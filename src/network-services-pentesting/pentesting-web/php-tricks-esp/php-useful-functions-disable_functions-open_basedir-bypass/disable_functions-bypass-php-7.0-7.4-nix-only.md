# disable_functions bypass - PHP 7.0-7.4 (*nix only)

{#include ../../../../../../../../home/runner/work/HackTricks-Feed/HackTricks-Feed/src/banners/hacktricks-training.md}

## PHP 7.0-7.4 (*nix only)

Below is the original proof-of-concept by **@mm0r1** that abuses a use-after-free (UAF) in `debug_backtrace()` (PHP bug #76047) to call `system()` even when it is present in `disable_functions`.
The technique still works on every vanilla build up to **7.4.2** (and the corresponding 7.3/7.2 branches) compiled without the February 2020 security fixes:

```php
<?php

# PHP 7.0-7.4 disable_functions bypass PoC (*nix only)
#
# Bug: https://bugs.php.net/bug.php?id=76047
# debug_backtrace() returns a reference to a variable
# that has been destroyed, causing a UAF vulnerability.
#
# This exploit should work on all PHP 7.0-7.4 versions
# released as of 30/01/2020.
#
# Author: https://github.com/mm0r1

pwn("uname -a");

function pwn($cmd) {
    /* … unchanged exploit … */
}
```

---

### Vulnerability overview (Bug #76047 – `debug_backtrace` UAF)

`debug_backtrace()` returned a reference to a zval that had already been freed. By carefully reallocating that slot, it is possible to fabricate a fake `closure` object and redirect execution flow to **any internal function pointer**—typically `zif_system`. Because the payload executes *inside* the PHP process, the `disable_functions` list is completely bypassed.

### Patch timeline

* **2020-02-20**  – Fixed in **PHP 7.4.3 / 7.3.15 / 7.2.30** (see changelog)
* Most mainstream Linux distributions back-ported the fix to their customised 7.4 packages during Q1 2020.

Running **≥7.4.3** therefore removes this specific UAF, but see the next section for more recent issues.

### Practical exploitation tips (2025)

* The exploit is *very* sensitive to heap layout. If it fails, increase `$n_alloc` or adjust the spray size.
* Modern distros compile PHP with **FORTIFY_SOURCE** and **ASLR**; for reliable exploitation disable PIE or brute-force heap addresses by leaking a pointer via `$abc`.
* In containerised environments you will normally need to escape chroots / namespaces after gaining code-execution; see the Linux-post-exploitation section of HackTricks.

### Detection & mitigation

1. Upgrade to **7.4.33-security** (or any version ≥7.4.3 with vendor back-ports).
2. Deploy additional kernel-level hardening (seccomp, AppArmor, SELinux) because memory-corruption bugs ignore `disable_functions`.
3. Monitor for suspicious combinations of `unset()`, `debug_backtrace()` and large heap sprays in requests.

---

## Other disable_functions bypasses affecting PHP 7.x (2021-2024)

While official support for 7.4 ended in **November 2022**, several high-profile memory-corruption bugs have been discovered *after* that deadline. When successfully exploited they provide an equivalent primitive to bug #76047 and can therefore bypass `disable_functions` as well.

### CVE-2021-21708 – UAF in `FILTER_VALIDATE_FLOAT`

A use-after-free occurs when `filter_var()` (or `filter_input()`) is invoked with `FILTER_VALIDATE_FLOAT` **and** the `min_range`/`max_range` options. If the validation fails the zval is freed while still referenced. The bug affects **7.4 < 7.4.28** (and early 8.x).

Minimal crash PoC:

```php
<?php
$options = [
    "options" => ["min_range" => 0, "max_range" => 0]
];
filter_var(3.14, FILTER_VALIDATE_FLOAT, $options);
?>
```

By replacing the freed chunk with a forged `zval`, attackers can hijack the virtual function table and pivot execution to `system()` in the same way as the backtrace exploit.

*Patched in PHP 7.4.28 (17 Feb 2022).* 

### Bug #81705 (2022) – Type confusion / UAF in `concat_function`

Concatenating an **array** into a string (e.g., `$x .= [0];`) raises a recoverable error. If a user-defined `set_error_handler()` mutates the variable inside that callback, `concat_function()` operates on a *different* zval, leading to UAF. The reporter demonstrated reliable EIP control on stock Ubuntu builds.

Simplified trigger:

```php
<?php
$var = [1,2,3];
set_error_handler(function() use (&$var) {
    $var = 0x41414141;   // Re-allocate freed zval
});
$var .= [0];
?>
```

*Fixed in PHP 7.4.33 / 8.0.23 / 8.1.10 (Sep 2022).* 

---

### Defensive recommendations (2025)

* **Do not rely on `disable_functions` for security isolation.** Any memory corruption entirely bypasses it.
* Keep legacy 7.4 deployments fully patched (latest upstream tag is **7.4.33**).
* Consider containerising PHP-FPM pools with seccomp filters that ban `execve`, or run them under a separate UID without shell access.
* If you *must* expose an un-patched build (e.g., for legacy code), run it behind an application firewall that inspects PHP payloads for the gadgets shown above.

## References

* [PHP 7.4.3 ChangeLog – Fix for bug #76047](https://www.php.net/ChangeLog-7.php#7.4.3)
* [NVD entry for CVE-2021-21708](https://nvd.nist.gov/vuln/detail/CVE-2021-21708)
* [PHP Bug #81705 – type confusion/UAF in `concat_function`](https://bugs.php.net/bug.php?id=81705)

{#include ../../../../../../../../home/runner/work/HackTricks-Feed/HackTricks-Feed/src/banners/hacktricks-training.md}
