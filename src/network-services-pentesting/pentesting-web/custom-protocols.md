# Custom UDP RPC Enumeration & File-Transfer Abuse

{{#include ../../banners/hacktricks-training.md}}

## Mapping proprietary RPC objects with Frida

Ältere Multiplayer-Titel integrieren oft hausgemachte RPC-Stacks auf UDP. In *Anno 1404: Venice* wird dies in `NetComEngine3.dll` über den Dispatcher `RMC_CallMessage` implementiert, der fünf Felder aus jedem Datagramm analysiert:

| Field | Purpose |
| --- | --- |
| `ID` | RPC-Verb (16-bit) |
| `Flags` | Transport-Modifikatoren (Zuverlässigkeit, Reihenfolge) |
| `Source` | Objekt-ID des Aufrufers |
| `TargetObject` | Instanz des Remote-Objekts |
| `Method` | Methodenindex innerhalb der Zielklasse |

Zwei Hilfsfunktionen – `ClassToMethodName()` und `TargetName()` – übersetzen rohe IDs in menschenlesbare Strings für das Logging. Durch brute-forcing von 24‑bit Objekt-IDs und 16‑bit Methoden-IDs und das Aufrufen dieser Helfer können wir die gesamte remote erreichbare Oberfläche ohne Traffic-Captures oder symbol leaks auflisten.

<details>
<summary>Frida-Oberflächen-Enumerator (gekürzt)</summary>
```javascript
'use strict';

const classToMethod = Module.getExportByName('NetComEngine3.dll', 'ClassToMethodName');
const targetName = Module.getExportByName('NetComEngine3.dll', 'TargetName');

function tryID(objID, methodID) {
const method = new NativeFunction(classToMethod, 'pointer', ['pointer', 'uint']);
const target = new NativeFunction(targetName, 'pointer', ['pointer']);
const buf = Memory.alloc(Process.pointerSize);
buf.writeU32(objID);
const m = method(buf, methodID);
if (!m.isNull()) {
const t = target(buf);
console.log(objID.toString(16), '=', t.readUtf16String());
console.log('  -', methodID, '=', m.readUtf16String());
}
}

for (let obj = 0; obj < 0x9000000; obj += 0x400000) {
for (let meth = 0; meth < 0x40; meth++) {
tryID(obj, meth);
}
}
```
</details>

Bei Ausführung von `frida -l explore-surface.js Addon.exe` wurde die vollständige RPC-Map ausgegeben, einschließlich des `Player`-Objekts (`0x7400000`) und seiner Dateiübertragungs-Verben `OnSendFileInit`, `OnSendFileData`, `OnReceivedFileData` und `OnCancelSendFile`. Derselbe Workflow gilt für jedes binäre Protokoll, das interne Reflection-Helper bereitstellt: fange den Dispatcher ab, brute-force die IDs und protokolliere, was die Engine bereits über jede aufrufbare Methode weiß.

### Tipps

- Nutze die Logging-Puffer der Engine (`WString::Format` in diesem Fall), um undokumentierte String-Codierungen nicht neu implementieren zu müssen.
- Gib `Flags` aus, um Zuverlässigkeitsfunktionen (ACK, resend requests) zu identifizieren, bevor du mit fuzzing beginnst; benutzerdefinierte UDP-Stacks verwerfen fehlerhafte Pakete oft stillschweigend.
- Speichere die enumerierte Map – sie dient als fuzzing-Korpus und macht offensichtlich, welche Objekte das Dateisystem, den Weltzustand oder das In-Game-Scripting manipulieren.

## Umgehung von Dateiübertragungs-RPCs

Die Synchronisation von Multiplayer-Spielständen verwendete einen Zwei-Paket-Handshake:

1. `OnSendFileInit` — überträgt den UTF‑16-Dateinamen, den der Client beim Speichern der eingehenden Nutzlast verwenden soll.
2. `OnSendFileData` — überträgt den rohen Dateiinhalt in Blöcken fester Größe.

Da der Server den Dateinamen kurz vor dem Senden über `ByteStreamWriteString()` serialisiert, kann ein Frida hook den Pointer auf ein traversal payload austauschen, während die Paketgrößen unverändert bleiben.

<details>
<summary>Filename swapper</summary>
```javascript
const writeStr = ptr('0x1003A250');
const ByteStreamWriteString = new NativeFunction(writeStr, 'pointer', ['pointer', 'pointer']);
const evil = Memory.allocUtf16String('..\\..\\..\\..\\Sauvegarde.sww');

Interceptor.attach(writeStr, {
onEnter(args) {
const src = args[1].readPointer();
const value = src.readUtf16String();
if (value && value.indexOf('Sauvegarde.sww') !== -1) {
args[1].writePointer(evil);
}
}
});
```
</details>

Die Opfer-Clients führten keinerlei Sanitisierung durch und schrieben das empfangene Save an jeden vom feindlichen Host angegebenen Pfad, z. B. in `C:\User\user` statt in den vorgesehenen `...\Savegames\MPShare`-Baum. Bei Windows-Installationen von Anno 1404 ist das Spielverzeichnis für alle schreibbar, wodurch die Traversal-Schwachstelle sofort zu einer beliebigen Datei-Schreibprimitive wird:

- **Drop DLLs** for classic search-order hijacking on next launch, or
- **Overwrite asset archives** (RDA files) so that weaponized models, textures, or scripts are loaded live during the same session.

### Verteidigen / Angreifen anderer Ziele

- Suche nach RPC-Verben namens `SendFile`, `Upload`, `ShareSave` usw., und fange den Serialisierungs-Helfer ab, der für Dateinamen oder Zielverzeichnisse zuständig ist.
- Selbst wenn Dateinamen auf Länge geprüft werden, vergessen viele Stacks, `..\` oder gemischte `/` vs `\`-Sequenzen zu kanonisieren; brute-force alle Trenner.
- Wenn der Empfänger Dateien unter dem Game-Installationspfad ablegt, überprüfe ACLs mit `icacls`, um zu bestätigen, ob ein unprivilegierter Benutzer dort Code ablegen kann.

## Path-Traversal zur Ausführung von Assets ausnutzen

Sobald du beliebige Bytes hochladen kannst, ersetze ein häufig geladenes Asset:

1. **Unpack the archive.** RDA archives are DEFLATE-based containers whose metadata is optionally XOR-obfuscated with `srand(0xA2C2A)` seeded streams. Tools like [RDAExplorer](https://github.com/lysanntranvouez/RDAExplorer) packen die Archive nach Änderungen wieder ein.
2. **Inject a malicious `.gr2`.** Die trojanisierte Granny-3D-Datei enthält den Relocation-Exploit, der `SectionContentArray` überschreibt und durch eine zweistufige Relocation-Sequenz einen beliebigen 4-Byte-Write in `granny2.dll` ermöglicht.
3. **Hijack allocator callbacks.** Mit deaktiviertem ASLR und ausgeschaltetem DEP leitet das Ersetzen der `malloc/free`-Funktionszeiger in `granny2.dll` die nächste Allocation auf deinen Shellcode um und ermöglicht sofortige RCE, ohne dass das Opfer das Spiel neu starten muss.

Dieses Muster lässt sich auf jeden Titel übertragen, der strukturierte Assets aus binären Archiven streamt: Kombiniere RPC-Level-Traversal zur Zustellung mit unsicherer Relocation-Verarbeitung zur Codeausführung.

## References

- [Synacktiv – Exploiting Anno 1404](https://www.synacktiv.com/publications/exploiting-anno-1404.html)
- [RDA File Format notes](https://github.com/lysanntranvouez/RDAExplorer/wiki/RDA-File-Format)

{{#include ../../banners/hacktricks-training.md}}
