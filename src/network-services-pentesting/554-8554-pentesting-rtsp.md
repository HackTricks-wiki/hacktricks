# 554,8554 - Pentesting RTSP

{{#include ../banners/hacktricks-training.md}}

## Información básica

De [wikipedia](https://en.wikipedia.org/wiki/Real_Time_Streaming_Protocol):

> El **Real Time Streaming Protocol** (**RTSP**) es un protocolo de control de red diseñado para su uso en sistemas de entretenimiento y comunicaciones para controlar servidores de medios en streaming. El protocolo se utiliza para establecer y controlar sesiones de medios entre puntos finales. Los clientes de servidores multimedia emiten comandos estilo VHS, como reproducir, grabar y pausar, para facilitar el control en tiempo real del streaming de medios desde el servidor hacia un cliente (video bajo demanda) o desde un cliente hacia el servidor (grabación de voz).
>
> La transmisión de los datos en streaming en sí no es una tarea de RTSP. La mayoría de los servidores RTSP usan el Real-time Transport Protocol (RTP) junto con el Real-time Control Protocol (RTCP) para la entrega de flujos de medios. Sin embargo, algunos proveedores implementan protocolos de transporte propietarios. El software de servidor RTSP de RealNetworks, por ejemplo, también utilizaba el RealNetworks' propietario Real Data Transport (RDT).

**Puertos por defecto:** 554,8554
```
PORT    STATE SERVICE
554/tcp open  rtsp
```
## Detalles clave

**RTSP** es similar a HTTP pero diseñado específicamente para transmisión de medios. Está definido en una especificación sencilla que se puede encontrar aquí:

[RTSP – RFC2326](https://tools.ietf.org/html/rfc2326)

Los dispositivos pueden permitir acceso **sin autenticación** o **con autenticación**. Para comprobarlo, se envía una petición "DESCRIBE". Un ejemplo básico se muestra a continuación:

`DESCRIBE rtsp://<ip>:<port> RTSP/1.0\r\nCSeq: 2`

Recuerda, el formato correcto incluye un doble "\r\n" para una respuesta consistente. Una respuesta "200 OK" indica acceso **sin autenticación**, mientras que "401 Unauthorized" indica que se necesita autenticación, revelando si se requiere **Basic** o **Digest authentication**.

Para la **Basic authentication**, codificas el nombre de usuario y la contraseña en base64 y lo incluyes en la petición así:

`DESCRIBE rtsp://<ip>:<port> RTSP/1.0\r\nCSeq: 2\r\nAuthorization: Basic YWRtaW46MTIzNA==`

Este ejemplo usa "admin" y "1234" como credenciales. Aquí hay un **Python script** para enviar dicha petición:
```python
import socket
req = "DESCRIBE rtsp://<ip>:<port> RTSP/1.0\r\nCSeq: 2\r\nAuthorization: Basic YWRtaW46MTIzNA==\r\n\r\n"
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(("192.168.1.1", 554))
s.sendall(req)
data = s.recv(1024)
print(data)
```
**Basic authentication** es más simple y preferida. **Digest authentication** requiere un manejo cuidadoso de los detalles de autenticación proporcionados en la respuesta "401 Unauthorized".

Esta visión general simplifica el proceso de acceso a flujos RTSP, centrándose en **Basic authentication** por su simplicidad y practicidad en los intentos iniciales.

## Enumeración

Vamos a recopilar información sobre los métodos válidos y las URLs soportadas, e intentar un brute-force para acceder al contenido (si es necesario).
```bash
nmap -sV --script "rtsp-*" -p <PORT> <IP>
```
#### Visualizar la transmisión RTSP con [ffplay](https://ffmpeg.org/ffplay.html)
Una vez que hayas descubierto una ruta RTSP válida (p. ej., `/mpeg4`, `/live.sdp`) y hayas confirmado el acceso (sin autenticación o con credenciales), puedes usar `ffplay` para reproducir la transmisión:
```bash
ffplay -rtsp_transport tcp rtsp://<IP>/mpeg4 -x 2560 -y 1440
```
- `-rtsp_transport tcp`: Usa TCP en lugar de UDP para un streaming más fiable
- `-x`, `-y`: flags opcionales para controlar la resolución de vídeo
- Reemplaza `<IP>` y la ruta según sea necesario

### [Brute Force](../generic-hacking/brute-force.md#rtsp)

### **Otros programas útiles**

To bruteforce: [https://github.com/Tek-Security-Group/rtsp_authgrinder](https://github.com/Tek-Security-Group/rtsp_authgrinder)

[**Cameradar**](https://github.com/Ullaakut/cameradar)

- Detectar hosts RTSP abiertos en cualquier objetivo accesible
- Obtener su información pública (nombre de host, puerto, modelo de cámara, etc.)
- Lanzar dictionary attacks automatizados para obtener la ruta del stream (por ejemplo /live.sdp)
- Lanzar dictionary attacks automatizados para obtener el usuario y la contraseña de las cámaras
- Generar miniaturas a partir de ellos para comprobar si los streams son válidos y tener una vista previa rápida de su contenido
- Intentar crear una pipeline de Gstreamer para comprobar si están codificados correctamente
- Imprimir un resumen de toda la información que Cameradar pudo obtener

### Ver también

{{#ref}}
32100-udp-pentesting-pppp-cs2-p2p-cameras.md
{{#endref}}

## Referencias

- [https://en.wikipedia.org/wiki/Real_Time_Streaming_Protocol](https://en.wikipedia.org/wiki/Real_Time_Streaming_Protocol)
- [http://badguyfu.net/rtsp-brute-forcing-for-fun-and-naked-pictures/](http://badguyfu.net/rtsp-brute-forcing-for-fun-and-naked-pictures/)
- [https://github.com/Ullaakut/cameradar](https://github.com/Ullaakut/cameradar)

{{#include ../banners/hacktricks-training.md}}
