# SMTP Smuggling

{{#include ../../banners/hacktricks-training.md}}

## Informazioni di base

This type of vulnerability was [**originally discovered in this post**](https://sec-consult.com/blog/detail/smtp-smuggling-spoofing-e-mails-worldwide/) were it's explained that It's possible to **exploit discrepancies in how the SMTP protocol is interpreted** when finalising an email, allowing an attacker to smuggle more emails in the body of the legit one, allowing to impersonate other users of the affected domain (such as admin@outlook.com) bypassing defenses such as SPF.

### Perché

This is because in the SMTP protocol, the **data of the message** to be sent in the email is controlled by a user (attacker) which could send specially crafted data abusing differences in parsers that will smuggle extra emails in the receptor. Take a look to this illustrated example from the original post:

<figure><img src="../../images/image (8) (1) (1) (1) (1).png" alt=""><figcaption><p><a href="https://sec-consult.com/fileadmin/user_upload/sec-consult/Dynamisch/Blogartikel/2023_12/SMTP_Smuggling-Overview__09_.png">https://sec-consult.com/fileadmin/user_upload/sec-consult/Dynamisch/Blogartikel/2023_12/SMTP_Smuggling-Overview__09_.png</a></p></figcaption></figure>

### Come

In order to exploit this vulnerability an attacker needs to send some data that the **Outbound SMPT server thinks that it's just 1 email but the Inbound SMTP server thinks that there are several emails**.

The researchers discovered that different **Inboud servers considers different characters as the end of the data** of the email message that Outbound servers doesn't.\
For example, a regular end of the data is `\r\n.\r`. But if the Inbound SMTP server also supports `\n.`, an attacker could just add **that data in his email and start indicating the SMTP commands** of a new ones to smuggle it just like in the previous image.

Ovviamente, questo può funzionare solo se l'**Outbound SMTP server non tratta quella sequenza** come fine del DATA, perché in tal caso vedrebbe 2 email invece che 1: alla base si sfrutta quindi una desincronizzazione fra parser.

Dati di desincronizzazione potenziali:

- `\n.`
- `\n.\r`

Nota anche che lo SPF viene bypassato perché se smuggli un'email da `admin@outlook.com` dentro un'email da `user@outlook.com`, **il mittente rimane comunque `outlook.com`.**

---

## Checklist dell'attaccante (quali condizioni devono sussistere?)

Per smugglaare con successo una seconda email, in genere serve:

- Un outbound server A attraverso cui puoi inviare (spesso con credenziali valide) che inoltri una sequenza di termine del DATA non standard senza modificarla. Molti servizi storicamente hanno inoltrato varianti come `\n.\r\n` o `\n.\n`.
- Un receiving server B che interpreterà quella sequenza non standard come fine del DATA e poi parserà ciò che segue come nuovi comandi SMTP (MAIL/RCPT/DATA...).
- Outbound deve realmente inviare con `DATA` (non `BDAT`). Se A supporta CHUNKING/BDAT, lo smuggling funziona solo se ricade su DATA (es. B non pubblicizza CHUNKING), altrimenti BDAT con lunghezza elimina l'ambiguità.
- PIPELINING non è obbligatorio ma aiuta a nascondere i comandi iniettati in una singola scrittura TCP così dispositivi intermedi non si risincronizzano.

Varianti comuni di fine‑DATA da testare (dipendono dal receiver):

- `\n.\n`
- `\n.\r\n`
- `\r.\r\n`
- `\r\n.\r` (CR finale "nudo")

Nota: Quello che funziona è l'intersezione di “ciò che A inoltra” ∩ “ciò che B accetta”.

---

## Esempio di sfruttamento manuale (sessione singola)

The following shows the idea using a raw STARTTLS SMTP session. After the first DATA block we insert a non‑standard terminator, then another SMTP dialog that the receiving server may treat as a new message.

<details>
<summary>Sessione di smuggling manuale (STARTTLS)</summary>
```
$ openssl s_client -starttls smtp -crlf -connect smtp.example.com:587
EHLO a.example
AUTH PLAIN <base64(\0user@example.com\0password)>
MAIL FROM:<user@example.com>
RCPT TO:<victim@target.com>
DATA
From: User <user@example.com>
To: victim <victim@target.com>
Subject: legit

hello A
\n.\r\nMAIL FROM:<admin@target.com>
RCPT TO:<victim@target.com>
DATA
From: Admin <admin@target.com>
To: victim <victim@target.com>
Subject: smuggled

hello B
\r\n.\r\n
```
</details>

Se A inoltra `\n.\r\n` e B lo accetta come end‑of‑DATA, il messaggio “hello B” può essere accettato come una seconda email da `admin@target.com` pur passando SPF (allineato con gli IP di A).

Tip: quando testi interattivamente, assicurati di usare `-crlf` in modo che OpenSSL preservi CRLF in quello che digiti.

---

## Automazione e scanner

- hannob/smtpsmug: invia un messaggio che termina con multiple sequenze end‑of‑DATA malformate per vedere cosa accetta il ricevente.
- Esempio: `./smtpsmug -s mail.target.com -p 25 -t victim@target.com`
- The‑Login/SMTP‑Smuggling‑Tools: scanner sia per il lato inbound che outbound più un SMTP server di analisi per vedere esattamente quali sequenze sopravvivono a un sender.
- Controllo rapido inbound: `python3 smtp_smuggling_scanner.py victim@target.com`
- Outbound via un relay: `python3 smtp_smuggling_scanner.py YOUR@ANALYSIS.DOMAIN --outbound-smtp-server smtp.relay.com --port 587 --starttls --sender-address you@relay.com --username you@relay.com --password '...'
`

Questi strumenti aiutano a mappare le coppie A→B dove lo smuggling funziona effettivamente.

---

## CHUNKING/BDAT vs DATA

- DATA usa un terminatore sentinel `<CR><LF>.<CR><LF>`; qualsiasi ambiguità nel modo in cui CR/LF vengono normalizzati o dot‑stuffed porta a desync.
- CHUNKING (BDAT) incornicia il corpo con una lunghezza in byte esatta e quindi previene lo smuggling classico. Tuttavia, se il sender ricade su DATA (perché il receiver non pubblicizza CHUNKING), lo smuggling classico diventa nuovamente possibile.

---

## Note sul software interessato e le correzioni (per il targeting)

- Postfix: prima della 3.9 il default tollerava bare LFs; a partire da 3.5.23/3.6.13/3.7.9/3.8.4 gli admin possono abilitare `smtpd_forbid_bare_newline`. La raccomandazione attuale è `smtpd_forbid_bare_newline = normalize` (3.8.5+/3.7.10+/3.6.14+/3.5.24+) oppure impostarlo su `reject` per una rigorosa applicazione RFC.
- Exim: corretto in 4.97.1 (e successive) per varianti che dipendevano da sequenze end‑of‑DATA miste quando si usa DATA. Le versioni più vecchie 4.97/4.96 possono essere sfruttabili a seconda di PIPELINING/CHUNKING.
- Sendmail: corretto in 8.18; le versioni più vecchie 8.17.x accettavano alcuni terminatori non standard.
- Diverse librerie/server (es. aiosmtpd prima della 1.4.5, alcuni vendor gateways, e specifici SaaS relays) avevano problemi simili; le versioni moderne tendono ad accettare DATA solo con il rigido `<CR><LF>.<CR><LF>`.

Usa gli scanner sopra per verificare il comportamento attuale; molti vendor hanno cambiato i default in early 2024–2025.

---

## Suggerimenti per red team ops

- Favorisci grandi sender commodity per A (storicamente Exchange Online, shared hosters, ecc.). Se continuano a inoltrare EOM non standard e sono presenti nello SPF della vittima, il MAIL FROM smuggled erediterà la loro reputation.
- Enumera le estensioni SMTP di B: banner `EHLO` per PIPELINING/CHUNKING; se CHUNKING manca hai maggiori possibilità con sender BDAT‑first. Combina con EOM malformati per sondare l'accettazione.
- Controlla gli header: il messaggio smuggled solitamente creerà una catena Received separata che inizia da B. DMARC spesso passerà perché il MAIL FROM è allineato con lo spazio IP di A.

---

## **Riferimenti**

- [https://sec-consult.com/blog/detail/smtp-smuggling-spoofing-e-mails-worldwide/](https://sec-consult.com/blog/detail/smtp-smuggling-spoofing-e-mails-worldwide/)
- [https://www.postfix.org/smtp-smuggling.html](https://www.postfix.org/smtp-smuggling.html)

{{#include ../../banners/hacktricks-training.md}}
