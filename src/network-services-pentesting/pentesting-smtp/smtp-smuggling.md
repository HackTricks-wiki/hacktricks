# SMTP Smuggling

{{#include ../../banners/hacktricks-training.md}}

## Temel Bilgiler

Bu tür bir zafiyet [**ilk olarak bu yazıda keşfedildi**](https://sec-consult.com/blog/detail/smtp-smuggling-spoofing-e-mails-worldwide/) ve burada, bir e‑posta sonlandırılırken SMTP protokolünün nasıl yorumlandığındaki tutarsızlıklardan **faydalanmanın mümkün olduğu**; saldırganın meşru bir e‑postanın gövdesine daha fazla e‑posta sokarak etkilenen alanın diğer kullanıcılarını (ör. admin@outlook.com) taklit edebileceği ve SPF gibi savunmaları atlatabileceği açıklanıyor.

### Neden

Bunun sebebi SMTP protokolünde gönderilecek mesajın **verilerinin** kullanıcı (saldırgan) tarafından kontrol edilmesidir; saldırgan, farklı parser’larda suistimal edilebilecek özel hazırlanmış veriler göndererek receptor’a ek e‑postalar smuggle edebilir. Orijinal yazıdan aşağıdaki görselleştirilmiş örneğe bakın:

<figure><img src="../../images/image (8) (1) (1) (1) (1).png" alt=""><figcaption><p><a href="https://sec-consult.com/fileadmin/user_upload/sec-consult/Dynamisch/Blogartikel/2023_12/SMTP_Smuggling-Overview__09_.png">https://sec-consult.com/fileadmin/user_upload/sec-consult/Dynamisch/Blogartikel/2023_12/SMTP_Smuggling-Overview__09_.png</a></p></figcaption></figure>

### Nasıl

Bu zafiyeti kullanmak için saldırganın, **Outbound SMPT server**'ın bunun sadece 1 e‑posta olduğunu düşünmesini sağlarken aynı verilerin **Inbound SMTP server** tarafından birkaç e‑posta olarak yorumlanmasını sağlaması gerekir.

Araştırmacılar, farklı **Inbound server'ların e‑posta mesaj verisinin sonu olarak farklı karakterleri kabul ettiğini** keşfettiler; outbound sunucuların kabul etmediği bazı sonlandırıcıları inbound sunucular kabul edebilir.\
Örneğin, normal veri sonlandırıcısı `\r\n.\r` iken, eğer Inbound SMTP server ayrıca `\n.`'i de destekliyorsa, saldırgan sadece o veriyi e‑postasına ekleyip yeni bir SMTP diyalogunun komutlarını başlatarak ikinci bir e‑postayı smuggle edebilir; önceki görseldeki gibi.

Elbette, bu yalnızca **Outbound SMTP server** da aynı veriyi mesaj verisinin sonu olarak işlemiyorsa işe yarar; aksi halde outbound 2 e‑posta görecektir ve burada sömürülen desenkronizasyon oluşur.

Olası desenkronizasyon verileri:

- `\n.`
- `\n.\r`

Ayrıca unutmayın ki SPF, eğer bir e‑postadan `admin@outlook.com` gibi bir adres smuggle edilirse atlanır çünkü **gönderen hala `outlook.com`** olarak kalır.

---

## Saldırganın kontrol listesi (hangi koşullar sağlanmalı?)

İkinci bir e‑postayı başarılı şekilde smuggle edebilmek için tipik olarak şunlar gerekir:

- Üzerinden gönderebileceğiniz bir outbound sunucu A (genelde geçerli kimlik bilgileriyle) ve bu sunucunun non‑standard end‑of‑DATA dizisini değiştirmeden iletmesi. Pek çok servis geçmişte `\n.\r\n` veya `\n.\n` gibi varyantları iletmiştir.
- Bu non‑standard diziyi DATA sonu olarak yorumlayıp sonrasını yeni SMTP komutları (MAIL/RCPT/DATA...) olarak parse eden bir receiving server B.
- Outbound gerçekte `DATA` ile göndermeli (BDAT ile değil). Eğer A CHUNKING/BDAT destekliyorsa, smuggling yalnızca DATA'ya geri dönülürse (ör. B CHUNKING'i ilan etmiyorsa) çalışır; aksi halde uzunluk çerçeveli BDAT belirsizliği engeller.
- PIPELINING gerekli değildir ama enjekte edilen komutları tek bir TCP write içinde gizleyerek ara cihazların yeniden senkronize olmasını zorlaştırır.

Test etmeye değer yaygın end‑of‑DATA varyantları (alıcıya bağlı):

- `\n.\n`
- `\n.\r\n`
- `\r.\r\n`
- `\r\n.\r` (sonda çıplak CR)

Not: Çalışan şey, “A'nın ilettikleri” ∩ “B'nin kabul ettikleri” kümesinin kesişimidir.

---

## Manuel exploitation örneği (tek oturum)

Aşağıda ham bir STARTTLS SMTP oturumu kullanılarak fikir gösteriliyor. İlk DATA bloğundan sonra non‑standard bir terminatör ekleyip, ardından alıcı sunucunun yeni bir mesaj olarak ele alabileceği başka bir SMTP diyaloğu ekliyoruz.

<details>
<summary>Manuel smuggling oturumu (STARTTLS)</summary>
```
$ openssl s_client -starttls smtp -crlf -connect smtp.example.com:587
EHLO a.example
AUTH PLAIN <base64(\0user@example.com\0password)>
MAIL FROM:<user@example.com>
RCPT TO:<victim@target.com>
DATA
From: User <user@example.com>
To: victim <victim@target.com>
Subject: legit

hello A
\n.\r\nMAIL FROM:<admin@target.com>
RCPT TO:<victim@target.com>
DATA
From: Admin <admin@target.com>
To: victim <victim@target.com>
Subject: smuggled

hello B
\r\n.\r\n
```
</details>

Eğer A `\n.\r\n` ile iletir ve B bunu end‑of‑DATA olarak kabul ederse, “hello B” mesajı admin@target.com adresinden ikinci bir e‑posta olarak kabul edilebilir ve SPF (A’nın IP’leriyle hizalanmış olarak) geçebilir.

Tip: Etkileşimli test yaparken, yazdıklarınızda OpenSSL’in CRLF’yi koruması için `-crlf` kullanıldığından emin olun.

---

## Otomasyon ve tarayıcılar

- hannob/smtpsmug: bir alıcının hangi dizileri kabul ettiğini görmek için birden fazla bozuk end‑of‑DATA dizisiyle biten bir mesaj gönderin.
- Örnek: `./smtpsmug -s mail.target.com -p 25 -t victim@target.com`
- The‑Login/SMTP‑Smuggling‑Tools: hem inbound hem outbound taraflar için tarayıcı ve gönderenin hangi dizileri geçirdiğini görmek üzere bir analiz SMTP sunucusu.
- Inbound hızlı kontrol: `python3 smtp_smuggling_scanner.py victim@target.com`
- Bir relay üzerinden outbound: `python3 smtp_smuggling_scanner.py YOUR@ANALYSIS.DOMAIN --outbound-smtp-server smtp.relay.com --port 587 --starttls --sender-address you@relay.com --username you@relay.com --password '...'
`

Bu araçlar, smuggling’in gerçekten çalıştığı A→B çiftlerini haritalamanıza yardımcı olur.

---

## CHUNKING/BDAT vs DATA

- DATA, sentinel sonlandırıcı olarak `<CR><LF>.<CR><LF>` kullanır; CR/LF’nin nasıl normalize edildiği veya dot‑stuffing yapıldığı konusundaki herhangi bir belirsizlik desenkronizasyona yol açar.
- CHUNKING (BDAT) gövdeyi kesin byte uzunluğuyla çerçeveler ve bu nedenle klasik smuggling’i engeller. Ancak, gönderici CHUNKING’i ilan etmediği için DATA’ya geri dönerse (fallback), klasik smuggling tekrar mümkün hale gelir.

---

## Etkilenen yazılımlar ve düzeltmeler hakkında notlar (hedefleme için)

- Postfix: 3.9 öncesinde varsayılan olarak çıplak LF’leri tolere ediyordu; 3.5.23/3.6.13/3.7.9/3.8.4 sürümlerinden itibaren yöneticiler `smtpd_forbid_bare_newline` etkinleştirebilir. Mevcut öneri `smtpd_forbid_bare_newline = normalize` (3.8.5+/3.7.10+/3.6.14+/3.5.24+) veya katı RFC uygulaması için `reject` olarak ayarlamaktır.
- Exim: DATA kullanıldığında karışık end‑of‑DATA dizilerine dayanan varyantlar için 4.97.1 (ve sonrası) sürümlerde düzeltildi. Eski 4.97/4.96 sürümleri PIPELINING/CHUNKING’e bağlı olarak istismar edilebilir olabilir.
- Sendmail: 8.18’de düzeltildi; eski 8.17.x bazı standart dışı sonlandırıcıları kabul ediyordu.
- Bazı kütüphaneler/sunucular (ör. aiosmtpd 1.4.5 öncesi, bazı vendor gateway’ler ve belirli SaaS relay’ler) benzer sorunlara sahipti; modern sürümler genellikle DATA’yı yalnızca katı `<CR><LF>.<CR><LF>` ile kabul eder.

Yukarıdaki tarayıcıları kullanarak mevcut davranışı doğrulayın; birçok vendor 2024–2025 başında varsayılanları değiştirdi.

---

## Red team operasyonları için ipuçları

- A için büyük, yaygın göndericileri tercih edin (tarihsel olarak Exchange Online, paylaşımlı hostlar vb.). Eğer hâlâ bazı standart dışı EOM’leri yönlendiriyor ve hedefin SPF’inde yer alıyorlarsa, smuggled MAIL FROM onların itibarını devralır.
- B’nin SMTP uzantılarını listeleyin: PIPELINING/CHUNKING için `EHLO` banner’ı; CHUNKING eksikse BDAT‑first gönderenlerden alma şansınız daha yüksektir. Kabulü test etmek için bozuk EOM’lerle birleştirin.
- Header’ları izleyin: smuggled mesaj genellikle B’de ayrı bir Received zinciri oluşturur. DMARC genellikle geçer çünkü MAIL FROM A’nın IP alanıyla hizalanır.

---

## **Referanslar**

- [https://sec-consult.com/blog/detail/smtp-smuggling-spoofing-e-mails-worldwide/](https://sec-consult.com/blog/detail/smtp-smuggling-spoofing-e-mails-worldwide/)
- [https://www.postfix.org/smtp-smuggling.html](https://www.postfix.org/smtp-smuggling.html)

{{#include ../../banners/hacktricks-training.md}}
