# SMTP Smuggling

{{#include ../../banners/hacktricks-training.md}}

## 기본 정보

이 취약점 유형은 [**원문 게시물에서 처음 발견됨**](https://sec-consult.com/blog/detail/smtp-smuggling-spoofing-e-mails-worldwide/)으로, 이메일을 마무리할 때 SMTP 프로토콜이 해석되는 방식의 불일치를 **악용해 합법적인 이메일 본문에 추가 이메일을 스머글링**할 수 있으며, 이를 통해 SPF 같은 방어를 우회하고 영향을 받는 도메인의 다른 사용자(예: admin@outlook.com)를 사칭할 수 있다고 설명합니다.

### 이유

이는 SMTP 프로토콜에서 이메일로 전송되는 **메시지의 데이터**가 사용자(공격자)에 의해 제어되며, 공격자가 파서 간의 차이를 악용해 수신 측에 추가 이메일을 스머글링할 수 있는 특수하게 조작된 데이터를 보낼 수 있기 때문입니다. 원문 게시물의 아래 예시를 확인해 보세요:

<figure><img src="../../images/image (8) (1) (1) (1) (1).png" alt=""><figcaption><p><a href="https://sec-consult.com/fileadmin/user_upload/sec-consult/Dynamisch/Blogartikel/2023_12/SMTP_Smuggling-Overview__09_.png">https://sec-consult.com/fileadmin/user_upload/sec-consult/Dynamisch/Blogartikel/2023_12/SMTP_Smuggling-Overview__09_.png</a></p></figcaption></figure>

### 작동 방식

이 취약점을 악용하려면 공격자는 **Outbound SMPT server는 단일 이메일로 인식하지만 Inbound SMTP server는 여러 개의 이메일로 인식**하도록 만드는 데이터를 전송해야 합니다.

연구진은 서로 다른 **Inboud servers가 이메일 메시지의 데이터 종료를 서로 다른 문자들로 간주**하는 반면 Outbound 서버는 그렇지 않은 경우가 있다는 것을 발견했습니다.\
예를 들어, 일반적인 데이터 종료는 `\r\n.\r` 입니다. 그러나 Inbound SMTP server가 `\n.` 도 지원한다면, 공격자는 단순히 해당 데이터를 이메일에 추가하고 새 이메일의 SMTP 명령을 시작해 이전 이미지와 같이 이를 스머글링할 수 있습니다.

물론, 이는 **Outbound SMTP server가 해당 데이터를 메시지의 종료로 처리하지 않아야**만 작동합니다. 그렇지 않으면 Outbound가 2개의 이메일을 보게 되어 동기화 문제를 악용할 수 없습니다.

잠재적 탈동기화 데이터:

- `\n.`
- `\n.\r`

또한, 만약 `user@outlook.com`에서 `admin@outlook.com`으로 보이는 이메일을 스머글링하면 SPF는 우회됩니다. 왜냐하면 **발신자는 여전히 `outlook.com`이기 때문**입니다.

---

## 공격자 체크리스트 (어떤 조건들이 필요합니까?)

두 번째 이메일을 성공적으로 스머글하려면 일반적으로 다음이 필요합니다:

- 통과시킬 수 있는 outbound 서버 A (종종 유효한 자격증명으로), 이 서버가 비표준 end‑of‑DATA 시퀀스를 변경하지 않고 전달할 것.
  많은 서비스들이 역사적으로 `\n.\r\n` 또는 `\n.\n` 같은 변형을 전달해 왔습니다.
- 해당 비표준 시퀀스를 end‑of‑DATA로 해석하고 그 이후를 새로운 SMTP 명령(MAIL/RCPT/DATA...)으로 파싱하는 수신 서버 B.
- Outbound가 실제로 `DATA`로 전송해야 함(BDAT가 아닌 경우). A가 CHUNKING/BDAT를 지원하면, B가 CHUNKING을 광고하지 않아 DATA로 폴백(fallback)하지 않는 한 스머글링이 작동하지 않습니다. 길이로 프레이밍된 BDAT는 모호성을 방지합니다.
- PIPELINING은 필수는 아니지만, 주입된 명령을 단일 TCP write로 숨기는 데 도움이 되어 중간 장치가 재동기화하지 못하게 합니다.

수신자에 따라 테스트해볼 만한 일반적인 end‑of‑DATA 변형:

- `\n.\n`
- `\n.\r\n`
- `\r.\r\n`
- `\r\n.\r` (끝에 CR만 있음)

참고: 실제로 동작하는 것은 “A가 전달하는 것” ∩ “B가 허용하는 것”의 교집합입니다.

---

## 수동 익스플로잇 예시 (단일 세션)

다음은 raw STARTTLS SMTP 세션을 사용해 개념을 보여줍니다. 첫 번째 DATA 블록 이후에 비표준 종료자를 삽입하고, 그 다음 수신 서버가 새 메시지로 처리할 수 있는 또 다른 SMTP 대화를 넣습니다.

<details>
<summary>수동 스머글링 세션 (STARTTLS)</summary>
```
$ openssl s_client -starttls smtp -crlf -connect smtp.example.com:587
EHLO a.example
AUTH PLAIN <base64(\0user@example.com\0password)>
MAIL FROM:<user@example.com>
RCPT TO:<victim@target.com>
DATA
From: User <user@example.com>
To: victim <victim@target.com>
Subject: legit

hello A
\n.\r\nMAIL FROM:<admin@target.com>
RCPT TO:<victim@target.com>
DATA
From: Admin <admin@target.com>
To: victim <victim@target.com>
Subject: smuggled

hello B
\r\n.\r\n
```
If A forwards `\n.\r\n` and B accepts it as end‑of‑DATA, message “hello B” may be accepted as a second email from `admin@target.com` while passing SPF (aligned with A’s IPs).
</details>

팁: 인터랙티브하게 테스트할 때는 OpenSSL이 입력한 CRLF를 보존하도록 `-crlf`를 사용해야 한다.

---

## Automation and scanners

- hannob/smtpsmug: 수신자가 무엇을 수락하는지 확인하기 위해 여러 개의 잘못된 end‑of‑DATA 시퀀스로 끝나는 메시지를 전송한다.
- 예: `./smtpsmug -s mail.target.com -p 25 -t victim@target.com`
- The‑Login/SMTP‑Smuggling‑Tools: 수신 및 발신 측 모두를 위한 스캐너와, 발신자 쪽에서 어떤 시퀀스가 실제로 살아남는지 정확히 확인할 수 있는 분석용 SMTP 서버를 포함한다.
- 인바운드 빠른 점검: `python3 smtp_smuggling_scanner.py victim@target.com`
- 릴레이를 통한 아웃바운드: `python3 smtp_smuggling_scanner.py YOUR@ANALYSIS.DOMAIN --outbound-smtp-server smtp.relay.com --port 587 --starttls --sender-address you@relay.com --username you@relay.com --password '...'
`

이 도구들은 smuggling이 실제로 작동하는 A→B 쌍을 매핑하는 데 도움을 준다.

---

## CHUNKING/BDAT vs DATA

- DATA는 센티넬 종료자 `<CR><LF>.<CR><LF>`를 사용한다; CR/LF가 어떻게 정규화되거나 dot‑stuffed되는지에 대한 어떤 모호성도 동기 불일치(desync)를 초래할 수 있다.
- CHUNKING (BDAT)은 본문을 정확한 바이트 길이로 프레이밍하여 고전적 smuggling을 방지한다. 그러나 수신자가 CHUNKING을 광고하지 않아 발신자가 DATA로 폴백하면 고전적 smuggling이 다시 가능해진다.

---

## Notes on affected software and fixes (for targeting)

- Postfix: 3.9 이전에는 기본값으로 bare LF를 허용했다; 3.5.23/3.6.13/3.7.9/3.8.4부터 관리자는 `smtpd_forbid_bare_newline`을 활성화할 수 있다. 현재 권장 사항은 `smtpd_forbid_bare_newline = normalize` (3.8.5+/3.7.10+/3.6.14+/3.5.24+) 또는 엄격한 RFC 적용을 위해 `reject`로 설정하는 것이다.
- Exim: DATA가 사용될 때 혼합된 end‑of‑DATA 시퀀스에 의존하는 변형은 4.97.1(및 이후)에서 수정되었다. 구형 4.97/4.96은 PIPELINING/CHUNKING에 따라 취약할 수 있다.
- Sendmail: 8.18에서 수정됨; 구버전 8.17.x는 일부 비표준 종료자를 수락했다.
- 다양한 라이브러리/서버(예: aiosmtpd 1.4.5 이전, 일부 벤더 게이트웨이 및 특정 SaaS 릴레이)에도 유사한 문제가 있었으며, 최신 버전들은 일반적으로 엄격한 `<CR><LF>.<CR><LF>`를 가진 DATA만 수락하는 경향이 있다.

위 스캐너들을 사용해 현재 동작을 확인하라; 많은 벤더가 2024–2025 초기에 기본값을 변경했다.

---

## Tips for red team ops

- A로는 대형 상용 발신자를 선호하라(역사적으로 Exchange Online, 공유 호스팅 등). 그들이 여전히 일부 비표준 EOM을 전달하고 피해자 SPF에 포함되어 있다면, smuggled한 MAIL FROM은 그들의 평판을 상속받게 된다.
- B의 SMTP 확장(extensions)을 열거하라: PIPELINING/CHUNKING 지원 여부는 `EHLO` 배너에서 확인한다; CHUNKING이 없으면 BDAT‑first 발신자로부터의 시도가 더 유리하다. 잘못된 EOM들과 결합해 수락 여부를 탐지하라.
- 헤더를 주시하라: smuggled된 메시지는 보통 B에서 시작하는 별도의 Received 체인을 생성한다. MAIL FROM이 A의 IP 공간과 정렬되므로 DMARC는 종종 통과한다.

---

## **참고자료**

- [https://sec-consult.com/blog/detail/smtp-smuggling-spoofing-e-mails-worldwide/](https://sec-consult.com/blog/detail/smtp-smuggling-spoofing-e-mails-worldwide/)
- [https://www.postfix.org/smtp-smuggling.html](https://www.postfix.org/smtp-smuggling.html)

{{#include ../../banners/hacktricks-training.md}}
