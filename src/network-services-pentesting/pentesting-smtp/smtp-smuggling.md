# SMTP Smuggling

{{#include ../../banners/hacktricks-training.md}}

## Informations de base

This type of vulnerability was [**originally discovered in this post**](https://sec-consult.com/blog/detail/smtp-smuggling-spoofing-e-mails-worldwide/) were it's explained that It's possible to **exploit discrepancies in how the SMTP protocol is interpreted** when finalising an email, allowing an attacker to smuggle more emails in the body of the legit one, allowing to impersonate other users of the affected domain (such as admin@outlook.com) bypassing defenses such as SPF.

### Pourquoi

Ceci s'explique par le fait que, dans le protocole SMTP, les **données du message** envoyées dans l'email sont contrôlées par un utilisateur (attaquant) qui peut envoyer des données spécialement conçues exploitant les différences entre parseurs, ce qui permettra de smuggler des emails supplémentaires chez le destinataire. Consultez cet exemple illustré issu du post original :

<figure><img src="../../images/image (8) (1) (1) (1) (1).png" alt=""><figcaption><p><a href="https://sec-consult.com/fileadmin/user_upload/sec-consult/Dynamisch/Blogartikel/2023_12/SMTP_Smuggling-Overview__09_.png">https://sec-consult.com/fileadmin/user_upload/sec-consult/Dynamisch/Blogartikel/2023_12/SMTP_Smuggling-Overview__09_.png</a></p></figcaption></figure>

### Comment

Pour exploiter cette vulnérabilité, un attaquant doit envoyer des données que le serveur Outbound SMTP considère comme une seule email, alors que le serveur Inbound SMTP considère qu'il s'agit de plusieurs e-mails.

Les chercheurs ont découvert que différents serveurs Inbound considèrent différents caractères comme la fin des données du message, que les serveurs Outbound ne considèrent pas nécessairement.\
Par exemple, une terminaison classique des données est `\r\n.\r`. Mais si le serveur Inbound SMTP accepte aussi `\n.`, un attaquant peut simplement ajouter **ces données dans son email et commencer à indiquer les commandes SMTP** d'un nouveau message à smuggler, comme dans l'image précédente.

Évidemment, cela ne fonctionne que si le **serveur Outbound SMTP ne considère pas non plus ces données** comme la fin du message, sinon il verra 2 emails au lieu d'un seul — au final c'est cette désynchronisation qui est exploitée dans la vulnérabilité.

Données de désynchronisation potentielles :

- `\n.`
- `\n.\r`

Notez aussi que le contournement de SPF s'explique par le fait que si vous smugglez un email depuis `admin@outlook.com` à partir d'un email envoyé par `user@outlook.com`, **l'expéditeur reste `outlook.com`.**

---

## Liste de contrôle de l'attaquant (quelles conditions doivent être remplies ?)

Pour smuggler avec succès un second email, vous avez généralement besoin de :

- Un serveur outbound A que vous pouvez utiliser pour envoyer (souvent avec des identifiants valides) qui transmettra une séquence de fin‑de‑DATA non standard sans la modifier. Historiquement, de nombreux services ont transmis des variantes comme `\n.\r\n` ou `\n.\n`.
- Un serveur récepteur B qui interprétera cette séquence non standard comme la fin du DATA puis analysera ce qui suit comme de nouvelles commandes SMTP (MAIL/RCPT/DATA...).
- Outbound doit réellement envoyer avec `DATA` (pas `BDAT`). Si A supporte CHUNKING/BDAT, le smuggling ne fonctionne que s'il retombe sur DATA (par ex., si B n'annonce pas CHUNKING), sinon le BDAT encadré par longueur empêche toute ambiguïté.
- PIPELINING n'est pas requis mais aide à masquer les commandes injectées dans un seul write TCP afin que les dispositifs intermédiaires ne se resynchronisent pas.

Variants courants de fin‑de‑DATA à tester (dépendant du récepteur) :

- `\n.\n`
- `\n.\r\n`
- `\r.\r\n`
- `\r\n.\r` (CR nu en fin)

Note : Ce qui fonctionne est l'intersection de “what A forwards” ∩ “what B accepts”.

---

## Exemple d'exploitation manuelle (session unique)

L'exemple suivant illustre le principe en utilisant une session SMTP STARTTLS brute. Après le premier bloc DATA, nous insérons un terminateur non standard, puis un autre dialogue SMTP que le serveur récepteur peut interpréter comme un nouveau message.

<details>
<summary>Manual smuggling session (STARTTLS)</summary>
```
$ openssl s_client -starttls smtp -crlf -connect smtp.example.com:587
EHLO a.example
AUTH PLAIN <base64(\0user@example.com\0password)>
MAIL FROM:<user@example.com>
RCPT TO:<victim@target.com>
DATA
From: User <user@example.com>
To: victim <victim@target.com>
Subject: legit

hello A
\n.\r\nMAIL FROM:<admin@target.com>
RCPT TO:<victim@target.com>
DATA
From: Admin <admin@target.com>
To: victim <victim@target.com>
Subject: smuggled

hello B
\r\n.\r\n
```
If A forwards `\n.\r\n` and B accepts it as end‑of‑DATA, message “hello B” may be accepted as a second email from `admin@target.com` while passing SPF (aligned with A’s IPs).
</details>

Tip: When testing interactively, ensure `-crlf` is used so OpenSSL preserves CRLF in what you type.

---

## Automatisation et scanners

- hannob/smtpsmug: envoie un message se terminant par plusieurs séquences de fin‑de‑DATA malformées pour voir ce que le récepteur accepte.
- Exemple: `./smtpsmug -s mail.target.com -p 25 -t victim@target.com`
- The‑Login/SMTP‑Smuggling‑Tools: scanner pour les côtés inbound et outbound ainsi qu'un serveur SMTP d'analyse pour voir exactement quelles séquences survivent côté sender.
- Inbound quick check: `python3 smtp_smuggling_scanner.py victim@target.com`
- Outbound via a relay: `python3 smtp_smuggling_scanner.py YOUR@ANALYSIS.DOMAIN --outbound-smtp-server smtp.relay.com --port 587 --starttls --sender-address you@relay.com --username you@relay.com --password '...'
`

Ces outils vous aident à cartographier les paires A→B où le smuggling fonctionne réellement.

---

## CHUNKING/BDAT vs DATA

- DATA uses a sentinel terminator `<CR><LF>.<CR><LF>`; any ambiguity in how CR/LF are normalized or dot‑stuffed leads to desync.
- CHUNKING (BDAT) frames the body with an exact byte length and therefore prevents classic smuggling. However, if the sender falls back to DATA (because the receiver doesn’t advertise CHUNKING), classic smuggling becomes possible again.

---

## Notes sur les logiciels affectés et les correctifs (pour le ciblage)

- Postfix: prior to 3.9 the default tolerated bare LFs; from 3.5.23/3.6.13/3.7.9/3.8.4 admins can enable `smtpd_forbid_bare_newline`. Current recommendation is `smtpd_forbid_bare_newline = normalize` (3.8.5+/3.7.10+/3.6.14+/3.5.24+) or set to `reject` for strict RFC enforcement.
- Exim: fixed in 4.97.1 (and later) for variants relying on mixed end‑of‑DATA sequences when DATA is used. Older 4.97/4.96 may be exploitable depending on PIPELINING/CHUNKING.
- Sendmail: fixed in 8.18; older 8.17.x accepted some non‑standard terminators.
- Various libraries/servers (e.g., aiosmtpd before 1.4.5, some vendor gateways, and specific SaaS relays) had similar issues; modern versions tend to accept DATA only with strict `<CR><LF>.<CR><LF>`.

Use the scanners above to verify current behavior; many vendors changed defaults in early 2024–2025.

---

## Tips for red team ops

- Favor large commodity senders for A (historically Exchange Online, shared hosters, etc.). If they still forward some non‑standard EOM and they’re in the victim’s SPF, your smuggled MAIL FROM will inherit their reputation.
- Enumerate B’s SMTP extensions: `EHLO` banner for PIPELINING/CHUNKING; if CHUNKING is missing you have a better chance from BDAT‑first senders. Combine with malformed EOMs to probe acceptance.
- Watch headers: the smuggled message will usually create a separate Received chain starting at B. DMARC will often pass because MAIL FROM aligns with A’s IP space.

---

## Références

- [https://sec-consult.com/blog/detail/smtp-smuggling-spoofing-e-mails-worldwide/](https://sec-consult.com/blog/detail/smtp-smuggling-spoofing-e-mails-worldwide/)
- [https://www.postfix.org/smtp-smuggling.html](https://www.postfix.org/smtp-smuggling.html)

{{#include ../../banners/hacktricks-training.md}}
