# SMTP Smuggling

{{#include ../../banners/hacktricks-training.md}}

## Informações básicas

This type of vulnerability was [**originally discovered in this post**](https://sec-consult.com/blog/detail/smtp-smuggling-spoofing-e-mails-worldwide/) were it's explained that It's possible to **exploit discrepancies in how the SMTP protocol is interpreted** when finalising an email, allowing an attacker to smuggle more emails in the body of the legit one, allowing to impersonate other users of the affected domain (such as admin@outlook.com) bypassing defenses such as SPF.

### Por que

Isso ocorre porque, no protocolo SMTP, os **dados da mensagem** a serem enviados no e-mail são controlados por um usuário (atacante) que pode enviar dados especialmente construídos abusando de diferenças nos parsers que irão contrabandear e-mails adicionais no receptor. Veja este exemplo ilustrado do post original:

<figure><img src="../../images/image (8) (1) (1) (1) (1).png" alt=""><figcaption><p><a href="https://sec-consult.com/fileadmin/user_upload/sec-consult/Dynamisch/Blogartikel/2023_12/SMTP_Smuggling-Overview__09_.png">https://sec-consult.com/fileadmin/user_upload/sec-consult/Dynamisch/Blogartikel/2023_12/SMTP_Smuggling-Overview__09_.png</a></p></figcaption></figure>

### Como

Para explorar essa vulnerabilidade, um atacante precisa enviar dados que o **servidor Outbound SMTP interpreta como apenas 1 e-mail, mas o servidor Inbound SMTP interpreta como vários e-mails**.

Os pesquisadores descobriram que diferentes **servidores Inbound consideram caracteres diferentes como fim dos dados** da mensagem de e-mail que os servidores Outbound não consideram.\
Por exemplo, um terminador regular é `\r\n.\r`. Mas se o servidor Inbound SMTP também aceitar `\n.`, um atacante poderia apenas adicionar **esses dados no seu e-mail e começar a indicar os comandos SMTP** de uma nova mensagem para contrabandeá‑la, como na imagem anterior.

Obviamente, isso só funcionará se o **servidor Outbound SMTP não tratar esses dados** também como fim dos dados da mensagem, porque nesse caso ele verá 2 e-mails em vez de apenas 1 — no fim das contas é essa dessincronização que está sendo explorada nessa vulnerabilidade.

Possíveis sequências de dessincronização:

- `\n.`
- `\n.\r`

Note também que o SPF é contornado porque se você contrabandear um e-mail de `admin@outlook.com` a partir de um e-mail de `user@outlook.com`, **o remetente ainda é `outlook.com`.**

---

## Checklist do atacante (quais condições devem ser satisfeitas?)

Para contrabandear com sucesso um segundo e-mail, normalmente você precisa de:

- Um servidor Outbound A pelo qual você possa enviar (frequentemente com credenciais válidas) que encaminhe uma sequência de fim‑de‑DATA não padronizada sem alterá‑la. Muitos serviços historicamente encaminharam variantes como `\n.\r\n` ou `\n.\n`.
- Um servidor receptor B que interpretará essa sequência não padronizada como fim‑de‑DATA e então analisará o que segue como novos comandos SMTP (MAIL/RCPT/DATA...).
- O Outbound deve realmente enviar com `DATA` (não `BDAT`). Se A suporta CHUNKING/BDAT, smuggling só funciona se houver fallback para DATA (por exemplo, B não anuncia CHUNKING), caso contrário o BDAT com comprimento evita ambiguidade.
- PIPELINING não é obrigatório mas ajuda a esconder os comandos injetados em uma única escrita TCP para que dispositivos intermediários não re-sincronizem.

Variantes comuns de fim‑de‑DATA que valem testar (dependendo do receptor):

- `\n.\n`
- `\n.\r\n`
- `\r.\r\n`
- `\r\n.\r` (bare CR at end)

Nota: O que funciona é a interseção de “o que A encaminha” ∩ “o que B aceita”.

---

## Exemplo de exploração manual (sessão única)

O seguinte mostra a ideia usando uma sessão SMTP STARTTLS bruta. Após o primeiro bloco DATA inserimos um terminador não padronizado, então outro diálogo SMTP que o servidor receptor pode tratar como uma nova mensagem.

<details>
<summary>Manual smuggling session (STARTTLS)</summary>
```
$ openssl s_client -starttls smtp -crlf -connect smtp.example.com:587
EHLO a.example
AUTH PLAIN <base64(\0user@example.com\0password)>
MAIL FROM:<user@example.com>
RCPT TO:<victim@target.com>
DATA
From: User <user@example.com>
To: victim <victim@target.com>
Subject: legit

hello A
\n.\r\nMAIL FROM:<admin@target.com>
RCPT TO:<victim@target.com>
DATA
From: Admin <admin@target.com>
To: victim <victim@target.com>
Subject: smuggled

hello B
\r\n.\r\n
```
If A forwards `\n.\r\n` and B accepts it as end‑of‑DATA, message “hello B” may be accepted as a second email from `admin@target.com` while passing SPF (aligned with A’s IPs).
</details>

Tip: When testing interactively, ensure `-crlf` is used so OpenSSL preserves CRLF in what you type.

---

## Automação e scanners

- hannob/smtpsmug: envia uma mensagem terminando com múltiplas sequências malformadas de end‑of‑DATA para ver o que um receptor aceita.
- Example: `./smtpsmug -s mail.target.com -p 25 -t victim@target.com`
- The‑Login/SMTP‑Smuggling‑Tools: scanner para os lados inbound e outbound, além de um servidor SMTP de análise para ver exatamente quais sequências sobrevivem a um remetente.
- Inbound quick check: `python3 smtp_smuggling_scanner.py victim@target.com`
- Outbound via a relay: `python3 smtp_smuggling_scanner.py YOUR@ANALYSIS.DOMAIN --outbound-smtp-server smtp.relay.com --port 587 --starttls --sender-address you@relay.com --username you@relay.com --password '...'
`

These tools help you map the A→B pairs where smuggling actually works.

---

## CHUNKING/BDAT vs DATA

- DATA uses a sentinel terminator `<CR><LF>.<CR><LF>`; any ambiguity in how CR/LF are normalized or dot‑stuffed leads to desync.
- CHUNKING (BDAT) frames the body with an exact byte length and therefore prevents classic smuggling. However, if the sender falls back to DATA (because the receiver doesn’t advertise CHUNKING), classic smuggling becomes possible again.

---

## Notas sobre software afetado e correções (para targeting)

- Postfix: prior to 3.9 the default tolerated bare LFs; from 3.5.23/3.6.13/3.7.9/3.8.4 admins can enable `smtpd_forbid_bare_newline`. Current recommendation is `smtpd_forbid_bare_newline = normalize` (3.8.5+/3.7.10+/3.6.14+/3.5.24+) or set to `reject` for strict RFC enforcement.
- Exim: fixed in 4.97.1 (and later) for variants relying on mixed end‑of‑DATA sequences when DATA is used. Older 4.97/4.96 may be exploitable depending on PIPELINING/CHUNKING.
- Sendmail: fixed in 8.18; older 8.17.x accepted some non‑standard terminators.
- Various libraries/servers (e.g., aiosmtpd before 1.4.5, some vendor gateways, and specific SaaS relays) had similar issues; modern versions tend to accept DATA only with strict `<CR><LF>.<CR><LF>`.

Use the scanners above to verify current behavior; many vendors changed defaults in early 2024–2025.

---

## Dicas para operações de red team

- Favor large commodity senders for A (historically Exchange Online, shared hosters, etc.). If they still forward some non‑standard EOM and they’re in the victim’s SPF, your smuggled MAIL FROM will inherit their reputation.
- Enumerate B’s SMTP extensions: `EHLO` banner for PIPELINING/CHUNKING; if CHUNKING is missing you have a better chance from BDAT‑first senders. Combine with malformed EOMs to probe acceptance.
- Watch headers: the smuggled message will usually create a separate Received chain starting at B. DMARC will often pass because MAIL FROM aligns with A’s IP space.

---

## **References**

- [https://sec-consult.com/blog/detail/smtp-smuggling-spoofing-e-mails-worldwide/](https://sec-consult.com/blog/detail/smtp-smuggling-spoofing-e-mails-worldwide/)
- [https://www.postfix.org/smtp-smuggling.html](https://www.postfix.org/smtp-smuggling.html)

{{#include ../../banners/hacktricks-training.md}}
