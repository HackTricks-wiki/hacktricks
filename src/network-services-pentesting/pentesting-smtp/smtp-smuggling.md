# SMTP Smuggling

{{#include ../../banners/hacktricks-training.md}}

## Podstawowe informacje

This type of vulnerability was [**originally discovered in this post**](https://sec-consult.com/blog/detail/smtp-smuggling-spoofing-e-mails-worldwide/) were it's explained that It's possible to **wykorzystać rozbieżności w sposobie interpretacji protokołu SMTP** podczas finalizowania wiadomości e-mail, co pozwala atakującemu wprowadzić do treści legalnej wiadomości dodatkowe e‑maile, umożliwiając podszycie się pod innych użytkowników dotkniętej domeny (np. admin@outlook.com) i obejście mechanizmów ochronnych takich jak SPF.

### Dlaczego

Dzieje się tak, ponieważ w protokole SMTP **dane wiadomości** wysyłanej w e‑mailu są kontrolowane przez użytkownika (atakującego), który może wysłać specjalnie spreparowane dane wykorzystujące różnice w parserach, które wprowadzą dodatkowe e‑maile po stronie odbiorcy. Zobacz ilustrację z oryginalnego wpisu:

<figure><img src="../../images/image (8) (1) (1) (1) (1).png" alt=""><figcaption><p><a href="https://sec-consult.com/fileadmin/user_upload/sec-consult/Dynamisch/Blogartikel/2023_12/SMTP_Smuggling-Overview__09_.png">https://sec-consult.com/fileadmin/user_upload/sec-consult/Dynamisch/Blogartikel/2023_12/SMTP_Smuggling-Overview__09_.png</a></p></figcaption></figure>

### Jak

Aby wykorzystać tę lukę, atakujący musi wysłać dane, które **serwer SMTP wychodzący (Outbound SMTP server) uważa za jedną wiadomość, natomiast serwer SMTP przychodzący (Inbound SMTP server) interpretuje jako wiele wiadomości**.

Badacze odkryli, że różne serwery przychodzące uznają różne znaki za koniec danych wiadomości, których serwery wychodzące nie uznają.\
Na przykład typowym zakończeniem danych jest `\r\n.\r`. Ale jeśli serwer przychodzący obsługuje również `\n.`, atakujący może po prostu dodać **ten ciąg do swojej wiadomości i zacząć umieszczać polecenia SMTP** rozpoczynające nową wiadomość, tak jak na powyższym obrazie.

Oczywiście, to zadziała tylko wtedy, gdy **serwer SMTP wychodzący nie traktuje tego ciągu** jako końca danych wiadomości; w przeciwnym razie zobaczy on 2 wiadomości zamiast jednej — to właśnie dezynchronizacja wykorzystywana w tej luce.

Potencjalne dane powodujące desynchronizację:

- `\n.`
- `\n.\r`

Zauważ też, że SPF jest obejściem, ponieważ jeśli wprowadzisz (smuggle) wiadomość od `admin@outlook.com` z wiadomości od `user@outlook.com`, **nadawca nadal pozostaje `outlook.com`.**

---

## Lista kontrolna atakującego (jakie warunki muszą być spełnione?)

Aby pomyślnie wprowadzić drugą wiadomość, zwykle potrzebujesz:

- serwera wychodzącego A, przez który możesz wysyłać (często z prawidłowymi poświadczeniami), który przekaże nie‑standardową sekwencję kończącą DATA bez zmian. Wiele usług historycznie przekazywało warianty takie jak `\n.\r\n` lub `\n.\n`.
- serwera odbierającego B, który zinterpretuje tę nie‑standardową sekwencję jako koniec DATA i następnie zanalizuje wszystko, co następuje, jako nowe polecenia SMTP (MAIL/RCPT/DATA...).
- serwer wychodzący musi faktycznie wysyłać przy użyciu `DATA` (nie `BDAT`). Jeśli A wspiera CHUNKING/BDAT, smuggling działa tylko wtedy, gdy nastąpi fallback do DATA (np. B nie reklamuje CHUNKING), w przeciwnym razie długość określona w BDAT eliminuje niejednoznaczność.
- PIPELINING nie jest wymagany, ale pomaga ukryć wstrzyknięte polecenia w jednym zapisie TCP, tak aby urządzenia pośrednie nie zresynchronizowały sesji.

Typowe warianty końca DATA warte przetestowania (zależne od odbiorcy):

- `\n.\n`
- `\n.\r\n`
- `\r.\r\n`
- `\r\n.\r` (goły CR na końcu)

Uwaga: Działa to tylko na przecięciu „co A przekazuje” ∩ „co B akceptuje”.

---

## Przykład ręcznego wykorzystania (jedna sesja)

Poniższe pokazuje pomysł z użyciem surowej sesji STARTTLS SMTP. Po pierwszym bloku DATA wstawiamy nie‑standardowy terminator, a potem kolejny dialog SMTP, który serwer odbierający może potraktować jako nową wiadomość.

<details>
<summary>Manual smuggling session (STARTTLS)</summary>
```
$ openssl s_client -starttls smtp -crlf -connect smtp.example.com:587
EHLO a.example
AUTH PLAIN <base64(\0user@example.com\0password)>
MAIL FROM:<user@example.com>
RCPT TO:<victim@target.com>
DATA
From: User <user@example.com>
To: victim <victim@target.com>
Subject: legit

hello A
\n.\r\nMAIL FROM:<admin@target.com>
RCPT TO:<victim@target.com>
DATA
From: Admin <admin@target.com>
To: victim <victim@target.com>
Subject: smuggled

hello B
\r\n.\r\n
```
Jeśli A przesyła `\n.\r\n`, a B zaakceptuje to jako koniec DATA, wiadomość “hello B” może zostać przyjęta jako drugi e-mail od `admin@target.com`, jednocześnie przechodząc SPF (zgodne z adresami IP A).
</details>

Tip: When testing interactively, ensure `-crlf` is used so OpenSSL preserves CRLF in what you type.

---

## Automation and scanners

- hannob/smtpsmug: send a message ending with multiple malformed end‑of‑DATA sequences to see what a receiver accepts.
- Example: `./smtpsmug -s mail.target.com -p 25 -t victim@target.com`
- The‑Login/SMTP‑Smuggling‑Tools: skaner zarówno dla ruchu przychodzącego, jak i wychodzącego oraz serwer SMTP do analizy, żeby zobaczyć dokładnie, które sekwencje przetrwają po stronie nadawcy.
- Inbound quick check: `python3 smtp_smuggling_scanner.py victim@target.com`
- Outbound via a relay: `python3 smtp_smuggling_scanner.py YOUR@ANALYSIS.DOMAIN --outbound-smtp-server smtp.relay.com --port 587 --starttls --sender-address you@relay.com --username you@relay.com --password '...'
`

These tools help you map the A→B pairs where smuggling actually works.

---

## CHUNKING/BDAT vs DATA

- DATA uses a sentinel terminator `<CR><LF>.<CR><LF>`; any ambiguity in how CR/LF are normalized or dot‑stuffed leads to desync.
- CHUNKING (BDAT) frames the body with an exact byte length and therefore prevents classic smuggling. However, if the sender falls back to DATA (because the receiver doesn’t advertise CHUNKING), classic smuggling becomes possible again.

---

## Notes on affected software and fixes (for targeting)

- Postfix: prior to 3.9 the default tolerated bare LFs; from 3.5.23/3.6.13/3.7.9/3.8.4 admins can enable `smtpd_forbid_bare_newline`. Current recommendation is `smtpd_forbid_bare_newline = normalize` (3.8.5+/3.7.10+/3.6.14+/3.5.24+) or set to `reject` for strict RFC enforcement.
- Exim: fixed in 4.97.1 (and later) for variants relying on mixed end‑of‑DATA sequences when DATA is used. Older 4.97/4.96 may be exploitable depending on PIPELINING/CHUNKING.
- Sendmail: fixed in 8.18; older 8.17.x accepted some non‑standard terminators.
- Various libraries/servers (e.g., aiosmtpd before 1.4.5, some vendor gateways, and specific SaaS relays) had similar issues; modern versions tend to accept DATA only with strict `<CR><LF>.<CR><LF>`.

Use the scanners above to verify current behavior; many vendors changed defaults in early 2024–2025.

---

## Wskazówki dla red team ops

- Preferuj dużych masowych nadawców dla A (historycznie Exchange Online, współdzieleni hosterzy itp.). Jeśli nadal przekazują jakieś niestandardowe EOM i znajdują się w SPF ofiary, twój przemycony MAIL FROM odziedziczy ich reputację.
- Wypisz rozszerzenia SMTP B: `EHLO` banner for PIPELINING/CHUNKING; if CHUNKING is missing you have a better chance from BDAT‑first senders. Combine with malformed EOMs to probe acceptance.
- Watch headers: the smuggled message will usually create a separate Received chain starting at B. DMARC will often pass because MAIL FROM aligns with A’s IP space.

---

## **References**

- [https://sec-consult.com/blog/detail/smtp-smuggling-spoofing-e-mails-worldwide/](https://sec-consult.com/blog/detail/smtp-smuggling-spoofing-e-mails-worldwide/)
- [https://www.postfix.org/smtp-smuggling.html](https://www.postfix.org/smtp-smuggling.html)

{{#include ../../banners/hacktricks-training.md}}
