# SMTP Smuggling

{{#include ../../banners/hacktricks-training.md}}

## Informazioni di base

Questo tipo di vulnerabilità è stato [**originariamente scoperto in questo post**](https://sec-consult.com/blog/detail/smtp-smuggling-spoofing-e-mails-worldwide/) dove viene spiegato che è possibile **sfruttare le discrepanze nell'interpretazione del protocollo SMTP** durante la finalizzazione di un'email, permettendo a un attaccante di contrabbandare più email nel corpo di quella legittima e di impersonare altri utenti del dominio interessato (ad esempio admin@outlook.com), bypassando difese come SPF.

### Perché

Questo avviene perché nel protocollo SMTP i **dati del messaggio** da inviare nell'email sono controllati da un utente (attaccante) che può inviare dati appositamente creati abusando delle differenze nei parser, i quali contrabbanderanno email aggiuntive nel destinatario. Dai un'occhiata a questo esempio illustrato tratto dal post originale:

<figure><img src="../../images/image (8) (1) (1) (1) (1).png" alt=""><figcaption><p><a href="https://sec-consult.com/fileadmin/user_upload/sec-consult/Dynamisch/Blogartikel/2023_12/SMTP_Smuggling-Overview__09_.png">https://sec-consult.com/fileadmin/user_upload/sec-consult/Dynamisch/Blogartikel/2023_12/SMTP_Smuggling-Overview__09_.png</a></p></figcaption></figure>

### Come

Per sfruttare questa vulnerabilità un attaccante deve inviare dei dati tali che il **server Outbound SMTP ritenga che si tratti di una sola email mentre il server Inbound SMTP ritenga che ci siano più email**.

I ricercatori hanno scoperto che diversi **server Inbound considerano caratteri diversi come fine dei dati** del messaggio email che i server Outbound non considerano.\
Per esempio, una terminazione normale dei dati è `\r\n.\r`. Ma se il server Inbound SMTP supporta anche `\n.`, un attaccante potrebbe semplicemente aggiungere **quelli dati nella sua email e iniziare a indicare i comandi SMTP** di nuovi messaggi da contrabbandare, proprio come nell'immagine precedente.

Ovviamente, questo può funzionare solo se il **server Outbound SMTP non tratta anch'esso questi dati** come fine dei dati del messaggio, perché in quel caso vedrebbe 2 email invece di una sola — in definitiva è questa desincronizzazione che viene sfruttata in questa vulnerabilità.

Dati potenzialmente utilizzabili per la desincronizzazione:

- `\n.`
- `\n.\r`

Nota anche che lo SPF viene bypassato perché se contrabbandi un'email da `admin@outlook.com` a partire da un'email di `user@outlook.com`, **il mittente è ancora `outlook.com`.**

---

## Checklist dell'attaccante (quali condizioni devono sussistere?)

Per contrabbandare con successo una seconda email, di solito sono necessari:

- Un server outbound A attraverso cui puoi inviare (spesso con credenziali valide) che inoltri una sequenza di fine‑DATA non standard senza modificarla. Molti servizi storicamente hanno inoltrato varianti come `\n.\r\n` o `\n.\n`.
- Un server ricevente B che interpreterà quella sequenza non standard come fine‑DATA e poi analizzerà quel che segue come nuovi comandi SMTP (MAIL/RCPT/DATA...).
- L'outbound deve effettivamente inviare con `DATA` (non con `BDAT`). Se A supporta CHUNKING/BDAT, lo smuggling funziona solo se ricade su DATA (es. se B non pubblicizza CHUNKING), altrimenti BDAT con framing a lunghezza previene ambiguità.
- PIPELINING non è richiesto ma aiuta a nascondere i comandi iniettati in una singola scrittura TCP in modo che i dispositivi intermedi non riescano a risincronizzarsi.

Varianti comuni di fine‑DATA che vale la pena testare (dipendono dal ricevente):

- `\n.\n`
- `\n.\r\n`
- `\r.\r\n`
- `\r\n.\r` (CR nudo alla fine)

Nota: Ciò che funziona è l'intersezione tra “ciò che A inoltra” ∩ “ciò che B accetta”.

---

## Esempio di sfruttamento manuale (sessione singola)

Quanto segue mostra l'idea usando una sessione SMTP STARTTLS raw. Dopo il primo blocco DATA inseriamo un terminatore non standard, poi un altro dialogo SMTP che il server ricevente può trattare come un nuovo messaggio.

<details>
<summary>Manual smuggling session (STARTTLS)</summary>
```
$ openssl s_client -starttls smtp -crlf -connect smtp.example.com:587
EHLO a.example
AUTH PLAIN <base64(\0user@example.com\0password)>
MAIL FROM:<user@example.com>
RCPT TO:<victim@target.com>
DATA
From: User <user@example.com>
To: victim <victim@target.com>
Subject: legit

hello A
\n.\r\nMAIL FROM:<admin@target.com>
RCPT TO:<victim@target.com>
DATA
From: Admin <admin@target.com>
To: victim <victim@target.com>
Subject: smuggled

hello B
\r\n.\r\n
```
Se A inoltra `\n.\r\n` e B lo accetta come end‑of‑DATA, il messaggio “hello B” può essere accettato come una seconda email da `admin@target.com` pur superando SPF (allineato con gli IP di A).
</details>

Suggerimento: quando testi interattivamente, assicurati di usare `-crlf` in modo che OpenSSL conservi CRLF in ciò che digiti.

---

## Automazione e scanner

- hannob/smtpsmug: invia un messaggio che termina con più sequenze end‑of‑DATA malformate per vedere cosa accetta il ricevente.
- Example: `./smtpsmug -s mail.target.com -p 25 -t victim@target.com`
- The‑Login/SMTP‑Smuggling‑Tools: scanner per entrambi i lati inbound e outbound più un server SMTP di analisi per vedere esattamente quali sequenze sopravvivono a un sender.
- Inbound quick check: `python3 smtp_smuggling_scanner.py victim@target.com`
- Outbound via a relay: `python3 smtp_smuggling_scanner.py YOUR@ANALYSIS.DOMAIN --outbound-smtp-server smtp.relay.com --port 587 --starttls --sender-address you@relay.com --username you@relay.com --password '...'
`

Questi strumenti aiutano a mappare le coppie A→B in cui lo smuggling funziona effettivamente.

---

## CHUNKING/BDAT vs DATA

- DATA usa un terminatore sentinel `<CR><LF>.<CR><LF>`; qualsiasi ambiguità nel modo in cui CR/LF vengono normalizzati o dot‑stuffed porta a desync.
- CHUNKING (BDAT) incapsula il corpo con una lunghezza esatta in byte e quindi previene lo smuggling classico. Tuttavia, se il sender ricade su DATA (perché il receiver non pubblicizza CHUNKING), lo smuggling classico diventa di nuovo possibile.

---

## Note sul software interessato e sulle patch (per il targeting)

- Postfix: prima della 3.9 il default tollerava bare LFs; dalla 3.5.23/3.6.13/3.7.9/3.8.4 gli admin possono abilitare `smtpd_forbid_bare_newline`. La raccomandazione attuale è `smtpd_forbid_bare_newline = normalize` (3.8.5+/3.7.10+/3.6.14+/3.5.24+) oppure impostarlo su `reject` per un'applicazione rigorosa della RFC.
- Exim: risolto in 4.97.1 (e versioni successive) per varianti che si basavano su sequenze end‑of‑DATA miste quando viene usato DATA. Le versioni più vecchie 4.97/4.96 possono essere sfruttabili a seconda di PIPELINING/CHUNKING.
- Sendmail: corretto in 8.18; le vecchie 8.17.x accettavano alcuni terminatori non standard.
- Varie librerie/server (es. aiosmtpd prima della 1.4.5, alcuni vendor gateway e specifici SaaS relays) avevano problemi simili; le versioni moderne tendono ad accettare DATA solo con il rigoroso `<CR><LF>.<CR><LF>`.

Usa gli scanner sopra per verificare il comportamento corrente; molti vendor hanno modificato i default all'inizio del 2024–2025.

---

## Consigli per operazioni di red team

- Preferisci grandi sender commodity per A (storicamente Exchange Online, shared hoster, ecc.). Se essi inoltrano ancora qualche EOM non standard e sono nello SPF della vittima, il tuo MAIL FROM smuggled erediterà la loro reputazione.
- Enumera le estensioni SMTP di B: banner `EHLO` per PIPELINING/CHUNKING; se CHUNKING manca hai maggiori possibilità con sender BDAT‑first. Combina con EOM malformati per sondare l'accettazione.
- Controlla gli header: il messaggio smuggled solitamente creerà una catena Received separata che inizia da B. DMARC spesso passerà perché MAIL FROM è allineato con lo spazio IP di A.

---

**Riferimenti**

- [https://sec-consult.com/blog/detail/smtp-smuggling-spoofing-e-mails-worldwide/](https://sec-consult.com/blog/detail/smtp-smuggling-spoofing-e-mails-worldwide/)
- [https://www.postfix.org/smtp-smuggling.html](https://www.postfix.org/smtp-smuggling.html)

{{#include ../../banners/hacktricks-training.md}}
