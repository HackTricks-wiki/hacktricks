# macOS Kernel Extensions & Debugging

{{#include ../../../banners/hacktricks-training.md}}

## Informa√ß√µes B√°sicas

As extens√µes do kernel (Kexts) s√£o **pacotes** com a extens√£o **`.kext`** que s√£o **carregados diretamente no espa√ßo do kernel do macOS**, fornecendo funcionalidade adicional ao sistema operacional principal.

### Status de descontinua√ß√£o & DriverKit / Extens√µes do Sistema
A partir do **macOS Catalina (10.15)**, a Apple marcou a maioria dos KPIs legados como *obsoletos* e introduziu os frameworks **Extens√µes do Sistema & DriverKit** que rodam em **espa√ßo do usu√°rio**. A partir do **macOS Big Sur (11)**, o sistema operacional *se recusar√° a carregar* kexts de terceiros que dependem de KPIs obsoletos, a menos que a m√°quina seja inicializada no modo **Seguran√ßa Reduzida**. No Apple Silicon, habilitar kexts tamb√©m requer que o usu√°rio:

1. Reinicie em **Recupera√ß√£o** ‚Üí *Utilit√°rio de Seguran√ßa de Inicializa√ß√£o*.
2. Selecione **Seguran√ßa Reduzida** e marque **‚ÄúPermitir gerenciamento de extens√µes do kernel por desenvolvedores identificados‚Äù**.
3. Reinicie e aprove o kext em **Configura√ß√µes do Sistema ‚Üí Privacidade & Seguran√ßa**.

Drivers em espa√ßo do usu√°rio escritos com DriverKit/Extens√µes do Sistema **reduzem drasticamente a superf√≠cie de ataque** porque falhas ou corrup√ß√£o de mem√≥ria s√£o confinadas a um processo isolado em vez do espa√ßo do kernel.

> üìù A partir do macOS Sequoia (15), a Apple removeu completamente v√°rios KPIs legados de rede e USB ‚Äì a √∫nica solu√ß√£o compat√≠vel para os fornecedores √© migrar para Extens√µes do Sistema.

### Requisitos

Obviamente, isso √© t√£o poderoso que √© **complicado carregar uma extens√£o do kernel**. Estes s√£o os **requisitos** que uma extens√£o do kernel deve atender para ser carregada:

- Ao **entrar no modo de recupera√ß√£o**, as **extens√µes do kernel devem ser permitidas** para serem carregadas:

<figure><img src="../../../images/image (327).png" alt=""><figcaption></figcaption></figure>

- A extens√£o do kernel deve ser **assinada com um certificado de assinatura de c√≥digo do kernel**, que s√≥ pode ser **concedido pela Apple**. Quem ir√° revisar em detalhes a empresa e os motivos pelos quais √© necess√°rio.
- A extens√£o do kernel tamb√©m deve ser **notarizada**, a Apple poder√° verific√°-la em busca de malware.
- Ent√£o, o usu√°rio **root** √© quem pode **carregar a extens√£o do kernel** e os arquivos dentro do pacote devem **pertencer ao root**.
- Durante o processo de upload, o pacote deve ser preparado em um **local protegido n√£o-root**: `/Library/StagedExtensions` (requer a concess√£o `com.apple.rootless.storage.KernelExtensionManagement`).
- Finalmente, ao tentar carreg√°-la, o usu√°rio [**receber√° um pedido de confirma√ß√£o**](https://developer.apple.com/library/archive/technotes/tn2459/_index.html) e, se aceito, o computador deve ser **reiniciado** para carreg√°-la.

### Processo de Carregamento

Em Catalina era assim: √â interessante notar que o processo de **verifica√ß√£o** ocorre em **espa√ßo do usu√°rio**. No entanto, apenas aplicativos com a concess√£o **`com.apple.private.security.kext-management`** podem **solicitar ao kernel que carregue uma extens√£o**: `kextcache`, `kextload`, `kextutil`, `kextd`, `syspolicyd`

1. O cli **`kextutil`** **inicia** o processo de **verifica√ß√£o** para carregar uma extens√£o
- Ele se comunicar√° com **`kextd`** enviando usando um **servi√ßo Mach**.
2. **`kextd`** verificar√° v√°rias coisas, como a **assinatura**
- Ele se comunicar√° com **`syspolicyd`** para **verificar** se a extens√£o pode ser **carregada**.
3. **`syspolicyd`** **pedir√°** ao **usu√°rio** se a extens√£o n√£o foi carregada anteriormente.
- **`syspolicyd`** relatar√° o resultado para **`kextd`**
4. **`kextd`** finalmente poder√° **dizer ao kernel para carregar** a extens√£o

Se **`kextd`** n√£o estiver dispon√≠vel, **`kextutil`** pode realizar as mesmas verifica√ß√µes.

### Enumera√ß√£o & gerenciamento (kexts carregados)

`kextstat` era a ferramenta hist√≥rica, mas est√° **obsoleta** nas vers√µes recentes do macOS. A interface moderna √© **`kmutil`**:
```bash
# List every extension currently linked in the kernel, sorted by load address
sudo kmutil showloaded --sort

# Show only third-party / auxiliary collections
sudo kmutil showloaded --collection aux

# Unload a specific bundle
sudo kmutil unload -b com.example.mykext
```
A sintaxe mais antiga ainda est√° dispon√≠vel para refer√™ncia:
```bash
# (Deprecated) Get loaded kernel extensions
kextstat

# (Deprecated) Get dependencies of the kext number 22
kextstat | grep " 22 " | cut -c2-5,50- | cut -d '(' -f1
```
`kmutil inspect` tamb√©m pode ser utilizado para **extrair o conte√∫do de uma Kernel Collection (KC)** ou verificar se um kext resolve todas as depend√™ncias de s√≠mbolo:
```bash
# List fileset entries contained in the boot KC
kmutil inspect -B /System/Library/KernelCollections/BootKernelExtensions.kc --show-fileset-entries

# Check undefined symbols of a 3rd party kext before loading
kmutil libraries -p /Library/Extensions/FancyUSB.kext --undef-symbols
```
## Kernelcache

> [!CAUTION]
> Mesmo que as extens√µes do kernel sejam esperadas em `/System/Library/Extensions/`, se voc√™ for para esta pasta, **n√£o encontrar√° nenhum bin√°rio**. Isso se deve ao **kernelcache** e, para reverter um `.kext`, voc√™ precisa encontrar uma maneira de obt√™-lo.

O **kernelcache** √© uma **vers√£o pr√©-compilada e pr√©-linkada do kernel XNU**, juntamente com **drivers** e **extens√µes de kernel** essenciais. Ele √© armazenado em um formato **compactado** e √© descompactado na mem√≥ria durante o processo de inicializa√ß√£o. O kernelcache facilita um **tempo de inicializa√ß√£o mais r√°pido** ao ter uma vers√£o pronta para execu√ß√£o do kernel e drivers cruciais dispon√≠veis, reduzindo o tempo e os recursos que seriam gastos carregando e vinculando dinamicamente esses componentes no momento da inicializa√ß√£o.

### Kernelcache Local

No iOS, ele est√° localizado em **`/System/Library/Caches/com.apple.kernelcaches/kernelcache`** no macOS voc√™ pode encontr√°-lo com: **`find / -name "kernelcache" 2>/dev/null`** \
No meu caso, no macOS, eu o encontrei em:

- `/System/Volumes/Preboot/1BAEB4B5-180B-4C46-BD53-51152B7D92DA/boot/DAD35E7BC0CDA79634C20BD1BD80678DFB510B2AAD3D25C1228BB34BCD0A711529D3D571C93E29E1D0C1264750FA043F/System/Library/Caches/com.apple.kernelcaches/kernelcache`

#### IMG4

O formato de arquivo IMG4 √© um formato de cont√™iner usado pela Apple em seus dispositivos iOS e macOS para **armazenar e verificar com seguran√ßa** componentes de firmware (como **kernelcache**). O formato IMG4 inclui um cabe√ßalho e v√°rias tags que encapsulam diferentes partes de dados, incluindo a carga √∫til real (como um kernel ou bootloader), uma assinatura e um conjunto de propriedades de manifesto. O formato suporta verifica√ß√£o criptogr√°fica, permitindo que o dispositivo confirme a autenticidade e integridade do componente de firmware antes de execut√°-lo.

Ele √© geralmente composto pelos seguintes componentes:

- **Carga √∫til (IM4P)**:
- Frequentemente compactada (LZFSE4, LZSS, ‚Ä¶)
- Opcionalmente criptografada
- **Manifesto (IM4M)**:
- Cont√©m Assinatura
- Dicion√°rio adicional de Chave/Valor
- **Informa√ß√µes de Restaura√ß√£o (IM4R)**:
- Tamb√©m conhecido como APNonce
- Impede a repeti√ß√£o de algumas atualiza√ß√µes
- OPCIONAL: Geralmente isso n√£o √© encontrado

Descompacte o Kernelcache:
```bash
# img4tool (https://github.com/tihmstar/img4tool)
img4tool -e kernelcache.release.iphone14 -o kernelcache.release.iphone14.e

# pyimg4 (https://github.com/m1stadev/PyIMG4)
pyimg4 im4p extract -i kernelcache.release.iphone14 -o kernelcache.release.iphone14.e
```
### Download

- [**KernelDebugKit Github**](https://github.com/dortania/KdkSupportPkg/releases)

No [https://github.com/dortania/KdkSupportPkg/releases](https://github.com/dortania/KdkSupportPkg/releases) √© poss√≠vel encontrar todos os kits de depura√ß√£o do kernel. Voc√™ pode baix√°-lo, mont√°-lo, abri-lo com a ferramenta [Suspicious Package](https://www.mothersruin.com/software/SuspiciousPackage/get.html), acessar a pasta **`.kext`** e **extrair**.

Verifique os s√≠mbolos com:
```bash
nm -a ~/Downloads/Sandbox.kext/Contents/MacOS/Sandbox | wc -l
```
- [**theapplewiki.com**](https://theapplewiki.com/wiki/Firmware/Mac/14.x)**,** [**ipsw.me**](https://ipsw.me/)**,** [**theiphonewiki.com**](https://www.theiphonewiki.com/)

√Äs vezes, a Apple libera **kernelcache** com **s√≠mbolos**. Voc√™ pode baixar alguns firmwares com s√≠mbolos seguindo os links nessas p√°ginas. Os firmwares conter√£o o **kernelcache** entre outros arquivos.

Para **extrair** os arquivos, comece mudando a extens√£o de `.ipsw` para `.zip` e **descompacte**.

Ap√≥s extrair o firmware, voc√™ obter√° um arquivo como: **`kernelcache.release.iphone14`**. Est√° no formato **IMG4**, voc√™ pode extrair as informa√ß√µes interessantes com:

[**pyimg4**](https://github.com/m1stadev/PyIMG4)**:**
```bash
pyimg4 im4p extract -i kernelcache.release.iphone14 -o kernelcache.release.iphone14.e
```
[**img4tool**](https://github.com/tihmstar/img4tool)**:**
```bash
img4tool -e kernelcache.release.iphone14 -o kernelcache.release.iphone14.e
```
### Inspecionando kernelcache

Verifique se o kernelcache possui s√≠mbolos com
```bash
nm -a kernelcache.release.iphone14.e | wc -l
```
Com isso, agora podemos **extrair todas as extens√µes** ou a **que voc√™ est√° interessado:**
```bash
# List all extensions
kextex -l kernelcache.release.iphone14.e
## Extract com.apple.security.sandbox
kextex -e com.apple.security.sandbox kernelcache.release.iphone14.e

# Extract all
kextex_all kernelcache.release.iphone14.e

# Check the extension for symbols
nm -a binaries/com.apple.security.sandbox | wc -l
```
## Vulnerabilidades recentes & t√©cnicas de explora√ß√£o

| Ano | CVE | Resumo |
|------|-----|---------|
| 2024 | **CVE-2024-44243** | Falha l√≥gica em **`storagekitd`** permitiu que um atacante *root* registrasse um pacote de sistema de arquivos malicioso que, em √∫ltima an√°lise, carregou um **kext n√£o assinado**, **contornando a Prote√ß√£o de Integridade do Sistema (SIP)** e permitindo rootkits persistentes. Corrigido no macOS 14.2 / 15.2.   |
| 2021 | **CVE-2021-30892** (*Shrootless*) | O daemon de instala√ß√£o com a autoriza√ß√£o `com.apple.rootless.install` poderia ser abusado para executar scripts p√≥s-instala√ß√£o arbitr√°rios, desativar o SIP e carregar kexts arbitr√°rios.  |

**Principais aprendizados para red-teamers**

1. **Procure por daemons autorizados (`codesign -dvv /path/bin | grep entitlements`) que interagem com Disk Arbitration, Installer ou Kext Management.**
2. **O abuso de contornos do SIP quase sempre concede a capacidade de carregar um kext ‚Üí execu√ß√£o de c√≥digo no kernel**.

**Dicas defensivas**

*Mantenha o SIP habilitado*, monitore invoca√ß√µes de `kmutil load`/`kmutil create -n aux` provenientes de bin√°rios n√£o-Apple e alerta sobre qualquer grava√ß√£o em `/Library/Extensions`. Eventos de Seguran√ßa de Endpoint `ES_EVENT_TYPE_NOTIFY_KEXTLOAD` fornecem visibilidade quase em tempo real.

## Depura√ß√£o do kernel macOS & kexts

O fluxo de trabalho recomendado pela Apple √© construir um **Kernel Debug Kit (KDK)** que corresponda √† vers√£o em execu√ß√£o e, em seguida, anexar **LLDB** por meio de uma sess√£o de rede **KDP (Kernel Debugging Protocol)**.

### Depura√ß√£o local de um p√¢nico em uma √∫nica execu√ß√£o
```bash
# Create a symbolication bundle for the latest panic
sudo kdpwrit dump latest.kcdata
kmutil analyze-panic latest.kcdata -o ~/panic_report.txt
```
### Depura√ß√£o remota ao vivo de outro Mac

1. Baixe + instale a vers√£o exata do **KDK** para a m√°quina alvo.
2. Conecte o Mac alvo e o Mac host com um cabo **USB-C ou Thunderbolt**.
3. No **alvo**:
```bash
sudo nvram boot-args="debug=0x100 kdp_match_name=macbook-target"
reboot
```
4. No **host**:
```bash
lldb
(lldb) kdp-remote "udp://macbook-target"
(lldb) bt  # get backtrace in kernel context
```
### Anexando LLDB a um kext carregado espec√≠fico
```bash
# Identify load address of the kext
ADDR=$(kmutil showloaded --bundle-identifier com.example.driver | awk '{print $4}')

# Attach
sudo lldb -n kernel_task -o "target modules load --file /Library/Extensions/Example.kext/Contents/MacOS/Example --slide $ADDR"
```
> ‚ÑπÔ∏è  KDP exp√µe apenas uma interface **somente leitura**. Para instrumenta√ß√£o din√¢mica, voc√™ precisar√° modificar o bin√°rio em disco, aproveitar o **hooking de fun√ß√£o do kernel** (por exemplo, `mach_override`) ou migrar o driver para um **hipervisor** para leitura/grava√ß√£o completa.

## Refer√™ncias

- DriverKit Security ‚Äì Apple Platform Security Guide
- Microsoft Security Blog ‚Äì *Analisando a CVE-2024-44243 bypass do SIP*

{{#include ../../../banners/hacktricks-training.md}}
