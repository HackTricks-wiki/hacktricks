# Rozszerzenia jƒÖdra macOS i Kernelcaches

{{#include ../../../banners/hacktricks-training.md}}

## Podstawowe informacje

Kernel extensions (Kexts) to pakiety z rozszerzeniem **`.kext`**, kt√≥re sƒÖ **≈Çadowane bezpo≈õrednio do przestrzeni jƒÖdra macOS**, dostarczajƒÖc dodatkowƒÖ funkcjonalno≈õƒá g≈Ç√≥wnemu systemowi operacyjnemu.

### Status przestarza≈Ço≈õci & DriverKit / System Extensions
PoczƒÖwszy od **macOS Catalina (10.15)** Apple oznaczy≈Ço wiƒôkszo≈õƒá starych KPI jako *deprecated* i wprowadzi≈Ço frameworki **System Extensions & DriverKit**, kt√≥re dzia≈ÇajƒÖ w **user-space**. Od **macOS Big Sur (11)** system operacyjny bƒôdzie *odmawia≈Ç ≈Çadowania* zewnƒôtrznych kext√≥w, kt√≥re polegajƒÖ na przestarza≈Çych KPI, chyba ≈ºe maszyna jest uruchomiona w trybie **Reduced Security**. Na Apple Silicon dodatkowo wymagane jest, aby u≈ºytkownik:

1. Uruchomi≈Ç ponownie do **Recovery** ‚Üí *Startup Security Utility*.
2. Wybra≈Ç **Reduced Security** i zaznaczy≈Ç **‚ÄúAllow user management of kernel extensions from identified developers‚Äù**.
3. Uruchomi≈Ç ponownie i zatwierdzi≈Ç kext w **System Settings ‚Üí Privacy & Security**.

Sterowniki u≈ºytkownika napisane z u≈ºyciem DriverKit/System Extensions znaczƒÖco **zmniejszajƒÖ powierzchniƒô ataku**, poniewa≈º awarie lub korupcja pamiƒôci sƒÖ ograniczone do sandboxowanego procesu, a nie przestrzeni jƒÖdra.

> üìù Od macOS Sequoia (15) Apple usunƒô≈Ço ca≈Çkowicie kilka starych KPI zwiƒÖzanych z sieciami i USB ‚Äì jedynym rozwiƒÖzaniem kompatybilnym w przysz≈Ço≈õci dla dostawc√≥w jest migracja do System Extensions.

### Wymagania

Oczywi≈õcie, to jest tak potƒô≈ºne, ≈ºe **≈Çadowanie rozszerzenia jƒÖdra jest skomplikowane**. Oto **wymagania**, kt√≥re rozszerzenie jƒÖdra musi spe≈Çniƒá, aby zostaƒá za≈Çadowane:

- Podczas **wej≈õcia w tryb recovery**, rozszerzenia jƒÖdra muszƒÖ byƒá **dozwolone** do ≈Çadowania:

<figure><img src="../../../images/image (327).png" alt=""><figcaption></figcaption></figure>

- Rozszerzenie jƒÖdra musi byƒá **podpisane certyfikatem podpisu kodu dla jƒÖdra (kernel code signing certificate)**, kt√≥ry mo≈ºe byƒá **przyznany tylko przez Apple**. Apple przeprowadzi szczeg√≥≈Çowy przeglƒÖd firmy i powod√≥w, dla kt√≥rych certyfikat jest potrzebny.
- Rozszerzenie jƒÖdra musi byƒá tak≈ºe **notarizowane**, Apple bƒôdzie mog≈Ço sprawdziƒá je pod kƒÖtem malware.
- Nastƒôpnie to u≈ºytkownik **root** mo≈ºe **za≈Çadowaƒá rozszerzenie jƒÖdra** i pliki wewnƒÖtrz pakietu muszƒÖ **nale≈ºeƒá do root**.
- Podczas procesu przesy≈Çania pakiet musi byƒá przygotowany w **chronionej lokalizacji nie-root**: `/Library/StagedExtensions` (wymaga uprawnienia `com.apple.rootless.storage.KernelExtensionManagement`).
- Wreszcie, przy pr√≥bie za≈Çadowania u≈ºytkownik [**otrzyma pro≈õbƒô o potwierdzenie**](https://developer.apple.com/library/archive/technotes/tn2459/_index.html) i, je≈õli zaakceptuje, komputer musi zostaƒá **uruchomiony ponownie**, aby za≈Çadowaƒá rozszerzenie.

### Proces ≈Çadowania

W Catalinie wyglƒÖda≈Ço to tak: interesujƒÖce jest to, ≈ºe proces **weryfikacji** odbywa siƒô w **userland**. Jednak tylko aplikacje z uprawnieniem **`com.apple.private.security.kext-management`** mogƒÖ **za≈ºƒÖdaƒá od jƒÖdra za≈Çadowania rozszerzenia**: `kextcache`, `kextload`, `kextutil`, `kextd`, `syspolicyd`

1. **`kextutil`** cli **rozpoczyna** proces **weryfikacji** przed za≈Çadowaniem rozszerzenia
- Komunikuje siƒô z **`kextd`** wysy≈ÇajƒÖc ≈ºƒÖdanie za pomocƒÖ **Mach service**.
2. **`kextd`** sprawdzi kilka rzeczy, takich jak **podpis**
- Bƒôdzie komunikowaƒá siƒô z **`syspolicyd`**, aby **sprawdziƒá**, czy rozszerzenie mo≈ºe zostaƒá **za≈Çadowane**.
3. **`syspolicyd`** **wy≈õwietli monit** u≈ºytkownikowi, je≈õli rozszerzenie nie by≈Ço wcze≈õniej ≈Çadowane.
- **`syspolicyd`** zg≈Çosi wynik do **`kextd`**
4. **`kextd`** ostatecznie bƒôdzie m√≥g≈Ç **powiedzieƒá jƒÖdru, aby za≈Çadowa≈Ço** rozszerzenie

Je≈õli **`kextd`** nie jest dostƒôpny, **`kextutil`** mo≈ºe wykonaƒá te same kontrole.

### Enumeracja i zarzƒÖdzanie (za≈Çadowane kexty)

`kextstat` by≈Ç historycznym narzƒôdziem, ale jest **deprecated** w nowszych wydaniach macOS. Nowoczesnym interfejsem jest **`kmutil`**:
```bash
# List every extension currently linked in the kernel, sorted by load address
sudo kmutil showloaded --sort

# Show only third-party / auxiliary collections
sudo kmutil showloaded --collection aux

# Unload a specific bundle
sudo kmutil unload -b com.example.mykext
```
Starsza sk≈Çadnia jest nadal dostƒôpna do wglƒÖdu:
```bash
# (Deprecated) Get loaded kernel extensions
kextstat

# (Deprecated) Get dependencies of the kext number 22
kextstat | grep " 22 " | cut -c2-5,50- | cut -d '(' -f1
```
`kmutil inspect` mo≈ºe byƒá r√≥wnie≈º u≈ºyty do **dump the contents of a Kernel Collection (KC)** lub do zweryfikowania, ≈ºe kext rozwiƒÖzuje wszystkie zale≈ºno≈õci symboli:
```bash
# List fileset entries contained in the boot KC
kmutil inspect -B /System/Library/KernelCollections/BootKernelExtensions.kc --show-fileset-entries

# Check undefined symbols of a 3rd party kext before loading
kmutil libraries -p /Library/Extensions/FancyUSB.kext --undef-symbols
```
## Kernelcache

> [!CAUTION]
> Nawet je≈õli rozszerzenia jƒÖdra oczekuje siƒô znale≈∫ƒá w `/System/Library/Extensions/`, je≈õli wejdziesz do tego folderu **nie znajdziesz ≈ºadnego pliku binarnego**. Dzieje siƒô tak z powodu **kernelcache** i aby wykonaƒá odwrotnƒÖ in≈ºynieriƒô jednego `.kext` musisz znale≈∫ƒá spos√≥b, by go uzyskaƒá.

The **kernelcache** is a **pre-compiled and pre-linked version of the XNU kernel**, along with essential device **drivers** and **kernel extensions**. It's stored in a **compressed** format and gets decompressed into memory during the boot-up process. The kernelcache facilitates a **faster boot time** by having a ready-to-run version of the kernel and crucial drivers available, reducing the time and resources that would otherwise be spent on dynamically loading and linking these components at boot time.

G≈Ç√≥wne zalety kernelcache to **szybko≈õƒá ≈Çadowania** oraz to, ≈ºe wszystkie modu≈Çy sƒÖ wstƒôpnie po≈ÇƒÖczone (brak op√≥≈∫nie≈Ñ przy ≈Çadowaniu). A po wstƒôpnym po≈ÇƒÖczeniu wszystkich modu≈Ç√≥w KXLD mo≈ºe zostaƒá usuniƒôty z pamiƒôci, wiƒôc **XNU cannot load new KEXTs.**

> [!TIP]
> The [https://github.com/dhinakg/aeota](https://github.com/dhinakg/aeota) tool decrypts Apple‚Äôs AEA (Apple Encrypted Archive / AEA asset) containers ‚Äî the encrypted container format Apple uses for OTA assets and some IPSW pieces ‚Äî and can produce the underlying .dmg/asset archive that you can then extract with the provided aastuff tools.

### Local Kerlnelcache

W iOS znajduje siƒô w **`/System/Library/Caches/com.apple.kernelcaches/kernelcache`** , natomiast w macOS mo≈ºesz go znale≈∫ƒá poleceniem: **`find / -name "kernelcache" 2>/dev/null`** \
W moim przypadku na macOS znalaz≈Çem go w:

- `/System/Volumes/Preboot/1BAEB4B5-180B-4C46-BD53-51152B7D92DA/boot/DAD35E7BC0CDA79634C20BD1BD80678DFB510B2AAD3D25C1228BB34BCD0A711529D3D571C93E29E1D0C1264750FA043F/System/Library/Caches/com.apple.kernelcaches/kernelcache`

Find also here the [**kernelcache of version 14 with symbols**](https://x.com/tihmstar/status/1295814618242318337?lang=en).

#### IMG4 / BVX2 (LZFSE) compressed

The IMG4 file format is a container format used by Apple in its iOS and macOS devices for securely **storing and verifying firmware** components (like **kernelcache**). The IMG4 format includes a header and several tags which encapsulate different pieces of data including the actual payload (like a kernel or bootloader), a signature, and a set of manifest properties. The format supports cryptographic verification, allowing the device to confirm the authenticity and integrity of the firmware component before executing it.

Zwykle sk≈Çada siƒô z nastƒôpujƒÖcych komponent√≥w:

- **Payload (IM4P)**:
  - Czƒôsto skompresowany (LZFSE4, LZSS, ‚Ä¶)
  - Opcjonalnie zaszyfrowany
- **Manifest (IM4M)**:
  - Zawiera Signature
  - Dodatkowy Key/Value dictionary
- **Restore Info (IM4R)**:
  - Znane tak≈ºe jako APNonce
  - Zapobiega replaying niekt√≥rych aktualizacji
  - OPTIONAL: Zwykle nie wystƒôpuje

Decompress the Kernelcache:
```bash
# img4tool (https://github.com/tihmstar/img4tool)
img4tool -e kernelcache.release.iphone14 -o kernelcache.release.iphone14.e

# pyimg4 (https://github.com/m1stadev/PyIMG4)
pyimg4 im4p extract -i kernelcache.release.iphone14 -o kernelcache.release.iphone14.e

# imjtool (https://newandroidbook.com/tools/imjtool.html)
imjtool _img_name_ [extract]

# disarm (you can use it directly on the IMG4 file) - [https://newandroidbook.com/tools/disarm.html](https://newandroidbook.com/tools/disarm.html)
disarm -L kernelcache.release.v57 # From unzip ipsw

# disamer (extract specific parts, e.g. filesets) - [https://newandroidbook.com/tools/disarm.html](https://newandroidbook.com/tools/disarm.html)
disarm -e filesets kernelcache.release.d23
```
#### Disarm ‚Äî symbole dla kernela

**`Disarm`** pozwala symbolicate funkcje z kernelcache przy u≈ºyciu matchers. Te matchers to po prostu proste regu≈Çy wzorc√≥w (linie tekstu), kt√≥re m√≥wiƒÖ disarm, jak rozpoznaƒá i auto-symbolicate funkcje, argumenty oraz panic/log strings wewnƒÖtrz binarki.

Czyli zasadniczo wskazujesz string, kt√≥rego u≈ºywa funkcja, a disarm go znajdzie i **symbolicate it**.
```bash
You can find some `xnu.matchers` in [https://newosxbook.com/tools/disarm.html](https://newosxbook.com/tools/disarm.html) in the **`Matchers`** section. You can also create your own matchers.

```bash
# Przejd≈∫ do /tmp/extracted gdzie disarm rozpakowa≈Ç filesets
disarm -e filesets kernelcache.release.d23 # Always extract to /tmp/extracted
cd /tmp/extracted
JMATCHERS=xnu.matchers disarm --analyze kernel.rebuilt  # Note that xnu.matchers is actually a file with the matchers
```

### Download

An **IPSW (iPhone/iPad Software)** is Apple‚Äôs firmware package format used for device restores, updates, and full firmware bundles. Among other things, it contains the **kernelcache**.

- [**KernelDebugKit Github**](https://github.com/dortania/KdkSupportPkg/releases)

In [https://github.com/dortania/KdkSupportPkg/releases](https://github.com/dortania/KdkSupportPkg/releases) it's possible to find all the kernel debug kits. You can download it, mount it, open it with [Suspicious Package](https://www.mothersruin.com/software/SuspiciousPackage/get.html) tool, access the **`.kext`** folder and **extract it**.

Check it for symbols with:

```bash
nm -a ~/Downloads/Sandbox.kext/Contents/MacOS/Sandbox | wc -l
```

- [**theapplewiki.com**](https://theapplewiki.com/wiki/Firmware/Mac/14.x)**,** [**ipsw.me**](https://ipsw.me/)**,** [**theiphonewiki.com**](https://www.theiphonewiki.com/)

Sometime Apple releases **kernelcache** with **symbols**. You can download some firmwares with symbols by following links on those pages. The firmwares will contain the **kernelcache** among other files.

To **extract** the kernel cache you can do:

```bash
# Zainstaluj narzƒôdzie ipsw
brew install blacktop/tap/ipsw

# Wyodrƒôbnij tylko kernelcache z IPSW
ipsw extract --kernel /path/to/YourFirmware.ipsw -o out/

# Powiniene≈õ otrzymaƒá co≈õ takiego:
#   out/Firmware/kernelcache.release.iPhoneXX
#   lub IMG4 payload: out/Firmware/kernelcache.release.iPhoneXX.im4p

# Je≈õli otrzymasz IMG4 payload:
ipsw img4 im4p extract out/Firmware/kernelcache*.im4p -o kcache.raw
```

Another option to **extract** the files start by changing the extension from `.ipsw` to `.zip` and **unzip** it.

After extracting the firmware you will get a file like: **`kernelcache.release.iphone14`**. It's in **IMG4** format, you can extract the interesting info with:

[**pyimg4**](https://github.com/m1stadev/PyIMG4)**:**

```bash
pyimg4 im4p extract -i kernelcache.release.iphone14 -o kernelcache.release.iphone14.e
```

[**img4tool**](https://github.com/tihmstar/img4tool)**:**

```bash
img4tool -e kernelcache.release.iphone14 -o kernelcache.release.iphone14.e
```

```bash
pyimg4 im4p extract -i kernelcache.release.iphone14 -o kernelcache.release.iphone14.e
```

[**img4tool**](https://github.com/tihmstar/img4tool)**:**

```bash
img4tool -e kernelcache.release.iphone14 -o kernelcache.release.iphone14.e
```

### Inspecting kernelcache

Check if the kernelcache has symbols with

```bash
nm -a kernelcache.release.iphone14.e | wc -l
```

With this we can now **extract all the extensions** or the **one you are interested in:**

```bash
# Wypisz wszystkie rozszerzenia
kextex -l kernelcache.release.iphone14.e
## Wyodrƒôbnij com.apple.security.sandbox
kextex -e com.apple.security.sandbox kernelcache.release.iphone14.e

# Wyodrƒôbnij wszystkie
kextex_all kernelcache.release.iphone14.e

# Sprawd≈∫ rozszerzenie pod kƒÖtem symboli
nm -a binaries/com.apple.security.sandbox | wc -l
```


## Recent vulnerabilities & exploitation techniques

| Year | CVE | Summary |
|------|-----|---------|
| 2024 | **CVE-2024-44243** | Logic flaw in **`storagekitd`** allowed a *root* attacker to register a malicious file-system bundle that ultimately loaded an **unsigned kext**, **bypassing System Integrity Protection (SIP)** and enabling persistent rootkits. Patched in macOS 14.2 / 15.2.   |
| 2021 | **CVE-2021-30892** (*Shrootless*) | Installation daemon with the entitlement `com.apple.rootless.install` could be abused to execute arbitrary post-install scripts, disable SIP and load arbitrary kexts.  |

**Take-aways for red-teamers**

1. **Look for entitled daemons (`codesign -dvv /path/bin | grep entitlements`) that interact with Disk Arbitration, Installer or Kext Management.**
2. **Abusing SIP bypasses almost always grants the ability to load a kext ‚Üí kernel code execution**.

**Defensive tips**

*Keep SIP enabled*, monitor for `kmutil load`/`kmutil create -n aux` invocations coming from non-Apple binaries and alert on any write to `/Library/Extensions`. Endpoint Security events `ES_EVENT_TYPE_NOTIFY_KEXTLOAD` provide near real-time visibility.

## Debugging macOS kernel & kexts

Apple‚Äôs recommended workflow is to build a **Kernel Debug Kit (KDK)** that matches the running build and then attach **LLDB** over a **KDP (Kernel Debugging Protocol)** network session.

### One-shot local debug of a panic

```bash
# Utw√≥rz pakiet symbolikacji dla najnowszego panic
sudo kdpwrit dump latest.kcdata
kmutil analyze-panic latest.kcdata -o ~/panic_report.txt
```

### Live remote debugging from another Mac

1. Download + install the exact **KDK** version for the target machine.
2. Connect the target Mac and the host Mac with a **USB-C or Thunderbolt cable**.
3. On the **target**:

```bash
sudo nvram boot-args="debug=0x100 kdp_match_name=macbook-target"
reboot
```

4. On the **host**:

```bash
lldb
(lldb) kdp-remote "udp://macbook-target"
(lldb) bt  # get backtrace in kernel context
```

### Attaching LLDB to a specific loaded kext

```bash
# Identify load address of the kext
ADDR=$(kmutil showloaded --bundle-identifier com.example.driver | awk '{print $4}')

# Attach
sudo lldb -n kernel_task -o "target modules load --file /Library/Extensions/Example.kext/Contents/MacOS/Example --slide $ADDR"
```

> ‚ÑπÔ∏è  KDP only exposes a **read-only** interface. For dynamic instrumentation you will need to patch the binary on-disk, leverage **kernel function hooking** (e.g. `mach_override`) or migrate the driver to a **hypervisor** for full read/write.

## References

- DriverKit Security ‚Äì Apple Platform Security Guide
- Microsoft Security Blog ‚Äì *Analyzing CVE-2024-44243 SIP bypass*

{{#include ../../../banners/hacktricks-training.md}}
