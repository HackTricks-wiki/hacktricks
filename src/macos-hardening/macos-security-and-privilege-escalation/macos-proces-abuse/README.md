# macOS Process Abuse

{{#include ../../../banners/hacktricks-training.md}}

## Processes Basic Information

एक प्रक्रिया एक चल रहे निष्पादन का उदाहरण है, हालाँकि प्रक्रियाएँ कोड नहीं चलाती हैं, ये थ्रेड हैं। इसलिए **प्रक्रियाएँ केवल चल रहे थ्रेड्स के लिए कंटेनर हैं** जो मेमोरी, डिस्क्रिप्टर्स, पोर्ट्स, अनुमतियाँ प्रदान करती हैं...

परंपरागत रूप से, प्रक्रियाएँ अन्य प्रक्रियाओं के भीतर शुरू की जाती थीं (PID 1 को छोड़कर) **`fork`** को कॉल करके, जो वर्तमान प्रक्रिया की एक सटीक प्रति बनाएगा और फिर **बच्ची प्रक्रिया** सामान्यतः **`execve`** को कॉल करेगी ताकि नए निष्पादन को लोड किया जा सके और इसे चलाया जा सके। फिर, **`vfork`** को पेश किया गया ताकि इस प्रक्रिया को बिना किसी मेमोरी कॉपी के तेज़ बनाया जा सके।\
फिर **`posix_spawn`** को पेश किया गया जो **`vfork`** और **`execve`** को एक कॉल में संयोजित करता है और फ्लैग स्वीकार करता है:

- `POSIX_SPAWN_RESETIDS`: प्रभावी आईडी को वास्तविक आईडी पर रीसेट करें
- `POSIX_SPAWN_SETPGROUP`: प्रक्रिया समूह संबंध सेट करें
- `POSUX_SPAWN_SETSIGDEF`: सिग्नल डिफ़ॉल्ट व्यवहार सेट करें
- `POSIX_SPAWN_SETSIGMASK`: सिग्नल मास्क सेट करें
- `POSIX_SPAWN_SETEXEC`: उसी प्रक्रिया में Exec करें (जैसे `execve` अधिक विकल्पों के साथ)
- `POSIX_SPAWN_START_SUSPENDED`: निलंबित शुरू करें
- `_POSIX_SPAWN_DISABLE_ASLR`: ASLR के बिना शुरू करें
- `_POSIX_SPAWN_NANO_ALLOCATOR:` libmalloc के नैनो आवंटक का उपयोग करें
- `_POSIX_SPAWN_ALLOW_DATA_EXEC:` डेटा सेगमेंट पर `rwx` की अनुमति दें
- `POSIX_SPAWN_CLOEXEC_DEFAULT`: exec(2) पर डिफ़ॉल्ट रूप से सभी फ़ाइल विवरण बंद करें
- `_POSIX_SPAWN_HIGH_BITS_ASLR:` ASLR स्लाइड के उच्च बिट्स को यादृच्छिक बनाएं

इसके अलावा, `posix_spawn` एक **`posix_spawnattr`** के एक ऐरे को निर्दिष्ट करने की अनुमति देता है जो उत्पन्न प्रक्रिया के कुछ पहलुओं को नियंत्रित करता है, और **`posix_spawn_file_actions`** को डिस्क्रिप्टर्स की स्थिति को संशोधित करने के लिए।

जब एक प्रक्रिया मरती है, तो यह **माता-पिता प्रक्रिया को लौटने का कोड भेजती है** (यदि माता-पिता मर गया, तो नया माता-पिता PID 1 है) सिग्नल `SIGCHLD` के साथ। माता-पिता को इस मान को प्राप्त करने के लिए `wait4()` या `waitid()` कॉल करना होगा और जब तक ऐसा नहीं होता, बच्चा एक ज़ोंबी स्थिति में रहता है जहाँ यह अभी भी सूचीबद्ध है लेकिन संसाधनों का उपभोग नहीं करता है।

### PIDs

PIDs, प्रक्रिया पहचानकर्ता, एक अद्वितीय प्रक्रिया की पहचान करते हैं। XNU में **PIDs** **64बिट** के होते हैं जो निरंतर बढ़ते हैं और **कभी लपेटते नहीं हैं** (दुरुपयोग से बचने के लिए)।

### Process Groups, Sessions & Coalations

**प्रक्रियाएँ** को **समूहों** में डाला जा सकता है ताकि उन्हें संभालना आसान हो सके। उदाहरण के लिए, एक शेल स्क्रिप्ट में कमांड एक ही प्रक्रिया समूह में होंगे ताकि उन्हें एक साथ **सिग्नल किया जा सके** जैसे कि किल का उपयोग करके।\
यह भी संभव है कि **प्रक्रियाओं को सत्रों में समूहित किया जाए**। जब एक प्रक्रिया एक सत्र शुरू करती है (`setsid(2)`), तो बच्चों की प्रक्रियाएँ सत्र के भीतर सेट की जाती हैं, जब तक कि वे अपना स्वयं का सत्र शुरू न करें।

Coalition एक और तरीका है प्रक्रियाओं को डार्विन में समूहित करने का। एक प्रक्रिया एक कोलैशन में शामिल होने से उसे पूल संसाधनों तक पहुँचने की अनुमति मिलती है, एक लेजर साझा करना या Jetsam का सामना करना। कोलैशनों के विभिन्न भूमिकाएँ होती हैं: नेता, XPC सेवा, एक्सटेंशन।

### Credentials & Personae

प्रत्येक प्रक्रिया **प्रमाणपत्र** रखती है जो **इसके विशेषाधिकारों की पहचान करती है** प्रणाली में। प्रत्येक प्रक्रिया का एक प्राथमिक `uid` और एक प्राथमिक `gid` होगा (हालाँकि यह कई समूहों से संबंधित हो सकता है)।\
यदि बाइनरी में `setuid/setgid` बिट है तो उपयोगकर्ता और समूह आईडी को बदलना भी संभव है।\
नए uids/gids सेट करने के लिए कई फ़ंक्शन हैं।

syscall **`persona`** एक **वैकल्पिक** सेट प्रदान करता है **प्रमाणपत्रों** का। एक व्यक्तित्व को अपनाने से इसके uid, gid और समूह सदस्यता **एक साथ** मान ली जाती है। [**स्रोत कोड**](https://github.com/apple/darwin-xnu/blob/main/bsd/sys/persona.h) में संरचना पाई जा सकती है:
```c
struct kpersona_info { uint32_t persona_info_version;
uid_t    persona_id; /* overlaps with UID */
int      persona_type;
gid_t    persona_gid;
uint32_t persona_ngroups;
gid_t    persona_groups[NGROUPS];
uid_t    persona_gmuid;
char     persona_name[MAXLOGNAME + 1];

/* TODO: MAC policies?! */
}
```
## थ्रेड्स बुनियादी जानकारी

1. **POSIX थ्रेड्स (pthreads):** macOS POSIX थ्रेड्स (`pthreads`) का समर्थन करता है, जो C/C++ के लिए एक मानक थ्रेडिंग API का हिस्सा हैं। macOS में pthreads का कार्यान्वयन `/usr/lib/system/libsystem_pthread.dylib` में पाया जाता है, जो सार्वजनिक रूप से उपलब्ध `libpthread` प्रोजेक्ट से आता है। यह पुस्तकालय थ्रेड बनाने और प्रबंधित करने के लिए आवश्यक कार्य प्रदान करता है।
2. **थ्रेड बनाना:** `pthread_create()` फ़ंक्शन का उपयोग नए थ्रेड बनाने के लिए किया जाता है। आंतरिक रूप से, यह फ़ंक्शन `bsdthread_create()` को कॉल करता है, जो XNU कर्नेल (जिस पर macOS आधारित है) के लिए विशिष्ट एक निम्न-स्तरीय सिस्टम कॉल है। यह सिस्टम कॉल विभिन्न फ्लैग लेता है जो `pthread_attr` (गुण) से निकाले जाते हैं, जो थ्रेड के व्यवहार को निर्दिष्ट करते हैं, जिसमें शेड्यूलिंग नीतियाँ और स्टैक आकार शामिल हैं।
- **डिफ़ॉल्ट स्टैक आकार:** नए थ्रेड के लिए डिफ़ॉल्ट स्टैक आकार 512 KB है, जो सामान्य संचालन के लिए पर्याप्त है लेकिन यदि अधिक या कम स्थान की आवश्यकता हो तो थ्रेड गुणों के माध्यम से समायोजित किया जा सकता है।
3. **थ्रेड प्रारंभिककरण:** `__pthread_init()` फ़ंक्शन थ्रेड सेटअप के दौरान महत्वपूर्ण है, जो `env[]` तर्क का उपयोग करके पर्यावरण चर को पार्स करता है, जिसमें स्टैक के स्थान और आकार के बारे में विवरण शामिल हो सकते हैं।

#### macOS में थ्रेड समाप्ति

1. **थ्रेड्स से बाहर निकलना:** थ्रेड्स को आमतौर पर `pthread_exit()` को कॉल करके समाप्त किया जाता है। यह फ़ंक्शन एक थ्रेड को साफ-सुथरे तरीके से बाहर निकलने की अनुमति देता है, आवश्यक सफाई करते हुए और थ्रेड को किसी भी जॉइनर्स को एक रिटर्न वैल्यू भेजने की अनुमति देता है।
2. **थ्रेड सफाई:** `pthread_exit()` को कॉल करने पर, फ़ंक्शन `pthread_terminate()` को सक्रिय किया जाता है, जो सभी संबंधित थ्रेड संरचनाओं को हटाने का प्रबंधन करता है। यह Mach थ्रेड पोर्ट को डिअलॉकेट करता है (Mach XNU कर्नेल में संचार उपप्रणाली है) और `bsdthread_terminate` को कॉल करता है, जो एक syscall है जो थ्रेड से संबंधित कर्नेल-स्तरीय संरचनाओं को हटा देता है।

#### समन्वय तंत्र

साझा संसाधनों तक पहुँच प्रबंधित करने और दौड़ की स्थितियों से बचने के लिए, macOS कई समन्वय प्राइमिटिव प्रदान करता है। ये मल्टी-थ्रेडिंग वातावरण में डेटा अखंडता और सिस्टम स्थिरता सुनिश्चित करने के लिए महत्वपूर्ण हैं:

1. **म्यूटेक्स:**
- **नियमित म्यूटेक्स (सिग्नेचर: 0x4D555458):** मानक म्यूटेक्स जिसका मेमोरी फ़ुटप्रिंट 60 बाइट है (56 बाइट म्यूटेक्स के लिए और 4 बाइट सिग्नेचर के लिए)।
- **फास्ट म्यूटेक्स (सिग्नेचर: 0x4d55545A):** नियमित म्यूटेक्स के समान लेकिन तेज़ संचालन के लिए अनुकूलित, आकार में भी 60 बाइट।
2. **कंडीशन वेरिएबल्स:**
- कुछ स्थितियों के होने की प्रतीक्षा के लिए उपयोग किया जाता है, जिसका आकार 44 बाइट है (40 बाइट प्लस 4-बाइट सिग्नेचर)।
- **कंडीशन वेरिएबल गुण (सिग्नेचर: 0x434e4441):** कंडीशन वेरिएबल्स के लिए कॉन्फ़िगरेशन गुण, आकार में 12 बाइट।
3. **एक बार वेरिएबल (सिग्नेचर: 0x4f4e4345):**
- सुनिश्चित करता है कि एक टुकड़ा प्रारंभिककरण को केवल एक बार निष्पादित किया जाए। इसका आकार 12 बाइट है।
4. **रीड-राइट लॉक:**
- एक समय में कई पाठकों या एक लेखक की अनुमति देता है, साझा डेटा तक कुशल पहुँच की सुविधा प्रदान करता है।
- **रीड राइट लॉक (सिग्नेचर: 0x52574c4b):** आकार में 196 बाइट।
- **रीड राइट लॉक गुण (सिग्नेचर: 0x52574c41):** रीड-राइट लॉक के लिए गुण, आकार में 20 बाइट।

> [!TIP]
> उन वस्तुओं के अंतिम 4 बाइट ओवरफ्लो का पता लगाने के लिए उपयोग किए जाते हैं।

### थ्रेड लोकल वेरिएबल्स (TLV)

**थ्रेड लोकल वेरिएबल्स (TLV)** Mach-O फ़ाइलों (macOS में निष्पादन योग्य फ़ाइलों के लिए प्रारूप) के संदर्भ में उपयोग किए जाते हैं ताकि **प्रत्येक थ्रेड** के लिए विशिष्ट वेरिएबल्स घोषित किए जा सकें। यह सुनिश्चित करता है कि प्रत्येक थ्रेड के पास एक अलग वेरिएबल का अपना अलग उदाहरण हो, जिससे संघर्षों से बचने और डेटा अखंडता बनाए रखने का एक तरीका प्रदान होता है बिना म्यूटेक्स जैसे स्पष्ट समन्वय तंत्र की आवश्यकता के।

C और संबंधित भाषाओं में, आप **`__thread`** कीवर्ड का उपयोग करके एक थ्रेड-लोकल वेरिएबल घोषित कर सकते हैं। यहाँ आपके उदाहरण में यह कैसे काम करता है:
```c
cCopy code__thread int tlv_var;

void main (int argc, char **argv){
tlv_var = 10;
}
```
यह स्निपेट `tlv_var` को एक थ्रेड-स्थानीय चर के रूप में परिभाषित करता है। इस कोड को चलाने वाला प्रत्येक थ्रेड अपना `tlv_var` रखेगा, और एक थ्रेड द्वारा `tlv_var` में किए गए परिवर्तन दूसरे थ्रेड में `tlv_var` को प्रभावित नहीं करेंगे।

Mach-O बाइनरी में, थ्रेड स्थानीय चर से संबंधित डेटा को विशिष्ट अनुभागों में व्यवस्थित किया गया है:

- **`__DATA.__thread_vars`**: इस अनुभाग में थ्रेड-स्थानीय चर के बारे में मेटाडेटा होता है, जैसे उनके प्रकार और प्रारंभिक स्थिति।
- **`__DATA.__thread_bss`**: इस अनुभाग का उपयोग उन थ्रेड-स्थानीय चर के लिए किया जाता है जो स्पष्ट रूप से प्रारंभ नहीं किए गए हैं। यह शून्य-प्रारंभित डेटा के लिए आरक्षित मेमोरी का एक भाग है।

Mach-O एक विशिष्ट API भी प्रदान करता है जिसे **`tlv_atexit`** कहा जाता है, जो थ्रेड के समाप्त होने पर थ्रेड-स्थानीय चर को प्रबंधित करने के लिए है। यह API आपको **विनाशक पंजीकृत करने** की अनुमति देता है—विशेष कार्य जो थ्रेड समाप्त होने पर थ्रेड-स्थानीय डेटा को साफ करते हैं।

### थ्रेडिंग प्राथमिकताएँ

थ्रेड प्राथमिकताओं को समझने में यह देखना शामिल है कि ऑपरेटिंग सिस्टम यह तय करता है कि कौन से थ्रेड कब चलाए जाएँ। यह निर्णय प्रत्येक थ्रेड को सौंपे गए प्राथमिकता स्तर से प्रभावित होता है। macOS और यूनिक्स-जैसे सिस्टम में, इसे `nice`, `renice`, और गुणवत्ता सेवा (QoS) वर्गों जैसे अवधारणाओं का उपयोग करके संभाला जाता है।

#### नाइस और रेनाइस

1. **नाइस:**
- एक प्रक्रिया का `nice` मान एक संख्या है जो इसकी प्राथमिकता को प्रभावित करता है। प्रत्येक प्रक्रिया का एक नाइस मान होता है जो -20 (सबसे उच्च प्राथमिकता) से 19 (सबसे निम्न प्राथमिकता) के बीच होता है। जब एक प्रक्रिया बनाई जाती है, तो डिफ़ॉल्ट नाइस मान आमतौर पर 0 होता है।
- एक निम्न नाइस मान (जो -20 के करीब होता है) एक प्रक्रिया को अधिक "स्वार्थी" बनाता है, जिससे इसे उच्च नाइस मान वाली अन्य प्रक्रियाओं की तुलना में अधिक CPU समय मिलता है।
2. **रेनाइस:**
- `renice` एक कमांड है जिसका उपयोग पहले से चल रही प्रक्रिया के नाइस मान को बदलने के लिए किया जाता है। इसका उपयोग प्रक्रियाओं की प्राथमिकता को गतिशील रूप से समायोजित करने के लिए किया जा सकता है, या तो उनके CPU समय आवंटन को नए नाइस मानों के आधार पर बढ़ाने या घटाने के लिए।
- उदाहरण के लिए, यदि एक प्रक्रिया को अस्थायी रूप से अधिक CPU संसाधनों की आवश्यकता है, तो आप `renice` का उपयोग करके इसके नाइस मान को कम कर सकते हैं।

#### गुणवत्ता सेवा (QoS) वर्ग

QoS वर्ग थ्रेड प्राथमिकताओं को संभालने के लिए एक अधिक आधुनिक दृष्टिकोण है, विशेष रूप से macOS जैसे सिस्टम में जो **ग्रैंड सेंट्रल डिस्पैच (GCD)** का समर्थन करते हैं। QoS वर्ग डेवलपर्स को कार्यों को उनके महत्व या तात्कालिकता के आधार पर विभिन्न स्तरों में **श्रेणीबद्ध** करने की अनुमति देते हैं। macOS इन QoS वर्गों के आधार पर स्वचालित रूप से थ्रेड प्राथमिकता प्रबंधित करता है:

1. **उपयोगकर्ता इंटरैक्टिव:**
- यह वर्ग उन कार्यों के लिए है जो वर्तमान में उपयोगकर्ता के साथ इंटरैक्ट कर रहे हैं या अच्छे उपयोगकर्ता अनुभव प्रदान करने के लिए तात्कालिक परिणामों की आवश्यकता होती है। इन कार्यों को इंटरफ़ेस को उत्तरदायी बनाए रखने के लिए उच्चतम प्राथमिकता दी जाती है (जैसे, एनिमेशन या इवेंट हैंडलिंग)।
2. **उपयोगकर्ता द्वारा आरंभित:**
- वे कार्य जो उपयोगकर्ता द्वारा आरंभ किए जाते हैं और तात्कालिक परिणामों की अपेक्षा करते हैं, जैसे कि एक दस्तावेज़ खोलना या एक बटन पर क्लिक करना जो गणनाओं की आवश्यकता होती है। ये उच्च प्राथमिकता वाले होते हैं लेकिन उपयोगकर्ता इंटरैक्टिव से नीचे होते हैं।
3. **उपयोगिता:**
- ये कार्य लंबे समय तक चलने वाले होते हैं और आमतौर पर प्रगति संकेतक दिखाते हैं (जैसे, फ़ाइलें डाउनलोड करना, डेटा आयात करना)। ये उपयोगकर्ता द्वारा आरंभित कार्यों की तुलना में प्राथमिकता में कम होते हैं और इन्हें तुरंत समाप्त करने की आवश्यकता नहीं होती है।
4. **पृष्ठभूमि:**
- यह वर्ग उन कार्यों के लिए है जो पृष्ठभूमि में कार्य करते हैं और उपयोगकर्ता को दिखाई नहीं देते हैं। ये कार्य जैसे अनुक्रमण, समन्वय, या बैकअप हो सकते हैं। इनकी प्राथमिकता सबसे कम होती है और सिस्टम प्रदर्शन पर न्यूनतम प्रभाव पड़ता है।

QoS वर्गों का उपयोग करते हुए, डेवलपर्स को सटीक प्राथमिकता संख्याओं का प्रबंधन करने की आवश्यकता नहीं होती है, बल्कि कार्य की प्रकृति पर ध्यान केंद्रित करना होता है, और सिस्टम CPU संसाधनों को तदनुसार अनुकूलित करता है।

इसके अलावा, विभिन्न **थ्रेड शेड्यूलिंग नीतियाँ** हैं जो शेड्यूलर द्वारा ध्यान में रखे जाने वाले शेड्यूलिंग पैरामीटर के सेट को निर्दिष्ट करती हैं। इसे `thread_policy_[set/get]` का उपयोग करके किया जा सकता है। यह रेस कंडीशन हमलों में उपयोगी हो सकता है।

## MacOS प्रक्रिया दुरुपयोग

MacOS, किसी अन्य ऑपरेटिंग सिस्टम की तरह, **प्रक्रियाओं के बीच बातचीत, संचार, और डेटा साझा करने** के लिए विभिन्न विधियाँ और तंत्र प्रदान करता है। जबकि ये तकनीकें कुशल प्रणाली कार्यप्रणाली के लिए आवश्यक हैं, इन्हें खतरे के तत्वों द्वारा **दुष्ट गतिविधियों** को करने के लिए भी दुरुपयोग किया जा सकता है।

### पुस्तकालय इंजेक्शन

पुस्तकालय इंजेक्शन एक तकनीक है जिसमें एक हमलावर **एक प्रक्रिया को एक दुर्भावनापूर्ण पुस्तकालय लोड करने के लिए मजबूर करता है**। एक बार इंजेक्ट होने के बाद, पुस्तकालय लक्षित प्रक्रिया के संदर्भ में चलता है, हमलावर को प्रक्रिया के समान अनुमतियाँ और पहुँच प्रदान करता है।

{{#ref}}
macos-library-injection/
{{#endref}}

### फ़ंक्शन हुकिंग

फ़ंक्शन हुकिंग में **सॉफ़्टवेयर कोड के भीतर फ़ंक्शन कॉल** या संदेशों को **अवरोधित करना** शामिल है। फ़ंक्शनों को हुक करके, एक हमलावर एक प्रक्रिया के **व्यवहार को संशोधित** कर सकता है, संवेदनशील डेटा का अवलोकन कर सकता है, या यहां तक कि निष्पादन प्रवाह पर नियंत्रण प्राप्त कर सकता है।

{{#ref}}
macos-function-hooking.md
{{#endref}}

### इंटर प्रोसेस संचार

इंटर प्रोसेस संचार (IPC) विभिन्न विधियों को संदर्भित करता है जिनके द्वारा अलग-अलग प्रक्रियाएँ **डेटा साझा और विनिमय** करती हैं। जबकि IPC कई वैध अनुप्रयोगों के लिए मौलिक है, इसका दुरुपयोग प्रक्रिया अलगाव को कमजोर करने, संवेदनशील जानकारी लीक करने, या अनधिकृत कार्य करने के लिए भी किया जा सकता है।

{{#ref}}
macos-ipc-inter-process-communication/
{{#endref}}

### इलेक्ट्रॉन अनुप्रयोग इंजेक्शन

विशिष्ट env वेरिएबल के साथ निष्पादित इलेक्ट्रॉन अनुप्रयोग प्रक्रिया इंजेक्शन के प्रति संवेदनशील हो सकते हैं:

{{#ref}}
macos-electron-applications-injection.md
{{#endref}}

### क्रोमियम इंजेक्शन

यह **ब्राउज़र में मैन इन द ब्राउज़र हमले** को करने के लिए `--load-extension` और `--use-fake-ui-for-media-stream` फ्लैग्स का उपयोग करना संभव है, जिससे कीस्ट्रोक्स, ट्रैफ़िक, कुकीज़ चुराने, पृष्ठों में स्क्रिप्ट इंजेक्ट करने की अनुमति मिलती है...:

{{#ref}}
macos-chromium-injection.md
{{#endref}}

### गंदा NIB

NIB फ़ाइलें **उपयोगकर्ता इंटरफ़ेस (UI) तत्वों** और उनके अनुप्रयोग के भीतर इंटरैक्शन को परिभाषित करती हैं। हालाँकि, वे **मनमाने आदेशों को निष्पादित** कर सकती हैं और **गेटकीपर** एक पहले से निष्पादित अनुप्रयोग को निष्पादित करने से नहीं रोकता है यदि एक **NIB फ़ाइल को संशोधित किया गया है**। इसलिए, इन्हें मनमाने कार्यक्रमों को मनमाने आदेश निष्पादित करने के लिए उपयोग किया जा सकता है:

{{#ref}}
macos-dirty-nib.md
{{#endref}}

### जावा अनुप्रयोग इंजेक्शन

कुछ जावा क्षमताओं (जैसे **`_JAVA_OPTS`** env वेरिएबल) का दुरुपयोग करके एक जावा अनुप्रयोग को **मनमाना कोड/आदेश** निष्पादित करने के लिए संभव है।

{{#ref}}
macos-java-apps-injection.md
{{#endref}}

### .Net अनुप्रयोग इंजेक्शन

यह .Net अनुप्रयोगों में कोड इंजेक्ट करने के लिए **.Net डिबगिंग कार्यक्षमता का दुरुपयोग** करके संभव है (जो macOS सुरक्षा जैसे रनटाइम हार्डनिंग द्वारा सुरक्षित नहीं है)।

{{#ref}}
macos-.net-applications-injection.md
{{#endref}}

### पर्ल इंजेक्शन

मनमाने कोड को निष्पादित करने के लिए पर्ल स्क्रिप्ट बनाने के विभिन्न विकल्पों की जाँच करें:

{{#ref}}
macos-perl-applications-injection.md
{{#endref}}

### रूबी इंजेक्शन

यह भी संभव है कि रूबी env वेरिएबल का दुरुपयोग करके मनमाने स्क्रिप्ट को मनमाना कोड निष्पादित करने के लिए बनाया जाए:

{{#ref}}
macos-ruby-applications-injection.md
{{#endref}}

### पायथन इंजेक्शन

यदि पर्यावरण चर **`PYTHONINSPECT`** सेट किया गया है, तो पायथन प्रक्रिया समाप्त होने पर पायथन CLI में गिर जाएगी। यह भी संभव है कि **`PYTHONSTARTUP`** का उपयोग करके एक पायथन स्क्रिप्ट को इंटरैक्टिव सत्र की शुरुआत में निष्पादित करने के लिए इंगित किया जाए।\
हालांकि, ध्यान दें कि **`PYTHONSTARTUP`** स्क्रिप्ट तब निष्पादित नहीं होगी जब **`PYTHONINSPECT`** इंटरैक्टिव सत्र बनाता है।

अन्य env वेरिएबल जैसे **`PYTHONPATH`** और **`PYTHONHOME`** भी मनमाने कोड को निष्पादित करने के लिए उपयोगी हो सकते हैं।

ध्यान दें कि **`pyinstaller`** के साथ संकलित निष्पादन योग्य इन पर्यावरण चर का उपयोग नहीं करेंगे, भले ही वे एम्बेडेड पायथन का उपयोग करके चल रहे हों।

> [!CAUTION]
> कुल मिलाकर, मैं पर्यावरण चर का दुरुपयोग करके पायथन को मनमाना कोड निष्पादित करने का कोई तरीका नहीं ढूंढ सका।\
> हालाँकि, अधिकांश लोग **Hombrew** का उपयोग करके पायथन स्थापित करते हैं, जो डिफ़ॉल्ट व्यवस्थापक उपयोगकर्ता के लिए **लिखने योग्य स्थान** में पायथन स्थापित करेगा। आप इसे कुछ इस तरह से हाइजैक कर सकते हैं:
>
> ```bash
> mv /opt/homebrew/bin/python3 /opt/homebrew/bin/python3.old
> cat > /opt/homebrew/bin/python3 <<EOF
> #!/bin/bash
> # अतिरिक्त हाइजैक कोड
> /opt/homebrew/bin/python3.old "$@"
> EOF
> chmod +x /opt/homebrew/bin/python3
> ```
>
> यहां तक कि **रूट** भी पायथन चलाते समय इस कोड को चलाएगा।

## पहचान

### शील्ड

[**शील्ड**](https://theevilbit.github.io/shield/) ([**गिटहब**](https://github.com/theevilbit/Shield)) एक ओपन-सोर्स एप्लिकेशन है जो **प्रक्रिया इंजेक्शन** क्रियाओं का **पता लगाने और अवरुद्ध करने** में सक्षम है:

- **पर्यावरण चर का उपयोग करना**: यह निम्नलिखित पर्यावरण चर में से किसी की उपस्थिति की निगरानी करेगा: **`DYLD_INSERT_LIBRARIES`**, **`CFNETWORK_LIBRARY_PATH`**, **`RAWCAMERA_BUNDLE_PATH`** और **`ELECTRON_RUN_AS_NODE`**
- **`task_for_pid`** कॉल का उपयोग करना: यह पता लगाने के लिए कि एक प्रक्रिया दूसरे की **कार्य पोर्ट** प्राप्त करना चाहती है, जो प्रक्रिया में कोड इंजेक्ट करने की अनुमति देती है।
- **इलेक्ट्रॉन ऐप्स पैरामीटर**: कोई व्यक्ति **`--inspect`**, **`--inspect-brk`** और **`--remote-debugging-port`** कमांड लाइन तर्क का उपयोग करके एक इलेक्ट्रॉन ऐप को डिबगिंग मोड में शुरू कर सकता है, और इस प्रकार इसमें कोड इंजेक्ट कर सकता है।
- **सिंबलिंक** या **हार्डलिंक** का उपयोग करना: आमतौर पर सबसे सामान्य दुरुपयोग यह है कि **हमारे उपयोगकर्ता अनुमतियों के साथ एक लिंक रखा जाए**, और **उच्चतर अनुमतियों** वाले स्थान की ओर इंगित किया जाए। हार्डलिंक और सिंबलिंक दोनों के लिए पहचान बहुत सरल है। यदि लिंक बनाने वाली प्रक्रिया का **लक्ष्य फ़ाइल** की तुलना में **विभिन्न अनुमतियों का स्तर** है, तो हम एक **अलर्ट** बनाते हैं। दुर्भाग्यवश, सिंबलिंक के मामले में अवरोधन संभव नहीं है, क्योंकि लिंक बनाने से पहले हमें लिंक के गंतव्य के बारे में जानकारी नहीं होती है। यह Apple के EndpointSecuriy ढांचे की एक सीमा है।

### अन्य प्रक्रियाओं द्वारा किए गए कॉल

[**इस ब्लॉग पोस्ट**](https://knight.sc/reverse%20engineering/2019/04/15/detecting-task-modifications.html) में आप देख सकते हैं कि यह संभव है कि **`task_name_for_pid`** फ़ंक्शन का उपयोग करके अन्य **प्रक्रियाओं में कोड इंजेक्ट करने** के बारे में जानकारी प्राप्त की जा सके और फिर उस अन्य प्रक्रिया के बारे में जानकारी प्राप्त की जा सके।

ध्यान दें कि उस फ़ंक्शन को कॉल करने के लिए आपको प्रक्रिया को चलाने वाले के समान **uid** होना चाहिए या **रूट** (और यह प्रक्रिया के बारे में जानकारी लौटाता है, कोड इंजेक्ट करने का कोई तरीका नहीं)।

## संदर्भ

- [https://theevilbit.github.io/shield/](https://theevilbit.github.io/shield/)
- [https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f)

{{#include ../../../banners/hacktricks-training.md}}
