# macOS Process Abuse

{{#include ../../../banners/hacktricks-training.md}}

## Processes Basic Information

Μια διαδικασία είναι μια περίπτωση ενός εκτελέσιμου που τρέχει, ωστόσο οι διαδικασίες δεν εκτελούν κώδικα, αυτές είναι νήματα. Επομένως, **οι διαδικασίες είναι απλώς δοχεία για τρέχοντα νήματα** παρέχοντας τη μνήμη, τους περιγραφείς, τις θύρες, τις άδειες...

Παραδοσιακά, οι διαδικασίες ξεκινούσαν μέσα σε άλλες διαδικασίες (εκτός από το PID 1) καλώντας **`fork`** που θα δημιουργούσε μια ακριβή αντιγραφή της τρέχουσας διαδικασίας και στη συνέχεια η **παιδική διαδικασία** θα καλούσε γενικά **`execve`** για να φορτώσει το νέο εκτελέσιμο και να το εκτελέσει. Στη συνέχεια, εισήχθη το **`vfork`** για να επιταχύνει αυτή τη διαδικασία χωρίς καμία αντιγραφή μνήμης.\
Στη συνέχεια, εισήχθη το **`posix_spawn`** συνδυάζοντας **`vfork`** και **`execve`** σε μία κλήση και αποδεχόμενο σημαίες:

- `POSIX_SPAWN_RESETIDS`: Επαναφορά των αποτελεσματικών ταυτοτήτων στις πραγματικές ταυτότητες
- `POSIX_SPAWN_SETPGROUP`: Ορισμός συσχέτισης ομάδας διαδικασιών
- `POSUX_SPAWN_SETSIGDEF`: Ορισμός της προεπιλεγμένης συμπεριφοράς σήματος
- `POSIX_SPAWN_SETSIGMASK`: Ορισμός μάσκας σήματος
- `POSIX_SPAWN_SETEXEC`: Εκτέλεση στην ίδια διαδικασία (όπως το `execve` με περισσότερες επιλογές)
- `POSIX_SPAWN_START_SUSPENDED`: Έναρξη σε αναστολή
- `_POSIX_SPAWN_DISABLE_ASLR`: Έναρξη χωρίς ASLR
- `_POSIX_SPAWN_NANO_ALLOCATOR:` Χρήση του Nano allocator της libmalloc
- `_POSIX_SPAWN_ALLOW_DATA_EXEC:` Επιτρέπεται το `rwx` σε τμήματα δεδομένων
- `POSIX_SPAWN_CLOEXEC_DEFAULT`: Κλείσιμο όλων των περιγραφών αρχείων κατά την εκτέλεση (2) από προεπιλογή
- `_POSIX_SPAWN_HIGH_BITS_ASLR:` Τυχαία τα υψηλά bits της μετατόπισης ASLR

Επιπλέον, το `posix_spawn` επιτρέπει τον καθορισμό ενός πίνακα **`posix_spawnattr`** που ελέγχει ορισμένες πτυχές της διαδικασίας που δημιουργείται, και **`posix_spawn_file_actions`** για να τροποποιήσει την κατάσταση των περιγραφέων.

Όταν μια διαδικασία πεθαίνει, στέλνει τον **κωδικό επιστροφής στην γονική διαδικασία** (αν η γονική διαδικασία έχει πεθάνει, η νέα γονική διαδικασία είναι το PID 1) με το σήμα `SIGCHLD`. Η γονική διαδικασία πρέπει να αποκτήσει αυτή την τιμή καλώντας `wait4()` ή `waitid()` και μέχρι να συμβεί αυτό, η παιδική διαδικασία παραμένει σε κατάσταση ζόμπι όπου είναι ακόμα καταχωρημένη αλλά δεν καταναλώνει πόρους.

### PIDs

Τα PIDs, ταυτοποιητές διαδικασιών, προσδιορίζουν μια μοναδική διαδικασία. Στο XNU, οι **PIDs** είναι **64bit** και αυξάνονται μονοτονικά και **ποτέ δεν επαναλαμβάνονται** (για να αποφεύγονται οι καταχρήσεις).

### Process Groups, Sessions & Coalations

**Διαδικασίες** μπορούν να εισαχθούν σε **ομάδες** για να διευκολυνθεί η διαχείρισή τους. Για παράδειγμα, οι εντολές σε ένα script shell θα είναι στην ίδια ομάδα διαδικασιών, έτσι είναι δυνατή η **σήμανση τους μαζί** χρησιμοποιώντας kill για παράδειγμα.\
Είναι επίσης δυνατή η **ομαδοποίηση διαδικασιών σε συνεδρίες**. Όταν μια διαδικασία ξεκινά μια συνεδρία (`setsid(2)`), οι παιδικές διαδικασίες τοποθετούνται μέσα στη συνεδρία, εκτός αν ξεκινήσουν τη δική τους συνεδρία.

Η συμμαχία είναι ένας άλλος τρόπος ομαδοποίησης διαδικασιών στο Darwin. Μια διαδικασία που συμμετέχει σε μια συμμαχία της επιτρέπει να έχει πρόσβαση σε πόρους πισίνας, μοιράζοντας ένα βιβλίο ή αντιμετωπίζοντας το Jetsam. Οι συμμαχίες έχουν διαφορετικούς ρόλους: Ηγέτης, Υπηρεσία XPC, Επέκταση.

### Credentials & Personae

Κάθε διαδικασία διατηρεί **διαπιστευτήρια** που **προσδιορίζουν τα προνόμιά** της στο σύστημα. Κάθε διαδικασία θα έχει μία κύρια `uid` και μία κύρια `gid` (αν και μπορεί να ανήκει σε πολλές ομάδες).\
Είναι επίσης δυνατή η αλλαγή του αναγνωριστικού χρήστη και ομάδας αν το δυαδικό αρχείο έχει το bit `setuid/setgid`.\
Υπάρχουν πολλές συναρτήσεις για **ορισμό νέων uids/gids**.

Η syscall **`persona`** παρέχει ένα **εναλλακτικό** σύνολο **διαπιστευτηρίων**. Η υιοθέτηση μιας προσωπικότητας υποθέτει την `uid`, `gid` και τις συμμετοχές ομάδας **ταυτόχρονα**. Στον [**κώδικα πηγής**](https://github.com/apple/darwin-xnu/blob/main/bsd/sys/persona.h) είναι δυνατή η εύρεση της δομής:
```c
struct kpersona_info { uint32_t persona_info_version;
uid_t    persona_id; /* overlaps with UID */
int      persona_type;
gid_t    persona_gid;
uint32_t persona_ngroups;
gid_t    persona_groups[NGROUPS];
uid_t    persona_gmuid;
char     persona_name[MAXLOGNAME + 1];

/* TODO: MAC policies?! */
}
```
## Βασικές Πληροφορίες για τα Νήματα

1. **POSIX Νήματα (pthreads):** Το macOS υποστηρίζει τα POSIX νήματα (`pthreads`), τα οποία είναι μέρος ενός τυπικού API νημάτων για C/C++. Η υλοποίηση των pthreads στο macOS βρίσκεται στο `/usr/lib/system/libsystem_pthread.dylib`, που προέρχεται από το δημόσια διαθέσιμο έργο `libpthread`. Αυτή η βιβλιοθήκη παρέχει τις απαραίτητες συναρτήσεις για τη δημιουργία και διαχείριση νημάτων.
2. **Δημιουργία Νημάτων:** Η συνάρτηση `pthread_create()` χρησιμοποιείται για τη δημιουργία νέων νημάτων. Εσωτερικά, αυτή η συνάρτηση καλεί τη `bsdthread_create()`, η οποία είναι μια χαμηλού επιπέδου κλήση συστήματος συγκεκριμένη για τον πυρήνα XNU (τον πυρήνα στον οποίο βασίζεται το macOS). Αυτή η κλήση συστήματος παίρνει διάφορες σημαίες που προέρχονται από το `pthread_attr` (χαρακτηριστικά) που καθορίζουν τη συμπεριφορά του νήματος, συμπεριλαμβανομένων των πολιτικών προγραμματισμού και του μεγέθους στοίβας.
- **Προεπιλεγμένο Μέγεθος Στοίβας:** Το προεπιλεγμένο μέγεθος στοίβας για νέα νήματα είναι 512 KB, το οποίο είναι επαρκές για τυπικές λειτουργίες αλλά μπορεί να προσαρμοστεί μέσω των χαρακτηριστικών του νήματος αν χρειάζεται περισσότερος ή λιγότερος χώρος.
3. **Αρχικοποίηση Νημάτων:** Η συνάρτηση `__pthread_init()` είναι κρίσιμη κατά τη ρύθμιση του νήματος, χρησιμοποιώντας το επιχείρημα `env[]` για να αναλύσει τις μεταβλητές περιβάλλοντος που μπορεί να περιλαμβάνουν λεπτομέρειες σχετικά με την τοποθεσία και το μέγεθος της στοίβας.

#### Τερματισμός Νημάτων στο macOS

1. **Έξοδος Νημάτων:** Τα νήματα τερματίζονται συνήθως καλώντας τη `pthread_exit()`. Αυτή η συνάρτηση επιτρέπει σε ένα νήμα να εξέλθει καθαρά, εκτελώντας την απαραίτητη καθαριότητα και επιτρέποντας στο νήμα να στείλει μια τιμή επιστροφής πίσω σε οποιουσδήποτε συμμετέχοντες.
2. **Καθαριότητα Νημάτων:** Κατά την κλήση της `pthread_exit()`, καλείται η συνάρτηση `pthread_terminate()`, η οποία χειρίζεται την αφαίρεση όλων των σχετικών δομών νήματος. Αποδεσμεύει τις θύρες νήματος Mach (Mach είναι το υποσύστημα επικοινωνίας στον πυρήνα XNU) και καλεί τη `bsdthread_terminate`, μια κλήση συστήματος που αφαιρεί τις δομές επιπέδου πυρήνα που σχετίζονται με το νήμα.

#### Μηχανισμοί Συγχρονισμού

Για να διαχειριστεί την πρόσβαση σε κοινόχρηστους πόρους και να αποφευχθούν οι συνθήκες αγώνα, το macOS παρέχει αρκετές πρωτογενείς συγχρονισμού. Αυτές είναι κρίσιμες σε περιβάλλοντα πολλαπλών νημάτων για να διασφαλιστεί η ακεραιότητα των δεδομένων και η σταθερότητα του συστήματος:

1. **Mutexes:**
- **Κανονικός Mutex (Υπογραφή: 0x4D555458):** Τυπικός mutex με αποτύπωμα μνήμης 60 bytes (56 bytes για τον mutex και 4 bytes για την υπογραφή).
- **Γρήγορος Mutex (Υπογραφή: 0x4d55545A):** Παρόμοιος με έναν κανονικό mutex αλλά βελτιστοποιημένος για ταχύτερες λειτουργίες, επίσης 60 bytes σε μέγεθος.
2. **Μεταβλητές Συνθηκών:**
- Χρησιμοποιούνται για να περιμένουν να συμβούν ορισμένες συνθήκες, με μέγεθος 44 bytes (40 bytes συν 4 bytes υπογραφή).
- **Χαρακτηριστικά Μεταβλητών Συνθηκών (Υπογραφή: 0x434e4441):** Χαρακτηριστικά ρύθμισης για μεταβλητές συνθηκών, μεγέθους 12 bytes.
3. **Once Variable (Υπογραφή: 0x4f4e4345):**
- Διασφαλίζει ότι ένα κομμάτι κώδικα αρχικοποίησης εκτελείται μόνο μία φορά. Το μέγεθός του είναι 12 bytes.
4. **Κλειδώματα Ανάγνωσης-Εγγραφής:**
- Επιτρέπει σε πολλούς αναγνώστες ή έναν συγγραφέα ταυτόχρονα, διευκολύνοντας την αποδοτική πρόσβαση σε κοινά δεδομένα.
- **Κλείδωμα Ανάγνωσης-Εγγραφής (Υπογραφή: 0x52574c4b):** Μεγέθους 196 bytes.
- **Χαρακτηριστικά Κλειδώματος Ανάγνωσης-Εγγραφής (Υπογραφή: 0x52574c41):** Χαρακτηριστικά για κλειδώματα ανάγνωσης-εγγραφής, 20 bytes σε μέγεθος.

> [!TIP]
> Τα τελευταία 4 bytes αυτών των αντικειμένων χρησιμοποιούνται για την ανίχνευση υπερχειλίσεων.

### Τοπικές Μεταβλητές Νημάτων (TLV)

**Τοπικές Μεταβλητές Νημάτων (TLV)** στο πλαίσιο των αρχείων Mach-O (η μορφή για εκτελέσιμα στο macOS) χρησιμοποιούνται για να δηλώσουν μεταβλητές που είναι συγκεκριμένες για **κάθε νήμα** σε μια εφαρμογή πολλαπλών νημάτων. Αυτό διασφαλίζει ότι κάθε νήμα έχει τη δική του ξεχωριστή παρουσία μιας μεταβλητής, παρέχοντας έναν τρόπο να αποφευχθούν οι συγκρούσεις και να διατηρηθεί η ακεραιότητα των δεδομένων χωρίς να χρειάζονται ρητοί μηχανισμοί συγχρονισμού όπως οι mutexes.

Στη C και σε σχετικές γλώσσες, μπορείτε να δηλώσετε μια τοπική μεταβλητή νήματος χρησιμοποιώντας τη λέξη-κλειδί **`__thread`**. Να πώς λειτουργεί στο παράδειγμά σας:
```c
cCopy code__thread int tlv_var;

void main (int argc, char **argv){
tlv_var = 10;
}
```
Αυτό το απόσπασμα ορίζει το `tlv_var` ως μια μεταβλητή τοπική στο νήμα. Κάθε νήμα που εκτελεί αυτόν τον κώδικα θα έχει τη δική του `tlv_var`, και οι αλλαγές που κάνει ένα νήμα στη `tlv_var` δεν θα επηρεάσουν τη `tlv_var` σε άλλο νήμα.

Στο δυαδικό Mach-O, τα δεδομένα που σχετίζονται με τις τοπικές μεταβλητές νήματος οργανώνονται σε συγκεκριμένες ενότητες:

- **`__DATA.__thread_vars`**: Αυτή η ενότητα περιέχει τα μεταδεδομένα σχετικά με τις τοπικές μεταβλητές νήματος, όπως τους τύπους τους και την κατάσταση αρχικοποίησης.
- **`__DATA.__thread_bss`**: Αυτή η ενότητα χρησιμοποιείται για τις τοπικές μεταβλητές νήματος που δεν έχουν αρχικοποιηθεί ρητά. Είναι ένα μέρος της μνήμης που έχει διατεθεί για δεδομένα που έχουν αρχικοποιηθεί σε μηδέν.

Το Mach-O παρέχει επίσης μια συγκεκριμένη API που ονομάζεται **`tlv_atexit`** για τη διαχείριση των τοπικών μεταβλητών νήματος όταν ένα νήμα εξέρχεται. Αυτή η API σας επιτρέπει να **καταχωρείτε καταστροφείς**—ειδικές συναρτήσεις που καθαρίζουν τα τοπικά δεδομένα νήματος όταν ένα νήμα τερματίζει.

### Προτεραιότητες Νημάτων

Η κατανόηση των προτεραιοτήτων νημάτων περιλαμβάνει την εξέταση του πώς το λειτουργικό σύστημα αποφασίζει ποια νήματα θα εκτελούνται και πότε. Αυτή η απόφαση επηρεάζεται από το επίπεδο προτεραιότητας που έχει ανατεθεί σε κάθε νήμα. Στα macOS και σε συστήματα παρόμοια με το Unix, αυτό διαχειρίζεται χρησιμοποιώντας έννοιες όπως το `nice`, `renice` και τις κλάσεις Ποιότητας Υπηρεσίας (QoS).

#### Nice και Renice

1. **Nice:**
- Η τιμή `nice` μιας διαδικασίας είναι ένας αριθμός που επηρεάζει την προτεραιότητά της. Κάθε διαδικασία έχει μια τιμή nice που κυμαίνεται από -20 (η υψηλότερη προτεραιότητα) έως 19 (η χαμηλότερη προτεραιότητα). Η προεπιλεγμένη τιμή nice όταν δημιουργείται μια διαδικασία είναι συνήθως 0.
- Μια χαμηλότερη τιμή nice (πιο κοντά στο -20) καθιστά μια διαδικασία πιο "εγωιστική", δίνοντάς της περισσότερο χρόνο CPU σε σύγκριση με άλλες διαδικασίες με υψηλότερες τιμές nice.
2. **Renice:**
- Το `renice` είναι μια εντολή που χρησιμοποιείται για να αλλάξει την τιμή nice μιας ήδη εκτελούμενης διαδικασίας. Αυτό μπορεί να χρησιμοποιηθεί για να προσαρμόσει δυναμικά την προτεραιότητα των διαδικασιών, είτε αυξάνοντας είτε μειώνοντας την κατανομή χρόνου CPU τους με βάση νέες τιμές nice.
- Για παράδειγμα, αν μια διαδικασία χρειάζεται περισσότερους πόρους CPU προσωρινά, μπορείτε να μειώσετε την τιμή nice της χρησιμοποιώντας το `renice`.

#### Κλάσεις Ποιότητας Υπηρεσίας (QoS)

Οι κλάσεις QoS είναι μια πιο σύγχρονη προσέγγιση για τη διαχείριση των προτεραιοτήτων νημάτων, ιδιαίτερα σε συστήματα όπως το macOS που υποστηρίζουν **Grand Central Dispatch (GCD)**. Οι κλάσεις QoS επιτρέπουν στους προγραμματιστές να **κατηγοριοποιούν** τη δουλειά σε διαφορετικά επίπεδα με βάση τη σημασία ή την επείγουσα ανάγκη τους. Το macOS διαχειρίζεται την προτεραιοποίηση νημάτων αυτόματα με βάση αυτές τις κλάσεις QoS:

1. **Αλληλεπίδραση Χρήστη:**
- Αυτή η κλάση είναι για εργασίες που αλληλεπιδρούν αυτή τη στιγμή με τον χρήστη ή απαιτούν άμεσα αποτελέσματα για να παρέχουν καλή εμπειρία χρήστη. Αυτές οι εργασίες έχουν την υψηλότερη προτεραιότητα για να διατηρούν την διεπαφή ανταγωνιστική (π.χ., κινούμενα σχέδια ή χειρισμός γεγονότων).
2. **Πρωτοβουλία Χρήστη:**
- Εργασίες που ξεκινά ο χρήστης και αναμένει άμεσα αποτελέσματα, όπως το άνοιγμα ενός εγγράφου ή το κλικ σε ένα κουμπί που απαιτεί υπολογισμούς. Αυτές είναι υψηλής προτεραιότητας αλλά κάτω από την αλληλεπίδραση χρήστη.
3. **Χρήση:**
- Αυτές οι εργασίες είναι μακροχρόνιες και συνήθως εμφανίζουν έναν δείκτη προόδου (π.χ., λήψη αρχείων, εισαγωγή δεδομένων). Είναι χαμηλότερης προτεραιότητας από τις εργασίες που ξεκινούν οι χρήστες και δεν χρειάζεται να ολοκληρωθούν άμεσα.
4. **Υπόβαθρο:**
- Αυτή η κλάση είναι για εργασίες που λειτουργούν στο παρασκήνιο και δεν είναι ορατές στον χρήστη. Αυτές μπορεί να είναι εργασίες όπως η ευρετηρίαση, η συγχρονισμός ή τα αντίγραφα ασφαλείας. Έχουν την χαμηλότερη προτεραιότητα και ελάχιστη επίδραση στην απόδοση του συστήματος.

Χρησιμοποιώντας τις κλάσεις QoS, οι προγραμματιστές δεν χρειάζεται να διαχειρίζονται τους ακριβείς αριθμούς προτεραιότητας αλλά να επικεντρώνονται στη φύση της εργασίας, και το σύστημα βελτιστοποιεί τους πόρους CPU αναλόγως.

Επιπλέον, υπάρχουν διαφορετικές **πολιτικές προγραμματισμού νημάτων** που ρέουν για να καθορίσουν ένα σύνολο παραμέτρων προγραμματισμού που ο προγραμματιστής θα λάβει υπόψη. Αυτό μπορεί να γίνει χρησιμοποιώντας `thread_policy_[set/get]`. Αυτό μπορεί να είναι χρήσιμο σε επιθέσεις συνθήκης αγώνα.

## Κατάχρηση Διαδικασιών MacOS

Το MacOS, όπως κάθε άλλο λειτουργικό σύστημα, παρέχει μια ποικιλία μεθόδων και μηχανισμών για **τις διαδικασίες να αλληλεπιδρούν, να επικοινωνούν και να μοιράζονται δεδομένα**. Ενώ αυτές οι τεχνικές είναι απαραίτητες για την αποδοτική λειτουργία του συστήματος, μπορούν επίσης να καταχραστούν από απειλητικούς παράγοντες για να **εκτελέσουν κακόβουλες δραστηριότητες**.

### Εισαγωγή Βιβλιοθηκών

Η Εισαγωγή Βιβλιοθηκών είναι μια τεχνική όπου ένας επιτιθέμενος **αναγκάζει μια διαδικασία να φορτώσει μια κακόβουλη βιβλιοθήκη**. Μόλις εισαχθεί, η βιβλιοθήκη εκτελείται στο πλαίσιο της στοχοθετημένης διαδικασίας, παρέχοντας στον επιτιθέμενο τις ίδιες άδειες και πρόσβαση με τη διαδικασία.

{{#ref}}
macos-library-injection/
{{#endref}}

### Hooking Συναρτήσεων

Το Hooking Συναρτήσεων περιλαμβάνει **παρεμβολές σε κλήσεις συναρτήσεων** ή μηνύματα εντός ενός κώδικα λογισμικού. Με το hooking συναρτήσεων, ένας επιτιθέμενος μπορεί να **τροποποιήσει τη συμπεριφορά** μιας διαδικασίας, να παρακολουθήσει ευαίσθητα δεδομένα ή ακόμη και να αποκτήσει έλεγχο της ροής εκτέλεσης.

{{#ref}}
macos-function-hooking.md
{{#endref}}

### Επικοινωνία Μεταξύ Διαδικασιών

Η Επικοινωνία Μεταξύ Διαδικασιών (IPC) αναφέρεται σε διάφορες μεθόδους με τις οποίες ξεχωριστές διαδικασίες **μοιράζονται και ανταλλάσσουν δεδομένα**. Ενώ η IPC είναι θεμελιώδης για πολλές νόμιμες εφαρμογές, μπορεί επίσης να καταχραστεί για να υπονομεύσει την απομόνωση διαδικασιών, να διαρρεύσει ευαίσθητες πληροφορίες ή να εκτελέσει μη εξουσιοδοτημένες ενέργειες.

{{#ref}}
macos-ipc-inter-process-communication/
{{#endref}}

### Εισαγωγή Εφαρμογών Electron

Οι εφαρμογές Electron που εκτελούνται με συγκεκριμένες μεταβλητές περιβάλλοντος θα μπορούσαν να είναι ευάλωτες σε εισαγωγή διαδικασίας:

{{#ref}}
macos-electron-applications-injection.md
{{#endref}}

### Εισαγωγή Chromium

Είναι δυνατόν να χρησιμοποιηθούν οι σημαίες `--load-extension` και `--use-fake-ui-for-media-stream` για να εκτελέσετε μια **επίθεση man in the browser** επιτρέποντας την κλοπή πληκτρολογήσεων, κυκλοφορίας, cookies, την εισαγωγή scripts σε σελίδες...:

{{#ref}}
macos-chromium-injection.md
{{#endref}}

### Dirty NIB

Τα αρχεία NIB **ορίζουν στοιχεία διεπαφής χρήστη (UI)** και τις αλληλεπιδράσεις τους εντός μιας εφαρμογής. Ωστόσο, μπορούν να **εκτελούν αυθαίρετες εντολές** και **ο Gatekeeper δεν σταματά** μια ήδη εκτελούμενη εφαρμογή από το να εκτελείται αν ένα **αρχείο NIB έχει τροποποιηθεί**. Επομένως, θα μπορούσαν να χρησιμοποιηθούν για να κάνουν αυθαίρετα προγράμματα να εκτελούν αυθαίρετες εντολές:

{{#ref}}
macos-dirty-nib.md
{{#endref}}

### Εισαγωγή Εφαρμογών Java

Είναι δυνατόν να καταχραστεί ορισμένες δυνατότητες java (όπως η **`_JAVA_OPTS`** μεταβλητή περιβάλλοντος) για να κάνει μια εφαρμογή java να εκτελεί **αυθαίρετο κώδικα/εντολές**.

{{#ref}}
macos-java-apps-injection.md
{{#endref}}

### Εισαγωγή Εφαρμογών .Net

Είναι δυνατόν να εισαχθεί κώδικας σε εφαρμογές .Net καταχρώντας τη **λειτουργικότητα αποσφαλμάτωσης .Net** (όχι προστατευμένη από τις προστασίες macOS όπως η σκληροποίηση χρόνου εκτέλεσης).

{{#ref}}
macos-.net-applications-injection.md
{{#endref}}

### Εισαγωγή Perl

Ελέγξτε διάφορες επιλογές για να κάνετε ένα σενάριο Perl να εκτελεί αυθαίρετο κώδικα στο:

{{#ref}}
macos-perl-applications-injection.md
{{#endref}}

### Εισαγωγή Ruby

Είναι επίσης δυνατόν να καταχραστεί η μεταβλητή περιβάλλοντος ruby για να εκτελούνται αυθαίρετα scripts:

{{#ref}}
macos-ruby-applications-injection.md
{{#endref}}

### Εισαγωγή Python

Αν η μεταβλητή περιβάλλοντος **`PYTHONINSPECT`** είναι ρυθμισμένη, η διαδικασία python θα εισέλθει σε μια CLI python μόλις ολοκληρωθεί. Είναι επίσης δυνατόν να χρησιμοποιηθεί το **`PYTHONSTARTUP`** για να υποδείξει ένα σενάριο python που θα εκτελείται στην αρχή μιας διαδραστικής συνεδρίας.\
Ωστόσο, σημειώστε ότι το σενάριο **`PYTHONSTARTUP`** δεν θα εκτελείται όταν το **`PYTHONINSPECT`** δημιουργεί τη διαδραστική συνεδρία.

Άλλες μεταβλητές περιβάλλοντος όπως **`PYTHONPATH`** και **`PYTHONHOME`** θα μπορούσαν επίσης να είναι χρήσιμες για να κάνουν μια εντολή python να εκτελεί αυθαίρετο κώδικα.

Σημειώστε ότι τα εκτελέσιμα αρχεία που έχουν μεταγλωττιστεί με **`pyinstaller`** δεν θα χρησιμοποιούν αυτές τις μεταβλητές περιβάλλοντος ακόμη και αν εκτελούνται χρησιμοποιώντας μια ενσωματωμένη python.

> [!CAUTION]
> Γενικά δεν μπόρεσα να βρω έναν τρόπο να κάνω την python να εκτελεί αυθαίρετο κώδικα καταχρώντας τις μεταβλητές περιβάλλοντος.\
> Ωστόσο, οι περισσότεροι άνθρωποι εγκαθιστούν την python χρησιμοποιώντας **Hombrew**, το οποίο θα εγκαταστήσει την python σε μια **γραφτή τοποθεσία** για τον προεπιλεγμένο διαχειριστή χρήστη. Μπορείτε να την καταλάβετε με κάτι τέτοιο:
>
> ```bash
> mv /opt/homebrew/bin/python3 /opt/homebrew/bin/python3.old
> cat > /opt/homebrew/bin/python3 <<EOF
> #!/bin/bash
> # Extra hijack code
> /opt/homebrew/bin/python3.old "$@"
> EOF
> chmod +x /opt/homebrew/bin/python3
> ```
>
> Ακόμη και **root** θα εκτελέσει αυτόν τον κώδικα όταν εκτελεί python.

## Ανίχνευση

### Shield

[**Shield**](https://theevilbit.github.io/shield/) ([**Github**](https://github.com/theevilbit/Shield)) είναι μια εφαρμογή ανοιχτού κώδικα που μπορεί να **ανιχνεύσει και να αποκλείσει ενέργειες εισαγωγής διαδικασίας**:

- Χρησιμοποιώντας **Μεταβλητές Περιβάλλοντος**: Θα παρακολουθεί την παρουσία οποιασδήποτε από τις παρακάτω μεταβλητές περιβάλλοντος: **`DYLD_INSERT_LIBRARIES`**, **`CFNETWORK_LIBRARY_PATH`**, **`RAWCAMERA_BUNDLE_PATH`** και **`ELECTRON_RUN_AS_NODE`**
- Χρησιμοποιώντας κλήσεις **`task_for_pid`**: Για να βρει πότε μια διαδικασία θέλει να αποκτήσει το **task port μιας άλλης** που επιτρέπει την εισαγωγή κώδικα στη διαδικασία.
- **Παράμετροι εφαρμογών Electron**: Κάποιος μπορεί να χρησιμοποιήσει τα **`--inspect`**, **`--inspect-brk`** και **`--remote-debugging-port`** επιχειρήματα γραμμής εντολών για να ξεκινήσει μια εφαρμογή Electron σε λειτουργία αποσφαλμάτωσης, και έτσι να εισάγει κώδικα σε αυτήν.
- Χρησιμοποιώντας **συμβολικούς συνδέσμους** ή **σκληρούς συνδέσμους**: Συνήθως η πιο κοινή κατάχρηση είναι να **τοποθετήσετε έναν σύνδεσμο με τα δικαιώματα του χρήστη μας**, και **να τον δείξετε σε μια τοποθεσία υψηλότερης άδειας**. Η ανίχνευση είναι πολύ απλή και για τους σκληρούς και για τους συμβολικούς συνδέσμους. Αν η διαδικασία που δημιουργεί τον σύνδεσμο έχει **διαφορετικό επίπεδο άδειας** από το αρχείο στόχο, δημιουργούμε μια **ειδοποίηση**. Δυστυχώς, στην περίπτωση των συμβολικών συνδέσμων, η απαγόρευση δεν είναι δυνατή, καθώς δεν έχουμε πληροφορίες σχετικά με τον προορισμό του συνδέσμου πριν από τη δημιουργία του. Αυτή είναι μια περιοριστική του πλαισίου EndpointSecuriy της Apple.

### Κλήσεις που γίνονται από άλλες διαδικασίες

Στο [**αυτό το blog post**](https://knight.sc/reverse%20engineering/2019/04/15/detecting-task-modifications.html) μπορείτε να βρείτε πώς είναι δυνατόν να χρησιμοποιήσετε τη συνάρτηση **`task_name_for_pid`** για να αποκτήσετε πληροφορίες σχετικά με άλλες **διαδικασίες που εισάγουν κώδικα σε μια διαδικασία** και στη συνέχεια να αποκτήσετε πληροφορίες σχετικά με αυτήν την άλλη διαδικασία.

Σημειώστε ότι για να καλέσετε αυτή τη συνάρτηση πρέπει να είστε **ο ίδιος uid** με αυτόν που εκτελεί τη διαδικασία ή **root** (και επιστρέφει πληροφορίες σχετικά με τη διαδικασία, όχι έναν τρόπο να εισάγετε κώδικα).

## Αναφορές

- [https://theevilbit.github.io/shield/](https://theevilbit.github.io/shield/)
- [https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f)

{{#include ../../../banners/hacktricks-training.md}}
