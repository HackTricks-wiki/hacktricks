{{#include ../../banners/hacktricks-training.md}}

Kod i więcej informacji w [https://mas.owasp.org/MASTG/iOS/0x06h-Testing-Platform-Interaction/#object-persistence](https://mas.owasp.org/MASTG/iOS/0x06h-Testing-Platform-Interaction/#object-persistence).

## Serializacja obiektów w rozwoju iOS

W iOS, **serializacja obiektów** polega na konwertowaniu obiektów na format, który można łatwo przechowywać lub przesyłać, a następnie rekonstruowaniu ich z tego formatu w razie potrzeby. Dwa główne protokoły, **`NSCoding`** i **`NSSecureCoding`**, ułatwiają ten proces dla Objective-C lub podklas `NSObject`, pozwalając na serializację obiektów do **`NSData`**, formatu, który opakowuje buforami bajtowymi.

### **`NSCoding`** Implementacja

Aby zaimplementować `NSCoding`, klasa musi dziedziczyć po `NSObject` lub być oznaczona jako `@objc`. Protokół ten wymaga implementacji dwóch metod do kodowania i dekodowania zmiennych instancji:
```swift
class CustomPoint: NSObject, NSCoding {
var x: Double = 0.0
var name: String = ""

func encode(with aCoder: NSCoder) {
aCoder.encode(x, forKey: "x")
aCoder.encode(name, forKey: "name")
}

required convenience init?(coder aDecoder: NSCoder) {
guard let name = aDecoder.decodeObject(forKey: "name") as? String else { return nil }
self.init(x: aDecoder.decodeDouble(forKey: "x"), name: name)
}
}
```
### **Zwiększanie bezpieczeństwa za pomocą `NSSecureCoding`**

Aby złagodzić luki, w których atakujący wstrzykują dane do już skonstruowanych obiektów, **`NSSecureCoding`** oferuje ulepszony protokół. Klasy zgodne z `NSSecureCoding` muszą weryfikować typ obiektów podczas dekodowania, zapewniając, że tylko oczekiwane typy obiektów są instancjonowane. Należy jednak zauważyć, że chociaż `NSSecureCoding` zwiększa bezpieczeństwo typów, nie szyfruje danych ani nie zapewnia ich integralności, co wymaga dodatkowych środków w celu ochrony wrażliwych informacji:
```swift
static var supportsSecureCoding: Bool {
return true
}

let obj = decoder.decodeObject(of: MyClass.self, forKey: "myKey")
```
## Archiwizacja danych za pomocą `NSKeyedArchiver`

`NSKeyedArchiver` i jego odpowiednik, `NSKeyedUnarchiver`, umożliwiają kodowanie obiektów do pliku i późniejsze ich odzyskiwanie. Mechanizm ten jest przydatny do utrwalania obiektów:
```swift
NSKeyedArchiver.archiveRootObject(customPoint, toFile: "/path/to/archive")
let customPoint = NSKeyedUnarchiver.unarchiveObjectWithFile("/path/to/archive") as? CustomPoint
```
### Używanie `Codable` do uproszczonej serializacji

Protokół `Codable` w Swift łączy `Decodable` i `Encodable`, ułatwiając kodowanie i dekodowanie obiektów takich jak `String`, `Int`, `Double` itd., bez dodatkowego wysiłku:
```swift
struct CustomPointStruct: Codable {
var x: Double
var name: String
}
```
To podejście wspiera proste serializowanie do i z list właściwości oraz JSON, co poprawia obsługę danych w aplikacjach Swift.

## Alternatywy kodowania JSON i XML

Poza natywnym wsparciem, kilka bibliotek firm trzecich oferuje możliwości kodowania/odkodowywania JSON i XML, z których każda ma swoje własne cechy wydajnościowe i kwestie bezpieczeństwa. Niezwykle ważne jest staranne wybieranie tych bibliotek, szczególnie w celu złagodzenia podatności, takich jak ataki XXE (XML External Entities), poprzez konfigurowanie parserów w celu zapobiegania przetwarzaniu zewnętrznych encji.

### Kwestie bezpieczeństwa

Podczas serializowania danych, szczególnie do systemu plików, istotne jest, aby być czujnym na potencjalne włączenie wrażliwych informacji. Zserializowane dane, jeśli zostaną przechwycone lub niewłaściwie obsłużone, mogą narażać aplikacje na ryzyko, takie jak nieautoryzowane działania lub wyciek danych. Zaleca się szyfrowanie i podpisywanie zserializowanych danych w celu zwiększenia bezpieczeństwa.

## Odniesienia

- [https://mas.owasp.org/MASTG/iOS/0x06h-Testing-Platform-Interaction/#object-persistence](https://mas.owasp.org/MASTG/iOS/0x06h-Testing-Platform-Interaction/#object-persistence)

{{#include ../../banners/hacktricks-training.md}}
