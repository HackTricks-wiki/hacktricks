# iOS Serialisation and Encoding

{{#include ../../banners/hacktricks-training.md}}

Code and more information in [https://mas.owasp.org/MASTG/iOS/0x06h-Testing-Platform-Interaction/#object-persistence](https://mas.owasp.org/MASTG/iOS/0x06h-Testing-Platform-Interaction/#object-persistence).

## Object Serialization in iOS Development

In iOS, **object serialization** involves converting objects into a format that can be easily stored or transmitted, and then reconstructing them from this format when needed. Two main protocols, **`NSCoding`** and **`NSSecureCoding`**, facilitate this process for Objective-C or `NSObject` subclasses, allowing objects to be serialized into **`NSData`**, a format that wraps byte buffers.

### **`NSCoding`** Implementation

To implement `NSCoding`, a class must inherit from `NSObject` or be marked as `@objc`. This protocol mandates the implementation of two methods for encoding and decoding instance variables:

```swift
class CustomPoint: NSObject, NSCoding {
    var x: Double = 0.0
    var name: String = ""

    func encode(with aCoder: NSCoder) {
        aCoder.encode(x, forKey: "x")
        aCoder.encode(name, forKey: "name")
    }

    required convenience init?(coder aDecoder: NSCoder) {
        guard let name = aDecoder.decodeObject(forKey: "name") as? String else { return nil }
        self.init(x: aDecoder.decodeDouble(forKey: "x"), name: name)
    }
}
```

### **Enhancing Security with `NSSecureCoding`**

To mitigate vulnerabilities where attackers inject data into already constructed objects, **`NSSecureCoding`** offers an enhanced protocol. Classes conforming to `NSSecureCoding` must verify the type of objects during decoding, ensuring that only the expected object types are instantiated. However, it's crucial to note that while `NSSecureCoding` enhances type safety, it doesn't encrypt data or ensure its integrity, necessitating additional measures for protecting sensitive information:

```swift
static var supportsSecureCoding: Bool {
    return true
}

let obj = decoder.decodeObject(of: MyClass.self, forKey: "myKey")
```

## Data Archiving with `NSKeyedArchiver`

`NSKeyedArchiver` and its counterpart, `NSKeyedUnarchiver`, enable encoding objects into a file and later retrieving them. This mechanism is useful for persisting objects:

```swift
NSKeyedArchiver.archiveRootObject(customPoint, toFile: "/path/to/archive")
let customPoint = NSKeyedUnarchiver.unarchiveObjectWithFile("/path/to/archive") as? CustomPoint
```

### Using `Codable` for Simplified Serialization

Swift's `Codable` protocol combines `Decodable` and `Encodable`, facilitating the encoding and decoding of objects like `String`, `Int`, `Double`, etc., without extra effort:

```swift
struct CustomPointStruct: Codable {
    var x: Double
    var name: String
}
```

This approach supports straightforward serialization to and from property lists and JSON, enhancing data handling in Swift applications.

## JSON and XML Encoding Alternatives

Beyond native support, several third-party libraries offer JSON and XML encoding/decoding capabilities, each with its own performance characteristics and security considerations. It's imperative to carefully select these libraries, especially to mitigate vulnerabilities like XXE (XML External Entities) attacks by configuring parsers to prevent external entity processing.

### Security Considerations

When serializing data, especially to the file system, it's essential to be vigilant about the potential inclusion of sensitive information. Serialized data, if intercepted or improperly handled, can expose applications to risks such as unauthorized actions or data leakage. Encrypting and signing serialized data is recommended to enhance security.

#### Pointer leaks via serialization order of pointer-keyed collections (NSDictionary/NSKeyedArchiver)

A subtle, non-timing, non-memory-safety infoleak can arise during a deserialize → re-serialize round trip when keyed collections are enumerated in an order that depends on pointer-derived hashing or pointer order.

- Root cause: Prior to Apple’s March 31, 2025 fixes, `NSKeyedArchiver` deterministically serialized `NSDictionary`/`NSSet` by iterating their internal order. In some cases that order mirrored the hash-table bucket order or tree order of the underlying collection. If any key’s `-hash` or ordering depends on its address (e.g., singletons/class objects inheriting `NSObject`’s pointer-based `-hash`), then the relative position of that entry in the serialized stream encodes bits of that pointer.
- Attack pattern: Pack a keyed collection with many attacker-controlled entries whose hashes collide into chosen buckets; include one entry whose hash/order depends on a secret pointer (e.g., `[NSNull null]` or a class object from the dyld shared cache). After the service unarchives with an allowlist and re-archives, the output bytes reflect the internal iteration order. The position of the secret-keyed entry among the attacker entries reveals which bucket it landed in, leaking low bits of the secret’s hash (and thus pointer) in a single round trip, without timing.

Minimal harness to demonstrate the primitive with a strict allowlist:

```objectivec
@import Foundation;
int main() {
  @autoreleasepool {
    NSArray *args = [[NSProcessInfo processInfo] arguments];
    if (args.count != 3) { return 1; }
    NSString *in_path = args[1];
    NSString *out_path = args[2];

    NSError *error = NULL;
    NSData *input_binary = /* ... read input bytes ... */ nil;
    id obj = [NSKeyedUnarchiver unarchivedObjectOfClasses:
                [NSSet setWithArray:@[NSDictionary.class, NSNumber.class, NSArray.class, NSNull.class]]
                                      fromData:input_binary
                                         error:&error];
    NSData *out = [NSKeyedArchiver archivedDataWithRootObject:obj
                                      requiringSecureCoding:YES
                                                      error:&error];
    /* ... write out to out_path ... */
  }
}
```

Signal model:
- If the table has B buckets (power of two), the bucket index leaks log2(B) low bits of the secret’s hash. If the hash is a function of the pointer value, those are pointer bits. With enough crafted collisions and layout control, a single round trip can leak a high-entropy subset of a dyld shared cache address (constant per boot and shared across processes), acting as a remote ASLR reduction.

Requirements for the oracle:
- The allowlist includes types whose hash/order can be pointer-derived (e.g., `NSNull`, some class objects).
- The archiver enumerates entries in internal hash/tree order (pre-fix behavior).
- The service returns the re-serialized data (directly or via logging/mirroring).
- The target pointer (e.g., shared cache base) is stable across processes in the same boot.

Mitigations and current status:
- Fixed by Apple in the March 31, 2025 security releases. Post-fix behavior removes or randomizes address dependence and/or applies canonical ordering during serialization.
- General guidance for any platform/stack:
  - Do not derive `-hash`/ordering from raw pointers for objects that cross trust boundaries; use address-independent hashing (e.g., per-process random salt) and stable, canonical serialization order.
  - Normalize/sort dictionary/set entries by a canonical key order prior to serialization.
  - Avoid deserialize → re-serialize of untrusted graphs; prefer schema-based formats that define a canonical order.
  - For Java and other ecosystems, use deserialization filtering and safer formats when possible.

Related ordering leaks:
- Similar ordering-based pointer disclosures exist where user-visible iteration reflects pointer order, e.g., Linux `/proc/self/fdinfo/<epoll>` lists watched fds by in-order traversal of an rb-tree effectively keyed by `struct file*` address. Such ordering leaks can defeat pointer-tagging mitigations.

## References

- [MASTG: Object Persistence](https://mas.owasp.org/MASTG/iOS/0x06h-Testing-Platform-Interaction/#object-persistence)
- [Pointer leaks through pointer-keyed data structures (Project Zero, 2025-09-26)](https://googleprojectzero.blogspot.com/2025/09/pointer-leaks-through-pointer-keyed.html)
- [Apple security updates – March 31, 2025](https://support.apple.com/en-us/122373)
- [28C3 – Effective DoS on web application platforms (hashDoS) – slides](https://fahrplan.events.ccc.de/congress/2011/Fahrplan/attachments/2007_28C3_Effective_DoS_on_web_application_platforms.pdf)
- [28C3 – Effective DoS on web application platforms (hashDoS) – recording](https://media.ccc.de/v/28c3-4680-en-effective_dos_attacks_against_web_application_platforms)
- [Phrack 53 – Solar Designer: scanlogd and collision-induced worst cases](https://phrack.org/issues/53/13)
- [Firefox 2016 timing-based infoleak via JS Map hashing](https://thejh.net/misc/firefox-cve-2016-9904-and-cve-2017-5378-bugreport)
- [Mozilla bug 1312001](https://bugzilla.mozilla.org/show_bug.cgi?id=1312001)
- [Chromium security: side-channel threat model](https://chromium.googlesource.com/chromium/src/+/master/docs/security/side-channel-threat-model.md)
- [Project Zero 2021 – Linux epoll rb-tree ordering leak](https://googleprojectzero.blogspot.com/2021/10/how-simple-linux-kernel-memory.html)
- [Java serialization filters (JDK 21 docs)](https://docs.oracle.com/en/java/javase/21/core/java-serialization-filters.html)
- [WOOT’15 – One class to rule them all: Android serialization](https://www.usenix.org/system/files/conference/woot15/woot15-paper-peles.pdf)

{{#include ../../banners/hacktricks-training.md}}