{{#include ../../banners/hacktricks-training.md}}

Код та більше інформації в [https://mas.owasp.org/MASTG/iOS/0x06h-Testing-Platform-Interaction/#object-persistence](https://mas.owasp.org/MASTG/iOS/0x06h-Testing-Platform-Interaction/#object-persistence).

## Сериалізація об'єктів у розробці iOS

У iOS **сериалізація об'єктів** передбачає перетворення об'єктів у формат, який можна легко зберігати або передавати, а потім відновлювати їх з цього формату за потреби. Два основні протоколи, **`NSCoding`** та **`NSSecureCoding`**, полегшують цей процес для Objective-C або підкласів `NSObject`, дозволяючи об'єктам бути сериалізованими в **`NSData`**, формат, який обгортає байтові буфери.

### **`NSCoding`** Реалізація

Щоб реалізувати `NSCoding`, клас повинен успадковувати від `NSObject` або бути позначеним як `@objc`. Цей протокол вимагає реалізації двох методів для кодування та декодування змінних екземпляра:
```swift
class CustomPoint: NSObject, NSCoding {
var x: Double = 0.0
var name: String = ""

func encode(with aCoder: NSCoder) {
aCoder.encode(x, forKey: "x")
aCoder.encode(name, forKey: "name")
}

required convenience init?(coder aDecoder: NSCoder) {
guard let name = aDecoder.decodeObject(forKey: "name") as? String else { return nil }
self.init(x: aDecoder.decodeDouble(forKey: "x"), name: name)
}
}
```
### **Покращення безпеки з `NSSecureCoding`**

Щоб зменшити вразливості, коли зловмисники впроваджують дані в уже створені об'єкти, **`NSSecureCoding`** пропонує покращений протокол. Класи, що відповідають `NSSecureCoding`, повинні перевіряти тип об'єктів під час декодування, забезпечуючи, що лише очікувані типи об'єктів створюються. Однак важливо зазначити, що хоча `NSSecureCoding` покращує безпеку типів, він не шифрує дані і не забезпечує їх цілісність, що вимагає додаткових заходів для захисту чутливої інформації:
```swift
static var supportsSecureCoding: Bool {
return true
}

let obj = decoder.decodeObject(of: MyClass.self, forKey: "myKey")
```
## Архівування даних за допомогою `NSKeyedArchiver`

`NSKeyedArchiver` та його аналог `NSKeyedUnarchiver` дозволяють кодувати об'єкти у файл, а потім їх відновлювати. Цей механізм корисний для збереження об'єктів:
```swift
NSKeyedArchiver.archiveRootObject(customPoint, toFile: "/path/to/archive")
let customPoint = NSKeyedUnarchiver.unarchiveObjectWithFile("/path/to/archive") as? CustomPoint
```
### Використання `Codable` для спрощеної серіалізації

Протокол `Codable` в Swift поєднує `Decodable` та `Encodable`, полегшуючи кодування та декодування об'єктів, таких як `String`, `Int`, `Double` тощо, без додаткових зусиль:
```swift
struct CustomPointStruct: Codable {
var x: Double
var name: String
}
```
Цей підхід підтримує просту серіалізацію до та з списків властивостей і JSON, покращуючи обробку даних у Swift-додатках.

## Альтернативи кодування JSON та XML

Окрім нативної підтримки, кілька сторонніх бібліотек пропонують можливості кодування/декодування JSON та XML, кожна з яких має свої характеристики продуктивності та міркування безпеки. Важливо ретельно обирати ці бібліотеки, особливо для зменшення вразливостей, таких як атаки XXE (XML External Entities), налаштовуючи парсери для запобігання обробці зовнішніх сутностей.

### Міркування безпеки

При серіалізації даних, особливо до файлової системи, важливо бути уважним до потенційного включення чутливої інформації. Серіалізовані дані, якщо їх перехопити або неправильно обробити, можуть піддати додатки ризикам, таким як несанкціоновані дії або витік даних. Рекомендується шифрувати та підписувати серіалізовані дані для підвищення безпеки.

## Посилання

- [https://mas.owasp.org/MASTG/iOS/0x06h-Testing-Platform-Interaction/#object-persistence](https://mas.owasp.org/MASTG/iOS/0x06h-Testing-Platform-Interaction/#object-persistence)

{{#include ../../banners/hacktricks-training.md}}
