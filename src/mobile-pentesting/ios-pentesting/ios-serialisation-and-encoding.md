{{#include ../../banners/hacktricks-training.md}}

Código e mais informações em [https://mas.owasp.org/MASTG/iOS/0x06h-Testing-Platform-Interaction/#object-persistence](https://mas.owasp.org/MASTG/iOS/0x06h-Testing-Platform-Interaction/#object-persistence).

## Serialização de Objetos no Desenvolvimento iOS

Em iOS, **serialização de objetos** envolve converter objetos em um formato que pode ser facilmente armazenado ou transmitido, e então reconstruí-los a partir desse formato quando necessário. Dois protocolos principais, **`NSCoding`** e **`NSSecureCoding`**, facilitam esse processo para subclasses de Objective-C ou `NSObject`, permitindo que objetos sejam serializados em **`NSData`**, um formato que envolve buffers de bytes.

### Implementação de **`NSCoding`**

Para implementar `NSCoding`, uma classe deve herdar de `NSObject` ou ser marcada como `@objc`. Este protocolo exige a implementação de dois métodos para codificar e decodificar variáveis de instância:
```swift
class CustomPoint: NSObject, NSCoding {
var x: Double = 0.0
var name: String = ""

func encode(with aCoder: NSCoder) {
aCoder.encode(x, forKey: "x")
aCoder.encode(name, forKey: "name")
}

required convenience init?(coder aDecoder: NSCoder) {
guard let name = aDecoder.decodeObject(forKey: "name") as? String else { return nil }
self.init(x: aDecoder.decodeDouble(forKey: "x"), name: name)
}
}
```
### **Aprimorando a Segurança com `NSSecureCoding`**

Para mitigar vulnerabilidades onde atacantes injetam dados em objetos já construídos, **`NSSecureCoding`** oferece um protocolo aprimorado. Classes que se conformam ao `NSSecureCoding` devem verificar o tipo de objetos durante a decodificação, garantindo que apenas os tipos de objetos esperados sejam instanciados. No entanto, é crucial notar que, embora `NSSecureCoding` aprimore a segurança de tipo, não criptografa dados nem garante sua integridade, necessitando de medidas adicionais para proteger informações sensíveis:
```swift
static var supportsSecureCoding: Bool {
return true
}

let obj = decoder.decodeObject(of: MyClass.self, forKey: "myKey")
```
## Arquivamento de Dados com `NSKeyedArchiver`

`NSKeyedArchiver` e seu contraparte, `NSKeyedUnarchiver`, permitem codificar objetos em um arquivo e posteriormente recuperá-los. Esse mecanismo é útil para persistir objetos:
```swift
NSKeyedArchiver.archiveRootObject(customPoint, toFile: "/path/to/archive")
let customPoint = NSKeyedUnarchiver.unarchiveObjectWithFile("/path/to/archive") as? CustomPoint
```
### Usando `Codable` para Serialização Simplificada

O protocolo `Codable` do Swift combina `Decodable` e `Encodable`, facilitando a codificação e decodificação de objetos como `String`, `Int`, `Double`, etc., sem esforço extra:
```swift
struct CustomPointStruct: Codable {
var x: Double
var name: String
}
```
Esta abordagem suporta a serialização direta de e para listas de propriedades e JSON, melhorando o manuseio de dados em aplicações Swift.

## Alternativas de Codificação JSON e XML

Além do suporte nativo, várias bibliotecas de terceiros oferecem capacidades de codificação/decodificação JSON e XML, cada uma com suas próprias características de desempenho e considerações de segurança. É imperativo selecionar cuidadosamente essas bibliotecas, especialmente para mitigar vulnerabilidades como ataques XXE (XML External Entities) configurando os analisadores para evitar o processamento de entidades externas.

### Considerações de Segurança

Ao serializar dados, especialmente para o sistema de arquivos, é essencial estar atento à possível inclusão de informações sensíveis. Dados serializados, se interceptados ou manuseados de forma inadequada, podem expor aplicações a riscos como ações não autorizadas ou vazamento de dados. Recomenda-se criptografar e assinar dados serializados para aumentar a segurança.

## Referências

- [https://mas.owasp.org/MASTG/iOS/0x06h-Testing-Platform-Interaction/#object-persistence](https://mas.owasp.org/MASTG/iOS/0x06h-Testing-Platform-Interaction/#object-persistence)

{{#include ../../banners/hacktricks-training.md}}
