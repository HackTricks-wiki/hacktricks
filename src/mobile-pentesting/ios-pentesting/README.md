# iOS Pentesting

{{#include ../../banners/hacktricks-training.md}}

## iOS Basiese


{{#ref}}
ios-basics.md
{{#endref}}

## Toetsomgewing

In hierdie bladsy kan jy inligting vind oor die **iOS simulator**, **emulators** en **jailbreaking:**


{{#ref}}
ios-testing-environment.md
{{#endref}}

## Aanvanklike Analise

### Basiese iOS Toetsoperasies

Tydens die toetsing sal **verskeie operasies voorgestel word** (koppel aan die toestel, lees/skryf/oplaai/aflaai van lêers, gebruik sekere gereedskap...). Daarom, as jy nie weet hoe om enige van hierdie aksies uit te voer nie, **begin asseblief deur die bladsy te lees**:


{{#ref}}
basic-ios-testing-operations.md
{{#endref}}

> [!TIP]
> Vir die volgende stappe moet die **app op die toestel geïnstalleer** wees en die **IPA file** van die toepassing reeds verkry wees.\
> Lees die [Basic iOS Testing Operations](basic-ios-testing-operations.md) bladsy om te leer hoe om dit te doen.

### Basiese Statiese Analise

Sommige interessante iOS - IPA file dekompilers:

- [https://github.com/LaurieWired/Malimite](https://github.com/LaurieWired/Malimite)
- [https://ghidra-sre.org/](https://ghidra-sre.org/)

Dit word aanbeveel om die hulpmiddel [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) te gebruik om 'n outomatiese Statiese Analise op die IPA file uit te voer.

Identifikasie van **beskermings wat in die binêre lêer teenwoordig is**:

- **PIE (Position Independent Executable)**: Wanneer geaktiveer, laai die toepassing in 'n ewekansige geheueadres elke keer as dit begin, wat dit moeiliker maak om die aanvanklike geheueadres te voorspel.

```bash
otool -hv <app-binary> | grep PIE   # It should include the PIE flag
```

- **Stack Canaries**: Om die integriteit van die stapel te valideer, word 'n ‘canary’ waarde op die stapel geplaas voordat 'n funksie geroep word en weer geverifieer wanneer die funksie eindig.

```bash
otool -I -v <app-binary> | grep stack_chk   # It should include the symbols: stack_chk_guard and stack_chk_fail
```

- **ARC (Automatic Reference Counting)**: Om algemene geheuekorruptie-foute te voorkom

```bash
otool -I -v <app-binary> | grep objc_release   # It should include the _objc_release symbol
```

- **Encrypted Binary**: Die binêre lêer behoort geïnkripteer te wees

```bash
otool -arch all -Vl <app-binary> | grep -A5 LC_ENCRYPT   # The cryptid should be 1
```

**Identifikasie van Gevoelige/Onseker Funksies**

- **Swak Hashing-algoritmes**

```bash
# On the iOS device
otool -Iv <app> | grep -w "_CC_MD5"
otool -Iv <app> | grep -w "_CC_SHA1"

# On linux
grep -iER "_CC_MD5"
grep -iER "_CC_SHA1"
```

- **Onveilige willekeurige funksies**

```bash
# On the iOS device
otool -Iv <app> | grep -w "_random"
otool -Iv <app> | grep -w "_srand"
otool -Iv <app> | grep -w "_rand"

# On linux
grep -iER "_random"
grep -iER "_srand"
grep -iER "_rand"
```

- **Onveilige 'Malloc' Funksie**

```bash
# On the iOS device
otool -Iv <app> | grep -w "_malloc"

# On linux
grep -iER "_malloc"
```

- **Onveilige en Kwesbare Funksies**

```bash
# On the iOS device
otool -Iv <app> | grep -w "_gets"
otool -Iv <app> | grep -w "_memcpy"
otool -Iv <app> | grep -w "_strncpy"
otool -Iv <app> | grep -w "_strlen"
otool -Iv <app> | grep -w "_vsnprintf"
otool -Iv <app> | grep -w "_sscanf"
otool -Iv <app> | grep -w "_strtok"
otool -Iv <app> | grep -w "_alloca"
otool -Iv <app> | grep -w "_sprintf"
otool -Iv <app> | grep -w "_printf"
otool -Iv <app> | grep -w "_vsprintf"

# On linux
grep -R "_gets"
grep -iER "_memcpy"
grep -iER "_strncpy"
grep -iER "_strlen"
grep -iER "_vsnprintf"
grep -iER "_sscanf"
grep -iER "_strtok"
grep -iER "_alloca"
grep -iER "_sprintf"
grep -iER "_printf"
grep -iER "_vsprintf"
```

#### Algemene jailbreak-detekteringsmetodes

- **Lêerstelselkontroles**: Kyk na die teenwoordigheid van algemene jailbreak-lêers en gidse, soos `/Applications/Cydia.app` of `/Library/MobileSubstrate/MobileSubstrate.dylib`.
- **Sandbox-oortredings**: Probeer toegang kry tot beperkte areas van die lêerstelsel, wat op nie-jailbroken toestelle geblokkeer behoort te wees.
- **API Kontroles**: Kyk of dit moontlik is om verbode oproepe soos `fork()` te gebruik om 'n kindproses te skep of `system()` om te sien of /bin/sh bestaan.
- **Proseskontroles**: Moniteer vir die teenwoordigheid van bekende jailbreak-verwante prosesse, soos `Cydia`, `Substrate`, of `ssh`.
- **Kernel Exploits**: Kyk na die teenwoordigheid van kern-exploits wat algemeen in jailbreaks gebruik word.
- **Omgewingsveranderlikes**: Inspekteer omgewingsveranderlikes vir tekens van 'n jailbreak, soos `DYLD_INSERT_LIBRARIES`.
- **Biblioteekkontrole**: Kyk na die libs wat in die app-proses gelaai is.
- **Kontroleer schemes**: Soos `canOpenURL(URL(string: "cydia://"))`.

#### Algemene anti-debugging-detekteringsmetodes

- **Kontroleer of 'n debugger teenwoordig is**: Gebruik `sysctl` of ander metodes om te check of 'n debugger aangeheg is.
- **Anti-Debugging API's**: Soek vir oproepe na anti-debugging API's soos `ptrace` of `SIGSTOP`, byvoorbeeld `ptrace(PT_DENY_ATTACH, 0, 0, 0)`.
- **Tydsmetings**: Meet die tyd wat sekere operasies neem en kyk vir afwykings wat debugging kan aandui.
- **Geheuekontroles**: Inspekteer geheue vir bekende debugger-artifakte of modifikasies.
- **Omgewingsveranderlikes**: Kyk na omgewingsveranderlikes wat 'n debugging-sessie kan aandui.
- **Mach-porte**: Detecteer of mach exception-porte deur debuggers gebruik word.

### Basiese Dinamiese Analise

Kyk na die dinamiese analise wat [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) uitvoer. Jy sal deur die verskillende views moet navigeer en daarmee moet interakteer; dit sal egter verskeie classes hook en 'n verslag voorberei sodra jy klaar is.

### Lys van Geïnstalleerde Apps

Gebruik die opdrag `frida-ps -Uai` om die **bundle identifier** van die geïnstalleerde apps te bepaal:
```bash
$ frida-ps -Uai
PID  Name                 Identifier
----  -------------------  -----------------------------------------
6847  Calendar             com.apple.mobilecal
6815  Mail                 com.apple.mobilemail
-  App Store            com.apple.AppStore
-  Apple Store          com.apple.store.Jolly
-  Calculator           com.apple.calculator
-  Camera               com.apple.camera
-  iGoat-Swift          OWASP.iGoat-Swift
```
### Basiese Enumeration & Hooking

Leer hoe om die components van die toepassing te enumerate en hoe om maklik methods en classes met objection te hook:

{{#ref}}
ios-hooking-with-objection.md
{{#endref}}

### IPA Struktuur

Die struktuur van 'n **IPA file** is in wese dié van 'n **gezipte pakket**. Deur die uitbreiding na `.zip` te hernoem, kan dit **ge-dekomprimeer** word om die inhoud te openbaar. Binne hierdie struktuur verteenwoordig 'n **Bundle** 'n volledig gepaketteerde toepassing wat gereed is vir installasie. Binne-in sal jy 'n gids genaamd `<NAME>.app` vind, wat die toepassing se hulpbronne inkapsuleer.

- **`Info.plist`**: Hierdie lêer bevat spesifieke konfigurasie-besonderhede van die toepassing.
- **`_CodeSignature/`**: Hierdie gids sluit 'n plist-lêer in wat 'n handtekening bevat, wat die integriteit van alle lêers in die bundle verseker.
- **`Assets.car`**: 'n Gekompresseerde argief wat asset-lêers soos ikone stoor.
- **`Frameworks/`**: Hierdie vouer huisves die toepassing se native biblioteke, wat in die vorm van `.dylib` of `.framework` lêers kan wees.
- **`PlugIns/`**: Dit kan uitbreidings van die toepassing insluit, bekend as `.appex` lêers, alhoewel dit nie altyd teenwoordig is nie. \* [**`Core Data`**](https://developer.apple.com/documentation/coredata): Dit word gebruik om jou toepassing se permanente data vir offline gebruik te stoor, om tydelike data te cache, en om undo-funksionaliteit op 'n enkele toestel by te voeg. Om data oor veelvuldige toestelle in 'n enkele iCloud-rekening te sinkroniseer, spiegel Core Data outomaties jou skema na 'n CloudKit-container.
- [**`PkgInfo`**](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigApplications.html): Die `PkgInfo` lêer is 'n alternatiewe manier om die tipe- en maker-kodes van jou toepassing of bundle te spesifiseer.
- **en.lproj, fr.proj, Base.lproj**: Dit is die taalpakke wat hulpbronne vir daardie spesifieke tale bevat, en 'n standaardhulpbron ingeval 'n taal nie ondersteun word nie.
- **Security**: Die `_CodeSignature/` gids speel 'n kritieke rol in die app se sekuriteit deur die integriteit van alle gebundelde lêers deur digitale handtekeninge te verifieer.
- **Asset Management**: Die `Assets.car` lêer gebruik kompressie om grafiese assets doeltreffend te bestuur, noodsaaklik vir die optimalisering van toepassingsprestasie en die vermindering van die totale grootte.
- **Frameworks and PlugIns**: Hierdie gidse beklemtoon die modulariteit van iOS-toepassings, wat ontwikkelaars toelaat om herbruikbare kodebiblioteke (`Frameworks/`) in te sluit en app-funksionaliteit uit te brei (`PlugIns/`).
- **Localization**: Die struktuur ondersteun veelvuldige tale, wat wêreldwye toepassingsbereik vergemaklik deur hulpbronne vir spesifieke taalpakke in te sluit.

**Info.plist**

Die **Info.plist** dien as 'n hoeksteen vir iOS-toepassings en kapsel sleutelkonfigurasiedata in die vorm van **key-value** pare. Hierdie lêer is noodsaaklik nie net vir toepassings nie, maar ook vir app-uitbreidings en frameworks wat binne gebundel is. Dit is gestruktureer in óf XML óf 'n binêre formaat en bevat kritiese inligting wat wissel van app-magtigings tot sekuriteitskonfigurasies. Vir 'n gedetailleerde ondersoek van beskikbare sleutels, kan verwys word na die [**Apple Developer Documentation**](https://developer.apple.com/documentation/bundleresources/information_property_list?language=objc).

Vir dié wat met hierdie lêer in 'n meer toeganklike formaat wil werk, kan die XML-omsetting moeiteloos bereik word deur die gebruik van `plutil` op macOS (natiurlik beskikbaar op weergawes 10.2 en later) of `plistutil` op Linux. Die opdragte vir omskakeling is soos volg:

- **For macOS**:
```bash
$ plutil -convert xml1 Info.plist
```
- **Vir Linux**:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
Onder die menigte inligting wat die **Info.plist**-lêer kan prijsgee, sluit noemenswaardige inskrywings in app-toestemmingsstringe (`UsageDescription`), pasgemaakte URL-skemas (`CFBundleURLTypes`), en konfigurasies vir App Transport Security (`NSAppTransportSecurity`). Hierdie inskrywings, saam met ander soos uitgevoerde/ingevoerde pasgemaakte dokumenttipes (`UTExportedTypeDeclarations` / `UTImportedTypeDeclarations`), kan moeiteloos gevind word deur die lêer te ondersoek of 'n eenvoudige `grep`-opdrag te gebruik:
```bash
$ grep -i <keyword> Info.plist
```
**Data-paaie**

In die iOS-omgewing is gidse spesifiek aangewys vir **stelseltoepassings** en **deur gebruikers geïnstalleerde toepassings**. Stelseltoepassings woon in die `/Applications` gids, terwyl deur gebruikers geïnstalleerde apps geplaas word onder `/var/mobile/containers/Data/Application/`. Hierdie toepassings kry 'n unieke identifiseerder bekend as 'n **128-bit UUID**, wat dit moeilik maak om handmatig 'n app se gids op te spoor weens die ewekansigheid van die gidsname.

> [!WARNING]
> Aangesien toepassings in iOS gesandbox moet wees, sal elke app ook 'n gids binne **`$HOME/Library/Containers`** hê met die app se **`CFBundleIdentifier`** as die gidsnaam.
>
> However, both folders (data & container folders) have the file **`.com.apple.mobile_container_manager.metadata.plist`** that links both files in the key `MCMetadataIdentifier`).

Om die vind van 'n deur gebruiker geïnstalleerde app se installasiegids te vergemaklik, bied die **objection tool** 'n nuttige opdrag, `env`. Hierdie opdrag openbaar gedetaileerde gidsinligting vir die betrokke app. Hieronder is 'n voorbeeld van hoe om hierdie opdrag te gebruik:
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # env

Name               Path
-----------------  -------------------------------------------------------------------------------------------
BundlePath         /var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app
CachesDirectory    /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library/Caches
DocumentDirectory  /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Documents
LibraryDirectory   /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library
```
Alternatiewelik kan die app-naam binne `/private/var/containers` met die `find`-opdrag gesoek word:
```bash
find /private/var/containers -name "Progname*"
```
Opdragte soos `ps` en `lsof` kan ook gebruik word om die app se proses te identifiseer en onderskeidelik oop lêers te lys, wat insigte verskaf oor die app se aktiewe gidsbane:
```bash
ps -ef | grep -i <app-name>
lsof -p <pid> | grep -i "/containers" | head -n 1
```
**Bundel-gids:**

- **AppName.app**
- Dit is die aansoekbundel soos vroeër in die IPA gesien; dit bevat noodsaaklike toepassingsdata, statiese inhoud sowel as die aansoek se saamgestelde binêr.
- Hierdie gids is sigbaar vir gebruikers, maar **gebruikers kan nie daarin skryf nie**.
- Inhoud in hierdie gids word **nie gerugsteun nie**.
- Die inhoud van hierdie vouer word gebruik om die **kodehandtekening te valideer**.

**Datagids:**

- **Documents/**
- Bevat alle gebruiker-gegenereerde data. Die eindgebruiker van die aansoek initieer die skep van hierdie data.
- Sigbaar vir gebruikers en **gebruikers kan daarin skryf**.
- Inhoud in hierdie gids word **gerugsteun**.
- Die aansoek kan paaie uitskakel deur `NSURLIsExcludedFromBackupKey` te stel.
- **Library/**
- Bevat alle **lêers wat nie gebruikerspesifiek is nie**, soos **caches**, **preferences**, **cookies**, en property list (plist) konfigurasielêers.
- iOS-apps gebruik gewoonlik die `Application Support` en `Caches` subgidse, maar die aansoek kan eie subgidse skep.
- **Library/Caches/**
- Bevat **semi-permanente gecachte lêers.**
- Onsigbaar vir gebruikers en **gebruikers kan nie daarin skryf nie**.
- Inhoud in hierdie gids word **nie gerugsteun nie**.
- Die OS kan die lêers in hierdie gids outomaties verwyder wanneer die aansoek nie loop nie en stoorplek min is.
- **Library/Application Support/**
- Bevat **permanente** **lêers** wat nodig is vir die werking van die aansoek.
- **Onsigbaar** **vir** **gebruikers** en gebruikers kan nie daarin skryf nie.
- Inhoud in hierdie gids word **gerug** **steun**.
- Die aansoek kan paaie uitskakel deur `NSURLIsExcludedFromBackupKey` te stel.
- **Library/Preferences/**
- Word gebruik om eienskappe te stoor wat **behou kan word selfs nadat 'n aansoek herbegin is**.
- Inligting word onversleuteld gestoor binne die aansoek-sandkis in 'n plist-lêer genaamd \[BUNDLE_ID].plist.
- Al die sleutel/waarde-paartjies wat gestoor is met `NSUserDefaults` is in hierdie lêer te vind.
- **tmp/**
- Gebruik hierdie gids om **tydelike lêers** te skryf wat nie tussen opstartings van die aansoek hoef te bly nie.
- Bevat nie-permanente gecachte lêers.
- **Onsigbaar** vir gebruikers.
- Inhoud in hierdie gids word nie gerugsteun nie.
- Die OS kan die lêers in hierdie gids outomaties verwyder wanneer die aansoek nie loop nie en stoorplek min is.

Kom ons kyk nader na iGoat-Swift se Application Bundle (.app) gids binne die Bundel-gids (`/var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app`):
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # ls
NSFileType      Perms  NSFileProtection    ...  Name
------------  -------  ------------------  ...  --------------------------------------
Regular           420  None                ...  rutger.html
Regular           420  None                ...  mansi.html
Regular           420  None                ...  splash.html
Regular           420  None                ...  about.html

Regular           420  None                ...  LICENSE.txt
Regular           420  None                ...  Sentinel.txt
Regular           420  None                ...  README.txt
```
### Binary Reversing

Binne die `<application-name>.app` gids sal jy 'n binêre lêer met die naam `<application-name>` vind. Dit is die lêer wat **uitgevoer** sal word. Jy kan 'n basiese inspeksie van die binêre met die hulpmiddel **`otool`** uitvoer:
```bash
otool -Vh DVIA-v2 #Check some compilation attributes
magic  cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64    ARM64        ALL  0x00     EXECUTE    65       7112   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE

otool -L DVIA-v2 #Get third party libraries
DVIA-v2:
/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.1)
/usr/lib/libsqlite3.dylib (compatibility version 9.0.0, current version 274.6.0)
/usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11)
@rpath/Bolts.framework/Bolts (compatibility version 1.0.0, current version 1.0.0)
[...]
```
**Kontroleer of die app versleut is**

Kyk of daar enige uitset is vir:
```bash
otool -l <app-binary> | grep -A 4 LC_ENCRYPTION_INFO
```
**Disassembling the binary**

Disassemble die text section:
```bash
otool -tV DVIA-v2
DVIA-v2:
(__TEXT,__text) section
+[DDLog initialize]:
0000000100004ab8    sub    sp, sp, #0x60
0000000100004abc    stp    x29, x30, [sp, #0x50]   ; Latency: 6
0000000100004ac0    add    x29, sp, #0x50
0000000100004ac4    sub    x8, x29, #0x10
0000000100004ac8    mov    x9, #0x0
0000000100004acc    adrp    x10, 1098 ; 0x10044e000
0000000100004ad0    add    x10, x10, #0x268
```
Om die **Objective-C gedeelte** van die voorbeeldtoepassing uit te druk, kan jy die volgende gebruik:
```bash
otool -oV DVIA-v2
DVIA-v2:
Contents of (__DATA,__objc_classlist) section
00000001003dd5b8 0x1004423d0 _OBJC_CLASS_$_DDLog
isa        0x1004423a8 _OBJC_METACLASS_$_DDLog
superclass 0x0 _OBJC_CLASS_$_NSObject
cache      0x0 __objc_empty_cache
vtable     0x0
data       0x1003de748
flags          0x80
instanceStart  8
```
Om 'n meer kompakte Objective-C code te kry, kan jy [**class-dump**](http://stevenygard.com/projects/class-dump/) gebruik:
```bash
class-dump some-app
//
//     Generated by class-dump 3.5 (64 bit).
//
//     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2013 by Steve Nygard.
//

#pragma mark Named Structures

struct CGPoint {
double _field1;
double _field2;
};

struct CGRect {
struct CGPoint _field1;
struct CGSize _field2;
};

struct CGSize {
double _field1;
double _field2;
};
```
However, the best options to disassemble the binary are: [**Hopper**](https://www.hopperapp.com/download.html?) and [**IDA**](https://www.hex-rays.com/products/ida/support/download_freeware/).

## Dataopberging

To learn about how iOS stores data in the device read this page:


{{#ref}}
ios-basics.md
{{#endref}}

> [!WARNING]
> Die volgende plekke om inligting te stoor moet **direk na die installering van die toepassing**, **na die nagaan van al die funksionaliteite** van die toepassing en selfs ná **uitlog van een gebruiker en aanmelding as 'n ander'** gekontroleer word.\
> Die doel is om **onbeskermde sensitiewe inligting** van die toepassing (wagwoorde, tokens), van die huidige gebruiker en van voorheen aangemelde gebruikers te vind.

### Plist

**plist** files are structured XML files that **contains key-value pairs**. It's a way to store persistent data, so sometimes you may find **sensitive information in these files**. It's recommended to check these files after installing the app and after using intensively it to see if new data is written.

Die mees algemene manier om data in plist-lêers te behou is deur die gebruik van **NSUserDefaults**. Hierdie plist-lêer word binne die app sandbox gestoor in **`Library/Preferences/<appBundleID>.plist`**

The [`NSUserDefaults`](https://developer.apple.com/documentation/foundation/nsuserdefaults) class provides a programmatic interface for interacting with the default system. The default system allows an application to customize its behaviour according to **user preferences**. Data saved by `NSUserDefaults` can be viewed in the application bundle. This class stores **data** in a **plist** **file**, but it's meant to be used with small amounts of data.

Hierdie data kan nie langer direk via 'n vertroude rekenaar toeganklik wees nie, maar kan bereik word deur 'n **backup**.

You can **dump** the information saved using **`NSUserDefaults`** using objection's `ios nsuserdefaults get`

Om al die plist's wat deur die toepassing gebruik word te vind, kan jy toegang kry tot `/private/var/mobile/Containers/Data/Application/{APPID}` en uitvoer:
```bash
find ./ -name "*.plist"
```
Om lêers van **XML of binary (bplist)** formaat na XML om te skakel, is daar verskeie metodes beskikbaar, afhangend van jou bedryfstelsel:

**Vir macOS-gebruikers:** Gebruik die `plutil` opdrag. Dit is 'n ingeboude hulpmiddel in macOS (10.2+), ontwerp vir hierdie doel:
```bash
$ plutil -convert xml1 Info.plist
```
**Vir Linux-gebruikers:** Installeer eers `libplist-utils`, gebruik dan `plistutil` om jou lêer te omskep:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
**Binne 'n Objection Session:** Om mobiele toepassings te ontleed, laat 'n spesifieke opdrag jou toe om plist-lêers direk te omskep:
```bash
ios plist cat /private/var/mobile/Containers/Data/Application/<Application-UUID>/Library/Preferences/com.some.package.app.plist
```
### Core Data

[`Core Data`](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/nsfetchedresultscontroller.html#//apple_ref/doc/uid/TP40001075-CH8-SW1) is 'n raamwerk vir die bestuur van die modellaag van objekte in jou toepassing. [Core Data can use SQLite as its persistent store](https://cocoacasts.com/what-is-the-difference-between-core-data-and-sqlite/), maar die raamwerk self is nie 'n databasis nie.\
CoreData enkripteer nie sy data standaard nie. Daar kan egter 'n addisionele enkripsielaag by CoreData gevoeg word. Sien die [GitHub Repo](https://github.com/project-imas/encrypted-core-data) vir meer besonderhede.

Jy kan die SQLite Core Data-inligting van 'n toepassing vind in die pad `/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support`

**As jy die SQLite kan open en toegang tot sensitiewe inligting kry, het jy 'n verkeerde konfigurasie gevind.**
```objectivec:Code from iGoat
-(void)storeDetails {
AppDelegate * appDelegate = (AppDelegate *)(UIApplication.sharedApplication.delegate);

NSManagedObjectContext *context =[appDelegate managedObjectContext];

User *user = [self fetchUser];
if (user) {
return;
}
user = [NSEntityDescription insertNewObjectForEntityForName:@"User"
inManagedObjectContext:context];
user.email = CoreDataEmail;
user.password = CoreDataPassword;
NSError *error;
if (![context save:&error]) {
NSLog(@"Error in saving data: %@", [error localizedDescription]);

}else{
NSLog(@"data stored in core data");
}
}
```
### YapDatabase

[YapDatabase](https://github.com/yapstudios/YapDatabase) is 'n key/value-stoor wat op SQLite gebou is.\
Aangesien Yap-databasisse SQLite-databasisse is, kan jy hulle vind deur die beoogde opdrag in die vorige afdeling te gebruik.

### Ander SQLite Databasisse

Dit is algemeen dat toepassings hul eie SQLite-databasis skep. Hulle mag **stoor** **sensitiewe** **data** daarin en dit ongeënkripteer laat. Daarom is dit altyd interessant om elke databasis binne die toepassingsgids na te gaan. Gaan dus na die toepassingsgids waar die data gestoor word (`/private/var/mobile/Containers/Data/Application/{APPID}`)
```bash
find ./ -name "*.sqlite" -or -name "*.db"
```
### Firebase Real-Time Databases

Ontwikkelaars kan **berg en sinkroniseer data** binne 'n **NoSQL cloud-hosted database** deur Firebase Real-Time Databases. In JSON-formaat gestoor, word die data in reële tyd na alle gekoppelde kliënte gesinchroniseer.

Hier kan jy vind hoe om verkeerd gekonfigureerde Firebase-databasisse te kontroleer:


{{#ref}}
../../network-services-pentesting/pentesting-web/buckets/firebase-database.md
{{#endref}}

### Realm databases

[Realm Objective-C](https://realm.io/docs/objc/latest/) en [Realm Swift](https://realm.io/docs/swift/latest/) bied 'n kragtige alternatief vir dataopberging wat nie deur Apple verskaf word nie. Per verstek stoor hulle **data ongeënkripteer**, met enkripsie beskikbaar via spesifieke konfigurasie.

Die databasisse is geleë by: `/private/var/mobile/Containers/Data/Application/{APPID}`. Om hierdie lêers te verken, kan mens opdragte soos die volgende gebruik:
```bash
iPhone:/private/var/mobile/Containers/Data/Application/A079DF84-726C-4AEA-A194-805B97B3684A/Documents root# ls
default.realm  default.realm.lock  default.realm.management/  default.realm.note|

$ find ./ -name "*.realm*"
```
Om hierdie databasislêers te bekyk, word die [**Realm Studio**](https://github.com/realm/realm-studio) hulpmiddel aanbeveel.

Om enkripsie binne 'n Realm-databasis te implementeer, kan die volgende kodefragment gebruik word:
```swift
// Open the encrypted Realm file where getKey() is a method to obtain a key from the Keychain or a server
let config = Realm.Configuration(encryptionKey: getKey())
do {
let realm = try Realm(configuration: config)
// Use the Realm as normal
} catch let error as NSError {
// If the encryption key is wrong, `error` will say that it's an invalid database
fatalError("Error opening realm: \(error)")
}
```
### Couchbase Lite Databasisse

[Couchbase Lite](https://github.com/couchbase/couchbase-lite-ios) word beskryf as 'n **liggewig** en **ingeslote** databasis-enjin wat die **dokument-georiënteerde** (NoSQL) benadering volg. Ontwerp om plaaslik op **iOS** en **macOS** te wees, bied dit die vermoë om data naatloos te sinkroniseer.

Om potensiële Couchbase-databasisse op 'n toestel te identifiseer, moet die volgende gids ondersoek word:
```bash
ls /private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support/
```
### Cookies

iOS stoor die cookies van die apps in die **`Library/Cookies/cookies.binarycookies`** binne elke app se gids. Ontwikkelaars besluit egter soms om dit in die **keychain** te stoor, aangesien die genoemde **cookie file in backups toeganklik is**.

Om die cookie-lêer te ondersoek kan jy [**this python script**](https://github.com/mdegrazia/Safari-Binary-Cookie-Parser) gebruik of gebruik objection se **`ios cookies get`.**\
**Jy kan ook objection gebruik om** hierdie lêers na 'n JSON-formaat om te skakel en die data te inspekteer.
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios cookies get --json
[
{
"domain": "highaltitudehacks.com",
"expiresDate": "2051-09-15 07:46:43 +0000",
"isHTTPOnly": "false",
"isSecure": "false",
"name": "username",
"path": "/",
"value": "admin123",
"version": "0"
}
]
```
### Cache

Per verstek berg NSURLSession data, soos **HTTP requests and responses in the Cache.db** database. Hierdie databasis kan **sensitive data** bevat, indien tokens, gebruikersname of enige ander sensitiewe inligting in die kas gestoor is. Om die gekashde inligting te vind, maak die data-gids van die app oop (`/var/mobile/Containers/Data/Application/<UUID>`) en gaan na `/Library/Caches/<Bundle Identifier>`. The **WebKit cache is also being stored in the Cache.db** file. **Objection** can open and interact with the database with the command `sqlite connect Cache.db`, as it is a n**ormal SQLite database**.

Dit word **recommended to disable Caching this data**, aangesien dit sensitiewe inligting in die versoek of antwoord kan bevat. Die volgende lys toon verskeie maniere om dit te bereik:

1.  Dit word aanbeveel om gebergde antwoorde na logout te verwyder. Dit kan gedoen word met die deur Apple verskafde metode genaamd [`removeAllCachedResponses`](https://developer.apple.com/documentation/foundation/urlcache/1417802-removeallcachedresponses). Jy kan hierdie metode soos volg aanroep:

`URLCache.shared.removeAllCachedResponses()`

Hierdie metode sal alle gekashde versoeke en antwoorde uit die Cache.db-lêer verwyder.

2.  As jy nie die voordeel van cookies hoef te gebruik nie, word dit aanbeveel om bloot die [.ephemeral](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral) configuration property van URLSession te gebruik, wat die stoor van cookies en Caches sal uitskakel.

[Apple documentation](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral):

' n ephemeral session configuration object is soortgelyk aan 'n default session configuration (see default), behalwe dat die ooreenstemmende session object nie store caches, credential stores, of enige session-related data to disk nie. In plaas daarvan word session-related data in RAM gestoor. Die enigste tyd dat 'n ephemeral session data to disk skryf is wanneer jy dit vertel om die inhoud van 'n URL na 'n file te skryf.

3.  Cache kan ook gedeaktiveer word deur die Cache Policy op [.notAllowed](https://developer.apple.com/documentation/foundation/urlcache/storagepolicy/notallowed) te stel. Dit sal die stoor van Cache in enige vorm uitskakel, hetsy in geheue of op skyf.

### Snapshots

Wanneer jy die home-knoppie druk, neem iOS 'n snapshot van die huidige skerm om die oorgang tussen toepassings gladder te maak. As daar egter **sensitive** **data** op die huidige skerm is, sal dit in die **image** bewaar word (wat **persists** **across** **reboots**). Hierdie is die snapshots wat jy ook kan bereik deur dubbel op die home-knoppie te druk om tussen apps te wissel.

Tensy die iPhone jailbroken is, moet die **attacker** fisiese **access** tot die **device** hê en dit **unblocked** wees om hierdie skermkiekies te sien. Per verstek word die laaste snapshot in die toepassing se sandbox gestoor in `Library/Caches/Snapshots/` of `Library/SplashBoard/Snapshots` gids (trusted computers kan nie vanaf iOX 7.0 toegang tot die filesystem kry nie).

Een manier om hierdie swakheid te voorkom is om 'n leë skerm te wys of die sensitiewe data te verwyder voordat die snapshot geneem word deur die `ApplicationDidEnterBackground()` funksie te gebruik.

Die volgende is 'n voorbeeld van 'n remediasiemetode wat 'n standaard skermkiekie sal stel.

Swift:
```swift
private var backgroundImage: UIImageView?

func applicationDidEnterBackground(_ application: UIApplication) {
let myBanner = UIImageView(image: #imageLiteral(resourceName: "overlayImage"))
myBanner.frame = UIScreen.main.bounds
backgroundImage = myBanner
window?.addSubview(myBanner)
}

func applicationWillEnterForeground(_ application: UIApplication) {
backgroundImage?.removeFromSuperview()
}
```
Objective-C:
```
@property (UIImageView *)backgroundImage;

- (void)applicationDidEnterBackground:(UIApplication *)application {
UIImageView *myBanner = [[UIImageView alloc] initWithImage:@"overlayImage.png"];
self.backgroundImage = myBanner;
self.backgroundImage.bounds = UIScreen.mainScreen.bounds;
[self.window addSubview:myBanner];
}

- (void)applicationWillEnterForeground:(UIApplication *)application {
[self.backgroundImage removeFromSuperview];
}
```
Dit stel die agtergrondbeeld op `overlayImage.png` elke keer wanneer die toepassing na die agtergrond verskuif word. Dit voorkom sensitiewe data leaks omdat `overlayImage.png` altyd die huidige view sal oorskryf.

### Keychain

Vir toegang tot en bestuur van die iOS keychain is hulpmiddels soos [**Keychain-Dumper**](https://github.com/ptoomey3/Keychain-Dumper) beskikbaar, geskik vir jailbroken toestelle. Boonop bied [**Objection**](https://github.com/sensepost/objection) die opdrag `ios keychain dump` vir soortgelyke doeleindes.

#### **Stoor Kredensiale**

Die **NSURLCredential** klas is ideaal om sensitiewe inligting direk in die keychain te stoor, en om die behoefte aan NSUserDefaults of ander wrappers te omseil. Om kredensiale na login te stoor, word die volgende Swift-kode gebruik:
```swift
NSURLCredential *credential;
credential = [NSURLCredential credentialWithUser:username password:password persistence:NSURLCredentialPersistencePermanent];
[[NSURLCredentialStorage sharedCredentialStorage] setCredential:credential forProtectionSpace:self.loginProtectionSpace];
```
Om hierdie gestoorde inlogbewyse te onttrek, word Objection se opdrag `ios nsurlcredentialstorage dump` gebruik.

## **Pasgemaakte Toetsenborde en Toetsenbordkas**

Vanaf iOS 8.0 kan gebruikers pasgemaakte toetsenborduitbreidings installeer, wat bestuur kan word onder **Instellings > Algemeen > Toetsenbord > Toetsenborde**. Alhoewel hierdie toetsenborde uitgebreide funksionaliteit bied, hou hulle 'n risiko in van toetsaanslag-registrasie en die stuur van data na eksterne bedieners, alhoewel gebruikers ingelig word oor toetsenborde wat netwerktoegang benodig. Apps kan, en behoort, die gebruik van pasgemaakte toetsenborde vir die invoer van sensitiewe inligting te beperk.

**Sekuriteitsaanbevelings:**

- Dit word aanbeveel om derdeparty-toetsenborde te deaktiveer vir verbeterde sekuriteit.
- Wees bewus van die outokorreksie- en outo-voorstel-funksies van die standaard iOS-toetsenbord, wat sensitiewe inligting in kaslêers geleë by `Library/Keyboard/{locale}-dynamic-text.dat` of `/private/var/mobile/Library/Keyboard/dynamic-text.dat` kan stoor. Hierdie kaslêers moet gereeld op sensitiewe data gekontroleer word. Dit word aanbeveel om die toetsenbordwoordeboek te herstel via **Instellings > Algemeen > Herstel > Herstel Toetsenbordwoordeboek** om gekasde data skoon te maak.
- Die onderskep van netwerkverkeer kan openbaar of 'n pasgemaakte toetsenbord toetsaanslae op afstand stuur.

### **Voorkoming van teksveldkasvorming**

Die [UITextInputTraits protocol](https://developer.apple.com/reference/uikit/uitextinputtraits) bied eienskappe om outokorreksie en veilige teksinvoer te bestuur, wat noodsaaklik is om die kasvorming van sensitiewe inligting te voorkom. Byvoorbeeld, die deaktivering van outokorreksie en die aktivering van veilige teksinvoer kan bereik word met:
```objectivec
textObject.autocorrectionType = UITextAutocorrectionTypeNo;
textObject.secureTextEntry = YES;
```
Verder moet ontwikkelaars verseker dat teksvelde, veral dié vir die invoer van sensitiewe inligting soos wagwoorde en PINs, caching uitskakel deur `autocorrectionType` op `UITextAutocorrectionTypeNo` en `secureTextEntry` op `YES` te stel.
```objectivec
UITextField *textField = [[UITextField alloc] initWithFrame:frame];
textField.autocorrectionType = UITextAutocorrectionTypeNo;
```
## **Logs**

Foutopsporing van kode behels dikwels die gebruik van **logging**. Daar is 'n risiko, aangesien **logs sensitiewe inligting kan bevat**. Voorheen, in iOS 6 en vroeër weergawes, was logs vir alle apps toeganklik, wat 'n risiko van sensitiewe data leakage geskep het. **Nou is toepassings beperk tot slegs toegang tot hul logs**.

Ten spyte van hierdie beperkings kan 'n **aanvaller met fisiese toegang** tot 'n ontgrendelde toestel dit steeds misbruik deur die toestel aan 'n rekenaar te koppel en **lees die logs**. Dit is belangrik om daarop te let dat logs op die skyf bly selfs na die verwydering van die app.

Om risiko's te verminder, word dit aanbeveel om **grondig met die app te interaksioneer**, al die funksies en insette te verken om te verseker dat geen sensitiewe inligting per ongeluk in logs aangeteken word nie.

Wanneer jy die app se bronkode deurgaan vir potensiële leaks, kyk vir beide **voorafgedefinieerde** en **maatgemaakte logging statements** wat sleutelwoorde soos `NSLog`, `NSAssert`, `NSCAssert`, `fprintf` gebruik vir ingeboude funksies, en enige vermeldings van `Logging` of `Logfile` vir maatgemaakte implementasies.

### **Monitering van stelsel logs**

Apps log verskeie stukke inligting wat sensitief kan wees. Om hierdie logs te monitor, gereedskap en opdragte soos:
```bash
idevice_id --list   # To find the device ID
idevicesyslog -u <id> (| grep <app>)   # To capture the device logs
```
is nuttig. Boonop bied **Xcode** 'n manier om konsole-logboodskappe te versamel:

1. Maak **Xcode** oop.
2. Koppel die iOS-toestel.
3. Gaan na **Window** -> **Devices and Simulators**.
4. Kies jou toestel.
5. Veroorsaak die probleem wat jy ondersoek.
6. Gebruik die **Open Console**-knoppie om konsole-logboodskappe in 'n nuwe venster te besigtig.

Vir meer gevorderde logging kan jy aan die toestel se shell koppel en **socat** gebruik om logs in reële tyd te monitor:
```bash
iPhone:~ root# socat - UNIX-CONNECT:/var/run/lockdown/syslog.sock
```
Gevolg deur opdragte om logaktiwiteite waar te neem, wat uiters waardevol kan wees om probleme te diagnoseer of om potensiële data leakage in logs te identifiseer.

## Rugsteunkopieë

**Outo-rugsteunfunksies** is geïntegreer in iOS en vergemaklik die skep van kopieë van toesteldata deur iTunes (tot macOS Catalina), Finder (vanaf macOS Catalina af), of iCloud. Hierdie rugsteunkopieë sluit byna alle toesteldata in, uitgesonderd hoogs sensitiewe elemente soos Apple Pay-besonderhede en Touch ID-konfigurasies.

### Sekuriteitsrisiko's

Die insluiting van **geïnstalleerde apps en hul data** in rugsteunkopieë roep die kwessie op van potensiële **data leakage** en die risiko dat **wysigings aan rugsteunkopieë die funksionaliteit van 'n app kan verander**. Dit word aanbeveel om **nie sensitiewe inligting in platte teks te stoor** binne enige app se gids of subgidse om hierdie risiko's te verminder.

### Uitsluiting van lêers uit rugsteunkopieë

Lêers in `Documents/` en `Library/Application Support/` word standaard gerugsteun. Ontwikkelaars kan spesifieke lêers of gidse uitsluit van rugsteunkopieë deur `NSURL setResourceValue:forKey:error:` met die `NSURLIsExcludedFromBackupKey` te gebruik. Hierdie praktyk is belangrik om sensitiewe data te beskerm teen opname in rugsteunkopieë.

### Toetsing vir kwesbaarhede

Om 'n app se rugsteunsekuriteit te evalueer, begin deur **'n rugsteun te skep** met Finder, en lokaliseer dit volgens leiding van [Apple's official documentation](https://support.apple.com/en-us/HT204215). Ontleed die rugsteun vir sensitiewe data of konfigurasies wat verander kan word om die gedrag van die app te beïnvloed.

Sensitiewe inligting kan opgespoor word met opdragreël-gereedskap of toepassings soos [iMazing](https://imazing.com). Vir geënkripteerde rugsteunkopieë kan die teenwoordigheid van enkripsie bevestig word deur die "IsEncrypted" sleutel in die "Manifest.plist" lêer by die wortel van die rugsteun na te gaan.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
...
<key>Date</key>
<date>2021-03-12T17:43:33Z</date>
<key>IsEncrypted</key>
<true/>
...
</plist>
```
For dealing with encrypted backups, Python scripts available in [DinoSec's GitHub repo](https://github.com/dinosec/iphone-dataprotection/tree/master/python_scripts), like **backup_tool.py** and **backup_passwd.py**, may be useful, albeit potentially requiring adjustments for compatibility with the latest iTunes/Finder versions. The [**iOSbackup** tool](https://pypi.org/project/iOSbackup/) is another option for accessing files within password-protected backups.

### App-gedrag wysig

An example of altering app behavior through backup modifications is demonstrated in the [Bither bitcoin wallet app](https://github.com/bither/bither-ios), where the UI lock PIN is stored within `net.bither.plist` under the **pin_code** key. Removing this key from the plist and restoring the backup removes the PIN requirement, providing unrestricted access.

## Opsomming van geheue-toetsing vir sensitiewe data

When dealing with sensitive information stored in an application's memory, it is crucial to limit the exposure time of this data. There are two primary approaches to investigate memory content: **'n geheue-dump skep** and **ontleding van die geheue in reële tyd**. Both methods have their challenges, including the potential to miss critical data during the dump process or analysis.

## **Herwinning en ontleding van 'n geheue-dump**

For both jailbroken and non-jailbroken devices, tools like [objection](https://github.com/sensepost/objection) and [Fridump](https://github.com/Nightbringer21/fridump) allow for the dumping of an app's process memory. Once dumped, analyzing this data requires various tools, depending on the nature of the information you're searching for.

To extract strings from a memory dump, commands such as `strings` or `rabin2 -zz` can be used:
```bash
# Extracting strings using strings command
$ strings memory > strings.txt

# Extracting strings using rabin2
$ rabin2 -ZZ memory > strings.txt
```
Vir meer gedetailleerde ontleding, insluitend die soektog na spesifieke datatipes of patrone, bied **radare2** uitgebreide soekvermoëns:
```bash
$ r2 <name_of_your_dump_file>
[0x00000000]> /?
...
```
## **Runtime-geheue-analise**

**r2frida** bied 'n kragtige alternatief om die geheue van 'n app in real time te inspekteer, sonder dat 'n memory dump benodig word. Hierdie instrument maak dit moontlik om soekopdragte direk op die lopende aansoek se geheue uit te voer:
```bash
$ r2 frida://usb//<name_of_your_app>
[0x00000000]> /\ <search_command>
```
## Gebroke Kriptografie

### Swak Sleutelbestuursprosesse

Sommige ontwikkelaars stoor sensitiewe data in die lokale stoorplek en enkripteer dit met 'n sleutel hardcoded/predictable in die kode. Dit behoort nie te gebeur nie aangesien reversing aanvallers kan toelaat om die vertroulike inligting te onttrek.

### Gebruik van Onveilige en/of Verouderde Algoritmes

Ontwikkelaars behoort nie **deprecated algorithms** te gebruik om magtiging **checks** uit te voer, data te **store** of te **send** nie. Sommige van hierdie algoritmes is: RC4, MD4, MD5, SHA1... As **hashes** byvoorbeeld gebruik word om wagwoorde te stoor, behoort brute-force **resistant** hashes met 'n salt gebruik te word.

### Kontrole

Die hoofkontroles om uit te voer is om te kyk of jy **hardcoded** wagwoorde/geheime in die kode kan vind, of dit **predictable** is, en of die kode 'n soort **weak** **cryptography** algoritmes gebruik.

Dit is interessant om te weet dat jy sommige **crypto** **libraries** outomaties kan **monitor** met behulp van **objection** met:
```swift
ios monitor crypt
```
Vir **more information** about iOS-kriptografiese APIs en biblioteke, besoek [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography)

## Plaaslike autentisering

**Plaaslike autentisering** speel 'n kritieke rol, veral wanneer dit gaan oor die beskerming van toegang by 'n afgeleë eindpunt deur kriptografiese metodes. Die kern is dat sonder behoorlike implementering, plaaslike autentiseringsmeganismes omseil kan word.

Apple's [**Local Authentication framework**](https://developer.apple.com/documentation/localauthentication) and the [**keychain**](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html) voorsien robuuste APIs vir ontwikkelaars om gebruikersverifikasiedialoë te fasiliteer en onderskeidelik geheime data veilig te hanteer. Die Secure Enclave beveilig vingerafdruk-ID vir Touch ID, terwyl Face ID staatmaak op gesigsherkenning sonder om biometriese data in gevaar te stel.

Om Touch ID/Face ID te integreer, het ontwikkelaars twee API-opsies:

- **`LocalAuthentication.framework`** vir hoëvlak gebruikersverifikasie sonder toegang tot biometriese data.
- **`Security.framework`** vir laervlak toegang tot keychain-dienste, wat geheime data beveilig met biometriese verifikasie. Verskeie [open-source wrappers](https://www.raywenderlich.com/147308/secure-ios-user-data-keychain-touch-id) maak keychain-toegang eenvoudiger.

> [!CAUTION]
> Beide `LocalAuthentication.framework` en `Security.framework` het egter kwesbaarhede, omdat hulle hoofsaaklik boolean-waardes teruggee sonder om data vir verifikasieprosesse te stuur, wat hulle vatbaar maak vir omseiling (verwys na [Don't touch me that way, by David Lindner et al](https://www.youtube.com/watch?v=XhXIHVGCFFM)).

### Implementering van plaaslike autentisering

Om gebruikers vir verifikasie te vra, moet ontwikkelaars die **`evaluatePolicy`**-metode binne die **`LAContext`**-klas gebruik, en kies tussen:

- **`deviceOwnerAuthentication`**: Vra vir Touch ID of toestelwagwoord, en misluk as geen een geaktiveer is.
- **`deviceOwnerAuthenticationWithBiometrics`**: Vra uitsluitlik vir Touch ID.

'n Suksesvolle verifikasie word aangedui deur 'n boolean-terugwaarde van **`evaluatePolicy`**, wat 'n potensiële sekuriteitsfout uitlig.

### Plaaslike autentisering met Keychain

Die implementering van **plaASlike autentisering** in iOS-apps behels die gebruik van **keychain APIs** om geheime data soos verifikasie-tokens veilig te stoor. Hierdie proses verseker dat die data slegs deur die gebruiker benader kan word deur hul toestelwagwoord of biometriese verifikasie soos Touch ID.

Die keychain bied die vermoë om items te stel met die `SecAccessControl`-attribuut, wat toegang tot die item beperk totdat die gebruiker suksesvol geverifieer het via Touch ID of toestelwagwoord. Hierdie funksie is noodsaaklik om sekuriteit te verbeter.

Below are code examples in Swift and Objective-C demonstrating how to save and retrieve a string to/from the keychain, leveraging these security features. The examples specifically show how to set up access control to require Touch ID authentication and ensure the data is accessible only on the device it was set up on, under the condition that a device passcode is configured.

{{#tabs}}
{{#tab name="Swift"}}
```swift
// From https://github.com/mufambisi/owasp-mstg/blob/master/Document/0x06f-Testing-Local-Authentication.md

// 1. create AccessControl object that will represent authentication settings

var error: Unmanaged<CFError>?

guard let accessControl = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
SecAccessControlCreateFlags.biometryCurrentSet,
&error) else {
// failed to create AccessControl object

return
}

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute

var query: [String: Any] = [:]

query[kSecClass as String] = kSecClassGenericPassword
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecAttrAccount as String] = "OWASP Account" as CFString
query[kSecValueData as String] = "test_strong_password".data(using: .utf8)! as CFData
query[kSecAttrAccessControl as String] = accessControl

// 3. save item

let status = SecItemAdd(query as CFDictionary, nil)

if status == noErr {
// successfully saved
} else {
// error while saving
}
```
{{#endtab}}

{{#tab name="Objective-C"}}
```objectivec
// 1. create AccessControl object that will represent authentication settings
CFErrorRef *err = nil;

SecAccessControlRef sacRef = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
kSecAccessControlUserPresence,
err);

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute
NSDictionary* query = @{
(_ _bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecAttrAccount: @"OWASP Account",
(__bridge id)kSecValueData: [@"test_strong_password" dataUsingEncoding:NSUTF8StringEncoding],
(__bridge id)kSecAttrAccessControl: (__bridge_transfer id)sacRef
};

// 3. save item
OSStatus status = SecItemAdd((__bridge CFDictionaryRef)query, nil);

if (status == noErr) {
// successfully saved
} else {
// error while saving
}
```
{{#endtab}}
{{#endtabs}}

Nou kan ons die gestoorde item uit die keychain aanvra. Keychain services sal die verifikasie-dialoog aan die gebruiker toon en data of nil teruggee, afhangend of of 'n geskikte vingerafdruk voorsien is of nie.

{{#tabs}}
{{#tab name="Swift"}}
```swift
// 1. define query
var query = [String: Any]()
query[kSecClass as String] = kSecClassGenericPassword
query[kSecReturnData as String] = kCFBooleanTrue
query[kSecAttrAccount as String] = "My Name" as CFString
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecUseOperationPrompt as String] = "Please, pass authorisation to enter this area" as CFString

// 2. get item
var queryResult: AnyObject?
let status = withUnsafeMutablePointer(to: &queryResult) {
SecItemCopyMatching(query as CFDictionary, UnsafeMutablePointer($0))
}

if status == noErr {
let password = String(data: queryResult as! Data, encoding: .utf8)!
// successfully received password
} else {
// authorization not passed
}
```
{{#endtab}}

{{#tab name="Objective-C"}}
```objectivec
// 1. define query
NSDictionary *query = @{(__bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecReturnData: @YES,
(__bridge id)kSecAttrAccount: @"My Name1",
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecUseOperationPrompt: @"Please, pass authorisation to enter this area" };

// 2. get item
CFTypeRef queryResult = NULL;
OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)query, &queryResult);

if (status == noErr){
NSData* resultData = ( __bridge_transfer NSData* )queryResult;
NSString* password = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding];
NSLog(@"%@", password);
} else {
NSLog(@"Something went wrong");
}
```
{{#endtab}}
{{#endtabs}}

### Opsporing

Die gebruik van frameworks in 'n app kan ook opgespoor word deur die app-binaire se lys van gedeelde dinamiese biblioteke te ontleed. Dit kan gedoen word deur `otool` te gebruik:
```bash
$ otool -L <AppName>.app/<AppName>
```
As `LocalAuthentication.framework` in 'n app gebruik word, sal die uitset albei van die volgende reëls bevat (onthou dat `LocalAuthentication.framework` `Security.framework` onder die enjinkap gebruik):
```bash
/System/Library/Frameworks/LocalAuthentication.framework/LocalAuthentication
/System/Library/Frameworks/Security.framework/Security
```
If `Security.framework` gebruik word, sal slegs die tweede een getoon word.

### Local Authentication Framework Bypass

#### **Objection**

Deur die **Objection Biometrics Bypass**, geleë by [this GitHub page](https://github.com/sensepost/objection/wiki/Understanding-the-iOS-Biometrics-Bypass), is 'n tegniek beskikbaar om die **LocalAuthentication**-meganisme te oorkom. Die kern van hierdie benadering behels die gebruik van **Frida** om die `evaluatePolicy` funksie te manipuleer, sodat dit konsekwent `True` as uitkoms lewer, ongeag die werklike verifikasie sukses. Dit is veral nuttig om gebrekkige biometriese autentiseringsprosesse te omseil.

Om hierdie bypass te aktiveer, word die volgende opdrag gebruik:
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios ui biometrics_bypass
(agent) Registering job 3mhtws9x47q. Type: ios-biometrics-disable
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # (agent) [3mhtws9x47q] Localized Reason for auth requirement: Please authenticate yourself
(agent) [3mhtws9x47q] OS authentication response: false
(agent) [3mhtws9x47q] Marking OS response as True instead
(agent) [3mhtws9x47q] Biometrics bypass hook complete
```
Hierdie opdrag begin 'n reeks waarin Objection 'n taak registreer wat effektief die uitslag van die `evaluatePolicy`-kontrole na `True` verander.

#### Frida

'n Voorbeeld van die gebruik van **`evaluatePolicy`** uit [DVIA-v2 application](https://github.com/prateek147/DVIA-v2):
```swift
+(void)authenticateWithTouchID {
LAContext *myContext = [[LAContext alloc] init];
NSError *authError = nil;
NSString *myLocalizedReasonString = @"Please authenticate yourself";

if ([myContext canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&authError]) {
[myContext evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics
localizedReason:myLocalizedReasonString
reply:^(BOOL success, NSError *error) {
if (success) {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Successful" withTitle:@"Success"];
});
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Failed !" withTitle:@"Error"];
});
}
}];
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Your device doesn't support Touch ID or you haven't configured Touch ID authentication on your device" withTitle:@"Error"];
});
}
}
```
Om die **bypass** van Local Authentication te bereik, word 'n Frida script geskryf. Hierdie script mik op die **evaluatePolicy** check, onderskep die callback om te verseker dit returns **success=1**. Deur die callback se gedrag te verander, word die authentication check effectively bypassed.

Die script hieronder is injected om die resultaat van die **evaluatePolicy** method te wysig. Dit verander die callback se resultaat sodat dit altyd 'n sukses aandui.
```swift
// from https://securitycafe.ro/2022/09/05/mobile-pentesting-101-bypassing-biometric-authentication/
if(ObjC.available) {
console.log("Injecting...");
var hook = ObjC.classes.LAContext["- evaluatePolicy:localizedReason:reply:"];
Interceptor.attach(hook.implementation, {
onEnter: function(args) {
var block = new ObjC.Block(args[4]);
const callback = block.implementation;
block.implementation = function (error, value)  {

console.log("Changing the result value to true")
const result = callback(1, null);
return result;
};
},
});
} else {
console.log("Objective-C Runtime is not available!");
}
```
Om die Frida script te inject en die biometric authentication te bypass, word die volgende opdrag gebruik:
```bash
frida -U -f com.highaltitudehacks.DVIAswiftv2 --no-pause -l fingerprint-bypass-ios.js
```
## Blootstelling van sensitiewe funksionaliteit deur IPC

### Custom URI Handlers / Deeplinks / Custom Schemes


{{#ref}}
ios-custom-uri-handlers-deeplinks-custom-schemes.md
{{#endref}}

### Universal Links


{{#ref}}
ios-universal-links.md
{{#endref}}

### UIActivity Sharing


{{#ref}}
ios-uiactivity-sharing.md
{{#endref}}

### UIPasteboard


{{#ref}}
ios-uipasteboard.md
{{#endref}}

### App Extensions


{{#ref}}
ios-app-extensions.md
{{#endref}}

### WebViews


{{#ref}}
ios-webviews.md
{{#endref}}

### Serialisation and Encoding


{{#ref}}
ios-serialisation-and-encoding.md
{{#endref}}

## Netwerkkommunikasie

Dit is belangrik om te kontroleer dat geen kommunikasie plaasvind **sonder enkripsie** en ook dat die toepassing korrek die **TLS-sertifikaat** van die bediener valideer.\  
Om hierdie soort probleme te kontroleer kan jy 'n proxy soos **Burp** gebruik:


{{#ref}}
burp-configuration-for-ios.md
{{#endref}}

### Kontrole van gasheernaam

Een algemene probleem by die validering van die TLS-sertifikaat is om te kontroleer dat die sertifikaat deur 'n **betroubare** **CA** onderteken is, maar **nie te kontroleer** of **die hostname** van die sertifikaat die hostname is wat geraak word nie.\  
Om hierdie probleem met Burp te toets, nadat jy Burp CA op die iPhone vertrou het, kan jy **'n nuwe sertifikaat met Burp vir 'n ander hostname skep** en dit gebruik. As die toepassing steeds werk, is dit kwesbaar.

### Certificate Pinning

As 'n toepassing SSL Pinning korrek gebruik, sal die toepassing slegs werk as die sertifikaat die verwagte een is. Wanneer jy 'n toepassing toets **kan dit 'n probleem wees aangesien Burp sy eie sertifikaat sal bedien.**\  
Om hierdie beskerming binne 'n jailbroken toestel te omseil, kan jy die toepassing [**SSL Kill Switch**](https://github.com/nabla-c0d3/ssl-kill-switch2) installeer of [**Burp Mobile Assistant**](https://portswigger.net/burp/documentation/desktop/mobile/config-ios-device) installeer.

Jy kan ook **objection's** `ios sslpinning disable` gebruik

## Divers

- In **`/System/Library`** kan jy die frameworks vind wat op die telefoon geïnstalleer is en deur stelseltoepassings gebruik word
- Toepassings wat deur die gebruiker vanaf die App Store geïnstalleer is, is geleë in **`/User/Applications`**
- En **`/User/Library`** bevat data wat deur die gebruikervlak-toepassings gestoor is
- Jy kan toegang kry tot **`/User/Library/Notes/notes.sqlite`** om die notas wat binne die toepassing gestoor is te lees.
- Binne die gids van 'n geïnstalleerde toepassing (**`/User/Applications/<APP ID>/`**) kan jy 'n paar interessante lêers vind:
- **`iTunesArtwork`**: Die ikoon wat deur die app gebruik word
- **`iTunesMetadata.plist`**: Inligting oor die app wat in die App Store gebruik word
- **`/Library/*`**: Bevat die voorkeure en cache. In **`/Library/Cache/Snapshots/*`** kan jy die snapshot vind wat van die toepassing geneem is voordat dit na die agtergrond gestuur is.

### Hot Patching/Enforced Updateing

Ontwikkelaars kan op afstand alle installasies van hul app onmiddellik **patch** sonder om die toepassing weer by die App Store in te dien en te wag vir goedkeuring.\  
Hiervoor word gewoonlik [**JSPatch**](https://github.com/bang590/JSPatch) gebruik. Maar daar is ook ander opsies soos [Siren](https://github.com/ArtSabintsev/Siren) en [react-native-appstore-version-checker](https://www.npmjs.com/package/react-native-appstore-version-checker).\  
**Dit is 'n gevaarlike meganisme wat deur kwaadwillige derdeparty-SDKs misbruik kan word, daarom word aanbeveel om te kontroleer watter metode gebruik word vir outomatiese opdatering (indien enige) en dit te toets.** Jy kan probeer om 'n vorige weergawe van die app af te laai vir hierdie doel.

### Third Parties

'n Beduidende uitdaging met **3rd party SDKs** is die **gebrek aan fynkorrelige beheer** oor hul funksionaliteit. Ontwikkelaars staan voor 'n keuse: of hulle integreer die SDK en aanvaar al sy funksies, insluitend potensiële sekuriteits kwesbaarhede en privaatheidskwessies, of hulle laat die voordele daarvan heeltemal vaar. Dikwels kan ontwikkelaars nie self kwesbaarhede binne hierdie SDKs patch nie. Verder, soos SDKs vertroue binne die gemeenskap verwerf, kan sommige begin om malware te bevat.

Die dienste wat deur derdeparty-SDKs verskaf word kan insluit gebruiker-gedragopsporing, advertensie vertonings, of verbetering van gebruikerservaring. Dit maak egter 'n risiko omdat ontwikkelaars dalk nie ten volle bewus is van die kode wat deur hierdie biblioteke uitgevoer word nie, wat tot potensiële privaatheids- en sekuriteitsrisiko's kan lei. Dit is noodsaaklik om die inligting wat met derdeparty-dienste gedeel word te beperk tot wat nodig is en te verseker dat geen sensitiewe data blootgestel word nie.

Implementering van derdeparty-dienste kom gewoonlik in twee vorme voor: 'n aparte biblioteek of 'n volwaardige SDK. Om gebruikersprivaatheid te beskerm, moet enige data wat met hierdie dienste gedeel word **geanonimiseer** word om die openbaarmaking van Personal Identifiable Information (PII) te voorkom.

Om die biblioteke wat 'n toepassing gebruik te identifiseer, kan die **`otool`**-opdrag gebruik word. Hierdie hulpmiddel moet teen die toepassing en elke gedeelde biblioteek wat dit gebruik gedraai word om bykomende biblioteke te ontdek.
```bash
otool -L <application_path>
```
## Interessante Kwesbaarhede & Gevallestudies


{{#ref}}
air-keyboard-remote-input-injection.md
{{#endref}}

{{#ref}}
itunesstored-bookassetd-sandbox-escape.md
{{#endref}}

{{#ref}}
zero-click-messaging-image-parser-chains.md
{{#endref}}

## **Verwysings & Meer Hulpbronne**

- [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering)
- [iOS & Mobile App Pentesting - INE](https://my.ine.com/CyberSecurity/courses/089d060b/ios-mobile-app-pentesting)
- [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/)
- [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/)
- [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/)
- [https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage](https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage)
- [https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way](https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053)
- [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060)
- [https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/](https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064](https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064)
- [https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc](https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054)
- [https://github.com/ivRodriguezCA/RE-iOS-Apps/](https://github.com/ivRodriguezCA/RE-iOS-Apps/) iOS gratis kursus([https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/](https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/))
- [https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577](https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577)
- [https://www.slideshare.net/RyanISI/ios-appsecurityminicourse](https://www.slideshare.net/RyanISI/ios-appsecurityminicourse)
- [https://github.com/prateek147/DVIA](https://github.com/prateek147/DVIA)
- [https://github.com/prateek147/DVIA-v2](https://github.com/prateek147/DVIA-v2)
- [https://github.com/OWASP/MSTG-Hacking-Playground%20](https://github.com/OWASP/MSTG-Hacking-Playground)
- OWASP iGoat [_https://github.com/OWASP/igoat_](https://github.com/OWASP/igoat) <<< Objective-C weergawe [_https://github.com/OWASP/iGoat-Swift_](https://github.com/OWASP/iGoat-Swift) <<< Swift weergawe
- [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
- [https://github.com/nabla-c0d3/ssl-kill-switch2](https://github.com/nabla-c0d3/ssl-kill-switch2)


{{#include ../../banners/hacktricks-training.md}}
