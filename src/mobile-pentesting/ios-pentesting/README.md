# iOS Pentesting

{{#include ../../banners/hacktricks-training.md}}

## iOS Basics

{{#ref}}
ios-basics.md
{{#endref}}

## Testing Environment

In hierdie bladsy kan jy inligting vind oor die **iOS simulator**, **emulators** en **jailbreaking:**

{{#ref}}
ios-testing-environment.md
{{#endref}}

## Initial Analysis

### Basic iOS Testing Operations

Tydens die toetsing **sal verskeie operasies voorgestel word** (verbinde met die toestel, lees/skryf/oplaai/aflaai van lêers, gebruik van sommige gereedskap...). Daarom, as jy nie weet hoe om enige van hierdie aksies uit te voer nie, **begin asseblief om die bladsy te lees**:

{{#ref}}
basic-ios-testing-operations.md
{{#endref}}

> [!NOTE]
> Vir die volgende stappe **moet die app geïnstalleer wees** op die toestel en moet die **IPA-lêer** van die toepassing reeds verkry gewees het.\
> Lees die [Basic iOS Testing Operations](basic-ios-testing-operations.md) bladsy om te leer hoe om dit te doen.

### Basic Static Analysis

Sommige interessante iOS - IPA-lêer decompilers:

- https://github.com/LaurieWired/Malimite
- https://ghidra-sre.org/

Dit word aanbeveel om die gereedskap [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) te gebruik om 'n outomatiese Statiese Analise op die IPA-lêer uit te voer.

Identifikasie van **beskermings wat in die binêre teenwoordig is**:

- **PIE (Position Independent Executable)**: Wanneer geaktiveer, laai die toepassing in 'n ewekansige geheue adres elke keer wanneer dit begin, wat dit moeiliker maak om sy aanvanklike geheue adres te voorspel.

```bash
otool -hv <app-binary> | grep PIE   # Dit moet die PIE-vlag insluit
```

- **Stack Canaries**: Om die integriteit van die stapel te valideer, word 'n ‘canary’ waarde op die stapel geplaas voordat 'n funksie aangeroep word en weer geverifieer sodra die funksie eindig.

```bash
otool -I -v <app-binary> | grep stack_chk   # Dit moet die simbole insluit: stack_chk_guard en stack_chk_fail
```

- **ARC (Automatic Reference Counting)**: Om algemene geheue korrupsie foute te voorkom

```bash
otool -I -v <app-binary> | grep objc_release   # Dit moet die _objc_release simbool insluit
```

- **Encrypted Binary**: Die binêre moet geënkripteer wees

```bash
otool -arch all -Vl <app-binary> | grep -A5 LC_ENCRYPT   # Die cryptid moet 1 wees
```

**Identifikasie van Sensitiewe/Onveilige Funksies**

- **Weak Hashing Algorithms**

```bash
# Op die iOS toestel
otool -Iv <app> | grep -w "_CC_MD5"
otool -Iv <app> | grep -w "_CC_SHA1"

# Op linux
grep -iER "_CC_MD5"
grep -iER "_CC_SHA1"
```

- **Insecure Random Functions**

```bash
# Op die iOS toestel
otool -Iv <app> | grep -w "_random"
otool -Iv <app> | grep -w "_srand"
otool -Iv <app> | grep -w "_rand"

# Op linux
grep -iER "_random"
grep -iER "_srand"
grep -iER "_rand"
```

- **Insecure ‘Malloc’ Function**

```bash
# Op die iOS toestel
otool -Iv <app> | grep -w "_malloc"

# Op linux
grep -iER "_malloc"
```

- **Insecure and Vulnerable Functions**

```bash
# Op die iOS toestel
otool -Iv <app> | grep -w "_gets"
otool -Iv <app> | grep -w "_memcpy"
otool -Iv <app> | grep -w "_strncpy"
otool -Iv <app> | grep -w "_strlen"
otool -Iv <app> | grep -w "_vsnprintf"
otool -Iv <app> | grep -w "_sscanf"
otool -Iv <app> | grep -w "_strtok"
otool -Iv <app> | grep -w "_alloca"
otool -Iv <app> | grep -w "_sprintf"
otool -Iv <app> | grep -w "_printf"
otool -Iv <app> | grep -w "_vsprintf"

# Op linux
grep -R "_gets"
grep -iER "_memcpy"
grep -iER "_strncpy"
grep -iER "_strlen"
grep -iER "_vsnprintf"
grep -iER "_sscanf"
grep -iER "_strtok"
grep -iER "_alloca"
grep -iER "_sprintf"
grep -iER "_printf"
grep -iER "_vsprintf"
```

### Basic Dynamic Analysis

Kyk na die dinamiese analise wat [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) uitvoer. Jy sal deur die verskillende weergawes moet navigeer en met hulle moet interaksie hê, maar dit sal verskeie klasse aanraak terwyl dit ander dinge doen en 'n verslag voorberei sodra jy klaar is.

### Listing Installed Apps

Gebruik die opdrag `frida-ps -Uai` om die **bundle identifier** van die geïnstalleerde apps te bepaal:
```bash
$ frida-ps -Uai
PID  Name                 Identifier
----  -------------------  -----------------------------------------
6847  Calendar             com.apple.mobilecal
6815  Mail                 com.apple.mobilemail
-  App Store            com.apple.AppStore
-  Apple Store          com.apple.store.Jolly
-  Calculator           com.apple.calculator
-  Camera               com.apple.camera
-  iGoat-Swift          OWASP.iGoat-Swift
```
### Basiese Enumerasie & Hooking

Leer hoe om die **komponente van die toepassing te enumerate** en hoe om maklik **metodes en klasse te hook** met objection:

{{#ref}}
ios-hooking-with-objection.md
{{#endref}}

### IPA Struktuur

Die struktuur van 'n **IPA-lêer** is essensieel dié van 'n **gecomprimeerde pakket**. Deur sy uitbreiding na `.zip` te hernoem, kan dit **decomprimeer** word om sy inhoud te onthul. Binne hierdie struktuur verteenwoordig 'n **Bundle** 'n volledig verpakte toepassing wat gereed is vir installasie. Binne-in sal jy 'n gids met die naam `<NAME>.app` vind, wat die toepassing se hulpbronne bevat.

- **`Info.plist`**: Hierdie lêer hou spesifieke konfigurasiedetails van die toepassing.
- **`_CodeSignature/`**: Hierdie gids sluit 'n plist-lêer in wat 'n handtekening bevat, wat die integriteit van alle lêers in die bundel verseker.
- **`Assets.car`**: 'n Gecomprimeerde argief wat hulpbronlêers soos ikone stoor.
- **`Frameworks/`**: Hierdie gids huisves die toepassing se inheemse biblioteke, wat in die vorm van `.dylib` of `.framework` lêers kan wees.
- **`PlugIns/`**: Dit kan uitbreidings van die toepassing insluit, bekend as `.appex` lêers, alhoewel hulle nie altyd teenwoordig is. \* [**`Core Data`**](https://developer.apple.com/documentation/coredata): Dit word gebruik om jou toepassing se permanente data vir offline gebruik te stoor, om tydelike data te kas, en om ongedaan maak funksionaliteit aan jou app op 'n enkele toestel toe te voeg. Om data oor verskeie toestelle in 'n enkele iCloud-rekening te sinkroniseer, spieël Core Data outomaties jou skema na 'n CloudKit-container.
- [**`PkgInfo`**](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigApplications.html): Die `PkgInfo`-lêer is 'n alternatiewe manier om die tipe en skepper kodes van jou toepassing of bundel te spesifiseer.
- **en.lproj, fr.proj, Base.lproj**: Is die taal pakkette wat hulpbronne vir daardie spesifieke tale bevat, en 'n standaard hulpbron in die geval dat 'n taal nie ondersteun word nie.
- **Sekuriteit**: Die `_CodeSignature/` gids speel 'n kritieke rol in die app se sekuriteit deur die integriteit van alle gebundelde lêers deur digitale handtekeninge te verifieer.
- **Hulpbronbestuur**: Die `Assets.car`-lêer gebruik kompressie om grafiese hulpbronne doeltreffend te bestuur, wat noodsaaklik is vir die optimalisering van toepassingprestasie en die vermindering van die algehele grootte.
- **Frameworks en PlugIns**: Hierdie gidse beklemtoon die modulariteit van iOS-toepassings, wat ontwikkelaars in staat stel om herbruikbare kode biblioteke (`Frameworks/`) in te sluit en app-funksionaliteit uit te brei (`PlugIns/`).
- **Lokalizering**: Die struktuur ondersteun verskeie tale, wat globale toepassingsbereik fasiliteer deur hulpbronne vir spesifieke taal pakkette in te sluit.

**Info.plist**

Die **Info.plist** dien as 'n hoeksteen vir iOS-toepassings, wat sleutel konfigurasiedata in die vorm van **sleutel-waarde** pare kapsuleer. Hierdie lêer is 'n vereiste nie net vir toepassings nie, maar ook vir app-uitbreidings en frameworks wat binne ingesluit is. Dit is gestruktureer in óf XML óf 'n binêre formaat en hou kritieke inligting wat wissel van app-toestemmings tot sekuriteitskonfigurasies. Vir 'n gedetailleerde verkenning van beskikbare sleutels, kan 'n mens na die [**Apple Developer Documentation**](https://developer.apple.com/documentation/bundleresources/information_property_list?language=objc) verwys.

Vir diegene wat met hierdie lêer in 'n meer toeganklike formaat wil werk, kan die XML-omskakeling maklik bereik word deur die gebruik van `plutil` op macOS (beskikbaar vanweë op weergawes 10.2 en later) of `plistutil` op Linux. Die opdragte vir omskakeling is soos volg:

- **Vir macOS**:
```bash
$ plutil -convert xml1 Info.plist
```
- **Vir Linux**:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
Onder die menigte inligting wat die **Info.plist** lêer kan bekendmaak, sluit noemenswaardige inskrywings app toestemming stringe (`UsageDescription`), pasgemaakte URL skemas (`CFBundleURLTypes`), en konfigurasies vir App Transport Security (`NSAppTransportSecurity`) in. Hierdie inskrywings, saam met ander soos uitgevoerde/ingevoerde pasgemaakte dokumenttipes (`UTExportedTypeDeclarations` / `UTImportedTypeDeclarations`), kan maklik gevind word deur die lêer te ondersoek of 'n eenvoudige `grep` opdrag te gebruik:
```bash
$ grep -i <keyword> Info.plist
```
**Data Paaie**

In die iOS-omgewing is gidsen spesifiek aangewys vir **stelsels toepassings** en **gebruikers geïnstalleerde toepassings**. Stelsels toepassings woon in die `/Applications` gids, terwyl gebruikers geïnstalleerde toepassings onder `/var/mobile/containers/Data/Application/` geplaas word. Hierdie toepassings word toegeskryf aan 'n unieke identifiseerder bekend as 'n **128-bit UUID**, wat die taak om 'n app se gids handmatig te vind uitdagend maak weens die ewekansigheid van die gidsname.

> [!WARNING]
> Aangesien toepassings in iOS in 'n sandbox moet wees, sal elke app ook 'n gids hê binne **`$HOME/Library/Containers`** met die app se **`CFBundleIdentifier`** as die gidsnaam.
>
> egter, beide gidse (data & houer gidse) het die lêer **`.com.apple.mobile_container_manager.metadata.plist`** wat beide lêers verbind in die sleutel `MCMetadataIdentifier`).

Om die ontdekking van 'n gebruikers geïnstalleerde app se installasie gids te vergemaklik, bied die **objection tool** 'n nuttige opdrag, `env`. Hierdie opdrag onthul gedetailleerde gidsinligting vir die betrokke app. Hieronder is 'n voorbeeld van hoe om hierdie opdrag te gebruik:
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # env

Name               Path
-----------------  -------------------------------------------------------------------------------------------
BundlePath         /var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app
CachesDirectory    /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library/Caches
DocumentDirectory  /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Documents
LibraryDirectory   /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library
```
Alternatiewelik kan die app naam binne die `/private/var/containers` gesoek word met die `find` opdrag:
```bash
find /private/var/containers -name "Progname*"
```
Opdragte soos `ps` en `lsof` kan ook gebruik word om die app se proses te identifiseer en oop lêers te lys, onderskeidelik, wat insigte bied in die aansoek se aktiewe gidspade:
```bash
ps -ef | grep -i <app-name>
lsof -p <pid> | grep -i "/containers" | head -n 1
```
**Bundel gids:**

- **AppName.app**
- Dit is die Aansoek Bundel soos voorheen in die IPA gesien, dit bevat noodsaaklike aansoekdata, statiese inhoud sowel as die aansoek se gecompileerde binêre.
- Hierdie gids is sigbaar vir gebruikers, maar **gebruikers kan nie daarin skryf nie**.
- Inhoud in hierdie gids is **nie gebackup nie**.
- Die inhoud van hierdie gids word gebruik om die **kodehandtekening te valideer**.

**Data gids:**

- **Dokumente/**
- Bevat al die gebruiker-gegenereerde data. Die aansoek eindgebruiker begin die skepping van hierdie data.
- Sigbaar vir gebruikers en **gebruikers kan daarin skryf**.
- Inhoud in hierdie gids is **gebackup**.
- Die aansoek kan paaie deaktiveer deur `NSURLIsExcludedFromBackupKey` in te stel.
- **Biblioteek/**
- Bevat al **lêers wat nie gebruiker-spesifiek is nie**, soos **kas**, **voorkeure**, **koekies**, en eiendomslys (plist) konfigurasielêers.
- iOS aansoeke gebruik gewoonlik die `Application Support` en `Caches` subgidsen, maar die aansoek kan pasgemaakte subgidsen skep.
- **Biblioteek/Kas/**
- Bevat **semi-permanente gekapte lêers.**
- Onsigbaar vir gebruikers en **gebruikers kan nie daarin skryf nie**.
- Inhoud in hierdie gids is **nie gebackup nie**.
- Die OS mag hierdie gids se lêers outomaties verwyder wanneer die aansoek nie loop nie en stoorplek laag is.
- **Biblioteek/Aansoekondersteuning/**
- Bevat **permanente** **lêers** wat nodig is om die aansoek te laat loop.
- **Onsigbaar** **vir** **gebruikers** en gebruikers kan nie daarin skryf nie.
- Inhoud in hierdie gids is **geback** **up**.
- Die aansoek kan paaie deaktiveer deur `NSURLIsExcludedFromBackupKey` in te stel.
- **Biblioteek/Voorkeure/**
- Gebruik om eienskappe te stoor wat kan **volhard selfs nadat 'n aansoek herbegin is**.
- Inligting word onversleuteld, binne die aansoek sandbox in 'n plist-lêer genaamd \[BUNDLE_ID].plist gestoor.
- Alle sleutel/waarde pare wat met `NSUserDefaults` gestoor is, kan in hierdie lêer gevind word.
- **tmp/**
- Gebruik hierdie gids om **tydelike lêers** te skryf wat nie tussen aansoeklopies moet volhard nie.
- Bevat nie-permanente gekapte lêers.
- **Onsigbaar** vir gebruikers.
- Inhoud in hierdie gids is nie gebackup nie.
- Die OS mag hierdie gids se lêers outomaties verwyder wanneer die aansoek nie loop nie en stoorplek laag is.

Kom ons kyk nader na iGoat-Swift se Aansoek Bundel (.app) gids binne die Bundel gids (`/var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app`):
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # ls
NSFileType      Perms  NSFileProtection    ...  Name
------------  -------  ------------------  ...  --------------------------------------
Regular           420  None                ...  rutger.html
Regular           420  None                ...  mansi.html
Regular           420  None                ...  splash.html
Regular           420  None                ...  about.html

Regular           420  None                ...  LICENSE.txt
Regular           420  None                ...  Sentinel.txt
Regular           420  None                ...  README.txt
```
### Binêre Terugkeer

Binne die `<application-name>.app` gids sal jy 'n binêre lêer vind genaamd `<application-name>`. Dit is die lêer wat **uitgevoer** sal word. Jy kan 'n basiese inspeksie van die binêre met die hulpmiddel **`otool`** uitvoer:
```bash
otool -Vh DVIA-v2 #Check some compilation attributes
magic  cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64    ARM64        ALL  0x00     EXECUTE    65       7112   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE

otool -L DVIA-v2 #Get third party libraries
DVIA-v2:
/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.1)
/usr/lib/libsqlite3.dylib (compatibility version 9.0.0, current version 274.6.0)
/usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11)
@rpath/Bolts.framework/Bolts (compatibility version 1.0.0, current version 1.0.0)
[...]
```
**Kontroleer of die aansoek geënkripteer is**

Kyk of daar enige uitvoer is vir:
```bash
otool -l <app-binary> | grep -A 4 LC_ENCRYPTION_INFO
```
**Ontbind die binêre**

Ontbind die teksgedeelte:
```bash
otool -tV DVIA-v2
DVIA-v2:
(__TEXT,__text) section
+[DDLog initialize]:
0000000100004ab8    sub    sp, sp, #0x60
0000000100004abc    stp    x29, x30, [sp, #0x50]   ; Latency: 6
0000000100004ac0    add    x29, sp, #0x50
0000000100004ac4    sub    x8, x29, #0x10
0000000100004ac8    mov    x9, #0x0
0000000100004acc    adrp    x10, 1098 ; 0x10044e000
0000000100004ad0    add    x10, x10, #0x268
```
Om die **Objective-C segment** van die voorbeeldtoepassing te druk, kan mens gebruik maak van:
```bash
otool -oV DVIA-v2
DVIA-v2:
Contents of (__DATA,__objc_classlist) section
00000001003dd5b8 0x1004423d0 _OBJC_CLASS_$_DDLog
isa        0x1004423a8 _OBJC_METACLASS_$_DDLog
superclass 0x0 _OBJC_CLASS_$_NSObject
cache      0x0 __objc_empty_cache
vtable     0x0
data       0x1003de748
flags          0x80
instanceStart  8
```
Om 'n meer kompakte Objective-C kode te verkry, kan jy [**class-dump**](http://stevenygard.com/projects/class-dump/): gebruik.
```bash
class-dump some-app
//
//     Generated by class-dump 3.5 (64 bit).
//
//     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2013 by Steve Nygard.
//

#pragma mark Named Structures

struct CGPoint {
double _field1;
double _field2;
};

struct CGRect {
struct CGPoint _field1;
struct CGSize _field2;
};

struct CGSize {
double _field1;
double _field2;
};
```
Maar die beste opsies om die binêre te ontleed is: [**Hopper**](https://www.hopperapp.com/download.html?) en [**IDA**](https://www.hex-rays.com/products/ida/support/download_freeware/).

## Data Berging

Om te leer hoe iOS data in die toestel stoor, lees hierdie bladsy:

{{#ref}}
ios-basics.md
{{#endref}}

> [!WARNING]
> Die volgende plekke om inligting te stoor moet **reg na die installering van die toepassing** nagegaan word, **na die kontrole van al die funksies** van die toepassing en selfs na **uitteken van een gebruiker en inteken in 'n ander**.\
> Die doel is om **onbeskermde sensitiewe inligting** van die toepassing (wagwoorde, tokens), van die huidige gebruiker en van voorheen ingelogde gebruikers te vind.

### Plist

**plist** lêers is gestruktureerde XML lêers wat **sleutel-waarde pare** bevat. Dit is 'n manier om volhoubare data te stoor, so soms kan jy **sensitiewe inligting in hierdie lêers** vind. Dit word aanbeveel om hierdie lêers na die installering van die app en na intensiewe gebruik daarvan na te gaan om te sien of nuwe data geskryf is.

Die mees algemene manier om data in plist lêers volhoubaar te stoor, is deur die gebruik van **NSUserDefaults**. Hierdie plist lêer word binne die app sandbox gestoor in **`Library/Preferences/<appBundleID>.plist`**

Die [`NSUserDefaults`](https://developer.apple.com/documentation/foundation/nsuserdefaults) klas bied 'n programmatiese koppelvlak vir interaksie met die standaardstelsel. Die standaardstelsel laat 'n toepassing toe om sy gedrag aan te pas volgens **gebruikersvoorkeure**. Data wat deur `NSUserDefaults` gestoor word, kan in die toepassingsbundel gesien word. Hierdie klas stoor **data** in 'n **plist** **lêer**, maar dit is bedoel om met klein hoeveelhede data gebruik te word.

Hierdie data kan nie langer direk via 'n vertroude rekenaar verkry word nie, maar kan verkry word deur 'n **rugsteun** uit te voer.

Jy kan die inligting wat gestoor is met **`NSUserDefaults`** dump deur objection se `ios nsuserdefaults get` te gebruik.

Om al die plist lêers wat deur die toepassing gebruik word te vind, kan jy toegang verkry tot `/private/var/mobile/Containers/Data/Application/{APPID}` en uitvoer:
```bash
find ./ -name "*.plist"
```
Om lêers van **XML of binêre (bplist)** formaat na XML om te skakel, is verskeie metodes beskikbaar, afhangende van jou bedryfstelsel:

**Vir macOS gebruikers:** Gebruik die `plutil` opdrag. Dit is 'n ingeboude hulpmiddel in macOS (10.2+), ontwerp vir hierdie doel:
```bash
$ plutil -convert xml1 Info.plist
```
**Vir Linux-gebruikers:** Installeer eers `libplist-utils`, en gebruik dan `plistutil` om jou lêer te omskep:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
**Binne 'n Objection-sessie:** Vir die ontleding van mobiele toepassings, laat 'n spesifieke opdrag jou toe om plist-lêers direk om te skakel:
```bash
ios plist cat /private/var/mobile/Containers/Data/Application/<Application-UUID>/Library/Preferences/com.some.package.app.plist
```
### Kern Data

[`Core Data`](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/nsfetchedresultscontroller.html#//apple_ref/doc/uid/TP40001075-CH8-SW1) is 'n raamwerk vir die bestuur van die modellaag van objekke in jou aansoek. [Core Data kan SQLite as sy volhoubare stoor gebruik](https://cocoacasts.com/what-is-the-difference-between-core-data-and-sqlite/), maar die raamwerk self is nie 'n databasis nie.\
CoreData enkripteer nie sy data standaard nie. Daar kan egter 'n addisionele enkripsielaag by CoreData gevoeg word. Sien die [GitHub Repo](https://github.com/project-imas/encrypted-core-data) vir meer besonderhede.

Jy kan die SQLite Core Data-inligting van 'n aansoek in die pad `/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support` vind.

**As jy die SQLite kan oopmaak en toegang tot sensitiewe inligting kan kry, het jy 'n verkeerde konfigurasie gevind.**
```objectivec:Code from iGoat
-(void)storeDetails {
AppDelegate * appDelegate = (AppDelegate *)(UIApplication.sharedApplication.delegate);

NSManagedObjectContext *context =[appDelegate managedObjectContext];

User *user = [self fetchUser];
if (user) {
return;
}
user = [NSEntityDescription insertNewObjectForEntityForName:@"User"
inManagedObjectContext:context];
user.email = CoreDataEmail;
user.password = CoreDataPassword;
NSError *error;
if (![context save:&error]) {
NSLog(@"Error in saving data: %@", [error localizedDescription]);

}else{
NSLog(@"data stored in core data");
}
}
```
### YapDatabase

[YapDatabase](https://github.com/yapstudios/YapDatabase) is 'n sleutel/waarde stoor wat op SQLite gebou is.\
Aangesien die Yap databasisse sqlite databasisse is, kan jy hulle vind met die voorgestelde opdrag in die vorige afdeling.

### Ander SQLite Databasisse

Dit is algemeen dat toepassings hul eie sqlite databasis skep. Hulle mag **sensitiewe** **data** daarop **stoor** en dit ongeënkripteer laat. Daarom is dit altyd interessant om elke databasis binne die toepassingsgids na te gaan. Gaan dus na die toepassingsgids waar die data gestoor word (`/private/var/mobile/Containers/Data/Application/{APPID}`)
```bash
find ./ -name "*.sqlite" -or -name "*.db"
```
### Firebase Real-Time Databases

Ontwikkelaars kan **data stoor en sinkroniseer** binne 'n **NoSQL wolk-gehoste databasis** deur Firebase Real-Time Databases. Gestoor in JSON-formaat, word die data in werklike tyd gesinkroniseer na alle gekonnekteerde kliënte.

Jy kan vind hoe om na verkeerd geconfigureerde Firebase databasisse te kyk hier:

{{#ref}}
../../network-services-pentesting/pentesting-web/buckets/firebase-database.md
{{#endref}}

### Realm databases

[Realm Objective-C](https://realm.io/docs/objc/latest/) en [Realm Swift](https://realm.io/docs/swift/latest/) bied 'n kragtige alternatief vir datastoor, wat nie deur Apple verskaf word nie. Standaard **stoor hulle data ongeënkripteer**, met enkripsie beskikbaar deur spesifieke konfigurasie.

Die databasisse is geleë by: `/private/var/mobile/Containers/Data/Application/{APPID}`. Om hierdie lêers te verken, kan 'n mens opdragte soos gebruik:
```bash
iPhone:/private/var/mobile/Containers/Data/Application/A079DF84-726C-4AEA-A194-805B97B3684A/Documents root# ls
default.realm  default.realm.lock  default.realm.management/  default.realm.note|

$ find ./ -name "*.realm*"
```
Vir die sien van hierdie databasislêers, word die [**Realm Studio**](https://github.com/realm/realm-studio) hulpmiddel aanbeveel.

Om versleuteling binne 'n Realm-databasis te implementeer, kan die volgende kode-snippet gebruik word:
```swift
// Open the encrypted Realm file where getKey() is a method to obtain a key from the Keychain or a server
let config = Realm.Configuration(encryptionKey: getKey())
do {
let realm = try Realm(configuration: config)
// Use the Realm as normal
} catch let error as NSError {
// If the encryption key is wrong, `error` will say that it's an invalid database
fatalError("Error opening realm: \(error)")
}
```
### Couchbase Lite Databases

[Couchbase Lite](https://github.com/couchbase/couchbase-lite-ios) word beskryf as 'n **liggewig** en **ingebedde** databasis enjin wat die **dokument-georiënteerde** (NoSQL) benadering volg. Ontwerp om inheems te wees aan **iOS** en **macOS**, bied dit die vermoë om data naatloos te sinkroniseer.

Om potensiële Couchbase databasisse op 'n toestel te identifiseer, moet die volgende gids ondersoek word:
```bash
ls /private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support/
```
### Koekies

iOS stoor die koekies van die programme in die **`Library/Cookies/cookies.binarycookies`** binne elke program se gids. egter, ontwikkelaars besluit soms om hulle in die **keychain** te stoor aangesien die genoemde **koekie-lêer in rugsteun toeganklik is**.

Om die koekie-lêer te ondersoek, kan jy [**hierdie python-skrip**](https://github.com/mdegrazia/Safari-Binary-Cookie-Parser) gebruik of objection se **`ios cookies get`.**\
**Jy kan ook objection gebruik om** hierdie lêers na 'n JSON-formaat te omskep en die data te ondersoek.
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios cookies get --json
[
{
"domain": "highaltitudehacks.com",
"expiresDate": "2051-09-15 07:46:43 +0000",
"isHTTPOnly": "false",
"isSecure": "false",
"name": "username",
"path": "/",
"value": "admin123",
"version": "0"
}
]
```
### Cache

Standaard stoor NSURLSession data, soos **HTTP versoeke en antwoorde in die Cache.db** databasis. Hierdie databasis kan **sensitiewe data** bevat, indien tokens, gebruikersname of enige ander sensitiewe inligting geberg is. Om die gebergde inligting te vind, open die datagids van die toepassing (`/var/mobile/Containers/Data/Application/<UUID>`) en gaan na `/Library/Caches/<Bundle Identifier>`. Die **WebKit cache word ook in die Cache.db** lêer gestoor. **Objection** kan die databasis oopmaak en daarmee interaksie hê met die opdrag `sqlite connect Cache.db`, aangesien dit 'n n**ormale SQLite databasis** is.

Dit word **aanbeveel om die caching van hierdie data te deaktiveer**, aangesien dit sensitiewe inligting in die versoek of antwoord kan bevat. Die volgende lys hieronder toon verskillende maniere om dit te bereik:

1.  Dit word aanbeveel om gebergde antwoorde na afmelding te verwyder. Dit kan gedoen word met die metode wat deur Apple verskaf word, genaamd [`removeAllCachedResponses`](https://developer.apple.com/documentation/foundation/urlcache/1417802-removeallcachedresponses). U kan hierdie metode soos volg aanroep:

`URLCache.shared.removeAllCachedResponses()`

Hierdie metode sal alle gebergde versoeke en antwoorde uit die Cache.db lêer verwyder.

2.  As u nie die voordeel van koekies hoef te gebruik nie, sal dit aanbeveel word om net die [.ephemeral](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral) konfigurasie eienskap van URLSession te gebruik, wat die stoor van koekies en caches sal deaktiveer.

[Apple dokumentasie](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral):

`'n Ephemeral sessie konfigurasie objek is soortgelyk aan 'n standaard sessie konfigurasie (sien standaard), behalwe dat die ooreenstemmende sessie objek nie caches, geloofwaardigheid stoor, of enige sessie-verwante data op skyf stoor nie. In plaas daarvan word sessie-verwante data in RAM gestoor. Die enigste keer dat 'n ephemeral sessie data op skyf skryf, is wanneer jy dit sê om die inhoud van 'n URL na 'n lêer te skryf.'`

3.  Cache kan ook gedeaktiveer word deur die Cache-beleid op [.notAllowed](https://developer.apple.com/documentation/foundation/urlcache/storagepolicy/notallowed) te stel. Dit sal die stoor van Cache op enige manier, hetsy in geheue of op skyf, deaktiveer.

### Snapshots

Wanneer jy die tuisknoppie druk, **neem iOS 'n snapshot van die huidige skerm** om die oorgang na die toepassing op 'n baie gladder manier te kan doen. As **sensitiewe** **data** egter op die huidige skerm teenwoordig is, sal dit in die **beeld** **gestoor** word (wat **volhard** **deur** **herlaaiings**). Dit is die snapshots waartoe jy ook toegang kan hê deur dubbel te tik op die tuisskerm om tussen toepassings te wissel.

Tensy die iPhone gejailbreak is, moet die **aanvaller** **toegang** tot die **toestel** **ontsluit** hê om hierdie skermskote te sien. Standaard word die laaste snapshot in die toepassings sandkas in die `Library/Caches/Snapshots/` of `Library/SplashBoard/Snapshots` gids gestoor (die vertroude rekenaars kan nie toegang tot die lêerstelsel vanaf iOX 7.0 verkry nie).

Een manier om hierdie slegte gedrag te voorkom, is om 'n leë skerm te plaas of die sensitiewe data te verwyder voordat die snapshot geneem word met die `ApplicationDidEnterBackground()` funksie.

Die volgende is 'n voorbeeld van 'n herstelmetode wat 'n standaard skermskoot sal stel.

Swift:
```swift
private var backgroundImage: UIImageView?

func applicationDidEnterBackground(_ application: UIApplication) {
let myBanner = UIImageView(image: #imageLiteral(resourceName: "overlayImage"))
myBanner.frame = UIScreen.main.bounds
backgroundImage = myBanner
window?.addSubview(myBanner)
}

func applicationWillEnterForeground(_ application: UIApplication) {
backgroundImage?.removeFromSuperview()
}
```
Objective-C:
```
@property (UIImageView *)backgroundImage;

- (void)applicationDidEnterBackground:(UIApplication *)application {
UIImageView *myBanner = [[UIImageView alloc] initWithImage:@"overlayImage.png"];
self.backgroundImage = myBanner;
self.backgroundImage.bounds = UIScreen.mainScreen.bounds;
[self.window addSubview:myBanner];
}

- (void)applicationWillEnterForeground:(UIApplication *)application {
[self.backgroundImage removeFromSuperview];
}
```
Dit stel die agtergrondbeeld in op `overlayImage.png` wanneer die toepassing in die agtergrond is. Dit voorkom sensitiewe data leaks omdat `overlayImage.png` altyd die huidige weergawe sal oorskry.

### Keychain

Vir toegang tot en bestuur van die iOS keychain, is gereedskap soos [**Keychain-Dumper**](https://github.com/ptoomey3/Keychain-Dumper) beskikbaar, geskik vir jailbroken toestelle. Boonop bied [**Objection**](https://github.com/sensepost/objection) die opdrag `ios keychain dump` vir soortgelyke doeleindes.

#### **Stoor Kredensiale**

Die **NSURLCredential** klas is ideaal om sensitiewe inligting direk in die keychain te stoor, wat die behoefte aan NSUserDefaults of ander wrappers omseil. Om kredensiale na aanmelding te stoor, word die volgende Swift kode gebruik:
```swift
NSURLCredential *credential;
credential = [NSURLCredential credentialWithUser:username password:password persistence:NSURLCredentialPersistencePermanent];
[[NSURLCredentialStorage sharedCredentialStorage] setCredential:credential forProtectionSpace:self.loginProtectionSpace];
```
Om hierdie gestoor geloofsbriewe te onttrek, word Objection se opdrag `ios nsurlcredentialstorage dump` gebruik.

## **Pasgemaakte Toetsborde en Toetsbordkas**

Met iOS 8.0 en later kan gebruikers pasgemaakte toetsborduitbreidings installeer, wat hanteerbaar is onder **Instellings > Algemeen > Toetsbord > Toetsborde**. Terwyl hierdie toetsborde uitgebreide funksionaliteit bied, stel dit 'n risiko van toetsaanslaglogging en die oordrag van data na eksterne bedieners, alhoewel gebruikers in kennis gestel word van toetsborde wat netwerktoegang benodig. Programme kan, en behoort, die gebruik van pasgemaakte toetsborde vir die invoer van sensitiewe inligting te beperk.

**Sekuriteitsaanbevelings:**

- Dit word aanbeveel om derdeparty-toetsborde te deaktiveer vir verbeterde sekuriteit.
- Wees bewus van die outokorreksie- en outo-suggereringsfunksies van die standaard iOS-toetsbord, wat sensitiewe inligting in kaslêers kan stoor wat geleë is in `Library/Keyboard/{locale}-dynamic-text.dat` of `/private/var/mobile/Library/Keyboard/dynamic-text.dat`. Hierdie kaslêers moet gereeld nagegaan word vir sensitiewe data. Dit word aanbeveel om die toetsbordwoordeboek te reset via **Instellings > Algemeen > Reset > Reset Toetsbordwoordeboek** om gekapte data te verwyder.
- Die onderskepping van netwerkverkeer kan onthul of 'n pasgemaakte toetsbord toetsaanslae op afstand oordra.

### **Voorkoming van Teksvakkas**

Die [UITextInputTraits protocol](https://developer.apple.com/reference/uikit/uitextinputtraits) bied eienskappe om outokorreksie en veilige teksinvoer te bestuur, wat noodsaaklik is om die kas van sensitiewe inligting te voorkom. Byvoorbeeld, om outokorreksie te deaktiveer en veilige teksinvoer in te skakel kan bereik word met:
```objectivec
textObject.autocorrectionType = UITextAutocorrectionTypeNo;
textObject.secureTextEntry = YES;
```
Boonop, ontwikkelaars moet verseker dat teksvelde, veral dié vir die invoer van sensitiewe inligting soos wagwoorde en PIN's, kasgeheue deaktiveer deur `autocorrectionType` op `UITextAutocorrectionTypeNo` en `secureTextEntry` op `YES` te stel.
```objectivec
UITextField *textField = [[UITextField alloc] initWithFrame:frame];
textField.autocorrectionType = UITextAutocorrectionTypeNo;
```
## **Logs**

Die ontfouting van kode behels dikwels die gebruik van **logging**. Daar is 'n risiko betrokke aangesien **logs sensitiewe inligting kan bevat**. Voorheen, in iOS 6 en vroeëre weergawes, was logs toeganklik vir alle toepassings, wat 'n risiko van sensitiewe data lek veroorsaak het. **Nou is toepassings beperk tot die toegang van slegs hul logs**.

Ten spyte van hierdie beperkings, kan 'n **aanvaller met fisiese toegang** tot 'n ontgrendelde toestel steeds hiervan voordeel trek deur die toestel aan 'n rekenaar te koppel en **die logs te lees**. Dit is belangrik om te noem dat logs op die skyf bly selfs nadat die app verwyder is.

Om risiko's te verminder, word dit aanbeveel om **grondig met die app te interaksie**, alle funksies en invoere te verken om te verseker dat geen sensitiewe inligting per ongeluk gelog word nie.

Wanneer jy die app se bronkode hersien vir potensiële lekke, soek vir beide **vooraf gedefinieerde** en **aangepaste logging verklarings** met sleutelwoorde soos `NSLog`, `NSAssert`, `NSCAssert`, `fprintf` vir ingeboude funksies, en enige vermeldings van `Logging` of `Logfile` vir aangepaste implementasies.

### **Monitoring System Logs**

Toepassings log verskeie stukke inligting wat sensitief kan wees. Om hierdie logs te monitor, gebruik gereedskap en opdragte soos:
```bash
idevice_id --list   # To find the device ID
idevicesyslog -u <id> (| grep <app>)   # To capture the device logs
```
is nuttig. Boonop, **Xcode** bied 'n manier om konsol logs te versamel:

1. Maak Xcode oop.
2. Koppel die iOS toestel.
3. Navigeer na **Window** -> **Devices and Simulators**.
4. Kies jou toestel.
5. Trigger die probleem wat jy ondersoek.
6. Gebruik die **Open Console** knoppie om logs in 'n nuwe venster te sien.

Vir meer gevorderde logging, kan die verbinding met die toestel se shell en die gebruik van **socat** werklike tyd log monitering bied:
```bash
iPhone:~ root# socat - UNIX-CONNECT:/var/run/lockdown/syslog.sock
```
Volg op met opdragte om logaktiwiteite te observeer, wat van onskatbare waarde kan wees vir die diagnose van probleme of die identifisering van potensiële datalekke in logs.

## Rugsteun

**Outomatiese rugsteun funksies** is in iOS geïntegreer, wat die skepping van toesteldata-kopieë deur iTunes (tot macOS Catalina), Finder (vanaf macOS Catalina) of iCloud vergemaklik. Hierdie rugsteun sluit byna alle toesteldata in, met uitsluiting van hoogs sensitiewe elemente soos Apple Pay besonderhede en Touch ID konfigurasies.

### Sekuriteitsrisiko's

Die insluiting van **geïnstalleerde toepassings en hul data** in rugsteun bring die kwessie van potensiële **datalekke** en die risiko dat **rugsteunwysigings die funksionaliteit van toepassings kan verander**. Dit word aanbeveel om **nie sensitiewe inligting in platte teks** binne enige toepassing se gids of subgidsen te stoor om hierdie risiko's te verminder.

### Uitsluiting van Lêers uit Rugsteun

Lêers in `Documents/` en `Library/Application Support/` word standaard gebackup. Ontwikkelaars kan spesifieke lêers of gidse van rugsteun uitsluit deur `NSURL setResourceValue:forKey:error:` met die `NSURLIsExcludedFromBackupKey` te gebruik. Hierdie praktyk is van kardinale belang om sensitiewe data te beskerm teen insluiting in rugsteun.

### Toets vir Kw vulnerabilities

Om 'n toepassing se rugsteun sekuriteit te evalueer, begin deur **'n rugsteun te skep** met Finder, en vind dit dan met leiding van [Apple se amptelike dokumentasie](https://support.apple.com/en-us/HT204215). Analiseer die rugsteun vir sensitiewe data of konfigurasies wat verander kan word om die gedrag van die toepassing te beïnvloed.

Sensitiewe inligting kan gesoek word met behulp van opdraglyn gereedskap of toepassings soos [iMazing](https://imazing.com). Vir versleutelde rugsteun kan die teenwoordigheid van versleuteling bevestig word deur die "IsEncrypted" sleutel in die "Manifest.plist" lêer by die rugsteun se wortel te kontroleer.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
...
<key>Date</key>
<date>2021-03-12T17:43:33Z</date>
<key>IsEncrypted</key>
<true/>
...
</plist>
```
Vir die hantering van versleutelde rugsteun, kan Python-skripte beskikbaar in [DinoSec se GitHub repo](https://github.com/dinosec/iphone-dataprotection/tree/master/python_scripts), soos **backup_tool.py** en **backup_passwd.py**, nuttig wees, alhoewel dit moontlik aanpassings mag vereis vir kompatibiliteit met die nuutste iTunes/Finder weergawes. Die [**iOSbackup** tool](https://pypi.org/project/iOSbackup/) is 'n ander opsie om toegang te verkry tot lêers binne wagwoord-beskermde rugsteun.

### Wysig App Gedrag

'n Voorbeeld van die verandering van app gedrag deur rugsteun wysigings word gedemonstreer in die [Bither bitcoin wallet app](https://github.com/bither/bither-ios), waar die UI slot PIN binne `net.bither.plist` onder die **pin_code** sleutel gestoor word. Om hierdie sleutel uit die plist te verwyder en die rugsteun te herstel, verwyder die PIN vereiste, wat onbeperkte toegang bied.

## Samevatting oor Geheue Toetsing vir Sensitiewe Data

Wanneer daar met sensitiewe inligting wat in 'n toepassing se geheue gestoor is, gewerk word, is dit van kardinale belang om die blootstellingstyd van hierdie data te beperk. Daar is twee primêre benaderings om geheue-inhoud te ondersoek: **die skep van 'n geheue dump** en **die analise van die geheue in werklike tyd**. Beide metodes het hul uitdagings, insluitend die potensiaal om kritieke data tydens die dump proses of analise te mis.

## **Herwin en Analiseer 'n Geheue Dump**

Vir beide jailbroken en nie-jailbroken toestelle, toelaat gereedskap soos [objection](https://github.com/sensepost/objection) en [Fridump](https://github.com/Nightbringer21/fridump) die dumping van 'n app se proses geheue. Sodra dit gedump is, vereis die analise van hierdie data verskeie gereedskap, afhangende van die aard van die inligting waarna jy soek.

Om strings uit 'n geheue dump te onttrek, kan opdragte soos `strings` of `rabin2 -zz` gebruik word:
```bash
# Extracting strings using strings command
$ strings memory > strings.txt

# Extracting strings using rabin2
$ rabin2 -ZZ memory > strings.txt
```
Vir meer gedetailleerde analise, insluitend die soek na spesifieke datatipe of patrone, **radare2** bied uitgebreide soekvermoëns:
```bash
$ r2 <name_of_your_dump_file>
[0x00000000]> /?
...
```
## **Tydelike Geheue Analise**

**r2frida** bied 'n kragtige alternatief om 'n app se geheue in werklike tyd te inspekteer, sonder om 'n geheue dump te benodig. Hierdie hulpmiddel stel die uitvoering van soekopdragte direk op die lopende toepassing se geheue in staat:
```bash
$ r2 frida://usb//<name_of_your_app>
[0x00000000]> /\ <search_command>
```
## Gebroke Kriptografie

### Swak Sleutelbestuurprosesse

Sommige ontwikkelaars stoor sensitiewe data in die plaaslike berging en enkripteer dit met 'n sleutel wat in die kode hardgecodeer/voorspelbaar is. Dit moet nie gedoen word nie, aangesien sommige omkering aanvallers kan toelaat om die vertroulike inligting te onttrek.

### Gebruik van Onveilige en/of Verouderde Algoritmes

Ontwikkelaars moet nie **verouderde algoritmes** gebruik om autorisasie **kontroles** uit te voer, **data** te **stoor** of **te stuur** nie. Sommige van hierdie algoritmes is: RC4, MD4, MD5, SHA1... As **hashes** gebruik word om wagwoorde te stoor, moet hashes wat teen brute-force **weerstandig** is, met sout gebruik word.

### Kontrole

Die hoofkontroles om uit te voer, is om te vind of jy **hardgecodeerde** wagwoorde/geheime in die kode kan vind, of as dit **voorspelbaar** is, en of die kode 'n soort **swak** **kriptografie** algoritmes gebruik.

Dit is interessant om te weet dat jy sommige **crypto** **biblioteke** outomaties kan **monitor** met **objection** met:
```swift
ios monitor crypt
```
Vir **meer inligting** oor iOS-kodering APIs en biblioteke, toegang tot [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography)

## Plaaslike Verifikasie

**Plaaslike verifikasie** speel 'n belangrike rol, veral wanneer dit kom by die beskerming van toegang by 'n afgeleë eindpunt deur middel van kodering metodes. Die essensie hier is dat sonder behoorlike implementering, plaaslike verifikasie meganismes omseil kan word.

Apple se [**Plaaslike Verifikasie raamwerk**](https://developer.apple.com/documentation/localauthentication) en die [**sleutelsak**](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html) bied robuuste APIs vir ontwikkelaars om gebruikersverifikasiedialoge te fasiliteer en veilig geheime data te hanteer, onderskeidelik. Die Veilige Enklave beveilig vingerafdruk-ID vir Touch ID, terwyl Face ID op gesigsherkenning staatmaak sonder om biometriese data in gevaar te stel.

Om Touch ID/Face ID te integreer, het ontwikkelaars twee API-keuses:

- **`LocalAuthentication.framework`** vir hoëvlak gebruikersverifikasie sonder toegang tot biometriese data.
- **`Security.framework`** vir laevlak sleutelsak dienste toegang, wat geheime data beveilig met biometriese verifikasie. Verskeie [oopbron wrappers](https://www.raywenderlich.com/147308/secure-ios-user-data-keychain-touch-id) maak sleutelsak toegang eenvoudiger.

> [!CAUTION]
> egter, beide `LocalAuthentication.framework` en `Security.framework` bied kwesbaarhede, aangesien hulle hoofsaaklik booleaanse waardes teruggee sonder om data vir verifikasieprosesse oor te dra, wat hulle vatbaar maak vir omseiling (verwys na [Don't touch me that way, deur David Lindner et al](https://www.youtube.com/watch?v=XhXIHVGCFFM)).

### Implementering van Plaaslike Verifikasie

Om gebruikers vir verifikasie te vra, moet ontwikkelaars die **`evaluatePolicy`** metode binne die **`LAContext`** klas gebruik, en kies tussen:

- **`deviceOwnerAuthentication`**: Vra vir Touch ID of toestel wagwoord, en faal as geen een geaktiveer is nie.
- **`deviceOwnerAuthenticationWithBiometrics`**: Vra eksklusief vir Touch ID.

'n Suksesvolle verifikasie word aangedui deur 'n booleaanse terugwaarde van **`evaluatePolicy`**, wat 'n potensiële sekuriteitsfout beklemtoon.

### Plaaslike Verifikasie met Sleutelsak

Die implementering van **plaaslike verifikasie** in iOS-apps behels die gebruik van **sleutelsak APIs** om geheime data soos verifikasietokens veilig te stoor. Hierdie proses verseker dat die data slegs deur die gebruiker, met behulp van hul toestel wagwoord of biometriese verifikasie soos Touch ID, toegang verkry kan word.

Die sleutelsak bied die vermoë om items met die `SecAccessControl` attribuut in te stel, wat toegang tot die item beperk totdat die gebruiker suksesvol deur Touch ID of toestel wagwoord verifieer. Hierdie kenmerk is van kardinale belang om sekuriteit te verbeter.

Hieronder is kodevoorbeelde in Swift en Objective-C wat demonstreer hoe om 'n string na/van die sleutelsak te stoor en te onttrek, terwyl hierdie sekuriteitskenmerke benut word. Die voorbeelde toon spesifiek hoe om toegangbeheer op te stel om Touch ID-verifikasie te vereis en te verseker dat die data slegs op die toestel waaraan dit ingestel is, toeganklik is, onder die voorwaarde dat 'n toestel wagwoord geconfigureer is.

{{#tabs}}
{{#tab name="Swift"}}
```swift
// From https://github.com/mufambisi/owasp-mstg/blob/master/Document/0x06f-Testing-Local-Authentication.md

// 1. create AccessControl object that will represent authentication settings

var error: Unmanaged<CFError>?

guard let accessControl = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
SecAccessControlCreateFlags.biometryCurrentSet,
&error) else {
// failed to create AccessControl object

return
}

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute

var query: [String: Any] = [:]

query[kSecClass as String] = kSecClassGenericPassword
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecAttrAccount as String] = "OWASP Account" as CFString
query[kSecValueData as String] = "test_strong_password".data(using: .utf8)! as CFData
query[kSecAttrAccessControl as String] = accessControl

// 3. save item

let status = SecItemAdd(query as CFDictionary, nil)

if status == noErr {
// successfully saved
} else {
// error while saving
}
```
{{#endtab}}

{{#tab name="Objective-C"}}
```objectivec
// 1. create AccessControl object that will represent authentication settings
CFErrorRef *err = nil;

SecAccessControlRef sacRef = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
kSecAccessControlUserPresence,
err);

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute
NSDictionary* query = @{
(_ _bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecAttrAccount: @"OWASP Account",
(__bridge id)kSecValueData: [@"test_strong_password" dataUsingEncoding:NSUTF8StringEncoding],
(__bridge id)kSecAttrAccessControl: (__bridge_transfer id)sacRef
};

// 3. save item
OSStatus status = SecItemAdd((__bridge CFDictionaryRef)query, nil);

if (status == noErr) {
// successfully saved
} else {
// error while saving
}
```
{{#endtab}}
{{#endtabs}}

Nou kan ons die gestoor item van die sleutelhouer versoek. Sleutelhouer dienste sal die verifikasiedialoog aan die gebruiker aanbied en data of nil teruggee, afhangende van of 'n geskikte vingerafdruk verskaf is of nie.

{{#tabs}}
{{#tab name="Swift"}}
```swift
// 1. define query
var query = [String: Any]()
query[kSecClass as String] = kSecClassGenericPassword
query[kSecReturnData as String] = kCFBooleanTrue
query[kSecAttrAccount as String] = "My Name" as CFString
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecUseOperationPrompt as String] = "Please, pass authorisation to enter this area" as CFString

// 2. get item
var queryResult: AnyObject?
let status = withUnsafeMutablePointer(to: &queryResult) {
SecItemCopyMatching(query as CFDictionary, UnsafeMutablePointer($0))
}

if status == noErr {
let password = String(data: queryResult as! Data, encoding: .utf8)!
// successfully received password
} else {
// authorization not passed
}
```
{{#endtab}}

{{#tab name="Objective-C"}}
```objectivec
// 1. define query
NSDictionary *query = @{(__bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecReturnData: @YES,
(__bridge id)kSecAttrAccount: @"My Name1",
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecUseOperationPrompt: @"Please, pass authorisation to enter this area" };

// 2. get item
CFTypeRef queryResult = NULL;
OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)query, &queryResult);

if (status == noErr){
NSData* resultData = ( __bridge_transfer NSData* )queryResult;
NSString* password = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding];
NSLog(@"%@", password);
} else {
NSLog(@"Something went wrong");
}
```
{{#endtab}}
{{#endtabs}}

### Ontdekking

Die gebruik van raamwerke in 'n toepassing kan ook opgespoor word deur die lys van gedeelde dinamiese biblioteke van die toepassing se binêre te analiseer. Dit kan gedoen word deur `otool` te gebruik:
```bash
$ otool -L <AppName>.app/<AppName>
```
As `LocalAuthentication.framework` in 'n app gebruik word, sal die uitvoer beide van die volgende lyne bevat (onthou dat `LocalAuthentication.framework` `Security.framework` onder die oppervlak gebruik):
```bash
/System/Library/Frameworks/LocalAuthentication.framework/LocalAuthentication
/System/Library/Frameworks/Security.framework/Security
```
As `Security.framework` gebruik word, sal slegs die tweede een vertoon word.

### Plaaslike Verifikasie Raamwerk Omseiling

#### **Objection**

Deur die **Objection Biometrics Bypass**, geleë op [hierdie GitHub-bladsy](https://github.com/sensepost/objection/wiki/Understanding-the-iOS-Biometrics-Bypass), is 'n tegniek beskikbaar om die **LocalAuthentication** meganisme te oorkom. Die kern van hierdie benadering behels die gebruik van **Frida** om die `evaluatePolicy` funksie te manipuleer, wat verseker dat dit konsekwent 'n `True` uitkoms lewer, ongeag die werklike verifikasie sukses. Dit is veral nuttig om gebrekkige biometriese verifikasieprosesse te omseil.

Om hierdie omseiling te aktiveer, word die volgende opdrag gebruik:
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios ui biometrics_bypass
(agent) Registering job 3mhtws9x47q. Type: ios-biometrics-disable
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # (agent) [3mhtws9x47q] Localized Reason for auth requirement: Please authenticate yourself
(agent) [3mhtws9x47q] OS authentication response: false
(agent) [3mhtws9x47q] Marking OS response as True instead
(agent) [3mhtws9x47q] Biometrics bypass hook complete
```
Hierdie opdrag stel 'n reeks in werking waar Objection 'n taak registreer wat effektief die uitkoms van die **`evaluatePolicy`** kontrole na `True` verander.

#### Frida

'n Voorbeeld van 'n gebruik van **`evaluatePolicy`** uit [DVIA-v2 toepassing](https://github.com/prateek147/DVIA-v2):
```swift
+(void)authenticateWithTouchID {
LAContext *myContext = [[LAContext alloc] init];
NSError *authError = nil;
NSString *myLocalizedReasonString = @"Please authenticate yourself";

if ([myContext canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&authError]) {
[myContext evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics
localizedReason:myLocalizedReasonString
reply:^(BOOL success, NSError *error) {
if (success) {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Successful" withTitle:@"Success"];
});
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Failed !" withTitle:@"Error"];
});
}
}];
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Your device doesn't support Touch ID or you haven't configured Touch ID authentication on your device" withTitle:@"Error"];
});
}
}
```
Om die **bypass** van Plaaslike Verifikasie te bereik, word 'n Frida-skrip geskryf. Hierdie skrip teiken die **evaluatePolicy** kontrole, wat sy terugroep onderbreek om te verseker dat dit **success=1** teruggee. Deur die gedrag van die terugroep te verander, word die verifikasietoets effektief omseil.

Die onderstaande skrip word ingespuit om die resultaat van die **evaluatePolicy** metode te verander. Dit verander die terugroep se resultaat om altyd sukses aan te dui.
```swift
// from https://securitycafe.ro/2022/09/05/mobile-pentesting-101-bypassing-biometric-authentication/
if(ObjC.available) {
console.log("Injecting...");
var hook = ObjC.classes.LAContext["- evaluatePolicy:localizedReason:reply:"];
Interceptor.attach(hook.implementation, {
onEnter: function(args) {
var block = new ObjC.Block(args[4]);
const callback = block.implementation;
block.implementation = function (error, value)  {

console.log("Changing the result value to true")
const result = callback(1, null);
return result;
};
},
});
} else {
console.log("Objective-C Runtime is not available!");
}
```
Om die Frida-skripte in te voeg en die biometriese verifikasie te omseil, word die volgende opdrag gebruik:
```bash
frida -U -f com.highaltitudehacks.DVIAswiftv2 --no-pause -l fingerprint-bypass-ios.js
```
## Sensitiewe Funksionaliteit Blootstelling Deur IPC

### Pasgemaakte URI Hanteerders / Deeplinks / Pasgemaakte Skemas

{{#ref}}
ios-custom-uri-handlers-deeplinks-custom-schemes.md
{{#endref}}

### Universele Skakels

{{#ref}}
ios-universal-links.md
{{#endref}}

### UIActivity Deel

{{#ref}}
ios-uiactivity-sharing.md
{{#endref}}

### UIPasteboard

{{#ref}}
ios-uipasteboard.md
{{#endref}}

### App Uitbreidings

{{#ref}}
ios-app-extensions.md
{{#endref}}

### WebViews

{{#ref}}
ios-webviews.md
{{#endref}}

### Serialisering en Kodering

{{#ref}}
ios-serialisation-and-encoding.md
{{#endref}}

## Netwerk Kommunikasie

Dit is belangrik om te kontroleer dat daar geen kommunikasie plaasvind **sonder versleuteling** nie en ook dat die toepassing korrek **die TLS sertifikaat** van die bediener valideer.\
Om hierdie tipe probleme te kontroleer, kan jy 'n proxy soos **Burp** gebruik:

{{#ref}}
burp-configuration-for-ios.md
{{#endref}}

### Gasheernaam kontrole

Een algemene probleem met die validasie van die TLS sertifikaat is om te kontroleer dat die sertifikaat deur 'n **betroubare** **CA** onderteken is, maar **nie te kontroleer** of **die gasheernaam** van die sertifikaat die gasheernaam is wat toeganklik is nie.\
Om hierdie probleem met Burp te kontroleer, nadat jy Burp CA op die iPhone vertrou het, kan jy **'n nuwe sertifikaat met Burp vir 'n ander gasheernaam skep** en dit gebruik. As die toepassing steeds werk, dan is daar iets wat kwesbaar is.

### Sertifikaat Pinning

As 'n toepassing korrek SSL Pinning gebruik, sal die toepassing slegs werk as die sertifikaat die verwagte een is. Wanneer jy 'n toepassing toets, **kan dit 'n probleem wees aangesien Burp sy eie sertifikaat sal dien.**\
Om hierdie beskerming binne 'n jailbreak toestel te omseil, kan jy die toepassing [**SSL Kill Switch**](https://github.com/nabla-c0d3/ssl-kill-switch2) installeer of [**Burp Mobile Assistant**](https://portswigger.net/burp/documentation/desktop/mobile/config-ios-device) installeer.

Jy kan ook **objection's** `ios sslpinning disable` gebruik.

## Verskeie

- In **`/System/Library`** kan jy die raamwerke vind wat op die telefoon geïnstalleer is deur stelsels toepassings.
- Die toepassings wat deur die gebruiker vanaf die App Store geïnstalleer is, is geleë in **`/User/Applications`**.
- En die **`/User/Library`** bevat data wat deur die gebruiker vlak toepassings gestoor is.
- Jy kan toegang verkry tot **`/User/Library/Notes/notes.sqlite`** om die notas wat binne die toepassing gestoor is, te lees.
- Binne die gids van 'n geïnstalleerde toepassing (**`/User/Applications/<APP ID>/`**) kan jy 'n paar interessante lêers vind:
- **`iTunesArtwork`**: Die ikoon wat deur die app gebruik word.
- **`iTunesMetadata.plist`**: Inligting van die app wat in die App Store gebruik word.
- **`/Library/*`**: Bevat die voorkeure en kas. In **`/Library/Cache/Snapshots/*`** kan jy die snapshot vind wat aan die toepassing gedoen is voordat dit na die agtergrond gestuur is.

### Hot Patching/Verpligte Opdatering

Die ontwikkelaars kan op afstand **alle installasies van hul app onmiddellik patch** sonder om die toepassing weer in te dien by die App Store en te wag totdat dit goedgekeur is.\
Vir hierdie doel word gewoonlik [**JSPatch**](https://github.com/bang590/JSPatch)** gebruik.** Maar daar is ook ander opsies soos [Siren](https://github.com/ArtSabintsev/Siren) en [react-native-appstore-version-checker](https://www.npmjs.com/package/react-native-appstore-version-checker).\
**Dit is 'n gevaarlike mechanisme wat deur kwaadwillige derdeparty SDK's misbruik kan word, daarom word dit aanbeveel om te kontroleer watter metode gebruik word vir outomatiese opdatering (indien enige) en dit te toets.** Jy kan probeer om 'n vorige weergawe van die app vir hierdie doel af te laai.

### Derde Partye

'n Beduidende uitdaging met **3de party SDK's** is die **gebrek aan fyn beheer** oor hul funksies. Ontwikkelaars staan voor 'n keuse: of om die SDK te integreer en al sy funksies te aanvaar, insluitend potensiële sekuriteitskwesbaarhede en privaatheidskwessies, of om die voordele daarvan heeltemal te verwerp. Dikwels is ontwikkelaars nie in staat om kwesbaarhede binne hierdie SDK's self te patch nie. Verder, soos SDK's vertroue binne die gemeenskap verkry, kan sommige begin om malware te bevat.

Die dienste wat deur derdeparty SDK's verskaf word, kan gebruikersgedragopsporing, advertensie vertonings of gebruikerservaring verbeterings insluit. Dit stel egter 'n risiko in, aangesien ontwikkelaars dalk nie ten volle bewus is van die kode wat deur hierdie biblioteke uitgevoer word nie, wat lei tot potensiële privaatheids- en sekuriteitsrisiko's. Dit is van kardinale belang om die inligting wat met derdeparty dienste gedeel word, te beperk tot wat nodig is en te verseker dat geen sensitiewe data blootgestel word nie.

Die implementering van derdeparty dienste kom gewoonlik in twee vorme: 'n standalone biblioteek of 'n volledige SDK. Om gebruikersprivaatheid te beskerm, moet enige data wat met hierdie dienste gedeel word, **geanonimiseer** word om die bekendmaking van Persoonlik Identifiseerbare Inligting (PII) te voorkom.

Om die biblioteke wat 'n toepassing gebruik, te identifiseer, kan die **`otool`** opdrag gebruik word. Hierdie hulpmiddel moet teen die toepassing en elke gedeelde biblioteek wat dit gebruik, uitgevoer word om addisionele biblioteke te ontdek.
```bash
otool -L <application_path>
```
## **Verwysings & Meer Hulpbronne**

- [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering)
- [iOS & Mobile App Pentesting - INE](https://my.ine.com/CyberSecurity/courses/089d060b/ios-mobile-app-pentesting)
- [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/)
- [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/)
- [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/)
- [https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage](https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage)
- [https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way](https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053)
- [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060)
- [https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/](https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064](https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064)
- [https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc](https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054)
- [https://github.com/ivRodriguezCA/RE-iOS-Apps/](https://github.com/ivRodriguezCA/RE-iOS-Apps/) IOS gratis kursus([https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/](https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/))
- [https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577](https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577)
- [https://www.slideshare.net/RyanISI/ios-appsecurityminicourse](https://www.slideshare.net/RyanISI/ios-appsecurityminicourse)
- [https://github.com/prateek147/DVIA](https://github.com/prateek147/DVIA)
- [https://github.com/prateek147/DVIA-v2](https://github.com/prateek147/DVIA-v2)
- [https://github.com/OWASP/MSTG-Hacking-Playground%20](https://github.com/OWASP/MSTG-Hacking-Playground)
- OWASP iGoat [_https://github.com/OWASP/igoat_](https://github.com/OWASP/igoat) <<< Objective-C weergawe [_https://github.com/OWASP/iGoat-Swift_](https://github.com/OWASP/iGoat-Swift) <<< Swift weergawe
- [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
- [https://github.com/nabla-c0d3/ssl-kill-switch2](https://github.com/nabla-c0d3/ssl-kill-switch2)


{{#include ../../banners/hacktricks-training.md}}
