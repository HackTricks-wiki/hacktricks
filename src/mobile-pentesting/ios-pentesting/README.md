# iOS Pentesting

{{#include ../../banners/hacktricks-training.md}}

## iOS Basiese


{{#ref}}
ios-basics.md
{{#endref}}

## Toetsomgewing

Op hierdie bladsy kan jy inligting vind oor die **iOS simulator**, **emulators** en **jailbreaking:**


{{#ref}}
ios-testing-environment.md
{{#endref}}

## Aanvanklike Analise

### Basiese iOS toetsingsoperasies

Tydens die toetsing sal **verskeie bewerkings voorgestel word** (verbinding maak met die toestel, lêers lees/skryf/oplaai/aflaai, 'n paar gereedskap gebruik...). Daarom, as jy nie weet hoe om enige van hierdie aksies uit te voer nie, **begin asseblief deur die bladsy te lees**:


{{#ref}}
basic-ios-testing-operations.md
{{#endref}}

> [!TIP]
> Vir die volgende stappe **moet die app geïnstalleer wees** op die toestel en moet jy reeds die **IPA file** van die toepassing verkry het.\
> Read the [Basic iOS Testing Operations](basic-ios-testing-operations.md) page to learn how to do this.

### Basiese Statiese Ontleding

Sommige interessante iOS - IPA files decompilers:

- [https://github.com/LaurieWired/Malimite](https://github.com/LaurieWired/Malimite)
- [https://ghidra-sre.org/](https://ghidra-sre.org/)

Dit word aanbeveel om die instrument [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) te gebruik om 'n outomatiese statiese ontleding op die IPA-lêer uit te voer.

Identifikasie van **beskerming wat in die binêr teenwoordig is**:

- **PIE (Position Independent Executable)**: Wanneer dit aangeskakel is, laai die toepassing in op 'n ewekansige geheue-adres elke keer as dit begin, wat dit moeiliker maak om sy aanvanklike geheue-adres te voorspel.

```bash
otool -hv <app-binary> | grep PIE   # It should include the PIE flag
```

- **Stack Canaries**: Om die integriteit van die stack te valideer, word 'n ‘canary’ waarde op die stack geplaas voordat 'n funksie aangeroep word en word dit weer nagegaan sodra die funksie eindig.

```bash
otool -I -v <app-binary> | grep stack_chk   # It should include the symbols: stack_chk_guard and stack_chk_fail
```

- **ARC (Automatic Reference Counting)**: Om algemene geheue-korrupsie tekortkominge te voorkom

```bash
otool -I -v <app-binary> | grep objc_release   # It should include the _objc_release symbol
```

- **Encrypted Binary**: Die binêr behoort versleuteld te wees

```bash
otool -arch all -Vl <app-binary> | grep -A5 LC_ENCRYPT   # The cryptid should be 1
```

**Identifikasie van sensitiewe/onveilige funksies**

- **Swak Hashing-algoritmes**

```bash
# On the iOS device
otool -Iv <app> | grep -w "_CC_MD5"
otool -Iv <app> | grep -w "_CC_SHA1"

# On linux
grep -iER "_CC_MD5"
grep -iER "_CC_SHA1"
```

- **Onveilige Random Funksies**

```bash
# On the iOS device
otool -Iv <app> | grep -w "_random"
otool -Iv <app> | grep -w "_srand"
otool -Iv <app> | grep -w "_rand"

# On linux
grep -iER "_random"
grep -iER "_srand"
grep -iER "_rand"
```

- **Onveilige 'Malloc' Funksie**

```bash
# On the iOS device
otool -Iv <app> | grep -w "_malloc"

# On linux
grep -iER "_malloc"
```

- **Onveilige en Kwesbare Funksies**

```bash
# On the iOS device
otool -Iv <app> | grep -w "_gets"
otool -Iv <app> | grep -w "_memcpy"
otool -Iv <app> | grep -w "_strncpy"
otool -Iv <app> | grep -w "_strlen"
otool -Iv <app> | grep -w "_vsnprintf"
otool -Iv <app> | grep -w "_sscanf"
otool -Iv <app> | grep -w "_strtok"
otool -Iv <app> | grep -w "_alloca"
otool -Iv <app> | grep -w "_sprintf"
otool -Iv <app> | grep -w "_printf"
otool -Iv <app> | grep -w "_vsprintf"

# On linux
grep -R "_gets"
grep -iER "_memcpy"
grep -iER "_strncpy"
grep -iER "_strlen"
grep -iER "_vsnprintf"
grep -iER "_sscanf"
grep -iER "_strtok"
grep -iER "_alloca"
grep -iER "_sprintf"
grep -iER "_printf"
grep -iER "_vsprintf"
```

#### Algemene jailbreak-opsporingsmetodes

- **Lêerstelselkontroles**: Kyk vir die teenwoordigheid van algemene jailbreak-lêers en -gidse, soos `/Applications/Cydia.app` of `/Library/MobileSubstrate/MobileSubstrate.dylib`.
- **Sandbox-oortredings**: Probeer toegang kry tot beperkte areas van die lêerstelsel, wat op nie-jailbroken toestelle geblokkeer behoort te wees.
- **API-kontroles**: Kyk of dit moontlik is om verbode oproepe soos `fork()` te gebruik om 'n kindproses te skep of `system()` om te sien of /bin/sh bestaan.
- **Proseskontroles**: Monitor vir die teenwoordigheid van bekende jailbreak-verwante prosesse, soos `Cydia`, `Substrate`, of `ssh`.
- **Kernel-uitbuitings**: Kyk vir die teenwoordigheid van kern-uitbuitings wat algemeen in jailbreaks gebruik word.
- **Omgewingveranderlikes**: Inspekteer omgewingsveranderlikes vir tekens van 'n jailbreak, soos `DYLD_INSERT_LIBRARIES`.
- **Biblioteekkontrole**: Kyk na die libs wat in die app-proses gelaai is.
- **Kontroleer skemas**: Soos `canOpenURL(URL(string: "cydia://"))`.

#### Algemene anti-debugging-opsporingsmetodes

- **Kontroleer vir Debugger-teenwoordigheid**: Gebruik `sysctl` of ander metodes om te kyk of 'n debugger aangeheg is.
- **Anti-Debugging APIs**: Soek na oproepe na anti-debugging APIs soos `ptrace` of `SIGSTOP`, byvoorbeeld `ptrace(PT_DENY_ATTACH, 0, 0, 0)`.
- **Timing-kontroles**: Meet die tyd wat sekere operasies neem en kyk vir afwykings wat debugging kan aandui.
- **Geheuekontroles**: Inspekteer geheue vir bekende debugger-artefakte of wysigings.
- **Omgewingveranderlikes**: Kyk vir omgewingveranderlikes wat 'n debugging-sessie kan aandui.
- **Mach Ports**: Ontdek of mach exception ports deur debuggers gebruik word.

### Basiese Dinamiese Ontleding

Kyk na die dinamiese ontleding wat [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) uitvoer. Jy sal deur die verskillende skerms moet navigeer en daarmee interaksie hê — dit sal verskeie classes hook terwyl dit ander dinge doen en 'n verslag voorberei sodra jy klaar is.

### Lys geïnstalleerde apps

Gebruik die opdrag `frida-ps -Uai` om die **bundle identifier** van die geïnstalleerde apps te bepaal:
```bash
$ frida-ps -Uai
PID  Name                 Identifier
----  -------------------  -----------------------------------------
6847  Calendar             com.apple.mobilecal
6815  Mail                 com.apple.mobilemail
-  App Store            com.apple.AppStore
-  Apple Store          com.apple.store.Jolly
-  Calculator           com.apple.calculator
-  Camera               com.apple.camera
-  iGoat-Swift          OWASP.iGoat-Swift
```
### Basic Enumeration & Hooking

Leer hoe om die components van die application te enumerate en hoe om maklik methods en classes te hook met objection:

{{#ref}}
ios-hooking-with-objection.md
{{#endref}}

### IPA Structure

Die struktuur van 'n **IPA file** is in wese dié van 'n **zipped package**. Deur die extensie na `.zip` te hernoem, kan dit **gedekomprimeer** word om sy inhoud te openbaar. Binne hierdie struktuur verteenwoordig 'n **Bundle** 'n volledig gepakketteerde toepassing gereed vir installasie. Binne sal jy 'n gids genaamd `<NAME>.app` vind, wat die toepassing se hulpbronne inkapsuleer.

- **`Info.plist`**: Hierdie lêer bevat spesifieke konfigurasie-besonderhede van die toepassing.
- **`_CodeSignature/`**: Hierdie gids sluit 'n plist-lêer in wat 'n signature bevat, en sodoende die integriteit van alle lêers in die bundle verseker.
- **`Assets.car`**: 'n Gecomprimeerde argief wat asset-lêers soos ikone stoor.
- **`Frameworks/`**: Hierdie vouer huisves die toepassing se native libraries, wat in die vorm van `.dylib` of `.framework` lêers kan wees.
- **`PlugIns/`**: Dit kan uitbreidings van die toepassing insluit, bekend as `.appex`-lêers, alhoewel dit nie altyd teenwoordig is nie. \* [**`Core Data`**](https://developer.apple.com/documentation/coredata): Dit word gebruik om jou toepassing se permanente data vir offline gebruik te stoor, om tydelike data te cache, en om undo-funksionaliteit by jou app op 'n enkele toestel te voeg. Om data oor verskeie toestelle in 'n enkele iCloud-rekening te sinkroniseer, spieël Core Data outomaties jou skema na 'n CloudKit container.
- [**`PkgInfo`**](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigApplications.html): Die `PkgInfo` lêer is 'n alternatiewe manier om die tipe en skepper-kodes van jou toepassing of bundle te spesifiseer.
- **en.lproj, fr.proj, Base.lproj**: Is die taalpakkette wat hulpbronne vir daardie spesifieke tale bevat, en 'n standaardhulpbron vir die geval dat 'n taal nie ondersteun word nie.
- **Security**: Die `_CodeSignature/` gids speel 'n kritieke rol in die app se sekuriteit deur die integriteit van alle ingesluit lêers deur digitale signatures te verifieer.
- **Asset Management**: Die `Assets.car` lêer gebruik kompressie om grafiese assets doeltreffend te bestuur, wat noodsaaklik is vir die optimalisering van toepassingsprestasie en die vermindering van die algehele grootte.
- **Frameworks and PlugIns**: Hierdie gidse beklemtoon die modulariteit van iOS-toepassings, wat ontwikkelaars toelaat om herbruikbare code libraries (`Frameworks/`) in te sluit en app-funksionaliteit uit te brei (`PlugIns/`).
- **Localization**: Die struktuur ondersteun meertaligheid, wat globale bereik van die toepassing vergemaklik deur hulpbronne vir spesifieke taalpakkette in te sluit.

**Info.plist**

Die **Info.plist** dien as 'n hoeksteen vir iOS-toepassings en enkapsuleer sleutel-konfigurasiedata in die vorm van **key-value** pare. Hierdie lêer is verpligtend nie net vir toepassings nie, maar ook vir app extensions en frameworks wat binne gebundel is. Dit is gestruktureer in óf XML óf 'n binêre formaat en bevat kritiese inligting wat wissel van app permits tot sekuriteitskonfigurasies. Vir 'n gedetaileerde ondersoek van beskikbare sleutels, kan mens verwys na die [**Apple Developer Documentation**](https://developer.apple.com/documentation/bundleresources/information_property_list?language=objc).

Vir dié wat met hierdie lêer in 'n meer toeganklike formaat wil werk, kan die XML-omsetting moeiteloos bereik word deur gebruik te maak van `plutil` op macOS (natief beskikbaar op weergawes 10.2 en later) of `plistutil` op Linux. Die opdragte vir omskakeling is soos volg:

- **For macOS**:
```bash
$ plutil -convert xml1 Info.plist
```
- **Vir Linux**:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
Onder die magdom inligting wat die **Info.plist**-lêer kan openbaar, is noemenswaardige inskrywings onder meer app-toestemmingsstrings (`UsageDescription`), pasgemaakte URL-skemas (`CFBundleURLTypes`) en konfigurasies vir App Transport Security (`NSAppTransportSecurity`). Hierdie inskrywings, saam met ander soos uitgevoerde/ingevoerde pasgemaakte dokumenttipes (`UTExportedTypeDeclarations` / `UTImportedTypeDeclarations`), kan moeiteloos gevind word deur die lêer te inspekteer of 'n eenvoudige `grep`-opdrag te gebruik:
```bash
$ grep -i <keyword> Info.plist
```
**Datapaaie**

In die iOS-omgewing is gidses spesifiek aangewys vir **stelseltoepassings** en **deur gebruikers geïnstalleerde toepassings**. Stelseltoepassings woon in die `/Applications` gids, terwyl deur gebruikers geïnstalleerde apps geplaas word onder `/var/mobile/containers/Data/Application/`. Hierdie toepassings word 'n unieke identifiseerder toegeken wat bekend staan as 'n **128-bit UUID**, wat die taak om handmatig 'n app se gids te vind uitdagend maak as gevolg van die ewekansigheid van die gidsname.

> [!WARNING]
> Aangesien toepassings in iOS gesandbox moet wees, sal elke app ook 'n gids hê binne **`$HOME/Library/Containers`** met die app se **`CFBundleIdentifier`** as die gidsnaam.
>
> Echter, beide gidse (data- & container-gidse) het die lêer **`.com.apple.mobile_container_manager.metadata.plist`** wat beide lêers koppel in die sleutel `MCMetadataIdentifier`).

Om die ontdekking van 'n deur gebruiker geïnstalleerde app se installasiegids te vergemaklik, bied die **objection tool** 'n nuttige opdrag, `env`. Hierdie opdrag openbaar gedetailleerde gidsinligting vir die betrokke app. Hieronder is 'n voorbeeld van hoe om hierdie opdrag te gebruik:
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # env

Name               Path
-----------------  -------------------------------------------------------------------------------------------
BundlePath         /var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app
CachesDirectory    /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library/Caches
DocumentDirectory  /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Documents
LibraryDirectory   /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library
```
Alternatiewelik kan die app-naam binne `/private/var/containers` met die `find`-opdrag gesoek word:
```bash
find /private/var/containers -name "Progname*"
```
Bevels soos `ps` en `lsof` kan ook gebruik word om onderskeidelik die app se proses te identifiseer en oop lêers te lys, wat insigte in die app se aktiewe gidspaaie verskaf:
```bash
ps -ef | grep -i <app-name>
lsof -p <pid> | grep -i "/containers" | head -n 1
```
**Bundel-gids:**

- **AppName.app**
- Dit is die Application Bundle soos voorheen in die IPA gesien; dit bevat noodsaaklike toepassingsdata, statiese inhoud sowel as die toepassing se saamgestelde binêr.
- Hierdie gids is sigbaar vir gebruikers, maar **gebruikers kan nie daarin skryf nie**.
- Inhoud in hierdie gids word **nie gerugsteun nie**.
- Die inhoud van hierdie vouer word gebruik om die **kode-handtekening te verifieer**.

**Datagids:**

- **Documents/**
- Bevat alle deur gebruikers gegenereerde data. Die eindgebruiker van die toepassing inisieer die skep van hierdie data.
- Sigbaar vir gebruikers en **gebruikers kan daarin skryf**.
- Inhoud in hierdie gids word **gerugsteun**.
- Die app kan paaie deaktiveer deur `NSURLIsExcludedFromBackupKey` te stel.
- **Library/**
- Bevat alle **lêers wat nie gebruiker-spesifiek is nie**, soos **caches**, **preferences**, **cookies**, en property list (plist) konfigurasielêers.
- iOS-apps gebruik gewoonlik die `Application Support` en `Caches` subgidse, maar die app kan aangepaste subgidse skep.
- **Library/Caches/**
- Bevat **semi-permanente gekasde lêers.**
- Onsigbaar vir gebruikers en **gebruikers kan daarin nie skryf nie**.
- Inhoud in hierdie gids word **nie gerugsteun nie**.
- Die OS mag die lêers in hierdie gids outomaties verwyder wanneer die app nie loop nie en stoorruimte min raak.
- **Library/Application Support/**
- Bevat **permanente** **lêers** wat nodig is vir die werking van die app.
- **Onsigbaar** **vir** **gebruikers** en gebruikers kan nie daarin skryf nie.
- Inhoud in hierdie gids word **gerugsteun**.
- Die app kan paaie deaktiveer deur `NSURLIsExcludedFromBackupKey` te stel.
- **Library/Preferences/**
- Word gebruik om eienskappe te stoor wat **selfs ná 'n herbegin van die toepassing kan voortbestaan**.
- Inligting word onversleuteld binne die toepassingssandbox gestoor in 'n plist-lêer met die naam \[BUNDLE_ID].plist.
- Al die sleutel/waarde-paartjies wat met `NSUserDefaults` gestoor is, kan in hierdie lêer gevind word.
- **tmp/**
- Gebruik hierdie gids om **tydelike lêers** te skryf wat nie tussen opstartings van die app hoef te bly nie.
- Bevat nie-permanente gekasde lêers.
- **Onsigbaar** vir gebruikers.
- Inhoud in hierdie gids word nie gerugsteun nie.
- Die OS mag die lêers in hierdie gids outomaties verwyder wanneer die app nie loop nie en stoorruimte min raak.

Kom ons neem 'n nader kyk na iGoat-Swift se Application Bundle (.app) gids binne die Bundel-gids (`/var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app`):
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # ls
NSFileType      Perms  NSFileProtection    ...  Name
------------  -------  ------------------  ...  --------------------------------------
Regular           420  None                ...  rutger.html
Regular           420  None                ...  mansi.html
Regular           420  None                ...  splash.html
Regular           420  None                ...  about.html

Regular           420  None                ...  LICENSE.txt
Regular           420  None                ...  Sentinel.txt
Regular           420  None                ...  README.txt
```
### Binary Reversing

Binne die `<application-name>.app` gids sal jy 'n binêre lêer met die naam `<application-name>` vind. Dit is die lêer wat **uitgevoer** sal word. Jy kan 'n basiese inspeksie van die binêre lêer uitvoer met die hulpmiddel **`otool`**:
```bash
otool -Vh DVIA-v2 #Check some compilation attributes
magic  cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64    ARM64        ALL  0x00     EXECUTE    65       7112   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE

otool -L DVIA-v2 #Get third party libraries
DVIA-v2:
/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.1)
/usr/lib/libsqlite3.dylib (compatibility version 9.0.0, current version 274.6.0)
/usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11)
@rpath/Bolts.framework/Bolts (compatibility version 1.0.0, current version 1.0.0)
[...]
```
**Kontroleer of die app geënkripteer is**

Kyk of daar enige uitset is vir:
```bash
otool -l <app-binary> | grep -A 4 LC_ENCRYPTION_INFO
```
**Disassembling the binary**

Disassemble the text section:
```bash
otool -tV DVIA-v2
DVIA-v2:
(__TEXT,__text) section
+[DDLog initialize]:
0000000100004ab8    sub    sp, sp, #0x60
0000000100004abc    stp    x29, x30, [sp, #0x50]   ; Latency: 6
0000000100004ac0    add    x29, sp, #0x50
0000000100004ac4    sub    x8, x29, #0x10
0000000100004ac8    mov    x9, #0x0
0000000100004acc    adrp    x10, 1098 ; 0x10044e000
0000000100004ad0    add    x10, x10, #0x268
```
Om die **Objective-C-segment** van die voorbeeldtoepassing te druk, kan mens gebruik:
```bash
otool -oV DVIA-v2
DVIA-v2:
Contents of (__DATA,__objc_classlist) section
00000001003dd5b8 0x1004423d0 _OBJC_CLASS_$_DDLog
isa        0x1004423a8 _OBJC_METACLASS_$_DDLog
superclass 0x0 _OBJC_CLASS_$_NSObject
cache      0x0 __objc_empty_cache
vtable     0x0
data       0x1003de748
flags          0x80
instanceStart  8
```
Om 'n meer kompakte Objective-C-kode te verkry, kan jy [**class-dump**](http://stevenygard.com/projects/class-dump/) gebruik:
```bash
class-dump some-app
//
//     Generated by class-dump 3.5 (64 bit).
//
//     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2013 by Steve Nygard.
//

#pragma mark Named Structures

struct CGPoint {
double _field1;
double _field2;
};

struct CGRect {
struct CGPoint _field1;
struct CGSize _field2;
};

struct CGSize {
double _field1;
double _field2;
};
```
Die beste opsies om die binêr te disasembleer is: [**Hopper**](https://www.hopperapp.com/download.html?) en [**IDA**](https://www.hex-rays.com/products/ida/support/download_freeware/).

## Gegewensberging

Om te leer hoe iOS data op die toestel stoor, lees hierdie bladsy:


{{#ref}}
ios-basics.md
{{#endref}}

> [!WARNING]
> Die volgende plekke waar inligting gestoor kan word moet **reg na die installering van die toepassing**, **na die kontrole van al die funksionaliteite** van die toepassing en selfs na **uitteken van een gebruiker en aanmelding as 'n ander gebruiker** nagegaan word.\
> Die doel is om **onbeskermde sensitiewe inligting** van die toepassing (wagwoorde, tokens), van die huidige gebruiker en van voorheen aangemelde gebruikers te vind.

### Plist

**plist**-lêers is gestruktureerde XML-lêers wat **sleutel-waarde-parings** bevat. Dit is 'n manier om permanente data te stoor, so soms kan jy **sensitiewe inligting in hierdie lêers** vind. Dit word aanbeveel om hierdie lêers na die installering van die app en na intensiewe gebruik te kontroleer om te sien of nuwe data geskryf is.

Die mees algemene manier om data in plist-lêers te behou is deur die gebruik van **NSUserDefaults**. Hierdie plist-lêer word binne die app-sandbox gestoor in **`Library/Preferences/<appBundleID>.plist`**

Die [`NSUserDefaults`](https://developer.apple.com/documentation/foundation/nsuserdefaults) klas bied 'n programmatiese koppelvlak om met die standaardstelsel te kommunikeer. Die standaardstelsel laat 'n toepassing toe om sy gedrag aan te pas volgens **gebruikersvoorkeure**. Data wat deur `NSUserDefaults` gestoor word, kan in die toepassingsbundle besigtig word. Hierdie klas stoor **data** in 'n **plist** **lêer**, maar dit is bedoel om met klein hoeveelhede data gebruik te word.

Hierdie data kan nie langer direk via 'n vertroude rekenaar toeganklik wees nie, maar kan bereik word deur 'n **backup** uit te voer.

Jy kan die inligting wat met **`NSUserDefaults`** gestoor is **dump** met behulp van objection se `ios nsuserdefaults get`

Om al die plist-lêers wat deur die toepassing gebruik word te vind, kan jy toegang kry tot `/private/var/mobile/Containers/Data/Application/{APPID}` en voer die volgende uit:
```bash
find ./ -name "*.plist"
```
Om lêers van **XML or binary (bplist)** formaat na XML om te skakel, is daar verskeie metodes beskikbaar wat afhang van jou bedryfstelsel:

**Vir macOS-gebruikers:** Gebruik die `plutil` opdrag. Dit is 'n ingeboude hulpmiddel in macOS (10.2+), ontwerp vir hierdie doel:
```bash
$ plutil -convert xml1 Info.plist
```
**Vir Linux-gebruikers:** Installeer `libplist-utils` eers, gebruik dan `plistutil` om jou lêer te omskep:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
**Within an Objection Session:** Vir die ontleding van mobiele toepassings stel 'n spesifieke opdrag jou in staat om plist-lêers direk te omskakel:
```bash
ios plist cat /private/var/mobile/Containers/Data/Application/<Application-UUID>/Library/Preferences/com.some.package.app.plist
```
### Core Data

[`Core Data`](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/nsfetchedresultscontroller.html#//apple_ref/doc/uid/TP40001075-CH8-SW1) is 'n raamwerk vir die bestuur van die modellaag van voorwerpe in jou toepassing. [Core Data can use SQLite as its persistent store](https://cocoacasts.com/what-is-the-difference-between-core-data-and-sqlite/), maar die raamwerk self is nie 'n databasis nie.\
CoreData enkripteer sy data nie standaard nie. Daar kan egter 'n ekstra enkripsielaag by CoreData gevoeg word. Sien die [GitHub Repo](https://github.com/project-imas/encrypted-core-data) vir meer besonderhede.

Jy kan die SQLite Core Data-inligting van 'n toepassing vind in die pad `/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support`

**As jy die SQLite kan oopmaak en toegang tot sensitiewe inligting kry, het jy 'n miskonfigurasie gevind.**
```objectivec:Code from iGoat
-(void)storeDetails {
AppDelegate * appDelegate = (AppDelegate *)(UIApplication.sharedApplication.delegate);

NSManagedObjectContext *context =[appDelegate managedObjectContext];

User *user = [self fetchUser];
if (user) {
return;
}
user = [NSEntityDescription insertNewObjectForEntityForName:@"User"
inManagedObjectContext:context];
user.email = CoreDataEmail;
user.password = CoreDataPassword;
NSError *error;
if (![context save:&error]) {
NSLog(@"Error in saving data: %@", [error localizedDescription]);

}else{
NSLog(@"data stored in core data");
}
}
```
### YapDatabase

[YapDatabase](https://github.com/yapstudios/YapDatabase) is 'n key/value store gebou bo-op SQLite.\
Aangesien die Yap databases sqlite databases is, kan jy dit vind met die beoogde command in die vorige afdeling.

### Other SQLite Databases

Dit is algemeen dat toepassings hul eie sqlite database skep. Hulle mag **stoor** **gevoelige** **data** daarop en dit onversleuteld laat. Daarom is dit altyd interessant om elke databasis binne die toepassingsgids na te gaan. Gaan dus na die application directory waar die data gestoor word (`/private/var/mobile/Containers/Data/Application/{APPID}`)
```bash
find ./ -name "*.sqlite" -or -name "*.db"
```
### Firebase Real-Time Databases

Ontwikkelaars kan via Firebase Real-Time Databases **data stoor en sinkroniseer** binne 'n **NoSQL cloud-gehoste databasis**. In JSON-formaat gestoor, word die data in reële tyd na alle gekoppelde kliënte gesinkroniseer.

Jy kan hier sien hoe om verkeerd gekonfigureerde Firebase-databasisse te kontroleer:

{{#ref}}
../../network-services-pentesting/pentesting-web/buckets/firebase-database.md
{{#endref}}

### Realm databasisse

[Realm Objective-C](https://realm.io/docs/objc/latest/) en [Realm Swift](https://realm.io/docs/swift/latest/) bied 'n kragtige alternatief vir data-opberging wat nie deur Apple voorsien word nie. Per verstek **stoor hulle data onversleuteld**, enkripsie is egter beskikbaar deur spesifieke konfigurasie.

Die databasisse is geleë by: `/private/var/mobile/Containers/Data/Application/{APPID}`. Om hierdie lêers te verken, kan jy opdragte soos die volgende gebruik:
```bash
iPhone:/private/var/mobile/Containers/Data/Application/A079DF84-726C-4AEA-A194-805B97B3684A/Documents root# ls
default.realm  default.realm.lock  default.realm.management/  default.realm.note|

$ find ./ -name "*.realm*"
```
Om hierdie databasislêers te bekyk, word die [**Realm Studio**](https://github.com/realm/realm-studio) tool aanbeveel.

Om enkripsie binne 'n Realm-databasis te implementeer, kan die volgende kodefragment gebruik word:
```swift
// Open the encrypted Realm file where getKey() is a method to obtain a key from the Keychain or a server
let config = Realm.Configuration(encryptionKey: getKey())
do {
let realm = try Realm(configuration: config)
// Use the Realm as normal
} catch let error as NSError {
// If the encryption key is wrong, `error` will say that it's an invalid database
fatalError("Error opening realm: \(error)")
}
```
### Couchbase Lite Databasisse

[Couchbase Lite](https://github.com/couchbase/couchbase-lite-ios) word beskryf as 'n **liggewig** en **ingebedde** databasis-enjin wat die **dokument-georiënteerde** (NoSQL) benadering volg. Ontwerp om inheems te wees op **iOS** en **macOS**, bied dit die vermoë om data naatloos te sinkroniseer.

Om potensiële Couchbase-databasisse op 'n toestel te identifiseer, moet die volgende gids ondersoek word:
```bash
ls /private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support/
```
### Cookies

iOS stoor die cookies van die apps in die **`Library/Cookies/cookies.binarycookies`** binne elke app se gids. Ontwikkelaars besluit egter soms om dit in die **keychain** te stoor, aangesien die genoemde **cookie file in backups verkrygbaar is**.

Om die cookies-lêer te inspekteer kan jy [**hierdie python skrip**](https://github.com/mdegrazia/Safari-Binary-Cookie-Parser) gebruik of objection se **`ios cookies get`.**\
**Jy kan ook objection gebruik om** hierdie lêers na 'n JSON-formaat te omskep en die data te inspekteer.
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios cookies get --json
[
{
"domain": "highaltitudehacks.com",
"expiresDate": "2051-09-15 07:46:43 +0000",
"isHTTPOnly": "false",
"isSecure": "false",
"name": "username",
"path": "/",
"value": "admin123",
"version": "0"
}
]
```
### Cache

By default NSURLSession stores data, such as **HTTP requests and responses in the Cache.db** database. Hierdie databasis kan **sensitiewe data** bevat, indien tokens, gebruikersname of enige ander sensitiewe inligting in die kas gestoor is. Om die gekashde inligting te vind, open die data-gids van die app (`/var/mobile/Containers/Data/Application/<UUID>`) en gaan na `/Library/Caches/<Bundle Identifier>`. Die **WebKit cache is ook in die Cache.db gestoor** lêer. **Objection** kan die databasis oopmaak en daarmee interaksie hê met die opdrag `sqlite connect Cache.db`, aangesien dit 'n n**ormale SQLite database** is.

Dit word **aanbeveel om hierdie data se caching te deaktiveer**, aangesien dit sensitiewe inligting in die versoek of respons kan bevat. Die volgende lys wys verskillende maniere om dit te bereik:

1.  Dit word aanbeveel om gekashde responsse na logout te verwyder. Dit kan gedoen word met die deur Apple verskafde metode genaamd [`removeAllCachedResponses`](https://developer.apple.com/documentation/foundation/urlcache/1417802-removeallcachedresponses). Jy kan hierdie metode soos volg aanroep:

`URLCache.shared.removeAllCachedResponses()`

Hierdie metode sal alle gekashde versoeke en responsse uit die Cache.db lêer verwyder.

2.  As jy nie die voordeel van cookies nodig het nie, is dit aanbeveel om bloot die [.ephemeral](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral) configuration property van URLSession te gebruik, wat die stoor van cookies en caches sal deaktiveer.

[Apple documentation](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral):

`An ephemeral session configuration object is similar to a default session configuration (see default), except that the corresponding session object doesn’t store caches, credential stores, or any session-related data to disk. Instead, session-related data is stored in RAM. The only time an ephemeral session writes data to disk is when you tell it to write the contents of a URL to a file.`

3.  Cache kan ook gedeaktiveer word deur die Cache Policy op [.notAllowed](https://developer.apple.com/documentation/foundation/urlcache/storagepolicy/notallowed) te stel. Dit sal die stoor van Cache op enige wyse, hetsy in geheue of op skyf, deaktiveer.

### Snapshots

Whenever you press the home button, iOS **takes a snapshot of the current screen** to be able to do the transition to the application on a much smoother way. However, if **sensitive** **data** is present in the current screen, it will be **saved** in the **image** (which **persists** **across** **reboots**). These are the snapshots that you can also access double tapping the home screen to switch between apps.

Tensy die iPhone jailbroken is, moet die **attacker** fisiese **access** tot die **device** hê om hierdie skermkiekies te kan sien. Standaard word die laaste snapshot in die toepassing se sandbox gestoor in `Library/Caches/Snapshots/` of `Library/SplashBoard/Snapshots` gids (trusted computers kon nie vanaf iOX 7.0 toegang tot die filesystem kry nie).

Een manier om hierdie onwenslike gedrag te voorkom, is om 'n leë skerm te wys of die sensitiewe data te verwyder voordat die snapshot geneem word deur die `ApplicationDidEnterBackground()` funksie te gebruik.

Die volgende is 'n voorbeeld van 'n remediasie-metode wat 'n standaard skermkiekie sal stel.

Swift:
```swift
private var backgroundImage: UIImageView?

func applicationDidEnterBackground(_ application: UIApplication) {
let myBanner = UIImageView(image: #imageLiteral(resourceName: "overlayImage"))
myBanner.frame = UIScreen.main.bounds
backgroundImage = myBanner
window?.addSubview(myBanner)
}

func applicationWillEnterForeground(_ application: UIApplication) {
backgroundImage?.removeFromSuperview()
}
```
Objective-C:
```
@property (UIImageView *)backgroundImage;

- (void)applicationDidEnterBackground:(UIApplication *)application {
UIImageView *myBanner = [[UIImageView alloc] initWithImage:@"overlayImage.png"];
self.backgroundImage = myBanner;
self.backgroundImage.bounds = UIScreen.mainScreen.bounds;
[self.window addSubview:myBanner];
}

- (void)applicationWillEnterForeground:(UIApplication *)application {
[self.backgroundImage removeFromSuperview];
}
```
Dit stel die agtergrondbeeld op `overlayImage.png` wanneer die toepassing na die agtergrond verskuif word. Dit voorkom sensitiewe data leaks omdat `overlayImage.png` altyd die huidige aansig sal oorskryf.

### Keychain

Vir toegang tot en bestuur van die iOS keychain is instrumente soos [**Keychain-Dumper**](https://github.com/ptoomey3/Keychain-Dumper) beskikbaar, geskik vir jailbroken toestelle. Benewens bied [**Objection**](https://github.com/sensepost/objection) die opdrag `ios keychain dump` vir soortgelyke doeleindes.

#### **Storing Credentials**

Die **NSURLCredential**-klas is ideaal om sensitiewe inligting direk in die keychain te stoor en die behoefte aan NSUserDefaults of ander wrappers te omseil. Om credentials na login te stoor, word die volgende Swift code gebruik:
```swift
NSURLCredential *credential;
credential = [NSURLCredential credentialWithUser:username password:password persistence:NSURLCredentialPersistencePermanent];
[[NSURLCredentialStorage sharedCredentialStorage] setCredential:credential forProtectionSpace:self.loginProtectionSpace];
```
Om hierdie gestoorde credentials te onttrek, word Objection se opdrag `ios nsurlcredentialstorage dump` gebruik.

## **Pasgemaakte Toetsenborde en Toetsenbordkas**

Vanaf iOS 8.0 af kan gebruikers pasgemaakte toetsenbord-uitbreidings installeer, wat beheerd kan word onder **Settings > General > Keyboard > Keyboards**. Alhoewel hierdie toetsenborde uitgebreide funksionaliteit bied, hou hulle ŉ risiko van keystroke logging en die oordrag van data na eksterne bedieners in, al word gebruikers in kennis gestel van toetsenborde wat netwerktoegang benodig. Apps kan, en behoort, die gebruik van pasgemaakte toetsenborde te beperk wanneer sensitiewe inligting ingevoer word.

**Sekuriteitsaanbevelings:**

- Dit word aanbeveel om derdeparty-toetsenborde uit te skakel vir verbeterde sekuriteit.
- Wees bewus van die autocorrect en auto-suggestions funksies van die standaard iOS keyboard, wat sensitiewe inligting in cache-lêers kan stoor wat gevind word in `Library/Keyboard/{locale}-dynamic-text.dat` of `/private/var/mobile/Library/Keyboard/dynamic-text.dat`. Hierdie cache-lêers moet gereeld nagegaan word vir sensitiewe data. Dit word aanbeveel om die keyboard dictionary te herstel via **Settings > General > Reset > Reset Keyboard Dictionary** om ge-kachete data skoon te maak.
- Die onderskep van netwerkverkeer kan openbaar of ŉ pasgemaakte toetsenbord keystrokes na ŉ eksterne bediener uitstuur.

### **Voorkoming van teksveld-kas**

Die [UITextInputTraits protocol](https://developer.apple.com/reference/uikit/uitextinputtraits) bied properties om autocorrection en secure text entry te bestuur, wat noodsaaklik is om die kas van sensitiewe inligting te voorkom. Byvoorbeeld, die deaktivering van autocorrection en die aktivering van secure text entry kan bereik word met:
```objectivec
textObject.autocorrectionType = UITextAutocorrectionTypeNo;
textObject.secureTextEntry = YES;
```
Daarbenewens moet ontwikkelaars verseker dat teksvelde, veral dié wat gebruik word om sensitiewe inligting soos wagwoorde en PINs in te voer, caching deaktiveer deur `autocorrectionType` op `UITextAutocorrectionTypeNo` en `secureTextEntry` op `YES` te stel.
```objectivec
UITextField *textField = [[UITextField alloc] initWithFrame:frame];
textField.autocorrectionType = UITextAutocorrectionTypeNo;
```
## **Logs**

Foutopsporing van code behels dikwels die gebruik van **logging**. Daar is 'n risiko aangesien **logs kan sensitiewe inligting bevat**. Eerder, in iOS 6 en vroeëre weergawes, was logs toeganklik vir alle apps, wat 'n risiko van sensitive data leakage geskep het. **Nou is applications beperk tot toegang slegs tot hul logs**.

Ten spyte van hierdie beperkings kan 'n **attacker with physical access** tot 'n ontgrendelde toestel steeds hiervan voordeel trek deur die toestel aan 'n rekenaar te koppel en **reading the logs**. Dit is belangrik om daarop te let dat logs op die skyf bly selfs na die app se verwydering.

Om risiko's te beperk, word dit aanbeveel om **deeglik met die app te interaksioneer**, al sy funksies en insette te ondersoek om te verseker dat geen sensitiewe inligting per ongeluk in logs geregistreer word nie.

Wanneer die app se bronkode vir potensiële leaks nagegaan word, kyk vir beide **vooraf gedefinieerde** en **aangepaste logging statements** wat sleutelwoorde soos `NSLog`, `NSAssert`, `NSCAssert`, `fprintf` vir ingeboude funksies gebruik, en enige vermeldings van `Logging` of `Logfile` vir aangepaste implementasies.

### **Monitoring System Logs**

Apps log verskeie stukkies inligting wat sensitief kan wees. Om hierdie logs te moniteer, gereedskap en opdragte soos:
```bash
idevice_id --list   # To find the device ID
idevicesyslog -u <id> (| grep <app>)   # To capture the device logs
```
is nuttig. Daarbenewens bied **Xcode** 'n manier om konsole-logboodskappe te versamel:

1. Maak Xcode oop.
2. Koppel die iOS-toestel.
3. Gaan na **Window** -> **Devices and Simulators**.
4. Kies jou toestel.
5. Roep die probleem wat jy ondersoek op.
6. Gebruik die **Open Console**-knoppie om logboodskappe in 'n nuwe venster te besigtig.

Vir meer gevorderde logging kan aansluiting op die toestel se shell en die gebruik van **socat** regstreekse logmonitering bied:
```bash
iPhone:~ root# socat - UNIX-CONNECT:/var/run/lockdown/syslog.sock
```
Gevolg deur opdragte om logaktiwiteite waar te neem, wat van onskatbare waarde kan wees om probleme te diagnoseer of potensiële data leakage in logs te identifiseer.

## Rugsteun

**Outomatiese rugsteunfunksies** is in iOS geïntegreer en maak dit moontlik om kopieë van toesteldata te skep via iTunes (tot macOS Catalina), Finder (vanaf macOS Catalina), of iCloud. Hierdie rugsteunkopieë sluit byna alle toesteldata in, behalwe uiters sensitiewe items soos Apple Pay-details en Touch ID-konfigurasies.

### Sekuriteitsrisiko's

Die insluiting van **geïnstalleerde apps en hul data** in rugsteun verhoog die kwessie van potensiële **data leakage** en die risiko dat **rugsteunwysigings app-funksionaliteit kan verander**. Dit word aanbeveel om **nie sensitiewe inligting in plaintext te stoor** binne enige app se gids of subgidse nie om hierdie risiko's te beperk.

### Uitsluiting van lêers uit rugsteun

Lêers in `Documents/` en `Library/Application Support/` word standaard gerugsteun. Ontwikkelaars kan spesifieke lêers of gidse uitsluit van rugsteun deur `NSURL setResourceValue:forKey:error:` met die `NSURLIsExcludedFromBackupKey` te gebruik. Hierdie praktyk is noodsaaklik om sensitiewe data te beskerm teen inklusie in rugsteun.

### Toetsing vir kwesbaarhede

Om 'n app se rugsteunsekuriteit te evalueer, begin deur **'n rugsteun te skep** met Finder, en lokaliseer dit dan volgens die leiding van [Apple's official documentation](https://support.apple.com/en-us/HT204215). Ontleed die rugsteun vir sensitiewe data of konfigurasies wat verander kan word om die app se gedrag te beïnvloed.

Sensitiewe inligting kan opgespoor word met behulp van opdragreëlgereedskap of toepassings soos [iMazing](https://imazing.com). Vir geïnkripteerde rugsteun kan die teenwoordigheid van enkripsie bevestig word deur die "IsEncrypted" sleutel in die "Manifest.plist" lêer by die wortel van die rugsteun na te gaan.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
...
<key>Date</key>
<date>2021-03-12T17:43:33Z</date>
<key>IsEncrypted</key>
<true/>
...
</plist>
```
Om met geënkripteerde backups te werk, kan Python-skripte beskikbaar in [DinoSec's GitHub repo](https://github.com/dinosec/iphone-dataprotection/tree/master/python_scripts), soos **backup_tool.py** en **backup_passwd.py**, nuttig wees, alhoewel hulle moontlik aanpassings benodig om versoenbaar te wees met die nuutste iTunes/Finder-weergawes. Die [**iOSbackup** tool](https://pypi.org/project/iOSbackup/) is 'n ander opsie om toegang tot lêers binne wagwoord-beskermde backups te kry.

### Verandering van App-gedrag

'n Voorbeeld van die verander van app-gedrag deur backup-wysigings word gedemonstreer in die [Bither bitcoin wallet app](https://github.com/bither/bither-ios), waar die UI lock PIN in `net.bither.plist` onder die **pin_code** sleutel gestoor word. Deur hierdie sleutel uit die plist te verwyder en die backup te herstel, verdwyn die PIN-vereiste en word onbeperkte toegang verleen.

## Opsomming oor geheue-toetsing vir sensitiewe data

Wanneer jy met sensitiewe inligting wat in 'n toepassing se geheue gestoor is werk, is dit van kritieke belang om die blootstellingstyd van hierdie data te beperk. Daar is twee hoofbenaderings om geheue-inhoud te ondersoek: **skep van 'n geheue-dump** en **analiseer die geheue in real time**. Albei metodes het hul uitdagings, insluitend die potensiaal om kritieke data te mis gedurende die dump-proses of analise.

## **Herverkry en analiseer 'n geheue-dump**

Vir beide jailbroken en non-jailbroken toestelle, laat gereedskap soos [objection](https://github.com/sensepost/objection) en [Fridump](https://github.com/Nightbringer21/fridump) toe om 'n app se prosesgeheue te dump. Nadat dit gedump is, vereis die analise van hierdie data verskeie gereedskap, afhangende van die aard van die inligting waarna jy soek.

Om strings uit 'n geheue-dump te onttrek, kan opdragte soos `strings` of `rabin2 -zz` gebruik word:
```bash
# Extracting strings using strings command
$ strings memory > strings.txt

# Extracting strings using rabin2
$ rabin2 -ZZ memory > strings.txt
```
Vir meer gedetailleerde ontleding, insluitend die soek na spesifieke datatipes of patrone, bied **radare2** uitgebreide soekvermoëns:
```bash
$ r2 <name_of_your_dump_file>
[0x00000000]> /?
...
```
## **Runtime Geheue-analise**

**r2frida** bied 'n kragtige alternatief om 'n app se memory in real time te ondersoek, sonder om 'n memory dump nodig te hê. Hierdie hulpmiddel maak dit moontlik om search commands direk op die running application's memory uit te voer:
```bash
$ r2 frida://usb//<name_of_your_app>
[0x00000000]> /\ <search_command>
```
## Gebroke Kriptografie

### Swak Sleutelbestuursprosesse

Sommige ontwikkelaars stoor sensitiewe data in die lokale stoor en enkripteer dit met 'n sleutel wat hardcoded/predictable in die kode is. Dit behoort nie te gebeur nie aangesien sommige reversing aanvallers kan toelaat om die vertroulike inligting uit te trek.

### Gebruik van Onveilige en/of Verouderde Algoritmes

Ontwikkelaars behoort nie **deprecated algorithms** te gebruik om authorisation **checks**, **store** of **send** data uit te voer nie. Sommige van hierdie algoritmes is: RC4, MD4, MD5, SHA1... As **hashes** byvoorbeeld gebruik word om wagwoorde te stoor, behoort brute-force **resistant** hashes met salt gebruik te word.

### Kontrole

Die hoofkontroles wat uitgevoer moet word is om te kyk of jy **hardcoded** wagwoorde/geheime in die kode kan vind, of dit **predictable** is, en of die kode 'n soort **weak** **cryptography** algoritmes gebruik.

Dit is interessant om te weet dat jy sommige **crypto** **libraries** outomaties kan **monitor** met **objection**:
```swift
ios monitor crypt
```
Vir **meer inligting** oor iOS-kryptografiese APIs en biblioteke, besoek [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography)

## Plaaslike autentisering

**Plaaslike autentisering** speel 'n kritieke rol, veral wanneer dit gaan oor die beskerming van toegang by 'n afgeleë eindpunt deur middel van kryptografiese metodes. Die kern hier is dat sonder behoorlike implementering plaaslike autentiseringsmeganismes omseil kan word.

Apple se [**Local Authentication framework**](https://developer.apple.com/documentation/localauthentication) en die [**keychain**](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html) bied robuuste APIs wat ontwikkelaars onderskeidelik help om gebruiker-verifikasie-dialoë te vertoon en om geheime data veilig te hanteer. Die Secure Enclave beveilig vingerafdruk-ID vir Touch ID, terwyl Face ID op gesigsherkenning staatmaak sonder om biometriese data te kompromitteer.

Om Touch ID/Face ID te integreer, het ontwikkelaars twee API-keuses:

- **`LocalAuthentication.framework`** vir hoëvlak gebruiker-verifikasie sonder toegang tot biometriese data.
- **`Security.framework`** vir laer-vlak keychain-diens toegang, wat geheime data met biometriese verifikasie beveilig. Verskeie [open-source wrappers](https://www.raywenderlich.com/147308/secure-ios-user-data-keychain-touch-id) maak keychain-toegang eenvoudiger.

> [!CAUTION]
> Beide `LocalAuthentication.framework` en `Security.framework` bevat egter kwesbaarhede, aangesien hulle hoofsaaklik booleaanse waardes teruggee sonder om data vir verifikasieprosesse te stuur, wat dit vatbaar maak vir omseilings (verwys na [Don't touch me that way, by David Lindner et al](https://www.youtube.com/watch?v=XhXIHVGCFFM)).

### Implementering van plaaslike autentisering

Om gebruikers vir verifikasie te versoek, moet ontwikkelaars die **`evaluatePolicy`**-metode binne die **`LAContext`**-klas gebruik, met die keuse tussen:

- **`deviceOwnerAuthentication`**: Vra vir Touch ID of die toestel se toegangskode; misluk as geen van beide geaktiveer is.
- **`deviceOwnerAuthenticationWithBiometrics`**: Vra uitsluitlik vir Touch ID.

'n Suksesvolle verifikasie word aangedui deur 'n booleaanse terugwaarde van **`evaluatePolicy`**, wat 'n potensiële sekuriteitsgebrek uitlig.

### Plaaslike autentisering met die keychain

Die implementering van **plaastlike autentisering** in iOS-apps behels die gebruik van **keychain APIs** om geheime data soos authentiseringstokens veilig te stoor. Hierdie proses verseker dat die data slegs deur die gebruiker benader kan word, met hulle toestel se toegangskode of biometriese verifikasie soos Touch ID.

Die keychain bied die vermoë om items met die `SecAccessControl`-attribuut te stel, wat toegang tot die item beperk totdat die gebruiker suksesvol geverifieer het via Touch ID of die toestel se toegangskode. Hierdie funksie is noodsaaklik vir die verbetering van sekuriteit.

Hieronder is kodevoorbeelde in Swift en Objective-C wat demonstreer hoe om 'n string na/en vanaf die keychain te stoor en te haal, terwyl hierdie sekuriteitskenmerke gebruik word. Die voorbeelde wys spesifiek hoe om toegangbeheer op te stel om Touch ID-verifikasie te vereis en te verseker dat die data slegs op die toestel waarop dit opgestel is toeganklik is, op voorwaarde dat 'n toestel se toegangskode gekonfigureer is.

{{#tabs}}
{{#tab name="Swift"}}
```swift
// From https://github.com/mufambisi/owasp-mstg/blob/master/Document/0x06f-Testing-Local-Authentication.md

// 1. create AccessControl object that will represent authentication settings

var error: Unmanaged<CFError>?

guard let accessControl = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
SecAccessControlCreateFlags.biometryCurrentSet,
&error) else {
// failed to create AccessControl object

return
}

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute

var query: [String: Any] = [:]

query[kSecClass as String] = kSecClassGenericPassword
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecAttrAccount as String] = "OWASP Account" as CFString
query[kSecValueData as String] = "test_strong_password".data(using: .utf8)! as CFData
query[kSecAttrAccessControl as String] = accessControl

// 3. save item

let status = SecItemAdd(query as CFDictionary, nil)

if status == noErr {
// successfully saved
} else {
// error while saving
}
```
{{#endtab}}

{{#tab name="Objective-C"}}
```objectivec
// 1. create AccessControl object that will represent authentication settings
CFErrorRef *err = nil;

SecAccessControlRef sacRef = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
kSecAccessControlUserPresence,
err);

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute
NSDictionary* query = @{
(_ _bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecAttrAccount: @"OWASP Account",
(__bridge id)kSecValueData: [@"test_strong_password" dataUsingEncoding:NSUTF8StringEncoding],
(__bridge id)kSecAttrAccessControl: (__bridge_transfer id)sacRef
};

// 3. save item
OSStatus status = SecItemAdd((__bridge CFDictionaryRef)query, nil);

if (status == noErr) {
// successfully saved
} else {
// error while saving
}
```
{{#endtab}}
{{#endtabs}}

Nou kan ons die gestoorde item uit die keychain versoek. Keychain services sal die outentiseringsdialoog aan die gebruiker voorlê en data of nil teruggee, afhangend daarvan of 'n geskikte vingerafdruk voorsien is of nie.

{{#tabs}}
{{#tab name="Swift"}}
```swift
// 1. define query
var query = [String: Any]()
query[kSecClass as String] = kSecClassGenericPassword
query[kSecReturnData as String] = kCFBooleanTrue
query[kSecAttrAccount as String] = "My Name" as CFString
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecUseOperationPrompt as String] = "Please, pass authorisation to enter this area" as CFString

// 2. get item
var queryResult: AnyObject?
let status = withUnsafeMutablePointer(to: &queryResult) {
SecItemCopyMatching(query as CFDictionary, UnsafeMutablePointer($0))
}

if status == noErr {
let password = String(data: queryResult as! Data, encoding: .utf8)!
// successfully received password
} else {
// authorization not passed
}
```
{{#endtab}}

{{#tab name="Objective-C"}}
```objectivec
// 1. define query
NSDictionary *query = @{(__bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecReturnData: @YES,
(__bridge id)kSecAttrAccount: @"My Name1",
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecUseOperationPrompt: @"Please, pass authorisation to enter this area" };

// 2. get item
CFTypeRef queryResult = NULL;
OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)query, &queryResult);

if (status == noErr){
NSData* resultData = ( __bridge_transfer NSData* )queryResult;
NSString* password = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding];
NSLog(@"%@", password);
} else {
NSLog(@"Something went wrong");
}
```
{{#endtab}}
{{#endtabs}}

### Opsporing

Die gebruik van frameworks in 'n app kan ook opgespoor word deur die app-binary se lys gedeelde dinamiese biblioteke te analiseer. Dit kan gedoen word deur `otool` te gebruik:
```bash
$ otool -L <AppName>.app/<AppName>
```
As `LocalAuthentication.framework` in 'n app gebruik word, sal die uitset albei van die volgende reëls bevat (onthou dat `LocalAuthentication.framework` `Security.framework` onder die kap gebruik):
```bash
/System/Library/Frameworks/LocalAuthentication.framework/LocalAuthentication
/System/Library/Frameworks/Security.framework/Security
```
As `Security.framework` gebruik word, sal slegs die tweede een gewys word.

### Local Authentication Framework Bypass

#### **Objection**

Deur die **Objection Biometrics Bypass**, geleë by [this GitHub page](https://github.com/sensepost/objection/wiki/Understanding-the-iOS-Biometrics-Bypass), is daar 'n tegniek beskikbaar om die **LocalAuthentication**-meganisme te oorwin. Die kern van hierdie benadering behels die gebruik van **Frida** om die `evaluatePolicy`-funksie te manipuleer, sodat dit konsekwent 'n `True` uitslag lewer, ongeag die werklike sukses van die verifikasie. Dit is veral nuttig om gebrekkige biometric authentication processes te omseil.

Om hierdie bypass te aktiveer, word die volgende opdrag gebruik:
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios ui biometrics_bypass
(agent) Registering job 3mhtws9x47q. Type: ios-biometrics-disable
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # (agent) [3mhtws9x47q] Localized Reason for auth requirement: Please authenticate yourself
(agent) [3mhtws9x47q] OS authentication response: false
(agent) [3mhtws9x47q] Marking OS response as True instead
(agent) [3mhtws9x47q] Biometrics bypass hook complete
```
Hierdie opdrag ontketen 'n reeks waarin Objection 'n taak registreer wat die uitslag van die `evaluatePolicy`-kontrole effektief verander na `True`.

#### Frida

'n voorbeeld van die gebruik van **`evaluatePolicy`** van [DVIA-v2 application](https://github.com/prateek147/DVIA-v2):
```swift
+(void)authenticateWithTouchID {
LAContext *myContext = [[LAContext alloc] init];
NSError *authError = nil;
NSString *myLocalizedReasonString = @"Please authenticate yourself";

if ([myContext canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&authError]) {
[myContext evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics
localizedReason:myLocalizedReasonString
reply:^(BOOL success, NSError *error) {
if (success) {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Successful" withTitle:@"Success"];
});
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Failed !" withTitle:@"Error"];
});
}
}];
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Your device doesn't support Touch ID or you haven't configured Touch ID authentication on your device" withTitle:@"Error"];
});
}
}
```
Om die **bypass** van Local Authentication te bereik, word 'n Frida-skrip geskryf. Hierdie skrip mik op die **evaluatePolicy**-kontrole en onderskep sy callback om te verseker dat dit **success=1** teruggee. Deur die gedrag van die callback te verander, word die authentication check effektief gebypass.

Die skrip hieronder word geïnjekteer om die resultaat van die **evaluatePolicy**-metode te wysig. Dit verander die callback se resultaat sodat dit altyd sukses aandui.
```swift
// from https://securitycafe.ro/2022/09/05/mobile-pentesting-101-bypassing-biometric-authentication/
if(ObjC.available) {
console.log("Injecting...");
var hook = ObjC.classes.LAContext["- evaluatePolicy:localizedReason:reply:"];
Interceptor.attach(hook.implementation, {
onEnter: function(args) {
var block = new ObjC.Block(args[4]);
const callback = block.implementation;
block.implementation = function (error, value)  {

console.log("Changing the result value to true")
const result = callback(1, null);
return result;
};
},
});
} else {
console.log("Objective-C Runtime is not available!");
}
```
Om die Frida script te inject en die biometric authentication te bypass, word die volgende opdrag gebruik:
```bash
frida -U -f com.highaltitudehacks.DVIAswiftv2 --no-pause -l fingerprint-bypass-ios.js
```
## Sensitive Functionality Exposure Through IPC

### Custom URI Handlers / Deeplinks / Custom Schemes


{{#ref}}
ios-custom-uri-handlers-deeplinks-custom-schemes.md
{{#endref}}

### Universal Links


{{#ref}}
ios-universal-links.md
{{#endref}}

### UIActivity Sharing


{{#ref}}
ios-uiactivity-sharing.md
{{#endref}}

### UIPasteboard


{{#ref}}
ios-uipasteboard.md
{{#endref}}

### App Extensions


{{#ref}}
ios-app-extensions.md
{{#endref}}

### WebViews


{{#ref}}
ios-webviews.md
{{#endref}}

### Serialisation and Encoding


{{#ref}}
ios-serialisation-and-encoding.md
{{#endref}}

## Netwerkkommunikasie

Dit is belangrik om te kontroleer dat geen kommunikasie plaasvind **without encryption** en ook dat die toepassing korrek die **validating the TLS certificate** van die bediener doen.\
Om hierdie soort probleme te toets kan jy 'n proxy soos **Burp** gebruik:


{{#ref}}
burp-configuration-for-ios.md
{{#endref}}

### Hostname check

Een algemene probleem by die valideer van die TLS-sertifikaat is om te kontroleer dat die sertifikaat deur 'n **trusted** **CA** onderteken is, maar **not check** of **the hostname** van die sertifikaat dieselfde is as die hostname wat geraak word.\
Om hierdie probleem met Burp te toets, nadat jy Burp CA op die iPhone vertrou het, kan jy **create a new certificate with Burp for a different hostname** en dit gebruik. As die toepassing steeds werk, is dit kwesbaar.

### Certificate Pinning

Indien 'n toepassing korrek SSL Pinning gebruik, sal die toepassing slegs werk as die sertifikaat die verwagte een is. By die toets van 'n toepassing **this might be a problem as Burp will serve it's own certificate.**\
Om hierdie beskerming op 'n jailbroken toestel te omseil, kan jy die toepassings [**SSL Kill Switch**](https://github.com/nabla-c0d3/ssl-kill-switch2) of [**Burp Mobile Assistant**](https://portswigger.net/burp/documentation/desktop/mobile/config-ios-device) installeer.

Jy kan ook **objection's** `ios sslpinning disable` gebruik

## Diverses

- In **`/System/Library`** kan jy die frameworks vind wat op die foon geïnstalleer is en deur stelseltoepassings gebruik word
- Toepassings wat deur die gebruiker uit die App Store geïnstalleer is, is geleë in **`/User/Applications`**
- En **`/User/Library`** bevat data gestoor deur toepassings op gebruikersvlak
- Jy kan toegang kry tot **`/User/Library/Notes/notes.sqlite`** om die notas wat binne die toepassing gestoor is te lees.
- Binne die gids van 'n geïnstalleerde toepassing (**`/User/Applications/<APP ID>/`**) kan jy enkele interessante lêers vind:
- **`iTunesArtwork`**: Die ikoon wat deur die app gebruik word
- **`iTunesMetadata.plist`**: Inligting oor die app wat in die App Store gebruik word
- **`/Library/*`**: Bevat die voorkeure en kas. In **`/Library/Cache/Snapshots/*`** kan jy die snapshot vind wat van die toepassing geneem is voordat dit na die agtergrond gestuur is.

### Hot Patching/Verpligte Opdatering

Ontwikkelaars kan op afstand alle installasies van hul app onmiddellik **patch all installations of their app instantly** sonder om die toepassing weer by die App Store in te dien en te wag tot dit goedgekeur is.\
Hiervoor word gewoonlik [**JSPatch**](https://github.com/bang590/JSPatch) gebruik. Maar daar is ook ander opsies soos [Siren](https://github.com/ArtSabintsev/Siren) en [react-native-appstore-version-checker](https://www.npmjs.com/package/react-native-appstore-version-checker).\
**Dit is 'n gevaarlike meganisme wat deur kwaadwillige derdeparty SDKs misbruik kan word; daarom word aanbeveel om te kontroleer watter metode vir automatic updating (indien enige) gebruik word en dit te toets.** Jy kan probeer om 'n vorige weergawe van die app af te laai vir hierdie doel.

### Third Parties

'n Beduidende uitdaging met **3rd party SDKs** is die **lack of granular control** oor hul funksionaliteite. Ontwikkelaars staan voor 'n keuse: óf die SDK integreer en al sy funksies aanvaar, insluitend potensiële sekuriteitskwesbaarhede en privaatheidskwessies, óf heeltemal afstand doen van sy voordele. Dikwels kan ontwikkelaars nie self kwesbaarhede binne hierdie SDKs patch nie. Verder, namate SDKs vertroue in die gemeenskap kry, kan sommige begin om malware te bevat.

Die dienste wat deur derdeparty SDKs verskaf word, kan gebruikersgedragopsporing, advertensie-weergawes, of verbeterings aan die gebruikerservaring insluit. Dit bring egter 'n risiko mee aangesien ontwikkelaars moontlik nie ten volle bewus is van die kode wat deur hierdie biblioteke uitgevoer word nie, wat tot potensiële privaatheids- en sekuriteitsrisiko's kan lei. Dit is belangrik om die inligting wat met derdeparty-dienste gedeel word tot slegs wat nodig is te beperk en te verseker dat geen sensitiewe data blootgestel word nie.

Implementering van derdeparty-dienste kom gewoonlik in twee vorms: 'n onafhanklike biblioteek of 'n volledige SDK. Om gebruikersprivaatheid te beskerm, behoort enige data wat met hierdie dienste gedeel word **anonymized** te word om die bekendmaking van Personal Identifiable Information (PII) te voorkom.

Om die biblioteke wat 'n toepassing gebruik te identifiseer, kan die **`otool`** opdrag gebruik word. Hierdie hulpmiddel moet teen die toepassing en elke gedeelde biblioteek wat dit gebruik, uitgevoer word om bykomende biblioteke te ontdek.
```bash
otool -L <application_path>
```
## Interessante Kwesbaarhede & Gevallestudies


{{#ref}}
air-keyboard-remote-input-injection.md
{{#endref}}

{{#ref}}
itunesstored-bookassetd-sandbox-escape.md
{{#endref}}

## **Verwysings & Meer Hulpbronne**

- [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering)
- [iOS & Mobile App Pentesting - INE](https://my.ine.com/CyberSecurity/courses/089d060b/ios-mobile-app-pentesting)
- [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/)
- [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/)
- [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/)
- [https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage](https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage)
- [https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way](https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053)
- [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060)
- [https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/](https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064](https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064)
- [https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc](https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054)
- [https://github.com/ivRodriguezCA/RE-iOS-Apps/](https://github.com/ivRodriguezCA/RE-iOS-Apps/) IOS gratis kursus([https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/](https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/))
- [https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577](https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577)
- [https://www.slideshare.net/RyanISI/ios-appsecurityminicourse](https://www.slideshare.net/RyanISI/ios-appsecurityminicourse)
- [https://github.com/prateek147/DVIA](https://github.com/prateek147/DVIA)
- [https://github.com/prateek147/DVIA-v2](https://github.com/prateek147/DVIA-v2)
- [https://github.com/OWASP/MSTG-Hacking-Playground%20](https://github.com/OWASP/MSTG-Hacking-Playground)
- OWASP iGoat [_https://github.com/OWASP/igoat_](https://github.com/OWASP/igoat) <<< Objective-C weergawe [_https://github.com/OWASP/iGoat-Swift_](https://github.com/OWASP/iGoat-Swift) <<< Swift weergawe
- [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
- [https://github.com/nabla-c0d3/ssl-kill-switch2](https://github.com/nabla-c0d3/ssl-kill-switch2)


{{#include ../../banners/hacktricks-training.md}}
