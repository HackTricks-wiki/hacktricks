# iOS Pentesting

{{#include ../../banners/hacktricks-training.md}}

## iOS Basics


{{#ref}}
ios-basics.md
{{#endref}}

## Testing Environment

इस पृष्ठ में आप **iOS simulator**, **emulators** और **jailbreaking** के बारे में जानकारी पाएंगे:


{{#ref}}
ios-testing-environment.md
{{#endref}}

## Initial Analysis

### Basic iOS Testing Operations

परीक्षण के दौरान **कई ऑपरेशन्स सुझाए जाएँगे** (डिवाइस से कनेक्ट करना, फ़ाइलें read/write/upload/download करना, कुछ tools का उपयोग करना ...). इसलिए, यदि आप इन किसी भी क्रियाओं को करना नहीं जानते हैं तो कृपया **पृष्ठ पढ़ना शुरू करें**:


{{#ref}}
basic-ios-testing-operations.md
{{#endref}}

> [!TIP]
> For the following steps **the app should be installed** in the device and should have already obtained the **IPA file** of the application.\
> Read the [Basic iOS Testing Operations](basic-ios-testing-operations.md) page to learn how to do this.

### Basic Static Analysis

कुछ उपयोगी iOS - IPA files decompilers:

- [https://github.com/LaurieWired/Malimite](https://github.com/LaurieWired/Malimite)
- [https://ghidra-sre.org/](https://ghidra-sre.org/)

यह अनुशंसित है कि ऑटोमेटेड Static Analysis के लिए [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) टूल का उपयोग किया जाए।

बाइनरी में मौजूद सुरक्षा उपायों की पहचान:

- **PIE (Position Independent Executable)**: सक्षम होने पर, एप्लिकेशन हर बार लॉन्च होने पर एक यादृच्छिक मेमोरी एड्रेस पर लोड होता है, जिससे इसकी प्रारंभिक मेमोरी एड्रेस की भविष्यवाणी करना कठिन हो जाता है।

```bash
otool -hv <app-binary> | grep PIE   # It should include the PIE flag
```

- **Stack Canaries**: स्टैक की अखंडता सत्यापित करने के लिए, फ़ंक्शन कॉल से पहले स्टैक पर एक ‘canary’ मान रखा जाता है और फ़ंक्शन समाप्त होने पर इसे फिर से सत्यापित किया जाता है।

```bash
otool -I -v <app-binary> | grep stack_chk   # It should include the symbols: stack_chk_guard and stack_chk_fail
```

- **ARC (Automatic Reference Counting)**: सामान्य memory corruption दोषों को रोकने के लिए

```bash
otool -I -v <app-binary> | grep objc_release   # It should include the _objc_release symbol
```

- **Encrypted Binary**: बाइनरी को encrypted होना चाहिए

```bash
otool -arch all -Vl <app-binary> | grep -A5 LC_ENCRYPT   # The cryptid should be 1
```

**संवेदनशील/असुरक्षित फ़ंक्शन्स की पहचान**

- **Weak Hashing Algorithms**

```bash
# On the iOS device
otool -Iv <app> | grep -w "_CC_MD5"
otool -Iv <app> | grep -w "_CC_SHA1"

# On linux
grep -iER "_CC_MD5"
grep -iER "_CC_SHA1"
```

- **Insecure Random Functions**

```bash
# On the iOS device
otool -Iv <app> | grep -w "_random"
otool -Iv <app> | grep -w "_srand"
otool -Iv <app> | grep -w "_rand"

# On linux
grep -iER "_random"
grep -iER "_srand"
grep -iER "_rand"
```

- **Insecure ‘Malloc’ Function**

```bash
# On the iOS device
otool -Iv <app> | grep -w "_malloc"

# On linux
grep -iER "_malloc"
```

- **Insecure and Vulnerable Functions**

```bash
# On the iOS device
otool -Iv <app> | grep -w "_gets"
otool -Iv <app> | grep -w "_memcpy"
otool -Iv <app> | grep -w "_strncpy"
otool -Iv <app> | grep -w "_strlen"
otool -Iv <app> | grep -w "_vsnprintf"
otool -Iv <app> | grep -w "_sscanf"
otool -Iv <app> | grep -w "_strtok"
otool -Iv <app> | grep -w "_alloca"
otool -Iv <app> | grep -w "_sprintf"
otool -Iv <app> | grep -w "_printf"
otool -Iv <app> | grep -w "_vsprintf"

# On linux
grep -R "_gets"
grep -iER "_memcpy"
grep -iER "_strncpy"
grep -iER "_strlen"
grep -iER "_vsnprintf"
grep -iER "_sscanf"
grep -iER "_strtok"
grep -iER "_alloca"
grep -iER "_sprintf"
grep -iER "_printf"
grep -iER "_vsprintf"
```

#### Common Jailbreak detection methods

- **File System Checks**: सामान्य jailbreak फ़ाइलों और निर्देशिकाओं की उपस्थिति देखें, जैसे कि `/Applications/Cydia.app` या `/Library/MobileSubstrate/MobileSubstrate.dylib`.
- **Sandbox Violations**: फ़ाइल सिस्टम के प्रतिबंधित क्षेत्रों तक पहुँचने का प्रयास करें, जो non-jailbroken डिवाइसों पर अवरुद्ध होना चाहिए।
- **API Checks**: जाँचें कि क्या प्रतिबंधित कॉल्स जैसे `fork()` से child process बनाना या `system()` से /bin/sh मौजूद है यह उपयोग किया जा सकता है।
- **Process Checks**: ज्ञात jailbreak-संबंधित प्रक्रियाओं की उपस्थिति की निगरानी करें, जैसे `Cydia`, `Substrate`, या `ssh`.
- **Kernel Exploits**: उन kernel exploits की उपस्थिति की जाँच करें जो आमतौर पर jailbreaks में उपयोग होते हैं।
- **Environment Variables**: jailbreak के संकेतों के लिए environment variables की जाँच करें, जैसे `DYLD_INSERT_LIBRARIES`.
- **Libraries Check**: ऐप प्रोसेस में लोड की गई लाइब्रेरीज़ की जाँच करें।
- **Check schemes**: जैसे `canOpenURL(URL(string: "cydia://"))`।

#### Common Anti-Debugging detection methods

- **Check for Debugger Presence**: जांचने के लिए `sysctl` या अन्य तरीकों का उपयोग करें कि क्या कोई debugger जुड़ा हुआ है।
- **Anti-Debugging APIs**: anti-debugging APIs जैसे `ptrace` या `SIGSTOP` कॉल्स की तलाश करें, जैसे `ptrace(PT_DENY_ATTACH, 0, 0, 0)`.
- **Timing Checks**: कुछ ऑपरेशनों में लगे समय को मापें और debugging का संकेत देने वाले विसंगतियों की तलाश करें।
- **Memory Checks**: ज्ञात debugger artifacts या संशोधनों के लिए मेमोरी की जाँच करें।
- **Environment Variables**: debugging सत्र का संकेत देने वाले environment variables की जाँच करें।
- **Mach Ports**: पता लगाएँ कि क्या mach exception ports debuggers द्वारा उपयोग किए जा रहे हैं।

### Basic Dynamic Analysis

[**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) द्वारा किए जाने वाले dynamic analysis को देखें। आपको विभिन्न views में नेविगेट करना और उनके साथ इंटरैक्ट करना होगा, लेकिन यह कई classes को hook करेगा और अन्य चीज़ें करते हुए एक report तैयार करेगा जब आप समाप्त कर लेंगी/करेंगे।

### Listing Installed Apps

इंस्टॉल किए गए ऐप्स का **bundle identifier** निर्धारित करने के लिए `frida-ps -Uai` कमांड का उपयोग करें:
```bash
$ frida-ps -Uai
PID  Name                 Identifier
----  -------------------  -----------------------------------------
6847  Calendar             com.apple.mobilecal
6815  Mail                 com.apple.mobilemail
-  App Store            com.apple.AppStore
-  Apple Store          com.apple.store.Jolly
-  Calculator           com.apple.calculator
-  Camera               com.apple.camera
-  iGoat-Swift          OWASP.iGoat-Swift
```
### Basic Enumeration & Hooking

जानें कैसे **enumerate the components of the application** और कैसे आसानी से **hook methods and classes** को objection के साथ किया जा सकता है:


{{#ref}}
ios-hooking-with-objection.md
{{#endref}}

### IPA संरचना

एक **IPA file** की संरचना मूल रूप से एक **zipped package** जैसी होती है। इसकी extension को `.zip` में बदलकर इसे **decompressed** किया जा सकता है ताकि इसकी सामग्री दिखे। इस संरचना के अंदर, एक **Bundle** एक पूरी तरह पैकेज्ड application को दर्शाता है जो इंस्टॉलेशन के लिए तैयार होता है। भीतर, आपको `<NAME>.app` नामक एक निर्देशिका मिलेगी, जो एप्लिकेशन के resources को समाहित करती है।

- **`Info.plist`**: यह फ़ाइल एप्लिकेशन के विशिष्ट विन्यास विवरण रखती है।
- **`_CodeSignature/`**: यह निर्देशिका एक plist फ़ाइल शामिल करती है जिसमें एक signature होता है, जो bundle में सभी फ़ाइलों की अखंडता सुनिश्चित करता है।
- **`Assets.car`**: एक compressed archive जो icons जैसे asset फ़ाइलों को संग्रहित करता है।
- **`Frameworks/`**: यह फ़ोल्डर एप्लिकेशन की native libraries रखता है, जो `.dylib` या `.framework` फ़ाइलों के रूप में हो सकती हैं।
- **`PlugIns/`**: इसमें application के extensions शामिल हो सकते हैं, जिन्हें `.appex` फ़ाइलें कहा जाता है, हालांकि ये हमेशा मौजूद नहीं होते। \* [**`Core Data`**](https://developer.apple.com/documentation/coredata): यह आपके एप्लिकेशन के स्थायी डेटा को ऑफ़लाइन उपयोग के लिए सहेजने, अस्थायी डेटा को cache करने, और एकल डिवाइस पर undo कार्यक्षमता जोड़ने के लिए उपयोग किया जाता है। मल्टीपल डिवाइसों पर एक ही iCloud खाते में डेटा सिंक करने के लिए, Core Data स्वचालित रूप से आपके schema को एक CloudKit container में mirror कर देता है.
- [**`PkgInfo`**](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigApplications.html): `PkgInfo` फ़ाइल आपके application या bundle के type और creator codes को निर्दिष्ट करने का एक वैकल्पिक तरीका है।
- **en.lproj, fr.proj, Base.lproj**: ये language packs हैं जो उन विशेष भाषाओं के लिए resources रखते हैं, और यदि कोई भाषा समर्थित नहीं है तो एक default resource प्रदान करते हैं।
- **Security**: `_CodeSignature/` निर्देशिका एप्लिकेशन की सुरक्षा में एक महत्वपूर्ण भूमिका निभाती है, bundle में रखी सभी फ़ाइलों की अखंडता को digital signatures के माध्यम से verify करके।
- **Asset Management**: `Assets.car` फ़ाइल graphical assets को कुशलतापूर्वक प्रबंधित करने के लिए compression का उपयोग करती है, जो एप्लिकेशन प्रदर्शन को अनुकूलित करने और उसके कुल आकार को कम करने में महत्वपूर्ण है।
- **Frameworks and PlugIns**: ये डायरेक्टरीज़ iOS एप्लिकेशन की modularity को रेखांकित करती हैं, जिससे डेवलपर्स reusable code libraries (`Frameworks/`) शामिल कर सकते हैं और app functionality को विस्तार दे सकते हैं (`PlugIns/`)।
- **Localization**: यह संरचना कई भाषाओं का समर्थन करती है, विशिष्ट language packs के resources शामिल करके वैश्विक एप्लिकेशन पहुंच की सुविधा प्रदान करती है।

**Info.plist**

**Info.plist** iOS एप्लिकेशन के लिए एक आधारशिला के रूप में कार्य करती है, और इसमें **key-value** जोड़ों के रूप में प्रमुख विन्यास डेटा संजोया जाता है। यह फ़ाइल न केवल एप्लिकेशनों के लिए बल्कि bundled app extensions और frameworks के लिए भी आवश्यक है। यह XML या binary format में संरचित हो सकती है और एप परमिशन से लेकर security configurations तक महत्वपूर्ण जानकारी रखती है। उपलब्ध keys का विस्तृत शोध करने के लिए, आप [**Apple Developer Documentation**](https://developer.apple.com/documentation/bundleresources/information_property_list?language=objc) देख सकते हैं।

जो लोग इस फ़ाइल के साथ अधिक सुलभ फ़ॉर्मेट में काम करना चाहते हैं, उनके लिए XML conversion macOS पर `plutil` (versions 10.2 और बाद के संस्करणों में नेटिव रूप से उपलब्ध) या Linux पर `plistutil` का उपयोग करके आसानी से किया जा सकता है। conversion के लिए कमांड निम्नलिखित हैं:

- **macOS के लिए**:
```bash
$ plutil -convert xml1 Info.plist
```
- **Linux के लिए**:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
Among the myriad of information that the **Info.plist** file can divulge, notable entries include app permission strings (`UsageDescription`), custom URL schemes (`CFBundleURLTypes`), and configurations for App Transport Security (`NSAppTransportSecurity`). These entries, along with others like exported/imported custom document types (`UTExportedTypeDeclarations` / `UTImportedTypeDeclarations`), can be effortlessly located by inspecting the file or employing a simple `grep` command:
```bash
$ grep -i <keyword> Info.plist
```
**डेटा पथ**

iOS वातावरण में, डायरेक्टरीज़ विशेष रूप से **system applications** और **user-installed applications** के लिए निर्धारित की जाती हैं। System applications `/Applications` डायरेक्टरी में रहती हैं, जबकि user-installed apps `/var/mobile/containers/Data/Application/` के अंतर्गत रखे जाते हैं। इन एप्लिकेशन को एक अद्वितीय पहचानकर्ता दिया जाता है जिसे **128-bit UUID** कहा जाता है, जिससे डायरेक्टरी नामों की यादृच्छिकता के कारण किसी ऐप के फ़ोल्डर को मैन्युअली ढूँढना चुनौतीपूर्ण हो जाता है।

> [!WARNING]
> As applications in iOS must be sandboxed, each app will have also a folder inside **`$HOME/Library/Containers`** with app's **`CFBundleIdentifier`** as the folder name.
>
> However, both folders (data & container folders) have the file **`.com.apple.mobile_container_manager.metadata.plist`** that links both files in the key `MCMetadataIdentifier`).

किसी user-installed ऐप की इंस्टॉलेशन डायरेक्टरी खोजने में मदद के लिए, **objection tool** एक उपयोगी कमांड, `env`, प्रदान करता है। यह कमांड संबंधित ऐप के लिए विस्तृत डायरेक्टरी जानकारी दिखाता है। नीचे इस कमांड का उपयोग करने का एक उदाहरण दिया गया है:
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # env

Name               Path
-----------------  -------------------------------------------------------------------------------------------
BundlePath         /var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app
CachesDirectory    /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library/Caches
DocumentDirectory  /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Documents
LibraryDirectory   /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library
```
वैकल्पिक रूप से, ऐप का नाम `/private/var/containers` के भीतर `find` कमांड का उपयोग करके खोजा जा सकता है:
```bash
find /private/var/containers -name "Progname*"
```
कमांड जैसे `ps` और `lsof` का उपयोग क्रमशः ऐप की प्रक्रिया पहचानने और खुली फ़ाइलों की सूची दिखाने के लिए भी किया जा सकता है, जो एप्लिकेशन के सक्रिय डायरेक्टरी पथों की जानकारी प्रदान करते हैं:
```bash
ps -ef | grep -i <app-name>
lsof -p <pid> | grep -i "/containers" | head -n 1
```
**बंडल निर्देशिका:**

- **AppName.app**
- यह Application Bundle है जैसा कि पहले IPA में देखा गया था, यह आवश्यक application डेटा, static कंटेंट तथा application's compiled binary को समाहित करता है।
- यह डायरेक्टरी उपयोगकर्ताओं के लिए दिखाई देती है, लेकिन **users can't write to it**।
- इस डायरेक्टरी की सामग्री **backed up नहीं** की जाती है।
- इस फ़ोल्डर की सामग्री का उपयोग **code signature को validate** करने के लिए किया जाता है।

**Data directory:**

- **Documents/**
- इसमें सभी user-generated डेटा होता है। यह डाटा application के end user द्वारा बनवाया जाता है।
- उपयोगकर्ताओं के लिए दिखाई देता है और **users can write to it**।
- इस डायरेक्टरी की सामग्री **backed up** की जाती है।
- ऐप `NSURLIsExcludedFromBackupKey` सेट करके पाथ्स को disable कर सकता है।
- **Library/**
- इसमें सभी **files that aren't user-specific** होते हैं, जैसे **caches**, **preferences**, **cookies**, और property list (plist) configuration फ़ाइलें।
- iOS apps आमतौर पर `Application Support` और `Caches` subdirectories का उपयोग करते हैं, लेकिन ऐप custom subdirectories बना सकता है।
- **Library/Caches/**
- इसमें **semi-persistent cached files.** होते हैं।
- उपयोगकर्ताओं के लिए Invisible है और **users can't write to it**।
- इस डायरेक्टरी की सामग्री **backed up नहीं** की जाती है।
- जब ऐप नहीं चल रहा होता और स्टोरेज स्पेस कम होता है तो OS इस डायरेक्टरी की फ़ाइलों को स्वतः हटा सकता है।
- **Library/Application Support/**
- इसमें ऐप चलाने के लिए आवश्यक **persistent** **files** होते हैं।
- उपयोगकर्ताओं के लिए **Invisible** है और users इसमें लिख नहीं सकते।
- इस डायरेक्टरी की सामग्री **backed** **up** की जाती है।
- ऐप `NSURLIsExcludedFromBackupKey` सेट करके पाथ्स को disable कर सकता है।
- **Library/Preferences/**
- उन properties को स्टोर करने के लिए उपयोग किया जाता है जो **application restart के बाद भी persist** कर सकती हैं।
- Information unencrypted रूप में application sandbox के अंदर \[BUNDLE_ID].plist नामक एक plist फ़ाइल में सेव की जाती है।
- `NSUserDefaults` का उपयोग करके स्टोर किए गए सभी key/value pairs इस फ़ाइल में पाए जा सकते हैं।
- **tmp/**
- इस डायरेक्टरी का उपयोग उन **temporary files** को लिखने के लिए करें जिन्हें app launches के बीच में बनाए रखने की आवश्यकता नहीं है।
- इसमें non-persistent cached files होते हैं।
- उपयोगकर्ताओं के लिए **Invisible** है।
- इस डायरेक्टरी की सामग्री backed up नहीं की जाती है।
- जब ऐप नहीं चल रहा होता और स्टोरेज स्पेस कम होता है तो OS इस डायरेक्टरी की फ़ाइलों को स्वतः हटा सकता है।

आइए iGoat-Swift के Application Bundle (.app) डायरेक्टरी के अंदर Bundle डायरेक्टरी (`/var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app`) को नज़दीक से देखते हैं:
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # ls
NSFileType      Perms  NSFileProtection    ...  Name
------------  -------  ------------------  ...  --------------------------------------
Regular           420  None                ...  rutger.html
Regular           420  None                ...  mansi.html
Regular           420  None                ...  splash.html
Regular           420  None                ...  about.html

Regular           420  None                ...  LICENSE.txt
Regular           420  None                ...  Sentinel.txt
Regular           420  None                ...  README.txt
```
### Binary Reversing

`<application-name>.app` फ़ोल्डर के अंदर आपको `<application-name>` नाम की एक binary फ़ाइल मिलेगी। यह वही फ़ाइल है जिसे **निष्पादित किया जाएगा**। आप टूल **`otool`** के साथ binary की बेसिक जांच कर सकते हैं:
```bash
otool -Vh DVIA-v2 #Check some compilation attributes
magic  cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64    ARM64        ALL  0x00     EXECUTE    65       7112   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE

otool -L DVIA-v2 #Get third party libraries
DVIA-v2:
/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.1)
/usr/lib/libsqlite3.dylib (compatibility version 9.0.0, current version 274.6.0)
/usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11)
@rpath/Bolts.framework/Bolts (compatibility version 1.0.0, current version 1.0.0)
[...]
```
**जांचें कि ऐप encrypted है या नहीं**

देखें कि इसके लिए कोई output है या नहीं:
```bash
otool -l <app-binary> | grep -A 4 LC_ENCRYPTION_INFO
```
**Disassembling the binary**

text section को Disassemble करें:
```bash
otool -tV DVIA-v2
DVIA-v2:
(__TEXT,__text) section
+[DDLog initialize]:
0000000100004ab8    sub    sp, sp, #0x60
0000000100004abc    stp    x29, x30, [sp, #0x50]   ; Latency: 6
0000000100004ac0    add    x29, sp, #0x50
0000000100004ac4    sub    x8, x29, #0x10
0000000100004ac8    mov    x9, #0x0
0000000100004acc    adrp    x10, 1098 ; 0x10044e000
0000000100004ad0    add    x10, x10, #0x268
```
नमूना एप्लिकेशन के **Objective-C segment** को प्रिंट करने के लिए निम्नलिखित का उपयोग किया जा सकता है:
```bash
otool -oV DVIA-v2
DVIA-v2:
Contents of (__DATA,__objc_classlist) section
00000001003dd5b8 0x1004423d0 _OBJC_CLASS_$_DDLog
isa        0x1004423a8 _OBJC_METACLASS_$_DDLog
superclass 0x0 _OBJC_CLASS_$_NSObject
cache      0x0 __objc_empty_cache
vtable     0x0
data       0x1003de748
flags          0x80
instanceStart  8
```
अधिक संक्षिप्त Objective-C कोड प्राप्त करने के लिए आप [**class-dump**](http://stevenygard.com/projects/class-dump/):
```bash
class-dump some-app
//
//     Generated by class-dump 3.5 (64 bit).
//
//     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2013 by Steve Nygard.
//

#pragma mark Named Structures

struct CGPoint {
double _field1;
double _field2;
};

struct CGRect {
struct CGPoint _field1;
struct CGSize _field2;
};

struct CGSize {
double _field1;
double _field2;
};
```
हालाँकि, बाइनरी को disassemble करने के लिए सबसे अच्छे विकल्प हैं: [**Hopper**](https://www.hopperapp.com/download.html?) और [**IDA**](https://www.hex-rays.com/products/ida/support/download_freeware/).

## डेटा स्टोरेज

To learn about how iOS stores data in the device read this page:


{{#ref}}
ios-basics.md
{{#endref}}

> [!WARNING]
> The following places to store information should be checked **right after installing the application**, **after checking all the functionalities** of the application and even after **login out from one user and login into a different one**.\
> The goal is to find **unprotected sensitive information** of the application (passwords, tokens), of the current user and of previously logged users.

### Plist

**plist** फाइलें संरचित XML फ़ाइलें होती हैं जो **key-value pairs** पर आधारित होती हैं। यह स्थायी डेटा स्टोर करने का एक तरीका है, इसलिए कभी-कभी आप **इन फाइलों में संवेदनशील जानकारी** पा सकते हैं। सलाह दी जाती है कि इन फाइलों की जाँच ऐप इंस्टॉल करने के बाद और ऐप का भारी उपयोग करने के बाद करें ताकि देखें कि क्या नया डेटा लिखा गया है।

The most common way to persist data in plist files is through the usage of **NSUserDefaults**. This plist file is saved inside the app sandbox in **`Library/Preferences/<appBundleID>.plist`**

The [`NSUserDefaults`](https://developer.apple.com/documentation/foundation/nsuserdefaults) class provides a programmatic interface for interacting with the default system. The default system allows an application to customize its behaviour according to **user preferences**. Data saved by `NSUserDefaults` can be viewed in the application bundle. This class stores **data** in a **plist** **file**, but it's meant to be used with small amounts of data.

This data cannot be longer accessed directly via a trusted computer, but can be accessed performing a **backup**.

आप objection के `ios nsuserdefaults get` का उपयोग करके **`NSUserDefaults`** में सहेजी जानकारी को **dump** कर सकते हैं।

To find all the plist of used by the application you can access to `/private/var/mobile/Containers/Data/Application/{APPID}` and run:
```bash
find ./ -name "*.plist"
```
फ़ाइलों को **XML or binary (bplist)** फॉर्मैट से XML में कन्वर्ट करने के लिए, आपके ऑपरेटिंग सिस्टम के आधार पर विभिन्न तरीके उपलब्ध हैं:

**macOS उपयोगकर्ताओं के लिए:** `plutil` कमांड का उपयोग करें। यह macOS (10.2+) में एक बिल्ट-इन टूल है, जो इस उद्देश्य के लिए डिज़ाइन किया गया है:
```bash
$ plutil -convert xml1 Info.plist
```
**Linux उपयोगकर्ताओं के लिए:** पहले `libplist-utils` स्थापित करें, फिर अपनी फ़ाइल को कनवर्ट करने के लिए `plistutil` का उपयोग करें:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
**Objection सत्र के भीतर:** मोबाइल एप्लिकेशनों का विश्लेषण करने के लिए, एक विशेष कमांड आपको plist फ़ाइलों को सीधे रूपांतरित करने की अनुमति देता है:
```bash
ios plist cat /private/var/mobile/Containers/Data/Application/<Application-UUID>/Library/Preferences/com.some.package.app.plist
```
### Core Data

[`Core Data`](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/nsfetchedresultscontroller.html#//apple_ref/doc/uid/TP40001075-CH8-SW1) आपके एप्लिकेशन में वस्तुओं की model layer को प्रबंधित करने के लिए एक framework है। [Core Data can use SQLite as its persistent store](https://cocoacasts.com/what-is-the-difference-between-core-data-and-sqlite/), लेकिन framework स्वयं एक database नहीं है.\
CoreData डिफ़ॉल्ट रूप से अपने डेटा को encrypt नहीं करता। हालांकि, CoreData में अतिरिक्त encryption layer जोड़ी जा सकती है। अधिक जानकारी के लिए [GitHub Repo](https://github.com/project-imas/encrypted-core-data) देखें।

आप किसी एप्लिकेशन की SQLite Core Data जानकारी इस path में पा सकते हैं `/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support`

**यदि आप SQLite खोलकर संवेदनशील जानकारी तक पहुँच सकते हैं, तो आपने एक गलत कॉन्फ़िगरेशन पाया है।**
```objectivec:Code from iGoat
-(void)storeDetails {
AppDelegate * appDelegate = (AppDelegate *)(UIApplication.sharedApplication.delegate);

NSManagedObjectContext *context =[appDelegate managedObjectContext];

User *user = [self fetchUser];
if (user) {
return;
}
user = [NSEntityDescription insertNewObjectForEntityForName:@"User"
inManagedObjectContext:context];
user.email = CoreDataEmail;
user.password = CoreDataPassword;
NSError *error;
if (![context save:&error]) {
NSLog(@"Error in saving data: %@", [error localizedDescription]);

}else{
NSLog(@"data stored in core data");
}
}
```
### YapDatabase

[YapDatabase](https://github.com/yapstudios/YapDatabase) SQLite के ऊपर बना एक key/value स्टोर है.\
चूँकि Yap डेटाबेस SQLite डेटाबेस होते हैं, आप उन्हें पिछले सेक्शन में दिए गए कमांड का उपयोग करके ढूँढ सकते हैं।

### Other SQLite Databases

ऐप्लिकेशन सामान्यतः अपना खुद का SQLite डेटाबेस बनाती हैं। वे उन पर **संग्रहित** **संवेदनशील** **डेटा** रख सकती हैं और उसे अनएन्क्रिप्टेड छोड़ सकती हैं। इसलिए, एप्लिकेशन डायरेक्टरी के अंदर मौजूद हर डेटाबेस की जाँच करना हमेशा दिलचस्प होता है। इसलिए उस application directory में जाएँ जहाँ डेटा सेव होता है (`/private/var/mobile/Containers/Data/Application/{APPID}`)
```bash
find ./ -name "*.sqlite" -or -name "*.db"
```
### Firebase Real-Time Databases

डेवलपर्स को Firebase Real-Time Databases के माध्यम से एक **NoSQL cloud-hosted database** में डेटा **स्टोर और सिंक** करने की सुविधा मिलती है। JSON फॉर्मैट में संग्रहीत, यह डेटा सभी जुड़े क्लाइंट्स के साथ रियल-टाइम में सिंक्रनाइज़ हो जाता है।

You can find how to check for misconfigured Firebase databases here:


{{#ref}}
../../network-services-pentesting/pentesting-web/buckets/firebase-database.md
{{#endref}}

### Realm databases

[Realm Objective-C](https://realm.io/docs/objc/latest/) and [Realm Swift](https://realm.io/docs/swift/latest/) Apple द्वारा प्रदान नहीं किए गए डेटा स्टोरेज के लिए एक शक्तिशाली विकल्प प्रदान करते हैं। डिफ़ॉल्ट रूप से, वे डेटा **बिना एन्क्रिप्शन के स्टोर** करते हैं, जबकि एनक्रिप्शन विशिष्ट कॉन्फ़िगरेशन के माध्यम से उपलब्ध है।

The databases are located at: `/private/var/mobile/Containers/Data/Application/{APPID}`. To explore these files, one can utilize commands like:
```bash
iPhone:/private/var/mobile/Containers/Data/Application/A079DF84-726C-4AEA-A194-805B97B3684A/Documents root# ls
default.realm  default.realm.lock  default.realm.management/  default.realm.note|

$ find ./ -name "*.realm*"
```
इन डेटाबेस फ़ाइलों को देखने के लिए, [**Realm Studio**](https://github.com/realm/realm-studio) टूल की सिफारिश की जाती है।

Realm डेटाबेस में encryption लागू करने के लिए, निम्नलिखित कोड स्निपेट का उपयोग किया जा सकता है:
```swift
// Open the encrypted Realm file where getKey() is a method to obtain a key from the Keychain or a server
let config = Realm.Configuration(encryptionKey: getKey())
do {
let realm = try Realm(configuration: config)
// Use the Realm as normal
} catch let error as NSError {
// If the encryption key is wrong, `error` will say that it's an invalid database
fatalError("Error opening realm: \(error)")
}
```
### Couchbase Lite डेटाबेस

[Couchbase Lite](https://github.com/couchbase/couchbase-lite-ios) को एक **हल्का** और **एम्बेडेड** डेटाबेस इंजन के रूप में वर्णित किया गया है जो **दस्तावेज़-उन्मुख** (NoSQL) दृष्टिकोण का पालन करता है। यह **iOS** और **macOS** के लिए नेटिव रूप से डिज़ाइन किया गया है, और यह डेटा को निर्बाध रूप से sync करने की क्षमता प्रदान करता है।

डिवाइस पर संभावित Couchbase डेटाबेस की पहचान करने के लिए, निम्नलिखित डायरेक्टरी का निरीक्षण किया जाना चाहिए:
```bash
ls /private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support/
```
### Cookies

iOS ऐप्स की cookies प्रत्येक ऐप के फ़ोल्डर में **`Library/Cookies/cookies.binarycookies`** में स्टोर होती हैं। हालाँकि, डेवलपर्स कभी-कभी इन्हें **keychain** में सेव करने का निर्णय लेते हैं क्योंकि उल्लिखित **cookie file बैकअप में एक्सेस किया जा सकता है**।

cookies file का निरीक्षण करने के लिए आप [**this python script**](https://github.com/mdegrazia/Safari-Binary-Cookie-Parser) या objection के **`ios cookies get`.**\  
**You can also use objection to** इन फाइलों को JSON फॉर्मेट में कन्वर्ट करके डेटा का निरीक्षण कर सकते हैं।
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios cookies get --json
[
{
"domain": "highaltitudehacks.com",
"expiresDate": "2051-09-15 07:46:43 +0000",
"isHTTPOnly": "false",
"isSecure": "false",
"name": "username",
"path": "/",
"value": "admin123",
"version": "0"
}
]
```
### Cache

By default NSURLSession stores data, such as **HTTP requests and responses in the Cache.db** database. यह डेटाबेस संवेदनशील जानकारी रख सकता है, अगर tokens, usernames या कोई अन्य sensitive जानकारी कैश की गई हो। कैश्ड जानकारी खोजने के लिए ऐप के data directory (`/var/mobile/Containers/Data/Application/<UUID>`) को खोलें और `/Library/Caches/<Bundle Identifier>` पर जाएँ। The **WebKit cache is also being stored in the Cache.db** file. **Objection** `sqlite connect Cache.db` कमांड के साथ डेटाबेस खोलकर और इंटरैक्ट करके इसका उपयोग कर सकता है, क्योंकि यह एक सामान्य SQLite डेटाबेस है।

यह सुझाव दिया जाता है कि इस data को Caching से disable किया जाए, क्योंकि request या response में यह संवेदनशील जानकारी रख सकता है। नीचे दी गई सूची इसको हासिल करने के विभिन्न तरीके दिखाती है:

1.  यह सलाह दी जाती है कि logout के बाद Cached responses को हटाया जाए। यह Apple द्वारा प्रदान किए गए मेथड [`removeAllCachedResponses`](https://developer.apple.com/documentation/foundation/urlcache/1417802-removeallcachedresponses) के साथ किया जा सकता है। आप इस method को निम्नलिखित तरीके से कॉल कर सकते हैं:

`URLCache.shared.removeAllCachedResponses()`

यह method Cache.db फाइल से सभी cached requests और responses हटा देगी।

2.  अगर आपको cookies के लाभों का उपयोग करने की आवश्यकता नहीं है तो URLSession की [.ephemeral](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral) configuration property का उपयोग करने की सलाह दी जाती है, जो cookies और Caches को सेव करने को disable कर देगी।

[Apple documentation](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral):

`An ephemeral session configuration object is similar to a default session configuration (see default), except that the corresponding session object doesn’t store caches, credential stores, or any session-related data to disk. Instead, session-related data is stored in RAM. The only time an ephemeral session writes data to disk is when you tell it to write the contents of a URL to a file.`

3.  Cache को Cache Policy को [.notAllowed](https://developer.apple.com/documentation/foundation/urlcache/storagepolicy/notallowed) पर सेट करके भी disabled किया जा सकता है। यह किसी भी रूप में Cache को स्टोर करना निरस्त कर देगा, चाहे memory में हो या disk पर।

### Snapshots

जब भी आप home button दबाते हैं, iOS वर्तमान स्क्रीन का एक snapshot लेता है ताकि application के बीच transition बहुत smoother हो सके। हालांकि, अगर current screen पर कोई **sensitive** **data** मौजूद है, तो वह image में **saved** हो जाएगी (जो **reboots** के बाद भी **persist** कर सकती है)। ये वही snapshots हैं जिन्हें आप apps के बीच स्विच करने के लिए home screen को double tap करके भी access कर सकते हैं।

जब तक iPhone jailbroken नहीं है, तब तक इन screenshots को देखने के लिए हमलावर को device तक अनलॉक किया हुआ access चाहिए होता है। डिफ़ॉल्ट रूप से आखिरी snapshot application's sandbox में `Library/Caches/Snapshots/` या `Library/SplashBoard/Snapshots` फ़ोल्डर में स्टोर होता है (trusted computers iOS 7.0 से फाइलसिस्टम तक access नहीं कर पाते)।

इस बुरी प्रैक्टिस को रोकने का एक तरीका यह है कि snapshot लेने से पहले blank screen दिखा दी जाए या sensitive डेटा को हटाया जाए, जो कि `ApplicationDidEnterBackground()` फ़ंक्शन का उपयोग करके किया जा सकता है।

निम्न एक sample remediation method है जो एक default screenshot सेट करेगा।

Swift:
```swift
private var backgroundImage: UIImageView?

func applicationDidEnterBackground(_ application: UIApplication) {
let myBanner = UIImageView(image: #imageLiteral(resourceName: "overlayImage"))
myBanner.frame = UIScreen.main.bounds
backgroundImage = myBanner
window?.addSubview(myBanner)
}

func applicationWillEnterForeground(_ application: UIApplication) {
backgroundImage?.removeFromSuperview()
}
```
Objective-C:
```
@property (UIImageView *)backgroundImage;

- (void)applicationDidEnterBackground:(UIApplication *)application {
UIImageView *myBanner = [[UIImageView alloc] initWithImage:@"overlayImage.png"];
self.backgroundImage = myBanner;
self.backgroundImage.bounds = UIScreen.mainScreen.bounds;
[self.window addSubview:myBanner];
}

- (void)applicationWillEnterForeground:(UIApplication *)application {
[self.backgroundImage removeFromSuperview];
}
```
यह एप्लिकेशन के बैकग्राउंड में जाने पर बैकग्राउंड इमेज को `overlayImage.png` पर सेट कर देता है। यह संवेदनशील डेटा leak को रोकता है क्योंकि `overlayImage.png` हमेशा वर्तमान view को ओवरराइड कर देगा।

### Keychain

iOS keychain तक पहुँचने और उसे प्रबंधित करने के लिए [**Keychain-Dumper**](https://github.com/ptoomey3/Keychain-Dumper) जैसे टूल उपलब्ध हैं, जो jailbroken devices के लिए उपयुक्त हैं। इसके अतिरिक्त, [**Objection**](https://github.com/sensepost/objection) समान उद्देश्यों के लिए कमांड `ios keychain dump` प्रदान करता है।

#### **क्रेडेंशियल्स संग्रहीत करना**

**NSURLCredential** class keychain में सीधे संवेदनशील जानकारी सेव करने के लिए आदर्श है, जिससे NSUserDefaults या अन्य wrappers की आवश्यकता टल जाती है। लॉगिन के बाद क्रेडेंशियल्स स्टोर करने के लिए, निम्न Swift कोड उपयोग किया जाता है:
```swift
NSURLCredential *credential;
credential = [NSURLCredential credentialWithUser:username password:password persistence:NSURLCredentialPersistencePermanent];
[[NSURLCredentialStorage sharedCredentialStorage] setCredential:credential forProtectionSpace:self.loginProtectionSpace];
```
इन संग्रहीत क्रेडेंशियल्स को निकालने के लिए Objection का कमांड `ios nsurlcredentialstorage dump` उपयोग किया जाता है।

## **कस्टम कीबोर्ड और कीबोर्ड कैश**

iOS 8.0 से, उपयोगकर्ता custom keyboard extensions इंस्टॉल कर सकते हैं, जिन्हें **Settings > General > Keyboard > Keyboards** के अंतर्गत मैनेज किया जा सकता है। जबकि ये कीबोर्ड विस्तारित कार्यक्षमता देते हैं, ये keystroke logging और डेटा को बाहरी सर्वरों पर भेजने का जोखिम पैदा कर सकते हैं, हालांकि नेटवर्क एक्सेस की आवश्यकता वाले कीबोर्ड के बारे में उपयोगकर्ताओं को सूचित किया जाता है। ऐप्स संवेदनशील जानकारी दर्ज करने के लिए custom keyboards के उपयोग को प्रतिबंधित कर सकते हैं और करना चाहिए।

**सुरक्षा अनुशंसाएँ:**

- बेहतर सुरक्षा के लिए third-party keyboards को disable करने की सलाह दी जाती है।
- डिफ़ॉल्ट iOS कीबोर्ड की autocorrect और auto-suggestions सुविधाओं के बारे में जागरूक रहें, जो संवेदनशील जानकारी को कैश फ़ाइलों में स्टोर कर सकती हैं, जो `Library/Keyboard/{locale}-dynamic-text.dat` या `/private/var/mobile/Library/Keyboard/dynamic-text.dat` में स्थित होती हैं। इन कैश फ़ाइलों की नियमित रूप से जाँच की जानी चाहिए। कैश्ड डेटा साफ़ करने के लिए **Settings > General > Reset > Reset Keyboard Dictionary** के माध्यम से keyboard dictionary को reset करने की सलाह दी जाती है।
- नेटवर्क ट्रैफ़िक को intercept करने से पता चल सकता है कि कोई custom keyboard keystrokes को दूर से transmit कर रहा है या नहीं।

### **टेक्स्ट फ़ील्ड कैशिंग रोकना**

The [UITextInputTraits protocol](https://developer.apple.com/reference/uikit/uitextinputtraits) offers properties to manage autocorrection and secure text entry, essential for preventing sensitive information caching. For example, disabling autocorrection and enabling secure text entry can be achieved with:
```objectivec
textObject.autocorrectionType = UITextAutocorrectionTypeNo;
textObject.secureTextEntry = YES;
```
इसके अतिरिक्त, डेवलपर्स को यह सुनिश्चित करना चाहिए कि टेक्स्ट फ़ील्ड, विशेषकर passwords और PINs जैसी संवेदनशील जानकारी दर्ज करने वाले फ़ील्ड, कैशिंग अक्षम हों; इसके लिए `autocorrectionType` को `UITextAutocorrectionTypeNo` और `secureTextEntry` को `YES` पर सेट करें।
```objectivec
UITextField *textField = [[UITextField alloc] initWithFrame:frame];
textField.autocorrectionType = UITextAutocorrectionTypeNo;
```
## **Logs**

कोड डिबग करने में अक्सर **logging** का उपयोग होता है। इसमें जोखिम होता है क्योंकि **logs may contain sensitive information**।

पहले, iOS 6 और उससे पहले के versions में, logs सभी apps के लिए accessible थे, जिससे sensitive data leakage का जोखिम था। **Now, applications are restricted to accessing only their logs**।

इन सीमाओं के बावजूद, एक **attacker with physical access** अनलॉक किए गए डिवाइस तक पहुंच कर इसे exploit कर सकता है — डिवाइस को कंप्यूटर से कनेक्ट करके और **reading the logs**। यह ध्यान रखना महत्वपूर्ण है कि logs ऐप अनइंस्टॉल करने के बाद भी डिस्क पर बने रहते हैं।

जोखिम कम करने के लिए सलाह दी जाती है कि आप ऐप के साथ **thoroughly interact with the app**, इसकी सभी functionalities और inputs का परीक्षण करें ताकि कोई भी संवेदनशील जानकारी अनजाने में log न हो रही हो यह सुनिश्चित किया जा सके।

जब आप संभावित leaks के लिए app के source code की समीक्षा कर रहे हों, तो दोनों **predefined** और **custom logging statements** खोजें, और उन keywords जैसे `NSLog`, `NSAssert`, `NSCAssert`, `fprintf` (built-in functions के लिए) और किसी भी संदर्भ के लिए `Logging` या `Logfile` (custom implementations के लिए)।

### **Monitoring System Logs**

Apps विभिन्न प्रकार की जानकारी log करते हैं जो संवेदनशील हो सकती है। इन logs की निगरानी करने के लिए, निम्न tools और commands उपयोग किए जा सकते हैं:
```bash
idevice_id --list   # To find the device ID
idevicesyslog -u <id> (| grep <app>)   # To capture the device logs
```
उपयोगी होते हैं। इसके अलावा, **Xcode** कंसोल लॉग इकट्ठा करने का तरीका प्रदान करता है:

1. Xcode खोलें।
2. iOS डिवाइस कनेक्ट करें।
3. **Window** -> **Devices and Simulators** पर जाएं।
4. अपने डिवाइस का चयन करें।
5. उस समस्या को ट्रिगर करें जिसे आप जांच रहे हैं।
6. लॉग्स देखने के लिए **Open Console** बटन का उपयोग करें, जो एक नई विंडो में खुलेगा।

अधिक उन्नत लॉगिंग के लिए, डिवाइस shell से कनेक्ट करके और **socat** का उपयोग करके आप रीयल-टाइम लॉग मॉनिटरिंग प्राप्त कर सकते हैं:
```bash
iPhone:~ root# socat - UNIX-CONNECT:/var/run/lockdown/syslog.sock
```
Followed by commands to observe log activities, which can be invaluable for diagnosing issues or identifying potential data leakage in logs.

## बैकअप

**Auto-backup features** iOS में अंतर्निहित हैं, जो iTunes (up to macOS Catalina), Finder (from macOS Catalina onward), या iCloud के माध्यम से डिवाइस डेटा की कॉपियाँ बनाने की सुविधा देते हैं। ये बैकअप लगभग सभी डिवाइस डेटा को शामिल करते हैं, सिवाय अत्यंत संवेदनशील तत्वों जैसे Apple Pay विवरण और Touch ID कॉन्फ़िगरेशन के।

### सुरक्षा जोखिम

बैकअप में **installed apps and their data** का शामिल होना संभावित **data leakage** और इस बात का जोखिम पैदा करता है कि **backup modifications could alter app functionality**। इन जोखिमों को कम करने के लिए किसी भी ऐप की डायरेक्टरी या उसके सबडायरेक्टरीज़ में संवेदनशील जानकारी को plaintext में संग्रहीत न करने की सलाह दी जाती है।

### बैकअप से फ़ाइलों को बाहर करना

`Documents/` और `Library/Application Support/` में मौजूद फ़ाइलें डिफ़ॉल्ट रूप से बैकअप की जाती हैं। डेवलपर्स विशिष्ट फ़ाइलों या डायरेक्टरीज़ को बैकअप से बाहर करने के लिए `NSURL setResourceValue:forKey:error:` का उपयोग कर सकते हैं, साथ में `NSURLIsExcludedFromBackupKey`। यह अभ्यास संवेदनशील डेटा को बैकअप में शामिल होने से बचाने के लिए महत्वपूर्ण है।

### कमजोरियों का परीक्षण

किसी ऐप की बैकअप सुरक्षा का आकलन करने के लिए, पहले Finder का उपयोग करके **बैकअप बनाना** शुरू करें, फिर इसे ढूँढने के लिए [Apple's official documentation](https://support.apple.com/en-us/HT204215) के निर्देशों का पालन करें। ऐसे बैकअप का विश्लेषण करें कि क्या उसमें संवेदनशील डेटा या कॉन्फ़िगरेशन हैं जिन्हें बदला जा सकता है और जो ऐप के व्यवहार को प्रभावित कर सकते हैं।

संवेदनशील जानकारी को कमांड-लाइन टूल्स या [iMazing](https://imazing.com) जैसे एप्लिकेशनों का उपयोग करके खोजा जा सकता है। encrypted backups के लिए, एन्क्रिप्शन की उपस्थिति की पुष्टि बैकअप की रूट में मौजूद "Manifest.plist" फ़ाइल में "IsEncrypted" key की जाँच करके की जा सकती है।
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
...
<key>Date</key>
<date>2021-03-12T17:43:33Z</date>
<key>IsEncrypted</key>
<true/>
...
</plist>
```
For dealing with encrypted backups, Python scripts available in [DinoSec's GitHub repo](https://github.com/dinosec/iphone-dataprotection/tree/master/python_scripts), like **backup_tool.py** and **backup_passwd.py**, may be useful, albeit potentially requiring adjustments for compatibility with the latest iTunes/Finder versions. The [**iOSbackup** tool](https://pypi.org/project/iOSbackup/) is another option for accessing files within password-protected backups.

### ऐप व्यवहार बदलना

बैकअप संशोधनों के माध्यम से ऐप व्यवहार बदलने का एक उदाहरण [Bither bitcoin wallet app](https://github.com/bither/bither-ios) में दिखाया गया है, जहाँ UI lock PIN `net.bither.plist` में **pin_code** key के तहत संग्रहीत होता है। इस key को plist से हटाकर और बैकअप को पुनर्स्थापित करने पर PIN आवश्यक नहीं रहता, जिससे अनियंत्रित पहुँच मिल जाती है।

## संवेदनशील डेटा के लिए मेमोरी परीक्षण का सारांश

जब किसी ऐप के मेमोरी में संग्रहीत संवेदनशील जानकारी से निपटा जाता है, तो इस डेटा के एक्सपोज़र समय को सीमित करना अत्यंत महत्वपूर्ण है। मेमोरी सामग्री की जांच के दो मुख्य तरीके हैं: **creating a memory dump** और **analyzing the memory in real time**। दोनों तरीकों में चुनौतियाँ हैं, जिनमें dump प्रक्रिया या विश्लेषण के दौरान महत्वपूर्ण डेटा छूट जाने की संभावना शामिल है।

## **Retrieving and Analyzing a Memory Dump**

For both jailbroken and non-jailbroken devices, tools like [objection](https://github.com/sensepost/objection) and [Fridump](https://github.com/Nightbringer21/fridump) allow for the dumping of an app's process memory. Once dumped, analyzing this data requires various tools, depending on the nature of the information you're searching for.

To extract strings from a memory dump, commands such as `strings` or `rabin2 -zz` can be used:
```bash
# Extracting strings using strings command
$ strings memory > strings.txt

# Extracting strings using rabin2
$ rabin2 -ZZ memory > strings.txt
```
अधिक विस्तृत विश्लेषण के लिए, जिसमें विशिष्ट डेटा प्रकार या पैटर्न की खोज शामिल है, **radare2** व्यापक खोज क्षमताएँ प्रदान करता है:
```bash
$ r2 <name_of_your_dump_file>
[0x00000000]> /?
...
```
## **रनटाइम मेमोरी विश्लेषण**

**r2frida** वास्तविक समय में किसी ऐप की memory का निरीक्षण करने के लिए एक शक्तिशाली विकल्प प्रदान करता है, और इसके लिए memory dump की आवश्यकता नहीं होती। यह टूल चल रही application's memory पर सीधे search commands निष्पादित करने में सक्षम बनाता है:
```bash
$ r2 frida://usb//<name_of_your_app>
[0x00000000]> /\ <search_command>
```
## Broken Cryptography

### Poor Key Management Processes

कुछ developers संवेदनशील डेटा local storage में सहेजते हैं और उसे code में hardcoded/predictable key से encrypt कर देते हैं। ऐसा नहीं करना चाहिए क्योंकि कुछ reversing से attackers confidential जानकारी निकाल सकते हैं।

### Use of Insecure and/or Deprecated Algorithms

Developers को authorisation **checks**, डेटा **store** या **send** करने के लिए **deprecated algorithms** का उपयोग नहीं करना चाहिए। इनमें कुछ algorithms हैं: RC4, MD4, MD5, SHA1... उदाहरण के लिए यदि पासवर्ड store करने के लिए **hashes** का उपयोग किया जाता है, तो salt के साथ brute-force **resistant** **hashes** का उपयोग किया जाना चाहिए।

### जाँच

मुख्य जाँचें यह ढूँढना हैं कि क्या आप कोड में **hardcoded** passwords/secrets ढूँढ सकते हैं, या क्या वे **predictable** हैं, और क्या कोड किसी तरह के **weak** **cryptography** algorithms का उपयोग कर रहा है।

यह जानना उपयोगी है कि आप कुछ **crypto** **libraries** को स्वचालित रूप से **monitor** करने के लिए **objection** का उपयोग कर सकते हैं:
```swift
ios monitor crypt
```
For **more information** about iOS cryptographic APIs and libraries access [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography)

## Local Authentication

**Local Authentication** विशेष रूप से महत्वपूर्ण भूमिका निभाता है, खासकर जब यह cryptographic तरीकों के माध्यम से किसी रिमोट एंडपॉइंट पर एक्सेस की सुरक्षा से संबंधित होता है। मुद्दा यह है कि सही तरीके से लागू न किए जाने पर local authentication mechanisms को बायपास किया जा सकता है।

Apple का [**Local Authentication framework**](https://developer.apple.com/documentation/localauthentication) और [**keychain**](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html) डेवलपर्स को उपयोगकर्ता authentication dialogs दिखाने और secret data को सुरक्षित तरीके से संभालने के लिए मजबूत APIs प्रदान करते हैं। Secure Enclave, Touch ID के लिए fingerprint ID को सुरक्षित करता है, जबकि Face ID facial recognition पर निर्भर करता है बिना biometric data को compromise किए।

Touch ID/Face ID को integrate करने के लिए डेवलपर्स के पास दो API विकल्प हैं:

- **`LocalAuthentication.framework`** — high-level user authentication के लिए, बिना biometric data तक पहुंच के।
- **`Security.framework`** — lower-level keychain services के लिए, biometric authentication के साथ secret data को secure करने के लिए। विभिन्न [open-source wrappers](https://www.raywenderlich.com/147308/secure-ios-user-data-keychain-touch-id) keychain access को सरल बनाते हैं।

> [!CAUTION]
> हालांकि, `LocalAuthentication.framework` और `Security.framework` दोनों कमजोरियों के प्रति संवेदनशील हैं, क्योंकि वे मुख्य रूप से authentication प्रक्रियाओं के लिए डेटा प्रेषित किए बिना boolean मान लौटाते हैं, जिससे इन्हें बायपास किया जा सकता है (संदर्भ के लिए देखें [Don't touch me that way, by David Lindner et al](https://www.youtube.com/watch?v=XhXIHVGCFFM))।

### Implementing Local Authentication

उपयोगकर्ताओं से authentication के लिए prompt करने हेतु, डेवलपर्स को **`LAContext`** क्लास के भीतर मौजूद **`evaluatePolicy`** मेथड का उपयोग करना चाहिए, और निम्नलिखित में से चुनना चाहिए:

- **`deviceOwnerAuthentication`**: Touch ID या device passcode के लिए prompt करता है, और यदि दोनों में से कोई सक्षम नहीं है तो असफल हो जाता है।
- **`deviceOwnerAuthenticationWithBiometrics`**: केवल Touch ID के लिए prompt करता है।

सफल authentication का संकेत **`evaluatePolicy`** से लौटाए गए boolean मान द्वारा मिलता है, जो एक संभावित सुरक्षा दोष को दर्शाता है।

### Local Authentication using Keychain

iOS ऐप्स में **local authentication** लागू करने का मतलब है कि secret data जैसे authentication tokens को सुरक्षित रूप से स्टोर करने के लिए **keychain APIs** का उपयोग किया जाए। यह प्रक्रिया सुनिश्चित करती है कि डेटा केवल उपयोगकर्ता द्वारा ही एक्सेस किया जा सके, उनके device passcode या biometric authentication (जैसे Touch ID) का उपयोग करके।

keychain आइटम्स को `SecAccessControl` attribute के साथ सेट करने की क्षमता देता है, जो आइटम तक पहुंच को तब तक प्रतिबंधित करता है जब तक उपयोगकर्ता सफलतापूर्वक Touch ID या device passcode के माध्यम से प्रमाणित न हो जाए। यह फीचर सुरक्षा बढ़ाने के लिए महत्वपूर्ण है।

नीचे Swift और Objective-C में कोड उदाहरण दिए गए हैं जो दिखाते हैं कि कैसे keychain में एक string सेव और रिट्रीव की जाती है, इन सुरक्षा फीचर्स का उपयोग करते हुए। उदाहरण विशेष रूप से दिखाते हैं कि कैसे access control सेट करके Touch ID authentication आवश्यक करवाया जाए और यह सुनिश्चित किया जाए कि डेटा केवल उसी डिवाइस पर उपलब्ध हो जिस पर इसे सेट किया गया था, बशर्ते कि डिवाइस passcode कॉन्फ़िगर किया गया हो।

{{#tabs}}
{{#tab name="Swift"}}
```swift
// From https://github.com/mufambisi/owasp-mstg/blob/master/Document/0x06f-Testing-Local-Authentication.md

// 1. create AccessControl object that will represent authentication settings

var error: Unmanaged<CFError>?

guard let accessControl = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
SecAccessControlCreateFlags.biometryCurrentSet,
&error) else {
// failed to create AccessControl object

return
}

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute

var query: [String: Any] = [:]

query[kSecClass as String] = kSecClassGenericPassword
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecAttrAccount as String] = "OWASP Account" as CFString
query[kSecValueData as String] = "test_strong_password".data(using: .utf8)! as CFData
query[kSecAttrAccessControl as String] = accessControl

// 3. save item

let status = SecItemAdd(query as CFDictionary, nil)

if status == noErr {
// successfully saved
} else {
// error while saving
}
```
{{#endtab}}

{{#tab name="Objective-C"}}
```objectivec
// 1. create AccessControl object that will represent authentication settings
CFErrorRef *err = nil;

SecAccessControlRef sacRef = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
kSecAccessControlUserPresence,
err);

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute
NSDictionary* query = @{
(_ _bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecAttrAccount: @"OWASP Account",
(__bridge id)kSecValueData: [@"test_strong_password" dataUsingEncoding:NSUTF8StringEncoding],
(__bridge id)kSecAttrAccessControl: (__bridge_transfer id)sacRef
};

// 3. save item
OSStatus status = SecItemAdd((__bridge CFDictionaryRef)query, nil);

if (status == noErr) {
// successfully saved
} else {
// error while saving
}
```
{{#endtab}}
{{#endtabs}}

अब हम keychain से सहेजा हुआ आइटम request कर सकते हैं। Keychain services उपयोगकर्ता को authentication dialog दिखाएँगी और उपयुक्त fingerprint दिए जाने पर data लौटाएँगी, अन्यथा nil लौटाएँगी।

{{#tabs}}
{{#tab name="Swift"}}
```swift
// 1. define query
var query = [String: Any]()
query[kSecClass as String] = kSecClassGenericPassword
query[kSecReturnData as String] = kCFBooleanTrue
query[kSecAttrAccount as String] = "My Name" as CFString
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecUseOperationPrompt as String] = "Please, pass authorisation to enter this area" as CFString

// 2. get item
var queryResult: AnyObject?
let status = withUnsafeMutablePointer(to: &queryResult) {
SecItemCopyMatching(query as CFDictionary, UnsafeMutablePointer($0))
}

if status == noErr {
let password = String(data: queryResult as! Data, encoding: .utf8)!
// successfully received password
} else {
// authorization not passed
}
```
{{#endtab}}

{{#tab name="Objective-C"}}
```objectivec
// 1. define query
NSDictionary *query = @{(__bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecReturnData: @YES,
(__bridge id)kSecAttrAccount: @"My Name1",
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecUseOperationPrompt: @"Please, pass authorisation to enter this area" };

// 2. get item
CFTypeRef queryResult = NULL;
OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)query, &queryResult);

if (status == noErr){
NSData* resultData = ( __bridge_transfer NSData* )queryResult;
NSString* password = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding];
NSLog(@"%@", password);
} else {
NSLog(@"Something went wrong");
}
```
{{#endtab}}
{{#endtabs}}

### पहचान

किसी ऐप में frameworks के उपयोग का पता ऐप बाइनरी की shared dynamic libraries की सूची का विश्लेषण करके भी लगाया जा सकता है। यह `otool` का उपयोग करके किया जा सकता है:
```bash
$ otool -L <AppName>.app/<AppName>
```
यदि किसी ऐप में `LocalAuthentication.framework` का उपयोग किया गया है, तो आउटपुट में निम्नलिखित दोनों पंक्तियाँ होंगी (ध्यान रखें कि `LocalAuthentication.framework` अंतर्निहित रूप से `Security.framework` का उपयोग करता है):
```bash
/System/Library/Frameworks/LocalAuthentication.framework/LocalAuthentication
/System/Library/Frameworks/Security.framework/Security
```
यदि `Security.framework` का उपयोग किया जाता है, तो केवल दूसरा दिखाया जाएगा।

### लोकल ऑथेंटिकेशन फ्रेमवर्क बायपास

#### **Objection**

Through the **Objection Biometrics Bypass**, located at [this GitHub page](https://github.com/sensepost/objection/wiki/Understanding-the-iOS-Biometrics-Bypass), a technique is available for overcoming the **LocalAuthentication** mechanism. इस दृष्टिकोण का मुख्य हिस्सा **Frida** का उपयोग करके `evaluatePolicy` फ़ंक्शन में हेरफेर करना है, ताकि यह वास्तविक ऑथेंटिकेशन सफलता की परवाह किए बिना लगातार `True` परिणाम दे। यह विशेष रूप से दोषपूर्ण बायोमैट्रिक ऑथेंटिकेशन प्रक्रियाओं को बायपास करने में उपयोगी है।

इस बायपास को सक्रिय करने के लिए, निम्नलिखित कमांड का उपयोग किया जाता है:
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios ui biometrics_bypass
(agent) Registering job 3mhtws9x47q. Type: ios-biometrics-disable
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # (agent) [3mhtws9x47q] Localized Reason for auth requirement: Please authenticate yourself
(agent) [3mhtws9x47q] OS authentication response: false
(agent) [3mhtws9x47q] Marking OS response as True instead
(agent) [3mhtws9x47q] Biometrics bypass hook complete
```
यह कमांड एक ऐसा अनुक्रम शुरू करता है जहाँ Objection एक टास्क रजिस्टर करता है जो प्रभावी रूप से `evaluatePolicy` चेक के परिणाम को `True` में बदल देता है।

#### Frida

यहाँ [DVIA-v2 application](https://github.com/prateek147/DVIA-v2) से **`evaluatePolicy`** के उपयोग का एक उदाहरण है:
```swift
+(void)authenticateWithTouchID {
LAContext *myContext = [[LAContext alloc] init];
NSError *authError = nil;
NSString *myLocalizedReasonString = @"Please authenticate yourself";

if ([myContext canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&authError]) {
[myContext evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics
localizedReason:myLocalizedReasonString
reply:^(BOOL success, NSError *error) {
if (success) {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Successful" withTitle:@"Success"];
});
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Failed !" withTitle:@"Error"];
});
}
}];
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Your device doesn't support Touch ID or you haven't configured Touch ID authentication on your device" withTitle:@"Error"];
});
}
}
```
Local Authentication के **bypass** को हासिल करने के लिए, एक Frida script लिखा गया है। यह script **evaluatePolicy** चेक को लक्षित करती है, और इसके callback को intercept करके सुनिश्चित करती है कि वह **success=1** लौटाए। callback के व्यवहार को बदलकर, authentication चेक को प्रभावी रूप से **bypass** किया जाता है।

नीचे दिया गया script **evaluatePolicy** method के परिणाम को बदलने के लिए inject किया जाता है। यह callback के परिणाम को हमेशा success दिखाने के लिए बदल देता है।
```swift
// from https://securitycafe.ro/2022/09/05/mobile-pentesting-101-bypassing-biometric-authentication/
if(ObjC.available) {
console.log("Injecting...");
var hook = ObjC.classes.LAContext["- evaluatePolicy:localizedReason:reply:"];
Interceptor.attach(hook.implementation, {
onEnter: function(args) {
var block = new ObjC.Block(args[4]);
const callback = block.implementation;
block.implementation = function (error, value)  {

console.log("Changing the result value to true")
const result = callback(1, null);
return result;
};
},
});
} else {
console.log("Objective-C Runtime is not available!");
}
```
Frida स्क्रिप्ट इंजेक्ट करने और बायोमेट्रिक प्रमाणीकरण को बायपास करने के लिए निम्नलिखित कमांड का उपयोग किया जाता है:
```bash
frida -U -f com.highaltitudehacks.DVIAswiftv2 --no-pause -l fingerprint-bypass-ios.js
```
## IPC के माध्यम से संवेदनशील कार्यक्षमता का एक्सपोज़र

### Custom URI Handlers / Deeplinks / Custom Schemes


{{#ref}}
ios-custom-uri-handlers-deeplinks-custom-schemes.md
{{#endref}}

### Universal Links


{{#ref}}
ios-universal-links.md
{{#endref}}

### UIActivity Sharing


{{#ref}}
ios-uiactivity-sharing.md
{{#endref}}

### UIPasteboard


{{#ref}}
ios-uipasteboard.md
{{#endref}}

### App Extensions


{{#ref}}
ios-app-extensions.md
{{#endref}}

### WebViews


{{#ref}}
ios-webviews.md
{{#endref}}

### Serialisation and Encoding


{{#ref}}
ios-serialisation-and-encoding.md
{{#endref}}

## Network Communication

यह सुनिश्चित करना महत्वपूर्ण है कि कोई संचार **encryption के बिना** न हो रहा हो और साथ ही एप्लिकेशन सर्वर के **TLS प्रमाणपत्र का सही सत्यापन** कर रहा हो।\
इन समस्याओं की जाँच करने के लिए आप **Burp** जैसे proxy का उपयोग कर सकते हैं:


{{#ref}}
burp-configuration-for-ios.md
{{#endref}}

### Hostname check

TLS प्रमाणपत्र सत्यापन में एक सामान्य समस्या यह है कि प्रमाणपत्र को एक **trusted** **CA** द्वारा साइन किया गया होना चेक किया जा सकता है, परंतु **यह नहीं चेक किया जाता** कि प्रमाणपत्र का **hostname** वही है जो एक्सेस किया जा रहा है।\
इस समस्या की जाँच करने के लिए Burp का उपयोग करते समय, iPhone में Burp CA पर भरोसा करने के बाद, आप **Burp के साथ किसी अलग hostname के लिए नया प्रमाणपत्र बना** कर उसे उपयोग कर सकते हैं। यदि एप्लिकेशन फिर भी काम करता है, तो यह कमजोर है।

### Certificate Pinning

यदि कोई एप्लिकेशन सही तरीके से **SSL Pinning** उपयोग कर रहा है, तो एप्लिकेशन केवल तभी काम करेगा जब प्रमाणपत्र वही हो जिसकी उम्मीद है। टेस्ट करते समय यह समस्या हो सकती है क्योंकि Burp अपना प्रमाणपत्र सर्व करेगा.\
इस संरक्षण को jailbroken डिवाइस के अंदर bypass करने के लिए, आप एप्लिकेशन [**SSL Kill Switch**](https://github.com/nabla-c0d3/ssl-kill-switch2) इंस्टॉल कर सकते हैं या [**Burp Mobile Assistant**](https://portswigger.net/burp/documentation/desktop/mobile/config-ios-device) इंस्टॉल कर सकते हैं।

आप **objection's** `ios sslpinning disable` का भी उपयोग कर सकते हैं

## Misc

- In **`/System/Library`** you can find the frameworks installed in the phone used by system applications
- The applications installed by the user from the App Store are located inside **`/User/Applications`**
- And the **`/User/Library`** contains data saved by the user level applications
- You can access **`/User/Library/Notes/notes.sqlite`** to read the notes saved inside the application.
- Inside the folder of an installed application (**`/User/Applications/<APP ID>/`**) you can find some interesting files:
- **`iTunesArtwork`**: The icon used by the app
- **`iTunesMetadata.plist`**: Info of the app used in the App Store
- **`/Library/*`**: Contains the preferences and cache. In **`/Library/Cache/Snapshots/*`** you can find the snapshot performed to the application before sending it to the background.

### Hot Patching/Enforced Updateing

डेवलपर अपने एप का कोई भी संस्करण App Store में फिर से सबमिट किए बिना रिमोटली **तुरंत patch** कर सकते हैं।\
इस उद्देश्य के लिए सामान्यतः [**JSPatch**](https://github.com/bang590/JSPatch)** का उपयोग किया जाता है।** पर अन्य विकल्प भी हैं, जैसे [Siren](https://github.com/ArtSabintsev/Siren) और [react-native-appstore-version-checker](https://www.npmjs.com/package/react-native-appstore-version-checker)।\
**यह एक खतरनाक मेकैनिज्म है जिसे malicious third party SDKs द्वारा गलत उपयोग किया जा सकता है, इसलिए सिफारिश की जाती है कि देखें कौन सा method automatic updating के लिए उपयोग किया जा रहा है (यदि कोई हो) और उसे टेस्ट करें।** इस उद्देश्य के लिए आप एप का पिछला वर्शन डाउनलोड कर के परीक्षण कर सकते हैं।

### Third Parties

**3rd party SDKs** के साथ एक बड़ा चुनौती उनकी functionalities पर **सूक्ष्म नियंत्रण का अभाव** है। डेवलपर के सामने विकल्प होता है: या तो SDK integrate करें और उसकी सभी सुविधाओं को स्वीकार करें — जिनमें संभावित security vulnerabilities और privacy concerns शामिल हैं — या उसके लाभों को पूरी तरह छोड़ दें। अक्सर डेवलपर स्वयं उन SDKs में vulnerabilities patch नहीं कर पाते। इसके अलावा, जैसे-जैसे SDKs समुदाय में भरोसा हासिल करते हैं, कुछ SDKs में malware भी शामिल हो सकता है।

तीसरे पक्ष द्वारा प्रदान की जाने वाली सेवाओं में user behavior tracking, advertisement display, या user experience enhancements शामिल हो सकते हैं। हालांकि, इससे जोखिम जुड़ा होता है क्योंकि डेवलपर उन libraries द्वारा चलाए जा रहे कोड से पूरी तरह अवगत नहीं हो सकते, जिससे privacy और security जोखिम उत्पन्न हो सकते हैं। यह महत्वपूर्ण है कि third-party सेवाओं के साथ साझा की जा रही जानकारी को केवल आवश्यक तक सीमित रखा जाए और यह सुनिश्चित किया जाए कि कोई संवेदनशील डेटा एक्सपोज़ न हो।

third-party services का निर्माण आमतौर पर दो रूपों में होता है: standalone library या full SDK। उपयोगकर्ता की privacy की रक्षा के लिए, इन सेवाओं के साथ साझा किया गया कोई भी डेटा **anonymized** होना चाहिए ताकि Personal Identifiable Information (PII) का खुलासा न हो।

किसी एप के उपयोग करने वाली libraries की पहचान करने के लिए, **`otool`** कमांड का उपयोग किया जा सकता है। यह टूल एप्लिकेशन और प्रत्येक shared library के खिलाफ चलाया जाना चाहिए ताकि अतिरिक्त libraries का पता चल सके।
```bash
otool -L <application_path>
```
## दिलचस्प Vulnerabilities और Case Studies


{{#ref}}
air-keyboard-remote-input-injection.md
{{#endref}}

{{#ref}}
itunesstored-bookassetd-sandbox-escape.md
{{#endref}}

## **संदर्भ और अधिक संसाधन**

- [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering)
- [iOS और Mobile App Pentesting - INE](https://my.ine.com/CyberSecurity/courses/089d060b/ios-mobile-app-pentesting)
- [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/)
- [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/)
- [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/)
- [https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage](https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage)
- [https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way](https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053)
- [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060)
- [https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/](https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064](https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064)
- [https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc](https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054)
- [https://github.com/ivRodriguezCA/RE-iOS-Apps/](https://github.com/ivRodriguezCA/RE-iOS-Apps/) iOS मुफ्त कोर्स([https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/](https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/))
- [https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577](https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577)
- [https://www.slideshare.net/RyanISI/ios-appsecurityminicourse](https://www.slideshare.net/RyanISI/ios-appsecurityminicourse)
- [https://github.com/prateek147/DVIA](https://github.com/prateek147/DVIA)
- [https://github.com/prateek147/DVIA-v2](https://github.com/prateek147/DVIA-v2)
- [https://github.com/OWASP/MSTG-Hacking-Playground%20](https://github.com/OWASP/MSTG-Hacking-Playground)
- OWASP iGoat [_https://github.com/OWASP/igoat_](https://github.com/OWASP/igoat) <<< Objective-C संस्करण [_https://github.com/OWASP/iGoat-Swift_](https://github.com/OWASP/iGoat-Swift) <<< Swift संस्करण
- [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
- [https://github.com/nabla-c0d3/ssl-kill-switch2](https://github.com/nabla-c0d3/ssl-kill-switch2)


{{#include ../../banners/hacktricks-training.md}}
