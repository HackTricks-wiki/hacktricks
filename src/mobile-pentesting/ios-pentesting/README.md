# iOS Pentesting

{{#include ../../banners/hacktricks-training.md}}

## iOS Temelleri

{{#ref}}
ios-basics.md
{{#endref}}

## Test Ortamı

Bu sayfada **iOS simülatörü**, **emülatörler** ve **jailbreaking** hakkında bilgi bulabilirsiniz:

{{#ref}}
ios-testing-environment.md
{{#endref}}

## İlk Analiz

### Temel iOS Test İşlemleri

Test sırasında **birçok işlem önerilecektir** (cihaza bağlanma, dosyaları okuma/yazma/yükleme/indirme, bazı araçları kullanma...). Bu nedenle, bu eylemlerden herhangi birini nasıl gerçekleştireceğinizi bilmiyorsanız, lütfen **sayfayı okumaya başlayın**:

{{#ref}}
basic-ios-testing-operations.md
{{#endref}}

> [!NOTE]
> Aşağıdaki adımlar için **uygulama cihazda yüklü olmalıdır** ve uygulamanın **IPA dosyası** zaten alınmış olmalıdır.\
> Bunu nasıl yapacağınızı öğrenmek için [Basic iOS Testing Operations](basic-ios-testing-operations.md) sayfasını okuyun.

### Temel Statik Analiz

Bazı ilginç iOS - IPA dosyası decompiler'ları:

- https://github.com/LaurieWired/Malimite
- https://ghidra-sre.org/

IPA dosyasına otomatik Statik Analiz yapmak için [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) aracını kullanmanız önerilir.

**İkili dosyada mevcut olan korumaların tanımlanması**:

- **PIE (Position Independent Executable)**: Etkinleştirildiğinde, uygulama her başlatıldığında rastgele bir bellek adresine yüklenir, bu da başlangıç bellek adresini tahmin etmeyi zorlaştırır.

```bash
otool -hv <app-binary> | grep PIE   # PIE bayrağını içermelidir
```

- **Stack Canaries**: Yığın bütünlüğünü doğrulamak için, bir işlev çağrılmadan önce yığının üzerine bir ‘canary’ değeri yerleştirilir ve işlev sona erdiğinde tekrar doğrulanır.

```bash
otool -I -v <app-binary> | grep stack_chk   # stack_chk_guard ve stack_chk_fail sembollerini içermelidir
```

- **ARC (Automatic Reference Counting)**: Yaygın bellek bozulma hatalarını önlemek için

```bash
otool -I -v <app-binary> | grep objc_release   # _objc_release sembolünü içermelidir
```

- **Şifreli İkili**: İkili dosya şifrelenmiş olmalıdır

```bash
otool -arch all -Vl <app-binary> | grep -A5 LC_ENCRYPT   # cryptid 1 olmalıdır
```

**Hassas/Güvensiz Fonksiyonların Tanımlanması**

- **Zayıf Hashing Algoritmaları**

```bash
# iOS cihazında
otool -Iv <app> | grep -w "_CC_MD5"
otool -Iv <app> | grep -w "_CC_SHA1"

# Linux'ta
grep -iER "_CC_MD5"
grep -iER "_CC_SHA1"
```

- **Güvensiz Rastgele Fonksiyonlar**

```bash
# iOS cihazında
otool -Iv <app> | grep -w "_random"
otool -Iv <app> | grep -w "_srand"
otool -Iv <app> | grep -w "_rand"

# Linux'ta
grep -iER "_random"
grep -iER "_srand"
grep -iER "_rand"
```

- **Güvensiz ‘Malloc’ Fonksiyonu**

```bash
# iOS cihazında
otool -Iv <app> | grep -w "_malloc"

# Linux'ta
grep -iER "_malloc"
```

- **Güvensiz ve Açık Fonksiyonlar**

```bash
# iOS cihazında
otool -Iv <app> | grep -w "_gets"
otool -Iv <app> | grep -w "_memcpy"
otool -Iv <app> | grep -w "_strncpy"
otool -Iv <app> | grep -w "_strlen"
otool -Iv <app> | grep -w "_vsnprintf"
otool -Iv <app> | grep -w "_sscanf"
otool -Iv <app> | grep -w "_strtok"
otool -Iv <app> | grep -w "_alloca"
otool -Iv <app> | grep -w "_sprintf"
otool -Iv <app> | grep -w "_printf"
otool -Iv <app> | grep -w "_vsprintf"

# Linux'ta
grep -R "_gets"
grep -iER "_memcpy"
grep -iER "_strncpy"
grep -iER "_strlen"
grep -iER "_vsnprintf"
grep -iER "_sscanf"
grep -iER "_strtok"
grep -iER "_alloca"
grep -iER "_sprintf"
grep -iER "_printf"
grep -iER "_vsprintf"
```

### Temel Dinamik Analiz

[**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) tarafından gerçekleştirilen dinamik analizi kontrol edin. Farklı görünümler arasında gezinmeniz ve onlarla etkileşimde bulunmanız gerekecek, ancak diğer şeyleri yaparken birkaç sınıfı hooklayacak ve işiniz bittiğinde bir rapor hazırlayacaktır.

### Yüklenen Uygulamaların Listelenmesi

Yüklenen uygulamaların **bundle identifier**'ını belirlemek için `frida-ps -Uai` komutunu kullanın:
```bash
$ frida-ps -Uai
PID  Name                 Identifier
----  -------------------  -----------------------------------------
6847  Calendar             com.apple.mobilecal
6815  Mail                 com.apple.mobilemail
-  App Store            com.apple.AppStore
-  Apple Store          com.apple.store.Jolly
-  Calculator           com.apple.calculator
-  Camera               com.apple.camera
-  iGoat-Swift          OWASP.iGoat-Swift
```
### Temel Sayım & Hooking

Uygulamanın **bileşenlerini saymayı** ve **objection ile yöntemleri ve sınıfları kolayca hook etmeyi** öğrenin:

{{#ref}}
ios-hooking-with-objection.md
{{#endref}}

### IPA Yapısı

Bir **IPA dosyasının** yapısı esasen bir **ziplenmiş paket** yapısıdır. Uzantısını `.zip` olarak değiştirerek, içeriğini **açabilirsiniz**. Bu yapı içinde, bir **Bundle**, kurulum için hazır tamamen paketlenmiş bir uygulamayı temsil eder. İçinde, uygulamanın kaynaklarını kapsayan `<NAME>.app` adında bir dizin bulacaksınız.

- **`Info.plist`**: Bu dosya, uygulamanın belirli yapılandırma ayrıntılarını tutar.
- **`_CodeSignature/`**: Bu dizin, bundle içindeki tüm dosyaların bütünlüğünü sağlamak için bir imza içeren bir plist dosyası içerir.
- **`Assets.car`**: İkonlar gibi varlık dosyalarını depolayan sıkıştırılmış bir arşivdir.
- **`Frameworks/`**: Bu klasör, `.dylib` veya `.framework` dosyaları şeklinde olabilen uygulamanın yerel kütüphanelerini barındırır.
- **`PlugIns/`**: Bu, uygulamaya eklemeler içerebilir, bunlar `.appex` dosyaları olarak bilinir, ancak her zaman mevcut olmayabilir. \* [**`Core Data`**](https://developer.apple.com/documentation/coredata): Uygulamanızın kalıcı verilerini çevrimdışı kullanım için kaydetmek, geçici verileri önbelleğe almak ve uygulamanıza tek bir cihazda geri alma işlevselliği eklemek için kullanılır. Birden fazla cihazda verileri senkronize etmek için Core Data, şemanızı otomatik olarak bir CloudKit konteynerine yansıtır.
- [**`PkgInfo`**](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigApplications.html): `PkgInfo` dosyası, uygulamanızın veya bundle'ınızın türünü ve yaratıcısını belirtmenin alternatif bir yoludur.
- **en.lproj, fr.proj, Base.lproj**: Bu, belirli diller için kaynakları içeren dil paketleridir ve bir dil desteklenmediğinde varsayılan bir kaynak içerir.
- **Güvenlik**: `_CodeSignature/` dizini, dijital imzalar aracılığıyla tüm paketlenmiş dosyaların bütünlüğünü doğrulayarak uygulamanın güvenliğinde kritik bir rol oynar.
- **Varlık Yönetimi**: `Assets.car` dosyası, grafik varlıkları verimli bir şekilde yönetmek için sıkıştırma kullanır, bu da uygulama performansını optimize etmek ve genel boyutunu azaltmak için önemlidir.
- **Frameworks ve PlugIns**: Bu dizinler, iOS uygulamalarının modülerliğini vurgular, geliştiricilerin yeniden kullanılabilir kod kütüphanelerini (`Frameworks/`) dahil etmelerine ve uygulama işlevselliğini genişletmelerine olanak tanır.
- **Yerelleştirme**: Yapı, belirli dil paketleri için kaynaklar ekleyerek küresel uygulama erişimini kolaylaştıran birden fazla dili destekler.

**Info.plist**

**Info.plist**, iOS uygulamaları için bir köşe taşı olarak hizmet eder ve **anahtar-değer** çiftleri biçiminde ana yapılandırma verilerini kapsar. Bu dosya, yalnızca uygulamalar için değil, aynı zamanda içinde paketlenmiş uygulama uzantıları ve frameworkler için de gereklidir. XML veya ikili formatta yapılandırılmıştır ve uygulama izinlerinden güvenlik yapılandırmalarına kadar kritik bilgileri tutar. Mevcut anahtarların detaylı bir keşfi için [**Apple Developer Documentation**](https://developer.apple.com/documentation/bundleresources/information_property_list?language=objc) adresine başvurabilirsiniz.

Bu dosyayla daha erişilebilir bir formatta çalışmak isteyenler için, XML dönüşümü macOS'ta (10.2 ve sonraki sürümlerde yerel olarak mevcut) `plutil` kullanılarak veya Linux'ta `plistutil` ile zahmetsizce gerçekleştirilebilir. Dönüşüm için komutlar aşağıdaki gibidir:

- **macOS için**:
```bash
$ plutil -convert xml1 Info.plist
```
- **Linux için**:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
**Info.plist** dosyasının ortaya çıkarabileceği çok sayıda bilgi arasında, dikkat çekici girdiler arasında uygulama izin dizeleri (`UsageDescription`), özel URL şemaları (`CFBundleURLTypes`) ve Uygulama Taşıma Güvenliği için yapılandırmalar (`NSAppTransportSecurity`) bulunmaktadır. Bu girdiler, dışa aktarılan/içe aktarılan özel belge türleri (`UTExportedTypeDeclarations` / `UTImportedTypeDeclarations`) gibi diğerleriyle birlikte, dosyayı inceleyerek veya basit bir `grep` komutu kullanarak kolayca bulunabilir:
```bash
$ grep -i <keyword> Info.plist
```
**Veri Yolları**

iOS ortamında, dizinler **sistem uygulamaları** ve **kullanıcı tarafından yüklenen uygulamalar** için özel olarak belirlenmiştir. Sistem uygulamaları `/Applications` dizininde bulunurken, kullanıcı tarafından yüklenen uygulamalar `/var/mobile/containers/Data/Application/` altında yer alır. Bu uygulamalar, dizin adlarının rastgeleliği nedeniyle bir uygulamanın klasörünü manuel olarak bulmayı zorlaştıran **128-bit UUID** olarak bilinen benzersiz bir tanımlayıcıya atanır.

> [!WARNING]
> iOS'taki uygulamalar sandbox'lanmış olmalıdır, bu nedenle her uygulamanın **`$HOME/Library/Containers`** içinde uygulamanın **`CFBundleIdentifier`** olarak adlandırılan bir klasörü olacaktır.
>
> Ancak, her iki klasör (veri ve konteyner klasörleri) de **`.com.apple.mobile_container_manager.metadata.plist`** dosyasına sahiptir ve bu dosya, `MCMetadataIdentifier` anahtarında her iki dosyayı bağlar.

Kullanıcı tarafından yüklenen bir uygulamanın kurulum dizinini keşfetmeyi kolaylaştırmak için, **objection aracı** faydalı bir komut olan `env` sağlar. Bu komut, söz konusu uygulama için ayrıntılı dizin bilgilerini ortaya çıkarır. Aşağıda bu komutun nasıl kullanılacağına dair bir örnek bulunmaktadır:
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # env

Name               Path
-----------------  -------------------------------------------------------------------------------------------
BundlePath         /var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app
CachesDirectory    /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library/Caches
DocumentDirectory  /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Documents
LibraryDirectory   /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library
```
Alternatif olarak, uygulama adı `/private/var/containers` içinde `find` komutunu kullanarak aranabilir:
```bash
find /private/var/containers -name "Progname*"
```
`ps` ve `lsof` gibi komutlar, uygulamanın işlemini tanımlamak ve sırasıyla açık dosyaları listelemek için de kullanılabilir, bu da uygulamanın aktif dizin yolları hakkında bilgiler sağlar:
```bash
ps -ef | grep -i <app-name>
lsof -p <pid> | grep -i "/containers" | head -n 1
```
**Bundle dizini:**

- **AppName.app**
- Bu, IPA'da daha önce görülen Uygulama Paketi olup, temel uygulama verilerini, statik içeriği ve uygulamanın derlenmiş ikili dosyasını içerir.
- Bu dizin kullanıcılara görünür, ancak **kullanıcılar buna yazamaz**.
- Bu dizindeki içerik **yedeklenmez**.
- Bu klasörün içeriği **kod imzasını doğrulamak** için kullanılır.

**Veri dizini:**

- **Documents/**
- Kullanıcı tarafından oluşturulan tüm verileri içerir. Uygulama son kullanıcısı bu verilerin oluşturulmasını başlatır.
- Kullanıcılara görünür ve **kullanıcılar buna yazabilir**.
- Bu dizindeki içerik **yedeklenir**.
- Uygulama, `NSURLIsExcludedFromBackupKey` ayarını yaparak yolları devre dışı bırakabilir.
- **Library/**
- **Kullanıcıya özel olmayan** tüm **dosyaları** içerir, örneğin **önbellekler**, **tercihler**, **çerezler** ve özellik listesi (plist) yapılandırma dosyaları.
- iOS uygulamaları genellikle `Application Support` ve `Caches` alt dizinlerini kullanır, ancak uygulama özel alt dizinler oluşturabilir.
- **Library/Caches/**
- **Yarı kalıcı önbellek dosyalarını** içerir.
- Kullanıcılara görünmez ve **kullanıcılar buna yazamaz**.
- Bu dizindeki içerik **yedeklenmez**.
- OS, uygulama çalışmadığında ve depolama alanı azaldığında bu dizinin dosyalarını otomatik olarak silebilir.
- **Library/Application Support/**
- Uygulamanın çalışması için gerekli **kalıcı** **dosyaları** içerir.
- **Kullanıcılara görünmez** ve kullanıcılar buna yazamaz.
- Bu dizindeki içerik **yedeklenir**.
- Uygulama, `NSURLIsExcludedFromBackupKey` ayarını yaparak yolları devre dışı bırakabilir.
- **Library/Preferences/**
- Uygulama yeniden başlatılsa bile **kalıcı** olabilen özellikleri saklamak için kullanılır.
- Bilgiler, şifrelenmemiş olarak, uygulama kumanda alanında \[BUNDLE_ID].plist adlı bir plist dosyasında saklanır.
- `NSUserDefaults` kullanılarak saklanan tüm anahtar/değer çiftleri bu dosyada bulunabilir.
- **tmp/**
- Uygulama başlatmaları arasında kalıcı olması gerekmeyen **geçici dosyalar** yazmak için bu dizini kullanın.
- Kalıcı olmayan önbellek dosyalarını içerir.
- Kullanıcılara **görünmez**.
- Bu dizindeki içerik yedeklenmez.
- OS, uygulama çalışmadığında ve depolama alanı azaldığında bu dizinin dosyalarını otomatik olarak silebilir.

iGoat-Swift'in Uygulama Paketi (.app) dizinine daha yakından bakalım (`/var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app`):
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # ls
NSFileType      Perms  NSFileProtection    ...  Name
------------  -------  ------------------  ...  --------------------------------------
Regular           420  None                ...  rutger.html
Regular           420  None                ...  mansi.html
Regular           420  None                ...  splash.html
Regular           420  None                ...  about.html

Regular           420  None                ...  LICENSE.txt
Regular           420  None                ...  Sentinel.txt
Regular           420  None                ...  README.txt
```
### İkili Tersine Mühendislik

`<application-name>.app` klasörünün içinde `<application-name>` adında bir ikili dosya bulacaksınız. Bu, **çalıştırılacak** dosyadır. İkili dosyanın temel bir incelemesini **`otool`** aracıyla yapabilirsiniz:
```bash
otool -Vh DVIA-v2 #Check some compilation attributes
magic  cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64    ARM64        ALL  0x00     EXECUTE    65       7112   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE

otool -L DVIA-v2 #Get third party libraries
DVIA-v2:
/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.1)
/usr/lib/libsqlite3.dylib (compatibility version 9.0.0, current version 274.6.0)
/usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11)
@rpath/Bolts.framework/Bolts (compatibility version 1.0.0, current version 1.0.0)
[...]
```
**Uygulamanın şifrelenip şifrelenmediğini kontrol et**

Şu çıktının olup olmadığını kontrol edin:
```bash
otool -l <app-binary> | grep -A 4 LC_ENCRYPTION_INFO
```
**İkiliyi Ayrıştırma**

Metin bölümünü ayrıştırın:
```bash
otool -tV DVIA-v2
DVIA-v2:
(__TEXT,__text) section
+[DDLog initialize]:
0000000100004ab8    sub    sp, sp, #0x60
0000000100004abc    stp    x29, x30, [sp, #0x50]   ; Latency: 6
0000000100004ac0    add    x29, sp, #0x50
0000000100004ac4    sub    x8, x29, #0x10
0000000100004ac8    mov    x9, #0x0
0000000100004acc    adrp    x10, 1098 ; 0x10044e000
0000000100004ad0    add    x10, x10, #0x268
```
Örnek uygulamanın **Objective-C segmentini** yazdırmak için şunları kullanabilirsiniz:
```bash
otool -oV DVIA-v2
DVIA-v2:
Contents of (__DATA,__objc_classlist) section
00000001003dd5b8 0x1004423d0 _OBJC_CLASS_$_DDLog
isa        0x1004423a8 _OBJC_METACLASS_$_DDLog
superclass 0x0 _OBJC_CLASS_$_NSObject
cache      0x0 __objc_empty_cache
vtable     0x0
data       0x1003de748
flags          0x80
instanceStart  8
```
Daha kompakt bir Objective-C kodu elde etmek için [**class-dump**](http://stevenygard.com/projects/class-dump/) kullanabilirsiniz:
```bash
class-dump some-app
//
//     Generated by class-dump 3.5 (64 bit).
//
//     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2013 by Steve Nygard.
//

#pragma mark Named Structures

struct CGPoint {
double _field1;
double _field2;
};

struct CGRect {
struct CGPoint _field1;
struct CGSize _field2;
};

struct CGSize {
double _field1;
double _field2;
};
```
Ancak, ikili dosyayı parçalamak için en iyi seçenekler: [**Hopper**](https://www.hopperapp.com/download.html?) ve [**IDA**](https://www.hex-rays.com/products/ida/support/download_freeware/).

## Veri Depolama

iOS'un cihazda verileri nasıl depoladığını öğrenmek için bu sayfayı okuyun:

{{#ref}}
ios-basics.md
{{#endref}}

> [!WARNING]
> Bilgileri depolamak için aşağıdaki yerler **uygulama yüklendikten hemen sonra**, **uygulamanın tüm işlevleri kontrol edildikten sonra** ve hatta **bir kullanıcıdan çıkış yapıldıktan ve farklı bir kullanıcıya giriş yapıldıktan sonra** kontrol edilmelidir.\
> Amaç, uygulamanın (şifreler, tokenlar), mevcut kullanıcının ve daha önce giriş yapmış kullanıcıların **korumasız hassas bilgilerini** bulmaktır.

### Plist

**plist** dosyaları, **anahtar-değer çiftleri** içeren yapılandırılmış XML dosyalarıdır. Kalıcı verileri depolamanın bir yoludur, bu nedenle bazen bu dosyalarda **hassas bilgiler bulabilirsiniz**. Uygulamayı yükledikten sonra ve yoğun bir şekilde kullandıktan sonra bu dosyaları kontrol etmeniz önerilir.

plist dosyalarında verileri kalıcı hale getirmenin en yaygın yolu **NSUserDefaults** kullanmaktır. Bu plist dosyası, uygulama kumandasının içinde **`Library/Preferences/<appBundleID>.plist`** konumunda kaydedilir.

[`NSUserDefaults`](https://developer.apple.com/documentation/foundation/nsuserdefaults) sınıfı, varsayılan sistemle etkileşim kurmak için programatik bir arayüz sağlar. Varsayılan sistem, bir uygulamanın **kullanıcı tercihleri** doğrultusunda davranışını özelleştirmesine olanak tanır. `NSUserDefaults` ile kaydedilen veriler uygulama paketinde görüntülenebilir. Bu sınıf, **plist** **dosyasında** **veri** depolar, ancak küçük miktarlardaki verilerle kullanılmak üzere tasarlanmıştır.

Bu verilere artık güvenilir bir bilgisayar aracılığıyla doğrudan erişilemez, ancak bir **yedekleme** yaparak erişilebilir.

**`NSUserDefaults`** kullanarak kaydedilen bilgileri **dump** edebilirsiniz, objection'ın `ios nsuserdefaults get` komutunu kullanarak.

Uygulama tarafından kullanılan tüm plist dosyalarını bulmak için `/private/var/mobile/Containers/Data/Application/{APPID}` konumuna erişebilir ve çalıştırabilirsiniz:
```bash
find ./ -name "*.plist"
```
**XML veya ikili (bplist) formatındaki dosyaları XML'ye dönüştürmek için, işletim sisteminize bağlı olarak çeşitli yöntemler mevcuttur:**

**macOS Kullanıcıları için:** `plutil` komutunu kullanın. Bu, macOS'ta (10.2+) bu amaç için tasarlanmış yerleşik bir araçtır:
```bash
$ plutil -convert xml1 Info.plist
```
**Linux Kullanıcıları için:** Öncelikle `libplist-utils`'ı kurun, ardından dosyanızı dönüştürmek için `plistutil` kullanın:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
**Objection Oturumu İçinde:** Mobil uygulamaları analiz etmek için, plist dosyalarını doğrudan dönüştürmenizi sağlayan özel bir komut vardır:
```bash
ios plist cat /private/var/mobile/Containers/Data/Application/<Application-UUID>/Library/Preferences/com.some.package.app.plist
```
### Core Data

[`Core Data`](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/nsfetchedresultscontroller.html#//apple_ref/doc/uid/TP40001075-CH8-SW1), uygulamanızdaki nesnelerin model katmanını yönetmek için bir çerçevedir. [Core Data, kalıcı depolama olarak SQLite kullanabilir](https://cocoacasts.com/what-is-the-difference-between-core-data-and-sqlite/), ancak çerçeve kendisi bir veritabanı değildir.\
CoreData varsayılan olarak verilerini şifrelemez. Ancak, CoreData'ya ek bir şifreleme katmanı eklenebilir. Daha fazla ayrıntı için [GitHub Repo](https://github.com/project-imas/encrypted-core-data) adresine bakın.

Bir uygulamanın SQLite Core Data bilgilerini `/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support` yolunda bulabilirsiniz.

**SQLite'i açabilir ve hassas bilgilere erişebilirseniz, o zaman bir yanlış yapılandırma bulmuşsunuz demektir.**
```objectivec:Code from iGoat
-(void)storeDetails {
AppDelegate * appDelegate = (AppDelegate *)(UIApplication.sharedApplication.delegate);

NSManagedObjectContext *context =[appDelegate managedObjectContext];

User *user = [self fetchUser];
if (user) {
return;
}
user = [NSEntityDescription insertNewObjectForEntityForName:@"User"
inManagedObjectContext:context];
user.email = CoreDataEmail;
user.password = CoreDataPassword;
NSError *error;
if (![context save:&error]) {
NSLog(@"Error in saving data: %@", [error localizedDescription]);

}else{
NSLog(@"data stored in core data");
}
}
```
### YapDatabase

[YapDatabase](https://github.com/yapstudios/YapDatabase) SQLite üzerine inşa edilmiş bir anahtar/değer deposudur.\
Yap veritabanları sqlite veritabanları olduğundan, önceki bölümde önerilen komutu kullanarak bunları bulabilirsiniz.

### Diğer SQLite Veritabanları

Uygulamaların kendi sqlite veritabanlarını oluşturması yaygındır. Bu veritabanlarında **duyarlı** **veri** **saklıyor** olabilirler ve bunu şifrelemeden bırakabilirler. Bu nedenle, uygulama dizinindeki her veritabanını kontrol etmek her zaman ilginçtir. Bu nedenle, verilerin kaydedildiği uygulama dizinine gidin (`/private/var/mobile/Containers/Data/Application/{APPID}`)
```bash
find ./ -name "*.sqlite" -or -name "*.db"
```
### Firebase Gerçek Zamanlı Veritabanları

Geliştiriciler, Firebase Gerçek Zamanlı Veritabanları aracılığıyla **veri depolayıp senkronize etme** yeteneğine sahiptir. JSON formatında depolanan veriler, gerçek zamanlı olarak tüm bağlı istemcilere senkronize edilir.

Yanlış yapılandırılmış Firebase veritabanlarını kontrol etmenin yolunu burada bulabilirsiniz:

{{#ref}}
../../network-services-pentesting/pentesting-web/buckets/firebase-database.md
{{#endref}}

### Realm veritabanları

[Realm Objective-C](https://realm.io/docs/objc/latest/) ve [Realm Swift](https://realm.io/docs/swift/latest/) Apple tarafından sağlanmayan veri depolama için güçlü bir alternatif sunar. Varsayılan olarak, **verileri şifrelenmemiş olarak depolar**, belirli bir yapılandırma ile şifreleme mevcuttur.

Veritabanları şurada bulunmaktadır: `/private/var/mobile/Containers/Data/Application/{APPID}`. Bu dosyaları keşfetmek için, şu gibi komutlar kullanılabilir:
```bash
iPhone:/private/var/mobile/Containers/Data/Application/A079DF84-726C-4AEA-A194-805B97B3684A/Documents root# ls
default.realm  default.realm.lock  default.realm.management/  default.realm.note|

$ find ./ -name "*.realm*"
```
Bu veritabanı dosyalarını görüntülemek için [**Realm Studio**](https://github.com/realm/realm-studio) aracının kullanılması önerilir.

Bir Realm veritabanında şifreleme uygulamak için aşağıdaki kod parçası kullanılabilir:
```swift
// Open the encrypted Realm file where getKey() is a method to obtain a key from the Keychain or a server
let config = Realm.Configuration(encryptionKey: getKey())
do {
let realm = try Realm(configuration: config)
// Use the Realm as normal
} catch let error as NSError {
// If the encryption key is wrong, `error` will say that it's an invalid database
fatalError("Error opening realm: \(error)")
}
```
### Couchbase Lite Veritabanları

[Couchbase Lite](https://github.com/couchbase/couchbase-lite-ios), **hafif** ve **gömülü** bir veritabanı motoru olarak tanımlanır ve **belge odaklı** (NoSQL) yaklaşımı takip eder. **iOS** ve **macOS** için yerel olacak şekilde tasarlanmış olup, verileri sorunsuz bir şekilde senkronize etme yeteneği sunar.

Bir cihazda potansiyel Couchbase veritabanlarını tanımlamak için aşağıdaki dizin incelenmelidir:
```bash
ls /private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support/
```
### Çerezler

iOS, uygulamaların çerezlerini her uygulama klasöründeki **`Library/Cookies/cookies.binarycookies`** içinde saklar. Ancak, geliştiriciler bazen bunları **anahtar zincirinde** saklamayı tercih ederler çünkü bahsedilen **çerez dosyası yedeklerde erişilebilir**.

Çerez dosyasını incelemek için [**bu python betiğini**](https://github.com/mdegrazia/Safari-Binary-Cookie-Parser) kullanabilir veya objection'ın **`ios cookies get`** komutunu kullanabilirsiniz.\
**Bu dosyaları JSON formatına** dönüştürmek ve verileri incelemek için objection'ı da kullanabilirsiniz.
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios cookies get --json
[
{
"domain": "highaltitudehacks.com",
"expiresDate": "2051-09-15 07:46:43 +0000",
"isHTTPOnly": "false",
"isSecure": "false",
"name": "username",
"path": "/",
"value": "admin123",
"version": "0"
}
]
```
### Cache

Varsayılan olarak NSURLSession, **HTTP istekleri ve yanıtları Cache.db** veritabanında depolar. Bu veritabanı, tokenlar, kullanıcı adları veya başka herhangi bir hassas bilgi önbelleğe alındıysa **hassas veriler** içerebilir. Önbelleğe alınmış bilgileri bulmak için uygulamanın veri dizinini açın (`/var/mobile/Containers/Data/Application/<UUID>`) ve `/Library/Caches/<Bundle Identifier>` dizinine gidin. **WebKit önbelleği de Cache.db** dosyasında depolanmaktadır. **Objection**, `sqlite connect Cache.db` komutuyla veritabanını açabilir ve etkileşimde bulunabilir, çünkü bu n**ormal bir SQLite veritabanıdır**.

Bu verilerin önbelleğe alınmasını **devre dışı bırakmanız önerilir**, çünkü istek veya yanıtta hassas bilgiler içerebilir. Aşağıdaki liste, bunu başarmanın farklı yollarını göstermektedir:

1.  Çıkış yaptıktan sonra Önbelleğe alınmış yanıtların kaldırılması önerilir. Bu, Apple tarafından sağlanan [`removeAllCachedResponses`](https://developer.apple.com/documentation/foundation/urlcache/1417802-removeallcachedresponses) yöntemi ile yapılabilir. Bu yöntemi aşağıdaki gibi çağırabilirsiniz:

`URLCache.shared.removeAllCachedResponses()`

Bu yöntem, Cache.db dosyasından tüm önbelleğe alınmış istekleri ve yanıtları kaldıracaktır.

2.  Çerezlerin avantajını kullanmanıza gerek yoksa, URLSession'ın [.ephemeral](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral) yapılandırma özelliğini kullanmanız önerilir; bu, çerezlerin ve önbelleklerin kaydedilmesini devre dışı bırakır.

[Apple belgeleri](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral):

`Geçici bir oturum yapılandırma nesnesi, varsayılan bir oturum yapılandırmasına (bkz. varsayılan) benzer, ancak ilgili oturum nesnesi önbellekleri, kimlik bilgisi depolarını veya herhangi bir oturumla ilgili veriyi diske kaydetmez. Bunun yerine, oturumla ilgili veriler RAM'de depolanır. Geçici bir oturumun diske veri yazdığı tek zaman, bir URL'nin içeriğini bir dosyaya yazmasını söylediğiniz zamandır.`

3.  Önbellek, Önbellek Politikasını [.notAllowed](https://developer.apple.com/documentation/foundation/urlcache/storagepolicy/notallowed) olarak ayarlayarak da devre dışı bırakılabilir. Bu, önbelleği herhangi bir şekilde, ister bellek ister disk üzerinde depolamayı devre dışı bırakır.

### Snapshots

Ana düğmeye her bastığınızda, iOS **mevcut ekranın bir anlık görüntüsünü alır** ve uygulamaya geçişi çok daha akıcı bir şekilde yapabilmek için. Ancak, eğer mevcut ekranda **hassas** **veri** varsa, bu **görüntüde** **kaydedilir** (bu **yeniden başlatmalarda** **sürdürülür**). Bunlar, uygulamalar arasında geçiş yapmak için ana ekranı çift tıklayarak erişebileceğiniz anlık görüntülerdir.

iPhone jailbreak edilmedikçe, **saldırganın** bu ekran görüntülerini görebilmesi için **cihaza** **erişimi** **açık** olması gerekir. Varsayılan olarak, son anlık görüntü uygulamanın sandbox'ında `Library/Caches/Snapshots/` veya `Library/SplashBoard/Snapshots` klasöründe depolanır (güvenilir bilgisayarlar iOX 7.0'dan itibaren dosya sistemine erişemez).

Bu kötü davranışı önlemenin bir yolu, `ApplicationDidEnterBackground()` fonksiyonunu kullanarak anlık görüntü almadan önce boş bir ekran koymak veya hassas verileri kaldırmaktır.

Aşağıda, varsayılan bir ekran görüntüsü ayarlayacak bir örnek düzeltme yöntemi bulunmaktadır.

Swift:
```swift
private var backgroundImage: UIImageView?

func applicationDidEnterBackground(_ application: UIApplication) {
let myBanner = UIImageView(image: #imageLiteral(resourceName: "overlayImage"))
myBanner.frame = UIScreen.main.bounds
backgroundImage = myBanner
window?.addSubview(myBanner)
}

func applicationWillEnterForeground(_ application: UIApplication) {
backgroundImage?.removeFromSuperview()
}
```
Objective-C:
```
@property (UIImageView *)backgroundImage;

- (void)applicationDidEnterBackground:(UIApplication *)application {
UIImageView *myBanner = [[UIImageView alloc] initWithImage:@"overlayImage.png"];
self.backgroundImage = myBanner;
self.backgroundImage.bounds = UIScreen.mainScreen.bounds;
[self.window addSubview:myBanner];
}

- (void)applicationWillEnterForeground:(UIApplication *)application {
[self.backgroundImage removeFromSuperview];
}
```
Bu, uygulama arka plana alındığında arka plan resmini `overlayImage.png` olarak ayarlar. `overlayImage.png` mevcut görünümü her zaman geçersiz kılacağı için hassas veri sızıntılarını önler.

### Anahtar Zinciri

iOS anahtar zincirine erişim ve yönetim için, jailbreak yapılmış cihazlar için uygun olan [**Keychain-Dumper**](https://github.com/ptoomey3/Keychain-Dumper) gibi araçlar mevcuttur. Ayrıca, benzer amaçlar için [**Objection**](https://github.com/sensepost/objection) `ios keychain dump` komutunu sağlar.

#### **Kimlik Bilgilerini Saklama**

**NSURLCredential** sınıfı, hassas bilgileri doğrudan anahtar zincirinde saklamak için idealdir ve NSUserDefaults veya diğer sarmalayıcıları atlamayı sağlar. Giriş yaptıktan sonra kimlik bilgilerini saklamak için aşağıdaki Swift kodu kullanılır:
```swift
NSURLCredential *credential;
credential = [NSURLCredential credentialWithUser:username password:password persistence:NSURLCredentialPersistencePermanent];
[[NSURLCredentialStorage sharedCredentialStorage] setCredential:credential forProtectionSpace:self.loginProtectionSpace];
```
Bu saklanan kimlik bilgilerini çıkarmak için, Objection'ın `ios nsurlcredentialstorage dump` komutu kullanılır.

## **Özel Klavyeler ve Klavye Önbelleği**

iOS 8.0 ve sonrasında, kullanıcılar **Ayarlar > Genel > Klavye > Klavyeler** altında yönetilebilen özel klavye uzantıları yükleyebilir. Bu klavyeler genişletilmiş işlevsellik sunarken, tuş vuruşlarını kaydetme ve verileri harici sunuculara iletme riski taşır; ancak kullanıcılar, ağ erişimi gerektiren klavyeler hakkında bilgilendirilir. Uygulamalar, hassas bilgi girişi için özel klavyelerin kullanımını kısıtlayabilir ve kısıtlamalıdır.

**Güvenlik Önerileri:**

- Gelişmiş güvenlik için üçüncü taraf klavyelerin devre dışı bırakılması önerilir.
- Varsayılan iOS klavyesinin otomatik düzeltme ve otomatik öneri özelliklerinin, `Library/Keyboard/{locale}-dynamic-text.dat` veya `/private/var/mobile/Library/Keyboard/dynamic-text.dat` konumundaki önbellek dosyalarında hassas bilgileri saklayabileceğini unutmayın. Bu önbellek dosyaları, hassas veriler için düzenli olarak kontrol edilmelidir. Önbelleğe alınmış verileri temizlemek için **Ayarlar > Genel > Sıfırla > Klavye Sözlüğünü Sıfırla** yoluyla klavye sözlüğünün sıfırlanması önerilir.
- Ağ trafiğini yakalamak, özel bir klavyenin tuş vuruşlarını uzaktan iletip iletmediğini ortaya çıkarabilir.

### **Metin Alanı Önbelleklemesini Önleme**

[UITextInputTraits protokolü](https://developer.apple.com/reference/uikit/uitextinputtraits), hassas bilgi önbelleklemesini önlemek için otomatik düzeltme ve güvenli metin girişi yönetimi için gerekli özellikler sunar. Örneğin, otomatik düzeltmeyi devre dışı bırakmak ve güvenli metin girişini etkinleştirmek şu şekilde yapılabilir:
```objectivec
textObject.autocorrectionType = UITextAutocorrectionTypeNo;
textObject.secureTextEntry = YES;
```
Ayrıca, geliştiricilerin metin alanlarının, özellikle şifreler ve PIN'ler gibi hassas bilgilerin girilmesi için olanların, `autocorrectionType`'ı `UITextAutocorrectionTypeNo` ve `secureTextEntry`'yi `YES` olarak ayarlayarak önbelleği devre dışı bıraktıklarından emin olmaları gerekir.
```objectivec
UITextField *textField = [[UITextField alloc] initWithFrame:frame];
textField.autocorrectionType = UITextAutocorrectionTypeNo;
```
## **Loglar**

Hata ayıklama kodu genellikle **loglama** kullanımını içerir. **Loglar hassas bilgileri içerebilir** ve bu bir risk taşır. Daha önce, iOS 6 ve önceki sürümlerde, loglar tüm uygulamalara erişilebilirdi ve bu da hassas veri sızıntısı riski oluşturuyordu. **Artık uygulamalar yalnızca kendi loglarına erişimle sınırlıdır**.

Bu kısıtlamalara rağmen, **açık bir cihaza fiziksel erişimi olan bir saldırgan**, cihazı bir bilgisayara bağlayarak ve **logları okuyarak** bunu istismar edebilir. Logların, uygulamanın kaldırılmasından sonra bile diskte kalmaya devam ettiğini belirtmek önemlidir.

Riskleri azaltmak için, **uygulama ile kapsamlı bir şekilde etkileşimde bulunulması** ve tüm işlevselliklerin ve girdilerin keşfedilmesi önerilir, böylece hassas bilgilerin yanlışlıkla loglanmadığından emin olunabilir.

Uygulamanın kaynak kodunu potansiyel sızıntılar için incelerken, `NSLog`, `NSAssert`, `NSCAssert`, `fprintf` gibi anahtar kelimeleri kullanarak hem **önceden tanımlı** hem de **özel loglama ifadeleri** arayın ve özel uygulamalar için `Logging` veya `Logfile` ifadelerine dikkat edin.

### **Sistem Loglarını İzleme**

Uygulamalar, hassas olabilecek çeşitli bilgileri loglar. Bu logları izlemek için, şu araçlar ve komutlar gibi:
```bash
idevice_id --list   # To find the device ID
idevicesyslog -u <id> (| grep <app>)   # To capture the device logs
```
yararlıdır. Ayrıca, **Xcode** konsol günlüklerini toplamak için bir yol sağlar:

1. Xcode'u açın.
2. iOS cihazını bağlayın.
3. **Window** -> **Devices and Simulators**'a gidin.
4. Cihazınızı seçin.
5. İncelemekte olduğunuz sorunu tetikleyin.
6. Günlükleri yeni bir pencerede görüntülemek için **Open Console** butonunu kullanın.

Daha gelişmiş günlükleme için, cihaz kabuğuna bağlanmak ve **socat** kullanmak gerçek zamanlı günlük izleme sağlayabilir:
```bash
iPhone:~ root# socat - UNIX-CONNECT:/var/run/lockdown/syslog.sock
```
Log aktivitelerini gözlemlemek için komutlar, sorunları teşhis etmek veya loglarda potansiyel veri sızıntılarını belirlemek için çok değerli olabilir.

## Yedeklemeler

**Otomatik yedekleme özellikleri**, iOS'a entegre edilmiştir ve iTunes (macOS Catalina'ya kadar), Finder (macOS Catalina'dan itibaren) veya iCloud aracılığıyla cihaz veri kopyalarının oluşturulmasını kolaylaştırır. Bu yedeklemeler, Apple Pay detayları ve Touch ID yapılandırmaları gibi son derece hassas unsurlar hariç, neredeyse tüm cihaz verilerini kapsar.

### Güvenlik Riskleri

**Yedeklemelerdeki yüklü uygulamalar ve verileri** dahil edilmesi, potansiyel **veri sızıntısı** ve **yedekleme değişikliklerinin uygulama işlevselliğini değiştirme riski** sorununu gündeme getirir. Bu riskleri azaltmak için, herhangi bir uygulamanın dizininde veya alt dizinlerinde hassas bilgilerin **düz metin olarak saklanmaması** önerilir.

### Yedeklemelerden Dosyaları Hariç Tutma

`Documents/` ve `Library/Application Support/` içindeki dosyalar varsayılan olarak yedeklenir. Geliştiriciler, `NSURL setResourceValue:forKey:error:` ile `NSURLIsExcludedFromBackupKey` kullanarak belirli dosyaları veya dizinleri yedeklemelerden hariç tutabilirler. Bu uygulama, hassas verilerin yedeklemelere dahil edilmesini korumak için kritik öneme sahiptir.

### Açıkları Test Etme

Bir uygulamanın yedekleme güvenliğini değerlendirmek için, önce **bir yedek oluşturun** ve ardından [Apple'ın resmi belgeleri](https://support.apple.com/en-us/HT204215) rehberliğinde yedeği bulun. Uygulama davranışını etkileyebilecek hassas veriler veya yapılandırmalar için yedeği analiz edin.

Hassas bilgilere, komut satırı araçları veya [iMazing](https://imazing.com) gibi uygulamalar kullanarak ulaşılabilir. Şifreli yedeklemeler için, şifrelemenin varlığı, yedeğin kökündeki "Manifest.plist" dosyasındaki "IsEncrypted" anahtarı kontrol edilerek doğrulanabilir.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
...
<key>Date</key>
<date>2021-03-12T17:43:33Z</date>
<key>IsEncrypted</key>
<true/>
...
</plist>
```
Şifreli yedeklerle başa çıkmak için, [DinoSec'in GitHub reposunda](https://github.com/dinosec/iphone-dataprotection/tree/master/python_scripts) bulunan Python betikleri, **backup_tool.py** ve **backup_passwd.py** gibi, faydalı olabilir, ancak en son iTunes/Finder sürümleriyle uyumlu hale getirmek için ayarlamalar gerektirebilir. [**iOSbackup** aracı](https://pypi.org/project/iOSbackup/) ise şifre korumalı yedekler içindeki dosyalara erişim için başka bir seçenektir.

### Uygulama Davranışını Değiştirme

Yedekleme değişiklikleri yoluyla uygulama davranışını değiştirme örneği, [Bither bitcoin cüzdan uygulamasında](https://github.com/bither/bither-ios) gösterilmektedir; burada UI kilit PIN'i `net.bither.plist` içinde **pin_code** anahtarı altında saklanmaktadır. Bu anahtarı plist'ten kaldırmak ve yedeği geri yüklemek, PIN gereksinimini ortadan kaldırarak sınırsız erişim sağlar.

## Hassas Veriler için Bellek Testi Özeti

Bir uygulamanın belleğinde saklanan hassas bilgilerle ilgilenirken, bu verilerin maruz kalma süresini sınırlamak çok önemlidir. Bellek içeriğini araştırmak için iki ana yaklaşım vardır: **bir bellek dökümü oluşturmak** ve **belleği gerçek zamanlı olarak analiz etmek**. Her iki yöntemin de, döküm süreci veya analiz sırasında kritik verileri kaçırma potansiyeli gibi zorlukları vardır.

## **Bir Bellek Dökümünü Alma ve Analiz Etme**

Hem jailbreak yapılmış hem de yapılmamış cihazlar için, [objection](https://github.com/sensepost/objection) ve [Fridump](https://github.com/Nightbringer21/fridump) gibi araçlar, bir uygulamanın işlem belleğini dökme imkanı sunar. Döküm alındıktan sonra, bu verilerin analizi, aradığınız bilginin niteliğine bağlı olarak çeşitli araçlar gerektirir.

Bir bellek dökümünden dizeleri çıkarmak için `strings` veya `rabin2 -zz` gibi komutlar kullanılabilir:
```bash
# Extracting strings using strings command
$ strings memory > strings.txt

# Extracting strings using rabin2
$ rabin2 -ZZ memory > strings.txt
```
Daha ayrıntılı analiz için, belirli veri türlerini veya desenlerini arama dahil, **radare2** geniş arama yetenekleri sunar:
```bash
$ r2 <name_of_your_dump_file>
[0x00000000]> /?
...
```
## **Çalışma Zamanı Bellek Analizi**

**r2frida**, bir uygulamanın belleğini gerçek zamanlı olarak incelemek için güçlü bir alternatif sunar, bellek dökümüne ihtiyaç duymadan. Bu araç, çalışan uygulamanın belleğinde doğrudan arama komutlarının yürütülmesini sağlar:
```bash
$ r2 frida://usb//<name_of_your_app>
[0x00000000]> /\ <search_command>
```
## Kırık Kriptografi

### Zayıf Anahtar Yönetim Süreçleri

Bazı geliştiriciler hassas verileri yerel depolamada saklar ve bunu kodda hardcoded/tahmin edilebilir bir anahtar ile şifreler. Bu yapılmamalıdır çünkü bazı tersine mühendislik işlemleri, saldırganların gizli bilgileri çıkarmasına olanak tanıyabilir.

### Güvensiz ve/veya Kullanımdan Kaldırılmış Algoritmaların Kullanımı

Geliştiriciler **kullanımdan kaldırılmış algoritmalar** kullanarak yetkilendirme **kontrolleri** yapmamalı, **veri** saklamamalı veya **göndermemelidir**. Bu algoritmalardan bazıları: RC4, MD4, MD5, SHA1... Örneğin, şifreleri saklamak için **hash'ler** kullanılıyorsa, tuz ile birlikte brute-force **dirençli** hash'ler kullanılmalıdır.

### Kontrol

Kodda **hardcoded** şifreler/gizli bilgiler bulup bulamayacağınızı, bunların **tahmin edilebilir** olup olmadığını ve kodun bazı **zayıf** **kriptografi** algoritmaları kullanıp kullanmadığını kontrol etmek için ana kontrolleri gerçekleştirmek önemlidir.

Bazı **kripto** **kütüphanelerini** otomatik olarak **objection** ile **izleyebileceğinizi** bilmek ilginçtir:
```swift
ios monitor crypt
```
Daha fazla bilgi için iOS kriptografik API'leri ve kütüphaneleri hakkında [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography) adresini ziyaret edin.

## Yerel Kimlik Doğrulama

**Yerel kimlik doğrulama**, özellikle uzaktan bir uç noktada kriptografik yöntemlerle erişimi korumak söz konusu olduğunda kritik bir rol oynar. Buradaki öz, uygun bir uygulama olmadan yerel kimlik doğrulama mekanizmalarının aşılabileceğidir.

Apple'ın [**Yerel Kimlik Doğrulama çerçevesi**](https://developer.apple.com/documentation/localauthentication) ve [**anahtar zinciri**](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html), geliştiricilerin kullanıcı kimlik doğrulama diyaloglarını kolaylaştırmaları ve gizli verileri güvenli bir şekilde yönetmeleri için sağlam API'ler sunar. Secure Enclave, Touch ID için parmak izi kimliğini güvence altına alırken, Face ID biyometrik verileri tehlikeye atmadan yüz tanımaya dayanır.

Touch ID/Face ID'yi entegre etmek için geliştiricilerin iki API seçeneği vardır:

- **`LocalAuthentication.framework`** biyometrik verilere erişim olmadan yüksek düzeyde kullanıcı kimlik doğrulaması için.
- **`Security.framework`** biyometrik kimlik doğrulaması ile gizli verileri güvence altına alarak daha düşük düzeyde anahtar zinciri hizmetlerine erişim için. Çeşitli [açık kaynaklı sarmalayıcılar](https://www.raywenderlich.com/147308/secure-ios-user-data-keychain-touch-id) anahtar zinciri erişimini daha basit hale getirir.

> [!CAUTION]
> Ancak, hem `LocalAuthentication.framework` hem de `Security.framework` zafiyetler sunar, çünkü esasen kimlik doğrulama süreçleri için veri iletmeden boolean değerleri döndürürler, bu da onları aşılabilir hale getirir (bkz. [Bana öyle dokunma, David Lindner ve diğerleri](https://www.youtube.com/watch?v=XhXIHVGCFFM)).

### Yerel Kimlik Doğrulama Uygulaması

Kullanıcılardan kimlik doğrulama istemek için geliştiricilerin **`LAContext`** sınıfındaki **`evaluatePolicy`** yöntemini kullanmaları gerekir ve şu seçeneklerden birini seçmelidirler:

- **`deviceOwnerAuthentication`**: Touch ID veya cihaz şifresi için istemde bulunur, ikisi de etkin değilse başarısız olur.
- **`deviceOwnerAuthenticationWithBiometrics`**: Sadece Touch ID için istemde bulunur.

Başarılı bir kimlik doğrulama, **`evaluatePolicy`** yönteminden dönen boolean bir değerle gösterilir ve bu, potansiyel bir güvenlik açığını vurgular.

### Anahtar Zinciri Kullanarak Yerel Kimlik Doğrulama

iOS uygulamalarında **yerel kimlik doğrulama** uygulamak, kimlik doğrulama token'ları gibi gizli verileri güvenli bir şekilde depolamak için **anahtar zinciri API'lerini** kullanmayı içerir. Bu süreç, verilerin yalnızca kullanıcının cihaz şifresi veya Touch ID gibi biyometrik kimlik doğrulama ile erişilebileceğini garanti eder.

Anahtar zinciri, kullanıcı başarılı bir şekilde Touch ID veya cihaz şifresi ile kimlik doğrulaması yapana kadar öğeye erişimi kısıtlayan `SecAccessControl` niteliği ile öğeleri ayarlama yeteneği sunar. Bu özellik, güvenliği artırmak için kritik öneme sahiptir.

Aşağıda, bu güvenlik özelliklerini kullanarak bir dizeyi anahtar zincirine kaydetme ve geri alma yöntemlerini gösteren Swift ve Objective-C'de kod örnekleri bulunmaktadır. Örnekler, Touch ID kimlik doğrulaması gerektirecek şekilde erişim kontrolünü nasıl ayarlayacağınızı ve verilerin yalnızca kurulduğu cihazda erişilebilir olmasını sağlamak için bir cihaz şifresinin yapılandırılması koşulunu göstermektedir.

{{#tabs}}
{{#tab name="Swift"}}
```swift
// From https://github.com/mufambisi/owasp-mstg/blob/master/Document/0x06f-Testing-Local-Authentication.md

// 1. create AccessControl object that will represent authentication settings

var error: Unmanaged<CFError>?

guard let accessControl = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
SecAccessControlCreateFlags.biometryCurrentSet,
&error) else {
// failed to create AccessControl object

return
}

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute

var query: [String: Any] = [:]

query[kSecClass as String] = kSecClassGenericPassword
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecAttrAccount as String] = "OWASP Account" as CFString
query[kSecValueData as String] = "test_strong_password".data(using: .utf8)! as CFData
query[kSecAttrAccessControl as String] = accessControl

// 3. save item

let status = SecItemAdd(query as CFDictionary, nil)

if status == noErr {
// successfully saved
} else {
// error while saving
}
```
{{#endtab}}

{{#tab name="Objective-C"}}
```objectivec
// 1. create AccessControl object that will represent authentication settings
CFErrorRef *err = nil;

SecAccessControlRef sacRef = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
kSecAccessControlUserPresence,
err);

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute
NSDictionary* query = @{
(_ _bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecAttrAccount: @"OWASP Account",
(__bridge id)kSecValueData: [@"test_strong_password" dataUsingEncoding:NSUTF8StringEncoding],
(__bridge id)kSecAttrAccessControl: (__bridge_transfer id)sacRef
};

// 3. save item
OSStatus status = SecItemAdd((__bridge CFDictionaryRef)query, nil);

if (status == noErr) {
// successfully saved
} else {
// error while saving
}
```
{{#endtab}}
{{#endtabs}}

Artık anahtarlıkta kaydedilen öğeyi talep edebiliriz. Anahtarlık hizmetleri, kullanıcıya kimlik doğrulama penceresini gösterecek ve uygun bir parmak izi sağlanıp sağlanmadığına bağlı olarak veri veya nil döndürecektir.

{{#tabs}}
{{#tab name="Swift"}}
```swift
// 1. define query
var query = [String: Any]()
query[kSecClass as String] = kSecClassGenericPassword
query[kSecReturnData as String] = kCFBooleanTrue
query[kSecAttrAccount as String] = "My Name" as CFString
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecUseOperationPrompt as String] = "Please, pass authorisation to enter this area" as CFString

// 2. get item
var queryResult: AnyObject?
let status = withUnsafeMutablePointer(to: &queryResult) {
SecItemCopyMatching(query as CFDictionary, UnsafeMutablePointer($0))
}

if status == noErr {
let password = String(data: queryResult as! Data, encoding: .utf8)!
// successfully received password
} else {
// authorization not passed
}
```
{{#endtab}}

{{#tab name="Objective-C"}}
```objectivec
// 1. define query
NSDictionary *query = @{(__bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecReturnData: @YES,
(__bridge id)kSecAttrAccount: @"My Name1",
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecUseOperationPrompt: @"Please, pass authorisation to enter this area" };

// 2. get item
CFTypeRef queryResult = NULL;
OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)query, &queryResult);

if (status == noErr){
NSData* resultData = ( __bridge_transfer NSData* )queryResult;
NSString* password = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding];
NSLog(@"%@", password);
} else {
NSLog(@"Something went wrong");
}
```
{{#endtab}}
{{#endtabs}}

### Tespit

Bir uygulamadaki framework'lerin kullanımı, uygulama ikilisinin paylaşılan dinamik kütüphaneler listesini analiz ederek de tespit edilebilir. Bu, `otool` kullanılarak yapılabilir:
```bash
$ otool -L <AppName>.app/<AppName>
```
Eğer bir uygulamada `LocalAuthentication.framework` kullanılıyorsa, çıktı aşağıdaki iki satırı da içerecektir (unutmayın ki `LocalAuthentication.framework` arka planda `Security.framework` kullanır):
```bash
/System/Library/Frameworks/LocalAuthentication.framework/LocalAuthentication
/System/Library/Frameworks/Security.framework/Security
```
Eğer `Security.framework` kullanılıyorsa, yalnızca ikincisi gösterilecektir.

### Yerel Kimlik Doğrulama Çerçevesi Atlatma

#### **Objection**

**Objection Biometrics Bypass** aracılığıyla, [bu GitHub sayfasında](https://github.com/sensepost/objection/wiki/Understanding-the-iOS-Biometrics-Bypass) yer alan bir teknik, **LocalAuthentication** mekanizmasını aşmak için mevcuttur. Bu yaklaşımın temeli, `evaluatePolicy` fonksiyonunu manipüle etmek için **Frida** kullanmaktır; bu sayede, gerçek kimlik doğrulama başarısından bağımsız olarak sürekli olarak `True` sonucu elde edilir. Bu, hatalı biyometrik kimlik doğrulama süreçlerini aşmak için özellikle faydalıdır.

Bu atlatmayı etkinleştirmek için aşağıdaki komut kullanılır:
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios ui biometrics_bypass
(agent) Registering job 3mhtws9x47q. Type: ios-biometrics-disable
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # (agent) [3mhtws9x47q] Localized Reason for auth requirement: Please authenticate yourself
(agent) [3mhtws9x47q] OS authentication response: false
(agent) [3mhtws9x47q] Marking OS response as True instead
(agent) [3mhtws9x47q] Biometrics bypass hook complete
```
Bu komut, Objection'ın `evaluatePolicy` kontrolünün sonucunu `True` olarak etkili bir şekilde değiştiren bir görevi kaydettiği bir dizi başlatır.

#### Frida

**`evaluatePolicy`** kullanımına bir örnek [DVIA-v2 uygulamasından](https://github.com/prateek147/DVIA-v2):
```swift
+(void)authenticateWithTouchID {
LAContext *myContext = [[LAContext alloc] init];
NSError *authError = nil;
NSString *myLocalizedReasonString = @"Please authenticate yourself";

if ([myContext canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&authError]) {
[myContext evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics
localizedReason:myLocalizedReasonString
reply:^(BOOL success, NSError *error) {
if (success) {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Successful" withTitle:@"Success"];
});
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Failed !" withTitle:@"Error"];
});
}
}];
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Your device doesn't support Touch ID or you haven't configured Touch ID authentication on your device" withTitle:@"Error"];
});
}
}
```
Yerel Kimlik Doğrulama'nın **bypass** edilmesi için bir Frida scripti yazılmıştır. Bu script, **evaluatePolicy** kontrolünü hedef alır ve geri çağrısını keserek **success=1** döndürmesini sağlar. Geri çağrının davranışını değiştirerek, kimlik doğrulama kontrolü etkili bir şekilde bypass edilir.

Aşağıdaki script, **evaluatePolicy** yönteminin sonucunu değiştirmek için enjekte edilir. Geri çağrının sonucunu her zaman başarıyı gösterecek şekilde değiştirir.
```swift
// from https://securitycafe.ro/2022/09/05/mobile-pentesting-101-bypassing-biometric-authentication/
if(ObjC.available) {
console.log("Injecting...");
var hook = ObjC.classes.LAContext["- evaluatePolicy:localizedReason:reply:"];
Interceptor.attach(hook.implementation, {
onEnter: function(args) {
var block = new ObjC.Block(args[4]);
const callback = block.implementation;
block.implementation = function (error, value)  {

console.log("Changing the result value to true")
const result = callback(1, null);
return result;
};
},
});
} else {
console.log("Objective-C Runtime is not available!");
}
```
Frida betiğini enjekte etmek ve biyometrik kimlik doğrulamayı atlatmak için aşağıdaki komut kullanılır:
```bash
frida -U -f com.highaltitudehacks.DVIAswiftv2 --no-pause -l fingerprint-bypass-ios.js
```
## Hassas Fonksiyonelliklerin IPC Üzerinden Açığa Çıkması

### Özel URI İşleyicileri / Deeplinks / Özel Şemalar

{{#ref}}
ios-custom-uri-handlers-deeplinks-custom-schemes.md
{{#endref}}

### Evrensel Bağlantılar

{{#ref}}
ios-universal-links.md
{{#endref}}

### UIActivity Paylaşımı

{{#ref}}
ios-uiactivity-sharing.md
{{#endref}}

### UIPasteboard

{{#ref}}
ios-uipasteboard.md
{{#endref}}

### Uygulama Uzantıları

{{#ref}}
ios-app-extensions.md
{{#endref}}

### Web Görünümleri

{{#ref}}
ios-webviews.md
{{#endref}}

### Serileştirme ve Kodlama

{{#ref}}
ios-serialisation-and-encoding.md
{{#endref}}

## Ağ İletişimi

**Şifreleme olmadan** iletişim gerçekleşmediğinden emin olmak ve ayrıca uygulamanın sunucunun **TLS sertifikasını** doğru bir şekilde **doğruladığından** emin olmak önemlidir.\
Bu tür sorunları kontrol etmek için **Burp** gibi bir proxy kullanabilirsiniz:

{{#ref}}
burp-configuration-for-ios.md
{{#endref}}

### Hostname Kontrolü

TLS sertifikasını doğrularken yaygın bir sorun, sertifikanın **güvenilir** bir **CA** tarafından imzalanıp imzalanmadığını kontrol etmektir, ancak **sertifikanın** **hostname**'inin erişilen hostname olup olmadığını **kontrol etmemektir**.\
Bu sorunu Burp kullanarak kontrol etmek için, iPhone'da Burp CA'sını güvenilir hale getirdikten sonra, **farklı bir hostname için Burp ile yeni bir sertifika oluşturabilir** ve bunu kullanabilirsiniz. Uygulama hala çalışıyorsa, o zaman bir şeyler savunmasızdır.

### Sertifika Pinning

Bir uygulama SSL Pinning'i doğru bir şekilde kullanıyorsa, uygulama yalnızca beklenen sertifika ile çalışır. Bir uygulamayı test ederken **bu, Burp kendi sertifikasını sunacağı için bir sorun olabilir.**\
Jailbroken bir cihazda bu korumayı aşmak için, [**SSL Kill Switch**](https://github.com/nabla-c0d3/ssl-kill-switch2) uygulamasını yükleyebilir veya [**Burp Mobile Assistant**](https://portswigger.net/burp/documentation/desktop/mobile/config-ios-device) yükleyebilirsiniz.

Ayrıca **objection's** `ios sslpinning disable` komutunu da kullanabilirsiniz.

## Çeşitli

- **`/System/Library`** içinde sistem uygulamaları tarafından kullanılan telefon üzerindeki framework'leri bulabilirsiniz.
- Kullanıcı tarafından App Store'dan yüklenen uygulamalar **`/User/Applications`** içinde yer almaktadır.
- **`/User/Library`** ise kullanıcı seviyesindeki uygulamalar tarafından kaydedilen verileri içerir.
- Uygulama içinde kaydedilen notları okumak için **`/User/Library/Notes/notes.sqlite`** dosyasına erişebilirsiniz.
- Yüklenmiş bir uygulamanın klasörü içinde (**`/User/Applications/<APP ID>/`**) bazı ilginç dosyalar bulabilirsiniz:
- **`iTunesArtwork`**: Uygulamanın kullandığı simge
- **`iTunesMetadata.plist`**: App Store'da kullanılan uygulama bilgileri
- **`/Library/*`**: Tercihleri ve önbelleği içerir. **`/Library/Cache/Snapshots/*`** içinde uygulamaya arka plana gönderilmeden önce yapılan anlık görüntüyü bulabilirsiniz.

### Sıcak Yamanın/Zorunlu Güncellemenin

Geliştiriciler, uygulamalarının tüm kurulumlarını anında **yamanlayabilir** ve uygulamayı App Store'a yeniden göndermeye gerek kalmadan onay bekleyebilirler.\
Bu amaçla genellikle [**JSPatch**](https://github.com/bang590/JSPatch)** kullanılır.** Ancak [Siren](https://github.com/ArtSabintsev/Siren) ve [react-native-appstore-version-checker](https://www.npmjs.com/package/react-native-appstore-version-checker) gibi diğer seçenekler de vardır.\
**Bu, kötü niyetli üçüncü taraf SDK'lar tarafından kötüye kullanılabilecek tehlikeli bir mekanizmadır, bu nedenle otomatik güncelleme için hangi yöntemin kullanıldığını kontrol etmek ve test etmek önerilir.** Bu amaçla uygulamanın önceki bir sürümünü indirmeyi deneyebilirsiniz.

### Üçüncü Taraflar

**3. taraf SDK'lar** ile ilgili önemli bir zorluk, işlevleri üzerinde **detaylı kontrol eksikliği**dir. Geliştiriciler, SDK'yı entegre etme ve potansiyel güvenlik açıkları ve gizlilik endişeleri dahil olmak üzere tüm özelliklerini kabul etme veya tamamen faydalarından vazgeçme seçeneği ile karşı karşıyadır. Genellikle, geliştiriciler bu SDK'lar içindeki güvenlik açıklarını kendileri yamalayamazlar. Ayrıca, SDK'lar topluluk içinde güven kazandıkça, bazıları kötü amaçlı yazılım içermeye başlayabilir.

Üçüncü taraf SDK'lar tarafından sağlanan hizmetler, kullanıcı davranışını izleme, reklam gösterimleri veya kullanıcı deneyimi iyileştirmeleri içerebilir. Ancak, bu, geliştiricilerin bu kütüphaneler tarafından yürütülen kodun tam olarak farkında olmaması nedeniyle potansiyel gizlilik ve güvenlik riskleri oluşturur. Üçüncü taraf hizmetlerle paylaşılan bilgilerin yalnızca gerekli olanlarla sınırlı olması ve hassas verilerin açığa çıkmadığından emin olunması önemlidir.

Üçüncü taraf hizmetlerin uygulanması genellikle iki biçimde gelir: bağımsız bir kütüphane veya tam bir SDK. Kullanıcı gizliliğini korumak için, bu hizmetlerle paylaşılan verilerin **anonimleştirilmesi** gerekmektedir, böylece Kişisel Tanımlanabilir Bilgilerin (PII) ifşası önlenir.

Bir uygulamanın kullandığı kütüphaneleri belirlemek için **`otool`** komutu kullanılabilir. Bu araç, uygulama ve kullandığı her paylaşılan kütüphane üzerinde çalıştırılmalıdır.
```bash
otool -L <application_path>
```
## **Referanslar ve Daha Fazla Kaynak**

- [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering)
- [iOS & Mobil Uygulama Pentesting - INE](https://my.ine.com/CyberSecurity/courses/089d060b/ios-mobile-app-pentesting)
- [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/)
- [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/)
- [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/)
- [https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage](https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage)
- [https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way](https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053)
- [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060)
- [https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/](https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064](https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064)
- [https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc](https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054)
- [https://github.com/ivRodriguezCA/RE-iOS-Apps/](https://github.com/ivRodriguezCA/RE-iOS-Apps/) IOS ücretsiz kurs([https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/](https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/))
- [https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577](https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577)
- [https://www.slideshare.net/RyanISI/ios-appsecurityminicourse](https://www.slideshare.net/RyanISI/ios-appsecurityminicourse)
- [https://github.com/prateek147/DVIA](https://github.com/prateek147/DVIA)
- [https://github.com/prateek147/DVIA-v2](https://github.com/prateek147/DVIA-v2)
- [https://github.com/OWASP/MSTG-Hacking-Playground%20](https://github.com/OWASP/MSTG-Hacking-Playground)
- OWASP iGoat [_https://github.com/OWASP/igoat_](https://github.com/OWASP/igoat) <<< Objective-C versiyonu [_https://github.com/OWASP/iGoat-Swift_](https://github.com/OWASP/iGoat-Swift) <<< Swift versiyonu
- [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
- [https://github.com/nabla-c0d3/ssl-kill-switch2](https://github.com/nabla-c0d3/ssl-kill-switch2)


{{#include ../../banners/hacktricks-training.md}}
