# iOS Pentesting

{{#include ../../banners/hacktricks-training.md}}

## iOS Basics

{{#ref}}
ios-basics.md
{{#endref}}

## Testing Environment

이 페이지에서는 **iOS 시뮬레이터**, **에뮬레이터** 및 **탈옥**에 대한 정보를 찾을 수 있습니다:

{{#ref}}
ios-testing-environment.md
{{#endref}}

## Initial Analysis

### Basic iOS Testing Operations

테스트 중에 **여러 작업이 제안될 것입니다** (장치에 연결, 파일 읽기/쓰기/업로드/다운로드, 일부 도구 사용...). 따라서 이러한 작업을 수행하는 방법을 모른다면, **페이지를 읽기 시작하세요**:

{{#ref}}
basic-ios-testing-operations.md
{{#endref}}

> [!NOTE]
> 다음 단계에서는 **앱이 장치에 설치되어 있어야** 하며, 애플리케이션의 **IPA 파일**을 이미 확보해야 합니다.\
> [Basic iOS Testing Operations](basic-ios-testing-operations.md) 페이지를 읽어 이 작업을 수행하는 방법을 배우세요.

### Basic Static Analysis

흥미로운 iOS - IPA 파일 디컴파일러:

- https://github.com/LaurieWired/Malimite
- https://ghidra-sre.org/

IPA 파일에 대한 자동 정적 분석을 수행하기 위해 [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) 도구를 사용하는 것이 좋습니다.

**이진 파일에 존재하는 보호 식별**:

- **PIE (Position Independent Executable)**: 활성화되면 애플리케이션이 실행될 때마다 무작위 메모리 주소에 로드되어 초기 메모리 주소를 예측하기 어렵게 만듭니다.

```bash
otool -hv <app-binary> | grep PIE   # PIE 플래그가 포함되어야 합니다.
```

- **Stack Canaries**: 스택의 무결성을 검증하기 위해 함수 호출 전에 스택에 '카나리' 값을 배치하고 함수가 끝난 후 다시 검증합니다.

```bash
otool -I -v <app-binary> | grep stack_chk   # stack_chk_guard 및 stack_chk_fail 기호가 포함되어야 합니다.
```

- **ARC (Automatic Reference Counting)**: 일반적인 메모리 손상 결함을 방지합니다.

```bash
otool -I -v <app-binary> | grep objc_release   # _objc_release 기호가 포함되어야 합니다.
```

- **Encrypted Binary**: 이진 파일은 암호화되어야 합니다.

```bash
otool -arch all -Vl <app-binary> | grep -A5 LC_ENCRYPT   # cryptid는 1이어야 합니다.
```

**민감한/취약한 함수 식별**

- **Weak Hashing Algorithms**

```bash
# iOS 장치에서
otool -Iv <app> | grep -w "_CC_MD5"
otool -Iv <app> | grep -w "_CC_SHA1"

# 리눅스에서
grep -iER "_CC_MD5"
grep -iER "_CC_SHA1"
```

- **Insecure Random Functions**

```bash
# iOS 장치에서
otool -Iv <app> | grep -w "_random"
otool -Iv <app> | grep -w "_srand"
otool -Iv <app> | grep -w "_rand"

# 리눅스에서
grep -iER "_random"
grep -iER "_srand"
grep -iER "_rand"
```

- **Insecure ‘Malloc’ Function**

```bash
# iOS 장치에서
otool -Iv <app> | grep -w "_malloc"

# 리눅스에서
grep -iER "_malloc"
```

- **Insecure and Vulnerable Functions**

```bash
# iOS 장치에서
otool -Iv <app> | grep -w "_gets"
otool -Iv <app> | grep -w "_memcpy"
otool -Iv <app> | grep -w "_strncpy"
otool -Iv <app> | grep -w "_strlen"
otool -Iv <app> | grep -w "_vsnprintf"
otool -Iv <app> | grep -w "_sscanf"
otool -Iv <app> | grep -w "_strtok"
otool -Iv <app> | grep -w "_alloca"
otool -Iv <app> | grep -w "_sprintf"
otool -Iv <app> | grep -w "_printf"
otool -Iv <app> | grep -w "_vsprintf"

# 리눅스에서
grep -R "_gets"
grep -iER "_memcpy"
grep -iER "_strncpy"
grep -iER "_strlen"
grep -iER "_vsnprintf"
grep -iER "_sscanf"
grep -iER "_strtok"
grep -iER "_alloca"
grep -iER "_sprintf"
grep -iER "_printf"
grep -iER "_vsprintf"
```

### Basic Dynamic Analysis

[**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF)가 수행하는 동적 분석을 확인하세요. 다양한 뷰를 탐색하고 상호작용해야 하지만, 다른 작업을 수행하는 동안 여러 클래스를 후킹하고 완료되면 보고서를 준비합니다.

### Listing Installed Apps

설치된 앱의 **번들 식별자**를 확인하려면 `frida-ps -Uai` 명령을 사용하세요:
```bash
$ frida-ps -Uai
PID  Name                 Identifier
----  -------------------  -----------------------------------------
6847  Calendar             com.apple.mobilecal
6815  Mail                 com.apple.mobilemail
-  App Store            com.apple.AppStore
-  Apple Store          com.apple.store.Jolly
-  Calculator           com.apple.calculator
-  Camera               com.apple.camera
-  iGoat-Swift          OWASP.iGoat-Swift
```
### 기본 열거 및 후킹

애플리케이션의 **구성 요소를 열거하는 방법**과 **objection을 사용하여 메서드와 클래스를 쉽게 후킹하는 방법**을 배웁니다:

{{#ref}}
ios-hooking-with-objection.md
{{#endref}}

### IPA 구조

**IPA 파일**의 구조는 본질적으로 **압축된 패키지**의 형태입니다. 확장자를 `.zip`으로 변경하면 **압축 해제**하여 내용을 확인할 수 있습니다. 이 구조 내에서 **Bundle**은 설치 준비가 완료된 완전 패키지 애플리케이션을 나타냅니다. 내부에는 애플리케이션의 리소스를 캡슐화하는 `<NAME>.app`이라는 디렉토리가 있습니다.

- **`Info.plist`**: 이 파일은 애플리케이션의 특정 구성 세부정보를 포함합니다.
- **`_CodeSignature/`**: 이 디렉토리에는 번들 내 모든 파일의 무결성을 보장하는 서명이 포함된 plist 파일이 있습니다.
- **`Assets.car`**: 아이콘과 같은 자산 파일을 저장하는 압축 아카이브입니다.
- **`Frameworks/`**: 이 폴더에는 `.dylib` 또는 `.framework` 파일 형식의 애플리케이션 네이티브 라이브러리가 포함되어 있습니다.
- **`PlugIns/`**: 이 디렉토리에는 애플리케이션의 확장인 `.appex` 파일이 포함될 수 있지만 항상 존재하는 것은 아닙니다. \* [**`Core Data`**](https://developer.apple.com/documentation/coredata): 애플리케이션의 영구 데이터를 오프라인에서 저장하고, 임시 데이터를 캐시하며, 단일 장치에서 앱의 실행 취소 기능을 추가하는 데 사용됩니다. 단일 iCloud 계정의 여러 장치 간에 데이터를 동기화하기 위해 Core Data는 자동으로 스키마를 CloudKit 컨테이너에 미러링합니다.
- [**`PkgInfo`**](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigApplications.html): `PkgInfo` 파일은 애플리케이션 또는 번들의 유형 및 작성자 코드를 지정하는 대체 방법입니다.
- **en.lproj, fr.proj, Base.lproj**: 특정 언어에 대한 리소스를 포함하는 언어 팩이며, 언어가 지원되지 않을 경우 기본 리소스를 포함합니다.
- **보안**: `_CodeSignature/` 디렉토리는 디지털 서명을 통해 번들된 모든 파일의 무결성을 검증하여 앱의 보안에서 중요한 역할을 합니다.
- **자산 관리**: `Assets.car` 파일은 압축을 사용하여 그래픽 자산을 효율적으로 관리하며, 이는 애플리케이션 성능 최적화와 전체 크기 감소에 중요합니다.
- **프레임워크 및 플러그인**: 이러한 디렉토리는 iOS 애플리케이션의 모듈성을 강조하며, 개발자가 재사용 가능한 코드 라이브러리(`Frameworks/`)를 포함하고 앱 기능을 확장(`PlugIns/`)할 수 있도록 합니다.
- **현지화**: 이 구조는 여러 언어를 지원하여 특정 언어 팩에 대한 리소스를 포함함으로써 글로벌 애플리케이션 도달을 촉진합니다.

**Info.plist**

**Info.plist**는 iOS 애플리케이션의 초석으로, **키-값** 쌍 형태로 주요 구성 데이터를 캡슐화합니다. 이 파일은 애플리케이션뿐만 아니라 번들 내의 앱 확장 및 프레임워크에도 필수적입니다. XML 또는 이진 형식으로 구성되어 있으며, 앱 권한에서 보안 구성에 이르기까지 중요한 정보를 포함합니다. 사용 가능한 키에 대한 자세한 탐색은 [**Apple Developer Documentation**](https://developer.apple.com/documentation/bundleresources/information_property_list?language=objc)를 참조할 수 있습니다.

이 파일을 보다 접근 가능한 형식으로 작업하려는 경우, macOS에서 `plutil`을 사용하여 XML 변환을 쉽게 수행할 수 있습니다(버전 10.2 이상에서 기본적으로 제공됨) 또는 Linux에서 `plistutil`을 사용할 수 있습니다. 변환 명령은 다음과 같습니다:

- **macOS의 경우**:
```bash
$ plutil -convert xml1 Info.plist
```
- **리눅스를 위한**:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
**Info.plist** 파일이 공개할 수 있는 수많은 정보 중에서 주목할 만한 항목으로는 앱 권한 문자열(`UsageDescription`), 사용자 정의 URL 스킴(`CFBundleURLTypes`), 그리고 앱 전송 보안 설정(`NSAppTransportSecurity`)이 있습니다. 이러한 항목들은 내보내기/가져오기 사용자 정의 문서 유형(`UTExportedTypeDeclarations` / `UTImportedTypeDeclarations`)과 같은 다른 항목들과 함께 파일을 검사하거나 간단한 `grep` 명령을 사용하여 쉽게 찾을 수 있습니다:
```bash
$ grep -i <keyword> Info.plist
```
**데이터 경로**

iOS 환경에서는 **시스템 애플리케이션**과 **사용자 설치 애플리케이션**을 위해 특정 디렉토리가 지정됩니다. 시스템 애플리케이션은 `/Applications` 디렉토리에 위치하고, 사용자 설치 앱은 `/var/mobile/containers/Data/Application/` 아래에 배치됩니다. 이러한 애플리케이션은 **128비트 UUID**라는 고유 식별자가 할당되어 있어, 디렉토리 이름의 무작위성 때문에 수동으로 앱의 폴더를 찾는 것이 어렵습니다.

> [!WARNING]
> iOS의 애플리케이션은 샌드박스화되어야 하므로, 각 앱은 **`$HOME/Library/Containers`** 내에 앱의 **`CFBundleIdentifier`**를 폴더 이름으로 가진 폴더도 갖습니다.
>
> 그러나 두 폴더(데이터 및 컨테이너 폴더) 모두 **`.com.apple.mobile_container_manager.metadata.plist`** 파일을 가지고 있으며, 이 파일은 키 `MCMetadataIdentifier`에서 두 파일을 연결합니다.

사용자 설치 앱의 설치 디렉토리를 발견하기 위해, **objection tool**은 유용한 명령어인 `env`를 제공합니다. 이 명령어는 해당 앱에 대한 자세한 디렉토리 정보를 보여줍니다. 아래는 이 명령어를 사용하는 방법의 예입니다:
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # env

Name               Path
-----------------  -------------------------------------------------------------------------------------------
BundlePath         /var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app
CachesDirectory    /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library/Caches
DocumentDirectory  /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Documents
LibraryDirectory   /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library
```
대안으로, 앱 이름은 `/private/var/containers` 내에서 `find` 명령어를 사용하여 검색할 수 있습니다:
```bash
find /private/var/containers -name "Progname*"
```
`ps` 및 `lsof`와 같은 명령어는 각각 앱의 프로세스를 식별하고 열린 파일을 나열하는 데 사용될 수 있으며, 애플리케이션의 활성 디렉토리 경로에 대한 통찰력을 제공합니다:
```bash
ps -ef | grep -i <app-name>
lsof -p <pid> | grep -i "/containers" | head -n 1
```
**번들 디렉토리:**

- **AppName.app**
- 이것은 IPA에서 이전에 본 애플리케이션 번들로, 필수 애플리케이션 데이터, 정적 콘텐츠 및 애플리케이션의 컴파일된 바이너리를 포함합니다.
- 이 디렉토리는 사용자에게 보이지만 **사용자는 여기에 쓸 수 없습니다**.
- 이 디렉토리의 콘텐츠는 **백업되지 않습니다**.
- 이 폴더의 내용은 **코드 서명을 검증하는 데 사용됩니다**.

**데이터 디렉토리:**

- **Documents/**
- 모든 사용자 생성 데이터를 포함합니다. 애플리케이션 최종 사용자가 이 데이터의 생성을 시작합니다.
- 사용자에게 보이며 **사용자는 여기에 쓸 수 있습니다**.
- 이 디렉토리의 콘텐츠는 **백업됩니다**.
- 앱은 `NSURLIsExcludedFromBackupKey`를 설정하여 경로를 비활성화할 수 있습니다.
- **Library/**
- **캐시**, **환경 설정**, **쿠키** 및 속성 목록(plist) 구성 파일과 같은 **사용자 특정이 아닌** 모든 **파일**을 포함합니다.
- iOS 앱은 일반적으로 `Application Support` 및 `Caches` 하위 디렉토리를 사용하지만, 앱은 사용자 정의 하위 디렉토리를 생성할 수 있습니다.
- **Library/Caches/**
- **반영구적인 캐시 파일**을 포함합니다.
- 사용자에게 보이지 않으며 **사용자는 여기에 쓸 수 없습니다**.
- 이 디렉토리의 콘텐츠는 **백업되지 않습니다**.
- OS는 앱이 실행되지 않고 저장 공간이 부족할 때 이 디렉토리의 파일을 자동으로 삭제할 수 있습니다.
- **Library/Application Support/**
- 앱 실행에 필요한 **영구적인** **파일**을 포함합니다.
- **사용자에게 보이지 않으며** 사용자는 여기에 쓸 수 없습니다.
- 이 디렉토리의 콘텐츠는 **백업됩니다**.
- 앱은 `NSURLIsExcludedFromBackupKey`를 설정하여 경로를 비활성화할 수 있습니다.
- **Library/Preferences/**
- 애플리케이션이 재시작된 후에도 **지속될 수 있는** 속성을 저장하는 데 사용됩니다.
- 정보는 암호화되지 않은 상태로 애플리케이션 샌드박스 내의 \[BUNDLE_ID].plist라는 plist 파일에 저장됩니다.
- `NSUserDefaults`를 사용하여 저장된 모든 키/값 쌍은 이 파일에서 찾을 수 있습니다.
- **tmp/**
- 앱 실행 간에 지속될 필요가 없는 **임시 파일**을 작성하는 데 이 디렉토리를 사용합니다.
- 비영구적인 캐시 파일을 포함합니다.
- **사용자에게 보이지 않습니다**.
- 이 디렉토리의 콘텐츠는 백업되지 않습니다.
- OS는 앱이 실행되지 않고 저장 공간이 부족할 때 이 디렉토리의 파일을 자동으로 삭제할 수 있습니다.

iGoat-Swift의 애플리케이션 번들(.app) 디렉토리를 번들 디렉토리 내에서 자세히 살펴보겠습니다 (`/var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app`):
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # ls
NSFileType      Perms  NSFileProtection    ...  Name
------------  -------  ------------------  ...  --------------------------------------
Regular           420  None                ...  rutger.html
Regular           420  None                ...  mansi.html
Regular           420  None                ...  splash.html
Regular           420  None                ...  about.html

Regular           420  None                ...  LICENSE.txt
Regular           420  None                ...  Sentinel.txt
Regular           420  None                ...  README.txt
```
### Binary Reversing

`<application-name>.app` 폴더 안에는 `<application-name>`이라는 이름의 바이너리 파일이 있습니다. 이 파일이 **실행**될 파일입니다. **`otool`** 도구를 사용하여 바이너리를 기본적으로 검사할 수 있습니다:
```bash
otool -Vh DVIA-v2 #Check some compilation attributes
magic  cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64    ARM64        ALL  0x00     EXECUTE    65       7112   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE

otool -L DVIA-v2 #Get third party libraries
DVIA-v2:
/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.1)
/usr/lib/libsqlite3.dylib (compatibility version 9.0.0, current version 274.6.0)
/usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11)
@rpath/Bolts.framework/Bolts (compatibility version 1.0.0, current version 1.0.0)
[...]
```
**앱이 암호화되어 있는지 확인하세요**

다음에 대한 출력이 있는지 확인하세요:
```bash
otool -l <app-binary> | grep -A 4 LC_ENCRYPTION_INFO
```
**이진 파일 분해**

텍스트 섹션을 분해합니다:
```bash
otool -tV DVIA-v2
DVIA-v2:
(__TEXT,__text) section
+[DDLog initialize]:
0000000100004ab8    sub    sp, sp, #0x60
0000000100004abc    stp    x29, x30, [sp, #0x50]   ; Latency: 6
0000000100004ac0    add    x29, sp, #0x50
0000000100004ac4    sub    x8, x29, #0x10
0000000100004ac8    mov    x9, #0x0
0000000100004acc    adrp    x10, 1098 ; 0x10044e000
0000000100004ad0    add    x10, x10, #0x268
```
샘플 애플리케이션의 **Objective-C 세그먼트**를 인쇄하려면 다음을 사용할 수 있습니다:
```bash
otool -oV DVIA-v2
DVIA-v2:
Contents of (__DATA,__objc_classlist) section
00000001003dd5b8 0x1004423d0 _OBJC_CLASS_$_DDLog
isa        0x1004423a8 _OBJC_METACLASS_$_DDLog
superclass 0x0 _OBJC_CLASS_$_NSObject
cache      0x0 __objc_empty_cache
vtable     0x0
data       0x1003de748
flags          0x80
instanceStart  8
```
보다 간결한 Objective-C 코드를 얻기 위해 [**class-dump**](http://stevenygard.com/projects/class-dump/)를 사용할 수 있습니다:
```bash
class-dump some-app
//
//     Generated by class-dump 3.5 (64 bit).
//
//     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2013 by Steve Nygard.
//

#pragma mark Named Structures

struct CGPoint {
double _field1;
double _field2;
};

struct CGRect {
struct CGPoint _field1;
struct CGSize _field2;
};

struct CGSize {
double _field1;
double _field2;
};
```
그러나 바이너리를 분해하는 가장 좋은 옵션은 [**Hopper**](https://www.hopperapp.com/download.html?)와 [**IDA**](https://www.hex-rays.com/products/ida/support/download_freeware/)입니다.

## 데이터 저장

iOS가 장치에 데이터를 저장하는 방법에 대해 알아보려면 이 페이지를 읽으세요:

{{#ref}}
ios-basics.md
{{#endref}}

> [!WARNING]
> 다음 정보 저장 위치는 **애플리케이션 설치 직후**, **애플리케이션의 모든 기능을 확인한 후**, 심지어 **한 사용자에서 로그아웃하고 다른 사용자로 로그인한 후**에 확인해야 합니다.\
> 목표는 애플리케이션의 **보호되지 않은 민감한 정보**(비밀번호, 토큰), 현재 사용자 및 이전에 로그인한 사용자에 대한 정보를 찾는 것입니다.

### Plist

**plist** 파일은 **키-값 쌍**을 포함하는 구조화된 XML 파일입니다. 이는 지속적인 데이터를 저장하는 방법으로, 때때로 **이 파일에서 민감한 정보를 찾을 수 있습니다**. 앱을 설치한 후와 집중적으로 사용한 후에 이러한 파일을 확인하는 것이 좋습니다.

plist 파일에 데이터를 지속적으로 저장하는 가장 일반적인 방법은 **NSUserDefaults**를 사용하는 것입니다. 이 plist 파일은 **`Library/Preferences/<appBundleID>.plist`**의 앱 샌드박스 내에 저장됩니다.

[`NSUserDefaults`](https://developer.apple.com/documentation/foundation/nsuserdefaults) 클래스는 기본 시스템과 상호작용하기 위한 프로그래밍 인터페이스를 제공합니다. 기본 시스템은 애플리케이션이 **사용자 기본 설정**에 따라 동작을 사용자화할 수 있도록 합니다. `NSUserDefaults`에 의해 저장된 데이터는 애플리케이션 번들에서 볼 수 있습니다. 이 클래스는 **plist** **파일**에 **데이터**를 저장하지만, 소량의 데이터와 함께 사용되도록 설계되었습니다.

이 데이터는 신뢰할 수 있는 컴퓨터를 통해 더 이상 직접 접근할 수 없지만, **백업**을 수행하여 접근할 수 있습니다.

**`NSUserDefaults`**를 사용하여 저장된 정보를 **덤프**하려면 objection의 `ios nsuserdefaults get`을 사용하세요.

애플리케이션에서 사용되는 모든 plist를 찾으려면 `/private/var/mobile/Containers/Data/Application/{APPID}`에 접근하고 다음을 실행하세요:
```bash
find ./ -name "*.plist"
```
파일을 **XML 또는 이진 (bplist)** 형식에서 XML로 변환하기 위해, 운영 체제에 따라 다양한 방법이 있습니다:

**macOS 사용자용:** `plutil` 명령을 사용하세요. 이는 이 목적을 위해 설계된 macOS (10.2+)의 내장 도구입니다:
```bash
$ plutil -convert xml1 Info.plist
```
**리눅스 사용자용:** 먼저 `libplist-utils`를 설치한 다음, `plistutil`을 사용하여 파일을 변환하세요:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
**Objection 세션 내에서:** 모바일 애플리케이션을 분석하기 위해, 특정 명령어를 사용하여 plist 파일을 직접 변환할 수 있습니다:
```bash
ios plist cat /private/var/mobile/Containers/Data/Application/<Application-UUID>/Library/Preferences/com.some.package.app.plist
```
### Core Data

[`Core Data`](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/nsfetchedresultscontroller.html#//apple_ref/doc/uid/TP40001075-CH8-SW1)는 애플리케이션의 객체 모델 계층을 관리하기 위한 프레임워크입니다. [Core Data는 SQLite를 영구 저장소로 사용할 수 있습니다](https://cocoacasts.com/what-is-the-difference-between-core-data-and-sqlite/), 하지만 프레임워크 자체는 데이터베이스가 아닙니다.\
CoreData는 기본적으로 데이터를 암호화하지 않습니다. 그러나 CoreData에 추가 암호화 계층을 추가할 수 있습니다. 자세한 내용은 [GitHub Repo](https://github.com/project-imas/encrypted-core-data)를 참조하세요.

애플리케이션의 SQLite Core Data 정보는 경로 `/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support`에서 찾을 수 있습니다.

**SQLite를 열고 민감한 정보에 접근할 수 있다면, 잘못된 구성 설정을 발견한 것입니다.**
```objectivec:Code from iGoat
-(void)storeDetails {
AppDelegate * appDelegate = (AppDelegate *)(UIApplication.sharedApplication.delegate);

NSManagedObjectContext *context =[appDelegate managedObjectContext];

User *user = [self fetchUser];
if (user) {
return;
}
user = [NSEntityDescription insertNewObjectForEntityForName:@"User"
inManagedObjectContext:context];
user.email = CoreDataEmail;
user.password = CoreDataPassword;
NSError *error;
if (![context save:&error]) {
NSLog(@"Error in saving data: %@", [error localizedDescription]);

}else{
NSLog(@"data stored in core data");
}
}
```
### YapDatabase

[YapDatabase](https://github.com/yapstudios/YapDatabase)는 SQLite 위에 구축된 키/값 저장소입니다.\
Yap 데이터베이스는 sqlite 데이터베이스이므로 이전 섹션에서 제안된 명령을 사용하여 찾을 수 있습니다.

### Other SQLite Databases

응용 프로그램이 자체 sqlite 데이터베이스를 생성하는 것은 일반적입니다. 그들은 **민감한** **데이터**를 저장하고 이를 암호화하지 않을 수 있습니다. 따라서 응용 프로그램 디렉토리 내의 모든 데이터베이스를 확인하는 것이 항상 흥미롭습니다. 따라서 데이터가 저장된 응용 프로그램 디렉토리로 이동하십시오 (`/private/var/mobile/Containers/Data/Application/{APPID}`)
```bash
find ./ -name "*.sqlite" -or -name "*.db"
```
### Firebase 실시간 데이터베이스

개발자는 Firebase 실시간 데이터베이스를 통해 **NoSQL 클라우드 호스팅 데이터베이스** 내에서 **데이터를 저장하고 동기화**할 수 있습니다. JSON 형식으로 저장된 데이터는 모든 연결된 클라이언트에 실시간으로 동기화됩니다.

잘못 구성된 Firebase 데이터베이스를 확인하는 방법은 여기에서 찾을 수 있습니다:

{{#ref}}
../../network-services-pentesting/pentesting-web/buckets/firebase-database.md
{{#endref}}

### Realm 데이터베이스

[Realm Objective-C](https://realm.io/docs/objc/latest/) 및 [Realm Swift](https://realm.io/docs/swift/latest/)는 Apple에서 제공하지 않는 데이터 저장을 위한 강력한 대안을 제공합니다. 기본적으로, 그들은 **암호화되지 않은 데이터**를 저장하며, 특정 구성에 따라 암호화가 가능합니다.

데이터베이스는 다음 위치에 있습니다: `/private/var/mobile/Containers/Data/Application/{APPID}`. 이러한 파일을 탐색하려면 다음과 같은 명령을 사용할 수 있습니다:
```bash
iPhone:/private/var/mobile/Containers/Data/Application/A079DF84-726C-4AEA-A194-805B97B3684A/Documents root# ls
default.realm  default.realm.lock  default.realm.management/  default.realm.note|

$ find ./ -name "*.realm*"
```
이 데이터베이스 파일을 보려면 [**Realm Studio**](https://github.com/realm/realm-studio) 도구를 권장합니다.

Realm 데이터베이스 내에서 암호화를 구현하려면 다음 코드 스니펫을 사용할 수 있습니다:
```swift
// Open the encrypted Realm file where getKey() is a method to obtain a key from the Keychain or a server
let config = Realm.Configuration(encryptionKey: getKey())
do {
let realm = try Realm(configuration: config)
// Use the Realm as normal
} catch let error as NSError {
// If the encryption key is wrong, `error` will say that it's an invalid database
fatalError("Error opening realm: \(error)")
}
```
### Couchbase Lite Databases

[Couchbase Lite](https://github.com/couchbase/couchbase-lite-ios)는 **경량** 및 **임베디드** 데이터베이스 엔진으로 설명되며, **문서 지향** (NoSQL) 접근 방식을 따릅니다. **iOS** 및 **macOS**에 네이티브로 설계되어 데이터 동기화를 원활하게 수행할 수 있는 기능을 제공합니다.

장치에서 잠재적인 Couchbase 데이터베이스를 식별하려면 다음 디렉토리를 검사해야 합니다:
```bash
ls /private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support/
```
### 쿠키

iOS는 각 앱 폴더의 **`Library/Cookies/cookies.binarycookies`**에 앱의 쿠키를 저장합니다. 그러나 개발자는 때때로 **키체인**에 저장하기로 결정하는데, 이는 언급된 **쿠키 파일이 백업에서 접근 가능하기 때문입니다.**

쿠키 파일을 검사하려면 [**이 파이썬 스크립트**](https://github.com/mdegrazia/Safari-Binary-Cookie-Parser)를 사용하거나 objection의 **`ios cookies get`**을 사용할 수 있습니다.\
**또한 objection을 사용하여** 이러한 파일을 JSON 형식으로 변환하고 데이터를 검사할 수 있습니다.
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios cookies get --json
[
{
"domain": "highaltitudehacks.com",
"expiresDate": "2051-09-15 07:46:43 +0000",
"isHTTPOnly": "false",
"isSecure": "false",
"name": "username",
"path": "/",
"value": "admin123",
"version": "0"
}
]
```
### Cache

기본적으로 NSURLSession은 **Cache.db** 데이터베이스에 **HTTP 요청 및 응답**과 같은 데이터를 저장합니다. 이 데이터베이스는 토큰, 사용자 이름 또는 기타 민감한 정보가 캐시된 경우 **민감한 데이터**를 포함할 수 있습니다. 캐시된 정보를 찾으려면 앱의 데이터 디렉토리(`/var/mobile/Containers/Data/Application/<UUID>`)를 열고 `/Library/Caches/<Bundle Identifier>`로 이동합니다. **WebKit 캐시도 Cache.db** 파일에 저장됩니다. **Objection**은 `sqlite connect Cache.db` 명령어로 데이터베이스를 열고 상호작용할 수 있습니다. 이는 n**ormal SQLite 데이터베이스**입니다.

이 데이터를 캐싱하는 것을 **비활성화하는 것이 권장됩니다**, 요청 또는 응답에 민감한 정보가 포함될 수 있기 때문입니다. 아래의 목록은 이를 달성하는 다양한 방법을 보여줍니다:

1. 로그아웃 후 캐시된 응답을 제거하는 것이 권장됩니다. 이는 Apple에서 제공하는 [`removeAllCachedResponses`](https://developer.apple.com/documentation/foundation/urlcache/1417802-removeallcachedresponses) 메서드를 사용하여 수행할 수 있습니다. 이 메서드는 다음과 같이 호출할 수 있습니다:

`URLCache.shared.removeAllCachedResponses()`

이 메서드는 Cache.db 파일에서 모든 캐시된 요청 및 응답을 제거합니다.

2. 쿠키의 이점을 사용할 필요가 없다면 URLSession의 [.ephemeral](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral) 구성 속성을 사용하는 것이 좋습니다. 이는 쿠키와 캐시 저장을 비활성화합니다.

[Apple documentation](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral):

`An ephemeral session configuration object is similar to a default session configuration (see default), except that the corresponding session object doesn’t store caches, credential stores, or any session-related data to disk. Instead, session-related data is stored in RAM. The only time an ephemeral session writes data to disk is when you tell it to write the contents of a URL to a file.`

3. 캐시 정책을 [.notAllowed](https://developer.apple.com/documentation/foundation/urlcache/storagepolicy/notallowed)로 설정하여 캐시를 비활성화할 수도 있습니다. 이는 메모리나 디스크에 캐시를 저장하는 것을 비활성화합니다.

### Snapshots

홈 버튼을 누를 때마다 iOS는 **현재 화면의 스냅샷을 찍습니다**. 이는 애플리케이션으로의 전환을 훨씬 부드럽게 할 수 있게 해줍니다. 그러나 **민감한** **데이터**가 현재 화면에 존재하는 경우, 이는 **이미지**에 **저장됩니다** (이는 **재부팅** 후에도 **유지됩니다**). 이러한 스냅샷은 홈 화면을 두 번 탭하여 앱 간 전환 시에도 접근할 수 있습니다.

iPhone이 탈옥되지 않는 한, **공격자**는 이러한 스크린샷을 보려면 **장치**에 **차단되지 않은** **접근**이 필요합니다. 기본적으로 마지막 스냅샷은 애플리케이션의 샌드박스에 `Library/Caches/Snapshots/` 또는 `Library/SplashBoard/Snapshots` 폴더에 저장됩니다 (신뢰할 수 있는 컴퓨터는 iOX 7.0부터 파일 시스템에 접근할 수 없습니다).

이러한 나쁜 행동을 방지하는 한 가지 방법은 `ApplicationDidEnterBackground()` 함수를 사용하여 스냅샷을 찍기 전에 빈 화면을 표시하거나 민감한 데이터를 제거하는 것입니다.

다음은 기본 스크린샷을 설정하는 샘플 수정 방법입니다.

Swift:
```swift
private var backgroundImage: UIImageView?

func applicationDidEnterBackground(_ application: UIApplication) {
let myBanner = UIImageView(image: #imageLiteral(resourceName: "overlayImage"))
myBanner.frame = UIScreen.main.bounds
backgroundImage = myBanner
window?.addSubview(myBanner)
}

func applicationWillEnterForeground(_ application: UIApplication) {
backgroundImage?.removeFromSuperview()
}
```
Objective-C:
```
@property (UIImageView *)backgroundImage;

- (void)applicationDidEnterBackground:(UIApplication *)application {
UIImageView *myBanner = [[UIImageView alloc] initWithImage:@"overlayImage.png"];
self.backgroundImage = myBanner;
self.backgroundImage.bounds = UIScreen.mainScreen.bounds;
[self.window addSubview:myBanner];
}

- (void)applicationWillEnterForeground:(UIApplication *)application {
[self.backgroundImage removeFromSuperview];
}
```
이것은 애플리케이션이 백그라운드로 전환될 때마다 배경 이미지를 `overlayImage.png`로 설정합니다. 이는 `overlayImage.png`가 항상 현재 뷰를 덮어쓰므로 민감한 데이터 유출을 방지합니다.

### Keychain

iOS 키체인에 접근하고 관리하기 위해 [**Keychain-Dumper**](https://github.com/ptoomey3/Keychain-Dumper)와 같은 도구가 제공되며, 이는 탈옥된 장치에 적합합니다. 또한, [**Objection**](https://github.com/sensepost/objection)은 유사한 목적을 위해 `ios keychain dump` 명령을 제공합니다.

#### **자격 증명 저장**

**NSURLCredential** 클래스는 NSUserDefaults나 다른 래퍼를 우회하여 민감한 정보를 키체인에 직접 저장하는 데 이상적입니다. 로그인 후 자격 증명을 저장하기 위해 다음 Swift 코드를 사용합니다:
```swift
NSURLCredential *credential;
credential = [NSURLCredential credentialWithUser:username password:password persistence:NSURLCredentialPersistencePermanent];
[[NSURLCredentialStorage sharedCredentialStorage] setCredential:credential forProtectionSpace:self.loginProtectionSpace];
```
이 저장된 자격 증명을 추출하기 위해 Objection의 명령 `ios nsurlcredentialstorage dump`가 사용됩니다.

## **사용자 정의 키보드 및 키보드 캐시**

iOS 8.0 이후로 사용자는 **설정 > 일반 > 키보드 > 키보드**에서 관리할 수 있는 사용자 정의 키보드 확장을 설치할 수 있습니다. 이러한 키보드는 확장된 기능을 제공하지만, 키스트로크 로깅 및 외부 서버로 데이터 전송의 위험이 있습니다. 사용자는 네트워크 접근이 필요한 키보드에 대해 알림을 받습니다. 앱은 민감한 정보 입력을 위해 사용자 정의 키보드 사용을 제한해야 합니다.

**보안 권장 사항:**

- 보안을 강화하기 위해 서드파티 키보드를 비활성화하는 것이 좋습니다.
- 기본 iOS 키보드의 자동 수정 및 자동 제안 기능이 민감한 정보를 `Library/Keyboard/{locale}-dynamic-text.dat` 또는 `/private/var/mobile/Library/Keyboard/dynamic-text.dat`에 캐시 파일로 저장할 수 있으므로 주의해야 합니다. 이러한 캐시 파일은 민감한 데이터를 위해 정기적으로 확인해야 합니다. 캐시된 데이터를 지우기 위해 **설정 > 일반 > 초기화 > 키보드 사전 초기화**를 통해 키보드 사전을 재설정하는 것이 권장됩니다.
- 네트워크 트래픽을 가로채면 사용자 정의 키보드가 원격으로 키스트로크를 전송하는지 여부를 확인할 수 있습니다.

### **텍스트 필드 캐싱 방지**

[UITextInputTraits 프로토콜](https://developer.apple.com/reference/uikit/uitextinputtraits)은 민감한 정보 캐싱을 방지하는 데 필수적인 자동 수정 및 보안 텍스트 입력을 관리하는 속성을 제공합니다. 예를 들어, 자동 수정을 비활성화하고 보안 텍스트 입력을 활성화하는 것은 다음과 같이 수행할 수 있습니다:
```objectivec
textObject.autocorrectionType = UITextAutocorrectionTypeNo;
textObject.secureTextEntry = YES;
```
또한, 개발자는 비밀번호 및 PIN과 같은 민감한 정보를 입력하는 텍스트 필드에서 캐싱을 비활성화하도록 `autocorrectionType`을 `UITextAutocorrectionTypeNo`로 설정하고 `secureTextEntry`를 `YES`로 설정해야 합니다.
```objectivec
UITextField *textField = [[UITextField alloc] initWithFrame:frame];
textField.autocorrectionType = UITextAutocorrectionTypeNo;
```
## **로그**

코드 디버깅은 종종 **로깅**을 포함합니다. **로그에 민감한 정보가 포함될 수 있는 위험**이 있습니다. 이전에는 iOS 6 및 이전 버전에서 로그가 모든 앱에 접근 가능하여 민감한 데이터 유출의 위험이 있었습니다. **현재는 애플리케이션이 자신의 로그만 접근할 수 있도록 제한됩니다**.

이러한 제한에도 불구하고 **잠금 해제된 장치에 물리적으로 접근할 수 있는 공격자**는 여전히 장치를 컴퓨터에 연결하고 **로그를 읽음으로써 이를 악용할 수 있습니다**. 로그는 앱이 제거된 후에도 디스크에 남아 있다는 점에 유의해야 합니다.

위험을 완화하기 위해 **앱과 철저히 상호작용**하고 모든 기능과 입력을 탐색하여 민감한 정보가 우연히 로깅되지 않도록 하는 것이 좋습니다.

앱의 소스 코드를 검토할 때 잠재적인 유출을 위해 `NSLog`, `NSAssert`, `NSCAssert`, `fprintf`와 같은 키워드를 사용하여 **미리 정의된** 및 **사용자 정의 로깅 문**을 찾아보세요. 또한 사용자 정의 구현을 위한 `Logging` 또는 `Logfile`의 언급도 확인하세요.

### **시스템 로그 모니터링**

앱은 민감할 수 있는 다양한 정보를 로깅합니다. 이러한 로그를 모니터링하기 위해 다음과 같은 도구와 명령을 사용합니다:
```bash
idevice_id --list   # To find the device ID
idevicesyslog -u <id> (| grep <app>)   # To capture the device logs
```
유용합니다. 또한, **Xcode**는 콘솔 로그를 수집하는 방법을 제공합니다:

1. Xcode를 엽니다.
2. iOS 장치를 연결합니다.
3. **Window** -> **Devices and Simulators**로 이동합니다.
4. 장치를 선택합니다.
5. 조사 중인 문제를 트리거합니다.
6. **Open Console** 버튼을 사용하여 새 창에서 로그를 봅니다.

더 고급 로그를 위해, 장치 셸에 연결하고 **socat**을 사용하면 실시간 로그 모니터링이 가능합니다:
```bash
iPhone:~ root# socat - UNIX-CONNECT:/var/run/lockdown/syslog.sock
```
로그 활동을 관찰하기 위한 명령어가 뒤따르며, 이는 문제 진단이나 로그에서 잠재적인 데이터 유출을 식별하는 데 매우 유용할 수 있습니다.

## 백업

**자동 백업 기능**은 iOS에 통합되어 있으며, iTunes(최대 macOS Catalina), Finder(최신 macOS Catalina부터) 또는 iCloud를 통해 장치 데이터 복사본을 생성할 수 있습니다. 이러한 백업은 Apple Pay 세부정보 및 Touch ID 구성과 같은 매우 민감한 요소를 제외한 거의 모든 장치 데이터를 포함합니다.

### 보안 위험

**설치된 앱 및 해당 데이터**가 백업에 포함되는 것은 잠재적인 **데이터 유출** 문제와 **백업 수정이 앱 기능을 변경할 수 있는 위험**을 제기합니다. 이러한 위험을 완화하기 위해 **어떤 앱의 디렉토리나 하위 디렉토리 내에 민감한 정보를 평문으로 저장하지 않는 것이 좋습니다.**

### 백업에서 파일 제외하기

`Documents/` 및 `Library/Application Support/`의 파일은 기본적으로 백업됩니다. 개발자는 `NSURL setResourceValue:forKey:error:`를 사용하여 `NSURLIsExcludedFromBackupKey`와 함께 특정 파일이나 디렉토리를 백업에서 제외할 수 있습니다. 이 관행은 민감한 데이터가 백업에 포함되지 않도록 보호하는 데 중요합니다.

### 취약점 테스트

앱의 백업 보안을 평가하기 위해, 먼저 Finder를 사용하여 **백업을 생성**한 다음, [Apple의 공식 문서](https://support.apple.com/en-us/HT204215)의 안내에 따라 이를 찾습니다. 백업에서 민감한 데이터나 앱 동작에 영향을 줄 수 있는 구성을 분석합니다.

민감한 정보는 명령줄 도구나 [iMazing](https://imazing.com)과 같은 애플리케이션을 사용하여 찾을 수 있습니다. 암호화된 백업의 경우, 백업의 루트에 있는 "Manifest.plist" 파일에서 "IsEncrypted" 키를 확인하여 암호화가 존재하는지 확인할 수 있습니다.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
...
<key>Date</key>
<date>2021-03-12T17:43:33Z</date>
<key>IsEncrypted</key>
<true/>
...
</plist>
```
암호화된 백업을 처리하기 위해 [DinoSec의 GitHub 저장소](https://github.com/dinosec/iphone-dataprotection/tree/master/python_scripts)에서 제공하는 Python 스크립트, 예를 들어 **backup_tool.py**와 **backup_passwd.py**가 유용할 수 있으며, 최신 iTunes/Finder 버전과의 호환성을 위해 조정이 필요할 수 있습니다. [**iOSbackup** 도구](https://pypi.org/project/iOSbackup/)는 비밀번호로 보호된 백업 내 파일에 접근하는 또 다른 옵션입니다.

### 앱 동작 수정

백업 수정을 통해 앱 동작을 변경하는 예는 [Bither 비트코인 지갑 앱](https://github.com/bither/bither-ios)에서 볼 수 있으며, 여기서 UI 잠금 PIN은 **pin_code** 키 아래 `net.bither.plist`에 저장됩니다. 이 키를 plist에서 제거하고 백업을 복원하면 PIN 요구 사항이 제거되어 무제한 접근이 가능합니다.

## 민감한 데이터에 대한 메모리 테스트 요약

애플리케이션의 메모리에 저장된 민감한 정보를 처리할 때, 이 데이터의 노출 시간을 제한하는 것이 중요합니다. 메모리 내용을 조사하는 두 가지 주요 접근 방식이 있습니다: **메모리 덤프 생성**과 **실시간 메모리 분석**. 두 방법 모두 덤프 과정이나 분석 중에 중요한 데이터를 놓칠 가능성 등 도전 과제가 있습니다.

## **메모리 덤프 검색 및 분석**

탈옥된 장치와 비탈옥 장치 모두에서 [objection](https://github.com/sensepost/objection) 및 [Fridump](https://github.com/Nightbringer21/fridump)와 같은 도구를 사용하여 앱의 프로세스 메모리를 덤프할 수 있습니다. 덤프된 데이터를 분석하려면 검색하려는 정보의 성격에 따라 다양한 도구가 필요합니다.

메모리 덤프에서 문자열을 추출하기 위해 `strings` 또는 `rabin2 -zz`와 같은 명령을 사용할 수 있습니다:
```bash
# Extracting strings using strings command
$ strings memory > strings.txt

# Extracting strings using rabin2
$ rabin2 -ZZ memory > strings.txt
```
보다 자세한 분석을 위해 특정 데이터 유형이나 패턴을 검색하는 것을 포함하여, **radare2**는 광범위한 검색 기능을 제공합니다:
```bash
$ r2 <name_of_your_dump_file>
[0x00000000]> /?
...
```
## **런타임 메모리 분석**

**r2frida**는 메모리 덤프 없이 앱의 메모리를 실시간으로 검사할 수 있는 강력한 대안을 제공합니다. 이 도구는 실행 중인 애플리케이션의 메모리에서 직접 검색 명령을 실행할 수 있게 해줍니다:
```bash
$ r2 frida://usb//<name_of_your_app>
[0x00000000]> /\ <search_command>
```
## 깨진 암호화

### 열쇠 관리 프로세스의 부족

일부 개발자는 민감한 데이터를 로컬 스토리지에 저장하고 코드에 하드코딩되거나 예측 가능한 키로 암호화합니다. 이는 역공학을 통해 공격자가 기밀 정보를 추출할 수 있으므로 해서는 안 됩니다.

### 안전하지 않거나 사용 중지된 알고리즘의 사용

개발자는 **사용 중지된 알고리즘**을 사용하여 **검사**를 수행하거나 **데이터를 저장**하거나 **전송**해서는 안 됩니다. 이러한 알고리즘의 예로는 RC4, MD4, MD5, SHA1 등이 있습니다. 예를 들어 **해시**를 사용하여 비밀번호를 저장하는 경우, 소금을 사용하여 해시 브루트 포스 **저항**이 있는 해시를 사용해야 합니다.

### 확인

주요 확인 사항은 코드에서 **하드코딩된** 비밀번호/비밀을 찾을 수 있는지, 또는 그것들이 **예측 가능**한지, 그리고 코드가 어떤 종류의 **약한** **암호화** 알고리즘을 사용하고 있는지 확인하는 것입니다.

일부 **암호** **라이브러리**를 자동으로 **모니터링**할 수 있다는 점은 흥미롭습니다. **objection**을 사용하여:
```swift
ios monitor crypt
```
자세한 정보는 iOS 암호화 API 및 라이브러리에 대해 [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography)에서 확인하세요.

## 로컬 인증

**로컬 인증**은 특히 원격 엔드포인트에 대한 접근을 암호화 방법으로 보호하는 데 중요한 역할을 합니다. 여기서 핵심은 적절한 구현이 없으면 로컬 인증 메커니즘이 우회될 수 있다는 것입니다.

Apple의 [**로컬 인증 프레임워크**](https://developer.apple.com/documentation/localauthentication)와 [**키체인**](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html)은 사용자 인증 대화 상자를 용이하게 하고 비밀 데이터를 안전하게 처리하기 위한 강력한 API를 제공합니다. Secure Enclave는 Touch ID에 대한 지문 ID를 보호하며, Face ID는 생체 데이터를 손상시키지 않고 얼굴 인식에 의존합니다.

Touch ID/Face ID를 통합하기 위해 개발자는 두 가지 API 선택이 있습니다:

- **`LocalAuthentication.framework`**: 생체 데이터에 접근하지 않고 고수준 사용자 인증을 위한 것입니다.
- **`Security.framework`**: 생체 인증으로 비밀 데이터를 보호하는 저수준 키체인 서비스 접근을 위한 것입니다. 다양한 [오픈 소스 래퍼](https://www.raywenderlich.com/147308/secure-ios-user-data-keychain-touch-id)가 키체인 접근을 간소화합니다.

> [!CAUTION]
> 그러나 `LocalAuthentication.framework`와 `Security.framework` 모두 주로 인증 프로세스를 위한 데이터를 전송하지 않고 불리언 값만 반환하므로 우회에 취약한 취약점을 가지고 있습니다(참조: [Don't touch me that way, by David Lindner et al](https://www.youtube.com/watch?v=XhXIHVGCFFM)).

### 로컬 인증 구현

사용자에게 인증을 요청하려면 개발자는 **`LAContext`** 클래스 내의 **`evaluatePolicy`** 메서드를 사용해야 하며, 다음 중에서 선택할 수 있습니다:

- **`deviceOwnerAuthentication`**: Touch ID 또는 장치 암호를 요청하며, 둘 다 활성화되지 않은 경우 실패합니다.
- **`deviceOwnerAuthenticationWithBiometrics`**: Touch ID만 요청합니다.

성공적인 인증은 **`evaluatePolicy`**에서 불리언 반환 값으로 표시되며, 이는 잠재적인 보안 결함을 강조합니다.

### 키체인을 이용한 로컬 인증

iOS 앱에서 **로컬 인증**을 구현하는 것은 인증 토큰과 같은 비밀 데이터를 안전하게 저장하기 위해 **키체인 API**를 사용하는 것을 포함합니다. 이 과정은 사용자가 자신의 장치 암호 또는 Touch ID와 같은 생체 인증을 사용하여 데이터에만 접근할 수 있도록 보장합니다.

키체인은 `SecAccessControl` 속성을 사용하여 항목을 설정할 수 있는 기능을 제공하며, 이는 사용자가 Touch ID 또는 장치 암호를 통해 성공적으로 인증할 때까지 항목에 대한 접근을 제한합니다. 이 기능은 보안을 강화하는 데 중요합니다.

아래는 Swift와 Objective-C에서 키체인에 문자열을 저장하고 검색하는 방법을 보여주는 코드 예제입니다. 이 예제는 Touch ID 인증을 요구하도록 접근 제어를 설정하고, 데이터가 설정된 장치에서만 접근 가능하도록 보장하는 방법을 구체적으로 보여줍니다.

{{#tabs}}
{{#tab name="Swift"}}
```swift
// From https://github.com/mufambisi/owasp-mstg/blob/master/Document/0x06f-Testing-Local-Authentication.md

// 1. create AccessControl object that will represent authentication settings

var error: Unmanaged<CFError>?

guard let accessControl = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
SecAccessControlCreateFlags.biometryCurrentSet,
&error) else {
// failed to create AccessControl object

return
}

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute

var query: [String: Any] = [:]

query[kSecClass as String] = kSecClassGenericPassword
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecAttrAccount as String] = "OWASP Account" as CFString
query[kSecValueData as String] = "test_strong_password".data(using: .utf8)! as CFData
query[kSecAttrAccessControl as String] = accessControl

// 3. save item

let status = SecItemAdd(query as CFDictionary, nil)

if status == noErr {
// successfully saved
} else {
// error while saving
}
```
{{#endtab}}

{{#tab name="Objective-C"}}
```objectivec
// 1. create AccessControl object that will represent authentication settings
CFErrorRef *err = nil;

SecAccessControlRef sacRef = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
kSecAccessControlUserPresence,
err);

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute
NSDictionary* query = @{
(_ _bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecAttrAccount: @"OWASP Account",
(__bridge id)kSecValueData: [@"test_strong_password" dataUsingEncoding:NSUTF8StringEncoding],
(__bridge id)kSecAttrAccessControl: (__bridge_transfer id)sacRef
};

// 3. save item
OSStatus status = SecItemAdd((__bridge CFDictionaryRef)query, nil);

if (status == noErr) {
// successfully saved
} else {
// error while saving
}
```
{{#endtab}}
{{#endtabs}}

이제 키체인에서 저장된 항목을 요청할 수 있습니다. 키체인 서비스는 사용자에게 인증 대화 상자를 표시하고 적절한 지문이 제공되었는지 여부에 따라 데이터 또는 nil을 반환합니다.

{{#tabs}}
{{#tab name="Swift"}}
```swift
// 1. define query
var query = [String: Any]()
query[kSecClass as String] = kSecClassGenericPassword
query[kSecReturnData as String] = kCFBooleanTrue
query[kSecAttrAccount as String] = "My Name" as CFString
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecUseOperationPrompt as String] = "Please, pass authorisation to enter this area" as CFString

// 2. get item
var queryResult: AnyObject?
let status = withUnsafeMutablePointer(to: &queryResult) {
SecItemCopyMatching(query as CFDictionary, UnsafeMutablePointer($0))
}

if status == noErr {
let password = String(data: queryResult as! Data, encoding: .utf8)!
// successfully received password
} else {
// authorization not passed
}
```
{{#endtab}}

{{#tab name="Objective-C"}}
```objectivec
// 1. define query
NSDictionary *query = @{(__bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecReturnData: @YES,
(__bridge id)kSecAttrAccount: @"My Name1",
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecUseOperationPrompt: @"Please, pass authorisation to enter this area" };

// 2. get item
CFTypeRef queryResult = NULL;
OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)query, &queryResult);

if (status == noErr){
NSData* resultData = ( __bridge_transfer NSData* )queryResult;
NSString* password = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding];
NSLog(@"%@", password);
} else {
NSLog(@"Something went wrong");
}
```
{{#endtab}}
{{#endtabs}}

### 탐지

앱에서 프레임워크의 사용은 앱 바이너리의 공유 동적 라이브러리 목록을 분석하여 감지할 수 있습니다. 이는 `otool`을 사용하여 수행할 수 있습니다:
```bash
$ otool -L <AppName>.app/<AppName>
```
앱에서 `LocalAuthentication.framework`가 사용되면 출력에는 다음 두 줄이 모두 포함됩니다 (기억하세요, `LocalAuthentication.framework`는 내부적으로 `Security.framework`를 사용합니다):
```bash
/System/Library/Frameworks/LocalAuthentication.framework/LocalAuthentication
/System/Library/Frameworks/Security.framework/Security
```
`Security.framework`가 사용되는 경우, 두 번째 것만 표시됩니다.

### 로컬 인증 프레임워크 우회

#### **Objection**

[이 GitHub 페이지](https://github.com/sensepost/objection/wiki/Understanding-the-iOS-Biometrics-Bypass)에 위치한 **Objection Biometrics Bypass**를 통해 **LocalAuthentication** 메커니즘을 극복할 수 있는 기술이 제공됩니다. 이 접근 방식의 핵심은 **Frida**를 활용하여 `evaluatePolicy` 함수를 조작하여 실제 인증 성공 여부와 관계없이 항상 `True` 결과를 반환하도록 하는 것입니다. 이는 결함이 있는 생체 인증 프로세스를 우회하는 데 특히 유용합니다.

이 우회를 활성화하기 위해 다음 명령이 사용됩니다:
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios ui biometrics_bypass
(agent) Registering job 3mhtws9x47q. Type: ios-biometrics-disable
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # (agent) [3mhtws9x47q] Localized Reason for auth requirement: Please authenticate yourself
(agent) [3mhtws9x47q] OS authentication response: false
(agent) [3mhtws9x47q] Marking OS response as True instead
(agent) [3mhtws9x47q] Biometrics bypass hook complete
```
이 명령은 Objection이 `evaluatePolicy` 검사의 결과를 `True`로 효과적으로 변경하는 작업을 등록하는 일련의 과정을 시작합니다.

#### Frida

**`evaluatePolicy`**의 사용 예시로 [DVIA-v2 애플리케이션](https://github.com/prateek147/DVIA-v2):
```swift
+(void)authenticateWithTouchID {
LAContext *myContext = [[LAContext alloc] init];
NSError *authError = nil;
NSString *myLocalizedReasonString = @"Please authenticate yourself";

if ([myContext canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&authError]) {
[myContext evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics
localizedReason:myLocalizedReasonString
reply:^(BOOL success, NSError *error) {
if (success) {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Successful" withTitle:@"Success"];
});
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Failed !" withTitle:@"Error"];
});
}
}];
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Your device doesn't support Touch ID or you haven't configured Touch ID authentication on your device" withTitle:@"Error"];
});
}
}
```
로컬 인증의 **우회**를 달성하기 위해 Frida 스크립트가 작성되었습니다. 이 스크립트는 **evaluatePolicy** 검사를 대상으로 하여, 콜백을 가로채서 **success=1**을 반환하도록 합니다. 콜백의 동작을 변경함으로써 인증 검사를 효과적으로 우회합니다.

아래 스크립트는 **evaluatePolicy** 메서드의 결과를 수정하기 위해 주입됩니다. 콜백의 결과를 항상 성공을 나타내도록 변경합니다.
```swift
// from https://securitycafe.ro/2022/09/05/mobile-pentesting-101-bypassing-biometric-authentication/
if(ObjC.available) {
console.log("Injecting...");
var hook = ObjC.classes.LAContext["- evaluatePolicy:localizedReason:reply:"];
Interceptor.attach(hook.implementation, {
onEnter: function(args) {
var block = new ObjC.Block(args[4]);
const callback = block.implementation;
block.implementation = function (error, value)  {

console.log("Changing the result value to true")
const result = callback(1, null);
return result;
};
},
});
} else {
console.log("Objective-C Runtime is not available!");
}
```
Frida 스크립트를 주입하고 생체 인증을 우회하기 위해 다음 명령어가 사용됩니다:
```bash
frida -U -f com.highaltitudehacks.DVIAswiftv2 --no-pause -l fingerprint-bypass-ios.js
```
## 민감한 기능 노출을 통한 IPC

### 사용자 정의 URI 핸들러 / 딥링크 / 사용자 정의 스킴

{{#ref}}
ios-custom-uri-handlers-deeplinks-custom-schemes.md
{{#endref}}

### 유니버설 링크

{{#ref}}
ios-universal-links.md
{{#endref}}

### UIActivity 공유

{{#ref}}
ios-uiactivity-sharing.md
{{#endref}}

### UIPasteboard

{{#ref}}
ios-uipasteboard.md
{{#endref}}

### 앱 확장

{{#ref}}
ios-app-extensions.md
{{#endref}}

### WebViews

{{#ref}}
ios-webviews.md
{{#endref}}

### 직렬화 및 인코딩

{{#ref}}
ios-serialisation-and-encoding.md
{{#endref}}

## 네트워크 통신

암호화 **없이** 통신이 발생하지 않는지 확인하는 것이 중요하며, 또한 애플리케이션이 서버의 TLS 인증서를 올바르게 **검증하고 있는지** 확인해야 합니다.\
이러한 문제를 확인하기 위해 **Burp**와 같은 프록시를 사용할 수 있습니다:

{{#ref}}
burp-configuration-for-ios.md
{{#endref}}

### 호스트 이름 확인

TLS 인증서를 검증할 때 일반적인 문제 중 하나는 인증서가 **신뢰할 수 있는** **CA**에 의해 서명되었는지 확인하는 것이지만, **호스트 이름**이 접근 중인 호스트 이름인지 **확인하지 않는** 것입니다.\
이 문제를 Burp를 사용하여 확인하기 위해, iPhone에서 Burp CA를 신뢰한 후, **다른 호스트 이름에 대해 Burp로 새 인증서를 생성하고** 사용할 수 있습니다. 애플리케이션이 여전히 작동하면, 취약점이 있는 것입니다.

### 인증서 고정

애플리케이션이 SSL Pinning을 올바르게 사용하고 있다면, 애플리케이션은 예상되는 인증서일 때만 작동합니다. 애플리케이션을 테스트할 때 **Burp가 자신의 인증서를 제공하므로 문제가 될 수 있습니다.**\
탈옥된 장치 내에서 이 보호를 우회하기 위해 [**SSL Kill Switch**](https://github.com/nabla-c0d3/ssl-kill-switch2)를 설치하거나 [**Burp Mobile Assistant**](https://portswigger.net/burp/documentation/desktop/mobile/config-ios-device)를 설치할 수 있습니다.

또한 **objection의** `ios sslpinning disable`을 사용할 수 있습니다.

## 기타

- **`/System/Library`**에서 시스템 애플리케이션에서 사용하는 프레임워크를 찾을 수 있습니다.
- App Store에서 사용자가 설치한 애플리케이션은 **`/User/Applications`**에 위치합니다.
- **`/User/Library`**는 사용자 수준 애플리케이션에 의해 저장된 데이터를 포함합니다.
- 애플리케이션 내에 저장된 노트를 읽기 위해 **`/User/Library/Notes/notes.sqlite`**에 접근할 수 있습니다.
- 설치된 애플리케이션의 폴더(**`/User/Applications/<APP ID>/`**) 내에서 몇 가지 흥미로운 파일을 찾을 수 있습니다:
- **`iTunesArtwork`**: 앱에서 사용하는 아이콘
- **`iTunesMetadata.plist`**: App Store에서 사용되는 앱 정보
- **`/Library/*`**: 환경 설정 및 캐시를 포함합니다. **`/Library/Cache/Snapshots/*`**에서 애플리케이션을 백그라운드로 전송하기 전에 수행된 스냅샷을 찾을 수 있습니다.

### 핫 패칭/강제 업데이트

개발자는 애플리케이션을 App Store에 재제출하고 승인을 기다리지 않고도 **모든 설치를 즉시 패치할 수 있습니다.**\
이를 위해 일반적으로 [**JSPatch**](https://github.com/bang590/JSPatch)**가 사용됩니다.** 그러나 [Siren](https://github.com/ArtSabintsev/Siren) 및 [react-native-appstore-version-checker](https://www.npmjs.com/package/react-native-appstore-version-checker)와 같은 다른 옵션도 있습니다.\
**이는 악의적인 제3자 SDK에 의해 남용될 수 있는 위험한 메커니즘이므로, 자동 업데이트에 사용되는 방법(있는 경우)을 확인하고 테스트하는 것이 좋습니다.** 이를 위해 애플리케이션의 이전 버전을 다운로드해 볼 수 있습니다.

### 제3자

**3rd party SDKs**와 관련된 중요한 도전 과제는 **기능에 대한 세부적인 제어 부족**입니다. 개발자는 SDK를 통합하고 모든 기능을 수용할 것인지, 또는 그 이점을 완전히 포기할 것인지 선택해야 합니다. 종종 개발자는 이러한 SDK 내의 취약점을 스스로 패치할 수 없습니다. 또한, SDK가 커뮤니티 내에서 신뢰를 얻으면서 일부는 악성 코드를 포함할 수 있습니다.

제3자 SDK가 제공하는 서비스에는 사용자 행동 추적, 광고 표시 또는 사용자 경험 향상이 포함될 수 있습니다. 그러나 이는 개발자가 이러한 라이브러리에서 실행되는 코드를 완전히 인식하지 못할 수 있으므로 잠재적인 개인 정보 및 보안 위험을 초래합니다. 제3자 서비스와 공유되는 정보는 필요한 것만으로 제한하고 민감한 데이터가 노출되지 않도록 하는 것이 중요합니다.

제3자 서비스의 구현은 일반적으로 독립형 라이브러리 또는 전체 SDK의 두 가지 형태로 제공됩니다. 사용자 개인 정보를 보호하기 위해 이러한 서비스와 공유되는 모든 데이터는 **익명화**되어 개인 식별 정보(PII)의 공개를 방지해야 합니다.

애플리케이션이 사용하는 라이브러리를 식별하기 위해 **`otool`** 명령을 사용할 수 있습니다. 이 도구는 애플리케이션과 사용되는 각 공유 라이브러리에 대해 실행되어 추가 라이브러리를 발견해야 합니다.
```bash
otool -L <application_path>
```
## **참고자료 및 추가 리소스**

- [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering)
- [iOS & Mobile App Pentesting - INE](https://my.ine.com/CyberSecurity/courses/089d060b/ios-mobile-app-pentesting)
- [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/)
- [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/)
- [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/)
- [https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage](https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage)
- [https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way](https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053)
- [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060)
- [https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/](https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064](https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064)
- [https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc](https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054)
- [https://github.com/ivRodriguezCA/RE-iOS-Apps/](https://github.com/ivRodriguezCA/RE-iOS-Apps/) IOS 무료 과정([https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/](https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/))
- [https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577](https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577)
- [https://www.slideshare.net/RyanISI/ios-appsecurityminicourse](https://www.slideshare.net/RyanISI/ios-appsecurityminicourse)
- [https://github.com/prateek147/DVIA](https://github.com/prateek147/DVIA)
- [https://github.com/prateek147/DVIA-v2](https://github.com/prateek147/DVIA-v2)
- [https://github.com/OWASP/MSTG-Hacking-Playground%20](https://github.com/OWASP/MSTG-Hacking-Playground)
- OWASP iGoat [_https://github.com/OWASP/igoat_](https://github.com/OWASP/igoat) <<< Objective-C 버전 [_https://github.com/OWASP/iGoat-Swift_](https://github.com/OWASP/iGoat-Swift) <<< Swift 버전
- [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
- [https://github.com/nabla-c0d3/ssl-kill-switch2](https://github.com/nabla-c0d3/ssl-kill-switch2)


{{#include ../../banners/hacktricks-training.md}}
