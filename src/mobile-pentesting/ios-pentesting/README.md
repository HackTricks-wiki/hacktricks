# iOS Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Noções Básicas do iOS


{{#ref}}
ios-basics.md
{{#endref}}

## Ambiente de Testes

Nesta página você pode encontrar informações sobre o **iOS simulator**, **emulators** e **jailbreaking:**


{{#ref}}
ios-testing-environment.md
{{#endref}}

## Análise Inicial

### Operações Básicas de Testes em iOS

Durante os testes **várias operações serão sugeridas** (conectar ao dispositivo, ler/gravar/enviar/baixar arquivos, usar algumas ferramentas...). Portanto, se você não sabe como executar alguma dessas ações, por favor, **comece lendo a página**:


{{#ref}}
basic-ios-testing-operations.md
{{#endref}}

> [!TIP]
> Para os próximos passos **o app deve estar instalado** no dispositivo e já deve ter obtido o **IPA file** da aplicação.\
> Leia a página [Basic iOS Testing Operations](basic-ios-testing-operations.md) para aprender como fazer isso.

### Análise Estática Básica

Alguns decompiladores interessantes para arquivos iOS - IPA:

- [https://github.com/LaurieWired/Malimite](https://github.com/LaurieWired/Malimite)
- [https://ghidra-sre.org/](https://ghidra-sre.org/)

É recomendado usar a ferramenta [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) para realizar uma Análise Estática automática do arquivo IPA.

Identificação das **proteções presentes no binário**:

- **PIE (Position Independent Executable)**: Quando ativado, a aplicação é carregada em um endereço de memória aleatório a cada inicialização, tornando mais difícil prever seu endereço inicial de memória.

```bash
otool -hv <app-binary> | grep PIE   # It should include the PIE flag
```

- **Stack Canaries**: Para validar a integridade da pilha, um valor ‘canary’ é colocado na pilha antes de chamar uma função e é validado novamente quando a função termina.

```bash
otool -I -v <app-binary> | grep stack_chk   # It should include the symbols: stack_chk_guard and stack_chk_fail
```

- **ARC (Automatic Reference Counting)**: Para prevenir falhas comuns de corrupção de memória

```bash
otool -I -v <app-binary> | grep objc_release   # It should include the _objc_release symbol
```

- **Encrypted Binary**: O binário deve estar criptografado

```bash
otool -arch all -Vl <app-binary> | grep -A5 LC_ENCRYPT   # The cryptid should be 1
```

Identificação de Funções Sensíveis/Inseguras

- **Weak Hashing Algorithms**

```bash
# On the iOS device
otool -Iv <app> | grep -w "_CC_MD5"
otool -Iv <app> | grep -w "_CC_SHA1"

# On linux
grep -iER "_CC_MD5"
grep -iER "_CC_SHA1"
```

- **Insecure Random Functions**

```bash
# On the iOS device
otool -Iv <app> | grep -w "_random"
otool -Iv <app> | grep -w "_srand"
otool -Iv <app> | grep -w "_rand"

# On linux
grep -iER "_random"
grep -iER "_srand"
grep -iER "_rand"
```

- **Insecure ‘Malloc’ Function**

```bash
# On the iOS device
otool -Iv <app> | grep -w "_malloc"

# On linux
grep -iER "_malloc"
```

- **Insecure and Vulnerable Functions**

```bash
# On the iOS device
otool -Iv <app> | grep -w "_gets"
otool -Iv <app> | grep -w "_memcpy"
otool -Iv <app> | grep -w "_strncpy"
otool -Iv <app> | grep -w "_strlen"
otool -Iv <app> | grep -w "_vsnprintf"
otool -Iv <app> | grep -w "_sscanf"
otool -Iv <app> | grep -w "_strtok"
otool -Iv <app> | grep -w "_alloca"
otool -Iv <app> | grep -w "_sprintf"
otool -Iv <app> | grep -w "_printf"
otool -Iv <app> | grep -w "_vsprintf"

# On linux
grep -R "_gets"
grep -iER "_memcpy"
grep -iER "_strncpy"
grep -iER "_strlen"
grep -iER "_vsnprintf"
grep -iER "_sscanf"
grep -iER "_strtok"
grep -iER "_alloca"
grep -iER "_sprintf"
grep -iER "_printf"
grep -iER "_vsprintf"
```

#### Métodos Comuns de Detecção de Jailbreak

- **File System Checks**: Procure pela presença de arquivos e diretórios comuns de jailbreak, como `/Applications/Cydia.app` ou `/Library/MobileSubstrate/MobileSubstrate.dylib`.
- **Sandbox Violations**: Tente acessar áreas restritas do sistema de arquivos, que devem estar bloqueadas em dispositivos sem jailbreak.
- **API Checks**: Verifique se é possível usar chamadas proibidas como `fork()` para criar um processo filho ou `system()` para ver se /bin/sh existe.
- **Process Checks**: Monitore a presença de processos conhecidos relacionados a jailbreak, como `Cydia`, `Substrate`, ou `ssh`.
- **Kernel Exploits**: Verifique a presença de exploits de kernel que são comumente usados em jailbreaks.
- **Environment Variables**: Inspecione variáveis de ambiente em busca de sinais de jailbreak, como `DYLD_INSERT_LIBRARIES`.
- **Libraries Check**: Verifique as libs que estão carregadas no processo do app.
- **Check schemes**: Como `canOpenURL(URL(string: "cydia://"))`.

#### Métodos Comuns de Detecção Anti-Debugging

- **Check for Debugger Presence**: Use `sysctl` ou outros métodos para verificar se um debugger está anexado.
- **Anti-Debugging APIs**: Procure chamadas a APIs anti-debugging como `ptrace` ou `SIGSTOP` como `ptrace(PT_DENY_ATTACH, 0, 0, 0)`.
- **Timing Checks**: Meça o tempo de execução de certas operações e procure discrepâncias que possam indicar debugging.
- **Memory Checks**: Inspecione a memória em busca de artefatos ou modificações conhecidas de debuggers.
- **Environment Variables**: Verifique variáveis de ambiente que possam indicar uma sessão de debugging.
- **Mach Ports**: Detecte se mach exception ports estão sendo usados por debuggers.

### Análise Dinâmica Básica

Confira a análise dinâmica que [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) realiza. Você precisará navegar pelas diferentes visualizações e interagir com elas, mas ele fará hooking de várias classes enquanto realiza outras ações e irá preparar um relatório quando você terminar.

### Listando Apps Instalados

Use o comando `frida-ps -Uai` para determinar o **bundle identifier** dos apps instalados:
```bash
$ frida-ps -Uai
PID  Name                 Identifier
----  -------------------  -----------------------------------------
6847  Calendar             com.apple.mobilecal
6815  Mail                 com.apple.mobilemail
-  App Store            com.apple.AppStore
-  Apple Store          com.apple.store.Jolly
-  Calculator           com.apple.calculator
-  Camera               com.apple.camera
-  iGoat-Swift          OWASP.iGoat-Swift
```
### Basic Enumeration & Hooking

Aprenda como **enumerar os componentes da aplicação** e como **hook methods and classes** facilmente com objection:


{{#ref}}
ios-hooking-with-objection.md
{{#endref}}

### Estrutura do IPA

A estrutura de um **IPA file** é essencialmente a de um **zipped package**. Ao renomear sua extensão para `.zip`, ele pode ser **decompressed** para revelar seu conteúdo. Dentro dessa estrutura, um **Bundle** representa uma aplicação totalmente empacotada pronta para instalação. No seu interior, você encontrará um diretório chamado `<NAME>.app`, que encapsula os recursos da aplicação.

- **`Info.plist`**: Este arquivo contém detalhes de configuração específicos da aplicação.
- **`_CodeSignature/`**: Este diretório inclui um arquivo plist que contém uma assinatura, garantindo a integridade de todos os arquivos no bundle.
- **`Assets.car`**: Um arquivo compactado que armazena arquivos de assets como ícones.
- **`Frameworks/`**: Esta pasta abriga as bibliotecas nativas da aplicação, que podem estar na forma de arquivos `.dylib` ou `.framework`.
- **`PlugIns/`**: Pode incluir extensões da aplicação, conhecidas como arquivos `.appex`, embora nem sempre estejam presentes. \* [**`Core Data`**](https://developer.apple.com/documentation/coredata): É usado para salvar os dados permanentes da sua aplicação para uso offline, para cachear dados temporários e para adicionar funcionalidade de undo ao seu app em um único dispositivo. Para sincronizar dados entre múltiplos dispositivos em uma única conta iCloud, Core Data espelha automaticamente seu esquema em um CloudKit container.
- [**`PkgInfo`**](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigApplications.html): O arquivo `PkgInfo` é uma forma alternativa de especificar os type e creator codes do seu aplicativo ou bundle.
- **en.lproj, fr.proj, Base.lproj**: São os pacotes de idioma que contêm recursos para essas línguas específicas, e um recurso padrão caso um idioma não seja suportado.
- **Security**: O diretório `_CodeSignature/` desempenha um papel crítico na segurança do app ao verificar a integridade de todos os arquivos empacotados por meio de assinaturas digitais.
- **Asset Management**: O arquivo `Assets.car` usa compressão para gerenciar de forma eficiente os assets gráficos, crucial para otimizar o desempenho da aplicação e reduzir seu tamanho total.
- **Frameworks and PlugIns**: Esses diretórios ressaltam a modularidade das aplicações iOS, permitindo que desenvolvedores incluam bibliotecas de código reutilizáveis (`Frameworks/`) e estendam a funcionalidade do app (`PlugIns/`).
- **Localization**: A estrutura suporta múltiplos idiomas, facilitando o alcance global do aplicativo ao incluir recursos para pacotes de idiomas específicos.

**Info.plist**

O **Info.plist** serve como uma pedra angular para aplicações iOS, encapsulando dados de configuração na forma de pares **key-value**. Este arquivo é obrigatório não apenas para aplicações, mas também para app extensions e frameworks incluídos no bundle. Ele é estruturado em XML ou em formato binário e contém informações críticas que vão desde permissões do app até configurações de segurança. Para uma exploração detalhada das chaves disponíveis, consulte a [**Apple Developer Documentation**](https://developer.apple.com/documentation/bundleresources/information_property_list?language=objc).

Para quem deseja trabalhar com este arquivo em um formato mais acessível, a conversão para XML pode ser feita facilmente através do uso de `plutil` no macOS (disponível nativamente nas versões 10.2 e posteriores) ou `plistutil` no Linux. Os comandos para conversão são os seguintes:

- **Para macOS**:
```bash
$ plutil -convert xml1 Info.plist
```
- **Para Linux**:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
Entre a miríade de informações que o **Info.plist** file pode divulgar, entradas notáveis incluem strings de permissão do app (`UsageDescription`), esquemas de URL personalizados (`CFBundleURLTypes`) e configurações para App Transport Security (`NSAppTransportSecurity`). Essas entradas, juntamente com outras como tipos de documento personalizados exportados/importados (`UTExportedTypeDeclarations` / `UTImportedTypeDeclarations`), podem ser facilmente localizadas inspecionando o arquivo ou empregando um simples comando `grep`:
```bash
$ grep -i <keyword> Info.plist
```
**Caminhos de Dados**

No ambiente iOS, os diretórios são designados especificamente para **aplicativos do sistema** e **aplicativos instalados pelo usuário**. Aplicativos do sistema residem no diretório `/Applications`, enquanto apps instalados pelo usuário são colocados em `/var/mobile/containers/Data/Application/`. Esses aplicativos recebem um identificador único conhecido como **UUID de 128 bits**, tornando a tarefa de localizar manualmente a pasta de um app desafiadora devido à aleatoriedade dos nomes dos diretórios.

> [!WARNING]
> Como as aplicações no iOS devem ser sandboxed, cada app também terá uma pasta dentro de **`$HOME/Library/Containers`** com o **`CFBundleIdentifier`** do app como nome da pasta.
>
> Entretanto, ambas as pastas (data & container folders) possuem o arquivo **`.com.apple.mobile_container_manager.metadata.plist`** que liga ambas as pastas pela chave `MCMetadataIdentifier`).

Para facilitar a descoberta do diretório de instalação de um app instalado pelo usuário, a ferramenta objection fornece um comando útil, `env`. Esse comando revela informações detalhadas de diretório para o app em questão. Abaixo está um exemplo de como usar esse comando:
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # env

Name               Path
-----------------  -------------------------------------------------------------------------------------------
BundlePath         /var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app
CachesDirectory    /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library/Caches
DocumentDirectory  /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Documents
LibraryDirectory   /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library
```
Alternativamente, o nome do app pode ser pesquisado dentro de `/private/var/containers` usando o comando `find`:
```bash
find /private/var/containers -name "Progname*"
```
Comandos como `ps` e `lsof` também podem ser utilizados para identificar o processo do app e listar arquivos abertos, respectivamente, fornecendo insights sobre os caminhos de diretório ativos do app:
```bash
ps -ef | grep -i <app-name>
lsof -p <pid> | grep -i "/containers" | head -n 1
```
**Diretório Bundle:**

- **AppName.app**
- Este é o Bundle da Aplicação visto anteriormente no IPA; contém dados essenciais do aplicativo, conteúdo estático, bem como o binário compilado do aplicativo.
- Este diretório é visível para os usuários, mas **os usuários não podem escrever nele**.
- O conteúdo deste diretório **não é incluído em backups**.
- O conteúdo desta pasta é usado para **validar a assinatura de código**.

**Diretório de dados:**

- **Documents/**
- Contém todos os dados gerados pelo usuário. O usuário final do aplicativo inicia a criação desses dados.
- Visível aos usuários e **os usuários podem escrever nele**.
- O conteúdo deste diretório é **incluído em backups**.
- O app pode excluir caminhos do backup definindo `NSURLIsExcludedFromBackupKey`.
- **Library/**
- Contém todos os **arquivos que não são específicos do usuário**, como **caches**, **preferences**, **cookies**, e arquivos de configuração property list (plist).
- Apps iOS geralmente usam os subdiretórios `Application Support` e `Caches`, mas o app pode criar subdiretórios personalizados.
- **Library/Caches/**
- Contém **arquivos em cache semi-persistentes.**
- Invisível para os usuários e **os usuários não podem escrever nele**.
- O conteúdo deste diretório **não é incluído em backups**.
- O sistema operacional pode excluir automaticamente os arquivos deste diretório quando o app não estiver em execução e o espaço de armazenamento estiver baixo.
- **Library/Application Support/**
- Contém **arquivos** **persistentes** necessários para a execução do app.
- **Invisível** **para** **os usuários** e os usuários não podem escrever nele.
- O conteúdo neste diretório é **incluído** **em** **backup**.
- O app pode excluir caminhos do backup definindo `NSURLIsExcludedFromBackupKey`.
- **Library/Preferences/**
- Usado para armazenar propriedades que podem **persistir mesmo após o aplicativo ser reiniciado**.
- As informações são salvas, sem criptografia, dentro do sandbox do aplicativo em um plist file chamado \[BUNDLE_ID].plist.
- Todos os pares chave/valor armazenados usando `NSUserDefaults` podem ser encontrados neste arquivo.
- **tmp/**
- Use este diretório para gravar **arquivos temporários** que não precisam persistir entre as execuções do app.
- Contém arquivos em cache não persistentes.
- **Invisível** para os usuários.
- O conteúdo deste diretório não é incluído em backups.
- O sistema operacional pode excluir automaticamente os arquivos deste diretório quando o app não estiver em execução e o espaço de armazenamento estiver baixo.

Vamos dar uma olhada mais de perto no Bundle da Aplicação (.app) do iGoat-Swift dentro do diretório Bundle (`/var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app`):
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # ls
NSFileType      Perms  NSFileProtection    ...  Name
------------  -------  ------------------  ...  --------------------------------------
Regular           420  None                ...  rutger.html
Regular           420  None                ...  mansi.html
Regular           420  None                ...  splash.html
Regular           420  None                ...  about.html

Regular           420  None                ...  LICENSE.txt
Regular           420  None                ...  Sentinel.txt
Regular           420  None                ...  README.txt
```
### Binary Reversing

Dentro da pasta `<application-name>.app` você encontrará um arquivo binário chamado `<application-name>`. Este é o arquivo que será **executado**. Você pode realizar uma inspeção básica do binário com a ferramenta **`otool`**:
```bash
otool -Vh DVIA-v2 #Check some compilation attributes
magic  cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64    ARM64        ALL  0x00     EXECUTE    65       7112   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE

otool -L DVIA-v2 #Get third party libraries
DVIA-v2:
/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.1)
/usr/lib/libsqlite3.dylib (compatibility version 9.0.0, current version 274.6.0)
/usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11)
@rpath/Bolts.framework/Bolts (compatibility version 1.0.0, current version 1.0.0)
[...]
```
**Verificar se o app está criptografado**

Verifique se há alguma saída para:
```bash
otool -l <app-binary> | grep -A 4 LC_ENCRYPTION_INFO
```
**Desassemblando o binário**

Desassemble a seção .text:
```bash
otool -tV DVIA-v2
DVIA-v2:
(__TEXT,__text) section
+[DDLog initialize]:
0000000100004ab8    sub    sp, sp, #0x60
0000000100004abc    stp    x29, x30, [sp, #0x50]   ; Latency: 6
0000000100004ac0    add    x29, sp, #0x50
0000000100004ac4    sub    x8, x29, #0x10
0000000100004ac8    mov    x9, #0x0
0000000100004acc    adrp    x10, 1098 ; 0x10044e000
0000000100004ad0    add    x10, x10, #0x268
```
Para imprimir o **segmento Objective-C** da aplicação de exemplo, pode-se usar:
```bash
otool -oV DVIA-v2
DVIA-v2:
Contents of (__DATA,__objc_classlist) section
00000001003dd5b8 0x1004423d0 _OBJC_CLASS_$_DDLog
isa        0x1004423a8 _OBJC_METACLASS_$_DDLog
superclass 0x0 _OBJC_CLASS_$_NSObject
cache      0x0 __objc_empty_cache
vtable     0x0
data       0x1003de748
flags          0x80
instanceStart  8
```
Para obter um código Objective-C mais compacto, você pode usar [**class-dump**](http://stevenygard.com/projects/class-dump/):
```bash
class-dump some-app
//
//     Generated by class-dump 3.5 (64 bit).
//
//     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2013 by Steve Nygard.
//

#pragma mark Named Structures

struct CGPoint {
double _field1;
double _field2;
};

struct CGRect {
struct CGPoint _field1;
struct CGSize _field2;
};

struct CGSize {
double _field1;
double _field2;
};
```
No entanto, as melhores opções para desassemblar o binário são: [**Hopper**](https://www.hopperapp.com/download.html?) and [**IDA**](https://www.hex-rays.com/products/ida/support/download_freeware/).

## Armazenamento de Dados

Para saber como o iOS armazena dados no dispositivo leia esta página:


{{#ref}}
ios-basics.md
{{#endref}}

> [!WARNING]
> Os seguintes locais para armazenar informação devem ser verificados **imediatamente após instalar a aplicação**, **após testar todas as funcionalidades** da aplicação e mesmo após **fazer logout de um usuário e login em outro**.\
> O objetivo é encontrar **informação sensível não protegida** da aplicação (passwords, tokens), do utilizador atual e de utilizadores previamente autenticados.

### Plist

**plist** files are structured XML files that **contains key-value pairs**. It's a way to store persistent data, so sometimes you may find **sensitive information in these files**. It's recommended to check these files after installing the app and after using intensively it to see if new data is written.

The most common way to persist data in plist files is through the usage of **NSUserDefaults**. This plist file is saved inside the app sandbox in **`Library/Preferences/<appBundleID>.plist`**

The [`NSUserDefaults`](https://developer.apple.com/documentation/foundation/nsuserdefaults) class provides a programmatic interface for interacting with the default system. The default system allows an application to customize its behaviour according to **user preferences**. Data saved by `NSUserDefaults` can be viewed in the application bundle. This class stores **data** in a **plist** **file**, but it's meant to be used with small amounts of data.

This data cannot be longer accessed directly via a trusted computer, but can be accessed performing a **backup**.

You can **dump** the information saved using **`NSUserDefaults`** using objection's `ios nsuserdefaults get`

To find all the plist of used by the application you can access to `/private/var/mobile/Containers/Data/Application/{APPID}` and run:
```bash
find ./ -name "*.plist"
```
Para converter arquivos em formato **XML ou binário (bplist)** para XML, existem vários métodos dependendo do seu sistema operacional:

**Para usuários do macOS:** Utilize o comando `plutil`. É uma ferramenta integrada do macOS (10.2+), projetada para esse propósito:
```bash
$ plutil -convert xml1 Info.plist
```
**Para usuários do Linux:** Instale `libplist-utils` primeiro, depois use `plistutil` para converter seu arquivo:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
**Within an Objection Session:** Para analisar aplicativos móveis, um comando específico permite converter arquivos plist diretamente:
```bash
ios plist cat /private/var/mobile/Containers/Data/Application/<Application-UUID>/Library/Preferences/com.some.package.app.plist
```
### Core Data

[`Core Data`](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/nsfetchedresultscontroller.html#//apple_ref/doc/uid/TP40001075-CH8-SW1) é um framework para gerenciar a camada de modelo dos objetos na sua aplicação. [Core Data can use SQLite as its persistent store](https://cocoacasts.com/what-is-the-difference-between-core-data-and-sqlite/), mas o próprio framework não é um banco de dados.\
CoreData não criptografa seus dados por padrão. No entanto, uma camada de criptografia adicional pode ser adicionada ao CoreData. Veja o [GitHub Repo](https://github.com/project-imas/encrypted-core-data) para mais detalhes.

Você pode encontrar as informações do SQLite Core Data de um aplicativo no caminho `/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support`

**Se você conseguir abrir o SQLite e acessar informações sensíveis, então encontrou uma configuração incorreta.**
```objectivec:Code from iGoat
-(void)storeDetails {
AppDelegate * appDelegate = (AppDelegate *)(UIApplication.sharedApplication.delegate);

NSManagedObjectContext *context =[appDelegate managedObjectContext];

User *user = [self fetchUser];
if (user) {
return;
}
user = [NSEntityDescription insertNewObjectForEntityForName:@"User"
inManagedObjectContext:context];
user.email = CoreDataEmail;
user.password = CoreDataPassword;
NSError *error;
if (![context save:&error]) {
NSLog(@"Error in saving data: %@", [error localizedDescription]);

}else{
NSLog(@"data stored in core data");
}
}
```
### YapDatabase

[YapDatabase](https://github.com/yapstudios/YapDatabase) é um armazenamento chave/valor construído em cima do SQLite.\ Como os bancos de dados Yap são bancos SQLite você pode encontrá-los usando o comando proposto na seção anterior.

### Outros Bancos de Dados SQLite

É comum que aplicações criem seu próprio banco de dados SQLite. Elas podem estar **armazenando** **dados** **sensíveis** neles e deixando-os sem criptografia. Portanto, é sempre interessante verificar cada banco de dados dentro do diretório da aplicação. Vá para o diretório da aplicação onde os dados são salvos (`/private/var/mobile/Containers/Data/Application/{APPID}`)
```bash
find ./ -name "*.sqlite" -or -name "*.db"
```
### Firebase Real-Time Databases

Os desenvolvedores podem **armazenar e sincronizar dados** em um **banco de dados NoSQL hospedado na nuvem** através do Firebase Real-Time Databases. Armazenados em formato JSON, os dados são sincronizados para todos os clientes conectados em tempo real.

You can find how to check for misconfigured Firebase databases here:


{{#ref}}
../../network-services-pentesting/pentesting-web/buckets/firebase-database.md
{{#endref}}

### Realm databases

[Realm Objective-C](https://realm.io/docs/objc/latest/) e [Realm Swift](https://realm.io/docs/swift/latest/) oferecem uma alternativa poderosa para armazenamento de dados, não fornecida pela Apple. Por padrão, eles **armazenam os dados sem criptografia**, sendo a criptografia disponível mediante configuração específica.

The databases are located at: `/private/var/mobile/Containers/Data/Application/{APPID}`. To explore these files, one can utilize commands like:
```bash
iPhone:/private/var/mobile/Containers/Data/Application/A079DF84-726C-4AEA-A194-805B97B3684A/Documents root# ls
default.realm  default.realm.lock  default.realm.management/  default.realm.note|

$ find ./ -name "*.realm*"
```
Para visualizar esses arquivos de banco de dados, a ferramenta [**Realm Studio**](https://github.com/realm/realm-studio) é recomendada.

Para implementar criptografia em um banco de dados Realm, o trecho de código a seguir pode ser usado:
```swift
// Open the encrypted Realm file where getKey() is a method to obtain a key from the Keychain or a server
let config = Realm.Configuration(encryptionKey: getKey())
do {
let realm = try Realm(configuration: config)
// Use the Realm as normal
} catch let error as NSError {
// If the encryption key is wrong, `error` will say that it's an invalid database
fatalError("Error opening realm: \(error)")
}
```
### Bancos de dados Couchbase Lite

[Couchbase Lite](https://github.com/couchbase/couchbase-lite-ios) é descrito como um mecanismo de banco de dados **leve** e **embutido** que segue a abordagem **orientada a documentos** (NoSQL). Projetado para ser nativo em **iOS** e **macOS**, oferece a capacidade de sincronizar dados de forma transparente.

Para identificar possíveis bancos de dados Couchbase em um dispositivo, o seguinte diretório deve ser inspecionado:
```bash
ls /private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support/
```
### Cookies

O iOS armazena os cookies dos apps em **`Library/Cookies/cookies.binarycookies`** dentro da pasta de cada app. No entanto, desenvolvedores às vezes optam por salvá-los no **keychain**, pois o referido **cookie file pode ser acessado em backups**.

Para inspecionar o cookie file você pode usar [**this python script**](https://github.com/mdegrazia/Safari-Binary-Cookie-Parser) ou usar o **`ios cookies get`** do objection.\
**Você também pode usar o objection para** converter esses arquivos para um formato JSON e inspecionar os dados.
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios cookies get --json
[
{
"domain": "highaltitudehacks.com",
"expiresDate": "2051-09-15 07:46:43 +0000",
"isHTTPOnly": "false",
"isSecure": "false",
"name": "username",
"path": "/",
"value": "admin123",
"version": "0"
}
]
```
### Cache

Por padrão o NSURLSession armazena dados, such as **HTTP requests and responses in the Cache.db** database. Este banco de dados pode conter **dados sensíveis**, se tokens, nomes de usuário ou qualquer outra informação sensível tiver sido armazenada em cache. Para encontrar as informações em cache abra o diretório de dados do app (`/var/mobile/Containers/Data/Application/<UUID>`) e vá para `/Library/Caches/<Bundle Identifier>`. O **WebKit cache is also being stored in the Cache.db** file. **Objection** pode abrir e interagir com o banco de dados com o comando `sqlite connect Cache.db`, pois é um **normal SQLite database**.

É **recomendado desabilitar o cache desses dados**, pois podem conter informações sensíveis na requisição ou resposta. A lista abaixo mostra diferentes maneiras de conseguir isso:

1.  É recomendável remover respostas em cache após o logout. Isso pode ser feito com o método fornecido pela Apple chamado [`removeAllCachedResponses`](https://developer.apple.com/documentation/foundation/urlcache/1417802-removeallcachedresponses) Você pode chamar este método da seguinte forma:

`URLCache.shared.removeAllCachedResponses()`

Este método removerá todas as requisições e respostas em cache do arquivo Cache.db.

2.  Se você não precisa usar a vantagem dos cookies, é recomendado usar a propriedade de configuração [.ephemeral](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral) do URLSession, que desabilitará a gravação de cookies e caches.

[Apple documentation](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral):

`An ephemeral session configuration object is similar to a default session configuration (see default), except that the corresponding session object doesn’t store caches, credential stores, or any session-related data to disk. Instead, session-related data is stored in RAM. The only time an ephemeral session writes data to disk is when you tell it to write the contents of a URL to a file.`

3.  O cache também pode ser desabilitado definindo a Cache Policy para [.notAllowed](https://developer.apple.com/documentation/foundation/urlcache/storagepolicy/notallowed). Isso impedirá o armazenamento do cache de qualquer forma, seja na memória ou no disco.

### Snapshots

Sempre que você pressiona o botão home, iOS **takes a snapshot of the current screen** para permitir uma transição muito mais suave para o aplicativo. Contudo, se **dados sensíveis** estiverem presentes na tela atual, eles serão **salvos** na **imagem** (que **persiste** **across** **reboots**). Esses são os snapshots que você também pode acessar dando um duplo toque no botão home para alternar entre apps.

A menos que o iPhone esteja jailbroken, o **atacante** precisa ter **acesso** ao **dispositivo** **desbloqueado** para ver essas capturas de tela. Por padrão o último snapshot é armazenado no sandbox do aplicativo em `Library/Caches/Snapshots/` ou na pasta `Library/SplashBoard/Snapshots` (os computadores confiáveis can't access the filesystem from iOX 7.0).

Uma forma de prevenir esse comportamento indesejado é colocar uma tela em branco ou remover os dados sensíveis antes de tirar o snapshot usando a função `ApplicationDidEnterBackground()`.

A seguir há um método de remediação de exemplo que definirá uma screenshot padrão.

Swift:
```swift
private var backgroundImage: UIImageView?

func applicationDidEnterBackground(_ application: UIApplication) {
let myBanner = UIImageView(image: #imageLiteral(resourceName: "overlayImage"))
myBanner.frame = UIScreen.main.bounds
backgroundImage = myBanner
window?.addSubview(myBanner)
}

func applicationWillEnterForeground(_ application: UIApplication) {
backgroundImage?.removeFromSuperview()
}
```
Objective-C:
```
@property (UIImageView *)backgroundImage;

- (void)applicationDidEnterBackground:(UIApplication *)application {
UIImageView *myBanner = [[UIImageView alloc] initWithImage:@"overlayImage.png"];
self.backgroundImage = myBanner;
self.backgroundImage.bounds = UIScreen.mainScreen.bounds;
[self.window addSubview:myBanner];
}

- (void)applicationWillEnterForeground:(UIApplication *)application {
[self.backgroundImage removeFromSuperview];
}
```
Isso define a imagem de fundo para `overlayImage.png` sempre que a aplicação for enviada para segundo plano. Isso previne leaks de dados sensíveis porque `overlayImage.png` sempre irá sobrepor a view atual.

### Keychain

Para acessar e gerenciar o iOS keychain, ferramentas como [**Keychain-Dumper**](https://github.com/ptoomey3/Keychain-Dumper) estão disponíveis, adequadas para dispositivos jailbroken. Além disso, [**Objection**](https://github.com/sensepost/objection) fornece o comando `ios keychain dump` para fins semelhantes.

#### **Storing Credentials**

A classe **NSURLCredential** é ideal para salvar informações sensíveis diretamente no keychain, contornando a necessidade de NSUserDefaults ou outros wrappers. Para armazenar credentials após o login, o seguinte código Swift é usado:
```swift
NSURLCredential *credential;
credential = [NSURLCredential credentialWithUser:username password:password persistence:NSURLCredentialPersistencePermanent];
[[NSURLCredentialStorage sharedCredentialStorage] setCredential:credential forProtectionSpace:self.loginProtectionSpace];
```
Para extrair essas credenciais armazenadas, utiliza-se o comando do Objection `ios nsurlcredentialstorage dump`.

## **Teclados Personalizados e Cache do Teclado**

A partir do iOS 8.0, os usuários podem instalar extensões de teclado personalizadas, que podem ser gerenciadas em **Settings > General > Keyboard > Keyboards**. Embora esses teclados ofereçam funcionalidades adicionais, eles apresentam risco de keystroke logging e de transmissão de dados para servidores externos, embora os usuários sejam notificados sobre teclados que requerem acesso à rede. Os aplicativos podem, e devem, restringir o uso de teclados personalizados para a entrada de informações sensíveis.

**Recomendações de Segurança:**

- Recomenda-se desativar teclados de terceiros para maior segurança.
- Esteja ciente dos recursos de autocorreção e sugestões automáticas do teclado padrão do iOS, que podem armazenar informações sensíveis em arquivos de cache localizados em `Library/Keyboard/{locale}-dynamic-text.dat` ou `/private/var/mobile/Library/Keyboard/dynamic-text.dat`. Esses arquivos de cache devem ser verificados regularmente em busca de dados sensíveis. Recomenda-se redefinir o dicionário do teclado via **Settings > General > Reset > Reset Keyboard Dictionary** para limpar os dados em cache.
- Interceptar o tráfego de rede pode revelar se um teclado personalizado está transmitindo keystrokes remotamente.

### **Prevenção do Cache de Campos de Texto**

O [UITextInputTraits protocol](https://developer.apple.com/reference/uikit/uitextinputtraits) oferece propriedades para gerenciar autocorreção e secure text entry, essenciais para prevenir o cache de informações sensíveis. Por exemplo, desabilitar a autocorreção e habilitar secure text entry pode ser feito com:
```objectivec
textObject.autocorrectionType = UITextAutocorrectionTypeNo;
textObject.secureTextEntry = YES;
```
Além disso, os desenvolvedores devem garantir que os campos de texto, especialmente aqueles para inserir informações sensíveis como senhas e PINs, desativem o cache configurando `autocorrectionType` para `UITextAutocorrectionTypeNo` e `secureTextEntry` para `YES`.
```objectivec
UITextField *textField = [[UITextField alloc] initWithFrame:frame];
textField.autocorrectionType = UITextAutocorrectionTypeNo;
```
## **Logs**

Depurar código frequentemente envolve o uso de **logging**. Há um risco envolvido, pois **os logs podem conter informações sensíveis**. Anteriormente, no iOS 6 e versões anteriores, os logs eram acessíveis a todos os apps, representando um risco de sensitive data leak. **Agora, os apps estão restritos a acessar apenas seus próprios logs**.

Apesar dessas restrições, um **atacante com acesso físico** a um dispositivo desbloqueado ainda pode explorar isso conectando o dispositivo a um computador e **lendo os logs**. É importante notar que os logs permanecem no disco mesmo após a desinstalação do app.

Para mitigar os riscos, recomenda-se **interagir exaustivamente com o app**, explorando todas as funcionalidades e entradas para garantir que nenhuma informação sensível esteja sendo registrada inadvertidamente.

Ao revisar o código-fonte do app em busca de potenciais leaks, procure tanto por declarações de logging **predefinidas** quanto **customizadas**, usando palavras-chave como `NSLog`, `NSAssert`, `NSCAssert`, `fprintf` para funções internas, e quaisquer menções de `Logging` ou `Logfile` para implementações customizadas.

### **Monitoramento dos logs do sistema**

Os apps registram diversas informações que podem ser sensíveis. Para monitorar esses logs, ferramentas e comandos como:
```bash
idevice_id --list   # To find the device ID
idevicesyslog -u <id> (| grep <app>)   # To capture the device logs
```
são úteis. Além disso, **Xcode** fornece uma forma de coletar logs do console:

1. Abra o Xcode.
2. Conecte o dispositivo iOS.
3. Navegue para **Window** -> **Devices and Simulators**.
4. Selecione seu dispositivo.
5. Reproduza o problema que você está investigando.
6. Use o botão **Open Console** para ver os logs em uma nova janela.

Para um monitoramento de logs mais avançado, conectar-se ao shell do dispositivo e usar o **socat** pode fornecer monitoramento de logs em tempo real:
```bash
iPhone:~ root# socat - UNIX-CONNECT:/var/run/lockdown/syslog.sock
```
Seguido por comandos para observar atividades de logs, que podem ser inestimáveis para diagnosticar problemas ou identificar potenciais vazamentos de dados nos logs.

## Backups

**Auto-backup features** estão integrados ao iOS, facilitando a criação de cópias dos dados do dispositivo através do iTunes (até macOS Catalina), Finder (a partir do macOS Catalina) ou iCloud. Esses backups abrangem quase todos os dados do dispositivo, excluindo elementos altamente sensíveis como detalhes do Apple Pay e configurações do Touch ID.

### Security Risks

A inclusão de **installed apps and their data** nos backups levanta a questão de potencial **data leakage** e o risco de que **backup modifications could alter app functionality**. Recomenda-se **não armazenar informações sensíveis em plaintext** dentro do diretório de qualquer app ou seus subdiretórios para mitigar esses riscos.

### Excluding Files from Backups

Arquivos em `Documents/` e `Library/Application Support/` são incluídos nos backups por padrão. Desenvolvedores podem excluir arquivos ou diretórios específicos dos backups usando `NSURL setResourceValue:forKey:error:` com a chave `NSURLIsExcludedFromBackupKey`. Essa prática é crucial para proteger dados sensíveis de serem incluídos nos backups.

### Testing for Vulnerabilities

Para avaliar a segurança do backup de um app, comece por **criar um backup** usando o Finder, depois localize-o seguindo as instruções da [documentação oficial da Apple](https://support.apple.com/en-us/HT204215). Analise o backup em busca de dados sensíveis ou configurações que possam ser alteradas para afetar o comportamento do app.

Informações sensíveis podem ser procuradas usando ferramentas de linha de comando ou aplicações como [iMazing](https://imazing.com). Para backups criptografados, a presença de criptografia pode ser confirmada verificando a chave "IsEncrypted" no arquivo "Manifest.plist" na raiz do backup.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
...
<key>Date</key>
<date>2021-03-12T17:43:33Z</date>
<key>IsEncrypted</key>
<true/>
...
</plist>
```
Para lidar com encrypted backups, scripts Python disponíveis no [DinoSec's GitHub repo](https://github.com/dinosec/iphone-dataprotection/tree/master/python_scripts), como **backup_tool.py** e **backup_passwd.py**, podem ser úteis, embora potencialmente requeiram ajustes para compatibilidade com as versões mais recentes do iTunes/Finder. A ferramenta [**iOSbackup**](https://pypi.org/project/iOSbackup/) é outra opção para acessar arquivos dentro de backups protegidos por senha.

### Modificando o Comportamento do App

Um exemplo de alteração do comportamento do app por meio de modificações no backup é demonstrado no [Bither bitcoin wallet app](https://github.com/bither/bither-ios), onde o UI lock PIN é armazenado dentro de `net.bither.plist` sob a chave **pin_code**. Remover essa chave do plist e restaurar o backup elimina a exigência do PIN, proporcionando acesso irrestrito.

## Resumo sobre Teste de Memória para Dados Sensíveis

Ao lidar com informações sensíveis armazenadas na memória de uma aplicação, é crucial limitar o tempo de exposição desses dados. Existem duas abordagens principais para investigar o conteúdo da memória: **creating a memory dump** e **analyzing the memory in real time**. Ambas têm desafios, incluindo a possibilidade de perder dados críticos durante o processo de dump ou durante a análise.

## **Recuperando e Analisando um Memory Dump**

Para dispositivos jailbroken e non-jailbroken, ferramentas como [objection](https://github.com/sensepost/objection) e [Fridump](https://github.com/Nightbringer21/fridump) permitem o dump da memória do processo de um app. Uma vez feito o dump, analisar esses dados requer várias ferramentas, dependendo da natureza da informação que você está procurando.

Para extrair strings de um memory dump, comandos como `strings` ou `rabin2 -zz` podem ser usados:
```bash
# Extracting strings using strings command
$ strings memory > strings.txt

# Extracting strings using rabin2
$ rabin2 -ZZ memory > strings.txt
```
Para uma análise mais detalhada, incluindo a busca por tipos de dados ou padrões específicos, **radare2** oferece amplas capacidades de pesquisa:
```bash
$ r2 <name_of_your_dump_file>
[0x00000000]> /?
...
```
## **Análise de Memória em Tempo Real**

**r2frida** fornece uma alternativa poderosa para inspecionar a memória de um app em tempo real, sem precisar de um memory dump. Esta ferramenta permite a execução de comandos de busca diretamente na memória do aplicativo em execução:
```bash
$ r2 frida://usb//<name_of_your_app>
[0x00000000]> /\ <search_command>
```
## Criptografia Quebrada

### Processos Fracos de Gerenciamento de Chaves

Alguns desenvolvedores salvam dados sensíveis no armazenamento local e os encriptam com uma chave hardcoded/predictable no code. Isso não deve ser feito, pois algum reversing pode permitir que atacantes extraiam a informação confidencial.

### Uso de Algoritmos Inseguros e/ou Depreciados

Desenvolvedores não devem usar **deprecated algorithms** para realizar authorisation **checks**, **store** ou **send** data. Alguns desses algoritmos são: RC4, MD4, MD5, SHA1... Se **hashes** forem usados para armazenar senhas, por exemplo, devem ser usados hashes brute-force **resistant** com salt.

### Check

As principais verificações a realizar são encontrar se você pode localizar **hardcoded** passwords/secrets no code, ou se estes são **predictable**, e se o code está usando algum tipo de **weak** **cryptography** algorithms.

É interessante saber que você pode **monitor** algumas **crypto** **libraries** automaticamente usando **objection** com:
```swift
ios monitor crypt
```
Para **mais informações** sobre APIs e bibliotecas criptográficas do iOS acesse [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography)

## Autenticação Local

A **autenticação local** desempenha um papel crucial, especialmente quando se trata de proteger o acesso a um endpoint remoto por métodos criptográficos. O essencial aqui é que, sem uma implementação adequada, os mecanismos de autenticação local podem ser contornados.

A Apple fornece APIs robustas para developers: o [**Local Authentication framework**](https://developer.apple.com/documentation/localauthentication) para diálogos de autenticação do usuário e o [**keychain**](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html) para manipular dados secretos de forma segura. O Secure Enclave protege a identificação por impressão digital do Touch ID, enquanto o Face ID usa reconhecimento facial sem comprometer os dados biométricos.

Para integrar Touch ID/Face ID, os developers têm duas opções de API:

- **`LocalAuthentication.framework`** para autenticação de usuário em alto nível sem acesso aos dados biométricos.
- **`Security.framework`** para acesso de baixo nível aos serviços do keychain, protegendo dados secretos com autenticação biométrica. Vários [open-source wrappers](https://www.raywenderlich.com/147308/secure-ios-user-data-keychain-touch-id) tornam o acesso ao keychain mais simples.

> [!CAUTION]
> Entretanto, tanto `LocalAuthentication.framework` quanto `Security.framework` apresentam vulnerabilidades, pois retornam principalmente valores booleanos sem transmitir dados para os processos de autenticação, tornando-os suscetíveis a contornos (consultar [Don't touch me that way, by David Lindner et al](https://www.youtube.com/watch?v=XhXIHVGCFFM)).

### Implementando a Autenticação Local

Para solicitar a autenticação do usuário, os developers devem utilizar o método **`evaluatePolicy`** dentro da classe **`LAContext`**, escolhendo entre:

- **`deviceOwnerAuthentication`**: Solicita Touch ID ou o device passcode, falhando se nenhum estiver habilitado.
- **`deviceOwnerAuthenticationWithBiometrics`**: Solicita exclusivamente Touch ID.

Uma autenticação bem-sucedida é indicada por um valor booleano retornado por **`evaluatePolicy`**, o que ressalta uma possível falha de segurança.

### Autenticação Local usando Keychain

Implementar **autenticação local** em apps iOS envolve o uso das APIs do keychain para armazenar de forma segura dados secretos, como tokens de autenticação. Esse processo garante que os dados só possam ser acessados pelo usuário, usando o device passcode ou autenticação biométrica como Touch ID.

O keychain permite definir itens com o atributo `SecAccessControl`, que restringe o acesso ao item até que o usuário autentique com sucesso via Touch ID ou device passcode. Esse recurso é crucial para aumentar a segurança.

A seguir há exemplos de código em Swift e Objective-C demonstrando como salvar e recuperar uma string no keychain, aproveitando esses recursos de segurança. Os exemplos mostram especificamente como configurar o access control para requerer autenticação por Touch ID e garantir que os dados sejam acessíveis apenas no dispositivo em que foram configurados, sob a condição de que um device passcode esteja configurado.

{{#tabs}}
{{#tab name="Swift"}}
```swift
// From https://github.com/mufambisi/owasp-mstg/blob/master/Document/0x06f-Testing-Local-Authentication.md

// 1. create AccessControl object that will represent authentication settings

var error: Unmanaged<CFError>?

guard let accessControl = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
SecAccessControlCreateFlags.biometryCurrentSet,
&error) else {
// failed to create AccessControl object

return
}

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute

var query: [String: Any] = [:]

query[kSecClass as String] = kSecClassGenericPassword
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecAttrAccount as String] = "OWASP Account" as CFString
query[kSecValueData as String] = "test_strong_password".data(using: .utf8)! as CFData
query[kSecAttrAccessControl as String] = accessControl

// 3. save item

let status = SecItemAdd(query as CFDictionary, nil)

if status == noErr {
// successfully saved
} else {
// error while saving
}
```
{{#endtab}}

{{#tab name="Objective-C"}}
```objectivec
// 1. create AccessControl object that will represent authentication settings
CFErrorRef *err = nil;

SecAccessControlRef sacRef = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
kSecAccessControlUserPresence,
err);

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute
NSDictionary* query = @{
(_ _bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecAttrAccount: @"OWASP Account",
(__bridge id)kSecValueData: [@"test_strong_password" dataUsingEncoding:NSUTF8StringEncoding],
(__bridge id)kSecAttrAccessControl: (__bridge_transfer id)sacRef
};

// 3. save item
OSStatus status = SecItemAdd((__bridge CFDictionaryRef)query, nil);

if (status == noErr) {
// successfully saved
} else {
// error while saving
}
```
{{#endtab}}
{{#endtabs}}

Agora podemos solicitar o item salvo do keychain. Keychain services exibirá o diálogo de autenticação para o usuário e retornará data ou nil dependendo se uma impressão digital adequada foi fornecida ou não.

{{#tabs}}
{{#tab name="Swift"}}
```swift
// 1. define query
var query = [String: Any]()
query[kSecClass as String] = kSecClassGenericPassword
query[kSecReturnData as String] = kCFBooleanTrue
query[kSecAttrAccount as String] = "My Name" as CFString
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecUseOperationPrompt as String] = "Please, pass authorisation to enter this area" as CFString

// 2. get item
var queryResult: AnyObject?
let status = withUnsafeMutablePointer(to: &queryResult) {
SecItemCopyMatching(query as CFDictionary, UnsafeMutablePointer($0))
}

if status == noErr {
let password = String(data: queryResult as! Data, encoding: .utf8)!
// successfully received password
} else {
// authorization not passed
}
```
{{#endtab}}

{{#tab name="Objective-C"}}
```objectivec
// 1. define query
NSDictionary *query = @{(__bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecReturnData: @YES,
(__bridge id)kSecAttrAccount: @"My Name1",
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecUseOperationPrompt: @"Please, pass authorisation to enter this area" };

// 2. get item
CFTypeRef queryResult = NULL;
OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)query, &queryResult);

if (status == noErr){
NSData* resultData = ( __bridge_transfer NSData* )queryResult;
NSString* password = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding];
NSLog(@"%@", password);
} else {
NSLog(@"Something went wrong");
}
```
{{#endtab}}
{{#endtabs}}

### Detecção

O uso de frameworks em um app também pode ser detectado analisando a lista de bibliotecas dinâmicas compartilhadas do binário do app. Isso pode ser feito usando `otool`:
```bash
$ otool -L <AppName>.app/<AppName>
```
Se `LocalAuthentication.framework` for usado em um aplicativo, a saída conterá ambas as linhas a seguir (lembre-se de que `LocalAuthentication.framework` usa `Security.framework` por baixo dos panos):
```bash
/System/Library/Frameworks/LocalAuthentication.framework/LocalAuthentication
/System/Library/Frameworks/Security.framework/Security
```
If `Security.framework` is used, only the second one will be shown.

### Local Authentication Framework Bypass

#### **Objection**

Through the **Objection Biometrics Bypass**, located at [this GitHub page](https://github.com/sensepost/objection/wiki/Understanding-the-iOS-Biometrics-Bypass), a technique is available for overcoming the **LocalAuthentication** mechanism. The core of this approach involves leveraging **Frida** to manipulate the `evaluatePolicy` function, ensuring it consistently yields a `True` outcome, irrespective of the actual authentication success. This is particularly useful for circumventing flawed biometric authentication processes.

Para ativar este bypass, o seguinte comando é usado:
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios ui biometrics_bypass
(agent) Registering job 3mhtws9x47q. Type: ios-biometrics-disable
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # (agent) [3mhtws9x47q] Localized Reason for auth requirement: Please authenticate yourself
(agent) [3mhtws9x47q] OS authentication response: false
(agent) [3mhtws9x47q] Marking OS response as True instead
(agent) [3mhtws9x47q] Biometrics bypass hook complete
```
Este comando inicia uma sequência na qual Objection registra uma tarefa que efetivamente altera o resultado da verificação `evaluatePolicy` para `True`.

#### Frida

Um exemplo de uso de **`evaluatePolicy`** da [DVIA-v2 application](https://github.com/prateek147/DVIA-v2):
```swift
+(void)authenticateWithTouchID {
LAContext *myContext = [[LAContext alloc] init];
NSError *authError = nil;
NSString *myLocalizedReasonString = @"Please authenticate yourself";

if ([myContext canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&authError]) {
[myContext evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics
localizedReason:myLocalizedReasonString
reply:^(BOOL success, NSError *error) {
if (success) {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Successful" withTitle:@"Success"];
});
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Failed !" withTitle:@"Error"];
});
}
}];
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Your device doesn't support Touch ID or you haven't configured Touch ID authentication on your device" withTitle:@"Error"];
});
}
}
```
Para realizar o **bypass** do Local Authentication, um script Frida é escrito. Esse script mira na verificação **evaluatePolicy**, interceptando seu callback para garantir que retorne **success=1**. Ao alterar o comportamento do callback, o bypass da verificação de autenticação é efetivado.

O script abaixo é injetado para modificar o resultado do método **evaluatePolicy**. Ele altera o resultado do callback para sempre indicar sucesso.
```swift
// from https://securitycafe.ro/2022/09/05/mobile-pentesting-101-bypassing-biometric-authentication/
if(ObjC.available) {
console.log("Injecting...");
var hook = ObjC.classes.LAContext["- evaluatePolicy:localizedReason:reply:"];
Interceptor.attach(hook.implementation, {
onEnter: function(args) {
var block = new ObjC.Block(args[4]);
const callback = block.implementation;
block.implementation = function (error, value)  {

console.log("Changing the result value to true")
const result = callback(1, null);
return result;
};
},
});
} else {
console.log("Objective-C Runtime is not available!");
}
```
Para injetar o Frida script e contornar a autenticação biométrica, o seguinte comando é usado:
```bash
frida -U -f com.highaltitudehacks.DVIAswiftv2 --no-pause -l fingerprint-bypass-ios.js
```
## Exposição de Funcionalidade Sensível através de IPC

### Handlers de URI personalizados / Deeplinks / Custom Schemes


{{#ref}}
ios-custom-uri-handlers-deeplinks-custom-schemes.md
{{#endref}}

### Universal Links


{{#ref}}
ios-universal-links.md
{{#endref}}

### UIActivity Sharing


{{#ref}}
ios-uiactivity-sharing.md
{{#endref}}

### UIPasteboard


{{#ref}}
ios-uipasteboard.md
{{#endref}}

### App Extensions


{{#ref}}
ios-app-extensions.md
{{#endref}}

### WebViews


{{#ref}}
ios-webviews.md
{{#endref}}

### Serialisation and Encoding


{{#ref}}
ios-serialisation-and-encoding.md
{{#endref}}

## Comunicação de Rede

É importante verificar que nenhuma comunicação esteja ocorrendo **sem criptografia** e também que a aplicação esteja corretamente **validando o certificado TLS** do servidor.\
Para verificar esse tipo de problema você pode usar um proxy como **Burp**:


{{#ref}}
burp-configuration-for-ios.md
{{#endref}}

### Verificação do hostname

Um problema comum na validação do certificado TLS é verificar se o certificado foi assinado por uma **CA** **confiável**, mas **não verificar** se **o hostname** do certificado corresponde ao hostname que está sendo acessado.\
Para verificar esse problema usando o Burp, depois de confiar na CA do Burp no iPhone, você pode **criar um novo certificado com o Burp para um hostname diferente** e usá-lo. Se a aplicação ainda funcionar, então há uma vulnerabilidade.

### Certificate Pinning

Se uma aplicação estiver usando SSL Pinning corretamente, então a aplicação só funcionará se o certificado for o esperado. Ao testar uma aplicação **isso pode ser um problema, pois o Burp irá apresentar seu próprio certificado.**\
Para contornar essa proteção em um dispositivo jailbroken, você pode instalar a aplicação [**SSL Kill Switch**](https://github.com/nabla-c0d3/ssl-kill-switch2) ou instalar [**Burp Mobile Assistant**](https://portswigger.net/burp/documentation/desktop/mobile/config-ios-device)

Você também pode usar **objection's** `ios sslpinning disable`

## Diversos

- Em **`/System/Library`** você pode encontrar os frameworks instalados no telefone usados pelas aplicações do sistema
- As aplicações instaladas pelo usuário a partir da App Store estão localizadas dentro de **`/User/Applications`**
- E **`/User/Library`** contém dados salvos pelas aplicações em nível de usuário
- Você pode acessar **`/User/Library/Notes/notes.sqlite`** para ler as notas salvas dentro da aplicação.
- Dentro da pasta de uma aplicação instalada (**`/User/Applications/<APP ID>/`**) você pode encontrar alguns arquivos interessantes:
- **`iTunesArtwork`**: O ícone usado pelo app
- **`iTunesMetadata.plist`**: Informações do app usadas na App Store
- **`/Library/*`**: Contém as preferências e cache. Em **`/Library/Cache/Snapshots/*`** você pode encontrar o snapshot realizado da aplicação antes de enviá-la para o background.

### Hot Patching/Atualização Forçada

Os desenvolvedores podem remotamente **corrigir todas as instalações do seu app instantaneamente** sem precisar reenviar a aplicação para a App Store e esperar até que seja aprovada.\
Para esse propósito geralmente é usado [**JSPatch**](https://github.com/bang590/JSPatch)**.** Mas há outras opções também, como [Siren](https://github.com/ArtSabintsev/Siren) e [react-native-appstore-version-checker](https://www.npmjs.com/package/react-native-appstore-version-checker).\
**Este é um mecanismo perigoso que pode ser abusado por SDKs de terceiros maliciosos; portanto, é recomendado verificar qual método é usado para atualização automática (se houver) e testá-lo.** Você pode tentar baixar uma versão anterior do app para esse propósito.

### Third Parties

Um desafio significativo com **3rd party SDKs** é a **falta de controle granular** sobre suas funcionalidades. Os desenvolvedores enfrentam uma escolha: integrar o SDK e aceitar todas as suas funcionalidades, incluindo potenciais vulnerabilidades de segurança e preocupações com a privacidade, ou renunciar totalmente aos seus benefícios. Frequentemente, os desenvolvedores não conseguem corrigir vulnerabilidades dentro desses SDKs por conta própria. Além disso, à medida que os SDKs ganham confiança na comunidade, alguns podem começar a conter malware.

Os serviços fornecidos por SDKs de terceiros podem incluir rastreamento de comportamento do usuário, exibição de anúncios ou melhorias na experiência do usuário. Contudo, isso introduz um risco, pois os desenvolvedores podem não estar totalmente cientes do código executado por essas bibliotecas, levando a potenciais riscos de privacidade e segurança. É crucial limitar as informações compartilhadas com serviços de terceiros ao necessário e garantir que nenhum dado sensível seja exposto.

A implementação de serviços de terceiros geralmente ocorre de duas formas: uma biblioteca independente ou um SDK completo. Para proteger a privacidade do usuário, quaisquer dados compartilhados com esses serviços devem ser **anonimizados** para evitar a divulgação de Personal Identifiable Information (PII).

Para identificar as bibliotecas que uma aplicação usa, o comando **`otool`** pode ser empregado. Essa ferramenta deve ser executada contra a aplicação e cada biblioteca compartilhada que ela usa para descobrir bibliotecas adicionais.
```bash
otool -L <application_path>
```
## Vulnerabilidades Interessantes & Estudos de Caso


{{#ref}}
air-keyboard-remote-input-injection.md
{{#endref}}

{{#ref}}
itunesstored-bookassetd-sandbox-escape.md
{{#endref}}

{{#ref}}
zero-click-messaging-image-parser-chains.md
{{#endref}}

## **Referências & Mais Recursos**

- [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering)
- [iOS & Mobile App Pentesting - INE](https://my.ine.com/CyberSecurity/courses/089d060b/ios-mobile-app-pentesting)
- [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/)
- [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/)
- [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/)
- [https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage](https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage)
- [https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way](https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053)
- [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060)
- [https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/](https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064](https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064)
- [https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc](https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054)
- [https://github.com/ivRodriguezCA/RE-iOS-Apps/](https://github.com/ivRodriguezCA/RE-iOS-Apps/) curso gratuito iOS([https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/](https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/))
- [https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577](https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577)
- [https://www.slideshare.net/RyanISI/ios-appsecurityminicourse](https://www.slideshare.net/RyanISI/ios-appsecurityminicourse)
- [https://github.com/prateek147/DVIA](https://github.com/prateek147/DVIA)
- [https://github.com/prateek147/DVIA-v2](https://github.com/prateek147/DVIA-v2)
- [https://github.com/OWASP/MSTG-Hacking-Playground%20](https://github.com/OWASP/MSTG-Hacking-Playground)
- OWASP iGoat [_https://github.com/OWASP/igoat_](https://github.com/OWASP/igoat) <<< versão Objective-C [_https://github.com/OWASP/iGoat-Swift_](https://github.com/OWASP/iGoat-Swift) <<< versão Swift
- [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
- [https://github.com/nabla-c0d3/ssl-kill-switch2](https://github.com/nabla-c0d3/ssl-kill-switch2)


{{#include ../../banners/hacktricks-training.md}}
