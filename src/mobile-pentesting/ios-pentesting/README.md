# iOS Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Osnove iOS-a


{{#ref}}
ios-basics.md
{{#endref}}

## Okruženje za testiranje

Na ovoj stranici možete pronaći informacije o **iOS simulatoru**, **emulatorima** i **jailbreakingu:**


{{#ref}}
ios-testing-environment.md
{{#endref}}

## Početna analiza

### Osnovne iOS operacije testiranja

Tokom testiranja biće predloženo **nekoliko operacija** (povezivanje sa uređajem, čitanje/pisanje/upload/download fajlova, korišćenje nekih alata...). Stoga, ako ne znate kako da izvedete bilo koju od ovih radnji, molimo vas **počnite sa čitanjem stranice**:


{{#ref}}
basic-ios-testing-operations.md
{{#endref}}

> [!TIP]
> Za sledeće korake **aplikacija treba da bude instalirana** na uređaju i treba da imate već dobijen **IPA file** aplikacije.\
> Read the [Basic iOS Testing Operations](basic-ios-testing-operations.md) page to learn how to do this.

### Osnovna statička analiza

Neki interesantni iOS - IPA dekompajleri:

- [https://github.com/LaurieWired/Malimite](https://github.com/LaurieWired/Malimite)
- [https://ghidra-sre.org/](https://ghidra-sre.org/)

Preporučuje se korišćenje alata [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) za automatsku statičku analizu IPA fajla.

Identifikacija **zaštita prisutnih u binarnom fajlu**:

- **PIE (Position Independent Executable)**: Kada je omogućen, aplikacija se učitava na nasumičnu memorijsku adresu pri svakom pokretanju, što otežava predviđanje početne memorijske adrese.

```bash
otool -hv <app-binary> | grep PIE   # It should include the PIE flag
```

- **Stack Canaries**: Da bi se verifikovao integritet stack-a, vrednost ‘canary’ se postavlja na stack pre poziva funkcije i ponovo proverava kada funkcija završi.

```bash
otool -I -v <app-binary> | grep stack_chk   # It should include the symbols: stack_chk_guard and stack_chk_fail
```

- **ARC (Automatic Reference Counting)**: Za sprečavanje uobičajenih grešaka usled korupcije memorije

```bash
otool -I -v <app-binary> | grep objc_release   # It should include the _objc_release symbol
```

- **Encrypted Binary**: Binarni fajl bi trebalo da bude enkriptovan

```bash
otool -arch all -Vl <app-binary> | grep -A5 LC_ENCRYPT   # The cryptid should be 1
```

**Identifikacija osetljivih/nesigurnih funkcija**

- **Slabi heš algoritmi**

```bash
# On the iOS device
otool -Iv <app> | grep -w "_CC_MD5"
otool -Iv <app> | grep -w "_CC_SHA1"

# On linux
grep -iER "_CC_MD5"
grep -iER "_CC_SHA1"
```

- **Nesigurne random funkcije**

```bash
# On the iOS device
otool -Iv <app> | grep -w "_random"
otool -Iv <app> | grep -w "_srand"
otool -Iv <app> | grep -w "_rand"

# On linux
grep -iER "_random"
grep -iER "_srand"
grep -iER "_rand"
```

- **Nesigurna ‘Malloc’ funkcija**

```bash
# On the iOS device
otool -Iv <app> | grep -w "_malloc"

# On linux
grep -iER "_malloc"
```

- **Nesigurne i ranjive funkcije**

```bash
# On the iOS device
otool -Iv <app> | grep -w "_gets"
otool -Iv <app> | grep -w "_memcpy"
otool -Iv <app> | grep -w "_strncpy"
otool -Iv <app> | grep -w "_strlen"
otool -Iv <app> | grep -w "_vsnprintf"
otool -Iv <app> | grep -w "_sscanf"
otool -Iv <app> | grep -w "_strtok"
otool -Iv <app> | grep -w "_alloca"
otool -Iv <app> | grep -w "_sprintf"
otool -Iv <app> | grep -w "_printf"
otool -Iv <app> | grep -w "_vsprintf"

# On linux
grep -R "_gets"
grep -iER "_memcpy"
grep -iER "_strncpy"
grep -iER "_strlen"
grep -iER "_vsnprintf"
grep -iER "_sscanf"
grep -iER "_strtok"
grep -iER "_alloca"
grep -iER "_sprintf"
grep -iER "_printf"
grep -iER "_vsprintf"
```

#### Uobičajene metode detekcije jailbreak-a

- **Provere fajl sistema**: Potražite prisustvo uobičajenih jailbreak fajlova i direktorijuma, poput `/Applications/Cydia.app` ili `/Library/MobileSubstrate/MobileSubstrate.dylib`.
- **Pokušaji kršenja sandbox-a**: Pokušajte da pristupite ograničenim delovima fajl sistema, koji bi na ne-jailbroken uređajima trebalo da budu blokirani.
- **Provere API-ja**: Proverite da li je moguće koristiti zabranjene pozive poput `fork()` za kreiranje child procesa ili `system()` da vidite da li /bin/sh postoji.
- **Provere procesa**: Pratite prisustvo poznatih procesa vezanih za jailbreak, kao što su `Cydia`, `Substrate`, ili `ssh`.
- **Kernel Exploits**: Proverite prisustvo kernel exploit-ova koji se obično koriste u jailbreak procedurama.
- **Environment Variables**: Ispitajte environment varijable za tragove jailbreak-a, kao što je `DYLD_INSERT_LIBRARIES`.
- **Provera biblioteka**: Proverite koje su libs učitane u procesu aplikacije.
- **Provera shema**: Na primer `canOpenURL(URL(string: "cydia://"))`.

#### Uobičajene metode detekcije anti-debugginga

- **Provera prisustva debagera**: Koristite `sysctl` ili druge metode da proverite da li je debager priključen.
- **Anti-debugging API-ji**: Potražite pozive ka anti-debugging API-jima kao što su `ptrace` ili `SIGSTOP`, npr. `ptrace(PT_DENY_ATTACH, 0, 0, 0)`.
- **Provere vremenskih razlika**: Merite vreme izvršavanja određenih operacija i tražite diskrepancije koje mogu ukazivati na debagovanje.
- **Provere memorije**: Pregledajte memoriju u potrazi za poznatim artefaktima debagera ili modifikacijama.
- **Environment Variables**: Proverite environment varijable koje mogu ukazivati na debag sesiju.
- **Mach Ports**: Detektujte da li se mach exception portovi koriste od strane debagera.

### Osnovna dinamička analiza

Pogledajte dinamičku analizu koju [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) izvodi. Moraćete da prolazite kroz različite prikaze i interagujete sa njima; alat će hook-ovati nekoliko klasa i obavljati druge radnje, i pripremiće izveštaj kada završite.

### Lista instaliranih aplikacija

Koristite komandu `frida-ps -Uai` da odredite **bundle identifier** instaliranih aplikacija:
```bash
$ frida-ps -Uai
PID  Name                 Identifier
----  -------------------  -----------------------------------------
6847  Calendar             com.apple.mobilecal
6815  Mail                 com.apple.mobilemail
-  App Store            com.apple.AppStore
-  Apple Store          com.apple.store.Jolly
-  Calculator           com.apple.calculator
-  Camera               com.apple.camera
-  iGoat-Swift          OWASP.iGoat-Swift
```
### Osnovna enumeracija & Hooking

Naučite kako da **enumerišete komponente aplikacije** i kako lako da **hook-ujete metode i klase** pomoću objection:


{{#ref}}
ios-hooking-with-objection.md
{{#endref}}

### IPA Structure

Struktura **IPA fajla** je suštinski ista kao i kod **zipovanog paketa**. Preimenovanjem ekstenzije u `.zip` može se **dekompresovati** i otkriti njen sadržaj. U ovoj strukturi, **Bundle** predstavlja potpuno zapakovanu aplikaciju spremnu za instalaciju. Unutar njega ćete naći direktorijum nazvan `<NAME>.app`, koji enkapsulira resurse aplikacije.

- **`Info.plist`**: Ovaj fajl sadrži specifične konfiguracione detalje aplikacije.
- **`_CodeSignature/`**: Ovaj direktorijum uključuje plist fajl koji sadrži potpis, osiguravajući integritet svih fajlova u bundle-u.
- **`Assets.car`**: Kompresovani arhiv koji čuva asset fajlove kao što su ikone.
- **`Frameworks/`**: Ova fascikla sadrži native biblioteke aplikacije, koje mogu biti u obliku `.dylib` ili `.framework` fajlova.
- **`PlugIns/`**: Ovo može uključivati ekstenzije aplikacije, poznate kao `.appex` fajlovi, iako nisu uvek prisutni. \* [**`Core Data`**](https://developer.apple.com/documentation/coredata): It is used to save your application’s permanent data for offline use, to cache temporary data, and to add undo functionality to your app on a single device. To sync data across multiple devices in a single iCloud account, Core Data automatically mirrors your schema to a CloudKit container.
- [**`PkgInfo`**](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigApplications.html): Fajl `PkgInfo` je alternativni način da se specificiraju type i creator kodovi vaše aplikacije ili bundle-a.
- **en.lproj, fr.proj, Base.lproj**: Jezicke pakete koji sadrže resurse za te konkretne jezike, kao i podrazumevani resurs u slučaju da određeni jezik nije podržan.
- **Security**: Direktorijum `_CodeSignature/` igra kritičnu ulogu u bezbednosti aplikacije verifikujući integritet svih fajlova u bundle-u putem digitalnih potpisa.
- **Asset Management**: Fajl `Assets.car` koristi kompresiju za efikasno upravljanje grafičkim resursima, što je ključno za optimizaciju performansi aplikacije i smanjenje ukupne veličine.
- **Frameworks and PlugIns**: Ovi direktorijumi naglašavaju modularnost iOS aplikacija, omogućavajući developerima da uključe ponovo upotrebljive biblioteke koda (`Frameworks/`) i prošire funkcionalnost aplikacije (`PlugIns/`).
- **Localization**: Struktura podržava više jezika, olakšavajući globalno širenje aplikacije uključivanjem resursa za specifične jezičke pakete.

**Info.plist**

**Info.plist** služi kao temelj za iOS aplikacije, enkapsulira ključne konfiguracione podatke u obliku **key-value** parova. Ovaj fajl je obavezan ne samo za aplikacije već i za app extensions i framework-e koji su bundled unutar aplikacije. Strukturiran je u XML ili binarnom formatu i sadrži kritične informacije koje se kreću od dozvola aplikacije do bezbednosnih podešavanja. Za detaljnije istraživanje dostupnih ključeva, možete pogledati [**Apple Developer Documentation**](https://developer.apple.com/documentation/bundleresources/information_property_list?language=objc).

Za one koji žele da rade sa ovim fajlom u pristupačnijem formatu, konverzija u XML se može lako ostvariti korišćenjem `plutil` na macOS (dostupan nativno od verzije 10.2 i novije) ili `plistutil` na Linux-u. Komande za konverziju su sledeće:

- **For macOS**:
```bash
$ plutil -convert xml1 Info.plist
```
- **Za Linux**:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
Među mnoštvom informacija koje fajl **Info.plist** može otkriti, značajne stavke uključuju stringove dozvola aplikacije (`UsageDescription`), prilagođene URL scheme-ove (`CFBundleURLTypes`) i konfiguracije za App Transport Security (`NSAppTransportSecurity`). Ove stavke, zajedno sa drugim, poput izvezenih/uvozenih prilagođenih tipova dokumenata (`UTExportedTypeDeclarations` / `UTImportedTypeDeclarations`), mogu se lako pronaći pregledom fajla ili korišćenjem jednostavne `grep` komande:
```bash
$ grep -i <keyword> Info.plist
```
**Putanje podataka**

U iOS okruženju, direktorijumi su posebno namenjeni za **system applications** i **user-installed applications**. System applications se nalaze u direktorijumu `/Applications`, dok se user-installed apps postavljaju pod `/var/mobile/containers/Data/Application/`. Tim aplikacijama dodeljuje se jedinstveni identifikator poznat kao **128-bit UUID**, što otežava ručno pronalaženje foldera aplikacije zbog nasumičnosti imena direktorijuma.

> [!WARNING]
> Pošto aplikacije na iOS moraju biti sandboxovane, svaka aplikacija će takođe imati folder unutar **`$HOME/Library/Containers`** sa **`CFBundleIdentifier`** aplikacije kao imenom foldera.
>
> Međutim, oba foldera (data & container folders) imaju fajl **`.com.apple.mobile_container_manager.metadata.plist`** koji povezuje oba foldera u ključu `MCMetadataIdentifier`).

Da bi se olakšalo otkrivanje direktorijuma u kojem je instalirana user-installed aplikacija, **objection tool** pruža korisnu komandu `env`. Ova komanda prikazuje detaljne informacije o direktorijumima za konkretnu aplikaciju. Ispod je primer kako koristiti ovu komandu:
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # env

Name               Path
-----------------  -------------------------------------------------------------------------------------------
BundlePath         /var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app
CachesDirectory    /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library/Caches
DocumentDirectory  /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Documents
LibraryDirectory   /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library
```
Alternativno, ime aplikacije može da se pretraži u `/private/var/containers` korišćenjem komande `find`:
```bash
find /private/var/containers -name "Progname*"
```
Komande kao što su `ps` i `lsof` takođe se mogu koristiti za identifikovanje procesa aplikacije, odnosno za listanje otvorenih fajlova, pružajući uvid u aktivne putanje direktorijuma aplikacije:
```bash
ps -ef | grep -i <app-name>
lsof -p <pid> | grep -i "/containers" | head -n 1
```
**Bundle direktorijum:**

- **AppName.app**
- Ovo je Application Bundle kao što je ranije viđeno u IPA, sadrži ključne podatke aplikacije, statički sadržaj kao i kompajlirani binarni fajl aplikacije.
- Ovaj direktorijum je vidljiv korisnicima, ali **korisnici ne mogu pisati u njega**.
- Sadržaj u ovom direktorijumu **nije uključen u rezervnu kopiju**.
- Sadržaj ovog foldera se koristi za **validaciju potpisa koda**.

**Data direktorijum:**

- **Documents/**
- Sadrži sve podatke koje generiše korisnik. Krajnji korisnik aplikacije inicira kreiranje ovih podataka.
- Vidljivo korisnicima i **korisnici mogu pisati u njega**.
- Sadržaj u ovom direktorijumu **je uključen u rezervnu kopiju**.
- Aplikacija može isključiti putanje postavljanjem `NSURLIsExcludedFromBackupKey`.
- **Library/**
- Sadrži sve **fajlove koji nisu specifični za korisnika**, kao što su **caches**, **preferences**, **cookies**, i property list (plist) konfiguracioni fajlovi.
- iOS aplikacije obično koriste poddirektorijume `Application Support` i `Caches`, ali aplikacija može kreirati prilagođene poddirektorijume.
- **Library/Caches/**
- Sadrži **polu-persistentne keširane fajlove.**
- Nevidljivo korisnicima i **korisnici ne mogu pisati u njega**.
- Sadržaj u ovom direktorijumu **nije uključen u rezervnu kopiju**.
- OS može automatski obrisati fajlove iz ovog direktorijuma kada aplikacija ne radi i kada je slobodan prostor na disku nizak.
- **Library/Application Support/**
- Sadrži **trajne** **fajlove** neophodne za rad aplikacije.
- **Nevidljivo** **za** **korisnike** i korisnici ne mogu pisati u njega.
- Sadržaj u ovom direktorijumu **je uključen u rezervnu kopiju**.
- Aplikacija može isključiti putanje postavljanjem `NSURLIsExcludedFromBackupKey`.
- **Library/Preferences/**
- Koristi se za čuvanje svojstava koja mogu **ostati sačuvana čak i nakon ponovnog pokretanja aplikacije**.
- Informacije se čuvaju, nekriptovano, unutar sandboxa aplikacije u plist fajlu nazvanom \[BUNDLE_ID].plist.
- Svi key/value parovi sačuvani korišćenjem `NSUserDefaults` mogu se naći u ovom fajlu.
- **tmp/**
- Koristite ovaj direktorijum za upis **privremenih fajlova** koji ne moraju da opstanu između pokretanja aplikacije.
- Sadrži ne-perzistentne keširane fajlove.
- **Nevidljivo** korisnicima.
- Sadržaj u ovom direktorijumu nije uključen u rezervnu kopiju.
- OS može automatski obrisati fajlove iz ovog direktorijuma kada aplikacija ne radi i kada je slobodan prostor na disku nizak.

Let's take a closer look at iGoat-Swift's Application Bundle (.app) directory inside the Bundle directory (`/var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app`):
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # ls
NSFileType      Perms  NSFileProtection    ...  Name
------------  -------  ------------------  ...  --------------------------------------
Regular           420  None                ...  rutger.html
Regular           420  None                ...  mansi.html
Regular           420  None                ...  splash.html
Regular           420  None                ...  about.html

Regular           420  None                ...  LICENSE.txt
Regular           420  None                ...  Sentinel.txt
Regular           420  None                ...  README.txt
```
### Binary Reversing

U folderu `<application-name>.app` naći ćete binarni fajl nazvan `<application-name>`. Ovo je fajl koji će biti **izvršen**. Možete obaviti osnovnu inspekciju binarnog fajla koristeći alat **`otool`**:
```bash
otool -Vh DVIA-v2 #Check some compilation attributes
magic  cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64    ARM64        ALL  0x00     EXECUTE    65       7112   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE

otool -L DVIA-v2 #Get third party libraries
DVIA-v2:
/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.1)
/usr/lib/libsqlite3.dylib (compatibility version 9.0.0, current version 274.6.0)
/usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11)
@rpath/Bolts.framework/Bolts (compatibility version 1.0.0, current version 1.0.0)
[...]
```
**Proverite da li je aplikacija šifrovana**

Pogledajte da li postoji bilo kakav izlaz za:
```bash
otool -l <app-binary> | grep -A 4 LC_ENCRYPTION_INFO
```
**Disasembliranje binarne datoteke**

Disasemblirajte .text sekciju:
```bash
otool -tV DVIA-v2
DVIA-v2:
(__TEXT,__text) section
+[DDLog initialize]:
0000000100004ab8    sub    sp, sp, #0x60
0000000100004abc    stp    x29, x30, [sp, #0x50]   ; Latency: 6
0000000100004ac0    add    x29, sp, #0x50
0000000100004ac4    sub    x8, x29, #0x10
0000000100004ac8    mov    x9, #0x0
0000000100004acc    adrp    x10, 1098 ; 0x10044e000
0000000100004ad0    add    x10, x10, #0x268
```
Da biste ispisali **Objective-C segment** primer aplikacije, možete koristiti:
```bash
otool -oV DVIA-v2
DVIA-v2:
Contents of (__DATA,__objc_classlist) section
00000001003dd5b8 0x1004423d0 _OBJC_CLASS_$_DDLog
isa        0x1004423a8 _OBJC_METACLASS_$_DDLog
superclass 0x0 _OBJC_CLASS_$_NSObject
cache      0x0 __objc_empty_cache
vtable     0x0
data       0x1003de748
flags          0x80
instanceStart  8
```
Da biste dobili kompaktniji Objective-C kod, možete koristiti [**class-dump**](http://stevenygard.com/projects/class-dump/):
```bash
class-dump some-app
//
//     Generated by class-dump 3.5 (64 bit).
//
//     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2013 by Steve Nygard.
//

#pragma mark Named Structures

struct CGPoint {
double _field1;
double _field2;
};

struct CGRect {
struct CGPoint _field1;
struct CGSize _field2;
};

struct CGSize {
double _field1;
double _field2;
};
```
Međutim, najbolje opcije za disasembliranje binarnog fajla su: [**Hopper**](https://www.hopperapp.com/download.html?) i [**IDA**](https://www.hex-rays.com/products/ida/support/download_freeware/).

## Čuvanje podataka

Da biste saznali kako iOS skladišti podatke na uređaju, pročitajte ovu stranicu:


{{#ref}}
ios-basics.md
{{#endref}}

> [!WARNING]
> Sledeća mesta za čuvanje informacija treba proveriti **odmah nakon instalacije aplikacije**, **nakon provere svih funkcionalnosti** aplikacije i čak nakon **odjave jednog korisnika i prijave drugog**.\
> Cilj je pronaći **nezaštićene osetljive informacije** aplikacije (passwords, tokens), trenutnog korisnika i prethodno prijavljenih korisnika.

### Plist

**plist** fajlovi su strukturisani XML fajlovi koji sadrže **parove ključ-vrednost**. To je način za čuvanje perzistentnih podataka, tako da ponekad možete naći **osetljive informacije u tim fajlovima**. Preporučuje se proveriti ove fajlove nakon instalacije aplikacije i nakon intenzivnog korišćenja da biste videli da li su upisani novi podaci.

Najčešći način za persistiranje podataka u plist fajlovima je kroz korišćenje **NSUserDefaults**. Ovaj plist fajl se čuva unutar sandbox-a aplikacije u **`Library/Preferences/<appBundleID>.plist`**

Klasa [`NSUserDefaults`](https://developer.apple.com/documentation/foundation/nsuserdefaults) pruža programski interfejs za interakciju sa default sistemom. Default sistem omogućava aplikaciji da prilagodi svoje ponašanje prema **korisničkim podešavanjima**. Podaci sačuvani pomoću `NSUserDefaults` mogu se pregledati u bundle-u aplikacije. Ova klasa čuva **podatke** u **plist** **fajlu**, ali je namenjena za male količine podataka.

Ovi podaci više ne mogu biti direktno pristupljeni putem pouzdanog računara, ali im se može pristupiti pravljenjem **backup**-a.

Možete **dump**-ovati informacije sačuvane pomoću **`NSUserDefaults`** koristeći objection komandu `ios nsuserdefaults get`

Da biste pronašli sve plist fajlove koje koristi aplikacija, možete pristupiti `/private/var/mobile/Containers/Data/Application/{APPID}` i pokrenuti:
```bash
find ./ -name "*.plist"
```
Da biste konvertovali fajlove iz **XML or binary (bplist)** formata u XML, dostupne su različite metode u zavisnosti od vašeg operativnog sistema:

**Za macOS korisnike:** Koristite komandu `plutil`. To je ugrađeni alat u macOS-u (10.2+), namenjen upravo za ovu svrhu:
```bash
$ plutil -convert xml1 Info.plist
```
**Za Linux korisnike:** Prvo instalirajte `libplist-utils`, zatim koristite `plistutil` da konvertujete svoj fajl:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
**Unutar Objection sesije:** Za analizu mobilnih aplikacija, posebna komanda vam omogućava da direktno konvertujete plist fajlove:
```bash
ios plist cat /private/var/mobile/Containers/Data/Application/<Application-UUID>/Library/Preferences/com.some.package.app.plist
```
### Core Data

[`Core Data`](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/nsfetchedresultscontroller.html#//apple_ref/doc/uid/TP40001075-CH8-SW1) je framework za upravljanje slojem modela objekata u vašoj aplikaciji. [Core Data can use SQLite as its persistent store](https://cocoacasts.com/what-is-the-difference-between-core-data-and-sqlite/), ali sam framework nije baza podataka.\
CoreData podrazumevano ne šifruje svoje podatke. Međutim, može se dodati dodatni sloj šifrovanja za CoreData. Pogledajte [GitHub Repo](https://github.com/project-imas/encrypted-core-data) za više detalja.

Informacije o SQLite Core Data jedne aplikacije možete pronaći na putanji `/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support`

**Ako možete otvoriti SQLite i pristupiti osetljivim informacijama, onda ste pronašli pogrešnu konfiguraciju.**
```objectivec:Code from iGoat
-(void)storeDetails {
AppDelegate * appDelegate = (AppDelegate *)(UIApplication.sharedApplication.delegate);

NSManagedObjectContext *context =[appDelegate managedObjectContext];

User *user = [self fetchUser];
if (user) {
return;
}
user = [NSEntityDescription insertNewObjectForEntityForName:@"User"
inManagedObjectContext:context];
user.email = CoreDataEmail;
user.password = CoreDataPassword;
NSError *error;
if (![context save:&error]) {
NSLog(@"Error in saving data: %@", [error localizedDescription]);

}else{
NSLog(@"data stored in core data");
}
}
```
### YapDatabase

[YapDatabase](https://github.com/yapstudios/YapDatabase) je key/value store izgrađen na vrhu SQLite.\
Pošto su Yap baze sqlite baze, možete ih pronaći koristeći komandu navedenu u prethodnom odeljku.

### Other SQLite Databases

Uobičajeno je da aplikacije kreiraju sopstvenu sqlite bazu. One mogu na njima **čuvati** **osetljive** **podatke** i ostavljati ih nešifrovanim. Zato je uvek interesantno proveriti svaku bazu unutar direktorijuma aplikacije. Dakle, idite u direktorijum aplikacije gde su podaci sačuvani (`/private/var/mobile/Containers/Data/Application/{APPID}`)
```bash
find ./ -name "*.sqlite" -or -name "*.db"
```
### Firebase Real-Time Databases

Programeri mogu da **smeštaju i sinhronizuju podatke** u **NoSQL bazi podataka smeštenoj u cloudu** preko Firebase Real-Time Databases. Podaci se čuvaju u JSON formatu i sinhronizuju se svim povezanim klijentima u realnom vremenu.

You can find how to check for misconfigured Firebase databases here:


{{#ref}}
../../network-services-pentesting/pentesting-web/buckets/firebase-database.md
{{#endref}}

### Realm databases

[Realm Objective-C](https://realm.io/docs/objc/latest/) and [Realm Swift](https://realm.io/docs/swift/latest/) nude snažnu alternativu za čuvanje podataka, koju ne obezbeđuje Apple. Po defaultu, one **smeštaju podatke nešifrovano**, dok je enkripcija dostupna kroz specifičnu konfiguraciju.

The databases are located at: `/private/var/mobile/Containers/Data/Application/{APPID}`. To explore these files, one can utilize commands like:
```bash
iPhone:/private/var/mobile/Containers/Data/Application/A079DF84-726C-4AEA-A194-805B97B3684A/Documents root# ls
default.realm  default.realm.lock  default.realm.management/  default.realm.note|

$ find ./ -name "*.realm*"
```
Za pregled ovih fajlova baze podataka preporučuje se alat [**Realm Studio**](https://github.com/realm/realm-studio).

Za implementaciju enkripcije u Realm bazi podataka može se koristiti sledeći kod:
```swift
// Open the encrypted Realm file where getKey() is a method to obtain a key from the Keychain or a server
let config = Realm.Configuration(encryptionKey: getKey())
do {
let realm = try Realm(configuration: config)
// Use the Realm as normal
} catch let error as NSError {
// If the encryption key is wrong, `error` will say that it's an invalid database
fatalError("Error opening realm: \(error)")
}
```
### Couchbase Lite baze podataka

[Couchbase Lite](https://github.com/couchbase/couchbase-lite-ios) opisuje se kao **lagan** i **ugrađen** engine baze podataka koji prati **dokument-orijentisani** (NoSQL) pristup. Dizajniran da bude nativan za **iOS** i **macOS**, omogućava besprekornu sinhronizaciju podataka.

Da biste identifikovali potencijalne Couchbase baze na uređaju, treba pregledati sledeći direktorijum:
```bash
ls /private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support/
```
### Kolačići

iOS čuva cookies aplikacija u **`Library/Cookies/cookies.binarycookies`** unutar foldera svake aplikacije. Međutim, developeri ponekad odluče da ih sačuvaju u **keychain** jer pomenuti **cookie file može biti dostupan u backup-ima**.

Za pregled cookies fajla možete koristiti [**this python script**](https://github.com/mdegrazia/Safari-Binary-Cookie-Parser) ili koristiti objection-ovu komandu **`ios cookies get`.**\
**Takođe možete koristiti objection da** konvertujete ove fajlove u JSON format i pregledate podatke.
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios cookies get --json
[
{
"domain": "highaltitudehacks.com",
"expiresDate": "2051-09-15 07:46:43 +0000",
"isHTTPOnly": "false",
"isSecure": "false",
"name": "username",
"path": "/",
"value": "admin123",
"version": "0"
}
]
```
### Keš

Podrazumevano NSURLSession čuva podatke, kao što su **HTTP requests and responses in the Cache.db** baza podataka. Ova baza može sadržati **osetljive podatke**, ako su tokeni, korisnička imena ili bilo koje druge osetljive informacije keširane. Da biste pronašli keširane informacije otvorite direktorijum podataka aplikacije (`/var/mobile/Containers/Data/Application/<UUID>`) i idite na `/Library/Caches/<Bundle Identifier>`. **WebKit cache is also being stored in the Cache.db** fajl. **Objection** može otvoriti i raditi sa bazom koristeći komandu `sqlite connect Cache.db`, pošto je u pitanju obična **SQLite database**.

Preporučuje se onemogućiti keširanje ovih podataka, jer mogu sadržati osetljive informacije u zahtevu ili odgovoru. Lista ispod prikazuje različite načine kako to postići:

1.  Preporučuje se ukloniti Cached responses nakon logout-a. Ovo se može uraditi pomoću metode koju je obezbedio Apple pod nazivom [`removeAllCachedResponses`](https://developer.apple.com/documentation/foundation/urlcache/1417802-removeallcachedresponses) Metodu možete pozvati na sledeći način:

`URLCache.shared.removeAllCachedResponses()`

Ova metoda će ukloniti sve keširane zahteve i odgovore iz Cache.db fajla.

2.  Ako vam nije potrebna prednost korišćenja cookies, preporučljivo je koristiti [.ephemeral](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral) konfiguracionu osobinu URLSession-a, koja će onemogućiti čuvanje cookies i keševa.

[Apple documentation](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral):

`An ephemeral session configuration object is similar to a default session configuration (see default), except that the corresponding session object doesn’t store caches, credential stores, or any session-related data to disk. Instead, session-related data is stored in RAM. The only time an ephemeral session writes data to disk is when you tell it to write the contents of a URL to a file.`

3.  Keš se takođe može onemogućiti podešavanjem Cache Policy na [.notAllowed](https://developer.apple.com/documentation/foundation/urlcache/storagepolicy/notallowed). Ovo će onemogućiti čuvanje Cache na bilo koji način, bilo u memoriji ili na disku.

### Snapshots

Kad pritisnete dugme Home, iOS **takes a snapshot of the current screen** da bi tranzicija ka aplikaciji bila mnogo glađa. Međutim, ako se na trenutnom ekranu nalazi **osetljiv** **sadržaj**, biće **sačuvan** u **slici** (koja **persistira** **preko** **reboota**). To su snimci koje možete takođe videti dvostrukim pritiskom na dugme Home da biste prešli između aplikacija.

Ako iPhone nije jailbroken, **napadač** mora imati **pristup** **uređaju** **otključanom** da bi video ove snimke. Po defaultu poslednji snapshot se čuva u sandbox-u aplikacije u `Library/Caches/Snapshots/` ili `Library/SplashBoard/Snapshots` folderu (trusted computers can't access the filesystem from iOX 7.0).

Jedan način da se spreči ovo loše ponašanje je postaviti prazan ekran ili ukloniti osetljive podatke pre pravljenja snapshot-a koristeći funkciju `ApplicationDidEnterBackground()`.

Ispod je primer metoda za remedijaciju koji postavlja podrazumevani screenshot.

Swift:
```swift
private var backgroundImage: UIImageView?

func applicationDidEnterBackground(_ application: UIApplication) {
let myBanner = UIImageView(image: #imageLiteral(resourceName: "overlayImage"))
myBanner.frame = UIScreen.main.bounds
backgroundImage = myBanner
window?.addSubview(myBanner)
}

func applicationWillEnterForeground(_ application: UIApplication) {
backgroundImage?.removeFromSuperview()
}
```
Objective-C:
```
@property (UIImageView *)backgroundImage;

- (void)applicationDidEnterBackground:(UIApplication *)application {
UIImageView *myBanner = [[UIImageView alloc] initWithImage:@"overlayImage.png"];
self.backgroundImage = myBanner;
self.backgroundImage.bounds = UIScreen.mainScreen.bounds;
[self.window addSubview:myBanner];
}

- (void)applicationWillEnterForeground:(UIApplication *)application {
[self.backgroundImage removeFromSuperview];
}
```
Ovo postavlja pozadinsku sliku na `overlayImage.png` svaki put kada se aplikacija prebaci u background. Sprečava sensitive data leaks zato što će `overlayImage.png` uvek prebrisati trenutni prikaz.

### Keychain

Za pristup i upravljanje iOS keychain-om dostupni su alati poput [**Keychain-Dumper**](https://github.com/ptoomey3/Keychain-Dumper), pogodni za jailbroken uređaje. Pored toga, [**Objection**](https://github.com/sensepost/objection) pruža komandu `ios keychain dump` za slične namene.

#### **Storing Credentials**

Klasa **NSURLCredential** je idealna za čuvanje osetljivih informacija direktno u keychain, zaobilazeći potrebu za NSUserDefaults ili drugim wrappers. Za čuvanje credentials nakon prijave koristi se sledeći Swift kod:
```swift
NSURLCredential *credential;
credential = [NSURLCredential credentialWithUser:username password:password persistence:NSURLCredentialPersistencePermanent];
[[NSURLCredentialStorage sharedCredentialStorage] setCredential:credential forProtectionSpace:self.loginProtectionSpace];
```
Za izdvajanje ovih sačuvanih akreditiva koristi se Objection-ova komanda `ios nsurlcredentialstorage dump`.

## **Custom Keyboards and Keyboard Cache**

Sa iOS 8.0 nadalje, korisnici mogu instalirati custom keyboard ekstenzije, kojima se upravlja preko **Settings > General > Keyboard > Keyboards**. Iako ove tastature nude proširenu funkcionalnost, predstavljaju rizik od keystroke logging-a i slanja podataka na eksterni server, mada se korisnici obaveštavaju o tastaturama koje zahtevaju mrežni pristup. Aplikacije mogu, i treba da, ograniče upotrebu custom keyboards za unos osetljivih informacija.

**Security Recommendations:**

- Preporučuje se onemogućavanje third-party keyboards radi poboljšane bezbednosti.
- Obratite pažnju na autocorrect i auto-suggestions funkcije default iOS keyboard, koje mogu čuvati osetljive informacije u keš fajlovima lociranim u `Library/Keyboard/{locale}-dynamic-text.dat` ili `/private/var/mobile/Library/Keyboard/dynamic-text.dat`. Ovi keš fajlovi bi trebalo redovno proveravati zbog osetljivih podataka. Resetovanje keyboard dictionary putem **Settings > General > Reset > Reset Keyboard Dictionary** se preporučuje za brisanje keširanih podataka.
- Presretanje mrežnog saobraćaja može otkriti da li custom keyboard prenosi keystrokes na daljinu.

### **Preventing Text Field Caching**

The [UITextInputTraits protocol](https://developer.apple.com/reference/uikit/uitextinputtraits) nudi properties za upravljanje autocorrection i secure text entry, koje su bitne za sprečavanje keširanja osetljivih informacija. Na primer, onemogućavanje autocorrection i omogućavanje secure text entry može se postići sa:
```objectivec
textObject.autocorrectionType = UITextAutocorrectionTypeNo;
textObject.secureTextEntry = YES;
```
Pored toga, developeri treba da obezbede da tekstualna polja, naročito ona za unos osetljivih podataka kao što su lozinke i PIN-ovi, onemoguće keširanje podešavanjem `autocorrectionType` na `UITextAutocorrectionTypeNo` i `secureTextEntry` na `YES`.
```objectivec
UITextField *textField = [[UITextField alloc] initWithFrame:frame];
textField.autocorrectionType = UITextAutocorrectionTypeNo;
```
## **Logs**

Otklanjanje grešaka u kodu često uključuje upotrebu **logging**. Postoji rizik jer **logs mogu da sadrže osetljive informacije**. Ranije, u iOS 6 i prethodnim verzijama, logs su bili dostupni svim aplikacijama, što je predstavljalo rizik od curenja osetljivih podataka. **Sada su aplikacije ograničene da pristupe samo svojim logs**.

Uprkos ovim ograničenjima, **napadač sa fizičkim pristupom** otključanom uređaju i dalje može ovo iskoristiti povezivanjem uređaja sa računarom i **čitanjem logs**. Važno je napomenuti da logs ostaju na disku čak i nakon deinstalacije aplikacije.

Da bi se ublažili rizici, preporučuje se **temeljno korišćenje aplikacije**, istražujući sve njene funkcionalnosti i ulaze kako bi se osiguralo da nijedna osetljiva informacija nije nenamerno zapisana u logs.

Prilikom pregleda izvornog koda aplikacije zbog potencijalnih leaks, tražite i **predefinisane** i **prilagođene logging izjave** koristeći ključne reči kao što su `NSLog`, `NSAssert`, `NSCAssert`, `fprintf` za ugrađene funkcije, i sve pojave `Logging` ili `Logfile` za prilagođene implementacije.

### **Praćenje sistemskih Logs**

Aplikacije zapisuju razne informacije koje mogu biti osetljive. Za nadgledanje ovih logs, koriste se alati i komande kao:
```bash
idevice_id --list   # To find the device ID
idevicesyslog -u <id> (| grep <app>)   # To capture the device logs
```
su korisni. Pored toga, **Xcode** omogućava prikupljanje logova konzole:

1. Otvorite Xcode.
2. Povežite iOS uređaj.
3. Idite na **Window** -> **Devices and Simulators**.
4. Izaberite svoj uređaj.
5. Reproducirajte problem koji istražujete.
6. Koristite dugme **Open Console** da pregledate logove u novom prozoru.

Za naprednije logovanje, povezivanje na shell uređaja i korišćenje **socat** može omogućiti praćenje logova u realnom vremenu:
```bash
iPhone:~ root# socat - UNIX-CONNECT:/var/run/lockdown/syslog.sock
```
Praćeno naredbama za posmatranje aktivnosti logova, koje mogu biti neprocenjive za dijagnostikovanje problema ili identifikovanje potencijalnog data leakage u logovima.

## Rezervne kopije

**Funkcije automatskog pravljenja rezervnih kopija** su integrisane u iOS, omogućavajući pravljenje kopija podataka uređaja preko iTunes (do macOS Catalina), Finder (od macOS Catalina nadalje), ili iCloud. Ove rezervne kopije obuhvataju gotovo sve podatke uređaja, izuzimajući veoma osetljive elemente kao što su Apple Pay detalji i konfiguracije Touch ID.

### Bezbednosni rizici

Uključivanje **instaliranih aplikacija i njihovih podataka** u rezervne kopije podiže pitanje potencijalnog **data leakage** i rizik da **izmene u rezervnim kopijama mogu promeniti funkcionalnost aplikacije**. Preporučuje se da se osetljivi podaci **ne čuvaju u plaintext obliku** unutar direktorijuma bilo koje aplikacije ili njenih poddirektorijuma kako bi se umanjili ovi rizici.

### Isključivanje fajlova iz rezervnih kopija

Fajlovi u `Documents/` i `Library/Application Support/` se po defaultu uključuju u rezervne kopije. Programeri mogu isključiti određene fajlove ili direktorijume iz rezervnih kopija koristeći `NSURL setResourceValue:forKey:error:` sa `NSURLIsExcludedFromBackupKey`. Ova praksa je ključna za zaštitu osetljivih podataka od uključivanja u rezervne kopije.

### Testiranje ranjivosti

Da biste procenili sigurnost rezervnih kopija aplikacije, počnite sa **pravljenjem backup-a** koristeći Finder, a zatim ga pronađite prateći uputstva iz [Apple's official documentation](https://support.apple.com/en-us/HT204215). Analizirajte rezervnu kopiju radi prisustva osetljivih podataka ili konfiguracija koje bi mogle biti izmenjene i uticati na ponašanje aplikacije.

Osetljive informacije mogu se tražiti koristeći komandne alate ili aplikacije kao što je [iMazing](https://imazing.com). Za enkriptovane rezervne kopije, prisustvo enkripcije može se potvrditi proverom ključa "IsEncrypted" u fajlu "Manifest.plist" u korenu rezervne kopije.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
...
<key>Date</key>
<date>2021-03-12T17:43:33Z</date>
<key>IsEncrypted</key>
<true/>
...
</plist>
```
Za rad sa šifrovanim backup-ovima, Python skripte dostupne u [DinoSec's GitHub repo](https://github.com/dinosec/iphone-dataprotection/tree/master/python_scripts), kao što su **backup_tool.py** i **backup_passwd.py**, mogu biti korisne, iako mogu zahtevati prilagođavanja radi kompatibilnosti sa najnovijim iTunes/Finder verzijama. Alat [**iOSbackup**](https://pypi.org/project/iOSbackup/) je još jedna opcija za pristup fajlovima unutar backup-ova zaštićenih lozinkom.

### Izmena ponašanja aplikacije

Primer izmene ponašanja aplikacije kroz modifikacije backup-a prikazan je u [Bither bitcoin wallet app](https://github.com/bither/bither-ios), gde je UI lock PIN smešten u `net.bither.plist` pod ključem **pin_code**. Uklanjanje ovog ključa iz plist-a i vraćanje backup-a uklanja zahtev za PIN-om, omogućavajući neograničen pristup.

## Pregled testiranja memorije za osetljive podatke

Kada se radi sa osetljivim informacijama smeštenim u memoriji aplikacije, ključno je ograničiti vreme izloženosti tih podataka. Postoje dva glavna pristupa za ispitivanje sadržaja memorije: kreiranje memory dump-a i analiza memorije u realnom vremenu. Oba metoda imaju svoje izazove, uključujući mogućnost propuštanja kritičnih podataka tokom procesa dump-a ili analize.

## **Preuzimanje i analiza memory dump-a**

Za jailbroken i non-jailbroken uređaje, alati poput [objection](https://github.com/sensepost/objection) i [Fridump](https://github.com/Nightbringer21/fridump) omogućavaju dump-ovanje procesa memorije aplikacije. Nakon dump-ovanja, za analizu tih podataka potrebni su različiti alati, u zavisnosti od prirode informacija koje tražite.

Da biste izvukli stringove iz memory dump-a, mogu se koristiti komandе kao što su `strings` ili `rabin2 -zz`:
```bash
# Extracting strings using strings command
$ strings memory > strings.txt

# Extracting strings using rabin2
$ rabin2 -ZZ memory > strings.txt
```
Za detaljniju analizu, uključujući pretragu za specifičnim tipovima podataka ili obrascima, **radare2** nudi opsežne mogućnosti pretrage:
```bash
$ r2 <name_of_your_dump_file>
[0x00000000]> /?
...
```
## **Analiza memorije tokom izvršavanja**

**r2frida** pruža moćnu alternativu za inspekciju memorije aplikacije u realnom vremenu, bez potrebe za dump-om memorije. Ovaj alat omogućava izvršavanje komandi za pretragu direktno na memoriji pokrenute aplikacije:
```bash
$ r2 frida://usb//<name_of_your_app>
[0x00000000]> /\ <search_command>
```
## Slomljena kriptografija

### Loši procesi upravljanja ključevima

Neki developeri čuvaju osetljive podatke u lokalnoj memoriji i enkriptuju ih ključem koji je hardkodiran/predvidiv u kodu. To ne bi trebalo raditi jer bi reverzno inženjerstvo moglo napadačima omogućiti da izvuku poverljive informacije.

### Upotreba nesigurnih i/ili zastarelih algoritama

Developeri ne bi trebalo da koriste **deprecated algorithms** za izvođenje autorizacionih **checks**, **store** ili **send** podataka. Neki od ovih algoritama su: RC4, MD4, MD5, SHA1... Ako se na primer koriste **hashes** za čuvanje lozinki, trebalo bi koristiti hashes otporne na brute-force sa salt.

### Provera

Glavne provere koje treba izvršiti su da li možete pronaći **hardcoded** lozinke/tajne u kodu, ili da li su one **predictable**, i da li kod koristi neku vrstu **weak** **cryptography** algoritama.

Zanimljivo je znati da možete automatski **monitor** neke **crypto** **libraries** koristeći **objection** sa:
```swift
ios monitor crypt
```
For **više informacija** o iOS kriptografskim API-jevima i bibliotekama pristupite [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography)

## Lokalna autentifikacija

**Lokalna autentifikacija** ima ključnu ulogu, posebno kada je u pitanju zaštita pristupa na udaljenoj tački putem kriptografskih metoda. Suština je da bez pravilne implementacije mehanizmi lokalne autentifikacije mogu biti zaobiđeni.

Apple-ov [**Local Authentication framework**](https://developer.apple.com/documentation/localauthentication) i [**keychain**](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html) pružaju robusne API-je developerima za omogućavanje dijaloga za autentifikaciju korisnika i bezbedno rukovanje tajnim podacima, respektivno. Secure Enclave štiti identitet otiska prsta za Touch ID, dok Face ID koristi prepoznavanje lica bez ugrožavanja biometrijskih podataka.

Za integraciju Touch ID/Face ID, developeri imaju dva izbora API-ja:

- **`LocalAuthentication.framework`** za visok nivo autentifikacije korisnika bez pristupa biometrijskim podacima.
- **`Security.framework`** za niži nivo pristupa keychain servisima, obezbeđujući tajne podatke uz biometrijsku autentifikaciju. Razni [open-source wrappers](https://www.raywenderlich.com/147308/secure-ios-user-data-keychain-touch-id) olakšavaju pristup keychain-u.

> [!CAUTION]
> Međutim, oba `LocalAuthentication.framework` i `Security.framework` imaju ranjivosti, jer uglavnom vraćaju boolean vrednosti bez prenosa podataka za procese autentifikacije, što ih čini podložnim zaobilaženju (pogledajte [Don't touch me that way, by David Lindner et al](https://www.youtube.com/watch?v=XhXIHVGCFFM)).

### Implementacija lokalne autentifikacije

Da bi se zatražila autentifikacija od korisnika, developeri treba da koriste metodu **`evaluatePolicy`** unutar klase **`LAContext`**, birajući između:

- **`deviceOwnerAuthentication`**: Zahteva Touch ID ili lozinku uređaja, i neuspeva ako nijedno nije omogućeno.
- **`deviceOwnerAuthenticationWithBiometrics`**: Isključivo zahteva Touch ID.

Uspešna autentifikacija se označava boolean povratnom vrednošću iz **`evaluatePolicy`**, što ističe potencijalni sigurnosni propust.

### Lokalna autentifikacija koristeći keychain

Implementacija **lokalne autentifikacije** u iOS aplikacijama uključuje upotrebu **keychain APIs** za bezbedno čuvanje tajnih podataka kao što su autentifikacioni tokeni. Ovaj proces osigurava da podacima može pristupiti samo korisnik, koristeći lozinku uređaja ili biometrijsku autentifikaciju poput Touch ID.

Keychain omogućava mogućnost postavljanja stavki sa atributom `SecAccessControl`, koji ograničava pristup stavci dok se korisnik ne autentifikuje uspešno putem Touch ID ili lozinke uređaja. Ova funkcija je ključna za unapređenje bezbednosti.

Ispod su primeri koda u Swift i Objective-C koji pokazuju kako sačuvati i preuzeti string u/iz keychain-a koristeći ove bezbednosne funkcije. Primeri posebno prikazuju kako podesiti kontrolu pristupa da zahteva Touch ID autentifikaciju i osigurati da su podaci dostupni samo na uređaju na kojem su postavljeni, pod uslovom da je konfigurisan passcode uređaja.

{{#tabs}}
{{#tab name="Swift"}}
```swift
// From https://github.com/mufambisi/owasp-mstg/blob/master/Document/0x06f-Testing-Local-Authentication.md

// 1. create AccessControl object that will represent authentication settings

var error: Unmanaged<CFError>?

guard let accessControl = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
SecAccessControlCreateFlags.biometryCurrentSet,
&error) else {
// failed to create AccessControl object

return
}

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute

var query: [String: Any] = [:]

query[kSecClass as String] = kSecClassGenericPassword
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecAttrAccount as String] = "OWASP Account" as CFString
query[kSecValueData as String] = "test_strong_password".data(using: .utf8)! as CFData
query[kSecAttrAccessControl as String] = accessControl

// 3. save item

let status = SecItemAdd(query as CFDictionary, nil)

if status == noErr {
// successfully saved
} else {
// error while saving
}
```
{{#endtab}}

{{#tab name="Objective-C"}}
```objectivec
// 1. create AccessControl object that will represent authentication settings
CFErrorRef *err = nil;

SecAccessControlRef sacRef = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
kSecAccessControlUserPresence,
err);

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute
NSDictionary* query = @{
(_ _bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecAttrAccount: @"OWASP Account",
(__bridge id)kSecValueData: [@"test_strong_password" dataUsingEncoding:NSUTF8StringEncoding],
(__bridge id)kSecAttrAccessControl: (__bridge_transfer id)sacRef
};

// 3. save item
OSStatus status = SecItemAdd((__bridge CFDictionaryRef)query, nil);

if (status == noErr) {
// successfully saved
} else {
// error while saving
}
```
{{#endtab}}
{{#endtabs}}

Sad možemo zatražiti sačuvanu stavku iz keychain-a. Keychain services će prikazati dijalog za autentikaciju korisniku i vratiti data ili nil u zavisnosti od toga da li je priložen odgovarajući fingerprint ili ne.

{{#tabs}}
{{#tab name="Swift"}}
```swift
// 1. define query
var query = [String: Any]()
query[kSecClass as String] = kSecClassGenericPassword
query[kSecReturnData as String] = kCFBooleanTrue
query[kSecAttrAccount as String] = "My Name" as CFString
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecUseOperationPrompt as String] = "Please, pass authorisation to enter this area" as CFString

// 2. get item
var queryResult: AnyObject?
let status = withUnsafeMutablePointer(to: &queryResult) {
SecItemCopyMatching(query as CFDictionary, UnsafeMutablePointer($0))
}

if status == noErr {
let password = String(data: queryResult as! Data, encoding: .utf8)!
// successfully received password
} else {
// authorization not passed
}
```
{{#endtab}}

{{#tab name="Objective-C"}}
```objectivec
// 1. define query
NSDictionary *query = @{(__bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecReturnData: @YES,
(__bridge id)kSecAttrAccount: @"My Name1",
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecUseOperationPrompt: @"Please, pass authorisation to enter this area" };

// 2. get item
CFTypeRef queryResult = NULL;
OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)query, &queryResult);

if (status == noErr){
NSData* resultData = ( __bridge_transfer NSData* )queryResult;
NSString* password = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding];
NSLog(@"%@", password);
} else {
NSLog(@"Something went wrong");
}
```
{{#endtab}}
{{#endtabs}}

### Otkrivanje

Korišćenje frameworks u app može takođe biti detektovano analizom app binary's list of shared dynamic libraries. Ovo se može uraditi korišćenjem `otool`:
```bash
$ otool -L <AppName>.app/<AppName>
```
Ako se u aplikaciji koristi `LocalAuthentication.framework`, izlaz će sadržati obe sledeće linije (imajte na umu da `LocalAuthentication.framework` koristi `Security.framework` ispod haube):
```bash
/System/Library/Frameworks/LocalAuthentication.framework/LocalAuthentication
/System/Library/Frameworks/Security.framework/Security
```
Ako se koristi `Security.framework`, prikazaće se samo drugi.

### Zaobilaženje Local Authentication Framework-a

#### **Objection**

Putem **Objection Biometrics Bypass**, located at [this GitHub page](https://github.com/sensepost/objection/wiki/Understanding-the-iOS-Biometrics-Bypass), dostupna je tehnika za zaobilaženje mehanizma **LocalAuthentication**. Osnova ovog pristupa uključuje korišćenje **Frida** za manipulaciju funkcijom `evaluatePolicy`, tako da ona konsekventno vraća `True`, bez obzira na stvarni ishod autentifikacije. Ovo je posebno korisno za zaobilaženje neispravnih procesa biometrijske autentifikacije.

Da biste aktivirali ovaj bypass, koristi se sledeća komanda:
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios ui biometrics_bypass
(agent) Registering job 3mhtws9x47q. Type: ios-biometrics-disable
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # (agent) [3mhtws9x47q] Localized Reason for auth requirement: Please authenticate yourself
(agent) [3mhtws9x47q] OS authentication response: false
(agent) [3mhtws9x47q] Marking OS response as True instead
(agent) [3mhtws9x47q] Biometrics bypass hook complete
```
Ova komanda pokreće sekvencu u kojoj Objection registruje zadatak koji efikasno menja ishod provere `evaluatePolicy` u `True`.

#### Frida

Primer upotrebe **`evaluatePolicy`** iz [DVIA-v2 application](https://github.com/prateek147/DVIA-v2):
```swift
+(void)authenticateWithTouchID {
LAContext *myContext = [[LAContext alloc] init];
NSError *authError = nil;
NSString *myLocalizedReasonString = @"Please authenticate yourself";

if ([myContext canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&authError]) {
[myContext evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics
localizedReason:myLocalizedReasonString
reply:^(BOOL success, NSError *error) {
if (success) {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Successful" withTitle:@"Success"];
});
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Failed !" withTitle:@"Error"];
});
}
}];
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Your device doesn't support Touch ID or you haven't configured Touch ID authentication on your device" withTitle:@"Error"];
});
}
}
```
Da bi se postigao **bypass** Local Authentication, napisan je Frida script. Ovaj script cilja **evaluatePolicy** check, presrećući njegov callback kako bi osigurao da vraća **success=1**.

Izmenom ponašanja callback-a, authentication check je efektivno bypassed.
```swift
// from https://securitycafe.ro/2022/09/05/mobile-pentesting-101-bypassing-biometric-authentication/
if(ObjC.available) {
console.log("Injecting...");
var hook = ObjC.classes.LAContext["- evaluatePolicy:localizedReason:reply:"];
Interceptor.attach(hook.implementation, {
onEnter: function(args) {
var block = new ObjC.Block(args[4]);
const callback = block.implementation;
block.implementation = function (error, value)  {

console.log("Changing the result value to true")
const result = callback(1, null);
return result;
};
},
});
} else {
console.log("Objective-C Runtime is not available!");
}
```
Da bi se ubacila Frida skripta i zaobišla biometrijska autentifikacija, koristi se sledeća komanda:
```bash
frida -U -f com.highaltitudehacks.DVIAswiftv2 --no-pause -l fingerprint-bypass-ios.js
```
## Sensitive Functionality Exposure Through IPC

### Custom URI Handlers / Deeplinks / Custom Schemes


{{#ref}}
ios-custom-uri-handlers-deeplinks-custom-schemes.md
{{#endref}}

### Universal Links


{{#ref}}
ios-universal-links.md
{{#endref}}

### UIActivity Sharing


{{#ref}}
ios-uiactivity-sharing.md
{{#endref}}

### UIPasteboard


{{#ref}}
ios-uipasteboard.md
{{#endref}}

### App Extensions


{{#ref}}
ios-app-extensions.md
{{#endref}}

### WebViews


{{#ref}}
ios-webviews.md
{{#endref}}

### Serialisation and Encoding


{{#ref}}
ios-serialisation-and-encoding.md
{{#endref}}

## Network Communication

It's important to check that no communication is occurring **without encryption** and also that the application is correctly **validating the TLS certificate** of the server.\
To check these kind of issues you can use a proxy like **Burp**:


{{#ref}}
burp-configuration-for-ios.md
{{#endref}}

### Hostname check

One common issue validating the TLS certificate is to check that the certificate was signed by a **trusted** **CA**, but **not check** if **the hostname** of the certificate is the hostname being accessed.\
In order to check this issue using Burp, after trusting Burp CA in the iPhone, you can **create a new certificate with Burp for a different hostname** and use it. If the application still works, then, something it's vulnerable.

### Certificate Pinning

If an application is correctly using SSL Pinning, then the application will only works if the certificate is the once expected to be. When testing an application **this might be a problem as Burp will serve it's own certificate.**\
In order to bypass this protection inside a jailbroken device, you can install the application [**SSL Kill Switch**](https://github.com/nabla-c0d3/ssl-kill-switch2) or install [**Burp Mobile Assistant**](https://portswigger.net/burp/documentation/desktop/mobile/config-ios-device)

You can also use **objection's** `ios sslpinning disable`

## Misc

- In **`/System/Library`** you can find the frameworks installed in the phone used by system applications
- The applications installed by the user from the App Store are located inside **`/User/Applications`**
- And the **`/User/Library`** contains data saved by the user level applications
- You can access **`/User/Library/Notes/notes.sqlite`** to read the notes saved inside the application.
- Inside the folder of an installed application (**`/User/Applications/<APP ID>/`**) you can find some interesting files:
- **`iTunesArtwork`**: The icon used by the app
- **`iTunesMetadata.plist`**: Info of the app used in the App Store
- **`/Library/*`**: Contains the preferences and cache. In **`/Library/Cache/Snapshots/*`** you can find the snapshot performed to the application before sending it to the background.

### Hot Patching/Enforced Updateing

The developers can remotely **patch all installations of their app instantly** without having to resubmit the application to the App store and wait until it's approved.\
For this purpose it's usually use [**JSPatch**](https://github.com/bang590/JSPatch)**.** But there are other options also such as [Siren](https://github.com/ArtSabintsev/Siren) and [react-native-appstore-version-checker](https://www.npmjs.com/package/react-native-appstore-version-checker).\
**This is a dangerous mechanism that could be abused by malicious third party SDKs therefore it's recommended to check which method is used to automatic updating (if any) and test it.** You could try to download a previous version of the app for this purpose.

### Third Parties

A significant challenge with **3rd party SDKs** is the **lack of granular control** over their functionalities. Developers are faced with a choice: either integrate the SDK and accept all its features, including potential security vulnerabilities and privacy concerns, or forego its benefits entirely. Often, developers are unable to patch vulnerabilities within these SDKs themselves. Furthermore, as SDKs gain trust within the community, some may start to contain malware.

The services provided by third-party SDKs may include user behavior tracking, advertisement displays, or user experience enhancements. However, this introduces a risk as developers may not be fully aware of the code executed by these libraries, leading to potential privacy and security risks. It's crucial to limit the information shared with third-party services to what is necessary and ensure that no sensitive data is exposed.

Implementation of third-party services usually comes in two forms: a standalone library or a full SDK. To protect user privacy, any data shared with these services should be **anonymized** to prevent the disclosure of Personal Identifiable Information (PII).

To identify the libraries an application uses, the **`otool`** command can be employed. This tool should be run against the application and each shared library it uses to discover additional libraries.
```bash
otool -L <application_path>
```
## Zanimljive ranjivosti i studije slučaja


{{#ref}}
air-keyboard-remote-input-injection.md
{{#endref}}

{{#ref}}
itunesstored-bookassetd-sandbox-escape.md
{{#endref}}

{{#ref}}
zero-click-messaging-image-parser-chains.md
{{#endref}}

## **Reference i dodatni resursi**

- [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering)
- [iOS & Mobile App Pentesting - INE](https://my.ine.com/CyberSecurity/courses/089d060b/ios-mobile-app-pentesting)
- [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/)
- [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/)
- [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/)
- [https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage](https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage)
- [https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way](https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053)
- [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060)
- [https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/](https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064](https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064)
- [https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc](https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054)
- [https://github.com/ivRodriguezCA/RE-iOS-Apps/](https://github.com/ivRodriguezCA/RE-iOS-Apps/) Besplatan iOS kurs([https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/](https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/))
- [https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577](https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577)
- [https://www.slideshare.net/RyanISI/ios-appsecurityminicourse](https://www.slideshare.net/RyanISI/ios-appsecurityminicourse)
- [https://github.com/prateek147/DVIA](https://github.com/prateek147/DVIA)
- [https://github.com/prateek147/DVIA-v2](https://github.com/prateek147/DVIA-v2)
- [https://github.com/OWASP/MSTG-Hacking-Playground%20](https://github.com/OWASP/MSTG-Hacking-Playground)
- OWASP iGoat [_https://github.com/OWASP/igoat_](https://github.com/OWASP/igoat) <<< Objective-C verzija [_https://github.com/OWASP/iGoat-Swift_](https://github.com/OWASP/iGoat-Swift) <<< Swift verzija
- [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
- [https://github.com/nabla-c0d3/ssl-kill-switch2](https://github.com/nabla-c0d3/ssl-kill-switch2)


{{#include ../../banners/hacktricks-training.md}}
