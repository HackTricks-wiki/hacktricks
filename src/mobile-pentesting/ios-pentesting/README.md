# iOS Pentesting

{{#include ../../banners/hacktricks-training.md}}

## iOS Temelleri


{{#ref}}
ios-basics.md
{{#endref}}

## Test Ortamı

Bu sayfada **iOS simulator**, **emulators** ve **jailbreaking** hakkında bilgi bulabilirsiniz:


{{#ref}}
ios-testing-environment.md
{{#endref}}

## İlk Analiz

### Temel iOS Test İşlemleri

Test sırasında **birkaç işlem önerilecektir** (cihazla bağlantı kurma, dosya okuma/yazma/yükleme/indirme, bazı araçları kullanma...). Bu işlemlerin nasıl yapılacağını bilmiyorsanız lütfen **sayfayı okumaya başlayın**:


{{#ref}}
basic-ios-testing-operations.md
{{#endref}}

> [!TIP]
> Bir sonraki adımlar için **uygulamanın cihazda yüklü olması** ve uygulamanın **IPA dosyasının** elde edilmiş olması gerekir.\
> Bunu nasıl yapacağınızı öğrenmek için [Basic iOS Testing Operations](basic-ios-testing-operations.md) sayfasını okuyun.

### Temel Statik Analiz

Bazı ilginç iOS - IPA dosyası decompiler'ları:

- [https://github.com/LaurieWired/Malimite](https://github.com/LaurieWired/Malimite)
- [https://ghidra-sre.org/](https://ghidra-sre.org/)

IPA dosyasına otomatik bir Statik Analiz uygulamak için [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) aracını kullanmanız önerilir.

İkili dosyada bulunan **korumaların tespiti**:

- **PIE (Position Independent Executable)**: Etkinleştirildiğinde, uygulama her başlatıldığında rastgele bir bellek adresine yüklenir ve başlangıç bellek adresini tahmin etmeyi zorlaştırır.

```bash
otool -hv <app-binary> | grep PIE   # It should include the PIE flag
```

- **Stack Canaries**: Stack'in bütünlüğünü doğrulamak için, bir ‘canary’ değeri fonksiyon çağrılmadan önce stack'e yerleştirilir ve fonksiyon sona erdiğinde tekrar doğrulanır.

```bash
otool -I -v <app-binary> | grep stack_chk   # It should include the symbols: stack_chk_guard and stack_chk_fail
```

- **ARC (Automatic Reference Counting)**: Yaygın bellek bozulması hatalarını önlemek için

```bash
otool -I -v <app-binary> | grep objc_release   # It should include the _objc_release symbol
```

- **Encrypted Binary**: İkili dosyanın şifrelenmiş olması gerekir

```bash
otool -arch all -Vl <app-binary> | grep -A5 LC_ENCRYPT   # The cryptid should be 1
```

**Hassas/Güvensiz Fonksiyonların Tespiti**

- **Zayıf Hash Algoritmaları**

```bash
# On the iOS device
otool -Iv <app> | grep -w "_CC_MD5"
otool -Iv <app> | grep -w "_CC_SHA1"

# On linux
grep -iER "_CC_MD5"
grep -iER "_CC_SHA1"
```

- **Güvensiz Rastgele Fonksiyonlar**

```bash
# On the iOS device
otool -Iv <app> | grep -w "_random"
otool -Iv <app> | grep -w "_srand"
otool -Iv <app> | grep -w "_rand"

# On linux
grep -iER "_random"
grep -iER "_srand"
grep -iER "_rand"
```

- **Güvensiz 'Malloc' Fonksiyonu**

```bash
# On the iOS device
otool -Iv <app> | grep -w "_malloc"

# On linux
grep -iER "_malloc"
```

- **Güvensiz ve Zafiyetli Fonksiyonlar**

```bash
# On the iOS device
otool -Iv <app> | grep -w "_gets"
otool -Iv <app> | grep -w "_memcpy"
otool -Iv <app> | grep -w "_strncpy"
otool -Iv <app> | grep -w "_strlen"
otool -Iv <app> | grep -w "_vsnprintf"
otool -Iv <app> | grep -w "_sscanf"
otool -Iv <app> | grep -w "_strtok"
otool -Iv <app> | grep -w "_alloca"
otool -Iv <app> | grep -w "_sprintf"
otool -Iv <app> | grep -w "_printf"
otool -Iv <app> | grep -w "_vsprintf"

# On linux
grep -R "_gets"
grep -iER "_memcpy"
grep -iER "_strncpy"
grep -iER "_strlen"
grep -iER "_vsnprintf"
grep -iER "_sscanf"
grep -iER "_strtok"
grep -iER "_alloca"
grep -iER "_sprintf"
grep -iER "_printf"
grep -iER "_vsprintf"
```

#### Yaygın jailbreak tespit yöntemleri

- **File System Checks**: `/Applications/Cydia.app` veya `/Library/MobileSubstrate/MobileSubstrate.dylib` gibi yaygın jailbreak dosya ve dizinlerinin varlığını kontrol edin.
- **Sandbox Violations**: Jailbreak yapılmamış cihazlarda engellenmesi gereken dosya sistemi alanlarına erişmeye çalışın.
- **API Checks**: `fork()` ile child process oluşturup oluşturamayacağınıza veya `system()` ile /bin/sh olup olmadığına bakmak gibi yasak çağrıların kullanımını kontrol edin.
- **Process Checks**: `Cydia`, `Substrate` veya `ssh` gibi bilinen jailbreak ile ilişkili süreçlerin varlığını izleyin.
- **Kernel Exploits**: Jailbreak'lerde yaygın olarak kullanılan kernel exploit'lerin varlığını kontrol edin.
- **Environment Variables**: `DYLD_INSERT_LIBRARIES` gibi jailbreak belirtisi olabilecek ortam değişkenlerini inceleyin.
- **Libraries Check**: Uygulama sürecine yüklenen kütüphaneleri kontrol edin.
- **Check schemes**: Örneğin `canOpenURL(URL(string: "cydia://"))` gibi.

#### Yaygın Anti-Debugging tespit yöntemleri

- **Check for Debugger Presence**: Bir debugger'ın bağlı olup olmadığını kontrol etmek için `sysctl` veya diğer yöntemleri kullanın.
- **Anti-Debugging APIs**: `ptrace` veya `SIGSTOP` gibi anti-debugging API çağrılarını arayın; örneğin `ptrace(PT_DENY_ATTACH, 0, 0, 0)`.
- **Timing Checks**: Belirli işlemlerin alınan sürelerini ölçün ve debugging varlığına işaret edebilecek tutarsızlıklara bakın.
- **Memory Checks**: Bilinen debugger eserleri veya değişiklikleri için belleği inceleyin.
- **Environment Variables**: Debugging oturumuna işaret edebilecek ortam değişkenlerini kontrol edin.
- **Mach Ports**: Mach exception portlarının debugger'lar tarafından kullanılıp kullanılmadığını tespit edin.

### Temel Dinamik Analiz

MobSF'in gerçekleştirdiği dinamik analize bakın. Farklı görünümler arasında gezinip bunlarla etkileşimde bulunmanız gerekecek; MobSF bazı sınıfları hook'layacak ve işlem tamamlandığında bir rapor hazırlayacaktır.

### Yüklü Uygulamaları Listeleme

Yüklü uygulamaların **bundle identifier**'ını belirlemek için `frida-ps -Uai` komutunu kullanın:
```bash
$ frida-ps -Uai
PID  Name                 Identifier
----  -------------------  -----------------------------------------
6847  Calendar             com.apple.mobilecal
6815  Mail                 com.apple.mobilemail
-  App Store            com.apple.AppStore
-  Apple Store          com.apple.store.Jolly
-  Calculator           com.apple.calculator
-  Camera               com.apple.camera
-  iGoat-Swift          OWASP.iGoat-Swift
```
### Temel Enumeration & Hooking

Uygulamanın bileşenlerini **enumerate** etmeyi ve yöntemleri ile sınıfları **hook** etmeyi objection ile nasıl kolayca yapacağınızı öğrenin:

{{#ref}}
ios-hooking-with-objection.md
{{#endref}}

### IPA Yapısı

Bir **IPA file**'ın yapısı esasen bir **zipped package**'ın yapısına denktir. Uzantısını `.zip` olarak değiştirerek içeriğini açabilirsiniz. Bu yapının içinde bir **Bundle**, kurulmaya hazır tamamen paketlenmiş bir uygulamayı temsil eder. İçinde uygulamanın kaynaklarını kapsayan `<NAME>.app` adlı bir dizin bulacaksınız.

- **`Info.plist`**: Bu dosya uygulamanın belirli yapılandırma detaylarını içerir.
- **`_CodeSignature/`**: Bu dizin, paket içindeki tüm dosyaların bütünlüğünü sağlayan bir imzayı içeren bir plist dosyası barındırır.
- **`Assets.car`**: Simge gibi varlık dosyalarını saklayan sıkıştırılmış bir arşivdir.
- **`Frameworks/`**: Bu klasör, uygulamanın native kütüphanelerini barındırır; bunlar `.dylib` veya `.framework` dosyaları şeklinde olabilir.
- **`PlugIns/`**: Bu, `.appex` dosyaları olarak bilinen uygulama uzantılarını içerebilir; ancak her zaman bulunmaz. \* [**`Core Data`**](https://developer.apple.com/documentation/coredata): Uygulamanızın kalıcı verilerini çevrimdışı kullanım için saklamak, geçici verileri önbelleğe almak ve tek bir cihazda geri alma (undo) işlevselliği eklemek için kullanılır. Birden fazla cihaz arasında tek bir iCloud hesabında veri senkronizasyonu yapmak için Core Data, şemanızı otomatik olarak bir CloudKit container'ına yansıtır.
- [**`PkgInfo`**](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigApplications.html): `PkgInfo` dosyası, uygulamanızın veya bundle'ın type ve creator kodlarını belirtmenin alternatif bir yoludur.
- **en.lproj, fr.proj, Base.lproj**: Belirli diller için kaynakları içeren dil paketleridir ve bir dil desteklenmiyorsa varsayılan bir kaynak sağlar.
- **Güvenlik**: `_CodeSignature/` dizini, paketlenmiş tüm dosyaların bütünlüğünü dijital imzalarla doğrulayarak uygulamanın güvenliğinde kritik bir rol oynar.
- **Varlık Yönetimi**: `Assets.car` dosyası, grafik varlıklarını verimli yönetmek için sıkıştırma kullanır; bu, uygulama performansını optimize etmek ve toplam boyutu azaltmak için önemlidir.
- **Frameworks and PlugIns**: Bu dizinler iOS uygulamalarının modülerliğini vurgular; geliştiricilerin yeniden kullanılabilir kod kütüphanelerini (`Frameworks/`) eklemesine ve uygulama işlevselliğini genişletmesine (`PlugIns/`) olanak tanır.
- **Yerelleştirme**: Bu yapı, belirli dil paketleri için kaynaklar içerecek şekilde çoklu dili destekleyerek uygulamanın küresel erişimini kolaylaştırır.

**Info.plist**

**Info.plist**, iOS uygulamaları için bir köşe taşıdır ve anahtar-değer çiftleri biçiminde temel yapılandırma verilerini kapsar. Bu dosya yalnızca uygulamalar için değil, içinde paketlenmiş app extensions ve frameworks için de gereklidir. XML veya ikili (binary) formatta yapılandırılmıştır ve uygulama izinlerinden güvenlik yapılandırmalarına kadar kritik bilgiler içerir. Kullanılabilir anahtarların ayrıntılı bir incelemesi için [**Apple Developer Documentation**](https://developer.apple.com/documentation/bundleresources/information_property_list?language=objc) başvurabilirsiniz.

Daha erişilebilir bir formatta bu dosyayla çalışmak isteyenler için XML dönüşümü macOS'ta bulunan `plutil` (10.2 ve sonraki sürümlerde varsayılan olarak mevcuttur) veya Linux'ta `plistutil` kullanılarak kolayca gerçekleştirilebilir. Dönüştürme için komutlar şöyle:

- **macOS için**:
```bash
$ plutil -convert xml1 Info.plist
```
- **Linux için**:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
Info.plist dosyasının açığa çıkarabileceği çok sayıda bilgi arasında, dikkat çekici girdiler uygulama izin dizeleri (`UsageDescription`), özel URL şemaları (`CFBundleURLTypes`) ve App Transport Security için yapılandırmalar (`NSAppTransportSecurity`) gibi öğeleri içerir. Bu girdiler, `UTExportedTypeDeclarations` / `UTImportedTypeDeclarations` gibi dışa/içe aktarılan özel belge türleriyle birlikte, dosyayı inceleyerek veya basit bir `grep` komutu kullanarak kolayca bulunabilir:
```bash
$ grep -i <keyword> Info.plist
```
**Veri Yolları**

iOS ortamında dizinler özel olarak **sistem uygulamaları** ve **kullanıcı tarafından yüklenen uygulamalar** için ayrılmıştır. Sistem uygulamaları `/Applications` dizininde bulunurken, kullanıcı tarafından yüklenen uygulamalar `/var/mobile/containers/Data/Application/` altında yer alır. Bu uygulamalara **128-bit UUID** olarak bilinen benzersiz bir kimlik atanır; dizin adlarındaki rastgelelik nedeniyle bir uygulamanın klasörünü elle bulmak zorlaşır.

> [!WARNING]
> iOS'ta uygulamalar sandbox'lanmak zorunda olduğu için, her uygulamanın ayrıca **`$HOME/Library/Containers`** içinde uygulamanın **`CFBundleIdentifier`**'ı ile aynı adı taşıyan bir klasörü olacaktır.
>
> Ancak, her iki klasörde (data & container klasörleri) de her iki dosyayı `MCMetadataIdentifier` anahtarında bağlayan **`.com.apple.mobile_container_manager.metadata.plist`** adlı dosya bulunur).

Kullanıcı tarafından yüklenen bir uygulamanın kurulum dizinini bulmayı kolaylaştırmak için, **objection tool** yararlı bir `env` komutu sağlar. Bu komut ilgili uygulama için ayrıntılı dizin bilgilerini gösterir. Aşağıda bu komutun nasıl kullanılacağına dair bir örnek bulunmaktadır:
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # env

Name               Path
-----------------  -------------------------------------------------------------------------------------------
BundlePath         /var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app
CachesDirectory    /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library/Caches
DocumentDirectory  /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Documents
LibraryDirectory   /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library
```
Alternatif olarak, uygulama adı `/private/var/containers` içinde `find` komutu kullanılarak aranabilir:
```bash
find /private/var/containers -name "Progname*"
```
`ps` ve `lsof` gibi komutlar, sırasıyla uygulamanın işlemini belirlemek ve açık dosyaları listelemek için de kullanılabilir; bu da uygulamanın aktif dizin yolları hakkında bilgi sağlar:
```bash
ps -ef | grep -i <app-name>
lsof -p <pid> | grep -i "/containers" | head -n 1
```
**Bundle dizini:**

- **AppName.app**
- Bu, daha önce IPA içinde görülen Application Bundle'dır; uygulamanın gerekli uygulama verilerini, statik içeriğini ve uygulamanın derlenmiş ikili dosyasını içerir.
- Bu dizin kullanıcılara görünür, ancak **kullanıcılar buraya yazamaz**.
- Bu dizindeki içerik **yedeklenmez**.
- Bu klasörün içeriği **kod imzasını doğrulamak** için kullanılır.

**Data dizini:**

- **Documents/**
- Kullanıcı tarafından oluşturulan tüm verileri içerir. Bu verilerin oluşturulması uygulama son kullanıcısı tarafından başlatılır.
- Kullanıcılara görünür ve **kullanıcılar buraya yazabilir**.
- Bu dizindeki içerik **yedeklenir**.
- Uygulama, `NSURLIsExcludedFromBackupKey` ayarlayarak yolları yedekten hariç tutabilir.
- **Library/**
- Uygulamaya özgü olmayan **dosyaları** içerir; örneğin **caches**, **preferences**, **cookies** ve property list (plist) yapılandırma dosyaları.
- iOS uygulamaları genellikle `Application Support` ve `Caches` alt dizinlerini kullanır, ancak uygulama özel alt dizinler oluşturabilir.
- **Library/Caches/**
- Yarı-kalıcı önbelleğe alınmış **dosyaları** içerir.
- Kullanıcılara görünmez ve **kullanıcılar buraya yazamaz**.
- Bu dizindeki içerik **yedeklenmez**.
- Uygulama çalışmıyorken ve depolama alanı azaldığında, OS bu dizinin dosyalarını otomatik olarak silebilir.
- **Library/Application Support/**
- Uygulamanın çalışması için gerekli **kalıcı** **dosyaları** içerir.
- Kullanıcılara **görünmez** ve kullanıcılar buraya yazamaz.
- Bu dizindeki içerik **yedeklenir**.
- Uygulama, `NSURLIsExcludedFromBackupKey` ayarlayarak yolları yedekten hariç tutabilir.
- **Library/Preferences/**
- Uygulama yeniden başlatılsa bile **kalıcı olabilen** özellikleri saklamak için kullanılır.
- Bilgiler, şifrelenmemiş olarak, uygulama sandbox'ı içinde \[BUNDLE_ID].plist adlı bir plist dosyasında saklanır.
- `NSUserDefaults` kullanılarak saklanan tüm anahtar/değer çiftleri bu dosyada bulunabilir.
- **tmp/**
- Bu dizini uygulama başlatmaları arasında kalması gerekmeyen **geçici dosyalar** yazmak için kullanın.
- Kalıcı olmayan önbelleğe alınmış dosyalar içerir.
- Kullanıcılara **görünmez**.
- Bu dizindeki içerik yedeklenmez.
- Uygulama çalışmıyorken ve depolama alanı azaldığında, OS bu dizinin dosyalarını otomatik olarak silebilir.

Bundle dizini içindeki iGoat-Swift'in Application Bundle (.app) dizinine daha yakından bakalım (`/var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app`):
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # ls
NSFileType      Perms  NSFileProtection    ...  Name
------------  -------  ------------------  ...  --------------------------------------
Regular           420  None                ...  rutger.html
Regular           420  None                ...  mansi.html
Regular           420  None                ...  splash.html
Regular           420  None                ...  about.html

Regular           420  None                ...  LICENSE.txt
Regular           420  None                ...  Sentinel.txt
Regular           420  None                ...  README.txt
```
### Binary Reversing

`<application-name>.app` klasörünün içinde `<application-name>` adlı bir binary dosyası bulacaksınız. Bu dosya **çalıştırılacak**. Binary üzerinde temel bir inceleme yapmak için **`otool`** aracını kullanabilirsiniz:
```bash
otool -Vh DVIA-v2 #Check some compilation attributes
magic  cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64    ARM64        ALL  0x00     EXECUTE    65       7112   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE

otool -L DVIA-v2 #Get third party libraries
DVIA-v2:
/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.1)
/usr/lib/libsqlite3.dylib (compatibility version 9.0.0, current version 274.6.0)
/usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11)
@rpath/Bolts.framework/Bolts (compatibility version 1.0.0, current version 1.0.0)
[...]
```
**Uygulamanın şifreli olup olmadığını kontrol et**

Aşağıdakiler için herhangi bir çıktı olup olmadığına bak:
```bash
otool -l <app-binary> | grep -A 4 LC_ENCRYPTION_INFO
```
**Binary'nin disassemblasyonu**

Text section'i disassemble edin:
```bash
otool -tV DVIA-v2
DVIA-v2:
(__TEXT,__text) section
+[DDLog initialize]:
0000000100004ab8    sub    sp, sp, #0x60
0000000100004abc    stp    x29, x30, [sp, #0x50]   ; Latency: 6
0000000100004ac0    add    x29, sp, #0x50
0000000100004ac4    sub    x8, x29, #0x10
0000000100004ac8    mov    x9, #0x0
0000000100004acc    adrp    x10, 1098 ; 0x10044e000
0000000100004ad0    add    x10, x10, #0x268
```
Örnek uygulamanın **Objective-C segmentini** yazdırmak için şunu kullanabilirsiniz:
```bash
otool -oV DVIA-v2
DVIA-v2:
Contents of (__DATA,__objc_classlist) section
00000001003dd5b8 0x1004423d0 _OBJC_CLASS_$_DDLog
isa        0x1004423a8 _OBJC_METACLASS_$_DDLog
superclass 0x0 _OBJC_CLASS_$_NSObject
cache      0x0 __objc_empty_cache
vtable     0x0
data       0x1003de748
flags          0x80
instanceStart  8
```
Daha kompakt Objective-C kodu elde etmek için [**class-dump**](http://stevenygard.com/projects/class-dump/) kullanabilirsiniz:
```bash
class-dump some-app
//
//     Generated by class-dump 3.5 (64 bit).
//
//     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2013 by Steve Nygard.
//

#pragma mark Named Structures

struct CGPoint {
double _field1;
double _field2;
};

struct CGRect {
struct CGPoint _field1;
struct CGSize _field2;
};

struct CGSize {
double _field1;
double _field2;
};
```
However, the best options to disassemble the binary are: [**Hopper**](https://www.hopperapp.com/download.html?) and [**IDA**](https://www.hex-rays.com/products/ida/support/download_freeware/).

## Data Storage

To learn about how iOS stores data in the device read this page:


{{#ref}}
ios-basics.md
{{#endref}}

> [!WARNING]
> The following places to store information should be checked **right after installing the application**, **after checking all the functionalities** of the application and even after **login out from one user and login into a different one**.\
> The goal is to find **unprotected sensitive information** of the application (passwords, tokens), of the current user and of previously logged users.

### Plist

**plist** files are structured XML files that **contains key-value pairs**. It's a way to store persistent data, so sometimes you may find **sensitive information in these files**. It's recommended to check these files after installing the app and after using intensively it to see if new data is written.

The most common way to persist data in plist files is through the usage of **NSUserDefaults**. This plist file is saved inside the app sandbox in **`Library/Preferences/<appBundleID>.plist`**

The [`NSUserDefaults`](https://developer.apple.com/documentation/foundation/nsuserdefaults) class provides a programmatic interface for interacting with the default system. The default system allows an application to customize its behaviour according to **user preferences**. Data saved by `NSUserDefaults` can be viewed in the application bundle. This class stores **data** in a **plist** **file**, but it's meant to be used with small amounts of data.

This data cannot be longer accessed directly via a trusted computer, but can be accessed performing a **backup**.

You can **dump** the information saved using **`NSUserDefaults`** using objection's `ios nsuserdefaults get`

To find all the plist of used by the application you can access to `/private/var/mobile/Containers/Data/Application/{APPID}` and run:
```bash
find ./ -name "*.plist"
```
Dosyaları **XML or binary (bplist)** formatından XML'e dönüştürmek için işletim sisteminize bağlı çeşitli yöntemler mevcuttur:

**macOS Kullanıcıları için:** `plutil` komutunu kullanın. Bu amaç için tasarlanmış, macOS (10.2+) içinde yerleşik bir araçtır:
```bash
$ plutil -convert xml1 Info.plist
```
**Linux Kullanıcıları İçin:** Önce `libplist-utils` paketini yükleyin, ardından dosyanızı dönüştürmek için `plistutil`'i kullanın:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
**Within an Objection Session:** Mobil uygulamaları analiz etmek için, belirli bir komut plist dosyalarını doğrudan dönüştürmenizi sağlar:
```bash
ios plist cat /private/var/mobile/Containers/Data/Application/<Application-UUID>/Library/Preferences/com.some.package.app.plist
```
### Core Data

[`Core Data`](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/nsfetchedresultscontroller.html#//apple_ref/doc/uid/TP40001075-CH8-SW1) uygulamanızdaki nesnelerin model katmanını yönetmek için bir framework'tür. [Core Data can use SQLite as its persistent store](https://cocoacasts.com/what-is-the-difference-between-core-data-and-sqlite/), ancak framework'ün kendisi bir veritabanı değildir.\

CoreData varsayılan olarak verilerini şifrelemez. Ancak CoreData'ya ek bir şifreleme katmanı eklenebilir. Daha fazla bilgi için [GitHub Repo](https://github.com/project-imas/encrypted-core-data)'ya bakın.

Bir uygulamanın SQLite Core Data bilgilerini şu yolda bulabilirsiniz: `/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support`

**Eğer SQLite'ı açıp hassas bilgilere erişebiliyorsanız, bu hatalı bir yapılandırma bulduğunuz anlamına gelir.**
```objectivec:Code from iGoat
-(void)storeDetails {
AppDelegate * appDelegate = (AppDelegate *)(UIApplication.sharedApplication.delegate);

NSManagedObjectContext *context =[appDelegate managedObjectContext];

User *user = [self fetchUser];
if (user) {
return;
}
user = [NSEntityDescription insertNewObjectForEntityForName:@"User"
inManagedObjectContext:context];
user.email = CoreDataEmail;
user.password = CoreDataPassword;
NSError *error;
if (![context save:&error]) {
NSLog(@"Error in saving data: %@", [error localizedDescription]);

}else{
NSLog(@"data stored in core data");
}
}
```
### YapDatabase

[YapDatabase](https://github.com/yapstudios/YapDatabase) SQLite üzerine inşa edilmiş bir anahtar/değer deposudur.\
Yap veritabanları sqlite veritabanı oldukları için onları önceki bölümde önerilen komutla bulabilirsiniz.

### Diğer SQLite Veritabanları

Uygulamaların kendi sqlite veritabanlarını oluşturması yaygındır. Bu veritabanlarında **hassas** **veri** **saklanıyor** olabilir ve şifrelenmemiş bırakılabilir. Bu nedenle, uygulama dizinindeki her veritabanını kontrol etmek her zaman önemlidir. Bu nedenle verilerin kaydedildiği uygulama dizinine gidin (`/private/var/mobile/Containers/Data/Application/{APPID}`)
```bash
find ./ -name "*.sqlite" -or -name "*.db"
```
### Firebase Real-Time Databases

Geliştiriciler, Firebase Real-Time Databases aracılığıyla bir **NoSQL bulut-barındırılan veritabanı** içinde **verileri depolayıp senkronize edebilirler**. Veriler JSON formatında saklanır ve gerçek zamanlı olarak tüm bağlı istemcilere senkronize edilir.

Yanlış yapılandırılmış Firebase veritabanlarını nasıl kontrol edeceğinizi şurada bulabilirsiniz:


{{#ref}}
../../network-services-pentesting/pentesting-web/buckets/firebase-database.md
{{#endref}}

### Realm databases

[Realm Objective-C](https://realm.io/docs/objc/latest/) and [Realm Swift](https://realm.io/docs/swift/latest/) Apple tarafından sağlanmayan veri depolama için güçlü bir alternatif sunar. Varsayılan olarak, **verileri şifrelenmemiş olarak depolarlar**, şifreleme belirli bir yapılandırma ile kullanılabilir.

Veritabanları şu konumda bulunur: `/private/var/mobile/Containers/Data/Application/{APPID}`. Bu dosyaları incelemek için şu gibi komutlar kullanılabilir:
```bash
iPhone:/private/var/mobile/Containers/Data/Application/A079DF84-726C-4AEA-A194-805B97B3684A/Documents root# ls
default.realm  default.realm.lock  default.realm.management/  default.realm.note|

$ find ./ -name "*.realm*"
```
Bu veritabanı dosyalarını görüntülemek için [**Realm Studio**](https://github.com/realm/realm-studio) aracı önerilir.

Bir Realm veritabanında şifreleme uygulamak için aşağıdaki kod parçası kullanılabilir:
```swift
// Open the encrypted Realm file where getKey() is a method to obtain a key from the Keychain or a server
let config = Realm.Configuration(encryptionKey: getKey())
do {
let realm = try Realm(configuration: config)
// Use the Realm as normal
} catch let error as NSError {
// If the encryption key is wrong, `error` will say that it's an invalid database
fatalError("Error opening realm: \(error)")
}
```
### Couchbase Lite Databases

[Couchbase Lite](https://github.com/couchbase/couchbase-lite-ios) **hafif** ve **gömülü** bir veritabanı motoru olarak tanımlanır ve **belge-odaklı** (NoSQL) yaklaşımını takip eder. **iOS** ve **macOS** için yerel olarak tasarlanmış olup, verileri sorunsuz şekilde senkronize etme imkanı sunar.

Bir cihazda potansiyel Couchbase veritabanlarını tespit etmek için aşağıdaki dizin incelenmelidir:
```bash
ls /private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support/
```
### Çerezler

iOS, uygulamaların çerezlerini her uygulamanın klasörünün içinde bulunan **`Library/Cookies/cookies.binarycookies`** dosyasında depolar. Ancak geliştiriciler bazen bunları **keychain**'e kaydetmeyi tercih ederler çünkü bahsedilen **çerez dosyasına yedeklerden erişilebilir**.

Çerez dosyasını incelemek için [**this python script**](https://github.com/mdegrazia/Safari-Binary-Cookie-Parser) veya objection'ın **`ios cookies get`.**\
**Ayrıca objection'ı kullanarak** bu dosyaları JSON formatına dönüştürebilir ve verileri inceleyebilirsiniz.
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios cookies get --json
[
{
"domain": "highaltitudehacks.com",
"expiresDate": "2051-09-15 07:46:43 +0000",
"isHTTPOnly": "false",
"isSecure": "false",
"name": "username",
"path": "/",
"value": "admin123",
"version": "0"
}
]
```
### Cache

By default NSURLSession stores data, such as **HTTP requests and responses in the Cache.db** database. This database can contain **sensitive data**, if tokens, usernames or any other sensitive information has been cached. To find the cached information open the data directory of the app (`/var/mobile/Containers/Data/Application/<UUID>`) and go to `/Library/Caches/<Bundle Identifier>`. The **WebKit cache is also being stored in the Cache.db** file. **Objection** can open and interact with the database with the command `sqlite connect Cache.db`, as it is a n**ormal SQLite database**.

Bu verilerin istek veya yanıttaki hassas bilgileri içerebileceği için, bu verilerin önbelleğe alınmasının devre dışı bırakılması önerilir. Aşağıdaki liste bunu başarmanın farklı yollarını göstermektedir:

1.  Oturum kapatma (logout) sonrasında Önbelleğe alınmış yanıtların kaldırılması önerilir. Bu, Apple tarafından sağlanan [`removeAllCachedResponses`](https://developer.apple.com/documentation/foundation/urlcache/1417802-removeallcachedresponses) adlı metod ile yapılabilir. Bu metodu şu şekilde çağırabilirsiniz:

`URLCache.shared.removeAllCachedResponses()`

Bu yöntem Cache.db dosyasındaki tüm önbelleğe alınmış istekleri ve yanıtları kaldıracaktır.

2.  Eğer cookie'lerin avantajını kullanmanız gerekmiyorsa, URLSession'ın [.ephemeral](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral) configuration özelliğini kullanmanız önerilir; bu, cookie ve cache kaydetmeyi devre dışı bırakır.

[Apple documentation](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral):

`An ephemeral session configuration object is similar to a default session configuration (see default), except that the corresponding session object doesn’t store caches, credential stores, or any session-related data to disk. Instead, session-related data is stored in RAM. The only time an ephemeral session writes data to disk is when you tell it to write the contents of a URL to a file.`

3.  Cache, Cache Policy'i [.notAllowed](https://developer.apple.com/documentation/foundation/urlcache/storagepolicy/notallowed) olarak ayarlayarak da devre dışı bırakılabilir. Bu, önbelleğin bellek veya disk üzerinde hiçbir şekilde saklanmasını engeller.

### Snapshots

Whenever you press the home button, iOS **takes a snapshot of the current screen** to be able to do the transition to the application on a much smoother way. However, if **sensitive** **data** is present in the current screen, it will be **saved** in the **image** (which **persists** **across** **reboots**). These are the snapshots that you can also access double tapping the home screen to switch between apps.

iPhone jailbreak'li değilse, bu ekran görüntülerini görebilmek için **saldırganın** **erişiminin** **cihaza** **kilidi açık** olması gerekir. Varsayılan olarak son snapshot uygulamanın sandbox'ında `Library/Caches/Snapshots/` veya `Library/SplashBoard/Snapshots` klasöründe saklanır (the trusted computers can' t access the filesystem from iOX 7.0).

Bu kötü davranışı önlemenin bir yolu, snapshot alınmadan önce boş bir ekran göstermek veya hassas verileri kaldırmaktır; bunu `ApplicationDidEnterBackground()` fonksiyonunu kullanarak yapabilirsiniz.

The following is a sample remediation method that will set a default screenshot.

Swift:
```swift
private var backgroundImage: UIImageView?

func applicationDidEnterBackground(_ application: UIApplication) {
let myBanner = UIImageView(image: #imageLiteral(resourceName: "overlayImage"))
myBanner.frame = UIScreen.main.bounds
backgroundImage = myBanner
window?.addSubview(myBanner)
}

func applicationWillEnterForeground(_ application: UIApplication) {
backgroundImage?.removeFromSuperview()
}
```
Objective-C:
```
@property (UIImageView *)backgroundImage;

- (void)applicationDidEnterBackground:(UIApplication *)application {
UIImageView *myBanner = [[UIImageView alloc] initWithImage:@"overlayImage.png"];
self.backgroundImage = myBanner;
self.backgroundImage.bounds = UIScreen.mainScreen.bounds;
[self.window addSubview:myBanner];
}

- (void)applicationWillEnterForeground:(UIApplication *)application {
[self.backgroundImage removeFromSuperview];
}
```
This sets the background image to `overlayImage.png` whenever the application is backgrounded. Bu, uygulama arka plana alındığında arka plan resmini `overlayImage.png` olarak ayarlar. Bu, hassas veri leaks'ini önler çünkü `overlayImage.png` her zaman mevcut görünümün üzerine yazacaktır.

### Keychain

iOS keychain'e erişim ve yönetim için, jailbroken cihazlar için uygun olan [**Keychain-Dumper**](https://github.com/ptoomey3/Keychain-Dumper) gibi araçlar mevcuttur. Ayrıca, [**Objection**](https://github.com/sensepost/objection) benzer amaçlar için `ios keychain dump` komutunu sağlar.

#### **Kimlik Bilgilerinin Saklanması**

Hassas bilgileri doğrudan keychain'e kaydetmek için **NSURLCredential** sınıfı idealdir; NSUserDefaults veya diğer wrapper'lara olan ihtiyacı ortadan kaldırır. Girişten sonra kimlik bilgilerini saklamak için aşağıdaki Swift kodu kullanılır:
```swift
NSURLCredential *credential;
credential = [NSURLCredential credentialWithUser:username password:password persistence:NSURLCredentialPersistencePermanent];
[[NSURLCredentialStorage sharedCredentialStorage] setCredential:credential forProtectionSpace:self.loginProtectionSpace];
```
Bu saklı kimlik bilgilerini çıkarmak için Objection'ın `ios nsurlcredentialstorage dump` komutu kullanılır.

## **Özel Klavyeler ve Klavye Önbelleği**

iOS 8.0 ve sonrası ile kullanıcılar **Ayarlar > Genel > Klavye > Klavyeler** altında yönetilebilen özel klavye uzantıları yükleyebilirler. Bu klavyeler genişletilmiş işlevsellik sunsa da keystroke logging ve verileri dış sunuculara gönderme riski taşırlar; ağ erişimi gerektiren klavyeler hakkında kullanıcılar bilgilendirilir. Uygulamalar hassas bilgi girişinde özel klavyelerin kullanımını sınırlayabilir ve sınırlamalıdır.

**Güvenlik Önerileri:**

- Artırılmış güvenlik için üçüncü taraf klavyelerin devre dışı bırakılması tavsiye edilir.
- Varsayılan iOS klavyesinin autocorrect ve auto-suggestions özelliklerinin, `Library/Keyboard/{locale}-dynamic-text.dat` veya `/private/var/mobile/Library/Keyboard/dynamic-text.dat` konumlarında bulunan önbellek dosyalarında hassas bilgileri depolayabileceğinin farkında olun. Bu önbellek dosyaları düzenli olarak hassas veriler açısından kontrol edilmelidir. Önbelleğe alınmış verileri temizlemek için **Ayarlar > Genel > Sıfırla > Klavye Sözlüğünü Sıfırla** yoluyla klavye sözlüğünün sıfırlanması önerilir.
- Ağ trafiğini yakalamak, özel bir klavyenin tuş vuruşlarını uzaktan aktarıp aktarmadığını ortaya çıkarabilir.

### **Metin Alanı Önbelleklemesini Önleme**

[UITextInputTraits protocol](https://developer.apple.com/reference/uikit/uitextinputtraits) autocorrection ve secure text entry'yi yönetmek için özellikler sunar; bu, hassas bilgilerin önbelleğe alınmasını önlemek için önemlidir. Örneğin, autocorrection'u devre dışı bırakmak ve secure text entry'yi etkinleştirmek şu şekilde yapılabilir:
```objectivec
textObject.autocorrectionType = UITextAutocorrectionTypeNo;
textObject.secureTextEntry = YES;
```
Ek olarak, geliştiriciler, özellikle passwords ve PINs gibi hassas bilgilerin girildiği metin alanlarının önbelleğe alınmasını devre dışı bırakmak için `autocorrectionType`'ı `UITextAutocorrectionTypeNo` ve `secureTextEntry`'i `YES` olarak ayarladıklarından emin olmalıdır.
```objectivec
UITextField *textField = [[UITextField alloc] initWithFrame:frame];
textField.autocorrectionType = UITextAutocorrectionTypeNo;
```
## **Kayıtlar**

Kod hata ayıklama genellikle **loglama** kullanımını içerir. Bu, **logların hassas bilgiler içerebileceği** için risk taşır. Önceden, iOS 6 ve önceki sürümlerde, loglara tüm uygulamalar erişebiliyordu ve bu durum hassas veri sızıntısı riskine yol açıyordu. **Şimdi, uygulamalar yalnızca kendi loglarına erişmekle sınırlıdır**.

Bu kısıtlamalara rağmen, kilidi açık bir cihaza fiziksel erişimi olan bir **saldırgan** cihazı bir bilgisayara bağlayarak bunu kötüye kullanabilir ve **logları okuyabilir**. Uygulama kaldırıldıktan sonra bile logların diskte kaldığını unutmayın.

Riskleri azaltmak için, uygulama ile **tüm fonksiyonlarını ve girdilerini kapsayacak şekilde derinlemesine etkileşimde bulunmanız** ve istemeden hassas bilgi kaydedilmediğinden emin olmanız önerilir.

Uygulamanın kaynak kodunu potansiyel sızıntılar için incelerken, yerleşik fonksiyonlar için `NSLog`, `NSAssert`, `NSCAssert`, `fprintf` gibi anahtar kelimeleri ve özel uygulamalar için `Logging` veya `Logfile` gibi ifadeleri kullanarak hem **ön tanımlı** hem de **özel logging ifadelerini** arayın.

### **Sistem Loglarını İzleme**

Uygulamalar hassas olabilecek çeşitli bilgiler kaydeder. Bu logları izlemek için şu araçlar ve komutlar kullanılır:
```bash
idevice_id --list   # To find the device ID
idevicesyslog -u <id> (| grep <app>)   # To capture the device logs
```
yararlıdır. Ek olarak, **Xcode** konsol loglarını toplamak için bir yol sağlar:

1. **Xcode**'u açın.
2. iOS cihazını bağlayın.
3. **Window** -> **Devices and Simulators** menüsüne gidin.
4. Cihazınızı seçin.
5. İncelediğiniz sorunu tetikleyin.
6. Logları yeni bir pencerede görüntülemek için **Open Console** düğmesini kullanın.

Daha gelişmiş loglama için, cihaza shell ile bağlanmak ve **socat** kullanmak gerçek zamanlı log izleme sağlayabilir:
```bash
iPhone:~ root# socat - UNIX-CONNECT:/var/run/lockdown/syslog.sock
```
Bunu, sorunları teşhis etmekte veya loglardaki olası veri sızıntılarını belirlemede çok değerli olabilecek log etkinliklerini gözlemlemek için verilen komutlar izler.

## Backups

**Auto-backup features** iOS'e entegre edilmiştir ve iTunes (macOS Catalina'ya kadar), Finder (macOS Catalina'dan itibaren) veya iCloud aracılığıyla cihaz verilerinin kopyalarının oluşturulmasını kolaylaştırır. Bu yedekler, Apple Pay bilgileri ve Touch ID yapılandırmaları gibi yüksek derecede hassas öğeler hariç neredeyse tüm cihaz verilerini kapsar.

### Security Risks

Yedeklere **yüklü uygulamalar ve verilerinin** dahil edilmesi, olası **veri sızıntısı** riskini ve **yedeklerde yapılacak değişikliklerin uygulama işlevselliğini etkileyebilme** riskini gündeme getirir. Bu riskleri azaltmak için herhangi bir uygulamanın dizininde veya alt dizinlerinde hassas bilgilerin **düz metin olarak saklanmaması** tavsiye edilir.

### Excluding Files from Backups

`Documents/` ve `Library/Application Support/` içindeki dosyalar varsayılan olarak yedeklenir. Geliştiriciler, belirli dosya veya dizinleri yedeklerden hariç tutmak için `NSURL setResourceValue:forKey:error:` ile `NSURLIsExcludedFromBackupKey` kullanabilir. Bu uygulama, hassas verilerin yedeklere dahil edilmesini engellemek için kritiktir.

### Testing for Vulnerabilities

Bir uygulamanın yedek güvenliğini değerlendirmek için önce Finder kullanarak **bir yedek oluşturun**, ardından [Apple'ın resmi dokümantasyonundaki](https://support.apple.com/en-us/HT204215) yönergeleri izleyerek yedeğin yerini bulun. Uygulama davranışını etkileyebilecek hassas veri veya yapılandırmalar için yedeği inceleyin.

Hassas bilgiler, komut satırı araçları veya [iMazing](https://imazing.com) gibi uygulamalar kullanılarak aranabilir. Şifreli yedekler için şifrelemenin varlığı, yedeğin kökündeki "Manifest.plist" dosyasındaki "IsEncrypted" anahtarını kontrol ederek doğrulanabilir.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
...
<key>Date</key>
<date>2021-03-12T17:43:33Z</date>
<key>IsEncrypted</key>
<true/>
...
</plist>
```
Şifreli yedeklerle uğraşırken, [DinoSec's GitHub repo](https://github.com/dinosec/iphone-dataprotection/tree/master/python_scripts) içinde bulunan Python scriptleri, örneğin **backup_tool.py** ve **backup_passwd.py**, yararlı olabilir; ancak en son iTunes/Finder sürümleriyle uyumluluk için uyarlama gerektirebilirler. [**iOSbackup** tool](https://pypi.org/project/iOSbackup/) parola korumalı yedeklerdeki dosyalara erişmek için başka bir seçenektir.

### Uygulama Davranışını Değiştirme

Yedek değişiklikleriyle uygulama davranışını değiştirmeye bir örnek, [Bither bitcoin wallet app](https://github.com/bither/bither-ios) üzerinde gösterilmiştir; burada UI lock PIN `net.bither.plist` içinde **pin_code** anahtarında saklanır. Bu anahtarı plist'ten kaldırıp yedeği geri yüklemek, PIN gereksinimini ortadan kaldırır ve sınırsız erişim sağlar.

## Hassas Veriler için Bellek Testi Özeti

Bir uygulamanın belleğinde saklanan hassas bilgilerle uğraşırken, bu verilerin maruz kalma süresini sınırlamak kritik önemdedir. Bellek içeriğini incelemek için iki ana yaklaşım vardır: **bellek dökümü oluşturma** ve **belleği gerçek zamanlı analiz etme**. Her iki yöntemin de zorlukları vardır; örneğin dump veya analiz sırasında kritik verilerin kaçırılma ihtimali bulunur.

## **Bellek Dökümünü Alma ve Analiz Etme**

Hem jailbroken hem de non-jailbroken cihazlar için, [objection](https://github.com/sensepost/objection) ve [Fridump](https://github.com/Nightbringer21/fridump) gibi araçlar bir uygulamanın process belleğini dump etmeye olanak tanır. Dump alındıktan sonra, bu verileri analiz etmek aradığınız bilgilerin niteliğine bağlı olarak çeşitli araçlar gerektirir.

Bir bellek dökümünden stringleri çıkarmak için `strings` veya `rabin2 -zz` gibi komutlar kullanılabilir:
```bash
# Extracting strings using strings command
$ strings memory > strings.txt

# Extracting strings using rabin2
$ rabin2 -ZZ memory > strings.txt
```
Belirli veri türlerini veya desenleri arama dahil daha ayrıntılı analiz için, **radare2** kapsamlı arama yetenekleri sunar:
```bash
$ r2 <name_of_your_dump_file>
[0x00000000]> /?
...
```
## **Çalışma Zamanı Bellek Analizi**

**r2frida** gerçek zamanlı olarak bir uygulamanın belleğini incelemek için memory dump'a ihtiyaç duymadan güçlü bir alternatif sağlar. Bu araç, çalışan uygulamanın belleği üzerinde doğrudan arama komutları yürütmeyi mümkün kılar:
```bash
$ r2 frida://usb//<name_of_your_app>
[0x00000000]> /\ <search_command>
```
## Bozuk Cryptography

### Zayıf Key Management Süreçleri

Bazı geliştiriciler hassas verileri local storage'da saklar ve kodda hardcoded/predictable bir key ile şifreler. Bu yapılmamalıdır çünkü bazı reversing durumları saldırganların gizli bilgileri çıkarmasına izin verebilir.

### Güvensiz ve/veya Deprecated Algorithms Kullanımı

Geliştiriciler authorisation **checks**, **store** veya **send** etmek için **deprecated algorithms** kullanmamalıdır. Bu algoritmalardan bazıları: RC4, MD4, MD5, SHA1... Örneğin **hashes** şifreleri saklamak için kullanılıyorsa, salt ile birlikte hashes brute-force **resistant** kullanılmalıdır.

### Kontrol

Yapılması gereken ana kontroller, kod içinde **hardcoded** passwords/secrets bulup bulamadığınız, bunların **predictable** olup olmadığı ve kodun herhangi bir tür **weak** **cryptography** algoritması kullanıp kullanmadığıdır.

Bazı **crypto** **libraries**'i **objection** ile otomatik olarak **monitor** edebileceğinizi bilmek ilginçtir:
```swift
ios monitor crypt
```
iOS kriptografik API'leri ve kütüphaneleri hakkında **daha fazla bilgi** için şu adresi ziyaret edin [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography)

## Yerel Kimlik Doğrulama

**Yerel kimlik doğrulama**, özellikle uzak bir uçnoktan kriptografik yöntemlerle erişimi koruma söz konusu olduğunda hayati bir rol oynar. Önemli olan nokta, doğru uygulanmadığında yerel kimlik doğrulama mekanizmalarının atlatılabileceğidir.

Apple'ın [**Local Authentication framework**](https://developer.apple.com/documentation/localauthentication) ve [**keychain**](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html) geliştiricilere sırasıyla kullanıcı kimlik doğrulama diyalogları sağlamak ve gizli verileri güvenli şekilde yönetmek için güçlü API'ler sunar. Secure Enclave, Touch ID için parmak izi verisini korur; Face ID ise biyometrik veriyi tehlikeye atmadan yüz tanımaya dayanır.

Touch ID/Face ID'yi entegre etmek için geliştiricilerin iki API seçeneği vardır:

- **`LocalAuthentication.framework`**: biyometrik verilere erişim olmadan yüksek seviyede kullanıcı kimlik doğrulaması sağlar.
- **`Security.framework`**: keychain hizmetlerine daha düşük seviyede erişim sağlar; gizli verileri biyometrik kimlik doğrulama ile korur. Çeşitli [open-source wrappers](https://www.raywenderlich.com/147308/secure-ios-user-data-keychain-touch-id) keychain erişimini basitleştirir.

> [!CAUTION]
> Ancak, hem `LocalAuthentication.framework` hem de `Security.framework` öncelikle boolean değerleri döndürdükleri ve kimlik doğrulama süreçleri için veri iletmedikleri için atlatılmaya müsaittir (bkz. [Don't touch me that way, by David Lindner et al](https://www.youtube.com/watch?v=XhXIHVGCFFM)).

### Yerel Kimlik Doğrulamanın Uygulanması

Kullanıcılardan kimlik doğrulama talep etmek için geliştiriciler **`LAContext`** sınıfındaki **`evaluatePolicy`** metodunu kullanmalıdır. Tercih edilebilecek politikalar:

- **`deviceOwnerAuthentication`**: Touch ID veya cihaz parolası için istem oluşturur; ikisi de etkin değilse başarısız olur.
- **`deviceOwnerAuthenticationWithBiometrics`**: Sadece Touch ID için istem oluşturur.

Başarılı bir kimlik doğrulama, **`evaluatePolicy`** metodundan dönen boolean değeri ile belirtilir; bu durum potansiyel bir güvenlik açığını işaret eder.

### Keychain Kullanarak Yerel Kimlik Doğrulama

iOS uygulamalarında yerel kimlik doğrulamanın uygulanması, authentication token gibi gizli verileri güvenli şekilde saklamak için keychain API'lerinin kullanılmasını içerir. Bu süreç, verinin yalnızca kullanıcı tarafından, cihaz parolası veya Touch ID gibi biyometrik kimlik doğrulama kullanılarak erişilebilir olmasını sağlar.

Keychain, öğelerin `SecAccessControl` özniteliği ile ayarlanmasına izin verir; bu, kullanıcı Touch ID veya cihaz parolası ile başarılı şekilde kimlik doğrulaması yapana kadar öğeye erişimi kısıtlar. Bu özellik güvenliği artırmak için kritik öneme sahiptir.

Aşağıda Swift ve Objective-C'de keychain'e bir string kaydetme ve geri okuma işlemlerini gösteren kod örnekleri bulunmaktadır; örnekler özellikle Touch ID kimlik doğrulaması gerektirecek şekilde access control kurulmasını ve verinin sadece kurulduğu cihazda, cihaz parolası yapılandırılmışsa erişilebilir olmasını göstermektedir.

{{#tabs}}
{{#tab name="Swift"}}
```swift
// From https://github.com/mufambisi/owasp-mstg/blob/master/Document/0x06f-Testing-Local-Authentication.md

// 1. create AccessControl object that will represent authentication settings

var error: Unmanaged<CFError>?

guard let accessControl = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
SecAccessControlCreateFlags.biometryCurrentSet,
&error) else {
// failed to create AccessControl object

return
}

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute

var query: [String: Any] = [:]

query[kSecClass as String] = kSecClassGenericPassword
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecAttrAccount as String] = "OWASP Account" as CFString
query[kSecValueData as String] = "test_strong_password".data(using: .utf8)! as CFData
query[kSecAttrAccessControl as String] = accessControl

// 3. save item

let status = SecItemAdd(query as CFDictionary, nil)

if status == noErr {
// successfully saved
} else {
// error while saving
}
```
{{#endtab}}

{{#tab name="Objective-C"}}
```objectivec
// 1. create AccessControl object that will represent authentication settings
CFErrorRef *err = nil;

SecAccessControlRef sacRef = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
kSecAccessControlUserPresence,
err);

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute
NSDictionary* query = @{
(_ _bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecAttrAccount: @"OWASP Account",
(__bridge id)kSecValueData: [@"test_strong_password" dataUsingEncoding:NSUTF8StringEncoding],
(__bridge id)kSecAttrAccessControl: (__bridge_transfer id)sacRef
};

// 3. save item
OSStatus status = SecItemAdd((__bridge CFDictionaryRef)query, nil);

if (status == noErr) {
// successfully saved
} else {
// error while saving
}
```
{{#endtab}}
{{#endtabs}}

Artık kaydedilmiş öğeyi Keychain'den isteyebiliriz. Keychain servisleri kullanıcıya kimlik doğrulama iletişim kutusunu gösterecek ve uygun bir parmak izi sağlanıp sağlanmadığına bağlı olarak veri veya nil döndürecektir.

{{#tabs}}
{{#tab name="Swift"}}
```swift
// 1. define query
var query = [String: Any]()
query[kSecClass as String] = kSecClassGenericPassword
query[kSecReturnData as String] = kCFBooleanTrue
query[kSecAttrAccount as String] = "My Name" as CFString
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecUseOperationPrompt as String] = "Please, pass authorisation to enter this area" as CFString

// 2. get item
var queryResult: AnyObject?
let status = withUnsafeMutablePointer(to: &queryResult) {
SecItemCopyMatching(query as CFDictionary, UnsafeMutablePointer($0))
}

if status == noErr {
let password = String(data: queryResult as! Data, encoding: .utf8)!
// successfully received password
} else {
// authorization not passed
}
```
{{#endtab}}

{{#tab name="Objective-C"}}
```objectivec
// 1. define query
NSDictionary *query = @{(__bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecReturnData: @YES,
(__bridge id)kSecAttrAccount: @"My Name1",
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecUseOperationPrompt: @"Please, pass authorisation to enter this area" };

// 2. get item
CFTypeRef queryResult = NULL;
OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)query, &queryResult);

if (status == noErr){
NSData* resultData = ( __bridge_transfer NSData* )queryResult;
NSString* password = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding];
NSLog(@"%@", password);
} else {
NSLog(@"Something went wrong");
}
```
{{#endtab}}
{{#endtabs}}

### Tespit

Bir uygulamada framework kullanımını, uygulama ikili dosyasının paylaşılan dinamik kütüphaneler listesini analiz ederek tespit etmek de mümkündür. Bu, `otool` kullanılarak yapılabilir:
```bash
$ otool -L <AppName>.app/<AppName>
```
Eğer `LocalAuthentication.framework` bir uygulamada kullanılıyorsa, çıktı aşağıdaki iki satırı içerecektir (unutmayın ki `LocalAuthentication.framework` altında `Security.framework` kullanır):
```bash
/System/Library/Frameworks/LocalAuthentication.framework/LocalAuthentication
/System/Library/Frameworks/Security.framework/Security
```
If `Security.framework` is used, only the second one will be shown.

### Local Authentication Framework Bypass

#### **Objection**

Bu [this GitHub page](https://github.com/sensepost/objection/wiki/Understanding-the-iOS-Biometrics-Bypass) adresinde bulunan **Objection Biometrics Bypass** aracılığıyla **LocalAuthentication** mekanizmasını aşmak için bir teknik mevcuttur. Bu yaklaşımın özü, `evaluatePolicy` fonksiyonunu manipüle etmek için **Frida**'yı kullanmayı içerir; böylece gerçek kimlik doğrulama başarısından bağımsız olarak sürekli `True` sonucu döndürmesi sağlanır. Bu, hatalı biyometrik kimlik doğrulama süreçlerini bypass etmek için özellikle kullanışlıdır.

Bu bypass'ı etkinleştirmek için aşağıdaki komut kullanılır:
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios ui biometrics_bypass
(agent) Registering job 3mhtws9x47q. Type: ios-biometrics-disable
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # (agent) [3mhtws9x47q] Localized Reason for auth requirement: Please authenticate yourself
(agent) [3mhtws9x47q] OS authentication response: false
(agent) [3mhtws9x47q] Marking OS response as True instead
(agent) [3mhtws9x47q] Biometrics bypass hook complete
```
Bu komut, Objection'ın `evaluatePolicy` kontrolünün sonucunu fiilen `True` olarak değiştiren bir görev kaydettiği bir diziyi başlatır.

#### Frida

[DVIA-v2 application](https://github.com/prateek147/DVIA-v2) kaynağından **`evaluatePolicy`** kullanımına bir örnek:
```swift
+(void)authenticateWithTouchID {
LAContext *myContext = [[LAContext alloc] init];
NSError *authError = nil;
NSString *myLocalizedReasonString = @"Please authenticate yourself";

if ([myContext canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&authError]) {
[myContext evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics
localizedReason:myLocalizedReasonString
reply:^(BOOL success, NSError *error) {
if (success) {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Successful" withTitle:@"Success"];
});
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Failed !" withTitle:@"Error"];
});
}
}];
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Your device doesn't support Touch ID or you haven't configured Touch ID authentication on your device" withTitle:@"Error"];
});
}
}
```
Local Authentication'ın **bypass**'ını gerçekleştirmek için bir Frida scripti yazılmıştır. Bu script, **evaluatePolicy** kontrolünü hedef alır ve callback'ini yakalayarak **success=1** döndüğünden emin olur. Callback'in davranışını değiştirerek kimlik doğrulama kontrolü etkin bir şekilde bypass edilir.

Aşağıdaki script, **evaluatePolicy** metodunun sonucunu değiştirmek için enjekte edilir. Callback'in sonucunu her zaman başarıyı gösterecek şekilde değiştirir.
```swift
// from https://securitycafe.ro/2022/09/05/mobile-pentesting-101-bypassing-biometric-authentication/
if(ObjC.available) {
console.log("Injecting...");
var hook = ObjC.classes.LAContext["- evaluatePolicy:localizedReason:reply:"];
Interceptor.attach(hook.implementation, {
onEnter: function(args) {
var block = new ObjC.Block(args[4]);
const callback = block.implementation;
block.implementation = function (error, value)  {

console.log("Changing the result value to true")
const result = callback(1, null);
return result;
};
},
});
} else {
console.log("Objective-C Runtime is not available!");
}
```
Frida betiğini enjekte etmek ve biyometrik kimlik doğrulamasını atlatmak için aşağıdaki komut kullanılır:
```bash
frida -U -f com.highaltitudehacks.DVIAswiftv2 --no-pause -l fingerprint-bypass-ios.js
```
## IPC Yoluyla Hassas İşlevsellik İfşası

### Custom URI Handlers / Deeplinks / Custom Schemes


{{#ref}}
ios-custom-uri-handlers-deeplinks-custom-schemes.md
{{#endref}}

### Universal Links


{{#ref}}
ios-universal-links.md
{{#endref}}

### UIActivity Sharing


{{#ref}}
ios-uiactivity-sharing.md
{{#endref}}

### UIPasteboard


{{#ref}}
ios-uipasteboard.md
{{#endref}}

### App Extensions


{{#ref}}
ios-app-extensions.md
{{#endref}}

### WebViews


{{#ref}}
ios-webviews.md
{{#endref}}

### Serialisation and Encoding


{{#ref}}
ios-serialisation-and-encoding.md
{{#endref}}

## Ağ İletişimi

İletişimin **şifreleme olmadan** gerçekleşmediğini ve uygulamanın sunucunun **TLS sertifikasını** doğru şekilde doğruladığını kontrol etmek önemlidir.\
Bu tür sorunları kontrol etmek için **Burp** gibi bir proxy kullanabilirsiniz:


{{#ref}}
burp-configuration-for-ios.md
{{#endref}}

### Hostname kontrolü

TLS sertifikasını doğrularken yaygın bir sorun, sertifikanın **güvenilir** bir **CA** tarafından imzalandığını kontrol etmek fakat sertifikanın **hostname**'inin erişilen hostname olup olmadığını **kontrol etmemektir**.\
Bu problemi Burp ile kontrol etmek için, iPhone'da Burp CA'ya güven verdikten sonra, Burp ile farklı bir hostname için **yeni bir sertifika oluşturup** bunu kullanabilirsiniz. Uygulama hâlâ çalışıyorsa, o zaman bir zafiyeti var demektir.

### Certificate Pinning

Eğer bir uygulama doğru şekilde SSL Pinning kullanıyorsa, uygulama yalnızca beklenen sertifika kullanıldığında çalışır. Bir uygulamayı test ederken **bu bir sorun olabilir çünkü Burp kendi sertifikasını sunar.**\
Bu korumayı atlatmak için jailbroken bir cihazda [**SSL Kill Switch**](https://github.com/nabla-c0d3/ssl-kill-switch2) uygulamasını yükleyebilir veya [**Burp Mobile Assistant**](https://portswigger.net/burp/documentation/desktop/mobile/config-ios-device) yükleyebilirsiniz.

Ayrıca **objection**'ın `ios sslpinning disable` komutunu kullanabilirsiniz

## Diğer

- In **`/System/Library`** you can find the frameworks installed in the phone used by system applications
- App Store'dan kullanıcı tarafından yüklenen uygulamalar **`/User/Applications`** içinde bulunur
- Ve **`/User/Library`** kullanıcı seviyesindeki uygulamalar tarafından kaydedilen verileri içerir
- Uygulama içinde kaydedilen notları okumak için **`/User/Library/Notes/notes.sqlite`** dosyasına erişebilirsiniz.
- Yüklü bir uygulamanın klasörü içinde (**`/User/Applications/<APP ID>/`**) bazı ilginç dosyalar bulabilirsiniz:
- **`iTunesArtwork`**: Uygulama tarafından kullanılan ikon
- **`iTunesMetadata.plist`**: Uygulamanın App Store'da kullanılan bilgileri
- **`/Library/*`**: Tercihleri ve önbelleği içerir. **`/Library/Cache/Snapshots/*`** içinde uygulama arka plana gönderilmeden önce alınan snapshot'ı bulabilirsiniz.

### Hot Patching/Enforced Updateing

Geliştiriciler uygulamalarının tüm kurulumlarını App Store'a yeniden göndermeden ve onay beklemeden uzaktan anında **patch'leyebilirler**.\
Bu amaçla genellikle [**JSPatch**](https://github.com/bang590/JSPatch) kullanılır. Ancak [Siren](https://github.com/ArtSabintsev/Siren) ve [react-native-appstore-version-checker](https://www.npmjs.com/package/react-native-appstore-version-checker) gibi diğer seçenekler de vardır.\
**Bu, kötü amaçlı üçüncü taraf SDK'lar tarafından kötüye kullanılabilecek tehlikeli bir mekanizmadır; bu nedenle hangi yöntemin otomatik güncelleme için kullanıldığını (varsa) kontrol etmek ve test etmek önerilir.** Bu amaçla uygulamanın önceki bir sürümünü indirip deneyebilirsiniz.

### Third Parties

3rd party SDKs ile ilgili önemli bir zorluk, işlevleri üzerinde **ayrıntılı kontrol eksikliğidir**. Geliştiriciler ya SDK'yı entegre edip potansiyel güvenlik açıkları ve gizlilik endişeleri dahil tüm özelliklerini kabul etmek zorunda kalır, ya da avantajlarından tamamen vazgeçer. Çoğu zaman geliştiriciler bu SDK'lardaki güvenlik açıklarını kendileri yamayamazlar. Ayrıca, SDK'lar toplumda güven kazandıkça bazıları kötü amaçlı yazılım içermeye başlayabilir.

Üçüncü taraf SDK'ların sağladığı hizmetler kullanıcı davranışı takibi, reklam gösterimleri veya kullanıcı deneyimi iyileştirmeleri içerebilir. Ancak bu, geliştiricilerin bu kütüphaneler tarafından yürütülen koda tamamen hakim olmaması nedeniyle gizlilik ve güvenlik riskleri doğurur. Üçüncü taraf hizmetlerle paylaşılan bilgilerin yalnızca gerekli olanla sınırlandırılması ve hiçbir hassas verinin ifşa edilmemesinin sağlanması çok önemlidir.

Üçüncü taraf hizmetlerin uygulanması genellikle iki şekilde olur: bağımsız bir kütüphane veya tam bir SDK. Kullanıcı gizliliğini korumak için bu hizmetlerle paylaşılan herhangi bir veri, Kişisel Olarak Tanımlanabilir Bilgileri (PII) ifşa edilmesini önlemek amacıyla **anonimleştirilmelidir**.

Bir uygulamanın kullandığı kütüphaneleri belirlemek için **`otool`** komutu kullanılabilir. Ek kütüphaneleri keşfetmek için bu araç uygulamaya ve uygulamanın kullandığı her paylaşılan kütüphaneye karşı çalıştırılmalıdır.
```bash
otool -L <application_path>
```
## İlginç Zafiyetler & Vaka İncelemeleri


{{#ref}}
air-keyboard-remote-input-injection.md
{{#endref}}

{{#ref}}
itunesstored-bookassetd-sandbox-escape.md
{{#endref}}

## **Referanslar & Diğer Kaynaklar**

- [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering)
- [iOS & Mobile App Pentesting - INE](https://my.ine.com/CyberSecurity/courses/089d060b/ios-mobile-app-pentesting)
- [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/)
- [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/)
- [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/)
- [https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage](https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage)
- [https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way](https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053)
- [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060)
- [https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/](https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064](https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064)
- [https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc](https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054)
- [https://github.com/ivRodriguezCA/RE-iOS-Apps/](https://github.com/ivRodriguezCA/RE-iOS-Apps/) IOS ücretsiz kurs([https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/](https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/))
- [https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577](https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577)
- [https://www.slideshare.net/RyanISI/ios-appsecurityminicourse](https://www.slideshare.net/RyanISI/ios-appsecurityminicourse)
- [https://github.com/prateek147/DVIA](https://github.com/prateek147/DVIA)
- [https://github.com/prateek147/DVIA-v2](https://github.com/prateek147/DVIA-v2)
- [https://github.com/OWASP/MSTG-Hacking-Playground%20](https://github.com/OWASP/MSTG-Hacking-Playground)
- OWASP iGoat [_https://github.com/OWASP/igoat_](https://github.com/OWASP/igoat) <<< Objective-C sürümü [_https://github.com/OWASP/iGoat-Swift_](https://github.com/OWASP/iGoat-Swift) <<< Swift sürümü
- [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
- [https://github.com/nabla-c0d3/ssl-kill-switch2](https://github.com/nabla-c0d3/ssl-kill-switch2)


{{#include ../../banners/hacktricks-training.md}}
