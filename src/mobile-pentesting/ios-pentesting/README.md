# iOS Pentesting

{{#include ../../banners/hacktricks-training.md}}

## iOS Βασικά


{{#ref}}
ios-basics.md
{{#endref}}

## Περιβάλλον Δοκιμών

Σε αυτή τη σελίδα μπορείτε να βρείτε πληροφορίες για το **iOS simulator**, **emulators** και **jailbreaking:**


{{#ref}}
ios-testing-environment.md
{{#endref}}

## Αρχική Ανάλυση

### Βασικές Ενέργειες Δοκιμών iOS

Κατά τη διάρκεια των δοκιμών θα προταθούν **πολλές ενέργειες** (σύνδεση στη συσκευή, ανάγνωση/εγγραφή/ανέβασμα/λήψη αρχείων, χρήση εργαλείων...). Επομένως, αν δεν ξέρετε πώς να εκτελέσετε κάποια από αυτές τις ενέργειες, παρακαλώ, **ξεκινήστε διαβάζοντας τη σελίδα**:


{{#ref}}
basic-ios-testing-operations.md
{{#endref}}

> [!TIP]
> Για τα επόμενα βήματα **η εφαρμογή πρέπει να είναι εγκατεστημένη** στη συσκευή και πρέπει ήδη να έχετε αποκτήσει το **IPA file** της εφαρμογής.\
> Read the [Basic iOS Testing Operations](basic-ios-testing-operations.md) page to learn how to do this.

### Βασική Στατική Ανάλυση

Μερικά ενδιαφέροντα decompilers για iOS - αρχεία IPA:

- [https://github.com/LaurieWired/Malimite](https://github.com/LaurieWired/Malimite)
- [https://ghidra-sre.org/](https://ghidra-sre.org/)

Συνιστάται η χρήση του εργαλείου [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) για την αυτόματη εκτέλεση μιας Static Analysis στο αρχείο IPA.

Αναγνώριση των **προστασιών που υπάρχουν στο binary**:

- **PIE (Position Independent Executable)**: Όταν είναι ενεργοποιημένο, η εφαρμογή φορτώνεται σε μια τυχαία διεύθυνση μνήμης κάθε φορά που ξεκινά, καθιστώντας δυσκολότερο τον προσδιορισμό της αρχικής διεύθυνσης μνήμης.

```bash
otool -hv <app-binary> | grep PIE   # It should include the PIE flag
```

- **Stack Canaries**: Για την επικύρωση της ακεραιότητας του stack, μια τιμή ‘canary’ τοποθετείται στο stack πριν την κλήση μιας συνάρτησης και επικυρώνεται ξανά όταν η συνάρτηση τελειώνει.

```bash
otool -I -v <app-binary> | grep stack_chk   # It should include the symbols: stack_chk_guard and stack_chk_fail
```

- **ARC (Automatic Reference Counting)**: Για την αποτροπή κοινών σφαλμάτων διαχείρισης μνήμης

```bash
otool -I -v <app-binary> | grep objc_release   # It should include the _objc_release symbol
```

- **Encrypted Binary**: Το binary θα πρέπει να είναι κρυπτογραφημένο

```bash
otool -arch all -Vl <app-binary> | grep -A5 LC_ENCRYPT   # The cryptid should be 1
```

**Αναγνώριση Ευαίσθητων/Μη Ασφαλών Συναρτήσεων**

- **Weak Hashing Algorithms**

```bash
# On the iOS device
otool -Iv <app> | grep -w "_CC_MD5"
otool -Iv <app> | grep -w "_CC_SHA1"

# On linux
grep -iER "_CC_MD5"
grep -iER "_CC_SHA1"
```

- **Insecure Random Functions**

```bash
# On the iOS device
otool -Iv <app> | grep -w "_random"
otool -Iv <app> | grep -w "_srand"
otool -Iv <app> | grep -w "_rand"

# On linux
grep -iER "_random"
grep -iER "_srand"
grep -iER "_rand"
```

- **Insecure ‘Malloc’ Function**

```bash
# On the iOS device
otool -Iv <app> | grep -w "_malloc"

# On linux
grep -iER "_malloc"
```

- **Insecure and Vulnerable Functions**

```bash
# On the iOS device
otool -Iv <app> | grep -w "_gets"
otool -Iv <app> | grep -w "_memcpy"
otool -Iv <app> | grep -w "_strncpy"
otool -Iv <app> | grep -w "_strlen"
otool -Iv <app> | grep -w "_vsnprintf"
otool -Iv <app> | grep -w "_sscanf"
otool -Iv <app> | grep -w "_strtok"
otool -Iv <app> | grep -w "_alloca"
otool -Iv <app> | grep -w "_sprintf"
otool -Iv <app> | grep -w "_printf"
otool -Iv <app> | grep -w "_vsprintf"

# On linux
grep -R "_gets"
grep -iER "_memcpy"
grep -iER "_strncpy"
grep -iER "_strlen"
grep -iER "_vsnprintf"
grep -iER "_sscanf"
grep -iER "_strtok"
grep -iER "_alloca"
grep -iER "_sprintf"
grep -iER "_printf"
grep -iER "_vsprintf"
```

#### Συνήθεις μέθοδοι ανίχνευσης Jailbreak

- **File System Checks**: Έλεγχος για την παρουσία κοινών αρχείων και καταλόγων jailbreak, όπως `/Applications/Cydia.app` ή `/Library/MobileSubstrate/MobileSubstrate.dylib`.
- **Sandbox Violations**: Προσπάθεια πρόσβασης σε περιορισμένες περιοχές του file system, οι οποίες θα πρέπει να είναι μπλοκαρισμένες σε μη-jailbroken συσκευές.
- **API Checks**: Έλεγχος αν είναι δυνατή η χρήση απαγορευμένων κλήσεων όπως `fork()` για δημιουργία child process ή `system()` για να ελεγχθεί αν υπάρχει /bin/sh.
- **Process Checks**: Παρακολούθηση για την παρουσία γνωστών διεργασιών σχετικών με jailbreak, όπως `Cydia`, `Substrate`, ή `ssh`.
- **Kernel Exploits**: Έλεγχος για την παρουσία kernel exploits που χρησιμοποιούνται συχνά σε jailbreaks.
- **Environment Variables**: Έλεγχος μεταβλητών περιβάλλοντος για ενδείξεις jailbreak, όπως `DYLD_INSERT_LIBRARIES`.
- **Libraries Check**: Έλεγχος των libs που φορτώνονται στη διεργασία της εφαρμογής.
- **Check schemes**: Όπως `canOpenURL(URL(string: "cydia://"))`.

#### Συνήθεις μέθοδοι ανίχνευσης Anti-Debugging

- **Check for Debugger Presence**: Χρήση `sysctl` ή άλλων μεθόδων για να ελεγχθεί αν ένας debugger είναι συνδεδεμένος.
- **Anti-Debugging APIs**: Έλεγχος κλήσεων σε anti-debugging APIs όπως `ptrace` ή `SIGSTOP` όπως `ptrace(PT_DENY_ATTACH, 0, 0, 0)`.
- **Timing Checks**: Μέτρηση του χρόνου που απαιτείται για ορισμένες ενέργειες και έλεγχος για ανωμαλίες που μπορεί να υποδηλώνουν debugging.
- **Memory Checks**: Επιθεώρηση μνήμης για γνωστά artifacts ή τροποποιήσεις που αφήνουν debuggers.
- **Environment Variables**: Έλεγχος μεταβλητών περιβάλλοντος που μπορεί να υποδεικνύουν debugging session.
- **Mach Ports**: Ανίχνευση αν χρησιμοποιούνται mach exception ports από debuggers.

### Βασική Δυναμική Ανάλυση

Δείτε τη dynamic analysis που εκτελεί το [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF). Θα χρειαστεί να περιηγηθείτε στις διαφορετικές προβολές και να αλληλεπιδράσετε με αυτές, αλλά το εργαλείο θα κάνει hooking σε αρκετές κλάσεις και θα ετοιμάσει μια αναφορά μόλις τελειώσετε.

### Καταγραφή Εγκατεστημένων Εφαρμογών

Χρησιμοποιήστε την εντολή `frida-ps -Uai` για να προσδιορίσετε το **bundle identifier** των εγκατεστημένων apps:
```bash
$ frida-ps -Uai
PID  Name                 Identifier
----  -------------------  -----------------------------------------
6847  Calendar             com.apple.mobilecal
6815  Mail                 com.apple.mobilemail
-  App Store            com.apple.AppStore
-  Apple Store          com.apple.store.Jolly
-  Calculator           com.apple.calculator
-  Camera               com.apple.camera
-  iGoat-Swift          OWASP.iGoat-Swift
```
### Βασική Enumeration & Hooking

Μάθετε πώς να **enumerate the components of the application** και πώς να **hook methods and classes** εύκολα με objection:


{{#ref}}
ios-hooking-with-objection.md
{{#endref}}

### Δομή IPA

Η δομή ενός **IPA file** είναι ουσιαστικά αυτή ενός **zipped package**. Μετονοματίζοντας την επέκτασή του σε `.zip`, μπορεί να **αποσυμπιεστεί** για να αποκαλύψει τα περιεχόμενά του. Μέσα σε αυτή τη δομή, ένα **Bundle** αντιπροσωπεύει μια πλήρως πακεταρισμένη εφαρμογή έτοιμη για εγκατάσταση. Στο εσωτερικό, θα βρείτε έναν κατάλογο με όνομα `<NAME>.app`, που περιλαμβάνει τους πόρους της εφαρμογής.

- **`Info.plist`**: Αυτό το αρχείο περιέχει συγκεκριμένες ρυθμίσεις της εφαρμογής.
- **`_CodeSignature/`**: Αυτός ο φάκελος περιλαμβάνει ένα αρχείο plist που περιέχει μια υπογραφή, εξασφαλίζοντας την ακεραιότητα όλων των αρχείων στο bundle.
- **`Assets.car`**: Ένα συμπιεσμένο αρχείο που αποθηκεύει αρχεία πόρων όπως εικονίδια.
- **`Frameworks/`**: Αυτός ο φάκελος φιλοξενεί τις native βιβλιοθήκες της εφαρμογής, που μπορεί να είναι σε μορφή `.dylib` ή `.framework`.
- **`PlugIns/`**: Μπορεί να περιλαμβάνει επεκτάσεις της εφαρμογής, γνωστές ως αρχεία `.appex`, αν και δεν είναι πάντα παρούσες. \* [**`Core Data`**](https://developer.apple.com/documentation/coredata): Χρησιμοποιείται για την αποθήκευση των μόνιμων δεδομένων της εφαρμογής για offline χρήση, για προσωρινή αποθήκευση (caching) προσωρινών δεδομένων και για την προσθήκη λειτουργίας undo στην εφαρμογή σε μεμονωμένη συσκευή. Για να συγχρονίσει δεδομένα σε πολλές συσκευές με έναν κοινό λογαριασμό iCloud, το Core Data αντικατοπτρίζει αυτόματα το σχήμα σας σε ένα CloudKit container.
- [**`PkgInfo`**](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigApplications.html): Το αρχείο `PkgInfo` είναι ένας εναλλακτικός τρόπος για να καθορίσετε τους κωδικούς τύπου και δημιουργού της εφαρμογής ή του bundle.
- **en.lproj, fr.proj, Base.lproj**: Είναι τα πακέτα γλώσσας που περιέχουν πόρους για αυτές τις συγκεκριμένες γλώσσες, καθώς και ένα προεπιλεγμένο resource σε περίπτωση που μια γλώσσα δεν υποστηρίζεται.
- **Ασφάλεια**: Ο φάκελος `_CodeSignature/` παίζει κρίσιμο ρόλο στην ασφάλεια της εφαρμογής επαληθεύοντας την ακεραιότητα όλων των αρχείων που περιλαμβάνονται στο bundle μέσω ψηφιακών υπογραφών.
- **Διαχείριση πόρων**: Το αρχείο `Assets.car` χρησιμοποιεί συμπίεση για την αποδοτική διαχείριση των γραφικών πόρων, κρίσιμη για τη βελτιστοποίηση της απόδοσης της εφαρμογής και τη μείωση του συνολικού μεγέθους της.
- **Frameworks και PlugIns**: Αυτοί οι φάκελοι υπογραμμίζουν τη modularity των iOS εφαρμογών, επιτρέποντας στους προγραμματιστές να συμπεριλάβουν επαναχρησιμοποιήσιμες βιβλιοθήκες κώδικα (`Frameworks/`) και να επεκτείνουν τη λειτουργικότητα της εφαρμογής (`PlugIns/`).
- **Τοπικοποίηση**: Η δομή υποστηρίζει πολλές γλώσσες, διευκολύνοντας την παγκόσμια διάδοση της εφαρμογής μέσω της συμπερίληψης πόρων για συγκεκριμένα πακέτα γλώσσας.

**Info.plist**

Το **Info.plist** λειτουργεί ως θεμέλιο για τις iOS εφαρμογές, περιλαμβάνοντας βασικά δεδομένα ρύθμισης σε μορφή **key-value** ζευγών. Αυτό το αρχείο είναι υποχρεωτικό όχι μόνο για τις εφαρμογές αλλά και για τις app extensions και τα frameworks που περιλαμβάνονται στο bundle. Είναι δομημένο είτε σε XML είτε σε δυαδική μορφή και περιέχει κρίσιμες πληροφορίες που κυμαίνονται από δικαιώματα εφαρμογής έως ρυθμίσεις ασφάλειας. Για λεπτομερή εξερεύνηση των διαθέσιμων κλειδιών, μπορείτε να ανατρέξετε στην [**Apple Developer Documentation**](https://developer.apple.com/documentation/bundleresources/information_property_list?language=objc).

Για όσους θέλουν να εργαστούν με αυτό το αρχείο σε πιο προσβάσιμη μορφή, η μετατροπή σε XML μπορεί να επιτευχθεί εύκολα μέσω της χρήσης του `plutil` σε macOS (διαθέσιμο εγγενώς σε εκδόσεις 10.2 και νεότερες) ή του `plistutil` σε Linux. Οι εντολές για τη μετατροπή είναι οι εξής:

- **For macOS**:
```bash
$ plutil -convert xml1 Info.plist
```
- **Για Linux**:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
Μεταξύ της πλήθους των πληροφοριών που μπορεί να αποκαλύψει το αρχείο **Info.plist**, εμφανή στοιχεία περιλαμβάνουν τις συμβολοσειρές αδειών εφαρμογής (`UsageDescription`), προσαρμοσμένα σχήματα URL (`CFBundleURLTypes`), και τις ρυθμίσεις για το App Transport Security (`NSAppTransportSecurity`). Αυτά τα στοιχεία, μαζί με άλλα όπως εξαγόμενοι/εισαγόμενοι προσαρμοσμένοι τύποι εγγράφων (`UTExportedTypeDeclarations` / `UTImportedTypeDeclarations`), μπορούν να εντοπιστούν εύκολα επιθεωρώντας το αρχείο ή χρησιμοποιώντας μια απλή εντολή `grep`:
```bash
$ grep -i <keyword> Info.plist
```
**Διαδρομές Δεδομένων**

Στο περιβάλλον iOS, οι κατάλογοι ορίζονται ειδικά για **συστημικές εφαρμογές** και **εφαρμογές εγκατεστημένες από τον χρήστη**. Οι συστημικές εφαρμογές βρίσκονται στον κατάλογο `/Applications`, ενώ οι εφαρμογές εγκατεστημένες από τον χρήστη τοποθετούνται κάτω από `/var/mobile/containers/Data/Application/`. Σε αυτές τις εφαρμογές ανατίθεται ένας μοναδικός αναγνωριστικός γνωστός ως **128-bit UUID**, γεγονός που καθιστά την χειροκίνητη εύρεση του φακέλου μιας εφαρμογής δύσκολη λόγω της τυχαιότητας των ονομάτων των καταλόγων.

> [!WARNING]
> Επειδή οι εφαρμογές στο iOS πρέπει να είναι sandboxed, κάθε εφαρμογή θα έχει επίσης έναν φάκελο μέσα στο **`$HOME/Library/Containers`** με το **`CFBundleIdentifier`** της εφαρμογής ως όνομα φακέλου.
>
> Ωστόσο, και οι δύο φάκελοι (data & container folders) έχουν το αρχείο **`.com.apple.mobile_container_manager.metadata.plist`** που συνδέει και τα δύο αρχεία στο κλειδί `MCMetadataIdentifier`).

Για να διευκολυνθεί η ανεύρεση του καταλόγου εγκατάστασης μιας εφαρμογής που εγκαταστάθηκε από χρήστη, το εργαλείο **objection** παρέχει μια χρήσιμη εντολή, `env`. Αυτή η εντολή αποκαλύπτει λεπτομερείς πληροφορίες καταλόγου για την αντίστοιχη εφαρμογή. Παρακάτω υπάρχει ένα παράδειγμα του πώς να χρησιμοποιήσετε αυτήν την εντολή:
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # env

Name               Path
-----------------  -------------------------------------------------------------------------------------------
BundlePath         /var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app
CachesDirectory    /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library/Caches
DocumentDirectory  /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Documents
LibraryDirectory   /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library
```
Εναλλακτικά, το όνομα της εφαρμογής μπορεί να αναζητηθεί μέσα στο `/private/var/containers` χρησιμοποιώντας την εντολή `find`:
```bash
find /private/var/containers -name "Progname*"
```
Εντολές όπως `ps` και `lsof` μπορούν επίσης να χρησιμοποιηθούν για να εντοπίσουν τη διεργασία της app και να απαριθμήσουν τα ανοιχτά αρχεία, αντίστοιχα, παρέχοντας πληροφορίες για τα ενεργά μονοπάτια καταλόγων της εφαρμογής:
```bash
ps -ef | grep -i <app-name>
lsof -p <pid> | grep -i "/containers" | head -n 1
```
**Κατάλογος Bundle:**

- **AppName.app**
- Αυτό είναι το Application Bundle όπως φαίνεται προηγουμένως στο IPA, περιέχει απαραίτητα δεδομένα εφαρμογής, στατικό περιεχόμενο καθώς και το compiled binary της εφαρμογής.
- Αυτός ο κατάλογος είναι ορατός στους χρήστες, αλλά **οι χρήστες δεν μπορούν να γράψουν σε αυτόν**.
- Το περιεχόμενο σε αυτόν τον κατάλογο **δεν συμπεριλαμβάνεται σε backup**.
- Το περιεχόμενο αυτού του φακέλου χρησιμοποιείται για να **επικυρώσει την υπογραφή κώδικα (code signature)**.

**Κατάλογος δεδομένων:**

- **Documents/**
- Περιέχει όλα τα δεδομένα που δημιουργούνται από τον χρήστη. Ο τελικός χρήστης της εφαρμογής ξεκινά τη δημιουργία αυτών των δεδομένων.
- Ορατό στους χρήστες και **οι χρήστες μπορούν να γράψουν σε αυτό**.
- Το περιεχόμενο σε αυτόν τον κατάλογο **συμπεριλαμβάνεται σε backup**.
- Η εφαρμογή μπορεί να αποκλείσει διαδρομές ορίζοντας το `NSURLIsExcludedFromBackupKey`.
- **Library/**
- Περιέχει όλα τα **αρχεία που δεν είναι συγκεκριμένα για τον χρήστη**, όπως **caches**, **preferences**, **cookies**, και αρχεία διαμόρφωσης property list (plist).
- Οι εφαρμογές iOS συνήθως χρησιμοποιούν τους υποκαταλόγους `Application Support` και `Caches`, αλλά η εφαρμογή μπορεί να δημιουργήσει προσαρμοσμένους υποκαταλόγους.
- **Library/Caches/**
- Περιέχει **ημι-μόνιμα αρχεία cache.**
- Αόρατο στους χρήστες και **οι χρήστες δεν μπορούν να γράψουν σε αυτό**.
- Το περιεχόμενο σε αυτόν τον κατάλογο **δεν συμπεριλαμβάνεται σε backup**.
- Το OS μπορεί να διαγράψει αυτόματα τα αρχεία αυτού του καταλόγου όταν η εφαρμογή δεν τρέχει και ο διαθέσιμος χώρος αποθήκευσης είναι χαμηλός.
- **Library/Application Support/**
- Περιέχει **επίμονα** **αρχεία** απαραίτητα για την εκτέλεση της εφαρμογής.
- Αόρατο στους χρήστες και οι χρήστες δεν μπορούν να γράψουν σε αυτό.
- Το περιεχόμενο σε αυτόν τον κατάλογο **συμπεριλαμβάνεται σε backup**.
- Η εφαρμογή μπορεί να αποκλείσει διαδρομές ορίζοντας το `NSURLIsExcludedFromBackupKey`.
- **Library/Preferences/**
- Χρησιμοποιείται για την αποθήκευση ιδιοτήτων που μπορούν να **παραμείνουν ακόμα και μετά την επανεκκίνηση της εφαρμογής**.
- Οι πληροφορίες αποθηκεύονται, χωρίς κρυπτογράφηση, μέσα στο sandbox της εφαρμογής σε ένα αρχείο plist ονόματι \[BUNDLE_ID].plist.
- Όλα τα ζεύγη κλειδί/τιμή που αποθηκεύονται χρησιμοποιώντας `NSUserDefaults` μπορούν να βρεθούν σε αυτό το αρχείο.
- **tmp/**
- Χρησιμοποιήστε αυτόν τον κατάλογο για να γράψετε **προσωρινά αρχεία** που δεν χρειάζεται να παραμείνουν μεταξύ των εκκινήσεων της εφαρμογής.
- Περιέχει μη-επίμονα αρχεία cache.
- Αόρατο στους χρήστες.
- Το περιεχόμενο σε αυτόν τον κατάλογο δεν συμπεριλαμβάνεται σε backup.
- Το OS μπορεί να διαγράψει αυτόματα τα αρχεία αυτού του καταλόγου όταν η εφαρμογή δεν τρέχει και ο διαθέσιμος χώρος αποθήκευσης είναι χαμηλός.

Ας ρίξουμε μια πιο προσεκτική ματιά στον Application Bundle (.app) του iGoat-Swift μέσα στον Bundle κατάλογο (`/var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app`):
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # ls
NSFileType      Perms  NSFileProtection    ...  Name
------------  -------  ------------------  ...  --------------------------------------
Regular           420  None                ...  rutger.html
Regular           420  None                ...  mansi.html
Regular           420  None                ...  splash.html
Regular           420  None                ...  about.html

Regular           420  None                ...  LICENSE.txt
Regular           420  None                ...  Sentinel.txt
Regular           420  None                ...  README.txt
```
### Binary Reversing

Μέσα στο φάκελο `<application-name>.app` θα βρείτε ένα αρχείο binary που ονομάζεται `<application-name>`. Αυτό είναι το αρχείο που θα **εκτελεστεί**. Μπορείτε να πραγματοποιήσετε μια βασική επιθεώρηση του binary με το εργαλείο **`otool`**:
```bash
otool -Vh DVIA-v2 #Check some compilation attributes
magic  cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64    ARM64        ALL  0x00     EXECUTE    65       7112   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE

otool -L DVIA-v2 #Get third party libraries
DVIA-v2:
/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.1)
/usr/lib/libsqlite3.dylib (compatibility version 9.0.0, current version 274.6.0)
/usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11)
@rpath/Bolts.framework/Bolts (compatibility version 1.0.0, current version 1.0.0)
[...]
```
**Ελέγξτε αν το app είναι κρυπτογραφημένο**

Δείτε αν υπάρχει οποιαδήποτε έξοδος για:
```bash
otool -l <app-binary> | grep -A 4 LC_ENCRYPTION_INFO
```
**Αποσυναρμολόγηση του binary**

Αποσυναρμολόγησε το text section:
```bash
otool -tV DVIA-v2
DVIA-v2:
(__TEXT,__text) section
+[DDLog initialize]:
0000000100004ab8    sub    sp, sp, #0x60
0000000100004abc    stp    x29, x30, [sp, #0x50]   ; Latency: 6
0000000100004ac0    add    x29, sp, #0x50
0000000100004ac4    sub    x8, x29, #0x10
0000000100004ac8    mov    x9, #0x0
0000000100004acc    adrp    x10, 1098 ; 0x10044e000
0000000100004ad0    add    x10, x10, #0x268
```
Για να εκτυπώσετε το **Objective-C segment** της δειγματικής εφαρμογής μπορείτε να χρησιμοποιήσετε:
```bash
otool -oV DVIA-v2
DVIA-v2:
Contents of (__DATA,__objc_classlist) section
00000001003dd5b8 0x1004423d0 _OBJC_CLASS_$_DDLog
isa        0x1004423a8 _OBJC_METACLASS_$_DDLog
superclass 0x0 _OBJC_CLASS_$_NSObject
cache      0x0 __objc_empty_cache
vtable     0x0
data       0x1003de748
flags          0x80
instanceStart  8
```
Για να αποκτήσετε πιο συμπαγή κώδικα Objective-C μπορείτε να χρησιμοποιήσετε [**class-dump**](http://stevenygard.com/projects/class-dump/):
```bash
class-dump some-app
//
//     Generated by class-dump 3.5 (64 bit).
//
//     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2013 by Steve Nygard.
//

#pragma mark Named Structures

struct CGPoint {
double _field1;
double _field2;
};

struct CGRect {
struct CGPoint _field1;
struct CGSize _field2;
};

struct CGSize {
double _field1;
double _field2;
};
```
Ωστόσο, οι καλύτερες επιλογές για disassemble the binary είναι: [**Hopper**](https://www.hopperapp.com/download.html?) και [**IDA**](https://www.hex-rays.com/products/ida/support/download_freeware/).

## Αποθήκευση Δεδομένων

Για να μάθετε πώς το iOS αποθηκεύει δεδομένα στη συσκευή διαβάστε αυτή τη σελίδα:


{{#ref}}
ios-basics.md
{{#endref}}

> [!WARNING]
> Τα παρακάτω μέρη για αποθήκευση πληροφοριών πρέπει να ελεγχθούν **right after installing the application**, **after checking all the functionalities** της εφαρμογής και ακόμη και μετά **login out from one user and login into a different one**.\
> Ο στόχος είναι να βρεθούν **unprotected sensitive information** της εφαρμογής (passwords, tokens), του τρέχοντος χρήστη και προηγούμενων χρηστών.

### Plist

**plist** files are structured XML files that **contains key-value pairs**. Είναι ένας τρόπος να αποθηκεύονται επίμονα δεδομένα, οπότε μερικές φορές μπορεί να βρείτε **sensitive information in these files**. Συνιστάται να ελέγχετε αυτά τα αρχεία μετά την εγκατάσταση της εφαρμογής και μετά από εντατική χρήση για να δείτε αν γράφονται νέα δεδομένα.

Ο πιο κοινός τρόπος για να επιμείνουν δεδομένα σε plist αρχεία είναι μέσω της χρήσης του **NSUserDefaults**. Αυτό το plist αρχείο αποθηκεύεται μέσα στο sandbox της εφαρμογής στο **`Library/Preferences/<appBundleID>.plist`**

Η κλάση [`NSUserDefaults`](https://developer.apple.com/documentation/foundation/nsuserdefaults) παρέχει ένα προγραμματιστικό interface για αλληλεπίδραση με το default system. Το default system επιτρέπει σε μια εφαρμογή να προσαρμόζει τη συμπεριφορά της σύμφωνα με τις **user preferences**. Δεδομένα που αποθηκεύονται από `NSUserDefaults` μπορούν να προβληθούν στο application bundle. Αυτή η κλάση αποθηκεύει **data** σε ένα **plist** **file**, αλλά προορίζεται για χρήση με μικρές ποσότητες δεδομένων.

Αυτά τα δεδομένα δεν μπορούν πλέον να προσπελαστούν απευθείας μέσω ενός trusted computer, αλλά μπορούν να προσπελαστούν εκτελώντας ένα **backup**.

Μπορείτε να **dump** τις πληροφορίες που έχουν αποθηκευτεί μέσω **`NSUserDefaults`** χρησιμοποιώντας την εντολή του objection `ios nsuserdefaults get`

Για να βρείτε όλα τα plist που χρησιμοποιούνται από την εφαρμογή μπορείτε να αποκτήσετε πρόσβαση στο `/private/var/mobile/Containers/Data/Application/{APPID}` και να εκτελέσετε:
```bash
find ./ -name "*.plist"
```
Για να μετατρέψετε αρχεία από **XML or binary (bplist)** μορφή σε XML, υπάρχουν διάφοροι τρόποι ανάλογα με το λειτουργικό σας σύστημα:

**Για χρήστες macOS:** Χρησιμοποιήστε την εντολή `plutil`. Είναι ένα ενσωματωμένο εργαλείο στο macOS (10.2+), σχεδιασμένο για αυτόν τον σκοπό:
```bash
$ plutil -convert xml1 Info.plist
```
**Για χρήστες Linux:** Εγκαταστήστε πρώτα `libplist-utils`, στη συνέχεια χρησιμοποιήστε `plistutil` για να μετατρέψετε το αρχείο σας:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
**Within an Objection Session:** Για την ανάλυση εφαρμογών για κινητά, μια συγκεκριμένη εντολή σας επιτρέπει να μετατρέψετε αρχεία plist απευθείας:
```bash
ios plist cat /private/var/mobile/Containers/Data/Application/<Application-UUID>/Library/Preferences/com.some.package.app.plist
```
### Core Data

[`Core Data`](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/nsfetchedresultscontroller.html#//apple_ref/doc/uid/TP40001075-CH8-SW1) είναι ένα πλαίσιο για τη διαχείριση του επιπέδου μοντέλου των αντικειμένων στην εφαρμογή σας. [Core Data can use SQLite as its persistent store](https://cocoacasts.com/what-is-the-difference-between-core-data-and-sqlite/), αλλά το ίδιο το πλαίσιο δεν είναι βάση δεδομένων.\
CoreData δεν κρυπτογραφεί τα δεδομένα του από προεπιλογή. Ωστόσο, μπορεί να προστεθεί ένα επιπλέον επίπεδο κρυπτογράφησης στο CoreData. Δείτε το [GitHub Repo](https://github.com/project-imas/encrypted-core-data) για περισσότερες λεπτομέρειες.

Μπορείτε να βρείτε τις πληροφορίες SQLite Core Data μιας εφαρμογής στη διαδρομή `/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support`

**Εάν μπορείτε να ανοίξετε το SQLite και να αποκτήσετε πρόσβαση σε ευαίσθητες πληροφορίες, τότε βρήκατε μια λανθασμένη διαμόρφωση.**
```objectivec:Code from iGoat
-(void)storeDetails {
AppDelegate * appDelegate = (AppDelegate *)(UIApplication.sharedApplication.delegate);

NSManagedObjectContext *context =[appDelegate managedObjectContext];

User *user = [self fetchUser];
if (user) {
return;
}
user = [NSEntityDescription insertNewObjectForEntityForName:@"User"
inManagedObjectContext:context];
user.email = CoreDataEmail;
user.password = CoreDataPassword;
NSError *error;
if (![context save:&error]) {
NSLog(@"Error in saving data: %@", [error localizedDescription]);

}else{
NSLog(@"data stored in core data");
}
}
```
### YapDatabase

[YapDatabase](https://github.com/yapstudios/YapDatabase) είναι ένα key/value store που βασίζεται σε SQLite.\  
Καθώς οι Yap βάσεις δεδομένων είναι sqlite βάσεις δεδομένων, μπορείτε να τις βρείτε χρησιμοποιώντας την εντολή που προτάθηκε στην προηγούμενη ενότητα.

### Άλλες βάσεις δεδομένων SQLite

Είναι σύνηθες οι εφαρμογές να δημιουργούν δικές τους sqlite βάσεις δεδομένων. Μπορεί να **αποθηκεύουν** **ευαίσθητα** **δεδομένα** σε αυτές και να τα αφήνουν χωρίς κρυπτογράφηση. Γι' αυτό, είναι πάντα ενδιαφέρον να ελέγχετε κάθε βάση δεδομένων μέσα στον κατάλογο της εφαρμογής. Πηγαίνετε στον κατάλογο της εφαρμογής όπου αποθηκεύονται τα δεδομένα (`/private/var/mobile/Containers/Data/Application/{APPID}`)
```bash
find ./ -name "*.sqlite" -or -name "*.db"
```
### Firebase Real-Time Databases

Οι προγραμματιστές μπορούν να **αποθηκεύουν και να συγχρονίζουν δεδομένα** μέσα σε μια **NoSQL cloud-hosted database** μέσω των Firebase Real-Time Databases. Αποθηκευμένα σε μορφή JSON, τα δεδομένα συγχρονίζονται με όλους τους συνδεδεμένους πελάτες σε πραγματικό χρόνο.

Μπορείτε να βρείτε πώς να ελέγξετε για κακώς διαμορφωμένες Firebase βάσεις δεδομένων εδώ:


{{#ref}}
../../network-services-pentesting/pentesting-web/buckets/firebase-database.md
{{#endref}}

### Realm databases

[Realm Objective-C](https://realm.io/docs/objc/latest/) και [Realm Swift](https://realm.io/docs/swift/latest/) προσφέρουν μια ισχυρή εναλλακτική για την αποθήκευση δεδομένων, που δεν παρέχεται από Apple. Από προεπιλογή, **αποθηκεύουν τα δεδομένα μη κρυπτογραφημένα**, ενώ η κρυπτογράφηση είναι διαθέσιμη μέσω συγκεκριμένης διαμόρφωσης.

Οι βάσεις δεδομένων βρίσκονται στο: `/private/var/mobile/Containers/Data/Application/{APPID}`. Για να εξερευνήσει κανείς αυτά τα αρχεία, μπορεί να χρησιμοποιήσει εντολές όπως:
```bash
iPhone:/private/var/mobile/Containers/Data/Application/A079DF84-726C-4AEA-A194-805B97B3684A/Documents root# ls
default.realm  default.realm.lock  default.realm.management/  default.realm.note|

$ find ./ -name "*.realm*"
```
Για την προβολή αυτών των αρχείων βάσης δεδομένων, συνιστάται το εργαλείο [**Realm Studio**](https://github.com/realm/realm-studio).

Για να υλοποιήσετε την κρυπτογράφηση σε μια βάση δεδομένων Realm, μπορείτε να χρησιμοποιήσετε το ακόλουθο απόσπασμα κώδικα:
```swift
// Open the encrypted Realm file where getKey() is a method to obtain a key from the Keychain or a server
let config = Realm.Configuration(encryptionKey: getKey())
do {
let realm = try Realm(configuration: config)
// Use the Realm as normal
} catch let error as NSError {
// If the encryption key is wrong, `error` will say that it's an invalid database
fatalError("Error opening realm: \(error)")
}
```
### Couchbase Lite Βάσεις Δεδομένων

[Couchbase Lite](https://github.com/couchbase/couchbase-lite-ios) περιγράφεται ως μια **ελαφριά** και **ενσωματωμένη** μηχανή βάσης δεδομένων που ακολουθεί την προσέγγιση document-oriented (NoSQL). Σχεδιασμένο να λειτουργεί εγγενώς σε **iOS** και **macOS**, προσφέρει δυνατότητα απρόσκοπτου συγχρονισμού δεδομένων.

Για να εντοπίσετε πιθανές βάσεις δεδομένων Couchbase σε μια συσκευή, πρέπει να ελεγχθεί ο παρακάτω κατάλογος:
```bash
ls /private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support/
```
### Cookies

iOS αποθηκεύει τα cookies των εφαρμογών στο **`Library/Cookies/cookies.binarycookies`** μέσα στον φάκελο κάθε εφαρμογής. Ωστόσο, οι προγραμματιστές μερικές φορές αποφασίζουν να τα αποθηκεύσουν στο **keychain**, καθώς το προαναφερθέν **cookie file μπορεί να ανακτηθεί από backups**.

Για να εξετάσετε το αρχείο cookies μπορείτε να χρησιμοποιήσετε [**this python script**](https://github.com/mdegrazia/Safari-Binary-Cookie-Parser) ή να χρησιμοποιήσετε το objection's **`ios cookies get`.**\
**Μπορείτε επίσης να χρησιμοποιήσετε το objection για να** μετατρέψετε αυτά τα αρχεία σε μορφή JSON και να εξετάσετε τα δεδομένα.
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios cookies get --json
[
{
"domain": "highaltitudehacks.com",
"expiresDate": "2051-09-15 07:46:43 +0000",
"isHTTPOnly": "false",
"isSecure": "false",
"name": "username",
"path": "/",
"value": "admin123",
"version": "0"
}
]
```
### Cache

Εξ ορισμού το NSURLSession αποθηκεύει δεδομένα, όπως **HTTP requests and responses in the Cache.db** database. Αυτή η βάση δεδομένων μπορεί να περιέχει **ευαίσθητα δεδομένα**, εάν tokens, usernames ή οποιαδήποτε άλλη ευαίσθητη πληροφορία έχει cacheαριστεί. Για να βρείτε τις αποθηκευμένες πληροφορίες ανοίξτε τον κατάλογο δεδομένων της εφαρμογής (`/var/mobile/Containers/Data/Application/<UUID>`) και πηγαίνετε στο `/Library/Caches/<Bundle Identifier>`. Ο **WebKit cache** αποθηκεύεται επίσης στο αρχείο Cache.db. Το **Objection** μπορεί να ανοίξει και να αλληλεπιδράσει με τη βάση δεδομένων με την εντολή `sqlite connect Cache.db`, καθώς είναι μια n**ormal SQLite database**.

Συνιστάται να απενεργοποιηθεί η αποθήκευση αυτών των δεδομένων, καθώς μπορεί να περιέχει ευαίσθητες πληροφορίες στο request ή στο response. Η παρακάτω λίστα δείχνει διάφορους τρόπους για να το πετύχετε:

1.  Συνιστάται να αφαιρείτε τις Cached responses μετά το logout. Αυτό μπορεί να γίνει με τη μέθοδο που παρέχει η Apple και ονομάζεται [`removeAllCachedResponses`](https://developer.apple.com/documentation/foundation/urlcache/1417802-removeallcachedresponses). Μπορείτε να καλέσετε αυτή τη μέθοδο ως εξής:

`URLCache.shared.removeAllCachedResponses()`

Αυτή η μέθοδος θα αφαιρέσει όλα τα cached requests και responses από το αρχείο Cache.db.

2.  Αν δεν χρειάζεστε το πλεονέκτημα των cookies, συνιστάται να χρησιμοποιήσετε την ιδιότητα διαμόρφωσης [.ephemeral](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral) του URLSession, η οποία θα απενεργοποιήσει την αποθήκευση cookies και Caches.

[Apple documentation](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral):

`An ephemeral session configuration object is similar to a default session configuration (see default), except that the corresponding session object doesn’t store caches, credential stores, or any session-related data to disk. Instead, session-related data is stored in RAM. The only time an ephemeral session writes data to disk is when you tell it to write the contents of a URL to a file.`

3.  Το Cache μπορεί επίσης να απενεργοποιηθεί ορίζοντας την Cache Policy σε [.notAllowed](https://developer.apple.com/documentation/foundation/urlcache/storagepolicy/notallowed). Αυτό θα απενεργοποιήσει την αποθήκευση Cache με οποιονδήποτε τρόπο, είτε στη μνήμη είτε στο δίσκο.

### Snapshots

Όποτε πατάτε το home button, το iOS **λαμβάνει ένα snapshot της τρέχουσας οθόνης** για να επιτρέψει μια πιο ομαλή μετάβαση στην εφαρμογή. Ωστόσο, αν υπάρχουν **ευαίσθητα δεδομένα** στην τρέχουσα οθόνη, αυτά θα **αποθηκευτούν** στην **εικόνα** (η οποία **διατηρείται** **μετά** από **reboots**). Πρόκειται για τα snapshots στα οποία έχετε επίσης πρόσβαση όταν πατάτε διπλά το home button για να αλλάξετε εφαρμογές.

Εφόσον το iPhone δεν είναι jailbroken, ο **επιτιθέμενος** πρέπει να έχει **πρόσβαση** στη **συσκευή** **ξεκλείδωτη** για να δει αυτά τα screenshots. Από προεπιλογή, το τελευταίο snapshot αποθηκεύεται στο sandbox της εφαρμογής στον φάκελο `Library/Caches/Snapshots/` ή `Library/SplashBoard/Snapshots` (the trusted computers can' t access the filesystem from iOX 7.0).

Ένας τρόπος να αποτρέψετε αυτή την ανεπιθύμητη συμπεριφορά είναι να εμφανίσετε μια κενή οθόνη ή να αφαιρέσετε τα ευαίσθητα δεδομένα πριν ληφθεί το snapshot χρησιμοποιώντας τη συνάρτηση `ApplicationDidEnterBackground()`.

Το ακόλουθο είναι ένα δείγμα μεθόδου αποκατάστασης που θα ορίσει μια προεπιλεγμένη εικόνα οθόνης.

Swift:
```swift
private var backgroundImage: UIImageView?

func applicationDidEnterBackground(_ application: UIApplication) {
let myBanner = UIImageView(image: #imageLiteral(resourceName: "overlayImage"))
myBanner.frame = UIScreen.main.bounds
backgroundImage = myBanner
window?.addSubview(myBanner)
}

func applicationWillEnterForeground(_ application: UIApplication) {
backgroundImage?.removeFromSuperview()
}
```
Objective-C:
```
@property (UIImageView *)backgroundImage;

- (void)applicationDidEnterBackground:(UIApplication *)application {
UIImageView *myBanner = [[UIImageView alloc] initWithImage:@"overlayImage.png"];
self.backgroundImage = myBanner;
self.backgroundImage.bounds = UIScreen.mainScreen.bounds;
[self.window addSubview:myBanner];
}

- (void)applicationWillEnterForeground:(UIApplication *)application {
[self.backgroundImage removeFromSuperview];
}
```
Αυτό ορίζει την εικόνα φόντου σε `overlayImage.png` κάθε φορά που η εφαρμογή πηγαίνει στο παρασκήνιο. Εμποδίζει leaks ευαίσθητων δεδομένων, επειδή η `overlayImage.png` θα καλύπτει πάντα την τρέχουσα προβολή.

### Keychain

Για πρόσβαση και διαχείριση του iOS keychain, υπάρχουν εργαλεία όπως το [**Keychain-Dumper**](https://github.com/ptoomey3/Keychain-Dumper), κατάλληλα για jailbroken συσκευές. Επιπλέον, το [**Objection**](https://github.com/sensepost/objection) παρέχει την εντολή `ios keychain dump` για παρόμοιους σκοπούς.

#### **Αποθήκευση Διαπιστευτηρίων**

Η κλάση **NSURLCredential** είναι ιδανική για την αποθήκευση ευαίσθητων πληροφοριών απευθείας στο keychain, παρακάμπτοντας την ανάγκη για NSUserDefaults ή άλλα wrappers. Για να αποθηκεύσετε διαπιστευτήρια μετά τη σύνδεση, χρησιμοποιείται ο παρακάτω Swift κώδικας:
```swift
NSURLCredential *credential;
credential = [NSURLCredential credentialWithUser:username password:password persistence:NSURLCredentialPersistencePermanent];
[[NSURLCredentialStorage sharedCredentialStorage] setCredential:credential forProtectionSpace:self.loginProtectionSpace];
```
Για την εξαγωγή αυτών των αποθηκευμένων διαπιστευτηρίων χρησιμοποιείται η εντολή της Objection `ios nsurlcredentialstorage dump`.

## **Custom Keyboards and Keyboard Cache**

Από το iOS 8.0 και μετά, οι χρήστες μπορούν να εγκαθιστούν προσαρμοσμένες επεκτάσεις πληκτρολογίου, οι οποίες διαχειρίζονται μέσω Settings > General > Keyboard > Keyboards. Ενώ αυτά τα πληκτρολόγια προσφέρουν επιπλέον λειτουργικότητα, εγκυμονούν τον κίνδυνο καταγραφής πλήκτρων (keystroke logging) και αποστολής δεδομένων σε εξωτερικούς servers, αν και οι χρήστες ειδοποιούνται για πληκτρολόγια που απαιτούν πρόσβαση στο δίκτυο. Οι εφαρμογές μπορούν, και θα πρέπει, να περιορίζουν τη χρήση προσαρμοσμένων πληκτρολογίων κατά την εισαγωγή ευαίσθητων πληροφοριών.

**Συστάσεις ασφαλείας:**

- Συνίσταται η απενεργοποίηση τρίτων πληκτρολογίων για αυξημένη ασφάλεια.
- Να λαμβάνεται υπόψη η αυτόματη διόρθωση και οι αυτόματες προτάσεις (autocorrect και auto-suggestions) του προεπιλεγμένου iOS πληκτρολογίου, οι οποίες θα μπορούσαν να αποθηκεύσουν ευαίσθητες πληροφορίες σε αρχεία cache που βρίσκονται στο `Library/Keyboard/{locale}-dynamic-text.dat` ή στο `/private/var/mobile/Library/Keyboard/dynamic-text.dat`. Αυτά τα αρχεία cache θα πρέπει να ελέγχονται τακτικά για ευαίσθητα δεδομένα. Η επαναφορά του λεξικού πληκτρολογίου μέσω Settings > General > Reset > Reset Keyboard Dictionary συνιστάται για την εκκαθάριση των cache.
- Η παγίδευση της κυκλοφορίας δικτύου μπορεί να αποκαλύψει εάν ένα προσαρμοσμένο πληκτρολόγιο αποστέλλει πλήκτρα απομακρυσμένα.

### **Preventing Text Field Caching**

Η [UITextInputTraits protocol](https://developer.apple.com/reference/uikit/uitextinputtraits) προσφέρει ιδιότητες για τη διαχείριση της αυτόματης διόρθωσης και της ασφαλούς εισαγωγής κειμένου, απαραίτητες για την αποτροπή της προσωρινής αποθήκευσης ευαίσθητων πληροφοριών. Για παράδειγμα, η απενεργοποίηση της αυτόματης διόρθωσης και η ενεργοποίηση της ασφαλούς εισαγωγής κειμένου μπορούν να επιτευχθούν με:
```objectivec
textObject.autocorrectionType = UITextAutocorrectionTypeNo;
textObject.secureTextEntry = YES;
```
Επιπλέον, οι προγραμματιστές πρέπει να διασφαλίζουν ότι τα πεδία κειμένου, ειδικά εκείνα για την εισαγωγή ευαίσθητων πληροφοριών όπως κωδικοί πρόσβασης και PINs, απενεργοποιούν την προσωρινή αποθήκευση ορίζοντας το `autocorrectionType` σε `UITextAutocorrectionTypeNo` και το `secureTextEntry` σε `YES`.
```objectivec
UITextField *textField = [[UITextField alloc] initWithFrame:frame];
textField.autocorrectionType = UITextAutocorrectionTypeNo;
```
## **Καταγραφές**

Ο εντοπισμός σφαλμάτων συχνά περιλαμβάνει τη χρήση **logging**. Υπάρχει ένας κίνδυνος καθώς **τα logs μπορεί να περιέχουν ευαίσθητες πληροφορίες**. Προηγουμένως, στο iOS 6 και παλαιότερες εκδόσεις, τα logs ήταν προσβάσιμα από όλες τις εφαρμογές, δημιουργώντας κίνδυνο για leak ευαίσθητων δεδομένων. **Τώρα, οι εφαρμογές περιορίζονται να έχουν πρόσβαση μόνο στα δικά τους logs**.

Παρά αυτούς τους περιορισμούς, ένας **attacker με φυσική πρόσβαση** σε ξεκλείδωτη συσκευή μπορεί να το εκμεταλλευτεί συνδέοντας τη συσκευή σε υπολογιστή και **διαβάζοντας τα logs**. Είναι σημαντικό να σημειωθεί ότι τα logs παραμένουν στο δίσκο ακόμα και μετά την απεγκατάσταση της εφαρμογής.

Για την ελαχιστοποίηση των κινδύνων, συνιστάται να **αλληλεπιδράσετε διεξοδικά με την εφαρμογή**, εξερευνώντας όλες τις λειτουργίες και τις εισόδους της για να διασφαλίσετε ότι δεν καταγράφονται άθελα ευαίσθητες πληροφορίες.

Κατά την ανασκόπηση του source code της εφαρμογής για ενδεχόμενα leaks, ψάξτε τόσο για **προκαθορισμένες** όσο και για **προσαρμοσμένες δηλώσεις logging** χρησιμοποιώντας λέξεις-κλειδιά όπως `NSLog`, `NSAssert`, `NSCAssert`, `fprintf` για ενσωματωμένες συναρτήσεις, καθώς και οποιαδήποτε αναφορά σε `Logging` ή `Logfile` για προσαρμοσμένες υλοποιήσεις.

### **Παρακολούθηση System Logs**

Οι εφαρμογές καταγράφουν διάφορες πληροφορίες που μπορεί να είναι ευαίσθητες. Για την παρακολούθηση αυτών των logs, εργαλεία και εντολές όπως:
```bash
idevice_id --list   # To find the device ID
idevicesyslog -u <id> (| grep <app>)   # To capture the device logs
```
είναι χρήσιμα. Επιπλέον, **Xcode** παρέχει έναν τρόπο να συλλέξετε console logs:

1. Ανοίξτε το **Xcode**.
2. Συνδέστε τη συσκευή iOS.
3. Πλοηγηθείτε σε **Window** -> **Devices and Simulators**.
4. Επιλέξτε τη συσκευή σας.
5. Προκαλέστε το ζήτημα που διερευνάτε.
6. Χρησιμοποιήστε το κουμπί **Open Console** για να δείτε logs σε νέο παράθυρο.

Για πιο προηγμένη καταγραφή, η σύνδεση στο device shell και η χρήση του **socat** μπορούν να παρέχουν παρακολούθηση logs σε πραγματικό χρόνο:
```bash
iPhone:~ root# socat - UNIX-CONNECT:/var/run/lockdown/syslog.sock
```
Ακολουθούν εντολές για την παρακολούθηση δραστηριοτήτων καταγραφής, οι οποίες μπορούν να είναι ανεκτίμητες για τη διάγνωση προβλημάτων ή τον εντοπισμό πιθανής data leakage στα logs.

## Αντίγραφα ασφαλείας

**Χαρακτηριστικά αυτόματου backup** ενσωματώνονται στο iOS, διευκολύνοντας τη δημιουργία αντιγράφων δεδομένων της συσκευής μέσω iTunes (μέχρι macOS Catalina), Finder (από macOS Catalina και μετά), ή iCloud. Αυτά τα backups περιλαμβάνουν σχεδόν όλα τα δεδομένα της συσκευής, εξαιρουμένων πολύ ευαίσθητων στοιχείων όπως τα στοιχεία Apple Pay και οι ρυθμίσεις Touch ID.

### Κίνδυνοι Ασφαλείας

Η συμπερίληψη των **εγκατεστημένων apps και των δεδομένων τους** στα backups εγείρει το ζήτημα της πιθανής data leakage και τον κίνδυνο ότι **οι τροποποιήσεις στα backups μπορεί να αλλάξουν τη λειτουργικότητα της εφαρμογής**. Συνιστάται να **μην αποθηκεύετε ευαίσθητες πληροφορίες σε plaintext** μέσα σε οποιονδήποτε κατάλογο της εφαρμογής ή σε υποκαταλόγους του, για να μειώσετε αυτούς τους κινδύνους.

### Εξαίρεση αρχείων από τα backups

Τα αρχεία στο `Documents/` και στο `Library/Application Support/` συμπεριλαμβάνονται στα backups από προεπιλογή. Οι developers μπορούν να εξαιρέσουν συγκεκριμένα αρχεία ή καταλόγους από τα backups χρησιμοποιώντας `NSURL setResourceValue:forKey:error:` με το `NSURLIsExcludedFromBackupKey`. Αυτή η πρακτική είναι κρίσιμη για την προστασία ευαίσθητων δεδομένων από τη συμπερίληψή τους στα backups.

### Έλεγχος για ευπάθειες

Για να αξιολογήσετε την ασφάλεια των backups μιας εφαρμογής, ξεκινήστε με το **δημιουργία ενός backup** χρησιμοποιώντας Finder, και στη συνέχεια εντοπίστε το ακολουθώντας τις οδηγίες από [Apple's official documentation](https://support.apple.com/en-us/HT204215). Αναλύστε το backup για ευαίσθητα δεδομένα ή ρυθμίσεις που θα μπορούσαν να τροποποιηθούν και να επηρεάσουν τη συμπεριφορά της εφαρμογής.

Ευαίσθητες πληροφορίες μπορούν να αναζητηθούν χρησιμοποιώντας εργαλεία γραμμής εντολών ή εφαρμογές όπως [iMazing](https://imazing.com). Για κρυπτογραφημένα backups, η παρουσία κρυπτογράφησης μπορεί να επιβεβαιωθεί ελέγχοντας το κλειδί "IsEncrypted" στο αρχείο "Manifest.plist" στη ρίζα του backup.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
...
<key>Date</key>
<date>2021-03-12T17:43:33Z</date>
<key>IsEncrypted</key>
<true/>
...
</plist>
```
Για την αντιμετώπιση κρυπτογραφημένων αντιγράφων ασφαλείας, Python scripts διαθέσιμα στο [DinoSec's GitHub repo](https://github.com/dinosec/iphone-dataprotection/tree/master/python_scripts), όπως τα **backup_tool.py** και **backup_passwd.py**, μπορεί να είναι χρήσιμα, αν και πιθανόν να χρειαστούν προσαρμογές για συμβατότητα με τις τελευταίες εκδόσεις του iTunes/Finder. Το εργαλείο [**iOSbackup** tool](https://pypi.org/project/iOSbackup/) αποτελεί άλλη επιλογή για πρόσβαση σε αρχεία μέσα σε αντίγραφα ασφαλείας προστατευμένα με κωδικό.

### Τροποποίηση συμπεριφοράς εφαρμογής

Ένα παράδειγμα αλλαγής της συμπεριφοράς μίας εφαρμογής μέσω τροποποιήσεων σε backup δείχνεται στην [Bither bitcoin wallet app](https://github.com/bither/bither-ios), όπου το UI lock PIN αποθηκεύεται στο `net.bither.plist` κάτω από το κλειδί **pin_code**. Η αφαίρεση αυτού του κλειδιού από το plist και η επαναφορά του backup αφαιρεί την απαίτηση PIN, παρέχοντας απεριόριστη πρόσβαση.

## Σύνοψη για τη δοκιμή μνήμης σε ευαίσθητα δεδομένα

Όταν χειρίζεστε ευαίσθητες πληροφορίες που αποθηκεύονται στη μνήμη μιας εφαρμογής, είναι κρίσιμο να περιορίσετε τον χρόνο έκθεσης αυτών των δεδομένων. Υπάρχουν δύο κύριες προσεγγίσεις για την έρευνα του περιεχομένου της μνήμης: **creating a memory dump** και **analyzing the memory in real time**. Και οι δύο μέθοδοι έχουν τις προκλήσεις τους, συμπεριλαμβανομένης της πιθανότητας να χαθούν κρίσιμα δεδομένα κατά τη διαδικασία του dump ή την ανάλυση.

## **Ανάκτηση και ανάλυση ενός memory dump**

Για συσκευές τόσο jailbroken όσο και non-jailbroken, εργαλεία όπως [objection](https://github.com/sensepost/objection) και [Fridump](https://github.com/Nightbringer21/fridump) επιτρέπουν το dumping της μνήμης της διεργασίας μιας εφαρμογής. Αφού γίνει dump, η ανάλυση αυτών των δεδομένων απαιτεί διάφορα εργαλεία, ανάλογα με τη φύση των πληροφοριών που αναζητάτε.

Για εξαγωγή strings από ένα memory dump, μπορούν να χρησιμοποιηθούν εντολές όπως `strings` ή `rabin2 -zz`:
```bash
# Extracting strings using strings command
$ strings memory > strings.txt

# Extracting strings using rabin2
$ rabin2 -ZZ memory > strings.txt
```
Για πιο λεπτομερή ανάλυση, συμπεριλαμβανομένης της αναζήτησης συγκεκριμένων τύπων δεδομένων ή μοτίβων, **radare2** προσφέρει εκτεταμένες δυνατότητες αναζήτησης:
```bash
$ r2 <name_of_your_dump_file>
[0x00000000]> /?
...
```
## **Ανάλυση μνήμης κατά την εκτέλεση**

**r2frida** παρέχει μια ισχυρή εναλλακτική για την επιθεώρηση της μνήμης μιας εφαρμογής σε πραγματικό χρόνο, χωρίς να απαιτείται memory dump. Αυτό το εργαλείο επιτρέπει την εκτέλεση εντολών αναζήτησης απευθείας στη μνήμη της τρέχουσας εφαρμογής:
```bash
$ r2 frida://usb//<name_of_your_app>
[0x00000000]> /\ <search_command>
```
## Ελαττωματική Κρυπτογραφία

### Κακές Διαδικασίες Διαχείρισης Κλειδιών

Ορισμένοι προγραμματιστές αποθηκεύουν ευαίσθητα δεδομένα στο local storage και τα κρυπτογραφούν με ένα κλειδί hardcoded/predictable στον κώδικα. Αυτό δεν θα έπρεπε να γίνεται, καθώς κάποιο reversing μπορεί να επιτρέψει σε attackers να εξάγουν τις εμπιστευτικές πληροφορίες.

### Χρήση Μη Ασφαλών και/ή Παρωχημένων Αλγορίθμων

Οι προγραμματιστές δεν πρέπει να χρησιμοποιούν **παρωχημένους αλγορίθμους** για να πραγματοποιούν ελέγχους εξουσιοδότησης, **αποθηκεύσουν** ή **στείλουν** δεδομένα. Κάποιοι από αυτούς τους αλγορίθμους είναι: RC4, MD4, MD5, SHA1... Εάν χρησιμοποιούνται **hashes** για την αποθήκευση κωδικών, για παράδειγμα, θα πρέπει να χρησιμοποιούνται μηχανισμοί **ανθεκτικοί σε brute-force** με salt.

### Έλεγχος

Οι κύριοι έλεγχοι που πρέπει να πραγματοποιηθούν είναι να εντοπιστεί αν υπάρχουν **hardcoded** κωδικοί/μυστικά στον κώδικα, αν αυτά είναι **predictable**, και αν ο κώδικας χρησιμοποιεί κάποιο είδος **weak cryptography** αλγορίθμων.

Αξίζει να σημειωθεί ότι μπορείτε να **monitor** ορισμένες **crypto** **libraries** αυτόματα χρησιμοποιώντας **objection** με:
```swift
ios monitor crypt
```
For **περισσότερες πληροφορίες** σχετικά με τα iOS κρυπτογραφικά APIs και βιβλιοθήκες δείτε [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography)

## Τοπική αυθεντικοποίηση

**Τοπική αυθεντικοποίηση** παίζει κρίσιμο ρόλο, ειδικά όταν αφορά τη διασφάλιση πρόσβασης σε ένα απομακρυσμένο endpoint μέσω κρυπτογραφικών μεθόδων. Η ουσία είναι ότι χωρίς σωστή υλοποίηση, οι μηχανισμοί τοπικής αυθεντικοποίησης μπορούν να παρακαμφθούν.

Apple's [**Local Authentication framework**](https://developer.apple.com/documentation/localauthentication) και το [**keychain**](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html) παρέχουν ισχυρά APIs για τους προγραμματιστές, για να εμφανίζουν διαλόγους πιστοποίησης χρήστη και να χειρίζονται με ασφάλεια μυστικά δεδομένα αντίστοιχα. Το Secure Enclave προστατεύει το fingerprint ID για Touch ID, ενώ το Face ID βασίζεται στην αναγνώριση προσώπου χωρίς να εκθέτει βιομετρικά δεδομένα.

Για την ενσωμάτωση Touch ID/Face ID, οι προγραμματιστές έχουν δύο επιλογές API:

- **`LocalAuthentication.framework`** για υψηλού επιπέδου αυθεντικοποίηση χρήστη χωρίς πρόσβαση σε βιομετρικά δεδομένα.
- **`Security.framework`** για χαμηλότερου επιπέδου πρόσβαση σε υπηρεσίες keychain, προστατεύοντας μυστικά δεδομένα με βιομετρική πιστοποίηση. Διάφορα [open-source wrappers](https://www.raywenderlich.com/147308/secure-ios-user-data-keychain-touch-id) απλοποιούν την πρόσβαση στο keychain.

> [!CAUTION]
> Ωστόσο, τόσο το `LocalAuthentication.framework` όσο και το `Security.framework` εμφανίζουν ευπάθειες, καθώς κυρίως επιστρέφουν boolean τιμές χωρίς να μεταβιβάζουν δεδομένα για τις διαδικασίες αυθεντικοποίησης, κάνοντάς τα ευάλωτα σε παρακάμψεις (βλ. [Don't touch me that way, by David Lindner et al](https://www.youtube.com/watch?v=XhXIHVGCFFM)).

### Υλοποίηση τοπικής αυθεντικοποίησης

Για να ζητήσουν από τους χρήστες να πιστοποιηθούν, οι προγραμματιστές πρέπει να χρησιμοποιήσουν τη μέθοδο **`evaluatePolicy`** μέσα στην κλάση **`LAContext`**, επιλέγοντας ανάμεσα σε:

- **`deviceOwnerAuthentication`**: Εμφανίζει αίτημα για Touch ID ή τον κωδικό συσκευής, αποτυγχάνει αν κανένα από τα δύο δεν είναι ενεργοποιημένο.
- **`deviceOwnerAuthenticationWithBiometrics`**: Εμφανίζει αποκλειστικά αίτημα για Touch ID.

Μια επιτυχημένη αυθεντικοποίηση δηλώνεται με μια boolean επιστροφή τιμής από την **`evaluatePolicy`**, κάτι που επισημαίνει μια πιθανή αδυναμία ασφάλειας.

### Τοπική αυθεντικοποίηση χρησιμοποιώντας Keychain

Η υλοποίηση της **τοπικής αυθεντικοποίησης** σε iOS apps περιλαμβάνει τη χρήση των **keychain APIs** για την ασφαλή αποθήκευση μυστικών δεδομένων όπως authentication tokens. Αυτή η διαδικασία εξασφαλίζει ότι τα δεδομένα μπορούν να προσπελαστούν μόνο από τον χρήστη, χρησιμοποιώντας το passcode της συσκευής ή βιομετρική πιστοποίηση όπως Touch ID.

Το keychain παρέχει τη δυνατότητα να οριστούν στοιχεία με το χαρακτηριστικό `SecAccessControl`, το οποίο περιορίζει την πρόσβαση στο αντικείμενο μέχρι ο χρήστης να πιστοποιηθεί επιτυχώς μέσω Touch ID ή του passcode της συσκευής. Αυτή η λειτουργία είναι κρίσιμη για την ενίσχυση της ασφάλειας.

Παρακάτω υπάρχουν παραδείγματα κώδικα σε Swift και Objective-C που δείχνουν πώς να αποθηκεύσετε και να ανακτήσετε μια συμβολοσειρά από το keychain, αξιοποιώντας αυτές τις δυνατότητες ασφαλείας. Τα παραδείγματα δείχνουν συγκεκριμένα πώς να ρυθμίσετε τον έλεγχο πρόσβασης ώστε να απαιτείται πιστοποίηση Touch ID και να εξασφαλίζεται ότι τα δεδομένα είναι προσπελάσιμα μόνο στη συσκευή όπου δημιουργήθηκαν, υπό την προϋπόθεση ότι έχει ρυθμιστεί passcode στη συσκευή.

{{#tabs}}
{{#tab name="Swift"}}
```swift
// From https://github.com/mufambisi/owasp-mstg/blob/master/Document/0x06f-Testing-Local-Authentication.md

// 1. create AccessControl object that will represent authentication settings

var error: Unmanaged<CFError>?

guard let accessControl = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
SecAccessControlCreateFlags.biometryCurrentSet,
&error) else {
// failed to create AccessControl object

return
}

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute

var query: [String: Any] = [:]

query[kSecClass as String] = kSecClassGenericPassword
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecAttrAccount as String] = "OWASP Account" as CFString
query[kSecValueData as String] = "test_strong_password".data(using: .utf8)! as CFData
query[kSecAttrAccessControl as String] = accessControl

// 3. save item

let status = SecItemAdd(query as CFDictionary, nil)

if status == noErr {
// successfully saved
} else {
// error while saving
}
```
{{#endtab}}

{{#tab name="Objective-C"}}
```objectivec
// 1. create AccessControl object that will represent authentication settings
CFErrorRef *err = nil;

SecAccessControlRef sacRef = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
kSecAccessControlUserPresence,
err);

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute
NSDictionary* query = @{
(_ _bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecAttrAccount: @"OWASP Account",
(__bridge id)kSecValueData: [@"test_strong_password" dataUsingEncoding:NSUTF8StringEncoding],
(__bridge id)kSecAttrAccessControl: (__bridge_transfer id)sacRef
};

// 3. save item
OSStatus status = SecItemAdd((__bridge CFDictionaryRef)query, nil);

if (status == noErr) {
// successfully saved
} else {
// error while saving
}
```
{{#endtab}}
{{#endtabs}}

Τώρα μπορούμε να ζητήσουμε το αποθηκευμένο item από το keychain. Οι Keychain services θα εμφανίσουν τον διάλογο αυθεντικοποίησης στον χρήστη και θα επιστρέψουν data ή nil ανάλογα με το αν έχει παρασχεθεί κατάλληλο fingerprint ή όχι.

{{#tabs}}
{{#tab name="Swift"}}
```swift
// 1. define query
var query = [String: Any]()
query[kSecClass as String] = kSecClassGenericPassword
query[kSecReturnData as String] = kCFBooleanTrue
query[kSecAttrAccount as String] = "My Name" as CFString
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecUseOperationPrompt as String] = "Please, pass authorisation to enter this area" as CFString

// 2. get item
var queryResult: AnyObject?
let status = withUnsafeMutablePointer(to: &queryResult) {
SecItemCopyMatching(query as CFDictionary, UnsafeMutablePointer($0))
}

if status == noErr {
let password = String(data: queryResult as! Data, encoding: .utf8)!
// successfully received password
} else {
// authorization not passed
}
```
{{#endtab}}

{{#tab name="Objective-C"}}
```objectivec
// 1. define query
NSDictionary *query = @{(__bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecReturnData: @YES,
(__bridge id)kSecAttrAccount: @"My Name1",
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecUseOperationPrompt: @"Please, pass authorisation to enter this area" };

// 2. get item
CFTypeRef queryResult = NULL;
OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)query, &queryResult);

if (status == noErr){
NSData* resultData = ( __bridge_transfer NSData* )queryResult;
NSString* password = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding];
NSLog(@"%@", password);
} else {
NSLog(@"Something went wrong");
}
```
{{#endtab}}
{{#endtabs}}

### Ανίχνευση

Η χρήση frameworks σε μια εφαρμογή μπορεί επίσης να ανιχνευθεί αναλύοντας τη λίστα των shared dynamic libraries του app binary. Αυτό μπορεί να γίνει χρησιμοποιώντας `otool`:
```bash
$ otool -L <AppName>.app/<AppName>
```
Εάν το `LocalAuthentication.framework` χρησιμοποιείται σε μια εφαρμογή, η έξοδος θα περιέχει και τις δύο από τις παρακάτω γραμμές (να θυμάστε ότι το `LocalAuthentication.framework` χρησιμοποιεί το `Security.framework` στο παρασκήνιο):
```bash
/System/Library/Frameworks/LocalAuthentication.framework/LocalAuthentication
/System/Library/Frameworks/Security.framework/Security
```
Εάν χρησιμοποιηθεί το `Security.framework`, θα εμφανιστεί μόνο το δεύτερο.

### Παράκαμψη του LocalAuthentication Framework Bypass

#### **Objection**

Μέσω του **Objection Biometrics Bypass**, located at [this GitHub page](https://github.com/sensepost/objection/wiki/Understanding-the-iOS-Biometrics-Bypass), υπάρχει μια τεχνική που επιτρέπει την παράκαμψη του μηχανισμού **LocalAuthentication**. Ο πυρήνας αυτής της προσέγγισης περιλαμβάνει τη χρήση του **Frida** για να τροποποιήσει τη συνάρτηση `evaluatePolicy`, διασφαλίζοντας ότι πάντα επιστρέφει `True`, ανεξάρτητα από την πραγματική επιτυχία της πιστοποίησης. Αυτό είναι ιδιαίτερα χρήσιμο για την παράκαμψη ελαττωματικών βιομετρικών διαδικασιών πιστοποίησης.

Για να ενεργοποιηθεί αυτή η παράκαμψη, χρησιμοποιείται η ακόλουθη εντολή:
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios ui biometrics_bypass
(agent) Registering job 3mhtws9x47q. Type: ios-biometrics-disable
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # (agent) [3mhtws9x47q] Localized Reason for auth requirement: Please authenticate yourself
(agent) [3mhtws9x47q] OS authentication response: false
(agent) [3mhtws9x47q] Marking OS response as True instead
(agent) [3mhtws9x47q] Biometrics bypass hook complete
```
Αυτή η εντολή ξεκινά μια ακολουθία όπου το Objection καταχωρεί ένα task που στην ουσία αλλάζει το αποτέλεσμα του ελέγχου `evaluatePolicy` σε `True`.

#### Frida

Ένα παράδειγμα χρήσης του **`evaluatePolicy`** από [DVIA-v2 application](https://github.com/prateek147/DVIA-v2):
```swift
+(void)authenticateWithTouchID {
LAContext *myContext = [[LAContext alloc] init];
NSError *authError = nil;
NSString *myLocalizedReasonString = @"Please authenticate yourself";

if ([myContext canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&authError]) {
[myContext evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics
localizedReason:myLocalizedReasonString
reply:^(BOOL success, NSError *error) {
if (success) {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Successful" withTitle:@"Success"];
});
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Failed !" withTitle:@"Error"];
});
}
}];
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Your device doesn't support Touch ID or you haven't configured Touch ID authentication on your device" withTitle:@"Error"];
});
}
}
```
Για να επιτευχθεί το **bypass** του Local Authentication, γράφεται ένα Frida script. Το script αυτό στοχεύει τον έλεγχο **evaluatePolicy**, παρεμβαίνοντας στο callback του ώστε να επιστρέφει **success=1**. Με την αλλαγή της συμπεριφοράς του callback, ο έλεγχος αυθεντικοποίησης παρακάμπτεται ουσιαστικά.

Το παρακάτω script εισάγεται για να τροποποιήσει το αποτέλεσμα της μεθόδου **evaluatePolicy**. Αλλάζει το αποτέλεσμα του callback ώστε να δείχνει πάντα επιτυχία.
```swift
// from https://securitycafe.ro/2022/09/05/mobile-pentesting-101-bypassing-biometric-authentication/
if(ObjC.available) {
console.log("Injecting...");
var hook = ObjC.classes.LAContext["- evaluatePolicy:localizedReason:reply:"];
Interceptor.attach(hook.implementation, {
onEnter: function(args) {
var block = new ObjC.Block(args[4]);
const callback = block.implementation;
block.implementation = function (error, value)  {

console.log("Changing the result value to true")
const result = callback(1, null);
return result;
};
},
});
} else {
console.log("Objective-C Runtime is not available!");
}
```
Για να inject το Frida script και να bypass την βιομετρική αυθεντικοποίηση, χρησιμοποιείται η παρακάτω εντολή:
```bash
frida -U -f com.highaltitudehacks.DVIAswiftv2 --no-pause -l fingerprint-bypass-ios.js
```
## Έκθεση Ευαίσθητων Λειτουργιών μέσω IPC

### Custom URI Handlers / Deeplinks / Custom Schemes


{{#ref}}
ios-custom-uri-handlers-deeplinks-custom-schemes.md
{{#endref}}

### Universal Links


{{#ref}}
ios-universal-links.md
{{#endref}}

### UIActivity Sharing


{{#ref}}
ios-uiactivity-sharing.md
{{#endref}}

### UIPasteboard


{{#ref}}
ios-uipasteboard.md
{{#endref}}

### App Extensions


{{#ref}}
ios-app-extensions.md
{{#endref}}

### WebViews


{{#ref}}
ios-webviews.md
{{#endref}}

### Serialisation and Encoding


{{#ref}}
ios-serialisation-and-encoding.md
{{#endref}}

## Δικτυακή Επικοινωνία

Είναι σημαντικό να ελέγξετε ότι δεν γίνεται καμία επικοινωνία **χωρίς κρυπτογράφηση** και επίσης ότι η εφαρμογή επαληθεύει σωστά το **πιστοποιητικό TLS** του server.\
Για να ελέγξετε αυτού του είδους τα ζητήματα μπορείτε να χρησιμοποιήσετε έναν proxy όπως το **Burp**:


{{#ref}}
burp-configuration-for-ios.md
{{#endref}}

### Έλεγχος hostname

Ένα κοινό πρόβλημα κατά την επαλήθευση του πιστοποιητικού TLS είναι να ελέγχεται ότι το πιστοποιητικό έχει υπογραφεί από μια **έμπιστη** **CA**, αλλά **να μην ελέγχεται** αν **το hostname** του πιστοποιητικού είναι το hostname που προσπελαύνεται.\
Για να ελέγξετε αυτό το ζήτημα χρησιμοποιώντας το Burp, αφού εμπιστευτείτε το Burp CA στο iPhone, μπορείτε να **δημιουργήσετε ένα νέο πιστοποιητικό με το Burp για διαφορετικό hostname** και να το χρησιμοποιήσετε. Αν η εφαρμογή συνεχίσει να λειτουργεί, τότε υπάρχει ευπάθεια.

### Certificate Pinning

Αν μια εφαρμογή χρησιμοποιεί σωστά το SSL Pinning, τότε η εφαρμογή θα λειτουργεί μόνο αν το πιστοποιητικό είναι αυτό που αναμένεται. Κατά τη δοκιμή μιας εφαρμογής **αυτό μπορεί να αποτελεί πρόβλημα καθώς το Burp θα σερβίρει το δικό του πιστοποιητικό.**\
Για να παρακάμψετε αυτήν την προστασία σε μια jailbroken συσκευή, μπορείτε να εγκαταστήσετε την εφαρμογή [**SSL Kill Switch**](https://github.com/nabla-c0d3/ssl-kill-switch2) ή να εγκαταστήσετε [**Burp Mobile Assistant**](https://portswigger.net/burp/documentation/desktop/mobile/config-ios-device)

Μπορείτε επίσης να χρησιμοποιήσετε την εντολή του **objection** `ios sslpinning disable`

## Διάφορα

- Στο **`/System/Library`** μπορείτε να βρείτε τα frameworks εγκατεστημένα στο τηλέφωνο που χρησιμοποιούνται από τις system εφαρμογές
- Οι εφαρμογές που εγκαθίστανται από τον χρήστη από το App Store βρίσκονται μέσα στο **`/User/Applications`**
- Και το **`/User/Library`** περιέχει δεδομένα που αποθηκεύονται από εφαρμογές επιπέδου χρήστη
- Μπορείτε να έχετε πρόσβαση στο **`/User/Library/Notes/notes.sqlite`** για να διαβάσετε τις σημειώσεις που έχουν αποθηκευτεί μέσα στην εφαρμογή.
- Μέσα στον φάκελο μιας εγκατεστημένης εφαρμογής (**`/User/Applications/<APP ID>/`**) μπορείτε να βρείτε μερικά ενδιαφέροντα αρχεία:
- **`iTunesArtwork`**: Το εικονίδιο που χρησιμοποιεί η app
- **`iTunesMetadata.plist`**: Πληροφορίες της app που χρησιμοποιούνται στο App Store
- **`/Library/*`**: Περιέχει τις προτιμήσεις και την cache. Στο **`/Library/Cache/Snapshots/*`** μπορείτε να βρείτε το snapshot που έγινε στην εφαρμογή πριν την αποστείλετε στο background.

### Hot Patching/Enforced Updateing

Οι developers μπορούν απομακρυσμένα να **patchάρουν όλες τις εγκαταστάσεις της εφαρμογής τους άμεσα** χωρίς να χρειαστεί να υποβάλουν ξανά την εφαρμογή στο App Store και να περιμένουν την έγκριση.\
Για αυτό το σκοπό συνήθως χρησιμοποιείται [**JSPatch**](https://github.com/bang590/JSPatch). Αλλά υπάρχουν και άλλες επιλογές όπως [Siren](https://github.com/ArtSabintsev/Siren) και [react-native-appstore-version-checker](https://www.npmjs.com/package/react-native-appstore-version-checker).\
**Αυτός είναι ένας επικίνδυνος μηχανισμός που μπορεί να καταχραστεί από κακόβουλα third party SDKs, επομένως συνιστάται να ελέγξετε ποια μέθοδος χρησιμοποιείται για αυτόματες ενημερώσεις (αν υπάρχει) και να τη δοκιμάσετε.** Μπορείτε να δοκιμάσετε να κατεβάσετε μια προηγούμενη έκδοση της εφαρμογής για αυτό το σκοπό.

### Third Parties

Μια σημαντική πρόκληση με τα **3rd party SDKs** είναι η **έλλειψη λεπτομερούς ελέγχου** πάνω στις λειτουργίες τους. Οι developers αντιμετωπίζουν μια επιλογή: είτε ενσωματώνουν το SDK και αποδέχονται όλες τις λειτουργίες του, συμπεριλαμβανομένων πιθανών ευπαθειών ασφαλείας και ανησυχιών για το απόρρητο, είτε παραιτούνται από τα οφέλη του. Συχνά, οι developers δεν μπορούν να επιδιορθώσουν ευπάθειες μέσα σε αυτά τα SDKs από μόνοι τους. Επιπλέον, καθώς τα SDKs αποκτούν εμπιστοσύνη στην κοινότητα, κάποια μπορεί να αρχίσουν να περιέχουν malware.

Οι υπηρεσίες που παρέχονται από third-party SDKs μπορεί να περιλαμβάνουν παρακολούθηση συμπεριφοράς χρηστών, εμφάνιση διαφημίσεων ή βελτιώσεις στην εμπειρία χρήστη. Ωστόσο, αυτό εισάγει ρίσκο καθώς οι developers μπορεί να μην είναι πλήρως ενήμεροι για τον κώδικα που εκτελούν αυτές οι βιβλιοθήκες, οδηγώντας σε πιθανούς κινδύνους απορρήτου και ασφάλειας. Είναι κρίσιμο να περιοριστούν τα δεδομένα που μοιράζονται με third-party υπηρεσίες στο ελάχιστο αναγκαίο και να διασφαλιστεί ότι δεν αποκαλύπτονται ευαίσθητα δεδομένα.

Η υλοποίηση υπηρεσιών τρίτων συνήθως γίνεται με δύο μορφές: μια ανεξάρτητη βιβλιοθήκη ή ένα πλήρες SDK. Για την προστασία του απορρήτου των χρηστών, οποιαδήποτε δεδομένα μοιράζονται με αυτές τις υπηρεσίες θα πρέπει να **ανωνυμοποιούνται** ώστε να αποτραπεί η αποκάλυψη Personal Identifiable Information (PII).

Για να εντοπίσετε ποιες βιβλιοθήκες χρησιμοποιεί μια εφαρμογή, μπορείτε να χρησιμοποιήσετε την εντολή **`otool`**. Αυτό το εργαλείο πρέπει να τρέξει πάνω στην εφαρμογή και σε κάθε shared library που χρησιμοποιεί για να ανακαλύψει επιπλέον βιβλιοθήκες.
```bash
otool -L <application_path>
```
## Ενδιαφέρουσες Ευπάθειες & Μελέτες Περίπτωσης


{{#ref}}
air-keyboard-remote-input-injection.md
{{#endref}}

{{#ref}}
itunesstored-bookassetd-sandbox-escape.md
{{#endref}}

{{#ref}}
zero-click-messaging-image-parser-chains.md
{{#endref}}

## **Αναφορές & Περισσότεροι Πόροι**

- [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering)
- [iOS & Mobile App Pentesting - INE](https://my.ine.com/CyberSecurity/courses/089d060b/ios-mobile-app-pentesting)
- [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/)
- [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/)
- [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/)
- [https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage](https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage)
- [https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way](https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053)
- [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060)
- [https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/](https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064](https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064)
- [https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc](https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054)
- [https://github.com/ivRodriguezCA/RE-iOS-Apps/](https://github.com/ivRodriguezCA/RE-iOS-Apps/) Δωρεάν μάθημα για IOS([https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/])
- [https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577](https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577)
- [https://www.slideshare.net/RyanISI/ios-appsecurityminicourse](https://www.slideshare.net/RyanISI/ios-appsecurityminicourse)
- [https://github.com/prateek147/DVIA](https://github.com/prateek147/DVIA)
- [https://github.com/prateek147/DVIA-v2](https://github.com/prateek147/DVIA-v2)
- [https://github.com/OWASP/MSTG-Hacking-Playground%20](https://github.com/OWASP/MSTG-Hacking-Playground)
- OWASP iGoat [_https://github.com/OWASP/igoat_](https://github.com/OWASP/igoat) <<< Έκδοση Objective-C [_https://github.com/OWASP/iGoat-Swift_](https://github.com/OWASP/iGoat-Swift) <<< Έκδοση Swift
- [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
- [https://github.com/nabla-c0d3/ssl-kill-switch2](https://github.com/nabla-c0d3/ssl-kill-switch2)


{{#include ../../banners/hacktricks-training.md}}
