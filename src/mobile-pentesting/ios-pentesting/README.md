# iOS Pentesting

{{#include ../../banners/hacktricks-training.md}}

## iOS Osnove


{{#ref}}
ios-basics.md
{{#endref}}

## Okruženje za testiranje

U ovoj stranici možete pronaći informacije o **iOS simulator**, **emulators** i **jailbreaking:**


{{#ref}}
ios-testing-environment.md
{{#endref}}

## Početna analiza

### Osnovne operacije testiranja iOS-a

Tokom testiranja biće predloženo **nekoliko operacija** (povezivanje sa uređajem, čitanje/pisanje/upload/download fajlova, korišćenje alata...). Dakle, ako ne znate kako da izvedete neku od ovih radnji, molimo vas **počnite sa čitanjem stranice**:


{{#ref}}
basic-ios-testing-operations.md
{{#endref}}

> [!TIP]
> Za naredne korake **aplikacija treba da bude instalirana** na uređaju i trebalo bi već da imate **IPA file** aplikacije.\
> Read the [Basic iOS Testing Operations](basic-ios-testing-operations.md) page to learn how to do this.

### Osnovna statička analiza

Neki interesantni iOS - IPA fajlova dekompajleri:

- [https://github.com/LaurieWired/Malimite](https://github.com/LaurieWired/Malimite)
- [https://ghidra-sre.org/](https://ghidra-sre.org/)

Preporučuje se korišćenje alata [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) za izvođenje automatske statičke analize IPA fajla.

Identifikacija **zaštita prisutnih u binarnom fajlu**:

- **PIE (Position Independent Executable)**: Kada je omogućeno, aplikacija se učitava na nasumičnu memorijsku adresu svaki put kada se pokrene, što otežava predviđanje njene početne memorijske adrese.

```bash
otool -hv <app-binary> | grep PIE   # It should include the PIE flag
```

- **Stack Canaries**: Da bi se validirao integritet steka, vrednost 'canary' se postavlja na stek pre poziva funkcije i ponovo se proverava po završetku funkcije.

```bash
otool -I -v <app-binary> | grep stack_chk   # It should include the symbols: stack_chk_guard and stack_chk_fail
```

- **ARC (Automatic Reference Counting)**: Da bi se sprečile uobičajene greške u upravljanju memorijom

```bash
otool -I -v <app-binary> | grep objc_release   # It should include the _objc_release symbol
```

- **Encrypted Binary**: Binarni fajl bi trebalo da bude enkriptovan

```bash
otool -arch all -Vl <app-binary> | grep -A5 LC_ENCRYPT   # The cryptid should be 1
```

**Identifikacija osetljivih/nesigurnih funkcija**

- **Weak Hashing Algorithms**

```bash
# On the iOS device
otool -Iv <app> | grep -w "_CC_MD5"
otool -Iv <app> | grep -w "_CC_SHA1"

# On linux
grep -iER "_CC_MD5"
grep -iER "_CC_SHA1"
```

- **Insecure Random Functions**

```bash
# On the iOS device
otool -Iv <app> | grep -w "_random"
otool -Iv <app> | grep -w "_srand"
otool -Iv <app> | grep -w "_rand"

# On linux
grep -iER "_random"
grep -iER "_srand"
grep -iER "_rand"
```

- **Insecure ‘Malloc’ Function**

```bash
# On the iOS device
otool -Iv <app> | grep -w "_malloc"

# On linux
grep -iER "_malloc"
```

- **Insecure and Vulnerable Functions**

```bash
# On the iOS device
otool -Iv <app> | grep -w "_gets"
otool -Iv <app> | grep -w "_memcpy"
otool -Iv <app> | grep -w "_strncpy"
otool -Iv <app> | grep -w "_strlen"
otool -Iv <app> | grep -w "_vsnprintf"
otool -Iv <app> | grep -w "_sscanf"
otool -Iv <app> | grep -w "_strtok"
otool -Iv <app> | grep -w "_alloca"
otool -Iv <app> | grep -w "_sprintf"
otool -Iv <app> | grep -w "_printf"
otool -Iv <app> | grep -w "_vsprintf"

# On linux
grep -R "_gets"
grep -iER "_memcpy"
grep -iER "_strncpy"
grep -iER "_strlen"
grep -iER "_vsnprintf"
grep -iER "_sscanf"
grep -iER "_strtok"
grep -iER "_alloca"
grep -iER "_sprintf"
grep -iER "_printf"
grep -iER "_vsprintf"
```

#### Uobičajene metode detekcije Jailbreak-a

- **Provere fajl sistema**: Potražite prisustvo uobičajenih fajlova i direktorijuma povezanih sa jailbreak-om, kao što su `/Applications/Cydia.app` ili `/Library/MobileSubstrate/MobileSubstrate.dylib`.
- **Kršenja sandbox-a**: Pokušajte da pristupite ograničenim delovima fajl sistema, što bi trebalo da bude blokirano na uređajima bez jailbreak-a.
- **API provere**: Proverite da li je moguće koristiti zabranjene pozive kao što su `fork()` za kreiranje child procesa ili `system()` da biste videli da li postoji /bin/sh.
- **Provere procesa**: Pratite prisustvo poznatih procesa povezanih sa jailbreak-om, kao što su `Cydia`, `Substrate`, ili `ssh`.
- **Kernel eksploati**: Proverite prisustvo kernel exploit-a koji se često koriste u jailbreak-ovima.
- **Environment Variables**: Ispitajte environment varijable zbog znakova jailbreak-a, kao što je `DYLD_INSERT_LIBRARIES`.
- **Provera biblioteka**: Proverite koje libs su učitane u procesu aplikacije.
- **Provera shema**: Kao `canOpenURL(URL(string: "cydia://"))`.

#### Uobičajene metode detekcije Anti-Debugging-a

- **Provera prisustva debuggera**: Koristite `sysctl` ili druge metode da proverite da li je debugger prikačen.
- **Anti-Debugging API-ji**: Potražite pozive anti-debugging API-ja kao što su `ptrace` ili `SIGSTOP`, npr. `ptrace(PT_DENY_ATTACH, 0, 0, 0)`.
- **Provere vremena**: Izmerite vreme potrebno za određene operacije i tražite odstupanja koja mogu ukazivati na debugovanje.
- **Provere memorije**: Ispitajte memoriju zbog poznatih artefakata ili modifikacija koje ostavljaju debugger-i.
- **Environment Variables**: Proverite environment varijable koje mogu ukazivati na debug sesiju.
- **Mach Ports**: Detektujte da li mach exception ports koriste debugger-i.

### Osnovna dinamička analiza

Pogledajte dinamičku analizu koju izvodi [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF). Biće potrebno da prolazite kroz različite prikaze i interagujete sa njima, ali će alat hook-ovati nekoliko klasa i uraditi druge stvari i pripremiti izveštaj kada završite.

### Prikaz instaliranih aplikacija

Koristite komandu `frida-ps -Uai` da odredite **bundle identifier** instaliranih aplikacija:
```bash
$ frida-ps -Uai
PID  Name                 Identifier
----  -------------------  -----------------------------------------
6847  Calendar             com.apple.mobilecal
6815  Mail                 com.apple.mobilemail
-  App Store            com.apple.AppStore
-  Apple Store          com.apple.store.Jolly
-  Calculator           com.apple.calculator
-  Camera               com.apple.camera
-  iGoat-Swift          OWASP.iGoat-Swift
```
### Osnovna Enumeration & Hooking

Naučite kako da **enumerate the components of the application** i kako lako da **hook methods and classes** pomoću objection:


{{#ref}}
ios-hooking-with-objection.md
{{#endref}}

### IPA Structure

Struktura **IPA file** je suštinski ista kao kod **zipped package**. Preimenovanjem ekstenzije u `.zip`, može se raspakovati kako bi se otkrio sadržaj. U okviru ove strukture, **Bundle** predstavlja potpuno upakovanu aplikaciju spremnu za instalaciju. Unutar ćete naći direktorijum nazvan `<NAME>.app`, koji enkapsulira resurse aplikacije.

- **`Info.plist`**: Ovaj fajl sadrži specifične konfiguracione detalje aplikacije.
- **`_CodeSignature/`**: Ovaj direktorijum uključuje plist fajl koji sadrži potpis, obezbeđujući integritet svih fajlova u bundle-u.
- **`Assets.car`**: Kompresovani arhiv koji skladišti asset fajlove poput ikonica.
- **`Frameworks/`**: Ova fascikla sadrži native biblioteke aplikacije, koje mogu biti u obliku `.dylib` ili `.framework` fajlova.
- **`PlugIns/`**: Može da uključi ekstenzije aplikacije, poznate kao `.appex` fajlovi, iako nisu uvek prisutni. \* [**`Core Data`**](https://developer.apple.com/documentation/coredata): Koristi se za čuvanje trajnih podataka aplikacije za offline upotrebu, za keširanje privremenih podataka i za dodavanje undo funkcionalnosti unutar jednog uređaja. Za sinhronizaciju podataka preko više uređaja u okviru istog iCloud naloga, Core Data automatski preslikava vaš šematski model u CloudKit container.
- [**`PkgInfo`**](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigApplications.html): `PkgInfo` fajl je alternativni način da se specificiraju type i creator kodovi vaše aplikacije ili bundle-a.
- **en.lproj, fr.proj, Base.lproj**: Jezički paketi koji sadrže resurse za te specifične jezike, kao i podrazumevani resurs u slučaju da je jezik nepodržan.
- **Security**: Direktoriјum `_CodeSignature/` igra ključnu ulogu u bezbednosti aplikacije verifikujući integritet svih fajlova u bundle-u putem digitalnih potpisa.
- **Asset Management**: Fajl `Assets.car` koristi kompresiju za efikasno upravljanje grafičkim resursima, što je ključno za optimizaciju performansi aplikacije i smanjenje ukupne veličine.
- **Frameworks and PlugIns**: Ovi direktorijumi naglašavaju modularnost iOS aplikacija, omogućavajući developerima da uključe ponovo upotrebljiv kod (`Frameworks/`) i prošire funkcionalnost aplikacije (`PlugIns/`).
- **Localization**: Struktura podržava više jezika, olakšavajući globalno širenje aplikacije uključivanjem resursa za određene jezičke pakete.

**Info.plist**

Fajl **Info.plist** predstavlja kamen temeljac za iOS aplikacije, enkapsulirajući ključne konfiguracione podatke u obliku **key-value** parova. Ovaj fajl je obavezan ne samo za aplikacije već i za app extensions i framework-ove uklopljene u bundle. Strukturiran je u XML ili binarnom formatu i sadrži kritične informacije koje se kreću od dozvola aplikacije do bezbednosnih konfiguracija. Za detaljno istraživanje dostupnih ključeva, možete se obratiti [**Apple Developer Documentation**](https://developer.apple.com/documentation/bundleresources/information_property_list?language=objc).

Za one koji žele da rade sa ovim fajlom u pristupačnijem formatu, XML konverzija se može lako postići pomoću `plutil` na macOS (dostupan nativno na verzijama 10.2 i novijim) ili `plistutil` na Linux-u. Komande za konverziju su sledeće:

- **For macOS**:
```bash
$ plutil -convert xml1 Info.plist
```
- **Za Linux**:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
Među bezbrojnim informacijama koje fajl **Info.plist** može otkriti, značajni unosi uključuju stringove dozvola aplikacije (`UsageDescription`), prilagođene URL scheme-ove (`CFBundleURLTypes`) i konfiguracije za App Transport Security (`NSAppTransportSecurity`). Ovi unosi, zajedno sa drugim, kao što su izvezeni/uvoženi prilagođeni tipovi dokumenata (`UTExportedTypeDeclarations` / `UTImportedTypeDeclarations`), mogu se lako pronaći pregledom fajla ili korišćenjem jednostavne `grep` komande:
```bash
$ grep -i <keyword> Info.plist
```
**Putanje podataka**

U iOS okruženju, direktorijumi su posebno dodeljeni za **sistemske aplikacije** i **korisnički instalirane aplikacije**. Sistemske aplikacije se nalaze u direktorijumu `/Applications`, dok su korisnički instalirane aplikacije smeštene pod `/var/mobile/containers/Data/Application/`. Ove aplikacije dobijaju jedinstveni identifikator poznat kao **128-bit UUID**, što otežava ručno pronalaženje fascikle aplikacije zbog nasumičnosti imena direktorijuma.

> [!WARNING]
> Pošto aplikacije na iOS moraju biti sandboxovane, svaka aplikacija će takođe imati fasciklu unutar **`$HOME/Library/Containers`** sa **`CFBundleIdentifier`** aplikacije kao imenom fascikle.
>
> Međutim, obe fascikle (data & container folders) imaju fajl **`.com.apple.mobile_container_manager.metadata.plist`** koji povezuje oba direktorijuma u ključu `MCMetadataIdentifier`).

Da bi se olakšalo otkrivanje direktorijuma instalacije aplikacije koju je korisnik instalirao, **objection tool** pruža korisnu komandu, `env`. Ova komanda prikazuje detaljne informacije o direktorijumima za aplikaciju o kojoj je reč. Ispod je primer kako koristiti ovu komandu:
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # env

Name               Path
-----------------  -------------------------------------------------------------------------------------------
BundlePath         /var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app
CachesDirectory    /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library/Caches
DocumentDirectory  /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Documents
LibraryDirectory   /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library
```
Alternativno, ime aplikacije može да се pretraži unutar `/private/var/containers` koristeći komandu `find`:
```bash
find /private/var/containers -name "Progname*"
```
Komande kao što su `ps` i `lsof` takođe se mogu koristiti za identifikaciju app procesa i navođenje otvorenih fajlova, odnosno za dobijanje uvida u aktivne direktorijumske putanje aplikacije:
```bash
ps -ef | grep -i <app-name>
lsof -p <pid> | grep -i "/containers" | head -n 1
```
**Bundle directory:**

- **AppName.app**
- Ovo je aplikacioni paket kao što je ranije viđeno u IPA, sadrži osnovne podatke aplikacije, statički sadržaj kao i kompajlirani binarni fajl aplikacije.
- Ovaj direktorijum je vidljiv korisnicima, ali **korisnici ne mogu da pišu u njega**.
- Sadržaj u ovom direktorijumu **se ne pravi rezervna kopija**.
- Sadržaj ove fascikle se koristi za **validaciju code signature**.

**Data directory:**

- **Documents/**
- Sadrži sve podatke koje generiše korisnik. Krajnji korisnik aplikacije inicira kreiranje ovih podataka.
- Vidljivo korisnicima i **korisnici mogu da pišu u njega**.
- Sadržaj u ovom direktorijumu **se pravi rezervna kopija**.
- Aplikacija može isključiti puteve koristeći `NSURLIsExcludedFromBackupKey`.
- **Library/**
- Sadrži sve **fajlove koji nisu specifični za korisnika**, kao što su **caches**, **preferences**, **cookies**, i property list (plist) konfiguracioni fajlovi.
- iOS aplikacije obično koriste `Application Support` i `Caches` poddirektorijume, ali aplikacija može kreirati prilagođene poddirektorijume.
- **Library/Caches/**
- Sadrži **polupostojane keširane fajlove.**
- Nevidljivo korisnicima i **korisnici ne mogu da pišu u njega**.
- Sadržaj u ovom direktorijumu **se ne pravi rezervna kopija**.
- Sistem može automatski izbrisati fajlove iz ovog direktorijuma kada aplikacija nije pokrenuta i kada je prostor za skladištenje ograničen.
- **Library/Application Support/**
- Sadrži **perzistentne** **fajlove** neophodne za pokretanje aplikacije.
- **Nevidljivo** **korisnicima** i korisnici ne mogu da pišu u njega.
- Sadržaj u ovom direktorijumu **se pravi rezervna kopija**.
- Aplikacija može isključiti puteve koristeći `NSURLIsExcludedFromBackupKey`.
- **Library/Preferences/**
- Koristi se za čuvanje svojstava koja mogu **ostati čak i nakon što se aplikacija restartuje**.
- Informacije se čuvaju, nešifrovane, unutar sandbox-a aplikacije u plist fajlu nazvanom \[BUNDLE_ID].plist.
- Sve key/value parove sačuvane pomoću `NSUserDefaults` možete naći u ovom fajlu.
- **tmp/**
- Koristite ovaj direktorijum za upis **privremenih fajlova** koji ne treba da traju između pokretanja aplikacije.
- Sadrži neperzistentne keširane fajlove.
- **Nevidljivo** korisnicima.
- Sadržaj u ovom direktorijumu se ne pravi rezervna kopija.
- Sistem može automatski izbrisati fajlove iz ovog direktorijuma kada aplikacija nije pokrenuta i kada je prostor za skladištenje ograničen.

Hajde da pogledamo bliže iGoat-Swift Application Bundle (.app) direktorijum unutar Bundle direktorijuma (`/var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app`):
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # ls
NSFileType      Perms  NSFileProtection    ...  Name
------------  -------  ------------------  ...  --------------------------------------
Regular           420  None                ...  rutger.html
Regular           420  None                ...  mansi.html
Regular           420  None                ...  splash.html
Regular           420  None                ...  about.html

Regular           420  None                ...  LICENSE.txt
Regular           420  None                ...  Sentinel.txt
Regular           420  None                ...  README.txt
```
### Binary Reversing

Unutar foldera `<application-name>.app` naći ćete binarni fajl nazvan `<application-name>`. Ovo je datoteka koja će biti **izvršena**. Možete obaviti osnovnu inspekciju binarnog fajla pomoću alata **`otool`**:
```bash
otool -Vh DVIA-v2 #Check some compilation attributes
magic  cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64    ARM64        ALL  0x00     EXECUTE    65       7112   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE

otool -L DVIA-v2 #Get third party libraries
DVIA-v2:
/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.1)
/usr/lib/libsqlite3.dylib (compatibility version 9.0.0, current version 274.6.0)
/usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11)
@rpath/Bolts.framework/Bolts (compatibility version 1.0.0, current version 1.0.0)
[...]
```
**Proverite da li je aplikacija šifrovana**

Proverite da li postoji izlaz za:
```bash
otool -l <app-binary> | grep -A 4 LC_ENCRYPTION_INFO
```
**Disasembliranje binarne datoteke**

Disasemblirajte sekciju .text:
```bash
otool -tV DVIA-v2
DVIA-v2:
(__TEXT,__text) section
+[DDLog initialize]:
0000000100004ab8    sub    sp, sp, #0x60
0000000100004abc    stp    x29, x30, [sp, #0x50]   ; Latency: 6
0000000100004ac0    add    x29, sp, #0x50
0000000100004ac4    sub    x8, x29, #0x10
0000000100004ac8    mov    x9, #0x0
0000000100004acc    adrp    x10, 1098 ; 0x10044e000
0000000100004ad0    add    x10, x10, #0x268
```
Za ispis **Objective-C segmenta** primera aplikacije može se koristiti:
```bash
otool -oV DVIA-v2
DVIA-v2:
Contents of (__DATA,__objc_classlist) section
00000001003dd5b8 0x1004423d0 _OBJC_CLASS_$_DDLog
isa        0x1004423a8 _OBJC_METACLASS_$_DDLog
superclass 0x0 _OBJC_CLASS_$_NSObject
cache      0x0 __objc_empty_cache
vtable     0x0
data       0x1003de748
flags          0x80
instanceStart  8
```
Da biste dobili kompaktniji Objective-C kod, možete koristiti [**class-dump**](http://stevenygard.com/projects/class-dump/):
```bash
class-dump some-app
//
//     Generated by class-dump 3.5 (64 bit).
//
//     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2013 by Steve Nygard.
//

#pragma mark Named Structures

struct CGPoint {
double _field1;
double _field2;
};

struct CGRect {
struct CGPoint _field1;
struct CGSize _field2;
};

struct CGSize {
double _field1;
double _field2;
};
```
Međutim, najbolje opcije za disasembliranje binarnog fajla su: [**Hopper**](https://www.hopperapp.com/download.html?) i [**IDA**](https://www.hex-rays.com/products/ida/support/download_freeware/).

## Skladištenje podataka

Da biste saznali kako iOS čuva podatke na uređaju pročitajte ovu stranicu:


{{#ref}}
ios-basics.md
{{#endref}}

> [!WARNING]
> Sledeća mesta za čuvanje informacija treba proveriti **odmah nakon instalacije aplikacije**, **nakon provere svih funkcionalnosti** aplikacije i čak nakon **odjave jednog korisnika i prijave drugog**.\
> Cilj je pronaći **nezaštićene osetljive informacije** aplikacije (lozinke, tokeni), trenutnog korisnika i ranije prijavljenih korisnika.

### Plist

**plist** fajlovi su strukturisani XML fajlovi koji sadrže **parove ključ-vrednost**. To je način za trajno čuvanje podataka, pa ponekad možete pronaći **osetljive informacije u tim fajlovima**. Preporučuje se proveriti ove fajlove nakon instalacije aplikacije i nakon intenzivne upotrebe da biste videli da li su novi podaci zapisani.

Najčešći način za trajno čuvanje podataka u plist fajlovima je korišćenje **NSUserDefaults**. Ovaj plist fajl se čuva unutar app sandbox-a u **`Library/Preferences/<appBundleID>.plist`**

Klasa [`NSUserDefaults`](https://developer.apple.com/documentation/foundation/nsuserdefaults) obezbeđuje programski interfejs za interakciju sa default sistemom. Default sistem omogućava aplikaciji da prilagodi svoje ponašanje prema korisničkim podešavanjima. Podaci sačuvani preko `NSUserDefaults` mogu se pregledati u bundle-u aplikacije. Ova klasa čuva podatke u plist fajlu, ali je namenjena za rad sa malim količinama podataka.

Ovi podaci više ne mogu biti direktno pristupljeni preko pouzdanog računara, ali im se može pristupiti izvršavanjem **backup**-a.

Možete **dump** informacije sačuvane pomoću **`NSUserDefaults`** koristeći objection-ovu komandu `ios nsuserdefaults get`

Da biste pronašli sve plist-ove koje koristi aplikacija, možete pristupiti `/private/var/mobile/Containers/Data/Application/{APPID}` i pokrenuti:
```bash
find ./ -name "*.plist"
```
Za konvertovanje fajlova iz **XML ili binarnog (bplist)** formata u XML, dostupne su razne metode u zavisnosti od vašeg operativnog sistema:

**Za macOS korisnike:** Koristite `plutil` komandu. To je ugrađeni alat u macOS-u (10.2+), namenjen za ovu svrhu:
```bash
$ plutil -convert xml1 Info.plist
```
**Za Linux korisnike:** Prvo instalirajte `libplist-utils`, zatim koristite `plistutil` da konvertujete vaš fajl:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
**U okviru Objection sesije:** Za analizu mobilnih aplikacija, određena komanda vam omogućava da direktno konvertujete plist files:
```bash
ios plist cat /private/var/mobile/Containers/Data/Application/<Application-UUID>/Library/Preferences/com.some.package.app.plist
```
### Core Data

[`Core Data`](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/nsfetchedresultscontroller.html#//apple_ref/doc/uid/TP40001075-CH8-SW1) je framework za upravljanje model-slojem objekata u vašoj aplikaciji. [Core Data can use SQLite as its persistent store](https://cocoacasts.com/what-is-the-difference-between-core-data-and-sqlite/), ali sam framework nije baza podataka.\
CoreData ne šifruje svoje podatke podrazumevano. Međutim, dodatni sloj enkripcije može se dodati CoreData. See the [GitHub Repo](https://github.com/project-imas/encrypted-core-data) for more details.

You can find the SQLite Core Data information of an application in the path `/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support`

**Ako možete otvoriti SQLite i pristupiti osetljivim informacijama, onda ste pronašli pogrešnu konfiguraciju.**
```objectivec:Code from iGoat
-(void)storeDetails {
AppDelegate * appDelegate = (AppDelegate *)(UIApplication.sharedApplication.delegate);

NSManagedObjectContext *context =[appDelegate managedObjectContext];

User *user = [self fetchUser];
if (user) {
return;
}
user = [NSEntityDescription insertNewObjectForEntityForName:@"User"
inManagedObjectContext:context];
user.email = CoreDataEmail;
user.password = CoreDataPassword;
NSError *error;
if (![context save:&error]) {
NSLog(@"Error in saving data: %@", [error localizedDescription]);

}else{
NSLog(@"data stored in core data");
}
}
```
### YapDatabase

[YapDatabase](https://github.com/yapstudios/YapDatabase) je key/value store izgrađen na vrhu SQLite.\
Pošto su Yap databases sqlite databases, možete ih pronaći koristeći pomenutu komandu iz prethodnog odeljka.

### Ostale SQLite baze podataka

Uobičajeno je da aplikacije kreiraju sopstvene sqlite baze podataka. Mogu da **čuvaju** **osetljive** **podatke** u njima i ostave ih nešifrovanim. Zbog toga je uvek zanimljivo proveriti svaku bazu u direktorijumu aplikacije. Pređite u direktorijum aplikacije gde su podaci sačuvani (`/private/var/mobile/Containers/Data/Application/{APPID}`)
```bash
find ./ -name "*.sqlite" -or -name "*.db"
```
### Firebase Real-Time Databases

Programeri mogu da **čuvaju i sinhronizuju podatke** u okviru **NoSQL baze podataka hostovane u oblaku** putem Firebase Real-Time Databases. Podaci se čuvaju u JSON formatu i sinhronizuju sa svim povezanim klijentima u realnom vremenu.

Možete pronaći kako proveriti pogrešno konfigurisane Firebase baze ovde:


{{#ref}}
../../network-services-pentesting/pentesting-web/buckets/firebase-database.md
{{#endref}}

### Realm databases

[Realm Objective-C](https://realm.io/docs/objc/latest/) and [Realm Swift](https://realm.io/docs/swift/latest/) nude moćnu alternativu za skladištenje podataka koju Apple ne obezbeđuje. Podrazumevano, oni **čuvaju podatke nešifrovane**, dok je šifrovanje dostupno kroz specifičnu konfiguraciju.

Baze se nalaze na: `/private/var/mobile/Containers/Data/Application/{APPID}`. Za istraživanje ovih fajlova mogu se koristiti komande kao što su:
```bash
iPhone:/private/var/mobile/Containers/Data/Application/A079DF84-726C-4AEA-A194-805B97B3684A/Documents root# ls
default.realm  default.realm.lock  default.realm.management/  default.realm.note|

$ find ./ -name "*.realm*"
```
Za pregled ovih datoteka baze podataka preporučuje se alat [**Realm Studio**](https://github.com/realm/realm-studio).

Za implementaciju enkripcije u Realm bazi podataka može se koristiti sledeći isječak koda:
```swift
// Open the encrypted Realm file where getKey() is a method to obtain a key from the Keychain or a server
let config = Realm.Configuration(encryptionKey: getKey())
do {
let realm = try Realm(configuration: config)
// Use the Realm as normal
} catch let error as NSError {
// If the encryption key is wrong, `error` will say that it's an invalid database
fatalError("Error opening realm: \(error)")
}
```
### Couchbase Lite baze podataka

[Couchbase Lite](https://github.com/couchbase/couchbase-lite-ios) je opisan kao **lagan** i **ugrađen** sistem baze podataka koji se zasniva na **orijentisanom na dokumente** (NoSQL) pristupu. Dizajniran da bude nativan za **iOS** i **macOS**, omogućava besprekornu sinhronizaciju podataka.

Da biste identifikovali potencijalne Couchbase baze podataka na uređaju, treba proveriti sledeći direktorijum:
```bash
ls /private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support/
```
### Cookies

iOS čuva cookies aplikacija u **`Library/Cookies/cookies.binarycookies`** unutar fascikle svake aplikacije. Međutim, developeri ponekad odluče da ih sačuvaju u **keychain** jer pomenuti **cookie file** može biti dostupan u backups.

Za inspekciju cookie file-a možete koristiti [**this python script**](https://github.com/mdegrazia/Safari-Binary-Cookie-Parser) ili koristiti objection-ovu komandu **`ios cookies get`.**\
**Možete takođe koristiti objection da** konvertujete ove fajlove u JSON format i pregledate podatke.
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios cookies get --json
[
{
"domain": "highaltitudehacks.com",
"expiresDate": "2051-09-15 07:46:43 +0000",
"isHTTPOnly": "false",
"isSecure": "false",
"name": "username",
"path": "/",
"value": "admin123",
"version": "0"
}
]
```
### Cache

By default NSURLSession stores data, such as **HTTP requests and responses in the Cache.db** database. This database can contain **sensitive data**, if tokens, usernames or any other sensitive information has been cached. To find the cached information open the data directory of the app (`/var/mobile/Containers/Data/Application/<UUID>`) and go to `/Library/Caches/<Bundle Identifier>`. The **WebKit cache is also being stored in the Cache.db** file. **Objection** can open and interact with the database with the command `sqlite connect Cache.db`, as it is a n**ormal SQLite database**.

Preporučuje se onemogućiti keširanje ovih podataka, jer mogu sadržati osetljive informacije u zahtevu ili odgovoru. Sledeći spisak prikazuje različite načine da se to postigne:

1.  Preporučuje se ukloniti keširane odgovore nakon logout-a. To se može uraditi uz pomoć metode koju je obezbedio Apple nazvane [`removeAllCachedResponses`](https://developer.apple.com/documentation/foundation/urlcache/1417802-removeallcachedresponses). Možete pozvati ovu metodu na sledeći način:

`URLCache.shared.removeAllCachedResponses()`

Ova metoda će ukloniti sve keširane zahteve i odgovore iz Cache.db fajla.

2.  Ako ne morate koristiti prednosti cookies, preporučljivo je koristiti [.ephemeral](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral) konfiguracionu opciju URLSession-a, koja će onemogućiti čuvanje cookies i Caches.

[Apple documentation](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral):

`An ephemeral session configuration object is similar to a default session configuration (see default), except that the corresponding session object doesn’t store caches, credential stores, or any session-related data to disk. Instead, session-related data is stored in RAM. The only time an ephemeral session writes data to disk is when you tell it to write the contents of a URL to a file.`

3.  Cache can be also disabled by setting the Cache Policy to [.notAllowed](https://developer.apple.com/documentation/foundation/urlcache/storagepolicy/notallowed). It will disable storing Cache in any fashion, either in memory or on disk.

### Snapshots

Whenever you press the home button, iOS **takes a snapshot of the current screen** to be able to do the transition to the application on a much smoother way. However, if **sensitive** **data** is present in the current screen, it will be **saved** in the **image** (which **persists** **across** **reboots**). These are the snapshots that you can also access double tapping the home screen to switch between apps.

Ako iPhone nije jailbroken, **napadač** mora imati **pristup** do **otključanog** **uređaja** da bi video ove snimke ekrana. Po defaultu poslednji snapshot se čuva u sandbox-u aplikacije u `Library/Caches/Snapshots/` ili `Library/SplashBoard/Snapshots` folderu (trusted computers can't access the filesystem from iOX 7.0).

Jedan način da se spreči ovo neželjeno ponašanje je da se prikaže prazna ekran ili uklone osetljivi podaci pre pravljenja snapshot-a koristeći funkciju `ApplicationDidEnterBackground()`.

Sledeći primer prikazuje metodu za otklanjanje propusta koja postavlja podrazumevani screenshot.

Swift:
```swift
private var backgroundImage: UIImageView?

func applicationDidEnterBackground(_ application: UIApplication) {
let myBanner = UIImageView(image: #imageLiteral(resourceName: "overlayImage"))
myBanner.frame = UIScreen.main.bounds
backgroundImage = myBanner
window?.addSubview(myBanner)
}

func applicationWillEnterForeground(_ application: UIApplication) {
backgroundImage?.removeFromSuperview()
}
```
Objective-C:
```
@property (UIImageView *)backgroundImage;

- (void)applicationDidEnterBackground:(UIApplication *)application {
UIImageView *myBanner = [[UIImageView alloc] initWithImage:@"overlayImage.png"];
self.backgroundImage = myBanner;
self.backgroundImage.bounds = UIScreen.mainScreen.bounds;
[self.window addSubview:myBanner];
}

- (void)applicationWillEnterForeground:(UIApplication *)application {
[self.backgroundImage removeFromSuperview];
}
```
Ovo postavlja pozadinsku sliku na `overlayImage.png` kad god se aplikacija prebaci u pozadinu. Time se sprečava sensitive data leak jer će `overlayImage.png` uvek prekriti trenutni prikaz.

### Keychain

Za pristup i upravljanje iOS keychain dostupni su alati poput [**Keychain-Dumper**](https://github.com/ptoomey3/Keychain-Dumper), pogodni za jailbroken devices. Pored toga, [**Objection**](https://github.com/sensepost/objection) pruža komandu `ios keychain dump` za slične namene.

#### **Skladištenje kredencijala**

Klasa **NSURLCredential** je idealna za čuvanje osetljivih informacija direktno u keychain-u, zaobilazeći potrebu za NSUserDefaults ili drugim wrapper-ima. Za skladištenje kredencijala nakon prijave koristi se sledeći Swift kod:
```swift
NSURLCredential *credential;
credential = [NSURLCredential credentialWithUser:username password:password persistence:NSURLCredentialPersistencePermanent];
[[NSURLCredentialStorage sharedCredentialStorage] setCredential:credential forProtectionSpace:self.loginProtectionSpace];
```
Za izdvajanje ovih sačuvanih kredencijala koristi se komanda Objection `ios nsurlcredentialstorage dump`.

## **Prilagođene tastature i keš tastature**

Sa iOS 8.0 nadalje, korisnici mogu instalirati prilagođene keyboard ekstenzije, kojima se može upravljati putem **Settings > General > Keyboard > Keyboards**. Iako ove tastature nude proširenu funkcionalnost, predstavljaju rizik od keystroke logging-a i slanja podataka na eksterne servere, iako su korisnici obavešteni o tastaturama kojima je potreban pristup mreži. Aplikacije mogu, i treba da, ograniče upotrebu prilagođenih tastatura za unos osetljivih informacija.

**Preporuke za bezbednost:**

- Preporučuje se onemogućavanje third-party tastatura radi poboljšane bezbednosti.
- Obratite pažnju na funkcije automatskog ispravljanja i automatskih predloga podrazumevane iOS tastature, koje mogu čuvati osetljive informacije u keš fajlovima lociranim u `Library/Keyboard/{locale}-dynamic-text.dat` ili `/private/var/mobile/Library/Keyboard/dynamic-text.dat`. Ovi keš fajlovi bi trebalo redovno da se proveravaju zbog osetljivih podataka. Preporučuje se resetovanje rečnika tastature putem **Settings > General > Reset > Reset Keyboard Dictionary** radi brisanja keširanih podataka.
- Presretanje mrežnog saobraćaja može otkriti da li prilagođena tastatura prenosi pritiske tastera na daljinu.

### **Sprečavanje keširanja polja za unos teksta**

The [UITextInputTraits protocol](https://developer.apple.com/reference/uikit/uitextinputtraits) nudi svojstva za upravljanje automatskim ispravljanjem i sigurnim unosom teksta, što je bitno za sprečavanje keširanja osetljivih informacija. Na primer, isključivanje automatskog ispravljanja i uključivanje sigurnog unosa teksta može se postići sa:
```objectivec
textObject.autocorrectionType = UITextAutocorrectionTypeNo;
textObject.secureTextEntry = YES;
```
Pored toga, programeri treba da obezbede da polja za unos teksta, posebno ona za unos osetljivih informacija kao što su lozinke i PIN-ovi, onemoguće keširanje podešavanjem `autocorrectionType` na `UITextAutocorrectionTypeNo` i `secureTextEntry` na `YES`.
```objectivec
UITextField *textField = [[UITextField alloc] initWithFrame:frame];
textField.autocorrectionType = UITextAutocorrectionTypeNo;
```
## **Logs**

Otklanjanje grešaka u kodu često podrazumeva korišćenje **logging**. Postoji rizik jer **logs mogu sadržati osetljive informacije**. Ranije, u iOS 6 i starijim verzijama, logs su bili dostupni svim aplikacijama, što je predstavljalo rizik od curenja osetljivih podataka. **Sada su aplikacije ograničene na pristup samo svojim logs**.

Uprkos tim ograničenjima, **napadač sa fizičkim pristupom** otključanom uređaju i dalje to može iskoristiti tako što će povezati uređaj sa računarom i **čitati logs**. Važno je napomenuti da logs ostaju na disku čak i nakon deinstalacije aplikacije.

Da bi se smanjili rizici, preporučuje se **temeljno interagovanje sa aplikacijom**, istražujući sve njene funkcionalnosti i ulaze kako bi se osiguralo da nijedna osetljiva informacija slučajno ne bude zabeležena.

Pri pregledu izvornog koda aplikacije u potrazi za potencijalnim leaks, tražite i **predefined** i **custom logging statements** koristeći ključne reči kao što su `NSLog`, `NSAssert`, `NSCAssert`, `fprintf` za ugrađene funkcije, i svaku pojavu `Logging` ili `Logfile` za custom implementacije.

### **Monitoring System Logs**

Aplikacije beleže razne informacije koje mogu biti osetljive. Za praćenje ovih logs, alati i komande kao što su:
```bash
idevice_id --list   # To find the device ID
idevicesyslog -u <id> (| grep <app>)   # To capture the device logs
```
su korisni. Dodatno, **Xcode** pruža način za prikupljanje konzolnih logova:

1. Otvorite Xcode.
2. Povežite iOS uređaj.
3. Idite na **Window** -> **Devices and Simulators**.
4. Izaberite svoj uređaj.
5. Pokrenite problem koji istražujete.
6. Koristite dugme **Open Console** da biste videli logove u novom prozoru.

Za naprednije logovanje, povezivanje sa shell-om uređaja i korišćenje **socat** može omogućiti praćenje logova u realnom vremenu:
```bash
iPhone:~ root# socat - UNIX-CONNECT:/var/run/lockdown/syslog.sock
```
Praćeno komandama za posmatranje aktivnosti logova, što može biti neprocenjivo za dijagnostikovanje problema ili identifikovanje potencijalnog data leakage u logovima.

## Bekapovi

**Auto-backup features** su integrisane u iOS, olakšavajući kreiranje kopija podataka uređaja putem iTunes (do macOS Catalina), Finder (od macOS Catalina nadalje) ili iCloud. Ovi bekapi obuhvataju gotovo sve podatke uređaja, isključujući veoma osetljive elemente poput podataka Apple Pay i konfiguracija Touch ID.

### Bezbednosni rizici

Uključivanje **instaliranih aplikacija i njihovih podataka** u bekap podiže pitanje potencijalnog **data leakage** i rizik da **izmene u bekapu mogu promeniti ponašanje aplikacije**. Savetuje se da **ne skladištite osetljive informacije u plaintext** unutar direktorijuma bilo koje aplikacije ili njenih poddirektorijuma kako biste umanjili ove rizike.

### Isključivanje fajlova iz bekapa

Fajlovi u `Documents/` i `Library/Application Support/` se podrazumevano bekapuju. Developeri mogu isključiti određene fajlove ili direktorijume iz bekapa koristeći `NSURL setResourceValue:forKey:error:` sa `NSURLIsExcludedFromBackupKey`. Ova praksa je ključna za zaštitu osetljivih podataka od uključivanja u bekap.

### Testiranje ranjivosti

Da biste procenili bezbednost bekapa aplikacije, počnite sa **kreiranjem bekapa** koristeći Finder, zatim ga pronađite prema uputstvima iz [Apple's official documentation](https://support.apple.com/en-us/HT204215). Analizirajte bekap u potrazi za osetljivim podacima ili konfiguracijama koje bi mogle biti izmenjene i uticati na ponašanje aplikacije.

Osetljive informacije mogu se tražiti koristeći komandne linijske alate ili aplikacije kao što je [iMazing](https://imazing.com). Za enkriptovane bekape, prisustvo enkripcije može se potvrditi pregledom ključa "IsEncrypted" u fajlu "Manifest.plist" u korenu bekapa.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
...
<key>Date</key>
<date>2021-03-12T17:43:33Z</date>
<key>IsEncrypted</key>
<true/>
...
</plist>
```
Za rad sa enkriptovanim backup-ovima, Python skripte dostupne u [DinoSec's GitHub repo](https://github.com/dinosec/iphone-dataprotection/tree/master/python_scripts), kao što su **backup_tool.py** i **backup_passwd.py**, mogu biti korisne, iako mogu zahtevati prilagođavanja radi kompatibilnosti sa najnovijim iTunes/Finder verzijama. The [**iOSbackup** tool](https://pypi.org/project/iOSbackup/) je još jedna opcija za pristup fajlovima unutar backup-ova zaštićenih lozinkom.

### Modifying App Behavior

Primer menjanja ponašanja aplikacije kroz izmene backup-a prikazan je u [Bither bitcoin wallet app](https://github.com/bither/bither-ios), gde je UI lock PIN smešten u `net.bither.plist` pod ključem **pin_code**. Uklanjanje ovog ključa iz plist-a i vraćanje backup-a uklanja zahtev za PIN-om, omogućavajući neograničen pristup.

## Summary on Memory Testing for Sensitive Data

Kada radite sa osetljivim informacijama koje su smeštene u memoriji aplikacije, ključno je ograničiti vreme izloženosti ovih podataka. Postoje dva primarna pristupa za ispitivanje sadržaja memorije: **creating a memory dump** i **analyzing the memory in real time**. Obe metode imaju svoje izazove, uključujući mogućnost da tokom procesa dumpovanja ili analize propustite kritične podatke.

## **Retrieving and Analyzing a Memory Dump**

For both jailbroken and non-jailbroken devices, tools like [objection](https://github.com/sensepost/objection) and [Fridump](https://github.com/Nightbringer21/fridump) allow for the dumping of an app's process memory. Kada je dump napravljen, analiza tih podataka zahteva različite alate, u zavisnosti od prirode informacija koje tražite.

Da biste izvukli strings iz memory dump-a, mogu se koristiti komande kao `strings` ili `rabin2 -zz`:
```bash
# Extracting strings using strings command
$ strings memory > strings.txt

# Extracting strings using rabin2
$ rabin2 -ZZ memory > strings.txt
```
Za detaljniju analizu, uključujući pretragu za specifične tipove podataka ili obrasce, **radare2** nudi opsežne mogućnosti pretrage:
```bash
$ r2 <name_of_your_dump_file>
[0x00000000]> /?
...
```
## **Analiza memorije u toku izvršavanja**

**r2frida** pruža moćnu alternativu za inspekciju memorije aplikacije u realnom vremenu, bez potrebe za memory dump. Ovaj alat omogućava izvršavanje search commands direktno nad memorijom pokrenute aplikacije:
```bash
$ r2 frida://usb//<name_of_your_app>
[0x00000000]> /\ <search_command>
```
## Slaba kriptografija

### Loši procesi upravljanja ključevima

Neki developeri čuvaju osetljive podatke u local storage i enkriptuju ih sa ključem koji je hardcoded/predictable u kodu. To ne bi trebalo raditi, jer reversing može omogućiti napadačima da izvuku poverljive informacije.

### Korišćenje nesigurnih i/ili zastarelih algoritama

Developeri ne bi trebalo da koriste **deprecated algorithms** za izvođenje autorizacionih **checks**, **store** ili **send** podataka. Neki od ovih algoritama su: RC4, MD4, MD5, SHA1... Ako se, na primer, za skladištenje lozinki koriste **hashes**, treba koristiti hashes brute-force **resistant** sa salt-om.

### Provera

Glavne provere koje treba izvršiti su da li možete pronaći **hardcoded** lozinke/tajne u kodu, da li su one **predictable**, i da li kod koristi neku vrstu **weak** **cryptography** algoritama.

Interesantno je znati da možete **monitor** neke **crypto** **libraries** automatski koristeći **objection** sa:
```swift
ios monitor crypt
```
Za **više informacija** o iOS kriptografskim API-jevima i bibliotekama, pogledajte [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography)

## Lokalna autentikacija

**Lokalna autentikacija** ima ključnu ulogu, naročito kada je u pitanju zaštita pristupa na udaljenoj krajnjoj tački pomoću kriptografskih metoda. Suština je da bez odgovarajuće implementacije, lokalni mehanizmi autentikacije mogu biti zaobiđeni.

Apple-ov [**Local Authentication framework**](https://developer.apple.com/documentation/localauthentication) i [**keychain**](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html) pružaju robusne API-je programerima za omogućavanje dijaloga za autentikaciju korisnika i bezbedno rukovanje tajnim podacima, redom. Secure Enclave štiti ID otiska prsta za Touch ID, dok Face ID koristi prepoznavanje lica bez kompromitovanja biometrijskih podataka.

Za integraciju Touch ID/Face ID developeri imaju dva izbora API-ja:

- **`LocalAuthentication.framework`** za autentikaciju korisnika na višem nivou bez pristupa biometrijskim podacima.
- **`Security.framework`** za niži nivo pristupa keychain servisima, osiguravajući tajne podatke pomoću biometrijske autentikacije. Razni [open-source wrappers](https://www.raywenderlich.com/147308/secure-ios-user-data-keychain-touch-id) olakšavaju pristup keychain-u.

> [!CAUTION]
> Međutim, i `LocalAuthentication.framework` i `Security.framework` imaju ranjivosti, budući da pretežno vraćaju boolean vrednosti bez prenosa podataka potrebnih za proces autentikacije, što ih čini podložnim zaobilaženju (pogledajte [Don't touch me that way, by David Lindner et al](https://www.youtube.com/watch?v=XhXIHVGCFFM)).

### Implementacija lokalne autentikacije

Za traženje autentikacije od korisnika, developeri treba da koriste metodu **`evaluatePolicy`** u okviru klase **`LAContext`**, birajući između:

- **`deviceOwnerAuthentication`**: zahteva Touch ID ili device passcode, i ne uspeva ako nijedno nije omogućeno.
- **`deviceOwnerAuthenticationWithBiometrics`**: isključivo zahteva Touch ID.

Uspešna autentikacija se označava boolean vrednošću koju vraća **`evaluatePolicy`**, što ukazuje na potencijalnu bezbednosnu slabost.

### Lokalna autentikacija korišćenjem keychain-a

Implementacija **local authentication** u iOS aplikacijama uključuje korišćenje **keychain APIs** za sigurno čuvanje tajnih podataka, kao što su authentication tokens. Ovaj proces obezbeđuje da podacima može pristupiti samo korisnik koristeći device passcode ili biometrijsku autentikaciju poput Touch ID.

Keychain omogućava postavljanje stavki sa atributom `SecAccessControl`, koji ograničava pristup stavci dok korisnik ne izvrši uspešnu autentikaciju preko Touch ID ili device passcode. Ova funkcionalnost je ključna za unapređenje bezbednosti.

Ispod su primeri koda u Swift i Objective-C koji pokazuju kako sačuvati i preuzeti string u/iz keychain-a, koristeći ove bezbednosne funkcije. Primeri posebno prikazuju kako podesiti access control da zahteva Touch ID autentikaciju i osigurati da podaci budu dostupni samo na uređaju na kojem su postavljeni, pod uslovom da je device passcode konfigurisana.

{{#tabs}}
{{#tab name="Swift"}}
```swift
// From https://github.com/mufambisi/owasp-mstg/blob/master/Document/0x06f-Testing-Local-Authentication.md

// 1. create AccessControl object that will represent authentication settings

var error: Unmanaged<CFError>?

guard let accessControl = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
SecAccessControlCreateFlags.biometryCurrentSet,
&error) else {
// failed to create AccessControl object

return
}

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute

var query: [String: Any] = [:]

query[kSecClass as String] = kSecClassGenericPassword
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecAttrAccount as String] = "OWASP Account" as CFString
query[kSecValueData as String] = "test_strong_password".data(using: .utf8)! as CFData
query[kSecAttrAccessControl as String] = accessControl

// 3. save item

let status = SecItemAdd(query as CFDictionary, nil)

if status == noErr {
// successfully saved
} else {
// error while saving
}
```
{{#endtab}}

{{#tab name="Objective-C"}}
```objectivec
// 1. create AccessControl object that will represent authentication settings
CFErrorRef *err = nil;

SecAccessControlRef sacRef = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
kSecAccessControlUserPresence,
err);

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute
NSDictionary* query = @{
(_ _bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecAttrAccount: @"OWASP Account",
(__bridge id)kSecValueData: [@"test_strong_password" dataUsingEncoding:NSUTF8StringEncoding],
(__bridge id)kSecAttrAccessControl: (__bridge_transfer id)sacRef
};

// 3. save item
OSStatus status = SecItemAdd((__bridge CFDictionaryRef)query, nil);

if (status == noErr) {
// successfully saved
} else {
// error while saving
}
```
{{#endtab}}
{{#endtabs}}

Sada možemo zatražiti sačuvanu stavku iz keychain-a. Keychain services će prikazati dijalog za autentifikaciju korisniku i vratiti podatke ili nil, u zavisnosti od toga da li je obezbeđen odgovarajući otisak prsta ili ne.

{{#tabs}}
{{#tab name="Swift"}}
```swift
// 1. define query
var query = [String: Any]()
query[kSecClass as String] = kSecClassGenericPassword
query[kSecReturnData as String] = kCFBooleanTrue
query[kSecAttrAccount as String] = "My Name" as CFString
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecUseOperationPrompt as String] = "Please, pass authorisation to enter this area" as CFString

// 2. get item
var queryResult: AnyObject?
let status = withUnsafeMutablePointer(to: &queryResult) {
SecItemCopyMatching(query as CFDictionary, UnsafeMutablePointer($0))
}

if status == noErr {
let password = String(data: queryResult as! Data, encoding: .utf8)!
// successfully received password
} else {
// authorization not passed
}
```
{{#endtab}}

{{#tab name="Objective-C"}}
```objectivec
// 1. define query
NSDictionary *query = @{(__bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecReturnData: @YES,
(__bridge id)kSecAttrAccount: @"My Name1",
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecUseOperationPrompt: @"Please, pass authorisation to enter this area" };

// 2. get item
CFTypeRef queryResult = NULL;
OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)query, &queryResult);

if (status == noErr){
NSData* resultData = ( __bridge_transfer NSData* )queryResult;
NSString* password = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding];
NSLog(@"%@", password);
} else {
NSLog(@"Something went wrong");
}
```
{{#endtab}}
{{#endtabs}}

### Detekcija

Upotreba framework-a u aplikaciji takođe se može otkriti analizom liste deljenih dinamičkih biblioteka binarnog fajla aplikacije. To se može uraditi korišćenjem `otool`:
```bash
$ otool -L <AppName>.app/<AppName>
```
Ako se `LocalAuthentication.framework` koristi u aplikaciji, izlaz će sadržavati obe sledeće linije (imajte na umu da `LocalAuthentication.framework` koristi `Security.framework` u pozadini):
```bash
/System/Library/Frameworks/LocalAuthentication.framework/LocalAuthentication
/System/Library/Frameworks/Security.framework/Security
```
Ako se koristi `Security.framework`, biće prikazan samo drugi.

### Zaobilaženje LocalAuthentication Framework-a

#### **Objection**

Putem **Objection Biometrics Bypass**, dostupnog na [this GitHub page](https://github.com/sensepost/objection/wiki/Understanding-the-iOS-Biometrics-Bypass), dostupna je tehnika za zaobilaženje **LocalAuthentication** mehanizma. Suština pristupa podrazumeva korišćenje **Frida** za manipulaciju funkcijom `evaluatePolicy`, osiguravajući da ona dosledno vraća `True` rezultat, bez obzira na stvarni uspeh autentifikacije. Ovo je posebno korisno za zaobilaženje neispravnih procesa biometrijske autentifikacije.

Za aktiviranje ovog bypass-a koristi se sledeća komanda:
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios ui biometrics_bypass
(agent) Registering job 3mhtws9x47q. Type: ios-biometrics-disable
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # (agent) [3mhtws9x47q] Localized Reason for auth requirement: Please authenticate yourself
(agent) [3mhtws9x47q] OS authentication response: false
(agent) [3mhtws9x47q] Marking OS response as True instead
(agent) [3mhtws9x47q] Biometrics bypass hook complete
```
Ova komanda pokreće sekvencu u kojoj Objection registruje zadatak koji efektivno menja ishod provere `evaluatePolicy` na `True`.

#### Frida

Primer upotrebe **`evaluatePolicy`** iz [DVIA-v2 application](https://github.com/prateek147/DVIA-v2):
```swift
+(void)authenticateWithTouchID {
LAContext *myContext = [[LAContext alloc] init];
NSError *authError = nil;
NSString *myLocalizedReasonString = @"Please authenticate yourself";

if ([myContext canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&authError]) {
[myContext evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics
localizedReason:myLocalizedReasonString
reply:^(BOOL success, NSError *error) {
if (success) {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Successful" withTitle:@"Success"];
});
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Failed !" withTitle:@"Error"];
});
}
}];
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Your device doesn't support Touch ID or you haven't configured Touch ID authentication on your device" withTitle:@"Error"];
});
}
}
```
Da bi se postigao **bypass** Local Authentication, napisana je Frida skripta. Ova skripta cilja **evaluatePolicy** proveru, presrećući njen callback kako bi osigurao da vraća **success=1**. Izmenom ponašanja callback-a, provera autentifikacije se efikasno zaobilazi.

Skripta ispod se injektuje da bi izmenila rezultat **evaluatePolicy** metode. Ona menja rezultat callback-a tako da uvek označava uspeh.
```swift
// from https://securitycafe.ro/2022/09/05/mobile-pentesting-101-bypassing-biometric-authentication/
if(ObjC.available) {
console.log("Injecting...");
var hook = ObjC.classes.LAContext["- evaluatePolicy:localizedReason:reply:"];
Interceptor.attach(hook.implementation, {
onEnter: function(args) {
var block = new ObjC.Block(args[4]);
const callback = block.implementation;
block.implementation = function (error, value)  {

console.log("Changing the result value to true")
const result = callback(1, null);
return result;
};
},
});
} else {
console.log("Objective-C Runtime is not available!");
}
```
Da biste injektovali Frida script i zaobišli biometric authentication, koristi se sledeća komanda:
```bash
frida -U -f com.highaltitudehacks.DVIAswiftv2 --no-pause -l fingerprint-bypass-ios.js
```
## Izlaganje osetljivih funkcionalnosti putem IPC

### Prilagođeni URI handleri / Deeplinks / Custom Schemes


{{#ref}}
ios-custom-uri-handlers-deeplinks-custom-schemes.md
{{#endref}}

### Universal Links


{{#ref}}
ios-universal-links.md
{{#endref}}

### UIActivity Sharing


{{#ref}}
ios-uiactivity-sharing.md
{{#endref}}

### UIPasteboard


{{#ref}}
ios-uipasteboard.md
{{#endref}}

### App Extensions


{{#ref}}
ios-app-extensions.md
{{#endref}}

### WebViews


{{#ref}}
ios-webviews.md
{{#endref}}

### Serijalizacija i kodiranje


{{#ref}}
ios-serialisation-and-encoding.md
{{#endref}}

## Mrežna komunikacija

Važno je proveriti da li nijedna komunikacija ne odvija **bez enkripcije** i takođe da aplikacija ispravno **validira TLS sertifikat** servera.\
Za proveru ovakvih problema možete koristiti proxy kao što je **Burp**:


{{#ref}}
burp-configuration-for-ios.md
{{#endref}}

### Provera imena hosta

Jedan čest problem pri validaciji TLS sertifikata je proveriti da je sertifikat potpisao **pouzdani** **CA**, ali **ne proveriti** da li je **ime hosta** u sertifikatu isto kao ime hosta kojem se pristupa.\
Da biste proverili ovaj problem koristeći Burp, nakon što poverite Burp CA na iPhone-u, možete **napraviti novi sertifikat sa Burp-om za drugačije ime hosta** i koristiti ga. Ako aplikacija i dalje radi, onda je ranjiva.

### Certificate Pinning

Ako aplikacija ispravno koristi SSL Pinning, aplikacija će raditi samo ako je sertifikat onaj koji se očekuje. Prilikom testiranja aplikacije **ovo može predstavljati problem jer Burp posluje svoj sertifikat.**\
Da biste zaobišli ovu zaštitu na jailbroken uređaju, možete instalirati aplikaciju [**SSL Kill Switch**](https://github.com/nabla-c0d3/ssl-kill-switch2) ili instalirati [**Burp Mobile Assistant**](https://portswigger.net/burp/documentation/desktop/mobile/config-ios-device)

Takođe možete koristiti **objection's** `ios sslpinning disable`

## Ostalo

- U **`/System/Library`** možete pronaći framework-e instalirane na telefonu koje koriste sistemske aplikacije
- Aplikacije koje je korisnik instalirao iz App Store nalaze se u **`/User/Applications`**
- A **`/User/Library`** sadrži podatke koje čuvaju aplikacije na nivou korisnika
- Možete pristupiti **`/User/Library/Notes/notes.sqlite`** da biste pročitali beleške sačuvane u aplikaciji.
- Unutar foldera instalirane aplikacije (**`/User/Applications/<APP ID>/`**) možete naći neke interesantne fajlove:
- **`iTunesArtwork`**: ikona koju koristi aplikacija
- **`iTunesMetadata.plist`**: informacije o aplikaciji koje se koriste u App Store-u
- **`/Library/*`**: sadrži preference i cache. U **`/Library/Cache/Snapshots/*`** možete naći snapshot napravljen aplikaciji pre slanja u background.

### Hot Patching / Prisilno ažuriranje

Programeri mogu na daljinu **patchovati sve instalacije svoje aplikacije trenutno** bez ponovnog slanja aplikacije u App Store i čekanja odobrenja.\
Za ovu svrhu obično se koristi [**JSPatch**](https://github.com/bang590/JSPatch). Ali postoje i druge opcije kao što su [Siren](https://github.com/ArtSabintsev/Siren) i [react-native-appstore-version-checker](https://www.npmjs.com/package/react-native-appstore-version-checker).\
**Ovo je opasan mehanizam koji bi mogao biti zloupotrebljen od strane zlonamernih third party SDK-ova, stoga se preporučuje proveriti koji metod se koristi za automatsko ažuriranje (ako postoji) i testirati ga.** Možete pokušati da preuzmete prethodnu verziju aplikacije u tu svrhu.

### Third Parties

Značajan izazov sa **3rd party SDKs** je **nedostatak granularne kontrole** nad njihovim funkcionalnostima. Programeri se suočavaju sa izborom: ili integrišu SDK i prihvate sve njegove funkcije, uključujući potencijalne sigurnosne ranjivosti i probleme privatnosti, ili potpuno odustanu od njegovih prednosti. Često programeri nisu u mogućnosti da sami isprave ranjivosti unutar tih SDK-ova. Štaviše, kako SDK-ovi stiču poverenje u zajednici, neki mogu početi da sadrže malware.

Usluge koje pružaju third-party SDK-ovi mogu uključivati praćenje ponašanja korisnika, prikazivanje reklama ili poboljšanja korisničkog iskustva. Međutim, to uvodi rizik jer programeri možda nisu u potpunosti svesni koda koji se izvršava iz tih biblioteka, što može dovesti do potencijalnih rizika za privatnost i bezbednost. Ključno je ograničiti informacije deljene sa third-party servisima na ono što je neophodno i osigurati da se ne otkrivaju osetljivi podaci.

Implementacija third-party servisa obično dolazi u dva oblika: standalone biblioteka ili potpuni SDK. Kako biste zaštitili privatnost korisnika, svi podaci deljeni sa ovim servisima treba da budu **anonimizovani** kako bi se sprečilo otkrivanje lično identifikovanih podataka (PII).

Da biste identifikovali biblioteke koje aplikacija koristi, može se iskoristiti komanda **`otool`**. Ovaj alat treba pokrenuti protiv aplikacije i svake deljene biblioteke koju koristi kako bi se otkrile dodatne biblioteke.
```bash
otool -L <application_path>
```
## Zanimljive ranjivosti i studije slučaja


{{#ref}}
air-keyboard-remote-input-injection.md
{{#endref}}

{{#ref}}
itunesstored-bookassetd-sandbox-escape.md
{{#endref}}

## **Reference i dodatni resursi**

- [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering)
- [iOS & Mobile App Pentesting - INE](https://my.ine.com/CyberSecurity/courses/089d060b/ios-mobile-app-pentesting)
- [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/)
- [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/)
- [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/)
- [https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage](https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage)
- [https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way](https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053)
- [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060)
- [https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/](https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064](https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064)
- [https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc](https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc)
- [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054)
- [https://github.com/ivRodriguezCA/RE-iOS-Apps/](https://github.com/ivRodriguezCA/RE-iOS-Apps/) IOS besplatan kurs([https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/](https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/))
- [https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577](https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577)
- [https://www.slideshare.net/RyanISI/ios-appsecurityminicourse](https://www.slideshare.net/RyanISI/ios-appsecurityminicourse)
- [https://github.com/prateek147/DVIA](https://github.com/prateek147/DVIA)
- [https://github.com/prateek147/DVIA-v2](https://github.com/prateek147/DVIA-v2)
- [https://github.com/OWASP/MSTG-Hacking-Playground%20](https://github.com/OWASP/MSTG-Hacking-Playground)
- OWASP iGoat [_https://github.com/OWASP/igoat_](https://github.com/OWASP/igoat) <<< Objective-C verzija [_https://github.com/OWASP/iGoat-Swift_](https://github.com/OWASP/iGoat-Swift) <<< Swift verzija
- [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
- [https://github.com/nabla-c0d3/ssl-kill-switch2](https://github.com/nabla-c0d3/ssl-kill-switch2)


{{#include ../../banners/hacktricks-training.md}}
