# iOS Custom URI Handlers / Deeplinks / Custom Schemes

{{#include ../../banners/hacktricks-training.md}}

## Basic Information

कस्टम URL स्कीम ऐप्स को एक कस्टम प्रोटोकॉल का उपयोग करके संवाद करने की अनुमति देती हैं, जैसा कि [Apple Developer Documentation](https://developer.apple.com/library/content/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Inter-AppCommunication/Inter-AppCommunication.html#//apple_ref/doc/uid/TP40007072-CH6-SW1) में विस्तृत किया गया है। इन स्कीमों को ऐप द्वारा घोषित किया जाना चाहिए, जो फिर उन स्कीमों के अनुसार आने वाले URLs को संभालता है। सभी URL पैरामीटर को **मान्य करना** और **कोई भी गलत URLs को अस्वीकार करना** महत्वपूर्ण है ताकि इस वेक्टर के माध्यम से हमलों को रोका जा सके।

एक उदाहरण दिया गया है जहाँ URI `myapp://hostname?data=123876123` एक विशिष्ट एप्लिकेशन क्रिया को सक्रिय करता है। एक ज्ञात भेद्यता Skype Mobile ऐप में थी, जिसने `skype://` प्रोटोकॉल के माध्यम से अनधिकृत कॉल क्रियाओं की अनुमति दी। पंजीकृत स्कीम ऐप के `Info.plist` में `CFBundleURLTypes` के तहत पाई जा सकती हैं। दुर्भावनापूर्ण ऐप्स इसको संवेदनशील जानकारी को इंटरसेप्ट करने के लिए URIs को फिर से पंजीकृत करके शोषण कर सकते हैं।

### Application Query Schemes Registration

iOS 9.0 से, यह जांचने के लिए कि क्या एक ऐप उपलब्ध है, `canOpenURL:` को `Info.plist` में `LSApplicationQueriesSchemes` के तहत URL स्कीमों की घोषणा करने की आवश्यकता होती है। यह एक ऐप द्वारा क्वेरी की जा सकने वाली स्कीमों को 50 तक सीमित करता है, जिससे ऐप एन्यूमरेशन को रोककर गोपनीयता बढ़ती है।
```xml
<key>LSApplicationQueriesSchemes</key>
<array>
<string>url_scheme1</string>
<string>url_scheme2</string>
</array>
```
### URL हैंडलिंग और मान्यता का परीक्षण

डेवलपर्स को URL पथ निर्माण और मान्यता को समझने के लिए स्रोत कोड में विशिष्ट विधियों का निरीक्षण करना चाहिए, जैसे `application:didFinishLaunchingWithOptions:` और `application:openURL:options:`। उदाहरण के लिए, Telegram URLs खोलने के लिए विभिन्न विधियों का उपयोग करता है:
```swift
func application(_ application: UIApplication, open url: URL, sourceApplication: String?) -> Bool {
self.openUrl(url: url)
return true
}

func application(_ application: UIApplication, open url: URL, sourceApplication: String?,
annotation: Any) -> Bool {
self.openUrl(url: url)
return true
}

func application(_ app: UIApplication, open url: URL,
options: [UIApplicationOpenURLOptionsKey : Any] = [:]) -> Bool {
self.openUrl(url: url)
return true
}

func application(_ application: UIApplication, handleOpen url: URL) -> Bool {
self.openUrl(url: url)
return true
}
```
### अन्य ऐप्स के लिए URL अनुरोधों का परीक्षण

`openURL:options:completionHandler:` जैसे तरीके अन्य ऐप्स के साथ बातचीत करने के लिए URL खोलने के लिए महत्वपूर्ण हैं। ऐप के स्रोत कोड में ऐसे तरीकों का उपयोग पहचानना बाहरी संचार को समझने के लिए कुंजी है।

### अप्रचलित तरीकों के लिए परीक्षण

URL खोलने को संभालने वाले अप्रचलित तरीके, जैसे `application:handleOpenURL:` और `openURL:`, की पहचान की जानी चाहिए और सुरक्षा निहितार्थों के लिए समीक्षा की जानी चाहिए।

### URL स्कीमों का फज़िंग

URL स्कीमों का फज़िंग मेमोरी भ्रष्टाचार बग की पहचान कर सकता है। [Frida](https://codeshare.frida.re/@dki/ios-url-scheme-fuzzing/) जैसे उपकरण इस प्रक्रिया को स्वचालित कर सकते हैं, विभिन्न पेलोड के साथ URL खोलकर क्रैश की निगरानी करने के लिए, जिसे iGoat-Swift ऐप में URL के हेरफेर द्वारा उदाहरणित किया गया है:
```bash
$ frida -U SpringBoard -l ios-url-scheme-fuzzing.js
[iPhone::SpringBoard]-> fuzz("iGoat", "iGoat://?contactNumber={0}&message={0}")
Watching for crashes from iGoat...
No logs were moved.
Opened URL: iGoat://?contactNumber=0&message=0
```
## कस्टम URL स्कीम हाइजैकिंग

According to [**this post**](https://evanconnelly.github.io/post/ios-oauth/), malicious apps could **register other apps custom schemes,** then the malicious app can open a browser that has all the cookies of the Safari App with [ASWebAuthenticationSession](https://developer.apple.com/documentation/authenticationservices/aswebauthenticationsession/2990952-init#parameters).&#x20;

With the broser the malicious app can load an attackers controlled web page and TCC will ask the mobile user for permissions to open that app. Then, the malicious webpage could redirect to a victim page, for example an OAuth flow with the parameter `prompt=none`. If the user was already logged in the OAuth flow, the OAuth flow will send the secret back to the victim application using the custom scheme of the victim app.\
However, because the malicious app also registered it and because the used browser is inside the malicious app, the custom scheme will be handled in this case by the malicious app which will be able to steal the OAuth token.

## संदर्भ

- [https://mas.owasp.org/MASTG/tests/ios/MASVS-PLATFORM/MASTG-TEST-0075/](https://mas.owasp.org/MASTG/tests/ios/MASVS-PLATFORM/MASTG-TEST-0075/)
- [https://evanconnelly.github.io/post/ios-oauth/](https://evanconnelly.github.io/post/ios-oauth/)

{{#include ../../banners/hacktricks-training.md}}
