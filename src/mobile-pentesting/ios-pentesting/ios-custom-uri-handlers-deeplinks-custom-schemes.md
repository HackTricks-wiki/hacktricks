# iOS Özel URI İşleyicileri / Derin Bağlantılar / Özel Şemalar

{{#include ../../banners/hacktricks-training.md}}

## Temel Bilgiler

Özel URL şemaları, uygulamaların özel bir protokol kullanarak iletişim kurmasını sağlar; bu, [Apple Geliştirici Dokümantasyonu](https://developer.apple.com/library/content/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Inter-AppCommunication/Inter-AppCommunication.html#//apple_ref/doc/uid/TP40007072-CH6-SW1) içinde detaylandırılmıştır. Bu şemalar, uygulama tarafından beyan edilmeli ve ardından bu şemalara uygun gelen URL'ler işlenmelidir. **Tüm URL parametrelerini doğrulamak** ve **herhangi bir hatalı URL'yi atmak** bu vektör üzerinden saldırıları önlemek için kritik öneme sahiptir.

`myapp://hostname?data=123876123` URI'sinin belirli bir uygulama eylemini tetiklediği bir örnek verilmiştir. Skype Mobil uygulamasında, `skype://` protokolü aracılığıyla izinsiz arama eylemlerine izin veren bir güvenlik açığı tespit edilmiştir. Kayıtlı şemalar, uygulamanın `Info.plist` dosyasında `CFBundleURLTypes` altında bulunabilir. Kötü niyetli uygulamalar, hassas bilgileri ele geçirmek için URI'leri yeniden kaydederek bunu istismar edebilir.

### Uygulama Sorgu Şemaları Kaydı

iOS 9.0'dan itibaren, bir uygulamanın mevcut olup olmadığını kontrol etmek için `canOpenURL:` kullanıldığında, URL şemalarının `Info.plist` dosyasında `LSApplicationQueriesSchemes` altında beyan edilmesi gerekmektedir. Bu, bir uygulamanın sorgulayabileceği şemaları 50 ile sınırlayarak uygulama sayımını önleyerek gizliliği artırır.
```xml
<key>LSApplicationQueriesSchemes</key>
<array>
<string>url_scheme1</string>
<string>url_scheme2</string>
</array>
```
### URL İşleme ve Doğrulama Testi

Geliştiriciler, URL yol yapısını ve doğrulamasını anlamak için kaynak kodundaki belirli yöntemleri incelemelidir, örneğin `application:didFinishLaunchingWithOptions:` ve `application:openURL:options:`. Örneğin, Telegram, URL'leri açmak için çeşitli yöntemler kullanır:
```swift
func application(_ application: UIApplication, open url: URL, sourceApplication: String?) -> Bool {
self.openUrl(url: url)
return true
}

func application(_ application: UIApplication, open url: URL, sourceApplication: String?,
annotation: Any) -> Bool {
self.openUrl(url: url)
return true
}

func application(_ app: UIApplication, open url: URL,
options: [UIApplicationOpenURLOptionsKey : Any] = [:]) -> Bool {
self.openUrl(url: url)
return true
}

func application(_ application: UIApplication, handleOpen url: URL) -> Bool {
self.openUrl(url: url)
return true
}
```
### Diğer Uygulamalara URL İsteklerini Test Etme

`openURL:options:completionHandler:` gibi yöntemler, diğer uygulamalarla etkileşimde bulunmak için URL'leri açmak açısından kritik öneme sahiptir. Uygulamanın kaynak kodunda bu tür yöntemlerin kullanımını belirlemek, dış iletişimleri anlamak için anahtardır.

### Kullanımdan Kaldırılmış Yöntemleri Test Etme

`application:handleOpenURL:` ve `openURL:` gibi URL açma işlemlerini yöneten kullanımdan kaldırılmış yöntemler, güvenlik etkileri açısından belirlenmeli ve gözden geçirilmelidir.

### URL Şemalarını Fuzzing

URL şemalarını fuzzing yapmak, bellek bozulması hatalarını belirleyebilir. [Frida](https://codeshare.frida.re/@dki/ios-url-scheme-fuzzing/) gibi araçlar, çökme durumlarını izlemek için farklı yüklerle URL'leri açarak bu süreci otomatikleştirebilir; bu, iGoat-Swift uygulamasındaki URL'lerin manipülasyonu ile örneklendirilmiştir:
```bash
$ frida -U SpringBoard -l ios-url-scheme-fuzzing.js
[iPhone::SpringBoard]-> fuzz("iGoat", "iGoat://?contactNumber={0}&message={0}")
Watching for crashes from iGoat...
No logs were moved.
Opened URL: iGoat://?contactNumber=0&message=0
```
## Özel URL şeması kaçırma

[**bu gönderiye**](https://evanconnelly.github.io/post/ios-oauth/) göre, kötü niyetli uygulamalar **diğer uygulamaların özel şemalarını kaydedebilir,** ardından kötü niyetli uygulama, [ASWebAuthenticationSession](https://developer.apple.com/documentation/authenticationservices/aswebauthenticationsession/2990952-init#parameters) ile Safari Uygulamasının tüm çerezlerine sahip bir tarayıcı açabilir.

Kötü niyetli uygulama, tarayıcı ile bir saldırganın kontrolündeki web sayfasını yükleyebilir ve TCC, mobil kullanıcıdan o uygulamayı açmak için izin isteyecektir. Ardından, kötü niyetli web sayfası bir kurban sayfasına yönlendirebilir, örneğin `prompt=none` parametresi ile bir OAuth akışı. Kullanıcı zaten OAuth akışında oturum açmışsa, OAuth akışı gizli anahtarı kurban uygulamasına, kurban uygulamasının özel şemasını kullanarak geri gönderecektir.\
Ancak, kötü niyetli uygulama bunu da kaydettiği için ve kullanılan tarayıcı kötü niyetli uygulamanın içinde olduğu için, bu durumda özel şema kötü niyetli uygulama tarafından işlenecek ve OAuth jetonunu çalma yeteneğine sahip olacaktır.

## Referanslar

- [https://mas.owasp.org/MASTG/tests/ios/MASVS-PLATFORM/MASTG-TEST-0075/](https://mas.owasp.org/MASTG/tests/ios/MASVS-PLATFORM/MASTG-TEST-0075/)
- [https://evanconnelly.github.io/post/ios-oauth/](https://evanconnelly.github.io/post/ios-oauth/)

{{#include ../../banners/hacktricks-training.md}}
