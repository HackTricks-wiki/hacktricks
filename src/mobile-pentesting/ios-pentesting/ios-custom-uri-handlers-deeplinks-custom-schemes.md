# iOS Pasgemaakte URI Hanteerders / Deeplinks / Pasgemaakte Skemas

{{#include ../../banners/hacktricks-training.md}}

## Basiese Inligting

Pasgemaakte URL skemas stel toepassings in staat om te kommunikeer met 'n pasgemaakte protokol, soos in die [Apple Developer Documentation](https://developer.apple.com/library/content/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Inter-AppCommunication/Inter-AppCommunication.html#//apple_ref/doc/uid/TP40007072-CH6-SW1) uiteengesit. Hierdie skemas moet deur die toepassing verklaar word, wat dan inkomende URL's volgens daardie skemas hanteer. Dit is van kardinale belang om **alle URL parameters te valideer** en **enige verkeerd gevormde URL's te verwerp** om aanvalle deur hierdie vektor te voorkom.

'n Voorbeeld word gegee waar die URI `myapp://hostname?data=123876123` 'n spesifieke toepassingsaksie aanroep. 'n Genoemde kwesbaarheid was in die Skype Mobile toepassing, wat ongereguleerde oproepaksies via die `skype://` protokol toegelaat het. Die geregistreerde skemas kan in die toepassing se `Info.plist` onder `CFBundleURLTypes` gevind word. Kwaadwillige toepassings kan dit benut deur URI's weer te registreer om sensitiewe inligting te onderskep.

### Toepassing Vraag Skemas Registrasie

Vanaf iOS 9.0, om te kontroleer of 'n toepassing beskikbaar is, vereis `canOpenURL:` dat URL skemas in die `Info.plist` onder `LSApplicationQueriesSchemes` verklaar word. Dit beperk die skemas wat 'n toepassing kan vra tot 50, wat privaatheid verbeter deur toepassingse enumerasie te voorkom.
```xml
<key>LSApplicationQueriesSchemes</key>
<array>
<string>url_scheme1</string>
<string>url_scheme2</string>
</array>
```
### Toetsing van URL Hantering en Validasie

Ontwikkelaars moet spesifieke metodes in die bronkode ondersoek om URL padkonstruksie en validasie te verstaan, soos `application:didFinishLaunchingWithOptions:` en `application:openURL:options:`. Byvoorbeeld, Telegram gebruik verskeie metodes om URL's te open:
```swift
func application(_ application: UIApplication, open url: URL, sourceApplication: String?) -> Bool {
self.openUrl(url: url)
return true
}

func application(_ application: UIApplication, open url: URL, sourceApplication: String?,
annotation: Any) -> Bool {
self.openUrl(url: url)
return true
}

func application(_ app: UIApplication, open url: URL,
options: [UIApplicationOpenURLOptionsKey : Any] = [:]) -> Bool {
self.openUrl(url: url)
return true
}

func application(_ application: UIApplication, handleOpen url: URL) -> Bool {
self.openUrl(url: url)
return true
}
```
### Toetsing van URL-versoeke na Ander Programme

Metodes soos `openURL:options:completionHandler:` is noodsaaklik om URL's te open om met ander programme te kommunikeer. Die identifisering van die gebruik van sulke metodes in die app se bronkode is sleutels tot die begrip van eksterne kommunikasie.

### Toetsing vir Verouderde Metodes

Verouderde metodes wat URL-opening hanteer, soos `application:handleOpenURL:` en `openURL:`, moet geïdentifiseer en hersien word vir sekuriteitsimplikasies.

### Fuzzing URL Skemas

Fuzzing URL skemas kan geheuekorruptie foute identifiseer. Gereedskap soos [Frida](https://codeshare.frida.re/@dki/ios-url-scheme-fuzzing/) kan hierdie proses outomatiseer deur URL's met verskillende payloads te open om vir crashes te monitor, soos geïllustreer deur die manipulasie van URL's in die iGoat-Swift app:
```bash
$ frida -U SpringBoard -l ios-url-scheme-fuzzing.js
[iPhone::SpringBoard]-> fuzz("iGoat", "iGoat://?contactNumber={0}&message={0}")
Watching for crashes from iGoat...
No logs were moved.
Opened URL: iGoat://?contactNumber=0&message=0
```
## Aangepaste URL-skema-hijacking

Volgens [**hierdie pos**](https://evanconnelly.github.io/post/ios-oauth/) kan kwaadwillige toepassings **ander toepassings se aangepaste skemas registreer,** dan kan die kwaadwillige toepassing 'n blaaier oopmaak wat al die koekies van die Safari-toepassing het met [ASWebAuthenticationSession](https://developer.apple.com/documentation/authenticationservices/aswebauthenticationsession/2990952-init#parameters).&#x20;

Met die blaaiers kan die kwaadwillige toepassing 'n webblad wat deur 'n aanvaller beheer word, laai en TCC sal die mobiele gebruiker vra om toestemming te gee om daardie toepassing oop te maak. Dan kan die kwaadwillige webblad na 'n slagofferbladsy herlei, byvoorbeeld 'n OAuth-stroom met die parameter `prompt=none`. As die gebruiker reeds ingelog was in die OAuth-stroom, sal die OAuth-stroom die geheim terugstuur na die slagoffer-toepassing met behulp van die aangepaste skema van die slagoffer-toepassing.\
E however, omdat die kwaadwillige toepassing dit ook geregistreer het en omdat die gebruikte blaaiers binne die kwaadwillige toepassing is, sal die aangepaste skema in hierdie geval hanteer word deur die kwaadwillige toepassing wat in staat sal wees om die OAuth-token te steel.

## Verwysings

- [https://mas.owasp.org/MASTG/tests/ios/MASVS-PLATFORM/MASTG-TEST-0075/](https://mas.owasp.org/MASTG/tests/ios/MASVS-PLATFORM/MASTG-TEST-0075/)
- [https://evanconnelly.github.io/post/ios-oauth/](https://evanconnelly.github.io/post/ios-oauth/)

{{#include ../../banners/hacktricks-training.md}}
