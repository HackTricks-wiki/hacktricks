# Xamarin Aplikacje

{{#include ../banners/hacktricks-training.md}}

## **Podstawowe informacje**

Xamarin to **otwarto-źródłowa platforma** zaprojektowana dla deweloperów do **tworzenia aplikacji dla iOS, Android i Windows** przy użyciu frameworków .NET i C#. Ta platforma daje dostęp do licznych narzędzi i rozszerzeń, umożliwiając efektywne tworzenie nowoczesnych aplikacji.

### Architektura Xamarin

- Dla **Androida**, Xamarin integruje się z przestrzeniami nazw Android i Java za pomocą .NET bindings, działając w środowisku wykonawczym Mono obok Android Runtime (ART). Managed Callable Wrappers (MCW) i Android Callable Wrappers (ACW) ułatwiają komunikację między Mono a ART, które oba są zbudowane na jądrze Linux.
- Dla **iOS**, aplikacje uruchamiane są w runtime Mono, wykorzystując pełną kompilację Ahead of Time (AOT) do konwersji kodu C# .NET na kod asemblera ARM. Ten proces działa obok Objective-C Runtime na jądrze typu UNIX.

### .NET Runtime i Mono Framework

Framework **.NET** zawiera pliki assembly, klasy i przestrzenie nazw do tworzenia aplikacji, a .NET Runtime zarządza wykonaniem kodu. Zapewnia niezależność od platformy i kompatybilność wsteczną. **Mono Framework** jest otwarto-źródłową wersją .NET, rozpoczętą w 2005 roku, aby rozszerzyć .NET na Linux; obecnie jest wspierana przez Microsoft i prowadzona przez Xamarin.

### Reverse Engineering Xamarin Apps

#### Decompilation of Xamarin Assemblies

Decompilation przekształca skompilowany kod z powrotem w kod źródłowy. W Windows, okno Modules w Visual Studio może identyfikować moduły do dekompilacji, umożliwiając bezpośredni dostęp do kodu stron trzecich i ekstrakcję kodu źródłowego do analizy.

#### JIT vs AOT Compilation

- **Android** obsługuje Just-In-Time (JIT) i Ahead-Of-Time (AOT) kompilację, z trybem Hybrid AOT dla optymalnej szybkości wykonywania. Pełny AOT jest dostępny wyłącznie dla licencji Enterprise.
- **iOS** używa wyłącznie AOT kompilacji z powodu ograniczeń Apple dotyczących dynamicznego wykonywania kodu.

### Wyodrębnianie plików dll z APK/IPA

Aby uzyskać dostęp do assemblies w APK/IPA, rozpakuj plik i przejrzyj katalog assemblies. Dla Androida narzędzia takie jak [XamAsmUnZ](https://github.com/cihansol/XamAsmUnZ) i [xamarin-decompress](https://github.com/NickstaDB/xamarin-decompress) mogą rozpakować pliki dll.
```bash
python3 xamarin-decompress.py -o /path/to/decompressed/apk
```
W przypadkach, gdy po dekompilacji APK można zobaczyć folder unknown/assemblies/ ze znajdującymi się w nim plikami `.dll`, można użyć [**dnSpy**](https://github.com/dnSpy/dnSpy) bezpośrednio na tych `.dlls` do ich analizy. Jednak czasami pliki `assemblies.blob` i `assemblies.manifest` znajdują się w folderze unknown/assemblies/. Narzędzie [pyxamstore](https://github.com/jakev/pyxamstore) potrafi rozpakować plik `assemblies.blob` w Xamarin apps, umożliwiając dostęp do .NET assemblies w celu dalszej analizy:
```bash
pyxamstore unpack -d /path/to/decompressed/apk/assemblies/
# After patching DLLs, rebuild the store
pyxamstore pack
```
Niektóre nowsze buildy Xamarin/MAUI przechowują skompresowane assemblies w formacie **XALZ** wewnątrz `/assemblies.blob` lub `/resources/assemblies`. Można je szybko zdekompresować za pomocą biblioteki [xamarout](https://pypi.org/project/xamarout/):
```python
from xamarout import xalz
import os
for root, _, files in os.walk("."):
for f in files:
if open(os.path.join(root, f), 'rb').read(4) == b"XALZ":
xa = xalz.XamarinCompressedAssembly(os.path.join(root, f))
xa.write("decompressed/" + f)
```
Pliki .dll z iOS są łatwo dostępne do dekompilacji, ujawniając znaczące części kodu aplikacji, który często dzieli wspólną bazę między różnymi platformami.

> **AOT on iOS**: managed IL jest kompilowany do natywnych plików `*.aotdata.*`. Patchowanie samego DLL nie zmieni logiki; trzeba hook native stubs (np. z użyciem Frida), ponieważ ciała IL są pustymi placeholderami.

### Analiza statyczna

Po uzyskaniu plików `.dll` możliwe jest statyczne przeanalizowanie kodu .Net za pomocą narzędzi takich jak [**dnSpy**](https://github.com/dnSpy/dnSpy) lub [**ILSpy**](https://github.com/icsharpcode/ILSpy), które pozwalają modyfikować kod aplikacji. Może to być bardzo przydatne do manipulowania aplikacją w celu obejścia zabezpieczeń, na przykład.\
Zwróć uwagę, że po zmodyfikowaniu aplikacji będziesz musiał ją ponownie spakować i ponownie podpisać.

> dnSpy jest zarchiwizowany; utrzymywane forki takie jak **dnSpyEx** nadal działają z .NET 8/MAUI assemblies i zachowują symbole debugowania przy ponownym zapisie.

### Analiza dynamiczna

Analiza dynamiczna obejmuje sprawdzanie pod kątem SSL pinning oraz używanie narzędzi takich jak [Fridax](https://github.com/NorthwaveSecurity/fridax) do modyfikacji binarki .NET w czasie wykonywania w aplikacjach Xamarin. Skrypty Frida są dostępne do obejścia root detection lub SSL pinning, zwiększając możliwości analizy.

Other interesting Frida scripts:

- [**xamarin-antiroot**](https://codeshare.frida.re/@Gand3lf/xamarin-antiroot/)
- [**xamarin-root-detect-bypass**](https://codeshare.frida.re/@nuschpl/xamarin-root-detect-bypass/)
- [**Frida-xamarin-unpin**](https://github.com/GoSecure/frida-xamarin-unpin)

Updated **Frida-xamarin-unpin** (Mono >=6) hooks `System.Net.Http.HttpClient.SendAsync` and swaps the handler to a permissive one, so it still works even when pinning is implemented in custom handlers. Run it after the app starts:
```bash
frida -U -l dist/xamarin-unpin.js com.target.app --no-pause
```
Szybki szablon do hookowania managed methods z dołączonym `frida-mono-api`:
```javascript
const mono = require('frida-mono-api');
Mono.ensureInitialized();
Mono.enumerateLoadedImages().forEach(i => console.log(i.name));
const klass = Mono.classFromName("Namespace", "Class");
const m = Mono.methodFromName(klass, "Method", 2);
Mono.intercept(m, { onEnter(args){ console.log(args[1].toInt32()); } });
```
### Ponowne podpisywanie

Narzędzie [Uber APK Signer](https://github.com/patrickfav/uber-apk-signer) upraszcza podpisywanie wielu plików APK tym samym kluczem i może być użyte do ponownego podpisania aplikacji po wprowadzeniu w niej zmian.

## Źródła

- [https://www.appknox.com/security/xamarin-reverse-engineering-a-guide-for-penetration-testers](https://www.appknox.com/security/xamarin-reverse-engineering-a-guide-for-penetration-testers)
- [https://thecobraden.com/posts/unpacking_xamarin_assembly_stores/](https://thecobraden.com/posts/unpacking_xamarin_assembly_stores/)
- [https://medium.com/@justmobilesec/introduction-to-the-exploitation-of-xamarin-apps-fde4619a51bf](https://medium.com/@justmobilesec/introduction-to-the-exploitation-of-xamarin-apps-fde4619a51bf)
- [https://github.com/jakev/pyxamstore](https://github.com/jakev/pyxamstore)
- [https://pypi.org/project/xamarout/](https://pypi.org/project/xamarout/)
- [https://github.com/GoSecure/frida-xamarin-unpin](https://github.com/GoSecure/frida-xamarin-unpin)
- [https://gist.github.com/Diefunction/e26fce039efcab57aac342a4b2d48ff6](https://gist.github.com/Diefunction/e26fce039efcab57aac342a4b2d48ff6)
- [https://reverseengineering.stackexchange.com/questions/31716/deobfuscating-ios-dll-file-i-think-arm64](https://reverseengineering.stackexchange.com/questions/31716/deobfuscating-ios-dll-file-i-think-arm64)

{{#include ../banners/hacktricks-training.md}}
