# Xamarin Apps

{{#include ../banners/hacktricks-training.md}}

## **Información básica**

Xamarin es una **plataforma de código abierto** diseñada para que los desarrolladores **construyan aplicaciones para iOS, Android y Windows** usando los frameworks .NET y C#. Esta plataforma ofrece acceso a numerosas herramientas y extensiones para crear aplicaciones modernas de forma eficiente.

### Arquitectura de Xamarin

- Para **Android**, Xamarin se integra con los namespaces de Android y Java a través de los bindings de .NET, funcionando dentro del entorno de ejecución Mono junto al Android Runtime (ART). Managed Callable Wrappers (MCW) y Android Callable Wrappers (ACW) facilitan la comunicación entre Mono y ART, ambos basados en el kernel de Linux.
- Para **iOS**, las aplicaciones se ejecutan bajo el runtime de Mono, utilizando compilación Ahead of Time (AOT) completa para convertir el código C# .NET en lenguaje ensamblador ARM. Este proceso corre junto al Objective-C Runtime sobre un kernel similar a UNIX.

### .NET Runtime y Mono Framework

El **framework .NET** incluye assemblies, clases y namespaces para el desarrollo de aplicaciones, con el .NET Runtime gestionando la ejecución del código. Ofrece independencia de plataforma y compatibilidad hacia atrás. El **Mono Framework** es una versión de código abierto del framework .NET, iniciada en 2005 para extender .NET a Linux, ahora soportada por Microsoft y liderada por Xamarin.

### Reverse Engineering Xamarin Apps

#### Decompilation of Xamarin Assemblies

Decompilation transforma el código compilado de vuelta a código fuente. En Windows, la ventana Modules en Visual Studio puede identificar módulos para decompilar, permitiendo acceso directo al código de terceros y la extracción del código fuente para su análisis.

#### JIT vs AOT Compilation

- **Android** soporta compilación Just-In-Time (JIT) y Ahead-Of-Time (AOT), con un modo Hybrid AOT para velocidad de ejecución óptima. Full AOT es exclusivo de licencias Enterprise.
- **iOS** emplea únicamente compilación AOT debido a las restricciones de Apple sobre la ejecución dinámica de código.

### Extracción de archivos dll desde APK/IPA

Para acceder a los assemblies en un APK/IPA, descomprime el archivo y explora el directorio assemblies. Para Android, herramientas como [XamAsmUnZ](https://github.com/cihansol/XamAsmUnZ) y [xamarin-decompress](https://github.com/NickstaDB/xamarin-decompress) pueden descomprimir archivos dll.
```bash
python3 xamarin-decompress.py -o /path/to/decompressed/apk
```
En casos en los que, después de descompilar el APK, es posible ver la carpeta unknown/assemblies/ con los archivos `.dll` dentro, es posible usar [**dnSpy**](https://github.com/dnSpy/dnSpy) directamente sobre los `.dlls` para analizarlos. Sin embargo, a veces los archivos `assemblies.blob` y `assemblies.manifest` están dentro de la carpeta unknown/assemblies/. La herramienta [pyxamstore](https://github.com/jakev/pyxamstore) puede desempaquetar el archivo `assemblies.blob` en apps Xamarin, permitiendo el acceso a los ensamblados .NET para un análisis más profundo:
```bash
pyxamstore unpack -d /path/to/decompressed/apk/assemblies/
# After patching DLLs, rebuild the store
pyxamstore pack
```
Algunas compilaciones recientes de Xamarin/MAUI almacenan assemblies comprimidos usando el formato **XALZ** dentro de `/assemblies.blob` o `/resources/assemblies`. Puedes descomprimirlos rápidamente con la librería [xamarout](https://pypi.org/project/xamarout/):
```python
from xamarout import xalz
import os
for root, _, files in os.walk("."):
for f in files:
if open(os.path.join(root, f), 'rb').read(4) == b"XALZ":
xa = xalz.XamarinCompressedAssembly(os.path.join(root, f))
xa.write("decompressed/" + f)
```
Los iOS dll files son fácilmente accesibles para decompilación, revelando porciones significativas del código de la aplicación, que a menudo comparte una base común entre distintas plataformas.

> **AOT on iOS**: managed IL se compila en archivos nativos `*.aotdata.*`. Parchear el DLL por sí solo no cambiará la lógica; necesitas hook native stubs (e.g., with Frida) porque los IL bodies son marcadores vacíos.

### Análisis Estático

Una vez obtenidos los `.dll`s es posible analizar el código .Net estáticamente usando herramientas como [**dnSpy**](https://github.com/dnSpy/dnSpy) o [**ILSpy**](https://github.com/icsharpcode/ILSpy) que permiten modificar el código de la app. Esto puede ser muy útil para manipular la aplicación y, por ejemplo, eludir protecciones.\ Ten en cuenta que tras modificar la app necesitarás empaquetarla de nuevo y volver a firmarla.

> dnSpy está archivado; forks mantenidos como **dnSpyEx** siguen funcionando con ensamblados .NET 8/MAUI y preservan los símbolos de depuración al re-guardar.

### Análisis Dinámico

El análisis dinámico implica comprobar SSL pinning y usar herramientas como [Fridax](https://github.com/NorthwaveSecurity/fridax) para modificaciones en tiempo de ejecución del binario .NET en aplicaciones Xamarin. Hay Frida scripts disponibles para bypass root detection o SSL pinning, lo que mejora las capacidades de análisis.

Other interesting Frida scripts:

- [**xamarin-antiroot**](https://codeshare.frida.re/@Gand3lf/xamarin-antiroot/)
- [**xamarin-root-detect-bypass**](https://codeshare.frida.re/@nuschpl/xamarin-root-detect-bypass/)
- [**Frida-xamarin-unpin**](https://github.com/GoSecure/frida-xamarin-unpin)

Updated **Frida-xamarin-unpin** (Mono >=6) hooks `System.Net.Http.HttpClient.SendAsync` and swaps the handler to a permissive one, so it still works even when pinning is implemented in custom handlers. Ejecutarlo después de que la app arranque:
```bash
frida -U -l dist/xamarin-unpin.js com.target.app --no-pause
```
Plantilla rápida para hookear métodos gestionados con el `frida-mono-api` incluido:
```javascript
const mono = require('frida-mono-api');
Mono.ensureInitialized();
Mono.enumerateLoadedImages().forEach(i => console.log(i.name));
const klass = Mono.classFromName("Namespace", "Class");
const m = Mono.methodFromName(klass, "Method", 2);
Mono.intercept(m, { onEnter(args){ console.log(args[1].toInt32()); } });
```
### Volver a firmar

La herramienta [Uber APK Signer](https://github.com/patrickfav/uber-apk-signer) simplifica la firma de múltiples APKs con la misma clave, y puede usarse para volver a firmar una aplicación después de que se le hayan realizado cambios.

## Referencias

- [https://www.appknox.com/security/xamarin-reverse-engineering-a-guide-for-penetration-testers](https://www.appknox.com/security/xamarin-reverse-engineering-a-guide-for-penetration-testers)
- [https://thecobraden.com/posts/unpacking_xamarin_assembly_stores/](https://thecobraden.com/posts/unpacking_xamarin_assembly_stores/)
- [https://medium.com/@justmobilesec/introduction-to-the-exploitation-of-xamarin-apps-fde4619a51bf](https://medium.com/@justmobilesec/introduction-to-the-exploitation-of-xamarin-apps-fde4619a51bf)
- [https://github.com/jakev/pyxamstore](https://github.com/jakev/pyxamstore)
- [https://pypi.org/project/xamarout/](https://pypi.org/project/xamarout/)
- [https://github.com/GoSecure/frida-xamarin-unpin](https://github.com/GoSecure/frida-xamarin-unpin)
- [https://gist.github.com/Diefunction/e26fce039efcab57aac342a4b2d48ff6](https://gist.github.com/Diefunction/e26fce039efcab57aac342a4b2d48ff6)
- [https://reverseengineering.stackexchange.com/questions/31716/deobfuscating-ios-dll-file-i-think-arm64](https://reverseengineering.stackexchange.com/questions/31716/deobfuscating-ios-dll-file-i-think-arm64)

{{#include ../banners/hacktricks-training.md}}
