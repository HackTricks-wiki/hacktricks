# Xamarin Apps

{{#include ../banners/hacktricks-training.md}}

## **बुनियादी जानकारी**

Xamarin एक **ओपन-सोर्स प्लेटफ़ॉर्म** है जो डेवलपर्स को .NET और C# फ्रेमवर्क का उपयोग करके **iOS, Android, और Windows के लिए एप्स बनाने** के लिए डिज़ाइन किया गया है। यह प्लेटफ़ॉर्म आधुनिक एप्लिकेशन कुशलता से बनाने के लिए अनेक tools और extensions तक पहुँच प्रदान करता है।

### Xamarin की वास्तुकला

- For **Android**, Xamarin .NET bindings के माध्यम से Android और Java namespaces के साथ इंटीग्रेट होता है, और Mono execution environment में Android Runtime (ART) के साथ चलता है। Managed Callable Wrappers (MCW) और Android Callable Wrappers (ACW) Mono और ART के बीच संचार की सुविधा देते हैं, दोनों Linux kernel पर आधारित हैं।
- For **iOS**, applications Mono runtime के अंतर्गत चलते हैं, और पूर्ण Ahead of Time (AOT) compilation का उपयोग करके C# .NET कोड को ARM assembly language में बदलते हैं। यह प्रक्रिया Objective-C Runtime के साथ एक UNIX-like kernel पर चलती है।

### .NET Runtime and Mono Framework

The **.NET framework** एप्लिकेशन डेवलपमेंट के लिए assemblies, classes, और namespaces प्रदान करता है, और .NET Runtime कोड निष्पादन का प्रबंधन करता है। यह प्लेटफ़ॉर्म स्वतंत्रता और backward compatibility प्रदान करता है। The **Mono Framework** .NET framework का एक ओपन-सोर्स संस्करण है, जिसे 2005 में .NET को Linux तक विस्तारित करने के लिए शुरू किया गया था, और अब Microsoft द्वारा समर्थित तथा Xamarin द्वारा नेतृत्वित है।

### Reverse Engineering Xamarin Apps

#### Decompilation of Xamarin Assemblies

Decompilation संकलित कोड को वापस स्रोत कोड में बदलता है। Windows में, Visual Studio का Modules window decompilation के लिए modules की पहचान कर सकता है, जिससे third-party code तक सीधे पहुँच और विश्लेषण के लिए source code का extraction संभव होता है।

#### JIT vs AOT Compilation

- **Android** Just-In-Time (JIT) और Ahead-Of-Time (AOT) compilation को समर्थन करता है, और optimal execution speed के लिए Hybrid AOT mode भी मौजूद है। Full AOT केवल Enterprise licenses के लिए उपलब्ध है।
- **iOS** केवल AOT compilation का उपयोग करता है क्योंकि Apple के dynamic code execution पर प्रतिबंध हैं।

### APK/IPA से dll फ़ाइलें निकालना

APK/IPA में assemblies तक पहुँचने के लिए, फाइल को unzip करें और assemblies directory को खोजें। Android के लिए, [XamAsmUnZ](https://github.com/cihansol/XamAsmUnZ) और [xamarin-decompress](https://github.com/NickstaDB/xamarin-decompress) जैसे tools dll फाइलों को uncompress कर सकते हैं।
```bash
python3 xamarin-decompress.py -o /path/to/decompressed/apk
```
ऐसे मामलों में जहाँ APK को decompile करने के बाद unknown/assemblies/ फ़ोल्डर और उसके अंदर `.dll` फ़ाइलें दिखाई देती हैं, आप सीधे `.dlls` पर [**dnSpy**](https://github.com/dnSpy/dnSpy) का उपयोग करके उन्हें analyze कर सकते हैं। हालांकि, कभी-कभी `assemblies.blob` और `assemblies.manifest` फाइलें unknown/assemblies/ फ़ोल्डर के अंदर होती हैं। टूल [pyxamstore](https://github.com/jakev/pyxamstore) Xamarin apps में `assemblies.blob` फ़ाइल को unpack कर सकता है, जिससे आगे के विश्लेषण के लिए .NET assemblies तक पहुँच प्राप्त होती है:
```bash
pyxamstore unpack -d /path/to/decompressed/apk/assemblies/
# After patching DLLs, rebuild the store
pyxamstore pack
```
कुछ हालिया Xamarin/MAUI बिल्ड्स संकुचित assemblies को **XALZ** फ़ॉर्मेट में `/assemblies.blob` या `/resources/assemblies` के अंदर स्टोर करते हैं। आप उन्हें [xamarout](https://pypi.org/project/xamarout/) लाइब्रेरी के साथ जल्दी से डिकम्प्रेस कर सकते हैं:
```python
from xamarout import xalz
import os
for root, _, files in os.walk("."):
for f in files:
if open(os.path.join(root, f), 'rb').read(4) == b"XALZ":
xa = xalz.XamarinCompressedAssembly(os.path.join(root, f))
xa.write("decompressed/" + f)
```
iOS dll फाइलें decompilation के लिए आसानी से उपलब्ध होती हैं, और एप्लिकेशन कोड के महत्वपूर्ण हिस्सों को उजागर करती हैं, जो अक्सर विभिन्न प्लेटफ़ॉर्म्स में एक सामान्य बेस साझा करते हैं।

> **AOT on iOS**: managed IL is compiled into native `*.aotdata.*` files. Patching the DLL alone will not change logic; you need to hook native stubs (e.g., with Frida) because the IL bodies are empty placeholders.

### Static Analysis

एक बार जब `.dll`s प्राप्त हो जाते हैं तो .Net कोड को statically analyze करना संभव होता है, उदाहरण के लिए [**dnSpy**](https://github.com/dnSpy/dnSpy) या [**ILSpy**](https://github.com/icsharpcode/ILSpy) जैसे tools का उपयोग करके, जो ऐप के कोड को modify करने की अनुमति देते हैं। यह protections को bypass करने के लिए ऐप को tamper करने में बहुत काम आता है।\
ध्यान रखें कि ऐप में बदलाव करने के बाद आपको इसे फिर से pack करके sign करना होगा।

> dnSpy is archived; maintained forks like **dnSpyEx** keep working with .NET 8/MAUI assemblies and preserve debug symbols when re-saving.

### Dynamic Analysis

Dynamic analysis में SSL pinning की जाँच करना और Xamarin apps में .NET binary के runtime modifications के लिए [Fridax](https://github.com/NorthwaveSecurity/fridax) जैसे tools का उपयोग शामिल है। Frida scripts root detection या SSL pinning को bypass करने के लिए उपलब्ध हैं, जिससे analysis की क्षमताएँ बढ़ती हैं।

Other interesting Frida scripts:

- [**xamarin-antiroot**](https://codeshare.frida.re/@Gand3lf/xamarin-antiroot/)
- [**xamarin-root-detect-bypass**](https://codeshare.frida.re/@nuschpl/xamarin-root-detect-bypass/)
- [**Frida-xamarin-unpin**](https://github.com/GoSecure/frida-xamarin-unpin)

Updated **Frida-xamarin-unpin** (Mono >=6) hooks `System.Net.Http.HttpClient.SendAsync` and swaps the handler to a permissive one, so it still works even when pinning is implemented in custom handlers. Run it after the app starts:
```bash
frida -U -l dist/xamarin-unpin.js com.target.app --no-pause
```
बंडल किए गए `frida-mono-api` के साथ managed methods को hook करने के लिए त्वरित टेम्पलेट:
```javascript
const mono = require('frida-mono-api');
Mono.ensureInitialized();
Mono.enumerateLoadedImages().forEach(i => console.log(i.name));
const klass = Mono.classFromName("Namespace", "Class");
const m = Mono.methodFromName(klass, "Method", 2);
Mono.intercept(m, { onEnter(args){ console.log(args[1].toInt32()); } });
```
### री-साइन करना

टूल [Uber APK Signer](https://github.com/patrickfav/uber-apk-signer) एक ही key से कई APKs को साइन करना सरल बनाता है, और किसी ऐप में बदलाव करने के बाद उसे री-साइन करने के लिए इस्तेमाल किया जा सकता है।

## संदर्भ

- [https://www.appknox.com/security/xamarin-reverse-engineering-a-guide-for-penetration-testers](https://www.appknox.com/security/xamarin-reverse-engineering-a-guide-for-penetration-testers)
- [https://thecobraden.com/posts/unpacking_xamarin_assembly_stores/](https://thecobraden.com/posts/unpacking_xamarin_assembly_stores/)
- [https://medium.com/@justmobilesec/introduction-to-the-exploitation-of-xamarin-apps-fde4619a51bf](https://medium.com/@justmobilesec/introduction-to-the-exploitation-of-xamarin-apps-fde4619a51bf)
- [https://github.com/jakev/pyxamstore](https://github.com/jakev/pyxamstore)
- [https://pypi.org/project/xamarout/](https://pypi.org/project/xamarout/)
- [https://github.com/GoSecure/frida-xamarin-unpin](https://github.com/GoSecure/frida-xamarin-unpin)
- [https://gist.github.com/Diefunction/e26fce039efcab57aac342a4b2d48ff6](https://gist.github.com/Diefunction/e26fce039efcab57aac342a4b2d48ff6)
- [https://reverseengineering.stackexchange.com/questions/31716/deobfuscating-ios-dll-file-i-think-arm64](https://reverseengineering.stackexchange.com/questions/31716/deobfuscating-ios-dll-file-i-think-arm64)

{{#include ../banners/hacktricks-training.md}}
