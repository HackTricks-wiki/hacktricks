# Applications Xamarin

{{#include ../banners/hacktricks-training.md}}

## **Informations de base**

Xamarin est une **plate-forme open-source** conçue pour permettre aux développeurs de **créer des applications pour iOS, Android et Windows** en utilisant les frameworks .NET et C#. Cette plate-forme offre l'accès à de nombreux outils et extensions pour développer des applications modernes de manière efficace.

### Architecture de Xamarin

- Pour **Android**, Xamarin s'intègre aux namespaces Android et Java via des bindings .NET, fonctionnant dans l'environnement d'exécution Mono aux côtés de l'Android Runtime (ART). Les Managed Callable Wrappers (MCW) et Android Callable Wrappers (ACW) facilitent la communication entre Mono et ART, qui reposent tous deux sur le kernel Linux.
- Pour **iOS**, les applications s'exécutent sous le runtime Mono, utilisant une compilation Ahead of Time (AOT) complète pour convertir le code C# .NET en assembleur ARM. Ce processus s'exécute parallèlement à l'Objective-C Runtime sur un kernel de type UNIX.

### .NET Runtime et framework Mono

Le **framework .NET** inclut des assemblies, des classes et des namespaces pour le développement d'applications, le Runtime .NET gérant l'exécution du code. Il offre indépendance de plateforme et compatibilité ascendante. Le **framework Mono** est une version open-source du framework .NET, initiée en 2005 pour porter .NET sur Linux, désormais soutenue par Microsoft et dirigée par Xamarin.

### Rétro-ingénierie des Applications Xamarin

#### Décompilation des assemblies Xamarin

La décompilation transforme du code compilé en code source. Sous Windows, la fenêtre Modules de Visual Studio peut identifier les modules pour décompilation, permettant un accès direct au code tiers et l'extraction du code source pour analyse.

#### Compilation JIT vs AOT

- **Android** supporte la compilation Just-In-Time (JIT) et Ahead-Of-Time (AOT), avec un mode Hybrid AOT pour une vitesse d'exécution optimale. Le Full AOT est réservé aux licences Enterprise.
- **iOS** n'emploie que la compilation AOT en raison des restrictions d'Apple sur l'exécution dynamique de code.

### Extraction de fichiers dll depuis APK/IPA

Pour accéder aux assemblies dans un APK/IPA, décompressez le fichier et explorez le répertoire des assemblies. Pour Android, des outils comme [XamAsmUnZ](https://github.com/cihansol/XamAsmUnZ) et [xamarin-decompress](https://github.com/NickstaDB/xamarin-decompress) peuvent décompresser les fichiers dll.
```bash
python3 xamarin-decompress.py -o /path/to/decompressed/apk
```
Dans les cas où, après avoir décompilé l'APK, il est possible de voir le dossier unknown/assemblies/ contenant les fichiers `.dll`, il est possible d'utiliser [**dnSpy**](https://github.com/dnSpy/dnSpy) directement sur les `.dlls` pour les analyser. Cependant, parfois les fichiers `assemblies.blob` et `assemblies.manifest` se trouvent dans le dossier unknown/assemblies/. L'outil [pyxamstore](https://github.com/jakev/pyxamstore) peut décompresser le fichier `assemblies.blob` dans les apps Xamarin, permettant l'accès aux assemblies .NET pour une analyse plus approfondie :
```bash
pyxamstore unpack -d /path/to/decompressed/apk/assemblies/
# After patching DLLs, rebuild the store
pyxamstore pack
```
Certaines builds récentes Xamarin/MAUI stockent des assemblies compressés au format **XALZ** dans `/assemblies.blob` ou `/resources/assemblies`. Vous pouvez rapidement les décompresser avec la bibliothèque [xamarout](https://pypi.org/project/xamarout/):
```python
from xamarout import xalz
import os
for root, _, files in os.walk("."):
for f in files:
if open(os.path.join(root, f), 'rb').read(4) == b"XALZ":
xa = xalz.XamarinCompressedAssembly(os.path.join(root, f))
xa.write("decompressed/" + f)
```
iOS dll files are readily accessible for decompilation, revealing significant portions of the application code, which often shares a common base across different platforms.

> **AOT on iOS** : le managed IL est compilé en fichiers natifs `*.aotdata.*`. Le patching du DLL seul ne changera pas la logique ; il faut hooker les stubs natifs (par ex. avec Frida) car les corps IL sont des placeholders vides.

### Analyse statique

Une fois les `.dll` obtenues il est possible d'analyser statiquement le code .Net en utilisant des outils tels que [**dnSpy**](https://github.com/dnSpy/dnSpy) ou [**ILSpy**](https://github.com/icsharpcode/ILSpy) qui permettent de modifier le code de l'app. Cela peut être très utile pour altérer l'application afin de contourner des protections, par exemple.\
Notez qu'après modification de l'app vous devrez la repackager et la signer à nouveau.

> dnSpy est archivé ; des forks maintenus comme **dnSpyEx** continuent de fonctionner avec des assemblies .NET 8/MAUI et conservent les symboles de debug lors de la sauvegarde.

### Analyse dynamique

L'analyse dynamique consiste à vérifier la présence de SSL pinning et à utiliser des outils comme [Fridax](https://github.com/NorthwaveSecurity/fridax) pour modifier à l'exécution le binaire .NET dans les apps Xamarin. Des scripts Frida sont disponibles pour bypasser la détection de root ou le SSL pinning, améliorant les capacités d'analyse.

Other interesting Frida scripts:

- [**xamarin-antiroot**](https://codeshare.frida.re/@Gand3lf/xamarin-antiroot/)
- [**xamarin-root-detect-bypass**](https://codeshare.frida.re/@nuschpl/xamarin-root-detect-bypass/)
- [**Frida-xamarin-unpin**](https://github.com/GoSecure/frida-xamarin-unpin)

Updated **Frida-xamarin-unpin** (Mono >=6) hooks `System.Net.Http.HttpClient.SendAsync` and swaps the handler to a permissive one, so it still works even when pinning is implemented in custom handlers. Run it after the app starts:
```bash
frida -U -l dist/xamarin-unpin.js com.target.app --no-pause
```
Modèle rapide pour hooker des managed methods avec le `frida-mono-api` inclus :
```javascript
const mono = require('frida-mono-api');
Mono.ensureInitialized();
Mono.enumerateLoadedImages().forEach(i => console.log(i.name));
const klass = Mono.classFromName("Namespace", "Class");
const m = Mono.methodFromName(klass, "Method", 2);
Mono.intercept(m, { onEnter(args){ console.log(args[1].toInt32()); } });
```
### Ré-signature

L'outil [Uber APK Signer](https://github.com/patrickfav/uber-apk-signer) simplifie la signature de plusieurs APK avec la même clé et peut être utilisé pour ré-signer une application après lui avoir apporté des modifications.

## References

- [https://www.appknox.com/security/xamarin-reverse-engineering-a-guide-for-penetration-testers](https://www.appknox.com/security/xamarin-reverse-engineering-a-guide-for-penetration-testers)
- [https://thecobraden.com/posts/unpacking_xamarin_assembly_stores/](https://thecobraden.com/posts/unpacking_xamarin_assembly_stores/)
- [https://medium.com/@justmobilesec/introduction-to-the-exploitation-of-xamarin-apps-fde4619a51bf](https://medium.com/@justmobilesec/introduction-to-the-exploitation-of-xamarin-apps-fde4619a51bf)
- [https://github.com/jakev/pyxamstore](https://github.com/jakev/pyxamstore)
- [https://pypi.org/project/xamarout/](https://pypi.org/project/xamarout/)
- [https://github.com/GoSecure/frida-xamarin-unpin](https://github.com/GoSecure/frida-xamarin-unpin)
- [https://gist.github.com/Diefunction/e26fce039efcab57aac342a4b2d48ff6](https://gist.github.com/Diefunction/e26fce039efcab57aac342a4b2d48ff6)
- [https://reverseengineering.stackexchange.com/questions/31716/deobfuscating-ios-dll-file-i-think-arm64](https://reverseengineering.stackexchange.com/questions/31716/deobfuscating-ios-dll-file-i-think-arm64)

{{#include ../banners/hacktricks-training.md}}
