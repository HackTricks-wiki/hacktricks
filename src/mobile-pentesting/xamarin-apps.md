# Xamarin Apps

{{#include ../banners/hacktricks-training.md}}

## **Grundlegende Informationen**

Xamarin ist eine **Open-Source-Plattform**, die Entwicklern ermöglicht, **Apps für iOS, Android und Windows zu erstellen** unter Verwendung der .NET- und C#-Frameworks. Die Plattform bietet Zugang zu zahlreichen Tools und Erweiterungen, um moderne Anwendungen effizient zu entwickeln.

### Xamarin-Architektur

- Für **Android** integriert Xamarin Android- und Java-Namespaces über .NET-Bindings und läuft innerhalb der Mono-Ausführungsumgebung neben der Android Runtime (ART). Managed Callable Wrappers (MCW) und Android Callable Wrappers (ACW) ermöglichen die Kommunikation zwischen Mono und ART, die beide auf dem Linux-Kernel basieren.
- Für **iOS** laufen Anwendungen unter der Mono-Runtime und nutzen vollständige Ahead of Time (AOT)-Kompilierung, um C# .NET-Code in ARM-Assemblersprache zu konvertieren. Dieser Prozess läuft parallel zur Objective-C Runtime auf einem UNIX-ähnlichen Kernel.

### .NET Runtime und Mono Framework

Das **.NET framework** umfasst Assemblies, Klassen und Namespaces für die Anwendungsentwicklung, wobei die .NET Runtime die Codeausführung verwaltet. Es bietet Plattformunabhängigkeit und Abwärtskompatibilität. Das **Mono Framework** ist eine Open-Source-Version des .NET framework, initiiert 2005, um .NET auf Linux zu bringen; es wird inzwischen von Microsoft unterstützt und von Xamarin weitergeführt.

### Reverse Engineering Xamarin Apps

#### Decompilation of Xamarin Assemblies

Decompilation wandelt kompilierten Code zurück in Quellcode. Unter Windows kann das Modules window in Visual Studio Module zur Decompilation identifizieren, was direkten Zugriff auf Code von Drittanbietern ermöglicht und die Extraktion von Quellcode zur Analyse erlaubt.

#### JIT vs AOT Compilation

- **Android** unterstützt Just-In-Time (JIT) und Ahead-Of-Time (AOT)-Kompilierung, mit einem Hybrid AOT-Modus für optimale Ausführungsgeschwindigkeit. Full AOT ist Enterprise-Lizenzen vorbehalten.
- **iOS** verwendet ausschließlich AOT-Kompilierung aufgrund von Apples Beschränkungen für dynamische Codeausführung.

### Extrahieren von dll-Dateien aus APK/IPA

Um auf die Assemblies in einer APK/IPA zuzugreifen, entpacke die Datei und durchsuchen das assemblies-Verzeichnis. Für Android können Tools wie [XamAsmUnZ](https://github.com/cihansol/XamAsmUnZ) und [xamarin-decompress](https://github.com/NickstaDB/xamarin-decompress) dll-Dateien entpacken.
```bash
python3 xamarin-decompress.py -o /path/to/decompressed/apk
```
In Fällen, in denen man nach dem Decompilieren der APK den Ordner unknown/assemblies/ mit den `.dll`-Dateien darin sehen kann, ist es möglich, [**dnSpy**](https://github.com/dnSpy/dnSpy) direkt über die `.dlls` zu verwenden, um sie zu analysieren. Allerdings befinden sich manchmal die Dateien `assemblies.blob` und `assemblies.manifest` im Ordner unknown/assemblies/. Das Tool [pyxamstore](https://github.com/jakev/pyxamstore) kann die Datei `assemblies.blob` in Xamarin-Apps entpacken und so Zugriff auf die .NET-Assemblies für weitere Analysen ermöglichen:
```bash
pyxamstore unpack -d /path/to/decompressed/apk/assemblies/
# After patching DLLs, rebuild the store
pyxamstore pack
```
Einige neuere Xamarin/MAUI-Builds speichern komprimierte Assemblies im **XALZ**-Format in `/assemblies.blob` oder `/resources/assemblies`. Du kannst sie schnell mit der [xamarout](https://pypi.org/project/xamarout/) Bibliothek dekomprimieren:
```python
from xamarout import xalz
import os
for root, _, files in os.walk("."):
for f in files:
if open(os.path.join(root, f), 'rb').read(4) == b"XALZ":
xa = xalz.XamarinCompressedAssembly(os.path.join(root, f))
xa.write("decompressed/" + f)
```
iOS .dll files sind leicht für die Dekompilierung zugänglich und offenbaren große Teile des Anwendungscodes, der häufig eine gemeinsame Basis über verschiedene Plattformen hinweg teilt.

> **AOT on iOS**: managed IL is compiled into native `*.aotdata.*` files. Patching the DLL alone will not change logic; you need to hook native stubs (e.g., with Frida) because the IL bodies are empty placeholders.

### Statische Analyse

Sobald die `.dll`s vorliegen, ist es möglich, den .Net-Code statisch mit Tools wie [**dnSpy**](https://github.com/dnSpy/dnSpy) oder [**ILSpy**](https://github.com/icsharpcode/ILSpy) zu analysieren, die es erlauben, den Anwendungscode zu ändern. Das kann sehr nützlich sein, um die Anwendung zu manipulieren und beispielsweise Schutzmechanismen zu umgehen.\
Beachte, dass du die App nach der Modifikation wieder packen und neu signieren musst.

> dnSpy is archived; maintained forks like **dnSpyEx** keep working with .NET 8/MAUI assemblies and preserve debug symbols when re-saving.

### Dynamische Analyse

Dynamische Analyse umfasst das Überprüfen auf SSL pinning und die Nutzung von Tools wie [Fridax](https://github.com/NorthwaveSecurity/fridax) für Laufzeit-Modifikationen der .NET-Binärdatei in Xamarin-Apps. Frida-Skripte sind verfügbar, um root detection oder SSL pinning zu umgehen und erweitern so die Analysefähigkeiten.

Weitere interessante Frida-Skripte:

- [**xamarin-antiroot**](https://codeshare.frida.re/@Gand3lf/xamarin-antiroot/)
- [**xamarin-root-detect-bypass**](https://codeshare.frida.re/@nuschpl/xamarin-root-detect-bypass/)
- [**Frida-xamarin-unpin**](https://github.com/GoSecure/frida-xamarin-unpin)

Updated **Frida-xamarin-unpin** (Mono >=6) hooks `System.Net.Http.HttpClient.SendAsync` and swaps the handler to a permissive one, so it still works even when pinning is implemented in custom handlers. Führe es nach dem Start der App aus:
```bash
frida -U -l dist/xamarin-unpin.js com.target.app --no-pause
```
Schnelle Vorlage, um managed methods mit dem mitgelieferten `frida-mono-api` zu hooken:
```javascript
const mono = require('frida-mono-api');
Mono.ensureInitialized();
Mono.enumerateLoadedImages().forEach(i => console.log(i.name));
const klass = Mono.classFromName("Namespace", "Class");
const m = Mono.methodFromName(klass, "Method", 2);
Mono.intercept(m, { onEnter(args){ console.log(args[1].toInt32()); } });
```
### Erneutes Signieren

Das Tool [Uber APK Signer](https://github.com/patrickfav/uber-apk-signer) vereinfacht das Signieren mehrerer APKs mit demselben Schlüssel und kann verwendet werden, um eine App nach vorgenommenen Änderungen erneut zu signieren.

## Referenzen

- [https://www.appknox.com/security/xamarin-reverse-engineering-a-guide-for-penetration-testers](https://www.appknox.com/security/xamarin-reverse-engineering-a-guide-for-penetration-testers)
- [https://thecobraden.com/posts/unpacking_xamarin_assembly_stores/](https://thecobraden.com/posts/unpacking_xamarin_assembly_stores/)
- [https://medium.com/@justmobilesec/introduction-to-the-exploitation-of-xamarin-apps-fde4619a51bf](https://medium.com/@justmobilesec/introduction-to-the-exploitation-of-xamarin-apps-fde4619a51bf)
- [https://github.com/jakev/pyxamstore](https://github.com/jakev/pyxamstore)
- [https://pypi.org/project/xamarout/](https://pypi.org/project/xamarout/)
- [https://github.com/GoSecure/frida-xamarin-unpin](https://github.com/GoSecure/frida-xamarin-unpin)
- [https://gist.github.com/Diefunction/e26fce039efcab57aac342a4b2d48ff6](https://gist.github.com/Diefunction/e26fce039efcab57aac342a4b2d48ff6)
- [https://reverseengineering.stackexchange.com/questions/31716/deobfuscating-ios-dll-file-i-think-arm64](https://reverseengineering.stackexchange.com/questions/31716/deobfuscating-ios-dll-file-i-think-arm64)

{{#include ../banners/hacktricks-training.md}}
