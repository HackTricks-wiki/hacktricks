# Xamarin Apps

{{#include ../banners/hacktricks-training.md}}

## **Osnovne informacije**

Xamarin je **platforma otvorenog koda** namenjena developerima za **izgradnju aplikacija za iOS, Android i Windows** koristeći .NET i C# framework-e. Ova platforma pruža pristup brojnim alatima i ekstenzijama za efikasno kreiranje modernih aplikacija.

### Arhitektura Xamarin-a

- Za **Android**, Xamarin se integriše sa Android i Java namespace-ima preko .NET bindings-a, radeći u okviru Mono izvršnog okruženja zajedno sa Android Runtime-om (ART). Managed Callable Wrappers (MCW) i Android Callable Wrappers (ACW) omogućavaju komunikaciju između Mono i ART, koji su obojica izgrađeni na Linux kernelu.
- Za **iOS**, aplikacije se izvršavaju pod Mono runtime-om, koristeći punu Ahead of Time (AOT) kompilaciju da konvertuju C# .NET kod u ARM assembly jezik. Ovaj proces radi pored Objective-C Runtime-a na kernelu sličnom UNIX-u.

### .NET Runtime i Mono Framework

The **.NET framework** uključuje assemblies, classes i namespaces za razvoj aplikacija, pri čemu .NET Runtime upravlja izvršavanjem koda. Nudi nezavisnost od platforme i kompatibilnost unazad. The **Mono Framework** je verzija .NET framework-a otvorenog koda, započeta 2005. godine kako bi se .NET proširio na Linux, sada podržana od strane Microsoft-a i vođena od strane Xamarin-a.

### Reverse Engineering Xamarin Apps

#### Decompilation of Xamarin Assemblies

Decompilation pretvara kompajlirani kod nazad u izvorni kod. Na Windows-u, prozor Modules u Visual Studio-u može identifikovati module za dekompilaciju, omogućavajući direktan pristup kodu treće strane i ekstrakciju izvornog koda za analizu.

#### JIT vs AOT Compilation

- **Android** podržava Just-In-Time (JIT) i Ahead-Of-Time (AOT) kompilaciju, sa Hybrid AOT režimom za optimalnu brzinu izvršavanja. Full AOT je ekskluzivan za Enterprise licence.
- **iOS** isključivo koristi AOT kompilaciju zbog Apple-ovih ograničenja na dinamičko izvršavanje koda.

### Extracting dll Files from APK/IPA

Da biste pristupili assembly-ima u APK/IPA, raspakujte fajl i pregledajte direktorijum assemblies. Za Android, alati poput [XamAsmUnZ](https://github.com/cihansol/XamAsmUnZ) i [xamarin-decompress](https://github.com/NickstaDB/xamarin-decompress) mogu dekompresovati dll fajlove.
```bash
python3 xamarin-decompress.py -o /path/to/decompressed/apk
```
U slučajevima kada se nakon dekompajliranja APK-a može videti folder unknown/assemblies/ sa `.dll` fajlovima unutra, moguće je koristiti [**dnSpy**](https://github.com/dnSpy/dnSpy) direktno nad `.dlls` za analizu. Međutim, ponekad se fajlovi `assemblies.blob` i `assemblies.manifest` nalaze u folderu unknown/assemblies/. Alat [pyxamstore](https://github.com/jakev/pyxamstore) može raspakovati fajl `assemblies.blob` u Xamarin aplikacijama, omogućavajući pristup .NET assemblies za dalju analizu:
```bash
pyxamstore unpack -d /path/to/decompressed/apk/assemblies/
# After patching DLLs, rebuild the store
pyxamstore pack
```
Neki noviji Xamarin/MAUI buildovi čuvaju kompresovane assemblies koristeći **XALZ** format unutar `/assemblies.blob` ili `/resources/assemblies`. Možete ih brzo dekompresovati koristeći biblioteku [xamarout](https://pypi.org/project/xamarout/):
```python
from xamarout import xalz
import os
for root, _, files in os.walk("."):
for f in files:
if open(os.path.join(root, f), 'rb').read(4) == b"XALZ":
xa = xalz.XamarinCompressedAssembly(os.path.join(root, f))
xa.write("decompressed/" + f)
```
iOS dll fajlovi su lako dostupni za dekompilaciju, otkrivajući značajne delove koda aplikacije, koji često dele zajedničku bazu između različitih platformi.

> **AOT on iOS**: managed IL se kompajlira u native `*.aotdata.*` fajlove. Patchovanje samog DLL-a neće promeniti logiku; potrebno je hook-ovati native stubove (npr. sa Frida) jer su IL bodies prazni placeholderi.

### Statička analiza

Kad se `.dll` fajlovi dobiju, moguće je statički analizirati .Net kod koristeći alate kao što su [**dnSpy**](https://github.com/dnSpy/dnSpy) ili [**ILSpy**](https://github.com/icsharpcode/ILSpy) koji omogućavaju modifikovanje koda aplikacije. Ovo može biti veoma korisno za menjanje aplikacije radi zaobilaženja zaštita, na primer.\
Note that after modifying the app you will need to pack it back again and sign it again.

> dnSpy je arhiviran; održavani forkovi poput **dnSpyEx** nastavljaju da rade sa .NET 8/MAUI assemblies i čuvaju debug simbole pri ponovnom snimanju.

### Dinamička analiza

Dinamička analiza obuhvata proveru SSL pinning-a i korišćenje alata kao što je [Fridax](https://github.com/NorthwaveSecurity/fridax) za runtime modifikacije .NET binara u Xamarin aplikacijama. Frida skripte su dostupne za zaobilaženje root detection-a ili SSL pinning-a, što poboljšava mogućnosti analize.

Other interesting Frida scripts:

- [**xamarin-antiroot**](https://codeshare.frida.re/@Gand3lf/xamarin-antiroot/)
- [**xamarin-root-detect-bypass**](https://codeshare.frida.re/@nuschpl/xamarin-root-detect-bypass/)
- [**Frida-xamarin-unpin**](https://github.com/GoSecure/frida-xamarin-unpin)

Updated **Frida-xamarin-unpin** (Mono >=6) hooks `System.Net.Http.HttpClient.SendAsync` and swaps the handler to a permissive one, so it still works even when pinning is implemented in custom handlers. Run it after the app starts:
```bash
frida -U -l dist/xamarin-unpin.js com.target.app --no-pause
```
Kratak predložak za hook upravljanih metoda pomoću uključenog `frida-mono-api`:
```javascript
const mono = require('frida-mono-api');
Mono.ensureInitialized();
Mono.enumerateLoadedImages().forEach(i => console.log(i.name));
const klass = Mono.classFromName("Namespace", "Class");
const m = Mono.methodFromName(klass, "Method", 2);
Mono.intercept(m, { onEnter(args){ console.log(args[1].toInt32()); } });
```
### Ponovno potpisivanje

Alat [Uber APK Signer](https://github.com/patrickfav/uber-apk-signer) olakšava potpisivanje više APK-ova istim ključem i može se koristiti za ponovno potpisivanje aplikacije nakon što su na njoj izvršene izmene.

## Reference

- [https://www.appknox.com/security/xamarin-reverse-engineering-a-guide-for-penetration-testers](https://www.appknox.com/security/xamarin-reverse-engineering-a-guide-for-penetration-testers)
- [https://thecobraden.com/posts/unpacking_xamarin_assembly_stores/](https://thecobraden.com/posts/unpacking_xamarin_assembly_stores/)
- [https://medium.com/@justmobilesec/introduction-to-the-exploitation-of-xamarin-apps-fde4619a51bf](https://medium.com/@justmobilesec/introduction-to-the-exploitation-of-xamarin-apps-fde4619a51bf)
- [https://github.com/jakev/pyxamstore](https://github.com/jakev/pyxamstore)
- [https://pypi.org/project/xamarout/](https://pypi.org/project/xamarout/)
- [https://github.com/GoSecure/frida-xamarin-unpin](https://github.com/GoSecure/frida-xamarin-unpin)
- [https://gist.github.com/Diefunction/e26fce039efcab57aac342a4b2d48ff6](https://gist.github.com/Diefunction/e26fce039efcab57aac342a4b2d48ff6)
- [https://reverseengineering.stackexchange.com/questions/31716/deobfuscating-ios-dll-file-i-think-arm64](https://reverseengineering.stackexchange.com/questions/31716/deobfuscating-ios-dll-file-i-think-arm64)

{{#include ../banners/hacktricks-training.md}}
