# Xamarin 应用

{{#include ../banners/hacktricks-training.md}}

## **基本信息**

Xamarin 是一个面向开发者的 **开源平台**，用于通过 .NET 和 C# 框架 **为 iOS、Android 和 Windows 构建应用**。该平台提供大量工具和扩展，以高效地创建现代应用。

### Xamarin 的架构

- 对于 **Android**，Xamarin 通过 .NET 绑定与 Android 和 Java 命名空间集成，运行在 Mono 执行环境中并与 Android Runtime (ART) 并存。Managed Callable Wrappers (MCW) 和 Android Callable Wrappers (ACW) 促进 Mono 与 ART 之间的通信，两者均构建在 Linux 内核之上。
- 对于 **iOS**，应用程序在 Mono 运行时下运行，使用完整的 Ahead of Time (AOT) 编译将 C# .NET 代码转换为 ARM 汇编语言。该过程与 Objective-C Runtime 在类 UNIX 内核上并行运行。

### .NET Runtime 与 Mono Framework

**.NET framework** 包含用于应用开发的程序集、类和命名空间，由 .NET Runtime 管理代码执行。它提供平台无关性和向后兼容性。**Mono Framework** 是 .NET framework 的开源实现，始于 2005 年，旨在将 .NET 扩展到 Linux，目前由 Microsoft 支持并由 Xamarin 领导。

### 反向工程 Xamarin 应用

#### Xamarin 程序集的反编译

反编译将已编译的代码转换回源代码。在 Windows 上，Visual Studio 的 Modules 窗口可以识别用于反编译的模块，从而直接访问第三方代码并提取源代码以便分析。

#### JIT 与 AOT 编译

- **Android** 支持 Just-In-Time (JIT) 和 Ahead-Of-Time (AOT) 编译，并提供 Hybrid AOT 模式以获得最佳执行速度。完整的 AOT 仅限于 Enterprise 许可证。
- **iOS** 由于 Apple 对动态代码执行的限制，仅采用 AOT 编译。

### 从 APK/IPA 提取 dll 文件

要访问 APK/IPA 中的程序集，解压文件并浏览 assemblies 目录。对于 Android，像 [XamAsmUnZ](https://github.com/cihansol/XamAsmUnZ) 和 [xamarin-decompress](https://github.com/NickstaDB/xamarin-decompress) 这样的工具可以解压 dll 文件。
```bash
python3 xamarin-decompress.py -o /path/to/decompressed/apk
```
在某些情况下，在反编译 APK 之后，如果可以看到 unknown/assemblies/ 文件夹并且其中包含 `.dll` 文件，就可以直接使用 [**dnSpy**](https://github.com/dnSpy/dnSpy) 对这些 `.dlls` 进行分析。然而，有时 unknown/assemblies/ 文件夹中包含 `assemblies.blob` 和 `assemblies.manifest` 文件。工具 [pyxamstore](https://github.com/jakev/pyxamstore) 可以解包 Xamarin apps 中的 `assemblies.blob` 文件，从而访问 .NET assemblies 以便进一步分析：
```bash
pyxamstore unpack -d /path/to/decompressed/apk/assemblies/
# After patching DLLs, rebuild the store
pyxamstore pack
```
一些较新的 Xamarin/MAUI 构建会在 `/assemblies.blob` 或 `/resources/assemblies` 中使用 **XALZ** 格式存储压缩的 assemblies。你可以使用 [xamarout](https://pypi.org/project/xamarout/) 库快速解压它们：
```python
from xamarout import xalz
import os
for root, _, files in os.walk("."):
for f in files:
if open(os.path.join(root, f), 'rb').read(4) == b"XALZ":
xa = xalz.XamarinCompressedAssembly(os.path.join(root, f))
xa.write("decompressed/" + f)
```
iOS dll files are readily accessible for decompilation, revealing significant portions of the application code, which often shares a common base across different platforms.

> **AOT on iOS**: managed IL is compiled into native `*.aotdata.*` files. Patching the DLL alone will not change logic; you need to hook native stubs (e.g., with Frida) because the IL bodies are empty placeholders.

### 静态分析

一旦获得了 `.dll`，可以使用像 [**dnSpy**](https://github.com/dnSpy/dnSpy) 或 [**ILSpy**](https://github.com/icsharpcode/ILSpy) 这样的工具对 .NET 代码进行静态分析并修改应用代码。这对于篡改应用以绕过防护非常有用。  
注意：修改应用后需要重新打包并重新签名。

> dnSpy is archived; maintained forks like **dnSpyEx** keep working with .NET 8/MAUI assemblies and preserve debug symbols when re-saving.

### 动态分析

动态分析包括检查 SSL pinning，并使用像 [Fridax](https://github.com/NorthwaveSecurity/fridax) 这样的工具在 Xamarin 应用中对 .NET 二进制进行运行时修改。可用的 Frida 脚本可以绕过 root 检测或 SSL pinning，从而增强分析能力。

其他有趣的 Frida 脚本：

- [**xamarin-antiroot**](https://codeshare.frida.re/@Gand3lf/xamarin-antiroot/)
- [**xamarin-root-detect-bypass**](https://codeshare.frida.re/@nuschpl/xamarin-root-detect-bypass/)
- [**Frida-xamarin-unpin**](https://github.com/GoSecure/frida-xamarin-unpin)

更新的 **Frida-xamarin-unpin** (Mono >=6) hooks `System.Net.Http.HttpClient.SendAsync` 并交换 handler 为一个宽松的实现，因此即使 pinning 在自定义 handler 中实现也仍然有效。启动应用后运行它：
```bash
frida -U -l dist/xamarin-unpin.js com.target.app --no-pause
```
快速模板，用于使用随附的 `frida-mono-api` 钩取托管方法：
```javascript
const mono = require('frida-mono-api');
Mono.ensureInitialized();
Mono.enumerateLoadedImages().forEach(i => console.log(i.name));
const klass = Mono.classFromName("Namespace", "Class");
const m = Mono.methodFromName(klass, "Method", 2);
Mono.intercept(m, { onEnter(args){ console.log(args[1].toInt32()); } });
```
### 重签名

该工具 [Uber APK Signer](https://github.com/patrickfav/uber-apk-signer) 简化了使用相同密钥对多个 APKs 进行签名的过程，并可用于在对应用进行修改后对其重新签名。

## 参考

- [https://www.appknox.com/security/xamarin-reverse-engineering-a-guide-for-penetration-testers](https://www.appknox.com/security/xamarin-reverse-engineering-a-guide-for-penetration-testers)
- [https://thecobraden.com/posts/unpacking_xamarin_assembly_stores/](https://thecobraden.com/posts/unpacking_xamarin_assembly_stores/)
- [https://medium.com/@justmobilesec/introduction-to-the-exploitation-of-xamarin-apps-fde4619a51bf](https://medium.com/@justmobilesec/introduction-to-the-exploitation-of-xamarin-apps-fde4619a51bf)
- [https://github.com/jakev/pyxamstore](https://github.com/jakev/pyxamstore)
- [https://pypi.org/project/xamarout/](https://pypi.org/project/xamarout/)
- [https://github.com/GoSecure/frida-xamarin-unpin](https://github.com/GoSecure/frida-xamarin-unpin)
- [https://gist.github.com/Diefunction/e26fce039efcab57aac342a4b2d48ff6](https://gist.github.com/Diefunction/e26fce039efcab57aac342a4b2d48ff6)
- [https://reverseengineering.stackexchange.com/questions/31716/deobfuscating-ios-dll-file-i-think-arm64](https://reverseengineering.stackexchange.com/questions/31716/deobfuscating-ios-dll-file-i-think-arm64)

{{#include ../banners/hacktricks-training.md}}
