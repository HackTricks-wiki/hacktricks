# Aplicaciones Xamarin

{{#include ../banners/hacktricks-training.md}}

## **Información básica**

Xamarin es una **plataforma de código abierto** diseñada para que los desarrolladores **construyan apps para iOS, Android y Windows** usando los frameworks .NET y C#. Esta plataforma ofrece acceso a numerosas herramientas y extensiones para crear aplicaciones modernas de manera eficiente.

### Arquitectura de Xamarin

- Para **Android**, Xamarin se integra con los namespaces de Android y Java a través de bindings de .NET, operando dentro del entorno de ejecución de Mono junto al Android Runtime (ART). Managed Callable Wrappers (MCW) y Android Callable Wrappers (ACW) facilitan la comunicación entre Mono y ART, ambos construidos sobre el kernel de Linux.
- Para **iOS**, las aplicaciones se ejecutan bajo el runtime de Mono, utilizando compilación completa Ahead of Time (AOT) para convertir código C# .NET en ensamblador ARM. Este proceso corre junto al Objective-C Runtime sobre un kernel tipo UNIX.

### .NET Runtime y Mono Framework

El **framework .NET** incluye assemblies, clases y namespaces para el desarrollo de aplicaciones, con el .NET Runtime gestionando la ejecución del código. Ofrece independencia de plataforma y compatibilidad hacia atrás. El **Mono Framework** es una versión de código abierto del framework .NET, iniciada en 2005 para extender .NET a Linux, ahora soportada por Microsoft y liderada por Xamarin.

### Ingeniería inversa de apps Xamarin

#### Descompilación de ensamblados Xamarin

La descompilación transforma código compilado de nuevo en código fuente. En Windows, la ventana Modules en Visual Studio puede identificar módulos para descompilación, permitiendo el acceso directo a código de terceros y la extracción de código fuente para análisis.

#### Compilación JIT vs AOT

- **Android** soporta Just-In-Time (JIT) y Ahead-Of-Time (AOT) compilation, con un modo Hybrid AOT para velocidad de ejecución óptima. Full AOT es exclusivo de licencias Enterprise.
- **iOS** emplea únicamente compilación AOT debido a las restricciones de Apple sobre la ejecución dinámica de código.

### Extracción de archivos dll de APK/IPA

Para acceder a los assemblies en un APK/IPA, descomprime el archivo y explora el directorio de ensamblados. Para Android, herramientas como [XamAsmUnZ](https://github.com/cihansol/XamAsmUnZ) y [xamarin-decompress](https://github.com/NickstaDB/xamarin-decompress) pueden descomprimir archivos dll.
```bash
python3 xamarin-decompress.py -o /path/to/decompressed/apk
```
En los casos en los que, después de descompilar el APK, es posible ver la carpeta unknown/assemblies/ con los archivos `.dll` dentro, se puede usar [**dnSpy**](https://github.com/dnSpy/dnSpy) directamente sobre los `.dll` para analizarlos. Sin embargo, a veces los archivos `assemblies.blob` y `assemblies.manifest` están dentro de la carpeta unknown/assemblies/. La herramienta [pyxamstore](https://github.com/jakev/pyxamstore) puede desempaquetar el archivo `assemblies.blob` en aplicaciones Xamarin, permitiendo el acceso a los ensamblados .NET para un análisis posterior:
```bash
pyxamstore unpack -d /path/to/decompressed/apk/assemblies/
# After patching DLLs, rebuild the store
pyxamstore pack
```
Algunas compilaciones recientes de Xamarin/MAUI almacenan assemblies comprimidos usando el formato **XALZ** dentro de `/assemblies.blob` o `/resources/assemblies`. Puedes descomprimirlos rápidamente con la librería [xamarout](https://pypi.org/project/xamarout/):
```python
from xamarout import xalz
import os
for root, _, files in os.walk("."):
for f in files:
if open(os.path.join(root, f), 'rb').read(4) == b"XALZ":
xa = xalz.XamarinCompressedAssembly(os.path.join(root, f))
xa.write("decompressed/" + f)
```
Los archivos dll de iOS son fácilmente accesibles para su descompilación, revelando porciones significativas del código de la aplicación, que a menudo comparten una base común entre diferentes plataformas.

> **AOT en iOS**: managed IL se compila en archivos nativos `*.aotdata.*`. Parchear solo el DLL no cambiará la lógica; necesitas hook native stubs (e.g., with Frida) porque los IL bodies son marcadores vacíos.

### Análisis estático

Una vez obtenidos los `.dll` es posible analizar el código .Net de forma estática usando herramientas como [**dnSpy**](https://github.com/dnSpy/dnSpy) o [**ILSpy**](https://github.com/icsharpcode/ILSpy) que permitirán modificar el código de la app. Esto puede ser muy útil para manipular la aplicación y, por ejemplo, bypass protections.\
Ten en cuenta que después de modificar la app necesitarás empaquetarla de nuevo y volver a firmarla.

> dnSpy está archivado; forks mantenidos como **dnSpyEx** siguen funcionando con ensamblados .NET 8/MAUI y preservan los símbolos de depuración al volver a guardar.

### Análisis dinámico

El análisis dinámico implica comprobar SSL pinning y usar herramientas como [Fridax](https://github.com/NorthwaveSecurity/fridax) para modificaciones en tiempo de ejecución del binario .NET en apps Xamarin. Hay scripts de Frida disponibles para bypass root detection o SSL pinning, aumentando las capacidades de análisis.

Other interesting Frida scripts:

- [**xamarin-antiroot**](https://codeshare.frida.re/@Gand3lf/xamarin-antiroot/)
- [**xamarin-root-detect-bypass**](https://codeshare.frida.re/@nuschpl/xamarin-root-detect-bypass/)
- [**Frida-xamarin-unpin**](https://github.com/GoSecure/frida-xamarin-unpin)

Updated **Frida-xamarin-unpin** (Mono >=6) hooks `System.Net.Http.HttpClient.SendAsync` and swaps the handler to a permissive one, so it still works even when pinning is implemented in custom handlers. Run it after the app starts:
```bash
frida -U -l dist/xamarin-unpin.js com.target.app --no-pause
```
Plantilla rápida para hacer hook a métodos administrados con el `frida-mono-api` incluido:
```javascript
const mono = require('frida-mono-api');
Mono.ensureInitialized();
Mono.enumerateLoadedImages().forEach(i => console.log(i.name));
const klass = Mono.classFromName("Namespace", "Class");
const m = Mono.methodFromName(klass, "Method", 2);
Mono.intercept(m, { onEnter(args){ console.log(args[1].toInt32()); } });
```
### Volver a firmar

La herramienta [Uber APK Signer](https://github.com/patrickfav/uber-apk-signer) simplifica la firma de múltiples APKs con la misma clave y puede usarse para volver a firmar una aplicación después de que se le hayan realizado cambios.

## Referencias

- [https://www.appknox.com/security/xamarin-reverse-engineering-a-guide-for-penetration-testers](https://www.appknox.com/security/xamarin-reverse-engineering-a-guide-for-penetration-testers)
- [https://thecobraden.com/posts/unpacking_xamarin_assembly_stores/](https://thecobraden.com/posts/unpacking_xamarin_assembly_stores/)
- [https://medium.com/@justmobilesec/introduction-to-the-exploitation-of-xamarin-apps-fde4619a51bf](https://medium.com/@justmobilesec/introduction-to-the-exploitation-of-xamarin-apps-fde4619a51bf)
- [https://github.com/jakev/pyxamstore](https://github.com/jakev/pyxamstore)
- [https://pypi.org/project/xamarout/](https://pypi.org/project/xamarout/)
- [https://github.com/GoSecure/frida-xamarin-unpin](https://github.com/GoSecure/frida-xamarin-unpin)
- [https://gist.github.com/Diefunction/e26fce039efcab57aac342a4b2d48ff6](https://gist.github.com/Diefunction/e26fce039efcab57aac342a4b2d48ff6)
- [https://reverseengineering.stackexchange.com/questions/31716/deobfuscating-ios-dll-file-i-think-arm64](https://reverseengineering.stackexchange.com/questions/31716/deobfuscating-ios-dll-file-i-think-arm64)

{{#include ../banners/hacktricks-training.md}}
