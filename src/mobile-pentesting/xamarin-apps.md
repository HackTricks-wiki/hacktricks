# Xamarin Apps

{{#include ../banners/hacktricks-training.md}}

## **Basic Information**

Xamarin é uma **plataforma de código aberto** projetada para desenvolvedores criarem apps para iOS, Android e Windows usando os frameworks .NET e C#. Esta plataforma oferece acesso a numerosas ferramentas e extensões para criar aplicações modernas de forma eficiente.

### Xamarin's Architecture

- Para **Android**, o Xamarin integra-se com namespaces Android e Java através de bindings .NET, operando dentro do ambiente de execução Mono juntamente com o Android Runtime (ART). Managed Callable Wrappers (MCW) e Android Callable Wrappers (ACW) facilitam a comunicação entre o Mono e o ART, ambos construídos sobre o kernel Linux.
- Para **iOS**, as aplicações rodam sob o runtime Mono, utilizando compilação Ahead of Time (AOT) completa para converter código C# .NET em assembly ARM. Esse processo executa-se ao lado do Objective-C Runtime em um kernel do tipo UNIX.

### .NET Runtime and Mono Framework

O **framework .NET** inclui assemblies, classes e namespaces para desenvolvimento de aplicações, com o .NET Runtime gerenciando a execução do código. Ele oferece independência de plataforma e compatibilidade retroativa. O **Mono Framework** é uma versão de código aberto do framework .NET, iniciada em 2005 para estender o .NET ao Linux, agora suportada pela Microsoft e liderada pela Xamarin.

### Reverse Engineering Xamarin Apps

#### Decompilation of Xamarin Assemblies

A decompilação transforma código compilado de volta em código-fonte. No Windows, a janela Modules no Visual Studio pode identificar módulos para decompilação, permitindo acesso direto a código de terceiros e extração do código-fonte para análise.

#### JIT vs AOT Compilação

- **Android** suporta Just-In-Time (JIT) e Ahead-Of-Time (AOT) compilation, com um modo Hybrid AOT para velocidade de execução otimizada. Full AOT é exclusivo para licenças Enterprise.
- **iOS** emprega exclusivamente AOT devido às restrições da Apple sobre execução dinâmica de código.

### Extracting dll Files from APK/IPA

Para acessar os assemblies em um APK/IPA, descompacte o arquivo e explore o diretório assemblies. Para Android, ferramentas como [XamAsmUnZ](https://github.com/cihansol/XamAsmUnZ) e [xamarin-decompress](https://github.com/NickstaDB/xamarin-decompress) podem descomprimir arquivos dll.
```bash
python3 xamarin-decompress.py -o /path/to/decompressed/apk
```
Em casos em que, após decompilar o APK, é possível ver a pasta unknown/assemblies/ com os arquivos `.dll` dentro dela, é possível usar [**dnSpy**](https://github.com/dnSpy/dnSpy) diretamente sobre os `.dlls` para analisá-los. No entanto, às vezes os arquivos `assemblies.blob` e `assemblies.manifest` estão dentro da pasta unknown/assemblies/. A ferramenta [pyxamstore](https://github.com/jakev/pyxamstore) pode desempacotar o arquivo `assemblies.blob` em apps Xamarin, permitindo acesso às .NET assemblies para análise posterior:
```bash
pyxamstore unpack -d /path/to/decompressed/apk/assemblies/
# After patching DLLs, rebuild the store
pyxamstore pack
```
Algumas builds recentes de Xamarin/MAUI armazenam assemblies comprimidos usando o formato **XALZ** dentro de `/assemblies.blob` ou `/resources/assemblies`. Você pode descompactá-los rapidamente com a biblioteca [xamarout](https://pypi.org/project/xamarout/):
```python
from xamarout import xalz
import os
for root, _, files in os.walk("."):
for f in files:
if open(os.path.join(root, f), 'rb').read(4) == b"XALZ":
xa = xalz.XamarinCompressedAssembly(os.path.join(root, f))
xa.write("decompressed/" + f)
```
Arquivos .dll do iOS são facilmente acessíveis para descompilação, revelando porções significativas do código da aplicação, que frequentemente compartilha uma base comum entre diferentes plataformas.

> **AOT on iOS**: o IL gerenciado é compilado em arquivos nativos `*.aotdata.*` files. Modificar o DLL sozinho não mudará a lógica; você precisa hookar os stubs nativos (e.g., com Frida) porque os corpos do IL são placeholders vazios.

### Static Analysis

Once the `.dll`s are obtained it's possible to analyze the .Net code statically using tools such as [**dnSpy**](https://github.com/dnSpy/dnSpy) or [**ILSpy**](https://github.com/icsharpcode/ILSpy) that will allow modifying the code of the app. This can be super useful to tamper the application to bypass protections for example.\
Observe que após modificar o app você precisará empacotá-lo novamente e assiná-lo novamente.

> dnSpy is archived; maintained forks like **dnSpyEx** keep working with .NET 8/MAUI assemblies and preserve debug symbols when re-saving.

### Dynamic Analysis

A análise dinâmica envolve checar SSL pinning e usar ferramentas como [Fridax](https://github.com/NorthwaveSecurity/fridax) para modificações em tempo de execução do binário .NET em apps Xamarin. Frida scripts estão disponíveis para bypass de root detection ou SSL pinning, ampliando as capacidades de análise.

Other interesting Frida scripts:

- [**xamarin-antiroot**](https://codeshare.frida.re/@Gand3lf/xamarin-antiroot/)
- [**xamarin-root-detect-bypass**](https://codeshare.frida.re/@nuschpl/xamarin-root-detect-bypass/)
- [**Frida-xamarin-unpin**](https://github.com/GoSecure/frida-xamarin-unpin)

Updated **Frida-xamarin-unpin** (Mono >=6) hooks `System.Net.Http.HttpClient.SendAsync` and swaps the handler to a permissive one, so it still works even when pinning is implemented in custom handlers. Run it after the app starts:
```bash
frida -U -l dist/xamarin-unpin.js com.target.app --no-pause
```
Modelo rápido para hook de métodos gerenciados com o `frida-mono-api`:
```javascript
const mono = require('frida-mono-api');
Mono.ensureInitialized();
Mono.enumerateLoadedImages().forEach(i => console.log(i.name));
const klass = Mono.classFromName("Namespace", "Class");
const m = Mono.methodFromName(klass, "Method", 2);
Mono.intercept(m, { onEnter(args){ console.log(args[1].toInt32()); } });
```
### Reassinatura

A ferramenta [Uber APK Signer](https://github.com/patrickfav/uber-apk-signer) simplifica a assinatura de múltiplos APKs com a mesma chave e pode ser usada para reassinar um app depois de alterações terem sido realizadas nele.

## Referências

- [https://www.appknox.com/security/xamarin-reverse-engineering-a-guide-for-penetration-testers](https://www.appknox.com/security/xamarin-reverse-engineering-a-guide-for-penetration-testers)
- [https://thecobraden.com/posts/unpacking_xamarin_assembly_stores/](https://thecobraden.com/posts/unpacking_xamarin_assembly_stores/)
- [https://medium.com/@justmobilesec/introduction-to-the-exploitation-of-xamarin-apps-fde4619a51bf](https://medium.com/@justmobilesec/introduction-to-the-exploitation-of-xamarin-apps-fde4619a51bf)
- [https://github.com/jakev/pyxamstore](https://github.com/jakev/pyxamstore)
- [https://pypi.org/project/xamarout/](https://pypi.org/project/xamarout/)
- [https://github.com/GoSecure/frida-xamarin-unpin](https://github.com/GoSecure/frida-xamarin-unpin)
- [https://gist.github.com/Diefunction/e26fce039efcab57aac342a4b2d48ff6](https://gist.github.com/Diefunction/e26fce039efcab57aac342a4b2d48ff6)
- [https://reverseengineering.stackexchange.com/questions/31716/deobfuscating-ios-dll-file-i-think-arm64](https://reverseengineering.stackexchange.com/questions/31716/deobfuscating-ios-dll-file-i-think-arm64)

{{#include ../banners/hacktricks-training.md}}
