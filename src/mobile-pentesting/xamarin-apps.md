# Applicazioni Xamarin

{{#include ../banners/hacktricks-training.md}}

## **Informazioni di base**

Xamarin è una **piattaforma open-source** progettata per permettere agli sviluppatori di **costruire app per iOS, Android e Windows** usando i framework .NET e C#. Questa piattaforma offre accesso a numerosi strumenti ed estensioni per creare applicazioni moderne in modo efficiente.

### Architettura di Xamarin

- Per **Android**, Xamarin si integra con gli namespace Android e Java tramite i binding .NET, operando all'interno dell'ambiente di esecuzione Mono insieme all'Android Runtime (ART). I Managed Callable Wrappers (MCW) e gli Android Callable Wrappers (ACW) facilitano la comunicazione tra Mono e ART, entrambi basati sul kernel Linux.
- Per **iOS**, le applicazioni vengono eseguite sotto il runtime Mono, utilizzando la compilazione full Ahead of Time (AOT) per convertire il codice C# .NET in codice assembly ARM. Questo processo viene eseguito insieme all'Objective-C Runtime su un kernel di tipo UNIX.

### .NET Runtime e Mono Framework

Il **.NET framework** include assembly, classi e namespace per lo sviluppo di applicazioni, con il .NET Runtime che gestisce l'esecuzione del codice. Offre indipendenza dalla piattaforma e compatibilità retroattiva. Il **Mono Framework** è una versione open-source del .NET framework, iniziata nel 2005 per estendere .NET a Linux, ora supportata da Microsoft e guidata da Xamarin.

### Reverse Engineering Xamarin Apps

#### Decompilation of Xamarin Assemblies

La decompilazione trasforma il codice compilato in codice sorgente. Su Windows, la finestra Modules in Visual Studio può identificare moduli da decompilare, permettendo l'accesso diretto al codice di terze parti e l'estrazione del codice sorgente per l'analisi.

#### JIT vs AOT Compilation

- **Android** supporta la compilazione Just-In-Time (JIT) e Ahead-Of-Time (AOT), con una modalità Hybrid AOT per una velocità di esecuzione ottimale. Full AOT è esclusiva delle licenze Enterprise.
- **iOS** usa esclusivamente la compilazione AOT a causa delle restrizioni di Apple sull'esecuzione di codice dinamico.

### Estrazione dei file dll da APK/IPA

Per accedere alle assembly in un APK/IPA, decomprimi il file ed esplora la directory assemblies. Per Android, strumenti come [XamAsmUnZ](https://github.com/cihansol/XamAsmUnZ) e [xamarin-decompress](https://github.com/NickstaDB/xamarin-decompress) possono decomprimere i file dll.
```bash
python3 xamarin-decompress.py -o /path/to/decompressed/apk
```
Nel caso in cui, dopo aver decompilato l'APK, sia possibile vedere la cartella unknown/assemblies/ con i file `.dll` al suo interno, è possibile usare [**dnSpy**](https://github.com/dnSpy/dnSpy) direttamente sui `.dll` per analizzarli. Tuttavia, a volte i file `assemblies.blob` e `assemblies.manifest` si trovano nella cartella unknown/assemblies/. Lo strumento [pyxamstore](https://github.com/jakev/pyxamstore) può estrarre il file `assemblies.blob` nelle app Xamarin, permettendo l'accesso agli assembly .NET per ulteriori analisi:
```bash
pyxamstore unpack -d /path/to/decompressed/apk/assemblies/
# After patching DLLs, rebuild the store
pyxamstore pack
```
Alcune build recenti di Xamarin/MAUI memorizzano assembly compressi usando il formato **XALZ** all'interno di `/assemblies.blob` o `/resources/assemblies`. Puoi decomprimerli rapidamente con la libreria [xamarout](https://pypi.org/project/xamarout/):
```python
from xamarout import xalz
import os
for root, _, files in os.walk("."):
for f in files:
if open(os.path.join(root, f), 'rb').read(4) == b"XALZ":
xa = xalz.XamarinCompressedAssembly(os.path.join(root, f))
xa.write("decompressed/" + f)
```
I file `.dll` su iOS sono facilmente accessibili per la decompilazione, rivelando porzioni significative del codice dell'applicazione, che spesso condivide una base comune tra diverse piattaforme.

> **AOT on iOS**: managed IL is compiled into native `*.aotdata.*` files. Patching the DLL alone will not change logic; you need to hook native stubs (e.g., with Frida) because the IL bodies are empty placeholders.

### Analisi statica

Una volta ottenuti i `.dll` è possibile analizzare staticamente il codice .Net usando strumenti come [**dnSpy**](https://github.com/dnSpy/dnSpy) o [**ILSpy**](https://github.com/icsharpcode/ILSpy) che permettono di modificare il codice dell'app. Questo può essere molto utile per manomettere l'applicazione e bypassare le protezioni, per esempio.\
Nota che dopo aver modificato l'app dovrai impacchettarla nuovamente e firmarla di nuovo.

> dnSpy is archived; maintained forks like **dnSpyEx** keep working with .NET 8/MAUI assemblies and preserve debug symbols when re-saving.

### Analisi dinamica

L'analisi dinamica comprende il controllo dello SSL pinning e l'uso di strumenti come [Fridax](https://github.com/NorthwaveSecurity/fridax) per modifiche runtime del binario .NET nelle app Xamarin. Script Frida sono disponibili per bypassare il rilevamento di root o lo SSL pinning, potenziando le capacità di analisi.

Altri script Frida interessanti:

- [**xamarin-antiroot**](https://codeshare.frida.re/@Gand3lf/xamarin-antiroot/)
- [**xamarin-root-detect-bypass**](https://codeshare.frida.re/@nuschpl/xamarin-root-detect-bypass/)
- [**Frida-xamarin-unpin**](https://github.com/GoSecure/frida-xamarin-unpin)

Aggiornato **Frida-xamarin-unpin** (Mono >=6) hooks `System.Net.Http.HttpClient.SendAsync` e sostituisce il handler con uno permissivo, quindi funziona anche quando il pinning è implementato in handler custom. Eseguilo dopo l'avvio dell'app:
```bash
frida -U -l dist/xamarin-unpin.js com.target.app --no-pause
```
Template rapido per hookare metodi managed con il `frida-mono-api` incluso:
```javascript
const mono = require('frida-mono-api');
Mono.ensureInitialized();
Mono.enumerateLoadedImages().forEach(i => console.log(i.name));
const klass = Mono.classFromName("Namespace", "Class");
const m = Mono.methodFromName(klass, "Method", 2);
Mono.intercept(m, { onEnter(args){ console.log(args[1].toInt32()); } });
```
### Rifirma

Lo strumento [Uber APK Signer](https://github.com/patrickfav/uber-apk-signer) semplifica la firma di più APK con la stessa chiave e può essere usato per rifirmare un'app dopo che sono state apportate modifiche.

## Riferimenti

- [https://www.appknox.com/security/xamarin-reverse-engineering-a-guide-for-penetration-testers](https://www.appknox.com/security/xamarin-reverse-engineering-a-guide-for-penetration-testers)
- [https://thecobraden.com/posts/unpacking_xamarin_assembly_stores/](https://thecobraden.com/posts/unpacking_xamarin_assembly_stores/)
- [https://medium.com/@justmobilesec/introduction-to-the-exploitation-of-xamarin-apps-fde4619a51bf](https://medium.com/@justmobilesec/introduction-to-the-exploitation-of-xamarin-apps-fde4619a51bf)
- [https://github.com/jakev/pyxamstore](https://github.com/jakev/pyxamstore)
- [https://pypi.org/project/xamarout/](https://pypi.org/project/xamarout/)
- [https://github.com/GoSecure/frida-xamarin-unpin](https://github.com/GoSecure/frida-xamarin-unpin)
- [https://gist.github.com/Diefunction/e26fce039efcab57aac342a4b2d48ff6](https://gist.github.com/Diefunction/e26fce039efcab57aac342a4b2d48ff6)
- [https://reverseengineering.stackexchange.com/questions/31716/deobfuscating-ios-dll-file-i-think-arm64](https://reverseengineering.stackexchange.com/questions/31716/deobfuscating-ios-dll-file-i-think-arm64)

{{#include ../banners/hacktricks-training.md}}
