# Xamarin Apps

{{#include ../banners/hacktricks-training.md}}

## **Informations de base**

Xamarin est une plateforme open-source conçue pour permettre aux développeurs de créer des applications pour iOS, Android et Windows en utilisant les frameworks .NET et C#. Cette plateforme offre l'accès à de nombreux outils et extensions pour développer efficacement des applications modernes.

### Architecture de Xamarin

- Pour **Android**, Xamarin s'intègre aux namespaces Android et Java via des bindings .NET, fonctionnant dans l'environnement d'exécution Mono parallèlement à l'Android Runtime (ART). Les Managed Callable Wrappers (MCW) et les Android Callable Wrappers (ACW) facilitent la communication entre Mono et ART, tous deux construits sur le kernel Linux.
- Pour **iOS**, les applications s'exécutent sous le runtime Mono, utilisant une compilation Ahead of Time (AOT) complète pour convertir le code C# .NET en code assembleur ARM. Ce processus fonctionne aux côtés de l'Objective-C Runtime sur un kernel de type UNIX.

### .NET Runtime et Mono Framework

Le framework .NET inclut des assemblies, des classes et des namespaces pour le développement d'applications, avec le .NET Runtime gérant l'exécution du code. Il offre indépendance de plateforme et compatibilité ascendante. Le Mono Framework est une version open-source du framework .NET, initiée en 2005 pour étendre .NET à Linux, aujourd'hui soutenue par Microsoft et dirigée par Xamarin.

### Rétro-ingénierie des applications Xamarin

#### Décompilation des assemblies Xamarin

La décompilation transforme le code compilé en code source. Sous Windows, la fenêtre Modules de Visual Studio peut identifier des modules à décompiler, permettant un accès direct au code tiers et l'extraction du code source pour analyse.

#### JIT vs AOT Compilation

- **Android** supporte la compilation Just-In-Time (JIT) et Ahead-Of-Time (AOT), avec un mode Hybrid AOT pour optimiser la vitesse d'exécution. Le Full AOT est réservé aux licences Enterprise.
- **iOS** n'emploie que la compilation AOT en raison des restrictions d'Apple sur l'exécution dynamique de code.

### Extraction des fichiers dll depuis APK/IPA

Pour accéder aux assemblies dans un APK/IPA, dézippez le fichier et explorez le répertoire assemblies. Pour Android, des outils comme [XamAsmUnZ](https://github.com/cihansol/XamAsmUnZ) et [xamarin-decompress](https://github.com/NickstaDB/xamarin-decompress) peuvent décompresser les fichiers dll.
```bash
python3 xamarin-decompress.py -o /path/to/decompressed/apk
```
Dans les cas où, après avoir décompilé l'APK, il est possible de voir le dossier unknown/assemblies/ contenant les fichiers `.dll`, il est possible d'utiliser [**dnSpy**](https://github.com/dnSpy/dnSpy) directement sur les `.dll` pour les analyser. Cependant, parfois les fichiers `assemblies.blob` et `assemblies.manifest` se trouvent dans le dossier unknown/assemblies/. L'outil [pyxamstore](https://github.com/jakev/pyxamstore) peut décompacter le fichier `assemblies.blob` dans les apps Xamarin, permettant d'accéder aux assemblies .NET pour une analyse plus approfondie :
```bash
pyxamstore unpack -d /path/to/decompressed/apk/assemblies/
# After patching DLLs, rebuild the store
pyxamstore pack
```
Certaines builds récentes de Xamarin/MAUI stockent des assemblies compressés en utilisant le format **XALZ** à l'intérieur de `/assemblies.blob` ou `/resources/assemblies`. Vous pouvez les décompresser rapidement avec la bibliothèque [xamarout](https://pypi.org/project/xamarout/) :
```python
from xamarout import xalz
import os
for root, _, files in os.walk("."):
for f in files:
if open(os.path.join(root, f), 'rb').read(4) == b"XALZ":
xa = xalz.XamarinCompressedAssembly(os.path.join(root, f))
xa.write("decompressed/" + f)
```
Les fichiers .dll iOS sont facilement accessibles pour la décompilation, révélant des portions importantes du code de l'application, qui partagent souvent une base commune entre différentes plateformes.

> **AOT on iOS**: managed IL is compiled into native `*.aotdata.*` files. Patching the DLL alone will not change logic; you need to hook native stubs (e.g., with Frida) because the IL bodies are empty placeholders.

### Static Analysis

Une fois les `.dll`s obtenues il est possible d'analyser statiquement le code .Net en utilisant des outils tels que [**dnSpy**](https://github.com/dnSpy/dnSpy) ou [**ILSpy**](https://github.com/icsharpcode/ILSpy) qui permettent de modifier le code de l'app. Cela peut être super utile pour altérer l'application afin de contourner des protections par exemple.\ Notez qu'après avoir modifié l'app vous devrez la reconditionner et la signer à nouveau.

> dnSpy is archived; maintained forks like **dnSpyEx** keep working with .NET 8/MAUI assemblies and preserve debug symbols when re-saving.

### Dynamic Analysis

L'analyse dynamique consiste à vérifier le SSL pinning et à utiliser des outils comme [Fridax](https://github.com/NorthwaveSecurity/fridax) pour des modifications à l'exécution du binaire .NET dans les apps Xamarin. Des scripts Frida sont disponibles pour bypasser la détection de root ou le SSL pinning, améliorant les capacités d'analyse.

Other interesting Frida scripts:

- [**xamarin-antiroot**](https://codeshare.frida.re/@Gand3lf/xamarin-antiroot/)
- [**xamarin-root-detect-bypass**](https://codeshare.frida.re/@nuschpl/xamarin-root-detect-bypass/)
- [**Frida-xamarin-unpin**](https://github.com/GoSecure/frida-xamarin-unpin)

Updated **Frida-xamarin-unpin** (Mono >=6) hooks `System.Net.Http.HttpClient.SendAsync` and swaps the handler to a permissive one, so it still works even when pinning is implemented in custom handlers. Run it after the app starts:
```bash
frida -U -l dist/xamarin-unpin.js com.target.app --no-pause
```
Modèle rapide pour hook des méthodes gérées avec le `frida-mono-api` fourni :
```javascript
const mono = require('frida-mono-api');
Mono.ensureInitialized();
Mono.enumerateLoadedImages().forEach(i => console.log(i.name));
const klass = Mono.classFromName("Namespace", "Class");
const m = Mono.methodFromName(klass, "Method", 2);
Mono.intercept(m, { onEnter(args){ console.log(args[1].toInt32()); } });
```
### Ré-signature

L'outil [Uber APK Signer](https://github.com/patrickfav/uber-apk-signer) simplifie la signature de plusieurs APK avec la même clé, et peut être utilisé pour re-signer une application après que des modifications y ont été apportées.

## Références

- [https://www.appknox.com/security/xamarin-reverse-engineering-a-guide-for-penetration-testers](https://www.appknox.com/security/xamarin-reverse-engineering-a-guide-for-penetration-testers)
- [https://thecobraden.com/posts/unpacking_xamarin_assembly_stores/](https://thecobraden.com/posts/unpacking_xamarin_assembly_stores/)
- [https://medium.com/@justmobilesec/introduction-to-the-exploitation-of-xamarin-apps-fde4619a51bf](https://medium.com/@justmobilesec/introduction-to-the-exploitation-of-xamarin-apps-fde4619a51bf)
- [https://github.com/jakev/pyxamstore](https://github.com/jakev/pyxamstore)
- [https://pypi.org/project/xamarout/](https://pypi.org/project/xamarout/)
- [https://github.com/GoSecure/frida-xamarin-unpin](https://github.com/GoSecure/frida-xamarin-unpin)
- [https://gist.github.com/Diefunction/e26fce039efcab57aac342a4b2d48ff6](https://gist.github.com/Diefunction/e26fce039efcab57aac342a4b2d48ff6)
- [https://reverseengineering.stackexchange.com/questions/31716/deobfuscating-ios-dll-file-i-think-arm64](https://reverseengineering.stackexchange.com/questions/31716/deobfuscating-ios-dll-file-i-think-arm64)

{{#include ../banners/hacktricks-training.md}}
