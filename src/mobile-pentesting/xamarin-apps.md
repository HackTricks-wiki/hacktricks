# Xamarin Εφαρμογές

{{#include ../banners/hacktricks-training.md}}

## **Βασικές Πληροφορίες**

Xamarin είναι μια **πλατφόρμα ανοιχτού κώδικα** σχεδιασμένη για προγραμματιστές να **δημιουργούν εφαρμογές για iOS, Android, και Windows** χρησιμοποιώντας τα πλαίσια .NET και C#. Αυτή η πλατφόρμα προσφέρει πρόσβαση σε πολυάριθμα εργαλεία και επεκτάσεις για την αποδοτική δημιουργία σύγχρονων εφαρμογών.

### Αρχιτεκτονική του Xamarin

- Για **Android**, το Xamarin ενσωματώνεται με τα Android και Java namespaces μέσω .NET bindings, λειτουργώντας μέσα στο περιβάλλον εκτέλεσης Mono παράλληλα με το Android Runtime (ART). Managed Callable Wrappers (MCW) και Android Callable Wrappers (ACW) διευκολύνουν την επικοινωνία μεταξύ Mono και ART, τα οποία και τα δύο βασίζονται στον Linux kernel.
- Για **iOS**, οι εφαρμογές τρέχουν υπό το runtime Mono, χρησιμοποιώντας πλήρη Ahead of Time (AOT) compilation για να μετατρέψουν κώδικα C# .NET σε ARM assembly language. Αυτή η διαδικασία τρέχει παράλληλα με το Objective-C Runtime πάνω σε έναν UNIX-όμοιο kernel.

### .NET Runtime και Mono Framework

Το **.NET framework** περιλαμβάνει assemblies, κλάσεις και namespaces για ανάπτυξη εφαρμογών, με το .NET Runtime να διαχειρίζεται την εκτέλεση του κώδικα. Προσφέρει ανεξαρτησία πλατφόρμας και συμβατότητα προς τα πίσω. Το **Mono Framework** είναι μια πλατφόρμα ανοιχτού κώδικα του .NET, ξεκίνησε το 2005 για να επεκτείνει το .NET σε Linux, τώρα υποστηρίζεται από τη Microsoft και ηγείται από την Xamarin.

### Αντίστροφη μηχανική (Reverse Engineering) εφαρμογών Xamarin

#### Απομεταγλώττιση (Decompilation) των Xamarin assemblies

Η απομεταγλώττιση μετατρέπει τον μεταγλωττισμένο κώδικα πίσω σε πηγαίο κώδικα. Στα Windows, το παράθυρο Modules στο Visual Studio μπορεί να εντοπίσει modules για απομεταγλώττιση, επιτρέποντας άμεση πρόσβαση σε κώδικα τρίτων και εξαγωγή του πηγαίου κώδικα για ανάλυση.

#### JIT vs AOT Compilation

- **Android** υποστηρίζει Just-In-Time (JIT) και Ahead-Of-Time (AOT) compilation, με λειτουργία Hybrid AOT για βέλτιστη ταχύτητα εκτέλεσης. Πλήρες AOT είναι αποκλειστικό για άδειες Enterprise.
- **iOS** χρησιμοποιεί αποκλειστικά AOT compilation λόγω των περιορισμών της Apple στην δυναμική εκτέλεση κώδικα.

### Εξαγωγή αρχείων dll από APK/IPA

Για να αποκτήσετε πρόσβαση στα assemblies σε ένα APK/IPA, αποσυμπιέστε το αρχείο και εξερευνήστε τον φάκελο assemblies. Για Android, εργαλεία όπως [XamAsmUnZ](https://github.com/cihansol/XamAsmUnZ) και [xamarin-decompress](https://github.com/NickstaDB/xamarin-decompress) μπορούν να αποσυμπιέσουν αρχεία dll.
```bash
python3 xamarin-decompress.py -o /path/to/decompressed/apk
```
Σε περιπτώσεις όπου, μετά το decompiling του APK, είναι δυνατό να φαίνεται ο φάκελος unknown/assemblies/ με τα `.dll` αρχεία μέσα, μπορείτε να χρησιμοποιήσετε το [**dnSpy**](https://github.com/dnSpy/dnSpy) απευθείας πάνω στα `.dlls` για να τα αναλύσετε. Ωστόσο, μερικές φορές τα αρχεία `assemblies.blob` και `assemblies.manifest` βρίσκονται μέσα στον φάκελο unknown/assemblies/. Το εργαλείο [pyxamstore](https://github.com/jakev/pyxamstore) μπορεί να αποσυμπιέσει το αρχείο `assemblies.blob` σε εφαρμογές Xamarin, επιτρέποντας την πρόσβαση στα .NET assemblies για περαιτέρω ανάλυση:
```bash
pyxamstore unpack -d /path/to/decompressed/apk/assemblies/
# After patching DLLs, rebuild the store
pyxamstore pack
```
Ορισμένα πρόσφατα builds του Xamarin/MAUI αποθηκεύουν συμπιεσμένα assemblies χρησιμοποιώντας τη μορφή **XALZ** μέσα στο `/assemblies.blob` ή στο `/resources/assemblies`. Μπορείτε να τα αποσυμπιέσετε γρήγορα με τη βιβλιοθήκη [xamarout](https://pypi.org/project/xamarout/):
```python
from xamarout import xalz
import os
for root, _, files in os.walk("."):
for f in files:
if open(os.path.join(root, f), 'rb').read(4) == b"XALZ":
xa = xalz.XamarinCompressedAssembly(os.path.join(root, f))
xa.write("decompressed/" + f)
```
iOS .dll αρχεία είναι εύκολα προσβάσιμα για αποσυμπίληση, αποκαλύπτοντας σημαντικά τμήματα του κώδικα της εφαρμογής, που συχνά μοιράζεται κοινή βάση μεταξύ διαφορετικών πλατφορμών.

> **AOT on iOS**: managed IL is compiled into native `*.aotdata.*` files. Patching the DLL alone will not change logic; you need to hook native stubs (e.g., with Frida) because the IL bodies are empty placeholders.

### Στατική Ανάλυση

Αφού αποκτηθούν τα `.dll` είναι δυνατόν να αναλυθεί ο .Net κώδικας στατικά χρησιμοποιώντας εργαλεία όπως [**dnSpy**](https://github.com/dnSpy/dnSpy) ή [**ILSpy**](https://github.com/icsharpcode/ILSpy) που θα επιτρέψουν την τροποποίηση του κώδικα της εφαρμογής. Αυτό μπορεί να είναι πολύ χρήσιμο για να παραποιήσετε την εφαρμογή ώστε, για παράδειγμα, να παρακάμψετε προστασίες.\
Σημειώστε ότι μετά την τροποποίηση της εφαρμογής θα χρειαστεί να τη συσκευάσετε ξανά και να την υπογράψετε ξανά.

> dnSpy is archived; maintained forks like **dnSpyEx** keep working with .NET 8/MAUI assemblies and preserve debug symbols when re-saving.

### Δυναμική Ανάλυση

Η δυναμική ανάλυση περιλαμβάνει έλεγχο για SSL pinning και τη χρήση εργαλείων όπως [Fridax](https://github.com/NorthwaveSecurity/fridax) για runtime τροποποιήσεις του .NET binary σε εφαρμογές Xamarin. Υπάρχουν Frida scripts διαθέσιμα για παράκαμψη root detection ή SSL pinning, βελτιώνοντας τις δυνατότητες ανάλυσης.

Other interesting Frida scripts:

- [**xamarin-antiroot**](https://codeshare.frida.re/@Gand3lf/xamarin-antiroot/)
- [**xamarin-root-detect-bypass**](https://codeshare.frida.re/@nuschpl/xamarin-root-detect-bypass/)
- [**Frida-xamarin-unpin**](https://github.com/GoSecure/frida-xamarin-unpin)

Updated **Frida-xamarin-unpin** (Mono >=6) hooks `System.Net.Http.HttpClient.SendAsync` and swaps the handler to a permissive one, so it still works even when pinning is implemented in custom handlers. Run it after the app starts:
```bash
frida -U -l dist/xamarin-unpin.js com.target.app --no-pause
```
Γρήγορο πρότυπο για hook διαχειριζόμενων μεθόδων με το ενσωματωμένο `frida-mono-api`:
```javascript
const mono = require('frida-mono-api');
Mono.ensureInitialized();
Mono.enumerateLoadedImages().forEach(i => console.log(i.name));
const klass = Mono.classFromName("Namespace", "Class");
const m = Mono.methodFromName(klass, "Method", 2);
Mono.intercept(m, { onEnter(args){ console.log(args[1].toInt32()); } });
```
### Επανυπογραφή

Το εργαλείο [Uber APK Signer](https://github.com/patrickfav/uber-apk-signer) απλοποιεί την υπογραφή πολλαπλών APK με το ίδιο κλειδί και μπορεί να χρησιμοποιηθεί για να επανυπογράψει μια εφαρμογή αφότου έχουν γίνει αλλαγές σε αυτή.

## Αναφορές

- [https://www.appknox.com/security/xamarin-reverse-engineering-a-guide-for-penetration-testers](https://www.appknox.com/security/xamarin-reverse-engineering-a-guide-for-penetration-testers)
- [https://thecobraden.com/posts/unpacking_xamarin_assembly_stores/](https://thecobraden.com/posts/unpacking_xamarin_assembly_stores/)
- [https://medium.com/@justmobilesec/introduction-to-the-exploitation-of-xamarin-apps-fde4619a51bf](https://medium.com/@justmobilesec/introduction-to-the-exploitation-of-xamarin-apps-fde4619a51bf)
- [https://github.com/jakev/pyxamstore](https://github.com/jakev/pyxamstore)
- [https://pypi.org/project/xamarout/](https://pypi.org/project/xamarout/)
- [https://github.com/GoSecure/frida-xamarin-unpin](https://github.com/GoSecure/frida-xamarin-unpin)
- [https://gist.github.com/Diefunction/e26fce039efcab57aac342a4b2d48ff6](https://gist.github.com/Diefunction/e26fce039efcab57aac342a4b2d48ff6)
- [https://reverseengineering.stackexchange.com/questions/31716/deobfuscating-ios-dll-file-i-think-arm64](https://reverseengineering.stackexchange.com/questions/31716/deobfuscating-ios-dll-file-i-think-arm64)

{{#include ../banners/hacktricks-training.md}}
