# Xamarin 앱

{{#include ../banners/hacktricks-training.md}}

## **기본 정보**

Xamarin은 **오픈 소스 플랫폼**으로, 개발자가 .NET 및 C# 프레임워크를 사용해 iOS, Android, Windows용 앱을 개발하도록 설계되었습니다. 이 플랫폼은 현대적인 애플리케이션을 효율적으로 만들기 위한 다양한 도구와 확장 기능에 대한 접근을 제공합니다.

### Xamarin의 아키텍처

- For **Android**, Xamarin은 .NET 바인딩을 통해 Android 및 Java 네임스페이스와 통합되며, Mono 실행 환경에서 Android Runtime (ART)와 함께 동작합니다. Managed Callable Wrappers (MCW)와 Android Callable Wrappers (ACW)는 Mono와 ART 간의 통신을 중개하며, 둘 다 Linux 커널 위에서 동작합니다.
- For **iOS**, 애플리케이션은 Mono 런타임 하에서 실행되며, 전체 Ahead of Time (AOT) 컴파일을 통해 C# .NET 코드를 ARM 어셈블리로 변환합니다. 이 과정은 Objective-C Runtime과 함께 UNIX 계열 커널에서 동작합니다.

### .NET Runtime and Mono Framework

**.NET framework**는 애플리케이션 개발을 위한 assemblies, classes, namespaces 등을 포함하며, .NET Runtime이 코드 실행을 관리합니다. 이는 플랫폼 독립성과 하위 호환성을 제공합니다. **Mono Framework**는 .NET framework의 오픈 소스 구현으로, 2005년에 .NET을 Linux로 확장하기 위해 시작되었고 현재 Microsoft의 지원을 받으며 Xamarin이 주도하고 있습니다.

### Reverse Engineering Xamarin Apps

#### Decompilation of Xamarin Assemblies

Decompilation은 컴파일된 코드를 소스 코드로 되돌리는 과정입니다. Windows에서는 Visual Studio의 Modules window를 통해 디컴파일 대상 모듈을 식별할 수 있으며, 이를 통해 서드파티 코드에 직접 접근하고 분석을 위해 소스 코드를 추출할 수 있습니다.

#### JIT vs AOT Compilation

- **Android**는 Just-In-Time (JIT) 및 Ahead-Of-Time (AOT) 컴파일을 지원하며, 실행 속도 최적화를 위해 Hybrid AOT 모드를 제공합니다. Full AOT는 Enterprise 라이선스에서만 사용 가능합니다.
- **iOS**는 Apple의 동적 코드 실행 제한 때문에 AOT 컴파일만 사용합니다.

### APK/IPA에서 dll 파일 추출

APK/IPA에 포함된 assemblies에 접근하려면 파일을 압축 해제(unzip)한 후 assemblies 디렉터리를 탐색하세요. Android의 경우 [XamAsmUnZ](https://github.com/cihansol/XamAsmUnZ) 및 [xamarin-decompress](https://github.com/NickstaDB/xamarin-decompress) 같은 도구로 dll 파일의 압축을 풀 수 있습니다.
```bash
python3 xamarin-decompress.py -o /path/to/decompressed/apk
```
APK를 decompile한 후 unknown/assemblies/ 폴더 안에 `.dll` 파일들이 보이는 경우, [**dnSpy**](https://github.com/dnSpy/dnSpy)를 사용해 `.dlls`를 직접 분석할 수 있습니다. 그러나 경우에 따라 unknown/assemblies/ 폴더에 `assemblies.blob` 및 `assemblies.manifest` 파일이 들어있을 수 있습니다. [pyxamstore](https://github.com/jakev/pyxamstore) 도구는 Xamarin apps에서 `assemblies.blob` 파일을 unpack하여 .NET assemblies에 접근해 추가 분석을 가능하게 합니다:
```bash
pyxamstore unpack -d /path/to/decompressed/apk/assemblies/
# After patching DLLs, rebuild the store
pyxamstore pack
```
일부 최신 Xamarin/MAUI 빌드는 `/assemblies.blob` 또는 `/resources/assemblies` 내부에 **XALZ** 형식으로 압축된 어셈블리를 저장합니다. [xamarout](https://pypi.org/project/xamarout/) 라이브러리로 빠르게 압축을 해제할 수 있습니다:
```python
from xamarout import xalz
import os
for root, _, files in os.walk("."):
for f in files:
if open(os.path.join(root, f), 'rb').read(4) == b"XALZ":
xa = xalz.XamarinCompressedAssembly(os.path.join(root, f))
xa.write("decompressed/" + f)
```
iOS dll files are readily accessible for decompilation, revealing significant portions of the application code, which often shares a common base across different platforms.

> **AOT on iOS**: managed IL은 네이티브 `*.aotdata.*` 파일로 컴파일됩니다. DLL만 패치해서는 로직이 변경되지 않습니다; IL 본문이 빈 플레이스홀더이므로 네이티브 스텁을 후킹해야 합니다(예: Frida 사용).

### 정적 분석

한 번 `.dll`s를 확보하면 [**dnSpy**](https://github.com/dnSpy/dnSpy) 또는 [**ILSpy**](https://github.com/icsharpcode/ILSpy) 같은 도구를 사용해 .Net 코드를 정적으로 분석할 수 있으며, 이를 통해 앱 코드를 수정할 수 있습니다. 예를 들어 보호를 우회하기 위해 애플리케이션을 변조할 때 매우 유용합니다.\
수정 후에는 앱을 다시 패키징하고 다시 서명해야 한다는 점을 유의하세요.

> dnSpy는 아카이브되었으며; **dnSpyEx** 같은 유지되는 포크는 .NET 8/MAUI 어셈블리와 함께 계속 작동하며 다시 저장할 때 디버그 심볼을 보존합니다.

### 동적 분석

동적 분석은 SSL pinning 확인과 Xamarin 앱의 .NET 바이너리를 런타임에 수정하기 위해 [Fridax](https://github.com/NorthwaveSecurity/fridax) 같은 도구 사용을 포함합니다. Frida 스크립트는 root detection 또는 SSL pinning을 바이패스하기 위해 사용 가능하며, 분석 능력을 향상시킵니다.

Other interesting Frida scripts:

- [**xamarin-antiroot**](https://codeshare.frida.re/@Gand3lf/xamarin-antiroot/)
- [**xamarin-root-detect-bypass**](https://codeshare.frida.re/@nuschpl/xamarin-root-detect-bypass/)
- [**Frida-xamarin-unpin**](https://github.com/GoSecure/frida-xamarin-unpin)

Updated **Frida-xamarin-unpin** (Mono >=6) hooks `System.Net.Http.HttpClient.SendAsync` and swaps the handler to a permissive one, so it still works even when pinning is implemented in custom handlers. Run it after the app starts:
```bash
frida -U -l dist/xamarin-unpin.js com.target.app --no-pause
```
번들로 제공되는 `frida-mono-api`로 관리되는 메서드를 후킹하기 위한 빠른 템플릿:
```javascript
const mono = require('frida-mono-api');
Mono.ensureInitialized();
Mono.enumerateLoadedImages().forEach(i => console.log(i.name));
const klass = Mono.classFromName("Namespace", "Class");
const m = Mono.methodFromName(klass, "Method", 2);
Mono.intercept(m, { onEnter(args){ console.log(args[1].toInt32()); } });
```
### 재서명

도구 [Uber APK Signer](https://github.com/patrickfav/uber-apk-signer)는 동일한 키로 여러 APK에 서명하는 작업을 단순화하며, 앱에 변경을 가한 후 앱을 재서명하는 데 사용할 수 있습니다.

## 참조

- [https://www.appknox.com/security/xamarin-reverse-engineering-a-guide-for-penetration-testers](https://www.appknox.com/security/xamarin-reverse-engineering-a-guide-for-penetration-testers)
- [https://thecobraden.com/posts/unpacking_xamarin_assembly_stores/](https://thecobraden.com/posts/unpacking_xamarin_assembly_stores/)
- [https://medium.com/@justmobilesec/introduction-to-the-exploitation-of-xamarin-apps-fde4619a51bf](https://medium.com/@justmobilesec/introduction-to-the-exploitation-of-xamarin-apps-fde4619a51bf)
- [https://github.com/jakev/pyxamstore](https://github.com/jakev/pyxamstore)
- [https://pypi.org/project/xamarout/](https://pypi.org/project/xamarout/)
- [https://github.com/GoSecure/frida-xamarin-unpin](https://github.com/GoSecure/frida-xamarin-unpin)
- [https://gist.github.com/Diefunction/e26fce039efcab57aac342a4b2d48ff6](https://gist.github.com/Diefunction/e26fce039efcab57aac342a4b2d48ff6)
- [https://reverseengineering.stackexchange.com/questions/31716/deobfuscating-ios-dll-file-i-think-arm64](https://reverseengineering.stackexchange.com/questions/31716/deobfuscating-ios-dll-file-i-think-arm64)

{{#include ../banners/hacktricks-training.md}}
