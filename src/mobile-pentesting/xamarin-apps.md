# Xamarin Apps

{{#include ../banners/hacktricks-training.md}}

## **Βασικές Πληροφορίες**

Xamarin είναι μια **πλατφόρμα ανοιχτού κώδικα** σχεδιασμένη για developers ώστε να **δημιουργούν εφαρμογές για iOS, Android, και Windows** χρησιμοποιώντας τα frameworks .NET και C#. Αυτή η πλατφόρμα προσφέρει πρόσβαση σε πληθώρα εργαλείων και επεκτάσεων για αποδοτική δημιουργία σύγχρονων εφαρμογών.

### Αρχιτεκτονική του Xamarin

- Για **Android**, το Xamarin ενσωματώνεται με τα namespaces του Android και Java μέσω .NET bindings, λειτουργώντας μέσα στο περιβάλλον εκτέλεσης Mono μαζί με το Android Runtime (ART). Τα Managed Callable Wrappers (MCW) και Android Callable Wrappers (ACW) διευκολύνουν την επικοινωνία μεταξύ Mono και ART, τα οποία και τα δύο βασίζονται στον Linux kernel.
- Για **iOS**, οι εφαρμογές εκτελούνται υπό το Mono runtime, χρησιμοποιώντας πλήρη Ahead of Time (AOT) compilation για να μετατρέψουν τον C# .NET κώδικα σε ARM assembly language. Αυτή η διαδικασία τρέχει παράλληλα με το Objective-C Runtime σε ένα UNIX-like kernel.

### .NET Runtime and Mono Framework

Το **.NET framework** περιλαμβάνει assemblies, classes, και namespaces για την ανάπτυξη εφαρμογών, με το .NET Runtime να διαχειρίζεται την εκτέλεση του κώδικα. Προσφέρει ανεξαρτησία πλατφόρμας και συμβατότητα προς τα πίσω. Το **Mono Framework** είναι μια έκδοση ανοιχτού κώδικα του .NET framework, ξεκίνησε το 2005 για να επεκτείνει το .NET στο Linux, τώρα υποστηρίζεται από τη Microsoft και ηγείται από την Xamarin.

### Reverse Engineering Xamarin Apps

#### Decompilation of Xamarin Assemblies

Decompilation μετατρέπει τον compiled κώδικα πίσω σε πηγαίο κώδικα. Σε Windows, το Modules window στο Visual Studio μπορεί να εντοπίσει modules για decompilation, επιτρέποντας άμεση πρόσβαση σε third-party code και την εξαγωγή του source code για ανάλυση.

#### JIT vs AOT Compilation

- **Android** υποστηρίζει Just-In-Time (JIT) και Ahead-Of-Time (AOT) compilation, με ένα Hybrid AOT mode για βέλτιστη ταχύτητα εκτέλεσης. Το Full AOT είναι αποκλειστικό των Enterprise licenses.
- **iOS** χρησιμοποιεί αποκλειστικά AOT compilation λόγω των περιορισμών της Apple στην dynamic code execution.

### Εξαγωγή dll Files από APK/IPA

Για πρόσβαση στα assemblies σε ένα APK/IPA, αποσυμπιέστε το αρχείο και εξερευνήστε το assemblies directory. Για Android, εργαλεία όπως [XamAsmUnZ](https://github.com/cihansol/XamAsmUnZ) και [xamarin-decompress](https://github.com/NickstaDB/xamarin-decompress) μπορούν να αποσυμπιέσουν dll αρχεία.
```bash
python3 xamarin-decompress.py -o /path/to/decompressed/apk
```
Σε περιπτώσεις όπου, μετά το decompiling του APK, είναι δυνατό να δείτε το φάκελο unknown/assemblies/ με τα αρχεία `.dll` μέσα, μπορείτε να χρησιμοποιήσετε το [**dnSpy**](https://github.com/dnSpy/dnSpy) απευθείας πάνω στα `.dlls` για να τα αναλύσετε. Ωστόσο, μερικές φορές τα αρχεία `assemblies.blob` και `assemblies.manifest` βρίσκονται μέσα στο φάκελο unknown/assemblies/. Το εργαλείο [pyxamstore](https://github.com/jakev/pyxamstore) μπορεί να unpack το αρχείο `assemblies.blob` σε Xamarin apps, επιτρέποντας πρόσβαση στα .NET assemblies για περαιτέρω ανάλυση:
```bash
pyxamstore unpack -d /path/to/decompressed/apk/assemblies/
# After patching DLLs, rebuild the store
pyxamstore pack
```
Κάποιες πρόσφατες κατασκευές Xamarin/MAUI αποθηκεύουν συμπιεσμένες assemblies χρησιμοποιώντας τη μορφή **XALZ** μέσα στο `/assemblies.blob` ή στο `/resources/assemblies`. Μπορείτε γρήγορα να τις αποσυμπιέσετε με τη βιβλιοθήκη [xamarout](https://pypi.org/project/xamarout/):
```python
from xamarout import xalz
import os
for root, _, files in os.walk("."):
for f in files:
if open(os.path.join(root, f), 'rb').read(4) == b"XALZ":
xa = xalz.XamarinCompressedAssembly(os.path.join(root, f))
xa.write("decompressed/" + f)
```
iOS dll files είναι εύκολα προσβάσιμα για απομεταγλώττιση (decompilation), αποκαλύπτοντας σημαντικά τμήματα του κώδικα της εφαρμογής, που συχνά μοιράζονται κοινή βάση μεταξύ διαφορετικών πλατφορμών.

> **AOT σε iOS**: managed IL μεταγλωττίζεται σε native `*.aotdata.*` αρχεία. Το να τροποποιήσεις μόνο τα DLL δεν θα αλλάξει τη λογική· χρειάζεται να κάνεις hook τα native stubs (π.χ. με Frida) γιατί τα σώματα του IL είναι κενά placeholders.

### Static Analysis

Μόλις αποκτηθούν τα `.dll` είναι δυνατό να αναλυθεί ο .Net κώδικας στατικά χρησιμοποιώντας εργαλεία όπως [**dnSpy**](https://github.com/dnSpy/dnSpy) ή [**ILSpy**](https://github.com/icsharpcode/ILSpy) που επιτρέπουν την τροποποίηση του κώδικα της εφαρμογής. Αυτό μπορεί να είναι ιδιαίτερα χρήσιμο για να χειραγωγήσεις την εφαρμογή και να παρακάμψεις προστασίες, για παράδειγμα.\
Σημειώστε ότι μετά την τροποποίηση της εφαρμογής θα χρειαστεί να τη συσκευάσεις ξανά και να την υπογράψεις ξανά.

> dnSpy είναι archived; maintained forks όπως **dnSpyEx** συνεχίζουν να δουλεύουν με .NET 8/MAUI assemblies και διατηρούν debug symbols όταν επανα-αποθηκεύουν.

### Dynamic Analysis

Η δυναμική ανάλυση περιλαμβάνει τον έλεγχο για SSL pinning και τη χρήση εργαλείων όπως [Fridax](https://github.com/NorthwaveSecurity/fridax) για runtime τροποποιήσεις του .NET binary σε εφαρμογές Xamarin. Υπάρχουν Frida scripts διαθέσιμα για παράκαμψη ανίχνευσης root ή SSL pinning, ενισχύοντας τις δυνατότητες ανάλυσης.

Other interesting Frida scripts:

- [**xamarin-antiroot**](https://codeshare.frida.re/@Gand3lf/xamarin-antiroot/)
- [**xamarin-root-detect-bypass**](https://codeshare.frida.re/@nuschpl/xamarin-root-detect-bypass/)
- [**Frida-xamarin-unpin**](https://github.com/GoSecure/frida-xamarin-unpin)

Updated **Frida-xamarin-unpin** (Mono >=6) hooks `System.Net.Http.HttpClient.SendAsync` and swaps the handler to a permissive one, so it still works even when pinning is implemented in custom handlers. Run it after the app starts:
```bash
frida -U -l dist/xamarin-unpin.js com.target.app --no-pause
```
Γρήγορο πρότυπο για να hook managed methods με το ενσωματωμένο `frida-mono-api`:
```javascript
const mono = require('frida-mono-api');
Mono.ensureInitialized();
Mono.enumerateLoadedImages().forEach(i => console.log(i.name));
const klass = Mono.classFromName("Namespace", "Class");
const m = Mono.methodFromName(klass, "Method", 2);
Mono.intercept(m, { onEnter(args){ console.log(args[1].toInt32()); } });
```
### Επανυπογραφή

Το εργαλείο [Uber APK Signer](https://github.com/patrickfav/uber-apk-signer) απλοποιεί την υπογραφή πολλαπλών APK με το ίδιο κλειδί και μπορεί να χρησιμοποιηθεί για την επανυπογραφή μιας εφαρμογής μετά από αλλαγές που έχουν γίνει σε αυτή.

## Αναφορές

- [https://www.appknox.com/security/xamarin-reverse-engineering-a-guide-for-penetration-testers](https://www.appknox.com/security/xamarin-reverse-engineering-a-guide-for-penetration-testers)
- [https://thecobraden.com/posts/unpacking_xamarin_assembly_stores/](https://thecobraden.com/posts/unpacking_xamarin_assembly_stores/)
- [https://medium.com/@justmobilesec/introduction-to-the-exploitation-of-xamarin-apps-fde4619a51bf](https://medium.com/@justmobilesec/introduction-to-the-exploitation-of-xamarin-apps-fde4619a51bf)
- [https://github.com/jakev/pyxamstore](https://github.com/jakev/pyxamstore)
- [https://pypi.org/project/xamarout/](https://pypi.org/project/xamarout/)
- [https://github.com/GoSecure/frida-xamarin-unpin](https://github.com/GoSecure/frida-xamarin-unpin)
- [https://gist.github.com/Diefunction/e26fce039efcab57aac342a4b2d48ff6](https://gist.github.com/Diefunction/e26fce039efcab57aac342a4b2d48ff6)
- [https://reverseengineering.stackexchange.com/questions/31716/deobfuscating-ios-dll-file-i-think-arm64](https://reverseengineering.stackexchange.com/questions/31716/deobfuscating-ios-dll-file-i-think-arm64)

{{#include ../banners/hacktricks-training.md}}
