# Xamarin Apps

{{#include ../banners/hacktricks-training.md}}

## **기본 정보**

Xamarin은 .NET과 C# 프레임워크를 사용하여 **iOS, Android, Windows용 앱을 빌드**하도록 설계된 **오픈소스 플랫폼**입니다. 이 플랫폼은 현대적인 애플리케이션을 효율적으로 만들기 위한 다양한 도구와 확장을 제공합니다.

### Xamarin의 아키텍처

- **Android**의 경우, Xamarin은 .NET 바인딩을 통해 Android와 Java 네임스페이스와 통합되며 Mono 실행 환경에서 Android Runtime (ART)와 함께 동작합니다. Managed Callable Wrappers (MCW)와 Android Callable Wrappers (ACW)는 Mono와 ART 간의 통신을 중재하며, 둘 다 Linux 커널 위에서 동작합니다.
- **iOS**의 경우, 애플리케이션은 Mono 런타임 하에서 실행되며 전체 Ahead of Time (AOT) 컴파일을 통해 C# .NET 코드를 ARM 어셈블리 언어로 변환합니다. 이 과정은 Objective-C Runtime과 함께 UNIX-like 커널 위에서 실행됩니다.

### .NET Runtime 및 Mono Framework

**.NET framework**는 애플리케이션 개발을 위한 어셈블리, 클래스, 네임스페이스를 포함하며 .NET Runtime이 코드 실행을 관리합니다. 플랫폼 독립성과 하위 호환성을 제공합니다. **Mono Framework**는 .NET의 오픈소스 구현체로, 2005년 Linux로 .NET을 확장하기 위해 시작되었고 현재 Microsoft의 지원을 받으며 Xamarin이 주도합니다.

### Xamarin 앱 리버스 엔지니어링

#### Xamarin 어셈블리 디컴파일

디컴파일은 컴파일된 코드를 다시 소스 코드로 변환하는 과정입니다. Windows에서는 Visual Studio의 Modules 창에서 디컴파일할 모듈을 식별할 수 있어 서드파티 코드를 직접 확인하고 분석을 위해 소스 코드를 추출할 수 있습니다.

#### JIT vs AOT 컴파일

- **Android**는 Just-In-Time (JIT) 및 Ahead-Of-Time (AOT) 컴파일을 지원하며, 실행 속도 최적화를 위한 Hybrid AOT 모드를 제공합니다. Full AOT는 Enterprise 라이선스에만 제공됩니다.
- **iOS**는 Apple의 동적 코드 실행 제한 때문에 오직 AOT 컴파일만 사용합니다.

### APK/IPA에서 dll 파일 추출

APK/IPA의 어셈블리에 접근하려면 파일을 압축 해제하고 assemblies 디렉터리를 탐색하면 됩니다. Android의 경우 [XamAsmUnZ](https://github.com/cihansol/XamAsmUnZ) 및 [xamarin-decompress](https://github.com/NickstaDB/xamarin-decompress) 같은 도구로 dll 파일을 압축 해제할 수 있습니다.
```bash
python3 xamarin-decompress.py -o /path/to/decompressed/apk
```
APK를 디컴파일한 후 unknown/assemblies/ 폴더 안에 `.dll` 파일들이 보이는 경우, [**dnSpy**](https://github.com/dnSpy/dnSpy)를 사용해 해당 `.dll`들을 직접 분석할 수 있습니다. 그러나 때때로 `assemblies.blob`과 `assemblies.manifest` 파일이 unknown/assemblies/ 폴더 안에 들어있는 경우가 있습니다. 도구 [pyxamstore](https://github.com/jakev/pyxamstore)는 Xamarin 앱에서 `assemblies.blob` 파일을 풀어 .NET assemblies에 접근하여 추가 분석을 가능하게 합니다:
```bash
pyxamstore unpack -d /path/to/decompressed/apk/assemblies/
# After patching DLLs, rebuild the store
pyxamstore pack
```
일부 최신 Xamarin/MAUI 빌드는 `/assemblies.blob` 또는 `/resources/assemblies` 내부에 **XALZ** 형식으로 압축된 assemblies를 저장합니다. [xamarout](https://pypi.org/project/xamarout/) 라이브러리로 빠르게 압축을 해제할 수 있습니다:
```python
from xamarout import xalz
import os
for root, _, files in os.walk("."):
for f in files:
if open(os.path.join(root, f), 'rb').read(4) == b"XALZ":
xa = xalz.XamarinCompressedAssembly(os.path.join(root, f))
xa.write("decompressed/" + f)
```
iOS dll files는 디컴파일로 쉽게 접근할 수 있어 애플리케이션 코드의 상당 부분을 드러내며, 이 코드는 종종 다른 플랫폼 간에 공통 베이스를 공유합니다.

> **AOT on iOS**: managed IL은 네이티브 `*.aotdata.*` 파일로 컴파일됩니다. DLL만 패치해도 로직은 변경되지 않습니다; IL 바디가 빈 플레이스홀더이므로 네이티브 스텁을 후킹해야 합니다(예: Frida).

### 정적 분석

`.dll`를 얻으면 [**dnSpy**](https://github.com/dnSpy/dnSpy)나 [**ILSpy**](https://github.com/icsharpcode/ILSpy) 같은 도구로 .Net 코드를 정적으로 분석할 수 있으며, 이를 통해 앱 코드를 수정할 수 있습니다. 예를 들어 보호 기능을 우회하기 위해 앱을 변조하는 데 매우 유용할 수 있습니다.\
수정 후에는 앱을 다시 패키징하고 서명해야 한다는 점에 유의하세요.

> dnSpy는 아카이브 상태입니다; **dnSpyEx** 같은 유지 관리되는 포크는 .NET 8/MAUI 어셈블리와 계속 작동하며 다시 저장할 때 디버그 심볼을 보존합니다.

### 동적 분석

동적 분석은 SSL pinning 점검과 Xamarin 앱의 .NET 바이너리를 런타임에 수정하기 위해 [Fridax](https://github.com/NorthwaveSecurity/fridax) 같은 도구 사용을 포함합니다. Frida 스크립트는 root detection 또는 SSL pinning을 우회하는 데 사용 가능하여 분석 역량을 향상시킵니다.

Other interesting Frida scripts:

- [**xamarin-antiroot**](https://codeshare.frida.re/@Gand3lf/xamarin-antiroot/)
- [**xamarin-root-detect-bypass**](https://codeshare.frida.re/@nuschpl/xamarin-root-detect-bypass/)
- [**Frida-xamarin-unpin**](https://github.com/GoSecure/frida-xamarin-unpin)

업데이트된 **Frida-xamarin-unpin** (Mono >=6)은 `System.Net.Http.HttpClient.SendAsync`를 후킹하고 핸들러를 더 관대한 핸들러로 교체하므로, 커스텀 핸들러에 pinning이 구현되어 있어도 작동합니다. 앱이 시작한 후에 실행하세요:
```bash
frida -U -l dist/xamarin-unpin.js com.target.app --no-pause
```
번들된 `frida-mono-api`로 관리되는 메서드를 후킹하기 위한 빠른 템플릿:
```javascript
const mono = require('frida-mono-api');
Mono.ensureInitialized();
Mono.enumerateLoadedImages().forEach(i => console.log(i.name));
const klass = Mono.classFromName("Namespace", "Class");
const m = Mono.methodFromName(klass, "Method", 2);
Mono.intercept(m, { onEnter(args){ console.log(args[1].toInt32()); } });
```
### 재서명

도구 [Uber APK Signer](https://github.com/patrickfav/uber-apk-signer)는 동일한 키로 여러 APK에 서명하는 것을 단순화하며, 변경을 가한 후 앱을 재서명하는 데 사용할 수 있습니다.

## 참고자료

- [https://www.appknox.com/security/xamarin-reverse-engineering-a-guide-for-penetration-testers](https://www.appknox.com/security/xamarin-reverse-engineering-a-guide-for-penetration-testers)
- [https://thecobraden.com/posts/unpacking_xamarin_assembly_stores/](https://thecobraden.com/posts/unpacking_xamarin_assembly_stores/)
- [https://medium.com/@justmobilesec/introduction-to-the-exploitation-of-xamarin-apps-fde4619a51bf](https://medium.com/@justmobilesec/introduction-to-the-exploitation-of-xamarin-apps-fde4619a51bf)
- [https://github.com/jakev/pyxamstore](https://github.com/jakev/pyxamstore)
- [https://pypi.org/project/xamarout/](https://pypi.org/project/xamarout/)
- [https://github.com/GoSecure/frida-xamarin-unpin](https://github.com/GoSecure/frida-xamarin-unpin)
- [https://gist.github.com/Diefunction/e26fce039efcab57aac342a4b2d48ff6](https://gist.github.com/Diefunction/e26fce039efcab57aac342a4b2d48ff6)
- [https://reverseengineering.stackexchange.com/questions/31716/deobfuscating-ios-dll-file-i-think-arm64](https://reverseengineering.stackexchange.com/questions/31716/deobfuscating-ios-dll-file-i-think-arm64)

{{#include ../banners/hacktricks-training.md}}
