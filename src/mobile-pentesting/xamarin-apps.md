# Xamarin Apps

{{#include ../banners/hacktricks-training.md}}

## **Podstawowe informacje**

Xamarin jest **platformą open-source** zaprojektowaną dla deweloperów do **tworzenia aplikacji na iOS, Android i Windows** przy użyciu frameworków .NET i C#. Ta platforma daje dostęp do licznych narzędzi i rozszerzeń umożliwiających efektywne tworzenie nowoczesnych aplikacji.

### Architektura Xamarin

- Dla **Androida**, Xamarin integruje się z przestrzeniami nazw Android i Java poprzez powiązania .NET, działając w środowisku wykonawczym Mono obok Android Runtime (ART). Managed Callable Wrappers (MCW) i Android Callable Wrappers (ACW) ułatwiają komunikację między Mono a ART, z których oba są zbudowane na kernelu Linux.
- Dla **iOS**, aplikacje uruchamiają się pod runtime Mono, wykorzystując pełną kompilację Ahead of Time (AOT) do konwersji kodu C# .NET na kod asemblera ARM. Proces ten działa obok Objective-C Runtime na jądrze typu UNIX.

### .NET Runtime i Mono Framework

**.NET framework** zawiera assemblies, klasy i przestrzenie nazw do tworzenia aplikacji, a .NET Runtime zarządza wykonaniem kodu. Oferuje niezależność platformy i kompatybilność wsteczną. **Mono Framework** to wersja open-source .NET frameworku, zainicjowana w 2005 roku w celu rozszerzenia .NET na Linux; obecnie wspierana przez Microsoft i prowadzona przez Xamarin.

### Reverse Engineering Xamarin Apps

#### Decompilation of Xamarin Assemblies

Decompilation przekształca skompilowany kod z powrotem w kod źródłowy. W Windows okno Modules w Visual Studio może zidentyfikować moduły do dekompilacji, co pozwala na bezpośredni dostęp do kodu stron trzecich i wyodrębnienie kodu źródłowego do analizy.

#### JIT vs AOT Compilation

- **Android** obsługuje kompilację Just-In-Time (JIT) i Ahead-Of-Time (AOT), z trybem Hybrid AOT dla optymalnej szybkości wykonania. Pełne AOT jest dostępne wyłącznie w licencjach Enterprise.
- **iOS** wykorzystuje wyłącznie kompilację AOT z powodu ograniczeń Apple dotyczących dynamicznego wykonywania kodu.

### Wyodrębnianie plików dll z APK/IPA

Aby uzyskać dostęp do assemblies w APK/IPA, rozpakuj plik i przejrzyj katalog assemblies. Dla Androida narzędzia takie jak [XamAsmUnZ](https://github.com/cihansol/XamAsmUnZ) i [xamarin-decompress](https://github.com/NickstaDB/xamarin-decompress) potrafią rozpakować pliki dll.
```bash
python3 xamarin-decompress.py -o /path/to/decompressed/apk
```
W przypadkach, gdy po dekompilacji APK można zobaczyć folder unknown/assemblies/ z plikami `.dll` w środku, można użyć [**dnSpy**](https://github.com/dnSpy/dnSpy) bezpośrednio na tych `.dlls`, aby je analizować. Jednak czasami w folderze unknown/assemblies/ znajdują się pliki `assemblies.blob` i `assemblies.manifest`. Narzędzie [pyxamstore](https://github.com/jakev/pyxamstore) potrafi rozpakować plik `assemblies.blob` w aplikacjach Xamarin, umożliwiając dostęp do .NET assemblies w celu dalszej analizy:
```bash
pyxamstore unpack -d /path/to/decompressed/apk/assemblies/
# After patching DLLs, rebuild the store
pyxamstore pack
```
Niektóre nowsze kompilacje Xamarin/MAUI przechowują skompresowane assemblies w formacie **XALZ** wewnątrz `/assemblies.blob` lub `/resources/assemblies`. Możesz szybko je zdekompresować za pomocą biblioteki [xamarout](https://pypi.org/project/xamarout/):
```python
from xamarout import xalz
import os
for root, _, files in os.walk("."):
for f in files:
if open(os.path.join(root, f), 'rb').read(4) == b"XALZ":
xa = xalz.XamarinCompressedAssembly(os.path.join(root, f))
xa.write("decompressed/" + f)
```
iOS .dll files are readily accessible for decompilation, revealing significant portions of the application code, which often shares a common base across different platforms.

> **AOT on iOS**: zarządzane IL są kompilowane do natywnych plików `*.aotdata.*`. Modyfikacja samego DLL nie zmieni logiki; trzeba hookować natywne stuby (np. za pomocą Frida), ponieważ ciała IL są pustymi zastępcami.

### Static Analysis

Po uzyskaniu plików `.dll` możliwe jest statyczne przeanalizowanie kodu .Net przy użyciu narzędzi takich jak [**dnSpy**](https://github.com/dnSpy/dnSpy) lub [**ILSpy**](https://github.com/icsharpcode/ILSpy), które pozwolą na modyfikację kodu aplikacji. Może to być bardzo przydatne, np. do manipulowania aplikacją w celu ominięcia zabezpieczeń.\ Zauważ, że po zmodyfikowaniu aplikacji trzeba ją ponownie spakować i podpisać.

> dnSpy is archived; maintained forks like **dnSpyEx** keep working with .NET 8/MAUI assemblies and preserve debug symbols when re-saving.

### Dynamic Analysis

Analiza dynamiczna polega na sprawdzaniu SSL pinning i korzystaniu z narzędzi takich jak [Fridax](https://github.com/NorthwaveSecurity/fridax) do modyfikacji binarki .NET w czasie wykonywania w aplikacjach Xamarin. Skrypty Frida są dostępne do obejścia wykrywania roota lub SSL pinning, co zwiększa możliwości analizy.

Other interesting Frida scripts:

- [**xamarin-antiroot**](https://codeshare.frida.re/@Gand3lf/xamarin-antiroot/)
- [**xamarin-root-detect-bypass**](https://codeshare.frida.re/@nuschpl/xamarin-root-detect-bypass/)
- [**Frida-xamarin-unpin**](https://github.com/GoSecure/frida-xamarin-unpin)

Updated **Frida-xamarin-unpin** (Mono >=6) hooks `System.Net.Http.HttpClient.SendAsync` and swaps the handler to a permissive one, so it still works even when pinning is implemented in custom handlers. Run it after the app starts:
```bash
frida -U -l dist/xamarin-unpin.js com.target.app --no-pause
```
Szybki szablon do hookowania zarządzanych metod z dołączonym `frida-mono-api`:
```javascript
const mono = require('frida-mono-api');
Mono.ensureInitialized();
Mono.enumerateLoadedImages().forEach(i => console.log(i.name));
const klass = Mono.classFromName("Namespace", "Class");
const m = Mono.methodFromName(klass, "Method", 2);
Mono.intercept(m, { onEnter(args){ console.log(args[1].toInt32()); } });
```
### Ponowne podpisywanie

Narzędzie [Uber APK Signer](https://github.com/patrickfav/uber-apk-signer) upraszcza podpisywanie wielu APK przy użyciu tego samego klucza i może być użyte do ponownego podpisania aplikacji po wprowadzeniu w niej zmian.

## Referencje

- [https://www.appknox.com/security/xamarin-reverse-engineering-a-guide-for-penetration-testers](https://www.appknox.com/security/xamarin-reverse-engineering-a-guide-for-penetration-testers)
- [https://thecobraden.com/posts/unpacking_xamarin_assembly_stores/](https://thecobraden.com/posts/unpacking_xamarin_assembly_stores/)
- [https://medium.com/@justmobilesec/introduction-to-the-exploitation-of-xamarin-apps-fde4619a51bf](https://medium.com/@justmobilesec/introduction-to-the-exploitation-of-xamarin-apps-fde4619a51bf)
- [https://github.com/jakev/pyxamstore](https://github.com/jakev/pyxamstore)
- [https://pypi.org/project/xamarout/](https://pypi.org/project/xamarout/)
- [https://github.com/GoSecure/frida-xamarin-unpin](https://github.com/GoSecure/frida-xamarin-unpin)
- [https://gist.github.com/Diefunction/e26fce039efcab57aac342a4b2d48ff6](https://gist.github.com/Diefunction/e26fce039efcab57aac342a4b2d48ff6)
- [https://reverseengineering.stackexchange.com/questions/31716/deobfuscating-ios-dll-file-i-think-arm64](https://reverseengineering.stackexchange.com/questions/31716/deobfuscating-ios-dll-file-i-think-arm64)

{{#include ../banners/hacktricks-training.md}}
