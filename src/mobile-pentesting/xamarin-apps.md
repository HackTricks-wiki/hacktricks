# Xamarin Apps

{{#include ../banners/hacktricks-training.md}}

## **Grundlegende Informationen**

Xamarin ist eine **Open-Source-Plattform**, die Entwicklern ermöglicht, **Apps für iOS, Android und Windows zu erstellen** und dabei .NET- und C#-Frameworks zu verwenden. Diese Plattform bietet Zugriff auf zahlreiche Tools und Erweiterungen, um moderne Anwendungen effizient zu entwickeln.

### Xamarin's Architecture

- Für **Android** integriert Xamarin Android- und Java-Namespaces über .NET-Bindings und läuft innerhalb der Mono-Ausführungsumgebung neben dem Android Runtime (ART). Managed Callable Wrappers (MCW) und Android Callable Wrappers (ACW) ermöglichen die Kommunikation zwischen Mono und ART, die beide auf dem Linux-Kernel aufbauen.
- Für **iOS** laufen Anwendungen unter dem Mono runtime und nutzen vollständige Ahead of Time (AOT)-Kompilierung, um C# .NET-Code in ARM-Assembler umzuwandeln. Dieser Prozess läuft neben dem Objective-C Runtime auf einem UNIX-ähnlichen Kernel.

### .NET Runtime and Mono Framework

Das .NET framework enthält Assemblies, Klassen und Namespaces für die Anwendungsentwicklung, wobei das .NET Runtime die Codeausführung verwaltet. Es bietet Plattformunabhängigkeit und Abwärtskompatibilität. Das Mono Framework ist eine Open-Source-Version des .NET frameworks, die 2005 initiiert wurde, um .NET auf Linux zu bringen; inzwischen wird es von Microsoft unterstützt und von Xamarin geleitet.

### Reverse Engineering Xamarin Apps

#### Decompilation of Xamarin Assemblies

Decompilation wandelt kompilierten Code zurück in Quellcode. Unter Windows kann das Modules-Fenster in Visual Studio Module zur Decompilation identifizieren, wodurch direkter Zugriff auf Drittanbieter-Code und die Extraktion von Quellcode zur Analyse möglich wird.

#### JIT vs AOT Compilation

- **Android** unterstützt Just-In-Time (JIT) und Ahead-Of-Time (AOT)-Kompilierung, mit einem Hybrid-AOT-Modus für optimale Ausführungsgeschwindigkeit. Full AOT ist exklusiv für Enterprise-Lizenzen.
- **iOS** verwendet ausschließlich AOT-Kompilierung aufgrund von Apples Einschränkungen bei der dynamischen Codeausführung.

### Extracting dll Files from APK/IPA

Um auf die Assemblies in einer APK/IPA zuzugreifen, entpacke die Datei und durchsuche das assemblies-Verzeichnis. Für Android können Tools wie [XamAsmUnZ](https://github.com/cihansol/XamAsmUnZ) und [xamarin-decompress](https://github.com/NickstaDB/xamarin-decompress) dll-Dateien entpacken.
```bash
python3 xamarin-decompress.py -o /path/to/decompressed/apk
```
In cases where after decompiling the APK it's possible to see the unknown/assemblies/ folder with the `.dll` files inside it, it's possible to use [**dnSpy**](https://github.com/dnSpy/dnSpy) directly over the `.dlls` to analyze them. However, sometimes the `assemblies.blob` and `assemblies.manifest` files are inside the unknown/assemblies/ folder. The tool [pyxamstore](https://github.com/jakev/pyxamstore) can unpack the `assemblies.blob` file in Xamarin apps, allowing access to the .NET assemblies for further analysis:
```bash
pyxamstore unpack -d /path/to/decompressed/apk/assemblies/
# After patching DLLs, rebuild the store
pyxamstore pack
```
Einige neuere Xamarin/MAUI-Builds speichern komprimierte assemblies im **XALZ**-Format in `/assemblies.blob` oder `/resources/assemblies`. Du kannst sie schnell mit der [xamarout](https://pypi.org/project/xamarout/) library dekomprimieren:
```python
from xamarout import xalz
import os
for root, _, files in os.walk("."):
for f in files:
if open(os.path.join(root, f), 'rb').read(4) == b"XALZ":
xa = xalz.XamarinCompressedAssembly(os.path.join(root, f))
xa.write("decompressed/" + f)
```
iOS dll files sind leicht für decompilation zugänglich und offenbaren bedeutende Teile des Anwendungscodes, der oft eine gemeinsame Basis über verschiedene Plattformen hinweg hat.

> **AOT on iOS**: managed IL wird in native `*.aotdata.*`-Dateien kompiliert. Das Patchen der DLL allein ändert die Logik nicht; du musst native Stubs hooken (z. B. mit Frida), weil die IL bodies leere Platzhalter sind.

### Static Analysis

Sobald die `.dll`s vorliegen, ist es möglich, den .Net-Code statisch mit Tools wie [**dnSpy**](https://github.com/dnSpy/dnSpy) oder [**ILSpy**](https://github.com/icsharpcode/ILSpy) zu analysieren, die das Modifizieren des App-Codes erlauben. Das kann sehr nützlich sein, um die Anwendung zu tampern, z. B. protections zu bypassen.\
Beachte, dass du die App nach dem Modifizieren wieder packen und erneut sign musst.

> dnSpy ist archiviert; gepflegte Forks wie **dnSpyEx** funktionieren weiterhin mit .NET 8/MAUI assemblies und erhalten Debug-Symbole beim erneuten Speichern.

### Dynamic Analysis

Dynamische Analyse umfasst das Prüfen auf SSL pinning und die Verwendung von Tools wie [Fridax](https://github.com/NorthwaveSecurity/fridax) für runtime modifications der .NET-Binärdatei in Xamarin-Apps. Frida-Skripte sind verfügbar, um root detection oder SSL pinning zu bypassen und so die Analysefähigkeiten zu erweitern.

Other interesting Frida scripts:

- [**xamarin-antiroot**](https://codeshare.frida.re/@Gand3lf/xamarin-antiroot/)
- [**xamarin-root-detect-bypass**](https://codeshare.frida.re/@nuschpl/xamarin-root-detect-bypass/)
- [**Frida-xamarin-unpin**](https://github.com/GoSecure/frida-xamarin-unpin)

Updated **Frida-xamarin-unpin** (Mono >=6) hooks `System.Net.Http.HttpClient.SendAsync` and swaps the handler to a permissive one, so it still works even when pinning is implemented in custom handlers. Run it after the app starts:
```bash
frida -U -l dist/xamarin-unpin.js com.target.app --no-pause
```
Kurze Vorlage zum Hooken von managed Methoden mit dem mitgelieferten `frida-mono-api`:
```javascript
const mono = require('frida-mono-api');
Mono.ensureInitialized();
Mono.enumerateLoadedImages().forEach(i => console.log(i.name));
const klass = Mono.classFromName("Namespace", "Class");
const m = Mono.methodFromName(klass, "Method", 2);
Mono.intercept(m, { onEnter(args){ console.log(args[1].toInt32()); } });
```
### Neusignieren

Das Tool [Uber APK Signer](https://github.com/patrickfav/uber-apk-signer) vereinfacht das Signieren mehrerer APKs mit demselben Schlüssel und kann verwendet werden, um eine App nach vorgenommenen Änderungen neu zu signieren.

## Referenzen

- [https://www.appknox.com/security/xamarin-reverse-engineering-a-guide-for-penetration-testers](https://www.appknox.com/security/xamarin-reverse-engineering-a-guide-for-penetration-testers)
- [https://thecobraden.com/posts/unpacking_xamarin_assembly_stores/](https://thecobraden.com/posts/unpacking_xamarin_assembly_stores/)
- [https://medium.com/@justmobilesec/introduction-to-the-exploitation-of-xamarin-apps-fde4619a51bf](https://medium.com/@justmobilesec/introduction-to-the-exploitation-of-xamarin-apps-fde4619a51bf)
- [https://github.com/jakev/pyxamstore](https://github.com/jakev/pyxamstore)
- [https://pypi.org/project/xamarout/](https://pypi.org/project/xamarout/)
- [https://github.com/GoSecure/frida-xamarin-unpin](https://github.com/GoSecure/frida-xamarin-unpin)
- [https://gist.github.com/Diefunction/e26fce039efcab57aac342a4b2d48ff6](https://gist.github.com/Diefunction/e26fce039efcab57aac342a4b2d48ff6)
- [https://reverseengineering.stackexchange.com/questions/31716/deobfuscating-ios-dll-file-i-think-arm64](https://reverseengineering.stackexchange.com/questions/31716/deobfuscating-ios-dll-file-i-think-arm64)

{{#include ../banners/hacktricks-training.md}}
