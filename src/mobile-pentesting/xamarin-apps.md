# Xamarin Toepassings

{{#include ../banners/hacktricks-training.md}}

## **Basiese Inligting**

Xamarin is 'n **open-source platform** wat ontwerp is vir ontwikkelaars om **apps te bou vir iOS, Android en Windows** met behulp van die .NET- en C#-raamwerke. Hierdie platform bied toegang tot talle gereedskap en uitbreidings om moderne toepassings doeltreffend te skep.

### Xamarin se Argitektuur

- Vir **Android** integreer Xamarin met Android- en Java-namespaces deur .NET-bindings, werk binne die Mono-uitvoeringsomgewing saam met die Android Runtime (ART). Managed Callable Wrappers (MCW) en Android Callable Wrappers (ACW) fasiliteer kommunikasie tussen Mono en ART, beide gebou op die Linux-kern.
- Vir **iOS** hardloop toepassings onder die Mono runtime en maak gebruik van volledige Ahead of Time (AOT) kompilering om C# .NET-kode in ARM-assemblytaal om te skakel. Hierdie proses loop langs die Objective-C Runtime op 'n UNIX-agtige kern.

### .NET Runtime en Mono Framework

Die **.NET framework** sluit assemblies, klasse en namespaces in vir toepassingontwikkeling, met die .NET Runtime wat kode-uitvoering bestuur. Dit bied platformonafhanklikheid en agterwaartse versoenbaarheid. Die **Mono Framework** is 'n open-source-weergawwe van die .NET framework, begin in 2005 om .NET na Linux uit te brei, nou ondersteun deur Microsoft en gelei deur Xamarin.

### Omgekeerde Ingenieurswese van Xamarin-toepassings

#### Dekomplisering van Xamarin-assemblye

Dekomplisering transformeër saamgestelde kode terug in bronkode. In Windows kan die Modules window in Visual Studio modules identifiseer vir dekompilering, wat direkte toegang tot kode van derdepartye en die onttrekking van bronkode vir analise moontlik maak.

#### JIT vs AOT-kompilering

- **Android** ondersteun Just-In-Time (JIT) en Ahead-Of-Time (AOT) kompilering, met 'n Hybrid AOT-modus vir optimale uitvoersnelheid. Volledige AOT is eksklusief aan Enterprise-lisensies.
- **iOS** gebruik uitsluitlik AOT-kompilering weens Apple se beperkings op dinamiese kode-uitvoering.

### Uittrekking van dll-lêers uit APK/IPA

Om toegang tot die assemblies in 'n APK/IPA te kry, pak die lêer uit en ondersoek die assemblies-gids. Vir Android kan gereedskap soos [XamAsmUnZ](https://github.com/cihansol/XamAsmUnZ) en [xamarin-decompress](https://github.com/NickstaDB/xamarin-decompress) dll-lêers uitpak.
```bash
python3 xamarin-decompress.py -o /path/to/decompressed/apk
```
In gevalle waar dit, nadat die APK gedecompileer is, moontlik is om die unknown/assemblies/ gids met die `.dll` lêers daarin te sien, is dit moontlik om [**dnSpy**](https://github.com/dnSpy/dnSpy) direk oor die `.dlls` te gebruik om dit te analiseer. Soms is die `assemblies.blob` en `assemblies.manifest` lêers egter in die unknown/assemblies/ gids. Die hulpmiddel [pyxamstore](https://github.com/jakev/pyxamstore) kan die `assemblies.blob` lêer in Xamarin apps uitpak, wat toegang tot die .NET assemblies vir verdere analise moontlik maak:
```bash
pyxamstore unpack -d /path/to/decompressed/apk/assemblies/
# After patching DLLs, rebuild the store
pyxamstore pack
```
Sommige onlangse Xamarin/MAUI builds stoor saamgeperste assemblies in die **XALZ**-formaat binne `/assemblies.blob` of `/resources/assemblies`. Jy kan dit vinnig dekomprimeer met die [xamarout](https://pypi.org/project/xamarout/) library:
```python
from xamarout import xalz
import os
for root, _, files in os.walk("."):
for f in files:
if open(os.path.join(root, f), 'rb').read(4) == b"XALZ":
xa = xalz.XamarinCompressedAssembly(os.path.join(root, f))
xa.write("decompressed/" + f)
```
iOS dll-lêers is maklik beskikbaar vir dekompilasie, wat groot gedeeltes van die toepassingskode openbaar — kode wat dikwels 'n gemeenskaplike basis oor verskeie platforms het.

> **AOT on iOS**: managed IL word saamgestel na native `*.aotdata.*` lêers. Om net die DLL te patch sal nie die logika verander nie; jy moet native stubs hook (bv. met Frida) omdat die IL-bodies leë plekhouers is.

### Statiese analise

Wanneer die `.dll`s bekom is, is dit moontlik om die .Net-kode staties te ontleed met gereedskap soos [**dnSpy**](https://github.com/dnSpy/dnSpy) of [**ILSpy**](https://github.com/icsharpcode/ILSpy) wat jou toelaat om die kode van die app te wysig. Dit kan baie nuttig wees om byvoorbeeld die toepassing te manipuleer om beskermings te omseil.\
Let daarop dat nadat jy die app gemodifiseer het, jy dit weer moet verpakk en weer moet onderteken.

> dnSpy is gearchiveer; maintained forks like **dnSpyEx** keep working with .NET 8/MAUI assemblies and preserve debug symbols when re-saving.

### Dinamiese analise

Dinamiese ontleding behels die nagaan van SSL pinning en die gebruik van gereedskap soos [Fridax](https://github.com/NorthwaveSecurity/fridax) vir runtime-wysigings van die .NET-binaire in Xamarin-apps. Frida-skripte is beskikbaar om root-detectie of SSL pinning te omseil, wat ontledingsvermoëns verbeter.

Other interesting Frida scripts:

- [**xamarin-antiroot**](https://codeshare.frida.re/@Gand3lf/xamarin-antiroot/)
- [**xamarin-root-detect-bypass**](https://codeshare.frida.re/@nuschpl/xamarin-root-detect-bypass/)
- [**Frida-xamarin-unpin**](https://github.com/GoSecure/frida-xamarin-unpin)

Updated **Frida-xamarin-unpin** (Mono >=6) hooks `System.Net.Http.HttpClient.SendAsync` and swaps the handler to a permissive one, so it still works even when pinning is implemented in custom handlers. Run it after the app starts:
```bash
frida -U -l dist/xamarin-unpin.js com.target.app --no-pause
```
Vinnige sjabloon om managed methods met die ingeslote `frida-mono-api` te hook:
```javascript
const mono = require('frida-mono-api');
Mono.ensureInitialized();
Mono.enumerateLoadedImages().forEach(i => console.log(i.name));
const klass = Mono.classFromName("Namespace", "Class");
const m = Mono.methodFromName(klass, "Method", 2);
Mono.intercept(m, { onEnter(args){ console.log(args[1].toInt32()); } });
```
### Herondertekening

Die hulpmiddel [Uber APK Signer](https://github.com/patrickfav/uber-apk-signer) maak dit makliker om verskeie APK's met dieselfde sleutel te onderteken, en kan gebruik word om 'n app opnuut te onderteken nadat daar veranderinge aan aangebring is.

## Verwysings

- [https://www.appknox.com/security/xamarin-reverse-engineering-a-guide-for-penetration-testers](https://www.appknox.com/security/xamarin-reverse-engineering-a-guide-for-penetration-testers)
- [https://thecobraden.com/posts/unpacking_xamarin_assembly_stores/](https://thecobraden.com/posts/unpacking_xamarin_assembly_stores/)
- [https://medium.com/@justmobilesec/introduction-to-the-exploitation-of-xamarin-apps-fde4619a51bf](https://medium.com/@justmobilesec/introduction-to-the-exploitation-of-xamarin-apps-fde4619a51bf)
- [https://github.com/jakev/pyxamstore](https://github.com/jakev/pyxamstore)
- [https://pypi.org/project/xamarout/](https://pypi.org/project/xamarout/)
- [https://github.com/GoSecure/frida-xamarin-unpin](https://github.com/GoSecure/frida-xamarin-unpin)
- [https://gist.github.com/Diefunction/e26fce039efcab57aac342a4b2d48ff6](https://gist.github.com/Diefunction/e26fce039efcab57aac342a4b2d48ff6)
- [https://reverseengineering.stackexchange.com/questions/31716/deobfuscating-ios-dll-file-i-think-arm64](https://reverseengineering.stackexchange.com/questions/31716/deobfuscating-ios-dll-file-i-think-arm64)

{{#include ../banners/hacktricks-training.md}}
