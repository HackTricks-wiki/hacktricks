# Xamarin Aansoeke

{{#include ../banners/hacktricks-training.md}}

## **Basiese Inligting**

Xamarin is 'n **oopbronplatform** ontwerp vir ontwikkelaars om **aansoeke vir iOS, Android en Windows te bou** met behulp van die .NET- en C#-raamwerke. Die platform bied toegang tot talle instrumente en uitbreidings om moderne aansoeke doeltreffend te skep.

### Xamarin se Argitektuur

- Vir **Android** integreer Xamarin met Android- en Java-namespaces deur .NET-bindings, en werk binne die Mono-uitvoeringsomgewing langs die Android Runtime (ART). Managed Callable Wrappers (MCW) en Android Callable Wrappers (ACW) fasiliteer kommunikasie tussen Mono en ART, wat albei op die Linux-kern gebou is.
- Vir **iOS** loop aansoeke onder die Mono-runtime en gebruik volle Ahead of Time (AOT)-samestelling om C# .NET-kode na ARM-assemblytaal om te skakel. Hierdie proses loop langs die Objective-C Runtime op 'n UNIX-agtige kern.

### .NET Runtime en Mono-raamwerk

Die **.NET framework** sluit assemblies, klasse en namespaces in vir toepassingsontwikkeling, met die .NET Runtime wat kode-uitvoering bestuur. Dit bied platformonafhanklikheid en agteruitkompatibiliteit. Die **Mono Framework** is 'n oopbronweergawe van die .NET-framework, begin in 2005 om .NET na Linux uit te brei, nou ondersteun deur Microsoft en gelei deur Xamarin.

### Omgekeerde Ingenieurswese van Xamarin-aansoeke

#### Dekompilering van Xamarin-assemblies

Dekompilering omskep saamgestelde kode terug na bronkode. In Windows kan die Modules-venster in Visual Studio modules identifiseer vir dekompilering, wat direkte toegang tot kode van derdepartye en die onttrekking van bronkode vir analise toelaat.

#### JIT vs AOT-samestelling

- **Android** ondersteun Just-In-Time (JIT) en Ahead-Of-Time (AOT)-samestelling, met 'n Hybrid AOT-modus vir optimale uitvoeringsnelheid. Volle AOT is uitsluitlik beskikbaar vir Enterprise-lisensies.
- **iOS** gebruik uitsluitlik AOT-samestelling as gevolg van Apple se beperkings op dinamiese kode-uitvoering.

### Uittrekking van dll-lêers uit APK/IPA

Om toegang tot die assemblies in 'n APK/IPA te kry, pak die lêer uit en verken die assemblies-gids. Vir Android kan hulpmiddels soos [XamAsmUnZ](https://github.com/cihansol/XamAsmUnZ) en [xamarin-decompress](https://github.com/NickstaDB/xamarin-decompress) dll-lêers ontpak.
```bash
python3 xamarin-decompress.py -o /path/to/decompressed/apk
```
In gevalle waar, nadat die APK gedecompileer is, dit moontlik is om die unknown/assemblies/ gids met die `.dll` lêers daarin te sien, is dit moontlik om [**dnSpy**](https://github.com/dnSpy/dnSpy) direk oor die `.dlls` te gebruik om dit te ontleed. Soms egter is die `assemblies.blob` en `assemblies.manifest` lêers binne die unknown/assemblies/ gids. Die hulpmiddel [pyxamstore](https://github.com/jakev/pyxamstore) kan die `assemblies.blob` lêer in Xamarin apps uitpak, wat toegang tot die .NET assemblies vir verdere ontleding moontlik maak:
```bash
pyxamstore unpack -d /path/to/decompressed/apk/assemblies/
# After patching DLLs, rebuild the store
pyxamstore pack
```
Sommige onlangse Xamarin/MAUI builds stoor saamgeperste assemblies in die **XALZ**-formaat binne `/assemblies.blob` of `/resources/assemblies`. Jy kan hulle vinnig uitpak met die [xamarout](https://pypi.org/project/xamarout/) biblioteek:
```python
from xamarout import xalz
import os
for root, _, files in os.walk("."):
for f in files:
if open(os.path.join(root, f), 'rb').read(4) == b"XALZ":
xa = xalz.XamarinCompressedAssembly(os.path.join(root, f))
xa.write("decompressed/" + f)
```
iOS dll files are readily accessible for decompilation, revealing significant portions of the application code, which often shares a common base across different platforms.

> **AOT on iOS**: managed IL is compiled into native `*.aotdata.*` files. Patching the DLL alone will not change logic; you need to hook native stubs (e.g., with Frida) because the IL bodies are empty placeholders.

### Static Analysis

Sodra die `.dll`s verkry is, is dit moontlik om die .Net-kode staties te ontleed deur hulpmiddels soos [**dnSpy**](https://github.com/dnSpy/dnSpy) of [**ILSpy**](https://github.com/icsharpcode/ILSpy) te gebruik wat toelaat om die kode van die app te modifiseer. Dit kan uiters nuttig wees om die toepassing te manipuleer om byvoorbeeld beskermings te omseil.\
Let wel dat nadat jy die app gemodifiseer het jy dit weer moet pak en weer moet onderteken.

> dnSpy is archived; maintained forks like **dnSpyEx** keep working with .NET 8/MAUI assemblies and preserve debug symbols when re-saving.

### Dynamic Analysis

Dynamic analysis behels die kontrole van SSL pinning en die gebruik van gereedskap soos [Fridax](https://github.com/NorthwaveSecurity/fridax) vir runtime-wysigings van die .NET-binaire in Xamarin-apps. Frida-skripte is beskikbaar om root-opsporing of SSL pinning te omseil, wat ontledingsvermoëns verbeter.

Other interesting Frida scripts:

- [**xamarin-antiroot**](https://codeshare.frida.re/@Gand3lf/xamarin-antiroot/)
- [**xamarin-root-detect-bypass**](https://codeshare.frida.re/@nuschpl/xamarin-root-detect-bypass/)
- [**Frida-xamarin-unpin**](https://github.com/GoSecure/frida-xamarin-unpin)

Updated **Frida-xamarin-unpin** (Mono >=6) hooks `System.Net.Http.HttpClient.SendAsync` and swaps the handler to a permissive one, so it still works even when pinning is implemented in custom handlers. Run it after the app starts:
```bash
frida -U -l dist/xamarin-unpin.js com.target.app --no-pause
```
Vinnige sjabloon om managed methods te hook met die ingesluit `frida-mono-api`:
```javascript
const mono = require('frida-mono-api');
Mono.ensureInitialized();
Mono.enumerateLoadedImages().forEach(i => console.log(i.name));
const klass = Mono.classFromName("Namespace", "Class");
const m = Mono.methodFromName(klass, "Method", 2);
Mono.intercept(m, { onEnter(args){ console.log(args[1].toInt32()); } });
```
### Herondertekening

Die hulpmiddel [Uber APK Signer](https://github.com/patrickfav/uber-apk-signer) vereenvoudig die ondertekening van meerdere APKs met dieselfde sleutel, en kan gebruik word om 'n app weer te onderteken nadat veranderinge daaraan aangebring is.

## Verwysings

- [https://www.appknox.com/security/xamarin-reverse-engineering-a-guide-for-penetration-testers](https://www.appknox.com/security/xamarin-reverse-engineering-a-guide-for-penetration-testers)
- [https://thecobraden.com/posts/unpacking_xamarin_assembly_stores/](https://thecobraden.com/posts/unpacking_xamarin_assembly_stores/)
- [https://medium.com/@justmobilesec/introduction-to-the-exploitation-of-xamarin-apps-fde4619a51bf](https://medium.com/@justmobilesec/introduction-to-the-exploitation-of-xamarin-apps-fde4619a51bf)
- [https://github.com/jakev/pyxamstore](https://github.com/jakev/pyxamstore)
- [https://pypi.org/project/xamarout/](https://pypi.org/project/xamarout/)
- [https://github.com/GoSecure/frida-xamarin-unpin](https://github.com/GoSecure/frida-xamarin-unpin)
- [https://gist.github.com/Diefunction/e26fce039efcab57aac342a4b2d48ff6](https://gist.github.com/Diefunction/e26fce039efcab57aac342a4b2d48ff6)
- [https://reverseengineering.stackexchange.com/questions/31716/deobfuscating-ios-dll-file-i-think-arm64](https://reverseengineering.stackexchange.com/questions/31716/deobfuscating-ios-dll-file-i-think-arm64)

{{#include ../banners/hacktricks-training.md}}
