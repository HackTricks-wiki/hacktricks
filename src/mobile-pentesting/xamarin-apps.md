# Xamarin Apps

{{#include ../banners/hacktricks-training.md}}

## **Informações Básicas**

Xamarin é uma plataforma de código aberto projetada para desenvolvedores criarem apps para iOS, Android e Windows usando os frameworks .NET e C#. A plataforma oferece acesso a diversas ferramentas e extensões para criar aplicações modernas de forma eficiente.

### Arquitetura do Xamarin

- Para **Android**, o Xamarin integra com namespaces Android e Java através de bindings .NET, operando dentro do runtime de execução Mono junto ao Android Runtime (ART). Managed Callable Wrappers (MCW) e Android Callable Wrappers (ACW) facilitam a comunicação entre Mono e ART, ambos construídos sobre o kernel Linux.
- Para **iOS**, as aplicações rodam sob o runtime Mono, utilizando compilação completa Ahead of Time (AOT) para converter código C# .NET em assembly ARM. Esse processo executa junto ao Objective-C Runtime em um kernel do tipo UNIX.

### .NET Runtime and Mono Framework

O framework .NET inclui assemblies, classes e namespaces para desenvolvimento de aplicações, com o .NET Runtime gerenciando a execução do código. Ele oferece independência de plataforma e compatibilidade retroativa. O Mono Framework é uma versão de código aberto do .NET framework, iniciada em 2005 para estender o .NET ao Linux, agora suportada pela Microsoft e liderada pela Xamarin.

### Reverse Engineering Xamarin Apps

#### Decompilation of Xamarin Assemblies

A decompilação transforma código compilado de volta em código-fonte. No Windows, a janela Modules do Visual Studio pode identificar módulos para decompilação, permitindo acesso direto a código de terceiros e a extração do código-fonte para análise.

#### JIT vs AOT Compilation

- **Android** suporta Just-In-Time (JIT) e Ahead-Of-Time (AOT) compilation, com um modo Hybrid AOT para otimizar a velocidade de execução. Full AOT é exclusivo de licenças Enterprise.
- **iOS** emprega exclusivamente compilação AOT devido às restrições da Apple sobre execução dinâmica de código.

### Extracting dll Files from APK/IPA

Para acessar os assemblies em um APK/IPA, descompacte o arquivo e explore o diretório assemblies. Para Android, ferramentas como [XamAsmUnZ](https://github.com/cihansol/XamAsmUnZ) e [xamarin-decompress](https://github.com/NickstaDB/xamarin-decompress) podem descomprimir arquivos dll.
```bash
python3 xamarin-decompress.py -o /path/to/decompressed/apk
```
Em casos em que, após descompilar o APK, é possível ver a pasta unknown/assemblies/ com os arquivos `.dll` dentro, é possível usar [**dnSpy**](https://github.com/dnSpy/dnSpy) diretamente sobre os `.dlls` para analisá-los. Contudo, por vezes os arquivos `assemblies.blob` e `assemblies.manifest` estão dentro da pasta unknown/assemblies/. A ferramenta [pyxamstore](https://github.com/jakev/pyxamstore) pode desempacotar o arquivo `assemblies.blob` em aplicativos Xamarin, permitindo acesso às .NET assemblies para análise posterior:
```bash
pyxamstore unpack -d /path/to/decompressed/apk/assemblies/
# After patching DLLs, rebuild the store
pyxamstore pack
```
Algumas builds recentes do Xamarin/MAUI armazenam assemblies comprimidos usando o formato **XALZ** dentro de `/assemblies.blob` ou `/resources/assemblies`. Você pode descomprimí-los rapidamente com a biblioteca [xamarout](https://pypi.org/project/xamarout/):
```python
from xamarout import xalz
import os
for root, _, files in os.walk("."):
for f in files:
if open(os.path.join(root, f), 'rb').read(4) == b"XALZ":
xa = xalz.XamarinCompressedAssembly(os.path.join(root, f))
xa.write("decompressed/" + f)
```
Arquivos dll do iOS estão prontamente acessíveis para decompilação, revelando porções significativas do código da aplicação, que frequentemente compartilha uma base comum entre diferentes plataformas.

> **AOT on iOS**: managed IL é compilado em arquivos nativos `*.aotdata.*` files. Aplicar patch apenas no DLL não mudará a lógica; é preciso hookar os native stubs (e.g., with Frida) porque os corpos IL são placeholders vazios.

### Static Analysis

Uma vez obtidos os `.dll`s é possível analisar o código .Net estaticamente usando ferramentas como [**dnSpy**](https://github.com/dnSpy/dnSpy) ou [**ILSpy**](https://github.com/icsharpcode/ILSpy) que permitem modificar o código do app. Isso pode ser muito útil para adulterar a aplicação e, por exemplo, contornar proteções.\
Note que após modificar o app você precisará empacotar novamente e assinar novamente.

> dnSpy is archived; maintained forks like **dnSpyEx** keep working with .NET 8/MAUI assemblies and preserve debug symbols when re-saving.

### Dynamic Analysis

A análise dinâmica envolve verificar SSL pinning e usar ferramentas como [Fridax](https://github.com/NorthwaveSecurity/fridax) para modificações em tempo de execução do binário .NET em apps Xamarin. Scripts Frida estão disponíveis para contornar detecção de root ou SSL pinning, ampliando as capacidades de análise.

Other interesting Frida scripts:

- [**xamarin-antiroot**](https://codeshare.frida.re/@Gand3lf/xamarin-antiroot/)
- [**xamarin-root-detect-bypass**](https://codeshare.frida.re/@nuschpl/xamarin-root-detect-bypass/)
- [**Frida-xamarin-unpin**](https://github.com/GoSecure/frida-xamarin-unpin)

Updated **Frida-xamarin-unpin** (Mono >=6) faz hook em `System.Net.Http.HttpClient.SendAsync` e troca o handler por um permissivo, então ainda funciona mesmo quando o pinning é implementado em handlers customizados. Execute-o após o app iniciar:
```bash
frida -U -l dist/xamarin-unpin.js com.target.app --no-pause
```
Template rápido para hook de métodos gerenciados com o `frida-mono-api` incluído:
```javascript
const mono = require('frida-mono-api');
Mono.ensureInitialized();
Mono.enumerateLoadedImages().forEach(i => console.log(i.name));
const klass = Mono.classFromName("Namespace", "Class");
const m = Mono.methodFromName(klass, "Method", 2);
Mono.intercept(m, { onEnter(args){ console.log(args[1].toInt32()); } });
```
### Reassinatura

A ferramenta [Uber APK Signer](https://github.com/patrickfav/uber-apk-signer) simplifica a assinatura de múltiplos APKs com a mesma chave e pode ser usada para reassinar um app após alterações terem sido realizadas.

## Referências

- [https://www.appknox.com/security/xamarin-reverse-engineering-a-guide-for-penetration-testers](https://www.appknox.com/security/xamarin-reverse-engineering-a-guide-for-penetration-testers)
- [https://thecobraden.com/posts/unpacking_xamarin_assembly_stores/](https://thecobraden.com/posts/unpacking_xamarin_assembly_stores/)
- [https://medium.com/@justmobilesec/introduction-to-the-exploitation-of-xamarin-apps-fde4619a51bf](https://medium.com/@justmobilesec/introduction-to-the-exploitation-of-xamarin-apps-fde4619a51bf)
- [https://github.com/jakev/pyxamstore](https://github.com/jakev/pyxamstore)
- [https://pypi.org/project/xamarout/](https://pypi.org/project/xamarout/)
- [https://github.com/GoSecure/frida-xamarin-unpin](https://github.com/GoSecure/frida-xamarin-unpin)
- [https://gist.github.com/Diefunction/e26fce039efcab57aac342a4b2d48ff6](https://gist.github.com/Diefunction/e26fce039efcab57aac342a4b2d48ff6)
- [https://reverseengineering.stackexchange.com/questions/31716/deobfuscating-ios-dll-file-i-think-arm64](https://reverseengineering.stackexchange.com/questions/31716/deobfuscating-ios-dll-file-i-think-arm64)

{{#include ../banners/hacktricks-training.md}}
