# Xamarin Apps

{{#include ../banners/hacktricks-training.md}}

## **Основна інформація**

Xamarin — **відкрита платформа**, створена для розробників, щоб **створювати додатки для iOS, Android та Windows**, використовуючи .NET та C# фреймворки. Ця платформа надає доступ до численних інструментів та розширень для ефективної розробки сучасних додатків.

### Архітектура Xamarin

- Для **Android** Xamarin інтегрується з Android та Java неймспейсами через .NET bindings, працюючи в середовищі виконання Mono поряд з Android Runtime (ART). Managed Callable Wrappers (MCW) та Android Callable Wrappers (ACW) забезпечують взаємодію між Mono та ART, обидва з яких базуються на ядрі Linux.
- Для **iOS** додатки працюють під Mono runtime, використовуючи повну Ahead of Time (AOT) компіляцію для перетворення C# .NET коду в ARM assembly. Цей процес виконується поряд з Objective-C Runtime на UNIX-подібному ядрі.

### .NET Runtime і Mono Framework

**.NET framework** включає збірки, класи та неймспейси для розробки додатків, а .NET Runtime керує виконанням коду. Він забезпечує незалежність від платформи та зворотну сумісність. **Mono Framework** — це відкрита реалізація .NET framework, започаткована у 2005 році для перенесення .NET на Linux, наразі підтримується Microsoft та очолюється Xamarin.

### Reverse Engineering Xamarin Apps

#### Decompilation of Xamarin Assemblies

Decompilation перетворює скомпільований код назад у вихідний код. У Windows вікно Modules у Visual Studio може ідентифікувати модулі для декомпіляції, що дозволяє безпосередній доступ до стороннього коду та витягнення вихідного коду для аналізу.

#### JIT vs AOT Compilation

- **Android** підтримує Just-In-Time (JIT) та Ahead-Of-Time (AOT) компіляцію, з Hybrid AOT режимом для оптимальної швидкості виконання. Повна AOT доступна лише для Enterprise ліцензій.
- **iOS** використовує виключно AOT компіляцію через обмеження Apple на динамічне виконання коду.

### Extracting dll Files from APK/IPA

Щоб отримати доступ до збірок всередині APK/IPA, розпакуйте файл і перегляньте директорію assemblies. Для Android інструменти на кшталт [XamAsmUnZ](https://github.com/cihansol/XamAsmUnZ) та [xamarin-decompress](https://github.com/NickstaDB/xamarin-decompress) можуть розпаковувати dll файли.
```bash
python3 xamarin-decompress.py -o /path/to/decompressed/apk
```
У випадках, коли після декомпіляції APK видно папку unknown/assemblies/ з файлами `.dll` всередині, можна використовувати [**dnSpy**](https://github.com/dnSpy/dnSpy) безпосередньо для аналізу цих `.dll`. Проте іноді в папці unknown/assemblies/ знаходяться файли `assemblies.blob` та `assemblies.manifest`. Інструмент [pyxamstore](https://github.com/jakev/pyxamstore) може розпакувати файл `assemblies.blob` у додатках Xamarin, що дозволяє отримати доступ до .NET assemblies для подальшого аналізу:
```bash
pyxamstore unpack -d /path/to/decompressed/apk/assemblies/
# After patching DLLs, rebuild the store
pyxamstore pack
```
Деякі сучасні збірки Xamarin/MAUI зберігають стиснуті збірки у форматі **XALZ** всередині `/assemblies.blob` або `/resources/assemblies`. Ви можете швидко розпакувати їх за допомогою бібліотеки [xamarout](https://pypi.org/project/xamarout/):
```python
from xamarout import xalz
import os
for root, _, files in os.walk("."):
for f in files:
if open(os.path.join(root, f), 'rb').read(4) == b"XALZ":
xa = xalz.XamarinCompressedAssembly(os.path.join(root, f))
xa.write("decompressed/" + f)
```
iOS .dll files are readily accessible for decompilation, revealing significant portions of the application code, which often shares a common base across different platforms.

> **AOT on iOS**: managed IL is compiled into native `*.aotdata.*` files. Patching the DLL alone will not change logic; you need to hook native stubs (e.g., with Frida) because the IL bodies are empty placeholders.

### Static Analysis

Once the `.dll`s are obtained it's possible to analyze the .Net code statically using tools such as [**dnSpy**](https://github.com/dnSpy/dnSpy) or [**ILSpy**](https://github.com/icsharpcode/ILSpy) that will allow modifying the code of the app. This can be super useful to tamper the application to bypass protections for example.\
Note that after modifying the app you will need to pack it back again and sign it again.

> dnSpy is archived; maintained forks like **dnSpyEx** keep working with .NET 8/MAUI assemblies and preserve debug symbols when re-saving.

### Dynamic Analysis

Dynamic analysis involves checking for SSL pinning and using tools like [Fridax](https://github.com/NorthwaveSecurity/fridax) for runtime modifications of the .NET binary in Xamarin apps. Frida scripts are available to bypass root detection or SSL pinning, enhancing analysis capabilities.

Other interesting Frida scripts:

- [**xamarin-antiroot**](https://codeshare.frida.re/@Gand3lf/xamarin-antiroot/)
- [**xamarin-root-detect-bypass**](https://codeshare.frida.re/@nuschpl/xamarin-root-detect-bypass/)
- [**Frida-xamarin-unpin**](https://github.com/GoSecure/frida-xamarin-unpin)

Updated **Frida-xamarin-unpin** (Mono >=6) hooks `System.Net.Http.HttpClient.SendAsync` and swaps the handler to a permissive one, so it still works even when pinning is implemented in custom handlers. Run it after the app starts:
```bash
frida -U -l dist/xamarin-unpin.js com.target.app --no-pause
```
Швидкий шаблон для hook керованих методів за допомогою вбудованого `frida-mono-api`:
```javascript
const mono = require('frida-mono-api');
Mono.ensureInitialized();
Mono.enumerateLoadedImages().forEach(i => console.log(i.name));
const klass = Mono.classFromName("Namespace", "Class");
const m = Mono.methodFromName(klass, "Method", 2);
Mono.intercept(m, { onEnter(args){ console.log(args[1].toInt32()); } });
```
### Повторне підписання

Інструмент [Uber APK Signer](https://github.com/patrickfav/uber-apk-signer) спрощує підписування кількох APK одним і тим же ключем та може бути використаний для повторного підписання додатку після внесення в нього змін.

## Посилання

- [https://www.appknox.com/security/xamarin-reverse-engineering-a-guide-for-penetration-testers](https://www.appknox.com/security/xamarin-reverse-engineering-a-guide-for-penetration-testers)
- [https://thecobraden.com/posts/unpacking_xamarin_assembly_stores/](https://thecobraden.com/posts/unpacking_xamarin_assembly_stores/)
- [https://medium.com/@justmobilesec/introduction-to-the-exploitation-of-xamarin-apps-fde4619a51bf](https://medium.com/@justmobilesec/introduction-to-the-exploitation-of-xamarin-apps-fde4619a51bf)
- [https://github.com/jakev/pyxamstore](https://github.com/jakev/pyxamstore)
- [https://pypi.org/project/xamarout/](https://pypi.org/project/xamarout/)
- [https://github.com/GoSecure/frida-xamarin-unpin](https://github.com/GoSecure/frida-xamarin-unpin)
- [https://gist.github.com/Diefunction/e26fce039efcab57aac342a4b2d48ff6](https://gist.github.com/Diefunction/e26fce039efcab57aac342a4b2d48ff6)
- [https://reverseengineering.stackexchange.com/questions/31716/deobfuscating-ios-dll-file-i-think-arm64](https://reverseengineering.stackexchange.com/questions/31716/deobfuscating-ios-dll-file-i-think-arm64)

{{#include ../banners/hacktricks-training.md}}
