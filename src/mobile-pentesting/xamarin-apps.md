# Xamarin アプリ

{{#include ../banners/hacktricks-training.md}}

## **基本情報**

Xamarin は **オープンソースのプラットフォーム**で、.NET と C# フレームワークを使用して **iOS、Android、Windows 向けのアプリを構築**するために設計されています。このプラットフォームは、多くのツールや拡張機能にアクセスでき、モダンなアプリケーションを効率的に作成できます。

### Xamarin のアーキテクチャ

- For **Android**, Xamarin integrates with Android and Java namespaces through .NET bindings, operating within the Mono execution environment alongside the Android Runtime (ART). Managed Callable Wrappers (MCW) and Android Callable Wrappers (ACW) facilitate communication between Mono and ART, both of which are built on the Linux kernel.
  - Android 向けでは、Xamarin は .NET バインディングを介して Android と Java のネームスペースと統合され、Mono 実行環境内で Android Runtime (ART) と並行して動作します。Managed Callable Wrappers (MCW) と Android Callable Wrappers (ACW) が Mono と ART 間の通信を仲介し、両者は Linux カーネル上に構築されています。
- For **iOS**, applications run under the Mono runtime, utilizing full Ahead of Time (AOT) compilation to convert C# .NET code into ARM assembly language. This process runs alongside the Objective-C Runtime on a UNIX-like kernel.
  - iOS 向けでは、アプリは Mono ランタイム上で動作し、フル Ahead of Time (AOT) コンパイルを利用して C#/.NET コードを ARM アセンブリに変換します。このプロセスは Objective-C Runtime と並行して UNIX ライクなカーネル上で実行されます。

### .NET Runtime and Mono Framework

The **.NET framework** includes assemblies, classes, and namespaces for application development, with the .NET Runtime managing code execution. It offers platform independence and backward compatibility. The **Mono Framework** is an open-source version of the .NET framework, initiated in 2005 to extend .NET to Linux, now supported by Microsoft and led by Xamarin.

.NET framework にはアプリケーション開発のためのアセンブリ、クラス、ネームスペースが含まれ、.NET Runtime がコード実行を管理します。プラットフォーム独立性と下位互換性を提供します。Mono Framework は .NET framework のオープンソース版で、2005 年に .NET を Linux に拡張するために開始され、現在は Microsoft がサポートし Xamarin が主導しています。

### Reverse Engineering Xamarin Apps

#### Decompilation of Xamarin Assemblies

Decompilation transforms compiled code back into source code. In Windows, the Modules window in Visual Studio can identify modules for decompilation, allowing for direct access to third-party code and extraction of source code for analysis.

逆コンパイルは、コンパイル済みコードをソースコードに戻すプロセスです。Windows では Visual Studio の Modules ウィンドウが逆コンパイル対象のモジュールを特定でき、サードパーティのコードに直接アクセスして解析用にソースコードを抽出できます。

#### JIT vs AOT Compilation

- **Android** supports Just-In-Time (JIT) and Ahead-Of-Time (AOT) compilation, with a Hybrid AOT mode for optimal execution speed. Full AOT is exclusive to Enterprise licenses.
  - Android は Just-In-Time (JIT) と Ahead-Of-Time (AOT) コンパイルをサポートし、実行速度最適化のための Hybrid AOT モードを提供します。フル AOT は Enterprise ライセンス限定です。
- **iOS** solely employs AOT compilation due to Apple's restrictions on dynamic code execution.
  - iOS は Apple の動的コード実行に関する制限のため、AOT コンパイルのみを採用しています。

### Extracting dll Files from APK/IPA

To access the assemblies in an APK/IPA, unzip the file and explore the assemblies directory. For Android, tools like [XamAsmUnZ](https://github.com/cihansol/XamAsmUnZ) and [xamarin-decompress](https://github.com/NickstaDB/xamarin-decompress) can uncompress dll files.

APK/IPA 内のアセンブリにアクセスするには、ファイルを解凍して assemblies ディレクトリを確認します。Android では、[XamAsmUnZ](https://github.com/cihansol/XamAsmUnZ) や [xamarin-decompress](https://github.com/NickstaDB/xamarin-decompress) のようなツールで dll ファイルを展開できます。
```bash
python3 xamarin-decompress.py -o /path/to/decompressed/apk
```
APK をデコンパイルした後に unknown/assemblies/ フォルダ内に `.dll` ファイルが見える場合、`.dll` に対して直接 [**dnSpy**](https://github.com/dnSpy/dnSpy) を使って解析することができます。しかし、場合によっては unknown/assemblies/ フォルダ内に `assemblies.blob` と `assemblies.manifest` ファイルが含まれていることがあります。ツール [pyxamstore](https://github.com/jakev/pyxamstore) は Xamarin apps の `assemblies.blob` ファイルを展開し、.NET assemblies へアクセスしてさらに解析できるようにします:
```bash
pyxamstore unpack -d /path/to/decompressed/apk/assemblies/
# After patching DLLs, rebuild the store
pyxamstore pack
```
最近の Xamarin/MAUI ビルドの一部は、**XALZ** 形式で圧縮された assemblies を `/assemblies.blob` や `/resources/assemblies` に格納します。 [xamarout](https://pypi.org/project/xamarout/) ライブラリを使うと、これらを素早く展開できます:
```python
from xamarout import xalz
import os
for root, _, files in os.walk("."):
for f in files:
if open(os.path.join(root, f), 'rb').read(4) == b"XALZ":
xa = xalz.XamarinCompressedAssembly(os.path.join(root, f))
xa.write("decompressed/" + f)
```
iOS dll files are readily accessible for decompilation, revealing significant portions of the application code, which often shares a common base across different platforms.

> **AOT on iOS**: managed IL is compiled into native `*.aotdata.*` files. Patching the DLL alone will not change logic; you need to hook native stubs (e.g., with Frida) because the IL bodies are empty placeholders.

### Static Analysis

Once the `.dll`s are obtained it's possible to analyze the .Net code statically using tools such as [**dnSpy**](https://github.com/dnSpy/dnSpy) or [**ILSpy**](https://github.com/icsharpcode/ILSpy) that will allow modifying the code of the app. This can be super useful to tamper the application to bypass protections for example.\
Note that after modifying the app you will need to pack it back again and sign it again.

> dnSpy is archived; maintained forks like **dnSpyEx** keep working with .NET 8/MAUI assemblies and preserve debug symbols when re-saving.

### Dynamic Analysis

Dynamic analysis involves checking for SSL pinning and using tools like [Fridax](https://github.com/NorthwaveSecurity/fridax) for runtime modifications of the .NET binary in Xamarin apps. Frida scripts are available to bypass root detection or SSL pinning, enhancing analysis capabilities.

Other interesting Frida scripts:

- [**xamarin-antiroot**](https://codeshare.frida.re/@Gand3lf/xamarin-antiroot/)
- [**xamarin-root-detect-bypass**](https://codeshare.frida.re/@nuschpl/xamarin-root-detect-bypass/)
- [**Frida-xamarin-unpin**](https://github.com/GoSecure/frida-xamarin-unpin)

Updated **Frida-xamarin-unpin** (Mono >=6) hooks `System.Net.Http.HttpClient.SendAsync` and swaps the handler to a permissive one, so it still works even when pinning is implemented in custom handlers. Run it after the app starts:
```bash
frida -U -l dist/xamarin-unpin.js com.target.app --no-pause
```
同梱の `frida-mono-api` を使ってマネージドメソッドにフックするためのクイックテンプレート:
```javascript
const mono = require('frida-mono-api');
Mono.ensureInitialized();
Mono.enumerateLoadedImages().forEach(i => console.log(i.name));
const klass = Mono.classFromName("Namespace", "Class");
const m = Mono.methodFromName(klass, "Method", 2);
Mono.intercept(m, { onEnter(args){ console.log(args[1].toInt32()); } });
```
### 再署名

ツール [Uber APK Signer](https://github.com/patrickfav/uber-apk-signer) は、同じキーで複数のAPKに署名する作業を簡素化し、アプリに変更を加えた後に再署名するために使用できます。

## 参考資料

- [https://www.appknox.com/security/xamarin-reverse-engineering-a-guide-for-penetration-testers](https://www.appknox.com/security/xamarin-reverse-engineering-a-guide-for-penetration-testers)
- [https://thecobraden.com/posts/unpacking_xamarin_assembly_stores/](https://thecobraden.com/posts/unpacking_xamarin_assembly_stores/)
- [https://medium.com/@justmobilesec/introduction-to-the-exploitation-of-xamarin-apps-fde4619a51bf](https://medium.com/@justmobilesec/introduction-to-the-exploitation-of-xamarin-apps-fde4619a51bf)
- [https://github.com/jakev/pyxamstore](https://github.com/jakev/pyxamstore)
- [https://pypi.org/project/xamarout/](https://pypi.org/project/xamarout/)
- [https://github.com/GoSecure/frida-xamarin-unpin](https://github.com/GoSecure/frida-xamarin-unpin)
- [https://gist.github.com/Diefunction/e26fce039efcab57aac342a4b2d48ff6](https://gist.github.com/Diefunction/e26fce039efcab57aac342a4b2d48ff6)
- [https://reverseengineering.stackexchange.com/questions/31716/deobfuscating-ios-dll-file-i-think-arm64](https://reverseengineering.stackexchange.com/questions/31716/deobfuscating-ios-dll-file-i-think-arm64)

{{#include ../banners/hacktricks-training.md}}
