# Xamarin ऐप्स

{{#include ../banners/hacktricks-training.md}}

## **मूल जानकारी**

Xamarin एक open-source प्लेटफ़ॉर्म है जो डेवलपर्स को .NET और C# फ्रेमवर्क का उपयोग करके iOS, Android, और Windows के लिए ऐप्स बनाने के लिए डिज़ाइन किया गया है। यह प्लेटफ़ॉर्म आधुनिक एप्लिकेशन प्रभावी ढंग से बनाने के लिए कई tools और extensions तक पहुँच प्रदान करता है।

### Xamarin की आर्किटेक्चर

- Android के लिए, Xamarin Android और Java namespaces के साथ .NET bindings के माध्यम से एकीकृत होता है, और Mono execution environment के भीतर Android Runtime (ART) के साथ साथ चलता है। Managed Callable Wrappers (MCW) और Android Callable Wrappers (ACW) Mono और ART के बीच संचार को सुविधाजनक बनाते हैं, दोनों ही Linux kernel पर आधारित होते हैं।
- iOS के लिए, एप्लिकेशन Mono runtime के अंतर्गत चलते हैं, और full Ahead of Time (AOT) compilation का उपयोग करके C# .NET कोड को ARM assembly भाषा में परिवर्तित करते हैं। यह प्रक्रिया Objective-C Runtime के साथ एक UNIX-like kernel पर साथ चलती है।

### .NET Runtime और Mono Framework

.NET framework में assemblies, classes, और namespaces शामिल होते हैं जो एप्लिकेशन डेवलपमेंट के लिए होते हैं, और .NET Runtime कोड निष्पादन का प्रबंधन करता है। यह platform independence और backward compatibility प्रदान करता है। Mono Framework .NET framework का एक open-source संस्करण है, जिसे 2005 में .NET को Linux तक विस्तारित करने के लिए शुरू किया गया था; अब इसे Microsoft द्वारा समर्थित किया जाता है और Xamarin द्वारा नेतृत्व किया जा रहा है।

### Xamarin ऐप्स का रिवर्स इंजीनियरिंग

#### Xamarin Assemblies का डीकम्पाइलेशन

डीकम्पाइलेशन संकलित कोड को स्रोत कोड में वापस बदल देता है। Windows में, Visual Studio की Modules विंडो डीकम्पाइलेशन के लिए मॉड्यूल की पहचान कर सकती है, जिससे third-party कोड तक सीधे पहुँच और विश्लेषण के लिए स्रोत कोड निकालना संभव होता है।

#### JIT बनाम AOT कम्पाइलेशन

- Android Just-In-Time (JIT) और Ahead-Of-Time (AOT) कम्पाइलेशन दोनों का समर्थन करता है, और बेहतर execution speed के लिए एक Hybrid AOT मोड मौजूद है। Full AOT केवल Enterprise लाइसेंस के लिए उपलब्ध है।
- iOS केवल AOT कम्पाइलेशन का उपयोग करता है क्योंकि Apple की dynamic code execution पर पाबंदियाँ हैं।

### APK/IPA से dll फ़ाइलें निकालना

APK/IPA में assemblies तक पहुँचने के लिए, फ़ाइल को unzip करें और assemblies directory को एक्सप्लोर करें। Android के लिए, [XamAsmUnZ](https://github.com/cihansol/XamAsmUnZ) और [xamarin-decompress](https://github.com/NickstaDB/xamarin-decompress) जैसे tools dll फ़ाइलों को अनकम्प्रेस कर सकते हैं।
```bash
python3 xamarin-decompress.py -o /path/to/decompressed/apk
```
किसी भी मामले में जहाँ APK को डिकम्पाइल करने के बाद unknown/assemblies/ फ़ोल्डर और उसके अंदर `.dll` फ़ाइलें दिखती हैं, तो [**dnSpy**](https://github.com/dnSpy/dnSpy) को सीधे उन `.dlls` पर उपयोग करके उनका विश्लेषण किया जा सकता है। हालांकि, कभी-कभी unknown/assemblies/ फ़ोल्डर के अंदर `assemblies.blob` और `assemblies.manifest` फ़ाइलें होती हैं। टूल [pyxamstore](https://github.com/jakev/pyxamstore) Xamarin apps में `assemblies.blob` फ़ाइल को अनपैक कर सकता है, जिससे आगे के विश्लेषण के लिए .NET assemblies तक पहुँच मिलती है:
```bash
pyxamstore unpack -d /path/to/decompressed/apk/assemblies/
# After patching DLLs, rebuild the store
pyxamstore pack
```
कुछ हाल के Xamarin/MAUI builds संकुचित assemblies को **XALZ** फॉर्मेट में `/assemblies.blob` या `/resources/assemblies` के अंदर स्टोर करते हैं। आप उन्हें [xamarout](https://pypi.org/project/xamarout/) लाइब्रेरी के साथ जल्दी से decompress कर सकते हैं:
```python
from xamarout import xalz
import os
for root, _, files in os.walk("."):
for f in files:
if open(os.path.join(root, f), 'rb').read(4) == b"XALZ":
xa = xalz.XamarinCompressedAssembly(os.path.join(root, f))
xa.write("decompressed/" + f)
```
iOS .dll फाइलें decompilation के लिए आसानी से उपलब्ध होती हैं, जिससे एप्लिकेशन कोड के महत्वपूर्ण हिस्से सामने आ जाते हैं, जो अक्सर विभिन्न प्लेटफॉर्म्स में एक सामान्य बेस साझा करते हैं।

> **AOT on iOS**: managed IL native `*.aotdata.*` files में compiled होता है। Patching the DLL alone logic को नहीं बदलेगा; आपको native stubs को hook करना होगा (उदा., Frida के साथ) क्योंकि IL bodies खाली placeholders होते हैं।

### Static Analysis

Once the `.dll`s are obtained it's possible to analyze the .Net code statically using tools such as [**dnSpy**](https://github.com/dnSpy/dnSpy) or [**ILSpy**](https://github.com/icsharpcode/ILSpy) that will allow modifying the code of the app. This can be super useful to tamper the application to bypass protections for example.\
Note that after modifying the app you will need to pack it back again and sign it again.

> dnSpy is archived; maintained forks like **dnSpyEx** keep working with .NET 8/MAUI assemblies and preserve debug symbols when re-saving.

### Dynamic Analysis

Dynamic analysis में SSL pinning की जाँच और Xamarin apps में .NET बाइनरी के runtime modifications के लिए [Fridax](https://github.com/NorthwaveSecurity/fridax) जैसे उपकरणों का उपयोग शामिल है। Frida scripts root detection या SSL pinning को bypass करने के लिए उपलब्ध हैं, जिससे analysis क्षमताएँ बढ़ती हैं।

Other interesting Frida scripts:

- [**xamarin-antiroot**](https://codeshare.frida.re/@Gand3lf/xamarin-antiroot/)
- [**xamarin-root-detect-bypass**](https://codeshare.frida.re/@nuschpl/xamarin-root-detect-bypass/)
- [**Frida-xamarin-unpin**](https://github.com/GoSecure/frida-xamarin-unpin)

Updated **Frida-xamarin-unpin** (Mono >=6) `System.Net.Http.HttpClient.SendAsync` को hook करता है और handler को एक permissive handler से बदल देता है, इसलिए यह तब भी काम करता है जब pinning custom handlers में लागू हो। Run it after the app starts:
```bash
frida -U -l dist/xamarin-unpin.js com.target.app --no-pause
```
बंडल किए गए `frida-mono-api` के साथ managed methods को hook करने के लिए त्वरित टेम्पलेट:
```javascript
const mono = require('frida-mono-api');
Mono.ensureInitialized();
Mono.enumerateLoadedImages().forEach(i => console.log(i.name));
const klass = Mono.classFromName("Namespace", "Class");
const m = Mono.methodFromName(klass, "Method", 2);
Mono.intercept(m, { onEnter(args){ console.log(args[1].toInt32()); } });
```
### पुनः साइन करना

टूल [Uber APK Signer](https://github.com/patrickfav/uber-apk-signer) एक ही कुंजी से कई APKs को साइन करना सरल बनाता है, और किसी ऐप में बदलाव किए जाने के बाद उसे पुनः साइन करने के लिए इस्तेमाल किया जा सकता है।

## संदर्भ

- [https://www.appknox.com/security/xamarin-reverse-engineering-a-guide-for-penetration-testers](https://www.appknox.com/security/xamarin-reverse-engineering-a-guide-for-penetration-testers)
- [https://thecobraden.com/posts/unpacking_xamarin_assembly_stores/](https://thecobraden.com/posts/unpacking_xamarin_assembly_stores/)
- [https://medium.com/@justmobilesec/introduction-to-the-exploitation-of-xamarin-apps-fde4619a51bf](https://medium.com/@justmobilesec/introduction-to-the-exploitation-of-xamarin-apps-fde4619a51bf)
- [https://github.com/jakev/pyxamstore](https://github.com/jakev/pyxamstore)
- [https://pypi.org/project/xamarout/](https://pypi.org/project/xamarout/)
- [https://github.com/GoSecure/frida-xamarin-unpin](https://github.com/GoSecure/frida-xamarin-unpin)
- [https://gist.github.com/Diefunction/e26fce039efcab57aac342a4b2d48ff6](https://gist.github.com/Diefunction/e26fce039efcab57aac342a4b2d48ff6)
- [https://reverseengineering.stackexchange.com/questions/31716/deobfuscating-ios-dll-file-i-think-arm64](https://reverseengineering.stackexchange.com/questions/31716/deobfuscating-ios-dll-file-i-think-arm64)

{{#include ../banners/hacktricks-training.md}}
