# Shizuku Privileged API

{{#include ../../banners/hacktricks-training.md}}

Shizuku es un servicio de código abierto que **crea un proceso Java privilegiado usando `app_process`** y expone APIs del **sistema Android seleccionadas a través de Binder**. Debido a que el proceso se lanza con las mismas **capacidades de UID `shell` que usa ADB**, cualquier aplicación (o terminal) que se conecte a la interfaz AIDL exportada puede realizar muchas acciones que normalmente requieren **`WRITE_SECURE_SETTINGS`, `INSTALL_PACKAGES`, operaciones de archivo dentro de `/data`,** etc. – **sin necesidad de rootear el dispositivo**.

Casos de uso típicos:
* Auditoría de seguridad desde un dispositivo no rooteado
* Eliminación de bloatware / desinstalación de aplicaciones del sistema
* Recopilación de registros, claves de Wi-Fi, información de procesos y sockets para blue-team/DFIR
* Automatización de la configuración del dispositivo desde aplicaciones personalizadas o scripts de shell

---
## 1. Iniciando el servicio privilegiado

`moe.shizuku.privileged.api` se puede iniciar de tres maneras diferentes – el servicio Binder resultante se comporta igual en todas ellas.

### 1.1 ADB inalámbrico (Android 11+)
1. Habilitar **Opciones de desarrollador ➜ Depuración inalámbrica** y emparejar el dispositivo.
2. Dentro de la aplicación Shizuku seleccionar **“Iniciar a través de depuración inalámbrica”** y copiar el código de emparejamiento.
3. El servicio persiste hasta el próximo reinicio (las sesiones de depuración inalámbrica se borran al iniciar).

### 1.2 Línea de comandos ADB USB / local
```bash
adb push start.sh \
/storage/emulated/0/Android/data/moe.shizuku.privileged.api/

# spawn the privileged process
adb shell sh /storage/emulated/0/Android/data/moe.shizuku.privileged.api/start.sh
```
El mismo script se puede ejecutar a través de una conexión **network ADB** (`adb connect <IP>:5555`).

### 1.3 Dispositivos con root
Si el dispositivo ya está rooteado, ejecuta:
```bash
su -c sh /data/adb/shizuku/start.sh
```
### 1.4 Verificando que está en ejecución
```bash
adb shell dumpsys activity service moe.shizuku.privileged.api | head
```
Un inicio exitoso devuelve `Running services (1)` junto con el PID del proceso privilegiado.

---
## 2. Vinculación desde una aplicación
Las aplicaciones de terceros solo necesitan lo siguiente dentro de su `AndroidManifest.xml`:
```xml
<uses-permission android:name="moe.shizuku.manager.permission.API"/>
```
En tiempo de ejecución obtienen el binder:
```java
IBinder binder = ShizukuProvider.getBinder();
IPackageManager pm  = IPackageManager.Stub.asInterface(binder);
```
A partir de este momento, la aplicación puede invocar cualquier método que el **`shell` user** pueda llamar – por ejemplo :
```java
pm.installPackage(new Uri("file:///sdcard/app.apk"), null, 0, null);
Settings.Global.putInt(resolver, Settings.Global.ADB_ENABLED, 1);
```
Una lista curada de más de **170 aplicaciones habilitadas para Shizuku** se mantiene en [awesome-shizuku](https://github.com/timschneeb/awesome-shizuku).

---
## 3. Rish – shell elevado dentro de Termux
La pantalla de configuración de Shizuku expone **“Usar Shizuku en aplicaciones de terminal”**. Habilitarlo descarga *rish* (`/data/local/tmp/rish`).
```bash
pkg install wget
wget https://rikka.app/rish/latest -O rish && chmod +x rish

# start elevated shell (inherits the binder connection)
./rish
whoami   #  ➜  shell
id       #  uid=2000(shell) gid=2000(shell) groups=... context=u:r:shell:s0
```
### 3.1 Comandos útiles de la shell rish
* Listar procesos en ejecución de un paquete dado:
```bash
ps -A | grep com.facebook.katana
```
* Enumerar sockets en escucha y mapearlos a paquetes (por ejemplo, **CVE-2019-6447 ES File Explorer**):
```bash
netstat -tuln
for pid in $(lsof -nP -iTCP -sTCP:LISTEN -t); do
printf "%s -> %s\n" "$pid" "$(cat /proc/$pid/cmdline)";
done
```
* Volcar los logs de cada aplicación:
```bash
logcat -d | grep -iE "(error|exception)"
```
* Leer credenciales de Wi-Fi almacenadas (Android 11 +):
```bash
cat /data/misc/wifi/WifiConfigStore.xml | grep -i "<ConfigKey>"
```
* Desinstalación masiva (ejemplo):
```bash
pm uninstall --user 0 com.miui.weather2
```

---
## 4. Consideraciones de seguridad / detección
1. Shizuku necesita privilegios de **depuración ADB**, por lo tanto, _Opciones de desarrollador → Depuración USB/Inalámbrica_ debe estar **habilitado**. 
Las organizaciones pueden bloquear esto a través de un MDM o mediante `settings put global development_settings_enabled 0`.
2. El servicio se registra bajo el nombre `moe.shizuku.privileged.api`. 
Un simple `adb shell service list | grep shizuku` (o regla de Endpoint Security) detecta su presencia.
3. Las capacidades están limitadas a lo que el usuario `shell` ya puede hacer – **no es root**. 
Las APIs sensibles que requieren el usuario `system` o `root` siguen siendo inaccesibles.
4. Las sesiones **no sobreviven a un reinicio** a menos que el dispositivo esté rooteado y Shizuku esté configurado como un daemon de inicio.

---
## 5. Mitigación
* Deshabilitar la depuración USB/Inalámbrica en dispositivos de producción.
* Monitorear servicios de Binder que expongan `moe.shizuku.privileged.api`.
* Usar políticas de SELinux (Android enterprise) para bloquear la interfaz AIDL de aplicaciones no gestionadas.

---
## Referencias

- [Blog – Shizuku: Desbloqueando capacidades avanzadas de Android sin root](https://www.mobile-hacker.com/2025/07/14/shizuku-unlocking-advanced-android-capabilities-without-root/)
- [Documentación oficial de Shizuku](https://shizuku.rikka.app/)
- [awesome-shizuku – lista de aplicaciones soportadas](https://github.com/timschneeb/awesome-shizuku)
- [shell rish (shell inversa ADB privilegiada)](https://github.com/RikkaApps/Shizuku/blob/master/RISH.md)

{{#include ../../banners/hacktricks-training.md}}
