# Shizuku Privileged API

{{#include ../../banners/hacktricks-training.md}}

Shizuku è un servizio open-source che **crea un processo Java privilegiato utilizzando `app_process`** ed espone selezionate **API di sistema Android tramite Binder**. Poiché il processo viene avviato con le stesse **capacità UID `shell` che utilizza ADB**, qualsiasi applicazione (o terminale) che si collega all'interfaccia AIDL esportata può eseguire molte azioni che normalmente richiedono **`WRITE_SECURE_SETTINGS`, `INSTALL_PACKAGES`, operazioni di file I/O all'interno di `/data`,** ecc. – **senza rootare il dispositivo**.

Casi d'uso tipici:
* Audit di sicurezza da un dispositivo non rootato
* Rimozione di bloatware / debloating delle app di sistema
* Raccolta di log, chiavi Wi-Fi, informazioni su processi e socket per blue-team/DFIR
* Automazione della configurazione del dispositivo da app personalizzate o script shell

---
## 1. Avvio del servizio privilegiato

`moe.shizuku.privileged.api` può essere avviato in tre modi diversi – il servizio Binder risultante si comporta allo stesso modo in tutti e tre.

### 1.1 ADB wireless (Android 11+)
1. Abilitare **Opzioni sviluppatore ➜ Debugging wireless** e accoppiare il dispositivo.
2. All'interno dell'app Shizuku selezionare **“Avvia tramite debugging wireless”** e copiare il codice di accoppiamento.
3. Il servizio sopravvive fino al successivo riavvio (le sessioni di debugging wireless vengono cancellate al boot).

### 1.2 USB / ADB locale one-liner
```bash
adb push start.sh \
/storage/emulated/0/Android/data/moe.shizuku.privileged.api/

# spawn the privileged process
adb shell sh /storage/emulated/0/Android/data/moe.shizuku.privileged.api/start.sh
```
Lo stesso script può essere eseguito su una connessione **network ADB** (`adb connect <IP>:5555`).

### 1.3 Dispositivi rootati
Se il dispositivo è già rootato, eseguire:
```bash
su -c sh /data/adb/shizuku/start.sh
```
### 1.4 Verificare che sia in esecuzione
```bash
adb shell dumpsys activity service moe.shizuku.privileged.api | head
```
Un avvio riuscito restituisce `Running services (1)` insieme al PID del processo privilegiato.

---
## 2. Binding da un'applicazione
Le app di terze parti hanno solo bisogno del seguente all'interno del loro `AndroidManifest.xml`:
```xml
<uses-permission android:name="moe.shizuku.manager.permission.API"/>
```
A runtime ottengono il binder:
```java
IBinder binder = ShizukuProvider.getBinder();
IPackageManager pm  = IPackageManager.Stub.asInterface(binder);
```
Da questo momento l'app può invocare qualsiasi metodo che l'utente **`shell`** può chiamare – per esempio :
```java
pm.installPackage(new Uri("file:///sdcard/app.apk"), null, 0, null);
Settings.Global.putInt(resolver, Settings.Global.ADB_ENABLED, 1);
```
Una lista curata di oltre **170 app abilitate per Shizuku** è mantenuta su [awesome-shizuku](https://github.com/timschneeb/awesome-shizuku).

---
## 3. Rish – shell elevata all'interno di Termux
La schermata delle impostazioni di Shizuku espone **“Usa Shizuku nelle app terminali”**. Abilitandola, viene scaricato *rish* (`/data/local/tmp/rish`).
```bash
pkg install wget
wget https://rikka.app/rish/latest -O rish && chmod +x rish

# start elevated shell (inherits the binder connection)
./rish
whoami   #  ➜  shell
id       #  uid=2000(shell) gid=2000(shell) groups=... context=u:r:shell:s0
```
### 3.1 Comandi utili dalla shell rish
* Elenca i processi in esecuzione di un dato pacchetto:
```bash
ps -A | grep com.facebook.katana
```
* Enumera i socket in ascolto e mappali ai pacchetti (ad es. **CVE-2019-6447 ES File Explorer**):
```bash
netstat -tuln
for pid in $(lsof -nP -iTCP -sTCP:LISTEN -t); do
printf "%s -> %s\n" "$pid" "$(cat /proc/$pid/cmdline)";
done
```
* Dump dei log di ogni applicazione:
```bash
logcat -d | grep -iE "(error|exception)"
```
* Leggi le credenziali Wi-Fi memorizzate (Android 11 +):
```bash
cat /data/misc/wifi/WifiConfigStore.xml | grep -i "<ConfigKey>"
```
* Debloat di massa (esempio):
```bash
pm uninstall --user 0 com.miui.weather2
```

---
## 4. Considerazioni sulla sicurezza / rilevamento
1. Shizuku ha bisogno di privilegi di **debugging ADB**, quindi _Opzioni sviluppatore → Debugging USB/Wireless_ deve essere **abilitato**. 
Le organizzazioni possono bloccare questo tramite un MDM o tramite `settings put global development_settings_enabled 0`.
2. Il servizio si registra con il nome `moe.shizuku.privileged.api`. 
Un semplice `adb shell service list | grep shizuku` (o regola di sicurezza dell'endpoint) ne rileva la presenza.
3. Le capacità sono limitate a ciò che l'utente `shell` può già fare – **non è root**. 
Le API sensibili che richiedono l'utente `system` o `root` sono ancora inaccessibili.
4. Le sessioni **non sopravvivono a un riavvio** a meno che il dispositivo non sia rootato e Shizuku sia configurato come daemon di avvio.

---
## 5. Mitigazione
* Disabilita il debugging USB/Wireless sui dispositivi di produzione.
* Monitora i servizi Binder che espongono `moe.shizuku.privileged.api`.
* Usa le politiche SELinux (Android enterprise) per bloccare l'interfaccia AIDL da applicazioni non gestite.

---
## Riferimenti

- [Blog – Shizuku: Sbloccare capacità avanzate di Android senza root](https://www.mobile-hacker.com/2025/07/14/shizuku-unlocking-advanced-android-capabilities-without-root/)
- [Documentazione ufficiale di Shizuku](https://shizuku.rikka.app/)
- [awesome-shizuku – elenco delle app supportate](https://github.com/timschneeb/awesome-shizuku)
- [shell rish (shell reverse-adb privilegiata)](https://github.com/RikkaApps/Shizuku/blob/master/RISH.md)

{{#include ../../banners/hacktricks-training.md}}
