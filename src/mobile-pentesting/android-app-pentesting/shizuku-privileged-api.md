# Shizuku Privileged API

{{#include ../../banners/hacktricks-training.md}}

Shizuku to usługa open-source, która **uruchamia uprzywilejowany proces Java za pomocą `app_process`** i udostępnia wybrane **API systemu Android przez Binder**. Ponieważ proces jest uruchamiany z tymi samymi **uprawnieniami UID `shell`, które wykorzystuje ADB**, każda aplikacja (lub terminal), która łączy się z eksportowanym interfejsem AIDL, może wykonywać wiele działań, które normalnie wymagają **`WRITE_SECURE_SETTINGS`, `INSTALL_PACKAGES`, operacji I/O w `/data`,** itd. – **bez rootowania urządzenia**.

Typowe przypadki użycia:
* Audyt bezpieczeństwa z nie-rootowanego urządzenia
* Usuwanie bloatware / debloating aplikacji systemowych
* Zbieranie logów, kluczy Wi-Fi, informacji o procesach i gniazdach dla blue-team/DFIR
* Automatyzacja konfiguracji urządzenia z niestandardowych aplikacji lub skryptów powłoki

---
## 1. Rozpoczynanie usługi uprzywilejowanej

`moe.shizuku.privileged.api` można uruchomić na trzy różne sposoby – wynikowa usługa Binder zachowuje się tak samo we wszystkich z nich.

### 1.1 Bezprzewodowy ADB (Android 11+)
1. Włącz **Opcje dewelopera ➜ Debugowanie bezprzewodowe** i sparuj urządzenie.
2. W aplikacji Shizuku wybierz **„Rozpocznij przez debugowanie bezprzewodowe”** i skopiuj kod parowania.
3. Usługa przetrwa do następnego restartu (sesje debugowania bezprzewodowego są czyszczone po uruchomieniu).

### 1.2 USB / lokalny ADB w jednej linii
```bash
adb push start.sh \
/storage/emulated/0/Android/data/moe.shizuku.privileged.api/

# spawn the privileged process
adb shell sh /storage/emulated/0/Android/data/moe.shizuku.privileged.api/start.sh
```
Ten sam skrypt można wykonać przez połączenie **network ADB** (`adb connect <IP>:5555`).

### 1.3 Urządzenia z rootem
Jeśli urządzenie jest już zrootowane, uruchom:
```bash
su -c sh /data/adb/shizuku/start.sh
```
### 1.4 Weryfikacja, że działa
```bash
adb shell dumpsys activity service moe.shizuku.privileged.api | head
```
Udany start zwraca `Running services (1)` razem z PID procesu z uprawnieniami.

---
## 2. Wiązanie z aplikacją
Aplikacje innych firm potrzebują tylko następującego w swoim `AndroidManifest.xml`:
```xml
<uses-permission android:name="moe.shizuku.manager.permission.API"/>
```
W czasie wykonywania uzyskują binder:
```java
IBinder binder = ShizukuProvider.getBinder();
IPackageManager pm  = IPackageManager.Stub.asInterface(binder);
```
Od tego momentu aplikacja może wywoływać dowolną metodę, którą może wywołać użytkownik **`shell`** – na przykład:
```java
pm.installPackage(new Uri("file:///sdcard/app.apk"), null, 0, null);
Settings.Global.putInt(resolver, Settings.Global.ADB_ENABLED, 1);
```
Zarządzana lista ponad **170 aplikacji z obsługą Shizuku** jest dostępna na [awesome-shizuku](https://github.com/timschneeb/awesome-shizuku).

---
## 3. Rish – podniesiona powłoka w Termux
Ekran ustawień Shizuku udostępnia **„Użyj Shizuku w aplikacjach terminalowych”**. Włączenie tej opcji pobiera *rish* (`/data/local/tmp/rish`).
```bash
pkg install wget
wget https://rikka.app/rish/latest -O rish && chmod +x rish

# start elevated shell (inherits the binder connection)
./rish
whoami   #  ➜  shell
id       #  uid=2000(shell) gid=2000(shell) groups=... context=u:r:shell:s0
```
### 3.1 Przydatne polecenia z powłoki rish
* Wyświetl uruchomione procesy danego pakietu:
```bash
ps -A | grep com.facebook.katana
```
* Wymień gniazda nasłuchujące i przypisz je do pakietów (np. **CVE-2019-6447 ES File Explorer**):
```bash
netstat -tuln
for pid in $(lsof -nP -iTCP -sTCP:LISTEN -t); do
printf "%s -> %s\n" "$pid" "$(cat /proc/$pid/cmdline)";
done
```
* Zrzutuj logi każdej aplikacji:
```bash
logcat -d | grep -iE "(error|exception)"
```
* Odczytaj zapisane dane uwierzytelniające Wi-Fi (Android 11 +):
```bash
cat /data/misc/wifi/WifiConfigStore.xml | grep -i "<ConfigKey>"
```
* Masowe usuwanie (przykład):
```bash
pm uninstall --user 0 com.miui.weather2
```

---
## 4. Rozważania dotyczące bezpieczeństwa / wykrywania
1. Shizuku potrzebuje **uprawnień do debugowania ADB**, dlatego _Opcje dewelopera → Debugowanie USB/bezprzewodowe_ muszą być **włączone**.
Organizacje mogą to zablokować za pomocą MDM lub poprzez `settings put global development_settings_enabled 0`.
2. Usługa rejestruje się pod nazwą `moe.shizuku.privileged.api`.
Proste `adb shell service list | grep shizuku` (lub zasada bezpieczeństwa punktu końcowego) wykrywa jej obecność.
3. Możliwości są ograniczone do tego, co użytkownik `shell` może już zrobić – **nie jest to root**.
Wrażliwe API, które wymagają użytkownika `system` lub `root`, są nadal niedostępne.
4. Sesje **nie przetrwają ponownego uruchomienia** chyba, że urządzenie jest zrootowane, a Shizuku jest skonfigurowane jako demon startowy.

---
## 5. Łagodzenie
* Wyłącz debugowanie USB/bezprzewodowe na urządzeniach produkcyjnych.
* Monitoruj usługi Binder, które udostępniają `moe.shizuku.privileged.api`.
* Użyj polityk SELinux (Android enterprise), aby zablokować interfejs AIDL z niezarządzanych aplikacji.

---
## Odniesienia

- [Blog – Shizuku: Odblokowywanie zaawansowanych możliwości Androida bez roota](https://www.mobile-hacker.com/2025/07/14/shizuku-unlocking-advanced-android-capabilities-without-root/)
- [Oficjalna dokumentacja Shizuku](https://shizuku.rikka.app/)
- [awesome-shizuku – lista wspieranych aplikacji](https://github.com/timschneeb/awesome-shizuku)
- [powłoka rish (uprzywilejowana powłoka reverse-adb)](https://github.com/RikkaApps/Shizuku/blob/master/RISH.md)

{{#include ../../banners/hacktricks-training.md}}
