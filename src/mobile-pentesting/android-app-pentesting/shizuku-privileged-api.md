# Shizuku Privileged API

{{#include ../../banners/hacktricks-training.md}}

Shizuku ist ein Open-Source-Dienst, der **einen privilegierten Java-Prozess mit `app_process` startet** und ausgewählte **Android-System-APIs über Binder bereitstellt**. Da der Prozess mit den gleichen **`shell` UID-Fähigkeiten, die ADB verwendet**, gestartet wird, kann jede Anwendung (oder jedes Terminal), die an die exportierte AIDL-Schnittstelle bindet, viele Aktionen ausführen, die normalerweise **`WRITE_SECURE_SETTINGS`, `INSTALL_PACKAGES`, Datei-I/O innerhalb von `/data`,** usw. erfordern – **ohne das Gerät zu rooten**.

Typische Anwendungsfälle:
* Sicherheitsüberprüfung von einem nicht gerooteten Gerät
* Entfernen von Bloatware / Debloating von System-Apps
* Sammeln von Protokollen, Wi-Fi-Schlüsseln, Prozess- und Socket-Informationen für Blue-Team/DFIR
* Automatisierung der Gerätekonfiguration von benutzerdefinierten Apps oder Shell-Skripten

---
## 1. Starten des privilegierten Dienstes

`moe.shizuku.privileged.api` kann auf drei verschiedene Arten gestartet werden – der resultierende Binder-Dienst verhält sich in allen gleich.

### 1.1 Wireless ADB (Android 11+)
1. Aktivieren Sie **Entwickleroptionen ➜ Wireless Debugging** und koppeln Sie das Gerät.
2. Wählen Sie in der Shizuku-App **„Starten über Wireless Debugging“** und kopieren Sie den Pairing-Code.
3. Der Dienst überlebt bis zum nächsten Neustart (Wireless-Debugging-Sitzungen werden beim Booten gelöscht).

### 1.2 USB / lokaler ADB Einzeiler
```bash
adb push start.sh \
/storage/emulated/0/Android/data/moe.shizuku.privileged.api/

# spawn the privileged process
adb shell sh /storage/emulated/0/Android/data/moe.shizuku.privileged.api/start.sh
```
Das gleiche Skript kann über eine **network ADB** Verbindung (`adb connect <IP>:5555`) ausgeführt werden.

### 1.3 Rooted Geräte
Wenn das Gerät bereits gerootet ist, führen Sie aus:
```bash
su -c sh /data/adb/shizuku/start.sh
```
### 1.4 Überprüfen, ob es läuft
```bash
adb shell dumpsys activity service moe.shizuku.privileged.api | head
```
Ein erfolgreicher Start gibt `Running services (1)` zusammen mit der PID des privilegierten Prozesses zurück.

---
## 2. Binding von einer Anwendung
Drittanbieter-Apps benötigen nur Folgendes in ihrem `AndroidManifest.xml`:
```xml
<uses-permission android:name="moe.shizuku.manager.permission.API"/>
```
Zur Laufzeit erhalten sie den Binder:
```java
IBinder binder = ShizukuProvider.getBinder();
IPackageManager pm  = IPackageManager.Stub.asInterface(binder);
```
Ab diesem Moment kann die App jede Methode aufrufen, die der **`shell`-Benutzer** aufrufen kann – zum Beispiel :
```java
pm.installPackage(new Uri("file:///sdcard/app.apk"), null, 0, null);
Settings.Global.putInt(resolver, Settings.Global.ADB_ENABLED, 1);
```
Eine kuratierte Liste von mehr als **170 Shizuku-aktivierten Apps** wird unter [awesome-shizuku](https://github.com/timschneeb/awesome-shizuku) gepflegt.

---
## 3. Rish – erhöhtes Shell in Termux
Der Shizuku-Einstellungsbildschirm zeigt **„Shizuku in Terminal-Apps verwenden“** an. Das Aktivieren lädt *rish* (`/data/local/tmp/rish`) herunter.
```bash
pkg install wget
wget https://rikka.app/rish/latest -O rish && chmod +x rish

# start elevated shell (inherits the binder connection)
./rish
whoami   #  ➜  shell
id       #  uid=2000(shell) gid=2000(shell) groups=... context=u:r:shell:s0
```
### 3.1 Nützliche Befehle aus der rish-Shell
* Liste der laufenden Prozesse eines bestimmten Pakets:
```bash
ps -A | grep com.facebook.katana
```
* Auflisten von hörenden Sockets und Zuordnung zu Paketen (z.B. **CVE-2019-6447 ES File Explorer**):
```bash
netstat -tuln
for pid in $(lsof -nP -iTCP -sTCP:LISTEN -t); do
printf "%s -> %s\n" "$pid" "$(cat /proc/$pid/cmdline)";
done
```
* Protokolle jeder Anwendung dumpen:
```bash
logcat -d | grep -iE "(error|exception)"
```
* Gespeicherte Wi-Fi-Anmeldeinformationen lesen (Android 11 +):
```bash
cat /data/misc/wifi/WifiConfigStore.xml | grep -i "<ConfigKey>"
```
* Bulk-Debloat (Beispiel):
```bash
pm uninstall --user 0 com.miui.weather2
```

---
## 4. Sicherheitsüberlegungen / Erkennung
1. Shizuku benötigt **ADB-Debugging**-Berechtigungen, daher müssen _Entwickleroptionen → USB/Wireless-Debugging_ **aktiviert** sein. 
Organisationen können dies über ein MDM oder durch `settings put global development_settings_enabled 0` blockieren.
2. Der Dienst registriert sich unter dem Namen `moe.shizuku.privileged.api`. 
Ein einfaches `adb shell service list | grep shizuku` (oder Endpoint-Sicherheitsregel) erkennt seine Anwesenheit.
3. Die Fähigkeiten sind auf das beschränkt, was der `shell`-Benutzer bereits tun kann – es ist **nicht root**. 
Sensible APIs, die den `system`- oder `root`-Benutzer erfordern, sind weiterhin unzugänglich.
4. Sitzungen überstehen **keinen Neustart**, es sei denn, das Gerät ist gerootet und Shizuku ist als Startdaemon konfiguriert.

---
## 5. Minderung
* Deaktivieren Sie USB/Wireless-Debugging auf Produktionsgeräten.
* Überwachen Sie Binder-Dienste, die `moe.shizuku.privileged.api` exponieren.
* Verwenden Sie SELinux-Richtlinien (Android Enterprise), um die AIDL-Schnittstelle von nicht verwalteten Anwendungen zu blockieren.

---
## Referenzen

- [Blog – Shizuku: Unlocking Advanced Android Capabilities Without Root](https://www.mobile-hacker.com/2025/07/14/shizuku-unlocking-advanced-android-capabilities-without-root/)
- [Shizuku Offizielle Dokumentation](https://shizuku.rikka.app/)
- [awesome-shizuku – Liste der unterstützten Apps](https://github.com/timschneeb/awesome-shizuku)
- [rish shell (privilegierte Reverse-ADB-Shell)](https://github.com/RikkaApps/Shizuku/blob/master/RISH.md)

{{#include ../../banners/hacktricks-training.md}}
