# Shizuku Privileged API

{{#include ../../banners/hacktricks-training.md}}

Shizuku एक ओपन-सोर्स सेवा है जो **`app_process` का उपयोग करके एक विशेषाधिकार प्राप्त Java प्रक्रिया उत्पन्न करती है** और चयनित **Android सिस्टम APIs को Binder के माध्यम से उजागर करती है**। चूंकि प्रक्रिया को उसी **`shell` UID क्षमताओं के साथ लॉन्च किया जाता है जो ADB उपयोग करता है**, कोई भी एप्लिकेशन (या टर्मिनल) जो निर्यातित AIDL इंटरफेस से बंधता है, कई कार्य कर सकता है जो सामान्यतः **`WRITE_SECURE_SETTINGS`, `INSTALL_PACKAGES`, `/data` के अंदर फ़ाइल I/O** आदि की आवश्यकता होती है - **डिवाइस को रूट किए बिना**।

विशिष्ट उपयोग के मामले:
* बिना रूट किए हैंडसेट से सुरक्षा ऑडिटिंग
* बloatware हटाना / सिस्टम ऐप्स को डिब्लोट करना
* ब्लू-टीम/DFIR के लिए लॉग, वाई-फाई कुंजी, प्रक्रिया और सॉकेट जानकारी एकत्र करना
* कस्टम ऐप्स या शेल स्क्रिप्ट से डिवाइस कॉन्फ़िगरेशन स्वचालित करना

---
## 1. विशेषाधिकार प्राप्त सेवा शुरू करना

`moe.shizuku.privileged.api` को तीन अलग-अलग तरीकों से शुरू किया जा सकता है - परिणामस्वरूप Binder सेवा सभी में समान व्यवहार करती है।

### 1.1 वायरलेस ADB (Android 11+)
1. **डेवलपर विकल्प ➜ वायरलेस डिबगिंग** सक्षम करें और डिवाइस को पेयर करें।
2. Shizuku ऐप के अंदर **“वायरलेस डिबगिंग के माध्यम से शुरू करें”** का चयन करें और पेयरिंग कोड कॉपी करें।
3. सेवा अगली रिबूट तक जीवित रहती है (वायरलेस-डिबगिंग सत्र बूट पर साफ़ हो जाते हैं)।

### 1.2 USB / स्थानीय ADB एक-लाइनर
```bash
adb push start.sh \
/storage/emulated/0/Android/data/moe.shizuku.privileged.api/

# spawn the privileged process
adb shell sh /storage/emulated/0/Android/data/moe.shizuku.privileged.api/start.sh
```
वही स्क्रिप्ट **नेटवर्क ADB** कनेक्शन (`adb connect <IP>:5555`) के माध्यम से चलायी जा सकती है।

### 1.3 रूटेड डिवाइस
यदि डिवाइस पहले से ही रूटेड है, तो चलाएँ:
```bash
su -c sh /data/adb/shizuku/start.sh
```
### 1.4 यह सत्यापित करना कि यह चल रहा है
```bash
adb shell dumpsys activity service moe.shizuku.privileged.api | head
```
एक सफल शुरुआत `Running services (1)` के साथ-साथ विशेषाधिकार प्राप्त प्रक्रिया का PID लौटाती है।

---
## 2. एक एप्लिकेशन से बाइंडिंग
थर्ड-पार्टी ऐप्स को केवल अपने `AndroidManifest.xml` के अंदर निम्नलिखित की आवश्यकता होती है:
```xml
<uses-permission android:name="moe.shizuku.manager.permission.API"/>
```
रनटाइम पर वे बाइंडर प्राप्त करते हैं:
```java
IBinder binder = ShizukuProvider.getBinder();
IPackageManager pm  = IPackageManager.Stub.asInterface(binder);
```
इस क्षण से ऐप किसी भी विधि को कॉल कर सकता है जिसे **`shell` उपयोगकर्ता** कॉल कर सकता है - उदाहरण के लिए :
```java
pm.installPackage(new Uri("file:///sdcard/app.apk"), null, 0, null);
Settings.Global.putInt(resolver, Settings.Global.ADB_ENABLED, 1);
```
एक क्यूरेटेड सूची **170 से अधिक Shizuku-सक्षम ऐप्स** की [awesome-shizuku](https://github.com/timschneeb/awesome-shizuku) पर रखी गई है।

---
## 3. Rish – Termux के अंदर ऊंचा शेल
Shizuku सेटिंग्स स्क्रीन **“Use Shizuku in terminal apps”** को प्रदर्शित करती है। इसे सक्षम करने पर *rish* (`/data/local/tmp/rish`) डाउनलोड होता है।
```bash
pkg install wget
wget https://rikka.app/rish/latest -O rish && chmod +x rish

# start elevated shell (inherits the binder connection)
./rish
whoami   #  ➜  shell
id       #  uid=2000(shell) gid=2000(shell) groups=... context=u:r:shell:s0
```
### 3.1 उपयोगी कमांड rish शेल से
* दिए गए पैकेज के चल रहे प्रोसेस की सूची:
```bash
ps -A | grep com.facebook.katana
```
* सुनने वाले सॉकेट्स की गणना करें और उन्हें पैकेज से मैप करें (जैसे **CVE-2019-6447 ES File Explorer**):
```bash
netstat -tuln
for pid in $(lsof -nP -iTCP -sTCP:LISTEN -t); do
printf "%s -> %s\n" "$pid" "$(cat /proc/$pid/cmdline)";
done
```
* हर एप्लिकेशन के लॉग्स को डंप करें:
```bash
logcat -d | grep -iE "(error|exception)"
```
* संग्रहीत Wi-Fi क्रेडेंशियल्स पढ़ें (Android 11 +):
```bash
cat /data/misc/wifi/WifiConfigStore.xml | grep -i "<ConfigKey>"
```
* बल्क डिब्लोट (उदाहरण):
```bash
pm uninstall --user 0 com.miui.weather2
```

---
## 4. सुरक्षा विचार / पहचान
1. Shizuku को **ADB डिबगिंग** विशेषाधिकार की आवश्यकता है, इसलिए _डेवलपर विकल्प → USB/वायरलेस डिबगिंग_ को **सक्षम** करना होगा।
संस्थाएँ इसे MDM के माध्यम से या `settings put global development_settings_enabled 0` के माध्यम से ब्लॉक कर सकती हैं।
2. सेवा अपने नाम `moe.shizuku.privileged.api` के तहत पंजीकृत होती है।
एक साधारण `adb shell service list | grep shizuku` (या एंडपॉइंट सुरक्षा नियम) इसकी उपस्थिति का पता लगाता है।
3. क्षमताएँ उस पर सीमित हैं जो `shell` उपयोगकर्ता पहले से कर सकता है - यह **रूट** नहीं है।
संवेदनशील APIs जो `system` या `root` उपयोगकर्ता की आवश्यकता होती हैं, अभी भी अप्राप्य हैं।
4. सत्र **रिबूट** के बाद जीवित नहीं रहते जब तक डिवाइस रूटेड न हो और Shizuku को स्टार्टअप डेमॉन के रूप में कॉन्फ़िगर न किया गया हो।

---
## 5. शमन
* उत्पादन उपकरणों पर USB/वायरलेस डिबगिंग को बंद करें।
* `moe.shizuku.privileged.api` को उजागर करने वाली बाइंडर सेवाओं की निगरानी करें।
* unmanaged एप्लिकेशनों से AIDL इंटरफेस को ब्लॉक करने के लिए SELinux नीतियों (Android enterprise) का उपयोग करें।

---
## संदर्भ

- [Blog – Shizuku: Unlocking Advanced Android Capabilities Without Root](https://www.mobile-hacker.com/2025/07/14/shizuku-unlocking-advanced-android-capabilities-without-root/)
- [Shizuku Official Documentation](https://shizuku.rikka.app/)
- [awesome-shizuku – list of supported apps](https://github.com/timschneeb/awesome-shizuku)
- [rish shell (privileged reverse-adb shell)](https://github.com/RikkaApps/Shizuku/blob/master/RISH.md)

{{#include ../../banners/hacktricks-training.md}}
