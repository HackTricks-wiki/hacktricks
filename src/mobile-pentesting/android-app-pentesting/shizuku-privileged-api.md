# Shizuku Privileged API

{{#include ../../banners/hacktricks-training.md}}

Shizuku 是一个开源服务，**使用 `app_process` 启动一个特权 Java 进程**，并通过 Binder 暴露选定的 **Android 系统 API**。由于该进程以与 ADB 相同的 **`shell` UID 权限**启动，任何绑定到导出的 AIDL 接口的应用程序（或终端）都可以执行许多通常需要 **`WRITE_SECURE_SETTINGS`、`INSTALL_PACKAGES`、在 `/data` 内的文件 I/O** 等操作 – **无需获取设备的 root 权限**。

典型用例：
* 从未 root 的手机进行安全审计
* 移除预装软件 / 精简系统应用
* 收集日志、Wi-Fi 密钥、进程和套接字信息以供蓝队/DFIR 使用
* 从自定义应用或 shell 脚本自动配置设备

---
## 1. 启动特权服务

`moe.shizuku.privileged.api` 可以通过三种不同方式启动 – 结果 Binder 服务在所有情况下表现相同。

### 1.1 无线 ADB (Android 11+)
1. 启用 **开发者选项 ➜ 无线调试** 并配对设备。
2. 在 Shizuku 应用中选择 **“通过无线调试启动”** 并复制配对代码。
3. 服务在下次重启之前保持有效（无线调试会话在启动时清除）。

### 1.2 USB / 本地 ADB 一行命令
```bash
adb push start.sh \
/storage/emulated/0/Android/data/moe.shizuku.privileged.api/

# spawn the privileged process
adb shell sh /storage/emulated/0/Android/data/moe.shizuku.privileged.api/start.sh
```
同样的脚本可以通过 **network ADB** 连接执行（`adb connect <IP>:5555`）。

### 1.3 已获取root权限的设备
如果设备已经获取root权限，请运行：
```bash
su -c sh /data/adb/shizuku/start.sh
```
### 1.4 验证它是否正在运行
```bash
adb shell dumpsys activity service moe.shizuku.privileged.api | head
```
成功启动会返回 `Running services (1)` 以及特权进程的 PID。

---
## 2. 从应用程序绑定
第三方应用只需在其 `AndroidManifest.xml` 中包含以下内容：
```xml
<uses-permission android:name="moe.shizuku.manager.permission.API"/>
```
在运行时，他们获取了 binder：
```java
IBinder binder = ShizukuProvider.getBinder();
IPackageManager pm  = IPackageManager.Stub.asInterface(binder);
```
从此时起，应用程序可以调用任何**`shell`用户**可能调用的方法，例如：
```java
pm.installPackage(new Uri("file:///sdcard/app.apk"), null, 0, null);
Settings.Global.putInt(resolver, Settings.Global.ADB_ENABLED, 1);
```
维护着一个超过 **170 个 Shizuku 启用应用程序** 的精选列表，地址在 [awesome-shizuku](https://github.com/timschneeb/awesome-shizuku)。

---
## 3. Rish – 在 Termux 中的提升 shell
Shizuku 设置屏幕显示 **“在终端应用中使用 Shizuku”**。启用它会下载 *rish* (`/data/local/tmp/rish`)。
```bash
pkg install wget
wget https://rikka.app/rish/latest -O rish && chmod +x rish

# start elevated shell (inherits the binder connection)
./rish
whoami   #  ➜  shell
id       #  uid=2000(shell) gid=2000(shell) groups=... context=u:r:shell:s0
```
### 3.1 有用的 rish shell 命令
* 列出给定包的运行进程：
```bash
ps -A | grep com.facebook.katana
```
* 枚举监听套接字并将其映射到包（例如 **CVE-2019-6447 ES File Explorer**）：
```bash
netstat -tuln
for pid in $(lsof -nP -iTCP -sTCP:LISTEN -t); do
printf "%s -> %s\n" "$pid" "$(cat /proc/$pid/cmdline)";
done
```
* 转储每个应用程序的日志：
```bash
logcat -d | grep -iE "(error|exception)"
```
* 读取存储的 Wi-Fi 凭据（Android 11 及以上）：
```bash
cat /data/misc/wifi/WifiConfigStore.xml | grep -i "<ConfigKey>"
```
* 批量卸载（示例）：
```bash
pm uninstall --user 0 com.miui.weather2
```

---
## 4. 安全考虑 / 检测
1. Shizuku 需要 **ADB 调试** 权限，因此 _开发者选项 → USB/无线调试_ 必须 **启用**。
组织可以通过 MDM 或 `settings put global development_settings_enabled 0` 来阻止此操作。
2. 该服务以 `moe.shizuku.privileged.api` 的名称注册自己。
简单的 `adb shell service list | grep shizuku`（或端点安全规则）可以检测到它的存在。
3. 功能仅限于 `shell` 用户已经可以做的事情 – 它 **不是 root**。
需要 `system` 或 `root` 用户的敏感 API 仍然无法访问。
4. 会话在重启后 **不会存活**，除非设备已获得 root 权限并且 Shizuku 被配置为启动守护进程。

---
## 5. 缓解措施
* 在生产设备上禁用 USB/无线调试。
* 监控暴露 `moe.shizuku.privileged.api` 的 Binder 服务。
* 使用 SELinux 策略（Android 企业）阻止未管理应用程序访问 AIDL 接口。

---
## 参考文献

- [Blog – Shizuku: Unlocking Advanced Android Capabilities Without Root](https://www.mobile-hacker.com/2025/07/14/shizuku-unlocking-advanced-android-capabilities-without-root/)
- [Shizuku 官方文档](https://shizuku.rikka.app/)
- [awesome-shizuku – 支持的应用程序列表](https://github.com/timschneeb/awesome-shizuku)
- [rish shell (特权反向 adb shell)](https://github.com/RikkaApps/Shizuku/blob/master/RISH.md)

{{#include ../../banners/hacktricks-training.md}}
