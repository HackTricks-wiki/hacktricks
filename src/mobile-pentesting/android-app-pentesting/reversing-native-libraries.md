# Ingeniería inversa de bibliotecas nativas

{{#include ../../banners/hacktricks-training.md}}


**Para más información consulta:** [**https://maddiestone.github.io/AndroidAppRE/reversing_native_libs.html**](https://maddiestone.github.io/AndroidAppRE/reversing_native_libs.html)

Las apps Android pueden usar bibliotecas nativas, típicamente escritas en C o C++, para tareas críticas de rendimiento. Los creadores de malware también abusan de estas bibliotecas porque los objetos compartidos ELF siguen siendo más difíciles de decompilar que el byte-code DEX/OAT.
Esta página se centra en flujos de trabajo *prácticos* y en mejoras recientes de herramientas (2023-2025) que facilitan la ingeniería inversa de archivos `.so` de Android.

---

### Flujo rápido de triaje para un `libfoo.so` recién extraído

1. **Extraer la biblioteca**
```bash
# From an installed application
adb shell "run-as <pkg> cat lib/arm64-v8a/libfoo.so" > libfoo.so
# Or from the APK (zip)
unzip -j target.apk "lib/*/libfoo.so" -d extracted_libs/
```
2. **Identificar arquitectura y protecciones**
```bash
file libfoo.so        # arm64 or arm32 / x86
readelf -h libfoo.so  # OS ABI, PIE, NX, RELRO, etc.
checksec --file libfoo.so  # (peda/pwntools)
```
3. **Listar símbolos exportados y vínculos JNI**
```bash
readelf -s libfoo.so | grep ' Java_'     # dynamic-linked JNI
strings libfoo.so   | grep -i "RegisterNatives" -n   # static-registered JNI
```
4. **Cargar en un decompilador** (Ghidra ≥ 11.0, IDA Pro, Binary Ninja, Hopper or Cutter/Rizin) y ejecutar análisis automático.
Las versiones recientes de Ghidra introdujeron un decompilador AArch64 que reconoce stubs PAC/BTI y etiquetas MTE, mejorando considerablemente el análisis de bibliotecas compiladas con el NDK de Android 14.
5. **Decidir entre reversing estático o dinámico:** el código sin símbolos (stripped) u ofuscado a menudo necesita *instrumentación* (Frida, ptrace/gdbserver, LLDB).

---

### Instrumentación dinámica (Frida ≥ 16)

La serie 16 de Frida introdujo varias mejoras específicas para Android que ayudan cuando el objetivo usa optimizaciones modernas de Clang/LLD:

* `thumb-relocator` ahora puede *hook tiny ARM/Thumb functions* generadas por el alineamiento agresivo de LLD (`--icf=all`).
* La enumeración y re-enlace de *ELF import slots* funciona en Android, permitiendo parchear por módulo con `dlopen()`/`dlsym()` cuando los inline hooks son rechazados.
* Se corrigió Java hooking para el nuevo **ART quick-entrypoint** usado cuando las apps se compilan con `--enable-optimizations` en Android 14.

Ejemplo: enumerando todas las funciones registradas a través de `RegisterNatives` y volcando sus direcciones en tiempo de ejecución:
```javascript
Java.perform(function () {
var Runtime = Java.use('java.lang.Runtime');
var register = Module.findExportByName(null, 'RegisterNatives');
Interceptor.attach(register, {
onEnter(args) {
var envPtr  = args[0];
var clazz   = Java.cast(args[1], Java.use('java.lang.Class'));
var methods = args[2];
var count   = args[3].toInt32();
console.log('[+] RegisterNatives on ' + clazz.getName() + ' -> ' + count + ' methods');
// iterate & dump (JNI nativeMethod struct: name, sig, fnPtr)
}
});
});
```
Frida funcionará sin configuración adicional en dispositivos con PAC/BTI (Pixel 8/Android 14+) siempre que uses frida-server 16.2 o posterior – versiones anteriores no conseguían localizar el padding para inline hooks.

### Telemetría JNI local al proceso mediante .so precargado (SoTap)

Cuando la instrumentación completa es excesiva o está bloqueada, aún puedes obtener visibilidad a nivel nativo precargando un pequeño logger dentro del proceso objetivo. SoTap es una biblioteca nativa ligera de Android (.so) que registra el comportamiento en tiempo de ejecución de otras bibliotecas JNI (.so) dentro del mismo proceso de la app (no se requiere root).

Key properties:
- Se inicializa temprano y observa las interacciones JNI/nativas dentro del proceso que la carga.
- Persiste logs usando múltiples rutas escribibles con graceful fallback a Logcat cuando el almacenamiento está restringido.
- Source-customizable: edita sotap.c para ampliar/ajustar lo que se registra y recompila por ABI.

Setup (repack the APK):
1) Drop the proper ABI build into the APK so the loader can resolve libsotap.so:
- lib/arm64-v8a/libsotap.so (for arm64)
- lib/armeabi-v7a/libsotap.so (for arm32)
2) Ensure SoTap loads before other JNI libs. Inject a call early (e.g., Application subclass static initializer or onCreate) so the logger is initialized first. Smali snippet example:
```smali
const-string v0, "sotap"
invoke-static {v0}, Ljava/lang/System;->loadLibrary(Ljava/lang/String;)V
```
3) Rebuild/sign/install, run the app, then collect logs.

Log paths (checked in order):
```
/data/user/0/%s/files/sotap.log
/data/data/%s/files/sotap.log
/sdcard/Android/data/%s/files/sotap.log
/sdcard/Download/sotap-%s.log
# If all fail: fallback to Logcat only
```
Notas y solución de problemas:
- ABI alignment is mandatory. A mismatch will raise UnsatisfiedLinkError and the logger won’t load.
- Storage constraints are common on modern Android; if file writes fail, SoTap will still emit via Logcat.
- Behavior/verbosity is intended to be customized; rebuild from source after editing sotap.c.

This approach is useful for triage de malware and JNI debugging where observing native call flows from process start is critical but root/system-wide hooks aren’t available.

---

### Vulnerabilidades recientes que vale la pena buscar en APKs

| Año | CVE | Librería afectada | Notas |
|------|-----|------------------|-------|
|2023|CVE-2023-4863|`libwebp` ≤ 1.3.1|Desbordamiento de búfer en el heap accesible desde código nativo que decodifica imágenes WebP. Varias apps Android incluyen versiones vulnerables. Cuando veas un `libwebp.so` dentro de un APK, comprueba su versión e intenta explotarlo o parchearlo.| |
|2024|Multiple|OpenSSL 3.x series|Varios problemas de seguridad de memoria y padding-oracle. Muchos bundles de Flutter & ReactNative incluyen su propio `libcrypto.so`.|

Cuando detectes archivos `.so` de *terceros* dentro de un APK, siempre verifica su hash contra los avisos upstream. SCA (Software Composition Analysis) es poco común en móvil, por lo que las compilaciones vulnerables y desactualizadas son frecuentes.

---

### Tendencias de Anti-Reversing y Hardening (Android 13-15)

* **Pointer Authentication (PAC) & Branch Target Identification (BTI):** Android 14 habilita PAC/BTI en las bibliotecas del sistema en silicio ARMv8.3+ compatible. Los decompiladores ahora muestran pseudo-instrucciones relacionadas con PAC; para análisis dinámico Frida inyecta trampolines *after* stripping PAC, pero tus trampolines personalizados deben llamar a `pacda`/`autibsp` cuando sea necesario.
* **MTE & Scudo hardened allocator:** memory-tagging is opt-in but many Play-Integrity aware apps build with `-fsanitize=memtag`; use `setprop arm64.memtag.dump 1` plus `adb shell am start ...` to capture tag faults.
* **LLVM Obfuscator (opaque predicates, control-flow flattening):** los packers comerciales (p. ej., Bangcle, SecNeo) protegen cada vez más código *nativo*, no solo Java; espera bogus control-flow y blobs de strings encriptados en `.rodata`.

---

### Recursos

- **Aprender ARM Assembly:** [Azeria Labs – ARM Assembly Basics](https://azeria-labs.com/writing-arm-assembly-part-1/)
- **Documentación JNI & NDK:** [Oracle JNI Spec](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html) · [Android JNI Tips](https://developer.android.com/training/articles/perf-jni) · [NDK Guides](https://developer.android.com/ndk/guides/)
- **Depuración de librerías nativas:** [Debug Android Native Libraries Using JEB Decompiler](https://medium.com/@shubhamsonani/how-to-debug-android-native-libraries-using-jeb-decompiler-eec681a22cf3)

### Referencias

- Registro de cambios de Frida 16.x (Android hooking, tiny-function relocation) – [frida.re/news](https://frida.re/news/)
- Aviso NVD para el overflow de `libwebp` CVE-2023-4863 – [nvd.nist.gov](https://nvd.nist.gov/vuln/detail/CVE-2023-4863)
- SoTap: Logger ligero in-app de comportamiento JNI (.so) – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- Lanzamientos de SoTap – [github.com/RezaArbabBot/SoTap/releases](https://github.com/RezaArbabBot/SoTap/releases)
- ¿Cómo trabajar con SoTap? – [t.me/ForYouTillEnd/13](https://t.me/ForYouTillEnd/13)

{{#include ../../banners/hacktricks-training.md}}
