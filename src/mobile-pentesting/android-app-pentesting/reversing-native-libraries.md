# 反向工程本地库

{{#include ../../banners/hacktricks-training.md}}


**更多信息请查看：** [**https://maddiestone.github.io/AndroidAppRE/reversing_native_libs.html**](https://maddiestone.github.io/AndroidAppRE/reversing_native_libs.html)

Android 应用可以使用本地库，通常用 C 或 C++ 编写，以处理对性能敏感的任务。malware 创建者也滥用这些库，因为 ELF 共享对象仍然比 DEX/OAT 字节码更难反编译。  
本页侧重于使反向 Android `.so` 文件更容易的*实用*工作流和*近期*工具改进（2023-2025）。

---

### 新提取 `libfoo.so` 的快速初步分析流程

1. **提取库**
```bash
# From an installed application
adb shell "run-as <pkg> cat lib/arm64-v8a/libfoo.so" > libfoo.so
# Or from the APK (zip)
unzip -j target.apk "lib/*/libfoo.so" -d extracted_libs/
```
2. **识别架构与保护**
```bash
file libfoo.so        # arm64 or arm32 / x86
readelf -h libfoo.so  # OS ABI, PIE, NX, RELRO, etc.
checksec --file libfoo.so  # (peda/pwntools)
```
3. **列出导出符号与 JNI 绑定**
```bash
readelf -s libfoo.so | grep ' Java_'     # dynamic-linked JNI
strings libfoo.so   | grep -i "RegisterNatives" -n   # static-registered JNI
```
4. **在反编译器中加载** (Ghidra ≥ 11.0, IDA Pro, Binary Ninja, Hopper or Cutter/Rizin) 并运行自动分析。  
较新的 Ghidra 版本引入了 AArch64 decompiler，能够识别 PAC/BTI stubs 和 MTE 标签，大大改进了使用 Android 14 NDK 构建的库的分析。
5. **决定静态还是动态逆向：** 被剥离或混淆的代码通常需要*插桩*（Frida、ptrace/gdbserver、LLDB）。

---

### 动态插桩 (Frida ≥ 16)

Frida 的 16 系列带来了若干针对 Android 的改进，对付使用现代 Clang/LLD 优化的目标很有帮助：

* `thumb-relocator` 现在可以 *hook* 由 LLD 的激进对齐（`--icf=all`）生成的微小 ARM/Thumb 函数。
* 在 Android 上枚举并重新绑定 ELF import slots 已可行，当 inline hooks 被拒绝时，支持按模块的 `dlopen()`/`dlsym()` 打补丁。
* 修复了针对新的 **ART quick-entrypoint** 的 Java hooking，该入口在使用 `--enable-optimizations` 在 Android 14 上编译应用时被使用。

示例：枚举所有通过 `RegisterNatives` 注册的函数并在运行时导出它们的地址：
```javascript
Java.perform(function () {
var Runtime = Java.use('java.lang.Runtime');
var register = Module.findExportByName(null, 'RegisterNatives');
Interceptor.attach(register, {
onEnter(args) {
var envPtr  = args[0];
var clazz   = Java.cast(args[1], Java.use('java.lang.Class'));
var methods = args[2];
var count   = args[3].toInt32();
console.log('[+] RegisterNatives on ' + clazz.getName() + ' -> ' + count + ' methods');
// iterate & dump (JNI nativeMethod struct: name, sig, fnPtr)
}
});
});
```
Frida will work out of the box on PAC/BTI-enabled devices (Pixel 8/Android 14+) as long as you use frida-server 16.2 or later – earlier versions failed to locate padding for inline hooks.

### 通过预加载 .so 在进程内获取 JNI 级遥测 (SoTap)

当完整的 instrumentation 过于繁重或被阻止时，你仍可以通过在目标进程内部预加载一个小型 logger 来获得 native 级可见性。SoTap 是一个轻量级的 Android native (.so) 库，用于记录同一应用进程内其他 JNI (.so) 库的运行时行为（无需 root）。

主要特性：
- 尽早初始化并观察加载它的进程内的 JNI/native 交互。
- 使用多个可写路径持久化日志，并在存储受限时优雅地回退到 Logcat。
- 可自定义源码：编辑 sotap.c 以扩展/调整记录内容，并针对各 ABI 重新构建。

设置（重新打包 APK）:
1) 将对应 ABI 的构建放入 APK，使加载器能够解析 libsotap.so：
- lib/arm64-v8a/libsotap.so (for arm64)
- lib/armeabi-v7a/libsotap.so (for arm32)
2) 确保 SoTap 在其他 JNI libs 之前加载。尽早注入调用（例如，在 Application 子类的静态初始化器或 onCreate 中），以便首先初始化 logger。Smali snippet example:
```smali
const-string v0, "sotap"
invoke-static {v0}, Ljava/lang/System;->loadLibrary(Ljava/lang/String;)V
```
3) 重新构建/签名/安装，运行应用，然后收集日志。

日志路径（按顺序检查）：
```
/data/user/0/%s/files/sotap.log
/data/data/%s/files/sotap.log
/sdcard/Android/data/%s/files/sotap.log
/sdcard/Download/sotap-%s.log
# If all fail: fallback to Logcat only
```
Notes and troubleshooting:
- ABI alignment is mandatory. A mismatch will raise UnsatisfiedLinkError and the logger won’t load.
- Storage constraints are common on modern Android; if file writes fail, SoTap will still emit via Logcat.
- Behavior/verbosity is intended to be customized; rebuild from source after editing sotap.c.

This approach is useful for malware triage and JNI debugging where observing native call flows from process start is critical but root/system-wide hooks aren’t available.

---

### See also: in‑memory native code execution via JNI

A common attack pattern is to download a raw shellcode blob at runtime and execute it directly from memory through a JNI bridge (no on‑disk ELF). Details and ready‑to‑use JNI snippet here:

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

---

### Recent vulnerabilities worth hunting for in APKs

| Year | CVE | Affected library | Notes |
|------|-----|------------------|-------|
|2023|CVE-2023-4863|`libwebp` ≤ 1.3.1|Heap buffer overflow reachable from native code that decodes WebP images. Several Android apps bundle vulnerable versions. When you see a `libwebp.so` inside an APK, check its version and attempt exploitation or patching.| |
|2024|Multiple|OpenSSL 3.x series|Several memory-safety and padding-oracle issues. Many Flutter & ReactNative bundles ship their own `libcrypto.so`.|

When you spot *third-party* `.so` files inside an APK, always cross-check their hash against upstream advisories. SCA (Software Composition Analysis) is uncommon on mobile, so outdated vulnerable builds are rampant.

---

### Anti-Reversing & Hardening trends (Android 13-15)

* **Pointer Authentication (PAC) & Branch Target Identification (BTI):** Android 14 enables PAC/BTI in system libraries on supported ARMv8.3+ silicon. Decompilers now display PAC‐related pseudo-instructions; for dynamic analysis Frida injects trampolines *after* stripping PAC, but your custom trampolines should call `pacda`/`autibsp` where necessary.
* **MTE & Scudo hardened allocator:** memory-tagging is opt-in but many Play-Integrity aware apps build with `-fsanitize=memtag`; use `setprop arm64.memtag.dump 1` plus `adb shell am start ...` to capture tag faults.
* **LLVM Obfuscator (opaque predicates, control-flow flattening):** commercial packers (e.g., Bangcle, SecNeo) increasingly protect *native* code, not only Java; expect bogus control-flow and encrypted string blobs in `.rodata`.

---

### Resources

- **Learning ARM Assembly:** [Azeria Labs – ARM Assembly Basics](https://azeria-labs.com/writing-arm-assembly-part-1/)
- **JNI & NDK Documentation:** [Oracle JNI Spec](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html) · [Android JNI Tips](https://developer.android.com/training/articles/perf-jni) · [NDK Guides](https://developer.android.com/ndk/guides/)
- **Debugging Native Libraries:** [Debug Android Native Libraries Using JEB Decompiler](https://medium.com/@shubhamsonani/how-to-debug-android-native-libraries-using-jeb-decompiler-eec681a22cf3)

### References

- Frida 16.x change-log (Android hooking, tiny-function relocation) – [frida.re/news](https://frida.re/news/)
- NVD advisory for `libwebp` overflow CVE-2023-4863 – [nvd.nist.gov](https://nvd.nist.gov/vuln/detail/CVE-2023-4863)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- SoTap Releases – [github.com/RezaArbabBot/SoTap/releases](https://github.com/RezaArbabBot/SoTap/releases)
- How to work with SoTap? – [t.me/ForYouTillEnd/13](https://t.me/ForYouTillEnd/13)
- [CoRPhone — JNI memory-only execution pattern and packaging](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
