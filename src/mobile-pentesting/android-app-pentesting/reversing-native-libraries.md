# Реверсія нативних бібліотек

{{#include ../../banners/hacktricks-training.md}}

**Для отримання додаткової інформації дивіться:** [**https://maddiestone.github.io/AndroidAppRE/reversing_native_libs.html**](https://maddiestone.github.io/AndroidAppRE/reversing_native_libs.html)

Android додатки можуть використовувати нативні бібліотеки, зазвичай написані на C або C++, для критично важливих завдань з точки зору продуктивності. Творці шкідливого ПЗ також зловживають цими бібліотеками, оскільки ELF спільні об'єкти все ще важче декомпілювати, ніж DEX/OAT байт-код. Ця сторінка зосереджена на *практичних* робочих процесах і *сучасних* покращеннях інструментів (2023-2025), які спрощують реверсування Android `.so` файлів.

---

### Швидкий робочий процес для свіжовитягнутої `libfoo.so`

1. **Витягніть бібліотеку**
```bash
# З встановленого додатку
adb shell "run-as <pkg> cat lib/arm64-v8a/libfoo.so" > libfoo.so
# Або з APK (zip)
unzip -j target.apk "lib/*/libfoo.so" -d extracted_libs/
```
2. **Визначте архітектуру та захисти**
```bash
file libfoo.so        # arm64 або arm32 / x86
readelf -h libfoo.so  # OS ABI, PIE, NX, RELRO тощо
checksec --file libfoo.so  # (peda/pwntools)
```
3. **Перерахуйте експортовані символи та прив'язки JNI**
```bash
readelf -s libfoo.so | grep ' Java_'     # динамічно зв'язані JNI
strings libfoo.so   | grep -i "RegisterNatives" -n   # статично зареєстровані JNI
```
4. **Завантажте в декомпілятор** (Ghidra ≥ 11.0, IDA Pro, Binary Ninja, Hopper або Cutter/Rizin) і запустіть автоаналіз. Новіші версії Ghidra представили декомпілятор AArch64, який розпізнає PAC/BTI стовпці та MTE теги, значно покращуючи аналіз бібліотек, створених з Android 14 NDK.
5. **Визначте, чи використовувати статичне чи динамічне реверсування:** знятий, обфускований код часто потребує *інструментації* (Frida, ptrace/gdbserver, LLDB).

---

### Динамічна інструментація (Frida ≥ 16)

Серія 16 Frida принесла кілька покращень, специфічних для Android, які допомагають, коли ціль використовує сучасні оптимізації Clang/LLD:

* `thumb-relocator` тепер може *перехоплювати маленькі ARM/Thumb функції*, згенеровані агресивним вирівнюванням LLD (`--icf=all`).
* Перерахування та повторне зв'язування *ELF імпортних слотів* працює на Android, що дозволяє патчинг `dlopen()`/`dlsym()` для кожного модуля, коли вбудовані хуки відхиляються.
* Хукінг Java був виправлений для нового **ART швидкого входу**, що використовується, коли додатки компілюються з `--enable-optimizations` на Android 14.

Приклад: перерахування всіх функцій, зареєстрованих через `RegisterNatives`, і вивантаження їх адрес під час виконання:
```javascript
Java.perform(function () {
var Runtime = Java.use('java.lang.Runtime');
var register = Module.findExportByName(null, 'RegisterNatives');
Interceptor.attach(register, {
onEnter(args) {
var envPtr  = args[0];
var clazz   = Java.cast(args[1], Java.use('java.lang.Class'));
var methods = args[2];
var count   = args[3].toInt32();
console.log('[+] RegisterNatives on ' + clazz.getName() + ' -> ' + count + ' methods');
// iterate & dump (JNI nativeMethod struct: name, sig, fnPtr)
}
});
});
```
Frida буде працювати з коробки на пристроях з підтримкою PAC/BTI (Pixel 8/Android 14+), якщо ви використовуєте frida-server 16.2 або новішу версію – попередні версії не змогли знайти заповнення для вбудованих хуків.  citeturn5search2turn5search0

---

### Останні вразливості, які варто шукати в APK

| Рік | CVE | Вразлива бібліотека | Примітки |
|------|-----|------------------|-------|
|2023|CVE-2023-4863|`libwebp` ≤ 1.3.1|Переповнення буфера купи, доступне з рідного коду, що декодує зображення WebP. Кілька Android додатків містять вразливі версії. Коли ви бачите `libwebp.so` всередині APK, перевірте його версію та спробуйте експлуатацію або патчування.| citeturn2search0|
|2024|Кілька|Серія OpenSSL 3.x|Кілька проблем з безпекою пам'яті та padding-oracle. Багато пакетів Flutter та ReactNative постачають свої власні `libcrypto.so`.|

Коли ви помічаєте *третіх сторін* `.so` файли всередині APK, завжди перевіряйте їх хеш проти upstream advisory. SCA (Аналіз складу програмного забезпечення) є рідкісним на мобільних пристроях, тому застарілі вразливі збірки поширені.

---

### Тенденції анти-реверсії та зміцнення (Android 13-15)

* **Аутентифікація вказівників (PAC) та ідентифікація цілей гілок (BTI):** Android 14 активує PAC/BTI в системних бібліотеках на підтримуваних ARMv8.3+ чіпах. Декомпілери тепер відображають псевдо-інструкції, пов'язані з PAC; для динамічного аналізу Frida інжектує trampolines *після* видалення PAC, але ваші власні trampolines повинні викликати `pacda`/`autibsp`, де це необхідно.
* **MTE та Scudo зміцнений аллокатор:** тегування пам'яті є опційним, але багато додатків, що враховують Play-Integrity, будуються з `-fsanitize=memtag`; використовуйте `setprop arm64.memtag.dump 1` плюс `adb shell am start ...` для захоплення помилок тегів.
* **LLVM Obfuscator (непрозорі предикати, сплющення контролю потоку):** комерційні пакувальники (наприклад, Bangcle, SecNeo) все більше захищають *рідний* код, а не тільки Java; очікуйте фальшивий контроль потоку та зашифровані рядкові об'єкти в `.rodata`.

---

### Ресурси

- **Вивчення ARM Assembly:** [Azeria Labs – Основи ARM Assembly](https://azeria-labs.com/writing-arm-assembly-part-1/)
- **Документація JNI та NDK:** [Oracle JNI Spec](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html) · [Android JNI Tips](https://developer.android.com/training/articles/perf-jni) · [NDK Guides](https://developer.android.com/ndk/guides/)
- **Налагодження рідних бібліотек:** [Налагодження рідних бібліотек Android за допомогою JEB Decompiler](https://medium.com/@shubhamsonani/how-to-debug-android-native-libraries-using-jeb-decompiler-eec681a22cf3)

### Посилання

- Журнал змін Frida 16.x (Android hooking, переміщення tiny-function) – [frida.re/news](https://frida.re/news/)  citeturn5search0
- Консультація NVD для переповнення `libwebp` CVE-2023-4863 – [nvd.nist.gov](https://nvd.nist.gov/vuln/detail/CVE-2023-4863) citeturn2search0

{{#include ../../banners/hacktricks-training.md}}
