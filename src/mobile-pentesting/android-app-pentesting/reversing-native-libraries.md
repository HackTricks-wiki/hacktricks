# नेटिव लाइब्रेरीज़ को रिवर्स करना

{{#include ../../banners/hacktricks-training.md}}


**अधिक जानकारी के लिए देखें:** [**https://maddiestone.github.io/AndroidAppRE/reversing_native_libs.html**](https://maddiestone.github.io/AndroidAppRE/reversing_native_libs.html)

Android apps प्रदर्शन-सम्बन्धी कार्यों के लिए आमतौर पर C या C++ में लिखी गई नेटिव लाइब्रेरीज़ का उपयोग कर सकते हैं। Malware रचनाकार भी इन लाइब्रेरीज़ का दुरुपयोग करते हैं क्योंकि ELF shared objects को DEX/OAT byte-code की तुलना में अभी भी decompile करना कठिन होता है।
यह पृष्ठ *व्यावहारिक* workflows और *हाल के* tooling सुधारों (2023-2025) पर केंद्रित है जो Android `.so` फ़ाइलों को रिवर्स करना आसान बनाते हैं।

---

### एक नए निकाले गए `libfoo.so` के लिए त्वरित ट्रायेज-वर्कफ़्लो

1. **लाइब्रेरी निकालना**
```bash
# From an installed application
adb shell "run-as <pkg> cat lib/arm64-v8a/libfoo.so" > libfoo.so
# Or from the APK (zip)
unzip -j target.apk "lib/*/libfoo.so" -d extracted_libs/
```
2. **आर्किटेक्चर और सुरक्षा पहचानें**
```bash
file libfoo.so        # arm64 or arm32 / x86
readelf -h libfoo.so  # OS ABI, PIE, NX, RELRO, etc.
checksec --file libfoo.so  # (peda/pwntools)
```
3. **Exported symbols और JNI bindings सूचीबद्ध करें**
```bash
readelf -s libfoo.so | grep ' Java_'     # dynamic-linked JNI
strings libfoo.so   | grep -i "RegisterNatives" -n   # static-registered JNI
```
4. **किसी decompiler में लोड करें** (Ghidra ≥ 11.0, IDA Pro, Binary Ninja, Hopper or Cutter/Rizin) और auto-analysis चलाएँ।
नवीन Ghidra संस्करणों में एक AArch64 decompiler शामिल है जो PAC/BTI stubs और MTE tags को पहचानता है, जिससे Android 14 NDK से बनी लाइब्रेरीज़ के विश्लेषण में काफी सुधार हुआ है।
5. **static बनाम dynamic reversing तय करें:** stripped, obfuscated code अक्सर *instrumentation* की जरूरत होती है (Frida, ptrace/gdbserver, LLDB).

---

### डायनामिक Instrumentation (Frida ≥ 16)

Frida के 16-series ने कई Android-विशिष्ट सुधार लाए हैं जो तब मदद करते हैं जब target आधुनिक Clang/LLD optimisations का उपयोग करता है:

* `thumb-relocator` अब LLD की aggressive alignment (`--icf=all`) द्वारा जनरेट की गई छोटी ARM/Thumb functions को *hook* कर सकता है।
* `ELF import slots` की enumerating और rebinding Android पर काम करती है, जिससे inline hooks अस्वीकार होने पर per-module `dlopen()`/`dlsym()` patching संभव होता है।
* Java hooking को नए **ART quick-entrypoint** के लिए फिक्स किया गया जो तब इस्तेमाल होता है जब apps Android 14 पर `--enable-optimizations` के साथ compiled होते हैं।

Example: enumerating all functions registered through `RegisterNatives` and dumping their addresses at runtime:
```javascript
Java.perform(function () {
var Runtime = Java.use('java.lang.Runtime');
var register = Module.findExportByName(null, 'RegisterNatives');
Interceptor.attach(register, {
onEnter(args) {
var envPtr  = args[0];
var clazz   = Java.cast(args[1], Java.use('java.lang.Class'));
var methods = args[2];
var count   = args[3].toInt32();
console.log('[+] RegisterNatives on ' + clazz.getName() + ' -> ' + count + ' methods');
// iterate & dump (JNI nativeMethod struct: name, sig, fnPtr)
}
});
});
```
Frida PAC/BTI-enabled डिवाइसों (Pixel 8/Android 14+) पर सीधे काम करेगा, बशर्ते आप frida-server 16.2 या बाद का उपयोग करें — पुराने वर्शन inline hooks के लिए padding ढूँढने में विफल होते थे।

### Preloaded .so (SoTap) के माध्यम से Process-local JNI telemetry

जब full-featured instrumentation ज़रूरत से ज़्यादा हो या blocked हो, तब भी आप target process के अंदर एक छोटा logger preload करके native-level visibility हासिल कर सकते हैं। SoTap एक lightweight Android native (.so) लाइब्रेरी है जो उसी app process के भीतर अन्य JNI (.so) लाइब्रेरियों के runtime व्यवहार को log करती है (no root required).

Key properties:
- जल्दी initialize होता है और उस process के अंदर JNI/native interactions को observe करता है जो इसे लोड करता है।
- Logs को कई writable paths में persist करता है और जब storage restricted हो तो graceful fallback के तौर पर Logcat का उपयोग करता है।
- Source-customizable: sotap.c को edit करके जो log होता है उसे extend/adjust करें और प्रत्येक ABI के लिए rebuild करें।

Setup (repack the APK):
1) Drop the proper ABI build into the APK so the loader can resolve libsotap.so:
- lib/arm64-v8a/libsotap.so (for arm64)
- lib/armeabi-v7a/libsotap.so (for arm32)
2) Ensure SoTap loads before other JNI libs. Inject a call early (e.g., Application subclass static initializer or onCreate) so the logger is initialized first. Smali snippet example:
```smali
const-string v0, "sotap"
invoke-static {v0}, Ljava/lang/System;->loadLibrary(Ljava/lang/String;)V
```
3) Rebuild/sign/install करें, ऐप चलाएँ, फिर logs इकट्ठा करें।

Log paths (checked in order):
```
/data/user/0/%s/files/sotap.log
/data/data/%s/files/sotap.log
/sdcard/Android/data/%s/files/sotap.log
/sdcard/Download/sotap-%s.log
# If all fail: fallback to Logcat only
```
नोट्स और समस्या निवारण:
- ABI alignment अनिवार्य है। किसी असंगति से UnsatisfiedLinkError होगी और logger लोड नहीं होगा।
- आधुनिक Android पर स्टोरेज सीमाएँ आम हैं; यदि फ़ाइल लिखना विफल होता है, तो SoTap फिर भी Logcat के माध्यम से लॉग भेजेगा।
- व्यवहार/verbosity को अनुकूलित करने के लिए बनाया गया है; sotap.c संपादित करने के बाद स्रोत से पुनर्निर्माण करें।

यह तरीका मैलवेयर ट्रायज और JNI डिबगिंग के लिए उपयोगी है जहाँ process की शुरुआत से native call flows का अवलोकन महत्वपूर्ण हो पर root/system-wide hooks उपलब्ध नहीं होते।

---

### APKs में खोजने योग्य हालिया कमजोरियाँ

| साल | CVE | प्रभावित लाइब्रेरी | नोट्स |
|------|-----|------------------|-------|
|2023|CVE-2023-4863|`libwebp` ≤ 1.3.1|हीप बफर ओवरफ़्लो जो WebP इमेजेस को डिकोड करने वाले native कोड से पहुँच योग्य है। कई Android ऐप्स कमजोर वर्जन बंडल करते हैं। जब आप किसी APK के भीतर `libwebp.so` देखें, तो उसकी वर्जन जांचें और exploit या patch करने का प्रयास करें.| |
|2024|Multiple|OpenSSL 3.x series|कई memory-safety और padding-oracle समस्याएँ। कई Flutter & ReactNative बंडल अपने स्वयं के `libcrypto.so` के साथ शिप करते हैं।|

जब आप किसी APK के अंदर *third-party* `.so` फ़ाइलें देखें, तो हमेशा उनका हैश upstream advisories से cross-check करें। मोबाइल पर SCA (Software Composition Analysis) आम नहीं है, इसलिए पुराने कमजोर बिल्ड व्यापक हैं।

---

### Anti-Reversing & Hardening प्रवृत्तियाँ (Android 13-15)

* **Pointer Authentication (PAC) & Branch Target Identification (BTI):** Android 14 समर्थित ARMv8.3+ सिलिकॉन पर system libraries में PAC/BTI सक्षम करता है। Decompilers अब PAC‐संबंधित pseudo-instructions दिखाते हैं; dynamic analysis के लिए Frida PAC हटाने के बाद trampolines inject करता है, लेकिन आपके कस्टम trampolines जहां आवश्यक हों वहां `pacda`/`autibsp` कॉल करना चाहिए।
* **MTE & Scudo hardened allocator:** memory-tagging ऑप्ट-इन है पर कई Play-Integrity aware ऐप्स `-fsanitize=memtag` के साथ बिल्ड करते हैं; tag faults पकड़ने के लिए `setprop arm64.memtag.dump 1` और `adb shell am start ...` का उपयोग करें।
* **LLVM Obfuscator (opaque predicates, control-flow flattening):** commercial packers (e.g., Bangcle, SecNeo) तेजी से *native* कोड की सुरक्षा करते हैं, सिर्फ Java नहीं; `.rodata` में नकली control-flow और encrypted string ब्लॉब्स की उम्मीद रखें।

---

### Resources

- **Learning ARM Assembly:** [Azeria Labs – ARM Assembly Basics](https://azeria-labs.com/writing-arm-assembly-part-1/)
- **JNI & NDK Documentation:** [Oracle JNI Spec](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html) · [Android JNI Tips](https://developer.android.com/training/articles/perf-jni) · [NDK Guides](https://developer.android.com/ndk/guides/)
- **Debugging Native Libraries:** [Debug Android Native Libraries Using JEB Decompiler](https://medium.com/@shubhamsonani/how-to-debug-android-native-libraries-using-jeb-decompiler-eec681a22cf3)

### References

- Frida 16.x change-log (Android hooking, tiny-function relocation) – [frida.re/news](https://frida.re/news/)
- NVD advisory for `libwebp` overflow CVE-2023-4863 – [nvd.nist.gov](https://nvd.nist.gov/vuln/detail/CVE-2023-4863)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- SoTap Releases – [github.com/RezaArbabBot/SoTap/releases](https://github.com/RezaArbabBot/SoTap/releases)
- How to work with SoTap? – [t.me/ForYouTillEnd/13](https://t.me/ForYouTillEnd/13)

{{#include ../../banners/hacktricks-training.md}}
