# Reversing Native Libraries

{{#include ../../banners/hacktricks-training.md}}


**欲了解更多信息请参阅：** [**https://maddiestone.github.io/AndroidAppRE/reversing_native_libs.html**](https://maddiestone.github.io/AndroidAppRE/reversing_native_libs.html)

Android 应用可以使用 native libraries，通常用 C 或 C++ 编写，以处理性能关键的任务。恶意软件作者也滥用这些库，因为 ELF shared objects 仍然比 DEX/OAT byte-code 更难反编译。
本页侧重于 *practical* 工作流程和 *recent* 工具改进（2023–2025），这些改进使得逆向 Android `.so` 文件更容易。

---

### Quick triage-workflow for a freshly pulled `libfoo.so`

1. **Extract the library**
```bash
# From an installed application
adb shell "run-as <pkg> cat lib/arm64-v8a/libfoo.so" > libfoo.so
# Or from the APK (zip)
unzip -j target.apk "lib/*/libfoo.so" -d extracted_libs/
```
2. **Identify architecture & protections**
```bash
file libfoo.so        # arm64 or arm32 / x86
readelf -h libfoo.so  # OS ABI, PIE, NX, RELRO, etc.
checksec --file libfoo.so  # (peda/pwntools)
```
3. **List exported symbols & JNI bindings**
```bash
readelf -s libfoo.so | grep ' Java_'     # dynamic-linked JNI
strings libfoo.so   | grep -i "RegisterNatives" -n   # static-registered JNI
```
4. **Load in a decompiler** (Ghidra ≥ 11.0, IDA Pro, Binary Ninja, Hopper or Cutter/Rizin) 并运行自动分析。
较新的 Ghidra 版本引入了 AArch64 decompiler，能识别 PAC/BTI stubs 和 MTE tags，极大改善了使用 Android 14 NDK 构建的库的分析效果。
5. **Decide on static vs dynamic reversing:** 已剥离或混淆的代码通常需要 *instrumentation*（Frida、ptrace/gdbserver、LLDB）。

---

### Dynamic Instrumentation (Frida ≥ 16)

Frida 的 16 系列带来了若干 Android 专用的改进，这些改进在目标使用现代 Clang/LLD 优化时非常有帮助：

* `thumb-relocator` 现在可以 *hook tiny ARM/Thumb functions*，这些函数由 LLD 的激进对齐（`--icf=all`）生成。
* 在 Android 上可以枚举并重新绑定 *ELF import slots*，当 inline hooks 被拒绝时，这使得可以按模块进行 `dlopen()`/`dlsym()` 修补。
* 修复了 Java hooking，以适配在 Android 14 上使用 `--enable-optimizations` 编译时的 **ART quick-entrypoint**。

Example: enumerating all functions registered through `RegisterNatives` and dumping their addresses at runtime:
```javascript
Java.perform(function () {
var Runtime = Java.use('java.lang.Runtime');
var register = Module.findExportByName(null, 'RegisterNatives');
Interceptor.attach(register, {
onEnter(args) {
var envPtr  = args[0];
var clazz   = Java.cast(args[1], Java.use('java.lang.Class'));
var methods = args[2];
var count   = args[3].toInt32();
console.log('[+] RegisterNatives on ' + clazz.getName() + ' -> ' + count + ' methods');
// iterate & dump (JNI nativeMethod struct: name, sig, fnPtr)
}
});
});
```
Frida 在启用 PAC/BTI 的设备上（Pixel 8/Android 14+）开箱即可工作，只要你使用 frida-server 16.2 或更高版本 —— 早期版本无法定位 inline hooks 的 padding。

### Process-local JNI telemetry via preloaded .so (SoTap)

当完整的 instrumentation 过于繁重或被阻止时，你仍然可以通过在目标进程内预加载一个小型 logger 来获取本地级别的可见性。SoTap 是一个轻量级的 Android native (.so) 库，它记录同一应用进程内其他 JNI (.so) 库的运行时行为（不需要 root）。

Key properties:
- 在加载它的进程中尽早初始化并观察 JNI/native 交互。
- 使用多个可写路径持久化日志，在存储受限时优雅地回退到 Logcat。
- 源码可定制：编辑 sotap.c 以扩展/调整记录内容，并按 ABI 重新构建。

Setup (repack the APK):
1) 将对应 ABI 的构建放入 APK 中以便加载器可以解析 libsotap.so:
- lib/arm64-v8a/libsotap.so (for arm64)
- lib/armeabi-v7a/libsotap.so (for arm32)
2) 确保 SoTap 在其他 JNI 库之前加载。尽早注入一次调用（例如，在 Application 子类的 static initializer 或 onCreate 中），以便 logger 先被初始化。Smali 代码示例:
```smali
const-string v0, "sotap"
invoke-static {v0}, Ljava/lang/System;->loadLibrary(Ljava/lang/String;)V
```
3) 重建/签名/安装，运行应用，然后收集日志。

Log paths (checked in order):
```
/data/user/0/%s/files/sotap.log
/data/data/%s/files/sotap.log
/sdcard/Android/data/%s/files/sotap.log
/sdcard/Download/sotap-%s.log
# If all fail: fallback to Logcat only
```
注意事项与故障排除：
- ABI 对齐是必须的。对齐不匹配会抛出 UnsatisfiedLinkError，导致 logger 无法加载。
- 现代 Android 常见存储限制；如果文件写入失败，SoTap 仍会通过 Logcat 输出。
- 行为/冗长度（verbosity）可按需定制；在编辑 sotap.c 后请从源码重新构建。

该方法适用于 malware 分析和 JNI 调试，特别是在需要从进程启动阶段观察 native 调用流程且无法使用 root/系统范围 hook 时。

---

### 值得在 APK 中寻找的近期漏洞

| 年份 | CVE | 受影响的库 | 备注 |
|------|-----|------------------|-------|
|2023|CVE-2023-4863|`libwebp` ≤ 1.3.1|本地代码在解码 WebP 图像时可能触发堆缓冲区溢出。若干 Android 应用捆绑了易受影响的版本。当你在 APK 中看到 `libwebp.so` 时，应检查其版本并尝试利用或修补。| |
|2024|Multiple|OpenSSL 3.x series|存在多种内存安全问题和 padding-oracle 漏洞。许多 Flutter 与 ReactNative 包会随附自家的 `libcrypto.so`。|

当你在 APK 内发现第三方 `.so` 文件时，务必将其哈希与上游通告核对。移动端很少做 SCA (Software Composition Analysis)，因此过期的易受影响构建非常普遍。

---

### 反逆向与加固趋势（Android 13-15）

* **Pointer Authentication (PAC) & Branch Target Identification (BTI):** Android 14 在支持的 ARMv8.3+ 芯片上在系统库中启用 PAC/BTI。反编译器现在会显示与 PAC 相关的伪指令；用于动态分析时，Frida 会在去除 PAC 后注入 trampolines，但自定义的 trampolines 在必要时应调用 `pacda`/`autibsp`。
* **MTE & Scudo hardened allocator:** memory-tagging 是可选的，但许多启用 Play-Integrity 的应用会使用 `-fsanitize=memtag` 构建；可用 `setprop arm64.memtag.dump 1` 加上 `adb shell am start ...` 来捕获 tag fault。
* **LLVM Obfuscator (opaque predicates, control-flow flattening):** 商业加壳器（例如 Bangcle、SecNeo）越来越多地保护 *native* 代码，而不仅仅是 Java；在 `.rodata` 中会看到伪造的控制流和加密的字符串 blob。

---

### 资源

- **学习 ARM 汇编：** [Azeria Labs – ARM Assembly Basics](https://azeria-labs.com/writing-arm-assembly-part-1/)
- **JNI 与 NDK 文档：** [Oracle JNI Spec](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html) · [Android JNI Tips](https://developer.android.com/training/articles/perf-jni) · [NDK Guides](https://developer.android.com/ndk/guides/)
- **调试 Native 库：** [Debug Android Native Libraries Using JEB Decompiler](https://medium.com/@shubhamsonani/how-to-debug-android-native-libraries-using-jeb-decompiler-eec681a22cf3)

### 参考

- Frida 16.x 更新日志（Android hooking，tiny-function relocation） – [frida.re/news](https://frida.re/news/)
- 关于 `libwebp` 溢出的 NVD 咨询 CVE-2023-4863 – [nvd.nist.gov](https://nvd.nist.gov/vuln/detail/CVE-2023-4863)
- SoTap: 轻量级的应用内 JNI (.so) 行为记录器 – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- SoTap 发布 – [github.com/RezaArbabBot/SoTap/releases](https://github.com/RezaArbabBot/SoTap/releases)
- 如何使用 SoTap？ – [t.me/ForYouTillEnd/13](https://t.me/ForYouTillEnd/13)

{{#include ../../banners/hacktricks-training.md}}
