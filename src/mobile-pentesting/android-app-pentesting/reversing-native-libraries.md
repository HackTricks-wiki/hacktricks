# Yerel Kütüphanelerin Tersine Mühendisliği

{{#include ../../banners/hacktricks-training.md}}


**Daha fazla bilgi için bakınız:** [**https://maddiestone.github.io/AndroidAppRE/reversing_native_libs.html**](https://maddiestone.github.io/AndroidAppRE/reversing_native_libs.html)

Android uygulamaları performans-kritik görevler için genellikle C veya C++ ile yazılmış yerel kütüphaneler kullanabilir. Malware yazarları da bu kütüphaneleri kötüye kullanır çünkü ELF shared objects hâlâ DEX/OAT byte-code'dan daha zor decompile edilir.
Bu sayfa, Android `.so` dosyalarını tersine çevirmeyi kolaylaştıran *pratik* iş akışları ve *güncel* araç iyileştirmelerine (2023-2025) odaklanır.

---

### Yeni çekilmiş `libfoo.so` için hızlı triyaj iş akışı

1. **Kütüphaneyi çıkartın**
```bash
# From an installed application
adb shell "run-as <pkg> cat lib/arm64-v8a/libfoo.so" > libfoo.so
# Or from the APK (zip)
unzip -j target.apk "lib/*/libfoo.so" -d extracted_libs/
```
2. **Mimari ve korumaları tespit edin**
```bash
file libfoo.so        # arm64 or arm32 / x86
readelf -h libfoo.so  # OS ABI, PIE, NX, RELRO, etc.
checksec --file libfoo.so  # (peda/pwntools)
```
3. **Dışa aktarılan sembolleri ve JNI bağlarını listeleyin**
```bash
readelf -s libfoo.so | grep ' Java_'     # dynamic-linked JNI
strings libfoo.so   | grep -i "RegisterNatives" -n   # static-registered JNI
```
4. **Bir decompiler'a yükleyin** (Ghidra ≥ 11.0, IDA Pro, Binary Ninja, Hopper or Cutter/Rizin) ve otomatik analizi çalıştırın.
Yeni Ghidra sürümleri, PAC/BTI stub'larını ve MTE etiketlerini tanıyan bir AArch64 decompiler'ı getirdi; bu, Android 14 NDK ile derlenen kütüphanelerin analizini büyük ölçüde iyileştirir.
5. **Statik mi dinamik mi tersine mühendislik yapacağına karar verin:** strip'lenmiş veya obfuskelenmiş kod genellikle *instrumentation* gerektirir (Frida, ptrace/gdbserver, LLDB).

---

### Dinamik Enstrümantasyon (Frida ≥ 16)

Frida'nın 16 serisi, hedef modern Clang/LLD optimizasyonları kullandığında yardımcı olan birkaç Android'e özgü iyileştirme getirdi:

* `thumb-relocator` artık LLD'nin agresif hizalaması (`--icf=all`) tarafından oluşturulan küçük ARM/Thumb fonksiyonlarına *hook* atabilir.
* Android'de *ELF import slotlarını* listeleme ve yeniden bağlama çalışıyor; inline hook'lar reddedildiğinde modül başına `dlopen()`/`dlsym()` patchleme yapılmasına olanak tanır.
* Java hooking, Android 14'te uygulamalar `--enable-optimizations` ile derlendiğinde kullanılan yeni **ART quick-entrypoint** için düzeltildi.

Örnek: `RegisterNatives` aracılığıyla kayıtlı tüm fonksiyonları listeleyip çalışma zamanında adreslerini dökme:
```javascript
Java.perform(function () {
var Runtime = Java.use('java.lang.Runtime');
var register = Module.findExportByName(null, 'RegisterNatives');
Interceptor.attach(register, {
onEnter(args) {
var envPtr  = args[0];
var clazz   = Java.cast(args[1], Java.use('java.lang.Class'));
var methods = args[2];
var count   = args[3].toInt32();
console.log('[+] RegisterNatives on ' + clazz.getName() + ' -> ' + count + ' methods');
// iterate & dump (JNI nativeMethod struct: name, sig, fnPtr)
}
});
});
```
Frida, PAC/BTI-enabled devices (Pixel 8/Android 14+) üzerinde, frida-server 16.2 veya daha yenisini kullandığınız sürece kutudan çıktığı gibi çalışır — önceki sürümler inline hooks için padding'i bulamıyordu.

### Process-local JNI telemetry via preloaded .so (SoTap)

Tam özellikli instrumentation aşırı veya engellenmiş olduğunda, hedef süreç içinde küçük bir logger'ı önceden yükleyerek native düzeyde görünürlük elde edebilirsiniz. SoTap, aynı uygulama süreci içindeki diğer JNI (.so) kütüphanelerinin çalışma zamanındaki davranışını kaydeden hafif bir Android native (.so) kütüphanesidir (root gerektirmez).

Temel özellikler:
- Erken başlatılır ve bunu yükleyen süreç içindeki JNI/native etkileşimlerini gözlemler.
- Kayıtları çoklu yazılabilir yollar kullanarak saklar ve depolama kısıtlı olduğunda Logcat'e nazikçe geri döner.
- Kaynak-özelleştirilebilir: kayda alınacakları genişletmek/ayarlamak için sotap.c'yi düzenleyin ve ABI başına yeniden derleyin.

Kurulum (repack the APK):
1) Drop the proper ABI build into the APK so the loader can resolve libsotap.so:
- lib/arm64-v8a/libsotap.so (for arm64)
- lib/armeabi-v7a/libsotap.so (for arm32)
2) Ensure SoTap loads before other JNI libs. Inject a call early (e.g., Application subclass static initializer or onCreate) so the logger is initialized first. Smali snippet example:
```smali
const-string v0, "sotap"
invoke-static {v0}, Ljava/lang/System;->loadLibrary(Ljava/lang/String;)V
```
3) Rebuild/sign/install, run the app, then collect logs.

Log paths (checked in order):
```
/data/user/0/%s/files/sotap.log
/data/data/%s/files/sotap.log
/sdcard/Android/data/%s/files/sotap.log
/sdcard/Download/sotap-%s.log
# If all fail: fallback to Logcat only
```
Notlar ve sorun giderme:
- ABI hizalaması zorunludur. Uyumsuzluk UnsatisfiedLinkError üretecek ve logger yüklenmeyecektir.
- Depolama kısıtlamaları modern Android'te yaygındır; dosya yazma işlemleri başarısız olursa bile SoTap Logcat üzerinden çıktı vermeye devam edecektir.
- Davranış/ayrıntı seviyesi özelleştirilmek içindir; sotap.c dosyasını düzenledikten sonra kaynaktan yeniden derleyin.

Bu yaklaşım, işlem başlangıcından itibaren native çağrı akışlarını gözlemlemenin kritik olduğu fakat root/sistem-genel hookların mevcut olmadığı durumlarda malware triage ve JNI debugging için faydalıdır.

---

### Ayrıca bakınız: in‑memory native code execution via JNI

Yaygın bir saldırı modeli, çalışma zamanında ham bir shellcode blobunu indirip JNI köprüsü aracılığıyla doğrudan bellekten çalıştırmaktır (disk üzerinde ELF yok). Detaylar ve kullanıma hazır JNI snippet burada:

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

---

### APK'larda aranması gereken güncel zafiyetler

| Yıl | CVE | Etkilenen kütüphane | Notlar |
|------|-----|------------------|-------|
|2023|CVE-2023-4863|`libwebp` ≤ 1.3.1|WebP görüntülerini decode eden native koddan erişilebilen heap buffer overflow. Birçok Android uygulaması savunmasız sürümleri paketliyor. Bir APK içinde `libwebp.so` gördüğünüzde sürümünü kontrol edin ve istismar veya yamalama denemeleri yapın.| |
|2024|Multiple|OpenSSL 3.x series|Birçok memory-safety ve padding-oracle sorunu mevcut. Birçok Flutter & ReactNative paketi kendi `libcrypto.so`'larını taşır.| |

APK içinde *third-party* `.so` dosyaları gördüğünüzde, hashlerini upstream advisories ile karşılaştırın. SCA (Software Composition Analysis) mobilde nadirdir, bu yüzden eski ve savunmasız yapılar yaygındır.

---

### Anti-Reversing & Hardening trendleri (Android 13-15)

* **Pointer Authentication (PAC) & Branch Target Identification (BTI):** Android 14, desteklenen ARMv8.3+ çiplerde sistem kütüphanelerinde PAC/BTI'yi etkinleştirir. Decompiler'lar artık PAC ile ilişkili sahte talimatları gösteriyor; dinamik analiz için Frida PAC'i kaldırdıktan sonra trampolinler enjekte eder, ancak özel trampolinleriniz gerektiğinde `pacda`/`autibsp` çağırmalıdır.
* **MTE & Scudo hardened allocator:** memory-tagging isteğe bağlıdır ancak birçok Play-Integrity farkındalıklı uygulama `-fsanitize=memtag` ile derlenir; tag hatalarını yakalamak için `setprop arm64.memtag.dump 1` ve `adb shell am start ...` kullanın.
* **LLVM Obfuscator (opaque predicates, control-flow flattening):** ticari packer'lar (ör. Bangcle, SecNeo) giderek *native* kodu da koruyor, sadece Java'yı değil; `.rodata` içinde sahte kontrol-akışları ve şifrelenmiş string blobları bekleyin.

---

### Kaynaklar

- **Learning ARM Assembly:** [Azeria Labs – ARM Assembly Basics](https://azeria-labs.com/writing-arm-assembly-part-1/)
- **JNI & NDK Documentation:** [Oracle JNI Spec](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html) · [Android JNI Tips](https://developer.android.com/training/articles/perf-jni) · [NDK Guides](https://developer.android.com/ndk/guides/)
- **Debugging Native Libraries:** [Debug Android Native Libraries Using JEB Decompiler](https://medium.com/@shubhamsonani/how-to-debug-android-native-libraries-using-jeb-decompiler-eec681a22cf3)

### Referanslar

- Frida 16.x değişiklik günlüğü (Android hooking, tiny-function relocation) – [frida.re/news](https://frida.re/news/)
- NVD danışmanlığı: `libwebp` overflow CVE-2023-4863 – [nvd.nist.gov](https://nvd.nist.gov/vuln/detail/CVE-2023-4863)
- SoTap: Hafif uygulama içi JNI (.so) davranış logger'ı – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- SoTap Sürümleri – [github.com/RezaArbabBot/SoTap/releases](https://github.com/RezaArbabBot/SoTap/releases)
- SoTap ile nasıl çalışılır? – [t.me/ForYouTillEnd/13](https://t.me/ForYouTillEnd/13)
- [CoRPhone — JNI memory-only execution pattern and packaging](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
