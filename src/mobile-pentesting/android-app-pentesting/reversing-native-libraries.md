# ネイティブライブラリのリバースエンジニアリング

{{#include ../../banners/hacktricks-training.md}}

**詳細情報は次を確認してください:** [**https://maddiestone.github.io/AndroidAppRE/reversing_native_libs.html**](https://maddiestone.github.io/AndroidAppRE/reversing_native_libs.html)

Androidアプリは、パフォーマンスが重要なタスクのために通常CまたはC++で書かれたネイティブライブラリを使用します。マルウェア作成者もこれらのライブラリを使用します。なぜなら、DEXバイトコードよりもリバースエンジニアリングが難しいからです。このセクションは、アセンブリ言語を教えるのではなく、Androidに特化したリバースエンジニアリングスキルを強調しています。互換性のためにARMおよびx86バージョンのライブラリが提供されています。

### 重要なポイント:

- **Androidアプリのネイティブライブラリ:**
- パフォーマンス集約型タスクに使用されます。
- CまたはC++で書かれており、リバースエンジニアリングが難しいです。
- Linuxバイナリに似た`.so`（共有オブジェクト）形式で見つかります。
- マルウェア作成者は分析を難しくするためにネイティブコードを好みます。
- **Javaネイティブインターフェース（JNI）とAndroid NDK:**
- JNIはJavaメソッドをネイティブコードで実装することを可能にします。
- NDKはネイティブコードを書くためのAndroid特有のツールセットです。
- JNIとNDKはJava（またはKotlin）コードとネイティブライブラリを橋渡しします。
- **ライブラリの読み込みと実行:**
- ライブラリは`System.loadLibrary`または`System.load`を使用してメモリに読み込まれます。
- JNI_OnLoadはライブラリの読み込み時に実行されます。
- Javaで宣言されたネイティブメソッドはネイティブ関数にリンクし、実行を可能にします。
- **Javaメソッドとネイティブ関数のリンク:**
- **動的リンク:** ネイティブライブラリ内の関数名は特定のパターンに一致し、自動リンクを可能にします。
- **静的リンク:** `RegisterNatives`を使用してリンクし、関数名や構造に柔軟性を提供します。
- **リバースエンジニアリングツールと技術:**
- GhidraやIDA Proなどのツールはネイティブライブラリの分析に役立ちます。
- `JNIEnv`はJNI関数と相互作用を理解するために重要です。
- ライブラリの読み込み、メソッドのリンク、ネイティブ関数の特定を練習するための演習が提供されています。

### リソース:

- **ARMアセンブリの学習:**
- 基本的なアーキテクチャの理解を深めるために推奨されます。
- Azeria Labsの[ARM Assembly Basics](https://azeria-labs.com/writing-arm-assembly-part-1/)が推奨されています。
- **JNIとNDKのドキュメント:**
- [OracleのJNI仕様](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html)
- [AndroidのJNIヒント](https://developer.android.com/training/articles/perf-jni)
- [NDKの始め方](https://developer.android.com/ndk/guides/)
- **ネイティブライブラリのデバッグ:**
- [JEBデコンパイラを使用してAndroidネイティブライブラリをデバッグする](https://medium.com/@shubhamsonani/how-to-debug-android-native-libraries-using-jeb-decompiler-eec681a22cf3)

{{#include ../../banners/hacktricks-training.md}}
