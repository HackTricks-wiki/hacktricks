# Reverse Engineering nativer Bibliotheken

{{#include ../../banners/hacktricks-training.md}}


**Für weitere Informationen siehe:** [**https://maddiestone.github.io/AndroidAppRE/reversing_native_libs.html**](https://maddiestone.github.io/AndroidAppRE/reversing_native_libs.html)

Android-Apps können native Bibliotheken verwenden, typischerweise in C oder C++, für performance-kritische Aufgaben. Malware-Autoren missbrauchen diese Bibliotheken ebenfalls, weil ELF shared objects nach wie vor schwerer zu dekompilieren sind als DEX/OAT-Bytecode.
Diese Seite konzentriert sich auf *praktische* Workflows und *aktuelle* Tool-Verbesserungen (2023-2025), die das Reversing von Android `.so`-Dateien erleichtern.

---

### Schneller Triage-Workflow für eine frisch gezogene `libfoo.so`

1. **Bibliothek extrahieren**
```bash
# From an installed application
adb shell "run-as <pkg> cat lib/arm64-v8a/libfoo.so" > libfoo.so
# Or from the APK (zip)
unzip -j target.apk "lib/*/libfoo.so" -d extracted_libs/
```
2. **Architektur & Schutzmechanismen identifizieren**
```bash
file libfoo.so        # arm64 or arm32 / x86
readelf -h libfoo.so  # OS ABI, PIE, NX, RELRO, etc.
checksec --file libfoo.so  # (peda/pwntools)
```
3. **Exportierte Symbole & JNI-Bindings auflisten**
```bash
readelf -s libfoo.so | grep ' Java_'     # dynamic-linked JNI
strings libfoo.so   | grep -i "RegisterNatives" -n   # static-registered JNI
```
4. **In einen Decompiler laden** (Ghidra ≥ 11.0, IDA Pro, Binary Ninja, Hopper or Cutter/Rizin) und Auto-Analyse ausführen.
Neuere Ghidra-Versionen haben einen AArch64-Decompiler eingeführt, der PAC/BTI-Stubs und MTE-Tags erkennt und die Analyse von Bibliotheken, die mit dem Android 14 NDK gebaut wurden, deutlich verbessert.
5. **Abwägen: static vs dynamic reversing:** stripped, obfuscated code benötigt oft *instrumentation* (Frida, ptrace/gdbserver, LLDB).

---

### Dynamische Instrumentation (Frida ≥ 16)

Frida’s 16-Serie brachte mehrere Android-spezifische Verbesserungen, die helfen, wenn das Ziel moderne Clang/LLD-Optimierungen verwendet:

* `thumb-relocator` kann jetzt *tiny ARM/Thumb functions* hooken, die von LLDs aggressiver Alignment-Strategie (`--icf=all`) erzeugt werden.
* Enumerating and rebinding *ELF import slots* funktioniert auf Android, wodurch pro Modul `dlopen()`/`dlsym()`-Patching möglich ist, wenn inline hooks abgelehnt werden.
* Java hooking wurde für den neuen **ART quick-entrypoint** behoben, der verwendet wird, wenn Apps mit `--enable-optimizations` auf Android 14 kompiliert werden.

Beispiel: Alle durch `RegisterNatives` registrierten Funktionen aufzählen und deren Adressen zur Laufzeit ausgeben:
```javascript
Java.perform(function () {
var Runtime = Java.use('java.lang.Runtime');
var register = Module.findExportByName(null, 'RegisterNatives');
Interceptor.attach(register, {
onEnter(args) {
var envPtr  = args[0];
var clazz   = Java.cast(args[1], Java.use('java.lang.Class'));
var methods = args[2];
var count   = args[3].toInt32();
console.log('[+] RegisterNatives on ' + clazz.getName() + ' -> ' + count + ' methods');
// iterate & dump (JNI nativeMethod struct: name, sig, fnPtr)
}
});
});
```
Frida funktioniert sofort auf PAC/BTI-aktivierten Geräten (Pixel 8/Android 14+), solange du frida-server 16.2 oder neuer verwendest – ältere Versionen konnten das padding für inline hooks nicht finden.

### Prozesslokale JNI-Telemetrie durch vorgeladenes .so (SoTap)

Wenn vollwertige Instrumentation übertrieben oder blockiert ist, kannst du trotzdem native Sichtbarkeit gewinnen, indem du einen kleinen Logger im Zielprozess vorgeladst. SoTap ist eine leichte Android-native (.so) Bibliothek, die das Laufzeitverhalten anderer JNI (.so) Libraries innerhalb desselben App-Prozesses protokolliert (kein Root erforderlich).

Wesentliche Eigenschaften:
- Initialisiert früh und beobachtet JNI/native Interaktionen innerhalb des Prozesses, der es lädt.
- Speichert Logs über mehrere beschreibbare Pfade mit einem sanften Fallback zu Logcat, wenn Speicher eingeschränkt ist.
- Quellcode-anpassbar: editier sotap.c, um zu erweitern/anzupassen, was geloggt wird, und rebuild pro ABI.

Setup (APK neu packen):
1) Lege den richtigen ABI-Build in das APK, damit der Loader libsotap.so auflösen kann:
- lib/arm64-v8a/libsotap.so (für arm64)
- lib/armeabi-v7a/libsotap.so (für arm32)
2) Stelle sicher, dass SoTap vor anderen JNI-Libs geladen wird. Injiziere einen frühen Aufruf (z. B. Application subclass static initializer oder onCreate), damit der Logger zuerst initialisiert wird. Smali-Snippet Beispiel:
```smali
const-string v0, "sotap"
invoke-static {v0}, Ljava/lang/System;->loadLibrary(Ljava/lang/String;)V
```
3) Rebuild/sign/install, starte die App und sammle dann die Logs.

Log-Pfade (der Reihe nach geprüft):
```
/data/user/0/%s/files/sotap.log
/data/data/%s/files/sotap.log
/sdcard/Android/data/%s/files/sotap.log
/sdcard/Download/sotap-%s.log
# If all fail: fallback to Logcat only
```
Hinweise und Fehlerbehebung:
- ABI-Ausrichtung ist obligatorisch. Eine Nichtübereinstimmung löst UnsatisfiedLinkError aus und der Logger wird nicht geladen.
- Speicherbeschränkungen sind bei modernen Android-Geräten üblich; falls Dateischreibvorgänge fehlschlagen, gibt SoTap weiterhin Ausgaben über Logcat aus.
- Das Verhalten/der Detailgrad ist zur Anpassung gedacht; nach dem Bearbeiten von sotap.c aus dem Quellcode neu bauen.

Dieser Ansatz ist nützlich für Malware-Triage und JNI-Debugging, wenn das Beobachten nativer Aufrufflüsse vom Prozessstart an kritisch ist, aber systemweite Hooks oder Root nicht verfügbar sind.

---

### Kürzlich veröffentlichte Verwundbarkeiten, nach denen es sich in APKs zu suchen lohnt

| Year | CVE | Affected library | Notes |
|------|-----|------------------|-------|
|2023|CVE-2023-4863|`libwebp` ≤ 1.3.1|Heap buffer overflow reachable from native code that decodes WebP images. Several Android apps bundle vulnerable versions. When you see a `libwebp.so` inside an APK, check its version and attempt exploitation or patching.| |
|2024|Multiple|OpenSSL 3.x series|Several memory-safety and padding-oracle issues. Many Flutter & ReactNative bundles ship their own `libcrypto.so`.|

Wenn Sie *third-party* `.so`-Dateien in einem APK entdecken, gleichen Sie deren Hash immer mit den Upstream-Advisories ab. SCA (Software Composition Analysis) ist auf Mobilgeräten unüblich, daher sind veraltete verwundbare Builds weit verbreitet.

---

### Anti-Reversing & Härtungstrends (Android 13-15)

* **Pointer Authentication (PAC) & Branch Target Identification (BTI):** Android 14 aktiviert PAC/BTI in Systembibliotheken auf unterstützter ARMv8.3+ Hardware. Decompiler zeigen jetzt PAC‐bezogene Pseudo-Instruktionen; für dynamische Analyse injiziert Frida Trampolines *nach dem Entfernen von PAC*, aber Ihre eigenen Trampolines sollten, wo nötig, `pacda`/`autibsp` aufrufen.
* **MTE & Scudo hardened allocator:** Memory-Tagging ist optional (opt-in), aber viele Play-Integrity-bewusste Apps werden mit `-fsanitize=memtag` gebaut; verwenden Sie `setprop arm64.memtag.dump 1` plus `adb shell am start ...`, um Tag-Fehler zu erfassen.
* **LLVM Obfuscator (opaque predicates, control-flow flattening):** kommerzielle Packer (z. B. Bangcle, SecNeo) schützen zunehmend *native* Code, nicht nur Java; erwarten Sie falsche Kontrollflüsse und verschlüsselte String-Blobs in `.rodata`.

---

### Ressourcen

- **ARM Assembly lernen:** [Azeria Labs – ARM Assembly Basics](https://azeria-labs.com/writing-arm-assembly-part-1/)
- **JNI- & NDK-Dokumentation:** [Oracle JNI Spec](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html) · [Android JNI Tips](https://developer.android.com/training/articles/perf-jni) · [NDK Guides](https://developer.android.com/ndk/guides/)
- **Debugging nativer Bibliotheken:** [Debug Android Native Libraries Using JEB Decompiler](https://medium.com/@shubhamsonani/how-to-debug-android-native-libraries-using-jeb-decompiler-eec681a22cf3)

### Referenzen

- Frida 16.x change-log (Android hooking, tiny-function relocation) – [frida.re/news](https://frida.re/news/)
- NVD-Hinweis für den `libwebp`-Overflow CVE-2023-4863 – [nvd.nist.gov](https://nvd.nist.gov/vuln/detail/CVE-2023-4863)
- SoTap: Leichter In-App JNI (.so)-Verhaltenslogger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- SoTap Releases – [github.com/RezaArbabBot/SoTap/releases](https://github.com/RezaArbabBot/SoTap/releases)
- Wie man mit SoTap arbeitet? – [t.me/ForYouTillEnd/13](https://t.me/ForYouTillEnd/13)

{{#include ../../banners/hacktricks-training.md}}
