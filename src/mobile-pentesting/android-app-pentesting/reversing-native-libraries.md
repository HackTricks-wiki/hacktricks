# Rétro-ingénierie des bibliothèques natives

{{#include ../../banners/hacktricks-training.md}}


**Pour plus d'informations, consultez :** [**https://maddiestone.github.io/AndroidAppRE/reversing_native_libs.html**](https://maddiestone.github.io/AndroidAppRE/reversing_native_libs.html)

Les applications Android peuvent utiliser des bibliothèques natives, généralement écrites en C ou C++, pour des tâches critiques en performance. Les créateurs de malware abusent aussi de ces bibliothèques car les objets partagés ELF sont encore plus difficiles à décompiler que le byte-code DEX/OAT.  
Cette page se concentre sur des workflows *pratiques* et des améliorations récentes des outils (2023-2025) qui facilitent la reversing des fichiers `.so` Android.

---

### Flux de triage rapide pour un `libfoo.so` fraîchement extrait

1. **Extraire la bibliothèque**
```bash
# From an installed application
adb shell "run-as <pkg> cat lib/arm64-v8a/libfoo.so" > libfoo.so
# Or from the APK (zip)
unzip -j target.apk "lib/*/libfoo.so" -d extracted_libs/
```
2. **Identifier l'architecture et les protections**
```bash
file libfoo.so        # arm64 or arm32 / x86
readelf -h libfoo.so  # OS ABI, PIE, NX, RELRO, etc.
checksec --file libfoo.so  # (peda/pwntools)
```
3. **Lister les symboles exportés et les bindings JNI**
```bash
readelf -s libfoo.so | grep ' Java_'     # dynamic-linked JNI
strings libfoo.so   | grep -i "RegisterNatives" -n   # static-registered JNI
```
4. **Charger dans un décompilateur** (Ghidra ≥ 11.0, IDA Pro, Binary Ninja, Hopper or Cutter/Rizin) et lancer l'analyse automatique.  
Les versions récentes de Ghidra ont introduit un décompilateur AArch64 qui reconnaît les stubs PAC/BTI et les tags MTE, améliorant grandement l'analyse des bibliothèques construites avec l'Android 14 NDK.
5. **Choisir entre reverse statique et dynamique :** du code stripped/obfusqué nécessite souvent de l'*instrumentation* (Frida, ptrace/gdbserver, LLDB).

---

### Instrumentation dynamique (Frida ≥ 16)

La série 16 de Frida a apporté plusieurs améliorations spécifiques à Android qui aident lorsque la cible utilise les optimisations modernes de Clang/LLD :

* `thumb-relocator` peut désormais *hook tiny ARM/Thumb functions* générées par l'alignement agressif de LLD (`--icf=all`).
* L'énumération et le rebinding des *ELF import slots* fonctionnent sur Android, permettant le patch par module via `dlopen()`/`dlsym()` lorsque les inline hooks sont rejetés.
* Le Java hooking a été corrigé pour le nouveau **ART quick-entrypoint** utilisé lorsque les apps sont compilées avec `--enable-optimizations` sur Android 14.

Exemple : énumérer toutes les fonctions enregistrées via `RegisterNatives` et dumper leurs adresses à l'exécution :
```javascript
Java.perform(function () {
var Runtime = Java.use('java.lang.Runtime');
var register = Module.findExportByName(null, 'RegisterNatives');
Interceptor.attach(register, {
onEnter(args) {
var envPtr  = args[0];
var clazz   = Java.cast(args[1], Java.use('java.lang.Class'));
var methods = args[2];
var count   = args[3].toInt32();
console.log('[+] RegisterNatives on ' + clazz.getName() + ' -> ' + count + ' methods');
// iterate & dump (JNI nativeMethod struct: name, sig, fnPtr)
}
});
});
```
Frida will work out of the box on PAC/BTI-enabled devices (Pixel 8/Android 14+) as long as you use frida-server 16.2 or later – earlier versions failed to locate padding for inline hooks.

### Process-local JNI telemetry via preloaded .so (SoTap)

When full-featured instrumentation is overkill or blocked, you can still gain native-level visibility by preloading a small logger inside the target process. SoTap is a lightweight Android native (.so) library that logs the runtime behavior of other JNI (.so) libraries within the same app process (no root required).

Key properties:
- Initializes early and observes JNI/native interactions inside the process that loads it.
- Persists logs using multiple writable paths with graceful fallback to Logcat when storage is restricted.
- Source-customizable: edit sotap.c to extend/adjust what gets logged and rebuild per ABI.

Setup (repaquetage de l'APK):
1) Déposez le build ABI approprié dans l'APK afin que le loader puisse résoudre libsotap.so :
- lib/arm64-v8a/libsotap.so (for arm64)
- lib/armeabi-v7a/libsotap.so (for arm32)
2) Assurez-vous que SoTap se charge avant les autres libs JNI. Injectez un appel tôt (par ex., static initializer de la sous-classe Application ou onCreate) afin que le logger soit initialisé en premier. Exemple de snippet Smali :
```smali
const-string v0, "sotap"
invoke-static {v0}, Ljava/lang/System;->loadLibrary(Ljava/lang/String;)V
```
3) Rebuild/sign/install, lancez l'app, puis collectez les logs.

Log paths (checked in order):
```
/data/user/0/%s/files/sotap.log
/data/data/%s/files/sotap.log
/sdcard/Android/data/%s/files/sotap.log
/sdcard/Download/sotap-%s.log
# If all fail: fallback to Logcat only
```
Notes et dépannage:
- L'alignement de l'ABI est obligatoire. Un désalignement déclenchera UnsatisfiedLinkError et le logger ne se chargera pas.
- Les contraintes de stockage sont courantes sur les Android modernes ; si les écritures de fichiers échouent, SoTap émettra toujours via Logcat.
- Le comportement/la verbosité est conçu·e pour être personnalisé·e ; recompilez depuis la source après avoir édité sotap.c.

Cette approche est utile pour le triage de malware et le debugging JNI lorsque l'observation des flux d'appels natifs depuis le démarrage du processus est critique mais que des hooks root/système globaux ne sont pas disponibles.

---

### Recent vulnerabilities worth hunting for in APKs

| Année | CVE | Bibliothèque affectée | Remarques |
|------|-----|------------------|-------|
|2023|CVE-2023-4863|`libwebp` ≤ 1.3.1|Heap buffer overflow reachable from native code that decodes WebP images. Plusieurs applications Android embarquent des versions vulnérables. Lorsque vous voyez un `libwebp.so` dans un APK, vérifiez sa version et tentez une exploitation ou un correctif.| |
|2024|Multiple|OpenSSL 3.x series|Several memory-safety and padding-oracle issues. Many Flutter & ReactNative bundles ship their own `libcrypto.so`.|

Lorsque vous repérez des fichiers `.so` *third-party* à l'intérieur d'un APK, vérifiez toujours leur hash par rapport aux avis upstream. SCA (Software Composition Analysis) est peu courant sur mobile, donc des builds vulnérables et obsolètes sont répandus.

---

### Anti-Reversing & Hardening trends (Android 13-15)

* **Pointer Authentication (PAC) & Branch Target Identification (BTI):** Android 14 active PAC/BTI dans les bibliothèques système sur les puces ARMv8.3+ compatibles. Les décompilateurs affichent maintenant des pseudo-instructions liées à PAC ; pour l'analyse dynamique Frida injecte des trampolines *après* avoir enlevé PAC, mais vos trampolines personnalisés devraient appeler `pacda`/`autibsp` lorsque nécessaire.
* **MTE & Scudo hardened allocator:** le memory-tagging est opt-in mais beaucoup d'apps compatibles Play-Integrity sont compilées avec `-fsanitize=memtag` ; utilisez `setprop arm64.memtag.dump 1` plus `adb shell am start ...` pour capturer les tag faults.
* **LLVM Obfuscator (opaque predicates, control-flow flattening):** des packers commerciaux (e.g., Bangcle, SecNeo) protègent de plus en plus le code *native*, pas seulement Java ; attendez-vous à du control-flow bidon et des blobs de chaînes chiffrés dans `.rodata`.

---

### Resources

- **Learning ARM Assembly:** [Azeria Labs – ARM Assembly Basics](https://azeria-labs.com/writing-arm-assembly-part-1/)
- **JNI & NDK Documentation:** [Oracle JNI Spec](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html) · [Android JNI Tips](https://developer.android.com/training/articles/perf-jni) · [NDK Guides](https://developer.android.com/ndk/guides/)
- **Debugging Native Libraries:** [Debug Android Native Libraries Using JEB Decompiler](https://medium.com/@shubhamsonani/how-to-debug-android-native-libraries-using-jeb-decompiler-eec681a22cf3)

### References

- Frida 16.x change-log (Android hooking, tiny-function relocation) – [frida.re/news](https://frida.re/news/)
- NVD advisory for `libwebp` overflow CVE-2023-4863 – [nvd.nist.gov](https://nvd.nist.gov/vuln/detail/CVE-2023-4863)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- SoTap Releases – [github.com/RezaArbabBot/SoTap/releases](https://github.com/RezaArbabBot/SoTap/releases)
- How to work with SoTap? – [t.me/ForYouTillEnd/13](https://t.me/ForYouTillEnd/13)

{{#include ../../banners/hacktricks-training.md}}
