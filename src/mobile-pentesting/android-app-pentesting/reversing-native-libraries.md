# Reversing Native Libraries

{{#include ../../banners/hacktricks-training.md}}


**For further information check:** [**https://maddiestone.github.io/AndroidAppRE/reversing_native_libs.html**](https://maddiestone.github.io/AndroidAppRE/reversing_native_libs.html)

Android 앱은 일반적으로 성능이 중요한 작업을 위해 C 또는 C++로 작성된 native libraries를 사용할 수 있습니다. Malware 제작자들도 이러한 라이브러리를 악용하는데, ELF shared objects는 여전히 DEX/OAT byte-code보다 디컴파일하기 더 어렵기 때문입니다.
이 페이지는 Android `.so` 파일을 역분석하기 쉽게 해주는 *실용적인* 워크플로우와 *최근* 툴링 개선사항(2023-2025)에 초점을 맞춥니다.

---

### Quick triage-workflow for a freshly pulled `libfoo.so`

1. **라이브러리 추출**
```bash
# From an installed application
adb shell "run-as <pkg> cat lib/arm64-v8a/libfoo.so" > libfoo.so
# Or from the APK (zip)
unzip -j target.apk "lib/*/libfoo.so" -d extracted_libs/
```
2. **아키텍처 및 보호 확인**
```bash
file libfoo.so        # arm64 or arm32 / x86
readelf -h libfoo.so  # OS ABI, PIE, NX, RELRO, etc.
checksec --file libfoo.so  # (peda/pwntools)
```
3. **내보낸 심볼 및 JNI 바인딩 나열**
```bash
readelf -s libfoo.so | grep ' Java_'     # dynamic-linked JNI
strings libfoo.so   | grep -i "RegisterNatives" -n   # static-registered JNI
```
4. **Decompiler에 로드** (Ghidra ≥ 11.0, IDA Pro, Binary Ninja, Hopper or Cutter/Rizin) 및 자동 분석 실행.
Newer Ghidra versions introduced an AArch64 decompiler that recognises PAC/BTI stubs and MTE tags, greatly improving analysis of libraries built with the Android 14 NDK.
5. **정적 vs 동적 역분석 결정:** stripped, obfuscated 코드의 경우 종종 *instrumentation*이 필요합니다 (Frida, ptrace/gdbserver, LLDB).

---

### Dynamic Instrumentation (Frida ≥ 16)

Frida’s 16-series brought several Android-specific improvements that help when the target uses modern Clang/LLD optimisations:

* `thumb-relocator`는 이제 LLD의 공격적 정렬(`--icf=all`)로 생성된 *작은 ARM/Thumb 함수에 hook*할 수 있습니다.
* Enumerating and rebinding *ELF import slots*는 Android에서 동작하며, inline hooks가 거부될 때 모듈별로 `dlopen()`/`dlsym()` 패치가 가능하게 합니다.
* Java hooking은 Android 14에서 `--enable-optimizations`로 컴파일된 앱이 사용하는 새로운 **ART quick-entrypoint**에 대해 수정되었습니다.

Example: enumerating all functions registered through `RegisterNatives` and dumping their addresses at runtime:
```javascript
Java.perform(function () {
var Runtime = Java.use('java.lang.Runtime');
var register = Module.findExportByName(null, 'RegisterNatives');
Interceptor.attach(register, {
onEnter(args) {
var envPtr  = args[0];
var clazz   = Java.cast(args[1], Java.use('java.lang.Class'));
var methods = args[2];
var count   = args[3].toInt32();
console.log('[+] RegisterNatives on ' + clazz.getName() + ' -> ' + count + ' methods');
// iterate & dump (JNI nativeMethod struct: name, sig, fnPtr)
}
});
});
```
Frida will work out of the box on PAC/BTI-enabled devices (Pixel 8/Android 14+) as long as you use frida-server 16.2 or later – earlier versions failed to locate padding for inline hooks.

### preloaded .so를 통한 프로세스 로컬 JNI 텔레메트리 (SoTap)

완전한 기능의 instrumentation이 과잉이거나 차단된 경우, 대상 프로세스 내부에 작은 로거를 preload하여 네이티브 수준의 가시성을 확보할 수 있습니다. SoTap은 동일 앱 프로세스 내의 다른 JNI (.so) 라이브러리들의 런타임 동작을 로깅하는 경량 Android native (.so) 라이브러리입니다(루트 권한 불필요).

Key properties:
- 일찍 초기화되어 이를 로드하는 프로세스 내부의 JNI/native 상호작용을 관찰합니다.
- 쓰기 가능한 여러 경로에 로그를 지속하며, 저장소가 제한될 경우 Logcat으로 우아하게 폴백합니다.
- 소스 커스터마이징 가능: sotap.c를 편집해 기록할 내용을 확장/조정한 뒤 ABI별로 다시 빌드하세요.

Setup (repack the APK):
1) Drop the proper ABI build into the APK so the loader can resolve libsotap.so:
- lib/arm64-v8a/libsotap.so (for arm64)
- lib/armeabi-v7a/libsotap.so (for arm32)
2) Ensure SoTap loads before other JNI libs. Inject a call early (e.g., Application subclass static initializer or onCreate) so the logger is initialized first. Smali snippet example:
```smali
const-string v0, "sotap"
invoke-static {v0}, Ljava/lang/System;->loadLibrary(Ljava/lang/String;)V
```
3) Rebuild/sign/install, run the app, then collect logs.

Log paths (checked in order):
```
/data/user/0/%s/files/sotap.log
/data/data/%s/files/sotap.log
/sdcard/Android/data/%s/files/sotap.log
/sdcard/Download/sotap-%s.log
# If all fail: fallback to Logcat only
```
Notes and troubleshooting:
- ABI 정렬은 필수입니다. 불일치하면 UnsatisfiedLinkError가 발생하고 logger가 로드되지 않습니다.
- 현대 Android에서는 저장소 제약이 흔합니다; 파일 쓰기가 실패하면 SoTap은 여전히 Logcat을 통해 출력합니다.
- 동작/출력 레벨은 사용자화하도록 설계되었습니다; sotap.c를 수정한 뒤 소스에서 재빌드하세요.

이 접근법은 프로세스 시작 시점부터 네이티브 호출 흐름을 관찰해야 하는 malware triage와 JNI 디버깅에 유용합니다. 다만 root/시스템 전체 훅을 사용할 수 없는 경우에 해당합니다.

---

### Recent vulnerabilities worth hunting for in APKs

| 연도 | CVE | 영향받는 라이브러리 | 설명 |
|------|-----|------------------|-------|
|2023|CVE-2023-4863|`libwebp` ≤ 1.3.1|네이티브 코드에서 WebP 이미지를 디코딩할 때 도달 가능한 힙 버퍼 오버플로우. 여러 Android 앱이 취약한 버전을 번들링하고 있습니다. APK 안에서 `libwebp.so`를 발견하면 버전을 확인하고 익스플로잇 또는 패치 시도를 하세요.| |
|2024|Multiple|OpenSSL 3.x series|여러 메모리 안전성 및 padding-oracle 문제. 많은 Flutter & ReactNative 번들들이 자체 `libcrypto.so`를 포함합니다.|

APK 내부에서 *third-party* `.so` 파일을 발견하면 항상 해당 해시를 upstream 권고사항과 대조하세요. 모바일에서는 SCA (Software Composition Analysis)가 드물기 때문에 구버전의 취약한 빌드가 널리 퍼져 있습니다.

---

### Anti-Reversing & Hardening trends (Android 13-15)

* **Pointer Authentication (PAC) & Branch Target Identification (BTI):** Android 14은 지원되는 ARMv8.3+ 실리콘에서 시스템 라이브러리에 PAC/BTI를 활성화합니다. 디컴파일러는 이제 PAC 관련 의사명령을 표시하고; 동적 분석에서는 Frida가 PAC를 제거한 뒤 트램폴린을 주입하지만, 사용자 지정 트램폴린은 필요한 경우 pacda/autibsp를 호출해야 합니다.
* **MTE & Scudo hardened allocator:** memory-tagging은 옵트인입니다만 많은 Play-Integrity 인식 앱이 `-fsanitize=memtag`로 빌드합니다; 태그 폴트를 캡처하려면 `setprop arm64.memtag.dump 1`과 `adb shell am start ...`를 사용하세요.
* **LLVM Obfuscator (opaque predicates, control-flow flattening):** 상용 packer들(예: Bangcle, SecNeo)은 점점 *native* 코드를 보호합니다(Java만이 아님); `.rodata`에 잘못된 제어 흐름과 암호화된 문자열 블랍이 있을 것으로 예상하세요.

---

### Resources

- **Learning ARM Assembly:** [Azeria Labs – ARM Assembly Basics](https://azeria-labs.com/writing-arm-assembly-part-1/)
- **JNI & NDK Documentation:** [Oracle JNI Spec](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html) · [Android JNI Tips](https://developer.android.com/training/articles/perf-jni) · [NDK Guides](https://developer.android.com/ndk/guides/)
- **Debugging Native Libraries:** [Debug Android Native Libraries Using JEB Decompiler](https://medium.com/@shubhamsonani/how-to-debug-android-native-libraries-using-jeb-decompiler-eec681a22cf3)

### References

- Frida 16.x change-log (Android hooking, tiny-function relocation) – [frida.re/news](https://frida.re/news/)
- NVD advisory for `libwebp` overflow CVE-2023-4863 – [nvd.nist.gov](https://nvd.nist.gov/vuln/detail/CVE-2023-4863)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- SoTap Releases – [github.com/RezaArbabBot/SoTap/releases](https://github.com/RezaArbabBot/SoTap/releases)
- How to work with SoTap? – [t.me/ForYouTillEnd/13](https://t.me/ForYouTillEnd/13)

{{#include ../../banners/hacktricks-training.md}}
