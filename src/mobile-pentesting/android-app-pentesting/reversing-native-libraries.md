# Reversing Native Libraries

{{#include ../../banners/hacktricks-training.md}}


**Per ulteriori informazioni consulta:** [**https://maddiestone.github.io/AndroidAppRE/reversing_native_libs.html**](https://maddiestone.github.io/AndroidAppRE/reversing_native_libs.html)

Le app Android possono usare librerie native, tipicamente scritte in C o C++, per compiti critici in termini di performance. Anche gli autori di malware abusano di queste librerie perché gli ELF shared objects sono ancora più difficili da decompilare rispetto al byte-code DEX/OAT.
Questa pagina si concentra su workflow *pratici* e su miglioramenti degli strumenti *recenti* (2023-2025) che rendono più facile il reversing di file `.so` Android.

---

### Quick triage-workflow for a freshly pulled `libfoo.so`

1. **Extract the library**
```bash
# From an installed application
adb shell "run-as <pkg> cat lib/arm64-v8a/libfoo.so" > libfoo.so
# Or from the APK (zip)
unzip -j target.apk "lib/*/libfoo.so" -d extracted_libs/
```
2. **Identify architecture & protections**
```bash
file libfoo.so        # arm64 or arm32 / x86
readelf -h libfoo.so  # OS ABI, PIE, NX, RELRO, etc.
checksec --file libfoo.so  # (peda/pwntools)
```
3. **List exported symbols & JNI bindings**
```bash
readelf -s libfoo.so | grep ' Java_'     # dynamic-linked JNI
strings libfoo.so   | grep -i "RegisterNatives" -n   # static-registered JNI
```
4. **Load in a decompiler** (Ghidra ≥ 11.0, IDA Pro, Binary Ninja, Hopper or Cutter/Rizin) and run auto-analysis.
Le versioni più recenti di Ghidra hanno introdotto un decompiler AArch64 che riconosce i PAC/BTI stubs e i tag MTE, migliorando notevolmente l'analisi delle librerie buildate con l'NDK di Android 14.
5. **Decide on static vs dynamic reversing:** il codice stripped o offuscato spesso richiede *strumentazione* (Frida, ptrace/gdbserver, LLDB).

---

### Dynamic Instrumentation (Frida ≥ 16)

La serie 16 di Frida ha introdotto diversi miglioramenti specifici per Android che aiutano quando il target usa ottimizzazioni moderne di Clang/LLD:

* `thumb-relocator` può ora *hookare funzioni ARM/Thumb piccole* generate dall'aggressivo allineamento di LLD (`--icf=all`).
* L'enumerazione e il rebinding degli *ELF import slots* funziona su Android, permettendo il patch per-modulo con `dlopen()`/`dlsym()` quando gli inline hooks vengono rifiutati.
* Java hooking è stato sistemato per il nuovo **ART quick-entrypoint** usato quando le app sono compilate con `--enable-optimizations` su Android 14.

Esempio: enumerare tutte le funzioni registrate tramite `RegisterNatives` e dumpare i loro indirizzi a runtime:
```javascript
Java.perform(function () {
var Runtime = Java.use('java.lang.Runtime');
var register = Module.findExportByName(null, 'RegisterNatives');
Interceptor.attach(register, {
onEnter(args) {
var envPtr  = args[0];
var clazz   = Java.cast(args[1], Java.use('java.lang.Class'));
var methods = args[2];
var count   = args[3].toInt32();
console.log('[+] RegisterNatives on ' + clazz.getName() + ' -> ' + count + ' methods');
// iterate & dump (JNI nativeMethod struct: name, sig, fnPtr)
}
});
});
```
Frida funzionerà immediatamente sui dispositivi abilitati PAC/BTI (Pixel 8/Android 14+) purché si usi frida-server 16.2 o superiore – le versioni precedenti non riuscivano a individuare il padding per gli inline hooks.

### Telemetria JNI locale al processo tramite .so precaricato (SoTap)

Quando un'instrumentazione completa è eccessiva o bloccata, è comunque possibile ottenere visibilità a livello nativo pre-caricando un piccolo logger all'interno del processo target. SoTap è una libreria nativa Android (.so) leggera che registra il comportamento a runtime di altre librerie JNI (.so) all'interno dello stesso processo dell'app (non richiede root).

Caratteristiche principali:
- Si inizializza precocemente e osserva le interazioni JNI/native all'interno del processo che la carica.
- Conserva i log usando più percorsi scrivibili con fallback elegante a Logcat quando lo storage è limitato.
- Personalizzabile dal sorgente: modifica sotap.c per estendere/aggiustare ciò che viene loggato e ricompila per ABI.

Setup (ripacchetta l'APK):
1) Inserisci la build per l'ABI corretta nell'APK in modo che il loader possa risolvere libsotap.so:
- lib/arm64-v8a/libsotap.so (per arm64)
- lib/armeabi-v7a/libsotap.so (per arm32)
2) Assicurati che SoTap venga caricata prima delle altre librerie JNI. Inietta una chiamata in anticipo (es. nell'inizializzatore statico della sottoclasse Application o onCreate) in modo che il logger venga inizializzato prima. Esempio di snippet Smali:
```smali
const-string v0, "sotap"
invoke-static {v0}, Ljava/lang/System;->loadLibrary(Ljava/lang/String;)V
```
3) Ricostruisci/firma/installa, avvia l'app, poi raccogli i log.

Percorsi dei log (verificati nell'ordine):
```
/data/user/0/%s/files/sotap.log
/data/data/%s/files/sotap.log
/sdcard/Android/data/%s/files/sotap.log
/sdcard/Download/sotap-%s.log
# If all fail: fallback to Logcat only
```
Notes and troubleshooting:
- L'allineamento ABI è obbligatorio. Un mismatch provocherà UnsatisfiedLinkError e il logger non verrà caricato.
- Le limitazioni di storage sono comuni sui dispositivi Android moderni; se le scritture su file falliscono, SoTap continuerà comunque a emettere tramite Logcat.
- Comportamento/verbosità è pensato per essere personalizzato; ricompila dalla sorgente dopo aver modificato sotap.c.

This approach is useful for malware triage and JNI debugging where observing native call flows from process start is critical but root/system-wide hooks aren’t available.

---

### See also: in‑memory native code execution via JNI

A common attack pattern is to download a raw shellcode blob at runtime and execute it directly from memory through a JNI bridge (no on‑disk ELF). Details and ready‑to‑use JNI snippet here:

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

---

### Recent vulnerabilities worth hunting for in APKs

| Year | CVE | Affected library | Notes |
|------|-----|------------------|-------|
|2023|CVE-2023-4863|`libwebp` ≤ 1.3.1|Overflow del buffer heap raggiungibile dal codice nativo che decodifica immagini WebP. Diverse app Android includono versioni vulnerabili. Quando trovi un `libwebp.so` dentro un APK, controlla la sua versione e prova a sfruttarla o a patcharla.| |
|2024|Multiple|OpenSSL 3.x series|Diverse problematiche di sicurezza della memoria e padding-oracle. Molti bundle Flutter & ReactNative distribuiscono il proprio `libcrypto.so`.|

When you spot *third-party* `.so` files inside an APK, always cross-check their hash against upstream advisories. SCA (Software Composition Analysis) is uncommon on mobile, so outdated vulnerable builds are rampant.

---

### Anti-Reversing & Hardening trends (Android 13-15)

* **Pointer Authentication (PAC) & Branch Target Identification (BTI):** Android 14 abilita PAC/BTI nelle librerie di sistema su siliconi ARMv8.3+ supportati. I decompiler ora mostrano pseudo-istruzioni relative a PAC; per l'analisi dinamica Frida inietta trampolines *after* stripping PAC, ma i tuoi trampolines personalizzati dovrebbero chiamare `pacda`/`autibsp` quando necessario.
* **MTE & Scudo hardened allocator:** il memory-tagging è opzionale ma molte app consapevoli di Play-Integrity vengono compilate con `-fsanitize=memtag`; usa `setprop arm64.memtag.dump 1` più `adb shell am start ...` per catturare i tag faults.
* **LLVM Obfuscator (opaque predicates, control-flow flattening):** i packer commerciali (es. Bangcle, SecNeo) proteggono sempre più il codice *native*, non solo Java; aspettati controllo-flusso fasullo e encrypted string blobs in `.rodata`.

---

### Resources

- **Imparare ARM Assembly:** [Azeria Labs – ARM Assembly Basics](https://azeria-labs.com/writing-arm-assembly-part-1/)
- **Documentazione JNI & NDK:** [Oracle JNI Spec](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html) · [Android JNI Tips](https://developer.android.com/training/articles/perf-jni) · [NDK Guides](https://developer.android.com/ndk/guides/)
- **Debugging delle Native Libraries:** [Debug Android Native Libraries Using JEB Decompiler](https://medium.com/@shubhamsonani/how-to-debug-android-native-libraries-using-jeb-decompiler-eec681a22cf3)

### References

- Changelog di Frida 16.x (Android hooking, tiny-function relocation) – [frida.re/news](https://frida.re/news/)
- Avviso NVD per l'overflow di `libwebp` CVE-2023-4863 – [nvd.nist.gov](https://nvd.nist.gov/vuln/detail/CVE-2023-4863)
- SoTap: logger leggero per il comportamento JNI in-app (.so) – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- SoTap Releases – [github.com/RezaArbabBot/SoTap/releases](https://github.com/RezaArbabBot/SoTap/releases)
- Come lavorare con SoTap? – [t.me/ForYouTillEnd/13](https://t.me/ForYouTillEnd/13)
- [CoRPhone — JNI memory-only execution pattern and packaging](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
