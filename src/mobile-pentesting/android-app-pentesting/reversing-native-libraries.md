# Rétro‑ingénierie des bibliothèques natives

{{#include ../../banners/hacktricks-training.md}}


**Pour plus d'informations, consulter :** [**https://maddiestone.github.io/AndroidAppRE/reversing_native_libs.html**](https://maddiestone.github.io/AndroidAppRE/reversing_native_libs.html)

Les applications Android peuvent utiliser des bibliothèques natives, typiquement écrites en C ou C++, pour des tâches sensibles en performance. Les créateurs de malware en abusent aussi car les objets partagés ELF restent plus difficiles à décompiler que le byte‑code DEX/OAT.
Cette page se concentre sur des workflows *pratiques* et des améliorations d'outillage *récentes* (2023-2025) qui facilitent le reverse engineering des fichiers `.so` Android.

---

### Workflow de triage rapide pour un `libfoo.so` fraîchement extrait

1. **Extraire la bibliothèque**
```bash
# From an installed application
adb shell "run-as <pkg> cat lib/arm64-v8a/libfoo.so" > libfoo.so
# Or from the APK (zip)
unzip -j target.apk "lib/*/libfoo.so" -d extracted_libs/
```
2. **Identifier l'architecture et les protections**
```bash
file libfoo.so        # arm64 or arm32 / x86
readelf -h libfoo.so  # OS ABI, PIE, NX, RELRO, etc.
checksec --file libfoo.so  # (peda/pwntools)
```
3. **Lister les symboles exportés et les liaisons JNI**
```bash
readelf -s libfoo.so | grep ' Java_'     # dynamic-linked JNI
strings libfoo.so   | grep -i "RegisterNatives" -n   # static-registered JNI
```
4. **Charger dans un décompilateur** (Ghidra ≥ 11.0, IDA Pro, Binary Ninja, Hopper or Cutter/Rizin) et lancer l'auto‑analyse.
Les versions récentes de Ghidra intègrent un décompilateur AArch64 qui reconnaît les stubs PAC/BTI et les tags MTE, améliorant grandement l'analyse des bibliothèques construites avec l'Android 14 NDK.
5. **Décider entre rétro‑ingénierie statique et dynamique :** les binaires stripped et obfusqués nécessitent souvent de l'*instrumentation* (Frida, ptrace/gdbserver, LLDB).

---

### Instrumentation dynamique (Frida ≥ 16)

La série 16 de Frida a apporté plusieurs améliorations spécifiques à Android qui aident lorsque la cible utilise les optimisations modernes de Clang/LLD :

* `thumb-relocator` peut maintenant *hook* de très petites fonctions ARM/Thumb générées par l'alignement agressif de LLD (`--icf=all`).
* L'énumération et la réaffectation des *ELF import slots* fonctionne sur Android, permettant le patch par module via `dlopen()`/`dlsym()` lorsque les inline hooks sont rejetés.
* Le Java hooking a été corrigé pour le nouvel **ART quick-entrypoint** utilisé lorsque les apps sont compilées avec `--enable-optimizations` sur Android 14.

Exemple : énumérer toutes les fonctions enregistrées via `RegisterNatives` et dumper leurs adresses à l'exécution :
```javascript
Java.perform(function () {
var Runtime = Java.use('java.lang.Runtime');
var register = Module.findExportByName(null, 'RegisterNatives');
Interceptor.attach(register, {
onEnter(args) {
var envPtr  = args[0];
var clazz   = Java.cast(args[1], Java.use('java.lang.Class'));
var methods = args[2];
var count   = args[3].toInt32();
console.log('[+] RegisterNatives on ' + clazz.getName() + ' -> ' + count + ' methods');
// iterate & dump (JNI nativeMethod struct: name, sig, fnPtr)
}
});
});
```
Frida will work out of the box on PAC/BTI-enabled devices (Pixel 8/Android 14+) as long as you use frida-server 16.2 or later – earlier versions failed to locate padding for inline hooks.

### Process-local JNI telemetry via preloaded .so (SoTap)

Lorsque l'instrumentation complète est excessive ou bloquée, vous pouvez toujours obtenir une visibilité au niveau natif en préchargeant un petit logger dans le processus cible. SoTap est une bibliothèque native Android légère (.so) qui enregistre le comportement d'exécution d'autres bibliothèques JNI (.so) au sein du même processus d'application (no root required).

Key properties:
- S'initialise tôt et observe les interactions JNI/native à l'intérieur du processus qui le charge.
- Conserve les logs en utilisant plusieurs chemins inscriptibles avec un fallback gracieux vers Logcat lorsque le stockage est restreint.
- Personnalisable au niveau source : éditez sotap.c pour étendre/ajuster ce qui est enregistré et reconstruire par ABI.

Setup (repack the APK):
1) Drop the proper ABI build into the APK so the loader can resolve libsotap.so:
- lib/arm64-v8a/libsotap.so (for arm64)
- lib/armeabi-v7a/libsotap.so (for arm32)
2) Ensure SoTap loads before other JNI libs. Inject a call early (e.g., Application subclass static initializer or onCreate) so the logger is initialized first. Smali snippet example:
```smali
const-string v0, "sotap"
invoke-static {v0}, Ljava/lang/System;->loadLibrary(Ljava/lang/String;)V
```
3) Rebuild/sign/install, run the app, then collect logs.

Log paths (checked in order):
```
/data/user/0/%s/files/sotap.log
/data/data/%s/files/sotap.log
/sdcard/Android/data/%s/files/sotap.log
/sdcard/Download/sotap-%s.log
# If all fail: fallback to Logcat only
```
Notes et dépannage :
- L'alignement ABI est obligatoire. Une incompatibilité lèvera UnsatisfiedLinkError et le logger ne se chargera pas.
- Les contraintes de stockage sont courantes sur les versions récentes d'Android ; si les écritures de fichiers échouent, SoTap émettra quand même via Logcat.
- Le comportement / la verbosité est prévu pour être personnalisé ; recompilez depuis la source après modification de sotap.c.

Cette approche est utile pour le triage de malware et le debugging JNI où l'observation des flux d'appels natifs depuis le démarrage du processus est critique mais les hooks nécessitant root ou au niveau système ne sont pas disponibles.

---

### Voir aussi : exécution de code natif en mémoire via JNI

Un pattern d'attaque courant consiste à télécharger un blob de shellcode brut à l'exécution et à l'exécuter directement depuis la mémoire via un pont JNI (pas d'ELF sur disque). Détails et snippet JNI prêt à l'emploi ici :

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

---

### Vulnérabilités récentes à rechercher dans les APK

| Année | CVE | Bibliothèque affectée | Remarques |
|------|-----|------------------|-------|
|2023|CVE-2023-4863|`libwebp` ≤ 1.3.1|Heap buffer overflow reachable from native code that decodes WebP images. Several Android apps bundle vulnerable versions. When you see a `libwebp.so` inside an APK, check its version and attempt exploitation or patching.| |
|2024|Multiple|OpenSSL 3.x series|Several memory-safety and padding-oracle issues. Many Flutter & ReactNative bundles ship their own `libcrypto.so`.|

Quand vous repérez des fichiers `.so` *third-party* dans un APK, vérifiez toujours leur hash par rapport aux avis upstream. SCA (Software Composition Analysis) est peu répandue sur mobile, donc des builds vulnérables et obsolètes sont courants.

---

### Anti-Reversing & Hardening trends (Android 13-15)

* **Pointer Authentication (PAC) & Branch Target Identification (BTI) :** Android 14 active PAC/BTI dans les bibliothèques système sur silicium ARMv8.3+ pris en charge. Les décompilateurs affichent maintenant des pseudo-instructions liées au PAC ; pour l'analyse dynamique, Frida injecte des trampolines *après* avoir retiré le PAC, mais vos trampolines personnalisés doivent appeler `pacda`/`autibsp` quand nécessaire.
* **MTE & Scudo hardened allocator :** le memory-tagging est optionnel mais de nombreuses apps compatibles Play-Integrity sont compilées avec `-fsanitize=memtag` ; utilisez `setprop arm64.memtag.dump 1` puis `adb shell am start ...` pour capturer les fautes de tag.
* **LLVM Obfuscator (opaque predicates, control-flow flattening) :** les packers commerciaux (par ex. Bangcle, SecNeo) protègent de plus en plus le code *native*, pas seulement le Java ; attendez-vous à du control-flow trompeur et des blobs de chaînes chiffrées dans `.rodata`.

---

### Ressources

- **Apprendre l'assembleur ARM :** [Azeria Labs – ARM Assembly Basics](https://azeria-labs.com/writing-arm-assembly-part-1/)
- **JNI & NDK Documentation :** [Oracle JNI Spec](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html) · [Android JNI Tips](https://developer.android.com/training/articles/perf-jni) · [NDK Guides](https://developer.android.com/ndk/guides/)
- **Debugging des bibliothèques natives :** [Debug Android Native Libraries Using JEB Decompiler](https://medium.com/@shubhamsonani/how-to-debug-android-native-libraries-using-jeb-decompiler-eec681a22cf3)

### Références

- Frida 16.x change-log (Android hooking, tiny-function relocation) – [frida.re/news](https://frida.re/news/)
- NVD advisory for `libwebp` overflow CVE-2023-4863 – [nvd.nist.gov](https://nvd.nist.gov/vuln/detail/CVE-2023-4863)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- SoTap Releases – [github.com/RezaArbabBot/SoTap/releases](https://github.com/RezaArbabBot/SoTap/releases)
- How to work with SoTap? – [t.me/ForYouTillEnd/13](https://t.me/ForYouTillEnd/13)
- [CoRPhone — JNI memory-only execution pattern and packaging](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
