# रिवर्सिंग नेटीव लाइब्रेरीज़

{{#include ../../banners/hacktricks-training.md}}


**अधिक जानकारी के लिए देखें:** [**https://maddiestone.github.io/AndroidAppRE/reversing_native_libs.html**](https://maddiestone.github.io/AndroidAppRE/reversing_native_libs.html)

Android ऐप्स performance-critical कार्यों के लिए आम तौर पर C या C++ में लिखी गई native libraries का उपयोग कर सकते हैं। मैलवेयर रचयिता भी इन लाइब्रेरीज़ का दुरुपयोग करते हैं क्योंकि ELF shared objects अभी भी DEX/OAT byte-code की तुलना में decompile करने में कठिन होते हैं।
यह पेज *प्रैक्टिकल* वर्कफ़्लोज़ और *हालिया* tooling सुधारों (2023-2025) पर केंद्रित है जो Android `.so` फ़ाइलों को रिवर्स करना आसान बनाते हैं।

---

### ताजा निकाली गई `libfoo.so` के लिए त्वरित ट्रायेज-वर्कफ़्लो

1. **लाइब्रेरी निकालें**
```bash
# From an installed application
adb shell "run-as <pkg> cat lib/arm64-v8a/libfoo.so" > libfoo.so
# Or from the APK (zip)
unzip -j target.apk "lib/*/libfoo.so" -d extracted_libs/
```
2. **आर्किटेक्चर और प्रोटेक्शंस पहचानें**
```bash
file libfoo.so        # arm64 or arm32 / x86
readelf -h libfoo.so  # OS ABI, PIE, NX, RELRO, etc.
checksec --file libfoo.so  # (peda/pwntools)
```
3. **exported symbols और JNI bindings सूचीबद्ध करें**
```bash
readelf -s libfoo.so | grep ' Java_'     # dynamic-linked JNI
strings libfoo.so   | grep -i "RegisterNatives" -n   # static-registered JNI
```
4. **Decompiler में लोड करें** (Ghidra ≥ 11.0, IDA Pro, Binary Ninja, Hopper or Cutter/Rizin) और auto-analysis चलाएँ।
नयी Ghidra versions ने एक AArch64 decompiler पेश किया है जो PAC/BTI stubs और MTE tags को पहचानता है, जिससे Android 14 NDK से बनी libraries का analysis काफी बेहतर हुआ है।
5. **static vs dynamic reversing पर निर्णय लें:** stripped, obfuscated code अक्सर *instrumentation* (Frida, ptrace/gdbserver, LLDB) की मांग करता है।

---

### डायनामिक इंस्ट्रूमेंटेशन (Frida ≥ 16)

Frida की 16-सीरीज़ ने कई Android-specific सुधार लाए हैं जो तब मदद करते हैं जब टार्गेट आधुनिक Clang/LLD optimisations का उपयोग करता है:

* `thumb-relocator` अब LLD की aggressive alignment (`--icf=all`) द्वारा जनरेट की गई छोटे ARM/Thumb functions को *hook* कर सकता है।
* Android पर *ELF import slots* को enumerate और rebind करना काम करता है, जिससे inline hooks reject होने पर per-module `dlopen()`/`dlsym()` patching सक्षम होता है।
* जब ऐप्स Android 14 पर `--enable-optimizations` के साथ compiled होते हैं तब उपयोग किए जाने वाले नए **ART quick-entrypoint** के लिए Java hooking ठीक किया गया है।

उदाहरण: `RegisterNatives` के माध्यम से रजिस्टर किए गए सभी functions को सूचीबद्ध करना और runtime पर उनके addresses dump करना:
```javascript
Java.perform(function () {
var Runtime = Java.use('java.lang.Runtime');
var register = Module.findExportByName(null, 'RegisterNatives');
Interceptor.attach(register, {
onEnter(args) {
var envPtr  = args[0];
var clazz   = Java.cast(args[1], Java.use('java.lang.Class'));
var methods = args[2];
var count   = args[3].toInt32();
console.log('[+] RegisterNatives on ' + clazz.getName() + ' -> ' + count + ' methods');
// iterate & dump (JNI nativeMethod struct: name, sig, fnPtr)
}
});
});
```
Frida बिना अतिरिक्त कॉन्फ़िगरेशन के PAC/BTI-enabled devices (Pixel 8/Android 14+) पर तब तक काम करेगा जब तक आप frida-server 16.2 या बाद का उपयोग कर रहे हैं – पुराने संस्करण inline hooks के लिए padding locate करने में विफल थे।

### Process-local JNI telemetry via preloaded .so (SoTap)

जब full-featured instrumentation ओवरकिल हो या ब्लॉक हो, तब भी आप target process के भीतर एक छोटा logger प्री-लोड करके native-स्तरीय visibility हासिल कर सकते हैं। SoTap एक lightweight Android native (.so) library है जो उसी app process के भीतर अन्य JNI (.so) libraries के runtime व्यवहार को लॉग करता है (no root required)।

मुख्य विशेषताएँ:
- प्रारंभ में इनिशियलाइज़ होता है और उस process के अंदर JNI/native interactions को observe करता है जो इसे लोड करता है।
- कई writable paths का उपयोग करके लॉग्स को स्थायी रूप से सहेजता है और जब storage restricted हो तो सुव्यवस्थित तरीके से Logcat पर fallback कर जाता है।
- Source-customizable: sotap.c को एडिट करके लॉग किए जाने वाले तत्वों को बढ़ाएँ/समायोजित करें और प्रत्येक ABI के लिए रीबिल्ड करें।

सेटअप (repack the APK):
1) सही ABI build को APK में डालें ताकि loader libsotap.so को resolve कर सके:
- lib/arm64-v8a/libsotap.so (arm64 के लिए)
- lib/armeabi-v7a/libsotap.so (arm32 के लिए)
2) सुनिश्चित करें कि SoTap अन्य JNI लाइब्स से पहले लोड हो। शुरुआती चरण में एक call inject करें (उदा., Application subclass के static initializer या onCreate) ताकि logger पहले initialize हो। Smali snippet उदाहरण:
```smali
const-string v0, "sotap"
invoke-static {v0}, Ljava/lang/System;->loadLibrary(Ljava/lang/String;)V
```
3) Rebuild/sign/install करें, ऐप चलाएँ, और फिर लॉग्स एकत्रित करें।

लॉग पाथ (क्रम में जाँचे जाते हैं):
```
/data/user/0/%s/files/sotap.log
/data/data/%s/files/sotap.log
/sdcard/Android/data/%s/files/sotap.log
/sdcard/Download/sotap-%s.log
# If all fail: fallback to Logcat only
```
नोट्स और समस्या निवारण:
- ABI alignment अनिवार्य है। mismatch होने पर UnsatisfiedLinkError उठेगा और logger लोड नहीं होगा।
- Storage constraints आधुनिक Android पर सामान्य हैं; अगर फाइल लिखने में विफलता हो तो SoTap फिर भी Logcat के जरिए emit करेगा।
- व्यवहार/verbosity को अनुकूलित करने के लिए उद्देश्यपूर्ण रखा गया है; sotap.c संपादित करने के बाद स्रोत से फिर से build करें।

यह तरीका malware triage और JNI debugging के लिए उपयोगी है जहाँ process start से native call flows का अवलोकन κρίतिक होता है लेकिन root/system-wide hooks उपलब्ध नहीं होते।

---

### Recent vulnerabilities worth hunting for in APKs

| Year | CVE | Affected library | Notes |
|------|-----|------------------|-------|
|2023|CVE-2023-4863|`libwebp` ≤ 1.3.1|नेटिव कोड जो WebP इमेजेस को डिकोड करता है उसमें पहुँच योग्य heap buffer overflow। कई Android apps कमजोर संस्करण bundle करते हैं। जब आप किसी APK में `libwebp.so` देखें, तो उसकी version चेक करें और exploit या patch करने का प्रयास करें.| |
|2024|Multiple|OpenSSL 3.x series|कई memory-safety और padding-oracle समस्याएँ। कई Flutter & ReactNative bundles अपना खुद का `libcrypto.so` ship करते हैं।|

जब आप किसी APK के अंदर third-party `.so` फाइलें देखें, तो हमेशा उनका hash upstream advisories के साथ cross-check करें। SCA (Software Composition Analysis) mobile पर आम नहीं है, इसलिए outdated vulnerable builds प्रचुर मात्रा में मिलते हैं।

---

### Anti-Reversing & Hardening trends (Android 13-15)

* **Pointer Authentication (PAC) & Branch Target Identification (BTI):** Android 14 system libraries में PAC/BTI सक्षम करता है जब ARMv8.3+ silicon समर्थित हो। Decompilers अब PAC‑संबंधित pseudo-instructions दिखाते हैं; dynamic analysis के लिए Frida PAC strip करने के बाद trampolines inject करता है, लेकिन आपके custom trampolines को जहाँ आवश्यक हो वहां `pacda`/`autibsp` कॉल करना चाहिए।
* **MTE & Scudo hardened allocator:** memory-tagging opt-in है लेकिन कई Play-Integrity aware apps `-fsanitize=memtag` के साथ build होते हैं; tag faults कैप्चर करने के लिए `setprop arm64.memtag.dump 1` और फिर `adb shell am start ...` का उपयोग करें।
* **LLVM Obfuscator (opaque predicates, control-flow flattening):** commercial packers (e.g., Bangcle, SecNeo) बढ़ती मात्रा में सिर्फ Java ही नहीं बल्कि *native* कोड की भी रक्षा करते हैं; `.rodata` में bogus control-flow और encrypted string blobs की उम्मीद रखें।

---

### Resources

- **Learning ARM Assembly:** [Azeria Labs – ARM Assembly Basics](https://azeria-labs.com/writing-arm-assembly-part-1/)
- **JNI & NDK Documentation:** [Oracle JNI Spec](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html) · [Android JNI Tips](https://developer.android.com/training/articles/perf-jni) · [NDK Guides](https://developer.android.com/ndk/guides/)
- **Debugging Native Libraries:** [Debug Android Native Libraries Using JEB Decompiler](https://medium.com/@shubhamsonani/how-to-debug-android-native-libraries-using-jeb-decompiler-eec681a22cf3)

### References

- Frida 16.x change-log (Android hooking, tiny-function relocation) – [frida.re/news](https://frida.re/news/)
- NVD advisory for `libwebp` overflow CVE-2023-4863 – [nvd.nist.gov](https://nvd.nist.gov/vuln/detail/CVE-2023-4863)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- SoTap Releases – [github.com/RezaArbabBot/SoTap/releases](https://github.com/RezaArbabBot/SoTap/releases)
- How to work with SoTap? – [t.me/ForYouTillEnd/13](https://t.me/ForYouTillEnd/13)

{{#include ../../banners/hacktricks-training.md}}
