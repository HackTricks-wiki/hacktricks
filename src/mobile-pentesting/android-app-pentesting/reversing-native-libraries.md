# Revirtiendo bibliotecas nativas

{{#include ../../banners/hacktricks-training.md}}


**Para más información consulta:** [**https://maddiestone.github.io/AndroidAppRE/reversing_native_libs.html**](https://maddiestone.github.io/AndroidAppRE/reversing_native_libs.html)

Las apps Android pueden usar bibliotecas nativas, típicamente escritas en C o C++, para tareas críticas de rendimiento. Los creadores de malware también abusan de estas bibliotecas porque los objetos compartidos ELF siguen siendo más difíciles de descompilar que el byte-code DEX/OAT.
Esta página se centra en flujos de trabajo *prácticos* y mejoras *recientes* de herramientas (2023-2025) que facilitan el reversing de archivos `.so` de Android.

---

### Flujo rápido de triaje para un `libfoo.so` recién extraído

1. **Extraer la biblioteca**
```bash
# From an installed application
adb shell "run-as <pkg> cat lib/arm64-v8a/libfoo.so" > libfoo.so
# Or from the APK (zip)
unzip -j target.apk "lib/*/libfoo.so" -d extracted_libs/
```
2. **Identificar arquitectura y protecciones**
```bash
file libfoo.so        # arm64 or arm32 / x86
readelf -h libfoo.so  # OS ABI, PIE, NX, RELRO, etc.
checksec --file libfoo.so  # (peda/pwntools)
```
3. **Listar símbolos exportados y enlaces JNI**
```bash
readelf -s libfoo.so | grep ' Java_'     # dynamic-linked JNI
strings libfoo.so   | grep -i "RegisterNatives" -n   # static-registered JNI
```
4. **Cargar en un decompilador** (Ghidra ≥ 11.0, IDA Pro, Binary Ninja, Hopper or Cutter/Rizin) y ejecutar análisis automático.
Las versiones más recientes de Ghidra introdujeron un decompilador AArch64 que reconoce stubs PAC/BTI y etiquetas MTE, mejorando considerablemente el análisis de bibliotecas construidas con el NDK de Android 14.
5. **Decidir entre reversing estático o dinámico:** el código stripped u ofuscado a menudo necesita *instrumentación* (Frida, ptrace/gdbserver, LLDB).

---

### Instrumentación dinámica (Frida ≥ 16)

La serie 16 de Frida trajo varias mejoras específicas para Android que ayudan cuando el objetivo usa optimizaciones modernas de Clang/LLD:

* `thumb-relocator` ahora puede *hook tiny ARM/Thumb functions* generadas por la alineación agresiva de LLD (`--icf=all`).
* La enumeración y re-binding de *ELF import slots* funciona en Android, permitiendo parcheo por módulo con `dlopen()`/`dlsym()` cuando los inline hooks son rechazados.
* Se corrigió Java hooking para el nuevo **ART quick-entrypoint** usado cuando las apps se compilan con `--enable-optimizations` en Android 14.

Ejemplo: enumerando todas las funciones registradas mediante `RegisterNatives` y volcando sus direcciones en tiempo de ejecución:
```javascript
Java.perform(function () {
var Runtime = Java.use('java.lang.Runtime');
var register = Module.findExportByName(null, 'RegisterNatives');
Interceptor.attach(register, {
onEnter(args) {
var envPtr  = args[0];
var clazz   = Java.cast(args[1], Java.use('java.lang.Class'));
var methods = args[2];
var count   = args[3].toInt32();
console.log('[+] RegisterNatives on ' + clazz.getName() + ' -> ' + count + ' methods');
// iterate & dump (JNI nativeMethod struct: name, sig, fnPtr)
}
});
});
```
Frida will work out of the box on PAC/BTI-enabled devices (Pixel 8/Android 14+) as long as you use frida-server 16.2 or later – earlier versions failed to locate padding for inline hooks.

### Telemetría JNI local al proceso vía .so precargado (SoTap)

Cuando la instrumentación completa es excesiva o está bloqueada, aún puedes obtener visibilidad a nivel nativo precargando un pequeño logger dentro del proceso objetivo. SoTap es una librería nativa ligera de Android (.so) que registra el comportamiento en tiempo de ejecución de otras librerías JNI (.so) dentro del mismo proceso de la app (no se requiere root).

Propiedades clave:
- Se inicializa temprano y observa las interacciones JNI/nativas dentro del proceso que lo carga.
- Persiste logs usando múltiples rutas escribibles con una degradación elegante a Logcat cuando el almacenamiento está restringido.
- Personalizable desde el código fuente: edita sotap.c para ampliar/ajustar qué se registra y recompila por ABI.

Setup (repack the APK):
1) Coloca la compilación adecuada por ABI dentro del APK para que el loader pueda resolver libsotap.so:
- lib/arm64-v8a/libsotap.so (for arm64)
- lib/armeabi-v7a/libsotap.so (for arm32)
2) Asegura que SoTap se cargue antes que otras libs JNI. Injerta una llamada temprano (por ejemplo, Application subclass static initializer or onCreate) para que el logger se inicialice primero. Smali snippet example:
```smali
const-string v0, "sotap"
invoke-static {v0}, Ljava/lang/System;->loadLibrary(Ljava/lang/String;)V
```
3) Rebuild/sign/install, run the app, then collect logs.

Log paths (checked in order):
```
/data/user/0/%s/files/sotap.log
/data/data/%s/files/sotap.log
/sdcard/Android/data/%s/files/sotap.log
/sdcard/Download/sotap-%s.log
# If all fail: fallback to Logcat only
```
Notas y solución de problemas:
- La alineación de ABI es obligatoria. Un desajuste provocará UnsatisfiedLinkError y el logger no se cargará.
- Las restricciones de almacenamiento son comunes en Android moderno; si las escrituras de archivos fallan, SoTap seguirá emitiendo vía Logcat.
- El comportamiento y el nivel de verbosidad están pensados para personalizarse; recompila desde la fuente después de editar sotap.c.

This approach is useful for malware triage and JNI debugging where observing native call flows from process start is critical but root/system-wide hooks aren’t available.

---

### Recent vulnerabilities worth hunting for in APKs

| Year | CVE | Affected library | Notes |
|------|-----|------------------|-------|
|2023|CVE-2023-4863|`libwebp` ≤ 1.3.1|Desbordamiento de heap alcanzable desde código nativo que decodifica imágenes WebP. Varias apps de Android incluyen versiones vulnerables. Cuando veas un `libwebp.so` dentro de un APK, verifica su versión e intenta explotarlo o parchearlo.| |
|2024|Multiple|OpenSSL 3.x series|Varios problemas de memory-safety y padding-oracle. Muchos bundles de Flutter & ReactNative incluyen su propio `libcrypto.so`.| |

When you spot *third-party* `.so` files inside an APK, always cross-check their hash against upstream advisories. SCA (Software Composition Analysis) is uncommon on mobile, so outdated vulnerable builds are rampant.

---

### Anti-Reversing & Hardening trends (Android 13-15)

* **Pointer Authentication (PAC) & Branch Target Identification (BTI):** Android 14 enables PAC/BTI in system libraries on supported ARMv8.3+ silicon. Decompilers now display PAC‐related pseudo-instructions; for dynamic analysis Frida injects trampolines *after* stripping PAC, but your custom trampolines should call `pacda`/`autibsp` where necessary.
* **MTE & Scudo hardened allocator:** el memory-tagging es opcional pero muchas apps conscientes de Play-Integrity se compilan con `-fsanitize=memtag`; usa `setprop arm64.memtag.dump 1` junto con `adb shell am start ...` para capturar fallos de etiqueta.
* **LLVM Obfuscator (opaque predicates, control-flow flattening):** los packers comerciales (p. ej., Bangcle, SecNeo) protegen cada vez más el *native* code, no solo Java; espera control-flow falso y blobs de strings cifrados en `.rodata`.

---

### Resources

- **Aprender ARM Assembly:** [Azeria Labs – ARM Assembly Basics](https://azeria-labs.com/writing-arm-assembly-part-1/)
- **Documentación JNI & NDK:** [Oracle JNI Spec](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html) · [Android JNI Tips](https://developer.android.com/training/articles/perf-jni) · [NDK Guides](https://developer.android.com/ndk/guides/)
- **Depuración de librerías nativas:** [Debug Android Native Libraries Using JEB Decompiler](https://medium.com/@shubhamsonani/how-to-debug-android-native-libraries-using-jeb-decompiler-eec681a22cf3)

### References

- Registro de cambios de Frida 16.x (Android hooking, tiny-function relocation) – [frida.re/news](https://frida.re/news/)
- Aviso NVD para el desbordamiento de `libwebp` CVE-2023-4863 – [nvd.nist.gov](https://nvd.nist.gov/vuln/detail/CVE-2023-4863)
- SoTap: logger ligero in-app para comportamiento JNI (.so) – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- Releases de SoTap – [github.com/RezaArbabBot/SoTap/releases](https://github.com/RezaArbabBot/SoTap/releases)
- ¿Cómo trabajar con SoTap? – [t.me/ForYouTillEnd/13](https://t.me/ForYouTillEnd/13)

{{#include ../../banners/hacktricks-training.md}}
