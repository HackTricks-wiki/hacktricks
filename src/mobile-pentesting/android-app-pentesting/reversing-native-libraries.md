# Reversing Native Libraries

{{#include ../../banners/hacktricks-training.md}}

**Vir verdere inligting, kyk:** [**https://maddiestone.github.io/AndroidAppRE/reversing_native_libs.html**](https://maddiestone.github.io/AndroidAppRE/reversing_native_libs.html)

Android-toepassings kan inheemse biblioteke gebruik, wat tipies in C of C++ geskryf is, vir prestasiekritieke take. Malware-skeppers misbruik ook hierdie biblioteke omdat ELF gedeelde voorwerpe steeds moeiliker is om te dekompileer as DEX/OAT byte-kode. Hierdie bladsy fokus op *praktiese* werksvloeie en *onlangse* hulpmiddelverbeterings (2023-2025) wat die omkering van Android `.so` lêers makliker maak.

---

### Vinnige triage-werksvloei vir 'n vars getrokke `libfoo.so`

1. **Onthaal die biblioteek**
```bash
# Van 'n geïnstalleerde toepassing
adb shell "run-as <pkg> cat lib/arm64-v8a/libfoo.so" > libfoo.so
# Of van die APK (zip)
unzip -j target.apk "lib/*/libfoo.so" -d extracted_libs/
```
2. **Identifiseer argitektuur & beskermings**
```bash
file libfoo.so        # arm64 of arm32 / x86
readelf -h libfoo.so  # OS ABI, PIE, NX, RELRO, ens.
checksec --file libfoo.so  # (peda/pwntools)
```
3. **Lys geëksporteerde simbole & JNI bindings**
```bash
readelf -s libfoo.so | grep ' Java_'     # dinamies-gekoppelde JNI
strings libfoo.so   | grep -i "RegisterNatives" -n   # staties-geregistreerde JNI
```
4. **Laai in 'n dekompiler** (Ghidra ≥ 11.0, IDA Pro, Binary Ninja, Hopper of Cutter/Rizin) en voer outomatiese analise uit. Nuwe Ghidra weergawes het 'n AArch64 dekompiler bekendgestel wat PAC/BTI stubs en MTE-tags herken, wat die analise van biblioteke wat met die Android 14 NDK gebou is, aansienlik verbeter.
5. **Bepaal op statiese vs dinamiese omkering:** gestript, obfuskeer kode benodig dikwels *instrumentasie* (Frida, ptrace/gdbserver, LLDB).

---

### Dinamiese Instrumentasie (Frida ≥ 16)

Frida se 16-reeks het verskeie Android-spesifieke verbeterings gebring wat help wanneer die teiken moderne Clang/LLD optimaliseringe gebruik:

* `thumb-relocator` kan nou *klein ARM/Thumb funksies* wat deur LLD se aggressiewe uitlijning (`--icf=all`) gegenereer is, *hook*.
* Die opnoem en herbinding van *ELF invoer slots* werk op Android, wat per-module `dlopen()`/`dlsym()` patching moontlik maak wanneer inline hooks verwerp word.
* Java hooking is reggestel vir die nuwe **ART vinnige toegangspunt** wat gebruik word wanneer toepassings gecompileer word met `--enable-optimizations` op Android 14.

Voorbeeld: opnoem van alle funksies wat deur `RegisterNatives` geregistreer is en hul adresse tydens uitvoering dump:
```javascript
Java.perform(function () {
var Runtime = Java.use('java.lang.Runtime');
var register = Module.findExportByName(null, 'RegisterNatives');
Interceptor.attach(register, {
onEnter(args) {
var envPtr  = args[0];
var clazz   = Java.cast(args[1], Java.use('java.lang.Class'));
var methods = args[2];
var count   = args[3].toInt32();
console.log('[+] RegisterNatives on ' + clazz.getName() + ' -> ' + count + ' methods');
// iterate & dump (JNI nativeMethod struct: name, sig, fnPtr)
}
});
});
```
Frida sal uit die boks werk op PAC/BTI-geaktiveerde toestelle (Pixel 8/Android 14+) solank jy frida-server 16.2 of later gebruik – vroeëre weergawes het gefaal om padding vir inline hooks te vind.  citeturn5search2turn5search0

---

### Onlangse kwesbaarhede wat die moeite werd is om in APK's te jag

| Jaar | CVE | Aangetaste biblioteek | Aantekeninge |
|------|-----|------------------|-------|
|2023|CVE-2023-4863|`libwebp` ≤ 1.3.1|Heap buffer overflow bereikbaar vanaf native kode wat WebP-prente decodeer. Verskeie Android-apps bundel kwesbare weergawes. Wanneer jy 'n `libwebp.so` binne 'n APK sien, kontroleer sy weergawe en probeer om te exploiteer of te patch.| citeturn2search0|
|2024|Meervoudig|OpenSSL 3.x reeks|Verskeie geheue-veilige en padding-orakel probleme. Baie Flutter & ReactNative bundels verskaf hul eie `libcrypto.so`.|

Wanneer jy *derdeparty* `.so` lêers binne 'n APK opmerk, kontroleer altyd hul hash teen opwaartse advies. SCA (Software Composition Analysis) is ongewoon op mobiele toestelle, so verouderde kwesbare boue is volop.

---

### Anti-Reversing & Hardening neigings (Android 13-15)

* **Pointer Authentication (PAC) & Branch Target Identification (BTI):** Android 14 stel PAC/BTI in stelselbiblioteke op ondersteunde ARMv8.3+ silikoon in. Decompilers vertoon nou PAC-verwante pseudo-instruksies; vir dinamiese analise injecteer Frida trampolines *nadat* PAC verwyder is, maar jou eie trampolines moet `pacda`/`autibsp` aanroep waar nodig.
* **MTE & Scudo geharde allokator:** geheue-tagging is opt-in maar baie Play-Integrity bewuste apps bou met `-fsanitize=memtag`; gebruik `setprop arm64.memtag.dump 1` plus `adb shell am start ...` om tag foute te vang.
* **LLVM Obfuscator (opake predikate, kontrole-stroom afvlakking):** kommersiële packers (bv. Bangcle, SecNeo) beskerm toenemend *native* kode, nie net Java nie; verwag valse kontrole-stroom en versleutelde string blobs in `.rodata`.

---

### Hulpbronne

- **Leer ARM Assembly:** [Azeria Labs – ARM Assembly Basics](https://azeria-labs.com/writing-arm-assembly-part-1/)
- **JNI & NDK Dokumentasie:** [Oracle JNI Spec](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html) · [Android JNI Wenke](https://developer.android.com/training/articles/perf-jni) · [NDK Gidse](https://developer.android.com/ndk/guides/)
- **Debugging Native Libraries:** [Debug Android Native Libraries Using JEB Decompiler](https://medium.com/@shubhamsonani/how-to-debug-android-native-libraries-using-jeb-decompiler-eec681a22cf3)

### Verwysings

- Frida 16.x verandering-log (Android hooking, tiny-function herlokasie) – [frida.re/news](https://frida.re/news/)  citeturn5search0
- NVD advies vir `libwebp` overflow CVE-2023-4863 – [nvd.nist.gov](https://nvd.nist.gov/vuln/detail/CVE-2023-4863) citeturn2search0

{{#include ../../banners/hacktricks-training.md}}
