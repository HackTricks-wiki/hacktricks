# Reverse-Engineering nativer Bibliotheken

{{#include ../../banners/hacktricks-training.md}}


**Für weitere Informationen siehe:** [**https://maddiestone.github.io/AndroidAppRE/reversing_native_libs.html**](https://maddiestone.github.io/AndroidAppRE/reversing_native_libs.html)

Android-Apps können native Bibliotheken verwenden, typischerweise in C oder C++ geschrieben, für performance-kritische Aufgaben. Malware-Autoren missbrauchen diese Bibliotheken ebenfalls, weil ELF shared objects immer noch schwieriger zu dekompilieren sind als DEX/OAT byte-code.
Diese Seite konzentriert sich auf *praktische* Workflows und *aktuelle* Tool-Verbesserungen (2023–2025), die das Reverse-Engineering von Android `.so`-Dateien erleichtern.

---

### Schneller Triage-Workflow für eine frisch extrahierte `libfoo.so`

1. **Extract the library**
```bash
# From an installed application
adb shell "run-as <pkg> cat lib/arm64-v8a/libfoo.so" > libfoo.so
# Or from the APK (zip)
unzip -j target.apk "lib/*/libfoo.so" -d extracted_libs/
```
2. **Architektur & Schutzmechanismen identifizieren**
```bash
file libfoo.so        # arm64 or arm32 / x86
readelf -h libfoo.so  # OS ABI, PIE, NX, RELRO, etc.
checksec --file libfoo.so  # (peda/pwntools)
```
3. **Exportierte Symbole & JNI-Bindings auflisten**
```bash
readelf -s libfoo.so | grep ' Java_'     # dynamic-linked JNI
strings libfoo.so   | grep -i "RegisterNatives" -n   # static-registered JNI
```
4. **In einen Decompiler laden** (Ghidra ≥ 11.0, IDA Pro, Binary Ninja, Hopper or Cutter/Rizin) und die Auto-Analyse laufen lassen.
Neuere Ghidra-Versionen haben einen AArch64-Decompiler eingeführt, der PAC/BTI-Stubs und MTE-Tags erkennt, was die Analyse von Bibliotheken verbessert, die mit dem Android 14 NDK gebaut wurden.
5. **Zwischen statischem und dynamischem Reverse-Engineering entscheiden:** stark gestrippten oder obfuskierten Code erfordert oft *Instrumentation* (Frida, ptrace/gdbserver, LLDB).

---

### Dynamische Instrumentierung (Frida ≥ 16)

Die 16er-Serie von Frida brachte mehrere Android-spezifische Verbesserungen, die helfen, wenn das Ziel moderne Clang/LLD-Optimierungen verwendet:

* `thumb-relocator` kann jetzt *sehr kleine ARM/Thumb-Funktionen* hooken, die durch LLDs aggressive Alignment (`--icf=all`) erzeugt werden.
* Das Auflisten und Neu-Binden von *ELF import slots* funktioniert auf Android und ermöglicht pro-Modul `dlopen()`/`dlsym()`-Patching, wenn Inline-Hooks abgelehnt werden.
* Java-Hooking wurde für den neuen **ART quick-entrypoint** behoben, der verwendet wird, wenn Apps mit `--enable-optimizations` auf Android 14 kompiliert werden.

Example: enumerating all functions registered through `RegisterNatives` and dumping their addresses at runtime:
```javascript
Java.perform(function () {
var Runtime = Java.use('java.lang.Runtime');
var register = Module.findExportByName(null, 'RegisterNatives');
Interceptor.attach(register, {
onEnter(args) {
var envPtr  = args[0];
var clazz   = Java.cast(args[1], Java.use('java.lang.Class'));
var methods = args[2];
var count   = args[3].toInt32();
console.log('[+] RegisterNatives on ' + clazz.getName() + ' -> ' + count + ' methods');
// iterate & dump (JNI nativeMethod struct: name, sig, fnPtr)
}
});
});
```
Frida funktioniert sofort auf PAC/BTI-aktivierten Geräten (Pixel 8/Android 14+), solange du frida-server 16.2 oder neuer verwendest – frühere Versionen konnten das Padding für inline hooks nicht finden.

### Prozesslokale JNI-Telemetrie über vorab geladenes .so (SoTap)

Wenn vollumfängliche Instrumentation übertrieben oder blockiert ist, kannst du trotzdem Sichtbarkeit auf Native-Ebene erreichen, indem du einen kleinen Logger im Zielprozess preloadest. SoTap ist eine leichte Android native (.so) Bibliothek, die das Laufzeitverhalten anderer JNI (.so) Bibliotheken im selben App-Prozess protokolliert (kein Root erforderlich).

Wesentliche Eigenschaften:
- Initialisiert früh und beobachtet JNI/native Interaktionen innerhalb des Prozesses, der es lädt.
- Persistiert Logs über mehrere schreibbare Pfade mit elegantem Fallback auf Logcat, wenn Speicher eingeschränkt ist.
- Quellcode-anpassbar: editier sotap.c, um zu erweitern/anzupassen, was geloggt wird, und baue pro ABI neu.

Einrichtung (repack the APK):
1) Drop the proper ABI build into the APK so the loader can resolve libsotap.so:
- lib/arm64-v8a/libsotap.so (for arm64)
- lib/armeabi-v7a/libsotap.so (for arm32)
2) Ensure SoTap loads before other JNI libs. Inject a call early (e.g., Application subclass static initializer or onCreate) so the logger is initialized first. Smali snippet example:
```smali
const-string v0, "sotap"
invoke-static {v0}, Ljava/lang/System;->loadLibrary(Ljava/lang/String;)V
```
3) Rebuild/sign/install, run the app, then collect logs.

Log paths (checked in order):
```
/data/user/0/%s/files/sotap.log
/data/data/%s/files/sotap.log
/sdcard/Android/data/%s/files/sotap.log
/sdcard/Download/sotap-%s.log
# If all fail: fallback to Logcat only
```
Hinweise und Fehlerbehebung:
- ABI-Ausrichtung ist zwingend erforderlich. Eine Nichtübereinstimmung führt zu UnsatisfiedLinkError und der Logger wird nicht geladen.
- Speicherbeschränkungen sind auf modernen Android-Geräten üblich; wenn Dateischreibvorgänge fehlschlagen, gibt SoTap weiterhin über Logcat aus.
- Verhalten/Ausführlichkeitsgrad ist zur Anpassung gedacht; nach Bearbeitung von sotap.c neu aus dem Quellcode bauen.

Dieser Ansatz ist nützlich für Malware-Triage und JNI-Debugging, wenn das Beobachten nativer Aufrufabläufe vom Prozessstart an kritisch ist, aber Root-/systemweite Hooks nicht verfügbar sind.

---

### See also: in‑memory native code execution via JNI

Ein gängiges Angriffs‑Pattern besteht darin, zur Laufzeit ein rohes Shellcode‑Blob herunterzuladen und es direkt aus dem Speicher über eine JNI‑Brücke auszuführen (kein ELF auf der Festplatte). Details und ein einsatzbereites JNI‑Schnipsel hier:

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

---

### Aktuelle Schwachstellen, nach denen man in APKs suchen sollte

| Jahr | CVE | Betroffene Bibliothek | Anmerkungen |
|------|-----|-----------------------|-------------|
|2023|CVE-2023-4863|`libwebp` ≤ 1.3.1|Heap-Pufferüberlauf, erreichbar aus nativem Code, der WebP-Bilder dekodiert. Mehrere Android-Apps bündeln verwundbare Versionen. Wenn Sie ein `libwebp.so` in einem APK sehen, prüfen Sie die Version und versuchen Sie, es auszunutzen oder zu patchen.| |
|2024|Multiple|OpenSSL 3.x series|Mehrere Memory-Safety- und Padding-Oracle-Probleme. Viele Flutter- & ReactNative-Bundles liefern ihre eigene `libcrypto.so`.|

Wenn Sie *third-party* `.so`-Dateien in einem APK finden, prüfen Sie immer deren Hash gegen Upstream-Hinweise. SCA (Software Composition Analysis) ist auf Mobilgeräten unüblich, daher sind veraltete, verwundbare Builds weit verbreitet.

---

### Anti-Reversing & Hardening-Trends (Android 13-15)

* **Pointer Authentication (PAC) & Branch Target Identification (BTI):** Android 14 aktiviert PAC/BTI in Systembibliotheken auf unterstützter ARMv8.3+ Hardware. Decompiler zeigen nun PAC‑bezogene Pseudo‑Instruktionen; für dynamische Analysen injiziert Frida Trampoline *nach* dem Entfernen von PAC, aber eigene Trampoline sollten `pacda`/`autibsp` aufrufen, wo nötig.
* **MTE & Scudo hardened allocator:** Memory-Tagging ist optional, aber viele Play-Integrity-bewusste Apps werden mit `-fsanitize=memtag` gebaut; benutzen Sie `setprop arm64.memtag.dump 1` plus `adb shell am start ...`, um Tag-Fehler zu erfassen.
* **LLVM Obfuscator (opaque predicates, control-flow flattening):** Kommerzielle Packager (z. B. Bangcle, SecNeo) schützen zunehmend *nativen* Code, nicht nur Java; erwarten Sie gefälschte Kontrollflüsse und verschlüsselte String‑Blobs in `.rodata`.

---

### Ressourcen

- **ARM-Assembly lernen:** [Azeria Labs – ARM Assembly Basics](https://azeria-labs.com/writing-arm-assembly-part-1/)
- **JNI- & NDK-Dokumentation:** [Oracle JNI Spec](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html) · [Android JNI Tips](https://developer.android.com/training/articles/perf-jni) · [NDK Guides](https://developer.android.com/ndk/guides/)
- **Debugging nativer Bibliotheken:** [Debug Android Native Libraries Using JEB Decompiler](https://medium.com/@shubhamsonani/how-to-debug-android-native-libraries-using-jeb-decompiler-eec681a22cf3)

### Referenzen

- Frida 16.x Changelog (Android hooking, tiny-function relocation) – [frida.re/news](https://frida.re/news/)
- NVD-Hinweis für `libwebp` overflow CVE-2023-4863 – [nvd.nist.gov](https://nvd.nist.gov/vuln/detail/CVE-2023-4863)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- SoTap Releases – [github.com/RezaArbabBot/SoTap/releases](https://github.com/RezaArbabBot/SoTap/releases)
- Wie mit SoTap arbeiten? – [t.me/ForYouTillEnd/13](https://t.me/ForYouTillEnd/13)
- [CoRPhone — JNI memory-only execution pattern and packaging](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
