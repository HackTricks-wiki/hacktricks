# Reversing Native Libraries

{{#include ../../banners/hacktricks-training.md}}


**अधिक जानकारी के लिए देखें:** [**https://maddiestone.github.io/AndroidAppRE/reversing_native_libs.html**](https://maddiestone.github.io/AndroidAppRE/reversing_native_libs.html)

Android apps performance-critical कामों के लिए अक्सर native libraries का उपयोग करती हैं, जो सामान्यतः C या C++ में लिखी जाती हैं। Malware क्रिएटर्स भी इन लाइब्रेरीज़ का दुरुपयोग करते हैं क्योंकि ELF shared objects को DEX/OAT byte-code से डीकम्पाइल करना अभी भी कठिन होता है।
यह पेज उन *प्रैक्टिकल* workflows और *हालिया* tooling सुधारों (2023-2025) पर केंद्रित है जो Android `.so` फाइलों को reversing करना आसान बनाते हैं।

---

### Quick triage-workflow for a freshly pulled `libfoo.so`

1. **Extract the library**
```bash
# From an installed application
adb shell "run-as <pkg> cat lib/arm64-v8a/libfoo.so" > libfoo.so
# Or from the APK (zip)
unzip -j target.apk "lib/*/libfoo.so" -d extracted_libs/
```
2. **Identify architecture & protections**
```bash
file libfoo.so        # arm64 or arm32 / x86
readelf -h libfoo.so  # OS ABI, PIE, NX, RELRO, etc.
checksec --file libfoo.so  # (peda/pwntools)
```
3. **List exported symbols & JNI bindings**
```bash
readelf -s libfoo.so | grep ' Java_'     # dynamic-linked JNI
strings libfoo.so   | grep -i "RegisterNatives" -n   # static-registered JNI
```
4. **Load in a decompiler** (Ghidra ≥ 11.0, IDA Pro, Binary Ninja, Hopper or Cutter/Rizin) and run auto-analysis.
नई Ghidra वर्ज़न्स ने एक AArch64 decompiler introduce किया है जो PAC/BTI stubs और MTE tags को पहचानता है, जिससे Android 14 NDK के साथ बनाई गई लाइब्रेरीज़ का analysis काफी बेहतर हो गया है।
5. **Decide on static vs dynamic reversing:** stripped, obfuscated code अक्सर *instrumentation* (Frida, ptrace/gdbserver, LLDB) की मांग करता है।

---

### Dynamic Instrumentation (Frida ≥ 16)

Frida की 16-series ने कई Android-विशिष्ट सुधार लाए हैं जो तब मदद करते हैं जब लक्ष्य modern Clang/LLD optimisations का उपयोग कर रहा हो:

* `thumb-relocator` अब LLD की aggressive alignment (`--icf=all`) द्वारा जेनरेट किए गए छोटे ARM/Thumb functions को hook कर सकता है।
* Android पर *ELF import slots* को enumerate और rebind करना संभव हो गया है, जिससे per-module `dlopen()`/`dlsym()` patching तब किया जा सकता है जब inline hooks reject हो जाते हैं।
* Java hooking को नए **ART quick-entrypoint** के लिए ठीक किया गया है, जो तब उपयोग होता है जब apps Android 14 पर `--enable-optimizations` के साथ compile किए जाते हैं।

Example: enumerating all functions registered through `RegisterNatives` and dumping their addresses at runtime:
```javascript
Java.perform(function () {
var Runtime = Java.use('java.lang.Runtime');
var register = Module.findExportByName(null, 'RegisterNatives');
Interceptor.attach(register, {
onEnter(args) {
var envPtr  = args[0];
var clazz   = Java.cast(args[1], Java.use('java.lang.Class'));
var methods = args[2];
var count   = args[3].toInt32();
console.log('[+] RegisterNatives on ' + clazz.getName() + ' -> ' + count + ' methods');
// iterate & dump (JNI nativeMethod struct: name, sig, fnPtr)
}
});
});
```
Frida will work out of the box on PAC/BTI-enabled devices (Pixel 8/Android 14+) as long as you use frida-server 16.2 or later – पुराने वर्शन padding for inline hooks खोज पाने में विफल रहते थे।

### प्रोसेस-लोकल JNI telemetry preloaded .so (SoTap) के माध्यम से

जब full-featured instrumentation overkill या blocked हो, तब भी आप target process के अंदर एक छोटा logger preload करके native-स्तर की visibility हासिल कर सकते हैं। SoTap एक lightweight Android native (.so) लाइब्रेरी है जो उसी app process के भीतर अन्य JNI (.so) लाइब्रेरीज़ के runtime व्यवहार को लॉग करती है (no root required)।

Key properties:
- जल्दी initialize होता है और इसे लोड करने वाले process के अंदर JNI/native interactions को observe करता है।
- कई writable paths का उपयोग करके logs persist करता है और जब storage restricted हो तो graceful fallback के रूप में Logcat का उपयोग करता है।
- स्रोत-अनुकूलनीय: sotap.c को edit करके लॉग होने वाली जानकारी बढ़ाएँ/समायोजित करें और प्रति ABI rebuild करें।

Setup (repack the APK):
1) सही ABI build को APK में डालें ताकि loader libsotap.so को resolve कर सके:
- lib/arm64-v8a/libsotap.so (for arm64)
- lib/armeabi-v7a/libsotap.so (for arm32)
2) सुनिश्चित करें कि SoTap अन्य JNI libs से पहले लोड हो। एक कॉल जल्दी inject करें (उदा., Application subclass static initializer या onCreate) ताकि logger पहले initialize हो। Smali snippet example:
```smali
const-string v0, "sotap"
invoke-static {v0}, Ljava/lang/System;->loadLibrary(Ljava/lang/String;)V
```
3) Rebuild/sign/install करें, ऐप चलाएँ, फिर logs जमा करें।

Log paths (checked in order):
```
/data/user/0/%s/files/sotap.log
/data/data/%s/files/sotap.log
/sdcard/Android/data/%s/files/sotap.log
/sdcard/Download/sotap-%s.log
# If all fail: fallback to Logcat only
```
नोट्स और समस्या निवारण:
- ABI alignment अनिवार्य है। मेल न खाने पर UnsatisfiedLinkError उठेगा और logger लोड नहीं होगा।
- आधुनिक Android पर storage सीमाएँ सामान्य हैं; यदि फ़ाइल लिखना विफल रहता है, तो SoTap फिर भी Logcat के माध्यम से emit करेगा।
- व्यवहार/verbosity को अनुकूलित किया जाने के लिए बनाया गया है; sotap.c संपादित करने के बाद स्रोत से पुनर्निर्माण करें।

यह तरीका malware triage और JNI debugging के लिए उपयोगी है जहाँ process की शुरुआत से native call flows का निरीक्षण महत्वपूर्ण होता है पर root/system-wide hooks उपलब्ध नहीं होते।

---

### See also: in‑memory native code execution via JNI

एक सामान्य attack pattern runtime पर raw shellcode blob डाउनलोड करके JNI bridge के माध्यम से इसे सीधे memory से execute करना है (कोई on‑disk ELF नहीं)। विवरण और उपयोग के लिए तैयार JNI snippet यहाँ:

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

---

### हाल की vulnerabilities जिन्हें APKs में ढूँढ़ना चाहिए

| साल | CVE | प्रभावित लाइब्रेरी | नोट्स |
|------|-----|------------------|-------|
|2023|CVE-2023-4863|`libwebp` ≤ 1.3.1|WebP images को decode करने वाले native code से पहुँचनीय heap buffer overflow। कई Android ऐप्स vulnerable versions को bundle करते हैं। जब आप किसी APK के अंदर `libwebp.so` देखें, तो उसकी version जाँचें और exploitation या patching का प्रयास करें.| |
|2024|Multiple|OpenSSL 3.x series|कई memory-safety और padding-oracle समस्याएँ। कई Flutter & ReactNative bundles अपने `libcrypto.so` के साथ आते हैं।|

जब आप किसी APK के अंदर *third-party* `.so` फाइलें देखें, तो उनका hash हमेशा upstream advisories के खिलाफ cross-check करें। SCA (Software Composition Analysis) मोबाइल पर असामान्य है, इसलिए outdated vulnerable builds प्रचुर मात्रा में पाए जाते हैं।

---

### Anti-Reversing & Hardening के रुझान (Android 13-15)

* **Pointer Authentication (PAC) & Branch Target Identification (BTI):** Android 14 समर्थित ARMv8.3+ सिलिकॉन पर system libraries में PAC/BTI सक्षम करता है। Decompilers अब PAC‑संबंधित pseudo-instructions दिखाते हैं; dynamic analysis के लिए Frida PAC को strip करने के बाद trampolines inject करता है, पर आपके custom trampolines जहाँ ज़रूरी हों वहां `pacda`/`autibsp` को कॉल करना चाहिए।
* **MTE & Scudo hardened allocator:** memory-tagging विकल्प पर है लेकिन कई Play-Integrity aware apps `-fsanitize=memtag` के साथ build करते हैं; tag faults कैप्चर करने के लिए `setprop arm64.memtag.dump 1` और `adb shell am start ...` का उपयोग करें।
* **LLVM Obfuscator (opaque predicates, control-flow flattening):** commercial packers (e.g., Bangcle, SecNeo) दिन-प्रतिदिन native code की रक्षा करने लगे हैं, केवल Java ही नहीं; `.rodata` में bogus control-flow और encrypted string blobs की उम्मीद रखें।

---

### संसाधन

- **ARM Assembly सीखना:** [Azeria Labs – ARM Assembly Basics](https://azeria-labs.com/writing-arm-assembly-part-1/)
- **JNI & NDK दस्तावेज़:** [Oracle JNI Spec](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html) · [Android JNI Tips](https://developer.android.com/training/articles/perf-jni) · [NDK Guides](https://developer.android.com/ndk/guides/)
- **Native Libraries डिबगिंग:** [Debug Android Native Libraries Using JEB Decompiler](https://medium.com/@shubhamsonani/how-to-debug-android-native-libraries-using-jeb-decompiler-eec681a22cf3)

### संदर्भ

- Frida 16.x change-log (Android hooking, tiny-function relocation) – [frida.re/news](https://frida.re/news/)
- NVD advisory for `libwebp` overflow CVE-2023-4863 – [nvd.nist.gov](https://nvd.nist.gov/vuln/detail/CVE-2023-4863)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- SoTap Releases – [github.com/RezaArbabBot/SoTap/releases](https://github.com/RezaArbabBot/SoTap/releases)
- How to work with SoTap? – [t.me/ForYouTillEnd/13](https://t.me/ForYouTillEnd/13)
- [CoRPhone — JNI memory-only execution pattern and packaging](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
