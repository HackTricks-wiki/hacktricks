# Reversing Native Libraries

{{#include ../../banners/hacktricks-training.md}}

**अधिक जानकारी के लिए देखें:** [**https://maddiestone.github.io/AndroidAppRE/reversing_native_libs.html**](https://maddiestone.github.io/AndroidAppRE/reversing_native_libs.html)

Android ऐप्स प्रदर्शन-क्रिटिकल कार्यों के लिए आमतौर पर C या C++ में लिखी गई नेटीव लाइब्रेरी का उपयोग कर सकते हैं। मैलवेयर निर्माता भी इन लाइब्रेरी का दुरुपयोग करते हैं क्योंकि ELF साझा वस्तुएं DEX/OAT बाइट-कोड की तुलना में डिकंपाइल करना अभी भी कठिन हैं। यह पृष्ठ *व्यावहारिक* कार्यप्रवाहों और *हाल के* उपकरण सुधारों (2023-2025) पर केंद्रित है जो Android `.so` फ़ाइलों को उलटने को आसान बनाते हैं।

---

### ताजा खींची गई `libfoo.so` के लिए त्वरित ट्रायज-कार्यप्रवाह

1. **लाइब्रेरी निकालें**
```bash
# एक स्थापित एप्लिकेशन से
adb shell "run-as <pkg> cat lib/arm64-v8a/libfoo.so" > libfoo.so
# या APK (ज़िप) से
unzip -j target.apk "lib/*/libfoo.so" -d extracted_libs/
```
2. **आर्किटेक्चर और सुरक्षा की पहचान करें**
```bash
file libfoo.so        # arm64 या arm32 / x86
readelf -h libfoo.so  # OS ABI, PIE, NX, RELRO, आदि।
checksec --file libfoo.so  # (peda/pwntools)
```
3. **निर्यातित प्रतीकों और JNI बाइंडिंग की सूची बनाएं**
```bash
readelf -s libfoo.so | grep ' Java_'     # डायनामिक-लिंक्ड JNI
strings libfoo.so   | grep -i "RegisterNatives" -n   # स्थैतिक-रजिस्टर्ड JNI
```
4. **एक डिकंपाइलर में लोड करें** (Ghidra ≥ 11.0, IDA Pro, Binary Ninja, Hopper या Cutter/Rizin) और ऑटो-विश्लेषण चलाएं। नए Ghidra संस्करणों ने एक AArch64 डिकंपाइलर पेश किया है जो PAC/BTI स्टब और MTE टैग को पहचानता है, जो Android 14 NDK के साथ निर्मित लाइब्रेरी के विश्लेषण में काफी सुधार करता है।
5. **स्थैतिक बनाम डायनामिक रिवर्सिंग पर निर्णय लें:** स्ट्रिप्ड, ऑबफस्केटेड कोड अक्सर *इंस्ट्रुमेंटेशन* (Frida, ptrace/gdbserver, LLDB) की आवश्यकता होती है।

---

### डायनामिक इंस्ट्रुमेंटेशन (Frida ≥ 16)

Frida की 16-श्रृंखला ने कई Android-विशिष्ट सुधार लाए हैं जो तब मदद करते हैं जब लक्ष्य आधुनिक Clang/LLD ऑप्टिमाइजेशन का उपयोग करता है:

* `thumb-relocator` अब LLD के आक्रामक संरेखण (`--icf=all`) द्वारा उत्पन्न *छोटे ARM/Thumb फ़ंक्शंस* को *हुक* कर सकता है।
* *ELF आयात स्लॉट* को सूचीबद्ध करना और फिर से बाइंड करना Android पर काम करता है, जब इनलाइन हुक अस्वीकृत होते हैं तो प्रति-मॉड्यूल `dlopen()`/`dlsym()` पैचिंग सक्षम करता है।
* नए **ART त्वरित-एंट्रीपॉइंट** के लिए जावा हुकिंग को ठीक किया गया था जिसका उपयोग तब किया जाता है जब ऐप्स को Android 14 पर `--enable-optimizations` के साथ संकलित किया जाता है।

उदाहरण: `RegisterNatives` के माध्यम से पंजीकृत सभी फ़ंक्शंस को सूचीबद्ध करना और रनटाइम पर उनके पते को डंप करना:
```javascript
Java.perform(function () {
var Runtime = Java.use('java.lang.Runtime');
var register = Module.findExportByName(null, 'RegisterNatives');
Interceptor.attach(register, {
onEnter(args) {
var envPtr  = args[0];
var clazz   = Java.cast(args[1], Java.use('java.lang.Class'));
var methods = args[2];
var count   = args[3].toInt32();
console.log('[+] RegisterNatives on ' + clazz.getName() + ' -> ' + count + ' methods');
// iterate & dump (JNI nativeMethod struct: name, sig, fnPtr)
}
});
});
```
Frida PAC/BTI-सक्षम उपकरणों (Pixel 8/Android 14+) पर बिना किसी समस्या के काम करेगा, जब तक आप frida-server 16.2 या बाद के संस्करण का उपयोग करते हैं - पहले के संस्करण इनलाइन हुक के लिए पैडिंग का पता लगाने में विफल रहे।  citeturn5search2turn5search0

---

### APKs में शिकार करने के लिए हाल की कमजोरियाँ

| वर्ष | CVE | प्रभावित पुस्तकालय | नोट्स |
|------|-----|------------------|-------|
|2023|CVE-2023-4863|`libwebp` ≤ 1.3.1|हीप बफर ओवरफ्लो जो उस नेटीव कोड से पहुंच योग्य है जो WebP छवियों को डिकोड करता है। कई Android ऐप्स कमजोर संस्करणों के साथ आते हैं। जब आप एक APK के अंदर `libwebp.so` देखते हैं, तो इसके संस्करण की जांच करें और शोषण या पैचिंग का प्रयास करें।| citeturn2search0|
|2024|कई|OpenSSL 3.x श्रृंखला|कई मेमोरी-सुरक्षा और पैडिंग-ओरैकल मुद्दे। कई Flutter & ReactNative बंडल अपने स्वयं के `libcrypto.so` के साथ आते हैं।|

जब आप एक APK के अंदर *तीसरे पक्ष* के `.so` फ़ाइलें देखते हैं, तो हमेशा उनके हैश को अपस्ट्रीम सलाहों के खिलाफ क्रॉस-चेक करें। SCA (सॉफ़्टवेयर कंपोज़िशन एनालिसिस) मोबाइल पर असामान्य है, इसलिए पुरानी कमजोर बिल्डें प्रचुर मात्रा में हैं।

---

### एंटी-रिवर्सिंग और हार्डनिंग प्रवृत्तियाँ (Android 13-15)

* **पॉइंटर ऑथेंटिकेशन (PAC) और ब्रांच टारगेट आइडेंटिफिकेशन (BTI):** Android 14 समर्थित ARMv8.3+ सिलिकॉन पर सिस्टम पुस्तकालयों में PAC/BTI सक्षम करता है। डिकंपाइलर्स अब PAC-संबंधित छद्म-निर्देश प्रदर्शित करते हैं; गतिशील विश्लेषण के लिए Frida PAC को स्ट्रिप करने के *बाद* ट्रैम्पोलिन इंजेक्ट करता है, लेकिन आपके कस्टम ट्रैम्पोलिन को आवश्यकतानुसार `pacda`/`autibsp` को कॉल करना चाहिए।
* **MTE और Scudo हार्डन किया गया आवंटक:** मेमोरी-टैगिंग ऑप्ट-इन है लेकिन कई Play-Integrity जागरूक ऐप्स `-fsanitize=memtag` के साथ बनते हैं; टैग दोषों को कैप्चर करने के लिए `setprop arm64.memtag.dump 1` और `adb shell am start ...` का उपयोग करें।
* **LLVM ओबफस्केटर (अस्पष्ट पूर्वधारणाएँ, नियंत्रण-प्रवाह समतलन):** व्यावसायिक पैकर (जैसे, Bangcle, SecNeo) बढ़ती हुई मात्रा में *नेटीव* कोड की सुरक्षा करते हैं, केवल Java नहीं; `.rodata` में गलत नियंत्रण-प्रवाह और एन्क्रिप्टेड स्ट्रिंग ब्लॉब की अपेक्षा करें।

---

### संसाधन

- **ARM असेंबली सीखना:** [Azeria Labs – ARM Assembly Basics](https://azeria-labs.com/writing-arm-assembly-part-1/)
- **JNI और NDK दस्तावेज़ीकरण:** [Oracle JNI Spec](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html) · [Android JNI Tips](https://developer.android.com/training/articles/perf-jni) · [NDK Guides](https://developer.android.com/ndk/guides/)
- **नेटीव पुस्तकालयों का डिबगिंग:** [JEB डिकंपाइलर का उपयोग करके Android नेटीव पुस्तकालयों का डिबगिंग](https://medium.com/@shubhamsonani/how-to-debug-android-native-libraries-using-jeb-decompiler-eec681a22cf3)

### संदर्भ

- Frida 16.x परिवर्तन-लॉग (Android हुकिंग, छोटे-फंक्शन पुनर्स्थान) – [frida.re/news](https://frida.re/news/)  citeturn5search0
- `libwebp` ओवरफ्लो CVE-2023-4863 के लिए NVD सलाह – [nvd.nist.gov](https://nvd.nist.gov/vuln/detail/CVE-2023-4863) citeturn2search0

{{#include ../../banners/hacktricks-training.md}}
