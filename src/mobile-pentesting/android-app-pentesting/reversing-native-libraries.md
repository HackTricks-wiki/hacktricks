# Reversão de Bibliotecas Nativas

{{#include ../../banners/hacktricks-training.md}}


**Para mais informações consulte:** [**https://maddiestone.github.io/AndroidAppRE/reversing_native_libs.html**](https://maddiestone.github.io/AndroidAppRE/reversing_native_libs.html)

Apps Android podem usar bibliotecas nativas, tipicamente escritas em C ou C++, para tarefas críticas de desempenho. Criadores de malware também abusam dessas bibliotecas porque ELF shared objects ainda são mais difíceis de decompilar do que byte-code DEX/OAT.
Esta página foca em fluxos de trabalho *práticos* e em melhorias recentes de tooling (2023-2025) que tornam a reversão de arquivos `.so` do Android mais fácil.

---

### Fluxo rápido de triagem para um `libfoo.so` recém-extraído

1. **Extrair a biblioteca**
```bash
# From an installed application
adb shell "run-as <pkg> cat lib/arm64-v8a/libfoo.so" > libfoo.so
# Or from the APK (zip)
unzip -j target.apk "lib/*/libfoo.so" -d extracted_libs/
```
2. **Identificar arquitetura e proteções**
```bash
file libfoo.so        # arm64 or arm32 / x86
readelf -h libfoo.so  # OS ABI, PIE, NX, RELRO, etc.
checksec --file libfoo.so  # (peda/pwntools)
```
3. **Listar símbolos exportados e bindings JNI**
```bash
readelf -s libfoo.so | grep ' Java_'     # dynamic-linked JNI
strings libfoo.so   | grep -i "RegisterNatives" -n   # static-registered JNI
```
4. **Carregar em um decompilador** (Ghidra ≥ 11.0, IDA Pro, Binary Ninja, Hopper or Cutter/Rizin) e executar a análise automática.
Versões mais recentes do Ghidra introduziram um decompilador AArch64 que reconhece stubs PAC/BTI e tags MTE, melhorando bastante a análise de bibliotecas compiladas com o Android 14 NDK.
5. **Decida entre reversing estático vs dinâmico:** código stripped ou ofuscado frequentemente precisa de *instrumentation* (Frida, ptrace/gdbserver, LLDB).

---

### Instrumentação Dinâmica (Frida ≥ 16)

A série 16 do Frida trouxe várias melhorias específicas para Android que ajudam quando o alvo usa otimizações modernas do Clang/LLD:

* `thumb-relocator` agora pode *hook tiny ARM/Thumb functions* geradas pelo alinhamento agressivo do LLD (`--icf=all`).
* Enumeração e rebinding de *ELF import slots* funciona no Android, permitindo patching por módulo com `dlopen()`/`dlsym()` quando inline hooks são rejeitados.
* Java hooking foi corrigido para o novo **ART quick-entrypoint** usado quando apps são compilados com `--enable-optimizations` no Android 14.

Exemplo: enumerar todas as funções registradas via `RegisterNatives` e despejar seus endereços em tempo de execução:
```javascript
Java.perform(function () {
var Runtime = Java.use('java.lang.Runtime');
var register = Module.findExportByName(null, 'RegisterNatives');
Interceptor.attach(register, {
onEnter(args) {
var envPtr  = args[0];
var clazz   = Java.cast(args[1], Java.use('java.lang.Class'));
var methods = args[2];
var count   = args[3].toInt32();
console.log('[+] RegisterNatives on ' + clazz.getName() + ' -> ' + count + ' methods');
// iterate & dump (JNI nativeMethod struct: name, sig, fnPtr)
}
});
});
```
Frida will work out of the box on PAC/BTI-enabled devices (Pixel 8/Android 14+) as long as you use frida-server 16.2 or later – earlier versions failed to locate padding for inline hooks.

### Telemetria JNI local ao processo via .so pré-carregado (SoTap)

Quando instrumentação completa é exagerada ou bloqueada, você ainda pode obter visibilidade em nível nativo pré-carregando um pequeno logger dentro do processo alvo. SoTap é uma biblioteca nativa Android leve (.so) que registra o comportamento em tempo de execução de outras bibliotecas JNI (.so) dentro do mesmo processo do app (não requer root).

Propriedades principais:
- Inicializa cedo e observa interações JNI/nativas dentro do processo que a carrega.
- Persiste logs usando múltiplos caminhos graváveis com fallback elegante para Logcat quando o armazenamento é restrito.
- Personalizável no código-fonte: edite sotap.c para estender/ajustar o que é registrado e reconstrua por ABI.

Configuração (reempacotar o APK):
1) Coloque a build para a ABI correta dentro do APK para que o loader consiga resolver libsotap.so:
- lib/arm64-v8a/libsotap.so (for arm64)
- lib/armeabi-v7a/libsotap.so (for arm32)
2) Assegure que SoTap seja carregado antes de outras libs JNI. Injete uma chamada cedo (por exemplo, no inicializador estático de uma subclasse de Application ou onCreate) para que o logger seja inicializado primeiro. Exemplo de snippet Smali:
```smali
const-string v0, "sotap"
invoke-static {v0}, Ljava/lang/System;->loadLibrary(Ljava/lang/String;)V
```
3) Reconstrua/assine/instale, execute o app e então colete os logs.

Caminhos de log (verificados na ordem):
```
/data/user/0/%s/files/sotap.log
/data/data/%s/files/sotap.log
/sdcard/Android/data/%s/files/sotap.log
/sdcard/Download/sotap-%s.log
# If all fail: fallback to Logcat only
```
Notes and troubleshooting:
- Alinhamento da ABI é obrigatório. Uma incompatibilidade causará um UnsatisfiedLinkError e o logger não será carregado.
- Restrições de armazenamento são comuns em Android modernos; se gravações de arquivo falharem, SoTap ainda emitirá via Logcat.
- Comportamento/verbosidade devem ser customizados; reconstrua a partir do código-fonte após editar sotap.c.

Esta abordagem é útil para triagem de malware e depuração JNI quando observar fluxos de chamadas nativas desde o início do processo é crítico, mas hooks root/system-wide não estão disponíveis.

---

### Recent vulnerabilities worth hunting for in APKs

| Year | CVE | Affected library | Notes |
|------|-----|------------------|-------|
|2023|CVE-2023-4863|`libwebp` ≤ 1.3.1|Overflow de buffer no heap alcançável a partir de código nativo que decodifica imagens WebP. Vários apps Android empacotam versões vulneráveis. Quando você encontrar um `libwebp.so` dentro de um APK, verifique sua versão e tente exploração ou patching.| |
|2024|Multiple|OpenSSL 3.x series|Várias questões de segurança de memória e padding-oracle. Muitos bundles Flutter & ReactNative incluem seu próprio `libcrypto.so`.|

Quando você spotar arquivos `.so` *de terceiros* dentro de um APK, sempre verifique o hash contra advisories upstream. SCA (Software Composition Analysis) é incomum em mobile, então builds desatualizados e vulneráveis são comuns.

---

### Anti-Reversing & Hardening trends (Android 13-15)

* **Pointer Authentication (PAC) & Branch Target Identification (BTI):** Android 14 habilita PAC/BTI em bibliotecas do sistema em silício ARMv8.3+ suportado. Decompilers agora exibem pseudo-instruções relacionadas a PAC; para análise dinâmica o Frida injeta trampolines *after* stripping PAC, mas seus trampolines customizados devem chamar `pacda`/`autibsp` quando necessário.
* **MTE & Scudo hardened allocator:** memory-tagging é opt-in, mas muitos apps com Play-Integrity são compilados com `-fsanitize=memtag`; use `setprop arm64.memtag.dump 1` plus `adb shell am start ...` para capturar tag faults.
* **LLVM Obfuscator (opaque predicates, control-flow flattening):** packers comerciais (e.g., Bangcle, SecNeo) protegem cada vez mais o código *nativo*, não só Java; espere control-flow falso e blobs de strings criptografadas em `.rodata`.

---

### Resources

- **Aprendendo ARM Assembly:** [Azeria Labs – ARM Assembly Basics](https://azeria-labs.com/writing-arm-assembly-part-1/)
- **Documentação JNI & NDK:** [Oracle JNI Spec](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html) · [Android JNI Tips](https://developer.android.com/training/articles/perf-jni) · [NDK Guides](https://developer.android.com/ndk/guides/)
- **Depuração de bibliotecas nativas:** [Debug Android Native Libraries Using JEB Decompiler](https://medium.com/@shubhamsonani/how-to-debug-android-native-libraries-using-jeb-decompiler-eec681a22cf3)

### References

- Changelog do Frida 16.x (Android hooking, tiny-function relocation) – [frida.re/news](https://frida.re/news/)
- Aviso NVD para `libwebp` overflow CVE-2023-4863 – [nvd.nist.gov](https://nvd.nist.gov/vuln/detail/CVE-2023-4863)
- SoTap: Logger leve in-app de comportamento JNI (.so) – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- Releases do SoTap – [github.com/RezaArbabBot/SoTap/releases](https://github.com/RezaArbabBot/SoTap/releases)
- Como trabalhar com SoTap? – [t.me/ForYouTillEnd/13](https://t.me/ForYouTillEnd/13)

{{#include ../../banners/hacktricks-training.md}}
