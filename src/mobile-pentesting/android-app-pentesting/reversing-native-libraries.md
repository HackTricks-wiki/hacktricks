# Reversing Native Libraries

{{#include ../../banners/hacktricks-training.md}}


**For further information check:** [**https://maddiestone.github.io/AndroidAppRE/reversing_native_libs.html**](https://maddiestone.github.io/AndroidAppRE/reversing_native_libs.html)

Οι Android εφαρμογές μπορούν να χρησιμοποιούν native libraries, συνήθως γραμμένες σε C ή C++, για εργασίες κρίσιμες στην απόδοση. Οι δημιουργοί malware επίσης καταχρώνται αυτές τις βιβλιοθήκες επειδή τα ELF shared objects εξακολουθούν να είναι πιο δύσκολα στην decompile σε σχέση με το DEX/OAT byte-code.
Αυτή η σελίδα εστιάζει σε *πρακτικές* ροές εργασίας και σε *πρόσφατες* βελτιώσεις εργαλείων (2023-2025) που καθιστούν την ανάλυση των Android `.so` αρχείων ευκολότερη.

---

### Quick triage-workflow for a freshly pulled `libfoo.so`

1. **Extract the library**
```bash
# From an installed application
adb shell "run-as <pkg> cat lib/arm64-v8a/libfoo.so" > libfoo.so
# Or from the APK (zip)
unzip -j target.apk "lib/*/libfoo.so" -d extracted_libs/
```
2. **Identify architecture & protections**
```bash
file libfoo.so        # arm64 or arm32 / x86
readelf -h libfoo.so  # OS ABI, PIE, NX, RELRO, etc.
checksec --file libfoo.so  # (peda/pwntools)
```
3. **List exported symbols & JNI bindings**
```bash
readelf -s libfoo.so | grep ' Java_'     # dynamic-linked JNI
strings libfoo.so   | grep -i "RegisterNatives" -n   # static-registered JNI
```
4. **Load in a decompiler** (Ghidra ≥ 11.0, IDA Pro, Binary Ninja, Hopper or Cutter/Rizin) and run auto-analysis.
Οι νεότερες εκδόσεις του Ghidra εισήγαγαν έναν AArch64 decompiler που αναγνωρίζει PAC/BTI stubs και MTE tags, βελτιώνοντας σημαντικά την ανάλυση βιβλιοθηκών που χτίστηκαν με το Android 14 NDK.
5. **Decide on static vs dynamic reversing:** το stripped, obfuscated code συχνά χρειάζεται *instrumentation* (Frida, ptrace/gdbserver, LLDB).

---

### Dynamic Instrumentation (Frida ≥ 16)

Η σειρά 16 του Frida έφερε αρκετές βελτιώσεις ειδικές για Android που βοηθούν όταν ο στόχος χρησιμοποιεί σύγχρονες βελτιστοποιήσεις Clang/LLD:

* `thumb-relocator` can now *hook tiny ARM/Thumb functions* generated by LLD’s aggressive alignment (`--icf=all`).
* Enumerating and rebinding *ELF import slots* works on Android, enabling per-module `dlopen()`/`dlsym()` patching when inline hooks are rejected.
* Java hooking was fixed for the new **ART quick-entrypoint** used when apps are compiled with `--enable-optimizations` on Android 14.

Example: enumerating all functions registered through `RegisterNatives` and dumping their addresses at runtime:
```javascript
Java.perform(function () {
var Runtime = Java.use('java.lang.Runtime');
var register = Module.findExportByName(null, 'RegisterNatives');
Interceptor.attach(register, {
onEnter(args) {
var envPtr  = args[0];
var clazz   = Java.cast(args[1], Java.use('java.lang.Class'));
var methods = args[2];
var count   = args[3].toInt32();
console.log('[+] RegisterNatives on ' + clazz.getName() + ' -> ' + count + ' methods');
// iterate & dump (JNI nativeMethod struct: name, sig, fnPtr)
}
});
});
```
Frida will work out of the box on PAC/BTI-enabled devices (Pixel 8/Android 14+) as long as you use frida-server 16.2 or later – earlier versions failed to locate padding for inline hooks.

### Τηλεμετρία JNI τοπική στη διαδικασία μέσω προφορτωμένου .so (SoTap)

Όταν η πλήρης instrumentation είναι υπερβολική ή μπλοκαρισμένη, μπορείτε ακόμα να αποκτήσετε ορατότητα σε native επίπεδο προφορτώνοντας έναν μικρό logger μέσα στη στοχευόμενη διαδικασία. SoTap είναι μια ελαφριά Android native (.so) βιβλιοθήκη που καταγράφει τη συμπεριφορά κατά το runtime άλλων JNI (.so) βιβλιοθηκών μέσα στην ίδια app process (no root required).

Κύρια χαρακτηριστικά:
- Εκκινεί νωρίς και παρατηρεί τις JNI/native αλληλεπιδράσεις μέσα στη διαδικασία που το φορτώνει.
- Διατηρεί τα logs χρησιμοποιώντας πολλαπλές εγγράψιμες διαδρομές με ομαλή επιστροφή στο Logcat όταν ο αποθηκευτικός χώρος είναι περιορισμένος.
- Source-customizable: επεξεργαστείτε το sotap.c για να επεκτείνετε/προσαρμόσετε τι καταγράφεται και κάντε rebuild ανά ABI.

Ρύθμιση (repack the APK):
1) Τοποθετήστε το κατάλληλο ABI build μέσα στο APK ώστε ο loader να μπορεί να επιλύσει libsotap.so:
- lib/arm64-v8a/libsotap.so (for arm64)
- lib/armeabi-v7a/libsotap.so (for arm32)
2) Βεβαιωθείτε ότι το SoTap φορτώνεται πριν από άλλες JNI libs. Εισάγετε μια κλήση νωρίς (π.χ., Application subclass static initializer ή onCreate) ώστε ο logger να αρχικοποιηθεί πρώτος. Smali snippet example:
```smali
const-string v0, "sotap"
invoke-static {v0}, Ljava/lang/System;->loadLibrary(Ljava/lang/String;)V
```
3) Κάντε rebuild/sign/install, τρέξτε την εφαρμογή, και στη συνέχεια συλλέξτε τα logs.

Log paths (checked in order):
```
/data/user/0/%s/files/sotap.log
/data/data/%s/files/sotap.log
/sdcard/Android/data/%s/files/sotap.log
/sdcard/Download/sotap-%s.log
# If all fail: fallback to Logcat only
```
Σημειώσεις και αντιμετώπιση προβλημάτων:
- ABI alignment είναι υποχρεωτική. Μη αντιστοιχία θα προκαλέσει UnsatisfiedLinkError και ο logger δεν θα φορτωθεί.
- Περιορισμοί αποθηκευτικού χώρου είναι συνηθισμένοι σε σύγχρονα Android· αν οι εγγραφές αρχείων αποτύχουν, το SoTap θα εξακολουθήσει να εκπέμπει μέσω Logcat.
- Η συμπεριφορά/επίπεδο λεπτομέρειας προορίζεται για προσαρμογή· αναδημιουργήστε από τον πηγαίο κώδικα μετά την επεξεργασία του sotap.c.

Αυτή η προσέγγιση είναι χρήσιμη για malware triage και JNI debugging όπου η παρατήρηση των native call flows από την εκκίνηση της διεργασίας είναι κρίσιμη αλλά root/system-wide hooks δεν είναι διαθέσιμα.

---

### Πρόσφατες ευπάθειες που αξίζει να αναζητήσετε σε APKs

| Έτος | CVE | Επηρεαζόμενη βιβλιοθήκη | Σημειώσεις |
|------|-----|------------------|-------|
|2023|CVE-2023-4863|`libwebp` ≤ 1.3.1|Heap buffer overflow προσβάσιμος από native code που αποκωδικοποιεί εικόνες WebP. Πολλές εφαρμογές Android συνοδεύουν ευπαθείς εκδόσεις. Όταν δείτε ένα `libwebp.so` μέσα σε ένα APK, ελέγξτε την έκδοσή του και δοκιμάστε εκμετάλλευση ή επιδιόρθωση.| |
|2024|Multiple|OpenSSL 3.x series|Πολλά ζητήματα memory-safety και padding-oracle. Πολλά Flutter & ReactNative bundles περιλαμβάνουν το δικό τους `libcrypto.so`.|

Όταν εντοπίσετε *third-party* `.so` αρχεία μέσα σε ένα APK, πάντα συγκρίνετε το hash τους με upstream advisories. Η SCA (Software Composition Analysis) είναι ασυνήθιστη στο mobile, οπότε παλιές ευπαθείς builds είναι διαδεδομένες.

---

### Anti-Reversing & Hardening τάσεις (Android 13-15)

* **Pointer Authentication (PAC) & Branch Target Identification (BTI):** Το Android 14 ενεργοποιεί PAC/BTI στις system libraries σε υποστηριζόμενο silicon ARMv8.3+. Οι decompilers τώρα εμφανίζουν PAC‐related pseudo-instructions· για dynamic analysis το Frida εισάγει trampolines *after* stripping PAC, αλλά τα custom trampolines σας πρέπει να καλούν `pacda`/`autibsp` όπου χρειάζεται.
* **MTE & Scudo hardened allocator:** memory-tagging είναι opt-in αλλά πολλές Play-Integrity aware εφαρμογές χτίζονται με `-fsanitize=memtag`; χρησιμοποιήστε `setprop arm64.memtag.dump 1` plus `adb shell am start ...` για να συλλάβετε tag faults.
* **LLVM Obfuscator (opaque predicates, control-flow flattening):** commercial packers (e.g., Bangcle, SecNeo) όλο και περισσότερο προστατεύουν το *native* code, όχι μόνο Java· αναμένετε bogus control-flow και encrypted string blobs στο `.rodata`.

---

### Πόροι

- **Learning ARM Assembly:** [Azeria Labs – ARM Assembly Basics](https://azeria-labs.com/writing-arm-assembly-part-1/)
- **JNI & NDK Documentation:** [Oracle JNI Spec](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html) · [Android JNI Tips](https://developer.android.com/training/articles/perf-jni) · [NDK Guides](https://developer.android.com/ndk/guides/)
- **Debugging Native Libraries:** [Debug Android Native Libraries Using JEB Decompiler](https://medium.com/@shubhamsonani/how-to-debug-android-native-libraries-using-jeb-decompiler-eec681a22cf3)

### Αναφορές

- Frida 16.x change-log (Android hooking, tiny-function relocation) – [frida.re/news](https://frida.re/news/)
- NVD advisory for `libwebp` overflow CVE-2023-4863 – [nvd.nist.gov](https://nvd.nist.gov/vuln/detail/CVE-2023-4863)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- SoTap Releases – [github.com/RezaArbabBot/SoTap/releases](https://github.com/RezaArbabBot/SoTap/releases)
- How to work with SoTap? – [t.me/ForYouTillEnd/13](https://t.me/ForYouTillEnd/13)

{{#include ../../banners/hacktricks-training.md}}
