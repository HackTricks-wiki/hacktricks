# Reverzovanje native biblioteka

{{#include ../../banners/hacktricks-training.md}}


**Za više informacija pogledajte:** [**https://maddiestone.github.io/AndroidAppRE/reversing_native_libs.html**](https://maddiestone.github.io/AndroidAppRE/reversing_native_libs.html)

Android aplikacije mogu koristiti native biblioteke, obično napisane u C ili C++, za zadatke koji zahtevaju visoke performanse. Autori malware-a takođe zloupotrebljavaju ove biblioteke jer su ELF shared objects i dalje teže dekompajlirati nego DEX/OAT bajtkod.
Ova stranica se fokusira na *praktične* radne tokove i *najnovija* poboljšanja alata (2023–2025) koja olakšavaju reverzovanje Android `.so` fajlova.

---

### Brzi trijažni workflow za sveže izvučenu `libfoo.so`

1. **Ekstrahujte biblioteku**
```bash
# From an installed application
adb shell "run-as <pkg> cat lib/arm64-v8a/libfoo.so" > libfoo.so
# Or from the APK (zip)
unzip -j target.apk "lib/*/libfoo.so" -d extracted_libs/
```
2. **Identifikujte arhitekturu i zaštite**
```bash
file libfoo.so        # arm64 or arm32 / x86
readelf -h libfoo.so  # OS ABI, PIE, NX, RELRO, etc.
checksec --file libfoo.so  # (peda/pwntools)
```
3. **Navedite eksportovane simbole i JNI vezivanja**
```bash
readelf -s libfoo.so | grep ' Java_'     # dynamic-linked JNI
strings libfoo.so   | grep -i "RegisterNatives" -n   # static-registered JNI
```
4. **Učitajte u dekompajler** (Ghidra ≥ 11.0, IDA Pro, Binary Ninja, Hopper or Cutter/Rizin) i pokrenite auto-analizu.
Novije Ghidra verzije uvele su AArch64 dekompajler koji prepoznaje PAC/BTI stubove i MTE tagove, značajno poboljšavajući analizu biblioteka izgrađenih pomoću Android 14 NDK-a.
5. **Odlučite za statičko ili dinamičko reverzovanje:** stripped, obfuscated kod često zahteva *instrumentation* (Frida, ptrace/gdbserver, LLDB).

---

### Dinamička instrumentacija (Frida ≥ 16)

Frida serija 16 donela je nekoliko Android-specifičnih poboljšanja koja pomažu kada cilj koristi moderne Clang/LLD optimizacije:

* `thumb-relocator` može sada *hook-ovati male ARM/Thumb funkcije* generisane agresivnim poravnanjem LLD-a (`--icf=all`).
* Enumerisanje i ponovno vezivanje *ELF import slots* radi na Androidu, omogućavajući per-module `dlopen()`/`dlsym()` patching kada inline hooks budu odbijeni.
* Java hooking je ispravljen za novi **ART quick-entrypoint** koji se koristi kada su aplikacije kompajlirane sa `--enable-optimizations` na Android 14.

Primer: nabrajanje svih funkcija registrovanih preko `RegisterNatives` i ispis njihovih adresa u runtime-u:
```javascript
Java.perform(function () {
var Runtime = Java.use('java.lang.Runtime');
var register = Module.findExportByName(null, 'RegisterNatives');
Interceptor.attach(register, {
onEnter(args) {
var envPtr  = args[0];
var clazz   = Java.cast(args[1], Java.use('java.lang.Class'));
var methods = args[2];
var count   = args[3].toInt32();
console.log('[+] RegisterNatives on ' + clazz.getName() + ' -> ' + count + ' methods');
// iterate & dump (JNI nativeMethod struct: name, sig, fnPtr)
}
});
});
```
Frida will work out of the box on PAC/BTI-enabled devices (Pixel 8/Android 14+) as long as you use frida-server 16.2 or later – earlier versions failed to locate padding for inline hooks.

### Telemetrija JNI-a lokalnog procesa putem prethodno učitanog .so (SoTap)

Kada je puna instrumentacija suvišna ili blokirana, i dalje možete dobiti uvid na native nivou tako što ćete prethodno učitati mali logger unutar ciljnog procesa. SoTap je lagana Android native (.so) biblioteka koja beleži runtime ponašanje drugih JNI (.so) biblioteka unutar istog app procesa (root nije potreban).

Ključna svojstva:
- Inicijalizuje se rano i posmatra JNI/native interakcije unutar procesa koji je učitava.
- Čuva logove koristeći više putanja za pisanje uz povratak na Logcat kada je skladište ograničeno.
- Source-customizable: edit sotap.c to extend/adjust what gets logged and rebuild per ABI.

Podešavanje (repack the APK):
1) Ubacite odgovarajući ABI build u APK tako da loader može da pronađe libsotap.so:
- lib/arm64-v8a/libsotap.so (for arm64)
- lib/armeabi-v7a/libsotap.so (for arm32)
2) Osigurajte da se SoTap učita pre ostalih JNI biblioteka. Inject a call early (e.g., Application subclass static initializer or onCreate) tako da je logger inicijalizovan prvi. Smali snippet example:
```smali
const-string v0, "sotap"
invoke-static {v0}, Ljava/lang/System;->loadLibrary(Ljava/lang/String;)V
```
3) Ponovno izgradite/potpišite/instalirajte, pokrenite app, pa prikupite logove.

Putanje logova (proveravaju se redom):
```
/data/user/0/%s/files/sotap.log
/data/data/%s/files/sotap.log
/sdcard/Android/data/%s/files/sotap.log
/sdcard/Download/sotap-%s.log
# If all fail: fallback to Logcat only
```
Beleške i rešavanje problema:
- ABI poravnanje je obavezno. Neusklađenost će izazvati UnsatisfiedLinkError i logger se neće učitati.
- Ograničenja prostora za skladištenje su česta na modernim Android uređajima; ako upis fajlova ne uspe, SoTap će i dalje emitovati preko Logcat.
- Ponašanje/verbosnost je predviđeno da se prilagodi; ponovo izgradite iz izvornog koda nakon izmena u sotap.c.

Ovakav pristup je koristan za malware triage i JNI debugging gde je ključno posmatrati tokove poziva native koda od starta procesa, a root/system-wide hookovi nisu dostupni.

---

### Nedavne ranjivosti vredne potrage u APK-ovima

| Godina | CVE | Pogođena biblioteka | Napomene |
|------|-----|------------------|-------|
|2023|CVE-2023-4863|`libwebp` ≤ 1.3.1|Heap buffer overflow reachable from native code that decodes WebP images. Several Android apps bundle vulnerable versions. When you see a `libwebp.so` inside an APK, check its version and attempt exploitation or patching.| |
|2024|Multiple|OpenSSL 3.x series|Several memory-safety and padding-oracle issues. Many Flutter & ReactNative bundles ship their own `libcrypto.so`.|

Kada primetite *trećih strana* `.so` fajlove unutar APK-a, uvek proverite njihov hash sa upstream advisories. SCA (Software Composition Analysis) je retka na mobilu, pa su zastarele i ranjive verzije raširene.

---

### Trendovi Anti-Reversinga i ojačavanja (Android 13-15)

* **Pointer Authentication (PAC) & Branch Target Identification (BTI):** Android 14 omogućava PAC/BTI u system libraries na podržanom ARMv8.3+ silikonu. Decompiler-i sada prikazuju PAC‐povezane pseudo-instrukcije; za dynamic analysis Frida injektuje trampoline *nakon* uklanjanja PAC, ali vaši custom trampolini treba da pozivaju `pacda`/`autibsp` gde je potrebno.
* **MTE & Scudo hardened allocator:** memory-tagging je opciono, ali mnoge aplikacije svesne Play-Integrity grade se sa `-fsanitize=memtag`; koristite `setprop arm64.memtag.dump 1` plus `adb shell am start ...` da zabeležite tag faults.
* **LLVM Obfuscator (opaque predicates, control-flow flattening):** komercijalni packeri (npr. Bangcle, SecNeo) sve češće štite *native* kod, ne samo Java; očekujte lažni control-flow i enkriptovane string blobove u `.rodata`.

---

### Resources

- **Učenje ARM asemblera:** [Azeria Labs – ARM Assembly Basics](https://azeria-labs.com/writing-arm-assembly-part-1/)
- **JNI & NDK dokumentacija:** [Oracle JNI Spec](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html) · [Android JNI Tips](https://developer.android.com/training/articles/perf-jni) · [NDK Guides](https://developer.android.com/ndk/guides/)
- **Debugovanje native biblioteka:** [Debug Android Native Libraries Using JEB Decompiler](https://medium.com/@shubhamsonani/how-to-debug-android-native-libraries-using-jeb-decompiler-eec681a22cf3)

### Reference

- Frida 16.x change-log (Android hooking, tiny-function relocation) – [frida.re/news](https://frida.re/news/)
- NVD advisory za `libwebp` overflow CVE-2023-4863 – [nvd.nist.gov](https://nvd.nist.gov/vuln/detail/CVE-2023-4863)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- SoTap Releases – [github.com/RezaArbabBot/SoTap/releases](https://github.com/RezaArbabBot/SoTap/releases)
- Kako raditi sa SoTap? – [t.me/ForYouTillEnd/13](https://t.me/ForYouTillEnd/13)

{{#include ../../banners/hacktricks-training.md}}
