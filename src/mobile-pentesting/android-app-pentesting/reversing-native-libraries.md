# Omgekeerde ingenieurswese van inheemse biblioteke

{{#include ../../banners/hacktricks-training.md}}


**Vir verdere inligting, kyk:** [**https://maddiestone.github.io/AndroidAppRE/reversing_native_libs.html**](https://maddiestone.github.io/AndroidAppRE/reversing_native_libs.html)

Android-apps kan inheemse biblioteke gebruik, gewoonlik geskryf in C of C++, vir prestasie-kritiese take. Malware-skepper misbruik ook hierdie biblioteke omdat ELF shared objects steeds moeiliker is om te dekompileer as DEX/OAT byte-code.
Hierdie blad fokus op *praktykgebaseerde* werkvloei en *onlangse* gereedskapverbeterings (2023-2025) wat die reversing van Android `.so`-lêers makliker maak.

---

### Vinnige triage-werkvloei vir 'n pas onttrekte `libfoo.so`

1. **Onttrek die biblioteek**
```bash
# From an installed application
adb shell "run-as <pkg> cat lib/arm64-v8a/libfoo.so" > libfoo.so
# Or from the APK (zip)
unzip -j target.apk "lib/*/libfoo.so" -d extracted_libs/
```
2. **Identifiseer argitektuur & beskermings**
```bash
file libfoo.so        # arm64 or arm32 / x86
readelf -h libfoo.so  # OS ABI, PIE, NX, RELRO, etc.
checksec --file libfoo.so  # (peda/pwntools)
```
3. **Lys uitgevoerde simbole & JNI-koppellings**
```bash
readelf -s libfoo.so | grep ' Java_'     # dynamic-linked JNI
strings libfoo.so   | grep -i "RegisterNatives" -n   # static-registered JNI
```
4. **Laai in 'n dekompiler** (Ghidra ≥ 11.0, IDA Pro, Binary Ninja, Hopper or Cutter/Rizin) en voer outo-analise uit.
Nuweer Ghidra-weergawes het 'n AArch64-dekompiler ingestel wat PAC/BTI-stubs en MTE-tags herken, wat die analise van biblioteke gebou met die Android 14 NDK baie verbeter.
5. **Besluit staties vs dinamies reverse:** gestrippe, obfuskeer kode benodig dikwels *instrumentation* (Frida, ptrace/gdbserver, LLDB).

---

### Dynamiese Instrumentasie (Frida ≥ 16)

Frida’s 16-reeks het verskeie Android-spesifieke verbeterings gebring wat help wanneer die teiken moderne Clang/LLD optimisasies gebruik:

* `thumb-relocator` kan nou *hook klein ARM/Thumb-funksies* wat deur LLD se aggressiewe uitlyning gegenereer is (`--icf=all`).
* Enumerering en herbinding van *ELF import slots* werk op Android, wat per-module `dlopen()`/`dlsym()` patching moontlik maak wanneer inline hooks verwerp word.
* Java hooking is reggestel vir die nuwe **ART quick-entrypoint** wat gebruik word wanneer apps saamgestel is met `--enable-optimizations` op Android 14.

Voorbeeld: enumerering van alle funksies geregistreer deur `RegisterNatives` en die uitgooi van hul adresse by runtime:
```javascript
Java.perform(function () {
var Runtime = Java.use('java.lang.Runtime');
var register = Module.findExportByName(null, 'RegisterNatives');
Interceptor.attach(register, {
onEnter(args) {
var envPtr  = args[0];
var clazz   = Java.cast(args[1], Java.use('java.lang.Class'));
var methods = args[2];
var count   = args[3].toInt32();
console.log('[+] RegisterNatives on ' + clazz.getName() + ' -> ' + count + ' methods');
// iterate & dump (JNI nativeMethod struct: name, sig, fnPtr)
}
});
});
```
Frida sal sonder ekstra konfigurasie werk op PAC/BTI-enabled toestelle (Pixel 8/Android 14+) solank jy frida-server 16.2 of later gebruik – vroeër weergawes het nie padding vir inline hooks kon lokaliseer nie.

### Process-local JNI telemetry via preloaded .so (SoTap)

Wanneer vol-funksionele instrumentation oordrewe of geblokkeer is, kan jy steeds native-vlak sigbaarheid kry deur 'n klein logger vooraf in die teikenproses te laai. SoTap is 'n liggewig Android native (.so) biblioteek wat die runtime-gedrag van ander JNI (.so) biblioteke binne dieselfde app-proses log (geen root benodig).

Belangrike eienskappe:
- Initialiseer vroeg en monitor JNI/native-interaksies binne die proses wat dit laai.
- Stoor logs deur verskeie skryfbare paaie te gebruik, met 'n elegante terugval na Logcat wanneer stoorruimte beperk is.
- Bron-aanpasbaar: wysig sotap.c om uit te brei/aan te pas wat aangeteken word en herbou per ABI.

Opstelling (herpak die APK):
1) Plaas die toepaslike ABI build in die APK sodat die laaier libsotap.so kan oplos:
- lib/arm64-v8a/libsotap.so (for arm64)
- lib/armeabi-v7a/libsotap.so (for arm32)
2) Verseker dat SoTap laai voordat ander JNI libs laai. Injekteer 'n oproep vroeg (bv. Application subclass static initializer of onCreate) sodat die logger eerstens geïnitialiseer word. Smali snippet example:
```smali
const-string v0, "sotap"
invoke-static {v0}, Ljava/lang/System;->loadLibrary(Ljava/lang/String;)V
```
3) Herbou/handteken/installeer, maak die app oop, en versamel dan logs.

Log paths (checked in order):
```
/data/user/0/%s/files/sotap.log
/data/data/%s/files/sotap.log
/sdcard/Android/data/%s/files/sotap.log
/sdcard/Download/sotap-%s.log
# If all fail: fallback to Logcat only
```
Notes en probleemoplossing:
- ABI-belyning is verpligtend. 'n Ongelykheid (mismatch) sal 'n UnsatisfiedLinkError veroorsaak en die logger sal nie laai nie.
- Bergingbeperkings is algemeen op moderne Android; as lêerskryf misluk, sal SoTap steeds via Logcat uitset lewer.
- Gedrag/uitvoerigheid is bedoel om aangepas te word; herbou vanaf die bron nadat jy sotap.c gewysig het.

Hierdie benadering is nuttig vir malware-triage en JNI-debugging waar dit kritiek is om native oproepvloei vanaf die prosesbegin te observeer, maar root/sisteemwye hooks nie beskikbaar is nie.

---

### Sien ook: in‑memory native code execution via JNI

'n Algemene aanvalspatroon is om 'n rou shellcode-blob tydens runtime af te laai en dit direk uit geheue deur 'n JNI-brug uit te voer (geen on‑disk ELF). Details en gereed-vir-gebruik JNI-snippet hier:

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

---

### Onlangse kwesbaarhede wat die moeite werd is om in APKs te soek

| Jaar | CVE | Geaffekteerde biblioteek | Notas |
|------|-----|--------------------------|-------|
|2023|CVE-2023-4863|`libwebp` ≤ 1.3.1|Heap buffer overflow bereikbaar vanaf native kode wat WebP-beelde dekodeer. Verskeie Android-apps pak kwesbare weergawes in. Wanneer jy 'n `libwebp.so` binne 'n APK sien, kontroleer die weergawe en probeer eksploitasie of pleistering.| |
|2024|Multiple|OpenSSL 3.x series|Verskeie geheue-veiligheid- en padding-oracle-kwessies. Baie Flutter- & ReactNative-bundels lewer hul eie `libcrypto.so`.|

Wanneer jy *third-party* `.so`-lêers binne 'n APK raak, kruisverifieer altyd hul hash teen upstream advisories. SCA (Software Composition Analysis) is ongereeld op mobiele toestelle, dus is verouderde kwesbare builds volop.

---

### Anti-Reversing & Hardening-neigings (Android 13–15)

* **Pointer Authentication (PAC) & Branch Target Identification (BTI):** Android 14 aktiveer PAC/BTI in stelselbiblioteke op ondersteunde ARMv8.3+ silikon. Decompilers vertoon nou PAC-verwante pseudo-instruksies; vir dinamiese analise injekteer Frida trampoliene ná die verwydering van PAC, maar jou eie trampoliene behoort `pacda`/`autibsp` aan te roep waar nodig.
* **MTE & Scudo hardened allocator:** Memory-tagging is opsioneel maar baie Play-Integrity-bewuste apps bou met `-fsanitize=memtag`; gebruik `setprop arm64.memtag.dump 1` plus `adb shell am start ...` om tag-foute vas te vang.
* **LLVM Obfuscator (opaque predicates, control-flow flattening):** Kommersiële packers (bv. Bangcle, SecNeo) beskerm toenemend *native* kode, nie net Java nie; verwag vals control-flow en enkripteerde string-blobs in `.rodata`.

---

### Hulpbronne

- **Learning ARM Assembly:** [Azeria Labs – ARM Assembly Basics](https://azeria-labs.com/writing-arm-assembly-part-1/)
- **JNI & NDK Documentation:** [Oracle JNI Spec](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html) · [Android JNI Tips](https://developer.android.com/training/articles/perf-jni) · [NDK Guides](https://developer.android.com/ndk/guides/)
- **Debugging Native Libraries:** [Debug Android Native Libraries Using JEB Decompiler](https://medium.com/@shubhamsonani/how-to-debug-android-native-libraries-using-jeb-decompiler-eec681a22cf3)

### Verwysings

- Frida 16.x change-log (Android hooking, tiny-function relocation) – [frida.re/news](https://frida.re/news/)
- NVD advisory for `libwebp` overflow CVE-2023-4863 – [nvd.nist.gov](https://nvd.nist.gov/vuln/detail/CVE-2023-4863)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- SoTap Releases – [github.com/RezaArbabBot/SoTap/releases](https://github.com/RezaArbabBot/SoTap/releases)
- How to work with SoTap? – [t.me/ForYouTillEnd/13](https://t.me/ForYouTillEnd/13)
- [CoRPhone — JNI memory-only execution pattern and packaging](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
