# Reversão de Bibliotecas Nativas

{{#include ../../banners/hacktricks-training.md}}


**Para mais informações, confira:** [**https://maddiestone.github.io/AndroidAppRE/reversing_native_libs.html**](https://maddiestone.github.io/AndroidAppRE/reversing_native_libs.html)

Aplicativos Android podem usar bibliotecas nativas, tipicamente escritas em C ou C++, para tarefas críticas de desempenho. Criadores de malware também abusam dessas bibliotecas porque ELF shared objects ainda são mais difíceis de decompilar do que byte-code DEX/OAT.
Esta página foca em fluxos de trabalho *práticos* e melhorias recentes de ferramentas (2023-2025) que tornam mais fácil reverter arquivos `.so` do Android.

---

### Fluxo rápido de triagem para um `libfoo.so` recém-extraído

1. **Extrair a biblioteca**
```bash
# From an installed application
adb shell "run-as <pkg> cat lib/arm64-v8a/libfoo.so" > libfoo.so
# Or from the APK (zip)
unzip -j target.apk "lib/*/libfoo.so" -d extracted_libs/
```
2. **Identificar arquitetura & proteções**
```bash
file libfoo.so        # arm64 or arm32 / x86
readelf -h libfoo.so  # OS ABI, PIE, NX, RELRO, etc.
checksec --file libfoo.so  # (peda/pwntools)
```
3. **Listar símbolos exportados & bindings JNI**
```bash
readelf -s libfoo.so | grep ' Java_'     # dynamic-linked JNI
strings libfoo.so   | grep -i "RegisterNatives" -n   # static-registered JNI
```
4. **Carregar em um decompiler** (Ghidra ≥ 11.0, IDA Pro, Binary Ninja, Hopper or Cutter/Rizin) e rodar a análise automática.
Versões mais recentes do Ghidra introduziram um decompiler AArch64 que reconhece PAC/BTI stubs e MTE tags, melhorando bastante a análise de bibliotecas construídas com o NDK do Android 14.
5. **Decidir entre reversing estático vs dinâmico:** código stripped/obfuscado frequentemente precisa de *instrumentation* (Frida, ptrace/gdbserver, LLDB).

---

### Instrumentação Dinâmica (Frida ≥ 16)

A série 16 do Frida trouxe várias melhorias específicas para Android que ajudam quando o alvo usa otimizações modernas do Clang/LLD:

* `thumb-relocator` agora pode *hook tiny ARM/Thumb functions* geradas pelo alinhamento agressivo do LLD (`--icf=all`).
* Enumerar e rebinding *ELF import slots* funciona no Android, permitindo patching por módulo via `dlopen()`/`dlsym()` quando inline hooks são rejeitados.
* Java hooking foi corrigido para o novo **ART quick-entrypoint** usado quando apps são compilados com `--enable-optimizations` no Android 14.

Exemplo: enumerar todas as funções registradas via `RegisterNatives` e despejar seus endereços em tempo de execução:
```javascript
Java.perform(function () {
var Runtime = Java.use('java.lang.Runtime');
var register = Module.findExportByName(null, 'RegisterNatives');
Interceptor.attach(register, {
onEnter(args) {
var envPtr  = args[0];
var clazz   = Java.cast(args[1], Java.use('java.lang.Class'));
var methods = args[2];
var count   = args[3].toInt32();
console.log('[+] RegisterNatives on ' + clazz.getName() + ' -> ' + count + ' methods');
// iterate & dump (JNI nativeMethod struct: name, sig, fnPtr)
}
});
});
```
Frida will work out of the box on PAC/BTI-enabled devices (Pixel 8/Android 14+) as long as you use frida-server 16.2 or later – earlier versions failed to locate padding for inline hooks.

### Telemetria JNI local ao processo via .so pré-carregado (SoTap)

Quando instrumentação completa é exagero ou está bloqueada, você ainda pode obter visibilidade em nível nativo pré-carregando um pequeno logger dentro do processo alvo. SoTap é uma biblioteca nativa Android leve (.so) que registra o comportamento em tempo de execução de outras bibliotecas JNI (.so) dentro do mesmo processo do app (não requer root).

Propriedades principais:
- Inicializa cedo e observa interações JNI/native dentro do processo que o carrega.
- Persiste logs usando múltiplos caminhos graváveis com fallback gracioso para o Logcat quando o armazenamento estiver restrito.
- Customizável na fonte: edite sotap.c para estender/ajustar o que é logado e reconstrua para cada ABI.

Configuração (reempacotar o APK):
1) Drop the proper ABI build into the APK so the loader can resolve libsotap.so:
- lib/arm64-v8a/libsotap.so (for arm64)
- lib/armeabi-v7a/libsotap.so (for arm32)
2) Ensure SoTap loads before other JNI libs. Inject a call early (e.g., Application subclass static initializer or onCreate) so the logger is initialized first. Smali snippet example:
```smali
const-string v0, "sotap"
invoke-static {v0}, Ljava/lang/System;->loadLibrary(Ljava/lang/String;)V
```
3) Reconstrua/assine/instale, execute o app, e então colete os logs.

Caminhos de log (verificados nesta ordem):
```
/data/user/0/%s/files/sotap.log
/data/data/%s/files/sotap.log
/sdcard/Android/data/%s/files/sotap.log
/sdcard/Download/sotap-%s.log
# If all fail: fallback to Logcat only
```
Notas e solução de problemas:
- Alinhamento de ABI é obrigatório. Uma incompatibilidade causará UnsatisfiedLinkError e o logger não será carregado.
- Restrições de armazenamento são comuns em Android modernos; se gravações de arquivo falharem, SoTap ainda emitirá via Logcat.
- Comportamento/verbosidade deve ser customizado; reconstrua a partir do código-fonte após editar sotap.c.

Esta abordagem é útil para triagem de malware e depuração JNI quando observar fluxos de chamadas nativas desde o início do processo é crítico, mas hooks em root/sistema não estão disponíveis.

---

### See also: in‑memory native code execution via JNI

Um padrão comum de ataque é baixar um blob de shellcode bruto em tempo de execução e executá-lo diretamente da memória através de uma ponte JNI (sem ELF no disco). Detalhes e snippet JNI pronto para uso aqui:

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

---

### Recent vulnerabilities worth hunting for in APKs

| Ano | CVE | Biblioteca afetada | Notas |
|------|-----|------------------|-------|
|2023|CVE-2023-4863|`libwebp` ≤ 1.3.1|Heap buffer overflow alcançável a partir de código nativo que decodifica imagens WebP. Vários apps Android empacotam versões vulneráveis. Quando você vê um `libwebp.so` dentro de um APK, verifique sua versão e tente exploração ou patch.| |
|2024|Multiple|OpenSSL 3.x series|Vários problemas de memory-safety e padding-oracle. Muitos bundles Flutter & ReactNative distribuem seu próprio `libcrypto.so`.| |

Quando você encontra arquivos `.so` de terceiros dentro de um APK, sempre verifique o hash deles contra advisories upstream. SCA (Software Composition Analysis) é incomum em mobile, então builds vulneráveis e desatualizados são frequentes.

---

### Anti-Reversing & Hardening trends (Android 13-15)

* **Pointer Authentication (PAC) & Branch Target Identification (BTI):** Android 14 habilita PAC/BTI em bibliotecas do sistema em silicon ARMv8.3+ suportado. Decompilers agora exibem pseudo-instruções relacionadas a PAC; para análise dinâmica o Frida injeta trampolines *after* stripping PAC, mas seus trampolines customizados devem chamar `pacda`/`autibsp` quando necessário.
* **MTE & Scudo hardened allocator:** memory-tagging é opt-in, mas muitos apps com Play-Integrity compilam com `-fsanitize=memtag`; use `setprop arm64.memtag.dump 1` mais `adb shell am start ...` para capturar falhas de tag.
* **LLVM Obfuscator (opaque predicates, control-flow flattening):** packers comerciais (e.g., Bangcle, SecNeo) protegem cada vez mais *native* code, não apenas Java; espere bogus control-flow e blobs de strings encriptados em `.rodata`.

---

### Resources

- **Learning ARM Assembly:** [Azeria Labs – ARM Assembly Basics](https://azeria-labs.com/writing-arm-assembly-part-1/)
- **JNI & NDK Documentation:** [Oracle JNI Spec](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html) · [Android JNI Tips](https://developer.android.com/training/articles/perf-jni) · [NDK Guides](https://developer.android.com/ndk/guides/)
- **Debugging Native Libraries:** [Debug Android Native Libraries Using JEB Decompiler](https://medium.com/@shubhamsonani/how-to-debug-android-native-libraries-using-jeb-decompiler-eec681a22cf3)

### References

- Frida 16.x change-log (Android hooking, tiny-function relocation) – [frida.re/news](https://frida.re/news/)
- NVD advisory for `libwebp` overflow CVE-2023-4863 – [nvd.nist.gov](https://nvd.nist.gov/vuln/detail/CVE-2023-4863)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- SoTap Releases – [github.com/RezaArbabBot/SoTap/releases](https://github.com/RezaArbabBot/SoTap/releases)
- How to work with SoTap? – [t.me/ForYouTillEnd/13](https://t.me/ForYouTillEnd/13)
- [CoRPhone — JNI memory-only execution pattern and packaging](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
