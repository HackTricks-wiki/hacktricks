# Installer le certificat Burp

{{#include ../../banners/hacktricks-training.md}}


## Proxy global via ADB

Configurez un proxy HTTP global pour que toutes les applications routent leur trafic via votre interceptor (Burp/mitmproxy) :
```bash
# Set proxy (device/emulator must reach your host IP)
adb shell settings put global http_proxy 192.168.1.2:8080

# Clear proxy
adb shell settings put global http_proxy :0
```
Astuce : dans Burp, liez votre listener à 0.0.0.0 afin que les appareils du LAN puissent se connecter (Proxy -> Options -> Proxy Listeners).

## Sur une machine virtuelle

Tout d'abord, vous devez télécharger le certificat Der depuis Burp. Vous pouvez le faire dans _**Proxy**_ --> _**Options**_ --> _**Import / Export CA certificate**_

![](<../../images/image (367).png>)

**Exportez le certificat au format Der** et **transformons** le en un format que **Android** pourra **comprendre.** Notez que **pour configurer le certificat burp sur la machine Android dans AVD** vous devez **exécuter** cette machine **avec** l'option **`-writable-system`**.\
Par exemple vous pouvez l'exécuter comme :
```bash
C:\Users\<UserName>\AppData\Local\Android\Sdk\tools\emulator.exe -avd "AVD9" -http-proxy 192.168.1.12:8080 -writable-system
```
Ensuite, pour **configurer le certificat de burps**, faites :
```bash
openssl x509 -inform DER -in burp_cacert.der -out burp_cacert.pem
CERTHASHNAME="`openssl x509 -inform PEM -subject_hash_old -in burp_cacert.pem | head -1`.0"
mv burp_cacert.pem $CERTHASHNAME #Correct name
adb root && sleep 2 && adb remount #Allow to write on /syste
adb push $CERTHASHNAME /sdcard/ #Upload certificate
adb shell mv /sdcard/$CERTHASHNAME /system/etc/security/cacerts/ #Move to correct location
adb shell chmod 644 /system/etc/security/cacerts/$CERTHASHNAME #Assign privileges
adb reboot #Now, reboot the machine
```
Once the **machine finish rebooting** the burp certificate will be in use by it!

## Utiliser Magisc

Si vous **avez rooté votre appareil avec Magisc** (par exemple un émulateur), et que vous **ne pouvez pas suivre** les **étapes** précédentes pour installer le certificat Burp parce que le **système de fichiers est en lecture seule** et que vous ne pouvez pas le remonter en écriture, il existe une autre méthode.

Expliqué dans [**this video**](https://www.youtube.com/watch?v=qQicUW0svB8) vous devez :

1. **Installer un certificat CA** : Il suffit de **glisser-déposer** le certificat Burp en DER en **changeant l’extension** en `.crt` sur le mobile pour qu’il soit stocké dans le dossier Downloads, puis aller dans `Install a certificate` -> `CA certificate`

<figure><img src="../../images/image (53).png" alt="" width="164"><figcaption></figcaption></figure>

- Vérifiez que le certificat a été correctement enregistré en allant dans `Trusted credentials` -> `USER`

<figure><img src="../../images/image (54).png" alt="" width="334"><figcaption></figcaption></figure>

2. **Le rendre approuvé par le système** : Téléchargez le module Magisc [MagiskTrustUserCerts](https://github.com/NVISOsecurity/MagiskTrustUserCerts) (un fichier .zip), **glissez-le** dans le téléphone, ouvrez l’application **Magics** sur le téléphone dans la section **`Modules`**, cliquez sur **`Install from storage`**, sélectionnez le module `.zip` et une fois installé **redémarrez** le téléphone :

<figure><img src="../../images/image (55).png" alt="" width="345"><figcaption></figcaption></figure>

- Après le redémarrage, allez dans `Trusted credentials` -> `SYSTEM` et vérifiez que le certificat Postswigger s’y trouve

<figure><img src="../../images/image (56).png" alt="" width="314"><figcaption></figcaption></figure>

### Apprendre à créer un module Magisc

Consultez [https://medium.com/@justmobilesec/magisk-for-mobile-pentesting-rooting-android-devices-and-building-custom-modules-part-ii-22badc498437](https://medium.com/@justmobilesec/magisk-for-mobile-pentesting-rooting-android-devices-and-building-custom-modules-part-ii-22badc498437)

## Post Android 14

Dans la dernière version Android 14, un changement important a été observé dans la gestion des certificats d’autorité (CA) approuvés par le système. Auparavant, ces certificats étaient stockés dans **`/system/etc/security/cacerts/`**, accessibles et modifiables par les utilisateurs disposant des privilèges root, ce qui permettait leur application immédiate à l’échelle du système. Cependant, avec Android 14, l’emplacement de stockage a été déplacé vers **`/apex/com.android.conscrypt/cacerts`**, un répertoire au sein du chemin **`/apex`**, qui est immuable par nature.

Les tentatives de remonter le **chemin APEX cacerts** en écriture échouent, car le système n’autorise pas ce type d’opération. Même les tentatives de démonter ou de superposer le répertoire avec un système de fichiers temporaire (tmpfs) ne contournent pas l’immuabilité ; les applications continuent d’accéder aux données de certificats d’origine indépendamment des modifications au niveau du système de fichiers. Cette résilience est due au fait que le montage **`/apex`** est configuré avec une propagation PRIVATE, assurant que toute modification au sein du répertoire **`/apex`** n’affecte pas les autres processus.

L’initialisation d’Android implique le processus `init`, qui, au démarrage du système d’exploitation, lance également le processus Zygote. Ce processus est responsable du lancement des processus d’application avec un nouveau namespace de montage qui inclut un montage privé **`/apex`**, isolant ainsi les modifications de ce répertoire des autres processus.

Néanmoins, une solution de contournement existe pour ceux qui doivent modifier les certificats CA approuvés par le système dans le répertoire **`/apex`**. Cela implique de remonter manuellement **`/apex`** pour supprimer la propagation PRIVATE, rendant ainsi le répertoire modifiable. Le processus inclut la copie du contenu de **`/apex/com.android.conscrypt`** vers un autre emplacement, le démontage du répertoire **`/apex/com.android.conscrypt`** pour éliminer la contrainte en lecture seule, puis la restauration du contenu à son emplacement d’origine dans **`/apex`**. Cette approche nécessite une action rapide pour éviter des plantages système. Pour garantir l’application de ces changements à l’échelle du système, il est recommandé de redémarrer le `system_server`, ce qui redémarre effectivement toutes les applications et ramène le système à un état cohérent.
```bash
# Create a separate temp directory, to hold the current certificates
# Otherwise, when we add the mount we can't read the current certs anymore.
mkdir -p -m 700 /data/local/tmp/tmp-ca-copy

# Copy out the existing certificates
cp /apex/com.android.conscrypt/cacerts/* /data/local/tmp/tmp-ca-copy/

# Create the in-memory mount on top of the system certs folder
mount -t tmpfs tmpfs /system/etc/security/cacerts

# Copy the existing certs back into the tmpfs, so we keep trusting them
mv /data/local/tmp/tmp-ca-copy/* /system/etc/security/cacerts/

# Copy our new cert in, so we trust that too
mv $CERTIFICATE_PATH /system/etc/security/cacerts/

# Update the perms & selinux context labels
chown root:root /system/etc/security/cacerts/*
chmod 644 /system/etc/security/cacerts/*
chcon u:object_r:system_file:s0 /system/etc/security/cacerts/*

# Deal with the APEX overrides, which need injecting into each namespace:

# First we get the Zygote process(es), which launch each app
ZYGOTE_PID=$(pidof zygote || true)
ZYGOTE64_PID=$(pidof zygote64 || true)
# N.b. some devices appear to have both!

# Apps inherit the Zygote's mounts at startup, so we inject here to ensure
# all newly started apps will see these certs straight away:
for Z_PID in "$ZYGOTE_PID" "$ZYGOTE64_PID"; do
if [ -n "$Z_PID" ]; then
nsenter --mount=/proc/$Z_PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
fi
done

# Then we inject the mount into all already running apps, so they
# too see these CA certs immediately:

# Get the PID of every process whose parent is one of the Zygotes:
APP_PIDS=$(
echo "$ZYGOTE_PID $ZYGOTE64_PID" | \
xargs -n1 ps -o 'PID' -P | \
grep -v PID
)

# Inject into the mount namespace of each of those apps:
for PID in $APP_PIDS; do
nsenter --mount=/proc/$PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts &
done
wait # Launched in parallel - wait for completion here

echo "System certificate injected"
```
### Bind-mounting par NSEnter

1. **Création d'un répertoire inscriptible** : Initialement, un répertoire inscriptible est créé en montant un `tmpfs` par-dessus le répertoire système de certificats non-APEX existant. Ceci est réalisé avec la commande suivante :
```bash
mount -t tmpfs tmpfs /system/etc/security/cacerts
```
2. **Preparing CA Certificates**: Après la configuration du répertoire inscriptible, les CA certificates que l'on souhaite utiliser doivent être copiés dans ce répertoire. Cela peut impliquer de copier les certificats par défaut depuis `/apex/com.android.conscrypt/cacerts/`. Il est essentiel d'ajuster les permissions et les SELinux labels de ces certificats en conséquence.
3. **Bind Mounting for Zygote**: En utilisant `nsenter`, on entre dans le namespace de montage de Zygote. Zygote, étant le processus responsable du lancement des applications Android, nécessite cette étape afin de garantir que toutes les applications lancées désormais utilisent les CA certificates nouvellement configurés. La commande utilisée est:
```bash
nsenter --mount=/proc/$ZYGOTE_PID/ns/mnt -- /bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
```
Cela garantit que chaque nouvelle application démarrée respectera la configuration mise à jour des certificats CA.

4. **Appliquer les changements aux applications en cours d'exécution**: Pour appliquer les changements aux applications déjà en cours d'exécution, `nsenter` est à nouveau utilisé pour entrer dans l'espace de noms de chaque application individuellement et effectuer un bind mount similaire. La commande nécessaire est :
```bash
nsenter --mount=/proc/$APP_PID/ns/mnt -- /bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
```
5. **Alternative Approach - Soft Reboot**: Une méthode alternative consiste à effectuer le bind mount sur le processus `init` (PID 1), puis à réaliser un soft reboot du système d'exploitation avec les commandes `stop && start`. Cette approche propagera les changements dans tous les namespaces, évitant d'avoir à traiter individuellement chaque application en cours d'exécution. Cependant, cette méthode est généralement moins recommandée en raison de l'inconvénient du redémarrage.

## Références

- [Android 14: Install a system CA certificate on a rooted device](https://httptoolkit.com/blog/android-14-install-system-ca-certificate/)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)

{{#include ../../banners/hacktricks-training.md}}
