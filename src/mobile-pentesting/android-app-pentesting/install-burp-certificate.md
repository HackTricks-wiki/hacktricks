# Sakinisha Cheti cha Burp

{{#include ../../banners/hacktricks-training.md}}


## Proxy ya mfumo mzima kupitia ADB

Sanidi proxy ya HTTP ya mfumo mzima ili programu zote zipitie trafiki kupitia interceptor yako (Burp/mitmproxy):
```bash
# Set proxy (device/emulator must reach your host IP)
adb shell settings put global http_proxy 192.168.1.2:8080

# Clear proxy
adb shell settings put global http_proxy :0
```
Kidokezo: Katika Burp, elekeza listener yako kwa 0.0.0.0 ili vifaa kwenye LAN viweze kuungana (Proxy -> Options -> Proxy Listeners).

## Kwenye Mashine ya Virtuali

Kwanza kabisa unahitaji kupakua cheti la Der kutoka Burp. Unaweza kufanya hivyo katika _**Proxy**_ --> _**Options**_ --> _**Import / Export CA certificate**_

![](<../../images/image (367).png>)

**Hamisha cheti kwa muundo wa Der** na kisha **tubadilishe** hadi iwe katika fomu ambayo **Android** itaweza **kuelewa.** Kumbuka kwamba **ili kusanidi cheti cha burp kwenye mashine ya Android katika AVD** unahitaji **kuendesha** mashine hii **kwa** chaguo **`-writable-system`**.\
Kwa mfano unaweza kuiendesha hivi:
```bash
C:\Users\<UserName>\AppData\Local\Android\Sdk\tools\emulator.exe -avd "AVD9" -http-proxy 192.168.1.12:8080 -writable-system
```
Kisha, ili **configure burps certificate**, fanya:
```bash
openssl x509 -inform DER -in burp_cacert.der -out burp_cacert.pem
CERTHASHNAME="`openssl x509 -inform PEM -subject_hash_old -in burp_cacert.pem | head -1`.0"
mv burp_cacert.pem $CERTHASHNAME #Correct name
adb root && sleep 2 && adb remount #Allow to write on /syste
adb push $CERTHASHNAME /sdcard/ #Upload certificate
adb shell mv /sdcard/$CERTHASHNAME /system/etc/security/cacerts/ #Move to correct location
adb shell chmod 644 /system/etc/security/cacerts/$CERTHASHNAME #Assign privileges
adb reboot #Now, reboot the machine
```
Mara tu **mashine imekamilisha kuanzisha upya**, cheti cha Burp kitakuwa kinatumika na mfumo!

## Kutumia Magisc

Ikiwa **ulikata root kifaa chako kwa Magisc** (labda emulator), na **huwezi kufuata** **hatua** zilizotangulia kusanidi Burp cert kwa sababu **filesystem ni read-only** na huwezi kuiremonta kuwa writable, kuna njia nyingine.

Iliyefafanuliwa katika [**this video**](https://www.youtube.com/watch?v=qQicUW0svB8) unahitaji:

1. **Install a CA certificate**: Just **drag&drop** the DER Burp certificate **changing the extension** to `.crt` in the mobile so it's stored in the Downloads folder and go to `Install a certificate` -> `CA certificate`

<figure><img src="../../images/image (53).png" alt="" width="164"><figcaption></figcaption></figure>

- Angalia cheti kilihifadhiwa vizuri kwa kwenda `Trusted credentials` -> `USER`

<figure><img src="../../images/image (54).png" alt="" width="334"><figcaption></figcaption></figure>

2. **Make it System trusted**: Download the Magisc module [MagiskTrustUserCerts](https://github.com/NVISOsecurity/MagiskTrustUserCerts) (a .zip file), **drag&drop it** in the phone, go to the **Magics app** in the phone to the **`Modules`** section, click on **`Install from storage`**, select the `.zip` module and once installed **reboot** the phone:

<figure><img src="../../images/image (55).png" alt="" width="345"><figcaption></figcaption></figure>

- Baada ya kuanzisha upya, nenda `Trusted credentials` -> `SYSTEM` na uhakikishe Postswigger cert iko hapo

<figure><img src="../../images/image (56).png" alt="" width="314"><figcaption></figcaption></figure>

### Jifunze jinsi ya kuunda module ya Magisc

Angalia [https://medium.com/@justmobilesec/magisk-for-mobile-pentesting-rooting-android-devices-and-building-custom-modules-part-ii-22badc498437](https://medium.com/@justmobilesec/magisk-for-mobile-pentesting-rooting-android-devices-and-building-custom-modules-part-ii-22badc498437)

## Baada ya Android 14

Katika toleo la hivi karibuni la Android 14, kumetokea mabadiliko makubwa katika jinsi Certificate Authority (CA) certificates zinazothibitishwa na mfumo zinavyoshughulikiwa. Hapo awali, cheti hizi zilihifadhiwa katika **`/system/etc/security/cacerts/`**, zikipatikana na zinabadilika kwa watumiaji wenye root, na hivyo kutumika mara moja kote kwenye mfumo. Hata hivyo, na Android 14, eneo la uhifadhi limehamishwa kwenda **`/apex/com.android.conscrypt/cacerts`**, saraka ndani ya `\`/apex\``, ambayo ni immutable kwa asili.

Jaribio la kuremonta APEX cacerts path kuwa writable yatashindwa, kwani mfumo hautaruhusu operesheni hizo. Hata jaribio la kuunmount au ku-overlay saraka kwa tmpfs halitachukua muda; programu zitabaki kutumia data za cheti asilia licha ya mabadiliko kwenye ngazi ya filesystem. Ustahimilivu huu unatokana na mount ya **`/apex`** kuwa na PRIVATE propagation, kuhakikisha kwamba mabadiliko ndani ya saraka ya **`/apex`** hayagusi michakato mingine.

Uanzishaji wa Android unahusisha mchakato wa `init`, ambao, anapoanza mfumo wa uendeshaji, pia huanzisha mchakato wa Zygote. Mchakato huu unawajibika kuwasha michakato ya programu ndani ya mount namespace mpya inayojumuisha mount ya kibinafsi ya **`/apex`**, hivyo kutenganisha mabadiliko ya saraka hii kutoka kwa michakato mingine.

Hata hivyo, kuna njia mbadala kwa wale wanaohitaji kubadilisha CA certificates zinazothibitishwa na mfumo ndani ya saraka ya **`/apex`**. Hii inahusisha kuremonta kwa mkono **`/apex`** ili kuondoa PRIVATE propagation, hivyo kuifanya iwe writable. Mchakato unajumuisha kunakili yaliyomo ya **`/apex/com.android.conscrypt`** mahali pengine, kuunmount saraka ya **`/apex/com.android.conscrypt`** ili kuondoa ukandamizaji wa read-only, na kisha kurejesha yaliyomo kwenye eneo lao la asili ndani ya **`/apex`**. Njia hii inahitaji hatua ya haraka ili kuepuka kukatika kwa mfumo. Ili kuhakikisha mabadiliko haya yanatumika kwenye mfumo mzima, inapendekezwa kuanzisha upya `system_server`, ambayo kwa ufanisi inaanzisha tena programu zote na kuleta mfumo katika hali thabiti.
```bash
# Create a separate temp directory, to hold the current certificates
# Otherwise, when we add the mount we can't read the current certs anymore.
mkdir -p -m 700 /data/local/tmp/tmp-ca-copy

# Copy out the existing certificates
cp /apex/com.android.conscrypt/cacerts/* /data/local/tmp/tmp-ca-copy/

# Create the in-memory mount on top of the system certs folder
mount -t tmpfs tmpfs /system/etc/security/cacerts

# Copy the existing certs back into the tmpfs, so we keep trusting them
mv /data/local/tmp/tmp-ca-copy/* /system/etc/security/cacerts/

# Copy our new cert in, so we trust that too
mv $CERTIFICATE_PATH /system/etc/security/cacerts/

# Update the perms & selinux context labels
chown root:root /system/etc/security/cacerts/*
chmod 644 /system/etc/security/cacerts/*
chcon u:object_r:system_file:s0 /system/etc/security/cacerts/*

# Deal with the APEX overrides, which need injecting into each namespace:

# First we get the Zygote process(es), which launch each app
ZYGOTE_PID=$(pidof zygote || true)
ZYGOTE64_PID=$(pidof zygote64 || true)
# N.b. some devices appear to have both!

# Apps inherit the Zygote's mounts at startup, so we inject here to ensure
# all newly started apps will see these certs straight away:
for Z_PID in "$ZYGOTE_PID" "$ZYGOTE64_PID"; do
if [ -n "$Z_PID" ]; then
nsenter --mount=/proc/$Z_PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
fi
done

# Then we inject the mount into all already running apps, so they
# too see these CA certs immediately:

# Get the PID of every process whose parent is one of the Zygotes:
APP_PIDS=$(
echo "$ZYGOTE_PID $ZYGOTE64_PID" | \
xargs -n1 ps -o 'PID' -P | \
grep -v PID
)

# Inject into the mount namespace of each of those apps:
for PID in $APP_PIDS; do
nsenter --mount=/proc/$PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts &
done
wait # Launched in parallel - wait for completion here

echo "System certificate injected"
```
### Bind-mounting through NSEnter

1. **Kuweka saraka inayoweza kuandikwa**: Awali, saraka inayoweza kuandikwa inaanzishwa kwa ku-mount `tmpfs` juu ya saraka ya vyeti ya mfumo non-APEX iliyopo. Hii inafikiwa kwa amri ifuatayo:
```bash
mount -t tmpfs tmpfs /system/etc/security/cacerts
```
2. **Kuandaa Vyeti vya CA**: Baada ya kuweka saraka inayoweza kuandikwa, vyeti vya CA ambavyo mtu anakusudia kutumia vinapaswa kunakiliwa katika saraka hii. Hii inaweza kuhusisha kunakili vyeti za default kutoka `/apex/com.android.conscrypt/cacerts/`. Ni muhimu kurekebisha ruhusa na lebo za SELinux za vyeti hivi ipasavyo.
3. **Bind Mounting for Zygote**: Kwa kutumia nsenter, mtu anaingia katika mount namespace ya Zygote. Zygote, kama mchakato unaehusika na kuanzisha programu za Android, anahitaji hatua hii ili kuhakikisha kwamba programu zote zinazozinduliwa kuanzia sasa zitumie vyeti vya CA vilivyosanidiwa upya. Amri inayotumika ni:
```bash
nsenter --mount=/proc/$ZYGOTE_PID/ns/mnt -- /bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
```
Hii inahakikisha kwamba kila app mpya itakayozinduliwa itazingatia usanidi wa CA certificates uliosasishwa.

4. **Kutekeleza Mabadiliko kwa Programu Zinazoendeshwa**: Ili kutekeleza mabadiliko kwa programu ambazo tayari zinaendeshwa, `nsenter` hutumika tena kuingia katika namespace ya kila app kibinafsi na kufanya bind mount sawa. Amri inayohitajika ni:
```bash
nsenter --mount=/proc/$APP_PID/ns/mnt -- /bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
```
5. **Alternative Approach - Soft Reboot**: Njia mbadala inahusisha kufanya bind mount kwenye mchakato wa `init` (PID 1) ikifuatiwa na soft reboot ya mfumo wa uendeshaji kwa amri za `stop && start`. Njia hii itasambaza mabadiliko katika namespaces zote, ikiepuka haja ya kushughulikia kila app inayokimbia kimoja kwa kimoja. Hata hivyo, njia hii kwa ujumla haipendekeziwi kutokana na usumbufu wa kufanya reboot.

## Marejeo

- [Android 14: Install a system CA certificate on a rooted device](https://httptoolkit.com/blog/android-14-install-system-ca-certificate/)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)

{{#include ../../banners/hacktricks-training.md}}
