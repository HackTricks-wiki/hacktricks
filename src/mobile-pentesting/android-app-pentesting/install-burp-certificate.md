# 安装 Burp 证书

{{#include ../../banners/hacktricks-training.md}}


## 通过 ADB 设置系统范围代理

配置全局 HTTP 代理，使所有应用的流量都通过你的拦截器（Burp/mitmproxy）：
```bash
# Set proxy (device/emulator must reach your host IP)
adb shell settings put global http_proxy 192.168.1.2:8080

# Clear proxy
adb shell settings put global http_proxy :0
```
提示：在 Burp 中，将监听器绑定到 0.0.0.0，这样局域网设备就可以连接（Proxy -> Options -> Proxy Listeners）。

## 在虚拟机上

首先你需要从 Burp 下载 Der 证书。你可以在 _**Proxy**_ --> _**Options**_ --> _**Import / Export CA certificate**_ 中完成此操作。

![](<../../images/image (367).png>)

**将证书以 Der 格式导出**，然后把它**转换**为 **Android** 能够**识别**的格式。注意，**要在 AVD 中的 Android 机器上配置 Burp 证书**，需要以 **`-writable-system`** 选项**运行**该虚拟机。\
例如你可以这样运行：
```bash
C:\Users\<UserName>\AppData\Local\Android\Sdk\tools\emulator.exe -avd "AVD9" -http-proxy 192.168.1.12:8080 -writable-system
```
然后，要 **配置 burps 证书**：
```bash
openssl x509 -inform DER -in burp_cacert.der -out burp_cacert.pem
CERTHASHNAME="`openssl x509 -inform PEM -subject_hash_old -in burp_cacert.pem | head -1`.0"
mv burp_cacert.pem $CERTHASHNAME #Correct name
adb root && sleep 2 && adb remount #Allow to write on /syste
adb push $CERTHASHNAME /sdcard/ #Upload certificate
adb shell mv /sdcard/$CERTHASHNAME /system/etc/security/cacerts/ #Move to correct location
adb shell chmod 644 /system/etc/security/cacerts/$CERTHASHNAME #Assign privileges
adb reboot #Now, reboot the machine
```
一旦机器完成重启，Burp 证书将被其使用！

## Using Magisc

如果你使用 Magisc 对设备进行了 root（可能是模拟器），并且因为文件系统为只读且无法重新挂载为可写而**无法按照之前的步骤安装 Burp 证书**，还有另一种方法。

在[**this video**](https://www.youtube.com/watch?v=qQicUW0svB8)中解释了，你需要：

1. **Install a CA certificate**: 只需将 DER 格式的 Burp 证书拖放到手机上，并将扩展名改为 `.crt`，使其保存在 Downloads 文件夹，然后进入 `Install a certificate` -> `CA certificate`

<figure><img src="../../images/image (53).png" alt="" width="164"><figcaption></figcaption></figure>

- 通过进入 `Trusted credentials` -> `USER` 检查证书是否已正确存储

<figure><img src="../../images/image (54).png" alt="" width="334"><figcaption></figcaption></figure>

2. **Make it System trusted**: 下载 Magisc 模块 [MagiskTrustUserCerts](https://github.com/NVISOsecurity/MagiskTrustUserCerts)（一个 .zip 文件），将其拖放到手机，在手机上的 Magics 应用中进入 `Modules` 部分，点击 `Install from storage`，选择该 `.zip` 模块并在安装完成后重启手机：

<figure><img src="../../images/image (55).png" alt="" width="345"><figcaption></figcaption></figure>

- 重启后，进入 `Trusted credentials` -> `SYSTEM` 检查 Postswigger 证书是否存在

<figure><img src="../../images/image (56).png" alt="" width="314"><figcaption></figcaption></figure>

### Learn how to create a Magisc module

查看 https://medium.com/@justmobilesec/magisk-for-mobile-pentesting-rooting-android-devices-and-building-custom-modules-part-ii-22badc498437

## Post Android 14

在最新的 Android 14 版本中，系统受信任的 CA 证书处理方式发生了重大变化。此前，这些证书存放在 **`/system/etc/security/cacerts/`**，有 root 权限的用户可以访问和修改，从而立即在系统范围内生效。然而在 Android 14 中，存储位置已移动到 **`/apex/com.android.conscrypt/cacerts`**，这是位于 **`/apex`** 路径下的目录，而该目录本质上是不可变的。

尝试将 **APEX cacerts 路径** 重新挂载为可写将会失败，系统不允许此类操作。即使尝试卸载或用临时文件系统（tmpfs）覆盖该目录，也无法绕过不可变性；应用程序仍然会访问原始的证书数据，而不会受文件系统层面的更改影响。这种鲁棒性源于 **`/apex`** 挂载被配置为 PRIVATE 传播，确保对 **`/apex`** 目录的任何修改不会影响其他进程。

Android 的初始化由 `init` 进程负责，在启动操作系统时，`init` 同时也会启动 Zygote 进程。Zygote 负责以包含私有 **`/apex`** 挂载的新挂载命名空间启动应用进程，从而将对该目录的更改与其他进程隔离。

尽管如此，仍然存在一种变通方法，适用于需要修改 **`/apex`** 目录下系统受信任 CA 证书的情况。该方法涉及手动重新挂载 **`/apex`** 以移除 PRIVATE 传播，从而使其可写。该过程包括将 **`/apex/com.android.conscrypt`** 的内容复制到另一位置，卸载 **`/apex/com.android.conscrypt`** 目录以消除只读限制，然后将内容恢复回 **`/apex`** 的原位置。该方法需要快速执行以避免系统崩溃。为了确保这些更改在系统范围内生效，建议重启 `system_server`，这会有效地重启所有应用并使系统回到一致状态。
```bash
# Create a separate temp directory, to hold the current certificates
# Otherwise, when we add the mount we can't read the current certs anymore.
mkdir -p -m 700 /data/local/tmp/tmp-ca-copy

# Copy out the existing certificates
cp /apex/com.android.conscrypt/cacerts/* /data/local/tmp/tmp-ca-copy/

# Create the in-memory mount on top of the system certs folder
mount -t tmpfs tmpfs /system/etc/security/cacerts

# Copy the existing certs back into the tmpfs, so we keep trusting them
mv /data/local/tmp/tmp-ca-copy/* /system/etc/security/cacerts/

# Copy our new cert in, so we trust that too
mv $CERTIFICATE_PATH /system/etc/security/cacerts/

# Update the perms & selinux context labels
chown root:root /system/etc/security/cacerts/*
chmod 644 /system/etc/security/cacerts/*
chcon u:object_r:system_file:s0 /system/etc/security/cacerts/*

# Deal with the APEX overrides, which need injecting into each namespace:

# First we get the Zygote process(es), which launch each app
ZYGOTE_PID=$(pidof zygote || true)
ZYGOTE64_PID=$(pidof zygote64 || true)
# N.b. some devices appear to have both!

# Apps inherit the Zygote's mounts at startup, so we inject here to ensure
# all newly started apps will see these certs straight away:
for Z_PID in "$ZYGOTE_PID" "$ZYGOTE64_PID"; do
if [ -n "$Z_PID" ]; then
nsenter --mount=/proc/$Z_PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
fi
done

# Then we inject the mount into all already running apps, so they
# too see these CA certs immediately:

# Get the PID of every process whose parent is one of the Zygotes:
APP_PIDS=$(
echo "$ZYGOTE_PID $ZYGOTE64_PID" | \
xargs -n1 ps -o 'PID' -P | \
grep -v PID
)

# Inject into the mount namespace of each of those apps:
for PID in $APP_PIDS; do
nsenter --mount=/proc/$PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts &
done
wait # Launched in parallel - wait for completion here

echo "System certificate injected"
```
### Bind-mounting 通过 NSEnter

1. **设置可写目录**：最初，通过在现有的 non-APEX 系统证书目录上挂载 `tmpfs` 来建立一个可写目录。 这可以通过以下命令实现：
```bash
mount -t tmpfs tmpfs /system/etc/security/cacerts
```
2. **准备 CA 证书**: 在可写目录设置完成后，需将要使用的 CA 证书复制到该目录中。这可能包括从 `/apex/com.android.conscrypt/cacerts/` 复制默认证书。必须相应地调整这些证书的权限和 SELinux 标签。
3. **为 Zygote 进行绑定挂载**: 使用 `nsenter` 进入 Zygote 的挂载命名空间。Zygote 是负责启动 Android 应用的进程，必须执行此步骤以确保此后启动的所有应用都使用新配置的 CA 证书。使用的命令为:
```bash
nsenter --mount=/proc/$ZYGOTE_PID/ns/mnt -- /bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
```
这可确保每个新启动的应用都会遵循已更新的 CA 证书设置。

4. **将更改应用于正在运行的应用**：要将这些更改应用到已在运行的应用上，仍然使用 `nsenter` 单独进入每个应用的命名空间，并执行类似的 bind mount。所需的命令为：
```bash
nsenter --mount=/proc/$APP_PID/ns/mnt -- /bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
```
5. **Alternative Approach - Soft Reboot**: 一种替代方法是在 `init` 进程 (PID 1) 上执行 bind mount，然后通过 `stop && start` 命令对操作系统进行软重启。该方法会将更改传播到所有命名空间，从而无需逐一处理每个正在运行的应用。但由于重启带来的不便，这种方法通常不太推荐。

## 参考资料

- [Android 14: Install a system CA certificate on a rooted device](https://httptoolkit.com/blog/android-14-install-system-ca-certificate/)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)

{{#include ../../banners/hacktricks-training.md}}
