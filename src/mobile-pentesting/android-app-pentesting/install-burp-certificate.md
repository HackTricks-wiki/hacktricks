# Burp Sertifikasını Yükle

{{#include ../../banners/hacktricks-training.md}}


## ADB üzerinden sistem çapında proxy

Tüm uygulamaların trafiğini interceptor'ınıza (Burp/mitmproxy) yönlendirmesi için sistem çapında bir HTTP proxy yapılandırın:
```bash
# Set proxy (device/emulator must reach your host IP)
adb shell settings put global http_proxy 192.168.1.2:8080

# Clear proxy
adb shell settings put global http_proxy :0
```
Tip: In Burp, bind your listener to 0.0.0.0 so devices on the LAN can connect (Proxy -> Options -> Proxy Listeners).

## Sanal Makinede

Öncelikle Burp'tan Der sertifikasını indirmeniz gerekiyor. Bunu _**Proxy**_ --> _**Options**_ --> _**Import / Export CA certificate**_ yolundan yapabilirsiniz.

![](<../../images/image (367).png>)

**Sertifikayı Der formatında dışa aktarın** ve bunu **Android**'in **anlayacağı** bir formata **dönüştürelim.** Not: **AVD içindeki Android makinede burp sertifikasını yapılandırmak için** bu makineyi **`-writable-system`** seçeneği ile **çalıştırmanız** gerektiğini unutmayın.\
Örneğin şöyle çalıştırabilirsiniz:
```bash
C:\Users\<UserName>\AppData\Local\Android\Sdk\tools\emulator.exe -avd "AVD9" -http-proxy 192.168.1.12:8080 -writable-system
```
Sonra, **burps sertifikasını yapılandırmak için şunu yapın**:
```bash
openssl x509 -inform DER -in burp_cacert.der -out burp_cacert.pem
CERTHASHNAME="`openssl x509 -inform PEM -subject_hash_old -in burp_cacert.pem | head -1`.0"
mv burp_cacert.pem $CERTHASHNAME #Correct name
adb root && sleep 2 && adb remount #Allow to write on /syste
adb push $CERTHASHNAME /sdcard/ #Upload certificate
adb shell mv /sdcard/$CERTHASHNAME /system/etc/security/cacerts/ #Move to correct location
adb shell chmod 644 /system/etc/security/cacerts/$CERTHASHNAME #Assign privileges
adb reboot #Now, reboot the machine
```
Makine **yeniden başlatmayı tamamladıktan sonra** burp sertifikası kullanılacaktır!

## Magisc Kullanımı

Eğer cihazınızı **Magisc ile rootladıysanız** (belki bir emulator), ve Burp sertifikasını yüklemek için önceki **adımları** **izleyemiyorsanız** çünkü **dosya sistemi salt okunur** ve yeniden yazılabilir şekilde yeniden mount edemiyorsanız, başka bir yol var.

[**this video**](https://www.youtube.com/watch?v=qQicUW0svB8) içinde açıklandığı üzere yapmanız gerekenler:

1. **Bir CA sertifikası yükleyin**: DER Burp sertifikasını `.crt` uzantısına **değiştirerek** mobil cihaza sadece **sürükle&bırak** ile Downloads klasörüne koyun ve `Install a certificate` -> `CA certificate`'e gidin

<figure><img src="../../images/image (53).png" alt="" width="164"><figcaption></figcaption></figure>

- Sertifikanın doğru saklandığını kontrol etmek için `Trusted credentials` -> `USER`'e gidin

<figure><img src="../../images/image (54).png" alt="" width="334"><figcaption></figcaption></figure>

2. **Sistemde güvenilir hale getirin**: Magisc modülünü [MagiskTrustUserCerts](https://github.com/NVISOsecurity/MagiskTrustUserCerts) (bir .zip dosyası) indirin, telefonuza **sürükle&bırak** ile koyun, telefondaki **Magics app**'e gidin `Modules` bölümüne, **`Install from storage`**'a tıklayın, `.zip` modülünü seçin ve yüklendikten sonra telefonu **yeniden başlatın**:

<figure><img src="../../images/image (55).png" alt="" width="345"><figcaption></figcaption></figure>

- Yeniden başlattıktan sonra `Trusted credentials` -> `SYSTEM`'e gidin ve Postswigger sertifikasının orada olduğunu kontrol edin

<figure><img src="../../images/image (56).png" alt="" width="314"><figcaption></figcaption></figure>

### Bir Magisc modülü oluşturmayı öğrenin

İnceleyin [https://medium.com/@justmobilesec/magisk-for-mobile-pentesting-rooting-android-devices-and-building-custom-modules-part-ii-22badc498437](https://medium.com/@justmobilesec/magisk-for-mobile-pentesting-rooting-android-devices-and-building-custom-modules-part-ii-22badc498437)

## Android 14 Sonrası

En son Android 14 sürümünde, sistem tarafından güvenilen Certificate Authority (CA) sertifikalarının işlenmesinde önemli bir değişiklik gözlemlendi. Önceden bu sertifikalar **`/system/etc/security/cacerts/`** içinde tutuluyor, root ayrıcalığına sahip kullanıcılar tarafından erişilebilir ve değiştirilebiliyordu; bu da sistem genelinde hemen uygulanmalarına imkan veriyordu. Ancak Android 14 ile depolama yeri **`/apex/com.android.conscrypt/cacerts`** içine taşındı; bu **`/apex`** yolundaki bir dizindir ve doğası gereği immutable (değiştirilemez) olarak tasarlanmıştır.

APEX cacerts yolunu yazılabilir olarak yeniden mount etmeye yönelik girişimler başarısızlıkla karşılaşıyor, çünkü sistem böyle işlemlere izin vermiyor. Dizini unmount etmeye veya üzerine geçici bir dosya sistemi (tmpfs) bind/overlay etmeye yönelik girişimler bile bu değiştirilemezliği aşamıyor; uygulamalar dosya sistemi düzeyindeki değişikliklerden bağımsız olarak orijinal sertifika verilerine erişmeye devam ediyor. Bu dayanıklılık, **`/apex`** mount'unun PRIVATE propagation ile yapılandırılmasından kaynaklanır; böylece **`/apex`** içindeki herhangi bir değişiklik diğer süreçleri etkilemez.

Android'in başlatılması, işletim sistemini başlatan `init` sürecini içerir; bu süreç aynı zamanda Zygote sürecini başlatır. Zygote, yeni bir mount namespace ile uygulama süreçlerini başlatmaktan sorumludur ve bu namespace içinde özel bir **`/apex`** mount bulunur; böylece bu dizindeki değişiklikler diğer süreçlerden izole edilir.

Yine de, **`/apex`** dizini içindeki sistem tarafından güvenilen CA sertifikalarını değiştirmek isteyenler için bir geçici çözüm vardır. Bu yöntem, PRIVATE propagation'ı kaldırmak için **`/apex`**'i elle yeniden mount etmeyi ve böylece yazılabilir hale getirmeyi içerir. İşlem, **`/apex/com.android.conscrypt`** içeriğini başka bir konuma kopyalamayı, **`/apex/com.android.conscrypt`** dizinini unmount ederek salt okunur kısıtlamasını kaldırmayı ve ardından içeriği tekrar **`/apex`** içindeki orijinal konumuna geri yüklemeyi kapsar. Bu yaklaşımın sistem çökmesini önlemek için hızlı hareket etmeyi gerektirdiğini unutmayın. Yapılan değişikliklerin sistem genelinde uygulanmasını sağlamak için `system_server`'ı yeniden başlatmanız (bu tüm uygulamaları etkili şekilde yeniden başlatır) önerilir.
```bash
# Create a separate temp directory, to hold the current certificates
# Otherwise, when we add the mount we can't read the current certs anymore.
mkdir -p -m 700 /data/local/tmp/tmp-ca-copy

# Copy out the existing certificates
cp /apex/com.android.conscrypt/cacerts/* /data/local/tmp/tmp-ca-copy/

# Create the in-memory mount on top of the system certs folder
mount -t tmpfs tmpfs /system/etc/security/cacerts

# Copy the existing certs back into the tmpfs, so we keep trusting them
mv /data/local/tmp/tmp-ca-copy/* /system/etc/security/cacerts/

# Copy our new cert in, so we trust that too
mv $CERTIFICATE_PATH /system/etc/security/cacerts/

# Update the perms & selinux context labels
chown root:root /system/etc/security/cacerts/*
chmod 644 /system/etc/security/cacerts/*
chcon u:object_r:system_file:s0 /system/etc/security/cacerts/*

# Deal with the APEX overrides, which need injecting into each namespace:

# First we get the Zygote process(es), which launch each app
ZYGOTE_PID=$(pidof zygote || true)
ZYGOTE64_PID=$(pidof zygote64 || true)
# N.b. some devices appear to have both!

# Apps inherit the Zygote's mounts at startup, so we inject here to ensure
# all newly started apps will see these certs straight away:
for Z_PID in "$ZYGOTE_PID" "$ZYGOTE64_PID"; do
if [ -n "$Z_PID" ]; then
nsenter --mount=/proc/$Z_PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
fi
done

# Then we inject the mount into all already running apps, so they
# too see these CA certs immediately:

# Get the PID of every process whose parent is one of the Zygotes:
APP_PIDS=$(
echo "$ZYGOTE_PID $ZYGOTE64_PID" | \
xargs -n1 ps -o 'PID' -P | \
grep -v PID
)

# Inject into the mount namespace of each of those apps:
for PID in $APP_PIDS; do
nsenter --mount=/proc/$PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts &
done
wait # Launched in parallel - wait for completion here

echo "System certificate injected"
```
### Bind-mounting through NSEnter

1. **Yazılabilir Bir Dizin Oluşturma**: Başlangıçta, mevcut non-APEX sistem sertifika dizininin üzerine bir `tmpfs` bağlanarak yazılabilir bir dizin oluşturulur. Bu, aşağıdaki komutla gerçekleştirilir:
```bash
mount -t tmpfs tmpfs /system/etc/security/cacerts
```
2. **CA Sertifikalarını Hazırlama**: Yazılabilir dizin ayarlandıktan sonra kullanmak istediğiniz CA sertifikaları bu dizine kopyalanmalıdır. Bu, varsayılan sertifikaların `/apex/com.android.conscrypt/cacerts/` dizininden kopyalanmasını içerebilir. Bu sertifikaların izinlerini ve SELinux etiketlerini uygun şekilde ayarlamak önemlidir.

3. **Zygote için Bind Mounting**: `nsenter` kullanılarak Zygote'un mount namespace'ına girilir. Zygote, Android uygulamalarını başlatmaktan sorumlu süreç olduğundan, bu adım bundan sonra başlatılan tüm uygulamaların yeni yapılandırılmış CA sertifikalarını kullanmasını sağlamak için gereklidir. Kullanılan komut ise:
```bash
nsenter --mount=/proc/$ZYGOTE_PID/ns/mnt -- /bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
```
Bu, başlatılan her yeni uygulamanın güncellenmiş CA sertifikaları yapılandırmasına uymasını sağlar.

4. **Çalışan Uygulamalara Değişiklikleri Uygulama**: Zaten çalışan uygulamalara değişiklikleri uygulamak için, `nsenter` yeniden kullanılarak her uygulamanın namespace'ine ayrı ayrı girilir ve benzer bir bind mount gerçekleştirilir. Gerekli komut şudur:
```bash
nsenter --mount=/proc/$APP_PID/ns/mnt -- /bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
```
5. **Alternatif Yaklaşım - Yumuşak Yeniden Başlatma**: Alternatif bir yöntem, `init` sürecinde (PID 1) bind mount uygulayıp ardından işletim sistemini `stop && start` komutları ile yumuşak şekilde yeniden başlatmaktır. Bu yaklaşım değişiklikleri tüm namespaces'lere yayar ve her çalışan uygulamayı ayrı ayrı ele alma ihtiyacını ortadan kaldırır. Ancak, yeniden başlatmanın zahmeti nedeniyle bu yöntem genellikle daha az tercih edilir.

## Referanslar

- [Android 14: Install a system CA certificate on a rooted device](https://httptoolkit.com/blog/android-14-install-system-ca-certificate/)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)

{{#include ../../banners/hacktricks-training.md}}
