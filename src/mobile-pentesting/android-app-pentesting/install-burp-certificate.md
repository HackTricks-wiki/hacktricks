# 安装 Burp 证书

{{#include ../../banners/hacktricks-training.md}}

<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

## 在虚拟机上

首先，您需要从 Burp 下载 Der 证书。您可以在 _**Proxy**_ --> _**Options**_ --> _**Import / Export CA certificate**_ 中完成此操作。

![](<../../images/image (367).png>)

**以 Der 格式导出证书**，然后让我们**转换**它为**Android**能够**理解**的格式。请注意，**为了在 AVD 的 Android 机器上配置 Burp 证书**，您需要**使用** **`-writable-system`** 选项运行此机器。\
例如，您可以这样运行它：
```bash
C:\Users\<UserName>\AppData\Local\Android\Sdk\tools\emulator.exe -avd "AVD9" -http-proxy 192.168.1.12:8080 -writable-system
```
然后，**配置 burp 的证书**：
```bash
openssl x509 -inform DER -in burp_cacert.der -out burp_cacert.pem
CERTHASHNAME="`openssl x509 -inform PEM -subject_hash_old -in burp_cacert.pem | head -1`.0"
mv burp_cacert.pem $CERTHASHNAME #Correct name
adb root && sleep 2 && adb remount #Allow to write on /syste
adb push $CERTHASHNAME /sdcard/ #Upload certificate
adb shell mv /sdcard/$CERTHASHNAME /system/etc/security/cacerts/ #Move to correct location
adb shell chmod 644 /system/etc/security/cacerts/$CERTHASHNAME #Assign privileges
adb reboot #Now, reboot the machine
```
一旦**机器完成重启**，Burp 证书将被使用！

## 使用 Magisc

如果你**用 Magisc 获取了设备的 root 权限**（可能是模拟器），并且你**无法按照**之前的**步骤**安装 Burp 证书，因为**文件系统是只读的**，你无法重新挂载为可写，还有另一种方法。

在[**这个视频**](https://www.youtube.com/watch?v=qQicUW0svB8)中解释，你需要：

1. **安装 CA 证书**：只需**拖放** DER Burp 证书，**更改扩展名**为 `.crt`，存储在手机的下载文件夹中，然后转到 `Install a certificate` -> `CA certificate`

<figure><img src="../../images/image (53).png" alt="" width="164"><figcaption></figcaption></figure>

- 检查证书是否正确存储，转到 `Trusted credentials` -> `USER`

<figure><img src="../../images/image (54).png" alt="" width="334"><figcaption></figcaption></figure>

2. **使其系统信任**：下载 Magisc 模块 [MagiskTrustUserCerts](https://github.com/NVISOsecurity/MagiskTrustUserCerts)（一个 .zip 文件），**拖放到**手机中，转到手机中的**Magics 应用**的**`Modules`**部分，点击**`Install from storage`**，选择 `.zip` 模块，安装完成后**重启**手机：

<figure><img src="../../images/image (55).png" alt="" width="345"><figcaption></figcaption></figure>

- 重启后，转到 `Trusted credentials` -> `SYSTEM`，检查 Postswigger 证书是否存在

<figure><img src="../../images/image (56).png" alt="" width="314"><figcaption></figcaption></figure>

## Android 14 后

在最新的 Android 14 版本中，系统信任的证书颁发机构（CA）证书的处理方式发生了重大变化。以前，这些证书存放在**`/system/etc/security/cacerts/`**，可以被具有 root 权限的用户访问和修改，从而允许在系统中立即应用。然而，在 Android 14 中，存储位置已移至**`/apex/com.android.conscrypt/cacerts`**，这是**`/apex`**路径下的一个目录，天生是不可变的。

尝试将**APEX cacerts 路径**重新挂载为可写时会失败，因为系统不允许此类操作。即使尝试卸载或用临时文件系统（tmpfs）覆盖该目录也无法规避不可变性；应用程序继续访问原始证书数据，无论文件系统级别的更改如何。这种韧性是由于**`/apex`**挂载配置为 PRIVATE 传播，确保在**`/apex`**目录中的任何修改不会影响其他进程。

Android 的初始化涉及 `init` 进程，该进程在启动操作系统时，也会启动 Zygote 进程。该进程负责以新的挂载命名空间启动应用程序进程，其中包括一个私有的**`/apex`**挂载，从而将对该目录的更改与其他进程隔离。

然而，对于需要修改**`/apex`**目录中系统信任的 CA 证书的人来说，存在一种解决方法。这涉及手动重新挂载**`/apex`**以移除 PRIVATE 传播，从而使其可写。该过程包括将**`/apex/com.android.conscrypt`**的内容复制到另一个位置，卸载**`/apex/com.android.conscrypt`**目录以消除只读约束，然后将内容恢复到**`/apex`**中的原始位置。此方法需要迅速行动以避免系统崩溃。为了确保这些更改在系统范围内生效，建议重启 `system_server`，这有效地重启所有应用程序并使系统恢复到一致状态。
```bash
# Create a separate temp directory, to hold the current certificates
# Otherwise, when we add the mount we can't read the current certs anymore.
mkdir -p -m 700 /data/local/tmp/tmp-ca-copy

# Copy out the existing certificates
cp /apex/com.android.conscrypt/cacerts/* /data/local/tmp/tmp-ca-copy/

# Create the in-memory mount on top of the system certs folder
mount -t tmpfs tmpfs /system/etc/security/cacerts

# Copy the existing certs back into the tmpfs, so we keep trusting them
mv /data/local/tmp/tmp-ca-copy/* /system/etc/security/cacerts/

# Copy our new cert in, so we trust that too
mv $CERTIFICATE_PATH /system/etc/security/cacerts/

# Update the perms & selinux context labels
chown root:root /system/etc/security/cacerts/*
chmod 644 /system/etc/security/cacerts/*
chcon u:object_r:system_file:s0 /system/etc/security/cacerts/*

# Deal with the APEX overrides, which need injecting into each namespace:

# First we get the Zygote process(es), which launch each app
ZYGOTE_PID=$(pidof zygote || true)
ZYGOTE64_PID=$(pidof zygote64 || true)
# N.b. some devices appear to have both!

# Apps inherit the Zygote's mounts at startup, so we inject here to ensure
# all newly started apps will see these certs straight away:
for Z_PID in "$ZYGOTE_PID" "$ZYGOTE64_PID"; do
if [ -n "$Z_PID" ]; then
nsenter --mount=/proc/$Z_PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
fi
done

# Then we inject the mount into all already running apps, so they
# too see these CA certs immediately:

# Get the PID of every process whose parent is one of the Zygotes:
APP_PIDS=$(
echo "$ZYGOTE_PID $ZYGOTE64_PID" | \
xargs -n1 ps -o 'PID' -P | \
grep -v PID
)

# Inject into the mount namespace of each of those apps:
for PID in $APP_PIDS; do
nsenter --mount=/proc/$PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts &
done
wait # Launched in parallel - wait for completion here

echo "System certificate injected"
```
### 通过 NSEnter 绑定挂载

1. **设置可写目录**：最初，通过在现有非 APEX 系统证书目录上挂载 `tmpfs` 来建立一个可写目录。可以使用以下命令实现：
```bash
mount -t tmpfs tmpfs /system/etc/security/cacerts
```
2. **准备 CA 证书**：在设置可写目录后，应该将打算使用的 CA 证书复制到该目录中。这可能涉及从 `/apex/com.android.conscrypt/cacerts/` 复制默认证书。必须相应地调整这些证书的权限和 SELinux 标签。
3. **为 Zygote 绑定挂载**：利用 `nsenter`，进入 Zygote 的挂载命名空间。Zygote 作为负责启动 Android 应用程序的进程，需要此步骤以确保所有随后启动的应用程序使用新配置的 CA 证书。使用的命令是：
```bash
nsenter --mount=/proc/$ZYGOTE_PID/ns/mnt -- /bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
```
这确保每个新启动的应用程序将遵循更新的 CA 证书设置。

4. **将更改应用于正在运行的应用程序**：要将更改应用于已经运行的应用程序，再次使用 `nsenter` 进入每个应用的命名空间，并执行类似的绑定挂载。必要的命令是：
```bash
nsenter --mount=/proc/$APP_PID/ns/mnt -- /bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
```
5. **替代方法 - 软重启**：一种替代方法涉及在 `init` 进程 (PID 1) 上执行绑定挂载，然后使用 `stop && start` 命令对操作系统进行软重启。这种方法将更改传播到所有命名空间，避免了单独处理每个正在运行的应用程序的需要。然而，由于重启的不便，这种方法通常不太受欢迎。

## 参考文献

- [https://httptoolkit.com/blog/android-14-install-system-ca-certificate/](https://httptoolkit.com/blog/android-14-install-system-ca-certificate/)

<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

{{#include ../../banners/hacktricks-training.md}}
