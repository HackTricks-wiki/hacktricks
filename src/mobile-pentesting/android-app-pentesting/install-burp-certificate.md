# Burp 인증서 설치

{{#include ../../banners/hacktricks-training.md}}


## ADB를 통한 시스템 전체 프록시

전역 HTTP 프록시를 구성하여 모든 앱이 트래픽을 interceptor (Burp/mitmproxy)를 통해 라우팅하도록 합니다:
```bash
# Set proxy (device/emulator must reach your host IP)
adb shell settings put global http_proxy 192.168.1.2:8080

# Clear proxy
adb shell settings put global http_proxy :0
```
팁: Burp에서 리스너를 0.0.0.0에 바인드하면 LAN의 디바이스들이 연결할 수 있습니다 (Proxy -> Options -> Proxy Listeners).

## 가상 머신에서

먼저 Burp에서 Der 인증서를 다운로드해야 합니다. _**Proxy**_ --> _**Options**_ --> _**Import / Export CA certificate**_에서 할 수 있습니다.

![](<../../images/image (367).png>)

**Der 형식으로 인증서를 내보내기**한 다음 **변환**하여 **Android**가 **이해할 수 있는** 형태로 만듭니다. **AVD의 Android 머신에 burp 인증서를 구성하려면** 이 머신을 **`-writable-system`** 옵션과 **함께** **실행**해야 한다는 점을 유의하세요.\
예를 들어 다음과 같이 실행할 수 있습니다:
```bash
C:\Users\<UserName>\AppData\Local\Android\Sdk\tools\emulator.exe -avd "AVD9" -http-proxy 192.168.1.12:8080 -writable-system
```
그런 다음, **burps 인증서를 구성하려면**:
```bash
openssl x509 -inform DER -in burp_cacert.der -out burp_cacert.pem
CERTHASHNAME="`openssl x509 -inform PEM -subject_hash_old -in burp_cacert.pem | head -1`.0"
mv burp_cacert.pem $CERTHASHNAME #Correct name
adb root && sleep 2 && adb remount #Allow to write on /syste
adb push $CERTHASHNAME /sdcard/ #Upload certificate
adb shell mv /sdcard/$CERTHASHNAME /system/etc/security/cacerts/ #Move to correct location
adb shell chmod 644 /system/etc/security/cacerts/$CERTHASHNAME #Assign privileges
adb reboot #Now, reboot the machine
```
머신이 **재부팅을 마치면** Burp certificate가 사용됩니다!

## Magisc 사용하기

만약 당신이 **Magisc로 기기를 루트(root)화했다**(에뮬레이터일 수 있음)면, 이전에 Burp cert를 설치하는 **단계들**을 따라할 수 없고 그 이유가 **파일시스템이 읽기 전용(read-only)**이라 remount로 쓰기 가능하게 만들 수 없다면, 다른 방법이 있습니다.

[**this video**](https://www.youtube.com/watch?v=qQicUW0svB8)에 설명된 것처럼, 다음을 수행해야 합니다:

1. **CA certificate 설치**: DER Burp certificate 파일의 확장자를 `.crt`로 **변경한 후** 모바일로 **드래그&드롭**하여 Downloads 폴더에 저장하고 `Install a certificate` -> `CA certificate`로 이동합니다

<figure><img src="../../images/image (53).png" alt="" width="164"><figcaption></figcaption></figure>

- 인증서가 제대로 저장되었는지 `Trusted credentials` -> `USER`로 이동해 확인하세요

<figure><img src="../../images/image (54).png" alt="" width="334"><figcaption></figcaption></figure>

2. **System trusted로 만들기**: Magisc 모듈 [MagiskTrustUserCerts](https://github.com/NVISOsecurity/MagiskTrustUserCerts) (.zip 파일)를 다운로드한 뒤, 폰에 **드래그&드롭**하고 폰의 **Magics app**에서 **`Modules`** 섹션으로 들어가 **`Install from storage`**를 클릭해 `.zip` 모듈을 선택하여 설치한 다음 폰을 **재부팅**합니다:

<figure><img src="../../images/image (55).png" alt="" width="345"><figcaption></figcaption></figure>

- 재부팅 후 `Trusted credentials` -> `SYSTEM`로 이동해 Postswigger cert가 있는지 확인하세요

<figure><img src="../../images/image (56).png" alt="" width="314"><figcaption></figcaption></figure>

### Magisc 모듈 만드는 법 배우기

다음 링크를 확인하세요: https://medium.com/@justmobilesec/magisk-for-mobile-pentesting-rooting-android-devices-and-building-custom-modules-part-ii-22badc498437

## Android 14 이후

최신 Android 14 릴리스에서는 system-trusted Certificate Authority (CA) 인증서 처리 방식에 큰 변화가 있었습니다. 이전에는 이 인증서들이 **`/system/etc/security/cacerts/`**에 위치해 있어 root 권한이 있는 사용자가 접근·수정할 수 있었고 시스템 전체에 즉시 적용되었습니다. 그러나 Android 14에서는 저장 위치가 **`/apex/com.android.conscrypt/cacerts`**로 이동했으며, 이는 **`/apex`** 경로 내의 디렉토리로 본질적으로 변경 불가능(immutable)합니다.

**APEX cacerts path**를 쓰기 가능하도록 remount하려는 시도는 시스템에서 허용되지 않아 실패합니다. 디렉토리를 언마운트하거나 tmpfs로 오버레이해도 불변성을 우회하지 못하며, 파일시스템 수준에서 변경을 가해도 애플리케이션은 여전히 원본 인증서 데이터를 참조합니다. 이는 **`/apex`** 마운트가 PRIVATE propagation으로 설정되어 있어 **`/apex`** 내의 변경이 다른 프로세스에 영향을 주지 않도록 하기 때문입니다.

Android 초기화는 `init` 프로세스가 운영체제를 시작하면서 Zygote 프로세스를 기동하는 과정을 포함합니다. Zygote는 새로운 마운트 네임스페이스를 가진 애플리케이션 프로세스를 시작하는 역할을 하며, 이 네임스페이스에는 private **`/apex`** 마운트가 포함되어 있어 해당 디렉토리에 대한 변경이 다른 프로세스와 격리됩니다.

그럼에도 불구하고 **`/apex`** 디렉토리 내의 system-trusted CA 인증서를 수정해야 하는 경우에 대한 우회 방법이 있습니다. 이 방법은 **`/apex`**의 PRIVATE propagation을 제거하기 위해 수동으로 remount하는 것으로, 이렇게 하면 쓰기가 가능해집니다. 절차는 **`/apex/com.android.conscrypt`**의 내용을 다른 위치로 복사하고, **`/apex/com.android.conscrypt`** 디렉토리를 언마운트하여 읽기 전용 제약을 제거한 뒤, 내용을 원래의 **`/apex`** 위치로 복원하는 것입니다. 이 과정은 시스템 크래시를 피하기 위해 빠르게 진행해야 합니다. 변경사항을 시스템 전반에 적용하려면 모든 애플리케이션을 사실상 재시작하는 `system_server`를 재시작하는 것이 권장됩니다.
```bash
# Create a separate temp directory, to hold the current certificates
# Otherwise, when we add the mount we can't read the current certs anymore.
mkdir -p -m 700 /data/local/tmp/tmp-ca-copy

# Copy out the existing certificates
cp /apex/com.android.conscrypt/cacerts/* /data/local/tmp/tmp-ca-copy/

# Create the in-memory mount on top of the system certs folder
mount -t tmpfs tmpfs /system/etc/security/cacerts

# Copy the existing certs back into the tmpfs, so we keep trusting them
mv /data/local/tmp/tmp-ca-copy/* /system/etc/security/cacerts/

# Copy our new cert in, so we trust that too
mv $CERTIFICATE_PATH /system/etc/security/cacerts/

# Update the perms & selinux context labels
chown root:root /system/etc/security/cacerts/*
chmod 644 /system/etc/security/cacerts/*
chcon u:object_r:system_file:s0 /system/etc/security/cacerts/*

# Deal with the APEX overrides, which need injecting into each namespace:

# First we get the Zygote process(es), which launch each app
ZYGOTE_PID=$(pidof zygote || true)
ZYGOTE64_PID=$(pidof zygote64 || true)
# N.b. some devices appear to have both!

# Apps inherit the Zygote's mounts at startup, so we inject here to ensure
# all newly started apps will see these certs straight away:
for Z_PID in "$ZYGOTE_PID" "$ZYGOTE64_PID"; do
if [ -n "$Z_PID" ]; then
nsenter --mount=/proc/$Z_PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
fi
done

# Then we inject the mount into all already running apps, so they
# too see these CA certs immediately:

# Get the PID of every process whose parent is one of the Zygotes:
APP_PIDS=$(
echo "$ZYGOTE_PID $ZYGOTE64_PID" | \
xargs -n1 ps -o 'PID' -P | \
grep -v PID
)

# Inject into the mount namespace of each of those apps:
for PID in $APP_PIDS; do
nsenter --mount=/proc/$PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts &
done
wait # Launched in parallel - wait for completion here

echo "System certificate injected"
```
### NSEnter를 통한 Bind-mounting

1. **쓰기 가능한 디렉터리 설정**: 처음에는 기존의 non-APEX 시스템 인증서 디렉터리 위에 `tmpfs`를 마운트하여 쓰기 가능한 디렉터리를 생성합니다. 이는 다음 명령어로 수행됩니다:
```bash
mount -t tmpfs tmpfs /system/etc/security/cacerts
```
2. **CA 인증서 준비**: 쓰기 가능한 디렉터리 설정 후, 사용하려는 CA 인증서를 이 디렉터리로 복사해야 합니다. 여기에는 `/apex/com.android.conscrypt/cacerts/`에서 기본 인증서를 복사하는 작업이 포함될 수 있습니다. 이러한 인증서들의 권한과 SELinux 라벨을 적절히 조정하는 것이 필수적입니다.
3. **Zygote를 위한 바인드 마운트**: `nsenter`를 사용하여 Zygote의 마운트 네임스페이스로 들어갑니다. Zygote는 Android 애플리케이션을 실행하는 프로세스이므로, 이후 시작되는 모든 애플리케이션이 새로 구성한 CA 인증서를 사용하도록 하기 위해 이 단계가 필요합니다. 사용되는 명령은:
```bash
nsenter --mount=/proc/$ZYGOTE_PID/ns/mnt -- /bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
```
이렇게 하면 새로 시작되는 모든 앱이 업데이트된 CA 인증서 설정을 따르도록 보장됩니다.

4. **실행 중인 앱에 변경사항 적용**: 이미 실행 중인 애플리케이션에 변경사항을 적용하려면, `nsenter`를 다시 사용하여 각 앱의 네임스페이스에 개별적으로 들어가 유사한 bind mount를 수행합니다. 필요한 명령은 다음과 같습니다:
```bash
nsenter --mount=/proc/$APP_PID/ns/mnt -- /bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
```
5. **대체 방법 - 소프트 리부트**: 대체 방법으로는 `init` 프로세스 (PID 1)에 bind mount를 수행한 후 `stop && start` 명령으로 운영체제를 소프트 리부트하는 방식이 있습니다. 이 방법은 변경사항을 모든 네임스페이스에 전파하여 실행 중인 각 앱을 개별적으로 처리할 필요를 없애줍니다. 그러나 재부팅의 불편함 때문에 일반적으로 선호되지는 않습니다.

## 참고 자료

- [Android 14: Install a system CA certificate on a rooted device](https://httptoolkit.com/blog/android-14-install-system-ca-certificate/)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)

{{#include ../../banners/hacktricks-training.md}}
