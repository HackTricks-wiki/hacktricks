# Burp Sertifikasını Yükle

{{#include ../../banners/hacktricks-training.md}}


## ADB ile sistem genelinde proxy

Global bir HTTP proxy yapılandırın, böylece tüm uygulamalar trafiği interceptor'ünüzden (Burp/mitmproxy) geçirir:
```bash
# Set proxy (device/emulator must reach your host IP)
adb shell settings put global http_proxy 192.168.1.2:8080

# Clear proxy
adb shell settings put global http_proxy :0
```
Tip: Burp'ta dinleyicinizi 0.0.0.0 adresine bağlayın, böylece LAN'daki cihazlar bağlanabilir (Proxy -> Options -> Proxy Listeners).

## Sanal Makinede

Öncelikle Burp'tan **DER** sertifikasını indirmeniz gerekiyor. Bunu _**Proxy**_ --> _**Options**_ --> _**Import / Export CA certificate**_ üzerinden yapabilirsiniz.

![](<../../images/image (367).png>)

**Der formatında sertifikayı dışa aktarın** ve bunu **dönüştürelim** ki **Android** **anlayabilsin.** Not: **AVD içindeki Android makinesinde Burp sertifikasını yapılandırabilmek için** bu makineyi **`-writable-system`** seçeneği ile **çalıştırmanız** gerekir.\
Örneğin şöyle çalıştırabilirsiniz:
```bash
C:\Users\<UserName>\AppData\Local\Android\Sdk\tools\emulator.exe -avd "AVD9" -http-proxy 192.168.1.12:8080 -writable-system
```
Sonra, **burps sertifikasını yapılandırmak için şunları yapın**:
```bash
openssl x509 -inform DER -in burp_cacert.der -out burp_cacert.pem
CERTHASHNAME="`openssl x509 -inform PEM -subject_hash_old -in burp_cacert.pem | head -1`.0"
mv burp_cacert.pem $CERTHASHNAME #Correct name
adb root && sleep 2 && adb remount #Allow to write on /syste
adb push $CERTHASHNAME /sdcard/ #Upload certificate
adb shell mv /sdcard/$CERTHASHNAME /system/etc/security/cacerts/ #Move to correct location
adb shell chmod 644 /system/etc/security/cacerts/$CERTHASHNAME #Assign privileges
adb reboot #Now, reboot the machine
```
Once the **makine yeniden başlatmayı tamamladıktan sonra** Burp sertifikası kullanılacaktır!

## Magisc Kullanımı

Eğer cihazınızı **Magisc ile root'ladıysanız** (örneğin bir emulator) ve Burp sertifikasını kurmak için önceki **adımları** izleyemiyorsanız çünkü **dosya sistemi salt okunur** ve yeniden yazılabilir şekilde remount edemiyorsanız, başka bir yol var.

Explained in [**this video**](https://www.youtube.com/watch?v=qQicUW0svB8) you need to:

1. **Install a CA certificate**: Sadece DER Burp sertifikasının uzantısını `.crt` olarak değiştirip mobil cihaza drag&drop yapın, böylece Downloads klasöründe saklanır ve `Install a certificate` -> `CA certificate` yolunu izleyin.

<figure><img src="../../images/image (53).png" alt="" width="164"><figcaption></figcaption></figure>

- Sertifikanın doğru şekilde saklandığını doğrulamak için `Trusted credentials` -> `USER` yoluna gidin.

<figure><img src="../../images/image (54).png" alt="" width="334"><figcaption></figcaption></figure>

2. **Make it System trusted**: Magisc modülü [MagiskTrustUserCerts](https://github.com/NVISOsecurity/MagiskTrustUserCerts) (.zip dosyası) indirin, telefonuza **drag&drop** yapın, telefondaki **Magics app** uygulamasında **`Modules`** bölümüne gidin, **`Install from storage`** seçeneğine tıklayın, `.zip` modülünü seçin ve kurulduktan sonra telefonu **reboot** edin:

<figure><img src="../../images/image (55).png" alt="" width="345"><figcaption></figcaption></figure>

- Yeniden başlattıktan sonra `Trusted credentials` -> `SYSTEM` yoluna gidip Postswigger cert'in orada olduğunu kontrol edin.

<figure><img src="../../images/image (56).png" alt="" width="314"><figcaption></figcaption></figure>

### Learn how to create a Magisc module

Check [https://medium.com/@justmobilesec/magisk-for-mobile-pentesting-rooting-android-devices-and-building-custom-modules-part-ii-22badc498437](https://medium.com/@justmobilesec/magisk-for-mobile-pentesting-rooting-android-devices-and-building-custom-modules-part-ii-22badc498437)

## Android 14 Sonrası

En son Android 14 sürümünde, sistem tarafından güvenilen Certificate Authority (CA) sertifikalarının yönetiminde önemli bir değişiklik gözlemlendi. Önceden bu sertifikalar **`/system/etc/security/cacerts/`** dizininde tutuluyor ve root ayrıcalığı olan kullanıcılar tarafından erişilip değiştirilebiliyordu; bu da sistem genelinde anında uygulanmalarına izin veriyordu. Ancak Android 14 ile birlikte saklama yeri **`/apex/com.android.conscrypt/cacerts`** olarak taşındı; bu dizin **`/apex`** yolunun içinde yer alır ve doğası gereği değiştirilemez (immutable).

**APEX cacerts yolunu** yazılabilir hale getirmek için remount yapma girişimleri başarısız olur; sistem bu tür işlemlere izin vermez. Dizini unmount etmeye veya geçici bir dosya sistemi (tmpfs) ile overlay yapmaya çalışmak bile immutability'yi aşmaz; uygulamalar dosya sistemi seviyesindeki değişikliklerden bağımsız olarak orijinal sertifika verilerine erişmeye devam eder. Bunun nedeni, **`/apex`** mount'ının PRIVATE propagation ile yapılandırılmış olmasıdır; bu da **`/apex`** içindeki değişikliklerin diğer süreçleri etkilememesini sağlar.

Android'in başlatılmasında `init` süreci işletim sistemini başlatırken aynı zamanda Zygote sürecini de başlatır. Bu süreç, uygulama süreçlerini yeni bir mount namespace ile başlatmaktan sorumludur ve bu namespace içinde private bir **`/apex`** mount bulunur; böylece bu dizindeki değişiklikler diğer süreçlerden izole edilir.

Yine de, **`/apex`** dizini içindeki sistem tarafından güvenilen CA sertifikalarını değiştirmek isteyenler için bir geçici çözüm vardır. Bu, **`/apex`**'in PRIVATE propagation özelliğini kaldıracak şekilde manuel olarak remount edilmesini içerir, böylece yazılabilir hale gelir. Süreç, **`/apex/com.android.conscrypt`** içeriğini başka bir konuma kopyalamayı, **`/apex/com.android.conscrypt`** dizinini unmount ederek salt okunur kısıtlamayı kaldırmayı ve ardından içeriği orijinal konumuna geri yüklemeyi kapsar. Bu yaklaşım sistem çökmesini önlemek için hızlı hareket etmeyi gerektirir. Değişikliklerin tüm sistemde uygulanmasını sağlamak için `system_server`'ı yeniden başlatmak tavsiye edilir; bu, tüm uygulamaları etkili bir şekilde yeniden başlatır ve sistemi tutarlı bir duruma getirir.
```bash
# Create a separate temp directory, to hold the current certificates
# Otherwise, when we add the mount we can't read the current certs anymore.
mkdir -p -m 700 /data/local/tmp/tmp-ca-copy

# Copy out the existing certificates
cp /apex/com.android.conscrypt/cacerts/* /data/local/tmp/tmp-ca-copy/

# Create the in-memory mount on top of the system certs folder
mount -t tmpfs tmpfs /system/etc/security/cacerts

# Copy the existing certs back into the tmpfs, so we keep trusting them
mv /data/local/tmp/tmp-ca-copy/* /system/etc/security/cacerts/

# Copy our new cert in, so we trust that too
mv $CERTIFICATE_PATH /system/etc/security/cacerts/

# Update the perms & selinux context labels
chown root:root /system/etc/security/cacerts/*
chmod 644 /system/etc/security/cacerts/*
chcon u:object_r:system_file:s0 /system/etc/security/cacerts/*

# Deal with the APEX overrides, which need injecting into each namespace:

# First we get the Zygote process(es), which launch each app
ZYGOTE_PID=$(pidof zygote || true)
ZYGOTE64_PID=$(pidof zygote64 || true)
# N.b. some devices appear to have both!

# Apps inherit the Zygote's mounts at startup, so we inject here to ensure
# all newly started apps will see these certs straight away:
for Z_PID in "$ZYGOTE_PID" "$ZYGOTE64_PID"; do
if [ -n "$Z_PID" ]; then
nsenter --mount=/proc/$Z_PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
fi
done

# Then we inject the mount into all already running apps, so they
# too see these CA certs immediately:

# Get the PID of every process whose parent is one of the Zygotes:
APP_PIDS=$(
echo "$ZYGOTE_PID $ZYGOTE64_PID" | \
xargs -n1 ps -o 'PID' -P | \
grep -v PID
)

# Inject into the mount namespace of each of those apps:
for PID in $APP_PIDS; do
nsenter --mount=/proc/$PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts &
done
wait # Launched in parallel - wait for completion here

echo "System certificate injected"
```
### Bind-mounting through NSEnter

1. **Setting Up a Writable Directory**: Başlangıçta, yazılabilir bir dizin mevcut non-APEX sistem sertifika dizini üzerine bir `tmpfs` mounting yapılarak oluşturulur. Bu, aşağıdaki komutla gerçekleştirilir:
```bash
mount -t tmpfs tmpfs /system/etc/security/cacerts
```
2. **CA Sertifikalarını Hazırlama**: Yazılabilir dizinin ayarlanmasının ardından, kullanılmak istenen CA sertifikaları bu dizine kopyalanmalıdır. Bu işlem, varsayılan sertifikaların `/apex/com.android.conscrypt/cacerts/` dizininden kopyalanmasını içerebilir. Bu sertifikaların izinlerinin ve SELinux etiketlerinin uygun şekilde ayarlanması şarttır.
3. **Bind Mounting for Zygote**: `nsenter` kullanılarak, Zygote'nin mount namespace'ine girilir. Zygote, Android uygulamalarını başlatmaktan sorumlu proses olduğundan, bundan sonra başlatılacak tüm uygulamaların yeni yapılandırılmış CA sertifikalarını kullanmasını sağlamak için bu adım gereklidir. Kullanılan komut şudur:
```bash
nsenter --mount=/proc/$ZYGOTE_PID/ns/mnt -- /bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
```
Bu, başlatılan her yeni uygulamanın güncellenmiş CA sertifikaları yapılandırmasına uyacağını garanti eder.

4. **Çalışan Uygulamalara Değişiklikleri Uygulama**: Zaten çalışmakta olan uygulamalara değişiklikleri uygulamak için, `nsenter` tekrar kullanılarak her uygulamanın namespace'ine ayrı ayrı girilir ve benzer bir bind mount yapılır. Gerekli komut şudur:
```bash
nsenter --mount=/proc/$APP_PID/ns/mnt -- /bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
```
5. **Alternatif Yaklaşım - Soft Reboot**: Alternatif bir yöntem, bind mount işlemini `init` sürecinde (PID 1) gerçekleştirmek ve ardından işletim sistemini `stop && start` komutlarıyla soft reboot yapmaktır. Bu yaklaşım, değişiklikleri tüm namespaces genelinde yayar ve her bir çalışan uygulamayı ayrı ayrı ele alma ihtiyacını ortadan kaldırır. Ancak, yeniden başlatmanın yarattığı rahatsızlık nedeniyle bu yöntem genellikle daha az tercih edilir.

## Referanslar

- [Android 14: Install a system CA certificate on a rooted device](https://httptoolkit.com/blog/android-14-install-system-ca-certificate/)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)

{{#include ../../banners/hacktricks-training.md}}
