# Instalirajte Burp Sertifikat

{{#include ../../banners/hacktricks-training.md}}


## Na Virtuelnoj Mašini

Prvo što treba da uradite je da preuzmete Der sertifikat sa Burp-a. To možete uraditi u _**Proxy**_ --> _**Options**_ --> _**Import / Export CA certificate**_

![](<../../images/image (367).png>)

**Izvezite sertifikat u Der formatu** i hajde da ga **transformišemo** u oblik koji **Android** može da **razume.** Imajte na umu da **da biste konfigurisali burp sertifikat na Android mašini u AVD** morate da **pokrenete** ovu mašinu **sa** **`-writable-system`** opcijom.\
Na primer, možete je pokrenuti ovako:
```bash
C:\Users\<UserName>\AppData\Local\Android\Sdk\tools\emulator.exe -avd "AVD9" -http-proxy 192.168.1.12:8080 -writable-system
```
Zatim, da **konfigurišete burp sertifikat uradite**:
```bash
openssl x509 -inform DER -in burp_cacert.der -out burp_cacert.pem
CERTHASHNAME="`openssl x509 -inform PEM -subject_hash_old -in burp_cacert.pem | head -1`.0"
mv burp_cacert.pem $CERTHASHNAME #Correct name
adb root && sleep 2 && adb remount #Allow to write on /syste
adb push $CERTHASHNAME /sdcard/ #Upload certificate
adb shell mv /sdcard/$CERTHASHNAME /system/etc/security/cacerts/ #Move to correct location
adb shell chmod 644 /system/etc/security/cacerts/$CERTHASHNAME #Assign privileges
adb reboot #Now, reboot the machine
```
Jednom kada se **mašina ponovo pokrene**, Burp sertifikat će biti u upotrebi!

## Korišćenje Magisc

Ako ste **rootovali svoj uređaj sa Magisc** (možda emulator), i ne možete da **pratite** prethodne **korake** za instalaciju Burp certifikata jer je **fajl sistem samo za čitanje** i ne možete ga ponovo montirati kao zapisiv, postoji drugi način.

Objašnjeno u [**ovom videu**](https://www.youtube.com/watch?v=qQicUW0svB8) potrebno je da:

1. **Instalirate CA sertifikat**: Samo **prevucite i ispustite** DER Burp sertifikat **menjajući ekstenziju** u `.crt` na mobilnom uređaju tako da se sačuva u Downloads folderu i idite na `Instaliraj sertifikat` -> `CA sertifikat`

<figure><img src="../../images/image (53).png" alt="" width="164"><figcaption></figcaption></figure>

- Proverite da li je sertifikat ispravno sačuvan odlaskom na `Trusted credentials` -> `USER`

<figure><img src="../../images/image (54).png" alt="" width="334"><figcaption></figcaption></figure>

2. **Učinite ga sistemski pouzdanim**: Preuzmite Magisc modul [MagiskTrustUserCerts](https://github.com/NVISOsecurity/MagiskTrustUserCerts) (zip fajl), **prevucite i ispustite** ga na telefon, idite na **Magics aplikaciju** na telefonu u **`Modules`** sekciju, kliknite na **`Install from storage`**, izaberite `.zip` modul i nakon instalacije **ponovo pokrenite** telefon:

<figure><img src="../../images/image (55).png" alt="" width="345"><figcaption></figcaption></figure>

- Nakon ponovnog pokretanja, idite na `Trusted credentials` -> `SYSTEM` i proverite da li je Postswigger sertifikat tu

<figure><img src="../../images/image (56).png" alt="" width="314"><figcaption></figcaption></figure>

## Post Android 14

U najnovijem izdanju Android 14, primećen je značajan pomak u upravljanju sistemski pouzdanim sertifikatima sertifikacione vlasti (CA). Prethodno su ovi sertifikati bili smešteni u **`/system/etc/security/cacerts/`**, dostupni i modifikovani od strane korisnika sa root privilegijama, što je omogućavalo trenutnu primenu širom sistema. Međutim, sa Android 14, lokacija za skladištenje je premestena u **`/apex/com.android.conscrypt/cacerts`**, direktorijum unutar **`/apex`** putanje, koji je po prirodi nepromenljiv.

Pokušaji ponovnog montiranja **APEX cacerts putanje** kao zapisive se susreću sa neuspehom, jer sistem ne dozvoljava takve operacije. Čak ni pokušaji da se demontira ili preklopi direktorijum sa privremenim fajl sistemom (tmpfs) ne zaobilaze nepromenljivost; aplikacije i dalje pristupaju originalnim podacima sertifikata bez obzira na promene na nivou fajl sistema. Ova otpornost je rezultat **`/apex`** montiranja koje je konfigurisano sa PRIVATE propagacijom, osiguravajući da bilo kakve izmene unutar **`/apex`** direktorijuma ne utiču na druge procese.

Inicijalizacija Android-a uključuje `init` proces, koji, prilikom pokretanja operativnog sistema, takođe pokreće Zygote proces. Ovaj proces je odgovoran za pokretanje aplikacionih procesa sa novim montiranim imenskim prostorom koji uključuje privatno **`/apex`** montiranje, čime se izoluje promene u ovom direktorijumu od drugih procesa.

Ipak, postoji rešenje za one koji trebaju da modifikuju sistemski pouzdane CA sertifikate unutar **`/apex`** direktorijuma. Ovo uključuje ručno ponovo montiranje **`/apex`** kako bi se uklonila PRIVATE propagacija, čime se omogućava zapisivanje. Proces uključuje kopiranje sadržaja **`/apex/com.android.conscrypt`** na drugo mesto, demontiranje **`/apex/com.android.conscrypt`** direktorijuma kako bi se eliminisala ograničenja samo za čitanje, a zatim vraćanje sadržaja na njihovu originalnu lokaciju unutar **`/apex`**. Ovaj pristup zahteva brzu akciju kako bi se izbegli padovi sistema. Da bi se osigurala sistemska primena ovih izmena, preporučuje se ponovo pokretanje `system_server`, što efikasno ponovo pokreće sve aplikacije i dovodi sistem u dosledno stanje.
```bash
# Create a separate temp directory, to hold the current certificates
# Otherwise, when we add the mount we can't read the current certs anymore.
mkdir -p -m 700 /data/local/tmp/tmp-ca-copy

# Copy out the existing certificates
cp /apex/com.android.conscrypt/cacerts/* /data/local/tmp/tmp-ca-copy/

# Create the in-memory mount on top of the system certs folder
mount -t tmpfs tmpfs /system/etc/security/cacerts

# Copy the existing certs back into the tmpfs, so we keep trusting them
mv /data/local/tmp/tmp-ca-copy/* /system/etc/security/cacerts/

# Copy our new cert in, so we trust that too
mv $CERTIFICATE_PATH /system/etc/security/cacerts/

# Update the perms & selinux context labels
chown root:root /system/etc/security/cacerts/*
chmod 644 /system/etc/security/cacerts/*
chcon u:object_r:system_file:s0 /system/etc/security/cacerts/*

# Deal with the APEX overrides, which need injecting into each namespace:

# First we get the Zygote process(es), which launch each app
ZYGOTE_PID=$(pidof zygote || true)
ZYGOTE64_PID=$(pidof zygote64 || true)
# N.b. some devices appear to have both!

# Apps inherit the Zygote's mounts at startup, so we inject here to ensure
# all newly started apps will see these certs straight away:
for Z_PID in "$ZYGOTE_PID" "$ZYGOTE64_PID"; do
if [ -n "$Z_PID" ]; then
nsenter --mount=/proc/$Z_PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
fi
done

# Then we inject the mount into all already running apps, so they
# too see these CA certs immediately:

# Get the PID of every process whose parent is one of the Zygotes:
APP_PIDS=$(
echo "$ZYGOTE_PID $ZYGOTE64_PID" | \
xargs -n1 ps -o 'PID' -P | \
grep -v PID
)

# Inject into the mount namespace of each of those apps:
for PID in $APP_PIDS; do
nsenter --mount=/proc/$PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts &
done
wait # Launched in parallel - wait for completion here

echo "System certificate injected"
```
### Bind-mounting through NSEnter

1. **Postavljanje upisive direktorijuma**: U početku, upisivi direktorijum se uspostavlja montiranjem `tmpfs` preko postojećeg direktorijuma sa sistemskim sertifikatima koji nije APEX. Ovo se postiže sledećom komandom:
```bash
mount -t tmpfs tmpfs /system/etc/security/cacerts
```
2. **Priprema CA sertifikata**: Nakon postavljanja upisive direktorijuma, CA sertifikate koje nameravate da koristite treba kopirati u ovaj direktorijum. To može uključivati kopiranje podrazumevanih sertifikata iz `/apex/com.android.conscrypt/cacerts/`. Važno je prilagoditi dozvole i SELinux oznake ovih sertifikata u skladu s tim.  
3. **Bind Mounting za Zygote**: Korišćenjem `nsenter`, ulazi se u Zygote-ov mount namespace. Zygote, kao proces odgovoran za pokretanje Android aplikacija, zahteva ovaj korak kako bi se osiguralo da sve aplikacije pokrenute od sada koriste novo konfigurisane CA sertifikate. Koristi se komanda:
```bash
nsenter --mount=/proc/$ZYGOTE_PID/ns/mnt -- /bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
```
Ovo osigurava da će svaka nova aplikacija koja se pokrene poštovati ažuriranu postavku CA sertifikata.

4. **Primena promena na aktivnim aplikacijama**: Da bi se promene primenile na već pokrenutim aplikacijama, `nsenter` se ponovo koristi za ulazak u prostor imena svake aplikacije pojedinačno i izvršavanje sličnog bind mount-a. Neophodna komanda je:
```bash
nsenter --mount=/proc/$APP_PID/ns/mnt -- /bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
```
5. **Alternativni pristup - Soft Reboot**: Alternativna metoda uključuje izvođenje bind mount-a na `init` procesu (PID 1) nakon čega sledi soft reboot operativnog sistema sa `stop && start` komandama. Ovaj pristup bi propagirao promene kroz sve namespace-ove, izbegavajući potrebu da se pojedinačno obrađuje svaka aplikacija koja se izvršava. Međutim, ova metoda se generalno manje preferira zbog neprijatnosti reboot-a.

## Reference

- [https://httptoolkit.com/blog/android-14-install-system-ca-certificate/](https://httptoolkit.com/blog/android-14-install-system-ca-certificate/)


{{#include ../../banners/hacktricks-training.md}}
