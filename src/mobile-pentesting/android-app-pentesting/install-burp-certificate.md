# Εγκατάσταση του πιστοποιητικού Burp

{{#include ../../banners/hacktricks-training.md}}


## Proxy σε επίπεδο συστήματος μέσω ADB

Διαμορφώστε έναν παγκόσμιο HTTP proxy ώστε όλες οι εφαρμογές να δρομολογούν την κίνηση μέσω του interceptor σας (Burp/mitmproxy):
```bash
# Set proxy (device/emulator must reach your host IP)
adb shell settings put global http_proxy 192.168.1.2:8080

# Clear proxy
adb shell settings put global http_proxy :0
```
Συμβουλή: Στο Burp, bind τον listener σε 0.0.0.0 ώστε οι συσκευές στο LAN να μπορούν να συνδεθούν (Proxy -> Options -> Proxy Listeners).

## Σε μια εικονική μηχανή

Πρώτα απ' όλα χρειάζεται να κατεβάσετε το πιστοποιητικό Der από το Burp. Μπορείτε να το κάνετε από _**Proxy**_ --> _**Options**_ --> _**Import / Export CA certificate**_

![](<../../images/image (367).png>)

**Export the certificate in Der format** και ας το **transform** σε μια μορφή που το **Android** θα είναι σε θέση να **understand.** Σημειώστε ότι **in order to configure the burp certificate on the Android machine in AVD** χρειάζεται να **run** αυτή τη μηχανή **with** την επιλογή **`-writable-system`**.\\
Για παράδειγμα μπορείτε να το τρέξετε ως:
```bash
C:\Users\<UserName>\AppData\Local\Android\Sdk\tools\emulator.exe -avd "AVD9" -http-proxy 192.168.1.12:8080 -writable-system
```
Στη συνέχεια, για να **ρυθμίσετε το πιστοποιητικό του burps**, κάντε:
```bash
openssl x509 -inform DER -in burp_cacert.der -out burp_cacert.pem
CERTHASHNAME="`openssl x509 -inform PEM -subject_hash_old -in burp_cacert.pem | head -1`.0"
mv burp_cacert.pem $CERTHASHNAME #Correct name
adb root && sleep 2 && adb remount #Allow to write on /syste
adb push $CERTHASHNAME /sdcard/ #Upload certificate
adb shell mv /sdcard/$CERTHASHNAME /system/etc/security/cacerts/ #Move to correct location
adb shell chmod 644 /system/etc/security/cacerts/$CERTHASHNAME #Assign privileges
adb reboot #Now, reboot the machine
```
Μόλις το **machine finish rebooting** το πιστοποιητικό burp θα χρησιμοποιείται από αυτό!

## Χρήση του Magisc

Αν **rooted τη συσκευή σας με Magisc** (ίσως an emulator), και **δεν μπορείτε να ακολουθήσετε** τα προηγούμενα **βήματα** για να εγκαταστήσετε το Burp cert επειδή το **filesystem είναι read-only** και δεν μπορείτε να remount το filesystem ως writable, υπάρχει άλλη λύση.

Όπως εξηγείται στο [**αυτό το βίντεο**](https://www.youtube.com/watch?v=qQicUW0svB8) πρέπει να:

1. **Εγκατάσταση πιστοποιητικού CA**: Απλώς **drag&drop** το DER Burp certificate αλλάζοντας την επέκταση σε `.crt` στο κινητό ώστε να αποθηκευτεί στον φάκελο Downloads και πηγαίνετε σε `Install a certificate` -> `CA certificate`

<figure><img src="../../images/image (53).png" alt="" width="164"><figcaption></figcaption></figure>

- Ελέγξτε ότι το πιστοποιητικό αποθηκεύτηκε σωστά πηγαίνοντας σε `Trusted credentials` -> `USER`

<figure><img src="../../images/image (54).png" alt="" width="334"><figcaption></figcaption></figure>

2. **Make it System trusted**: Κατεβάστε το Magisc module [MagiskTrustUserCerts](https://github.com/NVISOsecurity/MagiskTrustUserCerts) (αρχείο .zip), **drag&drop it** στο τηλέφωνο, ανοίξτε την **Magics app** στο τηλέφωνο στην ενότητα **`Modules`**, κάντε κλικ στο **`Install from storage`**, επιλέξτε το `.zip` module και μόλις εγκατασταθεί **reboot** το τηλέφωνο:

<figure><img src="../../images/image (55).png" alt="" width="345"><figcaption></figcaption></figure>

- Μετά την επανεκκίνηση, πηγαίνετε σε `Trusted credentials` -> `SYSTEM` και ελέγξτε ότι το Postswigger cert υπάρχει εκεί

<figure><img src="../../images/image (56).png" alt="" width="314"><figcaption></figcaption></figure>

### Μάθετε πώς να δημιουργήσετε ένα Magisc module

Δείτε [https://medium.com/@justmobilesec/magisk-for-mobile-pentesting-rooting-android-devices-and-building-custom-modules-part-ii-22badc498437](https://medium.com/@justmobilesec/magisk-for-mobile-pentesting-rooting-android-devices-and-building-custom-modules-part-ii-22badc498437)

## Post Android 14

Στην πιο πρόσφατη έκδοση Android 14 παρατηρήθηκε μια σημαντική αλλαγή στον τρόπο διαχείρισης των system-trusted Certificate Authority (CA) πιστοποιητικών. Προηγουμένως, αυτά τα πιστοποιητικά βρίσκονταν στο **`/system/etc/security/cacerts/`**, προσβάσιμα και τροποποιήσιμα από χρήστες με root προνόμια, επιτρέποντας την άμεση εφαρμογή τους σε όλο το σύστημα. Ωστόσο, με το Android 14, η θέση αποθήκευσης μεταφέρθηκε σε **`/apex/com.android.conscrypt/cacerts`**, έναν κατάλογο μέσα στο **`/apex`** path, ο οποίος είναι αμετάβλητος από τη φύση του.

Οι προσπάθειες να remount το APEX cacerts path ως writable αποτυγχάνουν, καθώς το σύστημα δεν επιτρέπει τέτοιες ενέργειες. Ακόμα και οι προσπάθειες να unmount ή να overlay τον κατάλογο με ένα προσωρινό file system (tmpfs) δεν παρακάμπτουν την αμεταβλητότητα· οι εφαρμογές εξακολουθούν να προσπελαύνουν τα αρχικά δεδομένα των πιστοποιητικών ανεξάρτητα από αλλαγές στο επίπεδο του file system. Αυτή η ανθεκτικότητα οφείλεται στο ότι το mount του **`/apex`** έχει ρυθμιστεί με PRIVATE propagation, διασφαλίζοντας ότι οποιεσδήποτε τροποποιήσεις μέσα στον κατάλογο **`/apex`** δεν επηρεάζουν άλλες διεργασίες.

Η εκκίνηση του Android περιλαμβάνει τη διεργασία `init` που, κατά την εκκίνηση του λειτουργικού, ξεκινά επίσης τη διεργασία Zygote. Αυτή η διαδικασία είναι υπεύθυνη για την εκκίνηση των διεργασιών εφαρμογών με ένα νέο mount namespace που περιλαμβάνει ένα ιδιωτικό mount **`/apex`**, απομονώνοντας έτσι τις αλλαγές σε αυτόν τον κατάλογο από άλλες διεργασίες.

Παρόλα αυτά, υπάρχει ένας τρόπος παράκαμψης για όσους χρειάζεται να τροποποιήσουν τα system-trusted CA πιστοποιητικά μέσα στον κατάλογο **`/apex`**. Αυτό περιλαμβάνει το χειροκίνητο remount του **`/apex`** για να αφαιρεθεί το PRIVATE propagation, καθιστώντας το writable. Η διαδικασία περιλαμβάνει την αντιγραφή του περιεχομένου του **`/apex/com.android.conscrypt`** σε άλλη τοποθεσία, το unmount του **`/apex/com.android.conscrypt`** για να αφαιρεθεί ο περιορισμός read-only, και στη συνέχεια την επαναφορά του περιεχομένου στην αρχική του θέση μέσα στο **`/apex`**. Αυτή η προσέγγιση απαιτεί γρήγορη εκτέλεση για να αποφευχθεί η κατάρρευση του συστήματος. Για να διασφαλιστεί η εφαρμογή των αλλαγών σε επίπεδο όλου του συστήματος, συνιστάται η επανεκκίνηση του `system_server`, που ουσιαστικά επανεκκινεί όλες τις εφαρμογές και επαναφέρει το σύστημα σε συνεπή κατάσταση.
```bash
# Create a separate temp directory, to hold the current certificates
# Otherwise, when we add the mount we can't read the current certs anymore.
mkdir -p -m 700 /data/local/tmp/tmp-ca-copy

# Copy out the existing certificates
cp /apex/com.android.conscrypt/cacerts/* /data/local/tmp/tmp-ca-copy/

# Create the in-memory mount on top of the system certs folder
mount -t tmpfs tmpfs /system/etc/security/cacerts

# Copy the existing certs back into the tmpfs, so we keep trusting them
mv /data/local/tmp/tmp-ca-copy/* /system/etc/security/cacerts/

# Copy our new cert in, so we trust that too
mv $CERTIFICATE_PATH /system/etc/security/cacerts/

# Update the perms & selinux context labels
chown root:root /system/etc/security/cacerts/*
chmod 644 /system/etc/security/cacerts/*
chcon u:object_r:system_file:s0 /system/etc/security/cacerts/*

# Deal with the APEX overrides, which need injecting into each namespace:

# First we get the Zygote process(es), which launch each app
ZYGOTE_PID=$(pidof zygote || true)
ZYGOTE64_PID=$(pidof zygote64 || true)
# N.b. some devices appear to have both!

# Apps inherit the Zygote's mounts at startup, so we inject here to ensure
# all newly started apps will see these certs straight away:
for Z_PID in "$ZYGOTE_PID" "$ZYGOTE64_PID"; do
if [ -n "$Z_PID" ]; then
nsenter --mount=/proc/$Z_PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
fi
done

# Then we inject the mount into all already running apps, so they
# too see these CA certs immediately:

# Get the PID of every process whose parent is one of the Zygotes:
APP_PIDS=$(
echo "$ZYGOTE_PID $ZYGOTE64_PID" | \
xargs -n1 ps -o 'PID' -P | \
grep -v PID
)

# Inject into the mount namespace of each of those apps:
for PID in $APP_PIDS; do
nsenter --mount=/proc/$PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts &
done
wait # Launched in parallel - wait for completion here

echo "System certificate injected"
```
### Bind-mounting μέσω NSEnter

1. **Ρύθμιση εγγράψιμου καταλόγου**: Αρχικά, δημιουργείται ένας εγγράψιμος κατάλογος κάνοντας mount ένα `tmpfs` πάνω στον υπάρχοντα non-APEX κατάλογο πιστοποιητικών συστήματος. Αυτό επιτυγχάνεται με την ακόλουθη εντολή:
```bash
mount -t tmpfs tmpfs /system/etc/security/cacerts
```
2. **Preparing CA Certificates**: Μετά τη ρύθμιση του εγγράψιμου καταλόγου, τα CA certificates που προτίθεστε να χρησιμοποιήσετε πρέπει να αντιγραφούν σε αυτόν τον κατάλογο. Αυτό μπορεί να περιλαμβάνει την αντιγραφή των προεπιλεγμένων certificates από `/apex/com.android.conscrypt/cacerts/`. Είναι απαραίτητο να προσαρμόσετε ανάλογα τα δικαιώματα (permissions) και τις SELinux ετικέτες αυτών των certificates.
3. **Bind Mounting for Zygote**: Χρησιμοποιώντας `nsenter`, εισέρχεστε στο mount namespace του Zygote. Το Zygote, ως η διεργασία υπεύθυνη για την εκκίνηση των Android εφαρμογών, απαιτεί αυτό το βήμα ώστε να διασφαλιστεί ότι όλες οι εφαρμογές που θα ξεκινούν από εδώ και πέρα θα χρησιμοποιούν τα νεοδιαμορφωμένα CA certificates. Η εντολή που χρησιμοποιείται είναι:
```bash
nsenter --mount=/proc/$ZYGOTE_PID/ns/mnt -- /bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
```
Αυτό εξασφαλίζει ότι κάθε νέα εφαρμογή που ξεκινάει θα συμμορφώνεται με τη ενημερωμένη ρύθμιση των πιστοποιητικών CA.

4. **Εφαρμογή αλλαγών σε εφαρμογές που τρέχουν**: Για να εφαρμόσετε τις αλλαγές σε ήδη τρέχουσες εφαρμογές, χρησιμοποιείται ξανά το `nsenter` για να εισέλθετε στο namespace κάθε εφαρμογής ξεχωριστά και να εκτελέσετε ένα αντίστοιχο bind mount. Η απαραίτητη εντολή είναι:
```bash
nsenter --mount=/proc/$APP_PID/ns/mnt -- /bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
```
5. **Εναλλακτική Προσέγγιση - Soft Reboot**: Μια εναλλακτική μέθοδος περιλαμβάνει την εκτέλεση του bind mount στη διαδικασία `init` (PID 1), ακολουθούμενη από ένα soft reboot του λειτουργικού συστήματος με τις εντολές `stop && start`. Αυτή η προσέγγιση θα διαδώσει τις αλλαγές σε όλα τα namespaces, αποφεύγοντας την ανάγκη να απευθυνθείτε ξεχωριστά σε κάθε running app. Ωστόσο, αυτή η μέθοδος γενικά θεωρείται λιγότερο προτιμητέα λόγω της ταλαιπωρίας του rebooting.

## Αναφορές

- [Android 14: Install a system CA certificate on a rooted device](https://httptoolkit.com/blog/android-14-install-system-ca-certificate/)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)

{{#include ../../banners/hacktricks-training.md}}
