# Instalacija Burp sertifikata

{{#include ../../banners/hacktricks-training.md}}


## Sistemski proxy putem ADB

Konfigurišite globalni HTTP proxy tako da sve aplikacije usmeravaju saobraćaj kroz vaš interceptor (Burp/mitmproxy):
```bash
# Set proxy (device/emulator must reach your host IP)
adb shell settings put global http_proxy 192.168.1.2:8080

# Clear proxy
adb shell settings put global http_proxy :0
```
Napomena: U Burp-u vežite vaš listener na 0.0.0.0 tako da se uređaji na LAN mogu povezati (Proxy -> Options -> Proxy Listeners).

## Na virtualnoj mašini

Prvo treba da preuzmete Der sertifikat iz Burp-a. To možete uraditi u _**Proxy**_ --> _**Options**_ --> _**Import / Export CA certificate**_

![](<../../images/image (367).png>)

**Izvezite sertifikat u Der formatu** i pretvorimo ga u oblik koji će **Android** moći da **razume.** Imajte na umu da, **da biste konfigurisali Burp sertifikat na Android mašini u AVD**, morate **pokrenuti** ovu mašinu **sa** opcijom **`-writable-system`**.\
Na primer, možete je pokrenuti ovako:
```bash
C:\Users\<UserName>\AppData\Local\Android\Sdk\tools\emulator.exe -avd "AVD9" -http-proxy 192.168.1.12:8080 -writable-system
```
Zatim, da **konfigurišete burp sertifikat, uradite**:
```bash
openssl x509 -inform DER -in burp_cacert.der -out burp_cacert.pem
CERTHASHNAME="`openssl x509 -inform PEM -subject_hash_old -in burp_cacert.pem | head -1`.0"
mv burp_cacert.pem $CERTHASHNAME #Correct name
adb root && sleep 2 && adb remount #Allow to write on /syste
adb push $CERTHASHNAME /sdcard/ #Upload certificate
adb shell mv /sdcard/$CERTHASHNAME /system/etc/security/cacerts/ #Move to correct location
adb shell chmod 644 /system/etc/security/cacerts/$CERTHASHNAME #Assign privileges
adb reboot #Now, reboot the machine
```
Once the **machine finish rebooting** the burp certificate will be in use by it!

## Using Magisc

If you **rooted your device with Magisc** (maybe an emulator), and you **can't follow** the previous **steps** to install the Burp cert because the **filesystem is read-only** and you cannot remount it writable, there is another way.

Explained in [**this video**](https://www.youtube.com/watch?v=qQicUW0svB8) you need to:

1. **Instalirajte CA sertifikat**: Samo **drag&drop** DER Burp sertifikat menjajući ekstenziju u `.crt` na mobilnom uređaju tako da bude sačuvan u Downloads folderu i idite na `Install a certificate` -> `CA certificate`

<figure><img src="../../images/image (53).png" alt="" width="164"><figcaption></figcaption></figure>

- Proverite da li je sertifikat ispravno sačuvan odlaskom na `Trusted credentials` -> `USER`

<figure><img src="../../images/image (54).png" alt="" width="334"><figcaption></figcaption></figure>

2. **Učinite ga sistemski poverljivim**: Preuzmite Magisc modul [MagiskTrustUserCerts](https://github.com/NVISOsecurity/MagiskTrustUserCerts) (fajl .zip), **drag&drop** ga na telefon, otvorite **Magics app** na telefonu u sekciju **`Modules`**, kliknite na **`Install from storage`**, izaberite `.zip` modul i nakon instalacije **reboot-ujte** telefon:

<figure><img src="../../images/image (55).png" alt="" width="345"><figcaption></figcaption></figure>

- Nakon reboot-a, idite na `Trusted credentials` -> `SYSTEM` i proverite da li je Postswigger cert tamo

<figure><img src="../../images/image (56).png" alt="" width="314"><figcaption></figcaption></figure>

### Learn how to create a Magisc module

Pogledajte [https://medium.com/@justmobilesec/magisk-for-mobile-pentesting-rooting-android-devices-and-building-custom-modules-part-ii-22badc498437](https://medium.com/@justmobilesec/magisk-for-mobile-pentesting-rooting-android-devices-and-building-custom-modules-part-ii-22badc498437)

## Post Android 14

U najnovijem izdanju Android 14 primećena je značajna promena u načinu rukovanja sistemski poverenim Certificate Authority (CA) sertifikatima. Ranije su ti sertifikati bili smešteni u **`/system/etc/security/cacerts/`**, dostupni i izmenljivi korisnicima sa root privilegijama, što je omogućavalo njihovu momentalnu primenu u sistemu. Međutim, sa Android 14 lokacija skladišta je premištena na **`/apex/com.android.conscrypt/cacerts`**, direktorijum unutar **`/apex`** putanje, koji je po prirodi neizmenljiv.

Pokušaji da se remount-uje **APEX cacerts path** kao writable nailaze na neuspeh, jer sistem ne dozvoljava takve operacije. Čak ni pokušaji da se direktorijum unmount-uje ili prekriva privremenim fajl sistemom (tmpfs) ne zaobilaze neizmenljivost; aplikacije nastavljaju da pristupaju originalnim podacima sertifikata bez obzira na promene na nivou fajl sistema. Ova otpornost je posledica toga što je mount za **`/apex`** konfigurisana sa PRIVATE propagation, što osigurava da bilo kakve izmene unutar **`/apex`** direktorijuma ne utiču na druge procese.

Inicijalizacija Android-a uključuje `init` proces koji, pri pokretanju operativnog sistema, takođe pokreće Zygote proces. Ovaj proces je odgovoran za pokretanje procesâ aplikacija sa novim mount namespace-om koji uključuje privatni **`/apex`** mount, čime se izoluje promene u ovom direktorijumu od ostalih procesa.

Ipak, postoji zaobilazno rešenje za one koji treba da modifikuju sistemski poverene CA sertifikate unutar **`/apex`** direktorijuma. To podrazumeva manuelno remount-ovanje **`/apex`** kako bi se uklonila PRIVATE propagation, čime postaje writable. Proces uključuje kopiranje sadržaja **`/apex/com.android.conscrypt`** na drugo mesto, unmount-ovanje **`/apex/com.android.conscrypt`** direktorijuma da bi se uklonio read-only ograničenje, a zatim vraćanje sadržaja na originalnu lokaciju unutar **`/apex`**. Ovaj pristup zahteva brzu akciju kako bi se izbegli padovi sistema. Da bi se osiguralo da promene važe system-wide, preporučuje se restartovanje `system_server`, što efektivno restartuje sve aplikacije i dovodi sistem u konzistentno stanje.
```bash
# Create a separate temp directory, to hold the current certificates
# Otherwise, when we add the mount we can't read the current certs anymore.
mkdir -p -m 700 /data/local/tmp/tmp-ca-copy

# Copy out the existing certificates
cp /apex/com.android.conscrypt/cacerts/* /data/local/tmp/tmp-ca-copy/

# Create the in-memory mount on top of the system certs folder
mount -t tmpfs tmpfs /system/etc/security/cacerts

# Copy the existing certs back into the tmpfs, so we keep trusting them
mv /data/local/tmp/tmp-ca-copy/* /system/etc/security/cacerts/

# Copy our new cert in, so we trust that too
mv $CERTIFICATE_PATH /system/etc/security/cacerts/

# Update the perms & selinux context labels
chown root:root /system/etc/security/cacerts/*
chmod 644 /system/etc/security/cacerts/*
chcon u:object_r:system_file:s0 /system/etc/security/cacerts/*

# Deal with the APEX overrides, which need injecting into each namespace:

# First we get the Zygote process(es), which launch each app
ZYGOTE_PID=$(pidof zygote || true)
ZYGOTE64_PID=$(pidof zygote64 || true)
# N.b. some devices appear to have both!

# Apps inherit the Zygote's mounts at startup, so we inject here to ensure
# all newly started apps will see these certs straight away:
for Z_PID in "$ZYGOTE_PID" "$ZYGOTE64_PID"; do
if [ -n "$Z_PID" ]; then
nsenter --mount=/proc/$Z_PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
fi
done

# Then we inject the mount into all already running apps, so they
# too see these CA certs immediately:

# Get the PID of every process whose parent is one of the Zygotes:
APP_PIDS=$(
echo "$ZYGOTE_PID $ZYGOTE64_PID" | \
xargs -n1 ps -o 'PID' -P | \
grep -v PID
)

# Inject into the mount namespace of each of those apps:
for PID in $APP_PIDS; do
nsenter --mount=/proc/$PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts &
done
wait # Launched in parallel - wait for completion here

echo "System certificate injected"
```
### Bind-mounting through NSEnter

1. **Setting Up a Writable Directory**: Inicialno se uspostavlja direktorijum za pisanje montiranjem `tmpfs` preko postojećeg non-APEX system certificate directory. Ovo se postiže sledećom komandom:
```bash
mount -t tmpfs tmpfs /system/etc/security/cacerts
```
2. **Priprema CA sertifikata**: Nakon kreiranja writable direktorijuma, CA sertifikati koje nameravate da koristite treba da se kopiraju u taj direktorijum. Ovo može uključivati kopiranje podrazumevanih sertifikata iz `/apex/com.android.conscrypt/cacerts/`. Važno je odgovarajuće podesiti dozvole i SELinux oznake ovih sertifikata.
3. **Bind Mounting za Zygote**: Korišćenjem `nsenter` ulazi se u mount namespace Zygote-a. Zygote, proces koji je odgovoran za pokretanje Android aplikacija, zahteva ovaj korak kako bi se osiguralo da sve aplikacije pokrenute ubuduće koriste novo konfigurisane CA sertifikate. Korišćena komanda je:
```bash
nsenter --mount=/proc/$ZYGOTE_PID/ns/mnt -- /bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
```
Ovo obezbeđuje da će svaka nova aplikacija koja se pokrene poštovati ažuriranu konfiguraciju CA sertifikata.

4. **Primena promena na već pokrenute aplikacije**: Da biste primenili promene na već pokrenute aplikacije, `nsenter` se ponovo koristi da se uđe u namespace svake aplikacije pojedinačno i izvrši sličan bind mount. Potrebna komanda je:
```bash
nsenter --mount=/proc/$APP_PID/ns/mnt -- /bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
```
5. **Alternative Approach - Soft Reboot**: Alternativna metoda obuhvata izvršavanje bind mount-a na procesu `init` (PID 1), nakon čega sledi soft reboot operativnog sistema pomoću komandi `stop && start`. Ovaj pristup propagira promene kroz sve namespaces, izbegavajući potrebu da se pojedinačno obrađuje svaka pokrenuta aplikacija. Međutim, ova metoda se generalno manje preferira zbog nepraktičnosti restartovanja.

## Reference

- [Android 14: Install a system CA certificate on a rooted device](https://httptoolkit.com/blog/android-14-install-system-ca-certificate/)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)

{{#include ../../banners/hacktricks-training.md}}
