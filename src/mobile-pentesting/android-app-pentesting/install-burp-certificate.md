# Install Burp Certificate

{{#include ../../banners/hacktricks-training.md}}


## System-wide proxy via ADB

Skonfiguruj globalne proxy HTTP, aby wszystkie aplikacje kierowały ruch przez twój interceptor (Burp/mitmproxy):
```bash
# Set proxy (device/emulator must reach your host IP)
adb shell settings put global http_proxy 192.168.1.2:8080

# Clear proxy
adb shell settings put global http_proxy :0
```
Tip: In Burp, bind your listener to 0.0.0.0 so devices on the LAN can connect (Proxy -> Options -> Proxy Listeners).

## Na maszynie wirtualnej

Najpierw musisz pobrać certyfikat Der z Burp. Możesz to zrobić w _**Proxy**_ --> _**Options**_ --> _**Import / Export CA certificate**_

![](<../../images/image (367).png>)

**Eksportuj certyfikat w formacie Der** i zamień go na formę, którą **Android** będzie w stanie **obsłużyć.** Zwróć uwagę, że **aby skonfigurować certyfikat Burp na maszynie Android w AVD** musisz **uruchomić** tę maszynę **z** opcją **`-writable-system`**.\
Na przykład możesz uruchomić ją tak:
```bash
C:\Users\<UserName>\AppData\Local\Android\Sdk\tools\emulator.exe -avd "AVD9" -http-proxy 192.168.1.12:8080 -writable-system
```
Następnie, aby **skonfigurować certyfikat burps, wykonaj:**
```bash
openssl x509 -inform DER -in burp_cacert.der -out burp_cacert.pem
CERTHASHNAME="`openssl x509 -inform PEM -subject_hash_old -in burp_cacert.pem | head -1`.0"
mv burp_cacert.pem $CERTHASHNAME #Correct name
adb root && sleep 2 && adb remount #Allow to write on /syste
adb push $CERTHASHNAME /sdcard/ #Upload certificate
adb shell mv /sdcard/$CERTHASHNAME /system/etc/security/cacerts/ #Move to correct location
adb shell chmod 644 /system/etc/security/cacerts/$CERTHASHNAME #Assign privileges
adb reboot #Now, reboot the machine
```
Gdy **machine finish rebooting** burp certificate będzie przez nią używany!

## Korzystanie z Magisc

Jeśli **rootowałeś urządzenie z Magisc** (może emulator) i **nie możesz wykonać** poprzednich **kroków** aby zainstalować Burp cert, ponieważ **filesystem jest tylko do odczytu** i nie możesz go zamontować jako zapisywalny, istnieje inne rozwiązanie.

Wyjaśnione w [**this video**](https://www.youtube.com/watch?v=qQicUW0svB8) musisz:

1. **Install a CA certificate**: Po prostu **drag&drop** DER Burp certificate **zmieniając rozszerzenie** na `.crt` na mobile aby został zapisany w Downloads folder i przejdź do `Install a certificate` -> `CA certificate`

<figure><img src="../../images/image (53).png" alt="" width="164"><figcaption></figcaption></figure>

- Sprawdź, że certyfikat został poprawnie zapisany przechodząc do `Trusted credentials` -> `USER`

<figure><img src="../../images/image (54).png" alt="" width="334"><figcaption></figcaption></figure>

2. **Make it System trusted**: Pobierz Magisc moduł [MagiskTrustUserCerts](https://github.com/NVISOsecurity/MagiskTrustUserCerts) (plik .zip), **drag&drop go** na telefon, otwórz **Magics app** na telefonie w sekcji **`Modules`**, kliknij **`Install from storage`**, wybierz `.zip` moduł i po instalacji **reboot** telefonu:

<figure><img src="../../images/image (55).png" alt="" width="345"><figcaption></figcaption></figure>

- Po reboot, przejdź do `Trusted credentials` -> `SYSTEM` i sprawdź, że Postswigger cert tam jest

<figure><img src="../../images/image (56).png" alt="" width="314"><figcaption></figcaption></figure>

### Learn how to create a Magisc module

Sprawdź [https://medium.com/@justmobilesec/magisk-for-mobile-pentesting-rooting-android-devices-and-building-custom-modules-part-ii-22badc498437](https://medium.com/@justmobilesec/magisk-for-mobile-pentesting-rooting-android-devices-and-building-custom-modules-part-ii-22badc498437)

## Po Android 14

W najnowszym wydaniu Android 14 zaobserwowano istotną zmianę w obsłudze system-trusted Certificate Authority (CA) certificates. Wcześniej te certyfikaty były przechowywane w **`/system/etc/security/cacerts/`**, dostępne i modyfikowalne przez użytkowników z uprawnieniami root, co pozwalało na ich natychmiastowe zastosowanie w całym systemie. Jednak w Android 14 lokalizacja przechowywania została przeniesiona do **`/apex/com.android.conscrypt/cacerts`**, katalogu w ścieżce **`/apex`**, który z natury jest niemutowalny.

Próby ponownego zamontowania **APEX cacerts path** jako zapisywalnego kończą się niepowodzeniem, ponieważ system nie pozwala na takie operacje. Nawet próby odmontowania lub nadpisania katalogu tymczasowym systemem plików (tmpfs) nie obchodzą niemutowalności; aplikacje nadal odczytują oryginalne dane certyfikatów niezależnie od zmian na poziomie systemu plików. Ta odporność wynika z faktu, że montowanie **`/apex`** jest skonfigurowane z PRIVATE propagation, co zapewnia, że jakiekolwiek modyfikacje wewnątrz katalogu **`/apex`** nie wpływają na inne procesy.

Inicjalizacja Androida obejmuje proces `init`, który przy uruchamianiu systemu operacyjnego także inicjuje proces Zygote. Ten proces jest odpowiedzialny za uruchamianie procesów aplikacji z nową przestrzenią nazw montowania, która zawiera prywatny mount **`/apex`**, izolując w ten sposób zmiany w tym katalogu od innych procesów.

Niemniej jednak istnieje obejście dla tych, którzy potrzebują modyfikować system-trusted CA certificates w katalogu **`/apex`**. Polega ono na ręcznym ponownym zamontowaniu **`/apex`** aby usunąć PRIVATE propagation, czyniąc go zapisywalnym. Proces obejmuje skopiowanie zawartości **`/apex/com.android.conscrypt`** do innej lokalizacji, odmontowanie katalogu **`/apex/com.android.conscrypt`** aby wyeliminować ograniczenie tylko do odczytu, a następnie przywrócenie zawartości na oryginalne miejsce w **`/apex`**. Podejście to wymaga szybkiego działania, aby uniknąć awarii systemu. Aby zapewnić zastosowanie tych zmian w całym systemie, zaleca się zrestartowanie `system_server`, co efektywnie restartuje wszystkie aplikacje i przywraca system do spójnego stanu.
```bash
# Create a separate temp directory, to hold the current certificates
# Otherwise, when we add the mount we can't read the current certs anymore.
mkdir -p -m 700 /data/local/tmp/tmp-ca-copy

# Copy out the existing certificates
cp /apex/com.android.conscrypt/cacerts/* /data/local/tmp/tmp-ca-copy/

# Create the in-memory mount on top of the system certs folder
mount -t tmpfs tmpfs /system/etc/security/cacerts

# Copy the existing certs back into the tmpfs, so we keep trusting them
mv /data/local/tmp/tmp-ca-copy/* /system/etc/security/cacerts/

# Copy our new cert in, so we trust that too
mv $CERTIFICATE_PATH /system/etc/security/cacerts/

# Update the perms & selinux context labels
chown root:root /system/etc/security/cacerts/*
chmod 644 /system/etc/security/cacerts/*
chcon u:object_r:system_file:s0 /system/etc/security/cacerts/*

# Deal with the APEX overrides, which need injecting into each namespace:

# First we get the Zygote process(es), which launch each app
ZYGOTE_PID=$(pidof zygote || true)
ZYGOTE64_PID=$(pidof zygote64 || true)
# N.b. some devices appear to have both!

# Apps inherit the Zygote's mounts at startup, so we inject here to ensure
# all newly started apps will see these certs straight away:
for Z_PID in "$ZYGOTE_PID" "$ZYGOTE64_PID"; do
if [ -n "$Z_PID" ]; then
nsenter --mount=/proc/$Z_PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
fi
done

# Then we inject the mount into all already running apps, so they
# too see these CA certs immediately:

# Get the PID of every process whose parent is one of the Zygotes:
APP_PIDS=$(
echo "$ZYGOTE_PID $ZYGOTE64_PID" | \
xargs -n1 ps -o 'PID' -P | \
grep -v PID
)

# Inject into the mount namespace of each of those apps:
for PID in $APP_PIDS; do
nsenter --mount=/proc/$PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts &
done
wait # Launched in parallel - wait for completion here

echo "System certificate injected"
```
### Bind-mounting through NSEnter

1. **Konfigurowanie katalogu zapisywalnego**: Najpierw tworzy się katalog umożliwiający zapis, montując `tmpfs` nad istniejącym katalogiem certyfikatów systemowych non-APEX. Robi się to za pomocą następującego polecenia:
```bash
mount -t tmpfs tmpfs /system/etc/security/cacerts
```
2. **Preparing CA Certificates**: Po skonfigurowaniu zapisywalnego katalogu, CA certificates, które zamierzasz użyć, należy skopiować do tego katalogu. Może to wymagać skopiowania domyślnych certyfikatów z `/apex/com.android.conscrypt/cacerts/`. Należy odpowiednio ustawić uprawnienia i etykiety SELinux tych certyfikatów.
3. **Bind Mounting for Zygote**: Używając `nsenter`, wchodzi się do mount namespace procesu Zygote. Zygote, będący procesem odpowiedzialnym za uruchamianie aplikacji Android, wymaga tego kroku, aby wszystkie później uruchamiane aplikacje korzystały z nowo skonfigurowanych CA certificates. Użyta komenda to:
```bash
nsenter --mount=/proc/$ZYGOTE_PID/ns/mnt -- /bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
```
To zapewnia, że każda nowo uruchomiona aplikacja będzie stosować zaktualizowaną konfigurację certyfikatów CA.

4. **Zastosowanie zmian w działających aplikacjach**: Aby zastosować zmiany w już działających aplikacjach, ponownie używa się `nsenter`, aby wejść do namespace każdej aplikacji indywidualnie i wykonać podobny bind mount. Niezbędne polecenie to:
```bash
nsenter --mount=/proc/$APP_PID/ns/mnt -- /bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
```
5. **Alternatywne podejście - Soft Reboot**: Alternatywna metoda polega na wykonaniu bind mount na procesie `init` (PID 1), a następnie przeprowadzeniu soft reboot systemu operacyjnego za pomocą poleceń `stop && start`. To podejście spowoduje propagację zmian we wszystkich namespaces, eliminując potrzebę indywidualnego adresowania każdej uruchomionej aplikacji. Jednak ta metoda jest zazwyczaj mniej preferowana ze względu na niedogodność związaną z ponownym uruchomieniem.

## Źródła

- [Android 14: Install a system CA certificate on a rooted device](https://httptoolkit.com/blog/android-14-install-system-ca-certificate/)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)

{{#include ../../banners/hacktricks-training.md}}
