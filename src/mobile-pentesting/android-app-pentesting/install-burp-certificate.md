# Εγκατάσταση πιστοποιητικού Burp

{{#include ../../banners/hacktricks-training.md}}


## Proxy σε όλο το σύστημα μέσω ADB

Διαμορφώστε έναν παγκόσμιο HTTP proxy ώστε όλες οι εφαρμογές να δρομολογούν την κίνηση μέσω του interceptor (Burp/mitmproxy):
```bash
# Set proxy (device/emulator must reach your host IP)
adb shell settings put global http_proxy 192.168.1.2:8080

# Clear proxy
adb shell settings put global http_proxy :0
```
Tip: Στο Burp, bind το listener σας στο 0.0.0.0 ώστε οι συσκευές στο LAN να μπορούν να συνδεθούν (Proxy -> Options -> Proxy Listeners).

## Σε Εικονική Μηχανή

Πρώτα απ' όλα πρέπει να κατεβάσετε το πιστοποιητικό Der από το Burp. Μπορείτε να το κάνετε στο _**Proxy**_ --> _**Options**_ --> _**Import / Export CA certificate**_

![](<../../images/image (367).png>)

**Εξάγετε το πιστοποιητικό σε μορφή Der** και ας **μετατρέψουμε** το σε μια μορφή που το **Android** θα μπορέσει να **κατανοήσει.** Σημειώστε ότι **για να ρυθμίσετε το burp certificate στην Android μηχανή στο AVD** χρειάζεται να **τρέξετε** αυτή τη μηχανή **με** την **`-writable-system`** επιλογή.\
Για παράδειγμα μπορείτε να το τρέξετε ως εξής:
```bash
C:\Users\<UserName>\AppData\Local\Android\Sdk\tools\emulator.exe -avd "AVD9" -http-proxy 192.168.1.12:8080 -writable-system
```
Έπειτα, για να **ρυθμίσετε το πιστοποιητικό burps, κάντε**:
```bash
openssl x509 -inform DER -in burp_cacert.der -out burp_cacert.pem
CERTHASHNAME="`openssl x509 -inform PEM -subject_hash_old -in burp_cacert.pem | head -1`.0"
mv burp_cacert.pem $CERTHASHNAME #Correct name
adb root && sleep 2 && adb remount #Allow to write on /syste
adb push $CERTHASHNAME /sdcard/ #Upload certificate
adb shell mv /sdcard/$CERTHASHNAME /system/etc/security/cacerts/ #Move to correct location
adb shell chmod 644 /system/etc/security/cacerts/$CERTHASHNAME #Assign privileges
adb reboot #Now, reboot the machine
```
Μόλις **η μηχανή ολοκληρώσει την επανεκκίνηση** το burp certificate θα χρησιμοποιείται από αυτή!

## Χρήση Magisc

If you **rooted your device with Magisc** (maybe an emulator), and you **can't follow** the previous **steps** to install the Burp cert because the **filesystem is read-only** and you cannot remount it writable, there is another way.

Εξηγείται σε [**αυτό το βίντεο**](https://www.youtube.com/watch?v=qQicUW0svB8) και χρειάζεται να:

1. **Install a CA certificate**: Απλά **drag&drop** το DER Burp certificate **changing the extension** σε `.crt` στο κινητό ώστε να αποθηκευτεί στο φάκελο Downloads και πηγαίνετε σε `Install a certificate` -> `CA certificate`

<figure><img src="../../images/image (53).png" alt="" width="164"><figcaption></figcaption></figure>

- Ελέγξτε ότι το πιστοποιητικό αποθηκεύτηκε σωστά πηγαίνοντας σε `Trusted credentials` -> `USER`

<figure><img src="../../images/image (54).png" alt="" width="334"><figcaption></figcaption></figure>

2. **Make it System trusted**: Κατεβάστε το Magisc module [MagiskTrustUserCerts](https://github.com/NVISOsecurity/MagiskTrustUserCerts) (ένα .zip αρχείο), **drag&drop it** στο τηλέφωνο, ανοίξτε την εφαρμογή **Magics** στο τηλέφωνο στην ενότητα **`Modules`**, κάντε κλικ στο **`Install from storage`**, επιλέξτε το `.zip` module και μόλις εγκατασταθεί **reboot** το τηλέφωνο:

<figure><img src="../../images/image (55).png" alt="" width="345"><figcaption></figcaption></figure>

- Μετά την επανεκκίνηση, πηγαίνετε σε `Trusted credentials` -> `SYSTEM` και ελέγξτε ότι το Postswigger cert είναι εκεί

<figure><img src="../../images/image (56).png" alt="" width="314"><figcaption></figcaption></figure>

### Learn how to create a Magisc module

Δείτε [https://medium.com/@justmobilesec/magisk-for-mobile-pentesting-rooting-android-devices-and-building-custom-modules-part-ii-22badc498437](https://medium.com/@justmobilesec/magisk-for-mobile-pentesting-rooting-android-devices-and-building-custom-modules-part-ii-22badc498437)

## Post Android 14

Στην πιο πρόσφατη έκδοση Android 14, παρατηρήθηκε σημαντική αλλαγή στον τρόπο χειρισμού των system-trusted Certificate Authority (CA) certificates. Παλαιότερα, αυτά τα πιστοποιητικά βρίσκονταν στο **`/system/etc/security/cacerts/`**, προσβάσιμα και τροποποιήσιμα από χρήστες με root προνόμια, πράγμα που επέτρεπε την άμεση εφαρμογή τους σε όλο το σύστημα. Ωστόσο, με το Android 14, η τοποθεσία αποθήκευσης μεταφέρθηκε στο **`/apex/com.android.conscrypt/cacerts`**, έναν κατάλογο εντός της διαδρομής **`/apex`**, ο οποίος είναι αμετάβλητος από τη φύση του.

Οι προσπάθειες να γίνει remount η APEX cacerts διαδρομή ως εγγράψιμη αποτυγχάνουν, καθώς το σύστημα δεν επιτρέπει τέτοιες ενέργειες. Ακόμη και οι προσπάθειες να απομακρυνθεί ή να επικαλυφθεί ο κατάλογος με ένα προσωρινό file system (tmpfs) δεν παρακάμπτουν την αμεταβλητότητα· οι εφαρμογές συνεχίζουν να προσπελάζουν τα αρχικά δεδομένα πιστοποιητικού ανεξάρτητα από αλλαγές στο επίπεδο του file system. Αυτή η ανθεκτικότητα οφείλεται στο ότι το mount του **`/apex`** έχει ρυθμιστεί με PRIVATE propagation, εξασφαλίζοντας ότι οποιεσδήποτε τροποποιήσεις εντός του καταλόγου **`/apex`** δεν επηρεάζουν άλλες διεργασίες.

Η αρχικοποίηση του Android περιλαμβάνει τη διεργασία `init`, η οποία, κατά την εκκίνηση του λειτουργικού συστήματος, ξεκινά επίσης τη διεργασία Zygote. Αυτή η διεργασία είναι υπεύθυνη για την εκκίνηση των διεργασιών εφαρμογών με ένα νέο mount namespace που περιλαμβάνει ένα private **`/apex`** mount, απομονώνοντας έτσι τις αλλαγές σε αυτόν τον κατάλογο από άλλες διεργασίες.

Παρόλα αυτά, υπάρχει μια λύση για όσους χρειάζονται να τροποποιήσουν τα system-trusted CA certificates εντός του καταλόγου **`/apex`**. Αυτή περιλαμβάνει το χειροκίνητο remount του **`/apex`** για την αφαίρεση της PRIVATE propagation, καθιστώντας το έτσι εγγράψιμο. Η διαδικασία περιλαμβάνει την αντιγραφή του περιεχομένου του **`/apex/com.android.conscrypt`** σε άλλη θέση, την αποπροσάρτηση (unmount) του καταλόγου **`/apex/com.android.conscrypt`** για να αφαιρεθεί ο περιορισμός μόνο για ανάγνωση, και στη συνέχεια την επαναφορά του περιεχομένου στην αρχική του θέση εντός του **`/apex`**. Αυτή η προσέγγιση απαιτεί ταχεία ενέργεια για να αποφευχθεί η αστάθεια ή το crash του συστήματος. Για να εξασφαλιστεί η εφαρμογή των αλλαγών σε ολόκληρο το σύστημα, συνιστάται η επανεκκίνηση της `system_server`, η οποία ουσιαστικά επανεκκινεί όλες τις εφαρμογές και επαναφέρει το σύστημα σε συνεπή κατάσταση.
```bash
# Create a separate temp directory, to hold the current certificates
# Otherwise, when we add the mount we can't read the current certs anymore.
mkdir -p -m 700 /data/local/tmp/tmp-ca-copy

# Copy out the existing certificates
cp /apex/com.android.conscrypt/cacerts/* /data/local/tmp/tmp-ca-copy/

# Create the in-memory mount on top of the system certs folder
mount -t tmpfs tmpfs /system/etc/security/cacerts

# Copy the existing certs back into the tmpfs, so we keep trusting them
mv /data/local/tmp/tmp-ca-copy/* /system/etc/security/cacerts/

# Copy our new cert in, so we trust that too
mv $CERTIFICATE_PATH /system/etc/security/cacerts/

# Update the perms & selinux context labels
chown root:root /system/etc/security/cacerts/*
chmod 644 /system/etc/security/cacerts/*
chcon u:object_r:system_file:s0 /system/etc/security/cacerts/*

# Deal with the APEX overrides, which need injecting into each namespace:

# First we get the Zygote process(es), which launch each app
ZYGOTE_PID=$(pidof zygote || true)
ZYGOTE64_PID=$(pidof zygote64 || true)
# N.b. some devices appear to have both!

# Apps inherit the Zygote's mounts at startup, so we inject here to ensure
# all newly started apps will see these certs straight away:
for Z_PID in "$ZYGOTE_PID" "$ZYGOTE64_PID"; do
if [ -n "$Z_PID" ]; then
nsenter --mount=/proc/$Z_PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
fi
done

# Then we inject the mount into all already running apps, so they
# too see these CA certs immediately:

# Get the PID of every process whose parent is one of the Zygotes:
APP_PIDS=$(
echo "$ZYGOTE_PID $ZYGOTE64_PID" | \
xargs -n1 ps -o 'PID' -P | \
grep -v PID
)

# Inject into the mount namespace of each of those apps:
for PID in $APP_PIDS; do
nsenter --mount=/proc/$PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts &
done
wait # Launched in parallel - wait for completion here

echo "System certificate injected"
```
### Bind-mounting μέσω NSEnter

1. **Δημιουργία εγγράψιμου καταλόγου**: Αρχικά, δημιουργείται ένας εγγράψιμος κατάλογος με την προσάρτηση ενός `tmpfs` πάνω από τον υπάρχοντα μη-APEX κατάλογο πιστοποιητικών συστήματος. Αυτό γίνεται με την ακόλουθη εντολή:
```bash
mount -t tmpfs tmpfs /system/etc/security/cacerts
```
2. **Preparing CA Certificates**: Αφού ρυθμιστεί ο εγγράψιμος κατάλογος, τα πιστοποιητικά CA που σκοπεύει κανείς να χρησιμοποιήσει πρέπει να αντιγραφούν σε αυτόν τον κατάλογο. Αυτό μπορεί να περιλαμβάνει την αντιγραφή των προεπιλεγμένων πιστοποιητικών από `/apex/com.android.conscrypt/cacerts/`. Είναι απαραίτητο να προσαρμόσετε τα δικαιώματα και τις ετικέτες SELinux αυτών των πιστοποιητικών ανάλογα.
3. **Bind Mounting for Zygote**: Χρησιμοποιώντας `nsenter`, εισέρχεται κανείς στο mount namespace του Zygote. Το Zygote, ως η διεργασία που είναι υπεύθυνη για την εκκίνηση των εφαρμογών Android, απαιτεί αυτό το βήμα ώστε να διασφαλιστεί ότι όλες οι εφαρμογές που θα ξεκινούν εφεξής θα χρησιμοποιούν τα πρόσφατα διαμορφωμένα πιστοποιητικά CA. Η εντολή που χρησιμοποιείται είναι:
```bash
nsenter --mount=/proc/$ZYGOTE_PID/ns/mnt -- /bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
```
Αυτό διασφαλίζει ότι κάθε νέα εφαρμογή που ξεκινάει θα συμμορφώνεται με τη ρύθμιση των ενημερωμένων πιστοποιητικών CA.

4. **Εφαρμογή Αλλαγών σε Εκτελούμενες Εφαρμογές**: Για να εφαρμόσετε τις αλλαγές σε εφαρμογές που ήδη εκτελούνται, χρησιμοποιείται ξανά το `nsenter` για να μπείτε στο namespace κάθε εφαρμογής ξεχωριστά και να πραγματοποιήσετε ένα παρόμοιο bind mount. Η απαραίτητη εντολή είναι:
```bash
nsenter --mount=/proc/$APP_PID/ns/mnt -- /bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
```
5. **Alternative Approach - Soft Reboot**: Μια εναλλακτική μέθοδος περιλαμβάνει την εκτέλεση του bind mount στη διαδικασία `init` (PID 1) και στη συνέχεια ένα soft reboot του λειτουργικού συστήματος με τις εντολές `stop && start`. Αυτή η προσέγγιση θα διαδώσει τις αλλαγές σε όλα τα namespaces, αποφεύγοντας την ανάγκη να απευθυνθεί κανείς σε κάθε εκτελούμενη app ξεχωριστά. Ωστόσο, αυτή η μέθοδος γενικά προτιμάται λιγότερο λόγω της αναστάτωσης από την επανεκκίνηση.

## Αναφορές

- [Android 14: Install a system CA certificate on a rooted device](https://httptoolkit.com/blog/android-14-install-system-ca-certificate/)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)

{{#include ../../banners/hacktricks-training.md}}
