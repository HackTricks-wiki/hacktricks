# 安装 Burp 证书

{{#include ../../banners/hacktricks-training.md}}


## 通过 ADB 配置系统级代理

配置一个全局 HTTP 代理，使所有应用的流量通过你的拦截器 (Burp/mitmproxy) 路由：
```bash
# Set proxy (device/emulator must reach your host IP)
adb shell settings put global http_proxy 192.168.1.2:8080

# Clear proxy
adb shell settings put global http_proxy :0
```
Tip：在 Burp 中，将监听器绑定到 0.0.0.0，这样 LAN 中的设备就可以连接（Proxy -> Options -> Proxy Listeners）。

## 在虚拟机上

首先你需要从 Burp 下载 Der 证书。你可以在 _**Proxy**_ --> _**Options**_ --> _**Import / Export CA certificate**_ 中完成此操作。

![](<../../images/image (367).png>)

**以 Der 格式导出证书**，然后把它**转换**为 **Android** 能够**识别**的格式。注意，**要在 AVD 中的 Android 机器上配置 Burp 证书**，你需要**使用** **`-writable-system`** 选项**运行**该机器。\
例如你可以运行它像：
```bash
C:\Users\<UserName>\AppData\Local\Android\Sdk\tools\emulator.exe -avd "AVD9" -http-proxy 192.168.1.12:8080 -writable-system
```
然后，要 **配置 burps certificate**：
```bash
openssl x509 -inform DER -in burp_cacert.der -out burp_cacert.pem
CERTHASHNAME="`openssl x509 -inform PEM -subject_hash_old -in burp_cacert.pem | head -1`.0"
mv burp_cacert.pem $CERTHASHNAME #Correct name
adb root && sleep 2 && adb remount #Allow to write on /syste
adb push $CERTHASHNAME /sdcard/ #Upload certificate
adb shell mv /sdcard/$CERTHASHNAME /system/etc/security/cacerts/ #Move to correct location
adb shell chmod 644 /system/etc/security/cacerts/$CERTHASHNAME #Assign privileges
adb reboot #Now, reboot the machine
```
一旦 **机器完成重启**，Burp 证书就会被其使用！

## 使用 Magisc

If you **rooted your device with Magisc**（可能是模拟器），并且你 **无法按照** 之前的 **步骤** 安装 Burp 证书，因为 **文件系统为只读** 且无法重新挂载为可写，还有另一种方法。

在 [**这个视频**](https://www.youtube.com/watch?v=qQicUW0svB8) 中讲解，你需要：

1. **Install a CA certificate**: 只需将 DER 格式的 Burp 证书拖放（将扩展名改为 `.crt`）到手机，使其存储在 Downloads 文件夹中，然后进入 `Install a certificate` -> `CA certificate`

<figure><img src="../../images/image (53).png" alt="" width="164"><figcaption></figcaption></figure>

- 通过进入 `Trusted credentials` -> `USER` 检查证书是否已正确存储

<figure><img src="../../images/image (54).png" alt="" width="334"><figcaption></figcaption></figure>

2. **Make it System trusted**: 下载 Magisc 模块 [MagiskTrustUserCerts](https://github.com/NVISOsecurity/MagiskTrustUserCerts)（一个 .zip 文件），将其拖放到手机，打开手机上的 Magics app，进入 **`Modules`** 部分，点击 **`Install from storage`**，选择该 `.zip` 模块，安装完成后 **重启** 手机：

<figure><img src="../../images/image (55).png" alt="" width="345"><figcaption></figcaption></figure>

- 重启后，进入 `Trusted credentials` -> `SYSTEM` 并检查 Postswigger cert 是否存在

<figure><img src="../../images/image (56).png" alt="" width="314"><figcaption></figcaption></figure>

### Learn how to create a Magisc module

查看 [https://medium.com/@justmobilesec/magisk-for-mobile-pentesting-rooting-android-devices-and-building-custom-modules-part-ii-22badc498437](https://medium.com/@justmobilesec/magisk-for-mobile-pentesting-rooting-android-devices-and-building-custom-modules-part-ii-22badc498437)

## Post Android 14

在最新的 Android 14 版本中，对系统信任的证书颁发机构 (CA) 证书的处理方式发生了重大变化。之前，这些证书存放在 **`/system/etc/security/cacerts/`**，具有 root 权限的用户可以访问并修改它们，从而能够立即在整个系统中生效。然而，在 Android 14 中，存储位置已迁移到 **`/apex/com.android.conscrypt/cacerts`**，这是 **`/apex`** 路径内的目录，天生为不可变。

试图将 **APEX cacerts path** 重新挂载为可写会失败，系统不允许此类操作。即使尝试卸载或用临时文件系统 (tmpfs) 覆盖该目录，也无法绕过这种不可变性；应用程序仍会访问原始证书数据，而不受文件系统层面更改的影响。这种强韧性来自 **`/apex`** 挂载被配置为具有 PRIVATE propagation，确保 **`/apex`** 目录内的任何修改不会影响其他进程。

Android 的初始化涉及 `init` 进程，该进程在启动操作系统时还会启动 Zygote 进程。Zygote 负责以包含私有 **`/apex`** 挂载的新挂载命名空间启动应用进程，从而将对该目录的更改与其他进程隔离开来。

不过，对于需要修改 **`/apex`** 目录中系统信任 CA 证书的情况，存在一种变通方法。该方法涉及手动重新挂载 **`/apex`** 以移除 PRIVATE propagation，从而使其可写。具体流程包括将 **`/apex/com.android.conscrypt`** 的内容复制到其他位置，卸载 **`/apex/com.android.conscrypt`** 目录以消除只读限制，然后将内容恢复到 **`/apex`** 中的原始位置。该方法需要快速操作以避免系统崩溃。为确保这些更改在系统范围内生效，建议重启 `system_server`，这将有效重启所有应用并使系统恢复一致状态。
```bash
# Create a separate temp directory, to hold the current certificates
# Otherwise, when we add the mount we can't read the current certs anymore.
mkdir -p -m 700 /data/local/tmp/tmp-ca-copy

# Copy out the existing certificates
cp /apex/com.android.conscrypt/cacerts/* /data/local/tmp/tmp-ca-copy/

# Create the in-memory mount on top of the system certs folder
mount -t tmpfs tmpfs /system/etc/security/cacerts

# Copy the existing certs back into the tmpfs, so we keep trusting them
mv /data/local/tmp/tmp-ca-copy/* /system/etc/security/cacerts/

# Copy our new cert in, so we trust that too
mv $CERTIFICATE_PATH /system/etc/security/cacerts/

# Update the perms & selinux context labels
chown root:root /system/etc/security/cacerts/*
chmod 644 /system/etc/security/cacerts/*
chcon u:object_r:system_file:s0 /system/etc/security/cacerts/*

# Deal with the APEX overrides, which need injecting into each namespace:

# First we get the Zygote process(es), which launch each app
ZYGOTE_PID=$(pidof zygote || true)
ZYGOTE64_PID=$(pidof zygote64 || true)
# N.b. some devices appear to have both!

# Apps inherit the Zygote's mounts at startup, so we inject here to ensure
# all newly started apps will see these certs straight away:
for Z_PID in "$ZYGOTE_PID" "$ZYGOTE64_PID"; do
if [ -n "$Z_PID" ]; then
nsenter --mount=/proc/$Z_PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
fi
done

# Then we inject the mount into all already running apps, so they
# too see these CA certs immediately:

# Get the PID of every process whose parent is one of the Zygotes:
APP_PIDS=$(
echo "$ZYGOTE_PID $ZYGOTE64_PID" | \
xargs -n1 ps -o 'PID' -P | \
grep -v PID
)

# Inject into the mount namespace of each of those apps:
for PID in $APP_PIDS; do
nsenter --mount=/proc/$PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts &
done
wait # Launched in parallel - wait for completion here

echo "System certificate injected"
```
### 通过 NSEnter 进行 Bind-mounting

1. **设置可写目录**：最初，通过在现有的非-APEX 系统证书目录上方挂载 `tmpfs` 来建立一个可写目录。通过以下命令实现：
```bash
mount -t tmpfs tmpfs /system/etc/security/cacerts
```
2. **Preparing CA Certificates**: 在设置可写目录之后，应将打算使用的 CA 证书复制到该目录。 这可能涉及从 `/apex/com.android.conscrypt/cacerts/` 复制默认证书。 必须相应地调整这些证书的权限和 SELinux 标签。
3. **Bind Mounting for Zygote**: 使用 `nsenter` 进入 Zygote 的 mount namespace。Zygote 是负责启动 Android 应用的进程，需要这一步以确保此后启动的所有应用都会使用新配置的 CA 证书。 使用的命令为:
```bash
nsenter --mount=/proc/$ZYGOTE_PID/ns/mnt -- /bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
```
4. **将更改应用于正在运行的应用程序**: 要将更改应用到已运行的应用程序，使用 `nsenter` 再次单独进入每个应用的命名空间并执行类似的 bind mount。所需的命令是：
```bash
nsenter --mount=/proc/$APP_PID/ns/mnt -- /bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
```
5. **Alternative Approach - Soft Reboot**: 另一种方法是在 `init` 进程（PID 1）上执行 bind mount，然后通过 `stop && start` 命令对操作系统进行 soft reboot。该方法会将更改传播到所有 namespaces，避免逐个处理每个正在运行的 app。不过，由于需要重启，通常不太推荐。

## References

- [Android 14: Install a system CA certificate on a rooted device](https://httptoolkit.com/blog/android-14-install-system-ca-certificate/)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)

{{#include ../../banners/hacktricks-training.md}}
