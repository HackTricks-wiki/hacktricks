# Burp प्रमाणपत्र स्थापित करें

{{#include ../../banners/hacktricks-training.md}}


## एक वर्चुअल मशीन पर

सबसे पहले, आपको Burp से Der प्रमाणपत्र डाउनलोड करने की आवश्यकता है। आप इसे _**Proxy**_ --> _**Options**_ --> _**Import / Export CA certificate**_ में कर सकते हैं।

![](<../../images/image (367).png>)

**Der प्रारूप में प्रमाणपत्र निर्यात करें** और इसे **उस रूप में परिवर्तित करें** जिसे **Android** **समझ सके।** ध्यान दें कि **AVD में Android मशीन पर burp प्रमाणपत्र कॉन्फ़िगर करने के लिए** आपको इस मशीन को **`-writable-system`** विकल्प के साथ **चलाना** होगा।\
उदाहरण के लिए, आप इसे इस तरह चला सकते हैं:
```bash
C:\Users\<UserName>\AppData\Local\Android\Sdk\tools\emulator.exe -avd "AVD9" -http-proxy 192.168.1.12:8080 -writable-system
```
फिर, **burps प्रमाणपत्र को कॉन्फ़िगर करने के लिए**:
```bash
openssl x509 -inform DER -in burp_cacert.der -out burp_cacert.pem
CERTHASHNAME="`openssl x509 -inform PEM -subject_hash_old -in burp_cacert.pem | head -1`.0"
mv burp_cacert.pem $CERTHASHNAME #Correct name
adb root && sleep 2 && adb remount #Allow to write on /syste
adb push $CERTHASHNAME /sdcard/ #Upload certificate
adb shell mv /sdcard/$CERTHASHNAME /system/etc/security/cacerts/ #Move to correct location
adb shell chmod 644 /system/etc/security/cacerts/$CERTHASHNAME #Assign privileges
adb reboot #Now, reboot the machine
```
एक बार जब **मशीन रीबूट करना समाप्त कर दे** तो बर्प प्रमाणपत्र इसका उपयोग में होगा!

## मैजिक का उपयोग करना

यदि आपने **मैजिक के साथ अपने डिवाइस को रूट किया है** (शायद एक एमुलेटर), और आप **पिछले** **कदमों** का पालन नहीं कर सकते हैं बर्प प्रमाणपत्र स्थापित करने के लिए क्योंकि **फाइल सिस्टम केवल पढ़ने के लिए है** और आप इसे फिर से लिखने योग्य नहीं बना सकते, तो एक और तरीका है।

[**इस वीडियो**](https://www.youtube.com/watch?v=qQicUW0svB8) में समझाया गया है कि आपको:

1. **एक CA प्रमाणपत्र स्थापित करें**: बस **खींचें और छोड़ें** DER बर्प प्रमाणपत्र को **विस्तार बदलते हुए** `.crt` में मोबाइल में ताकि यह डाउनलोड फ़ोल्डर में संग्रहीत हो जाए और `Install a certificate` -> `CA certificate` पर जाएं।

<figure><img src="../../images/image (53).png" alt="" width="164"><figcaption></figcaption></figure>

- यह जांचें कि प्रमाणपत्र सही ढंग से संग्रहीत हुआ है `Trusted credentials` -> `USER` पर जाकर।

<figure><img src="../../images/image (54).png" alt="" width="334"><figcaption></figcaption></figure>

2. **इसे सिस्टम द्वारा विश्वसनीय बनाएं**: मैजिक मॉड्यूल [MagiskTrustUserCerts](https://github.com/NVISOsecurity/MagiskTrustUserCerts) (एक .zip फ़ाइल) डाउनलोड करें, इसे फोन में **खींचें और छोड़ें**, फोन में **मैजिक ऐप** पर जाएं और **`Modules`** अनुभाग में, **`Install from storage`** पर क्लिक करें, `.zip` मॉड्यूल का चयन करें और एक बार स्थापित होने पर **रीबूट** करें:

<figure><img src="../../images/image (55).png" alt="" width="345"><figcaption></figcaption></figure>

- रीबूट करने के बाद, `Trusted credentials` -> `SYSTEM` पर जाएं और जांचें कि Postswigger प्रमाणपत्र वहां है।

<figure><img src="../../images/image (56).png" alt="" width="314"><figcaption></figcaption></figure>

## एंड्रॉइड 14 के बाद

हाल के एंड्रॉइड 14 रिलीज़ में, सिस्टम-विश्वसनीय प्रमाणपत्र प्राधिकरण (CA) प्रमाणपत्रों के प्रबंधन में एक महत्वपूर्ण बदलाव देखा गया है। पहले, ये प्रमाणपत्र **`/system/etc/security/cacerts/`** में housed थे, जिन्हें रूट विशेषाधिकार वाले उपयोगकर्ताओं द्वारा पहुंचा और संशोधित किया जा सकता था, जिससे सिस्टम में तुरंत आवेदन की अनुमति मिलती थी। हालाँकि, एंड्रॉइड 14 के साथ, संग्रहण स्थान को **`/apex/com.android.conscrypt/cacerts`** में स्थानांतरित कर दिया गया है, जो **`/apex`** पथ के भीतर एक निर्देशिका है, जो स्वाभाविक रूप से अपरिवर्तनीय है।

**APEX cacerts पथ** को फिर से लिखने योग्य के रूप में माउंट करने के प्रयास विफल होते हैं, क्योंकि सिस्टम ऐसी संचालन की अनुमति नहीं देता। अस्थायी फ़ाइल प्रणाली (tmpfs) के साथ निर्देशिका को अनमाउंट या ओवरले करने के प्रयास भी अपरिवर्तनीयता को नहीं रोकते; अनुप्रयोग मूल प्रमाणपत्र डेटा तक पहुंचना जारी रखते हैं चाहे फ़ाइल सिस्टम स्तर पर परिवर्तन हों या न हों। यह लचीलापन **`/apex`** माउंट के PRIVATE प्रोपेगेशन के साथ कॉन्फ़िगर होने के कारण है, यह सुनिश्चित करता है कि **`/apex`** निर्देशिका के भीतर कोई भी संशोधन अन्य प्रक्रियाओं को प्रभावित नहीं करता।

एंड्रॉइड का प्रारंभिककरण `init` प्रक्रिया द्वारा होता है, जो ऑपरेटिंग सिस्टम शुरू करने पर Zygote प्रक्रिया को भी प्रारंभ करता है। यह प्रक्रिया नए माउंट नामस्थान के साथ अनुप्रयोग प्रक्रियाओं को लॉन्च करने के लिए जिम्मेदार है जिसमें एक निजी **`/apex`** माउंट शामिल है, इस प्रकार इस निर्देशिका में परिवर्तनों को अन्य प्रक्रियाओं से अलग करता है।

फिर भी, उन लोगों के लिए एक समाधान है जिन्हें **`/apex`** निर्देशिका के भीतर सिस्टम-विश्वसनीय CA प्रमाणपत्रों को संशोधित करने की आवश्यकता है। इसमें PRIVATE प्रोपेगेशन को हटाने के लिए **`/apex`** को मैन्युअल रूप से फिर से माउंट करना शामिल है, जिससे इसे लिखने योग्य बनाया जा सके। प्रक्रिया में **`/apex/com.android.conscrypt`** की सामग्री को एक अन्य स्थान पर कॉपी करना, पढ़ने के लिए केवल बाधा को समाप्त करने के लिए **`/apex/com.android.conscrypt`** निर्देशिका को अनमाउंट करना, और फिर सामग्री को **`/apex`** के भीतर उनके मूल स्थान पर पुनर्स्थापित करना शामिल है। इस दृष्टिकोण के लिए प्रणाली क्रैश से बचने के लिए त्वरित कार्रवाई की आवश्यकता होती है। इन परिवर्तनों के प्रणाली-व्यापी आवेदन को सुनिश्चित करने के लिए, `system_server` को पुनरारंभ करने की सिफारिश की जाती है, जो प्रभावी रूप से सभी अनुप्रयोगों को पुनरारंभ करता है और प्रणाली को एक सुसंगत स्थिति में लाता है।
```bash
# Create a separate temp directory, to hold the current certificates
# Otherwise, when we add the mount we can't read the current certs anymore.
mkdir -p -m 700 /data/local/tmp/tmp-ca-copy

# Copy out the existing certificates
cp /apex/com.android.conscrypt/cacerts/* /data/local/tmp/tmp-ca-copy/

# Create the in-memory mount on top of the system certs folder
mount -t tmpfs tmpfs /system/etc/security/cacerts

# Copy the existing certs back into the tmpfs, so we keep trusting them
mv /data/local/tmp/tmp-ca-copy/* /system/etc/security/cacerts/

# Copy our new cert in, so we trust that too
mv $CERTIFICATE_PATH /system/etc/security/cacerts/

# Update the perms & selinux context labels
chown root:root /system/etc/security/cacerts/*
chmod 644 /system/etc/security/cacerts/*
chcon u:object_r:system_file:s0 /system/etc/security/cacerts/*

# Deal with the APEX overrides, which need injecting into each namespace:

# First we get the Zygote process(es), which launch each app
ZYGOTE_PID=$(pidof zygote || true)
ZYGOTE64_PID=$(pidof zygote64 || true)
# N.b. some devices appear to have both!

# Apps inherit the Zygote's mounts at startup, so we inject here to ensure
# all newly started apps will see these certs straight away:
for Z_PID in "$ZYGOTE_PID" "$ZYGOTE64_PID"; do
if [ -n "$Z_PID" ]; then
nsenter --mount=/proc/$Z_PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
fi
done

# Then we inject the mount into all already running apps, so they
# too see these CA certs immediately:

# Get the PID of every process whose parent is one of the Zygotes:
APP_PIDS=$(
echo "$ZYGOTE_PID $ZYGOTE64_PID" | \
xargs -n1 ps -o 'PID' -P | \
grep -v PID
)

# Inject into the mount namespace of each of those apps:
for PID in $APP_PIDS; do
nsenter --mount=/proc/$PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts &
done
wait # Launched in parallel - wait for completion here

echo "System certificate injected"
```
### NSEnter के माध्यम से बाइंड-माउंटिंग

1. **एक लिखने योग्य निर्देशिका सेट करना**: प्रारंभ में, एक लिखने योग्य निर्देशिका स्थापित की जाती है जो मौजूदा गैर-APEX सिस्टम प्रमाणपत्र निर्देशिका के ऊपर `tmpfs` को माउंट करके बनाई जाती है। यह निम्नलिखित कमांड के साथ किया जाता है:
```bash
mount -t tmpfs tmpfs /system/etc/security/cacerts
```
2. **CA प्रमाणपत्रों की तैयारी**: लिखने योग्य निर्देशिका की सेटअप के बाद, CA प्रमाणपत्रों को इस निर्देशिका में कॉपी किया जाना चाहिए। इसमें `/apex/com.android.conscrypt/cacerts/` से डिफ़ॉल्ट प्रमाणपत्रों को कॉपी करना शामिल हो सकता है। इन प्रमाणपत्रों की अनुमतियों और SELinux लेबल को उचित रूप से समायोजित करना आवश्यक है।
3. **Zygote के लिए बाइंड माउंटिंग**: `nsenter` का उपयोग करते हुए, कोई Zygote के माउंट नामस्थान में प्रवेश करता है। Zygote, जो Android अनुप्रयोगों को लॉन्च करने के लिए जिम्मेदार प्रक्रिया है, इस कदम की आवश्यकता होती है ताकि सभी अनुप्रयोग जो आगे शुरू किए जाते हैं, नए कॉन्फ़िगर किए गए CA प्रमाणपत्रों का उपयोग करें। उपयोग की जाने वाली कमांड है:
```bash
nsenter --mount=/proc/$ZYGOTE_PID/ns/mnt -- /bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
```
यह सुनिश्चित करता है कि हर नया ऐप जो शुरू किया जाएगा, अपडेटेड CA सर्टिफिकेट सेटअप का पालन करेगा।

4. **चल रहे ऐप्स पर परिवर्तन लागू करना**: पहले से चल रहे अनुप्रयोगों पर परिवर्तन लागू करने के लिए, `nsenter` का फिर से उपयोग किया जाता है ताकि प्रत्येक ऐप के नामस्थान में व्यक्तिगत रूप से प्रवेश किया जा सके और एक समान बाइंड माउंट किया जा सके। आवश्यक कमांड है:
```bash
nsenter --mount=/proc/$APP_PID/ns/mnt -- /bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
```
5. **वैकल्पिक दृष्टिकोण - सॉफ्ट रीबूट**: एक वैकल्पिक विधि `init` प्रक्रिया (PID 1) पर बाइंड माउंट करने के बाद `stop && start` कमांड के साथ ऑपरेटिंग सिस्टम का सॉफ्ट रीबूट करना शामिल है। यह दृष्टिकोण सभी नेमस्पेस में परिवर्तनों को फैलाएगा, प्रत्येक चल रहे ऐप को व्यक्तिगत रूप से संबोधित करने की आवश्यकता से बचते हुए। हालांकि, इस विधि को आमतौर पर रीबूट की असुविधा के कारण कम पसंद किया जाता है।

## संदर्भ

- [https://httptoolkit.com/blog/android-14-install-system-ca-certificate/](https://httptoolkit.com/blog/android-14-install-system-ca-certificate/)


{{#include ../../banners/hacktricks-training.md}}
