# Burp Certificate のインストール

{{#include ../../banners/hacktricks-training.md}}


## ADB経由のシステム全体プロキシ

全てのアプリがインターセプタ（Burp/mitmproxy）を経由してトラフィックをルーティングするように、グローバルな HTTP プロキシを設定します:
```bash
# Set proxy (device/emulator must reach your host IP)
adb shell settings put global http_proxy 192.168.1.2:8080

# Clear proxy
adb shell settings put global http_proxy :0
```
ヒント: In Burp, bind your listener to 0.0.0.0 so devices on the LAN can connect (Proxy -> Options -> Proxy Listeners).

## 仮想マシン上で

まず最初に、Burp から Der 証明書をダウンロードする必要があります。これは _**Proxy**_ --> _**Options**_ --> _**Import / Export CA certificate**_ で行えます。

![](<../../images/image (367).png>)

**証明書を Der フォーマットでエクスポートする** そしてそれを **変換**して、**Android** が**理解**できる形式にします。なお、**AVD の Android マシンに Burp 証明書を設定するためには** このマシンを **`-writable-system`** オプションを付けて**実行**する必要があります。\
例えば次のように実行できます:
```bash
C:\Users\<UserName>\AppData\Local\Android\Sdk\tools\emulator.exe -avd "AVD9" -http-proxy 192.168.1.12:8080 -writable-system
```
次に、**burps certificate を設定するには**:
```bash
openssl x509 -inform DER -in burp_cacert.der -out burp_cacert.pem
CERTHASHNAME="`openssl x509 -inform PEM -subject_hash_old -in burp_cacert.pem | head -1`.0"
mv burp_cacert.pem $CERTHASHNAME #Correct name
adb root && sleep 2 && adb remount #Allow to write on /syste
adb push $CERTHASHNAME /sdcard/ #Upload certificate
adb shell mv /sdcard/$CERTHASHNAME /system/etc/security/cacerts/ #Move to correct location
adb shell chmod 644 /system/etc/security/cacerts/$CERTHASHNAME #Assign privileges
adb reboot #Now, reboot the machine
```
マシンが再起動を完了すると、Burp 証明書が使用されます！

## Magisc の使用

もし Magisc でデバイスをルート化している（エミュレータの可能性もあります）、そしてファイルシステムが読み取り専用で remount して書き込み可能にできないために前の手順で Burp 証明書をインストールできない場合、別の方法があります。

[**this video**](https://www.youtube.com/watch?v=qQicUW0svB8) で説明されているように、次の操作を行います：

1. **CA 証明書をインストールする**: DER 形式の Burp 証明書の拡張子を `.crt` に変更してモバイルにドラッグ＆ドロップし、Downloads フォルダに保存します。次に `Install a certificate` -> `CA certificate` へ移動します。

<figure><img src="../../images/image (53).png" alt="" width="164"><figcaption></figcaption></figure>

- `Trusted credentials` -> `USER` に移動して証明書が正しく保存されていることを確認します

<figure><img src="../../images/image (54).png" alt="" width="334"><figcaption></figcaption></figure>

2. **システムで信頼されるようにする**: Magisc モジュール [MagiskTrustUserCerts](https://github.com/NVISOsecurity/MagiskTrustUserCerts)（.zip ファイル）をダウンロードし、電話にドラッグ＆ドロップします。電話の **Magics app** を開き、**`Modules`** セクションに移動して **`Install from storage`** をクリックし、.zip モジュールを選択してインストール後に電話を **reboot** します：

<figure><img src="../../images/image (55).png" alt="" width="345"><figcaption></figcaption></figure>

- 再起動後、`Trusted credentials` -> `SYSTEM` に移動して Postswigger 証明書が存在することを確認します

<figure><img src="../../images/image (56).png" alt="" width="314"><figcaption></figcaption></figure>

### Magisc モジュールの作り方を学ぶ

Check [https://medium.com/@justmobilesec/magisk-for-mobile-pentesting-rooting-android-devices-and-building-custom-modules-part-ii-22badc498437](https://medium.com/@justmobilesec/magisk-for-mobile-pentesting-rooting-android-devices-and-building-custom-modules-part-ii-22badc498437)

## Android 14 以降

最新の Android 14 リリースでは、system-trusted の Certificate Authority (CA) 証明書の扱いに大きな変更がありました。以前はこれらの証明書は **`/system/etc/security/cacerts/`** に保存され、root 権限のあるユーザーがアクセス・変更できたため、システム全体に即時反映されていました。しかし Android 14 では、保存場所が **`/apex/com.android.conscrypt/cacerts`**（**`/apex`** パス内のディレクトリ）に移動されており、これは本質的に不変（immutable）です。

APEX の cacerts パスを書き込み可能に remount しようとすると失敗します。システムがそのような操作を許可しないためです。ディレクトリをアンマウントしたり tmpfs でオーバーレイしたりしても不変性を回避できず、ファイルシステムレベルで変更を加えてもアプリケーションは元の証明書データにアクセスし続けます。この耐性は、**`/apex`** マウントが PRIVATE propagation に設定されているためで、**`/apex`** 内での変更が他のプロセスに影響を与えないようになっています。

Android の初期化では `init` プロセスが起動し、OS の起動時に Zygote プロセスも立ち上げます。Zygote は、新しいマウントネームスペースを持つアプリケーションプロセスを起動する役割を担っており、そのネームスペースには private な **`/apex`** マウントが含まれます。これにより、このディレクトリへの変更は他のプロセスから分離されます。

それでも、**`/apex`** ディレクトリ内の system-trusted CA 証明書を修正する必要がある場合の回避策が存在します。これは、**`/apex`** の PRIVATE propagation を解除して書き込み可能にするために手動で remount する方法です。手順は、**`/apex/com.android.conscrypt`** の内容を別の場所にコピーし、**`/apex/com.android.conscrypt`** をアンマウントして読み取り専用の制約を取り除き、内容を **`/apex`** の元の場所に戻す、というものです。この操作はシステムクラッシュを避けるために素早く行う必要があります。変更をシステム全体に反映させるためには、`system_server` を再起動する（これにより全アプリケーションが実質的に再起動され、システムが整合した状態になる）ことを推奨します。
```bash
# Create a separate temp directory, to hold the current certificates
# Otherwise, when we add the mount we can't read the current certs anymore.
mkdir -p -m 700 /data/local/tmp/tmp-ca-copy

# Copy out the existing certificates
cp /apex/com.android.conscrypt/cacerts/* /data/local/tmp/tmp-ca-copy/

# Create the in-memory mount on top of the system certs folder
mount -t tmpfs tmpfs /system/etc/security/cacerts

# Copy the existing certs back into the tmpfs, so we keep trusting them
mv /data/local/tmp/tmp-ca-copy/* /system/etc/security/cacerts/

# Copy our new cert in, so we trust that too
mv $CERTIFICATE_PATH /system/etc/security/cacerts/

# Update the perms & selinux context labels
chown root:root /system/etc/security/cacerts/*
chmod 644 /system/etc/security/cacerts/*
chcon u:object_r:system_file:s0 /system/etc/security/cacerts/*

# Deal with the APEX overrides, which need injecting into each namespace:

# First we get the Zygote process(es), which launch each app
ZYGOTE_PID=$(pidof zygote || true)
ZYGOTE64_PID=$(pidof zygote64 || true)
# N.b. some devices appear to have both!

# Apps inherit the Zygote's mounts at startup, so we inject here to ensure
# all newly started apps will see these certs straight away:
for Z_PID in "$ZYGOTE_PID" "$ZYGOTE64_PID"; do
if [ -n "$Z_PID" ]; then
nsenter --mount=/proc/$Z_PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
fi
done

# Then we inject the mount into all already running apps, so they
# too see these CA certs immediately:

# Get the PID of every process whose parent is one of the Zygotes:
APP_PIDS=$(
echo "$ZYGOTE_PID $ZYGOTE64_PID" | \
xargs -n1 ps -o 'PID' -P | \
grep -v PID
)

# Inject into the mount namespace of each of those apps:
for PID in $APP_PIDS; do
nsenter --mount=/proc/$PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts &
done
wait # Launched in parallel - wait for completion here

echo "System certificate injected"
```
### Bind-mounting through NSEnter

1. **Setting Up a Writable Directory**: 最初に、既存の non-APEX システム証明書ディレクトリの上に `tmpfs` をマウントして、書き込み可能なディレクトリを作成します。これは以下のコマンドで実行します：
```bash
mount -t tmpfs tmpfs /system/etc/security/cacerts
```
2. **CA証明書の準備**: 書き込み可能なディレクトリを設定した後、使用する CA certificates をそのディレクトリにコピーします。これはデフォルトの証明書を `/apex/com.android.conscrypt/cacerts/` からコピーすることを含む場合があります。これらの証明書のパーミッションと SELinux ラベルを適切に調整することが重要です。
3. **Zygote 用の Bind Mount**: `nsenter` を用いて Zygote の mount namespace に入ります。Zygote は Android アプリケーションを起動するプロセスであり、この手順により以降に起動されるすべてのアプリが新しく設定した CA certificates を利用するようになります。使用するコマンドは:
```bash
nsenter --mount=/proc/$ZYGOTE_PID/ns/mnt -- /bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
```
これにより、新しく起動するすべてのアプリが更新された CA certificates の設定に従うようになります。

4. **実行中のアプリへの変更適用**: 既に実行中のアプリに変更を適用するには、`nsenter` を再度使用して各アプリの namespace に個別に入り、同様の bind mount を行います。必要なコマンドは:
```bash
nsenter --mount=/proc/$APP_PID/ns/mnt -- /bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
```
5. **代替アプローチ - ソフト再起動**：別の方法としては、`init` プロセス（PID 1）で bind mount を実行し、その後 `stop && start` コマンドでオペレーティングシステムをソフト再起動する方法があります。このアプローチは変更をすべての namespaces に伝播させ、各実行中の app を個別に対処する必要を回避します。ただし、再起動の手間がかかるため、この方法は一般的にはあまり好まれません。

## 参考資料

- [Android 14: Install a system CA certificate on a rooted device](https://httptoolkit.com/blog/android-14-install-system-ca-certificate/)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)

{{#include ../../banners/hacktricks-training.md}}
