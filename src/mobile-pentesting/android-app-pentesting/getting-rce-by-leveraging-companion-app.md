# Getting RCE by Leveraging a Companion App

{{#include ../../banners/hacktricks-training.md}}

## Overview

This guide covers the end-to-end exploitation of the Eachine E58 FPV drone Android companion app (com.klh.lwfpv) by emulating the drone’s network endpoints and chaining native-library memory corruptions to achieve unauthenticated, remote full code execution (RCE) on a user’s smartphone.

## Target Application and Protocol

- **App**: LW FPV (com.klh.lwfpv)
- **Drone IPs**: 192.168.0.1 or 172.16.10.1
- **Ports & Protocols**:
  - TCP 7060 (AVC stream / video data)
  - UDP 40000 (VGA stream / video frames)
  - TCP 8060 (SendGetRecPlan JNI commands)
  - UDP 50000 (ParseGLInfoData FlyInfo)
  - TCP 8888 (Device control via libFHDev_Net.so / getUserList)
  - TCP encrypted commands via NC() in libFHDev_Net.so

## Exploitable Primitives

1. **AVC Stream (TCP 7060): Heap Buffer Overflow**

   ```c
   char *buffer = malloc(0xA00000);
   net_recv(sock, buffer, 0x2E); // header
   if (buffer->type == 257)
     net_recv(sock, buffer, *(int *)&buffer->size); // overflow
   ```

   Unchecked `buffer->size` allows overflowing the large heap allocation.

2. **VGA Stream (UDP 40000): Arbitrary Heap OOB Write**

   ```c
   char *buffer = malloc(0xA00000);
   size_read = vga_recv_udp(vga_udp_t, &buffer, 2000);
   short size  = *(short*)&buffer->content[49];
   ushort index = *(ushort*)&buffer->content[45] - 1;
   memcpy(&buffer[1400*index + 1036], &buffer->content[51], size); // OOB write
   ```

   Unchecked `index` and `size` permit writes anywhere within the 0xA00000 heap chunk.

3. **SendGetRecPlan (TCP 8060): JNI Heap Overflow**

   ```c
   char *buf = malloc(0x200);
   send(sock8060, buf, 0x2E, 0);
   net_recv(sock8060, buf, (int)buf->size); // overflow
   ```

   Overwrites adjacent Scudo bins (0x1c0–0x250) and corrupts libhwui’s `LinearAllocator` metadata to enable a Call-Oriented Programming (COP) primitive.

4. **ParseGLInfoData (UDP 50000): BSS Overflow**

   ```c
   uchar len = buffer[2];
   memcpy(&GLFlyInfoData, buffer + 3, len); // BSS overflow
   ```

   `len` is an unsigned char (0–0xFF), allowing overflow into globals following `GLFlyInfoData` (e.g., `LWDroneSoftwareData`).

5. **GetUserList (TCP 8888): Stack Overflow**

   ```c
   uint8_t user_list[0x880];
   int count = length / 0x45;
   do {
     memcpy(curr_item, buf_ptr, 0x44);
     buf_ptr += 0x45;
     curr_item += 0x44;
   } while (++i < count);
   ```

   Sending `length > 31*0x45` causes overflow of the 0x880-byte stack buffer.

6. **Dual-call Info Leak via NC()**

   ```c
   // NC() internal:
   msg_len = *(ushort*)&buffer[79];
   memcpy(inout_buffer, &buffer[82], msg_len - 1);
   *inout_len = msg_len - 1;
   
   // Two calls reusing inout_buffer and inout_len without reset:
   NC(GetTimeZone);  // sets inout_len arbitrarily high
   NC(GetCapacity);  // leaks stack, heap, library bases via memcpy
   ```

   First call sets `inout_len` from attacker-controlled `msg_len`, second call leaks memory based on stale `inout_len`.

## Exploitation Chain

1. **Leak & Neutralize**: Reply to `GetTimeZone` with `msg_length > 0x1000`, then feed bytes slowly (1 byte/sec) to stay in the recv loop and extract stack cookie, library bases (libFHDev_Net.so, liblewei63.so) and heap pointers.
2. **COP Primitive**: Trigger `SendGetRecPlan` overflow to corrupt `libhwui::LinearAllocator::mDtorList`. When the allocator is destroyed, each destructor entry calls an attacker-controlled function pointer with a controlled argument.
3. **Arbitrary Read**: Use COP to invoke `sub_738E8` in libFHDev_Net.so, which opens a new socket and sends `inout_buffer`, leaking `system()` address from libc.
4. **Final RCE**: Use COP to call `system("sh")` for shell execution on the device.

## References

- Synacktiv blog: https://www.synacktiv.com/en/publications/from-cheap-iot-toy-to-your-smartphone-getting-rce-by-leveraging-a-companion-app.html

{{#include /banners/hacktricks-training.md}}
