# Flutter

{{#include ../../banners/hacktricks-training.md}}

Flutter 是 **Google 的跨平台 UI 工具包**，允许开发者用单一的 Dart 代码库编写应用，然后由 **Engine**（本地 C/C++）将其转为针对 Android & iOS 的平台特定机器码。  
Engine 打包了 **Dart VM**、**BoringSSL**、Skia 等，并以共享库形式发布为 **libflutter.so**（Android）或 **Flutter.framework**（iOS）。所有实际的网络（DNS、sockets、TLS）都发生在 **这个库内部**，*而不是* 在通常的 Java/Kotlin 或 Swift/Obj-C 层。正是这种隔离设计导致常见的 Java 级 Frida 钩子在 Flutter 应用上失效。

## Intercepting HTTPS traffic in Flutter

这是对这篇 [blog post](https://sensepost.com/blog/2025/intercepting-https-communication-in-flutter-going-full-hardcore-mode-with-frida/) 的总结。

### Why HTTPS interception is tricky in Flutter
* **SSL/TLS verification lives two layers down** 在 BoringSSL 中的更底层，因此 Java 级的 SSL‐pinning 绕过并不会触及它。
* **BoringSSL uses its *own* CA store** 位于 libflutter.so 内部；把你的 Burp/ZAP CA 导入到 Android 的系统证书库不会改变任何东西。
* libflutter.so 中的符号被 **stripped & mangled**，将证书验证函数对动态工具隐藏起来。

### Fingerprint the exact Flutter stack
知道确切版本可以让你重建或模式匹配合适的二进制。

Step | Command / File | Outcome
----|----|----
Get snapshot hash | `python3 get_snapshot_hash.py libapp.so` | `adb4292f3ec25…`
Map hash → Engine | **enginehash** list in reFlutter | Flutter 3 · 7 · 12 + engine commit `1a65d409…`
Pull dependent commits | DEPS file in that engine commit | • `dart_revision` → Dart v2 · 19 · 6<br>• `dart_boringssl_rev` → BoringSSL `87f316d7…`

Find [get_snapshot_hash.py here](https://github.com/Impact-I/reFlutter/blob/main/scripts/get_snapshot_hash.py).

### Target: `ssl_crypto_x509_session_verify_cert_chain()`
* Located in **`ssl_x509.cc`** inside BoringSSL.
* **Returns `bool`** – a single `true` 就足以绕过整个证书链校验。
* 同一函数在每种 CPU 架构上都存在；唯一不同的是 opcode。

### Option A – Binary patching with **reFlutter**
1. **Clone** 应用所使用的 Flutter 版本对应的 Engine & Dart 源码。
2. **Regex-patch** 两个热点：
* 在 `ssl_x509.cc` 中，强制 `return 1;`
* （可选）在 `socket_android.cc` 中，硬编码一个代理（`"10.0.2.2:8080"`）。
3. **Re-compile** libflutter.so，放回 APK/IPA，签名并安装。
4. 为常见版本提供的 **Pre-patched builds** 已在 reFlutter 的 GitHub releases 中发布，以节省大量构建时间。

### Option B – Live hooking with **Frida** (the “hard-core” path)
因为符号被剥离，你需要对已加载的模块进行模式扫描以寻找其起始字节，然后在运行时修改返回值。
```javascript
// attach & locate libflutter.so
var flutter = Process.getModuleByName("libflutter.so");

// x86-64 pattern of the first 16 bytes of ssl_crypto_x509_session_verify_cert_chain
var sig = "55 41 57 41 56 41 55 41 54 53 48 83 EC 38 C6 02";

Memory.scan(flutter.base, flutter.size, sig, {
onMatch: function (addr) {
console.log("[+] found verifier at " + addr);
Interceptor.attach(addr, {
onLeave: function (retval) { retval.replace(0x1); }  // always 'true'
});
},
onComplete: function () { console.log("scan done"); }
});
```
我需要该文件的内容才能翻译。请把 src/mobile-pentesting/android-app-pentesting/flutter.md 的文本粘贴到这里，或上传文件。我会保留代码、标签、链接和路径不翻译，只把普通英文文本翻成中文。
```bash
frida -U -f com.example.app -l bypass.js
```
*移植小贴士*
* 对于 **arm64-v8a** 或 **armv7**，从 Ghidra 中获取函数的前 ~32 字节，转换为以空格分隔的十六进制字符串，然后替换 `sig`。
* 对每个 Flutter release 保持 **一个 pattern**，将它们存储在速查表中以便快速重用。

### 通过代理强制流量
Flutter 本身 **会忽略设备的代理设置**。最简单的选项：
* **Android Studio 模拟器：** Settings ▶ Proxy → manual。
* **物理设备：** 恶意 Wi‑Fi AP + DNS spoofing，或使用 Magisk 模块编辑 `/etc/hosts`。

### 基于偏移的 BoringSSL 验证 hook（无需签名扫描）
当基于 pattern 的脚本在不同架构间失效（例如 x86_64 vs ARM）时，可以通过在 libflutter.so 中使用绝对地址直接 hook BoringSSL 链验证器。工作流程：

- 从 APK 中提取对应 ABI 的库：`unzip -j app.apk "lib/*/libflutter.so" -d libs/`，并挑选与设备匹配的那个（例如 `lib/x86_64/libflutter.so`）。
- 在 Ghidra/IDA 中分析并定位 verifier：
- 来源：BoringSSL ssl_x509.cc 中的函数 `ssl_crypto_x509_session_verify_cert_chain`（3 个参数，返回 bool）。
- 在 stripped 的构建中，搜索字符串 `"ssl_client"` 并检查 XREFs；识别出接受三个类似指针参数并返回 boolean 的函数。
- 计算运行时偏移：取 Ghidra 显示的函数地址，减去分析时使用的 image base，以得到相对偏移（RVA）。示例：`0x02184644 - 0x00100000 = 0x02084644`。
- 在运行时通过 base + offset 进行 hook 并强制成功：
```javascript
// frida -U -f com.target.app -l bypass.js --no-pause
const base = Module.findBaseAddress('libflutter.so');
// Example offset from analysis. Recompute per build/arch.
const off  = ptr('0x02084644');
const addr = base.add(off);

// ssl_crypto_x509_session_verify_cert_chain: 3 args, bool return
Interceptor.replace(addr, new NativeCallback(function (a, b, c) {
return 1; // true
}, 'int', ['pointer', 'pointer', 'pointer']));

console.log('[+] Hooked BoringSSL verify_cert_chain at', addr);
```
注意事项
- 为每个目标构建和 CPU 架构重新计算偏移量；编译器/codegen 差异会破坏硬编码签名。
- 此绕过会导致 BoringSSL 接受任意链，从而启用 HTTPS MITM，无视 Flutter 内部的 pins/CA trust。
- 如果在调试期间你强制路由流量以确认 TLS 阻断，例如：
```bash
iptables -t nat -A OUTPUT -p tcp -j DNAT --to-destination <Burp_IP>:<Burp_Port>
```
…你仍然需要上面的 hook，因为验证发生在 libflutter.so 内部，而不是 Android’s system trust store。

## 参考资料
- [https://sensepost.com/blog/2025/intercepting-https-communication-in-flutter-going-full-hardcore-mode-with-frida/](https://sensepost.com/blog/2025/intercepting-https-communication-in-flutter-going-full-hardcore-mode-with-frida/)
- [Flutter SSL Bypass: How to Intercept HTTPS Traffic When all other Frida Scripts Fail](https://m4kr0x.medium.com/flutter-tls-bypass-how-to-intercept-https-traffic-when-all-other-frida-scripts-fail-bd3d04489088)
- [BoringSSL ssl_x509.cc (ssl_crypto_x509_session_verify_cert_chain)](https://github.com/google/boringssl/blob/main/ssl/ssl_x509.cc#L238)


{{#include ../../banners/hacktricks-training.md}}
