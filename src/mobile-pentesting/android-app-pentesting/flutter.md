# Flutter

{{#include ../../banners/hacktricks-training.md}}

# Flutter
Flutter ist **Googles plattformübergreifendes UI-Toolkit**, das Entwicklern ermöglicht, eine einzige Dart-Codebasis zu schreiben, die die **Engine** (natives C/C++) in plattformspezifischen Maschinencode für Android und iOS umwandelt. Die Engine bündelt eine **Dart VM**, **BoringSSL**, Skia usw. und wird als gemeinsame Bibliothek **libflutter.so** (Android) oder **Flutter.framework** (iOS) ausgeliefert. Alle tatsächlichen Netzwerkoperationen (DNS, Sockets, TLS) erfolgen **innerhalb dieser Bibliothek**, *nicht* in den üblichen Java/Kotlin Swift/Obj-C-Schichten. Dieses isolierte Design ist der Grund, warum die üblichen Java-Level Frida-Hooks bei Flutter-Apps fehlschlagen.

## Abfangen von HTTPS-Verkehr in Flutter

Dies ist eine Zusammenfassung dieses [Blogbeitrags](https://sensepost.com/blog/2025/intercepting-https-communication-in-flutter-going-full-hardcore-mode-with-frida/).

### Warum das Abfangen von HTTPS in Flutter schwierig ist
* **Die SSL/TLS-Überprüfung befindet sich zwei Schichten tiefer** in BoringSSL, sodass Java SSL-Pinning-Umgehungen sie nicht berühren.
* **BoringSSL verwendet seinen *eigenen* CA-Speicher** innerhalb von libflutter.so; das Importieren Ihres Burp/ZAP CA in den System-Speicher von Android ändert nichts.
* Symbole in libflutter.so sind **entfernt und verworren**, wodurch die Funktion zur Zertifikatsüberprüfung vor dynamischen Tools verborgen wird.

### Fingerabdruck des genauen Flutter-Stacks
Die Kenntnis der Version ermöglicht es Ihnen, die richtigen Binärdateien neu zu erstellen oder Muster zuzuordnen.

Schritt | Befehl / Datei | Ergebnis
----|----|----
Snapshot-Hash abrufen | ```bash\npython3 get_snapshot_hash.py libapp.so\n``` | `adb4292f3ec25…`
Hash → Engine zuordnen | **enginehash**-Liste in reFlutter | Flutter 3 · 7 · 12 + Engine-Commit `1a65d409…`
Abhängige Commits abrufen | DEPS-Datei in diesem Engine-Commit | • `dart_revision` → Dart v2 · 19 · 6<br>• `dart_boringssl_rev` → BoringSSL `87f316d7…`

Finden Sie [get_snapshot_hash.py hier](https://github.com/Impact-I/reFlutter/blob/main/scripts/get_snapshot_hash.py).

### Ziel: `ssl_crypto_x509_session_verify_cert_chain()`
* Befindet sich in **`ssl_x509.cc`** innerhalb von BoringSSL.
* **Gibt `bool` zurück** – ein einzelnes `true` reicht aus, um die gesamte Zertifikatkette zu umgehen.
* Dieselbe Funktion existiert auf jeder CPU-Architektur; nur die Opcodes unterscheiden sich.

### Option A – Binärpatching mit **reFlutter**
1. **Klonen** Sie die genauen Engine- und Dart-Quellen für die Flutter-Version der App.
2. **Regex-Patch** zwei Hotspots:
* In `ssl_x509.cc`, erzwingen Sie `return 1;`
* (Optional) In `socket_android.cc`, hard-coden Sie einen Proxy (`"10.0.2.2:8080"`).
3. **Re-kompilieren** Sie libflutter.so, fügen Sie es zurück in die APK/IPA ein, signieren Sie es und installieren Sie es.
4. **Vorab-gepatchte Builds** für gängige Versionen werden in den reFlutter GitHub-Releases bereitgestellt, um Stunden an Build-Zeit zu sparen.

### Option B – Live-Hooking mit **Frida** (der „Hardcore“-Weg)
Da das Symbol entfernt ist, scannen Sie das geladene Modul nach seinen ersten Bytes und ändern dann den Rückgabewert zur Laufzeit.
```javascript
// attach & locate libflutter.so
var flutter = Process.getModuleByName("libflutter.so");

// x86-64 pattern of the first 16 bytes of ssl_crypto_x509_session_verify_cert_chain
var sig = "55 41 57 41 56 41 55 41 54 53 48 83 EC 38 C6 02";

Memory.scan(flutter.base, flutter.size, sig, {
onMatch: function (addr) {
console.log("[+] found verifier at " + addr);
Interceptor.attach(addr, {
onLeave: function (retval) { retval.replace(0x1); }  // always 'true'
});
},
onComplete: function () { console.log("scan done"); }
});
```
Bitte geben Sie den Text ein, den Sie übersetzen möchten.
```bash
frida -U -f com.example.app -l bypass.js
```
*Portierungstipps*
* Für **arm64-v8a** oder **armv7**, nimm die ersten ~32 Bytes der Funktion aus Ghidra, konvertiere sie in einen durch Leerzeichen getrennten Hex-String und ersetze `sig`.
* Halte **ein Muster pro Flutter-Version**, speichere sie in einem Spickzettel für schnelle Wiederverwendung.

### Verkehr über deinen Proxy erzwingen
Flutter selbst **ignoriert die Proxy-Einstellungen des Geräts**. Einfachste Optionen:
* **Android Studio Emulator:** Einstellungen ▶ Proxy → manuell.
* **Physisches Gerät:** bösartiger Wi-Fi AP + DNS-Spoofing oder Bearbeitung des Magisk-Moduls `/etc/hosts`.

## Referenzen
- [https://sensepost.com/blog/2025/intercepting-https-communication-in-flutter-going-full-hardcore-mode-with-frida/](https://sensepost.com/blog/2025/intercepting-https-communication-in-flutter-going-full-hardcore-mode-with-frida/)

{{#include /banners/hacktricks-training.md}}
