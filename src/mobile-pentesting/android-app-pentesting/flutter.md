# Flutter

{{#include ../../banners/hacktricks-training.md}}

Flutter 是 **Google 的跨平台 UI 工具包**，允许开发者编写单一的 Dart 代码库，之后 **Engine**（native C/C++）将其转换为针对 Android 与 iOS 的平台特定机器代码。  
Engine 打包了 **Dart VM**、**BoringSSL**、Skia 等，并以共享库的形式发布为 **libflutter.so**（Android）或 **Flutter.framework**（iOS）。所有实际的网络通信（DNS、sockets、TLS）都发生在 **该库内部**，*而不是*在常见的 Java/Kotlin Swift/Obj-C 层。这种隔离设计是常规 Java 层 Frida 钩子在 Flutter 应用上失效的原因。

## 在 Flutter 中拦截 HTTPS 流量

这是对这篇 [blog post](https://sensepost.com/blog/2025/intercepting-https-communication-in-flutter-going-full-hardcore-mode-with-frida/) 的总结。

### 为什么在 Flutter 中拦截 HTTPS 很棘手
* **SSL/TLS verification lives two layers down** 在 BoringSSL 中实现，因此 Java 层的 SSL‐pinning 绕过方法无法触及它。
* **BoringSSL uses its *own* CA store** 位于 libflutter.so 内部；将你的 Burp/ZAP CA 导入 Android 系统证书存储并不会改变任何东西。
* libflutter.so 中的符号被 **stripped & mangled**，证书验证函数对动态工具来说被隐藏了。

### 指纹识别确切的 Flutter 堆栈
知道版本可以让你重建或模式匹配正确的二进制文件。

步骤 | 命令 / 文件 | 结果
----|----|----
获取 snapshot hash | `python3 get_snapshot_hash.py libapp.so` | `adb4292f3ec25…`
映射 hash → Engine | **enginehash** list in reFlutter | Flutter 3 · 7 · 12 + engine commit `1a65d409…`
拉取依赖提交 | DEPS file in that engine commit | • `dart_revision` → Dart v2 · 19 · 6<br>• `dart_boringssl_rev` → BoringSSL `87f316d7…`

在这里找到 [get_snapshot_hash.py](https://github.com/Impact-I/reFlutter/blob/main/scripts/get_snapshot_hash.py)。

### 目标: `ssl_crypto_x509_session_verify_cert_chain()`
* 位于 BoringSSL 内的 **`ssl_x509.cc`** 中。
* **返回 `bool`** —— 单个 `true` 就足以绕过整个证书链检查。
* 相同的函数在每种 CPU arch 上都存在；唯一不同的是 opcode。

### Option A – Binary patching with **reFlutter**
1. **Clone** 应用对应 Flutter 版本的 Engine & Dart 源码。
2. **Regex-patch** 两个热点：
* 在 `ssl_x509.cc` 中，强制 `return 1;`
* （可选）在 `socket_android.cc` 中，硬编码一个代理（`"10.0.2.2:8080"`）。
3. **Re-compile** libflutter.so，替换回 APK/IPA，签名，安装。
4. reFlutter GitHub releases 提供了常见版本的 **预打补丁构建**，可节省大量编译时间。

### Option B – Live hooking with **Frida** (the “hard-core” path)
由于符号被剥离，你需要对已加载模块进行模式扫描以找到其前几条指令，然后在运行时修改返回值。
```javascript
// attach & locate libflutter.so
var flutter = Process.getModuleByName("libflutter.so");

// x86-64 pattern of the first 16 bytes of ssl_crypto_x509_session_verify_cert_chain
var sig = "55 41 57 41 56 41 55 41 54 53 48 83 EC 38 C6 02";

Memory.scan(flutter.base, flutter.size, sig, {
onMatch: function (addr) {
console.log("[+] found verifier at " + addr);
Interceptor.attach(addr, {
onLeave: function (retval) { retval.replace(0x1); }  // always 'true'
});
},
onComplete: function () { console.log("scan done"); }
});
```
我没有收到要翻译的文件内容。请把 src/mobile-pentesting/android-app-pentesting/flutter.md 的内容粘贴到这里（或粘贴你想翻译的部分），我会按要求把英文翻成中文并保留所有 markdown/HTML 标签、代码、链接和路径不变。
```bash
frida -U -f com.example.app -l bypass.js
```
*移植提示*
* 对于 **arm64-v8a** 或 **armv7**，从 Ghidra 抓取函数的前 ~32 个字节，转换为空格分隔的十六进制字符串，然后替换 `sig`。
* 为每个 **Flutter** 发行版保留一条模式，将它们存入备忘单以便快速复用。

### 强制流量通过你的代理
Flutter 本身 **忽略设备代理设置**。最简单的选项：
* **Android Studio emulator:** Settings ▶ Proxy → manual.
* **Physical device:** 恶意 Wi‑Fi AP + DNS 欺骗，或通过 Magisk 模块编辑 `/etc/hosts`。

### 快速 Flutter TLS 绕过工作流程（Frida Codeshare + 系统 CA）
当你只需要观察被 pin 的 Flutter API 时，将 root/可写的 AVD、系统信任的代理 CA 和可直接使用的 Frida 脚本结合使用，通常比逆向工程 libflutter.so 更快：

1. **将你的代理 CA 安装到系统证书库。** 按照 [Install Burp Certificate](install-burp-certificate.md) 的说明，对 Burp 的 DER 证书进行 hash/重命名，并推送到 `/system/etc/security/cacerts/`（需要可写的 `/system`）。

2. **放入匹配的 `frida-server` 二进制并以 root 运行**，以便它可以附着到 Flutter 进程：
```bash
adb push frida-server-17.0.5-android-x86_64 /data/local/tmp/frida-server
adb shell "su -c 'chmod 755 /data/local/tmp/frida-server && /data/local/tmp/frida-server &'"
```
3. **安装主机端工具并枚举目标包。**
```bash
pip3 install frida-tools --break-system-packages
adb shell pm list packages -f | grep target
```
4. **使用 Codeshare 钩子启动 Flutter 应用，以使 BoringSSL 的 pin checks 失效。**
```bash
frida -U -f com.example.target --codeshare TheDauntless/disable-flutter-tls-v1 --no-pause
```
Codeshare 脚本覆写了 Flutter 的 TLS 验证器，使每个证书（包括 Burp 动态生成的证书）都被接受，从而绕过公钥 pin 比对。

5. **Route traffic through your proxy.** 在模拟器的 Wi‑Fi proxy GUI 中配置，或通过 `adb shell settings put global http_proxy 10.0.2.2:8080` 强制设置；如果直接路由失败，则退回使用 `adb reverse tcp:8080 tcp:8080` 或 host-only VPN。

6. **If the app ignores OS proxy settings, redirect sockets with a Frida shim.** 像 **frida4burp** 这样的工具会 hook `dart:io`/BoringSSL 的 socket 创建，强制将出站 TCP 会话导向你的 proxy，即便应用硬编码了 `HttpClient.findProxyFromEnvironment` 或绕过了 Wi‑Fi 设置。在脚本中设置 proxy host/port，并与 TLS bypass 一起运行：
```bash
frida -U -f com.example.target --no-pause \
--codeshare TheDauntless/disable-flutter-tls-v1 \
-l frida4burp.js
```
在 iOS 上通过 Frida gadget 或 USB frida-server 可用；将 socket redirect 与 TLS bypass 链接，可以同时恢复 Burp/mitmproxy 的路由和证书接受。

一旦在 OS 层信任了 CA，并且 Frida 破除了 Flutter 的 pinning logic（必要时再加上 socket redirection），Burp/mitmproxy 就能在无需 repacking APK 的情况下，恢复对 API fuzzing（BOLA、token tampering 等）的完整可见性。

### Offset-based hook of BoringSSL verification (no signature scan)
当 pattern-based scripts 在不同架构（例如 x86_64 vs ARM）间失效时，直接通过 libflutter.so 内的绝对地址 hook BoringSSL 的 chain verifier。工作流程：

- 从 APK 中提取正确 ABI 的库： `unzip -j app.apk "lib/*/libflutter.so" -d libs/`，并选择与设备匹配的那个（例如 `lib/x86_64/libflutter.so`）。
- 在 Ghidra/IDA 中分析并定位 verifier：
- 来源：BoringSSL ssl_x509.cc 函数 `ssl_crypto_x509_session_verify_cert_chain`（3 args，返回 bool）。
- 在 stripped 构建中，使用 **Search → For Strings → `ssl_client` → XREFs**，然后打开每个被引用的 `FUN_...`，选择具有 3 个指针类参数并返回 boolean 的那个。
- 计算运行时偏移：用 Ghidra 显示的函数地址减去 image base（例如 Ghidra 对于 PIE Android ELFs 常显示 `0x00100000`）。示例：`0x02184644 - 0x00100000 = 0x02084644`。
- 在运行时以 base + offset 的方式 hook 并强制成功：
```javascript
// frida -U -f com.target.app -l bypass.js --no-pause
const base = Module.findBaseAddress('libflutter.so');
// Example offset from analysis. Recompute per build/arch.
const off  = ptr('0x02084644');
const addr = base.add(off);

// ssl_crypto_x509_session_verify_cert_chain: 3 args, bool return
Interceptor.replace(addr, new NativeCallback(function (a, b, c) {
return 1; // true
}, 'int', ['pointer', 'pointer', 'pointer']));

console.log('[+] Hooked BoringSSL verify_cert_chain at', addr);
```
注意
- 签名扫描在 ARM 上可能成功，但在 x86_64 上可能未命中，因为 opcode 布局发生变化；只要重新计算 RVA，这种偏移方法与架构无关。
- 此绕过使 BoringSSL 接受任意证书链，从而启用 HTTPS MITM，而不受 Flutter 内部 pins/CA trust 的影响。
- 如果你在调试时强制路由流量以确认 TLS 阻断，例如：
```bash
iptables -t nat -A OUTPUT -p tcp -j DNAT --to-destination <Burp_IP>:<Burp_Port>
```
…你仍然需要上面的 hook，因为验证发生在 libflutter.so 内部，而不是 Android 的系统信任存储。

## 参考资料
- [https://sensepost.com/blog/2025/intercepting-https-communication-in-flutter-going-full-hardcore-mode-with-frida/](https://sensepost.com/blog/2025/intercepting-https-communication-in-flutter-going-full-hardcore-mode-with-frida/)
- [Flutter SSL Bypass: How to Intercept HTTPS Traffic When all other Frida Scripts Fail (vercel)](https://m4kr0.vercel.app/posts/flutter-ssl-bypass-how-to-intercept-https-traffic-when-all-other-frida-scripts-fail/)
- [Flutter SSL Bypass: How to Intercept HTTPS Traffic When all other Frida Scripts Fail (medium)](https://m4kr0x.medium.com/flutter-tls-bypass-how-to-intercept-https-traffic-when-all-other-frida-scripts-fail-bd3d04489088)
- [PoC Frida hook for Flutter SSL bypass](https://github.com/m4kr0x/flutter_ssl_bypass)
- [BoringSSL ssl_x509.cc (ssl_crypto_x509_session_verify_cert_chain)](https://github.com/google/boringssl/blob/main/ssl/ssl_x509.cc#L238)
- [SSL Pinning Bypass – Android](https://hardsoftsecurity.es/index.php/2025/11/26/ssl-pinning-bypass-android/)
- [Practical Mobile Traffic Interception](https://medium.com/@justmobilesec/practical-mobile-traffic-interception-1481e33d974e)


{{#include ../../banners/hacktricks-training.md}}
