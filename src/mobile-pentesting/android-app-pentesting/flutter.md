# Flutter

{{#include ../../banners/hacktricks-training.md}}

Flutter 是 **Google 的跨平台 UI 工具包**，允许开发者编写单一的 Dart 代码库，而 **Engine**（原生 C/C++）将其转换为针对 Android & iOS 的平台特定机器代码。
Engine 打包了 **Dart VM**、**BoringSSL**、Skia 等，并以共享库 **libflutter.so**（Android）或 **Flutter.framework**（iOS）的形式发布。所有实际的网络操作（DNS、sockets、TLS）都发生在 **这个库内部**，*而不是* 通常的 Java/Kotlin 或 Swift/Obj-C 层。这样的孤立设计就是常规 Java 级别的 Frida 钩子在 Flutter 应用上失效的原因。

## 在 Flutter 中拦截 HTTPS 流量

这是这篇 [博客文章](https://sensepost.com/blog/2025/intercepting-https-communication-in-flutter-going-full-hardcore-mode-with-frida/) 的摘要。

### 为什么在 Flutter 中拦截 HTTPS 很棘手
* **SSL/TLS 验证位于两层之下** 的 BoringSSL，因此 Java 级的 SSL‐pinning 绕过不会触及它。
* **BoringSSL 在 libflutter.so 内使用其 *自己的* CA 存储**；将你的 Burp/ZAP CA 导入到 Android 的系统存储并不会改变任何东西。
* libflutter.so 中的符号被 **剥离和混淆**，这将证书验证函数对动态工具隐藏起来。

### 指纹识别准确的 Flutter 堆栈
知道版本能让你重建或用模式匹配找到正确的二进制文件。

步骤 | 命令 / 文件 | 结果
----|----|----
获取 snapshot 哈希 | `python3 get_snapshot_hash.py libapp.so` | `adb4292f3ec25…`
将哈希映射到 Engine | **enginehash** 列表在 reFlutter 中 | Flutter 3 · 7 · 12 + engine commit `1a65d409…`
拉取依赖提交 | DEPS 文件在该 engine commit 中 | • `dart_revision` → Dart v2 · 19 · 6<br>• `dart_boringssl_rev` → BoringSSL `87f316d7…`

Find [get_snapshot_hash.py here](https://github.com/Impact-I/reFlutter/blob/main/scripts/get_snapshot_hash.py).

### 目标：`ssl_crypto_x509_session_verify_cert_chain()`
* 位于 BoringSSL 内的 **`ssl_x509.cc`** 中。
* **返回 `bool`** —— 单个 `true` 就足以绕过整个证书链校验。
* 相同函数在每种 CPU 架构上都存在；唯一区别是 opcode。

### Option A – 使用 **reFlutter** 进行二进制补丁
1. **Clone** 应用对应 Flutter 版本的精确 Engine & Dart 源码。
2. **Regex-patch** 两个热点：
* 在 `ssl_x509.cc` 中，强制 `return 1;`
* （可选）在 `socket_android.cc` 中，硬编码一个代理（`"10.0.2.2:8080"`）。
3. **Re-compile** libflutter.so，把它放回 APK/IPA，签名并安装。
4. 为常见版本提供的 **Pre-patched builds** 已包含在 reFlutter 的 GitHub releases 中，以节省数小时的构建时间。

### Option B – 使用 **Frida** 进行实时钩取（“硬核”路径）
由于符号被剥离，你需要对加载的模块做模式扫描以找到其前几字节，然后在运行时修改返回值。
```javascript
// attach & locate libflutter.so
var flutter = Process.getModuleByName("libflutter.so");

// x86-64 pattern of the first 16 bytes of ssl_crypto_x509_session_verify_cert_chain
var sig = "55 41 57 41 56 41 55 41 54 53 48 83 EC 38 C6 02";

Memory.scan(flutter.base, flutter.size, sig, {
onMatch: function (addr) {
console.log("[+] found verifier at " + addr);
Interceptor.attach(addr, {
onLeave: function (retval) { retval.replace(0x1); }  // always 'true'
});
},
onComplete: function () { console.log("scan done"); }
});
```
请粘贴或附上 src/mobile-pentesting/android-app-pentesting/flutter.md 的内容（或确认我可以直接使用该文件）。我会按要求把英文翻译成中文，并保留所有 markdown/HTML 标签、路径和不可翻译项不变。
```bash
frida -U -f com.example.app -l bypass.js
```
*移植提示*
* 对于 **arm64-v8a** 或 **armv7**，从 Ghidra 获取函数的前 ~32 字节，转换为以空格分隔的十六进制字符串，然后替换 `sig`。
* 为每个 **Flutter** 版本保留一条模式，并将它们存入速查表以便快速重用。

### 强制流量通过你的代理
Flutter 本身**忽略设备的代理设置**。最简单的选项：
* **Android Studio emulator:** Settings ▶ Proxy → manual.
* **Physical device:** evil Wi-Fi AP + DNS spoofing，或使用 Magisk 模块编辑 `/etc/hosts`。

### 快速 Flutter TLS 绕过工作流程 (Frida Codeshare + system CA)
当你只需要观察被 pin 的 Flutter API 时，结合一个已 root/可写的 AVD、一个系统信任的代理 CA 以及一个可直接替换的 Frida 脚本，通常比逆向工程 libflutter.so 更快：

1. **将你的代理 CA 安装到系统存储。** 按照 [Install Burp Certificate](install-burp-certificate.md) 对 Burp 的 DER 证书进行 hash/重命名，并推送到 `/system/etc/security/cacerts/`（需要可写的 `/system`）。

2. **放置匹配的 `frida-server` 二进制并以 root 运行**，以便它能附加到 Flutter 进程：
```bash
adb push frida-server-17.0.5-android-x86_64 /data/local/tmp/frida-server
adb shell "su -c 'chmod 755 /data/local/tmp/frida-server && /data/local/tmp/frida-server &'"
```
3. **安装主机端工具并枚举目标包。**
```bash
pip3 install frida-tools --break-system-packages
adb shell pm list packages -f | grep target
```
4. **使用包含可使 BoringSSL pin checks 无效的 Codeshare hook 启动 Flutter 应用。**
```bash
frida -U -f com.example.target --codeshare TheDauntless/disable-flutter-tls-v1 --no-pause
```
The Codeshare script overrides the Flutter TLS verifier so every certificate (including Burp's dynamically generated ones) is accepted, side-stepping public-key pin comparisons.

5. **通过你的代理路由流量。** 配置模拟器的 Wi-Fi proxy GUI，或通过 `adb shell settings put global http_proxy 10.0.2.2:8080` 强制设置；如果直接路由失败，回退到 `adb reverse tcp:8080 tcp:8080` 或 host-only VPN。

一旦 CA 在 OS 层被信任且 Frida 弹压（quashes）了 Flutter 的 pinning 逻辑，Burp/mitmproxy 就能在不重新打包 APK 的情况下恢复对 API fuzzing（BOLA、token 篡改等）的完全可见性。

### Offset-based hook of BoringSSL verification (no signature scan)
When pattern-based scripts fail across architectures (e.g., x86_64 vs ARM), directly hook the BoringSSL chain verifier by absolute address within libflutter.so. Workflow:

- 从 APK 中提取匹配 ABI 的库：`unzip -j app.apk "lib/*/libflutter.so" -d libs/`，并选择与设备匹配的那一个（例如 `lib/x86_64/libflutter.so`）。
- 在 Ghidra/IDA 中分析并定位 verifier：
- 来源：BoringSSL ssl_x509.cc 函数 `ssl_crypto_x509_session_verify_cert_chain`（3 个参数，返回 bool）。
- 在 stripped builds 中，搜索字符串 `"ssl_client"` 并检查 XREFs；识别接受三个类似指针参数并返回布尔值的函数。
- 计算运行时偏移：取 Ghidra 显示的函数地址并减去分析时使用的 image base，以得到相对偏移（RVA）。示例：`0x02184644 - 0x00100000 = 0x02084644`。
- 在运行时按 base + offset 进行 hook 并强制返回成功：
```javascript
// frida -U -f com.target.app -l bypass.js --no-pause
const base = Module.findBaseAddress('libflutter.so');
// Example offset from analysis. Recompute per build/arch.
const off  = ptr('0x02084644');
const addr = base.add(off);

// ssl_crypto_x509_session_verify_cert_chain: 3 args, bool return
Interceptor.replace(addr, new NativeCallback(function (a, b, c) {
return 1; // true
}, 'int', ['pointer', 'pointer', 'pointer']));

console.log('[+] Hooked BoringSSL verify_cert_chain at', addr);
```
注意
- 重新计算每个目标构建和 CPU 架构的偏移；编译器/代码生成差异会破坏硬编码的签名。
- 此绕过会使 BoringSSL 接受任意链，从而在 Flutter 内部无视 pins/CA trust，启用 HTTPS MITM。
- 如果你在调试期间强制路由流量以确认 TLS 阻断，例如：
```bash
iptables -t nat -A OUTPUT -p tcp -j DNAT --to-destination <Burp_IP>:<Burp_Port>
```
…你仍然需要上面的 hook，因为验证发生在 libflutter.so 内，而不是 Android’s system trust store。

## 参考资料
- [https://sensepost.com/blog/2025/intercepting-https-communication-in-flutter-going-full-hardcore-mode-with-frida/](https://sensepost.com/blog/2025/intercepting-https-communication-in-flutter-going-full-hardcore-mode-with-frida/)
- [Flutter SSL Bypass: How to Intercept HTTPS Traffic When all other Frida Scripts Fail](https://m4kr0x.medium.com/flutter-tls-bypass-how-to-intercept-https-traffic-when-all-other-frida-scripts-fail-bd3d04489088)
- [BoringSSL ssl_x509.cc (ssl_crypto_x509_session_verify_cert_chain)](https://github.com/google/boringssl/blob/main/ssl/ssl_x509.cc#L238)
- [SSL Pinning Bypass – Android](https://hardsoftsecurity.es/index.php/2025/11/26/ssl-pinning-bypass-android/)


{{#include ../../banners/hacktricks-training.md}}
