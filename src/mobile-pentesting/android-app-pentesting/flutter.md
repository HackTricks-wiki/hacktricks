# Flutter

{{#include ../../banners/hacktricks-training.md}}

Flutter, geliştiricilerin tek bir Dart kod tabanı yazmasını sağlayan Google’ın çapraz-platform UI toolkit’idir; Engine (native C/C++) bu kodu Android ve iOS için platforma özgü makine koduna dönüştürür.
Engine, içinde bir Dart VM, BoringSSL, Skia vb. paketler ve Android için paylaşılan kütüphane libflutter.so veya iOS için Flutter.framework olarak gönderilir. Tüm gerçek networking (DNS, sockets, TLS) bu kütüphane içinde gerçekleşir, alışılmış Java/Kotlin veya Swift/Obj‑C katmanlarında değil. Bu izole tasarım, sıradan Java seviyesindeki Frida hook’larının Flutter uygulamalarında çalışmamasının nedenidir.

## Intercepting HTTPS traffic in Flutter

This is a summary of this [blog post](https://sensepost.com/blog/2025/intercepting-https-communication-in-flutter-going-full-hardcore-mode-with-frida/).

### Why HTTPS interception is tricky in Flutter
* **SSL/TLS verification lives two layers down** in BoringSSL, so Java SSL‐pinning bypasses don’t touch it.
* **BoringSSL uses its *own* CA store** inside libflutter.so; importing your Burp/ZAP CA into Android’s system store changes nothing.
* Symbols in libflutter.so are **stripped & mangled**, hiding the certificate-verification function from dynamic tools.

### Fingerprint the exact Flutter stack
Sürümü bilmek, doğru ikili dosyaları yeniden derlemenize veya desen eşleştirmesine olanak verir.

Step | Command / File | Outcome
----|----|----
Get snapshot hash | `python3 get_snapshot_hash.py libapp.so` | `adb4292f3ec25…`
Map hash → Engine | **enginehash** list in reFlutter | Flutter 3 · 7 · 12 + engine commit `1a65d409…`
Pull dependent commits | DEPS file in that engine commit | • `dart_revision` → Dart v2 · 19 · 6<br>• `dart_boringssl_rev` → BoringSSL `87f316d7…`

Find [get_snapshot_hash.py here](https://github.com/Impact-I/reFlutter/blob/main/scripts/get_snapshot_hash.py).

### Target: `ssl_crypto_x509_session_verify_cert_chain()`
* Located in **`ssl_x509.cc`** inside BoringSSL.
* **Returns `bool`** – a single `true` is enough to bypass the whole certificate chain check.
* Same function exists on every CPU arch; only the opcodes differ.

### Option A – Binary patching with **reFlutter**
1. **Clone** the exact Engine & Dart sources for the app’s Flutter version.
2. **Regex-patch** two hotspots:
* In `ssl_x509.cc`, force `return 1;`
* (Optional) In `socket_android.cc`, hard-code a proxy (`"10.0.2.2:8080"`).
3. **Re-compile** libflutter.so, drop it back into the APK/IPA, sign, install.
4. **Pre-patched builds** for common versions are shipped in the reFlutter GitHub releases to save hours of build time.

### Option B – Live hooking with **Frida** (the “hard-core” path)
Because the symbol is stripped, you pattern-scan the loaded module for its first bytes, then change the return value on the fly.
```javascript
// attach & locate libflutter.so
var flutter = Process.getModuleByName("libflutter.so");

// x86-64 pattern of the first 16 bytes of ssl_crypto_x509_session_verify_cert_chain
var sig = "55 41 57 41 56 41 55 41 54 53 48 83 EC 38 C6 02";

Memory.scan(flutter.base, flutter.size, sig, {
onMatch: function (addr) {
console.log("[+] found verifier at " + addr);
Interceptor.attach(addr, {
onLeave: function (retval) { retval.replace(0x1); }  // always 'true'
});
},
onComplete: function () { console.log("scan done"); }
});
```
Dosya içeriği sağlanmamış. Lütfen src/mobile-pentesting/android-app-pentesting/flutter.md dosyasının içeriğini yapıştırın veya yükleyin. Çeviri yaparken:

- Kod, teknik terimler, hacking terimleri, cloud/SaaS isimleri, linkler, path'ler ve markdown/html tag'ları değiştirmeyeceğim.
- Diğer İngilizce metinleri Türkçeye çevireceğim ve orijinal markdown yapısını koruyacağım.
```bash
frida -U -f com.example.app -l bypass.js
```
*Portlama ipuçları*
* For **arm64-v8a** or **armv7**, Ghidra'dan fonksiyonun ilk ~32 baytını alın, boşlukla ayrılmış bir hex string'e çevirin ve `sig` ile değiştirin.
* Keep **one pattern per Flutter release**, bunları hızlı yeniden kullanım için bir cheat-sheet'te saklayın.

### Trafiği proxy'niz üzerinden yönlendirme
Flutter itself **ignores device proxy settings**. En kolay seçenekler:
* **Android Studio emulator:** Settings ▶ Proxy → manual.
* **Physical device:** evil Wi-Fi AP + DNS spoofing, veya Magisk modülü ile `/etc/hosts` düzenleme.

### Hızlı Flutter TLS bypass iş akışı (Frida Codeshare + system CA)
Sadece pinlenmiş bir Flutter API'sini gözlemlemeniz gerektiğinde, rootlu/yazılabilir bir AVD, sistem tarafından güvenilen bir proxy CA ve drop-in bir Frida scriptini birleştirmek genellikle libflutter.so'yu tersine mühendislik yapmaktan daha hızlıdır:

1. **Install your proxy CA in the system store.** [Install Burp Certificate](install-burp-certificate.md) yönergelerini izleyerek Burp'un DER sertifikasını hash/yeniden adlandırın ve `/system/etc/security/cacerts/` içine pushlayın (yazılabilir `/system` gerekli).

2. **Drop a matching `frida-server` binary and run it as root** böylece Flutter sürecine attach olabilecek:
```bash
adb push frida-server-17.0.5-android-x86_64 /data/local/tmp/frida-server
adb shell "su -c 'chmod 755 /data/local/tmp/frida-server && /data/local/tmp/frida-server &'"
```
3. **Host-side tooling'i yükleyin ve hedef paketi enumerate edin.**
```bash
pip3 install frida-tools --break-system-packages
adb shell pm list packages -f | grep target
```
4. **Codeshare hook ile BoringSSL pin kontrollerini etkisiz hale getiren Flutter uygulamasını başlatın.**
```bash
frida -U -f com.example.target --codeshare TheDauntless/disable-flutter-tls-v1 --no-pause
```
The Codeshare script overrides the Flutter TLS verifier so every certificate (including Burp's dynamically generated ones) is accepted, side-stepping public-key pin comparisons.

5. **Trafiği proxy'niz üzerinden yönlendirin.** Emülatörün Wi‑Fi proxy GUI'sini yapılandırın veya `adb shell settings put global http_proxy 10.0.2.2:8080` ile zorlayın; doğrudan yönlendirme başarısız olursa, `adb reverse tcp:8080 tcp:8080` veya ağa özel (host-only) VPN'e geri dönün.

Once the CA is trusted at the OS layer and Frida quashes Flutter's pinning logic, Burp/mitmproxy regains full visibility for API fuzzing (BOLA, token tampering, etc.) without repacking the APK.

### BoringSSL doğrulaması için offset-based hook (imza taraması yok)
When pattern-based scripts fail across architectures (e.g., x86_64 vs ARM), directly hook the BoringSSL chain verifier by absolute address within libflutter.so. Workflow:

- Extract the right-ABI library from the APK: `unzip -j app.apk "lib/*/libflutter.so" -d libs/` and pick the one matching the device (e.g., `lib/x86_64/libflutter.so`).
- Analyze in Ghidra/IDA and locate the verifier:
- Source: BoringSSL ssl_x509.cc function `ssl_crypto_x509_session_verify_cert_chain` (3 args, returns bool).
- In stripped builds, search for the string `"ssl_client"` and inspect XREFs; identify the function taking three pointer-like args and returning a boolean.
- Compute the runtime offset: take the function address shown by Ghidra and subtract the image base used during analysis to get the relative offset (RVA). Example: `0x02184644 - 0x00100000 = 0x02084644`.
- Hook at runtime by base + offset and force success:
```javascript
// frida -U -f com.target.app -l bypass.js --no-pause
const base = Module.findBaseAddress('libflutter.so');
// Example offset from analysis. Recompute per build/arch.
const off  = ptr('0x02084644');
const addr = base.add(off);

// ssl_crypto_x509_session_verify_cert_chain: 3 args, bool return
Interceptor.replace(addr, new NativeCallback(function (a, b, c) {
return 1; // true
}, 'int', ['pointer', 'pointer', 'pointer']));

console.log('[+] Hooked BoringSSL verify_cert_chain at', addr);
```
Notlar
- Her hedef build ve CPU mimarisi için offset'i yeniden hesaplayın; compiler/codegen farklılıkları sabit kodlanmış imzaları bozabilir.
- Bu bypass, BoringSSL'in herhangi bir zinciri kabul etmesine neden olur; Flutter içindeki pins/CA trust ne olursa olsun HTTPS MITM mümkün olur.
- TLS engellemesini doğrulamak için debugging sırasında trafiği force-route ederseniz, e.g.:
```bash
iptables -t nat -A OUTPUT -p tcp -j DNAT --to-destination <Burp_IP>:<Burp_Port>
```
…yine de yukarıdaki hook'a ihtiyacınız olacak, çünkü doğrulama libflutter.so içinde gerçekleşiyor, Android'in system trust store'unda değil.

## Referanslar
- [https://sensepost.com/blog/2025/intercepting-https-communication-in-flutter-going-full-hardcore-mode-with-frida/](https://sensepost.com/blog/2025/intercepting-https-communication-in-flutter-going-full-hardcore-mode-with-frida/)
- [Flutter SSL Bypass: How to Intercept HTTPS Traffic When all other Frida Scripts Fail](https://m4kr0x.medium.com/flutter-tls-bypass-how-to-intercept-https-traffic-when-all-other-frida-scripts-fail-bd3d04489088)
- [BoringSSL ssl_x509.cc (ssl_crypto_x509_session_verify_cert_chain)](https://github.com/google/boringssl/blob/main/ssl/ssl_x509.cc#L238)
- [SSL Pinning Bypass – Android](https://hardsoftsecurity.es/index.php/2025/11/26/ssl-pinning-bypass-android/)


{{#include ../../banners/hacktricks-training.md}}
