# Flutter

{{#include ../../banners/hacktricks-training.md}}

Flutter is **Google’s cross-platform UI toolkit** that lets developers write a single Dart code-base which the **Engine** (native C/C++) turns into platform-specific machine code for Android & iOS.
The Engine bundles a **Dart VM**, **BoringSSL**, Skia, etc., and ships as the shared library **libflutter.so** (Android) or **Flutter.framework** (iOS). All actual networking (DNS, sockets, TLS) happens **inside this library**, *not* in the usual Java/Kotlin Swift/Obj-C layers. That siloed design is why the usual Java-level Frida hooks fail on Flutter apps.

## Παρεμβολή της κίνησης HTTPS σε Flutter

Αυτό είναι μια σύνοψη αυτού του [blog post](https://sensepost.com/blog/2025/intercepting-https-communication-in-flutter-going-full-hardcore-mode-with-frida/).

### Γιατί η παρεμβολή HTTPS είναι δύσκολη στο Flutter
* **Η επαλήθευση SSL/TLS βρίσκεται δύο στρώματα πιο κάτω** στο BoringSSL, οπότε οι Java SSL‐pinning bypasses δεν το επηρεάζουν.
* **Το BoringSSL χρησιμοποιεί το *δικό* του CA store** μέσα στο libflutter.so· εισαγωγή του Burp/ZAP CA στο Android’s system store δεν αλλάζει τίποτα.
* Τα symbols στο libflutter.so είναι **stripped & mangled**, κρύβοντας τη συνάρτηση επαλήθευσης πιστοποιητικών από τα dynamic εργαλεία.

### Fingerprint the exact Flutter stack
Η γνώση της έκδοσης σας επιτρέπει να επαναχτίσετε ή να κάνετε pattern-match τα σωστά binaries.

Step | Εντολή / Αρχείο | Αποτέλεσμα
----|----|----
Get snapshot hash | `python3 get_snapshot_hash.py libapp.so` | `adb4292f3ec25…`
Map hash → Engine | **enginehash** list in reFlutter | Flutter 3 · 7 · 12 + engine commit `1a65d409…`
Pull dependent commits | DEPS file in that engine commit | • `dart_revision` → Dart v2 · 19 · 6<br>• `dart_boringssl_rev` → BoringSSL `87f316d7…`

Find [get_snapshot_hash.py here](https://github.com/Impact-I/reFlutter/blob/main/scripts/get_snapshot_hash.py).

### Target: `ssl_crypto_x509_session_verify_cert_chain()`
* Located in **`ssl_x509.cc`** inside BoringSSL.
* **Returns `bool`** – a single `true` is enough to bypass the whole certificate chain check.
* Same function exists on every CPU arch; only the opcodes differ.

### Option A – Binary patching with **reFlutter**
1. **Clone** the exact Engine & Dart sources for the app’s Flutter version.
2. **Regex-patch** two hotspots:
* In `ssl_x509.cc`, force `return 1;`
* (Optional) In `socket_android.cc`, hard-code a proxy (`"10.0.2.2:8080"`).
3. **Re-compile** libflutter.so, drop it back into the APK/IPA, sign, install.
4. **Pre-patched builds** for common versions are shipped in the reFlutter GitHub releases to save hours of build time.

### Option B – Live hooking with **Frida** (the “hard-core” path)
Επειδή το symbol είναι stripped, κάνετε pattern-scan στο φορτωμένο module για τα πρώτα bytes του, και μετά αλλάζετε την τιμή επιστροφής εν πτήσει.
```javascript
// attach & locate libflutter.so
var flutter = Process.getModuleByName("libflutter.so");

// x86-64 pattern of the first 16 bytes of ssl_crypto_x509_session_verify_cert_chain
var sig = "55 41 57 41 56 41 55 41 54 53 48 83 EC 38 C6 02";

Memory.scan(flutter.base, flutter.size, sig, {
onMatch: function (addr) {
console.log("[+] found verifier at " + addr);
Interceptor.attach(addr, {
onLeave: function (retval) { retval.replace(0x1); }  // always 'true'
});
},
onComplete: function () { console.log("scan done"); }
});
```
I don't have the contents of src/mobile-pentesting/android-app-pentesting/flutter.md. Please paste the markdown you want translated (or grant the file content), and I'll translate the English text to Greek while preserving code, tags, links, paths and markdown exactly as requested.
```bash
frida -U -f com.example.app -l bypass.js
```
*Συμβουλές μεταφοράς*
* Για **arm64-v8a** ή **armv7**, πάρε τα πρώτα ~32 bytes της συνάρτησης από Ghidra, μετέτρεψέ τα σε δεκαεξαδικό string χωρισμένο με κενά, και αντικατέστησε το `sig`.
* Διατήρησε **ένα pattern ανά Flutter release**, αποθήκευσέ τα σε ένα cheat-sheet για γρήγορη επαναχρησιμοποίηση.

### Ανακατεύθυνση κίνησης μέσω του proxy σου
Flutter itself **ignores device proxy settings**. Easiest options:
* **Android Studio emulator:** Settings ▶ Proxy → manual.
* **Φυσική συσκευή:** evil Wi-Fi AP + DNS spoofing, or Magisk module editing `/etc/hosts`.

### Γρήγορη ροή εργασίας bypass TLS για Flutter (Frida Codeshare + system CA)
Όταν χρειάζεσαι μόνο να παρατηρήσεις ένα pinned Flutter API, ο συνδυασμός ενός rooted/writable AVD, ενός system-trusted proxy CA, και ενός drop-in Frida script είναι συχνά ταχύτερος από το reverse-engineering του libflutter.so:

1. **Install your proxy CA in the system store.** Follow [Install Burp Certificate](install-burp-certificate.md) to hash/rename Burp's DER certificate and push it into `/system/etc/security/cacerts/` (writable `/system` required).

2. **Drop a matching `frida-server` binary and run it as root** so it can attach to the Flutter process:
```bash
adb push frida-server-17.0.5-android-x86_64 /data/local/tmp/frida-server
adb shell "su -c 'chmod 755 /data/local/tmp/frida-server && /data/local/tmp/frida-server &'"
```
3. **Εγκαταστήστε τα εργαλεία στην πλευρά του host και απαριθμήστε το πακέτο-στόχο.**
```bash
pip3 install frida-tools --break-system-packages
adb shell pm list packages -f | grep target
```
4. **Εκκίνησε την εφαρμογή Flutter με το Codeshare hook που απενεργοποιεί τους ελέγχους pin του BoringSSL.**
```bash
frida -U -f com.example.target --codeshare TheDauntless/disable-flutter-tls-v1 --no-pause
```
The Codeshare script overrides the Flutter TLS verifier so every certificate (including Burp's dynamically generated ones) is accepted, side-stepping public-key pin comparisons.

5. **Route traffic through your proxy.** Configure the emulator Wi-Fi proxy GUI or enforce it via `adb shell settings put global http_proxy 10.0.2.2:8080`; if direct routing fails, fall back to `adb reverse tcp:8080 tcp:8080` or a host-only VPN.

6. **If the app ignores OS proxy settings, redirect sockets with a Frida shim.** Tools like **frida4burp** hook `dart:io`/BoringSSL socket creation to force outbound TCP sessions to your proxy, even with hardcoded `HttpClient.findProxyFromEnvironment` or Wi‑Fi bypasses. Set the proxy host/port in the script and run it alongside the TLS bypass:
```bash
frida -U -f com.example.target --no-pause \
--codeshare TheDauntless/disable-flutter-tls-v1 \
-l frida4burp.js
```
Λειτουργεί σε iOS μέσω Frida gadget ή USB frida-server· η αλυσίδωση του socket redirect με το TLS bypass αποκαθιστά τόσο τη δρομολόγηση όσο και την αποδοχή πιστοποιητικών για Burp/mitmproxy.

Μόλις η CA εμπιστευτεί σε επίπεδο OS και το Frida καταργήσει τη λογική pinning του Flutter (συν socket redirection αν χρειάζεται), το Burp/mitmproxy ανακτά πλήρη ορατότητα για API fuzzing (BOLA, token tampering, κ.λπ.) χωρίς επαναπακετάρισμα του APK.

### Offset-based hook της επαλήθευσης του BoringSSL (no signature scan)
Όταν τα pattern-based scripts αποτυγχάνουν μεταξύ αρχιτεκτονικών (π.χ. x86_64 vs ARM), κάνετε απευθείας hook στον chain verifier του BoringSSL με απόλυτη διεύθυνση μέσα σε libflutter.so. Workflow:

- Εξάγετε τη βιβλιοθήκη με το σωστό ABI από το APK: `unzip -j app.apk "lib/*/libflutter.so" -d libs/` και επιλέξτε αυτή που ταιριάζει στη συσκευή (π.χ. `lib/x86_64/libflutter.so`).
- Αναλύστε με Ghidra/IDA και εντοπίστε τον verifier:
- Πηγή: BoringSSL ssl_x509.cc function `ssl_crypto_x509_session_verify_cert_chain` (3 args, returns bool).
- Σε stripped builds, χρησιμοποιήστε **Search → For Strings → `ssl_client` → XREFs**, στη συνέχεια ανοίξτε κάθε referenced `FUN_...` και επιλέξτε αυτόν με 3 args τύπου pointer και boolean επιστροφή.
- Υπολογίστε το runtime offset: πάρτε τη διεύθυνση της συνάρτησης που δείχνει το Ghidra και αφαιρέστε το image base (π.χ. το Ghidra συχνά δείχνει `0x00100000` για PIE Android ELFs). Παράδειγμα: `0x02184644 - 0x00100000 = 0x02084644`.
- Κάντε hook στο runtime με base + offset και επιβάλετε επιτυχία:
```javascript
// frida -U -f com.target.app -l bypass.js --no-pause
const base = Module.findBaseAddress('libflutter.so');
// Example offset from analysis. Recompute per build/arch.
const off  = ptr('0x02084644');
const addr = base.add(off);

// ssl_crypto_x509_session_verify_cert_chain: 3 args, bool return
Interceptor.replace(addr, new NativeCallback(function (a, b, c) {
return 1; // true
}, 'int', ['pointer', 'pointer', 'pointer']));

console.log('[+] Hooked BoringSSL verify_cert_chain at', addr);
```
Σημειώσεις
- Οι Signature scans μπορούν να πετύχουν σε ARM αλλά να αποτύχουν σε x86_64 επειδή η διάταξη των opcode αλλάζει· αυτή η offset method είναι architecture-agnostic αρκεί να επαναϋπολογίσεις το RVA.
- Αυτό το bypass προκαλεί το BoringSSL να αποδέχεται οποιαδήποτε chain, επιτρέποντας HTTPS MITM ανεξάρτητα από pins/CA trust μέσα στο Flutter.
- Εάν force-route την κυκλοφορία κατά το debugging για να επιβεβαιώσεις το TLS blocking, π.χ.:
```bash
iptables -t nat -A OUTPUT -p tcp -j DNAT --to-destination <Burp_IP>:<Burp_Port>
```
…θα εξακολουθήσετε να χρειάζεστε το παραπάνω hook, καθώς η επαλήθευση συμβαίνει μέσα στο libflutter.so, όχι στο system trust store του Android.

## Αναφορές
- [https://sensepost.com/blog/2025/intercepting-https-communication-in-flutter-going-full-hardcore-mode-with-frida/](https://sensepost.com/blog/2025/intercepting-https-communication-in-flutter-going-full-hardcore-mode-with-frida/)
- [Flutter SSL Bypass: How to Intercept HTTPS Traffic When all other Frida Scripts Fail (vercel)](https://m4kr0.vercel.app/posts/flutter-ssl-bypass-how-to-intercept-https-traffic-when-all-other-frida-scripts-fail/)
- [Flutter SSL Bypass: How to Intercept HTTPS Traffic When all other Frida Scripts Fail (medium)](https://m4kr0x.medium.com/flutter-tls-bypass-how-to-intercept-https-traffic-when-all-other-frida-scripts-fail-bd3d04489088)
- [PoC Frida hook for Flutter SSL bypass](https://github.com/m4kr0x/flutter_ssl_bypass)
- [BoringSSL ssl_x509.cc (ssl_crypto_x509_session_verify_cert_chain)](https://github.com/google/boringssl/blob/main/ssl/ssl_x509.cc#L238)
- [SSL Pinning Bypass – Android](https://hardsoftsecurity.es/index.php/2025/11/26/ssl-pinning-bypass-android/)
- [Practical Mobile Traffic Interception](https://medium.com/@justmobilesec/practical-mobile-traffic-interception-1481e33d974e)


{{#include ../../banners/hacktricks-training.md}}
