# Flutter

{{#include ../../banners/hacktricks-training.md}}

Flutter é o **Google’s cross-platform UI toolkit** que permite aos desenvolvedores escreverem uma única base de código Dart que o **Engine** (native C/C++) transforma em código de máquina específico da plataforma para Android & iOS.
O Engine agrupa um **Dart VM**, **BoringSSL**, Skia, etc., e é entregue como a biblioteca compartilhada **libflutter.so** (Android) ou **Flutter.framework** (iOS). Todo o networking real (DNS, sockets, TLS) acontece **dentro dessa biblioteca**, *não* nas camadas Java/Kotlin Swift/Obj-C usuais. Esse design isolado é o motivo pelo qual os hooks do Frida a nível Java normalmente falham em apps Flutter.

## Intercepting HTTPS traffic in Flutter

This is a summary of this [blog post](https://sensepost.com/blog/2025/intercepting-https-communication-in-flutter-going-full-hardcore-mode-with-frida/).

### Why HTTPS interception is tricky in Flutter
* **SSL/TLS verification lives two layers down** in BoringSSL, so Java SSL‐pinning bypasses don’t touch it.
* **BoringSSL uses its *own* CA store** inside libflutter.so; importing your Burp/ZAP CA into Android’s system store changes nothing.
* Symbols in libflutter.so are **removidos e ofuscados**, escondendo a função de verificação de certificados de ferramentas dinâmicas.

### Fingerprint the exact Flutter stack
Saber a versão permite que você recompile ou faça pattern-match nos binários corretos.

Step | Command / File | Outcome
----|----|----
Get snapshot hash | `python3 get_snapshot_hash.py libapp.so` | `adb4292f3ec25…`
Map hash → Engine | **enginehash** list in reFlutter | Flutter 3 · 7 · 12 + engine commit `1a65d409…`
Pull dependent commits | DEPS file in that engine commit | • `dart_revision` → Dart v2 · 19 · 6<br>• `dart_boringssl_rev` → BoringSSL `87f316d7…`

Find [get_snapshot_hash.py here](https://github.com/Impact-I/reFlutter/blob/main/scripts/get_snapshot_hash.py).

### Alvo: `ssl_crypto_x509_session_verify_cert_chain()`
* Localizado em **`ssl_x509.cc`** dentro do BoringSSL.
* **Returns `bool`** – um único `true` é suficiente para ignorar toda a checagem da cadeia de certificados.
* A mesma função existe em todas as arquiteturas CPU; apenas os opcodes diferem.

### Option A – Binary patching with **reFlutter**
1. **Clone** as fontes exatas do Engine & Dart para a versão Flutter do app.
2. **Regex-patch** dois pontos críticos:
* Em `ssl_x509.cc`, forçar `return 1;`
* (Opcional) Em `socket_android.cc`, codificar estaticamente um proxy (`"10.0.2.2:8080"`).
3. **Re-compile** libflutter.so, coloque-a de volta no APK/IPA, assine, instale.
4. **Pre-patched builds** para versões comuns são fornecidas nos releases do reFlutter no GitHub para economizar horas de build.

### Option B – Live hooking with **Frida** (the “hard-core” path)
Como o símbolo é removido, você faz pattern-scan no módulo carregado pelos seus primeiros bytes e então altera o valor de retorno em tempo de execução.
```javascript
// attach & locate libflutter.so
var flutter = Process.getModuleByName("libflutter.so");

// x86-64 pattern of the first 16 bytes of ssl_crypto_x509_session_verify_cert_chain
var sig = "55 41 57 41 56 41 55 41 54 53 48 83 EC 38 C6 02";

Memory.scan(flutter.base, flutter.size, sig, {
onMatch: function (addr) {
console.log("[+] found verifier at " + addr);
Interceptor.attach(addr, {
onLeave: function (retval) { retval.replace(0x1); }  // always 'true'
});
},
onComplete: function () { console.log("scan done"); }
});
```
I don't have the contents of src/mobile-pentesting/android-app-pentesting/flutter.md. Please paste the markdown you want translated (or upload the file), and I will translate it to Portuguese following your rules.
```bash
frida -U -f com.example.app -l bypass.js
```
*Dicas de portabilidade*
* Para **arm64-v8a** ou **armv7**, pegue os primeiros ~32 bytes da função no Ghidra, converta para uma string hex separada por espaços, e substitua `sig`.
* Mantenha **um padrão por release do Flutter**, armazene-os em um cheat-sheet para reutilização rápida.

### Forçando o tráfego através do seu proxy
O Flutter em si **ignora as configurações de proxy do dispositivo**. Opções mais fáceis:
* **Android Studio emulator:** Configurações ▶ Proxy → manual.
* **Dispositivo físico:** evil Wi-Fi AP + DNS spoofing, ou módulo Magisk editando `/etc/hosts`.

### Hook baseado em offset da verificação do BoringSSL (sem signature scan)
Quando scripts baseados em pattern falham entre arquiteturas (ex.: x86_64 vs ARM), faça hook diretamente no verificador de chain do BoringSSL pelo endereço absoluto dentro de libflutter.so. Workflow:

- Extraia a biblioteca com o ABI correto do APK: `unzip -j app.apk "lib/*/libflutter.so" -d libs/` e escolha a que corresponde ao dispositivo (ex.: `lib/x86_64/libflutter.so`).
- Analise no Ghidra/IDA e localize o verificador:
- Origem: BoringSSL ssl_x509.cc function `ssl_crypto_x509_session_verify_cert_chain` (3 args, returns bool).
- Em builds sem símbolos (stripped), procure pela string `"ssl_client"` e inspecione XREFs; identifique a função que recebe três args tipo ponteiro e retorna um booleano.
- Calcule o offset em tempo de execução: pegue o endereço da função mostrado pelo Ghidra e subtraia a image base usada durante a análise para obter o offset relativo (RVA). Exemplo: `0x02184644 - 0x00100000 = 0x02084644`.
- Faça hook em tempo de execução usando base + offset e force o sucesso:
```javascript
// frida -U -f com.target.app -l bypass.js --no-pause
const base = Module.findBaseAddress('libflutter.so');
// Example offset from analysis. Recompute per build/arch.
const off  = ptr('0x02084644');
const addr = base.add(off);

// ssl_crypto_x509_session_verify_cert_chain: 3 args, bool return
Interceptor.replace(addr, new NativeCallback(function (a, b, c) {
return 1; // true
}, 'int', ['pointer', 'pointer', 'pointer']));

console.log('[+] Hooked BoringSSL verify_cert_chain at', addr);
```
Notas
- Recalcule o offset para cada target build e arquitetura de CPU; diferenças de compiler/codegen quebram hardcoded signatures.
- Este bypass faz com que BoringSSL aceite qualquer chain, permitindo HTTPS MITM independentemente dos pins/CA trust dentro do Flutter.
- Se você force-route o tráfego durante o debugging para confirmar o bloqueio TLS, e.g.:
```bash
iptables -t nat -A OUTPUT -p tcp -j DNAT --to-destination <Burp_IP>:<Burp_Port>
```
…você ainda precisará do hook acima, pois a verificação ocorre dentro de libflutter.so, e não no repositório de certificados do sistema Android.

## Referências
- [https://sensepost.com/blog/2025/intercepting-https-communication-in-flutter-going-full-hardcore-mode-with-frida/](https://sensepost.com/blog/2025/intercepting-https-communication-in-flutter-going-full-hardcore-mode-with-frida/)
- [Flutter SSL Bypass: How to Intercept HTTPS Traffic When all other Frida Scripts Fail](https://m4kr0x.medium.com/flutter-tls-bypass-how-to-intercept-https-traffic-when-all-other-frida-scripts-fail-bd3d04489088)
- [BoringSSL ssl_x509.cc (ssl_crypto_x509_session_verify_cert_chain)](https://github.com/google/boringssl/blob/main/ssl/ssl_x509.cc#L238)


{{#include ../../banners/hacktricks-training.md}}
