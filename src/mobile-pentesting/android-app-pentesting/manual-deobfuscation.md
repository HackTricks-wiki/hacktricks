# Techniques manuelles de De-obfuscation

{{#include ../../banners/hacktricks-training.md}}

## Techniques **manuelles de De-obfuscation**

Dans le domaine de la **software security**, le processus consistant à rendre un code obscur lisible, connu sous le nom de **de-obfuscation**, est crucial. Ce guide explore diverses stratégies de de-obfuscation, en se concentrant sur les techniques d'analyse statique et la reconnaissance des obfuscation patterns. Il introduit également un exercice pour la mise en pratique et propose des ressources pour ceux qui souhaitent approfondir des sujets plus avancés.

### **Stratégies pour la de-obfuscation statique**

Lorsque vous êtes confronté à du **obfuscated code**, plusieurs stratégies peuvent être employées selon la nature de l'obfuscation :

- **DEX bytecode (Java)** : Une approche efficace consiste à identifier les méthodes de de-obfuscation de l'application, puis à reproduire ces méthodes dans un fichier Java. Ce fichier est exécuté pour inverser l'obfuscation sur les éléments ciblés.
- **Java and Native Code** : Une autre méthode est de traduire l'algorithme de de-obfuscation dans un langage de scripting comme Python. Cette stratégie souligne que l'objectif principal n'est pas de comprendre parfaitement l'algorithme, mais de l'exécuter efficacement.

### **Identifier l'obfuscation**

Reconnaître du code obfusqué est la première étape du processus de de-obfuscation. Les indicateurs clés incluent :

- L'**absence ou le brouillage des strings** en Java et Android, ce qui peut indiquer une string obfuscation.
- La **présence de fichiers binaires** dans le assets directory ou des appels à `DexClassLoader`, suggérant un unpacking de code et un chargement dynamique.
- L'utilisation de **native libraries** accompagnées de fonctions JNI non identifiables, indiquant une possible obfuscation des méthodes natives.

## **Analyse dynamique dans la De-obfuscation**

En exécutant le code dans un environnement contrôlé, l'analyse dynamique **permet d'observer le comportement du code obfusqué en temps réel**. Cette méthode est particulièrement efficace pour révéler le fonctionnement interne de patterns d'obfuscation complexes conçus pour masquer la véritable intention du code.

### **Applications de l'analyse dynamique**

- **Runtime Decryption** : De nombreuses techniques d'obfuscation consistent à chiffrer des strings ou des segments de code qui ne sont décryptés qu'à l'exécution. Grâce à l'analyse dynamique, ces éléments chiffrés peuvent être capturés au moment du décryptage, révélant leur forme réelle.
- **Identifying Obfuscation Techniques** : En surveillant le comportement de l'application, l'analyse dynamique peut aider à identifier des techniques d'obfuscation spécifiques utilisées, telles que code virtualization, packers, ou dynamic code generation.
- **Uncovering Hidden Functionality** : Le code obfusqué peut contenir des fonctionnalités cachées qui ne sont pas apparentes via l'analyse statique seule. L'analyse dynamique permet d'observer tous les chemins d'exécution, y compris ceux conditionnels, afin de dévoiler ces fonctionnalités cachées.

### Automated De-obfuscation with LLMs (Androidmeda)

Alors que les sections précédentes se concentrent sur des stratégies entièrement manuelles, en 2025 une nouvelle classe d'outils propulsés par des *Large-Language-Model (LLM)* a émergé, capable d'automatiser la plupart des tâches fastidieuses de renommage et de récupération du control-flow.
Un projet représentatif est **[Androidmeda](https://github.com/In3tinct/Androidmeda)** – une utilité Python qui prend des sources Java *decompiled* (par exemple produites par `jadx`) et renvoie une version grandement nettoyée, commentée et annotée pour la sécurité.

#### Fonctionnalités clés
* Renames meaningless identifiers générés par ProGuard / DexGuard / DashO / Allatori / … en noms *sémantiques*.
* Detects and restructures **control-flow flattening**, remplaçant des machines d'état opaques basées sur switch-case par des boucles normales / constructeurs if-else.
* Decrypts common **string encryption** patterns lorsque c'est possible.
* Injects **inline comments** qui expliquent le but des blocs complexes.
* Performs un *lightweight static security scan* et écrit les résultats dans `vuln_report.json` avec des niveaux de sévérité (informational → critical).

#### Installation
```bash
git clone https://github.com/In3tinct/Androidmeda
cd Androidmeda
pip3 install -r requirements.txt
```
#### Préparation des entrées
1. Décompilez l'APK cible avec `jadx` (ou tout autre décompilateur) et ne conservez que le répertoire *source* qui contient les fichiers `.java` :
```bash
jadx -d input_dir/ target.apk
```
2. (Optionnel) Réduisez `input_dir/` pour qu'il contienne uniquement les packages d'application que vous voulez analyser — cela accélère considérablement le traitement et réduit les coûts LLM.

#### Exemples d'utilisation

Fournisseur distant (Gemini-1.5-flash):
```bash
export OPENAI_API_KEY=<your_key>
python3 androidmeda.py \
--llm_provider google \
--llm_model gemini-1.5-flash \
--source_dir input_dir/ \
--output_dir out/ \
--save_code true
```
Hors ligne (local `ollama` backend avec `llama3.2`):
```bash
python3 androidmeda.py \
--llm_provider ollama \
--llm_model llama3.2 \
--source_dir input_dir/ \
--output_dir out/ \
--save_code true
```
#### Sortie
* `out/vuln_report.json` – tableau JSON avec `file`, `line`, `issue`, `severity`.
* A mirrored package tree with **fichiers `.java` désobfusqués** (only if `--save_code true`).

#### Conseils & troubleshooting
* **Skipped class** ⇒ généralement causé par une méthode non analysable ; isolez le package ou mettez à jour la regex du parser.
* **Slow run-time / high token usage** ⇒ point `--source_dir` to *specific* app packages instead of the entire decompile.
* Always *manually review* the vulnerability report – LLM hallucinations can lead to false positives / negatives.

#### Practical value – Crocodilus malware case study
Feeding a heavily obfuscated sample from the 2025 *Crocodilus* banking trojan through Androidmeda reduced analysis time from *hours* to *minutes*: the tool recovered call-graph semantics, revealed calls to accessibility APIs and hard-coded C2 URLs, and produced a concise report that could be imported into analysts’ dashboards.

---

### Targeted Dalvik string decryption with DaliVM

**DaliVM** est un émulateur Python de bytecode Dalvik conçu pour récupérer statiquement des valeurs disponibles uniquement à l'exécution (en particulier des chaînes décryptées) sans lancer Android. Il exécute une *méthode spécifique* à l'intérieur d'un APK en émulant les opcodes Dalvik et en simulant les API Android/Java.

**Flux de travail**
1. **Sélectionner la méthode cible** par signature Dalvik (`Lpkg/Class;->method(Args)Ret`). Exemples: `Lutil/Crypto;->decrypt(Ljava/lang/String;)Ljava/lang/String;`, `LMyClass;->compute(II)I`.
2. **Énumérer les sites d'appel** à travers **multi-DEX** (`classes*.dex`) et **reconstruire les arguments** via le traçage de flux de données en arrière, la recherche en avant, et l'exécution partielle si nécessaire.
3. **Émuler la méthode** à l'intérieur de la Dalvik VM (couvre 120+ opcodes across const/array/control/field/invoke, handles class init via `<clinit>`) et **collecter les valeurs de retour** (p.ex., chaînes décryptées).
4. **Contourner les dépendances d'exécution** en utilisant des mocks intégrés pour les API Android courantes (Context, PackageManager, Signature, reflection, system services) et des hooks pour la stdlib Java (String/StringBuilder/Integer/Math/Arrays/List/Iterator).
5. Si l'exécution bloque, **activez le traçage au niveau des opcodes** pour voir les changements de PC/registres et étendre les handlers d'opcodes.

**Utilisation CLI**
```bash
# Emulate a decryptor and dump all returns
python emulate.py app.apk "Lcom/example/Decryptor;->decrypt"

# Verbose, debug trace, and limit outputs
python emulate.py app.apk "Lcom/example/Decryptor;->decrypt" -v --debug --limit 10
```
Les sorties sont les valeurs de retour collectées par appel ; utiles pour l'extraction en masse de string/config lors de malware triage ou pour des apps fortement obfuscated.

## Références et lectures complémentaires

- [DaliVM: Python Dalvik emulator for static string decryption](https://github.com/fatalSec/DaliVM)
- [https://maddiestone.github.io/AndroidAppRE/obfuscation.html](https://maddiestone.github.io/AndroidAppRE/obfuscation.html)
- BlackHat USA 2018: “Unpacking the Packed Unpacker: Reverse Engineering an Android Anti-Analysis Library” [[video](https://www.youtube.com/watch?v=s0Tqi7fuOSU)]
- Cette présentation couvre le reverse engineering d'une des bibliothèques natives anti-analysis les plus complexes que j'ai vues utilisées par une application Android. Elle traite principalement d'obfuscation techniques dans le native code.
- REcon 2019: “The Path to the Payload: Android Edition” [[video](https://recon.cx/media-archive/2019/Session.005.Maddie_Stone.The_path_to_the_payload_Android_Edition-J3ZnNl2GYjEfa.mp4)]
- Cette présentation traite d'une série d'obfuscation techniques, uniquement en Java, qu'un Android botnet utilisait pour dissimuler son comportement.
- Deobfuscating Android Apps with Androidmeda (blog post) – [mobile-hacker.com](https://www.mobile-hacker.com/2025/07/22/deobfuscating-android-apps-with-androidmeda-a-smarter-way-to-read-obfuscated-code/)
- Androidmeda source code – [https://github.com/In3tinct/Androidmeda](https://github.com/In3tinct/Androidmeda)

{{#include ../../banners/hacktricks-training.md}}
