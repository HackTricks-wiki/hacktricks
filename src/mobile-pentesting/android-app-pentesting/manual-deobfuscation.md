# Tecniche manuali di deoffuscamento

{{#include ../../banners/hacktricks-training.md}}

## Tecniche manuali di **deoffuscamento**

Nel campo della **sicurezza del software**, il processo che rende il codice offuscato comprensibile, noto come **de-obfuscation**, è cruciale. Questa guida esplora varie strategie per il deoffuscamento, concentrandosi sulle tecniche di analisi statica e sul riconoscimento dei pattern di offuscamento. Inoltre introduce un esercizio di applicazione pratica e suggerisce risorse per chi vuole approfondire argomenti più avanzati.

### **Strategie per il deoffuscamento statico**

Quando si ha a che fare con codice offuscato, si possono impiegare diverse strategie a seconda della natura dell'offuscamento:

- **DEX bytecode (Java)**: Un approccio efficace consiste nell'identificare i metodi di de-obfuscation dell'applicazione, quindi replicare questi metodi in un file Java. Questo file viene eseguito per invertire l'offuscamento sugli elementi mirati.
- **Java and Native Code**: Un altro metodo è tradurre l'algoritmo di de-obfuscation in un linguaggio di scripting come Python. Questa strategia sottolinea che l'obiettivo principale non è comprendere perfettamente l'algoritmo, ma eseguirlo in modo efficace.

### **Identificazione dell'offuscamento**

Riconoscere il codice offuscato è il primo passo nel processo di deoffuscamento. Indicatori chiave includono:

- L'**assenza o l'alterazione delle strings** in Java e Android, che può suggerire string obfuscation.
- La **presenza di file binari** nella directory assets o chiamate a `DexClassLoader`, che indicano unpacking del codice e caricamento dinamico.
- L'uso di **native libraries** insieme a funzioni JNI non identificabili, indicando potenziali offuscamenti dei metodi nativi.

## **Analisi dinamica nel deoffuscamento**

Eseguendo il codice in un ambiente controllato, l'analisi dinamica **permette di osservare come il codice offuscato si comporta in tempo reale**. Questo metodo è particolarmente efficace nel rivelare il funzionamento interno di pattern di offuscamento complessi progettati per nascondere la reale intenzione del codice.

### **Applicazioni dell'analisi dinamica**

- **Runtime Decryption**: Molte tecniche di offuscamento prevedono la cifratura di strings o segmenti di codice che vengono decifrati solo a runtime. Attraverso l'analisi dinamica è possibile catturare questi elementi al momento della decifratura, rivelandone la forma reale.
- **Identifying Obfuscation Techniques**: Monitorando il comportamento dell'applicazione, l'analisi dinamica può aiutare a identificare specifiche tecniche di offuscamento in uso, come code virtualization, packers, o dynamic code generation.
- **Uncovering Hidden Functionality**: Il codice offuscato può contenere funzionalità nascoste non evidenti tramite sola analisi statica. L'analisi dinamica consente di osservare tutti i percorsi di esecuzione, inclusi quelli condizionali, per scoprire tali funzionalità nascoste.

### Automated De-obfuscation with LLMs (Androidmeda)

Mentre le sezioni precedenti si concentrano su strategie completamente manuali, nel 2025 è emersa una nuova classe di strumenti alimentati da *Large-Language-Model (LLM)* in grado di automatizzare gran parte del lavoro tedioso di rinominazione e recupero del controllo di flusso.
Un progetto rappresentativo è **[Androidmeda](https://github.com/In3tinct/Androidmeda)** – un'utility Python che prende sorgenti Java *decompilati* (es. prodotti da `jadx`) e restituisce una versione notevolmente ripulita, commentata e annotata per la sicurezza del codice.

#### Capacità principali
* Rinomina identificatori privi di significato generati da ProGuard / DexGuard / DashO / Allatori / … in nomi *semantici*.
* Rileva e ristruttura **control-flow flattening**, sostituendo macchine a stati opache basate su switch-case con loop normali / costrutti if-else.
* Decifra pattern comuni di **string encryption** quando possibile.
* Inserisce **inline comments** che spiegano lo scopo di blocchi complessi.
* Esegue una *lightweight static security scan* e scrive i risultati in `vuln_report.json` con livelli di gravità (informational → critical).

#### Installation
```bash
git clone https://github.com/In3tinct/Androidmeda
cd Androidmeda
pip3 install -r requirements.txt
```
#### Preparazione degli input
1. Decompila l'APK target con `jadx` (o qualsiasi altro decompilatore) e conserva solo la directory *source* che contiene i file `.java`:
```bash
jadx -d input_dir/ target.apk
```
2. (Opzionale) Riduci `input_dir/` in modo che contenga solo i pacchetti dell'applicazione che vuoi analizzare – questo accelera notevolmente l'elaborazione e riduce i costi LLM.

#### Esempi d'uso

Provider remoto (Gemini-1.5-flash):
```bash
export OPENAI_API_KEY=<your_key>
python3 androidmeda.py \
--llm_provider google \
--llm_model gemini-1.5-flash \
--source_dir input_dir/ \
--output_dir out/ \
--save_code true
```
Offline (backend locale `ollama` con llama3.2):
```bash
python3 androidmeda.py \
--llm_provider ollama \
--llm_model llama3.2 \
--source_dir input_dir/ \
--output_dir out/ \
--save_code true
```
#### Output
* `out/vuln_report.json` – array JSON con `file`, `line`, `issue`, `severity`.
* A mirrored package tree with **de-obfuscated `.java` files** (only if `--save_code true`).

#### Tips & troubleshooting
* **Skipped class** ⇒ di solito causato da un metodo non parsabile; isolare il package o aggiornare la regex del parser.
* **Slow run-time / high token usage** ⇒ puntare `--source_dir` a pacchetti app *specifici* invece dell'intero decompile.
* *Rivedere sempre* *manualmente* il report di vulnerabilità – le allucinazioni degli LLM possono portare a falsi positivi / negativi.

#### Practical value – Crocodilus malware case study
L'analisi di un campione pesantemente offuscato del trojan bancario 2025 *Crocodilus* tramite Androidmeda ha ridotto il tempo di analisi da *ore* a *minuti*: lo strumento ha recuperato la semantica del call-graph, ha rivelato chiamate alle accessibility APIs e URL C2 hard-coded, e ha prodotto un report conciso importabile nelle dashboard degli analisti.

---

### Targeted Dalvik string decryption with DaliVM

**DaliVM** è un emulatore Python di bytecode Dalvik mirato a recuperare staticamente valori disponibili solo a runtime (soprattutto stringhe decriptate) senza avviare Android. Esegue un metodo *specifico* all'interno di un APK emulando gli opcode Dalvik e simulando le Android/Java APIs.

**Workflow**
1. **Selezionare il metodo target** tramite firma Dalvik (`Lpkg/Class;->method(Args)Ret`). Esempi: `Lutil/Crypto;->decrypt(Ljava/lang/String;)Ljava/lang/String;`, `LMyClass;->compute(II)I`.
2. **Enumerare i call site** attraverso multi-DEX (`classes*.dex`) e ricostruire gli argomenti tramite tracciamento del data-flow a ritroso, lookup in avanti e esecuzione parziale quando necessario.
3. **Emulare il metodo** all'interno della Dalvik VM (supporta 120+ opcode tra const/array/control/field/invoke, gestisce l'inizializzazione della classe via `<clinit>`) e raccogliere i valori di ritorno (es. stringhe decriptate).
4. **Bypassare le dipendenze di runtime** usando mock integrati per API Android comuni (Context, PackageManager, Signature, reflection, system services) e hook per la stdlib Java (String/StringBuilder/Integer/Math/Arrays/List/Iterator).
5. Se l'esecuzione si blocca, abilitare il tracing a livello di opcode per vedere i cambiamenti di PC/register e estendere gli opcode handler.

**Uso CLI**
```bash
# Emulate a decryptor and dump all returns
python emulate.py app.apk "Lcom/example/Decryptor;->decrypt"

# Verbose, debug trace, and limit outputs
python emulate.py app.apk "Lcom/example/Decryptor;->decrypt" -v --debug --limit 10
```
Gli output sono i valori di ritorno raccolti per invocazione; utili per l'estrazione massiva di stringhe/config durante il triage di malware o in app pesantemente offuscate.

## Riferimenti e ulteriori letture

- [DaliVM: Python Dalvik emulator for static string decryption](https://github.com/fatalSec/DaliVM)
- [https://maddiestone.github.io/AndroidAppRE/obfuscation.html](https://maddiestone.github.io/AndroidAppRE/obfuscation.html)
- BlackHat USA 2018: “Unpacking the Packed Unpacker: Reverse Engineering an Android Anti-Analysis Library” [[video](https://www.youtube.com/watch?v=s0Tqi7fuOSU)]
- Questo talk tratta il reverse engineering di una delle librerie native anti-analysis più complesse che abbia visto utilizzare in un'app Android. Copre principalmente tecniche di offuscamento nel codice nativo.
- REcon 2019: “The Path to the Payload: Android Edition” [[video](https://recon.cx/media-archive/2019/Session.005.Maddie_Stone.The_path_to_the_payload_Android_Edition-J3ZnNl2GYjEfa.mp4)]
- Questo talk discute una serie di tecniche di offuscamento, esclusivamente in codice Java, che un botnet Android usava per nascondere il proprio comportamento.
- Deobfuscating Android Apps with Androidmeda (post del blog) – [mobile-hacker.com](https://www.mobile-hacker.com/2025/07/22/deobfuscating-android-apps-with-androidmeda-a-smarter-way-to-read-obfuscated-code/)
- Androidmeda source code – [https://github.com/In3tinct/Androidmeda](https://github.com/In3tinct/Androidmeda)

{{#include ../../banners/hacktricks-training.md}}
