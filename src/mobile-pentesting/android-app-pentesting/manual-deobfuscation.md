# Handmatige De-obfuscation Tegnieke

{{#include ../../banners/hacktricks-training.md}}

## Handmatige **De-obfuscation Tegnieke**

In die wêreld van **sagteware sekuriteit** is die proses om obscured kode verstaanbaar te maak, bekend as **de-obfuscation**, van kardinale belang. Hierdie gids verken verskeie strategieë vir de-obfuscation, met fokus op statiese analise tegnieke en die herkenning van obfuscation patrone. Daarbenewens word 'n oefening vir praktiese toepassing bekendgestel en verdere hulpbronne voorgestel vir diegene wat belangstel om meer gevorderde onderwerpe te verken.

### **Strategieë vir Statiese De-obfuscation**

Wanneer daar met **obfuscated kode** gewerk word, kan verskeie strategieë toegepas word, afhangende van die aard van die obfuscation:

- **DEX bytecode (Java)**: Een effektiewe benadering behels die identifisering van die toepassings de-obfuscation metodes, en dan die replisering van hierdie metodes in 'n Java-lêer. Hierdie lêer word uitgevoer om die obfuscation op die geteikende elemente om te keer.
- **Java en Native Kode**: 'n Ander metode is om die de-obfuscation algoritme in 'n skriptaal soos Python te vertaal. Hierdie strategie beklemtoon dat die primêre doel nie is om die algoritme ten volle te verstaan nie, maar om dit effektief uit te voer.

### **Identifisering van Obfuscation**

Die herkenning van obfuscated kode is die eerste stap in die de-obfuscation proses. Sleutel aanwysers sluit in:

- Die **afwesigheid of vermenging van strings** in Java en Android, wat kan dui op string obfuscation.
- Die **teenwoordigheid van binêre lêers** in die batesgids of oproepe na `DexClassLoader`, wat dui op kode unpacking en dinamiese laai.
- Die gebruik van **native biblioteke saam met onidentifiseerbare JNI funksies**, wat moontlike obfuscation van native metodes aandui.

## **Dinamiese Analise in De-obfuscation**

Deur die kode in 'n beheerde omgewing uit te voer, **laat dinamiese analise die waarneming van hoe die obfuscated kode in werklike tyd optree** toe. Hierdie metode is veral effektief om die innerlike werking van komplekse obfuscation patrone wat ontwerp is om die werklike bedoeling van die kode te verberg, te onthul.

### **Toepassings van Dinamiese Analise**

- **Runtime Decryption**: Baie obfuscation tegnieke behels die enkripsie van strings of kode segmente wat slegs tydens runtime gedekript word. Deur dinamiese analise kan hierdie geënkripteerde elemente op die oomblik van dekripsie vasgevang word, wat hul werklike vorm onthul.
- **Identifisering van Obfuscation Tegnieke**: Deur die toepassingsgedrag te monitor, kan dinamiese analise help om spesifieke obfuscation tegnieke te identifiseer wat gebruik word, soos kode virtualisering, packers, of dinamiese kode generasie.
- **Ontdek van Verborgen Funksionaliteit**: Obfuscated kode kan verborgen funksionaliteite bevat wat nie deur statiese analise alleen duidelik is nie. Dinamiese analise laat die waarneming van alle kodepaaie toe, insluitend dié wat voorwaardelik uitgevoer word, om sulke verborgen funksionaliteite te ontdek.

### Geoutomatiseerde De-obfuscation met LLMs (Androidmeda)

Terwyl die vorige afdelings fokus op volledig handmatige strategieë, het 'n nuwe klas van *Large-Language-Model (LLM) aangedrewe* gereedskap in 2025 ontstaan wat die meeste van die vervelige hernoemings- en kontrole-stroom herstelwerk kan outomatiseer.
Een verteenwoordigende projek is **[Androidmeda](https://github.com/In3tinct/Androidmeda)** – 'n Python-nuttigheid wat *decompiled* Java bronne (bv. geproduseer deur `jadx`) neem en 'n baie skoon, kommentaar en sekuriteit-geannoteerde weergawe van die kode teruggee.

#### Sleutel vermoëns
* Hernoem betekenislose identifiseerders wat deur ProGuard / DexGuard / DashO / Allatori / ... gegenereer is na *semantiese* name.
* Detecteer en herstruktureer **kontrole-stroom flattening**, wat ondoorgrondelike switch-case toestand masjiene vervang met normale lusse / if-else konstruksies.
* Dekripteer algemene **string enkripsie** patrone wanneer moontlik.
* Injecteer **inline kommentaar** wat die doel van komplekse blokke verduidelik.
* Voer 'n *liggewig statiese sekuriteit skandering* uit en skryf die bevindings na `vuln_report.json` met erns vlakke (informatief → krities).

#### Installasie
```bash
git clone https://github.com/In3tinct/Androidmeda
cd Androidmeda
pip3 install -r requirements.txt
```
#### Voorbereiding van die insette
1. Decompileer die teiken APK met `jadx` (of enige ander decompiler) en hou net die *source* gids wat die `.java` lêers bevat:
```bash
jadx -d input_dir/ target.apk
```
2. (Opsioneel) Snoei `input_dir/` sodat dit net die toepassingspakkette bevat wat jy wil analiseer – dit versnel die verwerking en LLM koste aansienlik.

#### Gebruik voorbeelde

Afgeleë verskaffer (Gemini-1.5-flash):
```bash
export OPENAI_API_KEY=<your_key>
python3 androidmeda.py \
--llm_provider google \
--llm_model gemini-1.5-flash \
--source_dir input_dir/ \
--output_dir out/ \
--save_code true
```
Offline (lokale `ollama` agtergrond met llama3.2):
```bash
python3 androidmeda.py \
--llm_provider ollama \
--llm_model llama3.2 \
--source_dir input_dir/ \
--output_dir out/ \
--save_code true
```
#### Uitset
* `out/vuln_report.json` – JSON-array met `file`, `line`, `issue`, `severity`.
* 'n Gekopieerde pakketboom met **de-obfuscated `.java`-lêers** (slegs as `--save_code true`).

#### Wenke & probleemoplossing
* **Oorgeslaan klas** ⇒ gewoonlik veroorsaak deur 'n onleesbare metode; isoleer die pakket of werk die parser regex op.
* **Langsame uitvoering / hoë token gebruik** ⇒ wys `--source_dir` na *spesifieke* app-pakkette in plaas van die hele dekompilering.
* Hersien altyd *handmatig* die kwesbaarheidverslag – LLM hallusinasies kan lei tot vals positiewe / negatiewe.

#### Praktiese waarde – Crocodilus malware gevalstudie
Die voer van 'n swaar obfuskeerbare monster van die 2025 *Crocodilus* banktrojaan deur Androidmeda het die ontledings tyd van *ure* na *minute* verminder: die hulpmiddel het oproep-grafiek semantiek herstel, oproepe na toeganklikheid API's en hard-gecodeerde C2 URL's onthul, en 'n bondige verslag geproduseer wat in ontleders se dashboards ingevoer kon word.

---

## Verwysings en Verdere Leeswerk

- [https://maddiestone.github.io/AndroidAppRE/obfuscation.html](https://maddiestone.github.io/AndroidAppRE/obfuscation.html)
- BlackHat USA 2018: “Unpacking the Packed Unpacker: Reverse Engineering an Android Anti-Analysis Library” [[video](https://www.youtube.com/watch?v=s0Tqi7fuOSU)]
- Hierdie praatjie bespreek die omgekeerde ingenieurswese van een van die mees komplekse anti-analise inheemse biblioteke wat ek gesien het wat deur 'n Android-toepassing gebruik word. Dit dek meestal obfuskerings tegnieke in inheemse kode.
- REcon 2019: “The Path to the Payload: Android Edition” [[video](https://recon.cx/media-archive/2019/Session.005.Maddie_Stone.The_path_to_the_payload_Android_Edition-J3ZnNl2GYjEfa.mp4)]
- Hierdie praatjie bespreek 'n reeks obfuskerings tegnieke, slegs in Java kode, wat 'n Android-botnet gebruik het om sy gedrag te verberg.
- Deobfuscating Android Apps with Androidmeda (blogpos) – [mobile-hacker.com](https://www.mobile-hacker.com/2025/07/22/deobfuscating-android-apps-with-androidmeda-a-smarter-way-to-read-obfuscated-code/)
- Androidmeda bronne kode – [https://github.com/In3tinct/Androidmeda](https://github.com/In3tinct/Androidmeda)

- [https://maddiestone.github.io/AndroidAppRE/obfuscation.html](https://maddiestone.github.io/AndroidAppRE/obfuscation.html)
- BlackHat USA 2018: “Unpacking the Packed Unpacker: Reverse Engineering an Android Anti-Analysis Library” \[[video](https://www.youtube.com/watch?v=s0Tqi7fuOSU)]
- Hierdie praatjie bespreek die omgekeerde ingenieurswese van een van die mees komplekse anti-analise inheemse biblioteke wat ek gesien het wat deur 'n Android-toepassing gebruik word. Dit dek meestal obfuskerings tegnieke in inheemse kode.
- REcon 2019: “The Path to the Payload: Android Edition” \[[video](https://recon.cx/media-archive/2019/Session.005.Maddie_Stone.The_path_to_the_payload_Android_Edition-J3ZnNl2GYjEfa.mp4)]
- Hierdie praatjie bespreek 'n reeks obfuskerings tegnieke, slegs in Java kode, wat 'n Android-botnet gebruik het om sy gedrag te verberg.

{{#include ../../banners/hacktricks-training.md}}
