# Manuelle Deobfuskationstechniken

{{#include ../../banners/hacktricks-training.md}}

## Manuelle **Deobfuskationstechniken**

Im Bereich der **Software-Sicherheit** ist der Prozess, obfuskierten Code verständlich zu machen, bekannt als **Deobfuskation**, von entscheidender Bedeutung. Dieser Leitfaden behandelt verschiedene Strategien zur Deobfuskation, wobei der Schwerpunkt auf statischen Analysetechniken und der Erkennung von Obfuskationsmustern liegt. Darüber hinaus wird eine Übung zur praktischen Anwendung vorgestellt und es werden weitere Ressourcen für Interessierte an fortgeschritteneren Themen vorgeschlagen.

### **Strategien zur statischen Deobfuskation**

Beim Umgang mit **obfuskiertem Code** können je nach Art der Obfuskation verschiedene Strategien angewendet werden:

- **DEX-Bytecode (Java)**: Ein effektiver Ansatz besteht darin, die Deobfuskationsmethoden der Anwendung zu identifizieren und diese Methoden dann in einer Java-Datei zu replizieren. Diese Datei wird ausgeführt, um die Obfuskation der Ziel-Elemente rückgängig zu machen.
- **Java und nativer Code**: Eine weitere Methode besteht darin, den Deobfuskationsalgorithmus in eine Skriptsprache wie Python zu übersetzen. Diese Strategie hebt hervor, dass das Hauptziel nicht darin besteht, den Algorithmus vollständig zu verstehen, sondern ihn effektiv auszuführen.

### **Erkennung von Obfuskation**

Die Erkennung von obfuskiertem Code ist der erste Schritt im Deobfuskationsprozess. Wichtige Indikatoren sind:

- Das **Fehlen oder die Verwirrung von Strings** in Java und Android, was auf String-Obfuskation hindeuten kann.
- Die **Präsenz von Binärdateien** im Assets-Verzeichnis oder Aufrufe an `DexClassLoader`, die auf das Entpacken von Code und dynamisches Laden hinweisen.
- Die Verwendung von **nativen Bibliotheken zusammen mit nicht identifizierbaren JNI-Funktionen**, was auf eine potenzielle Obfuskation nativer Methoden hinweist.

## **Dynamische Analyse in der Deobfuskation**

Durch die Ausführung des Codes in einer kontrollierten Umgebung ermöglicht die dynamische Analyse **die Beobachtung, wie sich der obfuskierten Code in Echtzeit verhält**. Diese Methode ist besonders effektiv, um die inneren Abläufe komplexer Obfuskationsmuster aufzudecken, die darauf ausgelegt sind, die wahre Absicht des Codes zu verbergen.

### **Anwendungen der dynamischen Analyse**

- **Laufzeit-Dekodierung**: Viele Obfuskationstechniken beinhalten die Verschlüsselung von Strings oder Codeabschnitten, die nur zur Laufzeit entschlüsselt werden. Durch dynamische Analyse können diese verschlüsselten Elemente zum Zeitpunkt der Dekodierung erfasst werden, wodurch ihre wahre Form sichtbar wird.
- **Identifizierung von Obfuskationstechniken**: Durch die Überwachung des Verhaltens der Anwendung kann die dynamische Analyse helfen, spezifische Obfuskationstechniken zu identifizieren, die verwendet werden, wie z.B. Code-Virtualisierung, Packager oder dynamische Code-Generierung.
- **Aufdeckung versteckter Funktionalitäten**: Obfuskierten Code kann versteckte Funktionalitäten enthalten, die durch statische Analyse allein nicht offensichtlich sind. Die dynamische Analyse ermöglicht die Beobachtung aller Codepfade, einschließlich der bedingt ausgeführten, um solche versteckten Funktionalitäten aufzudecken.

### Automatisierte Deobfuskation mit LLMs (Androidmeda)

Während die vorherigen Abschnitte sich auf vollständig manuelle Strategien konzentrieren, entstand 2025 eine neue Klasse von *Large-Language-Model (LLM) gestützten* Werkzeugen, die den Großteil der mühsamen Umbenennungs- und Kontrollflusswiederherstellungsarbeiten automatisieren können. 
Ein repräsentatives Projekt ist **[Androidmeda](https://github.com/In3tinct/Androidmeda)** – ein Python-Utility, das *dekompilierte* Java-Quellen (z.B. erzeugt von `jadx`) entgegennimmt und eine stark bereinigte, kommentierte und sicherheitsannotierte Version des Codes zurückgibt.

#### Hauptfähigkeiten
* Benennt bedeutungslose Bezeichner, die von ProGuard / DexGuard / DashO / Allatori / … generiert wurden, in *semantische* Namen um.
* Erkennt und restrukturiert **Kontrollfluss-Flatting**, indem undurchsichtige Switch-Case-Zustandsmaschinen durch normale Schleifen / If-Else-Konstrukte ersetzt werden.
* Entschlüsselt gängige **String-Verschlüsselungsmuster**, wenn möglich.
* Fügt **Inline-Kommentare** ein, die den Zweck komplexer Blöcke erklären.
* Führt einen *leichten statischen Sicherheits-Scan* durch und schreibt die Ergebnisse in `vuln_report.json` mit Schweregraden (informativ → kritisch).

#### Installation
```bash
git clone https://github.com/In3tinct/Androidmeda
cd Androidmeda
pip3 install -r requirements.txt
```
#### Eingaben vorbereiten
1. Decompile die Ziel-APK mit `jadx` (oder einem anderen Decompiler) und behalte nur das *source* Verzeichnis, das die `.java` Dateien enthält:
```bash
jadx -d input_dir/ target.apk
```
2. (Optional) Kürze `input_dir/`, sodass es nur die Anwendungs-Pakete enthält, die du analysieren möchtest – dies beschleunigt die Verarbeitung und senkt die LLM-Kosten erheblich.

#### Anwendungsbeispiele

Remote-Anbieter (Gemini-1.5-flash):
```bash
export OPENAI_API_KEY=<your_key>
python3 androidmeda.py \
--llm_provider google \
--llm_model gemini-1.5-flash \
--source_dir input_dir/ \
--output_dir out/ \
--save_code true
```
Offline (lokaler `ollama`-Backend mit llama3.2):
```bash
python3 androidmeda.py \
--llm_provider ollama \
--llm_model llama3.2 \
--source_dir input_dir/ \
--output_dir out/ \
--save_code true
```
#### Ausgabe
* `out/vuln_report.json` – JSON-Array mit `file`, `line`, `issue`, `severity`.
* Ein gespiegelt Paketbaum mit **de-obfuskierten `.java`-Dateien** (nur wenn `--save_code true`).

#### Tipps & Fehlersuche
* **Übersprungene Klasse** ⇒ normalerweise verursacht durch eine nicht analysierbare Methode; isolieren Sie das Paket oder aktualisieren Sie den Parser-RegEx.
* **Langsame Laufzeit / hoher Tokenverbrauch** ⇒ zeigen Sie `--source_dir` auf *spezifische* App-Pakete anstelle des gesamten Decompiles.
* Überprüfen Sie immer *manuell* den Sicherheitsbericht – LLM-Halluzinationen können zu falsch positiven / negativen Ergebnissen führen.

#### Praktischer Wert – Crocodilus-Malware-Fallstudie
Das Füttern einer stark obfuskierten Probe des 2025 *Crocodilus* Banking-Trojaners durch Androidmeda reduzierte die Analysezeit von *Stunden* auf *Minuten*: Das Tool stellte die Semantik des Aufrufgraphen wieder her, enthüllte Aufrufe an Accessibility-APIs und hartkodierte C2-URLs und erzeugte einen prägnanten Bericht, der in die Dashboards der Analysten importiert werden konnte.

---

## Referenzen und Weiterführende Literatur

- [https://maddiestone.github.io/AndroidAppRE/obfuscation.html](https://maddiestone.github.io/AndroidAppRE/obfuscation.html)
- BlackHat USA 2018: “Unpacking the Packed Unpacker: Reverse Engineering an Android Anti-Analysis Library” [[video](https://www.youtube.com/watch?v=s0Tqi7fuOSU)]
- Dieser Vortrag behandelt das Reverse Engineering einer der komplexesten Anti-Analyse-Bibliotheken, die ich bei einer Android-Anwendung gesehen habe. Es werden hauptsächlich Obfuskationstechniken im nativen Code behandelt.
- REcon 2019: “The Path to the Payload: Android Edition” [[video](https://recon.cx/media-archive/2019/Session.005.Maddie_Stone.The_path_to_the_payload_Android_Edition-J3ZnNl2GYjEfa.mp4)]
- Dieser Vortrag diskutiert eine Reihe von Obfuskationstechniken, die ausschließlich im Java-Code verwendet wurden, um das Verhalten eines Android-Botnets zu verbergen.
- Deobfuscating Android Apps with Androidmeda (Blogbeitrag) – [mobile-hacker.com](https://www.mobile-hacker.com/2025/07/22/deobfuscating-android-apps-with-androidmeda-a-smarter-way-to-read-obfuscated-code/)
- Androidmeda Quellcode – [https://github.com/In3tinct/Androidmeda](https://github.com/In3tinct/Androidmeda)

- [https://maddiestone.github.io/AndroidAppRE/obfuscation.html](https://maddiestone.github.io/AndroidAppRE/obfuscation.html)
- BlackHat USA 2018: “Unpacking the Packed Unpacker: Reverse Engineering an Android Anti-Analysis Library” \[[video](https://www.youtube.com/watch?v=s0Tqi7fuOSU)]
- Dieser Vortrag behandelt das Reverse Engineering einer der komplexesten Anti-Analyse-Bibliotheken, die ich bei einer Android-Anwendung gesehen habe. Es werden hauptsächlich Obfuskationstechniken im nativen Code behandelt.
- REcon 2019: “The Path to the Payload: Android Edition” \[[video](https://recon.cx/media-archive/2019/Session.005.Maddie_Stone.The_path_to_the_payload_Android_Edition-J3ZnNl2GYjEfa.mp4)]
- Dieser Vortrag diskutiert eine Reihe von Obfuskationstechniken, die ausschließlich im Java-Code verwendet wurden, um das Verhalten eines Android-Botnets zu verbergen.

{{#include ../../banners/hacktricks-training.md}}
