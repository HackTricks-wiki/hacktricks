# Техніки ручної деобфускації

{{#include ../../banners/hacktricks-training.md}}

## Ручні **Техніки деобфускації**

У сфері **безпеки програмного забезпечення** процес перетворення зашифрованого коду в зрозумілий, відомий як **деобфускація**, є критично важливим. Цей посібник розглядає різні стратегії деобфускації, зосереджуючи увагу на техніках статичного аналізу та розпізнаванні патернів обфускації. Крім того, він пропонує вправу для практичного застосування та рекомендує додаткові ресурси для тих, хто зацікавлений у вивченні більш складних тем.

### **Стратегії статичної деобфускації**

При роботі з **обфускованим кодом** можна використовувати кілька стратегій залежно від природи обфускації:

- **DEX байт-код (Java)**: Один із ефективних підходів полягає в ідентифікації методів деобфускації програми, а потім у відтворенні цих методів у Java-файлі. Цей файл виконується для скасування обфускації на цільових елементах.
- **Java та рідний код**: Інший метод полягає в перекладі алгоритму деобфускації на мову сценаріїв, таку як Python. Ця стратегія підкреслює, що основна мета полягає не в повному розумінні алгоритму, а в його ефективному виконанні.

### **Ідентифікація обфускації**

Визнання обфускованого коду є першим кроком у процесі деобфускації. Ключові ознаки включають:

- **відсутність або сплутування рядків** у Java та Android, що може свідчити про обфускацію рядків.
- **наявність бінарних файлів** у каталозі ресурсів або викликів до `DexClassLoader`, що натякає на розпакування коду та динамічне завантаження.
- Використання **рідних бібліотек разом з невизначеними функціями JNI**, що вказує на потенційну обфускацію рідних методів.

## **Динамічний аналіз у деобфускації**

Виконуючи код у контрольованому середовищі, динамічний аналіз **дозволяє спостерігати, як обфускований код поводиться в реальному часі**. Цей метод особливо ефективний для виявлення внутрішніх механізмів складних патернів обфускації, які призначені для приховування справжнього наміру коду.

### **Застосування динамічного аналізу**

- **Дешифрування в режимі виконання**: Багато технік обфускації передбачають шифрування рядків або сегментів коду, які дешифруються лише під час виконання. Завдяки динамічному аналізу ці зашифровані елементи можуть бути захоплені в момент дешифрування, розкриваючи їх справжню форму.
- **Ідентифікація технік обфускації**: Спостерігаючи за поведінкою програми, динамічний аналіз може допомогти виявити конкретні техніки обфускації, що використовуються, такі як віртуалізація коду, пакувальники або динамічна генерація коду.
- **Виявлення прихованої функціональності**: Обфускований код може містити приховані функціональні можливості, які не є очевидними лише через статичний аналіз. Динамічний аналіз дозволяє спостерігати всі шляхи коду, включаючи ті, що виконуються умовно, щоб виявити такі приховані функціональності.

### Автоматизована деобфускація з LLM (Androidmeda)

Хоча попередні розділи зосереджені на повністю ручних стратегіях, у 2025 році з'явився новий клас інструментів, що працюють на основі *моделей великої мови (LLM)*, які можуть автоматизувати більшість нудної роботи з перейменування та відновлення контролю потоку.
Одним із представницьких проектів є **[Androidmeda](https://github.com/In3tinct/Androidmeda)** – утиліта на Python, яка приймає *декомпільовані* Java-джерела (наприклад, створені за допомогою `jadx`) і повертає значно очищену, прокоментовану та анотовану з точки зору безпеки версію коду.

#### Ключові можливості
* Перейменовує безглузді ідентифікатори, згенеровані ProGuard / DexGuard / DashO / Allatori / … на *семантичні* назви.
* Виявляє та реорганізовує **плоску структуру контролю потоку**, замінюючи непрозорі машини станів switch-case на звичайні цикли / конструкції if-else.
* Дешифрує загальні **патерни шифрування рядків**, коли це можливо.
* Вставляє **вбудовані коментарі**, які пояснюють призначення складних блоків.
* Виконує *легкий статичний сканування безпеки* і записує результати в `vuln_report.json` з рівнями серйозності (інформаційний → критичний).

#### Встановлення
```bash
git clone https://github.com/In3tinct/Androidmeda
cd Androidmeda
pip3 install -r requirements.txt
```
#### Підготовка вхідних даних
1. Декодуйте цільовий APK за допомогою `jadx` (або будь-якого іншого декомпілера) і залиште лише директорію *source*, яка містить файли `.java`:
```bash
jadx -d input_dir/ target.apk
```
2. (Необов'язково) Обріжте `input_dir/`, щоб вона містила лише пакети додатків, які ви хочете аналізувати – це значно прискорює обробку та знижує витрати на LLM.

#### Приклади використання

Віддалений провайдер (Gemini-1.5-flash):
```bash
export OPENAI_API_KEY=<your_key>
python3 androidmeda.py \
--llm_provider google \
--llm_model gemini-1.5-flash \
--source_dir input_dir/ \
--output_dir out/ \
--save_code true
```
Офлайн (локальний `ollama` бекенд з llama3.2):
```bash
python3 androidmeda.py \
--llm_provider ollama \
--llm_model llama3.2 \
--source_dir input_dir/ \
--output_dir out/ \
--save_code true
```
#### Вихід
* `out/vuln_report.json` – JSON масив з `file`, `line`, `issue`, `severity`.
* Віддзеркалене дерево пакетів з **деобфусованими `.java` файлами** (тільки якщо `--save_code true`).

#### Поради та усунення неполадок
* **Пропущений клас** ⇒ зазвичай викликаний непарсованим методом; ізолюйте пакет або оновіть регулярний вираз парсера.
* **Повільний час виконання / високе використання токенів** ⇒ вкажіть `--source_dir` на *конкретні* пакети додатків замість всього декомпільованого коду.
* Завжди *вручну перевіряйте* звіт про вразливості – галюцинації LLM можуть призвести до хибнопозитивних / хибнонегативних результатів.

#### Практична цінність – Кейс дослідження шкідливого ПЗ Crocodilus
Обробка сильно обфускованого зразка з банківського троянця *Crocodilus* 2025 року через Androidmeda зменшила час аналізу з *годин* до *хвилин*: інструмент відновив семантику графа викликів, виявив виклики до API доступності та жорстко закодовані C2 URL, а також створив стиснутий звіт, який можна імпортувати в інформаційні панелі аналітиків.

---

## Посилання та подальше читання

- [https://maddiestone.github.io/AndroidAppRE/obfuscation.html](https://maddiestone.github.io/AndroidAppRE/obfuscation.html)
- BlackHat USA 2018: “Unpacking the Packed Unpacker: Reverse Engineering an Android Anti-Analysis Library” [[video](https://www.youtube.com/watch?v=s0Tqi7fuOSU)]
- Ця доповідь охоплює реверс-інжиніринг однієї з найскладніших антианалізаторських рідних бібліотек, які я бачив, що використовуються Android-додатком. Вона в основному охоплює техніки обфускації в рідному коді.
- REcon 2019: “The Path to the Payload: Android Edition” [[video](https://recon.cx/media-archive/2019/Session.005.Maddie_Stone.The_path_to_the_payload_Android_Edition-J3ZnNl2GYjEfa.mp4)]
- Ця доповідь обговорює серію технік обфускації, виключно в Java-коді, які використовувала Android-ботнет для приховування своєї поведінки.
- Деобфускація Android-додатків з Androidmeda (блог) – [mobile-hacker.com](https://www.mobile-hacker.com/2025/07/22/deobfuscating-android-apps-with-androidmeda-a-smarter-way-to-read-obfuscated-code/)
- Код Androidmeda – [https://github.com/In3tinct/Androidmeda](https://github.com/In3tinct/Androidmeda)

- [https://maddiestone.github.io/AndroidAppRE/obfuscation.html](https://maddiestone.github.io/AndroidAppRE/obfuscation.html)
- BlackHat USA 2018: “Unpacking the Packed Unpacker: Reverse Engineering an Android Anti-Analysis Library” \[[video](https://www.youtube.com/watch?v=s0Tqi7fuOSU)]
- Ця доповідь охоплює реверс-інжиніринг однієї з найскладніших антианалізаторських рідних бібліотек, які я бачив, що використовуються Android-додатком. Вона в основному охоплює техніки обфускації в рідному коді.
- REcon 2019: “The Path to the Payload: Android Edition” \[[video](https://recon.cx/media-archive/2019/Session.005.Maddie_Stone.The_path_to_the_payload_Android_Edition-J3ZnNl2GYjEfa.mp4)]
- Ця доповідь обговорює серію технік обфускації, виключно в Java-коді, які використовувала Android-ботнет для приховування своєї поведінки.

{{#include ../../banners/hacktricks-training.md}}
