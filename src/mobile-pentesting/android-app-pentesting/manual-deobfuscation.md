# マニュアルデオブファスケーション技術

{{#include ../../banners/hacktricks-training.md}}

## マニュアル **デオブファスケーション技術**

**ソフトウェアセキュリティ**の領域において、隠されたコードを理解可能にするプロセス、すなわち**デオブファスケーション**は重要です。このガイドでは、静的分析技術とオブファスケーションパターンの認識に焦点を当て、デオブファスケーションのさまざまな戦略を掘り下げます。さらに、実践的な応用のための演習を紹介し、より高度なトピックを探求したい人のための追加リソースを提案します。

### **静的デオブファスケーションの戦略**

**オブファスケートされたコード**を扱う際には、オブファスケーションの性質に応じていくつかの戦略を採用できます：

- **DEXバイトコード（Java）**: 効果的なアプローチの一つは、アプリケーションのデオブファスケーションメソッドを特定し、これらのメソッドをJavaファイルに複製することです。このファイルを実行して、ターゲット要素のオブファスケーションを逆転させます。
- **Javaおよびネイティブコード**: 別の方法は、デオブファスケーションアルゴリズムをPythonのようなスクリプト言語に翻訳することです。この戦略は、主な目標はアルゴリズムを完全に理解することではなく、効果的に実行することにあることを強調しています。

### **オブファスケーションの特定**

オブファスケートされたコードを認識することは、デオブファスケーションプロセスの最初のステップです。主な指標には以下が含まれます：

- JavaおよびAndroidにおける**文字列の欠如または混乱**は、文字列オブファスケーションを示唆する可能性があります。
- **バイナリファイルの存在**がアセットディレクトリにあるか、`DexClassLoader`への呼び出しが、コードのアンパックや動的読み込みを示唆します。
- **識別できないJNI関数と共に使用されるネイティブライブラリ**は、ネイティブメソッドのオブファスケーションの可能性を示しています。

## **デオブファスケーションにおける動的分析**

制御された環境でコードを実行することにより、動的分析は**オブファスケートされたコードがリアルタイムでどのように動作するかを観察することを可能にします**。この方法は、コードの真の意図を隠すために設計された複雑なオブファスケーションパターンの内部動作を明らかにするのに特に効果的です。

### **動的分析の応用**

- **ランタイム復号**: 多くのオブファスケーション技術は、ランタイムでのみ復号される文字列やコードセグメントを暗号化します。動的分析を通じて、これらの暗号化された要素は復号の瞬間にキャプチャされ、その真の形が明らかになります。
- **オブファスケーション技術の特定**: アプリケーションの動作を監視することで、動的分析は使用されている特定のオブファスケーション技術（コードの仮想化、パッカー、動的コード生成など）を特定するのに役立ちます。
- **隠れた機能の発見**: オブファスケートされたコードには、静的分析だけでは明らかでない隠れた機能が含まれている場合があります。動的分析は、条件付きで実行されるコードパスを含むすべてのコードパスを観察することで、そのような隠れた機能を明らかにします。

### LLMを用いた自動デオブファスケーション（Androidmeda）

前のセクションでは完全に手動の戦略に焦点を当てましたが、2025年には*大規模言語モデル（LLM）を活用した*ツールの新しいクラスが登場し、ほとんどの面倒な名前変更や制御フロー回復作業を自動化できるようになりました。
代表的なプロジェクトは**[Androidmeda](https://github.com/In3tinct/Androidmeda)**で、これは*デコンパイルされた*Javaソース（例：`jadx`によって生成された）を受け取り、コードの大幅にクリーンアップされた、コメント付きでセキュリティ注釈が付けられたバージョンを返すPythonユーティリティです。

#### 主な機能
* ProGuard / DexGuard / DashO / Allatori / …によって生成された意味のない識別子を*セマンティック*な名前に変更します。
* **制御フローのフラット化**を検出し、オペークなswitch-case状態機械を通常のループ/ if-else構造に置き換えます。
* 可能な場合、一般的な**文字列暗号化**パターンを復号します。
* 複雑なブロックの目的を説明する**インラインコメント**を挿入します。
* *軽量な静的セキュリティスキャン*を実行し、結果を`vuln_report.json`に深刻度レベル（情報 → 重大）で記録します。

#### インストール
```bash
git clone https://github.com/In3tinct/Androidmeda
cd Androidmeda
pip3 install -r requirements.txt
```
#### 入力の準備
1. `jadx`（または他のデコンパイラ）を使用してターゲットAPKをデコンパイルし、`.java`ファイルを含む*source*ディレクトリのみを保持します:
```bash
jadx -d input_dir/ target.apk
```
2. （オプション）`input_dir/`をトリミングして、分析したいアプリケーションパッケージのみを含むようにします。これにより、処理速度が大幅に向上し、LLMコストが削減されます。

#### 使用例

リモートプロバイダー（Gemini-1.5-flash）：
```bash
export OPENAI_API_KEY=<your_key>
python3 androidmeda.py \
--llm_provider google \
--llm_model gemini-1.5-flash \
--source_dir input_dir/ \
--output_dir out/ \
--save_code true
```
オフライン（ローカル `ollama` バックエンドを使用した llama3.2）：
```bash
python3 androidmeda.py \
--llm_provider ollama \
--llm_model llama3.2 \
--source_dir input_dir/ \
--output_dir out/ \
--save_code true
```
#### 出力
* `out/vuln_report.json` – `file`、`line`、`issue`、`severity`を含むJSON配列。
* **デオブフスケートされた`.java`ファイル**のミラーリングされたパッケージツリー（`--save_code true`の場合のみ）。

#### ヒントとトラブルシューティング
* **スキップされたクラス** ⇒ 通常は解析不可能なメソッドが原因; パッケージを隔離するか、パーサーの正規表現を更新する。
* **遅い実行時間 / 高いトークン使用量** ⇒ `--source_dir`を*特定の*アプリパッケージにポイントする、全体のデコンパイルではなく。
* 脆弱性レポートは常に*手動でレビュー*すること – LLMの幻覚は偽陽性/偽陰性を引き起こす可能性がある。

#### 実用的な価値 – Crocodilusマルウェアのケーススタディ
2025年の*Crocodilus*バンキングトロイの木馬からの重度にオブフスケートされたサンプルをAndroidmedaに通すことで、分析時間が*数時間*から*数分*に短縮されました：このツールはコールグラフのセマンティクスを回復し、アクセシビリティAPIへの呼び出しやハードコーディングされたC2 URLを明らかにし、アナリストのダッシュボードにインポートできる簡潔なレポートを生成しました。

---

## 参考文献とさらなる読み物

- [https://maddiestone.github.io/AndroidAppRE/obfuscation.html](https://maddiestone.github.io/AndroidAppRE/obfuscation.html)
- BlackHat USA 2018: “Unpacking the Packed Unpacker: Reverse Engineering an Android Anti-Analysis Library” [[video](https://www.youtube.com/watch?v=s0Tqi7fuOSU)]
- このトークでは、Androidアプリケーションで使用されている最も複雑なアンチ分析ネイティブライブラリの1つのリバースエンジニアリングについて説明します。主にネイティブコードのオブフスケーション技術をカバーしています。
- REcon 2019: “The Path to the Payload: Android Edition” [[video](https://recon.cx/media-archive/2019/Session.005.Maddie_Stone.The_path_to_the_payload_Android_Edition-J3ZnNl2GYjEfa.mp4)]
- このトークでは、Androidボットネットがその動作を隠すために使用していたJavaコード内の一連のオブフスケーション技術について説明します。
- Androidmedaを使用したAndroidアプリのデオブフスケーション（ブログ投稿） – [mobile-hacker.com](https://www.mobile-hacker.com/2025/07/22/deobfuscating-android-apps-with-androidmeda-a-smarter-way-to-read-obfuscated-code/)
- Androidmedaのソースコード – [https://github.com/In3tinct/Androidmeda](https://github.com/In3tinct/Androidmeda)

- [https://maddiestone.github.io/AndroidAppRE/obfuscation.html](https://maddiestone.github.io/AndroidAppRE/obfuscation.html)
- BlackHat USA 2018: “Unpacking the Packed Unpacker: Reverse Engineering an Android Anti-Analysis Library” \[[video](https://www.youtube.com/watch?v=s0Tqi7fuOSU)]
- このトークでは、Androidアプリケーションで使用されている最も複雑なアンチ分析ネイティブライブラリの1つのリバースエンジニアリングについて説明します。主にネイティブコードのオブフスケーション技術をカバーしています。
- REcon 2019: “The Path to the Payload: Android Edition” \[[video](https://recon.cx/media-archive/2019/Session.005.Maddie_Stone.The_path_to_the_payload_Android_Edition-J3ZnNl2GYjEfa.mp4)]
- このトークでは、Androidボットネットがその動作を隠すために使用していたJavaコード内の一連のオブフスケーション技術について説明します。

{{#include ../../banners/hacktricks-training.md}}
