# Manuel De-obfuscation Teknikleri

{{#include ../../banners/hacktricks-training.md}}

## Manuel **De-obfuscation Teknikleri**

**Yazılım güvenliği** alanında, gizli kodu anlaşılır hale getirme süreci olan **de-obfuscation**, kritik öneme sahiptir. Bu kılavuz, statik analiz tekniklerine ve obfuscation desenlerini tanımaya odaklanarak, de-obfuscation için çeşitli stratejileri incelemektedir. Ayrıca, pratik uygulama için bir alıştırma sunmakta ve daha ileri konuları keşfetmek isteyenler için ek kaynaklar önermektedir.

### **Statik De-obfuscation için Stratejiler**

**Obfuscated code** ile uğraşırken, obfuscation'ın doğasına bağlı olarak birkaç strateji uygulanabilir:

- **DEX bytecode (Java)**: Etkili bir yaklaşım, uygulamanın de-obfuscation yöntemlerini tanımlamak ve ardından bu yöntemleri bir Java dosyasında çoğaltmaktır. Bu dosya, hedeflenen unsurlar üzerindeki obfuscation'ı tersine çevirmek için çalıştırılır.
- **Java ve Native Code**: Diğer bir yöntem, de-obfuscation algoritmasını Python gibi bir betik diline çevirmektir. Bu strateji, temel amacın algoritmayı tamamen anlamak değil, etkili bir şekilde çalıştırmak olduğunu vurgular.

### **Obfuscation'ı Tanımlama**

Obfuscated code'u tanımak, de-obfuscation sürecindeki ilk adımdır. Anahtar göstergeler şunlardır:

- Java ve Android'deki **string'lerin yokluğu veya karıştırılması**, string obfuscation'ı önerebilir.
- **Binary dosyaların** varlığı, varlıklar dizininde veya `DexClassLoader` çağrıları, kodun açılması ve dinamik yüklenmesi hakkında ipuçları verebilir.
- **Tanımlanamayan JNI fonksiyonlarıyla birlikte native kütüphanelerin** kullanımı, native yöntemlerin potansiyel obfuscation'ını gösterebilir.

## **De-obfuscation'da Dinamik Analiz**

Kodun kontrol edilen bir ortamda çalıştırılması, dinamik analiz **obfuscated code'un gerçek zamanlı olarak nasıl davrandığını gözlemlemeyi sağlar**. Bu yöntem, kodun gerçek amacını gizlemek için tasarlanmış karmaşık obfuscation desenlerinin iç işleyişini ortaya çıkarmada özellikle etkilidir.

### **Dinamik Analizin Uygulamaları**

- **Runtime Decryption**: Birçok obfuscation tekniği, yalnızca çalışma zamanında çözülen string'leri veya kod parçalarını şifrelemeyi içerir. Dinamik analiz sayesinde, bu şifreli unsurların şifre çözme anında yakalanması, gerçek hallerini ortaya çıkarır.
- **Obfuscation Tekniklerini Tanımlama**: Uygulamanın davranışını izleyerek, dinamik analiz belirli obfuscation tekniklerini tanımlamaya yardımcı olabilir; örneğin, kod sanallaştırma, packer'lar veya dinamik kod üretimi.
- **Gizli Fonksiyonelliği Ortaya Çıkarma**: Obfuscated code, yalnızca statik analizle belirgin olmayan gizli işlevsellikler içerebilir. Dinamik analiz, koşullu olarak yürütülenler de dahil olmak üzere tüm kod yollarını gözlemleyerek bu tür gizli işlevsellikleri ortaya çıkarır.

### LLM'lerle Otomatik De-obfuscation (Androidmeda)

Önceki bölümler tamamen manuel stratejilere odaklanırken, 2025'te çoğu sıkıcı yeniden adlandırma ve kontrol akışı kurtarma işini otomatikleştirebilen yeni bir *Büyük Dil Modeli (LLM) destekli* araç sınıfı ortaya çıktı. Temsilci bir proje **[Androidmeda](https://github.com/In3tinct/Androidmeda)** – `jadx` tarafından üretilen *decompiled* Java kaynaklarını alıp, kodun büyük ölçüde temizlenmiş, yorumlanmış ve güvenlik notları eklenmiş bir versiyonunu döndüren bir Python aracıdır.

#### Anahtar yetenekler
* ProGuard / DexGuard / DashO / Allatori / … tarafından üretilen anlamsız tanımlayıcıları *anlamlı* isimlere yeniden adlandırır.
* **Control-flow flattening**'i tespit eder ve yeniden yapılandırır, opak switch-case durum makinelerini normal döngüler / if-else yapılarıyla değiştirir.
* Mümkün olduğunda yaygın **string encryption** desenlerini çözer.
* Karmaşık blokların amacını açıklayan **inline comments** ekler.
* *Hafif bir statik güvenlik taraması* gerçekleştirir ve bulguları `vuln_report.json` dosyasına ciddiyet seviyeleriyle (bilgilendirici → kritik) yazar.

#### Kurulum
```bash
git clone https://github.com/In3tinct/Androidmeda
cd Androidmeda
pip3 install -r requirements.txt
```
#### Girdileri Hazırlama
1. Hedef APK'yı `jadx` (veya başka bir decompiler) ile decompile edin ve yalnızca `.java` dosyalarını içeren *source* dizinini saklayın:
```bash
jadx -d input_dir/ target.apk
```
2. (İsteğe bağlı) `input_dir/`'yi, analiz etmek istediğiniz uygulama paketlerini içerecek şekilde kesin – bu, işleme hızını ve LLM maliyetlerini büyük ölçüde artırır.

#### Kullanım örnekleri

Uzaktan sağlayıcı (Gemini-1.5-flash):
```bash
export OPENAI_API_KEY=<your_key>
python3 androidmeda.py \
--llm_provider google \
--llm_model gemini-1.5-flash \
--source_dir input_dir/ \
--output_dir out/ \
--save_code true
```
Çevrimdışı (yerel `ollama` arka ucu ile llama3.2):
```bash
python3 androidmeda.py \
--llm_provider ollama \
--llm_model llama3.2 \
--source_dir input_dir/ \
--output_dir out/ \
--save_code true
```
#### Çıktı
* `out/vuln_report.json` – `file`, `line`, `issue`, `severity` içeren JSON dizisi.
* **De-obfuscated `.java` dosyaları** ile yansıtılmış bir paket ağacı (sadece `--save_code true` ise).

#### İpuçları ve sorun giderme
* **Atlanan sınıf** ⇒ genellikle ayrıştırılamayan bir yöntemden kaynaklanır; paketi izole edin veya ayrıştırıcı regex'i güncelleyin.
* **Yavaş çalışma süresi / yüksek token kullanımı** ⇒ `--source_dir`'i *belirli* uygulama paketlerine yönlendirin, tüm decompile yerine.
* Her zaman *manuel olarak* güvenlik açığı raporunu gözden geçirin – LLM halüsinasyonları yanlış pozitiflere / negatiflere yol açabilir.

#### Pratik değer – Crocodilus kötü amaçlı yazılım vaka çalışması
2025 *Crocodilus* bankacılık truva atından ağır şekilde obfuscate edilmiş bir örneği Androidmeda ile beslemek, analiz süresini *saatler* yerine *dakikalar* seviyesine indirdi: araç, çağrı grafiği anlamsını geri kazandı, erişilebilirlik API'lerine ve hard-coded C2 URL'lerine yapılan çağrıları ortaya çıkardı ve analistlerin panellerine aktarılabilecek özlü bir rapor üretti.

---

## Referanslar ve Daha Fazla Okuma

- [https://maddiestone.github.io/AndroidAppRE/obfuscation.html](https://maddiestone.github.io/AndroidAppRE/obfuscation.html)
- BlackHat USA 2018: “Unpacking the Packed Unpacker: Reverse Engineering an Android Anti-Analysis Library” [[video](https://www.youtube.com/watch?v=s0Tqi7fuOSU)]
- Bu konuşma, bir Android uygulaması tarafından kullanılan en karmaşık anti-analiz yerel kütüphanelerinden birinin ters mühendisliğini ele alıyor. Çoğunlukla yerel kodda obfuscation tekniklerini kapsıyor.
- REcon 2019: “The Path to the Payload: Android Edition” [[video](https://recon.cx/media-archive/2019/Session.005.Maddie_Stone.The_path_to_the_payload_Android_Edition-J3ZnNl2GYjEfa.mp4)]
- Bu konuşma, bir Android botnetinin davranışını gizlemek için kullandığı yalnızca Java kodunda bir dizi obfuscation tekniğini tartışıyor.
- Androidmeda ile Android Uygulamalarını Deobfuscate Etmek (blog yazısı) – [mobile-hacker.com](https://www.mobile-hacker.com/2025/07/22/deobfuscating-android-apps-with-androidmeda-a-smarter-way-to-read-obfuscated-code/)
- Androidmeda kaynak kodu – [https://github.com/In3tinct/Androidmeda](https://github.com/In3tinct/Androidmeda)

- [https://maddiestone.github.io/AndroidAppRE/obfuscation.html](https://maddiestone.github.io/AndroidAppRE/obfuscation.html)
- BlackHat USA 2018: “Unpacking the Packed Unpacker: Reverse Engineering an Android Anti-Analysis Library” \[[video](https://www.youtube.com/watch?v=s0Tqi7fuOSU)]
- Bu konuşma, bir Android uygulaması tarafından kullanılan en karmaşık anti-analiz yerel kütüphanelerinden birinin ters mühendisliğini ele alıyor. Çoğunlukla yerel kodda obfuscation tekniklerini kapsıyor.
- REcon 2019: “The Path to the Payload: Android Edition” \[[video](https://recon.cx/media-archive/2019/Session.005.Maddie_Stone.The_path_to_the_payload_Android_Edition-J3ZnNl2GYjEfa.mp4)]
- Bu konuşma, bir Android botnetinin davranışını gizlemek için kullandığı yalnızca Java kodunda bir dizi obfuscation tekniğini tartışıyor.

{{#include ../../banners/hacktricks-training.md}}
