# 수동 디오브퓨세이션 기법

{{#include ../../banners/hacktricks-training.md}}

## 수동 **디오브퓨세이션 기법**

**소프트웨어 보안** 분야에서, 코드의 난독화를 이해할 수 있도록 만드는 과정인 **디오브퓨세이션**은 매우 중요합니다. 이 가이드는 정적 분석 기법과 난독화 패턴 인식에 중점을 두고 다양한 디오브퓨세이션 전략을 탐구합니다. 또한, 실용적인 적용을 위한 연습을 소개하고, 더 고급 주제를 탐구하고자 하는 이들을 위한 추가 자료를 제안합니다.

### **정적 디오브퓨세이션 전략**

**난독화된 코드**를 다룰 때, 난독화의 성격에 따라 여러 전략을 사용할 수 있습니다:

- **DEX 바이트코드 (Java)**: 효과적인 접근법 중 하나는 애플리케이션의 디오브퓨세이션 메서드를 식별한 다음, 이 메서드를 Java 파일에 복제하는 것입니다. 이 파일을 실행하여 대상 요소의 난독화를 되돌립니다.
- **Java 및 네이티브 코드**: 또 다른 방법은 디오브퓨세이션 알고리즘을 Python과 같은 스크립팅 언어로 변환하는 것입니다. 이 전략은 주요 목표가 알고리즘을 완전히 이해하는 것이 아니라 효과적으로 실행하는 것임을 강조합니다.

### **난독화 식별하기**

난독화된 코드를 인식하는 것은 디오브퓨세이션 과정의 첫 번째 단계입니다. 주요 지표는 다음과 같습니다:

- Java 및 Android에서 **문자열의 부재 또는 혼란**이 있으며, 이는 문자열 난독화를 시사할 수 있습니다.
- 자산 디렉토리의 **바이너리 파일 존재** 또는 `DexClassLoader` 호출이 있으며, 이는 코드 언팩 및 동적 로딩을 암시합니다.
- **식별할 수 없는 JNI 함수와 함께 네이티브 라이브러리 사용**이 있으며, 이는 네이티브 메서드의 잠재적 난독화를 나타냅니다.

## **디오브퓨세이션에서의 동적 분석**

제어된 환경에서 코드를 실행함으로써, 동적 분석은 **난독화된 코드가 실시간으로 어떻게 작동하는지를 관찰할 수 있게 해줍니다**. 이 방법은 코드의 진정한 의도를 숨기기 위해 설계된 복잡한 난독화 패턴의 내부 작동을 밝혀내는 데 특히 효과적입니다.

### **동적 분석의 응용**

- **런타임 복호화**: 많은 난독화 기법은 문자열이나 코드 세그먼트를 암호화하여 런타임에만 복호화됩니다. 동적 분석을 통해 이러한 암호화된 요소는 복호화 순간에 캡처되어 그 진정한 형태를 드러낼 수 있습니다.
- **난독화 기법 식별**: 애플리케이션의 동작을 모니터링함으로써, 동적 분석은 코드 가상화, 패커 또는 동적 코드 생성과 같은 특정 난독화 기법을 식별하는 데 도움을 줄 수 있습니다.
- **숨겨진 기능 발견**: 난독화된 코드는 정적 분석만으로는 명백하지 않은 숨겨진 기능을 포함할 수 있습니다. 동적 분석은 조건부로 실행되는 코드 경로를 포함하여 모든 코드 경로를 관찰할 수 있게 하여 이러한 숨겨진 기능을 밝혀냅니다.

### LLM을 이용한 자동 디오브퓨세이션 (Androidmeda)

이전 섹션은 완전 수동 전략에 중점을 두었지만, 2025년에는 대부분의 지루한 이름 바꾸기 및 제어 흐름 복구 작업을 자동화할 수 있는 *대형 언어 모델(LLM) 기반* 도구의 새로운 클래스가 등장했습니다. 대표적인 프로젝트는 **[Androidmeda](https://github.com/In3tinct/Androidmeda)**로, *디컴파일된* Java 소스(예: `jadx`에 의해 생성된)를 받아들여 크게 정리되고 주석이 달린 보안 주석 버전을 반환하는 Python 유틸리티입니다.

#### 주요 기능
* ProGuard / DexGuard / DashO / Allatori / …에 의해 생성된 의미 없는 식별자를 *의미론적* 이름으로 바꿉니다.
* **제어 흐름 평탄화**를 감지하고 재구성하여 불투명한 switch-case 상태 기계를 일반 루프 / if-else 구조로 대체합니다.
* 가능한 경우 일반적인 **문자열 암호화** 패턴을 복호화합니다.
* 복잡한 블록의 목적을 설명하는 **인라인 주석**을 삽입합니다.
* *경량 정적 보안 스캔*을 수행하고 발견 사항을 심각도 수준(정보 → 치명적)과 함께 `vuln_report.json`에 기록합니다.

#### 설치
```bash
git clone https://github.com/In3tinct/Androidmeda
cd Androidmeda
pip3 install -r requirements.txt
```
#### 입력 준비
1. `jadx` (또는 다른 디컴파일러)를 사용하여 대상 APK를 디컴파일하고 `.java` 파일이 포함된 *source* 디렉토리만 유지합니다:
```bash
jadx -d input_dir/ target.apk
```
2. (선택 사항) `input_dir/`를 잘라내어 분석하려는 애플리케이션 패키지만 포함하도록 합니다 – 이는 처리 속도와 LLM 비용을 크게 줄입니다.

#### 사용 예시

원격 제공자 (Gemini-1.5-flash):
```bash
export OPENAI_API_KEY=<your_key>
python3 androidmeda.py \
--llm_provider google \
--llm_model gemini-1.5-flash \
--source_dir input_dir/ \
--output_dir out/ \
--save_code true
```
오프라인 (로컬 `ollama` 백엔드와 llama3.2):
```bash
python3 androidmeda.py \
--llm_provider ollama \
--llm_model llama3.2 \
--source_dir input_dir/ \
--output_dir out/ \
--save_code true
```
#### Output
* `out/vuln_report.json` – JSON 배열로 `file`, `line`, `issue`, `severity`를 포함합니다.
* **비가시화된 `.java` 파일**이 포함된 미러 패키지 트리 (단, `--save_code true`인 경우에만).

#### Tips & troubleshooting
* **건너뛴 클래스** ⇒ 일반적으로 구문 분석할 수 없는 메서드로 인해 발생; 패키지를 분리하거나 파서 정규 표현식을 업데이트하세요.
* **느린 실행 시간 / 높은 토큰 사용량** ⇒ `--source_dir`를 전체 디컴파일 대신 *특정* 앱 패키지로 지정하세요.
* 항상 *수동으로* 취약점 보고서를 검토하세요 – LLM 환각은 잘못된 긍정/부정을 초래할 수 있습니다.

#### Practical value – Crocodilus malware case study
2025년 *Crocodilus* 뱅킹 트로이 목마의 심하게 비가시화된 샘플을 Androidmeda를 통해 분석한 결과, 분석 시간이 *시간*에서 *분*으로 단축되었습니다: 이 도구는 호출 그래프 의미를 복구하고, 접근성 API에 대한 호출과 하드코딩된 C2 URL을 드러내며, 분석가의 대시보드에 가져올 수 있는 간결한 보고서를 생성했습니다.

---

## References and Further Reading

- [https://maddiestone.github.io/AndroidAppRE/obfuscation.html](https://maddiestone.github.io/AndroidAppRE/obfuscation.html)
- BlackHat USA 2018: “Unpacking the Packed Unpacker: Reverse Engineering an Android Anti-Analysis Library” [[video](https://www.youtube.com/watch?v=s0Tqi7fuOSU)]
- 이 발표는 제가 본 Android 애플리케이션에서 사용된 가장 복잡한 안티 분석 네이티브 라이브러리 중 하나의 리버스 엔지니어링을 다룹니다. 주로 네이티브 코드의 비가시화 기술을 다룹니다.
- REcon 2019: “The Path to the Payload: Android Edition” [[video](https://recon.cx/media-archive/2019/Session.005.Maddie_Stone.The_path_to_the_payload_Android_Edition-J3ZnNl2GYjEfa.mp4)]
- 이 발표는 Android 봇넷이 행동을 숨기기 위해 사용한 Java 코드의 일련의 비가시화 기술에 대해 논의합니다.
- Androidmeda로 Android 앱 비가시화 해제하기 (블로그 포스트) – [mobile-hacker.com](https://www.mobile-hacker.com/2025/07/22/deobfuscating-android-apps-with-androidmeda-a-smarter-way-to-read-obfuscated-code/)
- Androidmeda 소스 코드 – [https://github.com/In3tinct/Androidmeda](https://github.com/In3tinct/Androidmeda)

- [https://maddiestone.github.io/AndroidAppRE/obfuscation.html](https://maddiestone.github.io/AndroidAppRE/obfuscation.html)
- BlackHat USA 2018: “Unpacking the Packed Unpacker: Reverse Engineering an Android Anti-Analysis Library” \[[video](https://www.youtube.com/watch?v=s0Tqi7fuOSU)]
- 이 발표는 제가 본 Android 애플리케이션에서 사용된 가장 복잡한 안티 분석 네이티브 라이브러리 중 하나의 리버스 엔지니어링을 다룹니다. 주로 네이티브 코드의 비가시화 기술을 다룹니다.
- REcon 2019: “The Path to the Payload: Android Edition” \[[video](https://recon.cx/media-archive/2019/Session.005.Maddie_Stone.The_path_to_the_payload_Android_Edition-J3ZnNl2GYjEfa.mp4)]
- 이 발표는 Android 봇넷이 행동을 숨기기 위해 사용한 Java 코드의 일련의 비가시화 기술에 대해 논의합니다.

{{#include ../../banners/hacktricks-training.md}}
