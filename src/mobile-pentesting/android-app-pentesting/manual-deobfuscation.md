# 手动去混淆技术

{{#include ../../banners/hacktricks-training.md}}

## 手动 **去混淆技术**

在 **软件安全** 的领域中，使模糊代码可理解的过程，称为 **去混淆**，至关重要。本指南深入探讨了各种去混淆策略，重点关注静态分析技术和识别混淆模式。此外，它还介绍了一个实践应用的练习，并建议了进一步的资源，以供有兴趣探索更高级主题的人士使用。

### **静态去混淆策略**

在处理 **混淆代码** 时，可以根据混淆的性质采用几种策略：

- **DEX 字节码 (Java)**：一种有效的方法是识别应用程序的去混淆方法，然后在 Java 文件中复制这些方法。执行该文件以逆转目标元素的混淆。
- **Java 和本地代码**：另一种方法是将去混淆算法翻译成像 Python 这样的脚本语言。这一策略强调，主要目标不是完全理解算法，而是有效地执行它。

### **识别混淆**

识别混淆代码是去混淆过程的第一步。关键指标包括：

- Java 和 Android 中 **字符串的缺失或混淆**，这可能表明字符串混淆。
- 资产目录中 **二进制文件的存在** 或对 `DexClassLoader` 的调用，暗示代码解包和动态加载。
- 使用 **本地库和不可识别的 JNI 函数**，表明本地方法可能被混淆。

## **去混淆中的动态分析**

通过在受控环境中执行代码，动态分析 **允许观察混淆代码在实时中的行为**。这种方法在揭示复杂混淆模式的内部工作原理方面特别有效，这些模式旨在隐藏代码的真实意图。

### **动态分析的应用**

- **运行时解密**：许多混淆技术涉及加密字符串或代码段，这些内容仅在运行时解密。通过动态分析，可以在解密时捕获这些加密元素，揭示其真实形式。
- **识别混淆技术**：通过监控应用程序的行为，动态分析可以帮助识别正在使用的特定混淆技术，例如代码虚拟化、打包器或动态代码生成。
- **揭示隐藏功能**：混淆代码可能包含通过静态分析无法显现的隐藏功能。动态分析允许观察所有代码路径，包括那些有条件执行的路径，以揭示这些隐藏功能。

### 使用 LLM 的自动去混淆 (Androidmeda)

虽然前面的部分专注于完全手动的策略，但在 2025 年，出现了一类 *大型语言模型 (LLM) 驱动* 的工具，可以自动化大部分繁琐的重命名和控制流恢复工作。
一个代表性项目是 **[Androidmeda](https://github.com/In3tinct/Androidmeda)** – 一个 Python 工具，接受 *反编译* 的 Java 源代码（例如，由 `jadx` 生成），并返回一个经过大幅清理、注释和安全注释的代码版本。

#### 关键功能
* 将 ProGuard / DexGuard / DashO / Allatori / … 生成的无意义标识符重命名为 *语义* 名称。
* 检测并重构 **控制流扁平化**，用正常的循环 / if-else 结构替换不透明的 switch-case 状态机。
* 在可能的情况下解密常见的 **字符串加密** 模式。
* 注入 **内联注释**，解释复杂代码块的目的。
* 执行 *轻量级静态安全扫描*，并将发现写入 `vuln_report.json`，附带严重性级别（信息 → 关键）。 

#### 安装
```bash
git clone https://github.com/In3tinct/Androidmeda
cd Androidmeda
pip3 install -r requirements.txt
```
#### 准备输入
1. 使用 `jadx`（或其他反编译器）反编译目标 APK，并仅保留包含 `.java` 文件的 *source* 目录：
```bash
jadx -d input_dir/ target.apk
```
2. （可选）修剪 `input_dir/`，使其仅包含您想要分析的应用程序包 – 这大大加快了处理速度和 LLM 成本。

#### 使用示例

远程提供者 (Gemini-1.5-flash):
```bash
export OPENAI_API_KEY=<your_key>
python3 androidmeda.py \
--llm_provider google \
--llm_model gemini-1.5-flash \
--source_dir input_dir/ \
--output_dir out/ \
--save_code true
```
离线（本地 `ollama` 后端与 llama3.2）：
```bash
python3 androidmeda.py \
--llm_provider ollama \
--llm_model llama3.2 \
--source_dir input_dir/ \
--output_dir out/ \
--save_code true
```
#### 输出
* `out/vuln_report.json` – JSON 数组，包含 `file`、`line`、`issue`、`severity`。
* 一个镜像包树，包含 **去混淆的 `.java` 文件**（仅在 `--save_code true` 时）。

#### 提示与故障排除
* **跳过的类** ⇒ 通常是由于无法解析的方法引起的；隔离包或更新解析器正则表达式。
* **运行时间慢 / 高令牌使用** ⇒ 将 `--source_dir` 指向 *特定* 应用包，而不是整个反编译。
* 始终 *手动审查* 漏洞报告 – LLM 幻觉可能导致误报 /漏报。

#### 实际价值 – Crocodilus 恶意软件案例研究
将 2025 年 *Crocodilus* 银行木马的一个高度混淆样本输入 Androidmeda，将分析时间从 *小时* 减少到 *分钟*：该工具恢复了调用图语义，揭示了对可访问性 API 和硬编码 C2 URL 的调用，并生成了可以导入分析仪仪表板的简明报告。

---

## 参考文献和进一步阅读

- [https://maddiestone.github.io/AndroidAppRE/obfuscation.html](https://maddiestone.github.io/AndroidAppRE/obfuscation.html)
- BlackHat USA 2018: “解包打包的解包器：逆向工程一个 Android 反分析库” [[视频](https://www.youtube.com/watch?v=s0Tqi7fuOSU)]
- 本次演讲讨论了逆向工程我见过的 Android 应用程序使用的最复杂的反分析本地库之一。主要涵盖了本地代码中的混淆技术。
- REcon 2019: “通往有效载荷的路径：Android 版” [[视频](https://recon.cx/media-archive/2019/Session.005.Maddie_Stone.The_path_to_the_payload_Android_Edition-J3ZnNl2GYjEfa.mp4)]
- 本次演讲讨论了一系列仅在 Java 代码中使用的混淆技术，Android 僵尸网络使用这些技术来隐藏其行为。
- 使用 Androidmeda 去混淆 Android 应用（博客文章） – [mobile-hacker.com](https://www.mobile-hacker.com/2025/07/22/deobfuscating-android-apps-with-androidmeda-a-smarter-way-to-read-obfuscated-code/)
- Androidmeda 源代码 – [https://github.com/In3tinct/Androidmeda](https://github.com/In3tinct/Androidmeda)

- [https://maddiestone.github.io/AndroidAppRE/obfuscation.html](https://maddiestone.github.io/AndroidAppRE/obfuscation.html)
- BlackHat USA 2018: “解包打包的解包器：逆向工程一个 Android 反分析库” \[[视频](https://www.youtube.com/watch?v=s0Tqi7fuOSU)]
- 本次演讲讨论了逆向工程我见过的 Android 应用程序使用的最复杂的反分析本地库之一。主要涵盖了本地代码中的混淆技术。
- REcon 2019: “通往有效载荷的路径：Android 版” \[[视频](https://recon.cx/media-archive/2019/Session.005.Maddie_Stone.The_path_to_the_payload_Android_Edition-J3ZnNl2GYjEfa.mp4)]
- 本次演讲讨论了一系列仅在 Java 代码中使用的混淆技术，Android 僵尸网络使用这些技术来隐藏其行为。

{{#include ../../banners/hacktricks-training.md}}
