# Manual De-obfuscation Techniques

{{#include ../../banners/hacktricks-training.md}}

## Manual **De-obfuscation Techniques**

U oblasti bezbednosti softvera, proces koji čini zamagljen kod razumljivim, poznat kao **de-obfuscation**, je od suštinskog značaja. Ovaj vodič istražuje različite strategije za de-obfuscation, sa fokusom na static analysis tehnike i prepoznavanje obfuscation obrazaca. Takođe uvodi vežbu za praktičnu primenu i predlaže dodatne resurse za one koji žele da istraže naprednije teme.

### **Strategies for Static De-obfuscation**

Kada se radi sa **obfuscated code**, može se primeniti više strategija u zavisnosti od prirode obfuscation:

- **DEX bytecode (Java)**: Jedan efikasan pristup podrazumeva identifikovanje aplikacionih de-obfuscation metoda, a zatim repliciranje tih metoda u Java fajlu. Taj fajl se izvršava da bi se reverzovao obfuscation na ciljnim elementima.
- **Java and Native Code**: Druga metoda je prevesti de-obfuscation algoritam u scripting language kao što je Python. Ova strategija naglašava da primarni cilj nije potpuno razumevanje algoritma već njegovo efikasno izvršavanje.

### **Identifying Obfuscation**

Prepoznavanje obfuscated code je prvi korak u de-obfuscation procesu. Ključni indikatori uključuju:

- **The absence or scrambling of strings** u Java i Android, što može ukazivati na string obfuscation.
- **The presence of binary files** u assets direktorijumu ili pozivi ka `DexClassLoader`, što nagoveštava code unpacking i dynamic loading.
- Korišćenje **native libraries** uz neidentifikovane JNI funkcije, što ukazuje na potencijalnu obfuscation native metoda.

## **Dynamic Analysis in De-obfuscation**

Izvršavanjem koda u kontrolisanom okruženju, dynamic analysis omogućava posmatranje kako obfuscated code radi u realnom vremenu. Ova metoda je posebno efikasna u otkrivanju unutrašnjeg rada kompleksnih obfuscation obrazaca koji su dizajnirani da sakriju pravu nameru koda.

### **Applications of Dynamic Analysis**

- **Runtime Decryption**: Mnoge obfuscation tehnike uključuju enkriptovanje strings ili segmenata koda koji se dekriptuju samo at runtime. Kroz dynamic analysis, ovi enkriptovani elementi se mogu uhvatiti u trenutku dekripcije, otkrivajući njihov pravi oblik.
- **Identifying Obfuscation Techniques**: Praćenjem ponašanja aplikacije, dynamic analysis može pomoći u identifikovanju specifičnih obfuscation techniques koje se koriste, kao što su code virtualization, packers, ili dynamic code generation.
- **Uncovering Hidden Functionality**: Obfuscated code može sadržati skrivene funkcionalnosti koje nisu vidljive kroz static analysis. Dynamic analysis omogućava posmatranje svih code path-ova, uključujući one koji se izvršavaju uslovno, kako bi se otkrile takve skrivene funkcionalnosti.

### Automated De-obfuscation with LLMs (Androidmeda)

Dok se prethodni delovi fokusiraju na potpuno manualne strategije, 2025. se pojavila nova klasa alata zasnovanih na *Large-Language-Model (LLM)* koji mogu automatizovati većinu zamornog renaming-a i control-flow recovery posla. Jedan reprezentativan projekat je **[Androidmeda](https://github.com/In3tinct/Androidmeda)** – Python utility koji uzima *decompiled* Java izvore (npr. generisane od strane `jadx`) i vraća znatno očišćenu, komentarisanu i security-annotated verziju koda.

#### Key capabilities
* Preimenuje besmislene identifikatore koje generišu ProGuard / DexGuard / DashO / Allatori / … u *semantic* names.
* Detektuje i restruktuira **control-flow flattening**, zamenjujući opake switch-case state machines sa normalnim loops / if-else konstruktima.
* Dekriptuje uobičajene **string encryption** obrasce kada je moguće.
* Ubacuje **inline comments** koji objašnjavaju svrhu kompleksnih blokova.
* Izvodi *lightweight static security scan* i zapisuje nalaze u `vuln_report.json` sa nivoima težine (informational → critical).

#### Instalacija
```bash
git clone https://github.com/In3tinct/Androidmeda
cd Androidmeda
pip3 install -r requirements.txt
```
#### Priprema ulaza
1. Dekomпajlirajte ciljni APK pomoću `jadx` (ili nekog drugog dekompajlera) i zadržite samo *izvorni* direktorijum koji sadrži `.java` fajlove:
```bash
jadx -d input_dir/ target.apk
```
2. (Opcionalno) Skraćite `input_dir/` tako da sadrži samo aplikacione pakete koje želite da analizirate – ovo znatno ubrzava obradu i smanjuje troškove LLM-a.

#### Primeri upotrebe

Remote provider (Gemini-1.5-flash):
```bash
export OPENAI_API_KEY=<your_key>
python3 androidmeda.py \
--llm_provider google \
--llm_model gemini-1.5-flash \
--source_dir input_dir/ \
--output_dir out/ \
--save_code true
```
Vanmrežno (lokalni `ollama` backend sa llama3.2):
```bash
python3 androidmeda.py \
--llm_provider ollama \
--llm_model llama3.2 \
--source_dir input_dir/ \
--output_dir out/ \
--save_code true
```
#### Izlaz
* `out/vuln_report.json` – JSON niz sa `file`, `line`, `issue`, `severity`.
* Ogledano stablo paketa sa **de-obfuscated `.java` files** (samo ako `--save_code true`).

#### Saveti i rešavanje problema
* **Preskočena klasa** ⇒ obično uzrokovana metodom koja se ne može parsirati; izolujte paket ili ažurirajte parser regex.
* **Sporo izvršavanje / velika potrošnja tokena** ⇒ postavite `--source_dir` na *specifične* pakete aplikacije umesto na celu dekompilaciju.
* Uvek *ručno pregledajte* izveštaj o ranjivostima – LLM halucinacije mogu dovesti do lažno pozitivnih / negativnih rezultata.

#### Praktična vrednost – studija slučaja malvera Crocodilus
Slanje jako obfuskovanog uzorka iz 2025. godine bankarskog trojana *Crocodilus* kroz Androidmeda skratilo je vreme analize sa *sati* na *minute*: alat je povratio semantiku call-graph-a, otkrio pozive ka accessibility API-ima i hardkodirane C2 URL-ove, i proizveo sažet izveštaj koji se može uvesti u dashboard-e analitičara.

---

### Ciljana dekripcija Dalvik stringova pomoću DaliVM

**DaliVM** je Python Dalvik bytecode emulator namenjen statičkom vraćanju vrednosti koje postoje samo za vreme izvršavanja (posebno dekriptovanih stringova) bez pokretanja Android-a. Izvršava *specifičan* metod unutar APK-a emulirajući Dalvik opcode-e i mock-uje Android/Java API-je.

**Tok rada**
1. **Izaberite ciljanu metodu** po Dalvik signaturi (`Lpkg/Class;->method(Args)Ret`). Primeri: `Lutil/Crypto;->decrypt(Ljava/lang/String;)Ljava/lang/String;`, `LMyClass;->compute(II)I`.
2. **Enumerišite call site-ove** kroz **multi-DEX** (`classes*.dex`) i **rekonstruишите argumente** pomoću praćenja obrnutog toka podataka, forward lookup-a i delimičnog izvršenja po potrebi.
3. **Emulirajte metodu** unutar Dalvik VM-a (pokriva 120+ opcode-a across const/array/control/field/invoke, rukuje inicijalizacijom klase preko `<clinit>`) i **sakupljajte povratne vrednosti** (npr. dekriptovane stringove).
4. **Zaobiđite runtime zavisnosti** koristeći ugrađene mock-ove za uobičajene Android API-je (Context, PackageManager, Signature, reflection, system services) i hook-ove za Java stdlib (String/StringBuilder/Integer/Math/Arrays/List/Iterator).
5. Ako izvršavanje zakaže, **omogućite praćenje na nivou opcode-a** da vidite promene PC/registara i proširite opcode handler-e.

**Korišćenje CLI-a**
```bash
# Emulate a decryptor and dump all returns
python emulate.py app.apk "Lcom/example/Decryptor;->decrypt"

# Verbose, debug trace, and limit outputs
python emulate.py app.apk "Lcom/example/Decryptor;->decrypt" -v --debug --limit 10
```
Outputs su prikupljene vrednosti vraćene pri svakom pozivu; korisne za bulk string/config extraction tokom malware triage-a ili kod jako obfuscated aplikacija.

## Reference i dodatna literatura

- [DaliVM: Python Dalvik emulator for static string decryption](https://github.com/fatalSec/DaliVM)
- [https://maddiestone.github.io/AndroidAppRE/obfuscation.html](https://maddiestone.github.io/AndroidAppRE/obfuscation.html)
- BlackHat USA 2018: “Unpacking the Packed Unpacker: Reverse Engineering an Android Anti-Analysis Library” [[video](https://www.youtube.com/watch?v=s0Tqi7fuOSU)]
- Ovo predavanje obrađuje reverse engineering jedne od najsloženijih anti-analysis native biblioteka koje sam video u upotrebi u Android aplikacijama. Uglavnom pokriva obfuscation techniques u native kodu.
- REcon 2019: “The Path to the Payload: Android Edition” [[video](https://recon.cx/media-archive/2019/Session.005.Maddie_Stone.The_path_to_the_payload_Android_Edition-J3ZnNl2GYjEfa.mp4)]
- Ovo predavanje raspravlja o nizu obfuscation techniques, isključivo u Java kodu, koje je Android botnet koristio da sakrije svoje ponašanje.
- Deobfuscating Android Apps with Androidmeda (blog post) – [mobile-hacker.com](https://www.mobile-hacker.com/2025/07/22/deobfuscating-android-apps-with-androidmeda-a-smarter-way-to-read-obfuscated-code/)
- Androidmeda source code – [https://github.com/In3tinct/Androidmeda](https://github.com/In3tinct/Androidmeda)

{{#include ../../banners/hacktricks-training.md}}
