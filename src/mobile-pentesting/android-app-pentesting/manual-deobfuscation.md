# Tecniche di De-obfuscazione Manuale

{{#include ../../banners/hacktricks-training.md}}

## Tecniche di **De-obfuscazione Manuale**

Nel campo della **sicurezza del software**, il processo di rendere comprensibile il codice oscurato, noto come **de-obfuscazione**, è cruciale. Questa guida esplora varie strategie per la de-obfuscazione, concentrandosi su tecniche di analisi statica e riconoscimento dei modelli di offuscamento. Inoltre, introduce un esercizio per l'applicazione pratica e suggerisce ulteriori risorse per coloro che sono interessati ad esplorare argomenti più avanzati.

### **Strategie per la De-obfuscazione Statica**

Quando si tratta di **codice offuscato**, possono essere impiegate diverse strategie a seconda della natura dell'offuscamento:

- **Bytecode DEX (Java)**: Un approccio efficace consiste nell'identificare i metodi di de-obfuscazione dell'applicazione, quindi replicare questi metodi in un file Java. Questo file viene eseguito per invertire l'offuscamento sugli elementi mirati.
- **Codice Java e Nativo**: Un altro metodo è tradurre l'algoritmo di de-obfuscazione in un linguaggio di scripting come Python. Questa strategia evidenzia che l'obiettivo principale non è comprendere completamente l'algoritmo, ma eseguirlo in modo efficace.

### **Identificazione dell'Offuscamento**

Riconoscere il codice offuscato è il primo passo nel processo di de-obfuscazione. Gli indicatori chiave includono:

- L'**assenza o la distorsione delle stringhe** in Java e Android, che possono suggerire offuscamento delle stringhe.
- La **presenza di file binari** nella directory delle risorse o chiamate a `DexClassLoader`, che suggeriscono un unpacking del codice e un caricamento dinamico.
- L'uso di **librerie native insieme a funzioni JNI non identificabili**, che indicano un potenziale offuscamento dei metodi nativi.

## **Analisi Dinamica nella De-obfuscazione**

Eseguendo il codice in un ambiente controllato, l'analisi dinamica **consente di osservare come il codice offuscato si comporta in tempo reale**. Questo metodo è particolarmente efficace per scoprire il funzionamento interno di modelli di offuscamento complessi progettati per nascondere il vero intento del codice.

### **Applicazioni dell'Analisi Dinamica**

- **Decrittazione a Runtime**: Molte tecniche di offuscamento comportano la crittografia di stringhe o segmenti di codice che vengono decrittografati solo a runtime. Attraverso l'analisi dinamica, questi elementi crittografati possono essere catturati nel momento della decrittazione, rivelando la loro forma reale.
- **Identificazione delle Tecniche di Offuscamento**: Monitorando il comportamento dell'applicazione, l'analisi dinamica può aiutare a identificare specifiche tecniche di offuscamento utilizzate, come la virtualizzazione del codice, i packer o la generazione dinamica di codice.
- **Scoprire Funzionalità Nascoste**: Il codice offuscato può contenere funzionalità nascoste che non sono evidenti attraverso l'analisi statica da sola. L'analisi dinamica consente di osservare tutti i percorsi del codice, inclusi quelli eseguiti condizionalmente, per scoprire tali funzionalità nascoste.

### De-obfuscazione Automatica con LLM (Androidmeda)

Sebbene le sezioni precedenti si concentrino su strategie completamente manuali, nel 2025 è emersa una nuova classe di strumenti *alimentati da Modelli di Linguaggio di Grandi Dimensioni (LLM)* che possono automatizzare gran parte del lavoro noioso di rinominazione e recupero del flusso di controllo. 
Un progetto rappresentativo è **[Androidmeda](https://github.com/In3tinct/Androidmeda)** – un'utilità Python che prende fonti Java *decompilate* (ad es. prodotte da `jadx`) e restituisce una versione notevolmente ripulita, commentata e annotata per la sicurezza del codice.

#### Capacità Chiave
* Rinomina identificatori privi di significato generati da ProGuard / DexGuard / DashO / Allatori / … in nomi *semantici*.
* Rileva e ristruttura il **flattening del flusso di controllo**, sostituendo macchine a stati switch-case opache con normali cicli / costrutti if-else.
* Decrittografa comuni **modelli di crittografia delle stringhe** quando possibile.
* Inietta **commenti inline** che spiegano lo scopo di blocchi complessi.
* Esegue una *scansione statica di sicurezza leggera* e scrive i risultati in `vuln_report.json` con livelli di gravità (informativo → critico).

#### Installazione
```bash
git clone https://github.com/In3tinct/Androidmeda
cd Androidmeda
pip3 install -r requirements.txt
```
#### Preparazione degli input
1. Decompila l'APK target con `jadx` (o qualsiasi altro decompilatore) e conserva solo la directory *source* che contiene i file `.java`:
```bash
jadx -d input_dir/ target.apk
```
2. (Opzionale) Riduci `input_dir/` in modo che contenga solo i pacchetti dell'applicazione che desideri analizzare – questo accelera notevolmente l'elaborazione e i costi LLM.

#### Esempi di utilizzo

Fornitore remoto (Gemini-1.5-flash):
```bash
export OPENAI_API_KEY=<your_key>
python3 androidmeda.py \
--llm_provider google \
--llm_model gemini-1.5-flash \
--source_dir input_dir/ \
--output_dir out/ \
--save_code true
```
Offline (backend locale `ollama` con llama3.2):
```bash
python3 androidmeda.py \
--llm_provider ollama \
--llm_model llama3.2 \
--source_dir input_dir/ \
--output_dir out/ \
--save_code true
```
#### Output
* `out/vuln_report.json` – array JSON con `file`, `line`, `issue`, `severity`.
* Un albero di pacchetti speculare con **file `.java` de-offuscati** (solo se `--save_code true`).

#### Tips & troubleshooting
* **Classe saltata** ⇒ solitamente causata da un metodo non analizzabile; isola il pacchetto o aggiorna l'espressione regolare del parser.
* **Tempo di esecuzione lento / alto utilizzo di token** ⇒ punta `--source_dir` a pacchetti app *specifici* invece dell'intero decompilato.
* Rivedi sempre *manualmente* il rapporto sulle vulnerabilità – le allucinazioni LLM possono portare a falsi positivi / negativi.

#### Practical value – Crocodilus malware case study
Fornire un campione pesantemente offuscato del trojan bancario *Crocodilus* del 2025 attraverso Androidmeda ha ridotto il tempo di analisi da *ore* a *minuti*: lo strumento ha recuperato la semantica del grafo delle chiamate, rivelato chiamate alle API di accessibilità e URL C2 hard-coded, e prodotto un rapporto conciso che poteva essere importato nei dashboard degli analisti.

---

## References and Further Reading

- [https://maddiestone.github.io/AndroidAppRE/obfuscation.html](https://maddiestone.github.io/AndroidAppRE/obfuscation.html)
- BlackHat USA 2018: “Unpacking the Packed Unpacker: Reverse Engineering an Android Anti-Analysis Library” [[video](https://www.youtube.com/watch?v=s0Tqi7fuOSU)]
- Questo intervento tratta il reverse engineering di una delle librerie native anti-analisi più complesse che ho visto utilizzate da un'applicazione Android. Copre principalmente tecniche di offuscamento nel codice nativo.
- REcon 2019: “The Path to the Payload: Android Edition” [[video](https://recon.cx/media-archive/2019/Session.005.Maddie_Stone.The_path_to_the_payload_Android_Edition-J3ZnNl2GYjEfa.mp4)]
- Questo intervento discute una serie di tecniche di offuscamento, esclusivamente nel codice Java, che un botnet Android stava utilizzando per nascondere il suo comportamento.
- Deobfuscating Android Apps with Androidmeda (blog post) – [mobile-hacker.com](https://www.mobile-hacker.com/2025/07/22/deobfuscating-android-apps-with-androidmeda-a-smarter-way-to-read-obfuscated-code/)
- Codice sorgente di Androidmeda – [https://github.com/In3tinct/Androidmeda](https://github.com/In3tinct/Androidmeda)

- [https://maddiestone.github.io/AndroidAppRE/obfuscation.html](https://maddiestone.github.io/AndroidAppRE/obfuscation.html)
- BlackHat USA 2018: “Unpacking the Packed Unpacker: Reverse Engineering an Android Anti-Analysis Library” \[[video](https://www.youtube.com/watch?v=s0Tqi7fuOSU)]
- Questo intervento tratta il reverse engineering di una delle librerie native anti-analisi più complesse che ho visto utilizzate da un'applicazione Android. Copre principalmente tecniche di offuscamento nel codice nativo.
- REcon 2019: “The Path to the Payload: Android Edition” \[[video](https://recon.cx/media-archive/2019/Session.005.Maddie_Stone.The_path_to_the_payload_Android_Edition-J3ZnNl2GYjEfa.mp4)]
- Questo intervento discute una serie di tecniche di offuscamento, esclusivamente nel codice Java, che un botnet Android stava utilizzando per nascondere il suo comportamento.

{{#include ../../banners/hacktricks-training.md}}
