# Ręczne techniki deobfuskacji

{{#include ../../banners/hacktricks-training.md}}

## Ręczne **techniki deobfuskacji**

W dziedzinie **bezpieczeństwa oprogramowania** proces przekształcania zatartego kodu w zrozumiały, znany jako **deobfuskacja**, jest kluczowy. Ten przewodnik zagłębia się w różne strategie deobfuskacji, koncentrując się na technikach analizy statycznej i rozpoznawaniu wzorców obfuskacji. Dodatkowo wprowadza ćwiczenie do praktycznego zastosowania i sugeruje dalsze zasoby dla tych, którzy są zainteresowani zgłębianiem bardziej zaawansowanych tematów.

### **Strategie deobfuskacji statycznej**

Podczas pracy z **zatartym kodem** można zastosować kilka strategii w zależności od charakteru obfuskacji:

- **Bytecode DEX (Java)**: Jednym z efektywnych podejść jest zidentyfikowanie metod deobfuskacji aplikacji, a następnie odtworzenie tych metod w pliku Java. Plik ten jest wykonywany, aby odwrócić obfuskację na docelowych elementach.
- **Kod Java i natywny**: Inną metodą jest przetłumaczenie algorytmu deobfuskacji na język skryptowy, taki jak Python. Ta strategia podkreśla, że głównym celem nie jest pełne zrozumienie algorytmu, ale skuteczne jego wykonanie.

### **Rozpoznawanie obfuskacji**

Rozpoznanie zatartego kodu to pierwszy krok w procesie deobfuskacji. Kluczowe wskaźniki to:

- **brak lub zatarcie ciągów** w Java i Android, co może sugerować obfuskację ciągów.
- **obecność plików binarnych** w katalogu zasobów lub wywołania do `DexClassLoader`, co sugeruje rozpakowywanie kodu i dynamiczne ładowanie.
- Użycie **bibliotek natywnych obok nieidentyfikowalnych funkcji JNI**, co wskazuje na potencjalną obfuskację metod natywnych.

## **Analiza dynamiczna w deobfuskacji**

Wykonując kod w kontrolowanym środowisku, analiza dynamiczna **pozwala na obserwację, jak zatarte kody zachowują się w czasie rzeczywistym**. Metoda ta jest szczególnie skuteczna w odkrywaniu wewnętrznych mechanizmów złożonych wzorców obfuskacji, które mają na celu ukrycie prawdziwego zamiaru kodu.

### **Zastosowania analizy dynamicznej**

- **Deszyfrowanie w czasie rzeczywistym**: Wiele technik obfuskacji polega na szyfrowaniu ciągów lub segmentów kodu, które są deszyfrowane tylko w czasie wykonywania. Dzięki analizie dynamicznej te zaszyfrowane elementy mogą być uchwycone w momencie deszyfrowania, ujawniając ich prawdziwą formę.
- **Identyfikacja technik obfuskacji**: Monitorując zachowanie aplikacji, analiza dynamiczna może pomóc w identyfikacji konkretnych technik obfuskacji, takich jak wirtualizacja kodu, pakowanie lub dynamiczne generowanie kodu.
- **Odkrywanie ukrytej funkcjonalności**: Zatarte kody mogą zawierać ukryte funkcjonalności, które nie są widoczne tylko poprzez analizę statyczną. Analiza dynamiczna pozwala na obserwację wszystkich ścieżek kodu, w tym tych wykonywanych warunkowo, aby odkryć takie ukryte funkcjonalności.

### Zautomatyzowana deobfuskacja z LLM (Androidmeda)

Podczas gdy poprzednie sekcje koncentrują się na w pełni ręcznych strategiach, w 2025 roku pojawiła się nowa klasa narzędzi zasilanych *modelami językowymi (LLM)*, które mogą zautomatyzować większość żmudnej pracy związanej z renamingiem i odzyskiwaniem przepływu kontrolnego. 
Jednym z reprezentatywnych projektów jest **[Androidmeda](https://github.com/In3tinct/Androidmeda)** – narzędzie w Pythonie, które przyjmuje *dekompilowane* źródła Java (np. produkowane przez `jadx`) i zwraca znacznie oczyszczoną, skomentowaną i zabezpieczoną wersję kodu.

#### Kluczowe możliwości
* Zmienia nazwy bezsensownych identyfikatorów generowanych przez ProGuard / DexGuard / DashO / Allatori / … na *semantyczne* nazwy.
* Wykrywa i restrukturyzuje **spłaszczanie przepływu kontrolnego**, zastępując nieprzezroczyste maszyny stanowe switch-case normalnymi pętlami / konstrukcjami if-else.
* Deszyfruje powszechne **wzorce szyfrowania ciągów**, gdy to możliwe.
* Wstrzykuje **komentarze w linii**, które wyjaśniają cel złożonych bloków.
* Wykonuje *lekkie skanowanie bezpieczeństwa statycznego* i zapisuje wyniki do `vuln_report.json` z poziomami powagi (informacyjne → krytyczne).

#### Instalacja
```bash
git clone https://github.com/In3tinct/Androidmeda
cd Androidmeda
pip3 install -r requirements.txt
```
#### Przygotowanie wejść
1. Dezaktywuj docelowy APK za pomocą `jadx` (lub innego dekompilatora) i zachowaj tylko katalog *source*, który zawiera pliki `.java`:
```bash
jadx -d input_dir/ target.apk
```
2. (Opcjonalnie) Przytnij `input_dir/`, aby zawierał tylko pakiety aplikacji, które chcesz analizować – znacznie przyspiesza to przetwarzanie i koszty LLM.

#### Przykłady użycia

Zdalny dostawca (Gemini-1.5-flash):
```bash
export OPENAI_API_KEY=<your_key>
python3 androidmeda.py \
--llm_provider google \
--llm_model gemini-1.5-flash \
--source_dir input_dir/ \
--output_dir out/ \
--save_code true
```
Offline (lokalny `ollama` backend z llama3.2):
```bash
python3 androidmeda.py \
--llm_provider ollama \
--llm_model llama3.2 \
--source_dir input_dir/ \
--output_dir out/ \
--save_code true
```
#### Wynik
* `out/vuln_report.json` – tablica JSON z `file`, `line`, `issue`, `severity`.
* Odbity drzewo pakietów z **deobfuskowanymi plikami `.java`** (tylko jeśli `--save_code true`).

#### Wskazówki i rozwiązywanie problemów
* **Pominięta klasa** ⇒ zazwyczaj spowodowana nieparsowalną metodą; izoluj pakiet lub zaktualizuj wyrażenie regularne parsera.
* **Wolny czas działania / wysokie zużycie tokenów** ⇒ wskaźnik `--source_dir` na *konkretne* pakiety aplikacji zamiast całego dekompilatu.
* Zawsze *ręcznie przeglądaj* raport o podatnościach – halucynacje LLM mogą prowadzić do fałszywych pozytywów / negatywów.

#### Wartość praktyczna – studium przypadku złośliwego oprogramowania Crocodilus
Przetwarzanie mocno obfuskowanego próbki z 2025 *Crocodilus* trojana bankowego przez Androidmeda skróciło czas analizy z *godzin* do *minut*: narzędzie odzyskało semantykę grafu wywołań, ujawniło wywołania do API dostępności i zakodowane na stałe adresy URL C2, a także wygenerowało zwięzły raport, który można było zaimportować do pulpitów analityków.

---

## Odniesienia i dalsza lektura

- [https://maddiestone.github.io/AndroidAppRE/obfuscation.html](https://maddiestone.github.io/AndroidAppRE/obfuscation.html)
- BlackHat USA 2018: “Unpacking the Packed Unpacker: Reverse Engineering an Android Anti-Analysis Library” [[video](https://www.youtube.com/watch?v=s0Tqi7fuOSU)]
- Ta prezentacja dotyczy inżynierii odwrotnej jednej z najbardziej złożonych natywnych bibliotek antyanalizacyjnych, jakie widziałem w aplikacji Android. Dotyczy głównie technik obfuskacji w kodzie natywnym.
- REcon 2019: “The Path to the Payload: Android Edition” [[video](https://recon.cx/media-archive/2019/Session.005.Maddie_Stone.The_path_to_the_payload_Android_Edition-J3ZnNl2GYjEfa.mp4)]
- Ta prezentacja omawia szereg technik obfuskacji, wyłącznie w kodzie Java, które botnet Androida używał do ukrywania swojego zachowania.
- Deobfuskowanie aplikacji Android z Androidmeda (post na blogu) – [mobile-hacker.com](https://www.mobile-hacker.com/2025/07/22/deobfuscating-android-apps-with-androidmeda-a-smarter-way-to-read-obfuscated-code/)
- Kod źródłowy Androidmeda – [https://github.com/In3tinct/Androidmeda](https://github.com/In3tinct/Androidmeda)

- [https://maddiestone.github.io/AndroidAppRE/obfuscation.html](https://maddiestone.github.io/AndroidAppRE/obfuscation.html)
- BlackHat USA 2018: “Unpacking the Packed Unpacker: Reverse Engineering an Android Anti-Analysis Library” \[[video](https://www.youtube.com/watch?v=s0Tqi7fuOSU)]
- Ta prezentacja dotyczy inżynierii odwrotnej jednej z najbardziej złożonych natywnych bibliotek antyanalizacyjnych, jakie widziałem w aplikacji Android. Dotyczy głównie technik obfuskacji w kodzie natywnym.
- REcon 2019: “The Path to the Payload: Android Edition” \[[video](https://recon.cx/media-archive/2019/Session.005.Maddie_Stone.The_path_to_the_payload_Android_Edition-J3ZnNl2GYjEfa.mp4)]
- Ta prezentacja omawia szereg technik obfuskacji, wyłącznie w kodzie Java, które botnet Androida używał do ukrywania swojego zachowania.

{{#include ../../banners/hacktricks-training.md}}
