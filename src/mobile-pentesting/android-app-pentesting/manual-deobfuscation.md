# Técnicas Manuais de De-obfuscação

{{#include ../../banners/hacktricks-training.md}}

## Técnicas Manuais de **De-obfuscação**

No campo da **segurança de software**, o processo de tornar o código obscurecido compreensível, conhecido como **de-obfuscação**, é crucial. Este guia explora várias estratégias para de-obfuscação, focando em técnicas de análise estática e reconhecimento de padrões de obfuscação. Além disso, apresenta um exercício para aplicação prática e sugere recursos adicionais para aqueles interessados em explorar tópicos mais avançados.

### **Estratégias para De-obfuscação Estática**

Ao lidar com **código ofuscado**, várias estratégias podem ser empregadas dependendo da natureza da obfuscação:

- **Código bytecode DEX (Java)**: Uma abordagem eficaz envolve identificar os métodos de de-obfuscação do aplicativo e, em seguida, replicar esses métodos em um arquivo Java. Este arquivo é executado para reverter a obfuscação nos elementos alvo.
- **Código Java e Nativo**: Outro método é traduzir o algoritmo de de-obfuscação para uma linguagem de script como Python. Esta estratégia destaca que o objetivo principal não é entender completamente o algoritmo, mas executá-lo de forma eficaz.

### **Identificando Obfuscação**

Reconhecer código ofuscado é o primeiro passo no processo de de-obfuscação. Indicadores-chave incluem:

- A **ausência ou embaralhamento de strings** em Java e Android, o que pode sugerir obfuscação de strings.
- A **presença de arquivos binários** no diretório de assets ou chamadas para `DexClassLoader`, sugerindo desempacotamento de código e carregamento dinâmico.
- O uso de **bibliotecas nativas juntamente com funções JNI não identificáveis**, indicando potencial obfuscação de métodos nativos.

## **Análise Dinâmica na De-obfuscação**

Ao executar o código em um ambiente controlado, a análise dinâmica **permite observar como o código ofuscado se comporta em tempo real**. Este método é particularmente eficaz para descobrir o funcionamento interno de padrões de obfuscação complexos que são projetados para ocultar a verdadeira intenção do código.

### **Aplicações da Análise Dinâmica**

- **Descriptografia em Tempo de Execução**: Muitas técnicas de obfuscação envolvem a criptografia de strings ou segmentos de código que só são descriptografados em tempo de execução. Através da análise dinâmica, esses elementos criptografados podem ser capturados no momento da descriptografia, revelando sua verdadeira forma.
- **Identificação de Técnicas de Obfuscação**: Ao monitorar o comportamento do aplicativo, a análise dinâmica pode ajudar a identificar técnicas específicas de obfuscação sendo utilizadas, como virtualização de código, packers ou geração dinâmica de código.
- **Descoberta de Funcionalidades Ocultas**: O código ofuscado pode conter funcionalidades ocultas que não são aparentes apenas através da análise estática. A análise dinâmica permite observar todos os caminhos de código, incluindo aqueles executados condicionalmente, para descobrir tais funcionalidades ocultas.

### De-obfuscação Automatizada com LLMs (Androidmeda)

Enquanto as seções anteriores se concentram em estratégias totalmente manuais, em 2025 surgiu uma nova classe de ferramentas *movidas por Modelos de Linguagem Grande (LLM)* que podem automatizar a maior parte do trabalho tedioso de renomeação e recuperação de fluxo de controle. 
Um projeto representativo é o **[Androidmeda](https://github.com/In3tinct/Androidmeda)** – uma utilidade Python que recebe fontes Java *decompiladas* (por exemplo, produzidas por `jadx`) e retorna uma versão do código muito limpa, comentada e anotada em termos de segurança.

#### Principais capacidades
* Renomeia identificadores sem significado gerados por ProGuard / DexGuard / DashO / Allatori / … para nomes *semânticos*.
* Detecta e reestrutura **achatamento de fluxo de controle**, substituindo máquinas de estado opacas de switch-case por loops normais / construções if-else.
* Descriptografa padrões comuns de **criptografia de strings** quando possível.
* Injeta **comentários inline** que explicam o propósito de blocos complexos.
* Realiza uma *varredura de segurança estática leve* e escreve as descobertas em `vuln_report.json` com níveis de severidade (informativo → crítico).

#### Instalação
```bash
git clone https://github.com/In3tinct/Androidmeda
cd Androidmeda
pip3 install -r requirements.txt
```
#### Preparando as entradas
1. Decompile o APK alvo com `jadx` (ou qualquer outro decompilador) e mantenha apenas o diretório *source* que contém os arquivos `.java`:
```bash
jadx -d input_dir/ target.apk
```
2. (Opcional) Reduza `input_dir/` para que contenha apenas os pacotes de aplicação que você deseja analisar – isso acelera significativamente o processamento e os custos de LLM.

#### Exemplos de uso

Provedor remoto (Gemini-1.5-flash):
```bash
export OPENAI_API_KEY=<your_key>
python3 androidmeda.py \
--llm_provider google \
--llm_model gemini-1.5-flash \
--source_dir input_dir/ \
--output_dir out/ \
--save_code true
```
Offline (local `ollama` backend com llama3.2):
```bash
python3 androidmeda.py \
--llm_provider ollama \
--llm_model llama3.2 \
--source_dir input_dir/ \
--output_dir out/ \
--save_code true
```
#### Saída
* `out/vuln_report.json` – Array JSON com `file`, `line`, `issue`, `severity`.
* Uma árvore de pacotes espelhada com **arquivos `.java` decompostos** (somente se `--save_code true`).

#### Dicas e solução de problemas
* **Classe ignorada** ⇒ geralmente causada por um método não analisável; isole o pacote ou atualize a regex do parser.
* **Tempo de execução lento / alto uso de tokens** ⇒ aponte `--source_dir` para pacotes de app *específicos* em vez de todo o decompile.
* Sempre *revise manualmente* o relatório de vulnerabilidade – alucinações de LLM podem levar a falsos positivos / negativos.

#### Valor prático – Estudo de caso do malware Crocodilus
Alimentar uma amostra fortemente ofuscada do trojan bancário *Crocodilus* de 2025 através do Androidmeda reduziu o tempo de análise de *horas* para *minutos*: a ferramenta recuperou a semântica do grafo de chamadas, revelou chamadas para APIs de acessibilidade e URLs C2 codificadas, e produziu um relatório conciso que poderia ser importado para os painéis dos analistas.

---

## Referências e Leitura Adicional

- [https://maddiestone.github.io/AndroidAppRE/obfuscation.html](https://maddiestone.github.io/AndroidAppRE/obfuscation.html)
- BlackHat USA 2018: “Unpacking the Packed Unpacker: Reverse Engineering an Android Anti-Analysis Library” [[video](https://www.youtube.com/watch?v=s0Tqi7fuOSU)]
- Esta palestra aborda a engenharia reversa de uma das bibliotecas nativas anti-análise mais complexas que já vi usadas por um aplicativo Android. Ela cobre principalmente técnicas de ofuscação em código nativo.
- REcon 2019: “The Path to the Payload: Android Edition” [[video](https://recon.cx/media-archive/2019/Session.005.Maddie_Stone.The_path_to_the_payload_Android_Edition-J3ZnNl2GYjEfa.mp4)]
- Esta palestra discute uma série de técnicas de ofuscação, exclusivamente em código Java, que um botnet Android estava usando para esconder seu comportamento.
- Deobfuscating Android Apps with Androidmeda (post de blog) – [mobile-hacker.com](https://www.mobile-hacker.com/2025/07/22/deobfuscating-android-apps-with-androidmeda-a-smarter-way-to-read-obfuscated-code/)
- Código-fonte do Androidmeda – [https://github.com/In3tinct/Androidmeda](https://github.com/In3tinct/Androidmeda)

- [https://maddiestone.github.io/AndroidAppRE/obfuscation.html](https://maddiestone.github.io/AndroidAppRE/obfuscation.html)
- BlackHat USA 2018: “Unpacking the Packed Unpacker: Reverse Engineering an Android Anti-Analysis Library” \[[video](https://www.youtube.com/watch?v=s0Tqi7fuOSU)]
- Esta palestra aborda a engenharia reversa de uma das bibliotecas nativas anti-análise mais complexas que já vi usadas por um aplicativo Android. Ela cobre principalmente técnicas de ofuscação em código nativo.
- REcon 2019: “The Path to the Payload: Android Edition” \[[video](https://recon.cx/media-archive/2019/Session.005.Maddie_Stone.The_path_to_the_payload_Android_Edition-J3ZnNl2GYjEfa.mp4)]
- Esta palestra discute uma série de técnicas de ofuscação, exclusivamente em código Java, que um botnet Android estava usando para esconder seu comportamento.

{{#include ../../banners/hacktricks-training.md}}
