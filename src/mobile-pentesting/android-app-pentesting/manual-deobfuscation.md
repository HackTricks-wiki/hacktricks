# 手动去混淆技术

{{#include ../../banners/hacktricks-training.md}}

## 手动 **de-obfuscation** 技术

在**软件安全**领域，将被混淆的代码变得可理解的过程，称为 **de-obfuscation**，至关重要。本指南深入探讨了用于 de-obfuscation 的多种策略，重点是静态分析技术和识别混淆模式。此外，它还提供了一个实践练习，并为希望深入研究更高级主题的人推荐了进一步的资源。

### **静态 de-obfuscation 策略**

在处理 **obfuscated code** 时，可根据混淆的性质采用多种策略：

- **DEX bytecode (Java)**: 一种有效的方法是识别应用的 de-obfuscation 方法，然后在一个 Java 文件中复现这些方法。执行该文件以对目标元素进行反混淆。
- **Java and Native Code**: 另一种方法是将 de-obfuscation 算法翻译成像 Python 这样的脚本语言。该策略强调主要目标不是完全理解算法，而是有效执行它。

### **识别混淆**

识别被混淆的代码是 de-obfuscation 过程的第一步。关键指标包括：

- **Java 和 Android 中字符串的缺失或混乱**，这可能表明存在 string obfuscation。
- assets 目录中出现二进制文件或对 `DexClassLoader` 的调用，暗示 code unpacking 和 dynamic loading。
- 使用 native 库并伴有无法识别的 JNI 函数，表明 native 方法可能被混淆。

## de-obfuscation 中的 **动态分析**

通过在受控环境中执行代码，动态分析 **可以观察被混淆代码的实时行为**。该方法在揭示复杂混淆模式的内部工作原理方面尤其有效，这些模式旨在隐藏代码的真实意图。

### **动态分析的应用**

- **Runtime Decryption**: 许多混淆技术会加密字符串或代码段，只有在运行时才会被解密。通过动态分析，可以在解密时捕获这些加密元素，从而揭示它们的真实形式。
- **Identifying Obfuscation Techniques**: 通过监控应用的行为，动态分析可以帮助识别正在使用的特定混淆技术，例如 code virtualization、packers 或 dynamic code generation。
- **Uncovering Hidden Functionality**: 被混淆的代码可能包含静态分析无法识别的隐藏功能。动态分析允许观察所有代码路径（包括有条件执行的路径），以发现这些隐藏功能。

### Automated De-obfuscation with LLMs (Androidmeda)

尽管前面的章节侧重于完全手工的策略，但到了 2025 年，出现了一类由 *Large-Language-Model (LLM) powered* 驱动的新工具，能够自动化大部分繁琐的重命名和控制流恢复工作。
一个代表性项目是 **[Androidmeda](https://github.com/In3tinct/Androidmeda)** —— 一个 Python 工具，接受 *decompiled* 的 Java 源码（例如由 `jadx` 生成），并输出大幅清理、带注释且带安全注释的代码版本。

#### Key capabilities
* 将由 ProGuard / DexGuard / DashO / Allatori / … 生成的无意义标识符重命名为 *semantic* 名称。
* 检测并重构 **control-flow flattening**，将不透明的 switch-case 状态机替换为普通的循环 / if-else 构造。
* 在可能的情况下解密常见的 **string encryption** 模式。
* 注入 **inline comments**，解释复杂代码块的目的。
* 执行 *lightweight static security scan*，并将发现写入 `vuln_report.json`，并带有严重性等级（informational → critical）。

#### 安装
```bash
git clone https://github.com/In3tinct/Androidmeda
cd Androidmeda
pip3 install -r requirements.txt
```
#### 准备输入
1. 使用 `jadx`（或任何其他反编译器）反编译目标 APK，并仅保留包含 `.java` 文件的 *source* 目录：
```bash
jadx -d input_dir/ target.apk
```
2.（可选）精简 `input_dir/`，使其只包含你要分析的应用包 —— 这会大幅加快处理速度并降低 LLM 成本。

#### 使用示例

远程提供者 (Gemini-1.5-flash):
```bash
export OPENAI_API_KEY=<your_key>
python3 androidmeda.py \
--llm_provider google \
--llm_model gemini-1.5-flash \
--source_dir input_dir/ \
--output_dir out/ \
--save_code true
```
离线 (本地 `ollama` 后端，使用 llama3.2):
```bash
python3 androidmeda.py \
--llm_provider ollama \
--llm_model llama3.2 \
--source_dir input_dir/ \
--output_dir out/ \
--save_code true
```
#### 输出
* `out/vuln_report.json` – JSON 数组，包含 `file`、`line`、`issue`、`severity`。
* 一个镜像的包树，包含 **反混淆后的 `.java` 文件**（仅当 `--save_code true` 时）。

#### 提示与故障排除
* **Skipped class** ⇒ 通常由无法解析的方法引起；隔离该包或更新解析器的正则表达式（parser regex）。
* **Slow run-time / high token usage** ⇒ 将 `--source_dir` 指向*特定*的应用包，而不是整个反编译目录。
* 始终*手动审查*漏洞报告 — LLM 幻觉可能导致误报/漏报。

#### 实际价值 – Crocodilus malware 案例研究
将一份来自 2025 年 *Crocodilus* banking trojan 的高度混淆样本通过 Androidmeda 处理，将分析时间从 *hours* 缩短到 *minutes*：该工具恢复了 call-graph semantics，揭示了对 accessibility APIs 的调用和硬编码的 C2 URLs，并生成了可导入到分析师仪表板的简明报告。

---

### 使用 DaliVM 进行针对性的 Dalvik 字符串解密

**DaliVM** 是一个 Python Dalvik 字节码模拟器，旨在静态恢复仅在运行时可得的值（尤其是解密后的字符串），无需启动 Android。它通过模拟 Dalvik opcodes 并 mock Android/Java APIs，在 APK 内执行一个*特定*方法。

**工作流程**
1. **选择目标方法**，按 Dalvik 签名（`Lpkg/Class;->method(Args)Ret`）。示例：`Lutil/Crypto;->decrypt(Ljava/lang/String;)Ljava/lang/String;`、`LMyClass;->compute(II)I`。
2. **枚举调用点**，跨 **multi-DEX** (`classes*.dex`) 并在需要时通过向后数据流追踪、向前查找和部分执行来**重构参数**。
3. **在 Dalvik VM 内模拟该方法**（覆盖 120+ opcodes，涵盖 const/array/control/field/invoke，处理通过 `<clinit>` 的类初始化）并**收集返回值**（例如解密字符串）。
4. **绕过运行时依赖**，使用内置 mocks 针对常见 Android APIs（Context, PackageManager, Signature, reflection, system services）以及为 Java stdlib（String/StringBuilder/Integer/Math/Arrays/List/Iterator）提供的 hooks。
5. 如果执行停滞，**启用 opcode 级跟踪** 以查看 PC/寄存器 变化并扩展 opcode 处理器。

**CLI 使用**
```bash
# Emulate a decryptor and dump all returns
python emulate.py app.apk "Lcom/example/Decryptor;->decrypt"

# Verbose, debug trace, and limit outputs
python emulate.py app.apk "Lcom/example/Decryptor;->decrypt" -v --debug --limit 10
```
Outputs 是每次调用收集的返回值；在恶意软件分流（triage）或高度混淆的应用中批量提取字符串/配置时非常有用。

## 参考与扩展阅读

- [DaliVM: Python Dalvik emulator for static string decryption](https://github.com/fatalSec/DaliVM)
- [https://maddiestone.github.io/AndroidAppRE/obfuscation.html](https://maddiestone.github.io/AndroidAppRE/obfuscation.html)
- BlackHat USA 2018: “Unpacking the Packed Unpacker: Reverse Engineering an Android Anti-Analysis Library” [[video](https://www.youtube.com/watch?v=s0Tqi7fuOSU)]
- 本次演讲讲解了对我见过的、被 Android 应用使用的最复杂的反分析本地库之一进行逆向工程。主要涵盖本地（native）代码中的混淆技术。
- REcon 2019: “The Path to the Payload: Android Edition” [[video](https://recon.cx/media-archive/2019/Session.005.Maddie_Stone.The_path_to_the_payload_Android_Edition-J3ZnNl2GYjEfa.mp4)]
- 本次演讲讨论了一系列仅在 Java 代码中使用的混淆技术，某个 Android botnet 使用这些技术来隐藏其行为。
- 使用 Androidmeda 对 Android 应用进行去混淆（博客文章） – [mobile-hacker.com](https://www.mobile-hacker.com/2025/07/22/deobfuscating-android-apps-with-androidmeda-a-smarter-way-to-read-obfuscated-code/)
- Androidmeda 源代码 – [https://github.com/In3tinct/Androidmeda](https://github.com/In3tinct/Androidmeda)

{{#include ../../banners/hacktricks-training.md}}
