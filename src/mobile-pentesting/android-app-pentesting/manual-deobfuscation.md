# 手動による De-obfuscation Techniques

{{#include ../../banners/hacktricks-training.md}}

## 手動による **De-obfuscation Techniques**

ソフトウェアセキュリティの領域では、難読化されたコードを理解可能にするプロセス、つまり **de-obfuscation** は重要です。本ガイドでは静的解析のテクニックや難読化パターンの認識に焦点を当てたさまざまな手法を解説します。さらに、実践のための演習と、より高度なトピックを探求したい人のための追加リソースも紹介します。

### **Strategies for Static De-obfuscation**

難読化コードに対処する際は、難読化の性質に応じていくつかの戦略を適用できます:

- **DEX bytecode (Java)**: 効果的なアプローチの一つは、アプリの de-obfuscation メソッドを特定し、それらを Java ファイルに複製することです。そのファイルを実行して対象要素の難読化を逆転させます。
- **Java and Native Code**: 別の方法は、de-obfuscation アルゴリズムを Python のようなスクリプト言語に翻訳することです。この戦略は、主目的がアルゴリズムを完全に理解することではなく、実際に動かして処理を行うことにあることを強調します。

### Identifying Obfuscation

難読化の識別は de-obfuscation プロセスの第一歩です。主な指標は次のとおりです:

- Java や Android での **文字列の欠如や文字化け** は、string obfuscation を示唆することがあります。
- assets ディレクトリにバイナリファイルが存在する、または `DexClassLoader` への呼び出しがある場合は、コードの unpacking や動的読み込みの可能性を示します。
- ネイティブライブラリと判別できない `JNI` 関数が混在している場合、ネイティブメソッドの難読化が行われている可能性があります。

## **Dynamic Analysis in De-obfuscation**

制御された環境でコードを実行することで、動的解析は難読化コードがリアルタイムでどのように振る舞うかを観察できます。この手法は、コードの真の目的を隠すために設計された複雑な難読化パターンの内部動作を明らかにするのに特に有効です。

### **Applications of Dynamic Analysis**

- **Runtime Decryption**: 多くの難読化手法は文字列やコードセグメントを暗号化し、実行時にのみ復号します。動的解析を通じて、復号が行われる瞬間にこれらの暗号化要素を捕捉し、真の内容を明らかにできます。
- **Identifying Obfuscation Techniques**: アプリの振る舞いを監視することで、code virtualization、packers、dynamic code generation など、特定の難読化手法を特定できます。
- **Uncovering Hidden Functionality**: 難読化コードには静的解析だけでは明らかにならない隠れた機能が含まれていることがあります。動的解析は条件付きで実行されるパスを含むすべてのコードパスを観察できるため、そうした隠れた機能を発見できます。

### Automated De-obfuscation with LLMs (Androidmeda)

前節までは完全に手動の戦略に焦点を当てましたが、2025年には煩雑なリネーミングや制御フロー復元作業の大部分を自動化できる LLM を活用した新しいクラスのツールが登場しました。
その代表例が **[Androidmeda](https://github.com/In3tinct/Androidmeda)** です。これは decompiled な Java ソース（例: `jadx` が生成したもの）を入力として受け取り、きれいに整理され、コメントやセキュリティ注釈が付いたコードを出力する Python ユーティリティです。

#### Key capabilities
* ProGuard / DexGuard / DashO / Allatori / … によって生成された意味のない識別子を *意味のある* 名前にリネームします。
* **control-flow flattening** を検出して再構成し、不透明な switch-case 状態機を通常のループ / if-else 構造に置き換えます。
* 可能な場合、一般的な **string encryption** パターンを復号します。
* 複雑なブロックの目的を説明する **inline comments** を挿入します。
* 軽量な静的セキュリティスキャンを実行し、所見を `vuln_report.json` に重大度レベル（informational → critical）で書き出します。

#### インストール
```bash
git clone https://github.com/In3tinct/Androidmeda
cd Androidmeda
pip3 install -r requirements.txt
```
#### 入力の準備
1. ターゲットAPKを `jadx`（または他のデコンパイラ）でデコンパイルし、`.java` ファイルを含む *source* ディレクトリだけを保持してください:
```bash
jadx -d input_dir/ target.apk
```
2. (オプション) `input_dir/` を解析したいアプリケーションパッケージのみを含むように整理してください — これにより処理時間と LLM コストが大幅に短縮されます。

#### 使用例

Remote provider (Gemini-1.5-flash):
```bash
export OPENAI_API_KEY=<your_key>
python3 androidmeda.py \
--llm_provider google \
--llm_model gemini-1.5-flash \
--source_dir input_dir/ \
--output_dir out/ \
--save_code true
```
オフライン（ローカル `ollama` backend、`llama3.2` 使用）：
```bash
python3 androidmeda.py \
--llm_provider ollama \
--llm_model llama3.2 \
--source_dir input_dir/ \
--output_dir out/ \
--save_code true
```
#### 出力
* `out/vuln_report.json` – `file`, `line`, `issue`, `severity` を含む JSON 配列。
* ミラー化されたパッケージツリー（**de-obfuscated `.java` files**、`--save_code true` の場合のみ）。

#### ヒント＆トラブルシューティング
* **Skipped class** ⇒ 通常は解析不能なメソッドが原因です。パッケージを切り分けるか、parser の正規表現を更新してください。
* **Slow run-time / high token usage** ⇒ 全 decompile を指定するのではなく、`--source_dir` を特定のアプリパッケージに向けてください。
* 常に *manually review* で脆弱性レポートを確認してください — LLM のハルシネーションが誤検知や見逃しを引き起こす可能性があります。

#### Practical value – Crocodilus malware case study
2025 年の *Crocodilus* banking trojan からの高度に難読化されたサンプルを Androidmeda に通すことで、解析時間が *hours* から *minutes* に短縮されました。ツールはコールグラフのセマンティクスを復元し、accessibility APIs への呼び出しやハードコーディングされた C2 URL を明らかにし、アナリストのダッシュボードにインポートできる簡潔なレポートを生成しました。

---

### DaliVM を使った Dalvik 文字列のターゲット復号

**DaliVM** は、Android を起動せずにランタイムのみで決定される値（特に復号済み文字列）を静的に復元することを目的とした Python の Dalvik バイトコードエミュレータです。APK 内の *specific* メソッドを、Dalvik opcode をエミュレートし、Android/Java API をモックすることで実行します。

**ワークフロー**
1. **ターゲットメソッドを選択** — Dalvik シグネチャ (`Lpkg/Class;->method(Args)Ret`) で指定します。例: `Lutil/Crypto;->decrypt(Ljava/lang/String;)Ljava/lang/String;`, `LMyClass;->compute(II)I`。
2. **マルチDEX 全体でコールサイトを列挙**（`classes*.dex`）し、逆方向データフロー追跡、順方向ルックアップ、必要に応じた部分実行で引数を再構築します。
3. **Dalvik VM 内でメソッドをエミュレート**（const/array/control/field/invoke を含む 120+ の opcode をカバーし、`<clinit>` によるクラス初期化を処理）し、**戻り値を収集**（例: 復号された文字列）。
4. 組み込みのモック（Context、PackageManager、Signature、reflection、system services などの一般的な Android API）と Java stdlib（String/StringBuilder/Integer/Math/Arrays/List/Iterator）用のフックを使って、**ランタイム依存関係を回避**します。
5. 実行が停滞する場合は、PC/レジスタの変化を確認するために **opcode-level tracing** を有効にし、opcode ハンドラを拡張してください。

**CLI usage**
```bash
# Emulate a decryptor and dump all returns
python emulate.py app.apk "Lcom/example/Decryptor;->decrypt"

# Verbose, debug trace, and limit outputs
python emulate.py app.apk "Lcom/example/Decryptor;->decrypt" -v --debug --limit 10
```
Outputsは呼び出しごとに収集される戻り値です。マルウェアのトリアージや、難読化の激しいアプリにおける大量の文字列／設定の抽出に有用です。

## 参考資料と追加リソース

- [DaliVM: Python Dalvik emulator for static string decryption](https://github.com/fatalSec/DaliVM)
- [https://maddiestone.github.io/AndroidAppRE/obfuscation.html](https://maddiestone.github.io/AndroidAppRE/obfuscation.html)
- BlackHat USA 2018: “Unpacking the Packed Unpacker: Reverse Engineering an Android Anti-Analysis Library” [[video](https://www.youtube.com/watch?v=s0Tqi7fuOSU)]
- この発表では、私がAndroidアプリで見た中でも最も複雑なアンチアナリシス系ネイティブライブラリの1つのリバースエンジニアリングを解説しています。主にネイティブコードにおける難読化技術を扱います。
- REcon 2019: “The Path to the Payload: Android Edition” [[video](https://recon.cx/media-archive/2019/Session.005.Maddie_Stone.The_path_to_the_payload_Android_Edition-J3ZnNl2GYjEfa.mp4)]
- この発表では、Androidボットネットが挙動を隠すために使用していた、Javaコードのみで行われる一連の難読化技術について説明しています。
- Deobfuscating Android Apps with Androidmeda (blog post) – [mobile-hacker.com](https://www.mobile-hacker.com/2025/07/22/deobfuscating-android-apps-with-androidmeda-a-smarter-way-to-read-obfuscated-code/)
- Androidmeda source code – [https://github.com/In3tinct/Androidmeda](https://github.com/In3tinct/Androidmeda)

{{#include ../../banners/hacktricks-training.md}}
