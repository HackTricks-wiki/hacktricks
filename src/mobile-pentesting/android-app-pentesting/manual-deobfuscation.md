# Manuelle De-Obfuskationstechniken

{{#include ../../banners/hacktricks-training.md}}

## Manuelle **De-Obfuskationstechniken**

Im Bereich der **Software-Sicherheit** ist der Prozess, verschleierten Code verständlich zu machen, bekannt als **De-Obfuskation**, von entscheidender Bedeutung. Dieser Leitfaden behandelt verschiedene Strategien zur De-Obfuskation, mit Schwerpunkt auf statischen Analyse-Techniken und der Erkennung von Obfuskationsmustern. Zusätzlich wird eine Übung zur praktischen Anwendung eingeführt und weiterführende Ressourcen für diejenigen vorgeschlagen, die sich mit fortgeschritteneren Themen beschäftigen möchten.

### **Strategien für statische De-Obfuskation**

Beim Umgang mit **obfuskiertem Code** können je nach Art der Obfuskation mehrere Strategien angewendet werden:

- **DEX bytecode (Java)**: Ein effektiver Ansatz besteht darin, die De-Obfuskationsmethoden der Anwendung zu identifizieren und diese Methoden dann in einer Java-Datei nachzubilden. Diese Datei wird ausgeführt, um die Obfuskation an den Zielobjekten rückgängig zu machen.
- **Java and Native Code**: Eine andere Methode ist, den De-Obfuskationsalgorithmus in eine Skriptsprache wie Python zu übersetzen. Diese Strategie zeigt, dass das primäre Ziel nicht darin besteht, den Algorithmus vollständig zu verstehen, sondern ihn effektiv auszuführen.

### **Erkennung von Obfuskation**

Die Erkennung von obfuskiertem Code ist der erste Schritt im De-Obfuskationsprozess. Wichtige Indikatoren sind:

- Das **Fehlen oder die Verschleierung von Strings** in Java und Android, was auf String-Obfuskation hindeuten kann.
- Das **Vorhandensein von Binärdateien** im assets-Verzeichnis oder Aufrufe von `DexClassLoader`, die auf Code-Unpacking und dynamisches Laden hinweisen.
- Die Verwendung von **nativen Libraries zusammen mit nicht identifizierbaren JNI-Funktionen**, was auf mögliche Obfuskation nativer Methoden hinweist.

## **Dynamische Analyse bei der De-Obfuskation**

Durch Ausführen des Codes in einer kontrollierten Umgebung ermöglicht die dynamische Analyse die Beobachtung, wie sich der obfuskierte Code in Echtzeit verhält. Diese Methode ist besonders effektiv, um die inneren Abläufe komplexer Obfuskationsmuster aufzudecken, die darauf ausgelegt sind, die wahre Absicht des Codes zu verbergen.

### **Anwendungen der dynamischen Analyse**

- **Runtime Decryption**: Viele Obfuskationstechniken verschlüsseln Strings oder Codeabschnitte, die erst zur Laufzeit entschlüsselt werden. Durch dynamische Analyse können diese verschlüsselten Elemente im Moment der Entschlüsselung erfasst werden, wodurch ihre tatsächliche Form sichtbar wird.
- **Identifying Obfuscation Techniques**: Durch Überwachen des Verhaltens der Anwendung kann die dynamische Analyse helfen, spezifische eingesetzte Obfuskationstechniken zu identifizieren, wie z. B. code virtualization, packers oder dynamic code generation.
- **Uncovering Hidden Functionality**: Obfuskierter Code kann verborgene Funktionalitäten enthalten, die durch statische Analyse allein nicht erkennbar sind. Dynamische Analyse erlaubt die Beobachtung aller Codepfade, einschließlich bedingt ausgeführter Pfade, um solche versteckten Funktionalitäten aufzudecken.

### Automated De-obfuscation with LLMs (Androidmeda)

Während die vorherigen Abschnitte vollständig manuelle Strategien behandeln, ist 2025 eine neue Klasse von *Large-Language-Model (LLM) powered* Tools aufgetaucht, die den Großteil der mühsamen Umbenennungs- und Control-Flow-Recovery-Arbeiten automatisieren können. Ein repräsentatives Projekt ist **[Androidmeda](https://github.com/In3tinct/Androidmeda)** – ein Python-Utility, das *dekompilierte* Java-Quellen (z. B. erzeugt von `jadx`) annimmt und eine stark bereinigte, kommentierte und sicherheitsannotierte Version des Codes zurückgibt.

#### Key capabilities
* Benennt bedeutungslose Bezeichner, die von ProGuard / DexGuard / DashO / Allatori / … erzeugt wurden, in *semantische* Namen um.
* Erkennt und restrukturiert **control-flow flattening**, ersetzt undurchsichtige Switch-Case-Zustandsmaschinen durch normale Schleifen / if-else-Konstrukte.
* Entschlüsselt gängige **string encryption**-Muster, wenn möglich.
* Fügt **inline comments** ein, die den Zweck komplexer Blöcke erklären.
* Führt einen *leichtgewichtigen statischen Security-Scan* durch und schreibt die Ergebnisse in `vuln_report.json` mit Schweregraden (informational → critical).

#### Installation
```bash
git clone https://github.com/In3tinct/Androidmeda
cd Androidmeda
pip3 install -r requirements.txt
```
#### Vorbereitung der Eingaben
1. Dekompilieren Sie die Ziel-APK mit `jadx` (oder einem anderen Decompiler) und behalten Sie nur das *source*-Verzeichnis, das die `.java`-Dateien enthält:
```bash
jadx -d input_dir/ target.apk
```
2. (Optional) Kürzen Sie `input_dir/`, sodass es nur die Anwendungspakete enthält, die Sie analysieren möchten – das beschleunigt die Verarbeitung erheblich und senkt die LLM-Kosten.

#### Verwendungsbeispiele

Remote-Anbieter (Gemini-1.5-flash):
```bash
export OPENAI_API_KEY=<your_key>
python3 androidmeda.py \
--llm_provider google \
--llm_model gemini-1.5-flash \
--source_dir input_dir/ \
--output_dir out/ \
--save_code true
```
Offline (lokales `ollama` Backend mit llama3.2):
```bash
python3 androidmeda.py \
--llm_provider ollama \
--llm_model llama3.2 \
--source_dir input_dir/ \
--output_dir out/ \
--save_code true
```
#### Ausgabe
* `out/vuln_report.json` – JSON-Array mit `file`, `line`, `issue`, `severity`.
* A mirrored package tree with **de-obfuscated `.java` files** (only if `--save_code true`).

#### Tipps & Fehlerbehebung
* **Skipped class** ⇒ wird normalerweise durch eine nicht parsbare Methode verursacht; isolieren Sie das Package oder aktualisieren Sie die Parser-Regex.
* **Langsame Laufzeit / hoher Tokenverbrauch** ⇒ setzen Sie `--source_dir` auf *spezifische* App-Pakete anstatt auf das gesamte Decompile.
* Überprüfen Sie den Vulnerability-Report immer *manuell* – LLM-Halluzinationen können zu False Positives / Negatives führen.

#### Praktischer Wert – Crocodilus Malware-Fallstudie
Das Einspeisen eines stark obfuskierten Samples des 2025 *Crocodilus* banking trojan durch Androidmeda reduzierte die Analysezeit von *Stunden* auf *Minuten*: das Tool stellte call-graph-Semantik wieder her, offenbarte Aufrufe zu accessibility APIs und hartkodierte C2-URLs und erzeugte einen prägnanten Report, der in Analysten-Dashboards importiert werden konnte.

---

### Gezielte Dalvik-String-Entschlüsselung mit DaliVM

**DaliVM** ist ein Python Dalvik-Bytecode-Emulator, der darauf abzielt, zur Laufzeit verfügbare Werte (insbesondere entschlüsselte Strings) statisch wiederherzustellen, ohne Android hochzufahren. Er führt eine *konkrete* Methode innerhalb einer APK aus, indem er Dalvik-Opcodes emuliert und Android/Java-APIs simuliert.

**Ablauf**
1. **Wählen Sie die Zielmethode** per Dalvik-Signatur (`Lpkg/Class;->method(Args)Ret`). Beispiele: `Lutil/Crypto;->decrypt(Ljava/lang/String;)Ljava/lang/String;`, `LMyClass;->compute(II)I`.
2. **Durchsuchen Sie Aufrufstellen** über **multi-DEX** (`classes*.dex`) und **rekonstruieren Sie Argumente** mittels rückwärtsgerichteter Datenfluss-Analyse, Vorwärts-Suche und teilweiser Ausführung falls erforderlich.
3. **Emulieren Sie die Methode** innerhalb der Dalvik-VM (unterstützt 120+ opcodes für const/array/control/field/invoke, behandelt Klasseninitialisierung via `<clinit>`) und **sammeln Sie Rückgabewerte** (z. B. entschlüsselte Strings).
4. **Umgehen Sie Laufzeitabhängigkeiten** mit eingebauten Mocks für gängige Android-APIs (Context, PackageManager, Signature, reflection, system services) und Hooks für die Java-Stdlib (String/StringBuilder/Integer/Math/Arrays/List/Iterator).
5. Wenn die Ausführung stockt, **aktivieren Sie Opcode-Level-Tracing**, um PC/Register-Änderungen zu sehen und Opcode-Handler zu erweitern.

**CLI usage**
```bash
# Emulate a decryptor and dump all returns
python emulate.py app.apk "Lcom/example/Decryptor;->decrypt"

# Verbose, debug trace, and limit outputs
python emulate.py app.apk "Lcom/example/Decryptor;->decrypt" -v --debug --limit 10
```
Outputs sind die gesammelten Rückgabewerte pro Aufruf; nützlich für die massenhafte Extraktion von Strings/Konfigurationen während der Malware-Triage oder bei stark obfuskierten Apps.

## Referenzen und weiterführende Literatur

- [DaliVM: Python Dalvik emulator for static string decryption](https://github.com/fatalSec/DaliVM)
- [https://maddiestone.github.io/AndroidAppRE/obfuscation.html](https://maddiestone.github.io/AndroidAppRE/obfuscation.html)
- BlackHat USA 2018: “Unpacking the Packed Unpacker: Reverse Engineering an Android Anti-Analysis Library” [[video](https://www.youtube.com/watch?v=s0Tqi7fuOSU)]
- Dieser Vortrag behandelt das Reverse Engineering einer der komplexesten Anti-Analysis-Native-Bibliotheken, die ich bei Android-Anwendungen gesehen habe. Er geht hauptsächlich auf Obfuskationstechniken im nativen Code ein.
- REcon 2019: “The Path to the Payload: Android Edition” [[video](https://recon.cx/media-archive/2019/Session.005.Maddie_Stone.The_path_to_the_payload_Android_Edition-J3ZnNl2GYjEfa.mp4)]
- Dieser Vortrag bespricht eine Reihe von Obfuskationstechniken, ausschließlich im Java-Code, die ein Android-Botnet verwendete, um sein Verhalten zu verbergen.
- Deobfuscating Android Apps with Androidmeda (blog post) – [mobile-hacker.com](https://www.mobile-hacker.com/2025/07/22/deobfuscating-android-apps-with-androidmeda-a-smarter-way-to-read-obfuscated-code/)
- Androidmeda source code – [https://github.com/In3tinct/Androidmeda](https://github.com/In3tinct/Androidmeda)

{{#include ../../banners/hacktricks-training.md}}
