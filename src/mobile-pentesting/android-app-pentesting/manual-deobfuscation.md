# Manuel De-obfuscation Teknikleri

{{#include ../../banners/hacktricks-training.md}}

## Manuel **De-obfuscation Teknikleri**

Yazılım güvenliği alanında, gizlenmiş kodu anlaşılır hale getirme süreci olan **de-obfuscation**, hayati öneme sahiptir. Bu rehber, statik analiz tekniklerine ve obfuscation kalıplarının tanınmasına odaklanarak de-obfuscation için çeşitli stratejileri inceler. Ayrıca pratik uygulama için bir alıştırma sunar ve daha ileri konuları keşfetmek isteyenler için ek kaynaklar önerir.

### **Statik De-obfuscation için Stratejiler**

Obfuscated kodla uğraşırken, obfuscation'ın doğasına bağlı olarak birkaç strateji uygulanabilir:

- **DEX bytecode (Java)**: Etkili yaklaşımlardan biri, uygulamanın de-obfuscation yöntemlerini tespit edip bu yöntemleri bir Java dosyasında yeniden uygulamaktır. Bu dosya çalıştırılarak hedeflenen öğeler üzerindeki obfuscation tersine çevrilir.
- **Java and Native Code**: Diğer bir yöntem, de-obfuscation algoritmasını Python gibi bir scripting diline çevirmektir. Bu strateji, asıl amacın algoritmayı tamamen anlamak değil, onu etkili şekilde çalıştırmak olduğunu vurgular.

### **Obfuscation'ı Tanımlama**

Obfuscated kodu tanımak, de-obfuscation sürecinin ilk adımıdır. Önemli göstergeler şunlardır:

- Java ve Android'de **strings'in yokluğu veya karışık halde olması**, string obfuscation olabileceğini düşündürebilir.
- assets dizininde **binary dosyaların varlığı** veya `DexClassLoader` çağrıları, code unpacking ve dynamic loading'e işaret edebilir.
- **Native kütüphanelerin ve tanımlanamayan JNI fonksiyonlarının** birlikte kullanımı, native metodların obfuscation'ını gösterebilir.

## **De-obfuscation'da Dinamik Analiz**

Kodu kontrollü bir ortamda çalıştırarak yapılan dinamik analiz, obfuscated kodun gerçek zamanlı davranışını gözlemleme imkanı sağlar. Bu yöntem, kodun gerçek niyetini gizlemek üzere tasarlanmış karmaşık obfuscation kalıplarının iç işleyişini ortaya çıkarmada özellikle etkilidir.

### **Dinamik Analizin Uygulamaları**

- **Runtime Decryption**: Birçok obfuscation tekniği, yalnızca runtime'da çözülen string veya kod parçalarını şifreler. Dinamik analiz ile bu şifrelenmiş öğeler decryption anında yakalanarak gerçek halleri açığa çıkarılabilir.
- **Identifying Obfuscation Techniques**: Uygulamanın davranışı izlenerek, code virtualization, packers veya dynamic code generation gibi kullanılan spesifik obfuscation teknikleri tespit edilebilir.
- **Uncovering Hidden Functionality**: Obfuscated kod, statik analizle görülmeyen gizli fonksiyonlar içerebilir. Dinamik analiz, koşullu olarak çalıştırılanlar da dahil tüm code path'leri gözlemlemeye izin vererek bu tür gizli işlevleri ortaya çıkarır.

### Automated De-obfuscation with LLMs (Androidmeda)

Önceki bölümler tamamen manuel stratejilere odaklansa da, 2025'te adeta çoğu sıkıcı yeniden adlandırma ve control-flow recovery işini otomatikleştirebilen *Large-Language-Model (LLM) powered* araçlar ortaya çıktı. Bunlardan temsilî bir proje **[Androidmeda](https://github.com/In3tinct/Androidmeda)** — decompiled Java kaynaklarını (ör. `jadx` tarafından üretilen) alan ve kodun büyük ölçüde temizlenmiş, yorumlanmış ve güvenlik-annotated bir versiyonunu döndüren bir Python yardımcı aracıdır.

#### Temel yetenekler
* ProGuard / DexGuard / DashO / Allatori / … tarafından üretilen anlamsız identifier'ları semantik isimlere yeniden adlandırır.
* **control-flow flattening** tespit eder ve yeniden yapılandırır; opak switch-case state machine'lerini normal döngüler / if-else yapılarıyla değiştirir.
* Mümkün olduğunda yaygın **string encryption** kalıplarını decrypt eder.
* Karmaşık blokların amacını açıklayan **inline comments** ekler.
* Hafif bir *static security scan* gerçekleştirir ve bulguları bilgilendirme → kritik seviyeleriyle birlikte `vuln_report.json` içine yazar.

#### Kurulum
```bash
git clone https://github.com/In3tinct/Androidmeda
cd Androidmeda
pip3 install -r requirements.txt
```
#### Girdileri hazırlama
1. Hedef APK'yı `jadx` (veya başka bir decompiler) ile decompile edin ve sadece `.java` dosyalarını içeren *source* dizinini saklayın:
```bash
jadx -d input_dir/ target.apk
```
2. (Opsiyonel) `input_dir/`'i, sadece analiz etmek istediğiniz uygulama paketlerini içerecek şekilde kırpın — bu, işlem süresini kısaltır ve LLM maliyetlerini büyük ölçüde azaltır.

#### Kullanım örnekleri

Uzak sağlayıcı (Gemini-1.5-flash):
```bash
export OPENAI_API_KEY=<your_key>
python3 androidmeda.py \
--llm_provider google \
--llm_model gemini-1.5-flash \
--source_dir input_dir/ \
--output_dir out/ \
--save_code true
```
Çevrimdışı (yerel `ollama` backend, llama3.2 ile):
```bash
python3 androidmeda.py \
--llm_provider ollama \
--llm_model llama3.2 \
--source_dir input_dir/ \
--output_dir out/ \
--save_code true
```
#### Output
* `out/vuln_report.json` – `file`, `line`, `issue`, `severity` içeren JSON dizisi.
* A mirrored package tree with **de-obfuscated `.java` files** (only if `--save_code true`).

#### Tips & troubleshooting
* **Skipped class** ⇒ genellikle parse edilemeyen bir method nedeniyle oluşur; paketi izole edin veya parser regex'ini güncelleyin.
* **Slow run-time / high token usage** ⇒ `--source_dir`'yi tüm decompile çıktısı yerine *belirli* uygulama paketlerine işaret edin.
* Her zaman raporu *manuel olarak gözden geçirin* – LLM halüsinasyonları yanlış pozitif/negatif sonuçlara yol açabilir.

#### Practical value – Crocodilus malware case study
2025'ten gelen, ağır şekilde obfusk edilmiş bir *Crocodilus* banking trojan örneğinin Androidmeda üzerinden işlenmesi analiz süresini *saatlerden* *dakikalara* düşürdü: araç call-graph semantiğini kurtardı, accessibility API çağrılarını ve hard-coded C2 URL'lerini ortaya çıkardı ve analistlerin panolarına aktarılabilecek özlü bir rapor üretti.

---

### Targeted Dalvik string decryption with DaliVM

**DaliVM** is a Python Dalvik bytecode emulator aimed at statically recovering runtime-only values (especially decrypted strings) without spinning up Android. It executes a *specific* method inside an APK by emulating Dalvik opcodes and mocking Android/Java APIs.

**Workflow**
1. **Hedef metodu seçin** Dalvik imzası ile (`Lpkg/Class;->method(Args)Ret`). Örnekler: `Lutil/Crypto;->decrypt(Ljava/lang/String;)Ljava/lang/String;`, `LMyClass;->compute(II)I`.
2. **Çağrı noktalarını enumerate edin** tüm **multi-DEX** (`classes*.dex`) genelinde ve gerektiğinde geriye doğru veri-akışı izleme, ileri arama (forward lookup) ve kısmi yürütme ile **argümanları yeniden oluşturun**.
3. **Metodu Dalvik VM içinde emüle edin** (const/array/control/field/invoke kapsamında 120+ opcode'u kapsar, sınıf init'ini `<clinit>` üzerinden ele alır) ve **dönüş değerlerini toplayın** (örn. çözümlenmiş stringler).
4. **Runtime bağımlılıklarını atlatın** yaygın Android API'leri için yerleşik mock'lar (Context, PackageManager, Signature, reflection, system services) ve Java stdlib için hook'lar (String/StringBuilder/Integer/Math/Arrays/List/Iterator) kullanarak.
5. Eğer yürütme takılırsa, PC/register değişimlerini görmek ve opcode handler'larını genişletmek için **opcode seviyesinde izlemeyi** etkinleştirin.

**CLI usage**
```bash
# Emulate a decryptor and dump all returns
python emulate.py app.apk "Lcom/example/Decryptor;->decrypt"

# Verbose, debug trace, and limit outputs
python emulate.py app.apk "Lcom/example/Decryptor;->decrypt" -v --debug --limit 10
```
Outputs, her invocation başına toplanan return değerleridir; malware triage veya heavily obfuscated uygulamalar sırasında bulk string/config extraction için kullanışlıdır.

## Referanslar ve İleri Okuma

- [DaliVM: Python Dalvik emulator for static string decryption](https://github.com/fatalSec/DaliVM)
- [https://maddiestone.github.io/AndroidAppRE/obfuscation.html](https://maddiestone.github.io/AndroidAppRE/obfuscation.html)
- BlackHat USA 2018: “Unpacking the Packed Unpacker: Reverse Engineering an Android Anti-Analysis Library” [[video](https://www.youtube.com/watch?v=s0Tqi7fuOSU)]
- Bu konuşma, bir Android uygulamasında kullanılan ve şimdiye kadar gördüğüm en karmaşık anti-analysis native libraries'tan birinin reverse engineering'ini ele alıyor. Çoğunlukla native code'daki obfuscation techniques'i kapsıyor.
- REcon 2019: “The Path to the Payload: Android Edition” [[video](https://recon.cx/media-archive/2019/Session.005.Maddie_Stone.The_path_to_the_payload_Android_Edition-J3ZnNl2GYjEfa.mp4)]
- Bu konuşma, bir Android botnet'in davranışını gizlemek için kullandığı yalnızca Java kodundaki bir dizi obfuscation techniques'i tartışıyor.
- Deobfuscating Android Apps with Androidmeda (blog post) – [mobile-hacker.com](https://www.mobile-hacker.com/2025/07/22/deobfuscating-android-apps-with-androidmeda-a-smarter-way-to-read-obfuscated-code/)
- Androidmeda source code – [https://github.com/In3tinct/Androidmeda](https://github.com/In3tinct/Androidmeda)

{{#include ../../banners/hacktricks-training.md}}
