# Ręczne De-obfuscation Techniques

{{#include ../../banners/hacktricks-training.md}}

## Ręczne **De-obfuscation Techniques**

W obszarze **bezpieczeństwa oprogramowania**, proces uczynienia zamaskowanego kodu zrozumiałym, znany jako **de-obfuscation**, jest kluczowy. Ten przewodnik omawia różne strategie de-obfuscation, koncentrując się na technikach analizy statycznej i rozpoznawaniu wzorców obfuscation. Dodatkowo przedstawia ćwiczenie do praktycznego zastosowania oraz sugeruje dalsze zasoby dla osób chcących zgłębić bardziej zaawansowane tematy.

### **Strategie analizy statycznej De-obfuscation**

W pracy z **zamaskowanym kodem** można zastosować kilka strategii w zależności od natury obfuscation:

- **DEX bytecode (Java)**: Jednym ze skutecznych podejść jest zidentyfikowanie metod de-obfuscation aplikacji, a następnie odwzorowanie tych metod w pliku Java. Ten plik jest uruchamiany, aby odwrócić obfuscation na docelowych elementach.
- **Java i Native Code**: Inną metodą jest przetłumaczenie algorytmu de-obfuscation na język skryptowy, taki jak Python. Ta strategia pokazuje, że głównym celem nie jest pełne zrozumienie algorytmu, lecz jego skuteczne wykonanie.

### **Rozpoznawanie Obfuscation**

Rozpoznanie zamaskowanego kodu to pierwszy krok w procesie de-obfuscation. Kluczowe wskaźniki obejmują:

- Brak lub pomieszanie łańcuchów w Java i Android, co może sugerować obfuscation łańcuchów (string obfuscation).
- Obecność plików binarnych w katalogu assets lub wywołań do `DexClassLoader`, co wskazuje na unpacking kodu i dynamiczne ładowanie.
- Użycie bibliotek natywnych wraz z nierozpoznawalnymi funkcjami JNI, co może wskazywać na obfuscation metod natywnych.

## **Analiza dynamiczna w De-obfuscation**

Uruchamiając kod w kontrolowanym środowisku, analiza dynamiczna **pozwala obserwować, jak zamaskowany kod zachowuje się w czasie rzeczywistym**. Metoda ta jest szczególnie skuteczna w ujawnianiu wewnętrznych mechanizmów złożonych wzorców obfuscation, które mają na celu ukrycie prawdziwych intencji kodu.

### **Zastosowania analizy dynamicznej**

- **Runtime Decryption**: Wiele technik obfuscation polega na szyfrowaniu łańcuchów lub fragmentów kodu, które są odszyfrowywane dopiero w czasie wykonywania. Dzięki analizie dynamicznej te zaszyfrowane elementy można przechwycić w momencie deszyfracji, ujawniając ich prawdziwą postać.
- **Identifying Obfuscation Techniques**: Monitorując zachowanie aplikacji, analiza dynamiczna pomaga zidentyfikować konkretne techniki obfuscation używane w aplikacji, takie jak code virtualization, packers czy dynamic code generation.
- **Uncovering Hidden Functionality**: Zamaskowany kod może zawierać ukryte funkcjonalności, które nie są widoczne przy samej analizie statycznej. Analiza dynamiczna pozwala obserwować wszystkie ścieżki kodu, łącznie z tymi wykonywanymi warunkowo, aby ujawnić takie ukryte funkcje.

### Zautomatyzowana De-obfuscation z użyciem LLMs (Androidmeda)

Podczas gdy poprzednie sekcje koncentrują się na w pełni manualnych strategiach, w 2025 roku pojawiła się nowa klasa narzędzi napędzanych *Large-Language-Model (LLM)*, które mogą zautomatyzować większość żmudnej pracy związanej z nadawaniem sensownych nazw i odzyskiwaniem przepływu kontroli.
Jednym z reprezentatywnych projektów jest **[Androidmeda](https://github.com/In3tinct/Androidmeda)** – narzędzie w Pythonie, które bierze *zdekompilowane* źródła Java (np. wygenerowane przez `jadx`) i zwraca znacznie oczyszczoną, skomentowaną i oznakowaną pod kątem bezpieczeństwa wersję kodu.

#### Kluczowe możliwości
* Zmienia bezsensowne identyfikatory generowane przez ProGuard / DexGuard / DashO / Allatori / … na *semantic* nazwy.
* Wykrywa i restrukturyzuje **control-flow flattening**, zastępując nieprzejrzyste maszyny stanów oparte na switch-case normalnymi pętlami / konstrukcjami if-else.
* Deszyfruje powszechne wzorce **string encryption**, gdy to możliwe.
* Wstrzykuje **inline comments**, które wyjaśniają przeznaczenie złożonych bloków.
* Wykonuje *lightweight static security scan* i zapisuje wyniki w `vuln_report.json` z poziomami ważności (informational → critical).

#### Instalacja
```bash
git clone https://github.com/In3tinct/Androidmeda
cd Androidmeda
pip3 install -r requirements.txt
```
#### Przygotowanie danych wejściowych
1. Odekompiluj docelowy APK za pomocą `jadx` (lub dowolnego innego dekompilera) i zachowaj tylko katalog *source*, który zawiera pliki `.java`:
```bash
jadx -d input_dir/ target.apk
```
2. (Opcjonalnie) Przytnij `input_dir/`, tak aby zawierał tylko pakiety aplikacji, które chcesz analizować — to znacząco przyspiesza przetwarzanie i zmniejsza koszty LLM.

#### Przykłady użycia

Zdalny dostawca (Gemini-1.5-flash):
```bash
export OPENAI_API_KEY=<your_key>
python3 androidmeda.py \
--llm_provider google \
--llm_model gemini-1.5-flash \
--source_dir input_dir/ \
--output_dir out/ \
--save_code true
```
Offline (lokalny `ollama` backend z llama3.2):
```bash
python3 androidmeda.py \
--llm_provider ollama \
--llm_model llama3.2 \
--source_dir input_dir/ \
--output_dir out/ \
--save_code true
```
#### Wyjście
* `out/vuln_report.json` – tablica JSON zawierająca pola `file`, `line`, `issue`, `severity`.
* Odwzorowane drzewo pakietów z **deobfuskowanymi plikami `.java`** (tylko jeśli `--save_code true`).

#### Wskazówki i rozwiązywanie problemów
* **Pominięta klasa** ⇒ zwykle spowodowane nieparsowalną metodą; wyizoluj pakiet lub zaktualizuj regex parsera.
* **Wolne wykonanie / duże zużycie tokenów** ⇒ ustaw `--source_dir` na *konkretne* pakiety aplikacji zamiast całego dekompilatu.
* Zawsze *ręcznie przeglądaj* raport o podatnościach – halucynacje LLM mogą prowadzić do false positives / negatives.

#### Praktyczna wartość – studium przypadku malware Crocodilus
Przetworzenie silnie obfuskowanej próbki z 2025 roku bankowego trojana *Crocodilus* przez Androidmeda skróciło czas analizy z *godzin* do *minut*: narzędzie odzyskało semantykę grafu wywołań, ujawniło wywołania accessibility APIs i hard-coded C2 URLs oraz wygenerowało zwięzły raport, który można zaimportować do paneli analityków.

---

### Ukierunkowane odszyfrowywanie stringów Dalvik przy użyciu DaliVM

**DaliVM** to emulator bajt-kodu Dalvik napisany w Pythonie, przeznaczony do statycznego odzyskiwania wartości dostępnych tylko podczas wykonania (zwłaszcza odszyfrowanych stringów) bez uruchamiania Androida. Wykonuje *konkretną* metodę wewnątrz APK przez emulację Dalvik opcodes i mockowanie Android/Java APIs.

**Przebieg**
1. **Wybierz metodę docelową** według sygnatury Dalvik (`Lpkg/Class;->method(Args)Ret`). Przykłady: `Lutil/Crypto;->decrypt(Ljava/lang/String;)Ljava/lang/String;`, `LMyClass;->compute(II)I`.
2. **Wypisz miejsca wywołań** w obrębie **multi-DEX** (`classes*.dex`) i **odtwórz argumenty** za pomocą śledzenia przepływu danych wstecz (backward data-flow tracing), wyszukiwania w przód (forward lookup) oraz częściowego wykonania w razie potrzeby.
3. **Emuluj metodę** wewnątrz Dalvik VM (obsługuje 120+ opcodes obejmujących const/array/control/field/invoke, obsługuje inicjalizację klas przez `<clinit>`) i **zbierz wartości zwracane** (np. odszyfrowane stringi).
4. **Omijaj zależności w czasie wykonania** używając wbudowanych mocków dla powszechnych Android APIs (Context, PackageManager, Signature, reflection, system services) oraz hooków dla Java stdlib (String/StringBuilder/Integer/Math/Arrays/List/Iterator).
5. Jeśli wykonanie utknie, **włącz śledzenie na poziomie opcode'ów**, aby zobaczyć zmiany PC/rejestrów i rozbudować obsługę opcode'ów.

**Użycie CLI**
```bash
# Emulate a decryptor and dump all returns
python emulate.py app.apk "Lcom/example/Decryptor;->decrypt"

# Verbose, debug trace, and limit outputs
python emulate.py app.apk "Lcom/example/Decryptor;->decrypt" -v --debug --limit 10
```
Outputs są zebranymi wartościami zwracanymi przy każdym wywołaniu; przydatne do masowego wyodrębniania string/config podczas malware triage lub silnie obfuskowanych aplikacji.

## Referencje i dalsza lektura

- [DaliVM: Python Dalvik emulator for static string decryption](https://github.com/fatalSec/DaliVM)
- [https://maddiestone.github.io/AndroidAppRE/obfuscation.html](https://maddiestone.github.io/AndroidAppRE/obfuscation.html)
- BlackHat USA 2018: “Unpacking the Packed Unpacker: Reverse Engineering an Android Anti-Analysis Library” [[video](https://www.youtube.com/watch?v=s0Tqi7fuOSU)]
- Wykład opisuje reverse engineering jednej z najbardziej złożonych anti-analysis native libraries, które widziałem używane w aplikacji Android. Dotyczy głównie obfuscation techniques w native code.
- REcon 2019: “The Path to the Payload: Android Edition” [[video](https://recon.cx/media-archive/2019/Session.005.Maddie_Stone.The_path_to_the_payload_Android_Edition-J3ZnNl2GYjEfa.mp4)]
- Wykład omawia serię obfuscation techniques, zaimplementowanych wyłącznie w Java code, których Android botnet używał do ukrywania swojego zachowania.
- Deobfuscating Android Apps with Androidmeda (blog post) – [mobile-hacker.com](https://www.mobile-hacker.com/2025/07/22/deobfuscating-android-apps-with-androidmeda-a-smarter-way-to-read-obfuscated-code/)
- Androidmeda source code – [https://github.com/In3tinct/Androidmeda](https://github.com/In3tinct/Androidmeda)

{{#include ../../banners/hacktricks-training.md}}
