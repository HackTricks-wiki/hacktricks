# Técnicas manuales de desofuscación

{{#include ../../banners/hacktricks-training.md}}

## Técnicas manuales de **desofuscación**

En el ámbito de la **seguridad de software**, el proceso de hacer comprensible código obscuro, conocido como **desofuscación**, es crucial. Esta guía profundiza en varias estrategias para la desofuscación, centrándose en técnicas de análisis estático y en el reconocimiento de patrones de ofuscación. Además, introduce un ejercicio para la aplicación práctica y sugiere recursos adicionales para quienes quieran explorar temas más avanzados.

### **Estrategias para la desofuscación estática**

Al tratar con **código ofuscado**, se pueden emplear diversas estrategias según la naturaleza de la ofuscación:

- **DEX bytecode (Java)**: Un enfoque eficaz consiste en identificar los métodos de desofuscación de la aplicación y luego replicarlos en un archivo Java. Ese archivo se ejecuta para revertir la ofuscación en los elementos objetivo.
- **Java and Native Code**: Otro método es traducir el algoritmo de desofuscación a un lenguaje de scripting como Python. Esta estrategia pone de relieve que el objetivo principal no es comprender el algoritmo por completo, sino ejecutarlo de forma efectiva.

### **Identificando la ofuscación**

Reconocer código ofuscado es el primer paso en el proceso de desofuscación. Indicadores clave incluyen:

- La **ausencia o enmascaramiento de cadenas** en Java y Android, lo que puede sugerir ofuscación de strings.
- La **presencia de archivos binarios** en el directorio assets o llamadas a `DexClassLoader`, que insinúan desempaquetado de código y carga dinámica.
- El uso de **bibliotecas nativas junto con funciones JNI no identificables**, lo que indica una posible ofuscación de métodos nativos.

## **Análisis dinámico en la desofuscación**

Al ejecutar el código en un entorno controlado, el análisis dinámico **permite observar cómo se comporta el código ofuscado en tiempo real**. Este método es particularmente eficaz para descubrir el funcionamiento interno de patrones de ofuscación complejos diseñados para ocultar la verdadera intención del código.

### **Aplicaciones del análisis dinámico**

- **Runtime Decryption**: Muchas técnicas de ofuscación implican cifrar strings o segmentos de código que solo se descifran en runtime. Mediante análisis dinámico, estos elementos cifrados pueden capturarse en el momento del descifrado, revelando su forma real.
- **Identifying Obfuscation Techniques**: Al monitorizar el comportamiento de la aplicación, el análisis dinámico puede ayudar a identificar técnicas específicas de ofuscación que se estén utilizando, como code virtualization, packers o dynamic code generation.
- **Uncovering Hidden Functionality**: El código ofuscado puede contener funcionalidades ocultas que no son aparentes mediante análisis estático. El análisis dinámico permite la observación de todos los caminos de código, incluidos los ejecutados condicionalmente, para descubrir dichas funcionalidades ocultas.

### Automated De-obfuscation with LLMs (Androidmeda)

Mientras las secciones previas se centran en estrategias totalmente manuales, en 2025 surgió una nueva clase de herramientas impulsadas por *Large-Language-Model (LLM)* que pueden automatizar la mayor parte del tedioso trabajo de renombrado y recuperación del control-flow.  
Un proyecto representativo es **[Androidmeda](https://github.com/In3tinct/Androidmeda)** – una utilidad en Python que toma fuentes Java *decompiled* (p. ej. producidas por `jadx`) y devuelve una versión ampliamente limpiada, comentada y anotada con consideraciones de seguridad del código.

#### Capacidades clave
* Renombra identificadores carentes de sentido generados por ProGuard / DexGuard / DashO / Allatori / … a nombres *semánticos*.
* Detecta y reestructura **control-flow flattening**, reemplazando máquinas de estado opacas basadas en switch-case por bucles normales / constructos if-else.
* Descifra patrones comunes de cifrado de strings cuando es posible.
* Inserta **comentarios inline** que explican el propósito de bloques complejos.
* Realiza un *escaneo estático de seguridad ligero* y escribe los hallazgos en `vuln_report.json` con niveles de severidad (informativo → crítico).

#### Instalación
```bash
git clone https://github.com/In3tinct/Androidmeda
cd Androidmeda
pip3 install -r requirements.txt
```
#### Preparando las entradas
1. Descompila el APK objetivo con `jadx` (u otro descompilador) y conserva solo el directorio *source* que contiene los archivos `.java`:
```bash
jadx -d input_dir/ target.apk
```
2. (Opcional) Recorta `input_dir/` para que solo contenga los paquetes de la aplicación que quieras analizar – esto acelera enormemente el procesamiento y reduce los costes de LLM.

#### Ejemplos de uso

Proveedor remoto (Gemini-1.5-flash):
```bash
export OPENAI_API_KEY=<your_key>
python3 androidmeda.py \
--llm_provider google \
--llm_model gemini-1.5-flash \
--source_dir input_dir/ \
--output_dir out/ \
--save_code true
```
Sin conexión (backend local `ollama` con llama3.2):
```bash
python3 androidmeda.py \
--llm_provider ollama \
--llm_model llama3.2 \
--source_dir input_dir/ \
--output_dir out/ \
--save_code true
```
#### Salida
* `out/vuln_report.json` – arreglo JSON con `file`, `line`, `issue`, `severity`.
* A mirrored package tree with **de-obfuscated `.java` files** (only if `--save_code true`).

#### Consejos & resolución de problemas
* **Clase omitida** ⇒ generalmente causada por un método que no se puede parsear; aísla el paquete o actualiza la regex del parser.
* **Ejecución lenta / alto consumo de tokens** ⇒ apunta `--source_dir` a paquetes específicos de la app en lugar de toda la decompilación.
* Revisa siempre *manualmente* el informe de vulnerabilidades – las alucinaciones del LLM pueden causar falsos positivos / negativos.

#### Valor práctico – estudio de caso: Crocodilus malware
Procesar una muestra fuertemente ofuscada del troyano bancario *Crocodilus* de 2025 con Androidmeda redujo el tiempo de análisis de *horas* a *minutos*: la herramienta recuperó la semántica del grafo de llamadas, reveló llamadas a APIs de accesibilidad y URLs C2 codificadas (hard-coded), y generó un informe conciso que pudo importarse en los dashboards de los analistas.

---

### Descifrado dirigido de strings Dalvik con DaliVM

**DaliVM** es un emulador de bytecode Dalvik en Python diseñado para recuperar de forma estática valores que solo existen en tiempo de ejecución (especialmente cadenas descifradas) sin levantar Android. Ejecuta un método *específico* dentro de un APK emulando opcodes Dalvik y simulando Android/Java APIs.

**Flujo de trabajo**
1. **Selecciona el método objetivo** por su firma Dalvik (`Lpkg/Class;->method(Args)Ret`). Ejemplos: `Lutil/Crypto;->decrypt(Ljava/lang/String;)Ljava/lang/String;`, `LMyClass;->compute(II)I`.
2. **Enumera los sitios de llamada** a través de **multi-DEX** (`classes*.dex`) y **reconstruye los argumentos** mediante trazado de flujo de datos hacia atrás, búsqueda hacia adelante y ejecución parcial cuando sea necesario.
3. **Emula el método** dentro de la VM Dalvik (cubre 120+ opcodes en const/array/control/field/invoke, maneja la inicialización de clase vía `<clinit>`) y **recoge los valores de retorno** (p. ej., cadenas descifradas).
4. **Elude dependencias en tiempo de ejecución** usando mocks incorporados para APIs comunes de Android (Context, PackageManager, Signature, reflection, system services) y hooks para la stdlib de Java (String/StringBuilder/Integer/Math/Arrays/List/Iterator).
5. Si la ejecución se detiene, **habilita el trazado a nivel de opcode** para ver cambios de PC/registros y extender los handlers de opcode.

**Uso CLI**
```bash
# Emulate a decryptor and dump all returns
python emulate.py app.apk "Lcom/example/Decryptor;->decrypt"

# Verbose, debug trace, and limit outputs
python emulate.py app.apk "Lcom/example/Decryptor;->decrypt" -v --debug --limit 10
```
Los outputs son los valores de retorno recopilados por invocación; útiles para la extracción masiva de cadenas/config durante el triage de malware o en aplicaciones fuertemente ofuscadas.

## Referencias y lecturas adicionales

- [DaliVM: Python Dalvik emulator for static string decryption](https://github.com/fatalSec/DaliVM)
- [https://maddiestone.github.io/AndroidAppRE/obfuscation.html](https://maddiestone.github.io/AndroidAppRE/obfuscation.html)
- BlackHat USA 2018: “Unpacking the Packed Unpacker: Reverse Engineering an Android Anti-Analysis Library” [[video](https://www.youtube.com/watch?v=s0Tqi7fuOSU)]
- Esta charla trata sobre la ingeniería inversa de una de las bibliotecas nativas anti-análisis más complejas que he visto usadas por una aplicación Android. Cubre principalmente técnicas de ofuscación en código nativo.
- REcon 2019: “The Path to the Payload: Android Edition” [[video](https://recon.cx/media-archive/2019/Session.005.Maddie_Stone.The_path_to_the_payload_Android_Edition-J3ZnNl2GYjEfa.mp4)]
- Esta charla discute una serie de técnicas de ofuscación, únicamente en código Java, que una botnet Android estaba usando para ocultar su comportamiento.
- Deobfuscating Android Apps with Androidmeda (blog post) – [mobile-hacker.com](https://www.mobile-hacker.com/2025/07/22/deobfuscating-android-apps-with-androidmeda-a-smarter-way-to-read-obfuscated-code/)
- Androidmeda source code – [https://github.com/In3tinct/Androidmeda](https://github.com/In3tinct/Androidmeda)

{{#include ../../banners/hacktricks-training.md}}
