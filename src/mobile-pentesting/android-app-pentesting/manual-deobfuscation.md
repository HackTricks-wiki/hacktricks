# Manual De-obfuscation Techniques

{{#include ../../banners/hacktricks-training.md}}

## Manual **De-obfuscation Techniques**

**सॉफ़्टवेयर सुरक्षा** के क्षेत्र में, अस्पष्ट कोड को समझने योग्य बनाने की प्रक्रिया, जिसे **de-obfuscation** कहा जाता है, महत्वपूर्ण है। यह गाइड de-obfuscation के विभिन्न रणनीतियों में गहराई से जाती है, जो स्थैतिक विश्लेषण तकनीकों और अस्पष्टता पैटर्न को पहचानने पर केंद्रित है। इसके अतिरिक्त, यह व्यावहारिक अनुप्रयोग के लिए एक व्यायाम प्रस्तुत करती है और उन लोगों के लिए आगे के संसाधनों का सुझाव देती है जो अधिक उन्नत विषयों का अन्वेषण करना चाहते हैं।

### **Strategies for Static De-obfuscation**

जब **obfuscated code** के साथ काम कर रहे होते हैं, तो अस्पष्टता की प्रकृति के आधार पर कई रणनीतियाँ अपनाई जा सकती हैं:

- **DEX bytecode (Java)**: एक प्रभावी दृष्टिकोण में एप्लिकेशन के de-obfuscation तरीकों की पहचान करना शामिल है, फिर इन तरीकों को एक Java फ़ाइल में दोहराना। इस फ़ाइल को लक्षित तत्वों पर अस्पष्टता को उलटने के लिए निष्पादित किया जाता है।
- **Java और Native Code**: एक अन्य विधि de-obfuscation एल्गोरिदम को Python जैसी स्क्रिप्टिंग भाषा में अनुवाद करना है। यह रणनीति यह उजागर करती है कि प्राथमिक लक्ष्य एल्गोरिदम को पूरी तरह से समझना नहीं है, बल्कि इसे प्रभावी ढंग से निष्पादित करना है।

### **Identifying Obfuscation**

अस्पष्ट कोड को पहचानना de-obfuscation प्रक्रिया में पहला कदम है। प्रमुख संकेतक शामिल हैं:

- Java और Android में **स्ट्रिंग्स की अनुपस्थिति या उलझन**, जो स्ट्रिंग अस्पष्टता का सुझाव दे सकती है।
- **बाइनरी फ़ाइलों की उपस्थिति** जो assets निर्देशिका में हैं या `DexClassLoader` को कॉल करती हैं, जो कोड अनपैकिंग और गतिशील लोडिंग का संकेत देती हैं।
- **अज्ञात JNI फ़ंक्शंस के साथ Native Libraries** का उपयोग, जो संभावित रूप से स्थानीय विधियों की अस्पष्टता को इंगित करता है।

## **Dynamic Analysis in De-obfuscation**

नियंत्रित वातावरण में कोड को निष्पादित करके, गतिशील विश्लेषण **यह देखने की अनुमति देता है कि अस्पष्ट कोड वास्तविक समय में कैसे व्यवहार करता है**। यह विधि विशेष रूप से जटिल अस्पष्टता पैटर्न के आंतरिक कार्यों को उजागर करने में प्रभावी है जो कोड के वास्तविक इरादे को छिपाने के लिए डिज़ाइन किए गए हैं।

### **Applications of Dynamic Analysis**

- **Runtime Decryption**: कई अस्पष्टता तकनीकों में स्ट्रिंग्स या कोड खंडों को एन्क्रिप्ट करना शामिल होता है जो केवल रनटाइम पर डिक्रिप्ट होते हैं। गतिशील विश्लेषण के माध्यम से, इन एन्क्रिप्टेड तत्वों को डिक्रिप्शन के क्षण में कैप्चर किया जा सकता है, जिससे उनका वास्तविक रूप प्रकट होता है।
- **Identifying Obfuscation Techniques**: एप्लिकेशन के व्यवहार की निगरानी करके, गतिशील विश्लेषण विशिष्ट अस्पष्टता तकनीकों की पहचान करने में मदद कर सकता है, जैसे कोड वर्चुअलाइजेशन, पैकर, या गतिशील कोड जनरेशन।
- **Uncovering Hidden Functionality**: अस्पष्ट कोड में छिपी हुई कार्यक्षमताएँ हो सकती हैं जो केवल स्थैतिक विश्लेषण के माध्यम से स्पष्ट नहीं होती हैं। गतिशील विश्लेषण सभी कोड पथों का अवलोकन करने की अनुमति देता है, जिसमें वे भी शामिल हैं जो शर्तों के अनुसार निष्पादित होते हैं, ताकि ऐसी छिपी हुई कार्यक्षमताओं को उजागर किया जा सके।

### Automated De-obfuscation with LLMs (Androidmeda)

जबकि पिछले अनुभाग पूरी तरह से मैनुअल रणनीतियों पर ध्यान केंद्रित करते हैं, 2025 में *Large-Language-Model (LLM) powered* उपकरणों का एक नया वर्ग उभरा जो अधिकांश थकाऊ नामकरण और नियंत्रण-प्रवाह पुनर्प्राप्ति कार्य को स्वचालित कर सकता है। एक प्रतिनिधि परियोजना है **[Androidmeda](https://github.com/In3tinct/Androidmeda)** – एक Python उपयोगिता जो *decompiled* Java स्रोतों (जैसे `jadx` द्वारा उत्पन्न) को लेती है और कोड का एक बहुत साफ, टिप्पणी किया गया और सुरक्षा-एनोटेटेड संस्करण लौटाती है।

#### Key capabilities
* ProGuard / DexGuard / DashO / Allatori / … द्वारा उत्पन्न अर्थहीन पहचानकर्ताओं के नाम को *semantic* नामों में बदलता है।
* **control-flow flattening** का पता लगाता है और पुनर्गठन करता है, अपारदर्शी स्विच-केस राज्य मशीनों को सामान्य लूप / if-else संरचनाओं के साथ बदलता है।
* सामान्य **string encryption** पैटर्न को संभव होने पर डिक्रिप्ट करता है।
* जटिल ब्लॉकों के उद्देश्य को स्पष्ट करने वाले **inline comments** डालता है।
* एक *lightweight static security scan* करता है और निष्कर्षों को `vuln_report.json` में गंभीरता स्तरों (सूचनात्मक → महत्वपूर्ण) के साथ लिखता है।

#### Installation
```bash
git clone https://github.com/In3tinct/Androidmeda
cd Androidmeda
pip3 install -r requirements.txt
```
#### इनपुट तैयार करना
1. लक्षित APK को `jadx` (या किसी अन्य डिकंपाइलर) के साथ डिकंपाइल करें और केवल *स्रोत* निर्देशिका रखें जिसमें `.java` फ़ाइलें हैं:
```bash
jadx -d input_dir/ target.apk
```
2. (वैकल्पिक) `input_dir/` को इस तरह से ट्रिम करें कि इसमें केवल वे एप्लिकेशन पैकेज हों जिन्हें आप विश्लेषण करना चाहते हैं - इससे प्रोसेसिंग और LLM लागत में काफी तेजी आती है।

#### उपयोग के उदाहरण

Remote provider (Gemini-1.5-flash):
```bash
export OPENAI_API_KEY=<your_key>
python3 androidmeda.py \
--llm_provider google \
--llm_model gemini-1.5-flash \
--source_dir input_dir/ \
--output_dir out/ \
--save_code true
```
ऑफलाइन (स्थानीय `ollama` बैकएंड के साथ llama3.2):
```bash
python3 androidmeda.py \
--llm_provider ollama \
--llm_model llama3.2 \
--source_dir input_dir/ \
--output_dir out/ \
--save_code true
```
#### Output
* `out/vuln_report.json` – JSON array with `file`, `line`, `issue`, `severity`.
* एक मिरर पैकेज ट्री जिसमें **de-obfuscated `.java` फाइलें** हैं (केवल यदि `--save_code true` हो)।

#### Tips & troubleshooting
* **Skipped class** ⇒ आमतौर पर एक unparsable method के कारण होता है; पैकेज को अलग करें या parser regex को अपडेट करें।
* **Slow run-time / high token usage** ⇒ `--source_dir` को *specific* ऐप पैकेज की ओर इंगित करें न कि पूरे decompile की ओर।
* हमेशा *manually review* करें vulnerability report को – LLM hallucinations झूठे सकारात्मक / नकारात्मक परिणामों की ओर ले जा सकते हैं।

#### Practical value – Crocodilus malware case study
2025 *Crocodilus* बैंकिंग ट्रोजन से एक भारी obfuscated सैंपल को Androidmeda के माध्यम से फीड करने से विश्लेषण समय *घंटों* से *मिनटों* में कम हो गया: टूल ने कॉल-ग्राफ semantics को पुनर्प्राप्त किया, accessibility APIs और hard-coded C2 URLs के लिए कॉल का खुलासा किया, और एक संक्षिप्त रिपोर्ट तैयार की जिसे विश्लेषकों के डैशबोर्ड में आयात किया जा सकता था।

---

## References and Further Reading

- [https://maddiestone.github.io/AndroidAppRE/obfuscation.html](https://maddiestone.github.io/AndroidAppRE/obfuscation.html)
- BlackHat USA 2018: “Unpacking the Packed Unpacker: Reverse Engineering an Android Anti-Analysis Library” [[video](https://www.youtube.com/watch?v=s0Tqi7fuOSU)]
- This talk goes over reverse engineering one of the most complex anti-analysis native libraries I’ve seen used by an Android application. It covers mostly obfuscation techniques in native code.
- REcon 2019: “The Path to the Payload: Android Edition” [[video](https://recon.cx/media-archive/2019/Session.005.Maddie_Stone.The_path_to_the_payload_Android_Edition-J3ZnNl2GYjEfa.mp4)]
- This talk discusses a series of obfuscation techniques, solely in Java code, that an Android botnet was using to hide its behavior.
- Deobfuscating Android Apps with Androidmeda (blog post) – [mobile-hacker.com](https://www.mobile-hacker.com/2025/07/22/deobfuscating-android-apps-with-androidmeda-a-smarter-way-to-read-obfuscated-code/)
- Androidmeda source code – [https://github.com/In3tinct/Androidmeda](https://github.com/In3tinct/Androidmeda)

- [https://maddiestone.github.io/AndroidAppRE/obfuscation.html](https://maddiestone.github.io/AndroidAppRE/obfuscation.html)
- BlackHat USA 2018: “Unpacking the Packed Unpacker: Reverse Engineering an Android Anti-Analysis Library” \[[video](https://www.youtube.com/watch?v=s0Tqi7fuOSU)]
- This talk goes over reverse engineering one of the most complex anti-analysis native libraries I’ve seen used by an Android application. It covers mostly obfuscation techniques in native code.
- REcon 2019: “The Path to the Payload: Android Edition” \[[video](https://recon.cx/media-archive/2019/Session.005.Maddie_Stone.The_path_to_the_payload_Android_Edition-J3ZnNl2GYjEfa.mp4)]
- This talk discusses a series of obfuscation techniques, solely in Java code, that an Android botnet was using to hide its behavior.

{{#include ../../banners/hacktricks-training.md}}
