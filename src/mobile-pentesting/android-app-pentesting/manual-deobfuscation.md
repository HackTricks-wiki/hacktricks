# मैन्युअल De-obfuscation Techniques

{{#include ../../banners/hacktricks-training.md}}

## मैन्युअल **De-obfuscation Techniques**

सॉफ्टवेयर सुरक्षा के क्षेत्र में, अस्पष्ट कोड को समझने योग्य बनाने की प्रक्रिया, जिसे **de-obfuscation** कहा जाता है, अत्यंत महत्वपूर्ण है। यह गाइड static analysis techniques और obfuscation patterns को पहचानने पर ध्यान केंद्रित करते हुए विभिन्न रणनीतियों में गहराई से जाती है। इसके अलावा, यह व्यावहारिक अभ्यास प्रस्तुत करती है और अधिक उन्नत विषयों का अन्वेषण करने वालों के लिए आगे के संसाधन सुझाती है।

### **Static De-obfuscation के लिए रणनीतियाँ**

obfuscated code से निपटते समय, obfuscation की प्रकृति के अनुसार कई strategies अपनाई जा सकती हैं:

- **DEX bytecode (Java)**: एक प्रभावी तरीका एप्लिकेशन की de-obfuscation विधियों की पहचान करना है, फिर इन विधियों की नकल करके एक Java फ़ाइल में उन्हें लागू करना। इस फ़ाइल को चलाकर लक्षित तत्वों पर obfuscation को उल्टा किया जाता है।
- **Java and Native Code**: एक अन्य तरीका यह है कि de-obfuscation algorithm को Python जैसे scripting language में translate किया जाए। यह रणनीति यह रेखांकित करती है कि मुख्य लक्ष्य algorithm को पूरी तरह समझना नहीं बल्कि उसे प्रभावी ढंग से चलाना है।

### **Obfuscation की पहचान**

obfuscated code की पहचान de-obfuscation प्रक्रिया में पहला कदम है। प्रमुख संकेतों में शामिल हैं:

- Java और Android में **strings की अनुपस्थिति या scrambling**, जो string obfuscation का संकेत दे सकती है।
- assets directory में **binary files की उपस्थिति** या `DexClassLoader` को कॉल किया जाना, जो code unpacking और dynamic loading की ओर इशारा करता है।
- पहचान न होने योग्य JNI functions के साथ **native libraries का उपयोग**, जो native methods के संभावित obfuscation का संकेत देता है।

## **De-obfuscation में Dynamic Analysis**

एक नियंत्रित environment में कोड को execute करके, dynamic analysis यह देखने की अनुमति देता है कि obfuscated code वास्तविक समय में कैसे व्यवहार करता है। यह तरीका विशेष रूप से जटिल obfuscation patterns के आंतरिक कार्यों को उजागर करने में प्रभावी है जो कोड के वास्तविक उद्देश्य को छुपाने के लिए डिज़ाइन किए गए होते हैं।

### **Dynamic Analysis के अनुप्रयोग**

- **Runtime Decryption**: कई obfuscation तकनीकों में strings या code segments का encryption शामिल होता है जो केवल runtime पर ही decrypted होते हैं। dynamic analysis के माध्यम से, इन encrypted तत्वों को decryption के क्षण पर capture किया जा सकता है, जिससे उनका वास्तविक रूप प्रकट होता है।
- **Identifying Obfuscation Techniques**: application के व्यवहार की निगरानी करके, dynamic analysis उपयोग किए जा रहे विशिष्ट obfuscation techniques की पहचान करने में मदद कर सकता है, जैसे code virtualization, packers, या dynamic code generation।
- **Uncovering Hidden Functionality**: obfuscated code में ऐसे छिपे हुए functionalities हो सकते हैं जो केवल static analysis से स्पष्ट नहीं होते। Dynamic analysis सभी code paths का अवलोकन करने की अनुमति देता है, जिनमें conditionally executed path भी शामिल हैं, ताकि ऐसे छिपे हुए functionalities का पता लगाया जा सके।

### Automated De-obfuscation with LLMs (Androidmeda)

पिछले sections पूरी तरह मैनुअल रणनीतियों पर केंद्रित हैं, पर 2025 में *Large-Language-Model (LLM) powered* tooling का एक नया वर्ग उभरा जिसने अधिकांश tedious renaming और control-flow recovery कार्यों को automate कर दिया। एक प्रतिनिधि प्रोजेक्ट है **[Androidmeda](https://github.com/In3tinct/Androidmeda)** – एक Python utility जो *decompiled* Java स्रोतों (जैसे `jadx`) को लेता है और कोड का काफी cleaned-up, commented और security-annotated संस्करण लौटाता है।

#### Key capabilities
* ProGuard / DexGuard / DashO / Allatori / … द्वारा generate किए गए meaningless identifiers को *semantic* names में rename करता है।
* **control-flow flattening** का पता लगाता है और उसे restructure करता है, अपारदर्शी switch-case state machines को सामान्य loops / if-else constructs से replace करता है।
* संभावित होने पर सामान्य **string encryption** patterns को decrypt करता है।
* जटिल blocks के उद्देश्य को समझाने वाले **inline comments** insert करता है।
* एक *lightweight static security scan* करता है और findings को `vuln_report.json` में severity levels (informational → critical) के साथ लिखता है।

#### Installation
```bash
git clone https://github.com/In3tinct/Androidmeda
cd Androidmeda
pip3 install -r requirements.txt
```
#### इनपुट तैयार करना
1. लक्षित APK को `jadx` (या किसी अन्य decompiler) से डीकम्पाइल करें और केवल उस *source* डायरेक्टरी को रखें जिसमें `.java` फ़ाइलें होती हैं:
```bash
jadx -d input_dir/ target.apk
```
2. (वैकल्पिक) `input_dir/` को ट्रिम करें ताकि इसमें केवल वे application packages हों जिन्हें आप analyse करना चाहते हैं – यह प्रोसेसिंग को काफी तेज़ कर देता है और LLM लागत को कम कर देता है।

#### उपयोग के उदाहरण

रिमोट प्रदाता (Gemini-1.5-flash):
```bash
export OPENAI_API_KEY=<your_key>
python3 androidmeda.py \
--llm_provider google \
--llm_model gemini-1.5-flash \
--source_dir input_dir/ \
--output_dir out/ \
--save_code true
```
ऑफ़लाइन (स्थानीय `ollama` backend के साथ llama3.2):
```bash
python3 androidmeda.py \
--llm_provider ollama \
--llm_model llama3.2 \
--source_dir input_dir/ \
--output_dir out/ \
--save_code true
```
#### Output
* `out/vuln_report.json` – JSON array जिसमें `file`, `line`, `issue`, `severity` हों।
* A mirrored package tree with **de-obfuscated `.java` files** (only if `--save_code true`).

#### Tips & troubleshooting
* **Skipped class** ⇒ आम तौर पर एक unparsable method के कारण होता है; पैकेज को अलग करें या parser regex अपडेट करें।
* **Slow run-time / high token usage** ⇒ पूरा decompile करने के बजाय `--source_dir` को *specific* app packages की ओर निर्देशित करें।
* हमेशा *manually review* करें vulnerability report – LLM hallucinations false positives / negatives का कारण बन सकती हैं।

#### Practical value – Crocodilus malware case study
2025 के भारी रूप से obfuscated sample को Androidmeda के माध्यम से चलाने से विश्लेषण का समय *hours* से घटकर *minutes* रह गया: टूल ने call-graph semantics को रिकवर किया, accessibility APIs और hard-coded C2 URLs के कॉल्स को उजागर किया, और एक संक्षिप्त रिपोर्ट बनाई जिसे analysts’ dashboards में import किया जा सकता था।

---

### Targeted Dalvik string decryption with DaliVM

**DaliVM** एक Python Dalvik bytecode emulator है जो Android चलाए बिना static रूप से runtime-only values (खासकर decrypted strings) रिकवर करने के लिए बनाया गया है। यह APK के अंदर एक *specific* method को Dalvik opcodes का emulate करके और Android/Java APIs को mock करके execute करता है।

**Workflow**
1. **Select target method** by Dalvik signature (`Lpkg/Class;->method(Args)Ret`). Examples: `Lutil/Crypto;->decrypt(Ljava/lang/String;)Ljava/lang/String;`, `LMyClass;->compute(II)I`.
2. **Enumerate call sites** across **multi-DEX** (`classes*.dex`) and **reconstruct arguments** via backward data-flow tracing, forward lookup, and partial execution when needed.
3. **Emulate the method** inside the Dalvik VM (covers 120+ opcodes across const/array/control/field/invoke, handles class init via `<clinit>`) and **collect return values** (e.g., decrypted strings).
4. **Bypass runtime dependencies** using built-in mocks for common Android APIs (Context, PackageManager, Signature, reflection, system services) and hooks for Java stdlib (String/StringBuilder/Integer/Math/Arrays/List/Iterator).
5. If execution stalls, **enable opcode-level tracing** to see PC/register changes and extend opcode handlers.

**CLI usage**
```bash
# Emulate a decryptor and dump all returns
python emulate.py app.apk "Lcom/example/Decryptor;->decrypt"

# Verbose, debug trace, and limit outputs
python emulate.py app.apk "Lcom/example/Decryptor;->decrypt" -v --debug --limit 10
```
Outputs प्रत्येक कॉल पर एकत्र किए गए return मान होते हैं; यह malware triage या heavily obfuscated apps के दौरान bulk string/config extraction के लिए उपयोगी है।

## संदर्भ और आगे पढ़ने के लिए

- [DaliVM: Python Dalvik emulator for static string decryption](https://github.com/fatalSec/DaliVM)
- [https://maddiestone.github.io/AndroidAppRE/obfuscation.html](https://maddiestone.github.io/AndroidAppRE/obfuscation.html)
- BlackHat USA 2018: “Unpacking the Packed Unpacker: Reverse Engineering an Android Anti-Analysis Library” [[video](https://www.youtube.com/watch?v=s0Tqi7fuOSU)]
- यह टॉक एक Android application में उपयोग की गई सबसे जटिल anti-analysis native libraries में से एक का reverse engineering बताती है जिसे मैंने देखा है। यह मुख्य रूप से native code में obfuscation techniques को कवर करती है।
- REcon 2019: “The Path to the Payload: Android Edition” [[video](https://recon.cx/media-archive/2019/Session.005.Maddie_Stone.The_path_to_the_payload_Android_Edition-J3ZnNl2GYjEfa.mp4)]
- यह टॉक obfuscation techniques की एक श्रृंखला पर चर्चा करती है, जो केवल Java code में हैं, और जिन्हें एक Android botnet ने अपने व्यवहार को छिपाने के लिए उपयोग किया था।
- Deobfuscating Android Apps with Androidmeda (blog post) – [mobile-hacker.com](https://www.mobile-hacker.com/2025/07/22/deobfuscating-android-apps-with-androidmeda-a-smarter-way-to-read-obfuscated-code/)
- Androidmeda source code – [https://github.com/In3tinct/Androidmeda](https://github.com/In3tinct/Androidmeda)

{{#include ../../banners/hacktricks-training.md}}
