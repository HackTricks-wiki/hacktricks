# Manual De-obfuscation Techniques

{{#include ../../banners/hacktricks-training.md}}

## Manual **De-obfuscation Techniques**

У сфері безпеки програмного забезпечення процес зробити зашифрований код зрозумілим, відомий як **деобфускація**, є критично важливим. Цей посібник розглядає різні стратегії деобфускації з акцентом на методи статичного аналізу та розпізнавання шаблонів обфускації. Також він містить вправу для практичного застосування та пропозиції щодо ресурсів для подальшого вивчення більш просунутих тем.

### **Strategies for Static De-obfuscation**

При роботі з **обфусцованим кодом** можна застосовувати кілька стратегій залежно від природи обфускації:

- **DEX bytecode (Java)**: Один з ефективних підходів полягає у виявленні методів деобфускації додатку, а потім у відтворенні цих методів у Java-файлі. Цей файл виконується для скасування обфускації цільових елементів.
- **Java and Native Code**: Інший метод — перекласти алгоритм деобфускації на скриптову мову, наприклад Python. Ця стратегія підкреслює, що основна мета — не повністю зрозуміти алгоритм, а ефективно його виконати.

### **Identifying Obfuscation**

Розпізнавання обфусцованого коду — перший крок у процесі деобфускації. Ключові індикатори включають:

- Відсутність або перемішані рядки в Java та Android, що може свідчити про обфускацію рядків.
- Наявність бінарних файлів у директорії assets або виклики до `DexClassLoader`, що натякає на unpacking коду та динамічне завантаження.
- Використання native бібліотек разом з невпізнаваними JNI-функціями, що вказує на можливу обфускацію native-методів.

## **Dynamic Analysis in De-obfuscation**

Виконуючи код у контрольованому середовищі, динамічний аналіз дозволяє спостерігати, як обфусцований код поводиться в реальному часі. Цей метод особливо ефективний для виявлення внутрішньої логіки складних шаблонів обфускації, які призначені приховати справжній намір коду.

### **Applications of Dynamic Analysis**

- **Runtime Decryption**: Багато технік обфускації включають шифрування рядків або сегментів коду, які дешифруються лише під час виконання. За допомогою динамічного аналізу ці зашифровані елементи можна зафіксувати в момент їх дешифрування, виявивши їхній справжній вигляд.
- **Identifying Obfuscation Techniques**: Моніторинг поведінки додатку допомагає ідентифікувати конкретні техніки обфускації, такі як code virtualization, packers або dynamic code generation.
- **Uncovering Hidden Functionality**: Обфусцований код може містити приховані функціональності, які не очевидні при статичному аналізі. Динамічний аналіз дозволяє спостерігати всі гілки виконання коду, включно з умовно виконуваними, щоб виявити такі приховані можливості.

### Automated De-obfuscation with LLMs (Androidmeda)

У той час як попередні розділи зосереджені на повністю ручних стратегіях, у 2025 році з'явився новий клас інструментів, що використовують Large-Language-Model (LLM), який може автоматизувати більшість нудної роботи з перейменування та відновлення контролю виконання.
Одним із представницьких проєктів є **[Androidmeda](https://github.com/In3tinct/Androidmeda)** — Python-утиліта, яка приймає *decompiled* Java-джерела (наприклад, згенеровані `jadx`) і повертає значно очищену, прокоментовану та з маркуванням безпеки версію коду.

#### Key capabilities
* Renames meaningless identifiers generated by ProGuard / DexGuard / DashO / Allatori / … to *semantic* names.
* Detects and restructures **control-flow flattening**, replacing opaque switch-case state machines with normal loops / if-else constructs.
* Decrypts common **string encryption** patterns when possible.
* Injects **inline comments** that explain the purpose of complex blocks.
* Performs a *lightweight static security scan* and writes the findings to `vuln_report.json` with severity levels (informational → critical).

#### Installation
```bash
git clone https://github.com/In3tinct/Androidmeda
cd Androidmeda
pip3 install -r requirements.txt
```
#### Підготовка вхідних даних
1. Декомпілюйте цільовий APK за допомогою `jadx` (або будь-якого іншого декомпілятора) і залиште лише директорію *source*, яка містить файли `.java`:
```bash
jadx -d input_dir/ target.apk
```
2. (Опційно) Обріжте `input_dir/`, щоб він містив лише пакети додатків, які ви хочете аналізувати — це значно прискорить обробку та зменшить витрати на LLM.

#### Приклади використання

Віддалений провайдер (Gemini-1.5-flash):
```bash
export OPENAI_API_KEY=<your_key>
python3 androidmeda.py \
--llm_provider google \
--llm_model gemini-1.5-flash \
--source_dir input_dir/ \
--output_dir out/ \
--save_code true
```
Офлайн (локальний `ollama` бекенд з llama3.2):
```bash
python3 androidmeda.py \
--llm_provider ollama \
--llm_model llama3.2 \
--source_dir input_dir/ \
--output_dir out/ \
--save_code true
```
#### Вивід
* `out/vuln_report.json` – JSON-масив із `file`, `line`, `issue`, `severity`.
* A mirrored package tree with **деобфускованими `.java` файлами** (only if `--save_code true`).

#### Поради та усунення неполадок
* **Skipped class** ⇒ зазвичай спричинено методом, який неможливо розпарсити; ізолюйте пакет або оновіть регекс парсера.
* **Slow run-time / high token usage** ⇒ вкажіть `--source_dir` на *конкретні* пакети додатку замість всієї декомпіляції.
* Завжди *manually review* звіт про вразливості – галюцинації LLM можуть призвести до false positives / negatives.

#### Практична цінність – Crocodilus malware case study
Прогін сильно обфусцованого зразка 2025 *Crocodilus* banking trojan через Androidmeda скоротив час аналізу з *годин* до *хвилин*: інструмент відновив семантику call-graph, виявив виклики accessibility APIs та жорстко закодовані C2 URLs, і створив лаконічний звіт, який можна імпортувати в дашборди аналітиків.

---

### Цільове дешифрування Dalvik-рядків за допомогою DaliVM

**DaliVM** — Python-емулятор байткоду Dalvik, призначений для статичного відновлення значень, що існують лише під час виконання (особливо розшифрованих рядків), без підняття Android. Він виконує a *specific* метод всередині APK шляхом емуляції Dalvik opcodes і мокінгу Android/Java APIs.

**Робочий процес**
1. **Виберіть цільовий метод** за підписом Dalvik (`Lpkg/Class;->method(Args)Ret`). Приклади: `Lutil/Crypto;->decrypt(Ljava/lang/String;)Ljava/lang/String;`, `LMyClass;->compute(II)I`.
2. **Перелічте точки викликів** по всьому **multi-DEX** (`classes*.dex`) та **відновіть аргументи** шляхом зворотного трасування потоку даних, прямого пошуку та часткового виконання за потреби.
3. **Емулюйте метод** всередині Dalvik VM (підтримується 120+ opcodes для const/array/control/field/invoke, обробляється ініціалізація класу через `<clinit>`) та **збирайте значення повернення** (наприклад, розшифровані рядки).
4. **Обійдіть залежності часу виконання** за допомогою вбудованих моків для поширених Android API (Context, PackageManager, Signature, reflection, system services) та хуків для Java stdlib (String/StringBuilder/Integer/Math/Arrays/List/Iterator).
5. Якщо виконання зупиняється, **увімкніть трасування на рівні opcode** щоб бачити зміни PC/реєстрів і розширити обробники opcode.

**CLI usage**
```bash
# Emulate a decryptor and dump all returns
python emulate.py app.apk "Lcom/example/Decryptor;->decrypt"

# Verbose, debug trace, and limit outputs
python emulate.py app.apk "Lcom/example/Decryptor;->decrypt" -v --debug --limit 10
```
Outputs — це зібрані значення, що повертаються при кожному виклику; корисні для масового витягання рядків/конфігів під час malware triage або при роботі з сильно obfuscated apps.

## Посилання та додаткове читання

- [DaliVM: Python Dalvik emulator for static string decryption](https://github.com/fatalSec/DaliVM)
- [https://maddiestone.github.io/AndroidAppRE/obfuscation.html](https://maddiestone.github.io/AndroidAppRE/obfuscation.html)
- BlackHat USA 2018: “Unpacking the Packed Unpacker: Reverse Engineering an Android Anti-Analysis Library” [[video](https://www.youtube.com/watch?v=s0Tqi7fuOSU)]
- У цій доповіді розглянуто reverse engineering однієї з найскладніших anti-analysis native libraries, які я бачив у використанні Android application. Вона здебільшого охоплює obfuscation techniques у native code.
- REcon 2019: “The Path to the Payload: Android Edition” [[video](https://recon.cx/media-archive/2019/Session.005.Maddie_Stone.The_path_to_the_payload_Android_Edition-J3ZnNl2GYjEfa.mp4)]
- У цій доповіді описано низку obfuscation techniques, виключно в Java code, які Android botnet використовував для приховування своєї поведінки.
- Deobfuscating Android Apps with Androidmeda (blog post) – [mobile-hacker.com](https://www.mobile-hacker.com/2025/07/22/deobfuscating-android-apps-with-androidmeda-a-smarter-way-to-read-obfuscated-code/)
- Androidmeda source code – [https://github.com/In3tinct/Androidmeda](https://github.com/In3tinct/Androidmeda)

{{#include ../../banners/hacktricks-training.md}}
