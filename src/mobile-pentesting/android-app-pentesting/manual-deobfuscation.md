# 수동 난독화 해제 기법

{{#include ../../banners/hacktricks-training.md}}

## 수동 **난독화 해제 기법**

소프트웨어 보안의 영역에서, 난독화된 코드를 이해 가능하게 만드는 과정인 **난독화 해제(de-obfuscation)**는 매우 중요합니다. 이 가이드는 정적 분석 기법과 난독화 패턴 인식에 중점을 둔 다양한 난독화 해제 전략을 다룹니다. 또한 실습용 연습 문제를 소개하고, 더 고급 주제를 탐구하고자 하는 사람들을 위한 추가 자료를 제안합니다.

### **정적 난독화 해제 전략**

난독화의 성격에 따라 여러 전략을 적용할 수 있습니다:

- **DEX bytecode (Java)**: 효과적인 접근법 중 하나는 애플리케이션의 난독화 해제 메서드를 식별한 다음, 해당 메서드를 Java 파일로 복제하는 것입니다. 이 파일을 실행하여 대상 요소의 난독화를 역으로 수행합니다.
- **Java and Native Code**: 또 다른 방법은 난독화 해제 알고리즘을 Python 같은 스크립트 언어로 변환하는 것입니다. 이 전략은 알고리즘을 완전히 이해하는 것이 목표가 아니라 효과적으로 실행하는 것임을 강조합니다.

### **난독화 식별하기**

난독화된 코드를 인식하는 것이 난독화 해제의 첫 단계입니다. 주요 징후는 다음과 같습니다:

- Java 및 Android에서 문자열이 **없거나 섞여 있는 경우** — 문자열 난독화를 의심할 수 있습니다.
- assets 디렉토리의 **바이너리 파일 존재** 또는 `DexClassLoader` 호출 — 코드 언패킹과 동적 로딩을 시사합니다.
- **네이티브 라이브러리와 식별 불가한 JNI 함수의 동시 사용** — 네이티브 메서드 난독화를 의미할 수 있습니다.

## **난독화 해제에서의 동적 분석**

제어된 환경에서 코드를 실행함으로써 동적 분석은 **난독화된 코드가 실시간으로 어떻게 동작하는지 관찰할 수 있게 해줍니다**. 이 방법은 코드의 진짜 의도를 숨기기 위해 설계된 복잡한 난독화 패턴의 내부 작동을 밝혀내는 데 특히 효과적입니다.

### **동적 분석의 적용 사례**

- **런타임 복호화**: 많은 난독화 기법은 문자열이나 코드 조각을 암호화해 두고 런타임에만 복호화합니다. 동적 분석을 통해 복호화 시점의 요소들을 캡처하여 그 진짜 형태를 드러낼 수 있습니다.
- **난독화 기법 식별**: 애플리케이션 동작을 모니터링하면 code virtualization, packers, dynamic code generation과 같은 특정 난독화 기법을 식별하는 데 도움이 됩니다.
- **숨겨진 기능 발견**: 난독화된 코드는 정적 분석만으로는 드러나지 않는 숨겨진 기능을 포함할 수 있습니다. 동적 분석은 조건부로 실행되는 경로를 포함하여 모든 코드 경로를 관찰하여 이러한 숨겨진 기능을 밝혀냅니다.

### Automated De-obfuscation with LLMs (Androidmeda)

이전 섹션들이 완전 수동 전략에 초점을 맞추고 있는 반면, 2025년에 등장한 새로운 유형의 *대형 언어 모델(LLM) 기반* 도구는 대부분의 번거로운 이름 재정의 및 제어 흐름 복원 작업을 자동화할 수 있게 되었습니다.
대표적인 프로젝트 중 하나는 **[Androidmeda](https://github.com/In3tinct/Androidmeda)** – `jadx`로 생성된 것과 같은 *디컴파일된* Java 소스를 받아 코드의 가독성을 크게 향상시키고 주석과 보안 주석을 추가한 버전을 반환하는 Python 유틸리티입니다.

#### 주요 기능
* ProGuard / DexGuard / DashO / Allatori / …가 생성한 의미 없는 식별자를 *semantic* 이름으로 변경합니다.
* **control-flow flattening**을 감지하고 재구성하여 불투명한 switch-case 상태 머신을 정상적인 loops / if-else 구조로 대체합니다.
* 가능한 경우 일반적인 **string encryption** 패턴을 복호화합니다.
* 복잡한 블록의 목적을 설명하는 **inline comments**를 삽입합니다.
* *경량 정적 보안 스캔*을 수행하고 결과를 `vuln_report.json`에 심각도 수준(informational → critical)으로 기록합니다.

#### 설치
```bash
git clone https://github.com/In3tinct/Androidmeda
cd Androidmeda
pip3 install -r requirements.txt
```
#### 입력 준비
1. `jadx` (또는 다른 디컴파일러)를 사용해 대상 APK를 디컴파일하고 `.java` 파일이 들어있는 *source* 디렉토리만 유지하세요:
```bash
jadx -d input_dir/ target.apk
```
2. (선택) `input_dir/`를 분석하려는 애플리케이션 패키지들만 포함하도록 정리하세요 – 이렇게 하면 처리 속도가 크게 빨라지고 LLM 비용이 절감됩니다.

#### 사용 예시

원격 제공자 (Gemini-1.5-flash):
```bash
export OPENAI_API_KEY=<your_key>
python3 androidmeda.py \
--llm_provider google \
--llm_model gemini-1.5-flash \
--source_dir input_dir/ \
--output_dir out/ \
--save_code true
```
오프라인 (로컬 `ollama` 백엔드, llama3.2 사용):
```bash
python3 androidmeda.py \
--llm_provider ollama \
--llm_model llama3.2 \
--source_dir input_dir/ \
--output_dir out/ \
--save_code true
```
#### Output
* `out/vuln_report.json` – `file`, `line`, `issue`, `severity`를 포함한 JSON 배열.
* 미러된 패키지 트리와 **난독화 해제된 `.java` 파일들** (단, `--save_code true`일 경우에만).

#### Tips & troubleshooting
* **Skipped class** ⇒ 보통 파싱할 수 없는 메서드 때문에 발생합니다; 패키지를 분리해서 테스트하거나 파서 정규식(parser regex)을 업데이트하세요.
* **Slow run-time / high token usage** ⇒ 전체 디컴파일 대신 `--source_dir`를 특정 앱 패키지를 가리키도록 설정하세요.
* 취약점 보고서는 항상 *수동으로 검토*하세요 – LLM hallucinations는 false positives / negatives를 초래할 수 있습니다.

#### Practical value – Crocodilus malware 사례 연구
2025년 *Crocodilus* banking trojan의 심하게 난독화된 샘플을 Androidmeda에 통과시킨 결과 분석 시간이 *시간*에서 *분*으로 단축되었습니다: 도구는 호출 그래프 의미론을 복구하고, accessibility APIs에 대한 호출과 하드코딩된 C2 URLs을 드러냈으며, 분석가 대시보드로 가져갈 수 있는 간결한 보고서를 생성했습니다.

---

### DaliVM을 사용한 Dalvik 문자열 복호화 타깃팅

**DaliVM**은 Android를 실행하지 않고 정적으로 런타임 전용 값(특히 복호화된 문자열)을 복구하는 것을 목표로 하는 Python Dalvik 바이트코드 에뮬레이터입니다. Dalvik opcodes를 에뮬레이션하고 Android/Java APIs를 모킹하여 APK 내부의 *특정* 메서드를 실행합니다.

**워크플로우**
1. **대상 메서드 선택** — Dalvik 시그니처로 지정 (`Lpkg/Class;->method(Args)Ret`). 예: `Lutil/Crypto;->decrypt(Ljava/lang/String;)Ljava/lang/String;`, `LMyClass;->compute(II)I`.
2. **호출 지점 열거** — **multi-DEX** (`classes*.dex`) 전반에서 호출 지점을 찾고, 필요 시 역방향 데이터 흐름 추적, 전방 조회, 부분 실행을 통해 **인자 복원**.
3. Dalvik VM 내부에서 **메서드 에뮬레이션** 실행(120+ opcodes 지원, const/array/control/field/invoke 포함, `<clinit>`로 클래스 초기화 처리)하고 **반환 값 수집**(예: 복호화된 문자열).
4. **런타임 의존성 우회** — 공통 Android APIs(Context, PackageManager, Signature, reflection, system services)에 대한 내장 mocks와 Java stdlib(String/StringBuilder/Integer/Math/Arrays/List/Iterator)용 훅을 사용합니다.
5. 실행이 중단되면, PC/레지스터 변화를 확인하고 opcode 핸들러를 확장하기 위해 **opcode-level tracing**을 활성화하세요.

**CLI 사용법**
```bash
# Emulate a decryptor and dump all returns
python emulate.py app.apk "Lcom/example/Decryptor;->decrypt"

# Verbose, debug trace, and limit outputs
python emulate.py app.apk "Lcom/example/Decryptor;->decrypt" -v --debug --limit 10
```
Outputs는 호출당 수집된 return values입니다. 이는 malware triage나 고도로 obfuscated된 앱에서 bulk string/config extraction에 유용합니다.

## 참고자료 및 추가 읽을거리

- [DaliVM: Python Dalvik emulator for static string decryption](https://github.com/fatalSec/DaliVM)
- [https://maddiestone.github.io/AndroidAppRE/obfuscation.html](https://maddiestone.github.io/AndroidAppRE/obfuscation.html)
- BlackHat USA 2018: “Unpacking the Packed Unpacker: Reverse Engineering an Android Anti-Analysis Library” [[video](https://www.youtube.com/watch?v=s0Tqi7fuOSU)]
- 이 토크는 Android 애플리케이션에서 사용되는, 내가 본 것 중 가장 복잡한 anti-analysis native libraries 중 하나를 reverse engineering하는 내용을 다룹니다. 주로 native code에서의 obfuscation techniques를 다룹니다.
- REcon 2019: “The Path to the Payload: Android Edition” [[video](https://recon.cx/media-archive/2019/Session.005.Maddie_Stone.The_path_to_the_payload_Android_Edition-J3ZnNl2GYjEfa.mp4)]
- 이 토크는 Android botnet이 자신의 동작을 숨기기 위해 Java code에서만 사용한 일련의 obfuscation techniques를 설명합니다.
- Deobfuscating Android Apps with Androidmeda (블로그 게시물) – [mobile-hacker.com](https://www.mobile-hacker.com/2025/07/22/deobfuscating-android-apps-with-androidmeda-a-smarter-way-to-read-obfuscated-code/)
- Androidmeda source code – [https://github.com/In3tinct/Androidmeda](https://github.com/In3tinct/Androidmeda)

{{#include ../../banners/hacktricks-training.md}}
