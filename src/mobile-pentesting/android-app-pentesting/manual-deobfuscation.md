# Χειροκίνητες τεχνικές **De-obfuscation**

{{#include ../../banners/hacktricks-training.md}}

## Χειροκίνητες **De-obfuscation Techniques**

Στον χώρο της **software security**, η διαδικασία καθιστώντας κρυμμένο code κατανοητό, γνωστή ως **de-obfuscation**, είναι κρίσιμη. Αυτός ο οδηγός εξετάζει διάφορες στρατηγικές για de-obfuscation, εστιάζοντας σε τεχνικές static analysis και στην αναγνώριση προτύπων obfuscation. Επιπλέον, εισάγει μια άσκηση για πρακτική εφαρμογή και προτείνει επιπλέον πόρους για όσους ενδιαφέρονται να εξερευνήσουν πιο προχωρημένα θέματα.

### Στρατηγικές για Static De-obfuscation

Όταν αντιμετωπίζετε obfuscated code, μπορούν να εφαρμοστούν διάφορες στρατηγικές ανάλογα με τη φύση του obfuscation:

- **DEX bytecode (Java)**: Μια αποτελεσματική προσέγγιση περιλαμβάνει την αναγνώριση των μεθόδων de-obfuscation της εφαρμογής, και στη συνέχεια την αναπαραγωγή αυτών των μεθόδων σε ένα αρχείο Java. Αυτό το αρχείο εκτελείται για να αντιστραφεί το obfuscation στα στοχευμένα στοιχεία.
- **Java and Native Code**: Μια άλλη μέθοδος είναι να μεταφράσετε τον αλγόριθμο de-obfuscation σε μια scripting γλώσσα όπως η Python. Αυτή η στρατηγική τονίζει ότι ο κύριος στόχος δεν είναι πάντα να κατανοήσετε πλήρως τον αλγόριθμο, αλλά να τον εκτελέσετε αποτελεσματικά.

### Αναγνώριση Obfuscation

Η αναγνώριση obfuscated code είναι το πρώτο βήμα στη διαδικασία de-obfuscation. Βασικοί δείκτες περιλαμβάνουν:

- Η **απουσία ή η ανακάτωσή των strings** σε Java και Android, που μπορεί να υποδεικνύει string obfuscation.
- Η παρουσία δυαδικών αρχείων στον φάκελο assets ή κλήσεις σε `DexClassLoader`, που υπονοούν code unpacking και dynamic loading.
- Η χρήση native libraries μαζί με μη αναγνωρίσιμες JNI functions, υποδεικνύοντας πιθανή obfuscation των native methods.

## **Dynamic Analysis in De-obfuscation**

Εκτελώντας τον code σε ένα ελεγχόμενο περιβάλλον, η δυναμική ανάλυση επιτρέπει την παρατήρηση του πώς το obfuscated code συμπεριφέρεται σε πραγματικό χρόνο. Αυτή η μέθοδος είναι ιδιαίτερα αποτελεσματική στην αποκάλυψη των εσωτερικών μηχανισμών σύνθετων obfuscation patterns που σχεδιάζονται για να κρύψουν τον πραγματικό σκοπό του code.

### Εφαρμογές της Dynamic Analysis

- **Runtime Decryption**: Πολλές τεχνικές obfuscation περιλαμβάνουν την κρυπτογράφηση strings ή κομματιών του code που αποκρυπτογραφούνται μόνο κατά το runtime. Μέσω dynamic analysis, αυτά τα κρυπτογραφημένα στοιχεία μπορούν να παραληφθούν τη στιγμή της αποκρυπτογράφησης, αποκαλύπτοντας την πραγματική τους μορφή.
- **Identifying Obfuscation Techniques**: Με την παρακολούθηση της συμπεριφοράς της εφαρμογής, η dynamic analysis μπορεί να βοηθήσει στην αναγνώριση συγκεκριμένων τεχνικών obfuscation που χρησιμοποιούνται, όπως code virtualization, packers, ή dynamic code generation.
- **Uncovering Hidden Functionality**: Το obfuscated code μπορεί να περιέχει κρυφές λειτουργίες που δεν είναι εμφανείς μόνο με static analysis. Η dynamic analysis επιτρέπει την παρατήρηση όλων των code paths, συμπεριλαμβανομένων αυτών που εκτελούνται υπό συνθήκες, για να αποκαλύψει τέτοιες κρυφές λειτουργίες.

### Automated De-obfuscation with LLMs (Androidmeda)

Ενώ τα προηγούμενα τμήματα εστιάζουν σε πλήρως χειροκίνητες στρατηγικές, το 2025 εμφανίστηκε μια νέα κατηγορία εργαλείων με δυνατότητα αυτοματοποίησης, τροφοδοτούμενων από Large-Language-Model (LLM), που μπορούν να αυτοματοποιήσουν το μεγαλύτερο μέρος της κουραστικής εργασίας μετονομασίας και ανάκτησης control-flow.
Ένα αντιπροσωπευτικό project είναι το **[Androidmeda](https://github.com/In3tinct/Androidmeda)** – ένα Python utility που παίρνει decompiled Java sources (π.χ. παραγόμενα από `jadx`) και επιστρέφει μια σημαντικά καθαρισμένη, σχολιασμένη και security-annotated έκδοση του code.

#### Κύριες δυνατότητες
* Μετονομασία ασήμαντων identifiers που παράγονται από ProGuard / DexGuard / DashO / Allatori / … σε semantic ονόματα.
* Εντοπισμός και αναδιάρθρωση του **control-flow flattening**, αντικαθιστώντας αδιαφανείς μηχανές κατάστασης switch-case με κανονικούς βρόχους / if-else constructs.
* Αποκρυπτογράφηση κοινών patterns **string encryption** όταν είναι δυνατόν.
* Έγχυση **inline comments** που εξηγούν το σκοπό σύνθετων μπλοκ.
* Εκτέλεση ενός lightweight static security scan και εγγραφή των ευρημάτων σε `vuln_report.json` με επίπεδα severity (informational → critical).

#### Installation
```bash
git clone https://github.com/In3tinct/Androidmeda
cd Androidmeda
pip3 install -r requirements.txt
```
#### Προετοιμασία των εισόδων
1. Decompile το target APK με `jadx` (ή οποιονδήποτε άλλο decompiler) και διατήρησε μόνο τον φάκελο *source* που περιέχει τα αρχεία `.java`:
```bash
jadx -d input_dir/ target.apk
```
2. (Προαιρετικό) Περιορίστε το `input_dir/` ώστε να περιέχει μόνο τα πακέτα εφαρμογής που θέλετε να αναλύσετε — αυτό επιταχύνει σημαντικά την επεξεργασία και μειώνει το κόστος των LLM.

#### Παραδείγματα χρήσης

Απομακρυσμένος πάροχος (Gemini-1.5-flash):
```bash
export OPENAI_API_KEY=<your_key>
python3 androidmeda.py \
--llm_provider google \
--llm_model gemini-1.5-flash \
--source_dir input_dir/ \
--output_dir out/ \
--save_code true
```
Αποσυνδεδεμένο (τοπικό `ollama` backend με llama3.2):
```bash
python3 androidmeda.py \
--llm_provider ollama \
--llm_model llama3.2 \
--source_dir input_dir/ \
--output_dir out/ \
--save_code true
```
#### Έξοδος
* `out/vuln_report.json` – Πίνακας JSON με `file`, `line`, `issue`, `severity`.
* Ένα καθρεφτισμένο δέντρο πακέτων με **de-obfuscated `.java` files** (μόνο αν `--save_code true`).

#### Συμβουλές & αντιμετώπιση προβλημάτων
* **Skipped class** ⇒ συνήθως προκαλείται από μια μη-αναγνώσιμη μέθοδο· απομονώστε το πακέτο ή ενημερώστε το regex του parser.
* **Slow run-time / high token usage** ⇒ δείξτε `--source_dir` σε *συγκεκριμένα* πακέτα της εφαρμογής αντί για ολόκληρο το decompile.
* Πάντα *επιθεωρείτε χειροκίνητα* την αναφορά ευπαθειών – οι παραισθήσεις των LLM μπορεί να οδηγήσουν σε false positives / false negatives.

#### Πρακτική αξία – Μελέτη περίπτωσης malware Crocodilus
Η τροφοδότηση ενός βαριά obfuscated δείγματος από τον τραπεζικό trojan *Crocodilus* του 2025 μέσω του Androidmeda μείωσε τον χρόνο ανάλυσης από *ώρες* σε *λεπτά*: το εργαλείο αποκατέστησε τη σημασιολογία του call-graph, αποκάλυψε κλήσεις σε accessibility APIs και hard-coded C2 URLs, και παρήγαγε μια σύντομη αναφορά που μπορούσε να εισαχθεί στα dashboards των αναλυτών.

---

### Στοχευμένη αποκρυπτογράφηση συμβολοσειρών Dalvik με DaliVM

**DaliVM** είναι ένας Python Dalvik bytecode emulator που στοχεύει στην στατική ανάκτηση τιμών που υπάρχουν μόνο κατά το runtime (ειδικά αποκρυπτογραφημένων strings) χωρίς να χρειάζεται να τρέξετε Android. Εκτελεί μια *συγκεκριμένη* μέθοδο μέσα σε ένα APK προσομοιώνοντας Dalvik opcodes και κάνοντας mocking Android/Java APIs.

**Ροή εργασίας**
1. **Select target method** by Dalvik signature (`Lpkg/Class;->method(Args)Ret`). Παραδείγματα: `Lutil/Crypto;->decrypt(Ljava/lang/String;)Ljava/lang/String;`, `LMyClass;->compute(II)I`.
2. **Enumerate call sites** across **multi-DEX** (`classes*.dex`) και **ανακατασκευάστε τα ορίσματα** μέσω backward data-flow tracing, forward lookup, και μερικής εκτέλεσης όταν χρειάζεται.
3. **Emulate the method** μέσα στο Dalvik VM (υποστηρίζονται 120+ opcodes σε const/array/control/field/invoke, χειρίζεται την αρχικοποίηση κλάσης μέσω `<clinit>`) και **συλλέξτε τις επιστρεφόμενες τιμές** (π.χ. αποκρυπτογραφημένες συμβολοσειρές).
4. **Παρακάμψτε runtime εξαρτήσεις** χρησιμοποιώντας ενσωματωμένα mocks για κοινά Android APIs (Context, PackageManager, Signature, reflection, system services) και hooks για Java stdlib (String/StringBuilder/Integer/Math/Arrays/List/Iterator).
5. Αν η εκτέλεση σταματήσει, **ενεργοποιήστε ανίχνευση σε επίπεδο opcode** για να δείτε αλλαγές σε PC/registers και να επεκτείνετε τους opcode handlers.

**Χρήση CLI**
```bash
# Emulate a decryptor and dump all returns
python emulate.py app.apk "Lcom/example/Decryptor;->decrypt"

# Verbose, debug trace, and limit outputs
python emulate.py app.apk "Lcom/example/Decryptor;->decrypt" -v --debug --limit 10
```
Outputs είναι οι συλλεγμένες τιμές επιστροφής ανά κλήση· χρήσιμες για μαζική εξαγωγή string/config κατά το malware triage ή για έντονα obfuscated apps.

## Αναφορές και Περαιτέρω Ανάγνωση

- [DaliVM: Python Dalvik emulator for static string decryption](https://github.com/fatalSec/DaliVM)
- [https://maddiestone.github.io/AndroidAppRE/obfuscation.html](https://maddiestone.github.io/AndroidAppRE/obfuscation.html)
- BlackHat USA 2018: “Unpacking the Packed Unpacker: Reverse Engineering an Android Anti-Analysis Library” [[video](https://www.youtube.com/watch?v=s0Tqi7fuOSU)]
- Αυτή η ομιλία αναλύει το reverse engineering ενός από τα πιο σύνθετα anti-analysis native libraries που έχω δει να χρησιμοποιούνται σε μια εφαρμογή Android. Καλύπτει κυρίως obfuscation techniques σε native code.
- REcon 2019: “The Path to the Payload: Android Edition” [[video](https://recon.cx/media-archive/2019/Session.005.Maddie_Stone.The_path_to_the_payload_Android_Edition-J3ZnNl2GYjEfa.mp4)]
- Αυτή η ομιλία συζητά μια σειρά obfuscation techniques, αποκλειστικά σε Java code, που ένα Android botnet χρησιμοποιούσε για να κρύβει τη συμπεριφορά του.
- Deobfuscating Android Apps with Androidmeda (blog post) – [mobile-hacker.com](https://www.mobile-hacker.com/2025/07/22/deobfuscating-android-apps-with-androidmeda-a-smarter-way-to-read-obfuscated-code/)
- Androidmeda source code – [https://github.com/In3tinct/Androidmeda](https://github.com/In3tinct/Androidmeda)

{{#include ../../banners/hacktricks-training.md}}
