# Manual de Técnicas de Desofuscação

{{#include ../../banners/hacktricks-training.md}}

## Manual **Técnicas de Desofuscação**

No âmbito da **segurança de software**, o processo de tornar código obscuro compreensível, conhecido como **desofuscação**, é crucial. Este guia explora várias estratégias de desofuscação, focando em técnicas de análise estática e no reconhecimento de padrões de ofuscação. Além disso, introduz um exercício para aplicação prática e sugere recursos para quem quiser aprofundar tópicos avançados.

### **Estratégias para Desofuscação Estática**

Ao lidar com código **ofuscado**, várias estratégias podem ser empregadas dependendo da natureza da ofuscação:

- **DEX bytecode (Java)**: Uma abordagem eficaz envolve identificar os métodos de desofuscação da aplicação e então replicar esses métodos em um arquivo Java. Esse arquivo é executado para reverter a ofuscação nos elementos alvo.
- **Java and Native Code**: Outra técnica é traduzir o algoritmo de desofuscação para uma linguagem de script como Python. Essa estratégia mostra que o objetivo principal não é entender completamente o algoritmo, mas executá-lo de forma eficaz.

### **Identificando Ofuscação**

Reconhecer código ofuscado é o primeiro passo no processo de desofuscação. Indicadores chave incluem:

- A **ausência ou embaralhamento de strings** em Java e Android, que pode sugerir string obfuscation.
- A **presença de arquivos binários** no diretório assets ou chamadas a `DexClassLoader`, indicando unpacking de código e carregamento dinâmico.
- O uso de **native libraries** junto com funções JNI não identificáveis, indicando potencial ofuscação de métodos nativos.

## **Análise Dinâmica na Desofuscação**

Executando o código em um ambiente controlado, a análise dinâmica **permite observar como o código ofuscado se comporta em tempo real**. Esse método é especialmente eficaz para revelar o funcionamento interno de padrões complexos de ofuscação projetados para esconder a real intenção do código.

### **Aplicações da Análise Dinâmica**

- **Runtime Decryption**: Muitas técnicas de ofuscação envolvem criptografar strings ou segmentos de código que só são decriptados em tempo de execução. Através da análise dinâmica, esses elementos criptografados podem ser capturados no momento da decriptação, revelando sua forma real.
- **Identificação de Técnicas de Ofuscação**: Monitorando o comportamento da aplicação, a análise dinâmica pode ajudar a identificar técnicas específicas de ofuscação sendo usadas, como code virtualization, packers ou dynamic code generation.
- **Descoberta de Funcionalidades Ocultas**: Código ofuscado pode conter funcionalidades ocultas que não são aparentes apenas com análise estática. A análise dinâmica permite observar todos os caminhos de código, incluindo aqueles executados condicionalmente, para revelar tais funcionalidades ocultas.

### De-obfuscação Automatizada com LLMs (Androidmeda)

Enquanto as seções anteriores focam em estratégias totalmente manuais, em 2025 surgiu uma nova classe de ferramentas *Large-Language-Model (LLM) powered* que pode automatizar grande parte do trabalho tedioso de renomear e recuperar fluxo de controle.
Um projeto representativo é **[Androidmeda](https://github.com/In3tinct/Androidmeda)** – uma utilidade Python que recebe fontes Java *decompiled* (por exemplo produzidas por `jadx`) e retorna uma versão bastante limpa, comentada e anotada com aspectos de segurança do código.

#### Principais capacidades
* Renomeia identificadores sem sentido gerados por ProGuard / DexGuard / DashO / Allatori / … para nomes *semânticos*.
* Detecta e reestrutura **control-flow flattening**, substituindo máquinas de estado opacas baseadas em switch-case por loops normais / if-else.
* Decripta padrões comuns de **string encryption** quando possível.
* Injeta **inline comments** que explicam o propósito de blocos complexos.
* Realiza uma *lightweight static security scan* e escreve os achados em `vuln_report.json` com níveis de severidade (informational → critical).

#### Instalação
```bash
git clone https://github.com/In3tinct/Androidmeda
cd Androidmeda
pip3 install -r requirements.txt
```
#### Preparando as entradas
1. Decompile o APK alvo com `jadx` (ou qualquer outro decompiler) e mantenha apenas o diretório *source* que contém os arquivos `.java`:
```bash
jadx -d input_dir/ target.apk
```
2. (Opcional) Reduza `input_dir/` para que contenha apenas os pacotes da aplicação que você quer analisar – isso acelera massivamente o processamento e reduz os custos de LLM.

#### Exemplos de uso

Provedor remoto (Gemini-1.5-flash):
```bash
export OPENAI_API_KEY=<your_key>
python3 androidmeda.py \
--llm_provider google \
--llm_model gemini-1.5-flash \
--source_dir input_dir/ \
--output_dir out/ \
--save_code true
```
Offline (backend local `ollama` com llama3.2):
```bash
python3 androidmeda.py \
--llm_provider ollama \
--llm_model llama3.2 \
--source_dir input_dir/ \
--output_dir out/ \
--save_code true
```
#### Output
* `out/vuln_report.json` – Array JSON com `file`, `line`, `issue`, `severity`.
* A mirrored package tree com **arquivos `.java` desofuscados** (somente se `--save_code true`).

#### Tips & troubleshooting
* **Classe ignorada** ⇒ geralmente causada por um método inválido/parsers; isole o pacote ou atualize a regex do parser.
* **Execução lenta / alto uso de tokens** ⇒ aponte `--source_dir` para pacotes de app *específicos* em vez de toda a decompilação.
* Sempre *revise manualmente* o relatório de vulnerabilidades – alucinações de LLM podem levar a falsos positivos / negativos.

#### Practical value – Crocodilus malware case study
Alimentar uma amostra fortemente ofuscada do trojan bancário *Crocodilus* de 2025 pelo Androidmeda reduziu o tempo de análise de *horas* para *minutos*: a ferramenta recuperou a semântica do call-graph, revelou chamadas para APIs de acessibilidade e URLs C2 hard-coded, e produziu um relatório conciso que pôde ser importado nos dashboards dos analistas.

---

### Targeted Dalvik string decryption with DaliVM

**DaliVM** é um emulador Python de bytecode Dalvik voltado para recuperar estaticamente valores presentes apenas em tempo de execução (especialmente strings descriptografadas) sem iniciar o Android. Ele executa um método *específico* dentro de um APK emulando opcodes Dalvik e mockando APIs Android/Java.

**Workflow**
1. **Selecione o método alvo** pela assinatura Dalvik (`Lpkg/Class;->method(Args)Ret`). Exemplos: `Lutil/Crypto;->decrypt(Ljava/lang/String;)Ljava/lang/String;`, `LMyClass;->compute(II)I`.
2. **Enumere os call sites** através de **multi-DEX** (`classes*.dex`) e **reconstrua os argumentos** via rastreamento reverso de fluxo de dados, busca direta e execução parcial quando necessário.
3. **Emule o método** dentro da Dalvik VM (cobre 120+ opcodes incluindo const/array/control/field/invoke, lida com inicialização de classe via `<clinit>`) e **colete valores de retorno** (ex.: strings descriptografadas).
4. **Contorne dependências de runtime** usando mocks internos para APIs Android comuns (Context, PackageManager, Signature, reflection, system services) e hooks para a stdlib Java (String/StringBuilder/Integer/Math/Arrays/List/Iterator).
5. Se a execução travar, **ative o rastreio ao nível de opcode** para ver alterações de PC/register e estenda os handlers de opcode.

**CLI usage**
```bash
# Emulate a decryptor and dump all returns
python emulate.py app.apk "Lcom/example/Decryptor;->decrypt"

# Verbose, debug trace, and limit outputs
python emulate.py app.apk "Lcom/example/Decryptor;->decrypt" -v --debug --limit 10
```
Outputs são os valores de retorno coletados por invocação; úteis para extração em massa de strings/config durante triagem de malware ou apps fortemente ofuscados.

## Referências e Leituras Adicionais

- [DaliVM: Python Dalvik emulator for static string decryption](https://github.com/fatalSec/DaliVM)
- [https://maddiestone.github.io/AndroidAppRE/obfuscation.html](https://maddiestone.github.io/AndroidAppRE/obfuscation.html)
- BlackHat USA 2018: “Unpacking the Packed Unpacker: Reverse Engineering an Android Anti-Analysis Library” [[video](https://www.youtube.com/watch?v=s0Tqi7fuOSU)]
- Esta palestra aborda a engenharia reversa de uma das bibliotecas nativas anti-analysis mais complexas que já vi sendo usada por um aplicativo Android. Cobre principalmente técnicas de ofuscação em código nativo.
- REcon 2019: “The Path to the Payload: Android Edition” [[video](https://recon.cx/media-archive/2019/Session.005.Maddie_Stone.The_path_to_the_payload_Android_Edition-J3ZnNl2GYjEfa.mp4)]
- Esta palestra discute uma série de técnicas de ofuscação, exclusivamente em código Java, que um botnet Android estava usando para ocultar seu comportamento.
- Deobfuscating Android Apps with Androidmeda (blog post) – [mobile-hacker.com](https://www.mobile-hacker.com/2025/07/22/deobfuscating-android-apps-with-androidmeda-a-smarter-way-to-read-obfuscated-code/)
- Androidmeda source code – [https://github.com/In3tinct/Androidmeda](https://github.com/In3tinct/Androidmeda)

{{#include ../../banners/hacktricks-training.md}}
