# Handmatige De-obfuskering Tegnieke

{{#include ../../banners/hacktricks-training.md}}

## Handmatige **De-obfuskering Tegnieke**

In die veld van **software security** is die proses om verhulde kode verstaanbaar te maak, bekend as **de-obfuskering**, van kritieke belang. Hierdie gids behandel verskeie strategiese benaderings vir de-obfuskering, met fokus op statiese ontledingstegnieke en die herkenning van obfuskasiepatrone. Daarbenewens bevat dit ’n oefening vir praktiese toepassing en verwysings na verdere bronne vir diegene wat meer gevorderde onderwerpe wil verken.

### **Strategieë vir Statiese De-obfuskering**

Wanneer jy met **obfuscated code** werk, kan verskeie strategieë toegepas word, afhangend van die aard van die obfuskasie:

- **DEX bytecode (Java)**: Een effektiewe benadering behels die identifisering van die toepassing se de-obfuskering-metodes, en dan die reproduksie van daardie metodes in ’n Java-lêer. Hierdie lêer word uitgevoer om die obfuskasie op die geteikende elemente om te keer.
- **Java and Native Code**: ’n Ander metode is om die de-obfuskering-algoritme in ’n scriptingtaal soos Python te vertaal. Hierdie strategie beklemtoon dat die primêre doel nie is om die algoritme volledig te verstaan nie, maar om dit effektief uit te voer.

### **Identifisering van Obfuskasie**

Om obfuscated code te herken is die eerste stap in die de-obfuskering-proses. Sleutelaanwysers sluit in:

- Die **afwesigheid of deurmekaarmaak van strings** in Java en Android, wat daarop kan dui dat string obfuscation gebruik word.
- Die **teenwoordigheid van binary files** in die assets-directory of oproepe na `DexClassLoader`, wat dui op code unpacking en dynamic loading.
- Die gebruik van **native libraries saam met onidentifiseerbare JNI functions**, wat moontlike obfuskasie van native methods aandui.

## **Dynamic Analysis in De-obfuskering**

Deur die kode in ’n beheerde omgewing uit te voer, laat dynamic analysis toe dat jy kan waarnem hoe die obfuscated code in real time gedra. Hierdie metode is veral doeltreffend om die innerlike werking van komplekse obfuskasiepatrone bloot te lê wat bedoel is om die ware bedoeling van die kode te verberg.

### **Toepassings van Dynamic Analysis**

- **Runtime Decryption**: Baie obfuskasietegnieke behels die enkripsie van strings of kode-segmente wat slegs by runtime ontsleutel word. Deur dynamic analysis kan hierdie geënkripteerde elemente op die oomblik van dekripsie vasgevang word en hul ware vorm openbaar.
- **Identifying Obfuscation Techniques**: Deur die toepassing se gedrag te monitor kan dynamic analysis help om spesifieke obfuskasietegnieke te identifiseer wat gebruik word, soos code virtualization, packers, of dynamic code generation.
- **Uncovering Hidden Functionality**: Obfuscated code mag verborgen funksionaliteit bevat wat nie deur statiese ontleding alleen duidelik is nie. Dynamic analysis maak dit moontlik om alle code paths, insluitend voorwaardelik uitgevoerde paaie, te observeer en sulke verborgen funksies te openbaar.

### Automated De-obfuscation with LLMs (Androidmeda)

Terwyl die vorige afdelings op volledig manuele strategieë fokus, het in 2025 ’n nuwe klas van *Large-Language-Model (LLM) powered* gereedskap ontstaan wat die meeste van die vervelige hernoem- en control-flow recovery-werk kan outomatiseer.
Een verteenwoordigende projek is **[Androidmeda](https://github.com/In3tinct/Androidmeda)** – ’n Python-hulpmiddel wat *decompiled* Java-bronne (bv. geproduseer deur `jadx`) neem en ’n aansienlik opgeskuifde, van kommentaar voorsiene en security-gedetailleerde weergawe van die kode teruggee.

#### Sleutelvermoëns
* Hernoem betekenislose identifiers gegenereer deur ProGuard / DexGuard / DashO / Allatori / … na *semantic* names.
* Detects and restructures **control-flow flattening**, vervang ondoorgrondelike switch-case state machines met normale loops / if-else strukture.
* Decrypts common **string encryption** patterns where possible.
* Injects **inline comments** wat die doel van komplekse blokke verduidelik.
* Performs ’n *lightweight static security scan* en skryf die bevindinge na `vuln_report.json` met severity-vlakke (informational → critical).

#### Installation
```bash
git clone https://github.com/In3tinct/Androidmeda
cd Androidmeda
pip3 install -r requirements.txt
```
#### Voorbereiding van die insette
1. Dekompileer die teiken-APK met `jadx` (of enige ander dekompiler) en hou slegs die *source* gids wat die `.java` lêers bevat:
```bash
jadx -d input_dir/ target.apk
```
2. (Opsioneel) Beperk `input_dir/` sodat dit slegs die toepassingspakkette bevat wat jy wil ontleed – dit versnel verwerking en verminder LLM-koste aansienlik.

#### Gebruiksvoorbeelde

Afgeleë verskaffer (Gemini-1.5-flash):
```bash
export OPENAI_API_KEY=<your_key>
python3 androidmeda.py \
--llm_provider google \
--llm_model gemini-1.5-flash \
--source_dir input_dir/ \
--output_dir out/ \
--save_code true
```
Aflyn (lokale `ollama` backend met llama3.2):
```bash
python3 androidmeda.py \
--llm_provider ollama \
--llm_model llama3.2 \
--source_dir input_dir/ \
--output_dir out/ \
--save_code true
```
#### Uitset
* `out/vuln_report.json` – JSON-array met `file`, `line`, `issue`, `severity`.
* 'n gespieëlde pakketboom met **de-obfuscated `.java` files** (slegs as `--save_code true`).

#### Wenke & probleemoplossing
* **Skipped class** ⇒ gewoonlik veroorsaak deur 'n nie-ontleedbare metode; isoleer die pakket of werk die parser regex op.
* **Slow run-time / high token usage** ⇒ wys `--source_dir` na *spesifieke* app-pakkette in plaas van die hele decompile.
* Hersien altyd *manueel* die kwetsbaarheidsverslag – LLM hallucinations kan lei tot vals positiewe / negatiewe.

#### Praktiese waarde – Crocodilus malware gevallestudie
Deur 'n swaar geobfuskeerde monster van die 2025 *Crocodilus* banking trojan deur Androidmeda te voer, is analysetyd van *ure* tot *minute* verminder: die instrument het call-graph semantics herstel, oproepe na accessibility APIs en hard-gekodeerde C2 URLs onthul, en 'n bondige verslag geproduseer wat in ontleders’ dashboards ingevoer kon word.

---

### Gerigte Dalvik string-dekryptering met DaliVM

**DaliVM** is 'n Python Dalvik bytecode-emulator wat gemik is op staties herstel van runtime-only waardes (veral decrypted strings) sonder om Android te laat loop. Dit voer 'n *spesifieke* metode binne 'n APK uit deur Dalvik-opcodes te emuleer en Android/Java APIs te mock.

**Werkvloei**
1. **Select target method** by Dalvik signature (`Lpkg/Class;->method(Args)Ret`). Examples: `Lutil/Crypto;->decrypt(Ljava/lang/String;)Ljava/lang/String;`, `LMyClass;->compute(II)I`.
2. **Enumerate call sites** across **multi-DEX** (`classes*.dex`) and **reconstruct arguments** via backward data-flow tracing, forward lookup, and partial execution when needed.
3. **Emulate the method** inside the Dalvik VM (covers 120+ opcodes across const/array/control/field/invoke, handles class init via `<clinit>`) and **collect return values** (e.g., decrypted strings).
4. **Bypass runtime dependencies** using built-in mocks for common Android APIs (Context, PackageManager, Signature, reflection, system services) and hooks for Java stdlib (String/StringBuilder/Integer/Math/Arrays/List/Iterator).
5. If execution stalls, **enable opcode-level tracing** to see PC/register changes and extend opcode handlers.

**CLI gebruik**
```bash
# Emulate a decryptor and dump all returns
python emulate.py app.apk "Lcom/example/Decryptor;->decrypt"

# Verbose, debug trace, and limit outputs
python emulate.py app.apk "Lcom/example/Decryptor;->decrypt" -v --debug --limit 10
```
Outputs is die versamelde teruggegee-waardes per aanroep; nuttig vir massiewe string/config-uittreksels tydens malware-triage of swaar geobfuskateerde apps.

## Verwysings en Verdere Leesstof

- [DaliVM: Python Dalvik emulator for static string decryption](https://github.com/fatalSec/DaliVM)
- [https://maddiestone.github.io/AndroidAppRE/obfuscation.html](https://maddiestone.github.io/AndroidAppRE/obfuscation.html)
- BlackHat USA 2018: “Unpacking the Packed Unpacker: Reverse Engineering an Android Anti-Analysis Library” [[video](https://www.youtube.com/watch?v=s0Tqi7fuOSU)]
- Hierdie praatjie gaan oor reverse engineering van een van die mees komplekse anti-analysis native libraries wat ek in 'n Android application gesien het. Dit dek hoofsaaklik obfuscation techniques in native code.
- REcon 2019: “The Path to the Payload: Android Edition” [[video](https://recon.cx/media-archive/2019/Session.005.Maddie_Stone.The_path_to_the_payload_Android_Edition-J3ZnNl2GYjEfa.mp4)]
- Hierdie praatjie bespreek 'n reeks obfuscation techniques, uitsluitlik in Java code, wat 'n Android botnet gebruik het om sy gedrag te verberg.
- Deobfuscating Android Apps with Androidmeda (blog post) – [mobile-hacker.com](https://www.mobile-hacker.com/2025/07/22/deobfuscating-android-apps-with-androidmeda-a-smarter-way-to-read-obfuscated-code/)
- Androidmeda source code – [https://github.com/In3tinct/Androidmeda](https://github.com/In3tinct/Androidmeda)

{{#include ../../banners/hacktricks-training.md}}
