# Android Pixel Stealing via Window Blur and VSync (Pixnapping/GPU.zip)

{{#include ../../banners/hacktricks-training.md}}

Pixnapping (CVE-2025-48561) is a cross-app pixel-stealing attack on Android. Any installed app, with zero declared permissions, can recover pixels rendered by other apps or arbitrary websites by abusing Android UI/graphics primitives and a GPU compression timing side channel (GPU.zip). Demonstrated targets include Gmail/Google Accounts in the browser and apps such as Signal, Google Authenticator, Venmo, and Google Maps. TOTP codes can be recovered in under 30 seconds with no screenshots or special permissions.

Key ideas
- Force victim UI surfaces into the compositor’s pipeline (SurfaceFlinger) via intents and task mechanics.
- Overlay a semi-transparent activity to precisely cover the sensitive region and invoke Android’s window blur on that region, inducing color-dependent GPU work.
- Measure per-frame rendering/compression time via VSync callbacks; timing differences leak the underlying pixel values. Sweep the region and OCR the reconstructed bitmap.

Threat model and prerequisites
- Attacker controls any Android app; no runtime permissions or manifest-declared privileges.
- Victim content must be visible on screen (e.g., messages, emails, map tiles, 2FA codes). Non-rendered secrets are out of scope.

What makes this work on Android
- Activities from other apps can be programmatically invoked (or brought to front) so their UI is submitted to the compositor.
- A translucent activity from the attacker can sit on top without SYSTEM_ALERT_WINDOW, while still causing operations to apply to what is beneath when using the window blur API.
- Accurate frame-timing sources (VSync/FrameMetrics) expose measurable timing variation due to GPU/DSC-like compression (GPU.zip).

Attack pipeline (high level)
1) Submit victim pixels to the render pipeline
- Launch/activate the target activity so its sensitive UI gets composed.
- Ensure the attacker’s activity is translucent so the underlying surface remains visible/composited.

2) Induce per-pixel GPU work on the sensitive region
- Position a semi-transparent overlay precisely over the region of interest (ROI) (e.g., known coordinates for TOTP digits).
- Invoke the window blur API over that ROI so the GPU performs color-dependent work for the covered pixels.

3) Side-channel readout via GPU.zip + VSync timing
- Use VSync/frame callbacks to time the cost of rendering/compression. Per-probe timing is a function of the underlying pixel colors. Repeat while scanning the ROI to reconstruct a bitmap, then pass to OCR.

Primitives and building blocks

A) Programmatically invoke the victim activity (no special perms)
- If the package is known, fetch its launch intent and bring it to front:

```java
Intent i = getPackageManager().getLaunchIntentForPackage("com.google.android.apps.authenticator2");
if (i != null) {
  i.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP);
  startActivity(i);
}
```

- For deep links/explicit components you control during testing:

```bash
adb shell am start -n com.target/.SensitiveActivity --activity-new-task --activity-clear-top
```

Notes
- Task/intent flags influence z-order and recency; be consistent so the victim remains directly below your translucent overlay.

B) Precise semi-transparent overlay without SYSTEM_ALERT_WINDOW
- Use a translucent activity theme so the window shows what’s below while your views can be partially transparent.

```xml
<!-- AndroidManifest.xml -->
<activity android:name=".OverlayActivity" android:theme="@style/OverlayTheme"/>

<!-- res/values/styles.xml -->
<style name="OverlayTheme" parent="Theme.MaterialComponents.DayNight.NoActionBar">
    <item name="android:windowIsTranslucent">true</item>
    <item name="android:windowBackground">@android:color/transparent</item>
    <item name="android:colorBackgroundCacheHint">@null</item>
    <item name="android:windowNoTitle">true</item>
    <item name="android:windowDrawsSystemBarBackgrounds">false</item>
</style>
```

- Create a full-screen layout and position a semi-transparent view exactly on top of the target ROI.

```java
View probe = new View(this);
probe.setBackgroundColor(Color.argb(64, 0, 0, 0));  // semi-transparent cover for ROI
FrameLayout.LayoutParams lp = new FrameLayout.LayoutParams(w, h);
lp.leftMargin = roiX; lp.topMargin = roiY;
root.addView(probe, lp);
```

C) Inducing blur over the ROI (API 31+)
- Recent Android exposes a window blur API that can apply a blur to what is behind the attacker’s translucent window.
- Exact API names vary across releases/OEMs. Typical options include:
  - WindowManager.LayoutParams.setBlurBehindRadius(int)
  - Window.setBackgroundBlurRadius(int)
  - Per-view RenderEffect (blurs the view’s content; for blur-behind use the window-level blur API)

```java
Window w = getWindow();
WindowManager.LayoutParams p = w.getAttributes();
// Radius tuned experimentally; ensure device supports blur behind
try {
  p.setBlurBehindRadius(64);           // API 31+
  w.setAttributes(p);
} catch (Throwable t) {
  // fallback / no blur support
}
```

- Keep the overlay view aligned to the ROI; only that region needs to trigger the blurred-behind work.

D) Per-frame timing via VSync/FrameMetrics
- Measure frame cost while toggling/animating probes over each pixel/cluster in the ROI.
- Use Choreographer VSync callbacks or Window.OnFrameMetricsAvailableListener (API 24+) to collect timing.

```java
// Choreographer-based frame timing (nanoseconds)
Choreographer c = Choreographer.getInstance();
final long[] last = {0};
final ArrayDeque<Long> samples = new ArrayDeque<>();
Choreographer.FrameCallback cb = new Choreographer.FrameCallback(){
  @Override public void doFrame(long t){
    if (last[0] != 0) samples.add(t - last[0]);
    last[0] = t;
    // trigger small invalidation over ROI to force work
    probe.invalidate();
    c.postFrameCallback(this);
  }
};
runOnUiThread(() -> c.postFrameCallback(cb));
```

- Alternatively, attach a FrameMetrics listener to the overlay activity:

```java
getWindow().addOnFrameMetricsAvailableListener((w, metrics, dropCount) -> {
  long total = metrics.getMetric(FrameMetrics.TOTAL_DURATION);
  // Collect per-frame durations; compute distributions per probe
}, new Handler(Looper.getMainLooper()));
```

E) Reconstruction process
- For each pixel (or small tile) in the ROI:
  1. Position the blur-inducing overlay exactly over that pixel.
  2. Collect N frame timings; compute a statistic (median/mean) for the probe.
  3. Map timing to color/brightness class using a calibrated model (GPU.zip leaks compressibility-dependent timing).
- Aggregate the inferred pixels into a bitmap; feed to OCR (e.g., Tesseract) to recover digits/text.

Targeting TOTP (example)
- Many authenticators display 6–8 digits at stable positions and fixed fonts. Hard-code ROI coordinates per device density, calibrate on known screens, and sweep left→right.
- With a fast probe (few frames/pixel) end-to-end extraction can finish within a TOTP window (<30s).

Notes on reliability and alignment
- Device-specifics (GPU/driver/OEM composition) affect noise; collect multiple samples and use robust statistics.
- Re-compute ROI coordinates after rotations/DPI changes. Use DisplayMetrics + onLayout listeners for sub-pixel accuracy.

Silent app inventory (manifest-less)
- By observing side effects of invoking external activities, an app can infer if specific packages are installed even without declaring package visibility queries. This can guide target selection in constrained visibility environments. Details vary by OS build and are discussed in the Pixnapping paper.

Patches, status, and bypass (as of Oct 2025)
- Google shipped an AOSP patch limiting how many activities on a display can request blur; the front-most subset is honored. Researchers disclosed a workaround re-enabling Pixnapping; rated High severity. Additional fixes are expected in later bulletins.
- Researchers reported original attack paths still working on some OEMs (e.g., Samsung) despite the AOSP patch.
- No GPU vendor has committed to patch GPU.zip yet.

Defensive notes
- Users: apply Android security updates quickly.
- App developers: there are currently no app-level mitigations that reliably prevent this cross-app pixel leak. Typical flags like FLAG_SECURE or disabling screenshots do not address compositor/GPU side-channels. Monitor OS/OEM guidance for further mitigations.

Detection and experimentation tips (for red team and researchers)
- Validate whether blur-behind is supported on the device (OEMs may gate or disable it).
- Compare timing distributions with blur enabled vs disabled to verify signal; ensure background is static.
- Keep overlays minimal and avoid heavy UI work unrelated to the ROI to preserve signal-to-noise ratio.

## References
- [Pixnapping: Bringing Pixel Stealing out of the Stone Age](https://www.pixnapping.com/)
- [GPU.zip – hardware compression side channel](https://www.hertzbleed.com/gpu.zip/)
- [AOSP patch limiting blur requests (SurfaceFlinger)](https://android.googlesource.com/platform/frameworks/native/+/20465375a1d0cb71cdb891235a9f8a3fba31dbf6)

{{#include ../../banners/hacktricks-training.md}}