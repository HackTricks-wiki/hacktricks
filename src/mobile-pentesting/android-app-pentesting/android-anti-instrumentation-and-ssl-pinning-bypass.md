# Android Anti-Instrumentation & SSL Pinning Bypass (Frida/Objection)

{{#include ../../banners/hacktricks-training.md}}

This page provides a practical workflow to regain dynamic analysis against Android apps that detect/root‑block instrumentation or enforce TLS pinning. It focuses on fast triage, common detections, and copy‑pasteable hooks/tactics to bypass them without repacking when possible.

## Detection Surface (what apps check)

- Root checks: su binary, Magisk paths, getprop values, common root packages
- Frida/debugger checks (Java): Debug.isDebuggerConnected(), ActivityManager.getRunningAppProcesses(), getRunningServices(), scanning /proc, classpath, loaded libs
- Native anti‑debug: ptrace(), syscalls, anti‑attach, breakpoints, inline hooks
- Early init checks: Application.onCreate() or process start hooks that crash if instrumentation is present
- TLS pinning: custom TrustManager/HostnameVerifier, OkHttp CertificatePinner, Conscrypt pinning, native pins

## Step 1 — Quick win: hide root with Magisk DenyList

- Enable Zygisk in Magisk
- Enable DenyList, add the target package
- Reboot and retest

Many apps only look for obvious indicators (su/Magisk paths/getprop). DenyList often neutralizes naive checks.

References:
- Magisk (Zygisk & DenyList): https://github.com/topjohnwu/Magisk

## Step 2 — 30‑second Frida Codeshare tests

Try common drop‑in scripts before deep diving:

- anti-root-bypass.js
- anti-frida-detection.js
- hide_frida_gum.js

Example:
```bash
frida -U -f com.example.app -l anti-frida-detection.js
```
Ces modules stubent typiquement les Java root/debug checks, les process/service scans et le native ptrace(). Utile sur des apps faiblement protégées ; les targets durcies peuvent nécessiter des hooks sur mesure.

- Codeshare: https://codeshare.frida.re/

## Automatiser avec Medusa (Frida framework)

Medusa fournit 90+ modules prêts à l'emploi pour SSL unpinning, root/emulator detection bypass, HTTP comms logging, crypto key interception, et plus encore.
```bash
git clone https://github.com/Ch0pin/medusa
cd medusa
pip install -r requirements.txt
python medusa.py

# Example interactive workflow
show categories
use http_communications/multiple_unpinner
use root_detection/universal_root_detection_bypass
run com.target.app
```
Astuce : Medusa est idéal pour des gains rapides avant d'écrire des hooks personnalisés. Vous pouvez aussi cherry-pick des modules et les combiner avec vos propres scripts.

## Étape 3 — Contourner les détecteurs d'initialisation en s'attachant plus tard

De nombreuses détections ne s'exécutent que lors du spawn du processus/onCreate(). Spawn‑time injection (-f) ou les gadgets se font repérer ; s'attachant après le chargement de l'UI permet souvent de passer outre.
```bash
# Launch the app normally (launcher/adb), wait for UI, then attach
frida -U -n com.example.app
# Or with Objection to attach to running process
aobjection --gadget com.example.app explore  # if using gadget
```
Si cela fonctionne, maintenez la session stable et poursuivez par la cartographie et les vérifications des stubs.

## Étape 4 — Cartographier la logique de détection via Jadx et recherche de chaînes

Mots-clés de triage statique dans Jadx :
- "frida", "gum", "root", "magisk", "ptrace", "su", "getprop", "debugger"

Schémas Java typiques :
```java
public boolean isFridaDetected() {
return getRunningServices().contains("frida");
}
```
APIs courantes à examiner/hook:
- android.os.Debug.isDebuggerConnected
- android.app.ActivityManager.getRunningAppProcesses / getRunningServices
- java.lang.System.loadLibrary / System.load (native bridge)
- java.lang.Runtime.exec / ProcessBuilder (probing commands)
- android.os.SystemProperties.get (root/emulator heuristics)

## Étape 5 — Runtime stubbing with Frida (Java)

Surchargez les gardes personnalisés pour renvoyer des valeurs sûres sans repacking:
```js
Java.perform(() => {
const Checks = Java.use('com.example.security.Checks');
Checks.isFridaDetected.implementation = function () { return false; };

// Neutralize debugger checks
const Debug = Java.use('android.os.Debug');
Debug.isDebuggerConnected.implementation = function () { return false; };

// Example: kill ActivityManager scans
const AM = Java.use('android.app.ActivityManager');
AM.getRunningAppProcesses.implementation = function () { return java.util.Collections.emptyList(); };
});
```
Triage des plantages précoces ? Dump classes juste avant qu'il ne plante pour repérer les namespaces probablement utilisés pour la détection :
```js
Java.perform(() => {
Java.enumerateLoadedClasses({
onMatch: n => console.log(n),
onComplete: () => console.log('Done')
});
});
```
// Quick root detection stub example (adapt to target package/class names)
Java.perform(() => {
try {
const RootChecker = Java.use('com.target.security.RootCheck');
RootChecker.isDeviceRooted.implementation = function () { return false; };
} catch (e) {}
});

Log et neutraliser les méthodes suspectes pour confirmer le flux d'exécution :
```js
Java.perform(() => {
const Det = Java.use('com.example.security.DetectionManager');
Det.checkFrida.implementation = function () {
console.log('checkFrida() called');
return false;
};
});
```
## Contourner la détection d'émulateur/VM (Java stubs)

Heuristiques courantes : Build.FINGERPRINT/MODEL/MANUFACTURER/HARDWARE contenant generic/goldfish/ranchu/sdk ; artefacts QEMU comme /dev/qemu_pipe, /dev/socket/qemud ; MAC par défaut 02:00:00:00:00:00 ; NAT 10.0.2.x ; téléphonie/capteurs absents.

Falsification rapide des champs Build :
```js
Java.perform(function(){
var Build = Java.use('android.os.Build');
Build.MODEL.value = 'Pixel 7 Pro';
Build.MANUFACTURER.value = 'Google';
Build.BRAND.value = 'google';
Build.FINGERPRINT.value = 'google/panther/panther:14/UP1A.231105.003/1234567:user/release-keys';
});
```
Compléter par des stubs pour les vérifications d'existence de fichiers et les identifiants (TelephonyManager.getDeviceId/SubscriberId, WifiInfo.getMacAddress, SensorManager.getSensorList) pour retourner des valeurs réalistes.

## SSL pinning bypass quick hook (Java)

Neutraliser les TrustManagers personnalisés et forcer des SSL contexts permissifs :
```js
Java.perform(function(){
var X509TrustManager = Java.use('javax.net.ssl.X509TrustManager');
var SSLContext = Java.use('javax.net.ssl.SSLContext');

// No-op validations
X509TrustManager.checkClientTrusted.implementation = function(){ };
X509TrustManager.checkServerTrusted.implementation = function(){ };

// Force permissive TrustManagers
var TrustManagers = [ X509TrustManager.$new() ];
var SSLContextInit = SSLContext.init.overload('[Ljavax.net.ssl.KeyManager;','[Ljavax.net.ssl.TrustManager;','java.security.SecureRandom');
SSLContextInit.implementation = function(km, tm, sr){
return SSLContextInit.call(this, km, TrustManagers, sr);
};
});
```
Remarques
- Adapter pour OkHttp : hook okhttp3.CertificatePinner et HostnameVerifier au besoin, ou utilisez un script universel d'unpinning depuis CodeShare.
- Exemple d'exécution : `frida -U -f com.target.app -l ssl-bypass.js --no-pause`

## Étape 6 — Suivre la piste JNI/native lorsque les hooks Java échouent

Tracez les points d'entrée JNI pour localiser les loaders natifs et l'initialisation de la détection :
```bash
frida-trace -n com.example.app -i "JNI_OnLoad"
```
Triage natif rapide des fichiers .so inclus :
```bash
# List exported symbols & JNI
nm -D libfoo.so | head
objdump -T libfoo.so | grep Java_
strings -n 6 libfoo.so | egrep -i 'frida|ptrace|gum|magisk|su|root'
```
Interactif/natif reversing:
- Ghidra: https://ghidra-sre.org/
- r2frida: https://github.com/nowsecure/r2frida

Exemple : neutraliser ptrace pour contourner un simple anti‑debug dans libc:
```js
const ptrace = Module.findExportByName(null, 'ptrace');
if (ptrace) {
Interceptor.replace(ptrace, new NativeCallback(function () {
return -1; // pretend failure
}, 'int', ['int', 'int', 'pointer', 'pointer']));
}
```
Voir aussi :
{{#ref}}
reversing-native-libraries.md
{{#endref}}

## Étape 7 — Objection patching (embed gadget / strip basics)

Lorsque vous préférez le repacking aux runtime hooks, essayez :
```bash
objection patchapk --source app.apk
```
Remarques:
- Nécessite apktool; assurez-vous d'une version à jour via le guide officiel pour éviter des problèmes de build: https://apktool.org/docs/install
- Gadget injection permet l'instrumentation sans root mais peut toujours être détectée par des init‑time checks plus strictes.

En option, ajoutez des modules LSPosed et Shamiko pour un root hiding plus efficace dans les environnements Zygisk, et configurez DenyList pour couvrir les child processes.

Références:
- Objection: https://github.com/sensepost/objection

## Étape 8 — Repli : Patch TLS pinning pour la visibilité réseau

Si l'instrumentation est bloquée, vous pouvez toujours inspecter le trafic en supprimant le pinning de façon statique :
```bash
apk-mitm app.apk
# Then install the patched APK and proxy via Burp/mitmproxy
```
- Outil: https://github.com/shroudedcode/apk-mitm
- Pour les astuces de configuration réseau CA‑trust (et la confiance CA utilisateur Android 7+), voir :

{{#ref}}
make-apk-accept-ca-certificate.md
{{#endref}}

{{#ref}}
install-burp-certificate.md
{{#endref}}

## Fiche pratique de commandes utiles
```bash
# List processes and attach
frida-ps -Uai
frida -U -n com.example.app

# Spawn with a script (may trigger detectors)
frida -U -f com.example.app -l anti-frida-detection.js

# Trace native init
frida-trace -n com.example.app -i "JNI_OnLoad"

# Objection runtime
objection --gadget com.example.app explore

# Static TLS pinning removal
apk-mitm app.apk
```
## Universal proxy forcing + TLS unpinning (HTTP Toolkit Frida hooks)

Les applications modernes ignorent souvent les proxies système et appliquent plusieurs couches de pinning (Java + native), rendant la capture du trafic difficile même avec les CA utilisateur/système installées. Une approche pratique consiste à combiner universal TLS unpinning avec proxy forcing via des hooks Frida prêts à l'emploi, et à rediriger tout le trafic via mitmproxy/Burp.

Workflow
- Exécutez mitmproxy sur votre hôte (ou Burp). Assurez-vous que l'appareil peut atteindre l'IP/port de l'hôte.
- Chargez les hooks Frida consolidés de HTTP Toolkit pour à la fois unpin TLS et forcer l'utilisation du proxy sur les stacks courants (OkHttp/OkHttp3, HttpsURLConnection, Conscrypt, WebView, etc.). Cela contourne les vérifications CertificatePinner/TrustManager et remplace les sélecteurs de proxy, de sorte que le trafic est toujours envoyé via votre proxy même si l'app désactive explicitement les proxies.
- Démarrez l'app cible avec Frida et le script de hook, puis capturez les requêtes dans mitmproxy.

Exemple
```bash
# Device connected via ADB or over network (-U)
# See the repo for the exact script names & options
frida -U -f com.vendor.app \
-l ./android-unpinning-with-proxy.js \
--no-pause

# mitmproxy listening locally
mitmproxy -p 8080
```
Remarques
- Combinez-le avec un proxy système global via `adb shell settings put global http_proxy <host>:<port>` lorsque possible. Les Frida hooks forceront l'utilisation du proxy même lorsque les apps contournent les paramètres globaux.
- Cette technique est idéale lorsque vous devez MITM des flux d'onboarding mobile vers IoT où le pinning/évitation du proxy est courant.
- Hooks: https://github.com/httptoolkit/frida-interception-and-unpinning

## Références

- [Reversing Android Apps: Bypassing Detection Like a Pro](https://www.kayssel.com/newsletter/issue-12/)
- [Frida Codeshare](https://codeshare.frida.re/)
- [Objection](https://github.com/sensepost/objection)
- [apk-mitm](https://github.com/shroudedcode/apk-mitm)
- [Jadx](https://github.com/skylot/jadx)
- [Ghidra](https://ghidra-sre.org/)
- [r2frida](https://github.com/nowsecure/r2frida)
- [Apktool install guide](https://apktool.org/docs/install)
- [Magisk](https://github.com/topjohnwu/Magisk)
- [Medusa (Android Frida framework)](https://github.com/Ch0pin/medusa)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)

{{#include ../../banners/hacktricks-training.md}}
