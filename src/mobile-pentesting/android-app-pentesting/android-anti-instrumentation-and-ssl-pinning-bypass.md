# Android Anti-Instrumentation & SSL Pinning Bypass (Frida/Objection)

{{#include ../../banners/hacktricks-training.md}}

Αυτή η σελίδα παρέχει μια πρακτική ροή εργασίας για να ανακτήσετε τη δυναμική ανάλυση σε Android εφαρμογές που ανιχνεύουν/αποκλείουν instrumentation ή επιβάλλουν TLS pinning. Εστιάζει σε ταχεία αξιολόγηση, κοινούς ανιχνευτικούς ελέγχους, και copy‑pasteable hooks/tactics για να τα παρακάμψετε χωρίς repacking όταν είναι εφικτό.

## Detection Surface (what apps check)

- Root checks: su binary, Magisk paths, getprop values, common root packages
- Frida/debugger checks (Java): Debug.isDebuggerConnected(), ActivityManager.getRunningAppProcesses(), getRunningServices(), scanning /proc, classpath, loaded libs
- Native anti‑debug: ptrace(), syscalls, anti‑attach, breakpoints, inline hooks
- Early init checks: Application.onCreate() or process start hooks that crash if instrumentation is present
- TLS pinning: custom TrustManager/HostnameVerifier, OkHttp CertificatePinner, Conscrypt pinning, native pins

## Step 1 — Quick win: hide root with Magisk DenyList

- Enable Zygisk in Magisk
- Enable DenyList, add the target package
- Reboot and retest

Πολλές εφαρμογές ψάχνουν μόνο για προφανείς ενδείξεις (su/Magisk paths/getprop). Το DenyList συχνά εξουδετερώνει τους απλοϊκούς ελέγχους.

References:
- Magisk (Zygisk & DenyList): https://github.com/topjohnwu/Magisk

## Step 2 — 30‑second Frida Codeshare tests

Δοκιμάστε έτοιμα drop‑in scripts πριν προχωρήσετε σε βαθύτερη ανάλυση:

- anti-root-bypass.js
- anti-frida-detection.js
- hide_frida_gum.js

Example:
```bash
frida -U -f com.example.app -l anti-frida-detection.js
```
Συνήθως κάνουν stub Java root/debug ελέγχους, process/service σαρώσεις και native ptrace(). Χρήσιμα σε ελαφρώς προστατευμένες εφαρμογές· hardened targets μπορεί να χρειαστούν tailored hooks.

- Codeshare: https://codeshare.frida.re/

## Αυτοματοποιήστε με Medusa (Frida framework)

Medusa παρέχει 90+ έτοιμα modules για SSL unpinning, root/emulator detection bypass, HTTP comms logging, crypto key interception, και άλλα.
```bash
git clone https://github.com/Ch0pin/medusa
cd medusa
pip install -r requirements.txt
python medusa.py

# Example interactive workflow
show categories
use http_communications/multiple_unpinner
use root_detection/universal_root_detection_bypass
run com.target.app
```
Συμβουλή: Το Medusa είναι εξαιρετικό για γρήγορες νίκες πριν γράψετε custom hooks. Μπορείτε επίσης να cherry-pick modules και να τα συνδυάσετε με τα δικά σας scripts.

## Βήμα 3 — Παράκαμψη init-time detectors με attaching αργότερα

Πολλές ανιχνεύσεις τρέχουν μόνο κατά τη διάρκεια του process spawn/onCreate(). Η Spawn‑time injection (-f) ή gadgets εντοπίζονται· το attaching μετά το φόρτωμα του UI μπορεί να περάσει απαρατήρητο.
```bash
# Launch the app normally (launcher/adb), wait for UI, then attach
frida -U -n com.example.app
# Or with Objection to attach to running process
aobjection --gadget com.example.app explore  # if using gadget
```
Αν αυτό λειτουργήσει, διατήρησε τη συνεδρία σταθερή και προχώρα σε map και stub checks.

## Step 4 — Χαρτογράφησε τη λογική ανίχνευσης μέσω Jadx και string hunting

Στατικές λέξεις-κλειδιά για triage στο Jadx:
- "frida", "gum", "root", "magisk", "ptrace", "su", "getprop", "debugger"

Τυπικά Java patterns:
```java
public boolean isFridaDetected() {
return getRunningServices().contains("frida");
}
```
Συνηθισμένα APIs προς αναθεώρηση/hook:
- android.os.Debug.isDebuggerConnected
- android.app.ActivityManager.getRunningAppProcesses / getRunningServices
- java.lang.System.loadLibrary / System.load (native bridge)
- java.lang.Runtime.exec / ProcessBuilder (probing commands)
- android.os.SystemProperties.get (root/emulator heuristics)

## Βήμα 5 — Runtime stubbing με Frida (Java)

Παράκαμψε custom guards για να επιστρέφουν ασφαλείς τιμές χωρίς repacking:
```js
Java.perform(() => {
const Checks = Java.use('com.example.security.Checks');
Checks.isFridaDetected.implementation = function () { return false; };

// Neutralize debugger checks
const Debug = Java.use('android.os.Debug');
Debug.isDebuggerConnected.implementation = function () { return false; };

// Example: kill ActivityManager scans
const AM = Java.use('android.app.ActivityManager');
AM.getRunningAppProcesses.implementation = function () { return java.util.Collections.emptyList(); };
});
```
Αν διαχειρίζεστε πρώιμα crashes, κάντε dump των classes λίγο πριν τερματίσει για να εντοπίσετε πιθανές detection namespaces:
```js
Java.perform(() => {
Java.enumerateLoadedClasses({
onMatch: n => console.log(n),
onComplete: () => console.log('Done')
});
});
```
// Quick root detection stub example (adapt to target package/class names)
Java.perform(() => {
try {
const RootChecker = Java.use('com.target.security.RootCheck');
RootChecker.isDeviceRooted.implementation = function () { return false; };
} catch (e) {}
});

Καταγράψτε και αδρανοποιήστε ύποπτες μεθόδους για να επιβεβαιώσετε τη ροή εκτέλεσης:
```js
Java.perform(() => {
const Det = Java.use('com.example.security.DetectionManager');
Det.checkFrida.implementation = function () {
console.log('checkFrida() called');
return false;
};
});
```
## Bypass emulator/VM detection (Java stubs)

Κοινές ευρετικές μέθοδοι: Build.FINGERPRINT/MODEL/MANUFACTURER/HARDWARE που περιέχουν generic/goldfish/ranchu/sdk; QEMU ίχνη όπως /dev/qemu_pipe, /dev/socket/qemud; προεπιλεγμένη διεύθυνση MAC 02:00:00:00:00:00; 10.0.2.x NAT; έλλειψη τηλεφωνίας/αισθητήρων.

Γρήγορο spoof των πεδίων Build:
```js
Java.perform(function(){
var Build = Java.use('android.os.Build');
Build.MODEL.value = 'Pixel 7 Pro';
Build.MANUFACTURER.value = 'Google';
Build.BRAND.value = 'google';
Build.FINGERPRINT.value = 'google/panther/panther:14/UP1A.231105.003/1234567:user/release-keys';
});
```
Συμπλήρωσε με stubs για ελέγχους ύπαρξης αρχείων και αναγνωριστικά (TelephonyManager.getDeviceId/SubscriberId, WifiInfo.getMacAddress, SensorManager.getSensorList) ώστε να επιστρέφουν ρεαλιστικές τιμές.

## SSL pinning bypass quick hook (Java)

Αδρανοποίησε custom TrustManagers και εξανάγκασε permissive SSL contexts:
```js
Java.perform(function(){
var X509TrustManager = Java.use('javax.net.ssl.X509TrustManager');
var SSLContext = Java.use('javax.net.ssl.SSLContext');

// No-op validations
X509TrustManager.checkClientTrusted.implementation = function(){ };
X509TrustManager.checkServerTrusted.implementation = function(){ };

// Force permissive TrustManagers
var TrustManagers = [ X509TrustManager.$new() ];
var SSLContextInit = SSLContext.init.overload('[Ljavax.net.ssl.KeyManager;','[Ljavax.net.ssl.TrustManager;','java.security.SecureRandom');
SSLContextInit.implementation = function(km, tm, sr){
return SSLContextInit.call(this, km, TrustManagers, sr);
};
});
```
Notes
- Επέκτεινε για OkHttp: hook okhttp3.CertificatePinner and HostnameVerifier όπως απαιτείται, ή χρησιμοποίησε ένα universal unpinning script από CodeShare.
- Παράδειγμα εκτέλεσης: `frida -U -f com.target.app -l ssl-bypass.js --no-pause`

## Step 6 — Ακολούθησε το JNI/native μονοπάτι όταν τα Java hooks αποτυγχάνουν

Ιχνηλάτησε τα JNI entry points για να εντοπίσεις native loaders και detection init:
```bash
frida-trace -n com.example.app -i "JNI_OnLoad"
```
Γρήγορη εγγενής αξιολόγηση των συσκευασμένων αρχείων .so:
```bash
# List exported symbols & JNI
nm -D libfoo.so | head
objdump -T libfoo.so | grep Java_
strings -n 6 libfoo.so | egrep -i 'frida|ptrace|gum|magisk|su|root'
```
Διαδραστική/native reversing:
- Ghidra: https://ghidra-sre.org/
- r2frida: https://github.com/nowsecure/r2frida

Παράδειγμα: εξουδετέρωση ptrace για να παρακάμψετε απλό anti‑debug στο libc:
```js
const ptrace = Module.findExportByName(null, 'ptrace');
if (ptrace) {
Interceptor.replace(ptrace, new NativeCallback(function () {
return -1; // pretend failure
}, 'int', ['int', 'int', 'pointer', 'pointer']));
}
```
Δείτε επίσης:
{{#ref}}
reversing-native-libraries.md
{{#endref}}

## Βήμα 7 — Objection patching (embed gadget / strip basics)

Όταν προτιμάτε repacking αντί για runtime hooks, δοκιμάστε:
```bash
objection patchapk --source app.apk
```
Σημειώσεις:
- Απαιτεί apktool· βεβαιώσου ότι έχεις μια τρέχουσα έκδοση από τον επίσημο οδηγό για να αποφύγεις προβλήματα στο build: https://apktool.org/docs/install
- Το Gadget injection επιτρέπει instrumentation χωρίς root, αλλά μπορεί ακόμα να εντοπιστεί από πιο αυστηρούς init‑time ελέγχους.

Προαιρετικά, πρόσθεσε LSPosed modules και Shamiko για καλύτερη απόκρυψη root σε περιβάλλοντα Zygisk, και διαμόρφωσε τη DenyList ώστε να καλύπτει child processes.

Αναφορές:
- Objection: https://github.com/sensepost/objection

## Βήμα 8 — Fallback: Patch TLS pinning για ορατότητα δικτύου

Εάν instrumentation μπλοκάρεται, μπορείς ακόμα να επιθεωρήσεις την κίνηση αφαιρώντας το pinning στατικά:
```bash
apk-mitm app.apk
# Then install the patched APK and proxy via Burp/mitmproxy
```
- Εργαλείο: https://github.com/shroudedcode/apk-mitm
- Για κόλπα CA‑trust στη διαμόρφωση δικτύου (και Android 7+ user CA trust), δείτε:

{{#ref}}
make-apk-accept-ca-certificate.md
{{#endref}}

{{#ref}}
install-burp-certificate.md
{{#endref}}

## Χρήσιμη σύνοψη εντολών
```bash
# List processes and attach
frida-ps -Uai
frida -U -n com.example.app

# Spawn with a script (may trigger detectors)
frida -U -f com.example.app -l anti-frida-detection.js

# Trace native init
frida-trace -n com.example.app -i "JNI_OnLoad"

# Objection runtime
objection --gadget com.example.app explore

# Static TLS pinning removal
apk-mitm app.apk
```
## Καθολική επιβολή proxy + TLS unpinning (HTTP Toolkit Frida hooks)

Οι σύγχρονες εφαρμογές συχνά αγνοούν τα system proxies και εφαρμόζουν πολλαπλά επίπεδα pinning (Java + native), καθιστώντας την καταγραφή του traffic δύσκολη ακόμα και με τα user/system CAs εγκατεστημένα. Μια πρακτική προσέγγιση είναι να συνδυάσετε universal TLS unpinning με proxy forcing μέσω έτοιμων Frida hooks και να δρομολογήσετε τα πάντα μέσω mitmproxy/Burp.

Ροή εργασίας
- Τρέξτε mitmproxy στον host σας (ή Burp). Βεβαιωθείτε ότι η συσκευή μπορεί να φτάσει στο host IP/port.
- Φορτώστε τα ενοποιημένα Frida hooks του HTTP Toolkit για να εφαρμόσετε TLS unpinning και να επιβάλετε χρήση proxy σε κοινές στοίβες (OkHttp/OkHttp3, HttpsURLConnection, Conscrypt, WebView, κ.λπ.). Αυτό παρακάμπτει τους ελέγχους CertificatePinner/TrustManager και αντικαθιστά τους proxy selectors, έτσι ώστε το traffic να στέλνεται πάντα μέσω του proxy σας ακόμη κι αν η εφαρμογή απενεργοποιεί ρητά τους proxies.
- Ξεκινήστε την target app με Frida και το hook script, και καταγράψτε τα requests στο mitmproxy.

Παράδειγμα
```bash
# Device connected via ADB or over network (-U)
# See the repo for the exact script names & options
frida -U -f com.vendor.app \
-l ./android-unpinning-with-proxy.js \
--no-pause

# mitmproxy listening locally
mitmproxy -p 8080
```
Σημειώσεις
- Συνδυάστε με έναν proxy σε επίπεδο συστήματος μέσω `adb shell settings put global http_proxy <host>:<port>` όταν είναι δυνατό. Τα Frida hooks θα επιβάλλουν τη χρήση του proxy ακόμα και όταν οι εφαρμογές παρακάμπτουν τις global ρυθμίσεις.
- Αυτή η τεχνική είναι ιδανική όταν χρειάζεται να κάνετε MITM σε διαδικασίες onboarding mobile→IoT όπου το pinning/η αποφυγή proxy είναι συνηθισμένα.
- Hooks: https://github.com/httptoolkit/frida-interception-and-unpinning

## Αναφορές

- [Reversing Android Apps: Bypassing Detection Like a Pro](https://www.kayssel.com/newsletter/issue-12/)
- [Frida Codeshare](https://codeshare.frida.re/)
- [Objection](https://github.com/sensepost/objection)
- [apk-mitm](https://github.com/shroudedcode/apk-mitm)
- [Jadx](https://github.com/skylot/jadx)
- [Ghidra](https://ghidra-sre.org/)
- [r2frida](https://github.com/nowsecure/r2frida)
- [Apktool install guide](https://apktool.org/docs/install)
- [Magisk](https://github.com/topjohnwu/Magisk)
- [Medusa (Android Frida framework)](https://github.com/Ch0pin/medusa)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)

{{#include ../../banners/hacktricks-training.md}}
