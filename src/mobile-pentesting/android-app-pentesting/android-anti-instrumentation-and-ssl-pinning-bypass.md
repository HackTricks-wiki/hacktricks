# Android Anti-Instrumentation & SSL Pinning Bypass (Frida/Objection)

{{#include ../../banners/hacktricks-training.md}}

यह पृष्ठ Android ऐप्स के विरुद्ध dynamic analysis को वापस पाने के लिए एक प्रायोगिक वर्कफ़्लो प्रदान करता है जो instrumentation का पता लगाते/रूट‑ब्लॉक करते हैं या TLS pinning लागू करते हैं। यह तेज़ triage, सामान्य detections, और copy‑pasteable hooks/tactics पर केंद्रित है ताकि संभव होने पर बिना repacking के इन्हें बाईपास किया जा सके।

## Detection Surface (ऐप्स क्या चेक करते हैं)

- Root checks: su binary, Magisk paths, getprop values, common root packages
- Frida/debugger checks (Java): Debug.isDebuggerConnected(), ActivityManager.getRunningAppProcesses(), getRunningServices(), scanning /proc, classpath, loaded libs
- Native anti‑debug: ptrace(), syscalls, anti‑attach, breakpoints, inline hooks
- Early init checks: Application.onCreate() or process start hooks that crash if instrumentation is present
- TLS pinning: custom TrustManager/HostnameVerifier, OkHttp CertificatePinner, Conscrypt pinning, native pins

## Step 1 — Quick win: hide root with Magisk DenyList

- Enable Zygisk in Magisk
- Enable DenyList, add the target package
- Reboot and retest

कई ऐप्स केवल स्पष्ट संकेतकों (su/Magisk paths/getprop) की तलाश करते हैं। DenyList अक्सर naive checks को neutralize कर देता है।

References:
- Magisk (Zygisk & DenyList): https://github.com/topjohnwu/Magisk

### Play Integrity / Zygisk detections (post‑SafetyNet)

नवीनतम बैंकिंग/ID ऐप्स runtime checks को Google Play Integrity (SafetyNet replacement) से जोड़ देते हैं और यह भी क्रैश कर सकते हैं अगर Zygisk स्वयं मौजूद हो। त्वरित triage टिप्स:

- अस्थायी रूप से Zygisk को अक्षम करें (toggle off + reboot) और पुनः प्रयास करें; कुछ ऐप्स जैसे ही Zygote injection लोड होती है क्रैश कर देती हैं।
- अगर attestation लॉगिन को ब्लॉक कर रहा है, तो PlayIntegrityFix/Fork + TrickyStore के साथ Google Play Services को पैच करें या केवल टेस्टिंग के दौरान ReZygisk/Zygisk‑Next का उपयोग करें। लक्ष्य को DenyList में रखें और उन LSPosed मॉड्यूल से बचें जो props को leak करते हैं।
- एक‑बार के रन के लिए, KernelSU/APatch (कोई Zygote injection नहीं) का उपयोग करके Zygisk heuristics के नीचे रहें, फिर Frida attach करें।

## Step 2 — 30‑second Frida Codeshare tests

गहन विश्लेषण में जाने से पहले सामान्य drop‑in scripts आज़माएँ:

- anti-root-bypass.js
- anti-frida-detection.js
- hide_frida_gum.js

Example:
```bash
frida -U -f com.example.app -l anti-frida-detection.js
```
ये आमतौर पर Java root/debug checks, process/service scans, और native ptrace() को स्टब करते हैं। हल्के सुरक्षा वाले apps पर उपयोगी; hardened targets को tailored hooks की आवश्यकता हो सकती है।

- Codeshare: https://codeshare.frida.re/

## Medusa के साथ ऑटोमेट करें (Frida framework)

Medusa 90+ तैयार मॉड्यूल प्रदान करता है जो SSL unpinning, root/emulator detection bypass, HTTP comms logging, crypto key interception और अन्य के लिए उपयोगी हैं।
```bash
git clone https://github.com/Ch0pin/medusa
cd medusa
pip install -r requirements.txt
python medusa.py

# Example interactive workflow
show categories
use http_communications/multiple_unpinner
use root_detection/universal_root_detection_bypass
run com.target.app
```
टिप: Medusa कस्टम hooks लिखने से पहले त्वरित सफलता के लिए शानदार है। आप modules को भी चुनकर अपने scripts के साथ मिला सकते हैं।

## Step 3 — init-time detectors को बाद में attach करके bypass करें

कई detections केवल process spawn/onCreate() के दौरान चलते हैं। Spawn‑time injection (-f) या gadgets पकड़े जाते हैं; UI लोड होने के बाद attach करने पर ये चकमा दे सकते हैं।
```bash
# Launch the app normally (launcher/adb), wait for UI, then attach
frida -U -n com.example.app
# Or with Objection to attach to running process
aobjection --gadget com.example.app explore  # if using gadget
```
यदि यह काम करे, तो session को स्थिर रखें और map तथा stub checks पर आगे बढ़ें।

## चरण 4 — डिटेक्शन लॉजिक को Jadx और string hunting के माध्यम से मैप करें

Jadx में Static triage के लिए keywords:
- "frida", "gum", "root", "magisk", "ptrace", "su", "getprop", "debugger"

सामान्य Java पैटर्न:
```java
public boolean isFridaDetected() {
return getRunningServices().contains("frida");
}
```
सामान्य APIs जिनकी समीक्षा/hook की जानी चाहिए:
- android.os.Debug.isDebuggerConnected
- android.app.ActivityManager.getRunningAppProcesses / getRunningServices
- java.lang.System.loadLibrary / System.load (native bridge)
- java.lang.Runtime.exec / ProcessBuilder (probing commands)
- android.os.SystemProperties.get (root/emulator heuristics)

## चरण 5 — Frida (Java) के साथ रनटाइम स्टबिंग

कस्टम गार्ड्स को ओवरराइड करके बिना repacking किए सुरक्षित मान लौटाएं:
```js
Java.perform(() => {
const Checks = Java.use('com.example.security.Checks');
Checks.isFridaDetected.implementation = function () { return false; };

// Neutralize debugger checks
const Debug = Java.use('android.os.Debug');
Debug.isDebuggerConnected.implementation = function () { return false; };

// Example: kill ActivityManager scans
const AM = Java.use('android.app.ActivityManager');
AM.getRunningAppProcesses.implementation = function () { return java.util.Collections.emptyList(); };
});
```
शुरुआती क्रैश को ट्रायज कर रहे हैं? संभावित detection namespaces का पता लगाने के लिए यह मरने से ठीक पहले classes को dump करें:
```js
Java.perform(() => {
Java.enumerateLoadedClasses({
onMatch: n => console.log(n),
onComplete: () => console.log('Done')
});
});
```
// Quick root detection stub example (adapt to target package/class names)
Java.perform(() => {
try {
const RootChecker = Java.use('com.target.security.RootCheck');
RootChecker.isDeviceRooted.implementation = function () { return false; };
} catch (e) {}
});

निष्पादन प्रवाह की पुष्टि करने के लिए संदिग्ध मेथड्स को लॉग और निष्क्रिय करें:
```js
Java.perform(() => {
const Det = Java.use('com.example.security.DetectionManager');
Det.checkFrida.implementation = function () {
console.log('checkFrida() called');
return false;
};
});
```
## इम्युलेटर/VM डिटेक्शन बायपास (Java stubs)

सामान्य संकेत: Build.FINGERPRINT/MODEL/MANUFACTURER/HARDWARE में generic/goldfish/ranchu/sdk शामिल होना; QEMU artifacts जैसे /dev/qemu_pipe, /dev/socket/qemud; डिफ़ॉल्ट MAC 02:00:00:00:00:00; 10.0.2.x NAT; telephony/sensors का अभाव।

Build फ़ील्ड्स का त्वरित स्पूफ:
```js
Java.perform(function(){
var Build = Java.use('android.os.Build');
Build.MODEL.value = 'Pixel 7 Pro';
Build.MANUFACTURER.value = 'Google';
Build.BRAND.value = 'google';
Build.FINGERPRINT.value = 'google/panther/panther:14/UP1A.231105.003/1234567:user/release-keys';
});
```
फ़ाइल अस्तित्व जाँच और पहचानकर्ताओं (TelephonyManager.getDeviceId/SubscriberId, WifiInfo.getMacAddress, SensorManager.getSensorList) के लिए स्टब जोड़ें ताकि वे यथार्थवादी मान लौटाएँ।

## SSL pinning bypass quick hook (Java)

कस्टम TrustManagers को निष्क्रिय करें और permissive SSL contexts लागू करें:
```js
Java.perform(function(){
var X509TrustManager = Java.use('javax.net.ssl.X509TrustManager');
var SSLContext = Java.use('javax.net.ssl.SSLContext');

// No-op validations
X509TrustManager.checkClientTrusted.implementation = function(){ };
X509TrustManager.checkServerTrusted.implementation = function(){ };

// Force permissive TrustManagers
var TrustManagers = [ X509TrustManager.$new() ];
var SSLContextInit = SSLContext.init.overload('[Ljavax.net.ssl.KeyManager;','[Ljavax.net.ssl.TrustManager;','java.security.SecureRandom');
SSLContextInit.implementation = function(km, tm, sr){
return SSLContextInit.call(this, km, TrustManagers, sr);
};
});
```
Notes
- OkHttp के लिए विस्तार करें: आवश्यकतानुसार okhttp3.CertificatePinner और HostnameVerifier को hook करें, या CodeShare से एक universal unpinning script का उपयोग करें।
- उदाहरण चलाएँ: `frida -U -f com.target.app -l ssl-bypass.js --no-pause`

### OkHttp4 / gRPC / Cronet pinning (2024+)

आधुनिक स्टैक्स नए APIs (OkHttp4+, gRPC over Cronet/BoringSSL) के अंदर pin करते हैं। जब बेसिक SSLContext hook अटक जाए तब इन hooks को जोड़ें:
```js
Java.perform(() => {
try {
const Pinner = Java.use('okhttp3.CertificatePinner');
Pinner.check.overload('java.lang.String', 'java.util.List').implementation = function(){};
Pinner.check$okhttp.implementation = function(){};
} catch (e) {}

try {
const CronetB = Java.use('org.chromium.net.CronetEngine$Builder');
CronetB.enablePublicKeyPinningBypassForLocalTrustAnchors.overload('boolean').implementation = function(){ return this; };
CronetB.setPublicKeyPins.overload('java.lang.String', 'java.util.Set', 'boolean').implementation = function(){ return this; };
} catch (e) {}
});
```
यदि TLS फिर भी विफल रहता है, तो native स्तर पर जाएँ और Cronet/gRPC द्वारा उपयोग किए जाने वाले BoringSSL verification entry points को patch करें:
```js
const customVerify = Module.findExportByName(null, 'SSL_CTX_set_custom_verify');
if (customVerify) {
Interceptor.attach(customVerify, {
onEnter(args){
// arg0 = SSL_CTX*, arg1 = mode, arg2 = callback
args[1] = ptr(0); // SSL_VERIFY_NONE
args[2] = NULL;  // disable callback
}
});
}
```
## Step 6 — Java hooks असफल होने पर JNI/native ट्रेल का पालन करें

JNI entry points को ट्रेस करें ताकि native loaders और detection init का पता लगाया जा सके:
```bash
frida-trace -n com.example.app -i "JNI_OnLoad"
```
बंडल किए गए .so फ़ाइलों का त्वरित native triage:
```bash
# List exported symbols & JNI
nm -D libfoo.so | head
objdump -T libfoo.so | grep Java_
strings -n 6 libfoo.so | egrep -i 'frida|ptrace|gum|magisk|su|root'
```
Interactive/native reversing:
- Ghidra: https://ghidra-sre.org/
- r2frida: https://github.com/nowsecure/r2frida

उदाहरण: ptrace को निष्क्रिय करके सरल anti‑debug को libc में हराना:
```js
const ptrace = Module.findExportByName(null, 'ptrace');
if (ptrace) {
Interceptor.replace(ptrace, new NativeCallback(function () {
return -1; // pretend failure
}, 'int', ['int', 'int', 'pointer', 'pointer']));
}
```
इन्हें भी देखें:
{{#ref}}
reversing-native-libraries.md
{{#endref}}

## चरण 7 — Objection patching (embed gadget / strip basics)

जब आप runtime hooks के बजाय repacking को प्राथमिकता देते हैं, तो कोशिश करें:
```bash
objection patchapk --source app.apk
```
नोट:
- apktool की आवश्यकता है; बिल्ड समस्याओं से बचने के लिए आधिकारिक गाइड से नवीनतम संस्करण सुनिश्चित करें: https://apktool.org/docs/install
- Gadget injection रूट के बिना instrumentation सक्षम करता है, लेकिन इसे मजबूत init‑time checks द्वारा फिर भी पकड़ा जा सकता है।

वैकल्पिक रूप से, Zygisk environments में रूट छिपाने को मजबूत करने के लिए LSPosed modules और Shamiko जोड़ें, और child processes को कवर करने के लिए DenyList को संगठित करें।

एक पूर्ण वर्कफ़्लो देखने के लिए जिसमें script-mode Gadget configuration और अपने Frida 17+ agent को APK में बंडल करना शामिल है, देखें:

[Frida Tutorial — Self-contained agent + Gadget embedding](frida-tutorial/README.md)

संदर्भ:
- Objection: https://github.com/sensepost/objection

## चरण 8 — Fallback: नेटवर्क दृश्यता के लिए TLS pinning को पैच करें

यदि instrumentation अवरुद्ध है, तो आप pinning को स्थैतिक रूप से हटाकर ट्रैफ़िक का निरीक्षण फिर भी कर सकते हैं:
```bash
apk-mitm app.apk
# Then install the patched APK and proxy via Burp/mitmproxy
```
- टूल: https://github.com/shroudedcode/apk-mitm
- नेटवर्क कॉन्फ़िग CA‑trust ट्रिक्स (और Android 7+ user CA trust) के लिए देखें:

{{#ref}}
make-apk-accept-ca-certificate.md
{{#endref}}

{{#ref}}
install-burp-certificate.md
{{#endref}}

## उपयोगी कमांड चीट‑शीट
```bash
# List processes and attach
frida-ps -Uai
frida -U -n com.example.app

# Spawn with a script (may trigger detectors)
frida -U -f com.example.app -l anti-frida-detection.js

# Trace native init
frida-trace -n com.example.app -i "JNI_OnLoad"

# Objection runtime
objection --gadget com.example.app explore

# Static TLS pinning removal
apk-mitm app.apk
```
## Universal proxy forcing + TLS unpinning (HTTP Toolkit Frida hooks)

आधुनिक ऐप अक्सर system proxies की उपेक्षा करते हैं और pinning के कई स्तर (Java + native) लागू करते हैं, जिससे user/system CAs इंस्टॉल होने के बावजूद ट्रैफ़िक कैप्चर करना कठिन हो जाता है। एक व्यावहारिक तरीका यह है कि universal TLS unpinning को ready-made Frida hooks के माध्यम से proxy forcing के साथ मिलाया जाए, और सब कुछ mitmproxy/Burp के माध्यम से रूट किया जाए।

Workflow
- अपने host पर mitmproxy चलाएँ (या Burp)। सुनिश्चित करें कि डिवाइस host के IP/port तक पहुँच सकता है।
- HTTP Toolkit के consolidated Frida hooks लोड करें ताकि TLS unpinning और आम स्टैक्स (OkHttp/OkHttp3, HttpsURLConnection, Conscrypt, WebView, आदि) में proxy उपयोग को जबरदस्ती लागू किया जा सके। यह CertificatePinner/TrustManager चेक्स को बायपास करता है और proxy selectors को ओवरराइड करता है, इसलिए ट्रैफ़िक हमेशा आपके proxy के माध्यम से भेजा जाता है भले ही ऐप स्पष्ट रूप से proxies को निष्क्रिय कर दे।
- Frida और hook script के साथ लक्ष्य ऐप शुरू करें, और mitmproxy में requests कैप्चर करें।

Example
```bash
# Device connected via ADB or over network (-U)
# See the repo for the exact script names & options
frida -U -f com.vendor.app \
-l ./android-unpinning-with-proxy.js \
--no-pause

# mitmproxy listening locally
mitmproxy -p 8080
```
नोट्स
- संभव होने पर system-wide proxy के साथ मिलाएँ via `adb shell settings put global http_proxy <host>:<port>`. Frida hooks proxy के उपयोग को लागू करेंगे भले ही apps global settings को bypass करें।
- यह technique आदर्श है जब आपको MITM mobile-to-IoT onboarding flows करने की ज़रूरत हो, जहाँ pinning/proxy avoidance आम है।
- Hooks: https://github.com/httptoolkit/frida-interception-and-unpinning

## संदर्भ

- [Reversing Android Apps: Bypassing Detection Like a Pro](https://www.kayssel.com/newsletter/issue-12/)
- [Frida Codeshare](https://codeshare.frida.re/)
- [Objection](https://github.com/sensepost/objection)
- [apk-mitm](https://github.com/shroudedcode/apk-mitm)
- [Jadx](https://github.com/skylot/jadx)
- [Ghidra](https://ghidra-sre.org/)
- [r2frida](https://github.com/nowsecure/r2frida)
- [Apktool install guide](https://apktool.org/docs/install)
- [Magisk](https://github.com/topjohnwu/Magisk)
- [Medusa (Android Frida framework)](https://github.com/Ch0pin/medusa)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [Frida OkHttp4 SSL pinning bypass script](https://github.com/Zero3141/Frida-OkHttp-Bypass)
- [XDA guide to strong Play Integrity bypass (2025)](https://xdaforums.com/t/updated-11-17-2025-guide-get-strong-integrity-fix-banking-apps-revolut-google-wallet-android-16-working.4753805/)

{{#include ../../banners/hacktricks-training.md}}
