# Android Anti-Instrumentation & SSL Pinning Bypass (Frida/Objection)

{{#include ../../banners/hacktricks-training.md}}

Cette page propose un workflow pratique pour retrouver une analyse dynamique contre des apps Android qui détectent/empêchent l'instrumentation ou appliquent le TLS pinning. Elle se concentre sur le triage rapide, les détections courantes et des hooks/tactiques copiables-collables pour les contourner sans repack lorsque possible.

## Surface de détection (ce que les apps vérifient)

- Root checks: su binary, Magisk paths, getprop values, common root packages
- Frida/debugger checks (Java): Debug.isDebuggerConnected(), ActivityManager.getRunningAppProcesses(), getRunningServices(), scanning /proc, classpath, loaded libs
- Native anti‑debug: ptrace(), syscalls, anti‑attach, breakpoints, inline hooks
- Early init checks: Application.onCreate() or process start hooks that crash if instrumentation is present
- TLS pinning: custom TrustManager/HostnameVerifier, OkHttp CertificatePinner, Conscrypt pinning, native pins

## Étape 1 — Victoire rapide : cacher le root avec Magisk DenyList

- Activez Zygisk dans Magisk
- Activez DenyList, ajoutez le package cible
- Redémarrez et retestez

Beaucoup d'apps ne cherchent que des indicateurs évidents (su/Magisk paths/getprop). DenyList neutralise souvent les vérifications naïves.

Références:
- Magisk (Zygisk & DenyList): https://github.com/topjohnwu/Magisk

### Play Integrity / Zygisk detections (post‑SafetyNet)

Les applications bancaires/ID récentes lient les vérifications runtime à Google Play Integrity (remplaçant de SafetyNet) et peuvent aussi planter si Zygisk est présent. Conseils de triage rapide :

- Désactivez temporairement Zygisk (toggle off + reboot) et réessayez ; certaines apps plantent dès que l'injection Zygote est chargée.
- Si l'attestation bloque la connexion, patchez Google Play Services avec PlayIntegrityFix/Fork + TrickyStore ou utilisez ReZygisk/Zygisk‑Next uniquement lors des tests. Gardez la cible dans DenyList et évitez les modules LSPosed qui leak props.
- Pour des exécutions ponctuelles, utilisez KernelSU/APatch (pas d'injection Zygote) pour rester en dessous des heuristiques Zygisk, puis attachez Frida.

## Étape 2 — Tests Frida Codeshare de 30 secondes

Essayez des scripts drop‑in courants avant d'approfondir :

- anti-root-bypass.js
- anti-frida-detection.js
- hide_frida_gum.js

Exemple:
```bash
frida -U -f com.example.app -l anti-frida-detection.js
```
Ces modules désactivent généralement les vérifications Java de root/debug, les scans de processus/services et le ptrace() natif. Utile pour les applications peu protégées ; les cibles durcies peuvent nécessiter des hooks sur mesure.

- Codeshare: https://codeshare.frida.re/

## Automatiser avec Medusa (Frida framework)

Medusa propose 90+ modules prêts à l'emploi pour SSL unpinning, root/emulator detection bypass, HTTP comms logging, crypto key interception, et plus encore.
```bash
git clone https://github.com/Ch0pin/medusa
cd medusa
pip install -r requirements.txt
python medusa.py

# Example interactive workflow
show categories
use http_communications/multiple_unpinner
use root_detection/universal_root_detection_bypass
run com.target.app
```
Astuce : Medusa est idéal pour obtenir des résultats rapides avant d'écrire des hooks personnalisés. Vous pouvez aussi sélectionner des modules et les combiner avec vos propres scripts.

## Étape 3 — Contourner les détecteurs d'init en s'attachant tardivement

De nombreuses détections ne s'exécutent que lors du process spawn/onCreate(). Spawn‑time injection (-f) ou gadgets sont détectés ; s'attacher après le chargement de l'UI peut permettre de passer outre.
```bash
# Launch the app normally (launcher/adb), wait for UI, then attach
frida -U -n com.example.app
# Or with Objection to attach to running process
aobjection --gadget com.example.app explore  # if using gadget
```
Si cela fonctionne, gardez la session stable et procédez à la cartographie et aux vérifications des stubs.

## Étape 4 — Cartographier la logique de détection via Jadx et recherche de chaînes

Mots-clés de triage statique dans Jadx :
- "frida", "gum", "root", "magisk", "ptrace", "su", "getprop", "debugger"

Modèles Java typiques :
```java
public boolean isFridaDetected() {
return getRunningServices().contains("frida");
}
```
APIs courantes à examiner/hook:
- android.os.Debug.isDebuggerConnected
- android.app.ActivityManager.getRunningAppProcesses / getRunningServices
- java.lang.System.loadLibrary / System.load (native bridge)
- java.lang.Runtime.exec / ProcessBuilder (probing commands)
- android.os.SystemProperties.get (root/emulator heuristics)

## Étape 5 — Runtime stubbing with Frida (Java)

Surcharger les garde-fous personnalisés pour renvoyer des valeurs sûres sans repacking:
```js
Java.perform(() => {
const Checks = Java.use('com.example.security.Checks');
Checks.isFridaDetected.implementation = function () { return false; };

// Neutralize debugger checks
const Debug = Java.use('android.os.Debug');
Debug.isDebuggerConnected.implementation = function () { return false; };

// Example: kill ActivityManager scans
const AM = Java.use('android.app.ActivityManager');
AM.getRunningAppProcesses.implementation = function () { return java.util.Collections.emptyList(); };
});
```
Triage des plantages précoces ? Dump classes juste avant qu'il ne plante pour repérer les namespaces de détection probables :
```js
Java.perform(() => {
Java.enumerateLoadedClasses({
onMatch: n => console.log(n),
onComplete: () => console.log('Done')
});
});
```
```javascript
// Quick root detection stub example (adapt to target package/class names)
Java.perform(() => {
try {
const RootChecker = Java.use('com.target.security.RootCheck');
RootChecker.isDeviceRooted.implementation = function () { return false; };
} catch (e) {}
});
```

Consigner et neutraliser les méthodes suspectes pour confirmer le flux d'exécution :
```js
Java.perform(() => {
const Det = Java.use('com.example.security.DetectionManager');
Det.checkFrida.implementation = function () {
console.log('checkFrida() called');
return false;
};
});
```
## Contourner la détection d'émulateur/VM (Java stubs)

Heuristiques courantes : Build.FINGERPRINT/MODEL/MANUFACTURER/HARDWARE contenant generic/goldfish/ranchu/sdk ; artefacts QEMU comme /dev/qemu_pipe, /dev/socket/qemud ; MAC par défaut 02:00:00:00:00:00 ; NAT 10.0.2.x ; téléphonie/capteurs manquants.

Falsification rapide des champs Build :
```js
Java.perform(function(){
var Build = Java.use('android.os.Build');
Build.MODEL.value = 'Pixel 7 Pro';
Build.MANUFACTURER.value = 'Google';
Build.BRAND.value = 'google';
Build.FINGERPRINT.value = 'google/panther/panther:14/UP1A.231105.003/1234567:user/release-keys';
});
```
Complétez avec des stubs pour les vérifications d'existence de fichiers et les identifiants (TelephonyManager.getDeviceId/SubscriberId, WifiInfo.getMacAddress, SensorManager.getSensorList) afin de retourner des valeurs réalistes.

## SSL pinning bypass quick hook (Java)

Neutraliser les TrustManagers personnalisés et forcer des SSL contexts permissifs :
```js
Java.perform(function(){
var X509TrustManager = Java.use('javax.net.ssl.X509TrustManager');
var SSLContext = Java.use('javax.net.ssl.SSLContext');

// No-op validations
X509TrustManager.checkClientTrusted.implementation = function(){ };
X509TrustManager.checkServerTrusted.implementation = function(){ };

// Force permissive TrustManagers
var TrustManagers = [ X509TrustManager.$new() ];
var SSLContextInit = SSLContext.init.overload('[Ljavax.net.ssl.KeyManager;','[Ljavax.net.ssl.TrustManager;','java.security.SecureRandom');
SSLContextInit.implementation = function(km, tm, sr){
return SSLContextInit.call(this, km, TrustManagers, sr);
};
});
```
Remarques
- Adapter pour OkHttp : hook okhttp3.CertificatePinner et HostnameVerifier selon les besoins, ou utiliser un script d'unpinning universel depuis CodeShare.
- Exemple d'exécution : `frida -U -f com.target.app -l ssl-bypass.js --no-pause`

### OkHttp4 / gRPC / Cronet pinning (2024+)

Les stacks modernes effectuent du pinning dans des API plus récentes (OkHttp4+, gRPC over Cronet/BoringSSL). Ajoutez ces hooks lorsque le hook SSLContext de base bloque :
```js
Java.perform(() => {
try {
const Pinner = Java.use('okhttp3.CertificatePinner');
Pinner.check.overload('java.lang.String', 'java.util.List').implementation = function(){};
Pinner.check$okhttp.implementation = function(){};
} catch (e) {}

try {
const CronetB = Java.use('org.chromium.net.CronetEngine$Builder');
CronetB.enablePublicKeyPinningBypassForLocalTrustAnchors.overload('boolean').implementation = function(){ return this; };
CronetB.setPublicKeyPins.overload('java.lang.String', 'java.util.Set', 'boolean').implementation = function(){ return this; };
} catch (e) {}
});
```
Si TLS échoue encore, passez au natif et appliquez un patch aux points d'entrée de vérification de BoringSSL utilisés par Cronet/gRPC :
```js
const customVerify = Module.findExportByName(null, 'SSL_CTX_set_custom_verify');
if (customVerify) {
Interceptor.attach(customVerify, {
onEnter(args){
// arg0 = SSL_CTX*, arg1 = mode, arg2 = callback
args[1] = ptr(0); // SSL_VERIFY_NONE
args[2] = NULL;  // disable callback
}
});
}
```
## Étape 6 — Suivez la piste JNI/native lorsque les Java hooks échouent

Tracez les points d'entrée JNI pour localiser les native loaders et l'init de détection:
```bash
frida-trace -n com.example.app -i "JNI_OnLoad"
```
Triage natif rapide des fichiers .so embarqués :
```bash
# List exported symbols & JNI
nm -D libfoo.so | head
objdump -T libfoo.so | grep Java_
strings -n 6 libfoo.so | egrep -i 'frida|ptrace|gum|magisk|su|root'
```
Reversing interactif/native:
- Ghidra: https://ghidra-sre.org/
- r2frida: https://github.com/nowsecure/r2frida

Exemple: neutraliser ptrace pour contourner un anti‑debug simple dans libc:
```js
const ptrace = Module.findExportByName(null, 'ptrace');
if (ptrace) {
Interceptor.replace(ptrace, new NativeCallback(function () {
return -1; // pretend failure
}, 'int', ['int', 'int', 'pointer', 'pointer']));
}
```
Voir aussi :
{{#ref}}
reversing-native-libraries.md
{{#endref}}

## Étape 7 — Objection patching (embed gadget / strip basics)

Si vous préférez le repacking aux runtime hooks, essayez :
```bash
objection patchapk --source app.apk
```
Notes :
- Nécessite apktool ; assurez‑vous d'avoir une version à jour depuis le guide officiel pour éviter des problèmes de build : https://apktool.org/docs/install
- Gadget injection permet l'instrumentation sans root mais peut toujours être détecté par des vérifications d'init plus strictes.

En option, ajoutez des modules LSPosed et Shamiko pour un masquage root renforcé dans les environnements Zygisk, et soignez la DenyList pour couvrir les processus enfants.

Pour un workflow complet incluant la configuration du Gadget en script-mode et l'emballage de votre Frida 17+ agent dans l'APK, voir :

[Frida Tutorial — Self-contained agent + Gadget embedding](frida-tutorial/README.md)

Références :
- Objection : https://github.com/sensepost/objection

## Étape 8 — Repli : Patch TLS pinning pour la visibilité réseau

Si l'instrumentation est bloquée, vous pouvez toujours inspecter le trafic en supprimant le pinning de manière statique :
```bash
apk-mitm app.apk
# Then install the patched APK and proxy via Burp/mitmproxy
```
- Outil: https://github.com/shroudedcode/apk-mitm
- Pour les astuces de configuration réseau CA‑trust (et Android 7+ user CA trust), voir :

{{#ref}}
make-apk-accept-ca-certificate.md
{{#endref}}

{{#ref}}
install-burp-certificate.md
{{#endref}}

## Fiche pratique des commandes
```bash
# List processes and attach
frida-ps -Uai
frida -U -n com.example.app

# Spawn with a script (may trigger detectors)
frida -U -f com.example.app -l anti-frida-detection.js

# Trace native init
frida-trace -n com.example.app -i "JNI_OnLoad"

# Objection runtime
objection --gadget com.example.app explore

# Static TLS pinning removal
apk-mitm app.apk
```
## Universal proxy forcing + TLS unpinning (HTTP Toolkit Frida hooks)

Les applications modernes ignorent souvent les system proxies et imposent plusieurs couches de pinning (Java + native), rendant la capture du trafic pénible même avec des user/system CAs installées. Une approche pratique consiste à combiner universal TLS unpinning avec proxy forcing via des Frida hooks prêts à l'emploi, et à router tout via mitmproxy/Burp.

Workflow
- Run mitmproxy on your host (or Burp). Ensure the device can reach the host IP/port.
- Load HTTP Toolkit’s consolidated Frida hooks to both unpin TLS and force proxy usage across common stacks (OkHttp/OkHttp3, HttpsURLConnection, Conscrypt, WebView, etc.). This bypasses CertificatePinner/TrustManager checks and overrides proxy selectors, so traffic is always sent via your proxy even if the app explicitly disables proxies.
- Start the target app with Frida and the hook script, and capture requests in mitmproxy.

Exemple
```bash
# Device connected via ADB or over network (-U)
# See the repo for the exact script names & options
frida -U -f com.vendor.app \
-l ./android-unpinning-with-proxy.js \
--no-pause

# mitmproxy listening locally
mitmproxy -p 8080
```
Remarques
- Combinez avec un proxy système global via `adb shell settings put global http_proxy <host>:<port>` lorsque possible. Les hooks Frida feront respecter l'utilisation du proxy même lorsque les applications contournent les paramètres globaux.
- Cette technique est idéale lorsque vous devez effectuer un MITM des flux d'onboarding mobile vers IoT où le pinning/évitement du proxy est courant.
- Hooks: https://github.com/httptoolkit/frida-interception-and-unpinning

## Références

- [Reversing Android Apps: Bypassing Detection Like a Pro](https://www.kayssel.com/newsletter/issue-12/)
- [Frida Codeshare](https://codeshare.frida.re/)
- [Objection](https://github.com/sensepost/objection)
- [apk-mitm](https://github.com/shroudedcode/apk-mitm)
- [Jadx](https://github.com/skylot/jadx)
- [Ghidra](https://ghidra-sre.org/)
- [r2frida](https://github.com/nowsecure/r2frida)
- [Apktool install guide](https://apktool.org/docs/install)
- [Magisk](https://github.com/topjohnwu/Magisk)
- [Medusa (Android Frida framework)](https://github.com/Ch0pin/medusa)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [Frida OkHttp4 SSL pinning bypass script](https://github.com/Zero3141/Frida-OkHttp-Bypass)
- [XDA guide to strong Play Integrity bypass (2025)](https://xdaforums.com/t/updated-11-17-2025-guide-get-strong-integrity-fix-banking-apps-revolut-google-wallet-android-16-working.4753805/)

{{#include ../../banners/hacktricks-training.md}}
