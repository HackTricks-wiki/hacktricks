# Android 反注入与 SSL Pinning 绕过 (Frida/Objection)

{{#include ../../banners/hacktricks-training.md}}

本页提供一个实用工作流程，用于恢复对检测到或阻止 instrumentation 或强制 TLS pinning 的 Android 应用的动态分析。侧重快速分诊、常见检测点，以及可复制粘贴的 hooks/tactics，在可能的情况下无需重新打包即可绕过。

## Detection Surface (what apps check)

- Root checks: su 二进制、Magisk 路径、getprop 值、常见 root 包
- Frida/debugger checks (Java): Debug.isDebuggerConnected(), ActivityManager.getRunningAppProcesses(), getRunningServices(), 扫描 /proc、classpath、已加载的 libs
- Native anti‑debug: ptrace(), syscalls, anti‑attach、断点、inline hooks
- Early init checks: Application.onCreate() 或进程启动时的 hooks，如果检测到 instrumentation 则导致崩溃
- TLS pinning: custom TrustManager/HostnameVerifier、OkHttp CertificatePinner、Conscrypt pinning、本地 native pins

## Step 1 — Quick win: hide root with Magisk DenyList

- 在 Magisk 中启用 Zygisk
- 启用 DenyList，添加目标包
- 重启并重新测试

许多应用仅查找明显的指示器（su/Magisk 路径/getprop）。DenyList 通常可以中和这些简单的检测。

References:
- Magisk (Zygisk & DenyList): https://github.com/topjohnwu/Magisk

## Step 2 — 30‑second Frida Codeshare tests

在深入之前尝试常见的 drop‑in 脚本：

- anti-root-bypass.js
- anti-frida-detection.js
- hide_frida_gum.js

Example:
```bash
frida -U -f com.example.app -l anti-frida-detection.js
```
这些通常会 stub Java 的 root/debug 检查、process/service 扫描和原生 ptrace()。适用于保护较轻的应用；加固目标可能需要定制化的 hooks。

- Codeshare: https://codeshare.frida.re/

## 使用 Medusa 自动化（Frida framework）

Medusa 提供 90+ 即用模块，用于 SSL unpinning、root/emulator detection bypass、HTTP comms logging、crypto key interception 等。
```bash
git clone https://github.com/Ch0pin/medusa
cd medusa
pip install -r requirements.txt
python medusa.py

# Example interactive workflow
show categories
use http_communications/multiple_unpinner
use root_detection/universal_root_detection_bypass
run com.target.app
```
提示：Medusa 非常适合在编写自定义 hooks 之前快速获得成果。你也可以 cherry-pick modules，并将它们与自己的 scripts 结合使用。

## 第 3 步 — 通过延后 attaching 绕过 init-time 检测器

许多检测仅在 process spawn/onCreate() 阶段运行。Spawn‑time injection (-f) 或 gadgets 会被发现；在 UI 加载之后再进行 attaching 则可能绕过检测。
```bash
# Launch the app normally (launcher/adb), wait for UI, then attach
frida -U -n com.example.app
# Or with Objection to attach to running process
aobjection --gadget com.example.app explore  # if using gadget
```
如果这有效，保持会话稳定并继续进行映射和 stub 检查。

## 第4步 — 通过 Jadx 和字符串搜索映射检测逻辑

在 Jadx 中用于静态初筛的关键字：
- "frida", "gum", "root", "magisk", "ptrace", "su", "getprop", "debugger"

典型的 Java 模式：
```java
public boolean isFridaDetected() {
return getRunningServices().contains("frida");
}
```
常见需要审查/hook的 API：
- android.os.Debug.isDebuggerConnected
- android.app.ActivityManager.getRunningAppProcesses / getRunningServices
- java.lang.System.loadLibrary / System.load (native bridge)
- java.lang.Runtime.exec / ProcessBuilder (probing commands)
- android.os.SystemProperties.get (root/emulator heuristics)

## 第5步 — Runtime stubbing with Frida (Java)

覆写自定义防护以返回安全值，无需重新打包：
```js
Java.perform(() => {
const Checks = Java.use('com.example.security.Checks');
Checks.isFridaDetected.implementation = function () { return false; };

// Neutralize debugger checks
const Debug = Java.use('android.os.Debug');
Debug.isDebuggerConnected.implementation = function () { return false; };

// Example: kill ActivityManager scans
const AM = Java.use('android.app.ActivityManager');
AM.getRunningAppProcesses.implementation = function () { return java.util.Collections.emptyList(); };
});
```
在对早期崩溃进行分级吗？就在它崩溃之前转储类，以找出可能的检测命名空间：
```js
Java.perform(() => {
Java.enumerateLoadedClasses({
onMatch: n => console.log(n),
onComplete: () => console.log('Done')
});
});
```
// Quick root detection stub example (adapt to target package/class names)
Java.perform(() => {
try {
const RootChecker = Java.use('com.target.security.RootCheck');
RootChecker.isDeviceRooted.implementation = function () { return false; };
} catch (e) {}
});

记录并使可疑方法失效以确认执行流程：
```js
Java.perform(() => {
const Det = Java.use('com.example.security.DetectionManager');
Det.checkFrida.implementation = function () {
console.log('checkFrida() called');
return false;
};
});
```
## Bypass emulator/VM detection (Java stubs)

常见启发式规则：Build.FINGERPRINT/MODEL/MANUFACTURER/HARDWARE 包含 generic/goldfish/ranchu/sdk；存在 QEMU 伪像，如 /dev/qemu_pipe、/dev/socket/qemud；默认 MAC 02:00:00:00:00:00；10.0.2.x NAT；缺少 telephony/sensors。

快速伪装 Build 字段：
```js
Java.perform(function(){
var Build = Java.use('android.os.Build');
Build.MODEL.value = 'Pixel 7 Pro';
Build.MANUFACTURER.value = 'Google';
Build.BRAND.value = 'google';
Build.FINGERPRINT.value = 'google/panther/panther:14/UP1A.231105.003/1234567:user/release-keys';
});
```
补充用于文件存在性检查和标识符的桩（TelephonyManager.getDeviceId/SubscriberId, WifiInfo.getMacAddress, SensorManager.getSensorList），以返回真实的值。

## SSL pinning bypass quick hook (Java)

使自定义 TrustManagers 失效并强制使用宽松的 SSL contexts：
```js
Java.perform(function(){
var X509TrustManager = Java.use('javax.net.ssl.X509TrustManager');
var SSLContext = Java.use('javax.net.ssl.SSLContext');

// No-op validations
X509TrustManager.checkClientTrusted.implementation = function(){ };
X509TrustManager.checkServerTrusted.implementation = function(){ };

// Force permissive TrustManagers
var TrustManagers = [ X509TrustManager.$new() ];
var SSLContextInit = SSLContext.init.overload('[Ljavax.net.ssl.KeyManager;','[Ljavax.net.ssl.TrustManager;','java.security.SecureRandom');
SSLContextInit.implementation = function(km, tm, sr){
return SSLContextInit.call(this, km, TrustManagers, sr);
};
});
```
注意
- 针对 OkHttp 扩展：按需 hook okhttp3.CertificatePinner 和 HostnameVerifier，或使用来自 CodeShare 的通用 unpinning 脚本。
- 运行示例: `frida -U -f com.target.app -l ssl-bypass.js --no-pause`

## 第 6 步 — 在 Java hooks 失效时追踪 JNI/native 轨迹

追踪 JNI entry points 以定位 native loaders 和 detection init:
```bash
frida-trace -n com.example.app -i "JNI_OnLoad"
```
对捆绑的 .so 文件进行快速本地初步分析:
```bash
# List exported symbols & JNI
nm -D libfoo.so | head
objdump -T libfoo.so | grep Java_
strings -n 6 libfoo.so | egrep -i 'frida|ptrace|gum|magisk|su|root'
```
交互式/本地 reversing:
- Ghidra: https://ghidra-sre.org/
- r2frida: https://github.com/nowsecure/r2frida

示例：使 ptrace 失效以绕过 libc 中的简单 anti‑debug:
```js
const ptrace = Module.findExportByName(null, 'ptrace');
if (ptrace) {
Interceptor.replace(ptrace, new NativeCallback(function () {
return -1; // pretend failure
}, 'int', ['int', 'int', 'pointer', 'pointer']));
}
```
另见：
{{#ref}}
reversing-native-libraries.md
{{#endref}}

## 第7步 — Objection patching (embed gadget / strip basics)

当你更倾向于 repacking 而不是 runtime hooks 时，尝试：
```bash
objection patchapk --source app.apk
```
Notes:
- Requires apktool; ensure a current version from the official guide to avoid build issues: https://apktool.org/docs/install
- Gadget injection enables instrumentation without root but can still be caught by stronger init‑time checks.

Optionally, add LSPosed modules and Shamiko for stronger root hiding in Zygisk environments, and curate DenyList to cover child processes.

References:
- Objection: https://github.com/sensepost/objection

## Step 8 — 后备：修补 TLS pinning 以实现网络可见性

如果 instrumentation 被阻止，你仍然可以通过静态移除 pinning 来检查流量：
```bash
apk-mitm app.apk
# Then install the patched APK and proxy via Burp/mitmproxy
```
- 工具: https://github.com/shroudedcode/apk-mitm
- 有关网络配置 CA‑trust 技巧（以及 Android 7+ 用户 CA trust），请参见：

{{#ref}}
make-apk-accept-ca-certificate.md
{{#endref}}

{{#ref}}
install-burp-certificate.md
{{#endref}}

## 常用命令速查表
```bash
# List processes and attach
frida-ps -Uai
frida -U -n com.example.app

# Spawn with a script (may trigger detectors)
frida -U -f com.example.app -l anti-frida-detection.js

# Trace native init
frida-trace -n com.example.app -i "JNI_OnLoad"

# Objection runtime
objection --gadget com.example.app explore

# Static TLS pinning removal
apk-mitm app.apk
```
## 提示与注意事项

- 当应用在启动时崩溃时，优先延后 attach 而不是 spawn
- 某些检测会在关键流程（例如 payment、auth）中重新触发 — 在导航过程中保持 hooks 激活
- 结合静态与动态：在 Jadx 中进行 string hunt 以筛选类；然后 hook 方法以在 runtime 验证
- 被 Hardened 的应用可能使用 packers 和 native TLS pinning — 预计需要 reverse native code

## References

- [Reversing Android Apps: Bypassing Detection Like a Pro](https://www.kayssel.com/newsletter/issue-12/)
- [Frida Codeshare](https://codeshare.frida.re/)
- [Objection](https://github.com/sensepost/objection)
- [apk-mitm](https://github.com/shroudedcode/apk-mitm)
- [Jadx](https://github.com/skylot/jadx)
- [Ghidra](https://ghidra-sre.org/)
- [r2frida](https://github.com/nowsecure/r2frida)
- [Apktool install guide](https://apktool.org/docs/install)
- [Magisk](https://github.com/topjohnwu/Magisk)
- [Medusa (Android Frida framework)](https://github.com/Ch0pin/medusa)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)

{{#include ../../banners/hacktricks-training.md}}
