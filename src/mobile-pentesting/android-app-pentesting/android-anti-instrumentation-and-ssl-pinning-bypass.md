# Android Anti-Instrumentation & SSL Pinning Bypass (Frida/Objection)

{{#include ../../banners/hacktricks-training.md}}

Ця сторінка дає практичний workflow для відновлення dynamic analysis проти Android додатків, які детектують/блокують instrumentation через root або застосовують TLS pinning. Фокус на швидке triage, поширені детекції та copy‑pasteable hooks/тактики для обходу без repacking коли це можливо.

## Detection Surface (what apps check)

- Root checks: su binary, Magisk paths, getprop values, common root packages
- Frida/debugger checks (Java): Debug.isDebuggerConnected(), ActivityManager.getRunningAppProcesses(), getRunningServices(), сканування /proc, classpath, завантажені libs
- Native anti‑debug: ptrace(), syscalls, anti‑attach, breakpoints, inline hooks
- Early init checks: Application.onCreate() або hooks при старті процесу, які падають якщо instrumentation присутня
- TLS pinning: custom TrustManager/HostnameVerifier, OkHttp CertificatePinner, Conscrypt pinning, native pins

## Step 1 — Quick win: hide root with Magisk DenyList

- Увімкніть Zygisk у Magisk
- Увімкніть DenyList, додайте цільовий пакет
- Reboot і повторно протестуйте

Багато додатків шукають лише очевидні індикатори (su/Magisk paths/getprop). DenyList часто нейтралізує наївні перевірки.

References:
- Magisk (Zygisk & DenyList): https://github.com/topjohnwu/Magisk

### Play Integrity / Zygisk detections (post‑SafetyNet)

Новіші banking/ID додатки прив'язують runtime checks до Google Play Integrity (заміна SafetyNet) і також можуть падати якщо сам Zygisk присутній. Швидкі поради для triage:

- Тимчасово відключіть Zygisk (toggle off + reboot) і спробуйте ще раз; деякі додатки падають одразу після завантаження Zygote injection.
- Якщо attestation блокує логін, пропатчіть Google Play Services за допомогою PlayIntegrityFix/Fork + TrickyStore або використовуйте ReZygisk/Zygisk‑Next тільки під час тестування. Тримайте ціль у DenyList і уникайте LSPosed модулів, які leak props.
- Для одноразових запусків використовуйте KernelSU/APatch (без Zygote injection), щоб залишатися нижче порогів Zygisk, а потім підключіть Frida.

## Step 2 — 30‑second Frida Codeshare tests

Спробуйте поширені drop‑in скрипти перед глибоким зануренням:

- anti-root-bypass.js
- anti-frida-detection.js
- hide_frida_gum.js

Example:
```bash
frida -U -f com.example.app -l anti-frida-detection.js
```
Вони зазвичай підмінюють Java root/debug checks, process/service scans і native ptrace(). Корисні для слабо захищених додатків; більш захищені цілі можуть вимагати індивідуальних hooks.

- Codeshare: https://codeshare.frida.re/

## Автоматизація з Medusa (Frida framework)

Medusa надає 90+ готових модулів для SSL unpinning, root/emulator detection bypass, HTTP comms logging, crypto key interception та багато іншого.
```bash
git clone https://github.com/Ch0pin/medusa
cd medusa
pip install -r requirements.txt
python medusa.py

# Example interactive workflow
show categories
use http_communications/multiple_unpinner
use root_detection/universal_root_detection_bypass
run com.target.app
```
Порада: Medusa чудово підходить для швидких перемог перед написанням власних hooks. Ви також можете вибірково підбирати modules і комбінувати їх зі своїми scripts.

## Крок 3 — Обійти детектори ініціалізаційного часу, підключившись пізніше

Багато механізмів виявлення виконуються лише під час запуску процесу/onCreate(). Spawn‑time injection (-f) або gadgets потрапляють у виявлення; підключення після завантаження UI може дозволити їх оминути.
```bash
# Launch the app normally (launcher/adb), wait for UI, then attach
frida -U -n com.example.app
# Or with Objection to attach to running process
aobjection --gadget com.example.app explore  # if using gadget
```
Якщо це спрацює, утримуйте сесію стабільною та переходьте до перевірок map і stub.

## Крок 4 — Картування логіки виявлення за допомогою Jadx та пошуку рядків

- Статичні ключові слова для тріажу в Jadx:
  - "frida", "gum", "root", "magisk", "ptrace", "su", "getprop", "debugger"

Типові патерни Java:
```java
public boolean isFridaDetected() {
return getRunningServices().contains("frida");
}
```
Поширені API для перегляду/hook:
- android.os.Debug.isDebuggerConnected
- android.app.ActivityManager.getRunningAppProcesses / getRunningServices
- java.lang.System.loadLibrary / System.load (native bridge)
- java.lang.Runtime.exec / ProcessBuilder (probing commands)
- android.os.SystemProperties.get (root/emulator heuristics)

## Крок 5 — Runtime stubbing with Frida (Java)

Перевизначте власні guards, щоб повертати безпечні значення без repacking:
```js
Java.perform(() => {
const Checks = Java.use('com.example.security.Checks');
Checks.isFridaDetected.implementation = function () { return false; };

// Neutralize debugger checks
const Debug = Java.use('android.os.Debug');
Debug.isDebuggerConnected.implementation = function () { return false; };

// Example: kill ActivityManager scans
const AM = Java.use('android.app.ActivityManager');
AM.getRunningAppProcesses.implementation = function () { return java.util.Collections.emptyList(); };
});
```
Тріаж ранніх збоїв? Зробіть дамп класів одразу перед падінням, щоб виявити ймовірні простори імен, пов'язані з детекцією:
```js
Java.perform(() => {
Java.enumerateLoadedClasses({
onMatch: n => console.log(n),
onComplete: () => console.log('Done')
});
});
```
// Quick root detection stub example (adapt to target package/class names)
Java.perform(() => {
try {
const RootChecker = Java.use('com.target.security.RootCheck');
RootChecker.isDeviceRooted.implementation = function () { return false; };
} catch (e) {}
});

Логувати та нейтралізувати підозрілі методи, щоб підтвердити потік виконання:
```js
Java.perform(() => {
const Det = Java.use('com.example.security.DetectionManager');
Det.checkFrida.implementation = function () {
console.log('checkFrida() called');
return false;
};
});
```
## Bypass emulator/VM detection (Java stubs)

Загальні евристики: Build.FINGERPRINT/MODEL/MANUFACTURER/HARDWARE, які містять generic/goldfish/ranchu/sdk; артефакти QEMU, такі як /dev/qemu_pipe, /dev/socket/qemud; стандартна MAC 02:00:00:00:00:00; 10.0.2.x NAT; відсутні телефонні функції/датчики.

Швидкий spoof полів Build:
```js
Java.perform(function(){
var Build = Java.use('android.os.Build');
Build.MODEL.value = 'Pixel 7 Pro';
Build.MANUFACTURER.value = 'Google';
Build.BRAND.value = 'google';
Build.FINGERPRINT.value = 'google/panther/panther:14/UP1A.231105.003/1234567:user/release-keys';
});
```
Доповніть заглушками для перевірок існування файлів та ідентифікаторів (TelephonyManager.getDeviceId/SubscriberId, WifiInfo.getMacAddress, SensorManager.getSensorList), щоб повертати реалістичні значення.

## SSL pinning bypass quick hook (Java)

Нейтралізувати кастомні TrustManagers і примусово застосувати дозволяючі SSL contexts:
```js
Java.perform(function(){
var X509TrustManager = Java.use('javax.net.ssl.X509TrustManager');
var SSLContext = Java.use('javax.net.ssl.SSLContext');

// No-op validations
X509TrustManager.checkClientTrusted.implementation = function(){ };
X509TrustManager.checkServerTrusted.implementation = function(){ };

// Force permissive TrustManagers
var TrustManagers = [ X509TrustManager.$new() ];
var SSLContextInit = SSLContext.init.overload('[Ljavax.net.ssl.KeyManager;','[Ljavax.net.ssl.TrustManager;','java.security.SecureRandom');
SSLContextInit.implementation = function(km, tm, sr){
return SSLContextInit.call(this, km, TrustManagers, sr);
};
});
```
Примітки
- Розширте для OkHttp: hook okhttp3.CertificatePinner and HostnameVerifier as needed, or use a universal unpinning script from CodeShare.
- Приклад запуску: `frida -U -f com.target.app -l ssl-bypass.js --no-pause`

### OkHttp4 / gRPC / Cronet pinning (2024+)

Сучасні стеки pin всередині новіших APIs (OkHttp4+, gRPC over Cronet/BoringSSL). Додайте ці hooks, коли базовий SSLContext hook зависає:
```js
Java.perform(() => {
try {
const Pinner = Java.use('okhttp3.CertificatePinner');
Pinner.check.overload('java.lang.String', 'java.util.List').implementation = function(){};
Pinner.check$okhttp.implementation = function(){};
} catch (e) {}

try {
const CronetB = Java.use('org.chromium.net.CronetEngine$Builder');
CronetB.enablePublicKeyPinningBypassForLocalTrustAnchors.overload('boolean').implementation = function(){ return this; };
CronetB.setPublicKeyPins.overload('java.lang.String', 'java.util.Set', 'boolean').implementation = function(){ return this; };
} catch (e) {}
});
```
Якщо TLS все ще не вдається, перейдіть на native і пропатчіть точки входу перевірки BoringSSL, які використовуються Cronet/gRPC:
```js
const customVerify = Module.findExportByName(null, 'SSL_CTX_set_custom_verify');
if (customVerify) {
Interceptor.attach(customVerify, {
onEnter(args){
// arg0 = SSL_CTX*, arg1 = mode, arg2 = callback
args[1] = ptr(0); // SSL_VERIFY_NONE
args[2] = NULL;  // disable callback
}
});
}
```
## Крок 6 — Слідуйте JNI/native слідом, коли Java hooks не спрацьовують

Відстежте точки входу JNI, щоб знайти native loaders і detection init:
```bash
frida-trace -n com.example.app -i "JNI_OnLoad"
```
Швидкий нативний огляд вбудованих .so файлів:
```bash
# List exported symbols & JNI
nm -D libfoo.so | head
objdump -T libfoo.so | grep Java_
strings -n 6 libfoo.so | egrep -i 'frida|ptrace|gum|magisk|su|root'
```
Інтерактивне/нативне reversing:
- Ghidra: https://ghidra-sre.org/
- r2frida: https://github.com/nowsecure/r2frida

Приклад: деактивувати ptrace, щоб обійти простий anti‑debug у libc:
```js
const ptrace = Module.findExportByName(null, 'ptrace');
if (ptrace) {
Interceptor.replace(ptrace, new NativeCallback(function () {
return -1; // pretend failure
}, 'int', ['int', 'int', 'pointer', 'pointer']));
}
```
Див. також:
{{#ref}}
reversing-native-libraries.md
{{#endref}}

## Крок 7 — Objection patching (embed gadget / strip basics)

Якщо ви віддаєте перевагу repacking перед runtime hooks, спробуйте:
```bash
objection patchapk --source app.apk
```
Примітки:
- Requires apktool; ensure a current version from the official guide to avoid build issues: https://apktool.org/docs/install
- Gadget injection enables instrumentation without root but can still be caught by stronger init‑time checks.

Optionally, add LSPosed modules and Shamiko for stronger root hiding in Zygisk environments, and curate DenyList to cover child processes.

For a complete workflow including script-mode Gadget configuration and bundling your Frida 17+ agent into the APK, see:

[Frida Tutorial — Self-contained agent + Gadget embedding](frida-tutorial/README.md)

Посилання:
- Objection: https://github.com/sensepost/objection

## Крок 8 — Резервний варіант: Виправлення TLS pinning для видимості мережі

Якщо instrumentation заблоковано, ви все ще можете аналізувати трафік, видаливши pinning статично:
```bash
apk-mitm app.apk
# Then install the patched APK and proxy via Burp/mitmproxy
```
- Інструмент: https://github.com/shroudedcode/apk-mitm
- Для трюків з довірою CA в конфігурації мережі (та довіри користувацьких CA в Android 7+), див.:

{{#ref}}
make-apk-accept-ca-certificate.md
{{#endref}}

{{#ref}}
install-burp-certificate.md
{{#endref}}

## Зручна шпаргалка команд
```bash
# List processes and attach
frida-ps -Uai
frida -U -n com.example.app

# Spawn with a script (may trigger detectors)
frida -U -f com.example.app -l anti-frida-detection.js

# Trace native init
frida-trace -n com.example.app -i "JNI_OnLoad"

# Objection runtime
objection --gadget com.example.app explore

# Static TLS pinning removal
apk-mitm app.apk
```
## Універсальний proxy forcing + TLS unpinning (HTTP Toolkit Frida hooks)

Сучасні додатки часто ігнорують системні проксі й застосовують кілька шарів pinning (Java + native), через що перехоплення трафіку ускладнюється навіть при встановлених user/system CAs. Практичний підхід — поєднати універсальний TLS unpinning із proxy forcing за допомогою готових Frida hooks і направити весь трафік через mitmproxy/Burp.

Workflow
- Run mitmproxy on your host (or Burp). Ensure the device can reach the host IP/port.
- Load HTTP Toolkit’s consolidated Frida hooks to both unpin TLS and force proxy usage across common stacks (OkHttp/OkHttp3, HttpsURLConnection, Conscrypt, WebView, etc.). This bypasses CertificatePinner/TrustManager checks and overrides proxy selectors, so traffic is always sent via your proxy even if the app explicitly disables proxies.
- Start the target app with Frida and the hook script, and capture requests in mitmproxy.

Example
```bash
# Device connected via ADB or over network (-U)
# See the repo for the exact script names & options
frida -U -f com.vendor.app \
-l ./android-unpinning-with-proxy.js \
--no-pause

# mitmproxy listening locally
mitmproxy -p 8080
```
Примітки
- У разі можливості комбінуйте з system-wide proxy за допомогою `adb shell settings put global http_proxy <host>:<port>`. Frida hooks забезпечуватимуть примусове використання proxy навіть коли додатки оминають глобальні налаштування.
- Ця техніка ідеальна, коли потрібно виконати MITM mobile-to-IoT onboarding flows, де pinning/proxy avoidance є поширеним.
- Hooks: https://github.com/httptoolkit/frida-interception-and-unpinning

## References

- [Reversing Android Apps: Bypassing Detection Like a Pro](https://www.kayssel.com/newsletter/issue-12/)
- [Frida Codeshare](https://codeshare.frida.re/)
- [Objection](https://github.com/sensepost/objection)
- [apk-mitm](https://github.com/shroudedcode/apk-mitm)
- [Jadx](https://github.com/skylot/jadx)
- [Ghidra](https://ghidra-sre.org/)
- [r2frida](https://github.com/nowsecure/r2frida)
- [Apktool install guide](https://apktool.org/docs/install)
- [Magisk](https://github.com/topjohnwu/Magisk)
- [Medusa (Android Frida framework)](https://github.com/Ch0pin/medusa)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [Frida OkHttp4 SSL pinning bypass script](https://github.com/Zero3141/Frida-OkHttp-Bypass)
- [XDA guide to strong Play Integrity bypass (2025)](https://xdaforums.com/t/updated-11-17-2025-guide-get-strong-integrity-fix-banking-apps-revolut-google-wallet-android-16-working.4753805/)

{{#include ../../banners/hacktricks-training.md}}
