# Contournement Anti‑Instrumentation & SSL Pinning sur Android (Frida/Objection)

{{#include ../../banners/hacktricks-training.md}}

Cette page fournit un flux de travail pratique pour reprendre l'analyse dynamique des applications Android qui détectent ou bloquent l'instrumentation via root, ou qui imposent le TLS pinning. Elle se concentre sur le triage rapide, les détections courantes et des hooks/tactiques copiables‑collables pour les contourner sans repacking quand c'est possible.

## Surface de détection (ce que les applications vérifient)

- Vérifications de root : binaire su, chemins Magisk, valeurs getprop, packages root courants
- Vérifications Frida/debugger (Java) : Debug.isDebuggerConnected(), ActivityManager.getRunningAppProcesses(), getRunningServices(), scan de /proc, classpath, libs chargées
- Anti‑debug natif : ptrace(), syscalls, anti‑attach, breakpoints, inline hooks
- Vérifications en init précoce : Application.onCreate() ou hooks de démarrage de processus qui plantent si une instrumentation est présente
- TLS pinning : TrustManager/HostnameVerifier personnalisés, OkHttp CertificatePinner, Conscrypt pinning, pins natifs

## Step 1 — Quick win: hide root with Magisk DenyList

- Activer Zygisk dans Magisk
- Activer DenyList, ajouter le package cible
- Redémarrer et retester

De nombreuses applications ne recherchent que des indicateurs évidents (su/chemins Magisk/getprop). DenyList neutralise souvent les vérifications naïves.

References:
- Magisk (Zygisk & DenyList): https://github.com/topjohnwu/Magisk

## Step 2 — 30‑second Frida Codeshare tests

Essayez les scripts drop‑in courants avant d'approfondir :

- anti-root-bypass.js
- anti-frida-detection.js
- hide_frida_gum.js

Example:
```bash
frida -U -f com.example.app -l anti-frida-detection.js
```
Ces outils remplacent généralement par des stubs les vérifications Java de root/debug, les analyses de processus/services et les appels natifs ptrace(). Utile pour des apps faiblement protégées ; les cibles durcies peuvent nécessiter des hooks sur mesure.

- Codeshare: https://codeshare.frida.re/

## Automatiser avec Medusa (Frida framework)

Medusa fournit plus de 90 modules prêts à l'emploi pour SSL unpinning, le bypass de la détection root/emulator, la journalisation des comms HTTP, l'interception de clés crypto, et plus encore.
```bash
git clone https://github.com/Ch0pin/medusa
cd medusa
pip install -r requirements.txt
python medusa.py

# Example interactive workflow
show categories
use http_communications/multiple_unpinner
use root_detection/universal_root_detection_bypass
run com.target.app
```
Astuce : Medusa est idéal pour obtenir des résultats rapides avant d'écrire des custom hooks. Vous pouvez aussi sélectionner des modules et les combiner avec vos propres scripts.

## Étape 3 — Contourner les détecteurs d'initialisation en s'attachant tard

De nombreuses détections ne s'exécutent que pendant le process spawn/onCreate(). Les injections au spawn (-f) ou les gadgets sont détectés ; en s'attachant après le chargement de l'UI, on peut passer outre.
```bash
# Launch the app normally (launcher/adb), wait for UI, then attach
frida -U -n com.example.app
# Or with Objection to attach to running process
aobjection --gadget com.example.app explore  # if using gadget
```
Si cela fonctionne, maintenez la session stable et procédez à la cartographie et aux stub checks.

## Étape 4 — Cartographier la logique de détection via Jadx et recherche de chaînes

Static triage keywords in Jadx:
- "frida", "gum", "root", "magisk", "ptrace", "su", "getprop", "debugger"

Schémas Java typiques:
```java
public boolean isFridaDetected() {
return getRunningServices().contains("frida");
}
```
APIs courantes à examiner/hook :
- android.os.Debug.isDebuggerConnected
- android.app.ActivityManager.getRunningAppProcesses / getRunningServices
- java.lang.System.loadLibrary / System.load (native bridge)
- java.lang.Runtime.exec / ProcessBuilder (probing commands)
- android.os.SystemProperties.get (root/emulator heuristics)

## Étape 5 — Runtime stubbing with Frida (Java)

Surcharger les guards personnalisés pour renvoyer des valeurs sûres sans repacking :
```js
Java.perform(() => {
const Checks = Java.use('com.example.security.Checks');
Checks.isFridaDetected.implementation = function () { return false; };

// Neutralize debugger checks
const Debug = Java.use('android.os.Debug');
Debug.isDebuggerConnected.implementation = function () { return false; };

// Example: kill ActivityManager scans
const AM = Java.use('android.app.ActivityManager');
AM.getRunningAppProcesses.implementation = function () { return java.util.Collections.emptyList(); };
});
```
Triaging early crashes? Dump classes juste avant qu'il ne plante pour repérer les namespaces de détection probables:
```js
Java.perform(() => {
Java.enumerateLoadedClasses({
onMatch: n => console.log(n),
onComplete: () => console.log('Done')
});
});
```
// Quick root detection stub example (adapt to target package/class names)
Java.perform(() => {
try {
const RootChecker = Java.use('com.target.security.RootCheck');
RootChecker.isDeviceRooted.implementation = function () { return false; };
} catch (e) {}
});

Enregistrez et neutralisez les méthodes suspectes pour confirmer le flux d'exécution :
```js
Java.perform(() => {
const Det = Java.use('com.example.security.DetectionManager');
Det.checkFrida.implementation = function () {
console.log('checkFrida() called');
return false;
};
});
```
## Bypass emulator/VM detection (Java stubs)

Heuristiques courantes : Build.FINGERPRINT/MODEL/MANUFACTURER/HARDWARE contenant generic/goldfish/ranchu/sdk ; artefacts QEMU comme /dev/qemu_pipe, /dev/socket/qemud ; MAC par défaut 02:00:00:00:00:00 ; NAT 10.0.2.x ; téléphonie/capteurs absents.

Falsification rapide des champs Build :
```js
Java.perform(function(){
var Build = Java.use('android.os.Build');
Build.MODEL.value = 'Pixel 7 Pro';
Build.MANUFACTURER.value = 'Google';
Build.BRAND.value = 'google';
Build.FINGERPRINT.value = 'google/panther/panther:14/UP1A.231105.003/1234567:user/release-keys';
});
```
Complétez avec des stubs pour les vérifications d'existence de fichiers et les identifiants (TelephonyManager.getDeviceId/SubscriberId, WifiInfo.getMacAddress, SensorManager.getSensorList) afin de renvoyer des valeurs réalistes.

## SSL pinning bypass quick hook (Java)

Neutraliser les TrustManagers personnalisés et forcer des SSL contexts permissifs :
```js
Java.perform(function(){
var X509TrustManager = Java.use('javax.net.ssl.X509TrustManager');
var SSLContext = Java.use('javax.net.ssl.SSLContext');

// No-op validations
X509TrustManager.checkClientTrusted.implementation = function(){ };
X509TrustManager.checkServerTrusted.implementation = function(){ };

// Force permissive TrustManagers
var TrustManagers = [ X509TrustManager.$new() ];
var SSLContextInit = SSLContext.init.overload('[Ljavax.net.ssl.KeyManager;','[Ljavax.net.ssl.TrustManager;','java.security.SecureRandom');
SSLContextInit.implementation = function(km, tm, sr){
return SSLContextInit.call(this, km, TrustManagers, sr);
};
});
```
Remarques
- Étendre pour OkHttp : hook okhttp3.CertificatePinner et HostnameVerifier selon les besoins, ou utiliser un script universel d'unpinning depuis CodeShare.
- Exemple d'exécution : `frida -U -f com.target.app -l ssl-bypass.js --no-pause`

## Étape 6 — Suivre la piste JNI/native lorsque les hooks Java échouent

Tracer les points d'entrée JNI pour localiser les chargeurs natifs et l'initialisation de la détection :
```bash
frida-trace -n com.example.app -i "JNI_OnLoad"
```
Triage natif rapide des fichiers .so embarqués :
```bash
# List exported symbols & JNI
nm -D libfoo.so | head
objdump -T libfoo.so | grep Java_
strings -n 6 libfoo.so | egrep -i 'frida|ptrace|gum|magisk|su|root'
```
Interactive/native reversing:
- Ghidra: https://ghidra-sre.org/
- r2frida: https://github.com/nowsecure/r2frida

Exemple : neutraliser ptrace pour contourner un anti‑debug simple dans libc:
```js
const ptrace = Module.findExportByName(null, 'ptrace');
if (ptrace) {
Interceptor.replace(ptrace, new NativeCallback(function () {
return -1; // pretend failure
}, 'int', ['int', 'int', 'pointer', 'pointer']));
}
```
Voir aussi:
{{#ref}}
reversing-native-libraries.md
{{#endref}}

## Étape 7 — Objection patching (embed gadget / strip basics)

Si vous préférez le repacking aux runtime hooks, essayez:
```bash
objection patchapk --source app.apk
```
Remarques :
- Requiert apktool ; assurez‑vous d'une version récente depuis le guide officiel pour éviter des problèmes de build : https://apktool.org/docs/install
- L'injection de Gadget permet l'instrumentation sans root mais peut quand même être détectée par des init‑time checks plus stricts.

Optionnellement, ajoutez des modules LSPosed et Shamiko pour un meilleur camouflage du root dans les environnements Zygisk, et soignez la DenyList pour couvrir les processus enfants.

Pour un workflow complet incluant la configuration de Gadget en mode script et l'intégration de votre agent Frida 17+ dans l'APK, voir :

[Frida Tutorial — Self-contained agent + Gadget embedding](frida-tutorial/README.md)

Références :
- Objection : https://github.com/sensepost/objection

## Étape 8 — Repli : Patch TLS pinning pour visibilité réseau

Si l'instrumentation est bloquée, vous pouvez toujours inspecter le trafic en supprimant le pinning statiquement :
```bash
apk-mitm app.apk
# Then install the patched APK and proxy via Burp/mitmproxy
```
- Outil: https://github.com/shroudedcode/apk-mitm
- Pour les astuces de config réseau CA‑trust (et la confiance CA utilisateur Android 7+), voir :

{{#ref}}
make-apk-accept-ca-certificate.md
{{#endref}}

{{#ref}}
install-burp-certificate.md
{{#endref}}

## Fiche mémo pratique des commandes
```bash
# List processes and attach
frida-ps -Uai
frida -U -n com.example.app

# Spawn with a script (may trigger detectors)
frida -U -f com.example.app -l anti-frida-detection.js

# Trace native init
frida-trace -n com.example.app -i "JNI_OnLoad"

# Objection runtime
objection --gadget com.example.app explore

# Static TLS pinning removal
apk-mitm app.apk
```
## Forçage universel de proxy + TLS unpinning (HTTP Toolkit Frida hooks)

Les applications modernes ignorent souvent les proxies système et appliquent plusieurs couches de pinning (Java + natif), rendant la capture du trafic douloureuse même avec des CAs utilisateur/système installées. Une approche pratique consiste à combiner unpin TLS universel avec le forçage de proxy via des hooks Frida prêts à l'emploi, et à router tout via mitmproxy/Burp.

Flux de travail
- Exécutez mitmproxy sur votre hôte (ou Burp). Assurez-vous que l'appareil peut atteindre l'IP/port de l'hôte.
- Chargez les hooks Frida consolidés de HTTP Toolkit pour à la fois unpin TLS et forcer l'utilisation du proxy sur les stacks courants (OkHttp/OkHttp3, HttpsURLConnection, Conscrypt, WebView, etc.). Cela contourne les vérifications CertificatePinner/TrustManager et remplace les sélecteurs de proxy, de sorte que le trafic est toujours envoyé via votre proxy même si l'app désactive explicitement les proxies.
- Démarrez l'application cible avec Frida et le script de hook, puis capturez les requêtes dans mitmproxy.

Exemple
```bash
# Device connected via ADB or over network (-U)
# See the repo for the exact script names & options
frida -U -f com.vendor.app \
-l ./android-unpinning-with-proxy.js \
--no-pause

# mitmproxy listening locally
mitmproxy -p 8080
```
Remarques
- Combinez avec un proxy système via `adb shell settings put global http_proxy <host>:<port>` quand c'est possible. Les Frida hooks imposeront l'utilisation du proxy même lorsque les apps contournent les paramètres globaux.
- Cette technique est idéale lorsque vous devez MITM des onboarding flows mobile-to-IoT où pinning/proxy avoidance est courant.
- Hooks: https://github.com/httptoolkit/frida-interception-and-unpinning

## Références

- [Reversing Android Apps: Bypassing Detection Like a Pro](https://www.kayssel.com/newsletter/issue-12/)
- [Frida Codeshare](https://codeshare.frida.re/)
- [Objection](https://github.com/sensepost/objection)
- [apk-mitm](https://github.com/shroudedcode/apk-mitm)
- [Jadx](https://github.com/skylot/jadx)
- [Ghidra](https://ghidra-sre.org/)
- [r2frida](https://github.com/nowsecure/r2frida)
- [Apktool install guide](https://apktool.org/docs/install)
- [Magisk](https://github.com/topjohnwu/Magisk)
- [Medusa (Android Frida framework)](https://github.com/Ch0pin/medusa)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)

{{#include ../../banners/hacktricks-training.md}}
