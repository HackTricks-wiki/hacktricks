# Android Anti-Instrumentation & SSL Pinning Bypass (Frida/Objection)

{{#include ../../banners/hacktricks-training.md}}

यह पेज उन Android apps के खिलाफ डायनेमिक एनालिसिस को फिर से हासिल करने के लिए एक व्यावहारिक वर्कफ़्लो देता है जो instrumentation का पता लगाते/रूट‑ब्लॉक करते हैं या TLS pinning लागू करते हैं। यह तेज़ ट्रायज, आम डिटेक्शन, और बिना रैपैक किए संभव होने पर सीधे कॉपी‑पेस्ट करने योग्य hooks/tactics पर केंद्रित है।

## Detection Surface (what apps check)

- Root checks: su binary, Magisk paths, getprop values, common root packages
- Frida/debugger checks (Java): Debug.isDebuggerConnected(), ActivityManager.getRunningAppProcesses(), getRunningServices(), scanning /proc, classpath, loaded libs
- Native anti‑debug: ptrace(), syscalls, anti‑attach, breakpoints, inline hooks
- Early init checks: Application.onCreate() or process start hooks that crash if instrumentation is present
- TLS pinning: custom TrustManager/HostnameVerifier, OkHttp CertificatePinner, Conscrypt pinning, native pins

## Step 1 — Quick win: Magisk DenyList से root छुपाएँ

- Zygisk को Magisk में Enable करें
- DenyList को Enable करें, target package जोड़ें
- रीबूट करें और पुनः परीक्षण करें

कई apps सिर्फ़ स्पष्ट संकेतों (su/Magisk paths/getprop) को देखते हैं। DenyList अक्सर साधारण जाँचों को निष्क्रिय कर देता है।

References:
- Magisk (Zygisk & DenyList): https://github.com/topjohnwu/Magisk

## Step 2 — 30‑second Frida Codeshare टेस्ट

डीप डाइव करने से पहले सामान्य drop‑in scripts आज़माएँ:

- anti-root-bypass.js
- anti-frida-detection.js
- hide_frida_gum.js

Example:
```bash
frida -U -f com.example.app -l anti-frida-detection.js
```
ये आमतौर पर Java root/debug checks, process/service scans, और native ptrace() को stub करते हैं। हल्के सुरक्षा वाले apps में उपयोगी; hardened targets के लिए tailored hooks की ज़रूरत हो सकती है।

- Codeshare: https://codeshare.frida.re/

## Medusa (Frida framework) के साथ स्वचालित करें

Medusa 90+ तैयार मॉड्यूल प्रदान करता है जो SSL unpinning, root/emulator detection bypass, HTTP comms logging, crypto key interception, और अन्य चीज़ों के लिए हैं।
```bash
git clone https://github.com/Ch0pin/medusa
cd medusa
pip install -r requirements.txt
python medusa.py

# Example interactive workflow
show categories
use http_communications/multiple_unpinner
use root_detection/universal_root_detection_bypass
run com.target.app
```
टिप: Medusa कस्टम hooks लिखने से पहले quick wins के लिए शानदार है। आप modules को भी cherry-pick कर सकते हैं और उन्हें अपने scripts के साथ combine कर सकते हैं।

## Step 3 — init-time detectors को bypass करने के लिए देर से attach करें

कई detections केवल process spawn/onCreate() के दौरान ही चलते हैं। Spawn‑time injection (-f) या gadgets पकड़े जा सकते हैं; UI load होने के बाद attach करने से इनसे बचा जा सकता है।
```bash
# Launch the app normally (launcher/adb), wait for UI, then attach
frida -U -n com.example.app
# Or with Objection to attach to running process
aobjection --gadget com.example.app explore  # if using gadget
```
यदि यह काम करता है, session को स्थिर रखें और map और stub checks पर आगे बढ़ें।

## चरण 4 — Jadx और string hunting के माध्यम से detection logic का मैप बनाएं

Jadx में static triage के keywords:
- "frida", "gum", "root", "magisk", "ptrace", "su", "getprop", "debugger"

सामान्य Java पैटर्न:
```java
public boolean isFridaDetected() {
return getRunningServices().contains("frida");
}
```
सामान्य APIs जिन्हें review/hook करना चाहिए:
- android.os.Debug.isDebuggerConnected
- android.app.ActivityManager.getRunningAppProcesses / getRunningServices
- java.lang.System.loadLibrary / System.load (native bridge)
- java.lang.Runtime.exec / ProcessBuilder (probing commands)
- android.os.SystemProperties.get (root/emulator heuristics)

## चरण 5 — Runtime stubbing with Frida (Java)

कस्टम guards को ओवरराइड करके सुरक्षित मान लौटाएँ बिना repacking किए:
```js
Java.perform(() => {
const Checks = Java.use('com.example.security.Checks');
Checks.isFridaDetected.implementation = function () { return false; };

// Neutralize debugger checks
const Debug = Java.use('android.os.Debug');
Debug.isDebuggerConnected.implementation = function () { return false; };

// Example: kill ActivityManager scans
const AM = Java.use('android.app.ActivityManager');
AM.getRunningAppProcesses.implementation = function () { return java.util.Collections.emptyList(); };
});
```
प्रारंभिक क्रैशेस की ट्रायजिंग कर रहे हैं? बंद होने से ठीक पहले classes को dump करें ताकि संभावित detection namespaces का पता चल सके:
```js
Java.perform(() => {
Java.enumerateLoadedClasses({
onMatch: n => console.log(n),
onComplete: () => console.log('Done')
});
});
```
// Quick root detection stub example (adapt to target package/class names)
Java.perform(() => {
try {
const RootChecker = Java.use('com.target.security.RootCheck');
RootChecker.isDeviceRooted.implementation = function () { return false; };
} catch (e) {}
});

संदिग्ध मेथड्स को लॉग करें और निष्क्रिय करें ताकि निष्पादन प्रवाह की पुष्टि हो सके:
```js
Java.perform(() => {
const Det = Java.use('com.example.security.DetectionManager');
Det.checkFrida.implementation = function () {
console.log('checkFrida() called');
return false;
};
});
```
## Bypass emulator/VM detection (Java stubs)

सामान्य ह्यूरिस्टिक्स: Build.FINGERPRINT/MODEL/MANUFACTURER/HARDWARE में generic/goldfish/ranchu/sdk होना; QEMU अवशेष जैसे /dev/qemu_pipe, /dev/socket/qemud; default MAC 02:00:00:00:00:00; 10.0.2.x NAT; telephony/sensors की कमी।

Build fields का त्वरित spoof:
```js
Java.perform(function(){
var Build = Java.use('android.os.Build');
Build.MODEL.value = 'Pixel 7 Pro';
Build.MANUFACTURER.value = 'Google';
Build.BRAND.value = 'google';
Build.FINGERPRINT.value = 'google/panther/panther:14/UP1A.231105.003/1234567:user/release-keys';
});
```
फ़ाइल अस्तित्व जांच और पहचानकर्ताओं (TelephonyManager.getDeviceId/SubscriberId, WifiInfo.getMacAddress, SensorManager.getSensorList) के लिए स्टब जोड़ें ताकि वे वास्तविक दिखने वाले मान लौटाएँ।

## SSL pinning bypass quick hook (Java)

कस्टम TrustManagers को निष्क्रिय करें और permissive SSL contexts को लागू करें:
```js
Java.perform(function(){
var X509TrustManager = Java.use('javax.net.ssl.X509TrustManager');
var SSLContext = Java.use('javax.net.ssl.SSLContext');

// No-op validations
X509TrustManager.checkClientTrusted.implementation = function(){ };
X509TrustManager.checkServerTrusted.implementation = function(){ };

// Force permissive TrustManagers
var TrustManagers = [ X509TrustManager.$new() ];
var SSLContextInit = SSLContext.init.overload('[Ljavax.net.ssl.KeyManager;','[Ljavax.net.ssl.TrustManager;','java.security.SecureRandom');
SSLContextInit.implementation = function(km, tm, sr){
return SSLContextInit.call(this, km, TrustManagers, sr);
};
});
```
नोट्स
- OkHttp के लिए बढ़ाएँ: आवश्यकता अनुसार okhttp3.CertificatePinner और HostnameVerifier को hook करें, या CodeShare से एक universal unpinning script का उपयोग करें।
- उदाहरण चलाएँ: `frida -U -f com.target.app -l ssl-bypass.js --no-pause`

## चरण 6 — Java hooks विफल होने पर JNI/native ट्रेल का पालन करें

JNI एंट्री पॉइंट्स को ट्रेस करें ताकि native loaders और detection init का पता लगाया जा सके:
```bash
frida-trace -n com.example.app -i "JNI_OnLoad"
```
बंडल किए गए .so फ़ाइलों का त्वरित नेटिव ट्रायेज़:
```bash
# List exported symbols & JNI
nm -D libfoo.so | head
objdump -T libfoo.so | grep Java_
strings -n 6 libfoo.so | egrep -i 'frida|ptrace|gum|magisk|su|root'
```
Interactive/native reversing:
- Ghidra: https://ghidra-sre.org/
- r2frida: https://github.com/nowsecure/r2frida

उदाहरण: neuter ptrace to defeat simple anti‑debug in libc:
```js
const ptrace = Module.findExportByName(null, 'ptrace');
if (ptrace) {
Interceptor.replace(ptrace, new NativeCallback(function () {
return -1; // pretend failure
}, 'int', ['int', 'int', 'pointer', 'pointer']));
}
```
See also:
{{#ref}}
reversing-native-libraries.md
{{#endref}}

## चरण 7 — Objection patching (embed gadget / strip basics)

जब आप runtime hooks की बजाय repacking को प्राथमिकता देते हैं, तो आज़माएँ:
```bash
objection patchapk --source app.apk
```
नोट:
- apktool आवश्यक है; निर्माण समस्याओं से बचने के लिए आधिकारिक मार्गदर्शिका से नवीनतम संस्करण सुनिश्चित करें: https://apktool.org/docs/install
- Gadget injection root के बिना instrumentation सक्षम करता है, लेकिन इसे मजबूत init‑time checks द्वारा अभी भी पकड़ा जा सकता है।

इच्छानुसार, Zygisk environments में मजबूत root छुपाने के लिए LSPosed modules और Shamiko जोड़ें, और child processes को कवर करने के लिए DenyList को क्यूरेट करें।

पूर्ण वर्कफ़्लो के लिए जिसमें script-mode Gadget configuration और अपने Frida 17+ agent को APK में bundle करना शामिल है, देखें:

[Frida Tutorial — Self-contained agent + Gadget embedding](frida-tutorial/README.md)

संदर्भ:
- Objection: https://github.com/sensepost/objection

## चरण 8 — फ़ॉलबैक: नेटवर्क दृश्यता के लिए TLS pinning को पैच करें

यदि instrumentation अवरुद्ध है, तो आप pinning को स्थैतिक रूप से हटाकर ट्रैफ़िक का निरीक्षण कर सकते हैं:
```bash
apk-mitm app.apk
# Then install the patched APK and proxy via Burp/mitmproxy
```
- टूल: https://github.com/shroudedcode/apk-mitm
- नेटवर्क कॉन्फ़िग CA‑trust ट्रिक्स (और Android 7+ user CA trust) के लिए देखें:

{{#ref}}
make-apk-accept-ca-certificate.md
{{#endref}}

{{#ref}}
install-burp-certificate.md
{{#endref}}

## उपयोगी कमांड चीट‑शीट
```bash
# List processes and attach
frida-ps -Uai
frida -U -n com.example.app

# Spawn with a script (may trigger detectors)
frida -U -f com.example.app -l anti-frida-detection.js

# Trace native init
frida-trace -n com.example.app -i "JNI_OnLoad"

# Objection runtime
objection --gadget com.example.app explore

# Static TLS pinning removal
apk-mitm app.apk
```
## Universal proxy forcing + TLS unpinning (HTTP Toolkit Frida hooks)

आधुनिक ऐप्स अक्सर system proxies को अनदेखा करते हैं और pinning की कई परतें लागू करते हैं (Java + native), जिससे ट्रैफ़िक कैप्चर करना, भले ही user/system CAs इंस्टॉल हों, काफी मुश्किल हो जाता है। एक व्यावहारिक तरीका है ready-made Frida hooks के जरिए universal TLS unpinning को proxy forcing के साथ मिलाना और सब कुछ mitmproxy/Burp के माध्यम से रूट करना।

Workflow
- अपने होस्ट पर mitmproxy चलाएँ (या Burp)। सुनिश्चित करें कि डिवाइस होस्ट के IP/port तक पहुँच सकता है।
- HTTP Toolkit’s consolidated Frida hooks लोड करें ताकि TLS unpin और सामान्य स्टैक्स (OkHttp/OkHttp3, HttpsURLConnection, Conscrypt, WebView, आदि) में proxy उपयोग को मजबूर किया जा सके। यह CertificatePinner/TrustManager चेक्स को बायपास करता है और proxy selectors को ओवरराइड करता है, इसलिए ट्रैफ़िक हमेशा आपके proxy के जरिए भेजा जाता है, भले ही ऐप स्पष्ट रूप से proxies को डिसेबल कर दे।
- Frida और hook script के साथ target app शुरू करें, और mitmproxy में requests कैप्चर करें।

Example
```bash
# Device connected via ADB or over network (-U)
# See the repo for the exact script names & options
frida -U -f com.vendor.app \
-l ./android-unpinning-with-proxy.js \
--no-pause

# mitmproxy listening locally
mitmproxy -p 8080
```
नोट्स
- संभव हो तो इसे सिस्टम-व्यापी proxy के साथ संयोजन करें via `adb shell settings put global http_proxy <host>:<port>`. The Frida hooks तब भी proxy के उपयोग को लागू करेंगे जब apps global settings को bypass करें।
- यह technique आदर्श है जब आपको MITM mobile-to-IoT onboarding flows की आवश्यकता हो, जहाँ pinning/proxy avoidance सामान्य है।
- Hooks: https://github.com/httptoolkit/frida-interception-and-unpinning

## संदर्भ

- [Reversing Android Apps: Bypassing Detection Like a Pro](https://www.kayssel.com/newsletter/issue-12/)
- [Frida Codeshare](https://codeshare.frida.re/)
- [Objection](https://github.com/sensepost/objection)
- [apk-mitm](https://github.com/shroudedcode/apk-mitm)
- [Jadx](https://github.com/skylot/jadx)
- [Ghidra](https://ghidra-sre.org/)
- [r2frida](https://github.com/nowsecure/r2frida)
- [Apktool install guide](https://apktool.org/docs/install)
- [Magisk](https://github.com/topjohnwu/Magisk)
- [Medusa (Android Frida framework)](https://github.com/Ch0pin/medusa)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)

{{#include ../../banners/hacktricks-training.md}}
