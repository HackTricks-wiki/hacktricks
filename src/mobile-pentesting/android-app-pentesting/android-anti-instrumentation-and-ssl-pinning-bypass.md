# Android एंटी‑इंस्ट्रूमेंटेशन और SSL पिनिंग बायपास (Frida/Objection)

{{#include ../../banners/hacktricks-training.md}}

यह पृष्ठ उन Android ऐप्स के खिलाफ डायनामिक एनालिसिस पुनः प्राप्त करने के लिए एक व्यावहारिक वर्कफ़्लो प्रदान करता है जो इंस्ट्रूमेंटेशन का पता लगाते/रूट‑ब्लॉक करते हैं या TLS पिनिंग लागू करते हैं। यह तेज़ ट्रायेज़, सामान्य डिटेक्शंस, और कॉपी‑पेस्ट करने योग्य hooks/तactics पर केंद्रित है ताकि संभव होने पर बिना repacking के बायपास किया जा सके।

## Detection Surface (what apps check)

- Root checks: su binary, Magisk paths, getprop values, common root packages
- Frida/debugger checks (Java): Debug.isDebuggerConnected(), ActivityManager.getRunningAppProcesses(), getRunningServices(), scanning /proc, classpath, loaded libs
- Native anti‑debug: ptrace(), syscalls, anti‑attach, breakpoints, inline hooks
- Early init checks: Application.onCreate() or process start hooks that crash if instrumentation is present
- TLS pinning: custom TrustManager/HostnameVerifier, OkHttp CertificatePinner, Conscrypt pinning, native pins

## Step 1 — Quick win: hide root with Magisk DenyList

- Enable Zygisk in Magisk
- Enable DenyList, add the target package
- Reboot and retest

Many apps only look for obvious indicators (su/Magisk paths/getprop). DenyList often neutralizes naive checks.

References:
- Magisk (Zygisk & DenyList): https://github.com/topjohnwu/Magisk

## Step 2 — 30‑second Frida Codeshare tests

Try common drop‑in scripts before deep diving:

- anti-root-bypass.js
- anti-frida-detection.js
- hide_frida_gum.js

Example:
```bash
frida -U -f com.example.app -l anti-frida-detection.js
```
ये आम तौर पर Java के root/debug checks, process/service scans और native ptrace() को स्टब करते हैं। हल्के-प्रोटेक्टेड apps में उपयोगी; hardened targets के लिए tailored hooks की आवश्यकता हो सकती है।

- Codeshare: https://codeshare.frida.re/

## Medusa (Frida framework) के साथ ऑटोमेट करें

Medusa 90+ तैयार-मॉड्यूल प्रदान करता है जो SSL unpinning, root/emulator detection bypass, HTTP comms logging, crypto key interception और अन्य के लिए उपयोगी हैं।
```bash
git clone https://github.com/Ch0pin/medusa
cd medusa
pip install -r requirements.txt
python medusa.py

# Example interactive workflow
show categories
use http_communications/multiple_unpinner
use root_detection/universal_root_detection_bypass
run com.target.app
```
टिप: Medusa custom hooks लिखने से पहले quick wins के लिए बहुत अच्छा है। आप modules को भी cherry-pick करके इन्हें अपने scripts के साथ combine कर सकते हैं।

## Step 3 — init-time detectors को देर से attach करके bypass करें

कई detections केवल process spawn/onCreate() के दौरान ही चलते हैं। Spawn‑time injection (-f) या gadgets पकड़े जा जाते हैं; UI loads होने के बाद attach करने पर आप अक्सर इन्हें bypass कर सकते हैं।
```bash
# Launch the app normally (launcher/adb), wait for UI, then attach
frida -U -n com.example.app
# Or with Objection to attach to running process
aobjection --gadget com.example.app explore  # if using gadget
```
यदि यह काम करता है, तो session को स्थिर रखें और map और stub checks पर आगे बढ़ें।

## चरण 4 — Jadx और string hunting के माध्यम से detection logic को मैप करें

Static triage keywords in Jadx:
- "frida", "gum", "root", "magisk", "ptrace", "su", "getprop", "debugger"

सामान्य Java पैटर्न:
```java
public boolean isFridaDetected() {
return getRunningServices().contains("frida");
}
```
समीक्षा/hook करने के लिए सामान्य APIs:
- android.os.Debug.isDebuggerConnected
- android.app.ActivityManager.getRunningAppProcesses / getRunningServices
- java.lang.System.loadLibrary / System.load (native bridge)
- java.lang.Runtime.exec / ProcessBuilder (probing commands)
- android.os.SystemProperties.get (root/emulator heuristics)

## चरण 5 — Runtime stubbing with Frida (Java)

repacking के बिना सुरक्षित मान लौटाने के लिए custom guards को override करें:
```js
Java.perform(() => {
const Checks = Java.use('com.example.security.Checks');
Checks.isFridaDetected.implementation = function () { return false; };

// Neutralize debugger checks
const Debug = Java.use('android.os.Debug');
Debug.isDebuggerConnected.implementation = function () { return false; };

// Example: kill ActivityManager scans
const AM = Java.use('android.app.ActivityManager');
AM.getRunningAppProcesses.implementation = function () { return java.util.Collections.emptyList(); };
});
```
प्रारंभिक क्रैशेस की ट्रायजिंग कर रहे हैं? संभावित detection namespaces का पता लगाने के लिए मरने से ठीक पहले classes को dump करें:
```js
Java.perform(() => {
Java.enumerateLoadedClasses({
onMatch: n => console.log(n),
onComplete: () => console.log('Done')
});
});
```
// Quick root detection stub example (adapt to target package/class names)
Java.perform(() => {
try {
const RootChecker = Java.use('com.target.security.RootCheck');
RootChecker.isDeviceRooted.implementation = function () { return false; };
} catch (e) {}
});

लॉग करें और संदिग्ध मेथड्स को निष्क्रिय करके निष्पादन प्रवाह की पुष्टि करें:
```js
Java.perform(() => {
const Det = Java.use('com.example.security.DetectionManager');
Det.checkFrida.implementation = function () {
console.log('checkFrida() called');
return false;
};
});
```
## Bypass emulator/VM detection (Java stubs)

सामान्य संकेत: Build.FINGERPRINT/MODEL/MANUFACTURER/HARDWARE में generic/goldfish/ranchu/sdk शामिल होना; QEMU artifacts जैसे /dev/qemu_pipe, /dev/socket/qemud; डिफ़ॉल्ट MAC 02:00:00:00:00:00; 10.0.2.x NAT; telephony/sensors का अभाव।

Build फ़ील्ड्स का त्वरित spoof:
```js
Java.perform(function(){
var Build = Java.use('android.os.Build');
Build.MODEL.value = 'Pixel 7 Pro';
Build.MANUFACTURER.value = 'Google';
Build.BRAND.value = 'google';
Build.FINGERPRINT.value = 'google/panther/panther:14/UP1A.231105.003/1234567:user/release-keys';
});
```
फाइल अस्तित्व जांच और पहचानकर्ताओं (TelephonyManager.getDeviceId/SubscriberId, WifiInfo.getMacAddress, SensorManager.getSensorList) के लिए स्टब जोड़ें ताकि वे यथार्थवादी मान लौटाएँ।

## SSL pinning bypass quick hook (Java)

कस्टम TrustManagers को निष्क्रिय करें और अनुमत SSL contexts लागू करने के लिए मजबूर करें:
```js
Java.perform(function(){
var X509TrustManager = Java.use('javax.net.ssl.X509TrustManager');
var SSLContext = Java.use('javax.net.ssl.SSLContext');

// No-op validations
X509TrustManager.checkClientTrusted.implementation = function(){ };
X509TrustManager.checkServerTrusted.implementation = function(){ };

// Force permissive TrustManagers
var TrustManagers = [ X509TrustManager.$new() ];
var SSLContextInit = SSLContext.init.overload('[Ljavax.net.ssl.KeyManager;','[Ljavax.net.ssl.TrustManager;','java.security.SecureRandom');
SSLContextInit.implementation = function(km, tm, sr){
return SSLContextInit.call(this, km, TrustManagers, sr);
};
});
```
नोट्स
- OkHttp के लिए बढ़ाएँ: आवश्यकतानुसार okhttp3.CertificatePinner और HostnameVerifier को hook करें, या CodeShare से एक universal unpinning script का उपयोग करें.
- उदाहरण चलाएँ: `frida -U -f com.target.app -l ssl-bypass.js --no-pause`

## चरण 6 — जब Java hooks असफल हों तो JNI/native trail का पालन करें

JNI entry points को ट्रेस करें ताकि native loaders और detection init का पता लगाया जा सके:
```bash
frida-trace -n com.example.app -i "JNI_OnLoad"
```
बंडल किए गए .so फ़ाइलों का त्वरित नेटिव ट्रायेज़:
```bash
# List exported symbols & JNI
nm -D libfoo.so | head
objdump -T libfoo.so | grep Java_
strings -n 6 libfoo.so | egrep -i 'frida|ptrace|gum|magisk|su|root'
```
इंटरैक्टिव/native reversing:
- Ghidra: https://ghidra-sre.org/
- r2frida: https://github.com/nowsecure/r2frida

उदाहरण: ptrace को निष्क्रिय करके libc में सरल anti‑debug को बेअसर करें:
```js
const ptrace = Module.findExportByName(null, 'ptrace');
if (ptrace) {
Interceptor.replace(ptrace, new NativeCallback(function () {
return -1; // pretend failure
}, 'int', ['int', 'int', 'pointer', 'pointer']));
}
```
संदर्भ:
{{#ref}}
reversing-native-libraries.md
{{#endref}}

## चरण 7 — Objection patching (embed gadget / strip basics)

जब आप runtime hooks की बजाय repacking को प्राथमिकता देते हैं, तो आज़माएँ:
```bash
objection patchapk --source app.apk
```
नोट्स:
- apktool आवश्यक है; बिल्ड समस्याओं से बचने के लिए आधिकारिक गाइड से नवीनतम संस्करण सुनिश्चित करें: https://apktool.org/docs/install
- Gadget injection बिना root के instrumentation सक्षम करता है, लेकिन इसे मजबूत init‑time checks द्वारा फिर भी पकड़ा जा सकता है।

वैकल्पिक रूप से, LSPosed modules और Shamiko जोड़ें ताकि Zygisk environments में root छुपाने को मजबूत किया जा सके, और child processes को कवर करने के लिए DenyList को curate करें।

References:
- Objection: https://github.com/sensepost/objection

## चरण 8 — Fallback: नेटवर्क दृश्यता के लिए TLS pinning को पैच करें

यदि instrumentation अवरुद्ध है, तो आप pinning को स्थैतिक रूप से हटाकर ट्रैफ़िक का निरीक्षण कर सकते हैं:
```bash
apk-mitm app.apk
# Then install the patched APK and proxy via Burp/mitmproxy
```
- टूल: https://github.com/shroudedcode/apk-mitm
- नेटवर्क कॉन्फ़िग CA‑trust ट्रिक्स (और Android 7+ user CA trust) के लिए देखें:

{{#ref}}
make-apk-accept-ca-certificate.md
{{#endref}}

{{#ref}}
install-burp-certificate.md
{{#endref}}

## उपयोगी कमांड चीट‑शीट
```bash
# List processes and attach
frida-ps -Uai
frida -U -n com.example.app

# Spawn with a script (may trigger detectors)
frida -U -f com.example.app -l anti-frida-detection.js

# Trace native init
frida-trace -n com.example.app -i "JNI_OnLoad"

# Objection runtime
objection --gadget com.example.app explore

# Static TLS pinning removal
apk-mitm app.apk
```
## टिप्स और सावधानियाँ

- ऐप्स लॉन्च पर क्रैश होने पर spawning के बजाय attaching late करना बेहतर है
- कुछ detections critical flows (e.g., payment, auth) में फिर से चलते हैं — navigation के दौरान hooks को active रखें
- static और dynamic को mix करें: Jadx में string hunt करके classes shortlist करें; फिर runtime पर verify करने के लिए methods को hook करें
- Hardened apps packers और native TLS pinning का उपयोग कर सकते हैं — native code को reverse करने की उम्मीद रखें

## संदर्भ

- [Reversing Android Apps: Bypassing Detection Like a Pro](https://www.kayssel.com/newsletter/issue-12/)
- [Frida Codeshare](https://codeshare.frida.re/)
- [Objection](https://github.com/sensepost/objection)
- [apk-mitm](https://github.com/shroudedcode/apk-mitm)
- [Jadx](https://github.com/skylot/jadx)
- [Ghidra](https://ghidra-sre.org/)
- [r2frida](https://github.com/nowsecure/r2frida)
- [Apktool install guide](https://apktool.org/docs/install)
- [Magisk](https://github.com/topjohnwu/Magisk)
- [Medusa (Android Frida framework)](https://github.com/Ch0pin/medusa)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)

{{#include ../../banners/hacktricks-training.md}}
