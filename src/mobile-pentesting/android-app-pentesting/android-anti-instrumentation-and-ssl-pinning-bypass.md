# Android Anti-Instrumentation & SSL Pinning Bypass (Frida/Objection)

{{#include ../../banners/hacktricks-training.md}}

This page provides a practical workflow to regain dynamic analysis against Android apps that detect/root‑block instrumentation or enforce TLS pinning. It focuses on fast triage, common detections, and copy‑pasteable hooks/tactics to bypass them without repacking when possible.

## Detection Surface (what apps check)

- Vérifications de root : binaire su, chemins Magisk, valeurs getprop, packages root courants
- Vérifications Frida/debugger (Java) : Debug.isDebuggerConnected(), ActivityManager.getRunningAppProcesses(), getRunningServices(), analyse de /proc, classpath, bibliothèques chargées
- Anti‑debug natif : ptrace(), syscalls, anti‑attach, breakpoints, inline hooks
- Vérifications d'initialisation précoce : Application.onCreate() ou hooks de démarrage de processus qui plantent si instrumentation est présente
- TLS pinning : TrustManager/HostnameVerifier personnalisés, OkHttp CertificatePinner, Conscrypt pinning, pinning natifs

## Step 1 — Quick win: hide root with Magisk DenyList

- Enable Zygisk in Magisk
- Enable DenyList, add the target package
- Reboot and retest

Many apps only look for obvious indicators (su/Magisk paths/getprop). DenyList often neutralizes naive checks.

References:
- Magisk (Zygisk & DenyList): https://github.com/topjohnwu/Magisk

## Step 2 — 30‑second Frida Codeshare tests

Try common drop‑in scripts before deep diving:

- anti-root-bypass.js
- anti-frida-detection.js
- hide_frida_gum.js

Example:
```bash
frida -U -f com.example.app -l anti-frida-detection.js
```
Ils neutralisent généralement les vérifications Java de root/debug, les scans de processus/services et l'appel natif ptrace(). Utile sur des applications faiblement protégées ; les cibles durcies peuvent nécessiter des hooks sur mesure.

- Codeshare: https://codeshare.frida.re/

## Automatiser avec Medusa (Frida framework)

Medusa fournit plus de 90 modules prêts à l'emploi pour SSL unpinning, root/emulator detection bypass, HTTP comms logging, crypto key interception, et plus encore.
```bash
git clone https://github.com/Ch0pin/medusa
cd medusa
pip install -r requirements.txt
python medusa.py

# Example interactive workflow
show categories
use http_communications/multiple_unpinner
use root_detection/universal_root_detection_bypass
run com.target.app
```
Tip: Medusa is great for quick wins before writing custom hooks. You can also cherry-pick modules and combine them with your own scripts.

## Étape 3 — Contourner les détecteurs d'initialisation en s'attachant tard

De nombreuses détections ne s'exécutent que lors du process spawn/onCreate(). Les Spawn‑time injection (-f) ou gadgets se font repérer ; en s'attachant après le chargement de l'UI, on peut les contourner.
```bash
# Launch the app normally (launcher/adb), wait for UI, then attach
frida -U -n com.example.app
# Or with Objection to attach to running process
aobjection --gadget com.example.app explore  # if using gadget
```
Si cela fonctionne, maintenez la session stable et procédez à la cartographie et aux vérifications des stubs.

## Étape 4 — Cartographier la logique de détection via Jadx et recherche de chaînes

Mots-clés de triage statique dans Jadx :
- "frida", "gum", "root", "magisk", "ptrace", "su", "getprop", "debugger"

Modèles Java typiques :
```java
public boolean isFridaDetected() {
return getRunningServices().contains("frida");
}
```
Common APIs to review/hook:
- android.os.Debug.isDebuggerConnected
- android.app.ActivityManager.getRunningAppProcesses / getRunningServices
- java.lang.System.loadLibrary / System.load (native bridge)
- java.lang.Runtime.exec / ProcessBuilder (probing commands)
- android.os.SystemProperties.get (root/emulator heuristics)

## Étape 5 — Runtime stubbing with Frida (Java)

Surchargez les guards personnalisés pour renvoyer des valeurs sûres sans repacking:
```js
Java.perform(() => {
const Checks = Java.use('com.example.security.Checks');
Checks.isFridaDetected.implementation = function () { return false; };

// Neutralize debugger checks
const Debug = Java.use('android.os.Debug');
Debug.isDebuggerConnected.implementation = function () { return false; };

// Example: kill ActivityManager scans
const AM = Java.use('android.app.ActivityManager');
AM.getRunningAppProcesses.implementation = function () { return java.util.Collections.emptyList(); };
});
```
Triage des crashes précoces ? Dump classes juste avant qu'il ne plante pour repérer les namespaces de détection probables :
```js
Java.perform(() => {
Java.enumerateLoadedClasses({
onMatch: n => console.log(n),
onComplete: () => console.log('Done')
});
});
```
```javascript
// Quick root detection stub example (adapt to target package/class names)
Java.perform(() => {
try {
const RootChecker = Java.use('com.target.security.RootCheck');
RootChecker.isDeviceRooted.implementation = function () { return false; };
} catch (e) {}
});
```

Consigner et neutraliser les méthodes suspectes pour confirmer le flux d'exécution :
```js
Java.perform(() => {
const Det = Java.use('com.example.security.DetectionManager');
Det.checkFrida.implementation = function () {
console.log('checkFrida() called');
return false;
};
});
```
## Bypass emulator/VM detection (Java stubs)

Heuristiques courantes : Build.FINGERPRINT/MODEL/MANUFACTURER/HARDWARE contenant generic/goldfish/ranchu/sdk ; artefacts QEMU comme /dev/qemu_pipe, /dev/socket/qemud ; MAC par défaut 02:00:00:00:00:00 ; NAT 10.0.2.x ; téléphonie/capteurs manquants.

Falsification rapide des champs Build :
```js
Java.perform(function(){
var Build = Java.use('android.os.Build');
Build.MODEL.value = 'Pixel 7 Pro';
Build.MANUFACTURER.value = 'Google';
Build.BRAND.value = 'google';
Build.FINGERPRINT.value = 'google/panther/panther:14/UP1A.231105.003/1234567:user/release-keys';
});
```
Compléter avec des stubs pour les vérifications d'existence de fichiers et les identifiants (TelephonyManager.getDeviceId/SubscriberId, WifiInfo.getMacAddress, SensorManager.getSensorList) afin de renvoyer des valeurs réalistes.

## SSL pinning bypass quick hook (Java)

Neutraliser les TrustManagers personnalisés et forcer des SSL contexts permissifs :
```js
Java.perform(function(){
var X509TrustManager = Java.use('javax.net.ssl.X509TrustManager');
var SSLContext = Java.use('javax.net.ssl.SSLContext');

// No-op validations
X509TrustManager.checkClientTrusted.implementation = function(){ };
X509TrustManager.checkServerTrusted.implementation = function(){ };

// Force permissive TrustManagers
var TrustManagers = [ X509TrustManager.$new() ];
var SSLContextInit = SSLContext.init.overload('[Ljavax.net.ssl.KeyManager;','[Ljavax.net.ssl.TrustManager;','java.security.SecureRandom');
SSLContextInit.implementation = function(km, tm, sr){
return SSLContextInit.call(this, km, TrustManagers, sr);
};
});
```
Remarques
- Étendre pour OkHttp : hook okhttp3.CertificatePinner et HostnameVerifier si nécessaire, ou utiliser un script universel d'unpinning depuis CodeShare.
- Exemple d'exécution : `frida -U -f com.target.app -l ssl-bypass.js --no-pause`

## Étape 6 — Suivre la piste JNI/native lorsque les Java hooks échouent

Tracer les points d'entrée JNI pour localiser les chargeurs natifs et l'initialisation de la détection :
```bash
frida-trace -n com.example.app -i "JNI_OnLoad"
```
Triage natif rapide des fichiers .so empaquetés :
```bash
# List exported symbols & JNI
nm -D libfoo.so | head
objdump -T libfoo.so | grep Java_
strings -n 6 libfoo.so | egrep -i 'frida|ptrace|gum|magisk|su|root'
```
Reversing interactif/natif:
- Ghidra: https://ghidra-sre.org/
- r2frida: https://github.com/nowsecure/r2frida

Exemple : neutraliser ptrace pour contourner un anti‑debug simple dans libc:
```js
const ptrace = Module.findExportByName(null, 'ptrace');
if (ptrace) {
Interceptor.replace(ptrace, new NativeCallback(function () {
return -1; // pretend failure
}, 'int', ['int', 'int', 'pointer', 'pointer']));
}
```
Voir aussi :
{{#ref}}
reversing-native-libraries.md
{{#endref}}

## Étape 7 — Objection patching (embed gadget / strip basics)

Si vous préférez repacking aux runtime hooks, essayez :
```bash
objection patchapk --source app.apk
```
Notes:
- Nécessite apktool ; assurez‑vous d’avoir une version à jour depuis le guide officiel pour éviter des problèmes de build : https://apktool.org/docs/install
- Gadget injection permet l'instrumentation sans root mais peut toujours être détecté par des vérifications plus strictes au démarrage.

En option, ajoutez des modules LSPosed et Shamiko pour un masquage du root plus efficace dans les environnements Zygisk, et soignez la DenyList pour couvrir les processus enfants.

References:
- Objection: https://github.com/sensepost/objection

## Étape 8 — Solution de repli : Corriger le TLS pinning pour la visibilité réseau

Si l'instrumentation est bloquée, vous pouvez toujours inspecter le trafic en supprimant statiquement le pinning :
```bash
apk-mitm app.apk
# Then install the patched APK and proxy via Burp/mitmproxy
```
- Outil: https://github.com/shroudedcode/apk-mitm
- Pour les astuces de configuration réseau CA‑trust (et Android 7+ user CA trust), voir :

{{#ref}}
make-apk-accept-ca-certificate.md
{{#endref}}

{{#ref}}
install-burp-certificate.md
{{#endref}}

## Fiche mémo pratique des commandes
```bash
# List processes and attach
frida-ps -Uai
frida -U -n com.example.app

# Spawn with a script (may trigger detectors)
frida -U -f com.example.app -l anti-frida-detection.js

# Trace native init
frida-trace -n com.example.app -i "JNI_OnLoad"

# Objection runtime
objection --gadget com.example.app explore

# Static TLS pinning removal
apk-mitm app.apk
```
## Conseils & mises en garde

- Privilégiez attaching late plutôt que spawning lorsque les apps plantent au lancement
- Certaines detections re‑run dans des critical flows (par ex. payment, auth) — gardez les hooks actifs pendant la navigation
- Mix static and dynamic : string hunt dans Jadx pour présélectionner des classes ; puis hook methods pour vérifier à runtime
- Les apps hardenées peuvent utiliser des packers et native TLS pinning — attendez‑vous à reverse native code

## References

- [Reversing Android Apps: Bypassing Detection Like a Pro](https://www.kayssel.com/newsletter/issue-12/)
- [Frida Codeshare](https://codeshare.frida.re/)
- [Objection](https://github.com/sensepost/objection)
- [apk-mitm](https://github.com/shroudedcode/apk-mitm)
- [Jadx](https://github.com/skylot/jadx)
- [Ghidra](https://ghidra-sre.org/)
- [r2frida](https://github.com/nowsecure/r2frida)
- [Apktool install guide](https://apktool.org/docs/install)
- [Magisk](https://github.com/topjohnwu/Magisk)
- [Medusa (Android Frida framework)](https://github.com/Ch0pin/medusa)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)

{{#include ../../banners/hacktricks-training.md}}
