# Android Anti-Instrumentation & SSL Pinning Bypass (Frida/Objection)

{{#include ../../banners/hacktricks-training.md}}

This page provides a practical workflow to regain dynamic analysis against Android apps that detect/root‑block instrumentation or enforce TLS pinning. It focuses on fast triage, common detections, and copy‑pasteable hooks/tactics to bypass them without repacking when possible.

## 检测面（应用会检查的内容）

- Root checks: su binary, Magisk paths, getprop values, common root packages
- Frida/debugger checks (Java): Debug.isDebuggerConnected(), ActivityManager.getRunningAppProcesses(), getRunningServices(), scanning /proc, classpath, loaded libs
- Native anti‑debug: ptrace(), syscalls, anti‑attach, breakpoints, inline hooks
- Early init checks: Application.onCreate() or process start hooks that crash if instrumentation is present
- TLS pinning: custom TrustManager/HostnameVerifier, OkHttp CertificatePinner, Conscrypt pinning, native pins

## 步骤 1 — 快速取胜：使用 Magisk DenyList 隐藏 root

- Enable Zygisk in Magisk
- Enable DenyList, add the target package
- Reboot and retest

许多应用只查找明显的指示器（su/Magisk 路径/getprop）。DenyList 常常能中和这些简单的检测。

参考：
- Magisk (Zygisk & DenyList): https://github.com/topjohnwu/Magisk

### Play Integrity / Zygisk dete测（post‑SafetyNet）

较新的银行/身份类应用会将运行时检查绑定到 Google Play Integrity（取代 SafetyNet），并且如果检测到 Zygisk 本身也可能会崩溃。快速分诊提示：

- Temporarily disable Zygisk (toggle off + reboot) and retry; some apps crash as soon as Zygote injection loads.
- If attestation blocks login, patch Google Play Services with PlayIntegrityFix/Fork + TrickyStore or use ReZygisk/Zygisk‑Next only when testing. Keep the target in DenyList and avoid LSPosed modules that leak props.
- For one‑off runs, use KernelSU/APatch (no Zygote injection) to stay under Zygisk heuristics, then attach Frida.

## 步骤 2 — 30‑秒 Frida Codeshare 测试

在深入分析前先尝试常见的可直接替换脚本：

- anti-root-bypass.js
- anti-frida-detection.js
- hide_frida_gum.js

示例：
```bash
frida -U -f com.example.app -l anti-frida-detection.js
```
这些通常对 Java root/debug checks、process/service scans 和原生 ptrace() 进行 stub。适用于防护较弱的应用；强化的目标可能需要定制化的 hooks。

- Codeshare: https://codeshare.frida.re/

## 使用 Medusa (Frida framework) 自动化

Medusa 提供 90+ 个现成模块，用于 SSL unpinning、root/emulator detection bypass、HTTP comms logging、crypto key interception 等。
```bash
git clone https://github.com/Ch0pin/medusa
cd medusa
pip install -r requirements.txt
python medusa.py

# Example interactive workflow
show categories
use http_communications/multiple_unpinner
use root_detection/universal_root_detection_bypass
run com.target.app
```
提示：Medusa 非常适合在编写自定义 hooks 之前快速取得成果。你也可以挑选 modules 并将它们与自己的 scripts 结合使用。

## 第 3 步 — 延后附加以绕过初始化时检测器

许多检测仅在进程 spawn/onCreate() 期间运行。Spawn‑time injection (-f) 或 gadgets 会被侦测到；在 UI 加载后再进行 attaching 可以绕过它们。
```bash
# Launch the app normally (launcher/adb), wait for UI, then attach
frida -U -n com.example.app
# Or with Objection to attach to running process
aobjection --gadget com.example.app explore  # if using gadget
```
如果这有效，保持会话稳定并继续进行映射和存根检查。

## Step 4 — 通过 Jadx 和字符串搜索映射检测逻辑

Static triage keywords in Jadx:
- "frida", "gum", "root", "magisk", "ptrace", "su", "getprop", "debugger"

典型的 Java 模式：
```java
public boolean isFridaDetected() {
return getRunningServices().contains("frida");
}
```
常见需审查/hook 的 API:
- android.os.Debug.isDebuggerConnected
- android.app.ActivityManager.getRunningAppProcesses / getRunningServices
- java.lang.System.loadLibrary / System.load (native bridge)
- java.lang.Runtime.exec / ProcessBuilder (probing commands)
- android.os.SystemProperties.get (root/emulator heuristics)

## 第 5 步 — 使用 Frida (Java) 进行运行时桩

覆写自定义防护以返回安全值，无需重新打包：
```js
Java.perform(() => {
const Checks = Java.use('com.example.security.Checks');
Checks.isFridaDetected.implementation = function () { return false; };

// Neutralize debugger checks
const Debug = Java.use('android.os.Debug');
Debug.isDebuggerConnected.implementation = function () { return false; };

// Example: kill ActivityManager scans
const AM = Java.use('android.app.ActivityManager');
AM.getRunningAppProcesses.implementation = function () { return java.util.Collections.emptyList(); };
});
```
在处理早期崩溃时？在应用崩溃前导出类以发现可能的检测命名空间：
```js
Java.perform(() => {
Java.enumerateLoadedClasses({
onMatch: n => console.log(n),
onComplete: () => console.log('Done')
});
});
```
// Quick root detection stub example (adapt to target package/class names)
Java.perform(() => {
try {
const RootChecker = Java.use('com.target.security.RootCheck');
RootChecker.isDeviceRooted.implementation = function () { return false; };
} catch (e) {}
});

记录并中和可疑方法以确认执行流程：
```js
Java.perform(() => {
const Det = Java.use('com.example.security.DetectionManager');
Det.checkFrida.implementation = function () {
console.log('checkFrida() called');
return false;
};
});
```
## Bypass emulator/VM detection (Java stubs)

常见启发式：Build.FINGERPRINT/MODEL/MANUFACTURER/HARDWARE 中包含 generic/goldfish/ranchu/sdk；QEMU 伪迹如 /dev/qemu_pipe、/dev/socket/qemud；默认 MAC 02:00:00:00:00:00；10.0.2.x NAT；缺少 telephony/sensors。

Quick spoof of Build fields:
```js
Java.perform(function(){
var Build = Java.use('android.os.Build');
Build.MODEL.value = 'Pixel 7 Pro';
Build.MANUFACTURER.value = 'Google';
Build.BRAND.value = 'google';
Build.FINGERPRINT.value = 'google/panther/panther:14/UP1A.231105.003/1234567:user/release-keys';
});
```
补充用于文件存在性检查和标识符的存根（stubs），例如 TelephonyManager.getDeviceId/SubscriberId、WifiInfo.getMacAddress、SensorManager.getSensorList，以返回真实的值。

## SSL pinning bypass 快速 hook (Java)

使自定义 TrustManagers 失效并强制使用宽松的 SSL contexts：
```js
Java.perform(function(){
var X509TrustManager = Java.use('javax.net.ssl.X509TrustManager');
var SSLContext = Java.use('javax.net.ssl.SSLContext');

// No-op validations
X509TrustManager.checkClientTrusted.implementation = function(){ };
X509TrustManager.checkServerTrusted.implementation = function(){ };

// Force permissive TrustManagers
var TrustManagers = [ X509TrustManager.$new() ];
var SSLContextInit = SSLContext.init.overload('[Ljavax.net.ssl.KeyManager;','[Ljavax.net.ssl.TrustManager;','java.security.SecureRandom');
SSLContextInit.implementation = function(km, tm, sr){
return SSLContextInit.call(this, km, TrustManagers, sr);
};
});
```
注意事项
- 为 OkHttp 扩展：hook okhttp3.CertificatePinner 和 HostnameVerifier（按需），或使用来自 CodeShare 的通用 unpinning 脚本。
- 运行示例：`frida -U -f com.target.app -l ssl-bypass.js --no-pause`

### OkHttp4 / gRPC / Cronet pinning (2024+)

现代栈在较新的 API 中执行 pin（OkHttp4+、gRPC over Cronet/BoringSSL）。当基本的 SSLContext hook 无效或导致应用挂起时，添加这些 hooks：
```js
Java.perform(() => {
try {
const Pinner = Java.use('okhttp3.CertificatePinner');
Pinner.check.overload('java.lang.String', 'java.util.List').implementation = function(){};
Pinner.check$okhttp.implementation = function(){};
} catch (e) {}

try {
const CronetB = Java.use('org.chromium.net.CronetEngine$Builder');
CronetB.enablePublicKeyPinningBypassForLocalTrustAnchors.overload('boolean').implementation = function(){ return this; };
CronetB.setPublicKeyPins.overload('java.lang.String', 'java.util.Set', 'boolean').implementation = function(){ return this; };
} catch (e) {}
});
```
如果 TLS 仍然失败，退到原生层并修补 Cronet/gRPC 使用的 BoringSSL 验证入口点：
```js
const customVerify = Module.findExportByName(null, 'SSL_CTX_set_custom_verify');
if (customVerify) {
Interceptor.attach(customVerify, {
onEnter(args){
// arg0 = SSL_CTX*, arg1 = mode, arg2 = callback
args[1] = ptr(0); // SSL_VERIFY_NONE
args[2] = NULL;  // disable callback
}
});
}
```
## 第 6 步 — 在 Java hooks 失效时沿着 JNI/native 路径追踪

追踪 JNI entry points 以定位 native loaders 和 detection init:
```bash
frida-trace -n com.example.app -i "JNI_OnLoad"
```
对打包的 .so 文件进行快速本机初步评估：
```bash
# List exported symbols & JNI
nm -D libfoo.so | head
objdump -T libfoo.so | grep Java_
strings -n 6 libfoo.so | egrep -i 'frida|ptrace|gum|magisk|su|root'
```
交互式/本地 reversing:
- Ghidra: https://ghidra-sre.org/
- r2frida: https://github.com/nowsecure/r2frida

示例: neuter ptrace to defeat simple anti‑debug in libc:
```js
const ptrace = Module.findExportByName(null, 'ptrace');
if (ptrace) {
Interceptor.replace(ptrace, new NativeCallback(function () {
return -1; // pretend failure
}, 'int', ['int', 'int', 'pointer', 'pointer']));
}
```
另见：
{{#ref}}
reversing-native-libraries.md
{{#endref}}

## 第7步 — Objection patching (embed gadget / strip basics)

当你更喜欢 repacking 而不是 runtime hooks 时，尝试：
```bash
objection patchapk --source app.apk
```
注意：
- Requires apktool; ensure a current version from the official guide to avoid build issues: https://apktool.org/docs/install
- Gadget injection enables instrumentation without root but can still be caught by stronger init‑time checks.

Optionally, add LSPosed modules and Shamiko for stronger root hiding in Zygisk environments, and curate DenyList to cover child processes.

For a complete workflow including script-mode Gadget configuration and bundling your Frida 17+ agent into the APK, see:

[Frida Tutorial — Self-contained agent + Gadget embedding](frida-tutorial/README.md)

参考：
- Objection: https://github.com/sensepost/objection

## 第 8 步 — 后备方案：Patch TLS pinning for network visibility

如果 instrumentation 被阻止，你仍然可以通过静态移除 pinning 来检查流量：
```bash
apk-mitm app.apk
# Then install the patched APK and proxy via Burp/mitmproxy
```
- 工具: https://github.com/shroudedcode/apk-mitm
- 有关网络配置 CA‑trust 技巧（以及 Android 7+ 的 user CA trust），见：

{{#ref}}
make-apk-accept-ca-certificate.md
{{#endref}}

{{#ref}}
install-burp-certificate.md
{{#endref}}

## 常用命令速查表
```bash
# List processes and attach
frida-ps -Uai
frida -U -n com.example.app

# Spawn with a script (may trigger detectors)
frida -U -f com.example.app -l anti-frida-detection.js

# Trace native init
frida-trace -n com.example.app -i "JNI_OnLoad"

# Objection runtime
objection --gadget com.example.app explore

# Static TLS pinning removal
apk-mitm app.apk
```
## Universal proxy forcing + TLS unpinning (HTTP Toolkit Frida hooks)

现代应用程序经常忽略系统代理并在多个层面实施 pinning（Java + native），即使安装了 user/system CAs 也会使流量捕获变得很困难。一个实用的方法是结合通用的 TLS unpinning 和通过现成的 Frida hooks 强制代理，然后将所有流量通过 mitmproxy/Burp 转发。

工作流程
- 在你的主机上运行 mitmproxy（或 Burp）。确保设备能访问主机的 IP/端口。
- 加载 HTTP Toolkit 的集成 Frida hooks，以在常见堆栈（OkHttp/OkHttp3, HttpsURLConnection, Conscrypt, WebView, etc.）中同时执行 TLS unpinning 并强制使用代理。这样可以绕过 CertificatePinner/TrustManager 检查并覆盖 proxy selectors，因此即使应用显式禁用代理，流量也会始终通过你的代理发送。
- 使用 Frida 和 hook script 启动目标应用，并在 mitmproxy 中捕获请求。

示例
```bash
# Device connected via ADB or over network (-U)
# See the repo for the exact script names & options
frida -U -f com.vendor.app \
-l ./android-unpinning-with-proxy.js \
--no-pause

# mitmproxy listening locally
mitmproxy -p 8080
```
注意
- 尽可能与系统范围的代理结合使用：`adb shell settings put global http_proxy <host>:<port>`。Frida hooks 会强制使用代理，即使应用绕过全局设置。
- 当需要对移动设备到 IoT 的 onboarding 流量进行 MITM（常见有 pinning 或绕过代理）时，此技术非常合适。
- Hooks: https://github.com/httptoolkit/frida-interception-and-unpinning

## References

- [Reversing Android Apps: Bypassing Detection Like a Pro](https://www.kayssel.com/newsletter/issue-12/)
- [Frida Codeshare](https://codeshare.frida.re/)
- [Objection](https://github.com/sensepost/objection)
- [apk-mitm](https://github.com/shroudedcode/apk-mitm)
- [Jadx](https://github.com/skylot/jadx)
- [Ghidra](https://ghidra-sre.org/)
- [r2frida](https://github.com/nowsecure/r2frida)
- [Apktool install guide](https://apktool.org/docs/install)
- [Magisk](https://github.com/topjohnwu/Magisk)
- [Medusa (Android Frida framework)](https://github.com/Ch0pin/medusa)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [Frida OkHttp4 SSL pinning bypass script](https://github.com/Zero3141/Frida-OkHttp-Bypass)
- [XDA guide to strong Play Integrity bypass (2025)](https://xdaforums.com/t/updated-11-17-2025-guide-get-strong-integrity-fix-banking-apps-revolut-google-wallet-android-16-working.4753805/)

{{#include ../../banners/hacktricks-training.md}}
