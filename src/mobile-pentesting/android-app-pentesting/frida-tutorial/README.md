# Tutoriel Frida

{{#include ../../../banners/hacktricks-training.md}}


## Installation

Installer **frida tools**:
```bash
pip install frida-tools
pip install frida
```
**Télécharger et installer** sur l'appareil Android le **frida server** ([Download the latest release](https://github.com/frida/frida/releases)).\
Commande en une ligne pour redémarrer adb en mode root, se connecter à l'appareil, téléverser frida-server, lui donner les permissions d'exécution et l'exécuter en arrière-plan:
```bash
adb root; adb connect localhost:6000; sleep 1; adb push frida-server /data/local/tmp/; adb shell "chmod 755 /data/local/tmp/frida-server"; adb shell "/data/local/tmp/frida-server &"
```
**Vérifiez** si cela **fonctionne**:
```bash
frida-ps -U #List packages and processes
frida-ps -U | grep -i <part_of_the_package_name> #Get all the package name
```
## frida-ui (contrôleur Frida basé sur le navigateur)

**frida-ui** fournit une interface web sur `http://127.0.0.1:8000` pour lister les périphériques/applications et attacher ou lancer des cibles avec des scripts (aucun CLI nécessaire).

- Installation (fixer `frida` sur la version du device server) :
```bash
uv tool install frida-ui --with frida==16.7.19
# pipx install frida-ui
# pip install frida-ui
```
- Exécuter:
```bash
frida-ui
frida-ui --host 127.0.0.1 --port 8000 --reload
```
- Fonctionnalités: découvre les appareils USB/locaux, permet d'ajouter des serveurs distants (`192.168.1.x:27042`), et prend en charge **Attach**, **Spawn**, et **Spawn & Run** (pour hooker avant la logique `onCreate()` précoce).
- Scripting: éditeur, glisser-déposer de `.js`, importer CodeShare, télécharger des scripts et les logs de session.
- Serveurs distants: `./frida-server -l 0.0.0.0:27042 -D` l'expose sur le réseau afin que frida-ui puisse se connecter sans ADB.

## Frida server vs. Gadget (root vs. no-root)

Deux façons courantes d'instrumenter des applications Android avec Frida :

- Frida server (rooted devices): pousser et exécuter un démon natif qui vous permet de vous attach à n'importe quel processus.
- Frida Gadget (no root): intégrer Frida comme bibliothèque partagée dans l'APK et la charger automatiquement dans le processus cible.

Frida server (rooted)
```bash
# Download the matching frida-server binary for your device's arch
# https://github.com/frida/frida/releases
adb root
adb push frida-server-<ver>-android-<arch> /data/local/tmp/frida-server
adb shell chmod 755 /data/local/tmp/frida-server
adb shell /data/local/tmp/frida-server &    # run at boot via init/magisk if desired

# From host, list processes and attach
frida-ps -Uai
frida -U -n com.example.app
```
Frida Gadget (no-root)

1) Décompressez l'APK, ajoutez le gadget .so et la config :
- Placez libfrida-gadget.so dans `lib/<abi>/` (e.g., lib/arm64-v8a/)
- Créez assets/frida-gadget.config avec vos paramètres de chargement de script

Exemple frida-gadget.config
```json
{
"interaction": { "type": "script", "path": "/sdcard/ssl-bypass.js" },
"runtime": { "logFile": "/sdcard/frida-gadget.log" }
}
```
2) Référencer/charger le gadget afin qu'il soit initialisé tôt :
- Le plus simple : Ajoutez un petit stub Java avec System.loadLibrary("frida-gadget") dans Application.onCreate(), ou utilisez le chargement natif de la lib déjà présent.

3) Réemballez et signez l'APK, puis installez :
```bash
apktool d app.apk -o app_m
# ... add gadget .so and config ...
apktool b app_m -o app_gadget.apk
uber-apk-signer -a app_gadget.apk -o out_signed
adb install -r out_signed/app_gadget-aligned-debugSigned.apk
```
4) Attacher depuis l'hôte au processus gadget:
```bash
frida-ps -Uai
frida -U -n com.example.app
```
Remarques
- Certaines protections détectent Gadget ; gardez les noms/chemins discrets et chargez-le tardivement/conditionnellement si nécessaire.
- Pour les apps renforcées, privilégiez des tests sur appareil rooted avec server + late attach, ou combinez avec le masquage Magisk/Zygisk.

## Injection Frida basée sur JDWP sans root/repackaging (frida-jdwp-loader)

Si l'APK est debuggable (android:debuggable="true"), vous pouvez vous attacher via JDWP et injecter une bibliothèque native à un breakpoint Java. Pas de root et pas de repackage de l'APK.

- Repo: https://github.com/frankheat/frida-jdwp-loader
- Requirements: ADB, Python 3, USB/Wireless debugging. L'app doit être debuggable (emulator with `ro.debuggable=1`, rooted device with `resetprop`, or rebuild manifest).

Démarrage rapide:
```bash
git clone https://github.com/frankheat/frida-jdwp-loader.git
cd frida-jdwp-loader
# Inject frida-gadget.so into a debuggable target
python frida-jdwp-loader.py frida -n com.example.myapplication
# Keep the breakpoint thread suspended for early hooks
python frida-jdwp-loader.py frida -n com.example.myapplication -s
# Networkless: run a local agent script via Gadget "script" mode
python frida-jdwp-loader.py frida -n com.example.myapplication -i script -l script.js
```
Remarques
- Modes : spawn (pause à Application.onCreate) ou attach (pause à Activity.onStart). Utilisez `-b` pour définir une méthode Java spécifique, `-g` pour sélectionner la version/chemin de Gadget, `-p` pour choisir le port JDWP.
- Mode écoute : forwardez Gadget (par défaut 127.0.0.1:27042) si nécessaire : `adb forward tcp:27042 tcp:27042`; puis `frida-ps -H 127.0.0.1:27042`.
- Cela exploite le débogage JDWP. Le risque est de livrer des builds débogables ou d'exposer JDWP.

## Agent autonome + intégration de Gadget (Frida 17+; automatisé avec Objection)

Frida 17 a supprimé les bridges Java/ObjC intégrés de GumJS. Si votre agent hooks Java, vous devez inclure le Java bridge dans votre bundle.

1) Créez un agent Frida (TypeScript) et incluez le Java bridge
```bash
# Scaffolding
frida-create -t agent -o mod
cd mod && npm install
# Install the Java bridge for Frida 17+
npm install frida-java-bridge
# Dev loop (optional live-reload via REPL)
npm run watch
```
Minimal Java hook (force les lancers de dés à 1):
```ts
import Java from "frida-java-bridge";

Java.perform(function () {
var dicer = Java.use("org.secuso.privacyfriendlydicer.dicer.Dicer");
dicer.rollDice.implementation = function (numDice: number, numFaces: number) {
return Array(numDice).fill(1);
};
});
```
Créer un bundle unique pour l'intégration :
```bash
npm run build    # produces _agent.js via frida-compile
```
Test USB rapide (optionnel) :
```bash
frida -U -f org.secuso.privacyfriendlydicer -l _agent.js
```
2) Configurer Gadget pour charger automatiquement votre script
Le patcher d'Objection attend une Gadget config ; lorsque vous utilisez script mode, spécifiez le chemin sur le disque à l'intérieur de l'APK lib dir :
```json
{
"interaction": {
"type": "script",
"path": "libfrida-gadget.script.so"
}
}
```
3) Automatiser le patching d'APK avec Objection
```bash
# Embed Gadget, config, and your compiled agent into the APK; rebuild and sign
objection patchapk -s org.secuso.privacyfriendlydicer.apk \
-c gadget-config.json \
-l mod/_agent.js \
--use-aapt2
```
Ce que fait patchapk (vue d'ensemble) :
- Détecte l'ABI de l'appareil (par ex., arm64-v8a) et récupère le Gadget correspondant
- Ajoute éventuellement android.permission.INTERNET si nécessaire
- Injecte un initialiseur de classe statique appelant System.loadLibrary("frida-gadget") dans l'activité de lancement
- Place les fichiers suivants sous `lib/<abi>/` :
- libfrida-gadget.so
- libfrida-gadget.config.so (config sérialisée)
- libfrida-gadget.script.so (votre _agent.js)

Exemple de smali injecté (initialiseur statique) :
```smali
.method static constructor <clinit>()V
.locals 1
const-string v0, "frida-gadget"
invoke-static {v0}, Ljava/lang/System;->loadLibrary(Ljava/lang/String;)V
return-void
.end method
```
4) Vérifier le repack
```bash
apktool d org.secuso.privacyfriendlydicer.apk
apktool d org.secuso.privacyfriendlydicer.objection.apk
# Inspect differences
diff -r org.secuso.privacyfriendlydicer org.secuso.privacyfriendlydicer.objection
```
Modifications attendues :
- AndroidManifest.xml peut inclure `<uses-permission android:name="android.permission.INTERNET"/>`
- Nouvelles libs natives sous `lib/<abi>/` comme ci-dessus
- Le smali de l'activité lançable contient un `<clinit>` static qui appelle System.loadLibrary("frida-gadget")

5) Split APKs
- Patchez l'APK de base (celui qui déclare l'activité MAIN/LAUNCHER)
- Re-signez les splits restants avec la même clé :
```bash
objection signapk split1.apk split2.apk ...
```
- Installer les splits ensemble :
```bash
adb install-multiple split1.apk split2.apk ...
```
- Pour la distribution, vous pouvez fusionner les splits en un seul APK avec APKEditor, puis aligner/signer

## Suppression de FLAG_SECURE pendant l'analyse dynamique

Les apps qui appellent `getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE)` empêchent les captures d'écran, les affichages distants et même les snapshots des tâches récentes d'Android. Quand Freedom Chat appliquait ce flag, la seule façon de documenter les leaks était de manipuler la fenêtre à l'exécution. Un schéma fiable est :

- Hook every surcharge de `Window` qui peut réappliquer le flag (`setFlags`, `addFlags`, `setAttributes`) et masquer le bit `0x00002000` (`WindowManager.LayoutParams.FLAG_SECURE`).
- Après chaque reprise d'une activity, planifiez un appel sur le thread UI à `clearFlags(FLAG_SECURE)` afin que les Dialogs/Fragments créés ensuite héritent de l'état déverrouillé.
- Les apps construites avec React Native / Flutter créent souvent des fenêtres imbriquées ; hook `android.app.Dialog`/`android.view.View` helpers ou parcourez `getWindow().peekDecorView()` si vous voyez encore des cadres noirs.

<details>
<summary>Frida hook clearing Window.FLAG_SECURE</summary>
```javascript
Java.perform(function () {
var LayoutParams = Java.use("android.view.WindowManager$LayoutParams");
var FLAG_SECURE = LayoutParams.FLAG_SECURE.value;
var Window = Java.use("android.view.Window");
var Activity = Java.use("android.app.Activity");

function strip(value) {
var masked = value & (~FLAG_SECURE);
if (masked !== value) {
console.log("[-] Stripped FLAG_SECURE from 0x" + value.toString(16));
}
return masked;
}

Window.setFlags.overload('int', 'int').implementation = function (flags, mask) {
return this.setFlags.call(this, strip(flags), strip(mask));
};

Window.addFlags.implementation = function (flags) {
return this.addFlags.call(this, strip(flags));
};

Window.setAttributes.implementation = function (attrs) {
attrs.flags.value = strip(attrs.flags.value);
return this.setAttributes.call(this, attrs);
};

Activity.onResume.implementation = function () {
this.onResume();
var self = this;
Java.scheduleOnMainThread(function () {
try {
self.getWindow().clearFlags(FLAG_SECURE);
console.log("[+] Cleared FLAG_SECURE on " + self.getClass().getName());
} catch (err) {
console.log("[!] clearFlags failed: " + err);
}
});
};
});
```
</details>

Exécutez le script avec `frida -U -f <package> -l disable-flag-secure.js --no-pause`, interagissez avec l'UI, et les captures d'écran/enregistrements fonctionneront à nouveau. Comme tout se passe sur le thread UI il n'y a pas de scintillement, et vous pouvez toujours combiner le hook avec HTTP Toolkit/Burp pour capturer le trafic qui a révélé le `/channel` PIN leak.

## Dynamic DEX dumping / unpacking with clsdumper (Frida)

`clsdumper` est un dynamic **DEX/class dumper** basé sur Frida qui survit aux applications durcies en combinant une pré-étape anti-Frida avec des stratégies de découverte natives et Java (fonctionne même si `Java.perform()` plante). Exigences : Python 3.10+, appareil rooté avec `frida-server` en cours d'exécution, connexion USB ou TCP `--host`.

**Installation & utilisation rapide**
```bash
pip install clsdumper
# Attach to a running app
clsdumper com.example.app
# Spawn first (hooks before early loaders)
clsdumper com.example.app --spawn
# Select strategies
clsdumper com.example.app --strategies fart_dump,oat_extract
```
**Options CLI (les plus utiles)**
- `target`: nom du package ou PID.
- `--spawn`: lancer au lieu d'attacher.
- `--host <ip>`: se connecter à un frida-server distant.
- `--strategies <comma>`: limiter/sélectionner les extracteurs ; par défaut tous sauf `mmap_hook` (coûteux).
- `--no-scan` / `--deep-scan`: désactiver ou ralentir l'analyse mémoire approfondie (ajoute le scan CDEX).
- `--extract-classes`: post-traiter les dumps en `.smali` via androguard.
- `--no-anti-frida`: passer l'étape de contournement pré-hook.
- `--list` / `--list-apps`: énumérer les processus en cours ou les packages installés.

**Bypass anti-instrumentation (phase 0)**
- Intercepte `sigaction`/`signal` pour bloquer l'enregistrement des gestionnaires de crash/anti-debug.
- Fournit un `/proc/self/maps` filtré via `memfd_create` pour cacher les régions Frida.
- Surveille `pthread_create` pour détecter/neutraliser les threads watchdog qui traquent Frida.

**Découverte DEX (phases 1–2)** — plusieurs stratégies complémentaires avec métadonnées par hit + déduplication (agent-side djb2, host-side SHA-256):
- Native (pas besoin du bridge Java) : `art_walk` (parcourt ART Runtime→ClassLinker→DexFile), `open_common_hook` (hook `DexFile::OpenCommon`), `memory_scan` (magic DEX dans les maps lisibles), `oat_extract` (parse les .vdex/.oat mappés), `fart_dump` (hook `DefineClass` + parcourt `class_table_`), `dexfile_constructor` (hook les constructeurs `OatDexFile`), `mmap_hook` (surveille `mmap/mmap64`, désactivé par défaut pour les perfs).
- Java (lorsqu'il est disponible) : `cookie` (lit `mCookie` depuis les ClassLoaders), `classloader_hook` (surveille `loadClass`, `DexClassLoader`, `InMemoryDexClassLoader`).

**Disposition de la sortie**
```
dump_<target>/
dex/classes_001.dex ...
classes/                 # only when --extract-classes
metadata.json            # strategy per hit + hashes
```
Astuce : les applications protégées chargent souvent du code depuis plusieurs sources (in-memory payload, vdex/oat, custom loaders). Lancer avec le jeu multi-stratégies par défaut plus `--spawn` maximise la couverture ; activez `--deep-scan` seulement lorsque nécessaire pour éviter les impacts sur les performances.

## Tutoriels

### [Tutoriel 1](frida-tutorial-1.md)

**Source**: [https://medium.com/infosec-adventures/introduction-to-frida-5a3f51595ca1](https://medium.com/infosec-adventures/introduction-to-frida-5a3f51595ca1)\
**APK**: [https://github.com/t0thkr1s/frida-demo/releases](https://github.com/t0thkr1s/frida-demo/releases)\
**Code source**: [https://github.com/t0thkr1s/frida-demo](https://github.com/t0thkr1s/frida-demo)

**Suivez le [lien pour le lire](frida-tutorial-1.md).**

### [Tutoriel 2](frida-tutorial-2.md)

**D'après**: [https://11x256.github.io/Frida-hooking-android-part-2/](https://11x256.github.io/Frida-hooking-android-part-2/) (Parties 2, 3 & 4)\
**APKs et code source**: [https://github.com/11x256/frida-android-examples](https://github.com/11x256/frida-android-examples)

**Suivez le [lien pour le lire.](frida-tutorial-2.md)**

### [Tutoriel 3](owaspuncrackable-1.md)

**D'après**: [https://joshspicer.com/android-frida-1](https://joshspicer.com/android-frida-1)\
**APK**: [https://github.com/OWASP/owasp-mstg/blob/master/Crackmes/Android/Level_01/UnCrackable-Level1.apk](https://github.com/OWASP/owasp-mstg/blob/master/Crackmes/Android/Level_01/UnCrackable-Level1.apk)

**Suivez le [lien pour le lire](owaspuncrackable-1.md).**

**Vous pouvez trouver plus de scripts Frida ici :** [**https://codeshare.frida.re/**](https://codeshare.frida.re)

## Exemples rapides

### Appeler Frida depuis la ligne de commande
```bash
frida-ps -U

#Basic frida hooking
frida -l disableRoot.js -f owasp.mstg.uncrackable1

#Hooking before starting the app
frida -U --no-pause -l disableRoot.js -f owasp.mstg.uncrackable1
#The --no-pause and -f options allow the app to be spawned automatically,
#frozen so that the instrumentation can occur, and the automatically
#continue execution with our modified code.
```
### Script Python basique
```python
import frida, sys

jscode = open(sys.argv[0]).read()
process = frida.get_usb_device().attach('infosecadventures.fridademo')
script = process.create_script(jscode)
print('[ * ] Running Frida Demo application')
script.load()
sys.stdin.read()
```
### Hooking des fonctions sans paramètres

Hook la fonction `a()` de la classe `sg.vantagepoint.a.c`
```javascript
Java.perform(function () {
rootcheck1.a.overload().implementation = function () {
return false;
};
});
```
Hook java `exit()`
```javascript
var sysexit = Java.use("java.lang.System")
sysexit.exit.overload("int").implementation = function (var_0) {
send("java.lang.System.exit(I)V  // We avoid exiting the application  :)")
}
```
Hook MainActivity `.onStart()` et `.onCreate()`
```javascript
var mainactivity = Java.use("sg.vantagepoint.uncrackable1.MainActivity")
mainactivity.onStart.overload().implementation = function () {
send("MainActivity.onStart() HIT!!!")
var ret = this.onStart.overload().call(this)
}
mainactivity.onCreate.overload("android.os.Bundle").implementation = function (
var_0
) {
send("MainActivity.onCreate() HIT!!!")
var ret = this.onCreate.overload("android.os.Bundle").call(this, var_0)
}
```
Hook android `.onCreate()`
```javascript
var activity = Java.use("android.app.Activity")
activity.onCreate.overload("android.os.Bundle").implementation = function (
var_0
) {
send("Activity HIT!!!")
var ret = this.onCreate.overload("android.os.Bundle").call(this, var_0)
}
```
### Hooking de fonctions avec paramètres et récupération de la valeur

Hooking d'une fonction de déchiffrement. Affichez l'entrée, appelez la fonction originale pour décrypter l'entrée et enfin, affichez les données en clair :

<details>
<summary>Hooking d'une fonction de déchiffrement (Java) — afficher entrées/sorties</summary>
```javascript
function getString(data) {
var ret = ""
for (var i = 0; i < data.length; i++) {
ret += data[i].toString()
}
return ret
}
var aes_decrypt = Java.use("sg.vantagepoint.a.a")
aes_decrypt.a.overload("[B", "[B").implementation = function (var_0, var_1) {
send("sg.vantagepoint.a.a.a([B[B)[B   doFinal(enc)  // AES/ECB/PKCS7Padding")
send("Key       : " + getString(var_0))
send("Encrypted : " + getString(var_1))
var ret = this.a.overload("[B", "[B").call(this, var_0, var_1)
send("Decrypted : " + ret)

var flag = ""
for (var i = 0; i < ret.length; i++) {
flag += String.fromCharCode(ret[i])
}
send("Decrypted flag: " + flag)
return ret //[B
}
```
</details>

### Hooking des fonctions et les appeler avec notre input

Hook une fonction qui reçoit une string et l'appeler avec une autre string (from [here](https://11x256.github.io/Frida-hooking-android-part-2/))
```javascript
var string_class = Java.use("java.lang.String") // get a JS wrapper for java's String class

my_class.fun.overload("java.lang.String").implementation = function (x) {
//hooking the new function
var my_string = string_class.$new("My TeSt String#####") //creating a new String by using `new` operator
console.log("Original arg: " + x)
var ret = this.fun(my_string) // calling the original function with the new String, and putting its return value in ret variable
console.log("Return value: " + ret)
return ret
}
```
### Obtenir un objet déjà créé d'une classe

Si vous voulez extraire un attribut d'un objet déjà créé, vous pouvez utiliser ceci.

Dans cet exemple, vous allez voir comment obtenir l'objet de la classe my_activity et comment appeler la fonction .secret() qui affichera un attribut privé de l'objet:
```javascript
Java.choose("com.example.a11x256.frida_test.my_activity", {
onMatch: function (instance) {
//This function will be called for every instance found by frida
console.log("Found instance: " + instance)
console.log("Result of secret func: " + instance.secret())
},
onComplete: function () {},
})
```
## Autres tutoriels Frida

- [https://github.com/DERE-ad2001/Frida-Labs](https://github.com/DERE-ad2001/Frida-Labs)
- [Part 1 of Advanced Frida Usage blog series: IOS Encryption Libraries](https://8ksec.io/advanced-frida-usage-part-1-ios-encryption-libraries-8ksec-blogs/)


## Références

- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [Frida Gadget documentation](https://frida.re/docs/gadget/)
- [Frida releases (server binaries)](https://github.com/frida/frida/releases)
- [Objection (SensePost)](https://github.com/sensepost/objection)
- [Modding And Distributing Mobile Apps with Frida](https://pit.bearblog.dev/modding-and-distributing-mobile-apps-with-frida/)
- [frida-jdwp-loader](https://github.com/frankheat/frida-jdwp-loader)
- [Library injection for debuggable Android apps (blog)](https://koz.io/library-injection-for-debuggable-android-apps/)
- [jdwp-lib-injector (original idea/tool)](https://github.com/ikoz/jdwp-lib-injector)
- [jdwp-shellifier](https://github.com/hugsy/jdwp-shellifier)
- ["Super secure" MAGA-themed messaging app leaks everyone’s phone number](https://ericdaigle.ca/posts/super-secure-maga-messaging-app-leaks-everyones-phone-number/)
- [Android Frida Hooking: Disabling FLAG_SECURE](https://www.securify.nl/en/blog/android-frida-hooking-disabling-flagsecure/)
- [frida-ui](https://github.com/adityatelange/frida-ui)
- [clsdumper — Android Dynamic Class Dumper](https://github.com/TheQmaks/clsdumper)

{{#include ../../../banners/hacktricks-training.md}}
