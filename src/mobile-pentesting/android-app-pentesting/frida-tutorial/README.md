# Frida Anleitung

{{#include ../../../banners/hacktricks-training.md}}


## Installation

Installiere **frida tools**:
```bash
pip install frida-tools
pip install frida
```
**Herunterladen und installieren** auf dem Android-Gerät den **frida server** ([Download the latest release](https://github.com/frida/frida/releases)).\
Ein Einzeiler, um adb im Root-Modus neu zu starten, sich damit zu verbinden, frida-server hochzuladen, Ausführungsrechte zu vergeben und ihn im Hintergrund auszuführen:
```bash
adb root; adb connect localhost:6000; sleep 1; adb push frida-server /data/local/tmp/; adb shell "chmod 755 /data/local/tmp/frida-server"; adb shell "/data/local/tmp/frida-server &"
```
**Überprüfe**, ob es **funktioniert**:
```bash
frida-ps -U #List packages and processes
frida-ps -U | grep -i <part_of_the_package_name> #Get all the package name
```
## frida-ui (browserbasierter Frida-Controller)

**frida-ui** stellt eine Web-UI unter `http://127.0.0.1:8000` bereit, um Geräte/Apps aufzulisten und Targets mit scripts zu attachen oder zu spawnen (kein CLI erforderlich).

- Installieren (pin `frida` auf die Device-Server-Version):
```bash
uv tool install frida-ui --with frida==16.7.19
# pipx install frida-ui
# pip install frida-ui
```
- Ausführen:
```bash
frida-ui
frida-ui --host 127.0.0.1 --port 8000 --reload
```
- Funktionen: erkennt USB-/lokale Geräte, ermöglicht das Hinzufügen von Remote-Servern (`192.168.1.x:27042`) und unterstützt **Attach**, **Spawn** und **Spawn & Run** (um vor der frühen `onCreate()`-Logik eingreifen zu können).
- Scripting: Editor, Drag & Drop von `.js`-Dateien, CodeShare importieren, Skripte und Session-Logs herunterladen.
- Remote-Server: `./frida-server -l 0.0.0.0:27042 -D` macht ihn im Netzwerk erreichbar, sodass frida-ui sich ohne ADB verbinden kann.

## Frida server vs. Gadget (root vs. no-root)

Zwei gängige Methoden, um Android-Apps mit Frida zu instrumentieren:

- Frida server (rooted devices): Einen nativen Daemon auf das Gerät pushen und ausführen, der es ermöglicht, sich an jeden Prozess anzuhängen.
- Frida Gadget (no root): Frida als shared library in das APK einbinden und automatisch im Zielprozess laden.

Frida server (rooted)
```bash
# Download the matching frida-server binary for your device's arch
# https://github.com/frida/frida/releases
adb root
adb push frida-server-<ver>-android-<arch> /data/local/tmp/frida-server
adb shell chmod 755 /data/local/tmp/frida-server
adb shell /data/local/tmp/frida-server &    # run at boot via init/magisk if desired

# From host, list processes and attach
frida-ps -Uai
frida -U -n com.example.app
```
Frida Gadget (no-root)

1) Entpacke die APK, füge das gadget .so und die Konfiguration hinzu:
- Platziere libfrida-gadget.so in `lib/<abi>/` (z. B. lib/arm64-v8a/)
- Erstelle assets/frida-gadget.config mit deinen Einstellungen zum Laden von Skripten

Beispiel frida-gadget.config
```json
{
"interaction": { "type": "script", "path": "/sdcard/ssl-bypass.js" },
"runtime": { "logFile": "/sdcard/frida-gadget.log" }
}
```
2) Referenzieren/laden Sie das gadget, damit es früh initialisiert wird:
- Am einfachsten: Fügen Sie einen kleinen Java-Stub hinzu, der System.loadLibrary("frida-gadget") in Application.onCreate() aufruft, oder verwenden Sie das bereits vorhandene native Laden von Bibliotheken.

3) Packen Sie die APK neu, signieren Sie sie und installieren Sie sie:
```bash
apktool d app.apk -o app_m
# ... add gadget .so and config ...
apktool b app_m -o app_gadget.apk
uber-apk-signer -a app_gadget.apk -o out_signed
adb install -r out_signed/app_gadget-aligned-debugSigned.apk
```
4) Vom Host an den Gadget-Prozess anhängen:
```bash
frida-ps -Uai
frida -U -n com.example.app
```
Notizen
- Gadget wird von einigen Protections erkannt; halte Namen/Pfade stealthy und lade spät/bedingt, falls nötig.
- Bei gehärteten Apps bevorzuge rooted testing mit server + late attach, oder kombiniere es mit Magisk/Zygisk hiding.

## JDWP-based Frida injection without root/repackaging (frida-jdwp-loader)

Wenn die APK debuggable ist (android:debuggable="true"), kannst du über JDWP attachen und eine native Library an einem Java-Breakpoint injecten. Kein root und kein APK repackaging nötig.

- Repo: https://github.com/frankheat/frida-jdwp-loader
- Anforderungen: ADB, Python 3, USB/Wireless debugging. App muss debuggable sein (emulator mit `ro.debuggable=1`, gerootetes Gerät mit `resetprop`, oder Manifest neu bauen).

Schnellstart:
```bash
git clone https://github.com/frankheat/frida-jdwp-loader.git
cd frida-jdwp-loader
# Inject frida-gadget.so into a debuggable target
python frida-jdwp-loader.py frida -n com.example.myapplication
# Keep the breakpoint thread suspended for early hooks
python frida-jdwp-loader.py frida -n com.example.myapplication -s
# Networkless: run a local agent script via Gadget "script" mode
python frida-jdwp-loader.py frida -n com.example.myapplication -i script -l script.js
```
Notes
- Modi: spawn (break at Application.onCreate) oder attach (break at Activity.onStart). Verwende `-b`, um eine bestimmte Java-Methode festzulegen, `-g`, um Gadget-Version/Pfad auszuwählen, `-p`, um den JDWP-Port zu wählen.
- Listen-Modus: Gadget weiterleiten (Standard 127.0.0.1:27042), falls nötig: `adb forward tcp:27042 tcp:27042`; dann `frida-ps -H 127.0.0.1:27042`.
- Dies nutzt JDWP-Debugging. Das Risiko besteht darin, debuggable Builds auszuliefern oder JDWP offenzulegen.

## Eigenständiger Agent + Gadget-Einbettung (Frida 17+; automatisiert mit Objection)

Frida 17 hat die eingebauten Java/ObjC-Bridges aus GumJS entfernt. Wenn dein Agent Java hookt, musst du die Java-Bridge in dein Bundle einbinden.

1) Erstelle einen Frida-Agenten (TypeScript) und binde die Java-Bridge ein
```bash
# Scaffolding
frida-create -t agent -o mod
cd mod && npm install
# Install the Java bridge for Frida 17+
npm install frida-java-bridge
# Dev loop (optional live-reload via REPL)
npm run watch
```
Minimaler Java-Hook (erzwingt Würfelwürfe auf 1):
```ts
import Java from "frida-java-bridge";

Java.perform(function () {
var dicer = Java.use("org.secuso.privacyfriendlydicer.dicer.Dicer");
dicer.rollDice.implementation = function (numDice: number, numFaces: number) {
return Array(numDice).fill(1);
};
});
```
Ein einzelnes Bundle zum Einbetten erstellen:
```bash
npm run build    # produces _agent.js via frida-compile
```
Schneller USB-Test (optional):
```bash
frida -U -f org.secuso.privacyfriendlydicer -l _agent.js
```
2) Konfiguriere Gadget, damit es dein script automatisch lädt
Objection’s patcher erwartet eine Gadget config; wenn du script mode verwendest, gib den on-disk path innerhalb des APK lib dir an:
```json
{
"interaction": {
"type": "script",
"path": "libfrida-gadget.script.so"
}
}
```
3) APK-Patching mit Objection automatisieren
```bash
# Embed Gadget, config, and your compiled agent into the APK; rebuild and sign
objection patchapk -s org.secuso.privacyfriendlydicer.apk \
-c gadget-config.json \
-l mod/_agent.js \
--use-aapt2
```
Was patchapk macht (auf hoher Ebene):
- Ermittelt die ABI des Geräts (z. B. arm64-v8a) und lädt das passende Gadget
- Fügt optional android.permission.INTERNET hinzu, falls benötigt
- Injiziert einen statischen Klasseninitialisierer, der System.loadLibrary("frida-gadget") in die Launch-Activity aufruft
- Platziert Folgendes unter `lib/<abi>/`:
- libfrida-gadget.so
- libfrida-gadget.config.so (serialisierte Konfiguration)
- libfrida-gadget.script.so (dein _agent.js)

Beispiel injizierter smali (statischer Initialisierer):
```smali
.method static constructor <clinit>()V
.locals 1
const-string v0, "frida-gadget"
invoke-static {v0}, Ljava/lang/System;->loadLibrary(Ljava/lang/String;)V
return-void
.end method
```
4) Repack verifizieren
```bash
apktool d org.secuso.privacyfriendlydicer.apk
apktool d org.secuso.privacyfriendlydicer.objection.apk
# Inspect differences
diff -r org.secuso.privacyfriendlydicer org.secuso.privacyfriendlydicer.objection
```
Erwartete Änderungen:
- AndroidManifest.xml kann `<uses-permission android:name="android.permission.INTERNET"/>` enthalten
- Neue native libs unter `lib/<abi>/` wie oben
- Smali der startbaren Activity enthält eine statische `<clinit>`, die System.loadLibrary("frida-gadget") aufruft

5) Split APKs
- Patch die Base-APK (diejenige, die die MAIN/LAUNCHER-Activity deklariert)
- Verbleibende Splits mit demselben Schlüssel neu signieren:
```bash
objection signapk split1.apk split2.apk ...
```
- Installiere Splits zusammen:
```bash
adb install-multiple split1.apk split2.apk ...
```
- Für die Verteilung kannst du Splits mit APKEditor in eine einzige APK zusammenführen und dann align/sign

## Entfernen von FLAG_SECURE während der dynamischen Analyse

Apps, die `getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE)` aufrufen, verhindern Screenshots, Remote-Displays und sogar Androids recent-task snapshots. Als Freedom Chat dieses Flag durchsetzte, war der einzige Weg, die leaks zu dokumentieren, das Fenster zur Laufzeit zu manipulieren. Ein zuverlässiges Muster ist:

- Hook jede `Window`-Überladung, die das Flag erneut setzen kann (`setFlags`, `addFlags`, `setAttributes`) und maskiere das Bit `0x00002000` (`WindowManager.LayoutParams.FLAG_SECURE`).
- Nachdem jede Activity wieder aufgenommen wurde, plane einen Aufruf im UI-Thread zu `clearFlags(FLAG_SECURE)`, damit später erstellte Dialoge/Fragmente den entsperrten Zustand übernehmen.
- Apps, die mit React Native / Flutter gebaut wurden, erstellen oft verschachtelte Fenster; hook die `android.app.Dialog`/`android.view.View`-Hilfsfunktionen oder durchlaufe `getWindow().peekDecorView()`, falls du weiterhin schwarze Frames siehst.

<details>
<summary>Frida-Hook zum Entfernen von Window.FLAG_SECURE</summary>
```javascript
Java.perform(function () {
var LayoutParams = Java.use("android.view.WindowManager$LayoutParams");
var FLAG_SECURE = LayoutParams.FLAG_SECURE.value;
var Window = Java.use("android.view.Window");
var Activity = Java.use("android.app.Activity");

function strip(value) {
var masked = value & (~FLAG_SECURE);
if (masked !== value) {
console.log("[-] Stripped FLAG_SECURE from 0x" + value.toString(16));
}
return masked;
}

Window.setFlags.overload('int', 'int').implementation = function (flags, mask) {
return this.setFlags.call(this, strip(flags), strip(mask));
};

Window.addFlags.implementation = function (flags) {
return this.addFlags.call(this, strip(flags));
};

Window.setAttributes.implementation = function (attrs) {
attrs.flags.value = strip(attrs.flags.value);
return this.setAttributes.call(this, attrs);
};

Activity.onResume.implementation = function () {
this.onResume();
var self = this;
Java.scheduleOnMainThread(function () {
try {
self.getWindow().clearFlags(FLAG_SECURE);
console.log("[+] Cleared FLAG_SECURE on " + self.getClass().getName());
} catch (err) {
console.log("[!] clearFlags failed: " + err);
}
});
};
});
```
</details>

Run the script with `frida -U -f <package> -l disable-flag-secure.js --no-pause`, interact with the UI, and screenshots/recordings will work again. Because everything happens on the UI thread there is no flicker, and you can still combine the hook with HTTP Toolkit/Burp to capture the traffic that revealed the `/channel` PIN leak.

## Dynamisches DEX dumping / unpacking mit clsdumper (Frida)

`clsdumper` ist ein Frida-basiertes dynamisches **DEX/class dumper**, das gehärtete Apps überlebt, indem es eine anti-Frida Pre-Stage mit nativen und Java-Discovery-Strategien kombiniert (funktioniert sogar, wenn `Java.perform()` abstürzt). Voraussetzungen: Python 3.10+, gerootetes Gerät mit laufendem `frida-server`, USB- oder `--host` TCP-Verbindung.

**Installation & schnelle Verwendung**
```bash
pip install clsdumper
# Attach to a running app
clsdumper com.example.app
# Spawn first (hooks before early loaders)
clsdumper com.example.app --spawn
# Select strategies
clsdumper com.example.app --strategies fart_dump,oat_extract
```
**CLI-Optionen (am nützlichsten)**
- `target`: Paketname oder PID.
- `--spawn`: spawn statt attach.
- `--host <ip>`: mit remote frida-server verbinden.
- `--strategies <comma>`: Extraktoren begrenzen/auswählen; Standard ist alle außer `mmap_hook` (leistungsintensiv).
- `--no-scan` / `--deep-scan`: deaktiviert bzw. verlangsamt tiefen Memory-Scan (fügt CDEX-Scanning hinzu).
- `--extract-classes`: Dumps nachbearbeiten in `.smali` mit androguard.
- `--no-anti-frida`: überspringt die Pre-Hook-Bypass-Phase.
- `--list` / `--list-apps`: laufende Prozesse oder installierte Pakete auflisten.

**Anti-instrumentation bypass (Phase 0)**
- Hooks `sigaction`/`signal`, um die Registrierung von Crash-/Anti-Debug-Handlern zu blockieren.
- Stellt ein gefiltertes `/proc/self/maps` via `memfd_create` bereit, um Frida-Regionen zu verbergen.
- Überwacht `pthread_create`, um Watchdog-Threads, die Frida jagen, zu erfassen/neutralisieren.

**DEX discovery (Phasen 1–2)** — mehrere komplementäre Strategien mit pro-Treffer-Metadaten + Deduplizierung (agentseitig djb2, hostseitig SHA-256):
- Native (keine Java-Bridge nötig): `art_walk` (durchläuft ART Runtime→ClassLinker→DexFile), `open_common_hook` (hook `DexFile::OpenCommon`), `memory_scan` (DEX-Magic in lesbaren Maps), `oat_extract` (parsed gemappte .vdex/.oat), `fart_dump` (hook `DefineClass` + durchläuft `class_table_`), `dexfile_constructor` (hook `OatDexFile` constructors), `mmap_hook` (überwacht `mmap/mmap64`, standardmäßig deaktiviert wegen Performance).
- Java (wenn verfügbar): `cookie` (liest `mCookie` aus ClassLoaders), `classloader_hook` (überwacht `loadClass`, `DexClassLoader`, `InMemoryDexClassLoader`).

**Ausgabeaufbau**
```
dump_<target>/
dex/classes_001.dex ...
classes/                 # only when --extract-classes
metadata.json            # strategy per hit + hashes
```
Tipp: Geschützte Apps laden häufig Code aus mehreren Quellen (in-memory payload, vdex/oat, custom loaders). Das Ausführen mit dem Standard multi-strategy-Set plus `--spawn` maximiert die Abdeckung; aktiviere `--deep-scan` nur bei Bedarf, um Performance-Einbußen zu vermeiden.

## Tutorials

### [Tutorial 1](frida-tutorial-1.md)

**Von**: [https://medium.com/infosec-adventures/introduction-to-frida-5a3f51595ca1](https://medium.com/infosec-adventures/introduction-to-frida-5a3f51595ca1)\
**APK**: [https://github.com/t0thkr1s/frida-demo/releases](https://github.com/t0thkr1s/frida-demo/releases)\
**Source Code**: [https://github.com/t0thkr1s/frida-demo](https://github.com/t0thkr1s/frida-demo)

**Folge dem [Link, um es zu lesen](frida-tutorial-1.md).**

### [Tutorial 2](frida-tutorial-2.md)

**Von**: [https://11x256.github.io/Frida-hooking-android-part-2/](https://11x256.github.io/Frida-hooking-android-part-2/) (Teile 2, 3 & 4)\
**APKs und Source Code**: [https://github.com/11x256/frida-android-examples](https://github.com/11x256/frida-android-examples)

**Folge dem [Link, um es zu lesen.](frida-tutorial-2.md)**

### [Tutorial 3](owaspuncrackable-1.md)

**Von**: [https://joshspicer.com/android-frida-1](https://joshspicer.com/android-frida-1)\
**APK**: [https://github.com/OWASP/owasp-mstg/blob/master/Crackmes/Android/Level_01/UnCrackable-Level1.apk](https://github.com/OWASP/owasp-mstg/blob/master/Crackmes/Android/Level_01/UnCrackable-Level1.apk)

**Folge dem [Link, um es zu lesen](owaspuncrackable-1.md).**

**Weitere großartige Frida-Skripte findest du hier:** [**https://codeshare.frida.re/**](https://codeshare.frida.re)

## Schnelle Beispiele

### Frida über die Kommandozeile aufrufen
```bash
frida-ps -U

#Basic frida hooking
frida -l disableRoot.js -f owasp.mstg.uncrackable1

#Hooking before starting the app
frida -U --no-pause -l disableRoot.js -f owasp.mstg.uncrackable1
#The --no-pause and -f options allow the app to be spawned automatically,
#frozen so that the instrumentation can occur, and the automatically
#continue execution with our modified code.
```
### Grundlegendes Python-Skript
```python
import frida, sys

jscode = open(sys.argv[0]).read()
process = frida.get_usb_device().attach('infosecadventures.fridademo')
script = process.create_script(jscode)
print('[ * ] Running Frida Demo application')
script.load()
sys.stdin.read()
```
### Hooking Funktionen ohne Parameter

Hook die Funktion `a()` der Klasse `sg.vantagepoint.a.c`
```javascript
Java.perform(function () {
rootcheck1.a.overload().implementation = function () {
return false;
};
});
```
Hook java `exit()`
```javascript
var sysexit = Java.use("java.lang.System")
sysexit.exit.overload("int").implementation = function (var_0) {
send("java.lang.System.exit(I)V  // We avoid exiting the application  :)")
}
```
Hook MainActivity `.onStart()` & `.onCreate()`
```javascript
var mainactivity = Java.use("sg.vantagepoint.uncrackable1.MainActivity")
mainactivity.onStart.overload().implementation = function () {
send("MainActivity.onStart() HIT!!!")
var ret = this.onStart.overload().call(this)
}
mainactivity.onCreate.overload("android.os.Bundle").implementation = function (
var_0
) {
send("MainActivity.onCreate() HIT!!!")
var ret = this.onCreate.overload("android.os.Bundle").call(this, var_0)
}
```
Hook android `.onCreate()`
```javascript
var activity = Java.use("android.app.Activity")
activity.onCreate.overload("android.os.Bundle").implementation = function (
var_0
) {
send("Activity HIT!!!")
var ret = this.onCreate.overload("android.os.Bundle").call(this, var_0)
}
```
### Hooking von Funktionen mit Parametern und Abrufen des Werts

Hooking a decryption function. Gib die Eingabe aus, rufe die Originalfunktion auf, decrypt die Eingabe und gib schließlich die Klartextdaten aus:

<details>
<summary>Hooking a decryption function (Java) — print inputs/outputs</summary>
```javascript
function getString(data) {
var ret = ""
for (var i = 0; i < data.length; i++) {
ret += data[i].toString()
}
return ret
}
var aes_decrypt = Java.use("sg.vantagepoint.a.a")
aes_decrypt.a.overload("[B", "[B").implementation = function (var_0, var_1) {
send("sg.vantagepoint.a.a.a([B[B)[B   doFinal(enc)  // AES/ECB/PKCS7Padding")
send("Key       : " + getString(var_0))
send("Encrypted : " + getString(var_1))
var ret = this.a.overload("[B", "[B").call(this, var_0, var_1)
send("Decrypted : " + ret)

var flag = ""
for (var i = 0; i < ret.length; i++) {
flag += String.fromCharCode(ret[i])
}
send("Decrypted flag: " + flag)
return ret //[B
}
```
</details>

### Hooking von Funktionen und Aufruf mit unserer Eingabe

Hook eine Funktion, die einen String empfängt, und rufe sie mit einem anderen String auf (aus [here](https://11x256.github.io/Frida-hooking-android-part-2/))
```javascript
var string_class = Java.use("java.lang.String") // get a JS wrapper for java's String class

my_class.fun.overload("java.lang.String").implementation = function (x) {
//hooking the new function
var my_string = string_class.$new("My TeSt String#####") //creating a new String by using `new` operator
console.log("Original arg: " + x)
var ret = this.fun(my_string) // calling the original function with the new String, and putting its return value in ret variable
console.log("Return value: " + ret)
return ret
}
```
### Zugriff auf ein bereits erstelltes object einer class

Wenn du ein Attribut eines erstellten object auslesen möchtest, kannst du folgendes verwenden.

In diesem Beispiel siehst du, wie du das object der class my_activity bekommst und wie du die Funktion .secret() aufrufst, die ein privates Attribut des object ausgibt:
```javascript
Java.choose("com.example.a11x256.frida_test.my_activity", {
onMatch: function (instance) {
//This function will be called for every instance found by frida
console.log("Found instance: " + instance)
console.log("Result of secret func: " + instance.secret())
},
onComplete: function () {},
})
```
## Weitere Frida-Tutorials

- [https://github.com/DERE-ad2001/Frida-Labs](https://github.com/DERE-ad2001/Frida-Labs)
- [Teil 1 der Advanced Frida Usage Blog-Serie: IOS Encryption Libraries](https://8ksec.io/advanced-frida-usage-part-1-ios-encryption-libraries-8ksec-blogs/)


## Referenzen

- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [Frida Gadget documentation](https://frida.re/docs/gadget/)
- [Frida releases (server binaries)](https://github.com/frida/frida/releases)
- [Objection (SensePost)](https://github.com/sensepost/objection)
- [Modding And Distributing Mobile Apps with Frida](https://pit.bearblog.dev/modding-and-distributing-mobile-apps-with-frida/)
- [frida-jdwp-loader](https://github.com/frankheat/frida-jdwp-loader)
- [Library injection for debuggable Android apps (blog)](https://koz.io/library-injection-for-debuggable-android-apps/)
- [jdwp-lib-injector (original idea/tool)](https://github.com/ikoz/jdwp-lib-injector)
- [jdwp-shellifier](https://github.com/hugsy/jdwp-shellifier)
- ["Super secure" MAGA-themed messaging app leaks everyone’s phone number](https://ericdaigle.ca/posts/super-secure-maga-messaging-app-leaks-everyones-phone-number/)
- [Android Frida Hooking: Disabling FLAG_SECURE](https://www.securify.nl/en/blog/android-frida-hooking-disabling-flagsecure/)
- [frida-ui](https://github.com/adityatelange/frida-ui)
- [clsdumper — Android Dynamic Class Dumper](https://github.com/TheQmaks/clsdumper)

{{#include ../../../banners/hacktricks-training.md}}
