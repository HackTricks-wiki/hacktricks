# Objection Tutorial

{{#include ../../../banners/hacktricks-training.md}}



## **Вступ**

**objection - Дослідження мобільних додатків в реальному часі**

[**Objection**](https://github.com/sensepost/objection) - це набір інструментів для дослідження мобільних додатків в реальному часі, що працює на базі [Frida](https://www.frida.re). Він був створений з метою допомогти оцінити мобільні додатки та їхню безпеку без необхідності використовувати пристрій з джейлбрейком або рутом.

**Примітка:** Це не є формою обходу джейлбрейку / руту. Використовуючи `objection`, ви все ще обмежені всіма обмеженнями, накладеними відповідним пісочницею, з якою ви стикаєтеся.

### Резюме

**Мета** **objection** - дозволити користувачу викликати **основні дії, які пропонує Frida**. **В іншому випадку**, користувачеві потрібно буде створити **окремий скрипт для кожного додатку**, який він хоче протестувати.

## Туторіал

Для цього туторіалу я буду використовувати APK, який ви можете завантажити тут:

{% file src="../../../images/app-release.zip" %}

Або з його [оригінального репозиторію](https://github.com/asvid/FridaApp) (завантажити app-release.apk)

### Встановлення
```bash
pip3 install objection
```
### З'єднання

Зробіть **звичайне з'єднання ADB** і **запустіть** сервер **frida** на пристрої (і перевірте, що frida працює як на клієнті, так і на сервері).

Якщо ви використовуєте **пристрій з root-доступом**, потрібно вибрати додаток, який ви хочете протестувати, у параметрі _**--gadget**_. у цьому випадку:
```bash
frida-ps -Uai
objection --gadget asvid.github.io.fridaapp explore
```
### Основні дії

Не всі можливі команди objections будуть перераховані в цьому посібнику, лише ті, які я вважаю більш корисними.

#### Середовище

Деяка цікава інформація (наприклад, паролі або шляхи) може бути знайдена всередині середовища.
```bash
env
```
![](<../../../images/image (220).png>)

#### Інформація про Frida
```bash
frida
```
![](<../../../images/image (1093).png>)

#### Завантаження/Вивантаження
```bash
file download <remote path> [<local path>]
file upload <local path> [<remote path>]
```
#### Імпорт скрипту frida
```bash
import <local path frida-script>
```
#### SSLPinning
```bash
android sslpinning disable #Attempts to disable SSL Pinning on Android devices.
```
#### Виявлення root-доступу
```bash
android root disable  #Attempts to disable root detection on Android devices.
android root simulate #Attempts to simulate a rooted Android environment.
```
#### Виконати команду
```bash
android shell_exec whoami
```
#### Скриншоти
```bash
android ui screenshot /tmp/screenshot
android ui FLAG_SECURE false  #This may enable you to take screenshots using the hardware keys
```
### Статичний аналіз став динамічним

У реальному додатку ми повинні знати всю інформацію, виявлену в цій частині, перш ніж використовувати objection завдяки **статичному аналізу**. У будь-якому випадку, таким чином ви, можливо, зможете побачити **щось нове**, оскільки тут ви отримаєте лише повний список класів, методів та експортованих об'єктів.

Це також корисно, якщо якимось чином ви **не можете отримати читабельний вихідний код** додатку.

#### Список активностей, приймачів та сервісів
```bash
android hooking list activities
```
![](<../../../images/image (1016).png>)
```bash
android hooking list services
android hooking list receivers
```
Frida видасть помилку, якщо нічого не знайдено

#### Отримання поточної активності
```bash
android hooking get current_activity
```
![](<../../../images/image (813).png>)

#### Пошук класів

Давайте почнемо шукати класи всередині нашого додатку.
```bash
android hooking search classes asvid.github.io.fridaapp
```
![](<../../../images/image (507).png>)

#### Методи пошуку класу

Тепер давайте витягнемо методи всередині класу _MainActivity:_
```bash
android hooking search methods asvid.github.io.fridaapp MainActivity
```
![](<../../../images/image (929).png>)

#### Перелік оголошених методів класу з їх параметрами

Давайте з'ясуємо, які параметри потрібні методам класу:
```bash
android hooking list class_methods asvid.github.io.fridaapp.MainActivity
```
![](<../../../images/image (299).png>)

#### Список класів

Ви також можете перерахувати всі класи, які були завантажені в поточному додатку:
```bash
android hooking list classes #List all loaded classes, As the target application gets usedmore, this command will return more classes.
```
Це дуже корисно, якщо ви хочете **перехопити метод класу і знаєте лише назву класу**. Ви можете використовувати цю функцію, щоб **знайти, який модуль володіє класом** і потім перехопити його метод.

### Перехоплення є простим

#### Перехоплення (спостереження) методу

З [джерельного коду](https://github.com/asvid/FridaApp/blob/master/app/src/main/java/asvid/github/io/fridaapp/MainActivity.kt) програми ми знаємо, що **функція** _**sum()**_ **з** _**MainActivity**_ виконується **кожну секунду**. Спробуємо **вивантажити всю можливу інформацію** щоразу, коли функція викликається (аргументи, значення повернення та трасування):
```bash
android hooking watch class_method asvid.github.io.fridaapp.MainActivity.sum --dump-args --dump-backtrace --dump-return
```
![](<../../../images/image (1086).png>)

#### Хукання (спостереження) за цілим класом

Насправді, всі методи класу MainActivity мені дуже цікаві, давайте **захукаємо їх усі**. Будьте обережні, це може **викликати збої** в додатку.
```bash
android hooking watch class asvid.github.io.fridaapp.MainActivity --dump-args --dump-return
```
Якщо ви граєте з додатком, поки клас підключений, ви побачите, коли **кожна функція викликається**, її **аргументи** та **значення повернення**.

![](<../../../images/image (861).png>)

#### Зміна булевого значення повернення функції

З вихідного коду ви можете побачити, що функція _checkPin_ отримує _String_ як аргумент і повертає _boolean_. Давайте зробимо так, щоб функція **завжди повертала true**:

![](<../../../images/image (883).png>)

Тепер, якщо ви введете будь-що в текстове поле для PIN-коду, ви побачите, що все є дійсним:

![](<../../../images/image (228).png>)

### Екземпляри класу

Шукайте та виводьте **живі екземпляри конкретного Java класу**, вказаного повністю кваліфікованим ім'ям класу. Ось результат спроби отримати значення рядка для виявленого objection, яке зазвичай **містить значення властивостей для об'єкта**.
```
android heap print_instances <class>
```
![](<../../../images/image (1095).png>)

### Keystore/Intents

Ви можете експериментувати з keystore та intents, використовуючи:
```bash
android keystore list
android intents launch_activity
android intent launch_service
```
### Пам'ять

#### Дамп
```bash
memory dump all <local destination> #Dump all memory
memory dump from_base <base_address> <size_to_dump> <local_destination> #Dump a part
```
#### Список
```bash
memory list modules
```
![](<../../../images/image (286).png>)

Внизу списку ви можете побачити frida:

![](<../../../images/image (1097).png>)

Давайте перевіримо, що експортує frida:

![](<../../../images/image (298).png>)

#### Пошук/Запис

Ви також можете шукати та записувати в пам'яті за допомогою objection:
```bash
memory search "<pattern eg: 41 41 41 ?? 41>" (--string) (--offsets-only)
memory write "<address>" "<pattern eg: 41 41 41 41>" (--string)
```
### SQLite

Ви можете використовувати команду `sqlite` для взаємодії з базами даних sqlite.

### Exit
```bash
exit
```
## Що мені не вистачає в Objection

- Методи хуків іноді призводять до збоїв програми (це також пов'язано з Frida).
- Ви не можете використовувати екземпляри класів для виклику функцій екземпляра. І ви не можете створювати нові екземпляри класів і використовувати їх для виклику функцій.
- Немає ярлика (як для sslpinnin), щоб підключити всі загальні криптографічні методи, що використовуються програмою, щоб побачити зашифрований текст, відкритий текст, ключі, IV та алгоритми, що використовуються.
