# Objection Tutorial

{{#include ../../../banners/hacktricks-training.md}}



## **Einführung**

**objection - Runtime Mobile Exploration**

[**Objection**](https://github.com/sensepost/objection) ist ein Toolkit zur runtime mobilen Erkundung, das von [Frida](https://www.frida.re) unterstützt wird. Es wurde mit dem Ziel entwickelt, mobile Anwendungen und deren Sicherheitslage zu bewerten, ohne dass ein jailbreak- oder gerootetes mobiles Gerät erforderlich ist.

**Hinweis:** Dies ist keine Form von Jailbreak / Root-Bypass. Durch die Verwendung von `objection` sind Sie weiterhin durch alle Einschränkungen des jeweiligen Sandboxes, mit dem Sie konfrontiert sind, eingeschränkt.

### Zusammenfassung

Das **Ziel** von **objection** ist es, dem Benutzer zu ermöglichen, die **Hauptaktionen, die Frida bietet**, aufzurufen. **Andernfalls** muss der Benutzer ein **einzelnes Skript für jede Anwendung** erstellen, die er testen möchte.

## Tutorial

Für dieses Tutorial werde ich die APK verwenden, die Sie hier herunterladen können:

{% file src="../../../images/app-release.zip" %}

Oder aus dem [originalen Repository](https://github.com/asvid/FridaApp) (app-release.apk herunterladen)

### Installation
```bash
pip3 install objection
```
### Verbindung

Stellen Sie eine **reguläre ADB-Verbindung** her und **starten** Sie den **frida**-Server auf dem Gerät (und überprüfen Sie, ob frida sowohl auf dem Client als auch auf dem Server funktioniert).

Wenn Sie ein **gerootetes Gerät** verwenden, müssen Sie die Anwendung auswählen, die Sie im _**--gadget**_-Option testen möchten. In diesem Fall:
```bash
frida-ps -Uai
objection --gadget asvid.github.io.fridaapp explore
```
### Grundlegende Aktionen

Nicht alle möglichen Befehle von Objection werden in diesem Tutorial aufgelistet, nur die, die ich als nützlicher empfunden habe.

#### Umgebung

Einige interessante Informationen (wie Passwörter oder Pfade) könnten in der Umgebung gefunden werden.
```bash
env
```
![](<../../../images/image (220).png>)

#### Frida Informationen
```bash
frida
```
![](<../../../images/image (1093).png>)

#### Hochladen/Herunterladen
```bash
file download <remote path> [<local path>]
file upload <local path> [<remote path>]
```
#### Frida-Skript importieren
```bash
import <local path frida-script>
```
#### SSLPinning
```bash
android sslpinning disable #Attempts to disable SSL Pinning on Android devices.
```
#### Root-Erkennung
```bash
android root disable  #Attempts to disable root detection on Android devices.
android root simulate #Attempts to simulate a rooted Android environment.
```
#### Exec-Befehl
```bash
android shell_exec whoami
```
#### Screenshots
```bash
android ui screenshot /tmp/screenshot
android ui FLAG_SECURE false  #This may enable you to take screenshots using the hardware keys
```
### Statische Analyse wird dynamisch

In einer echten Anwendung sollten wir alle Informationen, die in diesem Teil entdeckt wurden, dank **statischer Analyse** kennen, bevor wir objection verwenden. Trotzdem kannst du auf diese Weise vielleicht **etwas Neues** sehen, da du hier nur eine vollständige Liste von Klassen, Methoden und exportierten Objekten haben wirst.

Dies ist auch nützlich, wenn du aus irgendeinem Grund **keinen lesbaren Quellcode** der App erhalten kannst.

#### Aktivitäten, Empfänger und Dienste auflisten
```bash
android hooking list activities
```
![](<../../../images/image (1016).png>)
```bash
android hooking list services
android hooking list receivers
```
Frida wird einen Fehler auslösen, wenn keine gefunden wird

#### Aktuelle Aktivität abrufen
```bash
android hooking get current_activity
```
![](<../../../images/image (813).png>)

#### Klassen suchen

Lass uns anfangen, nach Klassen in unserer Anwendung zu suchen.
```bash
android hooking search classes asvid.github.io.fridaapp
```
![](<../../../images/image (507).png>)

#### Suchmethoden einer Klasse

Jetzt extrahieren wir die Methoden innerhalb der Klasse _MainActivity:_
```bash
android hooking search methods asvid.github.io.fridaapp MainActivity
```
![](<../../../images/image (929).png>)

#### Liste der deklarierten Methoden einer Klasse mit ihren Parametern

Lass uns herausfinden, welche Parameter die Methoden der Klasse benötigen:
```bash
android hooking list class_methods asvid.github.io.fridaapp.MainActivity
```
![](<../../../images/image (299).png>)

#### Klassen auflisten

Sie können auch alle Klassen auflisten, die in der aktuellen Anwendung geladen wurden:
```bash
android hooking list classes #List all loaded classes, As the target application gets usedmore, this command will return more classes.
```
Das ist sehr nützlich, wenn Sie **die Methode einer Klasse hooken möchten und nur den Namen der Klasse kennen**. Sie könnten diese Funktion verwenden, um **zu suchen, welches Modul die Klasse besitzt** und dann ihre Methode zu hooken.

### Hooking ist einfach

#### Eine Methode hooken (überwachen)

Aus dem [Quellcode](https://github.com/asvid/FridaApp/blob/master/app/src/main/java/asvid/github/io/fridaapp/MainActivity.kt) der Anwendung wissen wir, dass die **Funktion** _**sum()**_ **von** _**MainActivity**_ **jede Sekunde** ausgeführt wird. Lassen Sie uns versuchen, **alle möglichen Informationen** jedes Mal zu **dumpen**, wenn die Funktion aufgerufen wird (Argumente, Rückgabewert und Backtrace):
```bash
android hooking watch class_method asvid.github.io.fridaapp.MainActivity.sum --dump-args --dump-backtrace --dump-return
```
![](<../../../images/image (1086).png>)

#### Hooking (Überwachen) einer gesamten Klasse

Tatsächlich finde ich alle Methoden der Klasse MainActivity wirklich interessant, lass uns **alle hooken**. Sei vorsichtig, das könnte eine Anwendung **zum Absturz bringen**.
```bash
android hooking watch class asvid.github.io.fridaapp.MainActivity --dump-args --dump-return
```
Wenn Sie mit der Anwendung spielen, während die Klasse gehookt ist, werden Sie sehen, wann **jede Funktion aufgerufen wird**, ihre **Argumente** und den **Rückgabewert**.

![](<../../../images/image (861).png>)

#### Ändern des booleschen Rückgabewerts einer Funktion

Aus dem Quellcode können Sie sehen, dass die Funktion _checkPin_ einen _String_ als Argument erhält und einen _boolean_ zurückgibt. Lassen Sie uns die Funktion **immer true zurückgeben**:

![](<../../../images/image (883).png>)

Jetzt, wenn Sie irgendetwas in das Textfeld für den PIN-Code eingeben, werden Sie sehen, dass alles gültig ist:

![](<../../../images/image (228).png>)

### Klasseninstanzen

Suchen und drucken Sie **lebende Instanzen einer bestimmten Java-Klasse**, die durch einen vollqualifizierten Klassennamen angegeben ist. Das Ergebnis ist der Versuch, einen String-Wert für eine entdeckte Objection zu erhalten, die typischerweise **Eigenschaftswerte für das Objekt enthalten würde**.
```
android heap print_instances <class>
```
![](<../../../images/image (1095).png>)

### Keystore/Intents

Sie können mit dem Keystore und Intents spielen, indem Sie:
```bash
android keystore list
android intents launch_activity
android intent launch_service
```
### Speicher

#### Dump
```bash
memory dump all <local destination> #Dump all memory
memory dump from_base <base_address> <size_to_dump> <local_destination> #Dump a part
```
#### Liste
```bash
memory list modules
```
![](<../../../images/image (286).png>)

Unten in der Liste kannst du frida sehen:

![](<../../../images/image (1097).png>)

Lass uns überprüfen, was frida exportiert:

![](<../../../images/image (298).png>)

#### Suchen/Schreiben

Du kannst auch im Speicher mit objection suchen und schreiben:
```bash
memory search "<pattern eg: 41 41 41 ?? 41>" (--string) (--offsets-only)
memory write "<address>" "<pattern eg: 41 41 41 41>" (--string)
```
### SQLite

Sie können den Befehl `sqlite` verwenden, um mit SQLite-Datenbanken zu interagieren.

### Exit
```bash
exit
```
## Was ich in Objection vermisse

- Die Hooking-Methoden lassen manchmal die Anwendung abstürzen (das liegt auch an Frida).
- Sie können die Instanzen der Klassen nicht verwenden, um Funktionen der Instanz aufzurufen. Und Sie können keine neuen Instanzen von Klassen erstellen und diese verwenden, um Funktionen aufzurufen.
- Es gibt keinen Shortcut (wie den für sslpinnin), um alle gängigen Krypto-Methoden, die von der Anwendung verwendet werden, zu hooken, um verschlüsselte Texte, Klartexte, Schlüssel, IVs und verwendete Algorithmen zu sehen.
