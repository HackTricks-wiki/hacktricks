# Objection Tutorial

{{#include ../../../banners/hacktricks-training.md}}



## **介绍**

**objection - 运行时移动探索**

[**Objection**](https://github.com/sensepost/objection) 是一个运行时移动探索工具包，由 [Frida](https://www.frida.re) 提供支持。它的目的是帮助评估移动应用程序及其安全态势，而无需越狱或获取根权限的移动设备。

**注意：** 这不是某种形式的越狱/根权限绕过。使用 `objection` 时，您仍然受到所面临的适用沙箱施加的所有限制。

### 简介

**objection** 的 **目标** 是让用户调用 **Frida 提供的主要操作**。**否则**，用户将需要为每个想要测试的应用程序创建 **单个脚本**。

## 教程

在本教程中，我将使用您可以在此处下载的 APK：

{% file src="../../../images/app-release.zip" %}

或从其 [原始仓库](https://github.com/asvid/FridaApp)（下载 app-release.apk）

### 安装
```bash
pip3 install objection
```
### 连接

建立一个 **常规 ADB 连接** 并 **启动** 设备上的 **frida** 服务器（并检查 frida 在客户端和服务器上是否正常工作）。

如果您使用的是 **root 设备**，则需要在 _**--gadget**_ 选项中选择您想要测试的应用程序。在这种情况下：
```bash
frida-ps -Uai
objection --gadget asvid.github.io.fridaapp explore
```
### 基本操作

本教程不会列出所有可能的objection命令，仅列出我发现更有用的命令。

#### 环境

一些有趣的信息（如密码或路径）可能会在环境中找到。
```bash
env
```
![](<../../../images/image (220).png>)

#### Frida 信息
```bash
frida
```
![](<../../../images/image (1093).png>)

#### 上传/下载
```bash
file download <remote path> [<local path>]
file upload <local path> [<remote path>]
```
#### 导入 frida 脚本
```bash
import <local path frida-script>
```
#### SSLPinning
```bash
android sslpinning disable #Attempts to disable SSL Pinning on Android devices.
```
#### 根检测
```bash
android root disable  #Attempts to disable root detection on Android devices.
android root simulate #Attempts to simulate a rooted Android environment.
```
#### 执行命令
```bash
android shell_exec whoami
```
#### 截图
```bash
android ui screenshot /tmp/screenshot
android ui FLAG_SECURE false  #This may enable you to take screenshots using the hardware keys
```
### 静态分析变为动态

在真实应用中，我们应该在使用 objection 之前了解这一部分发现的所有信息，这得益于 **静态分析**。无论如何，这种方式也许可以让你看到 **一些新东西**，因为在这里你将仅获得一个完整的类、方法和导出对象的列表。

如果你以某种方式 **无法获取应用的可读源代码**，这也是有用的。

#### 列出活动、接收器和服务
```bash
android hooking list activities
```
![](<../../../images/image (1016).png>)
```bash
android hooking list services
android hooking list receivers
```
Frida 如果未找到任何内容，将会启动错误

#### 获取当前活动
```bash
android hooking get current_activity
```
![](<../../../images/image (813).png>)

#### 搜索类

让我们开始在应用程序中查找类。
```bash
android hooking search classes asvid.github.io.fridaapp
```
![](<../../../images/image (507).png>)

#### 搜索类的方法

现在让我们提取类 _MainActivity:_ 中的方法：
```bash
android hooking search methods asvid.github.io.fridaapp MainActivity
```
![](<../../../images/image (929).png>)

#### 列出类的声明方法及其参数

让我们找出类的方法需要哪些参数：
```bash
android hooking list class_methods asvid.github.io.fridaapp.MainActivity
```
![](<../../../images/image (299).png>)

#### 列出类

您还可以列出当前应用程序中加载的所有类：
```bash
android hooking list classes #List all loaded classes, As the target application gets usedmore, this command will return more classes.
```
这在你想要**挂钩一个类的方法而你只知道类的名称**时非常有用。你可以使用这个函数来**搜索哪个模块拥有这个类**，然后挂钩它的方法。

### 挂钩变得简单

#### 挂钩（监视）一个方法

从[源代码](https://github.com/asvid/FridaApp/blob/master/app/src/main/java/asvid/github/io/fridaapp/MainActivity.kt)中我们知道**函数**_**sum()**_**来自**_**MainActivity**_**每秒运行一次**。让我们尝试在每次调用该函数时**转储所有可能的信息**（参数、返回值和回溯）：
```bash
android hooking watch class_method asvid.github.io.fridaapp.MainActivity.sum --dump-args --dump-backtrace --dump-return
```
![](<../../../images/image (1086).png>)

#### Hooking (watching) an entire class

实际上，我发现 MainActivity 类的所有方法都非常有趣，让我们**全部 hook 住**。小心，这可能会**崩溃**一个应用程序。
```bash
android hooking watch class asvid.github.io.fridaapp.MainActivity --dump-args --dump-return
```
如果您在类被挂钩时与应用程序进行交互，您将看到**每个函数被调用的时间**、其**参数**和**返回**值。

![](<../../../images/image (861).png>)

#### 更改函数的布尔返回值

从源代码中可以看到，函数_checkPin_接收一个_String_作为参数并返回一个_boolean_。让我们使该函数**始终返回 true**：

![](<../../../images/image (883).png>)

现在，如果您在 PIN 代码的文本框中输入任何内容，您将看到任何内容都是有效的：

![](<../../../images/image (228).png>)

### 类实例

搜索并打印**特定 Java 类的实时实例**，由完全限定的类名指定。输出是尝试获取发现的 objection 的字符串值的结果，该值通常**包含对象的属性值**。
```
android heap print_instances <class>
```
![](<../../../images/image (1095).png>)

### Keystore/Intents

您可以使用以下方法玩弄 keystore 和 intents：
```bash
android keystore list
android intents launch_activity
android intent launch_service
```
### 内存

#### 转储
```bash
memory dump all <local destination> #Dump all memory
memory dump from_base <base_address> <size_to_dump> <local_destination> #Dump a part
```
#### 列表
```bash
memory list modules
```
![](<../../../images/image (286).png>)

在列表底部，您可以看到 frida：

![](<../../../images/image (1097).png>)

让我们检查一下 frida 导出了什么：

![](<../../../images/image (298).png>)

#### 搜索/写入

您还可以使用 objection 在内存中搜索和写入：
```bash
memory search "<pattern eg: 41 41 41 ?? 41>" (--string) (--offsets-only)
memory write "<address>" "<pattern eg: 41 41 41 41>" (--string)
```
### SQLite

您可以使用命令 `sqlite` 与 sqlite 数据库进行交互。

### Exit
```bash
exit
```
## 我在 Objection 中缺失的内容

- 钩子方法有时会导致应用程序崩溃（这也是因为 Frida）。
- 你不能使用类的实例来调用实例的函数。你也不能创建类的新实例并使用它们来调用函数。
- 没有快捷方式（像 sslpinnin 那样）来钩住应用程序使用的所有常见加密方法，以查看加密文本、明文、密钥、IV 和使用的算法。
