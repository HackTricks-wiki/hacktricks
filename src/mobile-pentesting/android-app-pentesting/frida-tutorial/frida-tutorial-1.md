# Frida ट्यूटोरियल 1

{{#include ../../../banners/hacktricks-training.md}}


**यह पोस्ट का सारांश है**: [https://medium.com/infosec-adventures/introduction-to-frida-5a3f51595ca1](https://medium.com/infosec-adventures/introduction-to-frida-5a3f51595ca1)\
**APK**: [https://github.com/t0thkr1s/frida-demo/releases](https://github.com/t0thkr1s/frida-demo/releases)\
**Source Code**: [https://github.com/t0thkr1s/frida-demo](https://github.com/t0thkr1s/frida-demo)

## Python

Frida आपको एक चल रहे application के functions के अंदर **insert JavaScript code** डालने की अनुमति देता है। लेकिन आप **python** का उपयोग करके उन **hooks** को **call** कर सकते हैं और उनके साथ **interact** भी कर सकते हैं।

यह एक आसान **python** स्क्रिप्ट है जिसे आप इस ट्यूटोरियल में सुझाए गए सभी उदाहरणों के साथ उपयोग कर सकते हैं:
```python
#hooking.py
import frida, sys

with open(sys.argv[1], 'r') as f:
jscode = f.read()
process = frida.get_usb_device().attach('infosecadventures.fridademo')
script = process.create_script(jscode)
print('[ * ] Running Frida Demo application')
script.load()
sys.stdin.read()
```
script को कॉल करें:
```bash
python hooking.py <hookN.js>
```
frida के साथ python का उपयोग करना जानना उपयोगी है, लेकिन इन उदाहरणों के लिए आप सीधे Frida को command line frida tools का उपयोग करके कॉल भी कर सकते हैं:
```bash
frida -U --no-pause -l hookN.js -f infosecadventures.fridademo
```
## Hook 1 - Boolean Bypass

यहाँ आप देख सकते हैं कि कैसे किसी क्लास _infosecadventures.fridademo.utils.PinUtil_ की **boolean** method (_checkPin_) को **hook** किया जा सकता है
```javascript
//hook1.js
Java.perform(function () {
console.log("[ * ] Starting implementation override...")
var MainActivity = Java.use("infosecadventures.fridademo.utils.PinUtil")
MainActivity.checkPin.implementation = function (pin) {
console.log("[ + ] PIN check successfully bypassed!")
return true
}
})
```

```
python hooking.py hook1.js
```
Mirar: La funcion recibe como parametro un String, no hace falta overload?

## Hook 2 - Function Bruteforce

### Non-Static Function

यदि आप किसी क्लास के non-static function को कॉल करना चाहते हैं, तो आपको **पहले उस क्लास का एक instance चाहिए**। फिर, आप उस instance का उपयोग करके function को कॉल कर सकते हैं।\
ऐसा करने के लिए, आप **एक मौजूदा instance ढूँढें** और उसका उपयोग कर सकते हैं:
```javascript
Java.perform(function () {
console.log("[ * ] Starting PIN Brute-force, please wait...")
Java.choose("infosecadventures.fridademo.utils.PinUtil", {
onMatch: function (instance) {
console.log("[ * ] Instance found in memory: " + instance)
for (var i = 1000; i < 9999; i++) {
if (instance.checkPin(i + "") == true) {
console.log("[ + ] Found correct PIN: " + i)
break
}
}
},
onComplete: function () {},
})
})
```
इस मामले में यह काम नहीं कर रहा है क्योंकि कोई instance मौजूद नहीं है और function Static है

### Static Function

यदि function static है, तो आप इसे सीधे कॉल कर सकते हैं:
```javascript
//hook2.js
Java.perform(function () {
console.log("[ * ] Starting PIN Brute-force, please wait...")
var PinUtil = Java.use("infosecadventures.fridademo.utils.PinUtil")

for (var i = 1000; i < 9999; i++) {
if (PinUtil.checkPin(i + "") == true) {
console.log("[ + ] Found correct PIN: " + i)
}
}
})
```
## Hook 3 - arguments और return value को प्राप्त करना

आप किसी function को hook कर सकते हैं और उसे **print** करवा सकते हैं ताकि वह **passed arguments** और **return value** के मान दिखाए:
```javascript
//hook3.js
Java.perform(function () {
console.log("[ * ] Starting implementation override...")

var EncryptionUtil = Java.use(
"infosecadventures.fridademo.utils.EncryptionUtil"
)
EncryptionUtil.encrypt.implementation = function (key, value) {
console.log("Key: " + key)
console.log("Value: " + value)
var encrypted_ret = this.encrypt(key, value) //Call the original function
console.log("Encrypted value: " + encrypted_ret)
return encrypted_ret
}
})
```
## Hooking हाल के Android versions (14/15/16) पर

- **Frida 17.1.x+** से Android 14–16 पर Java hooking फिर से स्थिर है (ART quick entrypoint offsets were fixed)। अगर `Java.choose` Android 14+ पर कुछ लौटाता ही नहीं है, तो **frida-server/gadget** और **CLI/Python** पैकेजेस को >=17.1.5 में अपडेट करें।
- शुरुआती anti-debug checks वाले apps अक्सर `attach` से पहले बंद हो जाते हैं। **spawn** का उपयोग करें ताकि hooks `onCreate` से पहले लोड हो जाएं:
```bash
frida -U -f infosecadventures.fridademo -l hook1.js --no-pause
```
- जब कई ओवरलोड्स मौजूद हों, तो लक्ष्य को स्पष्ट रूप से चुनें:
```javascript
var Cls = Java.use("com.example.Class")
Cls.doThing.overload('java.lang.String', 'int').implementation = function(s, i) {
return this.doThing(s, i)
}
```
## Zygisk Gadget के साथ अधिक गुप्त injection

कुछ ऐप्स **ptrace** या `frida-server` का पता लगा लेती हैं। Magisk/Zygisk मॉड्यूल Zygote के भीतर **frida-gadget** लोड कर सकते हैं, जिससे किसी प्रोसेस पर ptrace न किया जाए:

1. एक Zygisk gadget मॉड्यूल इंस्टॉल करें (उदा., `zygisk-gadget`) और रिबूट करें।
2. स्टार्टअप चेक्स बायपास करने के लिए लक्ष्य पैकेज और वैकल्पिक डिले कॉन्फ़िगर करें:
```bash
adb shell "su -c 'echo infosecadventures.fridademo,5000 > /data/local/tmp/re.zyg.fri/target_packages'"
```
3. ऐप लॉन्च करें और gadget name से जुड़ें:
```bash
frida -U -n Gadget -l hook3.js
```
क्योंकि gadget को Zygote द्वारा इंजेक्ट किया जाता है, APK की integrity जांच अपरिवर्तित रहती है और बेसिक ptrace/Frida string जांच आमतौर पर विफल हो जाती हैं।

## महत्वपूर्ण

In this tutorial you have hooked methods using the name of the method and _.implementation_. But if there were **एक से अधिक method** with the same name, you will need to **उस method को निर्दिष्ट करें** that you want to hook **आर्गुमेंट्स के type को संकेत करते हुए**।

You can see that in [the next tutorial](frida-tutorial-2.md).




## संदर्भ

- [Frida News (Android 14–16 fixes & Frida 17.x releases)](https://frida.re/news/)
- [zygisk-gadget – Zygisk module that loads frida-gadget](https://github.com/hackcatml/zygisk-gadget)
{{#include ../../../banners/hacktricks-training.md}}
