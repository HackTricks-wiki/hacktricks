# APK-Decompiler

{{#include ../../banners/hacktricks-training.md}}

**Für weitere Details zu jedem Tool siehe den Originalbeitrag von** [**https://eiken.dev/blog/2021/02/how-to-break-your-jar-in-2021-decompilation-guide-for-jars-and-apks/#cfr**](https://eiken.dev/blog/2021/02/how-to-break-your-jar-in-2021-decompilation-guide-for-jars-and-apks/#cfr)

### [JD-Gui](https://github.com/java-decompiler/jd-gui)

Als der wegweisende GUI-Java-Decompiler ermöglicht **JD-Gui** die Untersuchung von Java-Code innerhalb von APK-Dateien. Es ist einfach zu bedienen; nach dem Erhalt der APK öffnen Sie sie einfach mit JD-Gui, um den Code zu inspizieren.

### [Jadx](https://github.com/skylot/jadx)

**Jadx** bietet eine benutzerfreundliche Oberfläche zum Decompilieren von Java-Code aus Android-Anwendungen. Es wird wegen seiner Benutzerfreundlichkeit auf verschiedenen Plattformen empfohlen.

- Um die GUI zu starten, navigieren Sie zum bin-Verzeichnis und führen Sie aus: `jadx-gui`
- Für die Verwendung über die Befehlszeile decompilieren Sie eine APK mit: `jadx app.apk`
- Um ein Ausgabeverzeichnis anzugeben oder Decompilierungsoptionen anzupassen: `jadx app.apk -d <path to output dir> --no-res --no-src --no-imports`

### [GDA-android-reversing-Tool](https://github.com/charles2gan/GDA-android-reversing-Tool)

**GDA**, ein nur für Windows verfügbares Tool, bietet umfangreiche Funktionen für das Reverse Engineering von Android-Apps. Installieren und führen Sie GDA auf Ihrem Windows-System aus, und laden Sie dann die APK-Datei zur Analyse.

### [Bytecode-Viewer](https://github.com/Konloch/bytecode-viewer/releases)

Mit **Bytecode-Viewer** können Sie APK-Dateien mit mehreren Decompilern analysieren. Nach dem Herunterladen führen Sie Bytecode-Viewer aus, laden Ihre APK und wählen die Decompiler aus, die Sie für die gleichzeitige Analyse verwenden möchten.

### [Enjarify](https://github.com/Storyyeller/enjarify)

**Enjarify** übersetzt Dalvik-Bytecode in Java-Bytecode, sodass Java-Analysetools Android-Anwendungen effektiver analysieren können.

- Um Enjarify zu verwenden, führen Sie aus: `enjarify app.apk` Dies erzeugt den Java-Bytecode, der dem bereitgestellten APK entspricht.

### [CFR](https://github.com/leibnitz27/cfr)

**CFR** kann moderne Java-Funktionen decompilieren. Verwenden Sie es wie folgt:

- Für die Standard-Decompilierung: `java -jar ./cfr.jar "app.jar" --outputdir "output_directory"`
- Für große JAR-Dateien passen Sie die JVM-Speicherzuweisung an: `java -Xmx4G -jar ./cfr.jar "app.jar" --outputdir "output_directory"`

### [Fernflower](https://github.com/JetBrains/intellij-community/tree/master/plugins/java-decompiler/engine)

**Fernflower**, ein analytischer Decompiler, muss aus dem Quellcode erstellt werden. Nach dem Erstellen:

- Decompilieren Sie eine JAR-Datei: `java -jar ./fernflower.jar "app.jar" "output_directory"` Dann extrahieren Sie die `.java`-Dateien aus der generierten JAR mit `unzip`.

### [Krakatau](https://github.com/Storyyeller/Krakatau)

**Krakatau** bietet detaillierte Kontrolle über die Decompilierung, insbesondere beim Umgang mit externen Bibliotheken.

- Verwenden Sie Krakatau, indem Sie den Pfad zur Standardbibliothek und die JAR-Datei angeben, die decompiliert werden soll: `./Krakatau/decompile.py -out "output_directory" -skip -nauto -path "./jrt-extractor/rt.jar" "app.jar"`

### [procyon](https://github.com/mstrobel/procyon)

Für eine einfache Decompilierung mit **procyon**:

- Decompilieren Sie eine JAR-Datei in ein angegebenes Verzeichnis: `procyon -jar "app.jar" -o "output_directory"`

### [frida-DEXdump](https://github.com/hluwa/frida-dexdump)

Dieses Tool kann verwendet werden, um das DEX einer laufenden APK im Speicher zu dumpen. Dies hilft, statische Obfuskation zu überwinden, die entfernt wird, während die Anwendung im Speicher ausgeführt wird.

{{#include ../../banners/hacktricks-training.md}}
