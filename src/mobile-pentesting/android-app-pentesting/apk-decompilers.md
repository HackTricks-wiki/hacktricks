# APK decompilers

{{#include ../../banners/hacktricks-training.md}}

**Per ulteriori dettagli su ciascun strumento, controlla il post originale di** [**https://eiken.dev/blog/2021/02/how-to-break-your-jar-in-2021-decompilation-guide-for-jars-and-apks/#cfr**](https://eiken.dev/blog/2021/02/how-to-break-your-jar-in-2021-decompilation-guide-for-jars-and-apks/#cfr)

### [JD-Gui](https://github.com/java-decompiler/jd-gui)

Come il pioniere decompilatore GUI Java, **JD-Gui** ti consente di investigare il codice Java all'interno dei file APK. È semplice da usare; dopo aver ottenuto l'APK, aprilo semplicemente con JD-Gui per ispezionare il codice.

### [Jadx](https://github.com/skylot/jadx)

**Jadx** offre un'interfaccia user-friendly per decompilare codice Java da applicazioni Android. È raccomandato per la sua facilità d'uso su diverse piattaforme.

- Per avviare l'interfaccia grafica, naviga nella directory bin ed esegui: `jadx-gui`
- Per l'uso da riga di comando, decompila un APK con: `jadx app.apk`
- Per specificare una directory di output o regolare le opzioni di decompilazione: `jadx app.apk -d <path to output dir> --no-res --no-src --no-imports`

### [GDA-android-reversing-Tool](https://github.com/charles2gan/GDA-android-reversing-Tool)

**GDA**, uno strumento solo per Windows, offre ampie funzionalità per il reverse engineering delle app Android. Installa e esegui GDA sul tuo sistema Windows, quindi carica il file APK per l'analisi.

### [Bytecode-Viewer](https://github.com/Konloch/bytecode-viewer/releases)

Con **Bytecode-Viewer**, puoi analizzare i file APK utilizzando più decompilatori. Dopo aver scaricato, esegui Bytecode-Viewer, carica il tuo APK e seleziona i decompilatori che desideri utilizzare per un'analisi simultanea.

### [Enjarify](https://github.com/Storyyeller/enjarify)

**Enjarify** traduce il bytecode Dalvik in bytecode Java, consentendo agli strumenti di analisi Java di analizzare le applicazioni Android in modo più efficace.

- Per utilizzare Enjarify, esegui: `enjarify app.apk` Questo genera l'equivalente bytecode Java dell'APK fornito.

### [CFR](https://github.com/leibnitz27/cfr)

**CFR** è in grado di decompilare le funzionalità Java moderne. Usalo come segue:

- Per la decompilazione standard: `java -jar ./cfr.jar "app.jar" --outputdir "output_directory"`
- Per file JAR di grandi dimensioni, regola l'allocazione della memoria JVM: `java -Xmx4G -jar ./cfr.jar "app.jar" --outputdir "output_directory"`

### [Fernflower](https://github.com/JetBrains/intellij-community/tree/master/plugins/java-decompiler/engine)

**Fernflower**, un decompilatore analitico, richiede la costruzione dal sorgente. Dopo la costruzione:

- Decompila un file JAR: `java -jar ./fernflower.jar "app.jar" "output_directory"` Poi, estrai i file `.java` dal JAR generato usando `unzip`.

### [Krakatau](https://github.com/Storyyeller/Krakatau)

**Krakatau** offre un controllo dettagliato sulla decompilazione, specialmente per la gestione di librerie esterne.

- Usa Krakatau specificando il percorso della libreria standard e il file JAR da decompilare: `./Krakatau/decompile.py -out "output_directory" -skip -nauto -path "./jrt-extractor/rt.jar" "app.jar"`

### [procyon](https://github.com/mstrobel/procyon)

Per una decompilazione semplice con **procyon**:

- Decompila un file JAR in una directory specificata: `procyon -jar "app.jar" -o "output_directory"`

### [frida-DEXdump](https://github.com/hluwa/frida-dexdump)

Questo strumento può essere utilizzato per dumpare il DEX di un APK in esecuzione in memoria. Questo aiuta a superare l'oscuramento statico che viene rimosso mentre l'applicazione è eseguita in memoria.

{{#include ../../banners/hacktricks-training.md}}
