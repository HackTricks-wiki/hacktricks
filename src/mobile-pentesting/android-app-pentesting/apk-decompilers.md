# APK dekompilatory

{{#include ../../banners/hacktricks-training.md}}

**Aby uzyskać więcej informacji na temat każdego narzędzia, sprawdź oryginalny post na** [**https://eiken.dev/blog/2021/02/how-to-break-your-jar-in-2021-decompilation-guide-for-jars-and-apks/#cfr**](https://eiken.dev/blog/2021/02/how-to-break-your-jar-in-2021-decompilation-guide-for-jars-and-apks/#cfr)

### [JD-Gui](https://github.com/java-decompiler/jd-gui)

Jako pionierski GUI dekompilator Java, **JD-Gui** pozwala na badanie kodu Java w plikach APK. Jest prosty w użyciu; po uzyskaniu pliku APK wystarczy otworzyć go w JD-Gui, aby sprawdzić kod.

### [Jadx](https://github.com/skylot/jadx)

**Jadx** oferuje przyjazny interfejs do dekompilacji kodu Java z aplikacji na Androida. Jest polecany za łatwość użycia na różnych platformach.

- Aby uruchomić GUI, przejdź do katalogu bin i wykonaj: `jadx-gui`
- Do użycia w wierszu poleceń, dekompiluj APK za pomocą: `jadx app.apk`
- Aby określić katalog wyjściowy lub dostosować opcje dekompilacji: `jadx app.apk -d <path to output dir> --no-res --no-src --no-imports`

### [GDA-android-reversing-Tool](https://github.com/charles2gan/GDA-android-reversing-Tool)

**GDA**, narzędzie tylko dla systemu Windows, oferuje rozbudowane funkcje do inżynierii wstecznej aplikacji na Androida. Zainstaluj i uruchom GDA na swoim systemie Windows, a następnie załaduj plik APK do analizy.

### [Bytecode-Viewer](https://github.com/Konloch/bytecode-viewer/releases)

Z **Bytecode-Viewer** możesz analizować pliki APK za pomocą wielu dekompilatorów. Po pobraniu uruchom Bytecode-Viewer, załaduj swój plik APK i wybierz dekompilatory, które chcesz użyć do jednoczesnej analizy.

### [Enjarify](https://github.com/Storyyeller/enjarify)

**Enjarify** tłumaczy bajty Dalvik na bajty Java, umożliwiając narzędziom analizy Java skuteczniejszą analizę aplikacji na Androida.

- Aby użyć Enjarify, uruchom: `enjarify app.apk` To generuje ekwiwalent bajtów Java dla podanego APK.

### [CFR](https://github.com/leibnitz27/cfr)

**CFR** jest w stanie dekompilować nowoczesne funkcje Java. Użyj go w następujący sposób:

- Do standardowej dekompilacji: `java -jar ./cfr.jar "app.jar" --outputdir "output_directory"`
- Dla dużych plików JAR, dostosuj przydział pamięci JVM: `java -Xmx4G -jar ./cfr.jar "app.jar" --outputdir "output_directory"`

### [Fernflower](https://github.com/JetBrains/intellij-community/tree/master/plugins/java-decompiler/engine)

**Fernflower**, analityczny dekompilator, wymaga budowy ze źródła. Po zbudowaniu:

- Dekompiluj plik JAR: `java -jar ./fernflower.jar "app.jar" "output_directory"` Następnie wyodrębnij pliki `.java` z wygenerowanego JAR za pomocą `unzip`.

### [Krakatau](https://github.com/Storyyeller/Krakatau)

**Krakatau** oferuje szczegółową kontrolę nad dekompilacją, szczególnie w przypadku obsługi zewnętrznych bibliotek.

- Użyj Krakatau, określając ścieżkę do standardowej biblioteki i plik JAR do dekompilacji: `./Krakatau/decompile.py -out "output_directory" -skip -nauto -path "./jrt-extractor/rt.jar" "app.jar"`

### [procyon](https://github.com/mstrobel/procyon)

Dla prostej dekompilacji z **procyon**:

- Dekompiluj plik JAR do określonego katalogu: `procyon -jar "app.jar" -o "output_directory"`

### [frida-DEXdump](https://github.com/hluwa/frida-dexdump)

To narzędzie może być używane do zrzucania DEX działającego APK w pamięci. Pomaga to pokonać statyczną obfuskację, która jest usuwana podczas wykonywania aplikacji w pamięci.

{{#include ../../banners/hacktricks-training.md}}
