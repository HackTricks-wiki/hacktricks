# APK decompilers

{{#include ../../banners/hacktricks-training.md}}

**Para más detalles sobre cada herramienta, consulta la publicación original en** [**https://eiken.dev/blog/2021/02/how-to-break-your-jar-in-2021-decompilation-guide-for-jars-and-apks/#cfr**](https://eiken.dev/blog/2021/02/how-to-break-your-jar-in-2021-decompilation-guide-for-jars-and-apks/#cfr)

### [JD-Gui](https://github.com/java-decompiler/jd-gui)

Como el decompilador GUI de Java pionero, **JD-Gui** te permite investigar el código Java dentro de archivos APK. Es fácil de usar; después de obtener el APK, simplemente ábrelo con JD-Gui para inspeccionar el código.

### [Jadx](https://github.com/skylot/jadx)

**Jadx** ofrece una interfaz fácil de usar para decompilar código Java de aplicaciones Android. Se recomienda por su facilidad de uso en diferentes plataformas.

- Para iniciar la GUI, navega al directorio bin y ejecuta: `jadx-gui`
- Para uso en línea de comandos, decompila un APK con: `jadx app.apk`
- Para especificar un directorio de salida o ajustar opciones de decompilación: `jadx app.apk -d <ruta al directorio de salida> --no-res --no-src --no-imports`

### [GDA-android-reversing-Tool](https://github.com/charles2gan/GDA-android-reversing-Tool)

**GDA**, una herramienta solo para Windows, ofrece amplias características para la ingeniería inversa de aplicaciones Android. Instala y ejecuta GDA en tu sistema Windows, luego carga el archivo APK para su análisis.

### [Bytecode-Viewer](https://github.com/Konloch/bytecode-viewer/releases)

Con **Bytecode-Viewer**, puedes analizar archivos APK utilizando múltiples decompiladores. Después de descargar, ejecuta Bytecode-Viewer, carga tu APK y selecciona los decompiladores que deseas usar para un análisis simultáneo.

### [Enjarify](https://github.com/Storyyeller/enjarify)

**Enjarify** traduce bytecode Dalvik a bytecode Java, permitiendo que las herramientas de análisis de Java analicen aplicaciones Android de manera más efectiva.

- Para usar Enjarify, ejecuta: `enjarify app.apk` Esto genera el bytecode Java equivalente del APK proporcionado.

### [CFR](https://github.com/leibnitz27/cfr)

**CFR** es capaz de decompilar características modernas de Java. Úsalo de la siguiente manera:

- Para decompilación estándar: `java -jar ./cfr.jar "app.jar" --outputdir "output_directory"`
- Para archivos JAR grandes, ajusta la asignación de memoria de la JVM: `java -Xmx4G -jar ./cfr.jar "app.jar" --outputdir "output_directory"`

### [Fernflower](https://github.com/JetBrains/intellij-community/tree/master/plugins/java-decompiler/engine)

**Fernflower**, un decompilador analítico, requiere ser construido desde el código fuente. Después de construir:

- Decompila un archivo JAR: `java -jar ./fernflower.jar "app.jar" "output_directory"` Luego, extrae los archivos `.java` del JAR generado usando `unzip`.

### [Krakatau](https://github.com/Storyyeller/Krakatau)

**Krakatau** ofrece un control detallado sobre la decompilación, especialmente para manejar bibliotecas externas.

- Usa Krakatau especificando la ruta de la biblioteca estándar y el archivo JAR a decompilar: `./Krakatau/decompile.py -out "output_directory" -skip -nauto -path "./jrt-extractor/rt.jar" "app.jar"`

### [procyon](https://github.com/mstrobel/procyon)

Para una decompilación sencilla con **procyon**:

- Decompila un archivo JAR a un directorio especificado: `procyon -jar "app.jar" -o "output_directory"`

### [frida-DEXdump](https://github.com/hluwa/frida-dexdump)

Esta herramienta se puede usar para volcar el DEX de un APK en ejecución en memoria. Esto ayuda a superar la ofuscación estática que se elimina mientras la aplicación se ejecuta en memoria.

{{#include ../../banners/hacktricks-training.md}}
