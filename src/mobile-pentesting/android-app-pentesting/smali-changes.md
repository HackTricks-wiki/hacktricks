# Smali - Dekompilacja/[Modyfikacja]/Kompilacja

{{#include ../../banners/hacktricks-training.md}}


Czasami warto zmodyfikować kod aplikacji, aby uzyskać dostęp do ukrytych informacji (np. dobrze obfuskowanych haseł lub flag). W takim przypadku warto zdekompilować APK, zmodyfikować kod i ponownie go skompilować.

**Opcodes reference:** [http://pallergabor.uw.hu/androidblog/dalvik_opcodes.html](http://pallergabor.uw.hu/androidblog/dalvik_opcodes.html)

## Szybki sposób

Używając **Visual Studio Code** i rozszerzenia [APKLab](https://github.com/APKLab/APKLab), możesz **automatycznie zdekompilować**, zmodyfikować, **ponownie skompilować**, podpisać i zainstalować aplikację bez uruchamiania poleceń.

Inny **skrypt**, który znacznie ułatwia to zadanie, to [**https://github.com/ax/apk.sh**](https://github.com/ax/apk.sh)

## Dekompilacja APK

Używając APKTool, możesz uzyskać dostęp do **kodu smali i zasobów**:
```bash
apktool d APP.apk
```
If **apktool** gives you any error, try[ installing the **latest version**](https://ibotpeaches.github.io/Apktool/install/)

Niektóre **interesujące pliki, które warto sprawdzić**:

- _res/values/strings.xml_ (and all xmls inside res/values/*)
- _AndroidManifest.xml_
- Any file with extension _.sqlite_ or _.db_

If `apktool` has **problems decoding the application** take a look to [https://ibotpeaches.github.io/Apktool/documentation/#framework-files](https://ibotpeaches.github.io/Apktool/documentation/#framework-files) or try using the argument **`-r`** (Nie dekoduj zasobów). Wówczas, jeśli problem był w zasobie, a nie w kodzie źródłowym, nie będziesz miał tego problemu (nie zdekompilujesz też zasobów).

## Change smali code

Możesz **zmieniać** **instrukcje**, zmieniać **wartość** niektórych zmiennych lub **dodawać** nowe instrukcje. Ja edytuję kod Smali używając [**VS Code**](https://code.visualstudio.com), następnie instaluję **smalise extension** i edytor powiadomi cię, jeśli jakaś **instrukcja jest niepoprawna**.\
Some **examples** can be found here:

- [Smali changes examples](smali-changes.md)
- [Google CTF 2018 - Shall We Play a Game?](google-ctf-2018-shall-we-play-a-game.md)

Or you can [**check below some Smali changes explained**](smali-changes.md#modifying-smali).

## Recompile the APK

Po zmodyfikowaniu kodu możesz **zrekompilować** kod używając:
```bash
apktool b . #In the folder generated when you decompiled the application
```
Spowoduje to, że nowe APK zostanie **compile** **inside** folderu _**dist**_.

Jeśli **apktool** zgłosi **error**, spróbuj[ installing the **latest version**](https://ibotpeaches.github.io/Apktool/install/)

### **Podpisz nowe APK**

Następnie musisz **wygenerować klucz** (zostaniesz poproszony o hasło oraz o kilka informacji, które możesz wypełnić losowo):
```bash
keytool -genkey -v -keystore key.jks -keyalg RSA -keysize 2048 -validity 10000 -alias <your-alias>
```
Na koniec, **podpisz** nowy APK:
```bash
jarsigner -keystore key.jks path/to/dist/* <your-alias>
```
### Optymalizacja nowej aplikacji

**zipalign** jest narzędziem do wyrównywania archiwów, które zapewnia istotną optymalizację plików aplikacji Android (APK). [More information here](https://developer.android.com/studio/command-line/zipalign).
```bash
zipalign [-f] [-v] <alignment> infile.apk outfile.apk
zipalign -v 4 infile.apk
```
### **Podpisz nowy APK (znowu?)**

Jeśli **wolisz** użyć [**apksigner**](https://developer.android.com/studio/command-line/) zamiast jarsigner, **powinieneś podpisać APK** po zastosowaniu **optymalizacji za pomocą** zipaling. ALE ZWRÓĆ UWAGĘ, ŻE MUSISZ **PODPISAĆ APLIKACJĘ TYLKO RAZ** PRZY UŻYCIU jarsigner (przed zipalign) LUB PRZY UŻYCIU aspsigner (po zipaling).
```bash
apksigner sign --ks key.jks ./dist/mycompiled.apk
```
## Modyfikowanie Smali

Dla następującego kodu Java Hello World:
```java
public static void printHelloWorld() {
System.out.println("Hello World")
}
```
Kod Smali wyglądałby tak:
```java
.method public static printHelloWorld()V
.registers 2
sget-object v0, Ljava/lang/System;->out:Ljava/io/PrintStream;
const-string v1, "Hello World"
invoke-virtual {v0,v1}, Ljava/io/PrintStream;->println(Ljava/lang/String;)V
return-void
.end method
```
Zestaw instrukcji Smali jest dostępny [here](https://source.android.com/devices/tech/dalvik/dalvik-bytecode#instructions).

### Drobne zmiany

### Modyfikacja wartości początkowych zmiennej w funkcji

Niektóre zmienne są zdefiniowane na początku funkcji przy użyciu opcode _const_, możesz zmodyfikować ich wartości lub zdefiniować nowe:
```bash
#Number
const v9, 0xf4240
const/4 v8, 0x1
#Strings
const-string v5, "wins"
```
### Podstawowe operacje
```bash
#Math
add-int/lit8 v0, v2, 0x1 #v2 + 0x1 and save it in v0
mul-int v0,v2,0x2 #v2*0x2 and save in v0

#Move the value of one object into another
move v1,v2

#Condtions
if-ge #Greater or equals
if-le #Less or equals
if-eq #Equals

#Get/Save attributes of an object
iget v0, p0, Lcom/google/ctf/shallweplayagame/GameActivity;->o:I #Save this.o inside v0
iput v0, p0, Lcom/google/ctf/shallweplayagame/GameActivity;->o:I #Save v0 inside this.o

#goto
:goto_6 #Declare this where you want to start a loop
if-ne v0, v9, :goto_6 #If not equals, go to: :goto_6
goto :goto_6 #Always go to: :goto_6
```
### Większe zmiany

### Logowanie
```bash
#Log win: <number>
iget v5, p0, Lcom/google/ctf/shallweplayagame/GameActivity;->o:I #Get this.o inside v5
invoke-static {v5}, Ljava/lang/String;->valueOf(I)Ljava/lang/String; #Transform number to String
move-result-object v1 #Move to v1
const-string v5, "wins" #Save "win" inside v5
invoke-static {v5, v1}, Landroid/util/Log;->d(Ljava/lang/String;Ljava/lang/String;)I #Logging "Wins: <num>"
```
Zalecenia:

- Jeśli zamierzasz użyć zadeklarowanych zmiennych wewnątrz funkcji (zadeklarowane v0,v1,v2...) umieść te linie pomiędzy _.local <number>_ i deklaracjami zmiennych (_const v0, 0x1_)
- Jeśli chcesz wstawić kod logowania w środku ciała funkcji:
- Dodaj 2 do liczby zadeklarowanych zmiennych: Ex: from _.locals 10_ to _.locals 12_
- Nowe zmienne powinny mieć kolejne numery względem już zadeklarowanych zmiennych (w tym przykładzie powinny to być _v10_ i _v11_, pamiętaj że numeracja zaczyna się od v0).
- Zmień kod funkcji logującej i użyj _v10_ i _v11_ zamiast _v5_ i _v1_.

### Wyświetlanie toastów

Pamiętaj, aby dodać 3 do liczby _.locals_ na początku funkcji.

Ten kod jest przygotowany do wstawienia w **środek funkcji** (**zmień** liczbę **zmiennych** w razie potrzeby). Pobierze **wartość this.o**, **zamieni** ją na **String**, a następnie **wyświetli** **toast** z jej wartością.
```bash
const/4 v10, 0x1
const/4 v11, 0x1
const/4 v12, 0x1
iget v10, p0, Lcom/google/ctf/shallweplayagame/GameActivity;->o:I
invoke-static {v10}, Ljava/lang/String;->valueOf(I)Ljava/lang/String;
move-result-object v11
invoke-static {p0, v11, v12}, Landroid/widget/Toast;->makeText(Landroid/content/Context;Ljava/lang/CharSequence;I)Landroid/widget/Toast;
move-result-object v12
invoke-virtual {v12}, Landroid/widget/Toast;->show()V
```
### Ładowanie biblioteki natywnej przy uruchamianiu (System.loadLibrary)

Czasami trzeba wstępnie załadować bibliotekę natywną, aby została zainicjalizowana przed innymi bibliotekami JNI (np. aby włączyć process-local telemetry/logging). Możesz wstrzyknąć wywołanie System.loadLibrary() w statycznym inicjalizatorze lub wcześnie w Application.onCreate(). Przykładowy smali dla statycznego inicjalizatora klasy (<clinit>):
```smali
.class public Lcom/example/App;
.super Landroid/app/Application;

.method static constructor <clinit>()V
.registers 1
const-string v0, "sotap"         # library name without lib...so prefix
invoke-static {v0}, Ljava/lang/System;->loadLibrary(Ljava/lang/String;)V
return-void
.end method
```
Alternatywnie, umieść te same dwie instrukcje na początku Application.onCreate(), aby zapewnić, że biblioteka załaduje się jak najwcześniej:
```smali
.method public onCreate()V
.locals 1

const-string v0, "sotap"
invoke-static {v0}, Ljava/lang/System;->loadLibrary(Ljava/lang/String;)V

invoke-super {p0}, Landroid/app/Application;->onCreate()V
return-void
.end method
```
Uwagi:
- Upewnij się, że właściwy wariant ABI biblioteki znajduje się w lib/<abi>/ (np. arm64-v8a/armeabi-v7a), aby uniknąć UnsatisfiedLinkError.
- Wczesne załadowanie (class static initializer) gwarantuje, że native logger będzie mógł obserwować późniejszą aktywność JNI.

## Źródła

- SoTap: Lekki logger zachowania JNI (.so) w aplikacji – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)

{{#include ../../banners/hacktricks-training.md}}
