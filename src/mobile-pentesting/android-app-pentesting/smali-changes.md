# Smali - Decompiling/[Modifying]/Compiling

{{#include ../../banners/hacktricks-training.md}}


Іноді буває корисно змінити код застосунку, щоб отримати приховану інформацію (наприклад добре обфусковані паролі або flags). Тоді може бути цікаво декомпілювати apk, змінити код і скомпілювати його знову.

**Opcodes reference:** [http://pallergabor.uw.hu/androidblog/dalvik_opcodes.html](http://pallergabor.uw.hu/androidblog/dalvik_opcodes.html)

## Fast Way

Використовуючи **Visual Studio Code** та розширення [APKLab](https://github.com/APKLab/APKLab), ви можете **автоматично декомпілювати**, змінити, **скомпілювати**, підписати та встановити застосунок без виконання будь-яких команд.

Ще один **скрипт**, який значно полегшує це завдання, — [**https://github.com/ax/apk.sh**](https://github.com/ax/apk.sh)

## Decompile the APK

За допомогою APKTool ви можете отримати доступ до **smali code and resources**:
```bash
apktool d APP.apk
```
Якщо **apktool** видає будь-яку помилку, спробуйте[ installing the **latest version**](https://ibotpeaches.github.io/Apktool/install/)

Деякі **цікаві файли, які варто переглянути**:

- _res/values/strings.xml_ (і всі xml-файли всередині res/values/*)
- _AndroidManifest.xml_
- Будь-який файл з розширенням _.sqlite_ або _.db_

Якщо `apktool` має **проблеми з декодуванням застосунку** перегляньте [https://ibotpeaches.github.io/Apktool/documentation/#framework-files](https://ibotpeaches.github.io/Apktool/documentation/#framework-files) або спробуйте використати аргумент **`-r`** (не декодувати ресурси). Якщо проблема була в ресурсі, а не в коді джерела, проблема зникне (ви також не декомпілюєте ресурси).

## Змінити smali код

Ви можете **змінювати** **інструкції**, змінювати **значення** деяких змінних або **додавати** нові інструкції. Я змінюю Smali-код за допомогою [**VS Code**](https://code.visualstudio.com), після чого встановіть **smalise extension** і редактор підкаже, якщо якась **інструкція некоректна**.\
Деякі **приклади** можна знайти тут:

- [Smali changes examples](smali-changes.md)
- [Google CTF 2018 - Shall We Play a Game?](google-ctf-2018-shall-we-play-a-game.md)

Або ви можете [**check below some Smali changes explained**](smali-changes.md#modifying-smali).

## Перекомпілювати APK

Після зміни коду ви можете **перекомпілювати** код, використовуючи:
```bash
apktool b . #In the folder generated when you decompiled the application
```
Він **зкомпілює** новий APK **всередині** папки _**dist**_.

Якщо **apktool** видає **помилку**, спробуйте [встановити **останню версію**](https://ibotpeaches.github.io/Apktool/install/)

### **Підписати новий APK**

Потім потрібно **згенерувати ключ** (у вас попросять пароль та деяку інформацію, яку можна заповнити довільно):
```bash
keytool -genkey -v -keystore key.jks -keyalg RSA -keysize 2048 -validity 10000 -alias <your-alias>
```
Нарешті, **підпишіть** новий APK:
```bash
jarsigner -keystore key.jks path/to/dist/* <your-alias>
```
### Оптимізувати новий додаток

**zipalign** — інструмент вирівнювання архівів, який забезпечує важливу оптимізацію для Android application (APK) files. [Детальніше](https://developer.android.com/studio/command-line/zipalign).
```bash
zipalign [-f] [-v] <alignment> infile.apk outfile.apk
zipalign -v 4 infile.apk
```
### **Підписати новий APK (знову?)**

Якщо ви **надаєте перевагу** використовувати [**apksigner**](https://developer.android.com/studio/command-line/) замість jarsigner, **ви повинні підписати apk** після застосування **оптимізації за допомогою** zipaling. ПРОТЕ ЗВЕРНІТЬ УВАГУ, ЩО ПОТРІБНО **ПІДПИСАТИ ДОДАТОК ЛИШЕ ОДИН РАЗ** за допомогою jarsigner (перед zipalign) АБО за допомогою aspsigner (після zipaling).
```bash
apksigner sign --ks key.jks ./dist/mycompiled.apk
```
## Зміна Smali

Для наступного Java-коду Hello World:
```java
public static void printHelloWorld() {
System.out.println("Hello World")
}
```
Код Smali буде:
```java
.method public static printHelloWorld()V
.registers 2
sget-object v0, Ljava/lang/System;->out:Ljava/io/PrintStream;
const-string v1, "Hello World"
invoke-virtual {v0,v1}, Ljava/io/PrintStream;->println(Ljava/lang/String;)V
return-void
.end method
```
Набір інструкцій Smali доступний [here](https://source.android.com/devices/tech/dalvik/dalvik-bytecode#instructions).

### Невеликі зміни

### Змінити початкові значення змінної всередині функції

Деякі змінні визначаються на початку функції за допомогою опкоду _const_, ви можете змінити їхні значення, або можете визначити нові:
```bash
#Number
const v9, 0xf4240
const/4 v8, 0x1
#Strings
const-string v5, "wins"
```
### Основні операції
```bash
#Math
add-int/lit8 v0, v2, 0x1 #v2 + 0x1 and save it in v0
mul-int v0,v2,0x2 #v2*0x2 and save in v0

#Move the value of one object into another
move v1,v2

#Condtions
if-ge #Greater or equals
if-le #Less or equals
if-eq #Equals

#Get/Save attributes of an object
iget v0, p0, Lcom/google/ctf/shallweplayagame/GameActivity;->o:I #Save this.o inside v0
iput v0, p0, Lcom/google/ctf/shallweplayagame/GameActivity;->o:I #Save v0 inside this.o

#goto
:goto_6 #Declare this where you want to start a loop
if-ne v0, v9, :goto_6 #If not equals, go to: :goto_6
goto :goto_6 #Always go to: :goto_6
```
### Більші зміни

### Логування
```bash
#Log win: <number>
iget v5, p0, Lcom/google/ctf/shallweplayagame/GameActivity;->o:I #Get this.o inside v5
invoke-static {v5}, Ljava/lang/String;->valueOf(I)Ljava/lang/String; #Transform number to String
move-result-object v1 #Move to v1
const-string v5, "wins" #Save "win" inside v5
invoke-static {v5, v1}, Landroid/util/Log;->d(Ljava/lang/String;Ljava/lang/String;)I #Logging "Wins: <num>"
```
Рекомендації:

- Якщо ви збираєтеся використовувати оголошені змінні всередині функції (declared v0,v1,v2...) розмістіть ці рядки між _.local <number>_ і деклараціями змінних (_const v0, 0x1_)
- Якщо ви хочете вставити logging code посеред коду функції:
- Додайте 2 до кількості оголошених змінних: Ex: from _.locals 10_ to _.locals 12_
- Нові змінні повинні бути наступними номерами від вже оголошених змінних (в цьому прикладі це повинні бути _v10_ та _v11_, пам'ятайте, що нумерація починається з v0).
- Змініть код logging function та використовуйте _v10_ і _v11_ замість _v5_ і _v1_.

### Toasting

Пам'ятайте додати 3 до числа _.locals_ на початку функції.

This code is prepared to be inserted in the **середину функції** (**змініть** число **змінних** за потреби). Він візьме **значення this.o**, **перетворить** його на **String** і потім **зробить** **toast** з його значення.
```bash
const/4 v10, 0x1
const/4 v11, 0x1
const/4 v12, 0x1
iget v10, p0, Lcom/google/ctf/shallweplayagame/GameActivity;->o:I
invoke-static {v10}, Ljava/lang/String;->valueOf(I)Ljava/lang/String;
move-result-object v11
invoke-static {p0, v11, v12}, Landroid/widget/Toast;->makeText(Landroid/content/Context;Ljava/lang/CharSequence;I)Landroid/widget/Toast;
move-result-object v12
invoke-virtual {v12}, Landroid/widget/Toast;->show()V
```
### Loading a Native Library at Startup (System.loadLibrary)

Іноді потрібно заздалегідь завантажити native library, щоб вона ініціалізувалася до інших JNI libs (наприклад, щоб увімкнути process-local telemetry/logging). Ви можете впровадити виклик System.loadLibrary() у статичний ініціалізатор або на ранньому етапі Application.onCreate(). Приклад smali для статичного ініціалізатора класу (<clinit>):
```smali
.class public Lcom/example/App;
.super Landroid/app/Application;

.method static constructor <clinit>()V
.registers 1
const-string v0, "sotap"         # library name without lib...so prefix
invoke-static {v0}, Ljava/lang/System;->loadLibrary(Ljava/lang/String;)V
return-void
.end method
```
Альтернативно, помістіть ті самі дві інструкції на початку вашого Application.onCreate(), щоб гарантувати, що бібліотека завантажується якомога раніше:
```smali
.method public onCreate()V
.locals 1

const-string v0, "sotap"
invoke-static {v0}, Ljava/lang/System;->loadLibrary(Ljava/lang/String;)V

invoke-super {p0}, Landroid/app/Application;->onCreate()V
return-void
.end method
```
Примітки:
- Переконайтеся, що правильний ABI-варіант бібліотеки існує під lib/<abi>/ (наприклад, arm64-v8a/armeabi-v7a), щоб уникнути UnsatisfiedLinkError.
- Раннє завантаження (class static initializer) гарантує, що native logger зможе спостерігати подальшу активність JNI.

## Посилання

- SoTap: Легкий in-app JNI (.so) логер поведінки – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)

{{#include ../../banners/hacktricks-training.md}}
