# Smali - Decompilieren/[Modifizieren]/Kompilieren

{{#include ../../banners/hacktricks-training.md}}


Manchmal ist es interessant, den Anwendungscode zu modifizieren, um für dich auf versteckte Informationen zuzugreifen (z. B. stark obfuskierte Passwörter oder Flags). Dann kann es sinnvoll sein, die apk zu dekompilieren, den Code zu ändern und sie wieder zu kompilieren.

**Opcodes-Referenz:** [http://pallergabor.uw.hu/androidblog/dalvik_opcodes.html](http://pallergabor.uw.hu/androidblog/dalvik_opcodes.html)

## Schnelle Methode

Mit **Visual Studio Code** und der Erweiterung [APKLab](https://github.com/APKLab/APKLab) kannst du die Anwendung **automatisch dekompilieren**, ändern, **wieder kompilieren**, signieren und installieren, ohne einen Befehl auszuführen.

Ein weiteres **Skript**, das diese Aufgabe stark erleichtert, ist [**https://github.com/ax/apk.sh**](https://github.com/ax/apk.sh)

## APK dekompilieren

Mit APKTool kannst du auf die **smali code and resources** zugreifen:
```bash
apktool d APP.apk
```
Wenn **apktool** einen Fehler ausgibt, versuche[ die **neueste Version** zu installieren](https://ibotpeaches.github.io/Apktool/install/)

Einige **interessante Dateien, die du dir ansehen solltest, sind**:

- _res/values/strings.xml_ (und alle XML-Dateien in res/values/*)
- _AndroidManifest.xml_
- Jede Datei mit der Erweiterung _.sqlite_ oder _.db_

Wenn `apktool` **Probleme beim Dekodieren der Anwendung** hat, siehe [https://ibotpeaches.github.io/Apktool/documentation/#framework-files] oder versuche das Argument **`-r`** zu verwenden (Ressourcen nicht dekompilieren). Dann, wenn das Problem in einer Ressource und nicht im Quellcode lag, wirst du das Problem nicht haben (du wirst die Ressourcen auch nicht dekompilieren).

## Smali-Code ändern

Du kannst **Anweisungen** ändern, den **Wert** einiger Variablen ändern oder neue Anweisungen **hinzufügen**. Ich ändere den Smali-Code mit [**VS Code**](https://code.visualstudio.com), anschließend installierst du die **smalise extension** und der Editor zeigt dir, ob eine **Anweisung inkorrekt ist**.\
Einige **Beispiele** findest du hier:

- [Smali changes examples](smali-changes.md)
- [Google CTF 2018 - Shall We Play a Game?](google-ctf-2018-shall-we-play-a-game.md)

Or you can [**check below some Smali changes explained**](smali-changes.md#modifying-smali).

## APK neu kompilieren

Nach dem Ändern des Codes kannst du den Code mit folgendem Befehl **neu kompilieren**:
```bash
apktool b . #In the folder generated when you decompiled the application
```
Die neue APK wird **kompiliert** **innerhalb** des _**dist**_ Ordners.

Wenn **apktool** einen **Fehler** wirft, versuche[ installing the **latest version**](https://ibotpeaches.github.io/Apktool/install/)

### **Signiere die neue APK**

Dann musst du einen **key generieren** (du wirst nach einem Passwort und einigen Informationen gefragt, die du zufällig ausfüllen kannst):
```bash
keytool -genkey -v -keystore key.jks -keyalg RSA -keysize 2048 -validity 10000 -alias <your-alias>
```
Schließlich, **signiere** die neue APK:
```bash
jarsigner -keystore key.jks path/to/dist/* <your-alias>
```
### Neue Anwendung optimieren

**zipalign** ist ein Tool zur Ausrichtung von Archiven, das wichtige Optimierungen für Android-Anwendungsdateien (APK) bereitstellt. [Weitere Informationen](https://developer.android.com/studio/command-line/zipalign).
```bash
zipalign [-f] [-v] <alignment> infile.apk outfile.apk
zipalign -v 4 infile.apk
```
### **Die neue APK signieren (nochmal?)**

Wenn du **lieber** [**apksigner**](https://developer.android.com/studio/command-line/) statt jarsigner verwendest, **solltest du die APK signieren** nachdem du **die Optimierung mit** zipaling angewendet hast. ABER BEACHTE, DASS DU DIE ANWENDUNG NUR EINMAL MIT jarsigner (vor zipalign) ODER MIT aspsigner (nach zipaling) SIGNIEREN MUSST.
```bash
apksigner sign --ks key.jks ./dist/mycompiled.apk
```
## Smali ändern

Für den folgenden Hello-World-Java-Code:
```java
public static void printHelloWorld() {
System.out.println("Hello World")
}
```
Der Smali-Code wäre:
```java
.method public static printHelloWorld()V
.registers 2
sget-object v0, Ljava/lang/System;->out:Ljava/io/PrintStream;
const-string v1, "Hello World"
invoke-virtual {v0,v1}, Ljava/io/PrintStream;->println(Ljava/lang/String;)V
return-void
.end method
```
Der Smali-Instruktionssatz ist verfügbar [here](https://source.android.com/devices/tech/dalvik/dalvik-bytecode#instructions).

### Leichte Änderungen

### Ändern der Anfangswerte einer Variable innerhalb einer Funktion

Einige Variablen werden am Anfang der Funktion mit dem Opcode _const_ definiert, du kannst ihre Werte ändern oder neue definieren:
```bash
#Number
const v9, 0xf4240
const/4 v8, 0x1
#Strings
const-string v5, "wins"
```
### Grundlegende Operationen
```bash
#Math
add-int/lit8 v0, v2, 0x1 #v2 + 0x1 and save it in v0
mul-int v0,v2,0x2 #v2*0x2 and save in v0

#Move the value of one object into another
move v1,v2

#Condtions
if-ge #Greater or equals
if-le #Less or equals
if-eq #Equals

#Get/Save attributes of an object
iget v0, p0, Lcom/google/ctf/shallweplayagame/GameActivity;->o:I #Save this.o inside v0
iput v0, p0, Lcom/google/ctf/shallweplayagame/GameActivity;->o:I #Save v0 inside this.o

#goto
:goto_6 #Declare this where you want to start a loop
if-ne v0, v9, :goto_6 #If not equals, go to: :goto_6
goto :goto_6 #Always go to: :goto_6
```
### Größere Änderungen

### Protokollierung
```bash
#Log win: <number>
iget v5, p0, Lcom/google/ctf/shallweplayagame/GameActivity;->o:I #Get this.o inside v5
invoke-static {v5}, Ljava/lang/String;->valueOf(I)Ljava/lang/String; #Transform number to String
move-result-object v1 #Move to v1
const-string v5, "wins" #Save "win" inside v5
invoke-static {v5, v1}, Landroid/util/Log;->d(Ljava/lang/String;Ljava/lang/String;)I #Logging "Wins: <num>"
```
Empfehlungen:

- Wenn du deklarierte Variablen innerhalb der Funktion verwenden willst (deklariert v0,v1,v2...) füge diese Zeilen zwischen der _.local <number>_ und den Deklarationen der Variablen (_const v0, 0x1_) ein
- Wenn du den Logging-Code in die Mitte des Codes einer Funktion einfügen willst:
- Erhöhe die Anzahl der deklarierten Variablen um 2: z.B. von _.locals 10_ auf _.locals 12_
- Die neuen Variablen sollten die nächsten Nummern nach den bereits deklarierten Variablen sein (in diesem Beispiel sollten es _v10_ und _v11_ sein, denke daran, dass bei v0 begonnen wird).
- Ändere den Code der Logging-Funktion und verwende _v10_ und _v11_ statt _v5_ und _v1_.

### Toasting

Denke daran, am Anfang der Funktion 3 zu der Anzahl der _.locals_ hinzuzufügen.

Dieser Code ist dafür vorbereitet, in die **Mitte einer Funktion** eingefügt zu werden (**ändere** die Anzahl der **Variablen** nach Bedarf). Er nimmt den **Wert von this.o**, **wandelt** ihn in einen **String** und erstellt anschließend einen **toast** mit dessen Wert.
```bash
const/4 v10, 0x1
const/4 v11, 0x1
const/4 v12, 0x1
iget v10, p0, Lcom/google/ctf/shallweplayagame/GameActivity;->o:I
invoke-static {v10}, Ljava/lang/String;->valueOf(I)Ljava/lang/String;
move-result-object v11
invoke-static {p0, v11, v12}, Landroid/widget/Toast;->makeText(Landroid/content/Context;Ljava/lang/CharSequence;I)Landroid/widget/Toast;
move-result-object v12
invoke-virtual {v12}, Landroid/widget/Toast;->show()V
```
### Laden einer nativen Bibliothek beim Start (System.loadLibrary)

Manchmal muss man eine native Bibliothek vorgeladen, damit sie sich vor anderen JNI-Libs initialisiert (z. B. um prozesslokale Telemetrie/Logging zu ermöglichen). Man kann einen Aufruf von System.loadLibrary() in einen statischen Initialisierer oder früh in Application.onCreate() injizieren. Beispiel smali für einen statischen Klassen-Initializer (<clinit>):
```smali
.class public Lcom/example/App;
.super Landroid/app/Application;

.method static constructor <clinit>()V
.registers 1
const-string v0, "sotap"         # library name without lib...so prefix
invoke-static {v0}, Ljava/lang/System;->loadLibrary(Ljava/lang/String;)V
return-void
.end method
```
Alternativ platzieren Sie dieselben beiden Anweisungen am Anfang Ihrer Application.onCreate(), um sicherzustellen, dass die library so früh wie möglich geladen wird:
```smali
.method public onCreate()V
.locals 1

const-string v0, "sotap"
invoke-static {v0}, Ljava/lang/System;->loadLibrary(Ljava/lang/String;)V

invoke-super {p0}, Landroid/app/Application;->onCreate()V
return-void
.end method
```
Hinweise:
- Stellen Sie sicher, dass die korrekte ABI-Variante der Bibliothek unter lib/<abi>/ vorhanden ist (z. B. arm64-v8a/armeabi-v7a), um UnsatisfiedLinkError zu vermeiden.
- Frühes Laden (class static initializer) garantiert, dass der native logger nachfolgende JNI-Aktivität beobachten kann.

## Referenzen

- SoTap: Leichtgewichtiger in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)

{{#include ../../banners/hacktricks-training.md}}
