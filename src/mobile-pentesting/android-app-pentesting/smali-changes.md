# Smali - Decompilando/[Modificando]/Compilando

{{#include ../../banners/hacktricks-training.md}}


Às vezes é interessante modificar o código da aplicação para acessar informações ocultas para você (talvez senhas bem ofuscadas ou flags). Então, pode ser interessante decompilar o apk, modificar o código e recompilá-lo.

**Referência de opcodes:** [http://pallergabor.uw.hu/androidblog/dalvik_opcodes.html](http://pallergabor.uw.hu/androidblog/dalvik_opcodes.html)

## Maneira Rápida

Usando **Visual Studio Code** e a extensão [APKLab](https://github.com/APKLab/APKLab), você pode **decompilar automaticamente**, modificar, **recompilar**, assinar e instalar o aplicativo sem executar nenhum comando.

Outro **script** que facilita muito essa tarefa é [**https://github.com/ax/apk.sh**](https://github.com/ax/apk.sh)

## Decompilar o APK

Usando APKTool você pode acessar o **smali code and resources**:
```bash
apktool d APP.apk
```
Se **apktool** lhe der algum erro, tente[ installing the **latest version**](https://ibotpeaches.github.io/Apktool/install/)

Alguns **arquivos interessantes que você deve verificar são**:

- _res/values/strings.xml_ (e todos os xmls dentro de res/values/*)
- _AndroidManifest.xml_
- Qualquer arquivo com extensão _.sqlite_ ou _.db_

Se `apktool` tiver **problemas ao decodificar a aplicação** consulte [https://ibotpeaches.github.io/Apktool/documentation/#framework-files](https://ibotpeaches.github.io/Apktool/documentation/#framework-files) ou tente usar o argumento **`-r`** (Não decodificar recursos). Então, se o problema estava em um recurso e não no código-fonte, você não terá o problema (você também não decompilará os recursos).

## Alterar código smali

Você pode **alterar** **instruções**, alterar o **valor** de algumas variáveis ou **adicionar** novas instruções. Eu altero o código Smali usando [**VS Code**](https://code.visualstudio.com), em seguida instalo a **smalise extension** e o editor dirá se alguma **instrução estiver incorreta**.\
Alguns **exemplos** podem ser encontrados aqui:

- [Smali changes examples](smali-changes.md)
- [Google CTF 2018 - Shall We Play a Game?](google-ctf-2018-shall-we-play-a-game.md)

Ou você pode [**check below some Smali changes explained**](smali-changes.md#modifying-smali).

## Recompile the APK

Após modificar o código você pode **recompilar** o código usando:
```bash
apktool b . #In the folder generated when you decompiled the application
```
Ele vai **compile** o novo APK **inside** a pasta _**dist**_.

Se o **apktool** lançar um **erro**, tente[ instalar a **última versão**](https://ibotpeaches.github.io/Apktool/install/)

### **Assinar o novo APK**

Então, você precisa **gerar uma chave** (será solicitado uma senha e algumas informações que você pode preencher aleatoriamente):
```bash
keytool -genkey -v -keystore key.jks -keyalg RSA -keysize 2048 -validity 10000 -alias <your-alias>
```
Finalmente, **assine** o novo APK:
```bash
jarsigner -keystore key.jks path/to/dist/* <your-alias>
```
### Otimizar nova aplicação

**zipalign** é uma ferramenta de alinhamento de arquivos que otimiza arquivos de aplicações Android (APK). [More information here](https://developer.android.com/studio/command-line/zipalign).
```bash
zipalign [-f] [-v] <alignment> infile.apk outfile.apk
zipalign -v 4 infile.apk
```
### **Assinar o novo APK (de novo?)**

Se você **prefere** usar [**apksigner**](https://developer.android.com/studio/command-line/) em vez de jarsigner, **você deve assinar o apk** depois de aplicar **a otimização com** zipaling. MAS NOTE QUE VOCÊ SÓ PRECISA **ASSINAR A APLICAÇÃO UMA VEZ** COM jarsigner (antes do zipalign) OU COM aspsigner (após zipaling).
```bash
apksigner sign --ks key.jks ./dist/mycompiled.apk
```
## Modificando Smali

Para o seguinte código Java Hello World:
```java
public static void printHelloWorld() {
System.out.println("Hello World")
}
```
O código Smali seria:
```java
.method public static printHelloWorld()V
.registers 2
sget-object v0, Ljava/lang/System;->out:Ljava/io/PrintStream;
const-string v1, "Hello World"
invoke-virtual {v0,v1}, Ljava/io/PrintStream;->println(Ljava/lang/String;)V
return-void
.end method
```
The Smali instruction set is available [aqui](https://source.android.com/devices/tech/dalvik/dalvik-bytecode#instructions).

### Alterações leves

### Modificar valores iniciais de uma variável dentro de uma função

Algumas variáveis são definidas no início da função usando o opcode _const_, você pode modificar seus valores, ou pode definir novas:
```bash
#Number
const v9, 0xf4240
const/4 v8, 0x1
#Strings
const-string v5, "wins"
```
### Operações Básicas
```bash
#Math
add-int/lit8 v0, v2, 0x1 #v2 + 0x1 and save it in v0
mul-int v0,v2,0x2 #v2*0x2 and save in v0

#Move the value of one object into another
move v1,v2

#Condtions
if-ge #Greater or equals
if-le #Less or equals
if-eq #Equals

#Get/Save attributes of an object
iget v0, p0, Lcom/google/ctf/shallweplayagame/GameActivity;->o:I #Save this.o inside v0
iput v0, p0, Lcom/google/ctf/shallweplayagame/GameActivity;->o:I #Save v0 inside this.o

#goto
:goto_6 #Declare this where you want to start a loop
if-ne v0, v9, :goto_6 #If not equals, go to: :goto_6
goto :goto_6 #Always go to: :goto_6
```
### Mudanças Maiores

### Logging
```bash
#Log win: <number>
iget v5, p0, Lcom/google/ctf/shallweplayagame/GameActivity;->o:I #Get this.o inside v5
invoke-static {v5}, Ljava/lang/String;->valueOf(I)Ljava/lang/String; #Transform number to String
move-result-object v1 #Move to v1
const-string v5, "wins" #Save "win" inside v5
invoke-static {v5, v1}, Landroid/util/Log;->d(Ljava/lang/String;Ljava/lang/String;)I #Logging "Wins: <num>"
```
Recomendações:

- Se você for usar variáveis declaradas dentro da função (declaradas v0,v1,v2...) coloque essas linhas entre _.local <number>_ e as declarações das variáveis (_const v0, 0x1_)
- Se quiser colocar o código de logging no meio do código de uma função:
- Adicione 2 ao número de variáveis declaradas: Ex: de _.locals 10_ para _.locals 12_
- As novas variáveis devem ser os próximos números das variáveis já declaradas (neste exemplo devem ser _v10_ e _v11_, lembre-se que começa em v0).
- Altere o código da função de logging e use _v10_ e _v11_ em vez de _v5_ e _v1_.

### Exibindo Toast

Lembre-se de adicionar 3 ao número de _.locals_ no início da função.

Este código está preparado para ser inserido no **meio de uma função** (**altere** o número das **variáveis** conforme necessário). Ele irá pegar o **valor de this.o**, **transformá-lo** em **String** e então **fazer** um **toast** com seu valor.
```bash
const/4 v10, 0x1
const/4 v11, 0x1
const/4 v12, 0x1
iget v10, p0, Lcom/google/ctf/shallweplayagame/GameActivity;->o:I
invoke-static {v10}, Ljava/lang/String;->valueOf(I)Ljava/lang/String;
move-result-object v11
invoke-static {p0, v11, v12}, Landroid/widget/Toast;->makeText(Landroid/content/Context;Ljava/lang/CharSequence;I)Landroid/widget/Toast;
move-result-object v12
invoke-virtual {v12}, Landroid/widget/Toast;->show()V
```
### Carregando uma Biblioteca Nativa na Inicialização (System.loadLibrary)

Às vezes você precisa pré-carregar uma biblioteca nativa para que ela seja inicializada antes de outras JNI libs (por exemplo, para habilitar process-local telemetry/logging). Você pode injetar uma chamada para System.loadLibrary() em um inicializador estático ou no início de Application.onCreate(). Exemplo smali para um inicializador estático de classe (<clinit>):
```smali
.class public Lcom/example/App;
.super Landroid/app/Application;

.method static constructor <clinit>()V
.registers 1
const-string v0, "sotap"         # library name without lib...so prefix
invoke-static {v0}, Ljava/lang/System;->loadLibrary(Ljava/lang/String;)V
return-void
.end method
```
Alternativamente, coloque as mesmas duas instruções no início do seu Application.onCreate() para garantir que a biblioteca seja carregada o mais cedo possível:
```smali
.method public onCreate()V
.locals 1

const-string v0, "sotap"
invoke-static {v0}, Ljava/lang/System;->loadLibrary(Ljava/lang/String;)V

invoke-super {p0}, Landroid/app/Application;->onCreate()V
return-void
.end method
```
Notas:
- Certifique-se de que a variante ABI correta da biblioteca exista em lib/<abi>/ (por exemplo, arm64-v8a/armeabi-v7a) para evitar UnsatisfiedLinkError.
- Carregar muito cedo (class static initializer) garante que o native logger possa observar a atividade JNI subsequente.

## Referências

- SoTap: registrador leve in-app de comportamento JNI (.so) – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)

{{#include ../../banners/hacktricks-training.md}}
