# Smali - Decompiling/[Modifying]/Compiling

{{#include ../../banners/hacktricks-training.md}}


कभी-कभी एप्लिकेशन कोड में बदलाव करके आपके लिए छिपी जानकारी तक पहुंचना दिलचस्प होता है (शायद अच्छी तरह से ऑबफ़्यूस्केट किए गए पासवर्ड या flags)। ऐसे में apk को decompile करना, कोड संशोधित करना और फिर से recompile करना उपयोगी हो सकता है।

**Opcodes reference:** [http://pallergabor.uw.hu/androidblog/dalvik_opcodes.html](http://pallergabor.uw.hu/androidblog/dalvik_opcodes.html)

## तेज़ तरीका

Using **Visual Studio Code** और [APKLab](https://github.com/APKLab/APKLab) extension का उपयोग करके, आप बिना किसी कमांड को चलाए एप्लिकेशन को **automatically decompile**, संशोधित, **recompile**, sign और install कर सकते हैं।

इस काम को काफी आसान बनाने वाला एक और **script** है [**https://github.com/ax/apk.sh**](https://github.com/ax/apk.sh)

## APK को Decompile करना

APKTool का उपयोग करके आप **smali code and resources** तक पहुँच सकते हैं:
```bash
apktool d APP.apk
```
यदि **apktool** आपको कोई त्रुटि देता है, तो [installing the **latest version**](https://ibotpeaches.github.io/Apktool/install/) आज़माएँ

कुछ **रोचक फ़ाइलें जिन्हें आपको देखना चाहिए**:

- _res/values/strings.xml_ (and all xmls inside res/values/*)
- _AndroidManifest.xml_
- Any file with extension _.sqlite_ or _.db_

यदि `apktool` को एप्लिकेशन को डिकोड करने में **समस्याएँ** हो रही हैं तो [https://ibotpeaches.github.io/Apktool/documentation/#framework-files](https://ibotpeaches.github.io/Apktool/documentation/#framework-files) देखें या तर्क **`-r`** (संसाधनों को डिकोड न करें) का उपयोग करके कोशिश करें। फिर, यदि समस्या किसी resource में थी न कि source code में, तो आपकी समस्या समाप्त हो जाएगी (आप संसाधनों को भी डिकम्पाइल नहीं करेंगे)।

## Smali कोड बदलें

आप **निर्देश** बदल सकते हैं, कुछ वेरिएबल्स के **मान** बदल सकते हैं या नए **निर्देश** जोड़ सकते हैं। मैं Smali कोड को [**VS Code**](https://code.visualstudio.com) का उपयोग करके बदलता/बदलती हूँ, फिर आप **smalise extension** इंस्टॉल करें और एडिटर बताएगा अगर कोई **निर्देश गलत** है.\  
कुछ **उदाहरण** यहाँ मिल सकते हैं:

- [Smali changes examples](smali-changes.md)
- [Google CTF 2018 - Shall We Play a Game?](google-ctf-2018-shall-we-play-a-game.md)

या आप [**check below some Smali changes explained**](smali-changes.md#modifying-smali) देख सकते हैं।

## APK को पुनः संकलित करें

कोड में बदलाव करने के बाद आप निम्न का उपयोग करके कोड को **पुनः संकलित** कर सकते हैं:
```bash
apktool b . #In the folder generated when you decompiled the application
```
यह नया APK _**dist**_ फ़ोल्डर के **inside** में **compile** करेगा।

यदि **apktool** कोई **error** फेंकता है, तो try [installing the **latest version**](https://ibotpeaches.github.io/Apktool/install/) करें।

### **नए APK को Sign करें**

फिर, आपको **generate a key** करने की ज़रूरत होगी (आपसे एक password और कुछ जानकारी के बारे में पूछा जाएगा जिन्हें आप randomly भर सकते हैं):
```bash
keytool -genkey -v -keystore key.jks -keyalg RSA -keysize 2048 -validity 10000 -alias <your-alias>
```
अंत में, नए APK को **sign** करें:
```bash
jarsigner -keystore key.jks path/to/dist/* <your-alias>
```
### नई एप्लिकेशन को अनुकूलित करें

**zipalign** एक आर्काइव संरेखण उपकरण है जो Android एप्लिकेशन (APK) फ़ाइलों के लिए महत्वपूर्ण अनुकूलन प्रदान करता है। [More information here](https://developer.android.com/studio/command-line/zipalign).
```bash
zipalign [-f] [-v] <alignment> infile.apk outfile.apk
zipalign -v 4 infile.apk
```
### **Sign the new APK (again?)**

अगर आप [**apksigner**](https://developer.android.com/studio/command-line/) का उपयोग jarsigner की जगह करना पसंद करते हैं, तो zipaling के साथ optimization लागू करने के बाद आपको **apk को sign करना चाहिए**। लेकिन ध्यान दें कि आपको केवल एक बार ही jarsigner के साथ (zipalign से पहले) या aspsigner के साथ (zipaling के बाद) **APPLICATION को SIGN करना होता है**।
```bash
apksigner sign --ks key.jks ./dist/mycompiled.apk
```
## Smali को संशोधित करना

निम्नलिखित Hello World Java कोड के लिए:
```java
public static void printHelloWorld() {
System.out.println("Hello World")
}
```
Smali कोड इस प्रकार होगा:
```java
.method public static printHelloWorld()V
.registers 2
sget-object v0, Ljava/lang/System;->out:Ljava/io/PrintStream;
const-string v1, "Hello World"
invoke-virtual {v0,v1}, Ljava/io/PrintStream;->println(Ljava/lang/String;)V
return-void
.end method
```
Smali instruction set इस लिंक पर उपलब्ध है [here](https://source.android.com/devices/tech/dalvik/dalvik-bytecode#instructions).

### हल्के बदलाव

### फ़ंक्शन के अंदर एक वेरिएबल के प्रारम्भिक मान बदलें

कुछ वेरिएबल फ़ंक्शन की शुरुआत में opcode _const_ का उपयोग करके परिभाषित होते हैं, आप उनके मानों को संशोधित कर सकते हैं, या आप नए मान परिभाषित कर सकते हैं:
```bash
#Number
const v9, 0xf4240
const/4 v8, 0x1
#Strings
const-string v5, "wins"
```
### बुनियादी संचालन
```bash
#Math
add-int/lit8 v0, v2, 0x1 #v2 + 0x1 and save it in v0
mul-int v0,v2,0x2 #v2*0x2 and save in v0

#Move the value of one object into another
move v1,v2

#Condtions
if-ge #Greater or equals
if-le #Less or equals
if-eq #Equals

#Get/Save attributes of an object
iget v0, p0, Lcom/google/ctf/shallweplayagame/GameActivity;->o:I #Save this.o inside v0
iput v0, p0, Lcom/google/ctf/shallweplayagame/GameActivity;->o:I #Save v0 inside this.o

#goto
:goto_6 #Declare this where you want to start a loop
if-ne v0, v9, :goto_6 #If not equals, go to: :goto_6
goto :goto_6 #Always go to: :goto_6
```
### बड़े परिवर्तन

### लॉगिंग
```bash
#Log win: <number>
iget v5, p0, Lcom/google/ctf/shallweplayagame/GameActivity;->o:I #Get this.o inside v5
invoke-static {v5}, Ljava/lang/String;->valueOf(I)Ljava/lang/String; #Transform number to String
move-result-object v1 #Move to v1
const-string v5, "wins" #Save "win" inside v5
invoke-static {v5, v1}, Landroid/util/Log;->d(Ljava/lang/String;Ljava/lang/String;)I #Logging "Wins: <num>"
```
सिफारिशें:

- यदि आप फ़ंक्शन के अंदर घोषित वेरिएबल्स (v0, v1, v2...) का उपयोग करने जा रहे हैं, तो इन लाइनों को _.local <number>_ और वेरिएबल्स की घोषणाओं (_const v0, 0x1_) के बीच रखें।
- यदि आप फ़ंक्शन के कोड के बीच में logging code रखना चाहते हैं:
- घोषित वेरिएबल्स की संख्या में 2 जोड़ें: उदाहरण: _.locals 10_ से _.locals 12_
- नए वेरिएबल्स पहले से घोषित वेरिएबल्स की अगली संख्याएँ होने चाहिए (इस उदाहरण में ये _v10_ और _v11_ होने चाहिए, याद रखें कि यह v0 से शुरू होता है)।
- logging function के कोड को बदलें और _v10_ और _v11_ का उपयोग _v5_ और _v1_ की जगह करें।

### Toast दिखाना

याद रखें कि फ़ंक्शन की शुरुआत में _.locals_ की संख्या में 3 जोड़ें।

यह कोड **फ़ंक्शन के बीच** में डालने के लिए तैयार किया गया है (ज़रूरत अनुसार **variables** की संख्या **change** करें)। यह **this.o के value** को लेगा, उसे **String** में **transform** करेगा और उसके मान के साथ एक **toast** बनाएगा।
```bash
const/4 v10, 0x1
const/4 v11, 0x1
const/4 v12, 0x1
iget v10, p0, Lcom/google/ctf/shallweplayagame/GameActivity;->o:I
invoke-static {v10}, Ljava/lang/String;->valueOf(I)Ljava/lang/String;
move-result-object v11
invoke-static {p0, v11, v12}, Landroid/widget/Toast;->makeText(Landroid/content/Context;Ljava/lang/CharSequence;I)Landroid/widget/Toast;
move-result-object v12
invoke-virtual {v12}, Landroid/widget/Toast;->show()V
```
### स्टार्टअप पर Native Library लोड करना (System.loadLibrary)

कभी-कभी आपको एक native लाइब्रेरी को पहले से लोड करना पड़ता है ताकि यह अन्य JNI लाइब्रेरीज़ से पहले इनिशियलाइज़ हो जाए (उदा., प्रोसेस-लोकल telemetry/logging सक्षम करने के लिए)। आप static initializer में या Application.onCreate() में जल्दी System.loadLibrary() कॉल इंजेक्ट कर सकते हैं। static class initializer (<clinit>) के लिए उदाहरण smali:
```smali
.class public Lcom/example/App;
.super Landroid/app/Application;

.method static constructor <clinit>()V
.registers 1
const-string v0, "sotap"         # library name without lib...so prefix
invoke-static {v0}, Ljava/lang/System;->loadLibrary(Ljava/lang/String;)V
return-void
.end method
```
वैकल्पिक रूप से, लाइब्रेरी जितनी जल्दी संभव हो लोड हो यह सुनिश्चित करने के लिए अपने Application.onCreate() की शुरुआत में वही दो निर्देश रखें:
```smali
.method public onCreate()V
.locals 1

const-string v0, "sotap"
invoke-static {v0}, Ljava/lang/System;->loadLibrary(Ljava/lang/String;)V

invoke-super {p0}, Landroid/app/Application;->onCreate()V
return-void
.end method
```
नोट्स:
- सुनिश्चित करें कि लाइब्रेरी का सही ABI वेरिएंट lib/<abi>/ (उदा., arm64-v8a/armeabi-v7a) के अंतर्गत मौजूद हो ताकि UnsatisfiedLinkError से बचा जा सके।
- बहुत जल्दी लोड करने पर (class static initializer) यह सुनिश्चित होता है कि native logger बाद की JNI गतिविधि को देख सके।

## संदर्भ

- SoTap: हल्का-फुल्का इन-ऐप JNI (.so) व्यवहार लॉगर – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)

{{#include ../../banners/hacktricks-training.md}}
