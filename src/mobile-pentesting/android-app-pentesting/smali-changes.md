# Smali - Dekompajliranje/[Modifikovanje]/Kompajliranje

{{#include ../../banners/hacktricks-training.md}}


Ponekad je zanimljivo izmeniti kod aplikacije kako biste pristupili skrivenim informacijama (možda dobro obfuskovanim lozinkama ili flagovima). Tada može biti korisno dekompajlirati apk, izmeniti kod i ponovo ga kompajlirati.

**Opcodes referenca:** [http://pallergabor.uw.hu/androidblog/dalvik_opcodes.html](http://pallergabor.uw.hu/androidblog/dalvik_opcodes.html)

## Brzi način

Koristeći **Visual Studio Code** i ekstenziju [APKLab](https://github.com/APKLab/APKLab), možete **automatski dekompajlirati**, izmeniti, **ponovo kompajlirati**, potpisati i instalirati aplikaciju bez izvršavanja bilo kakve naredbe.

Još jedna **skripta** koja uveliko olakšava ovaj zadatak je [**https://github.com/ax/apk.sh**](https://github.com/ax/apk.sh)

## Dekompajliranje APK-a

Koristeći APKTool, možete pristupiti **smali code and resources**:
```bash
apktool d APP.apk
```
Ako **apktool** gives you any error, try[ installing the **latest version**](https://ibotpeaches.github.io/Apktool/install/)

Neke **zanimljive datoteke koje bi trebalo da pogledate su**:

- _res/values/strings.xml_ (and all xmls inside res/values/*)
- _AndroidManifest.xml_
- Any file with extension _.sqlite_ or _.db_

Ako `apktool` ima **problema pri dekodiranju aplikacije** pogledajte [https://ibotpeaches.github.io/Apktool/documentation/#framework-files](https://ibotpeaches.github.io/Apktool/documentation/#framework-files) ili pokušajte koristiti argument **`-r`** (Ne dekodirajte resurse). Ako je problem bio u resursu, a ne u izvornom kodu, više nećete imati problem (takođe nećete dekompilovati resurse).

## Menjanje smali koda

Možete **menjati** instrukcije, menjati **vrednost** nekih promenljivih ili **dodavati** nove instrukcije. Ja menjam smali kod koristeći [**VS Code**](https://code.visualstudio.com), zatim instalirajte **smalise extension** i editor će vam reći ako je neka **instrukcija netačna**.\
Neke **primere** možete naći ovde:

- [Smali changes examples](smali-changes.md)
- [Google CTF 2018 - Shall We Play a Game?](google-ctf-2018-shall-we-play-a-game.md)

Ili možete [**check below some Smali changes explained**](smali-changes.md#modifying-smali).

## Rekompajlirajte APK

Nakon izmena koda možete **rekompajlirati** kod koristeći:
```bash
apktool b . #In the folder generated when you decompiled the application
```
Ovo će **kompajlirati** novi APK **unutar** _**dist**_ foldera.

Ako **apktool** izbaci **grešku**, pokušajte [instalirati **najnoviju verziju**](https://ibotpeaches.github.io/Apktool/install/)

### **Potpišite novi APK**

Zatim, potrebno je da **generišete ključ** (bićete upitani za lozinku i neke informacije koje možete popuniti nasumično):
```bash
keytool -genkey -v -keystore key.jks -keyalg RSA -keysize 2048 -validity 10000 -alias <your-alias>
```
Na kraju, **potpišite** novi APK:
```bash
jarsigner -keystore key.jks path/to/dist/* <your-alias>
```
### Optimizacija nove aplikacije

**zipalign** je alat za poravnavanje arhiva koji pruža važnu optimizaciju Android APK fajlova. [More information here](https://developer.android.com/studio/command-line/zipalign).
```bash
zipalign [-f] [-v] <alignment> infile.apk outfile.apk
zipalign -v 4 infile.apk
```
### **Potpišite novi APK (opet?)**

Ako **više volite** da koristite [**apksigner**](https://developer.android.com/studio/command-line/) umesto jarsigner, **trebalo bi da potpišete apk** nakon primene **optimizacije pomoću** zipaling. ALI OBRATITE PAŽNJU DA JE POTREBNO POTPISATI **APLIKACIJU SAMO JEDNOM** KORIŠĆENJEM jarsigner (pre zipalign) ILI KORIŠĆENJEM aspsigner (posle zipaling).
```bash
apksigner sign --ks key.jks ./dist/mycompiled.apk
```
## Modifying Smali

Za sledeći Hello World Java kod:
```java
public static void printHelloWorld() {
System.out.println("Hello World")
}
```
Smali code bi bio:
```java
.method public static printHelloWorld()V
.registers 2
sget-object v0, Ljava/lang/System;->out:Ljava/io/PrintStream;
const-string v1, "Hello World"
invoke-virtual {v0,v1}, Ljava/io/PrintStream;->println(Ljava/lang/String;)V
return-void
.end method
```
Skup instrukcija Smali je dostupan [here](https://source.android.com/devices/tech/dalvik/dalvik-bytecode#instructions).

### Male izmene

### Izmenite početne vrednosti promenljive unutar funkcije

Neke promenljive su definisane na početku funkcije koristeći opcode _const_, možete izmeniti njihove vrednosti, ili možete definisati nove:
```bash
#Number
const v9, 0xf4240
const/4 v8, 0x1
#Strings
const-string v5, "wins"
```
### Osnovne operacije
```bash
#Math
add-int/lit8 v0, v2, 0x1 #v2 + 0x1 and save it in v0
mul-int v0,v2,0x2 #v2*0x2 and save in v0

#Move the value of one object into another
move v1,v2

#Condtions
if-ge #Greater or equals
if-le #Less or equals
if-eq #Equals

#Get/Save attributes of an object
iget v0, p0, Lcom/google/ctf/shallweplayagame/GameActivity;->o:I #Save this.o inside v0
iput v0, p0, Lcom/google/ctf/shallweplayagame/GameActivity;->o:I #Save v0 inside this.o

#goto
:goto_6 #Declare this where you want to start a loop
if-ne v0, v9, :goto_6 #If not equals, go to: :goto_6
goto :goto_6 #Always go to: :goto_6
```
### Veće promene

### Logovanje
```bash
#Log win: <number>
iget v5, p0, Lcom/google/ctf/shallweplayagame/GameActivity;->o:I #Get this.o inside v5
invoke-static {v5}, Ljava/lang/String;->valueOf(I)Ljava/lang/String; #Transform number to String
move-result-object v1 #Move to v1
const-string v5, "wins" #Save "win" inside v5
invoke-static {v5, v1}, Landroid/util/Log;->d(Ljava/lang/String;Ljava/lang/String;)I #Logging "Wins: <num>"
```
Preporuke:

- Ako ćete koristiti deklarisane promenljive unutar funkcije (deklarisane v0,v1,v2...) stavite ove linije između _.local <number>_ i deklaracija promenljivih (_const v0, 0x1_)
- Ako želite da ubacite logging kod u sredinu koda funkcije:
- Dodajte 2 broju deklarisanih promenljivih: npr: od _.locals 10_ do _.locals 12_
- Nove promenljive treba da budu naredni brojevi postojećih deklarisanih promenljivih (u ovom primeru to treba da budu _v10_ i _v11_, zapamtite da se broji od v0).
- Promenite kod logging funkcije i koristite _v10_ i _v11_ umesto _v5_ i _v1_.

### Toasting

Zapamtite da dodate 3 broju _.locals_ na početku funkcije.

Ovaj kod je pripremljen da bude umetnut u **sredinu funkcije** (**promenite** broj **promenljivih** po potrebi). Uzeće **vrednost this.o**, **pretvoriće** je u **String** i zatim **prikazati** **toast** sa tom vrednošću.
```bash
const/4 v10, 0x1
const/4 v11, 0x1
const/4 v12, 0x1
iget v10, p0, Lcom/google/ctf/shallweplayagame/GameActivity;->o:I
invoke-static {v10}, Ljava/lang/String;->valueOf(I)Ljava/lang/String;
move-result-object v11
invoke-static {p0, v11, v12}, Landroid/widget/Toast;->makeText(Landroid/content/Context;Ljava/lang/CharSequence;I)Landroid/widget/Toast;
move-result-object v12
invoke-virtual {v12}, Landroid/widget/Toast;->show()V
```
### Loading a Native Library at Startup (System.loadLibrary)

Ponekad treba prethodno učitati native biblioteku tako da se inicijalizuje pre drugih JNI libs (npr. da bi se omogućila process-local telemetry/logging). Možete ubaciti poziv System.loadLibrary() u static initializer ili rano u Application.onCreate(). Primer smali za static class initializer (<clinit>):
```smali
.class public Lcom/example/App;
.super Landroid/app/Application;

.method static constructor <clinit>()V
.registers 1
const-string v0, "sotap"         # library name without lib...so prefix
invoke-static {v0}, Ljava/lang/System;->loadLibrary(Ljava/lang/String;)V
return-void
.end method
```
Alternativno, postavite ista dva uputstva na početak vašeg Application.onCreate() kako biste osigurali da se biblioteka učita što ranije:
```smali
.method public onCreate()V
.locals 1

const-string v0, "sotap"
invoke-static {v0}, Ljava/lang/System;->loadLibrary(Ljava/lang/String;)V

invoke-super {p0}, Landroid/app/Application;->onCreate()V
return-void
.end method
```
Napomene:
- Uverite se da odgovarajuća ABI varijanta biblioteke postoji pod lib/<abi>/ (npr. arm64-v8a/armeabi-v7a) kako biste izbegli UnsatisfiedLinkError.
- Učitavanje veoma rano (class static initializer) garantuje da native logger može da posmatra naknadnu JNI aktivnost.

## References

- SoTap: Lagan in-app JNI (.so) logger ponašanja – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)

{{#include ../../banners/hacktricks-training.md}}
