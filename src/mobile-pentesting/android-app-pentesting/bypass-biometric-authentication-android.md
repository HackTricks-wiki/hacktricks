# 绕过生物识别认证（Android）

{{#include ../../banners/hacktricks-training.md}}

## **方法 1 – 无加密对象使用的绕过**

这里的重点是 _onAuthenticationSucceeded_ 回调，它在认证过程中至关重要。WithSecure的研究人员开发了一个 [Frida 脚本](https://github.com/WithSecureLABS/android-keystore-audit/blob/master/frida-scripts/fingerprint-bypass.js)，使得可以绕过 _onAuthenticationSucceeded(...)_ 中的 NULL _CryptoObject_。该脚本在方法调用时强制自动绕过指纹认证。下面是一个简化的代码片段，演示了在 Android 指纹上下文中的绕过，完整应用程序可在 [GitHub](https://github.com/St3v3nsS/InsecureBanking) 上获取。
```javascript
biometricPrompt = new BiometricPrompt(this, executor, new BiometricPrompt.AuthenticationCallback() {
@Override
public void onAuthenticationSucceeded(@NonNull BiometricPrompt.AuthenticationResult result) {
Toast.makeText(MainActivity.this,"Success",Toast.LENGTH_LONG).show();
}
});
```
运行 Frida 脚本的命令：
```bash
frida -U -f com.generic.insecurebankingfingerprint --no-pause -l fingerprint-bypass.js
```
## **方法 2 – 异常处理方法**

另一个 [Frida 脚本](https://github.com/WithSecureLABS/android-keystore-audit/blob/master/frida-scripts/fingerprint-bypass-via-exception-handling.js) 由 WithSecure 提供，旨在绕过不安全的加密对象使用。该脚本调用 _onAuthenticationSucceeded_，并使用未通过指纹授权的 _CryptoObject_。如果应用程序尝试使用不同的密码对象，将会触发异常。该脚本准备调用 _onAuthenticationSucceeded_ 并处理 _javax.crypto.IllegalBlockSizeException_，确保应用程序后续使用的对象使用新密钥进行加密。

运行 Frida 脚本的命令：
```bash
frida -U -f com.generic.insecurebankingfingerprint --no-pause -l fingerprint-bypass-via-exception-handling.js
```
在到达指纹屏幕并启动 `authenticate()` 时，在 Frida 控制台中输入 `bypass()` 以激活绕过：
```
Spawning com.generic.insecurebankingfingerprint...
[Android Emulator 5554::com.generic.insecurebankingfingerprint]-> Hooking BiometricPrompt.authenticate()...
Hooking BiometricPrompt.authenticate2()...
Hooking FingerprintManager.authenticate()...
[Android Emulator 5554::com.generic.insecurebankingfingerprint]-> bypass()
```
## **方法 3 – 插桩框架**

插桩框架如 Xposed 或 Frida 可用于在运行时钩住应用程序方法。对于指纹认证，这些框架可以：

1. **模拟认证回调**：通过钩住 `BiometricPrompt.AuthenticationCallback` 的 `onAuthenticationSucceeded`、`onAuthenticationFailed` 或 `onAuthenticationError` 方法，您可以控制指纹认证过程的结果。
2. **绕过 SSL 钉扎**：这允许攻击者拦截和修改客户端与服务器之间的流量，可能改变认证过程或窃取敏感数据。

Frida 的示例命令：
```bash
frida -U -l script-to-bypass-authentication.js --no-pause -f com.generic.in
```
## **方法 4 – 逆向工程与代码修改**

逆向工程工具如 `APKTool`、`dex2jar` 和 `JD-GUI` 可用于反编译 Android 应用程序，阅读其源代码并理解其身份验证机制。步骤通常包括：

1. **反编译 APK**：将 APK 文件转换为更易读的格式（如 Java 代码）。
2. **分析代码**：查找指纹身份验证的实现并识别潜在的弱点（如后备机制或不当的验证检查）。
3. **重新编译 APK**：在修改代码以绕过指纹身份验证后，应用程序被重新编译、签名并安装到设备上进行测试。

## **方法 5 – 使用自定义身份验证工具**

有专门的工具和脚本设计用于测试和绕过身份验证机制。例如：

1. **MAGISK 模块**：MAGISK 是一个 Android 工具，允许用户获取设备的 root 权限并添加可以修改或伪造硬件级信息（包括指纹）的模块。
2. **自定义脚本**：可以编写脚本与 Android 调试桥（ADB）或直接与应用程序的后端交互，以模拟或绕过指纹身份验证。

---

## **方法 6 – 针对 `BiometricPrompt` 的通用 Frida Hook（API 28-34）**

在 2023 年，一个名为 **Universal-Android-Biometric-Bypass** 的社区 Frida 脚本出现在 CodeShare 上。该脚本钩住了 `BiometricPrompt.authenticate()` 的每个重载以及遗留的 `FingerprintManager.authenticate()`，并直接触发 `onAuthenticationSucceeded()`，带有一个 **伪造的 `AuthenticationResult`，其中包含一个空的 `CryptoObject`**。由于它动态适应 API 级别，如果目标应用程序对返回的 `CryptoObject` **没有进行加密检查**，它仍然可以在 Android 14（API 34）上工作。
```bash
# Install the script from CodeShare and run it against the target package
frida -U -f com.target.app --no-pause -l universal-android-biometric-bypass.js
```
关键思想
* 一切都发生在用户空间 - 不需要内核漏洞或 root 权限。
* 攻击对 UI 完全静默：系统生物识别对话框从未出现。
* 缓解措施：**在解锁敏感功能之前，始终验证 `result.cryptoObject` 及其密码/签名**。

## **方法 7 – 降级 / 回退操控**

从 Android 11 开始，开发者可以通过 `setAllowedAuthenticators()`（或较旧的 `setDeviceCredentialAllowed()`）指定哪些身份验证器是可接受的。一个 **运行时钩子** 攻击可以强制将 `allowedAuthenticators` 位域设置为较弱的 `BIOMETRIC_WEAK | DEVICE_CREDENTIAL` 值：
```javascript
// Frida one-liner – replace strong-only policy with weak/device-credential
var PromptInfoBuilder = Java.use('androidx.biometric.BiometricPrompt$PromptInfo$Builder');
PromptInfoBuilder.setAllowedAuthenticators.implementation = function(flags){
return this.setAllowedAuthenticators(0x0002 | 0x8000); // BIOMETRIC_WEAK | DEVICE_CREDENTIAL
};
```
如果应用程序**不**随后验证返回的 `AuthenticationResult`，攻击者可以简单地按下 _PIN/Pattern_ 回退按钮，甚至注册一个新的弱生物特征以获得访问权限。

## **方法 8 – 供应商 / 内核级 CVE**

关注 Android 安全公告：最近几个内核侧的漏洞允许通过指纹 HAL 进行本地特权升级，并有效地**禁用或短路传感器管道**。示例包括：

* **CVE-2023-20995** – `CustomizedSensor.cpp` 中 `captureImage` 的逻辑错误（Pixel 8，Android 13），允许在没有用户交互的情况下绕过解锁。
* **CVE-2024-53835 / CVE-2024-53840** – “由于不寻常的根本原因导致的可能生物识别绕过”，已在**2024 年 12 月 Pixel 公告**中修补。

尽管这些漏洞针对锁屏，但已获取 root 的测试人员可以将它们与应用级缺陷链式结合，以绕过应用内生物识别。

---

### 开发人员的加固检查清单（快速渗透测试者笔记）

* 在生成 **Keystore** 密钥时，强制执行 `setUserAuthenticationRequired(true)` 和 `setInvalidatedByBiometricEnrollment(true)`。然后需要有效的生物特征才能使用该密钥。
* 拒绝具有 **null 或意外密码/签名** 的 `CryptoObject`；将其视为致命的身份验证错误。
* 使用 `BiometricPrompt` 时，优先选择 `BIOMETRIC_STRONG`，并且**绝不要回退到 `BIOMETRIC_WEAK` 或 `DEVICE_CREDENTIAL`** 进行高风险操作。
* 固定最新的 `androidx.biometric` 版本 (≥1.2.0-beta02) – 最近的版本增加了自动 null 密码检查，并收紧了允许的身份验证器组合。

## 参考文献

- [Universal Android Biometric Bypass – Frida CodeShare](https://codeshare.frida.re/@ax/universal-android-biometric-bypass/)
- [Android Pixel Security Bulletin 2024-12-01](https://source.android.com/security/bulletin/pixel/2024-12-01)


{{#include ../../banners/hacktricks-training.md}}
