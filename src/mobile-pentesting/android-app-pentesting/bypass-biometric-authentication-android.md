# Bypass Biometric Authentication (Android)

{{#include ../../banners/hacktricks-training.md}}

## **Metodo 1 – Bypass senza utilizzo di Crypto Object**

L'attenzione qui è sul callback _onAuthenticationSucceeded_, che è cruciale nel processo di autenticazione. I ricercatori di WithSecure hanno sviluppato uno [script Frida](https://github.com/WithSecureLABS/android-keystore-audit/blob/master/frida-scripts/fingerprint-bypass.js), che consente di bypassare il NULL _CryptoObject_ in _onAuthenticationSucceeded(...)_. Lo script forza un bypass automatico dell'autenticazione tramite impronta digitale al momento dell'invocazione del metodo. Di seguito è riportato un frammento semplificato che dimostra il bypass in un contesto di impronta digitale Android, con l'applicazione completa disponibile su [GitHub](https://github.com/St3v3nsS/InsecureBanking).
```javascript
biometricPrompt = new BiometricPrompt(this, executor, new BiometricPrompt.AuthenticationCallback() {
@Override
public void onAuthenticationSucceeded(@NonNull BiometricPrompt.AuthenticationResult result) {
Toast.makeText(MainActivity.this,"Success",Toast.LENGTH_LONG).show();
}
});
```
Comando per eseguire lo script Frida:
```bash
frida -U -f com.generic.insecurebankingfingerprint --no-pause -l fingerprint-bypass.js
```
## **Metodo 2 – Approccio alla Gestione delle Eccezioni**

Un altro [Frida script](https://github.com/WithSecureLABS/android-keystore-audit/blob/master/frida-scripts/fingerprint-bypass-via-exception-handling.js) di WithSecure affronta il bypass dell'uso insicuro degli oggetti crittografici. Lo script invoca _onAuthenticationSucceeded_ con un _CryptoObject_ che non è stato autorizzato da un'impronta digitale. Se l'applicazione tenta di utilizzare un oggetto cifrato diverso, verrà generata un'eccezione. Lo script si prepara a invocare _onAuthenticationSucceeded_ e gestire il _javax.crypto.IllegalBlockSizeException_ nella classe _Cipher_, assicurando che gli oggetti successivi utilizzati dall'applicazione siano crittografati con la nuova chiave.

Comando per eseguire lo script Frida:
```bash
frida -U -f com.generic.insecurebankingfingerprint --no-pause -l fingerprint-bypass-via-exception-handling.js
```
Una volta raggiunta la schermata delle impronte digitali e l'inizio di `authenticate()`, digita `bypass()` nella console di Frida per attivare il bypass:
```
Spawning com.generic.insecurebankingfingerprint...
[Android Emulator 5554::com.generic.insecurebankingfingerprint]-> Hooking BiometricPrompt.authenticate()...
Hooking BiometricPrompt.authenticate2()...
Hooking FingerprintManager.authenticate()...
[Android Emulator 5554::com.generic.insecurebankingfingerprint]-> bypass()
```
## **Metodo 3 – Framework di Strumentazione**

I framework di strumentazione come Xposed o Frida possono essere utilizzati per agganciarsi ai metodi dell'applicazione durante l'esecuzione. Per l'autenticazione tramite impronta digitale, questi framework possono:

1. **Fingere i Callback di Autenticazione**: Agganciandosi ai metodi `onAuthenticationSucceeded`, `onAuthenticationFailed` o `onAuthenticationError` del `BiometricPrompt.AuthenticationCallback`, puoi controllare l'esito del processo di autenticazione tramite impronta digitale.
2. **Evitare il SSL Pinning**: Questo consente a un attaccante di intercettare e modificare il traffico tra il client e il server, potenzialmente alterando il processo di autenticazione o rubando dati sensibili.

Esempio di comando per Frida:
```bash
frida -U -l script-to-bypass-authentication.js --no-pause -f com.generic.in
```
## **Metodo 4 – Ingegneria inversa e modifica del codice**

Strumenti di ingegneria inversa come `APKTool`, `dex2jar` e `JD-GUI` possono essere utilizzati per decompilare un'applicazione Android, leggere il suo codice sorgente e comprendere il suo meccanismo di autenticazione. I passaggi generalmente includono:

1. **Decompilazione dell'APK**: Convertire il file APK in un formato più leggibile (come codice Java).
2. **Analisi del codice**: Cercare l'implementazione dell'autenticazione tramite impronta digitale e identificare potenziali vulnerabilità (come meccanismi di fallback o controlli di validazione inadeguati).
3. **Ricompilazione dell'APK**: Dopo aver modificato il codice per bypassare l'autenticazione tramite impronta digitale, l'applicazione viene ricompilata, firmata e installata sul dispositivo per il test.

## **Metodo 5 – Utilizzo di strumenti di autenticazione personalizzati**

Esistono strumenti e script specializzati progettati per testare e bypassare i meccanismi di autenticazione. Ad esempio:

1. **Moduli MAGISK**: MAGISK è uno strumento per Android che consente agli utenti di rootare i propri dispositivi e aggiungere moduli che possono modificare o falsificare informazioni a livello hardware, comprese le impronte digitali.
2. **Script personalizzati**: Possono essere scritti script per interagire con l'Android Debug Bridge (ADB) o direttamente con il backend dell'applicazione per simulare o bypassare l'autenticazione tramite impronta digitale.

---

## **Metodo 6 – Hook Frida Universale per `BiometricPrompt` (API 28-34)**

Nel 2023 è apparso uno script Frida della comunità denominato **Universal-Android-Biometric-Bypass** su CodeShare. Lo script aggancia ogni sovraccarico di `BiometricPrompt.authenticate()` così come il legacy `FingerprintManager.authenticate()` e attiva direttamente `onAuthenticationSucceeded()` con un **`AuthenticationResult` fabbricato contenente un `CryptoObject` nullo**. Poiché si adatta dinamicamente ai livelli API, funziona ancora su Android 14 (API 34) se l'app target non esegue **controlli crittografici sul `CryptoObject` restituito**.
```bash
# Install the script from CodeShare and run it against the target package
frida -U -f com.target.app --no-pause -l universal-android-biometric-bypass.js
```
Key ideas
* Tutto avviene nello spazio utente – non è necessario alcun exploit del kernel o root.
* L'attacco rimane completamente silenzioso per l'interfaccia utente: il dialogo biometrico di sistema non appare mai.
* Mitigazione: **verifica sempre `result.cryptoObject` e il suo cifrario/firma prima di sbloccare funzionalità sensibili**.

## **Method 7 – Downgrade / Fallback Manipulation**

A partire da Android 11, gli sviluppatori possono specificare quali autenticatori sono accettabili tramite `setAllowedAuthenticators()` (o il più vecchio `setDeviceCredentialAllowed()`). Un attacco di **runtime hooking** può forzare il campo bit `allowedAuthenticators` al valore più debole `BIOMETRIC_WEAK | DEVICE_CREDENTIAL`:
```javascript
// Frida one-liner – replace strong-only policy with weak/device-credential
var PromptInfoBuilder = Java.use('androidx.biometric.BiometricPrompt$PromptInfo$Builder');
PromptInfoBuilder.setAllowedAuthenticators.implementation = function(flags){
return this.setAllowedAuthenticators(0x0002 | 0x8000); // BIOMETRIC_WEAK | DEVICE_CREDENTIAL
};
```
Se l'app **non** valida successivamente il `AuthenticationResult` restituito, un attaccante può semplicemente premere il pulsante di fallback _PIN/Pattern_ o persino registrare un nuovo biometrico debole per ottenere accesso.

## **Metodo 8 – CVE a livello di fornitore / kernel**

Tieni d'occhio i bollettini di sicurezza di Android: diversi bug recenti a livello di kernel consentono l'escalation dei privilegi locali attraverso l'HAL delle impronte digitali e **disabilitano o cortocircuitano effettivamente il pipeline del sensore**. Esempi includono:

* **CVE-2023-20995** – errore logico in `captureImage` di `CustomizedSensor.cpp` (Pixel 8, Android 13) che consente di bypassare lo sblocco senza interazione dell'utente.
* **CVE-2024-53835 / CVE-2024-53840** – “possibile bypass biometrico a causa di una causa radice insolita” corretto nel **bollettino Pixel di dicembre 2024**.

Sebbene queste vulnerabilità mirino allo schermo di blocco, un tester con accesso root può combinarle con difetti a livello di app per bypassare anche i biometrici in-app.

---

### Checklist di indurimento per sviluppatori (Note rapide per pentester)

* Applica `setUserAuthenticationRequired(true)` e `setInvalidatedByBiometricEnrollment(true)` quando generi chiavi **Keystore**. Un biometrico valido è quindi richiesto prima che la chiave possa essere utilizzata.
* Rifiuta un `CryptoObject` con **cifratura / firma null o inaspettata**; considera questo come un errore di autenticazione fatale.
* Quando utilizzi `BiometricPrompt`, preferisci `BIOMETRIC_STRONG` e **non tornare mai a `BIOMETRIC_WEAK` o `DEVICE_CREDENTIAL`** per azioni ad alto rischio.
* Fissa l'ultima versione di `androidx.biometric` (≥1.2.0-beta02) – le versioni recenti aggiungono controlli automatici per cifrature null e stringono le combinazioni di autenticazione consentite.

## Riferimenti

- [Universal Android Biometric Bypass – Frida CodeShare](https://codeshare.frida.re/@ax/universal-android-biometric-bypass/)
- [Android Pixel Security Bulletin 2024-12-01](https://source.android.com/security/bulletin/pixel/2024-12-01)


{{#include ../../banners/hacktricks-training.md}}
