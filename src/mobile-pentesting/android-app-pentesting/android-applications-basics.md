# Android Applications Basics

{{#include ../../banners/hacktricks-training.md}}

## Android Security Model

**二つの層があります：**

- **OS**は、インストールされたアプリケーションを互いに隔離します。
- **アプリケーション自体**は、開発者が**特定の機能を公開**し、アプリケーションの機能を構成することを可能にします。

### UID Separation

**各アプリケーションには特定のユーザーIDが割り当てられます**。これはアプリのインストール時に行われ、**アプリはそのユーザーIDが所有するファイルまたは共有ファイルのみと相互作用できます**。したがって、アプリ自体、OSの特定のコンポーネント、およびルートユーザーのみがアプリのデータにアクセスできます。

### UID Sharing

**二つのアプリケーションは同じUIDを使用するように構成できます**。これは情報を共有するのに便利ですが、一方が侵害されると両方のアプリケーションのデータが侵害されることになります。これがこの動作が**推奨されない理由です**。\
**同じUIDを共有するには、アプリケーションはマニフェストで同じ`android:sharedUserId`値を定義する必要があります。**

### Sandboxing

**Androidアプリケーションサンドボックス**は、**各アプリケーションを別のユーザーIDの下で別のプロセスとして実行することを可能にします**。各プロセスは独自の仮想マシンを持っているため、アプリのコードは他のアプリから隔離されて実行されます。\
Android 5.0(L)以降、**SELinux**が強制されます。基本的に、SELinuxはすべてのプロセス間の相互作用を拒否し、その後、**期待される相互作用のみを許可するポリシーを作成しました**。

### Permissions

アプリをインストールするときに**アプリが権限を要求する**場合、アプリは**AndroidManifest.xml**ファイル内の**`uses-permission`**要素に設定された権限を要求しています。**uses-permission**要素は、**name**属性内で要求された権限の名前を示します。また、**maxSdkVersion**属性もあり、指定されたバージョンよりも高いバージョンでは権限の要求を停止します。\
Androidアプリケーションは最初にすべての権限を要求する必要はなく、**動的に権限を要求することもできます**が、すべての権限は**マニフェストで宣言されなければなりません**。

アプリが機能を公開する際には、**特定の権限を持つアプリのみがアクセスできるように制限することができます**。\
権限要素には三つの属性があります：

- 権限の**name**
- 関連する権限をグループ化するための**permission-group**属性
- 権限がどのように付与されるかを示す**protection-level**。四つのタイプがあります：
- **Normal**：アプリに**既知の脅威がない**場合に使用されます。ユーザーは**承認する必要はありません**。
- **Dangerous**：要求されたアプリケーションに**昇格したアクセス**を付与することを示します。**ユーザーに承認を求められます**。
- **Signature**：**コンポーネントをエクスポートするのと同じ証明書で署名されたアプリ**のみが権限を付与されます。これは最も強力な保護タイプです。
- **SignatureOrSystem**：**コンポーネントをエクスポートするのと同じ証明書で署名されたアプリ**または**システムレベルのアクセスで実行されているアプリ**のみが権限を付与されます。

## Pre-Installed Applications

これらのアプリは一般的に**`/system/app`**または**`/system/priv-app`**ディレクトリにあり、その中には**最適化された**ものもあります（`classes.dex`ファイルが見つからないこともあります）。これらのアプリケーションは、時には**過剰な権限で実行されている**ため、確認する価値があります（ルートとして）。

- **AOSP**（Android OpenSource Project）**ROM**に付属しているもの
- デバイスの**製造元**によって追加されたもの
- **携帯電話プロバイダー**によって追加されたもの（彼らから購入した場合）

## Rooting

物理的なAndroidデバイスにルートアクセスを取得するには、一般的に**1つまたは2つの脆弱性を**利用する必要があります。これらは通常、**デバイス**および**バージョン**に特有です。\
エクスプロイトが成功すると、通常、Linuxの`su`バイナリがユーザーのPATH環境変数に指定された場所（例：`/system/xbin`）にコピーされます。

suバイナリが設定されると、別のAndroidアプリが`su`バイナリとインターフェースし、**ルートアクセスのリクエストを処理**します（**Superuser**や**SuperSU**など、Google Playストアで入手可能）。

> [!CAUTION]
> ルート化プロセスは非常に危険であり、デバイスに深刻な損傷を与える可能性があることに注意してください。

### ROMs

**カスタムファームウェアをインストールしてOSを置き換えることが可能です**。これにより、古いデバイスの有用性を拡張したり、ソフトウェア制限を回避したり、最新のAndroidコードにアクセスしたりできます。\
**OmniROM**と**LineageOS**は、使用するための最も人気のあるファームウェアの二つです。

**カスタムファームウェアをインストールするためにデバイスをルート化する必要はない**ことに注意してください。**一部の製造元は**、文書化され、安全な方法でブートローダーのロック解除を許可しています。

### Implications

デバイスがルート化されると、任意のアプリがルートとしてアクセスを要求できます。悪意のあるアプリケーションがそれを取得すると、ほぼすべてにアクセスでき、電話を損傷させることができます。

## Android Application Fundamentals <a href="#2-android-application-fundamentals" id="2-android-application-fundamentals"></a>

- Androidアプリケーションの形式は_ APKファイル形式_と呼ばれます。基本的には**ZIPファイル**です（ファイル拡張子を.zipに変更することで、内容を抽出して表示できます）。
- APKの内容（網羅的ではありません）
- **AndroidManifest.xml**
- resources.arsc/strings.xml
- resources.arsc：バイナリXMLのようなプリコンパイルされたリソースを含みます。
- res/xml/files_paths.xml
- META-INF/
- ここに証明書が存在します！
- **classes.dex**
- Dalvikバイトコードを含み、アプリケーションがデフォルトで実行するコンパイルされたJava（またはKotlin）コードを表します。
- lib/
- CPUアーキテクチャごとにサブディレクトリに分けられたネイティブライブラリを格納します。
- `armeabi`：ARMベースのプロセッサ用のコード
- `armeabi-v7a`：ARMv7およびそれ以降のプロセッサ用のコード
- `x86`：X86プロセッサ用のコード
- `mips`：MIPSプロセッサ専用のコード
- assets/
- アプリに必要な雑多なファイルを格納し、追加のネイティブライブラリやDEXファイルを含むことがあり、時にはマルウェア作成者が追加のコードを隠すために使用します。
- res/
- resources.arscにコンパイルされていないリソースを含みます。

### **Dalvik & Smali**

Android開発では、**JavaまたはKotlin**がアプリ作成に使用されます。デスクトップアプリのようにJVMを使用する代わりに、Androidはこのコードを**Dalvik実行可能（DEX）バイトコード**にコンパイルします。以前は、Dalvik仮想マシンがこのバイトコードを処理していましたが、現在では新しいAndroidバージョンではAndroid Runtime（ART）が引き継いでいます。

リバースエンジニアリングでは、**Smali**が重要になります。これはDEXバイトコードの人間が読めるバージョンで、ソースコードをバイトコード命令に変換するアセンブリ言語のように機能します。Smaliとbaksmaliは、この文脈でのアセンブリおよび逆アセンブリツールを指します。

## Intents

インテントは、Androidアプリがそのコンポーネント間または他のアプリと通信するための主要な手段です。これらのメッセージオブジェクトは、アプリ間やコンポーネント間でデータを運ぶこともでき、HTTP通信でのGET/POSTリクエストのように機能します。

したがって、インテントは基本的に**コンポーネント間で渡されるメッセージ**です。インテントは**特定のコンポーネントやアプリに向けられる**ことも、**特定の受取人なしで送信される**こともできます。\
簡単に言えば、インテントは次のように使用できます：

- アクティビティを開始するため、通常はアプリのユーザーインターフェースを開く
- システムやアプリに変更を通知するためのブロードキャストとして
- バックグラウンドサービスを開始、停止、通信するため
- ContentProvidersを介してデータにアクセスするため
- イベントを処理するためのコールバックとして

脆弱な場合、**インテントはさまざまな攻撃を実行するために使用される可能性があります**。

### Intent-Filter

**インテントフィルター**は、**アクティビティ、サービス、またはブロードキャストレシーバーが異なるタイプのインテントとどのように相互作用できるかを定義します**。基本的に、これらのコンポーネントの能力を説明し、どのようなアクションを実行できるか、またはどのようなブロードキャストを処理できるかを示します。これらのフィルターを宣言する主な場所は**AndroidManifest.xmlファイル**内ですが、ブロードキャストレシーバーの場合は、コーディングすることも選択肢です。

インテントフィルターは、カテゴリ、アクション、およびデータフィルターで構成され、追加のメタデータを含めることができます。この設定により、コンポーネントは宣言された基準に一致する特定のインテントを処理できます。

Androidコンポーネント（アクティビティ/サービス/コンテンツプロバイダー/ブロードキャストレシーバー）の重要な側面は、その可視性または**公開状態**です。コンポーネントは、**`exported`**が**`true`**の値である場合、またはマニフェストにインテントフィルターが宣言されている場合、公開と見なされ、他のアプリと相互作用できます。ただし、開発者はこれらのコンポーネントを明示的にプライベートに保つ方法があり、他のアプリと意図せず相互作用しないようにすることができます。これは、マニフェスト定義で**`exported`**属性を**`false`**に設定することで実現されます。

さらに、開発者は特定の権限を要求することで、これらのコンポーネントへのアクセスをさらに保護するオプションがあります。**`permission`**属性を設定することで、指定された権限を持つアプリのみがコンポーネントにアクセスできるようにし、誰がそれと相互作用できるかに対する追加のセキュリティと制御の層を追加します。
```java
<activity android:name=".MyActivity" android:exported="false">
<!-- Intent filters go here -->
</activity>
```
### インプリシットインテント

インテントは、インテントコンストラクタを使用してプログラム的に作成されます:
```java
Intent email = new Intent(Intent.ACTION_SEND, Uri.parse("mailto:"));
```
**アクション**は、前に宣言されたインテントの**ACTION_SEND**であり、**エクストラ**はmailto **Uri**です（エクストラはインテントが期待している追加情報です）。

このインテントは、以下の例のようにマニフェスト内で宣言する必要があります:
```xml
<activity android:name="ShareActivity">
<intent-filter>
<action android:name="android.intent.action.SEND" />
<category android:name="android.intent.category.DEFAULT" />
</intent-filter>
</activity>
```
インテントフィルターは、メッセージを受信するために**アクション**、**データ**、および**カテゴリ**が一致する必要があります。

「インテント解決」プロセスは、どのアプリが各メッセージを受信すべきかを決定します。このプロセスは、**優先度属性**を考慮し、これは**インテントフィルター宣言**で設定できます。**優先度が高い方が選択されます**。この優先度は-1000から1000の間で設定でき、アプリケーションは`SYSTEM_HIGH_PRIORITY`値を使用できます。**競合**が発生した場合、「チョイザー」ウィンドウが表示され、**ユーザーが決定できます**。

### 明示的インテント

明示的インテントは、ターゲットとするクラス名を指定します：
```java
Intent downloadIntent = new (this, DownloadService.class):
```
他のアプリケーションでは、以前に宣言されたインテントにアクセスするために次のように使用できます：
```java
Intent intent = new Intent();
intent.setClassName("com.other.app", "com.other.app.ServiceName");
context.startService(intent);
```
### Pending Intents

これにより、他のアプリケーションが**あなたのアプリケーションの代理でアクションを実行する**ことができます。Pending Intentを構築する際には、**インテントと実行するアクションを指定する必要があります**。もし**宣言されたインテントが明示的でない場合**（どのインテントが呼び出せるかを宣言していない場合）、**悪意のあるアプリケーションが被害者アプリの代理で宣言されたアクションを実行する可能性があります**。さらに、**アクションが指定されていない場合**、悪意のあるアプリは**被害者の代理で任意のアクションを実行できる**ようになります。

### Broadcast Intents

前のインテントとは異なり、1つのアプリだけが受信するのではなく、ブロードキャストインテントは**複数のアプリで受信可能です**。ただし、APIバージョン14以降は、**メッセージを受信すべきアプリを指定することが可能です**。Intent.setPackageを使用します。

また、ブロードキャストを送信する際に**権限を指定することも可能です**。受信アプリはその権限を持っている必要があります。

ブロードキャストには**2種類**があります：**通常**（非同期）と**順序付き**（同期）。**順序**は**受信者要素内の設定された優先度**に基づいています。**各アプリはブロードキャストを処理、転送、または破棄することができます**。

`Context`クラスの関数`sendBroadcast(intent, receiverPermission)`を使用して**ブロードキャストを送信**することが可能です。\
また、**`LocalBroadCastManager`**の**`sendBroadcast`**関数を使用すると、**メッセージがアプリを離れないことが保証されます**。これを使用すると、受信者コンポーネントをエクスポートする必要すらありません。

### Sticky Broadcasts

この種のブロードキャストは**送信された後も長期間アクセス可能です**。\
これらはAPIレベル21で非推奨となり、**使用しないことが推奨されています**。\
**これにより、任意のアプリケーションがデータを盗聴することができるだけでなく、データを変更することも可能です**。

「sticky」という単語を含む関数（例：**`sendStickyBroadcast`**や**`sendStickyBroadcastAsUser`**）を見つけた場合は、**影響を確認し、削除を試みてください**。

## Deep links / URL schemes

Androidアプリケーションでは、**ディープリンク**を使用してURLを介して直接アクション（インテント）を開始します。これは、アクティビティ内で特定の**URLスキーム**を宣言することによって行われます。Androidデバイスがこのスキームを持つURLに**アクセスしようとすると**、アプリケーション内の指定されたアクティビティが起動します。

スキームは**`AndroidManifest.xml`**ファイルに宣言する必要があります：
```xml
[...]
<activity android:name=".MyActivity">
<intent-filter>
<action android:name="android.intent.action.VIEW" />
<category android:name="android.intent.category.DEFAULT" />
<category android:name="android.intent.category.BROWSABLE" />
<data android:scheme="examplescheme" />
</intent-filter>
[...]
```
前の例のスキームは `examplescheme://` です（**`category BROWSABLE`** も注意してください）

次に、データフィールドで **host** と **path** を指定できます:
```xml
<data android:scheme="examplescheme"
android:host="example"
/>
```
ウェブからアクセスするには、次のようにリンクを設定することができます:
```xml
<a href="examplescheme://example/something">click here</a>
<a href="examplescheme://example/javascript://%250dalert(1)">click here</a>
```
アプリで実行される**コードを見つけるために**、ディープリンクによって呼び出されるアクティビティに移動し、**`onNewIntent`**関数を検索します。

HTMLページを使用せずに[ディープリンクを呼び出す方法](./#exploiting-schemes-deep-links)を学びましょう。

## AIDL - Androidインターフェース定義言語

**Androidインターフェース定義言語（AIDL）**は、Androidアプリケーションにおけるクライアントとサービス間の**プロセス間通信**（IPC）を容易にするために設計されています。Androidでは他のプロセスのメモリに直接アクセスすることは許可されていないため、AIDLはオブジェクトをオペレーティングシステムが理解できる形式にマーシャリングすることで、異なるプロセス間の通信を容易にします。

### 主要概念

- **バウンドサービス**: これらのサービスはIPCのためにAIDLを利用し、アクティビティやコンポーネントがサービスにバインドし、リクエストを行い、レスポンスを受け取ることを可能にします。サービスのクラス内の`onBind`メソッドは、相互作用を開始するために重要であり、脆弱性を探すためのセキュリティレビューにおいて重要な領域です。

- **メッセンジャー**: バウンドサービスとして機能するメッセンジャーは、`onBind`メソッドを通じてデータを処理することに重点を置いたIPCを促進します。このメソッドを注意深く検査し、安全でないデータ処理や機密関数の実行がないか確認することが重要です。

- **バインダー**: AIDLの抽象化によりバインダー・クラスの直接使用はあまり一般的ではありませんが、バインダーは異なるプロセスのメモリ空間間でデータ転送を促進するカーネルレベルのドライバーとして機能することを理解することは有益です。さらなる理解のために、リソースは[https://www.youtube.com/watch?v=O-UHvFjxwZ8](https://www.youtube.com/watch?v=O-UHvFjxwZ8)で利用可能です。

## コンポーネント

これには、**アクティビティ、サービス、ブロードキャストレシーバー、プロバイダー**が含まれます。

### ランチャーアクティビティとその他のアクティビティ

Androidアプリでは、**アクティビティ**は画面のようなもので、アプリのユーザーインターフェースの異なる部分を表示します。アプリは多くのアクティビティを持つことができ、それぞれがユーザーにユニークな画面を提供します。

**ランチャーアクティビティ**はアプリへの主要な入り口であり、アプリのアイコンをタップすると起動します。これは、特定のMAINおよびLAUNCHERインテントを持つアプリのマニフェストファイルで定義されています。
```markup
<activity android:name=".LauncherActivity">
<intent-filter>
<action android:name="android.intent.action.MAIN" />
<category android:name="android.intent.category.LAUNCHER" />
</intent-filter>
</activity>
```
すべてのアプリがランチャーアクティビティを必要とするわけではなく、特にユーザーインターフェースのないバックグラウンドサービスのようなアプリは必要ありません。

アクティビティは、マニフェストで「exported」としてマークすることで、他のアプリやプロセスに利用可能にすることができます。この設定により、他のアプリがこのアクティビティを開始できるようになります：
```markdown
<service android:name=".ExampleExportedService" android:exported="true"/>
```
しかし、別のアプリからアクティビティにアクセスすることが常にセキュリティリスクであるわけではありません。懸念は、機密データが不適切に共有される場合に生じ、情報漏洩につながる可能性があります。

アクティビティのライフサイクルは**onCreateメソッドから始まり**、UIを設定し、ユーザーとのインタラクションのためにアクティビティを準備します。

### アプリケーションサブクラス

Android開発では、アプリは[Application](https://developer.android.com/reference/android/app/Application)クラスの**サブクラス**を作成するオプションがありますが、必須ではありません。このようなサブクラスが定義されると、それはアプリ内で最初にインスタンス化されるクラスになります。**`attachBaseContext`**メソッドがこのサブクラスで実装されている場合、**`onCreate`**メソッドの前に実行されます。このセットアップにより、アプリケーションの残りの部分が開始される前に早期初期化が可能になります。
```java
public class MyApp extends Application {
@Override
protected void attachBaseContext(Context base) {
super.attachBaseContext(base);
// Initialization code here
}

@Override
public void onCreate() {
super.onCreate();
// More initialization code
}
}
```
### サービス

[Services](https://developer.android.com/guide/components/services) は、**バックグラウンドオペレーティブ**であり、ユーザーインターフェースなしでタスクを実行することができます。これらのタスクは、ユーザーが異なるアプリケーションに切り替えても実行を続けることができるため、サービスは**長時間実行される操作**にとって重要です。

サービスは多用途であり、さまざまな方法で開始できますが、**Intents**がアプリケーションのエントリーポイントとしてサービスを起動する主な方法です。`startService`メソッドを使用してサービスが開始されると、その`onStart`メソッドが動作を開始し、`stopService`メソッドが明示的に呼び出されるまで実行を続けます。あるいは、サービスの役割がアクティブなクライアント接続に依存している場合、`bindService`メソッドを使用してクライアントをサービスにバインドし、データの受け渡しのために`onBind`メソッドが呼び出されます。

サービスの興味深い応用には、バックグラウンドでの音楽再生やネットワークデータの取得が含まれ、ユーザーがアプリと対話することを妨げません。さらに、サービスは**エクスポート**を通じて同じデバイス上の他のプロセスにアクセス可能にすることができます。これはデフォルトの動作ではなく、Android Manifestファイルで明示的な設定が必要です：
```xml
<service android:name=".ExampleExportedService" android:exported="true"/>
```
### Broadcast Receivers

**Broadcast receivers** は、メッセージングシステムにおけるリスナーとして機能し、複数のアプリケーションがシステムからの同じメッセージに応答できるようにします。アプリは **Manifest** を通じて、または **`registerReceiver`** API を介してアプリのコード内で **2つの主要な方法** で **レシーバーを登録** できます。Manifest では、ブロードキャストは権限でフィルタリングされ、動的に登録されたレシーバーは登録時に権限を指定することもできます。

**Intent フィルター** は、両方の登録方法で重要であり、どのブロードキャストがレシーバーをトリガーするかを決定します。一致するブロードキャストが送信されると、レシーバーの **`onReceive`** メソッドが呼び出され、アプリが低バッテリーアラートに応じて動作を調整するなど、適切に反応できるようになります。

ブロードキャストは **非同期** であり、順序なしにすべてのレシーバーに到達することも、**同期** であり、レシーバーが設定された優先順位に基づいてブロードキャストを受け取ることもできます。ただし、任意のアプリが自分自身を優先させてブロードキャストを傍受できる可能性があるため、潜在的なセキュリティリスクに注意することが重要です。

レシーバーの機能を理解するには、そのクラス内の **`onReceive`** メソッドを探してください。このメソッドのコードは受信した Intent を操作でき、特に **Ordered Broadcasts** では、データの検証が必要であることを強調しています。Ordered Broadcasts は Intent を変更または削除することができます。

### Content Provider

**Content Providers** は、アプリ間で **構造化データを共有する** ために不可欠であり、データセキュリティを確保するために **権限** を実装する重要性を強調しています。これにより、アプリはデータベース、ファイルシステム、またはウェブなど、さまざまなソースからデータにアクセスできます。**`readPermission`** や **`writePermission`** などの特定の権限は、アクセスを制御するために重要です。さらに、一時的なアクセスは、アプリのマニフェスト内の **`grantUriPermission`** 設定を通じて付与でき、`path`、`pathPrefix`、および `pathPattern` などの属性を利用して詳細なアクセス制御を行います。

入力検証は、SQL インジェクションなどの脆弱性を防ぐために重要です。Content Providers は、データ操作とアプリケーション間の共有を促進する基本的な操作をサポートします：`insert()`、`update()`、`delete()`、および `query()`。

**FileProvider** は、ファイルを安全に共有することに特化した Content Provider です。これは、フォルダーへのアクセスを制御するための特定の属性を持ってアプリのマニフェストで定義され、`android:exported` と `android:resource` がフォルダー構成を指します。機密データが意図せずに公開されないように、ディレクトリを共有する際には注意が必要です。

FileProvider の例のマニフェスト宣言：
```xml
<provider android:name="androidx.core.content.FileProvider"
android:authorities="com.example.myapp.fileprovider"
android:grantUriPermissions="true"
android:exported="false">
<meta-data android:name="android.support.FILE_PROVIDER_PATHS"
android:resource="@xml/filepaths" />
</provider>
```
`filepaths.xml`で共有フォルダーを指定する例:
```xml
<paths>
<files-path path="images/" name="myimages" />
</paths>
```
さらなる情報は以下を確認してください：

- [Android Developers: Content Providers](https://developer.android.com/guide/topics/providers/content-providers)
- [Android Developers: FileProvider](https://developer.android.com/training/secure-file-sharing/setup-sharing)

## WebViews

WebViewsはAndroidアプリ内の**ミニウェブブラウザ**のようなもので、ウェブまたはローカルファイルからコンテンツを取得します。通常のブラウザと同様のリスクに直面しますが、特定の**設定**を通じて**リスクを軽減する**方法があります。

Androidは2つの主要なWebViewタイプを提供しています：

- **WebViewClient**は基本的なHTMLには適していますが、JavaScriptのアラート機能をサポートしていないため、XSS攻撃のテストに影響を与えます。
- **WebChromeClient**はフルChromeブラウザの体験に近いです。

重要な点は、WebViewブラウザはデバイスのメインブラウザと**クッキーを共有しない**ことです。

コンテンツを読み込むために、`loadUrl`、`loadData`、`loadDataWithBaseURL`などのメソッドが利用可能です。これらのURLやファイルが**安全に使用できる**ことを確認することが重要です。セキュリティ設定は`WebSettings`クラスを通じて管理できます。例えば、`setJavaScriptEnabled(false)`でJavaScriptを無効にすることで、XSS攻撃を防ぐことができます。

JavaScriptの「ブリッジ」はJavaオブジェクトがJavaScriptと相互作用することを可能にし、Android 4.2以降はセキュリティのためにメソッドに`@JavascriptInterface`を付ける必要があります。

コンテンツアクセスを許可する（`setAllowContentAccess(true)`）ことで、WebViewsはContent Providersにアクセスできますが、コンテンツURLが安全であることを確認しない限りリスクがあります。

ファイルアクセスを制御するために：

- ファイルアクセスを無効にする（`setAllowFileAccess(false)`）ことで、ファイルシステムへのアクセスが制限され、特定のアセットに対して例外が設けられ、機密でないコンテンツのみに使用されることが保証されます。

## その他のアプリコンポーネントとモバイルデバイス管理

### **アプリケーションのデジタル署名**

- **デジタル署名**はAndroidアプリに必須で、インストール前に**真正に作成された**ことを保証します。このプロセスはアプリの識別のために証明書を使用し、インストール時にデバイスのパッケージマネージャーによって検証される必要があります。アプリは**自己署名または外部CAによって認証**され、不正アクセスから保護され、デバイスへの配信中にアプリが改ざんされないことを保証します。

### **セキュリティ強化のためのアプリ検証**

- **Android 4.2**以降、**Verify Apps**という機能により、ユーザーはインストール前にアプリの安全性を確認できます。この**検証プロセス**は、潜在的に有害なアプリに対してユーザーに警告を出したり、特に悪意のあるアプリのインストールを防いだりすることができ、ユーザーのセキュリティを強化します。

### **モバイルデバイス管理 (MDM)**

- **MDMソリューション**は、**デバイス管理API**を通じてモバイルデバイスの**監視とセキュリティ**を提供します。これらは、モバイルデバイスを効果的に管理し保護するためにAndroidアプリのインストールを必要とします。主な機能には、**パスワードポリシーの強制**、**ストレージ暗号化の義務付け**、および**リモートデータ消去の許可**が含まれ、モバイルデバイスに対する包括的な制御とセキュリティを確保します。
```java
// Example of enforcing a password policy with MDM
DevicePolicyManager dpm = (DevicePolicyManager) getSystemService(Context.DEVICE_POLICY_SERVICE);
ComponentName adminComponent = new ComponentName(context, AdminReceiver.class);

if (dpm.isAdminActive(adminComponent)) {
// Set minimum password length
dpm.setPasswordMinimumLength(adminComponent, 8);
}
```
{{#include ../../banners/hacktricks-training.md}}
