# Android Uygulamaları Temelleri

{{#include ../../banners/hacktricks-training.md}}

## Android Güvenlik Modeli

**İki katman vardır:**

- **OS**, yüklü uygulamaları birbirinden izole tutar.
- **uygulamanın kendisi**, geliştiricilerin **belirli işlevsellikleri açığa çıkarmasına** ve uygulama yeteneklerini yapılandırmasına olanak tanır.

### UID Ayrımı

**Her uygulamaya belirli bir Kullanıcı Kimliği atanır**. Bu, uygulamanın yüklenmesi sırasında yapılır, böylece **uygulama yalnızca kendi Kullanıcı Kimliğine ait dosyalarla veya paylaşılan** dosyalarla etkileşimde bulunabilir. Bu nedenle, yalnızca uygulamanın kendisi, OS'nin belirli bileşenleri ve root kullanıcısı uygulama verilerine erişebilir.

### UID Paylaşımı

**İki uygulama aynı UID'yi kullanacak şekilde yapılandırılabilir**. Bu, bilgi paylaşmak için yararlı olabilir, ancak bunlardan biri tehlikeye girerse, her iki uygulamanın verileri de tehlikeye girecektir. Bu nedenle bu davranış **kaçınılması gereken bir durumdur**.\
**Aynı UID'yi paylaşmak için, uygulamalar manifestolarında aynı `android:sharedUserId` değerini tanımlamalıdır.**

### Sandbox

**Android Uygulama Sandbox'ı**, **her uygulamayı** **ayrı bir kullanıcı kimliği altında ayrı bir işlem olarak çalıştırmaya** olanak tanır. Her işlem kendi sanal makinesine sahiptir, bu nedenle bir uygulamanın kodu diğer uygulamalardan izole bir şekilde çalışır.\
Android 5.0(L) itibarıyla **SELinux** uygulanmaktadır. Temelde, SELinux tüm işlem etkileşimlerini reddetti ve ardından **aralarındaki beklenen etkileşimleri yalnızca izin veren politikalar oluşturdu**.

### İzinler

Bir **uygulama yüklediğinizde ve izinler istiyorsa**, uygulama **AndroidManifest.xml** dosyasındaki **`uses-permission`** öğelerinde yapılandırılan izinleri istemektedir. **uses-permission** öğesi, istenen iznin adını **name** **özniteliği içinde belirtir.** Ayrıca, belirtilen sürümden daha yüksek sürümlerde izin istemeyi durduran **maxSdkVersion** özniteliğine de sahiptir.\
Android uygulamalarının başlangıçta tüm izinleri istemesi gerekmediğini, dinamik olarak da **izin isteyebileceğini** ancak tüm izinlerin **manifestoda beyan edilmesi gerektiğini** unutmayın.

Bir uygulama işlevsellik açığa çıkardığında, **yalnızca belirli bir izne sahip uygulamalara erişimi sınırlayabilir**.\
Bir izin öğesinin üç özniteliği vardır:

- İznin **adı**
- İzinlerin ilgili gruplar halinde gruplanmasına olanak tanıyan **permission-group** özniteliği.
- İzinlerin nasıl verildiğini belirten **protection-level**. Dört tür vardır:
- **Normal**: Uygulama için **bilinen bir tehdit yoksa** kullanılır. Kullanıcının **onaylaması gerekmez**.
- **Tehlikeli**: İznin, istek yapan uygulamaya bazı **yükseltilmiş erişim** sağladığını belirtir. **Kullanıcılardan onay istenir**.
- **İmza**: Yalnızca **bileşeni dışa aktaranla aynı sertifika ile imzalanmış uygulamalar** izin alabilir. Bu, en güçlü koruma türüdür.
- **İmza veya Sistem**: Yalnızca **bileşeni dışa aktaranla aynı sertifika ile imzalanmış uygulamalar veya **sistem düzeyinde erişimle çalışan uygulamalar** izin alabilir.

## Önceden Yüklenmiş Uygulamalar

Bu uygulamalar genellikle **`/system/app`** veya **`/system/priv-app`** dizinlerinde bulunur ve bazıları **optimize edilmiştir** (belki de `classes.dex` dosyasını bile bulamazsınız). Bu uygulamalar kontrol edilmeye değerdir çünkü bazen **çok fazla izinle çalışıyor olabilirler** (root olarak).

- **AOSP** (Android Açık Kaynak Projesi) **ROM** ile birlikte gelenler
- Cihaz **üreticisi** tarafından eklenenler
- **Telefon sağlayıcısı** tarafından eklenenler (eğer onlardan satın alındıysa)

## Rootlama

Bir fiziksel android cihazda root erişimi elde etmek için genellikle **1 veya 2 güvenlik açığını istismar etmeniz** gerekir; bu açılar genellikle **cihaz** ve **sürüm** için **özeldir**.\
İstismar çalıştığında, genellikle Linux `su` ikili dosyası, kullanıcının PATH ortam değişkeninde belirtilen bir konuma kopyalanır, örneğin `/system/xbin`.

Su ikili dosyası yapılandırıldıktan sonra, `su` ikili dosyası ile etkileşimde bulunmak ve **root erişim taleplerini işlemek için** başka bir Android uygulaması kullanılır, örneğin **Superuser** ve **SuperSU** (Google Play mağazasında mevcuttur).

> [!CAUTION]
> Rootlama işleminin çok tehlikeli olduğunu ve cihazı ciddi şekilde zarar verebileceğini unutmayın.

### ROM'lar

**Özel bir yazılım yükleyerek işletim sistemini değiştirmek mümkündür**. Bunu yaparak, eski bir cihazın kullanımını uzatmak, yazılım kısıtlamalarını aşmak veya en son Android koduna erişmek mümkündür.\
**OmniROM** ve **LineageOS**, kullanılacak en popüler yazılımlardan ikisidir.

**Cihazı rootlamak her zaman gerekli değildir**; bazı **üreticiler**, bootloader'larının iyi belgelenmiş ve güvenli bir şekilde kilidini açılmasına izin verir.

### Sonuçlar

Bir cihaz rootlandığında, herhangi bir uygulama root olarak erişim talep edebilir. Eğer kötü niyetli bir uygulama bunu elde ederse, neredeyse her şeye erişimi olacak ve telefonu zarar verebilecektir.

## Android Uygulama Temelleri <a href="#2-android-application-fundamentals" id="2-android-application-fundamentals"></a>

- Android uygulamalarının formatı _APK dosya formatı_ olarak adlandırılır. Temelde bir **ZIP dosyasıdır** (dosya uzantısını .zip olarak değiştirerek, içerikler çıkarılabilir ve görüntülenebilir).
- APK İçerikleri (kapsamlı değil)
- **AndroidManifest.xml**
- resources.arsc/strings.xml
- resources.arsc: ikili XML gibi önceden derlenmiş kaynakları içerir.
- res/xml/files_paths.xml
- META-INF/
- Sertifikanın bulunduğu yer burasıdır!
- **classes.dex**
- Uygulamanın varsayılan olarak çalıştırdığı derlenmiş Java (veya Kotlin) kodunu temsil eden Dalvik bytecode içerir.
- lib/
- CPU mimarisine göre alt dizinlerde ayrılmış yerel kütüphaneleri barındırır.
- `armeabi`: ARM tabanlı işlemciler için kod
- `armeabi-v7a`: ARMv7 ve daha yüksek tabanlı işlemciler için kod
- `x86`: X86 işlemciler için kod
- `mips`: yalnızca MIPS işlemcileri için kod
- assets/
- Uygulamanın ihtiyaç duyduğu çeşitli dosyaları depolar, potansiyel olarak ek yerel kütüphaneler veya DEX dosyaları içerebilir; bazen kötü amaçlı yazılım yazarları tarafından ek kodu gizlemek için kullanılır.
- res/
- resources.arsc içine derlenmemiş kaynakları içerir.

### **Dalvik & Smali**

Android geliştirmede, **Java veya Kotlin** uygulama oluşturmak için kullanılır. Masaüstü uygulamalarındaki gibi JVM kullanmak yerine, Android bu kodu **Dalvik Executable (DEX) bytecode**'a derler. Daha önce, Dalvik sanal makinesi bu bytecode'u yönetiyordu, ancak şimdi, daha yeni Android sürümlerinde Android Runtime (ART) devralmıştır.

Tersine mühendislik için, **Smali** kritik hale gelir. DEX bytecode'un insan tarafından okunabilir versiyonudur ve kaynak kodunu bytecode talimatlarına çevirerek assembly dili gibi işlev görür. Smali ve baksmali, bu bağlamda montaj ve ayrıştırma araçlarını ifade eder.

## Niyetler

Niyetler, Android uygulamalarının bileşenleri arasında veya diğer uygulamalarla iletişim kurmanın birincil yoludur. Bu mesaj nesneleri, uygulamalar veya bileşenler arasında veri taşıyabilir; HTTP iletişimlerinde GET/POST isteklerinin nasıl kullanıldığına benzer.

Yani bir Niyet, temelde **bileşenler arasında iletilen bir mesajdır**. Niyetler **belirli bileşenlere veya uygulamalara yönlendirilebilir** veya **belirli bir alıcı olmadan gönderilebilir**.\
Basit olmak gerekirse, Niyet şu amaçlarla kullanılabilir:

- Bir Aktivite başlatmak, genellikle bir uygulama için bir kullanıcı arayüzü açmak
- Sistemi ve uygulamaları değişiklikler hakkında bilgilendirmek için yayınlar olarak
- Arka planda bir hizmet başlatmak, durdurmak ve onunla iletişim kurmak
- ContentProviders aracılığıyla verilere erişmek
- Olayları işlemek için geri çağırmalar olarak

Eğer savunmasızsa, **Niyetler çeşitli saldırılar gerçekleştirmek için kullanılabilir**.

### Niyet-Filtre

**Niyet Filtreleri**, **bir aktivite, hizmet veya Yayın Alıcısının farklı türdeki Niyetlerle nasıl etkileşimde bulunabileceğini tanımlar**. Temelde, bu bileşenlerin hangi eylemleri gerçekleştirebileceği veya hangi tür yayınları işleyebileceği gibi yeteneklerini tanımlar. Bu filtreleri beyan etmenin birincil yeri **AndroidManifest.xml dosyasıdır**, ancak Yayın Alıcıları için kodlama da bir seçenektir.

Niyet Filtreleri, kategoriler, eylemler ve veri filtrelerinden oluşur ve ek meta verilerin dahil edilmesi mümkündür. Bu yapı, bileşenlerin beyan edilen kriterlerle eşleşen belirli Niyetleri işleyebilmesine olanak tanır.

Android bileşenlerinin (aktivite/hizmet/içerik sağlayıcıları/yayın alıcıları) kritik bir yönü, görünürlükleri veya **kamusal durumlarıdır**. Bir bileşen, **`exported`** değeri **`true`** olarak ayarlandığında kamuya açık kabul edilir ve diğer uygulamalarla etkileşimde bulunabilir. Ancak, geliştiricilerin bu bileşenleri özel tutmak için açık bir şekilde ayarlama seçeneği vardır; bu, diğer uygulamalarla istemeden etkileşimde bulunmamalarını sağlamak için **`exported`** özniteliğini **`false`** olarak ayarlamakla gerçekleştirilir.

Ayrıca, geliştiricilerin bu bileşenlere erişimi daha da güvence altına almak için belirli izinler talep etme seçeneği vardır. **`permission`** özniteliği, yalnızca belirlenen izne sahip uygulamaların bileşene erişebileceğini zorunlu kılacak şekilde ayarlanabilir ve bu da kimlerin etkileşimde bulunabileceği üzerinde ek bir güvenlik ve kontrol katmanı ekler.
```java
<activity android:name=".MyActivity" android:exported="false">
<!-- Intent filters go here -->
</activity>
```
### İkincil Niyetler

Niyetler, bir Niyet yapıcısı kullanılarak programatik olarak oluşturulur:
```java
Intent email = new Intent(Intent.ACTION_SEND, Uri.parse("mailto:"));
```
**Daha önce tanımlanan** intentin **Eylemi** **ACTION_SEND** ve **Ek** bir mailto **Uri**'dir (Ek, intentin beklediği ek bilgidir).

Bu intent, aşağıdaki örnekte olduğu gibi manifest içinde tanımlanmalıdır:
```xml
<activity android:name="ShareActivity">
<intent-filter>
<action android:name="android.intent.action.SEND" />
<category android:name="android.intent.category.DEFAULT" />
</intent-filter>
</activity>
```
Bir intent-filter'ın bir mesajı alabilmesi için **action**, **data** ve **category** ile eşleşmesi gerekir.

"Intent çözümleme" süreci, her mesajı hangi uygulamanın alması gerektiğini belirler. Bu süreç, **priority attribute**'unu dikkate alır; bu, i**ntent-filter bildirimi** içinde ayarlanabilir ve **daha yüksek önceliğe sahip olan seçilecektir**. Bu öncelik -1000 ile 1000 arasında ayarlanabilir ve uygulamalar `SYSTEM_HIGH_PRIORITY` değerini kullanabilir. Eğer bir **çelişki** oluşursa, **kullanıcının karar verebileceği** bir "chooser" penceresi açılır.

### Açık Intents

Açık bir intent, hedef aldığı sınıf adını belirtir:
```java
Intent downloadIntent = new (this, DownloadService.class):
```
Diğer uygulamalarda daha önce tanımlanan niyete erişmek için şunu kullanabilirsiniz:
```java
Intent intent = new Intent();
intent.setClassName("com.other.app", "com.other.app.ServiceName");
context.startService(intent);
```
### Pending Intents

Bunlar diğer uygulamaların **uygulamanız adına eylemler gerçekleştirmesine** olanak tanır, uygulamanızın kimliği ve izinlerini kullanarak. Bir Pending Intent oluştururken **bir intent ve gerçekleştirilecek eylem belirtilmelidir**. Eğer **belirtilen intent Açık Değilse** (hangi intentin çağrılabileceğini belirtmiyorsa) **kötü niyetli bir uygulama, mağdur uygulama adına belirtilen eylemi gerçekleştirebilir**. Dahası, **bir eylem belirtilmemişse**, kötü niyetli uygulama **mağdur adına herhangi bir eylem gerçekleştirebilir**.

### Broadcast Intents

Önceki intentlerden farklı olarak, yalnızca bir uygulama tarafından alınanlar, broadcast intents **birden fazla uygulama tarafından alınabilir**. Ancak, API sürüm 14'ten itibaren, mesajı alacak uygulamanın **belirtilmesi mümkündür**; bu, Intent.setPackage kullanılarak yapılır.

Alternatif olarak, **yayın gönderirken bir izin belirtmek de mümkündür**. Alıcı uygulamanın bu izne sahip olması gerekecektir.

**İki tür** Yayın vardır: **Normal** (asenkron) ve **Sıralı** (senkron). **Sıra**, **alıcı** öğesindeki **yapılandırılmış önceliğe** dayanır. **Her uygulama Yayını işleyebilir, iletebilir veya düşürebilir.**

`Context` sınıfından `sendBroadcast(intent, receiverPermission)` fonksiyonunu kullanarak **bir yayın göndermek** mümkündür.\
Ayrıca, **`LocalBroadCastManager`**'dan **`sendBroadcast`** fonksiyonunu kullanarak **mesajın uygulamadan asla çıkmamasını** sağlayabilirsiniz. Bunu kullanarak bir alıcı bileşenini dışa aktarmanıza gerek kalmaz.

### Sticky Broadcasts

Bu tür Yayınlar **gönderildikten uzun süre sonra erişilebilir**.\
Bunlar API seviye 21'de kullanımdan kaldırıldı ve **kullanılmamaları önerilir**.\
**Herhangi bir uygulamanın verileri dinlemesine, aynı zamanda değiştirmesine olanak tanır.**

"sticky" kelimesini içeren fonksiyonlar bulursanız, örneğin **`sendStickyBroadcast`** veya **`sendStickyBroadcastAsUser`**, **etkisini kontrol edin ve bunları kaldırmaya çalışın**.

## Deep links / URL schemes

Android uygulamalarında, **deep links** bir eylemi (Intent) doğrudan bir URL aracılığıyla başlatmak için kullanılır. Bu, bir aktivite içinde belirli bir **URL şeması** tanımlanarak yapılır. Bir Android cihazı bu şemaya sahip bir **URL'ye erişmeye çalıştığında**, uygulama içindeki belirtilen aktivite başlatılır.

Şema, **`AndroidManifest.xml`** dosyasında belirtilmelidir:
```xml
[...]
<activity android:name=".MyActivity">
<intent-filter>
<action android:name="android.intent.action.VIEW" />
<category android:name="android.intent.category.DEFAULT" />
<category android:name="android.intent.category.BROWSABLE" />
<data android:scheme="examplescheme" />
</intent-filter>
[...]
```
Önceki örnekteki şema `examplescheme://` (aynı zamanda **`category BROWSABLE`**'ı da not edin)

Daha sonra, veri alanında **host** ve **path** belirtebilirsiniz:
```xml
<data android:scheme="examplescheme"
android:host="example"
/>
```
Web'den erişmek için bir bağlantı ayarlamak mümkündür:
```xml
<a href="examplescheme://example/something">click here</a>
<a href="examplescheme://example/javascript://%250dalert(1)">click here</a>
```
Uygulamada **çalıştırılacak kodu** bulmak için, derin bağlantı ile çağrılan aktiviteye gidin ve **`onNewIntent`** fonksiyonunu arayın.

HTML sayfaları kullanmadan [derin bağlantıları nasıl çağıracağınızı öğrenin](./#exploiting-schemes-deep-links).

## AIDL - Android Arayüz Tanım Dili

**Android Arayüz Tanım Dili (AIDL)**, Android uygulamalarında istemci ve hizmet arasında **işlem arası iletişim** (IPC) sağlamak için tasarlanmıştır. Android'de başka bir işlemin belleğine doğrudan erişim izni verilmediğinden, AIDL, nesneleri işletim sistemi tarafından anlaşılan bir formata marşallayarak süreci basitleştirir ve farklı işlemler arasında iletişimi kolaylaştırır.

### Temel Kavramlar

- **Bağlı Hizmetler**: Bu hizmetler IPC için AIDL kullanır, etkinliklerin veya bileşenlerin bir hizmete bağlanmasına, isteklerde bulunmasına ve yanıt almasına olanak tanır. Hizmetin sınıfındaki `onBind` metodu, etkileşimi başlatmak için kritik öneme sahiptir ve güvenlik incelemesi için zafiyet arayışında önemli bir alan olarak işaretlenmelidir.

- **Messenger**: Bağlı bir hizmet olarak çalışan Messenger, `onBind` metodunu kullanarak veri işleme odaklı IPC'yi kolaylaştırır. Bu metodun, güvensiz veri işleme veya hassas fonksiyonların yürütülmesi açısından dikkatlice incelenmesi önemlidir.

- **Binder**: Binder sınıfının doğrudan kullanımı AIDL'in soyutlaması nedeniyle daha az yaygın olsa da, Binder'ın farklı işlemlerin bellek alanları arasında veri transferini kolaylaştıran bir çekirdek düzeyinde sürücü olduğunu anlamak faydalıdır. Daha fazla bilgi için [https://www.youtube.com/watch?v=O-UHvFjxwZ8](https://www.youtube.com/watch?v=O-UHvFjxwZ8) adresine başvurabilirsiniz.

## Bileşenler

Bunlar: **Aktiviteler, Hizmetler, Yayın Alıcıları ve Sağlayıcılar.**

### Başlatıcı Aktivite ve diğer aktiviteler

Android uygulamalarında, **aktiviteler** ekranlar gibidir ve uygulamanın kullanıcı arayüzünün farklı bölümlerini gösterir. Bir uygulama birçok aktiviteye sahip olabilir, her biri kullanıcıya benzersiz bir ekran sunar.

**Başlatıcı aktivite**, bir uygulamanın simgesine dokunduğunuzda başlatılan ana geçittir. Uygulamanın manifest dosyasında belirli MAIN ve LAUNCHER niyetleri ile tanımlanmıştır:
```markup
<activity android:name=".LauncherActivity">
<intent-filter>
<action android:name="android.intent.action.MAIN" />
<category android:name="android.intent.category.LAUNCHER" />
</intent-filter>
</activity>
```
Tüm uygulamaların bir başlatıcı aktiviteye ihtiyacı yoktur, özellikle kullanıcı arayüzü olmayanlar, arka plan hizmetleri gibi.

Aktiviteler, manifestte "exported" olarak işaretlenerek diğer uygulamalara veya süreçlere sunulabilir. Bu ayar, diğer uygulamaların bu aktiviteyi başlatmasına izin verir:
```markdown
<service android:name=".ExampleExportedService" android:exported="true"/>
```
Ancak, başka bir uygulamadan bir aktiviteye erişmek her zaman bir güvenlik riski değildir. Endişe, hassas verilerin yanlış bir şekilde paylaşılması durumunda ortaya çıkar; bu da bilgi sızıntılarına yol açabilir.

Bir aktivitenin yaşam döngüsü **onCreate yöntemi ile başlar**, UI'yı kurar ve aktiviteyi kullanıcı ile etkileşim için hazırlar.

### Uygulama Alt Sınıfı

Android geliştirmede, bir uygulama **Application** sınıfının bir **alt sınıfını** oluşturma seçeneğine sahiptir, ancak bu zorunlu değildir. Böyle bir alt sınıf tanımlandığında, uygulama içinde oluşturulan ilk sınıf olur. Bu alt sınıfta uygulanmışsa, **`attachBaseContext`** yöntemi **`onCreate`** yönteminden önce çalıştırılır. Bu kurulum, uygulamanın geri kalanı başlamadan önce erken başlatma sağlar.
```java
public class MyApp extends Application {
@Override
protected void attachBaseContext(Context base) {
super.attachBaseContext(base);
// Initialization code here
}

@Override
public void onCreate() {
super.onCreate();
// More initialization code
}
}
```
### Hizmetler

[Services](https://developer.android.com/guide/components/services) **kullanıcı arayüzü olmadan** görevleri yerine getirebilen **arka plan operatörleri**dir. Bu görevler, kullanıcılar farklı uygulamalara geçse bile çalışmaya devam edebilir, bu da hizmetleri **uzun süreli işlemler** için kritik hale getirir.

Hizmetler çok yönlüdür; çeşitli şekillerde başlatılabilirler, **Intents** bunları bir uygulamanın giriş noktası olarak başlatmanın birincil yöntemidir. Bir hizmet `startService` yöntemi kullanılarak başlatıldığında, `onStart` yöntemi devreye girer ve `stopService` yöntemi açıkça çağrılana kadar çalışmaya devam eder. Alternatif olarak, bir hizmetin rolü aktif bir istemci bağlantısına bağlıysa, istemciyi hizmete bağlamak için `bindService` yöntemi kullanılır ve veri geçişi için `onBind` yöntemi devreye girer.

Hizmetlerin ilginç bir uygulaması, arka planda müzik çalma veya kullanıcının bir uygulama ile etkileşimini engellemeden ağ verisi alma gibi durumları içerir. Ayrıca, hizmetler **dışa aktarma** yoluyla aynı cihazdaki diğer süreçlere erişilebilir hale getirilebilir. Bu, varsayılan bir davranış değildir ve Android Manifest dosyasında açık bir yapılandırma gerektirir:
```xml
<service android:name=".ExampleExportedService" android:exported="true"/>
```
### Broadcast Receivers

**Broadcast receivers** mesajlaşma sisteminde dinleyici olarak işlev görür ve birden fazla uygulamanın sistemden gelen aynı mesajlara yanıt vermesine olanak tanır. Bir uygulama **iki ana yolla** **bir alıcı kaydedebilir**: uygulamanın **Manifest** dosyası aracılığıyla veya uygulamanın kodu içinde **dinamik olarak** **`registerReceiver`** API'si ile. Manifest'te, yayınlar izinlerle filtrelenirken, dinamik olarak kaydedilen alıcılar kaydedilme sırasında izinleri de belirtebilir.

**Intent filtreleri**, her iki kayıt yönteminde de kritik öneme sahiptir ve hangi yayınların alıcıyı tetikleyeceğini belirler. Eşleşen bir yayın gönderildiğinde, alıcının **`onReceive`** metodu çağrılır ve uygulamanın buna göre tepki vermesini sağlar; örneğin, düşük pil uyarısına yanıt olarak davranışını ayarlamak gibi.

Yayınlar **asenkron** olabilir, tüm alıcılara sırasız ulaşır veya **senkron** olabilir, burada alıcılar belirlenen önceliklere göre yayını alır. Ancak, herhangi bir uygulamanın kendisini önceliklendirebileceği ve bir yayını kesebileceği potansiyel güvenlik riskini not etmek önemlidir.

Bir alıcının işlevselliğini anlamak için, sınıfı içinde **`onReceive`** metodunu arayın. Bu metodun kodu, alınan Intent'i manipüle edebilir ve alıcıların veri doğrulama ihtiyacını vurgular; özellikle **Sıralı Yayınlar**'da, bu Intent'i değiştirebilir veya düşürebilir.

### Content Provider

**Content Providers**, uygulamalar arasında **yapılandırılmış verilerin paylaşımı** için gereklidir ve veri güvenliğini sağlamak için **izinlerin** uygulanmasının önemini vurgular. Uygulamalara veritabanları, dosya sistemleri veya web gibi çeşitli kaynaklardan verilere erişim sağlar. **`readPermission`** ve **`writePermission`** gibi belirli izinler, erişimi kontrol etmek için kritik öneme sahiptir. Ayrıca, uygulamanın manifestinde **`grantUriPermission`** ayarları aracılığıyla geçici erişim sağlanabilir; `path`, `pathPrefix` ve `pathPattern` gibi nitelikler detaylı erişim kontrolü için kullanılır.

Girdi doğrulaması, SQL enjeksiyonu gibi güvenlik açıklarını önlemek için çok önemlidir. Content Providers, veri manipülasyonu ve uygulamalar arasında paylaşımı kolaylaştıran temel işlemleri destekler: `insert()`, `update()`, `delete()` ve `query()`.

**FileProvider**, dosyaları güvenli bir şekilde paylaşmaya odaklanan özel bir Content Provider'dır. Erişimi kontrol etmek için belirli niteliklerle uygulamanın manifestinde tanımlanır; bu nitelikler `android:exported` ve klasör yapılandırmalarını gösteren `android:resource` ile belirtilir. Hassas verilerin yanlışlıkla ifşa edilmesini önlemek için dizinleri paylaşırken dikkatli olunmalıdır.

FileProvider için örnek manifest bildirimi:
```xml
<provider android:name="androidx.core.content.FileProvider"
android:authorities="com.example.myapp.fileprovider"
android:grantUriPermissions="true"
android:exported="false">
<meta-data android:name="android.support.FILE_PROVIDER_PATHS"
android:resource="@xml/filepaths" />
</provider>
```
Ve `filepaths.xml` dosyasında paylaşılan klasörleri belirtmenin bir örneği:
```xml
<paths>
<files-path path="images/" name="myimages" />
</paths>
```
Daha fazla bilgi için kontrol edin:

- [Android Developers: Content Providers](https://developer.android.com/guide/topics/providers/content-providers)
- [Android Developers: FileProvider](https://developer.android.com/training/secure-file-sharing/setup-sharing)

## WebViews

WebViews, Android uygulamaları içinde **mini web tarayıcıları** gibidir ve içerikleri ya webden ya da yerel dosyalardan çeker. Normal tarayıcılarla benzer risklerle karşılaşırlar, ancak belirli **ayarlar** aracılığıyla bu **riskleri azaltmanın** yolları vardır.

Android, iki ana WebView türü sunar:

- **WebViewClient**, temel HTML için harikadır ancak JavaScript uyarı fonksiyonunu desteklemez, bu da XSS saldırılarının nasıl test edileceğini etkiler.
- **WebChromeClient**, tam Chrome tarayıcı deneyimine daha yakın bir şekilde çalışır.

Önemli bir nokta, WebView tarayıcılarının cihazın ana tarayıcısıyla **çerez paylaşmamasıdır**.

İçerik yüklemek için `loadUrl`, `loadData` ve `loadDataWithBaseURL` gibi yöntemler mevcuttur. Bu URL'lerin veya dosyaların **kullanım için güvenli** olduğundan emin olmak kritik öneme sahiptir. Güvenlik ayarları `WebSettings` sınıfı aracılığıyla yönetilebilir. Örneğin, `setJavaScriptEnabled(false)` ile JavaScript'in devre dışı bırakılması, XSS saldırılarını önleyebilir.

JavaScript "Bridge", Java nesnelerinin JavaScript ile etkileşimde bulunmasına olanak tanır ve Android 4.2'den itibaren güvenlik için yöntemlerin `@JavascriptInterface` ile işaretlenmesi gerekmektedir.

İçerik erişimine izin vermek (`setAllowContentAccess(true)`), WebView'ların Content Providers'a ulaşmasına olanak tanır; bu, içerik URL'leri güvenli olarak doğrulanmadıkça bir risk oluşturabilir.

Dosya erişimini kontrol etmek için:

- Dosya erişimini devre dışı bırakmak (`setAllowFileAccess(false)`), dosya sistemine erişimi sınırlar; belirli varlıklar için istisnalarla, yalnızca hassas olmayan içerikler için kullanılmasını sağlar.

## Diğer Uygulama Bileşenleri ve Mobil Cihaz Yönetimi

### **Uygulamaların Dijital İmzalanması**

- **Dijital imzalama**, Android uygulamaları için zorunludur ve uygulamaların kurulumdan önce **gerçekten yazıldığı** garantisini sağlar. Bu süreç, uygulama kimliği için bir sertifika kullanır ve kurulum sırasında cihazın paket yöneticisi tarafından doğrulanmalıdır. Uygulamalar **kendinden imzalı veya harici bir CA tarafından sertifikalandırılmış** olabilir, yetkisiz erişime karşı koruma sağlar ve uygulamanın cihaza teslimatı sırasında değiştirilmediğini garanti eder.

### **Gelişmiş Güvenlik için Uygulama Doğrulaması**

- **Android 4.2**'den itibaren, **Uygulamaları Doğrula** adlı bir özellik, kullanıcıların uygulamaların güvenliğini kurulumdan önce kontrol etmelerine olanak tanır. Bu **doğrulama süreci**, kullanıcıları potansiyel olarak zararlı uygulamalar hakkında uyarabilir veya özellikle kötü niyetli olanların kurulumunu engelleyebilir, kullanıcı güvenliğini artırır.

### **Mobil Cihaz Yönetimi (MDM)**

- **MDM çözümleri**, **Cihaz Yönetimi API'si** aracılığıyla mobil cihazlar için **denetim ve güvenlik** sağlar. Mobil cihazları etkili bir şekilde yönetmek ve güvence altına almak için bir Android uygulamasının kurulmasını gerektirir. Ana işlevler arasında **şifre politikalarının uygulanması**, **depolama şifrelemesinin zorunlu kılınması** ve **uzaktan veri silme izni verme** bulunur; bu da mobil cihazlar üzerinde kapsamlı kontrol ve güvenlik sağlar.
```java
// Example of enforcing a password policy with MDM
DevicePolicyManager dpm = (DevicePolicyManager) getSystemService(Context.DEVICE_POLICY_SERVICE);
ComponentName adminComponent = new ComponentName(context, AdminReceiver.class);

if (dpm.isAdminActive(adminComponent)) {
// Set minimum password length
dpm.setPasswordMinimumLength(adminComponent, 8);
}
```
{{#include ../../banners/hacktricks-training.md}}
