# React Native Uygulama Analizi

{{#include ../../banners/hacktricks-training.md}}

Uygulamanın React Native çerçevesinde inşa edilip edilmediğini doğrulamak için şu adımları izleyin:

1. APK dosyasını zip uzantısıyla yeniden adlandırın ve `cp com.example.apk example-apk.zip` ve `unzip -qq example-apk.zip -d ReactNative` komutunu kullanarak yeni bir klasöre çıkarın.

2. Yeni oluşturulan ReactNative klasörüne gidin ve assets klasörünü bulun. Bu klasörün içinde, minify edilmiş formatta React JavaScript içeren `index.android.bundle` dosyasını bulmalısınız.

3. JavaScript dosyasını aramak için `find . -print | grep -i ".bundle$"` komutunu kullanın.

Not: Eğer bir APK yerine bir Android App Bundle (.aab) verildiyse, önce evrensel bir APK oluşturun ve ardından bundle'ı çıkarın:
```bash
# Get bundletool.jar and generate a universal APK set
java -jar bundletool.jar build-apks \
--bundle=app-release.aab \
--output=app.apks \
--mode=universal \
--overwrite

# Extract the APK and then unzip it to find assets/index.android.bundle
unzip -p app.apks universal.apk > universal.apk
unzip -qq universal.apk -d ReactNative
ls ReactNative/assets/
```
## Javascript Kodu

Eğer `index.android.bundle` içeriğini kontrol ederseniz, uygulamanın JavaScript kodunu (minify edilmiş olsa bile) bulabilirsiniz, bu kodu **hassas bilgileri ve güvenlik açıklarını bulmak için analiz edebilirsiniz**.

Bundle, aslında uygulamanın tüm JS kodunu içerdiğinden, **onu farklı dosyalara ayırmak mümkündür** (bu, ters mühendisliğini kolaylaştırabilir) **[react-native-decompiler](https://github.com/numandev1/react-native-decompiler)** aracını kullanarak.

### Webpack

JavaScript kodunu daha fazla analiz etmek için, dosyayı [https://spaceraccoon.github.io/webpack-exploder/](https://spaceraccoon.github.io/webpack-exploder/) yükleyebilir veya şu adımları izleyebilirsiniz:

1. Aynı dizinde `index.html` adında bir dosya oluşturun ve aşağıdaki kodu ekleyin:
```html
<script src="./index.android.bundle"></script>
```
2. `index.html` dosyasını Google Chrome'da açın.

3. **OS X için Command+Option+J** veya **Windows için Control+Shift+J** tuşlarına basarak Geliştirici Araç Çubuğunu açın.

4. Geliştirici Araç Çubuğunda "Sources" sekmesine tıklayın. Ana paketi oluşturan klasörler ve dosyalar halinde bölünmüş bir JavaScript dosyası görmelisiniz.

Eğer `index.android.bundle.map` adında bir dosya bulursanız, kaynak kodunu minify edilmemiş formatta analiz edebilirsiniz. Harita dosyaları, minify edilmiş tanımlayıcıları eşleştirmenizi sağlayan kaynak eşleştirmesi içerir.

Hassas kimlik bilgileri ve uç noktaları aramak için bu adımları izleyin:

1. JavaScript kodunu analiz etmek için hassas anahtar kelimeleri belirleyin. React Native uygulamaları genellikle Firebase, AWS S3 hizmet uç noktaları, özel anahtarlar gibi üçüncü taraf hizmetler kullanır.

2. Bu özel durumda, uygulamanın Dialogflow hizmetini kullandığı gözlemlendi. Yapılandırmasıyla ilgili bir desen arayın.

3. Recon süreci sırasında JavaScript kodunda hassas sabit kodlanmış kimlik bilgileri bulunduğu için şanslıydık.

### Paketlerde hızlı gizli/uc nokta avı

Bu basit grep'ler genellikle minify edilmiş JS'de bile ilginç göstergeleri ortaya çıkarır:
```bash
# Common backends and crash reporters
strings -n 6 index.android.bundle | grep -Ei "(api\.|graphql|/v1/|/v2/|socket|wss://|sentry\.io|bugsnag|appcenter|codepush|firebaseio\.com|amplify|aws)"

# Firebase / Google keys (heuristics)
strings -n 6 index.android.bundle | grep -Ei "(AIza[0-9A-Za-z_-]{35}|AIzaSy[0-9A-Za-z_-]{33})"

# AWS access key id heuristic
strings -n 6 index.android.bundle | grep -E "AKIA[0-9A-Z]{16}"

# Expo/CodePush deployment keys
strings -n 6 index.android.bundle | grep -Ei "(CodePush|codepush:\\/\\/|DeploymentKey)"

# Sentry DSN
strings -n 6 index.android.bundle | grep -Ei "(Sentry\.init|dsn\s*:)"
```
Eğer Over-The-Air güncelleme çerçevelerinden şüpheleniyorsanız, ayrıca şunları arayın:
- Microsoft App Center / CodePush dağıtım anahtarları
- Expo EAS Updates yapılandırması (`expo-updates`, `expo\.io`, imzalama sertifikaları)

### JS kodunu değiştirin ve yeniden derleyin

Bu durumda kodu değiştirmek kolaydır. Uygulamayı `.zip` uzantısıyla yeniden adlandırmanız ve çıkarmanız yeterlidir. Ardından, **bu paket içindeki JS kodunu değiştirebilir ve uygulamayı yeniden derleyebilirsiniz**. Bu, test amaçları için uygulamaya **kod enjekte etmenize** yetecektir.

## Hermes bytecode

Eğer paket **Hermes bytecode** içeriyorsa, uygulamanın Javascript koduna **erişemeyeceksiniz** (hatta minify edilmiş versiyonuna bile).

Paketin Hermes bytecode içerip içermediğini kontrol etmek için aşağıdaki komutu çalıştırabilirsiniz:
```bash
file index.android.bundle
index.android.bundle: Hermes JavaScript bytecode, version 96
```
Ancak, **[hbctool](https://github.com/bongtrop/hbctool)**, daha yeni bytecode sürümlerini destekleyen hbctool'ün güncellenmiş forklari, **[hasmer](https://github.com/lucasbaizer2/hasmer)**, **[hermes_rs](https://github.com/Pilfer/hermes_rs)** (Rust kütüphanesi/API'leri) veya **[hermes-dec](https://github.com/P1sec/hermes-dec)** araçlarını kullanarak **bytecode'u ayrıştırabilir** ve ayrıca **bunu bazı sahte JS kodlarına decompile edebilirsiniz**. Örneğin:
```bash
# Disassemble and re-assemble with hbctool (works only for supported HBC versions)
hbctool disasm ./index.android.bundle ./hasm_out
# ...edit ./hasm_out/**/*.hasm (e.g., change comparisons, constants, feature flags)...
hbctool asm   ./hasm_out ./index.android.bundle

# Using hasmer (focus on disassembly; assembler/decompiler are WIP)
hasmer disasm ./index.android.bundle -o hasm_out

# Using hermes-dec to produce pseudo-JS
hbc-disassembler ./index.android.bundle /tmp/my_output_file.hasm
hbc-decompiler   ./index.android.bundle /tmp/my_output_file.js
```
İpucu: Açık kaynak Hermes projesi, belirli Hermes sürümlerinde `hbcdump` gibi geliştirici araçları da sunar. Paket oluşturmak için kullanılan eşleşen Hermes sürümünü oluşturursanız, `hbcdump` fonksiyonları, dize tablolarını ve daha derin analiz için bytecode'u dökebilir.

### Kodu Değiştir ve Yeniden Oluştur (Hermes)

İdeal olarak, ayrıştırılmış kodu (bir karşılaştırmayı, bir değeri veya değiştirmeniz gereken her neyse) değiştirebilmelisiniz ve ardından **bytecode'u yeniden oluşturup** uygulamayı yeniden inşa etmelisiniz.

- Orijinal **[hbctool](https://github.com/bongtrop/hbctool)**, paketi ayrıştırmayı ve değişikliklerden sonra geri inşa etmeyi destekler, ancak tarihsel olarak yalnızca daha eski bytecode sürümlerini desteklemiştir. Topluluk tarafından bakımı yapılan çatallar, daha yeni Hermes sürümlerine (orta 80'ler–96 dahil) destek sağlar ve genellikle modern RN uygulamalarını yamanın en pratik seçeneğidir.
- **[hermes-dec](https://github.com/P1sec/hermes-dec)** aracı bytecode'u yeniden inşa etmeyi desteklemez (yalnızca decompiler/ayrıştırıcıdır), ancak mantığı gezmek ve dizeleri dökmek için çok yardımcıdır.
- **[hasmer](https://github.com/lucasbaizer2/hasmer)** aracı, birden fazla Hermes sürümü için hem ayrıştırma hem de montajı desteklemeyi hedefler; montaj hala olgunlaşmaktadır ancak son bytecode üzerinde denemeye değer.

hbctool benzeri montajcılarla minimal bir iş akışı:
```bash
# 1) Disassemble to HASM directories
hbctool disasm assets/index.android.bundle ./hasm

# 2) Edit a guard or feature flag (example: force boolean true)
#    In the relevant .hasm, replace a LoadConstUInt8 0 with 1
#    or change a conditional jump target to bypass a check.

# 3) Reassemble into a new bundle
hbctool asm ./hasm assets/index.android.bundle

# 4) Repack the APK and resign
zip -r ../patched.apk *
# Align/sign as usual (see Android signing section in HackTricks)
```
Not edin ki Hermes bytecode formatı sürümlüdür ve derleyici tam olarak disk üzerindeki formatla eşleşmelidir. Format hataları alırsanız, güncellenmiş bir fork/alternatife geçin veya eşleşen Hermes araçlarını yeniden inşa edin.

## Dinamik Analiz

Uygulamayı dinamik olarak analiz etmeye çalışmanın bir yolu, Frida'yı kullanarak React uygulamasının geliştirici modunu etkinleştirmek ve **`react-native-debugger`** ile ona bağlanmaktır. Ancak, bunun için uygulamanın kaynak koduna ihtiyacınız var gibi görünüyor. Bununla ilgili daha fazla bilgi bulabilirsiniz [https://newsroom.bedefended.com/hooking-react-native-applications-with-frida/](https://newsroom.bedefended.com/hooking-react-native-applications-with-frida/).

### Frida ile sürümde Geliştirici Desteğini Etkinleştirme (uyarılar)

Bazı uygulamalar, Geliştirici Desteğini açıp kapatmayı sağlayan sınıfları yanlışlıkla gönderir. Eğer mevcutsa, `getUseDeveloperSupport()`'un true döndürmesini zorlamayı deneyebilirsiniz:
```javascript
// frida -U -f com.target.app -l enable-dev.js
Java.perform(function(){
try {
var Host = Java.use('com.facebook.react.ReactNativeHost');
Host.getUseDeveloperSupport.implementation = function(){
return true; // force dev support
};
console.log('[+] Patched ReactNativeHost.getUseDeveloperSupport');
} catch (e) {
console.log('[-] Could not patch: ' + e);
}
});
```
Uyarı: Doğru bir şekilde oluşturulmuş sürüm derlemelerinde, `DevSupportManagerImpl` ve ilgili yalnızca hata ayıklama sınıfları kaldırılır ve bu bayrağı değiştirmek uygulamayı çökertir veya hiçbir etkisi olmayabilir. Bu çalıştığında, genellikle geliştirici menüsünü açabilir ve hata ayıklayıcıları/denetleyicileri bağlayabilirsiniz.

### RN uygulamalarında ağ kesintisi

React Native Android genellikle arka planda OkHttp'ye dayanır ( `Networking` yerel modülü aracılığıyla). Dinamik testler sırasında köklenmemiş bir cihazda trafiği kesmek/gözlemlemek için:
- Sistem proxy'si kullanın + kullanıcı CA'sına güvenin veya diğer genel Android TLS atlatma tekniklerini kullanın.
- RN'e özgü ipucu: uygulama yanlışlıkla (hata ayıklama araçları) Flipper'ı sürümde paketliyorsa, Flipper Ağ eklentisi istekleri/yanıtları açığa çıkarabilir.

Genel Android kesintisi ve pinleme atlatma teknikleri için bakınız:

{{#ref}}
make-apk-accept-ca-certificate.md
{{#endref}}

{{#ref}}
frida-tutorial/objection-tutorial.md
{{#endref}}

## Popüler RN kütüphanelerindeki son sorunlar (nelere dikkat edilmeli)

JS paketinde veya yerel kütüphanelerde görünen üçüncü taraf modüllerini denetlerken, bilinen güvenlik açıklarını kontrol edin ve `package.json`/`yarn.lock` içindeki sürümleri doğrulayın.

- react-native-mmkv (Android): 2.11.0'dan önceki sürümler, isteğe bağlı şifreleme anahtarını Android günlüklerine kaydetti. ADB/logcat mevcutsa, gizli bilgiler kurtarılabilir. >= 2.11.0 olduğundan emin olun. Göstergeler: `react-native-mmkv` kullanımı, şifreleme ile MMKV başlatma ile ilgili günlük ifadeleri. CVE-2024-21668.
- react-native-document-picker: sürümler < 9.1.1, Android'de yol geçişine karşı savunmasızdı (dosya seçimi), 9.1.1'de düzeltildi. Girdileri ve kütüphane sürümünü doğrulayın.

Hızlı kontroller:
```bash
grep -R "react-native-mmkv" -n {index.android.bundle,*.map} 2>/dev/null || true
grep -R "react-native-document-picker" -n {index.android.bundle,*.map} 2>/dev/null || true
# If you also have the node_modules (rare on release): grep -R in package.json / yarn.lock
```
## Referanslar

- [https://medium.com/bugbountywriteup/lets-know-how-i-have-explored-the-buried-secrets-in-react-native-application-6236728198f7](https://medium.com/bugbountywriteup/lets-know-how-i-have-explored-the-buried-secrets-in-react-native-application-6236728198f7)
- [https://www.assetnote.io/resources/research/expanding-the-attack-surface-react-native-android-applications](https://www.assetnote.io/resources/research/expanding-the-attack-surface-react-native-android-applications)
- [https://payatu.com/wp-content/uploads/2023/02/Mastering-React-Native-Application-Pentesting-A-Practical-Guide-2.pdf](https://payatu.com/wp-content/uploads/2023/02/Mastering-React-Native-Application-Pentesting-A-Practical-Guide-2.pdf)
- CVE-2024-21668: react-native-mmkv Android'da şifreleme anahtarını günlüğe kaydediyor, v2.11.0'da düzeltildi (NVD): https://nvd.nist.gov/vuln/detail/CVE-2024-21668
- hbctool (ve çatalları) Hermes için montaj/dağıtım: https://github.com/bongtrop/hbctool

{{#include ../../banners/hacktricks-training.md}}
