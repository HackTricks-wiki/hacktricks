# Android 应用 Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android 应用 基础

强烈建议先阅读此页面，以了解与 Android security 相关的**最重要部分以及 Android 应用 中最危险的组件**：


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

这是连接 Android 设备（模拟或物理）所需的主要工具。\
**ADB** 允许从计算机通过 **USB** 或 **Network** 控制设备。该实用程序支持双向文件的 **copying**、应用的 **installation** 和 **uninstallation**、shell 命令的 **execution**、数据的 **backing up**、日志的 **reading**，以及其他功能。

查看以下 [**ADB Commands**](adb-commands.md) 列表以学习如何使用 adb。

## Smali

有时修改应用代码以访问**隐藏信息**（例如高度混淆的密码或 flags）非常有用。此时，反编译 apk、修改代码并重新编译可能是个不错的选择。\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md)。这在进行动态分析时可作为若干测试的替代方法非常有用。因此，请始终记住这个可能性。

## Other interesting tricks

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- 从设备提取 APK：
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- 使用 [APKEditor](https://github.com/REAndroid/APKEditor) 合并所有 splits 和 base apks：
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## 案例研究与漏洞


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## 静态分析

首先，在分析 APK 时，你应该使用反编译器**查看 Java 代码**。\
请[**在此阅读以获取关于不同可用反编译器的信息**](apk-decompilers.md)。

### 查找有价值的信息

仅查看 APK 的 **strings** 就可以搜索 **密码**、**URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep))、**api** keys、**encryption**、**bluetooth uuids**、**tokens** 以及任何有趣的东西……甚至查找代码执行的 **backdoors** 或身份验证后门（应用的硬编码管理员凭据）。

**Firebase**

特别注意 **Firebase URLs** 并检查其是否配置不当。[更多关于什么是 Firebase 以及如何利用它的信息在此。](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### 对应用的基本理解 - Manifest.xml, strings.xml

**检查应用的 _Manifest.xml_ 和 **_strings.xml_** 文件可以揭示潜在的安全漏洞**。这些文件可以通过反编译器访问，或者将 APK 扩展名重命名为 .zip 然后解压来获取。

从 **Manifest.xml** 中可识别的 **漏洞** 包括：

- **可调试的应用**：在 _Manifest.xml_ 文件中被设置为 debuggable (`debuggable="true"`) 的应用存在风险，因为它们允许连接，可能导致被利用。有关如何在设备上发现和利用可调试应用的更多信息，请参阅相关教程。
- **备份设置**：对于处理敏感信息的应用，应显式将 `android:allowBackup="false"` 属性设置为 false，以防止在 usb debugging 启用时通过 adb 非授权备份数据。
- **网络安全**：位于 _res/xml/_ 的自定义网络安全配置（`android:networkSecurityConfig="@xml/network_security_config"`）可以指定证书 pin、HTTP 流量设置等安全细节。例如，为特定域名允许 HTTP 流量。
- **导出 Activities 和 Services**：识别 manifest 中导出的 activities 和 services 可以突出可能被滥用的组件。动态测试期间的进一步分析可以揭示如何利用这些组件。
- **Content Providers 与 FileProviders**：暴露的 content providers 可能允许未授权访问或修改数据。FileProviders 的配置也应仔细审查。
- **Broadcast Receivers 和 URL Schemes**：这些组件可能被用于利用，特别要关注 URL schemes 如何处理输入以防止漏洞利用。
- **SDK 版本**：`minSdkVersion`、`targetSDKVersion` 和 `maxSdkVersion` 属性表明支持的 Android 版本，强调不要支持已过时且存在漏洞的 Android 版本以保证安全。

从 **strings.xml** 文件中，可以发现敏感信息，例如 API keys、自定义 schema 以及其他开发者注释，这强调了对这些资源进行仔细审查的必要性。

### Tapjacking

**Tapjacking** 是一种攻击，攻击者启动一个**恶意** **应用**并**将其放置在受害应用之上**。一旦它在视觉上遮挡了受害应用，其用户界面会被设计成以欺骗用户与之交互，同时将交互传递给受害应用。\
实际上，它是**使用户看不见他们实际上正在对受害应用执行操作**。

更多信息见：


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

一个将 **`launchMode`** 设置为 **`singleTask` 且未定义 `taskAffinity`** 的 **activity** 易受 task Hijacking 攻击。这意味着，如果在真实应用之前安装并启动一个**应用**，它可能**劫持真实应用的 task**（因此用户会与**恶意应用交互而误以为是在使用真实应用**）。

更多信息见：


{{#ref}}
android-task-hijacking.md
{{#endref}}

### 不安全的数据存储

**内部存储**

在 Android 中，存储在 **内部** 存储的文件设计为仅能被**创建它们的应用**访问。该安全措施由 Android 操作系统强制执行，通常足以满足大多数应用的安全需求。然而，开发者有时会使用诸如 `MODE_WORLD_READABLE` 和 `MODE_WORLD_WRITABLE` 的模式来**允许**文件在不同应用之间**共享**。但这些模式**并不限制其他应用对这些文件的访问**，包括潜在的恶意应用。

1. **静态分析：**
- **仔细审查** `MODE_WORLD_READABLE` 和 `MODE_WORLD_WRITABLE` 的使用。这些模式**可能会将文件暴露给意外或未授权的访问**。
2. **动态分析：**
- **验证**应用创建的文件的**权限**。特别是，**检查**是否有任何文件被设置为全局可读或可写。这会带来显著的安全风险，因为它将允许**任何安装在设备上的应用**（无论来源或意图）**读取或修改**这些文件。

**外部存储**

处理外部存储（例如 SD 卡）上的文件时，应注意以下事项：

1. **可访问性**：
- 外部存储上的文件是**全局可读可写**的，这意味着任何应用或用户都可以访问这些文件。
2. **安全问题**：
- 鉴于易访问性，建议**不要在外部存储上保存敏感信息**。
- 外部存储可以被移除或被任意应用访问，因此安全性较低。
3. **处理来自外部存储的数据**：
- 对从外部存储检索的数据始终**执行输入验证**。这是至关重要的，因为这些数据来自不受信任的来源。
- 强烈不建议在外部存储上存放可执行文件或 class 文件以进行动态加载。
- 如果应用必须从外部存储检索可执行文件，确保这些文件在动态加载前**经过签名和加密验证**。这是维护应用安全完整性的关键一步。

外部存储可在 /storage/emulated/0 、 /sdcard 、 /mnt/sdcard 访问

> [!TIP]
> 从 Android 4.4 (**API 17**) 开始，SD 卡具有目录结构，**将应用的访问限制在专门为该应用准备的目录内**。这可防止恶意应用获得对其他应用文件的读写访问。

**明文存储的敏感数据**

- **Shared preferences**：Android 允许每个应用轻松在路径 `/data/data/<packagename>/shared_prefs/` 保存 xml 文件，有时可以在该文件夹中以明文发现敏感信息。
- **Databases**：Android 允许每个应用轻松在路径 `/data/data/<packagename>/databases/` 保存 sqlite 数据库，有时可以在该文件夹中以明文发现敏感信息。

### Broken TLS

**Accept All Certificates**

出于某些原因，有时开发者会接受所有证书，即使例如 hostname 不匹配，也会用像下面这样的代码来处理：
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Broken Cryptography

**Poor Key Management Processes**

有些开发者会把敏感数据保存在本地存储并用硬编码/可预测的密钥在代码中加密。这样不应该做，因为逆向工程可能让攻击者提取机密信息。

**Use of Insecure and/or Deprecated Algorithms**

开发者不应使用 **deprecated algorithms** 来执行授权 **checks**、**store** 或 **send** 数据。其中一些算法有：RC4, MD4, MD5, SHA1... 如果用 **hashes** 来存储密码，例如，应使用带 salt 的抗暴力破解 **resistant** 哈希算法。

### Other checks

- 建议 **obfuscate the APK**，以增加逆向工程的难度。
- 如果应用是敏感的（如银行类应用），它应当执行它自己的检查来判断手机是否 **rooted** 并据此采取措施。
- 如果应用是敏感的（如银行类应用），它应检测是否在使用 **emulator**。
- 如果应用是敏感的（如银行类应用），它应在执行前 **check it's own integrity before executing** 以检测是否被修改。
- 使用 [**APKiD**](https://github.com/rednaga/APKiD) 来检查用哪个 compiler/packer/obfuscator 构建了 APK

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

The tool [**mariana-trench**](https://github.com/facebook/mariana-trench) is capable of finding **vulnerabilities** by **scanning** the **code** of the application. This tool contains a series of **known sources** (that indicates to the tool the **places** where the **input** is **controlled by the user**), **sinks** (which indicates to the tool **dangerous** **places** where malicious user input could cause damages) and **rules**. These rules indicates the **combination** of **sources-sinks** that indicates a vulnerability.

With this knowledge, **mariana-trench will review the code and find possible vulnerabilities on it**.

### Secrets leaked

An application may contain secrets (API keys, passwords, hidden urls, subdomains...) inside of it that you might be able to discover. You could us a tool such as [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> First of all, you need an environment where you can install the application and all the environment (Burp CA cert, Drozer and Frida mainly). Therefore, a rooted device (emulated or not) is extremely recommended.

### Online Dynamic analysis

You can create a **free account** in: [https://appetize.io/](https://appetize.io). This platform allows you to **upload** and **execute** APKs, so it is useful to see how an apk is behaving.

You can even **see the logs of your application** in the web and connect through **adb**.

![](<../../images/image (831).png>)

Thanks to the ADB connection you can use **Drozer** and **Frida** inside the emulators.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (You can create **x86** and **arm** devices, and according to [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** versions **support ARM libraries** without needing an slow arm emulator).
- Learn to set it up in this page:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, you need to create an account. _It's recommend to **download** the version **WITH**_ _**VirtualBox** to avoid potential errors._)
- [**Nox**](https://es.bignox.com) (Free, but it doesn't support Frida or Drozer).

> [!TIP]
> 创建任何平台上的新 emulator 时请记住，屏幕越大，emulator 运行越慢。如果可能请选择小屏幕。

To **install google services** (like AppStore) in Genymotion you need to click on the red marked button of the following image:

![](<../../images/image (277).png>)

Also, notice that in the **configuration of the Android VM in Genymotion** you can select **Bridge Network mode** (this will be useful if you will be connecting to the Android VM from a different VM with the tools).

#### Use a physical device

You need to activate the **debugging** options and it will be cool if you can **root** it:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Once you have installed the application, the first thing you should do is to try it and investigate what does it do, how does it work and get comfortable with it.\
> I will suggest to **perform this initial dynamic analysis using MobSF dynamic analysis + pidcat**, so we will be able to **learn how the application works** while MobSF **captures** a lot of **interesting** **data** you can review later on.

Magisk/Zygisk quick notes (recommended on Pixel devices)
- Patch boot.img with the Magisk app and flash via fastboot to get systemless root
- Enable Zygisk + DenyList for root hiding; consider LSPosed/Shamiko when stronger hiding is required
- Keep original boot.img to recover from OTA updates; re-patch after each OTA
- For screen mirroring, use scrcpy on the host



### Unintended Data Leakage

**Logging**

开发者应谨慎避免将 **debugging information** 暴露出去，因为这可能导致敏感数据 leak。推荐使用工具 [**pidcat**](https://github.com/JakeWharton/pidcat) 和 `adb logcat` 来监控应用日志，以识别并保护敏感信息。**Pidcat** 因其易用性和可读性更受推崇。

> [!WARNING]
> 请注意，从 **later newer than Android 4.0** 开始，**applications are only able to access their own logs**。所以应用无法访问其他应用的日志。\
> 无论如何，仍建议 **not log sensitive information**。

**Copy/Paste Buffer Caching**

Android 的 **clipboard-based** 框架支持应用之间的复制粘贴功能，但存在风险，因为 **other applications** 可以 **access** 剪贴板，可能泄露敏感数据。对于应用中的敏感区域（如信用卡信息），应禁用复制/粘贴功能以防止数据 leak。

**Crash Logs**

如果应用 **crashes** 并 **saves logs**，这些日志可能帮助攻击者，尤其是在应用无法被逆向时。为降低风险，尽量避免在崩溃时记录日志；如果必须通过网络传输日志，确保使用 SSL 通道。

作为 pentester，**try to take a look to these logs**。

**Analytics Data Sent To 3rd Parties**

应用通常集成类似 Google Adsense 的服务，如果实现不当，可能会不经意间泄露敏感数据。为识别潜在的数据泄露，建议 **intercept the application's traffic** 并检查是否有敏感信息被发送给第三方服务。

### SQLite DBs

大多数应用会使用 **internal SQLite databases** 来保存信息。在 pentest 过程中，检查所创建的 **databases**、**tables** 和 **columns** 的名称以及保存的所有 **data**，因为你可能会发现 **sensitive information**（这将构成漏洞）。\
数据库通常位于 `/data/data/the.package.name/databases`，例如 `/data/data/com.mwr.example.sieve/databases`

如果数据库保存机密信息且 **encrypted**，但你能在应用中 **find** 到 **password**，这仍然是一个 **vulnerability**。

使用 `.tables` 列出表，使用 `.schema <table_name>` 列出表的列。

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer is s useful tool to **exploit exported activities, exported services and Content Providers** as you will learn in the following sections.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Also remember that the code of an activity starts in the **`onCreate`** method.

**Authorisation bypass**

When an Activity is exported you can invoke its screen from an external app. Therefore, if an activity with **sensitive information** is **exported** you could **bypass** the **authentication** mechanisms **to access it.**

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

You can also start an exported activity from adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> 请注意，authorisation bypass 并不总是漏洞，这取决于 bypass 的工作方式以及暴露了哪些信息。

**敏感信息泄露**

**Activities can also return results**. 如果你能找到一个 exported 且未受保护的 activity 调用 **`setResult`** 方法并 **返回敏感信息**，则存在敏感信息泄露。

#### Tapjacking

如果没有防止 Tapjacking，你可以滥用 exported activity 使用户执行意外的操作。有关 Tapjacking 的更多信息，请参见 [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers 基本上用于 **共享数据**。如果应用有可用的 content providers，你可能能够从中 **提取敏感** 数据。也很有必要测试可能的 **SQL injections** 和 **Path Traversals**，因为它们可能存在漏洞。

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
请记住，Service 的动作在方法 `onStartCommand` 中开始。

Service 基本上是能够 **接收数据**、**处理** 它并 **返回**（或不返回）响应的东西。因此，如果应用导出了某些 services，应该 **检查** 其 **代码** 来了解它在做什么，并 **动态测试** 以提取机密信息、绕过认证措施等。\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
请记住，Broadcast Receiver 的动作在方法 `onReceive` 中开始。

Broadcast receiver 会等待某种类型的消息。取决于接收器如何处理该消息，它可能存在漏洞。\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

你可以手动查找 deep links，使用像 MobSF 这样的工具或像 [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py)。\
你可以使用 **adb** 或 **browser** 打开已声明的 **scheme**：
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_注意，你可以 **omit the package name**，手机会自动调用应该打开该链接的 app。_
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**执行的代码**

为了找到 **将会在 App 中执行的代码**，转到由 deeplink 调用的 activity 并搜索函数 **`onNewIntent`**。

![](<../../images/image (436) (1) (1) (1).png>)

**敏感信息**

每次发现 deep link 时，请检查 i**它是否没有通过 URL 参数 接收敏感数据（例如密码）**，因为任何其他应用都可能 **冒充 deep link 并窃取这些数据！**

**路径中的参数**

你 **还必须检查是否有任何 deep link 在 URL 的路径中使用参数**，例如：`https://api.example.com/v1/users/{username}`，在这种情况下你可以通过访问类似 `example://app/users?username=../../unwanted-endpoint%3fparam=value` 的路径来强制进行路径遍历。\
注意，如果你在应用内找到正确的 endpoints，你可能能够导致 **Open Redirect**（如果路径的一部分被用作域名）、**account takeover**（如果你能够在没有 CSRF token 的情况下修改用户详情，并且 vuln endpoint 使用了正确的方法）以及其他任何 vuln。更多 [info about this here](http://dphoeniixx.com/2020/12/13-2/)。

**更多示例**

一个关于链接（_/.well-known/assetlinks.json_）的有趣的 bug bounty 报告：[https://hackerone.com/reports/855618](https://hackerone.com/reports/855618)。

### 传输层检测与验证失败

- **证书并不总是被正确检查**：Android 应用常常忽略警告并接受自签名证书，或者在某些情况下回退到使用 HTTP 连接。
- **SSL/TLS 握手期间的协商有时很弱**，使用不安全的 cipher suites。这会使连接容易受到 man-in-the-middle (MITM) 攻击，允许攻击者解密数据。
- **私有信息泄露** 是一种风险，当应用使用安全通道进行认证，但随后在其他事务上通过非安全通道通信时。这种做法无法保护敏感数据，例如 session cookies 或用户详情，免遭恶意实体拦截。

#### 证书验证

我们将关注 **certificate verification**。必须验证服务器证书的完整性以增强安全性。这一点很关键，因为不安全的 TLS 配置以及在未加密通道上传输敏感数据会带来重大风险。有关验证服务器证书和修复漏洞的详细步骤，[**this resource**](https://manifestsecurity.com/android-application-security-part-10/) 提供了全面的指导。

#### SSL Pinning

SSL Pinning 是一种安全措施，应用将服务器的证书与存储在应用内的已知副本进行比对。该方法对于防止 MITM 攻击至关重要。强烈建议在处理敏感信息的应用中实现 SSL Pinning。

#### 流量检查

要检查 HTTP 流量，必须 **安装代理工具的证书**（例如 Burp）。如果不安装该证书，加密流量可能无法通过代理可见。有关安装自定义 CA 证书的指南，[**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine)。

针对 **API Level 24 and above** 的应用需要修改 Network Security Config 以接受代理的 CA 证书。此步骤对于检查加密流量至关重要。有关修改 Network Security Config 的说明，[**refer to this tutorial**](make-apk-accept-ca-certificate.md)。

如果使用 **Flutter**，你需要按照 [**this page**](flutter.md) 中的说明操作。这是因为仅将证书添加到系统存储并不能奏效，Flutter 有其自己的有效 CA 列表。

#### 静态检测 SSL/TLS pinning

在尝试运行时绕过之前，先快速映射 APK 中强制执行 pinning 的位置。静态发现可以帮助你规划 hooks/patches，并将注意力集中在正确的代码路径上。

Tool: SSLPinDetect
- 一个开源的静态分析实用工具，会将 APK 反编译为 Smali（通过 apktool）并扫描与 SSL/TLS pinning 实现相关的精选正则模式。
- 为每个匹配项报告精确的文件路径、行号和代码片段。
- 覆盖常见框架和自定义代码路径：OkHttp CertificatePinner、custom javax.net.ssl.X509TrustManager.checkServerTrusted、使用自定义 TrustManagers/KeyManagers 的 SSLContext.init，以及 Network Security Config XML 的 pins。

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
用法
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
示例模式规则 (JSON)
使用或扩展 signatures 来检测专有/自定义 pinning 样式。你可以加载自己的 JSON 并进行大规模扫描。
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
注意事项与提示
- 通过多线程和内存映射 I/O 对大型应用进行快速扫描；预编译的正则可以减少开销/误报。
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- 下一步要分类整理的典型检测目标：
- OkHttp: CertificatePinner 的使用，setCertificatePinner，okhttp3/okhttp 包引用
- Custom TrustManagers：javax.net.ssl.X509TrustManager，checkServerTrusted 的重写
- Custom SSL contexts：SSLContext.getInstance + SSLContext.init 与自定义管理器
- 在 res/xml network security config 中的声明式 pins 以及 manifest 引用
- 利用匹配到的位置来规划 Frida hooks、静态补丁或配置审查，然后再进行动态测试。



#### 绕过 SSL Pinning

当实现了 SSL Pinning 时，需要绕过它以检查 HTTPS 流量。为此有多种方法：

- 自动使用 [**apk-mitm**](https://github.com/shroudedcode/apk-mitm) **修改** **apk** 以 **绕过** SSLPinning。此选项的最大优点是你不需要 root 就能绕过 SSL Pinning，但你需要删除应用并重新安装新版本，并且这并不总是有效。
- 你可以使用 **Frida**（下文讨论）来绕过该保护。这里有一篇使用 Burp+Frida+Genymotion 的指南：[https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- 你也可以尝试使用 [**objection**](frida-tutorial/objection-tutorial.md)**：** 自动绕过 SSL Pinning：`objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- 你也可以尝试使用 **MobSF dynamic analysis**（下文说明）来**自动绕过 SSL Pinning**
- 如果你仍然认为有些流量没有被捕获，可以尝试使用 iptables **将流量转发到 burp**。阅读这篇博客：[https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### 寻找常见的 Web 漏洞

同样重要的是在应用内搜索常见的 Web 漏洞。关于识别和缓解这些漏洞的详细信息超出本摘要范围，但在其他地方有详尽覆盖。

### Frida

[Frida](https://www.frida.re) 是一个面向开发者、逆向工程师和安全研究人员的动态注入工具包。\
**你可以访问正在运行的应用并在运行时 hook 方法以更改行为、修改值、提取值、执行不同的代码...**\
如果你想 pentest Android 应用，你需要知道如何使用 Frida。

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- 一些用于与 Frida 交互的 “GUI”： [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection 非常适合自动化使用 Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- 你可以在这里找到一些 Awesome Frida 脚本： [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- 尝试按照 [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) 中的说明将 Frida 作为加载项来绕过 anti-debugging / anti-frida 机制（工具 [linjector](https://github.com/erfur/linjector-rs)）

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

检查应用是否在内存中存储了不应存储的敏感信息，例如密码或助记词。

使用 [**Fridump3**](https://github.com/rootbsd/fridump3) 你可以转储应用的内存，命令：
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
这会把内存转储到 ./dump 文件夹，你可以在里面用类似这样的 grep：
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Keystore 中的敏感数据**

在 Android 中，Keystore 是存储敏感数据的最佳位置，然而在获得足够权限的情况下仍然**可能被访问**。由于应用往往在此处以**明文形式存储敏感数据**，pentests 应以 root user 身份检查这一点，因为具有设备物理访问权限的人可能会窃取这些数据。

即使应用将数据存储在 Keystore 中，数据也应被加密。

要访问 Keystore 内部的数据，可以使用此 Frida 脚本: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

使用下面的 Frida 脚本，可能可以 **bypass fingerprint authentication**，Android 应用可能会执行该认证以 **保护某些敏感区域：**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **后台图像**

当你将应用置于后台时，Android 会存储一个 **应用的快照**，因此当它恢复到前台时，会先加载该图像，使应用看起来启动更快。

但是，如果该快照包含 **敏感信息**，有权访问快照的人可能会 **窃取该信息**（注意你需要 root 才能访问它）。

快照通常存储在： **`/data/system_ce/0/snapshots`**

Android 提供了一种通过设置 FLAG_SECURE 布局参数来 **防止截图被捕获** 的方式。使用此标志后，窗口内容会被视为受保护，防止其出现在截图中或在非安全显示设备上被查看。
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

此工具可以在动态分析期间帮助你管理不同的工具： [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

开发者常常创建代理组件（例如 activities、services 和 broadcast receivers）来处理这些 Intents，并将它们传递给诸如 `startActivity(...)` 或 `sendBroadcast(...)` 之类的方法，这可能存在风险。

危险在于允许攻击者通过错误引导这些 Intents 来触发非导出的应用组件或访问敏感的 content providers。一个显著的例子是 `WebView` 组件通过 `Intent.parseUri(...)` 将 URL 转换为 `Intent` 对象然后执行它们，这可能导致恶意 Intent 注入。

### 关键要点

- **Intent Injection** 类似于 web 的 Open Redirect 问题。
- 利用方式通常是将 `Intent` 对象作为 extras 传递，这些 Intent 可以被重定向以执行不安全的操作。
- 它可能使非导出组件和 content providers 暴露给攻击者。
- `WebView` 的 URL 到 `Intent` 的转换可能促成意外的行为。

### Android 客户端注入及其他

你可能在 Web 上已经见过这类漏洞。在 Android 应用中需要特别注意以下漏洞类型：

- **SQL Injection:** 在处理动态查询或 Content-Providers 时，确保使用参数化查询。
- **JavaScript Injection (XSS):** 确认已为所有 WebViews 禁用 JavaScript 和 Plugin 支持（默认禁用）。[More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** 应禁用 WebViews 对文件系统的访问（默认启用） - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: 在某些情况下，当 android 应用结束会话时 cookie 未被撤销，甚至可能被保存到磁盘。
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## 自动分析

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**静态分析**

![](<../../images/image (866).png>)

**对应用的漏洞评估**，使用友好的 web 前端。你也可以执行动态分析（但需要准备好相应环境）。
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Assisted Dynamic analysis with MobSF

**MobSF** 在 **Android** 的 **dynamic analysis** 中也非常有用，但在这种情况下你需要在宿主机上安装 MobSF 和 **genymotion**（VM 或 Docker 无法工作）。_注意：你需要**先在 genymotion 启动一个 VM**，然后再启动 **MobSF**。_\
**MobSF dynamic analyser** 可以：

- **Dump application data**（URLs、日志、剪贴板、你手动截的 screenshots、由 "**Exported Activity Tester**" 生成的 screenshots、电子邮件、SQLite 数据库、XML 文件以及其他生成的文件）。除了 screenshots 需要你手动按下截屏或按下 "**Exported Activity Tester**" 来获取所有 exported activities 的截图外，其它都能自动完成。
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**：会打印所有已加载的 classes
- **Capture Strings**：在使用应用时会打印抓取到的所有字符串（非常嘈杂）
- **Capture String Comparisons**：非常有用。会**显示被比较的两个字符串**以及比较结果是 True 还是 False
- **Enumerate Class Methods**：输入类名（例如 "java.io.File"）会打印该类的所有方法
- **Search Class Pattern**：按模式搜索 classes
- **Trace Class Methods**：**Trace** 整个类（查看该类所有方法的输入和输出）。记住默认情况下 MobSF 会 trace 若干有趣的 Android Api 方法。

一旦选择了你想使用的辅助模块，按下 "**Start Intrumentation**"，你将在 "**Frida Live Logs**" 中看到所有输出。

**Shell**

MobSF 在 dynamic analysis 页面底部还提供了一个 shell，包含一些 **adb** 命令、**MobSF commands** 和常用的 **shell** **commands**。一些有趣的命令：
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP tools**

当 HTTP 流量被捕获时，你可以在底部的 "**HTTP(S) Traffic**" 按钮看到原始的捕获视图，或在绿色的 "**Start HTTPTools**" 按钮看到更友好的视图。通过第二个选项，你可以将 **captured requests** 发送到像 Burp 或 Owasp ZAP 这样的 **proxies**。\
要做到这一点，_启动 Burp -->_ _关闭 Intercept --> 在 MobSB HTTPTools 中选择请求_ --> 按 "**Send to Fuzzer**" --> _选择代理地址_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080))。

完成 MobSF 的动态分析后，你可以点击 "**Start Web API Fuzzer**" 来 **fuzz http requests** 并查找漏洞。

> [!TIP]
> 在使用 MobSF 执行动态分析后，proxy settings 可能会被错误配置，且你可能无法从 GUI 修复它们。你可以通过运行以下命令来修复代理设置：
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

你可以从 [**Inspeckage**](https://github.com/ac-pm/Inspeckage) 获取该工具。\
该工具会使用一些 **Hooks**，在你进行 **动态分析** 时告诉你 **应用中发生了什么**。

### [Yaazhini](https://www.vegabird.com/yaazhini/)

这是一个用于通过 GUI 执行静态分析的优秀工具

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

该工具用于查找若干 **security related Android application vulnerabilities**，无论是在 **source code** 还是 **packaged APKs** 中。该工具还**能够创建可部署的 "Proof-of-Concept" APK** 和 **ADB commands**，以利用发现的一些漏洞（Exposed activities、intents、tapjacking...）。与 Drozer 一样，无需对测试设备进行 root。
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- 显示所有提取的文件，便于查阅
- 自动将 APK 文件反编译为 Java 和 Smali 格式
- 分析 AndroidManifest.xml 以查找常见漏洞和行为
- 对源代码进行静态分析以查找常见漏洞和行为
- 设备信息
- 以及更多
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER 是一个可在 Windows、MacOS X 和 Linux 上使用的命令行应用程序，用于分析 _.apk_ 文件以查找漏洞。它通过解压 APK 并应用一系列规则来检测这些漏洞。

所有规则都集中在一个 `rules.json` 文件中，每个公司或测试人员都可以创建自己的规则来分析他们需要的内容。

从 [download page](https://superanalyzer.rocks/download.html) 下载最新的二进制文件
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn 是一个 **crossplatform** 工具，帮助开发者、bugbounty hunters 和 ethical hackers 在移动应用上执行 [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis)。

其概念是将移动应用文件（.apk 或 .ipa 文件）拖放到 StaCoAn 应用上，它会为你生成一个可视化且可携带的报告。你可以调整设置和 wordlists 来获得定制化体验。

下载[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework 是一个 Android 漏洞分析系统，帮助开发者或 hackers 发现 Android 应用中的潜在安全漏洞。\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** 是一个工具，主要用于检测并提醒用户 Android 应用可能表现出的潜在恶意行为。

检测通过对应用的 Dalvik bytecode（以 **Smali** 表示）进行 **static analysis** 实现，使用 [`androguard`](https://github.com/androguard/androguard) 库。

此工具查找类似以下的 **常见的“恶意”应用行为**：Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** 是一个 **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework。它将常用的移动应用逆向工程和分析工具整合在一起，帮助测试移动 应用以应对 OWASP 移动安全威胁。其目标是使这项工作对移动应用开发者和安全专业人员更简单、更友好。

它可以：

- 使用不同工具提取 Java 和 Smali 代码
- 使用以下工具分析 APK: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- 使用正则表达式从 APK 中提取敏感信息
- 分析 Manifest
- 使用以下工具分析发现的域名: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) 和 [whatweb](https://github.com/urbanadventurer/WhatWeb)
- 通过 [apk-deguard.com](http://www.apk-deguard.com) 对 APK 进行去混淆

### Koodous

用于检测恶意软件： [https://koodous.com/](https://koodous.com/)

## 混淆/去混淆 代码

请注意，根据用于混淆代码的服务和配置不同，敏感信息可能会被混淆，也可能不会被混淆。

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

摘自 [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** 是一个开源的命令行工具，用于缩小、优化并混淆 Java 代码。它能够优化字节码并检测和移除未使用的指令。ProGuard 是自由软件，根据 GNU General Public License 第 2 版分发。

ProGuard 随 Android SDK 一起发布，并在以 release 模式构建应用时运行。

### [DexGuard](https://www.guardsquare.com/dexguard)

在 [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html) 可以找到一步步去混淆 apk 的指南

（摘自该指南）我们上次检查时，DexGuard 的运行模式如下：

- 将资源以 InputStream 加载；
- 将结果传给继承自 FilterInputStream 的类以进行解密；
- 做一些无用的混淆以浪费逆向人员几分钟的时间；
- 将解密后的结果传给 ZipInputStream 以得到 DEX 文件；
- 最后使用 `loadDex` 方法将得到的 DEX 作为资源加载。

### [DeGuard](http://apk-deguard.com)

**DeGuard 逆转 Android 混淆工具执行的混淆过程。 这使得包括代码审查和库识别在内的多种安全分析成为可能。**

你可以将混淆后的 APK 上传到他们的平台。

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

这是一个 LLM 工具，用于发现 android 应用中的潜在安全漏洞并去混淆 android 应用代码。使用 Google's Gemini public API。

### [Simplify](https://github.com/CalebFenton/simplify)

它是一个通用的 android 去混淆器。Simplify 通过对应用进行虚拟执行来理解其行为，然后尝试优化代码，使其在行为上与原来完全一致但更易于人工理解。每种优化类型都简单且通用，因此混淆的具体类型并不重要。

### [APKiD](https://github.com/rednaga/APKiD)

APKiD 为你提供关于一个 APK 是如何构建的信息。它能识别许多编译器、packers、obfuscators 以及其他奇怪的东西。它是 Android 领域的 [_PEiD_](https://www.aldeid.com/wiki/PEiD)。

### Manual

[阅读本教程以学习一些关于如何逆转自定义混淆的技巧](manual-deobfuscation.md)

## 实验室

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b 是一个基于 ubuntu-mate 的 Android 安全虚拟机，包含来自不同安全爱好者和研究人员的最新框架、教程和用于逆向工程及恶意软件分析的实验合集。

## 参考资料

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) 这是一个很好的资源列表
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android 快速课程
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)

## 待尝试

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
