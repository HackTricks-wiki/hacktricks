# Pentesting di Applicazioni Android

{{#include ../../banners/hacktricks-training.md}}

## Nozioni di base sulle Applicazioni Android

È altamente raccomandato iniziare leggendo questa pagina per conoscere le **parti più importanti relative alla sicurezza Android e i componenti più pericolosi in un'applicazione Android**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Questo è lo strumento principale necessario per connettersi a un dispositivo Android (emulato o fisico).\
**ADB** permette di controllare i dispositivi sia via **USB** che via **Network** da un computer. Questa utility consente la **copia** di file in entrambe le direzioni, la **installazione** e **disinstallazione** delle app, l'**esecuzione** di comandi shell, il **backup** dei dati, la **lettura** dei log, tra le altre funzioni.

Dai un'occhiata alla seguente lista di [**ADB Commands**](adb-commands.md) per imparare come usare adb.

## Smali

A volte è utile **modificare il codice dell'applicazione** per accedere a **informazioni nascoste** (ad esempio password molto offuscate o flag). In tal caso può essere interessante decompilare l'apk, modificare il codice e ricompilarlo.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Questo può essere molto utile come **alternativa per diversi test durante l'analisi dinamica** che verranno presentati. Quindi, **tieni sempre a mente questa possibilità**.

## Altri trucchi interessanti

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Estrarre l'APK dal dispositivo:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Unisci tutti gli split e gli APK base con [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Attacchi a Android Enterprise & Work Profile

{{#ref}}
android-enterprise-work-profile-bypass.md
{{#endref}}

## Case Studies & Vulnerabilities


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Analisi Statica

Prima di tutto, per analizzare un APK dovresti **dare un'occhiata al codice Java** usando un decompiler.\
Per favore, [**leggi qui per trovare informazioni sui diversi decompiler disponibili**](apk-decompilers.md).

### Ricerca di informazioni interessanti

Semplicemente guardando le **strings** dell'APK puoi cercare **password**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** e qualsiasi cosa interessante... cerca anche backdoor di esecuzione di codice o backdoor di autenticazione (credenziali admin hardcoded nell'app).

**Firebase**

Presta particolare attenzione alle **Firebase URLs** e verifica se è mal configurato. [More information about whats is FIrebase and how to exploit it here.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Comprensione di base dell'applicazione - Manifest.xml, strings.xml

L'**esame del _Manifest.xml_ e dei file **_strings.xml_** di un'applicazione può rivelare potenziali vulnerabilità di sicurezza**. Questi file possono essere accessi usando decompiler o rinominando l'estensione del file APK in .zip e poi decomprimendolo.

Le **vulnerabilità** identificate dal **Manifest.xml** includono:

- **Debuggable Applications**: Le applicazioni impostate come debuggable (`debuggable="true"`) nel file _Manifest.xml_ rappresentano un rischio in quanto permettono connessioni che possono portare a sfruttamenti. Per una comprensione più approfondita su come sfruttare applicazioni debuggable, fai riferimento a un tutorial su come trovare e sfruttare applicazioni debuggable su un device.
- **Backup Settings**: L'attributo `android:allowBackup="false"` dovrebbe essere impostato esplicitamente per le applicazioni che trattano informazioni sensibili per prevenire backup non autorizzati dei dati tramite adb, specialmente quando usb debugging è abilitato.
- **Network Security**: Le configurazioni di network security personalizzate (`android:networkSecurityConfig="@xml/network_security_config"`) in _res/xml/_ possono specificare dettagli di sicurezza come certificate pins e impostazioni sul traffico HTTP. Un esempio è permettere traffico HTTP per domini specifici.
- **Exported Activities and Services**: Identificare activities e services esportati nel manifest può evidenziare componenti che potrebbero essere abusati. Un'analisi più approfondita durante i test dinamici può rivelare come sfruttare questi componenti.
- **Content Providers and FileProviders**: Content provider esposti potrebbero permettere accesso o modifica non autorizzata dei dati. Anche la configurazione dei FileProviders deve essere scrutinata.
- **Broadcast Receivers and URL Schemes**: Questi componenti potrebbero essere sfruttati per exploit, con particolare attenzione a come gli URL schemes sono gestiti per vulnerabilità di input.
- **SDK Versions**: Gli attributi `minSdkVersion`, `targetSDKVersion`, e `maxSdkVersion` indicano le versioni Android supportate, evidenziando l'importanza di non supportare versioni Android obsolete e vulnerabili per ragioni di sicurezza.

Dal file **strings.xml** si possono scoprire informazioni sensibili come API keys, custom schemas e altri appunti degli sviluppatori, sottolineando la necessità di una revisione accurata di queste risorse.

### Tapjacking

**Tapjacking** è un attacco in cui un'applicazione **maligna** viene lanciata e **si posiziona sopra un'applicazione vittima**. Una volta che oscura visibilmente l'app vittima, la sua interfaccia utente è progettata in modo da ingannare l'utente inducendolo a interagire con essa, mentre in realtà inoltra l'interazione all'app vittima.\
Di fatto, sta **ciecando l'utente dal sapere che sta effettivamente eseguendo azioni sull'app vittima**.

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Un'**activity** con `launchMode` impostato su **`singleTask` senza alcun `taskAffinity`** definito è vulnerabile a task Hijacking. Questo significa che un'**application** può essere installata e se lanciata prima della reale applicazione potrebbe **hijackare il task della reale applicazione** (quindi l'utente interagirà con l'**application maligna pensando di usare quella reale**).

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Archiviazione dati insicura

**Internal Storage**

In Android, i file **memorizzati** nello **storage interno** sono **progettati** per essere **accessibili** esclusivamente dall'**app** che li **ha creati**. Questa misura di sicurezza è **applicata** dal sistema operativo Android ed è generalmente adeguata per le esigenze di sicurezza della maggior parte delle applicazioni. Tuttavia, gli sviluppatori a volte utilizzano modalità come `MODE_WORLD_READABLE` e `MODE_WORLD_WRITABLE` per **permettere** la condivisione di file tra diverse applicazioni. Queste modalità, comunque, **non limitano l'accesso** a questi file da parte di altre applicazioni, incluse quelle potenzialmente maligne.

1. **Static Analysis:**
- **Verifica** che l'uso di `MODE_WORLD_READABLE` e `MODE_WORLD_WRITABLE` sia **accuratamente esaminato**. Queste modalità **possono potenzialmente esporre** file ad accessi **non intenzionati o non autorizzati**.
2. **Dynamic Analysis:**
- **Controlla** i **permessi** impostati sui file creati dall'app. In particolare, **verifica** se qualche file è **impostato come leggibile o scrivibile worldwide**. Questo può rappresentare un rischio di sicurezza significativo, poiché permetterebbe a **qualsiasi application** installata sul dispositivo, indipendentemente dalla sua origine o intento, di **leggere o modificare** questi file.

**External Storage**

Quando si trattano file su **external storage**, come SD Card, devono essere prese alcune precauzioni:

1. **Accessibilità**:
- I file su external storage sono **globalmente leggibili e scrivibili**. Questo significa che qualsiasi application o utente può accedere a questi file.
2. **Preoccupazioni di sicurezza**:
- Data la facilità di accesso, è sconsigliato **memorizzare informazioni sensibili** su external storage.
- L'external storage può essere rimosso o accessibile da qualsiasi application, rendendolo meno sicuro.
3. **Gestione dei dati provenienti da External Storage**:
- Esegui sempre **input validation** sui dati recuperati dall'external storage. Questo è cruciale perché i dati provengono da una fonte non attendibile.
- È fortemente sconsigliato memorizzare eseguibili o class files su external storage per il caricamento dinamico.
- Se la tua applicazione deve recuperare file eseguibili dall'external storage, assicurati che questi file siano **signed e verificati criptograficamente** prima di essere caricati dinamicamente. Questo passo è vitale per mantenere l'integrità di sicurezza della tua applicazione.

External storage può essere **accessed** in `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> A partire da Android 4.4 (**API 17**), la SD card ha una struttura di directory che **limita l'accesso di un'app alla directory specificamente dedicata a quell'app**. Questo previene che applicazioni maligne ottengano accesso in lettura o scrittura ai file di un'altra app.

**Dati sensibili memorizzati in chiaro**

- **Shared preferences**: Android permette a ogni application di salvare facilmente file xml nel percorso `/data/data/<packagename>/shared_prefs/` e a volte è possibile trovare informazioni sensibili in chiaro in quella cartella.
- **Databases**: Android permette a ogni application di salvare facilmente database sqlite nel percorso `/data/data/<packagename>/databases/` e a volte è possibile trovare informazioni sensibili in chiaro in quella cartella.

### Broken TLS

**Accept All Certificates**

Per qualche motivo alcuni sviluppatori talvolta accettano tutti i certificati anche se, per esempio, l'hostname non corrisponde, con righe di codice come la seguente:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Un buon modo per testare questo è provare a catturare il traffico usando un proxy come Burp senza autorizzare Burp CA all'interno del dispositivo. Inoltre, puoi generare con Burp un certificato per un hostname diverso e usarlo.

### Crittografia difettosa

**Processi di gestione delle chiavi inadeguati**

Alcuni sviluppatori salvano dati sensibili nello storage locale e li criptano con una chiave hardcoded/prevedibile nel codice. Questo non dovrebbe essere fatto perché del reversing potrebbe permettere agli attaccanti di estrarre le informazioni confidenziali.

**Uso di algoritmi insicuri e/o deprecati**

Gli sviluppatori non dovrebbero usare **algoritmi deprecati** per eseguire controlli di **autorizzazione**, **memorizzare** o **inviare** dati. Alcuni di questi algoritmi sono: RC4, MD4, MD5, SHA1... Se vengono usati **hashes** per memorizzare password per esempio, dovrebbero essere usate funzioni di hash resistenti al brute-force con salt.

### Altri controlli

- Si raccomanda di **offuscare l'APK** per rendere più difficile il lavoro di reverse engineering agli attaccanti.
- Se l'app è sensibile (come le app bancarie), dovrebbe eseguire i propri controlli per verificare se il mobile è rooted e comportarsi di conseguenza.
- Se l'app è sensibile (come le app bancarie), dovrebbe controllare se viene usato un **emulator**.
- Se l'app è sensibile (come le app bancarie), dovrebbe **verificare la propria integrità prima dell'esecuzione** per controllare se è stata modificata.
- Usa [**APKiD**](https://github.com/rednaga/APKiD) per verificare quale compiler/packer/obfuscator è stato usato per costruire l'APK

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

Secondo questo [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked è un algoritmo Meta che comprime il contenuto di un'applicazione in un singolo file. Il blog parla della possibilità di creare un'app che decomprime questo tipo di app... e di un modo più rapido che coinvolge di **eseguire l'applicazione e raccogliere i file decompresse dal filesystem.**

### Automated Static Code Analysis

Lo strumento [**mariana-trench**](https://github.com/facebook/mariana-trench) è in grado di trovare **vulnerabilità** scansionando il **codice** dell'applicazione. Questo strumento contiene una serie di **known sources** (che indica allo strumento i **punti** dove l'**input** è **controllato dall'utente**), **sinks** (che indica allo strumento i punti **pericolosi** dove input malevoli dell'utente potrebbero causare danni) e **regole**. Queste regole indicano la **combinazione** di **sources-sinks** che segnala una vulnerabilità.

Con queste informazioni, **mariana-trench esaminerà il codice e troverà possibili vulnerabilità**.

### Secrets leaked

Un'applicazione può contenere secrets (API keys, passwords, hidden urls, subdomains...) al suo interno che potresti riuscire a scoprire. Puoi usare uno strumento come [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)
- In-memory native code execution via JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Analisi dinamica

> Prima di tutto, hai bisogno di un ambiente dove puoi installare l'applicazione e tutto l'ambiente (Burp CA cert, Drozer e Frida principalmente). Pertanto, un dispositivo rootato (emulato o meno) è fortemente raccomandato.

### Online Dynamic analysis

Puoi creare un **account gratuito** su: [https://appetize.io/](https://appetize.io). Questa piattaforma permette di **caricare** ed **eseguire** APK, quindi è utile per vedere come si comporta un apk.

Puoi persino **vedere i log della tua applicazione** sul web e connetterti tramite **adb**.

![](<../../images/image (831).png>)

Grazie alla connessione ADB puoi usare **Drozer** e **Frida** all'interno degli emulatori.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (Puoi creare dispositivi **x86** e **arm**, e secondo [**questa** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**ultime versioni x86** supportano le librerie ARM senza bisogno di un emulatore arm lento).
- Impara a configurarlo in questa pagina:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Versione gratuita:** Personal Edition, è necessario creare un account. _Si consiglia di **scaricare** la versione **CON**_ _**VirtualBox** per evitare potenziali errori._)
- [**Nox**](https://es.bignox.com) (Gratis, ma non supporta Frida o Drozer).

> [!TIP]
> Quando crei un nuovo emulatore su qualsiasi piattaforma ricorda che più grande è lo schermo, più lento funzionerà l'emulatore. Quindi seleziona schermi piccoli se possibile.

Per **installare google services** (come AppStore) in Genymotion è necessario cliccare sul pulsante marcato in rosso nell'immagine seguente:

![](<../../images/image (277).png>)

Inoltre, nota che nella **configurazione della VM Android in Genymotion** puoi selezionare la **Bridge Network mode** (questo sarà utile se ti connetterai alla VM Android da una VM diversa con gli strumenti).

#### Uso di un dispositivo fisico

Devi attivare le opzioni di **debugging** e sarà utile se puoi **rootarlo**:

1. **Impostazioni**.
2. (Da Android 8.0) Seleziona **Sistema**.
3. Seleziona **Informazioni sul telefono**.
4. Premi **Numero build** 7 volte.
5. Torna indietro e troverai le **Opzioni sviluppatore**.

> Una volta installata l'applicazione, la prima cosa che dovresti fare è provarla e investigare cosa fa, come funziona e prenderci confidenza.\
> Suggerisco di **eseguire questa analisi dinamica iniziale usando MobSF dynamic analysis + pidcat**, in modo da poter **imparare come funziona l'applicazione** mentre MobSF **cattura** molti **dati** **interessanti** che potrai rivedere in seguito.

Magisk/Zygisk quick notes (recommended on Pixel devices)
- Patch al boot.img con l'app Magisk e flasha via fastboot per ottenere systemless root
- Abilita Zygisk + DenyList per nascondere il root; considera LSPosed/Shamiko quando è richiesto un nascondimento più forte
- Conserva il boot.img originale per recuperare dagli aggiornamenti OTA; ripatchalo dopo ogni OTA
- Per il mirroring dello schermo, usa scrcpy sull'host



### Perdita di dati non intenzionale

**Logging**

Gli sviluppatori devono fare attenzione a non esporre informazioni di **debugging** pubblicamente, poiché ciò può portare a leak di dati sensibili. Gli strumenti [**pidcat**](https://github.com/JakeWharton/pidcat) e `adb logcat` sono raccomandati per monitorare i log dell'applicazione per identificare e proteggere le informazioni sensibili. **Pidcat** è preferito per la sua facilità d'uso e leggibilità.

> [!WARNING]
> Nota che da **versioni successive a Android 4.0**, **le applicazioni possono accedere solo ai propri log**. Quindi le applicazioni non possono accedere ai log di altre app.\
> Comunque, è comunque raccomandato di **non loggare informazioni sensibili**.

**Copy/Paste Buffer Caching**

Il framework basato su **clipboard** di Android abilita la funzionalità copia-incolla nelle app, ma comporta un rischio poiché **altre applicazioni** possono **accedere** alla clipboard, esponendo potenzialmente dati sensibili. È fondamentale **disabilitare copia/incolla** per sezioni sensibili di un'applicazione, come i dettagli delle carte di credito, per prevenire leak di dati.

**Crash Logs**

Se un'applicazione **crasha** e **salva log**, questi log possono aiutare gli attaccanti, soprattutto quando l'applicazione non può essere reverse-engineerata. Per mitigare questo rischio, evita di loggare sui crash e, se i log devono essere inviati via rete, assicurati che siano trasmessi tramite un canale SSL per sicurezza.

Come pentester, **prova a dare un'occhiata a questi log**.

**Analytics Data Sent To 3rd Parties**

Le applicazioni spesso integrano servizi come Google Adsense, che possono involontariamente causare leak di dati sensibili a causa di una implementazione scorretta da parte degli sviluppatori. Per identificare potenziali leak, è consigliabile **intercettare il traffico dell'applicazione** e controllare se vengono inviati dati sensibili a servizi di terze parti.

### SQLite DBs

La maggior parte delle applicazioni userà **database SQLite interni** per salvare informazioni. Durante il pentest dai un'occhiata ai **database** creati, ai nomi delle **tabelle** e delle **colonne** e a tutti i **dati** salvati perché potresti trovare **informazioni sensibili** (che costituirebbero una vulnerabilità).\
I database dovrebbero trovarsi in `/data/data/the.package.name/databases` come `/data/data/com.mwr.example.sieve/databases`

Se il database salva informazioni confidenziali ed è **encrypted** ma puoi **trovare** la **password** dentro l'applicazione è comunque una **vulnerabilità**.

Enumera le tabelle usando `.tables` ed enumera le colonne delle tabelle con `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** permette di **assumere il ruolo di un'app Android** e interagire con altre app. Può fare **qualunque cosa che un'app installata può fare**, come utilizzare il meccanismo di Inter-Process Communication (IPC) di Android e interagire con il sistema operativo sottostante. .\
Drozer è uno strumento utile per **sfruttare exported activities, exported services e Content Providers** come imparerai nelle sezioni seguenti.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Ricorda anche che il codice di un'activity inizia nel metodo **`onCreate`**.

**Authorisation bypass**

Quando un'Activity è exported puoi invocare la sua schermata da un'app esterna. Pertanto, se un'activity con **informazioni sensibili** è **exported** potresti **bypassare** i meccanismi di **autenticazione** **per accedervi.**

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

Puoi anche avviare un'activity esportata da adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTA**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> Nota che un authorisation bypass non è sempre una vulnerabilità, dipende da come il bypass funziona e quali informazioni sono esposte.

**Esposizione di informazioni sensibili**

Le Activity possono anche restituire risultati. Se riesci a trovare un'activity esportata e non protetta che chiama il metodo **`setResult`** e restituisce informazioni sensibili, c'è una esposizione di informazioni sensibili.

#### Tapjacking

Se il tapjacking non è prevenuto, potresti abusare dell'activity esportata per far sì che l'utente esegua azioni non previste. Per più informazioni su [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
I Content Provider sono fondamentalmente usati per **share data**. Se un'app ha Content Provider disponibili potresti essere in grado di **estrarre informazioni sensibili** da essi. È inoltre interessante testare possibili **SQL injections** e **Path Traversals** poiché potrebbero essere vulnerabili.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Ricorda che le azioni di un Service iniziano nel metodo `onStartCommand`.

Un Service è fondamentalmente qualcosa che **può ricevere dati**, **processarli** e **restituire** (o meno) una risposta. Quindi, se un'applicazione esporta dei service dovresti **controllare** il **code** per capire cosa sta facendo e **testarlo** **dinamically** per estrarre informazioni riservate, bypassing misure di autenticazione...\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Ricorda che le azioni di un Broadcast Receiver iniziano nel metodo `onReceive`.

Un broadcast receiver attenderà un tipo di messaggio. A seconda di come il receiver gestisce il messaggio potrebbe essere vulnerabile.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Puoi cercare i deep link manualmente, usando tool come MobSF o script come [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Puoi **open** a declared **scheme** using **adb** or a **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Nota che puoi **omettere il nome del package** e il dispositivo mobile chiamerà automaticamente l'app che dovrebbe aprire quel link._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Codice eseguito**

Per trovare il **codice che sarà eseguito nell'App**, vai all'activity invocata dal deep link e cerca la funzione **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Informazioni sensibili**

Ogni volta che trovi un deep link verifica che **non stia ricevendo dati sensibili (come password) tramite parametri URL**, perché qualsiasi altra applicazione potrebbe **impersonare il deep link e rubare quei dati!**

**Parametri nel path**

Devi **verificare anche se un deep link sta usando un parametro all'interno del path** dell'URL, ad esempio: `https://api.example.com/v1/users/{username}` , in tal caso puoi forzare un path traversal accedendo a qualcosa come: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Nota che se trovi gli endpoint corretti dentro l'applicazione potresti essere in grado di causare un **Open Redirect** (se parte del path viene usata come nome di dominio), **account takeover** (se puoi modificare i dettagli degli utenti senza token CSRF e l'endpoint vuln usava il metodo corretto) e qualsiasi altra vulnerabilità. More [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

Un [interessante bug bounty report](https://hackerone.com/reports/855618) riguardo link (_/.well-known/assetlinks.json_).

### Ispezione del livello di trasporto e fallimenti di verifica

- **I certificati non sono sempre ispezionati correttamente** dalle applicazioni Android. È comune che queste applicazioni ignorino gli avvisi e accettino certificati self-signed o, in alcune istanze, ricorrano a connessioni HTTP.
- **Le negoziazioni durante l'handshake SSL/TLS sono talvolta deboli**, impiegando cipher suite insicure. Questa vulnerabilità rende la connessione suscettibile ad attacchi man-in-the-middle (MITM), permettendo agli attaccanti di decrittare i dati.
- **Perdita di informazioni private** è un rischio quando le applicazioni si autenticano usando canali sicuri ma poi comunicano su canali non sicuri per altre transazioni. Questo approccio non protegge i dati sensibili, come cookie di sessione o dettagli dell'utente, dall'intercettazione da parte di entità malevole.

#### Verifica del certificato

Ci concentreremo sulla **verifica del certificato**. L'integrità del certificato del server deve essere verificata per aumentare la sicurezza. Questo è cruciale perché configurazioni TLS insicure e la trasmissione di dati sensibili su canali non cifrati possono rappresentare rischi significativi. Per passaggi dettagliati su come verificare i certificati server e risolvere vulnerabilità, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) fornisce una guida completa.

#### SSL Pinning

SSL Pinning è una misura di sicurezza in cui l'app verifica il certificato del server rispetto a una copia nota memorizzata all'interno dell'app stessa. Questo metodo è essenziale per prevenire attacchi MITM. Implementare SSL Pinning è fortemente raccomandato per applicazioni che gestiscono informazioni sensibili.

#### Ispezione del traffico

Per ispezionare il traffico HTTP, è necessario **installare il certificato dello strumento proxy** (es. Burp). Senza installare questo certificato, il traffico cifrato potrebbe non essere visibile attraverso il proxy. Per una guida su come installare una CA personalizzata, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Le applicazioni targettizzate a **API Level 24 and above** richiedono modifiche al Network Security Config per accettare il certificato CA del proxy. Questo passaggio è critico per ispezionare il traffico cifrato. Per istruzioni su come modificare il Network Security Config, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

Se viene usato **Flutter** devi seguire le istruzioni in [**this page**](flutter.md). Questo perché, semplicemente aggiungendo il certificato nello store non funzionerà: Flutter ha la propria lista di CA valide.

#### Rilevamento statico dello SSL/TLS pinning

Prima di tentare bypass a runtime, mappa rapidamente dove il pinning è applicato nell'APK. La scoperta statica ti aiuta a pianificare hook/patch e a concentrarti sui percorsi di codice giusti.

Tool: SSLPinDetect
- Utility open-source di static-analysis che decompila l'APK in Smali (via apktool) e scansiona pattern regex curati per implementazioni di SSL/TLS pinning.
- Riporta percorso file esatto, numero di riga e un frammento di codice per ogni match.
- Copre framework comuni e percorsi di codice custom: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Uso
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Esempio di regole di pattern (JSON)
Usa o estendi le signatures per rilevare stili di pinning proprietari/personalizzati. Puoi caricare il tuo JSON ed effettuare scan at scale.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Note e suggerimenti
- Fast scanning on large apps via multi-threading and memory-mapped I/O; pre-compiled regex reduces overhead/false positives.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Typical detection targets to triage next:
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Declarative pins in res/xml network security config and manifest references
- Use the matched locations to plan Frida hooks, static patches, or config reviews before dynamic testing.



#### Bypassare SSL Pinning

Quando SSL Pinning è implementato, diventa necessario bypassarlo per ispezionare il traffico HTTPS. Sono disponibili vari metodi per questo scopo:

- Automatically **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Il vantaggio principale di questa opzione è che non avrai bisogno di root per bypassare SSL Pinning, ma dovrai cancellare l'applicazione e reinstallare la nuova, e questo non funzionerà sempre.
- You could use **Frida** (discussed below) to bypass this protection. Qui trovi una guida per usare Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- You can also try to **automatically bypass SSL Pinning** using [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- You can also try to **automatically bypass SSL Pinning** using **MobSF dynamic analysis** (explained below)
- If you still think that there is some traffic that you aren't capturing you can try to **forward the traffic to burp using iptables**. Leggi questo blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Looking for Common Web Vulnerabilities

È importante cercare anche vulnerabilità web comuni all'interno dell'applicazione. Informazioni dettagliate su come identificarle e mitigare queste vulnerabilità sono oltre lo scopo di questo riassunto ma sono trattate estensivamente altrove.

### Frida

[Frida](https://www.frida.re) è un toolkit di instrumentazione dinamica per sviluppatori, reverse-engineer e ricercatori di sicurezza.\
**You can access running application and hook methods on run time to change the behaviour, change values, extract values, run different code...**\
Se vuoi fare pentest su applicazioni Android devi sapere come usare Frida.

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Alcune "GUI" per azioni con Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection è ottimo per automatizzare l'uso di Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Puoi trovare alcuni Awesome Frida scripts qui: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Prova a bypassare meccanismi anti-debugging / anti-frida caricando Frida come indicato in [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump della memoria - Fridump**

Verifica se l'applicazione sta memorizzando informazioni sensibili nella memoria che non dovrebbe conservare, come password o mnemonics.

Usando [**Fridump3**](https://github.com/rootbsd/fridump3) puoi eseguire il dump della memoria dell'app con:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Questo eseguirà il dump della memoria nella cartella ./dump, e lì puoi usare grep con qualcosa del tipo:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Dati sensibili nel Keystore**

Su Android il Keystore è il posto ideale per conservare dati sensibili; tuttavia, con privilegi sufficienti è ancora **possibile accedervi**. Poiché le applicazioni tendono a memorizzare qui **dati sensibili in clear text**, i pentests dovrebbero verificarne la presenza: un utente root o chiunque abbia accesso fisico al dispositivo potrebbe rubare questi dati.

Anche se un'app memorizza dati nel Keystore, i dati dovrebbero essere cifrati.

Per accedere ai dati nel Keystore puoi usare questo script Frida: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Usando il seguente script Frida potrebbe essere possibile **bypass fingerprint authentication** che le applicazioni Android potrebbero eseguire per **proteggere alcune aree sensibili:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Background Images**

Quando metti un'applicazione in background, Android salva una **snapshot of the application**, così quando viene riportata in foreground inizia a caricare l'immagine prima dell'app in modo che sembri caricata più velocemente.

Tuttavia, se questa snapshot contiene **informazioni sensibili**, qualcuno con accesso alla snapshot potrebbe **rubare queste info** (nota che serve root per accedervi).

Le snapshot sono di solito memorizzate in: **`/data/system_ce/0/snapshots`**

Android fornisce un modo per **prevent the screenshot capture by setting the FLAG_SECURE** come parametro di layout. Usando questa flag, i contenuti della finestra sono trattati come sicuri, evitando che compaiano in screenshot o vengano visualizzati su display non sicuri.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Questo strumento può aiutarti a gestire diversi tool durante la dynamic analysis: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Gli sviluppatori spesso creano componenti proxy come activities, services e broadcast receivers che gestiscono questi Intent e li passano a metodi come `startActivity(...)` o `sendBroadcast(...)`, il che può essere rischioso.

Il pericolo risiede nel permettere ad un attacker di triggerare componenti dell'app non-exported o di accedere a content providers sensibili deviando questi Intent. Un esempio notevole è il componente `WebView` che converte URL in oggetti `Intent` tramite `Intent.parseUri(...)` e poi li esegue, potenzialmente portando a malicious Intent injections.

### Essential Takeaways

- **Intent Injection** è simile al problema Open Redirect del web.
- Gli exploit implicano il passaggio di oggetti `Intent` come extras, che possono essere rediretti per eseguire operazioni non sicure.
- Può esporre a un attacker componenti non-exported e content providers.
- La conversione da URL a `Intent` di `WebView` può facilitare azioni non intenzionate.

### Android Client Side Injections e altri

Probabilmente conosci questo tipo di vulnerabilità dal Web. Devi essere particolarmente attento a queste vulnerabilità in un'app Android:

- **SQL Injection:** Quando si gestiscono query dinamiche o Content-Providers assicurati di usare query parametrizzate.
- **JavaScript Injection (XSS):** Verifica che il supporto JavaScript e Plugin sia disabilitato per qualsiasi WebViews (disabilitato di default). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** Le WebViews dovrebbero avere l'accesso al file system disabilitato (abilitato di default) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies:** In diversi casi quando l'app Android termina la sessione il cookie non viene revocato o può essere persino salvato su disco
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Analisi automatica

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Analisi statica**

![](<../../images/image (866).png>)

**Vulnerability assessment of the application** usando una gradevole interfaccia web. Puoi anche eseguire dynamic analysis (ma devi preparare l'ambiente).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Assisted Dynamic analysis with MobSF

**MobSF** can also be very helpful for **dynamic analysis** in **Android**, but in that case you will need to install MobSF and **genymotion** in your host (a VM or Docker won't work). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
The **MobSF dynamic analyser** can:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). All of this is done automatically except for the screenshots, you need to press when you want a screenshot or you need to press "**Exported Activity Tester**" to obtain screenshots of all the exported activities.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Frida scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: It will print all the loaded classes
- **Capture Strings**: It will print all the capture strings while using the application (super noisy)
- **Capture String Comparisons**: Could be very useful. It will **show the 2 strings being compared** and if the result was True or False.
- **Enumerate Class Methods**: Put the class name (like "java.io.File") and it will print all the methods of the class.
- **Search Class Pattern**: Search classes by pattern
- **Trace Class Methods**: **Trace** a **whole class** (see inputs and outputs of all methods of th class). Remember that by default MobSF traces several interesting Android Api methods.

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf also brings you a shell with some **adb** commands, **MobSF commands**, and common **shell** **commands** at the bottom of the dynamic analysis page. Some interesting commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**Strumenti HTTP**

Quando il traffico http viene catturato puoi vedere una visuale grezza del traffico catturato nel pulsante "**HTTP(S) Traffic**" in basso o una visuale più gradevole nel pulsante verde "**Start HTTPTools**". Dalla seconda opzione, puoi **inviare** le **richieste catturate** a **proxies** come Burp o Owasp ZAP.\
Per farlo, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> premi "**Send to Fuzzer**" --> _seleziona l'indirizzo del proxy_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Una volta terminata l'analisi dinamica con MobSF puoi premere "**Start Web API Fuzzer**" per **fuzz http requests** e cercare vulnerabilità.

> [!TIP]
> Dopo aver eseguito un'analisi dinamica con MobSF le impostazioni del proxy potrebbero essere mal configurate e potresti non riuscire a correggerle dall'interfaccia GUI. Puoi ripristinare le impostazioni del proxy eseguendo:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Analisi dinamica assistita con Inspeckage

Puoi ottenere lo strumento da [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Questo tool utilizza alcuni **Hooks** per informarti **su cosa sta succedendo nell'applicazione** mentre esegui un'**analisi dinamica**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Questo è un **ottimo tool per eseguire analisi statica con una GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Questo strumento è progettato per cercare diverse **vulnerabilità di applicazioni Android relative alla security**, sia nel **codice sorgente** sia negli **APKs pacchettizzati**. Lo strumento è anche **capace di creare un APK deployable "Proof-of-Concept"** e **ADB commands**, per sfruttare alcune delle vulnerabilità trovate (Exposed activities, intents, tapjacking...). Come con Drozer, non è necessario rootare il dispositivo di test.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Mostra tutti i file estratti per facile consultazione
- Decompila automaticamente file APK in formato Java e Smali
- Analizza AndroidManifest.xml per vulnerabilità e comportamenti comuni
- Analisi statica del codice sorgente per vulnerabilità e comportamenti comuni
- Informazioni sul dispositivo
- e altro
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER è un'applicazione da riga di comando utilizzabile su Windows, MacOS X e Linux, che analizza i file _.apk_ alla ricerca di vulnerabilità. Lo fa decomprimendo gli APK e applicando una serie di regole per rilevare tali vulnerabilità.

Tutte le regole sono centralizzate in un file `rules.json`, e ogni azienda o tester può creare le proprie regole per analizzare ciò di cui ha bisogno.

Scarica i binari più recenti dalla [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn è uno strumento **multipiattaforma** che aiuta sviluppatori, bugbounty hunters e ethical hackers nello svolgimento di [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) su applicazioni mobile.

Il concetto è che trascini e rilasci il file della tua applicazione mobile (un .apk o .ipa file) sull'applicazione StaCoAn e questa genererà per te un report visivo e portatile. Puoi modificare le impostazioni e le wordlists per ottenere un'esperienza personalizzata.

Scarica[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework è un sistema di analisi delle vulnerabilità Android che aiuta gli sviluppatori o hackers a trovare potenziali vulnerabilità di sicurezza nelle applicazioni Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** è uno strumento il cui scopo principale è rilevare e avvisare l'utente riguardo a potenziali comportamenti malevoli sviluppati da un'applicazione Android.

La rilevazione viene eseguita tramite la **static analysis** del Dalvik bytecode dell'applicazione, rappresentato come **Smali**, con la libreria [`androguard`](https://github.com/androguard/androguard).

Questo strumento cerca **comportamenti comuni delle applicazioni "bad"** come: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** è un framework per il Reverse engineering e l'analisi delle Mobile Application. È uno strumento che mette insieme tool comunemente usati per il reverse engineering e l'analisi delle mobile application, per aiutare nei test delle applicazioni mobili contro le minacce alla sicurezza mobile identificate da OWASP. Il suo obiettivo è rendere questo compito più semplice e accessibile agli sviluppatori di applicazioni mobili e ai professionisti della sicurezza.

È in grado di:

- Estrarre codice Java e Smali usando diversi tool
- Analizzare APK usando: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Estrarre informazioni private dall'APK usando regexp.
- Analizzare il Manifest.
- Analizzare i domini trovati usando: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) e [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deoffuscare APK tramite [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Utile per rilevare malware: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Nota che a seconda del servizio e della configurazione che usi per offuscare il codice, i segreti potrebbero risultare offuscati oppure no.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

Da [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** è uno strumento open source da riga di comando che riduce, ottimizza e offusca il codice Java. È in grado di ottimizzare il bytecode oltre a rilevare e rimuovere istruzioni non utilizzate. ProGuard è software libero e viene distribuito sotto la GNU General Public License, versione 2.

ProGuard è distribuito come parte dell'Android SDK e viene eseguito durante la compilazione dell'applicazione in modalità release.

### [DexGuard](https://www.guardsquare.com/dexguard)

Trovi una guida passo-passo per deoffuscare l'apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(Dalla guida) L'ultima volta che abbiamo controllato, la modalità di funzionamento di Dexguard era:

- caricare una risorsa come InputStream;
- dare il risultato a una classe che eredita da FilterInputStream per decrittarla;
- fare qualche inutile offuscazione per far perdere qualche minuto a un reverser;
- passare il risultato decrittato a un ZipInputStream per ottenere un file DEX;
- infine caricare il DEX risultante come Resource usando il metodo `loadDex`.

### [DeGuard](http://apk-deguard.com)

**DeGuard inverte il processo di offuscamento eseguito dagli strumenti di offuscamento Android. Questo consente numerose analisi di sicurezza, inclusa l'ispezione del codice e la predizione delle librerie.**

Puoi caricare un APK offuscato sulla loro piattaforma.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

Questo è uno strumento LLM per trovare potenziali vulnerabilità di sicurezza nelle app android e deoffuscare il codice delle app android. Usa la Google Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

È un **deoffuscatore Android generico.** Simplify **esegue virtualmente un'app** per comprenderne il comportamento e poi **cerca di ottimizzare il codice** in modo che si comporti in modo identico ma sia più facile da comprendere per un essere umano. Ogni tipo di ottimizzazione è semplice e generico, quindi non importa quale specifico tipo di offuscazione sia stato usato.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD ti dà informazioni su **come è stato realizzato un APK**. Identifica molti **compilatori**, **packers**, **obfuscators**, e altre cose strane. È il [_PEiD_](https://www.aldeid.com/wiki/PEiD) per Android.

### Manual

[Leggi questo tutorial per imparare alcuni trucchi su **come reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b è una virtual machine per la sicurezza Android basata su ubuntu-mate che include una raccolta dei più recenti framework, tutorial e lab da diversi security geeks e ricercatori per reverse engineering e analisi di malware.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) È una grande lista di risorse
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
