# Android एप्लिकेशन Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android Applications Basics

यह पृष्ठ पढ़ना ज़ोरदार रूप से अनुशंसित है ताकि आप Android security से संबंधित सबसे महत्वपूर्ण हिस्सों और किसी Android application में सबसे खतरनाक components के बारे में जान सकें:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

यह मुख्य tool है जिसकी आपको एक android device (emulated or physical) से कनेक्ट करने के लिए आवश्यकता होती है।\
**ADB** आपको कंप्यूटर से **USB** या **Network** के माध्यम से devices को control करने की अनुमति देता है। यह utility दोनों दिशाओं में फाइलों की **copying**, apps की **installation** और **uninstallation**, shell कमांड्स का **execution**, डेटा का **backing up**, logs का **reading**, तथा अन्य फ़ंक्शन्स सक्षम बनाती है।

निम्नलिखित सूची [**ADB Commands**](adb-commands.md) को देखें ताकि आप adb का उपयोग कैसे करना है सीख सकें।

## Smali

कभी-कभी application code को modify करना उपयोगी होता है ताकि hidden information (शायद अच्छी तरह obfuscated passwords या flags) तक पहुँचा जा सके। तब, apk को decompile करके, code modify करके और उसे फिर से recompile करना दिलचस्प हो सकता है।\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). यह dynamic analysis के दौरान प्रस्तुत कई tests के लिए एक **वैकल्पिक तरीका** बहुत उपयोगी हो सकता है। इसलिए, इस संभावना को हमेशा ध्यान में रखें।

## Other interesting tricks

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **APK डाउनलोड करें**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- डिवाइस से APK निकालना:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- सभी splits और base apks को [APKEditor](https://github.com/REAndroid/APKEditor) के साथ मर्ज करें:
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## केस स्टडीज़ & Vulnerabilities


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## स्टैटिक विश्लेषण

सबसे पहले, एक APK का विश्लेषण करने के लिए आपको decompiler का उपयोग करके **Java code** पर नज़र डालनी चाहिए।\
कृपया, [**यहाँ पढ़ें विभिन्न उपलब्ध decompilers के बारे में जानकारी पाने के लिए**](apk-decompilers.md).

### रोचक जानकारी ढूँढना

APK की **strings** देखकर आप **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** और अन्य दिलचस्प चीज़ें खोज सकते हैं... कोड execution **backdoors** या authentication backdoors (app में hardcoded admin credentials) भी खोजें।

**Firebase**

विशेष ध्यान दें कि **Firebase URLs** कैसे कॉन्फ़िगर हैं और जांचें कि क्या यह गलत कॉन्फ़िगर है। [Firebase क्या है और इसे कैसे exploit करें इसके बारे में अधिक जानकारी यहाँ।](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### एप्लिकेशन की बुनियादी समझ - Manifest.xml, strings.xml

किसी एप्लिकेशन के _Manifest.xml_ और **_strings.xml_** फाइलों की जांच से संभावित सुरक्षा कमजोरियाँ उजागर हो सकती हैं। इन फाइलों को decompilers से एक्सेस किया जा सकता है या APK की file extension को .zip में बदलकर उसे unzip करके भी निकाला जा सकता है।

**Manifest.xml** से पहचानी जाने वाली कमजोरियाँ शामिल हैं:

- **Debuggable Applications**: Manifest.xml में `debuggable="true"` सेट होने वाले एप्लिकेशन जोखिम पैदा करते हैं क्योंकि वे ऐसे कनेक्शन्स की अनुमति देते हैं जो exploit का रास्ता खोल सकते हैं। debuggable एप्लिकेशन को ढूँढने और exploit करने के बारे में समझने के लिए संबंधित ट्यूटोरियल देखें।
- **Backup Settings**: संवेदनशील जानकारी वाले एप्लिकेशन के लिए `android:allowBackup="false"` को स्पष्ट रूप से सेट किया जाना चाहिए ताकि adb के माध्यम से unauthorized data backups से बचा जा सके, विशेषकर जब usb debugging सक्षम हो।
- **Network Security**: कस्टम network security configurations (`android:networkSecurityConfig="@xml/network_security_config"`) जो _res/xml/_ में होते हैं, certificate pins और HTTP traffic settings जैसी सुरक्षा विवरण specify कर सकते हैं। एक उदाहरण यह है कि कुछ डोमेनों के लिए HTTP traffic की अनुमति देना।
- **Exported Activities and Services**: Manifest में exported activities और services की पहचान उन components को उजागर कर सकती है जिन्हें गलत तरीके से उपयोग किया जा सकता है। dynamic testing के दौरान और विश्लेषण से पता चल सकता है कि इन्हें कैसे exploit किया जा सकता है।
- **Content Providers and FileProviders**: एक्सपोज्ड content providers unauthorized access या data modification की अनुमति दे सकते हैं। FileProviders की configuration की भी बारीकी से जाँच की जानी चाहिए।
- **Broadcast Receivers and URL Schemes**: ये components exploitation के लिए उपयोग किए जा सकते हैं, खासकर यह ध्यान में रखते हुए कि URL schemes इनपुट-वulnerabilities के लिए कैसे manage किए जाते हैं।
- **SDK Versions**: `minSdkVersion`, `targetSDKVersion`, और `maxSdkVersion` attributes बताती हैं कि कौन से Android versions समर्थित हैं, जो यह दिखाते हैं कि पुराने, कमजोर Android versions का समर्थन न करने का महत्व क्यों है।

**strings.xml** फाइल से संवेदनशील जानकारी जैसे API keys, custom schemas, और अन्य developer नोट्स मिल सकते हैं, इसीलिए इन resources की सावधानीपूर्वक समीक्षा आवश्यक है।

### Tapjacking

**Tapjacking** एक ऐसा attack है जहाँ एक **दुर्भावनापूर्ण एप्लिकेशन** लॉन्च होती है और **victim application के ऊपर खुद को पोज़िशन कर लेती है**। जब यह victim app को दृश्यतः ढक देता है, तो इसका UI इस तरह डिज़ाइन किया जाता है कि यह यूज़र को बेवकूफ बनाकर उस पर interact करवा लेता है, जबकि यह interaction victim app को पास-थ्रू कर रहा होता है।\
असरतः, यह **यूज़र को अंधा कर देता है जिससे वह यह नहीं जान पाता कि वह वास्तव में victim app पर क्रियाएँ कर रहा है**।

अधिक जानकारी पाएँः


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

एक **activity** जिसका **`launchMode`** **`singleTask`** पर सेट हो और कोई `taskAffinity` परिभाषित न हो, task Hijacking के लिए vulnerable होती है। इसका मतलब यह है कि एक **malicious application** install की जा सकती है और यदि वास्तविक application लॉन्च होने से पहले इसे लॉन्च किया जाए तो यह **वास्तविक एप्लिकेशन के task को hijack कर सकता है** (जिससे यूज़र **malicious application** को वास्तविक समझकर उसी के साथ interact करेगा)।

अधिक जानकारीः


{{#ref}}
android-task-hijacking.md
{{#endref}}

### असुरक्षित डेटा स्टोरेज

**Internal Storage**

Android में, files जो **internal** storage में **store** की जाती हैं, वे सामान्यतः केवल उस **app** द्वारा access किए जाने के लिए डिज़ाइन की गई होती हैं जिसने इन्हें बनाया है। यह सुरक्षा उपाय Android operating system द्वारा लागू किया जाता है और अधिकांश applications की सुरक्षा आवश्यकताओं के लिए पर्याप्त होता है। हालाँकि, developers कभी-कभी `MODE_WORLD_READABLE` और `MODE_WORLD_WRITABLE` जैसे modes का उपयोग करते हैं ताकि files को विभिन्न applications के बीच **shared** किया जा सके। ये modes इन फाइलों तक अन्य applications, जिनमें संभावित रूप से malicious ones भी शामिल हैं, की पहुँच को **रोकते नहीं हैं**।

1. **Static Analysis:**
- `MODE_WORLD_READABLE` और `MODE_WORLD_WRITABLE` के उपयोग की **सावधानीपूर्वक जांच** करें। ये modes फाइलों को **अनवांछित या unauthorized access** के लिए उजागर कर सकते हैं।
2. **Dynamic Analysis:**
- ऐप द्वारा बनाए गए फाइलों पर सेट permissions की **सत्यापित** करें। विशेष रूप से जांचें कि क्या किसी भी फाइल को **संसार-व्यापी रूप से readable या writable** किया गया है। यह एक महत्वपूर्ण सुरक्षा जोखिम हो सकता है, क्योंकि इससे **किसी भी application** (चाहे वह कहीं से भी आई हो) उन फाइलों को **read या modify** कर सकता है।

**External Storage**

SD Cards जैसे **external storage** पर फाइलों के साथ निपटने के समय कुछ सतर्कताएँ अपनाई जानी चाहिए:

1. **Accessibility**:
- external storage पर फाइलें **globally readable और writable** होती हैं। इसका मतलब है कि कोई भी application या user इन फाइलों तक पहुँच सकता है।
2. **Security Concerns**:
- ऐसी सहज पहुँच के कारण, संवेदनशील जानकारी को external storage पर **स्टोर न करने** की सलाह दी जाती है।
- external storage को हटाया जा सकता है या किसी भी application द्वारा access किया जा सकता है, जिससे यह कम सुरक्षित बन जाता है।
3. **Handling Data from External Storage**:
- external storage से प्राप्त डेटा पर हमेशा **input validation** करें। यह महत्वपूर्ण है क्योंकि यह डेटा एक untrusted स्रोत से आता है।
- executables या class files को dynamic loading के लिए external storage पर स्टोर करना कड़ाई से न करने योग्य है।
- यदि आपका application external storage से executable files को retrieve करना ही चाहिए, तो सुनिश्चित करें कि ये फाइलें **signed और cryptographically verified** हों इससे पहले कि उन्हें dynamically load किया जाए। यह कदम आपकी application की security integrity बनाए रखने के लिए आवश्यक है।

External storage को `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard` में **access** किया जा सकता है

> [!TIP]
> Android 4.4 (**API 17**) से शुरू होकर, SD card की directory structure ऐसी है जो **किसी app की उन directories तक ही access सीमित करती है जो विशेष रूप से उस app के लिए हैं**। यह एक malicious application को किसी अन्य app की फाइलों का read या write access प्राप्त करने से रोकता है।

**स्पष्ट-पाठ (clear-text) में संग्रहीत संवेदनशील डेटा**

- **Shared preferences**: Android प्रत्येक application को आसानी से xml फाइलें `/data/data/<packagename>/shared_prefs/` path में save करने की अनुमति देता है और कभी-कभी उस फ़ोल्डर में स्पष्ट-पाठ में संवेदनशील जानकारी मिल सकती है।
- **Databases**: Android प्रत्येक application को आसानी से sqlite databases `/data/data/<packagename>/databases/` path में save करने की अनुमति देता है और कभी-कभी उस फ़ोल्डर में स्पष्ट-पाठ में संवेदनशील जानकारी मिल सकती है।

### Broken TLS

**Accept All Certificates**

कई बार developers किसी कारण से सभी certificates स्वीकार कर लेते हैं भले ही उदाहरण के लिए hostname मेल न खाता हो, ऐसी लाइनों के साथ कोड में जैसे कि निम्नलिखित:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Broken Cryptography

**खराब कुंजी प्रबंधन प्रक्रियाएँ**

कुछ डेवलपर्स संवेदनशील डेटा को local storage में सेव करते हैं और उसे कोड में hardcoded/predictable key से encrypt कर देते हैं। ऐसा नहीं होना चाहिए क्योंकि कुछ reversing से attackers गोपनीय जानकारी निकाल सकते हैं।

**असुरक्षित और/या Deprecated Algorithms का उपयोग**

Developers को **deprecated algorithms** का उपयोग करके authorisation **checks**, डेटा को **store** या **send** नहीं करना चाहिए। इनमें से कुछ algorithms हैं: RC4, MD4, MD5, SHA1... यदि पासवर्ड स्टोर करने के लिए **hashes** का उपयोग किया जाता है, तो salt के साथ brute-force **resistant** hashes का उपयोग करना चाहिए।

### Other checks

- यह सुझाया जाता है कि **APK को obfuscate किया जाए** ताकि attackers के लिए reverse engineer का काम कठिन हो।
- यदि ऐप संवेदनशील है (जैसे bank apps), तो उसे अपना **own checks यह देखने के लिए कि मोबाइल rooted है या नहीं** करना चाहिए और उसके अनुसार कार्य करना चाहिए।
- यदि ऐप संवेदनशील है (जैसे bank apps), तो उसे जांचना चाहिए कि क्या **emulator** उपयोग हो रहा है।
- यदि ऐप संवेदनशील है (जैसे bank apps), तो उसे **executing से पहले अपनी integrity जांचनी चाहिए** यह देखने के लिए कि क्या इसे modify किया गया है।
- [**APKiD**](https://github.com/rednaga/APKiD) का उपयोग करें यह जांचने के लिए कि किस compiler/packer/obfuscator का उपयोग करके APK बनाया गया था

### React Native Application

React applications के javascript code तक आसानी से पहुँचने के लिए निम्नलिखित पृष्ठ पढ़ें:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

C# code तक आसानी से पहुँचने के लिए निम्नलिखित पृष्ठ पढ़ें:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. ब्लॉग में ऐसी ऐप्स को decompress करने के लिए एक ऐप बनाने की संभावना के बारे में बताया गया है... और एक तेज़ तरीका जो **application को execute करके और filesystem से decompressed files इकट्ठा करने** में शामिल है।

### Automated Static Code Analysis

The tool [**mariana-trench**](https://github.com/facebook/mariana-trench) is capable of finding **vulnerabilities** by **scanning** the **code** of the application. यह टूल एक श्रृंखला के **known sources** (जो टूल को बताते हैं कि वे **places** कहाँ हैं जहाँ **input** **user द्वारा नियंत्रित** होता है), **sinks** (जो टूल को यह सूचित करते हैं कि कौन से **dangerous** **places** हैं जहाँ malicious user input नुकसान पहुंचा सकता है) और **rules** रखता है। ये rules उन **sources-sinks** के **combination** को दर्शाते हैं जो एक vulnerability संकेत करती है।

इन जानकारियों के साथ, **mariana-trench कोड की समीक्षा करेगा और उसमें संभावित vulnerabilities खोजेगा।**

### Secrets leaked

An application may contain secrets (API keys, passwords, hidden urls, subdomains...) inside of it that you might be able to discover. आप [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks) जैसे टूल का उपयोग कर सकते हैं

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> सबसे पहले, आपको ऐसा environment चाहिए जहाँ आप application और बाकी environment (मुख्य रूप से Burp CA cert, Drozer और Frida) install कर सकें। इसलिए, एक rooted device (emulated या नहीं) अत्यधिक अनुशंसित है।

### Online Dynamic analysis

आप [https://appetize.io/](https://appetize.io) पर एक **free account** बना सकते हैं। यह प्लेटफ़ॉर्म आपको APKs **upload** और **execute** करने की अनुमति देता है, इसलिए यह देखने के लिए उपयोगी है कि एक apk कैसे व्यवहार कर रहा है।

आप web में अपने application के **logs देख सकते हैं** और **adb** के माध्यम से connect भी कर सकते हैं।

![](<../../images/image (831).png>)

ADB connection के कारण आप emulators के अंदर **Drozer** और **Frida** का उपयोग कर सकते हैं।

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (आप **x86** और **arm** devices बना सकते हैं, और [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**के अनुसार latest x86 versions ARM libraries को support करते हैं बिना धीमे arm emulator की ज़रूरत के।)
- इसे सेटअप करना सीखें इस पृष्ठ पर:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, आपको account बनाना होगा. _यह सुझाव दिया जाता है कि potential errors से बचने के लिए **WITH** _**VirtualBox** वाला version **download** करें._)
- [**Nox**](https://es.bignox.com) (Free, लेकिन यह Frida या Drozer को support नहीं करता).

> [!TIP]
> किसी भी platform पर नया emulator बनाते समय याद रखें कि स्क्रीन जितनी बड़ी होगी, emulator उतना ही धीमा चलेगा। इसलिए यदि संभव हो तो छोटे स्क्रीन चुनें।

Genymotion में **google services** (जैसे AppStore) install करने के लिए आपको निम्न चित्र में लाल चिह्नित बटन पर क्लिक करना होगा:

![](<../../images/image (277).png>)

साथ ही ध्यान दें कि Genymotion में **Android VM की configuration** में आप **Bridge Network mode** चुन सकते हैं (यह उपयोगी होगा यदि आप tools के साथ अलग VM से Android VM से connect कर रहे हों)।

#### Use a physical device

आपको **debugging** विकल्प activate करने होंगे और अगर आप इसे **root** कर सकते हैं तो अच्छा होगा:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> एक बार जब आपने application install कर लिया है, तो सबसे पहले आपको इसे आज़माकर देखना चाहिए और जाँच करनी चाहिए कि यह क्या करता है, कैसे काम करता है और इसके साथ सहज होना चाहिए.\
> मैं सुझाव दूंगा कि इस प्रारंभिक डायनेमिक विश्लेषण को MobSF dynamic analysis + pidcat का उपयोग करके करें, ताकि हम यह सीख सकें कि application कैसे काम करता है जबकि MobSF कई सारी **interesting** **data** capture करता है जिन्हें आप बाद में review कर सकते हैं।

### Unintended Data Leakage

**Logging**

डेवलपर्स को सार्वजनिक रूप से **debugging information** उजागर करने में सावधानी बरतनी चाहिए, क्योंकि इससे sensitive data leaks हो सकते हैं। application logs की निगरानी के लिए [**pidcat**](https://github.com/JakeWharton/pidcat) और `adb logcat` tools की सिफारिश की जाती है ताकि संवेदनशील जानकारी की पहचान और सुरक्षा की जा सके। **Pidcat** इसके उपयोग में आसानी और पठनीयता के कारण पसंद किया जाता है।

> [!WARNING]
> यह ध्यान दें कि **Android 4.0 से नए वर्ज़न में**, **applications केवल अपने ही logs तक पहुँच सकती हैं**। इसलिए applications अन्य apps के logs तक पहुँच नहीं सकतीं।\
> फिर भी, यह सलाह दी जाती है कि **संवेदनशील जानकारी को log न करें**।

**Copy/Paste Buffer Caching**

Android का **clipboard-based** framework apps में copy-paste functionality सक्षम करता है, पर इससे जोखिम होता है क्योंकि **अन्य applications** clipboard तक पहुँच सकती हैं, जिससे संवेदनशील डेटा उजागर हो सकता है। इसलिए credit card details जैसे संवेदनशील हिस्सों के लिए copy/paste functions को disable करना महत्वपूर्ण है ताकि data leaks से बचा जा सके।

**Crash Logs**

यदि कोई application **crashes** और **logs save** करता है, तो ये logs attackers की मदद कर सकते हैं, विशेषकर जब application reverse-engineer नहीं किया जा सकता। इस जोखिम को कम करने के लिए, crashes पर logging से बचें, और यदि logs को network पर भेजना आवश्यक है, तो सुनिश्चित करें कि वे सुरक्षा के लिए SSL चैनल के माध्यम से भेजे जाएं।

As pentester, **इन logs को देखने की कोशिश करें**।

**Analytics Data Sent To 3rd Parties**

Applications अक्सर Google Adsense जैसे services को integrate करती हैं, जो developers की गलत implementation के कारण अनजाने में **sensitive data leak** कर सकती हैं। संभावित data leaks की पहचान के लिए, यह सलाह दी जाती है कि आप **application के traffic को intercept करें** और जांचें कि किसी भी संवेदनशील जानकारी को third-party services को भेजा तो नहीं जा रहा।

### SQLite DBs

ज़्यादातर applications जानकारी सहेजने के लिए **internal SQLite databases** का उपयोग करते हैं। pentest के दौरान बनाए गए **databases**, उनके **tables** और **columns** के नाम और सहेजे गए सभी **data** को देखें क्योंकि आप वहाँ **sensitive information** पा सकते हैं (जो एक vulnerability होगी).\
Databases आमतौर पर `/data/data/the.package.name/databases` में होते हैं जैसे `/data/data/com.mwr.example.sieve/databases`

यदि database confidential जानकारी सहेज रहा है और **encrypted** है पर आप application के अंदर password ढूँढ सकते हैं तो यह अभी भी एक **vulnerability** है।

.tables का उपयोग करके tables को enumerate करें और `.schema <table_name>` करके tables के columns को enumerate करें।

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** आपको **एक Android app की भूमिका अपनाने** और अन्य apps के साथ interact करने की अनुमति देता है। यह **वह सब कुछ कर सकता है जो एक installed application कर सकता है**, जैसे Android की Inter-Process Communication (IPC) mechanism का उपयोग करना और underlying operating system के साथ interact करना.\
Drozer एक उपयोगी tool है **exported activities, exported services और Content Providers को exploit करने के लिए** जैसा कि आप निम्नलिखित sections में सीखेंगे।

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
साथ ही याद रखें कि activity का code **`onCreate`** method में शुरू होता है।

**Authorisation bypass**

जब कोई Activity exported होती है तो आप external app से उसका स्क्रीन invoke कर सकते हैं। इसलिए, यदि कोई activity जिसमें **sensitive information** है **exported** है तो आप उसे access करने के लिए authentication mechanisms को **bypass** कर सकते हैं।

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

आप adb से भी एक exported activity start कर सकते हैं:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF किसी activity में `android:launchMode` के रूप में _**singleTask/singleInstance**_ के उपयोग को malicious के रूप में पहचानता है, लेकिन [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750) के कारण, जाहिरा तौर पर यह केवल पुराने संस्करणों (API versions < 21) में ही खतरनाक है।

> [!TIP]
> ध्यान दें कि एक authorisation bypass हमेशा एक vulnerability नहीं होती — यह इस पर निर्भर करेगा कि bypass कैसे काम करता है और कौन-सी जानकारी प्रकट होती है।

**Sensitive information leakage**

Activities भी results वापस कर सकती हैं। अगर आप कोई exported और unprotected activity ढूंढ लेते हैं जो **`setResult`** method कॉल कर रही है और **returning sensitive information** कर रही है, तो यह एक sensitive information leakage है।

#### Tapjacking

अगर tapjacking रोका नहीं गया है, तो आप exported activity का दुरुपयोग करके **user को अनपेक्षित कार्य करवाने** के लिए मजबूर कर सकते हैं। Tapjacking के बारे में अधिक जानकारी के लिए [**what is Tapjacking follow the link**](#tapjacking) देखें।

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers मूलतः **data share** करने के लिए उपयोग किए जाते हैं। अगर किसी app के पास उपलब्ध content providers हैं तो आप उनसे **sensitive** डेटा **extract** कर पाने में सक्षम हो सकते हैं। यह भी ज़रूरी है कि संभावित **SQL injections** और **Path Traversals** का टेस्ट किया जाए क्योंकि वे vulnerable हो सकते हैं।

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
याद रखें कि Service के actions method `onStartCommand` में शुरू होते हैं।

Service मूलतः कुछ ऐसा होता है जो **डेटा प्राप्त कर सकता है**, उसे **process** करता है और (या नहीं) एक response **returns** करता है। इसलिए, यदि कोई application कुछ services export कर रहा है तो आपको उसका **code** चेक कर के समझना चाहिए कि यह क्या कर रहा है और उसे **dynamically** टेस्ट करके confidential जानकारी निकालने, authentication measures को bypass करने आदि का प्रयास करना चाहिए।\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
याद रखें कि Broadcast Receiver के actions method `onReceive` में शुरू होते हैं।

एक broadcast receiver किसी प्रकार के message की प्रतीक्षा करेगा। यह इस पर निर्भर करता है कि receiver संदेश को कैसे handle करता है — यह vulnerable हो सकता है।\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

आप deep links को मैन्युअली खोज सकते हैं, MobSF जैसे tools या scripts जैसे [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py) का उपयोग करके।\
आप घोषित किए गए **scheme** को **adb** या किसी **browser** का उपयोग करके **open** कर सकते हैं:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_ध्यान दें कि आप **omit the package name** छोड़ सकते हैं और मोबाइल स्वचालित रूप से उस app को कॉल करेगा जो उस link को खोलना चाहिए._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Code executed**

In order to find the **code that will be executed in the App**, go to the activity called by the deeplink and search the function **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Sensitive info**

हर बार जब आप किसी deep link को पाते हैं तो जाँच करें कि क्या यह **URL parameters के माध्यम से संवेदनशील डेटा (जैसे passwords) प्राप्त नहीं कर रहा है**, क्योंकि कोई भी अन्य application उस deep link का impersonate कर सकता है और वह डेटा चरीद सकता/चुरा सकता है!

**Parameters in path**

आपको यह भी ज़रूर जाँचना चाहिए कि क्या कोई deep link URL के path के अंदर किसी parameter का उपयोग कर रहा है जैसे: `https://api.example.com/v1/users/{username}` , ऐसे मामलों में आप path traversal को फोर्स कर सकते हैं जैसे: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
यदि आप application के अंदर सही endpoints ढूँढ लेते हैं तो आप संभावित रूप से **Open Redirect** (यदि path का कोई हिस्सा domain name के रूप में उपयोग हो रहा हो), **account takeover** (यदि आप बिना CSRF token के users के विवरण बदल सकते हैं और vuln endpoint ने सही method का उपयोग किया हो) और अन्य किसी भी vuln को ट्रिगर कर सकते हैं। More [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Transport Layer Inspection and Verification Failures

- **Certificates are not always inspected properly** by Android applications. यह आम है कि ये applications warnings को अनदेखा कर self-signed certificates स्वीकार कर लें या कुछ मामलों में HTTP connections पर revert कर दें।
- **Negotiations during the SSL/TLS handshake are sometimes weak**, insecure cipher suites का उपयोग होता है। यह vulnerability connection को man-in-the-middle (MITM) attacks के लिए संवेदनशील बनाती है, जिससे attackers डेटा को decrypt कर सकते हैं।
- **Leakage of private information** is a risk when applications authenticate using secure channels but then communicate over non-secure channels for other transactions. यह तरीका संवेदनशील डेटा, जैसे session cookies या user details, को malicious entities द्वारा interception से सुरक्षित नहीं रखता।

#### Certificate Verification

हम focus करेंगे **certificate verification** पर। सर्वर के certificate की integrity verify करना सुरक्षा बढ़ाने के लिए आवश्यक है। यह महत्वपूर्ण है क्योंकि insecure TLS configurations और unencrypted चैनलों पर संवेदनशील डेटा भेजना गंभीर जोखिम पैदा कर सकता है। सर्वर certificates verify करने और vulnerabilities को address करने के विस्तृत steps के लिए, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) विस्तृत मार्गदर्शन प्रदान करता है।

#### SSL Pinning

SSL Pinning एक security measure है जहाँ application सर्वर के certificate को application में संग्रहीत ज्ञात copy के साथ verify करता है। यह method MITM attacks रोकने के लिए आवश्यक है। जो applications संवेदनशील जानकारी handle करते हैं उनके लिए SSL Pinning लागू करना अत्यधिक अनुशंसित है।

#### Traffic Inspection

HTTP traffic inspect करने के लिए, proxy tool का certificate (उदाहरण के लिए Burp) **install** करना ज़रूरी है। बिना इस certificate को install किए, encrypted traffic proxy के माध्यम से दिखाई नहीं दे सकती। custom CA certificate install करने के guide के लिए, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine)।

Applications जो **API Level 24 and above** target करते हैं उन्हें proxy के CA certificate को accept करने के लिए Network Security Config में परिवर्तन करने की आवश्यकता होती है। यह step encrypted traffic inspect करने के लिए critical है। Network Security Config modify करने के instructions के लिए, [**refer to this tutorial**](make-apk-accept-ca-certificate.md)।

यदि **Flutter** उपयोग में है तो आपको [**this page**](flutter.md) में दिए निर्देशों का पालन करना होगा। ऐसा इसलिए है क्योंकि केवल certificate को store में जोड़ना काम नहीं करेगा क्योंकि Flutter की अपनी valid CAs की सूची होती है।

#### Static detection of SSL/TLS pinning

runtime bypasses करने के प्रयास से पहले, जल्दी से map करें कि APK में pinning कहाँ enforce किया गया है। Static discovery आपको hooks/patches की योजना बनाने और सही code paths पर ध्यान केंद्रित करने में मदद करता है।

Tool: SSLPinDetect
- Open-source static-analysis utility जो APK को Smali (via apktool) में decompile करके SSL/TLS pinning implementations के curated regex patterns के लिए scan करता है।
- हर match के लिए exact file path, line number, और एक code snippet report करता है।
- सामान्य frameworks और custom code paths को कवर करता है: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, और Network Security Config XML pins।

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
उपयोग
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
उदाहरण पैटर्न नियम (JSON)
proprietary/custom pinning शैलियों का पता लगाने के लिए signatures का उपयोग करें या उन्हें बढ़ाएँ। आप अपना JSON लोड कर सकते हैं और बड़े पैमाने पर स्कैन कर सकते हैं।
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes and tips
- बड़े ऐप्स पर तेज़ स्कैनिंग via multi-threading और memory-mapped I/O; pre-compiled regex overhead/false positives घटाता है।
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- अगले triage के लिए सामान्य detection targets:
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Declarative pins in res/xml network security config और manifest references
- matched locations का उपयोग Frida hooks, static patches, या config reviews की योजना बनाने के लिए करें इससे पहले कि आप dynamic testing करें।



#### SSL Pinning को बायपास करना

जब SSL Pinning लागू किया जाता है, तो HTTPS ट्रैफिक की जांच के लिए इसे बायपास करना आवश्यक हो जाता है। इसके लिए विभिन्न तरीके उपलब्ध हैं:

- Automatically **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). इसका सबसे बड़ा फायदा यह है कि आपको SSL Pinning बायपास करने के लिए root की जरूरत नहीं पड़ेगी, लेकिन आपको एप्लिकेशन को डिलीट करके नया इंस्टॉल करना होगा, और यह हमेशा काम नहीं करेगा।
- आप इसे बायपास करने के लिए **Frida** का उपयोग कर सकते हैं (नीचे चर्चा की गई है)। यहाँ Burp+Frida+Genymotion को उपयोग करने का गाइड है: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- आप [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"` का उपयोग करके SSL Pinning को स्वचालित रूप से बायपास करने की कोशिश भी कर सकते हैं।
- आप **MobSF dynamic analysis** का उपयोग करके भी SSL Pinning को स्वचालित रूप से बायपास करने की कोशिश कर सकते हैं (नीचे समझाया गया है)।
- यदि आपको अभी भी लगता है कि कुछ ट्रैफिक कैप्चर नहीं हो रहा है तो आप ट्रैफिक को burp पर फॉरवर्ड करने के लिए iptables का उपयोग कर सकते हैं। यह ब्लॉग पढ़ें: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### एप्लिकेशन में सामान्य वेब कमजोरियों की तलाश

ऐप्लिकेशन के भीतर सामान्य वेब vulnerabilities की तलाश करना भी महत्वपूर्ण है। इन कमजोरियों की पहचान और उन्हें मिटाने के विस्तृत तरीके इस सारांश के दायरे से बाहर हैं लेकिन बहुत व्यापक रूप से अन्य जगहों पर कवर किए गए हैं।

### Frida

[Frida](https://www.frida.re) developers, reverse-engineers, और security researchers के लिए एक dynamic instrumentation toolkit है.\
**आप चल रही application तक पहुँच कर run time पर methods को hook कर सकते हैं ताकि व्यवहार बदलें, मान बदलें, मान निकालें, अलग code चलाएँ...**\
यदि आप Android applications की pentesting करना चाहते हैं तो आपको Frida का उपयोग करना आना चाहिए।

- Frida का उपयोग कैसे करें जानें: [**Frida tutorial**](frida-tutorial/index.html)
- Frida के साथ actions के लिए कुछ "GUI": [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection Frida के उपयोग को automate करने के लिए अच्छा है: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- कुछ Awesome Frida scripts यहाँ मिलेंगी: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- anti-debugging / anti-frida mechanisms को bypass करने की कोशिश करें, Frida को ऐसे load करके जैसा यहाँ बताया गया है: [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

जाँचे कि क्या application मेमोरी में संवेदनशील जानकारी स्टोर कर रहा है जो इसे नहीं रखना चाहिए, जैसे पासवर्ड या mnemonics।

Using [**Fridump3**](https://github.com/rootbsd/fridump3) आप ऐप की मेमोरी को dump कर सकते हैं:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
यह ./dump फ़ोल्डर में memory को dump करेगा, और वहां आप कुछ इस तरह grep कर सकते हैं:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Keystore में संवेदनशील डेटा**

Android में Keystore संवेदनशील डेटा स्टोर करने के लिए सबसे अच्छा स्थान है, लेकिन पर्याप्त privileges होने पर इसे फिर भी **इसे access करना संभव** है। चूँकि एप्लिकेशन यहाँ अक्सर **sensitive data in clear text** स्टोर करते हैं, इसलिए pentests को इसे root user के रूप में चेक करना चाहिए — किसी के पास device का physical access होने पर वह यह डेटा चुरा सकता है।

भले ही कोई app keystore में डेटा स्टोर करे, डेटा को encrypted होना चाहिए।

keystore के अंदर के डेटा को access करने के लिए आप इस Frida script का उपयोग कर सकते हैं: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

निम्नलिखित Frida script का उपयोग करके संभवतः उन Android applications में लागू किए गए **bypass fingerprint authentication** को दरकिनार किया जा सकता है, जो **कुछ संवेदनशील क्षेत्रों की सुरक्षा** के लिए किया जाता है:
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Background Images**

जब आप किसी ऐप को background में भेजते हैं, तो Android एक **snapshot of the application** स्टोर करता है — ताकि जब उसे foreground में वापस लाया जाए तो यह ऐप से पहले उस image को लोड करना शुरू कर दे और ऐसा लगे कि ऐप तेज़ी से लोड हुआ।

हालाँकि, अगर यह snapshot में **संवेदनशील जानकारी** मौजूद हो, तो snapshot तक पहुँच रखने वाला कोई भी व्यक्ति **उस जानकारी को चुरा सकता है** (ध्यान दें कि इसे एक्सेस करने के लिए root की आवश्यकता होती है)।

Snapshots सामान्यतः इस स्थान पर स्टोर रहते हैं: **`/data/system_ce/0/snapshots`**

Android एक तरीका प्रदान करता है जिससे आप लेआउट पैरामीटर में **FLAG_SECURE सेट करके screenshot capture को रोक सकते हैं**। इस flag का उपयोग करने पर, window की सामग्री को secure माना जाता है, जिससे वह screenshots में दिखाई नहीं देती और non-secure डिस्प्ले पर नहीं देखी जा सकती।
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

यह टूल dynamic analysis के दौरान विभिन्न टूल्स को मैनेज करने में मदद कर सकता है: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

डेवलपर्स अक्सर proxy components जैसे activities, services, और broadcast receivers बनाते हैं जो इन Intents को हैंडल करते हैं और उन्हें `startActivity(...)` या `sendBroadcast(...)` जैसे methods को पास कर देते हैं, जो रिस्की हो सकता है।

खतरा इस बात में है कि attackers इन Intents को मिसडायरेक्ट करके non-exported app components या sensitive content providers को ट्रिगर कर सकते हैं। एक उल्लेखनीय उदाहरण है `WebView` component जो URLs को `Intent` objects में `Intent.parseUri(...)` के जरिए कन्वर्ट करता है और फिर उन्हें execute करता है, जिससे malicious Intent injections हो सकते हैं।

### Essential Takeaways

- **Intent Injection** web के Open Redirect issue जैसा है।
- Exploits में `Intent` objects को extras के रूप में पास करना शामिल होता है, जिन्हें redirect करके unsafe operations execute कराए जा सकते हैं।
- यह non-exported components और content providers को attackers के लिए उजागर कर सकता है।
- `WebView` की URL से `Intent` conversion अनचाहे actions को सक्षम कर सकती है।

### Android Client Side Injections and others

शायद आप इस प्रकार की vulnerabilities के बारे में वेब से परिचित होंगे। Android application में इन vulnerabilities के साथ विशेष सतर्कता बरतनी चाहिए:

- **SQL Injection:** जब dynamic queries या Content-Providers के साथ काम कर रहे हों तो सुनिश्चित करें कि आप parameterized queries का उपयोग कर रहे हैं।
- **JavaScript Injection (XSS):** Verify करें कि किसी भी WebViews के लिए JavaScript और Plugin support disabled हो (disabled by default)। [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews को file system तक access बंद होना चाहिए (enabled by default) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: कई मामलों में जब android application session समाप्त करता है तो cookie revoke नहीं होती या वह disk पर भी saved हो सकती है
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Static analysis**

![](<../../images/image (866).png>)

**Vulnerability assessment of the application** एक अच्छे वेब-आधारित frontend का उपयोग करके करता है। आप dynamic analysis भी चला सकते हैं (लेकिन इसके लिए environment तैयार करना होगा)।
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Assisted Dynamic analysis with MobSF

**MobSF** Android में **dynamic analysis** के लिए भी बहुत मददगार हो सकता है, पर इस मामले में आपको अपने host पर MobSF और **genymotion** दोनों इंस्टॉल करने होंगे (एक VM या Docker काम नहीं करेगा)। _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
**MobSF dynamic analyser** निम्न कर सकता है:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). ये सब अपने आप किया जाता है सिवाय screenshots के — जब आप screenshot लेना चाहें तो आपको उसे क्लिक करना होगा या सभी exported activities के screenshots प्राप्त करने के लिए आपको "**Exported Activity Tester**" दबाना होगा।
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: यह सभी loaded classes को प्रिंट करेगा
- **Capture Strings**: यह application उपयोग करते समय मिलने वाली सभी capture strings को प्रिंट करेगा (काफी noisy)
- **Capture String Comparisons**: बहुत उपयोगी हो सकता है। यह **show the 2 strings being compared** करेगा और बताएगा कि result True था या False।
- **Enumerate Class Methods**: क्लास का नाम डालें (जैसे "java.io.File") और यह उस क्लास के सभी methods को प्रिंट करेगा।
- **Search Class Pattern**: pattern से classes खोजें
- **Trace Class Methods**: **Trace** a **whole class** (see inputs and outputs of all methods of th class). याद रखें कि default में MobSF कई दिलचस्प Android Api methods को trace करता है।

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf dynamic analysis पेज के नीचे कुछ **adb** commands, **MobSF commands**, और सामान्य **shell** **commands** के साथ एक shell भी देता है। कुछ रोचक commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP उपकरण**

जब HTTP ट्रैफ़िक कैप्चर होता है, आप कैप्चर किए गए ट्रैफ़िक का एक बदसूरत व्यू "**HTTP(S) Traffic**" बटन में देख सकते हैं या एक बेहतर व्यू "**Start HTTPTools**" हरे बटन में। दूसरे विकल्प से, आप **कैप्चर किए हुए अनुरोध** को **proxies** जैसे Burp या Owasp ZAP को **भेज** सकते हैं.\  
ऐसा करने के लिए, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> press "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

MobSF के साथ dynamic analysis पूरा करने के बाद आप "**Start Web API Fuzzer**" दबाकर **fuzz http requests** कर सकते हैं और कमजोरियों की तलाश कर सकते हैं।

> [!TIP]
> After performing a dynamic analysis with MobSF the proxy settings me be misconfigured and you won't be able to fix them from the GUI. You can fix the proxy settings by doing:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

You can get the tool from [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
This tool with use some **Hooks** to let you know **what is happening in the application** while you perform a **dynamic analysis**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

यह GUI के साथ static analysis करने के लिए एक शानदार tool है

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

यह tool कई **security related Android application vulnerabilities** की खोज के लिए बनाया गया है, चाहे वो **source code** में हों या **packaged APKs** में। यह tool **capable of creating a "Proof-of-Concept" deployable APK** और **ADB commands** भी बनाने में सक्षम है, ताकि पाए गए कुछ vulnerabilities (Exposed activities, intents, tapjacking...) का exploit किया जा सके। Drozer की तरह, टेस्ट डिवाइस को root करने की आवश्यकता नहीं है।
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- संदर्भ के लिए सभी निकाली गई फ़ाइलें दिखाता है
- APK फ़ाइलों को स्वचालित रूप से Java और Smali फ़ॉर्मेट में decompile करता है
- सामान्य vulnerabilities और व्यवहार के लिए AndroidManifest.xml का विश्लेषण करता है
- सामान्य vulnerabilities और व्यवहार के लिए Static source code analysis करता है
- डिवाइस जानकारी
- और भी
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER एक command-line application है जिसे Windows, MacOS X और Linux पर इस्तेमाल किया जा सकता है, जो कमजोरियों की तलाश में _.apk_ फ़ाइलों का विश्लेषण करता है। यह APKs को decompress करके और उन कमजोरियों का पता लगाने के लिए नियमों की एक श्रृंखला लागू करके यह काम करता है।

सभी नियम `rules.json` फ़ाइल में केंद्रीकृत हैं, और प्रत्येक कंपनी या tester अपनी ज़रूरत के अनुसार अपने नियम बना सकती/बना सकता है।

नवीनतम binaries को [download page](https://superanalyzer.rocks/download.html) से डाउनलोड करें
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn एक **क्रॉसप्लेटफ़ॉर्म** टूल है जो मोबाइल एप्लिकेशनों पर [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) करने वाले डेवलपर्स, bugbounty hunters और ethical hackers की मदद करता है।

आइडिया यह है कि आप अपनी मोबाइल एप्लिकेशन फ़ाइल (.apk या .ipa फ़ाइल) को StaCoAn एप्लिकेशन पर ड्रैग और ड्रॉप करें और यह आपके लिए एक विज़ुअल और पोर्टेबल रिपोर्ट जेनरेट करेगा। आप सेटिंग्स और wordlists को समायोजित करके एक कस्टमाइज़्ड अनुभव प्राप्त कर सकते हैं।

डाउनलोड[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework एक Android vulnerability analysis system है जो डेवलपर्स या hackers को Android applications में संभावित security vulnerabilities खोजने में मदद करता है।\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** एक उपकरण है जिसका मुख्य उद्देश्य Android application द्वारा विकसित संभावित हानिकारक व्यवहारों का पता लगाना और उपयोगकर्ता को चेतावनी देना है।

यह पता application's Dalvik bytecode के **static analysis** के माध्यम से लगाया जाता है, जिसे **Smali** के रूप में प्रतिनिधित्व किया गया है, और इसके लिए [`androguard`](https://github.com/androguard/androguard) लाइब्रेरी का उपयोग किया जाता है।

यह टूल **common behavior of "bad" applications** जैसी चीज़ों को ढूँढता है: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. यह एक ऐसा टूल है जो सामान्यतः उपयोग होने वाले mobile application reverse engineering और analysis tools को एकत्र करता है, ताकि OWASP mobile security threats के खिलाफ mobile applications के परीक्षण में मदद मिल सके। इसका उद्देश्य mobile application developers और security professionals के लिए यह कार्य आसान और अधिक अनुकूल बनाना है।

It is able to:

- विभिन्न उपकरणों का उपयोग करके Java और Smali कोड निकालना
- APKs का विश्लेषण करने के लिए उपयोग करें: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- regexps का उपयोग करके APK से निजी जानकारी निकालना
- Manifest का विश्लेषण करना
- पाए गए domains का विश्लेषण करने के लिए उपयोग करें: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- APK को [apk-deguard.com](http://www.apk-deguard.com) के माध्यम से Deobfuscate करना

### Koodous

मैलवेयर का पता लगाने के लिए उपयोगी: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

ध्यान दें कि आप जिस service और configuration का उपयोग करके code को obfuscate करते हैं, उसके अनुसार secrets obfuscated हो सकते हैं या नहीं भी हो सकते हैं।

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** एक open source command-line tool है जो Java code को shrink, optimize और obfuscate करता है। यह bytecode को optimize करने के साथ-साथ unused instructions का पता लगा कर उन्हें हटा भी सकता है। ProGuard free software है और GNU General Public License, version 2 के तहत वितरित होता है।

ProGuard Android SDK का हिस्सा के रूप में वितरित होता है और application को release mode में build करते समय चलता है।

### [DexGuard](https://www.guardsquare.com/dexguard)

Deobfuscate करने के लिए step-by-step guide देखें: [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(उस गाइड से) Last time we checked, the Dexguard mode of operation was:

- एक resource को InputStream के रूप में load करना;
- परिणाम को FilterInputStream से विरासत में ली गई एक class को feed करना ताकि इसे decrypt किया जा सके;
- reverser का थोड़ा समय बर्बाद करने के लिए कुछ बेकार obfuscation करना;
- decrypted परिणाम को ZipInputStream को feed करना ताकि एक DEX file मिले;
- अंत में प्राप्त DEX को Resource के रूप में `loadDex` method का उपयोग करके लोड करना।

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

आप obfuscated APK को उनके platform पर upload कर सकते हैं।

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

यह एक LLM tool है जो android apps में संभावित security vulnerabilities खोजने और android app code को deobfuscate करने के लिए है। Google के Gemini public API का उपयोग करता है।

### [Simplify](https://github.com/CalebFenton/simplify)

It is a **generic android deobfuscator.** Simplify एक app को **virtually execute** करता है ताकि उसके व्यवहार को समझा जा सके और फिर **tries to optimize the code** ताकि वह identical व्यवहार करे लेकिन मानव के लिए समझना आसान हो। प्रत्येक optimization type simple और generic है, इसलिए यह मायने नहीं रखता कि किस specific प्रकार का obfuscation उपयोग किया गया है।

### [APKiD](https://github.com/rednaga/APKiD)

APKiD आपको यह जानकारी देता है कि **how an APK was made**. यह कई **compilers**, **packers**, **obfuscators**, और अन्य अजीब चीज़ों की पहचान करता है। यह Android के लिए [_PEiD_](https://www.aldeid.com/wiki/PEiD) है।

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b एक Android security virtual machine है जो ubuntu-mate पर आधारित है और इसमें विभिन्न security geeks और researchers द्वारा reverse engineering और malware analysis के लिए नवीनतम framework, tutorials और labs का संग्रह शामिल है।

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) यह resources की एक बेहतरीन सूची है
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)

## Yet to try

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
