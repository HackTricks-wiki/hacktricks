# Pentesting de Aplicaciones Android

{{#include ../../banners/hacktricks-training.md}}

<figure><img src="../../images/image (3).png" alt=""><figcaption></figcaption></figure>

¡Únete al servidor de [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) para comunicarte con hackers experimentados y cazadores de recompensas por errores!

**Perspectivas de Hacking**\
Participa en contenido que profundiza en la emoción y los desafíos del hacking

**Noticias de Hackeo en Tiempo Real**\
Mantente al día con el mundo del hacking de ritmo rápido a través de noticias e información en tiempo real

**Últimos Anuncios**\
Mantente informado sobre las nuevas recompensas por errores que se lanzan y actualizaciones cruciales de la plataforma

**Únete a nosotros en** [**Discord**](https://discord.com/invite/N3FrSbmwdy) y comienza a colaborar con los mejores hackers hoy mismo!

## Fundamentos de Aplicaciones Android

Se recomienda encarecidamente comenzar a leer esta página para conocer las **partes más importantes relacionadas con la seguridad de Android y los componentes más peligrosos en una aplicación Android**:

{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Esta es la herramienta principal que necesitas para conectarte a un dispositivo Android (emulado o físico).\
**ADB** permite controlar dispositivos ya sea por **USB** o **Red** desde una computadora. Esta utilidad permite la **copia** de archivos en ambas direcciones, **instalación** y **desinstalación** de aplicaciones, **ejecución** de comandos de shell, **respaldo** de datos, **lectura** de registros, entre otras funciones.

Echa un vistazo a la siguiente lista de [**Comandos ADB**](adb-commands.md) para aprender a usar adb.

## Smali

A veces es interesante **modificar el código de la aplicación** para acceder a **información oculta** (quizás contraseñas o banderas bien ofuscadas). Entonces, podría ser interesante descompilar el apk, modificar el código y recompilarlo.\
[**En este tutorial** puedes **aprender a descompilar un APK, modificar el código Smali y recompilar el APK** con la nueva funcionalidad](smali-changes.md). Esto podría ser muy útil como una **alternativa para varias pruebas durante el análisis dinámico** que se van a presentar. Entonces, **siempre ten en mente esta posibilidad**.

## Otros trucos interesantes

- [Suplantar tu ubicación en Play Store](spoofing-your-location-in-play-store.md)
- **Descargar APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Extraer APK del dispositivo:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Combina todos los splits y apks base con [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Análisis Estático

Primero que nada, para analizar un APK deberías **echar un vistazo al código Java** usando un descompilador.\
Por favor, [**lee aquí para encontrar información sobre diferentes descompiladores disponibles**](apk-decompilers.md).

### Buscando información interesante

Solo echando un vistazo a las **cadenas** del APK puedes buscar **contraseñas**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **claves** **api**, **cifrado**, **uuids de bluetooth**, **tokens** y cualquier cosa interesante... busca incluso **puertas traseras** de ejecución de código o puertas traseras de autenticación (credenciales de administrador codificadas en la aplicación).

**Firebase**

Presta especial atención a las **URLs de firebase** y verifica si está mal configurado. [Más información sobre qué es Firebase y cómo explotarlo aquí.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Comprensión básica de la aplicación - Manifest.xml, strings.xml

La **examinación de los archivos \_Manifest.xml**_\*\* y \*\*_**strings.xml**\_\*\* de una aplicación puede revelar posibles vulnerabilidades de seguridad\*\*. Estos archivos se pueden acceder usando descompiladores o renombrando la extensión del archivo APK a .zip y luego descomprimiéndolo.

**Vulnerabilidades** identificadas en el **Manifest.xml** incluyen:

- **Aplicaciones depurables**: Las aplicaciones configuradas como depurables (`debuggable="true"`) en el archivo _Manifest.xml_ representan un riesgo ya que permiten conexiones que pueden llevar a la explotación. Para una mejor comprensión sobre cómo explotar aplicaciones depurables, consulta un tutorial sobre cómo encontrar y explotar aplicaciones depurables en un dispositivo.
- **Configuraciones de respaldo**: El atributo `android:allowBackup="false"` debe establecerse explícitamente para aplicaciones que manejan información sensible para prevenir copias de seguridad no autorizadas a través de adb, especialmente cuando la depuración por usb está habilitada.
- **Seguridad de red**: Configuraciones de seguridad de red personalizadas (`android:networkSecurityConfig="@xml/network_security_config"`) en _res/xml/_ pueden especificar detalles de seguridad como pines de certificado y configuraciones de tráfico HTTP. Un ejemplo es permitir tráfico HTTP para dominios específicos.
- **Actividades y servicios exportados**: Identificar actividades y servicios exportados en el manifiesto puede resaltar componentes que podrían ser mal utilizados. Un análisis adicional durante las pruebas dinámicas puede revelar cómo explotar estos componentes.
- **Proveedores de contenido y FileProviders**: Los proveedores de contenido expuestos podrían permitir acceso no autorizado o modificación de datos. La configuración de los FileProviders también debe ser examinada.
- **Receptores de difusión y esquemas de URL**: Estos componentes podrían ser aprovechados para la explotación, prestando especial atención a cómo se gestionan los esquemas de URL para vulnerabilidades de entrada.
- **Versiones de SDK**: Los atributos `minSdkVersion`, `targetSDKVersion` y `maxSdkVersion` indican las versiones de Android soportadas, destacando la importancia de no soportar versiones de Android obsoletas y vulnerables por razones de seguridad.

Del archivo **strings.xml**, se puede descubrir información sensible como claves API, esquemas personalizados y otras notas de desarrollador, subrayando la necesidad de una revisión cuidadosa de estos recursos.

### Tapjacking

**Tapjacking** es un ataque donde una **aplicación maliciosa** se lanza y **se posiciona encima de una aplicación víctima**. Una vez que oculta visiblemente la aplicación víctima, su interfaz de usuario está diseñada de tal manera que engaña al usuario para que interactúe con ella, mientras pasa la interacción a la aplicación víctima.\
En efecto, está **cegando al usuario para que no sepa que realmente está realizando acciones en la aplicación víctima**.

Encuentra más información en:

{{#ref}}
tapjacking.md
{{#endref}}

### Secuestro de Tareas

Una **actividad** con el **`launchMode`** configurado como **`singleTask` sin ninguna `taskAffinity`** definida es vulnerable al secuestro de tareas. Esto significa que una **aplicación** puede ser instalada y si se lanza antes que la aplicación real, podría **secuestrar la tarea de la aplicación real** (por lo que el usuario estará interactuando con la **aplicación maliciosa pensando que está usando la real**).

Más información en:

{{#ref}}
android-task-hijacking.md
{{#endref}}

### Almacenamiento de datos inseguro

**Almacenamiento Interno**

En Android, los archivos **almacenados** en el **almacenamiento interno** están **diseñados** para ser **accesibles** exclusivamente por la **aplicación** que los **creó**. Esta medida de seguridad es **aplicada** por el sistema operativo Android y generalmente es adecuada para las necesidades de seguridad de la mayoría de las aplicaciones. Sin embargo, los desarrolladores a veces utilizan modos como `MODE_WORLD_READABLE` y `MODE_WORLD_WRITABLE` para **permitir** que los archivos sean **compartidos** entre diferentes aplicaciones. Sin embargo, estos modos **no restringen el acceso** a estos archivos por otras aplicaciones, incluidas las potencialmente maliciosas.

1. **Análisis Estático:**
- **Asegúrate** de que el uso de `MODE_WORLD_READABLE` y `MODE_WORLD_WRITABLE` sea **examinado cuidadosamente**. Estos modos **pueden potencialmente exponer** archivos a **acceso no intencionado o no autorizado**.
2. **Análisis Dinámico:**
- **Verifica** los **permisos** establecidos en los archivos creados por la aplicación. Específicamente, **verifica** si algún archivo está **configurado para ser legible o escribible a nivel mundial**. Esto puede representar un riesgo de seguridad significativo, ya que permitiría que **cualquier aplicación** instalada en el dispositivo, independientemente de su origen o intención, **lea o modifique** estos archivos.

**Almacenamiento Externo**

Al tratar con archivos en **almacenamiento externo**, como tarjetas SD, se deben tomar ciertas precauciones:

1. **Accesibilidad**:
- Los archivos en almacenamiento externo son **globalmente legibles y escribibles**. Esto significa que cualquier aplicación o usuario puede acceder a estos archivos.
2. **Preocupaciones de Seguridad**:
- Dada la facilidad de acceso, se aconseja **no almacenar información sensible** en almacenamiento externo.
- El almacenamiento externo puede ser removido o accedido por cualquier aplicación, haciéndolo menos seguro.
3. **Manejo de Datos desde Almacenamiento Externo**:
- Siempre **realiza validación de entrada** en los datos recuperados del almacenamiento externo. Esto es crucial porque los datos provienen de una fuente no confiable.
- Almacenar ejecutables o archivos de clase en almacenamiento externo para carga dinámica está fuertemente desaconsejado.
- Si tu aplicación debe recuperar archivos ejecutables del almacenamiento externo, asegúrate de que estos archivos estén **firmados y verificados criptográficamente** antes de ser cargados dinámicamente. Este paso es vital para mantener la integridad de seguridad de tu aplicación.

El almacenamiento externo puede ser **accedido** en `/storage/emulated/0`, `/sdcard`, `/mnt/sdcard`

> [!NOTE]
> A partir de Android 4.4 (**API 17**), la tarjeta SD tiene una estructura de directorios que **limita el acceso de una aplicación al directorio que es específicamente para esa aplicación**. Esto previene que aplicaciones maliciosas obtengan acceso de lectura o escritura a los archivos de otra aplicación.

**Datos sensibles almacenados en texto claro**

- **Preferencias compartidas**: Android permite a cada aplicación guardar fácilmente archivos xml en la ruta `/data/data/<packagename>/shared_prefs/` y a veces es posible encontrar información sensible en texto claro en esa carpeta.
- **Bases de datos**: Android permite a cada aplicación guardar fácilmente bases de datos sqlite en la ruta `/data/data/<packagename>/databases/` y a veces es posible encontrar información sensible en texto claro en esa carpeta.

### TLS Roto

**Aceptar Todos los Certificados**

Por alguna razón, a veces los desarrolladores aceptan todos los certificados incluso si, por ejemplo, el nombre de host no coincide con líneas de código como la siguiente:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Una buena manera de probar esto es intentar capturar el tráfico usando algún proxy como Burp sin autorizar el Burp CA dentro del dispositivo. Además, puedes generar con Burp un certificado para un nombre de host diferente y usarlo.

### Criptografía Rota

**Procesos de Gestión de Claves Pobres**

Algunos desarrolladores guardan datos sensibles en el almacenamiento local y los encriptan con una clave codificada/predictible en el código. Esto no debería hacerse, ya que alguna ingeniería inversa podría permitir a los atacantes extraer la información confidencial.

**Uso de Algoritmos Inseguros y/o Obsoletos**

Los desarrolladores no deberían usar **algoritmos obsoletos** para realizar **verificaciones de autorización**, **almacenar** o **enviar** datos. Algunos de estos algoritmos son: RC4, MD4, MD5, SHA1... Si se utilizan **hashes** para almacenar contraseñas, por ejemplo, se deberían usar hashes resistentes a **fuerza bruta** con sal.

### Otras verificaciones

- Se recomienda **ofuscar el APK** para dificultar el trabajo de ingeniería inversa a los atacantes.
- Si la aplicación es sensible (como las aplicaciones bancarias), debería realizar sus **propias verificaciones para ver si el móvil está rooteado** y actuar en consecuencia.
- Si la aplicación es sensible (como las aplicaciones bancarias), debería verificar si se está utilizando un **emulador**.
- Si la aplicación es sensible (como las aplicaciones bancarias), debería **verificar su propia integridad antes de ejecutarse** para comprobar si ha sido modificada.
- Usa [**APKiD**](https://github.com/rednaga/APKiD) para verificar qué compilador/empaquetador/ofuscador se utilizó para construir el APK.

### Aplicación React Native

Lee la siguiente página para aprender cómo acceder fácilmente al código javascript de las aplicaciones React:

{{#ref}}
react-native-application.md
{{#endref}}

### Aplicaciones Xamarin

Lee la siguiente página para aprender cómo acceder fácilmente al código C# de una aplicación xamarin:

{{#ref}}
../xamarin-apps.md
{{#endref}}

### Aplicaciones Superempaquetadas

Según este [**blog**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/), superempaquetado es un algoritmo Meta que comprime el contenido de una aplicación en un solo archivo. El blog habla sobre la posibilidad de crear una aplicación que descomprima este tipo de aplicaciones... y una forma más rápida que implica **ejecutar la aplicación y recopilar los archivos descomprimidos del sistema de archivos.**

### Análisis Estático Automatizado del Código

La herramienta [**mariana-trench**](https://github.com/facebook/mariana-trench) es capaz de encontrar **vulnerabilidades** al **escanear** el **código** de la aplicación. Esta herramienta contiene una serie de **fuentes conocidas** (que indican a la herramienta los **lugares** donde la **entrada** es **controlada por el usuario**), **sumideros** (que indican a la herramienta **lugares peligrosos** donde la entrada maliciosa del usuario podría causar daños) y **reglas**. Estas reglas indican la **combinación** de **fuentes-sumideros** que indica una vulnerabilidad.

Con este conocimiento, **mariana-trench revisará el código y encontrará posibles vulnerabilidades en él**.

### Secretos filtrados

Una aplicación puede contener secretos (claves API, contraseñas, URLs ocultas, subdominios...) dentro de ella que podrías descubrir. Podrías usar una herramienta como [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks).

### Bypass de Autenticación Biométrica

{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Otras funciones interesantes

- **Ejecución de código**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Enviar SMS**: `sendTextMessage, sendMultipartTestMessage`
- **Funciones nativas** declaradas como `native`: `public native, System.loadLibrary, System.load`
- [Lee esto para aprender **cómo revertir funciones nativas**](reversing-native-libraries.md)

### **Otros trucos**

{{#ref}}
content-protocol.md
{{#endref}}

---

<figure><img src="../../images/image (3).png" alt=""><figcaption></figcaption></figure>

Únete al servidor de [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) para comunicarte con hackers experimentados y cazadores de recompensas por errores.

**Perspectivas de Hacking**\
Participa en contenido que profundiza en la emoción y los desafíos del hacking.

**Noticias de Hackeo en Tiempo Real**\
Mantente al día con el mundo del hacking de ritmo rápido a través de noticias e información en tiempo real.

**Últimos Anuncios**\
Mantente informado sobre las nuevas recompensas por errores que se lanzan y actualizaciones cruciales de la plataforma.

**Únete a nosotros en** [**Discord**](https://discord.com/invite/N3FrSbmwdy) y comienza a colaborar con los mejores hackers hoy mismo.

---

## Análisis Dinámico

> Primero que nada, necesitas un entorno donde puedas instalar la aplicación y todo el entorno (certificado Burp CA, Drozer y Frida principalmente). Por lo tanto, se recomienda encarecidamente un dispositivo rooteado (emulado o no).

### Análisis dinámico en línea

Puedes crear una **cuenta gratuita** en: [https://appetize.io/](https://appetize.io). Esta plataforma te permite **subir** y **ejecutar** APKs, por lo que es útil para ver cómo se comporta un apk.

Incluso puedes **ver los registros de tu aplicación** en la web y conectarte a través de **adb**.

![](<../../images/image (831).png>)

Gracias a la conexión ADB, puedes usar **Drozer** y **Frida** dentro de los emuladores.

### Análisis dinámico local

#### Usando un emulador

- [**Android Studio**](https://developer.android.com/studio) (Puedes crear dispositivos **x86** y **arm**, y según [**esto**](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**las últimas versiones x86** **soportan bibliotecas ARM** sin necesidad de un emulador arm lento).
- Aprende a configurarlo en esta página:

{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Versión gratuita:** Edición Personal, necesitas crear una cuenta. _Se recomienda **descargar** la versión **CON**_ _**VirtualBox** para evitar errores potenciales._)
- [**Nox**](https://es.bignox.com) (Gratis, pero no soporta Frida o Drozer).

> [!NOTE]
> Al crear un nuevo emulador en cualquier plataforma, recuerda que cuanto más grande sea la pantalla, más lento funcionará el emulador. Así que selecciona pantallas pequeñas si es posible.

Para **instalar servicios de Google** (como AppStore) en Genymotion, necesitas hacer clic en el botón marcado en rojo de la siguiente imagen:

![](<../../images/image (277).png>)

Además, ten en cuenta que en la **configuración de la VM de Android en Genymotion** puedes seleccionar **modo de red Bridge** (esto será útil si te conectarás a la VM de Android desde una VM diferente con las herramientas).

#### Usar un dispositivo físico

Necesitas activar las **opciones de depuración** y sería genial si puedes **rootearlo**:

1. **Configuración**.
2. (Desde Android 8.0) Selecciona **Sistema**.
3. Selecciona **Acerca del teléfono**.
4. Presiona **Número de compilación** 7 veces.
5. Regresa y encontrarás las **Opciones de desarrollador**.

> Una vez que hayas instalado la aplicación, lo primero que debes hacer es probarla e investigar qué hace, cómo funciona y familiarizarte con ella.\
> Te sugeriré **realizar este análisis dinámico inicial usando el análisis dinámico de MobSF + pidcat**, para que podamos **aprender cómo funciona la aplicación** mientras MobSF **captura** muchos **datos interesantes** que puedes revisar más tarde.

### Filtración de Datos No Intencionada

**Registro**

Los desarrolladores deben tener cuidado de no exponer **información de depuración** públicamente, ya que puede llevar a filtraciones de datos sensibles. Se recomiendan las herramientas [**pidcat**](https://github.com/JakeWharton/pidcat) y `adb logcat` para monitorear los registros de la aplicación y proteger la información sensible. **Pidcat** es preferido por su facilidad de uso y legibilidad.

> [!WARNING]
> Ten en cuenta que desde **versiones posteriores a Android 4.0**, **las aplicaciones solo pueden acceder a sus propios registros**. Así que las aplicaciones no pueden acceder a los registros de otras aplicaciones.\
> De todos modos, sigue siendo recomendable **no registrar información sensible**.

**Caché del Portapapeles**

El marco **basado en portapapeles** de Android permite la funcionalidad de copiar y pegar en las aplicaciones, pero presenta un riesgo ya que **otras aplicaciones** pueden **acceder** al portapapeles, exponiendo potencialmente datos sensibles. Es crucial **deshabilitar las funciones de copiar/pegar** para secciones sensibles de una aplicación, como los detalles de tarjetas de crédito, para prevenir filtraciones de datos.

**Registros de Fallos**

Si una aplicación **se bloquea** y **guarda registros**, estos registros pueden ayudar a los atacantes, especialmente cuando la aplicación no puede ser revertida. Para mitigar este riesgo, evita registrar en caso de fallos, y si los registros deben ser transmitidos a través de la red, asegúrate de que se envíen a través de un canal SSL por seguridad.

Como pentester, **intenta echar un vistazo a estos registros**.

**Datos de Análisis Enviados a Terceros**

Las aplicaciones a menudo integran servicios como Google Adsense, que pueden inadvertidamente **filtrar datos sensibles** debido a una implementación incorrecta por parte de los desarrolladores. Para identificar posibles filtraciones de datos, es aconsejable **interceptar el tráfico de la aplicación** y verificar si se está enviando información sensible a servicios de terceros.

### Bases de Datos SQLite

La mayoría de las aplicaciones utilizarán **bases de datos SQLite internas** para guardar información. Durante el pentest, echa un **vistazo** a las **bases de datos** creadas, los nombres de las **tablas** y **columnas** y todos los **datos** guardados porque podrías encontrar **información sensible** (lo que sería una vulnerabilidad).\
Las bases de datos deberían estar ubicadas en `/data/data/the.package.name/databases` como `/data/data/com.mwr.example.sieve/databases`.

Si la base de datos está guardando información confidencial y está **encriptada** pero puedes **encontrar** la **contraseña** dentro de la aplicación, sigue siendo una **vulnerabilidad**.

Enumera las tablas usando `.tables` y enumera las columnas de las tablas haciendo `.schema <table_name>`.

### Drozer (Explotar Actividades, Proveedores de Contenido y Servicios)

Desde [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** te permite **asumir el rol de una aplicación Android** e interactuar con otras aplicaciones. Puede hacer **cualquier cosa que una aplicación instalada puede hacer**, como hacer uso del mecanismo de Comunicación entre Procesos (IPC) de Android e interactuar con el sistema operativo subyacente.\
Drozer es una herramienta útil para **explotar actividades exportadas, servicios exportados y Proveedores de Contenido** como aprenderás en las siguientes secciones.

### Explotando Actividades Exportadas

[**Lee esto si quieres refrescar qué es una Actividad de Android.**](android-applications-basics.md#launcher-activity-and-other-activities)\
También recuerda que el código de una actividad comienza en el método **`onCreate`**.

**Bypass de Autorización**

Cuando una Actividad es exportada, puedes invocar su pantalla desde una aplicación externa. Por lo tanto, si una actividad con **información sensible** está **exportada**, podrías **eludir** los mecanismos de **autenticación** **para acceder a ella.**

[**Aprende cómo explotar actividades exportadas con Drozer.**](drozer-tutorial/#activities)

También puedes iniciar una actividad exportada desde adb:

- PackageName es com.example.demo
- Exported ActivityName es com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTA**: MobSF detectará como malicioso el uso de _**singleTask/singleInstance**_ como `android:launchMode` en una actividad, pero debido a [esto](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), aparentemente esto solo es peligroso en versiones antiguas (versiones de API < 21).

> [!NOTA]
> Ten en cuenta que un bypass de autorización no siempre es una vulnerabilidad, dependería de cómo funcione el bypass y qué información esté expuesta.

**Filtración de información sensible**

**Las actividades también pueden devolver resultados**. Si logras encontrar una actividad exportada y desprotegida que llame al método **`setResult`** y **devuelva información sensible**, hay una filtración de información sensible.

#### Tapjacking

Si el tapjacking no se previene, podrías abusar de la actividad exportada para hacer que el **usuario realice acciones inesperadas**. Para más información sobre [**qué es Tapjacking sigue el enlace**](./#tapjacking).

### Explotando Content Providers - Accediendo y manipulando información sensible

[**Lee esto si quieres refrescar qué es un Content Provider.**](android-applications-basics.md#content-provider)\
Los content providers se utilizan básicamente para **compartir datos**. Si una aplicación tiene content providers disponibles, es posible que puedas **extraer datos sensibles** de ellos. También es interesante probar posibles **inyecciones SQL** y **Path Traversals** ya que podrían ser vulnerables.

[**Aprende cómo explotar Content Providers con Drozer.**](drozer-tutorial/#content-providers)

### **Explotando Servicios**

[**Lee esto si quieres refrescar qué es un Servicio.**](android-applications-basics.md#services)\
Recuerda que las acciones de un Servicio comienzan en el método `onStartCommand`.

Un servicio es básicamente algo que **puede recibir datos**, **procesarlos** y **devolver** (o no) una respuesta. Entonces, si una aplicación está exportando algunos servicios, deberías **verificar** el **código** para entender qué está haciendo y **probarlo** **dinámicamente** para extraer información confidencial, eludir medidas de autenticación...\
[**Aprende cómo explotar Servicios con Drozer.**](drozer-tutorial/#services)

### **Explotando Broadcast Receivers**

[**Lee esto si quieres refrescar qué es un Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Recuerda que las acciones de un Broadcast Receiver comienzan en el método `onReceive`.

Un broadcast receiver estará esperando un tipo de mensaje. Dependiendo de cómo el receptor maneje el mensaje, podría ser vulnerable.\
[**Aprende cómo explotar Broadcast Receivers con Drozer.**](./#exploiting-broadcast-receivers)

### **Explotando Schemes / Deep links**

Puedes buscar deep links manualmente, utilizando herramientas como MobSF o scripts como [este](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Puedes **abrir** un **scheme** declarado usando **adb** o un **navegador**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Tenga en cuenta que puede **omitir el nombre del paquete** y el móvil llamará automáticamente a la aplicación que debería abrir ese enlace._
```markup
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Código ejecutado**

Para encontrar el **código que se ejecutará en la App**, ve a la actividad llamada por el deeplink y busca la función **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Información sensible**

Cada vez que encuentres un deep link verifica que **no esté recibiendo datos sensibles (como contraseñas) a través de parámetros de URL**, porque cualquier otra aplicación podría **suplantar el deep link y robar esos datos!**

**Parámetros en la ruta**

Debes **verificar también si algún deep link está utilizando un parámetro dentro de la ruta** de la URL como: `https://api.example.com/v1/users/{username}`, en ese caso puedes forzar un recorrido de ruta accediendo a algo como: `example://app/users?username=../../unwanted-endpoint%3fparam=value`.\
Ten en cuenta que si encuentras los endpoints correctos dentro de la aplicación, podrías causar un **Open Redirect** (si parte de la ruta se usa como nombre de dominio), **toma de control de cuenta** (si puedes modificar los detalles de los usuarios sin un token CSRF y el endpoint vulnerable usó el método correcto) y cualquier otra vulnerabilidad. Más [info sobre esto aquí](http://dphoeniixx.com/2020/12/13-2/).

**Más ejemplos**

Un [informe de bug bounty interesante](https://hackerone.com/reports/855618) sobre enlaces (_/.well-known/assetlinks.json_).

### Inspección y Verificación de la Capa de Transporte

- **Los certificados no siempre son inspeccionados adecuadamente** por las aplicaciones de Android. Es común que estas aplicaciones pasen por alto advertencias y acepten certificados autofirmados o, en algunos casos, vuelvan a usar conexiones HTTP.
- **Las negociaciones durante el apretón de manos SSL/TLS a veces son débiles**, empleando suites de cifrado inseguras. Esta vulnerabilidad hace que la conexión sea susceptible a ataques de hombre en el medio (MITM), permitiendo a los atacantes descifrar los datos.
- **La filtración de información privada** es un riesgo cuando las aplicaciones se autentican utilizando canales seguros pero luego se comunican a través de canales no seguros para otras transacciones. Este enfoque no protege los datos sensibles, como cookies de sesión o detalles del usuario, de la interceptación por entidades maliciosas.

#### Verificación de Certificados

Nos centraremos en la **verificación de certificados**. La integridad del certificado del servidor debe ser verificada para mejorar la seguridad. Esto es crucial porque las configuraciones TLS inseguras y la transmisión de datos sensibles a través de canales no encriptados pueden representar riesgos significativos. Para pasos detallados sobre cómo verificar certificados de servidor y abordar vulnerabilidades, [**este recurso**](https://manifestsecurity.com/android-application-security-part-10/) proporciona una guía completa.

#### SSL Pinning

SSL Pinning es una medida de seguridad donde la aplicación verifica el certificado del servidor contra una copia conocida almacenada dentro de la propia aplicación. Este método es esencial para prevenir ataques MITM. Se recomienda encarecidamente implementar SSL Pinning para aplicaciones que manejan información sensible.

#### Inspección de Tráfico

Para inspeccionar el tráfico HTTP, es necesario **instalar el certificado de la herramienta proxy** (por ejemplo, Burp). Sin instalar este certificado, el tráfico encriptado podría no ser visible a través de la proxy. Para una guía sobre cómo instalar un certificado CA personalizado, [**haz clic aquí**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Las aplicaciones que apuntan a **API Level 24 y superiores** requieren modificaciones en la Configuración de Seguridad de Red para aceptar el certificado CA de la proxy. Este paso es crítico para inspeccionar tráfico encriptado. Para instrucciones sobre cómo modificar la Configuración de Seguridad de Red, [**consulta este tutorial**](make-apk-accept-ca-certificate.md).

#### Bypass de SSL Pinning

Cuando se implementa SSL Pinning, es necesario eludirlo para inspeccionar el tráfico HTTPS. Existen varios métodos disponibles para este propósito:

- Modificar automáticamente el **apk** para **eludir** SSLPinning con [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). La mejor ventaja de esta opción es que no necesitarás root para eludir el SSL Pinning, pero necesitarás eliminar la aplicación y reinstalar la nueva, y esto no siempre funcionará.
- Podrías usar **Frida** (discutido a continuación) para eludir esta protección. Aquí tienes una guía para usar Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- También puedes intentar **eludir automáticamente SSL Pinning** usando [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- También puedes intentar **eludir automáticamente SSL Pinning** usando **análisis dinámico de MobSF** (explicado a continuación)
- Si aún piensas que hay algún tráfico que no estás capturando, puedes intentar **redirigir el tráfico a burp usando iptables**. Lee este blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Búsqueda de Vulnerabilidades Web Comunes

Es importante también buscar vulnerabilidades web comunes dentro de la aplicación. La información detallada sobre cómo identificar y mitigar estas vulnerabilidades está más allá del alcance de este resumen, pero se cubre extensamente en otros lugares.

### Frida

[Frida](https://www.frida.re) es un kit de herramientas de instrumentación dinámica para desarrolladores, ingenieros de reversa e investigadores de seguridad.\
**Puedes acceder a la aplicación en ejecución y enganchar métodos en tiempo de ejecución para cambiar el comportamiento, cambiar valores, extraer valores, ejecutar diferentes códigos...**\
Si deseas hacer pentesting en aplicaciones Android, necesitas saber cómo usar Frida.

- Aprende a usar Frida: [**Tutorial de Frida**](frida-tutorial/)
- Algunas "GUI" para acciones con Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection es genial para automatizar el uso de Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Puedes encontrar algunos scripts de Frida geniales aquí: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Intenta eludir mecanismos de anti-debugging / anti-frida cargando Frida como se indica en [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (herramienta [linjector](https://github.com/erfur/linjector-rs))

### **Volcar Memoria - Fridump**

Verifica si la aplicación está almacenando información sensible en la memoria que no debería estar almacenando, como contraseñas o mnemotécnicas.

Usando [**Fridump3**](https://github.com/rootbsd/fridump3) puedes volcar la memoria de la app con:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Esto volcará la memoria en la carpeta ./dump, y allí podrías grep con algo como:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Datos sensibles en Keystore**

En Android, el Keystore es el mejor lugar para almacenar datos sensibles, sin embargo, con suficientes privilegios todavía es **posible acceder a él**. Dado que las aplicaciones tienden a almacenar aquí **datos sensibles en texto claro**, las pruebas de penetración deben verificarlo, ya que un usuario root o alguien con acceso físico al dispositivo podría ser capaz de robar estos datos.

Incluso si una aplicación almacena datos en el keystore, los datos deben estar cifrados.

Para acceder a los datos dentro del keystore, podrías usar este script de Frida: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Bypass de huellas dactilares/Biométricos**

Usando el siguiente script de Frida, podría ser posible **eludir la autenticación por huella dactilar** que las aplicaciones de Android podrían estar realizando para **proteger ciertas áreas sensibles:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Imágenes de Fondo**

Cuando pones una aplicación en segundo plano, Android almacena un **instantánea de la aplicación** para que cuando se recupere al primer plano, comience a cargar la imagen antes de la app, por lo que parece que la app se cargó más rápido.

Sin embargo, si esta instantánea contiene **información sensible**, alguien con acceso a la instantánea podría **robar esa información** (ten en cuenta que necesitas root para acceder a ella).

Las instantáneas suelen almacenarse en: **`/data/system_ce/0/snapshots`**

Android proporciona una forma de **prevenir la captura de pantalla configurando el parámetro de diseño FLAG_SECURE**. Al usar esta bandera, el contenido de la ventana se trata como seguro, impidiendo que aparezca en capturas de pantalla o que se vea en pantallas no seguras.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Analizador de Aplicaciones Android**

Esta herramienta puede ayudarte a gestionar diferentes herramientas durante el análisis dinámico: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Inyección de Intents

Los desarrolladores a menudo crean componentes proxy como actividades, servicios y receptores de difusión que manejan estos Intents y los pasan a métodos como `startActivity(...)` o `sendBroadcast(...)`, lo que puede ser arriesgado.

El peligro radica en permitir que los atacantes activen componentes de la aplicación no exportados o accedan a proveedores de contenido sensibles al desviar estos Intents. Un ejemplo notable es el componente `WebView` que convierte URLs en objetos `Intent` a través de `Intent.parseUri(...)` y luego los ejecuta, lo que puede llevar a inyecciones de Intent maliciosas.

### Conclusiones Esenciales

- **Inyección de Intents** es similar al problema de Redirección Abierta en la web.
- Los exploits implican pasar objetos `Intent` como extras, que pueden ser redirigidos para ejecutar operaciones inseguras.
- Puede exponer componentes no exportados y proveedores de contenido a los atacantes.
- La conversión de URL a `Intent` de `WebView` puede facilitar acciones no intencionadas.

### Inyecciones del Lado del Cliente en Android y otros

Probablemente conozcas este tipo de vulnerabilidades de la web. Debes tener especial cuidado con estas vulnerabilidades en una aplicación Android:

- **Inyección SQL:** Al tratar con consultas dinámicas o Content-Providers, asegúrate de usar consultas parametrizadas.
- **Inyección de JavaScript (XSS):** Verifica que el soporte de JavaScript y Plugins esté deshabilitado para cualquier WebView (deshabilitado por defecto). [Más información aquí](webview-attacks.md#javascript-enabled).
- **Inclusión de Archivos Locales:** Los WebViews deben tener el acceso al sistema de archivos deshabilitado (habilitado por defecto) - `(webview.getSettings().setAllowFileAccess(false);)`. [Más información aquí](webview-attacks.md#javascript-enabled).
- **Cookies Eternas**: En varios casos, cuando la aplicación android finaliza la sesión, la cookie no se revoca o incluso podría guardarse en el disco.
- [**Secure Flag** en cookies](../../pentesting-web/hacking-with-cookies/#cookies-flags)

---

<figure><img src="../../images/image (3).png" alt=""><figcaption></figcaption></figure>

¡Únete al servidor de [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) para comunicarte con hackers experimentados y cazadores de bugs!

**Perspectivas de Hacking**\
Participa en contenido que profundiza en la emoción y los desafíos del hacking.

**Noticias de Hackeo en Tiempo Real**\
Mantente al día con el mundo del hacking de ritmo rápido a través de noticias e información en tiempo real.

**Últimos Anuncios**\
Mantente informado sobre las nuevas recompensas por bugs que se lanzan y actualizaciones cruciales de la plataforma.

**Únete a nosotros en** [**Discord**](https://discord.com/invite/N3FrSbmwdy) y comienza a colaborar con los mejores hackers hoy mismo!

## Análisis Automático

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Análisis estático**

![](<../../images/image (866).png>)

**Evaluación de vulnerabilidades de la aplicación** utilizando un bonito frontend basado en la web. También puedes realizar análisis dinámico (pero necesitas preparar el entorno).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Tenga en cuenta que MobSF puede analizar **Android**(apk)**, IOS**(ipa) **y Windows**(apx) aplicaciones (_Las aplicaciones de Windows deben ser analizadas desde un MobSF instalado en un host de Windows_).\
Además, si crea un archivo **ZIP** con el código fuente de una aplicación **Android** o **IOS** (vaya a la carpeta raíz de la aplicación, seleccione todo y cree un archivo ZIP), también podrá analizarlo.

MobSF también le permite realizar análisis de **diff/Comparar** y integrar **VirusTotal** (necesitará configurar su clave API en _MobSF/settings.py_ y habilitarlo: `VT_ENABLED = TRUE` `VT_API_KEY = <Su clave API>` `VT_UPLOAD = TRUE`). También puede establecer `VT_UPLOAD` en `False`, entonces el **hash** se **subirá** en lugar del archivo.

### Análisis dinámico asistido con MobSF

**MobSF** también puede ser muy útil para el **análisis dinámico** en **Android**, pero en ese caso necesitará instalar MobSF y **genymotion** en su host (una VM o Docker no funcionará). _Nota: Necesita **iniciar primero una VM en genymotion** y **luego MobSF.**_\
El **analizador dinámico de MobSF** puede:

- **Volcar datos de la aplicación** (URLs, registros, portapapeles, capturas de pantalla realizadas por usted, capturas de pantalla realizadas por "**Exported Activity Tester**", correos electrónicos, bases de datos SQLite, archivos XML y otros archivos creados). Todo esto se hace automáticamente excepto por las capturas de pantalla, necesita presionar cuando quiera una captura de pantalla o necesita presionar "**Exported Activity Tester**" para obtener capturas de pantalla de todas las actividades exportadas.
- Capturar **tráfico HTTPS**
- Usar **Frida** para obtener **información** **en tiempo de ejecución**

Desde las versiones de Android **> 5**, **iniciará automáticamente Frida** y establecerá configuraciones de **proxy** globales para **capturar** tráfico. Solo capturará tráfico de la aplicación probada.

**Frida**

Por defecto, también utilizará algunos scripts de Frida para **eludir la fijación de SSL**, **detección de root** y **detección de depuradores** y para **monitorear APIs interesantes**.\
MobSF también puede **invocar actividades exportadas**, tomar **capturas de pantalla** de ellas y **guardarlas** para el informe.

Para **iniciar** la prueba dinámica presione el botón verde: "**Start Instrumentation**". Presione "**Frida Live Logs**" para ver los registros generados por los scripts de Frida y "**Live API Monitor**" para ver todas las invocaciones a métodos enganchados, argumentos pasados y valores devueltos (esto aparecerá después de presionar "Start Instrumentation").\
MobSF también le permite cargar sus propios **scripts de Frida** (para enviar los resultados de sus scripts de Frida a MobSF use la función `send()`). También tiene **varios scripts preescritos** que puede cargar (puede agregar más en `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), solo **selecciónelos**, presione "**Load**" y presione "**Start Instrumentation**" (podrá ver los registros de esos scripts dentro de "**Frida Live Logs**").

![](<../../images/image (419).png>)

Además, tiene algunas funcionalidades auxiliares de Frida:

- **Enumerar Clases Cargadas**: Imprimirá todas las clases cargadas
- **Capturar Cadenas**: Imprimirá todas las cadenas capturadas mientras usa la aplicación (muy ruidoso)
- **Capturar Comparaciones de Cadenas**: Podría ser muy útil. **Mostrará las 2 cadenas que se están comparando** y si el resultado fue Verdadero o Falso.
- **Enumerar Métodos de Clase**: Ponga el nombre de la clase (como "java.io.File") e imprimirá todos los métodos de la clase.
- **Buscar Patrón de Clase**: Buscar clases por patrón
- **Rastrear Métodos de Clase**: **Rastrear** una **clase completa** (ver entradas y salidas de todos los métodos de la clase). Recuerde que por defecto MobSF rastrea varios métodos interesantes de la API de Android.

Una vez que haya seleccionado el módulo auxiliar que desea usar, necesita presionar "**Start Intrumentation**" y verá todas las salidas en "**Frida Live Logs**".

**Shell**

Mobsf también le ofrece una shell con algunos comandos **adb**, **comandos de MobSF**, y comandos comunes de **shell** en la parte inferior de la página de análisis dinámico. Algunos comandos interesantes:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**Herramientas HTTP**

Cuando se captura tráfico http, puedes ver una vista fea del tráfico capturado en "**HTTP(S) Traffic**" en la parte inferior o una vista más agradable en el botón verde "**Start HTTPTools**". Desde la segunda opción, puedes **enviar** las **solicitudes capturadas** a **proxies** como Burp o Owasp ZAP.\
Para hacerlo, _enciende Burp -->_ _apaga Intercept --> en MobSB HTTPTools selecciona la solicitud_ --> presiona "**Send to Fuzzer**" --> _selecciona la dirección del proxy_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Una vez que termines el análisis dinámico con MobSF, puedes presionar en "**Start Web API Fuzzer**" para **fuzz http requests** y buscar vulnerabilidades.

> [!NOTE]
> Después de realizar un análisis dinámico con MobSF, la configuración del proxy puede estar mal configurada y no podrás solucionarlo desde la GUI. Puedes corregir la configuración del proxy haciendo:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Análisis Dinámico Asistido con Inspeckage

Puedes obtener la herramienta de [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Esta herramienta utilizará algunos **Hooks** para informarte **qué está sucediendo en la aplicación** mientras realizas un **análisis dinámico**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Esta es una **gran herramienta para realizar análisis estático con una GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Esta herramienta está diseñada para buscar varias **vulnerabilidades relacionadas con la seguridad en aplicaciones Android**, ya sea en **código fuente** o **APKs empaquetados**. La herramienta también es **capaz de crear un "Proof-of-Concept" APK desplegable** y **comandos ADB**, para explotar algunas de las vulnerabilidades encontradas (Actividades expuestas, intents, tapjacking...). Al igual que con Drozer, no es necesario rootear el dispositivo de prueba.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Muestra todos los archivos extraídos para una fácil referencia
- Descompone automáticamente archivos APK a formato Java y Smali
- Analiza AndroidManifest.xml en busca de vulnerabilidades y comportamientos comunes
- Análisis estático del código fuente para vulnerabilidades y comportamientos comunes
- Información del dispositivo
- y más
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER es una aplicación de línea de comandos que se puede utilizar en Windows, MacOS X y Linux, que analiza archivos _.apk_ en busca de vulnerabilidades. Lo hace descomprimiendo APKs y aplicando una serie de reglas para detectar esas vulnerabilidades.

Todas las reglas están centradas en un archivo `rules.json`, y cada empresa o probador podría crear sus propias reglas para analizar lo que necesiten.

Descargue los últimos binarios en la [página de descarga](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn es una herramienta **multiplataforma** que ayuda a desarrolladores, cazadores de bugs y hackers éticos a realizar [análisis de código estático](https://en.wikipedia.org/wiki/Static_program_analysis) en aplicaciones móviles.

El concepto es que arrastras y sueltas tu archivo de aplicación móvil (un archivo .apk o .ipa) en la aplicación StaCoAn y generará un informe visual y portátil para ti. Puedes ajustar la configuración y las listas de palabras para obtener una experiencia personalizada.

Descargar [última versión](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework es un sistema de análisis de vulnerabilidades de Android que ayuda a los desarrolladores o hackers a encontrar posibles vulnerabilidades de seguridad en aplicaciones de Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** es una herramienta cuyo objetivo principal es detectar y advertir al usuario sobre comportamientos maliciosos potenciales desarrollados por una aplicación de Android.

La detección se realiza con el **análisis estático** del bytecode Dalvik de la aplicación, representado como **Smali**, con la biblioteca [`androguard`](https://github.com/androguard/androguard).

Esta herramienta busca **comportamientos comunes de aplicaciones "malas"** como: exfiltración de identificadores de telefonía, interceptación de flujos de audio/video, modificación de datos PIM, ejecución de código arbitrario...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** es un **M**obile **A**pplication **R**everse engineering y **A**nalysis Framework. Es una herramienta que reúne herramientas comúnmente utilizadas para la ingeniería inversa y análisis de aplicaciones móviles, para ayudar en la prueba de aplicaciones móviles contra las amenazas de seguridad móvil de OWASP. Su objetivo es facilitar esta tarea y hacerla más amigable para los desarrolladores de aplicaciones móviles y profesionales de seguridad.

Es capaz de:

- Extraer código Java y Smali utilizando diferentes herramientas
- Analizar APKs usando: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Extraer información privada del APK usando expresiones regulares.
- Analizar el Manifest.
- Analizar dominios encontrados usando: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) y [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Desofuscar APK a través de [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Útil para detectar malware: [https://koodous.com/](https://koodous.com)

## Ofuscando/Desofuscando código

Tenga en cuenta que dependiendo del servicio y la configuración que utilice para ofuscar el código. Los secretos pueden o no terminar ofuscados.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

De [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** es una herramienta de línea de comandos de código abierto que reduce, optimiza y ofusca código Java. Es capaz de optimizar bytecode así como detectar y eliminar instrucciones no utilizadas. ProGuard es software libre y se distribuye bajo la Licencia Pública General de GNU, versión 2.

ProGuard se distribuye como parte del SDK de Android y se ejecuta al construir la aplicación en modo de lanzamiento.

### [DexGuard](https://www.guardsquare.com/dexguard)

Encuentra una guía paso a paso para desofuscar el apk en [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(De esa guía) La última vez que verificamos, el modo de operación de Dexguard era:

- cargar un recurso como un InputStream;
- alimentar el resultado a una clase que hereda de FilterInputStream para descifrarlo;
- hacer alguna ofuscación inútil para perder unos minutos de tiempo de un reversor;
- alimentar el resultado descifrado a un ZipInputStream para obtener un archivo DEX;
- finalmente cargar el DEX resultante como un Recurso usando el método `loadDex`.

### [DeGuard](http://apk-deguard.com)

**DeGuard revierte el proceso de ofuscación realizado por herramientas de ofuscación de Android. Esto permite numerosos análisis de seguridad, incluyendo inspección de código y predicción de bibliotecas.**

Puedes subir un APK ofuscado a su plataforma.

### [Simplify](https://github.com/CalebFenton/simplify)

Es un **desofuscador genérico de android.** Simplify **ejecuta virtualmente una aplicación** para entender su comportamiento y luego **intenta optimizar el código** para que se comporte de manera idéntica pero sea más fácil de entender para un humano. Cada tipo de optimización es simple y genérico, por lo que no importa qué tipo específico de ofuscación se utilice.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD te da información sobre **cómo se hizo un APK**. Identifica muchos **compiladores**, **empaquetadores**, **ofuscadores** y otras cosas extrañas. Es [_PEiD_](https://www.aldeid.com/wiki/PEiD) para Android.

### Manual

[Lee este tutorial para aprender algunos trucos sobre **cómo revertir la ofuscación personalizada**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b es una máquina virtual de seguridad de Android basada en ubuntu-mate que incluye la colección de los últimos frameworks, tutoriales y laboratorios de diferentes expertos en seguridad e investigadores para ingeniería inversa y análisis de malware.

## Referencias

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Es una gran lista de recursos
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Curso rápido de Android
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)

## Aún por probar

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

<figure><img src="../../images/image (3).png" alt=""><figcaption></figcaption></figure>

Únete al servidor de [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) para comunicarte con hackers experimentados y cazadores de recompensas de errores.

**Perspectivas de Hacking**\
Participa en contenido que profundiza en la emoción y los desafíos del hacking

**Noticias de Hackeo en Tiempo Real**\
Mantente al día con el mundo del hacking de ritmo rápido a través de noticias e información en tiempo real

**Últimos Anuncios**\
Mantente informado sobre las nuevas recompensas por errores que se lanzan y actualizaciones cruciales de la plataforma

**Únete a nosotros en** [**Discord**](https://discord.com/invite/N3FrSbmwdy) y comienza a colaborar con los mejores hackers hoy mismo!

{{#include ../../banners/hacktricks-training.md}}
