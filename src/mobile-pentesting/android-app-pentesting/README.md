# Pentesting aplikacji Android

{{#include ../../banners/hacktricks-training.md}}

## Podstawy aplikacji Android

Zaleca się rozpocząć od przeczytania tej strony, aby poznać **najważniejsze części związane z bezpieczeństwem Androida oraz najniebezpieczniejsze komponenty w aplikacji Android**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

To główne narzędzie, którego potrzebujesz, aby połączyć się z urządzeniem Android (emulowanym lub fizycznym).\
**ADB** pozwala na kontrolowanie urządzeń zarówno przez **USB**, jak i **Network** z komputera. To narzędzie umożliwia **kopiowanie** plików w obu kierunkach, **instalację** i **odinstalowanie** aplikacji, **wykonywanie** poleceń shell, **tworzenie kopii zapasowych** danych, **odczytywanie** logów, oraz inne funkcje.

Zobacz następującą listę [**ADB Commands**](adb-commands.md), aby dowiedzieć się, jak używać adb.

## Smali

Czasami warto **zmodyfikować kod aplikacji**, aby uzyskać dostęp do **ukrytych informacji** (np. dobrze obfuskowanych haseł lub flag). Wtedy może być interesujące zdekompilować apk, zmodyfikować kod i skompilować go ponownie.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Może to być bardzo przydatne jako **alternatywa dla kilku testów podczas dynamicznej analizy**, które będą przedstawione. Zawsze **miej na uwadze tę możliwość**.

## Other interesting tricks

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Play Integrity attestation spoofing (SafetyNet replacement)](play-integrity-attestation-bypass.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [Android IME / InputMethodService Abuse (Malicious Keyboards)](inputmethodservice-ime-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Wyodrębnij APK z urządzenia:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Scal wszystkie splits i base apks za pomocą [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Android Enterprise i ataki na Work Profile

{{#ref}}
android-enterprise-work-profile-bypass.md
{{#endref}}

## Studia przypadków i podatności


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

{{#ref}}
abusing-android-media-pipelines-image-parsers.md
{{#endref}}

{{#ref}}
../../binary-exploitation/linux-kernel-exploitation/arm64-static-linear-map-kaslr-bypass.md
{{#endref}}

## Analiza statyczna

Przede wszystkim, analizując APK powinieneś **rzucić okiem na kod Java** używając dekompilera.\
Proszę, [**przeczytaj tutaj, aby znaleźć informacje o różnych dostępnych dekompilatorach**](apk-decompilers.md).

### Szukanie interesujących informacji

Wystarczy spojrzeć na **strings** APK, aby wyszukać **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** i wszystko, co może być interesujące... sprawdź nawet pod kątem code execution **backdoors** lub authentication backdoors (hardcoded admin credentials w aplikacji).

**Firebase**

Zwróć szczególną uwagę na **firebase URLs** i sprawdź, czy nie jest źle skonfigurowany. [Więcej informacji o tym, czym jest Firebase i jak go eksploatować tutaj.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Podstawowe zrozumienie aplikacji - Manifest.xml, strings.xml

**Analiza plików _Manifest.xml_ i _strings.xml_ aplikacji może ujawnić potencjalne luki bezpieczeństwa.** Do tych plików można uzyskać dostęp za pomocą dekompilatorów lub poprzez zmianę rozszerzenia APK na .zip i rozpakowanie archiwum.

Wśród **podatności** możliwych do wykrycia w **Manifest.xml** znajdują się:

- **Debuggable Applications**: Aplikacje ustawione jako debuggable (`debuggable="true"`) w pliku _Manifest.xml_ stanowią ryzyko, ponieważ pozwalają na połączenia mogące prowadzić do eksploatacji. Aby lepiej zrozumieć, jak eksploatować debuggable applications, odwołaj się do poradnika o znajdowaniu i wykorzystywaniu debuggable applications na urządzeniu.
- **Backup Settings**: Atrybut `android:allowBackup="false"` powinien być jawnie ustawiony dla aplikacji przetwarzających wrażliwe informacje, aby zapobiec nieautoryzowanym backupom danych przez adb, zwłaszcza gdy usb debugging jest włączony.
- **Network Security**: Niestandardowe konfiguracje network security (`android:networkSecurityConfig="@xml/network_security_config"`) w _res/xml/_ mogą określać szczegóły bezpieczeństwa, takie jak certificate pins i ustawienia ruchu HTTP. Przykładem jest zezwolenie na HTTP dla konkretnych domen.
- **Exported Activities and Services**: Identyfikacja exported activities i services w manifeście może wskazać komponenty, które mogą być nadużyte. Dalsza analiza podczas testów dynamicznych może ujawnić sposoby wykorzystania tych komponentów.
- **Content Providers and FileProviders**: Udostępnione content providers mogą umożliwić nieautoryzowany dostęp lub modyfikację danych. Należy również dokładnie przejrzeć konfigurację FileProviders.
- **Broadcast Receivers and URL Schemes**: Te komponenty mogą być wykorzystane do eksploatacji, ze szczególnym naciskiem na sposób obsługi URL schemes pod kątem podatności na wejście.
- **SDK Versions**: Atrybuty `minSdkVersion`, `targetSDKVersion` i `maxSdkVersion` wskazują obsługiwane wersje Androida, co podkreśla wagę nieobsługiwania przestarzałych, podatnych wersji Androida z punktu widzenia bezpieczeństwa.

Z pliku **strings.xml** można odkryć wrażliwe informacje, takie jak API keys, custom schemas i inne uwagi developerów, co podkreśla konieczność dokładnego przeglądu tych zasobów.

### Tapjacking

**Tapjacking** to atak, w którym **złośliwa** **aplikacja** jest uruchamiana i **ustawia się nad aplikacją ofiary**. Gdy wizualnie zasłania aplikację ofiary, jej interfejs jest zaprojektowany tak, aby nakłonić użytkownika do interakcji, jednocześnie przekazując te interakcje do aplikacji ofiary.\
W efekcie **oślepia użytkownika, który nie wie, że tak naprawdę wykonuje akcje w aplikacji ofiary**.

Znajdź więcej informacji w:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Activity z ustawionym **`launchMode`** na **`singleTask` bez zdefiniowanego `taskAffinity`** jest podatna na task Hijacking. Oznacza to, że **aplikacja** może zostać zainstalowana i jeśli zostanie uruchomiona przed prawdziwą aplikacją, może **przejąć task prawdziwej aplikacji** (tak że użytkownik będzie wchodził w interakcję z **złośliwą aplikacją, myśląc, że używa prawdziwej**).

Więcej informacji w:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Niezabezpieczone przechowywanie danych

Internal Storage

W Androidzie pliki **przechowywane** w **wewnętrznej** pamięci są **zaprojektowane** tak, aby były **dostępne** wyłącznie dla **aplikacji**, która je **utworzyła**. Ten mechanizm bezpieczeństwa jest **egzekwowany** przez system Android i zazwyczaj wystarcza dla potrzeb większości aplikacji. Jednak deweloperzy czasami używają trybów takich jak `MODE_WORLD_READABLE` i `MODE_WORLD_WRITABLE`, aby **pozwolić** na **udostępnianie** plików między różnymi aplikacjami. Te tryby **nie ograniczają jednak dostępu** do tych plików przez inne aplikacje, w tym potencjalnie złośliwe.

1. **Analiza statyczna:**
- **Upewnij się**, że użycie `MODE_WORLD_READABLE` i `MODE_WORLD_WRITABLE` jest **dokładnie sprawdzone**. Te tryby **mogą potencjalnie ujawnić** pliki dla **niezamierzonego lub nieautoryzowanego dostępu**.
2. **Analiza dynamiczna:**
- **Zweryfikuj** uprawnienia ustawione na plikach tworzonych przez aplikację. Konkretnie, **sprawdź**, czy jakiekolwiek pliki nie są **ustawione jako czytelne lub zapisywalne dla całego świata**. Może to stanowić poważne ryzyko bezpieczeństwa, ponieważ pozwoli **dowolnej aplikacji** zainstalowanej na urządzeniu, niezależnie od jej pochodzenia czy zamiaru, **odczytać lub zmodyfikować** te pliki.

External Storage

W przypadku plików na **external storage**, takich jak SD Card, należy zachować ostrożność:

1. **Dostępność**:
- Pliki na external storage są **globalnie czytelne i zapisywalne**. Oznacza to, że każda aplikacja lub użytkownik może uzyskać do nich dostęp.
2. **Obawy o bezpieczeństwo**:
- Ze względu na łatwy dostęp, nie zaleca się **przechowywania informacji wrażliwych** na external storage.
- External storage można usunąć lub uzyskać do niego dostęp przez dowolną aplikację, co czyni go mniej bezpiecznym.
3. **Obsługa danych z external storage**:
- Zawsze **przeprowadzaj walidację wejścia** na danych pobieranych z external storage. Jest to kluczowe, ponieważ dane pochodzą z nieufnego źródła.
- Przechowywanie plików wykonywalnych lub plików klas na external storage w celu dynamicznego ładowania jest zdecydowanie odradzane.
- Jeśli Twoja aplikacja musi pobierać pliki wykonywalne z external storage, upewnij się, że pliki te są **podpisane i kryptograficznie zweryfikowane** przed ich dynamicznym załadowaniem. Ten krok jest niezbędny do zachowania integralności bezpieczeństwa aplikacji.

External storage można **uzyskać** w /storage/emulated/0 , /sdcard , /mnt/sdcard

> [!TIP]
> Począwszy od Android 4.4 (**API 17**), SD card ma strukturę katalogów, która **ogranicza dostęp aplikacji do katalogu przeznaczonego konkretnie dla tej aplikacji**. Zapobiega to uzyskaniu przez złośliwą aplikację dostępu do odczytu lub zapisu plików innej aplikacji.

**Poufne dane przechowywane w postaci jawnej**

- **Shared preferences**: Android pozwala każdej aplikacji łatwo zapisywać pliki xml w ścieżce /data/data/<packagename>/shared_prefs/ i czasami można znaleźć wrażliwe informacje w postaci jawnej w tym folderze.
- **Databases**: Android pozwala każdej aplikacji łatwo zapisywać bazy sqlite w ścieżce /data/data/<packagename>/databases/ i czasami można znaleźć wrażliwe informacje w postaci jawnej w tym folderze.

### Broken TLS

**Akceptowanie wszystkich certyfikatów**

Z jakiegoś powodu czasami deweloperzy akceptują wszystkie certyfikaty nawet jeśli na przykład hostname nie pasuje, z użyciem linii kodu podobnych do poniższych:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Błędy kryptografii

**Słabe procesy zarządzania kluczami**

Niektórzy deweloperzy zapisują dane wrażliwe w local storage i szyfrują je kluczem zakodowanym na stałe/przewidywalnym w kodzie. Nie powinno się tego robić, ponieważ inżynieria wsteczna może pozwolić atakującemu na wydobycie poufnych informacji.

**Użycie niebezpiecznych i/lub przestarzałych algorytmów**

Deweloperzy nie powinni używać **deprecated algorithms** do wykonywania kontroli **authorisation checks**, **store** lub **send** data. Niektóre z tych algorytmów to: RC4, MD4, MD5, SHA1... Jeśli **hashes** są używane do przechowywania haseł na przykład, powinny być użyte algorytmy odporne na brute-force z salt.

### Inne kontrole

- Zaleca się **obfuskować APK**, aby utrudnić pracę reverse engineerom.
- Jeśli aplikacja jest wrażliwa (np. aplikacje bankowe), powinna wykonywać własne **sprawdzenia czy urządzenie jest rooted** i działać zgodnie z wynikiem.
- Jeśli aplikacja jest wrażliwa (np. aplikacje bankowe), powinna sprawdzać czy używany jest **emulator**.
- Jeśli aplikacja jest wrażliwa (np. aplikacje bankowe), powinna **sprawdzić swoją integralność przed wykonaniem**, aby upewnić się, że nie została zmodyfikowana.
- Użyj [**APKiD**](https://github.com/rednaga/APKiD) aby sprawdzić, który compiler/packer/obfuscator został użyty do zbudowania APK

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

The tool [**mariana-trench**](https://github.com/facebook/mariana-trench) is capable of finding **vulnerabilities** by **scanning** the **code** of the application. This tool contains a series of **known sources** (that indicates to the tool the **places** where the **input** is **controlled by the user**), **sinks** (which indicates to the tool **dangerous** **places** where malicious user input could cause damages) and **rules**. These rules indicates the **combination** of **sources-sinks** that indicates a vulnerability.

With this knowledge, **mariana-trench will review the code and find possible vulnerabilities on it**.

### Secrets leaked

An application may contain secrets (API keys, passwords, hidden urls, subdomains...) inside of it that you might be able to discover. You could us a tool such as [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)
- In-memory native code execution via JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Analiza dynamiczna

> Po pierwsze, potrzebujesz środowiska, w którym możesz zainstalować aplikację i całe otoczenie (Burp CA cert, Drozer i Frida głównie). Dlatego zalecane jest użycie rooted urządzenia (emulowanego lub nie).

### Analiza dynamiczna online

Możesz utworzyć **darmowe konto** na: [https://appetize.io/](https://appetize.io). Ta platforma pozwala **upload** i **execute** APK, więc jest przydatna, aby zobaczyć jak apk się zachowuje.

Możesz nawet **see the logs of your application** w web i połączyć się przez **adb**.

![](<../../images/image (831).png>)

Dzięki połączeniu ADB możesz używać **Drozer** i **Frida** wewnątrz emulatorów.

### Analiza dynamiczna lokalnie

#### Używanie emulatora

- [**Android Studio**](https://developer.android.com/studio) (Możesz tworzyć urządzenia **x86** i **arm**, a zgodnie z [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** versions **support ARM libraries** without needing an slow arm emulator).
- Naucz się go skonfigurować na tej stronie:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, musisz utworzyć konto. _Zaleca się **pobrać** wersję **WITH**_ _**VirtualBox** aby uniknąć potencjalnych błędów._)
- [**Nox**](https://es.bignox.com) (Darmowy, ale nie wspiera Frida ani Drozer).

> [!TIP]
> Tworząc nowy emulator na dowolnej platformie pamiętaj, że im większy ekran, tym wolniej będzie działać emulator. Wybieraj więc małe ekrany jeśli to możliwe.

Aby **zainstalować google services** (jak AppStore) w Genymotion musisz kliknąć czerwony oznaczony przycisk na poniższym obrazie:

![](<../../images/image (277).png>)

Zauważ także, że w **konfiguracji Android VM w Genymotion** możesz wybrać **Bridge Network mode** (to będzie przydatne jeśli łączysz się z Android VM z innej VM z narzędziami).

#### Użyj urządzenia fizycznego

Musisz aktywować opcje **debugging** i dobrze by było, gdybyś mógł je **root**:

1. **Settings**.
2. (FromAndroid 8.0) Wybierz **System**.
3. Wybierz **About phone**.
4. Naciśnij **Build number** 7 razy.
5. Wróć i znajdziesz **Developer options**.

> Po zainstalowaniu aplikacji, pierwszą rzeczą jaką powinieneś zrobić jest jej uruchomienie i zbadanie co robi, jak działa i oswojenie się z nią.\
> Sugeruję wykonanie tej wstępnej analizy dynamicznej używając MobSF dynamic analysis + pidcat, dzięki czemu będziemy mogli **learn how the application works** podczas gdy MobSF **captures** wiele **interesting** **data**, które możesz przejrzeć później.

Magisk/Zygisk szybkie notatki (zalecane na urządzeniach Pixel)
- Patch boot.img with the Magisk app and flash via fastboot to get systemless root
- Enable Zygisk + DenyList for root hiding; consider LSPosed/Shamiko when stronger hiding is required
- Keep original boot.img to recover from OTA updates; re-patch after each OTA
- For screen mirroring, use scrcpy on the host



### Niezamierzone wycieki danych

**Logging**

Deweloperzy powinni uważać, aby nie ujawniać **debugging information** publicznie, ponieważ może to prowadzić do wycieku danych wrażliwych. Narzędzia [**pidcat**](https://github.com/JakeWharton/pidcat) i `adb logcat` są rekomendowane do monitorowania logów aplikacji, aby zidentyfikować i chronić wrażliwe informacje. **Pidcat** jest preferowany ze względu na łatwość użycia i czytelność.

> [!WARNING]
> Zauważ, że od **późniejszych wersji niż Android 4.0**, **aplikacje mogą uzyskiwać dostęp tylko do własnych logów**. Więc aplikacje nie mogą uzyskać dostępu do logów innych aplikacji.\
> Mimo to, nadal zaleca się **nie logować informacji wrażliwych**.

**Kopiowanie/Wklejanie — bufor schowka**

Androidowy framework oparty na **clipboard** umożliwia funkcję kopiuj-wklej w aplikacjach, jednak stwarza ryzyko, ponieważ **inne aplikacje** mogą **dostępować** do schowka, potencjalnie ujawniając dane wrażliwe. Ważne jest wyłączenie funkcji copy/paste dla wrażliwych sekcji aplikacji, takich jak dane karty kredytowej, aby zapobiec wyciekowi danych.

**Crash Logs**

Jeśli aplikacja **crashuje** i **zapisuje logi**, te logi mogą pomóc atakującym, szczególnie gdy aplikacji nie da się odwrócić poprzez reverse-engineering. Aby złagodzić to ryzyko, unikaj logowania podczas crashów, a jeśli logi muszą być przesyłane przez sieć, upewnij się, że są wysyłane przez kanał SSL.

Jako pentester, **try to take a look to these logs**.

**Dane analityczne wysyłane do 3rd parties**

Aplikacje często integrują usługi takie jak Google Adsense, które mogą nieumyślnie **leak sensitive data** z powodu niewłaściwej implementacji przez deweloperów. Aby zidentyfikować potencjalny wyciek danych, warto **intercept the application's traffic** i sprawdzić, czy jakieś wrażliwe informacje są wysyłane do serwisów zewnętrznych.

### SQLite DBs

Większość aplikacji używa **internal SQLite databases** do zapisywania informacji. Podczas pentestu sprawdź **databases** utworzone, nazwy **tables** i **columns** oraz wszystkie zapisane **data**, ponieważ możesz znaleźć **sensitive information** (co byłoby luką).\
Bazy danych powinny być zlokalizowane w `/data/data/the.package.name/databases` na przykład `/data/data/com.mwr.example.sieve/databases`

Jeśli baza danych zapisuje poufne informacje i jest **encrypted b**ut możesz **find** the **password** inside the application to nadal jest to **vulnerability**.

Wymień tabele używając `.tables` i wypisz schematy tabel przy pomocy `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer is s useful tool to **exploit exported activities, exported services and Content Providers** as you will learn in the following sections.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Also remember that the code of an activity starts in the **`onCreate`** method.

**Authorisation bypass**

When an Activity is exported you can invoke its screen from an external app. Therefore, if an activity with **sensitive information** is **exported** you could **bypass** the **authentication** mechanisms **to access it.**

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

You can also start an exported activity from adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**UWAGA**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> Zwróć uwagę, że authorisation bypass nie zawsze jest podatnością — zależy to od sposobu działania bypass i tego, jakie informacje są ujawniane.

**Ujawnianie informacji wrażliwych**

**Activities can also return results**. Jeśli uda Ci się znaleźć eksportowaną i niezabezpieczoną activity, która wywołuje metodę **`setResult`** i **zwraca informacje wrażliwe**, dochodzi do ujawnienia informacji wrażliwych.

#### Tapjacking

Jeśli tapjacking nie jest zapobiegany, możesz wykorzystać eksportowaną activity, by sprawić, że **użytkownik wykona nieoczekiwane działania**. Więcej informacji o [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Przeczytaj to, jeśli chcesz odświeżyć, czym jest Content Provider.**](android-applications-basics.md#content-provider)\
Content providers są zasadniczo używane do **share data**. Jeśli aplikacja udostępnia content providers, możesz być w stanie **extract sensitive** dane z nich. Warto też przetestować możliwe **SQL injections** i **Path Traversals**, ponieważ mogą być podatne.

[**Dowiedz się, jak wykorzystać Content Providers za pomocą Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Przeczytaj to, jeśli chcesz odświeżyć, czym jest Service.**](android-applications-basics.md#services)\
Pamiętaj, że działania Service rozpoczynają się w metodzie `onStartCommand`.

Service to zasadniczo coś, co **może otrzymywać dane**, **przetwarzać** je i **zwracać** (lub nie) odpowiedź. Dlatego jeśli aplikacja eksportuje jakieś services, powinieneś **sprawdzić** **kod**, żeby zrozumieć, co robi, i **przetestować** go **dynamicznie**, aby wydobyć poufne informacje, obejść mechanizmy uwierzytelniania itd.\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Przeczytaj to, jeśli chcesz odświeżyć, czym jest Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Pamiętaj, że działania Broadcast Receiver rozpoczynają się w metodzie `onReceive`.

Broadcast receiver będzie oczekiwał na określony typ wiadomości. W zależności od tego, jak receiver obsługuje wiadomość, może być podatny.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

You can look for deep links manually, using tools like MobSF or scripts like [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
You can **open** a declared **scheme** using **adb** or a **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Zauważ, że możesz **pominąć nazwę pakietu**, a urządzenie mobilne automatycznie wywoła aplikację, która powinna otworzyć ten link._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Kod wykonywany**

Aby znaleźć **kod, który zostanie wykonany w aplikacji**, przejdź do activity wywoływanej przez deeplink i wyszukaj funkcję **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Wrażliwe informacje**

Za każdym razem, gdy znajdziesz deep link, sprawdź, czy **nie otrzymuje danych wrażliwych (np. haseł) przez parametry URL**, ponieważ każda inna aplikacja mogłaby **podszyć się pod ten deep link i ukraść te dane!**

**Parametry w ścieżce**

Musisz także sprawdzić, czy którykolwiek deep link używa parametru w części ścieżki URL, np.: `https://api.example.com/v1/users/{username}` — w takim przypadku możesz wymusić path traversal uzyskując dostęp do czegoś takiego: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Zauważ, że jeśli znajdziesz odpowiednie endpointy w aplikacji, możesz wywołać **Open Redirect** (jeśli część ścieżki używana jest jako nazwa domeny), **account takeover** (jeśli możesz modyfikować dane użytkowników bez tokena CSRF i podatny endpoint używał odpowiedniej metody) i inne podatności. Więcej [informacji o tym tutaj](http://dphoeniixx.com/2020/12/13-2/).

**Więcej przykładów**

Ciekawy [bug bounty report](https://hackerone.com/reports/855618) o linkach (_/.well-known/assetlinks.json_).

### Inspekcja warstwy transportowej i błędy weryfikacji

- **Certyfikaty nie zawsze są prawidłowo weryfikowane** przez aplikacje Android. Często aplikacje ignorują ostrzeżenia i akceptują self-signed certificates lub, w niektórych przypadkach, wracają do używania połączeń HTTP.
- **Negocjacje podczas ręki SSL/TLS są czasami słabe**, używając niesecure cipher suites. Ta podatność sprawia, że połączenie jest podatne na ataki man-in-the-middle (MITM), pozwalając atakującemu odszyfrować dane.
- Ujawnianie prywatnych informacji jest ryzykiem, gdy aplikacje uwierzytelniają się przy użyciu bezpiecznych kanałów, a następnie komunikują się po kanałach niezaszyfrowanych dla innych transakcji. Takie podejście nie chroni danych wrażliwych, takich jak session cookies czy dane użytkowników, przed przechwyceniem przez złośliwe podmioty.

#### Weryfikacja certyfikatu

Skoncentrujemy się na **weryfikacji certyfikatu**. Należy weryfikować integralność certyfikatu serwera, aby zwiększyć bezpieczeństwo. Jest to kluczowe, ponieważ niebezpieczne konfiguracje TLS i przesyłanie danych wrażliwych przez kanały niezabezpieczone mogą stwarzać poważne ryzyko. Dla szczegółowych kroków dotyczących weryfikacji certyfikatów serwera i usuwania podatności, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) zawiera wyczerpujące wskazówki.

#### SSL Pinning

SSL Pinning to środek bezpieczeństwa, w którym aplikacja weryfikuje certyfikat serwera względem znanej kopii przechowywanej wewnątrz aplikacji. Ta metoda jest istotna w zapobieganiu atakom MITM. Implementacja SSL Pinning jest wysoce zalecana dla aplikacji przetwarzających dane wrażliwe.

#### Inspekcja ruchu

Aby inspect HTTP traffic, konieczne jest **zainstalowanie certyfikatu narzędzia proxy** (np. Burp). Bez zainstalowania tego certyfikatu zaszyfrowany ruch może nie być widoczny przez proxy. Instrukcję instalacji custom CA certificate znajdziesz na [**tej stronie**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Aplikacje targetujące **API Level 24 and above** wymagają modyfikacji Network Security Config, aby zaakceptować CA certificate proxy. Ten krok jest kluczowy do inspekcji zaszyfrowanego ruchu. Instrukcje dotyczące modyfikacji Network Security Config znajdziesz w [**tym tutorialu**](make-apk-accept-ca-certificate.md).

Jeśli używane jest **Flutter**, musisz postępować zgodnie z instrukcjami na [**tej stronie**](flutter.md). Wynika to z faktu, że samo dodanie certyfikatu do store nie zadziała, ponieważ Flutter ma własną listę zaufanych CA.

#### Statyczne wykrywanie SSL/TLS pinning

Zanim spróbujesz obejść pinning w czasie wykonywania, szybko zmapuj miejsca, gdzie pinning jest wymuszany w APK. Statyczne wykrywanie pomaga zaplanować hooki/patchowanie i skupić się na właściwych ścieżkach kodu.

Tool: SSLPinDetect
- Open-source static-analysis utility that decompiles the APK to Smali (via apktool) and scans for curated regex patterns of SSL/TLS pinning implementations.
- Reports exact file path, line number, and a code snippet for each match.
- Covers common frameworks and custom code paths: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Użycie
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Przykładowe reguły wzorców (JSON)
Użyj lub rozszerzaj signatures, aby wykrywać proprietarne/dostosowane style pinning. Możesz załadować własne JSON i skanować na dużą skalę.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notatki i wskazówki
- Szybkie skanowanie dużych aplikacji za pomocą multi-threading i memory-mapped I/O; wstępnie skompilowane regexy zmniejszają narzut i false positives.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Typowe obiekty wykrywania do dalszej triage:
- OkHttp: użycie CertificatePinner, setCertificatePinner, odwołania do pakietów okhttp3/okhttp
- Custom TrustManagers: javax.net.ssl.X509TrustManager, nadpisania checkServerTrusted
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init z niestandardowymi managerami
- Declarative pins w res/xml network security config oraz odwołania w manifest
- Użyj dopasowanych lokalizacji do zaplanowania Frida hooks, static patches lub przeglądu config przed testami dynamicznymi.



#### Omijanie SSL Pinning

Gdy SSL Pinning jest zaimplementowany, konieczne staje się jego obejście, aby analizować ruch HTTPS. Dostępne są różne metody:

- Automatycznie zmodyfikuj **apk**, aby obejść SSLPinning za pomocą [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Największą zaletą tej opcji jest to, że nie będziesz potrzebować root, aby obejść SSL Pinning, ale będziesz musiał usunąć aplikację i zainstalować nową, i to nie zawsze zadziała.
- Możesz użyć **Frida** (omawiana poniżej) aby obejść tę ochronę. Tutaj jest poradnik użycia Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Możesz też spróbować **automatycznie obejść SSL Pinning** używając [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Możesz również spróbować **automatycznie obejść SSL Pinning** używając **MobSF dynamic analysis** (opisane poniżej)
- Jeśli nadal uważasz, że istnieje ruch, którego nie przechwytujesz, możesz spróbować **przekierować ruch do Burp za pomocą iptables**. Przeczytaj ten wpis: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Poszukiwanie typowych podatności webowych

Ważne jest także wyszukiwanie typowych podatności webowych w aplikacji. Szczegółowe informacje dotyczące identyfikacji i łagodzenia tych podatności wykraczają poza zakres tego streszczenia, ale są szeroko omówione w innych miejscach.

### Frida

[Frida](https://www.frida.re) to narzędzie do dynamicznej instrumentacji dla deweloperów, reverse-engineerów i badaczy bezpieczeństwa.\
**Możesz uzyskać dostęp do uruchomionej aplikacji i hookować metody w czasie działania, aby zmieniać zachowanie, zmieniać wartości, wyciągać wartości, uruchamiać inny kod...**\
Jeśli chcesz wykonywać pentest aplikacji Android, musisz umieć używać Frida.

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Kilka "GUI" do pracy z Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection jest świetne do automatyzacji użycia Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Możesz znaleźć niektóre Awesome Frida scripts tutaj: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Spróbuj obejść mechanizmy anti-debugging / anti-frida ładując Frida jak wskazano w [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (narzędzie [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Zrzucanie pamięci - Fridump**

Sprawdź, czy aplikacja nie przechowuje w pamięci danych wrażliwych, których nie powinna, np. haseł czy mnemoniców.

Używając [**Fridump3**](https://github.com/rootbsd/fridump3) możesz zrzucić pamięć aplikacji poleceniem:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
To zrzuci pamięć do folderu ./dump, a tam możesz przeszukać ją, używając grep, np.:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Wrażliwe dane w Keystore**

W Androidzie Keystore jest najlepszym miejscem do przechowywania wrażliwych danych, jednak przy odpowiednich uprawnieniach nadal **możliwe jest uzyskanie do niego dostępu**. Ponieważ aplikacje mają tendencję do przechowywania tutaj **wrażliwych danych w postaci jawnej**, pentests powinny to sprawdzić jako root user, ponieważ ktoś z fizycznym dostępem do urządzenia mógłby je ukraść.

Nawet jeśli aplikacja przechowuje dane w keystore, powinny one być zaszyfrowane.

Aby uzyskać dostęp do danych w keystore możesz użyć tego skryptu Frida: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Używając poniższego skryptu Frida możliwe jest **bypass fingerprint authentication**, które aplikacje Android mogą stosować, aby **chronić określone wrażliwe obszary:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Obrazy w tle**

Gdy umieścisz aplikację w tle, Android przechowuje **migawkę aplikacji**, dzięki czemu po przywróceniu na pierwszy plan najpierw ładuje obraz, co sprawia, że aplikacja wydaje się ładować szybciej.

Jednak jeśli ta migawka zawiera **poufne informacje**, ktoś z dostępem do migawki może **ukraść te informacje** (uwaga: dostęp wymaga root).

Migawki są zwykle przechowywane w: **`/data/system_ce/0/snapshots`**

Android oferuje sposób, by **zapobiec przechwytywaniu zrzutów ekranu przez ustawienie parametru layout FLAG_SECURE**. Używając tej flagi, zawartość okna jest traktowana jako bezpieczna, co zapobiega jej pojawianiu się na zrzutach ekranu lub wyświetlaniu na niezabezpieczonych wyświetlaczach.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Analizator aplikacji Android**

Narzędzie to może pomóc w zarządzaniu różnymi narzędziami podczas analizy dynamicznej: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Deweloperzy często tworzą proxy components takie jak activities, services i broadcast receivers, które obsługują te Intents i przekazują je do metod takich jak `startActivity(...)` lub `sendBroadcast(...)`, co może być ryzykowne.

Niebezpieczeństwo polega na umożliwieniu atakującym wywołania non-exported app components lub dostępu do wrażliwych content providers przez przekierowanie tych Intents. Przykładem jest komponent `WebView`, który konwertuje URL-e na obiekty `Intent` za pomocą `Intent.parseUri(...)` i następnie je wykonuje, co może prowadzić do złośliwych Intent injection.

### Essential Takeaways

- **Intent Injection** jest podobny do webowego problemu Open Redirect.
- Eksploity polegają na przekazywaniu obiektów `Intent` jako extras, które mogą zostać przekierowane do wykonania niebezpiecznych operacji.
- Może to ujawnić non-exported components i content providers atakującym.
- Konwersja URL-i na `Intent` przez `WebView` może ułatwiać niezamierzone akcje.

### Android Client Side Injections and others

Prawdopodobnie znasz tego typu podatności z Web. Musisz być szczególnie ostrożny z tymi podatnościami w aplikacji Android:

- **SQL Injection:** W przypadku dynamicznych zapytań lub Content-Providers upewnij się, że używasz zapytań parametryzowanych.
- **JavaScript Injection (XSS):** Verify that JavaScript and Plugin support is disabled for any WebViews (disabled by default). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews powinny mieć wyłączony dostęp do systemu plików (włączony domyślnie) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: W wielu przypadkach, gdy aplikacja Android kończy sesję, cookie nie jest unieważniane lub może być nawet zapisane na dysku.
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatyczna analiza

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Analiza statyczna**

![](<../../images/image (866).png>)

**Ocena podatności aplikacji** przy użyciu przyjemnego webowego frontendu. Możesz też przeprowadzić dynamic analysis (ale musisz przygotować środowisko).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Assisted Dynamic analysis with MobSF

**MobSF** może być również bardzo pomocny przy **analizie dynamicznej** w **Android**, ale w tym wypadku musisz zainstalować MobSF i **genymotion** na hoście (a VM or Docker won't work). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
The **MobSF dynamic analyser** can:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). All of this is done automatically except for the screenshots, you need to press when you want a screenshot or you need to press "**Exported Activity Tester**" to obtain screenshots of all the exported activities.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: It will print all the loaded classes
- **Capture Strings**: It will print all the capture strings while using the application (super noisy)
- **Capture String Comparisons**: Could be very useful. It will **show the 2 strings being compared** and if the result was True or False.
- **Enumerate Class Methods**: Put the class name (like "java.io.File") and it will print all the methods of the class.
- **Search Class Pattern**: Search classes by pattern
- **Trace Class Methods**: **Trace** a **whole class** (see inputs and outputs of all methods of th class). Remember that by default MobSF traces several interesting Android Api methods.

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf also brings you a shell with some **adb** commands, **MobSF commands**, and common **shell** **commands** at the bottom of the dynamic analysis page. Some interesting commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**Narzędzia HTTP**

Gdy ruch HTTP zostanie przechwycony, możesz zobaczyć surowy widok przechwyconego ruchu na przycisku "**HTTP(S) Traffic**" lub ładniejszy widok w zielonym przycisku "**Start HTTPTools**". Z tej drugiej opcji możesz **send** **captured requests** do **proxies** takich jak Burp lub Owasp ZAP.\
Aby to zrobić, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> naciśnij "**Send to Fuzzer**" --> _wybierz adres proxy_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Po zakończeniu dynamicznej analizy za pomocą MobSF możesz kliknąć "**Start Web API Fuzzer**", aby **fuzz http requests** i szukać podatności.

> [!TIP]
> Po wykonaniu dynamicznej analizy za pomocą MobSF ustawienia proxy mogą zostać źle skonfigurowane i nie będziesz w stanie naprawić ich z poziomu GUI. Możesz naprawić ustawienia proxy wykonując:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

Narzędzie możesz pobrać z [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
To narzędzie używa pewnych **Hooks**, aby poinformować cię **co dzieje się w aplikacji** podczas przeprowadzania **dynamicznej analizy**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

To **great tool to perform static analysis with a GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

To narzędzie jest zaprojektowane do wyszukiwania różnych **security related Android application vulnerabilities**, zarówno w **source code**, jak i w **packaged APKs**. Narzędzie jest również **capable of creating a "Proof-of-Concept" deployable APK** oraz generować **ADB commands**, aby exploitować niektóre z odkrytych podatności (Exposed activities, intents, tapjacking...). Podobnie jak w przypadku Drozer, nie ma potrzeby rootowania urządzenia testowego.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Wyświetla wszystkie wyodrębnione pliki do łatwego przeglądu
- Automatycznie dekompiluje pliki APK do formatu Java i Smali
- Analizuje AndroidManifest.xml pod kątem powszechnych podatności i zachowań
- Statyczna analiza kodu źródłowego pod kątem powszechnych podatności i zachowań
- Informacje o urządzeniu
- i więcej
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER jest aplikacją wiersza poleceń, którą można używać w Windows, MacOS X i Linux, która analizuje pliki _.apk_ w poszukiwaniu podatności. Robi to poprzez dekompresję APKs i zastosowanie serii reguł do wykrywania tych podatności.

Wszystkie reguły znajdują się w pliku `rules.json`, a każda firma lub tester może utworzyć własne reguły, aby analizować to, czego potrzebują.

Pobierz najnowsze binaria ze [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn to **wieloplatformowe** narzędzie, które wspomaga programistów, bugbounty hunters i ethical hackers przeprowadzających [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) na aplikacjach mobilnych.

Koncepcja polega na tym, że przeciągasz i upuszczasz plik aplikacji mobilnej (plik .apk lub .ipa) na aplikację StaCoAn, a ona wygeneruje dla Ciebie wizualny i przenośny raport. Możesz dostosować ustawienia i wordlists, aby uzyskać spersonalizowane doświadczenie.

Pobierz[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework to system analizy podatności dla Androida, który pomaga deweloperom lub hackers znaleźć potencjalne luki bezpieczeństwa w aplikacjach Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** to narzędzie, którego głównym celem jest wykrywanie i ostrzeganie użytkownika o potencjalnych złośliwych zachowaniach wykonywanych przez aplikację Android.

Wykrywanie odbywa się za pomocą **static analysis** aplikacji Dalvik bytecode, reprezentowanego jako **Smali**, przy użyciu biblioteki [`androguard`](https://github.com/androguard/androguard).

Narzędzie szuka **powszechnych zachowań "złych" aplikacji** takich jak: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. Jest to narzędzie, które łączy powszechnie używane narzędzia do reverse engineering i analizy aplikacji mobilnych, aby wspomóc testowanie aplikacji mobilnych pod kątem zagrożeń OWASP mobile security. Jego celem jest ułatwienie tej pracy i uczynienie jej bardziej przyjazną dla developerów aplikacji mobilnych oraz specjalistów ds. bezpieczeństwa.

It is able to:

- Wyodrębnić kod Java i Smali przy użyciu różnych narzędzi
- Analyze APKs using: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Wyodrębnić informacje prywatne z APK przy użyciu regexps.
- Analizować Manifest.
- Analyze found domains using: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuskować APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Przydatne do wykrywania malware: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Zwróć uwagę, że w zależności od usługi i konfiguracji użytej do obfuskacji kodu, sekrety mogą, ale nie muszą, pozostać obfuskowane.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. Potrafi optymalizować bytecode oraz wykrywać i usuwać nieużywane instrukcje. ProGuard jest darmowym oprogramowaniem i jest dystrybuowany na licencji GNU General Public License, version 2.

ProGuard jest dystrybuowany jako część Android SDK i uruchamiany podczas budowania aplikacji w trybie release.

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Last time we checked, the Dexguard mode of operation was:

- wczytać zasób jako InputStream;
- podać wynik do klasy dziedziczącej po FilterInputStream, aby go odszyfrować;
- wykonać jakąś bezużyteczną obfuskację, by zmarnować kilka minut czasu reversera;
- podać odszyfrowany wynik do ZipInputStream, aby otrzymać plik DEX;
- na końcu wczytać powstały DEX jako Resource używając metody `loadDex`.

### [DeGuard](http://apk-deguard.com)

**DeGuard odwraca proces obfuskacji wykonywany przez narzędzia do obfuskacji Androida. To umożliwia liczne analizy bezpieczeństwa, w tym inspekcję kodu i identyfikację bibliotek.**

Możesz przesłać obfuskowane APK na ich platformę.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

It is a **generic android deobfuscator.** Simplify **virtually executes an app** to understand its behavior and then **tries to optimize the code** so it behaves identically but is easier for a human to understand. Each optimization type is simple and generic, so it doesn't matter what the specific type of obfuscation is used.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD gives you information about **how an APK was made**. It identifies many **compilers**, **packers**, **obfuscators**, and other weird stuff. It's [_PEiD_](https://www.aldeid.com/wiki/PEiD) for Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b is an Android security virtual machine based on ubuntu-mate includes the collection of latest framework, tutorials and labs from different security geeks and researchers for reverse engineering and malware analysis.

## References

- [Play Integrity API: How It Works & How to Bypass It](https://m4kr0.vercel.app/posts/play-integrity-api-how-it-works--how-to-bypass-it/)
- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) To świetna lista zasobów
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
