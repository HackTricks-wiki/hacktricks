# Aplicações Android Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Fundamentos das Aplicações Android

É altamente recomendado começar lendo esta página para conhecer as **partes mais importantes relacionadas à segurança do Android e os componentes mais perigosos em uma aplicação Android**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Esta é a ferramenta principal que você precisa para conectar-se a um dispositivo Android (emulado ou físico).\
**ADB** permite controlar dispositivos via **USB** ou **rede** a partir de um computador. Esta utilidade possibilita a **cópia** de arquivos em ambas as direções, a **instalação** e **desinstalação** de apps, a **execução** de comandos shell, o **backup** de dados, a **leitura** de logs, entre outras funções.

Confira a seguinte lista de [**ADB Commands**](adb-commands.md) para aprender a usar o adb.

## Smali

Às vezes é interessante **modificar o código da aplicação** para acessar **informações ocultas** (talvez senhas bem ofuscadas ou flags). Então, pode ser interessante decompilar o apk, modificar o código e recompilá-lo.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Isto pode ser muito útil como uma **alternativa para vários testes durante a dynamic analysis** que serão apresentados. Então, **mantenha sempre em mente essa possibilidade**.

## Outros truques interessantes

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **Baixar APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Extrair APK do dispositivo:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Mescle todos os splits e os apks base com [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Estudos de Caso e Vulnerabilidades


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Análise Estática

Primeiro de tudo, para analisar um APK você deve **dar uma olhada no código Java** usando um decompilador.\
Por favor, [**leia aqui para encontrar informação sobre diferentes decompiladores disponíveis**](apk-decompilers.md).

### Procurando informações interessantes

Apenas olhando as **strings** do APK você pode procurar por **senhas**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** e qualquer coisa interessante... procure até por **backdoors** de execução de código ou backdoors de autenticação (credenciais admin hardcoded no app).

**Firebase**

Preste atenção especial às **Firebase URLs** e verifique se estão mal configuradas. [Mais informações sobre o que é Firebase e como explorá-lo aqui.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Entendimento básico da aplicação - Manifest.xml, strings.xml

A **examinação dos arquivos _Manifest.xml_ e **_strings.xml_** de uma aplicação pode revelar potenciais vulnerabilidades de segurança**. Esses arquivos podem ser acessados usando decompiladores ou renomeando o arquivo APK para .zip e descompactando-o.

As **vulnerabilidades** identificadas a partir do **Manifest.xml** incluem:

- **Debuggable Applications**: Aplicações definidas como debuggable (`debuggable="true"`) no arquivo _Manifest.xml_ apresentam risco, pois permitem conexões que podem levar à exploração. Para entender melhor como explorar aplicações debuggable, consulte um tutorial sobre encontrar e explorar aplicações debuggable em um dispositivo.
- **Backup Settings**: O atributo `android:allowBackup="false"` deve ser explicitamente definido para aplicações que lidam com informações sensíveis para evitar backups não autorizados via adb, especialmente quando usb debugging está habilitado.
- **Network Security**: Configurações customizadas de network security (`android:networkSecurityConfig="@xml/network_security_config"`) em _res/xml/_ podem especificar detalhes de segurança como certificate pins e configurações de tráfego HTTP. Um exemplo é permitir tráfego HTTP para domínios específicos.
- **Exported Activities and Services**: Identificar activities e services exportados no manifest pode evidenciar componentes que podem ser mal utilizados. Análises adicionais durante testes dinâmicos podem revelar como explorar esses componentes.
- **Content Providers and FileProviders**: Content providers expostos podem permitir acesso ou modificação não autorizada de dados. A configuração de FileProviders também deve ser cuidadosamente verificada.
- **Broadcast Receivers and URL Schemes**: Esses componentes podem ser aproveitados para exploração, com atenção particular à forma como os URL schemes são gerenciados quanto a vulnerabilidades de input.
- **SDK Versions**: Os atributos `minSdkVersion`, `targetSDKVersion` e `maxSdkVersion` indicam as versões do Android suportadas, ressaltando a importância de não suportar versões antigas e vulneráveis do Android por razões de segurança.

Do arquivo **strings.xml**, podem ser descobertas informações sensíveis como API keys, custom schemas e outras notas de desenvolvedor, reforçando a necessidade de revisão cuidadosa desses recursos.

### Tapjacking

**Tapjacking** é um ataque onde uma **aplicação maliciosa** é lançada e **se posiciona por cima de uma aplicação vítima**. Uma vez que obscurece visivelmente o app vítima, sua interface é projetada de forma a enganar o usuário para interagir com ela, enquanto está repassando a interação para o app vítima.\
Na prática, isso **cega o usuário quanto ao fato de estar, na verdade, executando ações no app vítima**.

Encontre mais informação em:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Uma **activity** com o **`launchMode`** definido como **`singleTask` sem qualquer `taskAffinity`** definida é vulnerável a Task Hijacking. Isso significa que uma **aplicação** pode ser instalada e, se iniciada antes da aplicação real, ela pode **hijackar a task da aplicação real** (fazendo com que o usuário interaja com a **aplicação maliciosa achando que está usando a aplicação legítima**).

Mais info em:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Armazenamento de dados inseguro

**Internal Storage**

No Android, arquivos **armazenados** no **internal** storage são **projetados** para serem **acessíveis** exclusivamente pela **app** que os **criou**. Essa medida de segurança é **aplicada** pelo sistema operacional Android e é geralmente suficiente para a maioria das aplicações. No entanto, desenvolvedores às vezes utilizam modos como `MODE_WORLD_READABLE` e `MODE_WORLD_WRITABLE` para **permitir** que arquivos sejam **compartilhados** entre diferentes aplicações. Esses modos, entretanto, **não restringem o acesso** a esses arquivos por outras aplicações, incluindo potencialmente maliciosas.

1. **Análise Estática:**
- **Assegure-se** de que o uso de `MODE_WORLD_READABLE` e `MODE_WORLD_WRITABLE` seja **cuidadosamente revisado**. Esses modos **podem expor** arquivos a **acesso não intencional ou não autorizado**.
2. **Análise Dinâmica:**
- **Verifique** as **permissões** definidas nos arquivos criados pelo app. Especificamente, **confirme** se algum arquivo está **configurado para ser legível ou gravável mundialmente**. Isso pode representar um risco significativo de segurança, pois permitiria que **qualquer aplicação** instalada no dispositivo, independentemente de sua origem ou intenção, **leia ou modifique** esses arquivos.

**External Storage**

Ao lidar com arquivos em **external storage**, como SD Cards, certas precauções devem ser tomadas:

1. **Acessibilidade**:
- Arquivos no external storage são **globalmente legíveis e graváveis**. Isso significa que qualquer aplicação ou usuário pode acessar esses arquivos.
2. **Preocupações de Segurança**:
- Dada a facilidade de acesso, é recomendado **não armazenar informações sensíveis** no external storage.
- O external storage pode ser removido ou acessado por qualquer aplicação, tornando-o menos seguro.
3. **Tratamento de Dados vindos do External Storage**:
- Sempre **execute validação de input** nos dados recuperados do external storage. Isso é crucial porque os dados vêm de uma fonte não confiável.
- Armazenar executáveis ou arquivos de classe no external storage para carregamento dinâmico é fortemente desaconselhado.
- Se sua aplicação precisa recuperar arquivos executáveis do external storage, garanta que esses arquivos sejam **assinados e verificados criptograficamente** antes de serem carregados dinamicamente. Esse passo é vital para manter a integridade de segurança da aplicação.

External storage pode ser **acessado** em `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> A partir do Android 4.4 (**API 17**), o SD card possui uma estrutura de diretórios que **limita o acesso de um app ao diretório que é especificamente para aquele app**. Isso impede que aplicações maliciosas ganhem acesso de leitura ou escrita aos arquivos de outro app.

**Dados sensíveis armazenados em texto simples**

- **Shared preferences**: O Android permite que cada aplicação salve facilmente arquivos xml no caminho `/data/data/<packagename>/shared_prefs/` e às vezes é possível encontrar informações sensíveis em clear-text nessa pasta.
- **Databases**: O Android permite que cada aplicação salve facilmente bancos sqlite no caminho `/data/data/<packagename>/databases/` e às vezes é possível encontrar informações sensíveis em clear-text nessa pasta.

### Broken TLS

**Accept All Certificates**

Por alguma razão, às vezes desenvolvedores aceitam todos os certificados mesmo se, por exemplo, o hostname não corresponder, com linhas de código como a seguinte:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Uma boa forma de testar isso é tentar capturar o tráfego usando algum proxy como Burp sem autorizar o Burp CA dentro do dispositivo. Também, você pode gerar com o Burp um certificado para um hostname diferente e usá-lo.

### Criptografia fraca

**Processos pobres de gerenciamento de chaves**

Alguns desenvolvedores salvam dados sensíveis no armazenamento local e os criptografam com uma chave hardcoded/preditiva no código. Isso não deveria ser feito, pois algum reversing pode permitir que atacantes extraiam a informação confidencial.

**Uso de algoritmos inseguros e/ou depreciados**

Desenvolvedores não deveriam usar **algoritmos depreciados** para realizar **checks** de autorização, **armazenar** ou **enviar** dados. Alguns desses algoritmos são: RC4, MD4, MD5, SHA1... Se **hashes** são usados para armazenar senhas por exemplo, hashes resistentes a brute-force deveriam ser usados com salt.

### Outros checks

- É recomendado **ofuscar o APK** para dificultar o trabalho de reverse engineer para atacantes.
- Se o app for sensível (como apps bancários), ele deveria executar seus **próprios checks para ver se o mobile está rooted** e agir em consequência.
- Se o app for sensível (como apps bancários), ele deveria checar se um **emulador** está sendo usado.
- Se o app for sensível (como apps bancários), ele deveria **checar sua própria integridade antes de executar** para verificar se foi modificado.
- Use [**APKiD**](https://github.com/rednaga/APKiD) para verificar qual compiler/packer/obfuscator foi usado para construir o APK

### React Native Application

Leia a página a seguir para aprender como acessar facilmente o código javascript de aplicações React:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Leia a página a seguir para aprender como acessar facilmente o código C# de aplicações xamarin:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

De acordo com este [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/), superpacked é um algoritmo Meta que comprime o conteúdo de uma aplicação em um único arquivo. O blog fala sobre a possibilidade de criar um app que descomprima esse tipo de apps... e uma forma mais rápida que envolve **executar a aplicação e coletar os arquivos descomprimidos do filesystem.**

### Análise Estática Automatizada de Código

A ferramenta [**mariana-trench**](https://github.com/facebook/mariana-trench) é capaz de encontrar **vulnerabilidades** escaneando o **code** da aplicação. Essa ferramenta contém uma série de **known sources** (que indicam ao tool os **lugares** onde a **input** é **controlada pelo usuário**), **sinks** (que indicam ao tool **lugares perigosos** onde input maliciosa do usuário poderia causar danos) e **rules**. Essas rules indicam a **combinação** de **sources-sinks** que sinaliza uma vulnerabilidade.

Com esse conhecimento, **mariana-trench irá revisar o code e encontrar possíveis vulnerabilidades nele**.

### Secrets leaked

Uma aplicação pode conter segredos (API keys, passwords, hidden urls, subdomains...) dentro dela que você pode ser capaz de descobrir. Você pode usar uma ferramenta como [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Outras funções interessantes

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declaradas como `native`: `public native, System.loadLibrary, System.load`
- [Leia isto para aprender **como reverter native functions**](reversing-native-libraries.md)

### **Outros truques**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Análise Dinâmica

> Antes de tudo, você precisa de um ambiente onde possa instalar a aplicação e todo o ambiente (Burp CA cert, Drozer e Frida principalmente). Portanto, um dispositivo rooted (emulado ou não) é altamente recomendado.

### Análise dinâmica Online

Você pode criar uma **conta gratuita** em: [https://appetize.io/](https://appetize.io/). Essa plataforma permite **upload** e **execução** de APKs, então é útil para ver como um apk está se comportando.

Você pode até **ver os logs da sua aplicação** na web e conectar via **adb**.

![](<../../images/image (831).png>)

Graças à conexão ADB você pode usar **Drozer** e **Frida** dentro dos emuladores.

### Análise Dinâmica Local

#### Usando um emulador

- [**Android Studio**](https://developer.android.com/studio) (Você pode criar dispositivos **x86** e **arm**, e de acordo com [**isso**](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**as versões x86 mais recentes** **suportam ARM libraries** sem precisar de um emulador arm lento).
- Aprenda a configurá-lo nesta página:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(versão gratuita:** Personal Edition, você precisa criar uma conta. _É recomendado **baixar** a versão **COM**_ _**VirtualBox** para evitar potenciais erros._)
- [**Nox**](https://es.bignox.com) (Gratuito, mas não suporta Frida ou Drozer).

> [!TIP]
> Ao criar um novo emulador em qualquer plataforma lembre-se que quanto maior a tela, mais lento o emulador irá rodar. Então selecione telas pequenas se possível.

Para **instalar google services** (como AppStore) no Genymotion você precisa clicar no botão marcado em vermelho da imagem a seguir:

![](<../../images/image (277).png>)

Além disso, note que na **configuração da VM Android no Genymotion** você pode selecionar **Bridge Network mode** (isso será útil se você for conectar na VM Android a partir de uma VM diferente com as ferramentas).

#### Use um dispositivo físico

Você precisa ativar as opções de **debugging** e será interessante se você puder **rootear** ele:

1. **Settings**.
2. (FromAndroid 8.0) Selecione **System**.
3. Selecione **About phone**.
4. Pressione **Build number** 7 vezes.
5. Volte e você encontrará as **Developer options**.

> Uma vez que você instalou a aplicação, a primeira coisa que deveria fazer é testá-la e investigar o que ela faz, como funciona e ficar confortável com ela.\
> Sugiro **realizar essa análise dinâmica inicial usando MobSF dynamic analysis + pidcat**, assim seremos capazes de **aprender como a aplicação funciona** enquanto o MobSF **captura** muitos dados **interessantes** que você pode revisar mais tarde.

### Vazamento de Dados Não Intencionais

**Logging**

Desenvolvedores devem ter cuidado ao expor **informações de debugging** publicamente, pois isso pode levar a vazamento de dados sensíveis. As ferramentas [**pidcat**](https://github.com/JakeWharton/pidcat) e `adb logcat` são recomendadas para monitorar os logs da aplicação para identificar e proteger informação sensível. **Pidcat** é preferido por sua facilidade de uso e legibilidade.

> [!WARNING]
> Note que a partir de **versões posteriores ao Android 4.0**, **aplicações só podem acessar seus próprios logs**. Portanto aplicações não podem acessar logs de outros apps.\
> De qualquer forma, ainda é recomendado **não logar informações sensíveis**.

**Cache do Clipboard / Copy-Paste**

O framework baseado em **clipboard** do Android habilita a funcionalidade de copy-paste em apps, mas representa um risco já que **outras aplicações** podem **acessar** o clipboard, potencialmente expondo dados sensíveis. É crucial **desabilitar funções de copy/paste** em seções sensíveis de uma aplicação, como detalhes de cartão de crédito, para evitar vazamentos de dados.

**Crash Logs**

Se uma aplicação **crasha** e **salva logs**, esses logs podem auxiliar atacantes, particularmente quando a aplicação não pode ser reverse-engineered. Para mitigar esse risco, evite logar em crashes, e se os logs devem ser transmitidos pela rede, assegure que sejam enviados via canal SSL para segurança.

Como pentester, **tente dar uma olhada nesses logs**.

**Dados de Analytics enviados para 3rd Parties**

Aplicações frequentemente integram serviços como Google Adsense, que podem inadvertidamente **vazar dados sensíveis** devido a implementação incorreta pelos desenvolvedores. Para identificar potenciais vazamentos, é aconselhável **interceptar o tráfego da aplicação** e checar por qualquer informação sensível sendo enviada para serviços de terceiros.

### SQLite DBs

A maioria das aplicações irá usar **internal SQLite databases** para salvar informação. Durante o pentest dê uma **olhada** nas **databases** criadas, os nomes das **tables** e **columns** e todos os **dados** salvos porque você pode encontrar **informação sensível** (o que seria uma vulnerabilidade).\
As databases devem estar localizadas em `/data/data/the.package.name/databases` como `/data/data/com.mwr.example.sieve/databases`

Se a database está salvando informação confidencial e está **encrypted** mas você pode **find** a **password** dentro da application, isso ainda é uma **vulnerabilidade**.

Enumere as tables usando `.tables` e enumere as columns das tables fazendo `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

Dos [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** permite que você **assuma o papel de um app Android** e interaja com outros apps. Ele pode fazer **qualquer coisa que uma aplicação instalada pode fazer**, como usar o mecanismo de Inter-Process Communication (IPC) do Android e interagir com o sistema operacional subjacente. .\
Drozer é uma ferramenta útil para **explorar exported activities, exported services e Content Providers** como você irá aprender nas seções seguintes.

### Explorando Activities exportadas

[**Leia isto se você quiser revisar o que é uma Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Lembre também que o código de uma activity começa no método **`onCreate`**.

**Bypass de autorização**

Quando uma Activity está exported você pode invocar sua tela a partir de um app externo. Assim, se uma activity com **informação sensível** está **exported** você poderia **bypassar** os mecanismos de **authentication** **para acessá-la.**

[**Aprenda como explorar exported activities com Drozer.**](drozer-tutorial/index.html#activities)

Você também pode iniciar uma exported activity a partir do adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTA**: MobSF detectará como malicioso o uso de _**singleTask/singleInstance**_ como `android:launchMode` em uma activity, mas devido a [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), aparentemente isso é perigoso apenas em versões antigas (API < 21).

> [!TIP]
> Observe que um authorisation bypass nem sempre é uma vulnerabilidade; depende de como o bypass funciona e quais informações são expostas.

**Vazamento de informações sensíveis**

**Activities também podem retornar resultados**. Se você conseguir encontrar uma activity exportada e desprotegida que chama o método **`setResult`** e **retorna informações sensíveis**, há um vazamento de informações sensíveis.

#### Tapjacking

Se o Tapjacking não for prevenido, você pode abusar da activity exportada para fazer o **usuário executar ações inesperadas**. Para mais informações sobre [**o que é Tapjacking siga o link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Leia isto se quiser relembrar o que é um Content Provider.**](android-applications-basics.md#content-provider)\
Content providers são basicamente usados para **compartilhar dados**. Se um app disponibiliza content providers você pode ser capaz de **extrair dados sensíveis** deles. Também é interessante testar possíveis **SQL injections** e **Path Traversals**, pois eles podem ser vulneráveis.

[**Aprenda como explorar Content Providers com Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Leia isto se quiser relembrar o que é um Service.**](android-applications-basics.md#services)\
Lembre-se que as ações de um Service começam no método `onStartCommand`.

Um Service é basicamente algo que **pode receber dados**, **processá-los** e **retornar** (ou não) uma resposta. Então, se uma aplicação está exportando alguns services você deve **verificar** o **código** para entender o que ele faz e **testá-lo** **dinamicamente** para extrair informações confidenciais, contornar medidas de autenticação...\
[**Aprenda como explorar Services com Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Leia isto se quiser relembrar o que é um Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Lembre-se que as ações de um Broadcast Receiver começam no método `onReceive`.

Um Broadcast Receiver ficará esperando por um tipo de mensagem. Dependendo de como o receiver lida com a mensagem, ele pode ser vulnerável.\
[**Aprenda como explorar Broadcast Receivers com Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Você pode procurar por deep links manualmente, usando ferramentas como MobSF ou scripts como [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Você pode **abrir** um **scheme** declarado usando **adb** ou um **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Observe que você pode **omitir o nome do pacote** e o dispositivo móvel chamará automaticamente o app que deve abrir esse link._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Código executado**

Para encontrar o **código que será executado no App**, vá para a activity chamada pelo deeplink e procure a função **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Informação sensível**

Sempre que encontrar um deep link verifique que **não está recebendo dados sensíveis (como senhas) via parâmetros de URL**, porque qualquer outra aplicação poderia **se passar pelo deep link e roubar esses dados!**

**Parameters in path**

Você **deve também verificar se algum deep link está usando um parâmetro dentro do path** da URL como: `https://api.example.com/v1/users/{username}`, nesse caso você pode forçar um path traversal acessando algo como: `example://app/users?username=../../unwanted-endpoint%3fparam=value`.\
Note que se você encontrar os endpoints corretos dentro da aplicação pode ser possível causar um **Open Redirect** (se parte do path for usada como domain name), **account takeover** (se você conseguir modificar detalhes de usuários sem CSRF token e o vuln endpoint usar o método correto) e qualquer outra vuln. Mais [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

Um [interesting bug bounty report](https://hackerone.com/reports/855618) sobre links (_/.well-known/assetlinks.json_).

### Inspeção da Camada de Transporte e Falhas de Verificação

- **Certificates are not always inspected properly** por aplicações Android. É comum que essas aplicações ignorem avisos e aceitem certificados self-signed ou, em alguns casos, retornem a usar conexões HTTP.
- **Negotiations during the SSL/TLS handshake are sometimes weak**, empregando cipher suites inseguros. Essa vulnerabilidade torna a conexão suscetível a ataques man-in-the-middle (MITM), permitindo que atacantes decifrem os dados.
- **Leakage of private information** é um risco quando aplicações se autenticam usando canais seguros mas depois se comunicam por canais não seguros para outras transações. Essa abordagem não protege dados sensíveis, como session cookies ou detalhes do usuário, da interceptação por entidades maliciosas.

#### Verificação de Certificado

Vamos focar na **verificação de certificados**. A integridade do certificado do servidor deve ser verificada para aumentar a segurança. Isso é crucial porque configurações TLS inseguras e a transmissão de dados sensíveis por canais não encriptados podem representar riscos significativos. Para passos detalhados sobre verificar certificados do servidor e corrigir vulnerabilidades, [**este recurso**](https://manifestsecurity.com/android-application-security-part-10/) fornece orientação abrangente.

#### SSL Pinning

SSL Pinning é uma medida de segurança onde a aplicação verifica o certificado do servidor contra uma cópia conhecida armazenada dentro da própria aplicação. Esse método é essencial para prevenir ataques MITM. Implementar SSL Pinning é fortemente recomendado para aplicações que lidam com informação sensível.

#### Inspeção de Tráfego

Para inspecionar tráfego HTTP, é necessário **instalar o certificado da ferramenta proxy** (por exemplo, Burp). Sem instalar esse certificado, o tráfego encriptado pode não ser visível através do proxy. Para um guia sobre instalar um certificado CA customizado, [**clique aqui**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Aplicações direcionadas a **API Level 24 and above** requerem modificações no Network Security Config para aceitar o certificado CA do proxy. Esse passo é crítico para inspecionar tráfego encriptado. Para instruções sobre como modificar o Network Security Config, [**consulte este tutorial**](make-apk-accept-ca-certificate.md).

Se **Flutter** estiver sendo usado, você precisa seguir as instruções em [**esta página**](flutter.md). Isso é porque apenas adicionar o certificado ao store não funcionará, já que Flutter tem sua própria lista de CAs válidas.

#### Detecção estática de SSL/TLS pinning

Antes de tentar bypasses em runtime, mapeie rapidamente onde o pinning é aplicado no APK. A descoberta estática ajuda a planejar hooks/patches e a focar nos caminhos de código corretos.

Tool: SSLPinDetect
- Utilitário open-source de análise estática que decompila o APK para Smali (via apktool) e escaneia por padrões regex curados de implementações de SSL/TLS pinning.
- Reporta o caminho de arquivo exato, número da linha e um trecho de código para cada correspondência.
- Cobre frameworks comuns e caminhos de código customizados: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init com TrustManagers/KeyManagers customizados, e pins em Network Security Config XML.

Install
- Pré-requisitos: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Uso
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Exemplo de regras de padrão (JSON)
Use ou estenda signatures para detectar estilos proprietários/personalizados de pinning. Você pode carregar seu próprio JSON e scan em escala.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notas e dicas
- Escaneamento rápido em apps grandes via multithreading e I/O mapeada em memória; regex pré-compiladas reduzem overhead/falsos positivos.
- Coleção de padrões: https://github.com/aancw/smali-sslpin-patterns
- Alvos típicos de detecção para triagem a seguir:
- OkHttp: uso de CertificatePinner, setCertificatePinner, referências ao pacote okhttp3/okhttp
- TrustManagers personalizados: javax.net.ssl.X509TrustManager, sobrescritas de checkServerTrusted
- SSL contexts personalizados: SSLContext.getInstance + SSLContext.init com managers personalizados
- Pins declarativos em res/xml network security config e referências no manifest
- Use as localizações correspondentes para planejar Frida hooks, patches estáticos, ou revisões de configuração antes de testes dinâmicos.



#### Contornando SSL Pinning

When SSL Pinning is implemented, bypassing it becomes necessary to inspect HTTPS traffic. Various methods are available for this purpose:

- Automatically **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). A maior vantagem dessa opção é que você não precisará de root para contornar o SSLPinning, mas será necessário apagar o aplicativo e reinstalar a nova versão, e isso nem sempre funcionará.
- You could use **Frida** (discussed below) to bypass this protection. Here you have a guide to use Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- You can also try to **automatically bypass SSL Pinning** using [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- You can also try to **automatically bypass SSL Pinning** using **MobSF dynamic analysis** (explained below)
- If you still think that there is some traffic that you aren't capturing you can try to **forward the traffic to burp using iptables**. Read this blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Procurando Vulnerabilidades Web Comuns

É importante também procurar por vulnerabilidades web comuns dentro da aplicação. Informações detalhadas sobre identificação e mitigação dessas vulnerabilidades estão além do escopo deste resumo, mas são amplamente abordadas em outros lugares.

### Frida

[Frida](https://www.frida.re) é um toolkit de instrumentação dinâmica para desenvolvedores, reverse-engineers, e pesquisadores de segurança.\
**Você pode acessar a aplicação em execução e hookar métodos em tempo de execução para alterar o comportamento, mudar valores, extrair valores, executar código diferente...**\
Se você quer pentest aplicações Android você precisa saber como usar Frida.

- Aprenda a usar o Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Algumas "GUI" para ações com Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection é ótimo para automatizar o uso do Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Você pode encontrar alguns scripts Awesome para Frida aqui: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Tente contornar mecanismos anti-debugging / anti-frida carregando o Frida conforme indicado em [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

Verifique se a aplicação está armazenando informações sensíveis na memória que não deveria, como senhas ou mnemônicos.

Usando [**Fridump3**](https://github.com/rootbsd/fridump3) você pode fazer dump da memória do app com:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Isto irá fazer o dump da memória na pasta ./dump, e lá você pode grep com algo como:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Dados sensíveis no Keystore**

No Android o Keystore é o melhor lugar para armazenar dados sensíveis, porém, com privilégios suficientes ainda é **possível acessá-lo**. Como as aplicações tendem a armazenar aqui **dados sensíveis em texto claro**, os pentests devem verificar isso com privilégios de root — alguém com acesso físico ao dispositivo poderia conseguir roubar esses dados.

Mesmo que um app armazene dados no Keystore, esses dados devem ser criptografados.

Para acessar os dados dentro do Keystore você pode usar este script Frida: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Usando o seguinte script Frida, pode ser possível **bypass fingerprint authentication** que aplicações Android possam estar executando para **proteger certas áreas sensíveis:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Imagens de Fundo**

Quando você coloca um aplicativo em segundo plano, o Android armazena um **snapshot da aplicação** para que, quando ele for restaurado para o primeiro plano, comece carregando a imagem antes do app, fazendo com que pareça que o aplicativo foi carregado mais rapidamente.

No entanto, se esse snapshot contiver **informações sensíveis**, alguém com acesso ao snapshot pode **roubar essas informações** (observe que é necessário root para acessá-lo).

Os snapshots geralmente são armazenados em: **`/data/system_ce/0/snapshots`**

O Android fornece uma forma de **impedir a captura de screenshots configurando o parâmetro de layout FLAG_SECURE**. Ao usar essa flag, o conteúdo da janela é tratado como seguro, evitando que apareça em screenshots ou que seja visualizado em displays não seguros.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Analisador de Aplicações Android**

Esta ferramenta pode ajudar você a gerenciar diferentes ferramentas durante a análise dinâmica: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Developers often create proxy components like activities, services, and broadcast receivers that handle these Intents and pass them to methods such as `startActivity(...)` or `sendBroadcast(...)`, which can be risky.

O perigo está em permitir que atacantes disparem componentes não-exportados do app ou acessem content providers sensíveis redirecionando esses Intents. Um exemplo notável é o componente `WebView` convertendo URLs em objetos `Intent` via `Intent.parseUri(...)` e então executando-os, potencialmente levando a injeções maliciosas de Intent.

### Pontos Essenciais

- **Intent Injection** is similar to web's Open Redirect issue.
- Exploits involve passing `Intent` objects as extras, which can be redirected to execute unsafe operations.
- It can expose non-exported components and content providers to attackers.
- `WebView`’s URL to `Intent` conversion can facilitate unintended actions.

### Injeções no Lado do Cliente Android e outros

Provavelmente você conhece esse tipo de vulnerabilidade da Web. Você deve ter cuidado especial com essas vulnerabilidades em uma aplicação Android:

- **SQL Injection:** When dealing with dynamic queries or Content-Providers ensure you are using parameterized queries.
- **JavaScript Injection (XSS):** Verifique que o suporte a JavaScript e Plugins esteja desabilitado para quaisquer WebViews (desabilitado por padrão). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews should have access to the file system disabled (enabled by default) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: Em vários casos, quando a aplicação Android finaliza a sessão o cookie não é revogado ou pode até ser salvo em disco
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Análise Automática

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Análise estática**

![](<../../images/image (866).png>)

**Avaliação de vulnerabilidades da aplicação** usando uma interface web agradável. Você também pode realizar análise dinâmica (mas é necessário preparar o ambiente).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Assisted Dynamic analysis with MobSF

**MobSF** can also be very helpful for **dynamic analysis** in **Android**, but in that case you will need to install MobSF and **genymotion** in your host (a VM or Docker won't work). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
The **MobSF dynamic analyser** can:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). All of this is done automatically except for the screenshots, you need to press when you want a screenshot or you need to press "**Exported Activity Tester**" to obtain screenshots of all the exported activities.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: It will print all the loaded classes
- **Capture Strings**: It will print all the capture strings while using the application (super noisy)
- **Capture String Comparisons**: Could be very useful. It will **show the 2 strings being compared** and if the result was True or False.
- **Enumerate Class Methods**: Put the class name (like "java.io.File") and it will print all the methods of the class.
- **Search Class Pattern**: Search classes by pattern
- **Trace Class Methods**: **Trace** a **whole class** (see inputs and outputs of all methods of th class). Remember that by default MobSF traces several interesting Android Api methods.

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf also brings you a shell with some **adb** commands, **MobSF commands**, and common **shell** **commands** at the bottom of the dynamic analysis page. Some interesting commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**Ferramentas HTTP**

Quando o tráfego http é capturado você pode ver uma vista bruta do tráfego capturado no botão inferior "**HTTP(S) Traffic**" ou uma vista mais agradável no botão verde "**Start HTTPTools**". Pela segunda opção, você pode **enviar** as **captured requests** para **proxies** como Burp ou Owasp ZAP.\
Para isso, _ligue o Burp -->_ _desative o Intercept --> em MobSF HTTPTools selecione a request_ --> pressione "**Send to Fuzzer**" --> _selecione o proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Uma vez que você termine a análise dinâmica com MobSF você pode pressionar "**Start Web API Fuzzer**" para **fuzz http requests** e procurar por vulnerabilidades.

> [!TIP]
> Após realizar uma análise dinâmica com MobSF as configurações de proxy podem ficar mal configuradas e você não conseguirá corrigi-las pela GUI. Você pode corrigir as configurações de proxy fazendo:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

Você pode obter a ferramenta em [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Esta ferramenta vai usar alguns **Hooks** para informar **o que está acontecendo na aplicação** enquanto você realiza uma **análise dinâmica**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Esta é uma **ótima ferramenta para realizar análise estática com uma GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Esta ferramenta foi projetada para procurar várias vulnerabilidades relacionadas à segurança em aplicações Android, seja no **source code** ou em **packaged APKs**. A ferramenta também é **capaz de criar um "Proof-of-Concept" deployable APK** e **comandos ADB**, para explorar algumas das vulnerabilidades encontradas (Exposed activities, intents, tapjacking...). Como com Drozer, não é necessário dar root no dispositivo de teste.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Exibe todos os arquivos extraídos para referência fácil
- Descompila automaticamente arquivos APK para os formatos Java e Smali
- Analisa AndroidManifest.xml para common vulnerabilities e behavior
- Análise estática do source code para common vulnerabilities e behavior
- Informações do dispositivo
- e mais
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER é uma aplicação de linha de comando que pode ser usada no Windows, MacOS X e Linux, e que analisa arquivos _.apk_ em busca de vulnerabilidades. Faz isso descomprimindo APKs e aplicando uma série de regras para detectar essas vulnerabilidades.

Todas as regras estão centralizadas em um arquivo `rules.json`, e cada empresa ou testador pode criar suas próprias regras para analisar o que precisam.

Baixe os binários mais recentes na [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn é uma ferramenta **multiplataforma** que auxilia desenvolvedores, bugbounty hunters e ethical hackers na realização de [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) em aplicações móveis.

O conceito é que você arraste e solte o arquivo da sua aplicação móvel (um arquivo .apk ou .ipa) na aplicação StaCoAn e ela irá gerar um relatório visual e portátil para você. Você pode ajustar as configurações e wordlists para obter uma experiência personalizada.

Baixar[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework é um sistema de análise de vulnerabilidades para Android que ajuda desenvolvedores ou hackers a encontrar potenciais vulnerabilidades de segurança em aplicações Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** é uma ferramenta cujo objetivo principal é detectar e avisar o usuário sobre potenciais comportamentos maliciosos desenvolvidos por um aplicativo Android.

A detecção é realizada com a **static analysis** do Dalvik bytecode da aplicação, representado como **Smali**, com a biblioteca [`androguard`](https://github.com/androguard/androguard).

Esta ferramenta procura por **comportamento comum de "aplicações maliciosas"** como: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** é um **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. É uma ferramenta que reúne ferramentas comumente usadas para mobile application reverse engineering e analysis, para auxiliar no teste de aplicações móveis contra as ameaças de segurança mobile da OWASP. Seu objetivo é tornar essa tarefa mais fácil e amigável para desenvolvedores de aplicações móveis e profissionais de segurança.

Ele é capaz de:

- Extrair código Java e Smali usando diferentes ferramentas
- Analisar APKs usando: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Extrair informações privadas do APK usando regexps.
- Analisar o Manifest.
- Analisar domínios encontrados usando: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) e [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscar APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Útil para detectar malware: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Observe que, dependendo do serviço e da configuração usados para ofuscar o código, segredos podem ou não acabar ofuscados.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

Segundo a [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** é uma ferramenta open source de linha de comando que reduz, otimiza e ofusca código Java. É capaz de otimizar bytecode assim como detectar e remover instruções não utilizadas. ProGuard é software livre e é distribuído sob a GNU General Public License, versão 2.

ProGuard é distribuído como parte do Android SDK e é executado ao construir a aplicação em modo release.

### [DexGuard](https://www.guardsquare.com/dexguard)

Encontre um guia passo a passo para deobfuscar o apk em [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(Do guia) Da última vez que verificamos, o modo de operação do Dexguard era:

- carregar um recurso como um InputStream;
- passar o resultado para uma classe que herda de FilterInputStream para decriptá-lo;
- fazer alguma obfuscação inútil para gastar alguns minutos do tempo de um reverser;
- passar o resultado decriptado para um ZipInputStream para obter um arquivo DEX;
- finalmente carregar o DEX resultante como um Resource usando o método `loadDex`.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverte o processo de ofuscação realizado por ferramentas de ofuscação Android. Isso possibilita diversas análises de segurança, incluindo inspeção de código e identificação de bibliotecas.**

Você pode enviar um APK ofuscado para a plataforma deles.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

Esta é uma ferramenta LLM para encontrar potenciais vulnerabilidades de segurança em android apps e deobfuscar o código de apps android. Usa a Gemini public API do Google.

### [Simplify](https://github.com/CalebFenton/simplify)

É um **deobfuscator genérico para android.** Simplify **virtualmente executa um app** para entender seu comportamento e então **tenta otimizar o código** para que se comporte de forma idêntica, mas seja mais fácil para um humano entender. Cada tipo de otimização é simples e genérico, então não importa qual tipo específico de ofuscação foi usado.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD fornece informações sobre **como um APK foi criado**. Identifica muitos **compilers**, **packers**, **obfuscators**, e outras coisas estranhas. É o [_PEiD_](https://www.aldeid.com/wiki/PEiD) para Android.

### Manual

[Leia este tutorial para aprender alguns truques sobre **como reverter ofuscação personalizada**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b é uma máquina virtual de segurança Android baseada em ubuntu-mate que inclui uma coleção dos frameworks, tutoriais e labs mais recentes de diferentes entusiastas e pesquisadores de segurança para reverse engineering e análise de malware.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) É uma ótima lista de recursos
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) curso rápido de Android
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)

## Yet to try

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
