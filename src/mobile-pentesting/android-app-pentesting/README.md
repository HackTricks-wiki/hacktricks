# Android 应用 Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android 应用 基础

强烈建议先阅读此页面，以了解与 Android 安全相关的**最重要部分以及 Android 应用中最危险的组件**：


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

这是连接 Android 设备（模拟或物理）所需的主要工具。\
**ADB** 允许从计算机通过 **USB** 或 **Network** 控制设备。该工具支持双向 **复制** 文件、**安装** 和 **卸载** 应用、**执行** shell 命令、**备份** 数据、**读取** 日志等功能。

查看以下 [**ADB Commands**](adb-commands.md) 列表以学习如何使用 adb。

## Smali

有时为了访问 **隐藏信息**（例如高度混淆的密码或 flags），修改应用代码会很有用。因此，可能需要反编译 apk、修改代码并重新编译。\
[**在本教程中** 你可以 **学习如何反编译 APK、修改 Smali 代码并重新编译 APK** 以加入新功能](smali-changes.md)。这在进行动态分析时作为若干测试的**替代方法**非常有用。请始终**记住**这一可能性。

## Other interesting tricks

- [在 Play Store 中伪装你的位置](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [利用不安全的 In-App 更新机制](insecure-in-app-update-rce.md)
- [滥用 Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **下载 APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- 从设备提取 APK：
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- 使用 [APKEditor](https://github.com/REAndroid/APKEditor) 合并所有 splits 和 base apks:
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Case Studies & Vulnerabilities


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Static Analysis

First of all, for analysing an APK you should **take a look to the to the Java code** using a decompiler.\
Please, [**read here to find information about different available decompilers**](apk-decompilers.md).

### Looking for interesting Info

只需查看 APK 的 **strings** 就可以搜索 **passwords**、**URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep))、**api** keys、**encryption**、**bluetooth uuids**、**tokens** 以及其他有价值的信息……甚至查找代码执行的 **backdoors** 或身份验证 backdoors（应用的硬编码管理员凭据）。

**Firebase**

特别注意 **firebase URLs** 并检查其是否配置不当。[More information about whats is FIrebase and how to exploit it here.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Basic understanding of the application - Manifest.xml, strings.xml

**对应用程序的 _Manifest.xml_ 和 **_strings.xml_** 文件的检查可以暴露潜在的安全漏洞**。这些文件可以通过反编译器访问，或将 APK 的文件扩展名重命名为 .zip 然后解压来获取。

**从 _Manifest.xml_ 识别出的漏洞包括：**

- **Debuggable Applications**: 在 _Manifest.xml_ 文件中将应用设置为 debuggable (`debuggable="true"`) 会带来风险，因为它允许连接从而可能被利用。有关如何发现并利用可调试应用的更多信息，请参考相关教程。
- **Backup Settings**: 对于处理敏感信息的应用，应显式设置 `android:allowBackup="false"` 属性，以防止通过 adb 进行未经授权的数据备份，尤其是在启用 usb debugging 时。
- **Network Security**: 在 _res/xml/_ 中的自定义网络安全配置（`android:networkSecurityConfig="@xml/network_security_config"`）可以指定证书 pin 和 HTTP 流量设置等安全细节。例如允许针对特定域的 HTTP 流量。
- **Exported Activities and Services**: 在 manifest 中识别 exported 的 activities 和 services 可以突出可能被滥用的组件。在动态测试期间的进一步分析可以揭示如何利用这些组件。
- **Content Providers and FileProviders**: 暴露的 content providers 可能允许未授权访问或修改数据。FileProviders 的配置也应仔细审查。
- **Broadcast Receivers and URL Schemes**: 这些组件可能被用于利用，特别需要注意 URL schemes 如何管理以防止输入相关的漏洞。
- **SDK Versions**: `minSdkVersion`、`targetSDKVersion` 和 `maxSdkVersion` 属性指示支持的 Android 版本，强调了不要支持过时且存在已知漏洞的 Android 版本以保证安全。

从 **strings.xml** 文件中，可以发现敏感信息，如 API keys、自定义 schema 及其他开发者注释，凸显了对这些资源进行仔细审查的必要性。

### Tapjacking

**Tapjacking** 是一种攻击，攻击者启动一个 **malicious application** 并将其定位在受害应用之上。一旦其可见地遮挡住受害应用，其用户界面将被设计为欺骗用户与之交互，同时将交互传递给受害应用。\
实际上，这会**使用户无法察觉他们实际上正在对受害应用执行操作**。

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

如果一个 activity 的 **`launchMode`** 被设置为 **`singleTask`** 且没有定义任何 **`taskAffinity`**，则该 activity 易受 Task Hijacking。 这意味着，如果在真实应用之前安装并启动一个应用，它可能会**劫持真实应用的 task**（因此用户会以为自己在使用真实应用，实际上在与恶意应用交互）。

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Insecure data storage

**Internal Storage**

在 Android 中，存储在 **internal** 存储的文件被设计为仅可被创建它们的 **app** 访问。这一安全措施由 Android 操作系统强制执行，通常足以满足大多数应用的安全需求。然而，开发者有时会使用诸如 `MODE_WORLD_READABLE` 和 `MODE_WORLD_WRITABLE` 的模式以**允许**文件在不同应用之间共享。但这些模式**不会限制**其他应用（包括潜在的恶意应用）对这些文件的访问。

1. **Static Analysis:**
- **Ensure** that the use of `MODE_WORLD_READABLE` and `MODE_WORLD_WRITABLE` is **carefully scrutinized**。这些模式**可能会暴露**文件给意外或未授权的访问。
2. **Dynamic Analysis:**
- **Verify** the **permissions** set on files created by the app。特别是，**检查**是否有任何文件被设置为全局可读或可写。这可能构成重大安全风险，因为它将允许设备上安装的**任何应用**（无论来源或意图）读取或修改这些文件。

**External Storage**

在处理位于外部存储（如 SD 卡）上的文件时，应采取如下预防措施：

1. **Accessibility**:
- 外部存储上的文件是**全局可读可写**的。这意味着任何应用或用户都可以访问这些文件。
2. **Security Concerns**:
- 鉴于易访问性，建议**不要在外部存储上保存敏感信息**。
- 外部存储可以被移除或被任何应用访问，因此安全性较低。
3. **Handling Data from External Storage**:
- 始终对从外部存储检索的数据执行**输入验证**，这很重要，因为这些数据来自不受信任的来源。
- 强烈不建议将可执行文件或 class 文件存放在外部存储上以便动态加载。
- 如果你的应用必须从外部存储检索可执行文件，确保在动态加载之前对这些文件进行签名和加密学验证。这一步对于维护应用的安全完整性至关重要。

External storage can be **accessed** in `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> Starting with Android 4.4 (**API 17**), the SD card has a directory structure which **limits access from an app to the directory which is specifically for that app**. This prevents malicious application from gaining read or write access to another app's files.

**Sensitive data stored in clear-text**

- **Shared preferences**: Android 允许每个应用很容易地在路径 `/data/data/<packagename>/shared_prefs/` 中保存 xml 文件，有时可以在该文件夹中发现以明文存储的敏感信息。
- **Databases**: Android 允许每个应用很容易地在路径 `/data/data/<packagename>/databases/` 中保存 sqlite 数据库，有时可以在该文件夹中发现以明文存储的敏感信息。

### Broken TLS

**Accept All Certificates**

出于某些原因，开发者有时会接受所有证书，即使例如 hostname 不匹配，也会使用类似以下的代码行：
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### 不安全的加密

**Poor Key Management Processes**

有些开发者会将敏感数据保存在本地存储，并用硬编码/可预测的密钥在代码中进行加密。这样做不应该被允许，因为一些逆向工程可能让攻击者提取机密信息。

**Use of Insecure and/or Deprecated Algorithms**

开发者不应使用**deprecated algorithms**来执行授权**checks**、**存储**或**发送**数据。这些算法包括：RC4、MD4、MD5、SHA1... 例如如果使用**hashes**来存储密码，应该使用抗**brute-force**的hash算法并加salt。

### 其他检查

- 建议对 **APK** 进行**obfuscate**，以增加逆向工程难度。
- 如果应用是敏感类（例如银行应用），它应该自行**检测设备是否已 root**并据此采取措施。
- 如果应用是敏感类（例如银行应用），它应该检测是否在**emulator**上运行。
- 如果应用是敏感类（例如银行应用），它应该**在执行前自检完整性**以确认是否被修改。
- 使用 [**APKiD**](https://github.com/rednaga/APKiD) 检查用于构建 APK 的编译器/packer/obfuscator。

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

The tool [**mariana-trench**](https://github.com/facebook/mariana-trench) is capable of finding **vulnerabilities** by **scanning** the **code** of the application. This tool contains a series of **known sources** (that indicates to the tool the **places** where the **input** is **controlled by the user**), **sinks** (which indicates to the tool **dangerous** **places** where malicious user input could cause damages) and **rules**. These rules indicates the **combination** of **sources-sinks** that indicates a vulnerability.

With this knowledge, **mariana-trench will review the code and find possible vulnerabilities on it**.

### Secrets leaked

应用可能包含秘密（API keys、密码、隐藏的 urls、子域名等），你可能能够在应用中发现它们。你可以使用诸如 [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks) 的工具。

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> First of all, you need an environment where you can install the application and all the environment (Burp CA cert, Drozer and Frida mainly). Therefore, a rooted device (emulated or not) is extremely recommended.

### Online Dynamic analysis

你可以在以下网站创建一个**免费账号**： [https://appetize.io/](https://appetize.io/)。该平台允许你**上传**并**执行**APK，便于查看 apk 的运行行为。

你甚至可以在网页上**查看应用的日志**并通过 **adb** 连接。

![](<../../images/image (831).png>)

借助 ADB 连接，你可以在模拟器中使用 **Drozer** 和 **Frida**。

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio)（你可以创建 **x86** 和 **arm** 设备，根据[**this**](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html) 最新信息，**最新 x86** 版本 **支持 ARM 库**，无需使用缓慢的 arm 模拟器）。
- 在此页面中学习如何设置：


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **（免费版本：Personal Edition，需要创建账户。建议下载带有**VirtualBox**的版本以避免潜在错误。）**
- [**Nox**](https://es.bignox.com)（免费，但不支持 Frida 或 Drozer）。

> [!TIP]
> 在任何平台上创建新的 emulator 时请记住，屏幕越大，模拟器运行越慢。因此尽量选择较小屏幕。

要在 Genymotion 中**安装 google services（如 Play Store）**，需要点击下图中标红的按钮：

![](<../../images/image (277).png>)

另外，请注意在 **Genymotion 的 Android VM 配置** 中可以选择 **Bridge Network mode**（如果你会从不同的 VM 连接到该 Android VM 并使用工具，这将很有用）。

#### Use a physical device

你需要激活 **debugging** 选项，如果能 **root** 设备会更好：

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> 一旦安装了应用，第一件事应该是运行它并调查它的行为，弄清它如何工作并熟悉它。\
> 我建议使用 MobSF dynamic analysis + pidcat 来执行这一步初始的动态分析，这样我们可以在 MobSF **捕获**大量以后可以查看的**有趣**数据的同时**学习应用的工作原理**。

### Unintended Data Leakage

**Logging**

开发者应谨慎避免公开暴露**调试信息**，因为这可能导致敏感数据泄露。建议使用工具 [**pidcat**](https://github.com/JakeWharton/pidcat) 和 `adb logcat` 来监控应用日志，以识别并保护敏感信息。**Pidcat** 因其易用性和可读性而受推荐。

> [!WARNING]
> 注意，从 **Android 4.0 之后的较新版本** 起，**应用只能访问自己的日志**。因此应用无法访问其他应用的日志。\
> 不管怎样，仍建议**不要记录敏感信息**。

**Copy/Paste Buffer Caching**

Android 的**基于剪贴板**的框架支持复制粘贴功能，但存在风险：**其他应用**可以**访问**剪贴板，可能导致敏感数据泄露。对于敏感区域（如信用卡信息）务必**禁用复制/粘贴**功能以防止数据泄露。

**Crash Logs**

如果应用**崩溃**并**保存日志**，这些日志可能帮助攻击者，尤其是在应用无法被逆向时。为减轻风险，避免在崩溃时记录敏感信息；若必须将日志通过网络发送，确保通过 SSL 通道传输以保障安全。

作为 pentester，**尝试查看这些日志**。

**Analytics Data Sent To 3rd Parties**

应用常集成第三方服务（如 Google Adsense），若实现不当可能会无意中**泄露敏感数据**。要识别潜在的数据泄露，建议**拦截应用流量**并检查是否将敏感信息发送给第三方服务。

### SQLite DBs

大多数应用会使用**internal SQLite databases**来保存信息。在渗透测试时，查看创建的**数据库**、**表名**和**列名**以及保存的所有**数据**非常重要，因为你可能会发现**敏感信息**（这将是一种漏洞）。\
数据库通常位于 `/data/data/the.package.name/databases`，例如 `/data/data/com.mwr.example.sieve/databases`

如果数据库保存了机密信息并且**加密了**，但你可以在应用中**找到**该数据库的**密码**，那仍然是一个**漏洞**。

使用 `.tables` 枚举表，并使用 `.schema <table_name>` 枚举表的列。

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer is s useful tool to **exploit exported activities, exported services and Content Providers** as you will learn in the following sections.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Also remember that the code of an activity starts in the **`onCreate`** method.

**Authorisation bypass**

When an Activity is exported you can invoke its screen from an external app. Therefore, if an activity with **sensitive information** is **exported** you could **bypass** the **authentication** mechanisms **to access it.**

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

You can also start an exported activity from adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**注意**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> 注意，authorisation bypass 并不总是一个漏洞，这取决于绕过的实现方式以及暴露了哪些信息。

**Sensitive information leakage**

**Activities can also return results**。如果你设法找到一个被导出且未受保护的 activity，调用 **`setResult`** 方法并 **返回敏感信息**，则会发生 sensitive information leakage。

#### Tapjacking

If Tapjacking isn't prevented, you could abuse the exported activity to make the **user perform unexpected actions**。For more info about [**what is Tapjacking follow the link**](#tapjacking)。

### Exploiting Content Providers - 访问和操作敏感信息

[**如果你想回顾什么是 Content Provider，请阅读此处。**](android-applications-basics.md#content-provider)\
Content providers 基本上用于 **share data**。如果一个 app 有可用的 content providers，你可能能够从中 **extract sensitive** 数据。也有必要测试可能的 **SQL injections** 和 **Path Traversals**，因为它们可能存在漏洞。

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**如果你想回顾什么是 Service，请阅读此处。**](android-applications-basics.md#services)\
记住，Service 的动作从方法 `onStartCommand` 开始。

As service 基本上是可以 **接收数据**、**处理** 并（或不）**返回** 响应的东西。因此，如果一个应用导出了某些 services，你应该 **检查** 其 **code** 以了解其行为，并 **动态** 测试以提取机密信息、绕过认证措施等。\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**如果你想回顾什么是 Broadcast Receiver，请阅读此处。**](android-applications-basics.md#broadcast-receivers)\
记住，Broadcast Receiver 的动作从方法 `onReceive` 开始。

A broadcast receiver 会等待某种类型的消息。取决于 receiver 如何处理该消息，它可能存在漏洞。\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

You can look for deep links manually, using tools like MobSF or scripts like [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
You can **open** a declared **scheme** using **adb** or a **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_注意你可以**省略包名**，移动设备会自动调用应打开该链接的应用。_
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**执行的代码**

为了找到应用中**将被执行的代码**，转到由 deep link 调用的 activity 并搜索函数 **`onNewIntent`**。

![](<../../images/image (436) (1) (1) (1).png>)

**敏感信息**

每次发现 deep link 时，请检查 **它没有通过 URL 参数接收敏感数据（比如密码）**，因为任何其他应用都可能 **冒充该 deep link 并窃取这些数据！**

**路径中的参数**

你**必须检查 deep link 是否在 URL 的路径中使用参数**，例如：`https://api.example.com/v1/users/{username}`，在这种情况下，你可以通过访问类似 `example://app/users?username=../../unwanted-endpoint%3fparam=value` 来强制进行路径遍历。\
注意，如果你在应用中找到了正确的端点，你可能能够导致 **Open Redirect**（如果路径的一部分被用作域名）、**account takeover**（如果你能在没有 CSRF token 的情况下修改用户详情并且 vuln 端点使用了正确的方法）以及其他任何 vuln。更多 [info about this here](http://dphoeniixx.com/2020/12/13-2/)。

**More examples**

一个关于链接（_/.well-known/assetlinks.json_）的 [interesting bug bounty report](https://hackerone.com/reports/855618)。

### 传输层检查与验证失败

- **证书并不总是被正确检查**，在 Android 应用中很常见。这些应用常常忽略警告并接受自签名证书，或者在某些情况下退回使用 HTTP 连接。
- **SSL/TLS 握手期间的协商有时较弱**，使用不安全的密码套件。此漏洞使连接容易受到中间人（MITM）攻击，允许攻击者解密数据。
- **Leakage of private information** 是一个风险，当应用使用安全通道进行认证，但随后在其他事务中通过非安全通道通信时会出现这种情况。这种做法无法保护敏感数据，例如会话 cookie 或用户详情，免遭恶意实体拦截。

#### 证书验证

我们将重点关注**certificate verification**。必须验证服务器证书的完整性以增强安全性。这一点至关重要，因为不安全的 TLS 配置以及在未加密通道上传输敏感数据可能带来重大风险。关于验证服务器证书和修复漏洞的详细步骤，请参阅 [**this resource**](https://manifestsecurity.com/android-application-security-part-10/)。

#### SSL Pinning

SSL Pinning 是一种安全措施，应用将服务器证书与存储在应用内的已知副本进行校验。此方法对于防止 MITM 攻击至关重要。强烈建议在处理敏感信息的应用中实现 SSL Pinning。

#### Traffic Inspection

要检查 HTTP 流量，必须**安装代理工具的证书**（例如 Burp）。如果不安装该证书，加密流量可能无法通过代理可见。关于安装自定义 CA 证书的指南，请 [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine)。

针对 **API Level 24 and above** 的应用需要修改 Network Security Config 以接受代理的 CA 证书。此步骤对检查加密流量至关重要。有关修改 Network Security Config 的说明，请参阅 [**refer to this tutorial**](make-apk-accept-ca-certificate.md)。

如果使用 **Flutter**，你需要遵循 [**this page**](flutter.md) 中的说明。这是因为仅将证书添加到存储中并不能奏效，Flutter 有自己的有效 CA 列表。

#### 静态检测 SSL/TLS pinning

在尝试运行时绕过之前，先快速映射 APK 中强制 pinning 的位置。静态发现有助于你规划 hooks/patches 并关注正确的代码路径。

Tool: SSLPinDetect
- 开源静态分析工具，会将 APK 反编译为 Smali（通过 apktool）并扫描针对 SSL/TLS pinning 实现的精心挑选的正则模式。
- 为每个匹配报告精确的文件路径、行号和代码片段。
- 覆盖常见框架和自定义代码路径：OkHttp CertificatePinner、custom javax.net.ssl.X509TrustManager.checkServerTrusted、SSLContext.init（带 custom TrustManagers/KeyManagers）和 Network Security Config XML pins。

安装
- 先决条件: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
用法
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
示例模式规则 (JSON)

使用或扩展 signatures 来检测专有/自定义 pinning 样式。你可以加载自己的 JSON 并进行大规模 scan。
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
笔记与提示
- 通过多线程和 memory-mapped I/O 对大型应用进行快速扫描；预编译的 regex 可减少开销/误报。
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- 常见的检测目标，作为下一步优先排查：
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- 声明式 pins 在 res/xml network security config 和 manifest 引用中
- 使用匹配到的位置来规划 Frida hooks、静态 patch 或配置审查，然后再做动态测试。



#### 绕过 SSL Pinning

当实现了 SSL Pinning 时，绕过它对检查 HTTPS 流量变得必要。有多种方法可以做到这一点：

- 自动地 **modify** the **apk** 来 **bypass** SSLPinning，可以使用 [**apk-mitm**](https://github.com/shroudedcode/apk-mitm)。此选项最大的优点是你不需要 root 即可绕过 SSL Pinning，但你需要删除应用并重装新的，而且并不总是有效。
- 你可以使用 **Frida**（下文讨论）来绕过该保护。这里有一篇使用 Burp+Frida+Genymotion 的指南： [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- 你也可以尝试使用 [**objection**](frida-tutorial/objection-tutorial.md)**:** 自动绕过 SSL Pinning：`objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- 你也可以尝试使用 **MobSF dynamic analysis** 自动绕过 SSL Pinning（下文会解释）
- 如果你仍然认为有些流量没有被捕获，可以尝试使用 iptables 将流量转发到 Burp。阅读这篇博客： [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### 查找常见的 Web 漏洞

同样重要的是在应用内搜索常见的 Web 漏洞。识别和缓解这些漏洞的详细信息超出本摘要范围，但在其他地方有详尽的覆盖。

### Frida

[Frida](https://www.frida.re) 是一个面向开发者、逆向工程师和安全研究人员的动态插桩工具包。\
**你可以访问正在运行的应用并在运行时 hook 方法以改变行为、修改值、提取值或执行不同的代码……**\
如果你要对 Android 应用做 pentest，你需要会使用 Frida。

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Some "GUI" for actions with Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- You can find some Awesome Frida scripts here: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Try to bypass anti-debugging / anti-frida mechanisms loading Frida as in indicated in [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

检查应用是否在内存中存储了不应该存放的敏感信息，比如密码或助记词。

Using [**Fridump3**](https://github.com/rootbsd/fridump3) you can dump the memory of the app with:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
这会将内存转储到 ./dump 文件夹，你可以在其中使用 grep 之类的命令进行搜索：
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Keystore 中的敏感数据**

在 Android 中，Keystore 是存储敏感数据的最佳位置，然而在拥有足够权限的情况下仍然**可能被访问**。由于应用通常倾向于在此处以**明文**存储敏感数据，pentests 应当以 root user 身份检查它，否则有物理访问设备的人可能会窃取这些数据。

即使应用将数据存储在 Keystore 中，也应该对这些数据进行加密。

要访问 Keystore 内的数据，可以使用此 Frida 脚本： [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

使用以下 Frida 脚本，可能可以**bypass fingerprint authentication**，用于绕过 Android 应用为**保护某些敏感区域**而执行的身份验证：
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **后台快照**

当你将应用置于后台时，Android 会存储一个**应用快照**，这样当它恢复到前台时，会先加载该图像，然后才加载应用本身，从而看起来应用加载更快。

然而，如果该快照包含**敏感信息**，有权限访问该快照的人可能会**窃取这些信息**（注意你需要 root 才能访问它）。

快照通常存储在：**`/data/system_ce/0/snapshots`**

Android 提供了一种通过设置 **FLAG_SECURE** 布局参数来防止截图的方法。使用此标志后，窗口内容将被视为受保护，从而阻止其出现在截图中或在非安全的显示设备上被查看。
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

这个工具可以帮助你在动态分析期间管理不同的工具： [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

开发者经常创建代理组件（如 activities、services 和 broadcast receivers）来处理这些 Intents，并将它们传递给像 `startActivity(...)` 或 `sendBroadcast(...)` 这样的函数，这可能存在风险。

危险在于允许攻击者通过误导这些 Intents 来触发未导出的应用组件或访问敏感的内容提供者。一个显著的例子是 `WebView` 组件通过 `Intent.parseUri(...)` 将 URL 转换为 `Intent` 对象并执行它们，这可能导致恶意 Intent 注入。

### Essential Takeaways

- **Intent Injection** 类似于 web 的 Open Redirect 问题。
- 漏洞利用通常涉及将 `Intent` 对象作为 extras 传递，这些 Intent 可被重定向以执行不安全的操作。
- 它可能使未导出的组件和内容提供者暴露给攻击者。
- `WebView` 将 URL 转换为 `Intent` 的行为可能促成非预期的操作。

### Android Client Side Injections and others

你可能从 Web 上了解过这类漏洞。在 Android 应用中需要特别注意这些漏洞：

- **SQL Injection:** 在处理动态查询或 Content-Providers 时，请确保使用参数化查询。
- **JavaScript Injection (XSS):** 验证任何 WebViews 的 JavaScript 和 Plugin 支持已被禁用（默认禁用）。 [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** 应禁用 WebViews 对文件系统的访问（默认启用） - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: 在某些情况下，当 android 应用结束会话时，cookie 未被撤销，甚至可能被保存到磁盘
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Static analysis**

![](<../../images/image (866).png>)

**Vulnerability assessment of the application** 使用一个漂亮的基于 web 的前端。你也可以执行动态分析（但需要准备环境）。
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Assisted Dynamic analysis with MobSF

MobSF 在 Android 的动态分析上也非常有用，但在这种情况下你需要在宿主机上安装 MobSF 和 **genymotion**（VM 或 Docker 无法工作）。_Note: You need to **start first a VM in genymotion** and **then MobSF.**_\ 
MobSF 的动态分析器可以：

- **Dump application data**（URLs、logs、剪贴板、你手动截取的 screenshots、由 "**Exported Activity Tester**" 生成的 screenshots、emails、SQLite 数据库、XML 文件以及其他生成的文件）。除了 screenshots 以外，其它都会自动完成；screenshots 需要你在想要截图时按下相应按钮，或者按下 "**Exported Activity Tester**" 以获取所有 exported activities 的 screenshots。
- 捕获 **HTTPS traffic**
- 使用 **Frida** 获取 **runtime** **information**

从 Android **versions > 5**，它会**自动启动 Frida**并设置全局**proxy**以**capture**流量。它只会捕获受测应用的流量。

**Frida**

默认情况下，它还会使用一些 Frida Scripts 来**bypass SSL pinning**、**root detection** 和 **debugger detection**，并**monitor interesting APIs**。\
MobSF 还可以**invoke exported activities**，抓取它们的 **screenshots** 并将其**save** 到报告中。

要**start** 动态测试，按绿色按钮：“Start Instrumentation”。按 “Frida Live Logs” 可以查看由 Frida scripts 生成的日志，按 “Live API Monitor” 可以查看对 hooked methods 的所有调用、传入参数和返回值（在按下 “Start Instrumentation” 后会出现）。\
MobSF 还允许你加载自定义的 **Frida scripts**（要将你的 Frida scripts 的结果发送到 MobSF，请使用函数 `send()`）。它也有若干预写脚本可供加载（你可以在 `MobSF/DynamicAnalyzer/tools/frida_scripts/others/` 中添加更多），只需选择它们，按 “Load”，然后按 “Start Instrumentation”（你将能在 “Frida Live Logs” 中看到这些脚本的日志）。

![](<../../images/image (419).png>)

此外，你还有一些辅助性的 Frida 功能：

- **Enumerate Loaded Classes**: 它会打印所有已加载的 classes
- **Capture Strings**: 在使用应用时它会打印所有捕获到的 strings（非常嘈杂）
- **Capture String Comparisons**: 非常有用。它会**show the 2 strings being compared**，并显示结果是 True 还是 False。
- **Enumerate Class Methods**: 输入类名（例如 "java.io.File"），它会打印该类的所有方法。
- **Search Class Pattern**: 按模式搜索 classes
- **Trace Class Methods**: **Trace** 整个 class（查看该类所有方法的输入和输出）。请记住默认情况下 MobSF 会跟踪若干有趣的 Android Api 方法。

一旦你选择了要使用的辅助模块，按下 “Start Intrumentation”，你将在 “Frida Live Logs” 中看到所有输出。

**Shell**

Mobsf 还在动态分析页面底部提供了一个 shell，包含一些 **adb** 命令、**MobSF commands** 和常见的 **shell commands**。一些有趣的命令：
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP tools**

当 HTTP 流量被 capture 时，你可以在“**HTTP(S) Traffic**”按钮看到捕获流量的粗糙视图，或在绿色的“**Start HTTPTools**”按钮看到更友好的视图。通过第二个选项，你可以将**captured requests** 发送到像 Burp 或 Owasp ZAP 这样的 proxies。\
为此，_power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> 按“**Send to Fuzzer**” --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080))。

一旦用 MobSF 完成 dynamic analysis，你可以点击“**Start Web API Fuzzer**”来 **fuzz http requests** 并查找漏洞。

> [!TIP]
> 在用 MobSF 执行 dynamic analysis 之后，proxy 设置可能会被错误配置，并且你可能无法通过 GUI 修复。你可以通过执行以下命令来修复 proxy 设置：
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

你可以从 [**Inspeckage**](https://github.com/ac-pm/Inspeckage) 获取此工具。\
该工具会使用一些 **Hooks**，在你执行 **dynamic analysis** 时让你了解应用内发生的情况。

### [Yaazhini](https://www.vegabird.com/yaazhini/)

这是一个用于通过 GUI 执行 **static analysis** 的优秀工具

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

该工具旨在查找若干 **security related Android application vulnerabilities**，可针对 **source code** 或 **packaged APKs**。该工具还**能够创建可部署的 "Proof-of-Concept" APK** 和 **ADB commands**，以利用发现的一些漏洞（如 Exposed activities、intents、tapjacking...）。与 Drozer 相同，无需对测试设备进行 root。
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- 显示所有提取的文件以便参考
- 自动将 APK 文件反编译为 Java 和 Smali 格式
- 分析 AndroidManifest.xml 以查找常见漏洞和行为
- 对静态源代码进行分析以查找常见漏洞和行为
- 设备信息
- 以及更多
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER 是一个命令行应用，可在 Windows、MacOS X 和 Linux 上使用，用于分析 _.apk_ 文件以查找漏洞。

它通过解压 APK 并应用一系列规则来检测这些漏洞。

所有规则集中在 `rules.json` 文件中，每家公司或测试人员都可以创建自己的规则来分析所需内容。

从 [download page](https://superanalyzer.rocks/download.html) 下载最新的二进制文件
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn 是一个 **跨平台** 工具，可帮助开发人员、bugbounty hunters 和 ethical hackers 在移动应用上执行 [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis)。

其概念是将你的移动应用文件（.apk 或 .ipa 文件）拖放到 StaCoAn 应用上，StaCoAn 会为你生成一份可视化且可携带的报告。你可以调整设置和 wordlists 以获得定制化的体验。

Download[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework 是一个 Android 漏洞分析系统，帮助开发者或黑客发现 Android 应用中的潜在安全漏洞。\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** 是一个工具，主要用于检测并提醒用户有关 Android 应用可能的潜在恶意行为。

检测是通过对应用的 Dalvik bytecode（以 **Smali** 表示）进行 **static analysis**，并使用 [`androguard`](https://github.com/androguard/androguard) 库来完成的。

该工具查找 **“坏”应用的常见行为**，例如：Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** 是一个 **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework。它将常用的移动应用逆向与分析工具整合在一起，帮助针对 OWASP mobile security threats 测试移动应用。其目标是让这项工作对移动应用开发者和安全专业人员更简单、更友好。

它可以：

- 使用不同的工具提取 Java 和 Smali 代码
- Analyze APKs using: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- 使用 regexp 从 APK 中提取私有信息。
- 分析 Manifest。
- Analyze found domains using: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- 通过 [apk-deguard.com](http://www.apk-deguard.com) 进行 Deobfuscate APK

### Koodous

Useful to detect malware: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

注意，取决于你用来混淆代码的服务和配置，Secrets 可能会被混淆，也可能不会被混淆。

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** 是一个开源命令行工具，用于压缩、优化和混淆 Java 代码。它能够优化字节码并检测和移除未使用的指令。ProGuard 是自由软件，按照 GNU General Public License 第2版发布。

ProGuard 随 Android SDK 一起分发，并在以 release 模式构建应用时运行。

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) 上一次我们检查时，Dexguard 的运行模式是：

- 将资源作为 InputStream 加载；
- 将结果传递给继承自 FilterInputStream 的类以进行解密；
- 做一些无用的混淆以浪费逆向人员几分钟的时间；
- 将解密后的结果传递给 ZipInputStream 以获取 DEX 文件；
- 最后使用 `loadDex` 方法将生成的 DEX 作为 Resource 加载。

### [DeGuard](http://apk-deguard.com)

**DeGuard 逆转了由 Android 混淆工具执行的混淆过程。这样可以进行许多安全分析，包括代码检查和库预测。**

你可以将混淆的 APK 上传到他们的平台。

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

它是一个 **通用的 android deobfuscator。** Simplify **几乎是执行应用** 来理解其行为，然后 **尝试优化代码**，使其行为保持一致但更易于人类理解。每种优化类型都很简单且通用，所以不管使用了哪种具体的混淆方式，都能起作用。

### [APKiD](https://github.com/rednaga/APKiD)

APKiD 会告诉你 **一个 APK 是如何构建的**。它能识别许多 **compilers**, **packers**, **obfuscators** 以及其他奇怪的东西。它是 Android 的 [_PEiD_]。

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b 是一个基于 ubuntu-mate 的 Android security 虚拟机，包含来自不同安全极客和研究人员的最新 framework、tutorials 和 labs，用于 reverse engineering 和 malware analysis。

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) 它是一个很好的资源列表
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android 快速课程
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)

## Yet to try

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
