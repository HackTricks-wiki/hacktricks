# Android-Anwendungen Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android Applications Basics

Es wird dringend empfohlen, diese Seite zuerst zu lesen, um die **wichtigsten Teile im Zusammenhang mit Android-Sicherheit und die gefährlichsten Komponenten in einer Android-Anwendung** kennenzulernen:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

This is the main tool you need to connect to an android device (emulated or physical).\
**ADB** ermöglicht die Steuerung von Geräten entweder über **USB** oder **Network** von einem Computer aus. Dieses Tool erlaubt das **Kopieren** von Dateien in beide Richtungen, die **Installation** und **Deinstallation** von Apps, die **Ausführung** von Shell-Befehlen, das **Sichern** von Daten, das **Lesen** von Logs, sowie andere Funktionen.

Sieh dir die folgende Liste der [**ADB Commands**](adb-commands.md) an, um zu lernen, wie man adb benutzt.

## Smali

Manchmal ist es interessant, den **Anwendungscode zu modifizieren**, um auf **versteckte Informationen** zuzugreifen (z. B. stark obfuskierte Passwörter oder Flags). Dann kann es sinnvoll sein, die APK zu dekompilieren, den Code zu ändern und die APK neu zu kompilieren.\
[**In diesem Tutorial** kannst du **lernen, wie man eine APK dekompiliert, Smali code modifiziert und die APK mit der neuen Funktionalität neu kompiliert**](smali-changes.md). Dies kann sehr nützlich als **Alternative für mehrere Tests während der dynamischen Analyse** sein, die vorgestellt werden. Behalte diese Möglichkeit also **immer im Hinterkopf**.

## Other interesting tricks

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **APKs herunterladen**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- APK vom Gerät extrahieren:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Alle Splits und base apks mit [APKEditor](https://github.com/REAndroid/APKEditor) zusammenführen:
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Android Enterprise & Work Profile Angriffe

{{#ref}}
android-enterprise-work-profile-bypass.md
{{#endref}}

## Fallstudien & Schwachstellen


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Statische Analyse

Zuerst sollten Sie zum Analysieren einer APK **den Java-Code ansehen** und dazu einen Decompiler verwenden.\
Bitte [**lesen Sie hier, um Informationen über verschiedene verfügbare Decompiler zu finden**](apk-decompilers.md).

### Nach interessanten Informationen suchen

Schon durch das Betrachten der **strings** der APK können Sie nach **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** und allem Interessanten suchen... achten Sie sogar auf Code-Execution **backdoors** oder Authentifizierungs-Backdoors (hartkodierte Admin-Zugangsdaten in der App).

**Firebase**

Achten Sie besonders auf **firebase URLs** und prüfen Sie, ob diese schlecht konfiguriert sind. [Mehr Informationen darüber, was Firebase ist und wie man es ausnutzen kann, finden Sie hier.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Grundlegendes Verständnis der Anwendung - Manifest.xml, strings.xml

Die **Untersuchung der _Manifest.xml_ und der **_strings.xml_** Dateien einer Anwendung kann potenzielle Sicherheitslücken aufdecken**. Auf diese Dateien kann mit Decompilern zugegriffen werden oder indem die APK-Endung in .zip geändert und entpackt wird.

**Schwachstellen**, die aus der **Manifest.xml** identifiziert werden können, umfassen:

- **Debuggable-Anwendungen**: Anwendungen, die in der _Manifest.xml_ als debuggable (`debuggable="true"`) gesetzt sind, stellen ein Risiko dar, da sie Verbindungen erlauben, die zu einer Ausnutzung führen können. Für ein tieferes Verständnis, wie man debuggable-Anwendungen ausnutzt, siehe Tutorials zum Finden und Ausnutzen von debuggable-Anwendungen auf einem Gerät.
- **Backup-Einstellungen**: Das Attribut `android:allowBackup="false"` sollte explizit für Anwendungen gesetzt werden, die mit sensiblen Informationen arbeiten, um unautorisierten Daten-Backup via adb zu verhindern, besonders wenn USB-Debugging aktiviert ist.
- **Netzwerksicherheit**: Benutzerdefinierte network security Konfigurationen (`android:networkSecurityConfig="@xml/network_security_config"`) in _res/xml/_ können Sicherheitsdetails wie certificate pins und HTTP-Traffic-Einstellungen spezifizieren. Ein Beispiel ist das Zulassen von HTTP-Traffic für bestimmte Domains.
- **Exported Activities und Services**: Das Identifizieren von exportierten Activities und Services im Manifest kann Komponenten aufzeigen, die missbraucht werden könnten. Weitere Analyse während dynamischer Tests kann aufdecken, wie diese Komponenten ausgenutzt werden können.
- **Content Providers und FileProviders**: Offen gelegte Content Providers könnten unbefugten Zugriff oder Modifikation von Daten erlauben. Auch die Konfiguration von FileProviders sollte genau geprüft werden.
- **Broadcast Receivers und URL-Schemes**: Diese Komponenten könnten für Exploits genutzt werden, wobei besonderes Augenmerk darauf liegen sollte, wie URL-Schemes Eingaben behandeln.
- **SDK-Versionen**: Die Attribute `minSdkVersion`, `targetSDKVersion` und `maxSdkVersion` geben die unterstützten Android-Versionen an und unterstreichen die Bedeutung, veraltete, verwundbare Android-Versionen nicht zu unterstützen.

Aus der **strings.xml** Datei können sensible Informationen wie API keys, custom schemas und andere Entwicklerhinweise entdeckt werden, was die Notwendigkeit einer sorgfältigen Überprüfung dieser Ressourcen betont.

### Tapjacking

**Tapjacking** ist ein Angriff, bei dem eine **malicious** **application** gestartet wird und **sich über eine Opfer-Anwendung legt**. Sobald sie die Opfer-App sichtbar überdeckt, ist ihre Benutzeroberfläche so gestaltet, dass der Benutzer dazu verleitet wird, mit ihr zu interagieren, während die Interaktion an die Opfer-App weitergereicht wird.\
Im Effekt wird der Benutzer **davon abgehalten zu erkennen, dass er eigentlich Aktionen in der Opfer-App ausführt**.

Mehr Informationen finden Sie in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Eine **activity** mit dem **`launchMode`** auf **`singleTask` ohne definierte `taskAffinity`** ist für Task Hijacking anfällig. Das bedeutet, dass eine **application** installiert werden kann und, wenn sie vor der echten Anwendung gestartet wird, **den Task der echten Anwendung kapern** könnte (so wird der Benutzer mit der **malicious application interagieren und denken, er benutzt die echte**).

Mehr Infos in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Unsichere Datenspeicherung

**Interner Speicher**

In Android sind Dateien, die im **internal** storage abgelegt werden, so konzipiert, dass sie ausschließlich von der **app**, die sie erstellt hat, **zugänglich** sind. Diese Sicherheitsmaßnahme wird vom Android-Betriebssystem durchgesetzt und ist in der Regel ausreichend für die Sicherheitsanforderungen der meisten Anwendungen. Entwickler nutzen jedoch manchmal Modi wie `MODE_WORLD_READABLE` und `MODE_WORLD_WRITABLE`, um Dateien zwischen verschiedenen Anwendungen zu **teilen**. Diese Modi **beschränken den Zugriff** auf diese Dateien jedoch nicht gegenüber anderen Anwendungen, einschließlich potenziell bösartiger.

1. **Statische Analyse:**
- **Stellen Sie sicher**, dass die Verwendung von `MODE_WORLD_READABLE` und `MODE_WORLD_WRITABLE` **sorgfältig geprüft** wird. Diese Modi **können Dateien unbeabsichtigt oder unautorisiert offenlegen**.
2. **Dynamische Analyse:**
- **Überprüfen** Sie die **Berechtigungen** auf Dateien, die von der App erstellt wurden. Prüfen Sie speziell, ob Dateien **für alle les- oder schreibbar** gesetzt wurden. Dies kann ein erhebliches Sicherheitsrisiko darstellen, da **jede installierte Anwendung**, unabhängig von Herkunft oder Absicht, diese Dateien **lesen oder verändern** könnte.

**Externer Speicher**

Beim Umgang mit Dateien auf **external storage**, wie z. B. SD-Karten, sollten bestimmte Vorsichtsmaßnahmen getroffen werden:

1. **Zugänglichkeit**:
- Dateien auf external storage sind **global les- und schreibbar**. Das bedeutet, jede Anwendung oder jeder Benutzer kann auf diese Dateien zugreifen.
2. **Sicherheitsbedenken**:
- Aufgrund der leichten Zugänglichkeit sollte **keine sensiblen Informationen** auf external storage gespeichert werden.
- Externer Speicher kann entfernt oder von jeder Anwendung eingesehen werden, was ihn weniger sicher macht.
3. **Umgang mit Daten aus externem Speicher**:
- Führen Sie immer **Input-Validierung** für Daten durch, die aus externem Speicher geladen werden. Das ist entscheidend, da die Daten aus einer untrusted Quelle stammen.
- Das Speichern von ausführbaren Dateien oder class files auf externem Speicher zum dynamischen Nachladen wird stark abgeraten.
- Wenn Ihre Anwendung ausführbare Dateien aus externem Speicher laden muss, stellen Sie sicher, dass diese Dateien **signiert und kryptographisch verifiziert** sind, bevor sie dynamisch geladen werden. Dieser Schritt ist wesentlich, um die Sicherheitsintegrität Ihrer Anwendung zu wahren.

External storage kann in /storage/emulated/0 , /sdcard , /mnt/sdcard zugegriffen werden

> [!TIP]
> Starting with Android 4.4 (**API 17**), the SD card has a directory structure which **limits access from an app to the directory which is specifically for that app**. This prevents malicious application from gaining read or write access to another app's files.

**Sensitive data stored in clear-text**

- **Shared preferences**: Android erlaubt jeder Anwendung, XML-Dateien im Pfad `/data/data/<packagename>/shared_prefs/` zu speichern, und manchmal lassen sich dort sensitive Informationen im Klartext finden.
- **Databases**: Android erlaubt jeder Anwendung, sqlite-Datenbanken im Pfad `/data/data/<packagename>/databases/` zu speichern, und manchmal lassen sich dort sensitive Informationen im Klartext finden.

### Fehlerhaftes TLS

**Accept All Certificates**

Aus irgendwelchen Gründen akzeptieren Entwickler manchmal alle Zertifikate, selbst wenn z. B. der Hostname nicht übereinstimmt, mit Codezeilen wie der folgenden:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Eine gute Möglichkeit, dies zu testen, ist zu versuchen, den Traffic mit einem Proxy wie Burp abzufangen, ohne das Burp CA im Gerät zu autorisieren. Außerdem können Sie mit Burp ein Zertifikat für einen anderen Hostnamen erzeugen und verwenden.

### Fehlerhafte Kryptographie

**Schlechte Prozesse zur Schlüsselverwaltung**

Einige Entwickler speichern sensible Daten im lokalen Speicher und verschlüsseln sie mit einem im Code hardcodierten/vorhersehbaren Schlüssel. Das sollte nicht gemacht werden, da Reverse-Engineering Angreifern erlauben könnte, die vertraulichen Informationen zu extrahieren.

**Verwendung unsicherer und/oder veralteter Algorithmen**

Entwickler sollten keine **veralteten Algorithmen** für Autorisierungs**prüfungen**, **Speicherung** oder **Übertragung** von Daten verwenden. Einige dieser Algorithmen sind: RC4, MD4, MD5, SHA1... Wenn **hashes** z. B. zum Speichern von Passwörtern verwendet werden, sollten brute-force-resistente **hashes** mit **salt** verwendet werden.

### Weitere Prüfungen

- Es wird empfohlen, die **APK zu obfuskieren**, um die Arbeit des Reverse-Engineerings für Angreifer zu erschweren.
- Wenn die App sensibel ist (z. B. Banking-Apps), sollte sie eigene **Prüfungen durchführen, ob das Mobilgerät gerootet** ist, und entsprechend reagieren.
- Wenn die App sensibel ist (z. B. Banking-Apps), sollte sie prüfen, ob ein **Emulator** verwendet wird.
- Wenn die App sensibel ist (z. B. Banking-Apps), sollte sie **ihre Integrität vor der Ausführung prüfen**, um festzustellen, ob sie modifiziert wurde.
- Verwenden Sie [**APKiD**](https://github.com/rednaga/APKiD), um zu prüfen, welcher Compiler/Packer/Obfuscator zum Erstellen der APK verwendet wurde

### React Native Application

Lies die folgende Seite, um zu lernen, wie man einfach auf den JavaScript-Code von React-Anwendungen zugreift:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Lies die folgende Seite, um zu lernen, wie man einfach auf C#-Code einer Xamarin-Anwendung zugreift:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

Laut diesem [**Blogpost**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) ist superpacked ein Meta-Algorithmus, der den Inhalt einer Anwendung in eine einzelne Datei komprimiert. Der Blog beschreibt die Möglichkeit, eine App zu erstellen, die diese Art von Apps dekomprimiert... und einen schnelleren Weg, der darin besteht, **die Anwendung auszuführen und die dekomprimierten Dateien vom Dateisystem zu sammeln.**

### Automated Static Code Analysis

Das Tool [**mariana-trench**](https://github.com/facebook/mariana-trench) ist in der Lage, **Vulnerabilities** zu finden, indem es den **Code** der Anwendung **scannt**. Dieses Tool enthält eine Reihe von **known sources** (die dem Tool die **Stellen** anzeigen, an denen die **Eingabe** vom Benutzer **kontrolliert** wird), **sinks** (die dem Tool **gefährliche** **Stellen** anzeigen, an denen bösartige Benutzereingaben Schaden verursachen könnten) und **rules**. Diese Regeln geben die **Kombination** von **sources-sinks** an, die auf eine Verwundbarkeit hinweist.

Mit diesem Wissen wird **mariana-trench den Code prüfen und mögliche Vulnerabilities darin finden**.

### Secrets leaked

Eine Anwendung kann Secrets (API keys, Passwörter, versteckte URLs, Subdomains...) enthalten, die Sie möglicherweise entdecken können. Sie könnten ein Tool wie [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks) verwenden.

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)
- In-memory native code execution via JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamische Analyse

> Zuerst benötigen Sie eine Umgebung, in der Sie die Anwendung und die gesamte Umgebung (Burp CA cert, Drozer und Frida hauptsächlich) installieren können. Daher wird ein gerootetes Gerät (emuliert oder nicht) dringend empfohlen.

### Online Dynamic analysis

Sie können ein **kostenloses Konto** unter: [https://appetize.io/](https://appetize.io) erstellen. Diese Plattform erlaubt es Ihnen, **APKs hochzuladen** und **auszuführen**, sodass sie nützlich ist, um zu sehen, wie sich eine APK verhält.

Sie können sogar **die Logs Ihrer Anwendung im Web sehen** und sich über **adb** verbinden.

![](<../../images/image (831).png>)

Dank der ADB-Verbindung können Sie **Drozer** und **Frida** innerhalb der Emulatoren verwenden.

### Lokale dynamische Analyse

#### Verwendung eines Emulators

- [**Android Studio**](https://developer.android.com/studio) (Sie können **x86**- und **arm**-Geräte erstellen, und laut [**diesem**](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html) **unterstützen aktuelle x86**-Versionen **ARM-Bibliotheken**, ohne einen langsamen ARM-Emulator zu benötigen).
- Lernen Sie, es auf dieser Seite einzurichten:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(kostenlose Version:** Personal Edition, Sie müssen ein Konto erstellen. _Es wird empfohlen, die Version **MIT**_ _**VirtualBox** herunterzuladen, um potenzielle Fehler zu vermeiden._)
- [**Nox**](https://es.bignox.com) (kostenlos, unterstützt jedoch Frida oder Drozer nicht).

> [!TIP]
> Wenn Sie einen neuen Emulator auf einer beliebigen Plattform erstellen, denken Sie daran: Je größer der Bildschirm ist, desto langsamer läuft der Emulator. Wählen Sie also wenn möglich kleine Bildschirme.

Um **Google Services** (wie AppStore) in Genymotion zu **installieren**, müssen Sie auf den rot markierten Button im folgenden Bild klicken:

![](<../../images/image (277).png>)

Beachten Sie außerdem, dass Sie in der **Konfiguration der Android-VM in Genymotion** den **Bridge Network mode** auswählen können (das ist nützlich, wenn Sie von einer anderen VM aus auf die Android-VM mit den Tools zugreifen möchten).

#### Verwendung eines physischen Geräts

Sie müssen die **Entwicklungsoptionen (Developer options)** aktivieren; es ist außerdem sinnvoll, wenn Sie es **rooten** können:

1. **Settings**.
2. (Ab Android 8.0) Wählen Sie **System**.
3. Wählen Sie **About phone**.
4. Drücken Sie **Build number** 7-mal.
5. Gehen Sie zurück und Sie finden die **Developer options**.

> Sobald Sie die Anwendung installiert haben, sollten Sie sie zuerst ausprobieren und untersuchen, was sie tut, wie sie funktioniert und sich damit vertraut machen.\
> Ich empfehle, **diese anfängliche dynamische Analyse mit MobSF dynamic analysis + pidcat** durchzuführen, damit wir **lernen, wie die Anwendung funktioniert**, während MobSF viele **interessante** **Daten** erfasst, die Sie später überprüfen können.

Magisk/Zygisk quick notes (recommended on Pixel devices)
- Patch boot.img with the Magisk app and flash via fastboot to get systemless root
- Enable Zygisk + DenyList for root hiding; consider LSPosed/Shamiko when stronger hiding is required
- Keep original boot.img to recover from OTA updates; re-patch after each OTA
- For screen mirroring, use scrcpy on the host

### Unintended Data Leakage

**Logging**

Entwickler sollten vorsichtig sein, DEBUG-Informationen öffentlich zugänglich zu machen, da dies zu sensitiven data leaks führen kann. Die Tools [**pidcat**](https://github.com/JakeWharton/pidcat) und `adb logcat` werden empfohlen, um Anwendungslogs zu überwachen und sensible Informationen zu identifizieren und zu schützen. **Pidcat** wird wegen seiner Benutzerfreundlichkeit und Lesbarkeit bevorzugt.

> [!WARNING]
> Beachten Sie, dass ab **neueren Versionen als Android 4.0** **Anwendungen nur noch auf ihre eigenen Logs zugreifen können**. Anwendungen können also nicht auf die Logs anderer Apps zugreifen.\
> Trotzdem wird weiterhin empfohlen, **keine sensiblen Informationen zu loggen**.

**Copy/Paste Buffer Caching**

Das **clipboard-basierte** Framework von Android ermöglicht Copy-Paste-Funktionalität in Apps, birgt jedoch das Risiko, dass **andere Anwendungen** auf die Zwischenablage zugreifen und dadurch sensible Daten exponieren können. Es ist wichtig, Copy/Paste-Funktionen für sensitive Bereiche einer Anwendung, wie Kreditkartendaten, zu **deaktivieren**, um Data Leaks zu verhindern.

**Crash Logs**

Wenn eine Anwendung **crasht** und **Logs speichert**, können diese Logs Angreifern helfen, insbesondere wenn die Anwendung nicht reverse-engineered werden kann. Um dieses Risiko zu mindern, vermeiden Sie Logging bei Crashes, und wenn Logs über das Netzwerk gesendet werden müssen, sorgen Sie dafür, dass sie über einen SSL-Kanal übertragen werden.

Als Pentester, **sehen Sie sich diese Logs an**.

**Analytics Data Sent To 3rd Parties**

Anwendungen integrieren häufig Dienste wie Google Adsense, die aufgrund fehlerhafter Implementierung durch Entwickler versehentlich **sensitive data** an Dritte senden können. Um mögliche Datenlecks zu erkennen, empfiehlt es sich, den Traffic der Anwendung abzufangen und zu prüfen, ob sensible Informationen an Third-Party-Services gesendet werden.

### SQLite DBs

Die meisten Anwendungen verwenden **interne SQLite-Datenbanken**, um Informationen zu speichern. Schauen Sie während des Pentests in die erstellten **Datenbanken**, die Namen der **Tabellen** und **Spalten** sowie alle gespeicherten **Daten**, da Sie dort **sensitive Informationen** finden könnten (was eine Verwundbarkeit wäre).\
Datenbanken sollten sich in `/data/data/the.package.name/databases` befinden, z. B. `/data/data/com.mwr.example.sieve/databases`

Wenn die Datenbank vertrauliche Informationen speichert und **verschlüsselt** ist, Sie aber das **Passwort** innerhalb der Anwendung finden können, ist das immer noch eine **Vulnerabilität**.

Enumerieren Sie die Tabellen mit `.tables` und listen Sie die Spalten der Tabellen mit `.schema <table_name>` auf.

### Drozer (Exploit Activities, Content Providers and Services)

Aus den [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** erlaubt es Ihnen, **die Rolle einer Android-App anzunehmen** und mit anderen Apps zu interagieren. Es kann **alles tun, was eine installierte Anwendung tun kann**, wie z. B. Androids Inter-Process Communication (IPC)-Mechanismus nutzen und mit dem zugrunde liegenden Betriebssystem interagieren.\
Drozer ist ein nützliches Tool, um **exportierte activities, exportierte services und Content Providers auszunutzen**, wie Sie in den folgenden Abschnitten lernen werden.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Denken Sie auch daran, dass der Code einer Activity in der **`onCreate`**-Methode startet.

**Authorisation bypass**

Wenn eine Activity exportiert ist, können Sie ihren Screen von einer externen App aus aufrufen. Daher könnten Sie, wenn eine Activity mit **sensiblen Informationen** **exportiert** ist, die **Authentifizierungsmechanismen umgehen**, um darauf zuzugreifen.

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

Sie können eine exportierte Activity auch über adb starten:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**HINWEIS**: MobSF wird die Verwendung von _**singleTask/singleInstance**_ als `android:launchMode` in einer activity als bösartig erkennen, aber aufgrund von [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750) ist dies anscheinend nur auf alten Versionen (API-Versionen < 21) gefährlich.

> [!TIP]
> Note that an authorisation bypass is not always a vulnerability, it would depend on how the bypass works and which information is exposed.

**Sensitive information leakage**

**Activities can also return results**. Wenn du eine exportierte und ungeschützte activity findest, die die Methode **`setResult`** aufruft und **sensitive information** zurückgibt, liegt eine sensitive information leakage vor.

#### Tapjacking

Wenn Tapjacking nicht verhindert wird, könntest du die exportierte activity missbrauchen, damit der **Benutzer unerwartete Aktionen ausführt**. For more info about [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers werden grundsätzlich verwendet, um **share data**. Wenn eine App verfügbare Content providers hat, könntest du möglicherweise **extract sensitive** Daten daraus **extrahieren**. Es ist auch wichtig, mögliche **SQL injections** und **Path Traversals** zu testen, da diese verwundbar sein könnten.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Denke daran, dass die Aktionen eines Service in der Methode `onStartCommand` beginnen.

Ein Service ist im Grunde etwas, das **can receive data**, **process** it und **returns** (oder nicht) eine Antwort. Wenn eine Anwendung also Services exportiert, solltest du den **code** prüfen, um zu verstehen, was er tut, und ihn **dynamically** testen, um vertrauliche Informationen zu extrahieren, Authentifizierungsmaßnahmen zu umgehen...\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Denke daran, dass die Aktionen eines Broadcast Receiver in der Methode `onReceive` starten.

Ein broadcast receiver wartet auf eine bestimmte Art von Nachricht. Abhängig davon, wie der Receiver die Nachricht verarbeitet, könnte er verwundbar sein.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

You can look for deep links manually, using tools like MobSF or scripts like [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
You can **open** a declared **scheme** using **adb** or a **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Beachte, dass du **den Paketnamen weglassen kannst** und das Mobilgerät automatisch die App aufruft, die diesen Link öffnen sollte._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Code executed**

Um den **Code, der in der App ausgeführt wird**, zu finden, gehe zur Activity, die vom deeplink aufgerufen wird, und suche die Funktion **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Sensible Informationen**

Jedes Mal, wenn du einen deep link findest, prüfe, ob **er nicht sensible Daten (wie Passwörter) über URL-Parameter empfängt**, denn jede andere Anwendung könnte **den deep link impersonate und diese Daten stehlen!**

**Parameter im Pfad**

Du **musst auch prüfen, ob ein deep link einen Parameter innerhalb des Pfads** der URL verwendet, z. B.: `https://api.example.com/v1/users/{username}`. In diesem Fall kannst du eine Path Traversal erzwingen, indem du z. B. aufrufst: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Beachte, dass du, wenn du die korrekten Endpunkte in der Anwendung findest, möglicherweise eine **Open Redirect** (wenn ein Teil des Pfads als Domain-Name verwendet wird), eine **account takeover** (wenn du Benutzerdaten ohne CSRF token ändern kannst und der verwundbare Endpoint die richtige Methode verwendet) und andere Vulns verursachen kannst. More [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Transport Layer Inspection and Verification Failures

- **Certificates werden nicht immer korrekt von Android-Anwendungen überprüft.** Es ist üblich, dass diese Anwendungen Warnungen übersehen und self-signed certificates akzeptieren oder in einigen Fällen auf HTTP-Verbindungen zurückfallen.
- **Die Verhandlungen während des SSL/TLS-Handshakes sind manchmal schwach**, es werden unsichere Cipher-Suites verwendet. Diese Schwäche macht die Verbindung anfällig für MITM-Angriffe und ermöglicht Angreifern das Entschlüsseln der Daten.
- **Offenlegung privater Informationen** ist ein Risiko, wenn Anwendungen für Authentifizierung sichere Kanäle verwenden, dann aber für andere Transaktionen über nicht-gesicherte Kanäle kommunizieren. Dieser Ansatz schützt sensible Daten, wie Session-Cookies oder Benutzerdetails, nicht vor Abfangen durch bösartige Parteien.

#### Certificate Verification

Wir konzentrieren uns auf die **Certificate Verification**. Die Integrität des Server-Zertifikats muss verifiziert werden, um die Sicherheit zu erhöhen. Das ist entscheidend, da unsichere TLS-Konfigurationen und die Übertragung sensibler Daten über unverschlüsselte Kanäle erhebliche Risiken darstellen können. Für detaillierte Schritte zur Überprüfung von Server-Zertifikaten und zur Behebung von Schwachstellen bietet [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) umfassende Anleitungen.

#### SSL Pinning

SSL Pinning ist eine Sicherheitsmaßnahme, bei der die Anwendung das Server-Zertifikat mit einer bekannten Kopie vergleicht, die innerhalb der Anwendung gespeichert ist. Diese Methode ist essentiell, um MITM-Angriffe zu verhindern. Die Implementierung von SSL Pinning wird dringend für Anwendungen empfohlen, die sensible Informationen verarbeiten.

#### Traffic Inspection

Um HTTP-Traffic zu inspizieren, ist es nötig, das Zertifikat des Proxy-Tools (z. B. Burp) zu **installieren**. Ohne die Installation dieses Zertifikats ist verschlüsselter Traffic möglicherweise nicht über den Proxy sichtbar. Für eine Anleitung zum Installieren eines custom CA-Zertifikats, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Anwendungen mit Ziel-API Level **24 and above** erfordern Änderungen an der Network Security Config, um das CA-Zertifikat des Proxys zu akzeptieren. Dieser Schritt ist wichtig, um verschlüsselten Traffic zu inspizieren. Für Anweisungen zur Änderung der Network Security Config, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

Wenn **Flutter** verwendet wird, musst du den Anweisungen auf [**this page**](flutter.md) folgen. Das liegt daran, dass das einfache Hinzufügen des Zertifikats zum Store nicht ausreicht, da Flutter seine eigene Liste gültiger CAs hat.

#### Static detection of SSL/TLS pinning

Bevor du Runtime-Bypässe versuchst, kartiere schnell, wo Pinning im APK durchgesetzt wird. Statische Erkennung hilft dir, Hooks/Patches zu planen und dich auf die richtigen Code-Pfade zu konzentrieren.

Tool: SSLPinDetect
- Open-source static-analysis utility, das das APK nach Smali dekompiliert (via apktool) und nach kuratierten Regex-Patterns von SSL/TLS pinning Implementierungen scannt.
- Reportet exakten Dateipfad, Zeilennummer und einen Code-Snippet für jeden Treffer.
- Deckt gängige Frameworks und custom code paths ab: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init mit custom TrustManagers/KeyManagers, und Network Security Config XML pins.

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Verwendung
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Beispiel-Pattern-Regeln (JSON)
Verwenden oder erweitern Sie signatures, um proprietäre/custom pinning styles zu erkennen. Sie können Ihr eigenes JSON laden und scan at scale.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes and tips
- Schnelles Scannen großer Apps via Multithreading und memory-mapped I/O; vor-kompilierte regex reduziert Overhead/Falsch-Positive.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Typische Erkennungsziele zur weiteren Priorisierung:
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Declarative pins in res/xml network security config and manifest references
- Verwende die gefundenen Stellen, um Frida hooks, statische Patches oder Konfigurationsprüfungen vor dynamischen Tests zu planen.



#### Bypassing SSL Pinning

Wenn SSL Pinning implementiert ist, wird es nötig, dieses zu umgehen, um HTTPS-Traffic zu untersuchen. Dafür gibt es verschiedene Methoden:

- Automatically **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Der größte Vorteil dieser Option ist, dass du kein root brauchst, um SSL Pinning zu umgehen, allerdings musst du die Anwendung löschen und die neue Version installieren, und es funktioniert nicht immer.
- You could use **Frida** (discussed below) to bypass this protection. Hier ist eine Anleitung, um Burp+Frida+Genymotion zu verwenden: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- You can also try to **automatically bypass SSL Pinning** using [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- You can also try to **automatically bypass SSL Pinning** using **MobSF dynamic analysis** (explained below)
- If you still think that there is some traffic that you aren't capturing you can try to **forward the traffic to burp using iptables**. Read this blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Looking for Common Web Vulnerabilities

Es ist wichtig, innerhalb der Anwendung auch nach häufigen Web-Schwachstellen zu suchen. Detaillierte Informationen zur Identifikation und Behebung dieser Schwachstellen gehen über diese Zusammenfassung hinaus, werden aber anderswo ausführlich behandelt.

### Frida

[Frida](https://www.frida.re) ist ein dynamisches Instrumentierungs-Toolkit für Entwickler, Reverse-Engineers und Sicherheitsforscher.\
**Du kannst auf laufende Anwendungen zugreifen und Methoden zur Laufzeit hooken, um Verhalten zu ändern, Werte zu ändern, Werte zu extrahieren, anderen Code auszuführen...**\
Wenn du Android-Anwendungen pentesten willst, musst du wissen, wie man Frida benutzt.

- Lerne, wie man Frida benutzt: [**Frida tutorial**](frida-tutorial/index.html)
- Einige "GUI" für Aktionen mit Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection ist großartig, um die Verwendung von Frida zu automatisieren: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Du findest einige Awesome Frida scripts hier: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Versuche, Anti-Debugging / Anti-Frida-Mechanismen zu umgehen, indem du Frida wie in folgender Anleitung lädst: [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (Tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

Überprüfe, ob die Anwendung sensible Informationen im Speicher ablegt, die dort nicht liegen sollten, wie Passwörter oder mnemonics.

Mit [**Fridump3**](https://github.com/rootbsd/fridump3) kannst du den Speicher der App auslesen mit:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Das wird das memory in ./dump dumpen, und dort könntest du mit etwas wie grep suchen:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Sensible Daten im Keystore**

Auf Android ist der Keystore der beste Ort, um sensible Daten zu speichern; mit ausreichenden Rechten ist es jedoch immer noch **möglich, darauf zuzugreifen**. Da Anwendungen dazu neigen, hier **sensible Daten im Klartext** zu speichern, sollten pentests dies als root user prüfen, da jemand mit physischem Zugriff auf das Gerät diese Daten stehlen könnte.

Selbst wenn eine App Daten im Keystore speichert, sollten diese Daten verschlüsselt sein.

Um auf die Daten im Keystore zuzugreifen, kann man dieses Frida script verwenden: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Mit dem folgenden Frida-Skript könnte es möglich sein, die von Android-Anwendungen möglicherweise durchgeführte **bypass fingerprint authentication** zu umgehen, um **bestimmte sensible Bereiche zu schützen:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Hintergrundbilder**

Wenn Sie eine Anwendung in den Hintergrund legen, speichert Android einen **Snapshot der Anwendung**, sodass beim Wiederherstellen in den Vordergrund zuerst das Bild geladen wird, bevor die App startet, wodurch es so aussieht, als wäre die App schneller geladen worden.

Wenn dieser Snapshot jedoch **sensible Informationen** enthält, könnte jemand mit Zugriff auf den Snapshot diese Informationen **stehlen** (beachte, dass man dafür root benötigt).

Die Snapshots befinden sich normalerweise unter: **`/data/system_ce/0/snapshots`**

Android bietet eine Möglichkeit, die **Erfassung des Screenshots durch Setzen des FLAG_SECURE** Layout-Parameters zu verhindern. Durch die Verwendung dieses Flags werden die Fensterinhalte als sicher behandelt, wodurch verhindert wird, dass sie in Screenshots erscheinen oder auf nicht sicheren Displays angezeigt werden.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Dieses Tool kann Ihnen helfen, verschiedene Tools während der dynamischen Analyse zu verwalten: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Entwickler erstellen oft Proxy-Komponenten wie activities, services und broadcast receivers, die diese Intents verarbeiten und an Methoden wie `startActivity(...)` oder `sendBroadcast(...)` weiterreichen, was riskant sein kann.

Die Gefahr besteht darin, Angreifern zu erlauben, nicht-exportierte App-Komponenten auszulösen oder durch Fehlleitung dieser Intents auf sensitive Content-Provider zuzugreifen. Ein bemerkenswertes Beispiel ist die `WebView`-Komponente, die URLs via `Intent.parseUri(...)` in `Intent`-Objekte umwandelt und diese dann ausführt, was potenziell zu bösartigen Intent-Injektionen führen kann.

### Essential Takeaways

- **Intent Injection** ist ähnlich wie das Open Redirect-Problem im Web.
- Exploits beinhalten das Weitergeben von `Intent`-Objekten als Extras, die umgeleitet werden können, um unsichere Operationen auszuführen.
- Es kann nicht-exportierte Komponenten und Content-Provider für Angreifer öffnen.
- Die URL-zu-`Intent`-Konversion von `WebView` kann unbeabsichtigte Aktionen ermöglichen.

### Android Client Side Injections and others

Wahrscheinlich kennen Sie diese Art von vulnerabilities aus dem Web. Bei Android-Anwendungen müssen Sie bei diesen besonders vorsichtig sein:

- **SQL Injection:** Beim Umgang mit dynamischen Abfragen oder Content-Providern sollten Sie sicherstellen, dass parametrisierte Abfragen verwendet werden.
- **JavaScript Injection (XSS):** Stellen Sie sicher, dass JavaScript- und Plugin-Unterstützung für alle WebViews deaktiviert ist (standardmäßig deaktiviert). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews sollten keinen Zugriff auf das Dateisystem haben (standardmäßig erlaubt) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: In mehreren Fällen wird beim Beenden der Android-Anwendung das Cookie nicht widerrufen oder es kann sogar auf der Festplatte gespeichert werden
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatische Analyse

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Statische Analyse**

![](<../../images/image (866).png>)

**Vulnerability assessment of the application** mithilfe eines ansprechenden webbasierten Frontends. Sie können auch eine dynamische Analyse durchführen (aber Sie müssen die Umgebung vorbereiten).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Beachte, dass MobSF **Android**(apk)**, IOS**(ipa) **und Windows**(apx) Anwendungen analysieren kann (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Außerdem, wenn du eine **ZIP**-Datei mit dem Quellcode einer **Android**- oder **IOS**-App erstellst (gehe in den Root-Ordner der Applikation, wähle alles aus und erstelle eine ZIPfile), kann es diese ebenfalls analysieren.

MobSF erlaubt außerdem, **diff/Compare** Analysen und die Integration von **VirusTotal** (du musst deinen API-Schlüssel in _MobSF/settings.py_ setzen und es aktivieren: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). Du kannst `VT_UPLOAD` auch auf `False` setzen, dann wird der **hash** statt der Datei **upload**.

### Assisted Dynamic analysis with MobSF

**MobSF** kann auch sehr hilfreich für **dynamische Analyse** in **Android** sein, aber in diesem Fall musst du MobSF und **genymotion** auf deinem Host installieren (eine VM oder Docker funktioniert nicht). _Hinweis: Du musst **zuerst eine VM in genymotion starten** und **dann MobSF.**_\
Der **MobSF dynamic analyser** kann:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). All of this is done automatically except for the screenshots, you need to press when you want a screenshot or you need to press "**Exported Activity Tester**" to obtain screenshots of all the exported activities.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

Ab Android **versions > 5** wird es **automatisch Frida starten** und globale **proxy**-Einstellungen setzen, um den Traffic zu **capture**n. Es wird nur Traffic der getesteten Applikation erfassen.

**Frida**

Standardmäßig verwendet es auch einige Frida Scripts, um **SSL pinning** zu **bypass**en, **root detection** und **debugger detection** zu umgehen und um interessante APIs zu **monitor**en.\
MobSF kann außerdem **invoke exported activities**, Screenshots davon machen und sie für den Report **save**n.

Um das dynamische Testing zu **start**en, drücke den grünen Button: "**Start Instrumentation**". Drücke "**Frida Live Logs**", um die von den Frida scripts erzeugten Logs zu sehen, und "**Live API Monitor**", um alle Aufrufe zu gehookten Methoden, übergebene Argumente und Rückgabewerte zu sehen (dies erscheint nach dem Drücken von "Start Instrumentation").\
MobSF erlaubt es dir auch, eigene **Frida scripts** zu laden (um die Ergebnisse deiner Frida scripts an MobSF zu senden, benutze die Funktion `send()`). Es hat auch **several pre-written scripts**, die du laden kannst (du kannst weitere in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/` hinzufügen), wähle sie einfach aus, drücke "**Load**" und dann "**Start Instrumentation**" (du wirst die Logs dieser Scripts innerhalb von "**Frida Live Logs**" sehen können).

![](<../../images/image (419).png>)

Außerdem gibt es einige zusätzliche Frida-Funktionalitäten:

- **Enumerate Loaded Classes**: Es gibt alle geladenen Klassen aus
- **Capture Strings**: Es gibt alle capture strings während der Nutzung der Applikation aus (sehr noisy)
- **Capture String Comparisons**: Sehr nützlich. Es zeigt die 2 Strings, die verglichen wurden, und ob das Ergebnis True oder False war.
- **Enumerate Class Methods**: Gib den Klassennamen ein (z. B. "java.io.File") und es listet alle Methoden der Klasse auf.
- **Search Class Pattern**: Suche Klassen nach Pattern
- **Trace Class Methods**: **Trace** eine **ganze Klasse** (sieh Eingaben und Ausgaben aller Methoden der Klasse). Denk daran, dass MobSF standardmäßig mehrere interessante Android API-Methoden trace`t.

Sobald du das Auxiliary-Modul ausgewählt hast, das du verwenden möchtest, musst du "**Start Intrumentation**" drücken und du wirst alle Ausgaben in "**Frida Live Logs**" sehen.

**Shell**

MobSF bringt dir außerdem eine Shell mit einigen **adb** commands, **MobSF commands**, und gängigen **shell** **commands** am unteren Rand der dynamic analysis Seite. Einige interessante Befehle:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP tools**

Wenn HTTP-Verkehr erfasst wird, kannst du eine unübersichtliche Ansicht des erfassten Verkehrs im "**HTTP(S) Traffic**" Bottom sehen oder eine schönere Ansicht im grünen Button "**Start HTTPTools**". Über die zweite Option kannst du die **captured requests** an **proxies** wie Burp oder Owasp ZAP **senden**.\
Dazu _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> press "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Sobald du die dynamische Analyse mit MobSF abgeschlossen hast, kannst du auf "**Start Web API Fuzzer**" klicken, um **HTTP-Requests zu fuzzen** und nach Schwachstellen zu suchen.

> [!TIP]
> Nach einer dynamischen Analyse mit MobSF können die Proxy-Einstellungen fehlerhaft sein und lassen sich nicht über die GUI korrigieren. Du kannst die Proxy-Einstellungen so zurücksetzen:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

Du kannst das Tool von [**Inspeckage**](https://github.com/ac-pm/Inspeckage) beziehen.\
Dieses Tool nutzt einige **Hooks**, um dir während einer **dynamischen Analyse** zu zeigen, **was in der Anwendung passiert**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Dies ist ein **großartiges Tool, um statische Analysen mit einer GUI durchzuführen**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Dieses Tool ist darauf ausgelegt, nach verschiedenen **security related Android application vulnerabilities** zu suchen, entweder im **source code** oder in **packaged APKs**. Das Tool ist außerdem **capable of creating a "Proof-of-Concept" deployable APK** und **ADB commands**, um einige der gefundenen Schwachstellen auszunutzen (Exposed activities, intents, tapjacking...). Wie bei Drozer ist es nicht nötig, das Testgerät zu rooten.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Zeigt alle extrahierten Dateien zur einfachen Referenz an
- Dekompiliert APK-Dateien automatisch in Java- und Smali-Format
- Analysiert AndroidManifest.xml auf häufige vulnerabilities und Verhalten
- Statische Quellcode-Analyse auf häufige vulnerabilities und Verhalten
- Geräteinformationen
- und mehr
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER ist eine Kommandozeilenanwendung, die unter Windows, MacOS X und Linux verwendet werden kann und _.apk_ Dateien auf der Suche nach Schwachstellen analysiert. Dazu entpackt sie APKs und wendet eine Reihe von Regeln an, um diese Schwachstellen zu erkennen.

Alle Regeln sind in einer `rules.json`-Datei zentralisiert. Unternehmen oder Tester können eigene Regeln erstellen, um gezielt zu analysieren.

Lade die neuesten Binärdateien von der [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn ist ein **crossplatform** Tool, das Entwickler, bugbounty hunters und ethical hackers bei der Durchführung von [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) an mobilen Anwendungen unterstützt.

Das Konzept ist, dass du deine mobile Anwendungsdatei (eine .apk- oder .ipa-Datei) per Drag & Drop auf die StaCoAn-Anwendung ziehst und sie einen visuellen und portablen Bericht für dich erstellt. Du kannst die Einstellungen und wordlists anpassen, um ein personalisiertes Erlebnis zu erhalten.

Herunterladen[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework ist ein Android-Schwachstellen-Analyse-System, das Entwicklern oder hackers hilft, potenzielle Sicherheitslücken in Android-Anwendungen zu finden.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** ist ein Tool, dessen Hauptziel es ist, potenziell bösartiges Verhalten einer Android-Anwendung zu erkennen und den Benutzer zu warnen.

Die Erkennung erfolgt durch die **static analysis** des Dalvik bytecode der Anwendung (dargestellt als **Smali**) mithilfe der [`androguard`](https://github.com/androguard/androguard) Bibliothek.

Dieses Tool sucht nach **häufigen Verhaltensweisen von "bösen" Anwendungen** wie: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** ist ein **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. Es ist ein Tool, das gängige Werkzeuge zur Reverse-Engineering- und Analyse von mobilen Applikationen zusammenführt, um bei Tests von mobilen Anwendungen gegen die OWASP mobile security threats zu unterstützen. Ziel ist es, diese Aufgabe für Mobile-Application-Entwickler und Security-Professionals einfacher und zugänglicher zu machen.

Es kann:

- Java- und Smali-Code mit verschiedenen Tools extrahieren
- APKs analysieren mit: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Private Informationen aus der APK mittels regulärer Ausdrücke extrahieren.
- Das Manifest analysieren.
- Gefundene Domains analysieren mit: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) und [whatweb](https://github.com/urbanadventurer/WhatWeb)
- APKs via [apk-deguard.com] deobfuskieren

### Koodous

Nützlich zur Erkennung von Malware: [https://koodous.com/](https://koodous.com/)

## Obfuskation/Deobfuskation von Code

Beachte, dass abhängig vom Dienst und der Konfiguration, die du zum Obfuskieren des Codes verwendest, Secrets möglicherweise obfuskiert sind oder nicht.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. It is able to optimize bytecode as well as detect and remove unused instructions. ProGuard is free software and is distributed under the GNU General Public License, version 2.

ProGuard wird als Teil des Android SDK verteilt und läuft beim Erstellen der Anwendung im Release-Modus.

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Last time we checked, the Dexguard mode of operation was:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

Du kannst ein obfuskiertes APK auf deren Plattform hochladen.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

It is a **generic android deobfuscator.** Simplify **virtually executes an app** to understand its behavior and then **tries to optimize the code** so it behaves identically but is easier for a human to understand. Each optimization type is simple and generic, so it doesn't matter what the specific type of obfuscation is used.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD gives you information about **how an APK was made**. It identifies many **compilers**, **packers**, **obfuscators**, and other weird stuff. It's [_PEiD_](https://www.aldeid.com/wiki/PEiD) for Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b ist eine Android security virtual machine auf ubuntu-mate-Basis und beinhaltet eine Sammlung der neuesten Frameworks, Tutorials und Labs von verschiedenen Security-Geeks und Forschern für reverse engineering und malware analysis.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Es ist eine großartige Liste von Ressourcen
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android Schnellkurs
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
