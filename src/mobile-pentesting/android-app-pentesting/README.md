# Pentesting de Aplicações Android

{{#include ../../banners/hacktricks-training.md}}

## Noções Básicas de Aplicações Android

É altamente recomendado começar lendo esta página para conhecer **as partes mais importantes relacionadas à segurança Android e os componentes mais perigosos em uma aplicação Android**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Esta é a principal ferramenta que você precisa para conectar a um dispositivo Android (emulado ou físico).\
**ADB** permite controlar dispositivos via **USB** ou **rede** a partir de um computador. Esta utilidade possibilita a **cópia** de arquivos em ambas as direções, **instalação** e **desinstalação** de apps, **execução** de comandos shell, **backup** de dados, **leitura** de logs, entre outras funções.

Dê uma olhada na lista a seguir de [**ADB Commands**](adb-commands.md) para aprender como usar o adb.

## Smali

Às vezes é interessante **modificar o código da aplicação** para acessar **informações ocultas** (talvez senhas bem ofuscadas ou flags). Então, pode ser interessante decompilar o apk, modificar o código e recompilar o apk.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Isso pode ser muito útil como **alternativa para vários testes durante a análise dinâmica** que serão apresentados. Portanto, mantenha sempre em mente essa possibilidade.

## Outras dicas interessantes

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **Baixar APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Extrair APK do dispositivo:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Mesclar todos os splits e base apks com [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Estudos de Caso & Vulnerabilidades


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Análise Estática

Antes de tudo, para analisar um APK você deve **dar uma olhada no código Java** usando um decompilador.\
Por favor, [**leia aqui para encontrar informação sobre diferentes decompiladores disponíveis**](apk-decompilers.md).

### Procurando informações interessantes

Apenas olhando as **strings** do APK você pode procurar por **senhas**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), chaves de **API**, **criptografia**, **bluetooth uuids**, **tokens** e qualquer coisa interessante... procure até por backdoors de execução de código ou backdoors de autenticação (credenciais admin hardcoded no app).

**Firebase**

Preste atenção especial às **firebase URLs** e verifique se está mal configurado. [Mais informações sobre o que é Firebase e como explorá-lo aqui.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Entendimento básico da aplicação - Manifest.xml, strings.xml

A **examinação dos arquivos _Manifest.xml_ e _strings.xml_ de uma aplicação pode revelar potenciais vulnerabilidades de segurança**. Esses arquivos podem ser acessados usando decompiladores ou renomeando a extensão do arquivo APK para .zip e então descompactando-o.

**Vulnerabilidades** identificadas no **Manifest.xml** incluem:

- **Debuggable Applications**: Aplicações marcadas como debuggable (`debuggable="true"`) no arquivo _Manifest.xml_ representam um risco, pois permitem conexões que podem levar à exploração. Para entender melhor como explorar aplicações debuggable, consulte um tutorial sobre encontrar e explorar aplicações debuggable em um dispositivo.
- **Backup Settings**: O atributo `android:allowBackup="false"` deve ser explicitamente definido para aplicações que lidam com informações sensíveis, para evitar backups de dados não autorizados via adb, especialmente quando usb debugging está habilitado.
- **Network Security**: Configurações customizadas de network security (`android:networkSecurityConfig="@xml/network_security_config"`) em _res/xml/_ podem especificar detalhes de segurança como certificate pins e configurações de tráfego HTTP. Um exemplo é permitir tráfego HTTP para domínios específicos.
- **Exported Activities and Services**: Identificar activities e services exportados no manifest pode destacar componentes que podem ser mal utilizados. Análises dinâmicas adicionais podem revelar como explorar esses componentes.
- **Content Providers and FileProviders**: Content providers expostos podem permitir acesso ou modificação não autorizada de dados. A configuração dos FileProviders também deve ser analisada cuidadosamente.
- **Broadcast Receivers and URL Schemes**: Esses componentes podem ser aproveitados para exploração, com atenção especial a como os URL schemes são gerenciados para vulnerabilidades de entrada.
- **SDK Versions**: Os atributos `minSdkVersion`, `targetSDKVersion`, e `maxSdkVersion` indicam as versões Android suportadas, ressaltando a importância de não suportar versões Android desatualizadas e vulneráveis por razões de segurança.

No arquivo **strings.xml**, informações sensíveis como chaves de API, schemas customizados e outras anotações de desenvolvedores podem ser descobertas, reforçando a necessidade de revisão cuidadosa desses recursos.

### Tapjacking

**Tapjacking** é um ataque onde uma **aplicação** **maliciosa** é executada e **se posiciona por cima de uma aplicação vítima**. Uma vez que obscurece visualmente a aplicação vítima, sua interface é desenhada de modo a enganar o usuário para interagir com ela, enquanto passa a interação para a aplicação vítima.\
Na prática, é **cegar o usuário para que ele não saiba que está realmente executando ações na aplicação vítima**.

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Uma **activity** com o **`launchMode`** definido para **`singleTask` sem qualquer `taskAffinity`** definida é vulnerável a Task Hijacking. Isso significa que uma **application** pode ser instalada e, se iniciada antes da aplicação real, poderia **hijackar a task da aplicação real** (fazendo com que o usuário interaja com a **aplicação maliciosa achando que está usando a aplicação real**).

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Armazenamento de dados inseguro

**Armazenamento Interno**

No Android, arquivos **armazenados** no armazenamento **interno** são **projetados** para serem **acessíveis** exclusivamente pela **aplicação** que os **criou**. Essa medida de segurança é **imposta** pelo sistema operacional Android e geralmente é adequada para as necessidades de segurança da maioria das aplicações. No entanto, desenvolvedores às vezes utilizam modos como `MODE_WORLD_READABLE` e `MODE_WORLD_WRITABLE` para **permitir** que arquivos sejam **compartilhados** entre diferentes aplicações. Ainda assim, esses modos **não restringem o acesso** a esses arquivos por outras aplicações, incluindo possíveis aplicações maliciosas.

1. **Static Analysis:**
- **Assegure-se** de que o uso de `MODE_WORLD_READABLE` e `MODE_WORLD_WRITABLE` seja **cuidadosamente analisado**. Esses modos **podem potencialmente expor** arquivos a **acesso não intencional ou não autorizado**.
2. **Dynamic Analysis:**
- **Verifique** as **permissões** definidas nos arquivos criados pelo app. Especificamente, **confirme** se algum arquivo está **definido como legível ou gravável mundialmente**. Isso pode representar um risco significativo de segurança, pois permitiria que **qualquer aplicação** instalada no dispositivo, independente de sua origem ou intenção, **leia ou modifique** esses arquivos.

**Armazenamento Externo**

Ao lidar com arquivos no **armazenamento externo**, como SD Cards, algumas precauções devem ser tomadas:

1. **Acessibilidade**:
- Arquivos no armazenamento externo são **globalmente legíveis e graváveis**. Isso significa que qualquer aplicação ou usuário pode acessar esses arquivos.
2. **Preocupações de Segurança**:
- Dada a facilidade de acesso, é aconselhável **não armazenar informações sensíveis** no armazenamento externo.
- O armazenamento externo pode ser removido ou acessado por qualquer aplicação, tornando-o menos seguro.
3. **Tratamento de Dados do Armazenamento Externo**:
- Sempre **realize validação de entrada** nos dados recuperados do armazenamento externo. Isso é crucial porque os dados são de uma fonte não confiável.
- Armazenar executáveis ou arquivos de classe no armazenamento externo para carregamento dinâmico é fortemente desencorajado.
- Se sua aplicação precisa recuperar arquivos executáveis do armazenamento externo, assegure que esses arquivos sejam **assinados e verificados criptograficamente** antes de serem carregados dinamicamente. Esse passo é vital para manter a integridade de segurança da sua aplicação.

External storage pode ser **acessado** em `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> A partir do Android 4.4 (**API 17**), o SD card possui uma estrutura de diretórios que **limita o acesso de uma app ao diretório específico daquela app**. Isso evita que aplicações maliciosas obtenham acesso de leitura ou escrita aos arquivos de outra app.

**Dados sensíveis armazenados em texto claro**

- **Shared preferences**: O Android permite que cada aplicação salve facilmente arquivos xml no caminho `/data/data/<packagename>/shared_prefs/` e às vezes é possível encontrar informações sensíveis em texto claro nessa pasta.
- **Databases**: O Android permite que cada aplicação salve facilmente bancos sqlite no caminho `/data/data/<packagename>/databases/` e às vezes é possível encontrar informações sensíveis em texto claro nessa pasta.

### Broken TLS

**Accept All Certificates**

Por algum motivo, às vezes desenvolvedores aceitam todos os certificados mesmo que, por exemplo, o hostname não corresponda, com linhas de código como a seguinte:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Uma boa maneira de testar isso é tentar capturar o tráfego usando um proxy como Burp sem autorizar o Burp CA dentro do dispositivo. Além disso, você pode gerar com Burp um certificado para um hostname diferente e usá-lo.

### Criptografia quebrada

**Processos de gerenciamento de chaves deficientes**

Alguns desenvolvedores salvam dados sensíveis no armazenamento local e os criptografam com uma chave hardcoded/predictable no código. Isso não deve ser feito, pois alguma engenharia reversa pode permitir que atacantes extraiam a informação confidencial.

**Uso de algoritmos inseguros e/ou depreciados**

Desenvolvedores não devem usar **deprecated algorithms** para realizar authorisation **checks**, **store** ou **send** dados. Alguns desses algoritmos são: RC4, MD4, MD5, SHA1... Se **hashes** forem usados para armazenar senhas, por exemplo, devem ser usados hashes brute-force **resistant** com salt.

### Outras verificações

- É recomendado **obfuscate the APK** para dificultar o trabalho de reverse engineer aos atacantes.
- Se o app for sensível (como apps bancários), deve perform it's **own checks to see if the mobile is rooted** e agir em consequência.
- Se o app for sensível (como apps bancários), deve verificar se um **emulator** está sendo usado.
- Se o app for sensível (como apps bancários), deve **check it's own integrity before executing** para verificar se foi modificado.
- Use [**APKiD**](https://github.com/rednaga/APKiD) para verificar qual compiler/packer/obfuscator foi usado para construir o APK

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. O blog trata da possibilidade de criar um app que descomprima esse tipo de apps... e de uma forma mais rápida que envolve executar a aplicação e recolher os ficheiros descomprimidos do sistema de arquivos.

### Automated Static Code Analysis

A ferramenta [**mariana-trench**](https://github.com/facebook/mariana-trench) é capaz de encontrar **vulnerabilidades** ao **scan** do **código** da aplicação. Esta ferramenta contém uma série de **known sources** (que indicam ao tool os **lugares** onde a **input** é **controlled by the user**), **sinks** (que indicam ao tool **lugares perigosos** onde entrada maliciosa do usuário poderia causar danos) e **rules**. Essas regras indicam a **combinação** de **sources-sinks** que aponta uma vulnerabilidade.

Com esse conhecimento, **mariana-trench irá revisar o código e encontrar possíveis vulnerabilidades nele**.

### Secrets leaked

Uma aplicação pode conter secrets (API keys, passwords, hidden urls, subdomains...) em seu interior que você pode conseguir descobrir. Você pode usar uma ferramenta como [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Análise Dinâmica

> Primeiro de tudo, você precisa de um ambiente onde possa instalar a aplicação e todo o ambiente (Burp CA cert, Drozer and Frida principalmente). Portanto, um dispositivo rooted (emulado ou não) é fortemente recomendado.

### Online Dynamic analysis

Você pode criar uma **free account** em: [https://appetize.io/](https://appetize.io). Esta plataforma permite que você **upload** e **execute** APKs, então é útil para ver como um apk está se comportando.

Você pode até **ver os logs da sua aplicação** na web e conectar-se através de **adb**.

![](<../../images/image (831).png>)

Graças à conexão ADB você pode usar **Drozer** e **Frida** dentro dos emuladores.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (Você pode criar dispositivos **x86** e **arm**, e de acordo com [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** versions **support ARM libraries** sem precisar de um emulador arm lento).
- Aprenda a configurá-lo nesta página:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, você precisa criar uma conta. _É recomendado **download** a versão **WITH** _**VirtualBox** para evitar potenciais erros._)
- [**Nox**](https://es.bignox.com) (Gratuito, mas não suporta Frida ou Drozer).

> [!TIP]
> Ao criar um novo emulador em qualquer plataforma, lembre-se de que quanto maior a tela, mais lento o emulador irá rodar. Portanto, selecione telas pequenas se possível.

Para **instalar google services** (como AppStore) no Genymotion você precisa clicar no botão marcado em vermelho na imagem a seguir:

![](<../../images/image (277).png>)

Também, note que na **configuração da VM Android no Genymotion** você pode selecionar **Bridge Network mode** (isso será útil se você for conectar na Android VM a partir de uma VM diferente com as ferramentas).

#### Use a physical device

Você precisa ativar as opções de **debugging** e será bom se você puder **root** o dispositivo:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Volte e você encontrará as **Developer options**.

> Uma vez que você tenha instalado a aplicação, a primeira coisa que deve fazer é testá-la e investigar o que ela faz, como funciona e familiarizar-se com ela.\
> Sugiro realizar esta análise dinâmica inicial usando MobSF dynamic analysis + pidcat, assim poderemos **learn how the application works** enquanto o MobSF **captures** muitos dados **interessantes** que você poderá revisar posteriormente.

Magisk/Zygisk quick notes (recommended on Pixel devices)
- Patch boot.img with the Magisk app and flash via fastboot to get systemless root
- Enable Zygisk + DenyList for root hiding; consider LSPosed/Shamiko when stronger hiding is required
- Keep original boot.img to recover from OTA updates; re-patch after each OTA
- For screen mirroring, use scrcpy on the host

### Unintended Data Leakage

**Logging**

Desenvolvedores devem ter cuidado ao expor **debugging information** publicamente, pois isso pode levar a leaks de dados sensíveis. As ferramentas [**pidcat**](https://github.com/JakeWharton/pidcat) e `adb logcat` são recomendadas para monitorar os logs da aplicação e identificar e proteger informações sensíveis. **Pidcat** é preferida por sua facilidade de uso e legibilidade.

> [!WARNING]
> Note que a partir de **later newer than Android 4.0**, **applications are only able to access their own logs**. Então aplicações não podem acessar os logs de outras apps.\
> De qualquer forma, ainda é recomendado **não logar informação sensível**.

**Copy/Paste Buffer Caching**

A framework baseada em **clipboard** do Android permite a funcionalidade de copiar/colar em apps, mas representa um risco já que **other applications** podem **access** a clipboard, potencialmente expondo dados sensíveis. É crucial **disable copy/paste** em seções sensíveis de uma aplicação, como dados de cartão de crédito, para prevenir leaks de dados.

**Crash Logs**

Se uma aplicação **crasha** e **salva logs**, esses logs podem auxiliar atacantes, especialmente quando a aplicação não pode ser reverse-engineered. Para mitigar esse risco, evite logar em crashes, e se logs precisarem ser transmitidos pela rede, assegure que sejam enviados via um canal SSL para segurança.

Como pentester, **tente dar uma olhada nesses logs**.

**Analytics Data Sent To 3rd Parties**

Aplicações frequentemente integram serviços como Google Adsense, que podem inadvertidamente **leak sensitive data** devido à implementação inadequada por parte dos desenvolvedores. Para identificar possíveis vazamentos, é aconselhável **interceptar o tráfego da aplicação** e checar por qualquer informação sensível sendo enviada a serviços de terceiros.

### SQLite DBs

A maioria das aplicações irá usar **internal SQLite databases** para salvar informações. Durante o pentest, dê uma **olhada** nos **databases** criados, nos nomes de **tables** e **columns** e em todos os **data** salvos porque você pode encontrar **informações sensíveis** (o que constituiria uma vulnerability).\
Os databases devem estar localizados em `/data/data/the.package.name/databases` como `/data/data/com.mwr.example.sieve/databases`

Se o database está salvando informação confidencial e está **encrypted** mas você consegue **find** a **password** dentro da aplicação, isso ainda é uma **vulnerability**.

Enumere as tabelas usando `.tables` e enumere as colunas das tabelas com `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer é uma ferramenta útil para **exploit exported activities, exported services and Content Providers** como você aprenderá nas seções seguintes.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Também lembre-se que o código de uma activity começa no método **`onCreate`**.

**Authorisation bypass**

Quando uma Activity está exportada você pode invocar sua tela a partir de um app externo. Portanto, se uma activity com **informação sensível** estiver **exported** você poderia **bypass** os mecanismos de **authentication** **to access it.**

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

Você também pode iniciar uma activity exportada a partir do adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF vai detectar como malicioso o uso de _**singleTask/singleInstance**_ como `android:launchMode` em uma activity, mas devido a [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), aparentemente isso é perigoso apenas em versões antigas (API versions < 21).

> [!TIP]
> Note que um authorisation bypass nem sempre é uma vulnerabilidade; isso depende de como o bypass funciona e quais informações são expostas.

**Vazamento de informações sensíveis**

Activities também podem retornar resultados. Se você conseguir encontrar uma activity exportada e desprotegida que chama o método **`setResult`** e retorna informações sensíveis, há um vazamento de informações sensíveis.

#### Tapjacking

Se o tapjacking não for prevenido, você pode abusar da activity exportada para fazer o usuário executar ações inesperadas. For more info about [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Acessando e manipulando informações sensíveis

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers são basicamente usados para **compartilhar dados**. Se um app tiver content providers disponíveis, você pode ser capaz de **extrair dados sensíveis** deles. Também é interessante testar possíveis **SQL injections** e **Path Traversals**, pois eles podem ser vulneráveis.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Lembre-se que as ações de um Service começam no método `onStartCommand`.

Um Service é basicamente algo que **pode receber dados**, **processá-los** e **retornar** (ou não) uma resposta. Então, se uma aplicação está exportando alguns services você deve **verificar** o **código** para entender o que ele está fazendo e **testá-lo** **dinamicamente** para extrair informações confidenciais, contornar medidas de autenticação...\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Lembre-se que as ações de um Broadcast Receiver começam no método `onReceive`.

Um broadcast receiver ficará aguardando um tipo de mensagem. Dependendo de como o receiver trata a mensagem, ele pode ser vulnerável.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Você pode procurar por deep links manualmente, usando ferramentas como MobSF ou scripts como [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Você pode **abrir** um **scheme** declarado usando **adb** ou um **navegador**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Observe que você pode **omitir o nome do pacote** e o dispositivo móvel chamará automaticamente o app que deve abrir esse link._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Código executado**

Para encontrar o **código que será executado no App**, vá para a activity chamada pelo deep link e procure a função **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Informação sensível**

Sempre que encontrar um deep link verifique se **ele não está recebendo dados sensíveis (como passwords) via parâmetros da URL**, porque qualquer outra aplicação poderia **se passar pelo deep link e roubar esses dados!**

**Parâmetros no path**

Você **também deve verificar se algum deep link está usando um parâmetro dentro do path** da URL, por exemplo: `https://api.example.com/v1/users/{username}`. Nesse caso você pode forçar um path traversal acessando algo como: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Note que se você encontrar os endpoints corretos dentro da aplicação pode ser capaz de causar um **Open Redirect** (se parte do path for usada como nome de domínio), **account takeover** (se você conseguir modificar detalhes de usuários sem CSRF token e o endpoint vulnerável usar o método correto) e qualquer outra vulnerabilidade. Mais [informações sobre isso aqui](http://dphoeniixx.com/2020/12/13-2/).

**Mais exemplos**

Um [relatório de bug bounty interessante](https://hackerone.com/reports/855618) sobre links (_/.well-known/assetlinks.json_).

### Inspeção da camada de transporte e falhas de verificação

- **Certificados nem sempre são inspecionados corretamente** por aplicações Android. É comum que essas aplicações ignorem avisos e aceitem certificados autoassinados ou, em algumas instâncias, revertam para conexões HTTP.
- **As negociações durante o handshake SSL/TLS às vezes são fracas**, empregando conjuntos de cifras inseguros. Essa vulnerabilidade torna a conexão suscetível a ataques MITM, permitindo que atacantes decifrem os dados.
- **Leakage of private information** é um risco quando aplicações se autenticam usando canais seguros mas depois se comunicam por canais não seguros para outras transações. Essa abordagem não protege dados sensíveis, como cookies de sessão ou detalhes de usuários, contra interceptação por entidades maliciosas.

#### Certificate Verification

Vamos focar na **verificação do certificado**. A integridade do certificado do servidor deve ser verificada para aumentar a segurança. Isso é crucial porque configurações TLS inseguras e a transmissão de dados sensíveis por canais não criptografados podem representar riscos significativos. Para passos detalhados sobre verificação de certificados de servidor e correção de vulnerabilidades, [**este recurso**](https://manifestsecurity.com/android-application-security-part-10/) fornece orientação abrangente.

#### SSL Pinning

SSL Pinning é uma medida de segurança onde a aplicação verifica o certificado do servidor contra uma cópia conhecida armazenada dentro da própria aplicação. Esse método é essencial para prevenir ataques MITM. Implementar SSL Pinning é fortemente recomendado para aplicações que lidam com informação sensível.

#### Traffic Inspection

Para inspecionar tráfego HTTP, é necessário **instalar o certificado da ferramenta proxy** (por exemplo, Burp). Sem instalar este certificado, o tráfego criptografado pode não ser visível através do proxy. Para um guia sobre como instalar um certificado CA customizado, [**clique aqui**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Aplicações com target em **API Level 24 and above** requerem modificações no Network Security Config para aceitar o certificado CA do proxy. Esta etapa é crítica para inspecionar tráfego criptografado. Para instruções sobre como modificar o Network Security Config, [**consulte este tutorial**](make-apk-accept-ca-certificate.md).

Se **Flutter** está sendo usado você precisa seguir as instruções em [**esta página**](flutter.md). Isso acontece porque apenas adicionar o certificado ao store não funcionará, já que Flutter tem sua própria lista de CAs válidas.

#### Static detection of SSL/TLS pinning

Antes de tentar bypasses em runtime, mapeie rapidamente onde o pinning é aplicado no APK. A descoberta estática ajuda a planejar hooks/patches e a focar nos caminhos de código corretos.

Tool: SSLPinDetect
- Open-source static-analysis utility that decompiles the APK to Smali (via apktool) and scans for curated regex patterns of SSL/TLS pinning implementations.
- Reports exact file path, line number, and a code snippet for each match.
- Covers common frameworks and custom code paths: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

Install
- Pré-requisitos: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Uso
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Exemplo de regras de padrão (JSON)
Use ou estenda signatures para detectar estilos de pinning proprietários/custom. Você pode carregar seu próprio JSON e scan em grande escala.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes and tips
- Escaneamento rápido em apps grandes via multi-threading e memory-mapped I/O; regex pré-compilado reduz overhead/falsos positivos.
- Coleção de padrões: https://github.com/aancw/smali-sslpin-patterns
- Alvos de detecção típicos para triagem a seguir:
- OkHttp: uso de CertificatePinner, setCertificatePinner, referências ao pacote okhttp3/okhttp
- TrustManagers personalizados: javax.net.ssl.X509TrustManager, sobrescritas de checkServerTrusted
- Contextos SSL personalizados: SSLContext.getInstance + SSLContext.init com gerenciadores personalizados
- Pins declarativos em res/xml network security config e referências no manifest
- Use os locais correspondentes para planejar Frida hooks, patches estáticos ou revisões de configuração antes dos testes dinâmicos.



#### Bypassando SSL Pinning

Quando SSL Pinning está implementado, contorná-lo torna-se necessário para inspecionar o tráfego HTTPS. Vários métodos estão disponíveis para esse propósito:

- Modify automaticamente o **apk** para contornar SSLPinning com [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). A maior vantagem dessa opção é que você não precisará de root para contornar o SSL Pinning, mas será necessário deletar o aplicativo e reinstalar o novo, e isso nem sempre funciona.
- Você pode usar **Frida** (discutido abaixo) para contornar essa proteção. Aqui há um guia para usar Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Você também pode tentar **contornar automaticamente o SSL Pinning** usando [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Você também pode tentar **contornar automaticamente o SSL Pinning** usando **MobSF dynamic analysis** (explicado abaixo)
- Se você ainda achar que há tráfego que não está capturando, pode tentar **encaminhar o tráfego para burp usando iptables**. Leia este blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Procurando por Vulnerabilidades Web Comuns

Também é importante procurar por vulnerabilidades web comuns dentro do aplicativo. Informações detalhadas sobre identificação e mitigação dessas vulnerabilidades estão além do escopo deste resumo, mas são amplamente abordadas em outros lugares.

### Frida

[Frida](https://www.frida.re) é um toolkit de instrumentação dinâmica para desenvolvedores, reverse-engineers e pesquisadores de segurança.\
**Você pode acessar a aplicação em execução e hookar métodos em tempo de execução para mudar o comportamento, alterar valores, extrair valores, executar código diferente...**\
Se você quer fazer pentest em aplicações Android, precisa saber como usar Frida.

- Aprenda a usar Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Algumas "GUI" para ações com Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection é ótima para automatizar o uso do Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Você pode encontrar alguns scripts Awesome para Frida aqui: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Tente contornar mecanismos anti-debugging / anti-frida carregando o Frida conforme indicado em [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (ferramenta [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & workflow de bypass de SSL pinning

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump de Memória - Fridump**

Verifique se a aplicação está armazenando informações sensíveis na memória que não deveria, como senhas ou mnemonics.

Usando [**Fridump3**](https://github.com/rootbsd/fridump3) você pode fazer dump da memória do app com:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Isso vai despejar a memória na pasta ./dump, e lá você pode usar grep com algo assim:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Dados sensíveis no Keystore**

No Android o Keystore é o melhor lugar para armazenar dados sensíveis, no entanto, com privilégios suficientes ainda é **possível acessá-lo**. Como as aplicações tendem a armazenar aqui **sensitive data in clear text**, os pentests devem verificar isso, pois um root user ou alguém com acesso físico ao dispositivo pode roubar esses dados.

Mesmo que um app armazene dados no keystore, os dados devem estar criptografados.

Para acessar os dados dentro do keystore você pode usar este Frida script: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Usando o seguinte script Frida, pode ser possível **bypass fingerprint authentication** que aplicações Android podem estar realizando para **proteger certas áreas sensíveis:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Imagens de Fundo**

Quando você coloca um aplicativo em background, o Android armazena um **snapshot of the application** para que, quando ele for restaurado para foreground, comece a carregar a imagem antes do aplicativo, fazendo parecer que o aplicativo foi carregado mais rapidamente.

No entanto, se esse snapshot contiver **informações sensíveis**, alguém com acesso ao snapshot pode **roubar essas informações** (observe que é necessário root para acessá-lo).

Os snapshots normalmente são armazenados em: **`/data/system_ce/0/snapshots`**

O Android disponibiliza uma forma de **prevenir a captura de screenshots definindo o parâmetro de layout FLAG_SECURE**. Ao usar essa flag, o conteúdo da janela é tratado como seguro, impedindo que apareça em screenshots ou que seja exibido em displays não seguros.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Esta ferramenta pode ajudá-lo a gerenciar diferentes ferramentas durante a análise dinâmica: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Desenvolvedores frequentemente criam componentes proxy, como activities, services e broadcast receivers, que manipulam esses Intents e os passam para métodos como `startActivity(...)` ou `sendBroadcast(...)`, o que pode ser arriscado.

O perigo está em permitir que atacantes acionem componentes da aplicação não exportados ou acessem content providers sensíveis ao redirecionar indevidamente esses Intents. Um exemplo notável é o componente `WebView` convertendo URLs em objetos `Intent` via `Intent.parseUri(...)` e então executando-os, potencialmente levando a injeções de Intent maliciosas.

### Essential Takeaways

- **Intent Injection** é similar ao problema Open Redirect da web.
- Explorações envolvem passar objetos `Intent` como extras, que podem ser redirecionados para executar operações inseguras.
- Pode expor componentes não exportados e content providers aos atacantes.
- A conversão de URLs para `Intent` do `WebView` pode facilitar ações não intencionais.

### Android Client Side Injections and others

Provavelmente você conhece esse tipo de vulnerabilidade da Web. É preciso ter especial cuidado com essas vulnerabilidades em uma aplicação Android:

- **SQL Injection:** Ao lidar com consultas dinâmicas ou Content-Providers, assegure-se de usar consultas parametrizadas.
- **JavaScript Injection (XSS):** Verifique se o suporte a JavaScript e a Plugins está desabilitado para quaisquer WebViews (desabilitado por padrão). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** O acesso ao sistema de arquivos pelos WebViews deve estar desabilitado (habilitado por padrão) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: Em vários casos, quando a aplicação Android finaliza a sessão, o cookie não é removido ou pode até ser salvo em disco
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Static analysis**

![](<../../images/image (866).png>)

**Vulnerability assessment of the application** usando uma interface web agradável. Você também pode realizar análise dinâmica (mas é necessário preparar o ambiente).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice que o MobSF pode analisar **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Além disso, se você criar um arquivo **ZIP** com o código-fonte de um app **Android** ou **IOS** (vá para a pasta root da aplicação, selecione tudo e crie um ZIPfile), ele também poderá analisá-lo.

MobSF também permite que você faça **diff/Compare** de análises e integre o **VirusTotal** (você precisará configurar sua API key em _MobSF/settings.py_ e habilitá-la: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). Você também pode definir `VT_UPLOAD` para `False`, então o **hash** será **upload** em vez do arquivo.

### Análise Dinâmica Assistida com MobSF

**MobSF** também pode ser muito útil para **análise dinâmica** em **Android**, mas nesse caso você precisará instalar MobSF e **genymotion** no seu host (uma VM ou Docker não funcionam). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
O **MobSF dynamic analyser** pode:

- **Dump application data** (URLs, logs, clipboard, screenshots feitas por você, screenshots feitas pelo "**Exported Activity Tester**", emails, bancos de dados SQLite, arquivos XML e outros arquivos criados). Tudo isso é feito automaticamente, exceto pelas screenshots — você precisa pressionar quando quiser uma screenshot ou pressionar "**Exported Activity Tester**" para obter screenshots de todas as activities exportadas.
- Capturar tráfego **HTTPS**
- Usar **Frida** para obter **runtime** **information**

A partir de android **versions > 5**, ele irá **automatically start Frida** e configurará as definições globais de **proxy** para **capture** o tráfego. Ele capturará apenas o tráfego da aplicação testada.

**Frida**

Por padrão, ele também usará alguns Frida Scripts para **bypass SSL pinning**, **root detection** e **debugger detection** e para **monitor interesting APIs**.\
MobSF também pode **invoke exported activities**, capturar **screenshots** delas e **save** para o relatório.

Para **start** o teste dinâmico pressione o botão verde: "**Start Instrumentation**". Pressione "**Frida Live Logs**" para ver os logs gerados pelos Frida scripts e "**Live API Monitor**" para ver todas as invocações aos métodos hookados, argumentos passados e valores retornados (isso aparecerá após pressionar "Start Instrumentation").\
MobSF também permite carregar seus próprios **Frida scripts** (para enviar os resultados dos seus Frida scripts para o MobSF use a função `send()`). Ele também possui **several pre-written scripts** que você pode carregar (você pode adicionar mais em `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), basta **selecioná-los**, pressionar "**Load**" e pressionar "**Start Instrumentation**" (você poderá ver os logs desses scripts dentro de "**Frida Live Logs**").

![](<../../images/image (419).png>)

Além disso, você tem algumas funcionalidades auxiliares do Frida:

- **Enumerate Loaded Classes**: Irá imprimir todas as classes carregadas
- **Capture Strings**: Irá imprimir todas as strings capturadas enquanto usa a aplicação (muito ruidoso)
- **Capture String Comparisons**: Pode ser muito útil. Irá **show the 2 strings being compared** e se o resultado foi True ou False.
- **Enumerate Class Methods**: Insira o nome da classe (como "java.io.File") e ele imprimirá todos os métodos da classe.
- **Search Class Pattern**: Buscar classes por pattern
- **Trace Class Methods**: **Trace** a **whole class** (ver entradas e saídas de todos os métodos da classe). Lembre-se que por padrão o MobSF traça vários métodos interessantes da Android API.

Após selecionar o módulo auxiliar que deseja usar, você precisa pressionar "**Start Instrumentation**" e verá todas as saídas em "**Frida Live Logs**".

**Shell**

MobSF também oferece um shell com alguns comandos **adb**, **MobSF commands**, e comandos comuns de **shell** na parte inferior da página de análise dinâmica. Alguns comandos interessantes:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**Ferramentas HTTP**

When http traffic is capture you can see an ugly view of the captured traffic on "**HTTP(S) Traffic**" bottom or a nicer view in "**Start HTTPTools**" green bottom. From the second option, you can **send** the **captured requests** to **proxies** like Burp or Owasp ZAP.\
To do so, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> press "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Once you finish the dynamic analysis with MobSF you can press on "**Start Web API Fuzzer**" to **fuzz http requests** an look for vulnerabilities.

> [!TIP]
> Após realizar uma análise dinâmica com MobSF as configurações de proxy podem ficar mal configuradas e você pode não conseguir corrigi-las pela GUI. Você pode corrigir as configurações de proxy executando:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Análise Dinâmica Assistida com Inspeckage

Você pode obter a ferramenta em [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Esta ferramenta utiliza alguns **Hooks** para mostrar **o que está acontecendo no aplicativo** enquanto você realiza uma **análise dinâmica**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Esta é uma **excelente ferramenta para realizar análise estática com uma GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Esta ferramenta foi projetada para buscar várias **vulnerabilidades de aplicações Android relacionadas à segurança**, tanto no **código-fonte** quanto em **APKs empacotados**. A ferramenta também é **capaz de criar um APK implantável de "Proof-of-Concept"** e **comandos ADB**, para explorar algumas das vulnerabilidades encontradas (atividades expostas, intents, tapjacking...). Como com Drozer, não é necessário rootear o dispositivo de teste.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Exibe todos os arquivos extraídos para fácil referência
- Descompila automaticamente arquivos APK para os formatos Java e Smali
- Analisa AndroidManifest.xml em busca de vulnerabilidades e comportamentos comuns
- Análise estática de código-fonte para vulnerabilidades e comportamentos comuns
- Informações do dispositivo
- e mais
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER é uma aplicação de linha de comando que pode ser usada em Windows, MacOS X e Linux, que analisa arquivos _.apk_ em busca de vulnerabilidades. Ele faz isso descompactando APKs e aplicando uma série de regras para detectar essas vulnerabilidades.

Todas as regras estão centralizadas em um arquivo `rules.json`, e cada empresa ou testador pode criar suas próprias regras para analisar o que precisa.

Faça o download dos binários mais recentes na [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn é uma ferramenta **multiplataforma** que auxilia desenvolvedores, bugbounty hunters e ethical hackers a realizar [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) em aplicações móveis.

O conceito é que você arraste e solte o arquivo da sua aplicação móvel (um arquivo .apk ou .ipa) no aplicativo StaCoAn e ele gerará um relatório visual e portátil para você. Você pode ajustar as configurações e wordlists para obter uma experiência personalizada.

Baixe[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework é um sistema de análise de vulnerabilidades para Android que ajuda desenvolvedores ou hackers a encontrar potenciais vulnerabilidades de segurança em aplicações Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** é uma ferramenta cujo objetivo principal é detectar e alertar o usuário sobre potenciais comportamentos maliciosos desenvolvidos por uma aplicação Android.

A detecção é realizada com a **static analysis** do bytecode Dalvik da aplicação, representado como **Smali**, com a biblioteca [`androguard`](https://github.com/androguard/androguard).

Esta ferramenta procura por **comportamentos comuns de aplicações "maliciosas"** como: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** é um **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. É uma ferramenta que agrega ferramentas comumente usadas para reverse engineering e análise de aplicações móveis, para auxiliar nos testes de aplicações móveis contra as ameaças de segurança mobile do OWASP. Seu objetivo é tornar essa tarefa mais fácil e amigável para desenvolvedores de aplicações móveis e profissionais de segurança.

Ele é capaz de:

- Extrair código Java e Smali usando diferentes ferramentas
- Analisar APKs usando: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Extrair informações privadas do APK usando regexps.
- Analisar o Manifest.
- Analisar domínios encontrados usando: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) e [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscar APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Útil para detectar malware: [https://koodous.com/](https://koodous.com/)

## Ofuscação/Deofuscação de código

Note que, dependendo do serviço e da configuração usada para ofuscar o código, segredos podem ou não terminar ofuscados.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** é uma ferramenta open source de linha de comando que reduz, otimiza e ofusca código Java. Ela é capaz de otimizar bytecode assim como detectar e remover instruções não usadas. ProGuard é software livre e é distribuído sob a GNU General Public License, versão 2.

ProGuard é distribuído como parte do Android SDK e é executado ao construir a aplicação em modo release.

### [DexGuard](https://www.guardsquare.com/dexguard)

Encontre um guia passo a passo para deobfuscar o apk em [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(Do guia) Da última vez que verificamos, o modo de operação do Dexguard era:

- carregar um recurso como um InputStream;
- alimentar o resultado para uma classe que herda de FilterInputStream para descriptografá-lo;
- fazer alguma ofuscação inútil para desperdiçar alguns minutos do tempo de um reverser;
- alimentar o resultado descriptografado para um ZipInputStream para obter um arquivo DEX;
- finalmente carregar o DEX resultante como um Resource usando o método `loadDex`.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverte o processo de ofuscação realizado por ferramentas de ofuscação Android. Isso possibilita inúmeras análises de segurança, incluindo inspeção de código e predição de bibliotecas.**

Você pode enviar um APK ofuscado para a plataforma deles.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

Esta é uma ferramenta LLM para encontrar quaisquer potenciais vulnerabilidades de segurança em apps android e deobfuscar código de apps android. Usa a Gemini public API do Google.

### [Simplify](https://github.com/CalebFenton/simplify)

É um **deobfuscador android genérico.** Simplify **executa virtualmente um app** para entender seu comportamento e então **tenta otimizar o código** para que se comporte de forma idêntica, mas seja mais fácil de entender por um humano. Cada tipo de otimização é simples e genérica, então não importa qual tipo específico de ofuscação foi usado.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD te dá informação sobre **como um APK foi feito**. Identifica muitos **compilers**, **packers**, **obfuscators**, e outras coisas estranhas. É o [_PEiD_](https://www.aldeid.com/wiki/PEiD) para Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b é uma máquina virtual de segurança Android baseada em ubuntu-mate que inclui a coleção dos mais recentes frameworks, tutoriais e labs de diferentes geeks e pesquisadores de segurança para reverse engineering e análise de malware.

## Referências

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) É uma ótima lista de recursos
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Curso rápido de Android
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)

## Ainda a testar

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
