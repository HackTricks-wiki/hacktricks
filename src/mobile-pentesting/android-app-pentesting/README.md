# Android Applications Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Osnove Android aplikacija

Preporučuje se da najpre pročitate ovu stranicu kako biste saznali o **najvažnijim delovima vezanim za bezbednost Androida i najopasnijim komponentama u Android aplikaciji**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Ovo je glavni alat koji vam treba za povezivanje sa Android uređajem (emuliranim ili fizičkim).\
**ADB** omogućava kontrolu uređaja ili preko **USB** ili preko **mreže** sa računara. Ovaj alat omogućava **kopiranje** fajlova u oba smera, **instalaciju** i **deinstalaciju** aplikacija, **izvršavanje** shell komandi, **pravljenje rezervnih kopija** podataka, **čitanje** logova, između ostalih funkcija.

Pogledajte sledeću listu [**ADB Commands**](adb-commands.md) da naučite kako da koristite adb.

## Smali

Ponekad je korisno **izmeniti kod aplikacije** da biste pristupili **skrivenim informacijama** (npr. dobro obfuskovanim lozinkama ili flagovima). U tom slučaju može biti korisno dekompajlirati apk, izmeniti kod i ponovo ga kompajlirati.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Ovo može biti veoma korisno kao **alternativa za nekoliko testova tokom dinamičke analize** koji će biti predstavljeni. Dakle, **uvek imajte ovu mogućnost na umu**.

## Ostali zanimljivi trikovi

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **Preuzimanje APK-ova**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Izvlačenje APK-a sa uređaja:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Spojite sve splits i base apks pomoću [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Studije slučaja i ranjivosti


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Statička analiza

Pre svega, pri analizi APK-a treba **pogledati Java kod** koristeći decompiler.\
Molimo, [**pročitajte ovde da biste našli informacije o različitim dostupnim decompilerima**](apk-decompilers.md).

### Traženje korisnih informacija

Samo pregledom **strings** iz APK-a možete pronaći **lozinke**, **URL-ove** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **API** ključeve, **enkripciju**, **bluetooth uuids**, **tokene** i sve što je interesantno... tražite čak i code execution **backdoors** ili authentication backdoors (hardkodovani admin kredencijali u aplikaciji).

**Firebase**

Obratite posebnu pažnju na **Firebase URL-ove** i proverite da li je loše konfigurisan. [Više informacija o tome šta je Firebase i kako ga eksploatisati ovde.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Osnovno razumevanje aplikacije - Manifest.xml, strings.xml

Pregled fajlova aplikacije _Manifest.xml_ i _strings.xml_ može otkriti potencijalne bezbednosne ranjivosti. Ovi fajlovi se mogu dobiti pomoću decompilera ili preimenovanjem APK fajla u .zip i zatim raspakivanjem.

Ranjivosti identifikovane u **Manifest.xml** uključuju:

- **Debuggable Applications**: Aplikacije označene kao debuggable (`debuggable="true"`) u _Manifest.xml_ predstavljaju rizik jer dozvoljavaju konekcije koje mogu dovesti do eksploatacije. Za detaljnije razumevanje kako iskoristiti debuggable aplikacije pogledajte tutorijal o pronalaženju i eksploataciji debuggable aplikacija na uređaju.
- **Backup Settings**: Atribut `android:allowBackup="false"` treba eksplicitno postaviti za aplikacije koje rade sa osetljivim informacijama kako bi se sprečilo neovlašćeno pravljenje backup-a putem adb, naročito kada je usb debugging omogućen.
- **Network Security**: Prilagođene network security konfiguracije (`android:networkSecurityConfig="@xml/network_security_config"`) u _res/xml/_ mogu definisati detalje bezbednosti poput certificate pinova i podešavanja HTTP saobraćaja. Primer je dozvoljavanje HTTP saobraćaja za određene domene.
- **Exported Activities and Services**: Identifikacija exported activities i servisa u manifestu može ukazati na komponente koje bi mogle biti zloupotrebljene. Dalja analiza tokom dinamičkog testiranja može otkriti kako iskoristiti te komponente.
- **Content Providers and FileProviders**: Izloženi content provider-i mogu dozvoliti neovlašćen pristup ili modifikaciju podataka. Konfiguracija FileProvider-a takođe treba biti pažljivo proverena.
- **Broadcast Receivers and URL Schemes**: Ove komponente mogu biti iskorišćene za eksploataciju, s posebnim osvrtom na to kako se URL schemes upravljaju u kontekstu input ranjivosti.
- **SDK Versions**: Atributi `minSdkVersion`, `targetSDKVersion`, i `maxSdkVersion` ukazuju na podržane Android verzije, naglašavajući važnost da se iz bezbednosnih razloga ne podržavaju zastarele, ranjive Android verzije.

Iz fajla **strings.xml** mogu se otkriti osetljive informacije kao što su API ključevi, custom schemas i druge developerske beleške, što naglašava potrebu za pažljivim pregledom ovih resursa.

### Tapjacking

**Tapjacking** je napad gde se pokreće maliciozna aplikacija koja se postavi iznad aplikacije žrtve. Kada vizuelno zaseni žrtvinu aplikaciju, njen korisnički interfejs je dizajniran tako da prevari korisnika da interaguje sa njim, dok zapravo prosleđuje interakciju žrtvinoj aplikaciji. U suštini, to zaslepljuje korisnika tako da ne zna da zapravo izvršava akcije na aplikaciji žrtve.

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Activity sa `launchMode` postavljenim na `singleTask` bez definisanog `taskAffinity` je ranjiva na Task Hijacking. To znači da aplikacija može biti instalirana i, ako se pokrene pre prave aplikacije, može preuzeti task prave aplikacije (tako da će korisnik interagovati sa malicioznom aplikacijom misleći da koristi pravu).

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Nesigurno čuvanje podataka

**Interna memorija**

Na Androidu, fajlovi smešteni u internu memoriju su dizajnirani da budu dostupni isključivo aplikaciji koja ih je kreirala. Ova bezbednosna mera sprovodi se od strane Android operativnog sistema i uglavnom je dovoljna za potrebe bezbednosti većine aplikacija. Međutim, developeri ponekad koriste mode-ove kao `MODE_WORLD_READABLE` i `MODE_WORLD_WRITABLE` da bi dozvolili deljenje fajlova među različitim aplikacijama. Ipak, ovi modovi ne ograničavaju pristup tim fajlovima od strane drugih aplikacija, uključujući potencijalno maliciozne.

1. **Statička analiza:**
- Proverite upotrebu `MODE_WORLD_READABLE` i `MODE_WORLD_WRITABLE` pažljivo. Ovi modovi mogu potencijalno izložiti fajlove neželjenom ili neovlašćenom pristupu.
2. **Dinamička analiza:**
- Verifikujte permisije postavljene na fajlovima koje aplikacija kreira. Konkretno, proverite da li su neki fajlovi podešeni da budu readable ili writable worldwide. Ovo može predstavljati značajan bezbednosni rizik, jer bi omogućilo bilo kojoj aplikaciji instaliranoj na uređaju, bez obzira na poreklo ili nameru, da čita ili menja te fajlove.

**Eksterna memorija**

Kada se radi o fajlovima na eksternoj memoriji, kao što su SD kartice, treba preduzeti određene mere opreza:

1. **Pristupačnost**:
- Fajlovi na eksternoj memoriji su globalno čitljivi i zapisivi. To znači da bilo koja aplikacija ili korisnik može pristupiti tim fajlovima.
2. **Bezbednosni problemi**:
- S obzirom na lakoću pristupa, savetuje se da se osetljive informacije ne čuvaju na eksternoj memoriji.
- Eksterna memorija može biti uklonjena ili joj može pristupiti bilo koja aplikacija, čime postaje manje sigurna.
3. **Rukovanje podacima sa eksterne memorije**:
- Uvek vršite validaciju inputa nad podacima preuzetim sa eksterne memorije. Ovo je ključno jer su ti podaci iz nepouzdanog izvora.
- Ne preporučuje se skladištenje izvršnih fajlova ili class fajlova na eksternoj memoriji radi dinamičkog učitavanja.
- Ako vaša aplikacija mora da učitava izvršne fajlove sa eksterne memorije, osigurajte da su ti fajlovi potpisani i kriptografski verifikovani pre nego što budu dinamički učitani. Ovaj korak je vitalan za održavanje bezbednosnog integriteta aplikacije.

Eksternu memoriju je moguće pristupiti u `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> Počev od Android 4.4 (**API 17**), SD kartica ima strukturu direktorijuma koja ograničava pristup aplikacije samo na direktorijum koji je specifično za tu aplikaciju. Ovo sprečava maliciozne aplikacije da dobiju pristup za čitanje ili pisanje fajlovima druge aplikacije.

**Osetljivi podaci sačuvani u običnom tekstu**

- **Shared preferences**: Android omogućava svakoj aplikaciji da lako sačuva xml fajlove u putanji `/data/data/<packagename>/shared_prefs/` i ponekad je moguće naći osetljive informacije u običnom tekstu u tom folderu.
- **Databases**: Android omogućava svakoj aplikaciji da lako sačuva sqlite baze podataka u putanji `/data/data/<packagename>/databases/` i ponekad je moguće naći osetljive informacije u običnom tekstu u tom folderu.

### Neispravan TLS

**Accept All Certificates**

Iz nekog razloga, ponekad developeri prihvataju sve sertifikate čak i ako, na primer, hostname ne odgovara, sa linijama koda kao što su sledeće:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Broken Cryptography

**Poor Key Management Processes**

Neki developeri čuvaju osetljive podatke u lokalnoj memoriji i encrypt-uju ih sa ključem hardkodiranim/predvidivim u kodu. Ovo ne bi trebalo raditi jer neki reversing može omogućiti napadačima da izvuku poverljive informacije.

**Use of Insecure and/or Deprecated Algorithms**

Developeri ne bi trebalo da koriste **deprecated algorithms** za izvršavanje autorizacionih **checks**, **store** ili **send** podataka. Neki od ovih algoritama su: RC4, MD4, MD5, SHA1... Ako se **hashes** koriste za čuvanje lozinki na primer, treba koristiti hashove otporne na **brute-force** sa **salt**.

### Other checks

- It's recommended to **obfuscate the APK** to difficult the reverse engineer labour to attackers.
- Ako je app osetljiv (kao bankarske aplikacije), treba da izvrši svoje **own checks to see if the mobile is rooted** i postupiti u skladu sa tim.
- Ako je app osetljiv (kao bankarske aplikacije), treba da proveri da li se koristi **emulator**.
- Ako je app osetljiv (kao bankarske aplikacije), treba da **check it's own integrity before executing** kako bi se proverilo da li je modifikovan.
- Koristite [**APKiD**](https://github.com/rednaga/APKiD) da proverite koji compiler/packer/obfuscator je korišćen za izgradnju APK

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

The tool [**mariana-trench**](https://github.com/facebook/mariana-trench) is capable of finding **vulnerabilities** by **scanning** the **code** of the application. This tool contains a series of **known sources** (that indicates to the tool the **places** where the **input** is **controlled by the user**), **sinks** (which indicates to the tool **dangerous** **places** where malicious user input could cause damages) and **rules**. These rules indicates the **combination** of **sources-sinks** that indicates a vulnerability.

With this knowledge, **mariana-trench will review the code and find possible vulnerabilities on it**.

### Secrets leaked

An application may contain secrets (API keys, passwords, hidden urls, subdomains...) inside of it that you might be able to discover. You could us a tool such as [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> Prvo, potrebno vam je okruženje gde možete instalirati aplikaciju i celu okolinu (Burp CA cert, Drozer and Frida mainly). Stoga se toplo preporučuje rooted uređaj (emulirani ili ne).

### Online Dynamic analysis

Možete napraviti **free account** na: [https://appetize.io/](https://appetize.io). Ova platforma vam omogućava da **upload** i **execute** APK-ove, pa je korisna da vidite kako se apk ponaša.

Možete čak **see the logs of your application** na webu i povezati se preko **adb**.

![](<../../images/image (831).png>)

Zahvaljujući ADB konekciji možete koristiti **Drozer** i **Frida** unutar emulatora.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (Možete kreirati **x86** i **arm** uređaje, i prema [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** verzije **support ARM libraries** bez potrebe za sporim arm emulatorom).
- Naučite kako da ga podesite na ovoj strani:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, potrebno je kreirati nalog. _Preporučuje se da **download** verziju **WITH**_ _**VirtualBox** da bi se izbegle potencijalne greške._)
- [**Nox**](https://es.bignox.com) (Free, ali ne podržava Frida ili Drozer).

> [!TIP]
> Kada kreirate novi emulator na bilo kojoj platformi zapamtite da što je veći ekran to će emulator sporije raditi. Zato, po mogućstvu, odaberite manje ekrane.

Da biste **install google services** (kao AppStore) u Genymotion potrebno je da kliknete na crveno označeno dugme na sledećoj slici:

![](<../../images/image (277).png>)

Takođe, primetite da u **configuration of the Android VM in Genymotion** možete izabrati **Bridge Network mode** (ovo će biti korisno ako ćete se povezivati na Android VM iz drugog VM-a sa alatkama).

#### Use a physical device

Potrebno je aktivirati **debugging** opcije i poželjno je ako ga možete **root**-ovati:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Kada instalirate aplikaciju, prvo što treba da uradite je da je probate i istražite šta radi, kako radi i da se udobno upoznate sa njom.\
> Predlažem da **perform this initial dynamic analysis using MobSF dynamic analysis + pidcat**, tako ćemo moći da **learn how the application works** dok MobSF **captures** puno **interesting** **data** koje možete kasnije pregledati.

### Unintended Data Leakage

**Logging**

Developeri treba da budu oprezni da ne izlažu **debugging information** javno, jer to može dovesti do curenja osetljivih podataka. Alati [**pidcat**](https://github.com/JakeWharton/pidcat) i `adb logcat` se preporučuju za praćenje logova aplikacije kako bi se identifikovale i zaštitile osetljive informacije. **Pidcat** je poželjan zbog jednostavnosti korišćenja i čitljivosti.

> [!WARNING]
> Imajte na umu da od **later newer than Android 4.0**, **applications are only able to access their own logs**. Dakle aplikacije ne mogu pristupiti logovima drugih aplikacija.\
> U svakom slučaju, i dalje se preporučuje da **not log sensitive information**.

**Copy/Paste Buffer Caching**

Androidov **clipboard-based** framework omogućava copy-paste funkcionalnost u aplikacijama, ali predstavlja rizik jer **other applications** mogu **access** clipboard i potencijalno izložiti osetljive podatke. Važno je **disable copy/paste** funkcije za osetljive delove aplikacije, poput podataka o kreditnim karticama, da bi se sprečilo curenje podataka.

**Crash Logs**

Ako aplikacija **crashes** i **saves logs**, ti logovi mogu pomoći napadačima, posebno kada aplikacija ne može biti reverse-engineer-ovana. Da biste umanjili ovaj rizik, izbegavajte logovanje pri padovima, i ako logovi moraju biti poslati preko mreže, osigurajte da se šalju putem SSL kanala.

Kao pentester, **try to take a look to these logs**.

**Analytics Data Sent To 3rd Parties**

Aplikacije često integrišu servise poput Google Adsense, koji mogu nenamerno **leak** osetljive podatke zbog nepravilne implementacije od strane developera. Da biste identifikovali potencijalna curenja podataka, preporučljivo je **intercept the application's traffic** i proveriti da li se osetljive informacije šalju trećim stranama.

### SQLite DBs

Većina aplikacija koristi **internal SQLite databases** za čuvanje informacija. Tokom pentest-a pogledajte **databases** koje su kreirane, imena **tables** i **columns** i sve **data** koja je sačuvana jer možete pronaći **sensitive information** (što bi bila ranjivost).\
Databases bi trebalo da budu locirane u `/data/data/the.package.name/databases` kao `/data/data/com.mwr.example.sieve/databases`

Ako baza podataka čuva poverljive informacije i ona je **encrypted b**ut možete **find** lozinku unutar aplikacije, to je i dalje **vulnerability**.

Enumerišite tabele koristeći `.tables` i enumerišite kolone tabela koristeći `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer is s useful tool to **exploit exported activities, exported services and Content Providers** as you will learn in the following sections.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Takođe zapamtite da kod jedne activity počinje u **`onCreate`** metodi.

**Authorisation bypass**

Kada je Activity exported, možete pozvati njen ekran iz eksternе aplikacije. Dakle, ako je activity sa **sensitive information** **exported**, mogli biste **bypass** **authentication** mehanizme **to access it.**

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

Možete takođe pokrenuti exported activity iz adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NAPOMENA**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> Imajte na umu da authorisation bypass nije uvek ranjivost; to zavisi od načina na koji bypass radi i koje informacije su exposed.

**Sensitive information leakage**

**Activities can also return results**. Ako uspete da pronađete exported i nezaštićenu activity koja poziva **`setResult`** metodu i **vraća osetljive informacije**, postoji sensitive information leakage.

#### Tapjacking

Ako Tapjacking nije sprečen, možete zloupotrebiti exported activity da naterate **korisnika da izvrši neočekivane radnje**. For more info about [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers se uglavnom koriste za **share data**. Ako aplikacija ima dostupne content providers možda ćete moći da **extract sensitive** podatke iz njih. Takođe je interesantno testirati moguće **SQL injections** i **Path Traversals** jer bi mogli biti ranjivi.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Zapamtite da akcije Service-a počinju u metodi `onStartCommand`.

Service je u suštini nešto što **može primiti podatke**, **obraditi** ih i **vratiti** (ili ne) odgovor. Dakle, ako aplikacija exportuje neke servise treba da **proverite** **kod** da biste razumeli šta radi i **testirate** ga **dinamički** radi izvlačenja poverljivih informacija, zaobilaženja mera autentifikacije...\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Zapamtite da akcije Broadcast Receiver-a počinju u metodi `onReceive`.

Broadcast receiver će čekati određeni tip poruke. U zavisnosti od načina na koji receiver obrađuje poruku, može biti ranjiv.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Možete tražiti deep links ručno, koristeći alate kao MobSF ili skripte kao [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Možete **open** deklarisani **scheme** koristeći **adb** ili **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Imajte na umu da možete **izostaviti naziv paketa** i mobilni uređaj će automatski pozvati aplikaciju koja treba da otvori tu vezu._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Kod koji se izvršava**

Da biste pronašli **kod koji će biti izvršen u aplikaciji**, idite na activity koju poziva deep link i potražite funkciju **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Osetljive informacije**

Svaki put kada nađete deep link, proverite da li **ne prima osetljive podatke (kao što su lozinke) putem URL parametara**, jer bilo koja druga aplikacija može **impersonate the deep link i ukrasti te podatke!**

**Parametri u putanji**

Morate takođe proveriti da li neki deep link koristi parametar unutar putanje URL-a, kao na primer: `https://api.example.com/v1/users/{username}` , u tom slučaju možete prouzrokovati path traversal pristupom nečemu poput: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Imajte na umu da ako pronađete ispravne endpoint-e unutar aplikacije, možete izazvati **Open Redirect** (ako je deo putanje korišćen kao domain name), **account takeover** (ako možete izmeniti podatke korisnika bez CSRF tokena i ranjivi endpoint koristi ispravan metod) i bilo koju drugu ranjivost. Više [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**Više primera**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Transport Layer Inspection and Verification Failures

- **Certificates are not always inspected properly** od strane Android aplikacija. Uobičajeno je da ove aplikacije ignorišu upozorenja i prihvate self-signed sertifikate ili, u nekim slučajevima, pređu na korišćenje HTTP konekcija.
- **Negotiations during the SSL/TLS handshake are sometimes weak**, koristeći nesigurne cipher suite-ove. Ova ranjivost čini konekciju podložnom man-in-the-middle (MITM) napadima, omogućavajući napadačima da dekriptuju podatke.
- **Leakage of private information** predstavlja rizik kada se aplikacije autentifikuju koristeći sigurne kanale, ali potom za druge transakcije komuniciraju preko nesigurnih kanala. Ovakav pristup ne štiti osetljive podatke, kao što su session cookies ili podaci o korisniku, od presretanja od strane zlonamernih entiteta.

#### Certificate Verification

Fokusiraćemo se na **certificate verification**. Integritet serverovog sertifikata mora biti verifikovan kako bi se povećala bezbednost. Ovo je ključno zato što nesigurne TLS konfiguracije i slanje osetljivih podataka preko nekriptovanih kanala mogu predstavljati značajne rizike. Za detaljne korake o verifikaciji server sertifikata i otklanjanju ranjivosti, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) pruža sveobuhvatne smernice.

#### SSL Pinning

SSL Pinning je mera bezbednosti gde aplikacija verifikuje serverov sertifikat u odnosu na poznatu kopiju smeštenu unutar same aplikacije. Ova metoda je ključna za sprečavanje MITM napada. Preporučuje se implementacija SSL Pinning-a za aplikacije koje obrađuju osetljive informacije.

#### Traffic Inspection

Da biste pregledali HTTP saobraćaj, potrebno je **instalirati sertifikat proxy alata** (npr. Burp). Bez instalacije tog sertifikata, enkriptovani saobraćaj možda neće biti vidljiv kroz proxy. Za vodič o instalaciji custom CA sertifikata, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Aplikacije koje targetiraju **API Level 24 and above** zahtevaju izmene u Network Security Config da bi prihvatile CA sertifikat proxy-a. Ovaj korak je ključan za inspekciju enkriptovanog saobraćaja. Za instrukcije o modifikaciji Network Security Config, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

Ako se koristi **Flutter**, treba pratiti instrukcije na [**this page**](flutter.md). Razlog je što samo dodavanje sertifikata u store neće raditi pošto Flutter ima sopstvenu listu validnih CA.

#### Static detection of SSL/TLS pinning

Pre nego što pokušate runtime bypass-e, brzo mapirajte gde je pinning primenjen u APK-u. Statičko otkrivanje pomaže da isplanirate hooks/patches i fokusirate se na prave code path-ove.

Tool: SSLPinDetect
- Open-source static-analysis utility koji dekompajlira APK u Smali (preko apktool) i skenira kurirane regex pattern-e implementacija SSL/TLS pinning-a.
- Prijavljuje tačnu file path, line number i code snippet za svaki match.
- Pokriva uobičajene framework-e i custom code path-ove: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init sa custom TrustManagers/KeyManagers, i Network Security Config XML pins.

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Korišćenje
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Primer pravila obrazaca (JSON)

Koristite ili proširite signatures da detektujete proprietarne/prilagođene pinning stilove. Možete učitati sopstveni JSON i scan at scale.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Napomene i saveti
- Brzo skeniranje velikih aplikacija putem multi-threading i memory-mapped I/O; pre-compiled regex smanjuje overhead/lažne pozitivne rezultate.
- Kolekcija patterna: https://github.com/aancw/smali-sslpin-patterns
- Tipični ciljevi za dalju trijažu:
- OkHttp: korišćenje CertificatePinner, setCertificatePinner, okhttp3/okhttp reference paketa
- Prilagođeni TrustManagers: javax.net.ssl.X509TrustManager, override checkServerTrusted
- Prilagođeni SSL contexti: SSLContext.getInstance + SSLContext.init sa prilagođenim managerima
- Deklarativni pins u res/xml network security config i reference u manifestu
- Iskoristite pronađene lokacije da planirate Frida hooks, statičke patch-eve ili reviziju konfiguracije pre dinamičkog testiranja.



#### Bypassing SSL Pinning

Kada je SSL Pinning implementiran, potrebno ga je zaobići da biste mogli da pregledate HTTPS saobraćaj. Za to postoje različite metode:

- Automatski **izmenite** **apk** da **zaobiđete** SSLPinning koristeći [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Najveća prednost ove opcije je što nećete trebati root da zaobiđete SSL Pinning, ali ćete morati da obrišete aplikaciju i ponovo instalirate izmenjenu verziju, i ovo neće uvek raditi.
- Možete koristiti **Frida** (opisana dalje) da zaobiđete ovu zaštitu. Vodič za korišćenje Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Takođe možete pokušati da **automatski zaobiđete SSL Pinning** koristeći [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Takođe možete pokušati da **automatski zaobiđete SSL Pinning** koristeći **MobSF dynamic analysis** (objašnjeno niže)
- Ako i dalje mislite da postoji saobraćaj koji ne presrećete, možete pokušati da **prosledite saobraćaj u Burp koristeći iptables**. Pročitajte ovaj blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Looking for Common Web Vulnerabilities

Važno je takođe tražiti uobičajene web ranjivosti unutar aplikacije. Detaljne informacije o identifikaciji i mitigaciji ovih ranjivosti su izvan opsega ovog sažetka, ali su široko pokrivene drugde.

### Frida

[Frida](https://www.frida.re) je toolkit za dinamičku instrumentaciju za developere, reverse-engineere i istraživače bezbednosti.\
**Možete pristupiti pokrenutoj aplikaciji i hook-ovati metode u runtime-u da promenite ponašanje, menjate vrednosti, izvlačite vrednosti, izvršavate drugačiji kod...**\
Ako želite da pentest Android aplikacije morate znati kako da koristite Frida.

- Naučite kako da koristite Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Neki "GUI" za rad sa Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection je odličan za automatizaciju korišćenja Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Možete naći neke odlične Frida skripte ovde: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Pokušajte zaobići anti-debugging / anti-frida mehanizme učitavanjem Frida kako je navedeno u [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (alat [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump memorije - Fridump**

Proverite da li aplikacija skladišti osetljive informacije u memoriji koje ne bi trebalo da skladišti, kao što su lozinke ili mnemonici.

Koristeći [**Fridump3**](https://github.com/rootbsd/fridump3) možete dump-ovati memoriju aplikacije sa:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Ovo će dump the memory u ./dump direktorijumu, i tamo možete pokrenuti grep sa nečim poput:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Osetljivi podaci u Keystore**

U Androidu je Keystore najbolje mesto za čuvanje osetljivih podataka, međutim, uz dovoljne privilegije i dalje je **moguće mu pristupiti**. Pošto aplikacije često ovde skladište **osetljive podatke u nešifrovanom obliku**, pentests bi trebalo da to provere, jer root user ili neko sa fizičkim pristupom uređaju može da ukrade te podatke.

Čak i ako aplikacija skladišti podatke u Keystore-u, podaci bi trebalo da budu šifrovani.

Za pristup podacima unutar Keystore-a možete koristiti ovaj Frida script: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Korišćenjem sledeće Frida skripte moguće je **bypass fingerprint authentication** koje Android aplikacije mogu koristiti da bi **zaštitile određene osetljive oblasti:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Pozadinske slike**

Kada stavite aplikaciju u pozadinu, Android čuva **snapshot of the application** tako da kada se vrati u prednji plan, prvo učitava tu sliku pre same aplikacije pa izgleda da se aplikacija brže učitava.

Međutim, ako ovaj snapshot sadrži **osetljive informacije**, neko sa pristupom snapshotu može **ukrasti te informacije** (napomena: potreban je root da biste mu pristupili).

Snapshots se obično čuvaju na: **`/data/system_ce/0/snapshots`**

Android pruža način da **prevent the screenshot capture by setting the FLAG_SECURE** layout parameter. Korišćenjem ovog FLAG_SECURE flag-a, sadržaj prozora se tretira kao siguran, sprečavajući njegovo pojavljivanje u screenshots ili pregled na nesigurnim prikazima.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Ovaj alat može pomoći pri upravljanju različitim alatima tokom dynamic analysis: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Developeri često prave proxy komponente kao što su activities, services, i broadcast receivers koje obrađuju ove Intents i prosleđuju ih metodama kao što su `startActivity(...)` ili `sendBroadcast(...)`, što može biti rizično.

Opasnost leži u tome što se napadačima može dozvoliti da pokrenu non-exported app components ili pristupe osetljivim content providers tako što će pogrešno usmeriti ove Intents. Značajan primer je `WebView` komponenta koja konvertuje URL-ove u `Intent` objekte preko `Intent.parseUri(...)` i potom ih izvršava, što može dovesti do malicious Intent injections.

### Essential Takeaways

- **Intent Injection** is similar to web's Open Redirect issue.
- Exploits involve passing `Intent` objects as extras, which can be redirected to execute unsafe operations.
- It can expose non-exported components and content providers to attackers.
- `WebView`’s URL to `Intent` conversion can facilitate unintended actions.

### Android Client Side Injections and others

Verovatno poznajete ovaj tip ranjivosti sa Web-a. Posebno morate biti oprezni sa ovim ranjivostima u Android aplikaciji:

- **SQL Injection:** When dealing with dynamic queries or Content-Providers ensure you are using parameterized queries.
- **JavaScript Injection (XSS):** Verify that JavaScript and Plugin support is disabled for any WebViews (disabled by default). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews should have access to the file system disabled (enabled by default) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: U više slučajeva, kada android aplikacija završi sesiju, cookie nije opozvan ili čak može biti sačuvan na disk
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Static analysis**

![](<../../images/image (866).png>)

**Vulnerability assessment of the application** koristeći lepo web-based frontend. Takođe možete izvršiti dynamic analysis (ali morate pripremiti environment).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Primetite da MobSF može da analizira **Android**(apk)**, IOS**(ipa) **i Windows**(apx) aplikacije (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Takođe, ako napravite **ZIP** fajl sa source code-om ako je u pitanju **Android** ili **IOS** app (idi u root folder aplikacije, izaberi sve i napravi ZIPfile), moći će da ga analizira takođe.

MobSF takođe dozvoljava da uradite **diff/Compare** analiza i da integrišete **VirusTotal** (neophodno je da podesiš svoj API ključ u _MobSF/settings.py_ i omogućiš ga: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). Možete takođe postaviti `VT_UPLOAD` na `False`, tada će se umesto fajla upload-ovati **hash**.

### Assisted Dynamic analysis with MobSF

**MobSF** može biti vrlo koristan i za **dynamic analysis** na **Android**, ali u tom slučaju treba da instaliraš MobSF i **genymotion** na svom hostu (VM ili Docker neće raditi). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
**MobSF dynamic analyser** može:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). Sve ovo se radi automatski osim screenshot-ova — za njih moraš pritisnuti kad želiš screenshot ili pritisnuti "**Exported Activity Tester**" da bi dobio screenshot-ove svih exported activities.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

Od android **verzija > 5**, automatski će pokrenuti Frida i postaviti globalna **proxy** podešavanja da bi **capture**-ovao saobraćaj. Uhvaćen će biti samo saobraćaj iz testirane aplikacije.

**Frida**

Po default-u, koristiće i neke Frida Scripts da **bypass SSL pinning**, **root detection** i **debugger detection** i da **monitor**-uje zanimljive API-je.\
MobSF takođe može da **invoke exported activities**, napravi **screenshots** i **sačuva** ih za izveštaj.

Da bi **pokrenuo** dynamic testing pritisni zeleno dugme: "**Start Instrumentation**". Pritisni "**Frida Live Logs**" da vidiš logove koje generišu Frida skripte i "**Live API Monitor**" da vidiš sve pozive na hooked metode, prosleđene argumente i vraćene vrednosti (ovo će se pojaviti nakon pritiskanja "Start Instrumentation").\
MobSF takođe dozvoljava da učitaš svoje **Frida scripts** (da bi poslao rezultate svojih Frida skripti u MobSF koristi funkciju `send()`). Ima i **nekoliko prethodno napisanih skripti** koje možeš učitati (možeš dodati još u `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), samo ih **selektuj**, pritisni "**Load**" i pritisni "**Start Instrumentation**" (moći ćeš da vidiš logove tih skripti unutar "**Frida Live Logs**").

![](<../../images/image (419).png>)

Pored toga, imaš neke pomoćne Frida funkcionalnosti:

- **Enumerate Loaded Classes**: Ispisaće sve učitane klase
- **Capture Strings**: Ispisaće sve capture strings dok koristiš aplikaciju (veoma noisy)
- **Capture String Comparisons**: Može biti vrlo korisno. Prikazaće **dve string vrednosti koje se upoređuju** i da li je rezultat True ili False.
- **Enumerate Class Methods**: Unesi ime klase (npr. "java.io.File") i ispišaće sve metode klase.
- **Search Class Pattern**: Pretražuj klase po pattern-u
- **Trace Class Methods**: **Trace** celu **klasu** (vidi input-e i output-e svih metoda klase). Zapamti da po default-u MobSF trace-uje nekoliko interesantnih Android Api metoda.

Kada izabereš pomoćni modul koji želiš da koristiš, potrebno je da pritisneš "**Start Intrumentation**" i sve izlaze ćeš videti u "**Frida Live Logs**".

**Shell**

Mobsf ti takođe daje shell sa nekim **adb** komandama, **MobSF commands**, i uobičajenim **shell** **commands** na dnu stranice za dynamic analysis. Neke interesantne komande:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP alati**

Kada je HTTP saobraćaj uhvaćen možete videti ružan prikaz uhvaćenog saobraćaja na "**HTTP(S) Traffic**" dugmetu ili lepši prikaz na zelenom dugmetu "**Start HTTPTools**". Iz druge opcije možete **poslati** **uhvaćene zahteve** na **proxies** kao Burp ili Owasp ZAP.\
Da biste to uradili, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> pritisnite "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Kada završite dinamičku analizu sa MobSF možete pritisnuti "**Start Web API Fuzzer**" da **fuzz** HTTP zahteve i tražite ranjivosti.

> [!TIP]
> Nakon izvršene dinamičke analize sa MobSF, proxy podešavanja mogu biti pogrešno konfigurisana i možda ih nećete moći popraviti iz GUI-ja. Možete popraviti proxy podešavanja ovako:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Pomoćena dinamička analiza sa Inspeckage

Alat možete preuzeti sa [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Ovaj alat koristi neke **Hooks** da vam pokaže **šta se dešava u aplikaciji** dok vršite **dinamičku analizu**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Ovo je **odličan alat za izvođenje statičke analize sa GUI-jem**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Ovaj alat je dizajniran da traži nekoliko **bezbednosno povezanih ranjivosti Android aplikacija**, bilo u **izvornom kodu** ili u **pakovanim APK-ovima**. Alat je takođe sposoban da kreira "Proof-of-Concept" deployable APK i ADB komande, kako bi iskoristio neke od pronađenih ranjivosti (Exposed activities, intents, tapjacking...). Kao i sa Drozer, nema potrebe da root-ujete test uređaj.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Prikazuje sve izvučene fajlove radi lakšeg pregleda
- Automatski dekompajlira APK fajlove u Java i Smali format
- Analizira AndroidManifest.xml u potrazi za uobičajenim ranjivostima i ponašanjem
- Statička analiza izvornog koda radi otkrivanja uobičajenih ranjivosti i ponašanja
- Informacije o uređaju
- i još
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER je aplikacija za komandnu liniju koja se može koristiti na Windows, MacOS X i Linux, i koja analizira _.apk_ fajlove u potrazi za ranjivostima. To radi dekompresovanjem APKs i primenom niza pravila za otkrivanje tih ranjivosti.

Sva pravila su smeštena u fajlu `rules.json`, i svaka kompanija ili tester može kreirati sopstvena pravila za analizu onoga što im je potrebno.

Preuzmite najnovije binarne fajlove sa [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn je **crossplatform** alat koji pomaže razvijačima, bugbounty hunters i ethical hackers pri izvođenju [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) na mobilnim aplikacijama.

Koncept je da prevučete i ispustite datoteku vaše mobilne aplikacije (fajl .apk ili .ipa) na StaCoAn aplikaciju i ona će za vas generisati vizuelni i prenosivi izveštaj. Možete prilagoditi podešavanja i wordlists kako biste dobili prilagođeno iskustvo.

Preuzmite[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework je sistem za analizu ranjivosti za Android koji pomaže developerima ili hackersima da pronađu potencijalne sigurnosne ranjivosti u Android aplikacijama.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** je alat čiji je glavni cilj da detektuje i upozori korisnika na potencijalna maliciozna ponašanja razvijena od strane Android aplikacije.

Detekcija se vrši pomoću **static analysis** Dalvik bytecode-a aplikacije, prikazanog kao **Smali**, koristeći biblioteku [`androguard`](https://github.com/androguard/androguard).

Ovaj alat traži **uobičajena ponašanja "loših" aplikacija** kao što su: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** je okvir za reverzni inženjering i analizu mobilnih aplikacija. To je alat koji okuplja često korišćene alate za reverzni inženjering i analizu mobilnih aplikacija, kako bi pomogao pri testiranju mobilnih aplikacija protiv OWASP mobile security pretnji. Njegov cilj je da ovaj zadatak učini lakšim i pristupačnijim za developere mobilnih aplikacija i bezbednosne profesionalce.

Može:

- Ekstrahovati Java i Smali kod koristeći različite alate
- Analizirati APK-ove koristeći: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Ekstrahovati privatne informacije iz APK-a korišćenjem regexp-ova.
- Analizirati Manifest.
- Analizirati pronađene domene koristeći: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) i [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuskovati APK preko [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Koristan za detekciju malvera: [https://koodous.com/](https://koodous.com)

## Obfuscating/Deobfuscating code

Imajte na umu da, u zavisnosti od servisa i konfiguracije koju koristite za obfuskaciju koda, tajne mogu biti ili ne moraju biti obfuskirane.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** je open source alat komandne linije koji smanjuje, optimizuje i obfuskira Java kod. Sposoban je da optimizuje bajtkod kao i da detektuje i ukloni neiskorišćene instrukcije. ProGuard je slobodan softver i distribuira se pod GNU General Public License, verzija 2.

ProGuard se distribuira kao deo Android SDK-a i radi prilikom buildovanja aplikacije u release modu.

### [DexGuard](https://www.guardsquare.com/dexguard)

Pronađite vodič korak-po-korak za deobfuskaciju apk-a na [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(Prema ovom vodiču) Poslednji put kada smo proverili, način rada DexGuard-a je bio:

- učitaj resurs kao InputStream;
- prosledi rezultat klasi koja nasleđuje FilterInputStream da bi ga dekriptovala;
- uradi neku beskorisnu obfuskaciju da bi potrošio nekoliko minuta reverzera;
- prosledi dekriptovani rezultat ZipInputStream-u da bi dobio DEX fajl;
- konačno učitaj rezultujući DEX kao Resource koristeći `loadDex` metodu.

### [DeGuard](http://apk-deguard.com)

**DeGuard vraća proces obfuskacije koji izvode Android alati za obfuskaciju. Ovo omogućava brojne bezbednosne analize, uključujući inspekciju koda i predviđanje biblioteka.**

Možete otpremiti obfuskirani APK na njihovu platformu.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

Ovo je LLM alat za pronalaženje potencijalnih bezbednosnih ranjivosti u Android aplikacijama i deobfuskaciju koda Android aplikacija. Koristi Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

To je generički deobfuskator za Android. Simplify virtuelno izvršava aplikaciju da bi razumeo njeno ponašanje i zatim pokušava da optimizuje kod tako da se ponaša identično, ali bude lakši za razumevanje ljudima. Svaki tip optimizacije je jednostavan i generički, tako da nije važno koji specifični tip obfuskacije je korišćen.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD vam daje informacije o tome kako je APK napravljen. Identifikuje mnoge kompajlere, packere, obfuskatore i druge neobične stvari. To je [_PEiD_](https://www.aldeid.com/wiki/PEiD) za Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b je Android sigurnosna virtuelna mašina zasnovana na ubuntu-mate koja uključuje kolekciju najnovijih framework-ova, tutorijala i laboratorija od različitih security geeka i istraživača za reverse engineering i analizu malvera.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) To je odlična lista resursa
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)

## Yet to try

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
