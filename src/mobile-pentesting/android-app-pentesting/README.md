# Android-Anwendungen Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Grundlagen zu Android-Anwendungen

Es wird dringend empfohlen, diese Seite zuerst zu lesen, um die **wichtigsten Teile in Bezug auf Android-Sicherheit und die gefährlichsten Komponenten in einer Android-Anwendung** kennenzulernen:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Dies ist das Hauptwerkzeug, das Sie benötigen, um eine Verbindung zu einem Android-Gerät (emuliert oder physisch) herzustellen.\
**ADB** ermöglicht es, Geräte entweder über **USB** oder **Netzwerk** von einem Computer aus zu steuern. Dieses Dienstprogramm erlaubt das **Kopieren** von Dateien in beide Richtungen, die **Installation** und **Deinstallation** von Apps, die **Ausführung** von Shell-Befehlen, das **Sichern** von Daten, das **Lesen** von Logs, unter anderen Funktionen.

Sieh dir die folgende Liste der [**ADB Commands**](adb-commands.md) an, um zu lernen, wie man adb benutzt.

## Smali

Manchmal ist es interessant, den **Anwendungscode zu modifizieren**, um auf **versteckte Informationen** zuzugreifen (z. B. stark obfuskierte Passwörter oder Flags). In solchen Fällen kann es hilfreich sein, die APK zu dekompilieren, den Code zu ändern und sie wieder zu kompilieren.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Dies kann sehr nützlich als **Alternative für mehrere Tests während der dynamischen Analyse** sein, die noch vorgestellt werden. Behalte daher **immer diese Möglichkeit** im Hinterkopf.

## Weitere interessante Tricks

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **APKs herunterladen**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- APK vom Gerät extrahieren:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Alle splits und base apks mit [APKEditor](https://github.com/REAndroid/APKEditor) zusammenführen:
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Fallstudien & Schwachstellen


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Statische Analyse

Zuerst sollte man zur Analyse einer APK **den Java-Code ansehen** und dazu einen Decompiler verwenden.\
Bitte, [**lies hier, um Informationen zu verschiedenen verfügbaren Decompilern zu finden**](apk-decompilers.md).

### Suche nach interessanten Informationen

Schon ein Blick auf die **strings** der APK kann Hinweise auf **Passwörter**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api**-Schlüssel, **Verschlüsselung**, **bluetooth uuids**, **Tokens** und alles andere Interessante liefern... suche auch nach Codeausführungs-**Backdoors** oder Authentifizierungs-Backdoors (hardcodierte Admin-Credentials in der App).

**Firebase**

Achte besonders auf **Firebase-URLs** und überprüfe, ob diese falsch konfiguriert sind. [Mehr Informationen darüber, was Firebase ist und wie man es ausnutzen kann, hier.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Grundlegendes Verständnis der Anwendung - Manifest.xml, strings.xml

Die **Untersuchung der _Manifest.xml_ und der **_strings.xml_** einer Anwendung kann potenzielle Sicherheitslücken offenbaren**. Auf diese Dateien kann man mit Decompilern zugreifen oder indem man die APK-Erweiterung in .zip umbenennt und die Datei entpackt.

Aus der **Manifest.xml** identifizierbare **Schwachstellen** umfassen:

- **Debuggable Applications**: Anwendungen, die in der _Manifest.xml_ als debuggable (`debuggable="true"`) gesetzt sind, stellen ein Risiko dar, da sie Verbindungen erlauben können, die zur Ausnutzung führen. Für ein besseres Verständnis, wie debuggable Applications ausgenutzt werden können, siehe ein Tutorial zum Finden und Ausnutzen von debuggable Applications auf einem Gerät.
- **Backup-Einstellungen**: Das Attribut `android:allowBackup="false"` sollte explizit für Anwendungen gesetzt werden, die mit sensiblen Informationen umgehen, um unautorisierte Datenbackups über adb zu verhindern, insbesondere wenn USB-Debugging aktiviert ist.
- **Network Security**: Benutzerdefinierte Netzwerk-Sicherheitskonfigurationen (`android:networkSecurityConfig="@xml/network_security_config"`) in _res/xml/_ können Sicherheitsdetails wie Certificate Pins und Einstellungen für HTTP-Traffic spezifizieren. Ein Beispiel wäre das Zulassen von HTTP-Traffic für bestimmte Domains.
- **Exported Activities und Services**: Das Identifizieren exportierter Activities und Services im Manifest kann Komponenten hervorheben, die missbraucht werden könnten. Weitere Analysen während dynamischer Tests können aufdecken, wie diese Komponenten ausgenutzt werden können.
- **Content Providers und FileProviders**: Exponierte Content Providers könnten unautorisierten Zugriff oder Modifikationen von Daten ermöglichen. Die Konfiguration von FileProviders sollte ebenfalls sorgfältig geprüft werden.
- **Broadcast Receivers und URL-Schemata**: Diese Komponenten könnten für Exploits genutzt werden, mit besonderem Augenmerk darauf, wie URL-Schemata für Eingaben gehandhabt werden.
- **SDK-Versionen**: Die Attribute `minSdkVersion`, `targetSDKVersion` und `maxSdkVersion` geben die unterstützten Android-Versionen an und machen deutlich, dass es wichtig ist, keine veralteten, verwundbaren Android-Versionen zu unterstützen.

Aus der **strings.xml** können sensible Informationen wie API-Schlüssel, Custom Schemes und andere Entwicklerhinweise entdeckt werden, was die Notwendigkeit unterstreicht, diese Ressourcen sorgfältig zu prüfen.

### Tapjacking

Tapjacking ist ein Angriff, bei dem eine **malicious** **application** gestartet wird und **sich über einer Opfer-Anwendung positioniert**. Sobald sie die Opfer-App sichtbar überlagert, ist ihre Benutzeroberfläche so gestaltet, dass sie den Benutzer zur Interaktion verleitet, während sie die Interaktion an die Opfer-App weiterreicht.\
Im Effekt **blendet sie den Benutzer aus, sodass er nicht erkennt, dass er tatsächlich Aktionen in der Opfer-App durchführt**.

Mehr Informationen dazu findest du in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Eine **activity** mit dem **`launchMode`** auf **`singleTask` ohne definiertes `taskAffinity`** ist anfällig für Task Hijacking. Das bedeutet, dass eine **application** installiert werden kann und wenn sie vor der echten Anwendung gestartet wird, die **Task der echten Anwendung hijacken** könnte (so dass der Benutzer mit der **malicious application interagiert und glaubt, die echte Anwendung zu benutzen**).

Mehr Infos in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Unsichere Datenspeicherung

**Internal Storage**

In Android sind Dateien, die im **internal** Storage **gespeichert** werden, **dafür vorgesehen**, ausschließlich von der **App**, die sie erstellt hat, **zugänglich** zu sein. Diese Sicherheitsmaßnahme wird vom Android-Betriebssystem durchgesetzt und ist für die Sicherheitsanforderungen der meisten Anwendungen in der Regel ausreichend. Entwickler verwenden jedoch manchmal Modi wie `MODE_WORLD_READABLE` und `MODE_WORLD_WRITABLE`, um Dateien zwischen verschiedenen Anwendungen **zu teilen**. Diese Modi **beschränken jedoch nicht den Zugriff** auf diese Dateien durch andere Anwendungen, einschließlich potenziell bösartiger.

1. **Statische Analyse:**
- **Stelle sicher**, dass die Verwendung von `MODE_WORLD_READABLE` und `MODE_WORLD_WRITABLE` **gründlich geprüft** wird. Diese Modi **können Dateien unbeabsichtigt oder unautorisiert zugänglich machen**.
2. **Dynamische Analyse:**
- **Überprüfe** die **Berechtigungen** der von der App erstellten Dateien. Insbesondere **prüfe**, ob Dateien so gesetzt sind, dass sie weltweit lesbar oder schreibbar sind. Dies kann ein erhebliches Sicherheitsrisiko darstellen, da es **jeder auf dem Gerät installierten Anwendung**, unabhängig von Herkunft oder Absicht, erlauben würde, diese Dateien zu **lesen oder zu verändern**.

**External Storage**

Beim Umgang mit Dateien auf **external storage**, wie SD-Karten, sollten bestimmte Vorsichtsmaßnahmen getroffen werden:

1. **Zugänglichkeit**:
- Dateien auf external storage sind **global lesbar und beschreibbar**. Das bedeutet, jede Anwendung oder jeder Benutzer kann auf diese Dateien zugreifen.
2. **Sicherheitsbedenken**:
- Aufgrund des einfachen Zugriffs wird **davon abgeraten, sensible Informationen** auf external storage zu speichern.
- External storage kann entfernt werden oder von jeder Anwendung eingesehen werden, was es weniger sicher macht.
3. **Umgang mit Daten aus external storage**:
- Führe immer **Eingabevalidierung** an Daten durch, die aus external storage abgerufen werden. Das ist entscheidend, da diese Daten aus einer nicht vertrauenswürdigen Quelle stammen.
- Das Speichern von ausführbaren Dateien oder class-Dateien auf external storage zur dynamischen Nachladung wird dringend abgeraten.
- Falls deine App ausführbare Dateien aus external storage laden muss, stelle sicher, dass diese Dateien **signiert und kryptografisch verifiziert** sind, bevor sie dynamisch geladen werden. Dieser Schritt ist wichtig, um die Sicherheitsintegrität deiner Anwendung zu wahren.

External storage kann unter /storage/emulated/0 , /sdcard , /mnt/sdcard zugegriffen werden

> [!TIP]
> Beginnend mit Android 4.4 (**API 17**) hat die SD-Karte eine Verzeichnisstruktur, die den Zugriff einer App auf das Verzeichnis beschränkt, das speziell für diese App vorgesehen ist. Dies verhindert, dass bösartige Anwendungen Lese- oder Schreibzugriff auf die Dateien einer anderen App erlangen.

**Sensitive data stored in clear-text**

- **Shared preferences**: Android erlaubt jeder App, einfach XML-Dateien im Pfad `/data/data/<packagename>/shared_prefs/` zu speichern, und manchmal lassen sich in diesem Ordner sensible Informationen im Klartext finden.
- **Databases**: Android erlaubt jeder App, einfach sqlite-Datenbanken im Pfad `/data/data/<packagename>/databases/` zu speichern, und manchmal lassen sich in diesem Ordner sensible Informationen im Klartext finden.

### Broken TLS

**Accept All Certificates**

Aus irgendeinem Grund akzeptieren Entwickler manchmal alle Zertifikate, selbst wenn beispielsweise der Hostname nicht übereinstimmt — mit Codezeilen wie der folgenden:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Fehlerhafte Kryptographie

**Schlechte Key-Management-Prozesse**

Einige Entwickler speichern sensible Daten im lokalen Speicher und verschlüsseln sie mit einem im Code hartkodierten/vorhersehbaren Key. Das sollte nicht gemacht werden, da Reverse-Engineering es Angreifern ermöglichen könnte, die vertraulichen Informationen zu extrahieren.

**Verwendung unsicherer und/oder veralteter Algorithmen**

Entwickler sollten keine **veralteten Algorithmen** verwenden, um Autorisierungs**prüfungen** durchzuführen, Daten zu **speichern** oder zu **senden**. Einige dieser Algorithmen sind: RC4, MD4, MD5, SHA1... Wenn **Hashes** z. B. zum Speichern von Passwörtern verwendet werden, sollten hashes verwendet werden, die bruteforce-**resistent** sind und Salt enthalten.

### Weitere Prüfungen

- Es wird empfohlen, das **APK zu obfuskieren**, um die Reverse-Engineering-Arbeit für Angreifer zu erschweren.
- Wenn die App sensibel ist (z. B. Bank-Apps), sollte sie **eigene Prüfungen durchführen, um zu erkennen, ob das Mobilgerät gerootet ist**, und entsprechend reagieren.
- Wenn die App sensibel ist (z. B. Bank-Apps), sollte sie prüfen, ob ein **emulator** verwendet wird.
- Wenn die App sensibel ist (z. B. Bank-Apps), sollte sie **ihre eigene Integrität vor der Ausführung prüfen**, um festzustellen, ob sie verändert wurde.
- Verwende [**APKiD**](https://github.com/rednaga/APKiD), um zu prüfen, welcher Compiler/Packager/Obfuscator zum Erstellen des APK verwendet wurde

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automatisierte statische Code-Analyse

Das Tool [**mariana-trench**](https://github.com/facebook/mariana-trench) ist in der Lage, **Vulnerabilities** zu finden, indem es den **Code** der Anwendung **scannt**. Dieses Tool enthält eine Reihe von **known sources** (die dem Tool die **Stellen** angeben, an denen die **Eingabe** vom Benutzer **kontrolliert** wird), **sinks** (die dem Tool **gefährliche** **Stellen** anzeigen, an denen bösartige Benutzereingaben Schaden anrichten könnten) und **rules**. Diese Regeln geben die **Kombination** von **sources-sinks** an, die auf eine Vulnerability hinweist.

Mit diesem Wissen **wird mariana-trench den Code überprüfen und mögliche Vulnerabilities darin finden**.

### Secrets leaked

Eine Anwendung kann Secrets (API-Keys, Passwörter, versteckte URLs, Subdomains...) enthalten, die Sie möglicherweise entdecken können. Du könntest ein Tool wie [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks) verwenden

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Andere interessante Funktionen

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)

### **Weitere Tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> First of all, you need an environment where you can install the application and all the environment (Burp CA cert, Drozer and Frida mainly). Therefore, a rooted device (emulated or not) is extremely recommended.

### Online Dynamic analysis

You can create a **free account** in: [https://appetize.io/](https://appetize.io). This platform allows you to **upload** and **execute** APKs, so it is useful to see how an apk is behaving.

You can even **see the logs of your application** in the web and connect through **adb**.

![](<../../images/image (831).png>)

Thanks to the ADB connection you can use **Drozer** and **Frida** inside the emulators.

### Lokale dynamische Analyse

#### Verwendung eines emulators

- [**Android Studio**](https://developer.android.com/studio) (Du kannst **x86** und **arm** Geräte erstellen, und laut [**diesem**](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**neueren x86** Versionen **unterstützen ARM-Bibliotheken** ohne einen langsamen arm-emulator zu benötigen).
- Lerne, wie man es auf dieser Seite einrichtet:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, du musst ein Konto erstellen. _Es wird empfohlen, die Version **WITH**_ _**VirtualBox** herunterzuladen, um potenzielle Fehler zu vermeiden._)
- [**Nox**](https://es.bignox.com) (Kostenlos, unterstützt aber Frida oder Drozer nicht).

> [!TIP]
> When creating a new emulator on any platform remember that the bigger the screen is, the slower the emulator will run. So select small screens if possible.

To **install google services** (like AppStore) in Genymotion you need to click on the red marked button of the following image:

![](<../../images/image (277).png>)

Also, notice that in the **configuration of the Android VM in Genymotion** you can select **Bridge Network mode** (this will be useful if you will be connecting to the Android VM from a different VM with the tools).

#### Verwende ein physisches Gerät

Du musst die **Debugging**-Optionen aktivieren und es ist vorteilhaft, wenn du es **rooten** kannst:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Once you have installed the application, the first thing you should do is to try it and investigate what does it do, how does it work and get comfortable with it.\
> I will suggest to **perform this initial dynamic analysis using MobSF dynamic analysis + pidcat**, so we will be able to **learn how the application works** while MobSF **captures** a lot of **interesting** **data** you can review later on.

Magisk/Zygisk quick notes (recommended on Pixel devices)
- Patch boot.img with the Magisk app and flash via fastboot to get systemless root
- Enable Zygisk + DenyList for root hiding; consider LSPosed/Shamiko when stronger hiding is required
- Keep original boot.img to recover from OTA updates; re-patch after each OTA
- For screen mirroring, use scrcpy on the host



### Unintended Data Leakage

**Logging**

Entwickler sollten vorsichtig sein, debug-Informationen öffentlich preiszugeben, da dies zu sensiblen Daten leaks führen kann. Die Tools [**pidcat**](https://github.com/JakeWharton/pidcat) und `adb logcat` werden empfohlen, um Anwendungslogs zu überwachen, damit sensible Informationen identifiziert und geschützt werden können. **Pidcat** wird aufgrund seiner einfachen Nutzung und Lesbarkeit bevorzugt.

> [!WARNING]
> Note that from **later newer than Android 4.0**, **applications are only able to access their own logs**. So applications cannot access other apps logs.\
> Anyway, it's still recommended to **not log sensitive information**.

**Copy/Paste Buffer Caching**

Androids **clipboard-basiertes** Framework ermöglicht Copy-Paste-Funktionen in Apps, birgt jedoch ein Risiko, da **andere Anwendungen** auf die Zwischenablage **zugreifen** können und dadurch möglicherweise sensible Daten exponiert werden. Es ist wichtig, Copy/Paste-Funktionen für sensible Bereiche einer Anwendung, wie Kreditkartendaten, zu **deaktivieren**, um leaks zu verhindern.

**Crash Logs**

Wenn eine Anwendung **abstürzt** und **Logs speichert**, können diese Logs Angreifern helfen, insbesondere wenn die Anwendung nicht reverse-engineered werden kann. Um dieses Risiko zu mindern, sollte man vermeiden, bei Abstürzen zu loggen, und falls Logs über das Netzwerk gesendet werden müssen, sicherstellen, dass sie über einen SSL-Kanal übertragen werden.

Als pentester, **versuche dir diese Logs anzusehen**.

**Analytics-Daten an Dritte gesendet**

Anwendungen integrieren oft Dienste wie Google Adsense, die unbeabsichtigt sensible Daten leak durch fehlerhafte Implementierung durch Entwickler auslösen können. Um potenzielle Daten leaks zu identifizieren, ist es ratsam, den Traffic der Anwendung abzufangen und zu prüfen, ob sensible Informationen an Drittanbieter gesendet werden.

### SQLite DBs

Die meisten Anwendungen verwenden **interne SQLite-Datenbanken**, um Informationen zu speichern. Während des Pentests solltest du einen **Blick** auf die erstellten **Datenbanken**, die Namen der **Tabellen** und **Spalten** und alle gespeicherten **Daten** werfen, da du sensible Informationen finden könntest (was eine Vulnerability wäre).\
Datenbanken sollten sich in `/data/data/the.package.name/databases` befinden, z. B. `/data/data/com.mwr.example.sieve/databases`

Wenn die Datenbank vertrauliche Informationen speichert und **verschlüsselt ist**, du aber das **Passwort** in der Anwendung **finden** kannst, ist das immer noch eine **Vulnerability**.

Zähle die Tabellen mit `.tables` auf und liste die Spalten der Tabellen mit `.schema <table_name>` auf

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer is s useful tool to **exploit exported activities, exported services and Content Providers** as you will learn in the following sections.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Also remember that the code of an activity starts in the **`onCreate`** method.

**Authorisation bypass**

When an Activity is exported you can invoke its screen from an external app. Therefore, if an activity with **sensitive information** is **exported** you could **bypass** the **authentication** mechanisms **to access it.**

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

You can also start an exported activity from adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> Beachte, dass ein authorisation bypass nicht immer eine vulnerability ist; es hängt davon ab, wie der Bypass funktioniert und welche Informationen exponiert werden.

**Sensitive information leakage**

**Activities can also return results**. Wenn es dir gelingt, eine exportierte und ungeschützte Activity zu finden, die die Methode **`setResult`** aufruft und **vertrauliche Informationen zurückgibt**, liegt eine sensitive information leakage vor.

#### Tapjacking

Wenn Tapjacking nicht verhindert wird, könntest du die exportierte Activity missbrauchen, um den **user unerwartete Aktionen ausführen zu lassen**. Für mehr Infos darüber, [**was Tapjacking ist, folge dem Link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers werden grundsätzlich verwendet, um **Daten zu teilen**. Wenn eine App Content providers bereitstellt, könntest du in der Lage sein, **sensible Daten** aus ihnen zu extrahieren. Es ist auch interessant, mögliche **SQL injections** und **Path Traversals** zu testen, da diese verwundbar sein könnten.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Denke daran, dass die Aktionen eines Service in der Methode `onStartCommand` beginnen.

Ein Service ist im Grunde etwas, das **Daten empfangen**, **verarbeiten** und (möglicherweise) eine Antwort **zurückgeben** kann. Wenn eine Anwendung also Services exportiert, solltest du den **Code** prüfen, um zu verstehen, was er macht, und ihn **dynamisch** testen, um vertrauliche Informationen zu extrahieren, Authentifizierungsmaßnahmen zu umgehen...

[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Denke daran, dass die Aktionen eines Broadcast Receiver in der Methode `onReceive` beginnen.

Ein Broadcast Receiver wartet auf einen Nachrichtentyp. Je nachdem, wie der Receiver die Nachricht verarbeitet, kann er verwundbar sein.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Du kannst manuell nach deep links suchen, z. B. mit Tools wie MobSF oder Skripten wie [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Du kannst ein deklariertes **scheme** mit **adb** oder einem **browser** öffnen:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Beachte, dass du den Paketnamen **weglassen kannst** und das Mobilgerät automatisch die App aufruft, die den Link öffnen soll._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Auszuführender Code**

Um den **Code zu finden, der in der App ausgeführt wird**, gehe zur Activity, die durch den deep link aufgerufen wird, und suche die Funktion **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Sensible Informationen**

Jedes Mal, wenn du einen deep link findest, überprüfe, dass er **nicht sensitive Daten (wie Passwörter) über URL-Parameter empfängt**, denn jede andere Anwendung könnte den deep link **vortäuschen und diese Daten stehlen!**

**Parameter im Pfad**

Du **musst auch prüfen, ob ein deep link einen Parameter im Pfad** der URL verwendet, z. B.: `https://api.example.com/v1/users/{username}` , in diesem Fall kannst du eine path traversal erzwingen, indem du auf etwas wie zugreifst: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Beachte, dass du, wenn du die korrekten Endpunkte in der Anwendung findest, möglicherweise einen **Open Redirect** (wenn ein Teil des Pfads als Domainname verwendet wird), eine **account takeover** (wenn du Benutzerdetails ohne CSRF-Token ändern kannst und der vuln Endpoint die richtige Methode verwendet) und andere vuln verursachen kannst. Mehr [Info dazu hier](http://dphoeniixx.com/2020/12/13-2/).

**Weitere Beispiele**

Ein [interessanter bug bounty report](https://hackerone.com/reports/855618) über Links (_/.well-known/assetlinks.json_).

### Transport Layer-Inspektion und Verifizierungsfehler

- **Certificates are not always inspected properly** von Android-Anwendungen. Es ist üblich, dass diese Anwendungen Warnungen übersehen und selbstsignierte Zertifikate akzeptieren oder in manchen Fällen auf HTTP-Verbindungen zurückfallen.
- **Negotiations during the SSL/TLS handshake are sometimes weak**, es werden unsichere Cipher Suites verwendet. Diese Schwachstelle macht die Verbindung anfällig für man-in-the-middle (MITM)-Angriffe und ermöglicht es Angreifern, die Daten zu entschlüsseln.
- **Leakage of private information** ist ein Risiko, wenn Anwendungen sich über sichere Kanäle authentifizieren, aber anschließend für andere Transaktionen über nicht sichere Kanäle kommunizieren. Dieser Ansatz schützt sensitive Daten wie Session-Cookies oder Benutzerdetails nicht vor dem Abfangen durch bösartige Akteure.

#### Zertifikatsprüfung

Wir konzentrieren uns auf **certificate verification**. Die Integrität des Serverzertifikats muss verifiziert werden, um die Sicherheit zu erhöhen. Das ist entscheidend, da unsichere TLS-Konfigurationen und die Übertragung sensibler Daten über unverschlüsselte Kanäle erhebliche Risiken darstellen können. Für detaillierte Schritte zur Verifikation von Serverzertifikaten und zur Behebung von Schwachstellen bietet [**diese Ressource**](https://manifestsecurity.com/android-application-security-part-10/) umfassende Anleitung.

#### SSL Pinning

SSL Pinning ist eine Sicherheitsmaßnahme, bei der die Anwendung das Serverzertifikat gegen eine bekannte Kopie prüft, die innerhalb der Anwendung selbst gespeichert ist. Diese Methode ist essentiell, um MITM-Angriffe zu verhindern. Die Implementierung von SSL Pinning wird dringend für Anwendungen empfohlen, die sensitive Informationen verarbeiten.

#### Traffic-Inspektion

Um HTTP-Traffic zu inspizieren, ist es notwendig, **das Zertifikat des Proxy-Tools zu installieren** (z. B. Burp). Ohne die Installation dieses Zertifikats ist verschlüsselter Traffic möglicherweise nicht über den Proxy sichtbar. Für eine Anleitung zur Installation eines benutzerdefinierten CA-Zertifikats, [**klicke hier**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Anwendungen, die **API Level 24 and above** anvisieren, erfordern Änderungen an der Network Security Config, damit das CA-Zertifikat des Proxys akzeptiert wird. Dieser Schritt ist entscheidend, um verschlüsselten Traffic zu inspizieren. Für Anweisungen zur Änderung der Network Security Config, [**siehe dieses Tutorial**](make-apk-accept-ca-certificate.md).

Wenn **Flutter** verwendet wird, musst du die Anweisungen auf [**dieser Seite**](flutter.md) befolgen. Das liegt daran, dass das einfache Hinzufügen des Zertifikats in den Store nicht ausreicht, da Flutter seine eigene Liste gültiger CAs hat.

#### Statische Erkennung von SSL/TLS Pinning

Bevor du Runtime-Bypasses versuchst, solltest du schnell kartieren, wo Pinning im APK durchgesetzt wird. Statische Erkennung hilft dir, Hooks/Patches zu planen und dich auf die richtigen Codepfade zu konzentrieren.

Tool: SSLPinDetect
- Open-source static-analysis utility, das das APK zu Smali (via apktool) dekompiliert und nach kuratierten Regex-Mustern für SSL/TLS-Pinning-Implementierungen scannt.
- Gibt für jeden Treffer den exakten Dateipfad, die Zeilennummer und einen Codeausschnitt aus.
- Deckt gängige Frameworks und benutzerdefinierte Codepfade ab: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

Install
- Voraussetzungen: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Verwendung
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Beispiel-Musterregeln (JSON)
Verwenden oder erweitern Sie signatures, um proprietäre/benutzerdefinierte pinning-Stile zu erkennen. Sie können Ihr eigenes JSON laden und in großem Maßstab scannen.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes and tips
- Schnellscans bei großen Apps mittels Multithreading und speichergemapter I/O; vorkompilierte Regex reduzieren Overhead/Falschmeldungen.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Typische Erkennungsziele zur weiteren Triage:
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Declarative pins in res/xml network security config and manifest references
- Verwende die gefundenen Stellen, um Frida hooks, statische Patches oder Konfigurationsreviews vor dynamischen Tests zu planen.



#### Bypassing SSL Pinning

When SSL Pinning is implemented, it becomes necessary to inspect HTTPS traffic by bypassing it. Verschiedene Methoden stehen dafür zur Verfügung:

- Automatically **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Der größte Vorteil dieser Option ist, dass du kein root benötigst, um SSL Pinning zu bypassen, aber du musst die Anwendung löschen und die neue installieren, und das funktioniert nicht immer.
- Du könntest **Frida** (discussed below) verwenden, um diesen Schutz zu bypassen. Hier ein Guide zur Nutzung von Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- You can also try to **automatically bypass SSL Pinning** using [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- You can also try to **automatically bypass SSL Pinning** using **MobSF dynamic analysis** (explained below)
- Wenn du immer noch denkst, dass es Traffic gibt, den du nicht aufzeichnest, kannst du versuchen, den Traffic mit iptables an burp weiterzuleiten. Lies diesen Blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Looking for Common Web Vulnerabilities

Es ist wichtig, auch nach typischen Web-Schwachstellen innerhalb der Anwendung zu suchen. Detaillierte Informationen zur Identifikation und Behebung dieser Schwachstellen gehen über diese Zusammenfassung hinaus, sind aber an anderer Stelle umfassend dokumentiert.

### Frida

[Frida](https://www.frida.re) ist ein dynamisches Instrumentierungs-Toolkit für Entwickler, Reverse-Engineers und Sicherheitsforscher.\
**Du kannst laufende Anwendungen erreichen und Methoden zur Laufzeit hooken, um Verhalten zu ändern, Werte zu verändern, Werte zu extrahieren, anderen Code auszuführen...**\
Wenn du Android-Anwendungen pentest willst, musst du wissen, wie man Frida benutzt.

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Einige "GUI" für Aktionen mit Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection ist großartig, um die Nutzung von Frida zu automatisieren: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Du findest einige Awesome Frida scripts hier: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Versuche, Anti-Debugging / Anti-Frida-Mechanismen zu bypassen, indem du Frida wie in [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) gezeigt lädst (Tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Speicher auslesen - Fridump**

Überprüfe, ob die Anwendung sensible Informationen im Speicher ablegt, die sie nicht ablegen sollte, wie Passwörter oder Mnemonics.

Mit [**Fridump3**](https://github.com/rootbsd/fridump3) kannst du den Speicher der App mit:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Das wird den Speicher im Ordner ./dump dumpen, und dort könntest du mit etwas wie grep suchen:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Sensible Daten im Keystore**

In Android ist der Keystore der beste Ort, um sensible Daten zu speichern, jedoch ist es bei ausreichenden Privilegien immer noch **möglich, darauf zuzugreifen**. Da Anwendungen hier dazu neigen, **sensible Daten im Klartext** zu speichern, sollten pentests dies prüfen, da ein root user oder jemand mit physischem Zugriff auf das Gerät diese Daten stehlen könnte.

Selbst wenn eine App Daten im Keystore speichert, sollten diese verschlüsselt sein.

Um auf die Daten im Keystore zuzugreifen, kann man dieses Frida script verwenden: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Mit dem folgenden Frida-Skript könnte es möglich sein, die von Android-Anwendungen möglicherweise eingesetzte **bypass fingerprint authentication** zu umgehen, die dazu dient, bestimmte sensible Bereiche zu schützen:
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Background Images**

Wenn du eine Anwendung in den Hintergrund verschiebst, speichert Android einen **Snapshot der Anwendung**, sodass beim Wiederherstellen in den Vordergrund zuerst das Bild geladen wird, bevor die App startet, wodurch es so wirkt, als wäre die App schneller geladen.

Wenn dieser Snapshot jedoch **sensible Informationen** enthält, könnte jemand mit Zugriff auf den Snapshot diese Informationen **stehlen** (beachte, dass du root benötigst, um darauf zuzugreifen).

Die Snapshots werden normalerweise gespeichert unter: **`/data/system_ce/0/snapshots`**

Android bietet eine Möglichkeit, die **Aufnahme von Screenshots durch Setzen des FLAG_SECURE** Layout-Parameters zu verhindern. Durch die Verwendung dieses Flags werden die Fensterinhalte als sicher behandelt, wodurch verhindert wird, dass sie in Screenshots erscheinen oder auf nicht-sicheren Displays angezeigt werden.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Dieses Tool kann dir helfen, verschiedene Tools während der dynamic analysis zu verwalten: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Developers often create proxy components like activities, services, and broadcast receivers that handle these Intents and pass them to methods such as `startActivity(...)` or `sendBroadcast(...)`, which can be risky.

Die Gefahr besteht darin, dass Angreifer diese Intents fehlleiten und so nicht-exportierte App-Komponenten auslösen oder auf sensible content providers zugreifen können. Ein bemerkenswertes Beispiel ist die `WebView`-Komponente, die URLs über `Intent.parseUri(...)` in `Intent`-Objekte umwandelt und diese dann ausführt, was potenziell zu bösartigen Intent injections führen kann.

### Essential Takeaways

- **Intent Injection** ist ähnlich wie das Open Redirect-Problem im Web.
- Exploits beinhalten das Weitergeben von `Intent`-Objekten als Extras, die umgeleitet werden können, um unsichere Operationen auszuführen.
- Dadurch können non-exported components und content providers für Angreifer zugänglich gemacht werden.
- Die Konvertierung von URLs zu `Intent`-Objekten durch `WebView` kann unbeabsichtigte Aktionen ermöglichen.

### Android Client Side Injections and others

Wahrscheinlich kennst du diese Art von Schwachstellen aus dem Web. Bei Android-Anwendungen musst du bei diesen Schwachstellen besonders vorsichtig sein:

- **SQL Injection:** Wenn du mit dynamischen Queries oder Content-Providers arbeitest, stelle sicher, dass parameterisierte Abfragen verwendet werden.
- **JavaScript Injection (XSS):** Verify that JavaScript and Plugin support is disabled for any WebViews (disabled by default). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** Bei WebViews sollte der Zugriff auf das Dateisystem deaktiviert sein (standardmäßig aktiviert) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: In vielen Fällen wird beim Beenden der Android-Anwendung die Session-Cookie nicht widerrufen oder es kann sogar auf die Festplatte gespeichert werden.
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatische Analyse

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Statische Analyse**

![](<../../images/image (866).png>)

**Sicherheitsbewertung der Anwendung** mithilfe einer ansprechenden webbasierten Oberfläche. Du kannst auch dynamic analysis durchführen (du musst aber die Umgebung vorbereiten).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Unterstützte dynamische Analyse mit MobSF

**MobSF** kann auch sehr nützlich für **dynamic analysis** unter **Android** sein, aber in diesem Fall müssen Sie MobSF und **genymotion** auf Ihrem Host installieren (a **VM** or **Docker** won't work). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
Der **MobSF dynamic analyser** kann:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). All of this is done automatically except for the screenshots, you need to press when you want a screenshot or you need to press "**Exported Activity Tester**" to obtain screenshots of all the exported activities.
- Erfassen von **HTTPS traffic**
- Verwenden von **Frida**, um **Laufzeitinformationen** zu erhalten

Ab **Android versions > 5** wird es **automatically start Frida** und globale **proxy**-Einstellungen setzen, um den Traffic zu **capture**. Es wird nur den Traffic der getesteten Anwendung erfassen.

**Frida**

Standardmäßig werden auch einige Frida Scripts verwendet, um **bypass SSL pinning**, **root detection** und **debugger detection** zu umgehen und um **monitor interesting APIs**.\
MobSF kann außerdem **invoke exported activities**, **screenshots** davon erstellen und diese für den Report **save**.

Um das dynamische Testing zu **start**en, drücken Sie den grünen Button: "**Start Instrumentation**". Drücken Sie "**Frida Live Logs**", um die von den Frida-Scripts erzeugten Logs zu sehen, und "**Live API Monitor**", um alle Aufrufe zu gehookten Methoden, übergebene Argumente und Rückgabewerte zu sehen (dies erscheint nach dem Drücken von "Start Instrumentation").\
MobSF erlaubt Ihnen auch, eigene **Frida scripts** zu laden (um die Ergebnisse Ihrer Friday scripts an MobSF zu senden, benutzen Sie die Funktion `send()`). Es gibt auch **several pre-written scripts**, die Sie laden können (Sie können weitere in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/` hinzufügen), einfach **select them**, drücken Sie "**Load**" und dann "**Start Instrumentation**" (Sie können die Logs dieser Scripts in "**Frida Live Logs**" sehen).

![](<../../images/image (419).png>)

Zudem haben Sie einige zusätzliche Frida-Funktionalitäten:

- **Enumerate Loaded Classes**: Druckt alle geladenen Klassen
- **Capture Strings**: Gibt alle erfassten Strings während der Nutzung der Anwendung aus (sehr noisy)
- **Capture String Comparisons**: Kann sehr nützlich sein. Es wird **die 2 Strings zeigen, die verglichen wurden** und ob das Ergebnis True oder False war.
- **Enumerate Class Methods**: Geben Sie den Klassennamen ein (z. B. "java.io.File") und es werden alle Methoden der Klasse ausgegeben.
- **Search Class Pattern**: Sucht Klassen nach Pattern
- **Trace Class Methods**: **Trace** einer **ganzen Klasse** (zeigt Eingaben und Ausgaben aller Methoden der Klasse). Denken Sie daran, dass MobSF standardmäßig mehrere interessante Android API-Methoden traces.

Sobald Sie das Auxiliary-Modul ausgewählt haben, das Sie verwenden möchten, müssen Sie "**Start Intrumentation**" drücken und Sie werden alle Ausgaben in "**Frida Live Logs**" sehen.

**Shell**

MobSF stellt Ihnen außerdem eine Shell mit einigen **adb** commands, **MobSF commands**, und gängigen **shell** **commands** unten auf der Seite für dynamische Analyse zur Verfügung. Einige interessante commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP tools**

Wenn HTTP-Traffic erfasst wird, kannst du eine unansehnliche Ansicht des erfassten Traffics unten unter "**HTTP(S) Traffic**" sehen oder eine schönere Ansicht über die grüne Schaltfläche "**Start HTTPTools**". Bei der zweiten Option kannst du **send** die **captured requests** an **proxies** wie Burp oder Owasp ZAP.\
Um das zu tun: _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> drücke "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Sobald du die dynamic analysis mit MobSF abgeschlossen hast, kannst du auf "**Start Web API Fuzzer**" drücken, um **fuzz http requests** und nach Schwachstellen zu suchen.

> [!TIP]
> Nach Durchführung einer dynamic analysis mit MobSF können die Proxy-Einstellungen falsch konfiguriert sein und du wirst sie nicht über die GUI beheben können. Du kannst die Proxy-Einstellungen wie folgt reparieren:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis mit Inspeckage

Du kannst das Tool von [**Inspeckage**](https://github.com/ac-pm/Inspeckage) bekommen.\
Dieses Tool verwendet einige **Hooks**, um dir zu zeigen, **what is happening in the application**, während du eine **dynamic analysis** durchführst.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Dies ist ein **tolles Tool, um static analysis mit einer GUI durchzuführen**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Dieses Tool ist dafür konzipiert, nach verschiedenen **security related Android application vulnerabilities** zu suchen, entweder im **source code** oder in **packaged APKs**. Das Tool ist außerdem **capable of creating a "Proof-of-Concept" deployable APK** und **ADB commands**, um einige der gefundenen Schwachstellen auszunutzen (Exposed activities, intents, tapjacking...). Wie bei Drozer ist es nicht nötig, das Testgerät zu rooten.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Zeigt alle extrahierten Dateien zur einfachen Übersicht an
- Dekompliliert APK-Dateien automatisch in Java- und Smali-Format
- Analysiert AndroidManifest.xml auf häufige Schwachstellen und Verhalten
- Statische Quellcode-Analyse auf häufige Schwachstellen und Verhalten
- Geräteinformationen
- und mehr
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER ist eine Kommandozeilenanwendung, die unter Windows, MacOS X und Linux verwendet werden kann und _.apk_-Dateien nach Schwachstellen analysiert. Dazu werden APKs dekomprimiert und eine Reihe von Regeln angewendet, um diese Schwachstellen zu erkennen.

Alle Regeln sind in einer Datei `rules.json` zentralisiert, und jedes Unternehmen oder jeder Tester kann eigene Regeln erstellen, um gezielt das zu analysieren, was benötigt wird.

Lade die neuesten Binärdateien von der [download page](https://superanalyzer.rocks/download.html) herunter
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn ist ein **crossplatform**-Tool, das Entwickler, bugbounty hunters und ethical hackers bei der Durchführung von [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) an mobilen Anwendungen unterstützt.

Das Konzept besteht darin, dass Sie Ihre mobile Anwendungsdatei (eine .apk- oder .ipa-Datei) per Drag & Drop auf die StaCoAn-Anwendung ziehen; sie erzeugt dann einen visuellen und portablen Bericht für Sie. Sie können die Einstellungen und wordlists anpassen, um ein individuelles Erlebnis zu erhalten.

Herunterladen[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework ist ein System zur Analyse von Schwachstellen in Android-Anwendungen, das Entwicklern oder hackers dabei hilft, potenzielle Sicherheitslücken zu finden.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** ist ein Tool, dessen Hauptzweck darin besteht, potenziell bösartiges Verhalten einer Android-Anwendung zu erkennen und den Benutzer davor zu warnen.

Die Erkennung erfolgt durch die **static analysis** des Dalvik-Bytecodes der Anwendung, dargestellt als **Smali**, mithilfe der [`androguard`](https://github.com/androguard/androguard)-Bibliothek.

Dieses Tool sucht nach **häufigem Verhalten von "bösen" Anwendungen** wie: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. Es ist ein Tool, das häufig verwendete mobile Application reverse engineering und analysis Tools zusammenführt, um beim Testen mobiler Anwendungen gegen die OWASP mobile security threats zu unterstützen. Ziel ist es, diese Aufgabe für mobile Anwendungsentwickler und Sicherheitsexperten einfacher und benutzerfreundlicher zu gestalten.

It is able to:

- Extract Java and Smali code using different tools
- APKs analysieren mit: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Private Informationen aus dem APK mittels regexps extrahieren.
- Das Manifest analysieren.
- Gefundene Domains analysieren mit: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) und [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Nützlich zur Erkennung von Malware: [https://koodous.com/](https://koodous.com)

## Obfuscating/Deobfuscating code

Beachte, dass abhängig vom Service und der Konfiguration, die du zum Obfuskieren des Codes verwendest, Secrets möglicherweise obfuskiert sind oder nicht.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. Es kann Bytecode optimieren sowie ungenutzte Instruktionen erkennen und entfernen. ProGuard ist freie Software und wird unter der GNU General Public License, version 2 vertrieben.

ProGuard wird als Teil des Android SDK verteilt und läuft beim Erstellen der Anwendung im Release-Modus.

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Last time we checked, the Dexguard mode of operation was:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

Du kannst eine obfuskierte APK auf deren Plattform hochladen.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

Es ist ein **generic android deobfuscator.** Simplify **virtually executes an app** um ihr Verhalten zu verstehen und versucht dann, **tries to optimize the code** damit es sich identisch verhält, aber für einen Menschen leichter zu verstehen ist. Jede Optimierungsart ist einfach und generisch, daher spielt es keine Rolle, welche spezifische Art der Obfuskation verwendet wurde.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD gives you information about **how an APK was made**. Es identifiziert viele **compilers**, **packers**, **obfuscators**, und andere seltsame Dinge. It's [_PEiD_](https://www.aldeid.com/wiki/PEiD) for Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b ist eine Android security virtual machine basierend auf ubuntu-mate und enthält eine Sammlung der neuesten Frameworks, Tutorials und Labs von verschiedenen Security-Geeks und Forschern für reverse engineering und malware analysis.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) It is a great list of resources
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)

## Noch auszuprobieren

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
