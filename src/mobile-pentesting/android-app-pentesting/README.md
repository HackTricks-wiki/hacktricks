# Android 애플리케이션 Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android 애플리케이션 기본

이 페이지를 먼저 읽어 **Android 보안과 Android 애플리케이션에서 가장 중요한 부분 및 가장 위험한 구성요소**에 대해 알아보는 것을 강력히 권장합니다:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

이것은 에뮬레이터 또는 실제 Android 기기에 연결하는 데 필요한 주요 도구입니다.\
**ADB**는 컴퓨터에서 **USB** 또는 **Network**을 통해 기기를 제어할 수 있게 해줍니다. 이 유틸리티는 파일의 양방향 **복사**, 앱의 **설치** 및 **삭제**, 쉘 명령 **실행**, 데이터 **백업**, 로그 **읽기** 등 여러 기능을 제공합니다.

adb 사용법을 배우려면 다음 목록의 [**ADB Commands**](adb-commands.md)를 확인하세요.

## Smali

때때로 **애플리케이션 코드를 수정**하여 **숨겨진 정보**(예: 잘 난독화된 비밀번호나 플래그)에 접근하는 것이 흥미로울 수 있습니다. 이 경우 apk를 디컴파일하고 코드를 수정한 뒤 다시 컴파일하는 것이 유용할 수 있습니다.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). 이는 향후 제시될 동적 분석 중 여러 테스트의 **대안**으로 매우 유용할 수 있습니다. 따라서 항상 이 가능성을 **염두에 두세요**.

## 기타 흥미로운 트릭

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- 기기에서 APK 추출:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- 모든 splits 및 base apks를 [APKEditor](https://github.com/REAndroid/APKEditor)로 병합하세요:
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Android Enterprise & Work Profile 공격

{{#ref}}
android-enterprise-work-profile-bypass.md
{{#endref}}

## 사례 연구 & 취약점


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## 정적 분석

우선, APK를 분석할 때는 디컴파일러를 사용하여 Java 코드를 확인해야 합니다.\
[**다양한 사용 가능한 디컴파일러에 대한 정보를 보려면 여기를 읽으세요**](apk-decompilers.md).

### 유용한 정보 찾기

APK의 **strings**만 살펴봐도 **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** 등 흥미로운 항목을 찾을 수 있습니다... 코드 실행 **backdoors**나 인증 backdoor(앱에 하드코딩된 관리자 자격증명)도 확인하세요.

Firebase

특히 **Firebase URLs**에 주의를 기울이고 잘못 구성되어 있는지 확인하세요. [More information about whats is FIrebase and how to exploit it here.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### 애플리케이션의 기본 이해 - Manifest.xml, strings.xml

애플리케이션의 _Manifest.xml_ 및 _strings.xml_ 파일을 검사하면 잠재적 보안 취약점을 밝힐 수 있습니다. 이 파일들은 디컴파일러로 접근하거나 APK 파일 확장자를 .zip으로 변경한 다음 압축을 풀어 확인할 수 있습니다.

Manifest.xml에서 식별되는 **취약점**에는 다음이 포함됩니다:

- **Debuggable Applications**: _Manifest.xml_에서 `debuggable="true"`로 설정된 애플리케이션은 연결을 허용하여 악용될 위험이 있습니다. debuggable 애플리케이션을 찾고 악용하는 방법에 대한 튜토리얼을 참조하세요.
- **Backup Settings**: 민감한 정보를 다루는 애플리케이션에는 `android:allowBackup="false"` 속성을 명시적으로 설정해 두어야 합니다. 특히 usb debugging이 활성화된 경우 adb를 통한 무단 데이터 백업을 방지할 수 있습니다.
- **Network Security**: `android:networkSecurityConfig="@xml/network_security_config"`와 같은 커스텀 네트워크 보안 구성(res/xml/)은 certificate pin, HTTP 트래픽 설정 등 보안 세부사항을 지정할 수 있습니다. 예로 특정 도메인에 대해 HTTP 트래픽을 허용하는 설정이 있습니다.
- **Exported Activities and Services**: 매니페스트에서 exported된 활동(Activity)와 서비스(Service)를 식별하면 악용될 수 있는 컴포넌트를 확인할 수 있습니다. 동적 테스트 중 추가 분석을 통해 이러한 컴포넌트를 어떻게 악용할 수 있는지 드러날 수 있습니다.
- **Content Providers and FileProviders**: 노출된 content providers는 데이터에 대한 무단 접근이나 수정 허용으로 이어질 수 있습니다. FileProviders의 구성도 철저히 검토해야 합니다.
- **Broadcast Receivers and URL Schemes**: 이러한 컴포넌트는 악용될 가능성이 있으며, 특히 URL scheme이 입력에 대해 어떻게 처리되는지 주의 깊게 봐야 합니다.
- **SDK Versions**: `minSdkVersion`, `targetSDKVersion`, `maxSdkVersion` 속성은 지원되는 Android 버전을 나타내며, 구버전의 취약한 Android 버전을 지원하지 않는 것이 중요함을 보여줍니다.

**strings.xml** 파일에서는 API keys, custom schemas 및 기타 개발자 메모와 같은 민감한 정보를 발견할 수 있으므로 이러한 리소스를 꼼꼼히 검토해야 합니다.

### Tapjacking

**Tapjacking**은 악의적인 **application**이 실행되어 **피해자 application 위에 자신을 위치**시키는 공격입니다. 한 번 피해자 앱을 시각적으로 가리면, 악성 UI는 사용자를 속여 상호작용하게 만들고 그 상호작용을 피해자 앱으로 전달합니다.\
결과적으로 사용자는 자신이 실제로 피해자 앱에서 동작을 수행하고 있다는 사실을 알지 못하게 됩니다.

자세한 정보는 아래를 참조하세요:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

`launchMode`가 **`singleTask`**로 설정되어 있고 `taskAffinity`가 정의되어 있지 않은 **activity**는 Task Hijacking에 취약합니다. 이는 악성 **application**을 설치하고 실제 애플리케이션보다 먼저 실행하면 **실제 애플리케이션의 task를 hijack**할 수 있음을 의미합니다(사용자는 실제 앱을 사용하는 것이라 생각하면서 **악성 애플리케이션과 상호작용**하게 됩니다).

자세한 내용은:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Insecure data storage

Internal Storage

Android에서 내부 저장소에 저장된 파일은 일반적으로 해당 파일을 생성한 앱만 접근할 수 있도록 설계되어 있으며, 운영체제가 이를 강제합니다. 그러나 개발자가 때때로 `MODE_WORLD_READABLE` 및 `MODE_WORLD_WRITABLE`와 같은 모드를 사용하여 파일을 다른 앱과 공유하도록 허용하는 경우가 있습니다. 이들 모드는 잠재적으로 악의적인 앱을 포함한 다른 앱에 의해 해당 파일에 대한 접근을 제한하지 않습니다.

1. Static Analysis:
- `MODE_WORLD_READABLE` 및 `MODE_WORLD_WRITABLE`의 사용을 신중하게 검토하세요. 이러한 모드는 파일을 의도치 않거나 무단 접근에 노출시킬 수 있습니다.
2. Dynamic Analysis:
- 앱이 생성한 파일에 설정된 권한을 확인하세요. 특히 어떤 파일이 전세계적으로 읽기 또는 쓰기가 가능하도록 설정되어 있는지 점검하세요. 이는 어떤 애플리케이션이든 디바이스에 설치되어 있으면 해당 파일을 읽거나 수정할 수 있게 하여 심각한 보안 위험을 초래할 수 있습니다.

External Storage

SD Card와 같은 외부 저장소의 파일을 다룰 때는 다음을 주의하세요:

1. 접근성:
- 외부 저장소의 파일은 전역적으로 읽기 및 쓰기가 가능합니다. 즉, 어떤 애플리케이션이나 사용자라도 접근할 수 있습니다.
2. 보안 문제:
- 접근이 쉬우므로 민감한 정보를 외부 저장소에 저장하지 않는 것이 권장됩니다.
- 외부 저장소는 제거되거나 어떤 애플리케이션에서도 접근 가능하므로 보안성이 낮습니다.
3. 외부 저장소에서 가져온 데이터 처리:
- 외부 저장소에서 가져온 데이터는 신뢰할 수 없는 소스이므로 항상 입력 검증을 수행하세요.
- 외부 저장소에 실행 파일이나 class 파일을 저장해 동적으로 로드하는 것은 강력히 권장되지 않습니다.
- 애플리케이션이 외부 저장소에서 실행 파일을 가져와야 하는 경우, 해당 파일이 동적으로 로드되기 전에 서명되고 암호학적으로 검증되었는지 확인하세요. 이는 애플리케이션의 보안 무결성을 유지하는 데 중요합니다.

외부 저장소는 /storage/emulated/0 , /sdcard , /mnt/sdcard 경로로 접근할 수 있습니다.

> [!TIP]
> Android 4.4 (**API 17**)부터 SD 카드에는 앱 전용 디렉터리 구조가 있어 앱이 해당 앱 전용 디렉터리로만 접근할 수 있도록 제한합니다. 이는 악의적인 애플리케이션이 다른 앱의 파일을 읽거나 쓸 수 없도록 방지합니다.

평문으로 저장된 민감한 데이터

- **Shared preferences**: Android는 각 애플리케이션이 `/data/data/<packagename>/shared_prefs/` 경로에 xml 파일을 쉽게 저장할 수 있도록 하며, 때로는 이 폴더에서 평문으로 된 민감한 정보를 찾을 수 있습니다.
- **Databases**: Android는 각 애플리케이션이 `/data/data/<packagename>/databases/` 경로에 sqlite 데이터베이스를 쉽게 저장할 수 있도록 하며, 때로는 이 폴더에서 평문으로 된 민감한 정보를 찾을 수 있습니다.

### Broken TLS

Accept All Certificates

어떤 이유에서인지 개발자들이 hostname이 일치하지 않더라도 모든 인증서를 수락하는 경우가 있으며, 예를 들어 다음과 같은 코드 라인에서 볼 수 있습니다:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### 취약한 암호화

**열악한 키 관리 프로세스**

일부 개발자는 민감한 데이터를 로컬 스토리지에 저장하고 코드에 하드코딩되었거나 예측 가능한 키로 암호화합니다. 이렇게 해서는 안 되며, 리버싱을 통해 공격자가 기밀 정보를 추출할 수 있습니다.

**보안에 취약하거나 더 이상 권장되지 않는 알고리즘의 사용**

개발자는 권한 부여 **checks**, 데이터 **store** 또는 **send**에 **deprecated algorithms**를 사용해서는 안 됩니다. 이러한 알고리즘의 예로는 RC4, MD4, MD5, SHA1 등이 있습니다. 예를 들어 비밀번호 저장에 **hashes**를 사용하는 경우, salt와 함께 **brute-force resistant**한 해시를 사용해야 합니다.

### 기타 점검사항

- 공격자의 리버스 엔지니어링 작업을 어렵게 하기 위해 **obfuscate the APK** 하는 것이 권장됩니다.
- 앱이 민감한 경우(예: bank apps)에는 모바일이 **rooted** 되었는지 **자체적으로 확인**하고 그에 따라 동작해야 합니다.
- 앱이 민감한 경우(예: bank apps)는 **emulator** 사용 여부를 확인해야 합니다.
- 앱이 민감한 경우(예: bank apps)는 **실행 전에 자체 무결성 검증을 수행하여** 수정되었는지 확인해야 합니다.
- 어떤 컴파일러/패커/난독화기가 APK 빌드에 사용되었는지 확인하려면 [**APKiD**](https://github.com/rednaga/APKiD)를 사용하세요.

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

도구 [**mariana-trench**](https://github.com/facebook/mariana-trench)는 애플리케이션의 **코드**를 **스캔**하여 **취약점**을 찾아낼 수 있습니다. 이 도구는 **known sources**(사용자에 의해 **입력**이 **제어되는 장소**를 도구에 알려주는 것), **sinks**(악의적인 사용자 입력이 피해를 줄 수 있는 **위험한 장소**) 및 **rules**의 집합을 포함합니다. 이러한 규칙들은 취약점을 나타내는 **sources-sinks** 조합을 지정합니다.

이 지식을 바탕으로 **mariana-trench는 코드를 검토하여 가능한 취약점을 찾아냅니다**.

### Secrets leaked

애플리케이션에는 API 키, 비밀번호, 숨겨진 URL, 서브도메인 등과 같은 secrets가 포함되어 있을 수 있으며, 이를 발견할 수 있습니다. 예를 들어 다음과 같은 도구를 사용할 수 있습니다: [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)
- In-memory native code execution via JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## 동적 분석

> 우선, 애플리케이션을 설치하고 모든 환경(Burp CA cert, Drozer 및 Frida 등)을 구성할 수 있는 환경이 필요합니다. 따라서 루팅된 장치(에뮬레이트 여부 무관)를 강력히 권장합니다.

### Online Dynamic analysis

무료 계정을 생성할 수 있는 서비스: [https://appetize.io/](https://appetize.io). 이 플랫폼은 APK를 **업로드**하고 **실행**할 수 있게 해 주므로 APK의 동작을 확인하는 데 유용합니다.

웹에서 **애플리케이션 로그를 확인**하거나 **adb**를 통해 연결할 수도 있습니다.

![](<../../images/image (831).png>)

ADB 연결 덕분에 에뮬레이터 내부에서 **Drozer**와 **Frida**를 사용할 수 있습니다.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (You can create **x86** and **arm** devices, and according to [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** versions **support ARM libraries** without needing an slow arm emulator).
- Learn to set it up in this page:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, you need to create an account. _It's recommend to **download** the version **WITH**_ _**VirtualBox** to avoid potential errors._)
- [**Nox**](https://es.bignox.com) (Free, but it doesn't support Frida or Drozer).

> [!TIP]
> 새로운 에뮬레이터를 생성할 때 화면이 클수록 에뮬레이터가 느려집니다. 가능하면 작은 화면을 선택하세요.

Genymotion에 google services(AppStore 등)를 설치하려면 다음 이미지에서 빨간색으로 표시된 버튼을 클릭해야 합니다:

![](<../../images/image (277).png>)

또한, **Genymotion의 Android VM 설정**에서 **Bridge Network mode**를 선택할 수 있으니(다른 VM에서 해당 Android VM에 도구로 접근할 경우 유용) 확인하세요.

#### Use a physical device

디버깅 옵션을 활성화해야 하며 가능하면 **root** 하는 것이 좋습니다:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> 애플리케이션을 설치한 후 가장 먼저 해야 할 일은 앱을 직접 사용해보고 무엇을 하는지, 어떻게 동작하는지 파악하여 익숙해지는 것입니다.\
> 초기 동적 분석은 MobSF dynamic analysis + pidcat을 사용하여 수행하는 것을 권장합니다. 이렇게 하면 MobSF가 나중에 검토할 수 있는 많은 **유용한 데이터**를 캡처하는 동안 애플리케이션이 어떻게 동작하는지 배울 수 있습니다.

Magisk/Zygisk 빠른 메모(특히 Pixel 기기 권장)
- Magisk 앱으로 boot.img를 패치하고 fastboot로 플래시하여 systemless root 획득
- Zygisk 활성화 + DenyList로 루트 숨김; 더 강력한 숨김이 필요하면 LSPosed/Shamiko 고려
- OTA 업데이트에서 복구할 수 있도록 원본 boot.img 보관; OTA 후 재패치 필요
- 화면 미러링은 호스트에서 scrcpy 사용

### Unintended Data Leakage

**Logging**

개발자는 **debugging information**을 공개적으로 노출하지 않도록 주의해야 합니다. 이는 민감한 데이터의 leak로 이어질 수 있습니다. 애플리케이션 로그를 모니터링하여 민감한 정보를 식별 및 보호하기 위해 도구 [**pidcat**](https://github.com/JakeWharton/pidcat) 및 `adb logcat`을 권장합니다. **Pidcat**은 사용 편의성과 가독성 때문에 선호됩니다.

> [!WARNING]
> Android 4.0 이후 버전에서는 **애플리케이션이 자신의 로그에만 접근할 수 있습니다**. 즉, 다른 앱의 로그에 접근할 수 없습니다.\
> 그럼에도 불구하고 민감한 정보를 로그에 남기지 않는 것이 권장됩니다.

**Copy/Paste Buffer Caching**

Android의 **clipboard-based** 프레임워크는 앱에서 복사-붙여넣기 기능을 가능하게 하지만, **다른 애플리케이션**이 클립보드에 접근할 수 있어 민감한 데이터가 노출될 위험이 있습니다. 신용카드 정보와 같은 민감한 섹션에 대해 복사/붙여넣기 기능을 비활성화하는 것이 중요합니다.

**Crash Logs**

애플리케이션이 **crashes**하여 로그를 저장하는 경우, 이러한 로그는 특히 애플리케이션을 리버스 엔지니어링하기 어려울 때 공격자에게 도움이 될 수 있습니다. 이 위험을 완화하려면 충돌 시 로깅을 피하고, 네트워크를 통해 로그를 전송해야 하는 경우 SSL 채널을 통해 전송하도록 하세요.

Pentester로서, **이러한 로그를 확인**해 보세요.

**Analytics Data Sent To 3rd Parties**

애플리케이션은 종종 Google Adsense와 같은 서비스를 통합하며, 잘못 구현된 경우 민감한 데이터가 제3자에게 우발적으로 leak될 수 있습니다. 잠재적 데이터 누수를 식별하려면 애플리케이션의 트래픽을 가로채고 제3자 서비스로 전송되는 민감한 정보가 있는지 확인하는 것이 좋습니다.

### SQLite DBs

대부분의 애플리케이션은 정보를 저장하기 위해 **internal SQLite databases**를 사용합니다. 펜테스트 중에 생성된 **데이터베이스**, **테이블 이름** 및 **컬럼**, 그리고 저장된 **모든 데이터**를 확인하세요. 민감한 정보가 발견될 수 있습니다(이는 취약점이 될 수 있음).\
데이터베이스는 일반적으로 `/data/data/the.package.name/databases`에 위치하며, 예: `/data/data/com.mwr.example.sieve/databases`

데이터베이스가 기밀 정보를 암호화하고 있더라도, 애플리케이션 내부에서 암호를 찾을 수 있다면 이는 여전히 **취약점**입니다.

테이블을 나열하려면 `.tables`를 사용하고, 테이블의 컬럼을 나열하려면 `.schema <table_name>`을 사용하세요.

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer is s useful tool to **exploit exported activities, exported services and Content Providers** as you will learn in the following sections.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
또한 Activity의 코드는 **`onCreate`** 메서드에서 시작된다는 점을 기억하세요.

**Authorisation bypass**

Activity가 exported되어 있으면 외부 앱에서 해당 화면을 호출할 수 있습니다. 따라서 **민감한 정보**를 노출하는 Activity가 **exported**되어 있으면 인증 메커니즘을 **bypass**하여 접근할 수 있습니다.

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

또한 adb에서 exported activity를 시작할 수 있습니다:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> authorisation bypass는 항상 취약점이 되는 것은 아니며, 우회 방식과 어떤 정보가 노출되는지에 따라 달라집니다.

**민감한 정보 누출**

**액티비티는 결과를 반환할 수도 있습니다**. 만약 export되어 있고 보호되지 않은 액티비티가 **`setResult`** 메서드를 호출하고 **민감한 정보를 반환**한다면, 민감한 정보 누출이 발생합니다.

#### Tapjacking

tapjacking이 방지되지 않으면 export된 액티비티를 악용하여 **사용자에게 예상치 못한 동작을 수행하게 만들 수 있습니다**. For more info about [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers는 기본적으로 **데이터를 공유**하는 데 사용됩니다. 앱에 Content providers가 존재하면 그들로부터 **민감한 데이터를 추출**할 수 있을지도 모릅니다. 또한 취약할 수 있으므로 가능한 **SQL injections** 및 **Path Traversals**를 테스트해보는 것도 중요합니다.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Service의 동작은 `onStartCommand` 메서드에서 시작된다는 것을 기억하세요.

Service는 기본적으로 데이터를 **수신**하고 이를 **처리**하며 (또는 하지 않고) **응답을 반환**하는 기능입니다. 따라서 애플리케이션이 서비스를 export하고 있다면 무엇을 하는지 이해하기 위해 **코드**를 **검토**하고 기밀 정보를 추출하거나 인증을 우회하는 등의 목적으로 동적으로 **테스트**해야 합니다.\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Broadcast Receiver의 동작은 `onReceive` 메서드에서 시작된다는 것을 기억하세요.

브로드캐스트 리시버는 특정 유형의 메시지를 기다립니다. 리시버가 메시지를 처리하는 방식에 따라 취약할 수 있습니다.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

You can look for deep links manually, using tools like MobSF or scripts like [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
선언된 **scheme**을 **adb**나 **browser**로 **열 수 있습니다**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_패키지 이름을 **생략할 수 있으며**, 모바일이 해당 링크를 열 앱을 자동으로 호출합니다._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**실행되는 코드**

앱에서 실행될 **코드**를 찾으려면 deeplink에 의해 호출되는 activity로 이동하여 함수 **`onNewIntent`**를 검색하세요.

![](<../../images/image (436) (1) (1) (1).png>)

**민감한 정보**

deep link를 찾을 때마다, **앱이 URL 매개변수로 민감한 데이터(예: 비밀번호)를 받고 있지 않은지 확인하세요**, 왜냐하면 다른 어떤 애플리케이션도 **deep link를 사칭하여 그 데이터를 훔칠 수 있기 때문입니다!**

**Parameters in path**

You **must check also if any deep link is using a parameter inside the path** of the URL like: `https://api.example.com/v1/users/{username}` , in that case you can force a path traversal accessing something like: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Note that if you find the correct endpoints inside the application you may be able to cause a **Open Redirect** (if part of the path is used as domain name), **account takeover** (if you can modify users details without CSRF token and the vuln endpoint used the correct method) and any other vuln. More [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### 전송 계층 검사 및 검증 실패

- **Certificates are not always inspected properly** by Android applications. 이러한 애플리케이션은 경고를 무시하고 self-signed certificates를 허용하거나, 경우에 따라 HTTP 연결로 되돌아가는 경우가 종종 있습니다.
- **Negotiations during the SSL/TLS handshake are sometimes weak**, 취약한 cipher suites를 사용합니다. 이 취약점은 연결을 man-in-the-middle (MITM) 공격에 취약하게 만들어 공격자가 데이터를 복호화할 수 있게 합니다.
- **Leakage of private information**은 애플리케이션이 보안 채널로 인증을 수행한 후 다른 트랜잭션에서는 비보안 채널로 통신할 때 발생할 수 있는 위험입니다. 이 접근법은 세션 쿠키나 사용자 정보와 같은 민감한 데이터를 악의적인 주체가 가로채지 못하도록 보호하는 데 실패합니다.

#### Certificate Verification

우리는 **certificate verification**에 집중할 것입니다. 서버 인증서의 무결성을 검증하는 것은 보안을 강화하는 데 중요합니다. 이는 insecure TLS 구성과 민감한 데이터를 암호화되지 않은 채널로 전송하는 것이 심각한 위험을 초래할 수 있기 때문입니다. 서버 인증서를 검증하고 취약점을 해결하는 상세한 단계는 [**this resource**](https://manifestsecurity.com/android-application-security-part-10/)에서 포괄적으로 안내하고 있습니다.

#### SSL Pinning

SSL Pinning은 애플리케이션이 서버의 인증서를 애플리케이션 자체에 저장된 알려진 사본과 대조하여 검증하는 보안 조치입니다. 이 방법은 MITM 공격을 방지하는 데 필수적입니다. 민감한 정보를 다루는 애플리케이션에는 SSL Pinning 구현을 강력히 권장합니다.

#### Traffic Inspection

HTTP 트래픽을 검사하려면 proxy 도구의 인증서(예: Burp)를 **설치**해야 합니다. 이 인증서를 설치하지 않으면 암호화된 트래픽이 프록시를 통해 보이지 않을 수 있습니다. custom CA certificate 설치 가이드는 [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine)를 참조하세요.

Applications targeting **API Level 24 and above**은 proxy의 CA 인증서를 수락하도록 Network Security Config를 수정해야 합니다. 이 단계는 암호화된 트래픽을 검사하는 데 중요합니다. Network Security Config 수정 방법은 [**refer to this tutorial**](make-apk-accept-ca-certificate.md)를 참고하세요.

If **Flutter** is being used you need to to follow the instructions in [**this page**](flutter.md). 이는 단순히 인증서를 스토어에 추가하는 것만으로는 작동하지 않기 때문이며, Flutter는 자체적인 유효 CA 목록을 가지고 있습니다.

#### SSL/TLS pinning의 정적 탐지

런타임 우회를 시도하기 전에, APK에서 pinning이 어디에 적용되는지 빠르게 매핑하세요. 정적 탐지는 훅/패치 계획을 세우고 올바른 코드 경로에 집중하는 데 도움이 됩니다.

Tool: SSLPinDetect
- Open-source static-analysis utility that decompiles the APK to Smali (via apktool) and scans for curated regex patterns of SSL/TLS pinning implementations.
- Reports exact file path, line number, and a code snippet for each match.
- Covers common frameworks and custom code paths: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

설치
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
사용법
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
예제 패턴 규칙 (JSON)
signatures를 사용하거나 확장하여 독점형/맞춤형 pinning 스타일을 탐지하세요. 자신만의 JSON을 로드하여 대규모로 스캔할 수 있습니다.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
노트 및 팁
- 멀티스레딩 및 메모리 매핑 I/O를 통해 대형 앱을 빠르게 스캔하세요; 미리 컴파일된 정규식은 오버헤드와 오탐을 줄여줍니다.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- 다음으로 우선순위를 두고 조사할 일반적인 탐지 대상:
- OkHttp: CertificatePinner 사용, setCertificatePinner, okhttp3/okhttp 패키지 참조
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted 오버라이드
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init 를 커스텀 매니저와 함께 사용
- res/xml의 network security config에 선언된 pins 및 manifest 참조
- 매칭된 위치를 사용해 동적 테스트 전에 Frida 훅, 정적 패치 또는 설정 검토를 계획하세요.



#### SSL Pinning 우회

SSL Pinning이 구현되어 있을 경우 HTTPS 트래픽을 검사하려면 이를 우회해야 합니다. 이를 위한 다양한 방법이 있습니다:

- Automatically **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). The best pro of this option, is that you won't need root to bypass the SSL Pinning, but you will need to delete the application and reinstall the new one, and this won't always work.
- You could use **Frida** (discussed below) to bypass this protection. Here you have a guide to use Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- You can also try to **automatically bypass SSL Pinning** using [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- You can also try to **automatically bypass SSL Pinning** using **MobSF dynamic analysis** (explained below)
- If you still think that there is some traffic that you aren't capturing you can try to **forward the traffic to burp using iptables**. Read this blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### 일반적인 웹 취약점 찾기

애플리케이션 내에서 일반적인 웹 취약점도 함께 찾아보는 것이 중요합니다. 이러한 취약점을 식별하고 완화하는 방법에 대한 자세한 정보는 이 요약의 범위를 벗어나지만 다른 곳에 광범위하게 다뤄져 있습니다.

### Frida

[Frida](https://www.frida.re) 는 개발자, 리버스 엔지니어 및 보안 연구원을 위한 동적 계측 툴킷입니다.\
**실행 중인 애플리케이션에 접근하여 런타임에 메서드를 훅(hook)해 동작을 변경하거나, 값 변경/추출, 다른 코드 실행 등을 할 수 있습니다.**\
Android 애플리케이션을 pentest하려면 Frida 사용법을 알아야 합니다.

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Some "GUI" for actions with Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- You can find some Awesome Frida scripts here: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Try to bypass anti-debugging / anti-frida mechanisms loading Frida as in indicated in [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning 우회 워크플로우

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **메모리 덤프 - Fridump**

애플리케이션이 비밀번호나 니모닉 같은 메모리에 저장하면 안 되는 민감한 정보를 메모리에 저장하고 있는지 확인하세요.

Using [**Fridump3**](https://github.com/rootbsd/fridump3) you can dump the memory of the app with:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
이 명령은 ./dump 폴더에 메모리를 덤프하며, 그 안에서 다음과 같이 grep할 수 있습니다:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Keystore의 민감한 데이터**

Android에서 Keystore는 민감한 데이터를 저장하기에 가장 좋은 장소이지만, 충분한 권한이 있으면 여전히 **접근이 가능하다**. 애플리케이션들은 여기 **clear text로 저장된 민감한 데이터**를 보관하는 경향이 있기 때문에 pentests는 root user로 확인해야 하며 기기에 물리적 접근권을 가진 누군가가 이 데이터를 훔칠 수 있다.

앱이 keystore에 데이터를 저장하더라도, 그 데이터는 암호화되어 있어야 한다.

keystore 내부의 데이터에 접근하려면 다음 Frida script를 사용할 수 있다: https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

다음 Frida 스크립트를 사용하면 Android 애플리케이션이 **특정 민감 영역을 보호하기 위해** 사용하는 지문 인증을 **bypass fingerprint authentication** 할 수 있습니다:
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **백그라운드 이미지**

애플리케이션을 백그라운드로 보내면, Android는 **애플리케이션의 스냅샷**을 저장합니다. 앱이 포그라운드로 복원될 때 앱이 로드되기 전에 이미지를 먼저 불러와 앱이 더 빠르게 로드된 것처럼 보이게 하기 위함입니다.

그러나 이 스냅샷에 **민감한 정보**가 포함되어 있으면, 스냅샷에 접근할 수 있는 누군가가 그 정보를 **탈취할 수 있습니다** (접근하려면 root 권한이 필요하다는 점에 유의하세요).

스냅샷은 일반적으로 다음 경로에 저장됩니다: **`/data/system_ce/0/snapshots`**

Android는 레이아웃 파라미터인 FLAG_SECURE를 설정하여 **스크린샷 캡처를 방지하는 방법**을 제공합니다. 이 플래그를 사용하면 창 내용이 보안 처리되어 스크린샷에 나타나거나 비보안 디스플레이에서 보이는 것을 방지합니다.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android 애플리케이션 분석기**

이 도구는 동적 분석(dynamic analysis) 동안 다양한 도구를 관리하는 데 도움이 될 수 있습니다: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

개발자는 종종 activities, services, broadcast receivers와 같은 프록시 컴포넌트를 생성하여 이러한 Intents를 처리하고 `startActivity(...)` 또는 `sendBroadcast(...)`와 같은 메서드로 전달하는데, 이는 위험할 수 있습니다.

위험은 공격자가 이러한 Intents를 오도하여 non-exported 앱 컴포넌트를 트리거하거나 민감한 content providers에 접근할 수 있게 하는 데 있습니다. 대표적인 예로 `WebView` 컴포넌트가 URL을 `Intent.parseUri(...)`를 통해 `Intent` 객체로 변환하고 이를 실행함으로써 악의적인 Intent injections로 이어질 수 있습니다.

### 핵심 요점

- **Intent Injection**는 웹의 Open Redirect 문제와 유사합니다.
- Exploits는 `Intent` 객체를 extras로 전달하여 리다이렉트되어 안전하지 않은 동작을 실행하도록 만들 수 있습니다.
- 공격자에게 non-exported 컴포넌트와 content providers를 노출시킬 수 있습니다.
- `WebView`의 URL → `Intent` 변환은 의도치 않은 동작을 유발할 수 있습니다.

### Android 클라이언트 측 Injections 및 기타

아마 웹에서 이런 유형의 취약점을 알고 있을 것입니다. Android 애플리케이션에서는 다음과 같은 취약점들에 특히 주의해야 합니다:

- **SQL Injection:** 동적 쿼리나 Content-Providers를 다룰 때는 파라미터화된 쿼리(parameterized queries)를 사용하고 있는지 확인하세요.
- **JavaScript Injection (XSS):** 모든 WebView에서 JavaScript 및 Plugin 지원이 비활성화되어 있는지 확인하세요(기본적으로 비활성화되어 있음). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebView는 파일 시스템 접근을 비활성화해야 합니다(기본값: 활성화) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: 몇몇 경우 Android 애플리케이션이 세션을 종료할 때 쿠키가 폐기되지 않거나 디스크에 저장될 수 있습니다
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## 자동 분석

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**정적 분석**

![](<../../images/image (866).png>)

**Vulnerability assessment of the application** using a nice web-based frontend. You can also perform dynamic analysis (but you need to prepare the environment).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Assisted Dynamic analysis with MobSF

**MobSF** can also be very helpful for **dynamic analysis** in **Android**, but in that case you will need to install MobSF and **genymotion** in your host (a VM or Docker won't work). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
The **MobSF dynamic analyser** can:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). All of this is done automatically except for the screenshots, you need to press when you want a screenshot or you need to press "**Exported Activity Tester**" to obtain screenshots of all the exported activities.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: It will print all the loaded classes
- **Capture Strings**: It will print all the capture strings while using the application (super noisy)
- **Capture String Comparisons**: Could be very useful. It will **show the 2 strings being compared** and if the result was True or False.
- **Enumerate Class Methods**: Put the class name (like "java.io.File") and it will print all the methods of the class.
- **Search Class Pattern**: Search classes by pattern
- **Trace Class Methods**: **Trace** a **whole class** (see inputs and outputs of all methods of th class). Remember that by default MobSF traces several interesting Android Api methods.

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf also brings you a shell with some **adb** commands, **MobSF commands**, and common **shell** **commands** at the bottom of the dynamic analysis page. Some interesting commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP 도구**

When http traffic is capture you can see an ugly view of the captured traffic on "**HTTP(S) Traffic**" bottom or a nicer view in "**Start HTTPTools**" green bottom. From the second option, you can **send** the **captured requests** to **proxies** like Burp or Owasp ZAP.\
To do so, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> press "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

MobSF로 동적 분석을 완료하면 "**Start Web API Fuzzer**"를 눌러 http 요청을 **fuzz**하고 취약점을 찾아볼 수 있습니다.

> [!TIP]
> MobSF로 동적 분석을 수행한 후에는 프록시 설정이 잘못 구성되어 GUI에서 수정할 수 없게 될 수 있습니다. 다음 명령으로 프록시 설정을 수정할 수 있습니다:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Inspeckage를 이용한 보조 동적 분석

도구는 [**Inspeckage**](https://github.com/ac-pm/Inspeckage)에서 얻을 수 있습니다.\
이 도구는 몇몇 **Hooks**를 사용하여 동적 분석을 수행하는 동안 애플리케이션에서 **무슨 일이 일어나고 있는지** 알려줍니다.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

GUI로 정적 분석을 수행하기에 **훌륭한 도구**입니다

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

이 도구는 **보안 관련 Android application 취약점**을 소스 코드 또는 패키지된 APK에서 찾아내도록 설계되었습니다. 또한 도구는 일부 발견된 취약점(Exposed activities, intents, tapjacking...)을 악용하기 위한 "Proof-of-Concept" 배포 가능한 APK와 **ADB commands**를 생성할 수 있습니다. Drozer와 마찬가지로 테스트 기기를 루팅할 필요는 없습니다.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- 모든 추출된 파일을 쉽게 참조할 수 있도록 표시
- APK 파일을 자동으로 Java 및 Smali 형식으로 디컴파일
- AndroidManifest.xml을 분석하여 일반적인 취약점 및 동작을 검사
- 정적 소스 코드 분석을 통해 일반적인 취약점 및 동작을 검사
- 장치 정보
- 등
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER는 Windows, MacOS X 및 Linux에서 사용할 수 있는 명령줄 애플리케이션으로, 취약점을 찾기 위해 _.apk_ 파일을 분석합니다. 이 도구는 APK를 압축 해제하고 일련의 규칙을 적용하여 취약점을 탐지합니다.

모든 규칙은 `rules.json` 파일에 중심화되어 있으며, 각 회사나 테스터는 필요한 분석을 위해 자체 규칙을 생성할 수 있습니다.

최신 바이너리는 [download page](https://superanalyzer.rocks/download.html)에서 다운로드하세요.
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn은 모바일 애플리케이션에 대해 [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis)를 수행하는 개발자, bugbounty hunters 및 ethical hackers를 돕는 **crossplatform** 도구입니다.

개념은 모바일 애플리케이션 파일(.apk 또는 .ipa 파일)을 StaCoAn 애플리케이션에 드래그 앤 드롭하면 시각적이고 휴대 가능한 리포트를 생성해 준다는 것입니다. 설정과 wordlists를 조정하여 맞춤형 경험을 얻을 수 있습니다.

다운로드[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework은 Android 애플리케이션에서 잠재적인 보안 취약점을 개발자나 hackers가 찾아내도록 돕는 Android 취약점 분석 시스템입니다.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn**은 Android 애플리케이션이 수행할 수 있는 잠재적 악성 동작을 탐지하고 사용자에게 경고하는 것을 주목적으로 하는 도구입니다.

탐지는 [`androguard`](https://github.com/androguard/androguard) 라이브러리를 사용하여 애플리케이션의 Dalvik bytecode(**Smali**로 표현된)에 대해 **static analysis**으로 수행됩니다.

이 도구는 다음과 같은 **"나쁜" 애플리케이션의 일반적인 동작**을 찾아냅니다: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA**는 **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework입니다. 자주 사용되는 모바일 애플리케이션 리버스 엔지니어링 및 분석 도구들을 모아 OWASP 모바일 보안 위협에 대해 모바일 애플리케이션을 테스트하는 데 도움을 주는 도구입니다. 목표는 이 작업을 모바일 애플리케이션 개발자와 보안 전문가에게 더 쉽고 친숙하게 만드는 것입니다.

다음 기능을 제공합니다:

- 다양한 도구를 사용해 Java 및 Smali 코드를 추출
- APK를 다음 도구들로 분석: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- 정규표현식으로 APK에서 민감 정보 추출
- Manifest 분석
- 발견된 도메인을 다음으로 분석: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) 및 [whatweb](https://github.com/urbanadventurer/WhatWeb)
- [apk-deguard.com](http://www.apk-deguard.com)을 통한 APK deobfuscate

### Koodous

악성코드 탐지에 유용: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

코드를 난독화하는 데 사용하는 서비스와 설정에 따라 비밀(Secrets)이 난독화될 수도 있고 그렇지 않을 수도 있다는 점에 유의하세요.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard**는 Java 코드를 축소(shrink), 최적화(optimize) 및 난독화(obfuscate)하는 오픈 소스 커맨드라인 도구입니다. 바이트코드를 최적화하고 사용되지 않는 명령을 감지 및 제거할 수 있습니다. ProGuard는 자유 소프트웨어이며 GNU General Public License 버전 2 아래에서 배포됩니다.

ProGuard는 Android SDK의 일부로 배포되며 release 모드로 애플리케이션을 빌드할 때 실행됩니다.

### [DexGuard](https://www.guardsquare.com/dexguard)

Deobfuscate된 apk에 대한 단계별 가이드는 [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)에서 확인하세요.

(그 가이드에 따르면) 마지막으로 확인했을 때, Dexguard의 동작 방식은:

- 리소스를 InputStream으로 로드;
- 결과를 FilterInputStream을 상속한 클래스에 전달하여 복호화;
- 리버서의 시간을 낭비시키기 위한 쓸데없는 난독화 수행;
- 복호화된 결과를 ZipInputStream에 전달하여 DEX 파일 획득;
- 마지막으로 `loadDex` 메서드를 사용해 결과 DEX를 Resource로 로드.

### [DeGuard](http://apk-deguard.com)

**DeGuard는 Android 난독화 도구가 수행한 난독화 과정을 역으로 수행합니다. 이를 통해 코드 검사 및 라이브러리 예측을 포함한 다양한 보안 분석이 가능해집니다.**

난독화된 APK를 해당 플랫폼에 업로드할 수 있습니다.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

It is a **generic android deobfuscator.** Simplify **virtually executes an app** to understand its behavior and then **tries to optimize the code** so it behaves identically but is easier for a human to understand. Each optimization type is simple and generic, so it doesn't matter what the specific type of obfuscation is used.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD gives you information about **how an APK was made**. It identifies many **compilers**, **packers**, **obfuscators**, and other weird stuff. It's [_PEiD_](https://www.aldeid.com/wiki/PEiD) for Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b는 ubuntu-mate 기반의 Android 보안 가상머신으로, 다양한 보안 연구자와 리서처들이 제공하는 최신 프레임워크, 튜토리얼 및 실습 자료들을 포함합니다. 리버스 엔지니어링 및 malware analysis에 적합합니다.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) 훌륭한 자료 목록입니다
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android 빠른 코스
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
