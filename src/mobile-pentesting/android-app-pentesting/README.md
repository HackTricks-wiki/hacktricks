# Pentesting aplikacji Android

{{#include ../../banners/hacktricks-training.md}}

## Podstawy aplikacji Android

Zaleca się rozpocząć od przeczytania tej strony, aby poznać **najważniejsze elementy związane z bezpieczeństwem Androida oraz najbardziej niebezpieczne komponenty w aplikacji Android**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

To główne narzędzie, którego potrzebujesz, aby połączyć się z urządzeniem Android (emulowanym lub fizycznym).\
**ADB** pozwala kontrolować urządzenia zarówno przez **USB**, jak i **Network** z komputera. To narzędzie umożliwia **copying** plików w obu kierunkach, **installation** i **uninstallation** aplikacji, **execution** poleceń shell, **backing up** danych, **reading** logów, między innymi funkcji.

Sprawdź następującą listę [**ADB Commands**](adb-commands.md), aby dowiedzieć się, jak używać adb.

## Smali

Czasami warto **modify the application code**, aby uzyskać dostęp do **hidden information** (np. dobrze obfuskowane hasła lub flagi). W takim przypadku może być interesujące zdekompilować APK, zmodyfikować kod i ponownie skompilować aplikację.\
[**W tym samouczku** możesz **nauczyć się jak zdekompilować APK, zmodyfikować Smali code i ponownie skompilować APK** z nową funkcjonalnością](smali-changes.md). Może to być bardzo przydatne jako **alternatywa dla kilku testów podczas dynamic analysis**, które zostaną zaprezentowane. Zawsze pamiętaj o tej możliwości.

## Other interesting tricks

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Extract APK from device:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Scal wszystkie splits i base apks za pomocą [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Case Studies & Vulnerabilities


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Static Analysis

Przede wszystkim, aby analizować APK powinieneś **przejrzeć kod Java** używając dekompilera.\
Proszę, [**przeczytaj tutaj, aby znaleźć informacje o różnych dostępnych dekompilatorach**](apk-decompilers.md).

### Szukanie interesujących informacji

Już samo przejrzenie **strings** w APK pozwala wyszukać **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **API keys**, **encryption**, **bluetooth uuids**, **tokens** i wszystko, co interesujące... szukaj nawet code execution **backdoors** lub authentication backdoors (hardcoded admin credentials w aplikacji).

**Firebase**

Zwróć szczególną uwagę na **Firebase URLs** i sprawdź, czy nie są źle skonfigurowane. [Więcej informacji o tym, czym jest Firebase i jak to wykorzystać znajdziesz tutaj.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Basic understanding of the application - Manifest.xml, strings.xml

**Analiza plików _Manifest.xml_ i _strings.xml_ aplikacji może ujawnić potencjalne podatności bezpieczeństwa.** Do tych plików można uzyskać dostęp za pomocą dekompilatorów lub zmieniając rozszerzenie pliku APK na .zip i rozpakowując go.

**Podatności** zidentyfikowane w **Manifest.xml** obejmują:

- **Debuggable Applications**: Aplikacje ustawione jako debuggable (`debuggable="true"`) w pliku _Manifest.xml_ stanowią ryzyko, ponieważ umożliwiają połączenia, które mogą prowadzić do exploitacji. Aby lepiej zrozumieć, jak wykorzystywać debuggable applications, zapoznaj się z tutorialem dotyczącym znajdowania i wykorzystywania debuggable applications na urządzeniu.
- **Backup Settings**: Atrybut `android:allowBackup="false"` powinien być jawnie ustawiony dla aplikacji przetwarzających wrażliwe informacje, aby zapobiec nieautoryzowanym backupom danych przez adb, szczególnie gdy usb debugging jest włączone.
- **Network Security**: Niestandardowe konfiguracje network security (`android:networkSecurityConfig="@xml/network_security_config"`) w _res/xml/_ mogą określać szczegóły bezpieczeństwa, takie jak certificate pins i ustawienia HTTP traffic. Przykładem może być zezwolenie na HTTP traffic dla określonych domen.
- **Exported Activities and Services**: Identyfikacja exported activities i services w manifeście może ujawnić komponenty, które mogą zostać wykorzystane. Dalsza analiza podczas testów dynamicznych może pokazać, jak te komponenty eksploatować.
- **Content Providers and FileProviders**: Eksponowane content providers mogą umożliwić nieautoryzowany dostęp lub modyfikację danych. Konfiguracja FileProviders również powinna zostać dokładnie sprawdzona.
- **Broadcast Receivers and URL Schemes**: Te komponenty mogą być wykorzystane do ataku, zwracając szczególną uwagę na sposób, w jaki URL schemes są obsługiwane pod kątem podatności wejścia.
- **SDK Versions**: Atrybuty `minSdkVersion`, `targetSDKVersion`, i `maxSdkVersion` wskazują obsługiwane wersje Androida, co podkreśla znaczenie niewspierania przestarzałych, podatnych wersji Androida z powodów bezpieczeństwa.

Z pliku **strings.xml** można odkryć wrażliwe informacje, takie jak API keys, custom schemas i inne notatki deweloperskie, co podkreśla potrzebę uważnego przeglądu tych zasobów.

### Tapjacking

**Tapjacking** to atak, w którym **malicious application** jest uruchamiana i **pozycjonuje się nad aplikacją ofiary**. Gdy zasłania aplikację ofiary, jej interfejs użytkownika jest zaprojektowany tak, aby zwieść użytkownika do interakcji z nim, podczas gdy interakcja jest przekazywana do aplikacji ofiary.\
W efekcie **użytkownik jest oślepiany i nie wie, że tak naprawdę wykonuje akcje w aplikacji ofiary**.

Znajdź więcej informacji w:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Aktywność z ustawionym **`launchMode`** na **`singleTask` bez zdefiniowanego `taskAffinity`** jest podatna na task Hijacking. Oznacza to, że aplikacja może zostać zainstalowana i jeśli zostanie uruchomiona przed prawdziwą aplikacją, może **przejąć task prawdziwej aplikacji** (tak że użytkownik będzie interagował z **malicious application**, myśląc, że używa prawdziwej aplikacji).

Więcej informacji w:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Insecure data storage

**Internal Storage**

W Androidzie pliki **przechowywane** w **internal storage** są **przeznaczone** do dostępu wyłącznie przez aplikację, która je utworzyła. Ten mechanizm bezpieczeństwa jest egzekwowany przez system Android i jest zwykle wystarczający dla potrzeb większości aplikacji. Jednak deweloperzy czasami używają trybów takich jak `MODE_WORLD_READABLE` i `MODE_WORLD_WRITABLE`, aby **umożliwić** udostępnianie plików między różnymi aplikacjami. Te tryby **nie ograniczają jednak dostępu** do tych plików przez inne aplikacje, w tym potencjalnie złośliwe.

1. Analiza statyczna:
- **Sprawdź** użycie `MODE_WORLD_READABLE` i `MODE_WORLD_WRITABLE` z dużą ostrożnością. Te tryby **mogą potencjalnie eksponować** pliki na **niezamierzony lub nieautoryzowany dostęp**.
2. Analiza dynamiczna:
- **Zweryfikuj** uprawnienia ustawione na plikach tworzonych przez aplikację. Konkretnie, **sprawdź**, czy jakieś pliki nie zostały ustawione jako czytelne lub zapisywalne dla wszystkich. To może stanowić istotne ryzyko bezpieczeństwa, ponieważ umożliwi **każdej aplikacji** zainstalowanej na urządzeniu, niezależnie od jej pochodzenia czy zamiarów, **odczyt lub modyfikację** tych plików.

**External Storage**

W przypadku plików na **external storage**, takich jak SD Cards, należy zachować ostrożność:

1. Dostępność:
- Pliki na external storage są **globalnie czytelne i zapisywalne**. Oznacza to, że każda aplikacja lub użytkownik może mieć do nich dostęp.
2. Obawy związane z bezpieczeństwem:
- Ze względu na łatwość dostępu, zaleca się **nie przechowywać na external storage informacji wrażliwych**.
- External storage może zostać usunięty lub dostęp do niego może uzyskać dowolna aplikacja, co czyni go mniej bezpiecznym.
3. Obsługa danych z external storage:
- Zawsze **waliduj dane wejściowe** pobierane z external storage. To ważne, ponieważ dane pochodzą ze źródła nieufnego.
- Odradza się przechowywanie plików wykonywalnych lub plików klas na external storage w celu dynamicznego ładowania.
- Jeśli Twoja aplikacja musi pobierać pliki wykonywalne z external storage, upewnij się, że te pliki są **signed and cryptographically verified** zanim zostaną dynamicznie załadowane. Ten krok jest kluczowy dla zachowania integralności bezpieczeństwa aplikacji.

External storage może być **dostępny** w /storage/emulated/0 , /sdcard , /mnt/sdcard

> [!TIP]
> Począwszy od Android 4.4 (**API 17**), SD card ma strukturę katalogów, która **ogranicza dostęp aplikacji tylko do katalogu przypisanego konkretnej aplikacji**. Zapobiega to temu, by malicious application uzyskała odczyt lub zapis plików innej aplikacji.

**Sensitive data stored in clear-text**

- **Shared preferences**: Android pozwala każdej aplikacji łatwo zapisywać pliki xml w ścieżce /data/data/<packagename>/shared_prefs/ i czasami można tam znaleźć wrażliwe informacje w postaci jawnej.
- **Databases**: Android pozwala każdej aplikacji łatwo zapisywać bazy danych sqlite w ścieżce /data/data/<packagename>/databases/ i czasami można tam znaleźć wrażliwe informacje w postaci jawnej.

### Broken TLS

**Accept All Certificates**

Z jakiegoś powodu czasami deweloperzy akceptują wszystkie certyfikaty, nawet jeśli na przykład hostname nie pasuje — przy użyciu fragmentów kodu takich jak poniższy:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Dobry sposób, by to przetestować, to spróbować przechwycić ruch używając proxy takiego jak Burp bez autoryzowania Burp CA wewnątrz urządzenia. Możesz też wygenerować w Burp certyfikat dla innej nazwy hosta i użyć go.

### Błędy w kryptografii

**Słabe procesy zarządzania kluczami**

Niektórzy deweloperzy zapisują dane wrażliwe w local storage i szyfrują je kluczem hardcoded/predictable w kodzie. Nie powinno się tego robić, ponieważ reversing może pozwolić atakującym na wydobycie poufnych informacji.

**Używanie niebezpiecznych i/lub przestarzałych algorytmów**

Deweloperzy nie powinni używać **przestarzałych algorytmów** do wykonywania autoryzacyjnych **checks**, **przechowywania** czy **wysyłania** danych. Niektóre z tych algorytmów to: RC4, MD4, MD5, SHA1... Jeśli do przechowywania haseł używane są **hashes**, powinny to być algorytmy odporne na brute-force stosowane z salt.

### Inne kontrole

- Zaleca się **obfuskować APK**, aby utrudnić pracę reverse engineerom.
- Jeśli aplikacja jest wrażliwa (np. aplikacje bankowe), powinna wykonywać własne **sprawdzenia, czy urządzenie jest zrootowane** i odpowiednio reagować.
- Jeśli aplikacja jest wrażliwa (np. aplikacje bankowe), powinna sprawdzać, czy używany jest **emulator**.
- Jeśli aplikacja jest wrażliwa (np. aplikacje bankowe), powinna **sprawdzić swoją integralność przed uruchomieniem**, aby upewnić się, że nie została zmodyfikowana.
- Użyj [**APKiD**](https://github.com/rednaga/APKiD) aby sprawdzić, który compiler/packer/obfuscator został użyty do zbudowania APK.

### React Native Application

Przeczytaj następującą stronę, aby dowiedzieć się, jak łatwo uzyskać dostęp do kodu javascript aplikacji React:

{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Przeczytaj następującą stronę, aby dowiedzieć się, jak łatwo uzyskać dostęp do kodu C# aplikacji Xamarin:

{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

Zgodnie z tym [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked to algorytm Meta, który kompresuje zawartość aplikacji do pojedynczego pliku. Blog opisuje możliwość stworzenia aplikacji, która dekompresuje tego typu aplikacje... oraz szybszy sposób polegający na **uruchomieniu aplikacji i zebraniu zdekompresowanych plików z systemu plików.**

### Automatyczna statyczna analiza kodu

Narzędzie [**mariana-trench**](https://github.com/facebook/mariana-trench) potrafi znaleźć **vulnerabilities** poprzez **skanowanie** **kodu** aplikacji. Narzędzie zawiera zbiór **known sources** (wskazujących narzędziu **miejsca**, gdzie **wejście** jest **kontrolowane przez użytkownika**), **sinks** (wskazujących **niebezpieczne** **miejsca**, gdzie złośliwe dane użytkownika mogą wyrządzić szkody) oraz **reguł**. Te reguły określają **kombinacje** **sources-sinks**, które wskazują na podatność.

Dzięki tej wiedzy **mariana-trench przeanalizuje kod i znajdzie możliwe podatności w nim**.

### Secrets leaked

Aplikacja może zawierać secrets (API keys, passwords, ukryte url, subdomeny...) wewnątrz siebie, które możesz być w stanie odkryć. Możesz użyć narzędzia takiego jak [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Inne interesujące funkcje

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)
- In-memory native code execution via JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Inne sztuczki**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Analiza dynamiczna

> Przede wszystkim potrzebujesz środowiska, w którym możesz zainstalować aplikację i całe otoczenie (certyfikat Burp CA, Drozer i Frida przede wszystkim). Dlatego zdecydowanie zalecane jest użycie zrootowanego urządzenia (emulowanego lub nie).

### Analiza dynamiczna online

Możesz stworzyć **darmowe konto** na: [https://appetize.io/](https://appetize.io). Ta platforma pozwala **upload** i **execute** APK, więc jest przydatna do obserwacji zachowania apk.

Możesz nawet **zobaczyć logi swojej aplikacji** w przeglądarce i połączyć się przez **adb**.

![](<../../images/image (831).png>)

Dzięki połączeniu ADB możesz używać **Drozer** i **Frida** wewnątrz emulatorów.

### Lokalna analiza dynamiczna

#### Używanie emulatora

- [**Android Studio**](https://developer.android.com/studio) (Możesz stworzyć urządzenia **x86** i **arm**, i zgodnie z [**tym** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**najnowsze wersje x86** obsługują biblioteki ARM bez potrzeby używania wolnego emulatora ARM).
- Naucz się go skonfigurować na tej stronie:

{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(wersja darmowa:** Personal Edition, wymaga utworzenia konta. _Zaleca się **pobrać** wersję **Z**_ _**VirtualBox**, aby uniknąć potencjalnych błędów._)
- [**Nox**](https://es.bignox.com) (Darmowy, ale nie obsługuje Frida ani Drozer).

> [!TIP]
> Podczas tworzenia nowego emulatora na dowolnej platformie pamiętaj, że im większy ekran, tym wolniej emulator będzie działać. Wybieraj jak najmniejsze ekrany, jeśli to możliwe.

Aby **zainstalować google services** (np. AppStore) w Genymotion, musisz kliknąć w czerwony zaznaczony przycisk na poniższym obrazie:

![](<../../images/image (277).png>)

Zauważ także, że w **konfiguracji VM Androida w Genymotion** możesz wybrać **Bridge Network mode** (to będzie przydatne, jeśli będziesz łączyć się z VM Androida z innej VM z narzędziami).

#### Używanie urządzenia fizycznego

Musisz aktywować opcje **debugowania**, a miło by było, gdybyś mógł je **zrootować**:

1. **Settings**.
2. (FromAndroid 8.0) Wybierz **System**.
3. Wybierz **About phone**.
4. Naciśnij **Build number** 7 razy.
5. Wróć i znajdziesz **Developer options**.

> Po zainstalowaniu aplikacji pierwszą rzeczą, którą powinieneś zrobić, jest jej uruchomienie i zbadanie, co robi, jak działa i oswojenie się z nią.\
> Sugeruję wykonanie tej początkowej analizy dynamicznej używając MobSF dynamic analysis + pidcat, dzięki czemu będziemy w stanie **nauczyć się, jak aplikacja działa**, podczas gdy MobSF **przechwyci** wiele **interesujących** **danych**, które możesz później przejrzeć.

Magisk/Zygisk quick notes (zalecane na urządzeniach Pixel)
- Zepatchuj boot.img przy pomocy aplikacji Magisk i wgraj przez fastboot, aby uzyskać systemless root
- Włącz Zygisk + DenyList do ukrywania roota; rozważ LSPosed/Shamiko gdy potrzebne jest silniejsze ukrywanie
- Zachowaj oryginalny boot.img, aby odzyskać się po OTA; ponownie zepatchuj po każdym OTA
- Do mirrorowania ekranu użyj scrcpy na hoście

### Niezamierzone ujawnianie danych

**Logowanie**

Deweloperzy powinni uważać, by nie ujawniać publicznie **informacji debugowych**, ponieważ może to prowadzić do wycieków danych wrażliwych. Narzędzia [**pidcat**](https://github.com/JakeWharton/pidcat) i `adb logcat` są zalecane do monitorowania logów aplikacji w celu identyfikacji i ochrony wrażliwych informacji. **Pidcat** jest preferowany ze względu na łatwość użycia i czytelność.

> [!WARNING]
> Zauważ, że od **wersji nowszych niż Android 4.0**, **aplikacje mogą uzyskiwać dostęp tylko do własnych logów**. Więc aplikacje nie mogą uzyskać logów innych applikacji.\
> Mimo to nadal zaleca się **nie logować informacji wrażliwych**.

**Bufor kopiuj/wklej**

Androidowy framework oparty na **schowku** umożliwia funkcję kopiuj-wklej w aplikacjach, jednak niesie ryzyko, ponieważ **inne aplikacje** mogą **uzyskać dostęp** do schowka, potencjalnie ujawniając dane wrażliwe. Należy **wyłączyć funkcje kopiuj/wklej** dla wrażliwych sekcji aplikacji, takich jak dane karty kredytowej, aby zapobiec wyciekom danych.

**Logi awarii**

Jeśli aplikacja **crashuje** i **zapisuje logi**, te logi mogą pomóc atakującym, szczególnie gdy aplikacji nie da się odwrócić. Aby zredukować to ryzyko, unikaj logowania przy awariach, a jeśli logi muszą być przesyłane przez sieć, upewnij się, że są wysyłane przez kanał SSL.

Jako pentester, **spróbuj rzucić okiem na te logi**.

**Dane analityczne wysyłane do 3rd Parties**

Aplikacje często integrują usługi takie jak Google Adsense, które mogą nieumyślnie **leakować** dane wrażliwe z powodu nieprawidłowej implementacji przez deweloperów. Aby zidentyfikować potencjalne wycieki danych, warto **przechwycić ruch aplikacji** i sprawdzić, czy jakiekolwiek dane wrażliwe są wysyłane do usług stron trzecich.

### Bazy danych SQLite

Większość aplikacji używa **wewnętrznych baz danych SQLite** do zapisywania informacji. Podczas pentestu przyjrzyj się **bazom danych** utworzonym, nazwom **tabel** i **kolumn** oraz wszystkim **danym** zapisanym, ponieważ możesz znaleźć **informacje wrażliwe** (co byłoby podatnością).\
Bazy danych powinny znajdować się w /data/data/the.package.name/databases, np. /data/data/com.mwr.example.sieve/databases

Jeśli baza danych przechowuje informacje poufne i jest **encrypted** ale możesz **znaleźć** **password** w aplikacji, to nadal jest **vulnerability**.

Wypisz tabele używając `.tables` i wypisz schemat kolumn używając `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

Zgodnie z [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** pozwala przyjąć rolę aplikacji Android i wchodzić w interakcję z innymi aplikacjami. Może robić **cokolwiek, co może zrobić zainstalowana aplikacja**, takie jak korzystanie z mechanizmu IPC Androida i interakcję z systemem operacyjnym.\
Drozer jest użytecznym narzędziem do **wykorzystywania eksportowanych activities, eksportowanych services i Content Providers**, jak poznasz w kolejnych sekcjach.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Pamiętaj też, że kod activity zaczyna się w metodzie **`onCreate`**.

**Authorisation bypass**

Kiedy Activity jest eksportowane, możesz wywołać jej ekran z zewnętrznej aplikacji. Dlatego, jeśli activity zawierająca **wrażliwe informacje** jest **exported**, możesz **bypass** mechanizmy **authentication**, aby uzyskać do niej dostęp.

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

Możesz też uruchomić eksportowane activity z adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> Zauważ, że obejście autoryzacji nie zawsze jest podatnością; zależy to od tego, jak działa obejście i jakie informacje są ujawnione.

**Ujawnianie wrażliwych informacji**

Aktywności mogą również zwracać wyniki. Jeśli uda Ci się znaleźć eksportowaną i niezabezpieczoną aktywność wywołującą metodę **`setResult`** i **zwracającą wrażliwe informacje**, występuje ujawnianie wrażliwych informacji.

#### Tapjacking

Jeśli Tapjacking nie jest zapobiegany, możesz wykorzystać eksportowaną aktywność, aby skłonić **użytkownika do wykonania nieoczekiwanych działań**. Po więcej informacji o [**czym jest Tapjacking przejdź pod ten link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers są zasadniczo używane do **udostępniania danych**. Jeśli aplikacja ma dostępne content providers, możesz być w stanie **wyekstrahować z nich wrażliwe dane**. Warto też przetestować możliwe **SQL injections** i **Path Traversals**, ponieważ mogą być podatne.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Pamiętaj, że działania Service rozpoczynają się w metodzie `onStartCommand`.

Service to w zasadzie coś, co **może otrzymywać dane**, **przetwarzać** je i **zwracać** (lub nie) odpowiedź. Jeśli aplikacja eksportuje jakieś services, powinieneś **sprawdzić** **kod**, żeby zrozumieć, co robi, i **przetestować** go **dynamicznie**, aby wydobyć poufne informacje, obejść mechanizmy uwierzytelniania...
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Pamiętaj, że działania Broadcast Receiver rozpoczynają się w metodzie `onReceive`.

Broadcast receiver będzie oczekiwać na określony typ komunikatu. W zależności od tego, jak receiver obsługuje komunikat, może być podatny.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Możesz szukać deep links ręcznie, używając narzędzi takich jak MobSF lub skryptów takich jak [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Możesz **otworzyć** zadeklarowany **scheme** używając **adb** lub **przeglądarki**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Zwróć uwagę, że możesz **pominąć nazwę pakietu**, a urządzenie mobilne automatycznie wywoła aplikację, która powinna otworzyć ten link._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Kod wykonywany**

Aby znaleźć **kod, który zostanie wykonany w App**, przejdź do activity wywoływanej przez deeplink i wyszukaj funkcję **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Wrażliwe informacje**

Za każdym razem, gdy znajdziesz deep link, sprawdź, że **nie odbiera wrażliwych danych (np. haseł) przez parametry URL**, ponieważ każda inna aplikacja mogłaby **podszyć się pod deep link i ukraść te dane!**

**Parametry w ścieżce**

Musisz również sprawdzić, **czy którykolwiek deep link używa parametru wewnątrz ścieżki** URL, np.: `https://api.example.com/v1/users/{username}`. W takim przypadku możesz wymusić path traversal, uzyskując dostęp do czegoś w stylu: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Zauważ, że jeśli znajdziesz poprawne endpoints wewnątrz aplikacji, możesz spowodować **Open Redirect** (jeśli część ścieżki jest używana jako nazwa domeny), **account takeover** (jeśli możesz modyfikować dane użytkowników bez tokena CSRF i podatny endpoint używał właściwej metody) oraz inne podatności. More [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Inspekcja warstwy transportowej i błędy w weryfikacji

- **Certyfikaty nie zawsze są weryfikowane poprawnie** przez aplikacje Android. Często aplikacje ignorują ostrzeżenia i akceptują self-signed certificates albo, w niektórych przypadkach, wracają do używania połączeń HTTP.
- **Negocjacje podczas SSL/TLS handshake bywają słabe**, stosując niebezpieczne cipher suites. Ta podatność umożliwia ataki man-in-the-middle (MITM), pozwalając atakującemu odszyfrować dane.
- **Ujawnianie prywatnych informacji** jest ryzykiem, gdy aplikacje uwierzytelniają się przy użyciu bezpiecznych kanałów, a następnie komunikują przez niezabezpieczone kanały dla innych operacji. Takie podejście nie chroni wrażliwych danych, takich jak session cookies czy dane użytkownika, przed przechwyceniem przez złośliwe podmioty.

#### Certificate Verification

Skupimy się na **weryfikacji certyfikatu**. Integralność certyfikatu serwera musi być sprawdzana, aby zwiększyć bezpieczeństwo. Jest to kluczowe, ponieważ niebezpieczne konfiguracje TLS i przesyłanie wrażliwych danych przez niezabezpieczone kanały mogą stwarzać poważne ryzyko. Dla szczegółowych kroków dotyczących weryfikacji certyfikatów serwera i usuwania podatności, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) zawiera obszerny poradnik.

#### SSL Pinning

SSL Pinning to środek bezpieczeństwa, w którym aplikacja weryfikuje certyfikat serwera względem znanej kopii przechowywanej wewnątrz aplikacji. Ta metoda jest kluczowa do zapobiegania atakom MITM. Implementacja SSL Pinning jest zdecydowanie zalecana dla aplikacji obsługujących wrażliwe informacje.

#### Traffic Inspection

Aby inspekcjonować ruch HTTP, konieczne jest **zainstalowanie certyfikatu narzędzia proxy** (np. Burp). Bez zainstalowania tego certyfikatu zaszyfrowany ruch może nie być widoczny przez proxy. Dla przewodnika po instalacji własnego CA certificate, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Aplikacje targetujące **API Level 24 and above** wymagają modyfikacji Network Security Config, aby zaakceptować CA certificate proxy. Ten krok jest kluczowy do inspekcji szyfrowanego ruchu. Instrukcje dotyczące modyfikacji Network Security Config znajdziesz w [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

Jeśli używane jest **Flutter**, musisz postępować zgodnie z instrukcjami na [**this page**](flutter.md). To dlatego, że samo dodanie certyfikatu do store nie zadziała — Flutter ma własną listę zaufanych CA.

#### Static detection of SSL/TLS pinning

Zanim spróbujesz obejść pinning w czasie wykonywania, szybko zmapuj miejsca, gdzie pinning jest egzekwowany w APK. Statyczne wykrywanie pomaga zaplanować hooki/patch’e i skupić się na odpowiednich ścieżkach kodu.

Tool: SSLPinDetect
- Open-source static-analysis utility that decompiles the APK to Smali (via apktool) and scans for curated regex patterns of SSL/TLS pinning implementations.
- Reports exact file path, line number, and a code snippet for each match.
- Covers common frameworks and custom code paths: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Użycie
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Przykładowe reguły wzorców (JSON)
Użyj lub rozszerz signatures, aby wykrywać proprietary/custom pinning styles. Możesz załadować własne pliki JSON i scan at scale.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Uwagi i wskazówki
- Szybkie skanowanie dużych aplikacji za pomocą multi-threading i memory-mapped I/O; pre-compiled regex zmniejsza narzut/fałszywe pozytywy.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Typowe cele detekcji do dalszej weryfikacji:
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Declarative pins in res/xml network security config and manifest references
- Wykorzystaj dopasowane lokalizacje do zaplanowania Frida hooks, static patches lub przeglądu konfiguracji przed testami dynamicznymi.



#### Omijanie SSL Pinning

Kiedy SSL Pinning jest zaimplementowany, konieczne staje się jego obejście, aby móc analizować ruch HTTPS. Dostępne są różne metody:

- Automatycznie **zmodyfikować** **apk**, aby **ominąć** SSLPinning za pomocą [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Największą zaletą tej opcji jest to, że nie będziesz potrzebować roota, ale będziesz musiał usunąć aplikację i zainstalować nową, i nie zawsze to zadziała.
- Możesz użyć **Frida** (omawiana poniżej) do ominięcia tej ochrony. Oto poradnik jak użyć Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Możesz też spróbować **automatycznie ominąć SSL Pinning** używając [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Możesz też spróbować **automatycznie ominąć SSL Pinning** używając **MobSF dynamic analysis** (opisane poniżej)
- Jeśli nadal uważasz, że część ruchu nie jest przechwytywana, możesz spróbować **przekierować ruch do Burp używając iptables**. Przeczytaj ten wpis: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Szukanie typowych podatności webowych

Ważne jest również wyszukiwanie typowych podatności webowych w aplikacji. Szczegółowe informacje o identyfikacji i łagodzeniu tych podatności wykraczają poza zakres tego skrótu, ale są szeroko omówione w innych miejscach.

### Frida

[Frida](https://www.frida.re) to narzędzie do dynamicznej instrumentacji dla deweloperów, reverse-engineerów i badaczy bezpieczeństwa.\
**Możesz uzyskać dostęp do uruchomionej aplikacji i hookować metody w czasie działania, aby zmienić zachowanie, zmienić wartości, wyodrębnić wartości, uruchomić inny kod...**\
Jeśli chcesz pentestować aplikacje Android, musisz umieć korzystać z Frida.

- Naucz się korzystać z Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Kilka "GUI" do działań z Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection świetnie automatyzuje użycie Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Możesz znaleźć świetne skrypty Frida tutaj: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Spróbuj obejść mechanizmy anti-debugging / anti-frida ładując Frida jak wskazano w [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (narzędzie [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & workflow obejścia SSL pinning

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Zrzut pamięci - Fridump**

Sprawdź, czy aplikacja nie przechowuje w pamięci wrażliwych informacji, których nie powinna, takich jak hasła czy mnemoniki.

Używając [**Fridump3**](https://github.com/rootbsd/fridump3) możesz zrzucić pamięć aplikacji poleceniem:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
To zapisze dump memory w folderze ./dump, a następnie możesz użyć grep, np.:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Poufne dane w Keystore**

W Androidzie Keystore jest najlepszym miejscem do przechowywania poufnych danych, jednak przy odpowiednich uprawnieniach nadal jest **możliwe uzyskanie dostępu**. Ponieważ aplikacje mają tendencję do przechowywania tutaj **poufnych danych w clear text**, pentests powinny to sprawdzić jako root user, ponieważ ktoś z fizycznym dostępem do urządzenia mógłby ukraść te dane.

Nawet jeśli aplikacja przechowuje dane w Keystore, dane powinny być zaszyfrowane.

Aby uzyskać dostęp do danych wewnątrz Keystore, możesz użyć tego Frida scriptu: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Odcisk palca/Biometria Bypass**

Używając poniższego skryptu Frida możliwe jest **bypass fingerprint authentication**, które aplikacje Android mogą stosować w celu **zabezpieczenia niektórych wrażliwych obszarów:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Obrazy w tle**

Gdy umieścisz aplikację w tle, Android zapisuje **migawkę aplikacji**, dzięki czemu po przywróceniu do pierwszego planu zaczyna ładować obraz przed samą aplikacją, żeby wyglądało, że aplikacja uruchomiła się szybciej.

Jednak jeśli ta migawka zawiera **poufne informacje**, osoba mająca dostęp do migawki może **ukraść te dane** (uwaga: dostęp do nich wymaga uprawnień root).

Migawki są zazwyczaj przechowywane w: **`/data/system_ce/0/snapshots`**

Android oferuje sposób na **zapobieganie przechwytywaniu zrzutów ekranu poprzez ustawienie parametru układu FLAG_SECURE**. Używając tej flagi, zawartość okna jest traktowana jako bezpieczna, co uniemożliwia jej pojawienie się na zrzutach ekranu lub wyświetlanie na niezabezpieczonych wyświetlaczach.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

To narzędzie może pomóc w zarządzaniu różnymi narzędziami podczas analizy dynamicznej: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Deweloperzy często tworzą komponenty-proxy, takie jak activities, services i broadcast receivers, które obsługują te Intenty i przekazują je do metod takich jak `startActivity(...)` lub `sendBroadcast(...)`, co może być ryzykowne.

Niebezpieczeństwo polega na umożliwieniu atakującym wywoływania nieeksportowanych komponentów aplikacji lub dostępu do wrażliwych content providers przez przekierowywanie tych Intentów. Dobrym przykładem jest komponent `WebView` konwertujący URL-e na obiekty `Intent` za pomocą `Intent.parseUri(...)` i następnie je wykonujący, co może prowadzić do złośliwych wstrzyknięć Intentów.

### Essential Takeaways

- **Intent Injection** is similar to web's Open Redirect issue.
- Eksploity polegają na przekazywaniu obiektów `Intent` jako extras, które mogą być przekierowane do wykonania niebezpiecznych operacji.
- Może to narażać nieeksportowane komponenty i content providers na dostęp ze strony atakujących.
- Konwersja URL → `Intent` przez `WebView` może ułatwiać niezamierzone działania.

### Android Client Side Injections and others

Prawdopodobnie znasz tego typu podatności z Weba. Trzeba szczególnie uważać na te podatności w aplikacji Android:

- **SQL Injection:** Przy pracy z zapytaniami dynamicznymi lub Content-Providers upewnij się, że używasz zapytań parametryzowanych.
- **JavaScript Injection (XSS):** Sprawdź, czy wsparcie dla JavaScript i Pluginów jest wyłączone dla wszystkich WebViews (domyślnie wyłączone). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews powinny mieć dostęp do systemu plików wyłączony (domyślnie włączony) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: W wielu przypadkach po zakończeniu sesji w aplikacji Android cookie nie jest unieważniany lub może nawet zostać zapisany na dysku
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Analiza statyczna**

![](<../../images/image (866).png>)

**Ocena podatności aplikacji** przy użyciu przyjaznego webowego interfejsu. Możesz też przeprowadzić analizę dynamiczną (ale musisz przygotować środowisko).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Zauważ, że MobSF może analizować **Android**(apk)**, IOS**(ipa) **and Windows**(apx) aplikacje (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Ponadto, jeśli stworzysz plik **ZIP** ze źródłami aplikacji **Android** lub **IOS** (wejdź do katalogu głównego aplikacji, zaznacz wszystko i utwórz ZIP), MobSF będzie w stanie go również przeanalizować.

MobSF umożliwia także wykonanie **diff/Compare** analiz oraz integrację z **VirusTotal** (musisz ustawić swój API key w _MobSF/settings.py_ i włączyć to: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). Możesz również ustawić `VT_UPLOAD` na `False`, wtedy zamiast pliku zostanie przesłany **hash**.

### Asystowana dynamic analysis z MobSF

**MobSF** może być również bardzo pomocny przy **dynamic analysis** na **Android**, ale w tym przypadku musisz zainstalować MobSF i **genymotion** na swoim hoście (VM lub Docker nie będą działać). _Uwaga: Musisz najpierw **uruchomić VM w genymotion** a dopiero potem MobSF._\
**MobSF dynamic analyser** potrafi:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). Wszystko to jest robione automatycznie z wyjątkiem screenshotów — musisz nacisnąć, kiedy chcesz zrobić screenshot lub nacisnąć "**Exported Activity Tester**", aby uzyskać zrzuty wszystkich exported activities.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

Od wersji **Android > 5** automatycznie uruchomi **Frida** i ustawi globalne ustawienia **proxy**, aby **capture** ruch. Będzie przechwytywać ruch tylko z testowanej aplikacji.

**Frida**

Domyślnie użyje także kilku Frida Scripts do **bypass SSL pinning**, **root detection** i **debugger detection** oraz do **monitor interesting APIs**.\
MobSF może także **invoke exported activities**, pobierać **screenshots** tych aktywności i **save** je do raportu.

Aby **start** testy dynamiczne naciśnij zielony przycisk: "**Start Instrumentation**". Naciśnij "**Frida Live Logs**", aby zobaczyć logi generowane przez skrypty Frida oraz "**Live API Monitor**", aby zobaczyć wszystkie wywołania do hookowanych metod, przekazywane argumenty i zwracane wartości (to pojawi się po naciśnięciu "Start Instrumentation").\
MobSF pozwala również wczytać własne **Frida scripts** (aby wysłać wyniki swoich Frida scripts do MobSF użyj funkcji `send()`). Ma też **kilka predpisanych skryptów**, które możesz wczytać (możesz dodać więcej w `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), po prostu **wybierz je**, naciśnij "**Load**" i naciśnij "**Start Instrumentation**" (będziesz mógł zobaczyć logi tych skryptów w "**Frida Live Logs**").

![](<../../images/image (419).png>)

Dodatkowo masz kilka pomocniczych funkcji Frida:

- **Enumerate Loaded Classes**: Wydrukuje wszystkie załadowane klasy
- **Capture Strings**: Wydrukuje wszystkie uchwycone stringi podczas używania aplikacji (bardzo hałaśliwe)
- **Capture String Comparisons**: Może być bardzo użyteczne. Pokaże **2 porównywane stringi** oraz czy wynik był True czy False.
- **Enumerate Class Methods**: Wpisz nazwę klasy (np. "java.io.File") i wydrukuje wszystkie metody tej klasy.
- **Search Class Pattern**: Wyszukiwanie klas po wzorcu
- **Trace Class Methods**: **Trace** całej klasy (zobacz wejścia i wyjścia wszystkich metod klasy). Pamiętaj, że domyślnie MobSF trace'uje kilka interesujących Android Api methods.

Gdy wybierzesz moduł pomocniczy, którego chcesz użyć, musisz nacisnąć "**Start Intrumentation**" i zobaczysz wszystkie outputy w "**Frida Live Logs**".

**Shell**

MobSF udostępnia również shell z kilkoma komendami **adb**, komendami **MobSF**, oraz standardowymi poleceniami **shell** na dole strony dynamic analysis. Kilka ciekawych komend:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP tools**

Kiedy ruch HTTP jest przechwytywany, możesz zobaczyć surowy widok przechwyconego ruchu w przycisku "**HTTP(S) Traffic**" na dole lub ładniejszy widok w zielonym przycisku "**Start HTTPTools**". Z drugiej opcji możesz **wysłać** **przechwycone żądania** do **proxies** takich jak Burp lub Owasp ZAP.\
Aby to zrobić: _uruchom Burp -->_ _wyłącz Intercept --> w MobSB HTTPTools wybierz żądanie_ --> naciśnij "**Send to Fuzzer**" --> _wybierz adres proxy_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Gdy zakończysz analizę dynamiczną w MobSF, możesz kliknąć "**Start Web API Fuzzer**", aby **fuzzować http requests** i szukać podatności.

> [!TIP]
> Po wykonaniu analizy dynamicznej w MobSF ustawienia proxy mogą być nieprawidłowo skonfigurowane i nie będzie można ich naprawić z GUI. Możesz naprawić ustawienia proxy wykonując:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

Narzędzie można pobrać z [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
To narzędzie wykorzystuje niektóre **Hooks**, aby informować Cię, **co dzieje się w aplikacji** podczas przeprowadzania **analizy dynamicznej**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

To **świetne narzędzie do przeprowadzania analizy statycznej z GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Narzędzie to zostało zaprojektowane do wyszukiwania różnych **bezpieczeństwa związanych z aplikacjami Android** podatności, zarówno w **source code**, jak i w spakowanych APKs. Narzędzie potrafi także **tworzyć deployowalne APK "Proof-of-Concept"** oraz komendy ADB, aby wykorzystać niektóre z odnalezionych podatności (Exposed activities, intents, tapjacking...). Podobnie jak w przypadku Drozer, nie ma potrzeby rootowania urządzenia testowego.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Wyświetla wszystkie wyodrębnione pliki dla łatwego przeglądu
- Automatycznie dekompiluje pliki APK do formatu Java i Smali
- Analizuje AndroidManifest.xml pod kątem typowych luk i zachowań
- Statyczna analiza kodu źródłowego pod kątem typowych luk i zachowań
- Informacje o urządzeniu
- i więcej
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER jest aplikacją wiersza poleceń, która może być używana na Windows, MacOS X i Linux, i analizuje pliki _.apk_ w poszukiwaniu luk. Działa to poprzez dekompresję APK i zastosowanie serii reguł w celu wykrywania tych luk.

Wszystkie reguły znajdują się w pliku `rules.json`, a każda firma lub tester może tworzyć własne reguły, aby analizować to, czego potrzebują.

Pobierz najnowsze binaria ze [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn jest **wieloplatformowym** narzędziem, które pomaga deweloperom, bugbounty hunters i ethical hackers w przeprowadzaniu [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) aplikacji mobilnych.

Koncepcja polega na przeciągnięciu i upuszczeniu pliku aplikacji mobilnej (plik .apk lub .ipa) na aplikację StaCoAn, która wygeneruje dla Ciebie wizualny i przenośny raport. Możesz dostosować ustawienia i wordlists, aby uzyskać spersonalizowane doświadczenie.

Pobierz[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework to system analizy podatności dla Androida, który pomaga deweloperom lub hackersom znaleźć potencjalne luki bezpieczeństwa w aplikacjach Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** to narzędzie, którego głównym celem jest wykrywanie i ostrzeganie użytkownika o potencjalnie złośliwych zachowaniach rozwijanych przez aplikację Android.

Detekcja odbywa się poprzez **static analysis** Dalvik bytecode aplikacji, reprezentowanego jako **Smali**, przy użyciu biblioteki [`androguard`](https://github.com/androguard/androguard).

To narzędzie wyszukuje **powszechne zachowania "złych" aplikacji** takie jak: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** to **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. To narzędzie łączące powszechnie używane narzędzia do reverse engineeringu i analizy aplikacji mobilnych, aby wspomóc testowanie aplikacji mobilnych pod kątem zagrożeń bezpieczeństwa zdefiniowanych przez OWASP mobile. Jego celem jest ułatwienie tego zadania programistom aplikacji mobilnych i specjalistom ds. bezpieczeństwa.

Potrafi:

- Extract Java and Smali code using different tools
- Analyze APKs using: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Extract private information from the APK using regexps.
- Analyze the Manifest.
- Analyze found domains using: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Przydatne do wykrywania malware: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Zwróć uwagę, że w zależności od usługi i konfiguracji użytej do obfuskacji kodu, sekrety mogą być albo obfuskowane, albo nie.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** to open source narzędzie wiersza poleceń, które zmniejsza, optymalizuje i obfuskauje kod Java. Potrafi optymalizować bytecode oraz wykrywać i usuwać nieużywane instrukcje. ProGuard jest wolnym oprogramowaniem i jest dystrybuowany na licencji GNU General Public License, wersja 2.

ProGuard jest dystrybuowany jako część Android SDK i uruchamiany podczas budowania aplikacji w trybie release.

### [DexGuard](https://www.guardsquare.com/dexguard)

Znajdziesz przewodnik krok po kroku dotyczący deobfuskacji apk w [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(Z tego przewodnika) Ostatnim razem, gdy sprawdzano, tryb działania DexGuard był następujący:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard odwraca proces obfuskacji wykonywany przez narzędzia obfuskacyjne dla Androida. To umożliwia liczne analizy bezpieczeństwa, w tym inspekcję kodu i rozpoznawanie bibliotek.**

Możesz przesłać obfuskowany APK na ich platformę.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

Jest to **ogólny deobfuskator dla androida.** Simplify **wirtualnie wykonuje aplikację**, aby zrozumieć jej zachowanie, a następnie **stara się zoptymalizować kod**, tak aby zachowywał się identycznie, ale był łatwiejszy do zrozumienia przez człowieka. Każdy typ optymalizacji jest prosty i ogólny, więc nie ma znaczenia, jaki konkretny typ obfuskacji został użyty.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD daje informacje o tym, **jak stworzono APK**. Identyfikuje wiele **kompilatorów**, **packers**, **obfuscators**, oraz innych dziwnych rzeczy. To [_PEiD_](https://www.aldeid.com/wiki/PEiD) dla Androida.

### Manual

[Przeczytaj ten samouczek, aby poznać triki dotyczące **jak odwrócić niestandardową obfuskację**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b to wirtualna maszyna do bezpieczeństwa Android oparta na ubuntu-mate, zawierająca zbiór najnowszych frameworków, samouczków i laboratoriów od różnych entuzjastów i badaczy bezpieczeństwa do reverse engineeringu i analizy malware.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) To świetna lista zasobów
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
