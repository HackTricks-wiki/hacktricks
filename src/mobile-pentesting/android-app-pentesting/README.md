# Testowanie aplikacji na Androida

{{#include ../../banners/hacktricks-training.md}}

## Podstawy aplikacji na Androida

Zaleca się rozpoczęcie od przeczytania tej strony, aby poznać **najważniejsze aspekty związane z bezpieczeństwem Androida oraz najbardziej niebezpieczne komponenty w aplikacji na Androida**:

{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

To główne narzędzie, którego potrzebujesz, aby połączyć się z urządzeniem z Androidem (emulowanym lub fizycznym).\
**ADB** umożliwia kontrolowanie urządzeń zarówno przez **USB**, jak i **sieć** z komputera. To narzędzie pozwala na **kopiowanie** plików w obie strony, **instalację** i **odinstalację** aplikacji, **wykonywanie** poleceń powłoki, **tworzenie kopii zapasowych** danych, **odczytywanie** logów, wśród innych funkcji.

Zobacz poniższą listę [**komend ADB**](adb-commands.md), aby dowiedzieć się, jak używać adb.

## Smali

Czasami interesujące jest **modyfikowanie kodu aplikacji**, aby uzyskać dostęp do **ukrytych informacji** (może dobrze obfuskowanych haseł lub flag). Wtedy może być interesujące dekompilowanie apk, modyfikowanie kodu i ponowne kompilowanie go.\
[**W tym samouczku** możesz **nauczyć się, jak dekompilować APK, modyfikować kod Smali i ponownie kompilować APK** z nową funkcjonalnością](smali-changes.md). Może to być bardzo przydatne jako **alternatywa dla kilku testów podczas analizy dynamicznej**, które będą przedstawione. Następnie **zawsze miej na uwadze tę możliwość**.

## Inne interesujące triki

- [Podrabianie swojej lokalizacji w Sklepie Play](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (dostęp z uprawnieniami bez roota oparty na ADB)](shizuku-privileged-api.md)
- [Wykorzystywanie niebezpiecznych mechanizmów aktualizacji w aplikacji](insecure-in-app-update-rce.md)
- **Pobieranie APK**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Ekstrakcja APK z urządzenia:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Połącz wszystkie podzielone i podstawowe pliki APK za pomocą [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Analiza statyczna

Przede wszystkim, aby przeanalizować APK, powinieneś **rzucić okiem na kod Java** za pomocą dekompilatora.\
Proszę, [**przeczytaj tutaj, aby znaleźć informacje o różnych dostępnych dekompilatorach**](apk-decompilers.md).

### Szukanie interesujących informacji

Samo spojrzenie na **ciągi** w APK pozwala na wyszukiwanie **haseł**, **URL** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **kluczy** **api**, **szyfrowania**, **uuid bluetooth**, **tokenów** i wszystkiego, co może być interesujące... szukaj nawet **tylnych drzwi** do wykonania kodu lub tylnych drzwi autoryzacyjnych (hardcodowane dane administratora w aplikacji).

**Firebase**

Zwróć szczególną uwagę na **adresy URL Firebase** i sprawdź, czy są źle skonfigurowane. [Więcej informacji na temat tego, czym jest Firebase i jak go wykorzystać, znajdziesz tutaj.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Podstawowe zrozumienie aplikacji - Manifest.xml, strings.xml

**Badanie plików _Manifest.xml_ i _strings.xml_ aplikacji może ujawnić potencjalne luki w zabezpieczeniach**. Pliki te można uzyskać za pomocą dekompilatorów lub przez zmianę rozszerzenia pliku APK na .zip, a następnie jego rozpakowanie.

**Luki** zidentyfikowane w **Manifest.xml** obejmują:

- **Aplikacje debugowalne**: Aplikacje ustawione jako debugowalne (`debuggable="true"`) w pliku _Manifest.xml_ stanowią ryzyko, ponieważ pozwalają na połączenia, które mogą prowadzić do wykorzystania. Aby uzyskać dalsze zrozumienie, jak wykorzystać aplikacje debugowalne, zapoznaj się z samouczkiem na temat znajdowania i wykorzystywania aplikacji debugowalnych na urządzeniu.
- **Ustawienia kopii zapasowej**: Atrybut `android:allowBackup="false"` powinien być wyraźnie ustawiony dla aplikacji zajmujących się wrażliwymi informacjami, aby zapobiec nieautoryzowanym kopiom zapasowym danych za pomocą adb, szczególnie gdy debugowanie USB jest włączone.
- **Bezpieczeństwo sieci**: Niestandardowe konfiguracje bezpieczeństwa sieci (`android:networkSecurityConfig="@xml/network_security_config"`) w _res/xml/_ mogą określać szczegóły bezpieczeństwa, takie jak przypinanie certyfikatów i ustawienia ruchu HTTP. Przykładem jest zezwolenie na ruch HTTP dla określonych domen.
- **Eksportowane aktywności i usługi**: Identyfikacja eksportowanych aktywności i usług w manifeście może uwydatnić komponenty, które mogą być nadużywane. Dalsza analiza podczas testów dynamicznych może ujawnić, jak wykorzystać te komponenty.
- **Dostawcy treści i FileProviders**: Ujawnione dostawcy treści mogą umożliwić nieautoryzowany dostęp lub modyfikację danych. Konfiguracja FileProviders powinna być również dokładnie sprawdzona.
- **Odbiorniki rozgłoszeniowe i schematy URL**: Te komponenty mogą być wykorzystywane do eksploatacji, z szczególną uwagą na to, jak zarządzane są schematy URL w kontekście luk wejściowych.
- **Wersje SDK**: Atrybuty `minSdkVersion`, `targetSDKVersion` i `maxSdkVersion` wskazują obsługiwane wersje Androida, podkreślając znaczenie nieobsługiwania przestarzałych, podatnych wersji Androida z powodów bezpieczeństwa.

Z pliku **strings.xml** można odkryć wrażliwe informacje, takie jak klucze API, niestandardowe schematy i inne notatki dewelopera, co podkreśla potrzebę starannego przeglądu tych zasobów.

### Tapjacking

**Tapjacking** to atak, w którym **złośliwa** **aplikacja** jest uruchamiana i **pozycjonuje się na wierzchu aplikacji ofiary**. Gdy widocznie zasłania aplikację ofiary, jej interfejs użytkownika jest zaprojektowany w taki sposób, aby oszukać użytkownika do interakcji z nią, podczas gdy przekazuje interakcję do aplikacji ofiary.\
W efekcie, **oślepia użytkownika, nie pozwalając mu wiedzieć, że faktycznie wykonuje akcje w aplikacji ofiary**.

Więcej informacji znajdziesz w:

{{#ref}}
tapjacking.md
{{#endref}}

### Przechwytywanie zadań

**Aktywność** z ustawionym **`launchMode`** na **`singleTask` bez zdefiniowanego `taskAffinity`** jest podatna na przechwytywanie zadań. Oznacza to, że **aplikacja** może być zainstalowana i jeśli zostanie uruchomiona przed prawdziwą aplikacją, może **przechwycić zadanie prawdziwej aplikacji** (więc użytkownik będzie interagował z **złośliwą aplikacją, myśląc, że używa prawdziwej**).

Więcej informacji w:

{{#ref}}
android-task-hijacking.md
{{#endref}}

### Niezabezpieczone przechowywanie danych

**Przechowywanie wewnętrzne**

W Androidzie pliki **przechowywane** w **przechowywaniu wewnętrznym** są **zaplanowane** do bycia **dostępnymi** wyłącznie przez **aplikację**, która je **utworzyła**. Ten środek bezpieczeństwa jest **egzekwowany** przez system operacyjny Android i jest zazwyczaj wystarczający dla potrzeb bezpieczeństwa większości aplikacji. Jednak deweloperzy czasami wykorzystują tryby takie jak `MODE_WORLD_READABLE` i `MODE_WORLD_WRITABLE`, aby **zezwolić** na **dzielenie** plików między różnymi aplikacjami. Niemniej jednak, te tryby **nie ograniczają dostępu** do tych plików przez inne aplikacje, w tym potencjalnie złośliwe.

1. **Analiza statyczna:**
- **Upewnij się**, że użycie `MODE_WORLD_READABLE` i `MODE_WORLD_WRITABLE` jest **starannie analizowane**. Te tryby **mogą potencjalnie ujawniać** pliki **niezamierzonym lub nieautoryzowanym dostępem**.
2. **Analiza dynamiczna:**
- **Zweryfikuj** **uprawnienia** ustawione na plikach utworzonych przez aplikację. Szczególnie **sprawdź**, czy jakiekolwiek pliki są **ustawione na bycie czytelnymi lub zapisywalnymi na całym świecie**. Może to stanowić istotne ryzyko bezpieczeństwa, ponieważ pozwoli **jakiejkolwiek aplikacji** zainstalowanej na urządzeniu, niezależnie od jej pochodzenia czy zamiaru, na **odczyt lub modyfikację** tych plików.

**Przechowywanie zewnętrzne**

Podczas pracy z plikami na **przechowywaniu zewnętrznym**, takim jak karty SD, należy podjąć pewne środki ostrożności:

1. **Dostępność**:
- Pliki na zewnętrznym przechowywaniu są **globalnie czytelne i zapisywalne**. Oznacza to, że każda aplikacja lub użytkownik może uzyskać dostęp do tych plików.
2. **Problemy z bezpieczeństwem**:
- Biorąc pod uwagę łatwość dostępu, zaleca się **nieprzechowywanie wrażliwych informacji** na zewnętrznym przechowywaniu.
- Zewnętrzne przechowywanie może być usunięte lub dostępne przez każdą aplikację, co czyni je mniej bezpiecznym.
3. **Obsługa danych z zewnętrznego przechowywania**:
- Zawsze **przeprowadzaj walidację wejścia** na danych pobranych z zewnętrznego przechowywania. Jest to kluczowe, ponieważ dane pochodzą z nieznanego źródła.
- Przechowywanie plików wykonywalnych lub klas na zewnętrznym przechowywaniu do dynamicznego ładowania jest zdecydowanie odradzane.
- Jeśli Twoja aplikacja musi pobrać pliki wykonywalne z zewnętrznego przechowywania, upewnij się, że te pliki są **podpisane i weryfikowane kryptograficznie** przed ich dynamicznym załadowaniem. Ten krok jest kluczowy dla utrzymania integralności bezpieczeństwa Twojej aplikacji.

Zewnętrzne przechowywanie można **uzyskać** w `/storage/emulated/0`, `/sdcard`, `/mnt/sdcard`

> [!TIP]
> Zaczynając od Androida 4.4 (**API 17**), karta SD ma strukturę katalogów, która **ogranicza dostęp aplikacji do katalogu, który jest specjalnie przeznaczony dla tej aplikacji**. To zapobiega złośliwej aplikacji uzyskiwaniu dostępu do plików innej aplikacji.

**Wrażliwe dane przechowywane w postaci niezaszyfrowanej**

- **Preferencje współdzielone**: Android pozwala każdej aplikacji na łatwe zapisywanie plików xml w ścieżce `/data/data/<packagename>/shared_prefs/` i czasami możliwe jest znalezienie wrażliwych informacji w postaci niezaszyfrowanej w tym folderze.
- **Bazy danych**: Android pozwala każdej aplikacji na łatwe zapisywanie baz danych sqlite w ścieżce `/data/data/<packagename>/databases/` i czasami możliwe jest znalezienie wrażliwych informacji w postaci niezaszyfrowanej w tym folderze.

### Uszkodzony TLS

**Akceptuj wszystkie certyfikaty**

Z jakiegoś powodu czasami deweloperzy akceptują wszystkie certyfikaty, nawet jeśli na przykład nazwa hosta nie pasuje do linii kodu, jak w poniższym przykładzie:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Dobrą metodą na przetestowanie tego jest próba przechwycenia ruchu za pomocą jakiegoś proxy, takiego jak Burp, bez autoryzowania Burp CA na urządzeniu. Możesz również wygenerować za pomocą Burp certyfikat dla innej nazwy hosta i go użyć.

### Uszkodzona kryptografia

**Słabe procesy zarządzania kluczami**

Niektórzy deweloperzy zapisują wrażliwe dane w lokalnej pamięci i szyfrują je kluczem zakodowanym/łatwym do przewidzenia w kodzie. Nie powinno się tego robić, ponieważ pewne odwracanie może pozwolić atakującym na wydobycie poufnych informacji.

**Użycie niebezpiecznych i/lub przestarzałych algorytmów**

Deweloperzy nie powinni używać **przestarzałych algorytmów** do przeprowadzania **sprawdzania** **autoryzacji**, **przechowywania** lub **wysyłania** danych. Niektóre z tych algorytmów to: RC4, MD4, MD5, SHA1... Jeśli **hashe** są używane do przechowywania haseł, powinny być używane hashe odporne na brute-force z solą.

### Inne kontrole

- Zaleca się **obfuskację APK**, aby utrudnić atakującym pracę inżynierii odwrotnej.
- Jeśli aplikacja jest wrażliwa (jak aplikacje bankowe), powinna przeprowadzać **własne kontrole, aby sprawdzić, czy urządzenie jest zrootowane** i działać w konsekwencji.
- Jeśli aplikacja jest wrażliwa (jak aplikacje bankowe), powinna sprawdzić, czy używany jest **emulator**.
- Jeśli aplikacja jest wrażliwa (jak aplikacje bankowe), powinna **sprawdzić swoją integralność przed wykonaniem**, aby sprawdzić, czy została zmodyfikowana.
- Użyj [**APKiD**](https://github.com/rednaga/APKiD), aby sprawdzić, który kompilator/pakiet/obfuskator został użyty do zbudowania APK.

### Aplikacja React Native

Przeczytaj następującą stronę, aby dowiedzieć się, jak łatwo uzyskać dostęp do kodu javascript aplikacji React:

{{#ref}}
react-native-application.md
{{#endref}}

### Aplikacje Xamarin

Przeczytaj następującą stronę, aby dowiedzieć się, jak łatwo uzyskać dostęp do kodu C# aplikacji xamarin:

{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superzapakowane aplikacje

Zgodnie z tym [**postem na blogu**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superzapakowane to algorytm Meta, który kompresuje zawartość aplikacji do jednego pliku. Blog mówi o możliwości stworzenia aplikacji, która dekompresuje tego rodzaju aplikacje... oraz szybszym sposobie, który polega na **wykonaniu aplikacji i zebraniu zdekompresowanych plików z systemu plików.**

### Zautomatyzowana analiza statyczna kodu

Narzędzie [**mariana-trench**](https://github.com/facebook/mariana-trench) jest w stanie znaleźć **luki** poprzez **skanowanie** **kodu** aplikacji. To narzędzie zawiera szereg **znanych źródeł** (które wskazują narzędziu **miejsca**, gdzie **wejście** jest **kontrolowane przez użytkownika**), **sinki** (które wskazują narzędziu **niebezpieczne** **miejsca**, gdzie złośliwe dane wejściowe mogą spowodować szkody) oraz **reguły**. Te reguły wskazują na **kombinację** **źródeł-sinków**, które wskazują na lukę.

Dzięki tej wiedzy, **mariana-trench przejrzy kod i znajdzie możliwe luki w nim**.

### Wycieki sekretów

Aplikacja może zawierać sekrety (klucze API, hasła, ukryte adresy URL, subdomeny...) wewnątrz, które możesz odkryć. Możesz użyć narzędzia takiego jak [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks).

### Ominięcie uwierzytelniania biometrycznego

{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Inne interesujące funkcje

- **Wykonanie kodu**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Wysyłanie SMS-ów**: `sendTextMessage, sendMultipartTestMessage`
- **Funkcje natywne** zadeklarowane jako `native`: `public native, System.loadLibrary, System.load`
- [Przeczytaj to, aby dowiedzieć się, **jak odwrócić funkcje natywne**](reversing-native-libraries.md)

### **Inne sztuczki**

{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Analiza dynamiczna

> Przede wszystkim potrzebujesz środowiska, w którym możesz zainstalować aplikację i całe środowisko (certyfikat Burp CA, Drozer i Frida głównie). Dlatego zaleca się użycie zrootowanego urządzenia (emulowanego lub nie).

### Analiza dynamiczna online

Możesz założyć **darmowe konto** na: [https://appetize.io/](https://appetize.io). Ta platforma pozwala na **przesyłanie** i **wykonywanie** APK, więc jest przydatna do zobaczenia, jak zachowuje się apk.

Możesz nawet **zobaczyć logi swojej aplikacji** w sieci i połączyć się przez **adb**.

![](<../../images/image (831).png>)

Dzięki połączeniu ADB możesz używać **Drozer** i **Frida** wewnątrz emulatorów.

### Analiza dynamiczna lokalna

#### Używając emulatora

- [**Android Studio**](https://developer.android.com/studio) (Możesz tworzyć urządzenia **x86** i **arm**, a według [**tego**](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**najnowsze wersje x86** obsługują biblioteki ARM bez potrzeby używania wolnego emulatora arm).
- Dowiedz się, jak to skonfigurować na tej stronie:

{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Darmowa wersja:** Edycja osobista, musisz założyć konto. _Zaleca się **pobranie** wersji **Z** _**VirtualBox**, aby uniknąć potencjalnych błędów._)
- [**Nox**](https://es.bignox.com) (Darmowy, ale nie obsługuje Frida ani Drozer).

> [!TIP]
> Podczas tworzenia nowego emulatora na jakiejkolwiek platformie pamiętaj, że im większy ekran, tym wolniej będzie działał emulator. Wybierz małe ekrany, jeśli to możliwe.

Aby **zainstalować usługi Google** (jak AppStore) w Genymotion, musisz kliknąć na czerwony oznaczony przycisk na poniższym obrazku:

![](<../../images/image (277).png>)

Zauważ również, że w **konfiguracji Android VM w Genymotion** możesz wybrać **tryb sieci mostkowej** (to będzie przydatne, jeśli będziesz łączyć się z Android VM z innej VM z narzędziami).

#### Użyj fizycznego urządzenia

Musisz włączyć opcje **debugowania**, a byłoby dobrze, gdybyś mógł je **zrootować**:

1. **Ustawienia**.
2. (Od Androida 8.0) Wybierz **System**.
3. Wybierz **Informacje o telefonie**.
4. Naciśnij **Numer kompilacji** 7 razy.
5. Wróć i znajdziesz **Opcje dewelopera**.

> Po zainstalowaniu aplikacji, pierwszą rzeczą, którą powinieneś zrobić, jest jej przetestowanie i zbadanie, co robi, jak działa i zapoznanie się z nią.\
> Sugeruję **przeprowadzenie tej początkowej analizy dynamicznej za pomocą analizy dynamicznej MobSF + pidcat**, abyśmy mogli **nauczyć się, jak działa aplikacja**, podczas gdy MobSF **zbiera** wiele **interesujących** **danych**, które możesz później przeglądać.

### Niezamierzony wyciek danych

**Logowanie**

Deweloperzy powinni być ostrożni, aby nie ujawniać **informacji debugowania** publicznie, ponieważ może to prowadzić do wycieków wrażliwych danych. Narzędzia [**pidcat**](https://github.com/JakeWharton/pidcat) i `adb logcat` są zalecane do monitorowania logów aplikacji w celu identyfikacji i ochrony wrażliwych informacji. **Pidcat** jest preferowane ze względu na łatwość użycia i czytelność.

> [!WARNING]
> Zauważ, że od **nowszych wersji niż Android 4.0**, **aplikacje mogą uzyskiwać dostęp tylko do swoich własnych logów**. Tak więc aplikacje nie mogą uzyskiwać dostępu do logów innych aplikacji.\
> Tak czy inaczej, nadal zaleca się **nie logować wrażliwych informacji**.

**Bufor kopiowania/wklejania**

Oparty na **schowku** framework Androida umożliwia funkcjonalność kopiowania i wklejania w aplikacjach, ale stwarza ryzyko, ponieważ **inne aplikacje** mogą **uzyskiwać dostęp** do schowka, potencjalnie ujawniając wrażliwe dane. Ważne jest, aby **wyłączyć funkcje kopiowania/wklejania** dla wrażliwych sekcji aplikacji, takich jak dane karty kredytowej, aby zapobiec wyciekom danych.

**Logi awarii**

Jeśli aplikacja **zawiesza się** i **zapisuje logi**, te logi mogą pomóc atakującym, szczególnie gdy aplikacja nie może być odwrócona. Aby zminimalizować to ryzyko, unikaj logowania w przypadku awarii, a jeśli logi muszą być przesyłane przez sieć, upewnij się, że są wysyłane przez kanał SSL dla bezpieczeństwa.

Jako pentester, **spróbuj spojrzeć na te logi**.

**Dane analityczne wysyłane do stron trzecich**

Aplikacje często integrują usługi takie jak Google Adsense, co może nieumyślnie **ujawniać wrażliwe dane** z powodu niewłaściwej implementacji przez deweloperów. Aby zidentyfikować potencjalne wycieki danych, zaleca się **przechwycenie ruchu aplikacji** i sprawdzenie, czy jakiekolwiek wrażliwe informacje są wysyłane do usług stron trzecich.

### Bazy danych SQLite

Większość aplikacji będzie używać **wewnętrznych baz danych SQLite** do zapisywania informacji. Podczas testów penetracyjnych zwróć uwagę na **bazy danych** utworzone, nazwy **tabel** i **kolumn** oraz wszystkie **dane** zapisane, ponieważ możesz znaleźć **wrażliwe informacje** (co byłoby luką).\
Bazy danych powinny znajdować się w `/data/data/the.package.name/databases` jak `/data/data/com.mwr.example.sieve/databases`.

Jeśli baza danych zapisuje poufne informacje i jest **szyfrowana**, ale możesz **znaleźć** **hasło** wewnątrz aplikacji, to nadal jest to **luka**.

Wylicz tabele używając `.tables` i wylicz kolumny tabel używając `.schema <table_name>`.

### Drozer (Eksploatacja aktywności, dostawców treści i usług)

Z [Dokumentacji Drozer](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** pozwala na **przyjęcie roli aplikacji Android** i interakcję z innymi aplikacjami. Może robić **wszystko, co może zrobić zainstalowana aplikacja**, takie jak korzystanie z mechanizmu komunikacji międzyprocesowej Androida (IPC) i interakcja z systemem operacyjnym.\
Drozer jest przydatnym narzędziem do **eksploatacji eksportowanych aktywności, eksportowanych usług i dostawców treści**, jak dowiesz się w następnych sekcjach.

### Eksploatacja eksportowanych aktywności

[**Przeczytaj to, jeśli chcesz odświeżyć, czym jest aktywność Androida.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Pamiętaj również, że kod aktywności zaczyna się w metodzie **`onCreate`**.

**Ominięcie autoryzacji**

Gdy aktywność jest eksportowana, możesz wywołać jej ekran z zewnętrznej aplikacji. Dlatego, jeśli aktywność z **wrażliwymi informacjami** jest **eksportowana**, możesz **ominąć** mechanizmy **uwierzytelniania**, aby uzyskać do niej dostęp.

[**Dowiedz się, jak eksploatować eksportowane aktywności za pomocą Drozer.**](drozer-tutorial/index.html#activities)

Możesz również uruchomić eksportowaną aktywność z adb:

- Nazwa pakietu to com.example.demo
- Nazwa eksportowanej aktywności to com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**UWAGA**: MobSF wykryje jako złośliwe użycie _**singleTask/singleInstance**_ jako `android:launchMode` w aktywności, ale z powodu [tego](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), najwyraźniej jest to niebezpieczne tylko w starych wersjach (wersje API < 21).

> [!WSKAZÓWKA]
> Zauważ, że obejście autoryzacji nie zawsze jest luką, zależy to od tego, jak działa obejście i jakie informacje są ujawniane.

**Wycieki wrażliwych informacji**

**Aktywności mogą również zwracać wyniki**. Jeśli uda ci się znaleźć eksportowaną i niechronioną aktywność wywołującą metodę **`setResult`** i **zwracającą wrażliwe informacje**, dochodzi do wycieku wrażliwych informacji.

#### Tapjacking

Jeśli tapjacking nie jest zapobiegany, możesz nadużyć eksportowanej aktywności, aby **zmusić użytkownika do wykonania nieoczekiwanych działań**. Aby uzyskać więcej informacji o [**tym, czym jest Tapjacking, kliknij tutaj**](#tapjacking).

### Wykorzystywanie dostawców treści - Uzyskiwanie dostępu i manipulowanie wrażliwymi informacjami

[**Przeczytaj to, jeśli chcesz odświeżyć, czym jest dostawca treści.**](android-applications-basics.md#content-provider)\
Dostawcy treści są zasadniczo używani do **dzielenia się danymi**. Jeśli aplikacja ma dostępne dostawców treści, możesz być w stanie **wyodrębnić wrażliwe** dane z nich. Interesujące jest również testowanie możliwych **iniekcji SQL** i **przechodzenia po ścieżkach**, ponieważ mogą być podatne.

[**Dowiedz się, jak wykorzystywać dostawców treści za pomocą Drozer.**](drozer-tutorial/index.html#content-providers)

### **Wykorzystywanie usług**

[**Przeczytaj to, jeśli chcesz odświeżyć, czym jest usługa.**](android-applications-basics.md#services)\
Pamiętaj, że działania usługi zaczynają się w metodzie `onStartCommand`.

Usługa to zasadniczo coś, co **może odbierać dane**, **przetwarzać** je i **zwracać** (lub nie) odpowiedź. Jeśli aplikacja eksportuje jakieś usługi, powinieneś **sprawdzić** **kod**, aby zrozumieć, co robi, i **testować** ją **dynamicznie** w celu wyodrębnienia poufnych informacji, omijania środków autoryzacji...\
[**Dowiedz się, jak wykorzystywać usługi za pomocą Drozer.**](drozer-tutorial/index.html#services)

### **Wykorzystywanie odbiorników rozgłoszeniowych**

[**Przeczytaj to, jeśli chcesz odświeżyć, czym jest odbiornik rozgłoszeniowy.**](android-applications-basics.md#broadcast-receivers)\
Pamiętaj, że działania odbiornika rozgłoszeniowego zaczynają się w metodzie `onReceive`.

Odbiornik rozgłoszeniowy będzie czekał na rodzaj wiadomości. W zależności od tego, jak odbiornik obsługuje wiadomość, może być podatny.\
[**Dowiedz się, jak wykorzystywać odbiorniki rozgłoszeniowe za pomocą Drozer.**](#exploiting-broadcast-receivers)

### **Wykorzystywanie schematów / głębokich linków**

Możesz ręcznie szukać głębokich linków, używając narzędzi takich jak MobSF lub skryptów jak [ten](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Możesz **otworzyć** zadeklarowany **schemat** za pomocą **adb** lub **przeglądarki**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Uwaga, że możesz **pominąć nazwę pakietu**, a urządzenie mobilne automatycznie otworzy aplikację, która powinna otworzyć ten link._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Kod wykonany**

Aby znaleźć **kod, który będzie wykonany w aplikacji**, przejdź do aktywności wywoływanej przez deeplink i poszukaj funkcji **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Wrażliwe informacje**

Za każdym razem, gdy znajdziesz deep link, sprawdź, czy **nie odbiera wrażliwych danych (takich jak hasła) za pomocą parametrów URL**, ponieważ każda inna aplikacja może **podszyć się pod deep link i ukraść te dane!**

**Parametry w ścieżce**

Musisz również sprawdzić, czy jakikolwiek deep link używa parametru wewnątrz ścieżki URL, takiego jak: `https://api.example.com/v1/users/{username}`, w takim przypadku możesz wymusić przejście przez ścieżkę, uzyskując dostęp do czegoś takiego jak: `example://app/users?username=../../unwanted-endpoint%3fparam=value`.\
Zauważ, że jeśli znajdziesz poprawne punkty końcowe w aplikacji, możesz być w stanie spowodować **Open Redirect** (jeśli część ścieżki jest używana jako nazwa domeny), **przejęcie konta** (jeśli możesz zmodyfikować dane użytkowników bez tokena CSRF, a podatny punkt końcowy używał poprawnej metody) i inne podatności. Więcej [informacji na ten temat tutaj](http://dphoeniixx.com/2020/12/13-2/).

**Więcej przykładów**

Ciekawy raport o bug bounty [tutaj](https://hackerone.com/reports/855618) dotyczący linków (_/.well-known/assetlinks.json_).

### Inspekcja i weryfikacja warstwy transportowej

- **Certyfikaty nie zawsze są poprawnie sprawdzane** przez aplikacje Android. Często te aplikacje ignorują ostrzeżenia i akceptują certyfikaty samopodpisane lub, w niektórych przypadkach, wracają do używania połączeń HTTP.
- **Negocjacje podczas handshake SSL/TLS są czasami słabe**, wykorzystując niebezpieczne zestawy szyfrów. Ta podatność sprawia, że połączenie jest podatne na ataki typu man-in-the-middle (MITM), co pozwala atakującym na odszyfrowanie danych.
- **Wycieki prywatnych informacji** są ryzykiem, gdy aplikacje uwierzytelniają się za pomocą bezpiecznych kanałów, ale następnie komunikują się przez niebezpieczne kanały w innych transakcjach. Takie podejście nie chroni wrażliwych danych, takich jak ciasteczka sesyjne czy dane użytkowników, przed przechwyceniem przez złośliwe podmioty.

#### Weryfikacja certyfikatu

Skupimy się na **weryfikacji certyfikatu**. Integralność certyfikatu serwera musi być weryfikowana, aby zwiększyć bezpieczeństwo. Jest to kluczowe, ponieważ niebezpieczne konfiguracje TLS i przesyłanie wrażliwych danych przez niezaszyfrowane kanały mogą stwarzać poważne ryzyko. Aby uzyskać szczegółowe kroki dotyczące weryfikacji certyfikatów serwera i rozwiązywania podatności, [**to źródło**](https://manifestsecurity.com/android-application-security-part-10/) oferuje kompleksowe wskazówki.

#### SSL Pinning

SSL Pinning to środek bezpieczeństwa, w którym aplikacja weryfikuje certyfikat serwera w porównaniu do znanej kopii przechowywanej w samej aplikacji. Ta metoda jest niezbędna do zapobiegania atakom MITM. Wdrożenie SSL Pinning jest zdecydowanie zalecane dla aplikacji obsługujących wrażliwe informacje.

#### Inspekcja ruchu

Aby zainstalować ruch HTTP, konieczne jest **zainstalowanie certyfikatu narzędzia proxy** (np. Burp). Bez zainstalowania tego certyfikatu zaszyfrowany ruch może nie być widoczny przez proxy. Aby uzyskać przewodnik dotyczący instalacji niestandardowego certyfikatu CA, [**kliknij tutaj**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Aplikacje celujące w **API Level 24 i wyżej** wymagają modyfikacji konfiguracji bezpieczeństwa sieci, aby zaakceptować certyfikat CA proxy. Ten krok jest kluczowy do inspekcji zaszyfrowanego ruchu. Aby uzyskać instrukcje dotyczące modyfikacji konfiguracji bezpieczeństwa sieci, [**zobacz ten samouczek**](make-apk-accept-ca-certificate.md).

Jeśli używasz **Flutter**, musisz postępować zgodnie z instrukcjami na [**tej stronie**](flutter.md). Dzieje się tak, ponieważ samo dodanie certyfikatu do magazynu nie zadziała, ponieważ Flutter ma swoją własną listę ważnych CA.

#### Obejście SSL Pinning

Gdy SSL Pinning jest wdrożone, konieczne staje się jego obejście, aby zainspirować ruch HTTPS. Istnieje kilka metod w tym celu:

- Automatycznie **zmodyfikuj** **apk**, aby **obejść** SSLPinning za pomocą [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Największą zaletą tej opcji jest to, że nie będziesz potrzebować roota, aby obejść SSL Pinning, ale będziesz musiał usunąć aplikację i zainstalować nową, co nie zawsze działa.
- Możesz użyć **Frida** (omówione poniżej), aby obejść tę ochronę. Oto przewodnik, jak używać Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Możesz także spróbować **automatycznie obejść SSL Pinning** za pomocą [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Możesz również spróbować **automatycznie obejść SSL Pinning** za pomocą **analizy dynamicznej MobSF** (wyjaśnionej poniżej)
- Jeśli nadal uważasz, że istnieje jakiś ruch, którego nie przechwytujesz, możesz spróbować **przekierować ruch do burp za pomocą iptables**. Przeczytaj ten blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Szukanie powszechnych podatności w sieci

Ważne jest również, aby szukać powszechnych podatności w aplikacji. Szczegółowe informacje na temat identyfikacji i łagodzenia tych podatności wykraczają poza zakres tego podsumowania, ale są szeroko omówione w innych miejscach.

### Frida

[Frida](https://www.frida.re) to zestaw narzędzi do dynamicznej instrumentacji dla programistów, inżynierów odwrotnych i badaczy bezpieczeństwa.\
**Możesz uzyskać dostęp do działającej aplikacji i podłączyć metody w czasie rzeczywistym, aby zmienić zachowanie, zmienić wartości, wyodrębnić wartości, uruchomić inny kod...**\
Jeśli chcesz przeprowadzić pentesting aplikacji Android, musisz wiedzieć, jak używać Frida.

- Naucz się, jak używać Frida: [**Samouczek Frida**](frida-tutorial/index.html)
- Nieco "GUI" do działań z Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection jest świetny do automatyzacji użycia Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Możesz znaleźć kilka niesamowitych skryptów Frida tutaj: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Spróbuj obejść mechanizmy anty-debugging / anty-frida, ładując Frida, jak wskazano w [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (narzędzie [linjector](https://github.com/erfur/linjector-rs))

### **Zrzut pamięci - Fridump**

Sprawdź, czy aplikacja przechowuje wrażliwe informacje w pamięci, które nie powinny być przechowywane, takie jak hasła lub mnemoniki.

Używając [**Fridump3**](https://github.com/rootbsd/fridump3), możesz zrzucić pamięć aplikacji za pomocą:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
To będzie zrzut pamięci w folderze ./dump, a tam możesz użyć grep z czymś takim jak:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Wrażliwe dane w Keystore**

W Androidzie Keystore to najlepsze miejsce do przechowywania wrażliwych danych, jednak przy wystarczających uprawnieniach **możliwe jest ich uzyskanie**. Ponieważ aplikacje mają tendencję do przechowywania tutaj **wrażliwych danych w postaci niezaszyfrowanej**, testy penetracyjne powinny to sprawdzić jako użytkownik root lub ktoś z fizycznym dostępem do urządzenia mógłby być w stanie ukraść te dane.

Nawet jeśli aplikacja przechowuje dane w keystore, dane powinny być zaszyfrowane.

Aby uzyskać dostęp do danych wewnątrz keystore, możesz użyć tego skryptu Frida: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Ominięcie odcisków palców/biometrii**

Używając poniższego skryptu Frida, możliwe jest **ominięcie uwierzytelniania odcisków palców**, które aplikacje Android mogą stosować w celu **ochrony niektórych wrażliwych obszarów:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Obrazy w tle**

Kiedy umieszczasz aplikację w tle, Android przechowuje **zrzut ekranu aplikacji**, aby po przywróceniu do pierwszego planu zaczęła ładować obraz przed aplikacją, co sprawia, że wygląda na to, że aplikacja została załadowana szybciej.

Jednakże, jeśli ten zrzut ekranu zawiera **wrażliwe informacje**, ktoś z dostępem do zrzutu może **ukraść te informacje** (zauważ, że potrzebujesz roota, aby uzyskać do niego dostęp).

Zrzuty ekranu są zazwyczaj przechowywane w: **`/data/system_ce/0/snapshots`**

Android zapewnia sposób na **zapobieganie przechwytywaniu zrzutów ekranu poprzez ustawienie parametru układu FLAG_SECURE**. Używając tej flagi, zawartość okna jest traktowana jako bezpieczna, co zapobiega jej pojawianiu się w zrzutach ekranu lub wyświetlaniu na niezabezpieczonych ekranach.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Analizator Aplikacji Android**

To narzędzie może pomóc w zarządzaniu różnymi narzędziami podczas analizy dynamicznej: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Wstrzykiwanie Intencji

Programiści często tworzą komponenty proxy, takie jak aktywności, usługi i odbiorniki rozgłoszeniowe, które obsługują te Intencje i przekazują je do metod takich jak `startActivity(...)` lub `sendBroadcast(...)`, co może być ryzykowne.

Niebezpieczeństwo polega na umożliwieniu atakującym wywoływania nieeksportowanych komponentów aplikacji lub dostępu do wrażliwych dostawców treści poprzez błędne kierowanie tych Intencji. Znaczącym przykładem jest komponent `WebView`, który konwertuje adresy URL na obiekty `Intent` za pomocą `Intent.parseUri(...)`, a następnie je wykonuje, co może prowadzić do złośliwych wstrzyknięć Intencji.

### Kluczowe Wnioski

- **Wstrzykiwanie Intencji** jest podobne do problemu Open Redirect w sieci.
- Eksploity polegają na przekazywaniu obiektów `Intent` jako dodatkowych, które mogą być przekierowywane do wykonywania niebezpiecznych operacji.
- Może to ujawniać nieeksportowane komponenty i dostawców treści atakującym.
- Konwersja URL na `Intent` w `WebView` może ułatwiać niezamierzone działania.

### Wstrzyknięcia po stronie klienta Androida i inne

Prawdopodobnie znasz ten rodzaj podatności z sieci. Musisz być szczególnie ostrożny z tymi podatnościami w aplikacji Android:

- **SQL Injection:** Przy obsłudze dynamicznych zapytań lub dostawców treści upewnij się, że używasz zapytań parametryzowanych.
- **Wstrzykiwanie JavaScript (XSS):** Sprawdź, czy obsługa JavaScript i wtyczek jest wyłączona dla wszelkich WebViews (domyślnie wyłączona). [Więcej informacji tutaj](webview-attacks.md#javascript-enabled).
- **Inkluzja lokalnych plików:** WebViews powinny mieć wyłączony dostęp do systemu plików (domyślnie włączony) - `(webview.getSettings().setAllowFileAccess(false);)`. [Więcej informacji tutaj](webview-attacks.md#javascript-enabled).
- **Wieczne ciasteczka**: W wielu przypadkach, gdy aplikacja androidowa kończy sesję, ciastko nie jest unieważniane lub może być nawet zapisywane na dysku.
- [**Bezpieczna flaga** w ciastkach](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Analiza Automatyczna

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Analiza statyczna**

![](<../../images/image (866).png>)

**Ocena podatności aplikacji** przy użyciu ładnego interfejsu internetowego. Możesz również przeprowadzić analizę dynamiczną (ale musisz przygotować środowisko).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Zauważ, że MobSF może analizować **Android**(apk)**, IOS**(ipa) **i Windows**(apx) aplikacje (_Aplikacje Windows muszą być analizowane z MobSF zainstalowanym na hoście Windows_).\
Ponadto, jeśli stworzysz plik **ZIP** z kodem źródłowym aplikacji **Android** lub **IOS** (przejdź do folderu głównego aplikacji, wybierz wszystko i stwórz plik ZIP), będzie w stanie również go przeanalizować.

MobSF pozwala również na **diff/Compare** analizy oraz na integrację z **VirusTotal** (będziesz musiał ustawić swój klucz API w _MobSF/settings.py_ i włączyć go: `VT_ENABLED = TRUE` `VT_API_KEY = <Twój klucz API>` `VT_UPLOAD = TRUE`). Możesz również ustawić `VT_UPLOAD` na `False`, wtedy **hash** zostanie **przesłany** zamiast pliku.

### Wspomagana analiza dynamiczna z MobSF

**MobSF** może być również bardzo pomocny w **analizie dynamicznej** w **Android**, ale w tym przypadku będziesz musiał zainstalować MobSF i **genymotion** na swoim hoście (VM lub Docker nie zadziała). _Uwaga: Musisz **najpierw uruchomić VM w genymotion** a **potem MobSF.**_\
**MobSF dynamic analyser** może:

- **Zrzucić dane aplikacji** (URL-e, logi, schowek, zrzuty ekranu wykonane przez Ciebie, zrzuty ekranu wykonane przez "**Exported Activity Tester**", e-maile, bazy danych SQLite, pliki XML i inne utworzone pliki). Wszystko to odbywa się automatycznie, z wyjątkiem zrzutów ekranu, musisz nacisnąć, gdy chcesz zrzut ekranu lub musisz nacisnąć "**Exported Activity Tester**", aby uzyskać zrzuty ekranu wszystkich eksportowanych aktywności.
- Przechwytywać **ruch HTTPS**
- Używać **Frida** do uzyskania **informacji w czasie rzeczywistym**

Od wersji Android **> 5**, automatycznie **uruchomi Frida** i ustawi globalne ustawienia **proxy** do **przechwytywania** ruchu. Będzie przechwytywać ruch tylko z testowanej aplikacji.

**Frida**

Domyślnie użyje również niektórych skryptów Frida do **obejścia SSL pinning**, **wykrywania root** i **wykrywania debuggera** oraz do **monitorowania interesujących API**.\
MobSF może również **wywoływać eksportowane aktywności**, robić **zrzuty ekranu** z nich i **zapisywać** je do raportu.

Aby **rozpocząć** testowanie dynamiczne, naciśnij zielony przycisk: "**Start Instrumentation**". Naciśnij "**Frida Live Logs**", aby zobaczyć logi generowane przez skrypty Frida i "**Live API Monitor**", aby zobaczyć wszystkie wywołania do podłączonych metod, przekazywane argumenty i zwracane wartości (to pojawi się po naciśnięciu "Start Instrumentation").\
MobSF pozwala również na załadowanie własnych **skryptów Frida** (aby wysłać wyniki swoich skryptów Frida do MobSF, użyj funkcji `send()`). Ma również **kilka wcześniej napisanych skryptów**, które możesz załadować (możesz dodać więcej w `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), wystarczy **je wybrać**, nacisnąć "**Load**" i nacisnąć "**Start Instrumentation**" (będziesz mógł zobaczyć logi tych skryptów w "**Frida Live Logs**").

![](<../../images/image (419).png>)

Ponadto masz kilka dodatkowych funkcji Frida:

- **Enumerate Loaded Classes**: Wydrukuje wszystkie załadowane klasy
- **Capture Strings**: Wydrukuje wszystkie przechwycone ciągi podczas korzystania z aplikacji (bardzo hałaśliwe)
- **Capture String Comparisons**: Może być bardzo przydatne. Pokaże **2 porównywane ciągi** i czy wynik był prawdziwy czy fałszywy.
- **Enumerate Class Methods**: Podaj nazwę klasy (np. "java.io.File") i wydrukuje wszystkie metody klasy.
- **Search Class Pattern**: Wyszukaj klasy według wzoru
- **Trace Class Methods**: **Śledź** **całą klasę** (zobacz wejścia i wyjścia wszystkich metod klasy). Pamiętaj, że domyślnie MobSF śledzi kilka interesujących metod API Androida.

Gdy wybierzesz moduł pomocniczy, który chcesz użyć, musisz nacisnąć "**Start Instrumentation**" i zobaczysz wszystkie wyniki w "**Frida Live Logs**".

**Shell**

Mobsf oferuje również powłokę z niektórymi poleceniami **adb**, **komendami MobSF** i powszechnymi **komendami powłoki** na dole strony analizy dynamicznej. Niektóre interesujące polecenia:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**Narzędzia HTTP**

Gdy ruch http jest przechwytywany, możesz zobaczyć brzydki widok przechwyconego ruchu na "**HTTP(S) Traffic**" na dole lub ładniejszy widok w zielonym przycisku "**Start HTTPTools**". Z drugiej opcji możesz **wysłać** **przechwycone żądania** do **proxy** takich jak Burp lub Owasp ZAP.\
Aby to zrobić, _włącz Burp -->_ _wyłącz Intercept --> w MobSB HTTPTools wybierz żądanie_ --> naciśnij "**Send to Fuzzer**" --> _wybierz adres proxy_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Po zakończeniu analizy dynamicznej z MobSF możesz nacisnąć "**Start Web API Fuzzer**", aby **fuzzować żądania http** i szukać luk.

> [!TIP]
> Po przeprowadzeniu analizy dynamicznej z MobSF ustawienia proxy mogą być źle skonfigurowane i nie będziesz w stanie ich naprawić z GUI. Możesz naprawić ustawienia proxy, wykonując:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Wspomagana analiza dynamiczna z Inspeckage

Możesz pobrać narzędzie z [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
To narzędzie użyje kilku **Hooks**, aby poinformować cię **co się dzieje w aplikacji** podczas przeprowadzania **analizy dynamicznej**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

To **świetne narzędzie do przeprowadzania analizy statycznej z GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

To narzędzie jest zaprojektowane do wyszukiwania kilku **związanych z bezpieczeństwem luk w aplikacjach Android**, zarówno w **kodzie źródłowym**, jak i **spakowanych APK**. Narzędzie jest również **zdolne do tworzenia "Proof-of-Concept" wdrażalnego APK** oraz **komend ADB**, aby wykorzystać niektóre z wykrytych luk (ujawnione aktywności, intencje, tapjacking...). Podobnie jak w przypadku Drozer, nie ma potrzeby rootowania urządzenia testowego.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Wyświetla wszystkie wyodrębnione pliki dla łatwego odniesienia
- Automatycznie dekompiluje pliki APK do formatu Java i Smali
- Analizuje AndroidManifest.xml pod kątem powszechnych luk i zachowań
- Statyczna analiza kodu źródłowego pod kątem powszechnych luk i zachowań
- Informacje o urządzeniu
- i więcej
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER to aplikacja działająca w wierszu poleceń, która może być używana w systemach Windows, MacOS X i Linux, analizująca pliki _.apk_ w poszukiwaniu luk. Robi to, dekompresując APK i stosując szereg reguł w celu wykrycia tych luk.

Wszystkie reguły są skoncentrowane w pliku `rules.json`, a każda firma lub tester może stworzyć własne reguły, aby analizować to, czego potrzebują.

Pobierz najnowsze pliki binarne z [strony pobierania](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn to **narzędzie wieloplatformowe**, które wspomaga programistów, łowców błędów i etycznych hakerów w przeprowadzaniu [analizy statycznej kodu](https://en.wikipedia.org/wiki/Static_program_analysis) aplikacji mobilnych.

Koncepcja polega na tym, że przeciągasz i upuszczasz plik swojej aplikacji mobilnej (plik .apk lub .ipa) na aplikację StaCoAn, a ona wygeneruje wizualny i przenośny raport dla Ciebie. Możesz dostosować ustawienia i listy słów, aby uzyskać spersonalizowane doświadczenie.

Pobierz [najnowszą wersję](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework to system analizy podatności Android, który pomaga deweloperom lub hakerom znaleźć potencjalne luki w zabezpieczeniach aplikacji na Androida.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** to narzędzie, którego głównym celem jest wykrywanie i ostrzeganie użytkownika o potencjalnych złośliwych zachowaniach rozwijanych przez aplikację na Androida.

Wykrywanie odbywa się za pomocą **analizy statycznej** bajtkodu Dalvik aplikacji, reprezentowanego jako **Smali**, z wykorzystaniem biblioteki [`androguard`](https://github.com/androguard/androguard).

To narzędzie szuka **typowych zachowań "złych" aplikacji**, takich jak: eksfiltracja identyfikatorów telekomunikacyjnych, przechwytywanie strumieni audio/wideo, modyfikacja danych PIM, wykonanie dowolnego kodu...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** to **M**obile **A**pplication **R**everse engineering i **A**nalysis Framework. Jest to narzędzie, które łączy powszechnie używane narzędzia do inżynierii wstecznej i analizy aplikacji mobilnych, aby wspierać testowanie aplikacji mobilnych w kontekście zagrożeń bezpieczeństwa OWASP. Jego celem jest ułatwienie tego zadania i uczynienie go bardziej przyjaznym dla deweloperów aplikacji mobilnych oraz specjalistów ds. bezpieczeństwa.

Może:

- Ekstrahować kod Java i Smali przy użyciu różnych narzędzi
- Analizować APK za pomocą: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Ekstrahować prywatne informacje z APK przy użyciu regexów.
- Analizować Manifest.
- Analizować znalezione domeny za pomocą: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) i [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuskować APK za pomocą [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Przydatne do wykrywania złośliwego oprogramowania: [https://koodous.com/](https://koodous.com)

## Obfuscating/Deobfuscating code

Zauważ, że w zależności od usługi i konfiguracji, której używasz do obfuskacji kodu, sekrety mogą być obfuskowane lub nie.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

Z [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** to narzędzie wiersza poleceń typu open source, które zmniejsza, optymalizuje i obfuskowało kod Java. Potrafi optymalizować bajty kodu oraz wykrywać i usuwać nieużywane instrukcje. ProGuard jest oprogramowaniem darmowym i jest dystrybuowane na licencji GNU General Public License, wersja 2.

ProGuard jest dystrybuowane jako część Android SDK i działa podczas budowania aplikacji w trybie wydania.

### [DexGuard](https://www.guardsquare.com/dexguard)

Znajdź przewodnik krok po kroku, jak deobfuskować apk w [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(Z tego przewodnika) Ostatni raz, gdy sprawdzaliśmy, tryb działania Dexguard był:

- załaduj zasób jako InputStream;
- przekaż wynik do klasy dziedziczącej z FilterInputStream, aby go odszyfrować;
- wykonaj kilka bezużytecznych obfuskacji, aby zmarnować kilka minut czasu odwracającego;
- przekaż odszyfrowany wynik do ZipInputStream, aby uzyskać plik DEX;
- w końcu załaduj wynikowy DEX jako zasób za pomocą metody `loadDex`.

### [DeGuard](http://apk-deguard.com)

**DeGuard odwraca proces obfuskacji wykonywany przez narzędzia obfuskacyjne Androida. Umożliwia to liczne analizy bezpieczeństwa, w tym inspekcję kodu i przewidywanie bibliotek.**

Możesz przesłać obfuskowane APK na ich platformę.

### [Deobfuscate android App](https://github.com/In3tinct/deobfuscate-android-app)

To narzędzie LLM do znajdowania potencjalnych luk w zabezpieczeniach w aplikacjach androidowych i deobfuskacji kodu aplikacji androidowych. Używa publicznego API Gemini od Google'a.

### [Simplify](https://github.com/CalebFenton/simplify)

To **ogólny deobfuskator androidowy.** Simplify **wirtualnie wykonuje aplikację**, aby zrozumieć jej zachowanie, a następnie **stara się zoptymalizować kod**, aby działał identycznie, ale był łatwiejszy do zrozumienia dla człowieka. Każdy typ optymalizacji jest prosty i ogólny, więc nie ma znaczenia, jaki konkretny typ obfuskacji jest używany.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD dostarcza informacji o **tym, jak stworzono APK**. Identyfikuje wiele **kompilatorów**, **packerów**, **obfuskatorów** i innych dziwnych rzeczy. To [_PEiD_](https://www.aldeid.com/wiki/PEiD) dla Androida.

### Manual

[Przeczytaj ten poradnik, aby poznać kilka sztuczek na **jak odwrócić niestandardową obfuskację**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b to wirtualna maszyna bezpieczeństwa Androida oparta na ubuntu-mate, która zawiera zbiór najnowszych frameworków, tutoriali i laboratoriów od różnych geeków i badaczy bezpieczeństwa do inżynierii wstecznej i analizy złośliwego oprogramowania.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) To świetna lista zasobów
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Szybki kurs Androida
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)

## Yet to try

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
