# Pentesting Android aplikacija

{{#include ../../banners/hacktricks-training.md}}

## Osnove Android aplikacija

Toplo se preporučuje da prvo pročitate ovu stranicu da biste se upoznali sa **najvažnijim delovima vezanim za bezbednost Androida i najopasnijim komponentama u Android aplikaciji**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Ovo je glavni alat koji vam treba za povezivanje sa Android uređajem (emuliranim ili fizičkim).\
**ADB** omogućava kontrolu uređaja preko **USB** ili **Network** sa računara. Ovaj alat omogućava **kopiranje** fajlova u oba smera, **instalaciju** i **deinstalaciju** aplikacija, **izvršavanje** shell komandi, **pravljenje bekapa** podataka, **čitanje** logova, između ostalih funkcija.

Pogledajte sledeću listu [**ADB Commands**](adb-commands.md) da biste naučili kako da koristite adb.

## Smali

Ponekad je korisno **izmeniti kod aplikacije** kako biste pristupili **skrivenim informacijama** (npr. dobro obfuskiranim lozinkama ili flagovima). U tom slučaju može biti korisno dekompajlirati APK, izmeniti kod i ponovo ga sastaviti.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Ovo može biti veoma korisno kao **alternativa za nekoliko testova tokom dinamičke analize** koji će biti predstavljeni. Dakle, **uvek imajte na umu ovu mogućnost**.

## Other interesting tricks

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Izdvajanje APK-a sa uređaja:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Spojite sve splits i base apks pomoću [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Android Enterprise & Work Profile Attacks

{{#ref}}
android-enterprise-work-profile-bypass.md
{{#endref}}

## Studije slučaja i ranjivosti


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Statička analiza

Pre svega, za analizu APK-a trebalo bi da **pogledate Java kod** koristeći decompiler.\
Molimo, [**pročitajte ovde da nađete informacije o različitim dostupnim decompiler-ima**](apk-decompilers.md).

### Potraga za zanimljivim informacijama

Samo pregledanjem **strings** u APK-u možete tražiti **lozinke**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **API** ključeve, **šifrovanje**, **Bluetooth UUID-ove**, **tokens** i sve što je interesantno... tražite čak i kod-exec backdoore ili backdoore za autentikaciju (hardkodovani admin kredencijali u aplikaciji).

**Firebase**

Obratite posebnu pažnju na **Firebase URLs** i proverite da li je loše konfigurisan. [Više informacija o tome šta je Firebase i kako ga iskoristiti ovde.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Osnovno razumevanje aplikacije - Manifest.xml, strings.xml

**Pregled _Manifest.xml_ i **_strings.xml_** fajlova aplikacije može otkriti potencijalne bezbednosne slabosti**. Ovi fajlovi su dostupni putem decompiler-a ili preimenovanjem APK fajla u .zip i potom raspakovanjem.

**Ranjivosti** koje se mogu identifikovati iz **Manifest.xml** uključuju:

- **Debuggable Applications**: Aplikacije koje su podešene kao debuggable (`debuggable="true"`) u _Manifest.xml_ predstavljaju rizik jer dozvoljavaju konekcije koje mogu dovesti do eksploatacije. Za dalje razumevanje kako iskorišćavati debuggable aplikacije, pogledajte tutorijal o pronalaženju i iskorišćavanju debuggable aplikacija na uređaju.
- **Backup Settings**: Atribut `android:allowBackup="false"` treba eksplicitno biti postavljen za aplikacije koje rade sa osetljivim informacijama kako bi se sprečilo neovlašćeno pravljenje backup-a putem adb-a, posebno kada je usb debugging omogućen.
- **Network Security**: Custom network security konfiguracije (`android:networkSecurityConfig="@xml/network_security_config"`) u _res/xml/_ mogu specificirati detalje poput certificate pin-ovanja i podešavanja HTTP saobraćaja. Primer je dozvoljavanje HTTP saobraćaja za određene domene.
- **Exported Activities and Services**: Identifikovanje eksportovanih aktivnosti i servisa u manifestu može ukazati na komponente koje bi mogle biti zloupotrebljene. Dalja analiza tokom dinamičkog testiranja može otkriti načine za iskorišćavanje ovih komponenti.
- **Content Providers and FileProviders**: Izloženi content provider-i mogu dozvoliti neovlašćen pristup ili modifikaciju podataka. Konfiguracija FileProvider-a takođe zahteva detaljnu proveru.
- **Broadcast Receivers and URL Schemes**: Ove komponente mogu biti iskorišćene za napad, sa posebnom pažnjom na način na koji su URL scheme-ovi obrađeni zbog mogućih ulaznih ranjivosti.
- **SDK Versions**: Atributi `minSdkVersion`, `targetSDKVersion`, i `maxSdkVersion` ukazuju na podržane Android verzije, naglašavajući važnost ne podržavanja zastarelih, ranjivih verzija Android-a iz bezbednosnih razloga.

Iz **strings.xml** fajla mogu se otkriti osetljive informacije poput API ključeva, custom schema, i drugih beleški developera, što naglašava potrebu za pažljivim pregledom ovih resursa.

### Tapjacking

**Tapjacking** je napad gde se **maliciozna** **aplikacija** pokreće i **pozicionira iznad žrtvine aplikacije**. Kada vizuelno zakloni žrtvinu aplikaciju, njen korisnički interfejs je dizajniran tako da prevari korisnika da interaguje sa njim, dok se ta interakcija prosleđuje žrtvinoj aplikaciji.\
U suštini, to je **zaslepljivanje korisnika kako ne bi znao da zapravo izvodi akcije u žrtvinoj aplikaciji**.

Više informacija potražite u:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Aktivnost sa **`launchMode`** postavljenim na **`singleTask` bez definisanog `taskAffinity`** je ranjiva na Task Hijacking. To znači da se **maliciozna aplikacija** može instalirati i ako se pokrene pre prave aplikacije, može **oteti task prave aplikacije** (tako da će korisnik interagovati sa **malicioznom aplikacijom misleći da koristi pravu**).

Više informacija u:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Nesigurno čuvanje podataka

**Interna memorija**

U Android-u, fajlovi **smešteni** u **internal** storage su **dizajnirani** da budu **pristupačni** isključivo aplikaciji koja ih je **kreirala**. Ova mera bezbednosti je **sprovodena** od strane Android operativnog sistema i uglavnom je dovoljna za bezbednosne potrebe većine aplikacija. Međutim, developeri ponekad koriste modove kao što su `MODE_WORLD_READABLE` i `MODE_WORLD_WRITABLE` da bi **dozvolili** deljenje fajlova između različitih aplikacija. Ipak, ovi modovi **ne ograničavaju pristup** tim fajlovima od strane drugih aplikacija, uključujući potencijalno maliciozne.

1. **Statička analiza:**
- **Proverite** upotrebu `MODE_WORLD_READABLE` i `MODE_WORLD_WRITABLE` i izvršite **pažljivu reviziju**. Ovi modovi **mogu potencijalno izložiti** fajlove nepredviđenom ili neovlašćenom pristupu.
2. **Dinamička analiza:**
- **Verifikujte** permisije podešene na fajlovima koje aplikacija kreira. Konkretno, **proverite** da li su neki fajlovi **podešeni kao čitljivi ili zapisivi globalno**. Ovo može predstavljati značajan bezbednosni rizik, jer bi **bilo koja aplikacija** instalirana na uređaju, bez obzira na poreklo ili nameru, mogla **čitati ili modifikovati** ove fajlove.

**Eksterna memorija**

Kada radite sa fajlovima na **external storage**, kao što su SD kartice, treba preduzeti određene mere opreza:

1. **Pristupačnost**:
- Fajlovi na external storage su **globalno čitljivi i zapisivi**. To znači da svaka aplikacija ili korisnik može pristupiti ovim fajlovima.
2. **Bezbednosne zabrinutosti**:
- S obzirom na lakoću pristupa, savetuje se **ne čuvati osetljive informacije** na external storage.
- External storage može biti uklonjen ili pristupljen od strane bilo koje aplikacije, što ga čini manje sigurnim.
3. **Rukovanje podacima iz external storage**:
- Uvek **izvršite validaciju ulaza** na podacima preuzetim sa external storage. Ovo je ključno jer podaci dolaze iz nepouzdanog izvora.
- Skladištenje izvršnih fajlova ili class fajlova na external storage za dinamičko učitavanje se snažno ne preporučuje.
- Ako vaša aplikacija mora da preuzme izvršne fajlove sa external storage, obavezno da ti fajlovi budu **potpisani i kriptografski verifikovani** pre nego što se dinamički učitaju. Ovaj korak je vitalan za održavanje bezbednosnog integriteta vaše aplikacije.

External storage može biti **pristupljen** u `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> Počevši od Android 4.4 (**API 17**), SD kartica ima strukturu direktorijuma koja **ograničava pristup aplikacije na direktorijum koji je specifično za tu aplikaciju**. Ovo sprečava maliciozne aplikacije da dobiju read ili write pristup fajlovima druge aplikacije.

**Osetljivi podaci sačuvani u plain-textu**

- **Shared preferences**: Android omogućava svakoj aplikaciji da lako sačuva xml fajlove u putanji `/data/data/<packagename>/shared_prefs/` i ponekad je moguće pronaći osetljive informacije u plain-textu u tom folderu.
- **Databases**: Android omogućava svakoj aplikaciji da lako sačuva sqlite baze podataka u putanji `/data/data/<packagename>/databases/` i ponekad je moguće pronaći osetljive informacije u plain-textu u tom folderu.

### Broken TLS

**Accept All Certificates**

Iz nekog razloga, ponekad developeri prihvataju sve sertifikate čak i kada, na primer, hostname ne odgovara, sa linijama koda kao u sledećem primeru:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Dobar način da ovo testirate je pokušaj presretanja saobraćaja koristeći neki proxy kao što je Burp bez autorizacije Burp CA unutar uređaja. Takođe, možete sa Burp-om generisati sertifikat za drugačiji hostname i koristiti ga.

### Neispravna kriptografija

**Loši procesi upravljanja ključevima**

Neki developeri čuvaju osetljive podatke u lokalnoj memoriji i enkriptuju ih ključem hardcoded/predictable u kodu. Ovo ne bi trebalo raditi jer malo reverse-engineering-a može omogućiti napadačima da izvuku poverljive informacije.

**Upotreba nesigurnih i/ili zastarelih algoritama**

Developeri ne bi trebalo da koriste **zastarele algoritme** za izvršavanje autorizacionih **provera**, **sređivanje** ili **slanje** podataka. Neki od ovih algoritama su: RC4, MD4, MD5, SHA1... Ako se koriste **hashes** za čuvanje lozinki na primer, treba koristiti hashove otpornе na brute-force sa salt-om.

### Ostale provere

- Preporučuje se da **obfuscate the APK** kako biste otežali posao reverse engineer-ima.
- Ako je app osetljiv (npr. bankarske aplikacije), treba da vrši sopstvene provere da li je mobilni uređaj **rooted** i da postupi u skladu sa tim.
- Ako je app osetljiv (npr. bankarske aplikacije), treba da proveri da li se koristi **emulator**.
- Ako je app osetljiv (npr. bankarske aplikacije), treba da **proveri sopstveni integritet pre izvršavanja** da bi utvrdila da li je modifikovana.
- Koristite [**APKiD**](https://github.com/rednaga/APKiD) da proverite koji compiler/packer/obfuscator je korišćen za izgradnju APK-a

### React Native Application

Pročitajte sledeću stranu da biste naučili kako lako pristupiti javascript kodu React aplikacija:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Pročitajte sledeću stranu da biste naučili kako lako pristupiti C# kodu xamarin aplikacija:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

Prema ovom [**blog postu**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked je Meta algoritam koji kompresuje sadržaj aplikacije u jednu datoteku. Blog govori o mogućnosti kreiranja aplikacije koja dekompresuje ovakve aplikacije... i o bržem načinu koji podrazumeva **izvršavanje aplikacije i prikupljanje dekompresovanih fajlova iz fajl sistema.**

### Automated Static Code Analysis

Alat [**mariana-trench**](https://github.com/facebook/mariana-trench) je sposoban da pronađe **ranjivosti** skeniranjem **koda** aplikacije. Ovaj alat sadrži niz **poznatih izvora** (koji ukazuju alatu **mesta** gde je **input** **kontrolisan od strane korisnika**), **sinks** (koji ukazuju alatu na **opasna** **mesta** gde zlonameran korisnički input može da prouzrokuje štetu) i **pravila**. Ta pravila ukazuju na **kombinaciju** **sources-sinks** koja označava ranjivost.

S tim znanjem, **mariana-trench će pregledati kod i pronaći moguće ranjivosti u njemu**.

### Secrets leaked

Aplikacija može sadržati tajne (API keys, lozinke, skrivene urls, subdomene...) unutar sebe koje biste mogli otkriti. Možete koristiti alat kao što je https://github.com/dwisiswant0/apkleaks

### Zaobilaženje biometrijske autentifikacije


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Ostale interesantne funkcije

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)
- In-memory native code execution via JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Ostali trikovi**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dinamička analiza

> Pre svega, potrebno je okruženje gde možete instalirati aplikaciju i svu prateću infrastrukturu (Burp CA cert, Drozer i Frida pre svega). Stoga je veoma preporučljiv rooted uređaj (emuliran ili ne).

### Online Dynamic analysis

Možete kreirati **besplatan nalog** na: [https://appetize.io/](https://appetize.io). Ova platforma vam dozvoljava da **upload**-ujete i **izvršite** APK-ove, tako da je korisna da vidite kako se apk ponaša.

Možete čak **videti logove vaše aplikacije** na webu i povezati se putem **adb**.

![](<../../images/image (831).png>)

Zahvaljujući ADB konekciji možete koristiti **Drozer** i **Frida** unutar emulatora.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (Možete kreirati **x86** i **arm** uređaje, i prema [**ovome**](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**najnovije x86** verzije **podržavaju ARM biblioteke** bez potrebe za sporim arm emulatorom).
- Naučite kako da ga podesite na ovoj strani:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, potrebno je kreirati nalog. _Preporučuje se da **preuzmete** verziju **WITH**_ _**VirtualBox** da biste izbegli potencijalne greške._)
- [**Nox**](https://es.bignox.com) (Besplatan, ali ne podržava Frida ili Drozer).

> [!TIP]
> Kada kreirate novi emulator na bilo kojoj platformi zapamtite da što je ekran veći to će emulator raditi sporije. Zato, ako je moguće, izaberite male ekrane.

Da biste **instalirali google services** (kao AppStore) u Genymotion potrebno je da kliknete na crveno obeleženo dugme sa sledeće slike:

![](<../../images/image (277).png>)

Takođe, obratite pažnju da u **konfiguraciji Android VM u Genymotion-u** možete izabrati **Bridge Network mode** (ovo će biti korisno ako ćete se povezivati na Android VM iz drugog VM-a sa alatima).

#### Use a physical device

Potrebno je aktivirati **developer options** i bilo bi poželjno da ga možete **root**-ovati:

1. **Settings**.
2. (FromAndroid 8.0) Izaberite **System**.
3. Izaberite **About phone**.
4. Pritisnite **Build number** 7 puta.
5. Vratite se nazad i naći ćete **Developer options**.

> Kada instalirate aplikaciju, prva stvar koju treba da uradite je da je isprobate, istražite šta radi, kako radi i da se upoznate sa njom.\
> Predlažem da **izvršite ovu početnu dinamičku analizu koristeći MobSF dynamic analysis + pidcat**, tako ćemo moći da **naučimo kako aplikacija radi** dok MobSF **hvata** mnogo **zanimljivih** **podataka** koje možete kasnije pregledati.

Magisk/Zygisk kratke napomene (preporučeno na Pixel uređajima)
- Patch-ujte boot.img pomoću Magisk aplikacije i flash-ujte preko fastboot-a da biste dobili systemless root
- Omogućite Zygisk + DenyList za skrivanje root-a; razmotrite LSPosed/Shamiko kada je potrebno jače skrivanje
- Sačuvajte originalni boot.img da biste se oporavili nakon OTA update-a; ponovo patch-ujte nakon svakog OTA
- Za screen mirroring, koristite scrcpy na hostu



### Unintended Data Leakage

**Logging**

Developeri treba da budu oprezni oko izlaganja **debugging information** javno, jer to može dovesti do curenja osetljivih podataka. Alati [**pidcat**](https://github.com/JakeWharton/pidcat) i `adb logcat` su preporučeni za praćenje logova aplikacije kako biste identifikovali i zaštitili osetljive informacije. **Pidcat** je omiljen zbog jednostavnosti korišćenja i čitljivosti.

> [!WARNING]
> Imajte u vidu da od **kasnije novije od Android 4.0**, **aplikacije mogu pristupiti samo svojim logovima**. Tako da aplikacije ne mogu pristupiti logovima drugih aplikacija.\
> U svakom slučaju, i dalje se preporučuje da **ne logujete osetljive informacije**.

**Copy/Paste Buffer Caching**

Androidov **clipboard-based** framework omogućava copy-paste funkcionalnost u aplikacijama, ali predstavlja rizik jer **drugi aplikacije** mogu **pristupiti** clipboard-u, potencijalno otkrivajući osetljive podatke. Ključno je **onemogućiti copy/paste** funkcije za osetljive delove aplikacije, poput podataka o kreditnim karticama, kako biste sprečili data leaks.

**Crash Logs**

Ako aplikacija **crash**-uje i **sačuva logove**, ti logovi mogu pomoći napadačima, posebno kada aplikacija ne može biti reverse-engineer-ovana. Da biste ublažili ovaj rizik, izbegavajte logovanje pri crash-evima, a ako logovi moraju biti poslati preko mreže, osigurajte da se šalju putem SSL kanala.

Kao pentester, **pokušajte da pogledate ove logove**.

**Analytics Data Sent To 3rd Parties**

Aplikacije često integrišu servise kao što je Google Adsense, koji mogu nenamerno **leak sensitive data** zbog nepravilne implementacije od strane developera. Da biste identifikovali potencijalne data leaks, preporučljivo je **interceptovati saobraćaj aplikacije** i proveriti da li se bilo kakve osetljive informacije šalju trećim stranama.

### SQLite DBs

Većina aplikacija koristi **internal SQLite databases** za čuvanje informacija. Tokom pentesta pogledajte **baze podataka** koje su kreirane, nazive **tabela** i **kolona** i sve **sačuvane podatke** jer možete naći **osetljive informacije** (što bi predstavljalo ranjivost).\
Baze podataka bi trebalo da se nalaze u `/data/data/the.package.name/databases` kao `/data/data/com.mwr.example.sieve/databases`

Ako baza podataka čuva poverljive informacije i **encrypted** je ali možete **naći** lozinku unutar aplikacije, to je i dalje **ranjivost**.

Enumerišite tabele koristeći `.tables` i enumerišite kolone tabela koristeći `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

Iz [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** vam omogućava da **preuzmete ulogu Android aplikacije** i interagujete sa drugim aplikacijama. Može uraditi **bilo šta što instalirana aplikacija može**, kao što je korišćenje Android-ovog mehanizma Inter-Process Communication (IPC) i interakcija sa osnovnim operativnim sistemom. .\
Drozer je koristan alat za **eksploatisanje exported activities, exported services i Content Providers** kao što ćete naučiti u sledećim sekcijama.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Takođe zapamtite da kod jedne activity počinje u **`onCreate`** metodi.

**Authorisation bypass**

Kada je Activity exported možete pozvati njen ekran iz spoljne app. Dakle, ako je aktivnost sa **osetljivim informacijama** **exported** možete **zaobići** **autentifikacione** mehanizme **da biste joj pristupili.**

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

Takođe možete pokrenuti exported activity iz adb-a:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NAPOMENA**: MobSF će detektovati kao zlonamerno korišćenje _**singleTask/singleInstance**_ kao `android:launchMode` u aktivnosti, ali zbog [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), izgleda da je ovo opasno samo na starijim verzijama (API versions < 21).

> [!TIP]
> Imajte na umu da authorisation bypass nije uvek ranjivost — zavisi od načina na koji bypass funkcioniše i koje informacije su izložene.

**Otkrivanje osetljivih informacija**

Aktivnosti takođe mogu vraćati rezultate. Ako uspete da pronađete exported i nezaštićenu aktivnost koja poziva metod `setResult` i vraća osetljive informacije, dolazi do curenja osetljivih informacija.

#### Tapjacking

Ako Tapjacking nije preventivan, možete zlostavljati exported aktivnost da naterate **korisnika da izvrši neočekivane radnje**. For more info about [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers se uglavnom koriste za **deljenje podataka**. Ako aplikacija ima dostupne content providere, možda ćete moći da **izvučete osetljive** podatke iz njih. Takođe je interesantno testirati moguće **SQL injections** i **Path Traversals** jer mogu biti ranjivi.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Zapamtite da se akcije Service-a pokreću u metodi `onStartCommand`.

Service je u suštini nešto što **može primati podatke**, **obrađivati** ih i **vraćati** (ili ne) odgovor. Dakle, ako aplikacija eksportuje neke servise treba da **proverite** **kod** da biste razumeli šta radi i **testirate** ga **dinamički** radi izvlačenja poverljivih informacija, zaobilaženja mera autentifikacije...\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Zapamtite da se akcije Broadcast Receiver-a pokreću u metodi `onReceive`.

Broadcast receiver će čekati određeni tip poruke. U zavisnosti od toga kako receiver obrađuje poruku, može biti ranjiv.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Možete ručno tražiti deep linkove koristeći alate kao MobSF ili skripte kao [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Možete **otvoriti** deklarisani **scheme** koristeći **adb** ili **pregledač**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Imajte na umu da možete **izostaviti naziv paketa** i mobilni uređaj će automatski pozvati aplikaciju koja treba da otvori taj link._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Kod koji će biti izvršen**

Da biste pronašli **kod koji će biti izvršen u aplikaciji**, otvorite aktivnost koju poziva deeplink i potražite funkciju **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Osetljive informacije**

Svaki put kada pronađete deep link, proverite da li **ne prima osetljive podatke (npr. lozinke) putem URL parametara**, jer bilo koja druga aplikacija može **imitiраti deep link i ukrasti te podatke!**

**Parametri u putanji**

Takođe morate proveriti da li neki deep link koristi parametar unutar putanje URL-a, kao npr.: `https://api.example.com/v1/users/{username}` , u tom slučaju možete forsirati path traversal pristupom nečemu poput: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Imajte na umu da ako pronađete odgovarajuće endpoint-e unutar aplikacije, možete izazvati **Open Redirect** (ako se deo putanje koristi kao domain name), **account takeover** (ako možete izmeniti users details bez CSRF tokena i ranjiv endpoint koristi odgovarajuću metodu) i bilo koju drugu vuln. More [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Inspekcija transportnog sloja i greške u verifikaciji

- **Sertifikati nisu uvek pravilno proveravani** od strane Android aplikacija. Često te aplikacije zanemare upozorenja i prihvate self-signed certificates ili, u nekim slučajevima, pređu na HTTP konekcije.
- **Pregovori tokom SSL/TLS handshake-a ponekad su slabi**, koristeći nesigurne cipher suites. Ova ranjivost čini vezu podložnom man-in-the-middle (MITM) napadima, omogućavajući napadačima da dešifruju podatke.
- **Icurenje privatnih informacija** predstavlja rizik kada se aplikacije autentifikuju koristeći sigurne kanale, ali zatim komuniciraju preko nesigurnih kanala za druge transakcije. Ovakav pristup ne štiti osetljive podatke, kao što su session cookies ili user details, od presretanja od strane zlonamernih entiteta.

#### Provera sertifikata

Fokusiraćemo se na **certificate verification**. Integritet serverovog sertifikata mora biti verifikovan da bi se povećala bezbednost. Ovo je ključno zato što nesigurne TLS konfiguracije i prenos osetljivih podataka preko nekriptovanih kanala mogu predstavljati značajan rizik. Za detaljne korake o proveri server sertifikata i otklanjanju ranjivosti, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) pruža sveobuhvatno uputstvo.

#### SSL Pinning

SSL Pinning je mera bezbednosti gde aplikacija verifikuje serverov sertifikat u odnosu na poznatu kopiju smeštenu unutar same aplikacije. Ova metoda je ključna za sprečavanje MITM napada. Implementacija SSL Pinning-a se snažno preporučuje za aplikacije koje obrađuju osetljive informacije.

#### Inspekcija saobraćaja

Da biste pregledali HTTP saobraćaj, neophodno je **instalirati sertifikat proxy alata** (npr. Burp). Bez instaliranja ovog sertifikata, enkriptovan saobraćaj možda neće biti vidljiv kroz proxy. Za vodič o instalaciji custom CA sertifikata, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Aplikacije koje targetuju **API Level 24 and above** zahtevaju izmene Network Security Config da bi prihvatile proxy-jev CA sertifikat. Ovaj korak je kritičan za inspekciju enkriptovanog saobraćaja. Za instrukcije o izmeni Network Security Config, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

Ako se koristi **Flutter**, potrebno je pratiti instrukcije na [**this page**](flutter.md). Ovo je zato što samo dodavanje sertifikata u store neće raditi, jer Flutter ima sopstvenu listu valid CAs.

#### Statičko otkrivanje SSL/TLS pinning-a

Pre nego što pokušate runtime bypass-e, brzo mapirajte gde se pinning sprovodi u APK-u. Statičko otkrivanje pomaže da isplanirate hooks/patches i da se fokusirate na prave kodne putanje.

Tool: SSLPinDetect
- Alat otvorenog koda za statičku analizu koji dekompajlira APK u Smali (preko apktool) i skenira kurirane regex obrasce implementacija SSL/TLS pinning-a.
- Izveštava tačnu putanju fajla, broj linije i isečak koda za svaki match.
- Obuhvata common frameworks i custom code paths: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

Instalacija
- Zahtevi: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Korišćenje
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Primer pravila obrazaca (JSON)
Koristite ili proširite signatures da detektujete vlasničke/prilagođene stilove pinning-a. Možete učitati svoj JSON i skenirati na velikoj skali.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Beleške i saveti
- Brzo skeniranje velikih aplikacija pomoću multi-threadinga i memory-mapped I/O; prekompajlirani regex smanjuje overhead/lažno pozitivne rezultate.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Tipični ciljevi za dalju trijažu:
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Deklarativne pins u res/xml network security config i reference u manifestu
- Koristi pronađene lokacije za planiranje Frida hooks, statičkih patch-eva ili pregleda konfiguracije pre dinamičkog testiranja.



#### Zaobilaženje SSL Pinning-a

Kada je SSL Pinning implementiran, njegovo zaobilaženje postaje neophodno za inspekciju HTTPS saobraćaja. Za ovu svrhu dostupne su različite metode:

- Automatski **izmeni** **apk** da **zaobiđeš** SSLPinning pomoću [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Najveća prednost ove opcije je što ti neće trebati root za zaobilaženje SSL Pinning-a, ali ćeš morati obrisati aplikaciju i instalirati novu verziju, i ovo neće uvek raditi.
- Možeš koristiti **Frida** (opisana niže) za zaobilaženje ove zaštite. Ovde je vodič za korišćenje Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Takođe možeš pokušati **automatski zaobići SSL Pinning** koristeći [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Takođe možeš pokušati **automatski zaobići SSL Pinning** koristeći **MobSF dynamic analysis** (objašnjeno niže)
- Ako i dalje misliš da postoji saobraćaj koji ne hvataš, možeš pokušati **proslediti saobraćaj ka burp-u koristeći iptables**. Pročitaj ovaj blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Potraga za uobičajenim web ranjivostima

Važno je takođe tražiti uobičajene web ranjivosti unutar aplikacije. Detaljne informacije o identifikaciji i ublažavanju ovih ranjivosti su izvan opsega ovog pregleda, ali su opširno obrađene na drugim mestima.

### Frida

[Frida](https://www.frida.re) je dinamički alat za instrumentaciju za developere, reverse-engineere i istraživače bezbednosti.\
**Možeš pristupiti pokrenutoj aplikaciji i hook-ovati metode u runtime-u da promeniš ponašanje, promeniš vrednosti, ekstrahuješ vrednosti, pokreneš drugačiji kod...**\
Ako želiš da pentest Android aplikacije moraš znati kako da koristiš Frida.

- Nauči kako da koristiš Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Neki "GUI" za rad sa Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection je odličan za automatizaciju korišćenja Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Možeš naći neke Awesome Frida skripte ovde: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Pokušaj da zaobiđeš anti-debugging / anti-frida mehanizme učitavanjem Frida kako je opisano u [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (alat [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

Proveri da li aplikacija čuva osetljive informacije u memoriji koje ne bi smela čuvati, poput lozinki ili mnemonic-a.

Using [**Fridump3**](https://github.com/rootbsd/fridump3) you can dump the memory of the app with:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Ovo će ispisati memoriju u ./dump folder, i tamo možete koristiti grep sa nečim poput:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Osetljivi podaci u Keystore**

Na Androidu Keystore je najbolje mesto za čuvanje osetljivih podataka, međutim, uz dovoljne privilegije i dalje je **moguće mu pristupiti**. Pošto aplikacije često ovde čuvaju **osetljive podatke u nešifrovanom obliku**, pentests bi to trebalo da provere kao root user, jer neko sa fizičkim pristupom uređaju može da ukrade te podatke.

Čak i ako aplikacija skladišti podatke u keystore, podaci bi trebalo da budu šifrovani.

Za pristup podacima unutar keystore-a možete koristiti ovaj Frida script: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Korišćenjem sledećeg Frida skripta moguće je **bypass fingerprint authentication** koju Android aplikacije mogu koristiti da bi **zaštitile određene osetljive oblasti:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Pozadinske slike**

Kada stavite aplikaciju u pozadinu, Android čuva **snimak aplikacije** tako da kada se vrati u prvi plan počne da učitava sliku pre same aplikacije pa izgleda kao da se aplikacija učitala brže.

Međutim, ako ovaj snimak sadrži **osetljive informacije**, neko ko ima pristup snimku može **ukrasti te podatke** (imajte na umu da je potreban root za pristup).

Snimci se obično čuvaju na lokaciji: **`/data/system_ce/0/snapshots`**

Android pruža način da **spreči snimanje ekrana postavljanjem FLAG_SECURE** layout parametra. Korišćenjem ovog flag-a, sadržaj prozora se tretira kao bezbedan, sprečavajući njegovo pojavljivanje u snimcima ekrana ili pregledanje na nezaštićenim prikazima.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Ovaj alat može pomoći pri upravljanju različitim alatima tokom dinamičke analize: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Programeri često kreiraju proxy komponente poput activities, services i broadcast receivers koje obrađuju ove Intents i prosleđuju ih metodama kao što su `startActivity(...)` ili `sendBroadcast(...)`, što može biti rizično.

Opasnost leži u tome što napadači mogu da pokrenu non-exported app components ili pristupe osetljivim content providers usmeravanjem ovih Intents na pogrešan način. Značajan primer je `WebView` komponenta koja konvertuje URL-ove u `Intent` objekte pomoću `Intent.parseUri(...)` i zatim ih izvršava, što može dovesti do malicioznih Intent injections.

### Suštinske napomene

- **Intent Injection** je sličan web-ovom Open Redirect issue.
- Eksploati uključuju prosleđivanje `Intent` objekata kao extras, koji mogu biti preusmereni da izvrše nesigurne operacije.
- Može izložiti non-exported komponente i content providers napadačima.
- Konverzija URL-a u `Intent` od strane `WebView` može omogućiti neželjene akcije.

### Android Client Side Injections i ostalo

Verovatno već znate za ovu vrstu ranjivosti sa Weba. Morate biti posebno oprezni sa ovim ranjivostima u Android aplikaciji:

- **SQL Injection:** Kada radite sa dinamičkim upitima ili Content-Providers, obavezno koristite parametrizovane upite.
- **JavaScript Injection (XSS):** Proverite da li je podrška za JavaScript i Plugin onemogućena za bilo koji WebView (po defaultu onemogućeno). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews bi trebalo da nemaju pristup fajl sistemu (podrazumevano omogućen) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: U nekoliko slučajeva, kada Android aplikacija završi sesiju, cookie nije opozvan ili čak može biti sačuvan na disk
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatska analiza

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Static analysis**

![](<../../images/image (866).png>)

**Procena ranjivosti aplikacije** koristeći lep web-based frontend. Takođe možete izvršiti dynamic analysis (ali morate pripremiti okruženje).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Pomognuta Dynamic analysis sa MobSF

**MobSF** takođe može biti veoma koristan za Dynamic analysis na **Android**, ali u tom slučaju treba da instalirate **MobSF** i **genymotion** na vaš host (a **VM** ili **Docker** neće raditi). _Napomena: prvo treba da pokrenete **VM u genymotion**, a zatim **MobSF**._\
The **MobSF dynamic analyser** može:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). Sve ovo se radi automatski osim za screenshots — za njih morate pritisnuti kad želite screenshot ili pritisnuti "**Exported Activity Tester**" da biste dobili screenshots svih exported activities.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: Ispisaće sve učitane klase
- **Capture Strings**: Ispisaće sve uhvaćene stringove tokom korišćenja aplikacije (veoma noisy)
- **Capture String Comparisons**: Može biti veoma korisno. Pokazaće 2 stringa koja se porede i da li je rezultat True ili False.
- **Enumerate Class Methods**: Unesite ime klase (npr. "java.io.File") i ispišaće sve metode te klase.
- **Search Class Pattern**: Pretražuje klase po pattern-u
- **Trace Class Methods**: **Trace** cele klase (vidite inpute i outpute svih metoda klase). Zapamtite da po defaultu MobSF trace-uje nekoliko interesantnih Android Api metoda.

Kada izaberete pomoćni modul koji želite da koristite, potrebno je da pritisnete "**Start Intrumentation**" i videćete sve izlaze u "**Frida Live Logs**".

**Shell**

Mobsf takođe donosi shell sa nekim **adb** komandama, **MobSF commands**, i uobičajenim **shell** **commands** na dnu stranice za dynamic analysis. Neke interesantne komande:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP tools**

When http traffic is capture you can see an ugly view of the captured traffic on "**HTTP(S) Traffic**" bottom or a nicer view in "**Start HTTPTools**" green bottom. From the second option, you can **send** the **captured requests** to **proxies** like Burp or Owasp ZAP.\
To do so, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> press "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Once you finish the dynamic analysis with MobSF you can press on "**Start Web API Fuzzer**" to **fuzz http requests** an look for vulnerabilities.

> [!TIP]
> After performing a dynamic analysis with MobSF the proxy settings me be misconfigured and you won't be able to fix them from the GUI. You can fix the proxy settings by doing:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

You can get the tool from [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
This tool with use some **Hooks** to let you know **what is happening in the application** while you perform a **dynamic analysis**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

This is a **great tool to perform static analysis with a GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

This tool is designed to look for several **security related Android application vulnerabilities**, either in **source code** or **packaged APKs**. The tool is also **capable of creating a "Proof-of-Concept" deployable APK** and **ADB commands**, to exploit some of the found vulnerabilities (Exposed activities, intents, tapjacking...). As with Drozer, there is no need to root the test device.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Prikazuje sve izvađene datoteke radi lakšeg pregleda
- Automatski decompile-uje APK datoteke u Java i Smali format
- Analizira AndroidManifest.xml za česte ranjivosti i ponašanje
- Statička analiza izvornog koda za česte ranjivosti i ponašanje
- Informacije o uređaju
- i još
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER je aplikacija za komandnu liniju koja se može koristiti na Windows, MacOS X i Linux, i analizira _.apk_ fajlove u potrazi za ranjivostima. To radi tako što dekompresuje APK-ove i primenjuje niz pravila kako bi otkrila te ranjivosti.

Sva pravila su centralizovana u fajlu `rules.json`, i svaka kompanija ili tester može kreirati sopstvena pravila za analizu onoga što im je potrebno.

Preuzmite najnovije binarne fajlove sa [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn je **crossplatform** alat koji pomaže developerima, bugbounty hunters i ethical hackers pri izvođenju [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) na mobilnim aplikacijama.

Koncept je da prevučete i otpustite fajl vaše mobilne aplikacije (an .apk or .ipa file) na StaCoAn aplikaciju i on će vam generisati vizuelni i prenosivi izveštaj. Možete podesiti settings i wordlists da biste dobili prilagođeno iskustvo.

Preuzmi[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework je sistem za analizu ranjivosti za Android koji pomaže programerima ili hackers da pronađu potencijalne bezbednosne ranjivosti u Android aplikacijama.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** je alat čija je glavna svrha da detektuje i upozori korisnika na potencijalna maliciozna ponašanja razvijena od strane Android aplikacije.

Detekcija se vrši pomoću **static analysis** Dalvik bytecode-a aplikacije, predstavljenog kao **Smali**, koristeći biblioteku [`androguard`](https://github.com/androguard/androguard).

Ovaj alat traži **uobičajeno ponašanje "loših" aplikacija** kao što su: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. To je alat koji okuplja često korišćene alate za mobile application reverse engineering i analysis, kako bi pomogao pri testiranju mobilnih aplikacija protiv OWASP mobile security pretnji. Njegov cilj je da ovaj zadatak učini lakšim i pristupačnijim developerima mobilnih aplikacija i security profesionalcima.

Može:

- Ekstrahovati Java i Smali code koristeći različite alate
- Analizirati APK-ove koristeći: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Ekstrahovati privatne informacije iz APK-a pomoću regexps.
- Analizirati Manifest.
- Analizirati pronađene domene koristeći: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) i [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Koristan za detekciju malware: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Imajte na umu da, u zavisnosti od servisa i konfiguracije koju koristite za obfuscate the code, secrets mogu ili ne moraju završiti obfuscated.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. On može da optimizuje bytecode kao i da detektuje i ukloni neiskorišćene instrukcije. ProGuard je free software i distribuira se pod GNU General Public License, version 2.

ProGuard se distribuira kao deo Android SDK i pokreće se kada se aplikacija build-uje u release mode.

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Last time we checked, the Dexguard mode of operation was:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

Možete upload-ovati obfuscated APK na njihovu platformu.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

Ovo je LLM alat za pronalaženje potencijalnih security vulnerabilities u android apps i za deobfuscate android app code. Koristi Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

To je **generic android deobfuscator.** Simplify **virtually executes an app** kako bi razumeo njegovo ponašanje i zatim pokušava da **optimizuje code** tako da se ponaša identično, ali bude lakše razumljiv čoveku. Svaka optimizacija je jednostavna i generička, tako da ne zavisi od specifičnog tipa obfuscation-a koji je korišćen.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD vam daje informacije o **how an APK was made**. Identifikuje mnoge **compilers**, **packers**, **obfuscators** i druge čudne stvari. To je [_PEiD_](https://www.aldeid.com/wiki/PEiD) za Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b je Android security virtualna mašina zasnovana na ubuntu-mate, uključuje kolekciju najnovijih framework-ova, tutorijala i labova od različitih security geeka i istraživača za reverse engineering i malware analysis.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) It is a great list of resources
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
