# Pentesting de Aplicaciones Android

{{#include ../../banners/hacktricks-training.md}}

## Conceptos Básicos de Aplicaciones Android

Es altamente recomendable empezar leyendo esta página para conocer las **partes más importantes relacionadas con la seguridad Android y los componentes más peligrosos en una aplicación Android**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Esta es la herramienta principal que necesitas para conectarte a un dispositivo Android (emulado o físico).\
**ADB** permite controlar dispositivos tanto por **USB** como por **Network** desde un ordenador. Esta utilidad habilita la **copia** de archivos en ambos sentidos, la **instalación** y **desinstalación** de apps, la **ejecución** de comandos de shell, la **copia de seguridad** de datos, la **lectura** de logs, entre otras funciones.

Consulta la siguiente lista de [**Comandos ADB**](adb-commands.md) para aprender cómo usar adb.

## Smali

A veces es interesante **modificar el código de la aplicación** para acceder a **información oculta** (quizá contraseñas bien ofuscadas o flags). Entonces, puede ser interesante decompilar el apk, modificar el código y recompilarlo.\
[**En este tutorial** puedes **aprender cómo decompilar un APK, modificar código Smali y recompilar el APK** con la nueva funcionalidad](smali-changes.md). Esto puede ser muy útil como **alternativa para varias pruebas durante el análisis dinámico** que se van a presentar. Por lo tanto, **mantén siempre en mente esta posibilidad**.

## Otros trucos interesantes

- [Falsificar tu ubicación en Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (acceso privilegiado sin root basado en ADB)](shizuku-privileged-api.md)
- [Explotando mecanismos de actualización in-app inseguros](insecure-in-app-update-rce.md)
- [Abusar de Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **Descargar APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Extraer APK del dispositivo:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Fusiona todos los splits y base apks con [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Estudios de caso y vulnerabilidades


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Análisis estático

First of all, for analysing an APK you should **take a look to the to the Java code** using a decompiler.\
Please, [**read here to find information about different available decompilers**](apk-decompilers.md).

### Buscando información interesante

Just taking a look to the **strings** of the APK you can search for **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** and anything interesting... look even for code execution **backdoors** or authentication backdoors (hardcoded admin credentials to the app).

**Firebase**

Pay special attention to **firebase URLs** and check if it is bad configured. [More information about whats is FIrebase and how to exploit it here.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Comprensión básica de la aplicación - Manifest.xml, strings.xml

The **examination of an application's _Manifest.xml_ and **_strings.xml_** files can reveal potential security vulnerabilities**. These files can be accessed using decompilers or by renaming the APK file extension to .zip and then unzipping it.

**Vulnerabilidades** identificadas desde el **Manifest.xml** incluyen:

- **Aplicaciones debuggable**: Applications set as debuggable (`debuggable="true"`) in the _Manifest.xml_ file pose a risk as they allow connections that can lead to exploitation. For further understanding on how to exploit debuggable applications, refer to a tutorial on finding and exploiting debuggable applications on a device.
- **Backup Settings**: The `android:allowBackup="false"` attribute should be explicitly set for applications dealing with sensitive information to prevent unauthorized data backups via adb, especially when usb debugging is enabled.
- **Network Security**: Custom network security configurations (`android:networkSecurityConfig="@xml/network_security_config"`) in _res/xml/_ can specify security details like certificate pins and HTTP traffic settings. An example is allowing HTTP traffic for specific domains.
- **Exported Activities and Services**: Identifying exported activities and services in the manifest can highlight components that might be misused. Further analysis during dynamic testing can reveal how to exploit these components.
- **Content Providers and FileProviders**: Exposed content providers could allow unauthorized access or modification of data. The configuration of FileProviders should also be scrutinized.
- **Broadcast Receivers and URL Schemes**: These components could be leveraged for exploitation, with particular attention to how URL schemes are managed for input vulnerabilities.
- **SDK Versions**: The `minSdkVersion`, `targetSDKVersion`, and `maxSdkVersion` attributes indicate the supported Android versions, highlighting the importance of not supporting outdated, vulnerable Android versions for security reasons.

From the **strings.xml** file, sensitive information such as API keys, custom schemas, and other developer notes can be discovered, underscoring the need for careful review of these resources.

### Tapjacking

**Tapjacking** is an attack where a **malicious** **application** is launched and **positions itself on top of a victim application**. Once it visibly obscures the victim app, its user interface is designed in such a way as to trick the user to interact with it, while it is passing the interaction along to the victim app.\
In effect, it is **blinding the user from knowing they are actually performing actions on the victim app**.

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

An **activity** with the **`launchMode`** set to **`singleTask` without any `taskAffinity`** defined is vulnerable to task Hijacking. This means, that an **application** can be installed and if launched before the real application it could **hijack the task of the real application** (so the user will be interacting with the **malicious application thinking he is using the real one**).

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Almacenamiento de datos inseguro

**Internal Storage**

In Android, files **stored** in **internal** storage are **designed** to be **accessible** exclusively by the **app** that **created** them. This security measure is **enforced** by the Android operating system and is generally adequate for the security needs of most applications. However, developers sometimes utilize modes such as `MODE_WORLD_READABLE` and `MODE_WORLD_WRITABLE` to **allow** files to be **shared** between different applications. Yet, these modes **do not restrict access** to these files by other applications, including potentially malicious ones.

1. **Static Analysis:**
- **Ensure** that the use of `MODE_WORLD_READABLE` and `MODE_WORLD_WRITABLE` is **carefully scrutinized**. These modes **can potentially expose** files to **unintended or unauthorized access**.
2. **Dynamic Analysis:**
- **Verify** the **permissions** set on files created by the app. Specifically, **check** if any files are **set to be readable or writable worldwide**. This can pose a significant security risk, as it would allow **any application** installed on the device, regardless of its origin or intent, to **read or modify** these files.

**External Storage**

When dealing with files on **external storage**, such as SD Cards, certain precautions should be taken:

1. **Accessibility**:
- Files on external storage are **globally readable and writable**. This means any application or user can access these files.
2. **Security Concerns**:
- Given the ease of access, it's advised **not to store sensitive information** on external storage.
- External storage can be removed or accessed by any application, making it less secure.
3. **Handling Data from External Storage**:
- Always **perform input validation** on data retrieved from external storage. This is crucial because the data is from an untrusted source.
- Storing executables or class files on external storage for dynamic loading is strongly discouraged.
- If your application must retrieve executable files from external storage, ensure these files are **signed and cryptographically verified** before they are dynamically loaded. This step is vital for maintaining the security integrity of your application.

External storage can be **accessed** in `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> Starting with Android 4.4 (**API 17**), the SD card has a directory structure which **limits access from an app to the directory which is specifically for that app**. This prevents malicious application from gaining read or write access to another app's files.

**Sensitive data stored in clear-text**

- **Shared preferences**: Android allow to each application to easily save xml files in the path `/data/data/<packagename>/shared_prefs/` and sometimes it's possible to find sensitive information in clear-text in that folder.
- **Databases**: Android allow to each application to easily save sqlite databases in the path `/data/data/<packagename>/databases/` and sometimes it's possible to find sensitive information in clear-text in that folder.

### Broken TLS

**Accept All Certificates**

For some reason sometimes developers accept all the certificates even if for example the hostname does not match with lines of code like the following one:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Una buena forma de probar esto es intentar capturar el tráfico usando algún proxy como Burp sin autorizar Burp CA dentro del dispositivo. También, puedes generar con Burp un certificado para un hostname diferente y usarlo.

### Criptografía rota

**Poor Key Management Processes**

Algunos desarrolladores guardan datos sensibles en el almacenamiento local y los cifran con una clave hardcoded/predictable en el código. Esto no debería hacerse, ya que algo de reversing podría permitir a los atacantes extraer la información confidencial.

**Use of Insecure and/or Deprecated Algorithms**

Los desarrolladores no deberían usar **deprecated algorithms** para realizar authorisation **checks**, **store** o **send** datos. Algunos de estos algoritmos son: RC4, MD4, MD5, SHA1... Si **hashes** se usan para almacenar contraseñas por ejemplo, deberían emplearse hashes resistentes a brute-force con salt.

### Other checks

- It's recommended to **obfuscate the APK** to difficult the reverse engineer labour to attackers.
- If the app is sensitive (like bank apps), it should perform it's **own checks to see if the mobile is rooted** and act in consequence.
- If the app is sensitive (like bank apps), it should check if an **emulator** is being used.
- If the app is sensitive (like bank apps), it should **check it's own integrity before executing** it to check if it was modified.
- Use [**APKiD**](https://github.com/rednaga/APKiD) to check which compiler/packer/obfuscator was used to build the APK

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

The tool [**mariana-trench**](https://github.com/facebook/mariana-trench) is capable of finding **vulnerabilities** by **scanning** the **code** of the application. This tool contains a series of **known sources** (that indicates to the tool the **places** where the **input** is **controlled by the user**), **sinks** (which indicates to the tool **dangerous** **places** where malicious user input could cause damages) and **rules**. These rules indicates the **combination** of **sources-sinks** that indicates a vulnerability.

With this knowledge, **mariana-trench will review the code and find possible vulnerabilities on it**.

### Secrets leaked

An application may contain secrets (API keys, passwords, hidden urls, subdomains...) inside of it that you might be able to discover. You could us a tool such as [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> First of all, you need an environment where you can install the application and all the environment (Burp CA cert, Drozer and Frida mainly). Therefore, a rooted device (emulated or not) is extremely recommended.

### Online Dynamic analysis

You can create a **free account** in: [https://appetize.io/](https://appetize.io). This platform allows you to **upload** and **execute** APKs, so it is useful to see how an apk is behaving.

You can even **see the logs of your application** in the web and connect through **adb**.

![](<../../images/image (831).png>)

Thanks to the ADB connection you can use **Drozer** and **Frida** inside the emulators.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (You can create **x86** and **arm** devices, and according to [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** versions **support ARM libraries** without needing an slow arm emulator).
- Learn to set it up in this page:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, you need to create an account. _It's recommend to **download** the version **WITH**_ _**VirtualBox** to avoid potential errors._)
- [**Nox**](https://es.bignox.com) (Free, but it doesn't support Frida or Drozer).

> [!TIP]
> When creating a new emulator on any platform remember that the bigger the screen is, the slower the emulator will run. So select small screens if possible.

To **install google services** (like AppStore) in Genymotion you need to click on the red marked button of the following image:

![](<../../images/image (277).png>)

Also, notice that in the **configuration of the Android VM in Genymotion** you can select **Bridge Network mode** (this will be useful if you will be connecting to the Android VM from a different VM with the tools).

#### Use a physical device

You need to activate the **debugging** options and it will be cool if you can **root** it:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Once you have installed the application, the first thing you should do is to try it and investigate what does it do, how does it work and get comfortable with it.\
> I will suggest to **perform this initial dynamic analysis using MobSF dynamic analysis + pidcat**, so we will be able to **learn how the application works** while MobSF **captures** a lot of **interesting** **data** you can review later on.

### Unintended Data Leakage

**Logging**

Developers should be cautious of exposing **debugging information** publicly, as it can lead to sensitive data leaks. The tools [**pidcat**](https://github.com/JakeWharton/pidcat) and `adb logcat` are recommended for monitoring application logs to identify and protect sensitive information. **Pidcat** is favored for its ease of use and readability.

> [!WARNING]
> Note that from **later newer than Android 4.0**, **applications are only able to access their own logs**. So applications cannot access other apps logs.\
> Anyway, it's still recommended to **not log sensitive information**.

**Copy/Paste Buffer Caching**

Android's **clipboard-based** framework enables copy-paste functionality in apps, yet poses a risk as **other applications** can **access** the clipboard, potentially exposing sensitive data. It's crucial to **disable copy/paste** functions for sensitive sections of an application, like credit card details, to prevent data leaks.

**Crash Logs**

If an application **crashes** and **saves logs**, these logs can assist attackers, particularly when the application cannot be reverse-engineered. To mitigate this risk, avoid logging on crashes, and if logs must be transmitted over the network, ensure they are sent via an SSL channel for security.

As pentester, **try to take a look to these logs**.

**Analytics Data Sent To 3rd Parties**

Applications often integrate services like Google Adsense, which can inadvertently **leak sensitive data** due to improper implementation by developers. To identify potential data leaks, it's advisable to **intercept the application's traffic** and check for any sensitive information being sent to third-party services.

### SQLite DBs

Most of the applications will use **internal SQLite databases** to save information. During the pentest take a **look** to the **databases** created, the names of **tables** and **columns** and all the **data** saved because you could find **sensitive information** (which would be a vulnerability).\
Databases should be located in `/data/data/the.package.name/databases` like `/data/data/com.mwr.example.sieve/databases`

If the database is saving confidential information and is **encrypted b**ut you can **find** the **password** inside the application it's still a **vulnerability**.

Enumerate the tables using `.tables` and enumerate the columns of the tables doing `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer is s useful tool to **exploit exported activities, exported services and Content Providers** as you will learn in the following sections.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Also remember that the code of an activity starts in the **`onCreate`** method.

**Authorisation bypass**

When an Activity is exported you can invoke its screen from an external app. Therefore, if an activity with **sensitive information** is **exported** you could **bypass** the **authentication** mechanisms **to access it.**

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

You can also start an exported activity from adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTA**: MobSF detectará como malicioso el uso de _**singleTask/singleInstance**_ como `android:launchMode` en una actividad, pero debido a [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), aparentemente esto solo es peligroso en versiones antiguas (API versions < 21).

> [!TIP]
> Ten en cuenta que an authorisation bypass no siempre es una vulnerabilidad; dependerá de cómo funcione el bypass y qué información se exponga.

**Filtración de información sensible**

**Las actividades también pueden devolver resultados**. Si logras encontrar una actividad exportada y sin protección que invoque el método **`setResult`** y **devuelva información sensible**, existe una filtración de información sensible.

#### Tapjacking

Si no se previene el tapjacking, podrías abusar de la actividad exportada para hacer que el **usuario realice acciones inesperadas**. Para más información sobre [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Los content providers se usan básicamente para **compartir datos**. Si una app tiene content providers disponibles, podrías **extraer datos sensibles** de ellos. También es interesante probar posibles **SQL injections** y **Path Traversals**, ya que podrían ser vulnerables.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Recuerda que las acciones de un Service comienzan en el método `onStartCommand`.

Un service es básicamente algo que **puede recibir datos**, **procesarlos** y **devolver** (o no) una respuesta. Entonces, si una aplicación está exportando algunos servicios deberías **revisar** el **código** para entender qué hace y **probarlo** **dinámicamente** para extraer información confidencial, bypassing authentication measures...\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Recuerda que las acciones de un Broadcast Receiver comienzan en el método `onReceive`.

Un broadcast receiver esperará un tipo de mensaje. Dependiendo de cómo el receiver maneje el mensaje, podría ser vulnerable.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Puedes buscar deep links manualmente, usando herramientas como MobSF o scripts como [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Puedes **abrir** un **scheme** declarado usando **adb** o un **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Ten en cuenta que puedes **omitir el nombre del paquete** y el dispositivo móvil llamará automáticamente a la app que debería abrir ese enlace._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Código ejecutado**

Para encontrar el **código que se ejecutará en la App**, ve a la actividad llamada por el deeplink y busca la función **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Información sensible**

Cada vez que encuentres un deep link verifica que **no reciba datos sensibles (como contraseñas) vía parámetros URL**, porque cualquier otra aplicación podría **suplantar el deep link y robar esos datos!**

**Parámetros en la ruta**

También **debes comprobar si algún deep link está usando un parámetro dentro de la ruta** de la URL como: `https://api.example.com/v1/users/{username}` , en ese caso puedes forzar un path traversal accediendo a algo como: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Ten en cuenta que si encuentras los endpoints correctos dentro de la aplicación podrías provocar un **Open Redirect** (si parte de la ruta se usa como nombre de dominio), **account takeover** (si puedes modificar detalles de usuarios sin token CSRF y el vuln endpoint usa el método correcto) y cualquier otra vuln. Más [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**Más ejemplos**

Un [interesante informe de bug bounty](https://hackerone.com/reports/855618) sobre links (_/.well-known/assetlinks.json_).

### Inspección de la capa de transporte y fallos de verificación

- **Los certificados no siempre se inspeccionan correctamente** en las aplicaciones Android. Es común que estas aplicaciones pasen por alto advertencias y acepten certificados autofirmados o, en algunos casos, vuelvan a usar conexiones HTTP.
- **Las negociaciones durante el handshake SSL/TLS a veces son débiles**, empleando suites de cifrado inseguras. Esta vulnerabilidad hace la conexión susceptible a ataques man-in-the-middle (MITM), permitiendo a los atacantes descifrar los datos.
- **Divulgación de información privada** es un riesgo cuando las aplicaciones se autentican usando canales seguros pero luego comunican por canales no seguros para otras transacciones. Este enfoque no protege datos sensibles, como cookies de sesión o detalles de usuario, de la intercepción por actores maliciosos.

#### Verificación de certificados

Nos centraremos en la **verificación de certificados**. La integridad del certificado del servidor debe verificarse para mejorar la seguridad. Esto es crucial porque las configuraciones TLS inseguras y la transmisión de datos sensibles por canales no cifrados pueden suponer riesgos significativos. Para pasos detallados sobre cómo verificar certificados de servidor y corregir vulnerabilidades, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) ofrece una guía completa.

#### SSL Pinning

SSL Pinning es una medida de seguridad donde la aplicación verifica el certificado del servidor contra una copia conocida almacenada dentro de la propia aplicación. Este método es esencial para prevenir ataques MITM. Se recomienda encarecidamente implementar SSL Pinning en aplicaciones que manejen información sensible.

#### Inspección de Tráfico

Para inspeccionar tráfico HTTP, es necesario **instalar el certificado de la herramienta proxy** (p.ej., Burp). Sin instalar este certificado, el tráfico cifrado podría no ser visible a través del proxy. Para una guía sobre cómo instalar un certificado CA personalizado, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Las aplicaciones dirigidas a **API Level 24 and above** requieren modificaciones en la Network Security Config para aceptar el certificado CA del proxy. Este paso es crítico para inspeccionar tráfico cifrado. Para instrucciones sobre cómo modificar la Network Security Config, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

Si se está usando **Flutter**, debes seguir las instrucciones en [**this page**](flutter.md). Esto se debe a que, simplemente añadir el certificado al almacén no funcionará ya que Flutter tiene su propia lista de CAs válidas.

#### Detección estática de SSL/TLS pinning

Antes de intentar bypasses en tiempo de ejecución, mapea rápidamente dónde se aplica el pinning en el APK. El descubrimiento estático te ayuda a planificar hooks/patches y enfocarte en las rutas de código correctas.

Herramienta: SSLPinDetect
- Utilidad de análisis estático de código abierto que decompila el APK a Smali (via apktool) y escanea patrones regex curados de implementaciones de SSL/TLS pinning.
- Reporta la ruta de archivo exacta, número de línea y un snippet de código para cada coincidencia.
- Cubre frameworks comunes y rutas de código personalizadas: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init con custom TrustManagers/KeyManagers, y Network Security Config XML pins.

Install
- Prerrequisitos: Python >= 3.8, Java en PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Uso
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Ejemplo de reglas de patrones (JSON)
Usa o amplía signatures para detectar estilos propietarios/personalizados de pinning. Puedes cargar tu propio JSON y escanear a gran escala.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notas y consejos
- Escaneo rápido de aplicaciones grandes mediante multi-threading y memory-mapped I/O; el uso de regex precompiladas reduce la sobrecarga/falsos positivos.
- Colección de patrones: https://github.com/aancw/smali-sslpin-patterns
- Objetivos típicos de detección para priorizar a continuación:
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Pins declarativos en res/xml network security config y referencias en el manifest
- Usa las ubicaciones coincidentes para planear Frida hooks, parches estáticos o revisiones de configuración antes de pruebas dinámicas.



#### Eludir SSL Pinning

Cuando SSL Pinning está implementado, es necesario eludirlo para inspeccionar el tráfico HTTPS. Existen varios métodos para ello:

- Modificar automáticamente el **apk** para **eludir** SSLPinning con [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). La mayor ventaja de esta opción es que no necesitarás root para eludir SSL Pinning, pero tendrás que eliminar la aplicación e instalar la nueva, y esto no siempre funciona.
- Puedes usar **Frida** (discutida más abajo) para eludir esta protección. Aquí tienes una guía para usar Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- También puedes intentar **eludir automáticamente SSL Pinning** usando [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- También puedes intentar **eludir automáticamente SSL Pinning** usando **MobSF dynamic analysis** (explicado más abajo)
- Si aún crees que hay tráfico que no estás capturando, puedes intentar **redirigir el tráfico a burp usando iptables**. Lee este blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Buscar vulnerabilidades web comunes

También es importante buscar vulnerabilidades web comunes dentro de la aplicación. La información detallada sobre cómo identificarlas y mitigarlas excede el alcance de este resumen, pero está ampliamente cubierta en otros lugares.

### Frida

[Frida](https://www.frida.re) es un toolkit de instrumentación dinámica para desarrolladores, ingenieros inversos e investigadores de seguridad.\
**Puedes acceder a la aplicación en ejecución e interceptar métodos en tiempo de ejecución para cambiar el comportamiento, modificar valores, extraer valores, ejecutar código diferente...**\
Si quieres realizar pentesting de aplicaciones Android necesitas saber cómo usar Frida.

- Aprende a usar Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Algunas "GUI" para acciones con Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection es ideal para automatizar el uso de Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Puedes encontrar algunos Awesome Frida scripts aquí: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Intenta evadir mecanismos anti-debugging / anti-frida cargando Frida como se indica en [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (herramienta [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Volcar memoria - Fridump**

Comprueba si la aplicación está almacenando información sensible en la memoria que no debería guardar, como contraseñas o frases mnemónicas.

Usando [**Fridump3**](https://github.com/rootbsd/fridump3) puedes volcar la memoria de la app con:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Esto volcará la memoria en la carpeta ./dump, y allí podrías usar grep con algo como:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Datos sensibles en Keystore**

En Android, el Keystore es el mejor lugar para almacenar datos sensibles; sin embargo, con suficientes privilegios sigue siendo **posible acceder a él**. Como las aplicaciones tienden a almacenar aquí **datos sensibles en clear text**, los pentests deberían comprobarlo como root user o alguien con acceso físico al dispositivo podría robar estos datos.

Incluso si una app almacena datos en el Keystore, los datos deberían estar cifrados.

Para acceder a los datos dentro del Keystore puedes usar este Frida script: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Usando el siguiente script de Frida podría ser posible **bypass fingerprint authentication** que realizan las aplicaciones Android para **proteger ciertas áreas sensibles:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Imágenes de fondo**

Cuando pones una aplicación en segundo plano, Android guarda una **instantánea de la aplicación** para que, al recuperarla al primer plano, empiece cargando la imagen antes que la app y parezca que la aplicación se cargó más rápido.

Sin embargo, si esta instantánea contiene **información sensible**, alguien con acceso a la instantánea podría **robar esa información** (nota: necesitas root para acceder a ella).

Las instantáneas suelen almacenarse en: **`/data/system_ce/0/snapshots`**

Android proporciona una forma de **evitar la captura de pantalla configurando el parámetro de layout FLAG_SECURE**. Al usar este flag, el contenido de la ventana se trata como seguro, impidiendo que aparezca en capturas de pantalla o que se muestre en displays no seguros.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Esta herramienta puede ayudarte a gestionar diferentes herramientas durante el análisis dinámico: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Los desarrolladores suelen crear proxy components como activities, services y broadcast receivers que manejan estos Intents y los pasan a métodos como `startActivity(...)` o `sendBroadcast(...)`, lo cual puede ser riesgoso.

El peligro radica en permitir a los atacantes activar componentes de la app non-exported o acceder a content providers sensibles redirigiendo indebidamente estos Intents. Un ejemplo notable es el componente `WebView` convirtiendo URLs a objetos `Intent` mediante `Intent.parseUri(...)` y luego ejecutándolos, lo que puede conducir a malicious Intent injections.

### Puntos esenciales

- **Intent Injection** es similar al Open Redirect en la web.
- Los exploits implican pasar objetos `Intent` como extras, que pueden ser redirigidos para ejecutar operaciones inseguras.
- Puede exponer componentes non-exported y content providers a atacantes.
- La conversión de URLs a `Intent` por parte de `WebView` puede facilitar acciones no deseadas.

### Inyecciones del lado del cliente en Android y otros

Probablemente conozcas este tipo de vulnerabilidades desde la Web. Debes tener especial cuidado con estas vulnerabilidades en una aplicación Android:

- **SQL Injection:** Cuando trates con consultas dinámicas o Content-Providers, asegúrate de usar consultas parametrizadas.
- **JavaScript Injection (XSS):** Verifica que el soporte de JavaScript y Plugins esté deshabilitado para cualquier WebView (deshabilitado por defecto). [Más información aquí](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** Las WebViews deberían tener el acceso al sistema de archivos deshabilitado (habilitado por defecto) - `(webview.getSettings().setAllowFileAccess(false);)`. [Más información aquí](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: En varios casos, cuando la aplicación Android finaliza la sesión, la cookie no se revoca o incluso puede ser guardada en disco
- [**Secure Flag** en cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Análisis automático

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Análisis estático**

![](<../../images/image (866).png>)

**Evaluación de vulnerabilidades de la aplicación** usando una interfaz web agradable. También puedes realizar análisis dinámico (pero necesitas preparar el entorno).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Assisted Dynamic analysis with MobSF

**MobSF** can also be very helpful for **dynamic analysis** in **Android**, but in that case you will need to install MobSF and **genymotion** in your host (a VM or Docker won't work). _Note: You need to **start first a VM in genymotion** and **then MobSF.**._\
The **MobSF dynamic analyser** can:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). All of this is done automatically except for the screenshots, you need to press when you want a screenshot or you need to press "**Exported Activity Tester**" to obtain screenshots of all the exported activities.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: Imprimirá todas las clases cargadas
- **Capture Strings**: Imprimirá todas las cadenas capturadas mientras usas la aplicación (muy ruidoso)
- **Capture String Comparisons**: Puede ser muy útil. Mostrará las 2 cadenas que se están comparando y si el resultado fue True o False.
- **Enumerate Class Methods**: Introduce el nombre de la clase (como "java.io.File") y listará todos los métodos de la clase.
- **Search Class Pattern**: Busca clases por patrón
- **Trace Class Methods**: Traza una clase completa (ver entradas y salidas de todos los métodos de la clase). Recuerda que por defecto MobSF traza varios métodos interesantes de la API de Android.

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf also brings you a shell with some **adb** commands, **MobSF commands**, and common **shell** **commands** at the bottom of the dynamic analysis page. Some interesting commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**Herramientas HTTP**

Cuando se captura tráfico HTTP puedes ver una vista tosca del tráfico capturado en el botón "**HTTP(S) Traffic**" o una vista más agradable en el botón verde "**Start HTTPTools**". Desde la segunda opción, puedes **enviar** las **solicitudes capturadas** a **proxies** como Burp u Owasp ZAP.\
Para ello, _enciende Burp -->_ _desactiva Intercept --> en MobSF HTTPTools selecciona la solicitud_ --> pulsa "**Send to Fuzzer**" --> _selecciona la dirección del proxy_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Una vez termines el análisis dinámico con MobSF puedes pulsar "**Start Web API Fuzzer**" para **fuzzear solicitudes HTTP** y buscar vulnerabilidades.

> [!TIP]
> Después de realizar un análisis dinámico con MobSF la configuración del proxy puede quedar mal configurada y no podrás arreglarla desde la GUI. Puedes corregir la configuración del proxy ejecutando:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Análisis dinámico asistido con Inspeckage

Puedes obtener la herramienta en [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Esta herramienta usa algunos **Hooks** para mostrarte **qué está ocurriendo en la aplicación** mientras llevas a cabo un **análisis dinámico**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Esta es una **excelente herramienta para realizar análisis estático con una GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Esta herramienta está diseñada para buscar varias vulnerabilidades relacionadas con la seguridad en aplicaciones Android, ya sea en el **source code** o en **packaged APKs**. La herramienta también es capaz de crear un APK desplegable tipo **"Proof-of-Concept"** y generar **ADB commands** para explotar algunas de las vulnerabilidades encontradas (Exposed activities, intents, tapjacking...). Al igual que con Drozer, no es necesario rootear el dispositivo de prueba.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Muestra todos los archivos extraídos para referencia rápida
- Decompila automáticamente archivos APK a formato Java y Smali
- Analiza AndroidManifest.xml en busca de vulnerabilidades y comportamientos comunes
- Análisis estático del código fuente en busca de vulnerabilidades y comportamientos comunes
- Información del dispositivo
- y más
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER es una aplicación de línea de comandos que puede usarse en Windows, MacOS X y Linux, que analiza archivos _.apk_ en busca de vulnerabilidades. Hace esto descomprimiendo APKs y aplicando una serie de reglas para detectar esas vulnerabilidades.

Todas las reglas se centralizan en un archivo `rules.json`, y cada empresa o tester puede crear sus propias reglas para analizar lo que necesiten.

Descarga los binarios más recientes desde la [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn es una herramienta **crossplatform** que ayuda a desarrolladores, bugbounty hunters y ethical hackers a realizar [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) en aplicaciones móviles.

El concepto es que arrastres y sueltes el archivo de tu aplicación móvil (un archivo .apk o .ipa) en la aplicación StaCoAn y esta generará un informe visual y portable para ti. Puedes ajustar la configuración y las wordlists para obtener una experiencia personalizada.

Download[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework es un sistema de análisis de vulnerabilidades para Android que ayuda a desarrolladores o hackers a encontrar posibles vulnerabilidades de seguridad en aplicaciones Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** es una herramienta cuyo objetivo principal es detectar y advertir al usuario sobre posibles comportamientos maliciosos desarrollados por una aplicación Android.

La detección se realiza mediante el **static analysis** del Dalvik bytecode de la aplicación, representado como **Smali**, con la librería [`androguard`](https://github.com/androguard/androguard).

Esta herramienta busca **comportamientos comunes de aplicaciones "malas"** como: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** es un Framework de Ingeniería Inversa y Análisis de Aplicaciones Móviles. Es una herramienta que agrupa herramientas comúnmente usadas para la ingeniería inversa y el análisis de aplicaciones móviles, para ayudar en las pruebas de aplicaciones móviles frente a las amenazas de seguridad móviles de OWASP. Su objetivo es hacer esta tarea más fácil y amigable para desarrolladores de aplicaciones móviles y profesionales de seguridad.

Es capaz de:

- Extraer código Java y Smali usando diferentes herramientas
- Analizar APKs usando: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Extraer información privada del APK usando regexps.
- Analizar el Manifest.
- Analizar los dominios encontrados usando: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) y [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Desofuscar APK vía [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Útil para detectar malware: [https://koodous.com/](https://koodous.com)

## Obfuscating/Deobfuscating code

Tenga en cuenta que, dependiendo del servicio y la configuración que use para ofuscar el código, los secretos pueden o no terminar ofuscados.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** es una herramienta de línea de comandos de código abierto que reduce, optimiza y ofusca código Java. Es capaz de optimizar bytecode así como detectar y eliminar instrucciones no utilizadas. ProGuard es software libre y se distribuye bajo la GNU General Public License, versión 2.

ProGuard se distribuye como parte del Android SDK y se ejecuta al compilar la aplicación en modo release.

### [DexGuard](https://www.guardsquare.com/dexguard)

Encuentra una guía paso a paso para desofuscar el apk en [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(Según esa guía) La última vez que comprobamos, el modo de operación de Dexguard era:

- cargar un recurso como un InputStream;
- pasar el resultado a una clase que hereda de FilterInputStream para descifrarlo;
- hacer alguna ofuscación inútil para hacer perder unos minutos a un analista de ingeniería inversa;
- pasar el resultado descifrado a un ZipInputStream para obtener un archivo DEX;
- finalmente cargar el DEX resultante como un Resource usando el método `loadDex`.

### [DeGuard](http://apk-deguard.com)

**DeGuard invierte el proceso de ofuscación realizado por las herramientas de ofuscación de Android. Esto permite numerosos análisis de seguridad, incluyendo la inspección de código y la identificación de librerías.**

Puedes subir un APK ofuscado a su plataforma.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

Es un deofuscador genérico para android. Simplify ejecuta virtualmente una app para entender su comportamiento y luego intenta optimizar el código para que se comporte de forma idéntica pero sea más fácil de entender para un humano. Cada tipo de optimización es simple y genérica, por lo que no importa qué tipo específico de ofuscación se haya usado.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD te da información sobre cómo se hizo un APK. Identifica muchos compiladores, packers, ofuscadores y otras cosas raras. Es el [_PEiD_](https://www.aldeid.com/wiki/PEiD) para Android.

### Manual

[Lee este tutorial para aprender algunos trucos sobre cómo revertir ofuscaciones personalizadas](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b es una máquina virtual de seguridad Android basada en ubuntu-mate que incluye la colección de los últimos frameworks, tutoriales y labs de diferentes entusiastas e investigadores de seguridad para reverse engineering y análisis de malware.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Es una gran lista de recursos
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)

## Yet to try

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
