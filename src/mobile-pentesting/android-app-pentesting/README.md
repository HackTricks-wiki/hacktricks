# Android 应用 Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android 应用基础

强烈建议先阅读此页面以了解与 Android 安全 相关的**最重要部分以及 Android 应用中最危险的组件**：


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

这是连接 Android 设备（模拟或物理）所需的主要工具。\
**ADB** 允许从计算机通过 **USB** 或 **Network** 控制设备。该工具支持在两个方向上**复制**文件、**安装**和**卸载**应用、**执行** shell 命令、**备份**数据、**读取**日志等功能。

查看下面的 [**ADB Commands**](adb-commands.md) 列表以学习如何使用 adb。

## Smali

有时通过**修改应用代码**来访问**隐藏信息**（例如高度混淆的密码或 flag）是很有趣的。此时，反编译 apk、修改代码并重新编译可能会很有用。\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). 这在将要进行的**动态分析**期间，作为若干测试的替代方法可能非常有用。因此，请**始终记住这一可能性**。

## 其他有趣的技巧

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **下载 APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- 从设备提取 APK:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- 使用 [APKEditor](https://github.com/REAndroid/APKEditor) 合并所有 splits 和 base apks:
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## 案例研究 & 漏洞


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## 静态分析

首先，对于分析 APK，你应该使用反编译器**查看 Java 代码**。\
请，[**在此处阅读以了解可用的不同反编译器信息**](apk-decompilers.md)。

### 查找重要信息

仅查看 APK 的 **strings** 就能搜索 **passwords**、**URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep))、**api** keys、**encryption**、**bluetooth uuids**、**tokens** 以及其他有价值的内容……甚至查找代码执行 **backdoors** 或身份验证 backdoors（应用的硬编码管理员凭据）。

**Firebase**

特别注意 **Firebase URLs** 并检查其配置是否不当。[这里有关于什么是 Firebase 以及如何利用它的更多信息。](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### 对应用的基本理解 - Manifest.xml, strings.xml

**检查应用的 _Manifest.xml_ 和 _strings.xml_ 文件可以揭示潜在的安全漏洞**。这些文件可以使用反编译器访问，或将 APK 扩展名重命名为 .zip 然后解压。

**从 Manifest.xml 中识别出的漏洞包括：**

- **Debuggable Applications**：在 _Manifest.xml_ 文件中被设置为 debuggable (`debuggable="true"`) 的应用存在风险，因为它们允许连接，可能导致被利用。关于如何在设备上查找并利用 debuggable 应用的更多信息，请参考相关教程。
- **Backup Settings**：对于处理敏感信息的应用，应显式设置 `android:allowBackup="false"` 属性，以防止通过 adb 在 usb debugging 启用时进行未授权的数据备份。
- **Network Security**：位于 _res/xml/_ 的自定义网络安全配置（`android:networkSecurityConfig="@xml/network_security_config"`）可以指定证书 pin、HTTP 流量设置等安全细节。例如为特定域名允许 HTTP 流量。
- **Exported Activities and Services**：在 manifest 中识别被导出的 activities 和 services 可以突出可能被滥用的组件。在动态测试期间的进一步分析可以揭示如何利用这些组件。
- **Content Providers and FileProviders**：暴露的 content providers 可能允许未授权访问或修改数据。FileProviders 的配置也应被仔细检查。
- **Broadcast Receivers and URL Schemes**：这些组件可能被利用进行攻击，尤其要注意 URL schemes 如何处理输入以防止注入类漏洞。
- **SDK Versions**：`minSdkVersion`、`targetSDKVersion` 和 `maxSdkVersion` 属性表明支持的 Android 版本，强调不要支持过时且易受攻击的 Android 版本以保证安全性。

从 **strings.xml** 文件中，可以发现敏感信息，例如 API keys、自定义 schemas 以及其他开发者注释，这凸显了对这些资源进行仔细审查的必要性。

### Tapjacking

**Tapjacking** 是一种攻击，恶意应用被启动并将自己放在受害应用之上。一旦它在视觉上遮挡了受害应用，其用户界面会被设计为欺骗用户与之交互，同时将该交互传递给受害应用。\
实际上，它使用户看不到自己实际上正在对受害应用执行操作。

更多信息见：


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

如果一个 **activity** 的 **`launchMode`** 被设置为 **`singleTask` 且未定义任何 `taskAffinity`**，则该 activity 易受 Task Hijacking 攻击。这意味着，如果在真实应用之前安装并启动了一个应用，它可能会 **劫持真实应用的 task**（用户会与恶意应用交互，却以为自己在使用真实的应用）。

更多信息见：


{{#ref}}
android-task-hijacking.md
{{#endref}}

### 不安全的数据存储

**内部存储**

在 Android 中，存储在 **内部** 存储中的文件设计为只能被**创建它们的应用**访问。该安全措施由 Android 操作系统强制执行，通常足以满足大多数应用的安全需求。但开发者有时会使用诸如 `MODE_WORLD_READABLE` 和 `MODE_WORLD_WRITABLE` 的模式来允许不同应用之间共享文件。然而，这些模式不会限制其他应用（包括潜在的恶意应用）访问这些文件。

1. **Static Analysis:**
- **确保** 仔细审查 `MODE_WORLD_READABLE` 和 `MODE_WORLD_WRITABLE` 的使用。这些模式**可能会暴露**文件，导致**非预期或未授权的访问**。
2. **Dynamic Analysis:**
- **验证** 应用所创建文件的**权限**。特别是，**检查**是否有文件被设置为对所有用户可读或可写。这将构成严重的安全风险，因为它允许**任何安装在设备上的应用**读取或修改这些文件，无论其来源或意图如何。

**外部存储**

在处理外部存储（例如 SD 卡）上的文件时，应采取以下预防措施：

1. **可访问性**：
- 外部存储上的文件是**全局可读可写**的。这意味着任何应用或用户都可以访问这些文件。
2. **安全考虑**：
- 鉴于易于访问，建议**不要在外部存储中存放敏感信息**。
- 外部存储可以被移除或被任何应用访问，因此安全性较低。
3. **处理来自外部存储的数据**：
- 对从外部存储检索的数据始终**执行输入验证**。这是至关重要的，因为这些数据来自不受信任的来源。
- 强烈不建议将可执行文件或 class 文件存放在外部存储以供动态加载。
- 如果应用必须从外部存储检索可执行文件，确保这些文件在动态加载前**已签名并经过加密验证**。这一步对于维护应用的安全完整性至关重要。

外部存储可以在 /storage/emulated/0、/sdcard、/mnt/sdcard 访问

> [!TIP]
> 从 Android 4.4 (**API 17**) 开始，SD 卡有一个目录结构，限制应用只能访问专属于该应用的目录。这可以防止恶意应用获得对其他应用文件的读或写访问。

**以明文存储的敏感数据**

- **Shared preferences**：Android 允许每个应用将 xml 文件轻松保存到路径 `/data/data/<packagename>/shared_prefs/`，有时可以在该文件夹中以明文找到敏感信息。
- **Databases**：Android 允许每个应用将 sqlite 数据库轻松保存到路径 `/data/data/<packagename>/databases/`，有时可以在该文件夹中以明文找到敏感信息。

### Broken TLS

**Accept All Certificates**

出于某些原因，开发者有时会接受所有证书，即使例如 hostname 不匹配，代码可能类似如下：
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### 加密缺陷

**密钥管理不当**

一些开发者将敏感数据保存在本地存储并使用硬编码/可预测的密钥加密。这不应该这样做，因为逆向工程可能让攻击者提取机密信息。

**使用不安全或/和已弃用的算法**

开发者不应使用 **已弃用的算法** 来执行授权 **检查**、**存储** 或 **发送** 数据。其中一些算法包括：RC4, MD4, MD5, SHA1... 如果使用 **哈希** 来存储密码，例如，应使用抗暴力破解的哈希并加盐。

### 其他检查

- 建议**混淆 APK**，以增加逆向工程的难度，阻碍攻击者。
- 如果应用敏感（例如银行应用），应执行其**自身检查以确定设备是否已 root**并据此采取措施。
- 如果应用敏感（例如银行应用），应检测是否在使用 **emulator**。
- 如果应用敏感（例如银行应用），应该在执行前**检查自身完整性**以验证是否被篡改。
- 使用 [**APKiD**](https://github.com/rednaga/APKiD) 来检查构建 APK 时使用了哪个编译器/打包器/混淆器

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### 自动化静态代码分析

工具 [**mariana-trench**](https://github.com/facebook/mariana-trench) 能够通过**扫描**应用的**代码**来发现**漏洞**。该工具包含一系列的 **known sources**（指示工具哪些位置的输入由用户控制）、**sinks**（指示工具哪些危险位置，恶意用户输入可能造成损害）和 **rules**。这些规则指定了表明漏洞的 **sources-sinks** 组合。

借助这些信息，**mariana-trench 将审查代码并发现可能的漏洞**。

### Secrets leaked

An application may contain secrets (API keys, passwords, hidden urls, subdomains...) inside of it that you might be able to discover. You could us a tool such as [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### 其他有趣的功能

- **代码执行**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **发送 SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native 函数** 声明为 `native`: `public native, System.loadLibrary, System.load`
- [阅读此文以了解 **如何逆向 native 函数**](reversing-native-libraries.md)
- 通过 JNI 在内存中执行 native 代码（下载 shellcode → mmap/mprotect → 调用）：

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **其他技巧**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## 动态分析

> 首先，你需要一个可以安装应用及其全部环境（主要是 Burp CA 证书、Drozer 和 Frida）的环境。因此，极其推荐使用已 root 的设备（模拟或真实）。

### 在线动态分析

你可以在: [https://appetize.io/](https://appetize.io/) 创建一个**免费账户**。该平台允许你**上传**并**执行** APK，因此有助于观察 apk 的运行行为。

你甚至可以在网页中**查看应用日志**并通过 **adb** 连接。

![](<../../images/image (831).png>)

借助 ADB 连接，你可以在模拟器内使用 **Drozer** 和 **Frida**。

### 本地动态分析

#### 使用模拟器

- [**Android Studio**](https://developer.android.com/studio)（你可以创建 **x86** 和 **arm** 设备，根据 [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**较新的 x86** 版本 **支持 ARM 库**，无需使用缓慢的 arm 模拟器）。
- Learn to set it up in this page:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **（免费版：** Personal Edition，需要创建一个账号。_建议**下载**包含 **VirtualBox** 的版本以避免潜在错误._)
- [**Nox**](https://es.bignox.com)（免费，但不支持 Frida 或 Drozer）。

> [!TIP]
> 当在任何平台上创建新 emulator 时，请记住屏幕越大，模拟器运行越慢。因此尽量选择小屏幕。

要在 Genymotion 中**安装 google services**（例如 AppStore），你需要点击下图中红色标记的按钮：

![](<../../images/image (277).png>)

另外，请注意在 Genymotion 的 **Android VM 配置** 中可以选择 **Bridge Network mode**（如果你要从另一个配有工具的 VM 连接到该 Android VM，这会很有用）。

#### 使用实体设备

你需要启用 **调试** 选项，如果能将设备 **root** 会更好：

1. **设置**。
2. （在 Android 8.0 及以上）选择 **系统**。
3. 选择 **关于手机**。
4. 连续按 **Build number** 7 次。
5. 返回，你会看到 **开发者选项**。

> 一旦安装好应用，首先应该尝试使用并研究它的功能、工作方式并熟悉它。\
> 我建议使用 MobSF 动态分析 + pidcat 来执行这一步初始动态分析，这样我们可以在 MobSF **捕获**大量**有趣**的**数据**供日后查看的同时，**学习应用如何工作**。

Magisk/Zygisk 简要说明（推荐在 Pixel 设备上）
- 使用 Magisk 应用 patch boot.img 并通过 fastboot 刷入以获得 systemless root
- 启用 Zygisk + DenyList 以隐藏 root；在需更强隐藏时可考虑 LSPosed/Shamiko
- 保留原始 boot.img 以便从 OTA 恢复；每次 OTA 后需重新 patch
- 若需屏幕镜像，在主机上使用 scrcpy

### Unintended Data Leakage

**日志记录**

开发者应谨慎避免公开**调试信息**，因为这可能导致敏感数据 leaks。建议使用工具 [**pidcat**](https://github.com/JakeWharton/pidcat) 和 `adb logcat` 来监视应用日志，以发现并保护敏感信息。**Pidcat** 因其易用性和可读性而更受欢迎。

> [!WARNING]
> 注意，从 **Android 4.0 之后的版本** 起，**应用只能访问自身的日志**。因此应用无法访问其他应用的日志。\
> 无论如何，仍建议**不要记录敏感信息**。

**复制/粘贴 剪贴板缓存**

Android 的 **基于剪贴板** 的框架在应用中实现了复制粘贴功能，但存在风险，因为**其他应用**可以**访问**剪贴板，可能暴露敏感数据。对应用中敏感部分（例如信用卡信息）务必**禁用复制/粘贴**功能，以防止数据 leaks。

**崩溃日志**

如果应用在**崩溃**时**保存日志**，这些日志可能会帮助攻击者，尤其是在应用无法被逆向的情况下。为降低风险，避免在崩溃时记录日志；如果必须通过网络传输日志，应确保通过 SSL 通道发送以保证安全。

作为 pentester，**尝试查看这些日志**。

**发送给第三方的 Analytics 数据**

应用通常集成像 Google Adsense 这样的服务，由于开发者实现不当，可能会无意间 leak 敏感数据。要识别潜在的数据 leaks，建议**拦截应用的流量**并检查是否有敏感信息被发送到第三方服务。

### SQLite 数据库

大多数应用会使用**内部 SQLite 数据库**来保存信息。在 pentest 期间，请查看创建的**数据库**、**表**和**列**的名称以及保存的所有**数据**，因为你可能会发现**敏感信息**（这将构成漏洞）。\
数据库通常位于 `/data/data/the.package.name/databases`，例如 `/data/data/com.mwr.example.sieve/databases`

如果数据库保存了机密信息并已加密，但你能在应用中找到密码，那仍然是一个**漏洞**。

使用 `.tables` 列出表，使用 `.schema <table_name>` 列出表的列。

### Drozer (Exploit Activities, Content Providers and Services)

根据 [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf)：**Drozer** 允许你**扮演 Android 应用的角色**并与其他应用交互。它可以执行**已安装应用可以执行的任何操作**，例如利用 Android 的进程间通信 (IPC) 机制并与底层操作系统交互。\
Drozer 是一个有用的工具，用于**利用已导出的 activities、已导出的 services 和 Content Providers**，你将在后面的章节中学习到。

### 利用已导出的 Activities

[**如果你想复习什么是 Android Activity，请阅读此文。**](android-applications-basics.md#launcher-activity-and-other-activities)  
另外记住，activity 的代码从 **`onCreate`** 方法开始。

**授权绕过**

当一个 Activity 被导出时，你可以从外部应用调用其界面。因此，如果包含**敏感信息**的 activity 被**导出**，你可能能够**绕过**认证机制**访问它**。

[**学习如何使用 Drozer 利用已导出的 activities。**](drozer-tutorial/index.html#activities)

你也可以通过 adb 启动已导出的 activity：

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> 注意 authorisation bypass 并不总是一个漏洞，这取决于绕过的方式以及暴露了哪些信息。

**Sensitive information leakage**

**Activities can also return results**。如果你发现一个被 exported 且未受保护的 activity 调用了 **`setResult`** 方法并且 **returning sensitive information**，就会有 sensitive information leakage。

#### Tapjacking

如果没有防止 Tapjacking，你可能滥用该 exported activity 让 **用户执行意外操作**。关于 [**what is Tapjacking follow the link**](#tapjacking) 可获取更多信息。

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers 基本上用于 **share data**。如果应用暴露了 content providers，你可能能够从中 **extract sensitive** 数据。也很有必要测试可能的 **SQL injections** 和 **Path Traversals**，因为它们可能存在漏洞。

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
请记住 Service 的动作从方法 `onStartCommand` 开始。

Service 本质上是可以 **接收数据**、**处理** 数据并 **返回**（或不返回）响应的东西。因此，如果应用导出了某些 services，你应当 **检查** **code** 以了解其行为，并对其进行 **动态测试** 以提取机密信息、绕过认证机制等...\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
请记住 Broadcast Receiver 的动作从方法 `onReceive` 开始。

Broadcast receiver 会等待某种类型的消息。根据 receiver 如何处理消息，它可能存在漏洞。\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

你可以手动查找 deep links，使用像 MobSF 这样的工具或像 [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py) 这样的脚本。\
你可以使用 **adb** 或 **browser** **open** 已声明的 **scheme**：
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_注意你可以**省略 package name**，手机会自动调用应该打开该链接的应用。_
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Code executed**

为了找到应用中将要执行的**代码 (code that will be executed in the App)**，转到由深度链接（deep link）调用的 activity 并搜索函数 **`onNewIntent`**。

![](<../../images/image (436) (1) (1) (1).png>)

**Sensitive info**

每次发现深度链接时，检查它是否通过 URL 参数接收敏感数据（例如密码），因为任何其他应用都可以模拟该深度链接并窃取这些数据！

**Parameters in path**

你**还必须检查是否有任何深度链接在 URL 路径中使用参数**，例如：`https://api.example.com/v1/users/{username}`，在这种情况下你可以通过访问像：`example://app/users?username=../../unwanted-endpoint%3fparam=value` 来强制进行 path traversal。\
注意，如果你在应用中找到了正确的 endpoints，你可能能够导致 **Open Redirect**（如果路径的一部分被用作域名）、**account takeover**（如果你可以在没有 CSRF token 的情况下修改用户详情且易受影响的 vuln endpoint 使用了正确的方法）以及其他任何漏洞。更多 [info about this here](http://dphoeniixx.com/2020/12/13-2/)。

**More examples**

一个关于链接（_/.well-known/assetlinks.json_）的有趣漏洞赏金报告：[https://hackerone.com/reports/855618](https://hackerone.com/reports/855618)。

### Transport Layer Inspection and Verification Failures

- Android 应用并不总是**正确检查证书**。这些应用常常忽视警告并接受自签名证书，或者在某些情况下回退到使用 HTTP 连接。
- SSL/TLS 握手期间的协商有时很弱，使用不安全的 cipher suites。这使得连接容易受到中间人 (MITM) 攻击，攻击者可以解密数据。
- Leakage of private information 是一种风险，当应用使用安全通道进行认证但随后在其他事务中通过非安全通道通信时。这种做法无法保护敏感数据，例如会话 cookies 或用户信息，免受恶意实体的拦截。

#### Certificate Verification

我们将关注**证书验证 (certificate verification)**。必须验证服务器证书的完整性以增强安全性。这一点非常关键，因为不安全的 TLS 配置和通过未加密通道传输敏感数据都会带来重大风险。关于验证服务器证书和修复漏洞的详细步骤，[**this resource**](https://manifestsecurity.com/android-application-security-part-10/) 提供了全面的指导。

#### SSL Pinning

SSL Pinning 是一种安全措施，应用将服务器证书与存储在应用内的已知副本进行比对。此方法对于防止 MITM 攻击至关重要。强烈建议对处理敏感信息的应用实现 SSL Pinning。

#### Traffic Inspection

要检查 HTTP 流量，需要**安装代理工具的证书**（例如 Burp）。如果不安装该证书，加密流量可能无法通过代理可见。有关安装自定义 CA 证书的指南，[**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine)。

针对 **API Level 24 及以上** 的应用需要修改 Network Security Config 以接受代理的 CA 证书。此步骤对于检查加密流量至关重要。有关修改 Network Security Config 的说明，请参阅 [**refer to this tutorial**](make-apk-accept-ca-certificate.md)。

如果使用 **Flutter**，你需要按照 [**this page**](flutter.md) 的说明操作。仅将证书添加到证书存储通常不起作用，因为 Flutter 有其自己的有效 CA 列表。

#### Static detection of SSL/TLS pinning

在尝试运行时绕过之前，先快速映射 APK 中强制执行 pinning 的位置。静态发现有助于你规划 hooks/patches 并把注意力集中在正确的 code paths 上。

Tool: SSLPinDetect
- 开源的静态分析工具，会将 APK 反编译为 Smali（通过 apktool），并扫描为 SSL/TLS pinning 实现整理的 regex 模式。
- 报告每个匹配项的确切文件路径、行号和代码片段。
- 覆盖常见框架和自定义代码路径：OkHttp CertificatePinner、自定义 javax.net.ssl.X509TrustManager.checkServerTrusted、SSLContext.init 与自定义 TrustManagers/KeyManagers，以及 Network Security Config XML pins。

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
用法
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
示例模式规则 (JSON)
使用或扩展 signatures 来检测专有/自定义 pinning 样式。你可以加载自己的 JSON 并进行大规模扫描。
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
注意事项与提示
- 通过多线程和内存映射 I/O 对大型应用进行快速扫描；预编译的正则 (regex) 可减少开销/误报。
- 模式集合: https://github.com/aancw/smali-sslpin-patterns
- 下一步典型的检测目标：
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- 自定义 TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- 自定义 SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- 在 res/xml network security config 和 manifest 中的声明式 pins
- 使用匹配到的位置在动态测试前规划 Frida hooks、静态补丁或配置审查。

#### 绕过 SSL Pinning

当实现了 SSL Pinning 时，必须绕过它来检查 HTTPS 流量。为此有多种方法：

- 自动使用 [**apk-mitm**](https://github.com/shroudedcode/apk-mitm) **modify** the **apk** 以 **bypass** SSLPinning。这个选项的最大优点是无需 root 即可绕过 SSL Pinning，但你需要删除应用并重新安装新的 APK，而且并不总是有效。
- 你可以使用 **Frida**（下文讨论）来绕过该保护。这里有一篇使用 Burp+Frida+Genymotion 的指南: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- 你也可以尝试使用 [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"` 自动绕过 SSL Pinning
- 你也可以尝试使用 **MobSF dynamic analysis**（下文说明）自动绕过 SSL Pinning
- 如果你仍然认为有流量未被捕获，可以尝试使用 iptables 将流量转发到 burp。阅读这篇博客: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### 寻找常见的 Web 漏洞

同样重要的是在应用内搜索常见的 Web 漏洞。关于识别和缓解这些漏洞的详细信息超出本摘要范围，但在其他地方有大量覆盖。

### Frida

[Frida](https://www.frida.re) 是针对开发者、逆向工程师和安全研究人员的动态注入工具包。\
**你可以在运行时访问运行中的应用并 hook 方法以改变行为、修改值、提取值或执行不同的代码...**\
如果你想 pentest Android 应用，你需要知道如何使用 Frida。

- 学习如何使用 Frida: [**Frida tutorial**](frida-tutorial/index.html)
- 一些用于 Frida 操作的 "GUI": [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection 非常适合自动化使用 Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- 你可以在这里找到一些 Awesome Frida 脚本: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- 尝试按 [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) 中所示通过加载 Frida 来绕过 anti-debugging / anti-frida 机制（工具 [linjector](https://github.com/erfur/linjector-rs)）

#### Anti-instrumentation & SSL pinning 绕过工作流

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **转储内存 - Fridump**

检查应用是否在内存中存储了不应该存储的敏感信息，例如密码或助记词。

使用 [**Fridump3**](https://github.com/rootbsd/fridump3) 你可以导出应用的内存，命令：
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
这将把内存转储到 ./dump 文件夹，在那里你可以用类似下面的 grep 命令进行搜索：
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Keystore 中的敏感数据**

在 Android 中，Keystore 是存放敏感数据的最佳位置，然而在获得足够权限的情况下仍然 **可能被访问**。由于应用往往在此处 **以明文存储敏感数据**，pentests 应以 root user 身份进行检查，否则具有设备物理访问权的人可能能够窃取这些数据。

即使应用将数据存储在 Keystore 中，数据也应当被加密。

To access the data inside the keystore you could use this Frida script: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

使用下面的 Frida 脚本，可能可以 **bypass fingerprint authentication**，Android 应用可能为保护某些敏感区域而执行该操作：
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **后台快照**

当你将应用置于后台时，Android 会保存应用的**快照**，这样当它恢复到前台时，会先加载该图像，再加载应用本身，从而看起来应用启动更快。

但是，如果该快照包含**敏感信息**，有权限访问该快照的人可能会**窃取这些信息**（注意，访问它需要 root 权限）。

快照通常存储在： **`/data/system_ce/0/snapshots`**

Android 提供了一种**通过设置 FLAG_SECURE 阻止截图捕获**的布局参数。使用该 flag 后，窗口内容会被视为安全，从而阻止其出现在截图中或在非安全显示器上被查看。
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android 应用分析器**

该工具可帮助你在动态分析期间管理不同的工具: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

开发者经常创建代理组件，如 activities、services 和 broadcast receivers，它们处理这些 Intents 并将它们传递给诸如 `startActivity(...)` 或 `sendBroadcast(...)` 之类的方法，这可能存在风险。

危险在于允许攻击者通过误导这些 Intents 来触发 non-exported 应用组件或访问敏感的 content providers。一个显著的例子是 `WebView` 组件通过 `Intent.parseUri(...)` 将 URL 转换为 `Intent` 对象然后执行它们，这可能导致恶意的 Intent injections。

### 关键要点

- **Intent Injection** 类似于 Web 的 Open Redirect 问题。
- 利用通常涉及将 `Intent` 对象作为 extras 传递，这些 Intent 可以被重定向以执行不安全的操作。
- 它可能使 non-exported 组件和 content providers 暴露给攻击者。
- `WebView` 将 URL 转换为 `Intent` 的机制可能促成意外的行为。

### Android Client Side Injections and others

你可能在 Web 上见过这类漏洞。在 Android 应用中需要特别注意以下漏洞：

- **SQL Injection:** 在处理动态查询或 Content-Providers 时，确保使用参数化查询。
- **JavaScript Injection (XSS):** 确保任何 WebViews 的 JavaScript 和 Plugin 支持被禁用（默认已禁用）。 [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews 应该禁用对文件系统的访问（默认启用） - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: 在若干情况下，当 android 应用结束会话时，cookie 未被撤销，甚至可能被保存到磁盘
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## 自动化分析

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**静态分析**

![](<../../images/image (866).png>)

**应用的漏洞评估** 使用一个漂亮的基于 web 的前端。你也可以执行动态分析（但需要先准备环境）。
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### 使用 MobSF 的辅助动态分析

**MobSF** 在 **Android** 的 **动态分析** 中也非常有用，但在这种情况下你需要在宿主机上安装 MobSF 和 **genymotion**（VM 或 Docker 无效）。_Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
The **MobSF dynamic analyser** can:

- **Dump application data**（URLs、logs、clipboard、你手动截的 screenshots、由 "**Exported Activity Tester**" 生成的 screenshots、emails、SQLite databases、XML files 以及其他生成的文件）。除了截图以外，所有这些都会自动完成；截图需要你在想截屏时按下按钮，或者按下 "**Exported Activity Tester**" 来获取所有 exported activities 的截图。
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: It will print all the loaded classes
- **Capture Strings**: It will print all the capture strings while using the application (super noisy)
- **Capture String Comparisons**: Could be very useful. It will **show the 2 strings being compared** and if the result was True or False.
- **Enumerate Class Methods**: Put the class name (like "java.io.File") and it will print all the methods of the class.
- **Search Class Pattern**: Search classes by pattern
- **Trace Class Methods**: **Trace** a **whole class** (see inputs and outputs of all methods of th class). Remember that by default MobSF traces several interesting Android Api methods.

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf also brings you a shell with some **adb** commands, **MobSF commands**, and common **shell** **commands** at the bottom of the dynamic analysis page. Some interesting commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP 工具**

当 HTTP 流量被捕获时，你可以在“**HTTP(S) Traffic**”底部看到捕获流量的简陋视图，或者在绿色按钮“**Start HTTPTools**”中看到更友好的视图。从第二个选项，你可以将**捕获的请求**发送到像 Burp 或 Owasp ZAP 这样的**proxies**。\
为此，_打开 Burp -->_ _关闭 Intercept --> 在 MobSB HTTPTools 中选择请求_ --> 按“**Send to Fuzzer**” --> _选择代理地址_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080))。

完成对 MobSF 的动态分析后，你可以点击“**Start Web API Fuzzer**”来**fuzz http requests**并查找漏洞。

> [!TIP]
> 在使用 MobSF 进行动态分析后，代理设置可能会被错误配置，且无法通过 GUI 修复。你可以通过执行以下命令修复代理设置：
>
> ```
> adb shell settings put global http_proxy :0
> ```

### 使用 Inspeckage 进行辅助动态分析

你可以从 [**Inspeckage**](https://github.com/ac-pm/Inspeckage) 获取该工具。\
该工具会使用一些 **Hooks**，在你执行 **动态分析** 时让你了解 **应用中正在发生的事情**。

### [Yaazhini](https://www.vegabird.com/yaazhini/)

这是一个**通过 GUI 执行静态分析的优秀工具**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

该工具旨在查找若干**与安全相关的 Android 应用漏洞**，无论是在**源代码**还是在**已打包的 APK**中。该工具还**能够创建可部署的 "Proof-of-Concept" APK**以及**ADB commands**，用于利用某些已发现的漏洞（Exposed activities、intents、tapjacking...）。与 Drozer 一样，无需对测试设备进行 root。
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- 显示所有提取的文件以便参考
- 自动将 APK files 反编译为 Java 和 Smali 格式
- 分析 AndroidManifest.xml 以查找常见漏洞和行为
- 对静态源代码进行分析以发现常见漏洞和行为
- 设备信息
- 以及更多
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER 是一个可以在 Windows, MacOS X and Linux 上使用的命令行应用程序，用于分析 _.apk_ 文件以查找漏洞。它通过解压 APK 并应用一系列规则来检测这些漏洞。

所有规则集中在 `rules.json` 文件中，每个公司或测试人员都可以创建自己的规则来分析他们需要的内容。

从 [download page](https://superanalyzer.rocks/download.html) 下载最新的二进制文件
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn 是一个 **crossplatform** 工具，帮助 developers、bugbounty hunters 和 ethical hackers 对移动应用执行 [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis)。

其工作原理是将你的移动应用文件（.apk 或 .ipa 文件）拖放到 StaCoAn 应用程序上，StaCoAn 会为你生成一个可视化且可携带的报告。你可以调整设置和 wordlists 以获得自定义体验。

下载[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework 是一个 Android 漏洞分析系统，帮助开发人员或 hackers 发现 Android 应用中的潜在安全漏洞。\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** 是一个工具，主要目的是检测并警告用户 Android 应用可能的恶意行为。

检测是通过对应用的 Dalvik bytecode（以 **Smali** 表示）进行 **静态分析**，并使用 [`androguard`](https://github.com/androguard/androguard) 库来完成。

该工具会寻找类似于以下的 **“恶意” 应用的常见行为**： Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** 是一个 **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework。它将常用的 mobile application reverse engineering 和 analysis 工具集合到一起，帮助针对 OWASP mobile security threats 对移动应用进行测试。其目标是让这项工作对移动应用开发者和安全专业人员更简单、更友好。

它能够：

- 提取 Java 和 Smali 代码，使用不同的工具
- 使用以下工具分析 APK: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- 使用正则表达式从 APK 中提取私有信息
- 分析 Manifest
- 使用以下工具分析发现的域名: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) 和 [whatweb](https://github.com/urbanadventurer/WhatWeb)
- 通过 [apk-deguard.com](http://www.apk-deguard.com) 进行反混淆

### Koodous

用于检测 malware: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

请注意，根据你用于混淆代码的服务和配置，敏感信息可能会被混淆，也可能不会。

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** 是一个开源命令行工具，用于缩小、优化和混淆 Java 代码。它能够优化 bytecode 并检测和移除未使用的指令。ProGuard 是自由软件，采用 GNU General Public License 第 2 版分发。

ProGuard 随 Android SDK 一起分发，并在以 release mode 构建应用时运行。

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Last time we checked, the Dexguard mode of operation was:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard 逆转由 Android obfuscation 工具执行的混淆过程。这使得多种安全分析成为可能，包括代码检查和库识别。**

你可以将混淆过的 APK 上传到他们的平台。

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

它是一个 **通用的 android deobfuscator。** Simplify 通过**在虚拟环境中执行应用**来理解其行为，然后**尝试优化代码**，使其在行为上与原来完全一致，但更容易被人工理解。每种优化类型都很简单且通用，因此具体使用了何种混淆方式并不重要。

### [APKiD](https://github.com/rednaga/APKiD)

APKiD 可以告诉你 **一个 APK 是如何构建的**。它能识别很多 **编译器、打包器、混淆器** 以及其他奇怪的东西。它是 Android 领域的 [_PEiD_](https://www.aldeid.com/wiki/PEiD)。

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b 是一个基于 ubuntu-mate 的 Android 安全虚拟机，包含来自不同安全爱好者和研究人员的最新框架、教程和用于 reverse engineering 与 malware analysis 的实验。

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) 这是一个很棒的资源列表
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android 快速课程
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
