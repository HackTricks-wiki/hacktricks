# Android Applications Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android Applications Basics

यह पृष्ठ पढ़ना अत्यधिक अनुशंसित है ताकि आप **Android सुरक्षा से संबंधित सबसे महत्वपूर्ण भागों और एक Android एप्लिकेशन में सबसे खतरनाक घटकों** के बारे में जान सकें:

{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

यह मुख्य उपकरण है जिसकी आपको एक Android डिवाइस (अनुकरणीय या भौतिक) से कनेक्ट करने की आवश्यकता है।\
**ADB** आपको **USB** या **Network** के माध्यम से कंप्यूटर से उपकरणों को नियंत्रित करने की अनुमति देता है। यह उपयोगिता **फाइलों** की दोनों दिशाओं में **कॉपीिंग**, ऐप्स की **स्थापना** और **अनइंस्टॉलेशन**, **शेल कमांड्स** का **निष्पादन**, **डेटा का बैकअप**, **लॉग्स का पढ़ना**, और अन्य कार्यों को सक्षम बनाती है।

ADB का उपयोग कैसे करें, यह जानने के लिए [**ADB Commands**](adb-commands.md) की निम्नलिखित सूची पर एक नज़र डालें।

## Smali

कभी-कभी **छिपी हुई जानकारी** (शायद अच्छी तरह से छिपे हुए पासवर्ड या फ्लैग) तक पहुँचने के लिए **एप्लिकेशन कोड को संशोधित करना** दिलचस्प होता है। फिर, APK को डिकंपाइल करना, कोड को संशोधित करना और इसे फिर से संकलित करना दिलचस्प हो सकता है।\
[**इस ट्यूटोरियल में** आप **APK को डिकंपाइल करना, Smali कोड को संशोधित करना और नए कार्यक्षमता के साथ APK को फिर से संकलित करना** सीख सकते हैं](smali-changes.md)। यह **गतिशील विश्लेषण** के दौरान कई परीक्षणों के लिए एक **वैकल्पिक** के रूप में बहुत उपयोगी हो सकता है जो प्रस्तुत किए जाने वाले हैं। फिर, **इस संभावना को हमेशा ध्यान में रखें**।

## Other interesting tricks

- [Play Store में अपनी स्थिति को धोखा देना](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-आधारित गैर-रूट विशेषाधिकार पहुंच)](shizuku-privileged-api.md)
- **APK डाउनलोड करें**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Extract APK from device:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- सभी स्प्लिट और बेस एपीके को [APKEditor](https://github.com/REAndroid/APKEditor) के साथ मिलाएं:
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Static Analysis

सबसे पहले, एक APK का विश्लेषण करने के लिए आपको **decompiler** का उपयोग करके **Java कोड** पर एक नज़र डालनी चाहिए।\
कृपया, [**विभिन्न उपलब्ध decompilers के बारे में जानकारी के लिए यहां पढ़ें**](apk-decompilers.md).

### Looking for interesting Info

APK के **strings** पर एक नज़र डालकर आप **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** और कुछ भी दिलचस्प खोज सकते हैं... यहां तक कि कोड निष्पादन **backdoors** या प्रमाणीकरण backdoors (ऐप के लिए हार्डकोडेड व्यवस्थापक क्रेडेंशियल्स) के लिए भी देखें।

**Firebase**

**firebase URLs** पर विशेष ध्यान दें और जांचें कि क्या यह गलत तरीके से कॉन्फ़िगर किया गया है। [यहां FIrebase के बारे में अधिक जानकारी और इसे कैसे शोषण करना है।](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Basic understanding of the application - Manifest.xml, strings.xml

एक एप्लिकेशन के _Manifest.xml_ और **_strings.xml_** फ़ाइलों की **जांच संभावित सुरक्षा कमजोरियों को प्रकट कर सकती है**। इन फ़ाइलों को decompilers का उपयोग करके या APK फ़ाइल एक्सटेंशन को .zip में बदलकर और फिर इसे अनज़िप करके एक्सेस किया जा सकता है।

**Manifest.xml** से पहचानी गई **Vulnerabilities** में शामिल हैं:

- **Debuggable Applications**: _Manifest.xml_ फ़ाइल में `debuggable="true"` के रूप में सेट की गई एप्लिकेशन जोखिम में होती हैं क्योंकि वे ऐसे कनेक्शन की अनुमति देती हैं जो शोषण की ओर ले जा सकते हैं। डिबग करने योग्य एप्लिकेशन को शोषित करने के तरीके को समझने के लिए, एक ट्यूटोरियल देखें।
- **Backup Settings**: संवेदनशील जानकारी से निपटने वाले एप्लिकेशनों के लिए `android:allowBackup="false"` विशेष रूप से सेट किया जाना चाहिए ताकि adb के माध्यम से अनधिकृत डेटा बैकअप को रोका जा सके, विशेष रूप से जब usb debugging सक्षम हो।
- **Network Security**: _res/xml/_ में कस्टम नेटवर्क सुरक्षा कॉन्फ़िगरेशन (`android:networkSecurityConfig="@xml/network_security_config"`) सुरक्षा विवरण जैसे प्रमाणपत्र पिन और HTTP ट्रैफ़िक सेटिंग्स को निर्दिष्ट कर सकते हैं। एक उदाहरण विशेष डोमेन के लिए HTTP ट्रैफ़िक की अनुमति देना है।
- **Exported Activities and Services**: मैनिफेस्ट में निर्यातित गतिविधियों और सेवाओं की पहचान करना उन घटकों को उजागर कर सकता है जो दुरुपयोग के लिए संवेदनशील हो सकते हैं। गतिशील परीक्षण के दौरान आगे के विश्लेषण से यह पता चल सकता है कि इन घटकों का शोषण कैसे किया जाए।
- **Content Providers and FileProviders**: उजागर सामग्री प्रदाता अनधिकृत पहुंच या डेटा में संशोधन की अनुमति दे सकते हैं। FileProviders की कॉन्फ़िगरेशन की भी जांच की जानी चाहिए।
- **Broadcast Receivers and URL Schemes**: ये घटक शोषण के लिए उपयोग किए जा सकते हैं, विशेष रूप से इनपुट कमजोरियों के लिए URL योजनाओं के प्रबंधन पर ध्यान दिया जाना चाहिए।
- **SDK Versions**: `minSdkVersion`, `targetSDKVersion`, और `maxSdkVersion` विशेषताएँ समर्थित Android संस्करणों को इंगित करती हैं, सुरक्षा कारणों से पुराने, कमजोर Android संस्करणों का समर्थन न करने के महत्व को उजागर करती हैं।

**strings.xml** फ़ाइल से, संवेदनशील जानकारी जैसे API keys, कस्टम स्कीम और अन्य डेवलपर नोट्स का पता लगाया जा सकता है, जो इन संसाधनों की सावधानीपूर्वक समीक्षा की आवश्यकता को उजागर करता है।

### Tapjacking

**Tapjacking** एक हमला है जहां एक **malicious** **application** लॉन्च किया जाता है और **पीड़ित एप्लिकेशन के शीर्ष पर खुद को रखता है**। जब यह पीड़ित ऐप को दृश्यमान रूप से अस्पष्ट करता है, तो इसका उपयोगकर्ता इंटरफ़ेस इस तरह से डिज़ाइन किया गया है कि उपयोगकर्ता को इसके साथ बातचीत करने के लिए धोखा दिया जाए, जबकि यह बातचीत को पीड़ित ऐप के पास भेज रहा है।\
इसका प्रभाव यह है कि यह **उपयोगकर्ता को यह जानने से अंधा कर देता है कि वे वास्तव में पीड़ित ऐप पर क्रियाएँ कर रहे हैं**।

अधिक जानकारी प्राप्त करें:

{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

एक **activity** जिसमें **`launchMode`** **`singleTask`** पर सेट है और कोई `taskAffinity` परिभाषित नहीं है, कार्य Hijacking के लिए संवेदनशील है। इसका मतलब है कि एक **application** स्थापित की जा सकती है और यदि इसे वास्तविक एप्लिकेशन से पहले लॉन्च किया जाता है, तो यह **वास्तविक एप्लिकेशन के कार्य को हाइजैक कर सकती है** (इसलिए उपयोगकर्ता **malicious application** के साथ बातचीत कर रहा होगा, यह सोचते हुए कि वह असली का उपयोग कर रहा है)।

अधिक जानकारी प्राप्त करें:

{{#ref}}
android-task-hijacking.md
{{#endref}}

### Insecure data storage

**Internal Storage**

Android में, **internal** storage में **stored** फ़ाइलें केवल उस **app** द्वारा **access** की जाने के लिए **design** की गई हैं जिसने उन्हें **create** किया है। यह सुरक्षा उपाय Android ऑपरेटिंग सिस्टम द्वारा **enforced** किया गया है और सामान्यतः अधिकांश एप्लिकेशनों की सुरक्षा आवश्यकताओं के लिए पर्याप्त है। हालाँकि, डेवलपर्स कभी-कभी `MODE_WORLD_READABLE` और `MODE_WORLD_WRITABLE` जैसे मोड का उपयोग करते हैं ताकि फ़ाइलों को विभिन्न एप्लिकेशनों के बीच **share** किया जा सके। फिर भी, ये मोड अन्य एप्लिकेशनों द्वारा इन फ़ाइलों तक पहुंच को **restrict** नहीं करते हैं, जिसमें संभावित रूप से दुर्भावनापूर्ण एप्लिकेशन भी शामिल हैं।

1. **Static Analysis:**
- **Ensure** करें कि `MODE_WORLD_READABLE` और `MODE_WORLD_WRITABLE` का उपयोग **carefully scrutinized** किया गया है। ये मोड फ़ाइलों को **unintended or unauthorized access** के लिए **potentially expose** कर सकते हैं।
2. **Dynamic Analysis:**
- **Verify** करें कि ऐप द्वारा बनाई गई फ़ाइलों पर सेट की गई **permissions** क्या हैं। विशेष रूप से, **check** करें कि क्या कोई फ़ाइलें **readable या writable worldwide** पर सेट की गई हैं। यह एक महत्वपूर्ण सुरक्षा जोखिम पैदा कर सकता है, क्योंकि यह **किसी भी एप्लिकेशन** को जो डिवाइस पर स्थापित है, उसकी उत्पत्ति या इरादे की परवाह किए बिना, इन फ़ाइलों को **read या modify** करने की अनुमति देगा।

**External Storage**

**external storage** पर फ़ाइलों के साथ काम करते समय, कुछ सावधानियाँ बरतनी चाहिए:

1. **Accessibility**:
- बाहरी संग्रहण में फ़ाइलें **globally readable और writable** होती हैं। इसका मतलब है कि कोई भी एप्लिकेशन या उपयोगकर्ता इन फ़ाइलों तक पहुंच सकता है।
2. **Security Concerns**:
- पहुंच की आसानी को देखते हुए, सलाह दी जाती है कि **संवेदनशील जानकारी** को बाहरी संग्रहण पर **न रखें**।
- बाहरी संग्रहण को किसी भी एप्लिकेशन द्वारा हटाया या एक्सेस किया जा सकता है, जिससे यह कम सुरक्षित हो जाता है।
3. **Handling Data from External Storage**:
- हमेशा बाहरी संग्रहण से प्राप्त डेटा पर **input validation** करें। यह महत्वपूर्ण है क्योंकि डेटा एक अविश्वसनीय स्रोत से है।
- बाहरी संग्रहण पर executable या class फ़ाइलों को गतिशील लोडिंग के लिए रखना दृढ़ता से हतोत्साहित किया जाता है।
- यदि आपके एप्लिकेशन को बाहरी संग्रहण से executable फ़ाइलें प्राप्त करनी हैं, तो सुनिश्चित करें कि ये फ़ाइलें **signed और cryptographically verified** हैं इससे पहले कि उन्हें गतिशील रूप से लोड किया जाए। यह आपके एप्लिकेशन की सुरक्षा अखंडता बनाए रखने के लिए महत्वपूर्ण है।

बाहरी संग्रहण को `/storage/emulated/0`, `/sdcard`, `/mnt/sdcard` में **access** किया जा सकता है।

> [!TIP]
> Android 4.4 (**API 17**) से शुरू होकर, SD कार्ड में एक निर्देशिका संरचना है जो **एक ऐप से उस ऐप के लिए विशेष रूप से निर्देशिका तक पहुंच को सीमित करती है**। यह दुर्भावनापूर्ण एप्लिकेशन को किसी अन्य ऐप की फ़ाइलों तक पढ़ने या लिखने की पहुंच प्राप्त करने से रोकता है।

**Sensitive data stored in clear-text**

- **Shared preferences**: Android प्रत्येक एप्लिकेशन को `/data/data/<packagename>/shared_prefs/` पथ में xml फ़ाइलें आसानी से सहेजने की अनुमति देता है और कभी-कभी उस फ़ोल्डर में स्पष्ट पाठ में संवेदनशील जानकारी मिल सकती है।
- **Databases**: Android प्रत्येक एप्लिकेशन को `/data/data/<packagename>/databases/` पथ में sqlite डेटाबेस को आसानी से सहेजने की अनुमति देता है और कभी-कभी उस फ़ोल्डर में स्पष्ट पाठ में संवेदनशील जानकारी मिल सकती है।

### Broken TLS

**Accept All Certificates**

किसी कारण से कभी-कभी डेवलपर्स सभी प्रमाणपत्रों को स्वीकार करते हैं, भले ही उदाहरण के लिए होस्टनाम कोड की निम्नलिखित पंक्तियों के साथ मेल न खाता हो:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Broken Cryptography

**Poor Key Management Processes**

कुछ डेवलपर्स संवेदनशील डेटा को स्थानीय स्टोरेज में सहेजते हैं और इसे कोड में हार्डकोडेड/पूर्वानुमानित कुंजी के साथ एन्क्रिप्ट करते हैं। ऐसा नहीं किया जाना चाहिए क्योंकि कुछ रिवर्सिंग हमलावरों को गोपनीय जानकारी निकालने की अनुमति दे सकती है।

**Use of Insecure and/or Deprecated Algorithms**

डेवलपर्स को **deprecated algorithms** का उपयोग करके प्राधिकरण **checks**, **store** या **send** डेटा नहीं करना चाहिए। इनमें से कुछ एल्गोरिदम हैं: RC4, MD4, MD5, SHA1... यदि **hashes** का उपयोग पासवर्ड को स्टोर करने के लिए किया जाता है, तो salt के साथ brute-force **resistant** hashes का उपयोग किया जाना चाहिए।

### Other checks

- यह अनुशंसा की जाती है कि **APK को obfuscate** किया जाए ताकि हमलावरों के लिए रिवर्स इंजीनियरिंग का काम कठिन हो सके।
- यदि ऐप संवेदनशील है (जैसे बैंक ऐप), तो इसे **देखने के लिए अपने स्वयं के checks** करने चाहिए कि मोबाइल रूटेड है या नहीं और इसके अनुसार कार्य करना चाहिए।
- यदि ऐप संवेदनशील है (जैसे बैंक ऐप), तो इसे यह जांचना चाहिए कि क्या एक **emulator** का उपयोग किया जा रहा है।
- यदि ऐप संवेदनशील है (जैसे बैंक ऐप), तो इसे **execute करने से पहले अपनी स्वयं की integrity की जांच करनी चाहिए** कि क्या इसे संशोधित किया गया है।
- [**APKiD**](https://github.com/rednaga/APKiD) का उपयोग करें यह जांचने के लिए कि APK बनाने के लिए कौन सा compiler/packer/obfuscator का उपयोग किया गया था।

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:

{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:

{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

The tool [**mariana-trench**](https://github.com/facebook/mariana-trench) is capable of finding **vulnerabilities** by **scanning** the **code** of the application. This tool contains a series of **known sources** (that indicates to the tool the **places** where the **input** is **controlled by the user**), **sinks** (which indicates to the tool **dangerous** **places** where malicious user input could cause damages) and **rules**. These rules indicates the **combination** of **sources-sinks** that indicates a vulnerability.

With this knowledge, **mariana-trench will review the code and find possible vulnerabilities on it**.

### Secrets leaked

An application may contain secrets (API keys, passwords, hidden urls, subdomains...) inside of it that you might be able to discover. You could us a tool such as [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication

{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)

### **Other tricks**

{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> First of all, you need an environment where you can install the application and all the environment (Burp CA cert, Drozer and Frida mainly). Therefore, a rooted device (emulated or not) is extremely recommended.

### Online Dynamic analysis

You can create a **free account** in: [https://appetize.io/](https://appetize.io). This platform allows you to **upload** and **execute** APKs, so it is useful to see how an apk is behaving.

You can even **see the logs of your application** in the web and connect through **adb**.

![](<../../images/image (831).png>)

Thanks to the ADB connection you can use **Drozer** and **Frida** inside the emulators.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (You can create **x86** and **arm** devices, and according to [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** versions **support ARM libraries** without needing an slow arm emulator).
- Learn to set it up in this page:

{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, you need to create an account. _It's recommend to **download** the version **WITH**_ _**VirtualBox** to avoid potential errors._)
- [**Nox**](https://es.bignox.com) (Free, but it doesn't support Frida or Drozer).

> [!TIP]
> When creating a new emulator on any platform remember that the bigger the screen is, the slower the emulator will run. So select small screens if possible.

To **install google services** (like AppStore) in Genymotion you need to click on the red marked button of the following image:

![](<../../images/image (277).png>)

Also, notice that in the **configuration of the Android VM in Genymotion** you can select **Bridge Network mode** (this will be useful if you will be connecting to the Android VM from a different VM with the tools).

#### Use a physical device

You need to activate the **debugging** options and it will be cool if you can **root** it:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Once you have installed the application, the first thing you should do is to try it and investigate what does it do, how does it work and get comfortable with it.\
> I will suggest to **perform this initial dynamic analysis using MobSF dynamic analysis + pidcat**, so we will be able to **learn how the application works** while MobSF **captures** a lot of **interesting** **data** you can review later on.

### Unintended Data Leakage

**Logging**

डेवलपर्स को **debugging information** को सार्वजनिक रूप से उजागर करने के प्रति सतर्क रहना चाहिए, क्योंकि इससे संवेदनशील डेटा लीक हो सकता है। एप्लिकेशन लॉग की निगरानी के लिए [**pidcat**](https://github.com/JakeWharton/pidcat) और `adb logcat` उपकरणों की सिफारिश की जाती है ताकि संवेदनशील जानकारी की पहचान और सुरक्षा की जा सके। **Pidcat** को इसके उपयोग में आसानी और पठनीयता के लिए पसंद किया जाता है।

> [!WARNING]
> ध्यान दें कि **Android 4.0 से नए संस्करणों** में, **ऐप्लिकेशन केवल अपने स्वयं के लॉग तक पहुंचने में सक्षम होते हैं**। इसलिए ऐप्लिकेशन अन्य ऐप्स के लॉग तक पहुंच नहीं सकते।\
> फिर भी, यह अनुशंसा की जाती है कि **संवेदनशील जानकारी को लॉग न करें**।

**Copy/Paste Buffer Caching**

Android का **clipboard-based** ढांचा ऐप्स में कॉपी-पेस्ट कार्यक्षमता को सक्षम करता है, फिर भी यह एक जोखिम प्रस्तुत करता है क्योंकि **अन्य एप्लिकेशन** क्लिपबोर्ड तक **पहुँच** सकते हैं, जिससे संवेदनशील डेटा उजागर हो सकता है। संवेदनशील अनुभागों के लिए **कॉपी/पेस्ट** कार्यों को अक्षम करना महत्वपूर्ण है, जैसे कि क्रेडिट कार्ड विवरण, डेटा लीक को रोकने के लिए।

**Crash Logs**

यदि एक एप्लिकेशन **crash** होता है और **logs** को सहेजता है, तो ये लॉग हमलावरों की मदद कर सकते हैं, विशेष रूप से जब एप्लिकेशन को रिवर्स-इंजीनियर नहीं किया जा सकता। इस जोखिम को कम करने के लिए, क्रैश पर लॉगिंग से बचें, और यदि लॉग को नेटवर्क के माध्यम से भेजा जाना चाहिए, तो सुनिश्चित करें कि उन्हें सुरक्षा के लिए SSL चैनल के माध्यम से भेजा जाए।

As pentester, **try to take a look to these logs**.

**Analytics Data Sent To 3rd Parties**

ऐप्लिकेशन अक्सर Google Adsense जैसी सेवाओं को एकीकृत करते हैं, जो डेवलपर्स द्वारा अनुचित कार्यान्वयन के कारण अनजाने में **संवेदनशील डेटा लीक** कर सकते हैं। संभावित डेटा लीक की पहचान करने के लिए, यह सलाह दी जाती है कि **ऐप्लिकेशन के ट्रैफ़िक को इंटरसेप्ट करें** और देखें कि क्या कोई संवेदनशील जानकारी तीसरे पक्ष की सेवाओं को भेजी जा रही है।

### SQLite DBs

Most of the applications will use **internal SQLite databases** to save information. During the pentest take a **look** to the **databases** created, the names of **tables** and **columns** and all the **data** saved because you could find **sensitive information** (which would be a vulnerability).\
Databases should be located in `/data/data/the.package.name/databases` like `/data/data/com.mwr.example.sieve/databases`

If the database is saving confidential information and is **encrypted b**ut you can **find** the **password** inside the application it's still a **vulnerability**.

Enumerate the tables using `.tables` and enumerate the columns of the tables doing `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer is s useful tool to **exploit exported activities, exported services and Content Providers** as you will learn in the following sections.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Also remember that the code of an activity starts in the **`onCreate`** method.

**Authorisation bypass**

When an Activity is exported you can invoke its screen from an external app. Therefore, if an activity with **sensitive information** is **exported** you could **bypass** the **authentication** mechanisms **to access it.**

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

You can also start an exported activity from adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF _**singleTask/singleInstance**_ के उपयोग को `android:launchMode` में एक गतिविधि के रूप में दुर्भावनापूर्ण के रूप में पहचानता है, लेकिन [इस](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750) के कारण, यह स्पष्ट रूप से केवल पुराने संस्करणों (API संस्करण < 21) पर खतरनाक है।

> [!TIP]
> ध्यान दें कि एक प्राधिकरण बायपास हमेशा एक कमजोर बिंदु नहीं होता है, यह इस पर निर्भर करेगा कि बायपास कैसे काम करता है और कौन सी जानकारी उजागर होती है।

**संवेदनशील जानकारी का रिसाव**

**गतिविधियाँ भी परिणाम लौट सकती हैं**। यदि आप एक निर्यातित और असुरक्षित गतिविधि को खोजने में सफल होते हैं जो **`setResult`** विधि को कॉल करती है और **संवेदनशील जानकारी लौटाती है**, तो यह संवेदनशील जानकारी का रिसाव है।

#### Tapjacking

यदि tapjacking को रोका नहीं गया, तो आप निर्यातित गतिविधि का दुरुपयोग कर सकते हैं ताकि **उपयोगकर्ता अप्रत्याशित क्रियाएँ करें**। Tapjacking के बारे में अधिक जानकारी के लिए [**यहाँ लिंक का पालन करें**](#tapjacking)।

### सामग्री प्रदाताओं का शोषण - संवेदनशील जानकारी तक पहुँच और हेरफेर

[**यदि आप सामग्री प्रदाता क्या है, इसे ताज़ा करना चाहते हैं तो इसे पढ़ें।**](android-applications-basics.md#content-provider)\
सामग्री प्रदाता मूल रूप से **डेटा साझा करने** के लिए उपयोग किए जाते हैं। यदि किसी ऐप में उपलब्ध सामग्री प्रदाता हैं, तो आप उनसे **संवेदनशील** डेटा निकालने में सक्षम हो सकते हैं। यह भी संभावित **SQL इंजेक्शन** और **पथ यात्रा** का परीक्षण करने के लिए दिलचस्प है क्योंकि वे कमजोर हो सकते हैं।

[**Drozer के साथ सामग्री प्रदाताओं का शोषण करना सीखें।**](drozer-tutorial/index.html#content-providers)

### **सेवाओं का शोषण**

[**यदि आप सेवा क्या है, इसे ताज़ा करना चाहते हैं तो इसे पढ़ें।**](android-applications-basics.md#services)\
याद रखें कि एक सेवा की क्रियाएँ `onStartCommand` विधि में शुरू होती हैं।

सेवा मूल रूप से कुछ ऐसा है जो **डेटा प्राप्त कर सकता है**, **प्रसंस्कृत** कर सकता है और **एक प्रतिक्रिया लौटाता है** (या नहीं)। फिर, यदि कोई एप्लिकेशन कुछ सेवाएँ निर्यात कर रहा है, तो आपको **कोड** की **जांच** करनी चाहिए ताकि यह समझ सकें कि यह क्या कर रहा है और **गोपनीय जानकारी निकालने**, प्रमाणीकरण उपायों को बायपास करने के लिए इसे **गतिशील रूप से** **परीक्षण** करें...\
[**Drozer के साथ सेवाओं का शोषण करना सीखें।**](drozer-tutorial/index.html#services)

### **ब्रॉडकास्ट रिसीवर्स का शोषण**

[**यदि आप ब्रॉडकास्ट रिसीवर क्या है, इसे ताज़ा करना चाहते हैं तो इसे पढ़ें।**](android-applications-basics.md#broadcast-receivers)\
याद रखें कि एक ब्रॉडकास्ट रिसीवर की क्रियाएँ `onReceive` विधि में शुरू होती हैं।

एक ब्रॉडकास्ट रिसीवर एक प्रकार के संदेश की प्रतीक्षा करेगा। रिसीवर जिस तरह से संदेश को संभालता है, उसके आधार पर यह कमजोर हो सकता है।\
[**Drozer के साथ ब्रॉडकास्ट रिसीवर्स का शोषण करना सीखें।**](#exploiting-broadcast-receivers)

### **स्कीमों / डीप लिंक का शोषण**

आप मैन्युअल रूप से डीप लिंक की तलाश कर सकते हैं, MobSF जैसे उपकरणों का उपयोग करके या [इस स्क्रिप्ट](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py) का उपयोग करके।\
आप **adb** या एक **ब्राउज़र** का उपयोग करके एक घोषित **स्कीम** को **खोल** सकते हैं:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_ध्यान दें कि आप **पैकेज नाम को छोड़ सकते हैं** और मोबाइल स्वचालित रूप से उस ऐप को कॉल करेगा जो उस लिंक को खोलना चाहिए._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**कोड निष्पादित किया गया**

**ऐप में निष्पादित होने वाले कोड** को खोजने के लिए, उस गतिविधि पर जाएं जिसे डीप लिंक द्वारा कॉल किया गया है और फ़ंक्शन **`onNewIntent`** को खोजें।

![](<../../images/image (436) (1) (1) (1).png>)

**संवेदनशील जानकारी**

हर बार जब आप एक डीप लिंक पाते हैं, तो जांचें कि **यह URL पैरामीटर के माध्यम से संवेदनशील डेटा (जैसे पासवर्ड) प्राप्त नहीं कर रहा है**, क्योंकि कोई अन्य एप्लिकेशन **डीप लिंक का अनुकरण कर सकता है और उस डेटा को चुरा सकता है!**

**पैरामीटर पथ में**

आपको **यह भी जांचना चाहिए कि क्या कोई डीप लिंक URL के पथ के अंदर पैरामीटर का उपयोग कर रहा है** जैसे: `https://api.example.com/v1/users/{username}` , इस मामले में आप पथ यात्रा को मजबूर कर सकते हैं और कुछ इस तरह पहुंच सकते हैं: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
ध्यान दें कि यदि आप एप्लिकेशन के अंदर सही एंडपॉइंट्स पाते हैं, तो आप **Open Redirect** (यदि पथ का एक भाग डोमेन नाम के रूप में उपयोग किया जाता है), **खाता अधिग्रहण** (यदि आप CSRF टोकन के बिना उपयोगकर्ता विवरण को संशोधित कर सकते हैं और कमजोर एंडपॉइंट ने सही विधि का उपयोग किया) और किसी अन्य कमजोरियों का कारण बन सकते हैं। इसके बारे में अधिक [जानकारी यहाँ](http://dphoeniixx.com/2020/12/13-2/) है।

**अधिक उदाहरण**

एक [दिलचस्प बग बाउंटी रिपोर्ट](https://hackerone.com/reports/855618) लिंक के बारे में (_/.well-known/assetlinks.json_)।

### ट्रांसपोर्ट लेयर निरीक्षण और सत्यापन विफलताएँ

- **प्रमाणपत्रों की हमेशा सही तरीके से जांच नहीं की जाती** Android एप्लिकेशनों द्वारा। इन एप्लिकेशनों के लिए चेतावनियों की अनदेखी करना और स्व-हस्ताक्षरित प्रमाणपत्रों को स्वीकार करना या कुछ मामलों में HTTP कनेक्शन का उपयोग करना सामान्य है।
- **SSL/TLS हैंडशेक के दौरान बातचीत कभी-कभी कमजोर होती है**, असुरक्षित सिफर सूट का उपयोग करते हुए। यह कमजोरी कनेक्शन को मैन-इन-द-मिडल (MITM) हमलों के प्रति संवेदनशील बनाती है, जिससे हमलावर डेटा को डिक्रिप्ट कर सकते हैं।
- **निजी जानकारी का लीक होना** एक जोखिम है जब एप्लिकेशन सुरक्षित चैनलों का उपयोग करके प्रमाणीकरण करते हैं लेकिन फिर अन्य लेनदेन के लिए असुरक्षित चैनलों के माध्यम से संचार करते हैं। यह दृष्टिकोण संवेदनशील डेटा, जैसे सत्र कुकीज़ या उपयोगकर्ता विवरण, को दुर्भावनापूर्ण संस्थाओं द्वारा इंटरसेप्शन से बचाने में विफल रहता है।

#### प्रमाणपत्र सत्यापन

हम **प्रमाणपत्र सत्यापन** पर ध्यान केंद्रित करेंगे। सुरक्षा बढ़ाने के लिए सर्वर के प्रमाणपत्र की अखंडता की जांच की जानी चाहिए। यह महत्वपूर्ण है क्योंकि असुरक्षित TLS कॉन्फ़िगरेशन और असुरक्षित चैनलों के माध्यम से संवेदनशील डेटा का संचरण महत्वपूर्ण जोखिम पैदा कर सकता है। सर्वर प्रमाणपत्रों को सत्यापित करने और कमजोरियों को संबोधित करने के लिए विस्तृत चरणों के लिए, [**यह संसाधन**](https://manifestsecurity.com/android-application-security-part-10/) व्यापक मार्गदर्शन प्रदान करता है।

#### SSL पिनिंग

SSL पिनिंग एक सुरक्षा उपाय है जहां एप्लिकेशन सर्वर के प्रमाणपत्र की जांच एक ज्ञात प्रति के खिलाफ करता है जो एप्लिकेशन के भीतर संग्रहीत होती है। यह विधि MITM हमलों को रोकने के लिए आवश्यक है। संवेदनशील जानकारी को संभालने वाले एप्लिकेशनों के लिए SSL पिनिंग को लागू करना अत्यधिक अनुशंसित है।

#### ट्रैफ़िक निरीक्षण

HTTP ट्रैफ़िक का निरीक्षण करने के लिए, **प्रॉक्सी टूल के प्रमाणपत्र को स्थापित करना आवश्यक है** (जैसे, Burp)। इस प्रमाणपत्र को स्थापित किए बिना, एन्क्रिप्टेड ट्रैफ़िक प्रॉक्सी के माध्यम से दिखाई नहीं दे सकता। कस्टम CA प्रमाणपत्र स्थापित करने के लिए एक गाइड के लिए, [**यहाँ क्लिक करें**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine)।

**API स्तर 24 और उससे ऊपर** को लक्षित करने वाले एप्लिकेशनों को प्रॉक्सी के CA प्रमाणपत्र को स्वीकार करने के लिए नेटवर्क सुरक्षा कॉन्फ़िगरेशन में संशोधन की आवश्यकता होती है। एन्क्रिप्टेड ट्रैफ़िक का निरीक्षण करने के लिए यह कदम महत्वपूर्ण है। नेटवर्क सुरक्षा कॉन्फ़िगरेशन को संशोधित करने के लिए निर्देशों के लिए, [**इस ट्यूटोरियल**](make-apk-accept-ca-certificate.md) को देखें।

यदि **Flutter** का उपयोग किया जा रहा है, तो आपको [**इस पृष्ठ**](flutter.md) में दिए गए निर्देशों का पालन करना होगा। इसका कारण यह है कि, केवल स्टोर में प्रमाणपत्र जोड़ने से काम नहीं चलेगा क्योंकि Flutter की अपनी मान्य CAs की सूची है।

#### SSL पिनिंग को बायपास करना

जब SSL पिनिंग लागू होती है, तो HTTPS ट्रैफ़िक का निरीक्षण करने के लिए इसे बायपास करना आवश्यक हो जाता है। इस उद्देश्य के लिए विभिन्न विधियाँ उपलब्ध हैं:

- स्वचालित रूप से **apk को संशोधित करें** ताकि **SSL पिनिंग को बायपास** किया जा सके [**apk-mitm**](https://github.com/shroudedcode/apk-mitm) के साथ। इस विकल्प का सबसे बड़ा लाभ यह है कि आपको SSL पिनिंग को बायपास करने के लिए रूट की आवश्यकता नहीं होगी, लेकिन आपको एप्लिकेशन को हटाना और नए को फिर से स्थापित करना होगा, और यह हमेशा काम नहीं करेगा।
- आप **Frida** का उपयोग कर सकते हैं (नीचे चर्चा की गई) इस सुरक्षा को बायपास करने के लिए। यहाँ Burp+Frida+Genymotion का उपयोग करने के लिए एक गाइड है: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- आप **objection** का उपयोग करके **SSL पिनिंग को स्वचालित रूप से बायपास** करने का प्रयास कर सकते हैं:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- आप **MobSF डायनामिक एनालिसिस** का उपयोग करके **SSL पिनिंग को स्वचालित रूप से बायपास** करने का प्रयास कर सकते हैं (नीचे समझाया गया)
- यदि आप अभी भी सोचते हैं कि कुछ ट्रैफ़िक है जिसे आप कैप्चर नहीं कर रहे हैं, तो आप **iptables का उपयोग करके ट्रैफ़िक को burp पर अग्रेषित करने** का प्रयास कर सकते हैं। इस ब्लॉग को पढ़ें: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### सामान्य वेब कमजोरियों की खोज

यह भी महत्वपूर्ण है कि आप एप्लिकेशन के भीतर सामान्य वेब कमजोरियों की खोज करें। इन कमजोरियों की पहचान और शमन के बारे में विस्तृत जानकारी इस सारांश के दायरे से परे है लेकिन इसे अन्यत्र व्यापक रूप से कवर किया गया है।

### Frida

[Frida](https://www.frida.re) डेवलपर्स, रिवर्स-इंजीनियर्स और सुरक्षा शोधकर्ताओं के लिए एक डायनामिक इंस्ट्रुमेंटेशन टूलकिट है।\
**आप चल रहे एप्लिकेशन तक पहुंच सकते हैं और रन टाइम पर विधियों को हुक कर सकते हैं ताकि व्यवहार को बदल सकें, मान बदल सकें, मान निकाल सकें, विभिन्न कोड चला सकें...**\
यदि आप Android एप्लिकेशनों का परीक्षण करना चाहते हैं, तो आपको Frida का उपयोग करना सीखना होगा।

- Frida का उपयोग कैसे करें: [**Frida ट्यूटोरियल**](frida-tutorial/index.html)
- Frida के साथ क्रियाओं के लिए कुछ "GUI": [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection Frida के उपयोग को स्वचालित करने के लिए शानदार है: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- आप यहाँ कुछ शानदार Frida स्क्रिप्ट्स पा सकते हैं: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- एंटी-डिबगिंग / एंटी-Frida तंत्रों को बायपास करने का प्रयास करें Frida को लोड करके जैसा कि [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) में संकेतित किया गया है (उपकरण [linjector](https://github.com/erfur/linjector-rs))

### **मेमोरी डंप - Fridump**

जांचें कि क्या एप्लिकेशन संवेदनशील जानकारी को मेमोरी में संग्रहीत कर रहा है जिसे इसे संग्रहीत नहीं करना चाहिए जैसे पासवर्ड या म्नेमोनिक्स।

[**Fridump3**](https://github.com/rootbsd/fridump3) का उपयोग करके आप ऐप की मेमोरी को डंप कर सकते हैं:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
यह ./dump फ़ोल्डर में मेमोरी को डंप करेगा, और वहाँ आप कुछ इस तरह grep कर सकते हैं:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Keystore में संवेदनशील डेटा**

Android में Keystore संवेदनशील डेटा संग्रहीत करने के लिए सबसे अच्छा स्थान है, हालाँकि, पर्याप्त विशेषाधिकारों के साथ इसे **एक्सेस करना संभव है**। चूंकि एप्लिकेशन यहाँ **स्पष्ट पाठ में संवेदनशील डेटा** संग्रहीत करने की प्रवृत्ति रखते हैं, इसलिए पेंटेस्ट को इसे रूट उपयोगकर्ता के रूप में जांचना चाहिए या किसी ऐसे व्यक्ति के साथ जो डिवाइस तक भौतिक पहुंच रखता हो, यह डेटा चुराने में सक्षम हो सकता है।

यहां तक कि यदि एक ऐप ने keystore में डेटा संग्रहीत किया है, तो डेटा को एन्क्रिप्ट किया जाना चाहिए।

Keystore के अंदर डेटा तक पहुँचने के लिए आप इस Frida स्क्रिप्ट का उपयोग कर सकते हैं: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

निम्नलिखित Frida स्क्रिप्ट का उपयोग करके यह संभव हो सकता है कि **फिंगरप्रिंट प्रमाणीकरण** को बायपास किया जा सके जो Android अनुप्रयोगों द्वारा कुछ संवेदनशील क्षेत्रों की **सुरक्षा** के लिए किया जा रहा है:
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **पृष्ठभूमि छवियाँ**

जब आप एक एप्लिकेशन को पृष्ठभूमि में डालते हैं, तो Android **एप्लिकेशन का एक स्नैपशॉट** स्टोर करता है ताकि जब इसे अग्रभूमि में पुनर्प्राप्त किया जाए, तो यह एप्लिकेशन से पहले छवि लोड करना शुरू कर दे, जिससे ऐसा लगता है कि एप्लिकेशन तेजी से लोड हुआ है।

हालांकि, यदि इस स्नैपशॉट में **संवेदनशील जानकारी** होती है, तो स्नैपशॉट तक पहुँच रखने वाला कोई भी व्यक्ति उस जानकारी को **चुरा सकता है** (ध्यान दें कि इसे एक्सेस करने के लिए आपको रूट की आवश्यकता है)।

स्नैपशॉट आमतौर पर यहाँ स्टोर होते हैं: **`/data/system_ce/0/snapshots`**

Android **FLAG_SECURE** लेआउट पैरामीटर सेट करके स्क्रीनशॉट कैप्चर को **रोकने** का एक तरीका प्रदान करता है। इस फ्लैग का उपयोग करके, विंडो की सामग्री को सुरक्षित माना जाता है, जिससे यह स्क्रीनशॉट में दिखाई नहीं देती या असुरक्षित डिस्प्ले पर नहीं देखी जा सकती।
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

यह उपकरण आपको गतिशील विश्लेषण के दौरान विभिन्न उपकरणों का प्रबंधन करने में मदद कर सकता है: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

डेवलपर्स अक्सर प्रॉक्सी घटक जैसे गतिविधियाँ, सेवाएँ, और प्रसारण रिसीवर बनाते हैं जो इन Intents को संभालते हैं और उन्हें `startActivity(...)` या `sendBroadcast(...)` जैसे तरीकों में पास करते हैं, जो जोखिम भरा हो सकता है।

खतरा इस बात में है कि हमलावरों को गैर-निर्यातित ऐप घटकों को ट्रिगर करने या संवेदनशील सामग्री प्रदाताओं तक पहुँचने की अनुमति दी जा रही है, इन Intents को गलत दिशा में भेजकर। एक उल्लेखनीय उदाहरण `WebView` घटक है जो URLs को `Intent` वस्तुओं में `Intent.parseUri(...)` के माध्यम से परिवर्तित करता है और फिर उन्हें निष्पादित करता है, जो संभावित रूप से दुर्भावनापूर्ण Intent इंजेक्शन की ओर ले जा सकता है।

### Essential Takeaways

- **Intent Injection** वेब के Open Redirect समस्या के समान है।
- शोषण में `Intent` वस्तुओं को अतिरिक्त के रूप में पास करना शामिल है, जिन्हें असुरक्षित संचालन निष्पादित करने के लिए पुनर्निर्देशित किया जा सकता है।
- यह गैर-निर्यातित घटकों और सामग्री प्रदाताओं को हमलावरों के लिए उजागर कर सकता है।
- `WebView` का URL से `Intent` में रूपांतरण अनपेक्षित क्रियाओं को सुविधाजनक बना सकता है।

### Android Client Side Injections and others

संभवतः आप वेब से इस प्रकार की कमजोरियों के बारे में जानते हैं। आपको Android एप्लिकेशन में इन कमजोरियों के प्रति विशेष रूप से सतर्क रहना चाहिए:

- **SQL Injection:** गतिशील प्रश्नों या सामग्री-प्रदाताओं के साथ काम करते समय सुनिश्चित करें कि आप पैरामीटरयुक्त प्रश्नों का उपयोग कर रहे हैं।
- **JavaScript Injection (XSS):** सुनिश्चित करें कि किसी भी WebViews के लिए JavaScript और प्लगइन समर्थन बंद है (डिफ़ॉल्ट रूप से बंद)। [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews को फ़ाइल प्रणाली तक पहुँच बंद होनी चाहिए (डिफ़ॉल्ट रूप से सक्षम) - `(webview.getSettings().setAllowFileAccess(false);)`। [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: कई मामलों में जब Android एप्लिकेशन सत्र समाप्त करता है, तो कुकी को रद्द नहीं किया जाता है या इसे डिस्क पर भी सहेजा जा सकता है।
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Static analysis**

![](<../../images/image (866).png>)

**Vulnerability assessment of the application** एक अच्छे वेब-आधारित फ्रंटेंड का उपयोग करके। आप गतिशील विश्लेषण भी कर सकते हैं (लेकिन आपको वातावरण तैयार करने की आवश्यकता है)।
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
ध्यान दें कि MobSF **Android**(apk)**, IOS**(ipa) **और Windows**(apx) अनुप्रयोगों का विश्लेषण कर सकता है (_Windows अनुप्रयोगों का विश्लेषण Windows होस्ट में स्थापित MobSF से किया जाना चाहिए_)।\
इसके अलावा, यदि आप एक **ZIP** फ़ाइल बनाते हैं जिसमें एक **Android** या **IOS** ऐप का स्रोत कोड होता है (अनुप्रयोग के रूट फ़ोल्डर पर जाएं, सब कुछ चुनें और एक ZIP फ़ाइल बनाएं), तो यह इसका विश्लेषण भी कर सकेगा।

MobSF आपको **diff/Compare** विश्लेषण करने और **VirusTotal** को एकीकृत करने की अनुमति भी देता है (आपको _MobSF/settings.py_ में अपना API कुंजी सेट करने की आवश्यकता होगी और इसे सक्षम करना होगा: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`)। आप `VT_UPLOAD` को `False` पर भी सेट कर सकते हैं, तब **hash** फ़ाइल के बजाय **upload** किया जाएगा।

### MobSF के साथ सहायक गतिशील विश्लेषण

**MobSF** **Android** में **गतिशील विश्लेषण** के लिए भी बहुत सहायक हो सकता है, लेकिन इस मामले में आपको अपने होस्ट में MobSF और **genymotion** स्थापित करने की आवश्यकता होगी (एक VM या Docker काम नहीं करेगा)। _नोट: आपको **पहले genymotion में एक VM शुरू करना होगा** और **फिर MobSF।**_\
**MobSF गतिशील विश्लेषक** कर सकता है:

- **अनुप्रयोग डेटा डंप करें** (URLs, लॉग, क्लिपबोर्ड, आपके द्वारा बनाए गए स्क्रीनशॉट, "**Exported Activity Tester**" द्वारा बनाए गए स्क्रीनशॉट, ईमेल, SQLite डेटाबेस, XML फ़ाइलें, और अन्य बनाई गई फ़ाइलें)। इनमें से सभी स्वचालित रूप से किया जाता है सिवाय स्क्रीनशॉट के, आपको तब दबाना होगा जब आप एक स्क्रीनशॉट चाहते हैं या आपको सभी निर्यातित गतिविधियों के स्क्रीनशॉट प्राप्त करने के लिए "**Exported Activity Tester**" पर दबाना होगा।
- **HTTPS ट्रैफ़िक कैप्चर करें**
- **Frida** का उपयोग करके **runtime** **जानकारी** प्राप्त करें

Android **संस्करण > 5** से, यह **स्वचालित रूप से Frida शुरू करेगा** और **ट्रैफ़िक कैप्चर** करने के लिए वैश्विक **proxy** सेटिंग्स सेट करेगा। यह केवल परीक्षण किए गए अनुप्रयोग से ट्रैफ़िक कैप्चर करेगा।

**Frida**

डिफ़ॉल्ट रूप से, यह **SSL पिनिंग**, **रूट डिटेक्शन** और **डीबगर डिटेक्शन** को **बायपास** करने और **दिलचस्प APIs** की निगरानी करने के लिए कुछ Frida स्क्रिप्ट का भी उपयोग करेगा।\
MobSF **निर्यातित गतिविधियों** को **invoke** कर सकता है, उनके **स्क्रीनशॉट** ले सकता है और उन्हें रिपोर्ट के लिए **सहेज** सकता है।

गतिशील परीक्षण **शुरू** करने के लिए हरे बटन पर दबाएं: "**Start Instrumentation**"। Frida स्क्रिप्ट द्वारा उत्पन्न लॉग देखने के लिए "**Frida Live Logs**" पर दबाएं और सभी हुक किए गए तरीकों, पास किए गए तर्कों और लौटाए गए मानों के आवाहनों को देखने के लिए "**Live API Monitor**" पर दबाएं (यह "Start Instrumentation" दबाने के बाद दिखाई देगा)।\
MobSF आपको अपने स्वयं के **Frida स्क्रिप्ट** लोड करने की भी अनुमति देता है (अपने शुक्रवार स्क्रिप्ट के परिणाम MobSF को भेजने के लिए `send()` फ़ंक्शन का उपयोग करें)। इसमें **कई पूर्व-लिखित स्क्रिप्ट** भी हैं जिन्हें आप लोड कर सकते हैं (आप `MobSF/DynamicAnalyzer/tools/frida_scripts/others/` में और अधिक जोड़ सकते हैं), बस **उन्हें चुनें**, "**Load**" पर दबाएं और "**Start Instrumentation**" पर दबाएं (आप उस स्क्रिप्ट के लॉग "**Frida Live Logs**" के अंदर देख सकेंगे)।

![](<../../images/image (419).png>)

इसके अलावा, आपके पास कुछ सहायक Frida कार्यक्षमताएँ हैं:

- **लोड की गई कक्षाओं की गणना करें**: यह सभी लोड की गई कक्षाओं को प्रिंट करेगा
- **स्ट्रिंग कैप्चर करें**: यह अनुप्रयोग का उपयोग करते समय सभी कैप्चर की गई स्ट्रिंग्स को प्रिंट करेगा (बहुत शोर)
- **स्ट्रिंग तुलना कैप्चर करें**: यह बहुत उपयोगी हो सकता है। यह **2 स्ट्रिंग्स को दिखाएगा जो तुलना की जा रही हैं** और यदि परिणाम सत्य या असत्य था।
- **कक्षा विधियों की गणना करें**: कक्षा का नाम डालें (जैसे "java.io.File") और यह कक्षा की सभी विधियों को प्रिंट करेगा।
- **कक्षा पैटर्न खोजें**: पैटर्न द्वारा कक्षाओं की खोज करें
- **कक्षा विधियों को ट्रेस करें**: **पूरी कक्षा को ट्रेस करें** (कक्षा की सभी विधियों के इनपुट और आउटपुट देखें)। याद रखें कि डिफ़ॉल्ट रूप से MobSF कई दिलचस्प Android API विधियों को ट्रेस करता है।

एक बार जब आप सहायक मॉड्यूल का चयन कर लेते हैं जिसे आप उपयोग करना चाहते हैं, तो आपको "**Start Intrumentation**" पर दबाना होगा और आप सभी आउटपुट "**Frida Live Logs**" में देखेंगे।

**Shell**

Mobsf आपको गतिशील विश्लेषण पृष्ठ के नीचे कुछ **adb** कमांड, **MobSF कमांड**, और सामान्य **shell** **commands** के साथ एक शेल भी लाता है। कुछ दिलचस्प कमांड:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP tools**

जब http ट्रैफ़िक कैप्चर किया जाता है, तो आप "**HTTP(S) Traffic**" नीचे कैप्चर किए गए ट्रैफ़िक का एक खराब दृश्य देख सकते हैं या "**Start HTTPTools**" हरे बटन में एक बेहतर दृश्य देख सकते हैं। दूसरे विकल्प से, आप **captured requests** को **proxies** जैसे Burp या Owasp ZAP को **send** कर सकते हैं।\
इसके लिए, _Burp चालू करें -->_ _Intercept बंद करें --> MobSB HTTPTools में अनुरोध चुनें_ --> "**Send to Fuzzer**" दबाएं --> _proxy पता चुनें_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080))।

एक बार जब आप MobSF के साथ डायनामिक विश्लेषण समाप्त कर लेते हैं, तो आप "**Start Web API Fuzzer**" पर क्लिक कर सकते हैं ताकि **http requests** को **fuzz** किया जा सके और कमजोरियों की तलाश की जा सके।

> [!TIP]
> MobSF के साथ डायनामिक विश्लेषण करने के बाद, प्रॉक्सी सेटिंग्स गलत हो सकती हैं और आप उन्हें GUI से ठीक नहीं कर पाएंगे। आप निम्नलिखित करके प्रॉक्सी सेटिंग्स को ठीक कर सकते हैं:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

आप [**Inspeckage**](https://github.com/ac-pm/Inspeckage) से टूल प्राप्त कर सकते हैं।\
यह टूल कुछ **Hooks** का उपयोग करेगा ताकि आपको पता चल सके **क्या हो रहा है एप्लिकेशन में** जब आप **dynamic analysis** करते हैं।

### [Yaazhini](https://www.vegabird.com/yaazhini/)

यह एक **शानदार टूल है जो GUI के साथ स्थिर विश्लेषण करने के लिए है**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

यह टूल कई **सुरक्षा संबंधित Android एप्लिकेशन कमजोरियों** की तलाश करने के लिए डिज़ाइन किया गया है, चाहे वह **source code** में हो या **packaged APKs** में। यह टूल कुछ पाए गए कमजोरियों (Exposed activities, intents, tapjacking...) का शोषण करने के लिए एक "Proof-of-Concept" डिप्लॉय करने योग्य APK और **ADB commands** बनाने में भी **सक्षम** है। Drozer की तरह, परीक्षण डिवाइस को रूट करने की आवश्यकता नहीं है।
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- सभी निकाले गए फ़ाइलों को आसान संदर्भ के लिए प्रदर्शित करता है
- APK फ़ाइलों को स्वचालित रूप से Java और Smali प्रारूप में डिकंपाइल करता है
- सामान्य कमजोरियों और व्यवहार के लिए AndroidManifest.xml का विश्लेषण करें
- सामान्य कमजोरियों और व्यवहार के लिए स्थैतिक स्रोत कोड विश्लेषण
- डिवाइस जानकारी
- और अधिक
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER एक कमांड-लाइन एप्लिकेशन है जिसे Windows, MacOS X और Linux में उपयोग किया जा सकता है, जो _.apk_ फ़ाइलों का विश्लेषण करता है ताकि कमजोरियों की खोज की जा सके। यह APKs को डिकंप्रेस करके और उन कमजोरियों का पता लगाने के लिए नियमों की एक श्रृंखला लागू करके ऐसा करता है।

सभी नियम `rules.json` फ़ाइल में केंद्रित होते हैं, और प्रत्येक कंपनी या परीक्षक अपने आवश्यकताओं के अनुसार विश्लेषण करने के लिए अपने नियम बना सकते हैं।

नवीनतम बाइनरी [डाउनलोड पृष्ठ](https://superanalyzer.rocks/download.html) से डाउनलोड करें।
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn एक **क्रॉसप्लेटफ़ॉर्म** उपकरण है जो डेवलपर्स, बग बाउंटी शिकारियों और नैतिक हैकरों को मोबाइल अनुप्रयोगों पर [स्टैटिक कोड विश्लेषण](https://en.wikipedia.org/wiki/Static_program_analysis) करने में मदद करता है।

इसका सिद्धांत यह है कि आप अपने मोबाइल अनुप्रयोग फ़ाइल (एक .apk या .ipa फ़ाइल) को StaCoAn अनुप्रयोग पर खींचते और छोड़ते हैं और यह आपके लिए एक दृश्य और पोर्टेबल रिपोर्ट उत्पन्न करेगा। आप सेटिंग्स और वर्डलिस्ट को अनुकूलित अनुभव प्राप्त करने के लिए समायोजित कर सकते हैं।

डाउनलोड[ नवीनतम रिलीज़](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework एक Android कमजोरियों का विश्लेषण प्रणाली है जो डेवलपर्स या हैकर्स को Android अनुप्रयोगों में संभावित सुरक्षा कमजोरियों को खोजने में मदद करती है।\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** एक उपकरण है जिसका मुख्य उद्देश्य Android एप्लिकेशन द्वारा विकसित संभावित दुर्भावनापूर्ण व्यवहारों का पता लगाना और उपयोगकर्ता को चेतावनी देना है।

पता लगाने की प्रक्रिया एप्लिकेशन के Dalvik बाइटकोड का **स्थैतिक विश्लेषण** करके की जाती है, जिसे **Smali** के रूप में दर्शाया गया है, [`androguard`](https://github.com/androguard/androguard) पुस्तकालय के साथ।

यह उपकरण **"खराब" एप्लिकेशनों के सामान्य व्यवहार** की तलाश करता है जैसे: टेलीफोनी पहचानकर्ताओं का निष्कासन, ऑडियो/वीडियो प्रवाह का अवरोधन, PIM डेटा में संशोधन, मनमाना कोड निष्पादन...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** एक **M**ोबाइल **A**प्लिकेशन **R**िवर्स इंजीनियरिंग और **A**नालिसिस फ्रेमवर्क है। यह एक उपकरण है जो सामान्यतः उपयोग किए जाने वाले मोबाइल एप्लिकेशन रिवर्स इंजीनियरिंग और विश्लेषण उपकरणों को एक साथ लाता है, ताकि OWASP मोबाइल सुरक्षा खतरों के खिलाफ मोबाइल एप्लिकेशनों का परीक्षण करने में सहायता मिल सके। इसका उद्देश्य इस कार्य को मोबाइल एप्लिकेशन डेवलपर्स और सुरक्षा पेशेवरों के लिए आसान और मित्रवत बनाना है।

यह सक्षम है:

- विभिन्न उपकरणों का उपयोग करके Java और Smali कोड निकालना
- [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD) का उपयोग करके APKs का विश्लेषण करना
- regexps का उपयोग करके APK से निजी जानकारी निकालना।
- मैनिफेस्ट का विश्लेषण करना।
- [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) और [whatweb](https://github.com/urbanadventurer/WhatWeb) का उपयोग करके पाए गए डोमेन का विश्लेषण करना
- [apk-deguard.com](http://www.apk-deguard.com) के माध्यम से APK को डिओबफस्केट करना

### Koodous

मैलवेयर का पता लगाने के लिए उपयोगी: [https://koodous.com/](https://koodous.com)

## कोड को ओबफस्केटिंग/डिओबफस्केटिंग करना

ध्यान दें कि जिस सेवा और कॉन्फ़िगरेशन का आप उपयोग करते हैं, उसके आधार पर कोड को ओबफस्केट करने के लिए। रहस्य ओबफस्केटेड हो सकते हैं या नहीं।

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

[विकिपीडिया](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** एक ओपन-सोर्स कमांड-लाइन उपकरण है जो Java कोड को संकुचित, अनुकूलित और ओबफस्केट करता है। यह बाइटकोड को अनुकूलित करने के साथ-साथ अप्रयुक्त निर्देशों का पता लगाने और उन्हें हटाने में सक्षम है। ProGuard मुफ्त सॉफ़्टवेयर है और इसे GNU जनरल पब्लिक लाइसेंस, संस्करण 2 के तहत वितरित किया जाता है।

ProGuard Android SDK का एक हिस्सा है और रिलीज़ मोड में एप्लिकेशन बनाने पर चलता है।

### [DexGuard](https://www.guardsquare.com/dexguard)

APK को डिओबफस्केट करने के लिए चरण-दर-चरण गाइड [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html) में खोजें

(उस गाइड से) आखिरी बार जब हमने जांचा, Dexguard का संचालन मोड था:

- एक संसाधन को InputStream के रूप में लोड करें;
- इसे डिक्रिप्ट करने के लिए FilterInputStream से विरासत में मिली एक क्लास को परिणाम दें;
- एक रिवर्सर के समय को बर्बाद करने के लिए कुछ बेकार ओबफस्केशन करें;
- DEX फ़ाइल प्राप्त करने के लिए डिक्रिप्टेड परिणाम को ZipInputStream में दें;
- अंततः `loadDex` विधि का उपयोग करके परिणामस्वरूप DEX को एक संसाधन के रूप में लोड करें।

### [DeGuard](http://apk-deguard.com)

**DeGuard Android ओबफस्केशन उपकरणों द्वारा किए गए ओबफस्केशन की प्रक्रिया को उलटता है। यह कोड निरीक्षण और पुस्तकालयों की भविष्यवाणी सहित कई सुरक्षा विश्लेषणों को सक्षम बनाता है।**

आप उनके प्लेटफॉर्म पर एक ओबफस्केटेड APK अपलोड कर सकते हैं।

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

यह एक LLM उपकरण है जो Android ऐप्स में किसी भी संभावित सुरक्षा कमजोरियों को खोजने और Android ऐप कोड को डिओबफस्केट करने के लिए है। Google के Gemini सार्वजनिक API का उपयोग करता है।

### [Simplify](https://github.com/CalebFenton/simplify)

यह एक **सामान्य Android डिओबफस्केटर है।** Simplify **वास्तव में एक ऐप को निष्पादित करता है** ताकि इसके व्यवहार को समझा जा सके और फिर **कोड को अनुकूलित करने की कोशिश करता है** ताकि यह समान रूप से व्यवहार करे लेकिन मानव के लिए समझना आसान हो। प्रत्येक अनुकूलन प्रकार सरल और सामान्य है, इसलिए यह मायने नहीं रखता कि ओबफस्केशन का विशिष्ट प्रकार क्या है।

### [APKiD](https://github.com/rednaga/APKiD)

APKiD आपको **यह जानकारी देता है कि एक APK कैसे बनाया गया था**। यह कई **कंपाइलर्स**, **पैकर**, **ओबफस्केटर्स**, और अन्य अजीब चीजों की पहचान करता है। यह Android के लिए [_PEiD_](https://www.aldeid.com/wiki/PEiD) है।

### मैनुअल

[कस्टम ओबफस्केशन को रिवर्स करने के कुछ ट्रिक्स सीखने के लिए इस ट्यूटोरियल को पढ़ें](manual-deobfuscation.md)

## प्रयोगशालाएँ

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b एक Android सुरक्षा वर्चुअल मशीन है जो ubuntu-mate पर आधारित है, जिसमें रिवर्स इंजीनियरिंग और मैलवेयर विश्लेषण के लिए विभिन्न सुरक्षा विशेषज्ञों और शोधकर्ताओं से नवीनतम फ्रेमवर्क, ट्यूटोरियल और प्रयोगशालाओं का संग्रह शामिल है।

## संदर्भ

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) यह संसाधनों की एक शानदार सूची है
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android त्वरित पाठ्यक्रम
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)

## अभी आजमाना बाकी है

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
