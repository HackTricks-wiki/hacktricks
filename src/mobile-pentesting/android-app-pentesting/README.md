# Pentesting Android-застосунків

{{#include ../../banners/hacktricks-training.md}}

## Основи Android-застосунків

Рекомендується почати з прочитання цієї сторінки, щоб дізнатися про **найважливіші частини, пов'язані з безпекою Android, та найбільш небезпечні компоненти в Android-застосунку**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Це основний інструмент, який потрібен для підключення до Android-пристрою (емулятор чи фізичний).\
**ADB** дозволяє керувати пристроями через **USB** або **Network** з комп'ютера. Ця утиліта дає змогу **копіювати** файли в обох напрямках, **встановлювати** та **видаляти** додатки, **виконувати** shell-команди, **робити резервні копії** даних, **читати** логи та виконувати інші функції.

Перегляньте наступний список [**ADB Commands**](adb-commands.md), щоб дізнатися, як користуватися adb.

## Smali

Іноді цікаво **змінити код додатка**, щоб отримати доступ до **прихованої інформації** (наприклад, добре обфусцованих паролів або флагів). Тоді може бути корисно декомпілювати apk, змінити код і перекомпілювати його.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Це може бути дуже корисно як **альтернатива для кількох тестів під час динамічного аналізу**, які будуть представлені. Отже, **завжди пам'ятайте про цю можливість**.

## Інші цікаві трюки

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Витягти APK з пристрою:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Об'єднайте всі splits та base apks за допомогою [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Кейси та вразливості


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Статичний аналіз

Перш за все, для аналізу APK слід **подивитися на Java code** за допомогою decompiler.\
Please, [**read here to find information about different available decompilers**](apk-decompilers.md).

### Пошук цікавої інформації

Просто переглянувши **strings** APK, можна шукати **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** та все, що цікаве... перевіряйте навіть на наявність code execution **backdoors** або authentication backdoors (hardcoded admin credentials до додатку).

**Firebase**

Зверніть особливу увагу на **firebase URLs** та перевірте, чи не налаштовано його неправильно. [More information about whats is FIrebase and how to exploit it here.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Базове розуміння застосунку - Manifest.xml, strings.xml

The **examination of an application's _Manifest.xml_ and **_strings.xml_** files can reveal potential security vulnerabilities**. Ці файли можна отримати за допомогою decompilers або перейменувавши розширення файлу APK на .zip і розпакувавши його.

**Вразливості**, виявлені у **Manifest.xml**, включають:

- **Debuggable Applications**: Applications, встановлені як debuggable (`debuggable="true"`) у файлі _Manifest.xml_ становлять ризик, оскільки дозволяють з'єднання, що можуть призвести до експлуатації. Для детальнішого розуміння того, як експлуатувати debuggable applications, зверніться до tutorial про пошук і експлуатацію debuggable applications на пристрої.
- **Backup Settings**: Атрибут `android:allowBackup="false"` має бути явно встановлений для додатків, що працюють з чутливою інформацією, щоб запобігти несанкціонованому резервному копіюванню даних через adb, особливо коли usb debugging увімкнено.
- **Network Security**: Custom network security configurations (`android:networkSecurityConfig="@xml/network_security_config"`) у _res/xml/_ можуть вказувати деталі безпеки, такі як certificate pins і налаштування HTTP-трафіку. Наприклад, можна дозволити HTTP-трафік для певних доменів.
- **Exported Activities and Services**: Виявлення exported activities and services у manifest може вказати на компоненти, якими можуть зловживати. Подальший аналіз під час dynamic testing може показати, як експлуатувати ці компоненти.
- **Content Providers and FileProviders**: Відкриті content providers можуть дозволити несанкціонований доступ або зміну даних. Конфігурацію FileProviders також слід ретельно перевіряти.
- **Broadcast Receivers and URL Schemes**: Ці компоненти можуть бути використані для експлуатації, з особливою увагою до того, як URL schemes обробляються для можливих векторів введення.
- **SDK Versions**: Атрибути `minSdkVersion`, `targetSDKVersion` і `maxSdkVersion` вказують на підтримувані версії Android, наголошуючи на важливості уникнення підтримки застарілих, вразливих версій Android з міркувань безпеки.

З файлу **strings.xml** можна знайти чутливу інформацію, таку як API keys, custom schemas та інші developer notes, що підкреслює необхідність ретельного перегляду цих ресурсів.

### Tapjacking

**Tapjacking** — це атака, коли **malicious application** запускається і розташовується поверх victim application. Коли воно візуально закриває victim app, його інтерфейс користувача спроектований так, щоб обманути користувача взаємодіяти з ним, водночас передаючи взаємодію жертві.\
Фактично, це **осліплює користувача, не даючи йому знати, що він насправді виконує дії у victim app**.

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Activity з `launchMode`, встановленим у `singleTask` без визначеного `taskAffinity`, вразлива до Task Hijacking. Це означає, що зловмисний **application** може бути встановлений і, якщо запущений перед реальним додатком, може **hijack the task** реального додатка (тому користувач взаємодіятиме з **malicious application**, думаючи, що використовує справжній).

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Insecure data storage

**Internal Storage**

В Android файли, що зберігаються у internal storage, призначені бути доступними виключно для app, який їх створив. Цей захід безпеки застосовується операційною системою Android і зазвичай є достатнім для потреб безпеки більшості застосунків. Проте розробники іноді використовують режими, такі як `MODE_WORLD_READABLE` і `MODE_WORLD_WRITABLE`, щоб дозволити sharing файлів між різними applications. Однак ці режими **не обмежують доступ** до цих файлів іншими applications, включно з потенційно malicious ones.

1. **Static Analysis:**
- **Ensure** що використання `MODE_WORLD_READABLE` і `MODE_WORLD_WRITABLE` **ретельно перевіряється**. Ці режими **можуть потенційно розкрити** файли для **непередбаченого або несанкціонованого доступу**.
2. **Dynamic Analysis:**
- **Verify** права доступу, встановлені на файлах, створених додатком. Зокрема, **перевіряйте**, чи будь-які файли **встановлені як readable або writable worldwide**. Це може становити значний ризик безпеки, оскільки дозволить **будь-якому application**, встановленому на пристрої, незалежно від його походження чи намірів, **читати або змінювати** ці файли.

**External Storage**

При роботі з файлами на external storage, такими як SD Cards, слід врахувати певні заходи безпеки:

1. **Accessibility**:
- Файли на external storage є **глобально читаними і записуваними**. Це означає, що будь-який application або користувач може отримати до них доступ.
2. **Security Concerns**:
- Через легкість доступу не радиться зберігати чутливу інформацію на external storage.
- External storage може бути вилучено або доступне будь-якому application, що робить його менш захищеним.
3. **Handling Data from External Storage**:
- Завжди **виконуйте валідацію введення** для даних, отриманих з external storage. Це критично важливо, оскільки дані надходять з недовіреного джерела.
- Не рекомендується зберігати виконувані файли або class files на external storage для динамічного завантаження.
- Якщо ваш додаток має отримувати виконувані файли з external storage, переконайтеся, що ці файли **підписані і криптографічно перевірені** перед їх динамічним завантаженням. Цей крок є вирішальним для підтримки цілісності безпеки вашого додатку.

External storage можна **доступитися** в `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> Починаючи з Android 4.4 (**API 17**), SD card має структуру директорій, яка **обмежує доступ додатку лише до директорії, яка призначена спеціально для цього додатку**. Це перешкоджає malicious application отримати доступ для читання або запису до файлів іншого додатку.

**Чутливі дані, збережені у відкритому тексті**

- **Shared preferences**: Android дозволяє кожному application легко зберігати xml-файли за шляхом `/data/data/<packagename>/shared_prefs/` і іноді в цій папці можна знайти чутливу інформацію у clear-text.
- **Databases**: Android дозволяє кожному application легко зберігати sqlite databases за шляхом `/data/data/<packagename>/databases/` і іноді в цій папці можна знайти чутливу інформацію у clear-text.

### Broken TLS

**Accept All Certificates**

З якоїсь причини іноді розробники приймають всі certificates навіть якщо, наприклад, hostname не збігається, з рядками коду, подібними до наступного:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Ненадійна криптографія

**Погані процеси управління ключами**

Деякі розробники зберігають чутливі дані в локальному сховищі і шифрують їх ключем, вбудованим/передбачуваним у коді. Так робити не слід, оскільки при зворотній інженерії атакуючі можуть витягти конфіденційну інформацію.

**Використання небезпечних та/або застарілих алгоритмів**

Розробники не повинні використовувати **deprecated algorithms** для виконання перевірок авторизації, зберігання або відправлення даних. Деякі з цих алгоритмів: RC4, MD4, MD5, SHA1... Якщо, наприклад, для зберігання паролів використовуються **хеші**, слід застосовувати хеші, стійкі до брутфорсу, з використанням salt.

### Інші перевірки

- Рекомендується **обфускувати APK**, щоб ускладнити роботу реверс-інженерам/атакуючим.
- Якщо додаток чутливий (наприклад банківські додатки), він повинен виконувати власні перевірки, щоб визначити, чи пристрій є **rooted**, і діяти відповідно.
- Якщо додаток чутливий (наприклад банківські додатки), він повинен перевіряти, чи використовується **emulator**.
- Якщо додаток чутливий (наприклад банківські додатки), він повинен **перевіряти власну цілісність перед виконанням**, щоб з'ясувати, чи його було змінено.
- Use [**APKiD**](https://github.com/rednaga/APKiD) to check which compiler/packer/obfuscator was used to build the APK

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

The tool [**mariana-trench**](https://github.com/facebook/mariana-trench) is capable of finding **vulnerabilities** by **scanning** the **code** of the application. This tool contains a series of **known sources** (that indicates to the tool the **places** where the **input** is **controlled by the user**), **sinks** (which indicates to the tool **dangerous** **places** where malicious user input could cause damages) and **rules**. These rules indicates the **combination** of **sources-sinks** that indicates a vulnerability.

With this knowledge, **mariana-trench will review the code and find possible vulnerabilities on it**.

### Secrets leaked

An application may contain secrets (API keys, passwords, hidden urls, subdomains...) inside of it that you might be able to discover. You could us a tool such as [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Динамічний аналіз

> First of all, you need an environment where you can install the application and all the environment (Burp CA cert, Drozer and Frida mainly). Therefore, a rooted device (emulated or not) is extremely recommended.

### Онлайн динамічний аналіз

You can create a **free account** in: [https://appetize.io/](https://appetize.io). This platform allows you to **upload** and **execute** APKs, so it is useful to see how an apk is behaving.

You can even **see the logs of your application** in the web and connect through **adb**.

![](<../../images/image (831).png>)

Thanks to the ADB connection you can use **Drozer** and **Frida** inside the emulators.

### Локальний динамічний аналіз

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (You can create **x86** and **arm** devices, and according to [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** versions **support ARM libraries** without needing an slow arm emulator).
- Learn to set it up in this page:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, you need to create an account. _It's recommend to **download** the version **WITH**_ _**VirtualBox** to avoid potential errors._)
- [**Nox**](https://es.bignox.com) (Free, but it doesn't support Frida or Drozer).

> [!TIP]
> When creating a new emulator on any platform remember that the bigger the screen is, the slower the emulator will run. So select small screens if possible.

To **install google services** (like AppStore) in Genymotion you need to click on the red marked button of the following image:

![](<../../images/image (277).png>)

Also, notice that in the **configuration of the Android VM in Genymotion** you can select **Bridge Network mode** (this will be useful if you will be connecting to the Android VM from a different VM with the tools).

#### Use a physical device

You need to activate the **debugging** options and it will be cool if you can **root** it:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Once you have installed the application, the first thing you should do is to try it and investigate what does it do, how does it work and get comfortable with it.\
> I will suggest to **perform this initial dynamic analysis using MobSF dynamic analysis + pidcat**, so we will be able to **learn how the application works** while MobSF **captures** a lot of **interesting** **data** you can review later on.

### Unintended Data Leakage

**Logging**

Developers should be cautious of exposing **debugging information** publicly, as it can lead to sensitive data leaks. The tools [**pidcat**](https://github.com/JakeWharton/pidcat) and `adb logcat` are recommended for monitoring application logs to identify and protect sensitive information. **Pidcat** is favored for its ease of use and readability.

> [!WARNING]
> Note that from **later newer than Android 4.0**, **applications are only able to access their own logs**. So applications cannot access other apps logs.\
> Anyway, it's still recommended to **not log sensitive information**.

**Copy/Paste Buffer Caching**

Android's **clipboard-based** framework enables copy-paste functionality in apps, yet poses a risk as **other applications** can **access** the clipboard, potentially exposing sensitive data. It's crucial to **disable copy/paste** functions for sensitive sections of an application, like credit card details, to prevent data leaks.

**Crash Logs**

If an application **crashes** and **saves logs**, these logs can assist attackers, particularly when the application cannot be reverse-engineered. To mitigate this risk, avoid logging on crashes, and if logs must be transmitted over the network, ensure they are sent via an SSL channel for security.

As pentester, **try to take a look to these logs**.

**Analytics Data Sent To 3rd Parties**

Applications often integrate services like Google Adsense, which can inadvertently **leak sensitive data** due to improper implementation by developers. To identify potential data leaks, it's advisable to **intercept the application's traffic** and check for any sensitive information being sent to third-party services.

### SQLite DBs

Most of the applications will use **internal SQLite databases** to save information. During the pentest take a **look** to the **databases** created, the names of **tables** and **columns** and all the **data** saved because you could find **sensitive information** (which would be a vulnerability).\
Databases should be located in `/data/data/the.package.name/databases` like `/data/data/com.mwr.example.sieve/databases`

If the database is saving confidential information and is **encrypted b**ut you can **find** the **password** inside the application it's still a **vulnerability**.

Enumerate the tables using `.tables` and enumerate the columns of the tables doing `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer is s useful tool to **exploit exported activities, exported services and Content Providers** as you will learn in the following sections.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Also remember that the code of an activity starts in the **`onCreate`** method.

**Authorisation bypass**

When an Activity is exported you can invoke its screen from an external app. Therefore, if an activity with **sensitive information** is **exported** you could **bypass** the **authentication** mechanisms **to access it.**

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

You can also start an exported activity from adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**ПРИМІТКА**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> Зауважте, що authorisation bypass не завжди є вразливістю — це залежатиме від того, як bypass працює і яка інформація розкривається.

**Sensitive information leakage**

**Activities can also return results**. Якщо вам вдасться знайти експортовану та незахищену activity, яка викликає метод **`setResult`** і **повертає конфіденційну інформацію**, відбувається sensitive information leakage.

#### Tapjacking

If Tapjacking isn't prevented, you could abuse the exported activity to make the **user perform unexpected actions**. For more info about [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers по суті використовуються для обміну даними. Якщо в додатку доступні content providers, ви можете вивести з них **конфіденційні** дані. Також варто протестувати на можливі **SQL injections** і **Path Traversals**, оскільки вони також можуть бути вразливими.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Пам'ятайте, що дії Service починаються в методі `onStartCommand`.

Service по суті — це те, що **може отримувати дані**, **обробляти** їх і **повертати** (або не повертати) відповідь. Тому, якщо додаток експортує якісь services, варто **перевірити** **код**, щоб зрозуміти, що він робить, і **протестувати** його **динамічно** для вилучення конфіденційної інформації, обходу заходів автентифікації тощо.\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Пам'ятайте, що дії Broadcast Receiver починаються в методі `onReceive`.

Broadcast receiver очікує на певний тип повідомлення. Залежно від того, як receiver обробляє повідомлення, він може бути вразливим.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

You can look for deep links manually, using tools like MobSF or scripts like [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Ви можете **відкрити** оголошену **scheme** за допомогою **adb** або **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Зверніть увагу, що ви можете **пропустити ім’я пакета** і мобільний пристрій автоматично викличе додаток, який має відкрити це посилання._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Code executed**

In order to find the **code that will be executed in the App**, go to the activity called by the deeplink and search the function **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Чутлива інформація**

Every time you find a deep link check that i**t's not receiving sensitive data (like passwords) via URL parameters**, because any other application could **impersonate the deep link and steal that data!**

**Parameters in path**

You **must check also if any deep link is using a parameter inside the path** of the URL like: `https://api.example.com/v1/users/{username}` , in that case you can force a path traversal accessing something like: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Note that if you find the correct endpoints inside the application you may be able to cause a **Open Redirect** (if part of the path is used as domain name), **account takeover** (if you can modify users details without CSRF token and the vuln endpoint used the correct method) and any other vuln. More [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Transport Layer Inspection and Verification Failures

- **Certificates are not always inspected properly** by Android applications. It's common for these applications to overlook warnings and accept self-signed certificates or, in some instances, revert to using HTTP connections.
- **Negotiations during the SSL/TLS handshake are sometimes weak**, employing insecure cipher suites. This vulnerability makes the connection susceptible to man-in-the-middle (MITM) attacks, allowing attackers to decrypt the data.
- **Leakage of private information** is a risk when applications authenticate using secure channels but then communicate over non-secure channels for other transactions. This approach fails to protect sensitive data, such as session cookies or user details, from interception by malicious entities.

#### Certificate Verification

We will focus on **certificate verification**. The integrity of the server's certificate must be verified to enhance security. This is crucial because insecure TLS configurations and the transmission of sensitive data over unencrypted channels can pose significant risks. For detailed steps on verifying server certificates and addressing vulnerabilities, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) provides comprehensive guidance.

#### SSL Pinning

SSL Pinning is a security measure where the application verifies the server's certificate against a known copy stored within the application itself. This method is essential for preventing MITM attacks. Implementing SSL Pinning is strongly recommended for applications handling sensitive information.

#### Traffic Inspection

To inspect HTTP traffic, it's necessary to **install the proxy tool's certificate** (e.g., Burp). Without installing this certificate, encrypted traffic might not be visible through the proxy. For a guide on installing a custom CA certificate, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Applications targeting **API Level 24 and above** require modifications to the Network Security Config to accept the proxy's CA certificate. This step is critical for inspecting encrypted traffic. For instructions on modifying the Network Security Config, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

If **Flutter** is being used you need to to follow the instructions in [**this page**](flutter.md). This is becasue, just adding the certificate into the store won't work as Flutter has its own list of valid CAs.

#### Static detection of SSL/TLS pinning

Before attempting runtime bypasses, quickly map where pinning is enforced in the APK. Static discovery helps you plan hooks/patches and focus on the right code paths.

Tool: SSLPinDetect
- Open-source static-analysis utility that decompiles the APK to Smali (via apktool) and scans for curated regex patterns of SSL/TLS pinning implementations.
- Reports exact file path, line number, and a code snippet for each match.
- Covers common frameworks and custom code paths: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Використання
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Приклади шаблонних правил (JSON)
Використовуйте або розширюйте signatures для виявлення proprietary/custom pinning styles. Ви можете завантажити власний JSON і scan at scale.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Нотатки та поради
- Швидке сканування великих додатків за допомогою мультипотоковості та memory-mapped I/O; попередньо скомпільовані regex знижують накладні витрати й хибні спрацьовування.
- Колекція шаблонів: https://github.com/aancw/smali-sslpin-patterns
- Типові цілі для виявлення, які слід розглянути далі:
- OkHttp: використання CertificatePinner, setCertificatePinner, посилання на pakети okhttp3/okhttp
- Користувацькі TrustManagers: javax.net.ssl.X509TrustManager, перевизначення checkServerTrusted
- Користувацькі SSL контексти: SSLContext.getInstance + SSLContext.init з кастомними менеджерами
- Декларативні pins у res/xml network security config та посилання в manifest
- Використайте знайдені місця, щоб спланувати Frida hooks, статичні патчі або перевірку конфігурацій перед динамічним тестуванням.



#### Обхід SSL Pinning

Коли реалізовано SSL Pinning, обходи стають необхідними для інспекції HTTPS-трафіку. Існують різні методи для цього:

- Автоматично **змінити** **apk** щоб **обійти** SSLPinning за допомогою [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Головний плюс — не потрібно root для обходу SSL Pinning, але потрібно видалити додаток і встановити модифікований, і це не завжди працює.
- Можна використати **Frida** (описано нижче) для обходу цього захисту. Тут є керівництво для використання Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Також можна спробувати **автоматично обійти SSL Pinning** за допомогою [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Також можна спробувати **автоматично обійти SSL Pinning** за допомогою **MobSF dynamic analysis** (пояснено нижче)
- Якщо ви все ще думаєте, що якийсь трафік не потрапляє у ваші логі, можна спробувати **форвардити трафік в burp за допомогою iptables**. Читайте цей блог: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Пошук поширених веб-вразливостей

Важливо також шукати поширені веб-вразливості у додатку. Детальна інформація про їх ідентифікацію та пом'якшення виходить за рамки цього короткого огляду, але докладно висвітлена в інших джерелах.

### Frida

[Frida](https://www.frida.re) — це комплект інструментів динамічної інструментації для розробників, реверс-інженерів та фахівців з безпеки.\
**Ви можете отримати доступ до запущеного додатку й перехоплювати методи під час виконання, щоб змінювати поведінку, змінювати значення, витягувати значення, виконувати інший код...**\
Якщо ви хочете pentest Android-додатки, вам потрібно вміти користуватися Frida.

- Дізнатися, як користуватися Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Деякі "GUI" для роботи з Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection чудово автоматизує використання Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Деякі корисні Frida-скрипти можна знайти тут: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Спробуйте обійти механізми anti-debugging / anti-frida, завантажуючи Frida як вказано в [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (інструмент [linjector](https://github.com/erfur/linjector-rs))

#### Анти-інструментація & workflow обходу SSL pinning

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Дамп пам'яті - Fridump**

Перевірте, чи додаток зберігає в пам'яті чутливу інформацію, якої не повинен зберігати — наприклад паролі чи мнемоніки.

Використовуючи [**Fridump3**](https://github.com/rootbsd/fridump3) ви можете дампнути пам'ять додатку за допомогою:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Це зробить dump пам'яті в папку ./dump, а в ній ви можете виконати grep приблизно так:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Sensitive data in Keystore**

В Android Keystore — найкраще місце для зберігання чутливих даних, однак за наявності достатніх привілеїв все ще **можна отримати до нього доступ**. Оскільки додатки часто зберігають тут **sensitive data in clear text**, pentests мають перевіряти це, оскільки root user або особа з фізичним доступом до пристрою може викрасти ці дані.

Навіть якщо додаток зберіг дані в keystore, дані мають бути зашифровані.

Щоб отримати доступ до даних всередині keystore, можна використати цей Frida script: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Використовуючи наведений Frida script, можливо обійти **bypass fingerprint authentication**, яку застосунки Android можуть реалізовувати для **захисту певних чутливих областей:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Фонові зображення**

Коли ви переводите застосунок у фоновий режим, Android зберігає **знімок застосунку**, тож під час повернення на передній план система спочатку завантажує це зображення, щоб здавалося, що застосунок відкрився швидше.

Однак якщо цей знімок містить **чутливу інформацію**, хтось із доступом до нього може **вкрасти цю інформацію** (зауважте, що для доступу потрібні root-права).

Зазвичай знімки зберігаються за шляхом: **`/data/system_ce/0/snapshots`**

Android надає спосіб **запобігти захопленню скріншоту, встановивши параметр макету FLAG_SECURE**. Використовуючи цей прапорець, вміст вікна позначається як захищений, що запобігає його появі у скріншотах або перегляду на незахищених дисплеях.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Цей інструмент може допомогти вам керувати різними інструментами під час динамічного аналізу: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Розробники часто створюють проксі-компоненти, такі як activities, services та broadcast receivers, які обробляють ці Intents і передають їх у методи на кшталт `startActivity(...)` або `sendBroadcast(...)`, що може бути ризиковано.

Небезпека полягає в тому, що це дозволяє атакуючим спровокувати non-exported app components або отримати доступ до чутливих content providers, перенаправивши ці Intents. Помітний приклад — компонент `WebView`, який перетворює URL у `Intent` через `Intent.parseUri(...)` і потім виконує їх, що може привести до шкідливої інжекції Intent.

### Essential Takeaways

- **Intent Injection** схожа на веб-проблему Open Redirect.
- Експлойти можуть передавати об'єкти `Intent` як extras, які потім перенаправляються для виконання небезпечних операцій.
- Це може відкрити доступ атакуючим до non-exported components та content providers.
- Перетворення URL у `Intent` в WebView може сприяти небажаним діям.

### Android Client Side Injections and others

Ймовірно ви знаєте про цей тип вразливостей із Web. Слід бути особливо обережним з такими вразливостями в Android-додатку:

- **SQL Injection:** При роботі з динамічними запитами або Content-Providers переконайтеся, що використовуєте parameterized queries.
- **JavaScript Injection (XSS):** Перевірте, що підтримка JavaScript та плагінів вимкнена для будь-яких WebViews (вимкнена за замовчуванням). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews повинні мати доступ до файлової системи вимкненим (увімкнено за замовчуванням) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: У кількох випадках, коли android application завершує сесію, cookie не відкликається або може бути навіть збережено на диску
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Статичний аналіз**

![](<../../images/image (866).png>)

**Оцінка вразливостей додатку** за допомогою зручного web-based frontend. Ви також можете виконати dynamic analysis (але потрібно підготувати середовище).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Додатки Windows потрібно аналізувати за допомогою MobSF, встановленого на хості Windows_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Допоміжний динамічний аналіз з MobSF

**MobSF** також дуже корисний для **dynamic analysis** в **Android**, але в цьому випадку потрібно встановити MobSF та **genymotion** на ваш хост (VM або Docker не підходять). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
**MobSF dynamic analyser** може:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). Усе це робиться автоматично, крім скриншотів — їх потрібно робити вручну або натиснути "**Exported Activity Tester**", щоб отримати скриншоти всіх exported activities.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

З android **versions > 5** він **автоматично запускатиме Frida** і встановлюватиме глобальні налаштування **proxy** для **перехоплення** трафіку. Він перехоплюватиме трафік лише з тестованого застосунку.

**Frida**

За замовчуванням використовуються деякі Frida Scripts для **bypass SSL pinning**, **root detection** і **debugger detection** та для **моніторингу цікавих API**.\
MobSF також може **викликати exported activities**, робити їх **скриншоти** і **зберігати** їх для звіту.

Щоб **почати** динамічне тестування, натисніть зелену кнопку: "**Start Instrumentation**". Натисніть "**Frida Live Logs**", щоб побачити логи, згенеровані Frida scripts, і "**Live API Monitor**", щоб побачити всі виклики заблокованих методів, передані аргументи та повернуті значення (це з’явиться після натискання "Start Instrumentation").\
MobSF також дозволяє завантажувати власні **Frida scripts** (щоб відправити результати ваших Frida scripts до MobSF, використовуйте функцію `send()`). Є також **кілька заздалегідь написаних скриптів**, які можна завантажити (ви можете додати більше в `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), просто **виберіть їх**, натисніть "**Load**" і натисніть "**Start Instrumentation**" (логи цих скриптів будуть видні в "**Frida Live Logs**").

![](<../../images/image (419).png>)

Крім того, доступні допоміжні Frida функціональності:

- **Enumerate Loaded Classes**: Виведе всі завантажені класи
- **Capture Strings**: Виводить усі перехоплені рядки під час використання застосунку (дуже шумно)
- **Capture String Comparisons**: Може бути дуже корисним. **Показує 2 рядки, що порівнюються**, і чи результат був True або False.
- **Enumerate Class Methods**: Введіть назву класу (наприклад "java.io.File") — буде виведено всі методи класу.
- **Search Class Pattern**: Пошук класів за шаблоном
- **Trace Class Methods**: **Trace** цілого **класу** (дивіться вхідні та вихідні дані всіх методів класу). Пам’ятайте, що за замовчуванням MobSF трасує декілька цікавих Android API методів.

Після вибору потрібного допоміжного модуля натисніть "**Start Instrumentation**" — ви побачите всі виводи в "**Frida Live Logs**".

**Shell**

MobSF також надає shell з деякими **adb** командами, **MobSF commands** та поширеними **shell** **commands** у нижній частині сторінки dynamic analysis. Деякі корисні команди:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP інструменти**

Коли http-трафік перехоплено, ви можете побачити непривабливий вигляд перехопленого трафіку внизу на "**HTTP(S) Traffic**" або більш приємний перегляд у зеленій кнопці "**Start HTTPTools**". З другого варіанту ви можете **send** the **captured requests** to **proxies** like Burp or Owasp ZAP.\
Щоб зробити це, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> натисніть "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Після завершення динамічного аналізу з MobSF ви можете натиснути "**Start Web API Fuzzer**", щоб **fuzz http requests** і шукати вразливості.

> [!TIP]
> Після виконання динамічного аналізу з MobSF налаштування проксі можуть бути некоректними, і ви не зможете виправити їх через GUI. Ви можете виправити налаштування проксі, виконавши:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Асистований динамічний аналіз з Inspeckage

You can get the tool from [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Цей інструмент використовує деякі **Hooks**, щоб показати вам **what is happening in the application** поки ви виконуєте **динамічний аналіз**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Це **great tool to perform static analysis with a GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Цей інструмент призначений для пошуку кількох **security related Android application vulnerabilities**, як у **source code**, так і в **packaged APKs**. Інструмент також **capable of creating a "Proof-of-Concept" deployable APK** та **ADB commands**, щоб експлуатувати деякі знайдені вразливості (Exposed activities, intents, tapjacking...). Як і з Drozer, немає потреби root-ити тестовий пристрій.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Відображає всі витягнуті файли для зручного перегляду
- Автоматично декомпілює APK файли у формат Java та Smali
- Аналізує AndroidManifest.xml на наявність типових вразливостей та поведінки
- Статичний аналіз вихідного коду на наявність типових вразливостей та поведінки
- Інформація про пристрій
- та інше
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER — це консольна програма, яку можна використовувати в Windows, MacOS X та Linux; вона аналізує _.apk_ файли в пошуку вразливостей. Вона робить це шляхом розпаковування APK і застосування ряду правил для виявлення цих вразливостей.

Усі правила зосереджені у файлі `rules.json`, і кожна компанія або тестувальник можуть створювати власні правила для аналізу того, що їм потрібно.

Завантажте останні бінарні файли зі [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn — **кросплатформний** інструмент, який допомагає розробникам, bugbounty hunters та ethical hackers виконувати [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) над мобільними додатками.

Концепція полягає в тому, що ви перетягуєте файл вашого мобільного застосунку (файл .apk або .ipa) у застосунок StaCoAn — і він згенерує для вас візуальний та портативний звіт. Ви можете налаштувати параметри та wordlists, щоб отримати індивідуальний досвід.

Завантажити[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework — це система аналізу вразливостей Android, яка допомагає розробникам або hackers знаходити потенційні вразливості безпеки в Android-додатках.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** — інструмент, основна мета якого — виявляти та попереджувати користувача про потенційно шкідливу поведінку Android-застосунку.

Виявлення виконується шляхом **static analysis** Dalvik bytecode застосунку, представленого як **Smali**, з використанням бібліотеки [`androguard`](https://github.com/androguard/androguard).

Цей інструмент шукає **common behavior of "bad" applications** такі як: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. It is a tool that puts together commonly used mobile application reverse engineering and analysis tools, to assist in testing mobile applications against the OWASP mobile security threats. Its objective is to make this task easier and friendlier to mobile application developers and security professionals.

Він здатен:

- Витягувати Java та Smali код за допомогою різних інструментів
- Аналізувати APK за допомогою: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Витягувати приватну інформацію з APK за допомогою регулярних виразів.
- Аналізувати Manifest.
- Аналізувати знайдені домени за допомогою: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Деобфускувати APK через [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Корисно для виявлення malware: [https://koodous.com/](https://koodous.com/)

## Обфускація/Деобфускація коду

Зверніть увагу, що залежно від сервісу та конфігурації, яку ви використовуєте для обфускації коду, секрети можуть бути обфусковані або залишитись у відкритому вигляді.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

Згідно з [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** — це інструмент з відкритим кодом командного рядка, який стискає, оптимізує та обфускує Java-код. Він вміє оптимізувати байткод, а також виявляти та видаляти невикористовувані інструкції. ProGuard — вільне програмне забезпечення і поширюється під GNU General Public License, version 2.

ProGuard постачається в складі Android SDK і запускається під час збірки застосунку в release-режимі.

### [DexGuard](https://www.guardsquare.com/dexguard)

Знайдіть покроковий посібник із деобфускації apk на [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(Згідно з цим посібником) Востаннє, коли ми перевіряли, режим роботи Dexguard був:

- завантажити ресурс як InputStream;
- передати результат у клас, що наслідується від FilterInputStream, щоб розшифрувати його;
- виконати деяку марну обфускацію, щоб витратити кілька хвилин часу реверсера;
- передати розшифрований результат до ZipInputStream, щоб отримати DEX файл;
- врешті завантажити отриманий DEX як Resource, використовуючи метод `loadDex`.

### [DeGuard](http://apk-deguard.com)

**DeGuard відміняє процес обфускації, виконаний Android obfuscation tools. Це дозволяє виконувати численні security analyses, включаючи інспекцію коду та виявлення бібліотек.**

Ви можете завантажити обфускований APK на їхню платформу.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

Це LLM-інструмент для виявлення потенційних вразливостей у android apps та деобфускації коду android app. Використовує Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

Це generic android deobfuscator. Simplify фактично виконує додаток, щоб зрозуміти його поведінку, а потім намагається оптимізувати код так, щоб він поводився ідентично, але був простішим для розуміння людиною. Кожен тип оптимізації простий і універсальний, тому не має значення, який саме тип обфускації використано.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD надає інформацію про те, як було створено APK. Він ідентифікує багато компіляторів, packers, obfuscators та інші дивні штуки. Це [_PEiD_](https://www.aldeid.com/wiki/PEiD) для Android.

### Manual

[Прочитайте цей посібник, щоб дізнатися деякі трюки щодо **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b — це Android security virtual machine на базі ubuntu-mate, яка включає колекцію останніх framework, tutorials та лабораторій від різних security geeks та дослідників для reverse engineering та malware analysis.

## Посилання

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Це чудовий список ресурсів
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Розширене виявлення SSL Pinning для аналізу безпеки Android](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)

## Ще спробувати

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
