# Pentesting d'applications Android

{{#include ../../banners/hacktricks-training.md}}

## Fondamentaux des applications Android

Il est fortement recommandé de commencer par lire cette page pour connaître les **parties les plus importantes liées à la sécurité Android et les composants les plus dangereux dans une application Android** :


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

C'est l'outil principal dont vous avez besoin pour vous connecter à un appareil Android (émulé ou physique).\
**ADB** permet de contrôler les appareils soit via **USB** soit via le **réseau** depuis un ordinateur. Cette utilité permet la **copie** de fichiers dans les deux sens, **l'installation** et **la désinstallation** d'apps, **l'exécution** de commandes shell, **la sauvegarde** des données, **la lecture** des logs, parmi d'autres fonctions.

Consultez la liste suivante de [**ADB Commands**](adb-commands.md) pour apprendre à utiliser adb.

## Smali

Parfois il est intéressant de **modifier le code de l'application** pour accéder à des **informations cachées** (peut-être des mots de passe ou des flags fortement obfusqués). Alors, il peut être utile de décompiler l'apk, modifier le code et le recompiler.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Cela peut être très utile comme **alternative pour plusieurs tests lors de l'analyse dynamique** qui vont être présentés. Donc, **gardez toujours à l'esprit cette possibilité**.

## Autres astuces intéressantes

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Extraire l'APK depuis l'appareil:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Fusionnez tous les splits et les apks de base avec [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Attaques Android Enterprise & Work Profile

{{#ref}}
android-enterprise-work-profile-bypass.md
{{#endref}}

## Études de cas & Vulnérabilités


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Analyse statique

Tout d'abord, pour analyser un APK vous devriez **regarder le code Java** en utilisant un décompilateur.  
Veuillez, [**lire ici pour trouver des informations sur les différents décompilateurs disponibles**](apk-decompilers.md).

### Recherche d'informations intéressantes

Rien qu'en regardant les **strings** de l'APK vous pouvez rechercher des **passwords**, des **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), des **api** keys, de l'**encryption**, des **bluetooth uuids**, des **tokens** et tout ce qui peut être intéressant... cherchez même des backdoors d'exécution de code ou des backdoors d'authentification (identifiants admin hardcodés dans l'app).

**Firebase**

Portez une attention particulière aux **Firebase URLs** et vérifiez si elles sont mal configurées. [More information about whats is Firebase and how to exploit it here.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Compréhension basique de l'application - Manifest.xml, strings.xml

L'**examen des fichiers _Manifest.xml_ et **_strings.xml_** d'une application peut révéler des vulnérabilités potentielles de sécurité**. Ces fichiers peuvent être consultés via des décompilateurs ou en renommant l'extension du fichier APK en .zip puis en le décompressant.

Les **vulnérabilités** identifiables à partir du **Manifest.xml** incluent :

- **Debuggable Applications** : Les applications configurées comme débogables (`debuggable="true"`) dans le _Manifest.xml_ représentent un risque car elles permettent des connexions pouvant mener à une exploitation. Pour comprendre comment exploiter des applications débogables, référez-vous à un tutoriel sur la recherche et l'exploitation d'applications debuggables sur un appareil.
- **Backup Settings** : L'attribut `android:allowBackup="false"` doit être explicitement défini pour les applications manipulant des informations sensibles afin d'empêcher des backups non autorisés via adb, surtout lorsque le débogage USB est activé.
- **Network Security** : Des configurations personnalisées de network security (`android:networkSecurityConfig="@xml/network_security_config"`) dans _res/xml/_ peuvent spécifier des détails de sécurité comme le pinning de certificats et les paramètres de trafic HTTP. Un exemple est d'autoriser le trafic HTTP pour des domaines spécifiques.
- **Exported Activities and Services** : Identifier les activités et services exportés dans le manifest peut mettre en évidence des composants susceptibles d'être détournés. Une analyse plus poussée lors de tests dynamiques peut révéler comment exploiter ces composants.
- **Content Providers and FileProviders** : Des content providers exposés pourraient permettre un accès non autorisé ou la modification de données. La configuration des FileProviders doit également être scrutée.
- **Broadcast Receivers and URL Schemes** : Ces composants peuvent être exploités, en accordant une attention particulière à la manière dont les URL schemes sont gérés pour les vulnérabilités d'entrée.
- **SDK Versions** : Les attributs `minSdkVersion`, `targetSDKVersion`, et `maxSdkVersion` indiquent les versions Android supportées, soulignant l'importance de ne pas supporter des versions Android obsolètes et vulnérables pour des raisons de sécurité.

À partir du fichier **strings.xml**, des informations sensibles telles que des API keys, des schémas personnalisés et d'autres notes de développeurs peuvent être découvertes, soulignant la nécessité d'un examen attentif de ces ressources.

### Tapjacking

**Tapjacking** est une attaque où une **application malveillante** est lancée et **se positionne au-dessus d'une application victime**. Une fois qu'elle obstrue visiblement l'application victime, son interface utilisateur est conçue de manière à tromper l'utilisateur afin qu'il interagisse avec elle, tandis qu'elle transmet l'interaction à l'application victime.  
En pratique, cela consiste à **priver l'utilisateur de la visibilité sur le fait qu'il effectue réellement des actions sur l'application victime**.

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Une **activity** avec le **`launchMode`** réglé sur **`singleTask` sans `taskAffinity`** défini est vulnérable au task Hijacking. Cela signifie qu'une **application** peut être installée et si elle est lancée avant la vraie application, elle pourrait **détourner la task de la vraie application** (l'utilisateur interagira donc avec l'**application malveillante en pensant utiliser la vraie**).

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Stockage de données peu sûr

Internal Storage

Sur Android, les fichiers **stockés** en **internal** storage sont **conçus** pour être **accessibles** exclusivement par l'**app** qui les a **créés**. Cette mesure de sécurité est **imposée** par le système d'exploitation Android et est généralement suffisante pour les besoins de sécurité de la plupart des applications. Cependant, les développeurs utilisent parfois des modes tels que `MODE_WORLD_READABLE` et `MODE_WORLD_WRITABLE` pour **permettre** aux fichiers d'être **partagés** entre différentes applications. Pourtant, ces modes **ne restreignent pas l'accès** à ces fichiers par d'autres applications, y compris des applications potentiellement malveillantes.

1. **Analyse statique :**
- **Vérifiez** que l'utilisation de `MODE_WORLD_READABLE` et `MODE_WORLD_WRITABLE` est **scrutée attentivement**. Ces modes **peuvent potentiellement exposer** des fichiers à un **accès non désiré ou non autorisé**.
2. **Analyse dynamique :**
- **Vérifiez** les **permissions** définies sur les fichiers créés par l'app. En particulier, **contrôlez** si des fichiers sont **configurés en lecture ou écriture mondiale**. Cela peut représenter un risque de sécurité important, car cela permettrait à **n'importe quelle application** installée sur l'appareil, quelle que soit son origine ou son intention, de **lire ou modifier** ces fichiers.

External Storage

Lorsqu'on traite des fichiers sur le **external storage**, comme les SD Cards, certaines précautions doivent être prises :

1. **Accessibilité** :
- Les fichiers sur external storage sont **globalement lisibles et modifiables**. Cela signifie que n'importe quelle application ou utilisateur peut y accéder.
2. **Problèmes de sécurité** :
- Étant donné la facilité d'accès, il est recommandé **de ne pas stocker d'informations sensibles** sur l'external storage.
- L'external storage peut être retiré ou accédé par n'importe quelle application, ce qui le rend moins sûr.
3. **Traitement des données provenant de l'external storage** :
- Toujours **effectuer une validation d'entrée** sur les données récupérées de l'external storage. C'est crucial car les données proviennent d'une source non fiable.
- Il est fortement déconseillé de stocker des exécutables ou des fichiers de classe sur l'external storage pour un chargement dynamique.
- Si votre application doit récupérer des fichiers exécutables depuis l'external storage, assurez-vous que ces fichiers sont **signés et vérifiés cryptographiquement** avant d'être chargés dynamiquement. Cette étape est vitale pour maintenir l'intégrité de la sécurité de votre application.

External storage peut être **accédé** dans `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> À partir d'Android 4.4 (**API 17**), la carte SD possède une structure de répertoire qui **limite l'accès d'une application au répertoire qui lui est spécifiquement dédié**. Cela empêche une application malveillante d'obtenir un accès en lecture ou écriture aux fichiers d'une autre application.

**Données sensibles stockées en clair**

- **Shared preferences** : Android permet à chaque application de facilement enregistrer des fichiers xml dans le chemin `/data/data/<packagename>/shared_prefs/` et parfois il est possible de trouver des informations sensibles en clair dans ce dossier.
- **Databases** : Android permet à chaque application de facilement enregistrer des bases sqlite dans le chemin `/data/data/<packagename>/databases/` et parfois il est possible de trouver des informations sensibles en clair dans ce dossier.

### TLS défaillant

**Accept All Certificates**

Pour une raison ou une autre, il arrive parfois que des développeurs acceptent tous les certificats même si, par exemple, le hostname ne correspond pas, avec des lignes de code comme la suivante :
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Broken Cryptography

**Poor Key Management Processes**

Certains développeurs sauvegardent des données sensibles dans le stockage local et les chiffrent avec une clé hardcodée/prédictible dans le code. Cela ne devrait pas être fait car un peu de reversing pourrait permettre à des attaquants d'extraire l'information confidentielle.

**Use of Insecure and/or Deprecated Algorithms**

Les développeurs ne devraient pas utiliser des **algorithmes dépréciés** pour effectuer des vérifications d'**authorization**, **stocker** ou **envoyer** des données. Certains de ces algorithmes sont : RC4, MD4, MD5, SHA1... Si des **hashes** sont utilisés pour stocker des mots de passe par exemple, des hashes résistants au brute-force devraient être utilisés avec du salt.

### Other checks

- Il est recommandé d'**obfusquer l'APK** pour rendre le travail de reverse engineer plus difficile aux attaquants.
- Si l'app est sensible (comme les apps bancaires), elle devrait effectuer ses **propres contrôles pour vérifier si le mobile est rooté** et agir en conséquence.
- Si l'app est sensible (comme les apps bancaires), elle devrait vérifier si un **emulator** est utilisé.
- Si l'app est sensible (comme les apps bancaires), elle devrait **vérifier sa propre intégrité avant de s'exécuter** afin de vérifier si elle a été modifiée.
- Utilisez [**APKiD**](https://github.com/rednaga/APKiD) pour vérifier quel compiler/packer/obfuscator a été utilisé pour construire l'APK

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

L'outil [**mariana-trench**](https://github.com/facebook/mariana-trench) est capable de trouver des **vulnerabilities** en **scannant** le **code** de l'application. Cet outil contient une série de **known sources** (qui indiquent à l'outil les **places** où l'**input** est **contrôlé par l'utilisateur**), **sinks** (qui indiquent à l'outil les **places dangereuses** où un input malveillant pourrait causer des dommages) et des **rules**. Ces rules indiquent la **combinaison** de **sources-sinks** qui signale une vulnérabilité.

Avec ces connaissances, **mariana-trench will review the code and find possible vulnerabilities on it**.

### Secrets leaked

An application may contain secrets (API keys, passwords, hidden urls, subdomains...) inside of it that you might be able to discover. You could us a tool such as [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)
- In-memory native code execution via JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> First of all, you need an environment where you can install the application and all the environment (Burp CA cert, Drozer and Frida mainly). Therefore, a rooted device (emulated or not) is extremely recommended.

### Online Dynamic analysis

Vous pouvez créer un **compte gratuit** sur : [https://appetize.io/](https://appetize.io). Cette plateforme permet d'**uploader** et d'**exécuter** des APKs, elle est donc utile pour voir comment un apk se comporte.

Vous pouvez même **voir les logs de votre application** sur le web et vous connecter via **adb**.

![](<../../images/image (831).png>)

Grâce à la connexion ADB vous pouvez utiliser **Drozer** et **Frida** à l'intérieur des émulateurs.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (Vous pouvez créer des devices **x86** et **arm**, et selon [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**les dernières versions x86** supportent les bibliothèques ARM sans nécessiter un émulateur ARM lent).
- Apprenez à le configurer sur cette page :


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, vous devez créer un compte. _Il est recommandé de **télécharger** la version **WITH**_ _**VirtualBox** pour éviter des erreurs potentielles._)
- [**Nox**](https://es.bignox.com) (Gratuit, mais il ne supporte pas Frida ou Drozer).

> [!TIP]
> Lorsque vous créez un nouvel émulateur sur n'importe quelle plateforme, souvenez-vous que plus l'écran est grand, plus l'émulateur sera lent. Choisissez donc des écrans petits si possible.

To **install google services** (like AppStore) in Genymotion you need to click on the red marked button of the following image:

![](<../../images/image (277).png>)

Also, notice that in the **configuration of the Android VM in Genymotion** you can select **Bridge Network mode** (this will be useful if you will be connecting to the Android VM from a different VM with the tools).

#### Use a physical device

Vous devez activer les options de **debugging** et il est préférable que vous puissiez le **rooter** :

1. **Paramètres**.
2. (Depuis Android 8.0) Sélectionnez **Système**.
3. Sélectionnez **À propos du téléphone**.
4. Appuyez 7 fois sur **Numéro de build**.
5. Revenez en arrière et vous trouverez les **Options pour les développeurs**.

> Une fois que vous avez installé l'application, la première chose à faire est de l'essayer, d'investiguer ce qu'elle fait, comment elle fonctionne et de vous familiariser avec elle.\
> Je suggère d'**effectuer cette analyse dynamique initiale en utilisant MobSF dynamic analysis + pidcat**, ainsi nous pourrons **comprendre comment l'application fonctionne** pendant que MobSF **capture** beaucoup de **données intéressantes** que vous pourrez revoir plus tard.

Magisk/Zygisk quick notes (recommended on Pixel devices)
- Patch boot.img with the Magisk app and flash via fastboot to get systemless root
- Enable Zygisk + DenyList for root hiding; consider LSPosed/Shamiko when stronger hiding is required
- Keep original boot.img to recover from OTA updates; re-patch after each OTA
- For screen mirroring, use scrcpy on the host



### Unintended Data Leakage

**Logging**

Les développeurs doivent être prudents quant à l'exposition d'**informations de debugging** publiquement, car cela peut entraîner des leaks de données sensibles. Les outils [**pidcat**](https://github.com/JakeWharton/pidcat) et `adb logcat` sont recommandés pour surveiller les logs d'application afin d'identifier et protéger les informations sensibles. **Pidcat** est privilégié pour sa facilité d'utilisation et sa lisibilité.

> [!WARNING]
> Notez que depuis **versions plus récentes qu'Android 4.0**, **les applications ne peuvent accéder qu'à leurs propres logs**. Ainsi, les applications ne peuvent pas accéder aux logs d'autres apps.\
> Quoi qu'il en soit, il est toujours recommandé de **ne pas logger d'informations sensibles**.

**Copy/Paste Buffer Caching**

Le framework basé sur le **clipboard** d'Android permet la fonctionnalité de copy-paste dans les apps, mais présente un risque car **d'autres applications** peuvent **accéder** au clipboard, exposant potentiellement des données sensibles. Il est crucial de **désactiver les fonctions de copy/paste** pour les sections sensibles d'une application, comme les détails de carte de crédit, pour éviter des leaks.

**Crash Logs**

Si une application **crashe** et **sauvegarde des logs**, ces logs peuvent aider des attaquants, surtout lorsque l'application ne peut pas être reverse-engineered. Pour atténuer ce risque, évitez de logger lors des crashes, et si des logs doivent être transmis sur le réseau, assurez-vous qu'ils sont envoyés via un canal SSL sécurisé.

As pentester, **try to take a look to these logs**.

**Analytics Data Sent To 3rd Parties**

Les applications intègrent souvent des services comme Google Adsense, qui peuvent involontairement causer des leaks de données sensibles à cause d'une implémentation incorrecte par les développeurs. Pour identifier d'éventuels leaks, il est conseillé d'**intercepter le trafic de l'application** et de vérifier si des informations sensibles sont envoyées à des services tiers.

### SQLite DBs

La plupart des applications utilisent des **bases de données SQLite internes** pour sauvegarder des informations. Pendant le pentest, jetez un **coup d'œil** aux **databases** créées, aux noms des **tables** et des **colonnes** et à toutes les **données** sauvegardées car vous pourriez trouver des **informations sensibles** (ce qui constituerait une vulnérabilité).\
Les bases de données devraient se trouver dans `/data/data/the.package.name/databases` comme `/data/data/com.mwr.example.sieve/databases`

Si la database sauvegarde des informations confidentielles et est **encrypted** mais que vous pouvez **find** le **password** à l'intérieur de l'application, c'est toujours une **vulnérabilité**.

Enumérez les tables en utilisant `.tables` et énumérez les colonnes des tables en faisant `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer is s useful tool to **exploit exported activities, exported services and Content Providers** as you will learn in the following sections.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Also remember that the code of an activity starts in the **`onCreate`** method.

**Authorisation bypass**

When an Activity is exported you can invoke its screen from an external app. Therefore, if an activity with **sensitive information** is **exported** you could **bypass** the **authentication** mechanisms **to access it.**

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

You can also start an exported activity from adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> Notez qu'un authorisation bypass n'est pas toujours une vulnérabilité ; cela dépend de la façon dont le bypass fonctionne et des informations qui sont exposées.

**Fuite d'informations sensibles**

Activities can also return results. If you manage to find an exported and unprotected activity calling the **`setResult`** method and **returning sensitive information**, there is a sensitive information leakage.

#### Tapjacking

If Tapjacking isn't prevented, you could abuse the exported activity to make the **user perform unexpected actions**. For more info about [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers are basically used to **share data**. If an app has available content providers you may be able to **extract sensitive** data from them. It also interesting to test possible **SQL injections** and **Path Traversals** as they could be vulnerable.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Rappelez-vous que les actions d'un Service commencent dans la méthode `onStartCommand`.

Un service est essentiellement quelque chose qui **peut recevoir des données**, **les traiter** et **retourner** (ou non) une réponse. Donc, si une application exporte des services, vous devriez **vérifier** le **code** pour comprendre ce qu'il fait et le **tester** **dynamiquement** afin d'extraire des informations confidentielles, contourner des mécanismes d'authentification...\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Rappelez-vous que les actions d'un Broadcast Receiver commencent dans la méthode `onReceive`.

Un broadcast receiver attendra un type de message. Selon la façon dont le receiver gère le message, il peut être vulnérable.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

You can look for deep links manually, using tools like MobSF or scripts like [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
You can **open** a declared **scheme** using **adb** or a **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Notez que vous pouvez **omettre le package name** et le mobile appellera automatiquement l'app qui doit ouvrir ce lien._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Code exécuté**

Pour trouver le **code qui sera exécuté dans l'App**, allez à l'activité appelée par le deep link et recherchez la fonction **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Informations sensibles**

Chaque fois que vous trouvez un deep link, vérifiez qu'**il ne reçoit pas de données sensibles (comme des passwords) via les paramètres de l'URL**, car toute autre application pourrait **se faire passer pour le deep link et voler ces données !**

**Paramètres dans le chemin**

Vous **devez aussi vérifier si un deep link utilise un paramètre à l'intérieur du chemin** de l'URL comme: `https://api.example.com/v1/users/{username}`, dans ce cas vous pouvez forcer un path traversal en accédant à quelque chose comme: `example://app/users?username=../../unwanted-endpoint%3fparam=value`.\
Notez que si vous trouvez les endpoints corrects à l'intérieur de l'application, vous pourriez être en mesure de provoquer un **Open Redirect** (si une partie du chemin est utilisée comme nom de domaine), un **account takeover** (si vous pouvez modifier les détails des users sans CSRF token et que le vuln endpoint accepte la méthode utilisée) et toute autre vuln. More [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Inspection de la couche Transport et défaillances de vérification

- **Les certificats ne sont pas toujours correctement inspectés** par les applications Android. Il est courant que ces applications ignorent les warnings et acceptent des certificats self-signed ou, dans certains cas, reviennent à des connexions HTTP.
- **Les négociations pendant le handshake SSL/TLS sont parfois faibles**, utilisant des suites de chiffrement non sécurisées. Cette vulnérabilité rend la connexion susceptible à des attaques man-in-the-middle (MITM), permettant aux attaquants de déchiffrer les données.
- **Leakage of private information** est un risque lorsque les applications s'authentifient en utilisant des canaux sécurisés mais communiquent ensuite sur des canaux non sécurisés pour d'autres transactions. Cette approche ne protège pas les données sensibles, comme les cookies de session ou les détails utilisateur, contre l'interception par des entités malveillantes.

#### Certificate Verification

Nous allons nous concentrer sur la **vérification des certificats**. L'intégrité du certificat du serveur doit être vérifiée pour renforcer la sécurité. C'est crucial car des configurations TLS non sécurisées et la transmission de données sensibles sur des canaux non chiffrés peuvent poser des risques significatifs. Pour des étapes détaillées sur la vérification des certificats serveur et la résolution des vulnérabilités, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) fournit des conseils complets.

#### SSL Pinning

SSL Pinning est une mesure de sécurité où l'application vérifie le certificat du serveur par rapport à une copie connue stockée au sein de l'application elle-même. Cette méthode est essentielle pour empêcher les attaques MITM. Il est fortement recommandé d'implémenter SSL Pinning pour les applications manipulant des informations sensibles.

#### Traffic Inspection

Pour inspecter le trafic HTTP, il est nécessaire d'**installer le certificat de l'outil proxy** (par ex., Burp). Sans l'installation de ce certificat, le trafic chiffré pourrait ne pas être visible via le proxy. Pour un guide sur l'installation d'un certificat CA personnalisé, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Les applications ciblant **API Level 24 and above** requièrent des modifications du Network Security Config pour accepter le certificat CA du proxy. Cette étape est critique pour inspecter le trafic chiffré. Pour des instructions sur la modification du Network Security Config, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

If **Flutter** is being used you need to to follow the instructions in [**this page**](flutter.md). This is becasue, just adding the certificate into the store won't work as Flutter has its own list of valid CAs.

#### Static detection of SSL/TLS pinning

Avant d'essayer des runtime bypasses, cartographiez rapidement où le pinning est appliqué dans l'APK. La découverte statique vous aide à planifier les hooks/patches et à vous concentrer sur les bons chemins de code.

Tool: SSLPinDetect
- Utilitaire open-source d'analyse statique qui décompile l'APK en Smali (via apktool) et scanne des patterns regex sélectionnés d'implémentations de SSL/TLS pinning.
- Rapporte le chemin de fichier exact, le numéro de ligne et un extrait de code pour chaque correspondance.
- Couvre les frameworks courants et chemins de code custom : OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

Installation
- Prérequis: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Utilisation
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Exemple de règles de pattern (JSON)
Utilisez ou étendez les signatures pour détecter les styles de pinning propriétaires/personnalisés. Vous pouvez charger votre propre JSON et scan at scale.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes et conseils
- Analyse rapide des grandes applications via multithreading et E/S mappée en mémoire ; les regex précompilées réduisent la surcharge / les faux positifs.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Cibles typiques à prioriser pour le triage :
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Pins déclaratifs dans res/xml (network security config) et références du manifest
- Utilisez les emplacements correspondants pour planifier des hooks Frida, des patchs statiques ou des revues de config avant les tests dynamiques.



#### Contourner SSL Pinning

When SSL Pinning is implemented, bypassing it becomes necessary to inspect HTTPS traffic. Plusieurs méthodes sont disponibles pour cela :

- Automatically **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Le principal avantage de cette option est que vous n'aurez pas besoin de root pour bypasser le SSL Pinning, mais vous devrez supprimer l'application et réinstaller la nouvelle, et cela ne fonctionnera pas toujours.
- You could use **Frida** (discussed below) to bypass this protection. Here you have a guide to use Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- You can also try to **automatically bypass SSL Pinning** using [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- You can also try to **automatically bypass SSL Pinning** using **MobSF dynamic analysis** (explained below)
- If you still think that there is some traffic that you aren't capturing you can try to **forward the traffic to burp using iptables**. Read this blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Recherche de vulnérabilités web courantes

Il est important de rechercher également les vulnérabilités web communes dans l'application. Les détails sur l'identification et l'atténuation de ces vulnérabilités dépassent le cadre de ce résumé mais sont traités en profondeur ailleurs.

### Frida

[Frida](https://www.frida.re) is a dynamic instrumentation toolkit for developers, reverse-engineers, and security researchers.\
**Vous pouvez accéder à l'application en cours d'exécution et hooker des méthodes à l'exécution pour modifier le comportement, changer des valeurs, extraire des valeurs, exécuter un autre code...**\
If you want to pentest Android applications you need to know how to use Frida.

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Some "GUI" for actions with Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- You can find some Awesome Frida scripts here: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Try to bypass anti-debugging / anti-frida mechanisms loading Frida as in indicated in [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump mémoire - Fridump**

Vérifiez si l'application stocke des informations sensibles en mémoire qu'elle ne devrait pas conserver, comme des mots de passe ou des mnémoniques.

Using [**Fridump3**](https://github.com/rootbsd/fridump3) you can dump the memory of the app with:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Cela va dump la mémoire dans le dossier ./dump, et vous pouvez y utiliser grep avec quelque chose comme :
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Données sensibles dans Keystore**

Dans Android, le Keystore est le meilleur endroit pour stocker des données sensibles ; cependant, avec des privilèges suffisants il est toujours **possible d'y accéder**. Comme les applications ont tendance à y stocker **des données sensibles en clair**, les pentests devraient le vérifier en tant que root user, car une personne ayant un accès physique à l'appareil pourrait être en mesure de voler ces données.

Même si une application stockait des données dans le Keystore, elles devraient être chiffrées.

Pour accéder aux données à l'intérieur du Keystore, vous pouvez utiliser ce script Frida : [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

En utilisant le script Frida suivant, il pourrait être possible de **bypass fingerprint authentication** que les applications Android effectuent afin de **protéger certaines zones sensibles :**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Images d'arrière-plan**

Quand vous placez une application en arrière-plan, Android enregistre un **instantané de l'application** de sorte que, lorsque celle-ci revient au premier plan, il commence par charger l'image avant l'application, donnant l'impression que l'application s'est chargée plus rapidement.

Cependant, si cet instantané contient **des informations sensibles**, quelqu'un ayant accès à l'instantané pourrait **voler ces informations** (notez que vous avez besoin de root pour y accéder).

Les instantanés sont généralement stockés ici : **`/data/system_ce/0/snapshots`**

Android fournit un moyen de **prévenir la capture d'écran en définissant le paramètre layout FLAG_SECURE**. En utilisant ce flag, le contenu de la fenêtre est traité comme sécurisé, l'empêchant d'apparaître dans des captures d'écran ou d'être affiché sur des écrans non sécurisés.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Cet outil peut vous aider à gérer différents outils lors de l'analyse dynamique : [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Les développeurs créent souvent des composants proxy comme activities, services et broadcast receivers qui traitent ces Intents et les transmettent à des méthodes telles que `startActivity(...)` ou `sendBroadcast(...)`, ce qui peut être risqué.

Le danger réside dans le fait de permettre à des attaquants de déclencher des composants d'application non-exportés ou d'accéder à des content providers sensibles en détournant ces Intents. Un exemple notable est le composant `WebView` qui convertit des URL en objets `Intent` via `Intent.parseUri(...)` puis les exécute, pouvant conduire à des Intent injections malveillantes.

### Essential Takeaways

- **Intent Injection** est similaire au problème Open Redirect du web.
- Les exploits consistent à passer des objets `Intent` en tant qu'extras, qui peuvent être redirigés pour exécuter des opérations non sécurisées.
- Cela peut exposer des composants non-exportés et des content providers aux attaquants.
- La conversion d'URL en `Intent` par `WebView` peut faciliter des actions non souhaitées.

### Android Client Side Injections and others

Vous connaissez probablement ce type de vulnérabilités depuis le Web. Il faut être particulièrement vigilant concernant ces vulnérabilités dans une application Android :

- **SQL Injection:** Quand vous traitez des requêtes dynamiques ou des Content-Providers, assurez-vous d'utiliser des requêtes paramétrées.
- **JavaScript Injection (XSS):** Vérifiez que le support JavaScript et Plugin est désactivé pour tous les WebViews (désactivé par défaut). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** Les WebViews devraient avoir l'accès au système de fichiers désactivé (activé par défaut) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: Dans plusieurs cas, lorsque l'application Android termine la session, le cookie n'est pas révoqué ou peut être même enregistré sur le disque
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Analyse automatique

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Analyse statique**

![](<../../images/image (866).png>)

**Évaluation des vulnérabilités de l'application** à l'aide d'une interface web conviviale. Vous pouvez également effectuer une analyse dynamique (mais vous devez préparer l'environnement).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notez que MobSF peut analyser **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Aussi, si vous créez un fichier **ZIP** avec le code source d'une appli **Android** ou **IOS** (allez dans le dossier racine de l'application, sélectionnez tout et créez un ZIPfile), MobSF pourra l'analyser également.

MobSF permet aussi de faire des **diff/Compare** d'analyses et d'intégrer **VirusTotal** (vous devrez définir votre API key dans _MobSF/settings.py_ et l'activer : `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). Vous pouvez aussi définir `VT_UPLOAD` à `False`, alors le **hash** sera **upload** au lieu du fichier.

### Assisted Dynamic analysis with MobSF

**MobSF** peut aussi être très utile pour l'**dynamic analysis** sur **Android**, mais dans ce cas vous devrez installer MobSF et **genymotion** sur votre hôte (une VM ou Docker ne fonctionnera pas). _Note : Vous devez **start first a VM in genymotion** puis **then MobSF.**_\
Le **MobSF dynamic analyser** peut :

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). Tout cela est fait automatiquement sauf pour les captures d'écran : vous devez appuyer quand vous voulez une capture d'écran ou appuyer sur "**Exported Activity Tester**" pour obtenir des captures de toutes les activités exportées.
- Capture le **HTTPS traffic**
- Utiliser **Frida** pour obtenir des informations **runtime**

À partir des versions **Android > 5**, il **automatiquement start Frida** et configurera les paramètres globaux de **proxy** pour **capture** le trafic. Il ne capturera que le trafic de l'application testée.

**Frida**

Par défaut, il utilisera aussi certains Frida Scripts pour **bypass SSL pinning**, **root detection** et **debugger detection** et pour **monitor interesting APIs**.\
MobSF peut aussi **invoke exported activities**, prendre des **screenshots** de celles-ci et les **save** pour le rapport.

Pour **start** le testing dynamique appuyez sur le bouton vert : "**Start Instrumentation**". Appuyez sur "**Frida Live Logs**" pour voir les logs générés par les Frida scripts et sur "**Live API Monitor**" pour voir toutes les invocations vers les méthodes hookées, les arguments passés et les valeurs retournées (cela apparaîtra après avoir pressé "Start Instrumentation").\
MobSF permet aussi de charger vos propres **Frida scripts** (pour envoyer les résultats de vos Frida scripts à MobSF utilisez la fonction `send()`). Il propose également **plusieurs scripts pré-écrits** que vous pouvez charger (vous pouvez en ajouter d'autres dans `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), il suffit de **les sélectionner**, appuyer sur "**Load**" puis sur "**Start Instrumentation**" (vous pourrez voir les logs de ces scripts dans "**Frida Live Logs**").

![](<../../images/image (419).png>)

De plus, vous disposez de quelques fonctionnalités auxiliaires Frida :

- **Enumerate Loaded Classes** : affichera toutes les classes chargées
- **Capture Strings** : affichera toutes les chaînes capturées pendant l'utilisation de l'application (très verbeux)
- **Capture String Comparisons** : peut être très utile. Il **montrera les 2 strings being compared** et si le résultat était True ou False.
- **Enumerate Class Methods** : indiquez le nom de la classe (comme "java.io.File") et il imprimera toutes les méthodes de la classe.
- **Search Class Pattern** : recherche des classes par pattern
- **Trace Class Methods** : **Trace** une **whole class** (voir les inputs et outputs de toutes les méthodes de la class). Souvenez-vous que par défaut MobSF trace plusieurs méthodes Android Api intéressantes.

Une fois que vous avez sélectionné le module auxiliaire que vous voulez utiliser, vous devez appuyer sur "**Start Intrumentation**" et vous verrez toutes les sorties dans "**Frida Live Logs**".

**Shell**

Mobsf fournit aussi un shell avec quelques commandes **adb**, des **MobSF commands**, et des **shell** **commands** communes en bas de la page d'analyse dynamique. Quelques commandes intéressantes :
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**Outils HTTP**

When http traffic is capture you can see an ugly view of the captured traffic on "**HTTP(S) Traffic**" bottom or a nicer view in "**Start HTTPTools**" green bottom. From the second option, you can **send** the **captured requests** to **proxies** like Burp or Owasp ZAP.\
To do so, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> press "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Une fois l'analyse dynamique terminée avec MobSF vous pouvez appuyer sur "**Start Web API Fuzzer**" pour **fuzzer les requêtes HTTP** et rechercher des vulnérabilités.

> [!TIP]
> Après avoir effectué une analyse dynamique avec MobSF, les paramètres du proxy peuvent être mal configurés et vous ne pourrez pas les corriger depuis l'interface graphique. Vous pouvez réparer les paramètres du proxy en exécutant :
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

You can get the tool from [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Cet outil utilise certains **Hooks** pour vous indiquer **ce qui se passe dans l'application** pendant que vous effectuez une **analyse dynamique**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

C'est un **excellent outil pour effectuer une analyse statique avec une interface graphique**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Cet outil est conçu pour rechercher plusieurs **vulnérabilités liées à la sécurité des applications Android**, que ce soit dans le **code source** ou dans des **APKs packagés**. L'outil est également capable de créer un APK déployable de type "Proof-of-Concept" et des **ADB commands**, pour exploiter certaines des vulnérabilités trouvées (Exposed activities, intents, tapjacking...). Comme avec Drozer, il n'est pas nécessaire de rooter l'appareil de test.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Affiche tous les fichiers extraits pour une consultation facile
- Décompile automatiquement les fichiers APK en Java et Smali
- Analyse AndroidManifest.xml pour les vulnérabilités et comportements courants
- Analyse statique du code source pour les vulnérabilités et comportements courants
- Informations sur l'appareil
- et plus
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER est une application en ligne de commande utilisable sous Windows, MacOS X et Linux, qui analyse les fichiers _.apk_ à la recherche de vulnérabilités. Elle fonctionne en décompressant les APKs et en appliquant une série de règles pour détecter ces vulnérabilités.

Toutes les règles sont centralisées dans le fichier `rules.json`, et chaque entreprise ou testeur peut créer ses propres règles pour analyser ce dont ils ont besoin.

Téléchargez les derniers binaires sur la [page de téléchargement](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn est un outil **multi-plateforme** qui aide les développeurs, bugbounty hunters et ethical hackers effectuant [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) sur des applications mobiles.

Le principe est de glisser-déposer votre fichier d'application mobile (un fichier .apk ou .ipa) dans l'application StaCoAn ; elle générera pour vous un rapport visuel et portable. Vous pouvez ajuster les paramètres et wordlists pour obtenir une expérience personnalisée.

Télécharger[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework est un système d'analyse de vulnérabilités Android qui aide les développeurs ou hackers à trouver des vulnérabilités potentielles dans les applications Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** est un outil dont le principal objectif est de détecter et d'avertir l'utilisateur des comportements potentiellement malveillants développés par une application Android.

La détection est effectuée par la **static analysis** du bytecode Dalvik de l'application, représenté en **Smali**, à l'aide de la bibliothèque [`androguard`](https://github.com/androguard/androguard).

Cet outil recherche les **common behavior of "bad" applications** comme : Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** est un framework d'ingénierie inverse et d'analyse d'applications mobiles. C'est un outil qui regroupe des outils couramment utilisés pour la rétro-ingénierie et l'analyse d'applications mobiles, afin d'aider à tester les applications mobiles contre les menaces de sécurité mobile OWASP. Son objectif est de rendre cette tâche plus facile et plus accessible pour les développeurs d'applications mobiles et les professionnels de la sécurité.

Il permet de :

- Extraire du code Java et Smali en utilisant différents outils
- Analyser des APKs en utilisant : [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Extraire des informations privées depuis l'APK en utilisant des regexps.
- Analyser le Manifest.
- Analyser les domaines trouvés en utilisant : [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) et [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Déobfusquer un APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Utile pour détecter les malwares : [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Notez que selon le service et la configuration que vous utilisez pour obfusquer le code, les secrets peuvent ou non rester obfusqués.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

D'après [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** est un outil open source en ligne de commande qui réduit, optimise et obfusque le code Java. Il est capable d'optimiser le bytecode ainsi que de détecter et supprimer les instructions inutilisées. ProGuard est un logiciel libre distribué sous la GNU General Public License, version 2.

ProGuard est distribué dans l'Android SDK et s'exécute lors de la compilation de l'application en release mode.

### [DexGuard](https://www.guardsquare.com/dexguard)

Trouvez un guide pas à pas pour déobfusquer l'apk sur [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(D'après ce guide) La dernière fois que nous avons vérifié, le mode d'opération de DexGuard était :

- charger une ressource en tant qu'InputStream ;
- passer le résultat à une classe héritant de FilterInputStream pour le décrypter ;
- effectuer quelques obfuscations inutiles pour faire perdre quelques minutes à un reverser ;
- passer le résultat décrypté à un ZipInputStream pour obtenir un fichier DEX ;
- enfin charger le DEX résultant comme Resource en utilisant la méthode `loadDex`.

### [DeGuard](http://apk-deguard.com)

**DeGuard inverse le processus d'obfuscation effectué par les outils d'obfuscation Android. Cela permet de nombreuses analyses de sécurité, y compris l'inspection du code et la prédiction des bibliothèques.**

Vous pouvez téléverser un APK obfusqué sur leur plateforme.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

C'est un **déobfusqueur Android générique.** Simplify **exécute virtuellement une app** pour comprendre son comportement puis **essaie d'optimiser le code** afin qu'il se comporte de manière identique mais soit plus facile à comprendre pour un humain. Chaque type d'optimisation est simple et générique, donc peu importe le type spécifique d'obfuscation utilisé.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD vous donne des informations sur **la façon dont un APK a été créé**. Il identifie de nombreux **compilers**, **packers**, **obfuscators**, et d'autres trucs bizarres. C'est [_PEiD_](https://www.aldeid.com/wiki/PEiD) pour Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b est une machine virtuelle de sécurité Android basée sur ubuntu-mate qui inclut une collection des derniers frameworks, tutoriels et labs de différents passionnés et chercheurs en sécurité pour la rétro-ingénierie et l'analyse de malware.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) C'est une excellente liste de ressources
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Cours rapide Android
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
