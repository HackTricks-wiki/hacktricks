# Pentesting des Applications Android

{{#include ../../banners/hacktricks-training.md}}

## Notions de base des Applications Android

Il est fortement recommandé de commencer par lire cette page pour connaître les **parties les plus importantes liées à la sécurité Android et les composants les plus dangereux d'une application Android** :


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

C'est l'outil principal dont vous avez besoin pour vous connecter à un appareil Android (émulé ou physique).\
**ADB** permet de contrôler des appareils soit via **USB** soit via **Network** depuis un ordinateur. Cet outil permet la **copie** de fichiers dans les deux sens, l'**installation** et la **désinstallation** d'apps, l'**exécution** de commandes shell, la **sauvegarde** des données, la **lecture** des logs, entre autres fonctions.

Consultez la liste suivante des [**ADB Commands**](adb-commands.md) pour apprendre à utiliser adb.

## Smali

Parfois il est intéressant de **modifier le code de l'application** pour accéder à des **informations cachées** (peut-être des mots de passe fortement obfusqués ou des flags). Dans ce cas, il peut être utile de décompiler le apk, modifier le code et le recompiler.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Cela peut être très utile comme **alternative pour plusieurs tests lors de l'analyse dynamique** qui vont être présentés. Ainsi, **gardez toujours à l'esprit cette possibilité**.

## Autres astuces intéressantes

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **Télécharger des APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Extraire l'APK depuis l'appareil:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Fusionnez tous les splits et les apks de base avec [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Études de cas & Vulnérabilités


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Analyse statique

Tout d'abord, pour analyser un APK vous devriez **examiner le code Java** à l'aide d'un decompiler.\
Veuillez, [**lire ici pour trouver des informations sur les différents decompilers disponibles**](apk-decompilers.md).

### Recherche d'informations intéressantes

En examinant simplement les **strings** de l'APK vous pouvez rechercher des **mots de passe**, des **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), des clés **api**, des éléments liés à **encryption**, des **bluetooth uuids**, des **tokens** et tout ce qui est intéressant... cherchez même des backdoors d'exécution de code ou des backdoors d'authentification (credentials admin hardcodés dans l'app).

**Firebase**

Portez une attention particulière aux **Firebase URLs** et vérifiez si la configuration est incorrecte. [Plus d'informations sur ce qu'est Firebase et comment l'exploiter ici.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Compréhension de base de l'application - Manifest.xml, strings.xml

L'**examen des fichiers _Manifest.xml_ et _strings.xml_ d'une application peut révéler des vulnérabilités de sécurité potentielles**. Ces fichiers peuvent être consultés avec des decompilers ou en renommant l'extension du fichier APK en .zip puis en le décompressant.

**Vulnérabilités** identifiées à partir du **Manifest.xml** incluent :

- **Applications debuggables**: Les applications définies comme debuggable (`debuggable="true"`) dans le fichier _Manifest.xml_ présentent un risque car elles permettent des connexions qui peuvent mener à une exploitation. Pour mieux comprendre comment exploiter des applications debuggables, consultez un tutoriel sur la découverte et l'exploitation d'applications debuggables sur un device.
- **Paramètres de backup**: L'attribut `android:allowBackup="false"` devrait être explicitement défini pour les applications traitant des informations sensibles afin d'empêcher des sauvegardes non autorisées via adb, surtout lorsque usb debugging est activé.
- **Network Security**: Des configurations réseau personnalisées (`android:networkSecurityConfig="@xml/network_security_config"`) dans _res/xml/_ peuvent spécifier des détails de sécurité comme le pinning de certificats et les paramètres de trafic HTTP. Un exemple est d'autoriser le trafic HTTP pour des domaines spécifiques.
- **Exported Activities and Services**: Identifier les activités et services exportés dans le manifest peut mettre en évidence des composants susceptibles d'être détournés. Une analyse plus poussée lors des tests dynamiques peut révéler comment exploiter ces composants.
- **Content Providers and FileProviders**: Des content providers exposés pourraient permettre un accès ou une modification non autorisés des données. La configuration des FileProviders doit également être examinée.
- **Broadcast Receivers and URL Schemes**: Ces composants pourraient être utilisés pour l'exploitation, en portant une attention particulière à la manière dont les URL schemes sont gérés pour les vulnérabilités d'entrée.
- **SDK Versions**: Les attributs `minSdkVersion`, `targetSDKVersion`, et `maxSdkVersion` indiquent les versions Android supportées, soulignant l'importance de ne pas supporter des versions Android obsolètes et vulnérables pour des raisons de sécurité.

À partir du fichier **strings.xml**, des informations sensibles telles que des clés API, des schemas personnalisés et d'autres notes de développeurs peuvent être découvertes, ce qui souligne la nécessité d'un examen attentif de ces ressources.

### Tapjacking

**Tapjacking** est une attaque où une **malicious application** est lancée et **se positionne au-dessus d'une application victime**. Une fois qu'elle obscurcit visuellement l'application victime, son interface utilisateur est conçue de telle manière qu'elle trompe l'utilisateur pour qu'il interagisse avec elle, tout en transmettant l'interaction à l'application victime.\
En pratique, c'est **aveugler l'utilisateur afin qu'il ne sache pas qu'il effectue en réalité des actions sur l'application victime**.

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Une **activity** avec le **`launchMode`** défini sur **`singleTask` sans aucun `taskAffinity`** est vulnérable au Task Hijacking. Cela signifie qu'une **application** peut être installée et si elle est lancée avant la vraie application elle pourrait **détourner la tâche de la vraie application** (ainsi l'utilisateur interagira avec la **malicious application** en pensant utiliser la vraie).

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Stockage de données non sécurisé

Internal Storage

En Android, les fichiers **stockés** en **internal** storage sont **conçus** pour être **accessibles** exclusivement par l'**app** qui les a **créés**. Cette mesure de sécurité est **appliquée** par le système d'exploitation Android et est généralement adéquate pour les besoins de sécurité de la plupart des applications. Cependant, les développeurs utilisent parfois des modes tels que `MODE_WORLD_READABLE` et `MODE_WORLD_WRITABLE` pour **permettre** que des fichiers soient **partagés** entre différentes applications. Or, ces modes **ne restreignent pas l'accès** à ces fichiers par d'autres applications, y compris potentiellement malveillantes.

1. **Static Analysis:**
- **Vérifier** soigneusement l'utilisation de `MODE_WORLD_READABLE` et `MODE_WORLD_WRITABLE`. Ces modes **peuvent potentiellement exposer** des fichiers à un **accès non intentionnel ou non autorisé**.
2. **Dynamic Analysis:**
- **Valider** les **permissions** définies sur les fichiers créés par l'app. Plus précisément, **vérifiez** si des fichiers sont **réglés comme lisibles ou modifiables par tous**. Cela peut constituer un risque de sécurité significatif, car cela permettrait à **n'importe quelle application** installée sur le device, quelle que soit son origine ou son intention, de **lire ou modifier** ces fichiers.

External Storage

Lorsqu'on traite des fichiers sur le **external storage**, comme les SD Cards, certaines précautions doivent être prises :

1. **Accessibilité**:
- Les fichiers sur external storage sont **globalement lisibles et modifiables**. Cela signifie que n'importe quelle application ou utilisateur peut accéder à ces fichiers.
2. **Préoccupations de sécurité**:
- Étant donné la facilité d'accès, il est conseillé **de ne pas stocker d'informations sensibles** sur l'external storage.
- L'external storage peut être retiré ou accédé par n'importe quelle application, le rendant moins sécurisé.
3. **Traitement des données provenant de l'external storage**:
- Effectuez toujours une **validation d'entrée** sur les données récupérées depuis l'external storage. C'est crucial car ces données proviennent d'une source non fiable.
- Il est fortement déconseillé de stocker des exécutables ou des fichiers de classes sur external storage pour les charger dynamiquement.
- Si votre application doit récupérer des fichiers exécutables depuis l'external storage, assurez-vous que ces fichiers sont **signés et vérifiés cryptographiquement** avant d'être chargés dynamiquement. Cette étape est vitale pour maintenir l'intégrité de sécurité de votre application.

External storage peut être **accédé** dans `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> Starting with Android 4.4 (**API 17**), the SD card has a directory structure which **limits access from an app to the directory which is specifically for that app**. This prevents malicious application from gaining read or write access to another app's files.

Données sensibles stockées en clair

- **Shared preferences**: Android permet à chaque application de facilement sauvegarder des fichiers xml dans le chemin `/data/data/<packagename>/shared_prefs/` et parfois il est possible de trouver des informations sensibles en clear-text dans ce dossier.
- **Databases**: Android permet à chaque application de facilement sauvegarder des bases sqlite dans le chemin `/data/data/<packagename>/databases/` et parfois il est possible de trouver des informations sensibles en clear-text dans ce dossier.

### TLS compromis

Accepter tous les certificats

Pour une raison quelconque, certains développeurs acceptent parfois tous les certificats même si, par exemple, le hostname ne correspond pas, avec des lignes de code comme la suivante :
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Une bonne façon de tester cela est d'essayer de capturer le trafic en utilisant un proxy comme Burp sans autoriser Burp CA à l'intérieur de l'appareil. De plus, vous pouvez générer avec Burp un certificat pour un hostname différent et l'utiliser.

### Cryptographie défaillante

**Mauvaises pratiques de gestion des clés**

Certains développeurs enregistrent des données sensibles dans le stockage local et les chiffrent avec une clé codée en dur/prévisible dans le code. Cela ne devrait pas être fait car du reversing pourrait permettre à des attaquants d'extraire l'information confidentielle.

**Utilisation d'algorithmes non sécurisés et/ou obsolètes**

Les développeurs ne devraient pas utiliser des **deprecated algorithms** pour effectuer des **checks** d'authorisation, **stocker** ou **envoyer** des données. Certains de ces algorithmes sont : RC4, MD4, MD5, SHA1... Si des **hashes** sont utilisés pour stocker des mots de passe par exemple, il faut utiliser des hashes résistants au brute-force avec du salt.

### Autres vérifications

- Il est recommandé d'**obfusquer l'APK** pour rendre plus difficile le travail de reverse engineering pour les attaquants.
- Si l'app est sensible (comme des apps bancaires), elle devrait effectuer ses **propres vérifications pour détecter si le mobile est rooted** et agir en conséquence.
- Si l'app est sensible (comme des apps bancaires), elle devrait vérifier si un **emulator** est utilisé.
- Si l'app est sensible (comme des apps bancaires), elle devrait **vérifier son intégrité avant exécution** pour détecter si elle a été modifiée.
- Utilisez [**APKiD**](https://github.com/rednaga/APKiD) pour vérifier quel compiler/packer/obfuscator a été utilisé pour construire l'APK

### Application React Native

Lisez la page suivante pour apprendre comment accéder facilement au code javascript des applications React :


{{#ref}}
react-native-application.md
{{#endref}}

### Applications Xamarin

Lisez la page suivante pour apprendre comment accéder facilement au code C# d'une application xamarin :


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Applications Superpacked

Selon ce [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/), superpacked est un algorithme Meta qui compresse le contenu d'une application en un seul fichier. Le blog parle de la possibilité de créer une app qui décompresse ce type d'apps... et d'une méthode plus rapide qui consiste à **exécuter l'application et récupérer les fichiers décompressés depuis le filesystem.**

### Analyse statique automatisée du code

L'outil [**mariana-trench**](https://github.com/facebook/mariana-trench) est capable de trouver des **vulnerabilities** en **scannant** le **code** de l'application. Cet outil contient une série de **known sources** (qui indiquent à l'outil les **endroits** où l'**input** est **contrôlé par l'utilisateur**), **sinks** (qui indiquent à l'outil les **endroits** **dangereux** où un input malveillant pourrait causer des dommages) et des **rules**. Ces rules indiquent la **combinaison** de **sources-sinks** qui signale une vulnérabilité.

Avec ces informations, **mariana-trench analysera le code et trouvera d'éventuelles vulnérabilités**.

### Secrets leaked

Une application peut contenir des secrets (API keys, passwords, hidden urls, subdomains...) en son sein que vous pourriez découvrir. Vous pouvez utiliser un outil tel que [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Contourner l'authentification biométrique


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Autres fonctions intéressantes

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** déclarées comme `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)

### **Autres astuces**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Analyse dynamique

> Tout d'abord, vous avez besoin d'un environnement où vous pouvez installer l'application et tout l'environnement (certificat Burp CA, Drozer et Frida principalement). Par conséquent, un appareil rooted (émulé ou non) est fortement recommandé.

### Analyse dynamique en ligne

Vous pouvez créer un **compte gratuit** sur : [https://appetize.io/](https://appetize.io). Cette plateforme permet de **uploader** et **exécuter** des APKs, elle est donc utile pour voir comment un APK se comporte.

Vous pouvez même **voir les logs de votre application** sur le web et vous connecter via **adb**.

![](<../../images/image (831).png>)

Grâce à la connexion ADB vous pouvez utiliser **Drozer** et **Frida** à l'intérieur des emulators.

### Analyse dynamique locale

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (Vous pouvez créer des devices **x86** et **arm**, et selon [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**les dernières versions x86** prennent en charge les **ARM libraries** sans avoir besoin d'un emulator ARM lent).
- Apprenez à le configurer sur cette page :


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Version gratuite :** Personal Edition, vous devez créer un compte. _Il est recommandé de **télécharger** la version **AVEC**_ _**VirtualBox** pour éviter des erreurs potentielles._)
- [**Nox**](https://es.bignox.com) (Gratuit, mais il ne supporte pas Frida ou Drozer).

> [!TIP]
> Lors de la création d'un nouvel emulator sur n'importe quelle plateforme, souvenez-vous que plus l'écran est grand, plus l'emulator sera lent. Préférez donc des écrans petits si possible.

Pour **installer google services** (comme AppStore) dans Genymotion vous devez cliquer sur le bouton marqué en rouge de l'image suivante :

![](<../../images/image (277).png>)

Aussi, notez que dans la **configuration de la Android VM dans Genymotion** vous pouvez sélectionner le **Bridge Network mode** (cela sera utile si vous vous connectez à la Android VM depuis une autre VM contenant les outils).

#### Utilisation d'un appareil physique

Vous devez activer les options de **debugging** et il est préférable de pouvoir le **rooter** :

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Une fois que vous avez installé l'application, la première chose à faire est de l'essayer et d'étudier ce qu'elle fait, comment elle fonctionne et vous familiariser avec elle.\
> Je suggère d'**effectuer cette analyse dynamique initiale en utilisant MobSF dynamic analysis + pidcat**, ainsi nous pourrons **apprendre comment l'application fonctionne** pendant que MobSF **capture** beaucoup de **données intéressantes** que vous pourrez revoir plus tard.

### Fuites de données non intentionnelles

**Logging**

Les développeurs doivent se méfier d'exposer des **debugging information** publiquement, car cela peut conduire à des données sensibles leaks. Les outils [**pidcat**](https://github.com/JakeWharton/pidcat) et `adb logcat` sont recommandés pour surveiller les logs de l'application afin d'identifier et protéger les informations sensibles. **Pidcat** est préféré pour sa simplicité et sa lisibilité.

> [!WARNING]
> Notez que depuis **les versions plus récentes qu'Android 4.0**, **les applications ne peuvent accéder qu'à leurs propres logs**. Ainsi, les applications ne peuvent pas accéder aux logs des autres apps.\
> Quoi qu'il en soit, il est toujours recommandé de **ne pas logger d'informations sensibles**.

**Copy/Paste Buffer Caching**

Le framework **clipboard-based** d'Android permet la fonctionnalité copier-coller dans les apps, mais présente un risque car **d'autres applications** peuvent **accéder** au clipboard, exposant potentiellement des données sensibles. Il est crucial de **désactiver copy/paste** pour les sections sensibles d'une application, comme les informations de carte bancaire, afin d'empêcher des data leaks.

**Crash Logs**

Si une application **crashe** et **sauvegarde des logs**, ces logs peuvent aider des attaquants, particulièrement lorsque l'application ne peut pas être reverse-engineered. Pour atténuer ce risque, évitez de logger lors des crashes, et si les logs doivent être transmis sur le réseau, assurez-vous qu'ils sont envoyés via un canal SSL pour la sécurité.

En tant que pentester, **essayez de jeter un coup d'œil à ces logs**.

**Analytics Data Sent To 3rd Parties**

Les applications intègrent souvent des services comme Google Adsense, qui peuvent involontairement leak des données sensibles en raison d'une implémentation incorrecte par les développeurs. Pour identifier d'éventuels data leaks, il est conseillé d'intercepter le trafic de l'application et de vérifier si des informations sensibles sont envoyées à des services tiers.

### SQLite DBs

La plupart des applications utilisent des bases de données SQLite internes pour sauvegarder des informations. Pendant le pentest, jetez un coup d'œil aux databases créées, aux noms des tables et des colonnes et à toutes les données sauvegardées car vous pourriez trouver des informations sensibles (ce qui constituerait une vulnérabilité).\
Les databases devraient se trouver dans /data/data/the.package.name/databases comme /data/data/com.mwr.example.sieve/databases

Si la database sauvegarde des informations confidentielles et est **encryptée** mais que vous pouvez **trouver** le **mot de passe** à l'intérieur de l'application, c'est toujours une **vulnérabilité**.

Énumérez les tables en utilisant `.tables` et énumérez les colonnes des tables en faisant `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

D'après les [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf) : **Drozer** permet d'assumer le rôle d'une application Android et d'interagir avec d'autres apps. Il peut faire tout ce qu'une application installée peut faire, comme utiliser le mécanisme Inter-Process Communication (IPC) d'Android et interagir avec le système d'exploitation sous-jacent.\
Drozer est un outil utile pour **exploiter les exported activities, exported services et Content Providers** comme vous l'apprendrez dans les sections suivantes.

### Exploitation des exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Souvenez-vous aussi que le code d'une activity commence dans la méthode **`onCreate`**.

**Authorisation bypass**

Quand une Activity est exported vous pouvez invoquer son écran depuis une app externe. Donc, si une activity contenant des **sensitive information** est **exported** vous pourriez **bypass** les mécanismes d'**authentication** pour y accéder.

[**Apprenez comment exploiter les exported activities avec Drozer.**](drozer-tutorial/index.html#activities)

Vous pouvez aussi démarrer une activity exportée depuis adb :

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> Note that an authorisation bypass is not always a vulnerability, it would depend on how the bypass works and which information is exposed.

**Sensitive information leakage**

**Activities can also return results**. If you manage to find an exported and unprotected activity calling the **`setResult`** method and **returning sensitive information**, there is a sensitive information leakage.

#### Tapjacking

If tapjacking isn't prevented, you could abuse the exported activity to make the **user perform unexpected actions**. For more info about [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers are basically used to **share data**. If an app has available content providers you may be able to **extract sensitive** data from them. It also interesting to test possible **SQL injections** and **Path Traversals** as they could be vulnerable.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Remember that a the actions of a Service start in the method `onStartCommand`.

As service is basically something that **can receive data**, **process** it and **returns** (or not) a response. Then, if an application is exporting some services you should **check** the **code** to understand what is it doing and **test** it **dynamically** for extracting confidential info, bypassing authentication measures...\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Remember that a the actions of a Broadcast Receiver start in the method `onReceive`.

A broadcast receiver will be waiting for a type of message. Depending on ho the receiver handles the message it could be vulnerable.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

You can look for deep links manually, using tools like MobSF or scripts like [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
You can **open** a declared **scheme** using **adb** or a **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Notez que vous pouvez **omettre le nom du package** et que l'appareil mobile lancera automatiquement l'application qui doit ouvrir ce lien._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Code exécuté**

Pour trouver le **code qui sera exécuté dans l'application**, allez dans l'activité appelée par le deeplink et recherchez la fonction **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Informations sensibles**

Chaque fois que vous trouvez un deep link, vérifiez que **il ne reçoit pas de données sensibles (comme des mots de passe) via les paramètres d'URL**, car toute autre application pourrait **usurper le deep link et voler ces données !**

**Paramètres dans le chemin**

Vous **devez également vérifier si un deep link utilise un paramètre à l'intérieur du chemin** de l'URL comme : `https://api.example.com/v1/users/{username}` , dans ce cas vous pouvez forcer un path traversal en accédant à quelque chose comme : `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Notez que si vous trouvez les endpoints corrects dans l'application, vous pourriez provoquer un **Open Redirect** (si une partie du chemin est utilisée comme nom de domaine), un **account takeover** (si vous pouvez modifier les détails des utilisateurs sans token CSRF et que l'endpoint vulnérable utilisait la méthode appropriée) et toute autre vulnérabilité. More [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Inspection de la couche transport et échecs de vérification

- **Les certificats ne sont pas toujours correctement vérifiés** par les applications Android. Il est courant que ces applications ignorent les avertissements et acceptent des certificats auto-signés ou, dans certains cas, reviennent à des connexions HTTP.
- **Les négociations lors du handshake SSL/TLS sont parfois faibles**, utilisant des suites de chiffrement non sécurisées. Cette vulnérabilité rend la connexion susceptible à des attaques man-in-the-middle (MITM), permettant aux attaquants de déchiffrer les données.
- **Fuite d'informations privées** est un risque lorsque les applications authentifient via des canaux sécurisés mais communiquent ensuite via des canaux non sécurisés pour d'autres transactions. Cette approche ne protège pas les données sensibles, telles que les cookies de session ou les informations utilisateur, contre l'interception par des acteurs malveillants.

#### Vérification des certificats

Nous nous concentrerons sur **certificate verification**. L'intégrité du certificat du serveur doit être vérifiée pour renforcer la sécurité. C'est crucial car des configurations TLS non sécurisées et la transmission de données sensibles sur des canaux non chiffrés peuvent présenter des risques importants. Pour des étapes détaillées sur la vérification des certificats serveur et la correction des vulnérabilités, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) fournit des conseils complets.

#### SSL Pinning

SSL Pinning est une mesure de sécurité où l'application vérifie le certificat du serveur par rapport à une copie connue stockée dans l'application elle-même. Cette méthode est essentielle pour prévenir les attaques MITM. L'implémentation de SSL Pinning est fortement recommandée pour les applications manipulant des informations sensibles.

#### Inspection du trafic

Pour inspecter le trafic HTTP, il est nécessaire d'**installer le certificat de l'outil proxy** (par ex., Burp). Sans l'installation de ce certificat, le trafic chiffré pourrait ne pas être visible via le proxy. Pour un guide sur l'installation d'un certificat CA personnalisé, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Les applications ciblant **API Level 24 and above** nécessitent des modifications du Network Security Config pour accepter le certificat CA du proxy. Cette étape est critique pour inspecter le trafic chiffré. Pour des instructions sur la modification du Network Security Config, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

Si **Flutter** est utilisé, vous devez suivre les instructions sur [**this page**](flutter.md). Ceci est dû au fait que l'ajout du certificat dans le store ne fonctionnera pas, car Flutter a sa propre liste de CA valides.

#### Détection statique du SSL/TLS pinning

Avant de tenter des contournements à l'exécution, cartographiez rapidement où le pinning est appliqué dans l'APK. La découverte statique vous aide à planifier les hooks/patches et à vous concentrer sur les bons code paths.

Tool: SSLPinDetect
- Utilitaire open-source d'analyse statique qui décompile l'APK en Smali (via apktool) et scanne des patterns regex sélectionnés d'implémentations de SSL/TLS pinning.
- Rapporte le chemin de fichier exact, le numéro de ligne et un extrait de code pour chaque correspondance.
- Couvre les frameworks courants et les code paths personnalisés : OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, et Network Security Config XML pins.

Installation
- Prérequis : Python >= 3.8, Java dans le PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Utilisation
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Exemple de règles de motifs (JSON)
Utilisez ou étendez les signatures pour détecter des styles de pinning propriétaires/personnalisés. Vous pouvez charger votre propre JSON et scanner à grande échelle.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes et astuces
- Analyse rapide des grosses apps via multi-threading et memory-mapped I/O ; des regex pré-compilées réduisent l'overhead/les faux positifs.
- Collection de patterns: https://github.com/aancw/smali-sslpin-patterns
- Cibles typiques à trier ensuite :
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Declarative pins in res/xml network security config and manifest references
- Utilisez les emplacements trouvés pour planifier des Frida hooks, des patchs statiques, ou des revues de config avant les tests dynamiques.



#### Contourner SSL Pinning

Quand SSL Pinning est implémenté, le contourner devient nécessaire pour inspecter le trafic HTTPS. Différentes méthodes sont disponibles pour cela :

- Modifiez automatiquement l'**apk** pour **contourner** SSLPinning avec [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Le principal avantage de cette option est que vous n'aurez pas besoin de root pour contourner le SSL Pinning, mais vous devrez supprimer l'application et réinstaller la nouvelle, et cela ne fonctionnera pas toujours.
- Vous pouvez utiliser **Frida** (décrit ci-dessous) pour contourner cette protection. Voici un guide pour utiliser Burp+Frida+Genymotion : [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Vous pouvez aussi essayer de **contourner automatiquement SSL Pinning** en utilisant [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Vous pouvez aussi essayer de **contourner automatiquement SSL Pinning** en utilisant **MobSF dynamic analysis** (expliqué ci-dessous)
- Si vous pensez toujours qu'il y a du trafic que vous ne capturez pas, vous pouvez essayer de **rediriger le trafic vers burp en utilisant iptables**. Lisez ce blog : [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Recherche de vulnérabilités web courantes

Il est important de rechercher également les vulnérabilités web courantes dans l'application. Les informations détaillées sur l'identification et l'atténuation de ces vulnérabilités dépassent le cadre de ce résumé mais sont largement couvertes ailleurs.

### Frida

[Frida](https://www.frida.re) est un toolkit d'instrumentation dynamique pour développeurs, reverse-engineers, et chercheurs en sécurité.\
**Vous pouvez accéder à l'application en cours d'exécution et hooker des méthodes au runtime pour changer le comportement, modifier des valeurs, extraire des valeurs, exécuter du code différent...**\
Si vous voulez pentester des applications Android vous devez savoir utiliser Frida.

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Some "GUI" for actions with Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- You can find some Awesome Frida scripts here: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Try to bypass anti-debugging / anti-frida mechanisms loading Frida as in indicated in [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dumper la mémoire - Fridump**

Vérifiez si l'application stocke des informations sensibles en mémoire qu'elle ne devrait pas stocker, comme des mots de passe ou des mnémoniques.

En utilisant [**Fridump3**](https://github.com/rootbsd/fridump3) vous pouvez dumper la mémoire de l'app avec:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Cela va dump la mémoire dans le dossier ./dump, et là vous pouvez utiliser grep avec quelque chose comme :
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Données sensibles dans le Keystore**

Sur Android, le Keystore est l'endroit idéal pour stocker des données sensibles, cependant, avec des privilèges suffisants, il est toujours **possible d'y accéder**.

Comme les applications ont tendance à stocker ici des **données sensibles en clair**, les pentests doivent vérifier cela en tant qu'utilisateur root car quelqu'un ayant un accès physique à l'appareil pourrait être capable de voler ces données.

Même si une application stocke des données dans le keystore, les données doivent être chiffrées.

Pour accéder aux données dans le keystore, vous pouvez utiliser ce script Frida : [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

En utilisant le script Frida suivant, il peut être possible de **bypass fingerprint authentication** que des applications Android mettent en place afin de **protéger certaines zones sensibles :**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Images d'arrière-plan**

Lorsque vous placez une application en arrière-plan, Android enregistre un **snapshot de l'application** afin que, lorsqu'elle est ramenée au premier plan, il commence par charger l'image avant l'application, donnant l'impression que l'app s'est chargée plus rapidement.

Cependant, si ce snapshot contient des **informations sensibles**, une personne ayant accès au snapshot pourrait **voler ces informations** (note : il faut les privilèges root pour y accéder).

Les snapshots sont généralement stockés ici : **`/data/system_ce/0/snapshots`**

Android fournit un moyen de **prévenir la capture d'écran en définissant le paramètre FLAG_SECURE** du layout. En utilisant ce flag, le contenu de la fenêtre est traité comme sécurisé, l'empêchant d'apparaître dans des captures d'écran ou d'être affiché sur des écrans non sécurisés.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Cet outil peut vous aider à gérer différents outils lors de l'analyse dynamique : [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Les développeurs créent souvent des composants proxy comme activities, services et broadcast receivers qui traitent ces Intents et les transmettent à des méthodes telles que `startActivity(...)` ou `sendBroadcast(...)`, ce qui peut être risqué.

Le danger réside dans le fait de permettre à des attaquants de déclencher des composants d'application non-exportés ou d'accéder à des content providers sensibles en détournant ces Intents. Un exemple notable est le composant `WebView` convertissant des URLs en objets `Intent` via `Intent.parseUri(...)` puis les exécutant, ce qui peut conduire à des injections d'Intent malveillantes.

### Essential Takeaways

- **Intent Injection** is similar to web's Open Redirect issue.
- Exploits involve passing `Intent` objects as extras, which can be redirected to execute unsafe operations.
- It can expose non-exported components and content providers to attackers.
- `WebView`’s URL to `Intent` conversion can facilitate unintended actions.

### Android Client Side Injections and others

Vous connaissez probablement ce type de vulnérabilités depuis le Web. Vous devez être particulièrement prudent avec ces vulnérabilités dans une application Android :

- **SQL Injection:** Lors du traitement de requêtes dynamiques ou de Content-Providers, assurez-vous d'utiliser des requêtes paramétrées.
- **JavaScript Injection (XSS):** Vérifiez que le support JavaScript et Plugin est désactivé pour tous les WebViews (désactivé par défaut). [Plus d'infos ici](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** Les WebViews doivent avoir l'accès au système de fichiers désactivé (activé par défaut) - `(webview.getSettings().setAllowFileAccess(false);)`. [Plus d'infos ici](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: Dans plusieurs cas, quand l'application Android termine la session le cookie n'est pas révoqué ou il peut même être sauvegardé sur le disque
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Static analysis**

![](<../../images/image (866).png>)

**Vulnerability assessment of the application** using a nice web-based frontend. You can also perform dynamic analysis (but you need to prepare the environment).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Assisted Dynamic analysis with MobSF

**MobSF** can also be very helpful for **dynamic analysis** in **Android**, but in that case you will need to install MobSF and **genymotion** in your host (a VM or Docker won't work). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
The **MobSF dynamic analyser** can:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). All of this is done automatically except for the screenshots, you need to press when you want a screenshot or you need to press "**Exported Activity Tester**" to obtain screenshots of all the exported activities.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: It will print all the loaded classes
- **Capture Strings**: It will print all the capture strings while using the application (super noisy)
- **Capture String Comparisons**: Could be very useful. It will **show the 2 strings being compared** and if the result was True or False.
- **Enumerate Class Methods**: Put the class name (like "java.io.File") and it will print all the methods of the class.
- **Search Class Pattern**: Search classes by pattern
- **Trace Class Methods**: **Trace** a **whole class** (see inputs and outputs of all methods of th class). Remember that by default MobSF traces several interesting Android Api methods.

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf also brings you a shell with some **adb** commands, **MobSF commands**, and common **shell** **commands** at the bottom of the dynamic analysis page. Some interesting commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**Outils HTTP**

When HTTP traffic is capture you can see an ugly view of the captured traffic on "**HTTP(S) Traffic**" bouton ou une vue plus agréable dans le bouton vert "**Start HTTPTools**". From the second option, you can **envoyer** les **requêtes capturées** vers des **proxies** comme Burp ou Owasp ZAP.\
To do so, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> press "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Once you finish the dynamic analysis with MobSF you can press on "**Start Web API Fuzzer**" to **fuzz http requests** an look for vulnerabilities.

> [!TIP]
> After performing a dynamic analysis with MobSF the proxy settings me be misconfigured and you won't be able to fix them from the GUI. You can fix the proxy settings by doing:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Analyse dynamique assistée avec Inspeckage

You can get the tool from [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Cet outil utilise des **Hooks** pour vous indiquer **ce qui se passe dans l'application** pendant que vous effectuez une **analyse dynamique**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

C'est un **excellent outil pour effectuer une analyse statique avec une interface graphique**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Cet outil est conçu pour rechercher plusieurs **vulnérabilités de sécurité liées aux applications Android**, soit dans le **code source** soit dans des **APKs packagés**. L'outil est également **capable de créer un APK déployable "Proof-of-Concept"** et des **ADB commands**, pour exploiter certaines des vulnérabilités trouvées (Exposed activities, intents, tapjacking...). Comme avec Drozer, il n'est pas nécessaire de rooter l'appareil de test.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Affiche tous les fichiers extraits pour consultation facile
- Décompile automatiquement les fichiers APK au format Java et Smali
- Analyse AndroidManifest.xml à la recherche de vulnérabilités et de comportements courants
- Analyse statique du code source pour détecter des vulnérabilités et des comportements courants
- Informations sur l'appareil
- et plus encore
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER est une application en ligne de commande utilisable sous Windows, MacOS X et Linux, qui analyse les fichiers _.apk_ à la recherche de vulnérabilités. Elle le fait en décompressant les APK et en appliquant une série de règles pour détecter ces vulnérabilités.

Toutes les règles sont centralisées dans un fichier `rules.json`, et chaque entreprise ou testeur peut créer ses propres règles pour analyser ce dont il a besoin.

Téléchargez les derniers binaires depuis la [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn est un outil multiplateforme qui aide les développeurs, bugbounty hunters et ethical hackers à réaliser du static code analysis sur des applications mobiles.

Le principe est que vous glissez-déposez le fichier de votre application mobile (un .apk ou .ipa) sur l'application StaCoAn et elle génère un rapport visuel et portable pour vous. Vous pouvez ajuster les paramètres et les wordlists pour obtenir une expérience personnalisée.

Télécharger la [latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework est un système d'analyse des vulnérabilités Android qui aide les développeurs ou hackers à trouver des vulnérabilités de sécurité potentielles dans les applications Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** est un outil dont l'objectif principal est de détecter et d'avertir l'utilisateur des comportements potentiellement malveillants développés par une application Android.

La détection est effectuée via la **static analysis** du Dalvik bytecode de l'application, représenté en **Smali**, à l'aide de la bibliothèque [`androguard`](https://github.com/androguard/androguard).

Cet outil recherche les **comportements courants des applications "malveillantes"** tels que : Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** est un Framework d'ingénierie inverse et d'analyse d'applications mobiles (Mobile Application Reverse engineering and Analysis Framework). C'est un outil qui regroupe des outils couramment utilisés pour le reverse engineering et l'analyse d'applications mobiles, afin d'aider à tester les applications mobiles contre les menaces de sécurité mobile d'OWASP. Son objectif est de rendre cette tâche plus facile et plus accessible aux développeurs d'applications mobiles et aux professionnels de la sécurité.

Il peut :

- Extraire le code Java et Smali en utilisant différents outils
- Analyser les APKs en utilisant : [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Extraire des informations privées depuis l'APK en utilisant des regexps.
- Analyser le Manifest.
- Analyser les domaines trouvés en utilisant : [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) et [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Déobfusquer l'APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Utile pour détecter du malware: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Notez que, selon le service et la configuration utilisés pour obfusquer le code, les secrets peuvent ou non finir obfusqués.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

D'après [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** est un outil open source en ligne de commande qui réduit, optimise et obfusque le code Java. Il peut optimiser le bytecode ainsi que détecter et supprimer les instructions inutilisées. ProGuard est un logiciel libre et est distribué sous la GNU General Public License, version 2.

ProGuard est distribué dans le cadre de l'Android SDK et s'exécute lors de la compilation de l'application en mode release.

### [DexGuard](https://www.guardsquare.com/dexguard)

Trouvez un guide pas-à-pas pour déobfusquer l'apk sur [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(D'après ce guide) La dernière fois que nous avons vérifié, le mode de fonctionnement de Dexguard était :

- charger une ressource en tant que InputStream ;
- fournir le résultat à une classe héritant de FilterInputStream pour le déchiffrer ;
- effectuer une obfuscation inutile pour faire perdre quelques minutes à un reverser ;
- fournir le résultat déchiffré à un ZipInputStream pour obtenir un fichier DEX ;
- finalement charger le DEX résultant comme une Resource en utilisant la méthode `loadDex`.

### [DeGuard](http://apk-deguard.com)

**DeGuard inverse le processus d'obfuscation effectué par les outils d'obfuscation Android. Cela permet de nombreuses analyses de sécurité, notamment l'inspection de code et l'identification des bibliothèques.**

Vous pouvez téléverser un APK obfusqué sur leur plateforme.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

C'est un outil LLM pour trouver d'éventuelles vulnérabilités de sécurité dans des apps android et déobfusquer le code d'applications android. Utilise l'API publique Gemini de Google.

### [Simplify](https://github.com/CalebFenton/simplify)

C'est un **déobfuscateur android générique.** Simplify **exécute virtuellement une app** pour comprendre son comportement puis **essaie d'optimiser le code** afin qu'il se comporte de manière identique mais soit plus facile à comprendre pour un humain. Chaque type d'optimisation est simple et générique, donc peu importe le type spécifique d'obfuscation utilisé.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD vous donne des informations sur **comment un APK a été créé**. Il identifie de nombreux **compilers**, **packers**, **obfuscators**, et d'autres trucs bizarres. C'est [_PEiD_](https://www.aldeid.com/wiki/PEiD) pour Android.

### Manual

[Lisez ce tutoriel pour apprendre quelques astuces sur **la façon d'inverser une obfuscation personnalisée**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b est une machine virtuelle de sécurité Android basée sur ubuntu-mate ; elle inclut une collection des derniers frameworks, tutoriels et labs provenant de différents passionnés et chercheurs en sécurité pour le reverse engineering et l'analyse de malware.

## Références

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) C'est une excellente liste de ressources
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Cours rapide Android
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)

## À tester

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
