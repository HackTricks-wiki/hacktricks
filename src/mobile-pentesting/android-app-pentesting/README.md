# Pentesting Εφαρμογών Android

{{#include ../../banners/hacktricks-training.md}}

## Βασικά για Εφαρμογές Android

Συνίσταται ανεπιφύλακτα να ξεκινήσετε διαβάζοντας αυτή τη σελίδα για να μάθετε σχετικά με τα **πιο σημαντικά μέρη που σχετίζονται με την ασφάλεια Android και τα πιο επικίνδυνα συστατικά σε μια εφαρμογή Android**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Αυτό είναι το κύριο εργαλείο που χρειάζεστε για να συνδεθείτε με μια συσκευή Android (εξομοιωμένη ή φυσική).\
Η **ADB** επιτρέπει τον έλεγχο των συσκευών είτε μέσω **USB** είτε μέσω **Network** από έναν υπολογιστή. Αυτή η χρησιμότητα επιτρέπει την **αντιγραφή** αρχείων και στις δύο κατευθύνσεις, την **εγκατάσταση** και **απεγκατάσταση** εφαρμογών, την **εκτέλεση** εντολών shell, το **backup** δεδομένων, την **ανάγνωση** logs, μεταξύ άλλων λειτουργιών.

Ρίξτε μια ματιά στην παρακάτω λίστα με τους [**ADB Commands**](adb-commands.md) για να μάθετε πώς να χρησιμοποιείτε το adb.

## Smali

Μερικές φορές είναι χρήσιμο να **τροποποιήσετε τον κώδικα της εφαρμογής** για να αποκτήσετε πρόσβαση σε **κρυφές πληροφορίες** (π.χ. καλά obfuscated passwords ή flags). Σε αυτή την περίπτωση, μπορεί να είναι ενδιαφέρον να αποσυμπιέσετε το apk, να τροποποιήσετε τον κώδικα και να το επανασυγκροτήσετε.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Αυτό μπορεί να είναι πολύ χρήσιμο ως **εναλλακτική για διάφορα τεστ κατά τη διάρκεια της dynamic analysis** που θα παρουσιαστούν. Έτσι, **κρατήστε πάντα στο μυαλό αυτήν την πιθανότητα**.

## Other interesting tricks

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Εξαγωγή APK από τη συσκευή:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Συγχωνεύστε όλα τα splits και τα base apks με [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Μελέτες Περιπτώσεων & Ευπάθειες


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Static Analysis

Πρώτα απ' όλα, για την ανάλυση ενός APK θα πρέπει να **ρίξετε μια ματιά στον Java κώδικα** χρησιμοποιώντας έναν decompiler.\
Please, [**read here to find information about different available decompilers**](apk-decompilers.md).

### Looking for interesting Info

Απλώς κοιτάζοντας τα **strings** του APK μπορείτε να αναζητήσετε **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** και οτιδήποτε ενδιαφέρον... ψάξτε ακόμη και για code execution **backdoors** ή authentication backdoors (hardcoded admin credentials στην εφαρμογή).

**Firebase**

Δώστε ιδιαίτερη προσοχή σε **Firebase URLs** και ελέγξτε αν είναι κακώς ρυθμισμένο. [More information about whats is FIrebase and how to exploit it here.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Basic understanding of the application - Manifest.xml, strings.xml

Η **εξέταση του _Manifest.xml_ και των **_strings.xml_** αρχείων μιας εφαρμογής μπορεί να αποκαλύψει πιθανές ευπάθειες ασφαλείας**. Αυτά τα αρχεία μπορούν να προσεγγιστούν χρησιμοποιώντας decompilers ή μετονομάζοντας το αρχείο APK σε .zip και αποσυμπιέζοντάς το.

**Ευπάθειες** που εντοπίζονται από το **Manifest.xml** περιλαμβάνουν:

- **Debuggable Applications**: Εφαρμογές που έχουν οριστεί ως debuggable (`debuggable="true"`) στο _Manifest.xml_ αποτελούν ρίσκο καθώς επιτρέπουν συνδέσεις που μπορούν να οδηγήσουν σε εκμετάλλευση. Για περαιτέρω κατανόηση του πώς να εκμεταλλευτείτε debuggable εφαρμογές, ανατρέξτε σε οδηγό για την εύρεση και εκμετάλλευση debuggable εφαρμογών σε μια συσκευή.
- **Backup Settings**: Το χαρακτηριστικό `android:allowBackup="false"` θα πρέπει να ορίζεται ρητά για εφαρμογές που χειρίζονται ευαίσθητες πληροφορίες, για να αποτραπούν μη εξουσιοδοτημένα backups μέσω adb, ειδικά όταν είναι ενεργοποιημένο το usb debugging.
- **Network Security**: Προσαρμοσμένες ρυθμίσεις network security (`android:networkSecurityConfig="@xml/network_security_config"`) στο _res/xml/_ μπορούν να καθορίσουν λεπτομέρειες ασφαλείας όπως certificate pins και ρυθμίσεις HTTP traffic. Ένα παράδειγμα είναι η επιτρεπόμενη HTTP κίνηση για συγκεκριμένα domains.
- **Exported Activities and Services**: Η ταυτοποίηση exported activities και services στο manifest μπορεί να αναδείξει components που ενδεχομένως μπορούν να χρησιμοποιηθούν κακόβουλα. Περαιτέρω ανάλυση κατά τη διάρκεια dynamic testing μπορεί να αποκαλύψει πώς να εκμεταλλευτείτε αυτά τα components.
- **Content Providers and FileProviders**: Εκτεθειμένοι content providers θα μπορούσαν να επιτρέψουν μη εξουσιοδοτημένη πρόσβαση ή τροποποίηση δεδομένων. Η διαμόρφωση των FileProviders πρέπει επίσης να εξεταστεί προσεκτικά.
- **Broadcast Receivers and URL Schemes**: Αυτά τα components θα μπορούσαν να χρησιμοποιηθούν για εκμετάλλευση, με ιδιαίτερη προσοχή στον τρόπο διαχείρισης των URL schemes για ευπάθειες εισόδου.
- **SDK Versions**: Τα attributes `minSdkVersion`, `targetSDKVersion`, και `maxSdkVersion` υποδεικνύουν τις υποστηριζόμενες εκδόσεις Android, τονίζοντας τη σημασία του να μην υποστηρίζονται ξεπερασμένες, ευάλωτες εκδόσεις Android για λόγους ασφαλείας.

Από το αρχείο **strings.xml**, μπορούν να εντοπιστούν ευαίσθητες πληροφορίες όπως API keys, custom schemas και άλλα developer notes, υπογραμμίζοντας την ανάγκη για προσεκτική ανασκόπηση αυτών των πόρων.

### Tapjacking

Tapjacking είναι μια επίθεση όπου μια **malicious** **application** εκκινείται και τοποθετείται πάνω από μια victim application. Μόλις καλύψει οπτικά την victim app, το user interface της σχεδιάζεται έτσι ώστε να παραπλανήσει τον χρήστη να αλληλεπιδράσει με αυτή, ενώ ταυτόχρονα προωθεί την αλληλεπίδραση στην victim app.\
Ουσιαστικά, τυφλώνει τον χρήστη ώστε να μην γνωρίζει ότι στην πραγματικότητα εκτελεί ενέργειες στην victim app.

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Μια **activity** με το `launchMode` ορισμένο σε `singleTask` χωρίς να υπάρχει δηλωμένο `taskAffinity` είναι ευάλωτη σε task Hijacking. Αυτό σημαίνει ότι μια **application** μπορεί να εγκατασταθεί και αν εκτελεστεί πριν από την πραγματική εφαρμογή, μπορεί να **hijackάρει το task της πραγματικής εφαρμογής** (έτσι ο χρήστης θα αλληλεπιδρά με την **malicious application** νομίζοντας ότι χρησιμοποιεί την πραγματική).

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Insecure data storage

Internal Storage

Στο Android, τα αρχεία που αποθηκεύονται στην internal storage έχουν σχεδιαστεί να είναι προσβάσιμα αποκλειστικά από την app που τα δημιούργησε. Αυτό το μέτρο ασφαλείας επιβάλλεται από το λειτουργικό σύστημα Android και είναι συνήθως επαρκές για τις ανάγκες ασφαλείας των περισσότερων εφαρμογών. Ωστόσο, οι developers μερικές φορές χρησιμοποιούν modes όπως τα MODE_WORLD_READABLE και MODE_WORLD_WRITABLE για να επιτρέψουν το sharing αρχείων μεταξύ διαφορετικών εφαρμογών. Αυτά τα modes όμως δεν περιορίζουν την πρόσβαση σε αυτά τα αρχεία από άλλες εφαρμογές, συμπεριλαμβανομένων πιθανώς malicious.

1. **Static Analysis:**
- **Εξακριβώστε** ότι η χρήση των MODE_WORLD_READABLE και MODE_WORLD_WRITABLE εξετάζεται προσεκτικά. Αυτά τα modes **μπορεί να εκθέσουν** αρχεία σε μη προγραμματισμένη ή μη εξουσιοδοτημένη πρόσβαση.
2. **Dynamic Analysis:**
- **Επαληθεύστε** τα **permissions** που έχουν οριστεί στα αρχεία που δημιουργεί η εφαρμογή. Συγκεκριμένα, **ελέγξτε** αν κάποια αρχεία έχουν οριστεί να είναι readable ή writable worldwide. Αυτό μπορεί να αποτελεί σημαντικό κίνδυνο ασφαλείας, καθώς θα επέτρεπε σε **οποιαδήποτε εφαρμογή** εγκατεστημένη στη συσκευή, ανεξαρτήτως προέλευσης ή πρόθεσης, να **διαβάσει ή να τροποποιήσει** αυτά τα αρχεία.

External Storage

Όταν χειρίζεστε αρχεία σε external storage, όπως SD Cards, θα πρέπει να ληφθούν υπόψη ορισμένες προφυλάξεις:

1. **Accessibility**:
- Τα αρχεία στο external storage είναι **ενεργά προσβάσιμα (globally readable and writable)**. Αυτό σημαίνει ότι οποιαδήποτε εφαρμογή ή χρήστης μπορεί να έχει πρόσβαση σε αυτά.
2. **Security Concerns**:
- Δε συνιστάται να αποθηκεύετε sensitive information σε external storage λόγω της ευκολίας πρόσβασης.
- Το external storage μπορεί να αφαιρεθεί ή να προσπελαστεί από οποιαδήποτε εφαρμογή, καθιστώντας το λιγότερο ασφαλές.
3. **Handling Data from External Storage**:
- Πάντα **εκτελέστε input validation** στα δεδομένα που ανακτάτε από external storage. Αυτό είναι κρίσιμο επειδή τα δεδομένα προέρχονται από μια μη αξιόπιστη πηγή.
- Η αποθήκευση εκτελέσιμων ή class files στο external storage για dynamic loading αποθαρρύνεται έντονα.
- Εάν η εφαρμογή σας πρέπει οπωσδήποτε να ανακτά εκτελέσιμα αρχεία από external storage, βεβαιωθείτε ότι αυτά τα αρχεία είναι **signed και cryptographically verified** πριν φορτωθούν δυναμικά. Αυτό είναι ζωτικό για τη διατήρηση της ακεραιότητας ασφαλείας της εφαρμογής σας.

External storage μπορεί να **προσπελαστεί** σε `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> Από το Android 4.4 (**API 17**) και μετά, η SD card έχει μια δομή φακέλων που **περιορίζει την πρόσβαση μιας εφαρμογής στον κατάλογο που προορίζεται ειδικά για αυτή την εφαρμογή**. Αυτό αποτρέπει μια malicious εφαρμογή από το να αποκτήσει read ή write πρόσβαση στα αρχεία άλλης εφαρμογής.

**Sensitive data stored in clear-text**

- **Shared preferences**: Το Android επιτρέπει σε κάθε εφαρμογή να αποθηκεύει εύκολα xml αρχεία στη διαδρομή `/data/data/<packagename>/shared_prefs/` και κάποιες φορές είναι δυνατό να βρεθούν sensitive πληροφορίες σε clear-text σε αυτόν τον φάκελο.
- **Databases**: Το Android επιτρέπει σε κάθε εφαρμογή να αποθηκεύει εύκολα sqlite databases στη διαδρομή `/data/data/<packagename>/databases/` και κάποιες φορές είναι δυνατό να βρεθούν sensitive πληροφορίες σε clear-text σε αυτόν τον φάκελο.

### Broken TLS

Accept All Certificates

Για κάποιο λόγο, μερικές φορές οι developers αποδέχονται όλα τα certificates ακόμα και αν, για παράδειγμα, το hostname δεν ταιριάζει, με γραμμές κώδικα όπως η ακόλουθη:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Ελαττωματική Κρυπτογραφία

**Κακή Διαχείριση Κλειδιών**

Κάποιοι developers αποθηκεύουν ευαίσθητα δεδομένα στην τοπική αποθήκευση και τα κρυπτογραφούν με ένα κλειδί ενσωματωμένο/προβλέψιμο στον κώδικα. Αυτό δεν πρέπει να γίνεται καθώς κάποιο reversing μπορεί να επιτρέψει σε επιτιθέμενους να εξάγουν τις εμπιστευτικές πληροφορίες.

**Χρήση ανασφαλών και/ή αποσυρθέντων αλγορίθμων**

Οι developers δεν πρέπει να χρησιμοποιούν **deprecated algorithms** για να πραγματοποιούν authorisation **checks**, να **αποθηκεύουν** ή να **στέλνουν** δεδομένα. Μερικοί από αυτούς τους αλγορίθμους είναι: RC4, MD4, MD5, SHA1... Εάν χρησιμοποιούνται **hashes** για την αποθήκευση κωδικών πρόσβασης για παράδειγμα, θα πρέπει να χρησιμοποιούνται hashes που είναι brute-force **resistant** με salt.

### Άλλοι έλεγχοι

- Συνιστάται να **obfuscate the APK** για να δυσκολέψετε το έργο των reverse engineers.
- Εάν η εφαρμογή είναι ευαίσθητη (όπως bank apps), θα πρέπει να εκτελεί τους δικούς της ελέγχους για να διαπιστώσει αν το κινητό είναι rooted και να ενεργεί ανάλογα.
- Εάν η εφαρμογή είναι ευαίσθητη (όπως bank apps), θα πρέπει να ελέγχει αν χρησιμοποιείται **emulator**.
- Εάν η εφαρμογή είναι ευαίσθητη (όπως bank apps), θα πρέπει να **ελέγχει την ακεραιότητά της πριν εκτελεστεί** για να διαπιστώσει αν έχει τροποποιηθεί.
- Χρησιμοποιήστε [**APKiD**](https://github.com/rednaga/APKiD) για να ελέγξετε ποιος compiler/packer/obfuscator χρησιμοποιήθηκε για το build του APK

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Αυτοματοποιημένη Στατική Ανάλυση Κώδικα

Το εργαλείο [**mariana-trench**](https://github.com/facebook/mariana-trench) είναι ικανό να εντοπίζει **vulnerabilities** σαρώνοντας τον **κώδικα** της εφαρμογής. Αυτό το εργαλείο περιέχει μια σειρά από **known sources** (που υποδεικνύουν στο εργαλείο τα **σημεία** όπου το **input** ελέγχεται από τον χρήστη), **sinks** (που υποδεικνύουν στο εργαλείο **επικίνδυνα** **σημεία** όπου κακόβουλο input χρήστη θα μπορούσε να προκαλέσει ζημιά) και **rules**. Αυτοί οι κανόνες υποδεικνύουν τον **συνδυασμό** **sources-sinks** που σηματοδοτεί μια ευπάθεια.

Με αυτή τη γνώση, **mariana-trench θα ανασκοπήσει τον κώδικα και θα βρει πιθανές ευπάθειες πάνω σε αυτόν**.

### Secrets leaked

An application may contain secrets (API keys, passwords, hidden urls, subdomains...) inside of it that you might be able to discover. You could us a tool such as [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Άλλες ενδιαφέρουσες λειτουργίες

- **Εκτέλεση κώδικα**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Αποστολή SMS**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** δηλωμένες ως `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)
- In-memory native code execution via JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Δυναμική Ανάλυση

> Πρώτα απ' όλα, χρειάζεστε ένα περιβάλλον όπου μπορείτε να εγκαταστήσετε την εφαρμογή και όλο το υπόλοιπο περιβάλλον (Burp CA cert, Drozer και Frida κυρίως). Επομένως, μια rooted συσκευή (εμουλαρισμένη ή όχι) συνιστάται ιδιαίτερα.

### Online Dynamic analysis

Μπορείτε να δημιουργήσετε έναν **free account** στο: [https://appetize.io/](https://appetize.io). Αυτή η πλατφόρμα σας επιτρέπει να **upload** και να **execute** APKs, οπότε είναι χρήσιμη για να δείτε πώς συμπεριφέρεται ένα apk.

Μπορείτε ακόμη να **δειτε τα logs της εφαρμογής σας** στο web και να συνδεθείτε μέσω **adb**.

![](<../../images/image (831).png>)

Χάρη στη σύνδεση ADB μπορείτε να χρησιμοποιήσετε **Drozer** και **Frida** μέσα στους emulators.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (Μπορείτε να δημιουργήσετε **x86** και **arm** συσκευές, και σύμφωνα με [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**οι νεότερες x86** εκδόσεις **υποστηρίζουν ARM libraries** χωρίς να χρειάζεστε έναν αργό arm emulator).
- Μάθετε πώς να το ρυθμίσετε σε αυτή τη σελίδα:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, χρειάζεται να δημιουργήσετε λογαριασμό. _Συνίσταται να **κατεβάσετε** την έκδοση **WITH**_ _**VirtualBox** για να αποφύγετε πιθανά σφάλματα._)
- [**Nox**](https://es.bignox.com) (Free, αλλά δεν υποστηρίζει Frida ή Drozer).

> [!TIP]
> Όταν δημιουργείτε ένα νέο emulator σε οποιαδήποτε πλατφόρμα θυμηθείτε ότι όσο μεγαλύτερη είναι η οθόνη τόσο πιο αργά θα τρέχει ο emulator. Έτσι επιλέξτε μικρές οθόνες αν είναι δυνατόν.

Για να **εγκαταστήσετε google services** (όπως AppStore) στο Genymotion χρειάζεται να κάνετε κλικ στο κόκκινο κουμπί που σημειώνεται στην παρακάτω εικόνα:

![](<../../images/image (277).png>)

Επίσης, σημειώστε ότι στις **ρυθμίσεις του Android VM στο Genymotion** μπορείτε να επιλέξετε **Bridge Network mode** (αυτό θα είναι χρήσιμο αν συνδεθείτε στο Android VM από διαφορετικό VM με τα εργαλεία).

#### Use a physical device

Πρέπει να ενεργοποιήσετε τις επιλογές **debugging** και είναι καλό αν μπορείτε να την **root**:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Μόλις έχετε εγκαταστήσει την εφαρμογή, το πρώτο που πρέπει να κάνετε είναι να τη δοκιμάσετε και να διερευνήσετε τι κάνει, πώς λειτουργεί και να εξοικειωθείτε με αυτήν.\
> Προτείνω να **εκτελέσετε αυτήν την αρχική δυναμική ανάλυση χρησιμοποιώντας MobSF dynamic analysis + pidcat**, ώστε να μπορέσουμε να **κατανοήσουμε πώς λειτουργεί η εφαρμογή** ενώ το MobSF **συλλέγει** πολλά **ενδιαφέροντα** **δεδομένα** που μπορείτε να αναλύσετε αργότερα.

Magisk/Zygisk quick notes (recommended on Pixel devices)
- Patch boot.img with the Magisk app and flash via fastboot to get systemless root
- Enable Zygisk + DenyList for root hiding; consider LSPosed/Shamiko when stronger hiding is required
- Keep original boot.img to recover from OTA updates; re-patch after each OTA
- For screen mirroring, use scrcpy on the host



### Ακούσια Διαρροή Δεδομένων

**Logging**

Οι developers θα πρέπει να είναι προσεκτικοί στο να μην εκθέτουν **debugging information** δημόσια, καθώς αυτό μπορεί να οδηγήσει σε ευαίσθητες πληροφορίες leak. Τα εργαλεία [**pidcat**](https://github.com/JakeWharton/pidcat) και `adb logcat` συνιστώνται για την παρακολούθηση των logs της εφαρμογής προκειμένου να εντοπιστούν και να προστατευτούν ευαίσθητες πληροφορίες. Το **Pidcat** προτιμάται για την ευκολία χρήσης και την αναγνωσιμότητά του.

> [!WARNING]
> Σημειώστε ότι από **αργότερα νεότερα από το Android 4.0**, **οι εφαρμογές μπορούν να έχουν πρόσβαση μόνο στα δικά τους logs**. Έτσι οι εφαρμογές δεν μπορούν να έχουν πρόσβαση στα logs άλλων εφαρμογών.\
> Παρόλα αυτά, εξακολουθεί να συνιστάται να **μην καταγράφετε ευαίσθητες πληροφορίες**.

**Copy/Paste Buffer Caching**

Το **clipboard-based** framework του Android επιτρέπει τη λειτουργία copy-paste στις εφαρμογές, αλλά αποτελεί ρίσκο καθώς **άλλες εφαρμογές** μπορούν να έχουν **πρόσβαση** στο clipboard, εκθέτοντας ενδεχομένως ευαίσθητα δεδομένα. Είναι κρίσιμο να **απενεργοποιείτε τις λειτουργίες copy/paste** για ευαίσθητες ενότητες της εφαρμογής, όπως στοιχεία πιστωτικής κάρτας, για να αποφευχθεί η leak δεδομένων.

**Crash Logs**

Εάν μια εφαρμογή **crashes** και **αποθηκεύει logs**, αυτά τα logs μπορούν να βοηθήσουν τους επιτιθέμενους, ιδιαίτερα όταν η εφαρμογή δεν μπορεί να αντιστραφεί. Για να μετριαστεί αυτός ο κίνδυνος, αποφύγετε την καταγραφή στα crashes, και αν τα logs πρέπει να μεταδίδονται μέσω δικτύου, βεβαιωθείτε ότι αποστέλλονται μέσω SSL καναλιού για ασφάλεια.

Ως pentester, **προσπαθήστε να ρίξετε μια ματιά σε αυτά τα logs**.

**Analytics Data Sent To 3rd Parties**

Οι εφαρμογές συχνά ενσωματώνουν υπηρεσίες όπως Google Adsense, οι οποίες μπορούν άθελά τους να leak ευαίσθητα δεδομένα λόγω λανθασμένης υλοποίησης από τους developers. Για να εντοπίσετε πιθανές leak, είναι σκόπιμο να **διακόψετε την κυκλοφορία της εφαρμογής** και να ελέγξετε αν αποστέλλονται ευαίσθητες πληροφορίες σε third-party υπηρεσίες.

### SQLite DBs

Οι περισσότερες εφαρμογές θα χρησιμοποιήσουν **internal SQLite databases** για να αποθηκεύσουν πληροφορίες. Κατά τη διάρκεια του pentest ρίξτε μια **ματιά** στις **βάσεις δεδομένων** που έχουν δημιουργηθεί, τα ονόματα των **πινάκων** και **στηλών** και όλα τα **δεδομένα** που έχουν αποθηκευτεί γιατί μπορεί να βρείτε **ευαίσθητες πληροφορίες** (που θα αποτελούσαν ευπάθεια).\
Οι βάσεις δεδομένων θα πρέπει να βρίσκονται σε `/data/data/the.package.name/databases` όπως `/data/data/com.mwr.example.sieve/databases`

Εάν η βάση δεδομένων αποθηκεύει εμπιστευτικές πληροφορίες και είναι **encrypted** αλλά μπορείτε να **βρείτε** το **password** μέσα στην εφαρμογή, είναι ακόμα **μια ευπάθεια**.

Αναγράψτε τους πίνακες χρησιμοποιώντας `.tables` και αναγράψτε τις στήλες των πινάκων με `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer is s useful tool to **exploit exported activities, exported services and Content Providers** as you will learn in the following sections.

### Εκμετάλλευση exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Επίσης θυμηθείτε ότι ο κώδικας μιας activity ξεκινάει στη μέθοδο **`onCreate`**.

**Παράκαμψη εξουσιοδότησης**

Όταν μια Activity είναι exported μπορείτε να καλέσετε την οθόνη της από μια εξωτερική εφαρμογή. Επομένως, αν μια activity με **ευαίσθητες πληροφορίες** είναι **exported** θα μπορούσατε να **bypass** τους μηχανισμούς **authentication** για να έχετε πρόσβαση σε αυτήν.

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

Μπορείτε επίσης να ξεκινήσετε μια exported activity από adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**ΣΗΜΕΙΩΣΗ**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> Σημειώστε ότι ένα authorisation bypass δεν είναι πάντα μια vulnerability — εξαρτάται από το πώς λειτουργεί το bypass και ποιες πληροφορίες εκτίθενται.

**Sensitive information leakage**

**Activities can also return results**. Αν καταφέρετε να βρείτε μια exported και unprotected activity που καλεί τη μέθοδο **`setResult`** και **επιστρέφει ευαίσθητες πληροφορίες**, υπάρχει sensitive information leakage.

#### Tapjacking

Αν το tapjacking δεν αποτρέπεται, μπορείτε να καταχραστείτε την exported activity ώστε να κάνετε τον χρήστη να εκτελέσει απροσδόκητες ενέργειες. Για περισσότερες πληροφορίες σχετικά με [**τι είναι το Tapjacking, ακολουθήστε τον σύνδεσμο**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Διαβάστε αυτό αν θέλετε να ανανεώσετε τι είναι ένα Content Provider.**](android-applications-basics.md#content-provider)\
Οι Content providers χρησιμοποιούνται βασικά για να **μοιράζουν δεδομένα**. Αν μια εφαρμογή έχει διαθέσιμους content providers ίσως να μπορείτε να **εξάγετε ευαίσθητα** δεδομένα από αυτούς. Επίσης είναι ενδιαφέρον να δοκιμάσετε πιθανά **SQL injections** και **Path Traversals** καθώς μπορεί να είναι ευάλωτα.

[**Μάθετε πώς να εκμεταλλευτείτε Content Providers με Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Διαβάστε αυτό αν θέλετε να ανανεώσετε τι είναι ένα Service.**](android-applications-basics.md#services)\
Θυμηθείτε ότι οι ενέργειες ενός Service ξεκινούν στη μέθοδο `onStartCommand`.

Ένα service είναι βασικά κάτι που **μπορεί να λαμβάνει δεδομένα**, να τα **επεξεργάζεται** και να **επιστρέφει** (ή όχι) μια απάντηση. Έτσι, αν μια εφαρμογή εξάγει κάποια services θα πρέπει να **ελέγξετε** τον **κώδικα** για να καταλάβετε τι κάνει και να το **δοκιμάσετε** **δυναμικά** για εξαγωγή εμπιστευτικών πληροφοριών, παράκαμψη μέτρων authentication...\
[**Μάθετε πώς να εκμεταλλευτείτε Services με Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Διαβάστε αυτό αν θέλετε να ανανεώσετε τι είναι ένα Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Θυμηθείτε ότι οι ενέργειες ενός Broadcast Receiver ξεκινούν στη μέθοδο `onReceive`.

Ένας broadcast receiver θα περιμένει έναν τύπο μηνύματος. Ανάλογα με το πώς ο receiver χειρίζεται το μήνυμα, μπορεί να είναι ευάλωτος.\
[**Μάθετε πώς να εκμεταλλευτείτε Broadcast Receivers με Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Μπορείτε να αναζητήσετε deep links χειροκίνητα, χρησιμοποιώντας εργαλεία όπως το MobSF ή scripts όπως [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Μπορείτε να **ανοίξετε** ένα δηλωμένο **scheme** χρησιμοποιώντας **adb** ή έναν **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Σημειώστε ότι μπορείτε να **παραλείψετε το package name** και το κινητό θα καλέσει αυτόματα την εφαρμογή που πρέπει να ανοίξει αυτόν τον σύνδεσμο._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Κώδικας που εκτελείται**

Για να βρείτε τον **κώδικα που θα εκτελεστεί στην App**, μεταβείτε στην activity που καλείται από το deeplink και αναζητήστε τη συνάρτηση **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Ευαίσθητες πληροφορίες**

Every time you find a deep link check that i**δεν λαμβάνει ευαίσθητα δεδομένα (όπως passwords) μέσω URL παραμέτρων**, because any other application could **impersonate the deep link and steal that data!**

**Parameters in path**

You **πρέπει επίσης να ελέγξετε αν οποιοδήποτε deep link χρησιμοποιεί παράμετρο μέσα στο path** του URL όπως: `https://api.example.com/v1/users/{username}` , in that case you can force a path traversal accessing something like: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Note that if you find the correct endpoints inside the application you may be able to cause a **Open Redirect** (if part of the path is used as domain name), **account takeover** (if you can modify users details without CSRF token and the vuln endpoint used the correct method) and any other vuln. More [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Transport Layer Inspection and Verification Failures

- **Certificates are not always inspected properly** by Android applications. Συχνά αυτές οι εφαρμογές παραβλέπουν προειδοποιήσεις και αποδέχονται self-signed certificates ή, σε μερικές περιπτώσεις, επιστρέφουν στη χρήση HTTP connections.
- **Negotiations during the SSL/TLS handshake are sometimes weak**, χρησιμοποιώντας insecure cipher suites. Αυτό το πρόβλημα καθιστά τη σύνδεση ευάλωτη σε man-in-the-middle (MITM) attacks, επιτρέποντας σε επιτιθέμενους να αποκρυπτογραφήσουν τα δεδομένα.
- **Leakage of private information** είναι ένας κίνδυνος όταν οι εφαρμογές αυθεντικοποιούνται μέσω secure channels αλλά μετά επικοινωνούν μέσω μη ασφαλών καναλιών για άλλες συναλλαγές. Αυτή η προσέγγιση δεν προστατεύει ευαίσθητα δεδομένα, όπως session cookies ή λεπτομέρειες χρήστη, από υποκλοπή από κακόβουλους φορείς.

#### Certificate Verification

Θα εστιάσουμε στην **certificate verification**. Η ακεραιότητα του server's certificate πρέπει να επαληθεύεται για την ενίσχυση της ασφάλειας. Αυτό είναι κρίσιμο επειδή insecure TLS ρυθμίσεις και η μετάδοση ευαίσθητων δεδομένων μέσω μη κρυπτογραφημένων καναλιών μπορεί να δημιουργήσουν σημαντικούς κινδύνους. Για αναλυτικά βήματα σχετικά με την επαλήθευση των server certificates και την αντιμετώπιση ευπαθειών, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) παρέχει πλήρεις οδηγίες.

#### SSL Pinning

SSL Pinning είναι ένα μέτρο ασφαλείας όπου η εφαρμογή επαληθεύει το server's certificate έναντι ενός γνωστού αντιγράφου που αποθηκεύεται μέσα στην εφαρμογή. Αυτή η μέθοδος είναι απαραίτητη για την πρόληψη MITM attacks. Η υλοποίηση του SSL Pinning συνιστάται έντονα για εφαρμογές που χειρίζονται ευαίσθητες πληροφορίες.

#### Traffic Inspection

Για να επιθεωρήσετε HTTP traffic, είναι απαραίτητο να **εγκαταστήσετε το certificate του proxy εργαλείου** (π.χ., Burp). Χωρίς την εγκατάσταση αυτού του certificate, το κρυπτογραφημένο traffic μπορεί να μην είναι ορατό μέσω του proxy. Για έναν οδηγό εγκατάστασης custom CA certificate, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Applications targeting **API Level 24 and above** απαιτούν τροποποιήσεις στο Network Security Config για να αποδεχτούν το CA certificate του proxy. Αυτό το βήμα είναι κρίσιμο για την επιθεώρηση κρυπτογραφημένης κυκλοφορίας. Για οδηγίες σχετικά με την τροποποίηση του Network Security Config, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

If **Flutter** is being used you need to to follow the instructions in [**this page**](flutter.md). Αυτό συμβαίνει επειδή, απλώς προσθέτοντας το certificate στο store δεν θα λειτουργήσει καθώς το Flutter έχει τη δική του λίστα με έγκυρα CAs.

#### Static detection of SSL/TLS pinning

Πριν επιχειρήσετε runtime bypasses, εντοπίστε γρήγορα που επιβάλλεται το pinning στο APK. Η στατική ανακάλυψη βοηθά να σχεδιάσετε hooks/patches και να επικεντρωθείτε στα σωστά code paths.

Tool: SSLPinDetect
- Open-source static-analysis utility που αποσυμπιέζει το APK σε Smali (μέσω apktool) και σαρώνει για curated regex patterns των SSL/TLS pinning implementations.
- Αναφέρει το ακριβές file path, line number, και ένα code snippet για κάθε match.
- Καλύπτει κοινά frameworks και custom code paths: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, και Network Security Config XML pins.

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Χρήση
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Παράδειγμα κανόνων pattern (JSON)
Χρησιμοποιήστε ή επεκτείνετε τις signatures για να εντοπίσετε ιδιόκτητους/προσαρμοσμένους pinning styles. Μπορείτε να φορτώσετε το δικό σας JSON και να scan at scale.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Σημειώσεις και συμβουλές
- Γρήγορη σάρωση σε μεγάλες εφαρμογές μέσω multi-threading και memory-mapped I/O; pre-compiled regex μειώνει το overhead/false positives.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Τυπικοί στόχοι ανίχνευσης για προτεραιοποίηση:
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Δηλωτικά pins σε res/xml network security config και αναφορές στο manifest
- Χρησιμοποιήστε τις αντιστοιχισμένες τοποθεσίες για να προγραμματίσετε Frida hooks, static patches, ή reviews του config πριν από δυναμικές δοκιμές.



#### Παράκαμψη SSL Pinning

Όταν έχει υλοποιηθεί SSL Pinning, η παράκαμψή του γίνεται απαραίτητη για την επιθεώρηση της HTTPS κίνησης. Υπάρχουν διάφορες μέθοδοι για αυτόν τον σκοπό:

- Αυτόματα **τροποποιήστε** το **apk** για να **παρακάμψετε** το SSLPinning με [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Το μεγαλύτερο πλεονέκτημα αυτής της επιλογής είναι ότι δεν θα χρειαστείτε root για να παρακάμψετε το SSL Pinning, αλλά θα χρειαστεί να διαγράψετε την εφαρμογή και να εγκαταστήσετε τη νέα, και αυτό δεν θα δουλεύει πάντα.
- Μπορείτε να χρησιμοποιήσετε το **Frida** (περιγράφεται παρακάτω) για να παρακάμψετε αυτήν την προστασία. Εδώ υπάρχει ένας οδηγός για τη χρήση Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Μπορείτε επίσης να δοκιμάσετε να **παρακάμψετε αυτόματα το SSL Pinning** χρησιμοποιώντας [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Μπορείτε επίσης να δοκιμάσετε να **παρακάμψετε αυτόματα το SSL Pinning** χρησιμοποιώντας **MobSF dynamic analysis** (εξηγείται παρακάτω)
- Εάν εξακολουθείτε να νομίζετε ότι υπάρχει κίνηση που δεν καταγράφετε, μπορείτε να δοκιμάσετε να **προωθήσετε την κίνηση προς burp χρησιμοποιώντας iptables**. Διαβάστε αυτό το blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Αναζήτηση κοινών Web ευπαθειών

Είναι σημαντικό επίσης να αναζητήσετε κοινές web ευπάθειες εντός της εφαρμογής. Λεπτομερείς πληροφορίες για την αναγνώριση και τη μετρίαση αυτών των ευπαθειών υπερβαίνουν το εύρος αυτής της περίληψης αλλά καλύπτονται εκτενώς σε άλλα μέρη.

### Frida

[Frida](https://www.frida.re) είναι ένα dynamic instrumentation toolkit για developers, reverse-engineers, και security researchers.\
**Μπορείτε να αποκτήσετε πρόσβαση σε τρέχουσα εφαρμογή και να κάνετε hook μεθόδους σε runtime για να αλλάξετε τη συμπεριφορά, να αλλάξετε τιμές, να εξάγετε τιμές, να τρέξετε διαφορετικό κώδικα...**\
Αν θέλετε να pentest Android applications πρέπει να ξέρετε πώς να χρησιμοποιείτε το Frida.

- Μάθετε πώς να χρησιμοποιείτε το Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Κάποια "GUI" για ενέργειες με Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection είναι εξαιρετικό για την αυτοματοποίηση της χρήσης του Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Μπορείτε να βρείτε μερικά Awesome Frida scripts εδώ: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Προσπαθήστε να παρακάμψετε anti-debugging / anti-frida μηχανισμούς φορτώνοντας το Frida όπως υποδεικνύεται στο [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (εργαλείο [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

Ελέγξτε εάν η εφαρμογή αποθηκεύει ευαίσθητες πληροφορίες στη μνήμη που δεν θα έπρεπε να αποθηκεύει, όπως passwords ή mnemonics.

Χρησιμοποιώντας [**Fridump3**](https://github.com/rootbsd/fridump3) μπορείτε να κάνετε dump τη μνήμη της εφαρμογής με:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Αυτό θα dump τη μνήμη στον φάκελο ./dump, και εκεί μπορείτε να κάνετε grep με κάτι σαν:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Ευαίσθητα δεδομένα στο Keystore**

Στο Android το Keystore είναι το καλύτερο μέρος για να αποθηκεύονται ευαίσθητα δεδομένα, ωστόσο, με επαρκή προνόμια εξακολουθεί να είναι **εφικτό να αποκτηθεί πρόσβαση σε αυτό**. Δεδομένου ότι οι εφαρμογές τείνουν να αποθηκεύουν εδώ **sensitive data in clear text**, τα pentests θα πρέπει να το ελέγχουν ως root user ή κάποιοι με φυσική πρόσβαση στη συσκευή θα μπορούσαν να κλέψουν αυτά τα δεδομένα.

Ακόμα κι αν μια εφαρμογή αποθήκευσε δεδομένα στο keystore, τα δεδομένα πρέπει να είναι κρυπτογραφημένα.

Για να αποκτήσετε πρόσβαση στα δεδομένα μέσα στο keystore μπορείτε να χρησιμοποιήσετε αυτό το Frida script: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Χρησιμοποιώντας το παρακάτω Frida script, μπορεί να είναι δυνατό να **bypass fingerprint authentication** που ενδέχεται να εκτελούν οι Android εφαρμογές προκειμένου να **προστατεύσουν ορισμένες ευαίσθητες περιοχές:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Εικόνες Φόντου**

Όταν βάζετε μια εφαρμογή στο παρασκήνιο, το Android αποθηκεύει ένα **στιγμιότυπο της εφαρμογής** έτσι ώστε όταν επανέλθει στο προσκήνιο να αρχίσει να φορτώνει την εικόνα πριν την εφαρμογή, κάνοντάς την να φαίνεται ότι φορτώθηκε πιο γρήγορα.

Ωστόσο, αν αυτό το στιγμιότυπο περιέχει **ευαίσθητες πληροφορίες**, κάποιος με πρόσβαση στο στιγμιότυπο μπορεί να **κλέψει αυτές τις πληροφορίες** (σημείωση: χρειάζεστε root για πρόσβαση).

Τα στιγμιότυπα αποθηκεύονται συνήθως εδώ: **`/data/system_ce/0/snapshots`**

Το Android παρέχει έναν τρόπο για να **αποτρέψετε τη λήψη στιγμιότυπου οθόνης ορίζοντας την παράμετρο διάταξης FLAG_SECURE**. Χρησιμοποιώντας αυτή τη σημαία, τα περιεχόμενα του παραθύρου θεωρούνται ασφαλή, αποτρέποντας την εμφάνισή τους σε στιγμιότυπα οθόνης ή την προβολή τους σε μη-ασφαλείς οθόνες.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Αναλυτής Εφαρμογών Android**

Αυτό το εργαλείο μπορεί να σας βοηθήσει στη διαχείριση διαφόρων εργαλείων κατά τη δυναμική ανάλυση: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Οι προγραμματιστές συχνά δημιουργούν proxy components όπως activities, services και broadcast receivers που χειρίζονται αυτά τα Intents και τα προωθούν σε μεθόδους όπως `startActivity(...)` ή `sendBroadcast(...)`, κάτι που μπορεί να είναι επικίνδυνο.

Ο κίνδυνος έγκειται στο ότι επιτρέπει σε επιτιθέμενους να ενεργοποιήσουν μη-exported components της εφαρμογής ή να αποκτήσουν πρόσβαση σε ευαίσθητους content providers κατευθύνοντας λανθασμένα αυτά τα Intents. Ένα αξιοσημείωτο παράδειγμα είναι το `WebView` component που μετατρέπει URLs σε `Intent` αντικείμενα μέσω `Intent.parseUri(...)` και στη συνέχεια τα εκτελεί, ενδεχομένως οδηγώντας σε κακόβουλες Intent injections.

### Βασικά Σημεία

- **Intent Injection** μοιάζει με το Open Redirect στο web.
- Εκμεταλλεύσεις περιλαμβάνουν τη μεταβίβαση `Intent` αντικειμένων ως extras, τα οποία μπορούν να αναδρομολογηθούν για την εκτέλεση μη ασφαλών ενεργειών.
- Μπορεί να εκθέσει μη-exported components και content providers σε επιτιθέμενους.
- Η μετατροπή URL → `Intent` από το `WebView` μπορεί να διευκολύνει ανεπιθύμητες ενέργειες.

### Android Client Side Injections and others

Πιθανόν να γνωρίζετε αυτό το είδος ευπαθειών από το Web. Πρέπει να είστε ιδιαίτερα προσεκτικοί με αυτές τις ευπάθειες σε μια εφαρμογή Android:

- **SQL Injection:** Όταν χειρίζεστε δυναμικά queries ή Content-Providers βεβαιωθείτε ότι χρησιμοποιείτε parameterized queries.
- **JavaScript Injection (XSS):** Επιβεβαιώστε ότι η υποστήριξη JavaScript και Plugin είναι απενεργοποιημένη για οποιαδήποτε WebViews (απενεργοποιημένη από προεπιλογή). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** Οι WebViews θα πρέπει να έχουν απενεργοποιημένη την πρόσβαση στο file system (ενεργοποιημένη από προεπιλογή) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Μόνιμα cookies**: Σε αρκετές περιπτώσεις όταν η εφαρμογή Android τερματίζει τη συνεδρία, το cookie δεν ανακαλείται ή μπορεί ακόμη να αποθηκευτεί στο δίσκο.
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Αυτόματη Ανάλυση

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Στατική ανάλυση**

![](<../../images/image (866).png>)

**Αξιολόγηση ευπαθειών της εφαρμογής** χρησιμοποιώντας ένα ευχάριστο web-based frontend. Μπορείτε επίσης να εκτελέσετε δυναμική ανάλυση (αλλά πρέπει να προετοιμάσετε το περιβάλλον).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Σημειώστε ότι το MobSF μπορεί να αναλύσει **Android**(apk)**, IOS**(ipa) **and Windows**(apx) εφαρμογές (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Επίσης, αν δημιουργήσετε ένα **ZIP** αρχείο με τον πηγαίο κώδικα μιας **Android** ή μιας **IOS** app (πηγαίνετε στον root folder της εφαρμογής, επιλέξτε τα πάντα και δημιουργήστε ένα ZIPfile), θα μπορέσει επίσης να το αναλύσει.

Το MobSF σας επιτρέπει επίσης να κάνετε **diff/Compare** αναλύσεις και να ενσωματώσετε το **VirusTotal** (θα χρειαστεί να ορίσετε το API key σας στο _MobSF/settings.py_ και να το ενεργοποιήσετε: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). Μπορείτε επίσης να ορίσετε `VT_UPLOAD` σε `False`, οπότε το **hash** θα γίνει **upload** αντί για το αρχείο.

### Βοηθούμενη δυναμική ανάλυση με MobSF

Το **MobSF** μπορεί επίσης να είναι πολύ χρήσιμο για **dynamic analysis** σε **Android**, αλλά σε αυτή την περίπτωση θα χρειαστεί να εγκαταστήσετε το MobSF και το **genymotion** στο host σας (ένα VM ή Docker δεν θα δουλέψει). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
Ο **MobSF dynamic analyser** μπορεί:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). Όλα αυτά γίνονται αυτόματα εκτός από τα screenshots — πρέπει να πατήσετε όταν θέλετε ένα screenshot ή να πατήσετε "**Exported Activity Tester**" για να λάβετε screenshots όλων των exported activities.
- Capture **HTTPS traffic**
- Χρησιμοποιεί **Frida** για να αποκτήσει **runtime** **information**

Από android **versions > 5**, θα **automatically start Frida** και θα ρυθμίσει τις global **proxy** ρυθμίσεις για να **capture** την κίνηση. Θα καταγράφει μόνο την κίνηση από την εφαρμογή υπό δοκιμή.

**Frida**

Εξ ορισμού, θα χρησιμοποιήσει επίσης κάποια Frida Scripts για να **bypass SSL pinning**, **root detection** και **debugger detection** και για να **monitor interesting APIs**.\
Το MobSF μπορεί επίσης να **invoke exported activities**, να τραβήξει **screenshots** αυτών και να τα **save** για την αναφορά.

Για να **start** το dynamic testing πατήστε το πράσινο κουμπί: "**Start Instrumentation**". Πατήστε το "**Frida Live Logs**" για να δείτε τα logs που παράγουν τα Frida scripts και το "**Live API Monitor**" για να δείτε όλες τις invocations σε hooked methods, τα arguments που περνάνε και τις επιστρεφόμενες τιμές (αυτό θα εμφανιστεί αφού πατήσετε "Start Instrumentation").\
Το MobSF σας επιτρέπει επίσης να φορτώσετε δικά σας **Frida scripts** (για να στείλετε τα αποτελέσματα των Frida scripts στο MobSF χρησιμοποιήστε τη συνάρτηση `send()`). Έχει επίσης **αρκετά προ-γραμμένα scripts** που μπορείτε να φορτώσετε (μπορείτε να προσθέσετε περισσότερα στο `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), απλά **επιλέξτε τα**, πατήστε "**Load**" και πατήστε "**Start Instrumentation**" (θα μπορείτε να δείτε τα logs αυτών των scripts μέσα στο "**Frida Live Logs**").

![](<../../images/image (419).png>)

Επιπλέον, έχετε μερικές βοηθητικές λειτουργίες Frida:

- **Enumerate Loaded Classes**: Θα εμφανίσει όλες τις loaded classes
- **Capture Strings**: Θα εμφανίσει όλα τα capture strings ενώ χρησιμοποιείτε την εφαρμογή (πολύ noisy)
- **Capture String Comparisons**: Μπορεί να είναι πολύ χρήσιμο. Θα **δείξει τις 2 strings που συγκρίνονται** και αν το αποτέλεσμα ήταν True ή False.
- **Enumerate Class Methods**: Βάλτε το όνομα της κλάσης (π.χ. "java.io.File") και θα εμφανίσει όλες τις μεθόδους της κλάσης.
- **Search Class Pattern**: Αναζήτηση κλάσεων με pattern
- **Trace Class Methods**: **Trace** ολόκληρη μια **class** (δείτε inputs και outputs όλων των μεθόδων της κλάσης). Θυμηθείτε ότι εξ ορισμού το MobSF traces αρκετές ενδιαφέρουσες Android Api methods.

Αφού επιλέξετε το auxiliary module που θέλετε να χρησιμοποιήσετε, πρέπει να πατήσετε "**Start Instrumentation**" και θα δείτε όλα τα outputs στο "**Frida Live Logs**".

**Shell**

Το MobSF παρέχει επίσης ένα shell με κάποιες εντολές **adb**, **MobSF commands**, και κοινές εντολές **shell** στο κάτω μέρος της σελίδας dynamic analysis. Μερικές ενδιαφέρουσες εντολές:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**Εργαλεία HTTP**

Όταν η http κίνηση καταγράφεται μπορείτε να δείτε μια άσχημη προβολή της καταγεγραμμένης κίνησης στο κάτω μέρος στο κουμπί "**HTTP(S) Traffic**" ή μια πιο καθαρή προβολή στο πράσινο κουμπί "**Start HTTPTools**". Από τη δεύτερη επιλογή, μπορείτε να **στέλνετε** τα **captured requests** σε **proxies** όπως Burp ή Owasp ZAP.\
Για να το κάνετε, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> πατήστε "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Μόλις ολοκληρώσετε το dynamic analysis με MobSF μπορείτε να πατήσετε "**Start Web API Fuzzer**" για να **fuzz http requests** και να αναζητήσετε ευπάθειες.

> [!TIP]
> Μετά από dynamic analysis με MobSF οι ρυθμίσεις proxy ίσως έχουν διαμορφωθεί λανθασμένα και δεν θα μπορείτε να τις διορθώσετε από το GUI. Μπορείτε να διορθώσετε τις ρυθμίσεις proxy εκτελώντας:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Βοηθημένη Dynamic Analysis με Inspeckage

Μπορείτε να αποκτήσετε το εργαλείο από [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Αυτό το εργαλείο θα χρησιμοποιήσει μερικά **Hooks** για να σας ενημερώνει **what is happening in the application** ενώ εκτελείτε **dynamic analysis**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Αυτό είναι ένα **great tool to perform static analysis with a GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Αυτό το εργαλείο έχει σχεδιαστεί για να αναζητά διάφορες **security related Android application vulnerabilities**, είτε στο **source code** είτε σε **packaged APKs**. Το εργαλείο είναι επίσης **capable of creating a "Proof-of-Concept" deployable APK** και **ADB commands**, για να εκμεταλλευτεί μερικές από τις ευπάθειες που βρέθηκαν (Exposed activities, intents, tapjacking...). Όπως και με Drozer, δεν υπάρχει ανάγκη να κάνετε root στη συσκευή δοκιμών.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Εμφανίζει όλα τα εξαγόμενα αρχεία για εύκολη αναφορά
- Κάνει αυτόματα decompile των APK αρχείων σε μορφή Java και Smali
- Αναλύει το AndroidManifest.xml για κοινές ευπάθειες και συμπεριφορά
- Στατική ανάλυση πηγαίου κώδικα για κοινές ευπάθειες και συμπεριφορά
- Πληροφορίες συσκευής
- και άλλα
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER είναι μια εφαρμογή γραμμής εντολών που μπορεί να χρησιμοποιηθεί σε Windows, MacOS X και Linux, η οποία αναλύει _.apk_ αρχεία ψάχνοντας για ευπάθειες. Το κάνει αυτό αποσυμπιέζοντας τα APKs και εφαρμόζοντας μια σειρά κανόνων για να εντοπίσει αυτές τις ευπάθειες.

Όλοι οι κανόνες είναι συγκεντρωμένοι σε ένα αρχείο `rules.json`, και κάθε εταιρεία ή tester μπορεί να δημιουργήσει τους δικούς του κανόνες για να αναλύσει ό,τι χρειάζεται.

Κατεβάστε τα πιο πρόσφατα binaries από τη [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

Το StaCoAn είναι ένα **crossplatform** εργαλείο που βοηθά προγραμματιστές, bugbounty hunters και ethical hackers να πραγματοποιούν [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) σε εφαρμογές για κινητά.

Η ιδέα είναι ότι σύρετε και αποθέτετε το αρχείο της εφαρμογής για κινητά σας (ένα .apk ή .ipa αρχείο) στην εφαρμογή StaCoAn και αυτή θα δημιουργήσει μια οπτική και φορητή αναφορά για εσάς. Μπορείτε να προσαρμόσετε τις ρυθμίσεις και τα wordlists για να έχετε μια εξατομικευμένη εμπειρία.

Κατέβασμα[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

Το AndroBugs Framework είναι ένα σύστημα ανάλυσης ευπαθειών για Android που βοηθά προγραμματιστές ή hackers να εντοπίσουν πιθανές ευπάθειες ασφαλείας σε εφαρμογές Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** είναι ένα εργαλείο του οποίου ο κύριος στόχος είναι να εντοπίζει και να προειδοποιεί τον χρήστη για πιθανές κακόβουλες συμπεριφορές που αναπτύσσονται από μια εφαρμογή Android.

Η ανίχνευση γίνεται με την **static analysis** του Dalvik bytecode της εφαρμογής, που αναπαρίσταται ως **Smali**, χρησιμοποιώντας τη βιβλιοθήκη [`androguard`](https://github.com/androguard/androguard).

Αυτό το εργαλείο εντοπίζει **συνηθισμένες συμπεριφορές "κακόβουλων" εφαρμογών** όπως: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** είναι ένα **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. Είναι ένα εργαλείο που συγκεντρώνει συνήθως χρησιμοποιούμενα εργαλεία mobile application reverse engineering και analysis, για να βοηθά στο testing εφαρμογών κινητών απέναντι στις OWASP mobile security threats. Στόχος του είναι να κάνει αυτή την εργασία πιο εύκολη και πιο φιλική προς τους developers εφαρμογών κινητών και τους επαγγελματίες ασφάλειας.

It is able to:

- Εξάγει Java και Smali code χρησιμοποιώντας διάφορα εργαλεία
- Αναλύει APKs using: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Εξάγει ιδιωτικές πληροφορίες από το APK χρησιμοποιώντας regexps.
- Αναλύει το Manifest.
- Αναλύει τα domains που βρέθηκαν χρησιμοποιώντας: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Χρήσιμο για την ανίχνευση malware: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Σημειώστε ότι, ανάλογα με την υπηρεσία και τη διαμόρφωση που χρησιμοποιείτε για να obfuscate τον code, τα secrets μπορεί να είναι ή να μην είναι obfuscated.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** είναι ένα open source command-line εργαλείο που συρρικνώνει, βελτιστοποιεί και obfuscates Java code. Μπορεί να βελτιστοποιήσει bytecode καθώς και να εντοπίσει και να αφαιρέσει μη χρησιμοποιούμενες εντολές. Το ProGuard είναι ελεύθερο λογισμικό και διανέμεται υπό την GNU General Public License, έκδοση 2.

Το ProGuard διανέμεται ως μέρος του Android SDK και τρέχει κατά τη διάρκεια της κατασκευής της εφαρμογής σε release mode.

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Την τελευταία φορά που ελέγξαμε, ο τρόπος λειτουργίας του Dexguard ήταν:

- φορτώνει ένα resource ως InputStream;
- τροφοδοτεί το αποτέλεσμα σε μια κλάση που κληρονομεί από FilterInputStream για να το decrypt;
- κάνει κάποια άσκοπη obfuscation για να σπαταλήσει μερικά λεπτά από το χρόνο ενός reverser;
- τροφοδοτεί το decrypted αποτέλεσμα σε ZipInputStream για να πάρει ένα DEX αρχείο;
- τελικά φορτώνει το προκύπτον DEX ως Resource χρησιμοποιώντας τη μέθοδο `loadDex`.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

Μπορείτε να ανεβάσετε ένα obfuscated APK στην πλατφόρμα τους.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

Αυτό είναι ένα LLM εργαλείο για να βρει πιθανές security vulnerabilities σε android apps και να deobfuscate τον android app code. Χρησιμοποιεί το public API Google Gemini.

### [Simplify](https://github.com/CalebFenton/simplify)

It is a **generic android deobfuscator.** Το Simplify **virtually executes an app** για να κατανοήσει τη συμπεριφορά της και στη συνέχεια **προσπαθεί να optimize τον code** ώστε να συμπεριφέρεται ταυτόσημα αλλά να είναι πιο εύκολο για έναν άνθρωπο να το καταλάβει. Κάθε τύπος optimization είναι απλός και generic, οπότε δεν έχει σημασία τι συγκεκριμένος τύπος obfuscation χρησιμοποιήθηκε.

### [APKiD](https://github.com/rednaga/APKiD)

Το APKiD δίνει πληροφορίες για **το πώς φτιάχτηκε ένα APK**. Αναγνωρίζει πολλούς **compilers**, **packers**, **obfuscators**, και άλλα περίεργα πράγματα. Είναι το [_PEiD_](https://www.aldeid.com/wiki/PEiD) για Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b είναι μια Android security virtual machine βασισμένη σε ubuntu-mate που περιλαμβάνει συλλογή από τα τελευταία framework, tutorials και labs από διάφορους security geeks και researchers για reverse engineering και malware analysis.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Είναι μια εξαιρετική λίστα πόρων
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
