# Android Applications Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android Applications की मूल बातें

यह पृष्ठ पढ़ना अत्यधिक अनुशंसित है ताकि आप **Android सुरक्षा से संबंधित सबसे महत्वपूर्ण हिस्सों और किसी Android एप्लिकेशन में सबसे खतरनाक कम्पोनेंट्स** के बारे में जान सकें:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

यह उस मुख्य उपकरण में से है जिसकी आपको एक android डिवाइस (emulated या physical) से कनेक्ट करने के लिए आवश्यकता होती है.\
**ADB** आपको कंप्यूटर से **USB** या **Network** के माध्यम से डिवाइस नियंत्रित करने की अनुमति देता है। यह utility दोनों दिशाओं में फ़ाइलों के **copying**, apps की **installation** और **uninstallation**, shell commands का **execution**, डेटा का **backing up**, logs का **reading**, और अन्य कार्य करने में सक्षम बनाता है।

adb का उपयोग कैसे करना है यह जानने के लिए निम्नलिखित [**ADB Commands**](adb-commands.md) की सूची देखें।

## Smali

कभी-कभी यह उपयोगी होता है कि आप **application code को modify** करें ताकि आप **hidden information** तक पहुँच सकें (शायद अच्छी तरह obfuscated passwords या flags)। ऐसी स्थिति में apk को decompile करना, कोड modify करना और फिर उसे recompile करना दिलचस्प हो सकता है.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). यह dynamic analysis के दौरान प्रस्तुत किए जाने वाले कई tests के लिए एक वैकल्पिक तरीका हो सकता है। इसलिए, हमेशा इस संभावना को ध्यान में रखें।

## Other interesting tricks

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- डिवाइस से APK निकालना:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- सभी splits और base apks को [APKEditor](https://github.com/REAndroid/APKEditor) के साथ मर्ज करें:
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Case Studies & Vulnerabilities


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Static Analysis

सबसे पहले, APK का विश्लेषण करने के लिए आपको **Java code** को decompiler का उपयोग करके देखना चाहिए।\
कृपया, [**read here to find information about different available decompilers**](apk-decompilers.md).

### Looking for interesting Info

APK की **strings** को देखकर आप **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** और किसी भी दिलचस्प चीज़ की तलाश कर सकते हैं... कोड execution के **backdoors** या authentication backdoors (hardcoded admin credentials to the app) की भी जांच करें।

**Firebase**

firebase URLs पर विशेष ध्यान दें और चेक करें कि क्या यह गलत कॉन्फ़िगर है। [More information about whats is FIrebase and how to exploit it here.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Basic understanding of the application - Manifest.xml, strings.xml

किसी एप्लिकेशन की _Manifest.xml_ और **_strings.xml_** फ़ाइलों की जांच संभावित सुरक्षा कमजोरियों का पता लगा सकती है। इन्हें decompilers से एक्सेस किया जा सकता है या APK की फ़ाइल एक्सटेंशन को .zip में rename करके unzip किया जा सकता है।

**Manifest.xml** से पहचानी जाने वाली कमजोरियाँ शामिल हैं:

- **Debuggable Applications**: Manifest.xml में एप्लिकेशन यदि `debuggable="true"` के रूप में सेट हैं तो वे जोखिम पैदा करते हैं क्योंकि वे ऐसे कनेक्शन की अनुमति देते हैं जो exploit की ओर ले जा सकते हैं। debuggable applications को ढूँढने और exploit करने के बारे में समझने के लिए संबंधित ट्यूटोरियल देखें।
- **Backup Settings**: संवेदनशील जानकारी संभालने वाले एप्लिकेशनों के लिए `android:allowBackup="false"` attribute को स्पष्ट रूप से सेट किया जाना चाहिए ताकि adb के माध्यम से अनधिकृत डेटा backups रोके जा सकें, विशेषकर जब usb debugging enabled हो।
- **Network Security**: कस्टम network security configurations (`android:networkSecurityConfig="@xml/network_security_config"`) जो _res/xml/_ में होते हैं, certificate pins और HTTP ट्रैफिक सेटिंग्स जैसे सुरक्षा विवरण निर्दिष्ट कर सकते हैं। उदाहरण के तौर पर कुछ domains के लिए HTTP ट्रैफिक की अनुमति देना।
- **Exported Activities and Services**: Manifest में exported activities और services की पहचान करने से ऐसे components सामने आ सकते हैं जिन्हें गलत तरीके से उपयोग किया जा सकता है। dynamic testing के दौरान आगे की जांच से यह पता चल सकता है कि इन components का कैसे exploit किया जा सकता है।
- **Content Providers and FileProviders**: एक्सपोज़्ड content providers अनधिकृत पहुँच या डेटा में संशोधन की अनुमति दे सकते हैं। FileProviders की configuration को भी अच्छी तरह से जांचा जाना चाहिए।
- **Broadcast Receivers and URL Schemes**: ये components exploitation के लिए इस्तेमाल किए जा सकते हैं, विशेषकर यह देखना कि URL schemes input के लिए कैसे manage किए जा रहे हैं।
- **SDK Versions**: `minSdkVersion`, `targetSDKVersion`, और `maxSdkVersion` attributes यह दर्शाते हैं कि कौन से Android versions सपोर्ट किए जाते हैं, जो यह बताता है कि पुराने, vulnerable Android versions का समर्थन न करना महत्वपूर्ण है।

**strings.xml** फ़ाइल से, संवेदनशील जानकारी जैसे API keys, custom schemas, और अन्य developer notes का पता चल सकता है, जो इन resources की सावधानीपूर्वक समीक्षा की आवश्यकता को रेखांकित करता है।

### Tapjacking

**Tapjacking** एक हमला है जहाँ एक **malicious** **application** लॉन्च होती है और **victim application के ऊपर खुद को पोज़िशन कर लेती है**। जब यह victim app को दृष्टि से छुपा देती है, तो इसका UI इस तरह डिजाइन किया जाता है कि यह उपयोगकर्ता को धोखा दे कर उस पर इंटरैक्ट करवा ले, जबकि यह इंटरैक्शन को victim app को पास कर रहा होता है।\
परिणामस्वरूप, यह **उपयोगकर्ता को अंधा कर देता है कि वे वास्तव में victim app पर ही काम कर रहे हैं**।

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

एक **activity** जिसका **`launchMode`** **`singleTask`** पर सेट है और कोई `taskAffinity` defined नहीं है, वह Task Hijacking के लिए vulnerable होती है। इसका मतलब है कि एक **malicious application** इंस्टॉल की जा सकती है और यदि इसे असली एप्लिकेशन से पहले लॉन्च किया जाए तो यह **असली एप्लिकेशन के task को hijack कर सकती है** (जिससे उपयोगकर्ता यह सोचकर कि वह असली ऐप उपयोग कर रहा है, **malicious application** के साथ interact करेगा)।

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Insecure data storage

**Internal Storage**

Android में, internal storage में रखी फ़ाइलें उस ऐप के द्वारा बनाई गई फ़ाइलों तक ही पहुँच के लिए डिज़ाइन की गई होती हैं। यह सुरक्षा उपाय Android operating system द्वारा लागू किया जाता है और अधिकांश अनुप्रयोगों की सुरक्षा आवश्यकताओं के लिए सामान्यतः पर्याप्त होता है। हालांकि, डेवलपर्स कभी-कभी `MODE_WORLD_READABLE` और `MODE_WORLD_WRITABLE` जैसे modes का उपयोग करते हैं ताकि फाइलें अलग-अलग एप्लिकेशनों के बीच साझा की जा सकें। ये modes इन फाइलों तक अन्य एप्लिकेशनों, संभवतः malicious एप्लिकेशनों की भी पहुँच को रोकते नहीं हैं।

1. **Static Analysis:**
- `MODE_WORLD_READABLE` और `MODE_WORLD_WRITABLE` के उपयोग की सावधानीपूर्वक जांच सुनिश्चित करें। ये modes फाइलों को अनजाने या अनधिकृत पहुँच के लिए उजागर कर सकते हैं।
2. **Dynamic Analysis:**
- ऐप द्वारा बनाए गए फ़ाइलों पर सेट की गई permissions की पुष्टि करें। विशेष रूप से चेक करें कि क्या कोई फ़ाइलें worldwide पढ़ने योग्य या लिखने योग्य सेट की गई हैं। यह एक गंभीर सुरक्षा जोखिम हो सकता है, क्योंकि इससे डिवाइस पर इंस्टॉल कोई भी एप्लिकेशन, उसकी उत्पत्ति या इरादे की परवाह किए बिना, इन फ़ाइलों को पढ़ या संशोधित कर सकता है।

**External Storage**

SD Cards जैसे external storage पर फ़ाइलों के साथ काम करते समय कुछ सावधानियाँ बरतनी चाहिए:

1. **Accessibility**:
- external storage पर फ़ाइलें globally readable और writable होती हैं। इसका अर्थ है कि कोई भी एप्लिकेशन या उपयोगकर्ता इन फ़ाइलों तक पहुँच सकता है।
2. **Security Concerns**:
- आसान पहुँच के कारण, संवेदनशील जानकारी external storage पर स्टोर न करने की सलाह दी जाती है।
- External storage हटाई जा सकती है या किसी भी एप्लिकेशन द्वारा एक्सेस की जा सकती है, जिससे यह कम सुरक्षित होता है।
3. **Handling Data from External Storage**:
- external storage से प्राप्त डेटा पर हमेशा input validation करें। यह आवश्यक है क्योंकि यह डेटा एक untrusted स्रोत से आता है।
- external storage पर executables या class files स्टोर करके dynamic loading के लिए रखना जोरदार रूप से हतोत्साहित किया जाता है।
- यदि आपका एप्लिकेशन external storage से executable फ़ाइलें प्राप्त करना अनिवार्य है, तो सुनिश्चित करें कि इन फाइलों पर sign और cryptographic verification की गई हो इससे पहले कि उन्हें dynamically load किया जाए। यह कदम आपकी एप्लिकेशन की सुरक्षा अखंडता बनाए रखने के लिए महत्वपूर्ण है।

External storage को `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard` में एक्सेस किया जा सकता है

> [!TIP]
> Starting with Android 4.4 (**API 17**), SD card का directory structure ऐसा है जो **किसी app से उस directory तक पहुँच को सीमित करता है जो विशेष रूप से उस app के लिए है**। यह malicious application को दूसरे app की फ़ाइलों तक read या write access पाने से रोकता है।

**Sensitive data stored in clear-text**

- **Shared preferences**: Android प्रत्येक application को आसानी से xml फ़ाइलें `/data/data/<packagename>/shared_prefs/` path में सेव करने की अनुमति देता है और कभी-कभी उस फ़ोल्डर में clear-text में संवेदनशील जानकारी मिल सकती है।
- **Databases**: Android प्रत्येक application को आसानी से sqlite databases `/data/data/<packagename>/databases/` path में सेव करने की अनुमति देता है और कभी-कभी उस फ़ोल्डर में clear-text में संवेदनशील जानकारी मिल सकती है।

### Broken TLS

**Accept All Certificates**

कभी-कभी डेवलपर्स किसी कारणवश सभी certificates स्वीकार कर लेते हैं भले ही उदाहरण के लिए hostname मैच न करे, और इसके लिए कोड की लाइनों का उपयोग कर लेते हैं जैसे कि निम्न:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Broken Cryptography

**Poor Key Management Processes**

कुछ डेवलपर संवेदनशील डेटा को local storage में सेव करते हैं और उसे कोड में hardcoded/अनुमेय (predictable) key से encrypt करते हैं। ऐसा नहीं किया जाना चाहिए क्योंकि कुछ reversing तकनीकें attackers को confidential information निकालने की अनुमति दे सकती हैं।

**Use of Insecure and/or Deprecated Algorithms**

डेवलपरों को authorisation checks, store या send data के लिए **deprecated algorithms** का उपयोग नहीं करना चाहिए। इनमें से कुछ algorithms हैं: RC4, MD4, MD5, SHA1... अगर उदाहरण के लिए पासवर्ड स्टोर करने के लिए **hashes** का उपयोग किया गया है, तो salt के साथ **hashes brute-force resistant** का उपयोग करना चाहिए।

### Other checks

- यह सुझाव दिया जाता है कि attackers के लिए reverse engineer का काम कठिन करने के लिए **APK को obfuscate** किया जाए।
- अगर app sensitive है (जैसे bank apps), तो उसे **mobile is rooted** होने की अपनी जाँच करनी चाहिए और उसी के अनुसार व्यवहार करना चाहिए।
- अगर app sensitive है (जैसे bank apps), तो उसे जांचना चाहिए कि क्या कोई **emulator** उपयोग हो रहा है।
- अगर app sensitive है (जैसे bank apps), तो उसे **check it's own integrity before executing** करना चाहिए ताकि यह सुनिश्चित हो सके कि इसे.modify नहीं किया गया है।
- Use [**APKiD**](https://github.com/rednaga/APKiD) to check which compiler/packer/obfuscator was used to build the APK

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

The tool [**mariana-trench**](https://github.com/facebook/mariana-trench) is capable of finding **vulnerabilities** by **scanning** the **code** of the application. This tool contains a series of **known sources** (that indicates to the tool the **places** where the **input** is **controlled by the user**), **sinks** (which indicates to the tool **dangerous** **places** where malicious user input could cause damages) and **rules**. These rules indicates the **combination** of **sources-sinks** that indicates a vulnerability.

With this knowledge, **mariana-trench will review the code and find possible vulnerabilities on it**.

### Secrets leaked

An application may contain secrets (API keys, passwords, hidden urls, subdomains...) inside of it that you might be able to discover. You could us a tool such as [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> First of all, you need an environment where you can install the application and all the environment (Burp CA cert, Drozer and Frida mainly). Therefore, a rooted device (emulated or not) is extremely recommended.

### Online Dynamic analysis

You can create a **free account** in: [https://appetize.io/](https://appetize.io). This platform allows you to **upload** and **execute** APKs, so it is useful to see how an apk is behaving.

You can even **see the logs of your application** in the web and connect through **adb**.

![](<../../images/image (831).png>)

Thanks to the ADB connection you can use **Drozer** and **Frida** inside the emulators.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (You can create **x86** and **arm** devices, and according to [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** versions **support ARM libraries** without needing an slow arm emulator).
- Learn to set it up in this page:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, you need to create an account. _It's recommend to **download** the version **WITH**_ _**VirtualBox** to avoid potential errors._)
- [**Nox**](https://es.bignox.com) (Free, but it doesn't support Frida or Drozer).

> [!TIP]
> जब किसी भी platform पर नया emulator बनाते हैं तो ध्यान रखें कि स्क्रीन जितनी बड़ी होगी, emulator उतना ही स्लो चलेगा। इसलिए यदि संभव हो तो छोटे स्क्रीन चुनें।

To **install google services** (like AppStore) in Genymotion you need to click on the red marked button of the following image:

![](<../../images/image (277).png>)

Also, notice that in the **configuration of the Android VM in Genymotion** you can select **Bridge Network mode** (this will be useful if you will be connecting to the Android VM from a different VM with the tools).

#### Use a physical device

You need to activate the **debugging** options and it will be cool if you can **root** it:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Once you have installed the application, the first thing you should do is to try it and investigate what does it do, how does it work and get comfortable with it.\
> I will suggest to **perform this initial dynamic analysis using MobSF dynamic analysis + pidcat**, so we will be able to **learn how the application works** while MobSF **captures** a lot of **interesting** **data** you can review later on.

Magisk/Zygisk quick notes (recommended on Pixel devices)
- Patch boot.img with the Magisk app and flash via fastboot to get systemless root
- Enable Zygisk + DenyList for root hiding; consider LSPosed/Shamiko when stronger hiding is required
- Keep original boot.img to recover from OTA updates; re-patch after each OTA
- For screen mirroring, use scrcpy on the host



### Unintended Data Leakage

**Logging**

डेवलपरों को सार्वजनिक रूप से **debugging information** उजागर करने में सावधानी बरतनी चाहिए, क्योंकि इससे संवेदनशील data leak हो सकता है। application logs को मॉनिटर करने के लिए tools [**pidcat**](https://github.com/JakeWharton/pidcat) और `adb logcat` की सिफारिश की जाती है ताकि संवेदनशील जानकारी की पहचान और सुरक्षा की जा सके। **Pidcat** इसकी उपयोगिता और पठनीयता के कारण प्रायः प्राथमिकता दिया जाता है।

> [!WARNING]
> Note that from **later newer than Android 4.0**, **applications are only able to access their own logs**. So applications cannot access other apps logs.\
> Anyway, it's still recommended to **not log sensitive information**.

**Copy/Paste Buffer Caching**

Android का **clipboard-based** framework apps में copy-paste सुविधा देता है, लेकिन जोखिम यह है कि **other applications** clipboard तक **access** कर सकती हैं, जिससे संवेदनशील डेटा उजागर हो सकता है। इसलिए application के संवेदनशील हिस्सों (जैसे credit card details) के लिए copy/paste functions को disable करना आवश्यक है ताकि data leak से बचा जा सके।

**Crash Logs**

यदि कोई application **crashes** और logs सेव करता है, तो ये logs attackers की मदद कर सकते हैं, खासकर जब application को reverse-engineer नहीं किया जा सकता। इस जोखिम को कम करने के लिए, crashes पर logging से बचें, और यदि logs नेटवर्क पर भेजने ही हों तो उन्हें SSL चैनल के माध्यम से भेजना सुनिश्चित करें।

As pentester, **try to take a look to these logs**.

**Analytics Data Sent To 3rd Parties**

Applications अक्सर Google Adsense जैसे services integrate करते हैं, जो developers के गलत implementation की वजह से अनजाने में संवेदनशील data leak कर सकते हैं। संभावित data leaks पहचानने के लिए, application के traffic को intercept करना और third-party services को भेजे जा रहे किसी भी संवेदनशील जानकारी की जाँच करना सलाहकार है।

### SQLite DBs

ज़्यादातर applications internal SQLite databases का उपयोग करके जानकारी सेव करेंगे। pentest के दौरान बनाए गए **databases**, **tables** और **columns** के नामों और सेव किए गए सारे डेटा को ध्यान से देखें क्योंकि आप वहां **sensitive information** पा सकते हैं (जो कि vulnerability होगी).\
Databases आमतौर पर `/data/data/the.package.name/databases` में स्थित होते हैं जैसे `/data/data/com.mwr.example.sieve/databases`

अगर database confidential information सेव कर रहा है और वह **encrypted b**ut आप application के अंदर password **find** कर सकते हैं तो यह फिर भी एक **vulnerability** है।

.tables का उपयोग करके tables enumerate करें और tables के columns को `.schema <table_name>` करके enumerate करें

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** आपको **assume the role of an Android app** और अन्य apps के साथ interact करने की अनुमति देता है। यह वही कुछ भी कर सकता है जो एक installed application कर सकता है, जैसे Android’s Inter-Process Communication (IPC) mechanism का उपयोग करना और underlying operating system के साथ interact करना। .\
Drozer एक उपयोगी tool है जो **exported activities, exported services and Content Providers** को exploit करने में मदद करता है जैसा कि आप अगले sections में सीखेंगे।

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
यह भी याद रखें कि किसी activity का कोड **`onCreate`** method में शुरू होता है।

**Authorisation bypass**

जब कोई Activity exported होती है तो आप उसकी screen को external app से invoke कर सकते हैं। इसलिए, अगर किसी activity में **sensitive information** है और वह **exported** है तो आप authentication mechanisms को **bypass** करके उसे access कर सकते हैं।

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

You can also start an exported activity from adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**नोट**: MobSF किसी activity में `android:launchMode` के रूप में _**singleTask/singleInstance**_ के उपयोग को malicious के रूप में पहचान सकता है, लेकिन [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750) के कारण, जाहिर तौर पर यह केवल पुराने वर्शनों (API versions < 21) में ही खतरनाक है।

> [!TIP]
> ध्यान दें कि एक authorisation bypass हमेशा एक vulnerability नहीं होता; यह इस बात पर निर्भर करेगा कि bypass कैसे काम करता है और कौन सी जानकारी प्रकट होती है।

**Sensitive information leakage**

**Activities can also return results**. यदि आप किसी exported और unprotected activity को ढूंढ पाते हैं जो **`setResult`** method को कॉल कर रही हो और **returning sensitive information**, तो there is a sensitive information leakage।

#### Tapjacking

यदि tapjacking रोका नहीं गया है, तो आप exported activity का दुरुपयोग करके **user को अप्रत्याशित क्रियाएँ करवा सकते हैं**। अधिक जानकारी के लिए [**what is Tapjacking follow the link**](#tapjacking) देखें।

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers मूल रूप से **share data** के लिए उपयोग किए जाते हैं। यदि किसी app के पास उपलब्ध content providers हैं, तो आप उनसे **extract sensitive** data कर सकते हैं। इसके अलावा संभावित **SQL injections** और **Path Traversals** का परीक्षण करना भी महत्वपूर्ण है क्योंकि वे vulnerable हो सकते हैं।

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
ध्यान रखें कि Service की क्रियाएँ method `onStartCommand` में शुरू होती हैं।

Service मूलतः ऐसा कुछ है जो **data receive** कर सकता है, उसे **process** करता है और (या नहीं) एक response **returns** करता है। इसलिए, यदि कोई application कुछ services export कर रहा है तो आपको **code** की जाँच करनी चाहिए यह समझने के लिए कि यह क्या कर रहा है और गोपनीय जानकारी निकालने, authentication measures को bypass करने के लिए इसे **dynamically** test करना चाहिए।\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
ध्यान रखें कि Broadcast Receiver की क्रियाएँ method `onReceive` में शुरू होती हैं।

एक broadcast receiver किसी प्रकार के message का इंतज़ार करेगा। यह निर्भर करता है कि receiver उस संदेश को कैसे handle करता है, यह vulnerable हो सकता है।\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

आप deep links मैन्युअली ढूंढ सकते हैं, MobSF जैसे tools या [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py) जैसे scripts का उपयोग करके।\
आप adb या किसी browser का उपयोग करके घोषित **scheme** को **open** कर सकते हैं:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_ध्यान दें कि आप **पैकेज नाम छोड़ सकते हैं** और मोबाइल स्वचालित रूप से उस ऐप को कॉल करेगा जो उस लिंक को खोलना चाहिए._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**App में निष्पादित होने वाला code**

App में निष्पादित होने वाला code खोजने के लिए, deeplink द्वारा कॉल की गई activity में जाएं और function **`onNewIntent`** खोजें।

![](<../../images/image (436) (1) (1) (1).png>)

**संवेदनशील जानकारी**

हर बार जब आप कोई deep link पाते हैं तो जांचें कि **यह URL parameters के माध्यम से संवेदनशील डेटा (जैसे passwords) प्राप्त नहीं कर रहा है**, क्योंकि कोई भी अन्य application **उस deep link की impersonate करके वह डेटा चुरा सकता है!**

**Path में Parameters**

आपको **यह भी जांचना चाहिए कि कोई deep link URL के path के अंदर parameter तो उपयोग नहीं कर रहा है** जैसे: `https://api.example.com/v1/users/{username}` , उस स्थिति में आप path traversal जबरदस्ती कर सकते हैं जैसे: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
ध्यान दें कि यदि आप application के अंदर सही endpoints ढूंढ लेते हैं तो आप **Open Redirect** (यदि path का कोई हिस्सा domain name के रूप में उपयोग होता है), **account takeover** (यदि आप CSRF token के बिना user details बदल सकते हैं और vulnerable endpoint ने सही method उपयोग किया) और किसी अन्य vuln का कारण बन सकते हैं। अधिक जानकारी के लिए [यहाँ](http://dphoeniixx.com/2020/12/13-2/) देखें।

**More examples**

एक [दिलचस्प bug bounty रिपोर्ट](https://hackerone.com/reports/855618) links के बारे में (_/.well-known/assetlinks.json_).

### ट्रांसपोर्ट लेयर निरीक्षण और सत्यापन विफलताएँ

- **Certificates हमेशा सही तरीके से निरीक्षित नहीं किए जाते** Android applications द्वारा। अक्सर ये applications warnings को अनदेखा कर self-signed certificates स्वीकार कर लेते हैं या कुछ मामलों में HTTP connections पर वापस चले जाते हैं।
- **SSL/TLS handshake के दौरान negotiations कभी-कभार कमजोर होते हैं**, जो insecure cipher suites का उपयोग करते हैं। यह vulnerability connection को man-in-the-middle (MITM) attacks के लिए संवेदनशील बनाती है, जिससे attackers डेटा decrypt कर सकते हैं।
- **Leakage of private information** एक जोखिम है जब applications secure channels का उपयोग करके authenticate करती हैं पर अन्य transactions के लिए non-secure channels पर communicate करती हैं। यह तरीका sensitive data, जैसे session cookies या user details, को malicious entities द्वारा interception से सुरक्षित नहीं रखता।

#### सर्टिफिकेट सत्यापन

हम **certificate verification** पर ध्यान केंद्रित करेंगे। सुरक्षा बढ़ाने के लिए server के certificate की integrity verify करना आवश्यक है। यह महत्वपूर्ण है क्योंकि insecure TLS configurations और unencrypted channels पर संवेदनशील डेटा का ट्रांसमिशन गंभीर जोखिम पैदा कर सकता है। server certificates verify करने और vulnerabilities को ठीक करने के विस्तृत चरणों के लिए, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) विस्तृत मार्गदर्शन प्रदान करता है।

#### SSL Pinning

SSL Pinning एक security measure है जहाँ application server के certificate को application में स्टोर ज्ञात copy के खिलाफ verify करती है। यह तरीका MITM attacks को रोकने के लिए आवश्यक है। संवेदनशील जानकारी संभालने वाली applications के लिए SSL Pinning लागू करना अत्यधिक अनुशंसित है।

#### ट्रैफ़िक निरीक्षण

HTTP ट्रैफ़िक inspect करने के लिए, **proxy tool का certificate install करना** आवश्यक है (उदा., Burp)। इस certificate को install किए बिना, encrypted ट्रैफ़िक proxy के माध्यम से दिखाई नहीं दे सकता। custom CA certificate install करने के लिए गाइड के लिए, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine) देखें।

Applications जो **API Level 24 and above** लक्षित करती हैं, उन्हें proxy की CA certificate स्वीकार करने के लिए Network Security Config में परिवर्तन करने की आवश्यकता होती है। यह कदम encrypted ट्रैफ़िक inspect करने के लिए महत्वपूर्ण है। Network Security Config बदलने के निर्देशों के लिए, [**refer to this tutorial**](make-apk-accept-ca-certificate.md) देखें।

यदि **Flutter** उपयोग हो रहा है तो आपको [**this page**](flutter.md) में दिए निर्देशों का पालन करना होगा। ऐसा इसलिए है क्योंकि केवल certificate को store में जोड़ना काम नहीं करेगा क्योंकि Flutter के पास अपनी स्वयं की valid CAs की सूची होती है।

#### SSL/TLS pinning का static पता लगाना

Runtime bypasses का प्रयास करने से पहले तेज़ी से मैप करें कि APK में कहाँ pinning लागू है। Static discovery आपको hooks/patches की योजना बनाने और सही code paths पर ध्यान केंद्रित करने में मदद करता है।

Tool: SSLPinDetect
- Open-source static-analysis utility है जो APK को Smali में decompile करता है (via apktool) और SSL/TLS pinning implementations के curated regex patterns के लिए scan करता है।
- प्रत्येक मिलान के लिए exact file path, line number, और एक code snippet रिपोर्ट करता है।
- सामान्य frameworks और custom code paths को कवर करता है: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, और Network Security Config XML pins।

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
उपयोग
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Example pattern rules (JSON)
प्रोप्रायटरी/कस्टम pinning शैलियों का पता लगाने के लिए signatures का उपयोग करें या इन्हें बढ़ाएँ। आप अपना JSON लोड करके बड़े पैमाने पर scan कर सकते हैं।
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
नोट्स और टिप्स
- बड़े ऐप्स पर तेज़ स्कैनिंग के लिए multi-threading और memory-mapped I/O का उपयोग करें; pre-compiled regex से overhead और false positives कम होते हैं।
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- अगले ट्रायएज के लिए सामान्य detection targets:
- OkHttp: CertificatePinner का उपयोग, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Declarative pins res/xml में network security config और manifest references
- मैचे हुए लोकेशनों का उपयोग Frida hooks, static patches, या config reviews प्लान करने के लिए करें, dynamic testing से पहले।

#### Bypassing SSL Pinning

जब SSL Pinning लागू होता है, HTTPS ट्रैफिक निरीक्षण करने के लिए इसे bypass करना आवश्यक हो जाता है। इसके लिए कई तरीके उपलब्ध हैं:

- Automatically **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). इस विकल्प का सबसे बड़ा फायदा यह है कि SSL Pinning bypass करने के लिए root की जरूरत नहीं होगी, लेकिन आपको एप्लिकेशन को डिलीट करके नया इंस्टॉल करना होगा, और यह हमेशा काम नहीं करेगा।
- आप **Frida** (नीचे बताया गया) का उपयोग करके इस प्रोटेक्शन को bypass कर सकते हैं। Burp+Frida+Genymotion उपयोग करने की गाइड यहाँ है: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- आप [**objection**](frida-tutorial/objection-tutorial.md) का उपयोग करके SSL Pinning को ऑटोमैटिकली bypass करने की कोशिश भी कर सकते हैं:**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- आप MobSF dynamic analysis (नीचे समझाया गया) का उपयोग करके SSL Pinning को ऑटोमैटिकली bypass करने की कोशिश भी कर सकते हैं
- यदि आपको लगता है कि अभी भी कुछ ट्रैफिक कैप्चर नहीं हो रहा है, तो आप iptables का उपयोग करके ट्रैफिक को Burp पर forward करने की कोशिश कर सकते हैं। पढ़ें: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Looking for Common Web Vulnerabilities

ऐप के अंदर सामान्य web vulnerabilities की खोज करना भी महत्वपूर्ण है। इन vulnerabilities की पहचान और निवारण पर विस्तृत जानकारी इस सारांश के दायरे से बाहर है लेकिन कहीं और व्यापक रूप से कवर की गई है।

### Frida

[Frida](https://www.frida.re) developers, reverse-engineers, और security researchers के लिए एक dynamic instrumentation toolkit है।\
**आप running application तक पहुँचकर run time पर methods को hook कर सकते हैं ताकि behaviour बदलें, values बदलें/निकाले, अलग code चलाएँ...**\
यदि आप Android applications का pentest करना चाहते हैं तो आपको Frida का उपयोग करना आना चाहिए।

- Frida सीखने के लिए: [**Frida tutorial**](frida-tutorial/index.html)
- Frida के साथ actions के लिए कुछ "GUI": [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection Frida के उपयोग को automate करने के लिए अच्छा है: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- कुछ Awesome Frida scripts यहाँ मिलेंगी: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- anti-debugging / anti-frida mechanisms को bypass करने के लिए Frida को इस तरह load करने की कोशिश करें जैसा कि [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) में बताया गया है (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

जाँचें कि क्या application मेमोरी में संवेदनशील जानकारी रख रहा है जो उसे नहीं रखनी चाहिए, जैसे passwords या mnemonics।

Fridump3 का उपयोग कर आप ऐप की मेमोरी dump कर सकते हैं:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
यह मेमोरी ./dump फ़ोल्डर में dump कर देगा, और वहाँ आप कुछ इस तरह grep कर सकते हैं:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Keystore में संवेदनशील डेटा**

Android में Keystore संवेदनशील डेटा स्टोर करने के लिए सबसे अच्छा स्थान है, लेकिन पर्याप्त privileges होने पर इसे अभी भी **access करना संभव** है। चूँकि applications यहाँ अक्सर **sensitive data in clear text** स्टोर करती हैं, इसलिए pentests को इसे root user के रूप में या किसी के पास फिजिकल पहुँच होने पर जांचना चाहिए क्योंकि वे इस डेटा को चुरा सकते हैं।

भले ही कोई app डेटा को keystore में स्टोर करे, वह डेटा एन्क्रिप्टेड होना चाहिए।

Keystore के अंदर मौजूद डेटा तक पहुँचने के लिए आप इस Frida script का उपयोग कर सकते हैं: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

निम्नलिखित Frida script का उपयोग करके Android applications में कुछ संवेदनशील हिस्सों की सुरक्षा के लिए लागू किए गए authentication को **bypass fingerprint authentication** किया जा सकता है:
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **पृष्ठभूमि छवियाँ**

जब आप किसी ऐप को बैकग्राउंड में रखते हैं, Android उस ऐप का **snapshot of the application** स्टोर करता है ताकि जब वह फ़ोरग्राउंड में वापस लाया जाए तो यह ऐप से पहले इमेज लोड करना शुरू कर दे और ऐसा लगे कि ऐप तेज़ी से लोड हुआ।

हालाँकि, यदि इस snapshot में **sensitive information** मौजूद है, तो snapshot तक पहुँच रखने वाला कोई भी व्यक्ति **steal that info** कर सकता है (ध्यान दें कि इसे एक्सेस करने के लिए root चाहिए)।

Snapshots सामान्यतः यहाँ स्टोर होते हैं: **`/data/system_ce/0/snapshots`**

Android स्क्रीनशॉट कैप्चर को रोकने का एक तरीका प्रदान करता है: **स्क्रीनशॉट कैप्चर को रोकने के लिए FLAG_SECURE सेट करना**। इस फ्लैग का उपयोग करने पर विंडो की सामग्री को सुरक्षित माना जाता है, जिससे वह स्क्रीनशॉट में दिखाई नहीं देती और गैर‑सुरक्षित डिस्प्ले पर नहीं देखी जा सकती।
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

यह टूल डायनामिक विश्लेषण के दौरान विभिन्न उपकरणों को प्रबंधित करने में मदद कर सकता है: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

डेवलपर्स अक्सर activities, services, और broadcast receivers जैसे proxy components बनाते हैं जो इन Intents को हैंडल करते हैं और उन्हें `startActivity(...)` या `sendBroadcast(...)` जैसी मेथड्स को पास कर देते हैं, जो जोखिम भरा हो सकता है।

खतरा इस बात में है कि attackers को इन Intents को गलत दिशा देकर non-exported app components को ट्रिगर करने या sensitive content providers तक पहुँचने की अनुमति मिल सकती है। एक उल्लेखनीय उदाहरण है `WebView` component द्वारा URLs को `Intent` objects में `Intent.parseUri(...)` के माध्यम से कन्वर्ट करना और फिर उन्हें execute करना, जो संभावित रूप से malicious Intent injections का कारण बन सकता है।

### आवश्यक निष्कर्ष

- **Intent Injection** web के Open Redirect issue जैसा है।
- Exploits में `Intent` objects को extras के रूप में पास करना शामिल है, जिन्हें redirect करके unsafe operations को execute कराया जा सकता है।
- यह non-exported components और content providers को attackers के सामने उजागर कर सकता है।
- `WebView` द्वारा URL से `Intent` में conversion अनिच्छित actions की सुविधा प्रदान कर सकता है।

### Android Client Side Injections and others

शायद आप वेब में इस तरह की vulnerabilities के बारे में जानते होंगे। Android application में इन vulnerabilities के साथ विशेष सावधानी बरतनी चाहिए:

- **SQL Injection:** जब dynamic queries या Content-Providers के साथ काम कर रहे हों तो सुनिश्चित करें कि आप parameterized queries का उपयोग कर रहे हैं।
- **JavaScript Injection (XSS):** Verify that JavaScript and Plugin support is disabled for any WebViews (disabled by default). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews को file system तक access disabled होना चाहिए (डिफ़ॉल्ट रूप से enabled) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: कई मामलों में जब the android application सेशन खत्म करता है तो cookie revoke नहीं होता या यह disk पर भी saved हो सकता है
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## स्वचालित विश्लेषण

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**स्टैटिक विश्लेषण**

![](<../../images/image (866).png>)

**एप्लिकेशन का vulnerability आकलन** एक अच्छा web-based frontend उपयोग करके किया जाता है। आप डायनामिक विश्लेषण भी कर सकते हैं (लेकिन आपको environment तैयार करना होगा)।
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Assisted Dynamic analysis with MobSF

**MobSF** मोबाइल में **dynamic analysis** के लिए भी बहुत मददगार हो सकता है, लेकिन इस मामले में आपको अपने होस्ट पर MobSF और **genymotion** इंस्टॉल करना होगा (VM या Docker काम नहीं करेगा)। _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
**MobSF dynamic analyser** निम्न कर सकता है:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). इन सब को स्वचालित रूप से किया जाता है सिवाय screenshots के — स्क्रीनशॉट लेने के लिए आपको उस समय दबाना होगा जब आप स्क्रीनशॉट चाहते हैं या सभी exported activities के स्क्रीनशॉट प्राप्त करने के लिए "**Exported Activity Tester**" दबाना होगा।
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

android **versions > 5** से, यह **स्वतः Frida शुरू** कर देगा और ट्रैफिक पकड़ने के लिए global **proxy** सेटिंग्स करेगा। यह केवल टेस्ट की जा रही application से ट्रैफिक ही capture करेगा।

**Frida**

By default, यह कुछ Frida Scripts भी उपयोग करेगा ताकि **SSL pinning**, **root detection** और **debugger detection** को bypass किया जा सके और **interesting APIs** की निगरानी की जा सके।\
MobSF **invoke exported activities** भी कर सकता है, उनका **screenshots** ले सकता है और रिपोर्ट के लिए उन्हें **save** कर सकता है।

डायनामिक टेस्टिंग शुरू करने के लिए हरे बटन पर प्रेस करें: "**Start Instrumentation**". "**Frida Live Logs**" पर प्रेस करके आप Frida scripts द्वारा जनरेट किए गए logs देख सकते हैं और "**Live API Monitor**" पर जाकर hooked methods, पास किए गए arguments और returned values देख सकते हैं (यह "Start Instrumentation" दबाने के बाद दिखाई देगा)।\
MobSF आपको अपने **Frida scripts** भी लोड करने की अनुमति देता है (अपने Frida scripts के results को MobSF को भेजने के लिए `send()` function का उपयोग करें)। इसमें कई **pre-written scripts** भी होते हैं जिन्हें आप लोड कर सकते हैं (आप और scripts `MobSF/DynamicAnalyzer/tools/frida_scripts/others/` में जोड़ सकते हैं), बस उन्हें **select** करें, "**Load**" दबाएँ और "**Start Instrumentation**" दबाएँ (आप उन scripts के logs "**Frida Live Logs**" के अंदर देख पाएँगे)।

![](<../../images/image (419).png>)

इसके अलावा, आपके पास कुछ Auxiliary Frida functionalities हैं:

- **Enumerate Loaded Classes**: यह सभी loaded classes प्रिंट करेगा
- **Capture Strings**: application का उपयोग करते हुए सभी capture strings प्रिंट करेगा (बहुत noisy)
- **Capture String Comparisons**: बहुत उपयोगी हो सकता है। यह **दोनों strings जो compare हो रही हैं** दिखाएगा और परिणाम True या False था या नहीं।
- **Enumerate Class Methods**: क्लास का नाम डालें (जैसे "java.io.File") और यह क्लास के सभी methods प्रिंट कर देगा।
- **Search Class Pattern**: pattern द्वारा classes खोजें
- **Trace Class Methods**: किसी **पूरी class** को **trace** करें (क्लास के सभी methods के inputs और outputs देखें)। ध्यान रखें कि default में MobSF कई दिलचस्प Android API methods को trace करता है।

एक बार जब आपने वह auxiliary module चुन लिया है जो आप उपयोग करना चाहते हैं, तो आपको "**Start Intrumentation**" दबाना होगा और आप सभी outputs "**Frida Live Logs**" में देखेंगे।

**Shell**

MobSF डायनामिक analysis पेज के नीचे कुछ **adb** commands, **MobSF commands**, और सामान्य **shell** **commands** के साथ एक shell भी प्रदान करता है। कुछ रोचक commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP tools**

When http traffic is capture you can see an ugly view of the captured traffic on "**HTTP(S) Traffic**" bottom or a nicer view in "**Start HTTPTools**" green bottom. From the second option, you can **send** the **captured requests** to **proxies** like Burp or Owasp ZAP.\
To do so, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> press "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

MobSF के साथ dynamic analysis पूरा करने के बाद आप "**Start Web API Fuzzer**" दबाकर **fuzz http requests** कर सकते हैं और vulnerabilities की तलाश कर सकते हैं।

> [!TIP]
> MobSF के साथ dynamic analysis करने के बाद proxy settings गलत कॉन्फ़िगर हो सकती हैं और आप उन्हें GUI से ठीक नहीं कर पाएंगे। आप proxy settings को ठीक करने के लिए नीचे दिया गया कमांड चला सकते हैं:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

You can get the tool from [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
यह टूल कुछ **Hooks** का उपयोग करेगा ताकि जब आप **dynamic analysis** कर रहे हों तो आपको पता चल सके **एप्लिकेशन में क्या हो रहा है**।

### [Yaazhini](https://www.vegabird.com/yaazhini/)

This is a **great tool to perform static analysis with a GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

This tool is designed to look for several **security related Android application vulnerabilities**, either in **source code** or **packaged APKs**. The tool is also **capable of creating a "Proof-of-Concept" deployable APK** and **ADB commands**, to exploit some of the found vulnerabilities (Exposed activities, intents, tapjacking...). As with Drozer, there is no need to root the test device.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- आसान संदर्भ के लिए सभी निकाले गए फ़ाइलें दिखाता है
- APK फ़ाइलों को स्वचालित रूप से Java और Smali फॉर्मैट में decompile करता है
- सामान्य कमजोरियों और व्यवहार के लिए AndroidManifest.xml का विश्लेषण करता है
- सामान्य कमजोरियों और व्यवहार के लिए स्थैतिक स्रोत कोड विश्लेषण
- डिवाइस जानकारी
- और भी
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER एक command-line application है जिसे Windows, MacOS X और Linux पर उपयोग किया जा सकता है, जो _.apk_ फाइलों का विश्लेषण करके vulnerabilities की तलाश करता है। यह APKs को decompress करके और vulnerabilities का पता लगाने के लिए नियमों की एक श्रृंखला लागू करके यह करता है।

सभी नियम `rules.json` फाइल में केंद्रित हैं, और प्रत्येक कंपनी या टेस्टर अपनी ज़रूरत के अनुसार अपने नियम बना सकता है।

नवीनतम binaries को [download page](https://superanalyzer.rocks/download.html) से डाउनलोड करें
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn एक **क्रॉस-प्लेटफ़ॉर्म** टूल है जो डेवलपर्स, bugbounty hunters और ethical hackers को मोबाइल एप्लिकेशन्स पर [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) करने में सहायता करता है।

कन्सेप्ट यह है कि आप अपनी मोबाइल एप्लिकेशन फ़ाइल (.apk या .ipa फ़ाइल) को StaCoAn एप्लिकेशन पर खींचकर छोड़ें और यह आपके लिए एक विज़ुअल और पोर्टेबल रिपोर्ट जनरेट करेगा। आप सेटिंग्स और wordlists को ट्वीक करके एक कस्टमाइज़्ड अनुभव प्राप्त कर सकते हैं।

डाउनलोड[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework एक Android vulnerability analysis सिस्टम है जो डेवलपर्स या hackers को Android applications में संभावित सुरक्षा कमजोरियों को खोजने में मदद करता है.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** एक उपकरण है जिसका मुख्य उद्देश्य उपयोगकर्ता को किसी Android application द्वारा विकसित संभावित malicious व्यवहारों के बारे में पहचानना और चेतावनी देना है।

यह detection application's Dalvik bytecode के **static analysis** के साथ की जाती है, जो **Smali** के रूप में प्रस्तुत होती है, और इसके लिए [`androguard`](https://github.com/androguard/androguard) लाइब्रेरी का उपयोग किया जाता है।

यह उपकरण **common behavior of "bad" applications** जैसे: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution... की तलाश करता है।
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. यह एक ऐसा टूल है जो सामान्यतः उपयोग किए जाने वाले mobile application reverse engineering और analysis tools को एक साथ रखता है, ताकि OWASP mobile security threats के खिलाफ mobile applications का परीक्षण करना आसान हो सके। इसका उद्देश्य mobile application developers और security professionals के लिए यह कार्य सरल और अधिक मैत्रीपूर्ण बनाना है।

It is able to:

- Extract Java and Smali code using different tools
- Analyze APKs using: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Extract private information from the APK using regexps.
- Analyze the Manifest.
- Analyze found domains using: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

malware का पता लगाने के लिए उपयोगी: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

ध्यान दें कि आप जिस service और configuration का उपयोग करते हैं, उसके अनुसार कोड obfuscate होने पर secrets obfuscated रह सकते हैं या नहीं रह सकते।

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. यह bytecode को optimize कर सकता है और unused instructions का पता लगा कर हटाने में सक्षम है। ProGuard free software है और GNU General Public License, version 2 के अंतर्गत वितरित होता है।

ProGuard Android SDK का हिस्सा के रूप में वितरित होता है और release mode में application build करते समय चलता है।

### [DexGuard](https://www.guardsquare.com/dexguard)

Deobfuscate करने के लिए step-by-step guide यहाँ मिलती है: [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Last time we checked, the Dexguard mode of operation was:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

आप एक obfuscated APK को उनके प्लेटफ़ॉर्म पर upload कर सकते हैं।

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

यह एक LLM टूल है जो android apps में संभावित security vulnerabilities खोजने और android app code को deobfuscate करने के लिए है। Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

यह एक **generic android deobfuscator** है। Simplify ऐप को लगभग तौर पर execute करता है ताकि उसके व्यवहार को समझा जा सके और फिर **कोड को optimize करने की कोशिश करता है** ताकि यह समान व्यवहार करे लेकिन इंसान के लिए समझना आसान हो। प्रत्येक optimization प्रकार simple और generic है, इसलिए यह मायने नहीं रखता कि किस specific प्रकार की obfuscation का उपयोग किया गया था।

### [APKiD](https://github.com/rednaga/APKiD)

APKiD आपको यह जानकारी देता है कि **how an APK was made**। यह कई **compilers**, **packers**, **obfuscators**, और अन्य अजीब चीज़ों की पहचान करता है। यह Android के लिए [_PEiD_] है।

### Manual

[इस tutorial को पढ़ें ताकि आप कुछ tricks सीख सकें कि **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b एक Android security virtual machine है जो ubuntu-mate पर आधारित है और इसमें reverse engineering और malware analysis के लिए नवीनतम framework, tutorials और labs का संग्रह शामिल है।

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) यह संसाधनों की एक शानदार सूची है
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)

## Yet to try

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
