# Android Applications Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android Applications Basics

Dit word sterk aanbeveel om eers hierdie bladsy te lees om die **belangrikste gedeeltes wat verband hou met Android-sekuriteit en die gevaarlikste komponente in 'n Android-toepassing** te leer ken:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Dit is die hoofhulpmiddel wat jy nodig het om aan 'n Android-toestel (gesimuleer of fisies) te koppel.\
**ADB** stel jou in staat om toestelle oor **USB** of **Network** van 'n rekenaar te beheer. Hierdie hulpmiddel maak dit moontlik om lêers in albei rigtings te **kopieer**, toepassings te **installeer** en te **verwyder**, shell-opdragte uit te **voer**, data te **rugsteun**, logs te **lees**, onder andere funksies.

Kyk na die volgende lys van [**ADB Commands**](adb-commands.md) om te leer hoe om adb te gebruik.

## Smali

Soms is dit interessant om die **toepassingskode te wysig** om by **weggesteekte inligting** te kom (miskien goed obfuscated wagwoorde of flags). Dan kan dit handig wees om die apk te dekompilleer, die kode te wysig en dit weer te kompilleer.\
[**In hierdie tutorial** kan jy **leer hoe om 'n APK te dekompilleer, Smali-kode te wysig en die APK weer te kompilleer** met die nuwe funksionaliteit](smali-changes.md). Dit kan baie nuttig wees as 'n **alternatief vir verskeie toetse tydens die dinamiese analise** wat aangebied gaan word. Hou dus **altyd hierdie moontlikheid in gedagte**.

## Other interesting tricks

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **Laai APKs af**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Onttrek APK vanaf toestel:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Voeg alle splits en base apks saam met [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Gevallestudies & Kwesbaarhede


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Statiese Analise

Eerstens, vir die ontleding van 'n APK moet jy **na die Java code kyk** met 'n decompiler.\
Lees asseblief [**hier vir inligting oor verskillende beskikbare decompilers**](apk-decompilers.md).

### Op soek na interessante inligting

Deur net na die **strings** van die APK te kyk kan jy soek na **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** en enigiets interessant... kyk selfs vir code execution **backdoors** of authentication backdoors (hardcoded admin credentials to the app).

**Firebase**

Let besondere aandag aan **Firebase URLs** en kontroleer of dit verkeerd gekonfigureer is. [Meer inligting oor wat Firebase is en hoe om dit te misbruik hier.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Basiese begrip van die toepassing - Manifest.xml, strings.xml

Die **ondersoek van 'n toepassing se _Manifest.xml_ en **_strings.xml_** lêers kan potensiële sekuriteitskwesbaarhede openbaar**. Hierdie lêers kan verkry word met behulp van decompilers of deur die APK-lêeruitbreiding na .zip te hernoem en dit dan uit te pak.

**Kwesbaarhede** geïdentifiseer in die **Manifest.xml** sluit in:

- **Debuggable Applications**: Aplikasies wat as debuggable gestel is (`debuggable="true"`) in die _Manifest.xml_ lêer vorm 'n risiko aangesien hulle verbindings toelaat wat tot uitbuiting kan lei. Vir meer begrip oor hoe om debuggable applications te eksploiteer, verwys na 'n handleiding oor die vind en uitbuiting van debuggable applications op 'n toestel.
- **Backup Settings**: Die `android:allowBackup="false"` attribuut moet uitdruklik gestel wees vir toepassings wat met sensitiewe inligting werk om ongemagtigde data-backups via adb te voorkom, veral wanneer usb debugging aangeskakel is.
- **Network Security**: Pasgemaakte network security-konfigurasies (`android:networkSecurityConfig="@xml/network_security_config"`) in _res/xml/_ kan sekuriteitsbesonderhede spesifiseer soos sertifikaat-pins en HTTP-verkeerinstellings. 'n Voorbeeld is om HTTP-verkeer vir spesifieke domeine toe te laat.
- **Exported Activities and Services**: Die identifisering van exported activities en services in die manifest kan komponente uitlig wat misbruik kan word. Verdere analise tydens dinamiese toetsing kan openbaar hoe om hierdie komponente te eksploiteer.
- **Content Providers and FileProviders**: Blootgestelde content providers kan ongemagtigde toegang of wysiging van data toelaat. Die konfigurasie van FileProviders moet ook deeglik ondersoek word.
- **Broadcast Receivers and URL Schemes**: Hierdie komponente kan vir uitbuiting aangewend word, met spesiale aandag aan hoe URL schemes bestuur word vir invoer-kwesbaarhede.
- **SDK Versions**: Die `minSdkVersion`, `targetSDKVersion`, en `maxSdkVersion` attribuut wys die ondersteunde Android-weergawes, wat die belangrikheid beklemtoon om nie verouderde, kwesbare Android-weergawes te ondersteun nie.

In die **strings.xml** lêer kan sensitiewe inligting soos API keys, custom schemas en ander ontwikkelaar-notas gevind word, wat die behoefte aan 'n deeglike hersiening van hierdie hulpbronne beklemtoon.

### Tapjacking

**Tapjacking** is 'n aanval waar 'n **kwaadwillige toepassing** gelanseer word en homself bo-op 'n slagoffer-toepassing posisioneer. Sodra dit die slagoffer-app sigbaar verdoesel, is sy gebruikerskoppelvlak so ontwerp om die gebruiker te mislei om daarmee te kommunikeer, terwyl dit die interaksie aan die slagoffer-app deurgee. In werklikheid word die gebruiker verblind sodat hulle nie weet dat hulle eintlik aksies op die slagoffer-app uitvoer nie.

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

'n activity met die `launchMode` gestel op `singleTask` sonder enige `taskAffinity` gedefinieer is kwesbaar vir Task Hijacking. Dit beteken dat 'n application geïnstalleer kan word en as dit voor die regte toepassing gelanseer word, kan dit die taak van die regte toepassing kaap (sodat die gebruiker met die kwaadwillige toepassing sal interakteer en dink hy gebruik die regte een).

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Onveilige datastoor

**Interne stoorplek**

In Android is lêers wat in interne stoorplek gestoor word bedoel om uitsluitlik deur die app wat dit geskep het toeganklik te wees. Hierdie sekuriteitsmaatreël word deur die Android-bedryfstelsel afgedwing en is oor die algemeen voldoende vir die sekuriteitsbehoeftes van die meeste toepassings. Ontwikkelaars gebruik egter soms modi soos `MODE_WORLD_READABLE` en `MODE_WORLD_WRITABLE` om lêers tussen verskillende toepassings te deel. Hierdie modi beperk egter nie toegang tot hierdie lêers deur ander toepassings nie, insluitend moontlik kwaadwillige eenhede.

1. **Static Analysis:**
- **Verseker** dat die gebruik van `MODE_WORLD_READABLE` en `MODE_WORLD_WRITABLE` noukeurig ondersoek word. Hierdie modi **kan lêers potensieel blootstel** aan onbedoelde of ongemagtigde toegang.
2. **Dynamic Analysis:**
- **Verifieer** die **permitte** wat op lêers geskep deur die app gestel is. Spesifiek, **kyk** of enige lêers vir wêreldwye lees- of skryfregte gestel is. Dit kan 'n beduidende sekuriteitsrisiko wees, aangesien dit enige toepassing op die toestel, ongeag herkoms of doel, toelaat om hierdie lêers te lees of te wysig.

**Eksterne stoorplek**

Wanneer jy met lêers op eksterne stoorplek werk, soos SD-kaarte, moet sekere voorsorgmaatreëls getref word:

1. **Toeganklikheid**:
- Lêers op eksterne stoorplek is wêreldwyd lees- en skryfbaar. Dit beteken enige toepassing of gebruiker kan toegang kry.
2. **Sekuriteitskwessies**:
- Gegewe die maklike toegang word dit aanbeveel om **nie sensitiewe inligting** op eksterne stoorplek te berg nie.
- Eksterne stoorplek kan verwyder of deur enige toepassing geraak word, wat dit minder veilig maak.
3. **Hantering van data van eksterne stoorplek**:
- Voer altyd **invoer-validasie** uit op data wat van eksterne stoorplek verkry is. Dit is noodsaaklik aangesien die data van 'n onbetroubare bron kom.
- Dit word sterk ontraden om uitvoerbare lêers of klaslêers op eksterne stoorplek te stoor vir dinamiese laai.
- As jou toepassing uitvoerbare lêers vanaf eksterne stoorplek moet laai, maak seker dat hierdie lêers **gesign en kriptografies geverifieer** is voordat hulle dinamies gelaai word. Hierdie stap is van kardinale belang om die sekuriteitsintegriteit van jou toepassing te behou.

Eksterne stoorplek kan in `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard` bereik word

> [!TIP]
> Beginnend met Android 4.4 (**API 17**), het die SD-kaart 'n gidsstruktuur wat die toegang van 'n app beperk tot die gids wat spesifiek vir daardie app is. Dit verhoed dat 'n kwaadwillige toepassing lees- of skryf toegang tot 'n ander app se lêers kry.

**Sensitiewe data gestoor in duidelike teks**

- **Shared preferences**: Android laat elke toepassing toe om maklik xml-lêers te stoor in die pad `/data/data/<packagename>/shared_prefs/` en soms is dit moontlik om sensitiewe inligting in duidelike teks in daardie gids te vind.
- **Databases**: Android laat elke toepassing toe om maklik sqlite-databasisse te stoor in die pad `/data/data/<packagename>/databases/` en soms is dit moontlik om sensitiewe inligting in duidelike teks in daardie gids te vind.

### Gebroke TLS

**Accept All Certificates**

Om een of ander rede aanvaar ontwikkelaars soms alle sertifikate selfs al stem byvoorbeeld die hostname nie ooreen nie met reëls kode soos die volgende:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
'n Goeie manier om dit te toets is om te probeer die verkeer vas te vang met 'n proxy soos Burp sonder om die Burp CA in die toestel te autoriseer. Ook kan jy met Burp 'n sertifikaat vir 'n ander hostname genereer en dit gebruik.

### Gebroke Kriptografie

**Swak sleutelbestuursprosesse**

Sommige ontwikkelaars stoor sensitiewe data in plaaslike stoorplekke en enkodeer dit met 'n sleutel wat in die kode hardkodering/patroneerbaar is. Dit behoort nie gedoen te word nie aangesien omgekeerde ingenieurswese 'n aanvaller kan toelaat om die vertroulike inligting te onttrek.

**Gebruik van onveilige en/of verouderde algoritmes**

Ontwikkelaars behoort nie **verouderde algoritmes** te gebruik om magtiging **checks**, **store** of **send** data uit te voer nie. Sommige van hierdie algoritmes is: RC4, MD4, MD5, SHA1... As **hashes** byvoorbeeld gebruik word om wagwoorde te stoor, moet hashes wat brute-force **resistent** is met salt gebruik word.

### Ander kontroles

- Dit word aanbeveel om die **APK** te obfuskeer om die reverse engineer se werk vir aanvallers moeiliker te maak.
- As die app sensitief is (soos bank-apps), behoort dit sy **eie kontroles om te kyk of die mobiele toestel geroot is** uit te voer en dienooreenkomstig te reageer.
- As die app sensitief is (soos bank-apps), behoort dit te kontroleer of 'n **emulator** gebruik word.
- As die app sensitief is (soos bank-apps), behoort dit **sy eie integriteit te kontroleer voordat dit uitgevoer word** om te sien of dit gewysig is.
- Gebruik [**APKiD**](https://github.com/rednaga/APKiD) om te kyk watter compiler/packer/obfuscator gebruik is om die APK te bou

### React Native-toepassing

Lees die volgende bladsy om te leer hoe om maklik toegang te kry tot die javascript-kode van React-toepassings:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Lees die volgende bladsy om te leer hoe om maklik toegang te kry tot C#-kode van 'n xamarin toepassing:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

Volgens hierdie [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) is superpacked 'n Meta-algoritme wat die inhoud van 'n toepassing saamdruk in 'n enkele lêer. Die blog bespreek die moontlikheid om 'n app te skep wat hierdie tipe apps dekomprimeer... en 'n vinniger manier wat behels om die toepassing te **execute the application and gather the decompressed files from the filesystem.**

### Geoutomatiseerde Statiese Kode-analise

Die hulpmiddel [**mariana-trench**](https://github.com/facebook/mariana-trench) is in staat om **vulnerabilities** te vind deur die **code** van die toepassing te **scan**. Hierdie hulpmiddel bevat 'n reeks **known sources** (wat aan die hulpmiddel aandui die **places** waar die **input** deur die gebruiker beheer word), **sinks** (wat aan die hulpmiddel aandui **dangerous** **places** waar kwaadwillige gebruikersinvoer skade kan veroorsaak) en **rules**. Hierdie reëls dui die **combination** van **sources-sinks** aan wat 'n kwetsbaarheid aandui.

Met hierdie kennis **sal mariana-trench die kode hersien en moontlike vulnerabilities daarin vind**.

### Secrets leaked

'n Toepassing kan geheime (API keys, wagwoorde, versteekte urls, subdomeine...) daarin bevat wat jy dalk kan ontdek. Jy kan 'n hulpmiddel soos [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks) gebruik.

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Ander interessante funksies

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Lees dit om te leer **how to reverse native functions**](reversing-native-libraries.md)

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dinamiese Analise

> Eerstens het jy 'n omgewing nodig waar jy die toepassing en al die omgewing (Burp CA cert, Drozer and Frida mainly) kan installeer. Daarom word 'n gerootte toestel (geëmuleer of nie) sterk aanbeveel.

### Aanlyn Dinamiese Analise

Jy kan 'n **gratis rekening** skep by: [https://appetize.io/](https://appetize.io). Hierdie platform laat jou toe om APKs te **upload** en **execute**, so dit is nuttig om te sien hoe 'n apk optree.

Jy kan selfs **die logs van jou toepassing in die web sien** en via **adb** koppel.

![](<../../images/image (831).png>)

Dankie aan die ADB-verbinding kan jy **Drozer** en **Frida** binne die emulator gebruik.

### Lokale Dinamiese Analise

#### Gebruik van 'n emulator

- [**Android Studio**](https://developer.android.com/studio) (Jy kan **x86** en **arm** toestelle skep, en volgens [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** weergawes **support ARM libraries** sonder om 'n stadiger arm-emulator te benodig).
- Leer om dit op te stel op hierdie bladsy:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, jy moet 'n rekening skep. _Dit word aanbeveel om die weergawe **WITH**_ _**VirtualBox** te **download** om potensiële foute te vermy._)
- [**Nox**](https://es.bignox.com) (Gratis, maar dit ondersteun nie Frida of Drozer nie).

> [!TIP]
> Wanneer jy 'n nuwe emulator op enige platform skep, onthou dat hoe groter die skerm is, hoe stadiger sal die emulator loop. Kies dus klein skerms indien moontlik.

Om **google services** (soos AppStore) in Genymotion te installeer, moet jy op die rooi gemerkte knoppie in die volgende beeld klik:

![](<../../images/image (277).png>)

Neem ook kennis dat in die **konfigurasie van die Android VM in Genymotion** jy **Bridge Network mode** kan kies (dit sal nuttig wees as jy vanaf 'n ander VM na die Android VM sal koppel met die hulpmiddels).

#### Gebruik 'n fisiese toestel

Jy moet die **debugging** opsies aktiveer en dit sal goed wees as jy dit kan **root**:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Sodra jy die toepassing geïnstalleer het, is die eerste ding wat jy moet doen om dit te probeer en ondersoek wat dit doen, hoe dit werk en gemaklik te raak daarmee.\
> Ek sal voorstel om hierdie aanvanklike dinamiese analise uit te voer deur MobSF dynamic analysis + pidcat te gebruik, sodat ons kan **leer hoe die toepassing werk** terwyl MobSF baie **interessante** **data** vasvang wat jy later kan hersien.

Magisk/Zygisk vinnige notas (aanbeveel op Pixel-toestelle)
- Patch boot.img met die Magisk-app en flash via fastboot om systemless root te kry
- Aktiveer Zygisk + DenyList vir root-verborge; oorweeg LSPosed/Shamiko wanneer sterker verberging benodig word
- Hou die oorspronklike boot.img om van OTA-opdaterings te herstel; her-patch na elke OTA
- Vir skermspieëling, gebruik scrcpy op die host

### Onbedoelde Data Lekkasie

**Logging**

Ontwikkelaars moet versigtig wees om **debugging-inligting** nie publiek bloot te stel nie, aangesien dit tot sensitiewe data leaks kan lei. Die hulpmiddels [**pidcat**](https://github.com/JakeWharton/pidcat) en `adb logcat` word aanbeveel om toepassingslogs te monitor om sensitiewe inligting te identifiseer en te beskerm. **Pidcat** word verkies vir sy gebruiksgemak en leesbaarheid.

> [!WARNING]
> Let wel dat vanaf **later newer than Android 4.0**, **applications are only able to access their own logs**. So applications cannot access other apps logs.\
> Dit word tog aanbeveel om **nie sensitiewe inligting te log nie**.

**Kopieer/Plak-klembord**

Android se **clipboard-based** raamwerk maak kopieer-plak funksionaliteit in apps moontlik, maar hou 'n risiko in omdat **ander applications** toegang tot die klembord kan hê en moontlik sensitiewe data kan blootstel. Dit is noodsaaklik om kopieer/plak-funksies vir sensitiewe gedeeltes van 'n toepassing, soos kredietkaartbesonderhede, uit te skakel om data leaks te voorkom.

**Crash Logs**

As 'n toepassing **crash** en **logs stoor**, kan hierdie logs aanvallers help, veral wanneer die toepassing nie gerusverseer kan word nie. Om hierdie risiko te verminder, vermy logboekhouding by crashes, en as logs oor die netwerk gestuur moet word, sorg dat hulle via 'n SSL-kanaal gestuur word vir sekuriteit.

As pentester, **probeer hierdie logs te besoek**.

**Analytics Data Sent To 3rd Parties**

Toepassings integreer dikwels dienste soos Google Adsense, wat onbedoeld sensitiewe data kan leak as gevolg van verkeerde implementering deur ontwikkelaars. Om potensiële data leaks te identifiseer, is dit raadsaam om die toepassing se verkeer te onderskep en te kyk vir enige sensitiewe inligting wat aan derdepartye gestuur word.

### SQLite DBs

Die meeste toepassings gebruik **internal SQLite databases** om inligting te stoor. Tydens die pentest kyk na die **databases** wat geskep is, die name van **tables** en **columns** en al die **data** wat gestoor is omdat jy moontlik **sensitiewe inligting** kan vind (wat 'n kwetsbaarheid sou wees).\
Databases behoort te wees in `/data/data/the.package.name/databases` soos `/data/data/com.mwr.example.sieve/databases`

As die databasis vertroulike inligting stoor en **encrypted** is maar jy die **password** in die toepassing kan **find**, is dit steeds 'n **vulnerability**.

Enumereer die tabelle met `.tables` en enumereer die kolomme van die tabelle met `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** stel jou in staat om die **rol van 'n Android app aan te neem** en met ander apps te interaksie. Dit kan **alles doen wat 'n geïnstalleerde toepassing kan doen**, soos die gebruik van Android se Inter-Process Communication (IPC) meganisme en interaksie met die onderliggende bedryfstelsel. .\
Drozer is 'n nuttige hulpmiddel om **exported activities, exported services and Content Providers** te **exploit** soos jy in die volgende afdelings sal leer.

### Eksploiteer exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Onthou ook dat die kode van 'n activity begin in die **`onCreate`** metode.

**Authorisation bypass**

Wanneer 'n Activity exported is, kan jy sy skerm van 'n eksterne app aanroep. Dus, as 'n activity met **sensitiewe inligting** **exported** is, kan jy die **authentication** meganismes **bypass** om dit te bereik.

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

Jy kan ook 'n exported activity vanaf adb begin:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> Let wel dat 'n authorisation bypass nie altyd 'n kwetsbaarheid is nie; dit hang af van hoe die bypass werk en watter inligting blootgestel word.

**Sensitiewe inligting lekkasie**

**Activities can also return results**. If you manage to find an exported and unprotected activity calling the **`setResult`** method and **returning sensitive information**, daar is 'n sensitiewe inligting lekkasie.

#### Tapjacking

If Tapjacking isn't prevented, jy kan die exported activity misbruik om die **gebruiker onvoorsiene aksies te laat uitvoer**. Vir meer inligting oor [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers word hoofsaaklik gebruik om **data te deel**. As 'n app beskikbare content providers het, mag jy in staat wees om **sensitiewe** data daaruit te **haal**. Dit is ook belangrik om moontlike **SQL injections** en **Path Traversals** te toets aangesien hulle kwesbaar kan wees.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Onthou dat die aksies van 'n Service begin in die metode `onStartCommand`.

'n Service is basies iets wat **data kan ontvang**, dit **verwerk** en (of nie) 'n antwoord **terugstuur**. As 'n toepassing sekere services exporteer, behoort jy die **code** te **kontroleer** om te verstaan wat dit doen en dit **dynamies** te **toets** om vertroulike inligting uit te haal, authentication measures te bypass...\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Onthou dat die aksies van 'n Broadcast Receiver begin in die metode `onReceive`.

'n Broadcast receiver sal wag vir 'n tipe boodskap. Afhangend van hoe die receiver die boodskap hanteer, kan dit kwesbaar wees.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Jy kan na deep links soek manuueel, met instrumente soos MobSF of skripte soos [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Jy kan 'n verklaarde **scheme** **open** met **adb** of 'n **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Neem kennis dat jy die **pakketnaam kan weglaat** en die mobiele toestel sal outomaties die app oproep wat daardie skakel moet oopmaak._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Code uitgevoer**

Om die **kode wat in die App uitgevoer sal word** te vind, gaan na die activity wat deur die deeplink aangeroep word en soek die funksie **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Sensitiewe inligting**

Elke keer as jy 'n deep link vind, kontroleer dat i**t nie sensitiewe data (like passwords) via URL parameters ontvang nie**, omdat enige ander toepassing die deep link kan **impersonate en daardie data steel!**

**Parameters in path**

Jy **moet ook kontroleer of enige deep link 'n parameter binne die path gebruik** van die URL soos: `https://api.example.com/v1/users/{username}`, in daardie geval kan jy 'n path traversal afdwing deur iets soos: `example://app/users?username=../../unwanted-endpoint%3fparam=value` toe te roep.\
Let daarop dat as jy die korrekte endpoints binne die toepassing vind, jy dalk 'n **Open Redirect** kan veroorsaak (as 'n deel van die path as domeinnaam gebruik word), **account takeover** (as jy gebruikersbesonderhede kan wysig sonder 'n CSRF token en die vuln endpoint die korrekte metode gebruik) en enige ander vuln. More [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Transport Layer Inspection and Verification Failures

- **Sertifikate word nie altyd behoorlik geïnspekteer nie** deur Android-toepassings. Dit is algemeen dat hierdie toepassings waarskuwings ignoreer en self-ondertekende sertifikate aanvaar of, in sommige gevalle, terugval na die gebruik van HTTP-verbindinge.
- **Onderhandelings tydens die SSL/TLS-handshake is soms swak**, wat onveilige cipher suites gebruik. Hierdie kwesbaarheid maak die verbinding vatbaar vir man-in-the-middle (MITM) aanvalle, wat aanvallers toelaat om die data te ontsleutel.
- **Lekking van privaat inligting** is 'n risiko wanneer toepassings eers verifieer met veilige kanale en dan oor nie-veilige kanale kommunikeer vir ander transaksies. Hierdie benadering beskerm nie sensitiewe data, soos sessie-koekies of gebruikerbesonderhede, teen onderskep deur kwaadwillige entiteite nie.

#### Certificate Verification

Ons sal fokus op **sertifikaatverifikasie**. Die integriteit van die bediener se sertifikaat moet geverifieer word om veiligheid te verbeter. Dit is noodsaaklik omdat onveilige TLS-konfigurasies en die oordrag van sensitiewe data oor nie-enkripteerde kanale beduidende risiko's kan meebring. For detailed steps on verifying server certificates and addressing vulnerabilities, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) provides comprehensive guidance.

#### SSL Pinning

SSL Pinning is 'n sekuriteitsmaatreël waar die toepassing die bediener se sertifikaat verifieer teen 'n bekende kopie wat binne die toepassing self gestoor is. Hierdie metode is essensieel om MITM-aanvalle te voorkom. Die implementering van SSL Pinning word sterk aanbeveel vir toepassings wat sensitiewe inligting hanteer.

#### Traffic Inspection

Om HTTP-verkeer te inspekteer, is dit nodig om die **proxy tool's certificate** te installeer (e.g., Burp). Sonder om hierdie sertifikaat te installeer, mag enkripsiesed verkeer nie deur die proxy sigbaar wees nie. Vir 'n gids oor die installering van 'n pasgemaakte CA-sertifikaat, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Toepassings wat mik op **API Level 24 and above** vereis wysigings aan die Network Security Config om die proxy se CA-sertifikaat te aanvaar. Hierdie stap is krities vir die inspeksie van enkripsiesed verkeer. Vir instruksies oor die wysiging van die Network Security Config, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

If **Flutter** is being used you need to to follow the instructions in [**this page**](flutter.md). This is because, just adding the certificate into the store won't work as Flutter has its own list of valid CAs.

#### Static detection of SSL/TLS pinning

Voordat jy runtime-bypasses probeer, karteer vinnig waar pinning in die APK afgedwing word. Statiese opsporing help jou om hooks/patches te beplan en op die regte kodebane te fokus.

Tool: SSLPinDetect
- Open-source static-analysis utility that decompiles the APK to Smali (via apktool) and scans for curated regex patterns of SSL/TLS pinning implementations.
- Rapporteer die presiese file path, lynnommer, en 'n kodefragment vir elke match.
- Dek algemene frameworks en custom code paths: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

Install
- Vereistes: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Gebruik
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Voorbeeld patroonreëls (JSON)
Gebruik of brei signatures uit om proprietary/custom pinning styles te detecteer. Jy kan jou eie JSON laai en op skaal scan.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes and tips
- Vinnige skandering van groot apps via multi-threading en memory-mapped I/O; vooraf-gekompileerde regex verminder overhead/vals positiewe.
- Patroonversameling: https://github.com/aancw/smali-sslpin-patterns
- Tipiese opsporingsdoelwitte om daarna te triageer:
- OkHttp: CertificatePinner gebruik, setCertificatePinner, okhttp3/okhttp pakketverwysings
- Aangepaste TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted oorskrywings
- Aangepaste SSL-kontekste: SSLContext.getInstance + SSLContext.init met aangepaste managers
- Deklaratiewe pins in res/xml network security config en manifest verwysings
- Gebruik die gevonde lokasies om Frida hooks, statiese pleisters, of konfigurasie-oorsigte te beplan voor dinamiese toetsing.



#### Omseiling van SSL Pinning

Wanneer SSL Pinning geïmplementeer is, word dit nodig om dit te omseil om HTTPS-verkeer te inspekteer. Verskeie metodes is beskikbaar vir hierdie doel:

- Outomaties **wysig** die **apk** om SSLPinning te **omseil** met [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Die grootste voordeel van hierdie opsie is dat jy nie root nodig het om die SSL Pinning te omseil nie, maar jy sal die toepassing moet verwyder en die nuwe een herinstalleer, en dit werk nie altyd nie.
- Jy kan **Frida** (hieronder bespreek) gebruik om hierdie beskerming te omseil. Hier is 'n gids om Burp+Frida+Genymotion te gebruik: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Jy kan ook probeer om **outomaties SSL Pinning te omseil** met [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Jy kan ook probeer om **outomaties SSL Pinning te omseil** deur **MobSF dynamic analysis** te gebruik (hieronder verduidelik)
- As jy steeds dink daar is verkeer wat jy nie vasvang nie, kan jy probeer om die verkeer na Burp deur te stuur met iptables. Lees hierdie blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Soek na algemene web kwesbaarhede

Dit is belangrik om ook binne die toepassing te soek na algemene web-kwesbaarhede. Gedetaileerde inligting oor die identifisering en mitigering van hierdie kwesbaarhede val buite die bestek van hierdie samevatting, maar word elders uitvoerig behandel.

### Frida

[Frida](https://www.frida.re) is 'n dinamiese instrumenteringsgereedskap vir ontwikkelaars, reverse-engineers, en sekuriteitsnavorsers.\
**Jy kan toegang tot 'n lopende toepassing kry en metodes tydens uitvoering hook om die gedrag te verander, waardes te verander, waardes uit te trek, ander kode uit te voer...**\
As jy Android-toepassings wil pentest, moet jy weet hoe om Frida te gebruik.

- Leer hoe om Frida te gebruik: [**Frida tutorial**](frida-tutorial/index.html)
- Sommige "GUI" vir aksies met Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is uitstekend om die gebruik van Frida te outomatiseer: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Jy kan sommige Awesome Frida-skripte hier vind: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Probeer om anti-debugging / anti-frida meganismes te omseil deur Frida soos aangedui in [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) te laai (hulpmiddel [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Geheue - Fridump**

Kyk of die toepassing sensitiewe inligting in die geheue stoor wat dit nie behoort te stoor nie, soos wagwoorde of mnemonics.

Deur [**Fridump3**](https://github.com/rootbsd/fridump3) te gebruik kan jy die geheue van die app dump met:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Dit sal die memory in die ./dump-gids dump, en daar kan jy met iets soos grep soek:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Sensitiewe data in Keystore**

In Android is die Keystore die beste plek om sensitiewe data te stoor, maar met genoeg bevoegdhede is dit steeds moontlik om daartoe toegang te kry. Aangesien toepassings geneig is om hier sensitiewe data in clear text te stoor, behoort pentests daarna te kyk as root user, aangesien iemand met fisiese toegang tot die toestel hierdie data moontlik kan steel.

Selfs as 'n app data in die Keystore stoor, behoort die data versleuteld te wees.

Om toegang tot die data binne die Keystore te kry, kan jy hierdie Frida script gebruik: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Deur die volgende Frida-skrip te gebruik, kan dit moontlik wees om die **bypass fingerprint authentication** uit te voer wat Android-toepassings mag gebruik om sekere **gevoelige gebiede te beskerm**:
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Achtergrondbeelde**

Wanneer jy 'n toepassing op die agtergrond plaas, stoor Android 'n **snapshot van die toepassing** sodat wanneer dit na die voorgrond herstel word, dit eers die beeld laai voordat die app begin laai, sodat dit lyk asof die app vinniger gelaai is.

As hierdie snapshot egter **sensitiewe inligting** bevat, kan iemand met toegang tot die snapshot daardie inligting **steel** (let wel dat jy root nodig het om daartoe toegang te kry).

Die snapshots word gewoonlik gestoor by: **`/data/system_ce/0/snapshots`**

Android bied 'n manier om **die vaslegging van skermskote te voorkom deur die FLAG_SECURE layout-parameter te stel**. Deur hierdie flag te gebruik, word die vensterinhoud as veilig beskou, wat verhoed dat dit in skermskote verskyn of op nie-veilige vertonings bekyk kan word.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android-toepassingsontleder**

This tool could help you managing different tools during the dynamic analysis: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Ontwikkelaars skep gereeld proxy-komponente soos activities, services, en broadcast receivers wat hierdie Intents hanteer en dit deurgee aan metodes soos `startActivity(...)` of `sendBroadcast(...)`, wat riskant kan wees.

Die gevaar lê daarin om aanvallers toe te laat nie-eksporteerde app-komponente of sensitiewe content providers te aktiveer/benader deur hierdie Intents verkeerd te lei. 'n Bekende voorbeeld is die `WebView`-komponent wat URLs na `Intent`-objekte omskakel via `Intent.parseUri(...)` en dit dan uitvoer, wat moontlik tot kwaadwillige Intent injections kan lei.

### Belangrike punte

- **Intent Injection** is soortgelyk aan die web se Open Redirect-kwessie.
- Eksploite behels die deurgee van `Intent`-objekte as extras, wat omgerig kan word om onveilige operasies uit te voer.
- Dit kan nie-eksporteerde komponente en content providers aan aanvallers blootstel.
- `WebView` se URL-naar-`Intent` omskakeling kan onbeoogde aksies vergemaklik.

### Android Client-Side Injections and others

Jy ken waarskynlik hierdie tipe kwesbaarhede van die Web af. Jy moet besonder versigtig wees met hierdie kwesbaarhede in 'n Android-toepassing:

- **SQL Injection:** Wanneer jy dinamiese navrae of Content-Providers hanteer, sorg dat jy geparametriseerde navrae gebruik.
- **JavaScript Injection (XSS):** Verify that JavaScript and Plugin support is disabled for any WebViews (disabled by default). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews should have access to the file system disabled (enabled by default) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: In verskeie gevalle, wanneer die android toepassing die sessie beëindig, word die cookie nie herroep nie of dit kan selfs na skyf gestoor word
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Outomatiese Analise

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Statiese analise**

![](<../../images/image (866).png>)

**Kwesbaarheidsevaluering van die toepassing** met 'n netjiese web-gebaseerde frontend. Jy kan ook dinamiese analise uitvoer (maar jy moet die omgewing voorberei).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Assisted Dynamic analysis with MobSF

**MobSF** can also be very helpful for **dynamic analysis** in **Android**, but in that case you will need to install MobSF and **genymotion** in your host (a VM or Docker won't work). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
The **MobSF dynamic analyser** can:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). All of this is done automatically except for the screenshots, you need to press when you want a screenshot or you need to press "**Exported Activity Tester**" to obtain screenshots of all the exported activities.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: Dit sal al die loaded classes uitdruk
- **Capture Strings**: Dit sal alle capture strings druk terwyl jy die toepassing gebruik (baie noisy)
- **Capture String Comparisons**: Kan baie nuttig wees. Dit sal **show the 2 strings being compared** en of die resultaat True of False was.
- **Enumerate Class Methods**: Sit die klasnaam (bv. "java.io.File") en dit sal al die methods van die klas druk.
- **Search Class Pattern**: Search classes by pattern
- **Trace Class Methods**: **Trace** 'n **whole class** (sien insette en uitsette van alle methods van die klas). Onthou dat standaard MobSF verskeie interessante Android Api methods trace.

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf also brings you a shell with some **adb** commands, **MobSF commands**, and common **shell** **commands** at the bottom of the dynamic analysis page. Some interesting commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP-gereedskap**

Wanneer HTTP-verkeer vasgelê word kan jy ’n lelike weergawe van die vasgelêde verkeer onder "**HTTP(S) Traffic**" knoppie sien of ’n netter weergawe onder die groen knoppie "**Start HTTPTools**". Vanaf die tweede opsie kan jy die **captured requests** na **proxies** soos Burp of Owasp ZAP stuur.\
Om dit te doen, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> druk "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Sodra jy die dinamiese ontleding met MobSF voltooi het, kan jy op "**Start Web API Fuzzer**" druk om **fuzz http requests** en na kwesbaarhede te soek.

> [!TIP]
> Na ’n dinamiese ontleding met MobSF kan die proxy-instellings verkeerd gekonfigureer raak en sal jy dit nie via die GUI kan regmaak nie. Jy kan die proxy-instellings regmaak deur:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Begeleide dinamiese ontleding met Inspeckage

Jy kan die hulpmiddel kry vanaf [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Hierdie hulpmiddel gebruik sekere **Hooks** om jou te laat weet **wat in die toepassing gebeur** terwyl jy ’n **dinamiese ontleding** uitvoer.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Dit is ’n **geweldige hulpmiddel om statiese ontleding met ’n GUI uit te voer**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Hierdie hulpmiddel is ontwerp om na verskeie **security related Android application vulnerabilities** te soek, hetsy in **source code** of **packaged APKs**. Die instrument is ook **in staat om 'n "Proof-of-Concept" deployable APK te skep** en **ADB commands**, om sommige van die gevonde kwesbaarhede te eksploiteer (Exposed activities, intents, tapjacking...). Soos met Drozer, is daar geen behoefte om die toetsapparaat te root nie.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Wys alle uitgehaalde lêers vir maklike verwysing
- Dekompileer APK-lêers outomaties na Java- en Smali-formaat
- Ontleed AndroidManifest.xml vir algemene kwesbaarhede en gedrag
- Statiese bronkode-ontleding vir algemene kwesbaarhede en gedrag
- Toestelinligting
- En meer
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER is 'n command-line toepassing wat in Windows, MacOS X en Linux gebruik kan word, wat _.apk_ lêers ontleed op soek na kwesbaarhede. Dit doen dit deur APKs te dekomprimeer en 'n reeks reëls toe te pas om daardie kwesbaarhede op te spoor.

Alle reëls is gekonsentreer in 'n `rules.json` lêer, en elke maatskappy of tester kan hul eie reëls skep om te analiseer wat hulle nodig het.

Laai die nuutste binaries af by die [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn is 'n **kruisplatform** gereedskap wat ontwikkelaars, bugbounty hunters en etiese hackers help om [statiese kode-analise](https://en.wikipedia.org/wiki/Static_program_analysis) op mobiele toepassings uit te voer.

Die idee is dat jy jou mobiele toepassing-lêer ('.apk' of '.ipa' lêer) op die StaCoAn-toepassing sleep en dit sal 'n visuele en draagbare verslag vir jou genereer. Jy kan die instellings en woordlyste aanpas om 'n pasgemaakte ervaring te kry.

Laai die [nuutste vrystelling](https://github.com/vincentcox/StaCoAn/releases) af:
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework is 'n stelsel vir Android-kwesbaarheidsanalise wat ontwikkelaars of hackers help om potensiële sekuriteitskwesbaarhede in Android-toepassings te vind.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** is 'n hulpmiddel waarvan die hoofdoel is om die gebruiker op te spoor en te waarsku oor potensiële kwaadwillige gedrag wat deur 'n Android-app ontwikkel is.

Die opsporing word gedoen deur die **static analysis** van die toepassing se Dalvik bytecode, wat voorgestel word as **Smali**, met die [`androguard`](https://github.com/androguard/androguard) biblioteek.

Hierdie hulpmiddel soek na **gewone gedrag van "slegte" toepassings** soos: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. Dit is 'n hulpmiddel wat algemeen gebruikte mobile application reverse engineering en analysis tools saamvoeg om te help met die toetsing van mobiele toepassings teen OWASP mobile security threats. Die doel is om hierdie taak makliker en meer gebruikersvriendelik te maak vir mobile application developers en security professionals.

It is able to:

- Ekstraheer Java en Smali code met verskeie tools
- Analiseer APK's met: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Ekstraheer privaat inligting uit die APK met regexps.
- Analiseer die Manifest.
- Analiseer gevonde domeine met: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) en [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Nuttig om malware te detecteer: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Neem kennis dat, afhangend van die diens en konfigurasie wat jy gebruik om die code te obfuskeer, geheime wel of nie geobfuskeer kan wees nie.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is 'n open source command-line hulpmiddel wat Java code verklein, optimaliseer en obfuskeer. Dit kan bytecode optimaliseer en ongebruikte instruksies opspoor en verwyder. ProGuard is gratis sagteware en word versprei onder die GNU General Public License, version 2.

ProGuard word saam met die Android SDK versprei en loop wanneer die toepassing in release mode gebou word.

### [DexGuard](https://www.guardsquare.com/dexguard)

Vind 'n stap-vir-stap gids om die apk te deobfusseer by [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(Volgens daardie gids) Die laaste keer wat ons nagegaan het, was die Dexguard operasionele wyse:

- laai 'n resource as 'n InputStream;
- gee die resultaat aan 'n klas wat van FilterInputStream erf om dit te ontsleutel;
- doen 'n bietjie nuttelose obfuskering om 'n paar minute van 'n reverser se tyd te mors;
- gee die ontsleutelde resultaat aan 'n ZipInputStream om 'n DEX-lêer te kry;
- laastens laai die resulterende DEX as 'n Resource met die `loadDex` metode.

### [DeGuard](http://apk-deguard.com)

**DeGuard keer die proses van obfuskering wat deur Android obfuscation tools uitgevoer word om. Dit maak talle security analyses moontlik, insluitend code inspection en library-identifikasie.**

Jy kan 'n geobfuskeerde APK na hul platform oplaai.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

Dit is 'n LLM tool om potensiële security vulnerabilities in android apps te vind en android app code te deobfusseer. Gebruik Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

Dit is 'n generic android deobfuscator. Simplify voer 'n app virtually uit om sy gedrag te verstaan en probeer dan die code optimaliseer sodat dit identies optree maar makliker vir 'n mens is om te verstaan. Elke optimaliseringstipe is eenvoudig en generies, so dit maak nie saak watter spesifieke tipe obfuscation gebruik word nie.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD gee jou inligting oor hoe 'n APK gemaak is. Dit identifiseer baie compilers, packers, obfuscators, en ander vreemde goed. Dit is [_PEiD_](https://www.aldeid.com/wiki/PEiD) vir Android.

### Manual

[Lees hierdie handleiding om 'n paar truuks te leer oor **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b is 'n Android security virtual machine gebaseer op ubuntu-mate wat 'n versameling van die nuutste framework, tutorials en labs van verskillende security geeks en navorsers bevat vir reverse engineering en malware analysis.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Dit is 'n uitstekende lys van hulpbronne
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)

## Yet to try

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
