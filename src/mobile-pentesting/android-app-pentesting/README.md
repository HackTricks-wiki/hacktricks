# 안드로이드 애플리케이션 펜테스팅

{{#include ../../banners/hacktricks-training.md}}

## 안드로이드 애플리케이션 기초

**안드로이드 보안과 안드로이드 애플리케이션에서 가장 위험한 구성 요소와 관련된 가장 중요한 부분**에 대해 알기 위해 이 페이지를 읽는 것을 강력히 권장합니다:

{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (안드로이드 디버그 브리지)

이것은 안드로이드 장치(에뮬레이트된 또는 물리적)에 연결하는 데 필요한 주요 도구입니다.\
**ADB**는 컴퓨터에서 **USB** 또는 **네트워크**를 통해 장치를 제어할 수 있게 해줍니다. 이 유틸리티는 **파일 복사**, **앱 설치 및 제거**, **셸 명령 실행**, **데이터 백업**, **로그 읽기** 등 여러 기능을 지원합니다.

ADB 사용 방법을 배우기 위해 다음 [**ADB 명령어 목록**](adb-commands.md)을 확인하세요.

## Smali

때때로 **숨겨진 정보**(아마도 잘 난독화된 비밀번호나 플래그)에 접근하기 위해 **애플리케이션 코드를 수정하는 것**이 흥미로울 수 있습니다. 그런 다음, apk를 디컴파일하고 코드를 수정한 후 다시 컴파일하는 것이 흥미로울 수 있습니다.\
[**이 튜토리얼에서** APK를 디컴파일하고 Smali 코드를 수정한 후 새로운 기능으로 APK를 다시 컴파일하는 방법을 **배울 수 있습니다**](smali-changes.md). 이는 **동적 분석 중 여러 테스트의 대안으로 매우 유용할 수 있습니다**. 그러므로 **이 가능성을 항상 염두에 두세요**.

## 기타 흥미로운 팁

- [Play Store에서 위치 스푸핑하기](spoofing-your-location-in-play-store.md)
- **APK 다운로드**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- 장치에서 APK 추출:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- 모든 분할 및 기본 APK를 [APKEditor](https://github.com/REAndroid/APKEditor)로 병합합니다:
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## 정적 분석

우선, APK를 분석하기 위해서는 **디컴파일러를 사용하여 Java 코드를 살펴봐야 합니다**.\
자세한 내용은 [**다양한 사용 가능한 디컴파일러에 대한 정보를 읽어보세요**](apk-decompilers.md).

### 흥미로운 정보 찾기

APK의 **문자열**을 살펴보면 **비밀번호**, **URL** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **API** 키, **암호화**, **블루투스 UUID**, **토큰** 및 흥미로운 모든 것을 검색할 수 있습니다... 코드 실행 **백도어** 또는 인증 백도어(앱에 하드코딩된 관리자 자격 증명)도 찾아보세요.

**Firebase**

**Firebase URL**에 특별한 주의를 기울이고 잘못 구성되어 있는지 확인하세요. [Firebase가 무엇인지 및 이를 악용하는 방법에 대한 자세한 정보는 여기에서 확인하세요.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### 애플리케이션에 대한 기본 이해 - Manifest.xml, strings.xml

**애플리케이션의 \_Manifest.xml**_\*\* 및 \*\*_**strings.xml**\_\*\* 파일의 검토는 잠재적인 보안 취약점을 드러낼 수 있습니다\*\*. 이러한 파일은 디컴파일러를 사용하거나 APK 파일 확장자를 .zip으로 변경한 후 압축을 풀어 접근할 수 있습니다.

**Manifest.xml**에서 식별된 **취약점**은 다음과 같습니다:

- **디버깅 가능한 애플리케이션**: _Manifest.xml_ 파일에서 디버깅 가능(`debuggable="true"`)으로 설정된 애플리케이션은 연결을 허용하여 악용될 위험이 있습니다. 디버깅 가능한 애플리케이션을 찾고 악용하는 방법에 대한 튜토리얼을 참조하세요.
- **백업 설정**: 민감한 정보를 다루는 애플리케이션의 경우 `android:allowBackup="false"` 속성을 명시적으로 설정하여 adb를 통한 무단 데이터 백업을 방지해야 합니다. 특히 USB 디버깅이 활성화된 경우에 그렇습니다.
- **네트워크 보안**: _res/xml/_의 사용자 지정 네트워크 보안 구성(`android:networkSecurityConfig="@xml/network_security_config"`)은 인증서 핀 및 HTTP 트래픽 설정과 같은 보안 세부정보를 지정할 수 있습니다. 예를 들어 특정 도메인에 대해 HTTP 트래픽을 허용하는 것입니다.
- **내보낸 활동 및 서비스**: 매니페스트에서 내보낸 활동 및 서비스를 식별하면 악용될 수 있는 구성 요소를 강조할 수 있습니다. 동적 테스트 중 추가 분석을 통해 이러한 구성 요소를 악용하는 방법을 밝혀낼 수 있습니다.
- **콘텐츠 제공자 및 파일 제공자**: 노출된 콘텐츠 제공자는 무단 데이터 접근 또는 수정이 가능할 수 있습니다. 파일 제공자의 구성도 면밀히 검토해야 합니다.
- **브로드캐스트 수신기 및 URL 스킴**: 이러한 구성 요소는 악용될 수 있으며, 입력 취약점에 대한 URL 스킴 관리 방법에 특히 주의해야 합니다.
- **SDK 버전**: `minSdkVersion`, `targetSDKVersion`, `maxSdkVersion` 속성은 지원되는 Android 버전을 나타내며, 보안상의 이유로 구식 취약한 Android 버전을 지원하지 않는 것이 중요합니다.

**strings.xml** 파일에서 API 키, 사용자 정의 스키마 및 기타 개발자 노트와 같은 민감한 정보를 발견할 수 있으며, 이러한 리소스를 신중하게 검토할 필요성을 강조합니다.

### Tapjacking

**Tapjacking**은 **악의적인** **애플리케이션**이 실행되어 **희생 애플리케이션 위에 위치하는 공격**입니다. 희생 앱을 가시적으로 가리면, 사용자 인터페이스는 사용자가 상호작용하도록 속이도록 설계되어 있으며, 이 상호작용은 희생 앱으로 전달됩니다.\
결과적으로, 사용자는 실제로 희생 앱에서 작업을 수행하고 있다는 사실을 **모르게 됩니다**.

자세한 정보는 다음에서 확인하세요:

{{#ref}}
tapjacking.md
{{#endref}}

### 작업 하이재킹

**`launchMode`**가 **`singleTask`**로 설정되고 **`taskAffinity`**가 정의되지 않은 **활동**은 작업 하이재킹에 취약합니다. 이는 **애플리케이션**이 설치될 수 있으며, 실제 애플리케이션보다 먼저 실행되면 **실제 애플리케이션의 작업을 하이재킹할 수 있습니다**(즉, 사용자가 **악의적인 애플리케이션과 상호작용하고 있다고 생각하게 됩니다**).

자세한 정보는 다음에서 확인하세요:

{{#ref}}
android-task-hijacking.md
{{#endref}}

### 안전하지 않은 데이터 저장

**내부 저장소**

Android에서 **내부** 저장소에 **저장된** 파일은 **생성한 앱**만 **접근할 수 있도록 설계**되었습니다. 이 보안 조치는 Android 운영 체제에 의해 **강제**되며, 대부분의 애플리케이션의 보안 요구 사항에 일반적으로 적합합니다. 그러나 개발자는 때때로 `MODE_WORLD_READABLE` 및 `MODE_WORLD_WRITABLE`와 같은 모드를 사용하여 파일이 서로 다른 애플리케이션 간에 **공유**될 수 있도록 합니다. 그러나 이러한 모드는 다른 애플리케이션, 특히 잠재적으로 악의적인 애플리케이션에 의한 파일 접근을 **제한하지 않습니다**.

1. **정적 분석:**
- `MODE_WORLD_READABLE` 및 `MODE_WORLD_WRITABLE`의 사용이 **면밀히 검토**되어야 합니다. 이러한 모드는 **원치 않거나 무단 접근**으로 파일을 **노출할 수 있습니다**.
2. **동적 분석:**
- 앱에서 생성된 파일에 설정된 **권한**을 **확인**합니다. 특히, 파일이 **전 세계적으로 읽거나 쓸 수 있도록 설정되어 있는지** 확인합니다. 이는 **어떤 애플리케이션**이든 장치에 설치된 애플리케이션이 이 파일을 **읽거나 수정**할 수 있게 하여 상당한 보안 위험을 초래할 수 있습니다.

**외부 저장소**

**외부 저장소**에서 파일을 다룰 때는 몇 가지 주의 사항이 필요합니다:

1. **접근성**:
- 외부 저장소의 파일은 **전 세계적으로 읽고 쓸 수 있습니다**. 즉, 모든 애플리케이션이나 사용자가 이러한 파일에 접근할 수 있습니다.
2. **보안 문제**:
- 접근이 용이하므로 **민감한 정보를 외부 저장소에 저장하지 않는 것이 좋습니다**.
- 외부 저장소는 제거되거나 모든 애플리케이션에 의해 접근될 수 있어 보안성이 떨어집니다.
3. **외부 저장소에서 데이터 처리**:
- 외부 저장소에서 검색한 데이터에 대해 항상 **입력 검증**을 수행합니다. 이는 데이터가 신뢰할 수 없는 출처에서 온 것이기 때문에 중요합니다.
- 동적 로딩을 위해 외부 저장소에 실행 파일이나 클래스 파일을 저장하는 것은 강력히 권장되지 않습니다.
- 애플리케이션이 외부 저장소에서 실행 파일을 검색해야 하는 경우, 이러한 파일이 **서명되고 암호학적으로 검증**되었는지 확인해야 합니다. 이 단계는 애플리케이션의 보안 무결성을 유지하는 데 중요합니다.

외부 저장소는 `/storage/emulated/0`, `/sdcard`, `/mnt/sdcard`에서 **접근할 수 있습니다**.

> [!NOTE]
> Android 4.4 (**API 17**)부터 SD 카드에는 **앱에 특정한 디렉토리로의 접근을 제한하는 디렉토리 구조**가 있습니다. 이는 악의적인 애플리케이션이 다른 앱의 파일에 대한 읽기 또는 쓰기 접근을 얻는 것을 방지합니다.

**명확한 텍스트로 저장된 민감한 데이터**

- **공유 환경 설정**: Android는 각 애플리케이션이 `/data/data/<packagename>/shared_prefs/` 경로에 XML 파일을 쉽게 저장할 수 있도록 허용하며, 때때로 해당 폴더에서 명확한 텍스트로 민감한 정보를 찾을 수 있습니다.
- **데이터베이스**: Android는 각 애플리케이션이 `/data/data/<packagename>/databases/` 경로에 SQLite 데이터베이스를 쉽게 저장할 수 있도록 허용하며, 때때로 해당 폴더에서 명확한 텍스트로 민감한 정보를 찾을 수 있습니다.

### 손상된 TLS

**모든 인증서 수락**

어떤 이유로 개발자는 때때로 호스트 이름이 다음과 같은 코드 줄과 일치하지 않더라도 모든 인증서를 수락합니다:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Broken Cryptography

**Poor Key Management Processes**

일부 개발자는 민감한 데이터를 로컬 저장소에 저장하고 코드에 하드코딩되거나 예측 가능한 키로 암호화합니다. 이는 리버싱을 통해 공격자가 기밀 정보를 추출할 수 있으므로 피해야 합니다.

**Use of Insecure and/or Deprecated Algorithms**

개발자는 **권장되지 않는 알고리즘**을 사용하여 **검사**, **저장** 또는 **전송** 데이터를 수행해서는 안 됩니다. 이러한 알고리즘에는 RC4, MD4, MD5, SHA1 등이 포함됩니다. 예를 들어 **해시**를 사용하여 비밀번호를 저장하는 경우, 소금을 사용하여 해시의 무차별 대입 **저항성**을 확보해야 합니다.

### Other checks

- APK를 **난독화**하여 공격자의 리버스 엔지니어링 작업을 어렵게 만드는 것이 좋습니다.
- 앱이 민감한 경우(예: 은행 앱) **모바일이 루팅되었는지 확인하는 자체 검사를 수행**하고 그에 따라 행동해야 합니다.
- 앱이 민감한 경우(예: 은행 앱) **에뮬레이터**가 사용되고 있는지 확인해야 합니다.
- 앱이 민감한 경우(예: 은행 앱) **실행하기 전에 자체 무결성을 확인**하여 수정되었는지 확인해야 합니다.
- [**APKiD**](https://github.com/rednaga/APKiD)를 사용하여 APK를 빌드하는 데 사용된 컴파일러/패커/난독화 도구를 확인하세요.

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:

{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:

{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

The tool [**mariana-trench**](https://github.com/facebook/mariana-trench) is capable of finding **vulnerabilities** by **scanning** the **code** of the application. This tool contains a series of **known sources** (that indicates to the tool the **places** where the **input** is **controlled by the user**), **sinks** (which indicates to the tool **dangerous** **places** where malicious user input could cause damages) and **rules**. These rules indicates the **combination** of **sources-sinks** that indicates a vulnerability.

With this knowledge, **mariana-trench will review the code and find possible vulnerabilities on it**.

### Secrets leaked

An application may contain secrets (API keys, passwords, hidden urls, subdomains...) inside of it that you might be able to discover. You could us a tool such as [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication

{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)

### **Other tricks**

{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> First of all, you need an environment where you can install the application and all the environment (Burp CA cert, Drozer and Frida mainly). Therefore, a rooted device (emulated or not) is extremely recommended.

### Online Dynamic analysis

You can create a **free account** in: [https://appetize.io/](https://appetize.io). This platform allows you to **upload** and **execute** APKs, so it is useful to see how an apk is behaving.

You can even **see the logs of your application** in the web and connect through **adb**.

![](<../../images/image (831).png>)

Thanks to the ADB connection you can use **Drozer** and **Frida** inside the emulators.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (You can create **x86** and **arm** devices, and according to [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** versions **support ARM libraries** without needing an slow arm emulator).
- Learn to set it up in this page:

{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, you need to create an account. _It's recommend to **download** the version **WITH**_ _**VirtualBox** to avoid potential errors._)
- [**Nox**](https://es.bignox.com) (Free, but it doesn't support Frida or Drozer).

> [!NOTE]
> When creating a new emulator on any platform remember that the bigger the screen is, the slower the emulator will run. So select small screens if possible.

To **install google services** (like AppStore) in Genymotion you need to click on the red marked button of the following image:

![](<../../images/image (277).png>)

Also, notice that in the **configuration of the Android VM in Genymotion** you can select **Bridge Network mode** (this will be useful if you will be connecting to the Android VM from a different VM with the tools).

#### Use a physical device

You need to activate the **debugging** options and it will be cool if you can **root** it:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Once you have installed the application, the first thing you should do is to try it and investigate what does it do, how does it work and get comfortable with it.\
> I will suggest to **perform this initial dynamic analysis using MobSF dynamic analysis + pidcat**, so we will be able to **learn how the application works** while MobSF **captures** a lot of **interesting** **data** you can review later on.

### Unintended Data Leakage

**Logging**

개발자는 **디버깅 정보**를 공개적으로 노출하는 것에 주의해야 하며, 이는 민감한 데이터 유출로 이어질 수 있습니다. 애플리케이션 로그를 모니터링하여 민감한 정보를 식별하고 보호하기 위해 [**pidcat**](https://github.com/JakeWharton/pidcat) 및 `adb logcat` 도구를 사용하는 것이 좋습니다. **Pidcat**은 사용 용이성과 가독성 때문에 선호됩니다.

> [!WARNING]
> **Android 4.0** 이후 버전에서는 **응용 프로그램이 자신의 로그에만 접근할 수 있습니다**. 따라서 응용 프로그램은 다른 앱의 로그에 접근할 수 없습니다.\
> 어쨌든, **민감한 정보를 기록하지 않는 것이 여전히 권장됩니다**.

**Copy/Paste Buffer Caching**

Android의 **클립보드 기반** 프레임워크는 앱에서 복사-붙여넣기 기능을 가능하게 하지만, **다른 애플리케이션**이 클립보드에 접근할 수 있어 민감한 데이터가 노출될 위험이 있습니다. 신용 카드 세부정보와 같은 애플리케이션의 민감한 섹션에 대해 **복사/붙여넣기** 기능을 비활성화하는 것이 중요합니다.

**Crash Logs**

응용 프로그램이 **충돌**하고 **로그를 저장**하는 경우, 이러한 로그는 공격자에게 도움이 될 수 있으며, 특히 응용 프로그램을 리버스 엔지니어링할 수 없는 경우 더욱 그렇습니다. 이 위험을 완화하기 위해 충돌 시 로그를 기록하지 않도록 하고, 로그를 네트워크를 통해 전송해야 하는 경우 SSL 채널을 통해 전송되도록 해야 합니다.

펜테스터로서, **이 로그를 살펴보는 것을 시도해 보세요**.

**Analytics Data Sent To 3rd Parties**

응용 프로그램은 종종 Google Adsense와 같은 서비스를 통합하여 개발자의 부적절한 구현으로 인해 민감한 데이터가 **유출될 수 있습니다**. 잠재적인 데이터 유출을 식별하기 위해 **응용 프로그램의 트래픽을 가로채고** 제3자 서비스에 전송되는 민감한 정보가 있는지 확인하는 것이 좋습니다.

### SQLite DBs

대부분의 응용 프로그램은 정보를 저장하기 위해 **내부 SQLite 데이터베이스**를 사용합니다. 펜테스트 중에 생성된 **데이터베이스**, **테이블** 및 **열**의 이름과 저장된 모든 **데이터**를 살펴보아야 합니다. 왜냐하면 **민감한 정보**(취약점이 될 수 있음)를 찾을 수 있기 때문입니다.\
데이터베이스는 `/data/data/the.package.name/databases`에 위치해야 하며, 예를 들어 `/data/data/com.mwr.example.sieve/databases`와 같습니다.

데이터베이스가 기밀 정보를 저장하고 **암호화**되어 있지만 애플리케이션 내에서 **비밀번호**를 **찾을 수** 있다면 여전히 **취약점**입니다.

`.tables`를 사용하여 테이블을 나열하고, `.schema <table_name>`을 사용하여 테이블의 열을 나열합니다.

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer**는 Android 앱의 역할을 **가정**하고 다른 앱과 상호작용할 수 있게 해줍니다. 이는 설치된 애플리케이션이 할 수 있는 모든 작업을 수행할 수 있으며, Android의 프로세스 간 통신(IPC) 메커니즘을 활용하고 기본 운영 체제와 상호작용할 수 있습니다.\
Drozer는 **내보낸 활동, 내보낸 서비스 및 콘텐츠 제공자를 악용하는 데 유용한 도구**입니다.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
또한 활동의 코드는 **`onCreate`** 메서드에서 시작된다는 것을 기억하세요.

**Authorisation bypass**

활동이 내보내지면 외부 앱에서 해당 화면을 호출할 수 있습니다. 따라서 **민감한 정보**가 있는 활동이 **내보내진 경우**, **인증** 메커니즘을 **우회**하여 접근할 수 있습니다.

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/#activities)

adb에서 내보낸 활동을 시작할 수도 있습니다:

- PackageName은 com.example.demo입니다.
- Exported ActivityName은 com.example.test.MainActivity입니다.
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**참고**: MobSF는 활동에서 `android:launchMode`로 _**singleTask/singleInstance**_를 사용할 경우 악성으로 감지하지만, [이것](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750) 때문에, 이는 구버전(API 버전 < 21)에서만 위험한 것으로 보입니다.

> [!NOTE]
> 권한 우회가 항상 취약점은 아니라는 점에 유의해야 하며, 이는 우회가 어떻게 작동하는지와 어떤 정보가 노출되는지에 따라 다릅니다.

**민감한 정보 유출**

**활동은 결과를 반환할 수도 있습니다**. 만약 보호되지 않은 내보내기된 활동을 찾아 **`setResult`** 메서드를 호출하고 **민감한 정보를 반환**한다면, 이는 민감한 정보 유출입니다.

#### Tapjacking

Tapjacking이 방지되지 않으면, 내보내기된 활동을 악용하여 **사용자가 예상치 못한 작업을 수행하게** 만들 수 있습니다. [**Tapjacking이 무엇인지에 대한 더 많은 정보는 링크를 따라가세요**](./#tapjacking).

### **콘텐츠 제공자 악용 - 민감한 정보 접근 및 조작**

[**콘텐츠 제공자가 무엇인지 새롭게 알고 싶다면 이 내용을 읽어보세요.**](android-applications-basics.md#content-provider)\
콘텐츠 제공자는 기본적으로 **데이터를 공유**하는 데 사용됩니다. 앱에 사용 가능한 콘텐츠 제공자가 있다면, 그로부터 **민감한** 데이터를 **추출**할 수 있을지도 모릅니다. 또한 **SQL 인젝션** 및 **경로 탐색**을 테스트하는 것도 흥미롭습니다. 이들은 취약할 수 있습니다.

[**Drozer로 콘텐츠 제공자를 악용하는 방법을 배우세요.**](drozer-tutorial/#content-providers)

### **서비스 악용**

[**서비스가 무엇인지 새롭게 알고 싶다면 이 내용을 읽어보세요.**](android-applications-basics.md#services)\
서비스의 동작은 `onStartCommand` 메서드에서 시작된다는 점을 기억하세요.

서비스는 기본적으로 **데이터를 수신**하고, **처리**하며 **응답**(또는 응답하지 않을 수 있음)을 **반환**하는 것입니다. 따라서 애플리케이션이 일부 서비스를 내보내고 있다면, **코드**를 **확인**하여 그것이 무엇을 하는지 이해하고, **민감한 정보를 추출**하거나 인증 수단을 우회하기 위해 **동적으로** **테스트**해야 합니다.\
[**Drozer로 서비스를 악용하는 방법을 배우세요.**](drozer-tutorial/#services)

### **브로드캐스트 수신기 악용**

[**브로드캐스트 수신기가 무엇인지 새롭게 알고 싶다면 이 내용을 읽어보세요.**](android-applications-basics.md#broadcast-receivers)\
브로드캐스트 수신기의 동작은 `onReceive` 메서드에서 시작된다는 점을 기억하세요.

브로드캐스트 수신기는 특정 유형의 메시지를 기다립니다. 수신기가 메시지를 처리하는 방식에 따라 취약할 수 있습니다.\
[**Drozer로 브로드캐스트 수신기를 악용하는 방법을 배우세요.**](./#exploiting-broadcast-receivers)

### **스킴 / 딥 링크 악용**

MobSF와 같은 도구나 [이 스크립트](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py)를 사용하여 딥 링크를 수동으로 찾을 수 있습니다.\
**adb** 또는 **브라우저**를 사용하여 선언된 **스킴**을 **열 수** 있습니다:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_패키지 이름을 **생략할 수** 있으며, 모바일은 자동으로 해당 링크를 열어야 하는 앱을 호출합니다._
```markup
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**코드 실행됨**

**앱에서 실행될 코드**를 찾으려면, 딥링크로 호출된 액티비티로 가서 **`onNewIntent`** 함수를 검색하세요.

![](<../../images/image (436) (1) (1) (1).png>)

**민감한 정보**

딥링크를 찾을 때마다 **URL 매개변수를 통해 민감한 데이터(예: 비밀번호)를 수신하지 않는지 확인**하세요. 다른 애플리케이션이 **딥링크를 가장하여 해당 데이터를 훔칠 수 있습니다!**

**경로의 매개변수**

**딥링크가 URL의 경로 내에서 매개변수를 사용하고 있는지 확인해야 합니다**. 예: `https://api.example.com/v1/users/{username}`. 이 경우, `example://app/users?username=../../unwanted-endpoint%3fparam=value`와 같은 경로 탐색을 강제할 수 있습니다.\
애플리케이션 내에서 올바른 엔드포인트를 찾으면 **Open Redirect**(경로의 일부가 도메인 이름으로 사용되는 경우), **계정 탈취**(CSRF 토큰 없이 사용자 세부정보를 수정할 수 있고 취약한 엔드포인트가 올바른 메서드를 사용하는 경우) 및 기타 취약점을 유발할 수 있습니다. 더 많은 [정보는 여기에서](http://dphoeniixx.com/2020/12/13-2/) 확인하세요.

**더 많은 예시**

링크에 대한 [흥미로운 버그 바운티 보고서](https://hackerone.com/reports/855618) (_/.well-known/assetlinks.json_).

### 전송 계층 검사 및 검증 실패

- **인증서는 Android 애플리케이션에서 항상 제대로 검사되지 않습니다**. 이러한 애플리케이션이 경고를 무시하고 자체 서명된 인증서를 수락하거나, 경우에 따라 HTTP 연결로 되돌아가는 것이 일반적입니다.
- **SSL/TLS 핸드셰이크 중 협상이 때때로 약합니다**, 안전하지 않은 암호 모음을 사용합니다. 이 취약점은 연결을 중간자(MITM) 공격에 취약하게 만들어 공격자가 데이터를 복호화할 수 있게 합니다.
- **민감한 정보의 유출**은 애플리케이션이 안전한 채널을 사용하여 인증하지만 다른 거래에 대해 비안전한 채널을 통해 통신할 때 위험이 있습니다. 이 접근 방식은 세션 쿠키나 사용자 세부정보와 같은 민감한 데이터를 악의적인 엔티티의 가로채기로부터 보호하지 못합니다.

#### 인증서 검증

**인증서 검증**에 집중하겠습니다. 보안을 강화하기 위해 서버의 인증서 무결성을 검증해야 합니다. 이는 안전하지 않은 TLS 구성과 암호화되지 않은 채널을 통한 민감한 데이터 전송이 상당한 위험을 초래할 수 있기 때문에 중요합니다. 서버 인증서를 검증하고 취약점을 해결하는 방법에 대한 자세한 단계는 [**이 리소스**](https://manifestsecurity.com/android-application-security-part-10/)에서 포괄적인 지침을 제공합니다.

#### SSL 핀닝

SSL 핀닝은 애플리케이션이 서버의 인증서를 애플리케이션 내에 저장된 알려진 복사본과 비교하여 검증하는 보안 조치입니다. 이 방법은 MITM 공격을 방지하는 데 필수적입니다. 민감한 정보를 처리하는 애플리케이션에는 SSL 핀닝 구현이 강력히 권장됩니다.

#### 트래픽 검사

HTTP 트래픽을 검사하려면 **프록시 도구의 인증서를 설치해야 합니다**(예: Burp). 이 인증서를 설치하지 않으면 암호화된 트래픽이 프록시를 통해 표시되지 않을 수 있습니다. 사용자 지정 CA 인증서를 설치하는 방법에 대한 가이드는 [**여기를 클릭하세요**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

**API Level 24 이상**을 대상으로 하는 애플리케이션은 프록시의 CA 인증서를 수락하도록 네트워크 보안 구성을 수정해야 합니다. 이 단계는 암호화된 트래픽을 검사하는 데 중요합니다. 네트워크 보안 구성을 수정하는 방법에 대한 지침은 [**이 튜토리얼을 참조하세요**](make-apk-accept-ca-certificate.md).

#### SSL 핀닝 우회

SSL 핀닝이 구현된 경우 HTTPS 트래픽을 검사하기 위해 이를 우회해야 합니다. 이를 위한 다양한 방법이 있습니다:

- **apk**를 자동으로 **수정**하여 SSL 핀닝을 **우회**하는 [**apk-mitm**](https://github.com/shroudedcode/apk-mitm)을 사용할 수 있습니다. 이 옵션의 가장 큰 장점은 SSL 핀닝을 우회하기 위해 루트가 필요하지 않지만, 애플리케이션을 삭제하고 새로 설치해야 하며, 항상 작동하지는 않습니다.
- **Frida**를 사용하여 이 보호를 우회할 수 있습니다(아래에서 논의됨). Burp+Frida+Genymotion을 사용하는 방법에 대한 가이드는 [여기](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)에서 확인하세요.
- **objection**을 사용하여 SSL 핀닝을 **자동으로 우회**할 수도 있습니다: `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- **MobSF 동적 분석**을 사용하여 SSL 핀닝을 **자동으로 우회**할 수도 있습니다(아래에서 설명).
- 여전히 캡처하지 못한 트래픽이 있다고 생각되면 **iptables를 사용하여 트래픽을 burp로 포워딩**할 수 있습니다. 이 블로그를 읽어보세요: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### 일반 웹 취약점 찾기

애플리케이션 내에서 일반 웹 취약점을 검색하는 것도 중요합니다. 이러한 취약점을 식별하고 완화하는 방법에 대한 자세한 정보는 이 요약의 범위를 넘어가지만, 다른 곳에서 광범위하게 다루어지고 있습니다.

### Frida

[Frida](https://www.frida.re)는 개발자, 리버스 엔지니어 및 보안 연구자를 위한 동적 계측 툴킷입니다.\
**실행 중인 애플리케이션에 접근하고 런타임에서 메서드를 후킹하여 동작을 변경하고, 값을 변경하고, 값을 추출하고, 다른 코드를 실행할 수 있습니다...**\
Android 애플리케이션을 펜테스트하려면 Frida를 사용하는 방법을 알아야 합니다.

- Frida 사용 방법 배우기: [**Frida 튜토리얼**](frida-tutorial/)
- Frida로 작업하기 위한 "GUI": [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection은 Frida 사용을 자동화하는 데 유용합니다: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- 여기에서 멋진 Frida 스크립트를 찾을 수 있습니다: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace)에서 지시한 대로 Frida를 로드하여 안티 디버깅 / 안티 Frida 메커니즘을 우회해 보세요(도구 [linjector](https://github.com/erfur/linjector-rs)).

### **메모리 덤프 - Fridump**

애플리케이션이 비밀번호나 암기구와 같은 민감한 정보를 저장하고 있지 않은지 확인하세요.

[**Fridump3**](https://github.com/rootbsd/fridump3)를 사용하여 앱의 메모리를 덤프할 수 있습니다:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
이것은 ./dump 폴더에 메모리를 덤프할 것이며, 그 안에서 다음과 같이 grep을 사용할 수 있습니다:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Keystore의 민감한 데이터**

Android에서 Keystore는 민감한 데이터를 저장하기에 가장 좋은 장소이지만, 충분한 권한이 있으면 여전히 **접근할 수 있습니다**. 애플리케이션이 여기에서 **명확한 텍스트로 민감한 데이터를 저장하는 경향이 있기 때문에** 펜테스트는 루트 사용자로 확인해야 하며, 물리적으로 장치에 접근할 수 있는 누군가가 이 데이터를 훔칠 수 있습니다.

앱이 keystore에 데이터를 저장하더라도, 데이터는 암호화되어야 합니다.

keystore 내부의 데이터에 접근하려면 이 Frida 스크립트를 사용할 수 있습니다: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **지문/생체 인식 우회**

다음 Frida 스크립트를 사용하면 **지문 인증을 우회**할 수 있을 수 있습니다. Android 애플리케이션이 **특정 민감한 영역을 보호하기 위해 수행할 수 있습니다:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **배경 이미지**

애플리케이션을 백그라운드에 두면, Android는 **애플리케이션의 스냅샷**을 저장하므로 포그라운드로 복구될 때 앱보다 이미지를 먼저 로드하여 앱이 더 빨리 로드된 것처럼 보입니다.

그러나 이 스냅샷에 **민감한 정보**가 포함되어 있다면, 스냅샷에 접근할 수 있는 사람은 **그 정보를 훔칠 수 있습니다** (접근하려면 루트 권한이 필요합니다).

스냅샷은 일반적으로 다음 위치에 저장됩니다: **`/data/system_ce/0/snapshots`**

Android는 **FLAG_SECURE** 레이아웃 매개변수를 설정하여 스크린샷 캡처를 **방지하는 방법**을 제공합니다. 이 플래그를 사용하면 창의 내용이 안전한 것으로 처리되어 스크린샷에 나타나거나 비안전한 디스플레이에서 볼 수 없게 됩니다.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **안드로이드 애플리케이션 분석기**

이 도구는 동적 분석 중 다양한 도구를 관리하는 데 도움이 될 수 있습니다: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### 인텐트 주입

개발자는 종종 이러한 인텐트를 처리하고 `startActivity(...)` 또는 `sendBroadcast(...)`와 같은 메서드로 전달하는 프록시 구성 요소인 액티비티, 서비스 및 브로드캐스트 수신기를 생성합니다. 이는 위험할 수 있습니다.

위험은 공격자가 이러한 인텐트를 잘못 유도하여 비공개 앱 구성 요소를 트리거하거나 민감한 콘텐츠 제공자에 접근할 수 있도록 허용하는 데 있습니다. 주목할 만한 예는 `WebView` 구성 요소가 URL을 `Intent` 객체로 변환하는 `Intent.parseUri(...)`를 통해 이를 실행하여 악의적인 인텐트 주입으로 이어질 수 있는 경우입니다.

### 주요 요점

- **인텐트 주입**은 웹의 오픈 리디렉션 문제와 유사합니다.
- 익스플로잇은 `Intent` 객체를 추가로 전달하여 안전하지 않은 작업을 실행하도록 리디렉션할 수 있습니다.
- 비공개 구성 요소와 콘텐츠 제공자를 공격자에게 노출할 수 있습니다.
- `WebView`의 URL을 `Intent`로 변환하는 것은 의도하지 않은 작업을 촉진할 수 있습니다.

### 안드로이드 클라이언트 측 주입 및 기타

아마도 웹에서 이러한 종류의 취약점에 대해 알고 계실 것입니다. 안드로이드 애플리케이션에서 이러한 취약점에 특히 주의해야 합니다:

- **SQL 주입:** 동적 쿼리 또는 콘텐츠 제공자를 다룰 때 매개변수화된 쿼리를 사용하고 있는지 확인하십시오.
- **자바스크립트 주입 (XSS):** 모든 WebViews에 대해 자바스크립트 및 플러그인 지원이 비활성화되어 있는지 확인하십시오 (기본적으로 비활성화됨). [자세한 정보는 여기](webview-attacks.md#javascript-enabled)를 참조하십시오.
- **로컬 파일 포함:** WebViews는 파일 시스템에 대한 접근이 비활성화되어야 합니다 (기본적으로 활성화됨) - `(webview.getSettings().setAllowFileAccess(false);)`. [자세한 정보는 여기](webview-attacks.md#javascript-enabled)를 참조하십시오.
- **영구 쿠키**: 여러 경우에 안드로이드 애플리케이션이 세션을 종료할 때 쿠키가 취소되지 않거나 디스크에 저장될 수 있습니다.
- [**쿠키의 보안 플래그**](../../pentesting-web/hacking-with-cookies/#cookies-flags)

---

## 자동 분석

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**정적 분석**

![](<../../images/image (866).png>)

**애플리케이션의 취약점 평가**를 위한 멋진 웹 기반 프론트엔드를 사용합니다. 동적 분석도 수행할 수 있지만 환경을 준비해야 합니다.
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
MobSF는 **Android**(apk)**, IOS**(ipa) **및 Windows**(apx) 애플리케이션을 분석할 수 있습니다 (_Windows 애플리케이션은 Windows 호스트에 설치된 MobSF에서 분석해야 합니다_).\
또한, **Android** 또는 **IOS** 앱의 소스 코드로 **ZIP** 파일을 생성하면 (애플리케이션의 루트 폴더로 이동하여 모든 것을 선택하고 ZIP 파일을 생성), 그것도 분석할 수 있습니다.

MobSF는 **diff/비교** 분석을 허용하고 **VirusTotal**와 통합할 수 있습니다 (API 키를 _MobSF/settings.py_에 설정하고 활성화해야 합니다: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). `VT_UPLOAD`를 `False`로 설정하면 **해시**가 파일 대신 **업로드**됩니다.

### MobSF를 이용한 보조 동적 분석

**MobSF**는 **Android**에서 **동적 분석**에 매우 유용할 수 있지만, 이 경우 MobSF와 **genymotion**을 호스트에 설치해야 합니다 (VM 또는 Docker는 작동하지 않습니다). _참고: **먼저 genymotion에서 VM을 시작한 후** **MobSF를 시작해야 합니다.**_\
**MobSF 동적 분석기**는 다음을 수행할 수 있습니다:

- **애플리케이션 데이터 덤프** (URL, 로그, 클립보드, 사용자가 만든 스크린샷, "**Exported Activity Tester**"가 만든 스크린샷, 이메일, SQLite 데이터베이스, XML 파일 및 기타 생성된 파일). 이 모든 것은 자동으로 수행되며, 스크린샷은 원할 때 눌러야 하거나 "**Exported Activity Tester**"를 눌러 모든 내보낸 활동의 스크린샷을 얻어야 합니다.
- **HTTPS 트래픽 캡처**
- **Frida**를 사용하여 **런타임** **정보**를 얻기

Android **버전 > 5**에서는 **Frida**를 **자동으로 시작**하고 **트래픽 캡처**를 위해 전역 **프록시** 설정을 합니다. 테스트된 애플리케이션에서만 트래픽을 캡처합니다.

**Frida**

기본적으로 SSL 핀닝, **루트 탐지** 및 **디버거 탐지**를 우회하고 **흥미로운 API**를 모니터링하기 위해 일부 Frida 스크립트를 사용합니다.\
MobSF는 또한 **내보낸 활동을 호출**하고, 그들의 **스크린샷을 캡처**하여 보고서에 **저장**할 수 있습니다.

동적 테스트를 **시작**하려면 초록색 버튼: "**Start Instrumentation**"을 누르십시오. "**Frida Live Logs**"를 눌러 Frida 스크립트에서 생성된 로그를 보고, "**Live API Monitor**"를 눌러 후킹된 메서드에 대한 모든 호출, 전달된 인수 및 반환 값을 확인하십시오 (이것은 "Start Instrumentation"을 누른 후에 나타납니다).\
MobSF는 또한 자신의 **Frida 스크립트**를 로드할 수 있습니다 (Frida 스크립트의 결과를 MobSF에 보내려면 `send()` 함수를 사용하십시오). 또한 로드할 수 있는 **여러 사전 작성된 스크립트**가 있습니다 (더 추가할 수 있습니다 `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), 그냥 **선택하고**, "**Load**"를 누르고 "**Start Instrumentation**"을 누르십시오 (해당 스크립트의 로그는 "**Frida Live Logs**"에서 볼 수 있습니다).

![](<../../images/image (419).png>)

또한, 몇 가지 보조 Frida 기능이 있습니다:

- **로드된 클래스 나열**: 모든 로드된 클래스를 출력합니다.
- **문자열 캡처**: 애플리케이션을 사용하는 동안 모든 캡처된 문자열을 출력합니다 (매우 시끄러움).
- **문자열 비교 캡처**: 매우 유용할 수 있습니다. **비교되는 2개의 문자열**과 결과가 True인지 False인지 보여줍니다.
- **클래스 메서드 나열**: 클래스 이름(예: "java.io.File")을 입력하면 클래스의 모든 메서드를 출력합니다.
- **클래스 패턴 검색**: 패턴으로 클래스를 검색합니다.
- **클래스 메서드 추적**: **전체 클래스**를 **추적**합니다 (클래스의 모든 메서드의 입력 및 출력을 봅니다). 기본적으로 MobSF는 여러 흥미로운 Android API 메서드를 추적합니다.

사용할 보조 모듈을 선택한 후 "**Start Instrumentation**"을 누르면 "**Frida Live Logs**"에서 모든 출력을 볼 수 있습니다.

**Shell**

Mobsf는 동적 분석 페이지 하단에 일부 **adb** 명령, **MobSF 명령** 및 일반 **셸** **명령**이 포함된 셸을 제공합니다. 몇 가지 흥미로운 명령:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP 도구**

HTTP 트래픽이 캡처되면 "**HTTP(S) Traffic**" 하단에서 캡처된 트래픽의 보기 또는 "**Start HTTPTools**" 녹색 버튼에서 더 나은 보기를 볼 수 있습니다. 두 번째 옵션에서 **캡처된 요청**을 **프록시**인 Burp 또는 Owasp ZAP으로 **전송**할 수 있습니다.\
이를 위해, _Burp 켜기 -->_ _Intercept 끄기 --> MobSB HTTPTools에서 요청 선택_ --> "**Send to Fuzzer**" 버튼을 누르기 --> _프록시 주소 선택_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

MobSF로 동적 분석을 마친 후 "**Start Web API Fuzzer**"를 눌러 **HTTP 요청을 퍼징**하고 취약점을 찾아볼 수 있습니다.

> [!NOTE]
> MobSF로 동적 분석을 수행한 후 프록시 설정이 잘못 구성될 수 있으며 GUI에서 이를 수정할 수 없습니다. 다음을 수행하여 프록시 설정을 수정할 수 있습니다:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Inspeckage를 이용한 보조 동적 분석

[**Inspeckage**](https://github.com/ac-pm/Inspeckage)에서 도구를 받을 수 있습니다.\
이 도구는 **동적 분석**을 수행하는 동안 **애플리케이션에서 무슨 일이 일어나고 있는지** 알기 위해 몇 가지 **후크**를 사용합니다.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

이것은 **GUI를 사용한 정적 분석을 수행하기 위한 훌륭한 도구**입니다.

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

이 도구는 **소스 코드** 또는 **패키지된 APK**에서 여러 **보안 관련 Android 애플리케이션 취약점**을 찾기 위해 설계되었습니다. 이 도구는 또한 발견된 일부 취약점을 악용하기 위한 **"Proof-of-Concept" 배포 가능한 APK** 및 **ADB 명령**을 생성할 수 있습니다 (노출된 활동, 인텐트, 탭재킹 등...). Drozer와 마찬가지로 테스트 장치를 루팅할 필요가 없습니다.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- 모든 추출된 파일을 쉽게 참조할 수 있도록 표시
- APK 파일을 자동으로 Java 및 Smali 형식으로 디컴파일
- 일반적인 취약점 및 동작을 위해 AndroidManifest.xml 분석
- 일반적인 취약점 및 동작에 대한 정적 소스 코드 분석
- 장치 정보
- 및 기타
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER는 Windows, MacOS X 및 Linux에서 사용할 수 있는 명령줄 애플리케이션으로, 취약점을 찾기 위해 _.apk_ 파일을 분석합니다. 이는 APK를 압축 해제하고 일련의 규칙을 적용하여 이러한 취약점을 감지합니다.

모든 규칙은 `rules.json` 파일에 중심을 두고 있으며, 각 회사나 테스터는 필요에 따라 분석할 규칙을 만들 수 있습니다.

최신 바이너리는 [download page](https://superanalyzer.rocks/download.html)에서 다운로드하세요.
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn은 개발자, 버그 바운티 헌터 및 윤리적 해커가 모바일 애플리케이션에 대해 [정적 코드 분석](https://en.wikipedia.org/wiki/Static_program_analysis)을 수행하는 데 도움을 주는 **크로스 플랫폼** 도구입니다.

개념은 모바일 애플리케이션 파일(.apk 또는 .ipa 파일)을 StaCoAn 애플리케이션에 드래그 앤 드롭하면 시각적이고 휴대 가능한 보고서를 생성하는 것입니다. 설정과 단어 목록을 조정하여 맞춤형 경험을 얻을 수 있습니다.

다운로드[ 최신 릴리스](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework는 개발자 또는 해커가 Android 애플리케이션에서 잠재적인 보안 취약점을 찾는 데 도움을 주는 Android 취약점 분석 시스템입니다.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn**는 Android 애플리케이션에서 발생할 수 있는 악의적인 행동을 감지하고 사용자에게 경고하는 것을 주요 목표로 하는 도구입니다.

감지는 애플리케이션의 Dalvik 바이트코드에 대한 **정적 분석**을 통해 수행되며, 이는 **Smali**로 표현됩니다. [`androguard`](https://github.com/androguard/androguard) 라이브러리를 사용합니다.

이 도구는 다음과 같은 **"나쁜" 애플리케이션의 일반적인 행동**을 찾습니다: 전화 식별자 유출, 오디오/비디오 흐름 가로채기, PIM 데이터 수정, 임의 코드 실행...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA**는 **M**obile **A**pplication **R**everse engineering 및 **A**nalysis Framework입니다. 이는 OWASP 모바일 보안 위협에 대해 모바일 애플리케이션을 테스트하는 데 도움을 주기 위해 일반적으로 사용되는 모바일 애플리케이션 리버스 엔지니어링 및 분석 도구를 통합한 도구입니다. 이 작업을 모바일 애플리케이션 개발자와 보안 전문가에게 더 쉽고 친숙하게 만드는 것이 목표입니다.

다음과 같은 기능을 제공합니다:

- 다양한 도구를 사용하여 Java 및 Smali 코드를 추출합니다.
- 다음을 사용하여 APK를 분석합니다: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- 정규 표현식을 사용하여 APK에서 개인 정보를 추출합니다.
- 매니페스트를 분석합니다.
- 다음을 사용하여 발견된 도메인을 분석합니다: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) 및 [whatweb](https://github.com/urbanadventurer/WhatWeb)
- [apk-deguard.com](http://www.apk-deguard.com)을 통해 APK를 디오브스큐레이션합니다.

### Koodous

악성 소프트웨어를 탐지하는 데 유용합니다: [https://koodous.com/](https://koodous.com)

## 코드 난독화/디오브스큐레이션

코드를 난독화하는 데 사용하는 서비스와 구성에 따라 비밀이 난독화될 수도 있고 그렇지 않을 수도 있습니다.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

[위키백과](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard**는 Java 코드를 축소, 최적화 및 난독화하는 오픈 소스 명령줄 도구입니다. 바이트코드를 최적화하고 사용되지 않는 명령어를 감지 및 제거할 수 있습니다. ProGuard는 무료 소프트웨어이며 GNU 일반 공중 라이선스 버전 2에 따라 배포됩니다.

ProGuard는 Android SDK의 일부로 배포되며 애플리케이션을 릴리스 모드로 빌드할 때 실행됩니다.

### [DexGuard](https://www.guardsquare.com/dexguard)

APK를 디오브스큐레이션하는 단계별 가이드를 [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)에서 찾을 수 있습니다.

(그 가이드에서) 마지막으로 확인했을 때, Dexguard의 작동 모드는 다음과 같았습니다:

- 리소스를 InputStream으로 로드합니다;
- 결과를 FilterInputStream에서 상속받은 클래스에 제공하여 복호화합니다;
- 리버서의 시간을 낭비하기 위해 쓸모없는 난독화를 수행합니다;
- 복호화된 결과를 ZipInputStream에 제공하여 DEX 파일을 가져옵니다;
- 마지막으로 `loadDex` 메서드를 사용하여 결과 DEX를 리소스로 로드합니다.

### [DeGuard](http://apk-deguard.com)

**DeGuard는 Android 난독화 도구가 수행한 난독화 프로세스를 역전시킵니다. 이를 통해 코드 검사 및 라이브러리 예측을 포함한 수많은 보안 분석이 가능합니다.**

난독화된 APK를 그들의 플랫폼에 업로드할 수 있습니다.

### [Deobfuscate android App](https://github.com/In3tinct/deobfuscate-android-app)

이것은 Android 앱에서 잠재적인 보안 취약점을 찾고 Android 앱 코드를 디오브스큐레이션하는 LLM 도구입니다. Google의 Gemini 공개 API를 사용합니다.

### [Simplify](https://github.com/CalebFenton/simplify)

이는 **일반 Android 디오브스큐레이터**입니다. Simplify는 **앱을 가상 실행**하여 그 동작을 이해하고, **코드를 최적화**하여 동일하게 동작하지만 사람이 이해하기 쉽게 만듭니다. 각 최적화 유형은 간단하고 일반적이므로 사용된 특정 난독화 유형은 중요하지 않습니다.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD는 **APK가 어떻게 만들어졌는지**에 대한 정보를 제공합니다. 많은 **컴파일러**, **패커**, **난독화 도구** 및 기타 이상한 것들을 식별합니다. Android용 [_PEiD_](https://www.aldeid.com/wiki/PEiD)입니다.

### Manual

[사용자 정의 난독화를 리버스하는 방법에 대한 몇 가지 요령을 배우려면 이 튜토리얼을 읽으세요](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b는 Ubuntu-mate를 기반으로 한 Android 보안 가상 머신으로, 리버스 엔지니어링 및 악성 소프트웨어 분석을 위한 최신 프레임워크, 튜토리얼 및 다양한 보안 전문가와 연구자들의 실험실을 포함합니다.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) 훌륭한 리소스 목록입니다.
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android 빠른 과정
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)

## Yet to try

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
