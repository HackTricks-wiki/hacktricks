# Android 应用 Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android 应用 基础

强烈建议先阅读此页面，以了解与 Android 安全相关的**最重要部分以及 Android 应用中最危险的组件**：


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

这是连接到 Android 设备（模拟或实体）所需的主要工具。\
**ADB** 允许从计算机通过 **USB** 或 **Network** 控制设备。该工具可实现文件的双向**复制**、应用的**安装**与**卸载**、shell 命令的**执行**、数据的**备份**、日志的**读取**，以及其他功能。

查看下面的 [**ADB Commands**](adb-commands.md) 列表，学习如何使用 adb。

## Smali

有时修改**应用程序代码**以访问**隐藏信息**（例如高度混淆的密码或 flag）是很有意义的。然后，反编译 APK、修改代码并重新编译可能会很有用。\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). 这在进行动态分析期间作为若干测试的替代方法时可能非常有用。请始终记住这种可能性。

## 其他有趣的技巧

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **下载 APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- 从设备提取 APK:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- 使用 [APKEditor](https://github.com/REAndroid/APKEditor) 合并所有 splits 和 base apks:
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## 案例研究与漏洞


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## 静态分析

首先，要分析一个 APK，你应该使用反编译器**查看 Java 代码**。\
请[**在此阅读以了解可用反编译器的相关信息**](apk-decompilers.md)。

### 查找有趣的信息

仅查看 APK 的 **strings** 就可以搜索 **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** 和任何有趣的东西……甚至查找代码执行的 **backdoors** 或身份验证 backdoors（应用的硬编码 admin credentials）。

**Firebase**

请特别注意 **Firebase URLs** 并检查其是否配置不当。[更多关于什么是 Firebase 以及如何利用它的信息见此处。](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### 对应用的基本理解 - Manifest.xml, strings.xml

对应用的 **_Manifest.xml_ 和 **_strings.xml_** 文件的检查可以揭示潜在的安全漏洞**。这些文件可以通过反编译器获取，或将 APK 文件扩展名改为 .zip 然后解压来访问。

从 **Manifest.xml** 中可以识别的 **漏洞** 包括：

- **Debuggable Applications**：在 _Manifest.xml_ 文件中被设置为 debuggable (`debuggable="true"`) 的应用存在风险，因为它们允许建立连接，可能导致被利用。关于如何在设备上查找和利用 debuggable 应用的更多信息，请参考相关教程。
- **Backup Settings**：对于处理敏感信息的应用，应明确设置 `android:allowBackup="false"` 属性，以防止通过 adb 在 usb debugging 启用时进行未授权的数据备份。
- **Network Security**：自定义网络安全配置（`android:networkSecurityConfig="@xml/network_security_config"`）位于 _res/xml/_ 中，可指定诸如证书 pinning 和 HTTP 流量设置等安全细节。例如可以为特定域名允许 HTTP 流量。
- **Exported Activities and Services**：识别 manifest 中导出的 activities 和 services 可以突出可能被滥用的组件。动态测试阶段可以进一步分析如何利用这些组件。
- **Content Providers and FileProviders**：暴露的 content providers 可能允许未授权的访问或修改数据。FileProviders 的配置也应仔细审查。
- **Broadcast Receivers and URL Schemes**：这些组件可能被用来进行利用，特别注意 URL schemes 如何处理输入以防止注入或其他输入相关的漏洞。
- **SDK Versions**：`minSdkVersion`、`targetSDKVersion` 和 `maxSdkVersion` 属性指示支持的 Android 版本，提示不要支持已过时且存在已知漏洞的 Android 版本以维护安全性。

从 **strings.xml** 文件中，可以发现诸如 API keys、自定义 schema 以及其他开发者备注等敏感信息，这强调了对这些资源进行仔细审查的必要性。

### Tapjacking

**Tapjacking** 是一种攻击，攻击者会启动一个 **malicious** **application** 并将其**放置在受害应用之上**。一旦它可见地遮挡了受害应用，其用户界面会被设计成以欺骗用户与其交互，同时将交互传递给受害应用。\
实际上，它是**让用户看不见他们实际上在对受害应用执行操作**。

更多信息请见：


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

如果一个 **activity** 的 **`launchMode`** 设置为 **`singleTask` 且未定义任何 `taskAffinity`**，则容易受到 Task Hijacking 的影响。这意味着，可以安装一个 **application**，并且如果在真实应用之前启动它，它可能**劫持真实应用的任务**（使用户在与**malicious application** 交互时误以为是在使用真实应用）。

更多信息见：


{{#ref}}
android-task-hijacking.md
{{#endref}}

### 不安全的数据存储

**Internal Storage**

在 Android 中，存储在 **internal** 存储中的文件**设计上只能由创建它们的应用访问**。该安全措施由 Android 操作系统强制执行，通常能满足大多数应用的安全需求。然而，开发者有时会使用诸如 `MODE_WORLD_READABLE` 和 `MODE_WORLD_WRITABLE` 的模式来**允许**文件在不同应用之间**共享**。但这些模式**不会限制其他应用对这些文件的访问**，包括可能的恶意应用。

1. 静态分析：
- **确保** 对 `MODE_WORLD_READABLE` 和 `MODE_WORLD_WRITABLE` 的使用进行**严格审查**。这些模式**可能会将文件暴露给非预期或未授权的访问**。
2. 动态分析：
- **验证** 应用创建的文件权限。特别是，**检查** 是否有任何文件被设置为全局可读或可写。这可能构成重大安全风险，因为它将允许**任何已安装的应用**（无论来源或意图）**读取或修改**这些文件。

**External Storage**

处理位于 **external storage**（如 SD 卡）上的文件时，应采取以下注意事项：

1. 可访问性：
- external storage 上的文件是**全局可读写**的。这意味着任何应用或用户都可以访问这些文件。
2. 安全顾虑：
- 鉴于访问容易，建议**不要在 external storage 上存储敏感信息**。
- external storage 可以被移除或被任何应用访问，因此安全性较低。
3. 处理来自 external storage 的数据：
- 始终对从 external storage 检索的数据进行**输入验证**。这很重要，因为这些数据来自不受信任的来源。
- 强烈不建议将可执行文件或 class 文件存放在 external storage 以供动态加载。
- 如果你的应用必须从 external storage 检索可执行文件，请确保在动态加载之前对这些文件进行**签名和密码学验证**。此步骤对于维护应用的安全完整性至关重要。

External storage 可以在 /storage/emulated/0, /sdcard, /mnt/sdcard 访问

> [!TIP]
> 从 Android 4.4（**API 17**）开始，SD 卡具有一种目录结构，**将应用的访问限制在专门为该应用设置的目录内**。这可以防止恶意应用获得对其他应用文件的读写权限。

**以明文存储的敏感数据**

- **Shared preferences**：Android 允许每个应用方便地在路径 `/data/data/<packagename>/shared_prefs/` 保存 xml 文件，有时可以在该文件夹中以明文找到敏感信息。
- **Databases**：Android 允许每个应用方便地在路径 `/data/data/<packagename>/databases/` 保存 sqlite 数据库，有时可以在该文件夹中以明文找到敏感信息。

### Broken TLS

**Accept All Certificates**

出于某些原因，开发者有时会接受所有证书，即使例如 hostname 不匹配，也会有如下类似的代码行：
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Broken Cryptography

**Poor Key Management Processes**

一些开发者会将敏感数据保存在本地存储并用硬编码/可预测的密钥进行加密。这样做不可取，因为通过一些 reversing 工作，攻击者可能提取出机密信息。

**Use of Insecure and/or Deprecated Algorithms**

开发者不应使用 **已弃用的算法** 来执行授权 **checks**、**存储** 或 **发送** 数据。部分此类算法包括：RC4、MD4、MD5、SHA1……例如，如果使用 **hashes** 来存储密码，应使用对 brute-force **resistant** 的哈希并配合 salt。

### Other checks

- 建议对 **APK 进行混淆（obfuscate the APK）**，以增加逆向工程的难度。
- 如果应用比较敏感（例如银行类应用），应该自行检查手机是否 **rooted** 并据此采取措施。
- 如果应用比较敏感（例如银行类应用），应检查是否在 **emulator** 中运行。
- 如果应用比较敏感（例如银行类应用），应在执行前 **检查自身完整性** 以确认是否被篡改。
- 使用 [**APKiD**](https://github.com/rednaga/APKiD) 检查构建 APK 时使用了哪个 compiler/packer/obfuscator

### React Native Application

阅读以下页面，了解如何轻松访问 React 应用的 javascript 代码：


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

阅读以下页面，了解如何轻松访问 xamarin 应用的 C# 代码：


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

根据这篇 [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/)，superpacked 是 Meta 的一种算法，它将应用的内容压缩到单个文件中。博文讨论了创建一个解压这类应用的应用的可能性……以及一种更快的方法，涉及 **执行应用并从文件系统收集解压后的文件。**

### Automated Static Code Analysis

工具 [**mariana-trench**](https://github.com/facebook/mariana-trench) 能通过 **扫描** 应用 **代码** 来发现 **vulnerabilities**。该工具包含一系列 **known sources**（指示工具哪些 **位置** 的 **输入** 由用户控制）、**sinks**（指示工具哪些 **危险** 的 **位置** 可能被恶意用户输入利用）和 **rules**。这些规则定义了指示存在漏洞的 **sources-sinks** 组合。

基于这些信息，**mariana-trench 会审查代码并发现其中的潜在漏洞**。

### Secrets leaked

应用中可能包含 secrets（API keys、密码、隐藏的 urls、子域名……）等，你可能能够发现这些信息。你可以使用诸如 [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks) 之类的工具。

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> 首先，你需要一个可以安装应用及其环境（主要是 Burp CA cert、Drozer 和 Frida）的环境。因此，强烈推荐使用已 root 的设备（模拟或真实设备均可）。

### Online Dynamic analysis

你可以在此创建一个 **免费账号**: [https://appetize.io/](https://appetize.io)。该平台允许你 **上传** 并 **执行** APK，非常适合观察 APK 的运行行为。

你甚至可以在网页中 **查看应用的日志** 并通过 **adb** 连接。

![](<../../images/image (831).png>)

借助 ADB 连接，你可以在模拟器内使用 **Drozer** 和 **Frida**。

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio)（你可以创建 **x86** 和 **arm** 设备，根据 [**this**](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html) **最新 x86** 版本 **支持 ARM 库**，无需使用较慢的 arm 模拟器）。
- 在此页面学习如何设置：


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **（免费版本：Personal Edition，需要创建账号。建议下载带有** _**VirtualBox**_** 的版本以避免潜在错误。）**
- [**Nox**](https://es.bignox.com)（免费，但不支持 Frida 或 Drozer）。

> [!TIP]
> 在任何平台创建新的模拟器时请记住，屏幕越大，模拟器运行越慢。因此如无必要请选择小屏幕。

要在 Genymotion 中 **安装 google services（例如 Play Store）**，需要点击下图中标红的按钮：

![](<../../images/image (277).png>)

另外，请注意在 **Genymotion 的 Android VM 配置中** 可以选择 **Bridge Network mode**（如果你会从另一个 VM 连接到该 Android VM 并使用工具，这会很有用）。

#### Use a physical device

你需要激活 **调试（debugging）** 选项，若能 **root** 设备会更好：

1. **Settings**。
2. （从 Android 8.0 起）选择 **System**。
3. 选择 **About phone**。
4. 连续按 **Build number** 7 次。
5. 返回，你会看到 **Developer options**。

> 一旦你安装了应用，首先应该运行并探索它，了解它的功能与工作方式并熟悉它。\
> 我建议使用 MobSF dynamic analysis + pidcat 来执行这一步初始的动态分析，这样我们在学习应用如何工作时，MobSF 会捕获大量你可以随后审查的有价值数据。

Magisk/Zygisk quick notes (recommended on Pixel devices)
- Patch boot.img with the Magisk app and flash via fastboot to get systemless root
- Enable Zygisk + DenyList for root hiding; consider LSPosed/Shamiko when stronger hiding is required
- Keep original boot.img to recover from OTA updates; re-patch after each OTA
- For screen mirroring, use scrcpy on the host



### Unintended Data Leakage

**Logging**

开发者应谨慎避免公开暴露 **debugging 信息**，因为这可能导致敏感数据 leak。推荐使用工具 [**pidcat**](https://github.com/JakeWharton/pidcat) 和 `adb logcat` 监控应用日志，以识别并保护敏感信息。**Pidcat** 因其易用性和可读性而更受欢迎。

> [!WARNING]
> 请注意，从 **Android 4.0 之后的版本** 起，**应用只能访问自身的日志**。因此应用无法访问其他应用的日志。\
> 无论如何，仍然建议 **不要记录敏感信息**。

**Copy/Paste Buffer Caching**

Android 的 **剪贴板（clipboard）框架** 支持应用间的复制粘贴功能，但存在风险：**其他应用** 可以访问剪贴板，可能泄露敏感数据。对应用中敏感部分（如信用卡信息）应禁用复制/粘贴功能以防止数据泄露。

**Crash Logs**

如果应用 **崩溃** 并保存了日志，这些日志会帮助攻击者，尤其是在应用无法被逆向时。为降低风险，应避免在崩溃时记录敏感信息；如果必须通过网络发送日志，确保通过 SSL 通道传输。

作为 pentester，**尝试查看这些日志**。

**Analytics Data Sent To 3rd Parties**

应用通常集成诸如 Google Adsense 之类的服务，开发者的不当实现可能无意中导致敏感数据 leak。建议通过拦截应用流量检查是否有敏感信息发送到第三方服务。

### SQLite DBs

大多数应用会使用 **内部 SQLite 数据库** 存储信息。在渗透测试期间，查看创建的 **数据库**、**表名** 与 **列名** 以及存储的所有 **数据** 十分重要，因为你可能会发现 **敏感信息**（这将构成漏洞）。\
数据库通常位于 `/data/data/the.package.name/databases`，例如 `/data/data/com.mwr.example.sieve/databases`

如果数据库保存机密信息并且**加密了**，但你能在应用中**找到解密密码**，这仍然是一个 **漏洞**。

使用 `.tables` 枚举表，使用 `.schema <table_name>` 枚举表的列。

### Drozer (Exploit Activities, Content Providers and Services)

来自 [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf)：**Drozer** 允许你 **以 Android 应用的身份行事** 并与其他应用交互。它可以执行 **已安装应用能做的任何事**，例如利用 Android 的进程间通信（IPC）机制并与底层操作系统交互。\
Drozer 是一个有用的工具，可用于 **利用 exported activities、exported services 和 Content Providers**，你将在下面的章节中学习到这些内容。

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
还要记住，activity 的代码在 **`onCreate`** 方法中开始执行。

**Authorisation bypass**

当一个 Activity 被 exported 时，你可以从外部应用调用其界面。因此，如果一个包含 **敏感信息** 的 activity 被 **exported**，你可能会 **bypass** 认证机制并访问该界面。

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

你也可以通过 adb 启动一个 exported activity：

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**注意**: MobSF 会检测将 _**singleTask/singleInstance**_ 作为活动的 `android:launchMode` 使用为恶意，但根据 [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750)，显然这仅在较旧版本（API 版本 < 21）上危险。

> [!TIP]
> 注意，an authorisation bypass 并不总是一个漏洞，是否构成漏洞取决于 bypass 的工作方式以及暴露了哪些信息。

**敏感信息泄露**

**Activities 也可以返回结果**。如果你能找到一个 exported 且未受保护的 activity 调用 **`setResult`** 方法并 **返回敏感信息**，则存在敏感信息泄露。

#### Tapjacking

如果未防护 tapjacking，你可以滥用已导出的 activity 让 **用户执行意外操作**。更多关于 [**what is Tapjacking follow the link**](#tapjacking)。

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers 基本上用于 **共享数据**。如果一个应用有可用的 content providers，你可能能够从中 **提取敏感** 数据。也有必要测试可能的 **SQL injections** 和 **Path Traversals**，因为它们可能存在漏洞。

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
请记住，Service 的动作在方法 `onStartCommand` 中开始。

Service 基本上是能够 **接收数据**、**处理** 并 **（可能）返回** 响应的组件。因此，如果一个应用导出了某些 services，你应该 **检查** 其 **代码** 以了解其行为，并进行 **动态测试** 以提取机密信息、绕过认证措施等...\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
请记住，Broadcast Receiver 的动作在方法 `onReceive` 中开始。

Broadcast receiver 会等待某类消息。根据接收器处理消息的方式，它可能存在漏洞。\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

你可以手动查找 deep links，使用像 MobSF 这样的工具或像 [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py) 这样的脚本。\
你可以使用 **adb** 或 **浏览器** 打开声明的 **scheme**：
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_注意，你可以**省略包名**，移动设备会自动调用应该打开该链接的应用。_
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**代码执行**

为了找到 **将在 App 中执行的代码**，前往由 deeplink 调用的 activity 并搜索函数 **`onNewIntent`**。

![](<../../images/image (436) (1) (1) (1).png>)

**敏感信息**

每次发现 deep link 时，请检查 **它是否未通过 URL 参数接收敏感数据（例如密码）**，因为任何其他应用都可能 **冒充该 deep link 并窃取这些数据！**

**路径中的参数**

你 **还必须检查是否有任何 deep link 在 URL 路径中使用参数**，例如：`https://api.example.com/v1/users/{username}`，在这种情况下，你可以通过访问类似 `example://app/users?username=../../unwanted-endpoint%3fparam=value` 的路径来强制进行路径遍历。\
请注意，如果你在应用内找到了正确的 endpoints，你可能能够导致 **Open Redirect**（如果路径的一部分被用作域名）、**account takeover**（如果你能在没有 CSRF token 的情况下修改用户详情且 vuln endpoint 使用了正确的方法）以及其他任何漏洞。更多 [info about this here](http://dphoeniixx.com/2020/12/13-2/)。

**More examples**

一个关于 links（_/.well-known/assetlinks.json_）的 [interesting bug bounty report](https://hackerone.com/reports/855618)。

### 传输层检查和验证失败

- **Certificates are not always inspected properly** by Android applications。此类应用常常忽略警告并接受自签名证书，或在某些情况下回退到使用 HTTP 连接。
- **Negotiations during the SSL/TLS handshake are sometimes weak**，使用不安全的 cipher suites。这一弱点使连接容易受到 man-in-the-middle (MITM) 攻击，允许攻击者解密数据。
- **Leakage of private information** 是一种风险：当应用使用安全通道进行认证，但随后在其他事务中通过非安全通道通信时，这种做法无法保护会话 cookie 或用户详情等敏感数据，容易被恶意方拦截。

#### Certificate Verification

我们将重点关注 **certificate verification**。必须验证服务器证书的完整性以增强安全性。これは关键，因为不安全的 TLS 配置以及通过未加密通道传输敏感数据会带来重大风险。有关验证服务器证书和修复漏洞的详细步骤，[**this resource**](https://manifestsecurity.com/android-application-security-part-10/) 提供了全面的指导。

#### SSL Pinning

SSL Pinning 是一种安全措施，应用将服务器的证书与存储在应用内的已知副本进行核验。该方法对于防止 MITM 攻击至关重要。强烈建议对处理敏感信息的应用实施 SSL Pinning。

#### Traffic Inspection

要检查 HTTP 流量，必须 **安装代理工具的证书**（例如 Burp）。如果不安装该证书，代理可能无法查看加密流量。有关安装自定义 CA 证书的指南，[**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine)。

针对 **API Level 24 and above** 的应用需要修改 Network Security Config 以接受代理的 CA 证书。这一步对于检查加密流量至关重要。有关修改 Network Security Config 的说明，请参阅 [**refer to this tutorial**](make-apk-accept-ca-certificate.md)。

如果使用 **Flutter**，需要遵循 [**this page**](flutter.md) 中的说明。因为仅将证书添加到系统存储并不能奏效，Flutter 有自己的有效 CA 列表。

#### 静态检测 SSL/TLS pinning

在尝试运行时绕过之前，先快速映射 APK 中强制 pinning 的位置。静态发现可以帮助你规划 hooks/patches 并集中在正确的代码路径上。

Tool: SSLPinDetect
- 开源静态分析工具，将 APK 反编译为 Smali（通过 apktool），并扫描针对 SSL/TLS pinning 实现的精选正则模式。
- 报告每个匹配项的精确文件路径、行号和代码片段。
- 覆盖常见框架和自定义代码路径：OkHttp CertificatePinner、自定义 javax.net.ssl.X509TrustManager.checkServerTrusted、使用自定义 TrustManagers/KeyManagers 的 SSLContext.init，以及 Network Security Config XML 中的 pins。

安装
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
使用
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
示例模式规则 (JSON)
使用或扩展签名以检测专有/自定义 pinning 样式。你可以加载自己的 JSON 并进行大规模扫描。
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
说明与提示
- 在大型应用上使用多线程和 memory-mapped I/O 进行快速扫描；预编译的 regex 可减少开销/误报。
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- 下一步要分类的典型检测目标：
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Declarative pins in res/xml network security config and manifest references
- 使用匹配到的位置来规划 Frida hooks、静态补丁或配置审查，然后再进行动态测试。



#### Bypassing SSL Pinning

当实现了 SSL Pinning 时，绕过它以检查 HTTPS 流量就变得必要。为此有多种可用方法：

- Automatically **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). The best pro of this option, is that you won't need root to bypass the SSL Pinning, but you will need to delete the application and reinstall the new one, and this won't always work.
- You could use **Frida** (discussed below) to bypass this protection. Here you have a guide to use Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- You can also try to **automatically bypass SSL Pinning** using [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- You can also try to **automatically bypass SSL Pinning** using **MobSF dynamic analysis** (explained below)
- If you still think that there is some traffic that you aren't capturing you can try to **forward the traffic to burp using iptables**. Read this blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Looking for Common Web Vulnerabilities

还应在应用内搜索常见的 web 漏洞。关于识别和缓解这些漏洞的详细信息超出了本摘要的范围，但在其他资料中有详尽覆盖。

### Frida

[Frida](https://www.frida.re) is a dynamic instrumentation toolkit for developers, reverse-engineers, and security researchers.\
**You can access running application and hook methods on run time to change the behaviour, change values, extract values, run different code...**\
如果你想 pentest Android applications 你需要知道如何使用 Frida。

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Some "GUI" for actions with Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- You can find some Awesome Frida scripts here: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Try to bypass anti-debugging / anti-frida mechanisms loading Frida as in indicated in [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

检查应用是否在内存中存储了不应存储的敏感信息，例如密码或助记词。

Using [**Fridump3**](https://github.com/rootbsd/fridump3) you can dump the memory of the app with:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
这会把内存转储到 ./dump 文件夹，在那里你可以用 grep 搜索，比如：
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Keystore 中的敏感数据**

在 Android 中，Keystore 是存放敏感数据的最佳位置，然而在获得足够权限的情况下，仍然**可能被访问**。

由于应用往往在此处以**明文形式存储敏感数据**，因此在进行 pentests 时应以 root 用户或拥有设备物理访问权限的身份检查这一点，以防该数据被窃取。

即使应用将数据存储在 Keystore 中，这些数据也应被加密。

要访问 Keystore 中的数据，你可以使用这个 Frida 脚本： [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

使用下面的 Frida 脚本，可能能够 **bypass fingerprint authentication**，Android 应用可能会执行该操作以 **保护某些敏感区域：**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **后台图像**

当你将应用置于后台时，Android 会存储**应用的快照**，因此当它恢复到前台时，会先加载该图像，使得应用看起来启动更快。

然而，如果该快照包含 **敏感信息**，有权限访问该快照的人可能会 **窃取这些信息**（注意访问需要 root）。

这些快照通常存储在： **`/data/system_ce/0/snapshots`**

Android 提供了一种方法，可以通过将布局参数设置为 **FLAG_SECURE 来防止截图**。使用该 flag 后，窗口内容将被视为受保护，从而防止出现在截图中或在非安全显示设备上被查看。
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

该工具可以在动态分析期间帮助你管理不同的工具： [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

开发者经常创建代理组件（例如 activities、services 和 broadcast receivers）来处理这些 Intents，并将它们传递给诸如 `startActivity(...)` 或 `sendBroadcast(...)` 之类的方法，这可能很危险。

危险在于攻击者可通过误导这些 Intents 来触发非 exported 的应用组件或访问敏感的 content providers。一个显著的例子是 `WebView` 组件通过 `Intent.parseUri(...)` 将 URL 转换为 `Intent` 对象并执行它们，可能导致恶意的 Intent 注入。

### 重要要点

- **Intent Injection** 类似于 web 中的 Open Redirect 问题。
- 利用方式包括将 `Intent` 对象作为 extras 传递，这些 Intent 可能被重定向以执行不安全的操作。
- 它可能会将非导出的组件和 content providers 暴露给攻击者。
- `WebView` 将 URL 转换为 `Intent` 的行为可能促成意外的操作。

### Android Client Side Injections and others

这些漏洞你可能在 Web 上已经见过。在 Android 应用中需要特别注意这些漏洞：

- **SQL Injection:** 在处理动态查询或 Content-Providers 时，确保使用参数化查询。
- **JavaScript Injection (XSS):** 确认对任意 WebViews 已禁用 JavaScript 和 Plugin 支持（默认禁用）。 [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** 应禁用 WebViews 对文件系统的访问（默认启用） - `(webview.getSettings().setAllowFileAccess(false);)`。 [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**：在若干情况下，当 android 应用结束会话时，cookie 未被撤销，甚至可能被保存到磁盘
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## 自动化分析

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**静态分析**

![](<../../images/image (866).png>)

**对应用的漏洞评估** 使用一个友好的基于 web 的前端。你也可以执行动态分析（但需要准备好环境）。
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### 使用 MobSF 的辅助动态分析

**MobSF** 在 **Android** 平台上对于 **动态分析** 也非常有帮助，但在这种情况下你需要在宿主机上安装 MobSF 和 **genymotion**（在 VM 或 Docker 中不起作用）。_注意：你需要先在 genymotion 中**启动一个 VM**，然后再启动 MobSF._\
**MobSF dynamic analyser** 可以：

- **Dump application data**（URLs、日志、剪贴板、你拍的截图、通过 "**Exported Activity Tester**" 拍的截图、电子邮件、SQLite 数据库、XML 文件和其他创建的文件）。除了截图外，所有这些都是自动完成的；截图需要你在想要截图时手动按下，或者按下 "**Exported Activity Tester**" 来获取所有 exported activities 的截图。
- 捕获 **HTTPS traffic**
- 使用 **Frida** 获取 **runtime** **information**

从 android **versions > 5** 开始，它会**自动启动 Frida**并会设置全局 **proxy** 来**捕获**流量。它只会捕获来自被测试应用的流量。

**Frida**

默认情况下，它还会使用一些 Frida Scripts 来**绕过 SSL pinning**、**root detection** 和 **debugger detection**，并**监控有趣的 API**。\
MobSF 还可以**调用 exported activities**，抓取它们的**screenshots**并将其**保存**到报告中。

要**开始**动态测试，按绿色按钮：“**Start Instrumentation**”。按“**Frida Live Logs**” 查看 Frida 脚本生成的日志，按“**Live API Monitor**” 查看对被 hook 方法的所有调用、传入参数和返回值（在按下 "Start Instrumentation" 后会出现）。\
MobSF 还允许你加载自己的 **Frida scripts**（要将你的 Frida 脚本结果发送到 MobSF，请使用函数 `send()`）。它也包含**若干预写脚本**可供加载（你可以在 `MobSF/DynamicAnalyzer/tools/frida_scripts/others/` 中添加更多），只需**选择**它们，按“**Load**”然后按“**Start Instrumentation**”（你将能在“**Frida Live Logs**”中看到这些脚本的日志）。

![](<../../images/image (419).png>)

此外，你还有一些辅助的 Frida 功能：

- **Enumerate Loaded Classes**：打印所有已加载的类
- **Capture Strings**：在使用应用时打印所有捕获到的字符串（噪声很大）
- **Capture String Comparisons**：非常有用。它会**显示被比较的两条字符串**以及比较结果是 True 还是 False。
- **Enumerate Class Methods**：输入类名（例如 "java.io.File"），它会打印该类的所有方法。
- **Search Class Pattern**：按模式搜索类
- **Trace Class Methods**：**Trace** 整个类（查看该类所有方法的输入和输出）。记住默认情况下 MobSF 会追踪若干有趣的 Android API 方法。

一旦你选择了要使用的辅助模块，你需要按“**Start Intrumentation**”，你会在“**Frida Live Logs**”中看到所有输出。

**Shell**

MobSF 在动态分析页面底部还提供了一个带有一些 **adb** 命令、**MobSF commands** 和常用 **shell** **commands** 的 shell。一些有趣的命令：
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP tools**

当 HTTP 流量被捕获时，你可以在底部的 "**HTTP(S) Traffic**" 按钮看到原始的捕获流量视图，或在绿色按钮 "**Start HTTPTools**" 中看到更友好的视图。从第二个选项，你可以将**捕获的请求** **发送**到像 Burp 或 Owasp ZAP 这样的 **proxies**。\
要做到这一点，_开启 Burp -->_ _关闭 Intercept --> 在 MobSB HTTPTools 中选择请求_ --> 点击 "**Send to Fuzzer**" --> _选择代理地址_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080))。

完成 MobSF 的动态分析后，你可以点击 "**Start Web API Fuzzer**" 来对 http 请求进行 **fuzz** 并查找漏洞。

> [!TIP]
> 在使用 MobSF 完成动态分析后，代理设置可能会被错误配置，且无法通过 GUI 修复。你可以通过运行以下命令修复代理设置：
>
> ```
> adb shell settings put global http_proxy :0
> ```

### 使用 Inspeckage 的辅助动态分析

你可以从 [**Inspeckage**](https://github.com/ac-pm/Inspeckage) 获取此工具。\
该工具将使用一些 **Hooks**，在你进行**动态分析**时告知你**应用中正在发生的事情**。

### [Yaazhini](https://www.vegabird.com/yaazhini/)

这是一个用于通过 GUI 执行静态分析的**优秀工具**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

该工具旨在查找多种**与安全相关的 Android 应用漏洞**，无论是在**源代码**还是**打包的 APK**中。该工具还能够**创建可部署的 "Proof-of-Concept" APK**和 **ADB commands**，以利用某些发现的漏洞（如暴露的 activities、intents、tapjacking 等）。与 Drozer 一样，无需对测试设备进行 root。
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- 显示所有提取的文件以便参考
- 自动将 APK 文件反编译为 Java 和 Smali 格式
- 分析 AndroidManifest.xml 以查找常见漏洞和行为
- 对源代码进行静态分析以查找常见漏洞和行为
- 设备信息
- 以及更多功能
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER 是一个命令行应用程序，可在 Windows、MacOS X 和 Linux 上使用，用于分析 _.apk_ 文件以查找漏洞。它通过解压 APKs 并应用一系列规则来检测这些漏洞。

所有规则集中在 `rules.json` 文件中，每家公司或测试人员都可以创建自己的规则来分析所需内容。

从 [download page](https://superanalyzer.rocks/download.html) 下载最新的二进制文件。
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn 是一个 crossplatform 工具，帮助开发者、bugbounty hunters 和 ethical hackers 对移动应用执行 [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis)。

其概念是将你的移动应用文件 (an .apk or .ipa file) 拖放到 StaCoAn 应用上，它会为你生成一个可视且便携的报告。你可以调整设置和 wordlists 来获得定制化体验。

下载[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework 是一个 Android 漏洞分析系统，帮助 developers 或 hackers 在 Android 应用中发现潜在的安全漏洞。\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** 是一个工具，主要用于检测并提醒用户 Android 应用程序可能的恶意行为。

检测是通过对应用的 Dalvik bytecode（以 **Smali** 表示）进行 **static analysis**，并使用 [`androguard`](https://github.com/androguard/androguard) 库来完成的。

该工具会查找 **common behavior of "bad" applications**，例如：Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** 是一个 **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework。它将常用的移动应用逆向工程和分析工具整合在一起，以协助针对 OWASP mobile security threats 对移动应用进行测试。其目标是让移动应用开发者和安全专业人员更容易、更友好地完成这项工作。

它能够：

- 使用不同工具提取 Java 和 Smali 代码
- 使用以下工具分析 APK: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- 使用 regexps 从 APK 中提取敏感信息。
- 分析 Manifest。
- 使用以下工具分析找到的域名: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- 通过 [apk-deguard.com](http://www.apk-deguard.com) 对 APK 进行反混淆

### Koodous

用于检测 malware: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

请注意，取决于用于混淆代码的服务和配置，敏感信息可能会被混淆，也可能不会被混淆。

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. It is able to optimize bytecode as well as detect and remove unused instructions. ProGuard is free software and is distributed under the GNU General Public License, version 2.

ProGuard 随 Android SDK 一起分发，并在以 release 模式构建应用时运行。

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Last time we checked, the Dexguard mode of operation was:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

你可以将混淆后的 APK 上传到他们的平台。

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

It is a **generic android deobfuscator.** Simplify **virtually executes an app** to understand its behavior and then **tries to optimize the code** so it behaves identically but is easier for a human to understand. Each optimization type is simple and generic, so it doesn't matter what the specific type of obfuscation is used.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD gives you information about **how an APK was made**. It identifies many **compilers**, **packers**, **obfuscators**, and other weird stuff. It's [_PEiD_](https://www.aldeid.com/wiki/PEiD) for Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b 是一个基于 ubuntu-mate 的 Android 安全虚拟机，包含来自不同安全极客和研究人员的最新框架、教程和用于逆向工程与 malware analysis 的实验。

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) It is a great list of resources
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)

## Yet to try

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
