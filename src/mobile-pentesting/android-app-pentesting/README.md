# Εφαρμογές Android Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Βασικά για Εφαρμογές Android

Συνιστάται ανεπιφύλακτα να ξεκινήσετε διαβάζοντας αυτή τη σελίδα για να μάθετε σχετικά με τα **πιο σημαντικά σημεία που σχετίζονται με την ασφάλεια του Android και τα πιο επικίνδυνα components σε μια εφαρμογή Android**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Αυτό είναι το κύριο εργαλείο που χρειάζεστε για να συνδεθείτε με μια συσκευή Android (εξομοιωμένη ή φυσική).\
**ADB** επιτρέπει τον έλεγχο συσκευών είτε μέσω **USB** είτε μέσω **Network** από υπολογιστή. Αυτό το εργαλείο επιτρέπει την **αντιγραφή** αρχείων και στις δύο κατευθύνσεις, την **εγκατάσταση** και **απεγκατάσταση** εφαρμογών, την **εκτέλεση** εντολών shell, τη **δημιουργία αντιγράφων ασφαλείας** δεδομένων, την **ανάγνωση** logs, μεταξύ άλλων λειτουργιών.

Ρίξτε μια ματιά στην ακόλουθη λίστα με [**ADB Commands**](adb-commands.md) για να μάθετε πώς να χρησιμοποιείτε το adb.

## Smali

Μερικές φορές είναι ενδιαφέρον να **τροποποιήσετε τον κώδικα της εφαρμογής** για να αποκτήσετε πρόσβαση σε **κρυφές πληροφορίες** (π.χ. καλά obfuscated passwords ή flags). Σε αυτές τις περιπτώσεις, μπορεί να είναι χρήσιμο να decompile το APK, να τροποποιήσετε τον κώδικα και να το recompile.\
[**Σε αυτό το tutorial** μπορείτε να **μάθετε πώς να decompile ένα APK, να τροποποιείτε Smali code και να recompile το APK** με τη νέα λειτουργικότητα](smali-changes.md). Αυτό μπορεί να είναι πολύ χρήσιμο ως **εναλλακτική για διάφορα tests κατά τη διάρκεια της dynamic analysis** που θα παρουσιαστούν. Επομένως, **κρατήστε πάντα υπόψη αυτή την πιθανότητα**.

## Άλλα ενδιαφέροντα κόλπα

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Play Integrity attestation spoofing (SafetyNet replacement)](play-integrity-attestation-bypass.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [Android IME / InputMethodService Abuse (Malicious Keyboards)](inputmethodservice-ime-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **Λήψη APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Εξαγωγή APK από τη συσκευή:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Συγχώνευσε όλα τα splits και τα base apks με [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Επιθέσεις σε Android Enterprise & Work Profile

{{#ref}}
android-enterprise-work-profile-bypass.md
{{#endref}}

## Μελέτες Περίπτωσης & Ευπάθειες


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

{{#ref}}
abusing-android-media-pipelines-image-parsers.md
{{#endref}}

{{#ref}}
../../binary-exploitation/linux-kernel-exploitation/arm64-static-linear-map-kaslr-bypass.md
{{#endref}}

## Στατική Ανάλυση

Πρώτα απ' όλα, για την ανάλυση ενός APK θα πρέπει να **ρίξετε μια ματιά στον Java κώδικα** χρησιμοποιώντας έναν decompiler.\
Παρακαλώ, [**διαβάστε εδώ για να βρείτε πληροφορίες σχετικά με διαφορετικούς διαθέσιμους decompilers**](apk-decompilers.md).

### Αναζήτηση ενδιαφέρουσας πληροφορίας

Απλά ρίχνοντας μια ματιά στα **strings** του APK μπορείτε να αναζητήσετε **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** και οτιδήποτε ενδιαφέρον... ψάξτε ακόμη και για code execution **backdoors** ή authentication backdoors (hardcoded admin credentials στην εφαρμογή).

**Firebase**

Δώστε ιδιαίτερη προσοχή στα **Firebase URLs** και ελέγξτε αν είναι κακώς διαμορφωμένα. [Περισσότερες πληροφορίες για το τι είναι το Firebase και πώς να το εκμεταλλευτείτε εδώ.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Βασική κατανόηση της εφαρμογής - Manifest.xml, strings.xml

Η **εξέταση των αρχείων _Manifest.xml_ και _strings.xml_ μιας εφαρμογής μπορεί να αποκαλύψει πιθανές ευπάθειες ασφάλειας**. Αυτά τα αρχεία μπορούν να προσεγγιστούν με χρήση decompilers ή με την αλλαγή της επέκτασης του APK σε .zip και στη συνέχεια αποσυμπίεση.

**Ευπάθειες** που εντοπίζονται από το **Manifest.xml** περιλαμβάνουν:

- **Debuggable Applications**: Οι εφαρμογές που έχουν οριστεί ως debuggable (`debuggable="true"`) στο αρχείο _Manifest.xml_ αποτελούν κίνδυνο καθώς επιτρέπουν συνδέσεις που μπορούν να οδηγήσουν σε εκμετάλλευση. Για περαιτέρω κατανόηση σχετικά με το πώς να εκμεταλλευτείτε debuggable applications, ανατρέξτε σε ένα tutorial για την εύρεση και εκμετάλλευση debuggable εφαρμογών σε μια συσκευή.
- **Backup Settings**: Το attribute `android:allowBackup="false"` θα πρέπει να ορίζεται ρητά για εφαρμογές που χειρίζονται ευαίσθητες πληροφορίες ώστε να αποτρέπονται μη εξουσιοδοτημένα backups δεδομένων μέσω adb, ειδικά όταν το usb debugging είναι ενεργοποιημένο.
- **Network Security**: Προσαρμοσμένες ρυθμίσεις network security (`android:networkSecurityConfig="@xml/network_security_config"`) στο _res/xml/_ μπορούν να καθορίζουν λεπτομέρειες ασφάλειας όπως certificate pins και ρυθμίσεις HTTP traffic. Ένα παράδειγμα είναι η επιτρεψη HTTP traffic για συγκεκριμένους domains.
- **Exported Activities and Services**: Η αναγνώριση exported activities και services στο manifest μπορεί να αναδείξει components που ενδέχεται να καταχραστούν. Περαιτέρω ανάλυση κατά τη διάρκεια dynamic testing μπορεί να αποκαλύψει πώς να εκμεταλλευτείτε αυτά τα components.
- **Content Providers and FileProviders**: Εκτεθειμένοι content providers μπορούν να επιτρέψουν μη εξουσιοδοτημένη πρόσβαση ή τροποποίηση δεδομένων. Η διαμόρφωση των FileProviders πρέπει επίσης να ελεγχθεί προσεκτικά.
- **Broadcast Receivers and URL Schemes**: Αυτά τα components μπορούν να χρησιμοποιηθούν για εκμετάλλευση, με ιδιαίτερη προσοχή στον τρόπο διαχείρισης των URL schemes για ευπάθειες εισόδου.
- **SDK Versions**: Τα attributes `minSdkVersion`, `targetSDKVersion`, και `maxSdkVersion` υποδεικνύουν τις υποστηριζόμενες εκδόσεις Android, τονίζοντας τη σημασία να μην υποστηρίζονται ξεπερασμένες, ευάλωτες εκδόσεις Android για λόγους ασφάλειας.

Από το αρχείο **strings.xml**, μπορούν να εντοπιστούν ευαίσθητες πληροφορίες όπως API keys, custom schemas, και άλλες σημειώσεις του developer, υπογραμμίζοντας την ανάγκη προσεκτικής αναθεώρησης αυτών των πόρων.

### Tapjacking

**Tapjacking** είναι μια επίθεση όπου μια **κακόβουλη εφαρμογή** ξεκινάει και **τοποθετείται πάνω από μια εφαρμογή-θύμα**. Μόλις καλύψει εμφανώς την εφαρμογή-θύμα, το UI της είναι σχεδιασμένο έτσι ώστε να ξεγελάει τον χρήστη να αλληλεπιδρά μαζί της, ενώ παράλληλα μεταβιβάζει την αλληλεπίδραση στην εφαρμογή-θύμα.\
Στο πραγματικό αποτέλεσμα, αυτό **τυφλώνει τον χρήστη ώστε να μην γνωρίζει ότι εκτελεί πραγματικά ενέργειες στην εφαρμογή-θύμα**.

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Μια **activity** με το **`launchMode`** ορισμένο σε **`singleTask` χωρίς να έχει οριστεί `taskAffinity`** είναι ευάλωτη σε task Hijacking. Αυτό σημαίνει ότι μια **εφαρμογή** μπορεί να εγκατασταθεί και αν εκκινηθεί πριν από την πραγματική εφαρμογή θα μπορούσε να **υποκλέψει το task της πραγματικής εφαρμογής** (ώστε ο χρήστης να αλληλεπιδρά με την **κακόβουλη εφαρμογή νομίζοντας ότι χρησιμοποιεί την πραγματική**).

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Μη ασφαλής αποθήκευση δεδομένων

**Εσωτερική Αποθήκευση**

Στο Android, τα αρχεία **αποθηκεύονται** σε **εσωτερική** αποθήκευση και έχουν σχεδιαστεί ώστε να είναι προσβάσιμα αποκλειστικά από την **εφαρμογή** που τα **έχει δημιουργήσει**. Αυτό το μέτρο ασφάλειας **επιβάλλεται** από το Android operating system και γενικά επαρκεί για τις ανάγκες ασφάλειας των περισσότερων εφαρμογών. Ωστόσο, οι developers μερικές φορές χρησιμοποιούν modes όπως `MODE_WORLD_READABLE` και `MODE_WORLD_WRITABLE` για να **επιτρέπουν** την **κοινή χρήση** αρχείων μεταξύ διαφορετικών εφαρμογών. Αυτές οι modes όμως **δεν περιορίζουν την πρόσβαση** σε αυτά τα αρχεία από άλλες εφαρμογές, συμπεριλαμβανομένων ενδεχομένως κακόβουλων.

1. **Static Analysis:**
- **Ελέγξτε** προσεκτικά τη χρήση των `MODE_WORLD_READABLE` και `MODE_WORLD_WRITABLE`. Αυτές οι modes **μπορεί να εκθέσουν** αρχεία σε **μη επιθυμητή ή μη εξουσιοδοτημένη πρόσβαση**.
2. **Dynamic Analysis:**
- **Επαληθεύστε** τα **permissions** που τίθενται στα αρχεία που δημιουργεί η εφαρμογή. Συγκεκριμένα, **ελέγξτε** αν κάποια αρχεία έχουν **ρυθμιστεί ώστε να είναι αναγνώσιμα ή εγγράψιμα παγκοσμίως**. Αυτό μπορεί να αποτελέσει σημαντικό κίνδυνο ασφαλείας, καθώς θα επέτρεπε σε **οποιαδήποτε εφαρμογή** εγκατεστημένη στη συσκευή, ανεξαρτήτως προέλευσης ή προθέσεων, να **διαβάσει ή να τροποποιήσει** αυτά τα αρχεία.

**Εξωτερική Αποθήκευση**

Όταν χειρίζεστε αρχεία σε **εξωτερική αποθήκευση**, όπως SD Cards, πρέπει να ληφθούν ορισμένες προφυλάξεις:

1. **Προσβασιμότητα**:
- Τα αρχεία στην εξωτερική αποθήκευση είναι **προσβάσιμα και εγγράψιμα παγκοσμίως**. Αυτό σημαίνει ότι οποιαδήποτε εφαρμογή ή χρήστης μπορεί να έχει πρόσβαση σε αυτά τα αρχεία.
2. **Θέματα Ασφαλείας**:
- Δεδομένης της ευκολίας πρόσβασης, συνιστάται **να μην αποθηκεύετε ευαίσθητες πληροφορίες** στην εξωτερική αποθήκευση.
- Η εξωτερική αποθήκευση μπορεί να αφαιρεθεί ή να προσπελαστεί από οποιαδήποτε εφαρμογή, καθιστώντας την λιγότερο ασφαλή.
3. **Χειρισμός Δεδομένων από Εξωτερική Αποθήκευση**:
- Πάντα **εκτελέστε έλεγχο εισόδου (input validation)** στα δεδομένα που ανακτώνται από εξωτερική αποθήκευση. Αυτό είναι κρίσιμο επειδή τα δεδομένα προέρχονται από μη αξιόπιστη πηγή.
- Η αποθήκευση εκτελέσιμων ή αρχείων κλάσεων στην εξωτερική αποθήκευση για dynamic loading δεν συνιστάται έντονα.
- Αν η εφαρμογή σας πρέπει να ανακτήσει εκτελέσιμα αρχεία από εξωτερική αποθήκευση, βεβαιωθείτε ότι αυτά τα αρχεία είναι υπογεγραμμένα και κρυπτογραφικά επαληθευμένα πριν φορτωθούν δυναμικά. Αυτό το βήμα είναι ζωτικής σημασίας για τη διατήρηση της ασφάλειας της εφαρμογής.

External storage can be **accessed** in `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> Από το Android 4.4 (**API 17**) και μετά, η SD card έχει δομή φακέλων που **περιορίζει την πρόσβαση μιας εφαρμογής στον κατάλογο που είναι συγκεκριμένος για εκείνη την εφαρμογή**. Αυτό αποτρέπει κακόβουλες εφαρμογές από το να αποκτήσουν δικαιώματα ανάγνωσης ή εγγραφής στα αρχεία άλλης εφαρμογής.

**Ευαίσθητα δεδομένα αποθηκευμένα σε απλό κείμενο**

- **Shared preferences**: Το Android επιτρέπει σε κάθε εφαρμογή να αποθηκεύει εύκολα xml αρχεία στη διαδρομή `/data/data/<packagename>/shared_prefs/` και μερικές φορές είναι δυνατό να βρεθούν ευαίσθητες πληροφορίες σε απλό κείμενο σε αυτόν τον φάκελο.
- **Databases**: Το Android επιτρέπει σε κάθε εφαρμογή να αποθηκεύει εύκολα sqlite databases στη διαδρομή `/data/data/<packagename>/databases/` και μερικές φορές είναι δυνατό να βρεθούν ευαίσθητες πληροφορίες σε απλό κείμενο σε αυτόν τον φάκελο.

### Σπασμένο TLS

**Accept All Certificates**

Για κάποιο λόγο μερικές φορές οι developers αποδέχονται όλα τα certificates ακόμα και αν, για παράδειγμα, το hostname δεν ταιριάζει με γραμμές κώδικα όπως η ακόλουθη:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Ελαττωματική κρυπτογραφία

**Κακές διαδικασίες διαχείρισης κλειδιών**

Κάποιοι προγραμματιστές αποθηκεύουν ευαίσθητα δεδομένα στο local storage και τα κρυπτογραφούν με ένα key ενσωματωμένο/προβλέψιμο στον κώδικα. Αυτό δεν θα έπρεπε να γίνεται, καθώς κάποιο reversing μπορεί να επιτρέψει σε επιτιθέμενους να εξάγουν τις εμπιστευτικές πληροφορίες.

**Χρήση μη ασφαλών και/ή παρωχημένων αλγορίθμων**

Οι προγραμματιστές δεν θα πρέπει να χρησιμοποιούν **deprecated algorithms** για να κάνουν authorisation **checks**, **store** ή **send** δεδομένα. Μερικοί από αυτούς τους αλγορίθμους είναι: RC4, MD4, MD5, SHA1... Αν χρησιμοποιούνται **hashes** για να αποθηκεύουν κωδικούς (π.χ.), πρέπει να χρησιμοποιούνται hashes ανθεκτικά σε brute-force μαζί με salt.

### Άλλοι έλεγχοι

- Συνιστάται να **obfuscate το APK** ώστε να δυσκολέψετε την εργασία των reverse engineers.
- Αν η εφαρμογή είναι ευαίσθητη (π.χ. τραπεζικές εφαρμογές), θα πρέπει να εκτελεί τους δικούς της ελέγχους για να διαπιστώσει αν το mobile είναι rooted και να ενεργεί ανάλογα.
- Αν η εφαρμογή είναι ευαίσθητη (π.χ. τραπεζικές εφαρμογές), θα πρέπει να ελέγχει αν χρησιμοποιείται emulator.
- Αν η εφαρμογή είναι ευαίσθητη (π.χ. τραπεζικές εφαρμογές), θα πρέπει να **ελέγχει την ακεραιότητα της πριν την εκτέλεση** για να διαπιστώσει αν έχει τροποποιηθεί.
- Χρησιμοποιήστε [**APKiD**](https://github.com/rednaga/APKiD) για να δείτε ποιος compiler/packer/obfuscator χρησιμοποιήθηκε για την κατασκευή του APK

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

Το εργαλείο [**mariana-trench**](https://github.com/facebook/mariana-trench) είναι ικανό να εντοπίζει **vulnerabilities** σαρώνοντας τον **code** της εφαρμογής. Αυτό το εργαλείο περιέχει μια σειρά από **known sources** (που υποδεικνύουν στο εργαλείο τα **μέρη** όπου το **input** ελέγχεται από τον χρήστη), **sinks** (που υποδεικνύουν στο εργαλείο **επικίνδυνα** **σημεία** όπου κακόβουλο user input μπορεί να προκαλέσει ζημιά) και **rules**. Αυτοί οι κανόνες υποδεικνύουν τον **συνδυασμό** **sources-sinks** που δηλώνει μια ευπάθεια.

Με αυτή τη γνώση, **mariana-trench θα επανεξετάσει τον κώδικα και θα βρει πιθανές ευπάθειες σε αυτόν**.

### Secrets leaked

An application may contain secrets (API keys, passwords, hidden urls, subdomains...) inside of it that you might be able to discover. You could us a tool such as [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Άλλες ενδιαφέρουσες λειτουργίες

- **Εκτέλεση κώδικα**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Αποστολή SMS**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** δηλωμένες ως `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)
- Εκτέλεση native κώδικα in-memory μέσω JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Άλλα κόλπα**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Δυναμική Ανάλυση

> Πρώτα απ' όλα, χρειάζεστε ένα περιβάλλον όπου μπορείτε να εγκαταστήσετε την εφαρμογή και όλο το απαραίτητο περιβάλλον (Burp CA cert, Drozer and Frida κυρίως). Επομένως, μια rooted συσκευή (emulated ή όχι) συνιστάται ιδιαίτερα.

### Online Dynamic analysis

Μπορείτε να δημιουργήσετε ένα **free account** στο: [https://appetize.io/](https://appetize.io). Αυτή η πλατφόρμα σας επιτρέπει να **upload** και να **execute** APKs, οπότε είναι χρήσιμη για να δείτε πώς συμπεριφέρεται ένα apk.

Μπορείτε ακόμη να **δειτε τα logs της εφαρμογής σας** στο web και να συνδεθείτε μέσω **adb**.

![](<../../images/image (831).png>)

Ευχαριστώντας την ADB σύνδεση μπορείτε να χρησιμοποιήσετε **Drozer** και **Frida** μέσα στους emulators.

### Τοπική Δυναμική Ανάλυση

#### Χρήση emulator

- [**Android Studio**](https://developer.android.com/studio) (Μπορείτε να δημιουργήσετε **x86** και **arm** συσκευές, και σύμφωνα με [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** versions **support ARM libraries** without needing an slow arm emulator).
- Μάθετε πώς να το ρυθμίσετε σε αυτή τη σελίδα:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, χρειάζεται να δημιουργήσετε λογαριασμό. _Συνιστάται να **κατεβάσετε** την έκδοση **ΜΕ**_ _**VirtualBox** για να αποφύγετε πιθανά σφάλματα._)
- [**Nox**](https://es.bignox.com) (Δωρεάν, αλλά δεν υποστηρίζει Frida ή Drozer).

> [!TIP]
> Κατά τη δημιουργία ενός νέου emulator σε οποιαδήποτε πλατφόρμα θυμηθείτε ότι όσο μεγαλύτερη είναι η οθόνη τόσο πιο αργά θα τρέχει ο emulator. Οπότε επιλέξτε μικρές οθόνες αν είναι δυνατό.

Για να **install google services** (όπως AppStore) σε Genymotion πρέπει να κάνετε κλικ στο κόκκινο κουμπί που επισημαίνεται στην παρακάτω εικόνα:

![](<../../images/image (277).png>)

Επίσης, σημειώστε ότι στις **ρυθμίσεις του Android VM στο Genymotion** μπορείτε να επιλέξετε **Bridge Network mode** (αυτό θα είναι χρήσιμο αν θα συνδέεστε στο Android VM από ένα διαφορετικό VM με τα εργαλεία).

#### Χρήση φυσικής συσκευής

Πρέπει να ενεργοποιήσετε τις επιλογές **debugging** και θα ήταν καλό αν μπορείτε να την **root**:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Once you have installed the application, the first thing you should do is to try it and investigate what does it do, how does it work and get comfortable with it.\
> Προτείνω να **εκτελέσετε αυτήν την αρχική δυναμική ανάλυση χρησιμοποιώντας MobSF dynamic analysis + pidcat**, έτσι θα είμαστε σε θέση να **μάθουμε πώς λειτουργεί η εφαρμογή** ενώ το MobSF **captures** πολλά **interesting** **data** που μπορείτε να αναθεωρήσετε αργότερα.

Magisk/Zygisk quick notes (recommended on Pixel devices)
- Patch boot.img with the Magisk app and flash via fastboot to get systemless root
- Enable Zygisk + DenyList for root hiding; consider LSPosed/Shamiko when stronger hiding is required
- Keep original boot.img to recover from OTA updates; re-patch after each OTA
- For screen mirroring, use scrcpy on the host



### Unintended Data Leakage

**Logging**

Οι προγραμματιστές πρέπει να είναι προσεκτικοί να μην εκθέτουν **debugging information** δημόσια, καθώς αυτό μπορεί να οδηγήσει σε ευαίσθητες data leaks. Τα εργαλεία [**pidcat**](https://github.com/JakeWharton/pidcat) και `adb logcat` συνιστώνται για την παρακολούθηση των logs της εφαρμογής ώστε να εντοπίζονται και να προστατεύονται ευαίσθητες πληροφορίες. **Pidcat** προτιμάται για την ευκολία χρήσης και την ευανάγνωστη μορφή.

> [!WARNING]
> Σημειώστε ότι από **μεταγενέστερες εκδόσεις του Android μεγαλύτερες από 4.0**, **οι εφαρμογές μπορούν να έχουν πρόσβαση μόνο στα δικά τους logs**. Έτσι οι εφαρμογές δεν μπορούν να έχουν πρόσβαση στα logs άλλων εφαρμογών.\
> Παρ' όλα αυτά, εξακολουθεί να συνιστάται να **μην καταγράφετε ευαίσθητες πληροφορίες**.

**Copy/Paste Buffer Caching**

Το πλαίσιο βάσει **clipboard** του Android παρέχει λειτουργία αντιγραφής-επικόλλησης στις εφαρμογές, αλλά παρουσιάζει κίνδυνο καθώς **άλλες εφαρμογές** μπορούν να **προσπελάσουν** το clipboard, ενδεχομένως εκθέτοντας ευαίσθητα δεδομένα. Είναι κρίσιμο να **απενεργοποιείτε τις λειτουργίες αντιγραφής/επικόλλησης** για ευαίσθητες ενότητες μιας εφαρμογής, όπως στοιχεία πιστωτικών καρτών, για να αποτρέψετε data leaks.

**Crash Logs**

Αν μια εφαρμογή **crashes** και **αποθηκεύει logs**, αυτά τα logs μπορούν να βοηθήσουν επιτιθέμενους, ειδικά όταν η εφαρμογή δεν μπορεί να αναστραφεί (reverse-engineered). Για να μειώσετε αυτόν τον κίνδυνο, αποφύγετε το logging κατά τα crashes, και αν τα logs πρέπει να μεταδοθούν μέσω δικτύου, βεβαιωθείτε ότι αποστέλλονται μέσω SSL channel για ασφάλεια.

Ως pentester, **δοκιμάστε να ρίξετε μια ματιά σε αυτά τα logs**.

**Analytics Data Sent To 3rd Parties**

Οι εφαρμογές συχνά ενσωματώνουν υπηρεσίες όπως το Google Adsense, οι οποίες μπορεί ακούσια να **leak** ευαίσθητα δεδομένα λόγω λανθασμένης υλοποίησης από τους developers. Για να εντοπίσετε πιθανές διαρροές δεδομένων, είναι συνετό να **intercept την κίνηση της εφαρμογής** και να ελέγξετε για τυχόν ευαίσθητες πληροφορίες που στέλνονται σε τρίτους.

### Βάσεις δεδομένων SQLite

Οι περισσότερες εφαρμογές θα χρησιμοποιήσουν **εσωτερικές βάσεις δεδομένων SQLite** για να αποθηκεύουν πληροφορίες. Κατά τη διάρκεια του pentest ρίξτε μια **ματιά** στις **βάσεις δεδομένων** που δημιουργούνται, τα ονόματα των **πινάκων** και των **στηλών** και όλα τα **αποθηκευμένα δεδομένα**, γιατί μπορεί να βρείτε **ευαίσθητες πληροφορίες** (οι οποίες θα θεωρηθούν ευπάθεια).\
Οι βάσεις δεδομένων θα πρέπει να βρίσκονται σε `/data/data/the.package.name/databases` όπως `/data/data/com.mwr.example.sieve/databases`

Αν η βάση δεδομένων αποθηκεύει εμπιστευτικές πληροφορίες και είναι **encrypted** αλλά μπορείτε να **βρείτε** τον **κωδικό** μέσα στην εφαρμογή, είναι ακόμη μια **ευπάθεια**.

Απαριθμήστε τους πίνακες χρησιμοποιώντας `.tables` και απαριθμήστε τις στήλες των πινάκων με `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer is s useful tool to **exploit exported activities, exported services and Content Providers** as you will learn in the following sections.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Also remember that the code of an activity starts in the **`onCreate`** method.

**Authorisation bypass**

When an Activity is exported you can invoke its screen from an external app. Therefore, if an activity with **sensitive information** is **exported** you could **bypass** the **authentication** mechanisms **to access it.**

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

You can also start an exported activity from adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**ΣΗΜΕΙΩΣΗ**: Το MobSF θα θεωρήσει κακόβουλη τη χρήση του _**singleTask/singleInstance**_ ως `android:launchMode` σε μια activity, αλλά λόγω [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), προφανώς αυτό είναι επικίνδυνο μόνο σε παλιές εκδόσεις (API versions < 21).

> [!TIP]
> Σημειώστε ότι ένα authorisation bypass δεν είναι πάντα ευπάθεια — εξαρτάται από το πώς λειτουργεί το bypass και ποιες πληροφορίες εκτίθενται.

**Sensitive information leakage**

Οι Activities μπορούν επίσης να επιστρέψουν αποτελέσματα. Εάν καταφέρετε να βρείτε μια exported και μη προστατευμένη activity που καλεί τη μέθοδο **`setResult`** και **επιστρέφει ευαίσθητες πληροφορίες**, υπάρχει διαρροή ευαίσθητων πληροφοριών.

#### Tapjacking

Εάν το Tapjacking δεν αποτρέπεται, μπορείτε να καταχραστείτε την exported activity για να κάνετε τον **χρήστη να εκτελέσει μη αναμενόμενες ενέργειες**. Για περισσότερες πληροφορίες σχετικά με [**τι είναι το Tapjacking ακολουθήστε τον σύνδεσμο**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Διαβάστε αυτό αν θέλετε να ανανεώσετε τι είναι ένα Content Provider.**](android-applications-basics.md#content-provider)\
Οι content providers χρησιμοποιούνται βασικά για να **μοιράζουν δεδομένα**. Εάν μια εφαρμογή διαθέτει content providers μπορεί να είστε σε θέση να **εξάγετε ευαίσθητα** δεδομένα από αυτούς. Είναι επίσης ενδιαφέρον να δοκιμάσετε πιθανές **SQL injections** και **Path Traversals**, καθώς μπορεί να είναι ευάλωτοι.

[**Μάθετε πώς να εκμεταλλευτείτε Content Providers με Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Διαβάστε αυτό αν θέλετε να ανανεώσετε τι είναι ένα Service.**](android-applications-basics.md#services)\
Θυμηθείτε ότι οι ενέργειες ενός Service ξεκινούν στη μέθοδο `onStartCommand`.

Ένα Service είναι ουσιαστικά κάτι που **μπορεί να λάβει δεδομένα**, να τα **επεξεργαστεί** και να **επιστρέψει** (ή όχι) μια απάντηση. Επομένως, αν μια εφαρμογή εξάγει κάποια services θα πρέπει να **ελέγξετε** τον **κώδικα** για να καταλάβετε τι κάνει και να το **δοκιμάσετε** **δυναμικά** για εξαγωγή εμπιστευτικών πληροφοριών, παράκαμψη μέτρων authentication...\
[**Μάθετε πώς να εκμεταλλευτείτε Services με Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Διαβάστε αυτό αν θέλετε να ανανεώσετε τι είναι ένα Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Θυμηθείτε ότι οι ενέργειες ενός Broadcast Receiver ξεκινούν στη μέθοδο `onReceive`.

Ένας broadcast receiver θα περιμένει έναν τύπο μηνύματος. Ανάλογα με το πώς ο receiver χειρίζεται το μήνυμα, μπορεί να είναι ευάλωτος.\
[**Μάθετε πώς να εκμεταλλευτείτε Broadcast Receivers με Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Μπορείτε να αναζητήσετε deep links χειροκίνητα, χρησιμοποιώντας εργαλεία όπως το MobSF ή scripts όπως [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Μπορείτε να **ανοίξετε** ένα δηλωμένο **scheme** χρησιμοποιώντας **adb** ή έναν **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Σημειώστε ότι μπορείτε να **παραλείψετε το όνομα πακέτου** και το κινητό θα καλέσει αυτόματα την εφαρμογή που πρέπει να ανοίξει αυτόν τον σύνδεσμο._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Κώδικας που εκτελείται**

Για να βρείτε τον **κώδικα που θα εκτελεστεί στην App**, πηγαίνετε στην activity που καλείται από το deeplink και ψάξτε τη συνάρτηση **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Ευαίσθητες πληροφορίες**

Κάθε φορά που βρίσκετε ένα deep link ελέγξτε ότι δεν δέχεται ευαίσθητα δεδομένα (όπως passwords) μέσω URL παραμέτρων, γιατί οποιαδήποτε άλλη εφαρμογή θα μπορούσε να impersonate το deep link και να κλέψει αυτά τα δεδομένα!

**Παράμετροι στο path**

Πρέπει επίσης να ελέγξετε αν κάποιο deep link χρησιμοποιεί παράμετρο μέσα στο path του URL όπως: `https://api.example.com/v1/users/{username}` , σε αυτή την περίπτωση μπορείτε να αναγκάσετε ένα path traversal προσπελάζοντας κάτι σαν: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Σημειώστε ότι αν βρείτε τα σωστά endpoints μέσα στην εφαρμογή μπορεί να καταφέρετε να προκαλέσετε ένα **Open Redirect** (αν μέρος του path χρησιμοποιείται ως domain name), **account takeover** (αν μπορείτε να τροποποιήσετε users details χωρίς CSRF token και το vuln endpoint χρησιμοποίησε τη σωστή μέθοδο) και οποιαδήποτε άλλη vuln. Περισσότερες [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**Περισσότερα παραδείγματα**

Ένα [interesting bug bounty report](https://hackerone.com/reports/855618) σχετικά με links (_/.well-known/assetlinks.json_).

### Transport Layer Inspection and Verification Failures

- **Certificates are not always inspected properly** by Android applications. Είναι συνηθισμένο αυτές οι εφαρμογές να αγνοούν προειδοποιήσεις και να αποδέχονται self-signed certificates ή, σε ορισμένες περιπτώσεις, να επιστρέφουν στη χρήση HTTP connections.
- **Negotiations during the SSL/TLS handshake are sometimes weak**, χρησιμοποιώντας insecure cipher suites. Αυτή η ευπάθεια καθιστά τη σύνδεση ευάλωτη σε man-in-the-middle (MITM) attacks, επιτρέποντας σε επιτιθέμενους να αποκρυπτογραφήσουν τα δεδομένα.
- **Leakage of private information** is a risk when applications authenticate using secure channels but then communicate over non-secure channels for other transactions. Αυτή η προσέγγιση αποτυγχάνει να προστατέψει ευαίσθητα δεδομένα, όπως session cookies ή user details, από υποκλοπή από κακόβουλους φορείς.

#### Certificate Verification

Θα επικεντρωθούμε στην **certificate verification**. Η ακεραιότητα του server's certificate πρέπει να επαληθεύεται για να ενισχυθεί η ασφάλεια. Αυτό είναι κρίσιμο γιατί insecure TLS configurations και η μεταφορά ευαίσθητων δεδομένων μέσω μη κρυπτογραφημένων καναλιών μπορούν να προκαλέσουν σημαντικούς κινδύνους. Για λεπτομερή βήματα σχετικά με την επαλήθευση server certificates και την αντιμετώπιση ευπαθειών, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) παρέχει πλήρη καθοδήγηση.

#### SSL Pinning

SSL Pinning είναι ένα μέτρο ασφαλείας όπου η εφαρμογή επαληθεύει το server's certificate έναντι ενός γνωστού αντιγράφου που αποθηκεύεται μέσα στην εφαρμογή. Αυτή η μέθοδος είναι απαραίτητη για την πρόληψη MITM επιθέσεων. Συνίσταται έντονα η εφαρμογή SSL Pinning για εφαρμογές που χειρίζονται ευαίσθητες πληροφορίες.

#### Traffic Inspection

Για να επιθεωρήσετε HTTP traffic, είναι απαραίτητο να **εγκαταστήσετε το proxy tool's certificate** (π.χ., Burp). Χωρίς την εγκατάσταση αυτού του certificate, το κρυπτογραφημένο traffic μπορεί να μην είναι ορατό μέσω του proxy. Για οδηγό σχετικά με την εγκατάσταση ενός custom CA certificate, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Εφαρμογές που στοχεύουν **API Level 24 and above** απαιτούν τροποποιήσεις στο Network Security Config για να αποδεχτούν το proxy's CA certificate. Αυτό το βήμα είναι κρίσιμο για την επιθεώρηση κρυπτογραφημένου traffic. Για οδηγίες σχετικά με την τροποποίηση του Network Security Config, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

Αν χρησιμοποιείται **Flutter** πρέπει να ακολουθήσετε τις οδηγίες στην [**this page**](flutter.md). Αυτό συμβαίνει επειδή, απλά προσθέτοντας το certificate στο store δεν θα λειτουργήσει καθώς το Flutter έχει τη δική του λίστα έγκυρων CAs.

#### Static detection of SSL/TLS pinning

Πριν επιχειρήσετε runtime bypasses, εντοπίστε γρήγορα πού εφαρμόζεται το pinning στο APK. Η στατική ανίχνευση βοηθά στο να σχεδιάσετε hooks/patches και να εστιάσετε στα σωστά code paths.

Tool: SSLPinDetect
- Open-source static-analysis utility που decompiles το APK σε Smali (via apktool) και σαρώσει για curated regex patterns των SSL/TLS pinning implementations.
- Reports exact file path, line number, and a code snippet for each match.
- Covers common frameworks and custom code paths: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

Εγκατάσταση
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Χρήση
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Παραδείγματα κανόνων προτύπων (JSON)
Μπορείς να χρησιμοποιήσεις ή να επεκτείνεις signatures για να εντοπίσεις proprietary/custom pinning styles. Μπορείς να φορτώσεις το δικό σου JSON και να εκτελέσεις scan σε μεγάλη κλίμακα.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Σημειώσεις και συμβουλές
- Γρήγορη σάρωση σε μεγάλες εφαρμογές μέσω multi-threading και memory-mapped I/O· προ-compiled regex μειώνει το overhead/false positives.
- Συλλογή patterns: https://github.com/aancw/smali-sslpin-patterns
- Τυπικοί στόχοι ανίχνευσης για περαιτέρω αξιολόγηση:
- OkHttp: χρήση CertificatePinner, setCertificatePinner, αναφορές πακέτου okhttp3/okhttp
- Προσαρμοσμένοι TrustManagers: javax.net.ssl.X509TrustManager, overrides του checkServerTrusted
- Προσαρμοσμένα SSL contexts: SSLContext.getInstance + SSLContext.init με custom managers
- Δηλωτικά pins στο res/xml network security config και αναφορές στο manifest
- Χρησιμοποιήστε τις αντιστοιχισμένες τοποθεσίες για να σχεδιάσετε Frida hooks, static patches ή reviews του config πριν από dynamic testing.



#### Παράκαμψη του SSL Pinning

Όταν το SSL Pinning έχει υλοποιηθεί, η παράκαμψή του γίνεται απαραίτητη για την επιθεώρηση της κίνησης HTTPS. Υπάρχουν διάφορες μέθοδοι διαθέσιμες για αυτόν τον σκοπό:

- Αυτόματα **τροποποιήστε** το **apk** για να **παρακάμψετε** το SSLPinning με [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Το μεγαλύτερο πλεονέκτημα αυτής της επιλογής είναι ότι δεν θα χρειαστείτε root για να παρακάμψετε το SSL Pinning, αλλά θα χρειαστεί να διαγράψετε την εφαρμογή και να εγκαταστήσετε τη νέα, και αυτό δεν θα λειτουργεί πάντα.
- Μπορείτε να χρησιμοποιήσετε **Frida** (συζητείται παρακάτω) για να παρακάμψετε αυτή την προστασία. Εδώ υπάρχει ένας οδηγός για χρήση Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Μπορείτε επίσης να δοκιμάσετε να **παρακάμψετε αυτόματα το SSL Pinning** χρησιμοποιώντας [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Μπορείτε επίσης να δοκιμάσετε να **παρακάμψετε αυτόματα το SSL Pinning** χρησιμοποιώντας **MobSF dynamic analysis** (εξηγείται παρακάτω)
- Αν νομίζετε ότι υπάρχει ακόμα κίνηση που δεν καταγράφετε, δοκιμάστε να **προωθήσετε την κίνηση στο burp χρησιμοποιώντας iptables**. Διαβάστε αυτό το άρθρο: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Αναζήτηση Συνηθισμένων Web Ευπαθειών

Είναι σημαντικό επίσης να αναζητήσετε κοινές web ευπάθειες μέσα στην εφαρμογή. Λεπτομερείς πληροφορίες για την ανίχνευση και την αντιμετώπιση αυτών των ευπαθειών υπερβαίνουν το πλαίσιο αυτής της περίληψης αλλά καλύπτονται εκτενώς αλλού.

### Frida

[Frida](https://www.frida.re) είναι ένα dynamic instrumentation toolkit για developers, reverse-engineers, και security researchers.\
**Μπορείτε να αποκτήσετε πρόσβαση στην τρέχουσα εφαρμογή και να κάνετε hook σε μεθόδους κατά το runtime για να αλλάξετε τη συμπεριφορά, να αλλάξετε τιμές, να εξάγετε τιμές, να εκτελέσετε διαφορετικό κώδικα...**\
Αν θέλετε να κάνετε pentest σε Android εφαρμογές πρέπει να ξέρετε πώς να χρησιμοποιείτε Frida.

- Μάθετε πώς να χρησιμοποιείτε Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Κάποια "GUI" για ενέργειες με Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection είναι εξαιρετικό για να αυτοματοποιήσει τη χρήση του Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Μπορείτε να βρείτε κάποια Awesome Frida scripts εδώ: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Προσπαθήστε να παρακάμψετε anti-debugging / anti-frida μηχανισμούς φορτώνοντας το Frida όπως υποδεικνύεται στο [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (εργαλείο [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

Ελέγξτε αν η εφαρμογή αποθηκεύει ευαίσθητες πληροφορίες στη μνήμη που δεν θα έπρεπε, όπως passwords ή mnemonics.

Χρησιμοποιώντας [**Fridump3**](https://github.com/rootbsd/fridump3) μπορείτε να κάνετε dump τη μνήμη της εφαρμογής με:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Αυτό θα κάνει dump της μνήμης στο φάκελο ./dump, και εκεί μπορείς να κάνεις grep με κάτι σαν:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Ευαίσθητα δεδομένα στο Keystore**

Στο Android το Keystore είναι το καλύτερο μέρος για αποθήκευση ευαίσθητων δεδομένων, όμως με αρκετά δικαιώματα εξακολουθεί να είναι **δυνατό να αποκτηθεί πρόσβαση σε αυτό**. Καθώς οι εφαρμογές τείνουν να αποθηκεύουν εδώ **ευαίσθητα δεδομένα σε απλό κείμενο**, οι pentests πρέπει να το ελέγχουν ως root user, γιατί κάποιος με φυσική πρόσβαση στη συσκευή μπορεί να καταφέρει να κλέψει αυτά τα δεδομένα.

Ακόμα και αν μια εφαρμογή αποθήκευσε δεδομένα στο keystore, τα δεδομένα πρέπει να είναι κρυπτογραφημένα.

Για να αποκτήσετε πρόσβαση στα δεδομένα μέσα στο keystore μπορείτε να χρησιμοποιήσετε αυτό το Frida script: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Χρησιμοποιώντας το παρακάτω Frida script, μπορεί να είναι δυνατό να **bypass fingerprint authentication** που ενδέχεται να εκτελούν εφαρμογές Android προκειμένου να **protect certain sensitive areas:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Εικόνες φόντου**

Όταν βάζετε μία εφαρμογή στο παρασκήνιο, το Android αποθηκεύει ένα **snapshot of the application** έτσι ώστε όταν ανακτηθεί στο foreground να αρχίζει να φορτώνει την εικόνα πριν από την εφαρμογή, ώστε να φαίνεται ότι η εφαρμογή φορτώθηκε πιο γρήγορα.

Ωστόσο, αν αυτό το snapshot περιέχει **ευαίσθητες πληροφορίες**, κάποιος με πρόσβαση στο snapshot μπορεί να **αποσπάσει αυτές τις πληροφορίες** (σημείωση: χρειάζεστε root για να το προσπελάσετε).

Τα snapshots συνήθως αποθηκεύονται στο: **`/data/system_ce/0/snapshots`**

Το Android παρέχει έναν τρόπο για **να αποτραπεί η καταγραφή screenshots ρυθμίζοντας την παράμετρο διάταξης FLAG_SECURE**. Με τη χρήση αυτής της σημαίας, τα περιεχόμενα του παραθύρου θεωρούνται ασφαλή, εμποδίζοντας την εμφάνισή τους σε screenshots ή την προβολή τους σε μη ασφαλείς οθόνες.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

This tool could help you managing different tools during the dynamic analysis: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Οι προγραμματιστές συχνά δημιουργούν proxy components όπως activities, services και broadcast receivers που διαχειρίζονται αυτά τα Intents και τα περνάνε σε μεθόδους όπως `startActivity(...)` ή `sendBroadcast(...)`, κάτι που μπορεί να είναι επικίνδυνο.

Ο κίνδυνος έγκειται στο ότι επιτρέπει σε attackers να ενεργοποιήσουν μη-exported components της εφαρμογής ή να έχουν πρόσβαση σε ευαίσθητους content providers, παραπλανούντας αυτά τα Intents. Ένα αξιοσημείωτο παράδειγμα είναι το `WebView` component που μετατρέπει URLs σε αντικείμενα `Intent` μέσω της `Intent.parseUri(...)` και στη συνέχεια τα εκτελεί, ενδεχομένως οδηγώντας σε malicious Intent injections.

### Essential Takeaways

- **Intent Injection** είναι παρόμοιο με το Open Redirect στο web.
- Οι εκμεταλλεύσεις περιλαμβάνουν τη μεταβίβαση αντικειμένων `Intent` ως extras, τα οποία μπορούν να αναδρομολογηθούν για να εκτελέσουν μη ασφαλείς ενέργειες.
- Μπορεί να εκθέσει μη-exported components και content providers σε επιτιθέμενους.
- Η μετατροπή URL σε `Intent` από το `WebView` μπορεί να διευκολύνει ανεπιθύμητες ενέργειες.

### Android Client Side Injections and others

Πιθανότατα γνωρίζετε αυτό το είδος ευπαθειών από το Web. Πρέπει να είστε ιδιαίτερα προσεκτικοί με αυτές τις ευπάθειες σε μια Android εφαρμογή:

- **SQL Injection:** Όταν χειρίζεστε δυναμικά queries ή Content-Providers, βεβαιωθείτε ότι χρησιμοποιείτε parameterized queries.
- **JavaScript Injection (XSS):** Ελέγξτε ότι η υποστήριξη JavaScript και Plugin είναι απενεργοποιημένη για οποιοδήποτε WebView (απενεργοποιημένη από προεπιλογή). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** Τα WebViews θα πρέπει να έχουν πρόσβαση στο file system απενεργοποιημένη (ενεργοποιημένη από προεπιλογή) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: Σε πολλές περιπτώσεις, όταν η android εφαρμογή τερματίζει τη συνεδρία, το cookie δεν ανακαλείται ή ακόμα μπορεί να αποθηκευτεί στο δίσκο
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Στατική ανάλυση**

![](<../../images/image (866).png>)

**Αξιολόγηση ευπαθειών της εφαρμογής** χρησιμοποιώντας ένα ωραίο web-based frontend. Μπορείτε επίσης να πραγματοποιήσετε dynamic analysis (αλλά χρειάζεται να προετοιμάσετε το περιβάλλον).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Βοηθούμενη δυναμική ανάλυση με MobSF

**MobSF** μπορεί επίσης να είναι πολύ χρήσιμο για **dynamic analysis** σε **Android**, αλλά σε αυτή την περίπτωση θα χρειαστεί να εγκαταστήσετε το MobSF και το **genymotion** στο host σας (a VM or Docker won't work). _Note: You need to **start first a VM in genymotion** and **then MobSF.**._\
Ο **MobSF dynamic analyser** μπορεί:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). All of this is done automatically except for the screenshots, you need to press when you want a screenshot or you need to press "**Exported Activity Tester**" to obtain screenshots of all the exported activities.
- Καταγραφή **HTTPS traffic**
- Χρήση του **Frida** για απόκτηση **runtime** πληροφοριών

Από Android **versions > 5**, θα ξεκινήσει αυτόματα το **Frida** και θα ορίσει τις global **proxy** ρυθμίσεις για να καταγράψει την κίνηση. Θα καταγράψει μόνο την κίνηση από την εφαρμογή που δοκιμάζεται.

**Frida**

Από προεπιλογή, θα χρησιμοποιήσει επίσης μερικά Frida Scripts για να **bypass SSL pinning**, **root detection** και **debugger detection** και για να **monitor interesting APIs**.\
Το MobSF μπορεί επίσης να **invoke exported activities**, να τραβήξει **screenshots** τους και να τα **save** για την αναφορά.

Για να **start** τη δυναμική δοκιμή πατήστε το πράσινο κουμπί: "**Start Instrumentation**". Πατήστε τα "**Frida Live Logs**" για να δείτε τα logs που παράγουν τα Frida scripts και το "**Live API Monitor**" για να δείτε όλες τις invocations σε hooked methods, τα ορίσματα που πέρασαν και τις επιστρεφόμενες τιμές (αυτό θα εμφανιστεί μετά το πάτημα του "Start Instrumentation").\
Το MobSF επίσης σας επιτρέπει να φορτώσετε τα δικά σας **Frida scripts** (για να στείλετε τα αποτελέσματα των Frida scripts σας στο MobSF χρησιμοποιήστε τη συνάρτηση `send()`). Έχει επίσης **several pre-written scripts** που μπορείτε να φορτώσετε (μπορείτε να προσθέσετε περισσότερα στο `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), απλώς **select them**, πατήστε "**Load**" και πατήστε "**Start Instrumentation**" (θα μπορείτε να δείτε τα logs αυτών των scripts μέσα στα "**Frida Live Logs**").

![](<../../images/image (419).png>)

Επιπλέον, έχετε μερικές βοηθητικές λειτουργίες του Frida:

- **Enumerate Loaded Classes**: Θα εμφανίσει όλες τις loaded classes
- **Capture Strings**: Θα εμφανίζει όλες τις captured strings κατά τη χρήση της εφαρμογής (πολύ noisy)
- **Capture String Comparisons**: Μπορεί να είναι πολύ χρήσιμο. Θα **show the 2 strings being compared** και αν το αποτέλεσμα ήταν True ή False.
- **Enumerate Class Methods**: Βάλτε το όνομα της κλάσης (όπως "java.io.File") και θα εμφανίσει όλες τις μεθόδους της κλάσης.
- **Search Class Pattern**: Αναζητά κλάσεις με βάση pattern
- **Trace Class Methods**: **Trace** ολόκληρη μια class (βλέπει inputs και outputs όλων των methods της κλάσης). Θυμηθείτε ότι από προεπιλογή το MobSF traces αρκετές ενδιαφέρουσες Android Api methods.

Μόλις έχετε επιλέξει το auxiliary module που θέλετε να χρησιμοποιήσετε πρέπει να πατήσετε "**Start Intrumentation**" και θα δείτε όλα τα outputs στα "**Frida Live Logs**".

**Shell**

Το MobSF παρέχει επίσης ένα shell με μερικές **adb** εντολές, **MobSF commands**, και κοινές **shell** **commands** στο κάτω μέρος της σελίδας δυναμικής ανάλυσης. Κάποιες ενδιαφέρουσες εντολές:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**Εργαλεία HTTP**

Όταν η κίνηση HTTP καταγράφεται μπορείτε να δείτε μια άσχημη προβολή της καταγεγραμμένης κίνησης στο κουμπί "**HTTP(S) Traffic**" ή μια πιο όμορφη προβολή στο πράσινο κουμπί "**Start HTTPTools**". Από τη δεύτερη επιλογή, μπορείτε να **send** τις **captured requests** σε **proxies** όπως το Burp ή το Owasp ZAP.\
Για να το κάνετε, _ενεργοποιήστε το Burp -->_ _απενεργοποιήστε το Intercept --> στο MobSB HTTPTools επιλέξτε το request_ --> πατήστε "**Send to Fuzzer**" --> _επιλέξτε τη διεύθυνση proxy_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Αφού ολοκληρώσετε τη dynamic analysis με το MobSF μπορείτε να πατήσετε στο "**Start Web API Fuzzer**" για να **fuzz http requests** και να αναζητήσετε ευπάθειες.

> [!TIP]
> Μετά την εκτέλεση μιας dynamic analysis με το MobSF, οι ρυθμίσεις proxy ενδέχεται να είναι λανθασμένες και δεν θα μπορείτε να τις διορθώσετε από το GUI. Μπορείτε να διορθώσετε τις ρυθμίσεις proxy κάνοντας:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Βοηθούμενη Dynamic Analysis με Inspeckage

Μπορείτε να κατεβάσετε το εργαλείο από [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Το εργαλείο αυτό θα χρησιμοποιήσει κάποια **Hooks** για να σας δείξει τι συμβαίνει στην εφαρμογή ενώ εκτελείτε **dynamic analysis**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Αυτό είναι ένα **εξαιρετικό εργαλείο για να πραγματοποιήσετε static analysis με GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Το εργαλείο αυτό έχει σχεδιαστεί για να εντοπίζει διάφορες **security related Android application vulnerabilities**, είτε στον **source code** είτε σε **packaged APKs**. Το εργαλείο είναι επίσης **capable of creating a "Proof-of-Concept" deployable APK** και **ADB commands**, για να εκμεταλλευτεί κάποιες από τις ανιχνευθείσες ευπάθειες (Exposed activities, intents, tapjacking...). Όπως και με το Drozer, δεν χρειάζεται να κάνετε root στη συσκευή δοκιμής.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Εμφανίζει όλα τα εξαγόμενα αρχεία για εύκολη αναφορά
- Αποσυναρμολογεί αυτόματα αρχεία APK σε μορφή Java και Smali
- Αναλύει το AndroidManifest.xml για κοινές ευπάθειες και συμπεριφορά
- Στατική ανάλυση πηγαίου κώδικα για κοινές ευπάθειες και συμπεριφορά
- Πληροφορίες συσκευής
- και άλλα
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

Το SUPER είναι μια εφαρμογή command-line που μπορεί να χρησιμοποιηθεί σε Windows, MacOS X και Linux, και αναλύει αρχεία _.apk_ ψάχνοντας για ευπάθειες. Το κάνει αποσυμπιέζοντας APKs και εφαρμόζοντας μια σειρά κανόνων για να εντοπίσει αυτές τις ευπάθειες.

Όλοι οι κανόνες βρίσκονται στο αρχείο `rules.json`, και κάθε εταιρεία ή tester μπορεί να δημιουργήσει δικούς του κανόνες για να αναλύσει ό,τι χρειάζεται.

Κατεβάστε τα πιο πρόσφατα binaries από τη [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

Το StaCoAn είναι ένα **crossplatform** εργαλείο που βοηθά προγραμματιστές, bugbounty hunters και ethical hackers να εκτελούν [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) σε εφαρμογές για κινητά.

Η ιδέα είναι ότι σύρετε και αφήνετε το αρχείο της εφαρμογής σας (ένα .apk ή .ipa αρχείο) στην εφαρμογή StaCoAn και θα δημιουργήσει μια οπτική και φορητή αναφορά για εσάς. Μπορείτε να τροποποιήσετε τις ρυθμίσεις και τα wordlists για να αποκτήσετε μια προσαρμοσμένη εμπειρία.

Κατεβάστε[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

Το AndroBugs Framework είναι ένα σύστημα ανάλυσης ευπαθειών για Android που βοηθά προγραμματιστές ή hackers να εντοπίσουν πιθανές ευπάθειες ασφαλείας σε εφαρμογές Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** είναι ένα εργαλείο του οποίου ο κύριος στόχος είναι να εντοπίζει και να προειδοποιεί τον χρήστη για πιθανές κακόβουλες συμπεριφορές που αναπτύσσει μια εφαρμογή Android.

Η ανίχνευση πραγματοποιείται με τη **static analysis** του Dalvik bytecode της εφαρμογής, το οποίο αναπαρίσταται ως **Smali**, χρησιμοποιώντας τη βιβλιοθήκη [`androguard`](https://github.com/androguard/androguard).

Αυτό το εργαλείο αναζητά **συνηθισμένες συμπεριφορές των "κακών" εφαρμογών** όπως: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** είναι ένα πλαίσιο για Mobile Application Reverse engineering και Analysis. Είναι ένα εργαλείο που συγκεντρώνει συνήθως χρησιμοποιούμενα εργαλεία για reverse engineering και ανάλυση εφαρμογών mobile, για να βοηθήσει στον έλεγχο εφαρμογών κινητών απέναντι στις OWASP mobile security απειλές. Στόχος του είναι να κάνει αυτή την εργασία πιο εύκολη και φιλική προς τους developers εφαρμογών mobile και τους επαγγελματίες ασφάλειας.

Μπορεί να:

- Εξάγει Java και Smali κώδικα χρησιμοποιώντας διάφορα εργαλεία
- Αναλύει APKs χρησιμοποιώντας: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Εξάγει ιδιωτικές πληροφορίες από το APK χρησιμοποιώντας regexps.
- Αναλύει το Manifest.
- Αναλύει τα εντοπισμένα domains χρησιμοποιώντας: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) και [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate το APK μέσω [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Χρήσιμο για την ανίχνευση malware: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Σημειώστε ότι ανάλογα με την υπηρεσία και τη διαμόρφωση που χρησιμοποιείτε για να obfuscate τον κώδικα, τα secrets μπορεί να εμφανιστούν obfuscated ή όχι.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

Από τη [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** είναι ένα open source command-line εργαλείο που συρρικνώνει, βελτιστοποιεί και obfuscates Java κώδικα. Είναι ικανό να βελτιστοποιεί bytecode καθώς και να εντοπίζει και να αφαιρεί αχρησιμοποίητες εντολές. Το ProGuard είναι ελεύθερο λογισμικό και διανέμεται υπό την GNU General Public License, version 2.

Το ProGuard διανέμεται ως μέρος του Android SDK και εκτελείται κατά τη δημιουργία της εφαρμογής σε release mode.

### [DexGuard](https://www.guardsquare.com/dexguard)

Βρείτε έναν οδηγό βήμα προς βήμα για να deobfuscate το apk στο [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(Από εκείνον τον οδηγό) Την τελευταία φορά που ελέγξαμε, ο τρόπος λειτουργίας του Dexguard ήταν:

- φορτώνει ένα resource ως InputStream;
- προωθεί το αποτέλεσμα σε μια κλάση που κληρονομεί από FilterInputStream για να το αποκωδικοποιήσει;
- κάνει κάποιου είδους άχρηστη obfuscation για να σπαταλήσει λίγα λεπτά του χρόνου ενός reverser;
- προωθεί το αποκρυπτογραφημένο αποτέλεσμα σε ένα ZipInputStream για να πάρει ένα αρχείο DEX;
- τελικά φορτώνει το προκύπτον DEX ως Resource χρησιμοποιώντας τη μέθοδο `loadDex`.

### [DeGuard](http://apk-deguard.com)

**DeGuard αντιστρέφει τη διαδικασία obfuscation που εκτελούν τα Android obfuscation εργαλεία. Αυτό επιτρέπει πλήθος security αναλύσεων, συμπεριλαμβανομένης της επιθεώρησης κώδικα και της πρόβλεψης βιβλιοθηκών.**

Μπορείτε να ανεβάσετε ένα obfuscated APK στην πλατφόρμα τους.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

Αυτό είναι ένα LLM εργαλείο για να βρει πιθανές security ευπάθειες σε android apps και να deobfuscate κώδικα android app. Χρησιμοποιεί το δημόσιο API Gemini της Google.

### [Simplify](https://github.com/CalebFenton/simplify)

Είναι ένας **generic android deobfuscator.** Το Simplify **virtualmente εκτελεί μια app** για να κατανοήσει τη συμπεριφορά της και στη συνέχεια **προσπαθεί να βελτιστοποιήσει τον κώδικα** ώστε να συμπεριφέρεται ταυτόσημα αλλά να είναι πιο εύκολος για έναν άνθρωπο να τον καταλάβει. Κάθε τύπος βελτιστοποίησης είναι απλός και generic, οπότε δεν έχει σημασία ποιος συγκεκριμένος τύπος obfuscation χρησιμοποιήθηκε.

### [APKiD](https://github.com/rednaga/APKiD)

Το APKiD σας δίνει πληροφορίες για **πώς κατασκευάστηκε ένα APK**. Αναγνωρίζει πολλούς **compilers**, **packers**, **obfuscators**, και άλλα περίεργα πράγματα. Είναι το [_PEiD_](https://www.aldeid.com/wiki/PEiD) για Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b είναι μια Android security virtual machine βασισμένη σε ubuntu-mate που περιλαμβάνει μια συλλογή από τα πιο πρόσφατα frameworks, tutorials και labs από διάφορους security geeks και researchers για reverse engineering και malware analysis.

## References

- [Play Integrity API: How It Works & How to Bypass It](https://m4kr0.vercel.app/posts/play-integrity-api-how-it-works--how-to-bypass-it/)
- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Είναι μια εξαιρετική λίστα πόρων
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
