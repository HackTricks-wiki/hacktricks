# Android Applications Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android 애플리케이션 기초

이 페이지를 먼저 읽어보는 것을 강력히 권장합니다. **Android 보안과 Android 애플리케이션에서 가장 위험한 구성요소들에 관련된 가장 중요한 부분들**을 이해할 수 있습니다:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

이 도구는 에뮬레이터든 실제 장치든 Android 기기에 연결하기 위해 필요한 주요 도구입니다.\
**ADB**는 컴퓨터에서 **USB**나 **Network**를 통해 기기를 제어할 수 있게 해줍니다. 이 유틸리티는 양방향으로 파일을 **복사**하고, 앱의 **설치**와 **제거**, 셸 명령의 **실행**, 데이터의 **백업**, 로그의 **읽기** 등 다양한 기능을 제공합니다.

adb 사용법을 배우려면 다음 [**ADB Commands**](adb-commands.md) 목록을 확인하세요.

## Smali

때때로 **애플리케이션 코드를 수정**하여 **숨겨진 정보**(예: 잘 난독화된 비밀번호나 플래그)에 접근하는 것이 흥미로울 수 있습니다. 이럴 때 apk를 디컴파일하고 코드를 수정한 뒤 다시 컴파일하는 것이 유용합니다.\
[**In this tutorial** you can **learn how to decompile an APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). 이는 동적 분석 중 수행하는 몇몇 테스트의 **대안**으로 매우 유용할 수 있습니다. 따라서 항상 이 가능성을 **염두에 두세요**.

## 기타 흥미로운 팁

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **APK 다운로드**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- 기기에서 APK 추출:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- 모든 splits 및 base apks를 [APKEditor](https://github.com/REAndroid/APKEditor)로 병합:
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## 사례 연구 및 취약점


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## 정적 분석

무엇보다도, APK를 분석할 때에는 decompiler를 사용해 **Java 코드를 확인해야 합니다**.\
Please, [**read here to find information about different available decompilers**](apk-decompilers.md).

### 흥미로운 정보 찾기

APK의 **strings**만 살펴봐도 **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** 등 흥미로운 항목을 찾을 수 있습니다... 코드 실행 **backdoors**나 인증 backdoors (hardcoded admin credentials to the app) 같은 것도 확인하세요.

**Firebase**

**Firebase URLs**에 특히 주의하고 잘못 구성되어 있는지 확인하세요. [More information about whats is FIrebase and how to exploit it here.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### 애플리케이션의 기본 이해 - Manifest.xml, strings.xml

애플리케이션의 _Manifest.xml_ 및 **_strings.xml_** 파일을 검사하면 잠재적인 보안 취약점을 발견할 수 있습니다. 이 파일들은 decompiler로 접근하거나 APK 확장자를 .zip으로 바꿔 압축을 푼 다음 확인할 수 있습니다.

Manifest.xml에서 식별되는 **취약점**에는 다음이 포함됩니다:

- **Debuggable Applications**: _Manifest.xml_ 파일에서 `debuggable="true"`로 설정된 애플리케이션은 연결을 허용하여 악용될 수 있으므로 위험합니다. 디버깅 가능한 애플리케이션을 장치에서 찾고 악용하는 방법에 대한 튜토리얼을 참고하세요.
- **Backup Settings**: 민감한 정보를 다루는 애플리케이션의 경우 `android:allowBackup="false"` 속성을 명시적으로 설정하여 adb를 통한 무단 데이터 백업을 방지해야 합니다(특히 USB 디버깅이 활성화된 경우).
- **Network Security**: _res/xml/_의 사용자 정의 네트워크 보안 구성(`android:networkSecurityConfig="@xml/network_security_config"`)은 certificate pin, HTTP 트래픽 설정 등 보안 세부사항을 지정할 수 있습니다. 예를 들어 특정 도메인에 대해 HTTP 트래픽을 허용하는 설정이 있을 수 있습니다.
- **Exported Activities and Services**: 매니페스트에서 exported된 activity 및 service를 식별하면 오용될 수 있는 컴포넌트를 찾는 데 도움이 됩니다. 동적 테스트 중 추가 분석으로 이러한 컴포넌트를 악용하는 방법을 발견할 수 있습니다.
- **Content Providers and FileProviders**: 노출된 content provider는 데이터의 무단 접근 또는 변경을 허용할 수 있습니다. FileProviders의 구성도 주의 깊게 검토해야 합니다.
- **Broadcast Receivers and URL Schemes**: 이러한 컴포넌트는 악용에 사용될 수 있으므로 URL 스킴이 입력 검증 측면에서 어떻게 처리되는지 특히 주의하세요.
- **SDK Versions**: `minSdkVersion`, `targetSDKVersion`, `maxSdkVersion` 속성은 지원되는 Android 버전을 나타내며, 오래된 취약한 Android 버전을 지원하지 않는 것이 중요함을 강조합니다.

**strings.xml** 파일에서는 API keys, custom schemas, 기타 개발자 메모 같은 민감한 정보를 발견할 수 있으므로 이러한 리소스를 면밀히 검토해야 합니다.

### Tapjacking

**Tapjacking**은 악성 **애플리케이션**이 실행되어 **대상 애플리케이션 위에 자신의 UI를 배치하는** 공격입니다. 화면상으로는 대상 앱을 가리게 되며, 악성 앱의 UI는 사용자를 속여 상호작용하도록 설계되어 있지만 해당 상호작용은 대상 앱으로 전달됩니다.\
결과적으로 사용자는 자신이 실제로 대상 앱에서 동작을 수행하고 있다는 사실을 인지하지 못하게 됩니다.

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

`launchMode`가 **`singleTask`**로 설정되어 있고 `taskAffinity`가 정의되어 있지 않은 **activity**는 Task Hijacking에 취약합니다. 이는 악성 **application**이 설치되어 실제 애플리케이션보다 먼저 실행될 경우 실제 애플리케이션의 태스크를 **가로챌 수 있다**는 의미입니다(사용자는 실제 앱을 사용하는 것으로 생각하면서 **malicious application**과 상호작용하게 됩니다).

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Insecure data storage

**Internal Storage**

Android에서 내부 저장소에 저장된 파일은 생성한 앱만 접근하도록 설계되어 있습니다. 이 보안 조치는 Android 운영체제에 의해 강제되며 대부분의 애플리케이션 보안 요구사항을 충족합니다. 그러나 개발자가 `MODE_WORLD_READABLE` 및 `MODE_WORLD_WRITABLE` 같은 모드를 사용하여 앱 간 파일 공유를 허용하는 경우가 있으며, 이러한 모드는 잠재적으로 악성 앱을 포함한 다른 애플리케이션이 해당 파일에 접근하는 것을 제한하지 않습니다.

1. **Static Analysis:**
- `MODE_WORLD_READABLE` 및 `MODE_WORLD_WRITABLE` 사용 여부를 면밀히 검토하세요. 이러한 모드는 파일을 의도치 않거나 무단 접근에 노출시킬 수 있습니다.
2. **Dynamic Analysis:**
- 앱이 생성한 파일의 권한을 확인하세요. 특히 파일이 전세계적으로 읽기 또는 쓰기로 설정되어 있는지 여부를 점검하세요. 이는 장치에 설치된 어떤 애플리케이션(출처나 의도와 관계없이)이 해당 파일을 읽거나 수정할 수 있게 하므로 중대한 보안 위험이 될 수 있습니다.

**External Storage**

SD 카드와 같은 외부 저장소의 파일을 다룰 때는 다음 사항을 주의하세요:

1. **Accessibility**:
- 외부 저장소의 파일은 전역적으로 읽기/쓰기 가능합니다. 즉, 모든 애플리케이션이나 사용자가 접근할 수 있습니다.
2. **Security Concerns**:
- 접근이 쉬우므로 민감한 정보를 외부 저장소에 저장하지 않는 것이 권장됩니다.
- 외부 저장소는 제거되거나 어떤 애플리케이션에서도 접근될 수 있어 보안 수준이 낮습니다.
3. **Handling Data from External Storage**:
- 외부 저장소에서 가져온 데이터는 항상 입력 검증을 수행하세요. 외부 저장소의 데이터는 신뢰할 수 없는 소스입니다.
- 외부 저장소에 실행 파일이나 클래스 파일을 저장해 동적으로 로딩하는 것은 강력히 권장되지 않습니다.
- 애플리케이션이 외부 저장소에서 실행 파일을 가져와야 한다면, 이 파일들이 동적으로 로드되기 전에 서명되고 암호학적으로 검증되었는지 확인해야 합니다. 이는 애플리케이션의 보안 무결성을 유지하는 데 필수적입니다.

External storage는 `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`에서 접근할 수 있습니다.

> [!TIP]
> Android 4.4 (**API 17**)부터 SD 카드는 앱이 **해당 앱 전용 디렉터리만 접근할 수 있도록** 디렉터리 구조가 변경되었습니다. 이는 악성 애플리케이션이 다른 앱의 파일에 대해 읽기 또는 쓰기 접근을 얻는 것을 방지합니다.

**Sensitive data stored in clear-text**

- **Shared preferences**: Android는 각 애플리케이션이 경로 `/data/data/<packagename>/shared_prefs/`에 XML 파일을 쉽게 저장하도록 허용하며, 때때로 해당 폴더에서 평문으로 저장된 민감한 정보를 찾을 수 있습니다.
- **Databases**: Android는 각 애플리케이션이 경로 `/data/data/<packagename>/databases/`에 sqlite 데이터베이스를 쉽게 저장하도록 허용하며, 때로는 해당 폴더에서 평문으로 저장된 민감한 정보를 찾을 수 있습니다.

### Broken TLS

**Accept All Certificates**

어떤 이유로 개발자가 hostname이 일치하지 않더라도 모든 인증서를 수락하는 경우가 있습니다. 예를 들어 다음과 같은 코드 라인과 유사한 경우가 그렇습니다:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Broken Cryptography

**부적절한 키 관리 프로세스**

일부 개발자는 민감한 데이터를 로컬 스토리지에 저장하고 코드에 하드코딩/예측 가능한 키로 암호화합니다. 이는 리버싱을 통해 공격자가 기밀 정보를 추출할 수 있으므로 해서는 안 됩니다.

**취약하거나/또는 더 이상 사용되지 않는 알고리즘의 사용**

개발자는 권한 확인, 데이터 저장 또는 전송에 **deprecated algorithms**를 사용하면 안 됩니다. 이러한 알고리즘에는 RC4, MD4, MD5, SHA1 등이 있습니다. 예를 들어 비밀번호 저장에 **hashes**를 사용할 경우, salt와 함께 **brute-force resistant**한 해시를 사용해야 합니다.

### Other checks

- APK을 난독화하여 공격자의 리버스 엔지니어링 작업을 어렵게 만드는 것이 권장됩니다.
- 앱이 민감한 경우(예: 은행 앱)에는 **자체적으로 모바일이 rooted인지 확인하는 검사**를 수행하고 그에 따라 동작해야 합니다.
- 앱이 민감한 경우(예: 은행 앱)에는 **emulator**가 사용되는지 확인해야 합니다.
- 앱이 민감한 경우(예: 은행 앱)에는 **실행 전에 자체 무결성(integrity)을 확인**하여 수정되었는지 검사해야 합니다.
- [**APKiD**](https://github.com/rednaga/APKiD)를 사용하여 어떤 compiler/packer/obfuscator로 APK가 빌드되었는지 확인하세요

### React Native Application

다음 페이지를 읽어 React 애플리케이션의 javascript 코드를 쉽게 접근하는 방법을 배우세요:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

다음 페이지를 읽어 Xamarin 애플리케이션의 C# 코드에 쉽게 접근하는 방법을 배우세요:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

도구 [**mariana-trench**](https://github.com/facebook/mariana-trench)는 애플리케이션의 **코드**를 **스캔**하여 **vulnerabilities**를 찾을 수 있습니다. 이 도구는 **known sources**(툴에 입력이 사용자에 의해 제어되는 **위치**를 알려주는 것들), **sinks**(악의적인 사용자 입력이 피해를 일으킬 수 있는 **위험한 위치**) 및 **rules**의 집합을 포함합니다. 이러한 규칙들은 취약점을 나타내는 **sources-sinks 조합**을 지시합니다.

이 지식을 바탕으로, **mariana-trench는 코드를 검토하여 가능한 취약점을 찾아냅니다**.

### Secrets leaked

An application may contain secrets (API keys, passwords, hidden urls, subdomains...) inside of it that you might be able to discover. You could us a tool such as [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)
- In-memory native code execution via JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> First of all, you need an environment where you can install the application and all the environment (Burp CA cert, Drozer and Frida mainly). Therefore, a rooted device (emulated or not) is extremely recommended.

### Online Dynamic analysis

You can create a **free account** in: [https://appetize.io/](https://appetize.io). This platform allows you to **upload** and **execute** APKs, so it is useful to see how an apk is behaving.

You can even **see the logs of your application** in the web and connect through **adb**.

![](<../../images/image (831).png>)

Thanks to the ADB connection you can use **Drozer** and **Frida** inside the emulators.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (You can create **x86** and **arm** devices, and according to [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** versions **support ARM libraries** without needing an slow arm emulator).
- Learn to set it up in this page:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, you need to create an account. _It's recommend to **download** the version **WITH**_ _**VirtualBox** to avoid potential errors._)
- [**Nox**](https://es.bignox.com) (Free, but it doesn't support Frida or Drozer).

> [!TIP]
> When creating a new emulator on any platform remember that the bigger the screen is, the slower the emulator will run. So select small screens if possible.

To **install google services** (like AppStore) in Genymotion you need to click on the red marked button of the following image:

![](<../../images/image (277).png>)

Also, notice that in the **configuration of the Android VM in Genymotion** you can select **Bridge Network mode** (this will be useful if you will be connecting to the Android VM from a different VM with the tools).

#### Use a physical device

You need to activate the **debugging** options and it will be cool if you can **root** it:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Once you have installed the application, the first thing you should do is to try it and investigate what does it do, how does it work and get comfortable with it.\
> I will suggest to **perform this initial dynamic analysis using MobSF dynamic analysis + pidcat**, so we will be able to **learn how the application works** while MobSF **captures** a lot of **interesting** **data** you can review later on.

Magisk/Zygisk quick notes (recommended on Pixel devices)
- Patch boot.img with the Magisk app and flash via fastboot to get systemless root
- Enable Zygisk + DenyList for root hiding; consider LSPosed/Shamiko when stronger hiding is required
- Keep original boot.img to recover from OTA updates; re-patch after each OTA
- For screen mirroring, use scrcpy on the host



### Unintended Data Leakage

**Logging**

개발자는 **디버깅 정보**를 공개적으로 노출하지 않도록 주의해야 하며, 이는 민감한 데이터의 leak로 이어질 수 있습니다. 애플리케이션 로그를 모니터링하여 민감한 정보를 식별하고 보호하기 위해 도구 [**pidcat**](https://github.com/JakeWharton/pidcat)과 `adb logcat`을 권장합니다. **Pidcat**은 사용 편의성과 가독성 때문에 선호됩니다.

> [!WARNING]
> Note that from **later newer than Android 4.0**, **applications are only able to access their own logs**. So applications cannot access other apps logs.\
> Anyway, it's still recommended to **not log sensitive information**.

**Copy/Paste Buffer Caching**

Android의 **클립보드 기반** 프레임워크는 앱 간 복사-붙여넣기 기능을 가능하게 하지만, **다른 애플리케이션**이 클립보드에 접근할 수 있어 민감한 데이터를 노출할 위험이 있습니다. 신용카드 정보와 같은 민감한 섹션에 대해서는 복사/붙여넣기 기능을 비활성화하는 것이 중요합니다.

**Crash Logs**

애플리케이션이 **crash**하고 로그를 저장하면, 특히 애플리케이션을 리버스할 수 없을 때 이러한 로그가 공격자에게 도움을 줄 수 있습니다. 이 위험을 완화하려면 크래시 시 로깅을 피하고, 네트워크로 로그를 전송해야 하는 경우 SSL 채널을 통해 전송하도록 하세요.

As pentester, **try to take a look to these logs**.

**Analytics Data Sent To 3rd Parties**

애플리케이션은 종종 Google Adsense와 같은 서비스를 통합하는데, 개발자의 잘못된 구현으로 인해 민감한 데이터가 **leak**될 수 있습니다. 잠재적인 데이터 누출을 식별하려면 애플리케이션의 트래픽을 가로채고 제3자 서비스로 전송되는 민감한 정보가 있는지 확인하는 것이 좋습니다.

### SQLite DBs

대부분의 애플리케이션은 정보를 저장하기 위해 **internal SQLite databases**를 사용합니다. 펜테스트 중에는 생성된 **databases**, **tables**와 **columns**의 이름 및 저장된 모든 **데이터**를 살펴보세요. 민감한 정보를 찾을 수 있으며 이는 취약점이 될 수 있습니다.\
데이터베이스는 일반적으로 `/data/data/the.package.name/databases`에 위치하며 예: `/data/data/com.mwr.example.sieve/databases`

데이터베이스가 기밀 정보를 저장하면서 **암호화되어(encrypted)** 있지만 애플리케이션 내에서 **password**를 찾을 수 있다면 여전히 **취약점**입니다.

`.tables`로 테이블을 열거하고 `.schema <table_name>`으로 테이블의 칼럼들을 열거하세요

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer is s useful tool to **exploit exported activities, exported services and Content Providers** as you will learn in the following sections.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Also remember that the code of an activity starts in the **`onCreate`** method.

**Authorisation bypass**

When an Activity is exported you can invoke its screen from an external app. Therefore, if an activity with **sensitive information** is **exported** you could **bypass** the **authentication** mechanisms **to access it.**

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

You can also start an exported activity from adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**참고**: MobSF는 activity에서 `android:launchMode`로 _**singleTask/singleInstance**_를 사용하는 것을 악성으로 탐지하지만, [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750)에 따르면 이는 구버전(API versions < 21)에서만 위험한 것으로 보입니다.

> [!TIP]
> 권한 우회는 항상 취약점이 되는 것은 아니며, 우회 방식과 어떤 정보가 노출되는지에 따라 달라집니다.

**Sensitive information leakage**

Activities는 결과를 반환할 수도 있습니다. export되어 보호되지 않은 activity가 **`setResult`** 메서드를 호출하여 **민감한 정보를 반환**한다면 sensitive information leakage가 발생합니다.

#### Tapjacking

Tapjacking이 차단되지 않으면 export된 activity를 악용해 **사용자가 예기치 않은 작업을 수행**하도록 만들 수 있습니다. For more info about [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)  
Content Provider는 기본적으로 **데이터를 공유**하는 데 사용됩니다. 앱에 사용 가능한 content providers가 있으면 그들로부터 **민감한 데이터**를 추출할 수 있습니다. 또한 취약할 수 있으므로 가능한 **SQL injections**와 **Path Traversals**에 대한 테스트도 수행해 보아야 합니다.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)  
Service의 동작은 `onStartCommand` 메서드에서 시작된다는 것을 기억하세요.

Service는 기본적으로 **데이터를 수신**, **처리**하고 (또는 하지 않고) 응답을 **반환**할 수 있는 구성요소입니다. 따라서 애플리케이션이 일부 서비스를 export하고 있다면, 해당 서비스가 무엇을 하는지 이해하기 위해 **코드**를 확인하고 기밀 정보를 추출하거나 인증 우회를 시도하는 등 **동적 테스트**를 수행해야 합니다.  
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)  
Broadcast Receiver의 동작은 `onReceive` 메서드에서 시작된다는 것을 기억하세요.

Broadcast receiver는 특정 타입의 메시지를 기다립니다. 수신기가 메시지를 처리하는 방식에 따라 취약해질 수 있습니다.  
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

깊은 링크(deep links)는 수동으로 찾을 수 있으며, MobSF 같은 도구나 [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py) 같은 스크립트를 사용할 수 있습니다.  
선언된 **scheme**은 **adb** 또는 **브라우저**를 사용해 **open**할 수 있습니다:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_참고: 패키지 이름을 **생략하면**, 모바일이 해당 링크를 열 앱을 자동으로 호출합니다._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**실행되는 코드**

앱에서 실행될 **코드를 찾기 위해**, deeplink가 호출하는 activity로 가서 함수 **`onNewIntent`**을 검색하세요.

![](<../../images/image (436) (1) (1) (1).png>)

**민감 정보**

deep link를 찾을 때마다 **URL 매개변수로 비밀번호 같은 민감한 데이터를 받고 있지 않은지** 확인하세요. 다른 어떤 애플리케이션도 **deep link를 가장해 그 데이터를 탈취할 수 있습니다!**

**Parameters in path**

URL 경로 내부에 파라미터를 사용하는 deep link가 있는지도 **반드시 확인해야 합니다**. 예: `https://api.example.com/v1/users/{username}` , 이런 경우 `example://app/users?username=../../unwanted-endpoint%3fparam=value` 같은 값을 사용해 경로 트래버설을 강제할 수 있습니다.\
앱 내부에서 올바른 엔드포인트를 찾으면 경로의 일부가 도메인으로 사용될 때 **Open Redirect**를 유발하거나, CSRF 토큰 없이 사용자 정보를 수정할 수 있고 취약한 엔드포인트가 올바른 메서드를 사용했다면 **account takeover**를 일으킬 수 있으며 기타 다양한 vuln을 초래할 수 있습니다. More [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### 전송 계층 검사 및 검증 실패

- **Certificates are not always inspected properly** by Android applications. Android 애플리케이션은 경고를 무시하고 자체 서명 인증서(self-signed certificates)를 수락하거나, 경우에 따라 HTTP 연결로 되돌아가는 경우가 흔합니다.
- **Negotiations during the SSL/TLS handshake are sometimes weak**, 취약한 cipher suites를 사용하면 연결이 man-in-the-middle (MITM) 공격에 취약해져 공격자가 데이터를 복호화할 수 있습니다.
- **Leakage of private information** is a risk when applications authenticate using secure channels but then communicate over non-secure channels for other transactions. 이 접근 방식은 세션 쿠키나 사용자 정보 같은 민감한 데이터를 악의적 행위자에 의해 가로채는 것으로부터 보호하지 못합니다.

#### 인증서 검증

우리는 **certificate verification**에 초점을 맞출 것입니다. 서버 인증서의 무결성을 검증하는 것은 보안을 강화하는 데 필수적입니다. TLS 설정이 안전하지 않거나 민감한 데이터를 암호화되지 않은 채널로 전송하는 경우 심각한 위험이 발생할 수 있습니다. 서버 인증서 검증 및 취약점 해결에 대한 자세한 단계는 [**this resource**](https://manifestsecurity.com/android-application-security-part-10/)를 참고하세요.

#### SSL Pinning

SSL Pinning은 애플리케이션이 서버 인증서를 앱 내부에 저장된 알려진 복사본과 대조하여 검증하는 보안 수단입니다. 이 방법은 MITM 공격을 방지하는 데 필수적입니다. 민감한 정보를 다루는 애플리케이션에는 SSL Pinning 구현을 강력히 권장합니다.

#### 트래픽 검사

HTTP 트래픽을 검사하려면 **프록시 도구의 인증서를 설치**해야 합니다 (예: Burp). 이 인증서를 설치하지 않으면 암호화된 트래픽이 프록시를 통해 표시되지 않을 수 있습니다. 커스텀 CA 인증서 설치 가이드는 [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine)를 참고하세요.

API Level 24 and above를 타깃으로 하는 애플리케이션은 프록시의 CA 인증서를 수락하도록 Network Security Config를 수정해야 합니다. 이 단계는 암호화된 트래픽을 검사하는 데 중요합니다. Network Security Config 수정 방법은 [**refer to this tutorial**](make-apk-accept-ca-certificate.md)를 참조하세요.

만약 **Flutter**를 사용하는 경우 [**this page**](flutter.md)의 지침을 따라야 합니다. 단순히 인증서를 스토어에 추가하는 것만으로는 작동하지 않으며, Flutter는 자체 유효 CA 목록을 사용하기 때문입니다.

#### SSL/TLS pinning의 정적 탐지

런타임에서 우회 시도를 하기 전에 APK에서 pinning이 적용되는 위치를 빠르게 매핑하세요. 정적 탐지는 훅/패치 계획을 세우고 올바른 코드 경로에 집중하는 데 도움이 됩니다.

Tool: SSLPinDetect
- APK를 Smali로 디컴파일(apktool 사용)하고 SSL/TLS pinning 구현에 대한 선별된 regex 패턴을 스캔하는 오픈 소스 정적 분석 유틸리티입니다.
- 각 매치에 대해 정확한 파일 경로, 라인 번호, 코드 스니펫을 보고합니다.
- OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, 및 Network Security Config XML pins 등 일반적인 프레임워크와 커스텀 코드 경로를 다룹니다.

설치
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
사용법
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
예시 패턴 규칙 (JSON)
proprietary/custom pinning styles를 탐지하기 위해 signatures를 사용하거나 확장하세요. 자신의 JSON을 로드하여 대규모로 스캔할 수 있습니다.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes and tips
- 대규모 앱을 빠르게 스캔하려면 멀티스레딩과 메모리 매핑 I/O를 사용; 사전 컴파일된 regex는 오버헤드/오탐을 줄여준다.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- 다음으로 우선 분류할 일반적인 탐지 대상:
- OkHttp: CertificatePinner 사용, setCertificatePinner, okhttp3/okhttp 패키지 참조
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted 오버라이드
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init 와 커스텀 매니저
- Declarative pins in res/xml network security config 및 manifest 참조
- 동적 테스트 전에 일치한 위치를 사용해 Frida hooks, 정적 패치 또는 설정 검토를 계획하라.



#### SSL Pinning 우회

SSL Pinning이 구현되어 있으면 HTTPS 트래픽을 검사하기 위해 이를 우회해야 할 필요가 있다. 이를 위한 다양한 방법이 있다:

- 자동으로 **apk**를 수정해 SSLPinning을 **우회**하려면 [**apk-mitm**](https://github.com/shroudedcode/apk-mitm)를 사용한다. 이 옵션의 가장 큰 장점은 SSL Pinning을 우회하기 위해 root가 필요 없다는 점이지만, 애플리케이션을 삭제하고 새로 설치해야 하며 항상 동작하는 것은 아니다.
- 이 보호를 우회하려면 **Frida**(아래에서 설명)를 사용할 수 있다. Burp+Frida+Genymotion을 사용하는 가이드는 다음을 참고하라: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- 또한 [**objection**](frida-tutorial/objection-tutorial.md)를 사용해 SSL Pinning을 **자동으로 우회**해볼 수 있다: `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- 또한 **MobSF dynamic analysis**(아래 설명)를 사용해 SSL Pinning을 **자동으로 우회**할 수 있다.
- 여전히 캡처되지 않는 트래픽이 있다고 생각되면 iptables를 사용해 트래픽을 burp로 포워딩해볼 수 있다. 블로그 참조: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### 일반적인 웹 취약점 찾기

애플리케이션 내의 일반적인 웹 취약점을 검색하는 것도 중요하다. 이러한 취약점 식별 및 완화에 대한 자세한 내용은 이 요약의 범위를 벗어나며 다른 자료에서 광범위하게 다루고 있다.

### Frida

[Frida](https://www.frida.re)는 개발자, 역공학자, 보안 연구원을 위한 동적 계측 툴킷이다.\
**실행 중인 애플리케이션에 접근해 런타임에 메서드를 훅(hook)해 동작을 변경하거나, 값 변경, 값 추출, 다른 코드 실행 등을 할 수 있다...**\
Android 애플리케이션을 pentest하려면 Frida 사용법을 알아야 한다.

- Frida 사용법 배우기: [**Frida tutorial**](frida-tutorial/index.html)
- Frida 작업용 일부 "GUI": [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection은 Frida 사용 자동화에 좋다: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Awesome Frida 스크립트는 여기에서 찾을 수 있다: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- anti-debugging / anti-frida 메커니즘을 우회하려면 [https://erfur.github.io/blog/dev/code-injection-without-ptrace]에 나와 있는 대로 Frida를 로드해보라 (도구 [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **메모리 덤프 - Fridump**

애플리케이션이 비밀번호나 니모닉처럼 저장해서는 안 되는 민감한 정보를 메모리에 저장하는지 확인하라.

[**Fridump3**](https://github.com/rootbsd/fridump3)를 사용해 앱의 메모리를 덤프할 수 있다:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
이것은 ./dump 폴더에 메모리를 덤프하며, 그 안에서 다음과 같이 grep할 수 있습니다:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Keystore의 민감한 데이터**

Android에서 Keystore는 민감한 데이터를 저장하기에 최적의 장소이지만, 충분한 권한이 있으면 여전히 **접근할 수 있습니다**. 애플리케이션이 여기서 **평문으로 된 민감한 데이터를** 저장하는 경향이 있으므로, pentests는 root user 권한으로 이를 검사해야 하며 기기에 물리적으로 접근할 수 있는 사람이 이 데이터를 탈취할 수 있습니다.

앱이 keystore에 데이터를 저장하더라도, 해당 데이터는 암호화되어야 합니다.

keystore 내부의 데이터에 접근하려면 다음 Frida 스크립트를 사용할 수 있습니다: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

다음 Frida 스크립트를 사용하면 Android 애플리케이션이 특정 민감한 영역을 보호하기 위해 수행하는 **bypass fingerprint authentication**을 우회할 수 있습니다:
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **백그라운드 이미지**

애플리케이션을 백그라운드로 보낼 때, Android는 **애플리케이션의 스냅샷**을 저장합니다. 그래서 포어그라운드로 복원될 때 앱보다 먼저 이미지를 불러와 앱이 더 빠르게 로드되는 것처럼 보입니다.

하지만 이 스냅샷에 **민감한 정보**가 포함되어 있다면, 스냅샷에 접근할 수 있는 누군가가 **그 정보를 탈취할 수 있습니다**(접근하려면 root 권한이 필요하다는 점에 유의하세요).

스냅샷은 일반적으로 다음 경로에 저장됩니다: **`/data/system_ce/0/snapshots`**

Android는 레이아웃 파라미터에 **FLAG_SECURE를 설정하여 스크린샷 캡처를 방지**하는 방법을 제공합니다. 이 플래그를 사용하면 창 내용이 보안 대상으로 처리되어 스크린샷에 나타나거나 비보안 디스플레이에서 표시되는 것을 방지합니다.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

This tool could help you managing different tools during the dynamic analysis: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Developers often create proxy components like activities, services, and broadcast receivers that handle these Intents and pass them to methods such as `startActivity(...)` or `sendBroadcast(...)`, which can be risky.

위험은 공격자가 이러한 Intents를 잘못 유도하여 non-exported app components를 트리거하거나 민감한 content providers에 접근하도록 허용하는 데 있습니다. 대표적인 예로는 `WebView` 컴포넌트가 URL을 `Intent.parseUri(...)`를 통해 `Intent` 객체로 변환한 뒤 실행하여 악의적인 Intent injections로 이어질 수 있는 경우가 있습니다.

### Essential Takeaways

- **Intent Injection**은 웹의 Open Redirect 문제와 유사합니다.
- Exploits involve passing `Intent` objects as extras, which can be redirected to execute unsafe operations.
- 이로 인해 non-exported components와 content providers가 공격자에게 노출될 수 있습니다.
- `WebView`의 URL → `Intent` 변환은 의도치 않은 동작을 유발할 수 있습니다.

### Android Client Side Injections and others

Probably you know about this kind of vulnerabilities from the Web. You have to be specially careful with this vulnerabilities in an Android application:

- **SQL Injection:** When dealing with dynamic queries or Content-Providers ensure you are using parameterized queries.
- **JavaScript Injection (XSS):** Verify that JavaScript and Plugin support is disabled for any WebViews (disabled by default). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews should have access to the file system disabled (enabled by default) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: In several cases when the android application finish the session the cookie isn't revoked or it could be even saved to disk
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**정적 분석**

![](<../../images/image (866).png>)

**애플리케이션의 취약점 평가**를 깔끔한 웹 기반 프런트엔드를 통해 제공합니다. 또한 동적 분석도 수행할 수 있습니다(단, 환경을 미리 준비해야 합니다).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Assisted Dynamic analysis with MobSF

**MobSF** can also be very helpful for **dynamic analysis** in **Android**, but in that case you will need to install MobSF and **genymotion** in your host (a VM or Docker won't work). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
The **MobSF dynamic analyser** can:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). All of this is done automatically except for the screenshots, you need to press when you want a screenshot or you need to press "**Exported Activity Tester**" to obtain screenshots of all the exported activities.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: It will print all the loaded classes
- **Capture Strings**: It will print all the capture strings while using the application (super noisy)
- **Capture String Comparisons**: Could be very useful. It will **show the 2 strings being compared** and if the result was True or False.
- **Enumerate Class Methods**: Put the class name (like "java.io.File") and it will print all the methods of the class.
- **Search Class Pattern**: Search classes by pattern
- **Trace Class Methods**: **Trace** a **whole class** (see inputs and outputs of all methods of th class). Remember that by default MobSF traces several interesting Android Api methods.

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf also brings you a shell with some **adb** commands, **MobSF commands**, and common **shell** **commands** at the bottom of the dynamic analysis page. Some interesting commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP 도구**

HTTP 트래픽을 캡처하면 하단의 "**HTTP(S) Traffic**" 버튼에서 캡처된 트래픽의 거친 뷰를 보거나 초록색 "**Start HTTPTools**" 버튼에서 더 깔끔한 뷰를 볼 수 있습니다. 두 번째 옵션에서는 **send**로 **captured requests**를 **proxies**(예: Burp 또는 Owasp ZAP)로 보낼 수 있습니다.\
이를 위해서는 _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> 버튼 "**Send to Fuzzer**"를 누르고 --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

MobSF로 dynamic analysis를 완료하면 "**Start Web API Fuzzer**"를 눌러 **fuzz http requests**를 수행하여 취약점을 찾을 수 있습니다.

> [!TIP]
> MobSF로 dynamic analysis를 수행한 후 프록시 설정이 잘못 구성되어 GUI에서 수정할 수 없게 될 수 있습니다. 다음 명령으로 프록시 설정을 수정할 수 있습니다:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

도구는 [**Inspeckage**](https://github.com/ac-pm/Inspeckage)에서 얻을 수 있습니다.\
이 도구는 몇 가지 **Hooks**를 사용하여 **dynamic analysis**를 수행하는 동안 애플리케이션에서 어떤 일이 일어나고 있는지 알려줍니다.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

이것은 GUI로 **static analysis**를 수행하기에 훌륭한 도구입니다.

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

이 도구는 여러 **security related Android application vulnerabilities**를 찾도록 설계되었으며, **source code** 또는 **packaged APKs**에서 동작합니다. 또한 이 도구는 일부 발견된 취약점(Exposed activities, intents, tapjacking...)을 악용하기 위한 **"Proof-of-Concept" deployable APK**와 **ADB commands**를 생성할 수 있습니다. Drozer와 마찬가지로 테스트 디바이스를 root할 필요가 없습니다.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- 참조하기 쉽도록 모든 추출된 파일을 표시합니다
- APK 파일을 자동으로 Java 및 Smali 형식으로 디컴파일합니다
- AndroidManifest.xml을 분석하여 일반적인 취약점 및 동작을 확인합니다
- 정적 소스 코드 분석을 통해 일반적인 취약점 및 동작을 탐지합니다
- 장치 정보
- 그 외에도
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER는 Windows, MacOS X 및 Linux에서 사용할 수 있는 command-line application으로, _.apk_ 파일을 분석해 취약점을 찾아냅니다. 이 도구는 APK를 압축 해제하고 일련의 규칙을 적용하여 해당 취약점을 탐지합니다.

모든 규칙은 `rules.json` 파일에 집중되어 있으며, 각 회사나 테스터는 필요에 따라 자체 규칙을 만들어 분석할 수 있습니다.

최신 바이너리는 [download page](https://superanalyzer.rocks/download.html)에서 다운로드하세요.
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn은 모바일 애플리케이션에서 [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis)를 수행하는 개발자, bugbounty hunters 및 ethical hackers를 돕는 **crossplatform** 도구입니다.

개념은 모바일 애플리케이션 파일(.apk 또는 .ipa 파일)을 StaCoAn 애플리케이션에 드래그 앤 드롭하면 시각적이고 휴대 가능한 보고서를 생성해 준다는 것입니다. 설정과 wordlists를 조정하여 맞춤형 경험을 얻을 수 있습니다.

다운로드[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework는 Android 애플리케이션에서 개발자 또는 hackers가 잠재적인 보안 취약점을 찾는 데 도움을 주는 취약점 분석 시스템입니다.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn**은 Android 애플리케이션이 생성할 수 있는 잠재적인 악성 동작을 탐지하고 사용자에게 경고하는 것을 주된 목적을 가진 도구입니다.

탐지는 애플리케이션의 Dalvik bytecode를 **Smali**로 표현한 것에 대한 **static analysis**를 [`androguard`](https://github.com/androguard/androguard) 라이브러리와 함께 사용하여 수행됩니다.

이 도구는 **"나쁜" 애플리케이션의 일반적인 동작**을 찾습니다. 예: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA**는 **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework입니다. 이 도구는 모바일 애플리케이션의 리버스 엔지니어링 및 분석에 자주 사용되는 도구들을 모아, OWASP 모바일 보안 위협에 대해 모바일 애플리케이션을 테스트하는 데 도움을 줍니다. 목표는 모바일 애플리케이션 개발자와 보안 전문가에게 이 작업을 더 쉽고 친숙하게 만드는 것입니다.

다음 기능을 제공합니다:

- 다양한 도구를 사용하여 Java 및 Smali 코드를 추출
- 다음 도구들을 사용해 APK를 분석: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- 정규식(regexp)을 사용하여 APK에서 개인 정보 추출
- Manifest 분석
- 발견된 도메인을 다음으로 분석: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) 및 [whatweb](https://github.com/urbanadventurer/WhatWeb)
- [apk-deguard.com]을 통해 APK 역난독화

### Koodous

악성코드 탐지에 유용: [https://koodous.com/](https://koodous.com/)

## 코드 난독화/역난독화

코드를 난독화하는 데 사용하는 서비스와 설정에 따라 비밀(Secrets)이 난독화되거나 그렇지 않을 수 있다는 점을 유의하세요.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard**는 Java 코드를 축소, 최적화 및 난독화하는 오픈 소스 명령줄 도구입니다. 바이트코드를 최적화하고 사용되지 않는 명령을 감지 및 제거할 수 있습니다. ProGuard는 자유 소프트웨어이며 GNU General Public License, version 2 하에 배포됩니다.

ProGuard는 Android SDK의 일부로 배포되며 릴리스 모드에서 애플리케이션을 빌드할 때 실행됩니다.

### [DexGuard](https://www.guardsquare.com/dexguard)

apk를 역난독화하는 단계별 가이드는 [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)에서 확인하세요.

(해당 가이드에 따르면) 마지막으로 확인했을 때 Dexguard의 동작 방식은 다음과 같았습니다:

- 리소스를 InputStream으로 로드;
- 결과를 FilterInputStream을 상속한 클래스에 전달하여 복호화;
- 리버서의 시간을 약간 소비하기 위한 불필요한 난독화 수행;
- 복호화된 결과를 ZipInputStream에 전달하여 DEX 파일 획득;
- 마지막으로 `loadDex` 메서드를 사용해 결과 DEX를 Resource로 로드.

### [DeGuard](http://apk-deguard.com)

**DeGuard는 Android 난독화 도구들이 수행한 난독화 과정을 역으로 수행합니다. 이를 통해 코드 검사 및 라이브러리 예측을 포함한 다양한 보안 분석이 가능해집니다.**

난독화된 APK를 플랫폼에 업로드할 수 있습니다.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

이는 android 앱의 잠재적 보안 취약점을 찾고 android 앱 코드를 역난독화하기 위한 LLM 도구입니다. Google의 Gemini public API를 사용합니다.

### [Simplify](https://github.com/CalebFenton/simplify)

이는 **범용 android deobfuscator**입니다. Simplify는 앱을 **가상으로 실행(virtually executes an app)** 해서 동작을 이해한 다음, 동작은 동일하지만 사람이 이해하기 쉬운 코드로 **최적화하려고 시도(tries to optimize the code)** 합니다. 각 최적화 유형은 단순하고 일반적이어서 사용된 특정 난독화 유형이 무엇인지와 관계없이 작동합니다.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD는 **APK가 어떻게 만들어졌는지**에 대한 정보를 제공합니다. 많은 **compilers**, **packers**, **obfuscators** 등 이상한 것들을 식별합니다. Android용 [_PEiD_](https://www.aldeid.com/wiki/PEiD)라고 할 수 있습니다.

### Manual

[이 튜토리얼을 읽어 **커스텀 난독화 역공략 방법을 배우세요**](manual-deobfuscation.md)

## 실습

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b는 ubuntu-mate 기반의 Android 보안 가상 머신으로, reverse engineering 및 malware analysis를 위한 최신 프레임워크, 튜토리얼 및 실습 모음을 포함합니다.

## 참고자료

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) 훌륭한 자료 목록입니다
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android 빠른 강좌
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097) — Android 보안 분석을 위한 고급 SSL Pinning 탐지
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect) — SSLPinDetect GitHub 저장소
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone) — Android 인메모리 JNI 실행 및 패키징 파이프라인

{{#include ../../banners/hacktricks-training.md}}
