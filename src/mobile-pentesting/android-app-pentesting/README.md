# Android aplikacije Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Osnove Android aplikacija

Preporučuje se da počnete sa čitanjem ove stranice kako biste saznali o **najvažnijim delovima vezanim za Android bezbednost i najopasnijim komponentama u Android aplikaciji**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Ovo je glavni alat koji vam je potreban da se povežete sa Android uređajem (emuliranim ili fizičkim).\
**ADB** omogućava kontrolu uređaja bilo preko **USB** ili **Network** sa računara. Ovaj alat omogućava **kopiranje** fajlova u oba smera, **instalaciju** i **deinstalaciju** aplikacija, **izvršavanje** shell komandi, **pravljenje rezervnih kopija** podataka, **čitanje** logova, između ostalih funkcija.

Pogledajte sledeću listu [**ADB Commands**](adb-commands.md) da naučite kako da koristite adb.

## Smali

Ponekad je zanimljivo da **izmenite kod aplikacije** da biste pristupili **skrivenim informacijama** (možda dobro obfuskovanim lozinkama ili flags). Zato može biti korisno decompile-ovati APK, izmeniti kod i ponovo ga recompile-ovati.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Ovo može biti veoma korisno kao **alternativa za nekoliko testova tokom dinamičke analize** koji će biti predstavljeni. Zato, **uvek imajte na umu ovu mogućnost**.

## Ostali zanimljivi trikovi

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Izdvajanje APK-a sa uređaja:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Spojite sve splits i base apks pomoću [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Studije slučaja i ranjivosti


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Static Analysis

Pre svega, za analiziranje APK-a trebalo bi da **pogledate Java kod** koristeći dekompajler.\
Molimo, [**pročitajte ovde da biste pronašli informacije o različitim dostupnim dekompajlerima**](apk-decompilers.md).

### Potraga za zanimljivim informacijama

Samo pregledom **strings** iz APK-a možete tražiti **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** i sve što je interesantno... čak i tražiti code execution **backdoors** ili authentication backdoors (hardcoded admin credentials u aplikaciji).

**Firebase**

Obratite posebnu pažnju na **firebase URLs** i proverite da li je loše konfigurisano. [Više informacija o tome šta je Firebase i kako ga eksploatisati ovde.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Osnovno razumevanje aplikacije - Manifest.xml, strings.xml

Pregled datoteka aplikacije _Manifest.xml_ i _strings.xml_ može otkriti potencijalne bezbednosne ranjivosti. Ove datoteke se mogu pristupiti koristeći dekompajlere ili preimenovanjem APK ekstenzije u .zip i zatim raspakivanjem.

**Ranjivosti** identifikovane iz **Manifest.xml** uključuju:

- **Debuggable Applications**: Aplikacije označene kao debuggable (`debuggable="true"`) u _Manifest.xml_ predstavljaju rizik jer omogućavaju konekcije koje mogu dovesti do eksploatacije. Za više informacija o tome kako eksploatisati debuggable aplikacije, pogledajte tutorijal o pronalaženju i eksploataciji debuggable aplikacija na uređaju.
- **Backup Settings**: Atribut `android:allowBackup="false"` treba eksplicitno biti postavljen za aplikacije koje rade sa osetljivim informacijama kako bi se sprečili neovlašćeni backup-i podataka preko adb-a, posebno kada je usb debugging omogućen.
- **Network Security**: Prilagođene konfiguracije network security (`android:networkSecurityConfig="@xml/network_security_config"`) u _res/xml/_ mogu odrediti detalje bezbednosti poput certificate pins i podešavanja HTTP saobraćaja. Primer je dozvoljavanje HTTP saobraćaja za određene domene.
- **Exported Activities and Services**: Identifikacija exported activities i services u manifestu može ukazati na komponente koje se mogu zloupotrebiti. Dalja analiza tokom dynamic testing-a može otkriti kako eksploatisati ove komponente.
- **Content Providers and FileProviders**: Izloženi content providers mogu dozvoliti neovlašćen pristup ili izmenu podataka. Konfiguracija FileProviders-a takođe treba detaljno da se pregleda.
- **Broadcast Receivers and URL Schemes**: Ove komponente se mogu iskoristiti za eksploataciju, sa posebnom pažnjom na način na koji su URL schemes upravljani u pogledu input vulnerabilities.
- **SDK Versions**: Atributi `minSdkVersion`, `targetSDKVersion` i `maxSdkVersion` ukazuju na podržane Android verzije, naglašavajući važnost nepodržavanja zastarelih, ranjivih Android verzija iz bezbednosnih razloga.

Iz datoteke **strings.xml** mogu se otkriti osetljive informacije poput API keys, custom schemas i drugih developer napomena, što naglašava potrebu za pažljivim pregledom tih resursa.

### Tapjacking

**Tapjacking** je napad u kome se pokrene zlonamerna aplikacija i postavi iznad ciljne aplikacije. Kada vizuelno zakloni ciljnu aplikaciju, njen korisnički interfejs je dizajniran tako da prevari korisnika da interaguje sa njim, dok se interakcija prosleđuje ciljnoj aplikaciji.\
U suštini, to je **oslepljivanje korisnika tako da ne zna da zapravo izvršava radnje u ciljnoj aplikaciji**.

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

An **activity** sa **`launchMode`** postavljenim na **`singleTask` bez definisanog `taskAffinity`** je ranjiva na Task Hijacking. To znači da se može instalirati zlonamerna aplikacija koja, ako se pokrene pre prave aplikacije, može preuzeti task prave aplikacije (tako da će korisnik interagovati sa zlonamernom aplikacijom misleći da koristi pravu).

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Insecure data storage

**Internal Storage**

U Androidu, fajlovi smešteni u internal storage su dizajnirani da budu dostupni isključivo aplikaciji koja ih je kreirala. Ova mera bezbednosti se sprovodi od strane Android operativnog sistema i generalno je dovoljna za bezbednosne potrebe većine aplikacija. Međutim, programeri ponekad koriste režime kao što su `MODE_WORLD_READABLE` i `MODE_WORLD_WRITABLE` da bi dozvolili deljenje fajlova među različitim aplikacijama. Ipak, ovi režimi ne ograničavaju pristup tim fajlovima drugim aplikacijama, uključujući potencijalno zlonamerne.

1. **Static Analysis:**
- **Proverite** da li se upotreba `MODE_WORLD_READABLE` i `MODE_WORLD_WRITABLE` pažljivo analizira. Ovi režimi **mogu potencijalno izložiti** fajlove neželjenom ili neovlašćenom pristupu.
2. **Dynamic Analysis:**
- **Proverite** permisije dodeljene fajlovima koje aplikacija kreira. Konkretno, **proverite** da li su neki fajlovi **postavljeni da budu readable ili writable worldwide**. To može predstavljati značajan bezbednosni rizik, jer bi omogućilo **svakoj aplikaciji** instaliranoj na uređaju, bez obzira na poreklo ili nameru, da **čitа ili menja** te fajlove.

**External Storage**

Kada je reč o fajlovima na external storage, kao što su SD kartice, treba preduzeti određene mere opreza:

1. **Accessibility**:
- Fajlovi na external storage su globalno readable i writable. To znači da svaka aplikacija ili korisnik može pristupiti tim fajlovima.
2. **Security Concerns**:
- S obzirom na jednostavnost pristupa, preporučuje se **ne čuvati osetljive informacije** na external storage.
- External storage može biti uklonjen ili mu može pristupiti bilo koja aplikacija, što ga čini manje bezbednim.
3. **Handling Data from External Storage**:
- Uvek **izvršite validaciju unosa** podataka preuzetih sa external storage. Ovo je presudno jer podaci dolaze iz nepoverljivog izvora.
- Ne preporučuje se čuvanje izvršnih fajlova ili class fajlova na external storage za dinamičko učitavanje.
- Ako vaša aplikacija mora da preuzme izvršne fajlove sa external storage, osigurajte da su ti fajlovi **potpisani i kriptografski verifikovani** pre nego što se dinamički učitaju. Ovaj korak je ključan za održavanje bezbednosnog integriteta vaše aplikacije.

External storage može biti accessed u `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> Počevši od Android 4.4 (**API 17**), SD kartica ima strukturu direktorijuma koja ograničava pristup aplikacije samo na direktorijum specifičan za tu aplikaciju. Ovo sprečava zlonamerne aplikacije da dobiju read ili write pristup fajlovima druge aplikacije.

**Sensitive data stored in clear-text**

- **Shared preferences**: Android omogućava svakoj aplikaciji da lako sačuva xml fajlove na putanji `/data/data/<packagename>/shared_prefs/` i ponekad je moguće pronaći osetljive informacije u clear-text u tom folderu.
- **Databases**: Android omogućava svakoj aplikaciji da lako sačuva sqlite databases na putanji `/data/data/<packagename>/databases/` i ponekad je moguće pronaći osetljive informacije u clear-text u tom folderu.

### Broken TLS

**Accept All Certificates**

Iz nekog razloga ponekad developeri prihvataju sve sertifikate čak i ako, na primer, hostname ne odgovara, sa linijama koda poput sledeće:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Dobar način da se ovo testira je pokušati presresti saobraćaj koristeći neki proxy poput Burp bez autorizovanja Burp CA unutar uređaja. Takođe, možete sa Burp-om generisati sertifikat za drugačiji hostname i koristiti ga.

### Pokvarena kriptografija

**Loši procesi upravljanja ključevima**

Neki developeri čuvaju osetljive podatke u lokalnoj memoriji i enkriptuju ih ključem hardcoded/predictable u kodu. To se ne bi smelo raditi, jer reversing može omogućiti napadačima da izvuku poverljive informacije.

**Korišćenje nesigurnih i/ili zastarelih algoritama**

Developeri ne bi trebalo da koriste **deprecated algorithms** za izvršavanje autorizacionih **checks**, za **store** ili **send** podataka. Neki od ovih algoritama su: RC4, MD4, MD5, SHA1... Ako se **hashes** koriste za čuvanje lozinki, treba koristiti hash-e otporne na brute-force i sa salt-om.

### Ostale provere

- Preporučuje se da **obfuscate the APK** kako biste otežali posao reverse engineer-a napadačima.
- Ako je aplikacija osetljiva (npr. bankarske aplikacije), treba da izvrši svoje provere da li je mobilni uređaj root-ovan i postupi u skladu s tim.
- Ako je aplikacija osetljiva (npr. bankarske aplikacije), treba da proveri da li se koristi **emulator**.
- Ako je aplikacija osetljiva (npr. bankarske aplikacije), treba da proveri sopstveni integritet pre izvršavanja kako bi utvrdila da li je bila modifikovana.
- Koristite [**APKiD**](https://github.com/rednaga/APKiD) da proverite koji compiler/packer/obfuscator je korišćen za izgradnju APK-a

### React Native Application

Pročitajte sledeću stranicu da biste naučili kako lako pristupiti javascript kodu React aplikacija:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Pročitajte sledeću stranicu da biste naučili kako lako pristupiti C# kodu Xamarin aplikacija:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

Prema ovom [**blog postu**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked je Meta algoritam koji kompresuje sadržaj aplikacije u jednu datoteku. Blog govori o mogućnosti kreiranja aplikacije koja dekompresuje ove tipove aplikacija... i o bržem pristupu koji uključuje da **execute the application and gather the decompressed files from the filesystem.**

### Automatizovana statička analiza koda

Alat [**mariana-trench**](https://github.com/facebook/mariana-trench) je sposoban da pronađe **vulnerabilities** skeniranjem **code** aplikacije. Ovaj alat sadrži niz **known sources** (koji ukazuju na mesta gde je **input** kontrolisan od strane korisnika), **sinks** (koji ukazuju na opasna mesta gde maliciozni unos korisnika može izazvati štetu) i **rules**. Ove rules ukazuju na **kombinaciju** **sources-sinks** koja označava ranjivost.

Sa ovim znanjem, **mariana-trench će pregledati kod i pronaći moguće vulnerabilities u njemu**.

### Secrets leaked

Aplikacija može da sadrži secrets (API keys, passwords, hidden urls, subdomains...) u sebi koje možete otkriti. Možete koristiti alat kao što je [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Ostale interesantne funkcije

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dinamička analiza

> Prvo, potrebna vam je okolina u kojoj možete instalirati aplikaciju i celu okolinu (Burp CA cert, Drozer i Frida pre svega). Stoga, root-ovan uređaj (emuliran ili ne) je toplo preporučen.

### Online dinamička analiza

Možete napraviti besplatan nalog na: [https://appetize.io/](https://appetize.io). Ova platforma omogućava da **upload** i **execute** APK-ove, pa je korisna da vidite kako se APK ponaša.

Možete čak i **videti logove vaše aplikacije** na webu i povezati se preko **adb**.

![](<../../images/image (831).png>)

Zahvaljujući ADB konekciji možete koristiti **Drozer** i **Frida** unutar emulatora.

### Lokalna dinamička analiza

#### Korišćenje emulatora

- [**Android Studio**](https://developer.android.com/studio) (Možete kreirati **x86** i **arm** uređaje, i prema [**ovome**](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**najnovije x86** verzije **support ARM libraries** bez potrebe za sporim arm emulatorom).
- Naučite kako da ga podesite na ovoj strani:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Besplatna verzija:** Personal Edition, potrebno je kreirati nalog. _Preporučuje se da **download** verziju **WITH**_ _**VirtualBox** da biste izbegli potencijalne greške._)
- [**Nox**](https://es.bignox.com) (Besplatan, ali ne podržava Frida ili Drozer).

> [!TIP]
> Kada kreirate novi emulator na bilo kojoj platformi imajte na umu da što je ekran veći, emulator će raditi sporije. Zato birajte male ekrane ako je moguće.

Da biste **install google services** (kao AppStore) u Genymotion potrebno je da kliknete na crveno označeno dugme na sledećoj slici:

![](<../../images/image (277).png>)

Takođe, obratite pažnju da u **konfiguraciji Android VM-a u Genymotion-u** možete izabrati **Bridge Network mode** (ovo će biti korisno ako ćete se povezivati na Android VM iz druge VM sa alatima).

#### Korišćenje fizičkog uređaja

Treba da aktivirate **debugging** opcije i bilo bi dobro da možete da ga **root**-ujete:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Kada instalirate aplikaciju, prvo što treba da uradite je da je probate i istražite šta radi, kako funkcioniše i da se upoznate sa njom.\
> Predlažem da **perform this initial dynamic analysis using MobSF dynamic analysis + pidcat**, tako da ćemo moći da **learn how the application works** dok MobSF **captures** puno **interesting** **data** koje možete kasnije pregledati.

Magisk/Zygisk kratke napomene (preporučeno na Pixel uređajima)
- Patch-ujte boot.img uz pomoć Magisk aplikacije i flash-ujte preko fastboot-a da biste dobili systemless root
- Omogućite Zygisk + DenyList za skrivanje root-a; razmotrite LSPosed/Shamiko kada je potrebno jače skrivanje
- Sačuvajte originalni boot.img da biste se oporavili posle OTA nadogradnji; ponovo patch-ujte posle svake OTA
- Za deljenje ekrana, koristite scrcpy na hostu



### Nenamerna curenja podataka

**Logovanje**

Developeri treba da budu oprezni da ne izlažu **debugging information** javno, jer to može dovesti do curenja osetljivih podataka. Alati [**pidcat**](https://github.com/JakeWharton/pidcat) i `adb logcat` se preporučuju za praćenje logova aplikacije kako biste identifikovali i zaštitili osetljive informacije. **Pidcat** je omiljen zbog jednostavnosti korišćenja i čitljivosti.

> [!WARNING]
> Imajte na umu da od **novijih verzija nakon Android 4.0**, **aplikacije mogu pristupiti samo svojim sopstvenim logovima**. Dakle, aplikacije ne mogu pristupiti logovima drugih aplikacija.\
> U svakom slučaju, još uvek je preporučljivo **ne logovati osetljive informacije**.

**Keširanje copy/paste buffera**

Android-ov **clipboard-based** okvir omogućava copy-paste funkcionalnost u aplikacijama, ali predstavlja rizik jer **druge aplikacije** mogu **access** clipboard, potencijalno izlažući osetljive podatke. Važno je **disable** copy/paste funkcije za osetljive delove aplikacije, kao što su podaci o kreditnim karticama, kako bi se sprečilo leak podataka.

**Crash Logs**

Ako aplikacija **crashes** i **saves logs**, ti logovi mogu pomoći napadačima, posebno kada aplikacija ne može biti reverse-engineer-ovana. Da biste umanjili ovaj rizik, izbegavajte logovanje pri padovima, a ako logovi moraju biti poslati preko mreže, osigurajte da se šalju putem SSL kanala.

Kao pentester, pokušajte da pogledate ove logove.

**Analytics Data Sent To 3rd Parties**

Aplikacije često integrišu servise poput Google Adsense, koji mogu nenamerno leak sensitive data zbog pogrešne implementacije developera. Da biste identifikovali potencijalno curenje podataka, preporučljivo je da **intercept** saobraćaj aplikacije i proverite da li se bilo kakve osetljive informacije šalju ka third-party servisima.

### SQLite DBs

Većina aplikacija koristi **internal SQLite databases** za čuvanje informacija. Tokom pentest-a pregledajte **databases** koje su kreirane, nazive **tables** i **columns** i sve sačuvane **data** jer možete naći osetljive informacije (što bi predstavljalo vulnerability).\
Baze bi trebalo da se nalaze u `/data/data/the.package.name/databases` kao na primer `/data/data/com.mwr.example.sieve/databases`

Ako baza čuva poverljive informacije i **encrypted** je, ali možete **find** **password** unutar aplikacije, to je i dalje **vulnerability**.

Nabrojite tabele koristeći `.tables` i nabrojite kolone tabele koristeći `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

Prema [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** vam omogućava da **assume the role of an Android app** i da interagujete sa drugim aplikacijama. Može uraditi **bilo šta što instalirana aplikacija može**, kao što je korišćenje Android-ovog Inter-Process Communication (IPC) mehanizma i interakcija sa osnovnim operativnim sistemom.\
Drozer je koristan alat za **exploit exported activities, exported services and Content Providers** kao što ćete naučiti u narednim sekcijama.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Takođe zapamtite da kod aktivnosti počinje u **`onCreate`** metodi.

**Authorisation bypass**

Kada je Activity exported, možete pozvati njen ekran iz eksterne aplikacije. Dakle, ako je aktivnost sa **senzitivnim informacijama** **exported**, možete **bypass** **authentication** mehanizme kako biste joj pristupili.

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

Takođe možete pokrenuti exported activity iz adb-a:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> Imajte na umu da authorisation bypass nije uvek ranjivost; to zavisi od načina na koji bypass radi i koje informacije su izložene.

**Sensitive information leakage**

**Activities can also return results**. If you manage to find an exported and unprotected activity calling the **`setResult`** method and **returning sensitive information**, there is a sensitive information leakage.

#### Tapjacking

If Tapjacking isn't prevented, you could abuse the exported activity to make the **user perform unexpected actions**. For more info about [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers are basically used to **share data**. If an app has available content providers you may be able to **extract sensitive** data from them. It also interesting to test possible **SQL injections** and **Path Traversals** as they could be vulnerable.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Remember that a the actions of a Service start in the method `onStartCommand`.

Service je u suštini nešto što **može primati podatke**, **procesuirati** ih i **vraća** (ili ne) odgovor. Dakle, ako aplikacija izlaže neke servise trebalo bi da **proverite** **kod** da biste razumeli šta radi i **testirate** ga **dinamički** radi ekstrakcije poverljivih informacija, zaobilaženja mera autentifikacije...\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Remember that a the actions of a Broadcast Receiver start in the method `onReceive`.

A broadcast receiver will be waiting for a type of message. Depending on how the receiver handles the message it could be vulnerable.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

You can look for deep links manually, using tools like MobSF or scripts like [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
You can **open** a declared **scheme** using **adb** or a **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Napomena: možete **izostaviti naziv paketa**, i mobilni će automatski pozvati aplikaciju koja treba da otvori taj link._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Kod koji će se izvršiti**

Da biste pronašli **kod koji će se izvršiti u App**, idite na aktivnost koju poziva deeplink i potražite funkciju **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Osetljive informacije**

Svaki put kada nađeš deep link, proveri da li **ne prima osetljive podatke (npr. lozinke) preko URL parametara**, jer bilo koja druga aplikacija može **imitiirati deep link i ukrasti te podatke!**

**Parametri u putanji**

Treba da proveriš i da li neki deep link koristi parametar unutar putanje URL-a kao što je: `https://api.example.com/v1/users/{username}`, u tom slučaju možeš forsirati path traversal pristupom nečemu poput: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Napomena da ako pronađeš tačne endpoint-e unutar aplikacije možeš izazvati **Open Redirect** (ako se deo putanje koristi kao domain name), **account takeover** (ako možeš izmeniti korisničke podatke bez CSRF tokena i ranjivi endpoint koristi odgovarajuću metodu) i bilo koju drugu vuln. More [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

Jedan [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Inspekcija transportnog sloja i propusti u verifikaciji

- **Sertifikati nisu uvek pravilno proveravani** od strane Android aplikacija. Često ove aplikacije zanemare upozorenja i prihvate self-signed sertifikate ili, u nekim slučajevima, pređu na korišćenje HTTP konekcija.
- **Pregovori tokom SSL/TLS handshake-a ponekad su slabi**, koristeći nesigurne cipher suite-ove. Ova ranjivost čini vezu podložnom man-in-the-middle (MITM) napadima, omogućavajući napadačima da dešifruju podatke.
- **Leakage of private information** predstavlja rizik kada se aplikacije autentifikuju koristeći sigurne kanale, ali zatim komuniciraju preko nesigurnih kanala za druge transakcije. Ovakav pristup ne štiti osetljive podatke, kao što su session cookies ili podaci o korisnicima, od presretanja od strane zlonamernih entiteta.

#### Verifikacija sertifikata

Usredsredićemo se na **certificate verification**. Integritet serverovog sertifikata mora biti verifikovan radi povećanja bezbednosti. Ovo je ključno jer nesigurne TLS konfiguracije i prenos osetljivih podataka preko nešifrovanih kanala mogu predstavljati značajne rizike. Za detaljne korake o verifikaciji server sertifikata i rešavanju ranjivosti, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) pruža sveobuhvatne smernice.

#### SSL Pinning

SSL Pinning je bezbednosna mera gde aplikacija proverava serverov sertifikat prema poznatoj kopiji smeštenoj unutar same aplikacije. Ova metoda je esencijalna za sprečavanje MITM napada. Implementacija SSL Pinning-a je snažno preporučena za aplikacije koje rukuju osetljivim informacijama.

#### Inspekcija saobraćaja

Za inspekciju HTTP saobraćaja neophodno je **instalirati sertifikat proxy alata** (npr. Burp). Bez instalacije tog sertifikata, šifrovani saobraćaj možda neće biti vidljiv kroz proxy. Za vodič o instalaciji custom CA sertifikata, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Aplikacije koje ciljaju **API Level 24 and above** zahtevaju modifikacije Network Security Config-a da bi prihvatile CA sertifikat proxy-ja. Ovaj korak je kritičan za inspekciju šifrovanog saobraćaja. Za uputstva o modifikaciji Network Security Config-a, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

Ako se koristi **Flutter** treba da pratiš instrukcije na [**this page**](flutter.md). To je zato što samo dodavanje sertifikata u store neće funkcionisati, jer Flutter ima sopstvenu listu validnih CAs.

#### Statička detekcija SSL/TLS pinning

Pre nego što pokušaš runtime bypass-e, brzo mapiraj gde se pinning primenjuje u APK-u. Statičko otkrivanje pomaže da isplaniraš hooks/patches i da se fokusiraš na prave code paths.

Tool: SSLPinDetect
- Open-source statički alat za analizu koji dekompajlira APK u Smali (putem apktool) i skenira za kurirane regex obrasce implementacija SSL/TLS pinning.
- Izveštava tačnu putanju fajla, broj linije i code snippet za svaki match.
- Obuhvata common frameworks i custom code paths: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, i Network Security Config XML pins.

Instalacija
- Zahtevi: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Korišćenje
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Primer pravila obrasca (JSON)
Koristite ili proširite signatures da otkrijete proprietary/custom pinning styles. Možete učitati sopstveni JSON i scan at scale.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes and tips
- Brzo skeniranje velikih aplikacija putem multi-threading i memory-mapped I/O; pre-compiled regex smanjuje overhead/false positives.
- Kolekcija patterna: https://github.com/aancw/smali-sslpin-patterns
- Tipični ciljevi za dalju proveru:
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Prilagođeni SSL konteksti: SSLContext.getInstance + SSLContext.init with custom managers
- Deklarativni pins u res/xml network security config i manifest references
- Iskoristite podudarne lokacije da planirate Frida hooks, statičke patches, ili pregled konfiguracije pre dinamičkog testiranja.



#### Bypassing SSL Pinning

Kada je SSL Pinning implementiran, potrebno ga je zaobići da biste mogli da pregledate HTTPS saobraćaj. Postoji nekoliko metoda za to:

- Automatically **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Najveća prednost ove opcije je što vam neće trebati root da zaobiđete SSL Pinning, ali moraćete da obrišete aplikaciju i ponovo instalirate novu, i ovo neće uvek raditi.
- You could use **Frida** (discussed below) to bypass this protection. Ovde imate vodič za korišćenje Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- You can also try to **automatically bypass SSL Pinning** using [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- You can also try to **automatically bypass SSL Pinning** using **MobSF dynamic analysis** (explained below)
- If you still think that there is some traffic that you aren't capturing you can try to **forward the traffic to burp using iptables**. Pročitajte ovaj blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Looking for Common Web Vulnerabilities

Važno je takođe tražiti uobičajene web ranjivosti u okviru aplikacije. Detaljne informacije o identifikaciji i ublažavanju ovih ranjivosti prelaze okvir ovog sažetka, ali su opširno obrađene drugde.

### Frida

[Frida](https://www.frida.re) je alatka za dinamičku instrumentaciju za developere, reverse-inženjere i istraživače bezbednosti.\
**Možete pristupiti pokrenutoj aplikaciji i hook-ovati metode u runtime-u da promenite ponašanje, promenite vrednosti, izvučete vrednosti, pokrenete drugačiji kod...**\
Ako želite da radite pentesting Android aplikacija, morate znati kako se koristi Frida.

- Naučite kako koristiti Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Neki "GUI" za rad sa Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection je odličan za automatizaciju upotrebe Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Možete pronaći neke odlične Frida skripte ovde: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Pokušajte zaobići anti-debugging / anti-frida mehanizme učitavanjem Frida kao što je navedeno u [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (alat [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

Proverite da li aplikacija čuva osetljive informacije u memoriji koje ne bi trebalo da čuva, poput lozinki ili mnemonika.

Korišćenjem [**Fridump3**](https://github.com/rootbsd/fridump3) možete dump-ovati memoriju aplikacije sa:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Ovo će dump-ovati memoriju u ./dump folder, i tamo možete koristiti grep sa nečim poput:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Osetljivi podaci u Keystore**

Na Androidu, Keystore je najbolje mesto za čuvanje osetljivih podataka, međutim, uz dovoljne privilegije i dalje je **moguće mu je pristupiti**. Pošto aplikacije obično ovde čuvaju **osetljive podatke u clear text**, pentests bi trebalo da to provere, jer root user ili neko sa fizičkim pristupom uređaju može da ukrade te podatke.

Čak i ako aplikacija čuva podatke u Keystore-u, ti podaci bi trebalo da budu šifrovani.

Za pristup podacima unutar Keystore-a možete koristiti ovaj Frida script: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Korišćenjem sledećeg Frida skripta može biti moguće **bypass fingerprint authentication** koju Android aplikacije mogu izvoditi kako bi **zaštitile određene osetljive oblasti:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Pozadinske slike**

Kada aplikaciju pošaljete u pozadinu, Android čuva **snapshot aplikacije** tako da, kada se vrati u prednji plan, počne da učitava sliku pre same aplikacije, pa izgleda kao da je aplikacija učitana brže.

Međutim, ako taj snapshot sadrži **osetljive informacije**, neko sa pristupom snapshotu može **ukrasti te informacije** (napomena: za pristup je potreban root).

Snapshoti se obično nalaze na: **`/data/system_ce/0/snapshots`**

Android pruža način da **sprečite snimanje ekrana postavljanjem FLAG_SECURE** layout parametra. Korišćenjem ovog flag-a, sadržaj prozora se tretira kao siguran, čime se sprečava njegovo pojavljivanje u snimcima ekrana ili prikazivanje na nesigurnim ekranima.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Ovaj alat vam može pomoći u upravljanju različitim alatima tokom dinamičke analize: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Developeri često kreiraju proxy komponente kao što su activities, services i broadcast receivers koje obrađuju ove Intents i prosleđuju ih metodama kao što su `startActivity(...)` ili `sendBroadcast(...)`, što može biti rizično.

Opasnost leži u tome što napadači mogu pokrenuti non-exported app components ili pristupiti osetljivim content providers preusmeravanjem ovih Intents. Značajan primer je `WebView` komponenta koja konvertuje URL-ove u `Intent` objekte putem `Intent.parseUri(...)` i potom ih izvršava, što može dovesti do malicious Intent injections.

### Ključne napomene

- **Intent Injection** je sličan web Open Redirect issue.
- Eksploiti uključuju prosleđivanje `Intent` objekata kao extras, koji se mogu preusmeriti da izvrše nebezbedne operacije.
- Može izložiti non-exported components i content providers napadačima.
- `WebView` konverzija URL-a u `Intent` može olakšati neželjene akcije.

### Android Client Side Injections i ostalo

Verovatno već znate za ovakve ranjivosti sa Weba. Morate biti posebno oprezni sa ovim ranjivostima u Android aplikaciji:

- **SQL Injection:** Kod rada sa dinamičkim upitima ili Content-Providers, koristite parametrizovane upite.
- **JavaScript Injection (XSS):** Proverite da li je podrška za JavaScript i Plugin onemogućena za sve WebViews (disabled by default). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews bi trebalo onemogućiti pristup fajl sistemu (enabled by default) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: U nekoliko slučajeva, kada Android aplikacija završi sesiju, cookie nije opozvan ili može biti sačuvan na disku
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Static analysis**

![](<../../images/image (866).png>)

**Procena ranjivosti aplikacije** korišćenjem lepog web interfejsa. Takođe možete izvršiti dinamičku analizu (ali morate pripremiti okruženje).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Assisted Dynamic analysis with MobSF

**MobSF** can also be very helpful for **dynamic analysis** in **Android**, but in that case you will need to install MobSF and **genymotion** in your host (a VM or Docker won't work). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
The **MobSF dynamic analyser** can:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). All of this is done automatically except for the screenshots, you need to press when you want a screenshot or you need to press "**Exported Activity Tester**" to obtain screenshots of all the exported activities.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: It will print all the loaded classes
- **Capture Strings**: It will print all the capture strings while using the application (super noisy)
- **Capture String Comparisons**: Could be very useful. It will **show the 2 strings being compared** and if the result was True or False.
- **Enumerate Class Methods**: Put the class name (like "java.io.File") and it will print all the methods of the class.
- **Search Class Pattern**: Search classes by pattern
- **Trace Class Methods**: **Trace** a **whole class** (see inputs and outputs of all methods of th class). Remember that by default MobSF traces several interesting Android Api methods.

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf also brings you a shell with some **adb** commands, **MobSF commands**, and common **shell** **commands** at the bottom of the dynamic analysis page. Some interesting commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP tools**

Kada se http saobraćaj snimi možete videti ružan prikaz snimljenog saobraćaja u dnu na "**HTTP(S) Traffic**" ili lepši prikaz preko zelenog dugmeta "**Start HTTPTools**". Iz druge opcije možete **send** **captured requests** ka **proxies** kao što su Burp ili Owasp ZAP.\
Da biste to uradili, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> pritisnite "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Kada završite dinamičku analizu sa MobSF možete pritisnuti "**Start Web API Fuzzer**" da **fuzz http requests** i tražite ranjivosti.

> [!TIP]
> Nakon izvođenja dinamičke analize sa MobSF podešavanja proxy-ja mogu biti pogrešno konfigurisana i možda ih nećete moći ispraviti iz GUI-ja. Možete popraviti proxy podešavanja sledećom komandom:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

Možete preuzeti alat sa [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Ovaj alat koristi neke **Hooks** da bi vam pokazao **šta se dešava u aplikaciji** dok izvodite **dinamičku analizu**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Ovo je **odličan alat za izvođenje statičke analize sa GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Ovaj alat je dizajniran da traži više **security related Android application vulnerabilities**, bilo u **source code** ili u **packaged APKs**. Alat je takođe sposoban da kreira **"Proof-of-Concept" deployable APK** i **ADB commands**, da iskoristi neke od pronađenih ranjivosti (Exposed activities, intents, tapjacking...). Kao i kod Drozer, nema potrebe za root-ovanjem test uređaja.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Prikazuje sve izvađene fajlove radi lakšeg pregleda
- Automatski dekompajlira APK fajlove u Java i Smali format
- Analizira AndroidManifest.xml radi uobičajenih ranjivosti i ponašanja
- Statička source code analiza za uobičajene ranjivosti i ponašanja
- Informacije o uređaju
- i još više
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER je aplikacija za komandnu liniju koja se može koristiti na Windows, MacOS X i Linux, i analizira _.apk_ fajlove u potrazi za ranjivostima. 

To radi dekompresovanjem APKs i primenom niza pravila da bi otkrio te ranjivosti.

Sva pravila su smeštena u fajlu `rules.json`, a svaka kompanija ili tester može kreirati sopstvena pravila da analizira ono što im je potrebno.

Preuzmite najnovije binarne fajlove sa [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn je **crossplatform** alat koji pomaže razvijačima, bugbounty hunters i ethical hackers u izvođenju [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) na mobilnim aplikacijama.

Koncept je da prevučete i otpustite fajl vaše mobilne aplikacije (.apk ili .ipa file) na StaCoAn aplikaciju i on će vam generisati vizuelni i prenosivi izveštaj. Možete promeniti podešavanja i wordlists da biste dobili prilagođeno iskustvo.

Preuzmite[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework je sistem za analizu ranjivosti Android aplikacija koji pomaže developers or hackers da otkriju potencijalne sigurnosne propuste.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** je alat čiji je glavni cilj da detektuje i upozori korisnika na potencijalno zlonamerna ponašanja koju razvija Android aplikacija.

Detekcija se vrši pomoću **statičke analize** Dalvik bytecode-a aplikacije, predstavljenog kao **Smali**, uz pomoć biblioteke [`androguard`](https://github.com/androguard/androguard).

Ovaj alat traži **uobičajeno ponašanje "loših" aplikacija** kao što su: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** je **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. To je alat koji okuplja često korišćene alate za reverse engineering i analizu mobilnih aplikacija, kako bi pomogao pri testiranju mobilnih aplikacija protiv OWASP mobile security pretnji. Njegov cilj je da ovaj zadatak učini lakšim i pristupačnijim programerima mobilnih aplikacija i stručnjacima za bezbednost.

U stanju je da:

- Ekstrahuje Java i Smali kod koristeći različite alate
- Analizira APK-ove koristeći: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Ekstrahuje privatne informacije iz APK-a koristeći regexps.
- Analizira Manifest.
- Analizira pronađene domene koristeći: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) i [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuskira APK preko [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Koristan za detekciju malware-a: [https://koodous.com/](https://koodous.com/)

## Obfuskacija/Deobfuskacija koda

Imajte na umu da, u zavisnosti od servisa i konfiguracije koju koristite za obfuskaciju koda, tajne mogu ili ne moraju ostati obfuskovane.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

Iz [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** je open source command-line alat koji smanjuje, optimizuje i obfuskira Java kod. Može optimizovati bytecode kao i detektovati i ukloniti neiskorišćene instrukcije. ProGuard je besplatan softver i distribuira se pod GNU General Public License, verzija 2.

ProGuard se distribuira kao deo Android SDK-a i pokreće se prilikom build-anja aplikacije u release modu.

### [DexGuard](https://www.guardsquare.com/dexguard)

Pronađite step-by-step vodič za deobfuskaciju apk-a na [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(Iz tog vodiča) Poslednji put kada smo proveravali, način rada Dexguard-a je bio:

- učitaj resource kao InputStream;
- prosledi rezultat klasi koja nasleđuje od FilterInputStream da bi ga dekriptovala;
- uradi neku besmislenu obfuskaciju da izgubiš nekoliko minuta reversera;
- prosledi dekriptovani rezultat u ZipInputStream da bi dobio DEX fajl;
- konačno učitaj nastali DEX kao Resource koristeći `loadDex` metodu.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverzuje proces obfuskacije koji izvode Android obfuscation alati. Ovo omogućava brojne analize bezbednosti, uključujući inspekciju koda i predviđanje biblioteka.**

Možete upload-ovati obfuskirani APK na njihovu platformu.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

Ovo je LLM alat za pronalaženje potencijalnih sigurnosnih ranjivosti u android aplikacijama i deobfuskaciju android app koda. Koristi Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

To je **generic android deobfuscator.** Simplify **virtually izvršava aplikaciju** da razume njeno ponašanje i zatim **pokušava da optimizuje kod** tako da se ponaša identično, ali bude lakši za čoveka da razume. Svaki tip optimizacije je jednostavan i generički, tako da nije važno koji tačno tip obfuskacije je korišćen.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD vam daje informacije o **kako je APK napravljen**. Identifikuje mnoge **compilers**, **packers**, **obfuscators**, i druge čudne stvari. To je [_PEiD_](https://www.aldeid.com/wiki/PEiD) za Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b je Android security virtualna mašina bazirana na ubuntu-mate koja uključuje kolekciju najnovijih framework-ova, tutorijala i labova od različitih security geeka i istraživača za reverse engineering i malware analizu.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) To je odlična lista resursa
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)

## Yet to try

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
