# Android Toepassings Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android Toepassings Basiese beginsels

Dit word sterk aanbeveel om eers hierdie bladsy te lees om meer te weet oor die **belangrikste dele wat verband hou met Android-sekuriteit en die gevaarlikste komponente in 'n Android-toepassing**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Dit is die hoofgereedskap wat jy benodig om met 'n Android-toestel (geëmuleer of fisies) te verbind.\
**ADB** laat toe om toestelle te beheer óf oor **USB** óf oor **Network** vanaf 'n rekenaar. Hierdie hulpmiddel maak dit moontlik om lêers in albei rigtings te **kopieer**, apps te **installeer** en te **deïnstalleer**, shell-opdragte uit te **voer**, data te **rugsteun**, logs te **lees**, en ander funksies.

Kyk na die volgende lys van [**ADB Commands**](adb-commands.md) om te leer hoe om adb te gebruik.

## Smali

Soms is dit interessant om die **aansoekkode te wysig** om by **weggesteekte inligting** te kom (bv. goed geobfuskate wagwoorde of flags). Dan kan dit interessant wees om die apk te dekompileer, die kode te wysig en dit weer saam te stel.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Dit kan baie nuttig wees as 'n **alternatief vir verskeie toetse tydens die dinamiese analise** wat aangebied gaan word. Hou dus **altyd hierdie moontlikheid in gedagte**.

## Ander interessante wenke

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Onttrek APK vanaf toestel:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Voeg alle splits en base apks saam met [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Gevallestudies & Kwetsbaarhede


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Statiese Analise

Eerstens, om 'n APK te ontleed, behoort jy **na die Java code te kyk** met 'n dekompiler.\
Please, [**read here to find information about different available decompilers**](apk-decompilers.md).

### Op soek na interessante inligting

Net deur na die **strings** van die APK te kyk kan jy soek na **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** en enigiets interessant... kyk selfs vir code execution **backdoors** of authentication backdoors (hardcoded admin credentials to the app).

**Firebase**

Gee besondere aandag aan **firebase URLs** en kontroleer of dit swak gekonfigureer is. [More information about whats is FIrebase and how to exploit it here.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Basiese begrip van die aansoek - Manifest.xml, strings.xml

Die **ondersoek van 'n aansoek se _Manifest.xml_ en _strings.xml_ lêers kan potensiële sekuriteitskwesbaarhede openbaar**. Hierdie lêers kan verkry word met behulp van dekompilers of deur die APK-lêeruitbreiding na .zip te hernoem en dit dan uit te pak.

**Kwetsbaarhede** geïdentifiseer uit die **Manifest.xml** sluit in:

- **Debuggable Applications**: Toepassings wat as debuggable gestel is (`debuggable="true"`) in die _Manifest.xml_ lêer vorm 'n risiko aangesien hulle verbindings toelaat wat tot uitbuiting kan lei. Vir meer begrip oor hoe om debuggable toepassings te misbruik, verwys na 'n handleiding oor die vind en benut van debuggable toepassings op 'n toestel.
- **Backup Settings**: Die `android:allowBackup="false"` attribuut moet eksplisiet gestel word vir toepassings wat met sensitiewe inligting werk om ongemagtigde data-rugsteun via adb te voorkom, veral wanneer usb debugging aangeskakel is.
- **Network Security**: Pasgemaakte network security konfigurasies (`android:networkSecurityConfig="@xml/network_security_config"`) in _res/xml/_ kan sekuriteitsbesonderhede soos certificate pins en HTTP-verkeerinstellings spesifiseer. 'n Voorbeeld is om HTTP-verkeer vir spesifieke domeine toe te laat.
- **Exported Activities and Services**: Die identifisering van exported activities en services in die manifest kan komponente uitlig wat misbruik kan word. Verdere analise gedurende dinamiese toetsing kan openbaar hoe om hierdie komponente te benut.
- **Content Providers and FileProviders**: Blootgestelde content providers kan ongemagtigde toegang of wysiging van data toelaat. Die konfigurasie van FileProviders moet ook noukeurig ondersoek word.
- **Broadcast Receivers and URL Schemes**: Hierdie komponente kan benut word vir uitbuiting, met besondere aandag aan hoe URL schemes vir inset-kwessies bestuur word.
- **SDK Versions**: Die `minSdkVersion`, `targetSDKVersion`, en `maxSdkVersion` attributen dui die ondersteunede Android weergawes aan, wat die belangrikheid beklemtoon om nie verouderde, kwesbare Android weergawes te ondersteun nie.

Uit die **strings.xml** lêer kan sensitiewe inligting soos API keys, custom schemas en ander ontwikkelaarnotas ontdek word, wat die behoefte aan 'n deeglike hersiening van hierdie hulpbronne beklemtoon.

### Tapjacking

**Tapjacking** is 'n aanval waar 'n **malicious** **application** gelanseer word en homself bo-op 'n victim application posisioneer. Sodra dit die victim app sigbaar verberg, is sy gebruikerskoppelvlak so ontwerp dat dit die gebruiker mislei om daarmee te interaksie, terwyl dit die interaksie aan die victim app deurgee. Effektief blind dit die gebruiker ten opsigte daarvan dat hulle eintlik aksies op die victim app uitvoer.

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

'n activity met die `launchMode` gestel op `singleTask` sonder enige `taskAffinity` gedefinieer is kwesbaar vir Task Hijacking. Dit beteken dat 'n application geïnstalleer kan word en as dit voor die werklike application gelanseer word, kan dit die taak van die werklike application kap (sodat die gebruiker met die malicious application sal interaksie hê terwyl hy dink hy gebruik die werklike een).

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Onveilige datastoor

**Internal Storage**

In Android is lêers wat in **internal** storage gestoor word bedoel om uitsluitlik deur die app wat dit geskep het toeganklik te wees. Hierdie sekuriteitsmaatreël word deur die Android bedryfstelsel afgedwing en is gewoonlik voldoende vir die sekuriteitsbehoeftes van meeste toepassings. Ontwikkelaars gebruik soms egter modusse soos `MODE_WORLD_READABLE` en `MODE_WORLD_WRITABLE` om lêers tussen verskeie toepassings te deel. Hierdie modusse beperk egter nie toegang tot hierdie lêers deur ander toepassings nie, insluitende potensieel malicious ones.

1. **Static Analysis:**
- **Ensure** dat die gebruik van `MODE_WORLD_READABLE` en `MODE_WORLD_WRITABLE` noukeurig geïnspekteer word. Hierdie modusse **kan moontlik** lêers aan **onbedoelde of ongemagtigde toegang** blootstel.
2. **Dynamic Analysis:**
- **Verify** die **permissions** wat op lêers geskep deur die app gestel is. Spesifiek, **kontroleer** of enige lêers ingestel is om wêreldwyd lees- of skryftoegang te hê. Dit kan 'n beduidende sekuriteitsrisiko inhou, aangesien dit **enige application** geïnstalleer op die toestel toelaat, ongeag oorsprong of doel, om hierdie lêers te **lees of wysig**.

**External Storage**

Wanneer jy met lêers op **external storage** werk, soos SD Cards, moet sekere voorsorgmaatreëls getref word:

1. **Accessibility**:
- Lêers op external storage is **globaal leesbaar en skryfbaar**. Dit beteken enige application of gebruiker kan toegang hê tot hierdie lêers.
2. **Security Concerns**:
- Gegewe die maklike toegang, word dit aanbeveel **om nie sensitiewe inligting op external storage te stoor nie**.
- External storage kan verwyder of deur enige application benader word, wat dit minder veilig maak.
3. **Handling Data from External Storage**:
- Voer altyd **input validation** uit op data wat van external storage verkry is. Dit is kritiek omdat die data van 'n onbetroubare bron afkomstig is.
- Dit word sterk ontraden om uitvoerbare lêers of class files op external storage te stoor vir dinamiese laai.
- As jou toepassing uitvoerbare lêers van external storage moet herwin, maak seker dat hierdie lêers **signed and cryptographically verified** is voordat hulle dinamies gelaai word. Hierdie stap is noodsaaklik om die sekuriteitsintegriteit van jou toepassing te handhaaf.

External storage kan geakses word in `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> Starting with Android 4.4 (**API 17**), the SD card has a directory structure which **limits access from an app to the directory which is specifically for that app**. This prevents malicious application from gaining read or write access to another app's files.

**Sensitiewe data gestoor in duidelike teks**

- **Shared preferences**: Android laat elke application toe om maklik xml lêers te stoor in die pad `/data/data/<packagename>/shared_prefs/` en soms is dit moontlik om sensitiewe inligting in duidelike teks in daardie gids te vind.
- **Databases**: Android laat elke application toe om maklik sqlite databases te stoor in die pad `/data/data/<packagename>/databases/` en soms is dit moontlik om sensitiewe inligting in duidelike teks in daardie gids te vind.

### Broken TLS

**Accept All Certificates**

Om sommige redes aanvaar ontwikkelaars soms alle sertifikate selfs al stem byvoorbeeld die hostname nie ooreen nie met reëls van kode soos die volgende een:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Gebroke Kriptografie

**Swakke Sleutelbestuursprosedures**

Sommige ontwikkelaars stoor sensitiewe data in plaaslike stoorplekke en enkripteer dit met 'n sleutel wat hardgekodeer/voorspelbaar in die kode is. Dit behoort nie so te wees nie, aangesien reversing aanvallers kan toelaat om die vertroulike inligting te onttrek.

**Gebruik van Onveilige en/of Verouderde Algoritmes**

Ontwikkelaars moet nie **deprecated algorithms** gebruik om autorisasie-**checks**, data te **store** of te **send** nie. Sommige van hierdie algoritmes is: RC4, MD4, MD5, SHA1... As **hashes** byvoorbeeld gebruik word om wagwoorde te stoor, moet **brute-force resistant** hashes met salt gebruik word.

### Ander kontroles

- Dit word aanbeveel om die **APK te obfuskeer** om die omgekeerde-ingenieurswerk vir aanvallers moeiliker te maak.
- As die app sensitief is (soos bankapps), moet dit sy **eie kontroles uitvoer om te sien of die mobile toestel geroot is** en dienooreenkomstig optree.
- As die app sensitief is (soos bankapps), moet dit nagaan of 'n **emulator** gebruik word.
- As die app sensitief is (soos bankapps), moet dit **sy eie integriteit kontroleer voordat dit uitgevoer word** om te sien of dit gewysig is.
- Gebruik [**APKiD**](https://github.com/rednaga/APKiD) om te kontroleer watter compiler/packer/obfuscator gebruik is om die APK te bou

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

Die tool [**mariana-trench**](https://github.com/facebook/mariana-trench) kan **vulnerabilities** opspoor deur die **code** van die toepassing te **scan**. Hierdie tool bevat 'n reeks **known sources** (wat vir die tool aandui die **places** waar die **input** deur die gebruiker beheer word), **sinks** (wat die tool aandui die **dangerous** **places** waar kwaadwillige gebruiker-input skade kan veroorsaak) en **rules**. Hierdie reëls dui die **combination** van **sources-sinks** aan wat 'n kwetsbaarheid aandui.

Met hierdie kennis sal **mariana-trench** die **code** hersien en moontlike **vulnerabilities** daarin vind.

### Geheime leak

'n Toepassing kan geheime bevat (API keys, wagwoorde, hidden urls, subdomains...) binne-in wat jy moontlik kan ontdek. Jy kan 'n hulpmiddel soos [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks) gebruik.

### Omseil Biometriese Verifikasie


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Ander interessante funksies

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dinamiese Analise

> Eerstens het jy 'n omgewing nodig waar jy die toepassing en al die benodigdhede kan installeer (veral Burp CA-sertifikaat, Drozer en Frida). Daarom word 'n gerootde toestel (geëmuleer of nie) uiters aanbeveel.

### Aanlyn Dinamiese analise

Jy kan 'n **gratis rekening** skep by: [https://appetize.io/](https://appetize.io). Hierdie platform laat jou toe om APKs te **upload** en te **execute**, dus is dit nuttig om te sien hoe 'n apk optree.

Jy kan selfs **die logs van jou toepassing** op die web sien en via **adb** koppel.

![](<../../images/image (831).png>)

Danksy die ADB-verbinding kan jy **Drozer** en **Frida** binne die emulators gebruik.

### Lokale Dinamiese Analise

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (You can create **x86** and **arm** devices, and according to [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** versions **support ARM libraries** without needing an slow arm emulator).
- Learn to set it up in this page:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, you need to create an account. _It's recommend to **download** the version **WITH**_ _**VirtualBox** to avoid potential errors._)
- [**Nox**](https://es.bignox.com) (Free, but it doesn't support Frida or Drozer).

> [!TIP]
> Wanneer jy 'n nuwe emulator op enige platform skep, onthou dat hoe groter die skerm is, hoe stadiger sal die emulator loop. Kies dus kleiner skerms indien moontlik.

Om **google services** (soos AppStore) in Genymotion te **installeer** moet jy op die rooi gemerkde knoppie in die volgende beeld klik:

![](<../../images/image (277).png>)

Neem ook kennis dat in die **konfigurasie van die Android VM in Genymotion** jy **Bridge Network mode** kan kies (dit sal nuttig wees as jy vanaf 'n ander VM met die gereedskap na die Android VM sal koppel).

#### Use a physical device

Jy moet die **debugging**-opsies aktiveer en dit sal handig wees as jy dit kan **root**:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Sodra jy die toepassing geïnstalleer het, moet jy dit eers probeer en ondersoek wat dit doen, hoe dit werk en gemaklik raak daarmee.\
> Ek stel voor om hierdie aanvanklike dinamiese analise uit te voer met MobSF dynamic analysis + pidcat, sodat ons kan **leer hoe die toepassing werk** terwyl MobSF baie **interesting** **data** vasvang wat jy later kan hersien.

### Onbedoelde Data leak

**Logging**

Ontwikkelaars moet versigtig wees om **debugging information** publiek bloot te stel, aangesien dit tot sensitiewe data leaks kan lei. Die gereedskap [**pidcat**](https://github.com/JakeWharton/pidcat) en `adb logcat` word aanbeveel om toepassingslogs te monitor en sensitiewe inligting te identifiseer en te beskerm. **Pidcat** word verkies vir sy gebruiksgemak en leesbaarheid.

> [!WARNING]
> Neem kennis dat vanaf **later newer than Android 4.0**, **applications are only able to access their own logs**. Dus kan toepassings nie ander apps se logs toegang nie.\
> Dit word steeds aanbeveel om **nie sensitiewe inligting te log nie**.

**Copy/Paste Buffer Caching**

Android se **clipboard-based** raamwerk bied copy-paste funksionaliteit in apps, maar dra 'n risiko omdat **ander applications** die clipboard kan **access**, wat potensieel sensitiewe data kan blootstel. Dit is belangrik om copy/paste funksies te **disable** vir sensitiewe dele van 'n toepassing, soos kredietkaartbesonderhede, om data leaks te voorkom.

**Crash Logs**

As 'n toepassing **crash** en logs stoor, kan hierdie logs aanvallers help, veral wanneer die toepassing nie maklik omgekeerd kan word nie. Om hierdie risiko te verminder, moet jy vermy om op crashes te log, en as logs oor die netwerk gestuur moet word, moet dit via 'n SSL-kanaal gestuur word.

As 'n pentester, **probeer om na hierdie logs te kyk**.

**Analytics Data Sent To 3rd Parties**

Toepassings integreer dikwels dienste soos Google Adsense, wat per ongeluk sensitiewe data kan leak as dit verkeerd geïmplementeer is deur ontwikkelaars. Om moontlike data leaks te identifiseer, is dit raadsaam om die toepassing se verkeer te onderskep en te kontroleer of sensitiewe inligting na derdepartye gestuur word.

### SQLite DBs

Die meeste toepassings gebruik **internal SQLite databases** om inligting te stoor. Tydens die pentest kyk na die **databases** wat geskep is, die name van **tables** en **columns** en al die **data** wat gestoor is, aangesien jy sensitiewe inligting kan vind (wat 'n kwetsbaarheid sou wees).\
Databases behoort te wees in `/data/data/the.package.name/databases` soos `/data/data/com.mwr.example.sieve/databases`

As die databasis vertroulike inligting stoor en **encrypted** is maar jy kan die **password** binne die toepassing **find**, is dit steeds 'n **vulnerability**.

Nommer die tabelle met `.tables` en lys die kolomme van 'n tabel met `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** laat jou toe om die **rol van 'n Android app aan te neem** en met ander apps te interakteer. Dit kan **enige iets doen wat 'n geïnstalleerde toepassing kan doen**, soos gebruik maak van Android se Inter-Process Communication (IPC) meganisme en met die onderliggende bedryfstelsel interakteer. .\
Drozer is 'n nuttige tool om **exported activities, exported services en Content Providers te exploit** soos jy in die volgende afdelings sal leer.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Onthou ook dat die kode van 'n activity begin in die **`onCreate`** metode.

**Authorisation bypass**

Wanneer 'n Activity geëxporteer is kan jy sy skerm vanaf 'n eksterne app oproep. Daarom, as 'n activity met **sensitive information** **exported** is, kan jy die **authentication** meganismes **bypass** om toegang daartoe te kry.

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

Jy kan ook 'n exported activity vanaf adb begin:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**OPMERKING**: MobSF sal die gebruik van _**singleTask/singleInstance**_ as `android:launchMode` in 'n activity as kwaadwillig beskou, maar weens [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750) blyk dit net gevaarlik te wees op ouer weergawes (API versions < 21).

> [!TIP]
> Let wel dat 'n authorisation bypass nie altyd 'n kwesbaarheid is nie; dit hang af van hoe die bypass werk en watter inligting blootgestel word.

**Gevoelige inligtinglekkasie**

**Activities can also return results**. As jy 'n exported en onbeveiligde activity vind wat die **`setResult`**-metode aanroep en **gevoelige inligting teruggee**, is daar 'n gevoelige inligtinglekkasie.

#### Tapjacking

As Tapjacking nie voorkom word nie, kan jy die exported activity misbruik om die **gebruiker onverwante aksies te laat uitvoer**. Vir meer info oor [**wat is Tapjacking — volg die skakel**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Lees dit as jy wil hernu wat 'n Content Provider is.**](android-applications-basics.md#content-provider)\
Content providers word basies gebruik om **data te deel**. As 'n app beskikbare content providers het, kan jy dalk **sensitiewe data** daaruit onttrek. Dit is ook interessant om moontlike **SQL injections** en **Path Traversals** te toets aangesien hulle kwesbaar kan wees.

[**Leer hoe om Content Providers met Drozer te benut.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Lees dit as jy wil hernu wat 'n Service is.**](android-applications-basics.md#services)\
Onthou dat die optrede van 'n Service begin in die metode `onStartCommand`.

'n Service is basies iets wat **data kan ontvang**, dit **verwerk** en (al dan nie) 'n antwoord **teruggee**. As 'n aansoek dus sommige services exporteer, moet jy die **kode** nagaan om te verstaan wat dit doen en dit **dinamies** toets om vertroulike inligting te onttrek, verifikasie-maatreëls te omseil...\
[**Leer hoe om Services met Drozer te benut.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Lees dit as jy wil hernu wat 'n Broadcast Receiver is.**](android-applications-basics.md#broadcast-receivers)\
Onthou dat die optrede van 'n Broadcast Receiver begin in die metode `onReceive`.

'n Broadcast receiver sal wag vir 'n tipe boodskap. Afhangend van hoe die receiver die boodskap hanteer, kan dit kwesbaar wees.\
[**Leer hoe om Broadcast Receivers met Drozer te benut.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Jy kan handmatig na deep links soek deur gereedskap soos MobSF of skripte soos [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py) te gebruik.\
Jy kan 'n verklaarde **scheme** oopmaak met **adb** of 'n **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Let wel dat jy die **package name** kan weglaat en die mobiele toestel sal outomaties die app oproep wat daardie link behoort te open._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Kode uitgevoer**

Om die **kode wat in die app uitgevoer sal word** te vind, gaan na die activity wat deur die deeplink aangeroep word en soek die funksie **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Sensitiewe inligting**

Elke keer as jy 'n deep link vind, kontroleer dat dit nie sensitiewe data (soos wagwoorde) via URL parameters ontvang nie, want enige ander toepassing kan die deep link nadoen en daardie data steel!

**Parameters in pad**

Jy moet ook kyk of enige deep link 'n parameter binne die pad van die URL gebruik soos: `https://api.example.com/v1/users/{username}` , in daardie geval kan jy 'n path traversal dwing deur iets soos te benader: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Neem kennis dat as jy die korrekte endpoints binne die toepassing vind, jy dalk 'n **Open Redirect** kan veroorsaak (as deel van die path as domain name gebruik word), **account takeover** (as jy gebruikersdetails kan wysig sonder CSRF token en die vuln endpoint die korrekte metode gebruik) en enige ander vuln. Meer [info hieroor](http://dphoeniixx.com/2020/12/13-2/).

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Transportlaag-inspeksie en verifikasie-foute

- **Sertifikate word nie altyd behoorlik geïnspekteer nie** deur Android-toepassings. Dit is algemeen dat hierdie toepassings waarskuwings ignoreer en self-signed sertifikate aanvaar of, in sommige gevalle, terugval na die gebruik van HTTP-verbindinge.
- **Onderhandelinge tydens die SSL/TLS-handshake is soms swak**, en gebruik onveilige cipher suites. Hierdie kwesbaarheid maak die verbinding vatbaar vir man-in-the-middle (MITM)-aanvalle, wat aanvallers in staat stel om die data te ontsleutel.
- **Leakage of private information** is 'n risiko wanneer toepassings met sekure kanale autentiseer, maar dan oor nie-sekure kanale kommunikeer vir ander transaksies. Hierdie benadering beskerm nie sensitiewe data, soos sessie cookies of gebruikerbesonderhede, teen onderskep deur kwaadwilliges nie.

#### Certificate Verification

Ons sal fokus op **certificate verification**. Die integriteit van die bediener se sertifikaat moet geverifieer word om sekuriteit te verbeter. Dit is van kritieke belang omdat onveilige TLS-konfigurasies en die oordrag van sensitiewe data oor onversleutelde kanale beduidende risiko's kan inhou. Vir gedetailleerde stappe oor die verifikasie van bediener-sertifikate en die aanspreek van kwesbaarhede, bied [**hierdie hulpbron**](https://manifestsecurity.com/android-application-security-part-10/) omvattende leiding.

#### SSL Pinning

SSL Pinning is 'n sekuriteitsmaatreël waar die toepassing die bediener se sertifikaat verifieer teen 'n bekende kopie wat binne die toepassing self gestoor is. Hierdie metode is noodsaaklik om MITM-aanvalle te voorkom. Dit word sterk aanbeveel om SSL Pinning te implementeer vir toepassings wat sensitiewe inligting hanteer.

#### Verkeersinspeksie

Om HTTP-verkeer te inspekteer, is dit nodig om die proxy-instrument se sertifikaat te installeer (bv. Burp). Sonder om hierdie sertifikaat te installeer, mag versleutelde verkeer nie deur die proxy sigbaar wees nie. Vir 'n gids oor die installering van 'n pasgemaakte CA-sertifikaat, [**klik hier**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Toepassings wat mik op **API Level 24 and above** vereis wysigings aan die Network Security Config om die proxy se CA-sertifikaat te aanvaar. Hierdie stap is krities vir die inspeksie van versleutelde verkeer. Vir instruksies oor die wysiging van die Network Security Config, [**verwys na hierdie handleiding**](make-apk-accept-ca-certificate.md).

As **Flutter** gebruik word, moet jy die instruksies op [**hierdie bladsy**](flutter.md) volg. Dit is omdat net om die sertifikaat by die store te voeg nie sal werk nie, aangesien Flutter sy eie lys geldige CAs het.

#### Statiese deteksie van SSL/TLS pinning

Voordat jy runtime-bypasses probeer, karteer vinnig waar pinning in die APK afgedwing word. Statiese opsporing help jou om hooks/patches te beplan en te fokus op die regte code paths.

Tool: SSLPinDetect
- Open-source static-analysis nut wat die APK na Smali dekompileer (via apktool) en skandeer vir gekureerde regex-patrone van SSL/TLS pinning-implementasies.
- Rapporteer die presiese file path, line number en 'n code snippet vir elke ooreenkoms.
- Dek algemene frameworks en custom code paths: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init met custom TrustManagers/KeyManagers, en Network Security Config XML pins.

Installeer
- Vereistes: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Gebruik
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Voorbeeld patroonreëls (JSON)
Gebruik of brei signatures uit om proprietary/custom pinning styles te detecteer. Jy kan jou eie JSON laai en op skaal scan.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Aantekeninge en wenke
- Vinnige skandering op groot apps via multi-threading en memory-mapped I/O; vooraf-gecompileerde regex verminder oorhoofse vrag/vals positiewe.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Tipiese detectiedoelwitte om volgende te triage:
- OkHttp: CertificatePinner gebruik, setCertificatePinner, okhttp3/okhttp pakketverwysings
- Aangepaste TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted oorskrywings
- Aangepaste SSL-kontekste: SSLContext.getInstance + SSLContext.init met aangepaste managers
- Deklaratiewe pins in res/xml network security config en manifest verwysings
- Gebruik die ooreenstemmende lokasies om Frida hooks, statiese patching, of konfigurasie-audits te beplan voordat jy dinamiese toetsing doen.



#### Om SSL Pinning te omseil

Wanneer SSL Pinning geïmplementeer is, word dit nodig om dit te omseil om HTTPS-verkeer te inspekteer. Verskeie metodes is beskikbaar vir hierdie doel:

- Outomaties **wysig** die **apk** om SSLPinning te **omseil** met [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Die grootste voordeel van hierdie opsie is dat jy nie root nodig het om die SSL Pinning te omseil nie, maar jy sal die toepassing moet verwyder en die nuwe een herinstalleer, en dit sal nie altyd werk nie.
- Jy kan **Frida** gebruik (hieronder bespreek) om hierdie beskerming te omseil. Hier is 'n gids om Burp+Frida+Genymotion te gebruik: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Jy kan ook probeer om SSL Pinning outomaties te omseil deur [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Jy kan ook probeer om SSL Pinning outomaties te omseil deur **MobSF dynamic analysis** (hieronder verduidelik)
- As jy steeds dink daar is verkeer wat jy nie vang nie, kan jy probeer om die verkeer na Burp te stuur met iptables. Lees hierdie blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Soek na algemene web-kwesbaarhede

Dit is belangrik om ook te soek na algemene web-kwesbaarhede binne die toepassing. Gedetailleerde inligting oor die identifisering en verligting van hierdie kwesbaarhede val buite die omvang van hierdie samevatting, maar word elders uitvoerig behandel.

### Frida

[Frida](https://www.frida.re) is 'n dinamiese instrumentasie toolkit vir ontwikkelaars, reverse-engineers, en sekuriteitsnavorsers.\
**Jy kan toegang tot 'n lopende toepassing kry en metodes op runtime hook om gedrag te verander, waardes te verander, waardes te onttrek, ander kode uit te voer...**\
As jy Android-toepassings wil pentest, moet jy weet hoe om Frida te gebruik.

- Leer hoe om Frida te gebruik: [**Frida tutorial**](frida-tutorial/index.html)
- Sommige "GUI" vir aksies met Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is uitstekend om die gebruik van Frida te outomatiseer: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Jy kan 'n paar Awesome Frida-skripte hier vind: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Probeer om anti-debugging / anti-frida meganismes te omseil deur Frida te laai soos aangedui in [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (hulpmiddel [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentasie & SSL pinning omseil-werkvloei

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

Kyk of die toepassing sensitiewe inligting in die geheue stoor wat dit nie behoort te stoor nie, soos wagwoorde of mnemonics.

Met [**Fridump3**](https://github.com/rootbsd/fridump3) kan jy die geheue van die app dump met:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Dit sal die geheue in die ./dump map dump, en daarbinne kan jy met iets soos grep:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Sensitiewe data in Keystore**

In Android is die Keystore die beste plek om sensitiewe data te stoor, maar met genoeg voorregte is dit steeds **moontlik om daartoe toegang te kry**. Aangesien toepassings geneig is om hier **sensitiewe data in platte teks** te stoor, moet pentests dit as root user of iemand met fisiese toegang tot die toestel nagaan, aangesien hulle hierdie data kan steel.

Selfs as 'n app data in die Keystore stoor, moet die data versleuteld wees.

Om toegang tot die data binne die Keystore te kry, kan jy hierdie Frida script gebruik: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Met die volgende Frida-script kan dit moontlik wees om **bypass fingerprint authentication** wat Android-toepassings mag uitvoer om **sekere sensitiewe gebiede te beskerm:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Agtergrondbeelde**

Wanneer jy 'n toepassing na die agtergrond plaas, stoor Android 'n **snapshot van die toepassing**, sodat wanneer dit weer in die voorgrond herstel word, dit eers die beeld laai voordat die app volledig opstart, wat die indruk skep dat die app vinniger gelaai is.

As hierdie snapshot egter **gevoelige inligting** bevat, kan iemand met toegang tot die snapshot daardie inligting **steel** (let wel: jy benodig root om dit te bereik).

Die snapshots word gewoonlik gestoor by: **`/data/system_ce/0/snapshots`**

Android bied 'n manier om die **opname van skermskote te voorkom deur die FLAG_SECURE te stel** layout-parameter. Deur hierdie flag te gebruik, word die vensterinhoud as veilig beskou, wat verhoed dat dit in skermskote verskyn of op nie-veilige skerms vertoon word.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Toepassingsontleder**

Hierdie instrument kan jou help om verskillende gereedskap tydens dinamiese analise te bestuur: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Ontwikkelaars skep dikwels proxy-komponente soos activities, services, en broadcast receivers wat hierdie Intents hanteer en dit aan metodes soos `startActivity(...)` of `sendBroadcast(...)` deurgee, wat riskant kan wees.

Die gevaar lê daarin om aanvallers toe te laat om nie-exported app-komponente te trigger of sensitiewe content providers te bereik deur hierdie Intents verkeerd te rig. 'n Merkwaardige voorbeeld is die `WebView`-komponent wat URLs na `Intent`-objekte omskakel via `Intent.parseUri(...)` en dan uitvoer, wat moontlik tot kwaadwillige Intent-inspuitings kan lei.

### Belangrike punte

- **Intent Injection** is soortgelyk aan 'n web Open Redirect-kwessie.
- Eksploite behels die deurgee van `Intent`-objekte as extras, wat omgerig kan word om onveilige operasies uit te voer.
- Dit kan nie-exported komponente en content providers aan aanvallers blootstel.
- Die `WebView` se URL-na-`Intent` omskakeling kan onbedoelde aksies vergemaklik.

### Android kliëntkant-inspuitings en ander

Jy ken hierdie soort kwesbaarhede waarskynlik van die web. Jy moet besonders versigtig wees met hierdie kwesbaarhede in 'n Android-toepassing:

- **SQL Injection:** Wanneer jy met dinamiese queries of Content-Providers werk, maak seker dat jy parameterized queries gebruik.
- **JavaScript Injection (XSS):** Verifieer dat JavaScript- en plugin-ondersteuning gedeaktiveer is vir enige WebViews (gedeaktiveer per verstek). [Meer inligting hier](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews moet toegang tot die lêerstelsel gedeaktiveer hê (geaktiveer per verstek) - `(webview.getSettings().setAllowFileAccess(false);)`. [Meer inligting hier](webview-attacks.md#javascript-enabled).
- **Eternal cookies:** In verskeie gevalle, wanneer die Android-toepassing die sessie beëindig, word die cookie nie herroep nie of dit kan selfs op skyf gestoor word
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatiese analise

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Statiese analise**

![](<../../images/image (866).png>)

**Kwetsbaarheidsassessering van die toepassing** gebruik 'n mooi web-gebaseerde frontend. Jy kan ook dinamiese analise uitvoer (maar jy moet die omgewing voorberei).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Geassisteerde dinamiese ontleding met MobSF

**MobSF** kan ook baie nuttig wees vir **dinamiese ontleding** op **Android**, maar in daardie geval moet jy MobSF en **genymotion** op jou host installeer (’n VM of Docker sal nie werk nie). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
Die **MobSF dynamic analyser** kan:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). Al hierdie data word outomaties versamel behalwe die skermkiekies — jy moet die knoppie druk wanneer jy ’n skermkiekie wil hê of jy moet "**Exported Activity Tester**" druk om skermkiekies van alle exported activities te verkry.
- Vasvang **HTTPS traffic**
- Gebruik **Frida** om **runtime** **information** te verkry

Vanaf Android **versions > 5** sal dit **automatically start Frida** en globale **proxy**-instellings opstel om verkeer vas te vang. Dit sal slegs verkeer van die getoetste toepassing vang.

**Frida**

Standaard sal dit ook ’n paar Frida-skripte gebruik om **bypass SSL pinning**, **root detection** en **debugger detection** te omseil en om **monitor interesting APIs**.\
MobSF kan ook **invoke exported activities**, gryp **screenshots** daarvan en **save** dit vir die verslag.

Om die dinamiese toetsing te **start**, druk die groen knop: "**Start Instrumentation**". Druk op "**Frida Live Logs**" om die logs te sien wat deur die Frida-skripte gegenereer word en "**Live API Monitor**" om alle invokasies na hooked methods, die deurgegewe argumente en die teruggegewe waardes te sien (dit sal verskyn nadat jy "Start Instrumentation" gedruk het).\
MobSF laat jou ook toe om jou eie **Frida scripts** te laad (om die resultate van jou Frida-skripte na MobSF te stuur, gebruik die funksie `send()`). Dit het ook **several pre-written scripts** wat jy kan laai (jy kan meer byvoeg in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), kies hulle net, druk "**Load**" en druk "**Start Instrumentation**" (jy sal die logs van daardie skripte binne "**Frida Live Logs**" kan sien).

![](<../../images/image (419).png>)

Verder het jy ’n paar bykomende Frida-funksionaliteite:

- Enumerate Loaded Classes: Dit sal al die gelaaide classes uitdruk
- Capture Strings: Dit sal alle gevangen strings uitdruk terwyl die toepassing gebruik word (baie luidrugtig)
- Capture String Comparisons: Kan baie nuttig wees. Dit sal die 2 strings wat vergelyk word wys en of die resultaat True of False was.
- Enumerate Class Methods: Voer die klassenaam in (bv. "java.io.File") en dit sal al die methods van die klas uitdruk.
- Search Class Pattern: Soek classes volgens ’n patroon
- Trace Class Methods: Trace ’n hele klas (sien insette en uitsette van alle methods van die klas). Onthou dat MobSF standaard verskeie interessante Android Api methods trace.

Sodra jy die bykomende module gekies het wat jy wil gebruik, moet jy op "**Start Intrumentation**" druk en jy sal al die uitsette in "**Frida Live Logs**" sien.

**Shell**

MobSF bied ook ’n shell aan met sommige **adb** commands, **MobSF commands**, en algemene **shell** **commands** onderaan die dinamiese analise-bladsy. ’n Paar interessante commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP gereedskap**

Wanneer HTTP-verkeer vasgelê word kan jy 'n lelike uitsig van die vasgelê verkeer sien op die "**HTTP(S) Traffic**" knoppie onderaan of 'n netter uitsig in die "**Start HTTPTools**" groen knoppie. Vanaf die tweede opsie kan jy die **vasgelê versoeke** **send** na **proxies** soos Burp of Owasp ZAP.\
Om dit te doen, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> press "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Sodra jy die dinamiese analise met MobSF voltooi het kan jy op "**Start Web API Fuzzer**" druk om **http versoeke** te fuzz en na kwesbaarhede te soek.

> [!TIP]
> Na die uitvoering van 'n dinamiese analise met MobSF kan die proxy-instellings verkeerd gekonfigureer wees en sal jy dit nie via die GUI kan regstel nie. Jy kan die proxy-instellings regmaak deur:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Geassisteerde dinamiese analise met Inspeckage

Jy kan die tool kry by [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Hierdie tool sal sommige **Hooks** gebruik om jou te laat weet **wat in die aansoek gebeur** terwyl jy 'n **dinamiese analise** uitvoer.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Dit is 'n **geweldige tool om statiese analise met 'n GUI uit te voer**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Hierdie tool is ontwerp om te soek na verskeie **security related Android application vulnerabilities**, hetsy in **source code** of **packaged APKs**. Die tool is ook **capable of creating a "Proof-of-Concept" deployable APK** en **ADB commands**, om sommige van die gevonde kwesbaarhede te eksploiteer (Exposed activities, intents, tapjacking...). Soos met Drozer, is daar geen behoefte om die toetsapparaat te root nie.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Vertoon alle uitgehaalde lêers vir maklike verwysing
- Decompileer outomaties APK-lêers na Java- en Smali-formaat
- Analiseer AndroidManifest.xml op algemene kwesbaarhede en gedrag
- Statiese bronkode-analise vir algemene kwesbaarhede en gedrag
- Toestelinligting
- en meer
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER is 'n opdragreëltoepassing wat in Windows, MacOS X en Linux gebruik kan word, en wat _.apk_ lêers ontleed om na kwesbaarhede te soek. Dit doen dit deur APKs te dekomprimeer en 'n reeks reëls toe te pas om daardie kwesbaarhede op te spoor.

Alle reëls is gesentreer in 'n `rules.json`-lêer, en elke maatskappy of toetser kan sy eie reëls skep om te ontleed wat hulle benodig.

Laai die nuutste binaries af vanaf die [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn is 'n **crossplatform** hulpmiddel wat ontwikkelaars, bugbounty hunters en etiese hackers help met die uitvoering van [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) op mobiele toepassings.

Die konsep is dat jy jou mobiele toepassingslêer (.apk of .ipa file) op die StaCoAn-toepassing sleep en dit sal vir jou 'n visuele en draagbare verslag genereer. Jy kan die instellings en wordlists aanpas om 'n aangepaste ervaring te kry.

Laai af[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework is 'n Android-kwesbaarheidsanalise-stelsel wat ontwikkelaars of hackers help om potensiële sekuriteitskwesbaarhede in Android-toepassings te vind.\  
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** is 'n hulpmiddel met die hoofdoel om te ontdek en die gebruiker te waarsku oor potensieel kwaadwillige gedrag wat deur 'n Android-toepassing ontwikkel is.

Die detectie word uitgevoer deur middel van die **static analysis** van die toepassing se Dalvik bytecode, voorgestel as **Smali**, met die [`androguard`](https://github.com/androguard/androguard) biblioteek.

Hierdie hulpmiddel soek na **common behavior of "bad" applications** soos: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is 'n **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. Dit is 'n hulpmiddel wat algemeen gebruikte mobile application reverse engineering en analysis tools bymekaar sit om te help met die toetsing van mobiele toepassings teen OWASP mobile security threats. Die doel is om hierdie taak makliker en meer gebruikersvriendelik te maak vir mobile application developers en security professionals.

Dit kan:

- Java en Smali kode ekstraheer met verskeie tools
- APKs analiseer met: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Privaat inligting uit die APK ekstraheer met behulp van regexps.
- Die Manifest analiseer.
- Gevonde domains analiseer met: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) en [whatweb](https://github.com/urbanadventurer/WhatWeb)
- APK deobfuscate via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Nuttig om malware op te spoor: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Let daarop dat, afhangend van die diens en konfigurasie wat jy gebruik om die kode te obfusk, geheime dalk wel of nie obfusk geraak nie.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is 'n open source command-line tool wat Java-kode verklein, optimaliseer en obfuskeer. Dit kan bytecode optimaliseer asook ongebruikte instruksies opspoor en verwyder. ProGuard is vrye sagteware en word versprei onder die GNU General Public License, version 2.

ProGuard word as deel van die Android SDK versprei en hardloop wanneer die toepassing in release mode gebou word.

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Last time we checked, the Dexguard mode of operation was:

- laai 'n resource as 'n InputStream;
- voer die resultaat aan 'n klas wat van FilterInputStream erf om dit te ontsleutel;
- doen 'n paar nuttelose obfuskasies om 'n paar minute van 'n reverser se tyd te mors;
- voer die ontsleutelde resultaat aan 'n ZipInputStream om 'n DEX-lêer te kry;
- laai uiteindelik die resulterende DEX as 'n Resource met die `loadDex` metode.

### [DeGuard](http://apk-deguard.com)

**DeGuard keert die proses van obfuskasie wat deur Android obfuscation tools uitgevoer is, om. Dit stel talle sekuriteitsanalises in staat, insluitend kode-inspeksie en die voorspellng van libraries.**

Jy kan 'n obfuskede APK na hul platform oplaai.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

Dit is 'n LLM-hulpmiddel om enige potensiële sekuriteitskwesbaarhede in android apps te vind en android app-kode te deobfuskeer. Gebruik Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

Dit is 'n **generic android deobfuscator.** Simplify **virtually executes an app** om die gedrag daarvan te verstaan en probeer dan die kode optimaliseer sodat dit identies optree maar makliker is vir 'n mens om te verstaan. Elke optimaliseringstipe is eenvoudig en generies, so dit maak nie saak watter spesifieke tipe obfuskasie gebruik word nie.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD gee jou inligting oor **how an APK was made**. Dit identifiseer baie **compilers**, **packers**, **obfuscators**, en ander vreemde goed. Dit is [_PEiD_](https://www.aldeid.com/wiki/PEiD) vir Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b is 'n Android security virtual machine gebaseer op ubuntu-mate en sluit 'n versameling van die nuutste framework, tutorials en labs in van verskeie security geeks en researchers vir reverse engineering en malware analysis.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Dit is 'n uitstekende lys van resources
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)

## Yet to try

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
