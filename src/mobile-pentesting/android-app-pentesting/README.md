# Aplicaciones Android Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Fundamentos de las Aplicaciones Android

Se recomienda encarecidamente comenzar leyendo esta página para conocer las **partes más importantes relacionadas con la seguridad de Android y los componentes más peligrosos en una aplicación Android**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Esta es la herramienta principal que necesitas para conectar con un dispositivo Android (emulado o físico).\
**ADB** permite controlar dispositivos tanto por **USB** como por **red** desde un ordenador. Esta utilidad permite el **copiado** de archivos en ambas direcciones, la **instalación** y **desinstalación** de apps, la **ejecución** de comandos de shell, la **copia de seguridad** de datos, la **lectura** de logs, entre otras funciones.

Consulta la siguiente lista de [**ADB Commands**](adb-commands.md) para aprender cómo usar adb.

## Smali

A veces es interesante **modificar el código de la aplicación** para acceder a **información oculta** (posiblemente contraseñas bien ofuscadas o flags). Entonces, puede ser interesante descompilar el apk, modificar el código y recompilarlo.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Esto puede ser muy útil como **alternativa para varias pruebas durante el análisis dinámico** que se van a presentar. Entonces, **ten siempre en cuenta esta posibilidad**.

## Otros trucos interesantes

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [Android IME / InputMethodService Abuse (Malicious Keyboards)](inputmethodservice-ime-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **Descargar APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Extraer APK del dispositivo:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Fusiona todos los splits y apks base con [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Android Enterprise & Work Profile Attacks

{{#ref}}
android-enterprise-work-profile-bypass.md
{{#endref}}

## Estudios de Caso & Vulnerabilidades


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

{{#ref}}
abusing-android-media-pipelines-image-parsers.md
{{#endref}}

{{#ref}}
../../binary-exploitation/linux-kernel-exploitation/arm64-static-linear-map-kaslr-bypass.md
{{#endref}}

## Análisis estático

Antes que nada, para analizar un APK deberías **echar un vistazo al código Java** usando un decompiler.\
Por favor, [**lee aquí para encontrar información sobre los diferentes decompilers disponibles**](apk-decompilers.md).

### Buscando información interesante

Con solo revisar las **strings** del APK puedes buscar **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **API** keys, **encryption**, **bluetooth uuids**, **tokens** y cualquier cosa interesante... incluso busca **backdoors** de ejecución de código o backdoors de autenticación (credenciales de admin hardcoded en la app).

**Firebase**

Presta especial atención a las URLs de **Firebase** y comprueba si está mal configurado. [Más información sobre qué es Firebase y cómo explotarlo aquí.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Comprensión básica de la aplicación - Manifest.xml, strings.xml

El **examen del _Manifest.xml_ y los archivos **_strings.xml_** de una aplicación puede revelar vulnerabilidades de seguridad potenciales**. Estos archivos pueden accederse usando decompilers o renombrando la extensión del APK a .zip y luego descomprimiéndolo.

**Vulnerabilidades** identificadas desde el **Manifest.xml** incluyen:

- **Debuggable Applications**: Las aplicaciones marcadas como debuggable (`debuggable="true"`) en el _Manifest.xml_ representan un riesgo ya que permiten conexiones que pueden llevar a la explotación. Para entender mejor cómo explotar aplicaciones debuggable, consulta un tutorial sobre cómo encontrar y explotar aplicaciones debuggable en un dispositivo.
- **Backup Settings**: El atributo `android:allowBackup="false"` debe establecerse explícitamente para aplicaciones que manejan información sensible para evitar backups no autorizados vía adb, especialmente cuando usb debugging está habilitado.
- **Network Security**: Las configuraciones personalizadas de network security (`android:networkSecurityConfig="@xml/network_security_config"`) en _res/xml/_ pueden especificar detalles de seguridad como certificate pins y ajustes de tráfico HTTP. Un ejemplo es permitir tráfico HTTP para dominios específicos.
- **Exported Activities and Services**: Identificar actividades y servicios exportados en el manifest puede señalar componentes que podrían ser mal utilizados. Un análisis adicional durante las pruebas dinámicas puede revelar cómo explotar estos componentes.
- **Content Providers and FileProviders**: Los content providers expuestos podrían permitir acceso o modificación no autorizado de datos. También debe examinarse la configuración de FileProviders.
- **Broadcast Receivers and URL Schemes**: Estos componentes podrían aprovecharse para explotación, prestando especial atención a cómo se gestionan los URL schemes para vulnerabilidades de entrada.
- **SDK Versions**: Los atributos `minSdkVersion`, `targetSDKVersion`, y `maxSdkVersion` indican las versiones de Android soportadas, subrayando la importancia de no soportar versiones antiguas y vulnerables de Android por razones de seguridad.

Desde el archivo **strings.xml**, se puede descubrir información sensible como API keys, esquemas personalizados y otras notas del desarrollador, lo que enfatiza la necesidad de revisar cuidadosamente estos recursos.

### Tapjacking

**Tapjacking** es un ataque donde una **aplicación** **maliciosa** se lanza y **se posiciona sobre una aplicación víctima**. Una vez que oscurece visiblemente la app víctima, su interfaz de usuario está diseñada de tal manera que engaña al usuario para que interactúe con ella, mientras pasa la interacción a la app víctima.\
En efecto, está **cegando al usuario para que no sepa que en realidad está realizando acciones en la app víctima**.

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Una **activity** con el **`launchMode`** establecido en **`singleTask` sin `taskAffinity`** definido es vulnerable a task Hijacking. Esto significa que una **aplicación** puede instalarse y si se lanza antes que la aplicación real podría **secuestrar la task de la aplicación real** (por lo que el usuario estará interactuando con la **aplicación maliciosa pensando que está usando la real**).

Más info en:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Almacenamiento de datos inseguro

**Almacenamiento interno**

En Android, los archivos **almacenados** en el **almacenamiento interno** están **diseñados** para ser **accesibles** exclusivamente por la **app** que los **creó**. Esta medida de seguridad es **impuesta** por el sistema operativo Android y suele ser adecuada para las necesidades de seguridad de la mayoría de aplicaciones. Sin embargo, los desarrolladores a veces utilizan modos como `MODE_WORLD_READABLE` y `MODE_WORLD_WRITABLE` para **permitir** que los archivos sean **compartidos** entre diferentes aplicaciones. Aun así, estos modos **no restringen el acceso** a estos archivos por otras aplicaciones, incluidas aplicaciones potencialmente maliciosas.

1. **Static Analysis:**
- **Asegúrate** de que el uso de `MODE_WORLD_READABLE` y `MODE_WORLD_WRITABLE` sea **revisado cuidadosamente**. Estos modos **pueden exponer** archivos a **accesos no intencionados o no autorizados**.
2. **Dynamic Analysis:**
- **Verifica** los **permisos** establecidos en los archivos creados por la app. Específicamente, **comprueba** si alguno de los archivos está **configurado como readable o writable worldwide**. Esto puede suponer un riesgo de seguridad significativo, ya que permitiría a **cualquier aplicación** instalada en el dispositivo, independientemente de su origen o intención, **leer o modificar** esos archivos.

**Almacenamiento externo**

Al tratar con archivos en **external storage**, como SD Cards, se deben tomar ciertas precauciones:

1. **Accesibilidad**:
- Los archivos en external storage son **globalmente legibles y escribibles**. Esto significa que cualquier aplicación o usuario puede acceder a estos archivos.
2. **Preocupaciones de seguridad**:
- Dada la facilidad de acceso, se aconseja **no almacenar información sensible** en external storage.
- El external storage puede ser removido o accedido por cualquier aplicación, lo que lo hace menos seguro.
3. **Manejo de datos desde external storage**:
- Siempre **realiza validación de entrada** sobre los datos recuperados desde external storage. Esto es crucial porque los datos provienen de una fuente no confiable.
- No es recomendable almacenar ejecutables o archivos .class en external storage para carga dinámica.
- Si tu aplicación debe recuperar archivos ejecutables desde external storage, asegúrate de que estos archivos estén **firmados y verificados criptográficamente** antes de cargarlos dinámicamente. Este paso es vital para mantener la integridad de seguridad de la aplicación.

External storage puede ser **accedido** en `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> A partir de Android 4.4 (**API 17**), la SD card tiene una estructura de directorios que **limita el acceso desde una app al directorio que es específicamente para esa app**. Esto impide que una aplicación maliciosa obtenga acceso de lectura o escritura a los archivos de otra app.

**Datos sensibles almacenados en texto claro**

- **Shared preferences**: Android permite a cada aplicación guardar fácilmente archivos xml en la ruta `/data/data/<packagename>/shared_prefs/` y a veces es posible encontrar información sensible en texto claro en esa carpeta.
- **Databases**: Android permite a cada aplicación guardar fácilmente bases de datos sqlite en la ruta `/data/data/<packagename>/databases/` y en ocasiones es posible encontrar información sensible en texto claro en esa carpeta.

### Broken TLS

**Accept All Certificates**

Por alguna razón, a veces los desarrolladores aceptan todos los certificados incluso si, por ejemplo, el hostname no coincide, con líneas de código como la siguiente:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Una buena manera de probar esto es intentar capturar el tráfico usando algún proxy como Burp sin autorizar el Burp CA dentro del dispositivo. Además, puedes generar con Burp un certificado para un hostname diferente y usarlo.

### Criptografía insegura

**Procesos deficientes de gestión de claves**

Algunos desarrolladores guardan datos sensibles en el almacenamiento local y los cifran con una clave hardcoded/predictable en el código. Esto no debería hacerse, ya que un reversing podría permitir a un atacante extraer la información confidencial.

**Uso de algoritmos inseguros y/o obsoletos**

Los desarrolladores no deberían usar **deprecated algorithms** para realizar comprobaciones de autorización (**checks**), **almacenar** o **enviar** datos. Algunos de estos algoritmos son: RC4, MD4, MD5, SHA1... Si se usan **hashes** para almacenar contraseñas, por ejemplo, deberían usarse hashes resistentes a brute-force con salt.

### Otras comprobaciones

- Se recomienda **obfuscate the APK** para dificultar el trabajo de reverse engineer a los atacantes.
- Si la app es sensible (como apps bancarias), debería realizar sus **propios checks para ver si el móvil está rooted** y actuar en consecuencia.
- Si la app es sensible (como apps bancarias), debería comprobar si se está usando un **emulator**.
- Si la app es sensible (como apps bancarias), debería **comprobar su propia integridad antes de ejecutarse** para verificar si ha sido modificada.
- Usa [**APKiD**](https://github.com/rednaga/APKiD) para comprobar qué compiler/packer/obfuscator se usó para construir el APK

### Aplicación React Native

Lee la siguiente página para aprender cómo acceder fácilmente al código javascript de aplicaciones React:


{{#ref}}
react-native-application.md
{{#endref}}

### Aplicaciones Xamarin

Lee la siguiente página para aprender cómo acceder fácilmente al código C# de una aplicación xamarin:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

Según este [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked es un algoritmo de Meta que comprime el contenido de una aplicación en un único fichero. El blog habla sobre la posibilidad de crear una app que descomprima este tipo de apps... y una manera más rápida que implica **ejecutar la aplicación y recoger los ficheros descomprimidos desde el filesystem.**

### Análisis Estático Automatizado de Código

La herramienta [**mariana-trench**](https://github.com/facebook/mariana-trench) es capaz de encontrar **vulnerabilidades** escaneando el **código** de la aplicación. Esta herramienta contiene una serie de **known sources** (que indican a la herramienta los **lugares** donde la **input** está **controlada por el usuario**), **sinks** (que indican a la herramienta **lugares peligrosos** donde la entrada maliciosa podría causar daños) y **rules**. Estas reglas indican la **combinación** de **sources-sinks** que señala una vulnerabilidad.

Con este conocimiento, **mariana-trench revisará el código y encontrará posibles vulnerabilidades en él**.

### Secretos leaked

Una aplicación puede contener secretos (API keys, passwords, hidden urls, subdomains...) dentro de ella que podrías descubrir. Puedes usar una herramienta como [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Otras funciones interesantes

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declaradas como `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)
- In-memory native code execution via JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Otros trucos**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Análisis Dinámico

> Primero que nada, necesitas un entorno donde puedas instalar la aplicación y todo el entorno (Burp CA cert, Drozer and Frida principalmente). Por lo tanto, se recomienda encarecidamente un dispositivo rooted (emulado o no).

### Análisis dinámico en línea

Puedes crear una **cuenta gratuita** en: [https://appetize.io/](https://appetize.io). Esta plataforma te permite **subir** y **ejecutar** APKs, por lo que es útil para ver cómo se comporta un apk.

Incluso puedes **ver los logs de tu aplicación** en la web y conectarte mediante **adb**.

![](<../../images/image (831).png>)

Gracias a la conexión ADB puedes usar **Drozer** y **Frida** dentro de los emuladores.

### Análisis Dinámico Local

#### Usando un emulador

- [**Android Studio**](https://developer.android.com/studio) (Puedes crear dispositivos **x86** y **arm**, y según [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**las versiones x86 más recientes** **soportan librerías ARM** sin necesitar un emulador arm lento).
- Aprende a configurarlo en esta página:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, necesitas crear una cuenta. _Se recomienda **descargar** la versión **WITH**_ _**VirtualBox** para evitar errores potenciales._)
- [**Nox**](https://es.bignox.com) (Gratis, pero no soporta Frida ni Drozer).

> [!TIP]
> Al crear un nuevo emulador en cualquier plataforma recuerda que cuanto más grande sea la pantalla, más lento funcionará el emulador. Así que selecciona pantallas pequeñas si es posible.

Para **install google services** (como AppStore) en Genymotion necesitas pulsar el botón marcado en rojo de la siguiente imagen:

![](<../../images/image (277).png>)

Además, ten en cuenta que en la **configuración de la Android VM en Genymotion** puedes seleccionar **Bridge Network mode** (esto será útil si te vas a conectar a la Android VM desde una VM diferente con las herramientas).

#### Usar un dispositivo físico

Necesitas activar las opciones de **debugging** y sería ideal si puedes **root**arlo:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Una vez que hayas instalado la aplicación, lo primero que debes hacer es usarla e investigar qué hace, cómo funciona y familiarizarte con ella.\
> Sugiero **realizar este análisis dinámico inicial usando MobSF dynamic analysis + pidcat**, de modo que podamos **aprender cómo funciona la aplicación** mientras MobSF **captura** una gran cantidad de **datos interesantes** que podrás revisar más tarde.

Magisk/Zygisk quick notes (recomendado en dispositivos Pixel)
- Patch boot.img con la app Magisk y flashea vía fastboot para obtener root systemless
- Habilita Zygisk + DenyList para ocultar root; considera LSPosed/Shamiko cuando se requiera ocultamiento más fuerte
- Conserva el boot.img original para recuperarte de actualizaciones OTA; vuelve a parchear después de cada OTA
- Para mirror de pantalla, usa scrcpy en el host

### Unintended Data Leakage

**Logging**

Los desarrolladores deben tener cuidado de no exponer **información de debugging** públicamente, ya que esto puede conducir a sensitive data leaks. Se recomiendan las herramientas [**pidcat**](https://github.com/JakeWharton/pidcat) y `adb logcat` para monitorizar los logs de la aplicación e identificar y proteger información sensible. **Pidcat** se prefiere por su facilidad de uso y legibilidad.

> [!WARNING]
> Ten en cuenta que desde **versiones posteriores a Android 4.0**, **las aplicaciones solo pueden acceder a sus propios logs**. Por lo tanto, las aplicaciones no pueden acceder a los logs de otras apps.\
> De todos modos, sigue siendo recomendable **no loggear información sensible**.

**Copy/Paste Buffer Caching**

El framework basado en **clipboard** de Android permite la funcionalidad de copiar-pegar en las apps, pero plantea un riesgo ya que **otras aplicaciones** pueden **acceder** al portapapeles, exponiendo potencialmente datos sensibles. Es crucial **deshabilitar las funciones de copy/paste** para secciones sensibles de una aplicación, como los datos de tarjetas de crédito, para prevenir data leaks.

**Crash Logs**

Si una aplicación **crashea** y **guarda logs**, estos logs pueden ayudar a atacantes, especialmente cuando la aplicación no puede ser reverse-engineered. Para mitigar este riesgo, evita loggear en crashes, y si los logs deben ser enviados por la red, asegúrate de que se envíen vía un canal SSL para seguridad.

Como pentester, **intenta echar un vistazo a estos logs**.

**Analytics Data Sent To 3rd Parties**

Las aplicaciones a menudo integran servicios como Google Adsense, lo que puede inadvertidamente causar sensitive data leaks debido a una implementación incorrecta por parte de los desarrolladores. Para identificar posibles fugas de datos, es recomendable **interceptar el tráfico de la aplicación** y comprobar si se está enviando información sensible a servicios de terceros.

### SQLite DBs

La mayoría de las aplicaciones usarán **SQLite databases** internas para guardar información. Durante el pentest echa un **vistazo** a las **bases de datos** creadas, los nombres de **tablas** y **columnas** y todos los **datos** guardados porque podrías encontrar **información sensible** (lo que sería una vulnerabilidad).\
Las bases de datos deberían estar en `/data/data/the.package.name/databases` como `/data/data/com.mwr.example.sieve/databases`

Si la base de datos guarda información confidencial y está **encrypted** pero puedes **find** la **password** dentro de la aplicación, sigue siendo una **vulnerabilidad**.

Enumera las tablas usando `.tables` y enumera las columnas de las tablas con `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** te permite **asumir el rol de una app Android** e interactuar con otras apps. Puede hacer **todo lo que una aplicación instalada puede hacer**, como usar el mecanismo de Inter-Process Communication (IPC) de Android e interactuar con el sistema operativo subyacente. .\
Drozer es una herramienta útil para **explotar actividades exportadas, servicios exportados y Content Providers** como aprenderás en las siguientes secciones.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Recuerda también que el código de una activity comienza en el método **`onCreate`**.

**Authorisation bypass**

Cuando una Activity está exportada puedes invocar su pantalla desde una app externa. Por lo tanto, si una activity con **información sensible** está **exportada** podrías **bypassear** los mecanismos de **autenticación** para acceder a ella.

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

También puedes iniciar una activity exportada desde adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTA**: MobSF detectará como malicioso el uso de _**singleTask/singleInstance**_ como `android:launchMode` en una activity, pero debido a [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), aparentemente esto solo es peligroso en versiones antiguas (API versions < 21).

> [!TIP]
> Ten en cuenta que un authorisation bypass no siempre es una vulnerabilidad; dependerá de cómo funcione el bypass y qué información se exponga.

**Fuga de información sensible**

**Activities can also return results**. Si logras encontrar una activity exportada y desprotegida que llama al método **`setResult`** y **devuelve información sensible**, hay una fuga de información sensible.

#### Tapjacking

Si el tapjacking no se previene, podrías abusar de la activity exportada para hacer que el **usuario realice acciones inesperadas**. For more info about [**what is Tapjacking follow the link**](#tapjacking).

### Explotación de Content Providers - Acceso y manipulación de información sensible

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers se usan básicamente para **compartir datos**. Si una app tiene content providers disponibles, podrías ser capaz de **extraer datos sensibles** de ellos. También es interesante probar posibles **SQL injections** y **Path Traversals**, ya que podrían ser vulnerables.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Recuerda que las acciones de un Service empiezan en el método `onStartCommand`.

Un service es básicamente algo que **puede recibir datos**, **procesarlos** y **retornar** (o no) una respuesta. Entonces, si una aplicación exporta algunos services deberías **check** el **code** para entender qué está haciendo y **test** it **dynamically** para extraer información confidencial, bypassing authentication measures...\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Recuerda que las acciones de un Broadcast Receiver comienzan en el método `onReceive`.

Un Broadcast Receiver estará esperando un tipo de mensaje. Dependiendo de cómo el receiver maneje el mensaje, podría ser vulnerable.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Puedes buscar deep links manualmente, usando herramientas como MobSF o scripts como [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Puedes **abrir** un **scheme** declarado usando **adb** o un **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Ten en cuenta que puedes **omitir el nombre del paquete** y el móvil llamará automáticamente a la app que debería abrir ese enlace._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Código ejecutado**

Para encontrar el **código que se ejecutará en la App**, ve a la activity llamada por el deeplink y busca la función **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Información sensible**

Cada vez que encuentres un deep link comprueba que **no esté recibiendo datos sensibles (como contraseñas) vía parámetros URL**, porque cualquier otra aplicación podría **suplantar el deep link y robar esos datos!**

**Parámetros en la ruta**

También **debes comprobar si algún deep link está usando un parámetro dentro de la ruta** de la URL como: `https://api.example.com/v1/users/{username}`, en ese caso puedes forzar un path traversal accediendo a algo como: `example://app/users?username=../../unwanted-endpoint%3fparam=value`.\
Ten en cuenta que si encuentras los endpoints correctos dentro de la aplicación podrías causar un **Open Redirect** (si parte de la ruta se usa como nombre de dominio), un **account takeover** (si puedes modificar los detalles de usuarios sin CSRF token y el endpoint vuln usó el método correcto) y cualquier otra vuln. More [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**Más ejemplos**

Un [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Inspección de la capa de transporte y fallos de verificación

- **Los certificados no siempre se inspeccionan correctamente** por las aplicaciones Android. Es común que estas aplicaciones pasen por alto advertencias y acepten certificados autofirmados o, en algunos casos, vuelvan a usar conexiones HTTP.
- **Las negociaciones durante el handshake SSL/TLS a veces son débiles**, empleando suites de cifrado inseguras. Esta vulnerabilidad hace la conexión susceptible a ataques man-in-the-middle (MITM), permitiendo a los atacantes descifrar los datos.
- **Leakage of private information** es un riesgo cuando las aplicaciones se autentican usando canales seguros pero luego comunican por canales no seguros para otras transacciones. Este enfoque no protege datos sensibles, como cookies de sesión o detalles de usuario, de la interceptación por entidades maliciosas.

#### Verificación de certificados

Nos centraremos en la **verificación de certificados**. La integridad del certificado del servidor debe verificarse para aumentar la seguridad. Esto es crucial porque las configuraciones TLS inseguras y la transmisión de datos sensibles por canales no cifrados pueden suponer riesgos significativos. Para pasos detallados sobre cómo verificar certificados de servidor y abordar vulnerabilidades, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) proporciona una guía completa.

#### SSL Pinning

SSL Pinning es una medida de seguridad donde la aplicación verifica el certificado del servidor contra una copia conocida almacenada dentro de la propia aplicación. Este método es esencial para prevenir ataques MITM. Se recomienda encarecidamente implementar SSL Pinning en aplicaciones que manejan información sensible.

#### Inspección de tráfico

Para inspeccionar el tráfico HTTP, es necesario **instalar el certificado de la herramienta proxy** (e.g., Burp). Sin instalar este certificado, el tráfico cifrado podría no ser visible a través del proxy. Para una guía sobre cómo instalar un certificado CA personalizado, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Las aplicaciones dirigidas a **API Level 24 and above** requieren modificaciones en el Network Security Config para aceptar el certificado CA del proxy. Este paso es crítico para inspeccionar tráfico cifrado. Para instrucciones sobre cómo modificar el Network Security Config, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

Si se está usando **Flutter** debes seguir las instrucciones en [**this page**](flutter.md). Esto es porque, simplemente añadir el certificado al almacén no funcionará ya que Flutter tiene su propia lista de CAs válidas.

#### Detección estática de SSL/TLS pinning

Antes de intentar bypasses en tiempo de ejecución, mapea rápidamente dónde se aplica el pinning en el APK. El descubrimiento estático te ayuda a planificar hooks/patches y a centrarte en las rutas de código correctas.

Tool: SSLPinDetect
- Utilidad de análisis estático open-source que decompila el APK a Smali (via apktool) y busca patrones regex seleccionados de implementaciones de SSL/TLS pinning.
- Reporta la ruta de archivo exacta, número de línea y un snippet de código para cada coincidencia.
- Cubre frameworks comunes y rutas de código custom: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

Instalación
- Requisitos previos: Python >= 3.8, Java en PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Uso
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Ejemplo de reglas de patrones (JSON)
Usa o amplía firmas para detectar estilos propietarios/personalizados de pinning. Puedes cargar tu propio JSON y escanear a gran escala.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notas y consejos
- Escaneo rápido en aplicaciones grandes mediante multi-threading y I/O mapeada en memoria; regex precompiladas reducen la sobrecarga/falsos positivos.
- Colección de patrones: https://github.com/aancw/smali-sslpin-patterns
- Objetivos típicos de detección para priorizar a continuación:
- OkHttp: uso de CertificatePinner, setCertificatePinner, referencias al paquete okhttp3/okhttp
- TrustManagers personalizados: javax.net.ssl.X509TrustManager, sobrescrituras de checkServerTrusted
- Contextos SSL personalizados: SSLContext.getInstance + SSLContext.init con managers personalizados
- Pins declarativos en res/xml network security config y referencias en el manifest
- Usa las ubicaciones coincidentes para planear hooks de Frida, parches estáticos o revisiones de configuración antes de las pruebas dinámicas.



#### Bypassing SSL Pinning

Cuando SSL Pinning está implementado, es necesario eludirlo para inspeccionar el tráfico HTTPS. Hay varios métodos disponibles para este propósito:

- Modificar automáticamente el **apk** para **bypassear** SSLPinning con [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). La principal ventaja de esta opción es que no necesitarás root para bypassear el SSL Pinning, pero tendrás que eliminar la aplicación e instalar la nueva, y esto no siempre funcionará.
- Puedes usar **Frida** (discutido más abajo) para eludir esta protección. Aquí tienes una guía para usar Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- También puedes intentar **bypassear automáticamente SSL Pinning** usando [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- También puedes intentar **bypassear automáticamente SSL Pinning** usando **MobSF dynamic analysis** (explicado más abajo)
- Si aún crees que hay tráfico que no estás capturando, puedes intentar **redirigir el tráfico a burp usando iptables**. Lee este blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Looking for Common Web Vulnerabilities

También es importante buscar vulnerabilidades web comunes dentro de la aplicación. La información detallada sobre cómo identificarlas y mitigarlas está fuera del alcance de este resumen, pero se trata ampliamente en otros recursos.

### Frida

[Frida](https://www.frida.re) es un toolkit de instrumentación dinámica para desarrolladores, ingenieros inversos y investigadores de seguridad.\
**Puedes acceder a la aplicación en ejecución y hookear métodos en tiempo de ejecución para cambiar el comportamiento, modificar valores, extraer valores, ejecutar otro código...**\
Si quieres pentest aplicaciones Android necesitas saber cómo usar Frida.

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Algunas "GUI" para acciones con Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection es ideal para automatizar el uso de Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Puedes encontrar algunos scripts geniales de Frida aquí: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Intenta bypassear mecanismos anti-debugging / anti-frida cargando Frida como se indica en [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (herramienta [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

Comprueba si la aplicación está almacenando información sensible en la memoria que no debería, como contraseñas o mnemónicos.

Usando [**Fridump3**](https://github.com/rootbsd/fridump3) puedes volcar la memoria de la app con:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Esto volcará la memoria en la carpeta ./dump, y allí podrías usar grep con algo como:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Datos sensibles en Keystore**

En Android el Keystore es el mejor lugar para almacenar datos sensibles; sin embargo, con suficientes privilegios todavía es **posible acceder a él**. Como las aplicaciones tienden a almacenar aquí **datos sensibles en texto claro**, los pentests deberían comprobarlo, ya que un root user o alguien con acceso físico al dispositivo podría robar estos datos.

Incluso si una app almacena datos en el keystore, los datos deberían estar cifrados.

Para acceder a los datos dentro del keystore puedes usar este Frida script: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Usando el siguiente script de Frida, podría ser posible **bypass fingerprint authentication** que las aplicaciones Android realizan para **proteger ciertas áreas sensibles:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Imágenes en segundo plano**

Cuando pones una aplicación en segundo plano, Android guarda una **instantánea de la aplicación** para que cuando se recupere al primer plano empiece a cargar la imagen antes que la app, de modo que parezca que la aplicación se cargó más rápido.

Sin embargo, si esta instantánea contiene **información sensible**, alguien con acceso a la instantánea podría **robar esa información** (nota: se necesita root para acceder a ella).

Las instantáneas suelen almacenarse en: **`/data/system_ce/0/snapshots`**

Android ofrece una forma de **evitar la captura de pantalla estableciendo el parámetro de layout FLAG_SECURE**. Al usar esta flag, el contenido de la ventana se trata como seguro, impidiendo que aparezca en capturas de pantalla o que se muestre en pantallas no seguras.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Analizador de Aplicaciones Android**

Esta herramienta puede ayudarte a gestionar diferentes herramientas durante el dynamic analysis: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Los desarrolladores a menudo crean componentes proxy como activities, services y broadcast receivers que manejan estos Intents y los pasan a métodos como `startActivity(...)` o `sendBroadcast(...)`, lo cual puede ser riesgoso.

El peligro radica en permitir que un atacante desencadene componentes no exportados de la app o acceda a content providers sensibles redirigiendo estos Intents. Un ejemplo notable es el componente `WebView` que convierte URLs en objetos `Intent` mediante `Intent.parseUri(...)` y luego los ejecuta, lo que puede conducir a inyecciones de Intent maliciosos.

### Puntos esenciales

- **Intent Injection** es similar al Open Redirect de la web.
- Los exploits implican pasar objetos `Intent` como extras, que pueden ser redirigidos para ejecutar operaciones inseguras.
- Puede exponer componentes no exportados y content providers a atacantes.
- La conversión de URL a `Intent` por parte de `WebView` puede facilitar acciones no deseadas.

### Android Client Side Injections and others

Probablemente conozcas este tipo de vulnerabilidades desde la Web. Debes tener especial cuidado con estas vulnerabilidades en una aplicación Android:

- **SQL Injection:** Al tratar con consultas dinámicas o Content-Providers asegúrate de usar consultas parametrizadas.
- **JavaScript Injection (XSS):** Verifica que el soporte de JavaScript y Plugins esté desactivado para cualquier WebView (desactivado por defecto). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews deberían tener el acceso al sistema de archivos deshabilitado (habilitado por defecto) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies:** En varios casos, cuando la aplicación Android termina la sesión la cookie no se revoca o incluso podría guardarse en disco.
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Análisis automático

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Análisis estático**

![](<../../images/image (866).png>)

**Evaluación de vulnerabilidades de la aplicación** usando un agradable frontend basado en web. También puedes realizar dynamic analysis (pero necesitas preparar el entorno).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Análisis dinámico asistido con MobSF

**MobSF** también puede ser muy útil para el análisis dinámico en **Android**, pero en ese caso necesitarás instalar MobSF y **genymotion** en tu host (una VM o Docker no funcionarán). _Nota: Debes **iniciar primero una VM en genymotion** y **luego MobSF**._\
El **analizador dinámico de MobSF** puede:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). Todo esto se hace automáticamente excepto las capturas de pantalla: debes pulsar cuando quieras una captura o debes pulsar "**Exported Activity Tester**" para obtener capturas de todas las actividades exportadas.
- Capturar **HTTPS traffic**
- Usar **Frida** para obtener información en tiempo de ejecución

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

Por defecto, también usará algunos Frida Scripts para bypass SSL pinning, root detection y debugger detection y para monitorizar APIs interesantes.\
MobSF también puede invocar actividades exportadas, obtener capturas de pantalla de las mismas y guardarlas para el informe.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: Imprimirá todas las clases cargadas
- **Capture Strings**: Imprimirá todas las strings capturadas mientras usas la aplicación (muy ruidoso)
- **Capture String Comparisons**: Puede ser muy útil. Mostrará las 2 strings que se están comparando y si el resultado fue True o False.
- **Enumerate Class Methods**: Escribe el nombre de la clase (por ejemplo "java.io.File") y mostrará todos los métodos de la clase.
- **Search Class Pattern**: Buscar clases por patrón
- **Trace Class Methods**: Tracea una clase completa (ver entradas y salidas de todos los métodos de la clase). Recuerda que por defecto MobSF traza varios métodos interesantes de la Android API.

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

MobSF también incluye una shell con algunos comandos **adb**, comandos **MobSF**, y comandos de **shell** comunes en la parte inferior de la página de análisis dinámico. Algunos comandos interesantes:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**Herramientas HTTP**

Cuando se captura tráfico HTTP puedes ver una vista poco atractiva del tráfico capturado en el botón "**HTTP(S) Traffic**" inferior o una vista más agradable en el botón verde "**Start HTTPTools**". Desde la segunda opción, puedes **enviar** las **solicitudes capturadas** a **proxies** como Burp o Owasp ZAP.\
Para ello, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> pulsa "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Una vez que termines el análisis dinámico con MobSF puedes pulsar "**Start Web API Fuzzer**" para **fuzz http requests** y buscar vulnerabilidades.

> [!TIP]
> Después de realizar un análisis dinámico con MobSF la configuración del proxy puede quedar mal configurada y no podrás arreglarla desde la GUI. Puedes corregir la configuración del proxy ejecutando:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Análisis dinámico asistido con Inspeckage

Puedes obtener la herramienta en [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Esta herramienta utiliza algunos **Hooks** para mostrarte **qué está ocurriendo en la aplicación** mientras realizas un **análisis dinámico**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Esta es una **gran herramienta para realizar análisis estático con una GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Esta herramienta está diseñada para buscar varias **vulnerabilidades relacionadas con la seguridad en aplicaciones Android**, ya sea en **código fuente** o en **APKs empaquetados**. La herramienta también es **capaz de crear un "Proof-of-Concept" deployable APK** y **ADB commands**, para explotar algunas de las vulnerabilidades encontradas (Exposed activities, intents, tapjacking...). Al igual que con Drozer, no es necesario rootear el dispositivo de prueba.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Muestra todos los archivos extraídos para una referencia rápida
- Descompila automáticamente archivos APK a formato Java y Smali
- Analiza AndroidManifest.xml en busca de vulnerabilidades y comportamientos comunes
- Análisis estático de código fuente en busca de vulnerabilidades y comportamientos comunes
- Información del dispositivo
- y más
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER es una aplicación de línea de comandos que puede utilizarse en Windows, MacOS X y Linux, que analiza _.apk_ files en busca de vulnerabilidades. Lo hace descomprimiendo los APKs y aplicando una serie de reglas para detectar esas vulnerabilidades.

Todas las reglas están centralizadas en un archivo `rules.json`, y cada empresa o tester puede crear sus propias reglas para analizar lo que necesiten.

Descarga los binarios más recientes desde la [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn es una herramienta **multiplataforma** que ayuda a desarrolladores, bugbounty hunters y ethical hackers a realizar [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) en aplicaciones móviles.

El concepto es que arrastras y sueltas el archivo de tu aplicación móvil (un archivo .apk o .ipa) sobre la aplicación StaCoAn y generará un informe visual y portátil para ti. Puedes ajustar la configuración y las wordlists para obtener una experiencia personalizada.

Descargar[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework es un sistema de análisis de vulnerabilidades para Android que ayuda a desarrolladores o hackers a encontrar posibles vulnerabilidades de seguridad en aplicaciones Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** es una herramienta cuyo objetivo principal es detectar y advertir al usuario sobre posibles comportamientos maliciosos desarrollados por una aplicación Android.

La detección se realiza mediante el **static analysis** del Dalvik bytecode de la aplicación, representado como **Smali**, con la librería [`androguard`](https://github.com/androguard/androguard).

Esta herramienta busca **comportamientos comunes de aplicaciones "malas"** como: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** es un **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. Es una herramienta que agrupa las herramientas más usadas para reverse engineering y análisis de aplicaciones móviles, para ayudar en las pruebas de aplicaciones móviles contra las amenazas de seguridad móviles de OWASP. Su objetivo es facilitar y hacer más amigable esta tarea para desarrolladores de aplicaciones móviles y profesionales de seguridad.

Es capaz de:

- Extract Java and Smali code using different tools
- Analyze APKs using: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Extraer información privada del APK usando regexps.
- Analizar el Manifest.
- Analizar los dominios encontrados usando: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Útil para detectar malware: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Ten en cuenta que, dependiendo del servicio y la configuración que uses para ofuscar el código, los secretos pueden o no quedar ofuscados.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. It is able to optimize bytecode as well as detect and remove unused instructions. ProGuard is free software and is distributed under the GNU General Public License, version 2.

ProGuard is distributed as part of the Android SDK and runs when building the application in release mode.

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Last time we checked, the Dexguard mode of operation was:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

Puedes subir un APK ofuscado a su plataforma.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

It is a **generic android deobfuscator.** Simplify **virtually executes an app** to understand its behavior and then **tries to optimize the code** so it behaves identically but is easier for a human to understand. Each optimization type is simple and generic, so it doesn't matter what the specific type of obfuscation is used.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD gives you information about **how an APK was made**. It identifies many **compilers**, **packers**, **obfuscators**, and other weird stuff. It's [_PEiD_](https://www.aldeid.com/wiki/PEiD) for Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b is an Android security virtual machine based on ubuntu-mate includes the collection of latest framework, tutorials and labs from different security geeks and researchers for reverse engineering and malware analysis.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Es una gran lista de recursos
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Curso rápido de Android
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
