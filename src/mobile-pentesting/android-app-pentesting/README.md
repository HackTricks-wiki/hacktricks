# Android Toepassings Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android Toepassings Basiese

Dit word sterk aanbeveel om eers hierdie bladsy te lees om te leer oor die **belangrikste dele wat verband hou met Android-sekuriteit en die gevaarlikste komponente in 'n Android-toepassing**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Dit is die hoofinstrument wat jy nodig het om met 'n Android-toestel (geëmuleer of fisies) te verbind.\
**ADB** stel jou in staat om toestelbeheer óf oor **USB** óf oor die **netwerk** vanaf 'n rekenaar uit te voer. Hierdie hulpmiddel maak dit moontlik om **lêers te kopieer** in albei rigtings, **installeer** en **verwyder** apps, **voer** shell-opdragte uit, **rugsteun** data, **lees** logs, en ander funksies.

Kyk na die volgende lys van [**ADB Commands**](adb-commands.md) om te leer hoe om ADB te gebruik.

## Smali

Soms is dit interessant om die **aansoekkode te wysig** om by **verborge inligting** te kom (bv. goed obfuskede wagwoorde of flags). Dan kan dit sin maak om die apk te decompileer, die kode te wysig en weer te compileer.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Dit kan baie nuttig wees as 'n **alternatief vir verskeie toetse tydens die dinamiese analise** wat aangebied gaan word. Hou dus **altyd hierdie moontlikheid in gedagte**.

## Ander interessante truuks

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [Android IME / InputMethodService Abuse (Malicious Keyboards)](inputmethodservice-ime-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Onttrek APK vanaf toestel:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Voeg alle splits en base apks saam met [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Android Enterprise & Work Profile Attacks

{{#ref}}
android-enterprise-work-profile-bypass.md
{{#endref}}

## Gevallestudies & Kwesbaarhede


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}


{{#ref}}
../../binary-exploitation/linux-kernel-exploitation/arm64-static-linear-map-kaslr-bypass.md
{{#endref}}

## Statiese Analise

Eerstens, om 'n APK te analiseer moet jy **kyk na die Java code** met 'n decompiler.\
Lees asseblief [**hier om inligting te vind oor verskillende beskikbare decompilers**](apk-decompilers.md).

### Soek na interessante inligting

Deur net na die **strings** van die APK te kyk kan jy soek na **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** sleutels, **encryption**, **bluetooth uuids**, **tokens** en enigiets interessant... kyk selfs vir code execution **backdoors** of authentication backdoors (hardcoded admin credentials in die app).

**Firebase**

Gee spesiale aandag aan **firebase URLs** en kontroleer of dit verkeerd gekonfigureer is. [Meer inligting oor wat Firebase is en hoe om dit te misbruik hier.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Basiese begrip van die toepassing - Manifest.xml, strings.xml

Die **ondersoek van 'n toepassing se _Manifest.xml_ en _strings.xml_ lêers kan moontlike sekuriteitskwesbaarhede ontbloot**. Hierdie lêers is toeganklik met decompilers of deur die APK-lêeruitbreiding na .zip te hernoem en dit uit te pak.

**Kwesbaarhede** geïdentifiseer uit die **Manifest.xml** sluit in:

- **Debuggable Applications**: Toepassings gemerk as debuggable (`debuggable="true"`) in die _Manifest.xml_ lêer vorm 'n risiko aangesien dit verbindings toelaat wat uitbuiting kan moontlik maak. Vir meer begrip oor hoe om debuggable applications te misbruik, verwys na 'n tutorial oor die vind en misbruik van debuggable applications op 'n toestel.
- **Backup Settings**: Die `android:allowBackup="false"` attribuut moet eksplisiet gestel word vir toepassings wat met sensitiewe inligting werk om ongemagtigde databackups via adb te voorkom, veral wanneer usb debugging geaktiveer is.
- **Network Security**: Pasgemaakte network security konfigurasies (`android:networkSecurityConfig="@xml/network_security_config"`) in _res/xml/_ kan sekuriteitsdetail soos certificate pins en HTTP traffic instellings spesifiseer. 'n Voorbeeld is om HTTP traffic vir spesifieke domeine toe te laat.
- **Exported Activities and Services**: Identifisering van exported activities en services in die manifest kan komponente uitlig wat misbruik kan word. Verdere ontleding tydens dinamiese toetsing kan openbaar hoe om hierdie komponente uit te buit.
- **Content Providers and FileProviders**: Blootgestelde content providers kan ongemagtigde toegang of wysiging van data toelaat. Die konfigurasie van FileProviders moet ook deeglik ondersoek word.
- **Broadcast Receivers and URL Schemes**: Hierdie komponente kan gebruik word vir uitbuiting, met besondere aandag aan hoe URL schemes bestuur word vir input kwesbaarhede.
- **SDK Versions**: Die `minSdkVersion`, `targetSDKVersion`, en `maxSdkVersion` attributte dui die ondersteunede Android weergawes aan, wat die belangrikheid beklemtoon om verouderde, kwesbare Android weergawes nie te ondersteun nie.

Uit die **strings.xml** lêer kan sensitiewe inligting soos API sleutels, custom schemas en ander ontwikkelaarsnotas gevind word, wat die nodigheid beklemtoon om hierdie hulpbronne sorgvuldig na te gaan.

### Tapjacking

**Tapjacking** is 'n aanval waar 'n **malicious** **application** gelanseer word en **op die top van 'n slagoffer-app posisioneer**. Sodra dit die slagoffer-app sigbaar bedek, is die gebruikerskoppelvlak so ontwerp dat dit die gebruiker mislei om daarmee te interaksie, terwyl dit die interaksie aan die slagoffer-app deurgee.\
In effek **verblind dit die gebruiker sodat hulle nie weet dat hulle eintlik aksies op die slagoffer-app uitvoer nie**.

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

'n **Activity** met die **`launchMode`** gestel op **`singleTask` sonder enige `taskAffinity`** gedefinieer is vatbaar vir task Hijacking. Dit beteken dat 'n **application** geïnstalleer kan word en as dit voor die werklike toepassing gelanseer word, dit die **task van die werklike toepassing kan kap** (sodat die gebruiker met die **malicious application sal interaksie hê en dink hy gebruik die werklike een**).

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Onveilige data-berging

**Internal Storage**

In Android is lêers wat in **internal** storage **gestoor** is ontwerp om **uitsluitend deur die app wat dit geskep het** toeganklik te wees. Hierdie sekuriteitsmaatreël word deur die Android bedryfstelsel afgedwing en is oor die algemeen voldoende vir meeste toepassings se sekuriteitsbehoeftes. Ontwikkelaars gebruik soms egter modusse soos `MODE_WORLD_READABLE` en `MODE_WORLD_WRITABLE` om lêers tussen verskillende toepassings te **deel**. Hierdie modusse **beperk nie die toegang** tot hierdie lêers deur ander toepassings nie, insluitend potensieel kwaadwillige toepassings.

1. **Static Analysis:**
- **Kontroleer** dat die gebruik van `MODE_WORLD_READABLE` en `MODE_WORLD_WRITABLE` **sorgvuldig nagegaan** word. Hierdie modusse **kan lêers blootstel** aan onbedoelde of ongemagtigde toegang.
2. **Dynamic Analysis:**
- **Verifieer** die **permissies** wat op lêers geskep deur die app gestel is. Kontroleer spesifiek of enige lêers **stelbaar is om wêreldwyd leesbaar of skryfbaar te wees**. Dit kan 'n beduidende sekuriteitsrisiko wees, aangesien dit **enige application** op die toestel sal toelaat om hierdie lêers te **lees of wysig**, ongeag oorsprong of bedoeling.

**External Storage**

Wanneer daar met lêers op **external storage** gewerk word, soos SD Cards, moet sekere voorsorgmaatreëls getref word:

1. **Toeganklikheid**:
- Lêers op external storage is **globaal leesbaar en skryfbaar**. Dit beteken enige toepassing of gebruiker kan toegang tot hierdie lêers kry.
2. **Sekuriteitsbedenkings**:
- As gevolg van die maklike toegang word dit aanbeveel **om nie sensitiewe inligting op external storage te stoor nie**.
- External storage kan verwyder of deur enige toepassing benader word, wat dit minder veilig maak.
3. **Hantering van data vanaf External Storage**:
- Voer altyd **input validation** uit op data wat vanaf external storage gehaal word. Dit is noodsaaklik omdat die data van 'n onbetroubare bron kom.
- Dit word sterk afgerader om uitvoerbare lêers of class files op external storage te stoor vir dinamiese laai.
- As jou toepassing uitvoerbare lêers van external storage moet haal, maak seker dat hierdie lêers **gesigneer en kriptografies geverifieer** is voordat hulle dinamies gelaai word. Hierdie stap is noodsaaklik om die veiligheidsintegriteit van jou toepassing te handhaaf.

External storage kan geaccess word in `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> Beginnend met Android 4.4 (**API 17**), het die SD-kaart 'n gidsstruktuur wat **toegang van 'n app beperk tot die gids wat spesifiek vir daardie app is**. Dit voorkom dat kwaadwillige toepassings lees- of skryf-toegang tot 'n ander app se lêers kry.

**Sensitiewe data gestoor in plain-tekst**

- **Shared preferences**: Android laat elke toepassing toe om maklik xml-lêers te stoor in die pad `/data/data/<packagename>/shared_prefs/` en soms is dit moontlik om sensitiewe inligting in plain-tekst in daardie gids te vind.
- **Databases**: Android laat elke toepassing toe om sqlite-databasisse te stoor in die pad `/data/data/<packagename>/databases/` en soms is dit moontlik om sensitiewe inligting in plain-tekst in daardie gids te vind.

### Broken TLS

**Accept All Certificates**

Om onduidelike redes aanvaar ontwikkelaars soms alle sertifikate selfs al stem die hostname byvoorbeeld nie ooreen nie, met reëls van code soos die volgende:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Gebroke kriptografie

**Swak sleutelbestuurprosesse**

Sommige ontwikkelaars stoor sensitiewe data in die plaaslike stoorplek en enkripteer dit met 'n sleutel wat hardgecodeer/voorspelbaar in die kode is. Dit behoort nie gedoen te word nie aangesien reversing aanvallers kan toelaat om die vertroulike inligting uit te trek.

**Gebruik van onveilige en/of verouderde algoritmes**

Ontwikkelaars moet nie **verouderde algoritmes** gebruik om authorisation **checks** uit te voer, data te **store** of te **send** nie. Sommige van hierdie algoritmes is: RC4, MD4, MD5, SHA1... As **hashes** byvoorbeeld gebruik word om passwords te store, moet hashes wat teen brute-force **bestand** is gebruik word saam met salt.

### Ander kontroles

- Dit word aanbeveel om die **APK te obfuskeren** om die reverse engineer-werk vir aanvallers moeiliker te maak.
- As die app sensitief is (soos bank apps), moet dit sy **eie kontroles uitvoer om te sien of die mobile is rooted** en dienooreenkomstig optree.
- As die app sensitief is (soos bank apps), moet dit kontroleer of 'n **emulator** gebruik word.
- As die app sensitief is (soos bank apps), moet dit **sy eie integriteit kontroleer voordat dit uitgevoer word** om te sien of dit gemodifiseer is.
- Use [**APKiD**](https://github.com/rednaga/APKiD) to check which compiler/packer/obfuscator was used to build the APK

### React Native Application

Lees die volgende bladsy om te leer hoe om maklik toegang tot javascript kode van React applications te kry:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Lees die volgende bladsy om te leer hoe om maklik toegang tot C# kode van 'n xamarin applications te kry:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. Die blog praat oor die moontlikheid om 'n app te skep wat hierdie soort apps dekomprimeer... en 'n vinniger manier wat behels om die **toepassing uit te voer en die decompressed files from the filesystem**.

### Automated Static Code Analysis

Die hulpmiddel [**mariana-trench**](https://github.com/facebook/mariana-trench) is in staat om **kwesbaarhede** te vind deur die **kode** van die toepassing te **scan**. Hierdie hulpmiddel bevat 'n serie van **known sources** (wat aan die hulpmiddel aandui die **plekke** waar die **input** deur die **user** beheer word), **sinks** (wat aan die hulpmiddel aandui **gevaarlike** **plekke** waar kwaadwillige gebruikersinvoer skade kan veroorsaak) en **rules**. Hierdie reëls dui die **kombinasie** van **sources-sinks** aan wat 'n kwetsbaarheid aandui.

Met hierdie kennis sal **mariana-trench die kode hersien en moontlike kwetsbaarhede daarin vind**.

### Secrets leaked

An application may contain secrets (API keys, passwords, hidden urls, subdomains...) inside of it that you might be able to discover. You could us a tool such as [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Ander interessante funksies

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Stuur SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)
- In-memory native code execution via JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dinamiese analise

> First of all, you need an environment where you can install the application and all the environment (Burp CA cert, Drozer and Frida mainly). Therefore, a rooted device (emulated or not) is extremely recommended.

### Aanlyn dinamiese analise

Jy kan 'n **free account** skep by: [https://appetize.io/](https://appetize.io). Hierdie platform laat jou toe om APKs te **upload** en te **execute**, so dit is nuttig om te sien hoe 'n apk gedra.

Jy kan selfs **die logs van jou toepassing** op die web sien en verbind deur **adb**.

![](<../../images/image (831).png>)

Danksy die ADB-verbinding kan jy **Drozer** en **Frida** binne die emulators gebruik.

### Lokale dinamiese analise

#### Gebruik van 'n emulator

- [**Android Studio**](https://developer.android.com/studio) (Jy kan **x86** en **arm** toestelle skep, en volgens [**this**](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html) **latest x86** versions **support ARM libraries** without needing an slow arm emulator).
- Leer om dit op te stel op hierdie bladsy:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, jy moet 'n rekening skep. _It's recommend to **download** the version **WITH**_ _**VirtualBox** to avoid potential errors._)
- [**Nox**](https://es.bignox.com) (Free, maar dit ondersteun nie Frida of Drozer nie).

> [!TIP]
> Wanneer jy 'n nuwe emulator op enige platform skep, onthou dat hoe groter die skerm is, hoe stadiger die emulator sal loop. Kies dus kleiner skerms indien moontlik.

Om **google services** (soos AppStore) in Genymotion te installeer moet jy op die rooi gemerkte knoppie in die volgende beeld klik:

![](<../../images/image (277).png>)

Let ook daarop dat in die **konfigurasie van die Android VM in Genymotion** jy **Bridge Network mode** kan kies (dit sal nuttig wees as jy vanaf 'n ander VM met die gereedskap aan die Android VM wil koppel).

#### Gebruik 'n fisiese toestel

Jy moet die **debugging** opsies aktiveer en dit sal goed wees as jy dit kan **root**:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Sodra jy die toepassing geïnstalleer het, is die eerste ding wat jy moet doen om dit te probeer en ondersoek wat dit doen, hoe dit werk en gemaklik daarmee te raak.  
> Ek stel voor om **hierdie aanvanklike dinamiese analise met MobSF dynamic analysis + pidcat** uit te voer, sodat ons kan **leer hoe die toepassing werk** terwyl MobSF baie **interessante** **data** vasvang wat jy later kan hersien.

Magisk/Zygisk quick notes (recommended on Pixel devices)
- Patch boot.img with the Magisk app and flash via fastboot to get systemless root
- Enable Zygisk + DenyList for root hiding; consider LSPosed/Shamiko when stronger hiding is required
- Keep original boot.img to recover from OTA updates; re-patch after each OTA
- For screen mirroring, use scrcpy on the host



### Onbedoelde data leaks

**Logging**

Ontwikkelaars moet versigtig wees om **debugging information** publiek te openbaar, aangesien dit tot sensitiewe data leaks kan lei. Die gereedskap [**pidcat**](https://github.com/JakeWharton/pidcat) en `adb logcat` word aanbeveel om toepassingslogs te monitor om sensitiewe inligting te identifiseer en te beskerm. **Pidcat** word graag gebruik vir sy gemak en leesbaarheid.

> [!WARNING]
> Let daarop dat vanaf **later newer than Android 4.0**, **applications are only able to access their own logs**. Dus kan toepassings nie ander apps se logs benader nie.  
> Dit word egter steeds aanbeveel om **nie sensitiewe inligting te log nie**.

**Kopieer/Plak-klembord**

Android se **clipboard-based** raamwerk maak kopieer-plak funksionaliteit in apps moontlik, maar stel 'n risiko omdat **other applications** die klembord kan **access**, wat potensieel sensitiewe data kan blootlê. Dit is noodsaaklik om kopieer/plak-funksies vir sensitiewe gedeeltes van 'n toepassing, soos kredietkaartbesonderhede, te **disable** om data leaks te voorkom.

**Crash Logs**

As 'n toepassing **crashes** en **saves logs**, kan hierdie logs aanvallers help, veral wanneer die toepassing nie gereverse-engineer kan word nie. Om hierdie risiko te verminder, vermy om by crashes te log, en as logs oor die netwerk gestuur moet word, maak seker dat hulle via 'n SSL-kanaal gestuur word vir sekuriteit.

As pentester, **try to take a look to these logs**.

**Analytics Data Sent To 3rd Parties**

Toepassings integreer dikwels dienste soos Google Adsense, wat per ongeluk sensitiewe data kan leak as gevolg van onvanpaste implementering deur ontwikkelaars. Om potensiële data leaks te identifiseer, is dit raadsaam om die verkeer van die toepassing te onderskep en te kontroleer vir enige sensitiewe inligting wat aan derde partye gestuur word.

### SQLite DBs

Die meeste toepassings sal **internal SQLite databases** gebruik om inligting te stoor. Tydens die pentest kyk na die **databases** wat geskep is, die name van **tables** en **columns** en al die **data** wat gestoor is omdat jy sensitiewe inligting kan vind (wat 'n kwetsbaarheid sou wees).  
Databasisse behoort te lê in `/data/data/the.package.name/databases` soos `/data/data/com.mwr.example.sieve/databases`

As die database vertroulike inligting stoor en **encrypted** is maar jy kan die **password** binne die toepassing **find**, is dit steeds 'n **vulnerability**.

Enumereer die tabelle met `.tables` en enumereer die kolomme van die tabelle met `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system.  
Drozer is 'n useful tool to **exploit exported activities, exported services and Content Providers** as you will learn in the following sections.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)  
Also remember that the code of an activity starts in the **`onCreate`** method.

**Authorisation bypass**

When an Activity is exported you can invoke its screen from an external app. Therefore, if an activity with **sensitive information** is **exported** you could **bypass** the **authentication** mechanisms **to access it.**

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

You can also start an exported activity from adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> Neem kennis dat an authorisation bypass nie altyd 'n kwesbaarheid is nie — dit hang af van hoe die bypass werk en watter inligting blootgestel word.

**Sensitive information leakage**

**Activities can also return results**. As jy daarin slaag om 'n exported en onbeveiligde activity te vind wat die **`setResult`**-metode aanroep en **sensitiewe inligting teruggee**, is daar 'n sensitive information leakage.

#### Tapjacking

As tapjacking nie verhoed word nie, kan jy die exported activity misbruik om die **gebruiker onvoorsiene aksies uit te laat voer**. Vir meer inligting oor [**wat Tapjacking is volg die skakel**](#tapjacking).

### Exploiting Content Providers - Toegang tot en manipulasie van sensitiewe inligting

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)  
Content providers word hoofsaaklik gebruik om **data te deel**. As 'n app beskikbare content providers het, kan jy dalk **sensitiewe** data daaruit onttrek. Dit is ook interessant om moontlike **SQL injections** en **Path Traversals** te toets, aangesien hulle kwesbaar kan wees.

[**Leer hoe om Content Providers met Drozer te exploiteer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)  
Onthou dat die aksies van 'n Service begin in die metode `onStartCommand`.

'n Service is basies iets wat **data kan ontvang**, dit kan **verwerk** en (al dan nie) 'n **respons terugstuur**. As 'n toepassing dus sekere services exporteer, moet jy die **code** nagaan om te verstaan wat dit doen en dit **dinamies toets** om vertroulike inligting te onttrek, outhentiseringsmaatreëls te omseil, ens.  
[**Leer hoe om Services met Drozer te exploiteer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)  
Onthou dat die aksies van 'n Broadcast Receiver begin in die metode `onReceive`.

'n Broadcast Receiver wag vir 'n tipe boodskap. Afhangend van hoe die receiver die boodskap hanteer, kan dit kwesbaar wees.  
[**Leer hoe om Broadcast Receivers met Drozer te exploiteer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Jy kan handmatig vir deep links soek, met gereedskap soos MobSF of skripte soos [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).  
Jy kan 'n verklaarde **scheme** **open** using **adb** or a **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Neem kennis dat jy **die pakketnaam kan weglaat** en die mobiele toestel sal outomaties die app aanroep wat daardie skakel behoort oop te maak._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Kode uitgevoer**

Om die **kode wat in die App uitgevoer sal word** te vind, gaan na die activity wat deur die deeplink aangeroep word en soek die funksie **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Gevoelige inligting**

Elke keer as jy 'n deep link vind, maak seker dat dit nie gevoelige data (soos passwords) via URL parameters ontvang nie, want enige ander toepassing kan die deep link naboots en daardie data steel!

**Parameters in path**

Jy **moet ook kontroleer of enige deep link 'n parameter binne die pad gebruik** van die URL soos: `https://api.example.com/v1/users/{username}`, in daardie geval kan jy 'n path traversal afdwing deur toegang te verkry soos: `example://app/users?username=../../unwanted-endpoint%3fparam=value`.  
Noteer dat as jy die korrekte endpoints binne die toepassing vind, jy moontlik 'n **Open Redirect** kan veroorsaak (as 'n deel van die pad as domain name gebruik word), **account takeover** (as jy gebruikersbesonderhede kan wysig sonder 'n CSRF token en die vuln endpoint die korrekte metode gebruik) en enige ander vuln. More [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Transport Layer-inspeksie en verifikasie-foute

- **Sertifikate word nie altyd behoorlik geïnspekteer nie** deur Android-toepassings. Dit is algemeen dat hierdie toepassings waarskuwings ignoreer en self-signed sertifikate aanvaar of, in sommige gevalle, terugval na die gebruik van HTTP-verbindinge.
- **Onderhandelinge tydens die SSL/TLS-handshake is soms swak**, en maak gebruik van onveilige cipher suites. Hierdie kwesbaarheid maak die verbinding vatbaar vir man-in-the-middle (MITM) aanvalle, wat aanvallers toelaat om die data te dekripteer.
- **Leakage of private information** is 'n risiko wanneer toepassings authenticate met behulp van veilige kanale maar dan oor nie-veilige kanale kommunikeer vir ander transaksies. Hierdie benadering misluk om gevoelige data, soos session cookies of gebruikersbesonderhede, teen onderskeping deur kwaadwilliges te beskerm.

#### Sertifikaatverifikasie

Ons sal fokus op **certificate verification**. Die integriteit van die bediener se sertifikaat moet geverifieer word om veiligheid te verbeter. Dit is kritiek omdat onveilige TLS-konfigurasies en die oordrag van gevoelige data oor onversleutelde kanale beduidende risiko's kan meebring. Vir gedetailleerde stappe oor die verifikasie van bediener-sertifikate en die aanspreek van kwesbaarhede, bied [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) omvattende leiding.

#### SSL Pinning

SSL Pinning is 'n sekuriteitsmaatreël waar die toepassing die bediener se sertifikaat vergelyk met 'n bekende kopie wat binne die toepassing gestoor is. Hierdie metode is noodsaaklik om MITM-aanvalle te voorkom. Implementering van SSL Pinning word sterk aanbeveel vir toepassings wat gevoelige inligting hanteer.

#### Traffic Inspection

Om HTTP-verkeer te inspekteer, is dit nodig om die **proxy tool se sertifikaat te installeer** (bv. Burp). Sonder om hierdie sertifikaat te installeer, mag versleutelde verkeer nie deur die proxy sigbaar wees nie. Vir 'n gids oor die installering van 'n custom CA certificate, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Toepassings wat op **API Level 24 and above** mik, vereis wysigings aan die Network Security Config om die proxy se CA certificate te aanvaar. Hierdie stap is kritiek om versleutelde verkeer te inspekteer. Vir instruksies oor die wysiging van die Network Security Config, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

As **Flutter** gebruik word, moet jy die instruksies in [**this page**](flutter.md) volg. Dit is omdat net om die sertifikaat in die store by te voeg nie sal werk nie, aangesien Flutter sy eie lys van geldige CAs het.

#### Statiese opsporing van SSL/TLS pinning

Voordat jy runtime bypasses probeer, karteer vinnig waar pinning in die APK afgedwing word. Statiese ontdekking help jou om hooks/patches te beplan en op die regte kodepaaie te fokus.

Tool: SSLPinDetect
- Open-source static-analysis utility wat die APK to Smali decompileer (via apktool) en skandeer vir gekurateerde regex-patrone van SSL/TLS pinning implementasies.
- Rapporteer die presiese lêerpad, reëlnommer, en 'n kodefragment vir elke tref.
- Dek algemene frameworks en custom code paths: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init met custom TrustManagers/KeyManagers, en Network Security Config XML pins.

Install
- Vereistes: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Gebruik
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Voorbeeld patroonreëls (JSON)

Gebruik of brei signatures uit om proprietary/custom pinning styles te detecteer. Jy kan jou eie JSON laai en op skaal scan.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Aantekeninge en wenke
- Vinnige skandering op groot apps via multi-threading en memory-mapped I/O; vooraf-gekompileerde regex verminder oorhoofse werk/vals positiewe.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Tipiese opsporingsdoelwitte om daarna te prioritiseer:
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Aangepaste TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Aangepaste SSL-kontekste: SSLContext.getInstance + SSLContext.init with custom managers
- Deklareerbare pins in res/xml network security config en manifestverwysings
- Gebruik die ooreenstemmende plekke om Frida hooks, statiese patches, of konfigurasie-oorsigte te beplan voordat dinamiese toetsing gedoen word.



#### Om SSL Pinning te omseil

Wanneer SSL Pinning geïmplementeer is, word dit nodig om dit te omseil om HTTPS-verkeer te inspekteer. Verskeie metodes is beskikbaar vir hierdie doel:

- Automatically **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Die hoof voordeel van hierdie opsie is dat jy nie root nodig het om die SSL Pinning te omseil nie, maar jy sal die toepassing moet verwyder en die nuwe weer moet installeer, en dit werk nie altyd nie.
- You could use **Frida** (discussed below) to bypass this protection. Here you have a guide to use Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- You can also try to **automatically bypass SSL Pinning** using [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- You can also try to **automatically bypass SSL Pinning** using **MobSF dynamic analysis** (explained below)
- If you still think that there is some traffic that you aren't capturing you can try to **forward the traffic to burp using iptables**. Read this blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Soek na Algemene Web-kwesbaarhede

Dit is belangrik om ook binne die toepassing na algemene web-kwesbaarhede te soek. Gedetailleerde inligting oor die identifisering en versagting van hierdie kwesbaarhede val buite die omvang van hierdie opsomming, maar word elders uitvoerig behandel.

### Frida

[Frida](https://www.frida.re) is a dynamic instrumentation toolkit for developers, reverse-engineers, and security researchers.\
**Jy kan toegang kry tot 'n draaiende toepassing en metode-hooks by runtime toepas om die gedrag te verander, waardes te wysig, waardes uit te haal, andersins kode uit te voer...**\
As jy Android-toepassings wil pentest, moet jy weet hoe om Frida te gebruik.

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Some "GUI" for actions with Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- You can find some Awesome Frida scripts here: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Try to bypass anti-debugging / anti-frida mechanisms loading Frida as in indicated in [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentering & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

Kontroleer of die toepassing sensitiewe inligting in die geheue stoor wat dit nie behoort te stoor nie, soos wagwoorde of mnemoniese frases.

Using [**Fridump3**](https://github.com/rootbsd/fridump3) you can dump the memory of the app with:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Dit sal die memory in die ./dump folder dump, en daar kan jy grep met iets soos:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Sensitiewe data in Keystore**

In Android is die Keystore die beste plek om sensitiewe data te stoor, maar met genoeg voorregte is dit steeds **moontlik om toegang daartoe te kry**. Aangesien toepassings geneig is om **sensitiewe data in duidelike teks** hier te stoor, moet die pentests dit as root user nagaan, want iemand met fisiese toegang tot die toestel kan hierdie data steel.

Selfs as 'n app data in die keystore stoor, moet die data geënkripteer wees.

Om by die data binne die keystore uit te kom, kan jy hierdie Frida script gebruik: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Vingerafdruk/Biometrie Omseiling**

Deur die volgende Frida-skrip te gebruik kan dit moontlik wees om die **vingerafdruk-verifikasie** wat Android-toepassings dalk uitvoer te **omseil** om sekere sensitiewe gebiede te **beskerm:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Agtergrondbeelde**

Wanneer jy 'n toepassing na die agtergrond skuif, stoor Android 'n **snapshot van die toepassing** sodat wanneer dit na die voorgrond herstel word, dit eers die beeld begin laai voordat die app begin, sodat dit lyk asof die app vinniger gelaai is.

As hierdie snapshot egter **gevoelige inligting** bevat, kan iemand met toegang tot die snapshot daardie inligting **steel** (let wel: jy benodig root-toegang om dit te kan bereik).

Die snapshots word gewoonlik gestoor by: **`/data/system_ce/0/snapshots`**

Android bied 'n manier om die **opname van skermkiekies te voorkom deur die FLAG_SECURE layout-parameter te stel**. Deur hierdie flag te gebruik, word die vensterinhoud as veilig behandel, wat verhoed dat dit in skermkiekies verskyn of op nie-veilig vertonings gesien kan word.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Hierdie hulpmiddel kan jou help om verskeie gereedskap tydens die dinamiese ontleding te bestuur: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Ontwikkelaars skep dikwels proxy-komponente soos activities, services en broadcast receivers wat hierdie Intents hanteer en dit aan metodes soos `startActivity(...)` of `sendBroadcast(...)` deurgee, wat riskant kan wees.

Die gevaar lê daarin om aanvallers toe te laat om nie-geëxporteerde app-komponente te aktiveer of sensitiewe content providers te bereik deur hierdie Intents verkeerd te lei. 'n Noemenswaardige voorbeeld is die `WebView`-komponent wat URL's na `Intent`-objecte omskakel via `Intent.parseUri(...)` en dit dan uitvoer, wat moontlik tot malicious Intent injections kan lei.

### Belangrike punte

- **Intent Injection** is soortgelyk aan die web se Open Redirect-kwessie.
- Eksploite behels om `Intent`-objekte as extras deur te gee, wat herlei kan word om onveilige operasies uit te voer.
- Dit kan nie-geëxporteerde komponente en content providers aan aanvallers blootstel.
- Die `WebView` se omskakeling van URL's na `Intent` kan onbeoogde aksies vergemaklik.

### Android Client Side Injections en ander

Jy ken waarskynlik hierdie soort kwesbaarhede van die web. Jy moet besonders versigtig wees met hierdie kwesbaarhede in 'n Android-toepassing:

- **SQL Injection:** Wanneer jy te make het met dinamiese navrae of Content-Providers, maak seker jy gebruik geparametriseerde navrae.
- **JavaScript Injection (XSS):** Maak seker dat JavaScript- en Plugin-ondersteuning vir enige WebViews gedeaktiveer is (gedeaktiveer per verstek). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews behoort toegang tot die lêerstelsel gedeaktiveer te hê (per verstek geaktiveer) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: In verskeie gevalle, wanneer die Android-toepassing die sessie beëindig, word die cookie nie herroep nie of dit kan selfs op skyf gestoor word
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Outomatiese Analise

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Statiese ontleding**

![](<../../images/image (866).png>)

**Kwetsbaarheidsassessering van die toepassing** met 'n netjiese web-gebaseerde frontend. Jy kan ook dinamiese ontleding doen (maar jy moet die omgewing voorberei).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Let op dat MobSF kan analiseer **Android**(apk)**, IOS**(ipa) **and Windows**(apx) toepassings (_Windows-toepassings moet ontleed word vanaf 'n MobSF wat op 'n Windows-host geïnstalleer is_).\
Ook, as jy 'n **ZIP**-lêer met die bronkode van 'n **Android** of 'n **IOS**-app skep (gaan na die wortelgids van die toepassing, kies alles en skep 'n ZIP-lêer), sal dit dit ook kan analiseer.

MobSF laat jou ook toe om **diff/Compare** ontledings te doen en om **VirusTotal** te integreer (jy sal jou API-sleutel in _MobSF/settings.py_ moet instel en dit aktiveer: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). Jy kan ook `VT_UPLOAD` op `False` stel, dan sal die **hash** in plaas van die lêer opgelaai word.

### Assisted Dynamic analysis with MobSF

**MobSF** kan ook baie nuttig wees vir **dynamic analysis** in **Android**, maar in daardie geval sal jy MobSF en **genymotion** op jou host moet installeer (n VM of Docker gaan nie werk nie). _Nota: Jy moet eers 'n VM in genymotion begin en **dan** MobSF._\
Die **MobSF dynamic analyser** kan:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). Dit word alles outomaties gedoen behalwe vir die skermkiekies — jy moet druk wanneer jy 'n skermkiekie wil hê of jy moet druk "**Exported Activity Tester**" om skermkiekies van al die exported activities te kry.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF kan ook **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF laat jou ook toe om jou eie **Frida scripts** te laai (om die resultate van jou Frida scripts na MobSF te stuur gebruik die funksie `send()`). Dit het ook **veral geskryfde scripts** wat jy kan laai (jy kan meer byvoeg in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), kies net **them**, druk "**Load**" en druk "**Start Instrumentation**" (jy sal die logs van daardie scripts binne "**Frida Live Logs**" kan sien).

![](<../../images/image (419).png>)

Verder het jy 'n paar aanvullende Frida-funksies:

- **Enumerate Loaded Classes**: Dit sal al die gelaaide klasse uitdruk
- **Capture Strings**: Dit sal al die vasgelegde stringe uitstuur terwyl jy die toepassing gebruik (baie luidrugtig)
- **Capture String Comparisons**: Kan baie nuttig wees. Dit sal **die 2 stringe wat vergelyk word wys** en of die resultaat True of False was.
- **Enumerate Class Methods**: Gee die klassenaam (soos "java.io.File") en dit sal al die metodes van die klas druk.
- **Search Class Pattern**: Soek klasse per patroon
- **Trace Class Methods**: **Trace** 'n **hele klas** (sien insette en uitsette van alle metodes van die klas). Onthou dat standaard MobSF verskeie interessante Android Api methods trace.

Sodra jy die hulpmoduut gekies het wat jy wil gebruik, moet jy op "**Start Intrumentation**" druk en jy sal al die uitvoer in "**Frida Live Logs**" sien.

**Shell**

MobSF gee jou ook 'n shell met sommige **adb** commands, **MobSF commands**, en algemene **shell** **commands** onderaan die dynamic analysis bladsy. Sommige interessante opdragte:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP tools**

Wanneer HTTP-verkeer vasgelê word, kan jy 'n lelike weergawe van die vasgelê verkeer sien op die "**HTTP(S) Traffic**" knoppie of 'n netter weergawe op die groen "**Start HTTPTools**" knoppie. Vanaf die tweede opsie kan jy die **captured requests** stuur na **proxies** soos Burp of Owasp ZAP.\
Om dit te doen, _skakel Burp aan -->_ _skakel Intercept af --> in MobSB HTTPTools kies die request_ --> druk "**Send to Fuzzer**" --> _kies die proxy-adres_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Sodra jy die dinamiese analise met MobSF voltooi het, kan jy op "**Start Web API Fuzzer**" druk om **fuzz http requests** te doen en na kwesbaarhede te soek.

> [!TIP]
> Na die uitvoering van 'n dinamiese analise met MobSF kan die proxy-instellings verkeerd gekonfigureer wees en sal jy dit nie vanuit die GUI kan regmaak nie. Jy kan die proxy-instellings herstel deur:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Geassisteerde dinamiese ontleding met Inspeckage

You can get the tool from [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Hierdie instrument gebruik 'n paar **Hooks** om jou te wys **wat in die toepassing gebeur** terwyl jy 'n **dinamiese analise** uitvoer.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Dit is 'n **geweldige instrument om static analysis met 'n GUI uit te voer**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Hierdie tool is ontwerp om na verskeie sekuriteitsverwante Android-toepassings-kwesbaarhede te soek, hetsy in **source code** of **packaged APKs**. Die tool is ook **capable of creating a "Proof-of-Concept" deployable APK** en **ADB commands** om sommige van die gevonde kwesbaarhede te eksploiteer (Exposed activities, intents, tapjacking...). Soos met Drozer, is dit nie nodig om die toetstoestel te root nie.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Wys alle onttrekte lêers vir maklike verwysing
- Dekompileer APK-lêers outomaties na Java- en Smali-formaat
- Analiseer AndroidManifest.xml vir algemene kwesbaarhede en gedrag
- Statiese bronkode-analise vir algemene kwesbaarhede en gedrag
- Toestelinligting
- en meer
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER is 'n opdragreëltoepassing wat op Windows, MacOS X en Linux gebruik kan word, en wat _.apk_ lêers ontleed op soek na kwesbaarhede. Dit doen dit deur APKs te dekomprimeer en 'n reeks reëls toe te pas om daardie kwesbaarhede op te spoor.

Alle reëls is sentreer in die `rules.json` lêer, en elke maatskappy of toetser kan sy eie reëls skep om te ontleed wat hulle nodig het.

Laai die jongste binaries af vanaf die [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn is 'n **crossplatform** tool wat ontwikkelaars, bugbounty hunters en ethical hackers help met [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) op mobiele toepassings.

Die konsep is dat jy jou mobiele toepassingslêer (an .apk or .ipa file) op die StaCoAn-toepassing sleur en los, en dit sal 'n visuele en draagbare verslag vir jou genereer. Jy kan die instellings en wordlists aanpas om 'n aangepaste ervaring te kry.

Download[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework is 'n Android-kwesbaarheid-analisesisteem wat ontwikkelaars of hackers help om potensiële sekuriteitskwesbaarhede in Android-toepassings te vind.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** is 'n hulpmiddel waarvan die hoofdoel is om potensieel kwaadwillige gedrag wat deur 'n Android-toepassing ontwikkel is, op te spoor en die gebruiker daaroor te waarsku.

Die opsporing word uitgevoer deur die **static analysis** van die toepassing se Dalvik bytecode, wat as **Smali** voorgestel word, met die [`androguard`](https://github.com/androguard/androguard) biblioteek.

Hierdie hulpmiddel soek na **algemene gedrag van "slegte" toepassings** soos: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. Dit is 'n hulpmiddel wat algemeen gebruikte mobile application reverse engineering- en analise-instrumente bymekaar sit om te help met die toetsing van mobiele toepassings teen die OWASP mobile security threats. Dit het ten doel om hierdie taak makliker en meer gebruikersvriendelik te maak vir mobiele toepassingsontwikkelaars en sekuriteitsprofessionals.

Dit kan:

- Onttrek Java- en Smali-kode met verskeie gereedskap
- Analiseer APK's met behulp van: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Onttrek privaat inligting uit die APK met regexps.
- Analiseer die Manifest.
- Analiseer gevonde domeine met behulp van: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com](http://apk-deguard.com)

### Koodous

Nuttig om malware op te spoor: [https://koodous.com/](https://koodous.com/)

## Obfuskering/Deobfuskering van kode

Neem kennis dat, afhangende van die diens en konfigurasie wat jy gebruik om die kode te obfuskeer, geheime moontlik wel of nie obfuskeer sal wees nie.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

Van [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is 'n open source opdragreël-hulpmiddel wat Java-kode verklein, optimaliseer en obfuskeer. Dit kan bytekode optimaliseer en ongebruikte instruksies opspoor en verwyder. ProGuard is vrye sagteware en word versprei onder die GNU General Public License, weergawe 2.

ProGuard word meeversprei as deel van die Android SDK en loop wanneer die toepassing in release-modus gebou word.

### [DexGuard](https://www.guardsquare.com/dexguard)

Vind 'n stap-vir-stap gids om die apk te deobfuskeer by [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(Uit daardie gids) Die laaste keer wat ons gekyk het, was die Dexguard bedryfswyse:

- laai 'n bron as 'n InputStream;
- voer die resultaat na 'n klas wat van FilterInputStream erf om dit te ontsleutel;
- doen 'n paar nuttelose obfuskasies om 'n paar minute van 'n reverser se tyd te mors;
- voer die ontsleutelde resultaat na 'n ZipInputStream om 'n DEX-lêer te kry;
- laastens laai die resulterende DEX as 'n Resource met die `loadDex` metode.

### [DeGuard](http://apk-deguard.com)

**DeGuard keer die obfuskeringproses om wat deur Android-obfuskeringinstrumente uitgevoer is. Dit stel verskeie sekuriteitsanalises in staat, insluitend kode-inspeksie en die identifisering van biblioteke.**

Jy kan 'n obfuskeerde APK na hul platform oplaai.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

Dit is 'n LLM-instrument om moontlike sekuriteitskwesbaarhede in Android-apps te vind en Android-appkode te deobfuskeer. Gebruik Google's Gemini openbare API.

### [Simplify](https://github.com/CalebFenton/simplify)

Dit is 'n **generiese android deobfuscator.** Simplify **virtueel voer 'n app uit** om sy gedrag te verstaan en probeer dan **die kode optimaliseer** sodat dit identies optree maar makliker vir 'n mens is om te verstaan. Elke tipe optimalisering is eenvoudig en generies, so dit maak nie saak watter spesifieke tipe obfuskering gebruik is nie.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD gee jou inligting oor **hoe 'n APK gemaak is**. Dit identifiseer baie **compilers**, **packers**, **obfuscators**, en ander vreemde goed. Dit is [_PEiD_](https://www.aldeid.com/wiki/PEiD) vir Android.

### Manual

[Lees hierdie handleiding om 'n paar truuks te leer oor **hoe om pasgemaakte obfuskering om te keer**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b is 'n Android-sekuriteits-virtuele masjien gebaseer op ubuntu-mate en sluit 'n versameling van die nuutste frameworks, tutoriale en labs van verskillende sekuriteits-entoesiaste en navorsers vir reverse engineering en malware-analise in.

## Verwysings

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Dit is 'n uitstekende lys hulpbronne
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android vinnige kursus
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
