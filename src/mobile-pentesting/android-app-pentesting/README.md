# Android Uygulamaları Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android Uygulamaları Temelleri

Bu sayfayı okumaya başlamanız kesinlikle tavsiye edilir; çünkü **Android güvenliğiyle ilgili en önemli bölümleri ve bir Android uygulamasındaki en tehlikeli bileşenleri** öğrenmenize yardımcı olur:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Bu, bir android cihaza (emüle edilmiş veya fiziksel) bağlanmak için ihtiyaç duyduğunuz ana araçtır.\
**ADB**, bir bilgisayardan **USB** veya **ağ** üzerinden cihazları kontrol etmeye olanak sağlar. Bu yardımcı program, dosyaların her iki yönde de **kopyalanmasını**, uygulamaların **kurulmasını** ve **kaldırılmasını**, shell komutlarının **çalıştırılmasını**, verilerin **yedeklenmesini**, logların **okunmasını** ve diğer fonksiyonları mümkün kılar.

ADB'yi nasıl kullanacağınızı öğrenmek için aşağıdaki [**ADB Commands**](adb-commands.md) listesine göz atın.

## Smali

Bazen **uygulama kodunu değiştirmek**, **gizli bilgilere** erişmek için ilginç olabilir (örneğin iyi obfuskelenmiş parolalar veya flags). Sonrasında apk'yı decompile edip kodu değiştirip tekrar derlemek ilginç olabilir.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Bu, yapılacak dynamic analysis sırasında sunulacak çeşitli testler için çok yararlı bir alternatif olabilir. Bu olasılığı her zaman aklınızda bulundurun.

## Diğer ilginç ipuçları

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [Android IME / InputMethodService Abuse (Malicious Keyboards)](inputmethodservice-ime-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **APK İndir**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Cihazdan APK çıkar:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Tüm splits ve base apks'leri [APKEditor](https://github.com/REAndroid/APKEditor) ile birleştirin:
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Android Enterprise & Work Profile Attacks

{{#ref}}
android-enterprise-work-profile-bypass.md
{{#endref}}

## Case Studies & Vulnerabilities


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}


{{#ref}}
../../binary-exploitation/linux-kernel-exploitation/arm64-static-linear-map-kaslr-bypass.md
{{#endref}}

## Static Analysis

Öncelikle bir APK'yı analiz ederken bir decompiler kullanarak **Java code**'a bir göz atmalısınız.\
Lütfen, [**farklı mevcut decompilers hakkında bilgi için burayı okuyun**](apk-decompilers.md).

### Looking for interesting Info

Sadece APK'nın **strings**'ine bakarak **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** ve ilginç olabilecek her şeyi arayabilirsiniz... kod execution **backdoors** veya authentication backdoors (uygulamaya gömülü admin kimlik bilgileri) bile arayın.

**Firebase**

Özellikle **Firebase URLs**'lerine dikkat edin ve kötü yapılandırılıp yapılandırılmadığını kontrol edin. [Firebase'in ne olduğu ve nasıl exploit edileceğine dair daha fazla bilgi için burayı okuyun.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Basic understanding of the application - Manifest.xml, strings.xml

Bir uygulamanın **_Manifest.xml_ ve **_strings.xml_** dosyalarının incelenmesi potansiyel güvenlik açıklarını ortaya çıkarabilir**. Bu dosyalara decompiler kullanarak veya APK dosya uzantısını .zip olarak değiştirip açarak erişilebilir.

**Manifest.xml**'den tespit edilebilecek **vulnerabilities** şunlardır:

- **Debuggable Applications**: _Manifest.xml_ dosyasında `debuggable="true"` olarak ayarlanmış uygulamalar risk oluşturur çünkü bağlantılara izin vererek exploitation'a yol açabilir. Debuggable uygulamaların cihazda nasıl bulunup exploit edileceğini anlamak için ilgili eğitim materyallerine bakın.
- **Backup Settings**: Hassas bilgileri işleyen uygulamalar için `android:allowBackup="false"` niteliğinin açıkça ayarlanması gerekir; aksi halde usb debugging etkin olduğunda adb üzerinden yetkisiz veri yedeklemelerine izin verilebilir.
- **Network Security**: _res/xml/_ içinde yer alan özel network security konfigürasyonları (`android:networkSecurityConfig="@xml/network_security_config"`) sertifika pin'leri ve HTTP trafiği ayarları gibi güvenlik detaylarını belirtebilir. Örneğin belirli domainler için HTTP trafiğine izin verme gibi durumlar olabilir.
- **Exported Activities and Services**: Manifest'te exported olarak işaretlenmiş activity ve service'leri belirlemek, kötüye kullanılabilecek bileşenleri ortaya çıkarabilir. Dinamik testler sırasında bu bileşenlerin nasıl exploit edilebileceği daha detaylı analizle ortaya çıkabilir.
- **Content Providers and FileProviders**: Açığa çıkmış content provider'lar yetkisiz erişim veya veri değiştirmeye izin verebilir. FileProvider yapılandırmaları da dikkatle incelenmelidir.
- **Broadcast Receivers and URL Schemes**: Bu bileşenler exploitation için kullanılabilir; özellikle URL scheme'lerinin girdi yönetimi açısından nasıl ele alındığına dikkat edilmelidir.
- **SDK Versions**: `minSdkVersion`, `targetSDKVersion` ve `maxSdkVersion` nitelikleri desteklenen Android versiyonlarını gösterir; eski ve zafiyetli Android sürümlerini desteklememek önemlidir.

**strings.xml** dosyasından API keys, custom schemas ve diğer geliştirici notları gibi hassas bilgiler keşfedilebilir; bu kaynakların dikkatle incelenmesi gerektiğini vurgular.

### Tapjacking

**Tapjacking**, kötü niyetli bir **application**'ın başlatıldığı ve **kurban uygulamanın üstüne konumlandırıldığı** bir saldırıdır. Kurban uygulamayı görünür şekilde örttüğünde, kötü amaçlı uygulamanın kullanıcı arayüzü kullanıcıyı etkileşimde bulunmaya kandıracak şekilde tasarlanır; aynı anda etkileşimi kurban uygulamaya iletir.\
Sonuç olarak, kullanıcı aslında kurban uygulamada işlem yaptığını bilmeden **körleştirilmiş** olur.

Detaylı bilgi için:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

`launchMode`'u **`singleTask`** olarak ayarlanmış ve herhangi bir `taskAffinity` tanımlanmamış bir **activity**, task Hijacking'e karşı savunmasızdır. Bu, kötü niyetli bir **application**'ın yüklendiğinde ve gerçek uygulamadan önce başlatıldığında **gerçek uygulamanın task'ını hijack edebileceği** anlamına gelir (böylece kullanıcı gerçek uygulamayı kullanıyormuş gibi düşünerek **malicious application** ile etkileşimde bulunur).

Daha fazla bilgi için:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Insecure data storage

**Internal Storage**

Android'de **internal** storage'da **kayıtlı** dosyalar, onları oluşturan **app** tarafından kullanılmak üzere **tasarlanmıştır**. Bu güvenlik önlemi Android işletim sistemi tarafından uygulanır ve çoğu uygulamanın güvenlik ihtiyaçları için genellikle yeterlidir. Ancak geliştiriciler bazen dosyaların farklı uygulamalar arasında **paylaşılmasına izin vermek** için `MODE_WORLD_READABLE` ve `MODE_WORLD_WRITABLE` gibi modları kullanır. Bu modlar, bu dosyalara diğer uygulamaların, potansiyel olarak kötü niyetli olanlar da dahil olmak üzere, erişimini **kısıtlamaz**.

1. **Static Analysis:**
- `MODE_WORLD_READABLE` ve `MODE_WORLD_WRITABLE` kullanımının **dikkatle incelendiğinden emin olun**. Bu modlar dosyaları **istenmeyen veya yetkisiz erişime** açabilir.
2. **Dynamic Analysis:**
- Uygulama tarafından oluşturulan dosyalara atanan **permissions**'ları doğrulayın. Özellikle herhangi bir dosyanın **worldwide readable veya writable** olarak ayarlanıp ayarlanmadığını **kontrol edin**. Bu, cihazdaki **herhangi bir uygulamanın**, kaynağı veya amacı ne olursa olsun, bu dosyaları **okuyup değiştirmesine** izin vereceği için ciddi bir güvenlik riski oluşturabilir.

**External Storage**

SD Kart gibi **external storage** üzerindeki dosyalarla çalışırken bazı önlemler alınmalıdır:

1. **Accessibility**:
- External storage'daki dosyalar **genel olarak readable ve writable**'dır. Bu, herhangi bir uygulamanın veya kullanıcının bu dosyalara erişebileceği anlamına gelir.
2. **Security Concerns**:
- Kolay erişim nedeniyle **hassas bilgileri external storage'da saklamamak** önerilir.
- External storage çıkarılabilir veya herhangi bir uygulama tarafından erişilebilir olduğundan daha az güvenlidir.
3. **Handling Data from External Storage**:
- External storage'dan alınan veriler üzerinde her zaman **input validation** yapın. Bunun önemi, verinin güvenilmeyen bir kaynaktan gelmesi gerçeğinden kaynaklanır.
- External storage'da bulunan executable veya class dosyalarını dynamic olarak yüklemek şiddetle tavsiye edilmez.
- Uygulamanız external storage'dan executable dosyalar almak zorundaysa, bu dosyaların dynamic olarak yüklenmeden önce **signed ve cryptographically verified** olduğundan emin olun. Bu adım uygulamanızın güvenlik bütünlüğü için hayati önemdedir.

External storage şu yollar altında **erişilebilir**: /storage/emulated/0 , /sdcard , /mnt/sdcard

> [!TIP]
> Android 4.4 (**API 17**) ile başlayan sürümlerde, SD kartın bir dizin yapısı vardır ve bu yapı **bir uygulamanın yalnızca o uygulamaya özel dizine erişimini sınırlar**. Bu, kötü amaçlı uygulamaların başka bir uygulamanın dosyalarına okuma veya yazma erişimi kazanmasını engeller.

**Sensitive data stored in clear-text**

- **Shared preferences**: Android her uygulamanın `/data/data/<packagename>/shared_prefs/` yolunda xml dosyalarını kolayca kaydetmesine izin verir ve bazen bu klasörde hassas bilgiler clear-text olarak bulunabilir.
- **Databases**: Android her uygulamanın `/data/data/<packagename>/databases/` yolunda sqlite veritabanlarını kolayca kaydetmesine izin verir ve bazen bu klasörde hassas bilgiler clear-text olarak bulunabilir.

### Broken TLS

**Accept All Certificates**

Bazı nedenlerden dolayı geliştiriciler bazen hostname eşleşmese bile tüm sertifikaları kabul ederler; örneğin aşağıdaki gibi kod satırlarıyla:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Bunu test etmenin iyi bir yolu, cihaz içinde Burp CA'yı yetkilendirmeden Burp gibi bir proxy kullanarak trafiği yakalamaya çalışmaktır. Ayrıca, Burp ile farklı bir hostname için bir sertifika oluşturup kullanabilirsiniz.

### Bozuk Kriptografi

**Zayıf Anahtar Yönetim Süreçleri**

Bazı geliştiriciler hassas verileri yerel depolamada kaydeder ve kod içinde hardcoded/öngörülebilir bir anahtarla şifreler. Bu yapılmamalıdır çünkü bazı reversing işlemleri saldırganların gizli bilgileri çıkarmasına olanak verebilir.

**Güvensiz ve/veya Kullanımdan Kalkmış Algoritmaların Kullanımı**

Geliştiriciler yetkilendirme **kontrollerini**, veri **depolamak** veya **göndermek** için **kullanımdan kalkmış algoritmaları** kullanmamalıdır. Bu algoritmalardan bazıları: RC4, MD4, MD5, SHA1... Örneğin parolaları depolamak için **hash'ler** kullanılıyorsa, salt ile birlikte brute-force'a dayanıklı hash'ler kullanılmalıdır.

### Diğer kontroller

- APK'yı **obfuscate etmek** saldırganların reverse engineer işini zorlaştırmak için önerilir.
- Uygulama hassassa (ör. bankacılık uygulamaları), cihazın **root'lu** olup olmadığını kontrol etmek için kendi kontrollerini yapmalı ve buna göre hareket etmelidir.
- Uygulama hassassa (ör. bankacılık uygulamaları), bir **emulator** kullanılıp kullanılmadığını kontrol etmelidir.
- Uygulama hassassa (ör. bankacılık uygulamaları), çalıştırmadan önce **kendi bütünlüğünü** kontrol etmeli ve değiştirilip değiştirilmediğini doğrulamalıdır.
- Hangi compiler/packer/obfuscator kullanılarak APK'nın oluşturulduğunu kontrol etmek için [**APKiD**](https://github.com/rednaga/APKiD) kullanın

### React Native Application

React uygulamalarının javascript koduna kolayca nasıl erişileceğini öğrenmek için aşağıdaki sayfayı okuyun:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Xamarin uygulamalarının C# koduna kolayca nasıl erişileceğini öğrenmek için aşağıdaki sayfayı okuyun:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

Bu [**blog postuna**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) göre superpacked, bir uygulamanın içeriğini tek bir dosyaya sıkıştıran bir Meta algoritmadır. Blog, bu tür uygulamaları açan bir uygulama oluşturma olasılığından bahseder... ve daha hızlı bir yöntem olarak **uygulamayı çalıştırıp dosya sisteminden açılmış dosyaları toplama** yolunu anlatır.

### Automated Static Code Analysis

[**mariana-trench**](https://github.com/facebook/mariana-trench) aracı, uygulamanın **kodunu tarayarak** **vulnerabilities** bulabilir. Bu araç, aralarında **bilinen kaynakların** (kullanıcı tarafından kontrol edilen **input**'un bulunduğu **yerler**i araca bildiren), **sinks** (kötü amaçlı kullanıcı girdisinin zarar verebileceği **tehlikeli** **yerler**) ve **kuralların** bulunduğu bir dizi tanıma sahiptir. Bu kurallar, bir zafiyeti gösteren **sources-sinks** kombinasyonlarını belirtir.

Bu bilgiyle, **mariana-trench kodu inceleyip olası zafiyetleri bulacaktır**.

### Secrets leaked

Bir uygulama içinde keşfedebileceğiniz secrets (API anahtarları, parolalar, gizli url'ler, subdomain'ler...) bulunabilir. Bunun için [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks) gibi bir araç kullanabilirsiniz

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Diğer ilginç fonksiyonlar

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)
- In-memory native code execution via JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dinamik Analiz

> Öncelikle, uygulamayı ve tüm ortamı (özellikle Burp CA sertifikası, Drozer ve Frida) kurabileceğiniz bir ortama ihtiyacınız var. Bu nedenle root'lu bir cihaz (emüle edilmiş olsun veya olmasın) şiddetle tavsiye edilir.

### Çevrimiçi Dinamik Analiz

Şurada **ücretsiz bir hesap** oluşturabilirsiniz: [https://appetize.io/](https://appetize.io). Bu platform APK yüklemenize ve çalıştırmanıza izin verir, bu yüzden bir apk'nın nasıl davrandığını görmek için faydalıdır.

Web üzerinden uygulamanızın loglarını **görebilir** ve **adb** ile bağlanabilirsiniz.

![](<../../images/image (831).png>)

ADB bağlantısı sayesinde emülatörlerde **Drozer** ve **Frida** kullanabilirsiniz.

### Yerel Dinamik Analiz

#### Emulator kullanarak

- [**Android Studio**](https://developer.android.com/studio) (Burada **x86** ve **arm** cihazlar oluşturabilirsiniz; ve [**bu** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**kaynağa göre** en son x86 sürümleri **ARM kütüphanelerini** yavaş bir arm emulator'e gerek kalmadan desteklemektedir).
- Kurulumunu bu sayfada öğrenin:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Ücretsiz sürüm:** Personal Edition, bir hesap oluşturmanız gerekir. _Hataları önlemek için VirtualBox ile birlikte OLAN_ sürümü **download** etmeniz önerilir._)
- [**Nox**](https://es.bignox.com) (Ücretsiz, ancak Frida veya Drozer'ı desteklemiyor).

> [!TIP]
> Yeni bir emulator oluştururken hangi platform olursa olsun ekran ne kadar büyükse emulator o kadar yavaş çalışır. Mümkünse küçük ekranları seçin.

Google hizmetlerini (ör. AppStore) Genymotion'a **install etmek** için aşağıdaki görüntüde kırmızı ile işaretlenmiş butona tıklamanız gerekir:

![](<../../images/image (277).png>)

Ayrıca, **Genymotion içindeki Android VM konfigürasyonunda** **Bridge Network mode** seçebilirsiniz (bu, Android VM'ine başka bir VM'den araçlarla bağlanacaksanız faydalı olacaktır).

#### Fiziksel bir cihaz kullanma

Debugging seçeneklerini aktifleştirmeniz gerekir ve mümkünse cihazı **root** yapmanız iyi olur:

1. **Settings**.
2. (Android 8.0'dan itibaren) **System**'i seçin.
3. **About phone**'u seçin.
4. **Build number** üzerine 7 kez basın.
5. Geri dönün ve **Developer options**'ı bulacaksınız.

> Uygulamayı yükledikten sonra yapmanız gereken ilk şey onu çalıştırıp ne yaptığını, nasıl çalıştığını incelemek ve rahat olmaktır.\
> Bu ilk dinamik analiz için MobSF dynamic analysis + pidcat kullanmanızı öneririm; böylece uygulamanın nasıl çalıştığını öğrenirken MobSF bir sürü ilginç veriyi yakalar ve sonradan inceleyebilirsiniz.

Magisk/Zygisk hızlı notlar (Pixel cihazlarda önerilir)
- boot.img'i Magisk uygulaması ile patch'leyin ve systemless root almak için fastboot ile flashlayın
- Zygisk + DenyList'i etkinleştirin; root gizleme için gerektiğinde LSPosed/Shamiko'yu düşünün
- OTA güncellemelerinden kurtulmak için orijinal boot.img'i saklayın; her OTA sonrası yeniden patch'leyin
- Ekran yansıtma için host üzerinde scrcpy kullanın

### İstenmeyen Veri Sızıntısı

**Logging**

Geliştiriciler, **debugging bilgilerini** herkese açık şekilde ifşa etmekten kaçınmalıdır; bu, hassas veri sızıntılarına yol açabilir. Uygulama loglarını izlemek ve hassas bilgileri tespit etmek için [**pidcat**](https://github.com/JakeWharton/pidcat) ve `adb logcat` araçları önerilir. **Pidcat**, kullanım kolaylığı ve okunabilirliği nedeniyle tercih edilir.

> [!WARNING]
> Android 4.0'dan **daha yeni sürümlerde**, **uygulamalar sadece kendi loglarına erişebilir**. Yani uygulamalar diğer uygulamaların loglarına erişemez.\
> Buna rağmen, hassas bilgileri **loglamamak** hâlâ önerilir.

**Copy/Paste Buffer Caching**

Android'in **clipboard-based** framework'ü uygulamalarda kopyala-yapıştır işlevselliği sağlar, ancak **diğer uygulamaların** panoya erişebilmesi nedeniyle hassas verilerin açığa çıkma riski vardır. Kredi kartı bilgileri gibi hassas bölümler için kopyala-yapıştır fonksiyonlarını devre dışı bırakmak önemlidir.

**Crash Logs**

Bir uygulama **crash** yaparsa ve logları kaydederse, bu loglar özellikle uygulama reverse-engineer edilemiyorsa saldırganlara yardımcı olabilir. Bu riski azaltmak için çökme anında loglamamaya çalışın; eğer logların ağ üzerinden gönderilmesi gerekiyorsa güvenlik için SSL kanalı kullanın.

Pentester olarak, **bu loglara bakmayı deneyin**.

**Analytics Data Sent To 3rd Parties**

Uygulamalar sıklıkla Google Adsense gibi servisleri entegre eder; hatalı uygulama nedeniyle hassas veriler üçüncü taraflara **sızabilir**. Olası veri sızıntılarını tespit etmek için uygulamanın trafiğini intercept edip üçüncü taraflara hassas bilgi gönderilip gönderilmediğini kontrol etmek iyi bir yöntemdir.

### SQLite DBs

Çoğu uygulama bilgi kaydetmek için **internal SQLite veritabanları** kullanır. Pentest sırasında oluşturulan **veritabanlarına**, **tabloların** ve **sütunların** isimlerine ve kaydedilen tüm **verilere** bakın; hassas bilgiler bulabilirsiniz (bu bir zafiyettir).\
Veritabanları genellikle `/data/data/the.package.name/databases` altında bulunur; örneğin `/data/data/com.mwr.example.sieve/databases`

Eğer veritabanı gizli bilgileri şifreliyorsa ve şifre uygulama içinde bulunabiliyorsa bu hâlâ bir zafiyettir.

Tabloları `.tables` ile listeleyin ve tabloların sütunlarını `.schema <table_name>` ile inceleyin

### Drozer (Exploit Activities, Content Providers and Services)

Drozer Docs'dan alıntı ([Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf)): **Drozer**, kendinizi bir Android uygulaması olarak varsaymanıza ve diğer uygulamalarla etkileşime girmenize olanak tanır. Kurulu bir uygulamanın yapabileceği **her şeyi** yapabilir; örneğin Android’in Inter-Process Communication (IPC) mekanizmasını kullanmak ve alt işletim sistemi ile etkileşimde bulunmak. .\
Drozer, dışa açılmış activities, exported services ve Content Provider'ları **exploit etmek** için kullanışlı bir araçtır; bunu sonraki bölümlerde öğreneceksiniz.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Ayrıca unutmayın ki bir activity'nin kodu **`onCreate`** metodunda başlar.

**Authorisation bypass**

Bir Activity exported olduğunda, ekranını dış bir uygulamadan çağırabilirsiniz. Bu nedenle, **hassas bilgi** içeren bir activity **exported** ise, ona erişmek için **authentication** mekanizmalarını **bypass** edebilirsiniz.

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

Ayrıca adb'den exported bir activity'i başlatabilirsiniz:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [bu](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> Bir authorisation bypass her zaman bir güvenlik açığı değildir; bunun nasıl çalıştığına ve hangi bilgilerin ifşa edildiğine bağlıdır.

**Hassas bilgi sızıntısı**

Activity'ler ayrıca sonuç döndürebilir. Eğer exported ve korunmasız bir activity bulup **`setResult`** metodunu çağırıp **hassas bilgi döndürdüğünü** tespit ederseniz, bu bir hassas bilgi sızıntısıdır.

#### Tapjacking

Eğer Tapjacking önlenmemişse, exported activity'yi suistimal ederek **kullanıcının beklenmeyen eylemler yapmasını** sağlayabilirsiniz. Tapjacking'in ne olduğu hakkında daha fazla bilgi için [**Tapjacking'in ne olduğunu öğrenmek için bağlantıya bakın**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Content Provider nedir hatırlamak istiyorsanız bunu okuyun.**](android-applications-basics.md#content-provider)\
Content providers temelde **veri paylaşmak** için kullanılır. Bir uygulamanın kullanılabilir content provider'ları varsa, bunlardan **hassas veriler** çekebilmeniz mümkün olabilir. Ayrıca potansiyel **SQL injections** ve **Path Traversals**'ı test etmek ilginçtir çünkü bunlar zayıf olabilir.

[**Drozer ile Content Providers'ı nasıl istismar edeceğinizi öğrenin.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Service nedir hatırlamak istiyorsanız bunu okuyun.**](android-applications-basics.md#services)\
Bir Service'in işlemlerinin `onStartCommand` metodunda başladığını unutmayın.

Bir service temelde **veri alabilen**, **işleyebilen** ve (veya) bir yanıt **döndürebilen** bir şeydir. Bu yüzden, bir uygulama bazı servisleri export ediyorsa ne yaptığını anlamak için **kodunu** kontrol etmeli ve gizli bilgileri çıkarmak, kimlik doğrulama önlemlerini atlamak vb. için **dinamik** olarak **test** etmelisiniz.\
[**Drozer ile Services'i nasıl istismar edeceğinizi öğrenin.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Broadcast Receiver nedir hatırlamak istiyorsanız bunu okuyun.**](android-applications-basics.md#broadcast-receivers)\
Bir Broadcast Receiver'ın işlemlerinin `onReceive` metodunda başladığını unutmayın.

Bir broadcast receiver belirli bir mesaj türünü bekler. Alıcının mesajı nasıl ele aldığına bağlı olarak zayıf olabilir.\
[**Drozer ile Broadcast Receiver'ları nasıl istismar edeceğinizi öğrenin.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Deep links'i elle arayabilirsiniz; MobSF gibi araçlar veya [bu](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py) gibi script'ler kullanabilirsiniz. Declare edilmiş bir **scheme**'i **adb** veya bir **tarayıcı** ile açabilirsiniz:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Paket adını **belirtmeyebileceğinizi** unutmayın; mobil, o bağlantıyı açması gereken uygulamayı otomatik olarak çağıracaktır._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Çalıştırılan kod**

Uygulamada **çalıştırılacak kodu** bulmak için, deeplink tarafından çağrılan activity'ye gidin ve **`onNewIntent`** fonksiyonunu arayın.

![](<../../images/image (436) (1) (1) (1).png>)

**Hassas bilgi**

Her bulduğunuz deep link için, **URL parametreleri aracılığıyla hassas veri (ör. şifreler) almadığından** emin olun, çünkü başka herhangi bir uygulama **deep link'i taklit ederek bu veriyi çalabilir!**

**Path içindeki parametreler**

URL'nin path'inde bir parametre kullanılıp kullanılmadığını da **kontrol etmelisiniz**; örneğin: `https://api.example.com/v1/users/{username}` , bu durumda `example://app/users?username=../../unwanted-endpoint%3fparam=value` gibi bir erişimle path traversal zorlayabilirsiniz.\
Uygulama içinde doğru endpoint'leri bulursanız, **Open Redirect** (path'in bir parçası domain adı olarak kullanılıyorsa), **account takeover** (kullanıcı detaylarını CSRF token olmadan değiştirebiliyorsanız ve zayıf endpoint doğru HTTP metodunu kullanıyorsa) ve diğer zafiyetlere yol açabilirsiniz. Daha fazla bilgi için [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**Daha fazla örnek**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Taşıma Katmanı İncelemesi ve Doğrulama Hataları

- **Sertifikalar Android uygulamaları tarafından her zaman doğru şekilde denetlenmez.** Bu uygulamaların uyarıları görmezden gelip self-signed sertifikaları kabul etmesi veya bazı durumlarda HTTP bağlantılarına dönmesi yaygındır.
- **SSL/TLS el sıkışması sırasında yapılan müzakereler bazen zayıf olabilir**, güvensiz cipher suites kullanılıyor olabilir. Bu zafiyet bağlantıyı man-in-the-middle (MITM) saldırılarına karşı savunmasız hale getirir ve saldırganların veriyi çözmesine olanak tanır.
- **Özel bilgilerin sızması** riski vardır; uygulamalar kimlik doğrulamayı güvenli kanallar aracılığıyla yapıp diğer işlemler için güvensiz kanalları kullanırsa. Bu yaklaşım, session cookie'leri veya kullanıcı detayları gibi hassas verileri kötü niyetli tarafların yakalamasından koruyamaz.

#### Sertifika Doğrulama

Burada **certificate verification** üzerine odaklanacağız. Sunucunun sertifikasının bütünlüğü güvenliği artırmak için doğrulanmalıdır. Bu önemlidir çünkü güvensiz TLS yapılandırmaları ve hassas verilerin şifrelenmemiş kanallar üzerinden iletilmesi ciddi riskler oluşturabilir. Sunucu sertifikalarını doğrulama ve zafiyetleri ele alma adımları için [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) kapsamlı rehberlik sağlar.

#### SSL Pinning

SSL Pinning, uygulamanın sunucu sertifikasını uygulama içinde saklanan bilinen bir kopyaya karşı doğrulamasıdır. Bu yöntem MITM saldırılarını önlemek için esastır. Hassas bilgi işleyen uygulamalar için SSL Pinning uygulanması şiddetle tavsiye edilir.

#### Trafik İncelemesi

HTTP trafiğini incelemek için, proxy aracının sertifikasını **yüklemeniz** gerekir (ör., Burp). Bu sertifikayı yüklemeden, şifreli trafik proxy üzerinden görünmeyebilir. Özel bir CA sertifikasının nasıl yükleneceğine dair rehber için [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

API Level 24 ve üzerini hedefleyen uygulamalar, proxy'nin CA sertifikasını kabul etmek için Network Security Config'te değişiklik yapılmasını gerektirir. Bu adım şifreli trafiği incelemek için kritiktir. Network Security Config'i nasıl değiştireceğinize dair talimatlar için [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

Eğer **Flutter** kullanılıyorsa, [**this page**](flutter.md)'deki talimatları takip etmeniz gerekir. Çünkü sertifikayı sadece store'a eklemek işe yaramaz; Flutter'ın kendi geçerli CA listesi vardır.

#### SSL/TLS pinning'in statik tespiti

Runtime bypass denemelerine başlamadan önce, pinning'in APK'da nerede uygulandığını hızlıca haritalayın. Statik keşif, hook/patch planlamanıza ve doğru kod yollarına odaklanmanıza yardımcı olur.

Tool: SSLPinDetect
- Açık kaynaklı bir statik analiz aracı; APK'yı Smali'ye decompile eder (apktool aracılığıyla) ve SSL/TLS pinning uygulamalarına ait seçilmiş regex desenlerini tarar.
- Her eşleşme için kesin dosya yolu, satır numarası ve bir kod snippet'i raporlar.
- Yaygın framework'leri ve özel kod yollarını kapsar: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

Kurulum
- Önkoşullar: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Kullanım
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Örnek pattern kuralları (JSON)
Signatures kullanarak veya genişleterek proprietary/custom pinning stillerini tespit edin. Kendi JSON'unuzu yükleyerek geniş ölçekte scan yapabilirsiniz.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notlar ve ipuçları
- Büyük uygulamalarda hızlı tarama için multi-threading ve memory-mapped I/O kullanın; önceden derlenmiş regex, yükü/yanlış pozitifleri azaltır.
- Desen koleksiyonu: https://github.com/aancw/smali-sslpin-patterns
- Bir sonraki önceliklendirme için tipik tespit hedefleri:
- OkHttp: CertificatePinner kullanımı, setCertificatePinner, okhttp3/okhttp paket referansları
- Özel TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted override'ları
- Özel SSL context'leri: SSLContext.getInstance + SSLContext.init ile custom manager'lar
- res/xml içindeki deklaratif pinler ve network security config ve manifest referansları
- Eşleşen konumları dinamik testten önce Frida hook'ları, statik yamalar veya konfigürasyon incelemeleri planlamak için kullanın.



#### SSL Pinning'i Atlatma

SSL Pinning uygulandığında, HTTPS trafiğini incelemek için bunu atlatmak gerekir. Bu amaçla çeşitli yöntemler mevcuttur:

- Otomatik olarak **apk**'yi **değiştirip** SSLPinning'i **atlatmak** için [**apk-mitm**](https://github.com/shroudedcode/apk-mitm) kullanın. Bu seçeneğin en büyük avantajı SSLPinning'i atlatmak için root gerekmemesi, ancak uygulamayı silip yeni sürümü yeniden yüklemeniz gerekeceği ve her zaman çalışmayacağıdır.
- Bu korumayı atlatmak için **Frida** (aşağıda anlatılmıştır) kullanabilirsiniz. Burp+Frida+Genymotion kullanımı ile ilgili kılavuz: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- [**objection**](frida-tutorial/objection-tutorial.md) kullanarak **SSL Pinning'i otomatik olarak atlamayı** da deneyebilirsiniz:**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- **MobSF dynamic analysis** kullanarak **SSL Pinning'i otomatik olarak atlamayı** da deneyebilirsiniz (aşağıda açıklanmıştır)
- Hâlâ yakalayamadığınız trafik olduğunu düşünüyorsanız trafiği burp'a iptables kullanarak **yönlendirmeyi** deneyebilirsiniz. Bu blogu okuyun: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Yaygın Web Zafiyetlerini Arama

Uygulama içinde yaygın web zafiyetlerini aramak da önemlidir. Bu zafiyetlerin tespiti ve giderilmesine dair ayrıntılar bu özetin kapsamı dışında olup başka kaynaklarda genişçe ele alınmıştır.

### Frida

[Frida](https://www.frida.re) geliştiriciler, reverse-engineer'lar ve güvenlik araştırmacıları için dinamik bir enstrümantasyon araç takımıdır.\
**Çalışan uygulamaya erişip çalışma zamanında metotları hook'layarak davranışı değiştirebilir, değerleri değiştirebilir, değerleri çıkarabilir, farklı kod çalıştırabilirsiniz...**\
Android uygulamalarına pentest yapmak istiyorsanız Frida'yı nasıl kullanacağınızı bilmeniz gerekir.

- Frida kullanmayı öğren: [**Frida tutorial**](frida-tutorial/index.html)
- Frida ile işlemler için bazı "GUI": [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection, Frida kullanımını otomatikleştirmek için harikadır: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Bazı Awesome Frida script'lerini burada bulabilirsiniz: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- anti-debugging / anti-frida mekanizmalarını atlatmayı deneyin; Frida'yı şu adreste belirtildiği gibi yükleyin: [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning atlatma iş akışı

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Bellek Dökümü - Fridump**

Uygulamanın şifreler veya mnemonikler gibi saklamaması gereken hassas bilgileri bellekte tutup tutmadığını kontrol edin.

Kullanarak [**Fridump3**](https://github.com/rootbsd/fridump3) uygulamanın belleğini şu komutla dökebilirsiniz:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Bu, belleği ./dump klasörüne dökecek ve orada şu gibi bir komutla grep yapabilirsiniz:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Sensitive data in Keystore**

Android'de Keystore hassas verileri depolamak için en iyi yerdir; ancak yeterli ayrıcalıklara sahip olunduğunda **ona erişmek hâlâ mümkündür**. Uygulamalar genellikle burada **açık metin halinde hassas veriler** depolama eğiliminde olduğundan, pentests bunu kontrol etmelidir; çünkü root user veya cihaza fiziksel erişimi olan kişiler bu verileri çalabilir.

Bir uygulama Keystore'a veri depolasa bile, verilerin şifrelenmiş olması gerekir.

Keystore içindeki verilere erişmek için bu Frida script'ini kullanabilirsiniz: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Parmak İzi/Biyometrik Atlama**

Aşağıdaki Frida script'i ile, Android uygulamalarının belirli hassas alanları **korumak için** uyguluyor olabileceği **parmak izi doğrulamasını atlatmak** mümkün olabilir:
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Arka Plan Görüntüleri**

Bir uygulamayı arka plana aldığınızda, Android uygulamanın bir **anlık görüntüsünü** saklar; böylece uygulama ön plana geri getirildiğinde uygulama yüklenmeden önce bu görüntü yüklenmeye başlar ve uygulama daha hızlı yüklenmiş gibi görünür.

Ancak bu anlık görüntü **gizli bilgiler** içeriyorsa, anlık görüntüye erişimi olan biri bu bilgileri **çalabilir** (erişmek için root gerektiğini unutmayın).

Anlık görüntüler genellikle şu dizinde saklanır: **`/data/system_ce/0/snapshots`**

Android, layout parametresi olarak FLAG_SECURE ayarlanarak **ekran görüntüsü alınmasını engelleme** yolu sağlar. Bu flag kullanıldığında, pencere içeriği güvenli olarak değerlendirilir; böylece içeriğin ekran görüntülerinde görünmesi veya güvenli olmayan ekranlarda görüntülenmesi engellenir.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Bu araç, dinamik analiz sırasında farklı araçları yönetmenize yardımcı olabilir: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Geliştiriciler genellikle activities, services ve broadcast receivers gibi proxy bileşenleri oluşturur; bu bileşenler bu Intents'leri işler ve `startActivity(...)` veya `sendBroadcast(...)` gibi metodlara iletir; bu durum riskli olabilir.

Tehlike, bu Intents'leri yanlış yönlendirerek saldırganların non-exported uygulama bileşenlerini tetiklemesine veya hassas content providers'a erişmesine izin verilmesidir. Örneğin `WebView` bileşeninin URL'leri `Intent.parseUri(...)` ile Intent nesnelerine dönüştürmesi ve sonra bunları yürütmesi, potansiyel olarak kötü amaçlı Intent enjeksiyonlarına yol açabilir.

### Essential Takeaways

- **Intent Injection** web'in Open Redirect sorununa benzer.
- Sömürüler, ekstra olarak `Intent` objeleri geçirilmesini içerir; bunlar tehlikeli işlemleri çalıştıracak şekilde yönlendirilebilir.
- Bu, non-exported bileşenleri ve content providers'ları saldırganlara maruz bırakabilir.
- `WebView`'in URL'leri `Intent`'e dönüştürmesi istenmeyen işlemleri kolaylaştırabilir.

### Android Client Side Injections and others

Muhtemelen bu tür zafiyetleri Web'den biliyorsunuzdur. Bir Android uygulamasında bu zafiyetlere özellikle dikkat etmelisiniz:

- **SQL Injection:** Dinamik sorgular veya Content-Providers ile çalışırken parametreli sorgular (parameterized queries) kullandığınızdan emin olun.
- **JavaScript Injection (XSS):** Herhangi bir WebView için JavaScript ve Plugin desteğinin devre dışı olduğundan emin olun (varsayılan olarak devre dışıdır). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebView'lerin dosya sistemine erişimi devre dışı bırakılmalıdır (varsayılan olarak açık) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: Birçok durumda Android uygulaması oturumu kapattığında cookie iptal edilmez veya hatta diske kaydedilmiş olabilir.
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Static analysis**

![](<../../images/image (866).png>)

**Uygulamanın zafiyet değerlendirmesi** güzel bir web tabanlı frontend kullanılarak yapılır. Dinamik analiz de gerçekleştirebilirsiniz (ancak ortamı hazırlamanız gerekir).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
MobSF'in **Android**(apk)**, IOS**(ipa) ve **Windows**(apx) uygulamalarını analiz edebildiğini unutmayın (_Windows uygulamaları, Windows host'a kurulu bir MobSF'den analiz edilmelidir_).\
Ayrıca, bir **Android** veya **IOS** uygulamasının kaynak koduyla bir **ZIP** dosyası oluşturursanız (uygulamanın kök klasörüne gidin, her şeyi seçin ve bir ZIP dosyası oluşturun), MobSF bunu da analiz edebilecektir.

MobSF ayrıca analizleri **diff/Compare** etmeye ve **VirusTotal** ile entegrasyon sağlamaya izin verir (API anahtarınızı _MobSF/settings.py_ içine ayarlamanız ve etkinleştirmeniz gerekir: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). `VT_UPLOAD` değerini `False` yaparsanız, dosya yerine **hash** **upload** edilecektir.

### MobSF ile Destekli Dinamik Analiz

**MobSF**, **Android** için **dynamic analysis** sırasında da çok yardımcı olabilir; ancak bu durumda host'unuza MobSF ve **genymotion** kurmanız gerekir (VM veya Docker çalışmaz). _Not: Önce **genymotion** içinde bir VM **başlatmanız**, sonra **MobSF**'yi başlatmanız gerekir._\
**MobSF dynamic analyser** şunları yapabilir:

- **Uygulama verilerini dump etmek** (URL'ler, loglar, clipboard, sizin aldığınız ekran görüntüleri, "**Exported Activity Tester**" ile alınan ekran görüntüleri, e-postalar, SQLite veritabanları, XML dosyaları ve oluşturulan diğer dosyalar). Tüm bunlar ekran görüntüleri hariç otomatik yapılır; ekran görüntüsü almak için istediğiniz anda ekran görüntüsü butonuna basmanız veya tüm exported activity'lerin ekran görüntülerini almak için "**Exported Activity Tester**"e basmanız gerekir.
- **HTTPS trafiğini** yakalamak
- **Frida** kullanarak **runtime** **bilgi** almak

Android sürümlerinde **> 5**, Frida'yı **otomatik** başlatır ve trafiği yakalamak için global **proxy** ayarlarını yapar. Sadece test edilen uygulamanın trafiğini yakalar.

**Frida**

Varsayılan olarak, SSL pinning, root detection ve debugger detection'ı **bypass** etmek ve ilginç API'leri **monitor** etmek için bazı Frida script'lerini de kullanır.\
MobSF ayrıca **exported activity**leri çağırabilir, bunların **screenshot**larını alıp rapor için **kaydedebilir**.

Dinamik testi **başlatmak** için yeşil butona basın: "**Start Instrumentation**". Frida script'lerinin ürettiği logları görmek için "**Frida Live Logs**"e, hook'lanmış metodlara yapılan tüm çağrıları, geçirilen argümanları ve dönen değerleri görmek için "**Live API Monitor**"e basın (bu, "Start Instrumentation"a bastıktan sonra görünecektir).\
Ayrıca kendi **Frida scripts**lerinizi yükleyebilirsiniz (Frida script'lerinizin sonuçlarını MobSF'e göndermek için `send()` fonksiyonunu kullanın). Hazır **birkaç pre-written script** de yükleyebilirsiniz (başka script eklemek isterseniz `MobSF/DynamicAnalyzer/tools/frida_scripts/others/` içine ekleyin), sadece script'leri **seçin**, "**Load**"a basın ve "**Start Instrumentation**"ı çalıştırın (o script'lerin loglarını "**Frida Live Logs**" içinde görebileceksiniz).

![](<../../images/image (419).png>)

Ayrıca bazı yardımcı Frida fonksiyonları vardır:

- **Enumerate Loaded Classes**: Yüklü tüm sınıfları yazdırır
- **Capture Strings**: Uygulamayı kullanırken yakalanan tüm stringleri yazdırır (çok gürültülü)
- **Capture String Comparisons**: Çok faydalı olabilir. Karşılaştırılan 2 string'i ve sonucun True mu False mu olduğunu **gösterir**.
- **Enumerate Class Methods**: Sınıf adını (ör. "java.io.File") girin, sınıfın tüm methodlarını yazdırır.
- **Search Class Pattern**: Pattern ile sınıf araması yapar
- **Trace Class Methods**: Bir **sınıfın tamamını trace** eder (sınıfın tüm methodlarının giriş ve çıkışlarını görür). Varsayılan olarak MobSF, birkaç ilginç Android API metodunu trace eder.

Kullanmak istediğiniz yardımcı modülü seçtikten sonra "**Start Intrumentation**"a basmanız gerekir ve tüm çıktıları "**Frida Live Logs**" içinde göreceksiniz.

**Shell**

MobSF, dynamic analysis sayfasının altında bazı **adb** komutları, **MobSF** komutları ve yaygın **shell** **komutları** içeren bir shell de sunar. Bazı ilginç komutlar:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP araçları**

When http traffic is capture you can see an ugly view of the captured traffic on "**HTTP(S) Traffic**" bottom or a nicer view in "**Start HTTPTools**" green bottom. From the second option, you can **send** the **captured requests** to **proxies** like Burp or Owasp ZAP.\
To do so, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> press "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

MobSF ile dinamik analiz bittikten sonra "**Start Web API Fuzzer**" düğmesine basarak **fuzz http requests** yapabilir ve zafiyet arayabilirsiniz.

> [!TIP]
> MobSF ile dinamik analiz gerçekleştirdikten sonra proxy ayarları yanlış yapılandırılmış olabilir ve bunları GUI'den düzeltemeyebilirsiniz. Proxy ayarlarını şu komutla düzeltebilirsiniz:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Inspeckage ile Destekli Dinamik Analiz

You can get the tool from [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Bu araç bazı **Hooks** kullanarak **dinamik analiz** yaparken **uygulamada neler olduğunu** size bildirir.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

This is a **great tool to perform static analysis with a GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

This tool is designed to look for several **security related Android application vulnerabilities**, either in **source code** or **packaged APKs**. The tool is also **capable of creating a "Proof-of-Concept" deployable APK** and **ADB commands**, to exploit some of the found vulnerabilities (Exposed activities, intents, tapjacking...). As with Drozer, there is no need to root the test device.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Kolay referans için çıkarılmış tüm dosyaları gösterir
- APK dosyalarını otomatik olarak Java ve Smali formatına decompile eder
- AndroidManifest.xml'i yaygın zafiyetler ve davranışlar için analiz eder
- Yaygın zafiyetler ve davranışlar için statik kaynak kodu analizi
- Cihaz bilgileri
- ve daha fazlası
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER, Windows, MacOS X ve Linux'ta kullanılabilen bir command-line uygulamasıdır; _.apk_ dosyalarını zafiyetler açısından analiz eder. Bunu, APK dosyalarını açarak ve bu zafiyetleri tespit etmek için bir dizi kural uygulayarak yapar.

Tüm kurallar `rules.json` dosyasında toplanmıştır; her şirket veya test eden kişi ihtiyaçlarına göre kendi kurallarını oluşturabilir.

En son ikili dosyaları [download page](https://superanalyzer.rocks/download.html) adresinden indirin.
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn, mobil uygulamalarda [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) yapan geliştiricilere, bugbounty hunters ve ethical hackers için yardımcı olan bir **crossplatform** araçtır.

Kavram şu: mobil uygulama dosyanızı (.apk veya .ipa dosyası) StaCoAn uygulamasına sürükleyip bırakırsınız ve size görsel ve taşınabilir bir rapor oluşturur. Ayarları ve wordlists'i değiştirerek özelleştirilmiş bir deneyim elde edebilirsiniz.

İndir[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework, geliştiricilere veya hackers'a Android uygulamalarındaki potansiyel güvenlik açıklarını bulmada yardımcı olan bir Android zafiyet analiz sistemidir.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** Android bir uygulamanın potansiyel zararlı davranışlarını tespit etmek ve kullanıcıyı uyarmak amacıyla geliştirilmiş bir araçtır.

Tespit, uygulamanın Dalvik bytecode'unun **Smali** olarak temsil edilen halinin [`androguard`](https://github.com/androguard/androguard) kütüphanesi ile yapılan **static analysis** ile gerçekleştirilir.

Bu araç Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution gibi **common behavior of "bad" applications** arar.
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. Mobil uygulamaları OWASP mobile security tehditlerine karşı test etmeye yardımcı olmak için yaygın olarak kullanılan mobil uygulama tersine mühendislik ve analiz araçlarını bir araya getiren bir araçtır. Amacı, bu görevi mobil uygulama geliştiricileri ve güvenlik profesyonelleri için daha kolay ve kullanıcı dostu hale getirmektir.

It is able to:

- Extract Java and Smali code using different tools
- Analyze APKs using: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Extract private information from the APK using regexps.
- Analyze the Manifest.
- Analyze found domains using: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Malware tespiti için faydalı: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Note that depending the service and configuration you use to obfuscate the code. Secrets may or may not ended obfuscated.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. It is able to optimize bytecode as well as detect and remove unused instructions. ProGuard is free software and is distributed under the GNU General Public License, version 2.

ProGuard is distributed as part of the Android SDK and runs when building the application in release mode.

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Last time we checked, the Dexguard mode of operation was:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

You can upload an obfuscated APK to their platform.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

Bu, android uygulamalarındaki potansiyel güvenlik açıklarını tespit etmek ve android uygulama kodunu deobfuscate etmek için kullanılan bir LLM aracıdır. Google'ın Gemini public API'sini kullanır.

### [Simplify](https://github.com/CalebFenton/simplify)

It is a **generic android deobfuscator.** Simplify **virtually executes an app** to understand its behavior and then **tries to optimize the code** so it behaves identically but is easier for a human to understand. Each optimization type is simple and generic, so it doesn't matter what the specific type of obfuscation is used.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD gives you information about **how an APK was made**. It identifies many **compilers**, **packers**, **obfuscators**, and other weird stuff. It's [_PEiD_](https://www.aldeid.com/wiki/PEiD) for Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b is an Android security virtual machine based on ubuntu-mate includes the collection of latest framework, tutorials and labs from different security geeks and researchers for reverse engineering and malware analysis.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Harika bir kaynak listesi
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android hızlı kursu
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
