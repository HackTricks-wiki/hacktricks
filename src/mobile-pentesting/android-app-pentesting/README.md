# Pentesting d'applications Android

{{#include ../../banners/hacktricks-training.md}}

## Notions de base des applications Android

Il est fortement recommandé de commencer par lire cette page pour connaître **les parties les plus importantes liées à la sécurité Android et les composants les plus dangereux d'une application Android** :


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

C'est l'outil principal pour se connecter à un appareil Android (émulé ou physique).\
**ADB** permet de contrôler les appareils soit via **USB** soit via **Network** depuis un ordinateur. Cet utilitaire permet la **copie** de fichiers dans les deux sens, l'**installation** et la **désinstallation** d'apps, l'**exécution** de commandes shell, la **sauvegarde** de données, la **lecture** de logs, entre autres fonctions.

Take a look to the following list of [**ADB Commands**](adb-commands.md) to learn how to use adb.

## Smali

Parfois, il peut être utile de **modifier le code de l'application** pour accéder à des **informations cachées** (par exemple des mots de passe fortement obfusqués ou des flags). Dans ce cas, il peut être intéressant de décompiler l'APK, modifier le code puis le recompiler.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Cela peut être très utile comme **alternative pour plusieurs tests lors de l'analyse dynamique** qui vont être présentés. Donc, **gardez toujours à l'esprit cette possibilité**.

## Autres astuces intéressantes

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Extraire l'APK depuis l'appareil:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Fusionnez tous les splits et les apks de base avec [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Études de cas & vulnérabilités


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Analyse statique

Tout d'abord, pour analyser un APK vous devriez **regarder le code Java** en utilisant un décompilateur.\
Veuillez [**lire ici pour trouver des informations sur les différents décompilateurs disponibles**](apk-decompilers.md).

### Recherche d'informations intéressantes

En regardant simplement les **strings** de l'APK, vous pouvez rechercher des **mots de passe**, des **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), des **clés API**, du **chiffrement**, des **bluetooth UUIDs**, des **tokens** et tout ce qui est intéressant... cherchez même des **backdoors** d'exécution de code ou des backdoors d'authentification (identifiants admin hardcodés dans l'app).

**Firebase**

Portez une attention particulière aux **Firebase URLs** et vérifiez si elles sont mal configurées. [Plus d'informations sur ce qu'est Firebase et comment l'exploiter ici.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Compréhension de base de l'application - Manifest.xml, strings.xml

L'**examen des fichiers _Manifest.xml_ et _strings.xml_ d'une application peut révéler des vulnérabilités potentielles de sécurité**. Ces fichiers peuvent être consultés à l'aide de décompilateurs ou en renommant l'extension du fichier APK en .zip puis en le décompressant.

Les **vulnérabilités** identifiées à partir du **Manifest.xml** incluent :

- **Debuggable Applications** : Les applications définies comme debuggable (`debuggable="true"`) dans le fichier _Manifest.xml_ présentent un risque car elles permettent des connexions pouvant conduire à une exploitation. Pour comprendre comment exploiter des applications debuggables, consultez un tutoriel sur la recherche et l'exploitation d'applications debuggables sur un appareil.
- **Backup Settings** : L'attribut `android:allowBackup="false"` doit être explicitement défini pour les applications manipulant des informations sensibles afin d'empêcher des sauvegardes de données non autorisées via adb, en particulier lorsque le débogage USB est activé.
- **Network Security** : Les configurations de sécurité réseau personnalisées (`android:networkSecurityConfig="@xml/network_security_config"`) dans _res/xml/_ peuvent spécifier des détails de sécurité comme le pinning de certificats et les paramètres de trafic HTTP. Un exemple est d'autoriser le trafic HTTP pour des domaines spécifiques.
- **Exported Activities and Services** : Identifier les activities et services exportés dans le manifest peut mettre en évidence des composants susceptibles d'être détournés. Une analyse supplémentaire en test dynamique peut révéler comment exploiter ces composants.
- **Content Providers and FileProviders** : Des content providers exposés pourraient permettre un accès ou une modification non autorisés des données. La configuration des FileProviders doit également être examinée.
- **Broadcast Receivers and URL Schemes** : Ces composants pourraient être exploités, en portant une attention particulière à la manière dont les schémas d'URL sont gérés pour les vulnérabilités d'entrée.
- **SDK Versions** : Les attributs `minSdkVersion`, `targetSDKVersion` et `maxSdkVersion` indiquent les versions Android supportées, soulignant l'importance de ne pas supporter des versions Android obsolètes et vulnérables pour des raisons de sécurité.

Depuis le fichier **strings.xml**, des informations sensibles telles que des clés API, des schemas personnalisés et d'autres notes de développeur peuvent être découvertes, soulignant la nécessité d'un examen attentif de ces ressources.

### Tapjacking

**Tapjacking** est une attaque où une **application** **malveillante** est lancée et **se positionne au-dessus d'une application victime**. Une fois qu'elle obscurcit visiblement l'application victime, son interface utilisateur est conçue de manière à tromper l'utilisateur pour qu'il interagisse avec elle, tandis qu'elle transmet l'interaction à l'application victime.\
En pratique, c'est **aveugler l'utilisateur afin qu'il ne sache pas qu'il effectue en réalité des actions sur l'application victime**.

Trouvez plus d'informations dans :


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Une **activity** avec le **`launchMode`** réglé sur **`singleTask` sans aucun `taskAffinity`** défini est vulnérable au Task Hijacking. Cela signifie qu'une **application** peut être installée et si elle est lancée avant la vraie application, elle pourrait **détourner la tâche de la vraie application** (ainsi l'utilisateur interagira avec l'**application malveillante en pensant utiliser la véritable application**).

Plus d'infos dans :


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Stockage de données non sécurisé

Internal Storage

Sur Android, les fichiers **stockés** dans le stockage **interne** sont **conçus** pour être **accessibles** exclusivement par l'**app** qui les a **créés**. Cette mesure de sécurité est **appliquée** par le système d'exploitation Android et est généralement adéquate pour les besoins de sécurité de la plupart des applications. Cependant, les développeurs utilisent parfois des modes tels que `MODE_WORLD_READABLE` et `MODE_WORLD_WRITABLE` pour **permettre** le partage de fichiers entre différentes applications. Pourtant, ces modes **ne restreignent pas l'accès** à ces fichiers par d'autres applications, y compris potentiellement des applications malveillantes.

1. **Analyse statique :**
- **Assurez-vous** que l'utilisation de `MODE_WORLD_READABLE` et `MODE_WORLD_WRITABLE` est **soigneusement examinée**. Ces modes **peuvent potentiellement exposer** des fichiers à un **accès non voulu ou non autorisé**.
2. **Analyse dynamique :**
- **Vérifiez** les **permissions** définies sur les fichiers créés par l'app. Plus précisément, **contrôlez** si des fichiers sont **rendus lisibles ou modifiables mondialement**. Cela peut constituer un risque de sécurité important, car cela permettrait à **n'importe quelle application** installée sur l'appareil, quel que soit son origine ou son intention, de **lire ou modifier** ces fichiers.

External Storage

Lorsqu'on traite des fichiers sur le **stockage externe**, comme les cartes SD, certaines précautions doivent être prises :

1. **Accessibilité** :
- Les fichiers sur le stockage externe sont **globalement lisibles et modifiables**. Cela signifie que n'importe quelle application ou utilisateur peut y accéder.
2. **Préoccupations de sécurité** :
- Étant donné la facilité d'accès, il est conseillé **de ne pas stocker d'informations sensibles** sur le stockage externe.
- Le stockage externe peut être retiré ou accédé par n'importe quelle application, ce qui le rend moins sûr.
3. **Traitement des données provenant du stockage externe** :
- Effectuez toujours une **validation d'entrée** sur les données récupérées depuis le stockage externe. C'est crucial car les données proviennent d'une source non fiable.
- Il est fortement déconseillé de stocker des exécutables ou des fichiers de classes sur le stockage externe pour un chargement dynamique.
- Si votre application doit récupérer des fichiers exécutables depuis le stockage externe, assurez-vous que ces fichiers sont **signés et vérifiés cryptographiquement** avant qu'ils ne soient chargés dynamiquement. Cette étape est vitale pour maintenir l'intégrité de sécurité de votre application.

Le stockage externe peut être **accessible** dans `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> À partir d'Android 4.4 (**API 17**), la carte SD possède une structure de répertoires qui **limite l'accès d'une app au répertoire qui est spécifiquement pour cette app**. Cela empêche une application malveillante d'obtenir un accès en lecture ou en écriture aux fichiers d'une autre app.

Données sensibles stockées en clair

- **Shared preferences** : Android permet à chaque application d'enregistrer facilement des fichiers xml dans le chemin `/data/data/<packagename>/shared_prefs/` et parfois il est possible de trouver des informations sensibles en clair dans ce dossier.
- **Databases** : Android permet à chaque application d'enregistrer facilement des bases sqlite dans le chemin `/data/data/<packagename>/databases/` et parfois il est possible de trouver des informations sensibles en clair dans ce dossier.

### Broken TLS

Accept All Certificates

Pour une raison ou une autre, parfois les développeurs acceptent tous les certificats même si par exemple le hostname ne correspond pas, avec des lignes de code comme la suivante :
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Une bonne façon de tester cela est d'essayer de capturer le trafic en utilisant un proxy comme Burp sans autoriser Burp CA à l'intérieur de l'appareil. De plus, vous pouvez générer avec Burp un certificat pour un hostname différent et l'utiliser.

### Cryptographie défaillante

**Processus de gestion des clés insuffisants**

Certains développeurs sauvegardent des données sensibles dans le stockage local et les chiffrent avec une clé hardcoded/prédictible dans le code. Cela ne devrait pas être fait car du reversing pourrait permettre aux attaquants d'extraire les informations confidentielles.

**Utilisation d'algorithmes non sécurisés et/ou obsolètes**

Les développeurs ne devraient pas utiliser des **algorithmes obsolètes** pour effectuer des **vérifications d'authorisation**, **stocker** ou **envoyer** des données. Certains de ces algorithmes sont : RC4, MD4, MD5, SHA1... Si des **hashes** sont utilisés pour stocker des mots de passe par exemple, des hashes résistants au brute-force devraient être utilisés avec du salt.

### Autres vérifications

- Il est recommandé d'**obfusquer l'APK** pour rendre le travail de reverse engineering plus difficile pour les attaquants.
- Si l'app est sensible (comme les applications bancaires), elle devrait effectuer ses **propres vérifications pour savoir si le mobile est rooted** et agir en conséquence.
- Si l'app est sensible (comme les applications bancaires), elle devrait vérifier si un **emulator** est utilisé.
- Si l'app est sensible (comme les applications bancaires), elle devrait **vérifier son intégrité avant exécution** pour vérifier si elle a été modifiée.
- Utilisez [**APKiD**](https://github.com/rednaga/APKiD) pour vérifier quel compiler/packer/obfuscator a été utilisé pour construire l'APK

### React Native Application

Lisez la page suivante pour apprendre comment accéder facilement au code javascript des applications React :


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Lisez la page suivante pour apprendre comment accéder facilement au code C# d'une application Xamarin :


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

The tool [**mariana-trench**](https://github.com/facebook/mariana-trench) is capable of finding **vulnérabilités** by **scanning** the **code** of the application. This tool contains a series of **known sources** (that indicates to the tool the **places** where the **input** is **controlled by the user**), **sinks** (which indicates to the tool **dangerous** **places** where malicious user input could cause damages) and **rules**. These rules indicates the **combinaison** of **sources-sinks** that indicates a vulnérabilité.

With this knowledge, **mariana-trench will review the code and find possible vulnerabilities on it**.

### Secrets leaked

An application may contain secrets (API keys, passwords, hidden urls, subdomains...) inside of it that you might be able to discover. You could us a tool such as [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Exécution de code**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Envoi de SMS**: `sendTextMessage, sendMultipartTestMessage`
- **Fonctions natives** déclarées comme `native`: `public native, System.loadLibrary, System.load`
- [Lisez ceci pour apprendre **comment reverse native functions**](reversing-native-libraries.md)

### **Autres astuces**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> First of all, you need an environment where you can install the application and all the environment (Burp CA cert, Drozer and Frida mainly). Therefore, a rooted device (emulated or not) is extremely recommended.

### Online Dynamic analysis

You can create a **free account** in: [https://appetize.io/](https://appetize.io). This platform allows you to **upload** and **execute** APKs, so it is useful to see how an apk is behaving.

You can even **see the logs of your application** in the web and connect through **adb**.

![](<../../images/image (831).png>)

Thanks to the ADB connection you can use **Drozer** and **Frida** inside the emulators.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (You can create **x86** and **arm** devices, and according to [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** versions **support ARM libraries** without needing an slow arm emulator).
- Learn to set it up in this page:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, you need to create an account. _It's recommend to **download** the version **WITH**_ _**VirtualBox** to avoid potential errors._)
- [**Nox**](https://es.bignox.com) (Free, but it doesn't support Frida or Drozer).

> [!TIP]
> When creating a new emulator on any platform remember that the bigger the screen is, the slower the emulator will run. So select small screens if possible.

To **install google services** (like AppStore) in Genymotion you need to click on the red marked button of the following image:

![](<../../images/image (277).png>)

Also, notice that in the **configuration of the Android VM in Genymotion** you can select **Bridge Network mode** (this will be useful if you will be connecting to the Android VM from a different VM with the tools).

#### Use a physical device

You need to activate the **debugging** options and it will be cool if you can **root** it:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Once you have installed the application, the first thing you should do is to try it and investigate what does it do, how does it work and get comfortable with it.\
> I will suggest to **perform this initial dynamic analysis using MobSF dynamic analysis + pidcat**, so we will be able to **learn how the application works** while MobSF **captures** a lot of **interesting** **data** you can review later on.

Magisk/Zygisk quick notes (recommended on Pixel devices)
- Patch boot.img with the Magisk app and flash via fastboot to get systemless root
- Enable Zygisk + DenyList for root hiding; consider LSPosed/Shamiko when stronger hiding is required
- Keep original boot.img to recover from OTA updates; re-patch after each OTA
- For screen mirroring, use scrcpy on the host



### Unintended Data Leakage

**Logging**

Les développeurs doivent être prudents quant à l'exposition des **debugging information** publiquement, car cela peut conduire à des données sensibles leaks. The tools [**pidcat**](https://github.com/JakeWharton/pidcat) and `adb logcat` are recommended for monitoring application logs to identify and protect sensitive information. **Pidcat** is favored for its ease of use and readability.

> [!WARNING]
> Note that from **later newer than Android 4.0**, **applications are only able to access their own logs**. So applications cannot access other apps logs.\
> Anyway, it's still recommended to **not log sensitive information**.

**Copy/Paste Buffer Caching**

Le framework **clipboard-based** d'Android permet la fonctionnalité copy-paste dans les apps, mais présente un risque car **other applications** peuvent **access** le clipboard, exposant potentiellement des données sensibles. Il est crucial de **désactiver copy/paste** pour les sections sensibles d'une application, comme les détails de carte de crédit, pour prévenir des data leaks.

**Crash Logs**

Si une application **crashes** et **sauvegarde des logs**, ces logs peuvent aider les attaquants, particulièrement lorsque l'application ne peut pas être reverse-engineered. Pour atténuer ce risque, évitez de logger lors des crashes, et si des logs doivent être transmis sur le réseau, assurez-vous qu'ils soient envoyés via un canal SSL pour la sécurité.

As pentester, **try to take a look to these logs**.

**Analytics Data Sent To 3rd Parties**

Les applications intègrent souvent des services comme Google Adsense, ce qui peut involontairement **leak sensitive data** en raison d'implémentations incorrectes par les développeurs. Pour identifier des potentielles data leaks, il est conseillé d'**intercept the application's traffic** et de vérifier s'il y a des informations sensibles envoyées à des services tiers.

### SQLite DBs

Most of the applications will use **internal SQLite databases** to save information. During the pentest take a **look** to the **databases** created, the names of **tables** and **columns** and all the **data** saved because you could find **sensitive information** (which would be a vulnerability).\
Databases should be located in `/data/data/the.package.name/databases` like `/data/data/com.mwr.example.sieve/databases`

If the database is saving confidential information and is **encrypted**, but you can **find** the **password** inside the application it's still a **vulnerability**.

Enumerate the tables using `.tables` and enumerate the columns of the tables doing `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer is s useful tool to **exploit exported activities, exported services and Content Providers** as you will learn in the following sections.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Also remember that the code of an activity starts in the **`onCreate`** method.

**Authorisation bypass**

When an Activity is exported you can invoke its screen from an external app. Therefore, if an activity with **sensitive information** is **exported** you could **bypass** the **authentication** mechanisms **to access it.**

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

You can also start an exported activity from adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**REMARQUE**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> Note that an authorisation bypass is not always a vulnerability, it would depend on how the bypass works and which information is exposed.

**Fuite d'informations sensibles**

**Activities can also return results**. If you manage to find an exported and unprotected activity calling the **`setResult`** method and **returning sensitive information**, there is a sensitive information leakage.

#### Tapjacking

If Tapjacking isn't prevented, you could abuse the exported activity to make the **user perform unexpected actions**. For more info about [**what is Tapjacking follow the link**](#tapjacking).

### Exploiter les Content Providers - Accéder et manipuler des informations sensibles

[**Lisez ceci si vous voulez revoir ce qu'est un Content Provider.**](android-applications-basics.md#content-provider)\
Content providers are basically used to **share data**. If an app has available content providers you may be able to **extract sensitive** data from them. It also interesting to test possible **SQL injections** and **Path Traversals** as they could be vulnerable.

[**Apprenez à exploiter les Content Providers avec Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiter les Services**

[**Lisez ceci si vous voulez revoir ce qu'est un Service.**](android-applications-basics.md#services)\
Rappelez-vous que les actions d'un Service commencent dans la méthode `onStartCommand`.

Un Service est essentiellement quelque chose qui **peut recevoir des données**, les **traiter** et **renvoyer** (ou non) une réponse. Donc, si une application exporte certains services vous devriez **vérifier** le **code** pour comprendre ce qu'il fait et le **tester** **dynamiquement** afin d'extraire des informations confidentielles, contourner des mesures d'authentification...\
[**Apprenez à exploiter les Services avec Drozer.**](drozer-tutorial/index.html#services)

### **Exploiter les Broadcast Receivers**

[**Lisez ceci si vous voulez revoir ce qu'est un Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Rappelez-vous que les actions d'un Broadcast Receiver commencent dans la méthode `onReceive`.

Un broadcast receiver attendra un type de message. Selon la façon dont le receiver traite le message, il pourrait être vulnérable.\
[**Apprenez à exploiter les Broadcast Receivers avec Drozer.**](#exploiting-broadcast-receivers)

### **Exploiter les Schemes / Deep links**

Vous pouvez rechercher des deep links manuellement, en utilisant des outils comme MobSF ou des scripts comme [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Vous pouvez **ouvrir** un déclaré **scheme** en utilisant **adb** ou un **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Remarque : vous pouvez **omettre le nom du package** et le mobile appellera automatiquement l'application qui doit ouvrir ce lien._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Code exécuté**

Pour trouver le **code qui sera exécuté dans l'App**, allez à l'activité appelée par le deep link et recherchez la fonction **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Informations sensibles**

Chaque fois que vous trouvez un deep link, vérifiez **qu'il ne reçoit pas de données sensibles (comme des mots de passe) via des paramètres d'URL**, car toute autre application pourrait **usurper le deep link et voler ces données !**

**Paramètres dans le chemin**

Vous **devez aussi vérifier si un deep link utilise un paramètre à l'intérieur du path** de l'URL comme : `https://api.example.com/v1/users/{username}` , dans ce cas vous pouvez forcer un path traversal en accédant à quelque chose comme : `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Notez que si vous trouvez les endpoints corrects à l'intérieur de l'application vous pouvez être capable de provoquer un **Open Redirect** (si une partie du path est utilisée comme nom de domaine), un **account takeover** (si vous pouvez modifier les détails d'utilisateurs sans token CSRF et que l'endpoint vulnérable utilisait la méthode correcte) et toute autre vuln. Plus d'infos [about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Inspection de la couche transport et échecs de vérification

- **Les certificats ne sont pas toujours inspectés correctement** par les applications Android. Il est courant que ces applications ignorent les warnings et acceptent des certificats self-signed ou, dans certains cas, repassent à des connexions HTTP.
- **Les négociations durant le SSL/TLS handshake sont parfois faibles**, employant des cipher suites non sécurisées. Cette vulnérabilité rend la connexion susceptible aux attaques man-in-the-middle (MITM), permettant aux attaquants de déchiffrer les données.
- **Fuite d'informations privées** est un risque lorsque les applications s'authentifient en utilisant des canaux sécurisés puis communiquent sur des canaux non sécurisés pour d'autres transactions. Cette approche ne protège pas les données sensibles, comme les cookies de session ou les informations utilisateur, contre l'interception par des entités malveillantes.

#### Vérification des certificats

Nous nous concentrerons sur la **vérification des certificats**. L'intégrité du certificat du serveur doit être vérifiée pour renforcer la sécurité. Ceci est crucial car des configurations TLS non sécurisées et la transmission de données sensibles sur des canaux non chiffrés peuvent poser des risques importants. Pour des étapes détaillées sur la vérification des certificats serveurs et la correction des vulnérabilités, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) fournit des conseils complets.

#### SSL Pinning

SSL Pinning est une mesure de sécurité où l'application vérifie le certificat du serveur par rapport à une copie connue stockée dans l'application elle-même. Cette méthode est essentielle pour prévenir les attaques MITM. Il est fortement recommandé d'implémenter SSL Pinning pour les applications manipulant des informations sensibles.

#### Inspection du trafic

Pour inspecter le trafic HTTP, il est nécessaire d'**installer le certificat du proxy** (par ex. Burp). Sans installer ce certificat, le trafic chiffré pourrait ne pas être visible via le proxy. Pour un guide sur l'installation d'un CA personnalisé, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Les applications ciblant **API Level 24 and above** nécessitent des modifications du Network Security Config pour accepter le certificat CA du proxy. Cette étape est critique pour inspecter le trafic chiffré. Pour des instructions sur la modification du Network Security Config, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

Si **Flutter** est utilisé, vous devez suivre les instructions sur [**this page**](flutter.md). Cela s'explique par le fait que, simplement ajouter le certificat dans le store ne fonctionnera pas car Flutter a sa propre liste de CAs valides.

#### Détection statique du SSL/TLS pinning

Avant d'essayer des contournements runtime, cartographiez rapidement où le pinning est appliqué dans l'APK. La découverte statique vous aide à planifier des hooks/patches et à vous concentrer sur les bons chemins de code.

Tool: SSLPinDetect
- Open-source static-analysis utility qui décompile l'APK en Smali (via apktool) et scanne des motifs regex sélectionnés d'implémentations de SSL/TLS pinning.
- Rapporte le chemin exact du fichier, le numéro de ligne, et un snippet de code pour chaque correspondance.
- Couvre des frameworks courants et des chemins de code personnalisés : OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, et Network Security Config XML pins.

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Utilisation
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Exemples de règles de pattern (JSON)
Utilisez ou étendez des signatures pour détecter des styles de pinning propriétaires/personnalisés. Vous pouvez charger votre propre JSON et effectuer des analyses à grande échelle.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes et astuces
- Analyse rapide des grandes applications via multi-threading et I/O mappée en mémoire ; les regex pré-compilées réduisent la surcharge / les faux positifs.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Cibles de détection typiques à trier ensuite :
- OkHttp: utilisation de CertificatePinner, setCertificatePinner, références de package okhttp3/okhttp
- TrustManagers personnalisés: javax.net.ssl.X509TrustManager, overrides de checkServerTrusted
- Contextes SSL personnalisés: SSLContext.getInstance + SSLContext.init avec des managers personnalisés
- Pins déclaratifs dans res/xml network security config et références dans le manifest
- Utilisez les emplacements identifiés pour planifier des hooks Frida, des patchs statiques, ou des revues de configuration avant les tests dynamiques.



#### Contournement de SSL Pinning

Lorsque SSL Pinning est implémenté, le contourner devient nécessaire pour inspecter le trafic HTTPS. Plusieurs méthodes sont disponibles pour cela :

- Automatiquement **modifier** le **apk** pour **bypasser** SSLPinning avec [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Le principal avantage de cette option est que vous n'aurez pas besoin de root pour bypasser le SSL Pinning, mais vous devrez supprimer l'application et réinstaller la nouvelle, et cela ne fonctionnera pas toujours.
- Vous pouvez utiliser **Frida** (discuté ci-dessous) pour bypasser cette protection. Voici un guide pour utiliser Burp+Frida+Genymotion : [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Vous pouvez aussi essayer de **bypasser automatiquement SSL Pinning** en utilisant [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Vous pouvez aussi essayer de **bypasser automatiquement SSL Pinning** en utilisant **MobSF dynamic analysis** (expliqué ci-dessous)
- Si vous pensez toujours qu'il y a du trafic que vous ne capturez pas, vous pouvez essayer de **rediriger le trafic vers burp en utilisant iptables**. Lisez ce blog : [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Recherche de vulnérabilités web courantes

Il est également important de rechercher des vulnérabilités web courantes dans l'application. Des informations détaillées sur l'identification et l'atténuation de ces vulnérabilités dépassent le cadre de ce résumé mais sont couvertes de manière exhaustive ailleurs.

### Frida

[Frida](https://www.frida.re) est un toolkit d'instrumentation dynamique pour développeurs, reverse-engineers, et chercheurs en sécurité.\
**Vous pouvez accéder à l'application en cours d'exécution et hooker des méthodes à l'exécution pour modifier le comportement, changer des valeurs, extraire des valeurs, exécuter du code différent...**\
Si vous voulez pentest des applications Android vous devez savoir comment utiliser Frida.

- Apprenez à utiliser Frida : [**Frida tutorial**](frida-tutorial/index.html)
- Quelques "GUI" pour des actions avec Frida : [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection est excellent pour automatiser l'utilisation de Frida : [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Vous pouvez trouver quelques scripts Frida "Awesome" ici : [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Essayez de contourner les mécanismes anti-debugging / anti-frida en chargeant Frida comme indiqué dans [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (outil [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

Vérifiez si l'application stocke des informations sensibles en mémoire qu'elle ne devrait pas stocker, comme des mots de passe ou des mnémoniques.

En utilisant [**Fridump3**](https://github.com/rootbsd/fridump3) vous pouvez faire un dump de la mémoire de l'app avec:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Cela dumpera la mémoire dans le dossier ./dump, et vous pourrez ensuite grep dedans avec quelque chose comme :
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Données sensibles dans Keystore**

Sur Android, le Keystore est l'endroit idéal pour stocker des données sensibles, cependant, avec des privilèges suffisants il reste possible d'y accéder. Comme les applications ont tendance à y stocker des données sensibles en clear text, les pentests devraient vérifier cela en tant que root user, car une personne ayant un accès physique à l'appareil pourrait voler ces données.

Même si une application stocke des données dans le Keystore, ces données doivent être chiffrées.

Pour accéder aux données dans le Keystore vous pouvez utiliser ce Frida script: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

En utilisant le script Frida suivant, il pourrait être possible de **bypass fingerprint authentication** que des applications Android effectuent afin de **protéger certaines zones sensibles :**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Images d'arrière-plan**

Lorsque vous placez une application en arrière-plan, Android stocke un **snapshot of the application** : lorsque celle-ci est ramenée au premier plan, il commence par charger l'image avant l'application, de sorte qu'il semble que l'application ait été chargée plus rapidement.

Cependant, si ce snapshot contient des **informations sensibles**, quelqu'un ayant accès au snapshot pourrait **voler ces informations** (notez qu'il faut un accès root pour y accéder).

Les snapshots sont généralement stockés à : **`/data/system_ce/0/snapshots`**

Android fournit un moyen d'empêcher la capture de screenshot en définissant le paramètre de layout FLAG_SECURE. En utilisant ce flag, le contenu de la fenêtre est traité comme sécurisé, ce qui empêche qu'il apparaisse dans des screenshots ou qu'il soit affiché sur des écrans non sécurisés.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Cet outil peut vous aider à gérer différents outils pendant l'analyse dynamique : [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Les développeurs créent souvent des composants proxy comme activities, services, et broadcast receivers qui traitent ces Intents et les passent à des méthodes telles que `startActivity(...)` ou `sendBroadcast(...)`, ce qui peut être risqué.

Le danger réside dans le fait de permettre à des attaquants de déclencher des composants d'application non-exportés ou d'accéder à des content providers sensibles en détournant ces Intents. Un exemple notable est le composant `WebView` qui convertit des URLs en objets `Intent` via `Intent.parseUri(...)` puis les exécute, ce qui peut conduire à des Intent injections malveillantes.

### Points essentiels

- **Intent Injection** est similaire au problème Open Redirect du web.
- Les exploits consistent à passer des objets `Intent` comme extras, qui peuvent être redirigés pour exécuter des opérations dangereuses.
- Cela peut exposer des composants non-exportés et des content providers aux attaquants.
- La conversion d'URLs en `Intent` par `WebView` peut faciliter des actions non prévues.

### Injections côté client Android et autres

Vous connaissez probablement ce type de vulnérabilités depuis le Web. Il faut être particulièrement vigilant avec ces vulnérabilités dans une application Android :

- **SQL Injection:** Lorsqu'on gère des requêtes dynamiques ou des Content-Providers, assurez-vous d'utiliser des requêtes paramétrées.
- **JavaScript Injection (XSS):** Verify that JavaScript and Plugin support is disabled for any WebViews (disabled by default). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews should have access to the file system disabled (enabled by default) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: Dans plusieurs cas, lorsque l'application Android termine la session le cookie n'est pas révoqué ou il peut même être enregistré sur le disque
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Analyse automatique

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Analyse statique**

![](<../../images/image (866).png>)

**Évaluation des vulnérabilités de l'application** via une jolie interface web. Vous pouvez aussi effectuer une analyse dynamique (mais vous devez préparer l'environnement).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Remarque: MobSF peut analyser **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Aussi, si vous créez un fichier **ZIP** avec le code source d'une application **Android** ou **IOS** (allez dans le dossier racine de l'application, sélectionnez tout et créez un ZIPfile), il pourra l'analyser également.

MobSF permet aussi de faire un **diff/Compare** des analyses et d'intégrer **VirusTotal** (vous devrez définir votre API key dans _MobSF/settings.py_ et l'activer: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). Vous pouvez aussi mettre `VT_UPLOAD` à `False`, dans ce cas le **hash** sera **upload** au lieu du fichier.

### Assisted Dynamic analysis with MobSF

**MobSF** peut aussi être très utile pour l'**analyse dynamique** sur **Android**, mais dans ce cas vous devrez installer MobSF et **genymotion** sur votre machine hôte (une VM ou Docker ne fonctionnera pas). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
Le **MobSF dynamic analyser** peut :

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). Tout cela est fait automatiquement sauf pour les captures d'écran : vous devez appuyer lorsque vous voulez une capture d'écran ou appuyer sur "**Exported Activity Tester**" pour obtenir des captures de toutes les activités exportées.
- Capturer le **HTTPS traffic**
- Utiliser **Frida** pour obtenir des informations **runtime**

À partir des versions Android **> 5**, il lancera **automatically Frida** et définira les paramètres de **proxy** globaux pour **capture** le trafic. Il ne capturera que le trafic de l'application testée.

**Frida**

Par défaut, il utilisera aussi quelques Frida Scripts pour **bypass SSL pinning**, **root detection** et **debugger detection** et pour **monitor interesting APIs**.\
MobSF peut aussi **invoke exported activities**, prendre des **screenshots** de celles-ci et les **save** pour le rapport.

Pour **start** le test dynamique, appuyez sur le bouton vert : "**Start Instrumentation**". Appuyez sur "**Frida Live Logs**" pour voir les logs générés par les Frida scripts et sur "**Live API Monitor**" pour voir toutes les invocations vers les méthodes hookées, les arguments passés et les valeurs retournées (cela apparaîtra après avoir appuyé sur "Start Instrumentation").\
MobSF permet également de charger vos propres **Frida scripts** (pour envoyer les résultats de vos Frida scripts à MobSF utilisez la fonction `send()`). Il propose aussi **several pre-written scripts** que vous pouvez charger (vous pouvez en ajouter dans `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), il suffit de **les sélectionner**, appuyer sur "**Load**" et appuyer sur "**Start Instrumentation**" (vous pourrez voir les logs de ces scripts dans "**Frida Live Logs**").

![](<../../images/image (419).png>)

De plus, vous disposez de quelques fonctionnalités auxiliaires Frida :

- **Enumerate Loaded Classes** : Affiche toutes les classes chargées
- **Capture Strings** : Affiche toutes les chaînes capturées pendant l'utilisation de l'application (très bruyant)
- **Capture String Comparisons** : Peut être très utile. Il **montrera les 2 strings comparées** et si le résultat était True ou False.
- **Enumerate Class Methods** : Indiquez le nom de la classe (comme "java.io.File") et il affichera toutes les méthodes de la classe.
- **Search Class Pattern** : Recherche des classes par pattern
- **Trace Class Methods** : **Trace** une **classe entière** (voir les entrées et sorties de toutes les méthodes de la classe). Rappelez-vous que par défaut MobSF trace plusieurs méthodes API Android intéressantes.

Une fois que vous avez sélectionné le module auxiliaire que vous voulez utiliser, vous devez appuyer sur "**Start Intrumentation**" et vous verrez toutes les sorties dans "**Frida Live Logs**".

**Shell**

MobSF fournit aussi un shell avec quelques commandes **adb**, commandes **MobSF**, et des commandes **shell** courantes en bas de la page d'analyse dynamique. Quelques commandes intéressantes :
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**Outils HTTP**

Lorsque le trafic HTTP est capturé, vous pouvez voir une vue brute du trafic capturé via le bouton "**HTTP(S) Traffic**" ou une vue plus lisible via le bouton vert "**Start HTTPTools**". Avec la seconde option, vous pouvez **envoyer** les **requêtes capturées** vers des **proxies** comme Burp ou Owasp ZAP.\
Pour ce faire, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> appuyez sur "**Send to Fuzzer**" --> _sélectionnez l'adresse du proxy_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Une fois que vous avez terminé l'analyse dynamique avec MobSF, vous pouvez cliquer sur "**Start Web API Fuzzer**" pour **fuzz** les requêtes HTTP et rechercher des vulnérabilités.

> [!TIP]
> Après avoir effectué une analyse dynamique avec MobSF, les paramètres du proxy peuvent être mal configurés et vous ne pourrez pas les corriger depuis la GUI. Vous pouvez corriger les paramètres du proxy en exécutant :
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

Vous pouvez obtenir l'outil depuis [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Cet outil utilise des **Hooks** pour vous indiquer **ce qui se passe dans l'application** pendant que vous effectuez une **analyse dynamique**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

C'est un **excellent outil pour effectuer une analyse statique avec une GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Cet outil est conçu pour rechercher plusieurs **vulnérabilités liées à la sécurité des applications Android**, que ce soit dans le **code source** ou dans les **APKs packagées**. L'outil est également **capable de créer un "Proof-of-Concept" deployable APK** et des **ADB commands**, pour exploiter certaines des vulnérabilités trouvées (Exposed activities, intents, tapjacking...). Comme avec Drozer, il n'est pas nécessaire de rooter l'appareil de test.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Affiche tous les fichiers extraits pour une consultation facile
- Décompile automatiquement les fichiers APK au format Java et Smali
- Analyse AndroidManifest.xml pour détecter les vulnérabilités courantes et le comportement
- Analyse statique du code source pour détecter les vulnérabilités courantes et le comportement
- Informations sur l'appareil
- et plus encore
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER est une application en ligne de commande utilisable sous Windows, MacOS X et Linux, qui analyse des fichiers _.apk_ à la recherche de vulnérabilités. Elle le fait en décompressant les APK et en appliquant une série de règles pour détecter ces vulnérabilités.

Toutes les règles sont centralisées dans un fichier `rules.json`, et chaque entreprise ou testeur peut créer ses propres règles pour analyser ce dont ils ont besoin.

Téléchargez les derniers binaires depuis la [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn est un outil **crossplatform** qui aide les développeurs, bugbounty hunters et ethical hackers à effectuer de la [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) sur les applications mobiles.

Le concept est que vous glissez-déposez le fichier de votre application mobile (un .apk ou .ipa) sur l'application StaCoAn et elle générera pour vous un rapport visuel et portable. Vous pouvez ajuster les paramètres et les wordlists pour obtenir une expérience personnalisée.

Téléchargez[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework est un système d'analyse de vulnérabilités Android qui aide les développeurs ou les hackers à trouver des vulnérabilités potentielles dans les applications Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** est un outil dont le but principal est de détecter et d'alerter l'utilisateur sur des comportements potentiellement malveillants développés par une application Android.

La détection est effectuée par **analyse statique** du bytecode Dalvik de l'application, représenté en **Smali**, à l'aide de la bibliothèque [`androguard`](https://github.com/androguard/androguard).

Cet outil recherche des **comportements courants d'applications "malveillantes"** tels que : exfiltration d'identifiants téléphoniques, interception de flux audio/vidéo, modification des données PIM, exécution de code arbitraire...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** est un framework d'ingénierie inverse et d'analyse d'applications mobiles. C'est un outil qui regroupe des outils couramment utilisés pour l'ingénierie inverse et l'analyse d'applications mobiles, afin d'aider à tester les applications mobiles contre les menaces de sécurité mobiles OWASP. Son objectif est de faciliter cette tâche et de la rendre plus accessible aux développeurs d'applications mobiles et aux professionnels de la sécurité.

Il permet de :

- Extraire le code Java et Smali en utilisant différents outils
- Analyser les APKs en utilisant : [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Extraire des informations privées depuis l'APK en utilisant des regexps.
- Analyser le Manifest.
- Analyser les domaines trouvés en utilisant : [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) et [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Déobfusquer un APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Utile pour détecter des malware : [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Notez que, selon le service et la configuration utilisés pour obfusquer le code, les secrets peuvent être ou non obfusqués.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** est un outil open source en ligne de commande qui réduit, optimise et obfusque le code Java. Il est capable d'optimiser le bytecode ainsi que de détecter et supprimer les instructions non utilisées. ProGuard est un logiciel libre et est distribué sous la GNU General Public License, version 2.

ProGuard est distribué dans l'Android SDK et s'exécute lors de la construction de l'application en mode release.

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Last time we checked, the Dexguard mode of operation was:

- charger une ressource en tant qu'InputStream ;
- fournir le résultat à une classe héritant de FilterInputStream pour le déchiffrer ;
- effectuer une obfuscation inutile pour faire perdre quelques minutes à la personne effectuant le reverse engineering ;
- fournir le résultat déchiffré à un ZipInputStream pour obtenir un fichier DEX ;
- enfin charger le DEX obtenu comme Resource en utilisant la méthode `loadDex`.

### [DeGuard](http://apk-deguard.com)

**DeGuard reversee le processus d'obfuscation effectué par les outils d'obfuscation Android. Cela permet de réaliser de nombreuses analyses de sécurité, y compris l'inspection du code et la prédiction des bibliothèques.**

Vous pouvez téléverser un APK obfusqué sur leur plateforme.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

It is a **generic android deobfuscator.** Simplify **virtually executes an app** to understand its behavior and then **tries to optimize the code** so it behaves identically but is easier for a human to understand. Each optimization type is simple and generic, so it doesn't matter what the specific type of obfuscation is used.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD vous donne des informations sur la façon dont un APK a été créé. Il identifie de nombreux compilers, packers, obfuscators et autres choses bizarres. C'est [_PEiD_](https://www.aldeid.com/wiki/PEiD) pour Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b est une machine virtuelle de sécurité Android basée sur ubuntu-mate qui inclut une collection des derniers frameworks, tutoriels et labs provenant de différents passionnés et chercheurs en sécurité pour le reverse engineering et l'analyse de malware.

## Références

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) C'est une excellente liste de ressources
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)

## À tester

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
