# Androidアプリケーション Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Androidアプリケーションの基本

このページは、**Androidのセキュリティに関連する最重要部分と、Androidアプリケーション内で最も危険なコンポーネント**について知るために、まず読むことを強く推奨します：


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

これは、エミュレートされたデバイスでも実機でも、Androidデバイスに接続するために必要な主要なツールです。\
**ADB** はコンピュータから **USB** または **Network** 経由でデバイスを制御できます。このユーティリティは、ファイルの双方向での**コピー**、アプリの**インストール**と**アンインストール**、**shell commands**の実行、データの**バックアップ**、ログの**閲覧**などの機能を提供します。

adbの使い方を学ぶには、次の[**ADB Commands**](adb-commands.md)の一覧を参照してください。

## Smali

アプリケーションコードを変更して**隠された情報**（難読化されたパスワードやフラグなど）にアクセスすることが有用な場合があります。その際、apkをデコンパイルしてコードを修正し、再コンパイルすることが考えられます。\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md)。これは、これから紹介する動的解析中のいくつかのテストの代替手段として非常に役立ちます。常にこの可能性を念頭に置いてください。

## その他の興味深いテクニック

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- デバイスからAPKを抽出する方法：
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- [APKEditor](https://github.com/REAndroid/APKEditor) を使用して、すべての splits と base apks をマージする:
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## ケーススタディと脆弱性


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## 静的解析

まず、APKを解析する際はデコンパイラを使って**Javaコードを確認する**べきです。\
[**利用可能なさまざまなデコンパイラに関する情報はこちらを参照してください**](apk-decompilers.md)。

### 興味深い情報の探索

APKの**strings**を覗くだけで、**パスワード**、**URL**（https://github.com/ndelphit/apkurlgrep）、**APIキー**、**暗号化**、**Bluetooth UUID**、**トークン**などや興味深いものを検索できます。コード実行の**バックドア**や認証バックドア（アプリにハードコードされた管理者資格情報）も探してみてください。

**Firebase**

**Firebase URL**には特に注意し、設定が不適切でないか確認してください。[Firebaseとは何か、及びそれを悪用する方法の詳細はこちら。](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### アプリケーションの基本理解 - Manifest.xml, strings.xml

アプリケーションの _Manifest.xml_ と _strings.xml_ ファイルを**調査することで潜在的なセキュリティ脆弱性が明らかになることがあります**。これらのファイルはデコンパイラで取得するか、APKの拡張子を .zip に変更して解凍して取得できます。

**Manifest.xml** から特定できる脆弱性には次のようなものがあります:

- **Debuggable Applications**: _Manifest.xml_ に `debuggable="true"` と設定されたアプリケーションは、接続を許可することで悪用につながるリスクがあります。デバイス上で debuggable なアプリを見つけて悪用する方法については、該当するチュートリアルを参照してください。
- **Backup Settings**: `android:allowBackup="false"` 属性は、機密情報を扱うアプリでは明示的に設定しておくべきです。特に USBデバッグ が有効な場合に adb 経由で不正なデータバックアップを防ぐため重要です。
- **Network Security**: _res/xml/_ 内のカスタムネットワークセキュリティ構成（`android:networkSecurityConfig="@xml/network_security_config"`）は、証明書ピンや HTTP トラフィック設定などのセキュリティ詳細を指定できます。例えば特定ドメインの HTTP トラフィックを許可する設定などが考えられます。
- **Exported Activities and Services**: マニフェスト内でエクスポートされた activity や service を特定することで、悪用されうるコンポーネントが浮かび上がります。動的テスト中のさらなる解析でこれらをどのように悪用できるかが明らかになります。
- **Content Providers and FileProviders**: 公開された content provider はデータへの不正アクセスや改ざんを許す可能性があります。FileProviders の設定も入念に確認してください。
- **Broadcast Receivers and URL Schemes**: これらのコンポーネントは悪用される可能性があり、特に URL スキームの扱い方による入力脆弱性に注意する必要があります。
- **SDK Versions**: `minSdkVersion`、`targetSDKVersion`、`maxSdkVersion` 属性はサポートする Android バージョンを示します。古く脆弱な Android バージョンをサポートしているとセキュリティ上の問題になります。

**strings.xml** ファイルからは、APIキー、カスタムスキーマ、その他開発者のメモなどの機密情報が見つかることがあり、これらのリソースを注意深くレビューする必要があります。

### Tapjacking

**Tapjacking** は、**悪意のある** **アプリケーション** が起動して **被害アプリの上に重ねて表示される** 攻撃です。被害アプリを目に見えて覆い隠すと、悪意のある UI はユーザを騙して操作させ、その操作を被害アプリに渡します。\
結果的に、ユーザは自分が実際に被害アプリ上で操作を行っていることに気づかないまま動作させられてしまいます。

詳しくは以下を参照してください:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

`launchMode` が **`singleTask`** に設定され、かつ `taskAffinity` が定義されていない **activity** は Task Hijacking の脆弱性があります。これは、別の **application** をインストールしてそれが本物のアプリより先に起動されると、**本物のアプリのタスクをハイジャックしてしまう**（ユーザは本物を使っているつもりで悪意のあるアプリを操作している）可能性があるという意味です。

詳細は以下を参照してください:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Insecure data storage

**Internal Storage**

Android では、内部ストレージに**保存された**ファイルはそれを作成した**アプリのみがアクセスできるように設計**されています。このセキュリティは OS によって強制され、多くのアプリにとっては十分です。しかし開発者が `MODE_WORLD_READABLE` や `MODE_WORLD_WRITABLE` のようなモードを使ってファイルを他のアプリ間で共有することがあり、これらのモードは悪意あるアプリも含めた他のアプリからのアクセスを制限しません。

1. **Static Analysis:**
- `MODE_WORLD_READABLE` と `MODE_WORLD_WRITABLE` の使用は**慎重に精査**してください。これらのモードはファイルを**意図しない、または不正なアクセス**に晒す可能性があります。
2. **Dynamic Analysis:**
- アプリが作成するファイルに設定されている**パーミッション**を確認してください。具体的には、ファイルが世界中で読み取り／書き込み可能になっていないかをチェックします。これがあると、デバイスにインストールされた**任意のアプリ**がそれらのファイルを読み取ったり改変したりできる重大なリスクになります。

**External Storage**

SDカードなどの**外部ストレージ**上のファイルを扱う際には、以下の注意が必要です:

1. **Accessibility**:
- 外部ストレージ上のファイルは**グローバルに読み書き可能**です。つまり任意のアプリやユーザがアクセスできます。
2. **Security Concerns**:
- アクセスが容易であるため、機密情報を外部ストレージに保存するべきではありません。
- 外部ストレージは取り外し可能であり、任意のアプリによってアクセスされ得るため安全性が低いです。
3. **Handling Data from External Storage**:
- 外部ストレージから取得したデータは常に**入力検証**を行ってください。外部ストレージのデータは信頼できないソースから来る可能性があるため重要です。
- 外部ストレージに実行ファイルや class ファイルを置き、動的にロードすることは強く推奨されません。
- どうしても外部ストレージから実行可能ファイルを取得して動的にロードする必要がある場合は、それらのファイルが**署名され、暗号的に検証**されていることを確認してください。これはアプリのセキュリティ整合性を保つ上で重要です。

外部ストレージには /storage/emulated/0 , /sdcard , /mnt/sdcard でアクセスできます

> [!TIP]
> Android 4.4（**API 17**）以降、SDカードにはアプリごとに専用のディレクトリ構造があり、アプリからはそのアプリ専用のディレクトリにのみアクセスが制限されます。これにより、悪意のあるアプリが別のアプリのファイルを読み書きすることを防げます。

**平文で保存された機密データ**

- **Shared preferences**: Android は各アプリが `/data/data/<packagename>/shared_prefs/` に XML ファイルを簡単に保存できる仕組みがあり、そのフォルダ内に平文で機密情報が保存されていることがあります。
- **Databases**: Android は各アプリが `/data/data/<packagename>/databases/` に sqlite データベースを簡単に保存でき、そのフォルダ内に平文で機密情報が保存されていることがあります。

### Broken TLS

**Accept All Certificates**

なぜか開発者が、例えばホスト名が一致しない場合でもすべての証明書を受け入れてしまうことがあります。以下のようなコード行で:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
BurpのCAをデバイス内で許可せずに、Burpのようなプロキシを使ってトラフィックをキャプチャしてみるのが良いテスト方法です。また、Burpで別のホスト名用の証明書を生成してそれを使うこともできます。

### Broken Cryptography

**不適切なキー管理プロセス**

一部の開発者は、機密データをローカルストレージに保存し、コード内にハードコード／予測可能なキーで暗号化してしまいます。これは避けるべきで、なぜなら一部のreversingによって攻撃者が機密情報を抽出してしまう可能性があるからです。

**Use of Insecure and/or Deprecated Algorithms**

開発者は**deprecated algorithms**を使って認可チェック、データの**保存**や**送信**を行うべきではありません。これらのアルゴリズムには RC4、MD4、MD5、SHA1 などがあります。例えばパスワードを保存するために**hashes**を使う場合は、ソルトを用いたブルートフォース耐性のあるハッシュを使用するべきです。

### Other checks

- 攻撃者によるreverse engineerの労力を難しくするために、**APKをobfuscate**することが推奨されます。
- アプリが機微なものである場合（銀行アプリなど）、モバイルが**rooted**かどうかを独自にチェックし、それに応じた処理を行うべきです。
- アプリが機微なものである場合（銀行アプリなど）、**emulator**が使われていないかをチェックするべきです。
- アプリが機微なものである場合（銀行アプリなど）、実行前に**自身のintegrityをチェック**して改変されていないか確認するべきです。
- どのcompiler/packer/obfuscatorが使われているかを確認するために [**APKiD**](https://github.com/rednaga/APKiD) を使用してください。

### React Native Application

Reactアプリケーションのjavascriptコードへ簡単にアクセスする方法を学ぶには、以下のページを読んでください：


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

XamarinアプリのC#コードへ簡単にアクセスする方法を学ぶには、以下のページを読んでください：


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

この[**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/)によると、superpackedはアプリのコンテンツを単一ファイルに圧縮するMetaアルゴリズムです。ブログではこの種のアプリを展開するアプリを作成する可能性について触れており、もう一つのより高速な方法として**アプリを実行してファイルシステムから解凍済みファイルを収集する**方法が述べられています。

### Automated Static Code Analysis

[**mariana-trench**](https://github.com/facebook/mariana-trench) はアプリケーションの**コード**を**スキャン**して**脆弱性**を発見できるツールです。このツールは、ツールに対して**入力がユーザによって制御される場所**を示す一連の**known sources**、悪意あるユーザ入力が被害を引き起こす可能性のある**危険な場所**を示す**sinks**、および**rules**を含みます。これらのrulesは、脆弱性を示すsources-sinksの**組み合わせ**を表します。

この知識に基づいて、**mariana-trenchはコードをレビューし、そこにある可能性のある脆弱性を発見します**。

### Secrets leaked

アプリケーションにはAPIキー、パスワード、隠しURL、サブドメインなどのsecretsが含まれている場合があり、これらを発見できることがあります。例えば [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks) のようなツールを使用できます。

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> まず最初に、アプリをインストールでき、かつ環境（Burp CA cert、Drozer、Frida など）を整えられる環境が必要です。したがって、rootedデバイス（エミュレートされたものでも可）が強く推奨されます。

### Online Dynamic analysis

[https://appetize.io/](https://appetize.io/) に**無料アカウント**を作成できます。このプラットフォームではAPKを**アップロード**して**実行**できるため、APKの挙動を確認するのに便利です。

ウェブ上で**アプリケーションのログを見る**こともでき、**adb**で接続することも可能です。

![](<../../images/image (831).png>)

ADB接続のおかげで、エミュレータ内で**Drozer**や**Frida**を使用できます。

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio)（**x86** および **arm** デバイスを作成できます。また、[**こちら**](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)によれば最新の x86 バージョンは遅い arm エミュレータを使わなくても ARM ライブラリをサポートします）。
- セットアップ方法は以下のページで学べます：


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition、アカウント作成が必要です。_潜在的なエラーを避けるために_ _**VirtualBox付き**のバージョンを**ダウンロード**することを推奨します。_)  
- [**Nox**](https://es.bignox.com)（無料ですが、FridaやDrozerはサポートしていません）。

> [!TIP]
> 新しいエミュレータを作成する際、画面が大きいほどエミュレータは遅くなることを覚えておいてください。可能であれば小さい画面を選んでください。

GenymotionにGoogleサービス（AppStoreなど）をインストールするには、以下画像の赤で示したボタンをクリックする必要があります：

![](<../../images/image (277).png>)

また、**GenymotionのAndroid VMの設定**で**Bridge Network mode**を選択できる点に注意してください（これは、ツールを持つ別のVMからAndroid VMに接続する場合に有用です）。

#### Use a physical device

デバッグオプションを有効にする必要があり、可能であれば**root**しておくと良いでしょう：

1. **Settings**.
2. (Android 8.0以降) **System**を選択。
3. **About phone**を選択。
4. **Build number**を7回押す。
5. 戻ると**Developer options**が表示されます。

> アプリをインストールしたら、まずそれを実行して何をするのか、どのように動作するのかを調査し、慣れてください。\
> 初期のdynamic analysisは MobSF dynamic analysis + pidcat を使って行うことを推奨します。こうすることで、アプリがどのように動作するかを学びつつ、後で確認できる多くの興味深いデータを MobSF がキャプチャします。

### Unintended Data Leakage

**Logging**

開発者は**デバッグ情報**を公開しないよう注意する必要があります。これは機密データのleakにつながる可能性があります。アプリケーションのログを監視して機密情報を特定・保護するために、[**pidcat**](https://github.com/JakeWharton/pidcat) や `adb logcat` の使用が推奨されます。**Pidcat**は使いやすさと可読性の面で好まれます。

> [!WARNING]
> Android 4.0以降のバージョンでは、**アプリは自分自身のログにしかアクセスできません**。したがってアプリは他のアプリのログにはアクセスできません。\
> それでも、機密情報をログに出力しないことが推奨されます。

**Copy/Paste Buffer Caching**

Androidの**クリップボードベースの**フレームワークはアプリ間でのコピー＆ペースト機能を提供しますが、**他のアプリ**がクリップボードにアクセスできるため、機密データが公開されるリスクがあります。クレジットカード情報のような機密箇所については、コピー／ペースト機能を無効にすることが重要です。

**Crash Logs**

アプリが**クラッシュ**してログを保存する場合、これらのログは特にアプリがリバースできない場合に攻撃者に役立つことがあります。このリスクを緩和するため、クラッシュ時にログを記録しないようにし、もしログをネットワーク経由で送信する必要がある場合は必ずSSLチャネルで送信してください。

pentesterとして、**これらのログを確認してみてください**。

**Analytics Data Sent To 3rd Parties**

多くのアプリは Google Adsense のようなサービスを統合しており、開発者の実装ミスにより機密データを第三者に送信してしまうことがあります。潜在的なデータ漏洩を特定するには、アプリケーションのトラフィックをインターセプトして第三者に送られている機密情報がないか確認することが推奨されます。

### SQLite DBs

ほとんどのアプリケーションは情報を保存するために**内部SQLiteデータベース**を使用します。ペンテスト中は作成された**データベース**、**テーブル名**や**カラム名**、および保存されている全ての**データ**を確認してください。ここで機密情報を見つけることがあり、それは脆弱性になります。\
データベースは通常 `/data/data/the.package.name/databases` にあります（例：`/data/data/com.mwr.example.sieve/databases`）。

データベースが機密情報を保存していて**encrypted**されていても、もしアプリケーション内で**password**を見つけられるなら、それは依然として**vulnerability**です。

`.tables` を使ってテーブルを列挙し、`.schema <table_name>` を使ってテーブルのカラムを列挙してください。

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** はAndroidアプリの役割を引き受け、他のアプリとやり取りすることを可能にします。インストールされたアプリができることは何でも行うことができ、AndroidのInter-Process Communication (IPC) メカニズムを利用し、基盤となるOSと相互作用できます。.\
Drozerは、exported activities、exported services、Content Providersを**exploit**するのに有用なツールです。これは以下のセクションで学びます。

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
また、Activityのコードは**`onCreate`**メソッドから始まることを覚えておいてください。

**Authorisation bypass**

Activityがexportedになっている場合、外部アプリからその画面を呼び出すことができます。したがって、**sensitive information**を含むActivityが**exported**されている場合、認証メカニズムを**bypass**してそれにアクセスできてしまう可能性があります。

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

adbからexported activityを起動することもできます：

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> authorisation bypass が常に脆弱性であるとは限りません。バイパスの動作や公開される情報によって判断されます。

**Sensitive information leakage**

**Activities can also return results**. エクスポートされ保護されていない activity が **`setResult`** メソッドを呼び出して **機密情報を返す** 場合、sensitive information leakage が発生します。

#### Tapjacking

Tapjacking が防止されていない場合、エクスポートされた activity を悪用して **ユーザに予期しない操作を行わせる** ことができます。詳細は[**what is Tapjacking follow the link**](#tapjacking)。

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers は基本的にデータを共有するために使われます。アプリに利用可能な content providers がある場合、そこから**機密情報を抽出**できる可能性があります。脆弱である可能性があるため、可能な **SQL injections** や **Path Traversals** のテストも重要です。

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Service の処理は `onStartCommand` メソッドで開始されることを覚えておいてください。

Service は基本的に**データを受け取り**、それを**処理**し、（場合によっては）**レスポンスを返す**ものです。したがって、アプリが何らかの services をエクスポートしている場合は、その動作を理解するために**コードを確認**し、機密情報の抽出や認証回避などを目的に**動的にテスト**するべきです。\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Broadcast Receiver の処理は `onReceive` メソッドで開始されることを覚えておいてください。

Broadcast receiver は特定の種類のメッセージを待ち受けます。受信したメッセージの処理方法によっては脆弱になる可能性があります。\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

deep links は手動で探すこともできます。MobSF のようなツールや [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py) のようなスクリプトを使ってください。\
宣言された **scheme** は **adb** や **browser** を使って **open** できます:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_注意：**パッケージ名を省略すると**、モバイルはそのリンクを開くアプリを自動的に起動します._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**実行されるコード**

アプリ内で実行される**コードを特定するために**、deeplink によって呼び出される activity に移動し、関数 **`onNewIntent`** を検索してください。

![](<../../images/image (436) (1) (1) (1).png>)

**機密情報**

deep link を見つけたら、毎回**URLパラメータ経由でパスワードなどの機密データを受け取っていないか**確認してください。そうしないと、他のアプリが**deep link を偽装してそのデータを盗む**可能性があります！

**Parameters in path**

URL のパス内でパラメータを使用している deep link がないか**必ず確認してください**。例えば `https://api.example.com/v1/users/{username}` のような場合、`example://app/users?username=../../unwanted-endpoint%3fparam=value` のようにパストラバーサルを強制できる可能性があります。\
アプリ内で正しいエンドポイントを見つけられれば、パスの一部がドメイン名として使われている場合の **Open Redirect**、CSRF トークンなしでユーザ詳細を変更できる場合の **account takeover**（脆弱なエンドポイントが適切なメソッドを使っている場合）など、さまざまな脆弱性を引き起こせます。詳細は [こちら](http://dphoeniixx.com/2020/12/13-2/) を参照してください。

**More examples**

[interesting bug bounty report](https://hackerone.com/reports/855618)（リンクに関する報告、_/.well-known/assetlinks.json_）。

### トランスポート層の検査と検証の失敗

- **Certificates are not always inspected properly** by Android applications. 多くのアプリケーションは警告を無視して自己署名証明書を受け入れたり、場合によっては HTTP 接続に戻したりすることがよくあります。
- **Negotiations during the SSL/TLS handshake are sometimes weak**, insecure な cipher suite を使用していることがあります。この脆弱性は接続を man-in-the-middle (MITM) 攻撃に対して脆弱にし、攻撃者がデータを復号できるようにします。
- **Leakage of private information** は、アプリが一部の認証を安全なチャネルで行いながら、その他のやり取りで非暗号化チャネルを使う場合に発生するリスクです。この方法では、セッション cookie やユーザ情報などの機密データが悪意のある第三者に傍受される可能性から保護されません。

#### 証明書検証

ここでは **certificate verification** に焦点を当てます。サーバーの証明書の整合性を検証することはセキュリティ強化のために不可欠です。不適切な TLS 設定や暗号化されていないチャネルでの機密データ送信は重大なリスクを招くため、サーバー証明書の検証と脆弱性への対応手順については [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) を参照してください。

#### SSL Pinning

SSL Pinning は、アプリがサーバーの証明書をアプリ内に格納された既知のコピーと照合するセキュリティ対策です。これは MITM 攻撃を防ぐために重要な手法であり、機密情報を扱うアプリケーションには SSL Pinning の実装が強く推奨されます。

#### トラフィック検査

HTTP トラフィックを検査するには、プロキシツールの証明書（例: Burp）を**インストールする必要があります**。この証明書をインストールしないと、暗号化されたトラフィックがプロキシで見えないことがあります。カスタム CA 証明書のインストール方法については [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine) を参照してください。

API Level 24 以降をターゲットにするアプリケーションは、プロキシの CA 証明書を受け入れるように Network Security Config の変更が必要です。暗号化トラフィックを検査するためにこの手順は重要です。Network Security Config の変更方法については [**refer to this tutorial**](make-apk-accept-ca-certificate.md) を参照してください。

もし **Flutter** を使用している場合は、[**this page**](flutter.md) の指示に従ってください。単に証明書をストアに追加するだけでは動作しないことがあり、Flutter は独自の有効な CA リストを使用しているためです。

#### Static detection of SSL/TLS pinning

ランタイムでのバイパスを試す前に、まず APK 内で pinning がどこに強制されているかを素早くマップしてください。静的解析で場所を特定することで、フックやパッチの計画が立てやすくなり、正しいコードパスに集中できます。

Tool: SSLPinDetect
- Open-source static-analysis utility that decompiles the APK to Smali (via apktool) and scans for curated regex patterns of SSL/TLS pinning implementations.
- Reports exact file path, line number, and a code snippet for each match.
- Covers common frameworks and custom code paths: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
使い方
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
パターンルールの例 (JSON)
signaturesを使用または拡張して、独自/カスタムpinningスタイルを検出します。独自のJSONを読み込んで、大規模にスキャンできます。
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes and tips
- 大規模アプリの高速スキャンは multi-threading と memory-mapped I/O を利用；pre-compiled regex がオーバーヘッド／false positives を減らします。
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- 次にトリアージすべき典型的な検出対象：
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Declarative pins in res/xml network security config and manifest references
- 一致した箇所を利用して、Frida hooks、static patches、または config reviews を dynamic testing の前に計画します。



#### SSL Pinning のバイパス

SSL Pinning が実装されている場合、HTTPS トラフィックを調査するためにそれをバイパスする必要があります。これにはいくつかの方法があります：

- Automatically **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). この方法の最大の利点は、SSL Pinning をバイパスするために root が不要なことですが、アプリを削除して新しいものを再インストールする必要があり、常に動作するとは限りません。
- **Frida**（下で説明）を使ってこの保護をバイパスすることもできます。Burp+Frida+Genymotion の使い方ガイドはこちら: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- [**objection**](frida-tutorial/objection-tutorial.md) を使って **自動的に SSL Pinning をバイパス** することもできます:**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- **MobSF dynamic analysis** を使って **自動的に SSL Pinning をバイパス** することも試せます（下で説明）
- まだキャプチャできていないトラフィックがあると思う場合は、iptables を使ってトラフィックを burp に転送してみてください。この記事を参照: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### 一般的な Web 脆弱性の検索

アプリケーション内の一般的な Web 脆弱性も検索することが重要です。これらの脆弱性の特定と緩和に関する詳細はこの要約の範囲外ですが、他の資料で広く扱われています。

### Frida

[Frida](https://www.frida.re) は開発者、リバースエンジニア、セキュリティ研究者向けの dynamic instrumentation toolkit です。\
**実行中のアプリケーションにアクセスして、実行時にメソッドを hook し挙動を変えたり、値を変更・抽出したり、別のコードを実行したりできます...**\
Android アプリを pentest したいなら、Frida の使い方を知っておく必要があります。

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Frida 用の操作用 "GUI" 例: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection は Frida の自動化に便利です: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Awesome な Frida スクリプトはこちらにあります: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) に示されているように、linjector ツールを使って Frida をロードし、anti-debugging / anti-frida 機構を回避することを試みてください。（tool [linjector](https://github.com/erfur/linjector-rs)）

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **メモリのダンプ - Fridump**

アプリがパスワードや mnemonic のように格納すべきでない機密情報をメモリ内に保存していないか確認してください。

[**Fridump3**](https://github.com/rootbsd/fridump3) を使うと、次のようにアプリのメモリをダンプできます：
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
これはメモリを ./dump フォルダにダンプし、そこで次のように grep できます:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Keystore内の機密データ**

AndroidではKeystoreが機密データを保存する最適な場所ですが、十分な権限があれば**アクセス可能**です。アプリはここに**sensitive data in clear text**を保存する傾向があるため、pentestsはroot userとして確認するべきです。物理的にデバイスにアクセスできる者がこのデータを盗むことができる可能性があります。

アプリがKeystoreにデータを保存している場合でも、そのデータは暗号化されているべきです。

Keystore内のデータにアクセスするには、次のFridaスクリプトを使用できます: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

以下の Frida script を使用すると、Android applications が **特定の機密領域を保護するために** 実行している **bypass fingerprint authentication** を回避できる場合があります:
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **バックグラウンド画像**

アプリをバックグラウンドにすると、Android は **アプリのスナップショット** を保存します。アプリがフォアグラウンドに復帰したとき、アプリ本体より先にその画像を読み込むことで、アプリの起動が速く見えるようになります。

しかし、この **アプリのスナップショット** に **機密情報** が含まれていると、スナップショットにアクセスできる人物が **その情報を盗む可能性** があります（アクセスには root が必要である点に注意）。

スナップショットは通常、次の場所に保存されます: **`/data/system_ce/0/snapshots`**

Android は **FLAG_SECURE を設定することでスクリーンショットの取得を防ぐ** レイアウトパラメータを提供します。このフラグを使用すると、ウィンドウの内容がセキュアとして扱われ、スクリーンショットに表示されたり、非セキュアなディスプレイで表示されるのを防ぎます。
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

このツールはダイナミック解析中に複数のツールを管理するのに役立ちます: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

開発者はしばしばこれらのIntentsを処理し、`startActivity(...)`や`sendBroadcast(...)`などのメソッドに渡すプロキシコンポーネント（activities、services、broadcast receivers）を作成しますが、これは危険を伴う場合があります。

この危険は、攻撃者がこれらのIntentsを誤誘導してnon-exportedなアプリコンポーネントをトリガーしたり、機密性の高いcontent providersにアクセスすることを許してしまう点にあります。代表的な例として、`WebView`が`Intent.parseUri(...)`でURLを`Intent`オブジェクトに変換し、それを実行することで、悪意あるIntent注入が発生する可能性があります。

### Essential Takeaways

- **Intent Injection** is similar to web's Open Redirect issue.
- エクスプロイトは`Intent`オブジェクトをextrasとして渡し、それがリダイレクトされて安全でない操作を実行させる方法を含みます。
- 攻撃者にnon-exportedなコンポーネントやcontent providersを露出させる可能性があります。
- `WebView`のURLから`Intent`への変換は意図しない動作を引き起こす可能性があります。

### Android Client Side Injections and others

おそらくWebでこの種の脆弱性について知っているでしょう。Androidアプリケーションでは特に以下の脆弱性に注意する必要があります:

- **SQL Injection:** 動的クエリやContent-Providersを扱う際は、パラメータ化されたクエリを使用していることを確認してください。
- **JavaScript Injection (XSS):** すべてのWebViewsでJavaScriptやPluginのサポートが無効になっていることを確認してください（デフォルトでは無効）。 [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViewsはファイルシステムへのアクセスを無効にしておくべきです（デフォルトでは有効） - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: 多くの場合、Androidアプリがセッションを終了してもクッキーが取り消されない、あるいはディスクに保存されることがあります。
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Static analysis**

![](<../../images/image (866).png>)

**Vulnerability assessment of the application** を使いやすいWebベースのフロントエンドで実行します。動的解析も行うことができます（ただし環境の準備が必要です）。
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Assisted Dynamic analysis with MobSF

**MobSF** can also be very helpful for **dynamic analysis** in **Android**, but in that case you will need to install MobSF and **genymotion** in your host (a VM or Docker won't work). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
The **MobSF dynamic analyser** can:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). All of this is done automatically except for the screenshots, you need to press when you want a screenshot or you need to press "**Exported Activity Tester**" to obtain screenshots of all the exported activities.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: It will print all the loaded classes
- **Capture Strings**: It will print all the capture strings while using the application (super noisy)
- **Capture String Comparisons**: Could be very useful. It will **show the 2 strings being compared** and if the result was True or False.
- **Enumerate Class Methods**: Put the class name (like "java.io.File") and it will print all the methods of the class.
- **Search Class Pattern**: Search classes by pattern
- **Trace Class Methods**: **Trace** a **whole class** (see inputs and outputs of all methods of th class). Remember that by default MobSF traces several interesting Android Api methods.

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf also brings you a shell with some **adb** commands, **MobSF commands**, and common **shell** **commands** at the bottom of the dynamic analysis page. Some interesting commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP tools**

HTTPトラフィックをキャプチャすると、下部の"**HTTP(S) Traffic**"ボタンでキャプチャされたトラフィックの見にくい表示を確認でき、緑の"**Start HTTPTools**"ボタンではより見やすい表示が得られます。後者から、キャプチャしたリクエストをBurpやOwasp ZAPなどの**プロキシ**に**送信**できます。\
その方法は、_power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> "**Send to Fuzzer**" を押す --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080))。

MobSFでdynamic analysisを終えたら、"**Start Web API Fuzzer**"を押してhttpリクエストを**fuzz**し、脆弱性を探すことができます。

> [!TIP]
> MobSFでdynamic analysisを実行した後、プロキシ設定が誤って構成され、GUIから修正できない場合があります。次のコマンドでプロキシ設定を修正できます:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

You can get the tool from [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
このツールは**Hooks**を使用して、dynamic analysis中に**アプリケーション内で何が起きているか**を知らせてくれます。

### [Yaazhini](https://www.vegabird.com/yaazhini/)

GUIでstatic analysisを行うのに**優れたツール**です。

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

このツールは、source codeまたはpackaged APKsのいずれかを対象に、複数のsecurity-relatedなAndroidアプリの脆弱性を検出するよう設計されています。ツールは"Proof-of-Concept"としてデプロイ可能なAPKやADBコマンドも生成でき、発見した脆弱性のいくつか（Exposed activities、intents、tapjacking...）を悪用することが可能です。Drozerと同様に、テストデバイスをrootする必要はありません。
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- 抽出されたすべてのファイルを表示して参照しやすくする
- APKファイルを自動的にJavaおよびSmali形式にデコンパイルする
- AndroidManifest.xmlを解析し、一般的な脆弱性や挙動を検出する
- 一般的な脆弱性や挙動を対象とした静的ソースコード解析
- デバイス情報
- その他
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPERはWindows、MacOS X、Linuxで使用できるコマンドラインアプリケーションで、_.apk_ファイルを解析して脆弱性を検出します。APKsを解凍し、一連のルールを適用してそれらの脆弱性を見つけます。

すべてのルールは`rules.json`ファイルに集約されており、各企業やテスターは必要に応じて独自のルールを作成できます。

最新のバイナリは[download page](https://superanalyzer.rocks/download.html)からダウンロードしてください。
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAnは、モバイルアプリケーションに対して[static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis)を行う開発者、bugbounty hunters、ethical hackersを支援する**crossplatform**ツールです。

コンセプトは、モバイルアプリケーションのファイル（.apk または .ipa ファイル）を StaCoAn アプリケーションにドラッグ＆ドロップすると、視覚的で持ち運び可能なレポートを生成するというものです。設定や wordlists を調整してカスタマイズされた体験を得ることができます。

ダウンロード[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework は Android 脆弱性解析システムで、developers や hackers が Android applications の潜在的な security vulnerabilities を発見するのを支援します。\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** は、Android アプリケーションによって行われる潜在的な悪意ある振る舞いを検出し、ユーザーに警告することを主目的としたツールです。

検出は、アプリケーションの Dalvik bytecode を **Smali** として表現したものの **static analysis** を、[`androguard`](https://github.com/androguard/androguard) ライブラリで実行することで行われます。

このツールは、**common behavior of "bad" applications** のような次の挙動を検出します: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. モバイルアプリケーションの一般的なリバースエンジニアリングおよび解析ツールをまとめたツールで、OWASPのモバイルセキュリティ脅威に対するアプリのテストを支援します。目的は、モバイルアプリ開発者やセキュリティ担当者にとってこの作業をより簡単で扱いやすくすることです。

できること:

- さまざまなツールを使って Java および Smali コードを抽出する
- 以下を使用して APK を解析する: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- 正規表現を使用して APK から機密情報を抽出する
- Manifest を解析する
- 見つかったドメインを以下で解析する: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) および [whatweb](https://github.com/urbanadventurer/WhatWeb)
- [apk-deguard.com] を使って APK の難読化を解除する

### Koodous

malware の検出に便利: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

使用するサービスや設定によって、コードを難読化した場合でも秘密情報が難読化される場合とされない場合があります。

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** は Java コードを縮小、最適化、難読化するオープンソースのコマンドラインツールです。バイトコードの最適化や未使用命令の検出と削除が可能です。ProGuard はフリーソフトウェアで、GNU General Public License, version 2 の下で配布されています。

ProGuard は Android SDK の一部として配布され、アプリをリリースモードでビルドするときに実行されます。

### [DexGuard](https://www.guardsquare.com/dexguard)

apk の難読化解除に関するステップバイステップのガイドは [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html) を参照してください。

(そのガイドによると) 最後に確認したときの DexGuard の動作モードは次の通りでした:

- リソースを InputStream として読み込む
- FilterInputStream を継承したクラスに結果を渡して復号する
- リバースエンジニアの時間を少し浪費するために無駄な難読化を行う
- 復号した結果を ZipInputStream に渡して DEX ファイルを取り出す
- 最後に得られた DEX を `loadDex` メソッドを使って Resource としてロードする

### [DeGuard](http://apk-deguard.com)

**DeGuard は Android の難読化ツールによって行われた難読化プロセスを逆にします。これによりコードの検査やライブラリの特定など、多くのセキュリティ解析が可能になります。**

難読化された APK を彼らのプラットフォームにアップロードできます。

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

これは android アプリの潜在的なセキュリティ脆弱性を見つけ、android アプリのコードを deobfuscate するための LLM ツールです。Google's Gemini public API を使用します。

### [Simplify](https://github.com/CalebFenton/simplify)

汎用の android deobfuscator です。Simplify はアプリをほぼ実行してその挙動を理解し、その後コードを最適化して同一の挙動を保ちつつ人間にとって理解しやすくしようとします。各最適化タイプは単純かつ汎用的なので、どのような特定の難読化手法が使われているかは問題になりません。

### [APKiD](https://github.com/rednaga/APKiD)

APKiD は APK がどのように作られたかの情報を提供します。多くのコンパイラ、パッカー、オブフuscator（難読化ツール）やその他の怪しいものを識別します。Android における [_PEiD_](https://www.aldeid.com/wiki/PEiD) のような存在です。

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b は ubuntu-mate ベースの Android セキュリティ仮想マシンで、最新のフレームワーク、チュートリアル、ラボをリバースエンジニアリングやマルウェア解析を行う各種セキュリティ研究者や技術者から収集して含んでいます。

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) — 素晴らしいリソース集です
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) — Android クイックコース
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)

## Yet to try

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
