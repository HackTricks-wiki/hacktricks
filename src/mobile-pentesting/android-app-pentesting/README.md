# Android Applications Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Androidアプリケーションの基本

このページをまず読むことを強くお勧めします。**Androidのセキュリティに関連する最も重要な部分と、Androidアプリケーション内で最も危険なコンポーネント**について知ることができます：


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

これは、androidデバイス（エミュレートされたものまたは実機）に接続するための主要なツールです。\
**ADB**を使うと、コンピュータから**USB**または**Network**経由でデバイスを制御できます。このユーティリティは、双方向のファイルの**コピー**、アプリの**インストール**と**アンインストール**、シェルコマンドの**実行**、データの**バックアップ**、ログの**読み取り**などの機能を提供します。

次の[**ADB Commands**](adb-commands.md)の一覧を参照してadbの使い方を学んでください。

## Smali

場合によっては、**隠された情報**（難読化されたパスワードやフラグなど）にアクセスするために**アプリケーションのコードを変更する**ことが有用です。そこで、apkを逆コンパイルしてコードを修正し、再コンパイルすることが有効な場合があります。\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md)。これは、これから紹介する動的解析中の複数のテストの**代替手段として非常に有用**です。したがって、**常にこの可能性を念頭に置いてください**。

## その他の興味深いトリック

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **APKのダウンロード**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- デバイスからAPKを抽出:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- すべての splits と base apks を [APKEditor](https://github.com/REAndroid/APKEditor) でマージする:
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## ケーススタディ & 脆弱性


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## 静的解析

まず、APK を解析する際は decompiler を使って **Java コードを確認する**べきです。\
Please, [**read here to find information about different available decompilers**](apk-decompilers.md).

### 興味深い情報を探す

APK の **strings** を見るだけで、**passwords**、**URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep))、**api** keys、**encryption**、**bluetooth uuids**、**tokens** など興味深いものを探せます。コード実行の **backdoors** や認証 backdoors（アプリにハードコードされた管理者資格情報）も確認してください。

**Firebase**

**Firebase** の URL に特に注意し、設定が不適切でないか確認してください。[More information about whats is FIrebase and how to exploit it here.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### アプリケーションの基本的理解 - Manifest.xml, strings.xml

アプリケーションの _Manifest.xml_ と **_strings.xml_** を調査することで、潜在的なセキュリティ脆弱性を明らかにできることがあります。これらのファイルは decompiler を使うか、APK の拡張子を .zip に変更して展開することで参照できます。

**Manifest.xml** から特定できる **脆弱性** には以下が含まれます:

- **Debuggable Applications**: _Manifest.xml_ で `debuggable="true"` に設定されたアプリは、接続を許可してしまい、悪用のリスクがあります。デバッグ可能なアプリをデバイス上で検出して悪用する方法については、該当チュートリアルを参照してください。
- **Backup Settings**: 敏感な情報を扱うアプリでは、`android:allowBackup="false"` を明示的に設定しておくべきです。特に USB debugging が有効な場合、adb 経由での不正なデータバックアップを防ぐためです。
- **Network Security**: `android:networkSecurityConfig="@xml/network_security_config"` のようなカスタム network security 設定（`res/xml/`）は、certificate pinning や HTTP トラフィック設定などのセキュリティ詳細を指定できます。例として特定ドメインで HTTP トラフィックを許可しているケースなどがあります。
- **Exported Activities and Services**: マニフェストで exported な activities や services を特定すると、悪用されうるコンポーネントが浮き彫りになります。動的テストでこれらをさらに解析し、どのように悪用できるかを確認します。
- **Content Providers and FileProviders**: 公開されている content provider はデータの不正アクセスや改竄を許す可能性があります。FileProviders の設定も注意深く確認してください。
- **Broadcast Receivers and URL Schemes**: これらのコンポーネントは悪用される可能性があり、特に URL schemes の扱い方が入力に対する脆弱性を生まないかを確認する必要があります。
- **SDK Versions**: `minSdkVersion`、`targetSDKVersion`、`maxSdkVersion` はサポートしている Android バージョンを示します。古い脆弱な Android バージョンをサポートしないことが重要です。

**strings.xml** ファイルからは、API keys、カスタムスキーマ、その他開発者のメモなどの機密情報が見つかることがあり、これらのリソースは注意深く確認する必要があります。

### Tapjacking

**Tapjacking** は、**malicious** な **application** を起動して **victim application の上に重ねて配置する**攻撃です。victim app を視覚的に覆い隠した状態で、UI をユーザを騙すように設計し、ユーザの操作を victim app に渡すようにします。\
結果として、ユーザは実際には victim app 上で操作を行っていることに気づかされないまま操作させられてしまいます。

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

`launchMode` が **`singleTask` で `taskAffinity` が定義されていない** activity は Task Hijacking の脆弱性があります。つまり、悪意ある **application** をインストールして、そのアプリが本来のアプリより先に起動されると、**本来のアプリのタスクをハイジャック**してしまう可能性があり（ユーザは本物のアプリを使っているつもりで悪意あるアプリを操作している）、危険です。

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Insecure data storage

**Internal Storage**

Android では、**internal** ストレージに保存されたファイルは、それを作成した **app** のみがアクセスできるように設計されています。このセキュリティ対策は OS によって強制されており、多くのアプリのセキュリティ要件には十分です。しかし、開発者が `MODE_WORLD_READABLE` や `MODE_WORLD_WRITABLE` のようなモードを使用して複数のアプリ間でファイルを共有する場合があります。これらのモードは他のアプリ、場合によっては悪意あるアプリからのアクセスを制限しません。

1. **Static Analysis:**
- `MODE_WORLD_READABLE` と `MODE_WORLD_WRITABLE` の使用がないかを慎重に確認してください。これらのモードはファイルを意図しない、または不正なアクセスに晒す可能性があります。
2. **Dynamic Analysis:**
- アプリが作成するファイルの権限を確認してください。特に、ファイルが worldwide に読み取り可能または書き込み可能に設定されていないかをチェックします。これが有効だと、デバイスにインストールされている任意のアプリがこれらのファイルを読み書きできるため、重大なセキュリティリスクになります。

**External Storage**

SD カードなどの **external storage** 上のファイルを扱う際は、以下の点に注意してください:

1. **Accessibility**:
- external storage 上のファイルは一般的にグローバルに読み書き可能です。つまり、任意のアプリやユーザがアクセスできます。
2. **Security Concerns**:
- アクセスが容易なため、機密情報を external storage に保存しないことが推奨されます。
- external storage は取り外し可能であり、任意のアプリからアクセスされる可能性があるため、安全性が低くなります。
3. **Handling Data from External Storage**:
- external storage から取得するデータは常に入力検証を行ってください。これは、信頼できないソースからのデータであるため非常に重要です。
- external storage に実行ファイルや class ファイルを保存して動的にロードすることは強く非推奨です。
- もしアプリが external storage から実行ファイルを取得して動的にロードする必要がある場合、それらのファイルは署名され、暗号的に検証されてからロードするようにしてください。これはアプリのセキュリティ整合性を保つために不可欠です。

External storage は /storage/emulated/0 , /sdcard , /mnt/sdcard でアクセスできます

> [!TIP]
> Android 4.4 (**API 17**) 以降、SD card はディレクトリ構造が変更され、アプリからアクセスできるのはそのアプリ専用のディレクトリに限定されるようになりました。これにより、悪意あるアプリが他のアプリのファイルに対して読み取りや書き込みアクセスを得ることを防ぎます。

**Sensitive data stored in clear-text**

- **Shared preferences**: Android は各アプリが `/data/data/<packagename>/shared_prefs/` に簡単に xml ファイルを保存できるようにしており、そのフォルダ内に平文の機密情報が見つかることがあります。
- **Databases**: Android は各アプリが `/data/data/<packagename>/databases/` に簡単に sqlite データベースを保存できるようにしており、そのフォルダ内に平文の機密情報が見つかることがあります。

### Broken TLS

**Accept All Certificates**

なぜか開発者がすべての証明書を受け入れてしまうことがあります。例えば hostname が一致しない場合でも以下のようなコード行で受け入れてしまうことがあります:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### 脆弱な暗号

**Poor Key Management Processes**

一部の開発者は機密データをローカルストレージに保存し、コード内にハードコード／予測可能なキーで暗号化します。これはリバースで攻撃者が機密情報を抽出できる可能性があるため避けるべきです。

**Use of Insecure and/or Deprecated Algorithms**

開発者は認証チェック、データの保存や送信に**deprecated algorithms**を使うべきではありません。これらのアルゴリズムには RC4, MD4, MD5, SHA1 などがあります。例えばパスワード保存に**hashes**を使う場合は、ソルト付きでブルートフォース耐性のあるハッシュを使用するべきです。

### Other checks

- It's recommended to **obfuscate the APK** to difficult the reverse engineer labour to attackers.
- If the app is sensitive (like bank apps), it should perform it's **own checks to see if the mobile is rooted** and act in consequence.
- If the app is sensitive (like bank apps), it should check if an **emulator** is being used.
- If the app is sensitive (like bank apps), it should **check it's own integrity before executing** it to check if it was modified.
- Use [**APKiD**](https://github.com/rednaga/APKiD) to check which compiler/packer/obfuscator was used to build the APK

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

The tool [**mariana-trench**](https://github.com/facebook/mariana-trench) is capable of finding **vulnerabilities** by **scanning** the **code** of the application. This tool contains a series of **known sources** (that indicates to the tool the **places** where the **input** is **controlled by the user**), **sinks** (which indicates to the tool **dangerous** **places** where malicious user input could cause damages) and **rules**. These rules indicates the **combination** of **sources-sinks** that indicates a vulnerability.

With this knowledge, **mariana-trench will review the code and find possible vulnerabilities on it**.

### Secrets leaked

An application may contain secrets (API keys, passwords, hidden urls, subdomains...) inside of it that you might be able to discover. You could us a tool such as [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> First of all, you need an environment where you can install the application and all the environment (Burp CA cert, Drozer and Frida mainly). Therefore, a rooted device (emulated or not) is extremely recommended.

### Online Dynamic analysis

You can create a **free account** in: [https://appetize.io/](https://appetize.io). This platform allows you to **upload** and **execute** APKs, so it is useful to see how an apk is behaving.

You can even **see the logs of your application** in the web and connect through **adb**.

![](<../../images/image (831).png>)

Thanks to the ADB connection you can use **Drozer** and **Frida** inside the emulators.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (You can create **x86** and **arm** devices, and according to [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** versions **support ARM libraries** without needing an slow arm emulator).
- Learn to set it up in this page:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, you need to create an account. _It's recommend to **download** the version **WITH**_ _**VirtualBox** to avoid potential errors._)
- [**Nox**](https://es.bignox.com) (Free, but it doesn't support Frida or Drozer).

> [!TIP]
> When creating a new emulator on any platform remember that the bigger the screen is, the slower the emulator will run. So select small screens if possible.

To **install google services** (like AppStore) in Genymotion you need to click on the red marked button of the following image:

![](<../../images/image (277).png>)

Also, notice that in the **configuration of the Android VM in Genymotion** you can select **Bridge Network mode** (this will be useful if you will be connecting to the Android VM from a different VM with the tools).

#### Use a physical device

You need to activate the **debugging** options and it will be cool if you can **root** it:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Once you have installed the application, the first thing you should do is to try it and investigate what does it do, how does it work and get comfortable with it.\
> I will suggest to **perform this initial dynamic analysis using MobSF dynamic analysis + pidcat**, so we will be able to **learn how the application works** while MobSF **captures** a lot of **interesting** **data** you can review later on.

### Unintended Data Leakage

**Logging**

開発者は**debugging information**を公開しないよう注意すべきです。これは機密データのleakにつながる可能性があります。アプリケーションログを監視して機密情報を特定・保護するために [**pidcat**](https://github.com/JakeWharton/pidcat) や `adb logcat` を使うことを推奨します。**Pidcat**は使いやすさと可読性の面で好まれます。

> [!WARNING]
> Note that from **later newer than Android 4.0**, **applications are only able to access their own logs**. So applications cannot access other apps logs.\
> Anyway, it's still recommended to **not log sensitive information**.

**Copy/Paste Buffer Caching**

Androidの**clipboard-based**フレームワークはアプリ間のコピー＆ペーストを可能にしますが、**他のアプリ**がクリップボードにアクセスできるため、機密データが露出するリスクがあります。クレジットカード情報などの機密セクションではコピー／ペースト機能を無効にすることが重要です。

**Crash Logs**

アプリが**クラッシュ**してログを保存する場合、これらのログはリバースが困難な場合でも攻撃者に手がかりを与えることがあります。このリスクを軽減するため、クラッシュ時に不要なログを残さない、またはログをネットワーク送信する場合はSSL経由で送るようにしてください。

ペンテスターとして、**これらのログを確認することを試みてください**。

**Analytics Data Sent To 3rd Parties**

多くのアプリは Google Adsense のようなサービスを統合しており、開発者の誤実装により機密データが誤ってthird-partyにleakすることがあります。潜在的なデータ漏洩を特定するには、アプリのトラフィックをインターセプトして、サードパーティに送信される機密情報がないか確認することを勧めます。

### SQLite DBs

ほとんどのアプリは情報を保存するために**internal SQLite databases**を使用します。ペンテスト中は作成された**databases**、**tables**や**columns**の名前、保存されている**data**を確認してください。機密情報が見つかる可能性があります（これがvulnerabilityとなります）。\
データベースは通常 `/data/data/the.package.name/databases` に存在します（例: `/data/data/com.mwr.example.sieve/databases`）。

データベースが機密情報を保存していて**encrypted**されていても、アプリ内でその**password**を**find**できる場合は、依然として**vulnerability**です。

テーブルの一覧は `.tables`、各テーブルのカラムは `.schema <table_name>` で列挙します。

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer is s useful tool to **exploit exported activities, exported services and Content Providers** as you will learn in the following sections.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Also remember that the code of an activity starts in the **`onCreate`** method.

**Authorisation bypass**

When an Activity is exported you can invoke its screen from an external app. Therefore, if an activity with **sensitive information** is **exported** you could **bypass** the **authentication** mechanisms **to access it.**

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

You can also start an exported activity from adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**注意**: MobSF は activity の `android:launchMode` に _**singleTask/singleInstance**_ を使用していることを悪意あるものとして検出しますが、[これ](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750) によると、これは古いバージョン（API versions < 21）のみ危険なようです。

> [!TIP]
> 認可 bypass が必ずしも脆弱性になるとは限らない点に注意してください。bypass の仕組みや露出する情報によって判断されます。

**機密情報の leak**

**Activities は結果を返すこともあります**。exported かつ保護されていない activity が **`setResult`** メソッドを呼び出し **機密情報を返している** のを見つけた場合、機密情報の leak が発生します。

#### Tapjacking

Tapjacking が防止されていない場合、exported activity を悪用して **user に予期しない操作を実行させる** ことができます。詳細は [**Tapjacking とは（リンク参照）**](#tapjacking) を参照してください。

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Content Provider を再確認したい場合はこちらを読んでください。**](android-applications-basics.md#content-provider)\
Content providers は基本的にデータを**共有**するために使用されます。アプリに利用可能な content providers があれば、そこから**機密データを抽出**できる可能性があります。脆弱であることがあるため、**SQL injections** や **Path Traversals** のテストを行うことも重要です。

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Service を再確認したい場合はこちらを読んでください。**](android-applications-basics.md#services)\
Service の処理は `onStartCommand` メソッドで開始されることを忘れないでください。

Service は基本的にデータを**受け取り**、**処理**し、（する場合には）レスポンスを**返す**ものです。したがって、アプリがいくつかのサービスを export している場合は、何をしているのかを理解するために**コード**を**確認**し、機密情報の抽出や認証の bypass などを目的に**動的に**テストするべきです。\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Broadcast Receiver を再確認したい場合はこちらを読んでください。**](android-applications-basics.md#broadcast-receivers)\
Broadcast Receiver の処理は `onReceive` メソッドで開始されることを忘れないでください。

Broadcast receiver は特定の種類のメッセージを待機します。受け取ったメッセージの処理方法によっては脆弱になる可能性があります。\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

deep links は手動で探すこともできます。MobSF のようなツールや [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py) のようなスクリプトを使ってください。\
宣言された **scheme** は **adb** や **browser** を使って **open** できます：
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_**package name を省略**すると、モバイルはそのリンクを開くべきアプリを自動的に呼び出します._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**実行されるコード**

アプリで**実行されるコード**を見つけるには、deeplink によって呼び出される activity に移動し、関数 **`onNewIntent`** を検索してください。

![](<../../images/image (436) (1) (1) (1).png>)

**機密情報**

deep link を見つけたら毎回、**URL パラメータ経由でパスワードのような機密データを受け取っていないか**を確認してください。そうでないと、他のアプリがその deep link を **impersonate してデータを盗む**可能性があります！

パス内のパラメータ
You **must check also if any deep link is using a parameter inside the path** of the URL like: `https://api.example.com/v1/users/{username}` , in that case you can force a path traversal accessing something like: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Note that if you find the correct endpoints inside the application you may be able to cause a **Open Redirect** (if part of the path is used as domain name), **account takeover** (if you can modify users details without CSRF token and the vuln endpoint used the correct method) and any other vuln. More [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

リンク（_/.well-known/assetlinks.json_）に関する[興味深い bug bounty レポート](https://hackerone.com/reports/855618)。

### Transport Layer Inspection and Verification Failures

- **Certificates are not always inspected properly** by Android applications. 多くのアプリは警告を見落とし、自己署名証明書を受け入れたり、場合によっては HTTP 接続にフォールバックすることがあります。
- **Negotiations during the SSL/TLS handshake are sometimes weak**, insecure な cipher suites を使用していることがあります。この脆弱性により接続は man-in-the-middle (MITM) 攻撃に対して脆弱になり、攻撃者がデータを復号できる可能性があります。
- **Leakage of private information** は、アプリがセキュアなチャネルで認証を行った後に他のトランザクションで非セキュアなチャネルを使って通信する場合にリスクとなります。この手法では、セッションクッキーやユーザー情報などの機密データが悪意ある第三者によって傍受されるおそれがあります。

#### Certificate Verification

ここでは **certificate verification** に焦点を当てます。サーバー証明書の整合性を検証することはセキュリティ向上のために必須です。これは、不適切な TLS 構成や暗号化されていないチャネルでの機密データ送信が重大なリスクを引き起こすためです。サーバー証明書の検証手順や脆弱性への対処方法の詳細は、[**this resource**](https://manifestsecurity.com/android-application-security-part-10/) を参照してください。

#### SSL Pinning

SSL Pinning は、アプリがサーバー証明書をアプリ内に格納された既知のコピーと照合して検証するセキュリティ手法です。これは MITM 攻撃を防ぐために重要です。機密情報を扱うアプリケーションでは SSL Pinning の実装が強く推奨されます。

#### Traffic Inspection

HTTP トラフィックを検査するには、プロキシツールの証明書（例: Burp）を **インストールする必要があります**。この証明書をインストールしないと、暗号化されたトラフィックはプロキシ経由で見えないことがあります。カスタム CA 証明書のインストール方法は、[**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine) を参照してください。

API Level 24 以上をターゲットにするアプリは、プロキシの CA 証明書を受け入れるために Network Security Config を変更する必要があります。暗号化トラフィックを検査するための Network Security Config の変更手順は、[**refer to this tutorial**](make-apk-accept-ca-certificate.md) を参照してください。

もし **Flutter** を使用している場合は、[**this page**](flutter.md) の指示に従う必要があります。単に証明書をストアに追加するだけでは機能しません。Flutter は独自の有効な CA リストを持っているためです。

#### Static detection of SSL/TLS pinning

ランタイムでのバイパスを試みる前に、まず APK 内でどこに pinning が強制されているかを素早くマップしてください。静的検出は、フックやパッチの計画を立て、適切なコードパスに集中するのに役立ちます。

Tool: SSLPinDetect
- APK を Smali にデコンパイル（apktool 経由）して、SSL/TLS pinning 実装のためにキュレートされた正規表現パターンをスキャンするオープンソースの静的解析ユーティリティ。
- 各マッチについて、正確なファイルパス、行番号、コードスニペットを報告します。
- OkHttp CertificatePinner、カスタム javax.net.ssl.X509TrustManager.checkServerTrusted、SSLContext.init with custom TrustManagers/KeyManagers、Network Security Config XML pins などの一般的なフレームワークやカスタムコードパスをカバーします。

Install
- 前提条件: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
使い方
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
パターンルールの例 (JSON)

signatures を使用または拡張して proprietary/custom pinning styles を検出します。自分の JSON を読み込んで、大規模にスキャンできます。
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes and tips
- 大規模なアプリに対してはマルチスレッディングとメモリマップドI/Oで高速スキャンする；事前コンパイル済みのregexはオーバーヘッド／誤検知を減らす。
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- 次にトリアージすべき典型的な検出対象：
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Declarative pins in res/xml network security config and manifest references
- 一致した箇所を利用して、dynamic testing の前に Frida hooks、static patches、または設定レビューを計画する。



#### SSL Pinningの回避

SSL Pinning が実装されている場合、HTTPSトラフィックを調査するためにそれを回避する必要がある。これにはいくつかの方法がある：

- 自動的に **apk** を修正して **SSLPinning** を **bypass** するために [**apk-mitm**](https://github.com/shroudedcode/apk-mitm) を使う。 この方法の最大の利点は、SSLPinning を回避するのに root が不要なことだが、アプリを削除して再インストールする必要があり、常に動作するとは限らない。
- この保護を回避するために **Frida**（下で説明）を使うこともできる。Burp+Frida+Genymotion を使うガイドはこちら: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- [**objection**](frida-tutorial/objection-tutorial.md) を使って **自動的に SSL Pinning を回避** することも試せる**：** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- **MobSF dynamic analysis**（下で説明）を使って **自動的に SSL Pinning を回避** することも試せる。
- それでも捕捉できていないトラフィックがあると思う場合は、iptables を使ってトラフィックを burp に転送することを試してみる。こちらのブログを読むと良い: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### 一般的なWeb脆弱性の探索

アプリ内で一般的なWeb脆弱性を探すことも重要だ。これらの脆弱性の特定や緩和に関する詳細はこの要約の範囲を超えるが、他の資料で詳しく扱われている。

### Frida

[Frida](https://www.frida.re) は開発者、リバースエンジニア、セキュリティ研究者向けのダイナミックなインストルメンテーションツールキットだ。\
**実行中のアプリにアクセスして、ランタイムでメソッドにhookを仕込み、挙動や値を変更したり、値を抽出したり、別のコードを実行したりできる。**\
Androidアプリをpentestするなら Frida の使い方を知っておく必要がある。

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Some "GUI" for actions with Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- You can find some Awesome Frida scripts here: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Try to bypass anti-debugging / anti-frida mechanisms loading Frida as in indicated in [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

アプリがパスワードやニーモニックなど、本来メモリに保持すべきでない機密情報をメモリ内に保存していないか確認する。

Using [**Fridump3**](https://github.com/rootbsd/fridump3) you can dump the memory of the app with:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
これにより ./dump フォルダにメモリがダンプされ、そこで次のように grep できます:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Keystore内の機密データ**

AndroidではKeystoreは機密データを保存する最適な場所ですが、権限が十分あれば**アクセス可能**な場合があります。アプリはここに**機密データをプレーンテキストで保存する**傾向があるため、pentestsではrootユーザーとして確認する必要があります。物理的にデバイスにアクセスできる者がこのデータを盗む可能性があります。

アプリがKeystoreにデータを保存している場合でも、データは暗号化されているべきです。

Keystore内のデータにアクセスするには、このFridaスクリプトを使用できます: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

以下のFridaスクリプトを使用すると、Androidアプリが特定の機密領域を保護するために実施している可能性のある **bypass fingerprint authentication** を回避できる場合があります:
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **バックグラウンド画像**

アプリをバックグラウンドにすると、Androidは**アプリケーションのスナップショット**を保存します。アプリがフォアグラウンドに復帰したとき、アプリ本体より先にその画像を読み込むことで、アプリがより速く起動したように見せます。

しかし、この**スナップショット**に**機密情報**が含まれている場合、そのスナップショットにアクセスできる第三者が**その情報を盗む**可能性があります（アクセスにはrootが必要な点に注意）。

スナップショットは通常次の場所に保存されます: **`/data/system_ce/0/snapshots`**

Androidは、レイアウトパラメータFLAG_SECUREを設定することで**スクリーンショットの取得を防止**できます。このフラグを使用すると、ウィンドウの内容がセキュアとして扱われ、スクリーンショットに表示されたり、非セキュアなディスプレイで閲覧されたりするのを防ぎます。
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

このツールは dynamic analysis 中に複数のツールを管理するのに役立ちます: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

開発者はしばしば、これらの Intents を処理して `startActivity(...)` や `sendBroadcast(...)` のようなメソッドに渡す proxy コンポーネント（activities、services、broadcast receivers など）を作成しますが、これは危険を伴う場合があります。

危険性は、攻撃者がこれらの Intents を誤誘導して non-exported なアプリコンポーネントをトリガーしたり、機密性の高い content providers にアクセスさせたりできる点にあります。顕著な例として、`WebView` コンポーネントが URL を `Intent` オブジェクトに `Intent.parseUri(...)` を使って変換し、それを実行してしまうことで、悪意ある Intent Injection を引き起こす可能性があります。

### Essential Takeaways

- **Intent Injection** は web の Open Redirect の問題に似ています。
- エクスプロイトは `Intent` オブジェクトを extras として渡し、それをリダイレクトして安全でない操作を実行させることを含みます。
- non-exported なコンポーネントや content providers を攻撃者に晒す可能性があります。
- `WebView` の URL → `Intent` 変換によって意図しない動作が発生することがあります。

### Android Client Side Injections and others

おそらく Web でこの種の脆弱性について知っているでしょう。Android アプリケーションでは特に以下の脆弱性に注意する必要があります:

- **SQL Injection:** 動的クエリや Content-Providers を扱うときは、パラメータ化されたクエリを使用していることを確認してください。
- **JavaScript Injection (XSS):** 任意の WebViews に対して JavaScript と Plugin サポートが無効になっていることを確認してください（デフォルトでは無効）。[More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews はファイルシステムへのアクセスを無効にしておくべきです（デフォルトで有効） - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: 多くのケースで Android アプリがセッションを終了しても cookie が破棄されず、ディスクに保存されることがあります。
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Static analysis**

![](<../../images/image (866).png>)

**Vulnerability assessment of the application** を使いやすい web-based frontend で行えます。dynamic analysis も実行できます（ただし環境の準備が必要です）。
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Assisted Dynamic analysis with MobSF

**MobSF** can also be very helpful for **dynamic analysis** in **Android**, but in that case you will need to install MobSF and **genymotion** in your host (a VM or Docker won't work). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
The **MobSF dynamic analyser** can:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). All of this is done automatically except for the screenshots, you need to press when you want a screenshot or you need to press "**Exported Activity Tester**" to obtain screenshots of all the exported activities.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: It will print all the loaded classes
- **Capture Strings**: It will print all the capture strings while using the application (super noisy)
- **Capture String Comparisons**: Could be very useful. It will **show the 2 strings being compared** and if the result was True or False.
- **Enumerate Class Methods**: Put the class name (like "java.io.File") and it will print all the methods of the class.
- **Search Class Pattern**: Search classes by pattern
- **Trace Class Methods**: **Trace** a **whole class** (see inputs and outputs of all methods of th class). Remember that by default MobSF traces several interesting Android Api methods.

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf also brings you a shell with some **adb** commands, **MobSF commands**, and common **shell** **commands** at the bottom of the dynamic analysis page. Some interesting commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP ツール**

When http traffic is capture you can see an ugly view of the captured traffic on "**HTTP(S) Traffic**" bottom or a nicer view in "**Start HTTPTools**" green bottom. From the second option, you can **send** the **captured requests** to **proxies** like Burp or Owasp ZAP.\
To do so, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> press "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Once you finish the dynamic analysis with MobSF you can press on "**Start Web API Fuzzer**" to **fuzz http requests** an look for vulnerabilities.

> [!TIP]
> After performing a dynamic analysis with MobSF the proxy settings me be misconfigured and you won't be able to fix them from the GUI. You can fix the proxy settings by doing:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

You can get the tool from [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
このツールはいくつかの **Hooks** を使用して、**dynamic analysis** を行っている間にアプリケーション内で**何が起きているか**を把握できるようにします。

### [Yaazhini](https://www.vegabird.com/yaazhini/)

これは **GUI を使った static analysis を実行するのに優れたツール** です

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

This tool is designed to look for several **security related Android application vulnerabilities**, either in **source code** or **packaged APKs**. The tool is also **capable of creating a "Proof-of-Concept" deployable APK** and **ADB commands**, to exploit some of the found vulnerabilities (Exposed activities, intents, tapjacking...). As with Drozer, there is no need to root the test device.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- 参照しやすいように抽出されたすべてのファイルを表示する
- APKファイルを自動的にJavaおよびSmali形式にデコンパイルする
- AndroidManifest.xmlを分析して一般的な脆弱性や挙動を検出する
- 静的ソースコード解析により一般的な脆弱性や挙動を検出する
- デバイス情報を表示する
- など
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPERはWindows、MacOS X、Linuxで使用できるコマンドラインアプリケーションで、_.apk_ ファイルを解析して脆弱性を検出します。これはAPKsを解凍し、複数のルールを適用して脆弱性を検出することで行います。

すべてのルールは `rules.json` ファイルに集約されており、各企業やテスターは必要に応じて独自のルールを作成して解析できます。

最新のバイナリは[download page](https://superanalyzer.rocks/download.html)からダウンロードしてください。
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAnは、モバイルアプリケーションの[static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis)を行う開発者、bugbounty hunters、ethical hackersを支援する**クロスプラットフォーム**ツールです。

使い方は、モバイルアプリのファイル（.apk または .ipa ファイル）を StaCoAn アプリにドラッグ＆ドロップすると、視覚的で持ち運び可能なレポートを自動生成する、というものです。設定や wordlists を調整してカスタマイズした出力にできます。

ダウンロード[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework は、Android 脆弱性解析システムで、開発者や hackers が Android アプリケーションの潜在的なセキュリティ脆弱性を発見するのを支援します。\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** は、Android アプリケーションによって開発された潜在的な悪意ある振る舞いを検出し、ユーザーに警告することを主目的としたツールです。

検出は、アプリケーションの Dalvik bytecode を **Smali** として表現したものに対する **static analysis** を [`androguard`](https://github.com/androguard/androguard) ライブラリで行うことで実行されます。

このツールは、次のような **common behavior of "bad" applications** を検出します: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. モバイルアプリの一般的に使用される reverse engineering と analysis ツールをまとめ、OWASP mobile security threats に対するモバイルアプリのテストを支援するツールです。目的は、この作業をモバイルアプリ開発者やセキュリティ専門家にとってより簡単で扱いやすくすることです。

It is able to:

- Extract Java and Smali code using different tools
- Analyze APKs using: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Extract private information from the APK using regexps.
- Analyze the Manifest.
- Analyze found domains using: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Useful to detect malware: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Note that depending the service and configuration you use to obfuscate the code. Secrets may or may not ended obfuscated.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. Java コードを縮小・最適化し、obfuscates するオープンソースのコマンドラインツールです。bytecode の最適化や未使用命令の検出と削除が可能です。ProGuard はフリーソフトウェアで、GNU General Public License, version 2 の下で配布されています。

ProGuard is distributed as part of the Android SDK and runs when building the application in release mode.

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Last time we checked, the Dexguard mode of operation was:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

obfuscated APK を彼らのプラットフォームにアップロードできます。

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

It is a **generic android deobfuscator.** Simplify **virtually executes an app** to understand its behavior and then **tries to optimize the code** so it behaves identically but is easier for a human to understand. Each optimization type is simple and generic, so it doesn't matter what the specific type of obfuscation is used.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD gives you information about **how an APK was made**. It identifies many **compilers**, **packers**, **obfuscators**, and other weird stuff. It's [_PEiD_](https://www.aldeid.com/wiki/PEiD) for Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b は ubuntu-mate ベースの Android security virtual machine で、reverse engineering と malware analysis のために様々な研究者や開発者から集められた最新のフレームワーク、チュートリアル、lab を含んでいます。

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) 優れたリソース一覧です
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)

## Yet to try

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
