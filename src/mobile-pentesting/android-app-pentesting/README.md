# Android 应用程序 Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android 应用基础

强烈建议先阅读此页面，以了解与 Android 安全相关的**最重要部分以及 Android 应用中最危险的组件**：


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

这是连接 Android 设备（模拟或实体）所需的主要工具。\
**ADB** 允许从计算机通过 **USB** 或 **Network** 控制设备。该工具支持双向**复制**文件、应用的**安装**与**卸载**、执行 shell 命令、**备份**数据、**读取**日志等功能。

查看下面的[**ADB Commands**](adb-commands.md) 列表以学习如何使用 adb。

## Smali

有时，**修改应用代码**以访问**隐藏信息**（例如高度混淆的密码或 flag）是很有意义的。随后，反编译 apk、修改代码并重新编译可能会很有用。\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md)。这在作为即将进行的动态分析测试中的一种替代方案时可能非常有用。因此，**始终记住这种可能性**。

## 其他有趣的技巧

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **下载 APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- 从设备中提取 APK：
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- 使用 [APKEditor](https://github.com/REAndroid/APKEditor) 合并所有 splits 和 base apks：
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Android Enterprise & Work Profile 攻击

{{#ref}}
android-enterprise-work-profile-bypass.md
{{#endref}}

## 案例研究与漏洞


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## 静态分析

首先，对于分析 APK，你应该使用反编译器**查看 Java 代码**。\
请，[**在此处阅读有关不同可用反编译器的信息**](apk-decompilers.md)。

### 查找有趣的信息

只需查看 APK 的 **strings** 就可以搜索 **密码**、**URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep))、**api keys**、**encryption**、**bluetooth uuids**、**tokens** 以及任何有趣的内容……甚至查找代码执行的 **backdoors** 或认证后门（应用的硬编码管理员凭据）。

**Firebase**

特别注意 **Firebase URLs** 并检查其配置是否错误。[关于 Firebase 是什么以及如何利用它的更多信息见此处。](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### 对应用的基本理解 - Manifest.xml, strings.xml

检查应用的 _Manifest.xml_ 和 **_strings.xml_** 文件可以发现潜在的安全漏洞。可通过反编译器访问这些文件，或将 APK 的扩展名改为 .zip 然后解压来获取。

**从 Manifest.xml 识别出的漏洞包括：**

- **可调试应用**: 在 _Manifest.xml_ 中设置为 debuggable (`debuggable="true"`) 的应用存在风险，因为它们允许连接，可能被利用。有关如何在设备上发现并利用可调试应用的更多信息，请参考相关教程。
- **备份设置**: 对于处理敏感信息的应用，应显式设置 `android:allowBackup="false"` 属性，以防止通过 adb 进行未授权的数据备份，尤其是在启用 usb debugging 时。
- **网络安全**: 在 _res/xml/_ 中自定义的网络安全配置 (`android:networkSecurityConfig="@xml/network_security_config"`) 可以指定证书 pin 和 HTTP 流量设置等安全细节。例如允许特定域的 HTTP 流量。
- **导出 Activity 和 Service**: 在 manifest 中识别导出的 activity 和 service 可以发现可能被滥用的组件。动态测试中的进一步分析可以揭示如何利用这些组件。
- **Content Providers 和 FileProviders**: 暴露的 content providers 可能允许未授权访问或修改数据。也应审查 FileProviders 的配置。
- **Broadcast Receivers 和 URL Schemes**: 这些组件可能被用于利用，尤其要注意 URL schemes 的处理是否存在输入漏洞。
- **SDK 版本**: `minSdkVersion`、`targetSDKVersion` 和 `maxSdkVersion` 属性表示支持的 Android 版本，强调了不支持过时且存在漏洞的 Android 版本以确保安全的重要性。

在 **strings.xml** 文件中，可能会发现敏感信息，例如 API keys、自定义 schema 以及其他开发者注释，凸显了对这些资源进行仔细审查的必要性。

### Tapjacking

Tapjacking 是一种攻击，其中一个**恶意应用**被启动并**置于受害应用之上**。一旦它可见地遮挡了受害应用，它的用户界面就会以某种方式设计来诱使用户与其交互，同时将该交互传递给受害应用。实际上，它使用户无法察觉自己实际上是在对受害应用执行操作。

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

一个将 `launchMode` 设置为 `singleTask` 且未定义 `taskAffinity` 的 **activity** 易受 Task Hijacking 的影响。这意味着，如果在真实应用之前安装并启动了一个应用，它可能**劫持真实应用的任务**（用户会以为在使用真实应用，实际上在与**恶意应用**交互）。

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### 不安全的数据存储

**内部存储**

在 Android 中，存储在**内部**存储的文件设计为只能被**创建它们的应用**访问。这一安全措施由 Android 操作系统强制执行，通常足以满足大多数应用的安全需求。然而，开发者有时会使用诸如 `MODE_WORLD_READABLE` 和 `MODE_WORLD_WRITABLE` 的模式来允许文件在不同应用之间**共享**。但这些模式**并不限制**其他应用（包括潜在的恶意应用）对这些文件的访问。

1. **静态分析：**
- **确保** 对 `MODE_WORLD_READABLE` 和 `MODE_WORLD_WRITABLE` 的使用进行**严格审查**。这些模式可能会将文件暴露给**非预期或未授权的访问**。
2. **动态分析：**
- **验证** 应用创建的文件的**权限**。尤其要**检查**是否有文件被设置为对全世界可读或可写。这会带来重大安全风险，因为它将允许设备上**任何应用**（无论来源或意图）**读取或修改**这些文件。

**外部存储**

在处理 SD 卡等**外部存储**上的文件时，应采取以下预防措施：

1. **可访问性**：
- 外部存储上的文件**全局可读可写**，这意味着任何应用或用户都可以访问这些文件。
2. **安全性问题**：
- 鉴于易于访问，建议**不要在外部存储上存储敏感信息**。
- 外部存储可被移除或被任何应用访问，因此安全性较低。
3. **处理来自外部存储的数据**：
- 始终对从外部存储检索的数据**执行输入验证**，这很重要，因为这些数据来自不受信任的来源。
- 强烈不建议将可执行文件或 class 文件存放在外部存储以供动态加载。
- 如果应用必须从外部存储获取可执行文件，确保在动态加载之前对这些文件进行**签名和加密验证**。此步骤对维护应用的安全完整性至关重要。

外部存储可在 `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard` 访问

> [!TIP]
> 从 Android 4.4（**API 17**）开始，SD 卡具有一种目录结构，**将应用的访问限制在专属于该应用的目录内**。这可防止恶意应用对其他应用的文件获得读写访问权限。

**以明文存储的敏感数据**

- **Shared preferences**：Android 允许每个应用在路径 `/data/data/<packagename>/shared_prefs/` 下轻松保存 xml 文件，有时可以在该文件夹中发现明文存储的敏感信息。
- **Databases**：Android 允许每个应用在路径 `/data/data/<packagename>/databases/` 下轻松保存 sqlite 数据库，有时可以在该文件夹中发现明文存储的敏感信息。

### TLS 配置缺陷

**接受所有证书**

在某些情况下，开发者会接受所有证书，即使例如 hostname 与证书不匹配，代码中可能出现如下类似的行：
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
一种很好的测试方法是尝试使用像 Burp 这样的代理来捕获流量，但不要在设备内授权 Burp CA。你也可以用 Burp 为不同的 hostname 生成一个证书并使用它。

### 弱密码学

**糟糕的密钥管理流程**

有些开发者会把敏感数据保存在本地存储中，并用硬编码/可预测的密钥在代码中进行加密。这不应该这样做，因为一些逆向工程可能允许攻击者提取机密信息。

**使用不安全和/或已弃用的算法**

开发者不应该使用 **已弃用的算法** 来执行授权 **检查**、**存储** 或 **发送** 数据。这些算法中的一些有：RC4, MD4, MD5, SHA1... 如果使用 **hashes** 来存储密码，例如，应该使用带 salt 的抗暴力破解的 hashes。

### 其他检查

- 建议 **混淆 APK**，以增加逆向工程的难度。
- 如果应用是敏感的（例如银行应用），应该对 **设备是否已 root** 做出自己的检测并据此采取措施。
- 如果应用是敏感的（例如银行应用），应该检测是否在使用 **emulator**。
- 如果应用是敏感的（例如银行应用），应该在执行前 **检查自身完整性**，以确认是否被修改。
- 使用 [**APKiD**](https://github.com/rednaga/APKiD) 检查构建 APK 时使用了哪个 compiler/packer/obfuscator

### React Native Application

阅读以下页面以了解如何轻松访问 React 应用的 javascript 代码：


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

阅读以下页面以了解如何轻松访问 xamarin 应用的 C# 代码：


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

根据这篇 [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/)，superpacked 是 Meta 的一种算法，它将应用的内容压缩到一个单一文件中。文章讨论了创建一个解压这类应用的应用的可能性……以及一种更快的方法，即 **执行应用并从文件系统收集解压后的文件。**

### Automated Static Code Analysis

工具 [**mariana-trench**](https://github.com/facebook/mariana-trench) 能通过 **扫描** 应用的 **代码** 来发现 **vulnerabilities**。该工具包含一系列 **known sources**（指示工具 **输入** 被用户控制的 **位置**）、**sinks**（指示工具潜在危险的**位置**，恶意用户输入可能在这些地方造成损害）和 **rules**。这些规则表示 **sources-sinks** 的 **组合**，从而表明存在漏洞。

基于这些知识，**mariana-trench 会审查代码并找出可能的漏洞。**

### Secrets leaked

应用中可能包含 secrets（API keys、密码、隐藏的 urls、子域名等），你可能能够发现这些信息。你可以使用诸如 [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks) 这样的工具。

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### 其他有趣的函数

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** 声明为 `native`: `public native, System.loadLibrary, System.load`
- [阅读此文以了解 **如何逆向 native functions**](reversing-native-libraries.md)
- 通过 JNI 的内存中本地代码执行（下载 shellcode → mmap/mprotect → 调用）:

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **其他技巧**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## 动态分析

> 首先，你需要一个可以安装应用和设置整个环境（主要是 Burp CA 证书、Drozer 和 Frida）的环境。因此，强烈推荐使用已 root 的设备（模拟或真实设备均可）。

### 在线动态分析

你可以在 [https://appetize.io/](https://appetize.io/) 创建一个 **免费账户**。该平台允许你 **上传** 并 **执行** APK，因此对于观察 apk 的行为很有用。

你甚至可以在网页上 **查看应用的日志** 并通过 **adb** 连接。

![](<../../images/image (831).png>)

借助 ADB 连接，你可以在模拟器内使用 **Drozer** 和 **Frida**。

### 本地动态分析

#### 使用 emulator

- [**Android Studio**](https://developer.android.com/studio)（你可以创建 **x86** 和 **arm** 设备，并且根据 [**this**](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html) **最新 x86** 版本 **支持 ARM libraries**，无需使用慢速的 arm emulator）。
- 在此页面学习如何设置：


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **（免费版本：Personal Edition，需要创建账户。建议下载** 带 **VirtualBox** 的版本以避免潜在错误。）**
- [**Nox**](https://es.bignox.com)（免费，但不支持 Frida 或 Drozer）。

> [!TIP]
> 在任何平台上创建新 emulator 时请记住：屏幕越大，emulator 运行越慢。所以如果可能请选小屏幕。

要在 Genymotion 中 **安装 google services**（如 AppStore），需要点击下图中标红的按钮：

![](<../../images/image (277).png>)

另外，请注意在 **Genymotion 的 Android VM 配置** 中可以选择 **Bridge Network mode**（如果你将从另一个 VM 连接到该 Android VM 并使用工具时，这会很有用）。

#### 使用真实设备

你需要开启 **调试** 选项，如果可以的话，最好能 **root** 它：

1. **Settings**。
2. （从 Android 8.0 起）选择 **System**。
3. 选择 **About phone**。
4. 连续按 **Build number** 7 次。
5. 返回，你会看到 **Developer options**。

> 一旦你安装了应用，首先应该做的是试用并调查它的行为、工作方式，并熟悉它。\
> 我建议使用 MobSF dynamic analysis + pidcat 来 **执行这个初始的动态分析**，这样我们在 MobSF **捕获** 许多你以后可以查看的 **有价值数据** 的同时，也能 **学习应用是如何工作的**。

Magisk/Zygisk 快速说明（在 Pixel 设备上推荐）
- 使用 Magisk 应用 patch boot.img 并通过 fastboot 刷写以获得 systemless root
- 启用 Zygisk + DenyList 以隐藏 root；在需要更强隐藏时考虑使用 LSPosed/Shamiko
- 保留原始 boot.img 以便在 OTA 更新后恢复；每次 OTA 后重新 patch
- 屏幕镜像使用 host 上的 scrcpy

### 非预期的数据泄露

**Logging**

开发者应谨慎避免公开 **调试信息**，因为这会导致敏感数据泄露。推荐使用工具 [**pidcat**](https://github.com/JakeWharton/pidcat) 和 `adb logcat` 来监控应用日志，以识别并保护敏感信息。**Pidcat** 因其易用性和可读性而更受欢迎。

> [!WARNING]
> 请注意，从 **晚于 Android 4.0 的版本** 起，**应用只能访问自己的日志**。所以应用无法访问其他应用的日志。\
> 无论如何，仍然建议 **不要记录敏感信息**。

**剪贴板缓存（Copy/Paste Buffer Caching）**

Android 的 **clipboard-based** 框架支持应用间复制粘贴功能，但存在风险，因为 **其他应用** 可以 **访问** 剪贴板，可能暴露敏感数据。对于应用中敏感的部分（如信用卡信息），应禁用复制/粘贴功能以防止数据泄露。

**崩溃日志（Crash Logs）**

如果应用 **崩溃** 并 **保存日志**，这些日志可能会帮助攻击者，尤其是在应用无法被逆向时。为降低风险，应避免在崩溃时记录日志；如果必须通过网络传输日志，确保通过 SSL 通道发送以保证安全。

作为 pentester，**尝试查看这些日志**。

**发送给第三方的 Analytics Data**

应用常常集成诸如 Google Adsense 之类的服务，如果开发者实现不当，可能会意外地 **leak sensitive data**。要识别潜在的数据泄露，建议 **拦截应用流量** 并检查是否有敏感信息被发送到第三方服务。

### SQLite DBs

大多数应用会使用 **internal SQLite databases** 来保存信息。在进行 pentest 时，查看创建的 **databases**、**tables** 和 **columns** 的名称以及保存的 **所有数据**，因为你可能会找到 **敏感信息**（这将构成漏洞）。\
数据库通常位于 `/data/data/the.package.name/databases`，例如 `/data/data/com.mwr.example.sieve/databases`

如果数据库保存了机密信息且已 **encrypted**，但你能在应用中 **找到** 该 **password**，这仍然是一个 **vulnerability**。

使用 `.tables` 枚举表，使用 `.schema <table_name>` 枚举表的列。

### Drozer (Exploit Activities, Content Providers and Services)

根据 [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf)：**Drozer** 允许你 **扮演一个 Android 应用** 的角色并与其他应用交互。它可以做 **任何已安装应用可以做的事**，例如利用 Android 的进程间通信（IPC）机制并与底层操作系统交互。\
Drozer 是一个有用的工具，用来 **exploit exported activities, exported services and Content Providers**，你将在以下章节中学习到这些内容。

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
还要记住，一个 activity 的代码在 **`onCreate`** 方法中开始执行。

**Authorisation bypass**

当一个 Activity 被 exported 时，你可以从外部应用调用它的界面。因此，如果一个包含 **敏感信息** 的 activity 被 **exported**，你可能可以 **bypass** **authentication** 机制来访问它。

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

你也可以从 adb 启动一个 exported activity：

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**注意**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> 请注意，authorisation bypass 并不总是一个漏洞，这取决于 bypass 的工作方式以及暴露了哪些信息。

**Sensitive information leakage**

Activities 也可以返回结果。如果你找到一个被 exported 且未受保护的 activity 调用了 **`setResult`** 方法并**返回 sensitive information**，那么就会发生 sensitive information leakage。

#### Tapjacking

如果未防止 Tapjacking，你可以滥用已导出的 activity 让用户执行意外操作。有关更多信息，请参阅 [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers 基本上用于 **share data**。如果一个 app 存在可用的 content providers，你可能能够从中 **extract sensitive** 数据。也应测试可能的 **SQL injections** 和 **Path Traversals**，因为它们可能存在漏洞。

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
请记住，Service 的动作在方法 `onStartCommand` 中开始。

Service 本质上是可以接收数据、处理它并（可选地）返回响应的组件。因此，如果一个应用导出了一些 services，你应检查其代码以了解其行为，并对其进行动态测试以提取机密信息、绕过认证措施等。\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
请记住，Broadcast Receiver 的动作在方法 `onReceive` 中开始。

广播接收器会等待某类消息。接收器如何处理消息可能会存在漏洞。\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

你可以手动查找 deep links，使用像 MobSF 这样的工具或像 [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py) 这样的脚本。\
你可以使用 **adb** 或 **browser** 打开已声明的 **scheme**：
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_请注意你可以 **省略包名**，移动设备会自动调用应该打开该链接的应用程序。_
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**执行的代码**

为了找到 **将在 App 中执行的代码**，转到 deeplink 调用的 activity 并搜索函数 **`onNewIntent`**。

![](<../../images/image (436) (1) (1) (1).png>)

**敏感信息**

每次发现 deep link 时，请检查 **它不会通过 URL 参数接收敏感数据（例如密码）**，因为任何其他应用都可以 **冒充 deep link 并窃取这些数据！**

**路径中的参数**

你 **必须检查是否有 deep link 在 URL 的 path 中使用参数**，例如：`https://api.example.com/v1/users/{username}`，在这种情况下你可以通过访问类似 `example://app/users?username=../../unwanted-endpoint%3fparam=value` 的方式强制进行路径遍历。\
注意，如果你在应用内找到正确的端点，你可能能够导致 **Open Redirect**（如果 path 的一部分被用作域名）、**account takeover**（如果你能在没有 CSRF token 的情况下修改用户详情，且 vuln endpoint 使用了正确的方法）以及任何其他漏洞。更多 [info about this here](http://dphoeniixx.com/2020/12/13-2/)。

**More examples**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### 传输层检查和验证失败

- **证书并非总是被 Android 应用正确检查**。这些应用常常忽略警告并接受自签名证书，或在某些情况下回退到使用 HTTP 连接。
- **SSL/TLS 握手期间的协商有时很弱**，使用不安全的密码套件。这使连接容易受到 man-in-the-middle (MITM) 攻击，允许攻击者解密数据。
- **Leakage of private information** 是一种风险，当应用使用安全通道进行认证但随后在其他事务上通过非安全通道通信时。该做法无法保护敏感数据，例如会话 cookie 或用户详情，免于被恶意方拦截。

#### 证书验证

我们将关注 **证书验证**。必须验证服务器证书的完整性以增强安全性。这一点很重要，因为不安全的 TLS 配置和通过未加密通道传输敏感数据会带来重大风险。关于验证服务器证书和修复漏洞的详细步骤，参见 [**该资源**](https://manifestsecurity.com/android-application-security-part-10/)。

#### SSL Pinning

SSL Pinning 是一种安全措施，应用将服务器证书与存储在应用内的已知副本进行比对验证。该方法对于防止 MITM 攻击至关重要。建议对处理敏感信息的应用实现 SSL Pinning。

#### 流量检查

要检查 HTTP 流量，需要 **安装代理工具的证书**（例如 Burp）。如果不安装该证书，加密流量可能无法通过代理可见。关于安装自定义 CA 证书的指南，见 [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine)。

目标为 **API Level 24 和以上** 的应用需要修改 Network Security Config 以接受代理的 CA 证书。此步骤对于检查加密流量至关重要。关于修改 Network Security Config 的说明，见 [**refer to this tutorial**](make-apk-accept-ca-certificate.md)。

如果使用 **Flutter**，需要按照 [**this page**](flutter.md) 中的说明操作。因为仅将证书添加到存储中不会生效，Flutter 有其自己的有效 CA 列表。

#### SSL/TLS pinning 的静态检测

在尝试运行时绕过之前，先快速映射 APK 中强制 pinning 的位置。静态发现可以帮助你规划 hooks/patches 并集中精力在正确的代码路径上。

Tool: SSLPinDetect
- 开源静态分析工具，会将 APK 反编译为 Smali（通过 apktool），并扫描用于 SSL/TLS pinning 实现的预先整理的正则模式。
- 为每个匹配报告精确的文件路径、行号和代码片段。
- 覆盖常见框架和自定义代码路径：OkHttp CertificatePinner、custom javax.net.ssl.X509TrustManager.checkServerTrusted、SSLContext.init with custom TrustManagers/KeyManagers，以及 Network Security Config XML pins。

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
用法
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
示例模式规则 (JSON)
使用或扩展 signatures 来检测专有/自定义 pinning styles。你可以加载自定义 JSON 并进行大规模扫描。
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
笔记与提示
- 通过多线程和内存映射 I/O 对大型应用进行快速扫描；预编译的 regex 可减少开销/误报。
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- 用于后续分类的典型检测目标：
- OkHttp：CertificatePinner 使用、setCertificatePinner、okhttp3/okhttp 包引用
- 自定义 TrustManagers：javax.net.ssl.X509TrustManager、checkServerTrusted 重写
- 自定义 SSL contexts：SSLContext.getInstance + SSLContext.init 与自定义 managers
- 在 res/xml 的 network security config 中声明式 pins 以及 manifest 引用
- 使用匹配到的位置来规划 Frida hooks、静态补丁或配置审查，然后再做动态测试。



#### Bypassing SSL Pinning

当实现了 SSL Pinning 时，为了检查 HTTPS 流量需要绕过它。可用的方法有多种：

- Automatically **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). The best pro of this option, is that you won't need root to bypass the SSL Pinning, but you will need to delete the application and reinstall the new one, and this won't always work.
- 你可以使用 **Frida**（见下文）来绕过这一防护。这里有一篇使用 Burp+Frida+Genymotion 的指南： [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- 也可以尝试使用 [**objection**](frida-tutorial/objection-tutorial.md) 自动绕过 SSL Pinning：`objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- 也可尝试使用 **MobSF dynamic analysis**（下文说明）自动绕过 SSL Pinning
- 如果仍然认为有流量未被捕获，可以尝试使用 iptables 将流量转发到 Burp。参见这篇博客： [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Looking for Common Web Vulnerabilities

还应该在应用内搜索常见的 Web 漏洞。有关识别和缓解这些漏洞的详细信息超出本文摘要范围，但已在其他地方有详尽介绍。

### Frida

[Frida](https://www.frida.re) 是面向开发者、逆向工程师和安全研究人员的动态插桩工具包。\
**你可以在运行时访问正在运行的应用并 hook 方法，以改变行为、修改/提取值或执行不同的代码...**\
如果你想 pentest Android 应用，就需要会使用 Frida。

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- 一些用于 Frida 操作的 "GUI"： [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection 非常适合自动化使用 Frida： [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- 这里有一些很棒的 Frida 脚本： [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- 尝试按 [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) 中所示加载 Frida 来绕过 anti-debugging / anti-frida 机制（工具 [linjector](https://github.com/erfur/linjector-rs)）

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

检查应用是否在内存中存储不应存在的敏感信息，例如密码或助记词。

使用 [**Fridump3**](https://github.com/rootbsd/fridump3) 可导出应用内存，命令示例：
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
这会将内存转储到 ./dump 文件夹，你可以在其中使用类似下面的 grep：
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Keystore 中的敏感数据**

在 Android 中，Keystore 是存储敏感数据的最佳位置，但是如果拥有足够的权限，仍然**可能访问到它**。由于应用程序往往会在此处以 **敏感数据 in clear text** 存储，pentests 应以 root user 身份进行检查，否则有物理访问设备的人可能会窃取这些数据。

即使应用将数据存储在 Keystore 中，数据仍应被加密。

要访问 Keystore 中的数据，可以使用这个 Frida script: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

使用以下 Frida 脚本，可能可以**bypass fingerprint authentication**，绕过 Android 应用为保护某些敏感区域所执行的验证：
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **后台快照**

当你将应用置于后台时，Android 会存储应用的**快照**，以便在恢复到前台时先加载该图像，从而看起来应用加载得更快。

然而，如果该快照包含**敏感信息**，有权限访问该快照的人可能会**窃取这些信息**（注意：访问它需要 root 权限）。

这些快照通常存储在：**`/data/system_ce/0/snapshots`**

Android 提供了一种方法，即在布局参数中设置 **FLAG_SECURE 来防止屏幕截图的捕获**。使用该标志后，窗口内容会被视为安全内容，阻止其出现在屏幕截图中或在非安全显示器上被查看。
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android 应用分析器**

This tool could help you managing different tools during the dynamic analysis: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Developers often create proxy components like activities, services, and broadcast receivers that handle these Intents and pass them to methods such as `startActivity(...)` or `sendBroadcast(...)`, which can be risky.

The danger lies in allowing attackers to trigger non-exported app components or access sensitive content providers by misdirecting these Intents. A notable example is the `WebView` component converting URLs to `Intent` objects via `Intent.parseUri(...)` and then executing them, potentially leading to malicious Intent injections.

### 重要要点

- **Intent Injection** 类似于 web 的 Open Redirect 问题。
- 利用通常涉及将 `Intent` 对象作为 extras 传递，这些可以被重定向以执行不安全的操作。
- 它可能会将非导出组件和 content providers 暴露给攻击者。
- `WebView` 的 URL 到 `Intent` 的转换可能促成非预期的操作。

### Android Client Side Injections and others

Probably you know about this kind of vulnerabilities from the Web. You have to be specially careful with this vulnerabilities in an Android application:

- **SQL Injection:** 在处理动态查询或 Content-Providers 时，确保使用参数化查询。
- **JavaScript Injection (XSS):** 确保任何 WebViews 的 JavaScript 和 Plugin 支持已被禁用（默认已禁用）。 [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** 应禁用 WebViews 对文件系统的访问（默认启用） - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**：在若干情况下，当 android 应用结束会话时，cookie 未被撤销，或甚至被保存到磁盘
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## 自动分析

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**静态分析**

![](<../../images/image (866).png>)

**应用的漏洞评估** 使用一个好看的基于 web 的前端。你也可以执行动态分析（但你需要准备环境）。
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Assisted Dynamic analysis with MobSF

**MobSF** can also be very helpful for **dynamic analysis** in **Android**, but in that case you will need to install MobSF and **genymotion** in your host (a VM or Docker won't work). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
The **MobSF dynamic analyser** can:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). All of this is done automatically except for the screenshots, you need to press when you want a screenshot or you need to press "**Exported Activity Tester**" to obtain screenshots of all the exported activities.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Frida scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: It will print all the loaded classes
- **Capture Strings**: It will print all the capture strings while using the application (super noisy)
- **Capture String Comparisons**: Could be very useful. It will **show the 2 strings being compared** and if the result was True or False.
- **Enumerate Class Methods**: Put the class name (like "java.io.File") and it will print all the methods of the class.
- **Search Class Pattern**: Search classes by pattern
- **Trace Class Methods**: **Trace** a **whole class** (see inputs and outputs of all methods of th class). Remember that by default MobSF traces several interesting Android Api methods.

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf also brings you a shell with some **adb** commands, **MobSF commands**, and common **shell** **commands** at the bottom of the dynamic analysis page. Some interesting commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP tools**

当 http 流量被捕获时，你可以在底部的 "**HTTP(S) Traffic**" 查看捕获流量的原始视图，或者在绿色按钮 "**Start HTTPTools**" 获取更友好的视图。通过第二个选项，你可以将 **captured requests** 发送到像 Burp 或 Owasp ZAP 这样的 **proxies**。\
操作方法：_启动 Burp -->_ _关闭 Intercept --> 在 MobSB HTTPTools 中选择请求_ --> 点击 "**Send to Fuzzer**" --> _选择代理地址_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080))。

完成对 MobSF 的动态分析后，你可以点击 "**Start Web API Fuzzer**" 来 **fuzz http requests** 并查找漏洞。

> [!TIP]
> 在使用 MobSF 执行动态分析后，代理设置可能会被错误配置且无法通过 GUI 修复。你可以通过以下方式修复代理设置：
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

你可以从 [**Inspeckage**](https://github.com/ac-pm/Inspeckage) 获取该工具。\
该工具将使用一些 **Hooks** 来在你执行 **dynamic analysis** 时让你了解 **what is happening in the application**。

### [Yaazhini](https://www.vegabird.com/yaazhini/)

这是一个用于带 GUI 的 **static analysis** 的优秀工具

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

该工具旨在查找若干与安全相关的 Android 应用漏洞，无论是在 **source code** 还是 **packaged APKs** 中。该工具还能够 **create a "Proof-of-Concept" deployable APK** 和 **ADB commands**，以利用发现的一些漏洞（如 Exposed activities、intents、tapjacking...）。与 Drozer 类似，无需对测试设备进行 root。
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- 显示所有提取的文件，便于参考
- 自动将 APK 文件反编译为 Java 和 Smali 格式
- 分析 AndroidManifest.xml 以查找常见漏洞与行为
- 对静态源代码进行分析以发现常见漏洞与行为
- 设备信息
- 以及更多功能
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER 是一个命令行应用程序，可在 Windows、MacOS X 和 Linux 上使用，用于分析 _.apk_ 文件以查找漏洞。它通过解压 APK 并应用一系列规则来检测这些漏洞。

所有规则集中在 `rules.json` 文件中，每个公司或测试人员都可以创建自己的规则来分析他们需要的内容。

从 [download page](https://superanalyzer.rocks/download.html) 下载最新的二进制文件
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn 是一个 **跨平台** 工具，帮助开发者、bugbounty hunters 和 ethical hackers 在移动应用上执行 [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis)。

其理念是将移动应用文件（.apk 或 .ipa 文件）拖放到 StaCoAn 应用中，它会为你生成可视化且便携的报告。你可以调整设置和 wordlists 以获得定制体验。

下载[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework 是一个 Android 漏洞分析系统，帮助开发者或黑客发现 Android 应用中的潜在安全漏洞。\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** 是一个工具，主要目的是检测并警告用户关于 Android 应用可能的潜在恶意行为。

检测是通过使用 [`androguard`](https://github.com/androguard/androguard) 库，对应用的 Dalvik bytecode（表示为 **Smali**）进行 **static analysis** 来执行。

该工具会寻找 **常见的“恶意”应用行为**，例如：Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** 是一个移动应用逆向与分析框架。它整合了常用的移动应用逆向与分析工具，以协助对移动应用进行针对 OWASP mobile security threats 的测试。其目标是让移动应用开发者和安全专业人员更容易、更友好地完成这项工作。

它能够：

- 使用不同工具提取 Java 和 Smali 代码
- 使用以下工具分析 APK: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- 使用正则表达式从 APK 中提取私有信息。
- 分析 Manifest。
- 使用以下工具分析发现的域名: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- 通过 [apk-deguard.com](http://www.apk-deguard.com) 对 APK 进行反混淆

### Koodous

用于检测恶意软件: [https://koodous.com/](https://koodous.com/)

## 代码混淆/反混淆

注意，取决于用于混淆代码的服务和配置，敏感信息可能会被混淆，也可能不会。

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** 是一个开源命令行工具，用于缩减、优化并混淆 Java 代码。它能够优化字节码并检测和移除未使用的指令。ProGuard 是自由软件，并根据 GNU General Public License 第2版发布。

ProGuard 随 Android SDK 一同发布，并在以 release 模式构建应用时运行。

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) 我们上次检查时，Dexguard 的运行方式是：

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard 逆转了 Android 混淆工具执行的混淆过程。这样可以进行多种安全分析，包括代码检查和识别所用库。**

你可以将混淆过的 APK 上传到他们的平台。

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

它是一个通用的 android 反混淆器。Simplify 通过对应用进行虚拟执行来理解其行为，然后尝试优化代码，使其在行为上保持一致但更易于人类理解。每种优化类型都简单且通用，因此所使用的具体混淆类型并不重要。

### [APKiD](https://github.com/rednaga/APKiD)

APKiD 提供关于 **how an APK was made** 的信息。它能识别许多 **compilers**, **packers**, **obfuscators**, 和其他奇怪的东西。它是 Android 上的 [_PEiD_](https://www.aldeid.com/wiki/PEiD)。

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b 是一个基于 ubuntu-mate 的 Android 安全虚拟机，包含来自不同安全极客和研究人员的最新框架、教程和用于逆向工程与恶意软件分析的实验。

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) 这是一个很棒的资源列表
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android 快速教程
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
