# Pentesting de Aplicações Android

{{#include ../../banners/hacktricks-training.md}}

## Noções Básicas de Aplicações Android

É altamente recomendável começar lendo esta página para conhecer as **partes mais importantes relacionadas à segurança Android e os componentes mais perigosos em uma aplicação Android**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Esta é a ferramenta principal que você precisa para conectar-se a um dispositivo Android (emulado ou físico).\
**ADB** permite controlar dispositivos tanto via **USB** quanto via **Network** a partir de um computador. Esta ferramenta possibilita a **cópia** de arquivos em ambas as direções, **instalação** e **desinstalação** de apps, **execução** de comandos shell, **backup** de dados, **leitura** de logs, entre outras funções.

Veja a lista a seguir de [**ADB Commands**](adb-commands.md) para aprender como usar adb.

## Smali

Às vezes é interessante **modificar o código da aplicação** para acessar **informações ocultas** (talvez passwords bem ofuscadas ou flags). Então, pode ser interessante descompilar o apk, modificar o código e recompilá-lo.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Isso pode ser muito útil como uma **alternativa para vários testes durante a análise dinâmica** que serão apresentados. Então, **sempre tenha esta possibilidade em mente**.

## Outros truques interessantes

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **Baixar APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Extrair APK do dispositivo:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Mescle todos os splits e base apks com [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Android Enterprise & Work Profile Attacks

{{#ref}}
android-enterprise-work-profile-bypass.md
{{#endref}}

## Estudos de Caso & Vulnerabilidades


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Análise Estática

Antes de mais nada, para analisar um APK você deve **dar uma olhada no código Java** usando um decompilador.\
Por favor, [**leia aqui para encontrar informação sobre diferentes decompiladores disponíveis**](apk-decompilers.md).

### Procurando informações interessantes

Apenas olhando as **strings** do APK você pode procurar **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** e qualquer coisa interessante... procure até por backdoors de execução de código ou backdoors de autenticação (credenciais admin hardcoded no app).

**Firebase**

Preste atenção especial às **firebase URLs** e verifique se está mal configurado. [Mais informação sobre o que é o Firebase e como explorá-lo aqui.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Entendimento básico da aplicação - Manifest.xml, strings.xml

A **análise do _Manifest.xml_ e dos arquivos **_strings.xml_** de uma aplicação pode revelar potenciais vulnerabilidades de segurança**. Esses arquivos podem ser acessados usando decompiladores ou renomeando a extensão do APK para .zip e depois descompactando-o.

**Vulnerabilidades** identificadas a partir do **Manifest.xml** incluem:

- **Debuggable Applications**: Aplicações marcadas como debuggable (`debuggable="true"`) no arquivo _Manifest.xml_ representam um risco, pois permitem conexões que podem levar à exploração. Para entender melhor como explorar aplicações debuggable, consulte um tutorial sobre como encontrar e explorar aplicações debuggable em um dispositivo.
- **Backup Settings**: O atributo `android:allowBackup="false"` deve ser explicitamente definido para aplicações que lidam com informações sensíveis para prevenir backups não autorizados via adb, especialmente quando usb debugging está habilitado.
- **Network Security**: Configurações customizadas de network security (`android:networkSecurityConfig="@xml/network_security_config"`) em _res/xml/_ podem especificar detalhes de segurança como certificate pins e configurações de tráfego HTTP. Um exemplo é permitir tráfego HTTP para domínios específicos.
- **Exported Activities and Services**: Identificar activities e services exportados no manifest pode destacar componentes que podem ser mal utilizados. Análises adicionais durante testes dinâmicos podem revelar como explorar esses componentes.
- **Content Providers and FileProviders**: Content providers expostos podem permitir acesso ou modificação não autorizada de dados. A configuração de FileProviders também deve ser examinada.
- **Broadcast Receivers and URL Schemes**: Esses componentes podem ser aproveitados para exploração, com atenção particular a como os URL schemes são gerenciados para vulnerabilidades de input.
- **SDK Versions**: Os atributos `minSdkVersion`, `targetSDKVersion`, e `maxSdkVersion` indicam as versões do Android suportadas, ressaltando a importância de não suportar versões antigas e vulneráveis do Android por razões de segurança.

No arquivo **strings.xml**, informações sensíveis como API keys, schemas customizados e outras notas do desenvolvedor podem ser descobertas, reforçando a necessidade de revisão cuidadosa desses recursos.

### Tapjacking

**Tapjacking** é um ataque em que uma **malicious** **application** é lançada e **se posiciona por cima de uma aplicação vítima**. Uma vez que obscurece visualmente o app vítima, sua interface é desenhada de forma a enganar o usuário para interagir com ela, enquanto passa a interação para o app vítima.\
Na prática, é **cegar o usuário para o fato de que ele está realmente realizando ações na aplicação vítima**.

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Uma **activity** com `launchMode` definida como **`singleTask` sem qualquer `taskAffinity`** definida é vulnerável a Task Hijacking. Isso significa que uma **application** pode ser instalada e, se iniciada antes da aplicação real, ela pode **hijack the task da aplicação real** (fazendo com que o usuário interaja com a **malicious application achando que está usando a real**).

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Armazenamento de dados inseguro

**Internal Storage**

No Android, arquivos **armazenados** no **internal** storage são **projetados** para serem **acessíveis** exclusivamente pelo **app** que os **criou**. Essa medida de segurança é **aplicada** pelo sistema operacional Android e é geralmente adequada para as necessidades de segurança da maioria das aplicações. No entanto, desenvolvedores às vezes utilizam modos como `MODE_WORLD_READABLE` e `MODE_WORLD_WRITABLE` para **permitir** que arquivos sejam **compartilhados** entre diferentes aplicações. Contudo, esses modos **não restringem o acesso** a esses arquivos por outras aplicações, incluindo possivelmente maliciosas.

1. **Static Analysis:**
- **Verifique** cuidadosamente o uso de `MODE_WORLD_READABLE` e `MODE_WORLD_WRITABLE`. Esses modos **podem potencialmente expor** arquivos a **acesso não intencional ou não autorizado**.
2. **Dynamic Analysis:**
- **Confirme** as **permissões** definidas nos arquivos criados pelo app. Especificamente, **verifique** se algum arquivo está **definido como legível ou gravável mundialmente**. Isso pode representar um risco de segurança significativo, pois permitiria que **qualquer aplicação** instalada no dispositivo, independentemente de sua origem ou intenção, **leia ou modifique** esses arquivos.

**External Storage**

Ao lidar com arquivos em **external storage**, como SD Cards, certas precauções devem ser tomadas:

1. **Acessibilidade**:
- Arquivos em external storage são **globalmente legíveis e graváveis**. Isso significa que qualquer aplicação ou usuário pode acessar esses arquivos.
2. **Preocupações de Segurança**:
- Dada a facilidade de acesso, é recomendado **não armazenar informações sensíveis** em external storage.
- External storage pode ser removido ou acessado por qualquer aplicação, tornando-o menos seguro.
3. **Tratamento de dados vindos do External Storage**:
- Sempre **faça validação de input** nos dados recuperados do external storage. Isso é crucial porque os dados vêm de uma fonte não confiável.
- Armazenar executáveis ou arquivos de classe no external storage para carregamento dinâmico é fortemente desencorajado.
- Se sua aplicação precisar recuperar arquivos executáveis do external storage, assegure que esses arquivos estejam **assinados e verificados criptograficamente** antes de serem carregados dinamicamente. Esse passo é vital para manter a integridade de segurança da aplicação.

External storage pode ser **acessado** em `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> A partir do Android 4.4 (**API 17**), o SD card possui uma estrutura de diretório que **limita o acesso de um app ao diretório especificamente destinado a esse app**. Isso impede que aplicações maliciosas obtenham acesso de leitura ou escrita aos arquivos de outro app.

**Dados sensíveis armazenados em texto claro**

- **Shared preferences**: O Android permite que cada aplicação salve facilmente arquivos xml no caminho `/data/data/<packagename>/shared_prefs/` e às vezes é possível encontrar informação sensível em texto claro nessa pasta.
- **Databases**: O Android permite que cada aplicação salve facilmente bancos sqlite no caminho `/data/data/<packagename>/databases/` e às vezes é possível encontrar informação sensível em texto claro nessa pasta.

### Broken TLS

**Accept All Certificates**

Por alguma razão, às vezes desenvolvedores aceitam todos os certificados mesmo se, por exemplo, o hostname não corresponder, com trechos de código como o seguinte:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Criptografia quebrada

**Processos de Gestão de Chaves Fracos**

Alguns desenvolvedores salvam dados sensíveis no armazenamento local e encriptam-nos com uma chave hardcoded/preditível no código. Isso não deve ser feito, pois alguma engenharia reversa pode permitir que atacantes extraiam a informação confidencial.

**Uso de Algoritmos Inseguros e/ou Depreciados**

Desenvolvedores não devem usar **deprecated algorithms** para realizar verificações de autorização, armazenar ou enviar dados. Alguns desses algoritmos são: RC4, MD4, MD5, SHA1... Se **hashes** forem usados para armazenar passwords, por exemplo, devem ser usados hashes resistentes a **brute-force** com salt.

### Outras verificações

- É recomendado **obfuscate the APK** para dificultar o trabalho de reverse engineer aos atacantes.
- Se o app for sensível (como apps bancários), ele deve realizar seus **own checks to see if the mobile is rooted** e agir em conformidade.
- Se o app for sensível (como apps bancários), ele deve verificar se um **emulator** está a ser utilizado.
- Se o app for sensível (como apps bancários), ele deve **check it's own integrity before executing** para verificar se foi modificado.
- Use [**APKiD**](https://github.com/rednaga/APKiD) para verificar qual compiler/packer/obfuscator foi usado para construir o APK

### Aplicação React Native

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Aplicações Xamarin

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

A ferramenta [**mariana-trench**](https://github.com/facebook/mariana-trench) é capaz de encontrar **vulnerabilidades** ao **scanning** o **code** da aplicação. Esta ferramenta contém uma série de **known sources** (que indica ao tool os **lugares** onde o **input** é **controlled by the user**), **sinks** (que indica ao tool **dangerous** **places** onde input malicioso do utilizador poderia causar danos) e **rules**. Essas regras indicam a **combinação** de **sources-sinks** que sinaliza uma vulnerabilidade.

Com esse conhecimento, **mariana-trench vai revisar o código e encontrar possíveis vulnerabilidades nele**.

### Secrets leaked

An application may contain secrets (API keys, passwords, hidden urls, subdomains...) inside of it that you might be able to discover. You could us a tool such as [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Outras funções interessantes

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)
- In-memory native code execution via JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> First of all, you need an environment where you can install the application and all the environment (Burp CA cert, Drozer and Frida mainly). Therefore, a rooted device (emulated or not) is extremely recommended.

### Online Dynamic analysis

You can create a **free account** in: [https://appetize.io/](https://appetize.io). This platform allows you to **upload** and **execute** APKs, so it is useful to see how an apk is behaving.

You can even **see the logs of your application** in the web and connect through **adb**.

![](<../../images/image (831).png>)

Thanks to the ADB connection you can use **Drozer** and **Frida** inside the emulators.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (You can create **x86** and **arm** devices, and according to [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** versions **support ARM libraries** without needing an slow arm emulator).
- Learn to set it up in this page:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, you need to create an account. _It's recommend to **download** the version **WITH**_ _**VirtualBox** to avoid potential errors._)
- [**Nox**](https://es.bignox.com) (Free, but it doesn't support Frida or Drozer).

> [!TIP]
> When creating a new emulator on any platform remember that the bigger the screen is, the slower the emulator will run. So select small screens if possible.

To **install google services** (like AppStore) in Genymotion you need to click on the red marked button of the following image:

![](<../../images/image (277).png>)

Also, notice that in the **configuration of the Android VM in Genymotion** you can select **Bridge Network mode** (this will be useful if you will be connecting to the Android VM from a different VM with the tools).

#### Use a physical device

You need to activate the **debugging** options and it will be cool if you can **root** it:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Once you have installed the application, the first thing you should do is to try it and investigate what does it do, how does it work and get comfortable with it.\
> I will suggest to **perform this initial dynamic analysis using MobSF dynamic analysis + pidcat**, so we will be able to **learn how the application works** while MobSF **captures** a lot of **interesting** **data** you can review later on.

Magisk/Zygisk quick notes (recommended on Pixel devices)
- Patch boot.img with the Magisk app and flash via fastboot to get systemless root
- Enable Zygisk + DenyList for root hiding; consider LSPosed/Shamiko when stronger hiding is required
- Keep original boot.img to recover from OTA updates; re-patch after each OTA
- For screen mirroring, use scrcpy on the host



### Unintended Data Leakage

**Logging**

Developers should be cautious of exposing **debugging information** publicly, as it can lead to sensitive data leaks. The tools [**pidcat**](https://github.com/JakeWharton/pidcat) and `adb logcat` are recommended for monitoring application logs to identify and protect sensitive information. **Pidcat** is favored for its ease of use and readability.

> [!WARNING]
> Note that from **later newer than Android 4.0**, **applications are only able to access their own logs**. So applications cannot access other apps logs.\
> Anyway, it's still recommended to **not log sensitive information**.

**Copy/Paste Buffer Caching**

Android's **clipboard-based** framework enables copy-paste functionality in apps, yet poses a risk as **other applications** can **access** the clipboard, potentially exposing sensitive data. It's crucial to **disable copy/paste** functions for sensitive sections of an application, like credit card details, to prevent data leaks.

**Crash Logs**

If an application **crashes** and **saves logs**, these logs can assist attackers, particularly when the application cannot be reverse-engineered. To mitigate this risk, avoid logging on crashes, and if logs must be transmitted over the network, ensure they are sent via an **SSL** channel for security.

As pentester, **try to take a look to these logs**.

**Analytics Data Sent To 3rd Parties**

Applications often integrate services like Google Adsense, which can inadvertently **leak sensitive data** due to improper implementation by developers. To identify potential data leaks, it's advisable to **intercept the application's traffic** and check for any sensitive information being sent to third-party services.

### SQLite DBs

Most of the applications will use **internal SQLite databases** to save information. During the pentest take a **look** to the **databases** created, the names of **tables** and **columns** and all the **data** saved because you could find **sensitive information** (which would be a vulnerability).\
Databases should be located in `/data/data/the.package.name/databases` like `/data/data/com.mwr.example.sieve/databases`

If the database is saving confidential information and is **criptografado** mas você pode **encontrar** a **senha** dentro da aplicação, ainda é uma **vulnerabilidade**.

Enumerate the tables using `.tables` and enumerate the columns of the tables doing `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer is s useful tool to **exploit exported activities, exported services and Content Providers** as you will learn in the following sections.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Also remember that the code of an activity starts in the **`onCreate`** method.

**Authorisation bypass**

When an Activity is exported you can invoke its screen from an external app. Therefore, if an activity with **sensitive information** is **exported** you could **bypass** the **authentication** mechanisms **to access it.**

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

You can also start an exported activity from adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTA**: MobSF irá detectar como malicioso o uso de _**singleTask/singleInstance**_ como `android:launchMode` em uma activity, mas devido a [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), aparentemente isso é perigoso apenas em versões antigas (API versions < 21).

> [!TIP]
> Observe que um authorisation bypass nem sempre é uma vulnerabilidade; isso depende de como o bypass funciona e quais informações são expostas.

**Vazamento de informações sensíveis**

**Activities podem também retornar resultados**. Se você conseguir encontrar uma activity exportada e desprotegida que chame o método **`setResult`** e **retorne informações sensíveis**, há um vazamento de informações sensíveis.

#### Tapjacking

Se o tapjacking não for prevenido, você pode abusar da activity exportada para fazer o **usuário realizar ações inesperadas**. Para mais info sobre [**o que é Tapjacking siga o link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Leia isto se quiser relembrar o que é um Content Provider.**](android-applications-basics.md#content-provider)\
Content providers são basicamente usados para **compartilhar dados**. Se um app possui content providers disponíveis você pode ser capaz de **extrair dados sensíveis** deles. Também é interessante testar possíveis **SQL injections** e **Path Traversals**, pois podem ser vulneráveis.

[**Aprenda a explorar Content Providers com Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Leia isto se quiser relembrar o que é um Service.**](android-applications-basics.md#services)\
Lembre-se de que as ações de um Service começam no método `onStartCommand`.

Um service é basicamente algo que **pode receber dados**, **processá-los** e **retornar** (ou não) uma resposta. Então, se uma aplicação está exportando alguns services você deve **verificar** o **código** para entender o que ele está fazendo e **testá-lo** **dinamicamente** para extrair informações confidenciais, bypassing authentication measures...\
[**Aprenda a explorar Services com Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Leia isto se quiser relembrar o que é um Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Lembre-se de que as ações de um Broadcast Receiver começam no método `onReceive`.

Um broadcast receiver ficará aguardando um tipo de mensagem. Dependendo de como o receiver trata a mensagem, ele pode ser vulnerável.\
[**Aprenda a explorar Broadcast Receivers com Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Você pode procurar por deep links manualmente, usando ferramentas como MobSF ou scripts como [este](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Você pode **abrir** um scheme declarado usando **adb** ou um **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Observe que você pode **omitir o nome do pacote** e o dispositivo móvel chamará automaticamente o app que deve abrir esse link._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Código executado**

Para encontrar o **código que será executado no App**, vá para a activity chamada pelo deeplink e procure a função **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Informação sensível**

Sempre que encontrar um deeplink verifique se **ele não está recebendo dados sensíveis (como senhas) via parâmetros da URL**, porque qualquer outra aplicação poderia **se passar pelo deeplink e roubar esses dados!**

**Parâmetros no path**

Você **deve também verificar se algum deeplink está usando um parâmetro dentro do path** da URL como: `https://api.example.com/v1/users/{username}`, nesse caso você pode forçar um path traversal acessando algo como: `example://app/users?username=../../unwanted-endpoint%3fparam=value`.\
Note que se você encontrar os endpoints corretos dentro da aplicação pode ser capaz de causar um **Open Redirect** (se parte do path for usada como nome de domínio), **account takeover** (se você conseguir modificar detalhes de usuários sem CSRF token e o endpoint vuln usou o método correto) e qualquer outra vuln. Mais [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**Mais exemplos**

Um [interesting bug bounty report](https://hackerone.com/reports/855618) sobre links (_/.well-known/assetlinks.json_).

### Transport Layer Inspection and Verification Failures

- **Certificados nem sempre são inspecionados corretamente** por aplicações Android. É comum que essas aplicações ignorem avisos e aceitem certificados autoassinados ou, em alguns casos, revertam para conexões HTTP.
- **As negociações durante o handshake SSL/TLS às vezes são fracas**, usando cipher suites inseguros. Essa vulnerabilidade torna a conexão suscetível a ataques man-in-the-middle (MITM), permitindo que atacantes decifrem os dados.
- **Leakage of private information** é um risco quando aplicações autenticam usando canais seguros mas então comunicam por canais não seguros para outras transações. Essa abordagem falha em proteger dados sensíveis, como cookies de sessão ou detalhes do usuário, contra interceptação por entidades maliciosas.

#### Certificate Verification

Nos concentraremos na **verificação de certificados**. A integridade do certificado do servidor deve ser verificada para aumentar a segurança. Isso é crucial porque configurações TLS inseguras e a transmissão de dados sensíveis por canais não encriptados podem representar riscos significativos. Para passos detalhados sobre verificar certificados de servidor e mitigar vulnerabilidades, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) fornece orientação abrangente.

#### SSL Pinning

SSL Pinning é uma medida de segurança onde a aplicação verifica o certificado do servidor contra uma cópia conhecida armazenada dentro da própria aplicação. Esse método é essencial para prevenir ataques man-in-the-middle (MITM). Implementar SSL Pinning é fortemente recomendado para aplicações que lidam com informações sensíveis.

#### Traffic Inspection

Para inspecionar o tráfego HTTP, é necessário **instalar o certificado da ferramenta proxy** (por exemplo, Burp). Sem instalar esse certificado, o tráfego encriptado pode não ser visível através do proxy. Para um guia sobre como instalar um certificado CA customizado, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Aplicações que têm como target **API Level 24 and above** requerem modificações no Network Security Config para aceitar o certificado CA do proxy. Esse passo é crítico para inspecionar tráfego encriptado. Para instruções sobre como modificar o Network Security Config, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

Se **Flutter** estiver sendo usado, você precisa seguir as instruções em [**this page**](flutter.md). Isso porque apenas adicionar o certificado ao store não funcionará, já que o Flutter tem sua própria lista de CAs válidas.

#### Static detection of SSL/TLS pinning

Antes de tentar bypasses em runtime, mapeie rapidamente onde o pinning é aplicado no APK. A descoberta estática ajuda a planejar hooks/patches e a focar nos caminhos de código corretos.

Tool: SSLPinDetect
- Utilitário open-source de análise estática que decompila o APK para Smali (via apktool) e busca por padrões regex selecionados de implementações de SSL/TLS pinning.
- Reporta o caminho exato do arquivo, número da linha e um snippet de código para cada correspondência.
- Cobre frameworks comuns e caminhos de código customizados: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

Install
- Pré-requisitos: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Uso
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Exemplo de regras de padrão (JSON)
Use ou estenda signatures para detectar estilos proprietários/personalizados de pinning. Você pode carregar seu próprio JSON e escanear em larga escala.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes and tips
- Varredura rápida em apps grandes via multi-threading e memory-mapped I/O; regex pré-compiladas reduzem overhead/falsos positivos.
- Coleção de padrões: https://github.com/aancw/smali-sslpin-patterns
- Alvos típicos de detecção para triagem a seguir:
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- TrustManagers personalizados: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- SSL contexts personalizados: SSLContext.getInstance + SSLContext.init com managers customizados
- Pins declarativos em res/xml network security config e referências no manifest
- Use os locais correspondentes para planejar Frida hooks, static patches, ou revisões de config antes do teste dinâmico.



#### Bypassing SSL Pinning

Quando SSL Pinning está implementado, contorná-lo torna-se necessário para inspecionar o tráfego HTTPS. Vários métodos estão disponíveis para esse propósito:

- Automaticamente **modify** o **apk** para **bypass** SSLPinning com [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). A maior vantagem desta opção é que você não precisará de root para contornar o SSL Pinning, mas será necessário deletar o aplicativo e reinstalar a nova versão, e isso nem sempre funciona.
- Você pode usar **Frida** (discutido abaixo) para contornar essa proteção. Aqui está um guia para usar Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Você também pode tentar **automatically bypass SSL Pinning** usando [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Você também pode tentar **automatically bypass SSL Pinning** usando **MobSF dynamic analysis** (explicado abaixo)
- Se você ainda acha que há tráfego que não está capturando, pode tentar encaminhar o tráfego para burp usando iptables. Leia este blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Looking for Common Web Vulnerabilities

Também é importante buscar por vulnerabilidades web comuns dentro da aplicação. Informações detalhadas sobre identificação e mitigação dessas vulnerabilidades estão além do escopo deste resumo, mas são amplamente cobertas em outros locais.

### Frida

[Frida](https://www.frida.re) é uma toolkit de instrumentação dinâmica para developers, reverse-engineers e security researchers.\
**Você pode acessar a aplicação em execução e hook methods em tempo de execução para alterar o comportamento, modificar valores, extrair valores, executar código diferente...**\
Se você quer pentest aplicações Android, precisa saber como usar Frida.

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Algumas "GUI" para ações com Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection é ótimo para automatizar o uso do Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Você pode encontrar alguns Awesome Frida scripts aqui: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Tente contornar mecanismos anti-debugging / anti-frida carregando o Frida conforme indicado em [https://erfur.github.io/blog/dev/code-injection-without-ptrace] (ferramenta [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

Verifique se a aplicação está armazenando informações sensíveis na memória que não deveria, como senhas ou mnemonics.

Usando [**Fridump3**](https://github.com/rootbsd/fridump3) você pode dumpar a memória do app com:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Isso vai despejar a memória na pasta ./dump, e lá você pode usar grep com algo como:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Sensitive data in Keystore**

No Android o Keystore é o melhor lugar para armazenar dados sensíveis, no entanto, com privilégios suficientes ainda é **possível acessá-lo**. Como as aplicações tendem a armazenar aqui **dados sensíveis em texto claro**, os pentests devem verificar isso, pois um usuário root ou alguém com acesso físico ao dispositivo pode roubar esses dados.

Mesmo que um app armazene dados no keystore, os dados devem estar criptografados.

Para acessar os dados dentro do keystore você pode usar este script do Frida: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Usando o seguinte script do Frida, pode ser possível **bypass fingerprint authentication** que aplicações Android podem realizar para **proteger certas áreas sensíveis:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Imagens de fundo**

Quando você coloca um aplicativo em segundo plano, o Android armazena um **snapshot da aplicação** para que, quando for recuperado ao primeiro plano, comece a carregar a imagem antes do app, fazendo com que pareça que o aplicativo foi carregado mais rápido.

No entanto, se esse snapshot contiver **informações sensíveis**, alguém com acesso ao snapshot pode **roubar essas informações** (observe que você precisa de root para acessá-lo).

Os snapshots geralmente são armazenados em: **`/data/system_ce/0/snapshots`**

Android fornece uma forma de **impedir a captura de tela definindo o FLAG_SECURE** como parâmetro de layout. Ao usar essa flag, o conteúdo da janela é tratado como seguro, impedindo que apareça em capturas de tela ou que seja visualizado em telas não seguras.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Esta ferramenta pode ajudar você a gerenciar diferentes ferramentas durante a análise dinâmica: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Desenvolvedores frequentemente criam componentes proxy como activities, services e broadcast receivers que recebem esses Intents e os passam para métodos como `startActivity(...)` ou `sendBroadcast(...)`, o que pode ser arriscado.

O perigo está em permitir que atacantes acionem componentes não-exportados do app ou acessem content providers sensíveis ao redirecionar esses Intents. Um exemplo notável é o componente `WebView` que converte URLs em objetos `Intent` via `Intent.parseUri(...)` e então os executa, potencialmente levando a injeções maliciosas de Intent.

### Principais conclusões

- **Intent Injection** is similar to web's Open Redirect issue.
- Exploits involve passing `Intent` objects as extras, which can be redirected to execute unsafe operations.
- It can expose non-exported components and content providers to attackers.
- `WebView`’s URL to `Intent` conversion can facilitate unintended actions.

### Android Client Side Injections and others

Provavelmente você já conhece esse tipo de vulnerabilidade da Web. É preciso ter cuidado especial com essas vulnerabilidades em uma aplicação Android:

- **SQL Injection:** Ao lidar com queries dinâmicas ou Content-Providers, certifique-se de utilizar consultas parametrizadas.
- **JavaScript Injection (XSS):** Verifique se o suporte a JavaScript e Plugins está desativado para qualquer WebView (desativado por padrão). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews should have access to the file system disabled (enabled by default) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: Em vários casos, quando a aplicação Android encerra a sessão o cookie não é revogado ou pode até ser salvo no disco
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Análise Automática

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Análise estática**

![](<../../images/image (866).png>)

**Avaliação de vulnerabilidades da aplicação** usando uma interface web amigável. Você também pode realizar análise dinâmica (mas precisa preparar o ambiente).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Observe que MobSF pode analisar **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Além disso, se você criar um arquivo **ZIP** com o código-fonte de um app **Android** ou **IOS** (vá para a pasta raiz da aplicação, selecione tudo e crie um ZIPfile), ele também será capaz de analisá-lo.

MobSF também permite **diff/Compare** análises e integrar o **VirusTotal** (você precisará configurar sua API key em _MobSF/settings.py_ e habilitá-la: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). Você também pode definir `VT_UPLOAD` para `False`, então o **hash** será **upload** em vez do arquivo.

### Assisted Dynamic analysis with MobSF

**MobSF** também pode ser muito útil para **dynamic analysis** em **Android**, mas nesse caso você precisará instalar MobSF e **genymotion** no seu host (uma VM ou Docker não funcionarão). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
O **MobSF dynamic analyser** pode:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). Tudo isso é feito automaticamente, exceto as screenshots — você precisa pressionar quando quiser uma screenshot ou pressionar "**Exported Activity Tester**" para obter screenshots de todas as exported activities.
- Capture **HTTPS traffic**
- Use **Frida** para obter **runtime** **information**

Em versões do **Android** > 5, ele **automatically start Frida** e vai configurar as definições globais de **proxy** para **capture** o tráfego. Ele só capturará o tráfego da aplicação testada.

**Frida**

Por padrão, ele também usa alguns Frida Scripts para **bypass SSL pinning**, **root detection** e **debugger detection** e para **monitor interesting APIs**.\
MobSF também pode **invoke exported activities**, capturar **screenshots** delas e **save** para o relatório.

Para **start** o teste dinâmico pressione o botão verde: "**Start Instrumentation**". Pressione "**Frida Live Logs**" para ver os logs gerados pelos Frida scripts e "**Live API Monitor**" para ver todas as invocações para métodos hookeados, argumentos passados e valores retornados (isso aparecerá após pressionar "Start Instrumentation").\
MobSF também permite carregar seus próprios **Frida scripts** (para enviar os resultados dos seus Frida scripts para o MobSF use a função `send()`). Também possui **vários scripts pré-escritos** que você pode carregar (você pode adicionar mais em `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), basta **selecioná-los**, pressionar "**Load**" e pressionar "**Start Instrumentation**" (você poderá ver os logs desses scripts dentro de "**Frida Live Logs**").

![](<../../images/image (419).png>)

Além disso, você tem algumas funcionalidades auxiliares do Frida:

- **Enumerate Loaded Classes**: Irá listar todas as classes carregadas
- **Capture Strings**: Irá imprimir todas as strings capturadas enquanto usa a aplicação (muito ruidoso)
- **Capture String Comparisons**: Pode ser muito útil. Irá **mostrar as 2 strings sendo comparadas** e se o resultado foi True ou False.
- **Enumerate Class Methods**: Insira o nome da classe (por exemplo "java.io.File") e ele irá listar todos os métodos da classe.
- **Search Class Pattern**: Busca classes por padrão
- **Trace Class Methods**: **Trace** uma **classe inteira** (veja entradas e saídas de todos os métodos da classe). Lembre-se que por padrão o MobSF traça vários métodos interessantes da Android Api.

Uma vez que você tenha selecionado o módulo auxiliar que deseja usar, precisa pressionar "**Start Intrumentation**" e verá todas as saídas em "**Frida Live Logs**".

**Shell**

Mobsf também traz um shell com alguns comandos **adb**, **MobSF commands**, e comandos comuns de **shell** na parte inferior da página de dynamic analysis. Alguns comandos interessantes:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**Ferramentas HTTP**

Quando o tráfego HTTP for capturado você pode ver uma visualização bruta do tráfego capturado no botão "**HTTP(S) Traffic**" ou uma visualização mais agradável no botão verde "**Start HTTPTools**". A partir da segunda opção, você pode **enviar** as **captured requests** para **proxies** como Burp ou Owasp ZAP.\
Para fazer isso, _ligue o Burp -->_ _desative o Intercept --> no MobSB HTTPTools selecione a request_ --> pressione "**Send to Fuzzer**" --> _selecione o endereço do proxy_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Uma vez que você termine a análise dinâmica com MobSF você pode pressionar "**Start Web API Fuzzer**" para **fuzz http requests** e procurar por vulnerabilidades.

> [!TIP]
> Após realizar uma análise dinâmica com MobSF as configurações de proxy podem ficar mal configuradas e você não conseguirá corrigi-las pela GUI. Você pode corrigir as configurações de proxy executando:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Análise dinâmica assistida com Inspeckage

Você pode obter a ferramenta em [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Esta ferramenta usa alguns **Hooks** para informar **o que está acontecendo no aplicativo** enquanto você realiza uma **análise dinâmica**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Esta é uma **ótima ferramenta para realizar análise estática com uma GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Esta ferramenta foi projetada para procurar várias **vulnerabilidades relacionadas à segurança em aplicações Android**, seja no **código-fonte** ou em **APKs empacotados**. A ferramenta também é **capaz de criar um APK implantável "Proof-of-Concept"** e **ADB commands**, para explorar algumas das vulnerabilidades encontradas (Exposed activities, intents, tapjacking...). Assim como com Drozer, não há necessidade de root no dispositivo de teste.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Exibe todos os arquivos extraídos para referência rápida
- Descompila automaticamente arquivos APK para os formatos Java e Smali
- Analisa AndroidManifest.xml em busca de vulnerabilidades e comportamentos comuns
- Análise estática de código-fonte em busca de vulnerabilidades e comportamentos comuns
- Informações do dispositivo
- e mais
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER é uma aplicação de linha de comando que pode ser usada no Windows, MacOS X e Linux, que analisa arquivos _.apk_ em busca de vulnerabilidades. Ele faz isso descomprimindo APKs e aplicando uma série de regras para detectar essas vulnerabilidades.

Todas as regras estão centralizadas em um arquivo `rules.json`, e cada empresa ou testador pode criar suas próprias regras para analisar o que for necessário.

Faça o download dos binários mais recentes na [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn é uma ferramenta **crossplatform** que auxilia desenvolvedores, bugbounty hunters e ethical hackers na realização de [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) em aplicações móveis.

O conceito é que você arraste e solte o arquivo da sua aplicação móvel (um arquivo .apk ou .ipa) na aplicação StaCoAn, e ela gerará um relatório visual e portátil para você. Você pode ajustar as configurações e wordlists para obter uma experiência personalizada.

Baixe[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework é um sistema de análise de vulnerabilidades para Android que ajuda desenvolvedores ou hackers a encontrar potenciais vulnerabilidades de segurança em aplicações Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** é uma ferramenta cujo objetivo principal é detectar e alertar o usuário sobre potenciais comportamentos maliciosos desenvolvidos por uma aplicação Android.

A detecção é realizada por meio da **static analysis** do bytecode Dalvik da aplicação, representado como **Smali**, usando a biblioteca [`androguard`](https://github.com/androguard/androguard).

Esta ferramenta procura por **comportamentos comuns de aplicações "maliciosas"** como: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. É uma ferramenta que reúne ferramentas comumente usadas para engenharia reversa e análise de aplicações móveis, para auxiliar nos testes de aplicações móveis contra as ameaças de segurança mobile do OWASP. Seu objetivo é tornar essa tarefa mais fácil e amigável para desenvolvedores de aplicações móveis e profissionais de segurança.

It is able to:

- Extract Java and Smali code using different tools
- Analyze APKs using: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Extract private information from the APK using regexps.
- Analyze the Manifest.
- Analyze found domains using: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Útil para detectar malware: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Observe que, dependendo do serviço e da configuração que você usa para ofuscar o código, os segredos podem ou não acabar ofuscados.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. It is able to optimize bytecode as well as detect and remove unused instructions. ProGuard is free software and is distributed under the GNU General Public License, version 2.

ProGuard is distributed as part of the Android SDK and runs when building the application in release mode.

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Last time we checked, the Dexguard mode of operation was:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

Você pode enviar um APK ofuscado para a plataforma deles.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

It is a **generic android deobfuscator.** Simplify **virtually executes an app** to understand its behavior and then **tries to optimize the code** so it behaves identically but is easier for a human to understand. Each optimization type is simple and generic, so it doesn't matter what the specific type of obfuscation is used.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD gives you information about **how an APK was made**. It identifies many **compilers**, **packers**, **obfuscators**, and other weird stuff. It's [_PEiD_](https://www.aldeid.com/wiki/PEiD) for Android.

### Manual

[Leia este tutorial para aprender alguns truques sobre **como reverter obfuscação customizada**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b é uma máquina virtual de segurança Android baseada em ubuntu-mate que inclui a coleção dos frameworks, tutoriais e labs mais recentes de diversos entusiastas e pesquisadores de segurança para engenharia reversa e análise de malware.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) É uma ótima lista de recursos
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Curso rápido de Android
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
