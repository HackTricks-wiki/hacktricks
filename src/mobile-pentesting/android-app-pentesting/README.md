# Teste de Penetração em Aplicações Android

{{#include ../../banners/hacktricks-training.md}}

## Fundamentos de Aplicações Android

É altamente recomendável começar a ler esta página para conhecer as **partes mais importantes relacionadas à segurança do Android e os componentes mais perigosos em uma aplicação Android**:

{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Esta é a principal ferramenta que você precisa para se conectar a um dispositivo Android (emulado ou físico).\
**ADB** permite controlar dispositivos tanto via **USB** quanto via **Rede** a partir de um computador. Esta utilidade possibilita a **cópia** de arquivos em ambas as direções, **instalação** e **desinstalação** de aplicativos, **execução** de comandos de shell, **backup** de dados, **leitura** de logs, entre outras funções.

Dê uma olhada na lista de [**Comandos ADB**](adb-commands.md) para aprender como usar o adb.

## Smali

Às vezes, é interessante **modificar o código da aplicação** para acessar **informações ocultas** (talvez senhas ou flags bem ofuscadas). Então, pode ser interessante descompilar o apk, modificar o código e recompilá-lo.\
[**Neste tutorial** você pode **aprender como descompilar um APK, modificar o código Smali e recompilar o APK** com a nova funcionalidade](smali-changes.md). Isso pode ser muito útil como uma **alternativa para vários testes durante a análise dinâmica** que serão apresentados. Então, **mantenha sempre em mente essa possibilidade**.

## Outros truques interessantes

- [Falsificando sua localização na Play Store](spoofing-your-location-in-play-store.md)
- **Baixar APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Extrair APK do dispositivo:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Mescle todos os splits e apks base com [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Análise Estática

Primeiramente, para analisar um APK você deve **dar uma olhada no código Java** usando um decompilador.\
Por favor, [**leia aqui para encontrar informações sobre diferentes decompiladores disponíveis**](apk-decompilers.md).

### Procurando informações interessantes

Apenas dando uma olhada nas **strings** do APK você pode procurar por **senhas**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **chaves** **api**, **criptografia**, **bluetooth uuids**, **tokens** e qualquer coisa interessante... procure até por **backdoors** de execução de código ou backdoors de autenticação (credenciais de admin hardcoded para o app).

**Firebase**

Preste atenção especial às **URLs do firebase** e verifique se está mal configurado. [Mais informações sobre o que é o Firebase e como explorá-lo aqui.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Compreensão básica da aplicação - Manifest.xml, strings.xml

A **examinação dos arquivos \_Manifest.xml**_\*\* e \*\*_**strings.xml**\_\*\* pode revelar potenciais vulnerabilidades de segurança\*\*. Esses arquivos podem ser acessados usando decompiladores ou renomeando a extensão do arquivo APK para .zip e, em seguida, descompactando-o.

**Vulnerabilidades** identificadas a partir do **Manifest.xml** incluem:

- **Aplicações Debugáveis**: Aplicações configuradas como debuggable (`debuggable="true"`) no arquivo _Manifest.xml_ representam um risco, pois permitem conexões que podem levar à exploração. Para uma melhor compreensão sobre como explorar aplicações debuggable, consulte um tutorial sobre como encontrar e explorar aplicações debuggable em um dispositivo.
- **Configurações de Backup**: O atributo `android:allowBackup="false"` deve ser explicitamente definido para aplicações que lidam com informações sensíveis para evitar backups de dados não autorizados via adb, especialmente quando a depuração USB está habilitada.
- **Segurança de Rede**: Configurações de segurança de rede personalizadas (`android:networkSecurityConfig="@xml/network_security_config"`) em _res/xml/_ podem especificar detalhes de segurança como pins de certificado e configurações de tráfego HTTP. Um exemplo é permitir tráfego HTTP para domínios específicos.
- **Atividades e Serviços Exportados**: Identificar atividades e serviços exportados no manifesto pode destacar componentes que podem ser mal utilizados. Uma análise adicional durante os testes dinâmicos pode revelar como explorar esses componentes.
- **Content Providers e FileProviders**: Content providers expostos podem permitir acesso ou modificação não autorizada de dados. A configuração de FileProviders também deve ser analisada.
- **Broadcast Receivers e URL Schemes**: Esses componentes podem ser aproveitados para exploração, com atenção especial a como os esquemas de URL são gerenciados para vulnerabilidades de entrada.
- **Versões do SDK**: Os atributos `minSdkVersion`, `targetSDKVersion` e `maxSdkVersion` indicam as versões do Android suportadas, destacando a importância de não suportar versões do Android desatualizadas e vulneráveis por razões de segurança.

A partir do arquivo **strings.xml**, informações sensíveis como chaves de API, esquemas personalizados e outras notas de desenvolvedor podem ser descobertas, sublinhando a necessidade de uma revisão cuidadosa desses recursos.

### Tapjacking

**Tapjacking** é um ataque onde uma **aplicação maliciosa** é lançada e **se posiciona em cima de uma aplicação vítima**. Uma vez que obscurece visivelmente o app vítima, sua interface de usuário é projetada de tal forma a enganar o usuário a interagir com ela, enquanto passa a interação para o app vítima.\
Na prática, isso **cega o usuário para saber que ele está realmente realizando ações no app vítima**.

Encontre mais informações em:

{{#ref}}
tapjacking.md
{{#endref}}

### Sequestro de Tarefa

Uma **atividade** com o **`launchMode`** definido como **`singleTask` sem qualquer `taskAffinity`** definido é vulnerável ao sequestro de tarefa. Isso significa que uma **aplicação** pode ser instalada e, se lançada antes da aplicação real, pode **sequestrar a tarefa da aplicação real** (portanto, o usuário estará interagindo com a **aplicação maliciosa pensando que está usando a real**).

Mais informações em:

{{#ref}}
android-task-hijacking.md
{{#endref}}

### Armazenamento de dados inseguro

**Armazenamento Interno**

No Android, arquivos **armazenados** em **armazenamento interno** são **projetados** para serem **acessíveis** exclusivamente pelo **app** que os **criou**. Essa medida de segurança é **imposta** pelo sistema operacional Android e geralmente é adequada para as necessidades de segurança da maioria das aplicações. No entanto, os desenvolvedores às vezes utilizam modos como `MODE_WORLD_READABLE` e `MODE_WORLD_WRITABLE` para **permitir** que arquivos sejam **compartilhados** entre diferentes aplicações. No entanto, esses modos **não restringem o acesso** a esses arquivos por outras aplicações, incluindo aquelas potencialmente maliciosas.

1. **Análise Estática:**
- **Assegure-se** de que o uso de `MODE_WORLD_READABLE` e `MODE_WORLD_WRITABLE` seja **cuidadosamente analisado**. Esses modos **podem potencialmente expor** arquivos a **acessos não intencionais ou não autorizados**.
2. **Análise Dinâmica:**
- **Verifique** as **permissões** definidas em arquivos criados pelo app. Especificamente, **verifique** se algum arquivo está **definido para ser legível ou gravável globalmente**. Isso pode representar um risco significativo à segurança, pois permitiria que **qualquer aplicação** instalada no dispositivo, independentemente de sua origem ou intenção, **lesse ou modificasse** esses arquivos.

**Armazenamento Externo**

Ao lidar com arquivos em **armazenamento externo**, como cartões SD, certas precauções devem ser tomadas:

1. **Acessibilidade**:
- Arquivos em armazenamento externo são **globalmente legíveis e graváveis**. Isso significa que qualquer aplicação ou usuário pode acessar esses arquivos.
2. **Preocupações de Segurança**:
- Dada a facilidade de acesso, é aconselhável **não armazenar informações sensíveis** em armazenamento externo.
- O armazenamento externo pode ser removido ou acessado por qualquer aplicação, tornando-o menos seguro.
3. **Manipulação de Dados do Armazenamento Externo**:
- Sempre **realize validação de entrada** nos dados recuperados do armazenamento externo. Isso é crucial porque os dados vêm de uma fonte não confiável.
- Armazenar executáveis ou arquivos de classe em armazenamento externo para carregamento dinâmico é fortemente desencorajado.
- Se sua aplicação precisar recuperar arquivos executáveis do armazenamento externo, assegure-se de que esses arquivos sejam **assinados e verificados criptograficamente** antes de serem carregados dinamicamente. Essa etapa é vital para manter a integridade de segurança da sua aplicação.

O armazenamento externo pode ser **acessado** em `/storage/emulated/0`, `/sdcard`, `/mnt/sdcard`

> [!NOTE]
> A partir do Android 4.4 (**API 17**), o cartão SD possui uma estrutura de diretório que **limita o acesso de um app ao diretório que é especificamente para aquele app**. Isso impede que aplicações maliciosas ganhem acesso de leitura ou gravação aos arquivos de outro app.

**Dados sensíveis armazenados em texto claro**

- **Preferências compartilhadas**: O Android permite que cada aplicação salve facilmente arquivos xml no caminho `/data/data/<packagename>/shared_prefs/` e às vezes é possível encontrar informações sensíveis em texto claro nessa pasta.
- **Bancos de dados**: O Android permite que cada aplicação salve facilmente bancos de dados sqlite no caminho `/data/data/<packagename>/databases/` e às vezes é possível encontrar informações sensíveis em texto claro nessa pasta.

### TLS Quebrado

**Aceitar Todos os Certificados**

Por algum motivo, às vezes os desenvolvedores aceitam todos os certificados, mesmo que, por exemplo, o nome do host não corresponda a linhas de código como a seguinte:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Uma boa maneira de testar isso é tentar capturar o tráfego usando algum proxy como Burp sem autorizar o Burp CA dentro do dispositivo. Além disso, você pode gerar com o Burp um certificado para um hostname diferente e usá-lo.

### Quebra de Criptografia

**Processos de Gerenciamento de Chaves Ruins**

Alguns desenvolvedores salvam dados sensíveis no armazenamento local e os criptografam com uma chave hardcoded/predizível no código. Isso não deve ser feito, pois alguma engenharia reversa pode permitir que atacantes extraiam as informações confidenciais.

**Uso de Algoritmos Inseguros e/ou Obsoletos**

Os desenvolvedores não devem usar **algoritmos obsoletos** para realizar **verificações de autorização**, **armazenar** ou **enviar** dados. Alguns desses algoritmos são: RC4, MD4, MD5, SHA1... Se **hashes** forem usados para armazenar senhas, por exemplo, hashes resistentes a força bruta **devem** ser usados com sal.

### Outras verificações

- É recomendado **ofuscar o APK** para dificultar o trabalho de engenharia reversa para os atacantes.
- Se o aplicativo for sensível (como aplicativos bancários), ele deve realizar suas **próprias verificações para ver se o celular está rooteado** e agir em consequência.
- Se o aplicativo for sensível (como aplicativos bancários), ele deve verificar se um **emulador** está sendo usado.
- Se o aplicativo for sensível (como aplicativos bancários), ele deve **verificar sua própria integridade antes de executar** para checar se foi modificado.
- Use [**APKiD**](https://github.com/rednaga/APKiD) para verificar qual compilador/pacote/ofuscador foi usado para construir o APK.

### Aplicação React Native

Leia a página a seguir para aprender como acessar facilmente o código javascript de aplicações React:

{{#ref}}
react-native-application.md
{{#endref}}

### Aplicações Xamarin

Leia a página a seguir para aprender como acessar facilmente o código C# de aplicações xamarin:

{{#ref}}
../xamarin-apps.md
{{#endref}}

### Aplicações Superpacked

De acordo com este [**post de blog**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/), superpacked é um algoritmo Meta que comprime o conteúdo de uma aplicação em um único arquivo. O blog fala sobre a possibilidade de criar um aplicativo que descompacte esses tipos de aplicativos... e uma maneira mais rápida que envolve **executar a aplicação e coletar os arquivos descompactados do sistema de arquivos.**

### Análise Estática Automatizada de Código

A ferramenta [**mariana-trench**](https://github.com/facebook/mariana-trench) é capaz de encontrar **vulnerabilidades** ao **escanear** o **código** da aplicação. Esta ferramenta contém uma série de **fontes conhecidas** (que indicam ao ferramenta os **lugares** onde a **entrada** é **controlada pelo usuário**), **sinks** (que indicam ao ferramenta **lugares perigosos** onde a entrada maliciosa do usuário pode causar danos) e **regras**. Essas regras indicam a **combinação** de **fontes-sinks** que indicam uma vulnerabilidade.

Com esse conhecimento, **mariana-trench revisará o código e encontrará possíveis vulnerabilidades nele**.

### Segredos vazados

Uma aplicação pode conter segredos (chaves de API, senhas, URLs ocultas, subdomínios...) dentro dela que você pode ser capaz de descobrir. Você poderia usar uma ferramenta como [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks).

### Bypass de Autenticação Biométrica

{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Outras funções interessantes

- **Execução de código**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Enviar SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Funções nativas** declaradas como `native`: `public native, System.loadLibrary, System.load`
- [Leia isso para aprender **como reverter funções nativas**](reversing-native-libraries.md)

### **Outras dicas**

{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Análise Dinâmica

> Primeiro de tudo, você precisa de um ambiente onde possa instalar a aplicação e todo o ambiente (certificado Burp CA, Drozer e Frida principalmente). Portanto, um dispositivo rooteado (emulado ou não) é extremamente recomendado.

### Análise dinâmica online

Você pode criar uma **conta gratuita** em: [https://appetize.io/](https://appetize.io). Esta plataforma permite que você **faça upload** e **execute** APKs, então é útil para ver como um apk está se comportando.

Você pode até **ver os logs da sua aplicação** na web e se conectar através do **adb**.

![](<../../images/image (831).png>)

Graças à conexão ADB, você pode usar **Drozer** e **Frida** dentro dos emuladores.

### Análise dinâmica local

#### Usando um emulador

- [**Android Studio**](https://developer.android.com/studio) (Você pode criar dispositivos **x86** e **arm**, e de acordo com [**isso**](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**as últimas versões x86** **suportam bibliotecas ARM** sem precisar de um emulador arm lento).
- Aprenda a configurá-lo nesta página:

{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Versão gratuita:** Edição Pessoal, você precisa criar uma conta. _É recomendado **baixar** a versão **COM**_ _**VirtualBox** para evitar erros potenciais._)
- [**Nox**](https://es.bignox.com) (Gratuito, mas não suporta Frida ou Drozer).

> [!NOTE]
> Ao criar um novo emulador em qualquer plataforma, lembre-se de que quanto maior a tela, mais lento o emulador funcionará. Portanto, selecione telas pequenas, se possível.

Para **instalar os serviços do google** (como AppStore) no Genymotion, você precisa clicar no botão marcado em vermelho da imagem a seguir:

![](<../../images/image (277).png>)

Além disso, note que na **configuração da VM Android no Genymotion** você pode selecionar o **modo de rede Bridge** (isso será útil se você estiver se conectando à VM Android de uma VM diferente com as ferramentas).

#### Usar um dispositivo físico

Você precisa ativar as opções de **depuração** e será legal se você puder **rootear**:

1. **Configurações**.
2. (A partir do Android 8.0) Selecione **Sistema**.
3. Selecione **Sobre o telefone**.
4. Pressione **Número da versão** 7 vezes.
5. Volte e você encontrará as **Opções de desenvolvedor**.

> Uma vez que você tenha instalado a aplicação, a primeira coisa que você deve fazer é testá-la e investigar o que ela faz, como funciona e se familiarizar com ela.\
> Eu sugeriria **realizar esta análise dinâmica inicial usando a análise dinâmica do MobSF + pidcat**, para que possamos **aprender como a aplicação funciona** enquanto o MobSF **captura** muitos **dados interessantes** que você pode revisar mais tarde.

### Vazamento de Dados Não Intencionais

**Registro**

Os desenvolvedores devem ter cuidado ao expor **informações de depuração** publicamente, pois isso pode levar a vazamentos de dados sensíveis. As ferramentas [**pidcat**](https://github.com/JakeWharton/pidcat) e `adb logcat` são recomendadas para monitorar logs de aplicações para identificar e proteger informações sensíveis. **Pidcat** é preferido por sua facilidade de uso e legibilidade.

> [!WARNING]
> Note que a partir de **versões mais recentes que Android 4.0**, **as aplicações só podem acessar seus próprios logs**. Portanto, as aplicações não podem acessar os logs de outros aplicativos.\
> De qualquer forma, ainda é recomendado **não registrar informações sensíveis**.

**Cache de Buffer de Copiar/Colar**

O framework **baseado em clipboard** do Android permite funcionalidade de copiar e colar em aplicativos, mas apresenta um risco, pois **outros aplicativos** podem **acessar** o clipboard, potencialmente expondo dados sensíveis. É crucial **desabilitar funções de copiar/colar** para seções sensíveis de uma aplicação, como detalhes de cartão de crédito, para evitar vazamentos de dados.

**Logs de Crash**

Se uma aplicação **crash** e **salvar logs**, esses logs podem ajudar atacantes, especialmente quando a aplicação não pode ser revertida. Para mitigar esse risco, evite registrar em crashes, e se os logs precisarem ser transmitidos pela rede, assegure-se de que sejam enviados através de um canal SSL para segurança.

Como pentester, **tente dar uma olhada nesses logs**.

**Dados de Análise Enviados a Terceiros**

As aplicações frequentemente integram serviços como Google Adsense, que podem inadvertidamente **vazar dados sensíveis** devido à implementação inadequada pelos desenvolvedores. Para identificar possíveis vazamentos de dados, é aconselhável **interceptar o tráfego da aplicação** e verificar se há informações sensíveis sendo enviadas para serviços de terceiros.

### Bancos de Dados SQLite

A maioria das aplicações usará **bancos de dados SQLite internos** para salvar informações. Durante o pentest, dê uma **olhada** nos **bancos de dados** criados, os nomes das **tabelas** e **colunas** e todos os **dados** salvos, pois você pode encontrar **informações sensíveis** (o que seria uma vulnerabilidade).\
Os bancos de dados devem estar localizados em `/data/data/the.package.name/databases` como `/data/data/com.mwr.example.sieve/databases`.

Se o banco de dados estiver salvando informações confidenciais e estiver **criptografado**, mas você conseguir **encontrar** a **senha** dentro da aplicação, ainda é uma **vulnerabilidade**.

Enumere as tabelas usando `.tables` e enumere as colunas das tabelas fazendo `.schema <table_name>`.

### Drozer (Exploit Activities, Content Providers e Services)

Do [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** permite que você **assuma o papel de um aplicativo Android** e interaja com outros aplicativos. Ele pode fazer **qualquer coisa que um aplicativo instalado pode fazer**, como fazer uso do mecanismo de Comunicação Inter-Processo (IPC) do Android e interagir com o sistema operacional subjacente.\
Drozer é uma ferramenta útil para **explorar atividades exportadas, serviços exportados e Content Providers**, como você aprenderá nas seções seguintes.

### Explorando Atividades Exportadas

[**Leia isso se você quiser refrescar o que é uma Atividade Android.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Além disso, lembre-se de que o código de uma atividade começa no método **`onCreate`**.

**Bypass de Autorização**

Quando uma Atividade é exportada, você pode invocar sua tela de um aplicativo externo. Portanto, se uma atividade com **informações sensíveis** for **exportada**, você poderá **burlar** os mecanismos de **autenticação** **para acessá-la.**

[**Aprenda como explorar atividades exportadas com Drozer.**](drozer-tutorial/index.html#activities)

Você também pode iniciar uma atividade exportada a partir do adb:

- PackageName é com.example.demo
- Exported ActivityName é com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTA**: O MobSF detectará como malicioso o uso de _**singleTask/singleInstance**_ como `android:launchMode` em uma atividade, mas devido a [isso](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), aparentemente isso é perigoso apenas em versões antigas (versões da API < 21).

> [!NOTA]
> Note que uma bypass de autorização nem sempre é uma vulnerabilidade, isso dependerá de como o bypass funciona e quais informações são expostas.

**Vazamento de informações sensíveis**

**Atividades também podem retornar resultados**. Se você conseguir encontrar uma atividade exportada e desprotegida chamando o método **`setResult`** e **retornando informações sensíveis**, há um vazamento de informações sensíveis.

#### Tapjacking

Se o tapjacking não for prevenido, você pode abusar da atividade exportada para fazer o **usuário realizar ações inesperadas**. Para mais informações sobre [**o que é Tapjacking siga o link**](#tapjacking).

### Explorando Provedores de Conteúdo - Acessando e manipulando informações sensíveis

[**Leia isso se você quiser relembrar o que é um Provedor de Conteúdo.**](android-applications-basics.md#content-provider)\
Provedores de conteúdo são basicamente usados para **compartilhar dados**. Se um aplicativo tiver provedores de conteúdo disponíveis, você pode ser capaz de **extrair dados sensíveis** deles. Também é interessante testar possíveis **injeções SQL** e **Path Traversals**, pois podem ser vulneráveis.

[**Aprenda como explorar Provedores de Conteúdo com Drozer.**](drozer-tutorial/index.html#content-providers)

### **Explorando Serviços**

[**Leia isso se você quiser relembrar o que é um Serviço.**](android-applications-basics.md#services)\
Lembre-se de que as ações de um Serviço começam no método `onStartCommand`.

Um serviço é basicamente algo que **pode receber dados**, **processá-los** e **retornar** (ou não) uma resposta. Então, se um aplicativo estiver exportando alguns serviços, você deve **verificar** o **código** para entender o que ele está fazendo e **testá-lo** **dinamicamente** para extrair informações confidenciais, contornar medidas de autenticação...\
[**Aprenda como explorar Serviços com Drozer.**](drozer-tutorial/index.html#services)

### **Explorando Broadcast Receivers**

[**Leia isso se você quiser relembrar o que é um Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Lembre-se de que as ações de um Broadcast Receiver começam no método `onReceive`.

Um broadcast receiver estará esperando por um tipo de mensagem. Dependendo de como o receptor lida com a mensagem, ele pode ser vulnerável.\
[**Aprenda como explorar Broadcast Receivers com Drozer.**](#exploiting-broadcast-receivers)

### **Explorando Schemes / Deep links**

Você pode procurar por deep links manualmente, usando ferramentas como MobSF ou scripts como [este](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Você pode **abrir** um **scheme** declarado usando **adb** ou um **navegador**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Observe que você pode **omitir o nome do pacote** e o dispositivo móvel chamará automaticamente o aplicativo que deve abrir esse link._
```markup
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Código executado**

Para encontrar o **código que será executado no App**, vá para a atividade chamada pelo deeplink e procure a função **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Informações sensíveis**

Toda vez que você encontrar um deep link, verifique se **não está recebendo dados sensíveis (como senhas) via parâmetros de URL**, porque qualquer outro aplicativo poderia **se passar pelo deep link e roubar esses dados!**

**Parâmetros no caminho**

Você **também deve verificar se algum deep link está usando um parâmetro dentro do caminho** da URL como: `https://api.example.com/v1/users/{username}`, nesse caso você pode forçar uma travessia de caminho acessando algo como: `example://app/users?username=../../unwanted-endpoint%3fparam=value`.\
Note que se você encontrar os endpoints corretos dentro do aplicativo, pode ser capaz de causar um **Open Redirect** (se parte do caminho for usada como nome de domínio), **assumir a conta** (se você puder modificar os detalhes dos usuários sem o token CSRF e o endpoint vulnerável usar o método correto) e qualquer outra vulnerabilidade. Mais [info sobre isso aqui](http://dphoeniixx.com/2020/12/13-2/).

**Mais exemplos**

Um [relatório de bug bounty interessante](https://hackerone.com/reports/855618) sobre links (_/.well-known/assetlinks.json_).

### Inspeção e Falhas de Verificação da Camada de Transporte

- **Os certificados nem sempre são inspecionados corretamente** por aplicativos Android. É comum que esses aplicativos ignorem avisos e aceitem certificados autoassinados ou, em alguns casos, voltem a usar conexões HTTP.
- **As negociações durante o handshake SSL/TLS às vezes são fracas**, empregando suítes de cifra inseguras. Essa vulnerabilidade torna a conexão suscetível a ataques man-in-the-middle (MITM), permitindo que atacantes decriptografem os dados.
- **Vazamento de informações privadas** é um risco quando aplicativos se autenticam usando canais seguros, mas depois se comunicam por canais não seguros para outras transações. Essa abordagem falha em proteger dados sensíveis, como cookies de sessão ou detalhes do usuário, de interceptação por entidades maliciosas.

#### Verificação de Certificado

Focaremos na **verificação de certificado**. A integridade do certificado do servidor deve ser verificada para aumentar a segurança. Isso é crucial porque configurações TLS inseguras e a transmissão de dados sensíveis por canais não criptografados podem representar riscos significativos. Para etapas detalhadas sobre como verificar certificados de servidor e abordar vulnerabilidades, [**este recurso**](https://manifestsecurity.com/android-application-security-part-10/) fornece orientações abrangentes.

#### SSL Pinning

SSL Pinning é uma medida de segurança onde o aplicativo verifica o certificado do servidor contra uma cópia conhecida armazenada dentro do próprio aplicativo. Esse método é essencial para prevenir ataques MITM. Implementar SSL Pinning é fortemente recomendado para aplicativos que lidam com informações sensíveis.

#### Inspeção de Tráfego

Para inspecionar o tráfego HTTP, é necessário **instalar o certificado da ferramenta de proxy** (por exemplo, Burp). Sem instalar esse certificado, o tráfego criptografado pode não ser visível através do proxy. Para um guia sobre como instalar um certificado CA personalizado, [**clique aqui**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Aplicativos que visam **API Level 24 e acima** requerem modificações na Configuração de Segurança da Rede para aceitar o certificado CA do proxy. Este passo é crítico para inspecionar tráfego criptografado. Para instruções sobre como modificar a Configuração de Segurança da Rede, [**consulte este tutorial**](make-apk-accept-ca-certificate.md).

#### Bypass de SSL Pinning

Quando o SSL Pinning é implementado, contorná-lo se torna necessário para inspecionar o tráfego HTTPS. Vários métodos estão disponíveis para esse propósito:

- Modifique automaticamente o **apk** para **contornar** o SSL Pinning com [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). O melhor pró dessa opção é que você não precisará de root para contornar o SSL Pinning, mas precisará excluir o aplicativo e reinstalar o novo, e isso nem sempre funcionará.
- Você pode usar **Frida** (discutido abaixo) para contornar essa proteção. Aqui está um guia para usar Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Você também pode tentar **contornar automaticamente o SSL Pinning** usando [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Você também pode tentar **contornar automaticamente o SSL Pinning** usando **análise dinâmica do MobSF** (explicado abaixo)
- Se você ainda acha que há algum tráfego que não está capturando, pode tentar **encaminhar o tráfego para o burp usando iptables**. Leia este blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Procurando Vulnerabilidades Comuns na Web

É importante também procurar vulnerabilidades comuns na web dentro do aplicativo. Informações detalhadas sobre como identificar e mitigar essas vulnerabilidades estão além do escopo deste resumo, mas são amplamente cobertas em outros lugares.

### Frida

[Frida](https://www.frida.re) é uma ferramenta de instrumentação dinâmica para desenvolvedores, engenheiros reversos e pesquisadores de segurança.\
**Você pode acessar aplicativos em execução e hook métodos em tempo de execução para mudar o comportamento, alterar valores, extrair valores, executar códigos diferentes...**\
Se você quer fazer pentesting em aplicativos Android, precisa saber como usar o Frida.

- Aprenda a usar o Frida: [**Tutorial Frida**](frida-tutorial/)
- Alguma "GUI" para ações com Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection é ótimo para automatizar o uso do Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Você pode encontrar alguns scripts Frida incríveis aqui: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Tente contornar mecanismos de anti-debugging / anti-frida carregando o Frida como indicado em [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (ferramenta [linjector](https://github.com/erfur/linjector-rs))

### **Dump de Memória - Fridump**

Verifique se o aplicativo está armazenando informações sensíveis na memória que não deveria estar armazenando, como senhas ou mnemônicos.

Usando [**Fridump3**](https://github.com/rootbsd/fridump3), você pode despejar a memória do aplicativo com:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Isso irá despejar a memória na pasta ./dump, e lá você pode usar grep com algo como:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Dados sensíveis no Keystore**

No Android, o Keystore é o melhor lugar para armazenar dados sensíveis, no entanto, com privilégios suficientes, ainda é **possível acessá-lo**. Como as aplicações tendem a armazenar aqui **dados sensíveis em texto claro**, os pentests devem verificar isso como usuário root ou alguém com acesso físico ao dispositivo poderia ser capaz de roubar esses dados.

Mesmo que um aplicativo armazene dados no keystore, os dados devem ser criptografados.

Para acessar os dados dentro do keystore, você pode usar este script Frida: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Bypass de Impressão Digital/Biometria**

Usando o seguinte script Frida, pode ser possível **bypassar a autenticação por impressão digital** que aplicativos Android podem estar realizando para **proteger certas áreas sensíveis:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Imagens de Fundo**

Quando você coloca um aplicativo em segundo plano, o Android armazena um **instantâneo do aplicativo** para que, quando ele for recuperado para o primeiro plano, comece a carregar a imagem antes do aplicativo, fazendo parecer que o aplicativo foi carregado mais rápido.

No entanto, se esse instantâneo contiver **informações sensíveis**, alguém com acesso ao instantâneo pode **roubar essas informações** (note que você precisa de root para acessá-las).

Os instantâneos geralmente são armazenados em: **`/data/system_ce/0/snapshots`**

O Android fornece uma maneira de **prevenir a captura de tela definindo o parâmetro de layout FLAG_SECURE**. Ao usar essa flag, o conteúdo da janela é tratado como seguro, impedindo que apareça em capturas de tela ou que seja visualizado em displays não seguros.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Analisador de Aplicações Android**

Esta ferramenta pode ajudar você a gerenciar diferentes ferramentas durante a análise dinâmica: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Injeção de Intent

Os desenvolvedores frequentemente criam componentes proxy como atividades, serviços e receptores de broadcast que manipulam esses Intents e os passam para métodos como `startActivity(...)` ou `sendBroadcast(...)`, o que pode ser arriscado.

O perigo reside em permitir que atacantes acionem componentes de aplicativo não exportados ou acessem provedores de conteúdo sensíveis ao redirecionar esses Intents. Um exemplo notável é o componente `WebView` convertendo URLs em objetos `Intent` via `Intent.parseUri(...)` e, em seguida, executando-os, potencialmente levando a injeções de Intent maliciosas.

### Principais Conclusões

- **Injeção de Intent** é semelhante ao problema de Redirecionamento Aberto da web.
- Explorações envolvem passar objetos `Intent` como extras, que podem ser redirecionados para executar operações inseguras.
- Pode expor componentes não exportados e provedores de conteúdo a atacantes.
- A conversão de URL para `Intent` do `WebView` pode facilitar ações não intencionais.

### Injeções do Lado do Cliente Android e outros

Provavelmente você conhece esse tipo de vulnerabilidades da Web. Você deve ter cuidado especial com essas vulnerabilidades em uma aplicação Android:

- **Injeção SQL:** Ao lidar com consultas dinâmicas ou Content-Providers, certifique-se de usar consultas parametrizadas.
- **Injeção de JavaScript (XSS):** Verifique se o suporte a JavaScript e Plugins está desativado para quaisquer WebViews (desativado por padrão). [Mais informações aqui](webview-attacks.md#javascript-enabled).
- **Inclusão de Arquivo Local:** WebViews devem ter o acesso ao sistema de arquivos desativado (ativado por padrão) - `(webview.getSettings().setAllowFileAccess(false);)`. [Mais informações aqui](webview-attacks.md#javascript-enabled).
- **Cookies Eternos**: Em vários casos, quando a aplicação android finaliza a sessão, o cookie não é revogado ou pode até ser salvo no disco.
- [**Secure Flag** em cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Análise Automática

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Análise estática**

![](<../../images/image (866).png>)

**Avaliação de vulnerabilidades da aplicação** usando uma interface web agradável. Você também pode realizar análise dinâmica (mas precisa preparar o ambiente).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Observe que o MobSF pode analisar **Android**(apk)**, IOS**(ipa) **e Windows**(apx) aplicações (_As aplicações do Windows devem ser analisadas a partir de um MobSF instalado em um host Windows_).\
Além disso, se você criar um arquivo **ZIP** com o código-fonte de um aplicativo **Android** ou **IOS** (vá para a pasta raiz do aplicativo, selecione tudo e crie um arquivo ZIP), ele também poderá analisá-lo.

O MobSF também permite que você **diff/Compare** análises e integre **VirusTotal** (você precisará definir sua chave de API em _MobSF/settings.py_ e habilitá-la: `VT_ENABLED = TRUE` `VT_API_KEY = <Sua chave de API>` `VT_UPLOAD = TRUE`). Você também pode definir `VT_UPLOAD` como `False`, então o **hash** será **upload** em vez do arquivo.

### Análise Dinâmica Assistida com MobSF

**MobSF** também pode ser muito útil para **análise dinâmica** em **Android**, mas nesse caso você precisará instalar o MobSF e **genymotion** em seu host (uma VM ou Docker não funcionará). _Nota: Você precisa **iniciar primeiro uma VM no genymotion** e **depois o MobSF.**_\
O **analisador dinâmico do MobSF** pode:

- **Dump de dados da aplicação** (URLs, logs, área de transferência, capturas de tela feitas por você, capturas de tela feitas por "**Exported Activity Tester**", e-mails, bancos de dados SQLite, arquivos XML e outros arquivos criados). Tudo isso é feito automaticamente, exceto pelas capturas de tela, você precisa pressionar quando quiser uma captura de tela ou precisa pressionar "**Exported Activity Tester**" para obter capturas de tela de todas as atividades exportadas.
- Capturar **tráfego HTTPS**
- Usar **Frida** para obter **informações em tempo de execução**

A partir das versões **Android > 5**, ele **iniciará automaticamente o Frida** e definirá configurações de **proxy** globais para **capturar** tráfego. Ele capturará apenas o tráfego do aplicativo testado.

**Frida**

Por padrão, ele também usará alguns Scripts Frida para **burlar SSL pinning**, **detecção de root** e **detecção de depurador** e para **monitorar APIs interessantes**.\
O MobSF também pode **invocar atividades exportadas**, capturar **capturas de tela** delas e **salvá-las** para o relatório.

Para **iniciar** o teste dinâmico, pressione o botão verde: "**Start Instrumentation**". Pressione "**Frida Live Logs**" para ver os logs gerados pelos scripts Frida e "**Live API Monitor**" para ver todas as invocações para métodos conectados, argumentos passados e valores retornados (isso aparecerá após pressionar "Start Instrumentation").\
O MobSF também permite que você carregue seus próprios **scripts Frida** (para enviar os resultados dos seus scripts Frida para o MobSF, use a função `send()`). Ele também possui **vários scripts pré-escritos** que você pode carregar (você pode adicionar mais em `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), basta **selecioná-los**, pressionar "**Load**" e pressionar "**Start Instrumentation**" (você poderá ver os logs desses scripts dentro de "**Frida Live Logs**").

![](<../../images/image (419).png>)

Além disso, você tem algumas funcionalidades auxiliares do Frida:

- **Enumerar Classes Carregadas**: Ele imprimirá todas as classes carregadas
- **Capturar Strings**: Ele imprimirá todas as strings capturadas enquanto usa o aplicativo (muito barulhento)
- **Capturar Comparações de Strings**: Pode ser muito útil. Ele **mostrará as 2 strings sendo comparadas** e se o resultado foi Verdadeiro ou Falso.
- **Enumerar Métodos de Classe**: Coloque o nome da classe (como "java.io.File") e ele imprimirá todos os métodos da classe.
- **Pesquisar Padrão de Classe**: Pesquisar classes por padrão
- **Rastrear Métodos de Classe**: **Rastrear** uma **classe inteira** (ver entradas e saídas de todos os métodos da classe). Lembre-se de que, por padrão, o MobSF rastreia vários métodos interessantes da API Android.

Uma vez que você tenha selecionado o módulo auxiliar que deseja usar, você precisa pressionar "**Start Intrumentation**" e verá todas as saídas em "**Frida Live Logs**".

**Shell**

O Mobsf também traz um shell com alguns comandos **adb**, comandos **MobSF** e comandos comuns de **shell** na parte inferior da página de análise dinâmica. Alguns comandos interessantes:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**Ferramentas HTTP**

Quando o tráfego http é capturado, você pode ver uma visualização feia do tráfego capturado no "**Tráfego HTTP(S)**" na parte inferior ou uma visualização mais agradável no botão verde "**Iniciar HTTPTools**". A partir da segunda opção, você pode **enviar** as **requisições capturadas** para **proxies** como Burp ou Owasp ZAP.\
Para fazer isso, _ligue o Burp -->_ _desative o Intercept --> no MobSB HTTPTools selecione a requisição_ --> pressione "**Enviar para Fuzzer**" --> _selecione o endereço do proxy_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Uma vez que você termine a análise dinâmica com MobSF, você pode pressionar em "**Iniciar Web API Fuzzer**" para **fuzz http requests** e procurar por vulnerabilidades.

> [!NOTE]
> Após realizar uma análise dinâmica com MobSF, as configurações do proxy podem estar mal configuradas e você não conseguirá corrigi-las pela GUI. Você pode corrigir as configurações do proxy fazendo:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Análise Dinâmica Assistida com Inspeckage

Você pode obter a ferramenta em [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Esta ferramenta usará alguns **Hooks** para te informar **o que está acontecendo na aplicação** enquanto você realiza uma **análise dinâmica**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Esta é uma **ótima ferramenta para realizar análise estática com uma GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Esta ferramenta é projetada para procurar várias **vulnerabilidades relacionadas à segurança em aplicações Android**, seja no **código fonte** ou em **APKs empacotados**. A ferramenta também é **capaz de criar um "Proof-of-Concept" APK implantável** e **comandos ADB**, para explorar algumas das vulnerabilidades encontradas (Atividades expostas, intents, tapjacking...). Assim como com o Drozer, não há necessidade de rootear o dispositivo de teste.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Exibe todos os arquivos extraídos para fácil referência
- Descompila automaticamente arquivos APK para os formatos Java e Smali
- Analisa AndroidManifest.xml em busca de vulnerabilidades e comportamentos comuns
- Análise estática de código-fonte para vulnerabilidades e comportamentos comuns
- Informações do dispositivo
- e mais
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER é um aplicativo de linha de comando que pode ser usado no Windows, MacOS X e Linux, que analisa arquivos _.apk_ em busca de vulnerabilidades. Ele faz isso descompactando APKs e aplicando uma série de regras para detectar essas vulnerabilidades.

Todas as regras estão centradas em um arquivo `rules.json`, e cada empresa ou testador pode criar suas próprias regras para analisar o que precisam.

Baixe os binários mais recentes na [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn é uma ferramenta **multiplataforma** que ajuda desenvolvedores, caçadores de bugs e hackers éticos a realizar [análise de código estático](https://en.wikipedia.org/wiki/Static_program_analysis) em aplicativos móveis.

O conceito é que você arrasta e solta seu arquivo de aplicativo móvel (um arquivo .apk ou .ipa) na aplicação StaCoAn e ela gerará um relatório visual e portátil para você. Você pode ajustar as configurações e listas de palavras para obter uma experiência personalizada.

Baixe a [última versão](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework é um sistema de análise de vulnerabilidades Android que ajuda desenvolvedores ou hackers a encontrar potenciais vulnerabilidades de segurança em aplicações Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** é uma ferramenta cujo principal objetivo é detectar e alertar o usuário sobre comportamentos potencialmente maliciosos desenvolvidos por um aplicativo Android.

A detecção é realizada com a **análise estática** do bytecode Dalvik do aplicativo, representado como **Smali**, com a biblioteca [`androguard`](https://github.com/androguard/androguard).

Esta ferramenta procura por **comportamentos comuns de aplicativos "ruins"** como: exfiltração de identificadores de telefonia, interceptação de fluxo de áudio/vídeo, modificação de dados PIM, execução de código arbitrário...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** é um **M**obile **A**pplication **R**everse engineering e **A**nalysis Framework. É uma ferramenta que reúne ferramentas comumente usadas para engenharia reversa e análise de aplicativos móveis, para auxiliar na testagem de aplicativos móveis contra as ameaças de segurança móvel da OWASP. Seu objetivo é tornar essa tarefa mais fácil e amigável para desenvolvedores de aplicativos móveis e profissionais de segurança.

Ele é capaz de:

- Extrair código Java e Smali usando diferentes ferramentas
- Analisar APKs usando: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Extrair informações privadas do APK usando regexps.
- Analisar o Manifest.
- Analisar domínios encontrados usando: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) e [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deofuscar APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Útil para detectar malware: [https://koodous.com/](https://koodous.com)

## Obfuscating/Deobfuscating code

Note que dependendo do serviço e configuração que você usa para ofuscar o código. Segredos podem ou não acabar ofuscados.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

De [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** é uma ferramenta de linha de comando de código aberto que reduz, otimiza e ofusca código Java. É capaz de otimizar bytecode, bem como detectar e remover instruções não utilizadas. ProGuard é software livre e é distribuído sob a Licença Pública Geral GNU, versão 2.

ProGuard é distribuído como parte do SDK do Android e é executado ao construir o aplicativo em modo de lançamento.

### [DexGuard](https://www.guardsquare.com/dexguard)

Encontre um guia passo a passo para deofuscar o apk em [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(Desse guia) Na última vez que verificamos, o modo de operação do Dexguard era:

- carregar um recurso como um InputStream;
- alimentar o resultado a uma classe que herda de FilterInputStream para descriptografá-lo;
- fazer alguma ofuscação inútil para desperdiçar alguns minutos do tempo de um reversor;
- alimentar o resultado descriptografado a um ZipInputStream para obter um arquivo DEX;
- finalmente carregar o DEX resultante como um Recurso usando o método `loadDex`.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverte o processo de ofuscação realizado por ferramentas de ofuscação do Android. Isso permite inúmeras análises de segurança, incluindo inspeção de código e previsão de bibliotecas.**

Você pode enviar um APK ofuscado para a plataforma deles.

### [Deobfuscate android App](https://github.com/In3tinct/deobfuscate-android-app)

Esta é uma ferramenta LLM para encontrar quaisquer vulnerabilidades de segurança potenciais em aplicativos android e deofuscar o código do aplicativo android. Usa a API pública Gemini do Google.

### [Simplify](https://github.com/CalebFenton/simplify)

É um **deofuscador android genérico.** Simplify **executa virtualmente um aplicativo** para entender seu comportamento e então **tenta otimizar o código** para que se comporte de forma idêntica, mas seja mais fácil para um humano entender. Cada tipo de otimização é simples e genérico, então não importa qual o tipo específico de ofuscação utilizada.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD fornece informações sobre **como um APK foi feito**. Ele identifica muitos **compiladores**, **empacotadores**, **ofuscadores** e outras coisas estranhas. É o [_PEiD_](https://www.aldeid.com/wiki/PEiD) para Android.

### Manual

[Leia este tutorial para aprender alguns truques sobre **como reverter ofuscação personalizada**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b é uma máquina virtual de segurança Android baseada em ubuntu-mate que inclui a coleção dos últimos frameworks, tutoriais e laboratórios de diferentes especialistas em segurança e pesquisadores para engenharia reversa e análise de malware.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) É uma ótima lista de recursos
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Curso rápido de Android
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)

## Yet to try

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
