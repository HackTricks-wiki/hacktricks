# Pentesting Android aplikacija

{{#include ../../banners/hacktricks-training.md}}

## Osnove Android aplikacija

Toplo se preporučuje da prvo pročitate ovu stranicu kako biste saznali o **najvažnijim delovima vezanim za bezbednost Androida i o najozbiljnijim/opasnijim komponentama u Android aplikaciji**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Ovo je glavni alat koji vam treba za povezivanje na Android uređaj (emuliran ili fizički).\
**ADB** omogućava kontrolu uređaja bilo preko **USB** ili **Network** sa računara. Ovaj alat omogućava **kopiranje** fajlova u oba smera, **instalaciju** i **deinstalaciju** aplikacija, **izvršavanje** shell komandi, **pravljenje backup-a** podataka, **čitanje** logova, među ostalim funkcijama.

Pogledajte sledeću listu [**ADB Commands**](adb-commands.md) da naučite kako koristiti adb.

## Smali

Ponekad je korisno **izmeniti kod aplikacije** kako biste pristupili **skrivenim informacijama** (npr. dobro obfuskovanim lozinkama ili flagovima). Tada može biti korisno dekompajlirati apk, izmeniti kod i ponovo ga kompajlirati.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Ovo može biti veoma korisno kao **alternativa za više testova tokom dinamičke analize** koji će biti predstavljeni. Dakle, **uvek imajte ovu mogućnost na umu**.

## Other interesting tricks

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Extract APK from device:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Spojite sve splits i base apks sa [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Studije slučaja i ranjivosti


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Statička analiza

Prvo, za analizu APK-a treba **pogledati Java kod** koristeći dekompajler.\
Molimo, [**pročitajte ovde za informacije o različitim dostupnim dekompajlerima**](apk-decompilers.md).

### Traženje interesantnih informacija

Samo pregledanjem **strings** iz APK-a možete tražiti **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** i sve što je interesantno... tražite čak i code execution **backdoors** ili authentication backdoors (hardcoded admin credentials u aplikaciji).

**Firebase**

Obratite posebnu pažnju na **firebase URLs** i proverite da li je pogrešno konfigurisano. [Više informacija o tome šta je Firebase i kako ga eksploatisati ovde.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Osnovno razumevanje aplikacije - Manifest.xml, strings.xml

**Pregled _Manifest.xml_ i **_strings.xml_** fajlova aplikacije može otkriti potencijalne sigurnosne ranjivosti**. Do ovih fajlova se može pristupiti pomoću dekompajlera ili preimenovanjem ekstenzije APK fajla u .zip i njihovim raspakivanjem.

**Ranjivosti** identifikovane iz **Manifest.xml** uključuju:

- **Debuggable Applications**: Aplikacije koje su označene kao debuggable (`debuggable="true"`) u _Manifest.xml_ predstavljaju rizik jer dozvoljavaju konekcije koje mogu dovesti do eksploatacije. Za dublje razumevanje kako eksploatisati debuggable aplikacije, pogledajte tutorijal o pronalaženju i iskorišćavanju debuggable aplikacija na uređaju.
- **Backup Settings**: Atribut `android:allowBackup="false"` treba eksplicitno postaviti za aplikacije koje rade sa osetljivim podacima kako bi se sprečili neautorizovani backup-i podataka preko adb, naročito kada je usb debugging omogućen.
- **Network Security**: Prilagođene network security konfiguracije (`android:networkSecurityConfig="@xml/network_security_config"`) u _res/xml/_ mogu specificirati detalje bezbednosti kao što su certificate pins i podešavanja HTTP saobraćaja. Primer je dozvoljavanje HTTP saobraćaja za određene domene.
- **Exported Activities and Services**: Identifikovanje exported aktivnosti i servisa u manifestu može ukazati na komponente koje se mogu zloupotrebiti. Dalja analiza tokom dinamičkog testiranja može otkriti kako iskoristiti ove komponente.
- **Content Providers and FileProviders**: Izloženi content provideri mogu omogućiti neautorizovan pristup ili modifikaciju podataka. Konfiguracija FileProviders takođe zahteva pažljivu proveru.
- **Broadcast Receivers and URL Schemes**: Ove komponente se mogu iskoristiti za eksploataciju, sa posebnom pažnjom na to kako se URL schemes obrađuju i moguće input ranjivosti.
- **SDK Versions**: Atributi `minSdkVersion`, `targetSDKVersion`, i `maxSdkVersion` ukazuju na podržane Android verzije, naglašavajući važnost izbegavanja podrške za zastarele, ranjive Android verzije iz bezbednosnih razloga.

Iz **strings.xml** fajla mogu se otkriti osetljive informacije kao što su API keys, custom schemas i druge beleške developera, što ističe potrebu za pažljivim pregledom ovih resursa.

### Tapjacking

**Tapjacking** je napad gde se pokrene **malicious** **application** koja se pozicionira iznad aplikacije žrtve. Kada vizuelno zaseni aplikaciju žrtve, njen UI je dizajniran tako da prevari korisnika da interaguje sa njim, dok istovremeno prosleđuje tu interakciju stvarnoj aplikaciji žrtve.\
U praksi, to je **slepilo korisnika da zna da zapravo izvodi akcije na aplikaciji žrtve**.

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Activity sa `launchMode` postavljenim na `singleTask` bez definisanog `taskAffinity` je ranjiva na Task Hijacking. To znači da se maliciozna aplikacija može instalirati i ako se pokrene pre prave aplikacije, može **hijack-ovati task prave aplikacije** (tako da će korisnik interagovati sa **malicious application** misleći da koristi pravu).

Više informacija u:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Nesigurno čuvanje podataka

**Internal Storage**

U Androidu, fajlovi koji se čuvaju u **internal storage** su dizajnirani da budu dostupni isključivo aplikaciji koja ih je kreirala. Ova sigurnosna mera je sprovedena od strane Android operativnog sistema i obično je adekvatna za potrebe većine aplikacija. Međutim, developeri ponekad koriste režime kao što su `MODE_WORLD_READABLE` i `MODE_WORLD_WRITABLE` da bi omogućili deljenje fajlova među različitim aplikacijama. Ti režimi ne ograničavaju pristup tim fajlovima drugim aplikacijama, uključujući i potencijalno zlonamerne.

1. **Static Analysis:**
- **Proverite** upotrebu `MODE_WORLD_READABLE` i `MODE_WORLD_WRITABLE` i pažljivo ih analizirajte. Ovi režimi **mogu potencijalno izložiti** fajlove neželjenom ili neautorizovanom pristupu.
2. **Dynamic Analysis:**
- **Verifikujte** permisije na fajlovima koje aplikacija kreira. Konkretno, **proverite** da li su neki fajlovi postavljeni da budu čitljivi ili pisivi za sve. Ovo može predstavljati značajan sigurnosni rizik, jer bi omogućilo **bilo kojoj aplikaciji** instaliranoj na uređaju, bez obzira na poreklo ili nameru, da **čitaju ili modifikuju** te fajlove.

**External Storage**

Kada se radi o fajlovima na **external storage**, kao što su SD kartice, treba preduzeti određene mere opreza:

1. **Dostupnost**:
- Fajlovi na external storage su **globalno čitljivi i pisivi**. To znači da bilo koja aplikacija ili korisnik može pristupiti tim fajlovima.
2. **Bezbednosne brige**:
- S obzirom na lakoću pristupa, preporučuje se **ne čuvati osetljive informacije** na external storage.
- External storage može biti uklonjen ili pristupljen od strane bilo koje aplikacije, što ga čini manje sigurnim.
3. **Rukovanje podacima iz External Storage**:
- Uvek **vršite validaciju ulaza** na podacima preuzetim iz external storage. Ovo je ključno jer podaci dolaze iz nepoverljivog izvora.
- Ne preporučuje se čuvanje izvršnih fajlova ili class fajlova na external storage za dinamičko učitavanje.
- Ako vaša aplikacija mora da učita izvršne fajlove iz external storage, osigurajte da su ti fajlovi **potpisani i kriptografski verifikovani** pre dinamičkog učitavanja. Ovaj korak je vitalan za očuvanje bezbednosnog integriteta aplikacije.

External storage se može pristupiti u /storage/emulated/0 , /sdcard , /mnt/sdcard

> [!TIP]
> Počev od Android 4.4 (**API 17**), SD kartica ima strukturu direktorijuma koja **ograničava pristup aplikaciji samo na direktorijum koji je specifičan za tu aplikaciju**. Ovo sprečava da maliciozna aplikacija dobije read ili write pristup fajlovima druge aplikacije.

**Osetljivi podaci čuvani u običnom tekstu**

- **Shared preferences**: Android omogućava svakoj aplikaciji da lako sačuva xml fajlove u putanji `/data/data/<packagename>/shared_prefs/` i ponekad je moguće pronaći osetljive informacije u običnom tekstu u tom folderu.
- **Databases**: Android omogućava svakoj aplikaciji da lako sačuva sqlite baze u putanji `/data/data/<packagename>/databases/` i ponekad je moguće pronaći osetljive informacije u običnom tekstu u tom folderu.

### Pokvaren TLS

**Accept All Certificates**

Iz nekog razloga, ponekad developeri prihvataju sve sertifikate čak i ako, na primer, hostname ne odgovara, sa linijama koda kao u sledećem primeru:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Pokvarena kriptografija

**Neispravni procesi upravljanja ključevima**

Neki developeri čuvaju osetljive podatke u lokalnom skladištu i enkriptuju ih ključem hardkodovanim/predvidivim u kodu. To ne bi trebalo raditi jer reverzovanje može omogućiti napadačima da izvuku poverljive informacije.

**Korišćenje nesigurnih i/ili zastarelih algoritama**

Developeri ne bi trebalo da koriste **deprecated algorithms** za izvođenje autorizacionih **provera**, **čuvanje** ili **slanje** podataka. Neki od ovih algoritama su: RC4, MD4, MD5, SHA1... Ako se **hashes** koriste za čuvanje lozinki, na primer, treba koristiti **brute-force resistant** heš metode sa salt-om.

### Ostale provere

- Preporučuje se da **obfuscate the APK** kako bi se otežalo reverz inženjering napadačima.
- Ako je app osetljiv (na primer bankarske aplikacije), treba da izvršava sopstvene provere da vidi da li je mobilni **rooted** i da se ponaša u skladu sa tim.
- Ako je app osetljiv (na primer bankarske aplikacije), treba da proveri da li se koristi **emulator**.
- Ako je app osetljiv (na primer bankarske aplikacije), treba da **proveri sopstveni integritet pre izvršavanja** kako bi proverio da li je izmenjen.
- Koristite [**APKiD**](https://github.com/rednaga/APKiD) da proverite koji compiler/packer/obfuscator je korišćen za izgradnju APK-a

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automatska statička analiza koda

The tool [**mariana-trench**](https://github.com/facebook/mariana-trench) is capable of finding **vulnerabilities** by **scanning** the **code** of the application. This tool contains a series of **known sources** (that indicates to the tool the **places** where the **input** is **controlled by the user**), **sinks** (which indicates to the tool **dangerous** **places** where malicious user input could cause damages) and **rules**. These rules indicates the **combination** of **sources-sinks** that indicates a vulnerability.

With this knowledge, **mariana-trench will review the code and find possible vulnerabilities on it**.

### Secrets leaked

An application may contain secrets (API keys, passwords, hidden urls, subdomains...) inside of it that you might be able to discover. You could us a tool such as [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Ostale interesantne funkcije

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)
- In-memory native code execution via JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Drugi trikovi**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dinamička analiza

> Pre svega, potrebna vam je okolina gde možete instalirati aplikaciju i svu okolinu (Burp CA cert, Drozer and Frida mainly). Stoga, rooted device (emuliran ili ne) je veoma preporučen.

### Online Dynamic analysis

You can create a **free account** in: [https://appetize.io/](https://appetize.io/). This platform allows you to **upload** and **execute** APKs, so it is useful to see how an apk is behaving.

You can even **see the logs of your application** in the web and connect through **adb**.

![](<../../images/image (831).png>)

Thanks to the ADB connection you can use **Drozer** and **Frida** inside the emulators.

### Lokalna dinamička analiza

#### Korišćenje emulatora

- [**Android Studio**](https://developer.android.com/studio) (You can create **x86** and **arm** devices, and according to [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** versions **support ARM libraries** without needing an slow arm emulator).
- Learn to set it up in this page:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, you need to create an account. _It's recommend to **download** the version **WITH**_ _**VirtualBox** to avoid potential errors._)
- [**Nox**](https://es.bignox.com) (Free, but it doesn't support Frida or Drozer).

> [!TIP]
> When creating a new emulator on any platform remember that the bigger the screen is, the slower the emulator will run. So select small screens if possible.

To **install google services** (like AppStore) in Genymotion you need to click on the red marked button of the following image:

![](<../../images/image (277).png>)

Also, notice that in the **configuration of the Android VM in Genymotion** you can select **Bridge Network mode** (this will be useful if you will be connecting to the Android VM from a different VM with the tools).

#### Use a physical device

You need to activate the **debugging** options and it will be cool if you can **root** it:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Once you have installed the application, the first thing you should do is to try it and investigate what does it do, how does it work and get comfortable with it.\
> I will suggest to **perform this initial dynamic analysis using MobSF dynamic analysis + pidcat**, so we will be able to **learn how the application works** while MobSF **captures** a lot of **interesting** **data** you can review later on.

Magisk/Zygisk quick notes (recommended on Pixel devices)
- Patch boot.img with the Magisk app and flash via fastboot to get systemless root
- Enable Zygisk + DenyList for root hiding; consider LSPosed/Shamiko when stronger hiding is required
- Keep original boot.img to recover from OTA updates; re-patch after each OTA
- For screen mirroring, use scrcpy on the host



### Unintended Data Leakage

**Logging**

Developers should be cautious of exposing **debugging information** publicly, as it can lead to sensitive data leaks. The tools [**pidcat**](https://github.com/JakeWharton/pidcat) and `adb logcat` are recommended for monitoring application logs to identify and protect sensitive information. **Pidcat** is favored for its ease of use and readability.

> [!WARNING]
> Note that from **later newer than Android 4.0**, **applications are only able to access their own logs**. So applications cannot access other apps logs.\
> Anyway, it's still recommended to **not log sensitive information**.

**Copy/Paste Buffer Caching**

Android's **clipboard-based** framework enables copy-paste functionality in apps, yet poses a risk as **other applications** can **access** the clipboard, potentially exposing sensitive data. It's crucial to **disable copy/paste** functions for sensitive sections of an application, like credit card details, to prevent data leaks.

**Crash Logs**

If an application **crashes** and **saves logs**, these logs can assist attackers, particularly when the application cannot be reverse-engineered. To mitigate this risk, avoid logging on crashes, and if logs must be transmitted over the network, ensure they are sent via an SSL channel for security.

As pentester, **try to take a look to these logs**.

**Analytics Data Sent To 3rd Parties**

Applications often integrate services like Google Adsense, which can inadvertently **leak sensitive data** due to improper implementation by developers. To identify potential data leaks, it's advisable to **intercept the application's traffic** and check for any sensitive information being sent to third-party services.

### SQLite DBs

Most of the applications will use **internal SQLite databases** to save information. During the pentest take a **look** to the **databases** created, the names of **tables** and **columns** and all the **data** saved because you could find **sensitive information** (which would be a vulnerability).\
Databases should be located in `/data/data/the.package.name/databases` like `/data/data/com.mwr.example.sieve/databases`

If the database is saving confidential information and is **encrypted b**ut you can **find** the **password** inside the application it's still a **vulnerability**.

Enumerate the tables using `.tables` and enumerate the columns of the tables doing `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer is s useful tool to **exploit exported activities, exported services and Content Providers** as you will learn in the following sections.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Also remember that the code of an activity starts in the **`onCreate`** method.

**Authorisation bypass**

When an Activity is exported you can invoke its screen from an external app. Therefore, if an activity with **sensitive information** is **exported** you could **bypass** the **authentication** mechanisms **to access it.**

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

You can also start an exported activity from adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF će označiti kao maliciozno korišćenje _**singleTask/singleInstance**_ kao `android:launchMode` u activity-ju, ali zbog [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), izgleda da je ovo opasno samo na starijim verzijama (API versions < 21).

> [!TIP]
> Imajte na umu da authorisation bypass nije uvek ranjivost; zavisi od toga kako bypass funkcioniše i koje informacije su izložene.

**Otkrivanje osetljivih informacija**

**Activities takođe mogu vraćati rezultate**. Ako uspete da pronađete eksportovanu i nezaštićenu activity koja poziva **`setResult`** metodu i **vraća osetljive informacije**, dolazi do otkrivanja osetljivih informacija.

#### Tapjacking

Ako tapjacking nije sprečen, možete zloupotrebiti eksportovanu activity da naterate **korisnika da izvrši neočekivane akcije**. For more info about [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Pristup i manipulacija osetljivim informacijama

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers se u osnovi koriste za **deljenje podataka**. Ako aplikacija ima dostupne content providers možda ćete moći da **izvučete osetljive** podatke iz njih. Takođe je važno testirati moguće **SQL injections** i **Path Traversals** jer bi mogli biti ranjivi.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Zapamtite da akcije Service-a počinju u metodi `onStartCommand`.

Servis je u suštini nešto što **može primiti podatke**, **obraditi** ih i **vratiti** (ili ne) odgovor. Dakle, ako aplikacija eksportuje neke servise treba da **proverite** **kod** da biste shvatili šta rade i da ih **testirate** **dinamički** radi izvlačenja poverljivih informacija, zaobilaženja mera autentifikacije...\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Zapamtite da akcije Broadcast Receiver-a počinju u metodi `onReceive`.

Broadcast receiver će čekati određenu vrstu poruke. U zavisnosti od toga kako receiver obrađuje poruku, može biti ranjiv.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Možete tražiti deep links ručno, koristeći alate kao što su MobSF ili skripte poput [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Možete otvoriti deklarisani scheme koristeći adb ili browser:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Imajte na umu da možete **izostaviti naziv paketa** i mobilni uređaj će automatski pozvati aplikaciju koja bi trebalo da otvori tu vezu._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Kod koji će se izvršiti**

Da biste pronašli **kod koji će biti izvršen u App**, idite na activity koju poziva deeplink i potražite funkciju **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Osetljive informacije**

Svakog puta kad pronađete deep link, proverite da li **ne prima osetljive podatke (npr. lozinke) putem URL parametara**, jer bilo koja druga aplikacija može **impersonate the deep link and steal that data!**

**Parametri u putanji**

Morate takođe proveriti da li neki deep link koristi parametar unutar path-a URL-a kao: `https://api.example.com/v1/users/{username}`, u tom slučaju možete forsirati path traversal pristupom nečemu poput: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Napomena: ako pronađete odgovarajuće endpoint-e unutar aplikacije možete izazvati **Open Redirect** (ako je deo path-a korišćen kao domain name), **account takeover** (ako možete izmeniti detalje korisnika bez CSRF tokena i ranjivi endpoint koristi ispravan method) i bilo koju drugu vuln. Više [informacija o ovome ovde](http://dphoeniixx.com/2020/12/13-2/).

**Još primera**

Zanimljiv [bug bounty izveštaj](https://hackerone.com/reports/855618) o linkovima (_/.well-known/assetlinks.json_).

### Inspekcija transportnog sloja i greške u verifikaciji

- **Sertifikati nisu uvek pravilno proveravani** od strane Android aplikacija. Često ove aplikacije zanemare upozorenja i prihvate self-signed sertifikate ili, u nekim slučajevima, vrate se na korišćenje HTTP konekcija.
- **Pregovori tokom SSL/TLS handshake-a su ponekad slabi**, koristeći nesigurne cipher suite-ove. Ova ranjivost čini konekciju podložnom man-in-the-middle (MITM) napadima, što omogućava napadačima da dekriptuju podatke.
- **Leakage of private information** predstavlja rizik kada aplikacije autentifikuju koristeći sigurne kanale, ali potom komuniciraju putem nesigurnih kanala za druge transakcije. Ovakav pristup ne uspeva da zaštiti osetljive podatke, kao što su session cookies ili korisnički podaci, od presretanja od strane malicioznih entiteta.

#### Verifikacija sertifikata

Usredsredićemo se na **verifikaciju sertifikata**. Integritet serverovog sertifikata mora biti verifikovan radi poboljšanja bezbednosti. Ovo je ključno jer nesigurne TLS konfiguracije i prenos osetljivih podataka preko nešifrovanih kanala mogu predstavljati značajne rizike. Za detaljne korake o verifikaciji server sertifikata i otklanjanju ranjivosti, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) pruža sveobuhvatne smernice.

#### SSL Pinning

SSL Pinning je mera bezbednosti gde aplikacija verifikuje serverov sertifikat upoređujući ga sa poznatom kopijom koju čuva unutar same aplikacije. Ova metoda je bitna za sprečavanje MITM napada. Implementacija SSL Pinning-a se toplo preporučuje za aplikacije koje rade sa osetljivim informacijama.

#### Inspekcija saobraćaja

Da biste inspekciju HTTP saobraćaja izvršili, neophodno je da instalirate sertifikat proxy alata (npr. Burp). Bez instalacije ovog sertifikata, enkriptovani saobraćaj možda neće biti vidljiv preko proxy-a. Za vodič o instalaciji custom CA sertifikata, [**kliknite ovde**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Aplikacije koje targetiraju **API Level 24 and above** zahtevaju izmene u Network Security Config da prihvate CA sertifikat proxy-a. Ovaj korak je kritičan za inspekciju enkriptovanog saobraćaja. Za instrukcije o izmeni Network Security Config, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

Ako se koristi **Flutter**, treba da pratite instrukcije na [**ovu stranicu**](flutter.md). To je zato što samo dodavanje sertifikata u store neće raditi, jer Flutter ima sopstvenu listu validnih CAs.

#### Statičko otkrivanje SSL/TLS pinninga

Pre nego što pokušate runtime bypass-e, brzo mapirajte gde je pinning primenjen u APK-u. Statičko otkrivanje pomaže da planirate hooks/patches i da se fokusirate na prave code paths.

Tool: SSLPinDetect
- Open-source static-analysis utility koja dekompajlira APK u Smali (via apktool) i skenira za kurirane regex patterns of SSL/TLS pinning implementations.
- Izveštava tačnu putanju fajla, broj linije i code snippet za svaki match.
- Pokriva common frameworks and custom code paths: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Korišćenje
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Primer pravila obrazaca (JSON)
Koristite ili proširite signatures da biste otkrili vlasničke/prilagođene pinning stilove. Možete učitati sopstveni JSON i skenirati na velikoj skali.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Napomene i saveti
- Brzo skeniranje velikih aplikacija preko multi-threadinga i memory-mapped I/O; pre-compiled regex smanjuje overhead/false positives.
- Kolekcija patterna: https://github.com/aancw/smali-sslpin-patterns
- Tipični ciljevi za dalju trijažu:
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Prilagođeni TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Prilagođeni SSL konteksti: SSLContext.getInstance + SSLContext.init with custom managers
- Deklarativni pins u res/xml network security config i manifest references
- Koristite poklapanja lokacija za planiranje Frida hooks, static patches, ili pregleda konfiguracije pre dinamičkog testiranja.



#### Zaobilaženje SSL Pinninga

Kada je SSL Pinning implementiran, njegovo zaobilaženje postaje neophodno za inspekciju HTTPS saobraćaja. Različite metode su dostupne za ovu svrhu:

- Automatski **modifikujte** **apk** da biste **zaobišli** SSLPinning koristeći [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Najveća prednost ove opcije je što vam neće trebati root da zaobiđete SSL Pinning, ali moraćete obrisati aplikaciju i ponovo instalirati novu, i ovo neće uvek raditi.
- Možete koristiti **Frida** (razgovarano ispod) da zaobiđete ovu zaštitu. Ovde je vodič za korišćenje Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Takođe možete pokušati da **automatski zaobiđete SSL Pinning** koristeći [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Takođe možete pokušati da **automatski zaobiđete SSL Pinning** koristeći **MobSF dynamic analysis** (objašnjeno dole)
- Ako i dalje mislite da postoji saobraćaj koji ne beležite, možete pokušati da **prosledite saobraćaj na Burp koristeći iptables**. Pročitajte ovaj blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Potraga za uobičajenim web ranjivostima

Važno je takođe tražiti uobičajene web ranjivosti unutar aplikacije. Detaljne informacije o identifikaciji i mitigaciji ovih ranjivosti prelaze okvir ovog rezimea, ali su opširno obrađene na drugim mestima.

### Frida

[Frida](https://www.frida.re) je dinamički alat za instrumentaciju za developere, reverse-enginere i istraživače bezbednosti.\
**Možete pristupiti pokrenutoj aplikaciji i hook-ovati metode u runtime-u da promenite ponašanje, promenite vrednosti, izvučete vrednosti, izvršite drugačiji kod...**\
Ako želite da pentestirate Android aplikacije morate znati kako da koristite Frida.

- Naučite kako koristiti Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Neki "GUI" za rad sa Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection je odličan za automatizaciju korišćenja Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Možete pronaći neke Awesome Frida skripte ovde: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Pokušajte da zaobiđete anti-debugging / anti-frida mehanizme učitavanjem Frida kako je navedeno u [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (alat [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation i workflow za zaobilaženje SSL pinninga

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump memorije - Fridump**

Proverite da li aplikacija čuva osetljive informacije u memoriji koje ne bi trebalo da čuva, kao što su lozinke ili mnemonici.

Koristeći [**Fridump3**](https://github.com/rootbsd/fridump3) možete dump-ovati memoriju aplikacije pomoću:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Ovo će dump memoriju u ./dump folder, a tamo možete pokrenuti grep sa nečim poput:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Osetljivi podaci u Keystore**

Na Androidu je Keystore najbolje mesto za čuvanje osetljivih podataka, međutim, uz dovoljno privilegija i dalje je **moguće mu je pristupiti**. Pošto aplikacije obično ovde čuvaju **osetljive podatke u clear text**, pentests bi trebalo da provere to, jer root user ili neko sa fizičkim pristupom uređaju mogao bi da ukrade te podatke.

Čak i ako aplikacija čuva podatke u keystore-u, podaci bi trebalo da budu enkriptovani.

Za pristup podacima unutar keystore-a možete koristiti ovaj Frida script: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Koristeći sledeći Frida script, moguće je **bypass fingerprint authentication** koju Android aplikacije koriste kako bi **zaštitile određena osetljiva područja:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Pozadinske slike**

Kada aplikaciju stavite u pozadinu, Android čuva **snimak aplikacije** tako da kada se vrati u prednji plan počne da učitava sliku pre same aplikacije, pa izgleda kao da je aplikacija brže učitana.

Međutim, ako taj snimak sadrži **osetljive informacije**, neko sa pristupom snimku može **ukrasti te informacije** (napomena: potreban je root za pristup).

Snimci su obično sačuvani na: **`/data/system_ce/0/snapshots`**

Android omogućava način da se **spreči screenshot podešavanjem FLAG_SECURE** layout parametra. Korišćenjem ovog flag-a, sadržaj prozora se tretira kao siguran, što sprečava njegovo pojavljivanje u screenshots ili prikazivanje na nesigurnim ekranima.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Ovaj alat može pomoći pri upravljanju različitim alatima tokom dinamičke analize: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Developeri često kreiraju proxy komponente kao što su activities, services i broadcast receivers koje obrađuju ove Intents i prosleđuju ih metodama kao što su `startActivity(...)` ili `sendBroadcast(...)`, što može biti rizično.

Opasnost leži u dopuštanju napadačima da pokrenu non-exported app components ili pristupe osetljivim content providers preusmeravanjem ovih Intents. Značajan primer je `WebView` komponenta koja konvertuje URL-ove u `Intent` objekte pomoću `Intent.parseUri(...)` i potom ih izvršava, što može dovesti do malicioznih Intent injections.

### Essential Takeaways

- **Intent Injection** je sličan web Open Redirect issue-u.
- Eksploati uključuju prosleđivanje `Intent` objekata kao extras, koji mogu biti preusmereni da izvrše nesigurne operacije.
- Može izložiti non-exported components i content providers napadačima.
- Konverzija URL-a u `Intent` od strane `WebView`-a može omogućiti nepredviđene akcije.

### Android Client Side Injections and others

Verovatno već znate za ovakve ranjivosti sa Web-a. Morate biti posebno oprezni sa ovim ranjivostima u Android aplikaciji:

- **SQL Injection:** Kada radite sa dinamičkim upitima ili Content-Providers, obavezno koristite parameterized queries.
- **JavaScript Injection (XSS):** Proverite da li je podrška za JavaScript i Plugin onemogućena za sve WebViews (po defaultu onemogućeno). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews bi trebalo da imaju pristup fajl sistemu onemogućen (podrazumevano omogućen) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: U više slučajeva, kada Android aplikacija završi sesiju, cookie nije opozvan ili čak može biti sačuvan na disku
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Static analysis**

![](<../../images/image (866).png>)

**Procena ranjivosti aplikacije** koristeći lep web-based frontend. Takođe možete izvršiti dinamičku analizu (ali morate pripremiti okruženje).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Primetite da MobSF može da analizira **Android**(apk)**, IOS**(ipa) **and Windows**(apx) aplikacije (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Takođe, ako napravite **ZIP** fajl sa source kodom za **Android** ili **IOS** aplikaciju (idite u root folder aplikacije, selektujte sve i napravite ZIPfile), moći će da ga analizira takođe.

MobSF takođe omogućava **diff/Compare** analiza i integraciju **VirusTotal** (treba da postavite vaš API ključ u _MobSF/settings.py_ i omogućite ga: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). Možete takođe podesiti `VT_UPLOAD` na `False`, onda će **hash** biti **upload** umesto fajla.

### Assisted Dynamic analysis with MobSF

**MobSF** može biti vrlo koristan i za **dinamičku analizu** na **Android**, ali u tom slučaju morate instalirati MobSF i **genymotion** na vašem hostu (VM ili Docker neće raditi). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
**MobSF dynamic analyser** može:

- **Dump application data** (URL-ove, logove, clipboard, screenshots koje napravite, screenshots dobijene preko "**Exported Activity Tester**", emailove, SQLite baze, XML fajlove i druge kreirane fajlove). Sve ovo se radi automatski osim screenshots — morate pritisnuti kad želite screenshot ili pritisnuti "**Exported Activity Tester**" da biste dobili screenshots svih exported activities.
- Capture **HTTPS traffic**
- Use **Frida** da dobijete **runtime** **information**

Na android **versions > 5**, automatski će pokrenuti Frida i postaviće globalna **proxy** podešavanja da bi **capture**-ovao saobraćaj. Hvataće samo saobraćaj iz testirane aplikacije.

**Frida**

Po defaultu, koristiće neke Frida Scripts da **bypass SSL pinning**, **root detection** i **debugger detection** i da **monitor interesting APIs**.\
MobSF takođe može **invoke exported activities**, napraviti **screenshots** istih i **save** ih za izveštaj.

Da biste **start**-ovali dinamičko testiranje pritisnite zeleni dugme: "**Start Instrumentation**". Pritisnite "**Frida Live Logs**" da vidite logove koje generišu Frida skripte i "**Live API Monitor**" da vidite sve pozive ka hooked metodama, prosleđene argumente i vraćene vrednosti (ovo će se pojaviti nakon pritiskanja "Start Instrumentation").\
MobSF takođe omogućava da učitate svoje **Frida scripts** (da pošaljete rezultate vaših Frida skripti u MobSF koristite funkciju `send()`). Ima **nekoliko pre-napisanih skripti** koje možete učitati (možete dodati više u `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), jednostavno ih **select**-ujte, pritisnite "**Load**" i pritisnite "**Start Instrumentation**" (moći ćete da vidite logove tih skripti u "**Frida Live Logs**").

![](<../../images/image (419).png>)

Pored toga, imate neke pomoćne Frida funkcionalnosti:

- **Enumerate Loaded Classes**: Ispisaće sve učitane klase
- **Capture Strings**: Ispisaće sve captur-ovane stringove dok koristite aplikaciju (veoma noisy)
- **Capture String Comparisons**: Može biti veoma korisno. Pokazaće **dva stringa koja se porede** i da li je rezultat True ili False.
- **Enumerate Class Methods**: Unesite ime klase (npr. "java.io.File") i prikazaće sve metode te klase.
- **Search Class Pattern**: Pretražuje klase po pattern-u
- **Trace Class Methods**: **Trace** cele klase (vidite input-e i output-e svih metoda klase). Zapamtite da po defaultu MobSF traca nekoliko interesantnih Android API metoda.

Kada odaberete pomoćni modul koji želite da koristite, potrebno je da pritisnete "**Start Intrumentation**" i videćete sve izlaze u "**Frida Live Logs**".

**Shell**

MobSF takođe donosi shell sa nekim **adb** komandama, **MobSF commands**, i uobičajenim **shell** **commands** na dnu stranice za dinamičku analizu. Neke interesantne komande:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP tools**

Kada se http saobraćaj zabeleži možete videti ružan prikaz zabeleženog saobraćaja na dugmetu "**HTTP(S) Traffic**" ili lepši prikaz na zelenom dugmetu "**Start HTTPTools**". Iz druge opcije možete **send** the **captured requests** to **proxies** kao Burp ili Owasp ZAP.\
Da biste to uradili, _uključite Burp -->_ _isključite Intercept --> u MobSB HTTPTools izaberite request_ --> pritisnite "**Send to Fuzzer**" --> _izaberite adresu proxy-ja_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Kada završite dinamičku analizu sa MobSF možete pritisnuti "**Start Web API Fuzzer**" da **fuzz http requests** i tražite ranjivosti.

> [!TIP]
> Nakon izvođenja dinamičke analize sa MobSF, proxy podešavanja mogu biti pogrešno konfigurisana i nećete moći da ih popravite iz GUI-ja. Možete popraviti proxy podešavanja tako što ćete uraditi:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

Možete preuzeti alat sa [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Ovaj alat koristi neke **Hooks** da vam pokaže **what is happening in the application** dok vršite **dynamic analysis**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Ovo je **great tool to perform static analysis with a GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Ovaj alat je dizajniran da traži više **security related Android application vulnerabilities**, bilo u **source code** ili u **packaged APKs**. Alat je takođe **capable of creating a "Proof-of-Concept" deployable APK** i **ADB commands**, za eksploatisanje nekih od pronađenih ranjivosti (Exposed activities, intents, tapjacking...). Kao i sa Drozer-om, nema potrebe da root-ujete test uređaj.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Prikazuje sve izvađene fajlove radi lakšeg pregleda
- Automatski dekompajlira APK fajlove u Java i Smali format
- Analizuje AndroidManifest.xml radi uobičajenih ranjivosti i ponašanja
- Statička analiza izvornog koda za uobičajene ranjivosti i ponašanja
- Informacije o uređaju
- i još mnogo toga
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER je aplikacija za komandnu liniju koja se može koristiti na Windows, MacOS X i Linux, i analizira _.apk_ fajlove u potrazi za ranjivostima. To radi dekompresovanjem APKs i primenom niza pravila za otkrivanje tih ranjivosti.

Sva pravila su centralizovana u `rules.json` fajlu, i svaka kompanija ili tester može da kreira sopstvena pravila da analizira ono što im je potrebno.

Preuzmite najnovije binarne fajlove sa [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn je **crossplatform** alat koji pomaže programerima, bugbounty hunterima i ethical hackerima pri izvođenju [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) na mobilnim aplikacijama.

Koncept je da prevučete i ispustite fajl vaše mobilne aplikacije (an .apk or .ipa file) na StaCoAn aplikaciju i ona će za vas generisati vizuelni i prenosiv izveštaj. Možete podesiti settings i wordlists da biste dobili prilagođeno iskustvo.

Preuzmi[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework je sistem za analizu ranjivosti Android aplikacija koji pomaže razvijačima ili hakerima da pronađu potencijalne bezbednosne ranjivosti.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** je alat čiji je glavni cilj da otkrije i upozori korisnika na potencijalno zlonamerna ponašanja koja može izvršavati Android aplikacija.

Detekcija se vrši pomoću **static analysis** Dalvik bytecode-a aplikacije, predstavljenog kao **Smali**, koristeći biblioteku [`androguard`](https://github.com/androguard/androguard).

Ovaj alat traži **uobičajeno ponašanje "loših" aplikacija** kao što su: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** je okvir za obrnuti inženjering i analizu mobilnih aplikacija. To je alat koji okuplja često korišćene alate za obrnuti inženjering i analizu mobilnih aplikacija, kako bi pomogao pri testiranju mobilnih aplikacija protiv OWASP-ovih pretnji u mobilnoj bezbednosti. Njegov cilj je da ovaj zadatak učini lakšim i pristupačnijim programerima mobilnih aplikacija i bezbednosnim profesionalcima.

Može:

- Ekstrahovati Java i Smali kod koristeći različite alate
- Analizira APK-ove koristeći: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Izvlači privatne informacije iz APK-a koristeći regexps.
- Analizira Manifest.
- Analizira pronađene domene koristeći: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) i [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuskuje APK preko [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Koristan za detekciju malvera: https://koodous.com/

## Obfuskovanje/Deobfuskovanje koda

Imajte na umu da, u zavisnosti od servisa i konfiguracije koju koristite za obfuskovanje koda, tajni podaci mogu, ali ne moraju, ostati obfuskovani.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** je open source alat iz komandne linije koji smanjuje, optimizuje i obfuskuje Java kod. Može optimizovati bytecode kao i detektovati i ukloniti neiskorišćene instrukcije. ProGuard je slobodan softver i distribuira se pod GNU General Public License, verzija 2.

ProGuard se distribuira kao deo Android SDK-a i pokreće se prilikom build-ovanja aplikacije u release modu.

### [DexGuard](https://www.guardsquare.com/dexguard)

Pronađite vodič korak-po-korak za deobfuskaciju apk-a na [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(Prema tom vodiču) Poslednji put kada smo proveravali, režim rada Dexguard-a je bio:

- učitaj resurs kao InputStream;
- prosledi rezultat klasi koja nasledjuje FilterInputStream da bi ga dešifrovala;
- uradi neku beskorisnu obfuskaciju da bi se reverseru potrošilo nekoliko minuta;
- prosledi dešifrovani rezultat ZipInputStream-u da bi se dobio DEX fajl;
- na kraju učitaj dobijeni DEX kao Resource koristeći `loadDex` metodu.

### [DeGuard](http://apk-deguard.com)

**DeGuard poništava proces obfuskacije koji izvode Android obfuscation tools. Ovo omogućava brojne bezbednosne analize, uključujući inspekciju koda i predviđanje biblioteka.**

Možete otpremiti obfuskovani APK na njihovu platformu.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

Ovo je LLM alat za pronalaženje potencijalnih bezbednosnih ranjivosti u android aplikacijama i deobfuskaciju koda android aplikacija. Koristi Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

To je generic android deobfuscator. Simplify praktično izvršava aplikaciju da razume njeno ponašanje, a zatim pokušava da optimizuje kod tako da se ponaša identično, ali bude lakši za razumevanje ljudskom čitaocu. Svaki tip optimizacije je jednostavan i generički, tako da nije bitno koja je konkretna vrsta obfuskacije korišćena.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD vam daje informacije o tome **kako je APK napravljen**. Identifikuje mnoge **compilers**, **packers**, **obfuscators**, i druge čudne stvari. To je [_PEiD_](https://www.aldeid.com/wiki/PEiD) za Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Laboratorije

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b je Android security virtuelna mašina zasnovana na ubuntu-mate koja sadrži kolekciju najnovijih framework-ova, tutorijala i laboratorija od različitih security geeka i istraživača za reverse engineering i analizu malvera.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) It is a great list of resources
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
