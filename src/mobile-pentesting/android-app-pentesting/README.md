# Pentesting de aplicaciones Android

{{#include ../../banners/hacktricks-training.md}}

## Fundamentos de aplicaciones Android

Es altamente recomendable comenzar leyendo esta página para conocer las **partes más importantes relacionadas con la seguridad de Android y los componentes más peligrosos en una aplicación Android**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Esta es la herramienta principal que necesitas para conectar con un dispositivo android (emulado o físico).\
**ADB** permite controlar dispositivos ya sea por **USB** o **Network** desde un ordenador. Esta utilidad habilita la **copia** de archivos en ambas direcciones, la **instalación** y **desinstalación** de apps, la **ejecución** de comandos de shell, la **copia de seguridad** de datos, la **lectura** de logs, entre otras funciones.

Echa un vistazo a la siguiente lista de [**ADB Commands**](adb-commands.md) para aprender cómo usar adb.

## Smali

A veces es interesante **modificar el código de la aplicación** para acceder a **información oculta** (quizás contraseñas u otros secretos bien ofuscados). Entonces, puede ser interesante decompilar el apk, modificar el código y recompilarlo.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Esto puede ser muy útil como una **alternativa para varias pruebas durante el análisis dinámico** que se van a presentar. Por tanto, **ten siempre en cuenta esta posibilidad**.

## Otros trucos interesantes

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **Descargar APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Extraer APK del dispositivo:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Fusiona todos los splits y base apks con [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Case Studies & Vulnerabilities


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Análisis Estático

First of all, for analysing an APK you should **take a look to the to the Java code** using a decompiler.\
Please, [**read here to find information about different available decompilers**](apk-decompilers.md).

### Buscando información interesante

Con solo examinar las **strings** del APK puedes buscar **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** y cualquier cosa interesante... busca incluso **backdoors** de ejecución de código o backdoors de autenticación (credenciales de admin hardcoded en la app).

**Firebase**

Presta especial atención a las **Firebase URLs** y verifica si está mal configurado. [Más información sobre qué es Firebase y cómo explotarlo aquí.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Comprensión básica de la aplicación - Manifest.xml, strings.xml

La **examinación de los archivos _Manifest.xml_ y **_strings.xml_** de una aplicación puede revelar vulnerabilidades de seguridad potenciales**. Estos archivos pueden accederse usando decompilers o renombrando la extensión del archivo APK a .zip y luego descomprimiéndolo.

**Vulnerabilidades** identificables desde el **Manifest.xml** incluyen:

- **Debuggable Applications**: Las aplicaciones marcadas como debuggable (`debuggable="true"`) en el _Manifest.xml_ representan un riesgo ya que permiten conexiones que pueden conducir a explotación. Para entender mejor cómo explotar aplicaciones debuggable, consulta un tutorial sobre cómo encontrar y explotar aplicaciones debuggable en un dispositivo.
- **Backup Settings**: El atributo `android:allowBackup="false"` debería establecerse explícitamente para aplicaciones que manejan información sensible para prevenir backups no autorizados vía adb, especialmente cuando usb debugging está habilitado.
- **Network Security**: Las configuraciones de seguridad de red personalizadas (`android:networkSecurityConfig="@xml/network_security_config"`) en _res/xml/_ pueden especificar detalles de seguridad como certificate pins y ajustes de tráfico HTTP. Un ejemplo es permitir tráfico HTTP para dominios específicos.
- **Exported Activities and Services**: Identificar actividades y servicios exportados en el manifiesto puede resaltar componentes que podrían ser mal utilizados. Un análisis más profundo durante pruebas dinámicas puede revelar cómo explotar estos componentes.
- **Content Providers and FileProviders**: Los content providers expuestos podrían permitir acceso o modificación no autorizada de datos. La configuración de FileProviders también debe ser escrutada.
- **Broadcast Receivers and URL Schemes**: Estos componentes podrían aprovecharse para explotación, con atención especial a cómo se gestionan los URL schemes por posibles vulnerabilidades de entrada.
- **SDK Versions**: Los atributos `minSdkVersion`, `targetSDKVersion`, y `maxSdkVersion` indican las versiones de Android soportadas, lo que resalta la importancia de no soportar versiones antiguas y vulnerables de Android por razones de seguridad.

Desde el archivo **strings.xml**, se puede descubrir información sensible como API keys, esquemas personalizados y otras notas del desarrollador, lo que subraya la necesidad de revisar cuidadosamente estos recursos.

### Tapjacking

**Tapjacking** es un ataque donde una **malicious** **application** se lanza y **se posiciona encima de una victim application**. Una vez que oculta visiblemente la app víctima, su interfaz de usuario está diseñada de tal manera que engaña al usuario para que interactúe con ella, mientras pasa la interacción a la app víctima.\
En efecto, está **cegando al usuario para que no sepa que en realidad está realizando acciones en la victim app**.

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

An **activity** with the **`launchMode`** set to **`singleTask` without any `taskAffinity`** defined is vulnerable to task Hijacking. This means, that an **application** can be installed and if launched before the real application it could **hijack the task of the real application** (so the user will be interacting with the **malicious application thinking he is using the real one**).

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Almacenamiento de datos inseguro

**Internal Storage**

En Android, los archivos **almacenados** en **internal** storage están **diseñados** para ser **accesibles** exclusivamente por la **app** que los **creó**. Esta medida de seguridad es **impuesta** por el sistema operativo Android y suele ser adecuada para las necesidades de seguridad de la mayoría de las aplicaciones. Sin embargo, los desarrolladores a veces utilizan modos como `MODE_WORLD_READABLE` y `MODE_WORLD_WRITABLE` para **permitir** que los archivos sean **compartidos** entre distintas aplicaciones. Aun así, estos modos **no restringen el acceso** a esos archivos por otras aplicaciones, incluidas posibles aplicaciones maliciosas.

1. **Static Analysis:**
- **Asegúrate** de que el uso de `MODE_WORLD_READABLE` y `MODE_WORLD_WRITABLE` sea **cuidadosamente escrutado**. Estos modos **pueden exponer** archivos a **accesos no intencionados o no autorizados**.
2. **Dynamic Analysis:**
- **Verifica** los **permisos** establecidos en archivos creados por la app. Específicamente, **comprueba** si alguno de los archivos está **establecido como legible o escribible por todo el mundo**. Esto puede implicar un riesgo de seguridad significativo, ya que permitiría que **cualquier aplicación** instalada en el dispositivo, independientemente de su origen o intención, **lea o modifique** esos archivos.

**External Storage**

Al tratar con archivos en **external storage**, como tarjetas SD, deben tomarse ciertas precauciones:

1. **Accesibilidad**:
- Los archivos en external storage son **globalmente legibles y escribibles**. Esto significa que cualquier aplicación o usuario puede acceder a esos archivos.
2. **Preocupaciones de seguridad**:
- Dada la facilidad de acceso, se recomienda **no almacenar información sensible** en external storage.
- El external storage puede ser removido o accedido por cualquier aplicación, lo que lo hace menos seguro.
3. **Manejo de datos desde external storage**:
- Siempre **realiza validación de entrada** sobre los datos recuperados desde external storage. Esto es crucial porque los datos provienen de una fuente no confiable.
- No se recomienda almacenar ejecutables o archivos de clase en external storage para carga dinámica.
- Si tu aplicación debe recuperar archivos ejecutables desde external storage, asegúrate de que dichos archivos estén **firmados y verificados criptográficamente** antes de cargarlos dinámicamente. Este paso es vital para mantener la integridad de seguridad de tu aplicación.

External storage puede ser **accedido** en `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> Starting with Android 4.4 (**API 17**), the SD card has a directory structure which **limits access from an app to the directory which is specifically for that app**. This prevents malicious application from gaining read or write access to another app's files.

**Sensitive data stored in clear-text**

- **Shared preferences**: Android permite a cada aplicación guardar fácilmente archivos xml en la ruta `/data/data/<packagename>/shared_prefs/` y a veces es posible encontrar información sensible en clear-text en esa carpeta.
- **Databases**: Android permite a cada aplicación guardar fácilmente bases de datos sqlite en la ruta `/data/data/<packagename>/databases/` y a veces es posible encontrar información sensible en clear-text en esa carpeta.

### Broken TLS

**Accept All Certificates**

For some reason sometimes developers accept all the certificates even if for example the hostname does not match with lines of code like the following one:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Una buena manera de probar esto es intentar capturar el tráfico usando algún proxy como Burp sin autorizar Burp CA dentro del dispositivo. También, puedes generar con Burp un certificado para un hostname distinto y usarlo.

### Criptografía rota

**Procesos deficientes de gestión de claves**

Algunos desarrolladores guardan datos sensibles en el almacenamiento local y los cifran con una clave hardcodeada/predictible en el código. Esto no debería hacerse, ya que algún reversing podría permitir a los atacantes extraer la información confidencial.

**Uso de algoritmos inseguros y/o obsoletos**

Los desarrolladores no deberían usar **algoritmos obsoletos** para realizar comprobaciones de **autorización**, **almacenar** o **enviar** datos. Algunos de estos algoritmos son: RC4, MD4, MD5, SHA1... Si se usan **hashes** para almacenar contraseñas, por ejemplo, se deben usar hashes **resistentes** a fuerza bruta con salt.

### Otras comprobaciones

- Se recomienda **ofuscar el APK** para dificultar el trabajo de reversing a los atacantes.
- Si la app es sensible (como apps bancarias), debería realizar sus **propias comprobaciones para ver si el móvil está rooteado** y actuar en consecuencia.
- Si la app es sensible (como apps bancarias), debería verificar si se está usando un **emulador**.
- Si la app es sensible (como apps bancarias), debería **comprobar su propia integridad antes de ejecutarse** para verificar si fue modificada.
- Usa [**APKiD**](https://github.com/rednaga/APKiD) para comprobar qué compiler/packer/obfuscator se usó para construir el APK

### Aplicación React Native

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Aplicaciones Xamarin

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

La herramienta [**mariana-trench**](https://github.com/facebook/mariana-trench) es capaz de encontrar **vulnerabilidades** escaneando el **código** de la aplicación. Esta herramienta contiene una serie de **fuentes conocidas** (que indican a la herramienta los **lugares** donde la **entrada** está **controlada por el usuario**), **sinks** (que indican a la herramienta **lugares peligrosos** donde la entrada maliciosa del usuario podría causar daños) y **reglas**. Estas reglas indican la **combinación** de **fuentes-sinks** que señalan una vulnerabilidad.

Con este conocimiento, **mariana-trench revisará el código y encontrará posibles vulnerabilidades en él**.

### Secrets leaked

Una aplicación puede contener secretos (API keys, contraseñas, URLs ocultas, subdominios...) dentro de ella que podrías llegar a descubrir. Podrías usar una herramienta como [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Otras funciones interesantes

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Análisis dinámico

> First of all, you need an environment where you can install the application and all the environment (Burp CA cert, Drozer and Frida mainly). Therefore, a rooted device (emulated or not) is extremely recommended.

### Análisis dinámico en línea

Puedes crear una **cuenta gratuita** en: [https://appetize.io/](https://appetize.io). Esta plataforma permite **subir** y **ejecutar** APKs, por lo que es útil para ver cómo se comporta un apk.

Incluso puedes **ver los logs de tu aplicación** en la web y conectarte mediante **adb**.

![](<../../images/image (831).png>)

Gracias a la conexión ADB puedes usar **Drozer** y **Frida** dentro de los emuladores.

### Análisis dinámico local

#### Uso de un emulador

- [**Android Studio**](https://developer.android.com/studio) (Puedes crear dispositivos **x86** y **arm**, y según [**esto** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**las últimas versiones x86** **soportan bibliotecas ARM** sin necesitar un emulador ARM lento).
- Aprende a configurarlo en esta página:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(**Versión gratuita:** Personal Edition, necesitas crear una cuenta. _Se recomienda **descargar** la versión **CON**_ _**VirtualBox** para evitar posibles errores._)
- [**Nox**](https://es.bignox.com) (Gratis, pero no soporta Frida o Drozer).

> [!TIP]
> Cuando crees un nuevo emulador en cualquier plataforma recuerda que cuanto más grande sea la pantalla, más lento será el emulador. Así que selecciona pantallas pequeñas si es posible.

Para **instalar google services** (como AppStore) en Genymotion necesitas hacer clic en el botón marcado en rojo de la siguiente imagen:

![](<../../images/image (277).png>)

Además, fíjate que en la **configuración de la VM Android en Genymotion** puedes seleccionar **Bridge Network mode** (esto será útil si vas a conectarte a la VM Android desde una VM diferente con las herramientas).

#### Usa un dispositivo físico

Necesitas activar las opciones de **debugging** y sería ideal si puedes **rootearlo**:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Once you have installed the application, the first thing you should do is to try it and investigate what does it do, how does it work and get comfortable with it.\
> I will suggest to **perform this initial dynamic analysis using MobSF dynamic analysis + pidcat**, so we will be able to **learn how the application works** while MobSF **captures** a lot of **interesting** **data** you can review later on.

### Unintended Data Leakage

**Logging**

Los desarrolladores deben tener cuidado al exponer información de **debugging** públicamente, ya que puede conducir a data leaks sensibles. Se recomiendan las herramientas [**pidcat**](https://github.com/JakeWharton/pidcat) y `adb logcat` para monitorizar los logs de la aplicación e identificar y proteger información sensible. **Pidcat** se prefiere por su facilidad de uso y legibilidad.

> [!WARNING]
> Ten en cuenta que desde **versiones posteriores a Android 4.0**, **las aplicaciones solo pueden acceder a sus propios logs**. Por lo tanto, las aplicaciones no pueden acceder a los logs de otras apps.\
> De todos modos, sigue siendo recomendable **no registrar información sensible**.

**Caché del portapapeles (Copy/Paste Buffer Caching)**

El framework basado en **clipboard** de Android permite la funcionalidad de copiar-pegar en las apps, pero entraña un riesgo ya que **otras aplicaciones** pueden **acceder** al portapapeles, exponiendo potencialmente datos sensibles. Es crucial **deshabilitar las funciones de copiar/pegar** en secciones sensibles de una aplicación, como los datos de tarjetas de crédito, para prevenir data leaks.

**Crash Logs**

Si una aplicación **crashea** y **guarda logs**, estos logs pueden ayudar a los atacantes, especialmente cuando la aplicación no puede ser reverse-engineered. Para mitigar este riesgo, evita loggear en crashs, y si los logs deben transmitirse por la red, asegúrate de enviarlos vía un canal SSL para seguridad.

Como pentester, **intenta echar un vistazo a estos logs**.

**Analytics Data Sent To 3rd Parties**

Las aplicaciones frecuentemente integran servicios como Google Adsense, lo que puede involuntariamente provocar data leaks debido a una implementación incorrecta por parte de los desarrolladores. Para identificar fugas potenciales de datos, es aconsejable **interceptar el tráfico de la aplicación** y comprobar si se está enviando información sensible a servicios de terceros.

### Bases de datos SQLite

La mayoría de las aplicaciones usan **bases de datos SQLite internas** para guardar información. Durante el pentest revisa las **bases de datos** creadas, los nombres de **tablas** y **columnas** y todos los **datos** guardados porque podrías encontrar **información sensible** (lo que sería una vulnerabilidad).\
Las bases de datos deberían ubicarse en `/data/data/the.package.name/databases` como `/data/data/com.mwr.example.sieve/databases`

Si la base de datos guarda información confidencial y está **encriptada** pero puedes **encontrar** la **contraseña** dentro de la aplicación, sigue siendo una **vulnerabilidad**.

Enumera las tablas usando `.tables` y enumera las columnas de las tablas con `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** te permite **asumir el rol de una app Android** e interactuar con otras apps. Puede hacer **cualquier cosa que una aplicación instalada pueda hacer**, como hacer uso del mecanismo de Inter-Process Communication (IPC) de Android e interactuar con el sistema operativo subyacente.\
Drozer es una herramienta útil para **explotar activities exportadas, servicios exportados y Content Providers** como aprenderás en las siguientes secciones.

### Explotando Activities exportadas

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
También recuerda que el código de una activity empieza en el método **`onCreate`**.

**Authorisation bypass**

Cuando una Activity está exportada puedes invocar su pantalla desde una app externa. Por lo tanto, si una activity con **información sensible** está **exportada** podrías **burlar** los mecanismos de **autenticación** para acceder a ella.

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

También puedes iniciar una activity exportada desde adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> Ten en cuenta que un authorisation bypass no siempre es una vulnerabilidad; dependerá de cómo funcione el bypass y qué información se exponga.

**Sensitive information leakage**

**Activities can also return results**. Si logras encontrar una activity exportada y sin protección que llame al método **`setResult`** y **devuelva información sensible**, se produce una sensitive information leakage.

#### Tapjacking

Si Tapjacking no está prevenido, podrías abusar de la activity exportada para hacer que el **usuario realice acciones inesperadas**. Para más info sobre [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)  
Content providers are basically used to **share data**. Si una app tiene content providers disponibles, podrías ser capaz de **extraer datos sensibles** de ellos. También es interesante probar posibles **SQL injections** y **Path Traversals** ya que podrían ser vulnerables.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)  
Recuerda que las acciones de un Service comienzan en el método `onStartCommand`.

Un Service es básicamente algo que **puede recibir datos**, **procesarlos** y **devolver** (o no) una respuesta. Entonces, si una aplicación exporta servicios deberías **revisar** el **código** para entender qué hace y **probarlo** **dinámicamente** para extraer información confidencial, eludir medidas de autenticación...  
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)  
Recuerda que las acciones de un Broadcast Receiver comienzan en el método `onReceive`.

Un broadcast receiver esperará un tipo de mensaje. Dependiendo de cómo el receiver maneje el mensaje, podría ser vulnerable.  
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Puedes buscar deep links manualmente, usando herramientas como MobSF o scripts como [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).  
Puedes **abrir** un **scheme** declarado usando **adb** o un **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Nota que puedes **omitir el nombre del paquete** y el móvil llamará automáticamente a la app que debería abrir ese enlace._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Código ejecutado**

Para encontrar el **código que se ejecutará en la App**, ve a la activity llamada por el deeplink y busca la función **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Información sensible**

Cada vez que encuentres un deep link verifica que **no esté recibiendo datos sensibles (como contraseñas) vía parámetros de URL**, porque cualquier otra aplicación podría **suplantar el deep link y robar esos datos!**

**Parámetros en el path**

También **debes comprobar si algún deep link está usando un parámetro dentro del path** de la URL como: `https://api.example.com/v1/users/{username}`, en ese caso puedes forzar un path traversal accediendo a algo como: `example://app/users?username=../../unwanted-endpoint%3fparam=value`.\
Ten en cuenta que si encuentras los endpoints correctos dentro de la aplicación podrías causar un **Open Redirect** (si parte del path se usa como nombre de dominio), **account takeover** (si puedes modificar detalles de usuarios sin token CSRF y el endpoint vulnerable usó el método correcto) y cualquier otra vuln. Más [info sobre esto aquí](http://dphoeniixx.com/2020/12/13-2/).

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Inspección de la capa de transporte y fallos de verificación

- **Los certificados no siempre son verificados correctamente** por las aplicaciones Android. Es común que estas aplicaciones omitan advertencias y acepten certificados self-signed o, en algunos casos, vuelvan a usar conexiones HTTP.
- **Las negociaciones durante el handshake SSL/TLS a veces son débiles**, empleando suites de cifrado inseguras. Esta vulnerabilidad hace la conexión susceptible a ataques MITM, permitiendo a un atacante descifrar los datos.
- **La filtración de información privada** es un riesgo cuando las aplicaciones se autentican usando canales seguros pero luego comunican otras transacciones por canales no seguros. Este enfoque no protege datos sensibles, como cookies de sesión o detalles de usuario, frente a la intercepción por actores maliciosos.

#### Verificación de certificados

Nos centraremos en la **verificación de certificados**. La integridad del certificado del servidor debe verificarse para mejorar la seguridad. Esto es crucial porque configuraciones TLS inseguras y la transmisión de datos sensibles por canales no cifrados pueden suponer riesgos significativos. Para pasos detallados sobre cómo verificar certificados de servidor y mitigar vulnerabilidades, [**este recurso**](https://manifestsecurity.com/android-application-security-part-10/) ofrece una guía completa.

#### SSL Pinning

SSL Pinning es una medida de seguridad donde la aplicación verifica el certificado del servidor frente a una copia conocida almacenada dentro de la propia aplicación. Este método es esencial para prevenir ataques MITM. Se recomienda implementar SSL Pinning en aplicaciones que manejan información sensible.

#### Inspección de tráfico

Para inspeccionar tráfico HTTP es necesario **instalar el certificado del proxy** (por ejemplo, Burp). Sin instalar este certificado, el tráfico cifrado podría no ser visible a través del proxy. Para una guía sobre cómo instalar un certificado CA personalizado, [**haz clic aquí**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Las aplicaciones dirigidas a **API Level 24 and above** requieren modificaciones en el Network Security Config para aceptar el certificado CA del proxy. Este paso es crítico para inspeccionar tráfico cifrado. Para instrucciones sobre cómo modificar el Network Security Config, [**consulta este tutorial**](make-apk-accept-ca-certificate.md).

Si se está usando **Flutter** debes seguir las instrucciones en [**esta página**](flutter.md). Esto se debe a que, simplemente añadiendo el certificado al store no funcionará ya que Flutter tiene su propia lista de CAs válidas.

#### Detección estática de SSL/TLS pinning

Antes de intentar bypasses en tiempo de ejecución, mapea rápidamente dónde se aplica el pinning en el APK. El descubrimiento estático te ayuda a planificar hooks/patches y a centrarte en las rutas de código correctas.

Tool: SSLPinDetect
- Utilidad open-source de análisis estático que descompila el APK a Smali (vía apktool) y escanea patrones regex curados de implementaciones de SSL/TLS pinning.
- Reporta la ruta exacta del archivo, número de línea y un snippet de código para cada coincidencia.
- Cubre frameworks comunes y rutas de código personalizadas: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init con TrustManagers/KeyManagers personalizados, y pins en Network Security Config XML.

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Uso
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Ejemplo de reglas de patrones (JSON)
Utiliza o amplía signatures para detectar estilos de pinning propietarios/personalizados. Puedes cargar tu propio JSON y escanear a gran escala.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes and tips
- Escaneo rápido en aplicaciones grandes mediante multi-threading y memory-mapped I/O; las regex precompiladas reducen la sobrecarga y los falsos positivos.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Objetivos típicos de detección para priorizar a continuación:
- OkHttp: uso de CertificatePinner, setCertificatePinner, referencias al paquete okhttp3/okhttp
- TrustManagers personalizados: javax.net.ssl.X509TrustManager, overrides de checkServerTrusted
- Contextos SSL personalizados: SSLContext.getInstance + SSLContext.init con managers personalizados
- Pins declarativos en res/xml network security config y referencias en el manifest
- Usa las ubicaciones coincidentes para planear Frida hooks, parches estáticos o revisiones de configuración antes de las pruebas dinámicas.



#### Evasión de SSL Pinning

Cuando se implementa SSL Pinning, es necesario evadirlo para inspeccionar el tráfico HTTPS. Existen varios métodos para este propósito:

- Automáticamente **modifica** el **apk** para **evadir** SSLPinning con [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). La mayor ventaja de esta opción es que no necesitarás root para evadir el SSL Pinning, pero tendrás que borrar la aplicación e instalar la nueva, y esto no siempre funcionará.
- Puedes usar **Frida** (visto abajo) para evadir esta protección. Aquí tienes una guía para usar Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- También puedes intentar **evadir automáticamente SSL Pinning** usando [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- También puedes intentar **evadir automáticamente SSL Pinning** usando el análisis dinámico de **MobSF** (explicado abajo)
- Si aún crees que hay tráfico que no estás capturando, puedes intentar reenviar el tráfico a Burp usando iptables. Lee este blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Buscando vulnerabilidades web comunes

También es importante buscar vulnerabilidades web comunes dentro de la aplicación. La información detallada sobre cómo identificarlas y mitigarlas excede el alcance de este resumen pero está ampliamente cubierta en otros lugares.

### Frida

[Frida](https://www.frida.re) es un toolkit de instrumentación dinámica para desarrolladores, ingenieros inversos e investigadores de seguridad.\
**Puedes acceder a la aplicación en ejecución y hookear métodos en tiempo de ejecución para cambiar el comportamiento, modificar valores, extraer valores, ejecutar código diferente...**\
Si quieres pentest aplicaciones Android necesitas saber cómo usar Frida.

- Aprende a usar Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Algunas "GUI" para acciones con Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection es genial para automatizar el uso de Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Puedes encontrar algunos scripts Awesome de Frida aquí: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Intenta evadir mecanismos anti-debugging / anti-frida cargando Frida como se indica en [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (herramienta [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Volcar memoria - Fridump**

Comprueba si la aplicación está almacenando información sensible en la memoria que no debería, como contraseñas o mnemónicos.

Usando [**Fridump3**](https://github.com/rootbsd/fridump3) puedes volcar la memoria de la app con:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Esto volcará la memoria en la carpeta ./dump, y allí podrías hacer grep con algo como:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Datos sensibles en Keystore**

En Android, el Keystore es el mejor lugar para almacenar datos sensibles; sin embargo, con suficientes privilegios todavía es **posible acceder a él**. Como las aplicaciones tienden a almacenar aquí **datos sensibles en texto claro**, los pentests deberían comprobarlo, ya que un root user o alguien con acceso físico al dispositivo podría robar estos datos.

Incluso si una app almacenara datos en el Keystore, los datos deberían estar cifrados.

Para acceder a los datos dentro del Keystore puedes usar este script de Frida: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Usando el siguiente script de Frida podría ser posible **bypass fingerprint authentication** que las aplicaciones Android podrían estar realizando para **proteger ciertas áreas sensibles:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Imágenes de fondo**

Cuando pones una aplicación en segundo plano, Android almacena una **instantánea de la aplicación** para que, cuando se recupere al primer plano, comience a cargar la imagen antes que la propia aplicación, haciendo que parezca que se carga más rápido.

Sin embargo, si esta instantánea contiene **información sensible**, alguien con acceso a la instantánea podría **robar esa información** (nota: se necesita root para acceder a ella).

Las instantáneas suelen almacenarse en: **`/data/system_ce/0/snapshots`**

Android proporciona una forma de **evitar la captura de pantalla configurando el parámetro de layout FLAG_SECURE**. Al usar esta flag, el contenido de la ventana se trata como seguro, impidiendo que aparezca en capturas de pantalla o que se vea en pantallas no seguras.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Esta herramienta puede ayudarte a gestionar diferentes herramientas durante el análisis dinámico: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Los desarrolladores a menudo crean componentes proxy como activities, services y broadcast receivers que manejan estos Intents y los pasan a métodos como `startActivity(...)` o `sendBroadcast(...)`, lo cual puede ser arriesgado.

El peligro radica en permitir que atacantes activen componentes de la app no exportados o accedan a content providers sensibles al redirigir estos Intents. Un ejemplo notable es el componente `WebView` que convierte URLs en objetos `Intent` mediante `Intent.parseUri(...)` y luego los ejecuta, lo que puede conducir a malicious Intent injections.

### Conclusiones esenciales

- **Intent Injection** es similar al Open Redirect de la web.
- Los exploits implican pasar objetos `Intent` como extras, que pueden ser redirigidos para ejecutar operaciones inseguras.
- Puede exponer componentes no exportados y content providers a atacantes.
- La conversión de URLs a `Intent` que realiza `WebView` puede facilitar acciones no intencionadas.

### Inyecciones del lado cliente en Android y otras

Probablemente conozcas este tipo de vulnerabilidades por la Web. Debes tener especial cuidado con estas vulnerabilidades en una aplicación Android:

- **SQL Injection:** Al manejar queries dinámicas o Content-Providers, asegúrate de usar consultas parametrizadas.
- **JavaScript Injection (XSS):** Verifica que el soporte de JavaScript y Plugins esté deshabilitado para cualquier WebView (deshabilitado por defecto). [Más info aquí](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** Los WebViews deberían tener el acceso al sistema de archivos deshabilitado (habilitado por defecto) - `(webview.getSettings().setAllowFileAccess(false);)`. [Más info aquí](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: En varios casos cuando la aplicación android termina la sesión, la cookie no se revoca o incluso puede guardarse en disco
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Análisis automático

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Análisis estático**

![](<../../images/image (866).png>)

**Evaluación de vulnerabilidades de la aplicación** usando una interfaz web agradable. También puedes realizar análisis dinámico (pero necesitas preparar el entorno).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Assisted Dynamic analysis with MobSF

**MobSF** can also be very helpful for **dynamic analysis** in **Android**, but in that case you will need to install MobSF and **genymotion** in your host (a VM or Docker won't work). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
The **MobSF dynamic analyser** can:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). All of this is done automatically except for the screenshots, you need to press when you want a screenshot or you need to press "**Exported Activity Tester**" to obtain screenshots of all the exported activities.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: It will print all the loaded classes
- **Capture Strings**: It will print all the capture strings while using the application (super noisy)
- **Capture String Comparisons**: Could be very useful. It will **show the 2 strings being compared** and if the result was True or False.
- **Enumerate Class Methods**: Put the class name (like "java.io.File") and it will print all the methods of the class.
- **Search Class Pattern**: Search classes by pattern
- **Trace Class Methods**: **Trace** a **whole class** (see inputs and outputs of all methods of th class). Remember that by default MobSF traces several interesting Android Api methods.

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf also brings you a shell with some **adb** commands, **MobSF commands**, and common **shell** **commands** at the bottom of the dynamic analysis page. Some interesting commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**Herramientas HTTP**

Cuando el tráfico HTTP es capturado puedes ver una vista fea del tráfico capturado en el botón "**HTTP(S) Traffic**" inferior o una vista más agradable en el botón verde "**Start HTTPTools**". Desde la segunda opción, puedes **enviar** las **solicitudes capturadas** a **proxies** como Burp o Owasp ZAP.\
Para ello, _enciende Burp -->_ _desactiva Intercept --> en MobSB HTTPTools selecciona la solicitud_ --> pulsa "**Send to Fuzzer**" --> _selecciona la dirección del proxy_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Una vez finalices el análisis dinámico con MobSF puedes pulsar "**Start Web API Fuzzer**" para **fuzz http requests** y buscar vulnerabilidades.

> [!TIP]
> Después de realizar un análisis dinámico con MobSF la configuración del proxy puede quedar mal configurada y no podrás arreglarla desde la GUI. Puedes corregir la configuración del proxy haciendo:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Análisis Dinámico Asistido con Inspeckage

Puedes obtener la herramienta desde [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Esta herramienta usará algunos **Hooks** para informarte **qué está sucediendo en la aplicación** mientras realizas un **análisis dinámico**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Esta es una **excelente herramienta para realizar análisis estático con una GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Esta herramienta está diseñada para buscar varias **vulnerabilidades de aplicaciones Android relacionadas con la seguridad**, ya sea en **código fuente** o en **APKs empaquetados**. La herramienta también es **capaz de crear un APK desplegable "Proof-of-Concept"** y **ADB commands**, para explotar algunas de las vulnerabilidades encontradas (Exposed activities, intents, tapjacking...). Al igual que con Drozer, no es necesario rootear el dispositivo de prueba.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Muestra todos los archivos extraídos para facilitar la consulta
- Descompila automáticamente archivos APK a formato Java y Smali
- Analiza AndroidManifest.xml en busca de vulnerabilidades y comportamientos comunes
- Análisis estático del código fuente en busca de vulnerabilidades y comportamientos comunes
- Información del dispositivo
- y más
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER es una aplicación de línea de comandos que puede usarse en Windows, MacOS X y Linux, y que analiza archivos _.apk_ en busca de vulnerabilidades. Lo hace descomprimiendo APKs y aplicando una serie de reglas para detectar esas vulnerabilidades.

Todas las reglas están centralizadas en un archivo `rules.json`, y cada empresa o tester puede crear sus propias reglas para analizar lo que necesite.

Descarga los últimos binarios desde la [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn es una herramienta **crossplatform** que ayuda a desarrolladores, bugbounty hunters y ethical hackers a realizar [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) en aplicaciones móviles.

El concepto es que arrastres y sueltes el archivo de tu aplicación móvil (un .apk o .ipa file) en la aplicación StaCoAn y ésta generará un informe visual y portable para ti. Puedes ajustar la configuración y las wordlists para obtener una experiencia personalizada.

Descargar[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework es un sistema de análisis de vulnerabilidades para Android que ayuda a desarrolladores o hackers a encontrar posibles vulnerabilidades de seguridad en aplicaciones Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** es una herramienta cuyo objetivo principal es detectar y advertir al usuario sobre posibles comportamientos maliciosos desarrollados por una aplicación Android.

La detección se realiza mediante el **análisis estático** del bytecode Dalvik de la aplicación, representado como **Smali**, con la librería [`androguard`](https://github.com/androguard/androguard).

Esta herramienta busca **comportamientos comunes de aplicaciones "malas"** como: exfiltración de identificadores de telefonía, intercepción de flujos de audio/video, modificación de datos PIM, ejecución arbitraria de código...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. Es una herramienta que reúne herramientas comúnmente usadas de reverse engineering y análisis de aplicaciones móviles, para ayudar en las pruebas de aplicaciones móviles frente a las amenazas de seguridad móviles de OWASP. Su objetivo es hacer esta tarea más fácil y accesible para desarrolladores de aplicaciones móviles y profesionales de seguridad.

It is able to:

- Extract Java and Smali code using different tools
- Analyze APKs using: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Extract private information from the APK using regexps.
- Analyze the Manifest.
- Analyze found domains using: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Útil para detectar malware: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Ten en cuenta que, dependiendo del servicio y la configuración que uses para ofuscar el código, los secretos pueden o no quedar ofuscados.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. It is able to optimize bytecode as well as detect and remove unused instructions. ProGuard is free software and is distributed under the GNU General Public License, version 2.

ProGuard is distributed as part of the Android SDK and runs when building the application in release mode.

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Last time we checked, the Dexguard mode of operation was:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

Puedes subir un APK ofuscado a su plataforma.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

It is a **generic android deobfuscator.** Simplify **virtually executes an app** to understand its behavior and then **tries to optimize the code** so it behaves identically but is easier for a human to understand. Each optimization type is simple and generic, so it doesn't matter what the specific type of obfuscation is used.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD gives you information about **how an APK was made**. It identifies many **compilers**, **packers**, **obfuscators**, and other weird stuff. It's [_PEiD_](https://www.aldeid.com/wiki/PEiD) for Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b is an Android security virtual machine based on ubuntu-mate includes the collection of latest framework, tutorials and labs from different security geeks and researchers for reverse engineering and malware analysis.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Es una gran lista de recursos
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)

## Yet to try

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
