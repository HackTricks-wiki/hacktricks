# Pentesting aplikacji Android

{{#include ../../banners/hacktricks-training.md}}

## Podstawy aplikacji Android

Zaleca się rozpocząć od przeczytania tej strony, aby poznać **najważniejsze elementy związane z bezpieczeństwem Androida oraz najbardziej niebezpieczne komponenty w aplikacji Android**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

To główne narzędzie, którego potrzebujesz, aby połączyć się z urządzeniem Android (emulowanym lub fizycznym).\
**ADB** pozwala kontrolować urządzenia zarówno przez **USB**, jak i przez **sieć** z komputera. To narzędzie umożliwia **kopiowanie** plików w obu kierunkach, **instalację** i **odinstalowanie** aplikacji, **wykonywanie** poleceń shell, **tworzenie kopii zapasowych** danych, **odczytywanie** logów i inne funkcje.

Zobacz następującą listę [**ADB Commands**](adb-commands.md), aby nauczyć się używać adb.

## Smali

Czasami warto **modyfikować kod aplikacji**, aby uzyskać dostęp do **ukrytych informacji** (np. dobrze obfuskowane hasła lub flagi). Wówczas może być interesujące zdekompilować APK, zmodyfikować kod i ponownie go skompilować.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). To może być bardzo przydatne jako **alternatywa dla kilku testów podczas dynamic analysis**, które zostaną zaprezentowane. Zawsze miej tę możliwość na uwadze.

## Other interesting tricks

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Wyodrębnij APK z urządzenia:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Połącz wszystkie splits i base apks za pomocą [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Case Studies & Vulnerabilities


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Static Analysis

Przede wszystkim, aby analizować APK powinieneś **rzucić okiem na kod Java** używając decompiler'a.\
Proszę, [**przeczytaj tutaj aby znaleźć informacje o różnych dostępnych decompilerach**](apk-decompilers.md).

### Looking for interesting Info

Wystarczy spojrzeć na **strings** z APK, aby wyszukać **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** i wszystko, co interesujące... sprawdź nawet obecność backdoorów do wykonania kodu lub backdoorów uwierzytelniania (hardcoded admin credentials w aplikacji).

**Firebase**

Zwróć szczególną uwagę na **firebase URLs** i sprawdź, czy nie są źle skonfigurowane. [Więcej informacji o tym czym jest Firebase i jak to eksploatować znajdziesz tutaj.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Basic understanding of the application - Manifest.xml, strings.xml

**Badanie plików _Manifest.xml_ oraz _strings.xml_ aplikacji może ujawnić potencjalne luki bezpieczeństwa**. Do tych plików można uzyskać dostęp używając decompilerów lub zmieniając rozszerzenie pliku APK na .zip i rozpakowując go.

**Luki** zidentyfikowane w **Manifest.xml** obejmują:

- **Debuggable Applications**: Aplikacje ustawione jako debuggable (`debuggable="true"`) w pliku _Manifest.xml_ stanowią ryzyko, ponieważ pozwalają na połączenia, które mogą prowadzić do eksploatacji. Aby lepiej zrozumieć jak eksploatować debuggable applications, odnieś się do tutoriala o znajdowaniu i wykorzystywaniu debuggable applications na urządzeniu.
- **Backup Settings**: Atrybut `android:allowBackup="false"` powinien być jawnie ustawiony dla aplikacji przetwarzających wrażliwe informacje, aby zapobiec nieautoryzowanym backupom danych przez adb, szczególnie gdy usb debugging jest włączone.
- **Network Security**: Niestandardowe konfiguracje network security (`android:networkSecurityConfig="@xml/network_security_config"`) w _res/xml/_ mogą określać szczegóły bezpieczeństwa takie jak certificate pins i ustawienia ruchu HTTP. Przykładem jest pozwolenie na HTTP traffic dla wybranych domen.
- **Exported Activities and Services**: Identyfikacja exported activities i services w manifeście może ujawnić komponenty, które mogą być nadużyte. Dalsza analiza podczas dynamic testing może pokazać jak eksploatować te komponenty.
- **Content Providers and FileProviders**: Udostępnione content providers mogą pozwolić na nieautoryzowany dostęp lub modyfikację danych. Konfiguracja FileProviders powinna być również dokładnie sprawdzona.
- **Broadcast Receivers and URL Schemes**: Te komponenty mogą być wykorzystane do eksploatacji, ze szczególnym uwzględnieniem sposobu obsługi URL schemes pod kątem podatności wejścia.
- **SDK Versions**: Atrybuty `minSdkVersion`, `targetSDKVersion` i `maxSdkVersion` wskazują wspierane wersje Androida, co podkreśla znaczenie nie wspierania przestarzałych, podatnych wersji Androida ze względów bezpieczeństwa.

Z pliku **strings.xml** można odkryć wrażliwe informacje takie jak API keys, custom schemas oraz inne notatki deweloperskie, co podkreśla potrzebę uważnego przeglądu tych zasobów.

### Tapjacking

**Tapjacking** to atak, w którym **malicious** **application** jest uruchamiana i **pozycjonuje się nad aplikacją ofiary**. Gdy zasłoni aplikację ofiary, jej interfejs użytkownika jest zaprojektowany w taki sposób, by oszukać użytkownika, skłaniając go do interakcji, podczas gdy interakcja jest przekazywana do aplikacji ofiary.\
W praktyce jest to **oślepianie użytkownika, przez co nie wie, że faktycznie wykonuje akcje w aplikacji ofiary**.

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Aktywność z `launchMode` ustawionym na **`singleTask` bez zdefiniowanego `taskAffinity`** jest podatna na task Hijacking. Oznacza to, że **aplikacja** może zostać zainstalowana i jeśli zostanie uruchomiona przed prawdziwą aplikacją, może **przejąć task prawdziwej aplikacji** (więc użytkownik będzie wchodził w interakcję z **malicious application myśląc, że używa prawdziwej**).

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Insecure data storage

**Internal Storage**

W Androidzie pliki **przechowywane** w **internal** storage są **zaprojektowane** tak, aby były dostępne wyłącznie dla **app**, która je **utworzyła**. Ten mechanizm bezpieczeństwa jest **wymuszany** przez system Android i ogólnie jest wystarczający dla potrzeb bezpieczeństwa większości aplikacji. Jednak deweloperzy czasami używają trybów takich jak `MODE_WORLD_READABLE` i `MODE_WORLD_WRITABLE`, aby **pozwolić** na współdzielenie plików między różnymi aplikacjami. Te tryby **nie ograniczają jednak dostępu** do tych plików przez inne aplikacje, w tym potencjalnie malicious ones.

1. **Static Analysis:**
- **Upewnij się**, że użycie `MODE_WORLD_READABLE` i `MODE_WORLD_WRITABLE` jest **dokładnie sprawdzone**. Te tryby **mogą potencjalnie ujawnić** pliki dla **niezamierzonego lub nieautoryzowanego dostępu**.
2. **Dynamic Analysis:**
- **Zweryfikuj** uprawnienia ustawione na plikach tworzonych przez aplikację. Konkretnie **sprawdź**, czy jakieś pliki nie zostały ustawione jako czytelne lub zapisywalne dla wszystkich. To może stanowić poważne ryzyko bezpieczeństwa, ponieważ umożliwiłoby **dowolnej aplikacji** zainstalowanej na urządzeniu, niezależnie od jej pochodzenia czy intencji, **odczyt lub modyfikację** tych plików.

**External Storage**

Przy pracy z plikami na **external storage**, takimi jak SD Cards, należy zachować następujące środki ostrożności:

1. **Accessibility**:
- Pliki na external storage są **globalnie czytelne i zapisywalne**. Oznacza to, że dowolna aplikacja lub użytkownik może mieć do nich dostęp.
2. **Security Concerns**:
- Ze względu na łatwy dostęp, nie zaleca się **przechowywania wrażliwych informacji** na external storage.
- External storage może być usunięty lub dostępny dla dowolnej aplikacji, co czyni go mniej bezpiecznym.
3. **Handling Data from External Storage**:
- Zawsze **przeprowadzaj walidację wejścia** danych pobieranych z external storage. To kluczowe, ponieważ dane pochodzą z nieufnego źródła.
- Przechowywanie plików wykonywalnych lub klas na external storage do dynamicznego ładowania jest zdecydowanie odradzane.
- Jeśli aplikacja musi pobierać pliki wykonywalne z external storage, upewnij się, że są one **podpisane i zweryfikowane kryptograficznie** przed dynamicznym załadowaniem. Ten krok jest niezbędny dla zachowania integralności bezpieczeństwa aplikacji.

External storage can be **accessed** in `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> Starting with Android 4.4 (**API 17**), the SD card has a directory structure which **limits access from an app to the directory which is specifically for that app**. This prevents malicious application from gaining read or write access to another app's files.

**Sensitive data stored in clear-text**

- **Shared preferences**: Android allow to each application to easily save xml files in the path `/data/data/<packagename>/shared_prefs/` and sometimes it's possible to find sensitive information in clear-text in that folder.
- **Databases**: Android allow to each application to easily save sqlite databases in the path `/data/data/<packagename>/databases/` and sometimes it's possible to find sensitive information in clear-text in that folder.

### Broken TLS

**Accept All Certificates**

Z jakiegoś powodu deweloperzy czasami akceptują wszystkie certyfikaty, nawet jeśli na przykład nazwa hosta nie pasuje, używając linii kodu takich jak poniższa:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Błędna kryptografia

**Słabe procesy zarządzania kluczami**

Niektórzy deweloperzy zapisują dane wrażliwe w local storage i szyfrują je kluczem zakodowanym na stałe/przewidywalnym w kodzie. Nie powinno się tego robić, ponieważ pewne techniki reversing mogą pozwolić atakującym na wyciągnięcie poufnych informacji.

**Użycie niebezpiecznych i/lub przestarzałych algorytmów**

Deweloperzy nie powinni używać **deprecated algorithms** do wykonywania autoryzacyjnych **checks**, **store** lub **send** danych. Niektóre z tych algorytmów to: RC4, MD4, MD5, SHA1... Jeśli **hashes** są używane do przechowywania haseł na przykład, należy używać hashów odpornych na brute-force z salt.

### Inne sprawdzenia

- It's recommended to **obfuscate the APK** to difficult the reverse engineer labour to attackers.
- If the app is sensitive (like bank apps), it should perform it's **own checks to see if the mobile is rooted** and act in consequence.
- If the app is sensitive (like bank apps), it should check if an **emulator** is being used.
- If the app is sensitive (like bank apps), it should **check it's own integrity before executing** it to check if it was modified.
- Use [**APKiD**](https://github.com/rednaga/APKiD) to check which compiler/packer/obfuscator was used to build the APK

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

The tool [**mariana-trench**](https://github.com/facebook/mariana-trench) is capable of finding **vulnerabilities** by **scanning** the **code** of the application. This tool contains a series of **known sources** (that indicates to the tool the **places** where the **input** is **controlled by the user**), **sinks** (which indicates to the tool **dangerous** **places** where malicious user input could cause damages) and **rules**. These rules indicates the **combination** of **sources-sinks** that indicates a vulnerability.

With this knowledge, **mariana-trench will review the code and find possible vulnerabilities on it**.

### Secrets leaked

An application may contain secrets (API keys, passwords, hidden urls, subdomains...) inside of it that you might be able to discover. You could us a tool such as [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Analiza dynamiczna

> First of all, you need an environment where you can install the application and all the environment (Burp CA cert, Drozer and Frida mainly). Therefore, a rooted device (emulated or not) is extremely recommended.

### Online Dynamic analysis

You can create a **free account** in: [https://appetize.io/](https://appetize.io). This platform allows you to **upload** and **execute** APKs, so it is useful to see how an apk is behaving.

You can even **see the logs of your application** in the web and connect through **adb**.

![](<../../images/image (831).png>)

Thanks to the ADB connection you can use **Drozer** and **Frida** inside the emulators.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (You can create **x86** and **arm** devices, and according to [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** versions **support ARM libraries** without needing an slow arm emulator).
- Learn to set it up in this page:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, you need to create an account. _It's recommend to **download** the version **WITH**_ _**VirtualBox** to avoid potential errors._)
- [**Nox**](https://es.bignox.com) (Free, but it doesn't support Frida or Drozer).

> [!TIP]
> When creating a new emulator on any platform remember that the bigger the screen is, the slower the emulator will run. So select small screens if possible.

To **install google services** (like AppStore) in Genymotion you need to click on the red marked button of the following image:

![](<../../images/image (277).png>)

Also, notice that in the **configuration of the Android VM in Genymotion** you can select **Bridge Network mode** (this will be useful if you will be connecting to the Android VM from a different VM with the tools).

#### Use a physical device

You need to activate the **debugging** options and it will be cool if you can **root** it:

1. **Ustawienia**.
2. (FromAndroid 8.0) Wybierz **System**.
3. Wybierz **Informacje o telefonie**.
4. Naciśnij **Numer kompilacji** 7 razy.
5. Wróć i znajdziesz **Opcje programistyczne**.

> Once you have installed the application, the first thing you should do is to try it and investigate what does it do, how does it work and get comfortable with it.\
> I will suggest to **perform this initial dynamic analysis using MobSF dynamic analysis + pidcat**, so we will be able to **learn how the application works** while MobSF **captures** a lot of **interesting** **data** you can review later on.

### Unintended Data Leakage

**Logging**

Deweloperzy powinni być ostrożni z ujawnianiem informacji debugowych publicznie, ponieważ może to prowadzić do sensitive data leaks. Narzędzia [**pidcat**](https://github.com/JakeWharton/pidcat) i `adb logcat` są rekomendowane do monitorowania logów aplikacji w celu identyfikacji i ochrony wrażliwych informacji. **Pidcat** jest preferowany ze względu na łatwość użycia i czytelność.

> [!WARNING]
> Note that from **later newer than Android 4.0**, **applications are only able to access their own logs**. So applications cannot access other apps logs.\
> Anyway, it's still recommended to **not log sensitive information**.

**Copy/Paste Buffer Caching**

Android's **clipboard-based** framework umożliwia funkcjonalność copy-paste w aplikacjach, jednak stanowi ryzyko, ponieważ **inne aplikacje** mogą **uzyskać dostęp** do schowka, potencjalnie ujawniając wrażliwe dane. Kluczowe jest **wyłączenie funkcji copy/paste** dla wrażliwych sekcji aplikacji, takich jak dane karty kredytowej, aby zapobiec data leaks.

**Crash Logs**

Jeśli aplikacja **crashuje** i **zapisuje logi**, te logi mogą pomóc atakującym, szczególnie gdy aplikacja nie może zostać łatwo reverse-engineerowana. Aby zminimalizować to ryzyko, unikaj logowania przy crashach, a jeśli logi muszą być przesyłane przez sieć, upewnij się, że są wysyłane przez kanał SSL dla bezpieczeństwa.

Jako pentester, **spróbuj rzucić okiem na te logi**.

**Analytics Data Sent To 3rd Parties**

Aplikacje często integrują usługi takie jak Google Adsense, które mogą przypadkowo leak sensitive data z powodu nieprawidłowej implementacji przez deweloperów. Aby zidentyfikować potencjalne wycieki danych, zaleca się przechwycenie ruchu aplikacji i sprawdzenie, czy jakiekolwiek wrażliwe informacje są wysyłane do usług zewnętrznych.

### SQLite DBs

Większość aplikacji używa **internal SQLite databases** do zapisywania informacji. Podczas pentestu przyjrzyj się **bazom danych** utworzonym, nazwom **tabel** i **kolumn** oraz wszystkim zapisanym **danym**, ponieważ możesz znaleźć **sensitive information** (co byłoby podatnością).\
Bazy danych powinny znajdować się w /data/data/the.package.name/databases, np. /data/data/com.mwr.example.sieve/databases

Jeśli baza danych zapisuje poufne informacje i jest **encrypted** ale możesz **find** hasło wewnątrz aplikacji, to nadal jest to **vulnerability**.

Enumeruj tabele używając `.tables` i enumeruj kolumny tabel używając `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer is s useful tool to **exploit exported activities, exported services and Content Providers** as you will learn in the following sections.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Also remember that the code of an activity starts in the **`onCreate`** method.

**Authorisation bypass**

When an Activity is exported you can invoke its screen from an external app. Therefore, if an activity with **sensitive information** is **exported** you could **bypass** the **authentication** mechanisms **to access it.**

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

You can also start an exported activity from adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> Należy pamiętać, że authorisation bypass nie zawsze jest podatnością — zależy to od tego, jak bypass działa i jakie informacje są ujawniane.

**Sensitive information leakage**

Activities mogą również zwracać wyniki. Jeśli uda Ci się znaleźć eksportowaną i niezabezpieczoną activity wywołującą metodę **`setResult`** i **zwracającą poufne informacje**, istnieje sensitive information leakage.

#### Tapjacking

Jeśli Tapjacking nie jest zapobiegany, możesz nadużyć eksportowanej activity, aby sprawić, że **użytkownik wykona nieoczekiwane akcje**. Po więcej informacji o [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Przeczytaj to, jeśli chcesz odświeżyć, czym jest Content Provider.**](android-applications-basics.md#content-provider)\
Content providers są zasadniczo używane do **udostępniania danych**. Jeśli aplikacja ma dostępne content providers, możesz być w stanie **wydobyć poufne** dane z nich. Warto również przetestować potencjalne **SQL injections** i **Path Traversals**, ponieważ mogą być podatne.

[**Dowiedz się, jak exploitować Content Providers przy użyciu Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Przeczytaj to, jeśli chcesz odświeżyć, czym jest Service.**](android-applications-basics.md#services)\
Pamiętaj, że działania Service zaczynają się w metodzie `onStartCommand`.

Service jest zasadniczo czymś, co **może odbierać dane**, **przetwarzać** je i **zwracać** (lub nie) odpowiedź. Zatem, jeśli aplikacja eksportuje jakieś services, powinieneś **sprawdzić** **kod**, aby zrozumieć, co robi, i **przetestować** go **dynamicznie** w celu wydobycia poufnych informacji, obejścia mechanizmów uwierzytelniania...\
[**Dowiedz się, jak exploitować Services przy użyciu Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Przeczytaj to, jeśli chcesz odświeżyć, czym jest Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Pamiętaj, że działania Broadcast Receiver zaczynają się w metodzie `onReceive`.

Broadcast Receiver będzie oczekiwał na określony typ komunikatu. W zależności od tego, jak receiver obsługuje wiadomość, może być podatny.\
[**Dowiedz się, jak exploitować Broadcast Receivers przy użyciu Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Możesz szukać deep links ręcznie, używając narzędzi takich jak MobSF lub skryptów takich jak [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Możesz **otworzyć** zadeklarowany **scheme** używając **adb** lub **przeglądarki**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Zauważ, że możesz **pominąć nazwę pakietu**, a urządzenie mobilne automatycznie wywoła aplikację, która powinna otworzyć ten link._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Kod wykonywany**

Aby znaleźć **kod, który zostanie wykonany w App**, przejdź do activity wywoływanej przez deeplink i wyszukaj funkcję **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Wrażliwe dane**

Za każdym razem, gdy znajdziesz deep link, sprawdź, czy **nie otrzymuje on wrażliwych danych (like passwords) via URL parameters**, ponieważ dowolna inna aplikacja może **impersonate the deep link and steal that data!**

**Parametry w ścieżce**

You **must check also if any deep link is using a parameter inside the path** of the URL like: `https://api.example.com/v1/users/{username}` , in that case you can force a path traversal accessing something like: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Note that if you find the correct endpoints inside the application you may be able to cause a **Open Redirect** (if part of the path is used as domain name), **account takeover** (if you can modify users details without CSRF token and the vuln endpoint used the correct method) and any other vuln. More [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Inspekcja warstwy transportowej i błędy weryfikacji

- **Certyfikaty nie zawsze są właściwie weryfikowane** przez aplikacje Android. Często aplikacje pomijają ostrzeżenia i akceptują certyfikaty samopodpisane lub, w niektórych przypadkach, wracają do używania połączeń HTTP.
- **Negocjacje podczas SSL/TLS handshake bywają czasem słabe**, używając niebezpiecznych zestawów szyfrów. Ta podatność naraża połączenie na man-in-the-middle (MITM) i pozwala atakującym odszyfrować dane.
- **Leakage of private information** jest ryzykiem, gdy aplikacje uwierzytelniają się przy użyciu secure channels, a następnie komunikują się przez non-secure channels dla innych transakcji. Takie podejście nie chroni wrażliwych danych, takich jak session cookies czy dane użytkownika, przed przechwyceniem przez złośliwe podmioty.

#### Weryfikacja certyfikatu

Skupimy się na **weryfikacji certyfikatu**. Integralność certyfikatu serwera musi być weryfikowana, aby zwiększyć bezpieczeństwo. Jest to kluczowe, ponieważ niebezpieczne konfiguracje TLS i przesyłanie wrażliwych danych przez kanały niezabezpieczone mogą stanowić poważne ryzyko. Dla szczegółowych kroków dotyczących weryfikacji certyfikatów serwera i usuwania podatności, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) provides comprehensive guidance.

#### SSL Pinning

SSL Pinning to mechanizm bezpieczeństwa, w którym aplikacja weryfikuje certyfikat serwera względem znanej kopii przechowywanej w samej aplikacji. Ta metoda jest istotna w zapobieganiu atakom MITM. Implementacja SSL Pinning jest zdecydowanie zalecana dla aplikacji przetwarzających wrażliwe informacje.

#### Inspekcja ruchu

Aby analizować ruch HTTP, konieczne jest **zainstalowanie certyfikatu narzędzia proxy** (np. Burp). Bez instalacji tego certyfikatu zaszyfrowany ruch może być niewidoczny przez proxy. For a guide on installing a custom CA certificate, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Aplikacje targetujące **API Level 24 and above** wymagają modyfikacji Network Security Config, aby zaakceptować certyfikat CA proxy. Ten krok jest krytyczny do inspekcji zaszyfrowanego ruchu. For instructions on modifying the Network Security Config, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

If **Flutter** is being used you need to to follow the instructions in [**this page**](flutter.md). This is because samo dodanie certyfikatu do store nie wystarczy, ponieważ Flutter ma własną listę zaufanych CAs.

#### Statyczne wykrywanie SSL/TLS pinning

Przed próbami obejścia w czasie runtime szybko zmapuj miejsca, gdzie pinning jest wymuszany w APK. Odkrywanie statyczne pomaga zaplanować hooki/patchy i skupić się na właściwych ścieżkach kodu.

Tool: SSLPinDetect
- Open-source static-analysis utility that decompiles the APK to Smali (via apktool) and scans for curated regex patterns of SSL/TLS pinning implementations.
- Reports exact file path, line number, and a code snippet for each match.
- Covers common frameworks and custom code paths: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Użycie
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Przykładowe reguły wzorców (JSON)
Użyj lub rozszerz signatures, aby wykrywać proprietarne/niestandardowe style pinning. Możesz załadować własne JSON i skanować na dużą skalę.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes and tips
- Szybkie skanowanie dużych aplikacji poprzez wielowątkowość i I/O mapowane w pamięci; prekompilowane wyrażenia regularne zmniejszają narzut/fałszywe pozytywy.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Typowe cele detekcji do dalszej analizy:
- OkHttp: użycie CertificatePinner, setCertificatePinner, odniesienia do pakietu okhttp3/okhttp
- Niestandardowe TrustManagers: javax.net.ssl.X509TrustManager, nadpisania checkServerTrusted
- Niestandardowe konteksty SSL: SSLContext.getInstance + SSLContext.init z niestandardowymi managerami
- Deklaratywne pins w res/xml network security config i odniesienia w manifeście
- Wykorzystaj znalezione lokalizacje do zaplanowania hooków Frida, statycznych patchy lub przeglądu konfiguracji przed testami dynamicznymi.



#### Bypassing SSL Pinning

Gdy implementowane jest SSL Pinning, jego obejście staje się konieczne do inspekcji ruchu HTTPS. Do tego celu dostępne są różne metody:

- Automatycznie **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Największą zaletą tej opcji jest to, że nie będziesz potrzebować root, aby obejść SSL Pinning, ale będziesz musiał usunąć aplikację i zainstalować nową wersję, i nie zawsze to zadziała.
- Możesz użyć **Frida** (omówione poniżej) aby obejść tę ochronę. Tutaj jest przewodnik jak użyć Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Możesz także spróbować **automatycznie bypass SSL Pinning** używając [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Możesz także spróbować **automatycznie bypass SSL Pinning** używając **MobSF dynamic analysis** (wyjaśnione poniżej)
- Jeśli nadal uważasz, że jakiś ruch nie jest przechwytywany, możesz spróbować **przekierować ruch do burp za pomocą iptables**. Przeczytaj ten blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Looking for Common Web Vulnerabilities

Ważne jest również wyszukiwanie typowych podatności webowych w aplikacji. Szczegółowe informacje na temat identyfikacji i łagodzenia tych podatności wykraczają poza zakres tego podsumowania, ale są szeroko omówione w innych materiałach.

### Frida

[Frida](https://www.frida.re) jest dynamicznym toolkitem do instrumentacji dla deweloperów, reverse-engineerów i badaczy bezpieczeństwa.\
**Możesz uzyskać dostęp do działającej aplikacji i hookować metody w czasie wykonywania, aby zmieniać zachowanie, zmieniać wartości, wydobywać wartości, uruchamiać inny kod...**\
Jeśli chcesz pentest aplikacje Android musisz znać Frida.

- Naucz się używać Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Kilka "GUI" do działań z Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection świetnie automatyzuje użycie Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Możesz znaleźć świetne skrypty Frida tutaj: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Spróbuj obejść mechanizmy anti-debugging / anti-frida ładując Frida zgodnie z wskazówkami w [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (narzędzie [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

Sprawdź, czy aplikacja nie przechowuje w pamięci poufnych informacji, których nie powinna przechowywać, takich jak hasła czy mnemoniki.

Using [**Fridump3**](https://github.com/rootbsd/fridump3) you can dump the memory of the app with:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Spowoduje to zrzut pamięci do folderu ./dump, a następnie możesz tam użyć grep, np.:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Wrażliwe dane w Keystore**

W Androidzie Keystore jest najlepszym miejscem do przechowywania wrażliwych danych, jednak przy wystarczających uprawnieniach wciąż **możliwe jest uzyskanie do niego dostępu**. Ponieważ aplikacje mają tendencję do przechowywania tutaj **wrażliwych danych w postaci jawnej**, pentests powinny to sprawdzić jako root user, ponieważ osoba z fizycznym dostępem do urządzenia mogłaby ukraść te dane.

Nawet jeśli aplikacja zapisuje dane w Keystore, dane powinny być zaszyfrowane.

Aby uzyskać dostęp do danych w Keystore, możesz użyć tego skryptu Frida: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Używając poniższego skryptu Frida, możliwe może być **bypass fingerprint authentication**, które aplikacje Android mogą stosować w celu **ochrony niektórych wrażliwych obszarów:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Obrazy w tle**

Kiedy umieścisz aplikację w tle, Android zapisuje **zrzut aplikacji**, dzięki czemu po przywróceniu jej na pierwszy plan najpierw ładuje ten obraz, co sprawia, że aplikacja wydaje się uruchamiać szybciej.

Jednak jeśli ten zrzut zawiera **poufne informacje**, ktoś mający dostęp do zrzutu może **ukraść te dane** (uwaga: dostęp wymaga root).

Zrzuty są zwykle przechowywane w: **`/data/system_ce/0/snapshots`**

Android udostępnia sposób, by **zapobiec wykonywaniu zrzutów ekranu przez ustawienie parametru layout FLAG_SECURE**. Dzięki użyciu tej flagi zawartość okna jest traktowana jako zabezpieczona, co uniemożliwia jej pojawianie się na zrzutach ekranu lub wyświetlanie na niezabezpieczonych ekranach.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

To narzędzie może pomóc w zarządzaniu różnymi narzędziami podczas analizy dynamicznej: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Programiści często tworzą komponenty pośredniczące, takie jak activities, services i broadcast receivers, które obsługują te Intents i przekazują je do metod takich jak `startActivity(...)` lub `sendBroadcast(...)`, co może być ryzykowne.

Niebezpieczeństwo polega na umożliwieniu atakującym wywoływania non-exported komponentów aplikacji lub dostępu do wrażliwych content providers przez błędne skierowanie tych Intents. Dobrym przykładem jest komponent `WebView`, który konwertuje URL-e na obiekty `Intent` za pomocą `Intent.parseUri(...)` i następnie je wykonuje, co może prowadzić do złośliwych Intent injections.

### Essential Takeaways

- **Intent Injection** jest podobny do webowego problemu Open Redirect.
- Eksploity polegają na przekazywaniu obiektów `Intent` jako extras, które mogą zostać przekierowane do wykonania niebezpiecznych operacji.
- Może ujawnić atakującym non-exported komponenty i content providers.
- Konwersja URL-i na `Intent` przez `WebView` może ułatwiać wykonywanie niezamierzonych akcji.

### Android Client Side Injections and others

Prawdopodobnie znasz ten typ podatności z Web. Należy zachować szczególną ostrożność wobec tych podatności w aplikacji Android:

- **SQL Injection:** Przy obsłudze dynamicznych zapytań lub Content-Providers upewnij się, że używasz zapytań parametryzowanych.
- **JavaScript Injection (XSS):** Sprawdź, czy obsługa JavaScript i Pluginów jest wyłączona dla wszystkich WebViews (wyłączone domyślnie). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** Dostęp WebViews do systemu plików powinien być wyłączony (włączony domyślnie) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: W wielu przypadkach po zakończeniu sesji przez aplikację Android cookie nie jest unieważniane lub może zostać zapisane na dysku
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Static analysis**

![](<../../images/image (866).png>)

**Ocena podatności aplikacji** z użyciem przyjaznego webowego frontendu. Możesz także przeprowadzić analizę dynamiczną (ale musisz przygotować środowisko).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Assisted Dynamic analysis with MobSF

**MobSF** może być również bardzo pomocny przy **dynamic analysis** w **Android**, ale w tym przypadku musisz zainstalować MobSF i **genymotion** na swoim hoście (VM lub Docker nie zadziała). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
The **MobSF dynamic analyser** może:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). Wszystko to jest wykonywane automatycznie z wyjątkiem screenshotów — musisz nacisnąć gdy chcesz zrobić screenshot lub nacisnąć "**Exported Activity Tester**", aby uzyskać zrzuty ekranu wszystkich exported activities.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, automatycznie uruchomi **Frida** i ustawi globalne ustawienia **proxy** aby **capture** ruch. Będzie przechwytywać ruch tylko z testowanej aplikacji.

**Frida**

Domyślnie użyje też kilku Frida Scripts do **bypass SSL pinning**, **root detection** i **debugger detection** oraz do **monitor interesting APIs**.\
MobSF może także **invoke exported activities**, zrobić **screenshots** tych aktywności i **save** je do raportu.

Aby **start** testy dynamiczne naciśnij zielony przycisk: "**Start Instrumentation**". Naciśnij "**Frida Live Logs**", aby zobaczyć logi generowane przez Frida scripts oraz "**Live API Monitor**", aby zobaczyć wszystkie wywołania hooked methods, przekazane argumenty i zwracane wartości (pojawi się to po naciśnięciu "Start Instrumentation").\
MobSF pozwala też załadować własne Frida scripts (aby wysłać wyniki swoich Frida scripts do MobSF użyj funkcji `send()`). Ma też kilka pre-napisanych skryptów, które możesz załadować (możesz dodać więcej w `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), po prostu wybierz je, naciśnij "**Load**" i potem "**Start Instrumentation**" (będziesz mógł zobaczyć logi tych skryptów w "**Frida Live Logs**").

![](<../../images/image (419).png>)

Ponadto masz kilka dodatkowych funkcji Frida:

- **Enumerate Loaded Classes**: Wydrukuje wszystkie załadowane klasy
- **Capture Strings**: Wydrukuje wszystkie uchwycone stringi podczas używania aplikacji (bardzo głośne)
- **Capture String Comparisons**: Może być bardzo użyteczne. Pokaże 2 porównywane stringi oraz czy wynik był True czy False.
- **Enumerate Class Methods**: Wpisz nazwę klasy (np. "java.io.File") i wypisze wszystkie metody tej klasy.
- **Search Class Pattern**: Wyszukuje klasy po wzorcu
- **Trace Class Methods**: **Trace** całej klasy (zobacz wejścia i wyjścia wszystkich metod klasy). Pamiętaj, że domyślnie MobSF śledzi kilka interesujących Android Api methods.

Gdy wybierzesz moduł pomocniczy, którego chcesz użyć, musisz nacisnąć "**Start Intrumentation**" i zobaczysz wszystkie wyjścia w "**Frida Live Logs**".

**Shell**

Mobsf dostarcza też shell z kilkoma **adb** commands, **MobSF commands**, oraz typowymi **shell** **commands** na dole strony dynamic analysis. Kilka interesujących poleceń:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**Narzędzia HTTP**

Gdy ruch HTTP jest przechwycony, możesz zobaczyć surowy widok przechwyconego ruchu w przycisku "**HTTP(S) Traffic**" na dole lub ładniejszy widok w zielonym przycisku "**Start HTTPTools**". Z tej drugiej opcji możesz **wysłać** **przechwycone żądania** do **proxies** takich jak Burp lub Owasp ZAP.\
Aby to zrobić, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> naciśnij "**Send to Fuzzer**" --> _wybierz adres proxy_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Po zakończeniu dynamic analysis z MobSF możesz nacisnąć "**Start Web API Fuzzer**", aby **fuzz http requests** i poszukać podatności.

> [!TIP]
> Po przeprowadzeniu dynamic analysis z MobSF ustawienia proxy mogą być nieprawidłowe i nie będziesz w stanie ich naprawić z poziomu GUI. Możesz naprawić ustawienia proxy, wykonując:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

You can get the tool from [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Narzędzie to wykorzystuje **Hooks**, aby poinformować Cię **co dzieje się w aplikacji** podczas wykonywania **dynamic analysis**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

To **świetne narzędzie do przeprowadzania static analysis z GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Narzędzie to zostało zaprojektowane do wyszukiwania różnych **security related Android application vulnerabilities**, zarówno w **source code**, jak i w **packaged APKs**. Narzędzie jest również **capable of creating a "Proof-of-Concept" deployable APK** oraz generować **ADB commands**, aby wykorzystać niektóre z znalezionych podatności (Exposed activities, intents, tapjacking...). Podobnie jak w przypadku Drozer, nie ma potrzeby rootowania urządzenia testowego.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Wyświetla wszystkie wyodrębnione pliki dla szybkiego wglądu
- Automatycznie dekompiluje pliki APK do formatu Java i Smali
- Analizuje AndroidManifest.xml pod kątem typowych podatności i zachowań
- Wykonuje statyczną analizę kodu źródłowego pod kątem typowych podatności i zachowań
- Informacje o urządzeniu
- i więcej
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER to aplikacja wiersza poleceń, którą można używać w Windows, MacOS X i Linux, analizująca pliki _.apk_ w poszukiwaniu podatności. Robi to, rozpakowując APK i stosując serię reguł, aby wykryć te podatności.

Wszystkie reguły znajdują się w pliku `rules.json`, a każda firma lub tester mogą stworzyć własne reguły, aby analizować to, czego potrzebują.

Pobierz najnowsze binaria z [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn to **crossplatform** narzędzie, które pomaga deweloperom, bugbounty hunters i ethical hackers w przeprowadzaniu [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) na aplikacjach mobilnych.

Koncepcja polega na tym, że przeciągasz i upuszczasz plik aplikacji mobilnej (.apk or .ipa file) na aplikację StaCoAn, a ona wygeneruje dla Ciebie wizualny i przenośny raport. Możesz dostosować ustawienia i wordlists, aby uzyskać spersonalizowane doświadczenie.

Pobierz[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework to system analizy podatności dla Androida, który pomaga deweloperom lub hackers znaleźć potencjalne luki bezpieczeństwa w aplikacjach Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** to narzędzie, którego głównym celem jest wykrywanie i ostrzeganie użytkownika przed potencjalnymi złośliwymi zachowaniami powodowanymi przez aplikację Android.

Wykrywanie odbywa się poprzez **analizę statyczną** kodu bajtowego Dalvik aplikacji, reprezentowanego jako **Smali**, przy użyciu biblioteki [`androguard`](https://github.com/androguard/androguard).

Narzędzie szuka **typowych zachowań "złych" aplikacji** takich jak: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. To narzędzie łączące często używane narzędzia do reverse engineeringu i analizy aplikacji mobilnych, aby wspomóc testowanie aplikacji mobilnych pod kątem zagrożeń bezpieczeństwa OWASP dla mobilnych aplikacji. Jego celem jest ułatwienie tej pracy i uczynienie jej bardziej przyjazną dla deweloperów aplikacji mobilnych oraz specjalistów ds. bezpieczeństwa.

Potrafi:

- Wyodrębniać kod Java i Smali przy użyciu różnych narzędzi
- Analizować APK za pomocą: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Wydobywać prywatne informacje z APK przy użyciu regexpów.
- Analizować Manifest.
- Analizować znalezione domeny za pomocą: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) oraz [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuskować APK przez [apk-deguard.com]

### Koodous

Przydatne do wykrywania złośliwego oprogramowania: https://koodous.com/

## Obfuscating/Deobfuscating code

Zwróć uwagę, że w zależności od usługi i konfiguracji użytej do obfuskacji kodu, sekrety mogą, ale nie muszą być obfuskowane.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

Z [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. Potrafi optymalizować bytecode oraz wykrywać i usuwać nieużywane instrukcje. ProGuard jest wolnym oprogramowaniem i jest dystrybuowany na licencji GNU General Public License, wersja 2.

ProGuard jest dostarczany jako część Android SDK i uruchamiany podczas budowania aplikacji w trybie release.

### [DexGuard](https://www.guardsquare.com/dexguard)

Znajdź przewodnik krok po kroku, jak zdeobfuskować apk w [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(Z tego przewodnika) Ostatnio, gdy sprawdzaliśmy, tryb działania Dexguard był następujący:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard odwraca proces obfuskacji wykonywany przez narzędzia do obfuskacji Androida. Umożliwia to liczne analizy bezpieczeństwa, w tym przegląd kodu i identyfikację bibliotek.**

Możesz przesłać obfuskowane APK na ich platformę.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

To narzędzie LLM do znajdowania potencjalnych luk w bezpieczeństwie aplikacji Android oraz deobfuskacji kodu aplikacji Android. Korzysta z publicznego API Gemini od Google.

### [Simplify](https://github.com/CalebFenton/simplify)

Jest to **uniwersalny deobfuskator dla Androida.** Simplify **praktycznie wykonuje aplikację** aby zrozumieć jej zachowanie, a następnie **stara się zoptymalizować kod**, tak aby zachowywał się identycznie, ale był łatwiejszy do zrozumienia dla człowieka. Każdy rodzaj optymalizacji jest prosty i uniwersalny, więc nie ma znaczenia, jaki konkretny typ obfuskacji został użyty.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD dostarcza informacji o **tym, jak zbudowano APK**. Identyfikuje wiele **kompilatorów**, **packerów**, **obfuskatorów** i innych dziwnych rzeczy. To jest [_PEiD_] dla Androida.

### Manual

Przeczytaj ten tutorial, aby poznać kilka sztuczek dotyczących **odwracania niestandardowej obfuskacji** (manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b to wirtualna maszyna bezpieczeństwa Android oparta na ubuntu-mate, zawierająca zbiór najnowszych frameworków, tutoriali i laboratoriów od różnych entuzjastów bezpieczeństwa i badaczy, przeznaczona do reverse engineeringu i analizy złośliwego oprogramowania.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) To świetna lista zasobów
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Krótkie wprowadzenie do Android App RE
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)

## Yet to try

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
