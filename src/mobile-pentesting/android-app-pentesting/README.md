# Android Applications Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android Applications बेसिक्स

यह पृष्ठ पढ़ना अत्यंत अनुशंसित है ताकि आप Android सुरक्षा से संबंधित सबसे महत्वपूर्ण हिस्सों और किसी Android application में मौजूद सबसे खतरनाक घटकों के बारे में जान सकें:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

यह मुख्य टूल है जिसकी आपको एक android डिवाइस (emulated या physical) से कनेक्ट करने के लिए आवश्यकता होती है.\
**ADB** कंप्यूटर से **USB** या **Network** के माध्यम से डिवाइस को नियंत्रित करने की अनुमति देता है। यह यूटिलिटी फाइलों को दोनों दिशाओं में **कॉपी** करने, ऐप्स की **इंस्टॉलेशन** और **अनइंस्टॉलेशन**, शेल कमांड्स का **एक्जीक्यूशन**, डेटा का **बैकअप**, लॉग्स का **रीडिंग** करने जैसी सुविधाएँ प्रदान करता है।

adb का उपयोग कैसे करना है यह जानने के लिए निम्नलिखित सूची [**ADB Commands**](adb-commands.md) देखें।

## Smali

कभी-कभी एप्लिकेशन के कोड को मॉडिफाई करना रोचक होता है ताकि **छिपी हुई जानकारी** (शायद अच्छे से obfuscated पासवर्ड या flags) तक पहुँचा जा सके। ऐसे मामलों में apk को decompile करना, कोड बदलना और फिर से recompile करना उपयोगी हो सकता है.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). यह डायनामिक एनालिसिस के दौरान किए जाने वाले कई परीक्षणों के लिए एक वैकल्पिक तरीका हो सकता है। इसलिए, इस संभावना को हमेशा ध्यान में रखें।

## अन्य रोचक तरकीबें

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [Android IME / InputMethodService Abuse (Malicious Keyboards)](inputmethodservice-ime-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **APKs डाउनलोड करें**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- डिवाइस से APK निकालें:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- सभी splits और base apks को [APKEditor](https://github.com/REAndroid/APKEditor) के साथ मर्ज करें:
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Android Enterprise & Work Profile Attacks

{{#ref}}
android-enterprise-work-profile-bypass.md
{{#endref}}

## Case Studies & Vulnerabilities


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

{{#ref}}
abusing-android-media-pipelines-image-parsers.md
{{#endref}}

{{#ref}}
../../binary-exploitation/linux-kernel-exploitation/arm64-static-linear-map-kaslr-bypass.md
{{#endref}}

## Static Analysis

सबसे पहले, किसी APK का विश्लेषण करने के लिए आपको decompiler का उपयोग करके Java code देखना चाहिए।\
कृपया, [**यहाँ पढ़ें ताकि विभिन्न उपलब्ध decompilers के बारे में जानकारी मिल सके**](apk-decompilers.md).

### Looking for interesting Info

APK की **strings** देखकर आप **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** और अन्य किसी भी रुचिकर चीज़ की खोज कर सकते हैं... यहाँ तक कि code execution **backdoors** या authentication backdoors (ऐप के लिए hardcoded admin credentials) की भी तलाश करें।

**Firebase**

**firebase URLs** पर विशेष ध्यान दें और जांचें कि क्या यह गलत तरीके से configured है। [Firebase क्या है और इसे कैसे exploit किया जा सकता है, इसके बारे में अधिक जानकारी यहाँ है.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Basic understanding of the application - Manifest.xml, strings.xml

किसी application's _Manifest.xml_ और **_strings.xml_** फ़ाइलों की जांच संभावित सुरक्षा कमजोरियाँ उजागर कर सकती है। इन फ़ाइलों को decompilers के माध्यम से या APK का extension .zip करके और फिर unzip करके access किया जा सकता है।

**Manifest.xml** से पहचानी जा सकने वाली कमजोरियाँ:

- **Debuggable Applications**: यदि _Manifest.xml_ में एप्लिकेशन `debuggable="true"` के रूप में सेट है तो यह जोखिम पैदा करता है क्योंकि यह ऐसे कनेक्शंस की अनुमति देता है जो exploit की ओर ले जा सकते हैं। debuggable applications को कैसे खोजा और exploit किया जाए, इसके लिए संबंधित ट्यूटोरियल देखें।
- **Backup Settings**: संवेदनशील जानकारी से संबंधित एप्लिकेशन के लिए `android:allowBackup="false"` attribute को स्पष्ट रूप से सेट किया जाना चाहिए ताकि adb के माध्यम से unauthorized data backups रोके जा सकें, विशेषकर जब usb debugging सक्षम हो।
- **Network Security**: कस्टम network security configurations (`android:networkSecurityConfig="@xml/network_security_config"`) जो _res/xml/_ में होते हैं, certificate pins और HTTP traffic settings जैसी security जानकारी निर्दिष्ट कर सकते हैं। उदाहरण के लिए, कुछ domains के लिए HTTP traffic की अनुमति देना।
- **Exported Activities and Services**: manifest में exported activities और services की पहचान करना उन components को उजागर कर सकता है जिन्हें गलत तरीके से उपयोग किया जा सकता है। dynamic testing के दौरान आगे के विश्लेषण से यह पता चल सकता है कि इन components का exploit कैसे किया जा सकता है।
- **Content Providers and FileProviders**: सार्वजनिक content providers unauthorized access या data modification की अनुमति दे सकते हैं। FileProviders की configuration को भी सूक्ष्मता से जांचना चाहिए।
- **Broadcast Receivers and URL Schemes**: ये components exploit के लिए leveraged किए जा सकते हैं, खासकर इस बात पर ध्यान देते हुए कि URL schemes को इनपुट के लिए कैसे संभाला जाता है।
- **SDK Versions**: `minSdkVersion`, `targetSDKVersion`, और `maxSdkVersion` attributes समर्थित Android संस्करणों को दर्शाते हैं, जो यह बताता है कि पुराने, कमजोर Android संस्करणों का समर्थन न करना सुरक्षा के लिए कितना महत्वपूर्ण है।

**strings.xml** फ़ाइल से API keys, custom schemas और अन्य developer नोट्स जैसी संवेदनशील जानकारी मिल सकती है, इसलिए इन resources की सावधानीपूर्वक समीक्षा आवश्यक है।

### Tapjacking

**Tapjacking** एक हमला है जहाँ कोई **malicious** **application** लॉन्च होती है और **victim application** के ऊपर स्थित हो जाती है। एक बार जब यह victim app को आंशिक या पूरी तरह से ढक देती है, तो इसका UI इस तरह डिज़ाइन किया जाता है कि उपयोगकर्ता को धोखा देकर वह उसके साथ interact करने पर मजबूर कर दे, जबकि यह interaction को victim app तक पास कर देता है।\
प्रभावतः यह उपयोगकर्ता को अंधा कर देता है ताकि वह न जान पाए कि वह वास्तव में victim app पर कार्रवाई कर रहा है।

अधिक जानकारी के लिए देखें:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

यदि किसी **activity** का **`launchMode`** **`singleTask`** पर सेट है और कोई `taskAffinity` परिभाषित नहीं है तो यह Task Hijacking के लिए vulnerable होता है। इसका मतलब है कि एक **malicious application** को इंस्टॉल किया जा सकता है और यदि वह असली application से पहले लॉन्च की जाती है तो यह असली application का task **hijack** कर सकती है (जिससे user सोचकर malicious application का उपयोग कर रहा है कि वह असली application इस्तेमाल कर रहा है)।

अधिक जानकारी:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Insecure data storage

**Internal Storage**

Android में, internal storage में **store** की गई फाइलें सामान्यतः उन्हीं apps द्वारा access की जा सकती हैं जिन्होंने उन्हें बनाया है। यह सुरक्षा उपाय Android OS द्वारा लागू किया जाता है और अधिकांश applications की security जरूरतों के लिए सामान्यतः पर्याप्त होता है। हालाँकि, developers कभी-कभी `MODE_WORLD_READABLE` और `MODE_WORLD_WRITABLE` जैसे modes का उपयोग करते हैं ताकि फाइलें अलग-अलग applications के बीच **share** की जा सकें। ये modes इन फाइलों तक अन्य applications, जिनमें potentially malicious apps भी शामिल हैं, द्वारा भी access की अनुमति दे सकते हैं।

1. **Static Analysis:**
- `MODE_WORLD_READABLE` और `MODE_WORLD_WRITABLE` के उपयोग की सावधानीपूर्वक जांच सुनिश्चित करें। ये modes फाइलों को अनपेक्षित या unauthorized access के लिए उजागर कर सकते हैं।
2. **Dynamic Analysis:**
- एप्लिकेशन द्वारा बनाई गई फाइलों पर सेट permissions की जाँच करें। विशेष रूप से, चेक करें कि क्या कोई फाइलें worldwide readable या writable के रूप में सेट हैं। यह एक महत्वपूर्ण सुरक्षा जोखिम हो सकता है, क्योंकि इससे किसी भी इंस्टॉल किए गए application को, उसके origin या intent से परे, इन फाइलों को पढ़ने या संशोधित करने की अनुमति मिल सकती है।

**External Storage**

SD Cards जैसे external storage पर फ़ाइलों से निपटते समय कुछ सावधानियाँ आवश्यक हैं:

1. **Accessibility**:
- external storage पर फाइलें सामान्यतः globally readable और writable होती हैं। इसका मतलब है कि कोई भी application या user इन फाइलों तक पहुंच सकता है।
2. **Security Concerns**:
- इसी आसान पहुँच के कारण, संवेदनशील जानकारी को external storage पर स्टोर न करने की सलाह दी जाती है।
- External storage को हटाया जा सकता है या किसी भी application द्वारा access किया जा सकता है, जिससे यह कम सुरक्षित बन जाता है।
3. **Handling Data from External Storage**:
- external storage से प्राप्त डेटा पर हमेशा input validation करें। यह आवश्यक है क्योंकि ये डेटा untrusted स्रोत से आता है।
- external storage पर executables या class files को dynamic loading के लिए स्टोर करना बहुत हतोत्साहित किया जाता है।
- यदि आपका application external storage से executable files प्राप्त करता है, तो सुनिश्चित करें कि ये फाइलें signed और cryptographically verified हैं इससे पहले कि उन्हें dynamically load किया जाए। यह कदम आपके application की security integrity बनाए रखने के लिए आवश्यक है।

External storage को `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard` में access किया जा सकता है

> [!TIP]
> Android 4.4 (**API 17**) से शुरू करते हुए, SD card में एक directory structure है जो किसी app की पहुंच को केवल उसी app के लिए निर्धारित directory तक सीमित करता है। यह किसी malicious application को दूसरे app की फ़ाइलों को पढ़ने या लिखने से रोकता है।

**Sensitive data stored in clear-text**

- **Shared preferences**: Android प्रत्येक application को आसानी से xml फाइलें `/data/data/<packagename>/shared_prefs/` पाथ में सेव करने की अनुमति देता है और कभी-कभी उस फ़ोल्डर में clear-text में संवेदनशील जानकारी मिल सकती है।
- **Databases**: Android प्रत्येक application को sqlite databases `/data/data/<packagename>/databases/` पाथ में आसानी से सेव करने की अनुमति देता है और कभी-कभी उस फ़ोल्डर में clear-text में संवेदनशील जानकारी मिल सकती है।

### Broken TLS

**Accept All Certificates**

कई बार developers किसी कारणवश सभी certificates स्वीकार कर लेते हैं, यहाँ तक कि यदि उदाहरण के लिए hostname match नहीं करता — ऐसा अक्सर निम्न कोड वाली लाइनों के साथ होता है:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### खराब क्रिप्टोग्राफी

**खराब कुंजी प्रबंधन प्रक्रियाएँ**

कुछ developers संवेदनशील डेटा को local storage में सेव करते हैं और उसे कोड में hardcoded/अनुमानित key से encrypt कर देते हैं। ऐसा नहीं किया जाना चाहिए क्योंकि कुछ reversing से attackers confidential जानकारी extract कर सकते हैं।

**असुरक्षित और/या Deprecated एल्गोरिदम का उपयोग**

Developers को authorization checks, store या send data के लिये **deprecated algorithms** का उपयोग नहीं करना चाहिए। इन एल्गोरिदम में कुछ हैं: RC4, MD4, MD5, SHA1... अगर पासवर्ड स्टोर करने के लिए **hashes** का उपयोग किया जा रहा है तो **brute-force resistant** hashes salt के साथ उपयोग किए जाने चाहिए।

### अन्य जाँचें

- यह recommend किया जाता है कि **APK को obfuscate** करें ताकि attackers के लिए reverse engineer करना कठिन हो।
- अगर ऐप sensitive है (जैसे bank apps), तो इसे अपने **खुद के checks करना चाहिए यह देखने के लिए कि मोबाइल rooted है या नहीं** और उसके अनुसार कार्रवाई करनी चाहिए।
- अगर ऐप sensitive है (जैसे bank apps), तो इसे जांचना चाहिए कि **emulator** उपयोग किया जा रहा है या नहीं।
- अगर ऐप sensitive है (जैसे bank apps), तो इसे **execute करने से पहले अपनी integrity चेक करनी चाहिए** ताकि यह पता चले कि इसे modify तो नहीं किया गया।
- Use [**APKiD**](https://github.com/rednaga/APKiD) यह चेक करने के लिए कि कौन सा compiler/packer/obfuscator APK build करने के लिए उपयोग हुआ था।

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

The tool [**mariana-trench**](https://github.com/facebook/mariana-trench) सक्षम है vulnerabilities ढूँढ़ने के लिए application के **code** को **scan** करके। इस tool में एक series है known **sources** (जो tool को बताती हैं उन **जगहों** को जहाँ **input** user द्वारा control होता है), **sinks** (जो tool को बताती हैं **खतरनाक** जगहें जहाँ malicious user input नुकसान पहुंचा सकता है) और **rules**। ये rules sources-sinks के **combination** को indicar करते हैं जो vulnerability इंगित करता है।

इन जानकारियों के साथ, **mariana-trench code की समीक्षा करेगा और संभावित vulnerabilities पाएगा**।

### Secrets leaked

An application may contain secrets (API keys, passwords, hidden urls, subdomains...) inside of it that you might be able to discover. You could us a tool such as [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)
- In-memory native code execution via JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> सबसे पहले, आपको एक ऐसा environment चाहिए जहाँ आप application और बाकी environment (Burp CA cert, Drozer और Frida मुख्य रूप से) install कर सकें। इसलिए, एक rooted device (emulated या real) अत्यधिक recommend किया जाता है।

### Online Dynamic analysis

आप एक **free account** बना सकते हैं: [https://appetize.io/](https://appetize.io). यह platform आपको APKs **upload** और **execute** करने की अनुमति देती है, इसलिए यह देखने के लिए उपयोगी है कि एक apk कैसे behave कर रहा है।

आप web में अपने application के logs भी **देख** सकते हैं और **adb** के माध्यम से connect कर सकते हैं।

![](<../../images/image (831).png>)

ADB connection की वजह से आप emulators के अंदर **Drozer** और **Frida** का उपयोग कर सकते हैं।

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (आप **x86** और **arm** devices बना सकते हैं, और according to [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** versions **ARM libraries** को support करते हैं बिना slow arm emulator की जरूरत के).
- इसे सेटअप करना सीखें इस पेज पर:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, आपको account बनाना होगा। _It's recommend to **download** the version **WITH**_ _**VirtualBox** to avoid potential errors._)
- [**Nox**](https://es.bignox.com) (Free, पर यह Frida या Drozer को support नहीं करता).

> [!TIP]
> जब किसी भी platform पर नया emulator बना रहे हों, ध्यान रखें कि स्क्रीन जितनी बड़ी होगी, emulator उतना ही slow चलेगा। इसलिए संभव हो तो छोटे स्क्रीन चुनें।

Google services (जैसे AppStore) को Genymotion में install करने के लिए आपको निम्नलिखित image में लाल निशान वाले बटन पर क्लिक करना होगा:

![](<../../images/image (277).png>)

इसके अलावा, ध्यान दें कि **Genymotion में Android VM की configuration** में आप **Bridge Network mode** चुन सकते हैं (यह उपयोगी होगा यदि आप Android VM से किसी दूसरे VM पर स्थित tools से connect कर रहे हों)।

#### Use a physical device

आपको **debugging** विकल्प activate करने होंगे और अच्छा होगा अगर आप इसे **root** कर सकें:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> एक बार जब आपने application install कर ली है, तो सबसे पहले आपको इसे try करना चाहिए और investigate करना चाहिए कि यह क्या करता है, यह कैसे काम करता है और इससे comfortable हो जाना चाहिए.\
> मैं सुझाव दूँगा कि इस initial dynamic analysis को MobSF dynamic analysis + pidcat का उपयोग करके करें, ताकि हम यह सीख सकें कि application कैसे काम करता है जबकि MobSF बहुत सारी interesting data capture करता है जिन्हें आप बाद में review कर सकते हैं।

Magisk/Zygisk quick notes (recommended on Pixel devices)
- Magisk app से boot.img patch करें और fastboot के जरिए flash करें ताकि systemless root मिले
- Zygisk + DenyList enable करें root hiding के लिए; जब अधिक मजबूत hiding की जरूरत हो तो LSPosed/Shamiko पर विचार करें
- OTA updates से recover करने के लिए original boot.img रखें; हर OTA के बाद re-patch करें
- स्क्रीन mirroring के लिए, host पर scrcpy का उपयोग करें

### Unintended Data Leakage

**Logging**

Developers को सावधान रहना चाहिए कि वे **debugging information** को public रूप से expose न करें, क्योंकि इससे संवेदनशील डेटा leak हो सकता है। बेहतर है कि application logs monitor करने के लिए tools जैसे [**pidcat**](https://github.com/JakeWharton/pidcat) और `adb logcat` का उपयोग करें ताकि sensitive information की पहचान की जा सके और उसकी सुरक्षा की जा सके। **Pidcat** उसकी ease-of-use और readability के कारण पसंदीदा है।

> [!WARNING]
> नोट करें कि **Android 4.0 के बाद के versions** से, **applications केवल अपने ही logs तक access कर सकती हैं**। इसलिए applications अन्य apps के logs को access नहीं कर सकतीं।\
> फिर भी, sensitive information को log करने से बचना चाहिए।

**Copy/Paste Buffer Caching**

Android का **clipboard-based** framework apps में copy-paste functionality सक्षम करता है, लेकिन यह जोखिम भी पैदा करता है क्योंकि **दूसरे applications** clipboard तक **access** कर सकते हैं, जिससे संवेदनशील डेटा expose हो सकता है। संवेदनशील sections (जैसे credit card details) के लिए copy/paste functions disable करना आवश्यक है ताकि data leak रोका जा सके।

**Crash Logs**

यदि कोई application crash होती है और logs save कर लेती है, तो ये logs attackers के लिए सहायक हो सकती हैं, खासकर जब application को reverse-engineer करना मुश्किल हो। इस जोखिम को कम करने के लिए, crashes पर logging से बचें, और अगर logs network पर भेजने ज़रूरी हों तो उन्हें SSL चैनल के माध्यम से भेजें।

As pentester, **इन logs को देखने की कोशिश करें**।

**Analytics Data Sent To 3rd Parties**

Applications अक्सर Google Adsense जैसे services integrate करती हैं, जो developers की गलत implementation के कारण अनजाने में संवेदनशील डेटा leak कर सकती हैं। संभावित data leaks की पहचान करने के लिए, यह सलाह दी जाती है कि आप application's traffic intercept करें और देखें कि क्या कोई sensitive information third-party services को भेजी जा रही है।

### SQLite DBs

अधिकतर applications internal SQLite databases का उपयोग जानकारी save करने के लिए करते हैं। pentest के दौरान उन **databases**, उनके **table** और **column** के नामों और saved **data** को ध्यान से देखें क्योंकि आप वहां से संवेदनशील जानकारी पा सकते हैं (जो vulnerability होगी).\
Databases को आम तौर पर `/data/data/the.package.name/databases` में पाया जाता है जैसे `/data/data/com.mwr.example.sieve/databases`

अगर database confidential जानकारी save कर रहा है और यह **encrypted** है लेकिन आप application के अंदर password ढूँढ़ लेते हैं तो यह अभी भी एक vulnerability है।

.tables का उपयोग करके tables enumerate करें और `.schema <table_name>` का उपयोग करके table के columns enumerate करें।

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** आपको **एक Android app की भूमिका अपनाने** और अन्य apps के साथ interact करने की अनुमति देता है। यह वही कर सकता है जो कोई installed application कर सकता है, जैसे कि Android’s Inter-Process Communication (IPC) mechanism का उपयोग करना और underlying operating system के साथ interact करना। .\
Drozer एक उपयोगी टूल है exported activities, exported services और Content Providers को **exploit** करने के लिए जैसा कि आप निम्न sections में सीखेंगे।

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
याद रखें कि किसी activity का कोड **`onCreate`** method में शुरू होता है।

**Authorisation bypass**

जब एक Activity exported होती है तो आप उसकी screen को एक external app से invoke कर सकते हैं। इसलिए, अगर किसी activity में **sensitve information** है और वह **exported** है तो आप authentication mechanisms को **bypass** करके उसे access कर सकते हैं।

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

आप adb से भी एक exported activity start कर सकते हैं:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF किसी activity में `android:launchMode` के रूप में _**singleTask/singleInstance**_ के उपयोग को malicious के रूप में पहचानता है, लेकिन [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750) के कारण, जाहिरा तौर पर यह केवल पुराने वर्शन (API versions < 21) पर ही खतरनाक है।

> [!TIP]
> ध्यान दें कि authorisation bypass हमेशा vulnerability नहीं होती — यह इस बात पर निर्भर करेगा कि bypass कैसे काम करता है और कौनसी जानकारी exposed होती है।

**Sensitive information leakage**

**Activities भी results return कर सकती हैं**. यदि आप कोई exported और unprotected activity ढूंढ़ लेते हैं जो **`setResult`** method को कॉल करके संवेदनशील जानकारी वापस कर रही है, तो यह sensitive information leakage है।

#### Tapjacking

यदि tapjacking रोका नहीं गया है, तो आप exported activity का दुरुपयोग करके **user को unexpected actions करवाने** हेतु मजबूर कर सकते हैं। For more info about [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers मूल रूप से **share data** के लिए उपयोग किए जाते हैं। यदि किसी app के पास content providers उपलब्ध हैं, तो आप उनसे **extract sensitive** data कर सकते हैं। यह भी आवश्यक है कि आप संभावित **SQL injections** और **Path Traversals** की जाँच करें क्योंकि वे vulnerable हो सकते हैं।

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
याद रखें कि Service के actions `onStartCommand` method में शुरू होते हैं।

Service मूल रूप से ऐसा component है जो **data receive कर सकता है**, उसे **process** करता है और (या नहीं) एक response **return** करता है। इसलिए, यदि कोई application कुछ services export कर रही है, तो आपको उस **code** की जाँच करनी चाहिए ताकि यह समझा जा सके कि वह क्या कर रहा है और उसे confidential info निकालने, authentication measures को bypass करने आदि के लिए **dynamically** टेस्ट किया जाना चाहिए...\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
याद रखें कि Broadcast Receiver के actions `onReceive` method में शुरू होते हैं।

एक broadcast receiver किसी प्रकार के message के लिए इंतज़ार करेगा। यह निर्भर करता है कि receiver message को कैसे handle करता है — यह vulnerable हो सकता है।\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

आप deep links मैन्युअल रूप से ढूंढ सकते हैं, MobSF जैसे tools या scripts जैसे [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py) का उपयोग करके।\
आप किसी declared **scheme** को **adb** या किसी **browser** से **open** कर सकते हैं:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_ध्यान दें कि आप **पैकेज नाम छोड़ सकते हैं** और मोबाइल स्वचालित रूप से उस app को कॉल करेगा जो उस लिंक को खोलना चाहिए._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Code executed**

ऐप में निष्पादित होने वाले **code that will be executed in the App** को खोजने के लिए, deeplink द्वारा कॉल की गई activity में जाएँ और फ़ंक्शन **`onNewIntent`** खोजें।

![](<../../images/image (436) (1) (1) (1).png>)

**Sensitive info**

हर बार जब आप कोई deep link पाते हैं तो जाँच करें कि i**t's not receiving sensitive data (like passwords) via URL parameters**, क्योंकि कोई भी अन्य एप्लिकेशन उस deep link का **impersonate** करके वह डेटा चुरा सकता है!

**Parameters in path**

आप **must check also if any deep link is using a parameter inside the path** of the URL जैसे: `https://api.example.com/v1/users/{username}` , ऐसे मामले में आप path traversal मजबूर कर सकते हैं, जैसे पहुँचाकर: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
ध्यान दें कि यदि आप एप्लिकेशन के अंदर सही endpoints ढूँढ लेते हैं तो आप **Open Redirect** (अगर path का कोई हिस्सा domain name के रूप में उपयोग हो रहा हो), **account takeover** (अगर आप CSRF token के बिना users के विवरण बदल सकते हैं और vuln endpoint ने सही method उपयोग किया हो) और किसी अन्य vuln का कारण बन सकते हैं। More [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Transport Layer Inspection and Verification Failures

- **Certificates are not always inspected properly** by Android applications. अक्सर ये applications warnings की उपेक्षा करते हैं और self-signed certificates को स्वीकार कर लेते हैं या कुछ मामलों में HTTP connections पर वापस चले जाते हैं।
- **Negotiations during the SSL/TLS handshake are sometimes weak**, और insecure cipher suites का उपयोग होता है। यह कमजोरी connection को man-in-the-middle (MITM) attacks के प्रति संवेदनशील बनाती है, जिससे attackers data को decrypt कर सकते हैं।
- **Leakage of private information** एक जोखिम है जब applications secure channels का उपयोग करके authenticate करती हैं पर बाद में अन्य transactions के लिए non-secure channels पर communicate करती हैं। यह तरीका sensitive data जैसे session cookies या user details को malicious entities द्वारा intercept होने से सुरक्षित नहीं रखता।

#### Certificate Verification

हम **certificate verification** पर फोकस करेंगे। सुरक्षा बढ़ाने के लिए server के certificate की integrity को verify करना आवश्यक है। यह महत्वपूर्ण है क्योंकि insecure TLS configurations और unencrypted channels पर sensitive data का ट्रांसमिशन गंभीर जोखिम पैदा कर सकता है। server certificates verify करने और vulnerabilities को ठीक करने के विस्तृत कदमों के लिए, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) व्यापक मार्गदर्शन प्रदान करता है।

#### SSL Pinning

SSL Pinning एक security measure है जहाँ application server के certificate को application में संग्रहीत ज्ञात कॉपी के साथ verify करती है। यह तरीका MITM attacks को रोकने के लिए आवश्यक है। जो applications sensitive information संभालती हैं उनके लिए SSL Pinning को लागू करना strongly recommended है।

#### Traffic Inspection

HTTP traffic को inspect करने के लिए proxy tool का certificate install करना आवश्यक है (उदा., Burp)। इस certificate को install किए बिना encrypted traffic proxy के माध्यम से दिखाई नहीं दे सकती। custom CA certificate install करने के गाइड के लिए, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine)।

API Level 24 और उससे ऊपर target करने वाले applications को proxy के CA certificate को accept करने के लिए Network Security Config में बदलाव करने की आवश्यकता होती है। यह कदम encrypted traffic inspect करने के लिए critical है। Network Security Config में बदलाव करने के निर्देशों के लिए, [**refer to this tutorial**](make-apk-accept-ca-certificate.md)।

यदि **Flutter** उपयोग किया जा रहा है तो आपको [**this page**](flutter.md) में दिए निर्देशों का पालन करना होगा। इसका कारण यह है कि केवल certificate को store में जोड़ना पर्याप्त नहीं होगा क्योंकि Flutter की अपनी valid CAs की सूची होती है।

#### Static detection of SSL/TLS pinning

runtime bypasses आजमाने से पहले, जल्दी से मैप करें कि APK में pinning कहाँ लागू किया गया है। static discovery आपको hooks/patches की योजना बनाने और सही code paths पर ध्यान केंद्रित करने में मदद करती है।

Tool: SSLPinDetect
- Open-source static-analysis utility जो APK को Smali में decompile (apktool के माध्यम से) करता है और SSL/TLS pinning implementations के curated regex patterns के लिए scan करता है।
- प्रत्येक match के लिए exact file path, line number, और code snippet रिपोर्ट करता है।
- आम frameworks और custom code paths को cover करता है: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, और Network Security Config XML pins।

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
उपयोग
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
उदाहरण पैटर्न नियम (JSON)
proprietary/custom pinning styles का पता लगाने के लिए signatures का उपयोग या विस्तार करें। आप अपना खुद का JSON लोड कर सकते हैं और बड़े पैमाने पर scan कर सकते हैं।
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes and tips
- बड़े apps पर Fast scanning के लिए multi-threading और memory-mapped I/O का उपयोग करें; pre-compiled regex overhead/false positives कम करता है।
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Typical detection targets to triage next:
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Declarative pins in res/xml network security config and manifest references
- मैच हुई locations का उपयोग Frida hooks, static patches, या config reviews की योजना बनाने के लिए करें, dynamic testing से पहले।



#### SSL Pinning बायपास करना

जब SSL Pinning लागू होता है, तो HTTPS ट्रैफ़िक की जाँच करने के लिए इसे बायपास करना आवश्यक हो जाता है। इस उद्देश्य के लिए विभिन्न तरीके उपलब्ध हैं:

- Automatically **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). इस विकल्प का सबसे बड़ा फायदा यह है कि आपको SSL Pinning बायपास करने के लिए root की आवश्यकता नहीं होगी, लेकिन आपको application को डिलीट करके नया install करना होगा, और यह हमेशा काम नहीं करेगा।
- आप इस सुरक्षा को bypass करने के लिए **Frida** (नीचे चर्चा किया गया) का उपयोग कर सकते हैं। यहाँ Burp+Frida+Genymotion का उपयोग करने के लिए एक गाइड है: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- आप [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"` का उपयोग करके SSL Pinning को स्वचालित रूप से बायपास करने की कोशिश भी कर सकते हैं।
- आप **MobSF dynamic analysis** (नीचे बताया गया) का उपयोग करके भी SSL Pinning को स्वचालित रूप से बायपास करने की कोशिश कर सकते हैं।
- यदि आपको अभी भी लगता है कि कुछ ट्रैफ़िक आप कैप्चर नहीं कर रहे हैं, तो आप ट्रैफ़िक को burp पर फॉरवर्ड करने के लिए **iptables** का उपयोग कर सकते हैं। इस ब्लॉग को पढ़ें: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Looking for Common Web Vulnerabilities

Application के अंदर सामान्य Web vulnerabilities की भी तलाश करना महत्वपूर्ण है। इन vulnerabilities की पहचान और निवारण के बारे में विस्तृत जानकारी इस सारांश के दायरे से बाहर है, लेकिन यह अन्यत्र व्यापक रूप से कवर किया गया है।

### Frida

[Frida](https://www.frida.re) developers, reverse-engineers, और security researchers के लिए एक dynamic instrumentation toolkit है।\
**आप running application तक पहुँच सकते हैं और run time पर methods को hook करके व्यवहार बदल सकते हैं, values बदल सकते हैं, values एक्सट्रेक्ट कर सकते हैं, अलग कोड चला सकते हैं...**\
अगर आप Android applications को pentest करना चाहते हैं तो आपको Frida का उपयोग करना आना चाहिए।

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Frida के लिए कुछ "GUI" actions: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection Frida के उपयोग को automate करने के लिए बढ़िया है: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- कुछ Awesome Frida scripts यहाँ मिलेंगी: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- anti-debugging / anti-frida mechanisms को बायपास करने की कोशिश करें, Frida को उस तरह लोड करके जैसा कि यहाँ दिखाया गया है: [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **मेमोरी डंप - Fridump**

जाँच करें कि क्या application memory में ऐसे sensitive information स्टोर कर रहा है जो उसे नहीं रखना चाहिए, जैसे passwords या mnemonics।

Using [**Fridump3**](https://github.com/rootbsd/fridump3) आप app की memory को dump कर सकते हैं:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
यह ./dump फ़ोल्डर में memory को dump कर देगा, और वहाँ आप कुछ इस तरह grep कर सकते हैं:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Keystore में संवेदनशील डेटा**

Android में Keystore संवेदनशील डेटा स्टोर करने के लिए सबसे अच्छा स्थान है, हालांकि पर्याप्त privileges होने पर इसे **एक्सेस करना संभव है**। चूंकि applications यहाँ अक्सर **sensitive data in clear text** स्टोर करते हैं, pentests को इसे root user के रूप में जांचना चाहिए, क्योंकि किसी के पास डिवाइस की physical access होने पर वह यह data चुरा सकता है।

यदि किसी app ने keystore में data स्टोर किया है, तब भी वह data encrypted होना चाहिए।

keystore के अंदर के data तक पहुँचने के लिए आप यह Frida script उपयोग कर सकते हैं: https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

निम्नलिखित Frida स्क्रिप्ट का उपयोग करके यह संभव हो सकता है कि Android applications द्वारा कुछ संवेदनशील क्षेत्रों की सुरक्षा के लिए लागू किए गए **bypass fingerprint authentication** को बायपास किया जा सके:
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **पृष्ठभूमि छवियाँ**

जब आप किसी ऐप को बैकग्राउंड में रखते हैं, Android उस ऐप का एक **snapshot** स्टोर करता है ताकि जब इसे फोरग्राउंड में वापस लाया जाए तो वह ऐप से पहले उस image को लोड करना शुरू कर दे और ऐसा लगे कि ऐप तेजी से लोड हुआ।

हालाँकि, यदि यह **snapshot** में **संवेदनशील जानकारी** होती है, तो snapshot तक पहुँच रखने वाला कोई व्यक्ति **उस जानकारी को चुरा सकता है** (नोट: इसे एक्सेस करने के लिए root की आवश्यकता होती है)।

ये snapshots आम तौर पर निम्न स्थान पर स्टोर होते हैं: **`/data/system_ce/0/snapshots`**

Android एक तरीका प्रदान करता है: **prevent the screenshot capture by setting the FLAG_SECURE** layout parameter. इस flag का उपयोग करने पर, window की सामग्री को secure माना जाता है, जिससे यह screenshots में दिखाई नहीं देगी और non-secure displays पर देखी नहीं जा सकेगी।
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

This tool could help you managing different tools during the dynamic analysis: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

डेवलपर्स अक्सर activities, services, और broadcast receivers जैसे प्रॉक्सी घटक बनाते हैं जो इन Intents को हैंडल करते हैं और उन्हें `startActivity(...)` या `sendBroadcast(...)` जैसी विधियों को पास करते हैं, जो जोखिम भरा हो सकता है।

खतरा इस बात में है कि attackers इन Intents को मिसडायरेक्ट करके non-exported app components को ट्रिगर कर सकते हैं या sensitive content providers तक पहुँच बना सकते हैं। एक उल्लेखनीय उदाहरण `WebView` component है जो URLs को `Intent` objects में `Intent.parseUri(...)` के माध्यम से बदलता है और फिर उन्हें execute कर सकता है, जिससे संभावित रूप से malicious Intent injections हो सकते हैं।

### महत्वपूर्ण निष्कर्ष

- **Intent Injection** web के Open Redirect issue के समान है।
- Exploits में `Intent` objects को extras के रूप में पास करना शामिल है, जिन्हें unsafe operations execute करने के लिए redirect किया जा सकता है।
- यह attackers को non-exported components और content providers तक पहुँच देने का रास्ता बना सकता है।
- `WebView` का URL से `Intent` conversion अनचाहे actions को सक्षम कर सकता है।

### Android Client Side Injections and others

शायद आप इस तरह की vulnerabilities के बारे में वेब से जानते होंगे। Android एप्लिकेशन में इन vulnerabilities के साथ विशेष सावधानी बरतनी चाहिए:

- **SQL Injection:** जब dynamic queries या Content-Providers के साथ काम कर रहे हों तो सुनिश्चित करें कि आप parameterized queries का उपयोग कर रहे हैं।
- **JavaScript Injection (XSS):** Verify that JavaScript and Plugin support is disabled for any WebViews (disabled by default). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews के लिए file system access को disabled रखना चाहिए (enabled by default) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: कई मामलों में जब Android एप्लिकेशन session खत्म करता है तो cookie revoke नहीं की जाती या उसे डिस्क पर भी सेव कर दिया जा सकता है
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Static analysis**

![](<../../images/image (866).png>)

**Vulnerability assessment of the application** using a nice web-based frontend. You can also perform dynamic analysis (but you need to prepare the environment).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Assisted Dynamic analysis with MobSF

**MobSF** डायनामिक एनालिसिस में भी बहुत मददगार हो सकता है, खासकर **Android** के लिए, लेकिन इस केस में आपको अपने host पर MobSF और **genymotion** इंस्टॉल करना होगा (एक VM या Docker काम नहीं करेगा)। _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
The **MobSF dynamic analyser** कर सकता है:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). यह सब ऑटोमैटिकली किया जाता है सिवाय screenshots के — screenshots के लिए आपको जब screenshot लेना हो तब बटन दबाना होगा या "**Exported Activity Tester**" दबाकर सभी exported activities के screenshots प्राप्त करने होंगे।
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: यह सभी loaded classes को प्रिंट करेगा
- **Capture Strings**: यह application उपयोग करते समय सभी captured strings प्रिंट करेगा (बहुत noisy)
- **Capture String Comparisons**: बहुत उपयोगी हो सकता है। यह **दोनों strings जिन्हें compare किया जा रहा है** और परिणाम True या False दिखायेगा।
- **Enumerate Class Methods**: क्लास नाम डालें (जैसे "java.io.File") और यह क्लास के सभी methods प्रिंट कर देगा।
- **Search Class Pattern**: pattern से classes खोजें
- **Trace Class Methods**: एक **पूरे class** को **Trace** करें (किसी class के सभी methods के inputs और outputs देखे)। ध्यान रहे कि default में MobSF कई दिलचस्प Android API methods को trace करता है।

एक बार जब आप वह auxiliary module चुन लेते हैं जिसे आप उपयोग करना चाहते हैं, तो आपको "**Start Intrumentation**" दबाना होगा और आप सभी outputs "**Frida Live Logs**" में देखेंगे।

**Shell**

Mobsf डाइनामिक analysis पेज के नीचे कुछ **adb** commands, **MobSF commands**, और सामान्य **shell** **commands** के साथ एक shell भी देता है। कुछ दिलचस्प commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP टूल्स**

जब HTTP ट्रैफिक कैप्चर होता है तो आप कैप्चर किए गए ट्रैफिक का एक बेकार व्यू "**HTTP(S) Traffic**" बॉटम में देख सकते हैं या "**Start HTTPTools**" हरे बटन में एक बेहतर व्यू। दूसरे विकल्प से, आप **captured requests** को **proxies** जैसे Burp या Owasp ZAP में **send** कर सकते हैं.\
ऐसा करने के लिए, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> press "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

एक बार जब आप MobSF के साथ dynamic analysis पूरा कर लेते हैं तो आप "**Start Web API Fuzzer**" दबाकर **fuzz http requests** कर सकते हैं और vulnerabilities की तलाश कर सकते हैं।

> [!TIP]
> MobSF के साथ dynamic analysis करने के बाद proxy settings misconfigured हो सकती हैं और आप उन्हें GUI से ठीक नहीं कर पाएँगे। आप proxy settings को इस तरह ठीक कर सकते हैं:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Inspeckage के साथ Assisted Dynamic Analysis

आप टूल [**Inspeckage**](https://github.com/ac-pm/Inspeckage) से प्राप्त कर सकते हैं।\
यह टूल कुछ **Hooks** का उपयोग करेगा ताकि जब आप **dynamic analysis** कर रहे हों तो यह आपको बताए कि **application में क्या हो रहा है**।

### [Yaazhini](https://www.vegabird.com/yaazhini/)

यह GUI के साथ **static analysis** करने के लिए एक शानदार टूल है

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

यह टूल कई security related Android application vulnerabilities ढूँढने के लिए बनाया गया है, चाहे वे **source code** में हों या packaged **APKs** में। टूल "Proof-of-Concept" deployable **APK** और **ADB commands** बनाने में भी सक्षम है, ताकि खोजी गई कुछ **vulnerabilities** (Exposed activities, intents, tapjacking...) का exploit किया जा सके। Drozer की तरह, टेस्ट डिवाइस को root करने की आवश्यकता नहीं है।
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- संदर्भ के लिए सभी निकाले गए फ़ाइलों को प्रदर्शित करता है
- APK फ़ाइलों को स्वचालित रूप से Java और Smali फॉर्मेट में decompile करता है
- AndroidManifest.xml का विश्लेषण सामान्य कमजोरियों और व्यवहार के लिए करता है
- Static source code analysis — सामान्य कमजोरियों और व्यवहार के लिए
- डिवाइस जानकारी
- और भी
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER एक command-line application है जिसे Windows, MacOS X और Linux पर इस्तेमाल किया जा सकता है, जो _.apk_ फाइलों का विश्लेषण करके vulnerabilities की तलाश करता है। यह APKs को decompress करके और इन vulnerabilities का पता लगाने के लिए नियमों की एक श्रृंखला लागू करके यह कार्य करता है।

सभी नियम `rules.json` फ़ाइल में केंद्रित हैं, और प्रत्येक company या tester अपनी आवश्यकताओं के अनुसार विश्लेषण के लिए अपने खुद के नियम बना सकते हैं।

नवीनतम binaries डाउनलोड करने के लिए [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn एक **crossplatform** टूल है जो developers, bugbounty hunters और ethical hackers को मोबाइल एप्लिकेशन पर [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) करने में मदद करता है।

विचार यह है कि आप अपना मोबाइल एप्लिकेशन फ़ाइल (एक .apk या .ipa फ़ाइल) को StaCoAn एप्लिकेशन पर drag and drop करें और यह आपके लिए एक visual और portable रिपोर्ट जनरेट कर देगा। आप settings और wordlists को tweak कर सकते हैं ताकि आपको एक customized अनुभव मिल सके।

डाउनलोड[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework एक Android कमजोरियों का विश्लेषण करने वाली प्रणाली है जो डेवलपर्स या hackers को Android एप्लिकेशन में संभावित सुरक्षा कमजोरियों को खोजने में मदद करती है.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** एक टूल है जिसका मुख्य उद्देश्य किसी Android application द्वारा विकसित संभावित दुर्भावनापूर्ण व्यवहारों का पता लगाना और उपयोगकर्ता को चेतावनी देना है।

यह पता लगाना application's Dalvik bytecode के **static analysis** के माध्यम से किया जाता है, जो **Smali** के रूप में प्रस्तुत होता है, और इसमें [`androguard`](https://github.com/androguard/androguard) लाइब्रेरी का उपयोग किया जाता है।

यह टूल उन **"bad" applications के सामान्य व्यवहार** की तलाश करता है जैसे: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** एक **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework है। यह एक ऐसा टूल है जो सामान्यत: उपयोग किए जाने वाले mobile application reverse engineering और analysis tools को एक साथ लाता है, ताकि OWASP mobile security threats के खिलाफ mobile applications की testing में मदद मिल सके। इसका उद्देश्य mobile application developers और security professionals के लिए यह काम आसान और अधिक user-friendly बनाना है।

यह सक्षम है:

- अलग-अलग tools का उपयोग करके Java और Smali code को Extract करने में
- APKs को analyze करने में: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- regexps का उपयोग करके APK से private information को Extract करने में
- Manifest का Analyze करने में
- पाए गए domains को analyze करने में: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) और [whatweb](https://github.com/urbanadventurer/WhatWeb)
- APK को deobfuscate करने में via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

malware detect करने के लिए उपयोगी: [https://koodous.com/](https://koodous.com)

## Obfuscating/Deobfuscating code

ध्यान दें कि किस सेवा और configuration का उपयोग करके आप code को obfuscate करते हैं, इसके आधार पर Secrets obfuscated हों भी सकते हैं और नहीं भी।

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** एक open source command-line tool है जो Java code को shrink, optimize और obfuscate करता है। यह bytecode को optimize करने के साथ-साथ unused instructions को detect और remove करने में सक्षम है। ProGuard free software है और GNU General Public License, version 2 के तहत distribute किया जाता है।

ProGuard Android SDK के हिस्से के रूप में distribute किया जाता है और application को release mode में build करते समय चलता है।

### [DexGuard](https://www.guardsquare.com/dexguard)

APK को deobfuscate करने के लिए step-by-step गाइड देखें: [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(उस गाइड से) पिछली बार जब हमने जाँचा था, तो Dexguard के mode of operation थे:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard उन Android obfuscation tools द्वारा किए गए obfuscation की प्रक्रिया को reverse करता है। यह कई security analyses को सक्षम बनाता है, जिनमें code inspection और libraries की prediction शामिल है।**

आप एक obfuscated APK को उनकी platform पर upload कर सकते हैं।

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

यह एक LLM tool है जो android apps में किसी भी संभावित security vulnerabilities को ढूंढने और android app code को deobfuscate करने के लिए है। Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

यह एक **generic android deobfuscator** है। Simplify **virtually executes an app** ताकि उसके व्यवहार को समझा जा सके और फिर **कोड को optimize करने** की कोशिश करता है ताकि वह व्यवहारिक रूप से समान रहे पर इंसान के लिए समझने में आसान हो। हर optimization type simple और generic है, इसलिए किसी विशेष प्रकार की obfuscation का होना मायने नहीं रखता।

### [APKiD](https://github.com/rednaga/APKiD)

APKiD आपको यह जानकारी देता है कि **एक APK कैसे बनाया गया था**। यह कई **compilers**, **packers**, **obfuscators**, और अन्य अजीब चीज़ों की पहचान करता है। यह Android के लिए [_PEiD_](https://www.aldeid.com/wiki/PEiD) है।

### Manual

[इस tutorial को पढ़ें ताकि आप सीख सकें कि custom obfuscation को कैसे reverse किया जाए](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b एक Android security virtual machine है जो ubuntu-mate पर आधारित है और इसमें latest framework, tutorials और अलग-अलग security geeks और researchers के labs का संग्रह शामिल है, जो reverse engineering और malware analysis के लिए उपयोगी हैं।

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) यह resources की एक शानदार सूची है
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
