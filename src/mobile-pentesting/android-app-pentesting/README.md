# Android Applications Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android Applications की मूल बातें

यह पृष्ठ पढ़ना अत्यधिक अनुशंसित है ताकि आप **Android सुरक्षा से संबंधित सबसे महत्वपूर्ण हिस्से और किसी Android एप्लिकेशन में सबसे खतरनाक घटक** के बारे में जान सकें:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

यह मुख्य उपकरण है जिसकी आपको किसी android डिवाइस (emulated या physical) से कनेक्ट करने के लिए आवश्यकता होती है.\
**ADB** आपको कंप्यूटर से **USB** या **Network** के माध्यम से डिवाइस को नियंत्रित करने की अनुमति देता है। यह उपयोगिता दोनों दिशाओं में फ़ाइलों की **कॉपी** करने, ऐप्स की **इंस्टॉलेशन** और **अनइंस्टॉलेशन**, shell commands का **निष्पादन**, डेटा का **बैकअप** लेने, लॉग्स को **पढ़ने**, और अन्य कार्यों में सक्षम बनाती है।

adb का उपयोग कैसे करना है यह सीखने के लिए निम्नलिखित सूची [**ADB Commands**](adb-commands.md) देखें।

## Smali

कभी-कभी यह दिलचस्प होता है कि एप्लिकेशन कोड को **संशोधित** किया जाए ताकि **छिपी हुई जानकारी** (शायद अच्छी तरह obfuscated passwords या flags) तक पहुँच सकें। फिर, apk को decompile करना, कोड संशोधित करना और उसे recompile करना दिलचस्प हो सकता है.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). यह **dynamic analysis के दौरान कई परीक्षणों के लिए एक विकल्प** के रूप में बहुत उपयोगी हो सकता है। इसलिए, इस संभावना को हमेशा ध्यान में रखें।

## Other interesting tricks

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- डिवाइस से APK निकालना:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- सभी splits और base apks को [APKEditor](https://github.com/REAndroid/APKEditor) के साथ मर्ज करें:
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## केस स्टडीज़ और कमजोरियाँ


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Static Analysis

सबसे पहले, किसी APK का विश्लेषण करने के लिए आपको decompiler का उपयोग करके **Java code** देखना चाहिए।\
कृपया, [**read here to find information about different available decompilers**](apk-decompilers.md).

### रोचक जानकारी की तलाश

APK की **strings** को देखकर आप **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** और कोई भी रोचक चीज़ ढूँढ सकते हैं... यहाँ तक कि code execution **backdoors** या authentication **backdoors** (ऐप के लिए hardcoded admin credentials) भी देखें।

**Firebase**

विशेष ध्यान दें **firebase URLs** पर और जाँचें कि क्या यह गलत तरीके से कॉन्फ़िगर है। [More information about whats is FIrebase and how to exploit it here.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Basic understanding of the application - Manifest.xml, strings.xml

**The examination of an application's _Manifest.xml_ and **_strings.xml_** files can reveal potential security vulnerabilities**. इन फाइलों तक decompilers के माध्यम से या APK की file extension को .zip में बदलकर और उसे unzip करके पहुँच किया जा सकता है।

**Manifest.xml** से पहचानी जाने वाली कमजोरियाँ शामिल हैं:

- **Debuggable Applications**: Manifest.xml में `debuggable="true"` सेट की गई applications जोखिमपूर्ण होती हैं क्योंकि ये कनेक्शन की अनुमति देती हैं जो exploitation तक ले जा सकती हैं। debuggable applications को ढूँढने और उनका फायदा उठाने के बारे में समझने के लिए संबंधित ट्यूटोरियल देखें।
- **Backup Settings**: संवेदनशील जानकारी रखने वाले applications के लिए `android:allowBackup="false"` attribute को स्पष्ट रूप से सेट करना चाहिए ताकि adb के माध्यम से अनधिकृत data backups से बचा जा सके, खासकर जब usb debugging सक्षम हो।
- **Network Security**: कस्टम network security configurations (`android:networkSecurityConfig="@xml/network_security_config"`) जो _res/xml/_ में होते हैं, certificate pins और HTTP traffic सेटिंग्स जैसी सुरक्षा जानकारी निर्दिष्ट कर सकते हैं। एक उदाहरण किसी विशिष्ट डोमेन के लिए HTTP ट्रैफ़िक की अनुमति देना हो सकता है।
- **Exported Activities and Services**: manifest में exported activities और services की पहचान करना उन components को उजागर कर सकता है जिन्हें दुरुपयोग किया जा सकता है। डायनामिक परीक्षण के दौरान आगे विश्लेषण यह स्पष्ट कर सकता है कि इन components का फायदा कैसे उठाया जा सकता है।
- **Content Providers and FileProviders**: एक्सपोज़्ड content providers अनधिकृत पहुँच या डेटा में संशोधन की अनुमति दे सकते हैं। FileProviders की कॉन्फ़िगरेशन की भी बारीकी से जाँच करें।
- **Broadcast Receivers and URL Schemes**: ये components exploitation के लिए उपयोग किए जा सकते हैं, विशेषकर यह ध्यान दें कि URL schemes इनपुट के लिए कैसे प्रबंधित किए जाते हैं।
- **SDK Versions**: `minSdkVersion`, `targetSDKVersion`, और `maxSdkVersion` attributes समर्थित Android वर्ज़न इंगित करते हैं, जो यह दर्शाते हैं कि पुराने, कमजोर Android वर्ज़न का समर्थन न करना सुरक्षा के लिए महत्वपूर्ण है।

**strings.xml** फ़ाइल से संवेदनशील जानकारी जैसे कि API keys, custom schemas, और अन्य developer नोट्स मिल सकते हैं, जिससे इन resources की सावधानीपूर्वक समीक्षा की आवश्यकता स्पष्ट होती है।

### Tapjacking

**Tapjacking** एक ऐसा हमला है जहाँ एक **malicious** **application** लॉन्च की जाती है और वह **victim application** के ऊपर स्वयं को पोजिशन कर लेती है। एक बार जब यह पीड़ित ऐप को आंशिक रूप से ढँक देती है, तो इसका UI इस तरह डिज़ाइन किया जाता है कि उपयोगकर्ता को भ्रमित करके वह उस पर इंटरैक्ट करे, जबकि यह इंटरैक्शन पीड़ित ऐप को पास-थ्रू कर देता है।\
असल में, यह **उपयोगकर्ता को अँधा कर देता है ताकि वे न जानें कि वे वास्तव में पीड़ित ऐप पर ही क्रियाएँ कर रहे हैं**।

अधिक जानकारी के लिए देखें:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

यदि किसी **activity** का **`launchMode`** **`singleTask`** पर सेट है और कोई `taskAffinity` परिभाषित नहीं है तो वह task Hijacking के लिए कमजोर होता है। इसका मतलब है कि एक **malicious application** इंस्टॉल की जा सकती है और यदि वास्तविक application से पहले लॉन्च हो तो यह **वास्तविक application के task को hijack कर सकता है** (तो उपयोगकर्ता सोचेंगे कि वे वास्तविक ऐप का उपयोग कर रहे हैं जबकि वे **malicious application** के साथ इंटरैक्ट कर रहे हैं)।

और जानकारी:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Insecure data storage

**Internal Storage**

Android में, internal storage में **store** की गई फाइलें सामान्यतः केवल उस **app** द्वारा एक्सेस की जा सकती हैं जिसने उन्हें बनाया था। यह सुरक्षा उपाय Android operating system द्वारा लागू किया जाता है और अधिकांश applications की सुरक्षा आवश्यकताओं के लिए पर्याप्त होता है। हालाँकि, developers कभी-कभी `MODE_WORLD_READABLE` और `MODE_WORLD_WRITABLE` जैसे modes का उपयोग करके फाइलों को विभिन्न applications के बीच **share** करने की अनुमति देते हैं। ये modes फाइलों को अन्य applications, जिनमें संभावित रूप से malicious ones भी शामिल हैं, द्वारा access करने से रोकते नहीं हैं।

1. **Static Analysis:**
- `MODE_WORLD_READABLE` और `MODE_WORLD_WRITABLE` के उपयोग की सावधानीपूर्वक जाँच सुनिश्चित करें। ये modes फाइलों को अनऑपचारिक या अनधिकृत पहुँच के लिए उजागर कर सकते हैं।
2. **Dynamic Analysis:**
- ऐप द्वारा बनाए गए फाइलों पर सेट की गई **permissions** की जाँच करें। विशेष रूप से, देखें कि क्या कोई फाइलें ऐसी हैं जो worldwide पढ़ी या लिखी जा सकती हैं। यह एक महत्वपूर्ण सुरक्षा जोखिम हो सकता है, क्योंकि इससे किसी भी इंस्टॉल की गई application को, उसके स्रोत या उद्देश्य की परवाह किए बिना, इन फाइलों को पढ़ने या संशोधित करने की अनुमति मिल सकती है।

**External Storage**

SD Cards जैसे external storage पर फाइलों से निपटते समय कुछ सावधानियाँ अपनानी चाहिए:

1. **Accessibility**:
- external storage पर फाइलें सामान्यतः **globally readable and writable** होती हैं। इसका मतलब है कि कोई भी application या उपयोगकर्ता इन फाइलों तक पहुंच सकता है।
2. **Security Concerns**:
- आसान पहुँच को देखते हुए, संवेदनशील जानकारी को external storage पर स्टोर न करने की सलाह दी जाती है।
- External storage हटाया जा सकता है या किसी भी application द्वारा एक्सेस किया जा सकता है, जिससे यह कम सुरक्षित होता है।
3. **Handling Data from External Storage**:
- External storage से प्राप्त डेटा पर हमेशा **input validation** करें। यह महत्वपूर्ण है क्योंकि यह डेटा एक untrusted स्रोत से आता है।
- External storage पर executables या class files को dynamic loading के लिए स्टोर करना सख्त रूप से discouraged है।
- यदि आपका application external storage से executable files प्राप्त करता है, तो सुनिश्चित करें कि ये फाइलें dynamically load करने से पहले **signed और cryptographically verified** हों। यह कदम आपके application की सुरक्षा अखंडता बनाए रखने के लिए आवश्यक है।

External storage को `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard` में एक्सेस किया जा सकता है

> [!TIP]
> Android 4.4 (**API 17**) से शुरू होकर, SD card की directory संरचना ऐसी है जो किसी app की पहुँच को उस directory तक सीमित कर देती है जो विशेष रूप से उस app के लिए है। यह किसी malicious application को दूसरे app की फाइलों पर read या write access प्राप्त करने से रोकता है।

**Sensitive data stored in clear-text**

- **Shared preferences**: Android प्रत्येक application को आसानी से xml फाइलें `/data/data/<packagename>/shared_prefs/` पाथ में सेव करने की अनुमति देता है और कभी-कभी उस फ़ोल्डर में clear-text में संवेदनशील जानकारी मिल सकती है।
- **Databases**: Android प्रत्येक application को आसानी से sqlite databases `/data/data/<packagename>/databases/` पाथ में सेव करने की अनुमति देता है और कभी-कभी उस फ़ोल्डर में clear-text में संवेदनशील जानकारी मिल सकती है।

### Broken TLS

**Accept All Certificates**

कभी-कभी developers किसी कारणवश सभी certificates को accept कर लेते हैं भले ही, उदाहरण के लिए, hostname मेल न खाए — ऐसे lines of code के साथ जैसे निम्नलिखित:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### टूटी क्रिप्टोग्राफी (Broken Cryptography)

**Poor Key Management Processes**

कुछ developers संवेदनशील डेटा को local storage में सेव करते हैं और उसे code में hardcoded/predictable key से encrypt करते हैं। ऐसा नहीं होना चाहिए क्योंकि कुछ reversing से attackers confidential information extract कर सकते हैं।

**Use of Insecure and/or Deprecated Algorithms**

Developers को **deprecated algorithms** का उपयोग authorisation **checks**, डेटा **store** या **send** करने के लिए नहीं करना चाहिए। उन algorithms में कुछ हैं: RC4, MD4, MD5, SHA1... अगर **hashes** का उपयोग पासवर्ड स्टोर करने के लिए किया जा रहा है तो salt के साथ brute-force **resistant** hashes का उपयोग होना चाहिए।

### अन्य जाँचें (Other checks)

- यह सुझाव दिया जाता है कि attackers के लिए reverse engineer का काम कठिन करने हेतु **obfuscate the APK** किया जाए।
- अगर app संवेदनशील है (जैसे bank apps), तो उसे अपने **own checks to see if the mobile is rooted** करने चाहिए और उसके अनुसार कार्रवाई करनी चाहिए।
- अगर app संवेदनशील है (जैसे bank apps), तो उसे जांचना चाहिए कि क्या **emulator** का उपयोग किया जा रहा है।
- अगर app संवेदनशील है (जैसे bank apps), तो उसे **check it's own integrity before executing** करना चाहिए ताकि पता चल सके कि उसे modify किया गया था या नहीं।
- APK को build करने के लिए किस compiler/packer/obfuscator का उपयोग हुआ यह जांचने के लिए [**APKiD**](https://github.com/rednaga/APKiD) का उपयोग करें

### React Native Application

React applications के javascript code तक आसानी से पहुँचने के बारे में जानने के लिए निम्न पृष्ठ पढ़ें:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

एक xamarin applications के C# code तक आसानी से पहुँचने के लिए निम्न पृष्ठ पढ़ें:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

इस [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) के अनुसार superpacked एक Meta algorithm है जो एक application की सामग्री को एक single file में compress कर देता है। ब्लॉग इस बात पर बात करता है कि ऐसे apps को decompress करने वाला एक app बनाना संभव है... और एक तेज़ तरीका जो involve करता है **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

टूल [**mariana-trench**](https://github.com/facebook/mariana-trench) application के **code** को **scanning** करके **vulnerabilities** ढूंढने में सक्षम है। इस टूल में कुछ **known sources** (जो tool को बताती हैं कि वे **places** कहाँ हैं जहाँ **input** **user** द्वारा नियंत्रित है), **sinks** (जो tool को बताती हैं वे **dangerous** **places** जहाँ malicious user input नुकसान कर सकता है) और **rules** शामिल हैं। ये rules उन **sources-sinks** के **combination** को बताते हैं जो vulnerability को इंगित करते हैं।

इन जानकारियों के साथ, **mariana-trench will review the code and find possible vulnerabilities on it**।

### Secrets leaked

एक application के अंदर secrets (API keys, passwords, hidden urls, subdomains...) हो सकते हैं जिन्हें आप खोज सकते हैं। आप ऐसे टूल का उपयोग कर सकते हैं जैसे [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### अन्य दिलचस्प फ़ंक्शंस (Other interesting functions)

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)

### **अन्य ट्रिक्स (Other tricks)**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> सबसे पहले, आपको एक ऐसा environment चाहिए जहाँ आप application और बाकी environment (Burp CA cert, Drozer और Frida मुख्य रूप से) install कर सकें। इसलिए, एक rooted device (emulated या नहीं) अत्यधिक अनुशंसित है।

### Online Dynamic analysis

आप [https://appetize.io/](https://appetize.io/) पर एक **free account** बना सकते हैं। यह platform आपको APKs **upload** और **execute** करने की अनुमति देता है, इसलिए यह यह देखने के लिए उपयोगी है कि apk कैसा व्यवहार कर रहा है।

आप web पर अपने application के logs भी **देख** सकते हैं और **adb** के माध्यम से connect कर सकते हैं।

![](<../../images/image (831).png>)

ADB connection की बदौलत आप emulators के अंदर **Drozer** और **Frida** का उपयोग कर सकते हैं।

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (आप **x86** और **arm** devices बना सकते हैं, और [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** versions **support ARM libraries** बिना slow arm emulator की आवश्यकता के).
- इसे सेट करने के लिए इस पेज को पढ़ें:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, आपको account बनाना होगा. _It's recommend to **download** the version **WITH**_ _**VirtualBox** ताकि संभावित errors से बचा जा सके._)
- [**Nox**](https://es.bignox.com) (Free, पर यह Frida या Drozer को सपोर्ट नहीं करता).

> [!TIP]
> किसी भी platform पर नया emulator बनाते समय ध्यान रखें कि स्क्रीन जितनी बड़ी होगी, emulator उतना ही धीमा चलेगा। इसलिए संभव हो तो छोटे स्क्रीन चुनें।

Genymotion में google services (जैसे AppStore) install करने के लिए आपको निम्न image में लाल चिह्नित बटन पर क्लिक करना होगा:

![](<../../images/image (277).png>)

साथ ही, ध्यान दें कि **Genymotion में Android VM की configuration** में आप **Bridge Network mode** चुन सकते हैं (यह उपयोगी होगा यदि आप tools वाले किसी अलग VM से Android VM से connect कर रहे हों)।

#### Use a physical device

आपको **debugging** options activate करनी होंगी और अच्छा होगा अगर आप इसे **root** कर सकें:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> एक बार जब आपने application install कर ली, तो पहली चीज़ जो आपको करनी चाहिए वह है इसे चलाकर देखना, यह जाँचना कि यह क्या करता है, कैसे काम करता है और इसके साथ comfortable होना।\
> मैं सुझाव दूंगा कि इस शुरुआती dynamic analysis को MobSF dynamic analysis + pidcat का उपयोग करके करें, ताकि हम यह सीख सकें कि application कैसे काम करता है जबकि MobSF बहुत सारी **interesting** **data** capture कर रहा है जिन्हें आप बाद में review कर सकते हैं।

### Unintended Data Leakage

**Logging**

Developers को सार्वजनिक रूप से **debugging information** उजागर करने में सावधान रहना चाहिए, क्योंकि इससे sensitive data leaks हो सकते हैं। application logs मॉनिटर करने के लिए टूल्स [**pidcat**](https://github.com/JakeWharton/pidcat) और `adb logcat` की सिफारिश की जाती है ताकि sensitive information की पहचान और सुरक्षा की जा सके। **Pidcat** अपनी उपयोग में आसानता और readability के कारण पसंदीदा है।

> [!WARNING]
> ध्यान दें कि **Android 4.0 से बाद के संस्करणों** में, **applications केवल अपने ही logs को एक्सेस कर पाती हैं**। इसलिए applications अन्य apps के logs को access नहीं कर सकतीं।\
> फिर भी, फिर भी यह अनुशंसित है कि **sensitive information को log न करें**।

**Copy/Paste Buffer Caching**

Android का **clipboard-based** framework apps में copy-paste functionality सक्षम करता है, फिर भी यह जोखिम पैदा करता है क्योंकि **other applications** clipboard को **access** कर सकती हैं, जिससे sensitive data उजागर होने की संभावना रहती है। इसलिए credit card details जैसी संवेदनशील sections के लिए copy/paste functions को disable करना महत्वपूर्ण है ताकि data leaks से बचा जा सके।

**Crash Logs**

यदि कोई application **crash** होता है और logs **save** करता है, तो ये logs attackers की मदद कर सकते हैं, विशेषकर तब जब application reverse-engineer नहीं की जा सकती। इस जोखिम को कम करने के लिए, crashes पर log न करें, और यदि logs को नेटवर्क पर भेजना आवश्यक है तो सुनिश्चित करें कि वे SSL channel के माध्यम से भेजे जा रहे हों।

As pentester, **try to take a look to these logs**.

**Analytics Data Sent To 3rd Parties**

Applications अक्सर Google Adsense जैसी services integrate करते हैं, जो developers के improper implementation के कारण अनजाने में **leak sensitive data** कर सकती हैं। संभावित data leaks पहचानने के लिए, application के traffic को intercept करना और यह जांचना सलाहप्रद है कि कोई sensitive information third-party services को तो नहीं भेजी जा रही है।

### SQLite DBs

ज्यादातर applications internal SQLite databases का उपयोग जानकारी save करने के लिए करती हैं। pentest के दौरान बनाए गए **databases**, **tables** और **columns** के नामों और saved **data** को जरूर देखें क्योंकि आपको वहाँ **sensitive information** मिल सकती है (जो एक vulnerability होगी).\
Databases आमतौर पर `/data/data/the.package.name/databases` में स्थित होते हैं जैसे `/data/data/com.mwr.example.sieve/databases`

यदि database confidential information save कर रहा है और वह **encrypted** है पर आप application के अंदर **password** **find** कर सकते हैं तो यह फिर भी एक **vulnerability** है।

.tables का उपयोग करके tables enumerate करें और `.schema <table_name>` करके tables के columns enumerate करें।

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** आपको एक Android app की भूमिका assume करने और other apps के साथ interact करने की अनुमति देता है। यह **anything that an installed application can do** कर सकता है, जैसे Android’s Inter-Process Communication (IPC) mechanism का उपयोग करना और underlying operating system के साथ interact करना। .\
Drozer एक उपयोगी टूल है ताकि आप **exploit exported activities, exported services and Content Providers** कर सकें जैसा कि आप निम्न sections में सीखेंगे।

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
यह भी याद रखें कि किसी activity का code **`onCreate`** method में शुरू होता है।

**Authorisation bypass**

जब कोई Activity exported होती है आप उसे किसी external app से invoke कर सकते हैं। इसलिए, यदि कोई activity जिसमें **sensitive information** है वह **exported** है तो आप authentication mechanisms को **bypass** करके उससे access प्राप्त कर सकते हैं।

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

आप adb से भी एक exported activity start कर सकते हैं:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**नोट**: MobSF किसी activity में `android:launchMode` के रूप में _**singleTask/singleInstance**_ के उपयोग को हानिकारक के रूप में पहचानता है, लेकिन [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750) के कारण, ऐसा प्रतीत होता है कि यह केवल पुराने वर्ज़न (API versions < 21) पर ही खतरनाक है।

> [!TIP]
> ध्यान दें कि an authorisation bypass हमेशा vulnerability नहीं होता — यह इस पर निर्भर करेगा कि bypass कैसे काम करता है और कौन-सी जानकारी उजागर होती है।

**Sensitive information leakage**

**Activities can also return results**. यदि आप किसी exported और unprotected activity को खोज लेते हैं जो **`setResult`** method को कॉल कर रही हो और संवेदनशील जानकारी return कर रही हो, तो यह sensitive information leakage है।

#### Tapjacking

यदि Tapjacking रोका नहीं गया है, तो आप exported activity का दुरुपयोग करके user को अनपेक्षित actions करने के लिए मजबूर कर सकते हैं। अधिक जानकारी के लिए [**Tapjacking क्या है — लिंक फॉलो करें**](#tapjacking)।

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers मूलतः डेटा **share** करने के लिए इस्तेमाल होते हैं। यदि किसी app के पास content providers उपलब्ध हैं तो आप उनसे संवेदनशील डेटा **extract** कर सकते हैं। साथ ही संभावित **SQL injections** और **Path Traversals** की जांच करना दिलचस्प होता है क्योंकि वे vulnerable हो सकते हैं।

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
याद रखें कि Service के actions method `onStartCommand` में शुरू होते हैं।

Service मूलतः कुछ ऐसा होता है जो डेटा **receive** कर सकता है, उसे **process** करता है और (या नहीं) एक response **returns** करता है। इसलिए, यदि कोई application कुछ services export कर रहा है तो आपको **code** को **check** करना चाहिए कि वह क्या कर रहा है और उसे **dynamically** **test** करना चाहिए ताकि confidential info extract की जा सके, authentication measures को bypass किया जा सके...\ 
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
याद रखें कि Broadcast Receiver के actions method `onReceive` में शुरू होते हैं।

A broadcast receiver किसी प्रकार के message के लिए waiting रहेगी। यह निर्भर करता है कि receiver message को कैसे handle करता है — इसके कारण यह vulnerable हो सकती है।\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

आप deep links मैन्युअली ढूँढ सकते हैं, MobSF जैसे tools या [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py) जैसी scripts का उपयोग करके।\
आप घोषित किए गए किसी **scheme** को **adb** या किसी **browser** का उपयोग करके **open** कर सकते हैं:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_ध्यान दें कि आप **package name छोड़ सकते हैं** और मोबाइल स्वतः उस app को कॉल करेगा जो उस लिंक को खोलना चाहिए._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**कोड निष्पादित**

ऐप में निष्पादित होने वाले **कोड को खोजने के लिए**, उस activity पर जाएँ जिसे deeplink कॉल करता है और function **`onNewIntent`** खोजें।

![](<../../images/image (436) (1) (1) (1).png>)

**संवेदनशील जानकारी**

हर बार जब आप कोई deep link पाते हैं, तो जाँच करें कि यह **URL parameters के माध्यम से संवेदनशील डेटा (जैसे passwords) प्राप्त तो नहीं कर रहा है**, क्योंकि कोई भी अन्य application **deep link की impersonate करके वह डेटा चुरा सकता है!**

**पाथ में पैरामीटर्स**

आपको यह भी **जाँचना चाहिए कि कोई deep link URL के path के अंदर parameter का उपयोग तो नहीं कर रहा है** जैसा कि: `https://api.example.com/v1/users/{username}` , ऐसे मामले में आप path traversal फोर्स कर सकते हैं जैसे: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
ध्यान दें कि यदि आप एप्लिकेशन के अंदर सही endpoints पाते हैं तो आप **Open Redirect** (अगर path का कोई हिस्सा domain name के रूप में उपयोग हो रहा हो), **account takeover** (अगर आप users विवरण बिना CSRF token के modify कर सकते हैं और vuln endpoint ने सही method उपयोग किया था) और कोई अन्य vuln पैदा कर सकते हैं। More [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### ट्रांसपोर्ट लेयर निरीक्षण और सत्यापन विफलताएँ

- **Certificates हमेशा ठीक से जांचे नहीं जाते** Android applications द्वारा। अक्सर ये applications warnings को नज़रअंदाज़ कर self-signed certificates को स्वीकार कर लेते हैं या कुछ मामलों में HTTP कनेक्शन्स पर लौट जाते हैं।
- **SSL/TLS handshake के दौरान negotiations कभी-कभी कमजोर होती हैं**, जो insecure cipher suites उपयोग करती हैं। यह कमजोरी कनेक्शन को man-in-the-middle (MITM) हमलों के प्रति संवेदनशील बनाती है, जिससे attackers डेटा को decrypt कर सकते हैं।
- **Leakage of private information** का जोखिम तब होता है जब applications secure चैनलों का उपयोग करके authenticate करती हैं पर अन्य ट्रांज़ैक्शन्स के लिए non-secure चैनलों पर communicate करती हैं। यह तरीका session cookies या user details जैसे संवेदनशील डेटा को malicious entities द्वारा interception से सुरक्षित नहीं रखता।

#### सर्टिफिकेट सत्यापन

हम **certificate verification** पर ध्यान केंद्रित करेंगे। सर्वर के certificate की integrity की पुष्टि करके सुरक्षा बढ़ाई जानी चाहिए। यह महत्वपूर्ण है क्योंकि insecure TLS configurations और unencrypted चैनलों पर संवेदनशील डेटा का संचार गंभीर जोखिम पैदा कर सकता है। सर्वर certificates को verify करने और कमजोरियों को ठीक करने के विस्तृत चरणों के लिए, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) व्यापक मार्गदर्शन प्रदान करता है।

#### SSL Pinning

SSL Pinning एक security measure है जहाँ application सर्वर के certificate की जाँच application में संग्रहीत ज्ञात copy के खिलाफ करती है। यह विधि MITM attacks रोकने के लिए आवश्यक है। संवेदनशील जानकारी हैंडल करने वाले अनुप्रयोगों के लिए SSL Pinning लागू करना strongly recomendado है।

#### ट्रैफ़िक निरीक्षण

HTTP ट्रैफ़िक निरीक्षण करने के लिए, proxy tool का certificate **install** करना आवश्यक है (उदाहरण के लिए, Burp)। इस certificate को install किए बिना, encrypted ट्रैफ़िक proxy के माध्यम से दिखाई नहीं दे सकती। custom CA certificate install करने के लिए गाइड के लिए, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine) देखें।

Applications जो **API Level 24 and above** target करते हैं, उन्हें Network Security Config में बदलाव करने की आवश्यकता होती है ताकि proxy की CA certificate स्वीकार की जा सके। यह कदम encrypted ट्रैफ़िक को inspect करने के लिए महत्वपूर्ण है। Network Security Config बदलने के निर्देशों के लिए, [**refer to this tutorial**](make-apk-accept-ca-certificate.md) देखें।

यदि **Flutter** उपयोग हो रहा है तो आपको [**this page**](flutter.md) के निर्देशों का पालन करना होगा। ऐसा इसलिए क्योंकि केवल certificate को store में जोड़ने से काम नहीं चलेगा क्योंकि Flutter के पास अपनी मान्य CAs की सूची होती है।

#### Static detection of SSL/TLS pinning

runtime bypasses का प्रयास करने से पहले, जल्दी से मैप करें कि APK में pinning कहाँ लागू है। Static discovery आपको hooks/patches की योजना बनाने और सही code paths पर फोकस करने में मदद करती है।

Tool: SSLPinDetect
- Open-source static-analysis utility जो APK को Smali (via apktool) में decompile करती है और SSL/TLS pinning implementations के curated regex patterns को scan करती है।
- प्रत्येक मैच के लिए exact file path, line number, और code snippet report करती है।
- सामान्य frameworks और custom code paths को कवर करती है: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, और Network Security Config XML pins।

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
उपयोग
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
पैटर्न नियमों का उदाहरण (JSON)
प्रोप्राइटरी/कस्टम pinning शैलियों का पता लगाने के लिए signatures का उपयोग करें या उन्हें विस्तारित करें। आप अपना स्वयं का JSON लोड कर सकते हैं और बड़े पैमाने पर स्कैन कर सकते हैं।
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
नोट्स और सुझाव
- बड़े ऐप्स पर तेज़ स्कैनिंग के लिए मल्टी-थ्रेडिंग और memory-mapped I/O का उपयोग; pre-compiled regex ओवरहेड और false positives कम करता है।
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- अगली ट्रायेज़ के लिए सामान्य खोज के लक्ष्य:
- OkHttp: CertificatePinner उपयोग, setCertificatePinner, okhttp3/okhttp पैकेज संदर्भ
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted के overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init custom managers के साथ
- res/xml में declarative pins, network security config और manifest संदर्भ
- मैच हुई लोकेशनों का उपयोग Frida hooks, static patches, या config reviews की योजना बनाने के लिए करें, dynamic testing से पहले।



#### SSL Pinning को बायपास करना

जब SSL Pinning लागू किया गया हो, तो HTTPS ट्रैफ़िक को निरीक्षण करने के लिए इसे बायपास करना आवश्यक हो जाता है। इस उद्देश्य के लिए कई तरीके उपलब्ध हैं:

- स्वचालित रूप से **apk** को बदलकर SSLPinning को **बायपास** करने के लिए [**apk-mitm**](https://github.com/shroudedcode/apk-mitm) का उपयोग करें। इस विकल्प का सबसे बड़ा प्रो यह है कि SSL Pinning बायपास करने के लिए आपको root की ज़रूरत नहीं पड़ेगी, लेकिन आपको एप्लिकेशन को डिलीट करके नया इंस्टॉल करना होगा, और यह हमेशा काम नहीं करेगा।
- आप इस सुरक्षा को बायपास करने के लिए **Frida** (नीचे चर्चा) का उपयोग कर सकते हैं। Burp+Frida+Genymotion का उपयोग करने का गाइड यहाँ है: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- आप [**objection**](frida-tutorial/objection-tutorial.md) का उपयोग करके **स्वचालित रूप से SSL Pinning बायपास** करने की भी कोशिश कर सकते हैं:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- आप **MobSF dynamic analysis** का उपयोग करके भी **स्वचालित रूप से SSL Pinning बायपास** करने का प्रयास कर सकते हैं (नीचे समझाया गया है)
- अगर आपको लगता है कि कुछ ट्रैफ़िक आप कैप्चर नहीं कर पा रहे हैं तो आप ट्रैफ़िक को burp पर फॉरवर्ड करने के लिए iptables का उपयोग करने की कोशिश कर सकते हैं। इस ब्लॉग को पढ़ें: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### एप्लिकेशन में सामान्य वेब कमजोरियों की तलाश

ऐप के भीतर सामान्य वेब कमजोरियों की खोज भी ज़रूरी है। इन कमजोरियों की पहचान और उन्हें कम करने के विस्तृत तरीके इस सारांश के दायरे से बाहर हैं लेकिन अन्य स्थानों पर विस्तार से कवर किए गए हैं।

### Frida

[Frida](https://www.frida.re) विकासकर्ताओं, रिवर्स-इन्जीनियर्स, और सुरक्षा शोधकर्ताओं के लिए एक dynamic instrumentation toolkit है.\
**आप रनिंग application तक पहुंच सकते हैं और रनटाइम पर मेथड्स को hook करके व्यवहार बदल सकते हैं, मान बदल सकते हैं, मान निकाल सकते हैं, अलग कोड चला सकते हैं...**\
अगर आप Android applications का pentest करना चाहते हैं तो आपको Frida का उपयोग करना आना चाहिए।

- Frida का उपयोग कैसे करें जानें: [**Frida tutorial**](frida-tutorial/index.html)
- Frida के साथ actions के लिए कुछ "GUI": [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection Frida के उपयोग को ऑटोमेट करने के लिए शानदार है: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- कुछ Awesome Frida scripts आप यहाँ पा सकते हैं: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- anti-debugging / anti-frida मैकेनिज़्म को बायपास करने की कोशिश करें Frida को उसी तरह लोड करके जैसा कि [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) में बताया गया है (टूल [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **डंप मेमोरी - Fridump**

जाँचें कि क्या ऐप मेमोरी में संवेदनशील जानकारी स्टोर कर रहा है जिसे वहां नहीं रखना चाहिए, जैसे passwords या mnemonics.

आप [**Fridump3**](https://github.com/rootbsd/fridump3) का उपयोग करके ऐप की मेमोरी को इस तरह डंप कर सकते हैं:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
यह ./dump फ़ोल्डर में memory को dump करेगा, और वहाँ आप कुछ इस तरह grep कर सकते हैं:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Keystore में संवेदनशील डेटा**

Android में Keystore संवेदनशील डेटा स्टोर करने के लिए सबसे अच्छा स्थान है, हालांकि पर्याप्त privileges होने पर फिर भी **उस तक पहुँच संभव है**।

चूँकि applications यहाँ अक्सर **सादा टेक्स्ट में संवेदनशील डेटा** स्टोर करते हैं, pentests को इसे root user के रूप में जांचना चाहिए, क्योंकि किसी के पास डिवाइस तक भौतिक पहुँच होने पर वह यह डेटा चुरा सकता है।

भले ही किसी app ने Keystore में डेटा स्टोर किया हो, डेटा एन्क्रिप्टेड होना चाहिए।

Keystore के अंदर के डेटा तक पहुँचने के लिए आप यह Frida script इस्तेमाल कर सकते हैं: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

निम्नलिखित Frida script का उपयोग करके संभवतः Android applications में किसी संवेदनशील क्षेत्र की सुरक्षा हेतु किए जा रहे **bypass fingerprint authentication** को निष्क्रिय किया जा सकता है:
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **पृष्ठभूमि छवियाँ**

जब आप किसी एप्लिकेशन को बैकग्राउंड में डालते हैं, Android एप्लिकेशन का एक **स्नैपशॉट** स्टोर करता है ताकि जब उसे फ़ोरग्राउंड में वापस लाया जाए तो यह ऐप से पहले इमेज लोड करना शुरू कर दे ताकि ऐसा लगे कि ऐप तेज़ी से लोड हुआ।

हालाँकि, अगर यह स्नैपशॉट **संवेदनशील जानकारी** रखता है, तो जिसके पास स्नैपशॉट तक पहुँच है वह **उस जानकारी को चुरा सकता है** (ध्यान दें कि इसे एक्सेस करने के लिए root की आवश्यकता होती है)।

स्नैपशॉट्स आमतौर पर इस पथ पर स्टोर होते हैं: **`/data/system_ce/0/snapshots`**

Android layout parameter में **FLAG_SECURE सेट करके स्क्रीनशॉट कैप्चर को रोकने** का तरीका प्रदान करता है। इस flag का उपयोग करने पर विंडो की सामग्री को सुरक्षित माना जाता है, जिससे यह स्क्रीनशॉट्स में दिखाई देने या गैर-सुरक्षित डिस्प्ले पर देखे जाने से रोका जाता है।
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

यह टूल dynamic analysis के दौरान विभिन्न टूल्स को प्रबंधित करने में मदद कर सकता है: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

डेवलपर्स अक्सर proxy components जैसे activities, services, और broadcast receivers बनाते हैं जो इन Intents को हैंडल करते हैं और उन्हें `startActivity(...)` या `sendBroadcast(...)` जैसे methods को पास कर देते हैं, जो जोखिम भरा हो सकता है।

खतरा इस बात में है कि attackers इन Intents को भटका कर non-exported app components को ट्रिगर कर सकते हैं या sensitive content providers तक पहुँच सकते हैं। एक महत्वपूर्ण उदाहरण यह है कि `WebView` component URLs को `Intent` objects में `Intent.parseUri(...)` के माध्यम से बदल देता है और फिर उन्हें execute कर देता है, जिससे संभावित रूप से malicious Intent injections हो सकते हैं।

### प्रमुख निष्कर्ष

- **Intent Injection** वेब के Open Redirect issue के समान है।
- Exploits में `Intent` objects को extras के रूप में पास करना शामिल होता है, जिन्हें redirect करके unsafe operations execute करवाए जा सकते हैं।
- यह attackers के लिए non-exported components और content providers को expose कर सकता है।
- `WebView` की URL से `Intent` में conversion अनचाही गतिविधियाँ होने में सहायक हो सकती है।

### Android Client Side Injections and others

संभवतः आप इस प्रकार की कमजोरियों को वेब से जानते होंगे। Android application में इन कमजोरियों के साथ विशेष सावधानी बरतनी चाहिए:

- **SQL Injection:** जब dynamic queries या Content-Providers के साथ काम कर रहे हों, सुनिश्चित करें कि आप parameterized queries का उपयोग कर रहे हैं।
- **JavaScript Injection (XSS):** Verify that JavaScript and Plugin support is disabled for any WebViews (disabled by default). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews should have access to the file system disabled (enabled by default) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: कई मामलों में जब Android application session समाप्त करता है तो cookie revoke नहीं होती या disk पर भी सेव हो सकती है
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Static analysis**

![](<../../images/image (866).png>)

**Vulnerability assessment of the application** using a nice web-based frontend. You can also perform dynamic analysis (but you need to prepare the environment).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### MobSF के साथ सहायक डायनेमिक विश्लेषण

**MobSF** Android में **dynamic analysis** के लिए भी बहुत मददगार हो सकता है, पर उस स्थिति में आपको अपने host पर MobSF और **genymotion** install करना होगा (a VM or Docker won't work)। _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
**MobSF dynamic analyser** निम्न कर सकता है:

- **Dump application data** (URLs, logs, clipboard, आपके द्वारा लिए गए screenshots, "**Exported Activity Tester**" द्वारा लिए गए screenshots, emails, SQLite databases, XML files, और अन्य बनाई गई फाइलें)। ये सब अपने आप किया जाता है सिवाय screenshots के — स्क्रीनशॉट लेने के लिए आपको मैन्युअली दबाना होगा जब आप screenshot चाहते हैं या सभी exported activities के screenshots प्राप्त करने के लिए आपको "**Exported Activity Tester**" दबाना होगा।
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

Android **versions > 5** से, यह स्वतः **Frida** शुरू कर देगा और ट्रैफिक कैप्चर करने के लिए global **proxy** settings सेट कर देगा। यह केवल टेस्ट की जा रही एप्लिकेशन का ट्रैफिक ही कैप्चर करेगा।

**Frida**

डिफ़ॉल्ट रूप से, यह कुछ Frida Scripts का उपयोग SSL pinning, root detection और debugger detection को bypass करने और interesting APIs की monitor करने के लिए भी करेगा।\
MobSF exported activities को invoke भी कर सकता है, उनके **screenshots** ले सकता है और रिपोर्ट के लिए **save** कर सकता है।

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: यह सभी loaded classes को print करेगा
- **Capture Strings**: एप्लिकेशन उपयोग करते समय यह सभी captured strings को print करेगा (super noisy)
- **Capture String Comparisons**: बहुत उपयोगी हो सकता है। यह तुलना की जा रही 2 strings दिखाएगा और परिणाम True था या False था।
- **Enumerate Class Methods**: क्लास नाम डालें (जैसे "java.io.File") और यह उस क्लास के सभी methods print करेगा।
- **Search Class Pattern**: पैटर्न से classes खोजें
- **Trace Class Methods**: किसी पूरे क्लास को **Trace** करें (क्लास के सभी methods के inputs और outputs देखें)। ध्यान रखें कि डिफ़ॉल्ट रूप से MobSF कई उपयोगी Android Api methods को trace करता है।

एक बार जब आप जिस auxiliary module को उपयोग करना चाहते हैं उसे select कर लेते हैं, तो आपको "**Start Intrumentation**" दबाना होगा और आप सभी outputs "**Frida Live Logs**" में देखेंगे।

**Shell**

MobSF आपको dynamic analysis पेज के निचले हिस्से में कुछ **adb** commands, **MobSF commands**, और सामान्य **shell** **commands** के साथ एक shell भी देता है। कुछ दिलचस्प commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP टूल्स**

When HTTP ट्रैफिक is capture you can see an ugly view of the captured traffic on "**HTTP(S) Traffic**" bottom or a nicer view in "**Start HTTPTools**" green bottom. From the second option, you can **send** the **captured requests** to **proxies** like Burp or Owasp ZAP.\
To do so, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> press "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Once you finish the dynamic analysis with MobSF you can press on "**Start Web API Fuzzer**" to **fuzz http requests** an look for vulnerabilities.

> [!TIP]
> After performing a dynamic analysis with MobSF the proxy settings me be misconfigured and you won't be able to fix them from the GUI. You can fix the proxy settings by doing:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

You can get the tool from [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
This tool with use some **Hooks** to let you know **what is happening in the application** while you perform a **dynamic analysis**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

This is a **great tool to perform static analysis with a GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

This tool is designed to look for several **security related Android application vulnerabilities**, either in **source code** or **packaged APKs**. The tool is also **capable of creating a "Proof-of-Concept" deployable APK** and **ADB commands**, to exploit some of the found vulnerabilities (Exposed activities, intents, tapjacking...). As with Drozer, there is no need to root the test device.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- सभी निकाली गई फ़ाइलें आसान संदर्भ के लिए दिखाता है
- APK फ़ाइलों को स्वचालित रूप से Java और Smali फॉर्मेट में decompile करता है
- AndroidManifest.xml का विश्लेषण करता है सामान्य vulnerabilities और व्यवहार के लिए
- Static source code analysis (सामान्य vulnerabilities और व्यवहार के लिए)
- डिवाइस जानकारी
- और भी
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER एक कमांड-लाइन एप्लीकेशन है जिसे Windows, MacOS X और Linux पर चलाया जा सकता है, जो _.apk_ फ़ाइलों का विश्लेषण करके कमजोरियों की खोज करता है। यह APKs को decompress करके और उन कमजोरियों का पता लगाने के लिए नियमों की एक श्रृंखला लागू करके ऐसा करता है।

सभी नियम `rules.json` फ़ाइल में केंद्रित हैं, और प्रत्येक कंपनी या tester अपनी आवश्यकताओं के अनुसार अपने नियम बना सकती है।

नवीनतम बाइनरीज़ [download page](https://superanalyzer.rocks/download.html) से डाउनलोड करें।
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn एक **crossplatform** टूल है जो developers, bugbounty hunters और ethical hackers को मोबाइल एप्लिकेशन पर [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) करने में मदद करता है।

कोन्सेप्ट यह है कि आप अपनी मोबाइल एप्लिकेशन फ़ाइल (एक .apk या .ipa फ़ाइल) को StaCoAn application पर drag and drop करें और यह आपके लिए एक visual और portable report जनरेट करेगा। आप settings और wordlists को tweak करके एक customized अनुभव पा सकते हैं।

Download[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework एक Android vulnerability analysis सिस्टम है जो developers या hackers को Android applications में संभावित security vulnerabilities खोजने में मदद करता है।\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** एक ऐसा टूल है जिसका मुख्य उद्देश्य उपयोगकर्ता को किसी Android application द्वारा विकसित संभावित हानिकारक व्यवहारों के बारे में पता लगाना और चेतावनी देना है।

डिटेक्शन ऐप्लिकेशन के Dalvik bytecode की **static analysis** के माध्यम से किया जाता है, जो **Smali** के रूप में प्रस्तुत होता है, और [`androguard`](https://github.com/androguard/androguard) लाइब्रेरी का उपयोग करता है।

यह टूल निम्नलिखित जैसी चीज़ों के लिए **common behavior of "bad" applications** को खोजता है: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** एक **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework है। यह एक टूल है जो सामान्यतः उपयोग किए जाने वाले mobile application reverse engineering और analysis tools को एक साथ रखता है, ताकि OWASP mobile security threats के खिलाफ mobile applications का परीक्षण करना आसान हो सके। इसका उद्देश्य mobile application developers और security professionals के लिए यह कार्य आसान और अधिक मित्रवत बनाना है।

यह सक्षम है:

- विभिन्न tools का उपयोग करके Java और Smali code निकालना
- APKs का विश्लेषण करना using: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- regexps का उपयोग करके APK से private information निकालना
- Manifest का विश्लेषण करना
- पाये गए domains का विश्लेषण करना using: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- APK को Deobfuscate करना via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

malware का पता लगाने के लिए उपयोगी: [https://koodous.com/](https://koodous.com)

## Obfuscating/Deobfuscating code

ध्यान दें कि जिस सेवा और कॉन्फ़िगरेशन का आप उपयोग करते हैं कोड को obfuscate करने के लिए, उसके अनुसार Secrets obfuscated हो सकती हैं या नहीं भी।

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** एक open source command-line tool है जो Java code को shrink, optimize और obfuscate करता है। यह bytecode को optimize करने के साथ-साथ unused instructions को detect और remove करने में सक्षम है। ProGuard free software है और GNU General Public License, version 2 के तहत वितरित किया जाता है।

ProGuard Android SDK के हिस्से के रूप में वितरित होता है और release mode में application build करने पर चलता है।

### [DexGuard](https://www.guardsquare.com/dexguard)

Deobfuscate करने के लिए चरण-दर-चरण गाइड यहाँ पढ़ें: [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) जब हमने आख़िरी बार जाँच की थी, Dexguard का mode of operation इस प्रकार था:

- एक resource को InputStream के रूप में load करें;
- परिणाम को decrypt करने के लिए FilterInputStream से inherit करने वाली एक class को feed करें;
- reverser का कुछ समय बर्बाद करने के लिए कुछ बेकार obfuscation करें;
- decrypted परिणाम को ZipInputStream में feed करें ताकि एक DEX file मिल सके;
- अंत में resulting DEX को Resource के रूप में `loadDex` method का उपयोग करके load करें।

### [DeGuard](http://apk-deguard.com)

**DeGuard उन Android obfuscation tools द्वारा किए गए obfuscation की प्रक्रिया को reverse करता है। यह कई security analyses को सक्षम बनाता है, जिसमें code inspection और libraries की prediction शामिल हैं।**

आप एक obfuscated APK को उनके platform पर upload कर सकते हैं।

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

यह एक LLM tool है जो android apps में किसी भी potential security vulnerabilities को खोजने और android app code को deobfuscate करने में मदद करता है। यह Google's Gemini public API का उपयोग करता है।

### [Simplify](https://github.com/CalebFenton/simplify)

यह एक generic android deobfuscator है। Simplify virtually executes एक app ताकि उसके व्यवहार को समझा जा सके और फिर code को optimize करने की कोशिश करता है ताकि वह identical व्यवहार करे पर इंसान के लिए समझने में आसान हो। प्रत्येक optimization प्रकार simple और generic है, इसलिए यह मायने नहीं रखता कि किस specific प्रकार की obfuscation का उपयोग किया गया था।

### [APKiD](https://github.com/rednaga/APKiD)

APKiD आपको यह जानकारी देता है कि किसी APK को कैसे बनाया गया था। यह कई compilers, packers, obfuscators और अन्य अजीब चीज़ों की पहचान करता है। यह Android के लिए [_PEiD_](https://www.aldeid.com/wiki/PEiD) की तरह है।

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b एक Android security virtual machine है जो ubuntu-mate पर आधारित है और इसमें reverse engineering और malware analysis के लिए नवीनतम frameworks, tutorials और labs का संग्रह शामिल है।

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) यह resources की एक शानदार सूची है
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)

## Yet to try

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
