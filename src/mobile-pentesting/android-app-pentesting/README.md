# Android Toepassings Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android Toepassings Basiese beginsels

Dit word sterk aanbeveel om eers hierdie bladsy te lees om meer te weet oor die **belangrikste dele wat verband hou met Android-veiligheid en die gevaarlikste komponente in 'n Android-toepassing**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Dit is die hoofinstrument wat jy nodig het om met 'n Android-toestel (geëmuleer of fisies) te verbind.\
**ADB** stel jou in staat om toestelle te beheer via **USB** of **Network** vanaf 'n rekenaar. Hierdie hulpmiddel maak voorsiening vir die **kopieëring** van lêers in beide rigtings, die **installasie** en **deïnstallasie** van apps, die **uitvoering** van shell-opdragte, die **rugsteun** van data, die **lees** van logs, onder andere funksies.

Kyk na die volgende lys van [**ADB Commands**](adb-commands.md) om te leer hoe om adb te gebruik.

## Smali

Soms is dit interessant om die **toepassingskode te wysig** om toegang te kry tot **verborgen inligting** (byvoorbeeld goed geobfuskate wagwoorde of flags). Dan kan dit interessant wees om die apk te dekompileer, die kode te wysig en dit weer te kompileer.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Dit kan baie nuttig wees as 'n **alternative for several tests during the dynamic analysis** wat aangebied gaan word. Hou hierdie moontlikheid altyd in gedagte.

## Ander interessante truuks

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Onttrek APK vanaf toestel:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Voeg alle splits en base apks saam met [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Android Enterprise & Work Profile Attacks

{{#ref}}
android-enterprise-work-profile-bypass.md
{{#endref}}

## Gevallestudies & Kwetsbaarhede


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Statiese Analise

Eerstens, om 'n APK te ontleed moet jy **na die Java-kode kyk** met 'n decompiler.\
Lees asseblief [**hier vir inligting oor verskillende beskikbare decompilers**](apk-decompilers.md).

### Soek na interessante inligting

Deur net na die **strings** van die APK te kyk kan jy soek na **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** en enigiets interessant... kyk selfs vir code execution **backdoors** of authentication backdoors (hardcoded admin credentials in die app).

**Firebase**

Betaal besondere aandag aan **Firebase URLs** en kontroleer of dit verkeerd gekonfigureer is. [Meer inligting oor wat Firebase is en hoe om dit uit te buit hier.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Basiese begrip van die toepassing - Manifest.xml, strings.xml

Die **ondersoek van 'n toepassing se _Manifest.xml_ en **_strings.xml_** lêers kan potensiële sekuriteitskwesbaarhede onthul**. Hierdie lêers is bereikbaar met behulp van decompilers of deur die APK-lêeruitbreiding na .zip te hernoem en dit dan uit te pak.

**Kwetsbaarhede** geïdentifiseer uit die **Manifest.xml** sluit in:

- **Debuggable Applications**: Toepassings wat as debuggable gestel is (`debuggable="true"`) in die _Manifest.xml_ lêer dra 'n risiko aangesien dit verbindings toelaat wat tot uitbuiting kan lei. Vir meer inligting oor hoe om debuggable applications te benut, verwys na 'n handleiding oor die vind en uitbuiting van debuggable applications op 'n toestel.
- **Backup Settings**: Die `android:allowBackup="false"` attribuut moet uitdruklik gestel word vir toepassings wat met sensitiewe inligting werk om ongemagtigde databack-ups via adb te voorkom, veral wanneer USB debugging aangeskakel is.
- **Network Security**: Aangepaste netwerk-sekuriteitskonfigurasies (`android:networkSecurityConfig="@xml/network_security_config"`) in _res/xml/_ kan sekuriteitsbesonderhede spesifiseer soos certificate pins en HTTP-verkeer-instellings. 'n Voorbeeld is om HTTP-verkeer toe te laat vir spesifieke domeine.
- **Exported Activities and Services**: Om geëksporteerde activities en services in die manifest te identifiseer kan komponente uitlig wat misbruik kan word. Verdere ontleding tydens dinamiese toetsing kan openbaar hoe om hierdie komponente uit te buit.
- **Content Providers and FileProviders**: Blootgestelde content providers kan ongemagtigde toegang of modifikasie van data toelaat. Die konfigurasie van FileProviders moet ook deeglik ondersoek word.
- **Broadcast Receivers and URL Schemes**: Hierdie komponente kan gebruik word vir uitbuiting, met spesiale aandag aan hoe URL-skema's bestuur word ten opsigte van input-kwesbaarhede.
- **SDK Versions**: Die `minSdkVersion`, `targetSDKVersion`, en `maxSdkVersion` attributte dui die ondersteunde Android-weergawes aan, en beklemtoon die belangrikheid om nie verouderde, kwesbare Android-weergawes te ondersteun vir sekuriteitsredes nie.

Uit die **strings.xml**-lêer kan sensitiewe inligting soos API-keys, aangepaste skemas en ander ontwikkelaar-note ontdek word, wat die nodigheid vir noukeurige hersiening van hierdie hulpbronne beklemtoon.

### Tapjacking

**Tapjacking** is 'n aanval waar 'n **kwaadwillige toepassing** geloods word en **homself bo 'n slagoffer-toepassing posisioneer**. Sodra dit die slagoffer-app sigbaar oorlê, is sy gebruikerskoppelvlak so ontwerp dat dit die gebruiker mislei om daarmee te interaksioneer, terwyl dit die interaksie aan die slagoffer-app deurgee. In effek blind dit die gebruiker sodat hulle nie weet dat hulle eintlik aksies op die slagoffer-app uitvoer nie.

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

An **activity** with the **`launchMode`** set to **`singleTask` without any `taskAffinity`** defined is vulnerable to task Hijacking. This means, that an **application** can be installed and if launched before the real application it could **hijack the task of the real application** (so the user will be interacting with the **malicious application thinking he is using the real one**).

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Onveilige data-opberging

**Interne berging**

Op Android is lêers wat in interne berging gestoor word ontwerp om uitsluitlik deur die app wat dit geskep het toegangbaar te wees. Hierdie sekuriteitsmaatreël word deur die Android-bedryfstelsel afgedwing en is gewoonlik voldoende vir die sekuriteitsbehoeftes van meeste toepassings. Ontwikkelaars gebruik egter soms modi soos `MODE_WORLD_READABLE` en `MODE_WORLD_WRITABLE` om lêers tussen verskillende toepassings te deel. Hierdie modi beperk egter nie toegang tot hierdie lêers deur ander toepassings nie, insluitend potensieel kwaadwillige toepassings.

1. **Statiese Analise:**
- **Verseker** dat die gebruik van `MODE_WORLD_READABLE` en `MODE_WORLD_WRITABLE` **noukeurig ondersoek** word. Hierdie modi **kan moontlik lêers blootstel** aan **onbedoelde of ongemagtigde toegang**.
2. **Dinamiese Analise:**
- **Bevestig** die **toestemmings** op lêers wat deur die app geskep is. Kontroleer spesifiek of enige lêers **gestel is om wêreldwyd lees- of skryfbaar te wees**. Dit kan 'n beduidende sekuriteitsrisiko inhou, aangesien dit **enige toepassing** geïnstalleer op die toestel, ongeag oorsprong of bedoeling, sou toelaat om hierdie lêers te **lees of wysig**.

**Eksterne berging**

Wanneer jy met lêers op **eksterne berging** werk, soos SD-kaarte, moet sekere voorsorgmaatreëls getref word:

1. **Toeganklikheid**:
- Lêers op eksterne berging is **globaal lees- en skryfbaar**. Dit beteken enige toepassing of gebruiker kan toegang tot hierdie lêers kry.
2. **Sekuriteitskwessies**:
- Gegewe die maklike toegang, word dit aanbeveel **nie om sensitiewe inligting op eksterne berging te stoor nie**.
- Eksterne berging kan verwyder of deur enige toepassing benader word, wat dit minder veilig maak.
3. **Hanteraars van data vanaf Eksterne Berging**:
- Voer altyd **input-validasie** uit op data wat vanaf eksterne berging teruggelaai word. Dit is noodsaaklik omdat die data van 'n onbetroubare bron kom.
- Om uitvoerbare lêers of class-lêers op eksterne berging te stoor vir dinamiese laai word sterk teenwoordig.
- As jou toepassing uitvoerbare lêers van eksterne berging moet laai, maak seker dat hierdie lêers **geteken en kriptografies geverifieer** is voordat hulle dinamies gelaai word. Hierdie stap is noodsaaklik vir die behoud van die sekuriteitsintegriteit van jou toepassing.

External storage can be **accessed** in `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> Vanaf Android 4.4 (**API 17**) het die SD-kaart 'n gidsstruktuur wat **toegang van 'n app beperk tot die gids wat spesifiek vir daardie app is**. Dit verhoed dat kwaadwillige toepassings lees- of skryf toegang tot 'n ander app se lêers kry.

**Sensitiewe data gestoor in gewone teks**

- **Shared preferences**: Android laat elke toepassing maklik xml-lêers stoor in die pad `/data/data/<packagename>/shared_prefs/` en soms is dit moontlik om sensitiewe inligting in gewone teks in daardie vouer te vind.
- **Databases**: Android laat elke toepassing maklik sqlite-databasisse stoor in die pad `/data/data/<packagename>/databases/` en soms is dit moontlik om sensitiewe inligting in gewone teks in daardie vouer te vind.

### Gebroke TLS

**Aanvaar alle sertifikate**

Om een of ander rede aanvaar ontwikkelaars soms alle sertifikate, selfs al stem die hostname byvoorbeeld nie ooreen nie, met reëls kode soos die volgende:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Gebroke kriptografie

**Slegte sleutelbestuursprosesse**

Sommige ontwikkelaars stoor sensitiewe data in die plaaslike berging en enkripteer dit met 'n sleutel wat hardcoded/predictable in die kode is. Dit behoort nie gedoen te word nie aangesien 'n mate van reversing 'n aanvaller kan toelaat om die vertroulike inligting te onttrek.

**Gebruik van onveilige en/of verouderde algoritmes**

Ontwikkelaars behoort nie **verouderde algoritmes** te gebruik om authorisation **checks**, **store** of **send** data uit te voer nie. Sommige van hierdie algoritmes is: RC4, MD4, MD5, SHA1... As **hashes** byvoorbeeld gebruik word om wagwoorde te stoor, moet brute-force-weerstandige hashes met salt gebruik word.

### Ander kontroles

- Dit word aanbeveel om die **APK te obfuskateer** om die reverse engineer se werk vir aanvallers moeiliker te maak.
- As die app sensitief is (soos bank-apps), moet dit sy **eie kontroles om te sien of die mobile rooted is** uitvoer en dienooreenkomstig optree.
- As die app sensitief is (soos bank-apps), moet dit kontroleer of 'n **emulator** gebruik word.
- As die app sensitief is (soos bank-apps), moet dit **sy eie integriteit kontroleer voordat dit uitgevoer word** om te kyk of dit gewysig is.
- Gebruik [**APKiD**](https://github.com/rednaga/APKiD) om te kontroleer watter compiler/packer/obfuscator gebruik is om die APK te bou

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

Die hulpmiddel [**mariana-trench**](https://github.com/facebook/mariana-trench) is in staat om **kwesbaarhede** te vind deur die **kode** van die toepassing te **scan**. Hierdie hulpmiddel bevat 'n reeks **known sources** (wat aan die instrument aandui die **plekke** waar die **input** deur die gebruiker beheer word), **sinks** (wat die instrument aandui as **gevaarlike** **plekke** waar kwaadwillige gebruikerinput skade kan veroorsaak) en **reëls**. Hierdie reëls dui die **kombinasie** van **sources-sinks** aan wat 'n kwesbaarheid aandui.

Met hierdie kennis sal **mariana-trench die kode deurgaan en moontlike kwesbaarhede daarin vind**.

### Secrets leaked

An application may contain secrets (API keys, passwords, hidden urls, subdomains...) inside of it that you might be able to discover. You could us a tool such as [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Ander interessante funksies

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)
- In-memory native code execution via JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> First of all, you need an environment where you can install the application and all the environment (Burp CA cert, Drozer and Frida mainly). Therefore, a rooted device (emulated or not) is extremely recommended.

### Online Dynamic analysis

Jy kan 'n **gratis account** skep by: [https://appetize.io/](https://appetize.io). Hierdie platform laat jou toe om APKs **op te laai** en **uit te voer**, dus is dit nuttig om te sien hoe 'n apk optree.

Jy kan selfs die **logs van jou toepassing** op die web sien en via **adb** koppel.

![](<../../images/image (831).png>)

Danksy die ADB-verbinding kan jy **Drozer** en **Frida** binne die emulators gebruik.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (Jy kan **x86** en **arm** toestelle skep, en volgens [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**laatste x86** weergawes **support ARM libraries** sonder om 'n stadiger arm emulator nodig te hê).
- Leer hoe om dit op te stel op hierdie bladsy:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, jy moet 'n account skep. _Dit word aanbeveel om die weergawe **WITH**_ _**VirtualBox** af te laai om potensiële foute te vermy._)
- [**Nox**](https://es.bignox.com) (Gratis, maar dit ondersteun nie Frida of Drozer nie).

> [!TIP]
> Wanneer jy 'n nuwe emulator op enige platform skep, onthou dat hoe groter die skerm is, hoe stadiger sal die emulator loop. Kies dus klein skerms indien moontlik.

Om **google services** (soos AppStore) in Genymotion te installeer, moet jy op die rooi gemerkte knoppie in die volgende beeld klik:

![](<../../images/image (277).png>)

Neem ook kennis dat jy in die **konfigurasie van die Android VM in Genymotion** die **Bridge Network mode** kan kies (dit sal nuttig wees as jy vanaf 'n ander VM na die Android VM met die hulpmiddels wil koppel).

#### Gebruik 'n fisiese toestel

Jy moet die **debugging** opsies aktiveer en dit sal lekker wees as jy dit kan **root**:

1. **Settings**.
2. (FromAndroid 8.0) Kies **System**.
3. Kies **About phone**.
4. Druk **Build number** 7 keer.
5. Gaan terug en jy sal die **Developer options** vind.

> Sodra jy die toepassing geïnstalleer het, is die eerste ding wat jy moet doen om dit te probeer en ondersoek wat dit doen, hoe dit werk en gemaklik te raak daarmee.\
> Ek stel voor om **hierdie aanvanklike dynamic analysis met MobSF dynamic analysis + pidcat** uit te voer, sodat ons kan **leer hoe die toepassing werk** terwyl MobSF baie **interessante** **data** vasvang wat jy later kan hersien.

Magisk/Zygisk vinnige opmerkings (aanbeveel op Pixel-toestelle)
- Patch boot.img met die Magisk app en flash via fastboot om systemless root te kry
- Aktiveer Zygisk + DenyList vir root hiding; oorweeg LSPosed/Shamiko wanneer sterk root hiding nodig is
- Hou die oorspronklike boot.img om van OTA-opdaterings te herstel; her-patch na elke OTA
- Vir skermspieël, gebruik scrcpy op die host



### Onbedoelde data leak

**Logging**

Ontwikkelaars moet versigtig wees om **debugging-inligting** publiek bloot te stel, aangesien dit tot sensitiewe data leak kan lei. Die hulpmiddels [**pidcat**](https://github.com/JakeWharton/pidcat) en `adb logcat` word aanbeveel om toepassingslogs te monitor en sensitiewe inligting te identifiseer en te beskerm. **Pidcat** word bevoordeel vir sy gemak van gebruik en leesbaarheid.

> [!WARNING]
> Let wel dat vanaf **later newer than Android 4.0**, **applications are only able to access their own logs**. So applications cannot access other apps logs.\
> Evensa, dit word steeds aanbeveel om **nie sensitiewe inligting te log nie**.

**Kopieer/Plak buffer caching**

Android se **clipboard-based** raamwerk maak copy-paste-funksionaliteit in apps moontlik, maar stel 'n risiko omdat **ander applications** die clipboard kan **access**, wat sensitiewe data kan blootstel. Dit is noodsaaklik om copy/paste-funksies vir sensitiewe gedeeltes van 'n toepassing, soos kredietkaartbesonderhede, te deaktiveer om data leaks te voorkom.

**Crash Logs**

As 'n toepassing **crash** en **logs stoor**, kan hierdie logs aanvallers help, veral wanneer die toepassing nie gerugsteun kan word nie. Om hierdie risiko te verminder, moet daar nie op crashes gelog word nie, en as logs oor die netwerk gestuur moet word, moet dit via 'n SSL-kanaal gestuur word vir sekuriteit.

As pentester, **probeer om na hierdie logs te kyk**.

**Analytics Data Sent To 3rd Parties**

Toepassings integreer dikwels dienste soos Google Adsense, wat per ongeluk sensitiewe data kan leak weens onvanpaste implementering deur ontwikkelaars. Om potensiële data leaks te identifiseer, is dit raadsaam om die toepassing se verkeer te onderskep en te kontroleer of enige sensitiewe inligting na derdepartye gestuur word.

### SQLite DBs

Die meeste toepassings sal **internal SQLite databases** gebruik om inligting te stoor. Tydens die pentest kyk na die **databases** wat geskep is, die name van **tables** en **columns** en al die **data** wat gestoor is omdat jy sensitiewe inligting kan vind (wat 'n kwesbaarheid sal wees).\
Databases behoort te wees geleë in `/data/data/the.package.name/databases` soos `/data/data/com.mwr.example.sieve/databases`

As die databasis vertroulike inligting stoor en dit is **encrypted** maar jy kan die **password** binne die toepassing vind, is dit steeds 'n **kwesbaarheid**.

Eerste verken die tabelle met `.tables` en verken die kolomme van die tabelle met `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer is 'n nuttige hulpmiddel om **exported activities, exported services and Content Providers** te **exploit** soos jy in die volgende afdelings sal leer.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Onthou ook dat die kode van 'n activity begin in die **`onCreate`** metode.

**Authorisation bypass**

Wanneer 'n Activity exported is, kan jy sy skerm vanaf 'n eksterne app aanroep. Daarom, as 'n activity met **sensitiewe inligting** exported is, kan jy die **authentication** meganismes **bypass** om toegang daartoe te kry.

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

Jy kan ook 'n exported activity vanaf adb start:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> Let wel: 'n authorisation bypass is nie altyd 'n kwesbaarheid nie; dit hang af van hoe die bypass werk en watter inligting blootgestel word.

**Sensitive information leakage**

**Activities can also return results**. If you manage to find an exported and unprotected activity calling the **`setResult`** method and **returning sensitive information**, daar is 'n lekkasie van sensitiewe inligting.

#### Tapjacking

As Tapjacking nie voorkom word nie, kan jy die exported activity misbruik om die gebruiker onverwagte aksies te laat uitvoer. For more info about [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers word in wese gebruik om **data te deel**. As 'n app beskikbare content providers het, kan jy dalk **sensitiewe data** daaruit onttrek. Dit is ook interessant om moontlike **SQL injections** en **Path Traversals** te toets aangesien hulle kwesbaar kan wees.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Onthou dat die aksies van 'n Service begin in die metode `onStartCommand`.

'n Service is basies iets wat **data kan ontvang**, dit kan **verwerk** en (al dan nie) 'n reaksie **teruggee**. As 'n aplikasie sekere services exporteer, moet jy die **code** nagaan om te verstaan wat dit doen en dit **dynamies** toets om vertroulike inligting te onttrek, en om moontlike authentication-maatreëls te omseil...\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Onthou dat die aksies van 'n Broadcast Receiver begin in die metode `onReceive`.

'n Broadcast receiver sal wag vir 'n tipe boodskap. Afhangend van hoe die receiver die boodskap hanteer, kan dit kwesbaar wees.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

You can look for deep links manually, using tools like MobSF or scripts like [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Jy kan 'n gedeclareerde **scheme** oopmaak met **adb** of 'n **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Let daarop dat jy die **package name** kan weglaat en die mobiele toestel sal outomaties die app oproep wat daardie skakel behoort oop te maak._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Kode uitgevoer**

Om die **kode wat in die App uitgevoer sal word** te vind, gaan na die activity wat deur die deeplink aangeroep word en soek die funksie **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Sensitiewe inligting**

Elke keer as jy 'n deep link vind, kontroleer dat **dit nie sensitiewe data (soos wagwoorde) via URL parameters ontvang nie**, want enige ander toepassing kan **die deep link nadoen en daardie data steel!**

**Parameters in pad**

Jy **moet ook kontroleer of enige deep link 'n parameter binne die pad gebruik** van die URL soos: `https://api.example.com/v1/users/{username}`, in daardie geval kan jy 'n path traversal afdwing deur toegang te kry tot iets soos: `example://app/users?username=../../unwanted-endpoint%3fparam=value`.\
Let wel dat as jy die korrekte endpoints in die toepassing vind, jy moontlik 'n **Open Redirect** kan veroorsaak (as 'n deel van die pad as domeinnaam gebruik word), **account takeover** (as jy gebruikersbesonderhede kan wysig sonder 'n CSRF-token en die kwesbare endpoint die regte metode gebruik) en enige ander vuln. Meer [info hieroor](http://dphoeniixx.com/2020/12/13-2/).

**Meer voorbeelde**

'n [Interessante bug bounty-verslag](https://hackerone.com/reports/855618) oor links (_/.well-known/assetlinks.json_).

### Transport Layer Inspection and Verification Failures

- **Sertifikate word nie altyd behoorlik geïnspekteer nie** deur Android-toepassings. Dit is algemeen dat hierdie toepassings waarskuwings ignoreer en self-ondertekende sertifikate aanvaar of, in sommige gevalle, terugval na die gebruik van HTTP-verbindinge.
- **Onderhandelinge tydens die SSL/TLS-handshake is soms swak**, en gebruik onveilige cipher suites. Hierdie kwesbaarheid maak die verbinding vatbaar vir man-in-the-middle (MITM)-aanvalle, wat aanvallers toelaat om die data te ontsleutel.
- **Leakage of private information** is 'n risiko wanneer toepassings via veilige kanale verifieer, maar dan oor onveilige kanale kommunikeer vir ander transaksies. Hierdie benadering misluk om sensitiewe data, soos session cookies of gebruikersbesonderhede, te beskerm teen onderskep deur kwaadwilliges.

#### Certificate Verification

Ons sal fokus op **sertifikaatverifikasie**. Die integriteit van die bediener se sertifikaat moet geverifieer word om sekuriteit te verbeter. Dit is van kritiek belang aangesien onveilige TLS-konfigurasies en die oordrag van sensitiewe data oor on-gekodeerde kanale beduidende risiko's kan inhou. Vir gedetailleerde stappe oor die verifiëring van bediener-sertifikate en die aanspreek van kwesbaarhede, bied [**hierdie hulpbron**](https://manifestsecurity.com/android-application-security-part-10/) omvattende leiding.

#### SSL Pinning

SSL Pinning is 'n sekuriteitsmaatreël waar die toepassing die bediener se sertifikaat verifieer teen 'n bekende kopie wat binne die toepassing self gestoor is. Hierdie metode is noodsaaklik om MITM-aanvalle te voorkom. Die implementering van SSL Pinning word sterk aanbeveel vir toepassings wat sensitiewe inligting hanteer.

#### Traffic Inspection

Om HTTP-verkeer te inspekteer, is dit nodig om die **proxy tool's certificate** te installeer (bv. Burp). Sonder die installasie van hierdie sertifikaat mag gekodeerde verkeer nie via die proxy sigbaar wees nie. Vir 'n gids oor die installering van 'n pasgemaakte CA-sertifikaat, [**klik hier**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Toepassings wat gemik is op **API Level 24 and above** vereis wysigings aan die Network Security Config om die proxy se CA-sertifikaat te aanvaar. Hierdie stap is kritiek vir die inspeksie van gekodeerde verkeer. Vir instrukies oor die wysiging van die Network Security Config, [**verwys na hierdie tutorial**](make-apk-accept-ca-certificate.md).

As **Flutter** gebruik word, moet jy die instruksies op [**hierdie bladsy**](flutter.md) volg. Dit is omdat net die sertifikaat by die store voeg nie sal werk nie, aangesien Flutter sy eie lys geldige CAs het.

#### Static detection of SSL/TLS pinning

Voordat jy runtime bypasses probeer, karteer vinnig waar pinning in die APK afgedwing word. Statiese ontdekking help jou om hooks/patches te beplan en te fokus op die regte kodepaaie.

Tool: SSLPinDetect
- Open-source statiese-analise nutsding wat die APK na Smali (via apktool) decompileer en vir gespesialiseerde regex-patroone van SSL/TLS pinning-implementasies deursoek.
- Rapporteer die presiese lêerpad, lynnommer en 'n kodefragment vir elke treffers.
- Dek algemene frameworks en pasgemaakte kodepaaie: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init met custom TrustManagers/KeyManagers, en Network Security Config XML pins.

Installeer
- Vereistes: Python >= 3.8, Java op PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Gebruik
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Voorbeeld patroonreëls (JSON)
Gebruik of brei signatures uit om proprietary/custom pinning styles te detecteer. Jy kan jou eie JSON laai en op groot skaal skandeer.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes and tips
- Vinnige skandering van groot apps via multi-threading en memory-mapped I/O; vooraf-gekompileerde regex verminder overhead/false positives.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Tipiese deteksie-teikens om daarna te triage:
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Deklaratiewe pins in res/xml network security config en manifest references
- Gebruik die ooreenstemmende plekke om Frida hooks, statiese patches, of config reviews te beplan voordat jy dinamiese toetsing doen.



#### Omseiling van SSL Pinning

Wanneer SSL Pinning geïmplementeer is, word dit noodsaaklik om dit te omseil om HTTPS-verkeer te inspekteer. Verskeie metodes is beskikbaar vir hierdie doel:

- Automatically **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Die grootste voordeel van hierdie opsie is dat jy nie 'root' nodig het om die SSL Pinning te omseil nie, maar jy sal die toepassing moet verwyder en die nuwe een moet herinstalleer, en dit sal nie altyd werk nie.
- Jy kan **Frida** gebruik (bespreek hieronder) om hierdie beskerming te omseil. Hier is 'n gids om Burp+Frida+Genymotion te gebruik: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Jy kan ook probeer om **outomaties SSL Pinning te omseil** met [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Jy kan ook probeer om **outomaties SSL Pinning te omseil** met **MobSF dynamic analysis** (hieronder verduidelik)
- As jy steeds dink daar is verkeer wat jy nie vang nie, kan jy probeer om die verkeer na Burp te stuur met iptables. Lees hierdie blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Soek na algemene web-kwesbaarhede

Dit is ook belangrik om binne die toepassing na algemene web-kwesbaarhede te soek. Gedetailleerde inligting oor die identifisering en mitigering van hierdie kwesbaarhede val buite die bestek van hierdie samevatting, maar word elders deeglik behandel.

### Frida

[Frida](https://www.frida.re) is 'n dinamiese instrumenterings-toolkit vir ontwikkelaars, reverse-engineers, en sekuriteitsnavorsers.\
**Jy kan toegang kry tot 'n lopende toepassing en hook methods op runtime om die gedrag te verander, waardes te verander, waardes te onttrek, verskillende kode uit te voer...**\
As jy Android-toepassings wil pentest, moet jy weet hoe om Frida te gebruik.

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Some "GUI" for actions with Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- You can find some Awesome Frida scripts here: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Probeer om anti-debugging / anti-frida-meganismes te omseil deur Frida te laai soos aangedui in [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentasie & SSL pinning omseil-werkvloei

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

Kontroleer of die toepassing sensitiewe inligting in die geheue stoor wat dit nie behoort te stoor nie, soos wagwoorde of mnemonics.

Deur [**Fridump3**](https://github.com/rootbsd/fridump3) te gebruik, kan jy die geheue van die app dump met:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Dit sal die memory na die ./dump folder dump, en daarbinne kan jy met iets soos grep:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Sensitiewe data in Keystore**

In Android is die Keystore die beste plek om sensitiewe data te stoor, maar met voldoende voorregte is dit steeds **moontlik om toegang daartoe te kry**. Omdat toepassings geneig is om hier **sensitiewe data in duidelike teks** te stoor, behoort pentests dit te kontroleer aangesien 'n root user of iemand met fisiese toegang tot die toestel hierdie data kan steel.

Selfs as 'n app data in die keystore stoor, behoort die data versleuteld te wees.

Om toegang tot die data binne die keystore te kry, kan jy hierdie Frida script gebruik: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Met die volgende Frida-script kan dit moontlik wees om die **bypass fingerprint authentication** wat Android-toepassings dalk uitvoer om sekere sensitiewe gebiede te beskerm:
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Agtergrondbeelde**

Wanneer jy 'n toepassing in die agtergrond plaas, stoor Android 'n **snapshot van die toepassing**, sodat wanneer dit na die voorgrond herstel word dit eers die beeld laai voordat die app self gelaai word, en dit lyk asof die app vinniger gelaai is.

Indien hierdie snapshot egter **gevoelige inligting** bevat, kan iemand met toegang tot die snapshot daardie inligting **steel** (let daarop dat jy root nodig het om toegang daartoe).

Die snapshots word gewoonlik gestoor by: **`/data/system_ce/0/snapshots`**

Android bied 'n manier om **die vang van skermskote te voorkom deur die FLAG_SECURE** layout-parameter te stel. Deur hierdie vlag te gebruik, word die vensterinhoud as veilig beskou, wat voorkom dat dit in skermskote verskyn of op nie-veilige vertonings besigtig word.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Hierdie hulpmiddel kan jou help om verskillende tools tydens dinamiese analise te bestuur: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Ontwikkelaars skep dikwels proxy-komponente soos activities, services, en broadcast receivers wat hierdie Intents hanteer en dit aan metodes soos `startActivity(...)` of `sendBroadcast(...)` deurgee, wat riskant kan wees.

Die gevaar lê in die toestaan dat aanvallers nie-geëksporteerde app-komponente of sensitiewe content providers kan aktiveer deur hierdie Intents verkeerd te lei. 'n Merkwaardige voorbeeld is die `WebView`-komponent wat URL's na `Intent`-objekte omskakel via `Intent.parseUri(...)` en dit dan uitvoer, wat moontlik tot malicious Intent injections kan lei.

### Belangrike punte

- **Intent Injection** is soortgelyk aan die web se Open Redirect-kwessie.
- Eksploite behels die deurgee van `Intent`-objekte as extras, wat omgerig kan word om onveilige operasies uit te voer.
- Dit kan nie-geëksporteerde komponente en content providers aan aanvallers blootstel.
- Die omskakeling van URL na `Intent` deur `WebView` kan onbedoelde aksies fasiliteer.

### Android Client Side Injections and others

Jy ken waarskynlik hierdie tipe kwesbaarhede van die web. Wees spesiaal versigtig met hierdie kwesbaarhede in 'n Android-toepassing:

- **SQL Injection:** Wanneer jy met dinamiese navrae of Content-Providers werk, sorg dat jy geparameteriseerde navrae gebruik.
- **JavaScript Injection (XSS):** Kontroleer dat JavaScript- en plugin-ondersteuning vir enige WebViews gedeaktiveer is (gedeaktiveer per verstek). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews behoort geen toegang tot die lêerstelsel te hê nie (toegelaat per verstek) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: In verskeie gevalle, wanneer die Android-toepassing die sessie beëindig, word die cookie nie herroep nie of dit kan selfs op skyf gestoor word
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Outomatiese Analise

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Statiese analise**

![](<../../images/image (866).png>)

**Kwetsbaarheidsassessering van die toepassing** met 'n netjiese web-gebaseerde frontend. Jy kan ook dinamiese analise uitvoer (maar jy moet die omgewing voorberei).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Let wel dat MobSF **Android**(apk)**, IOS**(ipa) **en Windows**(apx) toepassings kan ontleed (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
As jy ook 'n **ZIP**-lêer met die bronkode van 'n **Android** of **IOS** app skep (gaan na die root-lêergids van die toepassing, kies alles en skep 'n ZIPfile), kan dit dit ook ontleed.

MobSF laat jou ook toe om **diff/Compare** ontledings te doen en om **VirusTotal** te integreer (jy sal jou API-sleutel in _MobSF/settings.py_ moet instel en dit aktiveer: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). Jy kan ook `VT_UPLOAD` op `False` stel; dan sal die **hash** in plaas van die lêer **upload**.

### Geassisteerde dinamiese ontleding met MobSF

**MobSF** kan ook baie nuttig wees vir dinamiese ontleding op **Android**, maar in daardie geval moet jy MobSF en **genymotion** op jou gasheer installeer (a VM or Docker won't work). _Nota: Jy moet eers **start first a VM in genymotion** en **then MobSF.**_\
Die **MobSF dynamic analyser** kan:

- **Dump application data** (URLs, logs, clipboard, skermkiekies wat jy neem, skermkiekies gemaak deur "**Exported Activity Tester**", e-posse, SQLite databasisse, XML-lêers, en ander geskepte lêers). Dit gebeur alles outomaties behalwe vir die skermkiekies; jy moet die knoppie druk wanneer jy 'n skermkiekie wil hê of jy moet "**Exported Activity Tester**" druk om skermkiekies van al die exported activities te bekom.
- Capture **HTTPS traffic**
- Gebruik **Frida** om **runtime information** te bekom

Vanaf Android **versions > 5**, sal dit **automatically start Frida** en globale **proxy**-instellings opstel om verkeer te **capture**. Dit sal slegs verkeer van die getoetste toepassing vasvang.

**Frida**

By verstek sal dit ook sommige Frida-skripte gebruik om **bypass SSL pinning**, **root detection** en **debugger detection** te omseil en om interessante APIs te monitor.\
MobSF kan ook **invoke exported activities**, **grab screenshots** daarvan en dit **save** vir die verslag.

Om die dinamiese toetsing te **start** druk die groen knoppie: "**Start Instrumentation**". Druk die "**Frida Live Logs**" om die logs wat deur die Frida-skripte gegenereer word te sien en "**Live API Monitor**" om al die aanroepe na gehookte metodes, argumente wat deurgegee is en teruggegewe waardes te sien (dit sal verskyn nadat jy "Start Instrumentation" gedruk het).\
MobSF laat jou ook toe om jou eie **Frida scripts** te laai (om die resultate van jou Frida-skripte aan MobSF te stuur gebruik die funksie `send()`). Dit het ook **verskeie vooraf-geskrewe skripte** wat jy kan laai (jy kan meer byvoeg in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), kies net **select them**, druk "**Load**" en druk "**Start Instrumentation**" (jy sal die logs van daardie skripte binne "**Frida Live Logs**" kan sien).

![](<../../images/image (419).png>)

Verder het jy 'n paar bykomende Frida-funksies:

- **Enumerate Loaded Classes**: Dit sal al die gelaaide klasse vertoon
- **Capture Strings**: Dit sal al die opgevang stringe vertoon terwyl jy die toepassing gebruik (baie lawaaierig)
- **Capture String Comparisons**: Dit kan baie nuttig wees. Dit sal **wys die 2 strings wat vergelyk word** en of die resultaat True of False was.
- **Enumerate Class Methods**: Sit die klassenaam (soos "java.io.File") en dit sal al die metodes van die klas vertoon.
- **Search Class Pattern**: Soek klasse volgens patroon
- **Trace Class Methods**: **Trace** 'n **hele klas** (sien insette en uitsette van alle metodes van die klas). Onthou dat MobSF standaard verskeie interessante Android Api-metodes trace.

Sodra jy die bykomende module gekies het wat jy wil gebruik, moet jy op "**Start Intrumentation**" druk en jy sal al die uitsette in "**Frida Live Logs**" sien.

**Shell**

MobSF bied ook 'n shell met 'n paar **adb** commands, **MobSF commands**, en algemene **shell** **commands** onderaan die dinamiese analise-blad. Sommige interessante opdragte:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP gereedskap**

Wanneer HTTP-verkeer vasgevang word, kan jy 'n lelike uitsig van die vasgevangde verkeer in die "**HTTP(S) Traffic**" onderaan sien of 'n netter uitsig deur die groen knop "**Start HTTPTools**". Vanaf die tweede opsie kan jy die **vasgevangde versoeke** na **proxies** soos Burp of Owasp ZAP **stuur**.\
Om dit te doen, _skakel Burp aan -->_ _skakel Intercept af --> in MobSB HTTPTools kies die versoek_ --> druk "**Send to Fuzzer**" --> _kies die proxy-adres_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Sodra jy die dinamiese ontleding met MobSF voltooi het, kan jy op "**Start Web API Fuzzer**" druk om **fuzz HTTP-versoeke** en na kwesbaarhede te soek.

> [!TIP]
> Na 'n dinamiese ontleding met MobSF kan die proxy-instellings verkeerd gekonfigureer wees en jy sal dit nie via die GUI kan regmaak nie. Jy kan die proxy-instellings regmaak deur:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Geassisteerde dinamiese ontleding met Inspeckage

Jy kan die hulpmiddel kry by [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Hierdie hulpmiddel gebruik sekere **Hooks** om jou te laat weet **wat in die toepassing gebeur** terwyl jy 'n **dinamiese ontleding** doen.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Dit is 'n **geweldige hulpmiddel om statiese ontleding met 'n GUI uit te voer**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Hierdie hulpmiddel is ontwerp om na verskeie **veiligheidsverwante Android-toepassingskwesbaarhede** te soek, óf in **bronkode** óf in **gepakte APKs**. Die hulpmiddel is ook **in staat om 'n "Proof-of-Concept" deployable APK te skep** en **ADB-opdragte**, om sommige van die gevonde kwesbaarhede te benut (Exposed activities, intents, tapjacking...). Soos met Drozer, hoef die toetstoestel nie geroot te wees nie.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Wys alle uitgehaalde lêers vir maklike verwysing
- Decompileer APK-lêers outomaties na Java- en Smali-formaat
- Ontleed AndroidManifest.xml vir algemene vulnerabilities en gedrag
- Statiese source code-analise vir algemene vulnerabilities en gedrag
- Toestelinligting
- en meer
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER is 'n command-line toepassing wat in Windows, MacOS X en Linux gebruik kan word en _.apk_ lêers ontleed op soek na kwetsbaarhede. Dit doen dit deur APKs te ontpak en 'n reeks reëls toe te pas om daardie kwetsbaarhede op te spoor.

Alle reëls is gesentraliseer in 'n `rules.json`-lêer, en elke maatskappy of toetser kan hul eie reëls skep om te ontleed wat hulle benodig.

Laai die nuutste binaries af vanaf die [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn is a **platformonafhanklike** hulpmiddel wat ontwikkelaars, bugbounty hunters en ethical hackers help met [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) van mobiele toepassings.

Die konsep is dat jy jou mobiele toepassingslêer ('.apk' of '.ipa' lêer) op die StaCoAn-toepassing sleep en laat val, en dit sal 'n visuele en draagbare verslag vir jou genereer. Jy kan die instellings en wordlists aanpas om 'n aangepaste ervaring te kry.

Laai af[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework is 'n Android-kwetsbaarheidsanalise-stelsel wat ontwikkelaars of hackers help om potensiële sekuriteitskwetsbaarhede in Android-toepassings te vind.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** is 'n hulpmiddel met die hoofdoel om die gebruiker te help om potensieel kwaadwillige gedrag wat deur 'n Android-toepassing ontwikkel is, op te spoor en te waarsku.

Die opsporing word uitgevoer deur middel van die **static analysis** van die toepassing se Dalvik bytecode, voorgestel as **Smali**, met die [`androguard`](https://github.com/androguard/androguard) biblioteek.

Hierdie instrument soek na **algemene gedrag van "slegte" toepassings** soos: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. Dit is 'n instrument wat algemeen gebruikte mobile application reverse engineering and analysis tools bymekaar sit om te help met die toetsing van mobile applications teen OWASP mobile security threats. Die doel is om hierdie taak makliker en meer gebruikersvriendelik te maak vir mobile application developers en security professionals.

It is able to:

- Extract Java and Smali code using different tools
- Analyze APKs using: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Extract private information from the APK using regexps.
- Analyze the Manifest.
- Analyze found domains using: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Nuttig om malware op te spoor: [https://koodous.com/](https://koodous.com)

## Obfuscating/Deobfuscating code

Let wel dat, afhangend van die diens en die konfigurasie wat jy gebruik om die code te obfuscate, kan geheime wel of nie obfuscated eindig nie.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is 'n open source command-line tool wat Java-kode shrink, optimize en obfuscate. Dit kan bytecode optimaliseer asook ongebruikte instrukies opspoor en verwyder. ProGuard is gratis sagteware en word versprei onder die GNU General Public License, weergawe 2.

ProGuard word versprei as deel van die Android SDK en loop wanneer die toepassing in release mode gebou word.

### [DexGuard](https://www.guardsquare.com/dexguard)

Vind 'n stap-vir-stap gids om die apk te deobfuscate by [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Last time we checked, the Dexguard mode of operation was:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

Jy kan 'n obfuscated APK na hul platform upload.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

Dit is 'n LLM tool om enige potensiële security vulnerabilities in android apps te vind en om android app code te deobfuscate. Gebruik Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

Dit is 'n generic android deobfuscator. Simplify voer 'n app practically uit om die gedrag daarvan te verstaan en probeer dan die code optimaliseer sodat dit identies optree maar makliker is vir 'n mens om te verstaan. Elke optimaliseringstipe is eenvoudig en generies, so dit maak nie saak watter spesifieke tipe obfuscation gebruik word nie.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD gee jou inligting oor hoe 'n APK gemaak is. Dit identifiseer baie compilers, packers, obfuscators, en ander vreemde goed. Dit is die [_PEiD_](https://www.aldeid.com/wiki/PEiD) vir Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b is 'n Android security virtual machine gebaseer op ubuntu-mate wat 'n versameling van die nuutste framework, tutorials en labs van verskeie security geeks en navorsers vir reverse engineering en malware analysis insluit.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Dit is 'n uitstekende lys hulpbronne
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android vinnige kursus
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
