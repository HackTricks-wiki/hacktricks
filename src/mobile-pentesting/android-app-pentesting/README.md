# Android Uygulamaları Pentesting

{{#include ../../banners/hacktricks-training.md}}

<figure><img src="../../images/image (3).png" alt=""><figcaption></figcaption></figure>

Deneyimli hackerlar ve bug bounty avcıları ile iletişim kurmak için [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) sunucusuna katılın!

**Hacking İçgörüleri**\
Hacking'in heyecanı ve zorluklarına dalan içeriklerle etkileşimde bulunun

**Gerçek Zamanlı Hack Haberleri**\
Gerçek zamanlı haberler ve içgörülerle hızlı tempolu hacking dünyasında güncel kalın

**Son Duyurular**\
Yeni başlayan bug bounty'ler ve önemli platform güncellemeleri hakkında bilgi sahibi olun

Bugün [**Discord**](https://discord.com/invite/N3FrSbmwdy) üzerinden bize katılın ve en iyi hackerlarla işbirliği yapmaya başlayın!

## Android Uygulamaları Temelleri

**Android güvenliği ile ilgili en önemli kısımlar ve bir Android uygulamasındaki en tehlikeli bileşenler** hakkında bilgi edinmek için bu sayfayı okumaya başlamanız şiddetle tavsiye edilir:

{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Bu, bir android cihazına (emüle edilmiş veya fiziksel) bağlanmak için ihtiyaç duyduğunuz ana araçtır.\
**ADB**, cihazları bir bilgisayardan **USB** veya **Ağ** üzerinden kontrol etmeyi sağlar. Bu yardımcı program, dosyaların her iki yönde **kopyalanmasını**, uygulamaların **yüklenmesini** ve **kaldırılmasını**, shell komutlarının **çalıştırılmasını**, verilerin **yedeklenmesini**, **logların okunmasını** ve diğer işlevleri sağlar.

ADB'yi nasıl kullanacağınızı öğrenmek için aşağıdaki [**ADB Komutları**](adb-commands.md) listesine göz atın.

## Smali

Bazen **gizli bilgilere** erişmek için **uygulama kodunu değiştirmek** ilginç olabilir (belki iyi obfuscate edilmiş şifreler veya bayraklar). Bu durumda, apk'yı decompile etmek, kodu değiştirmek ve yeniden derlemek ilginç olabilir.\
[**Bu eğitimde** APK'yı nasıl decompile edeceğinizi, Smali kodunu nasıl değiştireceğinizi ve APK'yı yeni işlevsellik ile nasıl yeniden derleyeceğinizi **öğrenebilirsiniz**](smali-changes.md). Bu, sunulacak dinamik analiz sırasında birkaç test için **alternatif olarak** çok faydalı olabilir. Bu nedenle, **her zaman bu olasılığı aklınızda bulundurun**.

## Diğer ilginç ipuçları

- [Play Store'da konumunuzu sahteleyin](spoofing-your-location-in-play-store.md)
- **APK'ları İndirin**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Cihazdan APK çıkarın:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Tüm bölümleri ve temel apk'ları [APKEditor](https://github.com/REAndroid/APKEditor) ile birleştirin:
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Statik Analiz

Öncelikle, bir APK'yı analiz etmek için **Java koduna göz atmalısınız** bir dekompiler kullanarak.\
Lütfen, [**farklı mevcut dekompilerler hakkında bilgi bulmak için burayı okuyun**](apk-decompilers.md).

### İlginç Bilgiler Aramak

APK'nın **string'lerine** bakarak **şifreler**, **URL'ler** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** anahtarları, **şifreleme**, **bluetooth uuids**, **token'lar** ve ilginç herhangi bir şey arayabilirsiniz... hatta kod yürütme **arka kapıları** veya kimlik doğrulama arka kapıları (uygulama için hardcoded admin kimlik bilgileri) arayın.

**Firebase**

**firebase URL'lerine** özel dikkat gösterin ve kötü yapılandırılıp yapılandırılmadığını kontrol edin. [Firebase nedir ve nasıl istismar edilir hakkında daha fazla bilgi burada.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Uygulamanın Temel Anlayışı - Manifest.xml, strings.xml

Bir uygulamanın **_Manifest.xml**_\*\* ve \*\*_**strings.xml**\_\*\* dosyalarının incelenmesi potansiyel güvenlik açıklarını ortaya çıkarabilir\*\*. Bu dosyalara dekompilerler kullanarak veya APK dosya uzantısını .zip olarak değiştirip ardından açarak erişilebilir.

**Manifest.xml** dosyasından tespit edilen **açıklar** şunlardır:

- **Debuggable Uygulamalar**: _Manifest.xml_ dosyasında debuggable olarak ayarlanmış (`debuggable="true"`) uygulamalar, bağlantılara izin vererek istismar riskini artırır. Debuggable uygulamaları nasıl istismar edeceğinizi anlamak için bir cihazda debuggable uygulamaları bulma ve istismar etme üzerine bir eğitime başvurun.
- **Yedekleme Ayarları**: Hassas bilgilerle ilgilenen uygulamalar için `android:allowBackup="false"` niteliği açıkça ayarlanmalıdır, böylece adb üzerinden yetkisiz veri yedeklemeleri önlenir, özellikle usb hata ayıklama etkinleştirildiğinde.
- **Ağ Güvenliği**: _res/xml/_ içindeki özel ağ güvenliği yapılandırmaları (`android:networkSecurityConfig="@xml/network_security_config"`) sertifika pinleri ve HTTP trafiği ayarları gibi güvenlik detaylarını belirtebilir. Örneğin, belirli alanlar için HTTP trafiğine izin vermek.
- **Dışa Aktarılan Aktiviteler ve Servisler**: Manifestte dışa aktarılan aktiviteleri ve servisleri tanımlamak, kötüye kullanılabilecek bileşenleri vurgulayabilir. Dinamik test sırasında daha fazla analiz, bu bileşenleri nasıl istismar edeceğinizi ortaya çıkarabilir.
- **İçerik Sağlayıcıları ve FileProviders**: Açıkta olan içerik sağlayıcıları, yetkisiz erişim veya veri değişikliği sağlayabilir. FileProviders'ın yapılandırması da incelenmelidir.
- **Broadcast Alıcıları ve URL Şemaları**: Bu bileşenler istismar için kullanılabilir, URL şemalarının giriş açıkları için nasıl yönetildiğine özel dikkat gösterilmelidir.
- **SDK Versiyonları**: `minSdkVersion`, `targetSDKVersion` ve `maxSdkVersion` nitelikleri desteklenen Android sürümlerini gösterir, güvenlik nedenleriyle eski, savunmasız Android sürümlerinin desteklenmemesinin önemini vurgular.

**strings.xml** dosyasından, API anahtarları, özel şemalar ve diğer geliştirici notları gibi hassas bilgiler keşfedilebilir, bu da bu kaynakların dikkatli bir şekilde gözden geçirilmesi gereğini vurgular.

### Tapjacking

**Tapjacking**, **kötü niyetli** bir **uygulamanın** başlatıldığı ve **bir kurban uygulamasının üzerine yerleştirildiği** bir saldırıdır. Kurban uygulamasını görünür bir şekilde gizlediğinde, kullanıcı arayüzü, kullanıcının onunla etkileşimde bulunmasını sağlamak için tasarlanmıştır, bu arada etkileşimi kurban uygulamasına iletmektedir.\
Sonuç olarak, bu, **kullanıcının aslında kurban uygulamasında eylemler gerçekleştirdiğini bilmesini engellemektedir**.

Daha fazla bilgi için:

{{#ref}}
tapjacking.md
{{#endref}}

### Görev Ele Geçirme

**`launchMode`**'u **`singleTask`** olarak ayarlanmış ve herhangi bir `taskAffinity` tanımlanmamış bir **aktivite**, görev ele geçirmeye karşı savunmasızdır. Bu, bir **uygulamanın** kurulabileceği ve gerçek uygulamadan önce başlatılırsa, **gerçek uygulamanın görevini ele geçirebileceği** anlamına gelir (bu durumda kullanıcı, **kötü niyetli uygulama ile etkileşimde bulunurken gerçek uygulamayı kullanıyormuş gibi düşünecektir**).

Daha fazla bilgi için:

{{#ref}}
android-task-hijacking.md
{{#endref}}

### Güvensiz Veri Depolama

**Dahili Depolama**

Android'de, **dahili** depolamada **saklanan** dosyalar yalnızca **oluşturan** **uygulama** tarafından **erişilebilir** olacak şekilde **tasarlanmıştır**. Bu güvenlik önlemi, Android işletim sistemi tarafından **uygulanır** ve genellikle çoğu uygulamanın güvenlik ihtiyaçları için yeterlidir. Ancak, geliştiriciler bazen `MODE_WORLD_READABLE` ve `MODE_WORLD_WRITABLE` gibi modları kullanarak dosyaların farklı uygulamalar arasında **paylaşılmasına** izin verirler. Ancak, bu modlar diğer uygulamalar, potansiyel olarak kötü niyetli olanlar da dahil olmak üzere, bu dosyalara erişimi **kısıtlamaz**.

1. **Statik Analiz:**
- `MODE_WORLD_READABLE` ve `MODE_WORLD_WRITABLE` kullanımının **dikkatlice incelenmesini** sağlayın. Bu modlar, dosyaları **istenmeyen veya yetkisiz erişime** açabilir.
2. **Dinamik Analiz:**
- Uygulama tarafından oluşturulan dosyaların üzerindeki **izinleri** **doğrulayın**. Özellikle, herhangi bir dosyanın **dünya çapında okunabilir veya yazılabilir** olarak ayarlanıp ayarlanmadığını **kontrol edin**. Bu, cihazda yüklü olan **herhangi bir uygulamanın**, kökeni veya niyeti ne olursa olsun, bu dosyaları **okumasına veya değiştirmesine** izin vereceğinden önemli bir güvenlik riski oluşturabilir.

**Harici Depolama**

**Harici depolama** ile ilgili dosyalarla çalışırken, belirli önlemler alınmalıdır:

1. **Erişilebilirlik**:
- Harici depolamadaki dosyalar **genel olarak okunabilir ve yazılabilir**. Bu, herhangi bir uygulamanın veya kullanıcının bu dosyalara erişebileceği anlamına gelir.
2. **Güvenlik Endişeleri**:
- Erişimin kolaylığı göz önüne alındığında, **hassas bilgileri** harici depolamada saklamamanız önerilir.
- Harici depolama, herhangi bir uygulama tarafından çıkarılabilir veya erişilebilir, bu da onu daha az güvenli hale getirir.
3. **Harici Depolamadan Veri İşleme**:
- Harici depolamadan alınan veriler üzerinde her zaman **giriş doğrulaması** yapın. Bu, verilerin güvenilir bir kaynaktan gelmediği için kritik öneme sahiptir.
- Dinamik yükleme için harici depolamada yürütülebilir veya sınıf dosyaları saklamak kesinlikle önerilmez.
- Uygulamanız harici depolamadan yürütülebilir dosyaları almak zorundaysa, bu dosyaların dinamik olarak yüklenmeden önce **imzalanmış ve kriptografik olarak doğrulanmış** olduğundan emin olun. Bu adım, uygulamanızın güvenlik bütünlüğünü korumak için hayati öneme sahiptir.

Harici depolama, `/storage/emulated/0`, `/sdcard`, `/mnt/sdcard` yollarında **erişilebilir**.

> [!NOTE]
> Android 4.4 ile birlikte (**API 17**), SD kartın bir dizin yapısı vardır ve bu, **bir uygulamanın yalnızca o uygulama için özel olan dizine erişimini sınırlar**. Bu, kötü niyetli uygulamaların başka bir uygulamanın dosyalarına okuma veya yazma erişimi kazanmasını engeller.

**Açık metin olarak saklanan hassas veriler**

- **Paylaşılan tercihleri**: Android, her uygulamanın `/data/data/<packagename>/shared_prefs/` yolunda xml dosyalarını kolayca kaydetmesine izin verir ve bazen o klasörde açık metin olarak hassas bilgiler bulmak mümkündür.
- **Veritabanları**: Android, her uygulamanın `/data/data/<packagename>/databases/` yolunda sqlite veritabanlarını kolayca kaydetmesine izin verir ve bazen o klasörde açık metin olarak hassas bilgiler bulmak mümkündür.

### Kırık TLS

**Tüm Sertifikaları Kabul Etme**

Bazı nedenlerden dolayı, bazen geliştiriciler tüm sertifikaları kabul eder, örneğin, ana bilgisayar adı kod satırlarıyla eşleşmediğinde bile:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Bu testi yapmanın iyi bir yolu, Burp gibi bir proxy kullanarak trafiği yakalamaya çalışmaktır, ancak cihaz içinde Burp CA'yı yetkilendirmeden. Ayrıca, Burp ile farklı bir hostname için bir sertifika oluşturabilir ve bunu kullanabilirsiniz.

### Kırık Kriptografi

**Zayıf Anahtar Yönetim Süreçleri**

Bazı geliştiriciler hassas verileri yerel depolamada saklar ve bunu kodda hardcoded/tahmin edilebilir bir anahtar ile şifreler. Bu yapılmamalıdır çünkü bazı tersine mühendislik işlemleri, saldırganların gizli bilgileri çıkarmasına izin verebilir.

**Güvensiz ve/veya Kullanımdan Kaldırılmış Algoritmaların Kullanımı**

Geliştiriciler, yetkilendirme **kontrolleri** yapmak, **veri saklamak** veya **göndermek** için **kullanımdan kaldırılmış algoritmalar** kullanmamalıdır. Bu algoritmalardan bazıları: RC4, MD4, MD5, SHA1... Örneğin, şifreleri saklamak için **hash'ler** kullanılıyorsa, tuz ile birlikte **brute-force dayanıklı** hash'ler kullanılmalıdır.

### Diğer Kontroller

- **APK'yı obfuscate etmek** önerilir, böylece tersine mühendislik işlemi saldırganlar için zorlaşır.
- Uygulama hassas ise (banka uygulamaları gibi), **mobilin köklenip köklenmediğini kontrol etmelidir** ve buna göre hareket etmelidir.
- Uygulama hassas ise (banka uygulamaları gibi), bir **emülatör** kullanılıp kullanılmadığını kontrol etmelidir.
- Uygulama hassas ise (banka uygulamaları gibi), **çalıştırmadan önce kendi bütünlüğünü kontrol etmelidir** ve değiştirilip değiştirilmediğini kontrol etmelidir.
- [**APKiD**](https://github.com/rednaga/APKiD) kullanarak APK'nın hangi derleyici/paketleyici/obfuscator ile oluşturulduğunu kontrol edin.

### React Native Uygulaması

React uygulamalarının javascript koduna kolayca erişmek için aşağıdaki sayfayı okuyun:

{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Uygulamaları

Xamarin uygulamalarının C# koduna kolayca erişmek için aşağıdaki sayfayı okuyun:

{{#ref}}
../xamarin-apps.md
{{#endref}}

### Süper Paketlenmiş Uygulamalar

Bu [**blog yazısına**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) göre süper paketlenmiş, bir uygulamanın içeriğini tek bir dosyaya sıkıştıran bir Meta algoritmadır. Blog, bu tür uygulamaları açan bir uygulama oluşturma olasılığından bahsediyor... ve **uygulamayı çalıştırıp dosya sisteminden açılmış dosyaları toplamak** gibi daha hızlı bir yol.

### Otomatik Statik Kod Analizi

[**mariana-trench**](https://github.com/facebook/mariana-trench) aracı, uygulamanın **kodunu tarayarak** **zayıflıkları** bulma yeteneğine sahiptir. Bu araç, **kullanıcı tarafından kontrol edilen** **giriş** yerlerini gösteren bir dizi **bilinen kaynak** (kaynaklar), kötü niyetli kullanıcı girişinin zarar verebileceği **tehlikeli** **yerleri** gösteren **sinkler** ve **kurallar** içerir. Bu kurallar, bir zayıflığı gösteren **kaynak-sink kombinasyonunu** belirtir.

Bu bilgiyle, **mariana-trench kodu gözden geçirecek ve olası zayıflıkları bulacaktır**.

### Sızdırılan Sırlar

Bir uygulama, içinde keşfedebileceğiniz sırlar (API anahtarları, şifreler, gizli URL'ler, alt alan adları...) içerebilir. [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks) gibi bir araç kullanabilirsiniz.

### Biyometrik Kimlik Doğrulamasını Atlatma

{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Diğer İlginç Fonksiyonlar

- **Kod yürütme**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **SMS Gönderme**: `sendTextMessage, sendMultipartTestMessage`
- **Native fonksiyonlar** `native` olarak tanımlanır: `public native, System.loadLibrary, System.load`
- [Native fonksiyonları **tersine çevirmeyi öğrenmek için bunu okuyun**](reversing-native-libraries.md)

### **Diğer Hileler**

{{#ref}}
content-protocol.md
{{#endref}}

---

<figure><img src="../../images/image (3).png" alt=""><figcaption></figcaption></figure>

Deneyimli hackerlar ve bug bounty avcıları ile iletişim kurmak için [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) sunucusuna katılın!

**Hacking İçgörüleri**\
Hacking'in heyecanı ve zorluklarına dalan içeriklerle etkileşimde bulunun

**Gerçek Zamanlı Hack Haberleri**\
Hızla değişen hacking dünyasında gerçek zamanlı haberler ve içgörülerle güncel kalın

**Son Duyurular**\
Yeni başlayan bug bounty'ler ve önemli platform güncellemeleri hakkında bilgi sahibi olun

Bugün en iyi hackerlarla işbirliği yapmak için [**Discord**](https://discord.com/invite/N3FrSbmwdy) sunucumuza katılın!

---

## Dinamik Analiz

> Öncelikle, uygulamayı ve tüm ortamı (özellikle Burp CA sertifikası, Drozer ve Frida) kurabileceğiniz bir ortama ihtiyacınız var. Bu nedenle, köklü bir cihaz (emüle edilmiş veya değil) son derece önerilir.

### Çevrimiçi Dinamik Analiz

[https://appetize.io/](https://appetize.io) adresinde **ücretsiz bir hesap** oluşturabilirsiniz. Bu platform, APK'ları **yüklemenize** ve **çalıştırmanıza** olanak tanır, bu nedenle bir APK'nın nasıl davrandığını görmek için faydalıdır.

Ayrıca, uygulamanızın **loglarını** webde görebilir ve **adb** üzerinden bağlanabilirsiniz.

![](<../../images/image (831).png>)

ADB bağlantısı sayesinde, emülatörler içinde **Drozer** ve **Frida** kullanabilirsiniz.

### Yerel Dinamik Analiz

#### Bir emülatör kullanarak

- [**Android Studio**](https://developer.android.com/studio) ( **x86** ve **arm** cihazlar oluşturabilirsiniz ve [**bu**](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**en son x86** sürümleri **ARM kütüphanelerini** yavaş bir arm emülatörüne ihtiyaç duymadan destekler).
- Bunu ayarlamayı öğrenmek için bu sayfayı okuyun:

{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Ücretsiz sürüm:** Kişisel Sürüm, bir hesap oluşturmanız gerekir. _Potansiyel hataları önlemek için **VirtualBox ile** sürümü **indirmeyi** öneririz._)
- [**Nox**](https://es.bignox.com) (Ücretsiz, ancak Frida veya Drozer'ı desteklemez).

> [!NOTE]
> Herhangi bir platformda yeni bir emülatör oluştururken, ekran ne kadar büyükse, emülatör o kadar yavaş çalışır. Bu nedenle, mümkünse küçük ekranlar seçin.

Genymotion'da **Google hizmetlerini** (AppStore gibi) yüklemek için aşağıdaki resmin kırmızı ile işaretlenmiş butonuna tıklamanız gerekir:

![](<../../images/image (277).png>)

Ayrıca, Genymotion'daki **Android VM yapılandırmasında** **Bridge Network mode** seçeneğini seçebileceğinizi unutmayın (bu, Android VM'ye farklı bir VM'den bağlanıyorsanız faydalı olacaktır).

#### Fiziksel bir cihaz kullanma

**hata ayıklama** seçeneklerini etkinleştirmeniz gerekir ve cihazı **köklemek** iyi olur:

1. **Ayarlar**.
2. (Android 8.0'dan itibaren) **Sistem**'i seçin.
3. **Telefon Hakkında**'yı seçin.
4. **Build numarasına** 7 kez basın.
5. Geri dönün ve **Geliştirici seçeneklerini** bulacaksınız.

> Uygulamayı yükledikten sonra yapmanız gereken ilk şey, onu denemek ve ne yaptığını, nasıl çalıştığını araştırmak ve onunla rahat olmaktır.\
> Bu ilk dinamik analizi **MobSF dinamik analizi + pidcat** kullanarak yapmanızı öneririm, böylece **uygulamanın nasıl çalıştığını öğrenebiliriz** ve MobSF **ilginç** **verileri** toplarken daha sonra gözden geçirebiliriz.

### İstenmeyen Veri Sızıntısı

**Günlükleme**

Geliştiriciler, **hata ayıklama bilgilerini** kamuya açık bir şekilde ifşa etmekten kaçınmalıdır, çünkü bu hassas veri sızıntılarına yol açabilir. Uygulama günlüklerini izlemek ve hassas bilgileri korumak için [**pidcat**](https://github.com/JakeWharton/pidcat) ve `adb logcat` araçları önerilir. **Pidcat**, kullanım kolaylığı ve okunabilirliği nedeniyle tercih edilmektedir.

> [!WARNING]
> **Android 4.0'dan** daha yeni sürümlerden itibaren, **uygulamalar yalnızca kendi günlüklerine erişebilir**. Yani uygulamalar diğer uygulamaların günlüklerine erişemez.\
> Yine de, **hassas bilgileri günlüğe kaydetmemek** önerilir.

**Kopyala/Yapıştır Tamponu Önbellekleme**

Android'in **panoya dayalı** çerçevesi, uygulamalarda kopyala-yapıştır işlevselliği sağlar, ancak **diğer uygulamalar** panoya **erişebildiği** için hassas verilerin açığa çıkma riski taşır. Hassas bölümler için kopyala/yapıştır işlevlerini devre dışı bırakmak, kredi kartı bilgileri gibi, veri sızıntılarını önlemek için kritik öneme sahiptir.

**Çökme Günlükleri**

Bir uygulama **çöker** ve **günlükleri kaydederse**, bu günlükler saldırganlara yardımcı olabilir, özellikle uygulama tersine mühendislik ile çözülemezse. Bu riski azaltmak için, çökme durumunda günlük kaydetmekten kaçının ve eğer günlükler ağ üzerinden iletilmesi gerekiyorsa, güvenlik için SSL kanalı üzerinden gönderildiğinden emin olun.

Pentester olarak, **bu günlükleri gözden geçirmeye çalışın**.

**Üçüncü Taraflara Gönderilen Analitik Veriler**

Uygulamalar genellikle Google Adsense gibi hizmetleri entegre eder, bu da geliştiricilerin yanlış uygulaması nedeniyle hassas verilerin **sızmasına** neden olabilir. Potansiyel veri sızıntılarını belirlemek için, uygulamanın trafiğini **yakalamak** ve üçüncü taraf hizmetlere gönderilen hassas bilgileri kontrol etmek önerilir.

### SQLite DB'leri

Çoğu uygulama, bilgileri saklamak için **içsel SQLite veritabanları** kullanır. Pentest sırasında oluşturulan **veritabanlarına**, **tabloların** ve **sütunların** adlarına ve saklanan tüm **verilere** bir **göz atın** çünkü **hassas bilgiler** bulabilirsiniz (bu bir zayıflık olacaktır).\
Veritabanları `/data/data/the.package.name/databases` içinde yer almalıdır, örneğin `/data/data/com.mwr.example.sieve/databases`.

Eğer veritabanı gizli bilgileri saklıyorsa ve **şifrelenmişse** ancak uygulama içinde **şifreyi bulabiliyorsanız**, bu hala bir **zayıflıktır**.

Tabloları `.tables` ile listeleyin ve tabloların sütunlarını `.schema <table_name>` ile listeleyin.

### Drozer (Saldırı Aktiviteleri, İçerik Sağlayıcıları ve Servisler)

[Drozer Belgeleri](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf)'nden: **Drozer**, bir Android uygulamasının rolünü üstlenmenizi ve diğer uygulamalarla etkileşimde bulunmanızı sağlar. Yüklenmiş bir uygulamanın yapabileceği her şeyi yapabilir, örneğin Android’in Araçlar Arası İletişim (IPC) mekanizmasını kullanabilir ve altındaki işletim sistemi ile etkileşimde bulunabilir.\
Drozer, **ihracat edilmiş aktiviteleri, ihracat edilmiş servisleri ve İçerik Sağlayıcıları** istismar etmek için faydalı bir araçtır, bunu aşağıdaki bölümlerde öğreneceksiniz.

### İhracat Edilmiş Aktiviteleri İstismar Etme

[**Bir Android Aktivitesinin ne olduğunu tazelemek istiyorsanız bunu okuyun.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Ayrıca, bir aktivitenin kodunun **`onCreate`** metodunda başladığını unutmayın.

**Yetkilendirme atlatma**

Bir Aktivite ihracat edildiğinde, dış bir uygulamadan ekranını çağırabilirsiniz. Bu nedenle, **hassas bilgileri** içeren bir aktivite **ihracat edilmişse**, **kimlik doğrulama** mekanizmalarını **atlatabilirsiniz**.

[**Drozer ile ihracat edilmiş aktiviteleri nasıl istismar edeceğinizi öğrenin.**](drozer-tutorial/#activities)

Ayrıca, adb'den ihracat edilmiş bir aktivite başlatabilirsiniz:

- Paket Adı com.example.demo
- İhracat Edilmiş Aktivite Adı com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOT**: MobSF, bir aktivitede `android:launchMode` olarak _**singleTask/singleInstance**_ kullanımını kötü niyetli olarak tespit edecektir, ancak [bu](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750) nedeniyle, görünüşe göre bu yalnızca eski sürümlerde (API sürümleri < 21) tehlikelidir.

> [!NOT]
> Bir yetkilendirme atlamanın her zaman bir zafiyet olmadığını unutmayın, bu atlamanın nasıl çalıştığına ve hangi bilgilerin açığa çıktığına bağlıdır.

**Hassas bilgi sızıntısı**

**Aktiviteler ayrıca sonuç döndürebilir**. Eğer **`setResult`** metodunu çağıran ve **hassas bilgi döndüren** bir dışa aktarılmış ve korunmasız aktivite bulursanız, burada bir hassas bilgi sızıntısı vardır.

#### Tapjacking

Eğer tapjacking engellenmezse, dışa aktarılmış aktiviteyi **kullanıcının beklenmedik eylemler gerçekleştirmesi** için kötüye kullanabilirsiniz. Daha fazla bilgi için [**Tapjacking nedir, bağlantıyı takip edin**](./#tapjacking).

### İçerik Sağlayıcılarını Sömürme - Hassas bilgilere erişim ve manipülasyon

[**Bir İçerik Sağlayıcının ne olduğunu tazelemek istiyorsanız bunu okuyun.**](android-applications-basics.md#content-provider)\
İçerik sağlayıcılar temelde **veri paylaşmak** için kullanılır. Eğer bir uygulamada mevcut içerik sağlayıcılar varsa, onlardan **hassas** verileri **çıkartma** imkanınız olabilir. Ayrıca, olası **SQL enjeksiyonlarını** ve **Path Traversals** test etmek de ilginçtir çünkü bunlar zayıf olabilir.

[**Drozer ile İçerik Sağlayıcıları nasıl sömüreceğinizi öğrenin.**](drozer-tutorial/#content-providers)

### **Hizmetleri Sömürme**

[**Bir Servisin ne olduğunu tazelemek istiyorsanız bunu okuyun.**](android-applications-basics.md#services)\
Bir Servisin eylemlerinin `onStartCommand` metodunda başladığını unutmayın.

Servis, temelde **veri alabilen**, **işleyebilen** ve **bir yanıt döndüren** (ya da döndürmeyen) bir şeydir. Dolayısıyla, bir uygulama bazı hizmetleri dışa aktarıyorsa, ne yaptığını anlamak için **kodunu kontrol etmeli** ve gizli bilgileri çıkartmak, kimlik doğrulama önlemlerini atlamak için **dinamik olarak test etmelisiniz**...\
[**Drozer ile Hizmetleri nasıl sömüreceğinizi öğrenin.**](drozer-tutorial/#services)

### **Yayın Alıcılarını Sömürme**

[**Bir Yayın Alıcısının ne olduğunu tazelemek istiyorsanız bunu okuyun.**](android-applications-basics.md#broadcast-receivers)\
Bir Yayın Alıcısının eylemlerinin `onReceive` metodunda başladığını unutmayın.

Bir yayın alıcısı bir tür mesaj bekleyecektir. Alıcının mesajı nasıl işlediğine bağlı olarak, zayıf olabilir.\
[**Drozer ile Yayın Alıcılarını nasıl sömüreceğinizi öğrenin.**](./#exploiting-broadcast-receivers)

### **Şemaları / Derin bağlantıları Sömürme**

Derin bağlantıları manuel olarak, MobSF gibi araçlar veya [bu](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py) gibi betikler kullanarak arayabilirsiniz.\
Bir tanımlı **şemayı** **adb** veya bir **tarayıcı** kullanarak **açabilirsiniz**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Not edin ki **paket adını atlayabilirsiniz** ve mobil otomatik olarak o bağlantıyı açması gereken uygulamayı çağıracaktır._
```markup
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Kod çalıştırıldı**

Uygulamada **çalıştırılacak kodu** bulmak için, derin bağlantıyla çağrılan aktiviteye gidin ve **`onNewIntent`** fonksiyonunu arayın.

![](<../../images/image (436) (1) (1) (1).png>)

**Hassas bilgi**

Her derin bağlantı bulduğunuzda, **URL parametreleri aracılığıyla hassas veriler (şifreler gibi) almadığından emin olun**, çünkü başka bir uygulama **derin bağlantıyı taklit edebilir ve bu verileri çalabilir!**

**Yolda parametreler**

**URL'nin yolunda bir parametre kullanan herhangi bir derin bağlantıyı da kontrol etmelisiniz**; örneğin: `https://api.example.com/v1/users/{username}`. Bu durumda, bir yol geçişi zorlayarak şuna erişebilirsiniz: `example://app/users?username=../../unwanted-endpoint%3fparam=value`.\
Uygulama içinde doğru uç noktaları bulursanız, **Açık Yönlendirme** (eğer yolun bir kısmı alan adı olarak kullanılıyorsa), **hesap ele geçirme** (eğer kullanıcı detaylarını CSRF token olmadan değiştirebiliyorsanız ve zayıf uç nokta doğru yöntemi kullanıyorsa) ve diğer zayıflıkları tetikleyebilirsiniz. Daha fazla [bilgi burada](http://dphoeniixx.com/2020/12/13-2/).

**Daha fazla örnek**

Bağlantılar hakkında [ilginç bir hata ödül raporu](https://hackerone.com/reports/855618) (_/.well-known/assetlinks.json_).

### Taşıma Katmanı İncelemesi ve Doğrulama Hataları

- **Sertifikalar her zaman düzgün bir şekilde incelenmez** Android uygulamaları tarafından. Bu uygulamaların uyarıları göz ardı etmesi ve kendinden imzalı sertifikaları kabul etmesi veya bazı durumlarda HTTP bağlantılarına geri dönmesi yaygındır.
- **SSL/TLS el sıkışması sırasında müzakereler bazen zayıftır**, güvensiz şifreleme takımları kullanır. Bu zayıflık, bağlantıyı adam ortada (MITM) saldırılarına karşı savunmasız hale getirir ve saldırganların verileri şifrelerini çözmesine olanak tanır.
- **Özel bilgilerin sızması**, uygulamalar güvenli kanallar kullanarak kimlik doğrulaması yaparken, diğer işlemler için güvensiz kanallar üzerinden iletişim kurduğunda bir risk oluşturur. Bu yaklaşım, oturum çerezleri veya kullanıcı detayları gibi hassas verileri kötü niyetli varlıkların ele geçirmesinden korumaz.

#### Sertifika Doğrulama

**Sertifika doğrulama** üzerine odaklanacağız. Sunucunun sertifikasının bütünlüğü, güvenliği artırmak için doğrulanmalıdır. Bu, güvensiz TLS yapılandırmaları ve hassas verilerin şifrelenmemiş kanallar üzerinden iletilmesi önemli riskler oluşturabileceğinden kritik öneme sahiptir. Sunucu sertifikalarını doğrulama ve zayıflıkları giderme ile ilgili ayrıntılı adımlar için, [**bu kaynak**](https://manifestsecurity.com/android-application-security-part-10/) kapsamlı rehberlik sağlamaktadır.

#### SSL Pinning

SSL Pinning, uygulamanın sunucunun sertifikasını uygulama içinde saklanan bilinen bir kopya ile doğruladığı bir güvenlik önlemidir. Bu yöntem, MITM saldırılarını önlemek için gereklidir. Hassas bilgileri işleyen uygulamalar için SSL Pinning uygulamak şiddetle önerilir.

#### Trafik İncelemesi

HTTP trafiğini incelemek için, **proxy aracının sertifikasını yüklemek** gereklidir (örneğin, Burp). Bu sertifikayı yüklemeden, şifreli trafik proxy üzerinden görünmeyebilir. Özel CA sertifikası yükleme rehberi için, [**buraya tıklayın**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

**API Seviye 24 ve üzeri** hedefleyen uygulamalar, proxy'nin CA sertifikasını kabul etmek için Ağ Güvenliği Yapılandırmasında değişiklikler gerektirir. Bu adım, şifreli trafiği incelemek için kritik öneme sahiptir. Ağ Güvenliği Yapılandırmasını değiştirme talimatları için, [**bu eğitime başvurun**](make-apk-accept-ca-certificate.md).

#### SSL Pinning'i Atlatma

SSL Pinning uygulandığında, HTTPS trafiğini incelemek için bunu atlatmak gerekli hale gelir. Bu amaçla çeşitli yöntemler mevcuttur:

- **apk'yi otomatik olarak değiştirerek** SSL Pinning'i [**apk-mitm**](https://github.com/shroudedcode/apk-mitm) ile **atlatabilirsiniz**. Bu seçeneğin en iyi yanı, SSL Pinning'i atlatmak için root'a ihtiyacınız olmamasıdır, ancak uygulamayı silip yeni olanı yeniden yüklemeniz gerekecek ve bu her zaman işe yaramayabilir.
- Bu korumayı atlatmak için **Frida** kullanabilirsiniz (aşağıda tartışılmıştır). Burp+Frida+Genymotion kullanma rehberiniz burada: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- **SSL Pinning'i otomatik olarak atlatmayı** [**objection**](frida-tutorial/objection-tutorial.md)** ile deneyebilirsiniz:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- **MobSF dinamik analizi** kullanarak da **SSL Pinning'i otomatik olarak atlatmayı** deneyebilirsiniz (aşağıda açıklanmıştır).
- Hala yakalamadığınız bir trafik olduğunu düşünüyorsanız, trafiği **iptables kullanarak burp'a yönlendirmeyi** deneyebilirsiniz. Bu blogu okuyun: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Yaygın Web Zayıflıklarını Arama

Uygulama içinde yaygın web zayıflıklarını da aramak önemlidir. Bu zayıflıkları tanımlama ve hafifletme ile ilgili ayrıntılı bilgiler bu özetin kapsamının ötesindedir, ancak başka yerlerde kapsamlı bir şekilde ele alınmaktadır.

### Frida

[Frida](https://www.frida.re), geliştiriciler, ters mühendisler ve güvenlik araştırmacıları için dinamik bir enstrümantasyon aracıdır.\
**Çalışan uygulamaya erişebilir ve çalışma zamanında yöntemleri bağlayarak davranışları değiştirebilir, değerleri değiştirebilir, değerleri çıkarabilir, farklı kodlar çalıştırabilirsiniz...**\
Android uygulamalarını pentest etmek istiyorsanız, Frida'yı nasıl kullanacağınızı bilmelisiniz.

- Frida'yı nasıl kullanacağınızı öğrenin: [**Frida eğitimi**](frida-tutorial/)
- Frida ile eylemler için bazı "GUI": [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection, Frida kullanımını otomatikleştirmek için harikadır: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Burada bazı harika Frida betikleri bulabilirsiniz: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Frida'yı [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) adresinde belirtildiği gibi yükleyerek anti-debugging / anti-frida mekanizmalarını atlatmayı deneyin (araç [linjector](https://github.com/erfur/linjector-rs)).

### **Belleği Dökme - Fridump**

Uygulamanın, saklamaması gereken hassas bilgileri (şifreler veya mnemonikler gibi) bellekte saklayıp saklamadığını kontrol edin.

[**Fridump3**](https://github.com/rootbsd/fridump3) kullanarak uygulamanın belleğini dökebilirsiniz:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Bu, ./dump klasöründe belleği dökecektir ve orada şunlarla grep yapabilirsiniz:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Keystore'daki Hassas Veriler**

Android'de Keystore, hassas verileri saklamak için en iyi yerdir, ancak yeterli ayrıcalıklara sahip olunduğunda **erişmek mümkündür**. Uygulamalar burada genellikle **hassas verileri düz metin olarak** sakladığından, pentestler bunun için root kullanıcı olarak kontrol edilmelidir veya cihaza fiziksel erişimi olan birisi bu verileri çalabilir.

Bir uygulama verileri keystore'da saklasa bile, verilerin şifrelenmiş olması gerekir.

Keystore içindeki verilere erişmek için bu Frida script'ini kullanabilirsiniz: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Parmak İzi/Biyometrik Bypass**

Aşağıdaki Frida betiğini kullanarak, Android uygulamalarının **belirli hassas alanları korumak için** gerçekleştirebileceği **parmak izi kimlik doğrulamasını atlamak** mümkün olabilir:
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Arka Plan Görüntüleri**

Bir uygulamayı arka plana aldığınızda, Android **uygulamanın bir anlık görüntüsünü** saklar, böylece ön plana geri döndüğünde, uygulama yüklenmeden önce görüntüyü yüklemeye başlar, bu da uygulamanın daha hızlı yüklendiği izlenimini verir.

Ancak, bu anlık görüntü **hassas bilgiler** içeriyorsa, anlık görüntüye erişimi olan biri bu bilgileri **çalıp alabilir** (erişim için root gereklidir).

Anlık görüntüler genellikle şurada saklanır: **`/data/system_ce/0/snapshots`**

Android, **FLAG_SECURE** düzen parametresini ayarlayarak ekran görüntüsü alımını **önlemenin** bir yolunu sunar. Bu bayrağı kullanarak, pencere içeriği güvenli olarak kabul edilir, bu da ekran görüntülerinde görünmesini veya güvenli olmayan ekranlarda görüntülenmesini engeller.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Uygulama Analizörü**

Bu araç, dinamik analiz sırasında farklı araçları yönetmenize yardımcı olabilir: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Enjeksiyonu

Geliştiriciler genellikle bu Intents'leri işleyen ve `startActivity(...)` veya `sendBroadcast(...)` gibi yöntemlere ileten proxy bileşenleri, aktiviteleri, hizmetleri ve yayın alıcıları oluştururlar; bu da riskli olabilir.

Tehlike, saldırganların bu Intents'leri yanlış yönlendirerek dışa aktarılmamış uygulama bileşenlerini tetiklemelerine veya hassas içerik sağlayıcılarına erişmelerine izin vermekte yatmaktadır. Dikkate değer bir örnek, URL'leri `Intent` nesnelerine dönüştüren `WebView` bileşenidir; bu, potansiyel olarak kötü niyetli Intent enjeksiyonlarına yol açabilir.

### Temel Çıkarımlar

- **Intent Enjeksiyonu**, webin Açık Yönlendirme sorununa benzer.
- Sömürü, `Intent` nesnelerini ekstra olarak geçirmeyi içerir; bu, güvensiz işlemleri yürütmek için yönlendirilebilir.
- Dışa aktarılmamış bileşenleri ve içerik sağlayıcılarını saldırganlara açabilir.
- `WebView`’in URL'den `Intent` dönüşümü, istenmeyen eylemleri kolaylaştırabilir.

### Android İstemci Tarafı Enjeksiyonları ve Diğerleri

Bu tür zafiyetler hakkında Web'den haberdar olmalısınız. Bir Android uygulamasında bu zafiyetlere karşı özellikle dikkatli olmalısınız:

- **SQL Enjeksiyonu:** Dinamik sorgular veya İçerik Sağlayıcılarla çalışırken, parametreli sorgular kullandığınızdan emin olun.
- **JavaScript Enjeksiyonu (XSS):** Herhangi bir WebView için JavaScript ve Eklenti desteğinin devre dışı olduğundan emin olun (varsayılan olarak devre dışıdır). [Daha fazla bilgi burada](webview-attacks.md#javascript-enabled).
- **Yerel Dosya Dahil Etme:** WebView'lerin dosya sistemine erişimi devre dışı olmalıdır (varsayılan olarak etkindir) - `(webview.getSettings().setAllowFileAccess(false);)`. [Daha fazla bilgi burada](webview-attacks.md#javascript-enabled).
- **Sonsuz çerezler**: Birçok durumda, android uygulaması oturumu bitirdiğinde çerez iptal edilmez veya hatta diske kaydedilebilir.
- [**Çerezlerde Güvenli Bayrak**](../../pentesting-web/hacking-with-cookies/#cookies-flags)

---

<figure><img src="../../images/image (3).png" alt=""><figcaption></figcaption></figure>

Deneyimli hackerlar ve hata ödülü avcıları ile iletişim kurmak için [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) sunucusuna katılın!

**Hacking İçgörüleri**\
Hacking'in heyecanı ve zorluklarına dalan içeriklerle etkileşimde bulunun.

**Gerçek Zamanlı Hack Haberleri**\
Gerçek zamanlı haberler ve içgörülerle hızlı tempolu hacking dünyasında güncel kalın.

**Son Duyurular**\
Yeni hata ödülleri ve kritik platform güncellemeleri hakkında bilgi sahibi olun.

**Bize katılın** [**Discord**](https://discord.com/invite/N3FrSbmwdy) ve bugün en iyi hackerlarla işbirliği yapmaya başlayın!

## Otomatik Analiz

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Statik analiz**

![](<../../images/image (866).png>)

**Uygulamanın güvenlik açığı değerlendirmesi**, güzel bir web tabanlı ön yüz kullanarak yapılır. Dinamik analiz de gerçekleştirebilirsiniz (ancak ortamı hazırlamanız gerekir).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
MobSF, **Android**(apk)**, IOS**(ipa) **ve Windows**(apx) uygulamalarını (_Windows uygulamaları, Windows ana bilgisayarında kurulu bir MobSF'den analiz edilmelidir_) analiz edebilir.\
Ayrıca, bir **Android** veya **IOS** uygulamasının kaynak koduyla bir **ZIP** dosyası oluşturursanız (uygulamanın kök klasörüne gidin, her şeyi seçin ve bir ZIP dosyası oluşturun), bunu da analiz edebilecektir.

MobSF ayrıca **diff/Compare** analizine ve **VirusTotal** entegrasyonuna izin verir (API anahtarınızı _MobSF/settings.py_ dosyasına ayarlamanız ve etkinleştirmeniz gerekecek: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). Ayrıca `VT_UPLOAD`'ı `False` olarak ayarlayabilirsiniz, bu durumda **hash** dosya yerine **yüklenir**.

### MobSF ile Yardımlı Dinamik Analiz

**MobSF**, **Android** için **dinamik analiz** konusunda da çok yardımcı olabilir, ancak bu durumda MobSF ve **genymotion**'ı ana bilgisayarınıza kurmanız gerekecek (bir VM veya Docker çalışmayacaktır). _Not: Öncelikle **genymotion'da bir VM başlatmalısınız** ve **sonra MobSF'yi başlatmalısınız.**_\
**MobSF dinamik analizörü** şunları yapabilir:

- **Uygulama verilerini dökme** (URL'ler, günlükler, panoya kopyalananlar, sizin yaptığınız ekran görüntüleri, "**Exported Activity Tester**" tarafından yapılan ekran görüntüleri, e-postalar, SQLite veritabanları, XML dosyaları ve diğer oluşturulan dosyalar). Tüm bunlar otomatik olarak yapılır, ekran görüntüleri için istediğinizde basmanız veya tüm dışa aktarılan etkinliklerin ekran görüntülerini almak için "**Exported Activity Tester**" butonuna basmanız gerekir.
- **HTTPS trafiğini yakalama**
- **Runtime** **bilgilerini elde etmek için **Frida** kullanma**

Android **sürümleri > 5**'ten itibaren, **Frida**'yı **otomatik olarak başlatacak** ve trafiği **yakalamak** için global **proxy** ayarlarını ayarlayacaktır. Sadece test edilen uygulamadan gelen trafiği yakalayacaktır.

**Frida**

Varsayılan olarak, **SSL pinning**, **root tespiti** ve **hata ayıklayıcı tespiti** atlamak ve **ilginç API'leri izlemek** için bazı Frida Script'lerini de kullanacaktır.\
MobSF ayrıca **dışa aktarılan etkinlikleri çağırabilir**, bunların **ekran görüntülerini** alabilir ve rapor için **kaydedebilir**.

Dinamik testi **başlatmak** için yeşil butona basın: "**Start Instrumentation**". Frida script'leri tarafından üretilen günlükleri görmek için "**Frida Live Logs**" butonuna basın ve bağlı yöntemlere yapılan tüm çağrıları, geçirilen argümanları ve döndürülen değerleri görmek için "**Live API Monitor**" butonuna basın (bu, "Start Instrumentation" butonuna bastıktan sonra görünecektir).\
MobSF ayrıca kendi **Frida script'lerinizi** yüklemenize izin verir (Frida script'lerinizin sonuçlarını MobSF'ye göndermek için `send()` fonksiyonunu kullanın). Ayrıca yükleyebileceğiniz **birçok önceden yazılmış script** vardır (daha fazlasını `MobSF/DynamicAnalyzer/tools/frida_scripts/others/` dizinine ekleyebilirsiniz), sadece **seçin**, "**Load**" butonuna basın ve "**Start Instrumentation**" butonuna basın (bu script'lerin günlüklerini "**Frida Live Logs**" içinde görebileceksiniz).

![](<../../images/image (419).png>)

Ayrıca, bazı Yardımcı Frida işlevsellikleriniz var:

- **Yüklenen Sınıfları Listele**: Yüklenen tüm sınıfları yazdırır
- **Dizeleri Yakala**: Uygulama kullanılırken tüm yakalanan dizeleri yazdırır (çok gürültülü)
- **Dize Karşılaştırmalarını Yakala**: Çok faydalı olabilir. **Karşılaştırılan 2 dizeyi** ve sonucun True veya False olup olmadığını **gösterir**.
- **Sınıf Yöntemlerini Listele**: Sınıf adını (örneğin "java.io.File") yazın ve sınıfın tüm yöntemlerini yazdırır.
- **Sınıf Deseni Ara**: Desene göre sınıfları arar
- **Sınıf Yöntemlerini İzle**: **Bütün bir sınıfı izler** (sınıfın tüm yöntemlerinin giriş ve çıkışlarını görün). Varsayılan olarak MobSF, birkaç ilginç Android API yöntemini izler.

Kullanmak istediğiniz yardımcı modülü seçtikten sonra "**Start Instrumentation**" butonuna basmanız gerekir ve tüm çıktıları "**Frida Live Logs**" içinde göreceksiniz.

**Shell**

Mobsf ayrıca dinamik analiz sayfasının altında bazı **adb** komutları, **MobSF komutları** ve yaygın **shell** **komutları** ile bir shell sunar. Bazı ilginç komutlar:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP araçları**

HTTP trafiği yakalandığında, "**HTTP(S) Trafik**" altındaki yakalanan trafiğin çirkin bir görünümünü veya "**HTTP Araçlarını Başlat**" yeşil butonundaki daha güzel bir görünümünü görebilirsiniz. İkinci seçenekten, **yakalanan istekleri** Burp veya Owasp ZAP gibi **proxy'lere** **gönderebilirsiniz**.\
Bunu yapmak için, _Burp'ı açın -->_ _Intercept'i kapatın --> MobSB HTTP Araçları'nda isteği seçin_ --> "**Fuzzer'a Gönder**" butonuna basın --> _proxy adresini seçin_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

MobSF ile dinamik analizi tamamladıktan sonra, **http isteklerini fuzz** etmek ve güvenlik açıklarını aramak için "**Web API Fuzzer'ı Başlat**" butonuna basabilirsiniz.

> [!NOTE]
> MobSF ile dinamik bir analiz gerçekleştirdikten sonra proxy ayarları yanlış yapılandırılmış olabilir ve bunları GUI'den düzeltemezsiniz. Proxy ayarlarını düzeltmek için:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Inspeckage ile Yardımlı Dinamik Analiz

Aracı [**Inspeckage**](https://github.com/ac-pm/Inspeckage) adresinden edinebilirsiniz.\
Bu araç, **dinamik analiz** gerçekleştirirken **uygulamada neler olduğunu** anlamanızı sağlamak için bazı **Hooks** kullanacaktır.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Bu, **GUI ile statik analiz gerçekleştirmek için harika bir araçtır.**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Bu araç, **kaynak kodunda** veya **paketlenmiş APK'larda** çeşitli **güvenlik ile ilgili Android uygulama açıklarını** aramak için tasarlanmıştır. Araç ayrıca, bulunan bazı güvenlik açıklarını (Açık aktiviteler, intentler, tapjacking...) istismar etmek için **"Proof-of-Concept" dağıtılabilir APK** ve **ADB komutları** oluşturma yeteneğine de sahiptir. Drozer ile olduğu gibi, test cihazını root etmenize gerek yoktur.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Kolay referans için tüm çıkarılan dosyaları görüntüler
- APK dosyalarını otomatik olarak Java ve Smali formatına decompile eder
- Yaygın güvenlik açıkları ve davranışlar için AndroidManifest.xml'i analiz eder
- Yaygın güvenlik açıkları ve davranışlar için statik kaynak kodu analizi
- Cihaz bilgisi
- ve daha fazlası
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER, Windows, MacOS X ve Linux'ta kullanılabilen bir komut satırı uygulamasıdır ve güvenlik açıklarını aramak için _.apk_ dosyalarını analiz eder. Bunu, APK'ları sıkıştırmasını açarak ve bu güvenlik açıklarını tespit etmek için bir dizi kural uygulayarak yapar.

Tüm kurallar `rules.json` dosyasında toplanmıştır ve her şirket veya testçi, ihtiyaç duydukları şeyleri analiz etmek için kendi kurallarını oluşturabilir.

En son ikili dosyaları [indirme sayfasından](https://superanalyzer.rocks/download.html) indirin.
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn, mobil uygulamalar üzerinde [statik kod analizi](https://en.wikipedia.org/wiki/Static_program_analysis) gerçekleştiren geliştiricilere, bugbounty avcılarına ve etik hackerlara yardımcı olan **çapraz platform** bir araçtır.

Kavram, mobil uygulama dosyanızı (bir .apk veya .ipa dosyası) StaCoAn uygulamasına sürükleyip bırakmanız ve bunun için görsel ve taşınabilir bir rapor oluşturmasıdır. Özelleştirilmiş bir deneyim elde etmek için ayarları ve kelime listelerini değiştirebilirsiniz.

[son sürümü](https://github.com/vincentcox/StaCoAn/releases) indirin:
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework, geliştiricilerin veya hackerların Android uygulamalarındaki potansiyel güvenlik açıklarını bulmalarına yardımcı olan bir Android zafiyet analiz sistemidir.\
[Windows sürümleri](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn**, bir Android uygulaması tarafından geliştirilen potansiyel kötü niyetli davranışları tespit etmek ve kullanıcıyı uyarmak amacıyla tasarlanmış bir araçtır.

Tespit, uygulamanın Dalvik bytecode'unun **statik analizi** ile gerçekleştirilir ve bu, **Smali** olarak temsil edilir; [`androguard`](https://github.com/androguard/androguard) kütüphanesi kullanılır.

Bu araç, aşağıdaki gibi **"kötü" uygulamaların yaygın davranışlarını** arar: Telefon kimliklerinin sızdırılması, Ses/görüntü akışının kesilmesi, PIM verilerinin değiştirilmesi, Rastgele kod yürütme...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA**, **M**obil **U**ygulama **T**ersten mühendislik ve **A**naliz Çerçevesidir. Bu, mobil uygulamaları OWASP mobil güvenlik tehditlerine karşı test etmeye yardımcı olmak için yaygın olarak kullanılan mobil uygulama ters mühendislik ve analiz araçlarını bir araya getiren bir araçtır. Amacı, bu görevi mobil uygulama geliştiricileri ve güvenlik profesyonelleri için daha kolay ve daha dostane hale getirmektir.

Şunları yapabilir:

- Farklı araçlar kullanarak Java ve Smali kodunu çıkarmak
- APK'ları analiz etmek için: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Regex kullanarak APK'dan özel bilgileri çıkarmak.
- Manifest'i analiz etmek.
- Bulunan alanları analiz etmek için: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) ve [whatweb](https://github.com/urbanadventurer/WhatWeb)
- APK'yı [apk-deguard.com](http://www.apk-deguard.com) üzerinden deşifre etmek

### Koodous

Kötü amaçlı yazılımları tespit etmek için kullanışlı: [https://koodous.com/](https://koodous.com)

## Kodun Obfuscation/Deobfuscation'ı

Kodu obfuscate etmek için kullandığınız hizmet ve yapılandırmaya bağlı olarak, gizli bilgiler obfuscate edilmiş veya edilmemiş olabilir.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

[Wikipedia'dan](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard**, Java kodunu küçülten, optimize eden ve obfuscate eden açık kaynaklı bir komut satırı aracıdır. Bytecode'u optimize etmenin yanı sıra kullanılmayan talimatları tespit edip kaldırabilir. ProGuard, ücretsiz bir yazılımdır ve GNU Genel Kamu Lisansı, sürüm 2 altında dağıtılmaktadır.

ProGuard, Android SDK'nın bir parçası olarak dağıtılır ve uygulama yayın modunda derlenirken çalışır.

### [DexGuard](https://www.guardsquare.com/dexguard)

APK'yı deşifre etmek için adım adım bir kılavuzu [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html) adresinde bulabilirsiniz.

(Bu kılavuzdan) Son kontrol ettiğimizde, Dexguard çalışma modu şuydu:

- Bir kaynağı InputStream olarak yüklemek;
- Sonucu deşifre etmek için FilterInputStream'den türetilen bir sınıfa beslemek;
- Bir ters mühendislik uzmanının birkaç dakikasını boşa harcamak için gereksiz obfuscation yapmak;
- Deşifre edilmiş sonucu bir ZipInputStream'e beslemek ve bir DEX dosyası almak;
- Son olarak, elde edilen DEX'i `loadDex` yöntemi kullanarak bir Kaynak olarak yüklemek.

### [DeGuard](http://apk-deguard.com)

**DeGuard, Android obfuscation araçları tarafından gerçekleştirilen obfuscation sürecini tersine çevirir. Bu, kod denetimi ve kütüphaneleri tahmin etme gibi birçok güvenlik analizini mümkün kılar.**

Obfuscate edilmiş bir APK'yı platformlarına yükleyebilirsiniz.

### [Simplify](https://github.com/CalebFenton/simplify)

Bu, **genel bir android deobfuscator'dır.** Simplify, bir uygulamayı **sanallaştırarak çalıştırır** ve davranışını anlamaya çalışır, ardından **kodun optimize edilmesini** sağlar, böylece aynı şekilde davranır ancak bir insanın anlaması daha kolaydır. Her optimizasyon türü basit ve genel olduğundan, kullanılan obfuscation türü önemli değildir.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD, **bir APK'nın nasıl yapıldığını** hakkında bilgi verir. Birçok **derleyici**, **paketleyici**, **obfuscator** ve diğer garip şeyleri tanımlar. Android için [_PEiD_](https://www.aldeid.com/wiki/PEiD) gibidir.

### Manual

[Özel obfuscation'ı nasıl tersine çevireceğinizi öğrenmek için bu eğitimi okuyun](manual-deobfuscation.md)

## Laboratuvarlar

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b, ubuntu-mate tabanlı bir Android güvenlik sanal makinesidir ve ters mühendislik ve kötü amaçlı yazılım analizi için farklı güvenlik meraklıları ve araştırmacılardan en son çerçeve, eğitim ve laboratuvar koleksiyonunu içerir.

## Referanslar

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Harika bir kaynak listesi
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android hızlı kursu
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)

## Denemek için

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

<figure><img src="../../images/image (3).png" alt=""><figcaption></figcaption></figure>

Deneyimli hackerlar ve bug bounty avcıları ile iletişim kurmak için [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) sunucusuna katılın!

**Hacking Insights**\
Hacking'in heyecanı ve zorluklarına dalan içeriklerle etkileşimde bulunun

**Gerçek Zamanlı Hack Haberleri**\
Gerçek zamanlı haberler ve içgörüler aracılığıyla hızlı tempolu hacking dünyasında güncel kalın

**Son Duyurular**\
Yeni başlayan bug bounty'ler ve önemli platform güncellemeleri hakkında bilgi sahibi olun

**Bize katılın** [**Discord**](https://discord.com/invite/N3FrSbmwdy) ve bugün en iyi hackerlarla işbirliği yapmaya başlayın!

{{#include ../../banners/hacktricks-training.md}}
