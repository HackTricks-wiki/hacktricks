# Pentesting додатків Android

{{#include ../../banners/hacktricks-training.md}}

## Основи додатків Android

Рекомендується почати з прочитання цієї сторінки, щоб дізнатися про **найважливіші частини, пов'язані з безпекою Android, та найнебезпечніші компоненти в Android-додатку**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Це головний інструмент, який потрібен, щоб підключитися до пристрою Android (емулятор або фізичний).\
**ADB** дозволяє керувати пристроями через **USB** або **Network** з комп'ютера. Ця утиліта дозволяє **копіювання** файлів в обох напрямках, **встановлення** та **видалення** додатків, **виконання** shell-команд, **резервне копіювання** даних, **читання** логів та інші функції.

Перегляньте наступний список [**ADB Commands**](adb-commands.md), щоб дізнатися, як користуватися adb.

## Smali

Іноді цікаво **змінити код додатку**, щоб отримати доступ до **прихованої інформації** (наприклад, сильно обфусцованих паролів або flags). Тоді може бути корисно декомпілювати apk, змінити код і перекомпілювати його.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Це може бути дуже корисно як **альтернатива для кількох тестів під час динамічного аналізу**, які будуть представлені. Тому **завжди майте на увазі цю можливість**.

## Інші цікаві трюки

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **Завантажити APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Витягнути APK з пристрою:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Об'єднайте всі splits і base apks за допомогою [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Кейси та вразливості


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Static Analysis

Перш за все, для аналізу APK слід **подивитися Java код** за допомогою декомпілятора.\
Будь ласка, [**прочитайте тут, щоб знайти інформацію про різні доступні decompilers**](apk-decompilers.md).

### Пошук цікавої інформації

Просто переглянувши **strings** APK, ви можете шукати **паролі**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** і все, що може бути цікавим... шукайте навіть кодові виконувані **backdoors** або бекдори автентифікації (хардкодені admin credentials для додатку).

**Firebase**

Зверніть особливу увагу на **Firebase URLs** і перевірте, чи коректно він налаштований. [Більше інформації про те, що таке Firebase і як це експлуатувати тут.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Базове розуміння застосунку - Manifest.xml, strings.xml

**Перевірка файлів _Manifest.xml_ та _strings.xml_ додатку може виявити потенційні вразливості безпеки**. До цих файлів можна отримати доступ за допомогою decompilers або перейменувавши розширення APK на .zip і розпакувавши його.

**Вразливості**, які можна визначити з **Manifest.xml**, включають:

- **Debuggable Applications**: Додатки, вказані як debuggable (`debuggable="true"`) у файлі _Manifest.xml_, становлять ризик, оскільки дозволяють підключення, що може призвести до експлуатації. Для детальнішого розуміння того, як використовувати debuggable додатки, зверніться до навчального матеріалу про знаходження і експлуатацію debuggable додатків на пристрої.
- **Backup Settings**: Атрибут `android:allowBackup="false"` має бути явно вказаний для додатків, що працюють з чутливою інформацією, щоб запобігти несанкціонованому резервному копіюванню даних через adb, особливо коли USB debugging увімкнено.
- **Network Security**: Користувацькі конфігурації network security (`android:networkSecurityConfig="@xml/network_security_config"`) у _res/xml/_ можуть вказувати деталі безпеки, такі як certificate pins і налаштування HTTP трафіку. Приклад — дозволити HTTP трафік для певних доменів.
- **Exported Activities and Services**: Виявлення exported activities та services у манифесті може вказати на компоненти, які можуть бути неправильно використані. Подальший аналіз під час dynamic testing може показати, як експлуатувати ці компоненти.
- **Content Providers and FileProviders**: Відкриті content providers можуть дозволити несанкціонований доступ або модифікацію даних. Конфігурацію FileProviders також слід ретельно перевірити.
- **Broadcast Receivers and URL Schemes**: Ці компоненти можуть бути використані для експлуатації, зверніть особливу увагу на те, як URL schemes обробляються щодо уразливостей введення.
- **SDK Versions**: Атрибути `minSdkVersion`, `targetSDKVersion` та `maxSdkVersion` вказують підтримувані версії Android, підкреслюючи важливість відмови від підтримки застарілих, вразливих версій Android з міркувань безпеки.

У файлі **strings.xml** можна знайти чутливу інформацію, таку як API keys, custom schemas та інші нотатки розробника, що підкреслює необхідність ретельного перегляду цих ресурсів.

### Tapjacking

**Tapjacking** — це атака, коли **шкідливий** **додаток** запускається і **розміщується поверх застосунку-жертви**. Коли він візуально перекриває додаток-жертву, його інтерфейс спроектований так, щоб обдурити користувача і змусити його взаємодіяти з ним, при цьому взаємодія передається у додаток-жертву.\
Фактично це **приосліплює користувача**, через що він не знає, що насправді виконує дії у додатку-жертві.

Дізнайтеся більше у:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Активність з `launchMode`, встановленим у **`singleTask` без визначеного `taskAffinity`**, вразлива до Task Hijacking. Це означає, що **шкідливий додаток** може бути встановлений і якщо він буде запущений перед реальним додатком, він може **перехопити task реального додатку** (тому користувач взаємодіятиме зі **шкідливим додатком, думаючи, що це реальний**).

Детальніше тут:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Небезпечне зберігання даних

**Внутрішнє сховище**

В Android файли, **збережені** у **internal** storage, **призначені** для доступу виключно тим **додатком**, який їх **створив**. Цей захід безпеки **застосовується** операційною системою Android і зазвичай достатній для потреб більшості додатків. Однак розробники іноді використовують режими, такі як `MODE_WORLD_READABLE` і `MODE_WORLD_WRITABLE`, щоб **дозволити** файлам **бути доступними** між різними додатками. Ці режими, проте, **не обмежують доступ** до файлів іншими додатками, включно з потенційно шкідливими.

1. **Static Analysis:**
- **Переконайтеся**, що використання `MODE_WORLD_READABLE` і `MODE_WORLD_WRITABLE` **ретельно перевірено**. Ці режими **можуть потенційно відкрити** файли для **непередбачуваного або несанкціонованого доступу**.
2. **Dynamic Analysis:**
- **Перевірте** дозволи, встановлені на файлах, створених додатком. Зокрема, **перевірте**, чи будь-які файли **налаштовані як readable або writable worldwide**. Це може створити значний ризик безпеки, оскільки дозволить **будь-якому встановленому додатку** на пристрої, незалежно від його походження або намірів, **читати або змінювати** ці файли.

**Зовнішнє сховище**

При роботі з файлами на **external storage**, таких як SD Card, слід враховувати такі запобіжні заходи:

1. **Доступність**:
- Файли на external storage **доступні для читання і запису глобально**. Це означає, що будь-який додаток або користувач може отримати до них доступ.
2. **Проблеми безпеки**:
- Через простоту доступу не рекомендується **зберігати чутливу інформацію** на external storage.
- External storage може бути вилучене або доступне будь-якому додатку, що робить його менш безпечним.
3. **Обробка даних з external storage**:
- Завжди **виконуйте валідацію введення** для даних, отриманих з external storage. Це критично, оскільки такі дані походять з недовіреного джерела.
- Не рекомендується зберігати виконувані файли або class-файли на external storage для динамічного завантаження.
- Якщо ваш додаток повинен отримувати виконувані файли з external storage, переконайтеся, що ці файли **підписані та криптографічно перевірені** перед їх динамічним завантаженням. Цей крок важливий для збереження цілісності безпеки вашого додатку.

External storage можна **знайти** в `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> Починаючи з Android 4.4 (**API 17**), SD card має структуру директорій, яка **обмежує доступ додатку лише до директорії, призначеної конкретно для цього додатку**. Це перешкоджає шкідливим додаткам отримувати доступ для читання або запису до файлів іншого додатку.

**Чутливі дані, збережені у відкритому тексті**

- **Shared preferences**: Android дозволяє кожному додатку зручно зберігати xml-файли в шляху `/data/data/<packagename>/shared_prefs/` і іноді в цій папці можна знайти чутливу інформацію у відкритому тексті.
- **Databases**: Android дозволяє кожному додатку зручно зберігати sqlite бази даних в шляху `/data/data/<packagename>/databases/` і іноді в цій папці можна знайти чутливу інформацію у відкритому тексті.

### Broken TLS

**Accept All Certificates**

З якоїсь причини розробники іноді приймають усі сертифікати, навіть якщо, наприклад, hostname не збігається, з рядками коду на кшталт наступного:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Хороший спосіб перевірити це — спробувати перехопити трафік за допомогою proxy, наприклад Burp, не авторизувавши Burp CA на пристрої. Також можна згенерувати в Burp сертифікат для іншого hostname і використати його.

### Ненадійна криптографія

**Недостатні процеси управління ключами**

Деякі розробники зберігають чутливі дані в локальному сховищі і шифрують їх ключем, захардкоженим/передбачуваним у коді. Так робити не слід, оскільки деякий reversing може дозволити зловмисникам витягти конфіденційну інформацію.

**Використання небезпечних та/або застарілих алгоритмів**

Розробники не повинні використовувати **deprecated algorithms** для виконання авторизаційних **checks**, **store** або **send** даних. Деякі з цих алгоритмів: RC4, MD4, MD5, SHA1... Якщо для збереження паролів, наприклад, використовуються **hashes**, слід застосовувати brute-force **resistant** hashes із salt.

### Інші перевірки

- Рекомендовано **obfuscate the APK**, щоб ускладнити reverse engineering для зловмисників.
- Якщо додаток чутливий (наприклад bank apps), він повинен виконувати власні перевірки, щоб з’ясувати, чи мобільний пристрій **is rooted**, і діяти відповідно.
- Якщо додаток чутливий (наприклад bank apps), він повинен перевіряти, чи використовується **emulator**.
- Якщо додаток чутливий (наприклад bank apps), він повинен **check it's own integrity before executing** щоб переконатися, що його не було змінено.
- Використовуйте [**APKiD**](https://github.com/rednaga/APKiD) щоб перевірити, який compiler/packer/obfuscator був використаний для збірки APK

### React Native Application

Прочитайте наступну сторінку, щоб дізнатися, як легко отримати доступ до javascript коду React застосунків:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Прочитайте наступну сторінку, щоб дізнатися, як легко отримати доступ до C# коду xamarin застосунків:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

Згідно з цим [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/), superpacked — це Meta алгоритм, який стискає вміст застосунку в один файл. Блог розповідає про можливість створити додаток, який розпаковує такого роду застосунки... і про швидший спосіб, який передбачає **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

Інструмент [**mariana-trench**](https://github.com/facebook/mariana-trench) здатен знаходити **vulnerabilities** шляхом **scanning** **code** застосунку. Цей інструмент містить серію **known sources** (які вказують інструменту **places**, де **input** **controlled by the user**), **sinks** (які вказують інструменту **dangerous** **places**, де зловмисний користувацький ввід може завдати шкоди) та **rules**. Ці правила вказують **combination** **sources-sinks**, що означає вразливість.

Завдяки цьому знанню, **mariana-trench will review the code and find possible vulnerabilities on it**.

### Secrets leaked

Застосунок може містити secrets (API keys, passwords, hidden urls, subdomains...) всередині, які ви можете виявити. Ви можете використати інструмент, такий як [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Інші цікаві функції

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Прочитайте це, щоб дізнатися **how to reverse native functions**](reversing-native-libraries.md)

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Динамічний аналіз

> По-перше, вам потрібне середовище, де ви можете встановити застосунок і все оточення (Burp CA cert, Drozer and Frida в основному). Тому настійно рекомендується використовувати rooted пристрій (емулятор чи ні).

### Онлайн динамічний аналіз

Ви можете створити **free account** на: [https://appetize.io/](https://appetize.io/). Ця платформа дозволяє **upload** та **execute** APK, тому вона корисна, щоб побачити, як apk поводиться.

Ви навіть можете **see the logs of your application** в вебі та підключитися через **adb**.

![](<../../images/image (831).png>)

Завдяки ADB з’єднанню ви можете використовувати **Drozer** та **Frida** всередині емулаторів.

### Локальний динамічний аналіз

#### Використання емулятора

- [**Android Studio**](https://developer.android.com/studio) (Ви можете створювати **x86** та **arm** пристрої, і згідно з [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** версії **support ARM libraries** без потреби в повільному arm емуляторі).
- Дізнайтесь, як налаштувати це на цій сторінці:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, потрібно створити акаунт. _Рекомендується **download** версію **WITH**_ _**VirtualBox** щоб уникнути потенційних помилок._)
- [**Nox**](https://es.bignox.com) (Free, але не підтримує Frida або Drozer).

> [!TIP]
> Коли створюєте новий емулатор на будь-якій платформі, пам’ятайте, що чим більший екран, тим повільніше працюватиме емулятор. Тому за можливості обирайте менші екрани.

Щоб **install google services** (наприклад AppStore) в Genymotion, потрібно натиснути на червону кнопку, позначену на наступному зображенні:

![](<../../images/image (277).png>)

Також зверніть увагу, що в **configuration of the Android VM in Genymotion** ви можете обрати **Bridge Network mode** (це буде корисно, якщо ви підключатиметесь до Android VM з іншої VM з інструментами).

#### Використання фізичного пристрою

Вам потрібно активувати опції **debugging** і бажано, щоб ви могли його **root**:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Після встановлення застосунку перше, що ви повинні зробити — це спробувати його і дослідити, що він робить, як працює і звикнути до нього.\
> Рекомендую **perform this initial dynamic analysis using MobSF dynamic analysis + pidcat**, щоб ми могли **learn how the application works**, поки MobSF **captures** багато **interesting** **data**, які ви потім зможете переглянути.

Magisk/Zygisk quick notes (recommended on Pixel devices)
- Patch boot.img with the Magisk app and flash via fastboot to get systemless root
- Enable Zygisk + DenyList for root hiding; consider LSPosed/Shamiko when stronger hiding is required
- Keep original boot.img to recover from OTA updates; re-patch after each OTA
- For screen mirroring, use scrcpy on the host



### Ненавмисний витік даних

**Logging**

Розробникам слід бути обережними з публічним виведенням **debugging information**, оскільки це може призвести до витоків чутливих даних. Рекомендується використовувати інструменти [**pidcat**](https://github.com/JakeWharton/pidcat) та `adb logcat` для моніторингу журналів застосунку, щоб ідентифікувати та захистити чутливу інформацію. **Pidcat** віддають перевагу за його простоту використання та читабельність.

> [!WARNING]
> Зауважте, що починаючи з **пізніших версій, новіших за Android 4.0**, **додатки можуть отримувати доступ лише до своїх власних логів**. Тож додатки не можуть отримувати логи інших застосунків.\
> Тим не менш, все ще рекомендовано **не логувати чутливу інформацію**.

**Copy/Paste Buffer Caching**

Android-фреймворк на основі буфера обміну (clipboard) забезпечує функціональність копіювання/вставки в додатках, але несе ризик, оскільки **інші додатки** можуть **access** буфер обміну, потенційно розкриваючи чутливі дані. Важливо **disable copy/paste** функції для чутливих частин застосунку, наприклад деталей кредитної картки, щоб запобігти витокам даних.

**Crash Logs**

Якщо застосунок **crashes** і **saves logs**, ці журнали можуть допомогти зловмисникам, особливо коли застосунок не можна відреференсувати. Щоб зменшити цей ризик, уникайте логування під час краху, і якщо журнали мають передаватися мережею, переконайтесь, що вони надсилаються через SSL-канал для безпеки.

Як pentester, **try to take a look to these logs**.

**Analytics Data Sent To 3rd Parties**

Додатки часто інтегрують сервіси на кшталт Google Adsense, які можуть ненавмисно **leak sensitive data** через неправильну реалізацію розробниками. Щоб виявити можливі витоки даних, варто **intercept the application's traffic** і перевірити, чи не надсилається чутлива інформація до third-party сервісів.

### SQLite DBs

Більшість застосунків використовують **internal SQLite databases** для збереження інформації. Під час pentest перегляньте **databases**, назви **tables** і **columns** та всі **data**, що зберігається, оскільки ви можете знайти **sensitive information** (що буде вразливістю).\
Бази даних зазвичай знаходяться в `/data/data/the.package.name/databases`, наприклад `/data/data/com.mwr.example.sieve/databases`

Якщо база даних зберігає конфіденційну інформацію і вона **encrypted**, але ви можете **find** пароль всередині застосунку, це все одно **vulnerability**.

Перелічіть таблиці за допомогою `.tables` і перераховуйте колонки таблиць командою `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

Згідно з [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** дозволяє вам **assume the role of an Android app** та взаємодіяти з іншими додатками. Він може робити **anything that an installed application can do**, наприклад використовувати Android’s Inter-Process Communication (IPC) механізм та взаємодіяти з підлягаючою операційною системою. .\
Drozer — корисний інструмент для **exploit exported activities, exported services and Content Providers**, як ви дізнаєтесь у наступних розділах.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Також пам’ятайте, що код activity починається в методі **`onCreate`**.

**Authorisation bypass**

Коли Activity є exported, ви можете викликати його екран з зовнішнього додатку. Тому, якщо activity з **sensitive information** є **exported**, ви можете **bypass** механізми **authentication**, щоб отримати доступ до нього.

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

Ви також можете запустити exported activity з adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**ПРИМІТКА**: MobSF виявлятиме як шкідливе використання _**singleTask/singleInstance**_ як `android:launchMode` в activity, але через [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), очевидно, це небезпечно лише на старих версіях (API versions < 21).

> [!TIP]
> Зверніть увагу, що authorisation bypass не завжди є vulnerability, це залежить від того, як працює bypass і яка інформація стає доступною.

**Sensitive information leakage**

**Activities can also return results**. Якщо вам вдасться знайти exported and unprotected activity, яка викликає метод **`setResult`** і **returning sensitive information**, це є sensitive information leakage.

#### Tapjacking

Якщо Tapjacking не запобігається, ви можете зловживати exported activity, щоб змусити **користувача виконати несподівані дії**. For more info about [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Доступ та маніпуляція sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers зазвичай використовуються для **share data**. Якщо в додатку є доступні content providers, можливо, ви зможете **extract sensitive** дані з них. Також варто протестувати можливі **SQL injections** і **Path Traversals**, оскільки вони можуть бути вразливими.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Пам'ятайте, що дії Service починаються в методі `onStartCommand`.

Service по суті — це те, що **can receive data**, **process** її і **returns** (або ні) відповідь. Отже, якщо додаток експортує якісь services, вам слід **check** **code**, щоб зрозуміти, що він робить, і **test** його **dynamically** для витягання конфіденційної інформації, обходу заходів автентифікації...\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Пам'ятайте, що дії Broadcast Receiver починаються в методі `onReceive`.

Broadcast receiver чекатиме певного типу повідомлення. Залежно від того, як receiver обробляє повідомлення, він може бути вразливим.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

You can look for deep links manually, using tools like MobSF or scripts like [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Ви можете **відкрити** оголошену **scheme** за допомогою **adb** або **браузера**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Зверніть увагу, що ви можете **omit the package name**, і мобільний пристрій автоматично викличе app, який має відкрити це посилання._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Code executed**

Щоб знайти **code that will be executed in the App**, перейдіть до activity, що викликається deeplink, і знайдіть функцію **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Sensitive info**

Кожного разу, коли ви знаходите deep link, перевіряйте, що **it's not receiving sensitive data (like passwords) via URL parameters**, бо будь-який інший додаток може **impersonate the deep link and steal that data!**

**Parameters in path**

Ви **must check also if any deep link is using a parameter inside the path** URL, наприклад: `https://api.example.com/v1/users/{username}`. У такому випадку ви можете спричинити path traversal, отримавши доступ до чогось на кшталт: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Зверніть увагу, що якщо ви знайдете правильні endpoints всередині додатку, ви можете викликати **Open Redirect** (якщо частина шляху використовується як домен), **account takeover** (якщо можна змінити дані користувача без CSRF token і вразливий endpoint використовував правильний метод) та інші вразливості. More [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Transport Layer Inspection and Verification Failures

- **Certificates are not always inspected properly** додатками Android. Часто такі додатки ігнорують попередження і приймають self-signed certificates або в деяких випадках повертаються до HTTP-з’єднань.
- **Negotiations during the SSL/TLS handshake are sometimes weak**, використовуються небезпечні cipher suites. Це робить з’єднання вразливим до man-in-the-middle (MITM) атак, дозволяючи нападникам розшифровувати дані.
- **Leakage of private information** — ризик, коли додатки автентифікуються через secure channels, але потім виконують інші операції через non-secure channels. Такий підхід не захищає чутливі дані, як-от session cookies або user details, від перехоплення зловмисниками.

#### Certificate Verification

Ми зосередимось на **certificate verification**. Необхідно перевіряти цілісність server's certificate для підвищення безпеки. Це критично, оскільки insecure TLS configurations і передача чутливих даних по незашифрованих каналах можуть створювати значні ризики. For detailed steps on verifying server certificates and addressing vulnerabilities, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) provides comprehensive guidance.

#### SSL Pinning

SSL Pinning — це механізм безпеки, коли додаток перевіряє server's certificate проти відомої копії, збереженої всередині додатку. Цей метод є важливим для запобігання MITM атак. Рекомендується впроваджувати SSL Pinning для додатків, що працюють з чутливою інформацією.

#### Traffic Inspection

Щоб інспектувати HTTP traffic, потрібно **install the proxy tool's certificate** (наприклад, Burp). Якщо цей сертифікат не встановлено, зашифрований трафік може бути невидимим через проксі. For a guide on installing a custom CA certificate, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Додатки, що target **API Level 24 and above**, вимагають змін у Network Security Config, щоб приймати proxy's CA certificate. Це критичний крок для інспекції зашифрованого трафіку. Для інструкцій щодо модифікації Network Security Config, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

Якщо використовується **Flutter**, потрібно слідувати інструкціям на [**this page**](flutter.md). Це тому, що просте додавання сертифіката в store не спрацює — Flutter має свій власний список дійсних CAs.

#### Static detection of SSL/TLS pinning

Перед спробами runtime bypasses швидко відобразіть, де саме в APK застосовано pinning. Static discovery допомагає спланувати hooks/patches і зосередитись на потрібних code paths.

Tool: SSLPinDetect
- Open-source static-analysis utility, що декомпілює APK у Smali (через apktool) і сканує за curated regex patterns реалізацій SSL/TLS pinning.
- Reports exact file path, line number, and a code snippet for each match.
- Охоплює поширені frameworks і кастомні code paths: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Використання
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Приклад шаблонних правил (JSON)
Використовуйте або розширюйте signatures для виявлення proprietary/custom pinning styles. Ви можете завантажити власний JSON і сканувати в масштабі.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes and tips
- Швидке сканування великих додатків через multi-threading та memory-mapped I/O; попередньо скомпільовані regex зменшують накладні витрати/хибні спрацьовування.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Типові цілі виявлення для подальшого тріажу:
- OkHttp: використання CertificatePinner, setCertificatePinner, посилання на пакети okhttp3/okhttp
- Custom TrustManagers: javax.net.ssl.X509TrustManager, перевизначення checkServerTrusted
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init з кастомними managers
- Declarative pins у res/xml network security config та посилання в manifest
- Використовуйте знайдені місця для планування Frida hooks, static patches або перегляду конфігурацій перед dynamic testing.



#### Bypassing SSL Pinning

Коли реалізовано SSL Pinning, його bypassing стає необхідним для інспекції HTTPS-трафіку. Для цього існують різні методи:

- Автоматично **змінити** **apk**, щоб **bypass** SSLPinning за допомогою [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Найбільша перевага цього варіанту в тому, що для bypass SSL Pinning root не потрібен, але доведеться видалити додаток і перевстановити його, і це не завжди працює.
- Ви можете використати **Frida** (описано нижче) для bypass цього захисту. Ось гайд для використання Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Ви також можете спробувати **automatically bypass SSL Pinning** за допомогою [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Ви також можете спробувати **automatically bypass SSL Pinning** використовуючи **MobSF dynamic analysis** (описано нижче)
- Якщо ви все ще вважаєте, що частина трафіку не перехоплюється, можна спробувати **forward the traffic to burp using iptables**. Читайте цю статтю: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Looking for Common Web Vulnerabilities

Важливо також шукати загальні web-вразливості в додатку. Детальна інформація щодо ідентифікації та пом'якшення цих вразливостей виходить за рамки цього резюме, але детально описана в інших матеріалах.

### Frida

[Frida](https://www.frida.re) — це інструментарій динамічної інструментації для розробників, реверс-інженерів та дослідників безпеки.\
**Ви можете отримати доступ до працюючого додатку та hook methods під час виконання, щоб змінювати поведінку, змінювати значення, витягувати значення, запускати інший код...**\
Якщо ви хочете pentest Android-додатки, потрібно вміти користуватись Frida.

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Some "GUI" for actions with Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- You can find some Awesome Frida scripts here: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Try to bypass anti-debugging / anti-frida mechanisms loading Frida as in indicated in [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Дамп пам'яті - Fridump**

Перевірте, чи додаток не зберігає в пам'яті конфіденційну інформацію, якої не повинен зберігати, наприклад паролі або мнемонічні фрази.

Використовуючи [**Fridump3**](https://github.com/rootbsd/fridump3) ви можете зробити дамп пам'яті додатку за допомогою:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Це скине пам'ять у папку ./dump, і там ви можете за допомогою grep виконати щось на кшталт:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Чутливі дані в Keystore**

В Android Keystore — найкраще місце для зберігання чутливих даних, однак за наявності достатніх привілеїв все одно **можна отримати до нього доступ**. Оскільки додатки зазвичай тут зберігають **чутливі дані у відкритому вигляді**, pentests повинні перевіряти це як root user, інакше особа з фізичним доступом до пристрою може вкрасти ці дані.

Навіть якщо додаток зберіг дані в Keystore, ці дані мають бути зашифровані.

Щоб отримати доступ до даних всередині Keystore, можна використати цей Frida скрипт: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

За допомогою наведеного Frida script може стати можливим **bypass fingerprint authentication**, яке Android applications використовують для **захисту певних чутливих областей:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Фонові зображення**

Коли ви переводите додаток у фоновий режим, Android зберігає **знімок додатка**, тож під час відновлення на передній план він починає завантажувати це зображення перед самим додатком — це створює враження, що додаток відкрився швидше.

Однак, якщо цей знімок містить **чутливу інформацію**, хтось із доступом до нього може **вкрасти цю інформацію** (зверніть увагу, що для доступу потрібен root).

Знімки зазвичай зберігаються за шляхом: **`/data/system_ce/0/snapshots`**

Android надає спосіб **заборонити захоплення знімків екрана шляхом встановлення параметра макета FLAG_SECURE**. Використовуючи цей прапорець, вміст вікна позначається як захищений, що запобігає його появі у знімках екрана або перегляду на незахищених дисплеях.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Аналізатор Android-додатків**

Цей інструмент може допомогти в управлінні різними інструментами під час dynamic analysis: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Розробники часто створюють proxy components, такі як activities, services, і broadcast receivers, які обробляють ці Intents і передають їх у методи на кшталт `startActivity(...)` або `sendBroadcast(...)`, що може бути небезпечно.

Небезпека полягає в тому, що атакувальники можуть змусити виконати non-exported app components або отримати доступ до чутливих content providers, перенаправивши ці Intents. Яскравий приклад — компонент `WebView`, який конвертує URL у `Intent` через `Intent.parseUri(...)` і потім виконує їх, що потенційно може призвести до malicious Intent injections.

### Essential Takeaways

- **Intent Injection** is similar to web's Open Redirect issue.
- Exploits involve passing `Intent` objects as extras, which can be redirected to execute unsafe operations.
- It can expose non-exported components and content providers to attackers.
- `WebView`’s URL to `Intent` conversion can facilitate unintended actions.

### Android Client Side Injections and others

Ймовірно, ви вже знаєте про цей тип вразливостей з Web. Слід бути особливо обережним із цими вразливостями в Android-додатку:

- **SQL Injection:** При роботі з dynamic queries або Content-Providers переконайтеся, що ви використовуєте parameterized queries.
- **JavaScript Injection (XSS):** Переконайтеся, що JavaScript та Plugin support вимкнені для будь-яких WebViews (вимкнено за замовчуванням). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews повинні мати доступ до файлової системи вимкненим (увімкнено за замовчуванням) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: У кількох випадках, коли Android-додаток завершує сесію, cookie не відкликається або навіть може зберігатися на диску.
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Автоматичний аналіз

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Статичний аналіз**

![](<../../images/image (866).png>)

**Vulnerability assessment of the application** using a nice web-based frontend. You can also perform dynamic analysis (but you need to prepare the environment).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Assisted Dynamic analysis with MobSF

**MobSF** can also be very helpful for **dynamic analysis** in **Android**, but in that case you will need to install MobSF and **genymotion** in your host (a VM or Docker won't work). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
The **MobSF dynamic analyser** can:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). All of this is done automatically except for the screenshots, you need to press when you want a screenshot or you need to press "**Exported Activity Tester**" to obtain screenshots of all the exported activities.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Frida scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: It will print all the loaded classes
- **Capture Strings**: It will print all the capture strings while using the application (super noisy)
- **Capture String Comparisons**: Could be very useful. It will **show the 2 strings being compared** and if the result was True or False.
- **Enumerate Class Methods**: Put the class name (like "java.io.File") and it will print all the methods of the class.
- **Search Class Pattern**: Search classes by pattern
- **Trace Class Methods**: **Trace** a **whole class** (see inputs and outputs of all methods of the class). Remember that by default MobSF traces several interesting Android Api methods.

Once you have selected the auxiliary module you want to use you need to press "**Start Instrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf also brings you a shell with some **adb** commands, **MobSF commands**, and common **shell** **commands** at the bottom of the dynamic analysis page. Some interesting commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP tools**

When http traffic is capture you can see an ugly view of the captured traffic on "**HTTP(S) Traffic**" bottom or a nicer view in "**Start HTTPTools**" green bottom. From the second option, you can **send** the **captured requests** to **proxies** like Burp or Owasp ZAP.\
To do so, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> press "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Once you finish the dynamic analysis with MobSF you can press on "**Start Web API Fuzzer**" to **fuzz http requests** an look for vulnerabilities.

> [!TIP]
> After performing a dynamic analysis with MobSF the proxy settings me be misconfigured and you won't be able to fix them from the GUI. You can fix the proxy settings by doing:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Асистований динамічний аналіз з Inspeckage

You can get the tool from [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Цей інструмент використовує деякі **Hooks**, щоб повідомляти, **що відбувається в додатку**, поки ви виконуєте **динамічний аналіз**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

This is a **great tool to perform static analysis with a GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

This tool is designed to look for several **security related Android application vulnerabilities**, either in **source code** or **packaged APKs**. The tool is also **capable of creating a "Proof-of-Concept" deployable APK** and **ADB commands**, to exploit some of the found vulnerabilities (Exposed activities, intents, tapjacking...). As with Drozer, there is no need to root the test device.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Відображає всі вилучені файли для зручного перегляду
- Автоматично декомпілює APK файли в форматах Java та Smali
- Аналізує AndroidManifest.xml на наявність поширених вразливостей та поведінки
- Статичний аналіз вихідного коду на поширені вразливості та поведінку
- Інформація про пристрій
- та інше
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER — консольна програма, яку можна запускати у Windows, MacOS X та Linux, яка аналізує _.apk_ файли в пошуку вразливостей. Вона робить це, розпаковуючи APKs та застосовуючи серію правил для виявлення цих вразливостей.

Усі правила зібрані у файлі `rules.json`, і кожна компанія або тестувальник може створити власні правила для аналізу того, що їм потрібно.

Завантажте останні бінарні файли зі сторінки [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn — це **кросплатформний** інструмент, який допомагає розробникам, bugbounty hunters та ethical hackers виконувати [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) на мобільних застосунках.

Концепція полягає в тому, що ви перетягуєте файл вашого мобільного застосунку (.apk або .ipa) у застосунок StaCoAn, і він згенерує для вас візуальний та портативний звіт. Ви можете налаштувати параметри та wordlists, щоб отримати індивідуальний досвід.

Download[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework — це система аналізу вразливостей для Android, яка допомагає розробникам або hackers знаходити потенційні вразливості безпеки в Android-застосунках.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** — інструмент, основна мета якого — виявляти та попереджати користувача про потенційно шкідливу поведінку Android-застосунку.

Виявлення виконується за допомогою **static analysis** байткоду Dalvik застосунку, представленого як **Smali**, з використанням бібліотеки [`androguard`](https://github.com/androguard/androguard).

Цей інструмент шукає **common behavior of "bad" applications**, такі як: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** — це фреймворк для Mobile Application Reverse engineering and Analysis. Це інструмент, який об’єднує поширені інструменти для реверс-інжинірингу та аналізу мобільних додатків, щоб допомогти у тестуванні мобільних додатків на предмет загроз OWASP mobile security. Його мета — зробити це завдання простішим та зручнішим для mobile application developers і security professionals.

Він може:

- Extract Java and Smali code using different tools
- Analyze APKs using: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Extract private information from the APK using regexps.
- Analyze the Manifest.
- Analyze found domains using: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Корисно для виявлення malware: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Зверніть увагу, що в залежності від сервісу та конфігурації, яку ви використовуєте для обфускації коду, секрети можуть бути або не бути обфусцовані.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. It is able to optimize bytecode as well as detect and remove unused instructions. ProGuard is free software and is distributed under the GNU General Public License, version 2.

ProGuard розповсюджується як частина Android SDK і запускається при збірці застосунку в release-режимі.

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Last time we checked, the Dexguard mode of operation was:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

Ви можете завантажити обфусцований APK на їхню платформу.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

It is a **generic android deobfuscator.** Simplify **virtually executes an app** to understand its behavior and then **tries to optimize the code** so it behaves identically but is easier for a human to understand. Each optimization type is simple and generic, so it doesn't matter what the specific type of obfuscation is used.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD gives you information about **how an APK was made**. It identifies many **compilers**, **packers**, **obfuscators**, and other weird stuff. It's [_PEiD_](https://www.aldeid.com/wiki/PEiD) for Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b is an Android security virtual machine based on ubuntu-mate includes the collection of latest framework, tutorials and labs from different security geeks and researchers for reverse engineering and malware analysis.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Це чудовий список ресурсів
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)

## Yet to try

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
