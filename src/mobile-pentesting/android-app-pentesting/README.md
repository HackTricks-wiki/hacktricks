# Android Uygulamaları Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android Uygulamaları Temelleri

Bu sayfayı okumaya başlamanız, **Android güvenliğiyle ilgili en önemli kısımlar ve bir Android uygulamasındaki en tehlikeli bileşenler** hakkında bilgi sahibi olmanız açısından şiddetle tavsiye edilir:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Bu, bir Android cihaza (emüle edilmiş veya fiziksel) bağlanmak için ihtiyaç duyduğunuz ana araçtır.\
**ADB**, bir bilgisayardan **USB** veya **Network** üzerinden cihazları kontrol etmeye olanak tanır. Bu yardımcı araç, dosyaların her iki yönde **kopyalanmasını**, uygulamaların **kurulumunu** ve **kaldırılmasını**, shell komutlarının **çalıştırılmasını**, verilerin **yedeklenmesini**, logların **okunmasını** ve diğer işlevleri sağlar.

adb kullanmayı öğrenmek için aşağıdaki [**ADB Commands**](adb-commands.md) listesine göz atın.

## Smali

Bazen **uygulama code'unu değiştirmek** gizli bilgilere (ör. iyi obfuskelenmiş parolalar veya flag'ler) erişmek için ilginç olabilir. Bu durumda apk'yı decompile edip, code'u değiştirmek ve tekrar derlemek ilginç olabilir.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Bu, sunulacak dinamik analiz sırasında gerçekleştirilecek çeşitli testler için bir **alternatif** olarak çok yararlı olabilir. Bu olasılığı her zaman aklınızda bulundurun.

## Diğer ilginç püf noktaları

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **APK'leri indir**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Cihazdan APK çıkar:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Tüm split'leri ve base apk'ları [APKEditor](https://github.com/REAndroid/APKEditor) ile birleştirin:
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Android Enterprise & Work Profile Attacks

{{#ref}}
android-enterprise-work-profile-bypass.md
{{#endref}}

## Vaka Çalışmaları & Zayıflıklar


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Statik Analiz

Her şeyden önce, bir APK'yı analiz etmek için bir decompiler kullanarak **Java koduna bakmalısınız**.\
Lütfen, [**farklı kullanılabilir decompilerlar hakkında bilgi bulmak için burayı okuyun**](apk-decompilers.md).

### İlginç Bilgiler Arama

Sadece APK'nın **strings**'lerine bakarak **şifreler**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** anahtarları, **encryption**, **bluetooth uuids**, **tokens** ve ilginç olabilecek her şeyi arayabilirsiniz... hatta kod yürütme için **backdoors** veya kimlik doğrulama backdoor'ları (uygulamaya gömülü admin kimlik bilgileri) için bile bakın.

**Firebase**

Özellikle **firebase URL**'lerine dikkat edin ve kötü yapılandırılmış olup olmadığını kontrol edin. [Firebase'in ne olduğu ve nasıl sömürülebileceği hakkında daha fazla bilgi için buraya bakın.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Uygulamayı Temel Düzeyde Anlamak - Manifest.xml, strings.xml

Bir uygulamanın **_Manifest.xml_ ve **_strings.xml_** dosyalarının incelenmesi potansiyel güvenlik zafiyetlerini ortaya çıkarabilir**. Bu dosyalara decompilerlar ile erişilebileceği gibi APK dosya uzantısını .zip olarak değiştirip açarak da ulaşılabilir.

**Manifest.xml** dosyasından tespit edilebilecek **zayıflıklar** şunlardır:

- **Debuggable Applications**: _Manifest.xml_ dosyasında `debuggable="true"` olarak ayarlanmış uygulamalar risk oluşturur çünkü bağlantılara izin vererek sömürüye yol açabilir. Debuggable uygulamaların nasıl sömürüleceği hakkında daha fazla bilgi için debuggable uygulamaları cihaz üzerinde bulma ve sömürme ile ilgili bir eğitime bakın.
- **Backup Settings**: Hassas bilgilerle uğraşan uygulamalar için `android:allowBackup="false"` özelliğinin açıkça ayarlanması gerekir; aksi takdirde özellikle usb debugging etkinse adb üzerinden yetkisiz veri yedeklemelerine izin verilebilir.
- **Network Security**: _res/xml/_ içindeki özel ağ güvenlik yapılandırmaları (`android:networkSecurityConfig="@xml/network_security_config"`) certificate pinleri ve HTTP trafiği ayarları gibi güvenlik detaylarını belirtebilir. Örneğin belirli domainler için HTTP trafiğine izin verme gibi.
- **Exported Activities and Services**: Manifestte dışa açılmış activity ve servisleri belirlemek, kötüye kullanılabilecek bileşenleri ortaya çıkarabilir. Dinamik testler sırasında bu bileşenlerin nasıl sömürülebileceği daha fazla analizle görülebilir.
- **Content Providers and FileProviders**: Açıkta bırakılmış content provider'lar yetkisiz erişime veya veri değişikliğine izin verebilir. FileProvider yapılandırmaları da dikkatle incelenmelidir.
- **Broadcast Receivers and URL Schemes**: Bu bileşenler sömürü için kullanılabilir; özellikle URL şemalarının giriş doğrulaması açısından nasıl yönetildiğine dikkat edilmelidir.
- **SDK Versions**: `minSdkVersion`, `targetSDKVersion`, ve `maxSdkVersion` öznitelikleri desteklenen Android sürümlerini gösterir; artık desteklenmeyen, zafiyetli Android sürümlerine destek verilmemesinin önemi burada ortaya çıkar.

**strings.xml** dosyasından API anahtarları, özel şemalar ve diğer geliştirici notları gibi hassas bilgiler keşfedilebilir; bu kaynakların dikkatle incelenmesi gerekir.

### Tapjacking

Tapjacking, kötü niyetli bir uygulamanın başlatılarak **victim application**'ın üstüne konumlandırılması ile yapılan bir saldırıdır. Bir kere victim uygulamayı görünür şekilde örttüğünde, kullanıcıyı kandıracak şekilde tasarlanmış bir kullanıcı arayüzü ile etkileşim sağlamaya çalışır; bu etkileşim aynı zamanda victim uygulamaya iletilir.\
Sonuç olarak, kullanıcı aslında victim uygulama üzerinde işlem yaptığını bilmeyecek şekilde **körleştirilir**.

Daha fazla bilgi için:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Bir **activity**'nin **`launchMode`** değeri **`singleTask` olup herhangi bir `taskAffinity`** tanımlanmamışsa task Hijacking'e karşı savunmasızdır. Bu, kötü niyetli bir uygulamanın kurulup gerçek uygulamadan önce başlatılması durumunda **gerçek uygulamanın task'ını ele geçirebileceği** anlamına gelir (yani kullanıcı gerçek uygulamayı kullandığını düşünerek **kötü amaçlı uygulama ile etkileşime girecektir**).

Daha fazla bilgi:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Güvensiz veri depolama

**Dahili Depolama**

Android'de dahili depolamada saklanan dosyalar, bunları oluşturan **uygulama tarafından erişilebilir** olacak şekilde tasarlanmıştır. Bu güvenlik önlemi Android işletim sistemi tarafından uygulanır ve çoğu uygulamanın güvenlik ihtiyaçları için genellikle yeterlidir. Ancak geliştiriciler bazen `MODE_WORLD_READABLE` ve `MODE_WORLD_WRITABLE` gibi modları kullanarak dosyaların farklı uygulamalar arasında **paylaşılmasına izin verirler**. Bu modlar, bu dosyalara diğer uygulamalar tarafından, potansiyel olarak kötü amaçlı olanlar dahil, erişimi **kısıtlamaz**.

1. **Statik Analiz:**
- `MODE_WORLD_READABLE` ve `MODE_WORLD_WRITABLE` kullanımının **dikkatle incelenmesini** sağlayın. Bu modlar dosyaların **istem dışı veya yetkisiz erişime** maruz kalmasına yol açabilir.
2. **Dinamik Analiz:**
- Uygulama tarafından oluşturulan dosyalara ayarlanmış **izinleri doğrulayın**. Özellikle herhangi bir dosyanın **dünya tarafından okunabilir veya yazılabilir** olarak ayarlanıp ayarlanmadığını **kontrol edin**. Bu, cihazda yüklü herhangi bir uygulamanın, kaynağı veya amacı ne olursa olsun, bu dosyaları **okumasına veya değiştirmesine** izin verebileceği için ciddi bir güvenlik riski oluşturur.

**Harici Depolama**

SD Kart gibi **harici depolama**daki dosyalarla uğraşırken bazı önlemler alınmalıdır:

1. **Erişilebilirlik**:
- Harici depolamadaki dosyalar **global olarak okunabilir ve yazılabilir**dir. Bu, herhangi bir uygulamanın veya kullanıcının bu dosyalara erişebileceği anlamına gelir.
2. **Güvenlik Endişeleri**:
- Erişimin kolaylığı nedeniyle hassas bilgileri harici depolamada saklamamanız önerilir.
- Harici depolama çıkarılabilir veya herhangi bir uygulama tarafından erişilebilir olduğundan daha az güvenlidir.
3. **Harici Depolamadan Veri İşleme**:
- Harici depolamadan alınan veriler üzerinde her zaman **girdi doğrulaması** yapın. Bu önemlidir çünkü veri güvenilmeyen bir kaynaktan gelmektedir.
- Harici depolamada yürütülebilir veya class dosyalarının dinamik olarak yüklenmesi için saklanması şiddetle tavsiye edilmez.
- Uygulamanızın harici depolamadan yürütülebilir dosyalar alması gerekiyorsa, bu dosyaların dinamik olarak yüklenmeden önce **imzalanmış ve kriptografik olarak doğrulanmış** olmasını sağlayın. Bu adım uygulamanızın güvenlik bütünlüğü için hayati önemdedir.

Harici depolamaya `/storage/emulated/0`, `/sdcard`, `/mnt/sdcard` üzerinden erişilebilir.

> [!TIP]
> Android 4.4 (**API 17**) ile başlayarak, SD kartın dizin yapısı **bir uygulamanın yalnızca o uygulamaya özel dizine erişimini sınırlayan** bir yapı içerir. Bu, kötü niyetli bir uygulamanın başka bir uygulamanın dosyalarına okuma veya yazma erişimi kazanmasını engeller.

**Düz metin olarak saklanan hassas veriler**

- **Shared preferences**: Android her uygulamanın kolayca xml dosyaları `/data/data/<packagename>/shared_prefs/` yoluna kaydetmesine izin verir ve bazen bu klasörde düz metin olarak hassas bilgiler bulunabilir.
- **Databases**: Android her uygulamanın kolayca sqlite veritabanlarını `/data/data/<packagename>/databases/` yoluna kaydetmesine izin verir ve bazen bu klasörde düz metin olarak hassas bilgiler bulunabilir.

### Broken TLS

**Accept All Certificates**

Bazı nedenlerden dolayı geliştiriciler bazen hostname eşleşmese bile tüm sertifikaları kabul ederler; örneğin aşağıdaki gibi kod satırlarıyla:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Bunu test etmenin iyi bir yolu, cihaz içinde Burp CA'yı yetkilendirmeden Burp gibi bir proxy kullanarak trafiği yakalamaya çalışmaktır. Ayrıca Burp ile farklı bir hostname için bir sertifika oluşturup onu kullanabilirsiniz.

### Broken Cryptography

**Poor Key Management Processes**

Bazı geliştiriciler hassas verileri local storage'da saklayıp kod içinde hardcoded/öngörülebilir bir anahtarla encrypt eder. Bu yapılmamalıdır çünkü bazı reversing teknikleri saldırganların gizli bilgileri çıkarmasına izin verebilir.

**Use of Insecure and/or Deprecated Algorithms**

Geliştiriciler yetkilendirme **checks** yapmak, veriyi **store** etmek veya **send** etmek için **deprecated algorithms** kullanmamalıdır. Bu algoritmalardan bazıları: RC4, MD4, MD5, SHA1... Örneğin şifreleri saklamak için **hashes** kullanılıyorsa, salt ile birlikte brute-force **resistant** hash'ler kullanılmalıdır.

### Other checks

- APK'yı ters mühendislik işini zorlaştırmak için **obfuscate the APK** yapmanız önerilir.
- Uygulama hassassa (örn. bankacılık uygulamaları gibi), mobilin **rooted** olup olmadığını kontrol etmelidir ve duruma göre davranmalıdır.
- Uygulama hassassa (örn. bankacılık uygulamaları gibi), bir **emulator** kullanılıp kullanılmadığını kontrol etmelidir.
- Uygulama hassassa (örn. bankacılık uygulamaları gibi), çalıştırmadan önce **kendi integrity'sini check etmelidir**; böylece değiştirildiğini anlayabilir.
- Hangi compiler/packer/obfuscator kullanılarak APK oluşturulduğunu kontrol etmek için [**APKiD**](https://github.com/rednaga/APKiD) kullanın

### React Native Application

React uygulamalarının javascript koduna kolayca nasıl erişileceğini öğrenmek için aşağıdaki sayfayı okuyun:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Bir xamarin uygulamasının C# koduna kolayca nasıl erişeceğinizi öğrenmek için aşağıdaki sayfayı okuyun:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

Bu [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) göre superpacked, bir uygulamanın içeriğini tek bir dosyaya sıkıştıran bir Meta algoritmasıdır. Blog, bu tür uygulamaları dekompres eden bir uygulama oluşturma ihtimalinden ve dosyaları elde etmek için **uygulamayı çalıştırıp filesystem'ten dekompres edilmiş dosyaları toplama** gibi daha hızlı bir yöntemden bahsediyor.

### Automated Static Code Analysis

[**mariana-trench**](https://github.com/facebook/mariana-trench) aracı, uygulamanın **kodunu** **scanning** yaparak **vulnerabilities** bulabilir. Bu araç, araca **input**'un **kullanıcı tarafından kontrol edildiği** **yerleri** gösteren bir dizi **known sources**, kötü niyetli kullanıcı girdisinin zarara yol açabileceği **dangerous places** gösteren **sinks** ve **rules** içerir. Bu kurallar, bir vulnerability'yi gösterecek **sources-sinks** kombinasyonlarını belirtir.

Bu bilgi ile **mariana-trench kodu gözden geçirir ve olası vulnerability'leri bulur**.

### Secrets leaked

Bir uygulama içinde keşfedebileceğiniz sırlar (API keys, şifreler, gizli url'ler, subdomain'ler...) olabilir. Böyle bir durumda [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks) gibi bir araç kullanabilirsiniz.

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)
- JNI aracılığıyla bellek içi native kod çalıştırma (indirilen shellcode → mmap/mprotect → çağır):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> Öncelikle uygulamayı ve tüm ortamı (Burp CA sertifikası, Drozer ve Frida başta olmak üzere) kurabileceğiniz bir ortama ihtiyacınız var. Bu yüzden bir rooted cihaz (emüle edilmiş veya değil) kesinlikle önerilir.

### Online Dynamic analysis

Ücretsiz bir hesap oluşturabilirsiniz: [https://appetize.io/](https://appetize.io). Bu platform APK yüklemeye ve çalıştırmaya izin verir; bu da bir apk'nın nasıl davrandığını görmek için faydalıdır.

Web üzerinden uygulamanızın log'larını bile görebilir ve **adb** ile bağlanabilirsiniz.

![](<../../images/image (831).png>)

ADB bağlantısı sayesinde emülatör içinde **Drozer** ve **Frida** kullanabilirsiniz.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (x86 ve arm cihazlar oluşturabilirsiniz; ve [**this**](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html) göre **latest x86** sürümleri ARM kütüphanelerini yavaş arm emülatörüne gerek kalmadan destekler).
- Kurulumunu bu sayfada öğrenin:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, bir hesap oluşturmanız gerekir. _POTANSİYEL HATALARDAN KAÇINMAK İÇİN VirtualBox İLE birlikte olan sürümü **download** etmeniz önerilir._)
- [**Nox**](https://es.bignox.com) (Ücretsiz, ancak Frida veya Drozer'ı desteklemiyor).

> [!TIP]
> Herhangi bir platformda yeni bir emulator oluştururken ekran ne kadar büyükse emulator o kadar yavaş çalışır. Mümkünse küçük ekranları seçin.

Genymotion'da google servislerini (ör. AppStore) **install** etmek için aşağıdaki görüntüde kırmızı ile işaretlenmiş butona tıklamanız gerekir:

![](<../../images/image (277).png>)

Ayrıca, **Genymotion içindeki Android VM konfigürasyonunda** **Bridge Network mode** seçebileceğinizi unutmayın (bu, araçların bulunduğu farklı bir VM'den Android VM'ye bağlanacaksanız faydalı olacaktır).

#### Use a physical device

**Debugging** seçeneklerini etkinleştirmeniz gerekir ve mümkünse cihazı **root** etmeniz iyi olur:

1. **Settings**.
2. (Android 8.0 ve sonrası) **System** seçin.
3. **About phone** seçin.
4. **Build number** üzerine 7 kez basın.
5. Geri dönün ve **Developer options**'ı bulacaksınız.

> Uygulamayı yükledikten sonra yapmanız gereken ilk şey onu çalıştırmak, ne yaptığını ve nasıl çalıştığını araştırmak ve rahat olmaktır.\
> İlk dynamic analysis'i MobSF dynamic analysis + pidcat kullanarak yapmanızı öneririm; böylece uygulamanın nasıl çalıştığını öğrenirken MobSF birçok ilginç veriyi **capture** eder ve daha sonra inceleyebilirsiniz.

Magisk/Zygisk kısa notlar (Pixel cihazlarda önerilir)
- systemless root elde etmek için Magisk uygulamasıyla boot.img'yi patch'leyip fastboot ile flashlayın
- root gizlemek için Zygisk + DenyList'i etkinleştirin; daha güçlü gizleme gerektiğinde LSPosed/Shamiko düşünün
- OTA güncellemelerinden kurtulmak için orijinal boot.img'yi saklayın; her OTA'dan sonra yeniden patch'leyin
- ekran yansıtma için host üzerinde scrcpy kullanın



### Unintended Data Leakage

**Logging**

Geliştiriciler, **debugging information**'ı açıkça ortaya çıkarmakta dikkatli olmalıdır; çünkü bu hassas verilerin leak olmasına yol açabilir. Uygulama loglarını izlemek ve hassas bilgileri tespit etmek için [**pidcat**](https://github.com/JakeWharton/pidcat) ve `adb logcat` araçları önerilir. **Pidcat** kullanım kolaylığı ve okunabilirliği nedeniyle tercih edilir.

> [!WARNING]
> **Android 4.0**'dan daha yeni sürümlerde **uygulamalar sadece kendi loglarına erişebilir**. Yani uygulamalar diğer uygulamaların loglarına erişemez.\
> Yine de, hassas bilgileri loglamamak hala önerilir.

**Copy/Paste Buffer Caching**

Android'in **clipboard-based** framework'ü uygulamalarda kopyala-yapıştır işlevselliği sağlar, ancak diğer uygulamaların clipboard'a erişebilmesi nedeniyle hassas verilerin ifşa edilmesi riski vardır. Kredi kartı bilgileri gibi hassas uygulama bölümlerinde kopyala/yapıştır fonksiyonlarını devre dışı bırakmak önemlidir, böylece veri leaks önlenir.

**Crash Logs**

Bir uygulama **crash** yapıp log kaydederse, bu loglar özellikle uygulama tersine mühendislik yapılamıyorsa saldırganlara yardımcı olabilir. Bu riski azaltmak için crash durumlarında log tutmaktan kaçının; eğer loglar network üzerinden gönderilecekse güvenlik için SSL kanalı ile gönderildiğinden emin olun.

Bir pentester olarak, bu loglara **bakmaya çalışın**.

**Analytics Data Sent To 3rd Parties**

Uygulamalar sıklıkla Google Adsense gibi servisleri entegre eder; geliştiriciler yanlış uygulama yaparsa bu servisler hassas verileri istemeden leak edebilir. Olası veri leaks'lerini tespit etmek için uygulamanın trafiğini intercept edip üçüncü taraf servislere hassas bilgi gönderilip gönderilmediğini kontrol etmek önerilir.

### SQLite DBs

Çoğu uygulama bilgi saklamak için **internal SQLite databases** kullanır. Pentest sırasında oluşturulan **databaseları**, **table** ve **column** isimlerini ve saklanan tüm **data**yı inceleyin; çünkü hassas bilgi (bu bir vulnerability olur) bulabilirsiniz.\
Databaseler genellikle `/data/data/the.package.name/databases` içinde bulunur, örneğin `/data/data/com.mwr.example.sieve/databases`

Eğer database gizli bilgileri saklıyor ve **encrypted** ise fakat şifreyi uygulama içinde **bulabiliyorsanız**, bu yine bir **vulnerability**'dir.

Tabloları `.tables` ile, tabloların kolonlarını ise `.schema <table_name>` ile enumerate edin.

### Drozer (Exploit Activities, Content Providers and Services)

Drozer Docs'tan: [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf) — **Drozer**, size bir Android uygulaması rolünü üstlenme ve diğer uygulamalarla etkileşim kurma imkanı verir. Yüklü bir uygulamanın yapabileceği her şeyi yapabilir; örneğin Android’in Inter-Process Communication (IPC) mekanizmasını kullanabilir ve alt işletim sistemi ile etkileşime girebilir. .\
Drozer, ihraç edilmiş activities, exported services ve Content Providers'ı **exploit etmek** için faydalı bir araçtır; bunu sonraki bölümlerde öğreneceksiniz.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Ayrıca bir activity'nin kodunun **`onCreate`** metodunda başladığını unutmayın.

**Authorisation bypass**

Bir Activity exported ise ekranını dış bir uygulamadan çağırabilirsiniz. Bu nedenle, eğer **hassas bilgi** içeren bir activity **exported** ise, ona erişmek için **authentication** mekanizmalarını **bypass** edebilirsiniz.

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

Ayrıca adb'den bir exported activity'i başlatabilirsiniz:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> Yetkilendirme bypass'ının her zaman bir güvenlik açığı olmadığını unutmayın; bunun nasıl çalıştığına ve hangi bilgilerin açığa çıktığına bağlıdır.

**Hassas bilgi sızıntısı**

Activity'ler aynı zamanda sonuç döndürebilir. Eğer dışa açılmış ve korunmasız bir activity bulup `setResult` metodunu çağırıp **hassas bilgileri döndürdüğünü** tespit ederseniz, bu bir hassas bilgi sızıntısıdır.

#### Tapjacking

Eğer Tapjacking önlenmemişse, dışa açılmış activity'yi kötüye kullanarak **kullanıcının beklenmeyen işlemler yapmasını** sağlayabilirsiniz. Tapjacking'in ne olduğunu öğrenmek için daha fazla bilgiye [**buradan**](#tapjacking) ulaşabilirsiniz.

### Exploiting Content Providers - Hassas bilgilerin erişimi ve manipülasyonu

[**Content Provider'ın ne olduğunu tazelemek istiyorsanız bunu okuyun.**](android-applications-basics.md#content-provider)\
Content providers temelde **veri paylaşmak** için kullanılır. Eğer bir uygulamanın kullanılabilir content provider'ları varsa, bunlardan **hassas verileri çıkarmayı** başarabilirsiniz. Ayrıca olası **SQL injections** ve **Path Traversals**'ı test etmek ilginçtir çünkü zafiyetli olabilirler.

[**Drozer ile Content Providers nasıl exploit edilir öğrenin.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Service nedir hatırlamak isterseniz bunu okuyun.**](android-applications-basics.md#services)\
Unutmayın ki bir Service'in işlemleri `onStartCommand` metodunda başlar.

Service esasen **veri alabilen**, **işleyebilen** ve (veya) bir yanıt **döndürebilen** bir bileşendir. Bu nedenle, bir uygulama bazı service'leri export ediyorsa kodu **kontrol etmeli**, ne yaptığını anlamalı ve gizli bilgileri çıkarmak, yetkilendirme önlemlerini bypass etmek gibi amaçlarla **dinamik** olarak **test** etmelisiniz.\
[**Drozer ile Services nasıl exploit edilir öğrenin.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Broadcast Receiver nedir hatırlamak isterseniz bunu okuyun.**](android-applications-basics.md#broadcast-receivers)\
Unutmayın ki bir Broadcast Receiver'ın işlemleri `onReceive` metodunda başlar.

Bir broadcast receiver belirli bir mesaj türünü bekler. Alıcının mesajı nasıl ele aldığına bağlı olarak zafiyetli olabilir.\
[**Drozer ile Broadcast Receivers nasıl exploit edilir öğrenin.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Deep links'i manuel olarak, MobSF gibi araçlar veya [bu script](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py) gibi scriptlerle arayabilirsiniz.\
Beyan edilmiş bir **scheme**'i **adb** veya bir **browser** ile açabilirsiniz:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Unutmayın ki paket adını **atlayabilirsiniz** ve mobil otomatik olarak bu bağlantıyı açacak uygulamayı çağırır._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Çalıştırılan kod**

Uygulamada çalıştırılacak **kodu bulmak için**, deeplink tarafından çağrılan activity'ye gidin ve **`onNewIntent`** fonksiyonunu arayın.

![](<../../images/image (436) (1) (1) (1).png>)

**Hassas bilgi**

Her deep link bulduğunuzda, **URL parametreleri aracılığıyla hassas veri (ör. şifreler) almadığından** emin olun, çünkü herhangi başka bir uygulama **deep link'i taklit edip bu veriyi çalabilir!**

**Path içindeki parametreler**

Ayrıca herhangi bir deep link'in URL'nin path bölümünde bir parametre kullanıp kullanmadığını kontrol etmelisiniz; örneğin: `https://api.example.com/v1/users/{username}`. Bu durumda path traversal zorlayarak şu şekilde erişim sağlayabilirsiniz: `example://app/users?username=../../unwanted-endpoint%3fparam=value`.  
Doğru endpoint'leri uygulama içinde bulursanız **Open Redirect** (path'in bir kısmı domain adı olarak kullanılıyorsa), **account takeover** (kullanıcı detaylarını CSRF token olmadan değiştirebiliyorsanız ve zafiyetli endpoint doğru yöntemi kullanıyorsa) ve diğer zafiyetlere neden olabilirsiniz. Daha fazla [bilgi burada](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

Bir [interesting bug bounty report](https://hackerone.com/reports/855618) linklerle ilgili (_/.well-known/assetlinks.json_).

### Transport Layer Inspection and Verification Failures

- **Sertifikalar her zaman düzgün şekilde incelenmez** Android uygulamaları tarafından. Bu uygulamaların uyarıları göz ardı edip kendi imzalı (self-signed) sertifikaları kabul etmeleri veya bazı durumlarda HTTP bağlantılarına geri dönmeleri yaygındır.
- **SSL/TLS el sıkışması sırasında müzakereler bazen zayıftır**, güvensiz cipher suite'ler kullanılabilir. Bu zafiyet bağlantıyı man-in-the-middle (MITM) saldırılarına karşı savunmasız bırakır ve saldırganların veriyi deşifre etmesine olanak tanır.
- **Leakage of private information** uygulamaların güvenli kanallarla kimlik doğrulaması yapıp diğer işlemler için güvenli olmayan kanallar üzerinden iletişim kurması durumunda bir risktir. Bu yaklaşım session cookies veya kullanıcı bilgileri gibi hassas verileri kötü niyetli aktörlerin ele geçirmesinden korumaz.

#### Certificate Verification

Bu bölümde **sertifika doğrulama** üzerine odaklanacağız. Sunucunun sertifikasının bütünlüğü güvenliği artırmak için doğrulanmalıdır. Güvensiz TLS konfigürasyonları ve hassas verilerin şifrelenmemiş kanallar üzerinden iletilmesi ciddi riskler oluşturabilir. Sunucu sertifikalarını doğrulama ve zafiyetleri giderme adımları için detaylı rehber [**bu kaynakta**](https://manifestsecurity.com/android-application-security-part-10/) mevcuttur.

#### SSL Pinning

SSL Pinning, uygulamanın sunucunun sertifikasını uygulama içinde saklanan bilinen bir kopyaya karşı doğruladığı bir güvenlik önlemidir. Bu yöntem MITM saldırılarını önlemek için kritiktir. Hassas bilgi işleyen uygulamalar için SSL Pinning uygulanması şiddetle tavsiye edilir.

#### Traffic Inspection

HTTP trafiğini incelemek için **proxy aracının sertifikasını yüklemeniz** gerekir (ör. Burp). Bu sertifika yüklenmezse, şifreli trafik proxy üzerinden görünmeyebilir. Özel bir CA sertifikasının nasıl yükleneceğine dair rehber için [**buraya tıklayın**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

**API Level 24 and above** hedefleyen uygulamalar, proxy'nin CA sertifikasını kabul etmek için Network Security Config'te değişiklik yapılmasını gerektirir. Bu adım şifreli trafiği incelemek için kritiktir. Network Security Config'i nasıl değiştireceğinize dair talimatlar için [**bu eğitime bakın**](make-apk-accept-ca-certificate.md).

Eğer **Flutter** kullanılıyorsa, [**bu sayfadaki**](flutter.md) talimatları takip etmelisiniz. Bunun sebebi sadece sertifikayı store'a eklemenin yeterli olmaması; Flutter'ın kendi geçerli CA listesi olmasıdır.

#### Static detection of SSL/TLS pinning

Çalışma zamanı bypass denemelerine başlamadan önce, pinlemenin APK içinde nerelerde uygulandığını hızlıca haritalayın. Statik keşif, hook/patch planlamanıza ve doğru kod yollarına odaklanmanıza yardımcı olur.

Tool: SSLPinDetect
- Açık kaynaklı statik analiz aracı; APK'yı Smali'ye decompile eder (apktool aracılığıyla) ve SSL/TLS pinning uygulamalarına ait özenle seçilmiş regex kalıplarını tarar.
- Her eşleşme için tam dosya yolu, satır numarası ve bir kod snippet'i raporlar.
- Ortak framework'leri ve özel kod yollarını kapsar: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, ve Network Security Config XML pinleri.

Install
- Önkoşullar: Python >= 3.8, Java PATH üzerinde, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Kullanım
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Örnek desen kuralları (JSON)
Özel/özelleştirilmiş pinning stillerini tespit etmek için signatures kullanın veya genişletin. Kendi JSON'unuzu yükleyebilir ve geniş ölçekli tarama yapabilirsiniz.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notlar ve ipuçları
- Büyük uygulamalarda fast scanning için multi-threading ve memory-mapped I/O kullanın; önceden derlenmiş regex overhead/false positive'ları azaltır.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Sonraki önceliklendirme için tipik tespit hedefleri:
- OkHttp: CertificatePinner kullanımı, setCertificatePinner, okhttp3/okhttp paket referansları
- Özel TrustManager'lar: javax.net.ssl.X509TrustManager, checkServerTrusted override'ları
- Özel SSL context'leri: SSLContext.getInstance + SSLContext.init ile custom managers
- res/xml network security config içindeki deklaratif pin'ler ve manifest referansları
- Eşleşen konumları, dinamik testten önce Frida hook'ları, statik patch'ler veya konfigürasyon incelemeleri planlamak için kullanın.



#### SSL Pinning'i Bypass Etme

SSL Pinning uygulandığında, HTTPS trafiğini incelemek için bunu bypass etmek gerekir. Bu amaçla çeşitli yöntemler mevcuttur:

- Otomatik olarak **apk**'yi [**apk-mitm**](https://github.com/shroudedcode/apk-mitm) ile **modify** edip SSLPinning'i **bypass** edebilirsiniz. Bu seçeneğin en büyük avantajı SSL Pinning'i bypass etmek için root gerekmemesi, ancak uygulamayı silip yeniden yüklemeniz gerekecek ve her zaman işe yaramayabilir.
- Bu korumayı bypass etmek için **Frida** (aşağıda tartışılıyor) kullanabilirsiniz. Burp+Frida+Genymotion kullanımı için kılavuz: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Ayrıca [**objection**](frida-tutorial/objection-tutorial.md) kullanarak **otomatik olarak SSL Pinning'i bypass etmeyi** deneyebilirsiniz:**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Ayrıca **MobSF dynamic analysis** (aşağıda açıklanıyor) kullanarak **otomatik olarak SSL Pinning'i bypass etmeyi** deneyebilirsiniz
- Hâlâ yakalayamadığınız trafik olduğunu düşünüyorsanız trafiği iptables kullanarak burp'a yönlendirmeyi deneyebilirsiniz. Bu blogu okuyun: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Yaygın Web Zafiyetlerini Arama

Uygulama içinde yaygın web zafiyetlerini aramak da önemlidir. Bu zafiyetleri tespit etme ve hafifletme konusundaki ayrıntılı bilgiler bu özetin kapsamı dışında olup başka yerlerde genişçe ele alınmıştır.

### Frida

[Frida](https://www.frida.re) geliştiriciler, reverse-engineers ve güvenlik araştırmacıları için dinamik enstrümantasyon araç takımıdır.\
**Çalışan uygulamaya erişip çalışma zamanında method'lara hook atarak davranışı değiştirebilir, değerleri değiştirebilir, değer çıkarabilir, farklı kod çalıştırabilirsiniz...**\
Android uygulamalarını pentest etmek istiyorsanız Frida'yı kullanmayı bilmeniz gerekir.

- Frida kullanmayı öğrenin: [**Frida tutorial**](frida-tutorial/index.html)
- Frida ile eylemler için bazı "GUI"ler: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection, Frida kullanımını otomatikleştirmek için harikadır: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Bazı Awesome Frida script'lerini burada bulabilirsiniz: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Anti-debugging / anti-frida mekanizmalarını atlatmayı deneyin; Frida'yı şu şekilde yükleyin: [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (araç [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Bellek Dökümü - Fridump**

Uygulamanın şifreler veya mnemonics gibi bellekte saklanmaması gereken hassas bilgileri bellekte saklayıp saklamadığını kontrol edin.

[**Fridump3**](https://github.com/rootbsd/fridump3) kullanarak uygulamanın belleğini şu komutla dökebilirsiniz:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Bu, belleği ./dump klasörüne dump edecek ve orada şöyle bir şeyle grep yapabilirsiniz:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Keystore'daki hassas veriler**

Android'de Keystore hassas verileri depolamak için en iyi yerdir, ancak yeterli ayrıcalıklara sahip olunursa yine de **erişmek mümkün olabilir**. Uygulamalar burada genellikle **hassas verileri açık metin olarak** depolamaya eğilimli olduğundan, pentests bunu kontrol etmelidir; aksi takdirde root user veya cihaza fiziksel erişimi olan kişiler bu verileri çalabilir.

Bir uygulama Keystore'a veri depolasa bile, veriler şifrelenmiş olmalıdır.

Keystore içindeki verilere erişmek için şu Frida script'ini kullanabilirsiniz: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Aşağıdaki Frida script'ini kullanarak Android uygulamalarının belirli hassas alanları korumak için gerçekleştirdiği **bypass fingerprint authentication** işlemini atlamak mümkün olabilir:
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Arka Plan Görüntüleri**

Bir uygulamayı arka plana aldığınızda, Android uygulamanın bir **anlık görüntüsünü** saklar; böylece uygulama öne alındığında uygulamadan önce bu görüntüyü yüklemeye başlar ve uygulama daha hızlı yüklenmiş gibi görünür.

Ancak bu anlık görüntü **hassas bilgiler** içeriyorsa, anlık görüntüye erişimi olan biri bu bilgileri **çalabilir** (erişim için root gerektiğini unutmayın).

Anlık görüntüler genellikle şu konumda saklanır: **`/data/system_ce/0/snapshots`**

Android, **FLAG_SECURE ayarlanarak ekran görüntüsü alınmasını engelleme** yolu sağlar. Bu flag kullanıldığında, pencere içeriği güvenli kabul edilir; böylece içeriğin ekran görüntülerinde görünmesi veya güvenli olmayan ekranlarda görüntülenmesi engellenir.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Bu araç, dinamik analiz sırasında farklı araçları yönetmende yardımcı olabilir: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Geliştiriciler genellikle bu Intents'i işleyen ve bunları `startActivity(...)` veya `sendBroadcast(...)` gibi yöntemlere ileten activities, services ve broadcast receivers gibi proxy bileşenler oluşturur; bu riskli olabilir.

Tehlike, saldırganların bu Intents'i yanlış yönlendirerek non-exported uygulama bileşenlerini tetiklemesine veya hassas content providers'a erişmesine izin verilmesindedir. Önemli bir örnek, `WebView` bileşeninin URL'leri `Intent.parseUri(...)` ile `Intent` nesnelerine dönüştürmesi ve sonra bunları çalıştırmasıdır; bu da potansiyel olarak kötü amaçlı Intent enjeksiyonlarına yol açabilir.

### Essential Takeaways

- **Intent Injection** web'in Open Redirect sorununa benzer.
- Exploit'ler, `Intent` nesnelerinin extras olarak geçirilmesini içerir; bunlar yönlendirilerek güvensiz işlemleri çalıştırabilir.
- Bu, non-exported bileşenleri ve content providers'ı saldırganlara maruz bırakabilir.
- `WebView`'in URL'den `Intent` dönüşümü istenmeyen eylemleri kolaylaştırabilir.

### Android Client Side Injections and others

Muhtemelen bu tür zafiyetleri Web'den biliyorsunuzdur. Android uygulamalarında bu zafiyetlere özellikle dikkat etmelisiniz:

- **SQL Injection:** Dinamik sorgular veya Content-Providers ile uğraşırken parameterized queries kullandığınızdan emin olun.
- **JavaScript Injection (XSS):** Herhangi bir WebView için JavaScript ve Plugin desteğinin devre dışı olduğundan emin olun (varsayılan olarak devre dışıdır). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebView'lerin dosya sistemine erişiminin devre dışı olması gerekir (varsayılan olarak etkin) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: Bazı durumlarda android uygulama oturumu kapattığında cookie iptal edilmez veya hatta diske kaydedilebilir
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Otomatik Analiz

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Statik analiz**

![](<../../images/image (866).png>)

**Uygulamanın zayıflık değerlendirmesi** güzel bir web tabanlı frontend kullanılarak yapılır. Dinamik analiz de gerçekleştirebilirsiniz (ancak ortamı hazırlamanız gerekir).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Assisted Dynamic analysis with MobSF

**MobSF** can also be very helpful for **dynamic analysis** in **Android**, but in that case you will need to install MobSF and **genymotion** in your host (a VM or Docker won't work). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
The **MobSF dynamic analyser** can:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). All of this is done automatically except for the screenshots, you need to press when you want a screenshot or you need to press "**Exported Activity Tester**" to obtain screenshots of all the exported activities.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: It will print all the loaded classes
- **Capture Strings**: It will print all the capture strings while using the application (super noisy)
- **Capture String Comparisons**: Could be very useful. It will **show the 2 strings being compared** and if the result was True or False.
- **Enumerate Class Methods**: Put the class name (like "java.io.File") and it will print all the methods of the class.
- **Search Class Pattern**: Search classes by pattern
- **Trace Class Methods**: **Trace** a **whole class** (see inputs and outputs of all methods of the class). Remember that by default MobSF traces several interesting Android Api methods.

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf also brings you a shell with some **adb** commands, **MobSF commands**, and common **shell** **commands** at the bottom of the dynamic analysis page. Some interesting commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP araçları**

HTTP trafiği yakalandığında, yakalanan trafiğin çirkin bir görünümünü "**HTTP(S) Traffic**" butonunda veya daha düzgün bir görünümü "**Start HTTPTools**" yeşil butonunda görebilirsiniz. İkinci seçenekten, **captured requests**'i Burp veya Owasp ZAP gibi **proxies**'e **send** edebilirsiniz.\
Bunu yapmak için, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> basın "**Send to Fuzzer**" --> _proxy adresini seçin_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

MobSF ile dinamik analizi bitirdiğinizde "**Start Web API Fuzzer**" tuşuna basarak **fuzz http requests** yapabilir ve zafiyet arayabilirsiniz.

> [!TIP]
> MobSF ile dinamik analiz yaptıktan sonra proxy ayarları yanlış yapılandırılabilir ve bunları GUI üzerinden düzeltemeyebilirsiniz. Proxy ayarlarını düzeltmek için şu komutu çalıştırabilirsiniz:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Inspeckage ile Yardımlı Dinamik Analiz

Aracı [**Inspeckage**](https://github.com/ac-pm/Inspeckage) adresinden edinebilirsiniz.\
Bu araç, dinamik analiz yaparken uygulamada neler olduğunu size bildirmek için bazı **Hooks** kullanır.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Bu, GUI ile statik analiz yapmak için harika bir araçtır.

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Bu araç, hem **source code**'da hem de **packaged APKs**'ta çeşitli **security related Android application vulnerabilities**'ı aramak üzere tasarlanmıştır. Araç ayrıca bulunan bazı zafiyetleri istismar etmek için deploy edilebilir bir "Proof-of-Concept" APK ve **ADB commands** oluşturma konusunda da yeteneklidir (Exposed activities, intents, tapjacking...). Drozer'da olduğu gibi, test cihazını rootlamaya gerek yoktur.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Kolay başvuru için çıkarılan tüm dosyaları gösterir
- APK dosyalarını otomatik olarak Java ve Smali formatına decompile eder
- AndroidManifest.xml'i yaygın vulnerabilities ve davranışları için analiz eder
- Statik kaynak kodu analizi ile yaygın vulnerabilities ve davranışları tespit eder
- Cihaz bilgileri
- ve daha fazlası
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER, Windows, MacOS X ve Linux'ta kullanılabilen bir komut satırı uygulamasıdır; _.apk_ dosyalarını güvenlik açıkları açısından analiz eder. Bunu, APK'leri açarak ve bu güvenlik açıklarını tespit etmek için bir dizi kural uygulayarak yapar.

Tüm kurallar `rules.json` dosyasında toplanmıştır; her şirket veya test uzmanı ihtiyaçlarına göre kendi kurallarını oluşturabilir.

En son ikili dosyaları [download page](https://superanalyzer.rocks/download.html) üzerinden indirin.
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn, mobil uygulamalarda [static code analysis] yapan geliştiriciler, bugbounty hunters ve ethical hackers için yardımcı bir **çapraz platform** araçtır.

Kavram şu: mobil uygulama dosyanızı (bir .apk veya .ipa dosyası) StaCoAn uygulamasına sürükleyip bırakırsınız ve uygulama sizin için görsel ve taşınabilir bir rapor oluşturur. Ayarları ve wordlists üzerinde değişiklik yaparak özelleştirilmiş bir deneyim elde edebilirsiniz.

İndir[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework, geliştiricilere veya hackers gibi kişilere Android uygulamalarındaki potansiyel güvenlik açıklarını bulmalarında yardımcı olan bir Android zafiyet analiz sistemidir.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** bir araçtır; ana amacı bir Android uygulaması tarafından geliştirilen potansiyel kötü amaçlı davranışları tespit etmek ve kullanıcıyı uyarmaktır.

Tespit, uygulamanın Dalvik bytecode'unun **Smali** olarak temsil edilen halinin [`androguard`](https://github.com/androguard/androguard) kütüphanesi ile yapılan **static analysis** ile gerçekleştirilir.

Bu araç şu gibi **"kötü" uygulamaların ortak davranışlarını** arar: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. Yaygın kullanılan mobil uygulama reverse engineering ve analysis araçlarını bir araya getiren bir araçtır; OWASP mobile security tehditlerine karşı mobile uygulamaların test edilmesine yardımcı olur. Amacı, bu görevi mobil uygulama geliştiricileri ve güvenlik uzmanları için daha kolay ve daha erişilebilir kılmaktır.

It is able to:

- Farklı araçlar kullanarak Java ve Smali kodunu extract eder
- APK'leri analiz eder using: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- APK'ten regexps kullanarak private information çıkarır.
- Manifest'i analiz eder.
- Bulunan domainleri analiz eder using: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Malware tespiti için kullanışlı: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Kodu obfuscate etmek için kullandığınız servis ve yapılandırmaya bağlı olarak secrets obfuscated olabilir veya olmayabilir.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. Bytecode'u optimize edebilir ve kullanılmayan talimatları tespit edip kaldırabilir. ProGuard ücretsiz yazılımdır ve GNU General Public License, version 2 altında dağıtılmaktadır.

ProGuard, Android SDK'nın bir parçası olarak dağıtılır ve uygulama release modunda derlenirken çalışır.

### [DexGuard](https://www.guardsquare.com/dexguard)

APK'ı deobfuscate etmek için adım adım rehbere bakın: [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(Bu rehberden) En son kontrol ettiğimizde, Dexguard'ın çalışma modu şöyleydi:

- Bir kaynağı InputStream olarak yükle;
- Sonucu decrypt etmek için FilterInputStream'ten türeyen bir sınıfa ver;
- reverser'ın birkaç dakikasını harcatmak için gereksiz obfuscation yap;
- Şifre çözülmüş sonucu ZipInputStream'e vererek bir DEX dosyası elde et;
- Son olarak ortaya çıkan DEX'i `loadDex` metodunu kullanarak bir Resource olarak yükle.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

Obfuscated bir APK'yı platformlarına upload edebilirsiniz.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

Bu, android uygulamalardaki potansiyel security vulnerabilities'leri bulmak ve android uygulama kodunu deobfuscate etmek için bir LLM aracıdır. Google'ın Gemini public API'sini kullanır.

### [Simplify](https://github.com/CalebFenton/simplify)

Genel bir android deobfuscator'dır. Simplify, bir uygulamayı virtually executes ederek davranışını anlar ve ardından kodu aynı davranışı koruyacak şekilde ama insan tarafından anlaşılması daha kolay olacak biçimde optimize etmeye çalışır. Her optimizasyon türü basit ve genel olduğu için hangi spesifik obfuscation türünün kullanıldığı önemli değildir.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD size bir APK'nın nasıl yapıldığı hakkında bilgi verir. Birçok compilers, packers, obfuscators ve diğer tuhaf şeyleri tespit eder. Android için _PEiD_ gibidir.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b, ubuntu-mate tabanlı bir Android security virtual machine'dir; reverse engineering ve malware analysis için farklı security meraklıları ve araştırmacıların en son framework, tutorial ve lab koleksiyonunu içerir.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Harika bir kaynak listesi
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android hızlı kursu
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
