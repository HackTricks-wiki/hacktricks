# Android Uygulamaları Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android Uygulamaları Temelleri

**Android güvenliği ile ilgili en önemli kısımlar ve bir Android uygulamasındaki en tehlikeli bileşenler** hakkında bilgi edinmek için bu sayfayı okumaya başlamanız şiddetle tavsiye edilir:

{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Bu, bir android cihazına (emüle edilmiş veya fiziksel) bağlanmak için ihtiyaç duyduğunuz ana araçtır.\
**ADB**, cihazları bir bilgisayardan **USB** veya **Ağ** üzerinden kontrol etmeyi sağlar. Bu yardımcı program, dosyaların her iki yönde **kopyalanmasını**, uygulamaların **yüklenmesini** ve **kaldırılmasını**, shell komutlarının **çalıştırılmasını**, verilerin **yedeklenmesini**, günlüklerin **okunmasını** ve diğer birçok işlevi mümkün kılar.

ADB'yi nasıl kullanacağınızı öğrenmek için aşağıdaki [**ADB Komutları**](adb-commands.md) listesine göz atın.

## Smali

Bazen **gizli bilgilere** erişmek için **uygulama kodunu değiştirmek** ilginç olabilir (belki iyi obfuscate edilmiş şifreler veya bayraklar). Bu durumda, apk'yı decompile etmek, kodu değiştirmek ve yeniden compile etmek ilginç olabilir.\
[**Bu eğitimde** **APK'yı decompile etmeyi, Smali kodunu değiştirmeyi ve APK'yı yeni işlevsellik ile yeniden compile etmeyi** öğrenebilirsiniz](smali-changes.md). Bu, sunulacak dinamik analiz sırasında birkaç test için **alternatif olarak** çok faydalı olabilir. Bu nedenle, **her zaman bu olasılığı aklınızda bulundurun**.

## Diğer ilginç ipuçları

- [Play Store'da konumunuzu sahtelemek](spoofing-your-location-in-play-store.md)
- [Shizuku Ayrıcalıklı API (ADB tabanlı köksüz ayrıcalıklı erişim)](shizuku-privileged-api.md)
- [Güvensiz Uygulama İçi Güncelleme Mekanizmalarını Sömürmek](insecure-in-app-update-rce.md)
- **APK'ları İndirin**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Cihazdan APK çıkarın:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Tüm bölümleri ve temel apk'ları [APKEditor](https://github.com/REAndroid/APKEditor) ile birleştirin:
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Statik Analiz

Öncelikle, bir APK'yı analiz etmek için **Java koduna göz atmalısınız** bir dekompiler kullanarak.\
Lütfen, [**farklı mevcut dekompilerler hakkında bilgi bulmak için burayı okuyun**](apk-decompilers.md).

### İlginç Bilgiler Aramak

APK'nın **string'lerine** bakarak **şifreler**, **URL'ler** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** anahtarları, **şifreleme**, **bluetooth uuid'leri**, **token'lar** ve ilginç olabilecek her şeyi arayabilirsiniz... hatta kod yürütme **arka kapıları** veya kimlik doğrulama arka kapıları (uygulama için hardcoded admin kimlik bilgileri) için bile bakın.

**Firebase**

**firebase URL'lerine** özel dikkat edin ve kötü yapılandırılıp yapılandırılmadığını kontrol edin. [Firebase nedir ve nasıl istismar edilir hakkında daha fazla bilgi burada.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Uygulamanın Temel Anlayışı - Manifest.xml, strings.xml

Bir uygulamanın _Manifest.xml_ ve **_strings.xml_** dosyalarının **incelenmesi potansiyel güvenlik açıklarını ortaya çıkarabilir**. Bu dosyalar dekompilerler kullanılarak veya APK dosya uzantısı .zip olarak yeniden adlandırılıp ardından açılarak erişilebilir.

**Manifest.xml** dosyasından tespit edilen **açıklar** şunlardır:

- **Debuggable Uygulamalar**: _Manifest.xml_ dosyasında debuggable olarak ayarlanmış (`debuggable="true"`) uygulamalar, bağlantılara izin vererek istismar riskini artırır. Debuggable uygulamaları bulma ve istismar etme hakkında daha fazla bilgi için bir eğitime başvurun.
- **Yedekleme Ayarları**: Hassas bilgilerle ilgilenen uygulamalar için `android:allowBackup="false"` niteliği açıkça ayarlanmalıdır, böylece adb üzerinden yetkisiz veri yedeklemeleri önlenir, özellikle usb hata ayıklama etkinleştirildiğinde.
- **Ağ Güvenliği**: _res/xml/_ içindeki özel ağ güvenliği yapılandırmaları (`android:networkSecurityConfig="@xml/network_security_config"`) sertifika pinleri ve HTTP trafiği ayarları gibi güvenlik detaylarını belirtebilir. Örneğin, belirli alanlar için HTTP trafiğine izin vermek.
- **Dışa Aktarılan Aktiviteler ve Servisler**: Manifestte dışa aktarılan aktiviteleri ve servisleri tanımlamak, kötüye kullanılabilecek bileşenleri vurgulayabilir. Dinamik test sırasında daha fazla analiz, bu bileşenlerin nasıl istismar edileceğini ortaya çıkarabilir.
- **İçerik Sağlayıcıları ve FileProviders**: Açık içerik sağlayıcıları, yetkisiz erişim veya veri değişikliği izni verebilir. FileProviders'ın yapılandırması da incelenmelidir.
- **Broadcast Alıcıları ve URL Şemaları**: Bu bileşenler istismar için kullanılabilir, URL şemalarının giriş açıkları için nasıl yönetildiğine özel dikkat gösterilmelidir.
- **SDK Sürümleri**: `minSdkVersion`, `targetSDKVersion` ve `maxSdkVersion` nitelikleri desteklenen Android sürümlerini belirtir, güvenlik nedenleriyle eski, savunmasız Android sürümlerinin desteklenmemesinin önemini vurgular.

**strings.xml** dosyasından, API anahtarları, özel şemalar ve diğer geliştirici notları gibi hassas bilgiler keşfedilebilir, bu da bu kaynakların dikkatli bir şekilde gözden geçirilmesi gerekliliğini vurgular.

### Tapjacking

**Tapjacking**, **kötü niyetli** bir **uygulamanın** başlatıldığı ve **bir kurban uygulamasının üzerine yerleştiği** bir saldırıdır. Kurban uygulamayı görünür şekilde gizledikten sonra, kullanıcı arayüzü kullanıcıyı yanıltacak şekilde tasarlanmıştır, böylece kullanıcı etkileşimini bu uygulama ile gerçekleştirirken, etkileşim kurban uygulamaya iletilir.\
Sonuç olarak, bu durum **kullanıcının aslında kurban uygulamasında işlem yaptığını bilmesini engellemektedir**.

Daha fazla bilgi için:

{{#ref}}
tapjacking.md
{{#endref}}

### Görev Ele Geçirme

**`launchMode`**'u **`singleTask`** olarak ayarlanmış ve herhangi bir `taskAffinity` tanımlanmamış bir **aktivite**, görev ele geçirmeye karşı savunmasızdır. Bu, bir **uygulamanın** yüklenebileceği ve gerçek uygulamadan önce başlatılırsa, gerçek uygulamanın görevini **ele geçirebileceği** anlamına gelir (bu durumda kullanıcı, **gerçek uygulamayı kullanıyormuş gibi kötü niyetli uygulama ile etkileşimde bulunacaktır**).

Daha fazla bilgi için:

{{#ref}}
android-task-hijacking.md
{{#endref}}

### Güvensiz Veri Depolama

**Dahili Depolama**

Android'de, **dahili** depolamada **saklanan** dosyalar yalnızca **oluşturan** **uygulama** tarafından **erişilebilir** olacak şekilde **tasarlanmıştır**. Bu güvenlik önlemi, Android işletim sistemi tarafından **uygulanır** ve çoğu uygulamanın güvenlik ihtiyaçları için genellikle yeterlidir. Ancak, geliştiriciler bazen `MODE_WORLD_READABLE` ve `MODE_WORLD_WRITABLE` gibi modları kullanarak dosyaların farklı uygulamalar arasında **paylaşılmasına** izin verir. Ancak, bu modlar diğer uygulamalar tarafından, potansiyel olarak kötü niyetli olanlar da dahil olmak üzere, bu dosyalara erişimi **kısıtlamaz**.

1. **Statik Analiz:**
- `MODE_WORLD_READABLE` ve `MODE_WORLD_WRITABLE` kullanımının **dikkatlice incelenmesi** gerektiğini **sağlayın**. Bu modlar, dosyaları **istenmeyen veya yetkisiz erişime** açabilir.
2. **Dinamik Analiz:**
- Uygulama tarafından oluşturulan dosyaların üzerindeki **izinleri** **doğrulayın**. Özellikle, herhangi bir dosyanın **dünya çapında okunabilir veya yazılabilir** olup olmadığını **kontrol edin**. Bu, cihazda yüklü olan **herhangi bir uygulamanın**, kökeni veya niyeti ne olursa olsun, bu dosyaları **okumasına veya değiştirmesine** izin vereceğinden önemli bir güvenlik riski oluşturabilir.

**Harici Depolama**

**Harici depolama** ile ilgili dosyalarla çalışırken, belirli önlemler alınmalıdır:

1. **Erişilebilirlik**:
- Harici depolamadaki dosyalar **genel olarak okunabilir ve yazılabilir**. Bu, herhangi bir uygulamanın veya kullanıcının bu dosyalara erişebileceği anlamına gelir.
2. **Güvenlik Endişeleri**:
- Erişimin kolaylığı göz önüne alındığında, **hassas bilgilerin harici depolamada saklanmaması** önerilir.
- Harici depolama, herhangi bir uygulama tarafından çıkarılabilir veya erişilebilir, bu da güvenliğini azaltır.
3. **Harici Depolamadan Veri İşleme**:
- Harici depolamadan alınan veriler üzerinde her zaman **girdi doğrulaması** yapın. Bu, verilerin güvenilir bir kaynaktan gelmediği için kritik öneme sahiptir.
- Dinamik yükleme için harici depolamada yürütülebilir veya sınıf dosyalarının saklanması kesinlikle önerilmez.
- Uygulamanız harici depolamadan yürütülebilir dosyalar alması gerekiyorsa, bu dosyaların dinamik olarak yüklenmeden önce **imzalanmış ve kriptografik olarak doğrulanmış** olduğundan emin olun. Bu adım, uygulamanızın güvenlik bütünlüğünü korumak için hayati öneme sahiptir.

Harici depolama, `/storage/emulated/0`, `/sdcard`, `/mnt/sdcard` konumlarında **erişilebilir**.

> [!TIP]
> Android 4.4 ile birlikte (**API 17**), SD kartın bir dizin yapısı vardır ve bu, **bir uygulamanın yalnızca o uygulama için özel olan dizine erişimini sınırlar**. Bu, kötü niyetli uygulamaların başka bir uygulamanın dosyalarına okuma veya yazma erişimi kazanmasını engeller.

**Açık metin olarak saklanan hassas veriler**

- **Paylaşılan tercihleri**: Android, her uygulamanın `/data/data/<packagename>/shared_prefs/` yolunda xml dosyalarını kolayca kaydetmesine izin verir ve bazen bu klasörde açık metin olarak hassas bilgiler bulmak mümkündür.
- **Veritabanları**: Android, her uygulamanın `/data/data/<packagename>/databases/` yolunda sqlite veritabanlarını kolayca kaydetmesine izin verir ve bazen bu klasörde açık metin olarak hassas bilgiler bulmak mümkündür.

### Kırık TLS

**Tüm Sertifikaları Kabul Etme**

Bazı nedenlerden dolayı, bazen geliştiriciler tüm sertifikaları kabul eder, örneğin, ana bilgisayar adı aşağıdaki gibi kod satırlarıyla eşleşmese bile:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Bir bunu test etmenin iyi bir yolu, Burp gibi bir proxy kullanarak trafiği yakalamaya çalışmaktır, ancak cihaz içinde Burp CA'yı yetkilendirmeden. Ayrıca, Burp ile farklı bir hostname için bir sertifika oluşturabilir ve bunu kullanabilirsiniz.

### Kırık Kriptografi

**Zayıf Anahtar Yönetim Süreçleri**

Bazı geliştiriciler hassas verileri yerel depolamada saklar ve bunu kodda hardcoded/tahmin edilebilir bir anahtar ile şifreler. Bu yapılmamalıdır çünkü bazı tersine mühendislik işlemleri, saldırganların gizli bilgileri çıkarmasına izin verebilir.

**Güvensiz ve/veya Kullanımdan Kaldırılmış Algoritmaların Kullanımı**

Geliştiriciler, yetkilendirme **kontrolleri** yapmak, **veri saklamak** veya **göndermek** için **kullanımdan kaldırılmış algoritmalar** kullanmamalıdır. Bu algoritmalardan bazıları: RC4, MD4, MD5, SHA1... Örneğin, şifreleri saklamak için **hash'ler** kullanılıyorsa, tuz ile birlikte **brute-force saldırılarına dayanıklı** hash'ler kullanılmalıdır.

### Diğer Kontroller

- **APK'yı obfuscate etmek** önerilir, böylece tersine mühendislik işlemleri saldırganlar için zorlaşır.
- Uygulama hassas ise (örneğin banka uygulamaları), **mobilin köklenip köklenmediğini kontrol etmelidir** ve buna göre hareket etmelidir.
- Uygulama hassas ise (örneğin banka uygulamaları), bir **emülatör** kullanılıp kullanılmadığını kontrol etmelidir.
- Uygulama hassas ise (örneğin banka uygulamaları), **çalıştırmadan önce kendi bütünlüğünü kontrol etmelidir**.
- APK'yı oluşturmak için hangi derleyici/paketleyici/obfuscator kullanıldığını kontrol etmek için [**APKiD**](https://github.com/rednaga/APKiD) kullanın.

### React Native Uygulaması

React uygulamalarının javascript koduna kolayca erişmeyi öğrenmek için aşağıdaki sayfayı okuyun:

{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Uygulamaları

Xamarin uygulamalarının C# koduna kolayca erişmeyi öğrenmek için aşağıdaki sayfayı okuyun:

{{#ref}}
../xamarin-apps.md
{{#endref}}

### Süper Paketlenmiş Uygulamalar

Bu [**blog yazısına**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) göre süper paketlenmiş, bir uygulamanın içeriğini tek bir dosyaya sıkıştıran bir Meta algoritmadır. Blog, bu tür uygulamaları açan bir uygulama oluşturma olasılığından bahsediyor... ve **uygulamayı çalıştırıp dosya sisteminden açılmış dosyaları toplamak** gibi daha hızlı bir yol.

### Otomatik Statik Kod Analizi

[**mariana-trench**](https://github.com/facebook/mariana-trench) aracı, uygulamanın **kodunu tarayarak** **zayıflıkları** bulma yeteneğine sahiptir. Bu araç, **kullanıcı tarafından kontrol edilen** **giriş** yerlerini gösteren bir dizi **bilinen kaynak** içerir, **sink** (kötü niyetli kullanıcı girişinin zarar verebileceği **tehlikeli** **yerleri** gösterir) ve **kurallar** içerir. Bu kurallar, bir zayıflığı gösteren **kaynak-sink** kombinasyonlarını belirtir.

Bu bilgiyle, **mariana-trench kodu gözden geçirecek ve olası zayıflıkları bulacaktır**.

### Sızdırılan Sırlar

Bir uygulama, içinde keşfedebileceğiniz sırlar (API anahtarları, şifreler, gizli URL'ler, alt alan adları...) içerebilir. [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks) gibi bir araç kullanabilirsiniz.

### Biyometrik Kimlik Doğrulamasını Atlatma

{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Diğer İlginç Fonksiyonlar

- **Kod yürütme**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **SMS Gönderme**: `sendTextMessage, sendMultipartTestMessage`
- **Native fonksiyonlar** `native` olarak tanımlanır: `public native, System.loadLibrary, System.load`
- [Native fonksiyonları **tersine mühendislik yapmayı öğrenmek için bunu okuyun**](reversing-native-libraries.md)

### **Diğer Hileler**

{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dinamik Analiz

> Öncelikle, uygulamayı ve tüm ortamı (özellikle Burp CA sertifikası, Drozer ve Frida) kurabileceğiniz bir ortama ihtiyacınız var. Bu nedenle, köklü bir cihaz (emüle edilmiş veya değil) son derece önerilir.

### Çevrimiçi Dinamik Analiz

[https://appetize.io/](https://appetize.io) adresinde **ücretsiz bir hesap** oluşturabilirsiniz. Bu platform, APK'ları **yüklemenize** ve **çalıştırmanıza** olanak tanır, bu nedenle bir apk'nın nasıl davrandığını görmek için faydalıdır.

Ayrıca, **uygulamanızın günlüklerini** webde görebilir ve **adb** üzerinden bağlanabilirsiniz.

![](<../../images/image (831).png>)

ADB bağlantısı sayesinde, emülatörler içinde **Drozer** ve **Frida** kullanabilirsiniz.

### Yerel Dinamik Analiz

#### Bir emülatör kullanarak

- [**Android Studio**](https://developer.android.com/studio) (X86 ve ARM cihazları oluşturabilirsiniz ve [**bu**](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**en son x86** sürümleri ARM kütüphanelerini yavaş bir ARM emülatörüne ihtiyaç duymadan destekler).
- Kurulumunu öğrenmek için bu sayfayı okuyun:

{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Ücretsiz sürüm:** Kişisel Sürüm, bir hesap oluşturmanız gerekir. _Potansiyel hataları önlemek için **VirtualBox ile** sürümü **indirmeyi** öneririz._)
- [**Nox**](https://es.bignox.com) (Ücretsiz, ancak Frida veya Drozer'ı desteklemez).

> [!TIP]
> Herhangi bir platformda yeni bir emülatör oluştururken, ekranın ne kadar büyük olursa, emülatörün o kadar yavaş çalışacağını unutmayın. Bu nedenle, mümkünse küçük ekranlar seçin.

Genymotion'da **Google hizmetlerini** (AppStore gibi) kurmak için aşağıdaki resmin kırmızı ile işaretlenmiş butonuna tıklamanız gerekir:

![](<../../images/image (277).png>)

Ayrıca, Genymotion'daki **Android VM yapılandırmasında** **Bridge Network mode** seçeneğini seçebileceğinizi unutmayın (bu, Android VM'ye farklı bir VM'den bağlanıyorsanız faydalı olacaktır).

#### Fiziksel bir cihaz kullanma

**Hata ayıklama** seçeneklerini etkinleştirmeniz gerekir ve eğer **kökleyebilirseniz** harika olur:

1. **Ayarlar**.
2. (Android 8.0'dan itibaren) **Sistem**'i seçin.
3. **Telefon Hakkında**'yı seçin.
4. **Build numarasına** 7 kez basın.
5. Geri dönün ve **Geliştirici seçeneklerini** bulacaksınız.

> Uygulamayı kurduktan sonra yapmanız gereken ilk şey, onu denemek ve ne yaptığını, nasıl çalıştığını araştırmak ve onunla rahat olmaktır.\
> **MobSF dinamik analizi + pidcat** kullanarak bu ilk dinamik analizi yapmanızı öneririm, böylece **uygulamanın nasıl çalıştığını öğrenebiliriz** ve MobSF **ilginç** **verileri** toplarken daha sonra gözden geçirebilirsiniz.

### İstenmeyen Veri Sızıntısı

**Günlükleme**

Geliştiricilerin, **hata ayıklama bilgilerini** kamuya açık bir şekilde ifşa etme konusunda dikkatli olmaları gerekir, çünkü bu hassas veri sızıntılarına yol açabilir. Uygulama günlüklerini izlemek ve hassas bilgileri korumak için [**pidcat**](https://github.com/JakeWharton/pidcat) ve `adb logcat` araçları önerilir. **Pidcat**, kullanım kolaylığı ve okunabilirliği nedeniyle tercih edilmektedir.

> [!WARNING]
> **Android 4.0'dan daha yeni** sürümlerden itibaren, **uygulamalar yalnızca kendi günlüklerine erişebilir**. Yani uygulamalar diğer uygulamaların günlüklerine erişemez.\
> Yine de, **hassas bilgileri günlüğe kaydetmemek** önerilir.

**Kopyala/Yapıştır Tamponu Önbellekleme**

Android'in **panoya dayalı** çerçevesi, uygulamalarda kopyala-yapıştır işlevselliği sağlar, ancak **diğer uygulamalar** panoya **erişebileceğinden** hassas verilerin açığa çıkma riski taşır. Hassas bölümler için, örneğin kredi kartı bilgileri gibi, **kopyala/yapıştır** işlevlerini devre dışı bırakmak kritik öneme sahiptir.

**Çökme Günlükleri**

Eğer bir uygulama **çöker** ve **günlükleri kaydederse**, bu günlükler saldırganlara yardımcı olabilir, özellikle uygulama tersine mühendislik yapılamıyorsa. Bu riski azaltmak için, çökme durumunda günlüğe kaydetmekten kaçının ve eğer günlükler ağ üzerinden iletilmesi gerekiyorsa, güvenlik için SSL kanalı üzerinden gönderildiğinden emin olun.

Pentester olarak, **bu günlükleri gözden geçirmeye çalışın**.

**Üçüncü Taraflara Gönderilen Analitik Veriler**

Uygulamalar genellikle Google Adsense gibi hizmetleri entegre eder, bu da geliştiricilerin yanlış uygulaması nedeniyle hassas verilerin **sızmasına** neden olabilir. Potansiyel veri sızıntılarını belirlemek için, uygulamanın trafiğini **yakalamak** ve üçüncü taraf hizmetlere gönderilen hassas bilgileri kontrol etmek önerilir.

### SQLite DB'leri

Çoğu uygulama, bilgileri saklamak için **içsel SQLite veritabanları** kullanacaktır. Pentest sırasında oluşturulan **veritabanlarına**, **tabloların** ve **sütunların** adlarına ve saklanan tüm **verilere** bir **göz atın** çünkü **hassas bilgiler** bulabilirsiniz (bu bir zayıflık olacaktır).\
Veritabanları `/data/data/the.package.name/databases` içinde yer almalıdır, örneğin `/data/data/com.mwr.example.sieve/databases`

Eğer veritabanı gizli bilgileri saklıyorsa ve **şifrelenmişse** ancak uygulama içinde **şifreyi** bulabiliyorsanız, bu hala bir **zayıflıktır**.

Tabloları `.tables` ile listeleyin ve tabloların sütunlarını `.schema <table_name>` ile listeleyin.

### Drozer (Saldırı Aktiviteleri, İçerik Sağlayıcıları ve Hizmetler)

[Drozer Belgeleri](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf)'nden: **Drozer**, bir Android uygulamasının rolünü üstlenmenizi ve diğer uygulamalarla etkileşimde bulunmanızı sağlar. Yüklenmiş bir uygulamanın yapabileceği her şeyi yapabilir, örneğin Android’in Araçlar Arası İletişim (IPC) mekanizmasını kullanabilir ve temel işletim sistemi ile etkileşimde bulunabilir.\
Drozer, **ihracat yapılmış aktiviteleri, ihracat yapılmış hizmetleri ve İçerik Sağlayıcıları** istismar etmek için faydalı bir araçtır, bunu aşağıdaki bölümlerde öğreneceksiniz.

### İhracat Yapılmış Aktiviteleri İstismar Etme

[**Bir Android Aktivitesinin ne olduğunu tazelemek istiyorsanız bunu okuyun.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Ayrıca, bir aktivitenin kodunun **`onCreate`** metodunda başladığını unutmayın.

**Yetkilendirme atlatma**

Bir Aktivite ihracat yapıldığında, dış bir uygulamadan ekranını çağırabilirsiniz. Bu nedenle, **hassas bilgileri** içeren bir aktivite **ihracat** edilmişse, **kimlik doğrulama** mekanizmalarını **atlatabilirsiniz**.

[**Drozer ile ihracat yapılmış aktiviteleri nasıl istismar edeceğinizi öğrenin.**](drozer-tutorial/index.html#activities)

Ayrıca, adb'den ihracat yapılmış bir aktivite başlatabilirsiniz:

- Paket Adı com.example.demo
- İhracat Yapılmış Aktivite Adı com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOT**: MobSF, bir aktivitede `android:launchMode` olarak _**singleTask/singleInstance**_ kullanımını kötü niyetli olarak tespit edecektir, ancak [bu](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750) nedeniyle, görünüşe göre bu yalnızca eski sürümlerde (API sürümleri < 21) tehlikelidir.

> [!İPUCU]
> Bir yetkilendirme atlamanın her zaman bir zafiyet olmadığını unutmayın, bu atlamanın nasıl çalıştığına ve hangi bilgilerin açığa çıktığına bağlıdır.

**Hassas bilgi sızıntısı**

**Aktiviteler ayrıca sonuç döndürebilir**. Eğer **`setResult`** metodunu çağıran ve **hassas bilgi döndüren** bir dışa aktarılmış ve korunmasız aktivite bulursanız, burada bir hassas bilgi sızıntısı vardır.

#### Tapjacking

Eğer tapjacking engellenmezse, dışa aktarılmış aktiviteyi **kullanıcının beklenmedik eylemler gerçekleştirmesi** için kötüye kullanabilirsiniz. Daha fazla bilgi için [**Tapjacking nedir, bağlantıyı takip edin**](#tapjacking).

### İçerik Sağlayıcılarını Sömürme - Hassas bilgilere erişim ve manipülasyon

[**Bir İçerik Sağlayıcının ne olduğunu tazelemek istiyorsanız bunu okuyun.**](android-applications-basics.md#content-provider)\
İçerik sağlayıcılar temelde **veri paylaşmak** için kullanılır. Eğer bir uygulamanın mevcut içerik sağlayıcıları varsa, onlardan **hassas** verileri **çıkarma** şansınız olabilir. Ayrıca, olası **SQL enjeksiyonlarını** ve **Path Traversals** test etmek de ilginçtir çünkü bunlar savunmasız olabilir.

[**Drozer ile İçerik Sağlayıcıları nasıl sömüreceğinizi öğrenin.**](drozer-tutorial/index.html#content-providers)

### **Hizmetleri Sömürme**

[**Bir Servisin ne olduğunu tazelemek istiyorsanız bunu okuyun.**](android-applications-basics.md#services)\
Bir Servisin eylemlerinin `onStartCommand` metodunda başladığını unutmayın.

Servis, temelde **veri alabilen**, **işleyebilen** ve **bir yanıt döndüren** (veya döndürmeyen) bir şeydir. Dolayısıyla, bir uygulama bazı hizmetleri dışa aktarıyorsa, ne yaptığını anlamak için **kodunu kontrol etmeli** ve gizli bilgileri çıkarmak, kimlik doğrulama önlemlerini atlamak için **dinamik olarak test etmelisiniz**...\
[**Drozer ile Hizmetleri nasıl sömüreceğinizi öğrenin.**](drozer-tutorial/index.html#services)

### **Broadcast Alıcılarını Sömürme**

[**Bir Broadcast Alıcının ne olduğunu tazelemek istiyorsanız bunu okuyun.**](android-applications-basics.md#broadcast-receivers)\
Bir Broadcast Alıcının eylemlerinin `onReceive` metodunda başladığını unutmayın.

Bir yayın alıcısı bir tür mesaj bekleyecektir. Alıcının mesajı nasıl işlediğine bağlı olarak, savunmasız olabilir.\
[**Drozer ile Broadcast Alıcılarını nasıl sömüreceğinizi öğrenin.**](#exploiting-broadcast-receivers)

### **Şemaları / Derin bağlantıları Sömürme**

Derin bağlantıları manuel olarak, MobSF gibi araçlar veya [bu](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py) gibi betikler kullanarak arayabilirsiniz.\
Bir tanımlı **şemayı** **adb** veya bir **tarayıcı** kullanarak **açabilirsiniz**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Not edin ki **paket adını atlayabilirsiniz** ve mobil, o bağlantıyı açması gereken uygulamayı otomatik olarak çağıracaktır._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Kod çalıştırıldı**

Uygulamada **çalıştırılacak kodu** bulmak için, derin bağlantıyla çağrılan aktiviteye gidin ve **`onNewIntent`** fonksiyonunu arayın.

![](<../../images/image (436) (1) (1) (1).png>)

**Hassas bilgi**

Her derin bağlantı bulduğunuzda, **URL parametreleri aracılığıyla hassas veri (şifreler gibi) almadığından emin olun**, çünkü başka bir uygulama **derin bağlantıyı taklit edebilir ve bu veriyi çalabilir!**

**Yolda parametreler**

**URL'nin yolunda bir parametre kullanan herhangi bir derin bağlantıyı da kontrol etmelisiniz**: `https://api.example.com/v1/users/{username}` , bu durumda bir yol geçişi zorlayarak şuna erişebilirsiniz: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Uygulama içinde doğru uç noktaları bulursanız, **Açık Yönlendirme** (eğer yolun bir kısmı alan adı olarak kullanılıyorsa), **hesap ele geçirme** (eğer kullanıcı detaylarını CSRF token olmadan değiştirebiliyorsanız ve zayıf uç nokta doğru yöntemi kullanıyorsa) ve diğer zayıflıkları tetikleyebilirsiniz. Daha fazla [bilgi burada](http://dphoeniixx.com/2020/12/13-2/).

**Daha fazla örnek**

Bağlantılar hakkında [ilginç bir hata ödül raporu](https://hackerone.com/reports/855618) (_/.well-known/assetlinks.json_).

### Taşıma Katmanı İncelemesi ve Doğrulama Hataları

- Android uygulamaları **sertifikaları her zaman düzgün bir şekilde incelemez**. Bu uygulamaların uyarıları göz ardı etmesi ve kendinden imzalı sertifikaları kabul etmesi veya bazı durumlarda HTTP bağlantılarına geri dönmesi yaygındır.
- **SSL/TLS el sıkışması sırasında müzakereler bazen zayıftır**, güvensiz şifreleme takımları kullanır. Bu zayıflık, bağlantıyı adam ortası (MITM) saldırılarına karşı savunmasız hale getirir ve saldırganların verileri şifrelerini çözmesine olanak tanır.
- Uygulamalar güvenli kanallar kullanarak kimlik doğrulaması yaparken, diğer işlemler için güvensiz kanallar üzerinden iletişim kurmaları durumunda **özel bilgilerin sızması** riski vardır. Bu yaklaşım, oturum çerezleri veya kullanıcı detayları gibi hassas verilerin kötü niyetli varlıklar tarafından ele geçirilmesini korumaz.

#### Sertifika Doğrulama

**Sertifika doğrulama** üzerine odaklanacağız. Sunucunun sertifikasının bütünlüğü, güvenliği artırmak için doğrulanmalıdır. Bu, güvensiz TLS yapılandırmaları ve hassas verilerin şifrelenmemiş kanallar üzerinden iletilmesi durumunda önemli riskler oluşturabileceğinden kritik öneme sahiptir. Sunucu sertifikalarını doğrulama ve zayıflıkları giderme ile ilgili ayrıntılı adımlar için, [**bu kaynak**](https://manifestsecurity.com/android-application-security-part-10/) kapsamlı rehberlik sağlamaktadır.

#### SSL Pinning

SSL Pinning, uygulamanın sunucunun sertifikasını uygulama içinde saklanan bilinen bir kopya ile doğruladığı bir güvenlik önlemidir. Bu yöntem, MITM saldırılarını önlemek için gereklidir. Hassas bilgi işleyen uygulamalar için SSL Pinning uygulamak şiddetle önerilir.

#### Trafik İncelemesi

HTTP trafiğini incelemek için, **proxy aracının sertifikasını yüklemek** gereklidir (örneğin, Burp). Bu sertifikayı yüklemeden, şifreli trafik proxy üzerinden görünmeyebilir. Özel CA sertifikası yükleme rehberi için, [**buraya tıklayın**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

**API Seviye 24 ve üzeri** hedefleyen uygulamalar, proxy'nin CA sertifikasını kabul etmek için Ağ Güvenlik Yapılandırmasında değişiklikler gerektirir. Bu adım, şifreli trafiği incelemek için kritik öneme sahiptir. Ağ Güvenlik Yapılandırmasını değiştirme talimatları için, [**bu eğitime başvurun**](make-apk-accept-ca-certificate.md).

**Flutter** kullanılıyorsa, [**bu sayfadaki**](flutter.md) talimatları takip etmeniz gerekir. Bunun nedeni, sertifikayı depoya eklemenin işe yaramayacak olmasıdır, çünkü Flutter'ın kendi geçerli CA listesi vardır.

#### SSL Pinning'i Aşma

SSL Pinning uygulandığında, HTTPS trafiğini incelemek için bunu aşmak gerekli hale gelir. Bu amaçla çeşitli yöntemler mevcuttur:

- **apk'yi otomatik olarak değiştirerek** SSLPinning'i **aşmak için** [**apk-mitm**](https://github.com/shroudedcode/apk-mitm) kullanabilirsiniz. Bu seçeneğin en iyi avantajı, SSL Pinning'i aşmak için root'a ihtiyaç duymamanızdır, ancak uygulamayı silip yeni olanı yeniden yüklemeniz gerekecek ve bu her zaman işe yaramayabilir.
- Bu korumayı aşmak için **Frida** kullanabilirsiniz (aşağıda tartışılmıştır). Burp+Frida+Genymotion kullanma rehberiniz burada: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- **SSL Pinning'i otomatik olarak aşmayı** denemek için [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- **MobSF dinamik analizi** kullanarak da **SSL Pinning'i otomatik olarak aşmayı** deneyebilirsiniz (aşağıda açıklanmıştır).
- Hala yakalamadığınız bazı trafiğin olduğunu düşünüyorsanız, trafiği **iptables kullanarak burp'a yönlendirmeyi** deneyebilirsiniz. Bu blogu okuyun: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Yaygın Web Zayıflıklarını Arama

Uygulama içinde yaygın web zayıflıklarını da aramak önemlidir. Bu zayıflıkları tanımlama ve hafifletme ile ilgili ayrıntılı bilgiler bu özetin kapsamının ötesindedir, ancak başka yerlerde kapsamlı bir şekilde ele alınmaktadır.

### Frida

[Frida](https://www.frida.re), geliştiriciler, ters mühendisler ve güvenlik araştırmacıları için dinamik bir enstrümantasyon aracıdır.\
**Çalışan uygulamaya erişebilir ve çalışma zamanında yöntemleri bağlayarak davranışı değiştirebilir, değerleri değiştirebilir, değerleri çıkarabilir, farklı kodlar çalıştırabilirsiniz...**\
Android uygulamalarını pentest etmek istiyorsanız, Frida'yı nasıl kullanacağınızı bilmelisiniz.

- Frida'yı nasıl kullanacağınızı öğrenin: [**Frida eğitimi**](frida-tutorial/index.html)
- Frida ile eylemler için bazı "GUI": [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection, Frida'nın kullanımını otomatikleştirmek için harikadır: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Burada bazı harika Frida betikleri bulabilirsiniz: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Frida'yı [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) adresinde belirtildiği gibi yükleyerek anti-debugging / anti-frida mekanizmalarını aşmayı deneyin (araç [linjector](https://github.com/erfur/linjector-rs))

### **Belleği Dökme - Fridump**

Uygulamanın, saklamaması gereken hassas bilgileri (şifreler veya mnemonikler gibi) bellekte saklayıp saklamadığını kontrol edin.

[**Fridump3**](https://github.com/rootbsd/fridump3) kullanarak uygulamanın belleğini dökebilirsiniz:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Bu, belleği ./dump klasörüne dökecektir ve orada şunlarla grep yapabilirsiniz:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Keystore'daki Hassas Veriler**

Android'de Keystore, hassas verileri saklamak için en iyi yerdir, ancak yeterli ayrıcalıklara sahip olunduğunda **erişmek mümkündür**. Uygulamalar burada **hassas verileri düz metin olarak** saklama eğiliminde olduğundan, pentestler bunun için root kullanıcı olarak kontrol edilmelidir veya cihaza fiziksel erişimi olan birisi bu verileri çalabilir.

Bir uygulama verileri keystore'da saklasa bile, verilerin şifrelenmiş olması gerekir.

Keystore içindeki verilere erişmek için bu Frida script'ini kullanabilirsiniz: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Parmak İzi/Biyometrik Bypass**

Aşağıdaki Frida betiğini kullanarak, Android uygulamalarının **belirli hassas alanları korumak** amacıyla gerçekleştirebileceği **parmak izi kimlik doğrulamasını atlamak** mümkün olabilir:
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Arka Plan Görüntüleri**

Bir uygulamayı arka plana aldığınızda, Android **uygulamanın bir anlık görüntüsünü** saklar, böylece ön plana geri döndüğünde, uygulama yüklenmeden önce görüntüyü yüklemeye başlar, bu da uygulamanın daha hızlı yüklendiği izlenimini verir.

Ancak, bu anlık görüntü **hassas bilgiler** içeriyorsa, anlık görüntüye erişimi olan biri bu bilgileri **çalıp alabilir** (erişmek için root'a ihtiyacınız olduğunu unutmayın).

Anlık görüntüler genellikle şurada saklanır: **`/data/system_ce/0/snapshots`**

Android, **FLAG_SECURE** düzen parametresini ayarlayarak ekran görüntüsü alımını **önlemenin** bir yolunu sağlar. Bu bayrağı kullanarak, pencere içeriği güvenli olarak kabul edilir, bu da ekran görüntülerinde görünmesini veya güvenli olmayan ekranlarda görüntülenmesini engeller.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Uygulama Analizörü**

Bu araç, dinamik analiz sırasında farklı araçları yönetmenize yardımcı olabilir: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Enjeksiyonu

Geliştiriciler genellikle bu Intents'i işleyen ve `startActivity(...)` veya `sendBroadcast(...)` gibi yöntemlere ileten proxy bileşenleri, aktiviteleri ve hizmetleri oluştururlar; bu da riskli olabilir.

Tehlike, saldırganların bu Intents'i yanlış yönlendirerek dışa aktarılmamış uygulama bileşenlerini tetiklemelerine veya hassas içerik sağlayıcılarına erişmelerine izin vermekte yatmaktadır. Dikkate değer bir örnek, URL'leri `Intent` nesnelerine dönüştüren `WebView` bileşenidir; bu, `Intent.parseUri(...)` aracılığıyla yapılır ve ardından bunları çalıştırarak kötü niyetli Intent enjeksiyonlarına yol açabilir.

### Temel Çıkarımlar

- **Intent Enjeksiyonu**, webin Açık Yönlendirme sorununa benzer.
- Sömürüler, `Intent` nesnelerini ekstra olarak geçirmeyi içerir; bu, güvensiz işlemleri gerçekleştirmek için yönlendirilebilir.
- Dışa aktarılmamış bileşenleri ve içerik sağlayıcılarını saldırganlara açabilir.
- `WebView`’in URL'den `Intent` dönüşümü, istenmeyen eylemleri kolaylaştırabilir.

### Android İstemci Tarafı Enjeksiyonları ve Diğerleri

Bu tür güvenlik açıkları hakkında webden haberdar olmalısınız. Bir Android uygulamasında bu güvenlik açıklarına özellikle dikkat etmelisiniz:

- **SQL Enjeksiyonu:** Dinamik sorgular veya İçerik Sağlayıcılarla çalışırken, parametreli sorgular kullandığınızdan emin olun.
- **JavaScript Enjeksiyonu (XSS):** Herhangi bir WebView için JavaScript ve Eklenti desteğinin devre dışı olduğundan emin olun (varsayılan olarak devre dışıdır). [Daha fazla bilgi burada](webview-attacks.md#javascript-enabled).
- **Yerel Dosya Dahil Etme:** WebView'lerin dosya sistemine erişimi devre dışı olmalıdır (varsayılan olarak etkindir) - `(webview.getSettings().setAllowFileAccess(false);)`. [Daha fazla bilgi burada](webview-attacks.md#javascript-enabled).
- **Sonsuz çerezler**: Birçok durumda, android uygulaması oturumu bitirdiğinde çerez iptal edilmez veya hatta diske kaydedilebilir.
- [**Çerezlerde Güvenli Bayrak**](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Otomatik Analiz

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Statik analiz**

![](<../../images/image (866).png>)

**Uygulamanın güvenlik açığı değerlendirmesi**, güzel bir web tabanlı ön yüz kullanarak yapılır. Ayrıca dinamik analiz de gerçekleştirebilirsiniz (ancak ortamı hazırlamanız gerekir).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
MobSF, **Android**(apk)**, IOS**(ipa) **ve Windows**(apx) uygulamalarını (_Windows uygulamaları, Windows ana bilgisayarında kurulu bir MobSF'den analiz edilmelidir_) analiz edebilir.\
Ayrıca, bir **Android** veya **IOS** uygulamasının kaynak koduyla bir **ZIP** dosyası oluşturursanız (uygulamanın kök klasörüne gidin, her şeyi seçin ve bir ZIP dosyası oluşturun), bunu da analiz edebilecektir.

MobSF ayrıca **diff/karşılaştırma** analizi yapmanıza ve **VirusTotal** ile entegre olmanıza olanak tanır (API anahtarınızı _MobSF/settings.py_ dosyasında ayarlamanız ve etkinleştirmeniz gerekecek: `VT_ENABLED = TRUE` `VT_API_KEY = <API anahtarınız>` `VT_UPLOAD = TRUE`). Ayrıca `VT_UPLOAD`'u `False` olarak ayarlayabilirsiniz, bu durumda **hash** dosya yerine **yüklenir**.

### MobSF ile Yardımlı Dinamik Analiz

**MobSF**, **Android** için **dinamik analiz** konusunda da çok yardımcı olabilir, ancak bu durumda MobSF ve **genymotion**'ı ana bilgisayarınıza kurmanız gerekecek (bir VM veya Docker çalışmayacaktır). _Not: Öncelikle **genymotion'da bir VM başlatmalısınız** ve **sonra MobSF'yi başlatmalısınız**._\
**MobSF dinamik analizörü** şunları yapabilir:

- **Uygulama verilerini dökme** (URL'ler, günlükler, panoya kopyalananlar, sizin yaptığınız ekran görüntüleri, "**Exported Activity Tester**" tarafından yapılan ekran görüntüleri, e-postalar, SQLite veritabanları, XML dosyaları ve diğer oluşturulan dosyalar). Tüm bunlar otomatik olarak yapılır, ekran görüntüleri için istediğinizde basmanız veya tüm dışa aktarılan etkinliklerin ekran görüntülerini elde etmek için "**Exported Activity Tester**" butonuna basmanız gerekir.
- **HTTPS trafiğini yakalama**
- **Çalışma zamanı** **bilgilerini** elde etmek için **Frida** kullanma

Android **sürümleri > 5**'ten itibaren, **Frida**'yı **otomatik olarak başlatacak** ve trafiği **yakalamak** için global **proxy** ayarlarını ayarlayacaktır. Sadece test edilen uygulamadan gelen trafiği yakalayacaktır.

**Frida**

Varsayılan olarak, SSL pinning, **root tespiti** ve **hata ayıklayıcı tespiti** atlamak ve **ilginç API'leri** izlemek için bazı Frida Script'lerini de kullanacaktır.\
MobSF ayrıca **dışa aktarılan etkinlikleri** çağırabilir, bunların **ekran görüntülerini** alabilir ve rapor için **kaydedebilir**.

Dinamik testi **başlatmak** için yeşil butona basın: "**Start Instrumentation**". Frida script'leri tarafından üretilen günlükleri görmek için "**Frida Live Logs**" butonuna basın ve bağlı yöntemlere yapılan tüm çağrıları, geçirilen argümanları ve döndürülen değerleri görmek için "**Live API Monitor**" butonuna basın (bu, "Start Instrumentation" butonuna bastıktan sonra görünecektir).\
MobSF ayrıca kendi **Frida script'lerinizi** yüklemenize olanak tanır (Frida script'lerinizin sonuçlarını MobSF'ye göndermek için `send()` fonksiyonunu kullanın). Ayrıca yükleyebileceğiniz **birçok önceden yazılmış script** vardır (daha fazlasını `MobSF/DynamicAnalyzer/tools/frida_scripts/others/` dizinine ekleyebilirsiniz), sadece **seçin**, "**Load**" butonuna basın ve "**Start Instrumentation**" butonuna basın (bu script'lerin günlüklerini "**Frida Live Logs**" içinde görebileceksiniz).

![](<../../images/image (419).png>)

Ayrıca, bazı Yardımcı Frida işlevsellikleriniz var:

- **Yüklenen Sınıfları Sayma**: Yüklenen tüm sınıfları yazdırır
- **Dizeleri Yakalama**: Uygulamayı kullanırken yakalanan tüm dizeleri yazdırır (çok gürültülü)
- **Dize Karşılaştırmalarını Yakalama**: Çok faydalı olabilir. **Karşılaştırılan 2 dizeyi** ve sonucun True veya False olup olmadığını **gösterir**.
- **Sınıf Yöntemlerini Sayma**: Sınıf adını (örneğin "java.io.File") yazın ve sınıfın tüm yöntemlerini yazdırır.
- **Sınıf Deseni Arama**: Desene göre sınıfları arama
- **Sınıf Yöntemlerini İzleme**: **Bütün bir sınıfı izleme** (sınıfın tüm yöntemlerinin giriş ve çıkışlarını görün). Varsayılan olarak MobSF, birkaç ilginç Android API yöntemini izler.

Kullanmak istediğiniz yardımcı modülü seçtikten sonra "**Start Instrumentation**" butonuna basmanız gerekir ve tüm çıktıları "**Frida Live Logs**" içinde göreceksiniz.

**Shell**

Mobsf ayrıca dinamik analiz sayfasının altında bazı **adb** komutları, **MobSF komutları** ve yaygın **shell** **komutları** ile bir shell sunar. Bazı ilginç komutlar:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP araçları**

HTTP trafiği yakalandığında, "**HTTP(S) Trafiği**" altında yakalanan trafiğin çirkin bir görünümünü veya "**HTTP Araçlarını Başlat**" yeşil butonunda daha güzel bir görünümünü görebilirsiniz. İkinci seçenekten, **yakalanan istekleri** Burp veya Owasp ZAP gibi **proxy'lere** **gönderebilirsiniz**.\
Bunu yapmak için, _Burp'ı açın -->_ _Intercept'i kapatın --> MobSB HTTP Araçları'nda isteği seçin_ --> "**Fuzzer'a Gönder**" butonuna basın --> _proxy adresini seçin_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

MobSF ile dinamik analizi tamamladıktan sonra, **http isteklerini fuzzlamak** ve güvenlik açıklarını aramak için "**Web API Fuzzer'ı Başlat**" butonuna basabilirsiniz.

> [!TIP]
> MobSF ile dinamik analiz gerçekleştirdikten sonra proxy ayarları yanlış yapılandırılmış olabilir ve bunları GUI'den düzeltemezsiniz. Proxy ayarlarını düzeltmek için:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Inspeckage ile Yardımlı Dinamik Analiz

Aracı [**Inspeckage**](https://github.com/ac-pm/Inspeckage) adresinden edinebilirsiniz.\
Bu araç, **dinamik analiz** gerçekleştirirken **uygulamada neler olduğunu** anlamanızı sağlamak için bazı **Hooks** kullanacaktır.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Bu, **GUI ile statik analiz gerçekleştirmek için harika bir araçtır.**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Bu araç, **kaynak kodunda** veya **paketlenmiş APK'larda** çeşitli **güvenlik ile ilgili Android uygulama açıklarını** aramak için tasarlanmıştır. Araç ayrıca, bulunan bazı güvenlik açıklarını (Açık aktiviteler, intentler, tapjacking...) istismar etmek için **"Proof-of-Concept" dağıtılabilir APK** ve **ADB komutları** oluşturma yeteneğine de sahiptir. Drozer ile olduğu gibi, test cihazını root etmenize gerek yoktur.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Kolay referans için tüm çıkarılan dosyaları görüntüler
- APK dosyalarını otomatik olarak Java ve Smali formatına decompile eder
- Yaygın güvenlik açıkları ve davranışlar için AndroidManifest.xml'i analiz eder
- Yaygın güvenlik açıkları ve davranışlar için statik kaynak kodu analizi
- Cihaz bilgisi
- ve daha fazlası
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER, Windows, MacOS X ve Linux'ta kullanılabilen bir komut satırı uygulamasıdır ve güvenlik açıklarını aramak için _.apk_ dosyalarını analiz eder. Bunu, APK'ları sıkıştırmasını açarak ve bu güvenlik açıklarını tespit etmek için bir dizi kural uygulayarak yapar.

Tüm kurallar `rules.json` dosyasında toplanmıştır ve her şirket veya testçi, ihtiyaç duydukları şeyleri analiz etmek için kendi kurallarını oluşturabilir.

En son ikili dosyaları [indirme sayfasından](https://superanalyzer.rocks/download.html) indirin.
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn, mobil uygulamalar üzerinde [statik kod analizi](https://en.wikipedia.org/wiki/Static_program_analysis) gerçekleştiren geliştiricilere, bugbounty avcılarına ve etik hackerlara yardımcı olan **çoklu platform** bir araçtır.

Kavram, mobil uygulama dosyanızı (bir .apk veya .ipa dosyası) StaCoAn uygulamasına sürükleyip bırakmanız ve bunun için size görsel ve taşınabilir bir rapor oluşturmasıdır. Özelleştirilmiş bir deneyim elde etmek için ayarları ve kelime listelerini değiştirebilirsiniz.

[En son sürümü](https://github.com/vincentcox/StaCoAn/releases) indirin:
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework, geliştiricilerin veya hackerların Android uygulamalarındaki potansiyel güvenlik açıklarını bulmalarına yardımcı olan bir Android zafiyet analiz sistemidir.\
[Windows sürümleri](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn**, bir Android uygulaması tarafından geliştirilen potansiyel kötü niyetli davranışları tespit etmek ve kullanıcıyı uyarmak amacıyla tasarlanmış bir araçtır.

Tespit, uygulamanın Dalvik bytecode'unun **statik analizi** ile gerçekleştirilir ve bu, **Smali** olarak temsil edilir; [`androguard`](https://github.com/androguard/androguard) kütüphanesi kullanılır.

Bu araç, aşağıdaki gibi **"kötü" uygulamaların yaygın davranışlarını** arar: Telefon kimliklerinin sızdırılması, Ses/görüntü akışının kesilmesi, PIM verilerinin değiştirilmesi, Rastgele kod yürütme...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA**, **M**obil **A**pplication **R**everse engineering ve **A**naliz Framework'üdür. Bu, mobil uygulamaları OWASP mobil güvenlik tehditlerine karşı test etmeye yardımcı olmak için yaygın olarak kullanılan mobil uygulama tersine mühendislik ve analiz araçlarını bir araya getiren bir araçtır. Amacı, bu görevi mobil uygulama geliştiricileri ve güvenlik profesyonelleri için daha kolay ve daha dostane hale getirmektir.

Şunları yapabilir:

- Farklı araçlar kullanarak Java ve Smali kodunu çıkarmak
- APK'ları analiz etmek için: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Regex kullanarak APK'dan özel bilgileri çıkarmak.
- Manifest'i analiz etmek.
- Bulunan alanları analiz etmek için: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) ve [whatweb](https://github.com/urbanadventurer/WhatWeb)
- APK'yı [apk-deguard.com](http://www.apk-deguard.com) üzerinden deşifre etmek.

### Koodous

Kötü amaçlı yazılımları tespit etmek için kullanışlı: [https://koodous.com/](https://koodous.com)

## Kodun Obfuscation/Deobfuscation'ı

Kodu obfuscate etmek için kullandığınız hizmet ve yapılandırmaya bağlı olarak, gizli bilgiler obfuscate edilmiş veya edilmemiş olabilir.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

[Wikipedia'dan](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard**, Java kodunu küçülten, optimize eden ve obfuscate eden açık kaynaklı bir komut satırı aracıdır. Bytecode'u optimize etmenin yanı sıra kullanılmayan talimatları tespit edip kaldırabilir. ProGuard, ücretsiz bir yazılımdır ve GNU Genel Kamu Lisansı, sürüm 2 altında dağıtılmaktadır.

ProGuard, Android SDK'nın bir parçası olarak dağıtılır ve uygulama yayın modunda derlenirken çalışır.

### [DexGuard](https://www.guardsquare.com/dexguard)

APK'yı deşifre etmek için adım adım bir kılavuzu [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html) adresinde bulabilirsiniz.

(Bu kılavuzdan) Son kontrol ettiğimizde, Dexguard çalışma modu şuydu:

- Bir kaynağı InputStream olarak yüklemek;
- Sonucu deşifre etmek için FilterInputStream'den türetilmiş bir sınıfa beslemek;
- Bir tersine mühendislik uzmanının birkaç dakikasını boşa harcamak için gereksiz obfuscation yapmak;
- Deşifre edilmiş sonucu bir ZipInputStream'e beslemek ve bir DEX dosyası almak;
- Son olarak, elde edilen DEX'i `loadDex` yöntemi ile bir Kaynak olarak yüklemek.

### [DeGuard](http://apk-deguard.com)

**DeGuard, Android obfuscation araçları tarafından gerçekleştirilen obfuscation sürecini tersine çevirir. Bu, kod incelemesi ve kütüphaneleri tahmin etme gibi birçok güvenlik analizini mümkün kılar.**

Obfuscate edilmiş bir APK'yı platformlarına yükleyebilirsiniz.

### [Deobfuscate android App](https://github.com/In3tinct/deobfuscate-android-app)

Bu, Android uygulamalarındaki potansiyel güvenlik açıklarını bulmak ve Android uygulama kodunu deşifre etmek için bir LLM aracıdır. Google'ın Gemini kamu API'sini kullanır.

### [Simplify](https://github.com/CalebFenton/simplify)

Bu, **genel bir android deobfuscator'dır.** Simplify, bir uygulamayı **sanallaştırarak çalıştırır** ve davranışını anlamaya çalışır, ardından **kodun optimize edilmesini** sağlar, böylece aynı şekilde davranır ancak bir insanın anlaması daha kolaydır. Her optimizasyon türü basit ve genel olduğundan, kullanılan obfuscation türü ne olursa olsun önemli değildir.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD, **bir APK'nın nasıl yapıldığını** size bildirir. Birçok **derleyici**, **paketleyici**, **obfuscator** ve diğer garip şeyleri tanımlar. Android için [_PEiD_](https://www.aldeid.com/wiki/PEiD) gibidir.

### Manual

[Özel obfuscation'ı tersine çevirme ile ilgili bazı ipuçlarını öğrenmek için bu eğitimi okuyun](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b, ubuntu-mate tabanlı bir Android güvenlik sanal makinesidir ve tersine mühendislik ve kötü amaçlı yazılım analizi için farklı güvenlik uzmanları ve araştırmacılardan en son framework, eğitimler ve laboratuvarları içermektedir.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Harika bir kaynak listesi
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android hızlı kursu
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)

## Yet to try

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
