# Android 应用程序渗透测试

{{#include ../../banners/hacktricks-training.md}}

## Android 应用程序基础

强烈建议您首先阅读此页面，以了解与 Android 安全性相关的 **最重要部分和 Android 应用程序中最危险的组件**：

{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android 调试桥)

这是您连接到 Android 设备（模拟或物理）所需的主要工具。\
**ADB** 允许从计算机通过 **USB** 或 **网络** 控制设备。此工具使 **文件** 双向 **复制**、**安装** 和 **卸载** 应用程序、**执行** shell 命令、**备份** 数据、**读取** 日志等功能成为可能。

查看以下 [**ADB 命令**](adb-commands.md) 列表，以了解如何使用 adb。

## Smali

有时修改 **应用程序代码** 以访问 **隐藏信息**（可能是经过良好混淆的密码或标志）是很有趣的。然后，反编译 apk、修改代码并重新编译可能会很有趣。\
[**在本教程中**，您可以 **学习如何反编译 APK、修改 Smali 代码并使用新功能重新编译 APK**](smali-changes.md)。这在 **动态分析** 中作为 **多项测试的替代方案** 将非常有用。然后，**始终记住这个可能性**。

## 其他有趣的技巧

- [在 Play 商店中伪装您的位置](spoofing-your-location-in-play-store.md)
- **下载 APK**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- 从设备提取 APK:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- 使用 [APKEditor](https://github.com/REAndroid/APKEditor) 合并所有拆分和基础 APK：
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## 静态分析

首先，对于分析 APK，您应该**查看 Java 代码**，使用反编译器。\
请[**在这里阅读有关不同可用反编译器的信息**](apk-decompilers.md)。

### 寻找有趣的信息

仅仅查看 APK 的**字符串**，您就可以搜索**密码**、**URL** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep))、**api** 密钥、**加密**、**蓝牙 UUID**、**令牌**以及任何有趣的内容……甚至查找代码执行的**后门**或身份验证后门（硬编码的管理员凭据）。

**Firebase**

特别注意**firebase URL**，并检查其是否配置不当。[有关 Firebase 的更多信息以及如何利用它，请点击这里。](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### 应用程序的基本理解 - Manifest.xml, strings.xml

**检查应用程序的 \_Manifest.xml**_\*\* 和 \*\*_**strings.xml**\_\*\* 文件可以揭示潜在的安全漏洞\*\*。这些文件可以通过反编译器访问，或通过将 APK 文件扩展名重命名为 .zip 然后解压缩来访问。

从 **Manifest.xml** 中识别的**漏洞**包括：

- **可调试的应用程序**：在 _Manifest.xml_ 文件中设置为可调试 (`debuggable="true"`) 的应用程序存在风险，因为它们允许连接，可能导致被利用。有关如何利用可调试应用程序的进一步理解，请参考有关在设备上查找和利用可调试应用程序的教程。
- **备份设置**：对于处理敏感信息的应用程序，`android:allowBackup="false"` 属性应明确设置，以防止通过 adb 进行未经授权的数据备份，特别是在启用 USB 调试时。
- **网络安全**：_res/xml/_ 中的自定义网络安全配置 (`android:networkSecurityConfig="@xml/network_security_config"`) 可以指定安全细节，如证书固定和 HTTP 流量设置。一个例子是允许特定域的 HTTP 流量。
- **导出活动和服务**：在清单中识别导出的活动和服务可以突出可能被滥用的组件。在动态测试期间的进一步分析可以揭示如何利用这些组件。
- **内容提供者和文件提供者**：暴露的内容提供者可能允许未经授权访问或修改数据。文件提供者的配置也应受到审查。
- **广播接收器和 URL 方案**：这些组件可能被利用进行攻击，特别注意如何管理 URL 方案以防止输入漏洞。
- **SDK 版本**：`minSdkVersion`、`targetSDKVersion` 和 `maxSdkVersion` 属性指示支持的 Android 版本，强调出于安全原因不支持过时、易受攻击的 Android 版本的重要性。

从 **strings.xml** 文件中，可以发现敏感信息，如 API 密钥、自定义模式和其他开发者注释，强调了仔细审查这些资源的必要性。

### Tapjacking

**Tapjacking** 是一种攻击，其中**恶意** **应用程序**被启动并**位于受害者应用程序之上**。一旦它可见地遮挡了受害者应用程序，其用户界面被设计成欺骗用户与之交互，同时将交互传递给受害者应用程序。\
实际上，它是**让用户不知道他们实际上是在对受害者应用程序执行操作**。

获取更多信息：

{{#ref}}
tapjacking.md
{{#endref}}

### 任务劫持

一个**活动**的**`launchMode`** 设置为**`singleTask`**，且没有定义任何 `taskAffinity`，则容易受到任务劫持。这意味着，可以安装一个**应用程序**，如果在真实应用程序之前启动，它可能会**劫持真实应用程序的任务**（因此用户将与**恶意应用程序**交互，以为自己在使用真实应用程序）。

更多信息：

{{#ref}}
android-task-hijacking.md
{{#endref}}

### 不安全的数据存储

**内部存储**

在 Android 中，**存储**在**内部**存储中的文件**设计**为仅由**创建**它们的**应用程序**访问。此安全措施由 Android 操作系统**强制**执行，通常足以满足大多数应用程序的安全需求。然而，开发者有时会使用 `MODE_WORLD_READABLE` 和 `MODE_WORLD_WRITABLE` 等模式来**允许**文件在不同应用程序之间**共享**。然而，这些模式**并不限制**其他应用程序（包括潜在恶意应用程序）对这些文件的访问。

1. **静态分析：**
- **确保**仔细审查 `MODE_WORLD_READABLE` 和 `MODE_WORLD_WRITABLE` 的使用。这些模式**可能会暴露**文件给**意外或未经授权的访问**。
2. **动态分析：**
- **验证**应用程序创建的文件上的**权限**。具体来说，**检查**是否有任何文件被**设置为全球可读或可写**。这可能构成重大安全风险，因为这将允许**任何安装在设备上的应用程序**，无论其来源或意图如何，**读取或修改**这些文件。

**外部存储**

处理**外部存储**上的文件（如 SD 卡）时，应采取某些预防措施：

1. **可访问性**：
- 外部存储上的文件是**全球可读和可写**的。这意味着任何应用程序或用户都可以访问这些文件。
2. **安全问题**：
- 鉴于访问的便利性，建议**不要在外部存储上存储敏感信息**。
- 外部存储可以被任何应用程序移除或访问，使其安全性降低。
3. **处理来自外部存储的数据**：
- 始终对从外部存储检索的数据**执行输入验证**。这至关重要，因为数据来自不受信任的来源。
- 强烈不建议在外部存储上存储可执行文件或类文件以进行动态加载。
- 如果您的应用程序必须从外部存储检索可执行文件，请确保这些文件在动态加载之前**经过签名和加密验证**。此步骤对于维护应用程序的安全完整性至关重要。

外部存储可以在 `/storage/emulated/0`、`/sdcard`、`/mnt/sdcard` 中访问。

> [!NOTE]
> 从 Android 4.4（**API 17**）开始，SD 卡具有一个目录结构，**限制应用程序访问特定于该应用程序的目录**。这防止恶意应用程序获得对另一个应用程序文件的读写访问。

**以明文存储的敏感数据**

- **共享偏好**：Android 允许每个应用程序轻松地在路径 `/data/data/<packagename>/shared_prefs/` 中保存 xml 文件，有时可以在该文件夹中找到明文的敏感信息。
- **数据库**：Android 允许每个应用程序轻松地在路径 `/data/data/<packagename>/databases/` 中保存 sqlite 数据库，有时可以在该文件夹中找到明文的敏感信息。

### 不安全的 TLS

**接受所有证书**

出于某种原因，有时开发者会接受所有证书，即使例如主机名与以下代码行不匹配：
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
测试这个的一个好方法是尝试使用一些代理（如 Burp）捕获流量，而不在设备中授权 Burp CA。此外，您还可以使用 Burp 为不同的主机名生成证书并使用它。

### 破损的加密

**糟糕的密钥管理流程**

一些开发人员将敏感数据保存在本地存储中，并使用在代码中硬编码/可预测的密钥进行加密。这不应该这样做，因为某些反向工程可能允许攻击者提取机密信息。

**使用不安全和/或过时的算法**

开发人员不应使用**过时的算法**来执行授权**检查**、**存储**或**发送**数据。这些算法包括：RC4、MD4、MD5、SHA1……如果**哈希**用于存储密码，例如，应该使用抗暴力破解的哈希并加盐。

### 其他检查

- 建议**混淆 APK**，以增加攻击者的反向工程难度。
- 如果应用程序是敏感的（如银行应用），它应该执行**自己的检查以查看手机是否已被root**并采取相应措施。
- 如果应用程序是敏感的（如银行应用），它应该检查是否正在使用**模拟器**。
- 如果应用程序是敏感的（如银行应用），它应该**在执行之前检查自己的完整性**以确认是否被修改。
- 使用 [**APKiD**](https://github.com/rednaga/APKiD) 检查构建 APK 时使用的编译器/打包器/混淆器

### React Native 应用程序

阅读以下页面以了解如何轻松访问 React 应用程序的 JavaScript 代码：

{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin 应用程序

阅读以下页面以了解如何轻松访问 Xamarin 应用程序的 C# 代码：

{{#ref}}
../xamarin-apps.md
{{#endref}}

### 超级打包应用程序

根据这篇 [**博客文章**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/)，超级打包是一种将应用程序内容压缩为单个文件的 Meta 算法。该博客讨论了创建一个解压缩此类应用程序的应用程序的可能性……以及一种更快的方法，即**执行应用程序并从文件系统中收集解压缩的文件**。

### 自动化静态代码分析

工具 [**mariana-trench**](https://github.com/facebook/mariana-trench) 能够通过**扫描**应用程序的**代码**来发现**漏洞**。该工具包含一系列**已知源**（指示工具**用户控制输入的地方**）、**汇**（指示工具**危险的地方**，恶意用户输入可能造成损害）和**规则**。这些规则指示**源-汇**的**组合**，表明存在漏洞。

通过这些知识，**mariana-trench 将审查代码并找到可能的漏洞**。

### 泄露的秘密

应用程序可能包含秘密（API 密钥、密码、隐藏的 URL、子域名……），您可能能够发现。您可以使用工具，例如 [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### 绕过生物识别认证

{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### 其他有趣的功能

- **代码执行**：`Runtime.exec(), ProcessBuilder(), native code:system()`
- **发送短信**：`sendTextMessage, sendMultipartTestMessage`
- **声明为 `native` 的本地函数**：`public native, System.loadLibrary, System.load`
- [阅读此文以了解**如何反向工程本地函数**](reversing-native-libraries.md)

### **其他技巧**

{{#ref}}
content-protocol.md
{{#endref}}

---

---

## 动态分析

> 首先，您需要一个可以安装应用程序和所有环境（主要是 Burp CA 证书、Drozer 和 Frida）的环境。因此，强烈建议使用已 root 的设备（无论是模拟的还是非模拟的）。

### 在线动态分析

您可以在 [https://appetize.io/](https://appetize.io) 创建一个**免费账户**。该平台允许您**上传**和**执行** APK，因此它对于查看 APK 的行为非常有用。

您甚至可以在网页上**查看应用程序的日志**并通过**adb**连接。

![](<../../images/image (831).png>)

通过 ADB 连接，您可以在模拟器中使用**Drozer**和**Frida**。

### 本地动态分析

#### 使用模拟器

- [**Android Studio**](https://developer.android.com/studio)（您可以创建**x86**和**arm**设备，并且根据[**这个**](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**最新的 x86** 版本**支持 ARM 库**，无需慢速的 arm 模拟器）。
- 在此页面学习如何设置：

{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **（免费版：**个人版，您需要创建一个账户。_建议**下载**带有_**VirtualBox**的版本，以避免潜在错误。_)
- [**Nox**](https://es.bignox.com)（免费，但不支持 Frida 或 Drozer）。

> [!NOTE]
> 创建新模拟器时，请记住，屏幕越大，模拟器运行越慢。因此，如果可能，请选择小屏幕。

要在 Genymotion 中**安装 Google 服务**（如 AppStore），您需要单击以下图像中红色标记的按钮：

![](<../../images/image (277).png>)

此外，请注意在 Genymotion 的**Android VM 配置中**，您可以选择**桥接网络模式**（如果您将从不同的 VM 连接到 Android VM 使用工具，这将非常有用）。

#### 使用物理设备

您需要激活**调试**选项，如果您可以**root**它，那就更好了：

1. **设置**。
2. （从 Android 8.0 开始）选择**系统**。
3. 选择**关于手机**。
4. 按**构建号** 7 次。
5. 返回，您将找到**开发者选项**。

> 一旦您安装了应用程序，您首先应该尝试它并调查它的功能、工作原理，并熟悉它。\
> 我建议使用 MobSF 动态分析 + pidcat 执行此初步动态分析，这样我们就可以在 MobSF **捕获**大量**有趣的**数据时**了解应用程序的工作原理**，您可以稍后查看这些数据。

### 意外数据泄露

**日志记录**

开发人员应谨慎公开**调试信息**，因为这可能导致敏感数据泄露。建议使用工具 [**pidcat**](https://github.com/JakeWharton/pidcat) 和 `adb logcat` 监控应用程序日志，以识别和保护敏感信息。**Pidcat**因其易用性和可读性而受到青睐。

> [!WARNING]
> 请注意，从**Android 4.0 及更高版本**开始，**应用程序只能访问自己的日志**。因此，应用程序无法访问其他应用的日志。\
> 无论如何，仍然建议**不要记录敏感信息**。

**复制/粘贴缓冲区缓存**

Android 的**基于剪贴板**的框架使应用程序能够实现复制粘贴功能，但由于**其他应用程序**可以**访问**剪贴板，可能会暴露敏感数据。因此，至关重要的是**禁用敏感部分的复制/粘贴**功能，例如信用卡详细信息，以防止数据泄露。

**崩溃日志**

如果应用程序**崩溃**并**保存日志**，这些日志可能会帮助攻击者，特别是当应用程序无法被反向工程时。为了降低此风险，避免在崩溃时记录日志，如果必须通过网络传输日志，请确保通过 SSL 通道发送以确保安全。

作为渗透测试者，**请尝试查看这些日志**。

**发送给第三方的分析数据**

应用程序通常集成像 Google Adsense 这样的服务，由于开发人员的不当实现，可能会无意中**泄露敏感数据**。为了识别潜在的数据泄露，建议**拦截应用程序的流量**并检查是否有任何敏感信息被发送到第三方服务。

### SQLite 数据库

大多数应用程序将使用**内部 SQLite 数据库**来保存信息。在渗透测试期间，请**查看**创建的**数据库**、**表**和**列**的名称以及所有保存的**数据**，因为您可能会发现**敏感信息**（这将是一个漏洞）。\
数据库应位于 `/data/data/the.package.name/databases`，例如 `/data/data/com.mwr.example.sieve/databases`

如果数据库保存机密信息并且是**加密的**但您可以在应用程序中**找到**密码，这仍然是一个**漏洞**。

使用 `.tables` 枚举表，使用 `.schema <table_name>` 枚举表的列。

### Drozer（利用活动、内容提供者和服务）

来自 [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf)：**Drozer** 允许您**假装成一个 Android 应用程序**并与其他应用程序交互。它可以做**任何已安装应用程序可以做的事情**，例如利用 Android 的进程间通信（IPC）机制并与底层操作系统交互。\
Drozer 是一个有用的工具，可以**利用导出活动、导出服务和内容提供者**，您将在以下部分中学习。

### 利用导出活动

[**如果您想刷新 Android 活动的概念，请阅读此文。**](android-applications-basics.md#launcher-activity-and-other-activities)\
还要记住，活动的代码从**`onCreate`**方法开始。

**授权绕过**

当一个活动被导出时，您可以从外部应用程序调用其界面。因此，如果一个包含**敏感信息**的活动被**导出**，您可能会**绕过**访问它的**身份验证**机制。

[**了解如何使用 Drozer 利用导出活动。**](drozer-tutorial/index.html#activities)

您还可以从 adb 启动导出活动：

- 包名是 com.example.demo
- 导出活动名称是 com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**注意**: MobSF 会将使用 _**singleTask/singleInstance**_ 作为 `android:launchMode` 的活动检测为恶意，但由于 [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750)，显然这在旧版本（API 版本 < 21）中才是危险的。

> [!NOTE]
> 请注意，授权绕过并不总是一个漏洞，这取决于绕过的工作方式和暴露的信息。

**敏感信息泄露**

**活动也可以返回结果**。如果你设法找到一个导出且未保护的活动调用 **`setResult`** 方法并 **返回敏感信息**，则存在敏感信息泄露。

#### Tapjacking

如果未防止 tapjacking，你可能会滥用导出的活动使 **用户执行意外操作**。有关 [**tapjacking 的更多信息，请查看链接**](#tapjacking)。

### 利用内容提供者 - 访问和操纵敏感信息

[**如果你想刷新内容提供者的概念，请阅读此内容。**](android-applications-basics.md#content-provider)\
内容提供者基本上用于 **共享数据**。如果一个应用程序有可用的内容提供者，你可能能够 **提取敏感** 数据。测试可能的 **SQL 注入** 和 **路径遍历** 也很有趣，因为它们可能存在漏洞。

[**学习如何使用 Drozer 利用内容提供者。**](drozer-tutorial/index.html#content-providers)

### **利用服务**

[**如果你想刷新服务的概念，请阅读此内容。**](android-applications-basics.md#services)\
请记住，服务的操作始于方法 `onStartCommand`。

服务基本上是可以 **接收数据**、**处理** 数据并 **返回**（或不返回）响应的东西。因此，如果一个应用程序导出了一些服务，你应该 **检查** 其 **代码** 以了解其功能，并 **动态测试** 以提取机密信息、绕过身份验证措施...\
[**学习如何使用 Drozer 利用服务。**](drozer-tutorial/index.html#services)

### **利用广播接收器**

[**如果你想刷新广播接收器的概念，请阅读此内容。**](android-applications-basics.md#broadcast-receivers)\
请记住，广播接收器的操作始于方法 `onReceive`。

广播接收器将等待某种类型的消息。根据接收器如何处理消息，它可能会存在漏洞。\
[**学习如何使用 Drozer 利用广播接收器。**](#exploiting-broadcast-receivers)

### **利用方案 / 深度链接**

你可以手动查找深度链接，使用像 MobSF 这样的工具或像 [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py) 的脚本。\
你可以使用 **adb** 或 **浏览器** **打开** 声明的 **方案**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_请注意，您可以**省略包名**，手机将自动调用应该打开该链接的应用程序。_
```markup
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**代码执行**

为了找到**将在应用中执行的代码**，请转到由深度链接调用的活动，并搜索函数**`onNewIntent`**。

![](<../../images/image (436) (1) (1) (1).png>)

**敏感信息**

每次找到深度链接时，请检查**它是否通过 URL 参数接收敏感数据（如密码）**，因为任何其他应用程序都可能**冒充深度链接并窃取该数据！**

**路径中的参数**

您**还必须检查任何深度链接是否在 URL 的路径中使用参数**，例如：`https://api.example.com/v1/users/{username}`，在这种情况下，您可以强制路径遍历，访问类似于：`example://app/users?username=../../unwanted-endpoint%3fparam=value`。\
请注意，如果您在应用程序中找到正确的端点，您可能能够导致**开放重定向**（如果路径的一部分用作域名），**账户接管**（如果您可以在没有 CSRF 令牌的情况下修改用户详细信息，并且漏洞端点使用了正确的方法）以及任何其他漏洞。更多[信息在这里](http://dphoeniixx.com/2020/12/13-2/)。

**更多示例**

一个[有趣的漏洞赏金报告](https://hackerone.com/reports/855618)关于链接 (_/.well-known/assetlinks.json_)。

### 传输层检查和验证失败

- **证书并不总是被 Android 应用程序正确检查**。这些应用程序常常忽视警告，接受自签名证书，或者在某些情况下，恢复使用 HTTP 连接。
- **SSL/TLS 握手期间的协商有时较弱**，使用不安全的密码套件。此漏洞使连接容易受到中间人（MITM）攻击，允许攻击者解密数据。
- **私密信息泄露**是一个风险，当应用程序通过安全通道进行身份验证，但随后在其他交易中通过非安全通道进行通信。这种方法未能保护敏感数据，例如会话 cookie 或用户详细信息，免受恶意实体的拦截。

#### 证书验证

我们将重点关注**证书验证**。必须验证服务器证书的完整性以增强安全性。这一点至关重要，因为不安全的 TLS 配置和通过未加密通道传输敏感数据可能会带来重大风险。有关验证服务器证书和解决漏洞的详细步骤，[**此资源**](https://manifestsecurity.com/android-application-security-part-10/)提供了全面的指导。

#### SSL 钉扎

SSL 钉扎是一种安全措施，应用程序将服务器的证书与存储在应用程序内部的已知副本进行验证。这种方法对于防止 MITM 攻击至关重要。强烈建议处理敏感信息的应用程序实施 SSL 钉扎。

#### 流量检查

要检查 HTTP 流量，必须**安装代理工具的证书**（例如，Burp）。如果不安装此证书，加密流量可能无法通过代理可见。有关安装自定义 CA 证书的指南，[**请点击这里**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine)。

针对**API Level 24 及以上**的应用程序需要修改网络安全配置以接受代理的 CA 证书。这一步对于检查加密流量至关重要。有关修改网络安全配置的说明，[**请参考此教程**](make-apk-accept-ca-certificate.md)。

#### 绕过 SSL 钉扎

当实施 SSL 钉扎时，绕过它成为检查 HTTPS 流量的必要条件。为此有多种方法可用：

- 自动**修改** **apk**以**绕过** SSLPinning，使用[**apk-mitm**](https://github.com/shroudedcode/apk-mitm)。此选项的最大优点是您无需 root 即可绕过 SSL 钉扎，但您需要删除应用程序并重新安装新版本，这并不总是有效。
- 您可以使用**Frida**（下面讨论）来绕过此保护。这里有一个使用 Burp+Frida+Genymotion 的指南：[https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- 您还可以尝试使用[**objection**](frida-tutorial/objection-tutorial.md)**自动绕过 SSL 钉扎**：`objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- 您还可以尝试使用**MobSF 动态分析**（下面解释）**自动绕过 SSL 钉扎**
- 如果您仍然认为有一些流量未被捕获，您可以尝试**使用 iptables 将流量转发到 burp**。阅读此博客：[https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### 寻找常见的网络漏洞

在应用程序中搜索常见的网络漏洞也很重要。有关识别和缓解这些漏洞的详细信息超出了本摘要的范围，但在其他地方有广泛的覆盖。

### Frida

[Frida](https://www.frida.re) 是一个动态插桩工具包，供开发人员、逆向工程师和安全研究人员使用。\
**您可以访问正在运行的应用程序并在运行时挂钩方法以更改行为、更改值、提取值、运行不同的代码...**\
如果您想对 Android 应用程序进行渗透测试，您需要知道如何使用 Frida。

- 学习如何使用 Frida：[**Frida 教程**](frida-tutorial/index.html)
- 一些用于 Frida 操作的“GUI”： [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection 非常适合自动化使用 Frida：[**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- 您可以在这里找到一些很棒的 Frida 脚本：[**https://codeshare.frida.re/**](https://codeshare.frida.re)
- 尝试通过加载 Frida 绕过反调试/反 Frida 机制，如在[https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace)中所示（工具[linjector](https://github.com/erfur/linjector-rs)）

### **内存转储 - Fridump**

检查应用程序是否在内存中存储不应存储的敏感信息，如密码或助记符。

使用[**Fridump3**](https://github.com/rootbsd/fridump3)，您可以转储应用程序的内存：
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
这将把内存转储到 ./dump 文件夹中，在那里你可以使用类似的 grep：
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Keystore中的敏感数据**

在Android中，Keystore是存储敏感数据的最佳位置，然而，拥有足够权限的情况下仍然**可以访问它**。由于应用程序倾向于在此处存储**明文敏感数据**，因此渗透测试应以root用户身份进行检查，或者某些具有物理访问权限的人可能能够窃取这些数据。

即使应用程序将数据存储在keystore中，数据也应该是加密的。

要访问keystore中的数据，可以使用此Frida脚本：[https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **指纹/生物识别绕过**

使用以下 Frida 脚本，可能可以 **绕过指纹认证**，Android 应用程序可能会执行此操作以 **保护某些敏感区域：**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **背景图像**

当您将应用程序置于后台时，Android 会存储应用程序的 **快照**，因此当它恢复到前台时，它会在应用程序加载之前开始加载图像，这样看起来应用程序加载得更快。

然而，如果这个快照包含 **敏感信息**，那么有权限访问快照的人可能会 **窃取这些信息**（请注意，您需要 root 权限才能访问它）。

快照通常存储在： **`/data/system_ce/0/snapshots`**

Android 提供了一种方法来 **通过设置 FLAG_SECURE** 布局参数来防止屏幕截图的捕获。使用此标志后，窗口内容被视为安全，防止其出现在屏幕截图中或在不安全的显示器上查看。
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android 应用分析器**

此工具可以帮助您在动态分析过程中管理不同的工具：[https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### 意图注入

开发人员经常创建代理组件，如活动、服务和广播接收器，处理这些意图并将其传递给 `startActivity(...)` 或 `sendBroadcast(...)` 等方法，这可能存在风险。

危险在于允许攻击者通过错误引导这些意图来触发未导出的应用组件或访问敏感内容提供者。一个显著的例子是 `WebView` 组件通过 `Intent.parseUri(...)` 将 URL 转换为 `Intent` 对象，然后执行它们，这可能导致恶意意图注入。

### 重要要点

- **意图注入** 类似于网络的开放重定向问题。
- 利用涉及将 `Intent` 对象作为附加项传递，这可能被重定向以执行不安全的操作。
- 它可以将未导出的组件和内容提供者暴露给攻击者。
- `WebView` 的 URL 到 `Intent` 转换可以促进意外操作。

### Android 客户端侧注入及其他

您可能对这种类型的漏洞有所了解。您必须特别小心 Android 应用中的这些漏洞：

- **SQL 注入：** 在处理动态查询或内容提供者时，确保使用参数化查询。
- **JavaScript 注入 (XSS)：** 验证任何 WebViews 的 JavaScript 和插件支持是否已禁用（默认禁用）。 [更多信息在这里](webview-attacks.md#javascript-enabled)。
- **本地文件包含：** WebViews 应禁用对文件系统的访问（默认启用） - `(webview.getSettings().setAllowFileAccess(false);)`。 [更多信息在这里](webview-attacks.md#javascript-enabled)。
- **持久性 Cookie：** 在多个情况下，当 Android 应用结束会话时，Cookie 并未被撤销，甚至可能被保存到磁盘。
- [**Cookie 中的安全标志**](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## 自动分析

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**静态分析**

![](<../../images/image (866).png>)

**使用漂亮的基于 Web 的前端进行应用程序的漏洞评估。** 您还可以执行动态分析（但需要准备环境）。
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
注意，MobSF 可以分析 **Android**(apk)**、IOS**(ipa) **和 Windows**(apx) 应用程序（_Windows 应用程序必须从安装在 Windows 主机上的 MobSF 进行分析_）。\
此外，如果您创建一个包含 **Android** 或 **IOS** 应用程序源代码的 **ZIP** 文件（转到应用程序的根文件夹，选择所有内容并创建一个 ZIP 文件），它也能够分析它。

MobSF 还允许您进行 **diff/比较** 分析，并集成 **VirusTotal**（您需要在 _MobSF/settings.py_ 中设置您的 API 密钥并启用它：`VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`）。您还可以将 `VT_UPLOAD` 设置为 `False`，这样 **hash** 将被 **上传** 而不是文件。

### 使用 MobSF 进行辅助动态分析

**MobSF** 对于 **Android** 的 **动态分析** 也非常有帮助，但在这种情况下，您需要在主机上安装 MobSF 和 **genymotion**（虚拟机或 Docker 不会工作）。_注意：您需要 **先在 genymotion 中启动虚拟机**，然后 **再启动 MobSF。**_\
**MobSF 动态分析器** 可以：

- **转储应用程序数据**（URLs、日志、剪贴板、您拍摄的屏幕截图、由 "**Exported Activity Tester**" 拍摄的屏幕截图、电子邮件、SQLite 数据库、XML 文件和其他创建的文件）。所有这些都是自动完成的，除了屏幕截图，您需要在想要截图时按下，或者您需要按 "**Exported Activity Tester**" 以获取所有导出活动的屏幕截图。
- 捕获 **HTTPS 流量**
- 使用 **Frida** 获取 **运行时** **信息**

从 Android **版本 > 5** 开始，它将 **自动启动 Frida** 并设置全局 **代理** 设置以 **捕获** 流量。它只会捕获被测试应用程序的流量。

**Frida**

默认情况下，它还将使用一些 Frida 脚本来 **绕过 SSL 钉扎**、**根检测** 和 **调试器检测**，并 **监控有趣的 API**。\
MobSF 还可以 **调用导出活动**，抓取它们的 **屏幕截图** 并 **保存** 到报告中。

要 **开始** 动态测试，请按绿色按钮：“**开始仪器化**”。按下“**Frida 实时日志**”以查看 Frida 脚本生成的日志，按下“**实时 API 监视器**”以查看所有调用的挂钩方法、传递的参数和返回值（在按下“开始仪器化”后会出现）。\
MobSF 还允许您加载自己的 **Frida 脚本**（要将您的 Frida 脚本的结果发送到 MobSF，请使用 `send()` 函数）。它还具有 **多个预编写的脚本**，您可以加载（您可以在 `MobSF/DynamicAnalyzer/tools/frida_scripts/others/` 中添加更多），只需 **选择它们**，按“**加载**”并按“**开始仪器化**”（您将能够在“**Frida 实时日志**”中看到该脚本的日志）。

![](<../../images/image (419).png>)

此外，您还有一些辅助 Frida 功能：

- **枚举已加载的类**：它将打印所有已加载的类
- **捕获字符串**：它将打印在使用应用程序时捕获的所有字符串（非常嘈杂）
- **捕获字符串比较**：可能非常有用。它将 **显示正在比较的两个字符串** 以及结果是 True 还是 False。
- **枚举类方法**：输入类名（如 "java.io.File"），它将打印该类的所有方法。
- **搜索类模式**：按模式搜索类
- **跟踪类方法**：**跟踪** 一个 **整个类**（查看该类所有方法的输入和输出）。请记住，默认情况下 MobSF 跟踪几个有趣的 Android API 方法。

一旦您选择了要使用的辅助模块，您需要按“**开始仪器化**”，您将看到所有输出在“**Frida 实时日志**”中。

**Shell**

Mobsf 还为您提供了一个带有一些 **adb** 命令、**MobSF 命令** 和常见 **shell** **命令** 的 shell，位于动态分析页面的底部。一些有趣的命令：
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP工具**

当http流量被捕获时，您可以在“**HTTP(S) Traffic**”底部看到捕获流量的丑陋视图，或在“**Start HTTPTools**”绿色按钮中看到更好的视图。从第二个选项中，您可以**发送****捕获的请求**到像Burp或Owasp ZAP这样的**代理**。\
为此，_打开Burp -->_ _关闭拦截 --> 在MobSB HTTPTools中选择请求_ --> 按下“**Send to Fuzzer**” --> _选择代理地址_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080))。

完成MobSF的动态分析后，您可以按“**Start Web API Fuzzer**”来**模糊http请求**并寻找漏洞。

> [!NOTE]
> 在使用MobSF进行动态分析后，代理设置可能会配置错误，您将无法从GUI中修复它们。您可以通过以下方式修复代理设置：
>
> ```
> adb shell settings put global http_proxy :0
> ```

### 使用Inspeckage进行辅助动态分析

您可以从[**Inspeckage**](https://github.com/ac-pm/Inspeckage)获取该工具。\
该工具将使用一些**Hooks**来让您了解**在进行动态分析时应用程序中发生了什么**。

### [Yaazhini](https://www.vegabird.com/yaazhini/)

这是一个**用于执行带GUI的静态分析的好工具**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

该工具旨在查找多个**与安全相关的Android应用程序漏洞**，无论是在**源代码**还是**打包的APK**中。该工具还**能够创建可部署的“概念验证”APK**和**ADB命令**，以利用一些发现的漏洞（暴露的活动、意图、点击劫持...）。与Drozer一样，测试设备无需root。
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- 显示所有提取的文件以便于参考
- 自动将APK文件反编译为Java和Smali格式
- 分析AndroidManifest.xml以查找常见漏洞和行为
- 对常见漏洞和行为进行静态源代码分析
- 设备信息
- 以及更多
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER 是一个可以在 Windows、MacOS X 和 Linux 上使用的命令行应用程序，旨在分析 _.apk_ 文件以寻找漏洞。它通过解压 APK 并应用一系列规则来检测这些漏洞。

所有规则都集中在一个 `rules.json` 文件中，每个公司或测试人员都可以创建自己的规则来分析他们所需的内容。

从 [download page](https://superanalyzer.rocks/download.html) 下载最新的二进制文件。
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn 是一个 **跨平台** 工具，帮助开发者、漏洞赏金猎人和道德黑客对移动应用程序进行 [静态代码分析](https://en.wikipedia.org/wiki/Static_program_analysis)。

其概念是将您的移动应用程序文件（.apk 或 .ipa 文件）拖放到 StaCoAn 应用程序上，它将为您生成一个可视化和便携的报告。您可以调整设置和词汇表，以获得定制的体验。

下载 [最新版本](https://github.com/vincentcox/StaCoAn/releases)：
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework 是一个 Android 漏洞分析系统，帮助开发者或黑客发现 Android 应用中的潜在安全漏洞。\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** 是一个工具，其主要目的是检测并警告用户关于 Android 应用程序可能存在的恶意行为。

检测是通过对应用程序的 Dalvik 字节码进行 **静态分析** 来执行的，该字节码以 **Smali** 形式表示，使用 [`androguard`](https://github.com/androguard/androguard) 库。

该工具寻找 **“坏” 应用程序的常见行为**，例如：电话标识符外泄、音频/视频流拦截、PIM 数据修改、任意代码执行...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** 是一个 **M**obile **A**pplication **R**everse engineering 和 **A**nalysis Framework。它是一个将常用的移动应用程序逆向工程和分析工具整合在一起的工具，旨在帮助测试移动应用程序以应对 OWASP 移动安全威胁。其目标是使这一任务对移动应用程序开发人员和安全专业人员更加简单和友好。

它能够：

- 使用不同工具提取 Java 和 Smali 代码
- 使用以下工具分析 APK：[smalisca](https://github.com/dorneanu/smalisca)、[ClassyShark](https://github.com/google/android-classyshark)、[androbugs](https://github.com/AndroBugs/AndroBugs_Framework)、[androwarn](https://github.com/maaaaz/androwarn)、[APKiD](https://github.com/rednaga/APKiD)
- 使用正则表达式从 APK 中提取私人信息。
- 分析 Manifest。
- 使用以下工具分析发现的域名：[pyssltest](https://github.com/moheshmohan/pyssltest)、[testssl](https://github.com/drwetter/testssl.sh) 和 [whatweb](https://github.com/urbanadventurer/WhatWeb)
- 通过 [apk-deguard.com](http://www.apk-deguard.com) 进行 APK 的去混淆。

### Koodous

用于检测恶意软件：[https://koodous.com/](https://koodous.com)

## 混淆/去混淆代码

请注意，具体取决于您用于混淆代码的服务和配置。秘密可能会被混淆或不被混淆。

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

来自 [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** 是一个开源命令行工具，用于缩小、优化和混淆 Java 代码。它能够优化字节码，并检测和删除未使用的指令。ProGuard 是自由软件，按照 GNU 通用公共许可证第 2 版分发。

ProGuard 作为 Android SDK 的一部分分发，并在以发布模式构建应用程序时运行。

### [DexGuard](https://www.guardsquare.com/dexguard)

在 [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html) 找到去混淆 APK 的逐步指南。

（来自该指南）上次我们检查时，Dexguard 的操作模式是：

- 将资源加载为 InputStream；
- 将结果传递给继承自 FilterInputStream 的类以进行解密；
- 进行一些无用的混淆，以浪费反向工程师几分钟的时间；
- 将解密后的结果传递给 ZipInputStream 以获取 DEX 文件；
- 最后使用 `loadDex` 方法将结果 DEX 加载为资源。

### [DeGuard](http://apk-deguard.com)

**DeGuard 逆转了 Android 混淆工具执行的混淆过程。这使得进行多种安全分析成为可能，包括代码检查和预测库。**

您可以将混淆的 APK 上传到他们的平台。

### [Deobfuscate android App](https://github.com/In3tinct/deobfuscate-android-app)

这是一个 LLM 工具，用于查找 Android 应用中的潜在安全漏洞并去混淆 Android 应用代码。使用 Google 的 Gemini 公共 API。

### [Simplify](https://github.com/CalebFenton/simplify)

它是一个 **通用的 Android 去混淆器。** Simplify **虚拟执行应用程序** 以理解其行为，然后 **尝试优化代码** 使其行为相同，但更易于人类理解。每种优化类型都是简单和通用的，因此无论使用何种特定类型的混淆都无关紧要。

### [APKiD](https://github.com/rednaga/APKiD)

APKiD 提供有关 **APK 是如何制作的** 信息。它识别许多 **编译器**、**打包工具**、**混淆器** 和其他奇怪的东西。它是 Android 的 [_PEiD_](https://www.aldeid.com/wiki/PEiD)。

### 手动

[阅读本教程以学习一些关于 **如何逆向自定义混淆** 的技巧](manual-deobfuscation.md)

## 实验室

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b 是一个基于 ubuntu-mate 的 Android 安全虚拟机，包含来自不同安全极客和研究人员的最新框架、教程和实验室，用于逆向工程和恶意软件分析。

## 参考资料

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) 这是一个很好的资源列表
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android 快速课程
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)

## 尚待尝试

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
