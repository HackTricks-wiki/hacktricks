# Androidアプリケーション Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Androidアプリケーションの基本

このページを最初に読むことを強く推奨します。**Androidのセキュリティに関連する最も重要な部分と、Androidアプリケーション内で最も危険なコンポーネント**について知るためです:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

これはエミュレートされたデバイスや実機に接続するための主要なツールです。\
**ADB** を使うと、コンピュータから **USB** または **Network** 経由でデバイスを制御できます。このユーティリティは、**双方向のファイルコピー**、アプリの**インストール**および**アンインストール**、シェルコマンドの**実行**、データの**バックアップ**、ログの**読み取り**などの機能を提供します。

adbの使い方を学ぶために次の[**ADB Commands**](adb-commands.md)のリストを参照してください。

## Smali

時には、**アプリケーションのコードを修正**して**隠された情報**（高度に難読化されたパスワードやフラグなど）にアクセスすることが有益です。その場合、apkを逆コンパイルしてコードを変更し、再コンパイルすることが有効かもしれません。\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md)。これは、これから紹介する動的解析中のいくつかのテストに対する**代替手段**として非常に役立ちます。したがって、**常にこの可能性を念頭に置いてください**。

## Other interesting tricks

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [Android IME / InputMethodService Abuse (Malicious Keyboards)](inputmethodservice-ime-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Extract APK from device:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- [APKEditor](https://github.com/REAndroid/APKEditor) を使って、すべての splits と base apks をマージする:
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Android Enterprise & Work Profile 攻撃

{{#ref}}
android-enterprise-work-profile-bypass.md
{{#endref}}

## ケーススタディ & 脆弱性


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}


{{#ref}}
../../binary-exploitation/linux-kernel-exploitation/arm64-static-linear-map-kaslr-bypass.md
{{#endref}}

## 静的解析

まず第一に、APK を解析する際は **decompiler を使って Java コードを確認する**べきです。\
[**こちらを読んで、利用可能なさまざまな decompiler に関する情報を確認してください**](apk-decompilers.md)。

### 興味深い情報を探す

APK の **strings** を見るだけでも、**passwords**、**URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep))、**API** keys、**encryption**、**bluetooth uuids**、**tokens** など興味深いものを探せます。コード実行の **backdoors** や認証用の backdoors（アプリにハードコードされた管理者資格情報）も確認してください。

Firebase

**Firebase** の URL には特に注意し、設定不備がないか確認してください。[Firebase が何か、またそれをどう悪用するかの詳細はこちら。](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### アプリケーションの基本理解 - Manifest.xml, strings.xml

アプリケーションの **Manifest.xml** と **strings.xml** を確認することで、潜在的なセキュリティ脆弱性が明らかになることがあります。これらのファイルは decompiler でアクセスするか、APK の拡張子を .zip に変更して展開することで取得できます。

Manifest.xml から特定できる **脆弱性** には次のものがあります:

- **Debuggable Applications**: Manifest.xml で `debuggable="true"` に設定されたアプリケーションはリスクを伴います。デバッグ接続を許可することで、悪用につながる可能性があります。デバッグ可能なアプリをデバイス上で見つけて悪用する方法については該当のチュートリアルを参照してください。
- **Backup Settings**: `android:allowBackup="false"` 属性は、機密情報を扱うアプリケーションでは明示的に設定しておくべきです。特に usb debugging が有効な場合、adb を使った不正なデータバックアップを防ぐために重要です。
- **Network Security**: `android:networkSecurityConfig="@xml/network_security_config"` のようなカスタムネットワークセキュリティ設定（res/xml/ 内）は、証明書ピンや HTTP トラフィックの許可設定などのセキュリティ詳細を指定できます。例えば特定ドメインに対して HTTP を許可する設定などがあります。
- **Exported Activities and Services**: manifest 内でエクスポートされている activities や services を特定することで、悪用され得るコンポーネントが浮かび上がります。動的テスト時の追加解析で、これらコンポーネントの悪用方法が明らかになることがあります。
- **Content Providers and FileProviders**: 公開された content providers はデータの不正アクセスや改ざんを許してしまう可能性があります。FileProviders の設定も注意深く確認してください。
- **Broadcast Receivers and URL Schemes**: これらのコンポーネントは悪用される可能性があり、特に URL スキームの扱い方による入力脆弱性に注意が必要です。
- **SDK Versions**: `minSdkVersion`、`targetSDKVersion`、`maxSdkVersion` の属性はサポート対象の Android バージョンを示します。脆弱な古い Android バージョンをサポートしている場合はセキュリティ上の懸念点になります。

strings.xml からは、API キーやカスタムスキーマ、開発者のメモなどの機密情報が見つかることがあるため、これらのリソースを慎重に確認する必要があります。

### Tapjacking

**Tapjacking** は、**malicious** な **application** を起動して被害者アプリの上に **表示させる** 攻撃です。被害者アプリを視覚的に覆い隠した状態で、攻撃アプリの UI はユーザーをだまして操作させるように設計されており、同時にその操作を被害者アプリへ透過的に渡します。\
結果として、ユーザーは実際には被害者アプリ上で操作を行っていることに気づかされません。

詳細は以下を参照してください:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

`launchMode` が `singleTask` に設定され、`taskAffinity` が定義されていない activity は Task Hijacking に対して脆弱です。つまり、悪意のある **application** をインストールしてそれを本物のアプリより先に起動すると、**本来のアプリのタスクをハイジャックする**可能性があります（ユーザーは本物のアプリを使っているつもりで実は **malicious application** を操作していることになります）。

詳細は以下を参照してください:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### 不適切なデータ保存

Internal Storage

Android では、内部ストレージに保存されたファイルはそれを作成したアプリのみがアクセスできるよう設計されています。このセキュリティ対策は OS によって強制され、ほとんどのアプリケーションのセキュリティ要件に対して十分であることが多いです。しかし、開発者が `MODE_WORLD_READABLE` や `MODE_WORLD_WRITABLE` のようなモードを使って異なるアプリ間でファイルを共有することがあります。これらのモードは他のアプリ（悪意あるものを含む）によるアクセスを制限しません。

1. Static Analysis:
- `MODE_WORLD_READABLE` や `MODE_WORLD_WRITABLE` の使用は慎重に確認してください。これらのモードはファイルを意図しない、あるいは不正なアクセスにさらす可能性があります。
2. Dynamic Analysis:
- アプリが作成するファイルに設定されている権限を検証してください。特に、ファイルが世界中から読み取り/書き込み可能になっていないかを確認します。これが許されていると、インストールされているどのアプリでもそのファイルを読み書きできるようになり重大なリスクになります。

External Storage

SD カードなどの外部ストレージ上のファイルについては、以下の注意が必要です:

1. Accessibility:
- 外部ストレージ上のファイルはグローバルに読み書き可能です。つまり、どのアプリやユーザーでもこれらのファイルにアクセスできます。
2. Security Concerns:
- アクセスが容易なため、機密情報を外部ストレージに保存しないことが推奨されます。
- 外部ストレージは取り外し可能であり、任意のアプリからアクセスされる可能性があるため安全性は低くなります。
3. Handling Data from External Storage:
- 外部ストレージから取得したデータに対しては常に入力検証を行ってください。外部ストレージは信頼できないソースからのデータと見なすべきです。
- 外部ストレージに実行ファイルや class ファイルを置いて動的に読み込むことは強く非推奨です。
- アプリが外部ストレージから実行ファイルを読み込む必要がある場合は、それらのファイルが署名されており暗号的に検証されていることを確認してから動的にロードしてください。これはアプリケーションのセキュリティ整合性を保つために重要です。

外部ストレージには `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard` でアクセスできます

> [!TIP]
> Android 4.4（**API 17**）以降では、SD カードはアプリごとにアクセスできるディレクトリ構造があり、アプリが自分専用のディレクトリ以外にアクセスすることを制限します。これにより悪意あるアプリが他のアプリのファイルを読み書きするのを防ぎます。

**クリアテキストで保存された機密データ**

- **Shared preferences**: Android は各アプリが `/data/data/<packagename>/shared_prefs/` に簡単に XML ファイルを保存できるようにしており、そのフォルダ内にクリアテキストで機密情報が含まれていることがあります。
- **Databases**: Android は各アプリが `/data/data/<packagename>/databases/` に sqlite データベースを保存できるようにしており、そのフォルダ内にクリアテキストで機密情報が含まれていることがあります。

### Broken TLS

**Accept All Certificates**

なぜか時々開発者がすべての証明書を受け入れてしまうことがあります。例えばホスト名が一致しない場合でも次のようなコード行で証明書をすべて受け入れてしまうことがあります:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### 脆弱な暗号化

**不十分な鍵管理プロセス**

一部の開発者は機密データをローカルストレージに保存し、コード内にハードコード／予測可能なキーで暗号化しています。リバースエンジニアリングにより攻撃者が機密情報を抽出できる可能性があるため、これは避けるべきです。

**安全でないおよび/または廃止されたアルゴリズムの使用**

開発者は認可チェック、データの保存や送信に対して**廃止されたアルゴリズム**を使用すべきではありません。これらのアルゴリズムの例：RC4, MD4, MD5, SHA1... 例えばパスワード保存に**hashes**を使用する場合は、salt を使い、ブルートフォースに**耐性のある**ハッシュを使用するべきです。

### その他のチェック

- APK を逆解析しにくくするために、**APK を難読化する**ことを推奨します。
- アプリが機密性の高いものであれば（銀行アプリ等）、**デバイスが root されているかを自分でチェック**し、それに応じて動作するべきです。
- アプリが機密性の高いものであれば（銀行アプリ等）、**エミュレータが使用されていないかの検査**を行うべきです。
- アプリが機密性の高いものであれば（銀行アプリ等）、**実行前に自分自身の整合性をチェック**して改変されていないか確認するべきです。
- [**APKiD**](https://github.com/rednaga/APKiD) を使って、APK のビルドに使用されたコンパイラ/パッカー/難読化ツールを確認してください。

### React Native Application

以下のページを読んで、React アプリケーションの javascript コードに簡単にアクセスする方法を学んでください：


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

以下のページを読んで、Xamarin アプリケーションの C# コードに簡単にアクセスする方法を学んでください：


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

この [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) によると、superpacked はアプリのコンテンツを単一ファイルに圧縮する Meta アルゴリズムです。ブログではこの種のアプリを展開するアプリを作成する可能性について触れており、もう一つのより高速な方法として、**アプリケーションを実行してファイルシステムから展開済みファイルを収集する**方法が挙げられています。

### 自動静的コード解析

[**mariana-trench**](https://github.com/facebook/mariana-trench) は、アプリケーションの**コード**を**スキャン**して**脆弱性**を検出することができるツールです。このツールは一連の**known sources**（ツールに**ユーザが制御する入力が入る場所**を示す）、**sinks**（悪意あるユーザ入力がダメージを与えうる**危険な場所**を示す）および**rules**を含みます。これらのルールは、脆弱性を示す**sources-sinks の組み合わせ**を指定します。

この知識に基づき、**mariana-trench はコードをレビューして可能な脆弱性を見つけます**。

### 秘密 leaked

アプリケーション内には秘密（API keys、passwords、hidden urls、subdomains...）が含まれていることがあり、それらを発見できる場合があります。例えば次のツールを使用できます: [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### その他の興味深い関数

- **コード実行**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **SMS 送信**: `sendTextMessage, sendMultipartTestMessage`
- **native 関数** が `native` として宣言されている: `public native, System.loadLibrary, System.load`
- [ネイティブ関数をリバースする方法はこちらを参照してください](reversing-native-libraries.md)
- JNI 経由のインメモリネイティブコード実行（ダウンロードした shellcode → mmap/mprotect → 呼び出し）:

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **その他のトリック**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## 動的解析

> まず第一に、アプリケーションをインストールでき、必要な環境（Burp CA cert、Drozer、Frida など）を整えられる環境が必要です。したがって、root 化されたデバイス（エミュレータでも可）が強く推奨されます。

### オンライン動的解析

無料アカウントを作成できるサービス: [https://appetize.io/](https://appetize.io)。このプラットフォームは APK を**アップロード**して**実行**することができるため、APK の挙動を確認するのに便利です。

ウェブ上でアプリケーションのログを**見る**ことや、**adb** を介して接続することもできます。

![](<../../images/image (831).png>)

ADB 接続のおかげで、エミュレータ内で **Drozer** や **Frida** を使用できます。

### ローカル動的解析

#### エミュレータを使用する場合

- [**Android Studio**](https://developer.android.com/studio)（**x86** と **arm** デバイスを作成可能。かつ [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**によれば最新の x86 バージョンは ARM ライブラリをサポートしており、遅い arm エミュレータを使う必要がない**）。
- セットアップ方法は以下のページで学んでください：


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition、アカウント作成が必要です。_潜在的なエラーを避けるために_ _**VirtualBox 同梱版をダウンロードすることを推奨します。**_)_
- [**Nox**](https://es.bignox.com)（無料ですが、Frida や Drozer をサポートしていません）。

> [!TIP]
> どのプラットフォームでも新しいエミュレータを作成する際は、画面サイズが大きいほどエミュレータの動作が遅くなることを覚えておいてください。可能なら小さい画面を選択してください。

Genymotion に Google サービス（例えば Play Store）をインストールするには、次の画像の赤で示したボタンをクリックする必要があります:

![](<../../images/image (277).png>)

また、**Genymotion の Android VM の構成**では **Bridge Network mode** を選択できる点に注意してください（別の VM からツールで Android VM に接続する場合に便利です）。

#### 実機を使用する場合

**デバッグオプション**を有効にする必要があります。できれば **root** しておくと便利です:

1. **Settings**.
2. (Android 8.0 以降) **System** を選択。
3. **About phone** を選択。
4. **Build number** を7回押す。
5. 戻ると **Developer options** が表示されます。

> アプリをインストールしたら、まずはアプリを実行してその挙動や仕組みを調査し、慣れてください。\
> 初期の動的解析は MobSF dynamic analysis + pidcat を使って行うことを推奨します。そうすることで MobSF が多くの**興味深いデータ**をキャプチャする間に、アプリの動作を学習できます。

Magisk/Zygisk クイックノート（Pixel デバイスで推奨）
- Magisk アプリで boot.img をパッチし、fastboot 経由でフラッシュして systemless root を得る
- Zygisk を有効にし、DenyList で root 隠蔽を行う；より強力な隠蔽が必要な場合は LSPosed/Shamiko を検討する
- OTA 更新から回復するためにオリジナルの boot.img を保管しておく；OTA 後に再パッチする
- 画面ミラーリングにはホスト上で scrcpy を使用する

### 意図しないデータ漏洩

**Logging**

開発者はデバッグ情報を公開すると機密データのleaksにつながる可能性があるため注意すべきです。アプリのログを監視して機密情報を特定・保護するために、ツール [**pidcat**](https://github.com/JakeWharton/pidcat) や `adb logcat` の使用が推奨されます。**Pidcat** は使いやすさと可読性の面で好まれます。

> [!WARNING]
> Android 4.0 より新しいバージョンでは、**アプリケーションは自分自身のログにのみアクセス可能**です。他のアプリのログにはアクセスできません。\
> それでも、**機密情報をログに残さない**ことを強く推奨します。

**コピー/ペーストのバッファキャッシュ**

Android の **クリップボードベースの**フレームワークはアプリ間でのコピー＆ペーストを可能にしますが、**他のアプリケーションがクリップボードにアクセスできる**ため、機密データが露呈するリスクがあります。クレジットカード情報などの機密箇所ではコピー/ペースト機能を**無効にする**ことが重要です。

**クラッシュログ**

アプリが**クラッシュ**してログを保存する場合、これらのログは特にアプリの逆解析が難しい場合に攻撃者の助けになります。このリスクを軽減するため、クラッシュ時にログを残さないようにし、ネットワーク経由でログを送信する必要がある場合は必ず SSL チャネルで送信してください。

pentester として、**これらのログを確認する**ことを試みてください。

**サードパーティへの送信される分析データ**

アプリはしばしば Google Adsense のようなサービスを統合しており、開発者の不適切な実装により機密データがleakする可能性があります。潜在的なデータ漏洩を特定するには、アプリのトラフィックを傍受してサードパーティに機密情報が送信されていないか確認してください。

### SQLite DBs

ほとんどのアプリは情報を保存するために**内部 SQLite データベース**を使用します。ペンテスト時には作成された**データベース**、**テーブル名**や**カラム名**、保存されている**全データ**を確認してください。そこに**機密情報**が見つかることがあり、これは脆弱性となります。\
データベースは通常 `/data/data/the.package.name/databases` にあります（例: `/data/data/com.mwr.example.sieve/databases`）。

データベースが機密情報を保存していて**暗号化されている**場合でも、アプリケーション内でその**パスワードを見つけられる**なら、それは依然として**脆弱性**です。

`.tables` でテーブルを列挙し、`.schema <table_name>` でテーブルのカラムを列挙してください。

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** を使うと **Android アプリとしての振る舞いを模倣**し、他のアプリと相互作用できます。インストール済みアプリが行えることは何でも実行でき、Android の Inter-Process Communication (IPC) 機構を利用して基盤となる OS とやり取りできます。\
Drozer はエクスポートされた activities、exported services、および Content Providers を**悪用（exploit）**するのに有用なツールです。以下のセクションで学びます。

### エクスポートされた Activities の悪用

[**Android Activity が何かを復習したい場合はこちらを読んでください。**](android-applications-basics.md#launcher-activity-and-other-activities)\
また、Activity のコードは通常 **`onCreate`** メソッドから始まることを覚えておいてください。

**認可バイパス**

Activity が exported されている場合、外部アプリからその画面を呼び出すことができます。したがって、**機密情報を表示する Activity が exported されている**と、認証機構を**バイパス**してアクセスできる可能性があります。

[**Drozer で exported activities を悪用する方法を学ぶ。**](drozer-tutorial/index.html#activities)

また、adb から exported activity を起動することもできます:

- PackageName は com.example.demo
- Exported ActivityName は com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSFはactivityで`android:launchMode`として_**singleTask/singleInstance**_を使用していることを悪意あるものとして検出しますが、[this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750)によれば、これは古いバージョン（API versions < 21）でのみ危険なようです。

> [!TIP]
> authorisation bypassが必ずしも脆弱性とは限らないことに注意してください。これはbypassの動作と露出する情報によります。

**Sensitive information leakage**

**Activitiesは結果を返すこともできます**。エクスポートされ保護されていないactivityが**`setResult`**メソッドを呼び出して**機密情報を返す**ようなものを見つけられた場合、機密情報の漏えいが発生します。

#### Tapjacking

Tapjackingが防止されていない場合、エクスポートされたactivityを悪用して**ユーザーに予期しない操作をさせる**ことができます。For more info about [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providersは基本的に**データを共有**するために使われます。アプリに利用可能なcontent providersがある場合、それらから**機密データを抽出**できる可能性があります。また、脆弱である可能性があるため、**SQL injections**や**Path Traversals**のテストを行うことも重要です。

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Serviceの動作は`onStartCommand`メソッドから始まることを忘れないでください。

Serviceは基本的にデータを**受け取り**、**処理**し、（場合によっては）レスポンスを**返す**ものです。したがって、アプリがいくつかのserviceをエクスポートしている場合は、何をしているかを理解するために**コードを確認**し、機密情報の抽出や認証回避を目的として**動的にテスト**するべきです。\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Broadcast Receiverの動作は`onReceive`メソッドから始まることを忘れないでください。

Broadcast receiverは特定の種類のメッセージを待ち受けています。メッセージの処理方法によっては脆弱になる可能性があります。\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

手動でdeep linksを探すことができます。MobSFのようなツールや[this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py)のようなスクリプトを使用してください。\
宣言された**scheme**は**adb**または**browser**で開くことができます:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_**パッケージ名を省略しても**、モバイルがそのリンクを開くアプリを自動的に呼び出します。_
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**実行されるコード**

アプリで**実行されるコード**を見つけるには、deeplink によって呼び出される activity に移動し、関数 **`onNewIntent`** を検索してください。

![](<../../images/image (436) (1) (1) (1).png>)

**Sensitive info**

deep link を見つけるたびに、**URL パラメータ経由でパスワードのような機密データを受け取っていないか**を確認してください。さもないと他のアプリが **deep link を偽装してそのデータを盗む**可能性があります！

**Parameters in path**

URL のパス内にパラメータを使用している deep link がないかを**必ず確認してください**。例えば: `https://api.example.com/v1/users/{username}` のようなケースでは、次のようにパストラバーサルを強制できる可能性があります: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
アプリ内で正しいエンドポイントを見つけた場合、パスの一部がドメイン名として使われていると **Open Redirect** を引き起こしたり、CSRF トークンなしでユーザ詳細を変更できる場合は **account takeover**（脆弱なエンドポイントが正しいメソッドを使用している場合）など、その他の脆弱性を誘発できる可能性があります。More [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

リンクに関する [interesting bug bounty report](https://hackerone.com/reports/855618)（_/.well-known/assetlinks.json_）は興味深い報告です。

### Transport Layer Inspection and Verification Failures

- **Certificates are not always inspected properly** by Android applications. これらのアプリは警告を無視して自己署名証明書を受け入れたり、場合によっては HTTP にフォールバックすることがよくあります。
- **Negotiations during the SSL/TLS handshake are sometimes weak**, 不適切な暗号スイートを使用することがあり、この脆弱性により接続が MITM 攻撃に対して脆弱になり、攻撃者がデータを復号できる可能性があります。
- **Leakage of private information** は、アプリが認証にはセキュアなチャネルを使用するが他の通信に非セキュアなチャネルを使用する場合にリスクとなります。この手法ではセッション Cookie やユーザ情報などの機密データが悪意ある第三者に傍受されるおそれがあります。

#### Certificate Verification

ここでは **certificate verification** に焦点を当てます。サーバ証明書の整合性を検証することはセキュリティ向上のために重要です。不適切な TLS 設定や暗号化されていないチャネルでの機密データ送信は重大なリスクをもたらすためです。サーバ証明書の検証と脆弱性対処の詳細な手順については、[**this resource**](https://manifestsecurity.com/android-application-security-part-10/) を参照してください。

#### SSL Pinning

SSL Pinning は、アプリがサーバの証明書をアプリ内に保存された既知のコピーと照合するセキュリティ対策です。この方法は MITM 攻撃を防ぐために重要であり、機密情報を扱うアプリには SSL Pinning の実装が強く推奨されます。

#### Traffic Inspection

HTTP トラフィックを検査するには、プロキシツールの証明書（例: Burp）を**インストールする必要があります**。この証明書をインストールしないと、暗号化されたトラフィックはプロキシ経由で見えない場合があります。カスタム CA 証明書のインストール方法については [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine) を参照してください。

**API Level 24 and above** をターゲットにしているアプリは、プロキシの CA 証明書を受け入れるように Network Security Config の変更が必要です。暗号化されたトラフィックを検査するためにこの手順は重要です。Network Security Config の変更手順については [**refer to this tutorial**](make-apk-accept-ca-certificate.md) を参照してください。

もし **Flutter** を使用している場合は、[**this page**](flutter.md) の指示に従う必要があります。単に証明書をストアに追加するだけでは動作しないことがあり、Flutter は独自の有効な CA リストを持っているためです。

#### Static detection of SSL/TLS pinning

ランタイムでのバイパスを試みる前に、APK 内でどこに pinning が強制されているかを素早くマッピングしてください。静的検出によりフック/パッチの計画を立て、適切なコードパスに集中できます。

Tool: SSLPinDetect
- Open-source な静的解析ユーティリティで、APK を Smali にデコンパイル（apktool 経由）して、SSL/TLS pinning 実装のためのキュレートされた正規表現パターンをスキャンします。
- 各マッチに対して正確なファイルパス、行番号、およびコードスニペットを報告します。
- 共通のフレームワークやカスタムコードパスをカバーします: OkHttp CertificatePinner、カスタム javax.net.ssl.X509TrustManager.checkServerTrusted、SSLContext.init とカスタム TrustManagers/KeyManagers、Network Security Config XML pins など。

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
使い方
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
パターンルールの例 (JSON)
signatures を使用または拡張して、プロプライエタリ／カスタムの pinning スタイルを検出します。独自の JSON を読み込み、大規模に scan できます。
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes and tips
- 大規模アプリの高速スキャンはマルチスレッディングとメモリマップドI/Oを利用する；事前コンパイルされた正規表現はオーバーヘッドや誤検知を減らす。
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- 次に優先的にトリアージすべき典型的な検出ターゲット:
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Declarative pins in res/xml network security config and manifest references
- 一致した箇所を使って Frida フック、静的パッチ、または設定レビューを動的テスト前に計画する。



#### SSL Pinning のバイパス

アプリに SSL Pinning が実装されている場合、HTTPS トラフィックを解析するためにそれをバイパスする必要が出てくる。目的のために利用できる方法はいくつかある:

- Automatically **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). このオプションの最大の利点は、SSL Pinning をバイパスするために root が不要な点だが、アプリを削除して新しいものを再インストールする必要があり、常に成功するとは限らない。
- You could use **Frida** (discussed below) to bypass this protection. Here you have a guide to use Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- You can also try to **automatically bypass SSL Pinning** using [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- You can also try to **automatically bypass SSL Pinning** using **MobSF dynamic analysis** (explained below)
- If you still think that there is some traffic that you aren't capturing you can try to **forward the traffic to burp using iptables**. Read this blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Looking for Common Web Vulnerabilities

アプリ内で一般的な Web 脆弱性を検索することも重要である。これらの脆弱性の特定と緩和に関する詳細な情報はこの要約の範囲を超えるが、他の資料で広く扱われている。

### Frida

[Frida](https://www.frida.re) は開発者、リバースエンジニア、セキュリティ研究者向けの動的インストルメンテーションツールキットである。\
**実行中のアプリにアクセスしてランタイムでメソッドをフックし、振る舞いを変更したり、値を変更・抽出したり、別のコードを実行したりできる。**\
Android アプリを pentest するなら Frida の使い方を知っておく必要がある。

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Some "GUI" for actions with Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- You can find some Awesome Frida scripts here: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Try to bypass anti-debugging / anti-frida mechanisms loading Frida as in indicated in [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

アプリがパスワードやニーモニック（シードフレーズ）など、本来メモリに保持すべきでない機密情報をメモリ内に保存していないかを確認する。

Using [**Fridump3**](https://github.com/rootbsd/fridump3) you can dump the memory of the app with:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
これにより ./dump フォルダにメモリがダンプされ、そこで次のように grep できます:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Keystore内の機密データ**

AndroidではKeystoreが機密データを保存する最良の場所ですが、十分な特権があれば、それでも**アクセス可能です**。アプリケーションはここに**平文の機密データ**を保存する傾向があるため、pentestsではroot userとして確認する必要があります。デバイスに物理的にアクセスできる人物がこのデータを盗む可能性があります。

たとえアプリがKeystoreにデータを保存していても、そのデータは暗号化されているべきです。

Keystore内のデータにアクセスするには、このFridaスクリプトを使用できます: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

以下のFridaスクリプトを使用すると、Androidアプリが特定の機密領域を保護するために実行している**bypass fingerprint authentication**が可能になる場合があります：
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **バックグラウンド画像**

アプリをバックグラウンドにすると、Androidは**アプリケーションのスナップショット**を保存します。これにより、フォアグラウンドに戻したときにアプリ本体より先にその画像を読み込んで表示するため、アプリの起動が速く見えます。

ただし、そのスナップショットに**機密情報**が含まれている場合、そのスナップショットにアクセスできる人物が**その情報を盗む**可能性があります（アクセスするにはroot権限が必要です）。

スナップショットは通常次の場所に保存されます: **`/data/system_ce/0/snapshots`**

Androidは、レイアウトパラメータに**FLAG_SECUREを設定してスクリーンショットの取得を防ぐ**方法を提供しています。このフラグを使用するとウィンドウの内容がセキュアとして扱われ、スクリーンショットに表示されたり、安全でないディスプレイで表示されたりするのを防ぎます。
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

このツールは動的分析中に複数のツールを管理するのに役立ちます: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

開発者はしばしば activities、services、broadcast receivers のようなプロキシコンポーネントを作成し、これらのIntentを処理して `startActivity(...)` や `sendBroadcast(...)` などのメソッドに渡しますが、これは危険を招くことがあります。

問題は、これらのIntentを誤誘導することで攻撃者が export されていないアプリコンポーネントをトリガーしたり、機密性の高い content providers にアクセスできるようになってしまう点です。代表的な例として、`WebView` コンポーネントが URL を `Intent.parseUri(...)` を使って `Intent` オブジェクトに変換し、それを実行してしまうことで、悪意ある Intent 注入を招く可能性があるケースがあります。

### Essential Takeaways

- **Intent Injection** は Web の Open Redirect 問題に似ています。
- 攻撃は `Intent` オブジェクトを extras として渡すことで行われ、リダイレクトされて安全でない操作を実行させる可能性があります。
- それにより export されていないコンポーネントや content providers が攻撃者に露出する可能性があります。
- `WebView` の URL から `Intent` への変換が意図しない動作を引き起こす可能性があります。

### Android Client Side Injections and others

多くはウェブで見られる脆弱性と同様のものです。Android アプリでは特に注意する必要があります：

- **SQL Injection:** 動的なクエリや Content-Providers を扱う場合は、パラメータ化されたクエリを使用していることを確認してください。
- **JavaScript Injection (XSS):** 任意の WebView について JavaScript と Plugin サポートが無効になっているかを確認してください（デフォルトで無効）。 [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebView はファイルシステムへのアクセスを無効にするべきです（デフォルトで有効） - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: 多くの場合、Android アプリがセッションを終了してもクッキーが無効化されなかったり、ディスクに保存されてしまうことがあります
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Static analysis**

![](<../../images/image (866).png>)

**使いやすい web ベースのフロントエンドを使ってアプリケーションの脆弱性評価を行えます。** 動的分析も実行可能ですが、環境の準備が必要です。
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Assisted Dynamic analysis with MobSF

**MobSF** can also be very helpful for **dynamic analysis** in **Android**, but in that case you will need to install MobSF and **genymotion** in your host (a VM or Docker won't work). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
The **MobSF dynamic analyser** can:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). All of this is done automatically except for the screenshots, you need to press when you want a screenshot or you need to press "**Exported Activity Tester**" to obtain screenshots of all the exported activities.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: It will print all the loaded classes
- **Capture Strings**: It will print all the capture strings while using the application (super noisy)
- **Capture String Comparisons**: Could be very useful. It will **show the 2 strings being compared** and if the result was True or False.
- **Enumerate Class Methods**: Put the class name (like "java.io.File") and it will print all the methods of the class.
- **Search Class Pattern**: Search classes by pattern
- **Trace Class Methods**: **Trace** a **whole class** (see inputs and outputs of all methods of th class). Remember that by default MobSF traces several interesting Android Api methods.

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf also brings you a shell with some **adb** commands, **MobSF commands**, and common **shell** **commands** at the bottom of the dynamic analysis page. Some interesting commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP ツール**

When http traffic is capture you can see an ugly view of the captured traffic on "**HTTP(S) Traffic**" bottom or a nicer view in "**Start HTTPTools**" green bottom. From the second option, you can **send** the **captured requests** to **proxies** like Burp or Owasp ZAP.\
To do so, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> press "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Once you finish the dynamic analysis with MobSF you can press on "**Start Web API Fuzzer**" to **fuzz http requests** an look for vulnerabilities.

> [!TIP]
> MobSF で動的解析を行った後、プロキシ設定が誤って構成され GUI から修正できない場合があります。プロキシ設定は次のコマンドで修正できます:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Inspeckage を使った支援付き動的解析

You can get the tool from [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
This tool with use some **Hooks** to let you know **what is happening in the application** while you perform a **dynamic analysis**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

これは GUI で静的解析を行うのに **優れたツール** です

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

This tool is designed to look for several **security related Android application vulnerabilities**, either in **source code** or **packaged APKs**. The tool is also **capable of creating a "Proof-of-Concept" deployable APK** and **ADB commands**, to exploit some of the found vulnerabilities (Exposed activities, intents, tapjacking...). As with Drozer, there is no need to root the test device.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- 参照しやすいように抽出されたすべてのファイルを表示します
- APKファイルを自動で Java および Smali 形式にデコンパイルします
- AndroidManifest.xml を解析し、一般的な脆弱性や挙動を検出します
- 静的ソースコード解析により、一般的な脆弱性や挙動を検出します
- デバイス情報
- その他
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPERはWindows、MacOS X、Linuxで使用できるコマンドラインアプリケーションで、_.apk_ファイルを解析して脆弱性を探します。APKを展開し、一連のルールを適用してそれらの脆弱性を検出します。

すべてのルールは`rules.json`ファイルに集約されており、各企業やテスターは必要に応じて独自のルールを作成できます。

最新のバイナリは[download page](https://superanalyzer.rocks/download.html)からダウンロードしてください。
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAnは、モバイルアプリケーションに対して[static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis)を行う開発者、bugbounty hunters、ethical hackersを支援する**crossplatform**ツールです。

使い方は、モバイルアプリケーションファイル（.apk または .ipa ファイル）をStaCoAnアプリにドラッグ＆ドロップすると、視覚的で持ち運び可能なレポートを生成してくれます。設定やwordlistsを調整してカスタマイズされた体験を得ることができます。

ダウンロード[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Frameworkは、Androidの脆弱性分析システムで、開発者や hackers が Android アプリケーションの潜在的なセキュリティ脆弱性を発見するのを支援します。\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** は、Android アプリケーションによって発生し得る潜在的な悪意のある振る舞いを検出し、ユーザーに警告することを主目的としたツールです。

検出は、[`androguard`](https://github.com/androguard/androguard) ライブラリを使用して、アプリケーションの Dalvik bytecode を **Smali** として表現したものに対する **static analysis** により行われます。

このツールは **common behavior of "bad" applications** のような以下の振る舞いを検出します: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** は **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework です。これは、OWASP の mobile security threats に対するモバイルアプリケーションのテストを支援するために、一般的に使用されるモバイルアプリケーションの reverse engineering および analysis ツールをまとめたツールです。目的は、モバイルアプリ開発者やセキュリティ専門家にとってこの作業をより簡単で扱いやすくすることです。

以下が可能です:

- 異なるツールを使って Java および Smali コードを抽出する
- APK を以下で解析する: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- 正規表現を使用して APK から private information を抽出する。
- Manifest を解析する。
- 見つかったドメインを以下で解析する: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- [apk-deguard.com](http://www.apk-deguard.com) を通じて APK を deobfuscate する

### Koodous

マルウェア検出に役立ちます: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

使用するサービスや設定によっては、secrets が obfuscated される場合とされない場合があります。

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** は Java コードを縮小、最適化、obfuscate するオープンソースのコマンドラインツールです。バイトコードを最適化し、未使用の命令を検出して削除することができます。ProGuard はフリーソフトウェアで、GNU General Public License, version 2 の下で配布されています。

ProGuard は Android SDK の一部として配布され、アプリケーションを release mode でビルドする際に実行されます。

### [DexGuard](https://www.guardsquare.com/dexguard)

APK の deobfuscate に関するステップバイステップガイドは [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html) を参照してください。

(From that guide) 最後に確認したときの Dexguard の動作モードは以下でした:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard は Android obfuscation tools によって行われた obfuscation のプロセスを逆にします。これにより、code inspection や predicting libraries を含む多くのセキュリティ解析が可能になります。**

オブファスケートされた APK をプラットフォームにアップロードできます。

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

これは android apps の潜在的なセキュリティ脆弱性を見つけ、android app のコードを deobfuscate するための LLM ツールです。Google's Gemini public API を使用します。

### [Simplify](https://github.com/CalebFenton/simplify)

これは **generic android deobfuscator** です。Simplify は **実質的にアプリを実行して（virtually executes）その振る舞いを理解し、コードを最適化して** 人間にとって理解しやすくしつつ元と同じ振る舞いをするようにします。各最適化の種類は単純かつ汎用的で、どのような種類の obfuscation が使われているかは問題になりません。

### [APKiD](https://github.com/rednaga/APKiD)

APKiD は **APK がどのように作られたか** に関する情報を提供します。多くの **compilers**, **packers**, **obfuscators**, そしてその他の怪しいものを識別します。Android の [_PEiD_](https://www.aldeid.com/wiki/PEiD) といえます。

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b は ubuntu-mate ベースの Android security virtual machine で、reverse engineering と malware analysis 向けの最新の framework、チュートリアル、ラボを複数のセキュリティ研究者やリサーチャーから収集して含んでいます。

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) 優れたリソースのリストです
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android クイックコース
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
