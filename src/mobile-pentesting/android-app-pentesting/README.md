# Додатки Android Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Основи додатків Android

Рекомендується почати з цієї сторінки, щоб дізнатися про **найважливіші компоненти, пов'язані з безпекою Android, та найбільш небезпечні складові в Android-додатку**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

This is the main tool you need to connect to an android device (emulated or physical).\
**ADB** дозволяє керувати пристроями по **USB** або **Network** з комп'ютера. Ця утиліта дозволяє **копіювати** файли в обох напрямках, **встановлювати** та **видаляти** apps, **виконувати** shell-команди, **резервно зберігати** дані, **читати** logs, та інші функції.

Перегляньте наступний список [**ADB Commands**](adb-commands.md), щоб дізнатися, як використовувати adb.

## Smali

Іноді буває цікаво **змінити код додатку**, щоб отримати доступ до **прихованої інформації** (можливо добре обфусцовані паролі або flags). Тоді може бути цікаво декомпілювати the apk, змінити код і перекомпілювати його.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Це може бути дуже корисно як **альтернатива для кількох тестів під час динамічного аналізу**, що будуть представлені. Тому **завжди майте на увазі цю можливість**.

## Інші цікаві трюки

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **Завантажити APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Витягнути APK з пристрою:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Об'єднайте всі splits і base apks за допомогою [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Кейси та вразливості


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Статичний аналіз

По-перше, для аналізу APK слід **переглянути Java-код** за допомогою decompiler.\
Будь ласка, [**прочитайте тут, щоб знайти інформацію про різні доступні decompilers**](apk-decompilers.md).

### Пошук цікавої інформації

Просто переглянувши **strings** у APK, можна шукати **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** та все, що може бути цікавим... шукайте навіть code execution **backdoors** або authentication backdoors (жорстко вбудовані admin credentials у додатку).

**Firebase**

Зверніть особливу увагу на **firebase URLs** і перевірте, чи вони неправильно налаштовані. [Більше інформації про те, що таке Firebase і як його експлуатувати тут.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Базове розуміння застосунку - Manifest.xml, strings.xml

Дослідження файлів застосунку _Manifest.xml_ та _strings.xml_ може виявити потенційні вразливості. Ці файли можна отримати за допомогою decompilers або перейменувавши розширення APK на .zip і розпакувавши його.

**Вразливості**, які можна виявити в **Manifest.xml**, включають:

- **Debuggable Applications**: Застосунки, які мають `debuggable="true"` у _Manifest.xml_, становлять ризик, оскільки вони дозволяють підключення, що може призвести до експлуатації. Для подальшого розуміння того, як експлуатувати debuggable застосунки, зверніться до керівництва з пошуку та експлуатації debuggable застосунків на пристрої.
- **Backup Settings**: Атрибут `android:allowBackup="false"` слід явно встановлювати для застосунків, що працюють з чутливою інформацією, щоб запобігти несанкціонованому резервному копіюванню даних через adb, особливо коли увімкнено usb debugging.
- **Network Security**: Користувацькі налаштування network security (`android:networkSecurityConfig="@xml/network_security_config"`) у _res/xml/_ можуть вказувати параметри безпеки, як-от certificate pins та налаштування HTTP traffic. Наприклад, дозволи для HTTP-трафіку для певних доменів.
- **Exported Activities and Services**: Виявлення exported activities і services у manifest може вказати на компоненти, які можна зловживати. Подальший аналіз під час динамічного тестування може показати, як експлуатувати ці компоненти.
- **Content Providers and FileProviders**: Відкриті content providers можуть дозволити несанкціонований доступ або зміну даних. Слід ретельно перевірити конфігурацію FileProviders.
- **Broadcast Receivers and URL Schemes**: Ці компоненти можуть бути використані для експлуатації, особливо звертайте увагу на те, як обробляються URL schemes для можливих вразливостей вводу.
- **SDK Versions**: Атрибути `minSdkVersion`, `targetSDKVersion` і `maxSdkVersion` вказують підтримувані версії Android, підкреслюючи важливість уникнення підтримки застарілих, уразливих версій Android.

З файлу **strings.xml** можна знайти чутливу інформацію, таку як API keys, custom schemas та інші примітки розробників, що підкреслює необхідність ретельного перегляду цих ресурсів.

### Tapjacking

**Tapjacking** — це атака, коли **зловмисний додаток** запускається й **розміщується поверх додатку-жертви**. Коли воно візуально затуляє жертву, його інтерфейс спроектовано так, щоб обдурити користувача і змусити його взаємодіяти з ним, тоді як взаємодія передається до додатку-жертви.\
Фактично, це **позбавляє користувача можливості знати, що він насправді виконує дії у додатку-жертві**.

Детальніше в:

{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Activity з `launchMode`, встановленим у `singleTask` без визначеного `taskAffinity`, уразлива до Task Hijacking. Це означає, що шкідливий додаток може бути встановлений і, якщо його запустити перед реальним додатком, він може **перехопити task реального додатку** (тому користувач взаємодіятиме зі **зловмисним додатком, думаючи, що використовує реальний**).

Детальніше в:

{{#ref}}
android-task-hijacking.md
{{#endref}}

### Небезпечне збереження даних

**Internal Storage**

У Android файли, що зберігаються у внутрішньому сховищі, призначені бути доступними виключно для додатку, який їх створив. Цей захід безпеки примусово застосовується операційною системою Android і загалом відповідає потребам безпеки більшості додатків. Проте розробники іноді використовують режими на кшталт `MODE_WORLD_READABLE` та `MODE_WORLD_WRITABLE`, щоб дозволити спільний доступ до файлів між різними додатками. Однак ці режими **не обмежують доступ** до цих файлів іншими додатками, у тому числі потенційно шкідливими.

1. **Static Analysis:**
- **Переконайтеся**, що використання `MODE_WORLD_READABLE` і `MODE_WORLD_WRITABLE` ретельно перевіряється. Ці режими **можуть потенційно зробити файли доступними** для небажаного або несанкціонованого доступу.
2. **Dynamic Analysis:**
- **Перевірте** дозволи на файли, створені додатком. Зокрема, **перевірте**, чи встановлені які-небудь файли як доступні для читання або запису для всіх. Це може становити значний ризик безпеки, оскільки дозволяє **будь-якому додатку**, встановленому на пристрої, незалежно від його походження чи намірів, **читати або змінювати** ці файли.

**External Storage**

При роботі з файлами на external storage, таких як SD Cards, слід врахувати такі застереження:

1. **Доступність**:
- Файли на external storage зазвичай **загально доступні для читання і запису**. Це означає, що будь-який додаток або користувач може отримати до них доступ.
2. **Питання безпеки**:
- Через простоту доступу не рекомендується зберігати на external storage чутливу інформацію.
- External storage можна вийняти або до нього може отримати доступ будь-який додаток, що робить його менш безпечним.
3. **Обробка даних з external storage**:
- Завжди **виконуйте валідацію вводу** для даних, отриманих з external storage. Це критично, оскільки дані походять з ненадійного джерела.
- Не рекомендується зберігати виконувані файли або class-файли на external storage для динамічного завантаження.
- Якщо ваш додаток все ж має отримувати виконувані файли з external storage, переконайтеся, що ці файли **підписані та криптографічно перевірені** перед динамічним завантаженням. Цей крок є важливим для збереження цілісності безпеки вашого додатку.

External storage можна **знайти** в `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> Починаючи з Android 4.4 (**API 17**), структура директорій на SD-карті **обмежує доступ додатка лише до каталогу, призначеного конкретно для цього додатка**. Це запобігає тому, щоб шкідливий додаток отримав доступ для читання або запису файлів іншого додатку.

**Чутливі дані, збережені у відкритому вигляді**

- **Shared preferences**: Android дозволяє кожному додатку зручно зберігати xml-файли за шляхом `/data/data/<packagename>/shared_prefs/`, і іноді у цій папці можна знайти чутливу інформацію у відкритому вигляді.
- **Databases**: Android дозволяє кожному додатку зручно зберігати sqlite бази даних за шляхом `/data/data/<packagename>/databases/`, і іноді у цій папці можна знайти чутливу інформацію у відкритому вигляді.

### Проблеми з TLS

**Accept All Certificates**

З якоїсь причини іноді розробники приймають усі сертифікати, навіть якщо, наприклад, hostname не збігається, з рядками коду на кшталт наступного:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Неправильна криптографія

**Погані процеси управління ключами**

Деякі розробники зберігають конфіденційні дані у локальному сховищі й шифрують їх ключем, який закодовано в коді або є передбачуваним (hardcoded/predictable). Так не слід робити, оскільки деякий reversing може дозволити атакувальникам витягти конфіденційну інформацію.

**Використання небезпечних і/або застарілих алгоритмів**

Розробникам не слід використовувати **deprecated algorithms** для виконання авторизаційних перевірок, збереження або відправки даних. Деякі з таких алгоритмів: RC4, MD4, MD5, SHA1... Якщо для збереження паролів використовуються **hashes**, слід застосовувати стійкі до **brute-force** hashes з salt.

### Інші перевірки

- Рекомендується **obfuscate the APK**, щоб ускладнити роботу reverse engineer для атакувальників.
- Якщо додаток є критичним (наприклад банківський), він має виконувати власні перевірки, щоб визначити, чи мобільний пристрій rooted, і діяти відповідно.
- Якщо додаток є критичним (наприклад банківський), він має перевіряти, чи використовується **emulator**.
- Якщо додаток є критичним (наприклад банківський), він має **check it's own integrity before executing** щоб перевірити, чи не було його змінено.
- Використовуйте [**APKiD**](https://github.com/rednaga/APKiD), щоб перевірити, який compiler/packer/obfuscator був використаний для збірки APK

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

The tool [**mariana-trench**](https://github.com/facebook/mariana-trench) is capable of finding **vulnerabilities** by **scanning** the **code** of the application. This tool contains a series of **known sources** (that indicates to the tool the **places** where the **input** is **controlled by the user**), **sinks** (which indicates to the tool **dangerous** **places** where malicious user input could cause damages) and **rules**. These rules indicates the **combination** of **sources-sinks** that indicates a vulnerability.

With this knowledge, **mariana-trench will review the code and find possible vulnerabilities on it**.

### Secrets leaked

An application may contain secrets (API keys, passwords, hidden urls, subdomains...) inside of it that you might be able to discover. You could us a tool such as [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Інші цікаві функції

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Динамічний Аналіз

> Перш за все, вам потрібне середовище, де можна встановити додаток та всі інструменти (Burp CA cert, Drozer and Frida головним чином). Тому настійно рекомендується rooted пристрій (емулятор чи ні).

### Онлайн динамічний аналіз

Ви можете створити **free account** на: [https://appetize.io/](https://appetize.io). Ця платформа дозволяє вам **upload** і **execute** APKs, тому корисна, щоб подивитися, як apk поводиться.

Ви навіть можете **see the logs of your application** в вебі та підключитися через **adb**.

![](<../../images/image (831).png>)

Завдяки ADB-з'єднанню ви можете використовувати **Drozer** і **Frida** всередині емуляторів.

### Локальний динамічний аналіз

#### Використання емулятора

- [**Android Studio**](https://developer.android.com/studio) (You can create **x86** and **arm** devices, and according to [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** versions **support ARM libraries** without needing an slow arm emulator).
- Learn to set it up in this page:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, you need to create an account. _It's recommend to **download** the version **WITH**_ _**VirtualBox** to avoid potential errors._)
- [**Nox**](https://es.bignox.com) (Free, but it doesn't support Frida or Drozer).

> [!TIP]
> When creating a new emulator on any platform remember that the bigger the screen is, the slower the emulator will run. So select small screens if possible.

To **install google services** (like AppStore) in Genymotion you need to click on the red marked button of the following image:

![](<../../images/image (277).png>)

Also, notice that in the **configuration of the Android VM in Genymotion** you can select **Bridge Network mode** (this will be useful if you will be connecting to the Android VM from a different VM with the tools).

#### Use a physical device

You need to activate the **debugging** options and it will be cool if you can **root** it:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Once you have installed the application, the first thing you should do is to try it and investigate what does it do, how does it work and get comfortable with it.\
> I will suggest to **perform this initial dynamic analysis using MobSF dynamic analysis + pidcat**, so we will be able to **learn how the application works** while MobSF **captures** a lot of **interesting** **data** you can review later on.

### Unintended Data Leakage

**Logging**

Розробникам слід остерігатися публічного розкриття **debugging information**, оскільки це може призвести до чутливих data leak. Для моніторингу логів додатку та виявлення і захисту чутливої інформації рекомендовано використовувати інструменти [**pidcat**](https://github.com/JakeWharton/pidcat) і `adb logcat`. **Pidcat** цінується за простоту використання та читабельність.

> [!WARNING]
> Note that from **later newer than Android 4.0**, **applications are only able to access their own logs**. So applications cannot access other apps logs.\
> Anyway, it's still recommended to **not log sensitive information**.

**Copy/Paste Buffer Caching**

Android's **clipboard-based** framework enables copy-paste functionality in apps, yet poses a risk as **other applications** can **access** the clipboard, potentially exposing sensitive data. It's crucial to **disable copy/paste** functions for sensitive sections of an application, like credit card details, to prevent data leak.

**Crash Logs**

If an application **crashes** and **saves logs**, these logs can assist attackers, particularly when the application cannot be reverse-engineered. To mitigate this risk, avoid logging on crashes, and if logs must be transmitted over the network, ensure they are sent via an SSL channel for security.

As pentester, **try to take a look to these logs**.

**Analytics Data Sent To 3rd Parties**

Applications often integrate services like Google Adsense, which can inadvertently **leak sensitive data** due to improper implementation by developers. To identify potential data leaks, it's advisable to **intercept the application's traffic** and check for any sensitive information being sent to third-party services.

### SQLite DBs

Most of the applications will use **internal SQLite databases** to save information. During the pentest take a **look** to the **databases** created, the names of **tables** and **columns** and all the **data** saved because you could find **sensitive information** (which would be a vulnerability).\
Databases should be located in `/data/data/the.package.name/databases` like `/data/data/com.mwr.example.sieve/databases`

If the database is saving confidential information and is **encrypted b**ut you can **find** the **password** inside the application it's still a **vulnerability**.

Enumerate the tables using `.tables` and enumerate the columns of the tables doing `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer is s useful tool to **exploit exported activities, exported services and Content Providers** as you will learn in the following sections.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Also remember that the code of an activity starts in the **`onCreate`** method.

**Authorisation bypass**

When an Activity is exported you can invoke its screen from an external app. Therefore, if an activity with **sensitive information** is **exported** you could **bypass** the **authentication** mechanisms **to access it.**

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

You can also start an exported activity from adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> Зверніть увагу, що an authorisation bypass не завжди є вразливістю — це залежить від того, як bypass працює і яка інформація розкривається.

**Витік чутливої інформації**

**Activities can also return results**. Якщо вам вдасться знайти exported і unprotected activity, яка викликає метод **`setResult`** і повертає чутливу інформацію, це призводить до витоку чутливої інформації.

#### Tapjacking

Якщо Tapjacking не запобігається, ви можете зловживати exported activity, щоб змусити користувача виконати unexpected дії. For more info about [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers, в основному, використовуються для **обміну даними**. Якщо в додатку доступні content providers, ви можете змогли б **отримати чутливі** дані з них. Також варто перевірити можливі **SQL injections** і **Path Traversals**, оскільки вони можуть бути вразливими.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Пам'ятайте, що дії Service починаються в методі `onStartCommand`.

Сервіс по суті — це те, що **може отримувати дані**, **обробляти** їх і **повертати** (або ні) відповідь. Тому, якщо додаток експортує якісь сервіси, вам слід **перевірити** **код**, щоб зрозуміти, що він робить, і **протестувати** його **динамічно** для отримання конфіденційної інформації, обходу механізмів автентифікації тощо.\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Пам'ятайте, що дії Broadcast Receiver починаються в методі `onReceive`.

Broadcast receiver очікує певний тип повідомлення. Залежно від того, як receiver обробляє повідомлення, він може бути вразливим.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

You can look for deep links manually, using tools like MobSF or scripts like [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
You can **open** a declared **scheme** using **adb** or a **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Note that you can **omit the package name** and the mobile will automatically call the app that should open that link._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Код, що виконається**

Щоб знайти **код, який буде виконаний в App**, перейдіть до activity, викликаної deeplink, і знайдіть функцію **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Чутлива інформація**

Кожного разу, коли ви знаходите deep link, перевіряйте, чи i**t's not receiving sensitive data (like passwords) via URL parameters**, тому що будь-який інший додаток може **імітувати deep link і вкрасти ці дані!**

**Parameters in path**

Ви **також повинні перевірити, чи якийсь deep link не використовує параметр всередині шляху** URL, наприклад: `https://api.example.com/v1/users/{username}`, у такому випадку ви можете примусити path traversal, звернувшись, наприклад, до: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Зверніть увагу, що якщо ви знайдете правильні endpoints всередині додатку, ви можете спричинити **Open Redirect** (якщо частина шляху використовується як домен), **account takeover** (якщо ви можете змінити деталі користувача без CSRF token і вразливий endpoint використовував правильний метод) та будь-яку іншу vuln. Більше [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Transport Layer Inspection and Verification Failures

- **Certificates are not always inspected properly** by Android applications. Часто такі додатки ігнорують попередження й приймають self-signed certificates або, в деяких випадках, повертаються до використання HTTP-з’єднань.
- **Negotiations during the SSL/TLS handshake are sometimes weak**, застосовуючи небезпечні cipher suites. Ця вразливість робить з’єднання вразливим до man-in-the-middle (MITM) атак, дозволяючи атакуючим розшифровувати дані.
- **Leakage of private information** is a risk when applications authenticate using secure channels but then communicate over non-secure channels for other transactions. Такий підхід не захищає чутливі дані, наприклад session cookies або відомості користувачів, від перехоплення зловмисниками.

#### Certificate Verification

Ми зосередимося на **certificate verification**. Необхідно перевіряти цілісність сертифіката сервера для підвищення безпеки. Це критично, оскільки ненадійні налаштування TLS та передача чутливих даних по незашифрованих каналах можуть становити значні ризики. Для детальних кроків з перевірки сертифікатів сервера та усунення вразливостей — [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) містить вичерпні вказівки.

#### SSL Pinning

SSL Pinning — це захід безпеки, коли додаток перевіряє сертифікат сервера проти відомої копії, збереженої всередині самого додатку. Цей метод є важливим для запобігання MITM-атакам. Рекомендовано реалізувати SSL Pinning для додатків, що працюють з чутливою інформацією.

#### Traffic Inspection

Для інспекції HTTP-трафіку необхідно **встановити сертифікат проксі-інструмента** (наприклад, Burp). Без встановлення цього сертифіката зашифрований трафік може бути невидимим через проксі. Інструкцію зі встановлення кастомного CA-сертифіката дивіться [**тут**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Додатки, що таргетять **API Level 24 and above**, вимагають змін у Network Security Config, щоб приймати CA-сертифікат проксі. Це критичний крок для інспекції зашифрованого трафіку. Інструкції зі зміни Network Security Config дивіться [**туторіал**](make-apk-accept-ca-certificate.md).

Якщо використовується **Flutter**, потрібно слідувати інструкціям на [**цій сторінці**](flutter.md). Просто додати сертифікат у сховище може бути недостатньо, оскільки Flutter має власний список дійсних CA.

#### Static detection of SSL/TLS pinning

Перед тим як намагатися runtime bypasses, швидко знайдіть, де саме в APK запроваджено pinning. Статичне виявлення допомагає спланувати hooks/patches і зосередитися на потрібних code paths.

Tool: SSLPinDetect
- Open-source static-analysis utility, що декомпілює APK у Smali (через apktool) і сканує за курованими regex-патернами реалізацій SSL/TLS pinning.
- Повертає точний file path, номер рядка та фрагмент коду для кожного збігу.
- Покриває поширені фреймворки та кастомні шляхи: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, та Network Security Config XML pins.

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Використання
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Приклад правил шаблонів (JSON)
Використовуйте або розширюйте signatures для виявлення proprietary/custom pinning стилів. Ви можете завантажити власний JSON і виконувати масштабне сканування.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Поради та підказки
- Швидке сканування великих додатків через multi-threading та memory-mapped I/O; pre-compiled regex зменшує накладні витрати/хибні спрацьовування.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Типові цілі для виявлення та подальшої триажі:
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Declarative pins in res/xml network security config and manifest references
- Використовуйте знайдені локації для планування Frida hooks, static patches або перевірки конфігурацій перед динамічним тестуванням.



#### Bypassing SSL Pinning

Коли реалізовано SSL Pinning, його необхідно обійти для інспекції HTTPS-трафіку. Існують різні методи для цього:

- Автоматично **modify** the **apk** щоб **bypass** SSLPinning за допомогою [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Головна перевага цього варіанту в тому, що вам не знадобиться root для обходу SSL Pinning, але доведеться видалити додаток і перевстановити змінений, і це не завжди працює.
- Можна використовувати **Frida** (описана нижче) для обходу цього захисту. Ось гайд для використання Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Також можна спробувати **automatically bypass SSL Pinning** використовуючи [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Також можна спробувати **automatically bypass SSL Pinning** використовуючи **MobSF dynamic analysis** (пояснено нижче)
- Якщо ви все ще вважаєте, що якийсь трафік не захоплюється, можна спробувати **forward the traffic to burp using iptables**. Читайте цей блог: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Looking for Common Web Vulnerabilities

Важливо також шукати загальні web-вразливості всередині додатка. Детальна інформація про виявлення та пом'якшення цих вразливостей виходить за рамки цього огляду, але широко описана в інших джерелах.

### Frida

[Frida](https://www.frida.re) — це тулкіт для динамічної інструментації для розробників, реверс-інженерів і security researcher-ів.\
**Ви можете отримати доступ до запущеного додатка і hook методи під час виконання, щоб змінювати поведінку, змінювати значення, витягувати значення, виконувати інший код...**\
Якщо ви хочете pentest Android додатки, ви повинні вміти користуватись Frida.

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Some "GUI" for actions with Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- You can find some Awesome Frida scripts here: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Спробуйте обійти anti-debugging / anti-frida механізми, завантаживши Frida як вказано тут [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

Перевірте, чи додаток не зберігає в пам'яті конфіденційну інформацію, яку не повинен зберігати, наприклад паролі або мнемоніки.

Використовуючи [**Fridump3**](https://github.com/rootbsd/fridump3) ви можете зробити dump пам'яті додатка за допомогою:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Це вивантажить пам'ять у папку ./dump, і там ви можете виконати grep за допомогою чогось на кшталт:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Чутливі дані в Keystore**

В Android Keystore — найкраще місце для зберігання чутливих даних, однак при наявності достатніх привілеїв все ще **можна отримати до нього доступ**.

Оскільки додатки схильні зберігати тут **sensitive data in clear text**, pentests мають перевіряти це під root або особою з фізичним доступом до пристрою, яка може вкрасти ці дані.

Навіть якщо додаток зберіг дані в Keystore, ці дані повинні бути зашифровані.

Щоб отримати доступ до даних у Keystore, можна використати цей Frida script: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Використовуючи наступний Frida-скрипт, можливо виконати **bypass fingerprint authentication**, яке Android-додатки можуть використовувати для **захисту певних чутливих областей:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Фонові зображення**

Коли ви переводите застосунок у фон, Android зберігає **snapshot of the application**, тож при поверненні на передній план система спочатку завантажує це зображення перед самим застосунком, щоб здавалося, ніби застосунок відкрився швидше.

Однак, якщо цей snapshot містить **чутливу інформацію**, людина з доступом до snapshot може **вкрасти ці дані** (зверніть увагу, що для доступу потрібен root).

Snapshots зазвичай зберігаються за шляхом: **`/data/system_ce/0/snapshots`**

Android надає можливість **запобігти захопленню знімків екрана, встановивши параметр макета FLAG_SECURE**. Використовуючи цей флаг, вміст вікна вважається захищеним, що запобігає його появі у знімках екрана або перегляду на ненадійних дисплеях.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Цей інструмент може допомогти вам керувати різними інструментами під час dynamic analysis: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Розробники часто створюють proxy components, такі як activities, services і broadcast receivers, які обробляють ці Intents і передають їх у методи, такі як `startActivity(...)` або `sendBroadcast(...)`, що може бути ризиковано.

Небезпека полягає в тому, що атака може змусити виконати non-exported app components або отримати доступ до чутливих content providers, неправильно скерувавши ці Intents. Помітний приклад — компонент `WebView`, який перетворює URL у `Intent` об'єкти через `Intent.parseUri(...)` і потім виконує їх, що потенційно може призвести до malicious Intent injections.

### Essential Takeaways

- **Intent Injection** схоже на Open Redirect у web.
- Експлойти включають передачу `Intent` об'єктів як extras, які можуть бути перенаправлені для виконання небезпечних операцій.
- Це може відкрити non-exported components та content providers для атакуючих.
- Конвертація URL у `Intent` компонентом `WebView` може сприяти небажаним діям.

### Android Client Side Injections and others

Ймовірно, ви знайомі з цими типами вразливостей з Web. У Android application необхідно бути особливо уважним щодо таких вразливостей:

- **SQL Injection:** When dealing with dynamic queries or Content-Providers ensure you are using parameterized queries.
- **JavaScript Injection (XSS):** Переконайтеся, що підтримка JavaScript та Plugin вимкнена для будь-яких WebViews (disabled by default). [Детальніше тут](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews повинні мати доступ до файлової системи вимкненим (enabled by default) - `(webview.getSettings().setAllowFileAccess(false);)`. [Детальніше тут](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: У ряді випадків, коли android application завершує сесію, cookie не відкликається або може навіть зберігатися на диску
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Static analysis**

![](<../../images/image (866).png>)

**Vulnerability assessment of the application** using a nice web-based frontend. You can also perform dynamic analysis (but you need to prepare the environment).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Зверніть увагу, що MobSF може аналізувати **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Також, якщо ви створите **ZIP** файл зі вихідним кодом якщо **Android** або **IOS** app (перейдіть у кореневу папку застосунку, виділіть усе і створіть ZIPfile), воно також зможе його аналізувати.

MobSF також дозволяє робити **diff/Compare** аналізи та інтегрувати **VirusTotal** (вам потрібно встановити ваш API key у _MobSF/settings.py_ і увімкнути його: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). Ви також можете встановити `VT_UPLOAD` у `False`, тоді **hash** буде **upload** замість файлу.

### Асистований динамічний аналіз з MobSF

**MobSF** також може бути дуже корисним для **dynamic analysis** в **Android**, але в цьому випадку вам потрібно встановити MobSF та **genymotion** на вашому хості (a VM or Docker won't work). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
**MobSF dynamic analyser** може:

- **Dump application data** (URLs, логи, clipboard, скриншоти, зроблені вами, скриншоти зроблені "**Exported Activity Tester**", emails, SQLite бази даних, XML файли і інші створені файли). Усе це робиться автоматично, окрім скриншотів — їх потрібно робити вручну або натиснути "**Exported Activity Tester**", щоб отримати скриншоти всіх exported activities.
- Перехоплювати **HTTPS traffic**
- Використовувати **Frida** для отримання **runtime** **information**

Для android **versions > 5**, воно **automatically start Frida** і встановить глобальні налаштування **proxy** для **capture** трафіку. Воно перехоплюватиме трафік лише від тестованого застосунку.

**Frida**

За замовчуванням також використовуються деякі Frida Scripts для **bypass SSL pinning**, **root detection** та **debugger detection**, а також для **monitor interesting APIs**.\
MobSF також може **invoke exported activities**, захоплювати **screenshots** цих активностей і **save** їх у звіті.

Щоб **start** динамічне тестування натисніть зелену кнопку: "**Start Instrumentation**". Натисніть "**Frida Live Logs**", щоб побачити логи, згенеровані Frida scripts, і "**Live API Monitor**", щоб побачити всі виклики до hooked methods, передані аргументи та повернуті значення (це з'явиться після натискання "Start Instrumentation").\
MobSF також дозволяє завантажувати власні **Frida scripts** (щоб надіслати результати ваших Friday scripts до MobSF використовуйте функцію `send()`). Воно також має **several pre-written scripts**, які ви можете завантажити (можете додати більше у `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), просто **select them**, натисніть "**Load**" і натисніть "**Start Instrumentation**" (ви зможете бачити логи тих скриптів всередині "**Frida Live Logs**").

![](<../../images/image (419).png>)

Крім того, у вас є кілька допоміжних функцій Frida:

- **Enumerate Loaded Classes**: Виведе всі завантажені класи
- **Capture Strings**: Виводитиме всі захоплені рядки під час використання застосунку (дуже шумно)
- **Capture String Comparisons**: Може бути дуже корисним. Воно **показуватиме 2 рядки, що порівнюються**, і чи був результат True або False.
- **Enumerate Class Methods**: Введіть назву класу (наприклад "java.io.File") і воно виведе всі методи класу.
- **Search Class Pattern**: Шукає класи за шаблоном
- **Trace Class Methods**: **Trace** цілий клас (див. входи та виходи всіх методів класу). Пам'ятайте, що за замовчуванням MobSF трасує кілька цікавих Android Api методів.

Після того, як ви обрали допоміжний модуль, який хочете використати, потрібно натиснути "**Start Intrumentation**" і ви побачите всі виводи в "**Frida Live Logs**".

**Shell**

MobSF також надає shell з деякими **adb** командами, **MobSF commands**, та поширеними **shell commands** внизу сторінки динамічного аналізу. Декілька цікавих команд:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP tools**

Коли HTTP-трафік перехоплено, ви можете побачити неохайний вигляд перехопленого трафіку у нижній частині "**HTTP(S) Traffic**" або приємніший вигляд у зеленій кнопці "**Start HTTPTools**". З другого варіанту ви можете **відправити** **перехоплені запити** до **proxies**, наприклад Burp або Owasp ZAP.\
Для цього: _увімкніть Burp -->_ _вимкніть Intercept --> в MobSB HTTPTools виберіть запит_ --> натисніть "**Send to Fuzzer**" --> _виберіть адресу проксі_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Після завершення dynamic analysis з MobSF можна натиснути "**Start Web API Fuzzer**", щоб **fuzz http requests** і шукати вразливості.

> [!TIP]
> Після виконання dynamic analysis з MobSF налаштування proxy settings можуть бути некоректними, і ви не зможете виправити їх через GUI. Ви можете виправити proxy settings, виконавши:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

Ви можете отримати інструмент з [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Цей інструмент використовує деякі **Hooks**, щоб повідомляти **що відбувається в додатку** під час виконання **dynamic analysis**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Це **чудовий інструмент для виконання static analysis з GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Цей інструмент призначений для пошуку кількох **security related Android application vulnerabilities**, як у **source code**, так і в **packaged APKs**. Інструмент також **capable of creating a "Proof-of-Concept" deployable APK** та **ADB commands** для експлуатації деяких знайдених вразливостей (Exposed activities, intents, tapjacking...). Як і з Drozer, немає потреби root тестового пристрою.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Відображає всі витягнуті файли для зручного перегляду
- Автоматично декомпілює APK файли у Java та Smali формат
- Аналізує AndroidManifest.xml на наявність типових вразливостей та поведінки
- Статичний аналіз вихідного коду на типові вразливості та поведінку
- Інформація про пристрій
- та інше
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER — це програма командного рядка, яка може використовуватись на Windows, MacOS X і Linux, і аналізує _.apk_ файли у пошуках вразливостей. Вона робить це шляхом розпакування APKs та застосування набору правил для виявлення цих вразливостей.

Всі правила зберігаються у файлі `rules.json`, і кожна компанія або тестувальник може створити власні правила для аналізу того, що їм потрібно.

Завантажте останні бінарні файли зі сторінки [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn — це **crossplatform** інструмент, який допомагає розробникам, bugbounty hunters та ethical hackers виконувати [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) на мобільних додатках.

Ідея полягає в тому, що ви перетягуєте файл вашого мобільного додатку (an .apk or .ipa file) у застосунок StaCoAn, і він згенерує для вас візуальний та портативний звіт. Ви можете налаштувати налаштування та wordlists для отримання персоналізованого досвіду.

Завантажити[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework — система аналізу вразливостей Android, яка допомагає розробникам або hackers знаходити потенційні вразливості в Android-застосунках.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** — інструмент, основна мета якого — виявляти та попереджати користувача про потенційно шкідливу поведінку, реалізовану Android-додатком.

Виявлення виконується за допомогою **static analysis** байткоду Dalvik додатка, представленого як **Smali**, з використанням бібліотеки [`androguard`](https://github.com/androguard/androguard).

Цей інструмент шукає **поширені ознаки "шкідливих" додатків**, такі як: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. Це інструмент, який об'єднує поширені mobile application reverse engineering and analysis tools, щоб допомогти у тестуванні мобільних додатків проти OWASP mobile security threats. Мета — зробити це завдання простішим і зручнішим для розробників мобільних додатків та фахівців із безпеки.

Він може:

- Витягувати Java та Smali код за допомогою різних інструментів
- Аналізувати APK за допомогою: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Витягувати приватну інформацію з APK за допомогою regexps.
- Аналізувати Manifest.
- Аналізувати знайдені домени за допомогою: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) та [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK через [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Корисно для виявлення malware: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Зверніть увагу, що залежно від сервісу та конфігурації, яку ви використовуєте для обфускації коду, секрети можуть залишатися або не залишатися обфускованими.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. Він може оптимізувати байткод, а також виявляти та видаляти невикористовувані інструкції. ProGuard є вільним програмним забезпеченням і розповсюджується під ліцензією GNU General Public License, version 2.

ProGuard розповсюджується як частина Android SDK і запускається при збірці додатка у release mode.

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Last time we checked, the Dexguard mode of operation was:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard відновлює код після обфускації, виконаної інструментами обфускації для Android. Це дозволяє проводити численні аналізи безпеки, включно з перевіркою коду та виявленням бібліотек.**

Ви можете завантажити обфускований APK на їх платформу.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

It is a **generic android deobfuscator.** Simplify **virtually executes an app** to understand its behavior and then **tries to optimize the code** so it behaves identically but is easier for a human to understand. Each optimization type is simple and generic, so it doesn't matter what the specific type of obfuscation is used.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD gives you information about **how an APK was made**. It identifies many **compilers**, **packers**, **obfuscators**, and other weird stuff. It's [_PEiD_](https://www.aldeid.com/wiki/PEiD) for Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b is an Android security virtual machine based on ubuntu-mate includes the collection of latest framework, tutorials and labs from different security geeks and researchers for reverse engineering and malware analysis.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Це чудовий список ресурсів
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Короткий курс по Android
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)

## Yet to try

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
