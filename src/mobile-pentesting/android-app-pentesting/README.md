# Android Applications Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android Applications Basics

Рекомендується почати з цієї сторінки, щоб дізнатися про **найважливіші частини, пов'язані з безпекою Android, та найнебезпечніші компоненти в Android-додатку**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Це основний інструмент, який потрібен для підключення до android-пристрою (емулятор або фізичний пристрій).\
**ADB** дозволяє керувати пристроями як через **USB**, так і по **Network** з комп'ютера. Ця утиліта дає змогу **копіювати** файли в обох напрямах, **встановлювати** та **видаляти** додатки, **виконувати** shell-команди, **робити резервні копії** даних, **читати** логи та виконувати інші функції.

Перегляньте наступний список [**ADB Commands**](adb-commands.md), щоб навчитися використовувати adb.

## Smali

Іноді цікаво **змінити код додатку**, щоб отримати доступ до **прихованої інформації** (наприклад, добре обфусцовані паролі або flags). У такому випадку може бути корисно декомпілювати apk, змінити код і перекомпілювати його.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Це може бути дуже корисно як **альтернатива для кількох тестів під час динамічного аналізу**, які будуть представлені. Тож **завжди майте на увазі цю можливість**.

## Other interesting tricks

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **Завантажити APK**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Витягти APK з пристрою:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Злийте всі splits та base apks за допомогою [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Android Enterprise & Work Profile Attacks

{{#ref}}
android-enterprise-work-profile-bypass.md
{{#endref}}

## Кейси та вразливості


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Статичний аналіз

По-перше, для аналізу APK варто **переглянути Java-код** за допомогою decompiler.\
Будь-ласка, [**прочитайте тут, щоб знайти інформацію про різні доступні decompilers**](apk-decompilers.md).

### Пошук цікавої інформації

Просто переглянувши **strings** у APK, можна шукати **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** та будь-що цікаве... перевіряйте також на наявність виконуваних кодом **backdoors** або authentication backdoors (захардкожені admin credentials у додатку).

**Firebase**

Зверніть особливу увагу на **firebase URLs** і перевіряйте, чи неправильно воно налаштоване. [Більше інформації про те, що таке Firebase і як це експлуатувати тут.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Базове розуміння додатку - Manifest.xml, strings.xml

**Огляд файлів _Manifest.xml_ та _strings.xml_ додатку може виявити потенційні вразливості безпеки**. До цих файлів можна отримати доступ за допомогою decompiler або перейменувавши розширення файлу APK на .zip і розпаковуючи його.

**Вразливості**, що можуть бути виявлені у **Manifest.xml**, включають:

- **Debuggable Applications**: Додатки, позначені як debuggable (`debuggable="true"`) у _Manifest.xml_, становлять ризик, оскільки дозволяють підключення, які можуть призвести до експлуатації. Для кращого розуміння того, як експлуатувати debuggable додатки, зверніться до підручника з пошуку та експлуатації debuggable applications на пристрої.
- **Backup Settings**: Атрибут `android:allowBackup="false"` має бути явно встановлений для додатків, що працюють з чутливою інформацією, щоб запобігти несанкціонованим резервним копіям даних через adb, особливо коли увімкнено usb debugging.
- **Network Security**: Користувацькі конфігурації network security (`android:networkSecurityConfig="@xml/network_security_config"`) у _res/xml/_ можуть визначати деталі безпеки, такі як certificate pins та налаштування HTTP-трафіку. Приклад — дозволити HTTP-трафік для певних доменів.
- **Exported Activities and Services**: Виявлення exported activities та services у manifest може підказати компоненти, які можуть бути зловживані. Подальший аналіз під час динамічного тестування може показати, як експлуатувати ці компоненти.
- **Content Providers and FileProviders**: Відкриті content providers можуть дозволити несанкціонований доступ або модифікацію даних. Також слід уважно перевірити конфігурацію FileProviders.
- **Broadcast Receivers and URL Schemes**: Ці компоненти можуть бути використані для експлуатації, зокрема зверніть увагу на те, як URL schemes обробляються для вхідних даних.
- **SDK Versions**: Атрибути `minSdkVersion`, `targetSDKVersion` та `maxSdkVersion` вказують підтримувані версії Android, підкреслюючи важливість не підтримувати застарілі, вразливі версії Android з міркувань безпеки.

З файлу **strings.xml** можна знайти чутливу інформацію, таку як API keys, custom schemas та інші примітки розробників, що підкреслює необхідність ретельного перегляду цих ресурсів.

### Tapjacking

**Tapjacking** — це атака, коли **зловмисний додаток** запускається і **розташовується поверх додатку-жертви**. Поки він візуально закриває додаток-жертву, його інтерфейс спроектований так, щоб обманути користувача щодо взаємодії, при цьому передаючи цю взаємодію додатку-жертві.\
Фактично це **осліплює користувача від того, що він насправді виконує дії в додатку-жертві**.

Детальніше в:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Activity з `launchMode`, встановленим у `singleTask` без визначеного `taskAffinity`, вразлива до task Hijacking. Це означає, що **додаток** може бути встановлений і, якщо він запущений раніше за справжній додаток, може **захопити task справжнього додатку** (тому користувач взаємодіє з **зловмисним додатком**, думаючи, що використовує справжній).

Більше інформації в:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Insecure data storage

**Internal Storage**

В Android файли, що зберігаються у внутрішньому сховищі, спроектовані так, щоб бути доступними виключно для додатку, який їх створив. Цей захід безпеки забезпечується операційною системою Android і зазвичай є достатнім для потреб більшості додатків. Проте розробники іноді використовують режими, такі як `MODE_WORLD_READABLE` та `MODE_WORLD_WRITABLE`, щоб дозволити спільний доступ до файлів між різними додатками. Однак ці режими **не обмежують доступ** до цих файлів іншими додатками, включно з потенційно зловмисними.

1. **Static Analysis:**
- **Переконайтесь**, що використання `MODE_WORLD_READABLE` та `MODE_WORLD_WRITABLE` **ретельно перевіряється**. Ці режими **могуть потенційно відкрити** файли для **непередбаченого або несанкціонованого доступу**.
2. **Dynamic Analysis:**
- **Перевірте** permissions, встановлені для файлів, створених додатком. Зокрема, **перевіряйте**, чи будь-які файли **не встановлені як доступні для читання або запису для всіх**. Це може створити значний ризик безпеки, оскільки дозволить **будь-якому додатку**, встановленому на пристрої, незалежно від його походження чи намірів, **читати або змінювати** ці файли.

**External Storage**

Коли працюєте з файлами на external storage, таких як SD Cards, слід вжити певних запобіжних заходів:

1. **Accessibility**:
- Файли на external storage є **глобально доступними для читання і запису**. Це означає, що будь-який додаток або користувач може отримати доступ до цих файлів.
2. **Security Concerns**:
- Через легкість доступу не рекомендується **зберігати чутливу інформацію** на external storage.
- External storage може бути видалено або до нього може отримати доступ будь-який додаток, через що воно менш безпечне.
3. **Handling Data from External Storage**:
- Завжди **виконуйте валідацію вводу** для даних, отриманих з external storage. Це критично, оскільки дані походять з недовіреного джерела.
- Не рекомендується зберігати виконувані файли або class-файли на external storage для динамічного завантаження.
- Якщо ваш додаток повинен отримувати виконувані файли з external storage, переконайтеся, що ці файли **підписані та криптографічно перевірені** перед динамічним завантаженням. Це важливий крок для збереження цілісності безпеки вашого додатку.

External storage можна **доступитися** у /storage/emulated/0 , /sdcard , /mnt/sdcard

> [!TIP]
> Починаючи з Android 4.4 (**API 17**), на SD card існує структура каталогів, яка **обмежує доступ додатку лише до каталогу, специфічного для цього додатку**. Це запобігає тому, щоб зловмисний додаток отримував доступ для читання або запису до файлів іншого додатку.

**Чутливі дані, збережені у відкритому вигляді**

- **Shared preferences**: Android дозволяє кожному додатку легко зберігати xml-файли у шляху `/data/data/<packagename>/shared_prefs/` і іноді в цьому каталозі можна знайти чутливу інформацію у відкритому вигляді.
- **Databases**: Android дозволяє кожному додатку легко зберігати sqlite databases у шляху `/data/data/<packagename>/databases/` і іноді в цьому каталозі можна знайти чутливу інформацію у відкритому вигляді.

### Broken TLS

**Accept All Certificates**

З якоїсь причини іноді розробники приймають усі сертифікати, навіть якщо, наприклад, hostname не відповідає, з рядками коду на кшталт наведеного нижче:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Ненадійна криптографія

**Неналежні процеси управління ключами**

Деякі розробники зберігають чутливі дані в локальному сховищі і шифрують їх ключем, захардкоженим/передбачуваним у коді. Так робити не слід, оскільки реверсінг може дозволити атакуючим витягти конфіденційну інформацію.

**Використання небезпечних та/або застарілих алгоритмів**

Розробникам не слід використовувати **deprecated algorithms** для виконання авторизаційних **checks**, **store** або **send** даних. Деякі з цих алгоритмів: RC4, MD4, MD5, SHA1... Якщо для зберігання паролів використовуються **hashes**, слід застосовувати хеші, стійкі до брутфорсу, із salt.

### Інші перевірки

- Рекомендується **обфускувати APK**, щоб ускладнити роботу реверс-інженерів.
- Якщо додаток чутливий (наприклад банківські додатки), він має виконувати власні перевірки, щоб визначити, чи мобільний пристрій є rooted, і діяти відповідно.
- Якщо додаток чутливий (наприклад банківські додатки), він повинен перевіряти, чи використовується **emulator**.
- Якщо додаток чутливий (наприклад банківські додатки), він має **перевіряти власну цілісність перед виконанням**, щоб визначити, чи був він змінений.
- Використовуйте [**APKiD**](https://github.com/rednaga/APKiD) щоб перевірити, який compiler/packer/obfuscator використовувався для побудови APK

### React Native Application

Прочитайте наступну сторінку, щоб дізнатися, як легко отримати доступ до javascript-коду React-додатків:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Прочитайте наступну сторінку, щоб дізнатися, як легко отримати доступ до C# коду xamarin-додатків:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

Згідно з цим [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked — це Meta алгоритм, який стискає вміст додатку в один файл. У блозі йдеться про можливість створення додатка, який розпаковує такого роду апки... та про швидший спосіб, який передбачає **запуск додатка та збір розпакованих файлів з файлової системи.**

### Automated Static Code Analysis

Інструмент [**mariana-trench**](https://github.com/facebook/mariana-trench) здатний знаходити **vulnerabilities** шляхом **scanning** **code** додатку. Цей інструмент містить набір **known sources** (вказує інструменту **місця**, де **input** контролюється користувачем), **sinks** (вказує інструменту **небезпечні** **місця**, де зловмисний ввід користувача може спричинити шкоду) та **rules**. Ці правила вказують **комбінації** **sources-sinks**, які означають наявність вразливості.

Завдяки цьому **mariana-trench перегляне код і знайде можливі vulnerabilities у ньому**.

### Secrets leaked

Додаток може містити secrets (API keys, паролі, приховані url, субдомени...) всередині себе, які ви можете виявити. Ви можете використати інструмент такий як [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Інші цікаві функції

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Читайте це, щоб дізнатись **як реверсити native функції**](reversing-native-libraries.md)
- In-memory native code execution via JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Інші трюки**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Динамічний аналіз

> По-перше, вам потрібне середовище, куди ви зможете встановити додаток і все оточення (Burp CA cert, Drozer і Frida головним чином). Тому настійно рекомендовано використати rooted device (емулятор чи ні).

### Онлайн-динамічний аналіз

Ви можете створити **безкоштовний акаунт** на: [https://appetize.io/](https://appetize.io). Ця платформа дозволяє **завантажувати** та **виконувати** APK, тож вона корисна, щоб побачити, як apk поводиться.

Ви навіть можете **дивитись логи вашого додатку** у вебі та підключатись через **adb**.

![](<../../images/image (831).png>)

Завдяки ADB-з'єднанню ви можете використовувати **Drozer** та **Frida** всередині емульторів.

### Локальний динамічний аналіз

#### Використання емультора

- [**Android Studio**](https://developer.android.com/studio) (Ви можете створювати **x86** та **arm** пристрої, і згідно з [**цим** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**новіші x86** версії **підтримують ARM-бібліотеки** без необхідності повільного arm емулятора).
- Дізнайтесь як налаштувати його на цій сторінці:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Безкоштовна версія:** Personal Edition, потрібно створити акаунт. _Рекомендується **завантажити** версію **З**_ _**VirtualBox** щоб уникнути потенційних помилок._)
- [**Nox**](https://es.bignox.com) (Безкоштовний, але не підтримує Frida або Drozer).

> [!TIP]
> При створенні нового емультора на будь-якій платформі пам’ятайте, що чим більший екран, тим повільніше працюватиме емултор. Тому за можливості обирайте менші екрани.

Щоб **встановити google services** (наприклад AppStore) в Genymotion, потрібно натиснути червону кнопку, позначену на наступному зображенні:

![](<../../images/image (277).png>)

Також зауважте, що в **конфігурації Android VM у Genymotion** ви можете обрати **Bridge Network mode** (це буде корисно, якщо ви будете підключатись до Android VM з іншої VM з інструментами).

#### Використання фізичного пристрою

Вам потрібно активувати опції **розробника** і бажано, щоб пристрій був **root**:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Після встановлення додатку, перш за все, спробуйте його і дослідіть, що він робить, як він працює та звикніть до нього.\
> Я рекомендую **виконати цей початковий динамічний аналіз за допомогою MobSF dynamic analysis + pidcat**, щоб ми могли **зрозуміти, як працює додаток**, у той час як MobSF **збирає** багато **цікавих** **даних**, які ви потім зможете переглянути.

Magisk/Zygisk quick notes (recommended on Pixel devices)
- Patch boot.img with the Magisk app and flash via fastboot to get systemless root
- Enable Zygisk + DenyList for root hiding; consider LSPosed/Shamiko when stronger hiding is required
- Keep original boot.img to recover from OTA updates; re-patch after each OTA
- For screen mirroring, use scrcpy on the host

### Unintended Data Leakage

**Logging**

Розробникам слід бути обережними з публічним розкриттям **debugging information**, оскільки це може призвести до витоку чутливих даних. Рекомендовано використовувати інструменти [**pidcat**](https://github.com/JakeWharton/pidcat) та `adb logcat` для моніторингу логів додатку, щоб виявити та захистити чутливу інформацію. **Pidcat** цінується за зручність використання та читабельність.

> [!WARNING]
> Зверніть увагу, що з **версій новіших за Android 4.0**, **додатки можуть отримувати доступ лише до власних логів**. Тому додатки не можуть отримувати логи інших додатків.\
> У будь-якому разі, все одно рекомендовано **не логувати чутливу інформацію**.

**Copy/Paste Buffer Caching**

Android-фреймворк на основі **clipboard** забезпечує функціонал копіювання-вставки в додатках, але становить ризик, оскільки **інші додатки** можуть **доступатися** до буфера обміну, потенційно розкриваючи чутливі дані. Важливо **відключити функції copy/paste** для чутливих секцій додатку, наприклад даних платіжної картки, щоб запобігти витокам даних.

**Crash Logs**

Якщо додаток **впадає** і **зберігає логи**, ці логи можуть допомогти атаці, особливо коли додаток не піддається реверсінгу. Щоб зменшити цей ризик, уникайте логування під час падінь, а якщо логи потрібно відправляти по мережі, переконайтесь, що вони надсилаються через SSL-канал.

Як pentester, **спробуйте переглянути ці логи**.

**Analytics Data Sent To 3rd Parties**

Додатки часто інтегрують сервіси на кшталт Google Adsense, які через неправильну реалізацію можуть ненавмисно **leak** чутливі дані. Щоб виявити потенційні витоки даних, рекомендовано **перехопити трафік додатку** і перевірити, чи надсилається якась чутлива інформація до сторонніх сервісів.

### SQLite DBs

Більшість додатків використовують **internal SQLite databases** для збереження інформації. Під час pentest перегляньте **databases**, імена **tables** та **columns** і всі **дані**, що зберігаються, оскільки ви можете знайти **чутливу інформацію** (що буде вразливістю).\
Databases мають знаходитись у `/data/data/the.package.name/databases` як, наприклад, `/data/data/com.mwr.example.sieve/databases`

Якщо база даних зберігає конфіденційну інформацію і вона **encrypted** але ви можете **знайти** **password** всередині додатку — це все одно **vulnerability**.

Перелічіть таблиці за допомогою `.tables` і перелічіть колонки таблиць командою `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

Згідно з [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** дозволяє вам **взяти на себе роль Android app** і взаємодіяти з іншими додатками. Воно може робити **будь-що, що може робити встановлений додаток**, наприклад використовувати Android’s Inter-Process Communication (IPC) механізм та взаємодіяти з підлягаючою операційною системою. .\
Drozer — корисний інструмент для **експлуатації exported activities, exported services та Content Providers**, як ви дізнаєтесь у наступних розділах.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Також пам’ятайте, що виконання коду активності починається у методі **`onCreate`**.

**Authorisation bypass**

Коли Activity є exported, ви можете викликати її екран з зовнішнього додатку. Тому, якщо activity з **чутливою інформацією** є **exported**, ви можете **bypass** механізми **authentication**, щоб отримати до неї доступ.

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

Ви також можете запустити exported activity з adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**ПРИМІТКА**: MobSF буде вважати шкідливим використання _**singleTask/singleInstance**_ як `android:launchMode` в activity, але згідно з [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), очевидно це небезпечно лише на старих версіях (API versions < 21).

> [!TIP]
> Зверніть увагу, що bypass авторизації не завжди є вразливістю — це залежить від того, як працює bypass і яка інформація стає доступною.

**Витік конфіденційної інформації**

Activities також можуть повертати результати. Якщо вам вдасться знайти експортовану й незахищену activity, яка викликає метод **`setResult`** і **повертає конфіденційну інформацію**, це призводить до витоку конфіденційної інформації.

#### Tapjacking

Якщо tapjacking не запобігається, ви можете зловживати експортованою activity, щоб змусити **користувача виконувати непередбачені дії**. Для отримання додаткової інформації про [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers зазвичай використовуються для **поділу даних**. Якщо додаток має доступні content providers, ви можете мати змогу **витягнути конфіденційні** дані з них. Також варто перевірити можливі **SQL injections** та **Path Traversals**, оскільки вони можуть бути вразливими.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Пам'ятайте, що дії Service починаються в методі `onStartCommand`.

Сервіс по суті — це те, що **може отримувати дані**, **опрацьовувати** їх і **повертати** (або ні) відповідь. Отже, якщо додаток експортує якісь services, ви повинні **перевірити** **код**, щоб зрозуміти, що він робить, і **динамічно** протестувати його для вилучення конфіденційної інформації, обходу заходів аутентифікації...\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Пам'ятайте, що дії Broadcast Receiver починаються в методі `onReceive`.

Broadcast receiver очікує певний тип повідомлення. Залежно від того, як receiver обробляє повідомлення, він може бути вразливим.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Ви можете шукати deep links вручну, використовуючи інструменти як MobSF або скрипти, як [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Ви можете **відкрити** задекларований **scheme** за допомогою **adb** або **браузера**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Зауважте, що ви можете **опустити ім'я пакета** і мобільний пристрій автоматично викличе додаток, який має відкрити це посилання._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Код, що виконується**

Щоб знайти **код, який буде виконано в App**, перейдіть до activity, викликаної deeplink'ом, і знайдіть функцію **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Чутлива інформація**

Кожного разу, коли ви знаходите deep link, перевіряйте, що **він не отримує чутливі дані (наприклад паролі) через URL-параметри**, оскільки будь-який інший додаток може **імітувати цей deep link і викрасти ці дані!**

**Параметри в шляху**

Ви **повинні також перевірити, чи якийсь deep link не використовує параметр всередині шляху** URL, наприклад: `https://api.example.com/v1/users/{username}` , у такому випадку ви можете змусити path traversal, звернувшись до: `example://app/users?username=../../unwanted-endpoint%3fparam=value`.\
Зауважте, що якщо ви знайдете відповідні endpoints у додатку, ви можете викликати **Open Redirect** (якщо частина шляху використовується як домен), **account takeover** (якщо ви можете змінювати деталі користувачів без CSRF token і вразливий endpoint використовував правильний метод) та інші вразливості. Детальніше [тут](http://dphoeniixx.com/2020/12/13-2/).

**Більше прикладів**

Цікавий [bug bounty report](https://hackerone.com/reports/855618) щодо links (_/.well-known/assetlinks.json_).

### Інспекція транспортного рівня та помилки валідації

- **Certificates are not always inspected properly** у Android-додатках. Часто ці додатки ігнорують попередження і приймають self-signed certificates або, в деяких випадках, переходять на використання HTTP-з'єднань.
- **Negotiations during the SSL/TLS handshake are sometimes weak**, використовуючи небезпечні cipher suites. Ця вразливість робить з'єднання вразливим до man-in-the-middle (MITM) атак, дозволяючи зловмисникам розшифровувати дані.
- **Leakage of private information** — ризик, коли додатки автентифікуються через захищені канали, але потім комунікують по незахищених каналах для інших операцій. Такий підхід не захищає чутливі дані, такі як session cookies або відомості користувача, від перехоплення зловмисниками.

#### Certificate Verification

Ми зосередимось на **certificate verification**. Треба перевіряти цілісність сертифіката сервера для підвищення безпеки. Це важливо, оскільки insecure TLS конфігурації і передача чутливих даних по незашифрованих каналах можуть становити значні ризики. Для детальних кроків щодо перевірки серверних сертифікатів та усунення вразливостей, [**цей ресурс**](https://manifestsecurity.com/android-application-security-part-10/) містить вичерпні рекомендації.

#### SSL Pinning

SSL Pinning — це захід безпеки, коли додаток перевіряє сертифікат сервера проти відомої копії, збереженої всередині додатку. Цей метод необхідний для запобігання MITM-атакам. Рекомендується впроваджувати SSL Pinning у додатках, що працюють з чутливою інформацією.

#### Traffic Inspection

Щоб інспектувати HTTP-трафік, необхідно **встановити сертифікат proxy tool** (наприклад, Burp). Без встановлення цього сертифіката зашифрований трафік може бути невидимим через проксі. Для інструкції з встановлення custom CA certificate, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Додатки, які таргетять **API Level 24 and above**, потребують змін у Network Security Config, щоб прийняти proxy's CA certificate. Цей крок критично важливий для інспекції зашифрованого трафіку. Для інструкцій щодо змін у Network Security Config, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

Якщо використовується **Flutter**, потрібно виконати інструкції на [**this page**](flutter.md). Це тому, що просто додати сертифікат у сховище не спрацює, оскільки Flutter має власний список допустимих CAs.

#### Static detection of SSL/TLS pinning

Перед спробами runtime bypasses швидко визначте, де в APK застосовано pinning. Статичне виявлення допоможе спланувати hooks/patches і сфокусуватися на потрібних code paths.

Tool: SSLPinDetect
- Open-source utility для static-analysis, яка декомпілює APK у Smali (через apktool) і сканує підготовлені regex patterns реалізацій SSL/TLS pinning.
- Повертає точний file path, line number та фрагмент коду для кожного збігу.
- Підтримує common frameworks і custom code paths: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init з custom TrustManagers/KeyManagers, та Network Security Config XML pins.

Встановлення
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Використання
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Приклади правил шаблонів (JSON)
Використовуйте або розширюйте signatures для виявлення власницьких/налаштованих стилів pinning. Ви можете завантажити власний JSON і сканувати масштабно.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes and tips
- Швидке сканування великих apps через multi-threading та memory-mapped I/O; pre-compiled regex зменшує накладні витрати/хибнопозитиви.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Типові цілі для подальшої перевірки:
- OkHttp: використання CertificatePinner, setCertificatePinner, посилання на пакети okhttp3/okhttp
- Custom TrustManagers: javax.net.ssl.X509TrustManager, перевизначення checkServerTrusted
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init з користувацькими менеджерами
- Declarative pins у res/xml network security config та посилання в manifest
- Використовуйте знайдені місця, щоб спланувати Frida hooks, статичні патчі або перегляд конфігурацій перед динамічним тестуванням.



#### Обхід SSL Pinning

Коли реалізовано SSL Pinning, необхідно його обійти, щоб інспектувати HTTPS-трафік. Для цього доступні різні методи:

- Автоматично **змінити** **apk** щоб **обійти** SSLPinning за допомогою [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Головна перевага цього варіанту — не потрібен root для обходу SSL Pinning, але потрібно видалити додаток і встановити змінений, і це не завжди працює.
- Ви можете використати **Frida** (обговорюється нижче) для обходу цього захисту. Ось гайд як використовувати Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Ви також можете спробувати **автоматично обійти SSL Pinning** використовуючи [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Ви також можете спробувати **автоматично обійти SSL Pinning** використовуючи **MobSF dynamic analysis** (пояснено нижче)
- Якщо ви все ще вважаєте, що частину трафіку не вдається захопити, можна спробувати **перенаправити трафік у burp за допомогою iptables**. Читайте цей блог: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Пошук поширених веб-вразливостей

Важливо також шукати поширені веб-вразливості всередині додатку. Детальна інформація про ідентифікацію та пом’якшення цих вразливостей виходить за межі цього зведення, але широко висвітлюється в інших джерелах.

### Frida

[Frida](https://www.frida.re) — динамічний інструментарій для інструментування для розробників, реверсінженерів та дослідників безпеки.\
**Ви можете отримувати доступ до запущеного додатку та hook-ати методи під час виконання, змінювати поведінку, змінювати значення, витягувати значення, виконувати інший код...**\
Якщо ви хочете pentest Android-додатки, вам потрібно вміти використовувати Frida.

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Some "GUI" for actions with Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- You can find some Awesome Frida scripts here: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Спробуйте обійти anti-debugging / anti-frida механізми, завантажуючи Frida як показано в [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (інструмент [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Зняття дампу пам'яті - Fridump**

Перевірте, чи додаток зберігає в пам'яті конфіденційну інформацію, яку не повинен зберігати, наприклад паролі або мнемоніки.

Використовуючи [**Fridump3**](https://github.com/rootbsd/fridump3) ви можете зняти дамп пам'яті додатка за допомогою:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Це виконає dump пам'яті у папку ./dump, і там ви можете використовувати grep приблизно так:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Чутливі дані в Keystore**

В Android Keystore — найкраще місце для зберігання чутливих даних, проте при достатніх привілеях все ще **можна отримати до нього доступ**. Оскільки додатки зазвичай зберігають тут **чутливі дані у відкритому вигляді**, під час pentests слід це перевіряти, оскільки root user або особа з фізичним доступом до пристрою може вкрасти ці дані.

Навіть якщо додаток зберігає дані в Keystore, ці дані мають бути зашифровані.

Щоб отримати доступ до даних всередині keystore, можна використати цей Frida script: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Використовуючи наступний Frida script, можливо здійснити **bypass fingerprint authentication**, яке Android-застосунки можуть виконувати, щоб **захистити певні чутливі області:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Background Images**

Коли ви переміщаєте додаток у фоновий режим, Android зберігає **знімок додатка**, тому при поверненні на передній план спочатку завантажує це зображення перед самим додатком, щоб здавалося, що додаток запускається швидше.

Однак якщо цей знімок містить **чутливу інформацію**, хтось, хто має доступ до знімка, може **вкрасти цю інформацію** (зверніть увагу, що для доступу потрібен root).

Знімки зазвичай зберігаються у: **`/data/system_ce/0/snapshots`**

Android надає спосіб **запобігти захопленню знімків екрана, встановивши параметр макета FLAG_SECURE**. Використовуючи цей прапорець, вміст вікна позначається як захищений, що запобігає його появі у знімках екрана або перегляду на незахищених дисплеях.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Цей інструмент може допомогти вам керувати різними інструментами під час динамічного аналізу: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Розробники часто створюють проксі-компоненти, такі як activities, services та broadcast receivers, які обробляють ці Intents і передають їх у методи, такі як `startActivity(...)` або `sendBroadcast(...)`, що може бути небезпечно.

Небезпека полягає в тому, що атакувальники можуть ініціювати non-exported app components або отримати доступ до чутливих content providers, неправильно спрямувавши ці Intents. Яскравий приклад — компонент `WebView`, який перетворює URL на об'єкти `Intent` через `Intent.parseUri(...)` і потім виконує їх, що може призвести до зловмисних Intent injections.

### Essential Takeaways

- **Intent Injection** схожа на web's Open Redirect проблему.
- Експлойти включають передачу об'єктів `Intent` як extras, які можна перенаправити для виконання небезпечних операцій.
- Це може відкрити non-exported components та content providers для атакувальників.
- Перетворення URL у `Intent` компонентом `WebView` може сприяти виконанню небажаних дій.

### Android Client Side Injections and others

Ймовірно, ви знаєте про такого роду вразливості з Web. Потрібно бути особливо обережним з цими вразливостями в Android-додатку:

- **SQL Injection:** При роботі з динамічними запитами або Content-Providers переконайтеся, що ви використовуєте parameterized queries.
- **JavaScript Injection (XSS):** Переконайтеся, що підтримка JavaScript і Plugin вимкнена для будь-яких WebViews (за замовчуванням вимкнена). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** Доступ WebViews до файлової системи повинен бути вимкнений (за замовчуванням увімкнений) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: У деяких випадках при завершенні сесії Android-додатку cookie не відкликається або навіть може бути збережений на диск
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Статичний аналіз**

![](<../../images/image (866).png>)

**Vulnerability assessment of the application** using a nice web-based frontend. Ви також можете виконати динамічний аналіз (але потрібно підготувати середовище).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Assisted Dynamic analysis with MobSF

**MobSF** can also be very helpful for **dynamic analysis** in **Android**, but in that case you will need to install MobSF and **genymotion** in your host (a VM or Docker won't work). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
The **MobSF dynamic analyser** can:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). All of this is done automatically except for the screenshots, you need to press when you want a screenshot or you need to press "**Exported Activity Tester**" to obtain screenshots of all the exported activities.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: It will print all the loaded classes
- **Capture Strings**: It will print all the capture strings while using the application (super noisy)
- **Capture String Comparisons**: Could be very useful. It will **show the 2 strings being compared** and if the result was True or False.
- **Enumerate Class Methods**: Put the class name (like "java.io.File") and it will print all the methods of the class.
- **Search Class Pattern**: Search classes by pattern
- **Trace Class Methods**: **Trace** a **whole class** (see inputs and outputs of all methods of th class). Remember that by default MobSF traces several interesting Android Api methods.

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf also brings you a shell with some **adb** commands, **MobSF commands**, and common **shell** **commands** at the bottom of the dynamic analysis page. Some interesting commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP інструменти**

Коли HTTP-трафік захоплено, ви можете бачити негарний вигляд захопленого трафіку на кнопці "**HTTP(S) Traffic**" внизу або більш приємний вигляд у зеленій кнопці "**Start HTTPTools**". З другого варіанта ви можете **send** **captured requests** на **proxies**, такі як Burp або Owasp ZAP.\
Для цього _power on Burp -->_ _turn off Intercept --> в MobSB HTTPTools select the request_ --> натисніть "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Після завершення dynamic analysis з MobSF ви можете натиснути "**Start Web API Fuzzer**", щоб **fuzz http requests** і шукати вразливості.

> [!TIP]
> Після виконання dynamic analysis з MobSF налаштування proxy можуть бути некоректними, і ви не зможете виправити їх через GUI. Ви можете виправити налаштування proxy, виконавши:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Асистований Dynamic Analysis з Inspeckage

Ви можете отримати інструмент з [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Цей інструмент використовує деякі **Hooks**, щоб повідомляти вам, **what is happening in the application**, поки ви виконуєте **dynamic analysis**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Це **great tool to perform static analysis with a GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Цей інструмент призначений для пошуку різних **security related Android application vulnerabilities**, як у **source code**, так і в **packaged APKs**. Інструмент також **capable of creating a "Proof-of-Concept" deployable APK** та **ADB commands**, щоб експлуатувати деякі з виявлених вразливостей (Exposed activities, intents, tapjacking...). Як і з Drozer, немає потреби root-ити тестовий пристрій.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Відображає всі вилучені файли для зручного перегляду
- Автоматично декомпілює APK файли у формат Java та Smali
- Аналізує AndroidManifest.xml на наявність поширених вразливостей та поведінки
- Статичний аналіз вихідного коду на наявність поширених вразливостей та поведінки
- Інформація про пристрій
- та інше
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER — це застосунок командного рядка, який може використовуватися в Windows, MacOS X і Linux та аналізує _.apk_ файли в пошуку вразливостей. Він робить це шляхом розпаковування APKs і застосування набору правил для виявлення цих вразливостей.

Усі правила зберігаються у файлі `rules.json`, і кожна компанія або тестувальник може створити власні правила для аналізу того, що їм потрібно.

Завантажте останні бінарні файли зі сторінки [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn — це **crossplatform** інструмент, який допомагає розробникам, bugbounty hunters та ethical hackers виконувати [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) мобільних додатків.

Концепція полягає в тому, що ви перетягуєте файл мобільного додатка (an .apk or .ipa file) у застосунок StaCoAn, і він згенерує для вас візуальний та портативний звіт. Ви можете налаштувати settings та wordlists, щоб отримати персоналізований досвід.

Завантажити[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework — це система аналізу вразливостей для Android, яка допомагає розробникам або hackers виявляти потенційні проблеми безпеки в Android-застосунках.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** — інструмент, основна мета якого — виявляти та попереджати користувача про потенційно шкідливу поведінку, яку демонструє додаток Android.

Виявлення виконується за допомогою **static analysis** додатку байткоду Dalvik, представленого як **Smali**, із використанням бібліотеки [`androguard`](https://github.com/androguard/androguard).

Цей інструмент шукає **поширені поведінкові ознаки «шкідливих» додатків**, наприклад: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** — фреймворк для реверс-інжинірингу та аналізу мобільних застосунків. Це інструмент, який об'єднує часто вживані інструменти для mobile application reverse engineering та аналізу, щоб допомогти у тестуванні мобільних застосунків щодо OWASP mobile security threats. Його мета — зробити це завдання простішим і зручнішим для розробників мобільних застосунків та фахівців з безпеки.

Має можливість:

- Витягувати Java та Smali код за допомогою різних інструментів
- Аналізувати APK за допомогою: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Витягувати приватну інформацію з APK за допомогою regexps.
- Аналізувати Manifest.
- Аналізувати знайдені домени за допомогою: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) та [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Деобфускувати APK через [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Корисно для виявлення malware: [https://koodous.com/](https://koodous.com/)

## Обфускація/деобфускація коду

Зверніть увагу, що залежно від сервісу та конфігурації, які ви використовуєте для обфускації коду, секрети можуть бути обфусковані або залишатися у відкритому вигляді.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. It is able to optimize bytecode as well as detect and remove unused instructions. ProGuard is free software and is distributed under the GNU General Public License, version 2.

ProGuard is distributed as part of the Android SDK and runs when building the application in release mode.

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Last time we checked, the Dexguard mode of operation was:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

You can upload an obfuscated APK to their platform.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

It is a **generic android deobfuscator.** Simplify **virtually executes an app** to understand its behavior and then **tries to optimize the code** so it behaves identically but is easier for a human to understand. Each optimization type is simple and generic, so it doesn't matter what the specific type of obfuscation is used.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD gives you information about **how an APK was made**. It identifies many **compilers**, **packers**, **obfuscators**, and other weird stuff. It's [_PEiD_](https://www.aldeid.com/wiki/PEiD) for Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b is an Android security virtual machine based on ubuntu-mate includes the collection of latest framework, tutorials and labs from different security geeks and researchers for reverse engineering and malware analysis.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Це чудовий перелік ресурсів
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
