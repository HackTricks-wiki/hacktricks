# Pentesting von Android-Anwendungen

{{#include ../../banners/hacktricks-training.md}}

## Grundlagen zu Android-Anwendungen

Es wird dringend empfohlen, zuerst diese Seite zu lesen, um die **wichtigsten Teile im Zusammenhang mit Android-Sicherheit und die gefährlichsten Komponenten in einer Android-Anwendung** zu kennen:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Dies ist das Haupttool, das du benötigst, um ein Android-Gerät (emuliert oder physisch) zu verbinden.\
**ADB** ermöglicht die Steuerung von Geräten entweder über **USB** oder **Network** von einem Computer aus. Dieses Utility erlaubt das **Kopieren** von Dateien in beide Richtungen, die **Installation** und **Deinstallation** von Apps, die **Ausführung** von Shell-Befehlen, das **Sichern** von Daten, das **Lesen** von Logs, neben anderen Funktionen.

Sieh dir die folgende Liste der [**ADB Commands**](adb-commands.md) an, um zu lernen, wie man adb verwendet.

## Smali

Manchmal ist es interessant, den Anwendungscode zu **modifizieren**, um auf **versteckte Informationen** zuzugreifen (z. B. stark obfuskierte Passwörter oder flags). Dann kann es sinnvoll sein, die APK zu dekompilieren, den Code zu ändern und die APK wieder zu kompilieren.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Das kann sehr nützlich sein als **Alternative für mehrere Tests während der dynamischen Analyse**, die weiter unten vorgestellt werden. Behalte diese Möglichkeit also immer im Hinterkopf.

## Other interesting tricks

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- APK aus Gerät extrahieren:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Alle splits und base apks mit [APKEditor](https://github.com/REAndroid/APKEditor) zusammenführen:
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Fallstudien & Schwachstellen


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Statische Analyse

Zuerst solltest du beim Analysieren einer APK **den Java-Code ansehen** mit einem decompiler.\
Bitte, [**lies hier, um Informationen über verschiedene verfügbare decompiler zu finden**](apk-decompilers.md).

### Suche nach interessanten Informationen

Schon ein Blick in die **strings** der APK kann Hinweise auf **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** und andere interessante Dinge liefern... suche auch nach code execution **backdoors** oder authentication backdoors (hardcodierte Admin-Credentials in der App).

**Firebase**

Achte besonders auf **Firebase URLs** und prüfe, ob es falsch konfiguriert ist. [Mehr Informationen darüber, was Firebase ist und wie man es ausnutzt, hier.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Grundlegendes Verständnis der Anwendung - Manifest.xml, strings.xml

Die **Untersuchung der Anwendungs-_Manifest.xml_ und der **_strings.xml_** Dateien kann potenzielle Sicherheitslücken offenbaren**. Diese Dateien sind mittels decompilers zugänglich oder indem man die APK-Endung in .zip ändert und sie entpackt.

**Schwachstellen**, die aus der **Manifest.xml** hervorgehen können, umfassen:

- **Debuggable Applications**: Anwendungen, die als debuggable (`debuggable="true"`) in der _Manifest.xml_ gesetzt sind, stellen ein Risiko dar, da sie Verbindungen erlauben, die zu einer Ausnutzung führen können. Für ein besseres Verständnis, wie man debuggable Anwendungen ausnutzt, siehe Tutorials zum Auffinden und Ausnutzen debuggable Anwendungen auf einem Gerät.
- **Backup Settings**: Das Attribut `android:allowBackup="false"` sollte explizit für Anwendungen gesetzt werden, die mit sensiblen Informationen arbeiten, um unautorisierte Daten-Backups via adb zu verhindern, besonders wenn usb debugging aktiviert ist.
- **Network Security**: Eigene network security Konfigurationen (`android:networkSecurityConfig="@xml/network_security_config"`) in _res/xml/_ können Sicherheitsdetails wie certificate pins und HTTP-Traffic-Einstellungen angeben. Ein Beispiel ist das Erlauben von HTTP-Traffic für bestimmte Domains.
- **Exported Activities and Services**: Das Identifizieren exportierter Activities und Services im Manifest kann Komponenten aufzeigen, die missbraucht werden könnten. Eine weitere Analyse während dynamischer Tests kann offenbaren, wie diese Komponenten ausgenutzt werden können.
- **Content Providers and FileProviders**: Offen exponierte Content Providers könnten unautorisierten Zugriff oder die Manipulation von Daten erlauben. Die Konfiguration von FileProviders sollte ebenfalls genau geprüft werden.
- **Broadcast Receivers and URL Schemes**: Diese Komponenten könnten für Exploits genutzt werden, mit besonderem Augenmerk darauf, wie URL-Schemes für Input-Schwachstellen gehandhabt werden.
- **SDK Versions**: Die Attribute `minSdkVersion`, `targetSDKVersion` und `maxSdkVersion` geben die unterstützten Android-Versionen an und heben hervor, warum es wichtig ist, keine veralteten, verwundbaren Android-Versionen zu unterstützen.

Aus der **strings.xml** Datei können sensible Informationen wie API keys, custom schemas und andere Entwicklerhinweise entdeckt werden, was die Notwendigkeit einer sorgfältigen Überprüfung dieser Ressourcen unterstreicht.

### Tapjacking

Tapjacking ist ein Angriff, bei dem eine **malicious** **application** gestartet wird und sich **über eine victim application legt**. Sobald sie die victim app sichtbar überdeckt, ist ihre Benutzeroberfläche so gestaltet, dass der Benutzer zur Interaktion verleitet wird, während die Interaktion an die victim app weitergereicht wird.\
Effektiv wird der Benutzer **gebilndet und weiß nicht, dass er tatsächlich Aktionen in der victim app durchführt**.

Mehr Informationen findest du in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Eine **activity** mit dem **`launchMode`** auf **`singleTask`** gesetzt und ohne definierte `taskAffinity` ist für Task Hijacking anfällig. Das bedeutet, dass eine **application** installiert werden kann, die, wenn sie vor der echten Anwendung gestartet wird, **die Task der echten Anwendung hijacken** könnte (sodass der Benutzer mit der **malicious application interagiert und denkt, er benutze die echte**).

Mehr Info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Unsichere Datenspeicherung

**Internal Storage**

In Android sind Dateien, die im **internal** storage **gespeichert** werden, so **konzipiert**, dass sie **ausschließlich von der App zugänglich** sind, die sie erstellt hat. Diese Sicherheitsmaßnahme wird vom Android-Betriebssystem durchgesetzt und ist in der Regel ausreichend für die Sicherheitsanforderungen der meisten Anwendungen. Entwickler verwenden jedoch manchmal Modi wie `MODE_WORLD_READABLE` und `MODE_WORLD_WRITABLE`, um Dateien zwischen verschiedenen Anwendungen zu **teilen**. Diese Modi **beschränken den Zugriff nicht** auf diese Dateien durch andere Anwendungen, einschließlich potenziell bösartiger.

1. **Statische Analyse:**
- **Überprüfe**, ob `MODE_WORLD_READABLE` und `MODE_WORLD_WRITABLE` verwendet werden. Diese Modi **können Dateien unbeabsichtigt oder unautorisiert zugänglich machen**.
2. **Dynamische Analyse:**
- **Verifiziere** die **Berechtigungen** von Dateien, die von der App erstellt wurden. Prüfe speziell, ob Dateien **weltweit lesbar oder beschreibbar** gesetzt sind. Das stellt ein erhebliches Sicherheitsrisiko dar, da **jede installierte Anwendung**, unabhängig von Herkunft oder Absicht, diese Dateien **lesen oder ändern** könnte.

**External Storage**

Beim Umgang mit Dateien auf **external storage**, wie SD-Karten, sind bestimmte Vorsichtsmaßnahmen zu treffen:

1. **Zugänglichkeit**:
- Dateien auf external storage sind **global lesbar und beschreibbar**. Das bedeutet, jede Anwendung oder jeder Benutzer kann auf diese Dateien zugreifen.
2. **Sicherheitsbedenken**:
- Aufgrund der leichten Zugänglichkeit sollte man **keine sensiblen Informationen** auf external storage speichern.
- External storage kann entfernt oder von beliebigen Anwendungen ausgelesen werden, wodurch es weniger sicher ist.
3. **Umgang mit Daten von External Storage**:
- Führe immer **Input-Validierung** auf Daten durch, die von external storage geladen werden. Das ist wichtig, da die Daten aus einer untrusted Quelle stammen.
- Das Speichern von Executables oder class files auf external storage zum dynamischen Laden ist stark zu vermeiden.
- Wenn deine Anwendung ausführbare Dateien aus external storage laden muss, stelle sicher, dass diese Dateien **signiert und kryptografisch verifiziert** sind, bevor sie dynamisch geladen werden. Dieser Schritt ist entscheidend für die Integrität und Sicherheit deiner Anwendung.

External storage kann unter /storage/emulated/0 , /sdcard , /mnt/sdcard zugegriffen werden.

> [!TIP]
> Beginnend mit Android 4.4 (**API 17**) hat die SD-Karte eine Verzeichnisstruktur, die den Zugriff einer App auf das Verzeichnis einschränkt, das speziell für diese App vorgesehen ist. Das verhindert, dass bösartige Anwendungen Lese- oder Schreibzugriff auf die Dateien einer anderen App erlangen.

**Sensitive data stored in clear-text**

- **Shared preferences**: Android erlaubt jeder Anwendung, XML-Dateien unter dem Pfad `/data/data/<packagename>/shared_prefs/` abzulegen, und manchmal findet man dort sensitive Informationen im Klartext.
- **Databases**: Android erlaubt jeder Anwendung, sqlite-Datenbanken unter dem Pfad `/data/data/<packagename>/databases/` zu speichern, und manchmal findet man dort sensitive Informationen im Klartext.

### Broken TLS

**Accept All Certificates**

Aus irgendeinem Grund akzeptieren Entwickler manchmal alle Zertifikate, selbst wenn zum Beispiel der Hostname nicht übereinstimmt, mit Codezeilen wie der folgenden:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Broken Cryptography

**Poor Key Management Processes**

Einige Entwickler speichern sensitive Daten im lokalen Speicher und verschlüsseln sie mit einem im Code hardcodierten/vorhersehbaren key. Das sollte nicht gemacht werden, da ein reversing Angreifern erlauben könnte, die vertraulichen Informationen zu extrahieren.

**Use of Insecure and/or Deprecated Algorithms**

Entwickler sollten keine **deprecated algorithms** verwenden, um Autorisierungs-**checks** durchzuführen, Daten zu **store** oder zu **send**. Einige dieser Algorithmen sind: RC4, MD4, MD5, SHA1... Wenn beispielsweise **hashes** verwendet werden, um Passwörter zu speichern, sollten brute-force-resistant **hashes** mit salt verwendet werden.

### Other checks

- Es wird empfohlen, die **obfuscate the APK** zu verwenden, um die Arbeit des reverse engineer für Angreifer zu erschweren.
- Wenn die App sensibel ist (wie bank apps), sollte sie ihre **own checks to see if the mobile is rooted** durchführen und entsprechend handeln.
- Wenn die App sensibel ist (wie bank apps), sollte sie prüfen, ob ein **emulator** verwendet wird.
- Wenn die App sensibel ist (wie bank apps), sollte sie **check it's own integrity before executing** um zu prüfen, ob sie modifiziert wurde.
- Use [**APKiD**](https://github.com/rednaga/APKiD) um zu prüfen, welcher compiler/packer/obfuscator verwendet wurde, um die APK zu bauen

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

The tool [**mariana-trench**](https://github.com/facebook/mariana-trench) is capable of finding **vulnerabilities** by **scanning** the **code** of the application. This tool contains a series of **known sources** (that indicates to the tool the **places** where the **input** is **controlled by the user**), **sinks** (which indicates to the tool **dangerous** **places** where malicious user input could cause damages) and **rules**. These rules indicates the **combination** of **sources-sinks** that indicates a vulnerability.

With this knowledge, **mariana-trench will review the code and find possible vulnerabilities on it**.

### Secrets leaked

An application may contain secrets (API keys, passwords, hidden urls, subdomains...) inside of it that you might be able to discover. You could us a tool such as [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> First of all, you need an environment where you can install the application and all the environment (Burp CA cert, Drozer and Frida mainly). Therefore, a rooted device (emulated or not) is extremely recommended.

### Online Dynamic analysis

You can create a **free account** in: [https://appetize.io/](https://appetize.io). This platform allows you to **upload** and **execute** APKs, so it is useful to see how an apk is behaving.

You can even **see the logs of your application** in the web and connect through **adb**.

![](<../../images/image (831).png>)

Thanks to the ADB connection you can use **Drozer** and **Frida** inside the emulators.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (You can create **x86** and **arm** devices, and according to [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** versions **support ARM libraries** without needing an slow arm emulator).
- Learn to set it up in this page:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, you need to create an account. _It's recommend to **download** the version **WITH**_ _**VirtualBox** to avoid potential errors._)
- [**Nox**](https://es.bignox.com) (Free, but it doesn't support Frida or Drozer).

> [!TIP]
> When creating a new emulator on any platform remember that the bigger the screen is, the slower the emulator will run. So select small screens if possible.

To **install google services** (like AppStore) in Genymotion you need to click on the red marked button of the following image:

![](<../../images/image (277).png>)

Also, notice that in the **configuration of the Android VM in Genymotion** you can select **Bridge Network mode** (this will be useful if you will be connecting to the Android VM from a different VM with the tools).

#### Use a physical device

You need to activate the **debugging** options and it will be cool if you can **root** it:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Once you have installed the application, the first thing you should do is to try it and investigate what does it do, how does it work and get comfortable with it.\
> I will suggest to **perform this initial dynamic analysis using MobSF dynamic analysis + pidcat**, so we will be able to **learn how the application works** while MobSF **captures** a lot of **interesting** **data** you can review later on.

### Unintended Data Leakage

**Logging**

Entwickler sollten vorsichtig sein, **debugging information** öffentlich preiszugeben, da dies zu sensiblen data leaks führen kann. Die Tools [**pidcat**](https://github.com/JakeWharton/pidcat) und `adb logcat` werden empfohlen, um Anwendungslogs zu überwachen und sensible Informationen zu identifizieren bzw. zu schützen. **Pidcat** wird wegen seiner Benutzerfreundlichkeit und Lesbarkeit bevorzugt.

> [!WARNING]
> Note that from **later newer than Android 4.0**, **applications are only able to access their own logs**. So applications cannot access other apps logs.\
> Anyway, it's still recommended to **not log sensitive information**.

**Copy/Paste Buffer Caching**

Android's **clipboard-based** framework enables copy-paste functionality in apps, yet poses a risk as **other applications** can **access** the clipboard, potentially exposing sensitive data. It's crucial to **disable copy/paste** functions for sensitive sections of an application, like credit card details, to prevent data leaks.

**Crash Logs**

If an application **crashes** and **saves logs**, these logs can assist attackers, particularly when the application cannot be reverse-engineered. To mitigate this risk, avoid logging on crashes, and if logs must be transmitted over the network, ensure they are sent via an SSL channel for security.

As pentester, **try to take a look to these logs**.

**Analytics Data Sent To 3rd Parties**

Applications often integrate services like Google Adsense, which can inadvertently **leak sensitive data** due to improper implementation by developers. To identify potential data leaks, it's advisable to **intercept the application's traffic** and check for any sensitive information being sent to third-party services.

### SQLite DBs

Most of the applications will use **internal SQLite databases** to save information. During the pentest take a **look** to the **databases** created, the names of **tables** and **columns** and all the **data** saved because you could find **sensitive information** (which would be a vulnerability).\
Databases should be located in `/data/data/the.package.name/databases` like `/data/data/com.mwr.example.sieve/databases`

If the database is saving confidential information and is **encrypted b**ut you can **find** the **password** inside the application it's still a **vulnerability**.

Enumerate the tables using `.tables` and enumerate the columns of the tables doing `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer is s useful tool to **exploit exported activities, exported services and Content Providers** as you will learn in the following sections.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Also remember that the code of an activity starts in the **`onCreate`** method.

**Authorisation bypass**

When an Activity is exported you can invoke its screen from an external app. Therefore, if an activity with **sensitive information** is **exported** you could **bypass** the **authentication** mechanisms **to access it.**

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

You can also start an exported activity from adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**HINWEIS**: MobSF wird die Verwendung von _**singleTask/singleInstance**_ als `android:launchMode` in einer activity als bösartig erkennen, aber aufgrund von [diesem](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750) ist das offenbar nur auf alten Versionen (API versions < 21) gefährlich.

> [!TIP]
> Beachte, dass ein authorisation bypass nicht immer eine vulnerability ist — es kommt darauf an, wie der bypass funktioniert und welche Informationen exponiert werden.

**Sensitive information leakage**

Activities können auch Ergebnisse zurückgeben. Wenn es dir gelingt, eine exportierte und ungeschützte activity zu finden, die die Methode **`setResult`** aufruft und **sensible Informationen zurückgibt**, liegt ein Leck sensibler Informationen vor.

#### Tapjacking

Wenn Tapjacking nicht verhindert wird, könntest du die exportierte activity missbrauchen, um den **Benutzer unerwartete Aktionen ausführen zu lassen**. Für mehr Infos über [**was Tapjacking ist, folge dem Link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Lies dies, wenn du auffrischen möchtest, was ein Content Provider ist.**](android-applications-basics.md#content-provider)\
Content providers werden im Grunde verwendet, um **Daten zu teilen**. Wenn eine App Content providers bereitstellt, kannst du möglicherweise **sensible Daten aus ihnen extrahieren**. Es ist außerdem sinnvoll, mögliche **SQL injections** und **Path Traversals** zu testen, da diese verwundbar sein könnten.

[**Lerne, wie man Content Providers mit Drozer ausnutzt.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Lies dies, wenn du auffrischen möchtest, was ein Service ist.**](android-applications-basics.md#services)\
Denke daran, dass die Aktionen eines Service in der Methode `onStartCommand` beginnen.

Ein Service ist im Grunde etwas, das **Daten empfangen**, diese **verarbeiten** und (oder nicht) eine Antwort **zurückgeben** kann. Wenn eine Anwendung also Services exportiert, solltest du den **Code** prüfen, um zu verstehen, was er tut, und ihn **dynamisch** testen, um vertrauliche Informationen zu extrahieren, Authentifizierungsmaßnahmen zu umgehen usw.\
[**Lerne, wie man Services mit Drozer ausnutzt.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Lies dies, wenn du auffrischen möchtest, was ein Broadcast Receiver ist.**](android-applications-basics.md#broadcast-receivers)\
Denke daran, dass die Aktionen eines Broadcast Receiver in der Methode `onReceive` beginnen.

Ein Broadcast Receiver wartet auf einen bestimmten Nachrichtentyp. Je nachdem, wie der Receiver die Nachricht verarbeitet, kann er verwundbar sein.\
[**Lerne, wie man Broadcast Receivers mit Drozer ausnutzt.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Du kannst nach deep links manuell suchen, indem du Tools wie MobSF oder Skripte wie [dieses](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py) verwendest.\
Du kannst ein deklariertes **scheme** mit **adb** oder einem **browser** **öffnen**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Beachte, dass du **den Paketnamen weglassen** kannst und das Mobilgerät automatisch die App aufruft, die diesen Link öffnen sollte._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Ausgeführter Code**

Um den **Code zu finden, der in der App ausgeführt wird**, gehe zur Activity, die vom deeplink aufgerufen wird, und suche die Funktion **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Sensitive info**

Jedes Mal, wenn du einen deep link findest, überprüfe, dass **er keine sensitiven Daten (wie Passwörter) über URL parameters erhält**, denn jede andere Anwendung könnte **den deep link vortäuschen und diese Daten stehlen!**

**Parameters in path**

Du **musst auch prüfen, ob ein deep link einen Parameter im Pfad** der URL verwendet, z. B.: `https://api.example.com/v1/users/{username}`. In diesem Fall kannst du ein path traversal erzwingen, indem du auf etwas wie `example://app/users?username=../../unwanted-endpoint%3fparam=value` zugreifst.\
Note that if you find the correct endpoints inside the application you may be able to cause a **Open Redirect** (if part of the path is used as domain name), **account takeover** (if you can modify users details without CSRF token and the vuln endpoint used the correct method) and any other vuln. More [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Transport Layer-Inspektion und Verifikationsfehler

- **Zertifikate werden nicht immer korrekt geprüft** von Android-Anwendungen. Es ist üblich, dass diese Anwendungen Warnungen ignorieren und selbstsignierte Zertifikate akzeptieren oder in einigen Fällen auf HTTP-Verbindungen zurückfallen.
- **Aushandlungen während des SSL/TLS-Handshake sind manchmal schwach**, es werden insecure cipher suites eingesetzt. Diese Schwachstelle macht die Verbindung anfällig für man-in-the-middle (MITM) Angriffe und erlaubt Angreifern, die Daten zu entschlüsseln.
- **Offenlegung privater Informationen** ist ein Risiko, wenn Anwendungen sich über sichere Kanäle authentifizieren, dann aber für andere Transaktionen über unsichere Kanäle kommunizieren. Dieser Ansatz schützt sensible Daten wie Session-Cookies oder Benutzerdetails nicht vor dem Abfangen durch böswillige Akteure.

#### Certificate Verification

Wir konzentrieren uns auf die **Zertifikatsverifikation**. Die Integrität des Serverzertifikats muss verifiziert werden, um die Sicherheit zu erhöhen. Das ist entscheidend, da unsichere TLS-Konfigurationen und die Übertragung sensibler Daten über unverschlüsselte Kanäle erhebliche Risiken darstellen können. Für detaillierte Schritte zur Überprüfung von Serverzertifikaten und zur Behebung von Schwachstellen bietet [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) umfassende Anleitungen.

#### SSL Pinning

SSL Pinning ist eine Sicherheitsmaßnahme, bei der die Anwendung das Serverzertifikat gegen eine bekannte Kopie verifiziert, die innerhalb der Anwendung gespeichert ist. Diese Methode ist essenziell, um MITM-Angriffe zu verhindern. Die Implementierung von SSL Pinning wird dringend empfohlen für Anwendungen, die mit sensitiven Informationen umgehen.

#### Traffic Inspection

Um HTTP-Traffic zu inspizieren, ist es notwendig, **das Zertifikat des Proxy-Tools zu installieren** (z. B. Burp). Ohne die Installation dieses Zertifikats ist verschlüsselter Traffic möglicherweise nicht über den Proxy sichtbar. For a guide on installing a custom CA certificate, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Applications targeting **API Level 24 and above** require modifications to the Network Security Config to accept the proxy's CA certificate. This step is critical for inspecting encrypted traffic. For instructions on modifying the Network Security Config, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

If **Flutter** is being used you need to to follow the instructions in [**this page**](flutter.md). This is becasue, just adding the certificate into the store won't work as Flutter has its own list of valid CAs.

#### Static detection of SSL/TLS pinning

Bevor du Runtime-Bypässe versuchst, mappe schnell, wo Pinning im APK erzwungen wird. Statische Erkennung hilft dir, Hooks/Patches zu planen und dich auf die richtigen Code-Pfade zu konzentrieren.

Tool: SSLPinDetect
- Open-source static-analysis utility that decompiles the APK to Smali (via apktool) and scans for curated regex patterns of SSL/TLS pinning implementations.
- Reports exact file path, line number, and a code snippet for each match.
- Covers common frameworks and custom code paths: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

Installation
- Voraussetzungen: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Verwendung
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Beispiel-Musterregeln (JSON)

Verwenden oder erweitern Sie signatures, um proprietäre/custom pinning styles zu erkennen. Sie können Ihr eigenes JSON laden und scan at scale.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes and tips
- Schnelles Scannen großer Apps per Multithreading und memory-mapped I/O; vorkompilierte regex reduziert Overhead/Falschpositive.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Typische Erkennungsziele zur weiteren Triage:
- OkHttp: CertificatePinner-Nutzung, setCertificatePinner, okhttp3/okhttp Paketreferenzen
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted-Overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init mit eigenen Managern
- Deklarative pins in res/xml network security config und Manifest-Referenzen
- Nutze die gefundenen Stellen, um Frida-Hooks, statische Patches oder Config-Reviews vor dynamischem Testing zu planen.



#### Umgehung von SSL Pinning

Wenn SSL Pinning implementiert ist, wird seine Umgehung notwendig, um HTTPS-Traffic zu untersuchen. Dafür stehen verschiedene Methoden zur Verfügung:

- Automatisch die **apk** mit [**apk-mitm**](https://github.com/shroudedcode/apk-mitm) **modifizieren**, um SSLPinning zu **bypassen**. Der größte Vorteil dieser Option ist, dass du kein root brauchst, um das SSL Pinning zu umgehen, aber du musst die Anwendung löschen und die neue installieren — das funktioniert nicht immer.
- Du kannst **Frida** (unten besprochen) verwenden, um diesen Schutz zu umgehen. Hier ein Guide für Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Du kannst auch versuchen, SSL Pinning automatisch mit [**objection**](frida-tutorial/objection-tutorial.md) zu umgehen: `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Du kannst auch versuchen, SSL Pinning automatisch mit **MobSF dynamic analysis** zu umgehen (unten erklärt)
- Wenn du denkst, dass Traffic nicht erfasst wird, kannst du versuchen, den Traffic per iptables an Burp weiterzuleiten. Lies diesen Blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Suche nach gängigen Web-Vulnerabilities

Es ist wichtig, auch nach gängigen Web-Vulnerabilities innerhalb der Anwendung zu suchen. Detaillierte Informationen zur Identifikation und Behebung dieser Schwachstellen liegen außerhalb dieser Zusammenfassung, werden aber an anderer Stelle ausführlich behandelt.

### Frida

[Frida](https://www.frida.re) ist ein dynamisches Instrumentierungs-Toolkit für Entwickler, Reverse-Engineers und Sicherheitsforscher.\
Du kannst auf laufende Anwendungen zugreifen und Methoden zur Laufzeit hooken, um Verhalten zu ändern, Werte zu verändern, Werte zu extrahieren oder anderen Code auszuführen...\
Wenn du Android-Anwendungen pentesten willst, musst du wissen, wie man Frida benutzt.

- Lerne, wie man Frida benutzt: [**Frida tutorial**](frida-tutorial/index.html)
- Einige "GUI" für Aktionen mit Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection ist gut, um die Nutzung von Frida zu automatisieren: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Du findest einige Awesome Frida-Skripte hier: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Versuche, Anti-Debugging / Anti-Frida-Mechanismen zu umgehen, indem du Frida wie in [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) gezeigt lädst (Tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Speicher dumpen - Fridump**

Prüfe, ob die Anwendung sensible Informationen im Speicher ablegt, die dort nicht sein sollten, z. B. Passwörter oder mnemonics.

Mit [**Fridump3**](https://github.com/rootbsd/fridump3) kannst du den Speicher der App dumpen mit:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Dadurch wird der Speicher im Ordner ./dump gedumpt, und dort könntest du mit etwas wie folgendem grep suchen:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Sensible Daten im Keystore**

In Android ist der Keystore der beste Ort, um sensible Daten zu speichern, jedoch ist es mit ausreichenden Privilegien weiterhin **möglich, darauf zuzugreifen**. Da Anwendungen hier dazu neigen, **sensible Daten im Klartext** zu speichern, sollten pentests dies überprüfen, da ein root user oder jemand mit physischem Zugriff auf das Gerät diese Daten stehlen könnte.

Selbst wenn eine App Daten im Keystore speichert, sollten die Daten verschlüsselt sein.

Um auf die Daten im Keystore zuzugreifen, kannst du dieses Frida-Skript verwenden: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Mit dem folgenden Frida-Skript kann es möglich sein, eine von Android-Anwendungen eingesetzte **bypass fingerprint authentication** zu umgehen, die zum Schutz bestimmter sensibler Bereiche verwendet wird:
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Hintergrundbilder**

Wenn Sie eine Anwendung in den Hintergrund legen, speichert Android eine **snapshot of the application**, sodass beim Wiederherstellen in den Vordergrund das Bild vor der App geladen wird und es so aussieht, als wäre die App schneller gestartet.

Wenn dieser snapshot jedoch **sensible Informationen** enthält, könnte jemand mit Zugriff auf den snapshot **diese Informationen stehlen** (Hinweis: Zum Zugriff wird Root benötigt).

Die snapshots werden üblicherweise hier gespeichert: **`/data/system_ce/0/snapshots`**

Android bietet eine Möglichkeit, **das Erfassen von screenshots zu verhindern, indem der Layout-Parameter FLAG_SECURE gesetzt wird**. Wenn dieses Flag verwendet wird, werden die Fensterinhalte als sicher behandelt, wodurch verhindert wird, dass sie in screenshots erscheinen oder auf nicht-sicheren Displays angezeigt werden.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Dieses Tool kann Ihnen beim Verwalten verschiedener Tools während der dynamic analysis helfen: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Entwickler erstellen häufig Proxy-Komponenten wie activities, services und broadcast receivers, die diese Intents verarbeiten und an Methoden wie `startActivity(...)` oder `sendBroadcast(...)` weitergeben, was riskant sein kann.

Die Gefahr liegt darin, Angreifern zu erlauben, nicht-exportierte App-Komponenten auszulösen oder sensible content providers zu erreichen, indem diese Intents fehlgeleitet werden. Ein bemerkenswertes Beispiel ist die `WebView`-Komponente, die URLs mittels `Intent.parseUri(...)` in `Intent`-Objekte umwandelt und diese dann ausführt, was potenziell zu bösartigen Intent injections führen kann.

### Wesentliche Erkenntnisse

- **Intent Injection** ist ähnlich wie das Open Redirect-Problem im Web.
- Exploits beinhalten das Übergeben von `Intent`-Objekten als extras, die umgeleitet werden können, um unsichere Operationen auszuführen.
- Dadurch können nicht-exportierte Komponenten und content providers für Angreifer zugänglich werden.
- Die URL-zu-`Intent`-Konvertierung von `WebView` kann unbeabsichtigte Aktionen ermöglichen.

### Android Client Side Injections and others

Wahrscheinlich kennen Sie diese Art von Schwachstellen aus dem Web. Bei einer Android-Anwendung müssen Sie besonders auf diese Schwachstellen achten:

- **SQL Injection:** Beim Umgang mit dynamischen Abfragen oder Content-Providers stellen Sie sicher, dass parametrisierte Abfragen verwendet werden.
- **JavaScript Injection (XSS):** Vergewissern Sie sich, dass JavaScript- und Plugin-Unterstützung für alle WebViews deaktiviert ist (standardmäßig deaktiviert). [Mehr Infos hier](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews sollten keinen Zugriff auf das Dateisystem haben (standardmäßig aktiviert) - `(webview.getSettings().setAllowFileAccess(false);)`. [Mehr Infos hier](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: In mehreren Fällen wird beim Beenden der Android-Anwendung die Session-Cookie nicht widerrufen oder das Cookie kann sogar auf der Festplatte gespeichert werden
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatische Analyse

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Statische Analyse**

![](<../../images/image (866).png>)

**Vulnerability assessment der Anwendung** mittels eines ansprechenden web-basierten Frontends. Sie können auch dynamic analysis durchführen (aber Sie müssen die Umgebung vorbereiten).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Beachte, dass MobSF **Android**(apk)**, IOS**(ipa) **und Windows**(apx) Anwendungen analysieren kann (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Außerdem, wenn du eine **ZIP** Datei mit dem Source-Code einer **Android** oder **IOS** App erstellst (gehe in den Root-Ordner der Anwendung, wähle alles aus und erstelle eine ZIPfile), kann es diese ebenfalls analysieren.

MobSF erlaubt dir auch, **diff/Compare** Analysen durchzuführen und **VirusTotal** zu integrieren (du musst deinen API Key in _MobSF/settings.py_ setzen und es aktivieren: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). Du kannst `VT_UPLOAD` auch auf `False` setzen, dann wird der **hash** statt der Datei **upload**.

### Unterstützte Dynamic analysis mit MobSF

**MobSF** kann auch bei der **dynamic analysis** von **Android** sehr hilfreich sein, in diesem Fall musst du jedoch MobSF und **genymotion** auf deinem Host installieren (eine VM oder Docker funktioniert nicht). _Hinweis: Du musst **zuerst eine VM in genymotion starten** und **dann MobSF.**_\
Der **MobSF dynamic analyser** kann:

- **Dump Anwendungsdaten** (URLs, logs, clipboard, screenshots, die du gemacht hast, screenshots die vom "**Exported Activity Tester**" gemacht wurden, emails, SQLite Datenbanken, XML Dateien und andere erstellte Dateien). All dies geschieht automatisch außer bei den Screenshots — diese musst du manuell auslösen, oder du musst "**Exported Activity Tester**" drücken, um Screenshots aller exportierten Activities zu erhalten.
- **Capture HTTPS traffic**
- **Use Frida** um **Laufzeitinformationen** zu erhalten

Ab android **versions > 5** wird es **automatisch Frida starten** und globale **proxy** Einstellungen setzen, um den Traffic zu **capture**. Es wird nur den Traffic der getesteten Anwendung erfassen.

**Frida**

Standardmäßig verwendet es auch einige Frida Scripts, um **SSL pinning** zu **bypassen**, **root detection** und **debugger detection** zu umgehen und um interessante **APIs** zu **monitoren**.\
MobSF kann auch **invoke exported activities**, **Screenshots** davon machen und sie für den Report **save**.

Um das dynamic testing zu **starten** drücke den grünen Button: "**Start Instrumentation**". Drücke "**Frida Live Logs**" um die von den Frida scripts erzeugten Logs zu sehen und "**Live API Monitor**" um alle Aufrufe der gehookten Methoden, übergebene Argumente und zurückgegebene Werte zu sehen (dies erscheint nach dem Drücken von "Start Instrumentation").\
MobSF erlaubt dir außerdem, eigene **Frida scripts** zu laden (um die Ergebnisse deiner Frida scripts an MobSF zu senden benutze die Funktion `send()`). Es gibt auch **mehrere vorgeschriebene scripts**, die du laden kannst (du kannst weitere in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/` hinzufügen), einfach **auswählen**, "**Load**" drücken und "**Start Instrumentation**" drücken (die Logs dieser scripts wirst du im "**Frida Live Logs**" sehen).

![](<../../images/image (419).png>)

Außerdem hast du einige zusätzliche Frida-Funktionalitäten:

- **Enumerate Loaded Classes**: Es gibt alle geladenen Klassen aus
- **Capture Strings**: Gibt alle erfassten Strings während der Nutzung der Anwendung aus (sehr viele Ausgaben)
- **Capture String Comparisons**: Kann sehr nützlich sein. Es zeigt die 2 verglichenen Strings und ob das Ergebnis True oder False war.
- **Enumerate Class Methods**: Gib den Klassennamen ein (z.B. "java.io.File") und es listet alle Methoden der Klasse auf.
- **Search Class Pattern**: Sucht Klassen nach einem Pattern
- **Trace Class Methods**: **Trace** eine **ganze Klasse** (siehe Eingaben und Ausgaben aller Methoden der Klasse). Denk daran, dass MobSF standardmäßig mehrere interessante Android Api Methoden trace't.

Sobald du das Hilfsmodul ausgewählt hast, das du verwenden möchtest, musst du "**Start Intrumentation**" drücken und du wirst alle Ausgaben in "**Frida Live Logs**" sehen.

**Shell**

Mobsf bietet dir außerdem eine Shell mit einigen **adb** Befehlen, **MobSF** Befehlen und gängigen **shell** **commands** am unteren Rand der dynamic analysis Seite. Einige interessante Befehle:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP-Tools**

Wenn HTTP-Traffic erfasst wird, kannst du eine rohe Ansicht des aufgezeichneten Traffics über den "**HTTP(S) Traffic**"-Button sehen oder eine schönere Ansicht über den grünen "**Start HTTPTools**"-Button. Über die zweite Option kannst du die **aufgezeichneten Requests** an **Proxies** wie Burp oder Owasp ZAP **senden**.\
Um das zu tun: _Burp einschalten -->_ _Intercept ausschalten --> in MobSB HTTPTools die Anfrage auswählen_ --> auf "**Send to Fuzzer**" drücken --> _die Proxy-Adresse auswählen_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Sobald du die dynamische Analyse mit MobSF abgeschlossen hast, kannst du auf "**Start Web API Fuzzer**" drücken, um **http requests zu fuzz-en** und nach Schwachstellen zu suchen.

> [!TIP]
> Nach einer dynamischen Analyse mit MobSF können die Proxy-Einstellungen falsch konfiguriert sein und du kannst sie nicht über die GUI reparieren. Du kannst die Proxy-Einstellungen folgendermaßen zurücksetzen:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

Du kannst das Tool von [**Inspeckage**](https://github.com/ac-pm/Inspeckage) beziehen.\
Dieses Tool verwendet einige **Hooks**, um dir während einer **dynamic analysis** zu zeigen, **was in der Anwendung passiert**, während du sie ausführst.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Dies ist ein **tolles Tool, um statische Analyse mit einer GUI durchzuführen**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Dieses Tool wurde entwickelt, um nach verschiedenen **security related Android application vulnerabilities** zu suchen, sowohl im **source code** als auch in **packaged APKs**. Das Tool ist außerdem **in der Lage, eine \"Proof-of-Concept\" deployable APK** und **ADB commands** zu erstellen, um einige der gefundenen Schwachstellen auszunutzen (Exposed activities, intents, tapjacking...). Wie bei Drozer ist es nicht nötig, das Testgerät zu rooten.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Zeigt alle extrahierten Dateien zur einfachen Referenz an
- Dekompiliert automatisch APK-Dateien in Java- und Smali-Format
- Analysiert AndroidManifest.xml auf häufige Schwachstellen und Verhaltensweisen
- Statische Quellcode-Analyse auf häufige Schwachstellen und Verhaltensweisen
- Geräteinformationen
- und mehr
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER ist eine Kommandozeilenanwendung, die unter Windows, MacOS X und Linux genutzt werden kann und _.apk_-Dateien nach Schwachstellen analysiert. Dazu dekomprimiert sie APKs und wendet eine Reihe von Regeln an, um diese Schwachstellen zu erkennen.

Alle Regeln sind in einer `rules.json`-Datei zentralisiert, und jedes Unternehmen oder jeder Tester kann eigene Regeln erstellen, um das zu analysieren, was sie benötigen.

Lade die neuesten Binaries von der [download page](https://superanalyzer.rocks/download.html) herunter.
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn ist ein **crossplatform** Tool, das Entwickler, bugbounty hunters und ethical hackers bei der Durchführung von [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) an mobilen Anwendungen unterstützt.

Das Konzept ist, dass Sie Ihre mobile Anwendungsdatei (eine .apk- oder .ipa-Datei) per Drag & Drop auf die StaCoAn-Anwendung ziehen; anschließend erstellt sie einen visuellen und portablen Bericht für Sie. Sie können die Einstellungen und wordlists anpassen, um eine maßgeschneiderte Erfahrung zu erhalten.

Herunterladen[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework ist ein Android vulnerability analysis system, das Entwicklern oder hackers hilft, potenzielle security vulnerabilities in Android-Anwendungen zu finden.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** ist ein Tool, dessen Hauptziel darin besteht, den Benutzer vor potenziell bösartigen Verhaltensweisen einer Android-Anwendung zu erkennen und zu warnen.

Die Erkennung erfolgt durch **static analysis** des Dalvik bytecode der Anwendung, dargestellt als **Smali**, mithilfe der [`androguard`](https://github.com/androguard/androguard) Bibliothek.

Dieses Tool sucht nach **häufigen Verhaltensmustern von "bad" applications** wie: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** ist ein **M**obile **A**pplication **R**everse Engineering und **A**nalysis Framework. Es ist ein Tool, das häufig verwendete Mobile Application Reverse Engineering- und Analysis-Tools zusammenführt, um bei der Prüfung von mobilen Anwendungen gegen die OWASP mobile security threats zu unterstützen. Ziel ist es, diese Aufgabe für Mobile-Application-Entwickler und Sicherheitsfachleute einfacher und benutzerfreundlicher zu machen.

Es kann:

- Java- und Smali-Code mit verschiedenen Tools extrahieren
- APKs analysieren mit: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Private Informationen aus der APK mit Regexps extrahieren.
- Das Manifest analysieren.
- Gefundene Domains analysieren mit: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) und [whatweb](https://github.com/urbanadventurer/WhatWeb)
- APK via [apk-deguard.com](http://www.apk-deguard.com) deobfuskieren

### Koodous

Nützlich zur Erkennung von Malware: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Beachte, dass abhängig vom Service und der Konfiguration, die du zum Obfuskieren des Codes verwendest, Secrets eventuell obfuskiert sind oder nicht.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** ist ein Open-Source-Kommandozeilen-Tool, das Java-Code schrumpft, optimiert und obfuskiert. Es kann Bytecode optimieren sowie ungenutzte Instruktionen erkennen und entfernen. ProGuard ist freie Software und wird unter der GNU General Public License, Version 2 vertrieben.

ProGuard wird als Teil des Android SDK ausgeliefert und läuft beim Erstellen der Anwendung im Release-Modus.

### [DexGuard](https://www.guardsquare.com/dexguard)

Eine Schritt-für-Schritt-Anleitung zum Deobfuskieren der APK findest du unter [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(Aus diesem Leitfaden) Beim letzten Mal, als wir es überprüft haben, war der DexGuard Betriebsmodus wie folgt:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard kehrt den von Android-Obfuskationstools durchgeführten Obfuskationsprozess um. Dies ermöglicht zahlreiche Sicherheitsanalysen, einschließlich Code-Inspektion und Erkennung von Bibliotheken.**

Du kannst eine obfuskierte APK auf ihre Plattform hochladen.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

Dies ist ein LLM-Tool, um mögliche Sicherheitslücken in Android-Apps zu finden und Android-App-Code zu deobfuskieren. Verwendet Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

Es ist ein **generischer android deobfuscator.** Simplify **führt eine App praktisch aus**, um ihr Verhalten zu verstehen, und versucht dann, den Code so zu optimieren, dass er sich identisch verhält, aber für einen Menschen leichter zu verstehen ist. Jeder Optimierungstyp ist einfach und generisch, sodass es egal ist, welche konkrete Art der Obfuskation verwendet wurde.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD liefert Informationen darüber, **wie eine APK erstellt wurde**. Es identifiziert viele **Compilers**, **Packers**, **Obfuscators** und andere merkwürdige Dinge. Es ist [_PEiD_](https://www.aldeid.com/wiki/PEiD) für Android.

### Manual

[Lesen Sie dieses Tutorial, um einige Tricks zu lernen, **wie man benutzerdefinierte Obfuskation reverse-engineert**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b ist eine Android-Sicherheits-virtuelle Maschine basierend auf ubuntu-mate und enthält eine Sammlung der neuesten Frameworks, Tutorials und Labs von verschiedenen Security-Geeks und Forschern für Reverse Engineering und Malware-Analyse.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Es ist eine großartige Liste von Ressourcen
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)

## Yet to try

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
