# Android Applications Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Misingi ya Programu za Android

Inashauriwa sana kuanza kusoma ukurasa huu ili kujua kuhusu **sehemu muhimu zaidi zinazohusiana na usalama wa Android na vipengele hatari zaidi katika programu ya Android**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Hii ni zana kuu unayohitaji kuunganishwa na kifaa cha Android (kimeiga au cha kiasili).\
**ADB** inaruhusu kudhibiti vifaa ama kupitia **USB** au **Network** kutoka kwa kompyuta. Kifaa hiki kinakuruhusu kufanya **kunakili** faili pande zote mbili, **ufungaji** na **kuondoa** apps, **kutekeleza** amri za shell, **kuhifadhi nakala** za data, **kusoma** logi, pamoja na kazi nyingine.

Tazama orodha ifuatayo ya [**ADB Commands**](adb-commands.md) ili kujifunza jinsi ya kutumia adb.

## Smali

Wakati mwingine inavutia **kubadilisha code ya programu** ili kupata **taarifa zilizofichwa** (labda nywila zilizofichwa vizuri au flagi). Baadaye, inaweza kuwa muhimu ku-decompile APK, kubadilisha code na ku-recompile APK.\
[**Katika tutorial hii** unaweza **kujifunza jinsi ya ku-decompile APK, kubadilisha Smali code na ku-recompile APK** na functionality mpya](smali-changes.md). Hii inaweza kuwa muhimu kama **mbadala kwa vipimo kadhaa wakati wa dynamic analysis** vitakavyoonyeshwa. Kwa hivyo, **kumbuka kila wakati uwezekano huu**.

## Other interesting tricks

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [Android IME / InputMethodService Abuse (Malicious Keyboards)](inputmethodservice-ime-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Extract APK from device:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Unganisha splits zote na base apks kwa kutumia [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Shambulio za Android Enterprise na Work Profile

{{#ref}}
android-enterprise-work-profile-bypass.md
{{#endref}}

## Masomo ya Kesi & Udhaifu


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}


{{#ref}}
../../binary-exploitation/linux-kernel-exploitation/arm64-static-linear-map-kaslr-bypass.md
{{#endref}}

## Uchambuzi wa Statiki

Kwanza kabisa, kwa kuchambua APK unapaswa **kuangalia msimbo wa Java** kwa kutumia decompiler.\
Tafadhali, [**soma hapa kupata taarifa kuhusu decompilers mbalimbali zinazopatikana**](apk-decompilers.md).

### Kutafuta Taarifa Zinazovutia

Kwa kuangalia tu **strings** za APK unaweza kutafuta **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **API** keys, **encryption**, **bluetooth uuids**, **tokens** na chochote cha kuvutia... angalia hata kwa code execution **backdoors** au authentication backdoors (hardcoded admin credentials kwa app).

**Firebase**

Lipa umakini maalum kwa **Firebase** na ukague ikiwa imepangwa vibaya. [Taarifa zaidi kuhusu ni nini Firebase na jinsi ya kuitumia hapa.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Uelewa wa Msingi wa Programu - Manifest.xml, strings.xml

Ukaguzi wa faili za programu _Manifest.xml_ na **_strings.xml_** unaweza kufichua udhaifu wa usalama. Faili hizi zinaweza kupatikana kwa kutumia decompilers au kwa kubadili kiendelezi cha faili ya APK kuwa .zip kisha kuizipisha.

Udhaifu yanayopatikana katika **Manifest.xml** ni pamoja na:

- **Debuggable Applications**: Programu zilizo wekwa kama debuggable (`debuggable="true"`) katika faili _Manifest.xml_ zina hatari kwa sababu zinaruhusu muunganisho ambao unaweza kusababisha exploitation. Kwa uelewa zaidi juu ya jinsi ya ku-exploit programu debuggable, rejea mwongozo wa kutafuta na ku-exploit programu debuggable kwenye kifaa.
- **Backup Settings**: Sifa `android:allowBackup="false"` inapaswa kuwekwa wazi kwa programu zinazoshughulikia taarifa nyeti ili kuzuia backups zisizoruhusiwa za data kupitia adb, hasa wakati usb debugging imewezeshwa.
- **Network Security**: Usanidi maalum wa network security (`android:networkSecurityConfig="@xml/network_security_config"`) katika _res/xml/_ unaweza kubainisha maelezo ya usalama kama certificate pins na mipangilio ya trafiki ya HTTP. Mfano ni kuruhusu trafiki ya HTTP kwa domain maalum.
- **Exported Activities and Services**: Kutambua activities na services zilizotumwa (exported) katika manifest kunaweza kuonyesha components ambazo zinaweza kutumika vibaya. Uchambuzi zaidi wakati wa majaribio ya dynamic unaweza kufichua jinsi ya kuzitumia.
- **Content Providers and FileProviders**: Content providers zilizo wazi zinaweza kuruhusu ufikiaji usioruhusiwa au urekebishaji wa data. Uundaji wa FileProviders pia unapaswa kuchunguzwa kwa makini.
- **Broadcast Receivers and URL Schemes**: Components hizi zinaweza kutumika kwa exploitation, kwa umakini maalum jinsi URL schemes zinavyosimamiwa kwa udhaifu wa input.
- **SDK Versions**: Vigezo `minSdkVersion`, `targetSDKVersion`, na `maxSdkVersion` vinaonyesha toleo la Android linaloungwa mkono, zikibainisha umuhimu wa kutounga mkono toleo la Android lililopo zamani na lenye udhaifu kwa sababu za usalama.

Kutoka kwa faili **strings.xml**, taarifa nyeti kama API keys, custom schemas, na maelezo mengine ya developer zinaweza kupatikana, ikisisitiza umuhimu wa kupitia kwa makini rasilimali hizi.

### Tapjacking

**Tapjacking** ni shambulio ambapo **malicious application** inazinduliwa na kujipanga juu ya **victim application**. Mara inapoonekana kufunika app ya mwathiri, interface yake imeundwa kwa njia ya kuwadanganya watumiaji kuingiliana nayo, wakati inapitisha mwingiliano huo kwa app ya mwathiri.\
Kwa ufanisi, ni **kuficha kwa mtumiaji kwamba kwa kweli anafanya vitendo kwenye app ya mwathiri**.

Pata taarifa zaidi katika:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Activity yenye `launchMode` imewekwa kuwa `singleTask` bila `taskAffinity` iliyoainishwa inakuwa hatarini kwa task Hijacking. Hii ina maana kwamba, programu inaweza kusanikishwa na ikiwa itaendeshwa kabla ya programu halisi inaweza **hijack task ya programu halisi** (hivyo mtumiaji atakuwa anaitumia **malicious application akiwa akidhani anatumia ile halisi**).

Taarifa zaidi katika:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Uhifadhi wa Data Usio Salama

Internal Storage

Katika Android, faili zilizohifadhiwa kwenye uhifadhi wa ndani zimetengenezwa kuwa zinapatikana kwa kipekee na app iliyozitengeneza. Kipimo hiki cha usalama kinatakiwa na mfumo wa uendeshaji wa Android na kwa ujumla kinatosha kwa mahitaji ya usalama ya programu nyingi. Hata hivyo, waendelezaji wakati mwingine hutumia modes kama `MODE_WORLD_READABLE` na `MODE_WORLD_WRITABLE` kuruhusu faili kushirikiwa kati ya programu mbalimbali. Modes hizi hazizuizi ufikiaji wa faili hizi na programu zingine, ikiwemo zile ambazo zinaweza kuwa malicious.

1. **Static Analysis:**
- **Hakikisha** kwamba matumizi ya `MODE_WORLD_READABLE` na `MODE_WORLD_WRITABLE` yamepitwa kwa makini. Modes hizi **zinaweza kufichua** faili kwa ufikiaji usiotarajiwa au usioruhusiwa.
2. **Dynamic Analysis:**
- **Thibitisha** ruhusa zilizowekwa kwenye faili zilizotengenezwa na app. Haddharisha hasa ikiwa faili yoyote imewekwa kuwa readable au writable kwa kila mtu. Hii inaweza kuwa hatari kubwa ya usalama, kwani itaruhusu **programu yoyote** iliyosanikishwa kwenye kifaa, bila kujali chanzo au nia yake, kusoma au kurekebisha faili hizi.

External Storage

Wakati ukishughulikia faili kwenye external storage, kama SD Cards, tahadhari zifuatazo zinapaswa kuchukuliwa:

1. **Accessibility**:
- Faili kwenye external storage zinapatika kwa kusomwa na kuandikwa kwa kimataifa. Hii ina maana programu yoyote au mtumiaji anaweza kufikia faili hizi.
2. **Security Concerns**:
- Kutokana na urahisi wa ufikiaji, inashauriwa **kutoiwekea taarifa nyeti** kwenye external storage.
- External storage inaweza kuondolewa au kufikiwa na programu yoyote, ikifanya iwe isiyo salama.
3. **Handling Data from External Storage**:
- Daima **fanya uthibitisho wa input** kwa data inayopatikana kutoka external storage. Hii ni muhimu kwa sababu data ni kutoka chanzo kisichoaminika.
- Kuhifadhi executables au class files kwenye external storage kwa ajili ya dynamic loading haipendekeziwi.
- Ikiwa programu yako lazima iupokee faili za executable kutoka external storage, hakikisha faili hizi zimesainiwa na kuthibitishwa kwa njia ya cryptographic kabla ya kuzichomekwa kwa dynamic. Hatua hii ni lazima kwa kudumisha uadilifu wa usalama wa programu yako.

External storage inaweza kupatikana katika /storage/emulated/0 , /sdcard , /mnt/sdcard

> [!TIP]
> Kuanzia Android 4.4 (**API 17**), SD card ina muundo wa saraka unaopunguza ufikiaji kutoka kwa app hadi saraka ambayo ni mahsusi kwa app hiyo. Hii inaizuia malicious application kupata ufikiaji wa kusoma au kuandika kwenye faili za programu nyingine.

Sensitive data stored in clear-text

- **Shared preferences**: Android inaruhusu kila application kuhifadhi kwa urahisi faili za xml katika njia `/data/data/<packagename>/shared_prefs/` na wakati mwingine inawezekana kupata taarifa nyeti kwa clear-text katika saraka hiyo.
- **Databases**: Android inaruhusu kila application kuhifadhi kwa urahisi database za sqlite katika njia `/data/data/<packagename>/databases/` na wakati mwingine inawezekana kupata taarifa nyeti kwa clear-text katika saraka hiyo.

### TLS Iliyovunjika

**Accept All Certificates**

Kwa sababu fulani wakati mwingine waendelezaji wanakubali certificates zote hata kama kwa mfano hostname haifanani na mistari ya msimbo kama ifuatayo:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Njia nzuri ya kujaribu hili ni kujaribu kushika traffic kwa kutumia proxy kama Burp bila ku-authorise Burp CA ndani ya kifaa. Pia, unaweza kuunda kwa Burp certificate kwa hostname tofauti na kuitumia.

### Broken Cryptography

**Poor Key Management Processes**

Wengine waendelezaji huhifadhi data nyeti kwenye local storage na kuificha kwa kutumia key iliyowekwa/kutabirika ndani ya code. Hii haipaswi kufanywa kwani reverse engineering inaweza kumruhusu mshambuliaji kutoa taarifa za siri.

**Use of Insecure and/or Deprecated Algorithms**

Waendelezaji hawapaswi kutumia **deprecated algorithms** kufanya **authorisation checks**, **store** au **send** data. Baadhi ya algorithms hizi ni: RC4, MD4, MD5, SHA1... Ikiwa **hashes** zinatumiwa kuhifadhi password kwa mfano, hashes zinazostahimili **brute-force** zinapaswa kutumiwa pamoja na salt.

### Other checks

- Inashauriwa **obfuscate the APK** ili kuifanya kazi ya reverse engineer kuwa ngumu kwa attackers.
- Ikiwa app ni nyeti (kama app za benki), inapaswa kufanya **own checks to see if the mobile is rooted** na kuchukua hatua kwa mujibu wa matokeo.
- Ikiwa app ni nyeti (kama app za benki), inapaswa kukagua ikiwa **emulator** inatumiwa.
- Ikiwa app ni nyeti (kama app za benki), inapaswa **check it's own integrity before executing** ili kuona kama ilibadilishwa.
- Tumia [**APKiD**](https://github.com/rednaga/APKiD) kuona compiler/packer/obfuscator iliyotumika kujenga APK

### React Native Application

Soma ukurasa ufuatao ili kujifunza jinsi ya kufikia kwa urahisi javascript code za React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Soma ukurasa ufuatao ili kujifunza jinsi ya kufikia kwa urahisi C# code za xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

Kama ilivyoelezwa katika huu [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked ni algorithm ya Meta inayosqueeze content ya application kwenye file moja. Blogu inazungumzia uwezekano wa kuunda app inayodecompress aina hizi za apps... na njia ya haraka ambayo inahusisha **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

Tool ya [**mariana-trench**](https://github.com/facebook/mariana-trench) ina uwezo wa kupata **vulnerabilities** kwa **scanning** **code** ya application. Tool hii ina mfululizo wa **known sources** (zinazoonyesha kwa tool **places** ambapo **input** inadhibitiwa na user), **sinks** (zinazoonyesha kwa tool **dangerous** **places** ambapo malicious user input inaweza kusababisha uharibifu) na **rules**. Rules hizi zinaonyesha **combination** ya **sources-sinks** ambayo inaonyesha vulnerability.

Kwa maarifa haya, **mariana-trench itapitia code na kupata vulnerabilities zinazowezekana ndani yake**.

### Secrets leaked

Application inaweza kuwa na secrets (API keys, passwords, hidden urls, subdomains...) ndani yake ambazo unaweza kuwa na uwezo wa kugundua. Unaweza kutumia tool kama [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)
- In-memory native code execution via JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> Kwanza kabisa, unahitaji environment ambapo unaweza kusanidi application na mazingira yote (Burp CA cert, Drozer and Frida kwa ujumla). Kwa hivyo, kifaa kilicho rooted (emulated au sio) kinapendekezwa sana.

### Online Dynamic analysis

Unaweza kuunda **free account** katika: [https://appetize.io/](https://appetize.io). Jukwaa hili linakuwezesha **upload** na **execute** APKs, hivyo ni muhimu kuona jinsi apk inavyo behave.

Unaweza hata **see the logs of your application** kwenye web na kuunganishwa kupitia **adb**.

![](<../../images/image (831).png>)

Shukrani kwa ADB connection unaweza kutumia **Drozer** na **Frida** ndani ya emulators.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (Unaweza kuunda **x86** na **arm** devices, na kwa mujibu wa [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** versions **support ARM libraries** bila ya kuhitaji emulator ya polepole ya arm).
- Jifunze jinsi ya kuiweka kwenye ukurasa huu:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, unahitaji kuunda account. _Inapendekezwa **download** version **WITH**_ _**VirtualBox** ili kuepuka makosa yanayoweza kutokea._)
- [**Nox**](https://es.bignox.com) (Free, lakini haitoi support kwa Frida au Drozer).

> [!TIP]
> Unapotengeneza emulator mpya kwenye platform yoyote kumbuka kuwa skrini kubwa zaidi inafanya emulator kuwa polepole. Kwa hivyo chagua skrini ndogo inapowezekana.

Ili **install google services** (kama AppStore) kwenye Genymotion unahitaji kubofya kitufe kilicho alama nyekundu kwenye picha ifuatayo:

![](<../../images/image (277).png>)

Pia, kumbuka kuwa kwenye **configuration ya Android VM katika Genymotion** unaweza kuchagua **Bridge Network mode** (hii itakuwa muhimu ikiwa utakuwa unajiunga na Android VM kutoka VM tofauti yenye tools).

#### Use a physical device

Unahitaji kuwasha **debugging** options na itakuwa vizuri ikiwa unaweza kuin root:

1. **Settings**.
2. (FromAndroid 8.0) Chagua **System**.
3. Chagua **About phone**.
4. Bonyeza **Build number** mara 7.
5. Rudi nyuma na utapata **Developer options**.

> Mara baada ya kufunga application, jambo la kwanza unalopaswa kufanya ni kujaribu na kuchunguza inafanya nini, jinsi inavyofanya kazi na kujiridhisha nayo.\
> Napendekeza **perform this initial dynamic analysis using MobSF dynamic analysis + pidcat**, ili tuweze **learn how the application works** wakati MobSF **captures** data nyingi **interesting** unazoweza kupitia baadaye.

Magisk/Zygisk quick notes (recommended on Pixel devices)
- Patch boot.img with the Magisk app and flash via fastboot to get systemless root
- Enable Zygisk + DenyList for root hiding; consider LSPosed/Shamiko when stronger hiding is required
- Keep original boot.img to recover from OTA updates; re-patch after each OTA
- For screen mirroring, use scrcpy on the host



### Unintended Data Leakage

**Logging**

Waendelezaji wanapaswa kuwa waangalifu kuepuka kuf expose **debugging information** hadharani, kwani inaweza kusababisha data nyeti ku-leak. Tools [**pidcat**](https://github.com/JakeWharton/pidcat) na `adb logcat` zinapendekezwa kwa monitoring application logs ili kubaini na kulinda taarifa nyeti. **Pidcat** inapendelewa kwa urahisi wake wa matumizi na readable output.

> [!WARNING]
> Kumbuka kuwa tangu **later newer than Android 4.0**, **applications are only able to access their own logs**. Hivyo applications hawawezi kufikia logs za apps nyingine.\
> Hata hivyo, bado inashauriwa **not log sensitive information**.

**Copy/Paste Buffer Caching**

Android's **clipboard-based** framework inaruhusu copy-paste katika apps, lakini inaleta hatari kwani **other applications** zinaweza **access** clipboard, na hivyo kuweza ku-expose taarifa nyeti. Ni muhimu **disable copy/paste** functions kwa sehemu nyeti za application, kama maelezo ya kadi za benki, ili kuzuia data ku-leak.

**Crash Logs**

Ikiwa application **crashes** na **saves logs**, logs hizi zinaweza kumsaidia mshambuliaji, hasa wakati application haiwezi ku-reverse-engineered. Ili kupunguza hatari hii, epuka logging wakati wa crashes, na ikiwa logs lazima zitumwe mtandaoni, hakikisha zinasafirishwa kupitia channel ya SSL kwa usalama.

Kama pentester, **try to take a look to these logs**.

**Analytics Data Sent To 3rd Parties**

Applications mara nyingi hujumuisha services kama Google Adsense, ambazo kwa kushindwa kutekelezwa vizuri na waendelezaji zinaweza kwa bahati mbaya ku-leak data nyeti. Ili kubaini potential data leaks, inashauriwa **intercept the application's traffic** na kuangalia kama kuna taarifa nyeti zinatumwa kwa third-party services.

### SQLite DBs

Wengi wa applications watatumia **internal SQLite databases** kuhifadhi taarifa. Wakati wa pentest angalia **databases** zilizoundwa, majina ya **tables** na **columns** na data zote zilizohifadhiwa kwa sababu unaweza kupata **sensitive information** (ambayo itakuwa vulnerability).\
Databases zinapaswa kuwa kwenye `/data/data/the.package.name/databases` kama `/data/data/com.mwr.example.sieve/databases`

Ikiwa database inahifadhi taarifa za siri na ime-**encrypted** lakini unaweza **find** password ndani ya application bado ni **vulnerability**.

Gundua tables kwa kutumia `.tables` na gundua columns za table kwa kutumia `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

Kutoka [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** inakuwezesha **assume the role of an Android app** na kuingiliana na apps nyingine. Inaweza kufanya **anything that an installed application can do**, kama kutumia Android’s Inter-Process Communication (IPC) mechanism na kuingiliana na operating system iliyopo chini. .\
Drozer ni tool yenye umuhimu katika **exploit exported activities, exported services and Content Providers** kama utakavyojifunza katika sehemu zifuatazo.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Kumbuka pia kwamba code ya activity inaanza katika method ya **`onCreate`**.

**Authorisation bypass**

Wakati Activity ime-exported unaweza kuitisha screen yake kutoka app ya nje. Kwa hivyo, ikiwa activity yenye **sensitive information** ime-exported unaweza **bypass** **authentication** mechanisms ili kuifikia.

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

Unaweza pia kuanzisha exported activity kutoka adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF itagundua matumizi ya _**singleTask/singleInstance**_ kama `android:launchMode` katika activity kuwa malicious, lakini kutokana na [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), inaonekana hili ni hatari tu kwenye toleo za zamani (API versions < 21).

> [!TIP]
> Kumbuka kwamba an authorisation bypass sio kila mara vulnerability; itategemea jinsi bypass inavyofanya kazi na ni taarifa gani zimefunuliwa.

**Sensitive information leakage**

**Activities can also return results**. Ikiwa utaweza kupata activity iliyokuwa exported na isiyolindwa inayoitisha method ya **`setResult`** na **kurudisha taarifa nyeti**, kuna sensitive information leakage.

#### Tapjacking

Ikiwa Tapjacking haizuiziwi, unaweza kutumia activity iliyosafirishwa kuwalazimisha **watumiaji kufanya vitendo visivyotarajiwa**. Kwa habari zaidi kuhusu [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Kufikia na kusimamia taarifa nyeti

[**Soma hii ikiwa unataka kukumbusha ni nini Content Provider.**](android-applications-basics.md#content-provider)\
Content providers kwa kawaida hutumika **kushiriki data**. Ikiwa app ina content providers zinazopatikana unaweza kuwa na uwezo wa **kutoa data nyeti** kutoka kwao. Pia ni muhimu kujaribu uwezekano wa **SQL injections** na **Path Traversals** kwa sababu zinaweza kuwa zinazo udhaifu.

[**Jifunze jinsi ya ku-exploit Content Providers kwa kutumia Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Soma hii ikiwa unataka kukumbusha ni Service gani.**](android-applications-basics.md#services)\
Kumbuka kwamba vitendo vya Service huanza kwenye method `onStartCommand`.

Service kwa msingi ni kitu kinachoweza **kupokea data**, **kuchakata** na **kurudisha** (au la) majibu. Kwa hiyo, ikiwa application ina services zilizoorodheshwa (exported), unapaswa **kagua** **code** ili uelewe inafanya nini na kuzijaribu kwa wakati wa utekelezaji (dynamically) ili kupata taarifa za siri, kupitisha hatua za uthibitishaji...\
[**Jifunze jinsi ya ku-exploit Services kwa kutumia Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Soma hii ikiwa unataka kukumbusha ni Broadcast Receiver gani.**](android-applications-basics.md#broadcast-receivers)\
Kumbuka kwamba vitendo vya Broadcast Receiver huanza kwenye method `onReceive`.

Broadcast receiver itasubiri aina ya ujumbe. Kulingana na jinsi receiver inavyoshughulikia ujumbe inaweza kuwa dhaifu.\
[**Jifunze jinsi ya ku-exploit Broadcast Receivers kwa kutumia Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Unaweza kutafuta deep links kwa mikono, ukitumia zana kama MobSF au scripts kama [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Unaweza **open** scheme iliyotangazwa kwa kutumia **adb** au **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Kumbuka kwamba unaweza **kuacha package name** na simu itaitisha app ambayo inapaswa kufungua link hiyo moja kwa moja._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Msimbo unaotekelezwa**

Ili kupata **msimbo unaotekelezwa katika App**, nenda kwenye activity inayoitwa na deeplink na tafuta function **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Taarifa nyeti**

Kila unapopata deep link hakikisha kuwa **hairipokei data nyeti (kama nywila) kupitia vigezo vya URL**, kwa sababu programu nyingine yoyote inaweza **kuiga deep link na kuiba data hiyo!**

**Parameters in path**

Pia **lazima uhakikishe kama deep link inatumia parameter ndani ya path** ya URL kama: `https://api.example.com/v1/users/{username}`, katika kesi hiyo unaweza kulazimisha path traversal kwa kufikia kitu kama: `example://app/users?username=../../unwanted-endpoint%3fparam=value`.\
Kumbuka kwamba ukipata endpoints sahihi ndani ya application unaweza kusababisha **Open Redirect** (ikiwa sehemu ya path inatumika kama domain name), **account takeover** (ikiwa unaweza kubadilisha maelezo ya watumiaji bila CSRF token na endpoint yenye uharibifu ilitumia method sahihi) na udhaifu mwingine wowote. More [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Transport Layer Inspection and Verification Failures

- **Certificates hazikaguliwi kila mara ipasavyo** na applications za Android. Ni kawaida kwa applications hizi kupuuza onyo na kukubali self-signed certificates au, katika baadhi ya matukio, kurudi kutumia muunganisho wa HTTP.
- **Mizungumzo wakati wa SSL/TLS handshake mara nyingine ni dhaifu**, zikitumia insecure cipher suites. Udhaifu huu unaifanya connection iwe nyeti kwa man-in-the-middle (MITM) attacks, ukiruhusu washambuliaji ku-decrypt data.
- **Leakage of private information** ni hatari wakati applications zinathibitisha kwa kutumia channels salama lakini kisha zinawasiliana kwa channels zisizo salama kwa shughuli nyingine. Mbinu hii inashindwa kulinda data nyeti, kama session cookies au maelezo ya mtumiaji, dhidi ya interception na wahalifu.

#### Certificate Verification

Tutazingatia **certificate verification**. Uadilifu wa certificate ya server lazima uthibitishwe ili kuongeza usalama. Hii ni muhimu kwa sababu TLS konfigurations zisizo salama na upeleka wa data nyeti kupitia channels zisizo encrypt zinaweza kusababisha hatari kubwa. Kwa hatua za kina kuhusu uthibitishaji wa certificate za server na kutatua udhaifu, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) inatoa mwongozo kamili.

#### SSL Pinning

SSL Pinning ni kipimo cha usalama ambapo application inathibitisha certificate ya server dhidi ya nakala inayojulikana iliyohifadhiwa ndani ya application yenyewe. Njia hii ni muhimu kwa kuzuia MITM attacks. Kutekeleza SSL Pinning kunashauriwa kwa nguvu kwa applications zinazoendesha taarifa nyeti.

#### Traffic Inspection

Ili kuchunguza trafiki ya HTTP, ni lazima **uinstall certificate ya proxy tool** (mf., Burp). Bila kuinstall certificate hii, trafiki iliyofichwa inaweza isiweonekana kupitia proxy. Kwa mwongozo kuhusu jinsi ya kuinstall CA certificate maalum, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Applications zinazolenga **API Level 24 and above** zinahitaji mabadiliko katika Network Security Config ili kukubali CA certificate ya proxy. Hatua hii ni muhimu kwa kuchunguza trafiki iliyofichwa. Kwa maelekezo juu ya kubadilisha Network Security Config, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

If **Flutter** is being used you need to to follow the instructions in [**this page**](flutter.md). Hii ni kwa sababu, kuweka tu certificate kwenye store haitafanyi kazi kwa sababu Flutter ina orodha yake ya CA halali.

#### Static detection of SSL/TLS pinning

Kabla ya kujaribu runtime bypasses, chora haraka maeneo ambapo pinning inatekelezwa ndani ya APK. Static discovery inakusaidia kupanga hooks/patches na kuzingatia code paths sahihi.

Tool: SSLPinDetect
- Open-source static-analysis utility that decompiles the APK to Smali (via apktool) and scans for curated regex patterns of SSL/TLS pinning implementations.
- Reports exact file path, line number, and a code snippet for each match.
- Covers common frameworks and custom code paths: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Matumizi
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Mfano wa sheria za muundo (JSON)
Tumia au ongeza signatures ili kugundua proprietary/custom pinning styles. Unaweza kupakia JSON yako mwenyewe na kuendesha skani kwa wingi.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Vidokezo na ushauri
- Kuchunguza apps kubwa kwa haraka kupitia multi-threading na memory-mapped I/O; pre-compiled regex hupunguza overhead/false positives.
- Mkusanyo wa pattern: https://github.com/aancw/smali-sslpin-patterns
- Malengo ya kawaida ya utambuzi kwa kuchunguza zifuatazo:
- OkHttp: matumizi ya CertificatePinner, setCertificatePinner, marejeo ya package okhttp3/okhttp
- TrustManagers maalum: javax.net.ssl.X509TrustManager, overrides za checkServerTrusted
- SSL contexts maalum: SSLContext.getInstance + SSLContext.init na custom managers
- Declarative pins katika res/xml network security config na marejeo katika manifest
- Tumia maeneo yaliyolingana kupanga Frida hooks, static patches, au mapitio ya config kabla ya dynamic testing.

#### Kuiepuka SSL Pinning

Wakati SSL Pinning imetekelezwa, kuiepuka kunakuwa muhimu ili kuchunguza traffic ya HTTPS. Mbinu mbalimbali zinapatikana kwa ajili ya hili:

- Kiotomatiki **badili** the **apk** ili **kuiepuka** SSLPinning kwa kutumia [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Faida kuu ya chaguo hili ni kwamba hautahitaji root kuiepuka SSL Pinning, lakini utahitaji kufuta application na kuiweka upya, na hii haitafanya kazi kila mara.
- Unaweza kutumia **Frida** (itajadiliwa hapa chini) kuiepuka ulinzi huu. Hapa kuna mwongozo kutumia Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Unaweza pia kujaribu **kuiepuka SSL Pinning kiotomatiki** kwa kutumia [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Unaweza pia kujaribu **kuiepuka SSL Pinning kiotomatiki** kwa kutumia **MobSF dynamic analysis** (imefafanuliwa hapa chini)
- Ikiwa bado unadhani kuna traffic ambayo hawaitoshi, unaweza kujaribu **kupeleka traffic kwa Burp kwa kutumia iptables**. Soma blogu hii: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Kutafuta Common Web Vulnerabilities

Ni muhimu pia kutafuta common web vulnerabilities ndani ya application. Maelezo ya kina juu ya kutambua na kupunguza vulnerabilities hizi yatalenga zaidi kuliko muhtasari huu lakini yameelezewa kwa kina sehemu nyingine.

### Frida

[Frida](https://www.frida.re) ni toolkit ya dynamic instrumentation kwa developers, reverse-engineers, na security researchers.\
**Unaweza kufikia application inayofanya kazi na hook methods wakati wa run time kubadilisha tabia, badilisha values, extract values, run different code...**\
Ikiwa unataka pentest Android applications lazima ujue jinsi ya kutumia Frida.

- Jifunze jinsi ya kutumia Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Baadhi ya "GUI" kwa vitendo na Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection ni nzuri kuendesha matumizi ya Frida kiotomatiki: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Unaweza kupata baadhi ya Awesome Frida scripts hapa: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Jaribu kuiepuka anti-debugging / anti-frida mechanisms kwa kuingiza Frida kama ilivyoonyeshwa katika [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

Angalia kama application inahifadhi taarifa nyeti ndani ya memory ambazo haipaswi kuhifadhi, kama passwords au mnemonics.

Kwa kutumia [**Fridump3**](https://github.com/rootbsd/fridump3) unaweza dump memory ya app kwa:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Hii itatoa kumbukumbu kwenye folda ./dump; ndani yake unaweza kutumia grep kwa kitu kama:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Taarifa nyeti kwenye Keystore**

Katika Android Keystore ni mahali bora pa kuhifadhi taarifa nyeti, hata hivyo, kwa idhini za kutosha bado **inawezekana kuipata**. Kwa kuwa apps huweka hapa mara nyingi **sensitive data in clear text** pentests zinapaswa kuangalia hili kama root user, au mtu mwenye ufikiaji wa kimwili wa kifaa anaweza kuiba data hii.

Hata kama app imehifadhi data katika Keystore, data hiyo inapaswa kuwa imefungwa (encrypted).

Ili kupata data ndani ya keystore unaweza kutumia Frida script hii: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Kutumia Frida script ifuatayo inaweza kuwa inawezekana **bypass fingerprint authentication** ambayo programu za Android zinaweza kuwa zikifanya ili **kulinda maeneo fulani nyeti:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Picha za Mandharinyuma**

Unapoweka programu nyuma, Android huhifadhi **snapshot ya programu** ili inaporejeshwa mbele ianze kupakia picha kabla ya programu, hivyo inaonekana kama programu ilipakiwa kwa haraka.

Hata hivyo, ikiwa snapshot hii ina **taarifa nyeti**, mtu mwenye ufikiaji wa snapshot anaweza **kuiba taarifa hizo** (kumbuka unahitaji root ili kuifikia).

Snapshots kwa kawaida huhifadhiwa katika: **`/data/system_ce/0/snapshots`**

Android inatoa njia ya **kuzuia screenshot kwa kuweka parametro ya layout FLAG_SECURE**. Kwa kutumia flag hii, yaliyomo kwenye dirisha yanachukuliwa kuwa salama, hivyo kuzuia kuonekana kwenye screenshots au kuonyeshwa kwenye displays zisizo salama.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Kichanganuzi cha Programu za Android**

Kifaa hiki kinaweza kukusaidia kusimamia zana tofauti wakati wa uchambuzi wa dynamic: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Waendelezaji mara nyingi huunda components za proxy kama activities, services, na broadcast receivers zinazoshughulikia Intents hizi na kuzipitisha kwa methods kama `startActivity(...)` au `sendBroadcast(...)`, jambo ambalo linaweza kuwa hatari.

Hatari iko katika kuruhusu washambuliaji kuanzisha app components zisizo-exported au kupata content providers nyeti kwa kupindisha Intents hizi. Mfano unaovutia ni component ya `WebView` kubadilisha URLs kuwa vitu vya `Intent` kupitia `Intent.parseUri(...)` kisha kuviendesha, jambo ambalo linaweza kusababisha Intent injections za mhalifu.

### Mambo Muhimu ya Kumbuka

- **Intent Injection** ni sawa na tatizo la Open Redirect kwenye web.
- Matumizi ya udhaifu yanajumuisha kupitisha vitu vya `Intent` kama extras, ambavyo yanaweza kuelekezwa upya kutekeleza operesheni zisizo salama.
- Inaweza kufichua components zisizo-exported na content providers kwa washambuliaji.
- Ubadilishaji wa URL kuwa `Intent` katika `WebView` unaweza kuwezesha vitendo visivyotarajiwa.

### Android Client Side Injections and others

Huenda unafahamu aina hizi za udhaifu kutoka kwenye Web. Lazima uwe makini hasa na udhaifu huu katika programu ya Android:

- **SQL Injection:** Unapotumia queries za dynamic au Content-Providers hakikisha unatumia parameterized queries.
- **JavaScript Injection (XSS):** Hakikisha kwamba support ya JavaScript na Plugin imezimwa kwa WebViews yoyote (imezimwa kwa default). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews zinapaswa kuwa na access kwa file system imezimwa (imewezeshwa kwa default) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: Katika matukio kadhaa, programu ya android inapomaliza session cookie haifutwi au inaweza hata kuhifadhiwa kwenye diski
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Uchambuzi Otomatiki

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Uchambuzi statiki**

![](<../../images/image (866).png>)

**Tathmini ya udhaifu ya programu** kwa kutumia frontend nzuri ya web. Pia unaweza kufanya uchambuzi wa dynamic (lakini unahitaji kuandaa mazingira).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Maombi ya Windows lazima yachunguzwe kutoka kwa MobSF iliyosakinishwa kwenye Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Assisted Dynamic analysis with MobSF

**MobSF** can also be very helpful for **dynamic analysis** in **Android**, but in that case you will need to install MobSF and **genymotion** in your host (a VM or Docker won't work). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
The **MobSF dynamic analyser** can:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). Hili lote hufanywa kiotomatiki isipokuwa kwa screenshots — unahitaji kubonyeza unapotaka screenshot au kubonyeza "**Exported Activity Tester**" kupata screenshots za exported activities zote.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: Itataja loaded classes zote
- **Capture Strings**: Itachapisha capture strings zote unapotumia application (inasababisha noise nyingi)
- **Capture String Comparisons**: Inaweza kuwa muhimu sana. Itaonyesha the 2 strings being compared na kama matokeo yalikuwa True au False.
- **Enumerate Class Methods**: Weka jina la class (kama "java.io.File") na itachapisha methods zote za class hiyo.
- **Search Class Pattern**: Tafuta classes kwa pattern
- **Trace Class Methods**: Trace whole class (ona inputs na outputs za methods zote za class). Kumbuka kuwa kwa default MobSF inatTrace methods kadhaa za kuvutia za Android Api.

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf pia inakuja na shell yenye baadhi ya amri za **adb**, **MobSF commands**, na amri za **shell** za kawaida chini ya ukurasa wa dynamic analysis. Some interesting commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**Zana za HTTP**

Wakati trafiki ya HTTP inapokamatwa unaweza kuona muonekano mbaya wa trafiki iliyokamatwa kwenye butoni ya chini "**HTTP(S) Traffic**" au muonekano mzuri kwenye butoni ya kijani "**Start HTTPTools**". Kutoka kwa chaguo la pili, unaweza **tuma** **maombi yaliyokamatwa** kwa **proxies** kama Burp au Owasp ZAP.\
Ili kufanya hivyo, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> press "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Mara utakapo maliza dynamic analysis na MobSF unaweza bonyeza "**Start Web API Fuzzer**" ili **fuzz http requests** na kutafuta vulnerabilities.

> [!TIP]
> Baada ya kufanya dynamic analysis na MobSF, proxy settings zinaweza kuwa zimebadilishwa vibaya na huwezi kuzirekebisha kutoka GUI. Unaweza kurekebisha proxy settings kwa kufanya:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Uchanganuzi wa Dynamic uliosaidiwa na Inspeckage

Unaweza kupata zana kutoka [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Zana hii itatumia baadhi ya **Hooks** kukufahamisha **kinachotokea katika application** wakati unafanya **dynamic analysis**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Hii ni **zana nzuri ya kufanya static analysis kwa GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Zana hii imeundwa kutafuta baadhi ya **security related Android application vulnerabilities**, ama katika **source code** au **packaged APKs**. Zana pia ina uwezo wa kuunda **"Proof-of-Concept" deployable APK** na **ADB commands**, ili ku-exploit baadhi ya vulnerabilities zilizopatikana (Exposed activities, intents, tapjacking...). Kama ilivyo kwa Drozer, hakuna haja ya root test device.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Inaonyesha faili zote zilizoo ndolewa kwa marejeo rahisi
- Inafanya decompile moja kwa moja faili za APK hadi kwa Java na muundo wa Smali
- Huchambua AndroidManifest.xml kwa udhaifu na tabia za kawaida
- Uchambuzi wa static wa source code kwa ajili ya udhaifu na tabia za kawaida
- Taarifa za kifaa
- na zaidi
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER ni programu ya command-line inayoweza kutumika kwenye Windows, MacOS X na Linux, inayochambua faili za _.apk_ kutafuta vulnerabilities. Hii hufanywa kwa kuzipakua APKs na kutumia mfululizo wa rules ili kugundua vulnerabilities hizo.

Rules zote ziko katika faili ya `rules.json`, na kila kampuni au mjaribu anaweza kuunda rules zao ili kuchambua wanachohitaji.

Download the latest binaries from in the [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn ni chombo cha **crossplatform** kinachowasaidia waendelezaji, bugbounty hunters na ethical hackers wanaofanya [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) kwa programu za rununu.

Dhana ni kwamba unaburuta na kuuacha faili ya programu yako ya rununu (faili ya .apk au .ipa) kwenye programu ya StaCoAn na itaitengeneza ripoti ya kimuonekano na inayobebeka kwako. Unaweza kubadilisha mipangilio na orodha za maneno ili kupata uzoefu uliobinafsishwa.

Pakua[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework ni mfumo wa uchambuzi wa udhaifu wa Android unaosaidia waendelezaji au hackers kutambua udhaifu za usalama zinazowezekana katika programu za Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** ni zana ambayo lengo lake kuu ni kugundua na kumtahadharisha mtumiaji kuhusu tabia hatarishi zinazoweza kujitokeza katika programu ya Android.

Uchunguzi hufanywa kwa **static analysis** ya Dalvik bytecode ya programu, inayowakilishwa kama **Smali**, kwa kutumia maktaba ya [`androguard`](https://github.com/androguard/androguard).

Zana hii inatafuta **tabia za kawaida za programu "mbaya"** kama: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. Ni zana inayoweka pamoja zana zinazotumika mara kwa mara za mobile application reverse engineering and analysis, kusaidia katika kujaribu mobile applications dhidi ya OWASP mobile security threats. Lengo lake ni kufanya kazi hii iwe rahisi na rafiki kwa watengenezaji wa mobile applications na wataalamu wa usalama.

Ina uwezo wa:

- Kutoa Java na Smali code kwa kutumia zana mbalimbali
- Chunguza APKs kwa kutumia: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Kutoa taarifa binafsi kutoka APK kwa kutumia regexps.
- Chunguza Manifest.
- Chunguza domains zilizopatikana kwa kutumia: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com]

### Koodous

Inayotumika kugundua malware: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Kumbuka kwamba, kulingana na huduma na usanidi utakaoitumia kuobfuscate the code, Secrets zinaweza au zisiwe obfuscated.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

Kutoka [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** ni zana ya open source ya command-line inayopunguza, inaboresha na obfuscates Java code. Ina uwezo wa optimize bytecode pamoja na kugundua na kuondoa instructions zisizotumika. ProGuard ni free software na inasambazwa chini ya GNU General Public License, version 2.

ProGuard inatolewa kama sehemu ya Android SDK na inakimbia wakati wa kujenga application katika release mode.

### [DexGuard](https://www.guardsquare.com/dexguard)

Pata mwongozo wa hatua kwa hatua wa ku-deobfuscate the apk kwenye [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(Kutoka kwenye mwongozo huo) Mara ya mwisho tuliyokagua, Dexguard mode of operation ilikuwa:

- pakia resource kama InputStream;
- impatie matokeo class inayorithi kutoka FilterInputStream ili ku-decrypt;
- fanya obfuscation isiyo na maana ili kumchukua dakika chache mkariri;
- impatie matokeo yaliyofichuliwa ZipInputStream ili kupata faili ya DEX;
- hatimaye pakia DEX iliyopatikana kama Resource ukitumia method `loadDex`.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

Unaweza kupakia obfuscated APK kwenye jukwaa lao.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

Hii ni zana ya LLM ya kutafuta potential security vulnerabilities katika android apps na deobfuscate android app code. Inatumia Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

Ni generic android deobfuscator. Simplify virtually executes an app kuelewa tabia yake kisha inajaribu optimize the code ili iendelee kufanya kazi kwa utendaji uleule lakini iwe rahisi kwa binadamu kuelewa. Kila aina ya optimization ni rahisi na generic, hivyo haijalishi aina maalum ya obfuscation inayotumika.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD inakupa taarifa kuhusu how an APK was made. Inatambua compilers, packers, obfuscators, na vitu vingine vya ajabu. Ni [_PEiD_](https://www.aldeid.com/wiki/PEiD) kwa Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Maabara

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b ni Android security virtual machine iliyotegemea ubuntu-mate, inajumuisha mkusanyiko wa latest frameworks, tutorials na labs kutoka kwa wapenzi na watafiti wa usalama kwa ajili ya reverse engineering na malware analysis.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Ni orodha nzuri ya rasilimali
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
