# Android Applications Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android Applications Basics

このページを読むことを強くお勧めします。**Androidのセキュリティに関連する最も重要な部分と、Androidアプリケーションの最も危険なコンポーネント**について知るためです：

{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

これは、Androidデバイス（エミュレートされたものまたは物理的なもの）に接続するために必要な主なツールです。\
**ADB**は、コンピュータから**USB**または**ネットワーク**経由でデバイスを制御することを可能にします。このユーティリティは、**ファイルのコピー**、**アプリのインストール**と**アンインストール**、**シェルコマンドの実行**、**データのバックアップ**、**ログの読み取り**など、さまざまな機能を提供します。

以下のリストの[**ADB Commands**](adb-commands.md)を確認して、adbの使い方を学んでください。

## Smali

時には、**隠された情報**（おそらくよく難読化されたパスワードやフラグ）にアクセスするために、**アプリケーションコードを修正する**ことが興味深い場合があります。そのため、apkを逆コンパイルし、コードを修正して再コンパイルすることが興味深いかもしれません。\
[**このチュートリアルでは、APKを逆コンパイルし、Smaliコードを修正して、新しい機能を持つAPKを再コンパイルする方法を学ぶことができます**](smali-changes.md)。これは、**動的分析中に提示されるいくつかのテストの代替手段として非常に役立つ**可能性があります。したがって、**この可能性を常に念頭に置いておいてください**。

## Other interesting tricks

- [Play Storeでの位置情報の偽装](spoofing-your-location-in-play-store.md)
- **APKのダウンロード**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- デバイスからAPKを抽出:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- [APKEditor](https://github.com/REAndroid/APKEditor)を使用して、すべてのスプリットとベースAPKをマージします:
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## 静的分析

まず、APKを分析するためには、**デコンパイラを使用してJavaコードを確認する必要があります**。\
詳細な情報については、[**こちらをお読みください。さまざまなデコンパイラについての情報があります**](apk-decompilers.md)。

### 興味深い情報の探索

APKの**文字列**を確認するだけで、**パスワード**、**URL** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep))、**API**キー、**暗号化**、**Bluetooth UUID**、**トークン**、およびその他の興味深いものを検索できます... コード実行の**バックドア**や認証バックドア（アプリへのハードコーディングされた管理者資格情報）も探してください。

**Firebase**

**FirebaseのURL**に特に注意を払い、設定が不適切でないか確認してください。[Firebaseとは何か、どのように悪用するかについての詳細情報はこちら。](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### アプリケーションの基本理解 - Manifest.xml, strings.xml

アプリケーションの**\_Manifest.xml**_\*\*および\*\*_**strings.xml**\_\*\*ファイルの**検査は、潜在的なセキュリティ脆弱性を明らかにすることができます\*\***。これらのファイルは、デコンパイラを使用するか、APKファイルの拡張子を.zipに変更してから解凍することでアクセスできます。

**Manifest.xml**から特定された**脆弱性**には以下が含まれます：

- **デバッグ可能なアプリケーション**: _Manifest.xml_ファイルでデバッグ可能として設定されたアプリケーション（`debuggable="true"`）は、接続を許可するため、悪用のリスクがあります。デバッグ可能なアプリケーションを見つけて悪用する方法については、デバイス上のデバッグ可能なアプリケーションを見つけて悪用するチュートリアルを参照してください。
- **バックアップ設定**: 機密情報を扱うアプリケーションには、`android:allowBackup="false"`属性を明示的に設定して、特にUSBデバッグが有効な場合にadbを介した不正なデータバックアップを防ぐ必要があります。
- **ネットワークセキュリティ**: _res/xml/_内のカスタムネットワークセキュリティ構成（`android:networkSecurityConfig="@xml/network_security_config"`）は、証明書ピンやHTTPトラフィック設定などのセキュリティ詳細を指定できます。特定のドメインに対してHTTPトラフィックを許可することが一例です。
- **エクスポートされたアクティビティとサービス**: マニフェスト内のエクスポートされたアクティビティとサービスを特定することで、悪用される可能性のあるコンポーネントを明らかにできます。動的テスト中のさらなる分析により、これらのコンポーネントを悪用する方法が明らかになる可能性があります。
- **コンテンツプロバイダーとファイルプロバイダー**: 公開されたコンテンツプロバイダーは、不正なアクセスやデータの変更を許可する可能性があります。ファイルプロバイダーの構成も注意深く確認する必要があります。
- **ブロードキャストレシーバーとURLスキーム**: これらのコンポーネントは悪用される可能性があり、特にURLスキームが入力脆弱性に対してどのように管理されているかに注意を払う必要があります。
- **SDKバージョン**: `minSdkVersion`、`targetSDKVersion`、および`maxSdkVersion`属性は、サポートされているAndroidバージョンを示し、セキュリティ上の理由から古い脆弱なAndroidバージョンをサポートしないことの重要性を強調しています。

**strings.xml**ファイルからは、APIキー、カスタムスキーマ、およびその他の開発者ノートなどの機密情報が発見される可能性があり、これらのリソースを注意深くレビューする必要があります。

### タップジャッキング

**タップジャッキング**は、**悪意のある** **アプリケーション**が起動され、**被害者アプリケーションの上に位置する**攻撃です。被害者アプリを視覚的に隠すと、そのユーザーインターフェースはユーザーを騙してそれに対話させるように設計されており、実際には被害者アプリに対してその対話を渡しています。\
実際には、**ユーザーが被害者アプリでアクションを実行していることを知らないようにしています**。

詳細情報は以下を参照してください：

{{#ref}}
tapjacking.md
{{#endref}}

### タスクハイジャック

**`launchMode`**が**`singleTask`**に設定され、`taskAffinity`が定義されていない**アクティビティ**は、タスクハイジャックに対して脆弱です。これは、**アプリケーション**がインストールされ、実際のアプリケーションの前に起動されると、**実際のアプリケーションのタスクをハイジャックする**可能性があることを意味します（つまり、ユーザーは**悪意のあるアプリケーションを使用していると思い込んでいる**）。

詳細情報は以下を参照してください：

{{#ref}}
android-task-hijacking.md
{{#endref}}

### 不安定なデータストレージ

**内部ストレージ**

Androidでは、**内部**ストレージに**保存された**ファイルは、**作成した**アプリのみが**アクセスできる**ように**設計されています**。このセキュリティ対策はAndroidオペレーティングシステムによって**強制され**、ほとんどのアプリケーションのセキュリティニーズには一般的に十分です。しかし、開発者は時折、`MODE_WORLD_READABLE`や`MODE_WORLD_WRITABLE`のようなモードを利用して、ファイルを異なるアプリケーション間で**共有**できるようにします。しかし、これらのモードは、他のアプリケーション（潜在的に悪意のあるものを含む）によるこれらのファイルへのアクセスを**制限しません**。

1. **静的分析:**
- `MODE_WORLD_READABLE`および`MODE_WORLD_WRITABLE`の使用が**注意深く検討されるべきです**。これらのモードは、**意図しないまたは不正なアクセス**にファイルを**さらす可能性があります**。
2. **動的分析:**
- アプリによって作成されたファイルに設定された**権限**を**確認**します。特に、ファイルが**全世界に対して読み取りまたは書き込み可能に設定されているかどうかを確認**します。これは重大なセキュリティリスクを引き起こす可能性があり、デバイスにインストールされた**任意のアプリケーション**が、出所や意図に関係なく、これらのファイルを**読み取ったり変更したり**できるようになります。

**外部ストレージ**

**外部ストレージ**上のファイルを扱う際には、いくつかの注意が必要です：

1. **アクセス可能性**:
- 外部ストレージ上のファイルは**全世界に対して読み取りおよび書き込み可能**です。つまり、任意のアプリケーションやユーザーがこれらのファイルにアクセスできます。
2. **セキュリティの懸念**:
- アクセスの容易さを考慮すると、**機密情報を外部ストレージに保存しないことが推奨されます**。
- 外部ストレージは取り外し可能であり、任意のアプリケーションによってアクセスされる可能性があるため、セキュリティが低下します。
3. **外部ストレージからのデータ処理**:
- 外部ストレージから取得したデータに対しては常に**入力検証を行う**必要があります。これは、データが信頼できないソースからのものであるため、重要です。
- 外部ストレージに実行可能ファイルやクラスファイルを保存して動的に読み込むことは強く推奨されません。
- アプリケーションが外部ストレージから実行可能ファイルを取得する必要がある場合、これらのファイルが**署名され、暗号的に検証されていることを確認**してから動的に読み込む必要があります。このステップは、アプリケーションのセキュリティの整合性を維持するために重要です。

外部ストレージは、`/storage/emulated/0`、`/sdcard`、`/mnt/sdcard`で**アクセス可能**です。

> [!NOTE]
> Android 4.4（**API 17**）以降、SDカードにはディレクトリ構造があり、**アプリが特定のアプリ用のディレクトリにのみアクセスできるように制限されています**。これにより、悪意のあるアプリケーションが他のアプリのファイルに対して読み取りまたは書き込みアクセスを得ることが防止されます。

**平文で保存された機密データ**

- **共有設定**: Androidは各アプリケーションが`/data/data/<packagename>/shared_prefs/`パスにXMLファイルを簡単に保存できるようにしており、そのフォルダ内に平文で機密情報が見つかることがあります。
- **データベース**: Androidは各アプリケーションが`/data/data/<packagename>/databases/`パスにSQLiteデータベースを簡単に保存できるようにしており、そのフォルダ内に平文で機密情報が見つかることがあります。

### 壊れたTLS

**すべての証明書を受け入れる**

何らかの理由で、開発者がホスト名がコードの行と一致しない場合でも、すべての証明書を受け入れることがあります。
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Broken Cryptography

**Poor Key Management Processes**

一部の開発者は、機密データをローカルストレージに保存し、コード内にハードコーディングされた/予測可能なキーで暗号化します。これは、リバースエンジニアリングにより攻撃者が機密情報を抽出できる可能性があるため、行うべきではありません。

**Use of Insecure and/or Deprecated Algorithms**

開発者は、認証チェック、データの保存または送信を行うために**非推奨のアルゴリズム**を使用すべきではありません。これらのアルゴリズムには、RC4、MD4、MD5、SHA1などがあります。たとえば、パスワードを保存するために**ハッシュ**が使用される場合、ソルトを使用したハッシュのブルートフォース耐性が必要です。

### Other checks

- APKを**難読化する**ことを推奨します。これにより、攻撃者のリバースエンジニアリング作業が困難になります。
- アプリが機密性が高い場合（銀行アプリなど）、**モバイルがルート化されているかどうかを確認する独自のチェックを実行**し、適切に対処する必要があります。
- アプリが機密性が高い場合（銀行アプリなど）、**エミュレーター**が使用されているかどうかを確認する必要があります。
- アプリが機密性が高い場合（銀行アプリなど）、**実行前に自身の整合性を確認**し、変更されていないかを確認する必要があります。
- [**APKiD**](https://github.com/rednaga/APKiD)を使用して、APKをビルドするために使用されたコンパイラ/パッカー/難読化ツールを確認します。

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:

{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:

{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

The tool [**mariana-trench**](https://github.com/facebook/mariana-trench) is capable of finding **vulnerabilities** by **scanning** the **code** of the application. This tool contains a series of **known sources** (that indicates to the tool the **places** where the **input** is **controlled by the user**), **sinks** (which indicates to the tool **dangerous** **places** where malicious user input could cause damages) and **rules**. These rules indicates the **combination** of **sources-sinks** that indicates a vulnerability.

With this knowledge, **mariana-trench will review the code and find possible vulnerabilities on it**.

### Secrets leaked

An application may contain secrets (API keys, passwords, hidden urls, subdomains...) inside of it that you might be able to discover. You could us a tool such as [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication

{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)

### **Other tricks**

{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> First of all, you need an environment where you can install the application and all the environment (Burp CA cert, Drozer and Frida mainly). Therefore, a rooted device (emulated or not) is extremely recommended.

### Online Dynamic analysis

You can create a **free account** in: [https://appetize.io/](https://appetize.io). This platform allows you to **upload** and **execute** APKs, so it is useful to see how an apk is behaving.

You can even **see the logs of your application** in the web and connect through **adb**.

![](<../../images/image (831).png>)

Thanks to the ADB connection you can use **Drozer** and **Frida** inside the emulators.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (You can create **x86** and **arm** devices, and according to [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** versions **support ARM libraries** without needing an slow arm emulator).
- Learn to set it up in this page:

{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, you need to create an account. _It's recommend to **download** the version **WITH**_ _**VirtualBox** to avoid potential errors._)
- [**Nox**](https://es.bignox.com) (Free, but it doesn't support Frida or Drozer).

> [!NOTE]
> When creating a new emulator on any platform remember that the bigger the screen is, the slower the emulator will run. So select small screens if possible.

To **install google services** (like AppStore) in Genymotion you need to click on the red marked button of the following image:

![](<../../images/image (277).png>)

Also, notice that in the **configuration of the Android VM in Genymotion** you can select **Bridge Network mode** (this will be useful if you will be connecting to the Android VM from a different VM with the tools).

#### Use a physical device

You need to activate the **debugging** options and it will be cool if you can **root** it:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Once you have installed the application, the first thing you should do is to try it and investigate what does it do, how does it work and get comfortable with it.\
> I will suggest to **perform this initial dynamic analysis using MobSF dynamic analysis + pidcat**, so we will be able to **learn how the application works** while MobSF **captures** a lot of **interesting** **data** you can review later on.

### Unintended Data Leakage

**Logging**

開発者は、**デバッグ情報**を公開することに注意すべきです。これは、機密データの漏洩につながる可能性があります。アプリケーションログを監視して機密情報を特定し保護するために、ツール[**pidcat**](https://github.com/JakeWharton/pidcat)と`adb logcat`を推奨します。**Pidcat**は、その使いやすさと可読性から好まれます。

> [!WARNING]
> **Android 4.0以降**、**アプリケーションは自分のログにのみアクセスできる**ことに注意してください。したがって、アプリケーションは他のアプリのログにアクセスできません。\
> それでも、**機密情報をログに記録しない**ことを推奨します。

**Copy/Paste Buffer Caching**

Androidの**クリップボードベース**のフレームワークは、アプリ内でのコピー＆ペースト機能を可能にしますが、**他のアプリケーション**がクリップボードにアクセスできるため、機密データが漏洩するリスクがあります。クレジットカードの詳細など、アプリケーションの機密セクションでは**コピー/ペースト**機能を無効にすることが重要です。

**Crash Logs**

アプリケーションが**クラッシュ**し、**ログを保存**する場合、これらのログは攻撃者に役立つ可能性があります。特にアプリケーションがリバースエンジニアリングできない場合はそうです。このリスクを軽減するために、クラッシュ時にログを記録しないようにし、ログをネットワーク経由で送信する必要がある場合は、SSLチャネルを介して送信されることを確認してください。

ペンテスターとして、**これらのログを確認することをお勧めします**。

**Analytics Data Sent To 3rd Parties**

アプリケーションは、Google Adsenseなどのサービスを統合することが多く、開発者による不適切な実装により、機密データが**漏洩する**可能性があります。潜在的なデータ漏洩を特定するために、**アプリケーションのトラフィックを傍受し**、第三者サービスに送信される機密情報がないかを確認することをお勧めします。

### SQLite DBs

ほとんどのアプリケーションは、情報を保存するために**内部SQLiteデータベース**を使用します。ペンテスト中に作成された**データベース**、**テーブル**と**カラム**の名前、保存されたすべての**データ**を確認してください。機密情報（脆弱性となる可能性があります）を見つけることができるかもしれません。\
データベースは`/data/data/the.package.name/databases`に位置する必要があります。例えば`/data/data/com.mwr.example.sieve/databases`

データベースが機密情報を保存しており、**暗号化されている**が、アプリケーション内に**パスワード**が見つかる場合、それでも**脆弱性**です。

`.tables`を使用してテーブルを列挙し、`.schema <table_name>`を実行してテーブルのカラムを列挙します。

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer is s useful tool to **exploit exported activities, exported services and Content Providers** as you will learn in the following sections.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Also remember that the code of an activity starts in the **`onCreate`** method.

**Authorisation bypass**

Activityがエクスポートされると、外部アプリからその画面を呼び出すことができます。したがって、**機密情報**を含むActivityが**エクスポート**されている場合、**認証**メカニズムを**バイパス**してアクセスすることができます。

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

You can also start an exported activity from adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**注意**: MobSFは、アクティビティの`android:launchMode`における_**singleTask/singleInstance**_の使用を悪意のあるものとして検出しますが、[これ](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750)によると、これは古いバージョン（APIバージョン<21）でのみ危険なようです。

> [!NOTE]
> 認証バイパスは常に脆弱性ではないことに注意してください。バイパスの動作とどの情報が公開されているかによります。

**機密情報の漏洩**

**アクティビティは結果を返すこともできます**。もし、**`setResult`**メソッドを呼び出し、**機密情報を返す**エクスポートされた保護されていないアクティビティを見つけることができれば、機密情報の漏洩があります。

#### タップジャッキング

タップジャッキングが防止されていない場合、エクスポートされたアクティビティを悪用して**ユーザーに予期しないアクションを実行させる**ことができます。タップジャッキングについての詳細は、[**こちらのリンクを参照してください**](#tapjacking)。

### **コンテンツプロバイダーの悪用 - 機密情報へのアクセスと操作**

[**コンテンツプロバイダーとは何かを再確認したい場合は、こちらをお読みください。**](android-applications-basics.md#content-provider)\
コンテンツプロバイダーは基本的に**データを共有する**ために使用されます。アプリに利用可能なコンテンツプロバイダーがある場合、そこから**機密データを抽出**できるかもしれません。また、**SQLインジェクション**や**パストラバーサル**の可能性をテストすることも興味深いです。これらは脆弱である可能性があります。

[**Drozerを使用してコンテンツプロバイダーを悪用する方法を学びましょう。**](drozer-tutorial/index.html#content-providers)

### **サービスの悪用**

[**サービスとは何かを再確認したい場合は、こちらをお読みください。**](android-applications-basics.md#services)\
サービスのアクションは`onStartCommand`メソッドで開始されることを覚えておいてください。

サービスは基本的に**データを受信**し、**処理**し、**応答**（またはしない）を返すものです。したがって、アプリケーションがいくつかのサービスをエクスポートしている場合は、**コードを確認**して何をしているのかを理解し、**動的にテスト**して機密情報を抽出したり、認証手段をバイパスしたりする必要があります。\
[**Drozerを使用してサービスを悪用する方法を学びましょう。**](drozer-tutorial/index.html#services)

### **ブロードキャストレシーバーの悪用**

[**ブロードキャストレシーバーとは何かを再確認したい場合は、こちらをお読みください。**](android-applications-basics.md#broadcast-receivers)\
ブロードキャストレシーバーのアクションは`onReceive`メソッドで開始されることを覚えておいてください。

ブロードキャストレシーバーは特定のメッセージを待機しています。レシーバーがメッセージをどのように処理するかによって、脆弱性が生じる可能性があります。\
[**Drozerを使用してブロードキャストレシーバーを悪用する方法を学びましょう。**](#exploiting-broadcast-receivers)

### **スキーム/ディープリンクの悪用**

手動でディープリンクを探すことができ、MobSFのようなツールや[このスクリプト](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py)を使用できます。\
**adb**や**ブラウザ**を使用して宣言された**スキーム**を**開く**ことができます:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_パッケージ名を**省略する**ことができ、モバイルは自動的にそのリンクを開くべきアプリを呼び出します。_
```markup
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**実行されるコード**

**アプリで実行されるコード**を見つけるために、ディープリンクによって呼び出されるアクティビティに移動し、関数**`onNewIntent`**を検索します。

![](<../../images/image (436) (1) (1) (1).png>)

**機密情報**

ディープリンクを見つけるたびに、**URLパラメータを介して機密データ（パスワードなど）を受信していないか確認してください**。他のアプリケーションが**ディープリンクを偽装してそのデータを盗む可能性があります！**

**パス内のパラメータ**

**URLのパス内でパラメータを使用しているディープリンクがあるかどうかも確認する必要があります**。例えば、`https://api.example.com/v1/users/{username}` のように。この場合、`example://app/users?username=../../unwanted-endpoint%3fparam=value` のようにパスのトラバーサルを強制することができます。\
アプリケーション内で正しいエンドポイントを見つけた場合、**オープンリダイレクト**（パスの一部がドメイン名として使用される場合）、**アカウント乗っ取り**（CSRFトークンなしでユーザーの詳細を変更でき、脆弱なエンドポイントが正しいメソッドを使用している場合）、およびその他の脆弱性を引き起こす可能性があります。詳細な情報は[こちら](http://dphoeniixx.com/2020/12/13-2/)を参照してください。

**さらなる例**

リンクに関する[興味深いバグバウンティレポート](https://hackerone.com/reports/855618) (_/.well-known/assetlinks.json_)。

### トランスポート層の検査と検証の失敗

- **証明書はAndroidアプリケーションによって常に適切に検査されるわけではありません**。これらのアプリケーションは警告を見落とし、自己署名証明書を受け入れたり、場合によってはHTTP接続に戻ったりすることが一般的です。
- **SSL/TLSハンドシェイク中の交渉は時々弱く**、安全でない暗号スイートを使用しています。この脆弱性により、接続が中間者攻撃（MITM）に対して脆弱になり、攻撃者がデータを復号化できるようになります。
- **プライベート情報の漏洩**は、アプリケーションが安全なチャネルを使用して認証するが、他のトランザクションのために非安全なチャネルで通信する場合にリスクがあります。このアプローチは、セッションクッキーやユーザーの詳細などの機密データを悪意のあるエンティティによる傍受から保護できません。

#### 証明書の検証

**証明書の検証**に焦点を当てます。サーバーの証明書の整合性を確認することは、セキュリティを強化するために重要です。これは、安全でないTLS構成や暗号化されていないチャネルを介して機密データを送信することが重大なリスクをもたらすため、重要です。サーバー証明書の検証と脆弱性への対処に関する詳細な手順は、[**このリソース**](https://manifestsecurity.com/android-application-security-part-10/)で包括的に説明されています。

#### SSLピンニング

SSLピンニングは、アプリケーションがサーバーの証明書をアプリケーション内に保存された既知のコピーと照合するセキュリティ対策です。この方法は、MITM攻撃を防ぐために不可欠です。機密情報を扱うアプリケーションには、SSLピンニングの実装が強く推奨されます。

#### トラフィックの検査

HTTPトラフィックを検査するには、**プロキシツールの証明書をインストールする必要があります**（例：Burp）。この証明書をインストールしないと、暗号化されたトラフィックはプロキシを通じて表示されない可能性があります。カスタムCA証明書のインストールに関するガイドは、[**こちらをクリック**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine)してください。

**APIレベル24以上**をターゲットとするアプリケーションは、プロキシのCA証明書を受け入れるためにネットワークセキュリティ構成を変更する必要があります。このステップは、暗号化されたトラフィックを検査するために重要です。ネットワークセキュリティ構成の変更に関する指示は、[**このチュートリアルを参照**](make-apk-accept-ca-certificate.md)してください。

#### SSLピンニングのバイパス

SSLピンニングが実装されている場合、HTTPSトラフィックを検査するためにそれをバイパスする必要があります。この目的のために利用できるさまざまな方法があります：

- 自動的に**apkを修正**して**SSLピンニングをバイパス**するには、[**apk-mitm**](https://github.com/shroudedcode/apk-mitm)を使用します。このオプションの最大の利点は、SSLピンニングをバイパスするためにrootが必要ないことですが、アプリケーションを削除して新しいものを再インストールする必要があり、これが常に機能するわけではありません。
- **Frida**を使用してこの保護をバイパスすることもできます（以下で説明）。Burp+Frida+Genymotionを使用するためのガイドはこちらです：[https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- **objection**を使用して**SSLピンニングを自動的にバイパス**することも試みることができます：`objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- **MobSF動的分析**を使用して**SSLピンニングを自動的にバイパス**することも試みることができます（以下で説明）。
- まだキャプチャしていないトラフィックがあると思われる場合は、**iptablesを使用してトラフィックをburpに転送**することを試みることができます。このブログを読んでください：[https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### 一般的なWeb脆弱性の検索

アプリケーション内で一般的なWeb脆弱性を検索することも重要です。これらの脆弱性を特定し、軽減するための詳細な情報はこの要約の範囲を超えていますが、他の場所で広範にカバーされています。

### Frida

[Frida](https://www.frida.re)は、開発者、リバースエンジニア、セキュリティ研究者のための動的インスツルメンテーションツールキットです。\
**実行中のアプリケーションにアクセスし、実行時にメソッドをフックして動作を変更したり、値を変更したり、値を抽出したり、異なるコードを実行したりできます...**\
Androidアプリケーションをペンテストするには、Fridaの使い方を知っておく必要があります。

- Fridaの使い方を学ぶ：[**Fridaチュートリアル**](frida-tutorial/)
- Fridaでのアクション用の「GUI」：[**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- OjectionはFridaの使用を自動化するのに最適です：[**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- ここで素晴らしいFridaスクリプトを見つけることができます：[**https://codeshare.frida.re/**](https://codeshare.frida.re)
- [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace)に示されているようにFridaを読み込んで、アンチデバッグ/アンチFridaメカニズムをバイパスすることを試みてください（ツール[linjector](https://github.com/erfur/linjector-rs)）。

### **メモリダンプ - Fridump**

アプリケーションがパスワードやニーモニックのような機密情報を保存していないか確認してください。

[**Fridump3**](https://github.com/rootbsd/fridump3)を使用して、アプリのメモリをダンプできます：
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
これは、./dump フォルダーにメモリをダンプします。そこで、次のように grep できます:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Keystore内の機密データ**

Androidでは、Keystoreは機密データを保存するのに最適な場所ですが、十分な権限があれば**アクセスすることが可能です**。アプリケーションはここに**平文で機密データを保存する傾向があるため**、ペンテストはそれを確認する必要があります。ルートユーザーやデバイスへの物理的アクセスを持つ者がこのデータを盗むことができるかもしれません。

アプリがKeystoreにデータを保存していても、データは暗号化されているべきです。

Keystore内のデータにアクセスするには、このFridaスクリプトを使用できます: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **指紋/生体認証バイパス**

次のFridaスクリプトを使用することで、Androidアプリケーションが特定の機密領域を保護するために実行している**指紋認証をバイパス**することが可能になるかもしれません：
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **バックグラウンド画像**

アプリケーションをバックグラウンドに置くと、Androidはアプリケーションの**スナップショット**を保存します。これにより、フォアグラウンドに復帰したときに、アプリがより早く読み込まれているように見えます。

しかし、このスナップショットに**機密情報**が含まれている場合、スナップショットにアクセスできる誰かがその情報を**盗む**可能性があります（アクセスするにはルート権限が必要です）。

スナップショットは通常、次の場所に保存されます: **`/data/system_ce/0/snapshots`**

Androidは、FLAG_SECUREレイアウトパラメータを設定することで**スクリーンショットのキャプチャを防ぐ**方法を提供します。このフラグを使用すると、ウィンドウの内容は安全と見なされ、スクリーンショットに表示されたり、非安全なディスプレイで表示されたりすることを防ぎます。
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

このツールは、動的分析中に異なるツールを管理するのに役立ちます: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

開発者は、これらのインテントを処理し、`startActivity(...)`や`sendBroadcast(...)`などのメソッドに渡すプロキシコンポーネント（アクティビティ、サービス、ブロードキャストレシーバーなど）を作成することがよくありますが、これはリスクを伴います。

危険は、攻撃者がこれらのインテントを誤って誘導することによって、非エクスポートアプリコンポーネントをトリガーしたり、機密コンテンツプロバイダーにアクセスしたりできることにあります。注目すべき例は、`WebView`コンポーネントがURLを`Intent`オブジェクトに変換し、`Intent.parseUri(...)`を介して実行することで、悪意のあるインテント注入につながる可能性があります。

### Essential Takeaways

- **Intent Injection**は、ウェブのオープンリダイレクト問題に似ています。
- 脆弱性は、`Intent`オブジェクトをエクストラとして渡すことに関与し、これが不正な操作を実行するためにリダイレクトされる可能性があります。
- 攻撃者に非エクスポートコンポーネントやコンテンツプロバイダーを露出させる可能性があります。
- `WebView`のURLから`Intent`への変換は、意図しないアクションを促進する可能性があります。

### Android Client Side Injections and others

おそらく、あなたはウェブからこの種の脆弱性について知っているでしょう。Androidアプリケーションにおいては、これらの脆弱性に特に注意する必要があります：

- **SQL Injection:** 動的クエリやコンテンツプロバイダーを扱う際は、パラメータ化されたクエリを使用していることを確認してください。
- **JavaScript Injection (XSS):** すべてのWebViewに対してJavaScriptとプラグインのサポートが無効になっていることを確認してください（デフォルトで無効）。 [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViewはファイルシステムへのアクセスを無効にする必要があります（デフォルトで有効） - `(webview.getSettings().setAllowFileAccess(false);)`。 [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: Androidアプリケーションがセッションを終了するとき、クッキーが取り消されない場合や、ディスクに保存されることがあります。
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Static analysis**

![](<../../images/image (866).png>)

**アプリケーションの脆弱性評価**を行うための素晴らしいウェブベースのフロントエンドを使用します。動的分析も実行できますが、環境を準備する必要があります。
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
MobSFは**Android**(apk)**、IOS**(ipa) **およびWindows**(apx)アプリケーションを分析できます（_WindowsアプリケーションはWindowsホストにインストールされたMobSFから分析する必要があります_）。\
また、**Android**または**IOS**アプリのソースコードで**ZIP**ファイルを作成すると（アプリケーションのルートフォルダーに移動し、すべてを選択してZIPファイルを作成）、それも分析できます。

MobSFは**diff/Compare**分析を行い、**VirusTotal**を統合することもできます（_MobSF/settings.py_にAPIキーを設定し、`VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`を有効にする必要があります）。`VT_UPLOAD`を`False`に設定すると、**ハッシュ**がファイルの代わりに**アップロード**されます。

### MobSFによる支援された動的分析

**MobSF**は**Android**における**動的分析**にも非常に役立ちますが、その場合はホストにMobSFと**genymotion**をインストールする必要があります（VMやDockerでは動作しません）。_注：最初に**genymotionでVMを起動**し、**その後MobSFを起動**する必要があります。_\
**MobSF動的アナライザー**は以下を行うことができます：

- **アプリケーションデータをダンプ**（URL、ログ、クリップボード、あなたが作成したスクリーンショット、"**Exported Activity Tester**"によって作成されたスクリーンショット、メール、SQLiteデータベース、XMLファイル、その他の作成されたファイル）。これらはすべて自動的に行われますが、スクリーンショットは、取得したいときに押す必要があります。または、すべてのエクスポートされたアクティビティのスクリーンショットを取得するために"**Exported Activity Tester**"を押す必要があります。
- **HTTPSトラフィックをキャプチャ**
- **Frida**を使用して**ランタイム** **情報**を取得

Androidの**バージョン > 5**では、**Frida**が**自動的に起動**し、**トラフィックをキャプチャ**するためのグローバル**プロキシ**設定が行われます。テストされたアプリケーションからのトラフィックのみをキャプチャします。

**Frida**

デフォルトでは、SSLピンニング、**ルート検出**、**デバッガ検出**を**バイパス**し、**興味深いAPI**を**監視**するためにいくつかのFridaスクリプトも使用します。\
MobSFはまた、**エクスポートされたアクティビティを呼び出し**、それらの**スクリーンショットを取得**し、レポート用に**保存**することもできます。

動的テストを**開始**するには、緑のボタン"**Start Instrumentation**"を押します。"**Frida Live Logs**"を押すと、Fridaスクリプトによって生成されたログが表示され、"**Live API Monitor**"を押すと、フックされたメソッドへのすべての呼び出し、渡された引数、返された値が表示されます（これは"Start Instrumentation"を押した後に表示されます）。\
MobSFは、独自の**Fridaスクリプト**を読み込むこともできます（Fridaスクリプトの結果をMobSFに送信するには、`send()`関数を使用します）。また、読み込むことができる**いくつかの事前に書かれたスクリプト**もあります（`MobSF/DynamicAnalyzer/tools/frida_scripts/others/`に追加できます）。ただ**選択**し、"**Load**"を押し、"**Start Instrumentation**"を押すと、そのスクリプトのログを"**Frida Live Logs**"内で見ることができます。

![](<../../images/image (419).png>)

さらに、いくつかの補助的なFrida機能があります：

- **読み込まれたクラスを列挙**：すべての読み込まれたクラスを印刷します
- **文字列をキャプチャ**：アプリケーションを使用中にキャプチャされたすべての文字列を印刷します（非常に騒がしい）
- **文字列比較をキャプチャ**：非常に便利です。**比較されている2つの文字列**と結果がTrueかFalseかを**表示**します。
- **クラスメソッドを列挙**：クラス名（例："java.io.File"）を入力すると、そのクラスのすべてのメソッドが印刷されます。
- **クラスパターンを検索**：パターンでクラスを検索
- **クラスメソッドをトレース**：**クラス全体をトレース**（そのクラスのすべてのメソッドの入力と出力を確認）。デフォルトでは、MobSFは興味深いAndroid APIメソッドをいくつかトレースします。

使用したい補助モジュールを選択したら、"**Start Intrumentation**"を押すと、すべての出力が"**Frida Live Logs**"に表示されます。

**Shell**

Mobsfは、動的分析ページの下部にいくつかの**adb**コマンド、**MobSFコマンド**、および一般的な**シェル** **コマンド**を持つシェルも提供します。いくつかの興味深いコマンド：
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTPツール**

HTTPトラフィックがキャプチャされると、"**HTTP(S) Traffic**"の下にキャプチャされたトラフィックの醜いビューが表示されるか、"**Start HTTPTools**"の緑のボタンでより良いビューが表示されます。2番目のオプションから、**キャプチャされたリクエスト**を**プロキシ**（BurpやOwasp ZAPなど）に**送信**できます。\
そのためには、_Burpを起動 -->_ _インターセプトをオフにする --> MobSB HTTPToolsでリクエストを選択_ --> "**Send to Fuzzer**"を押す --> _プロキシアドレスを選択_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080))。

MobSFで動的分析を終えたら、"**Start Web API Fuzzer**"を押して**HTTPリクエストをファズ**し、脆弱性を探すことができます。

> [!NOTE]
> MobSFで動的分析を実行した後、プロキシ設定が誤って構成される可能性があり、GUIから修正できなくなることがあります。プロキシ設定を修正するには、次のコマンドを実行します：
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Inspeckageによる支援動的分析

ツールは[**Inspeckage**](https://github.com/ac-pm/Inspeckage)から入手できます。\
このツールは、**動的分析**を実行している間に**アプリケーションで何が起こっているか**を知らせるためにいくつかの**フック**を使用します。

### [Yaazhini](https://www.vegabird.com/yaazhini/)

これは**GUIを使用した静的分析を実行するための優れたツール**です。

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

このツールは、**ソースコード**または**パッケージ化されたAPK**のいずれかで、いくつかの**セキュリティ関連のAndroidアプリケーションの脆弱性**を探すように設計されています。このツールは、発見された脆弱性（公開されたアクティビティ、インテント、タップジャッキングなど）を悪用するための**"Proof-of-Concept"デプロイ可能APK**および**ADBコマンド**を作成することも**可能です**。Drozerと同様に、テストデバイスをルート化する必要はありません。
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- 参照用にすべての抽出ファイルを表示
- APKファイルを自動的にJavaおよびSmali形式にデコンパイル
- 一般的な脆弱性と動作のためにAndroidManifest.xmlを分析
- 一般的な脆弱性と動作のための静的ソースコード分析
- デバイス情報
- その他多数
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPERは、Windows、MacOS X、Linuxで使用できるコマンドラインアプリケーションで、脆弱性を探すために_.apk_ファイルを分析します。これは、APKを解凍し、一連のルールを適用して脆弱性を検出することによって行われます。

すべてのルールは`rules.json`ファイルに集中しており、各企業やテスターは自分たちのニーズに応じて分析するための独自のルールを作成できます。

最新のバイナリは[ダウンロードページ](https://superanalyzer.rocks/download.html)からダウンロードしてください。
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAnは、開発者、バグバウンティハンター、倫理的ハッカーがモバイルアプリケーションに対して[静的コード分析](https://en.wikipedia.org/wiki/Static_program_analysis)を行うのを支援する**クロスプラットフォーム**ツールです。

このコンセプトは、モバイルアプリケーションファイル（.apkまたは.ipaファイル）をStaCoAnアプリケーションにドラッグアンドドロップすると、視覚的でポータブルなレポートが生成されるというものです。設定やワードリストを調整して、カスタマイズされた体験を得ることができます。

ダウンロード[最新リリース](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Frameworkは、開発者やハッカーがAndroidアプリケーションの潜在的なセキュリティ脆弱性を見つけるのを助けるAndroid脆弱性分析システムです。\
[Windowsリリース](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn**は、Androidアプリケーションによって開発された潜在的な悪意のある動作を検出し、ユーザーに警告することを主な目的としたツールです。

検出は、アプリケーションのDalvikバイトコードの**静的分析**を使用して行われ、**Smali**として表現されます。[`androguard`](https://github.com/androguard/androguard)ライブラリを使用しています。

このツールは、次のような**「悪い」アプリケーションの一般的な動作**を探します：電話識別子の流出、音声/ビデオフローの傍受、PIMデータの変更、任意のコード実行...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA**は**モバイルアプリケーションの逆コンパイルと分析フレームワーク**です。これは、OWASPモバイルセキュリティ脅威に対してモバイルアプリケーションをテストするために、一般的に使用されるモバイルアプリケーションの逆コンパイルおよび分析ツールをまとめたツールです。その目的は、この作業をモバイルアプリケーションの開発者やセキュリティ専門家にとってより簡単で親しみやすくすることです。

以下のことが可能です：

- 異なるツールを使用してJavaおよびSmaliコードを抽出する
- [smalisca](https://github.com/dorneanu/smalisca)、[ClassyShark](https://github.com/google/android-classyshark)、[androbugs](https://github.com/AndroBugs/AndroBugs_Framework)、[androwarn](https://github.com/maaaaz/androwarn)、[APKiD](https://github.com/rednaga/APKiD)を使用してAPKを分析する
- 正規表現を使用してAPKからプライベート情報を抽出する
- マニフェストを分析する
- [pyssltest](https://github.com/moheshmohan/pyssltest)、[testssl](https://github.com/drwetter/testssl.sh)、[whatweb](https://github.com/urbanadventurer/WhatWeb)を使用して見つかったドメインを分析する
- [apk-deguard.com](http://www.apk-deguard.com)を介してAPKをデオブフスケートする

### Koodous

マルウェアを検出するのに役立ちます: [https://koodous.com/](https://koodous.com)

## コードの難読化/デオブフスケート

使用するサービスと設定によって、コードを難読化する際に秘密が難読化される場合とされない場合があります。

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

[Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>より): **ProGuard**は、Javaコードを縮小、最適化、難読化するオープンソースのコマンドラインツールです。バイトコードを最適化し、未使用の命令を検出して削除することができます。ProGuardはフリーソフトウェアで、GNU一般公衆ライセンス第2版の下で配布されています。

ProGuardはAndroid SDKの一部として配布され、リリースモードでアプリケーションをビルドする際に実行されます。

### [DexGuard](https://www.guardsquare.com/dexguard)

APKをデオブフスケートするためのステップバイステップガイドは[https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)で見つけることができます。

（そのガイドから）最後に確認したとき、Dexguardの動作モードは次のとおりでした：

- リソースをInputStreamとして読み込む;
- 結果をFilterInputStreamから継承したクラスに渡して復号化する;
- リバースエンジニアに数分の時間を無駄にさせるために無駄な難読化を行う;
- 復号化された結果をZipInputStreamに渡してDEXファイルを取得する;
- 最後に、`loadDex`メソッドを使用して結果のDEXをリソースとして読み込む。

### [DeGuard](http://apk-deguard.com)

**DeGuardは、Androidの難読化ツールによって行われた難読化プロセスを逆転させます。これにより、コード検査やライブラリの予測など、数多くのセキュリティ分析が可能になります。**

難読化されたAPKを彼らのプラットフォームにアップロードできます。

### [Deobfuscate android App](https://github.com/In3tinct/deobfuscate-android-app)

これは、Androidアプリの潜在的なセキュリティ脆弱性を見つけ、AndroidアプリのコードをデオブフスケートするためのLLMツールです。GoogleのGeminiパブリックAPIを使用します。

### [Simplify](https://github.com/CalebFenton/simplify)

これは**一般的なAndroidデオブフスケーター**です。Simplifyは**アプリを仮想的に実行**してその動作を理解し、その後**コードを最適化しようとします**。各最適化タイプはシンプルで一般的であるため、使用される特定の難読化のタイプは関係ありません。

### [APKiD](https://github.com/rednaga/APKiD)

APKiDは**APKがどのように作成されたか**に関する情報を提供します。多くの**コンパイラ**、**パッカー**、**難読化ツール**、およびその他の奇妙なものを特定します。これはAndroid用の[_PEiD_](https://www.aldeid.com/wiki/PEiD)です。

### マニュアル

[カスタム難読化を逆コンパイルする方法についてのいくつかのトリックを学ぶためにこのチュートリアルを読んでください](manual-deobfuscation.md)

## ラボ

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4bは、Ubuntu-mateに基づいたAndroidセキュリティ仮想マシンで、リバースエンジニアリングとマルウェア分析のための最新のフレームワーク、チュートリアル、ラボのコレクションを含んでいます。

## 参考文献

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) これは素晴らしいリソースのリストです
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Androidのクイックコース
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)

## まだ試していない

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
