# Εφαρμογές Android Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Βασικά για Εφαρμογές Android

Συνιστάται ανεπιφύλακτα να ξεκινήσετε διαβάζοντας αυτή τη σελίδα για να μάθετε σχετικά με τα **πιο σημαντικά μέρη που σχετίζονται με την ασφάλεια του Android και τα πιο επικίνδυνα στοιχεία σε μια εφαρμογή Android**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Αυτό είναι το κύριο εργαλείο που χρειάζεστε για να συνδεθείτε σε μια συσκευή Android (εξομοιωμένη ή φυσική).\
**ADB** επιτρέπει τον έλεγχο συσκευών είτε μέσω **USB** είτε μέσω **Network** από έναν υπολογιστή. Αυτή η χρησιμότητα επιτρέπει την **αντιγραφή** αρχείων και στις δύο κατευθύνσεις, την **εγκατάσταση** και **απεγκατάσταση** εφαρμογών, την **εκτέλεση** εντολών shell, τη **δημιουργία αντιγράφων ασφαλείας** δεδομένων, την **ανάγνωση** αρχείων καταγραφής, μεταξύ άλλων λειτουργιών.

Take a look to the following list of [**ADB Commands**](adb-commands.md) to learn how to use adb.

## Smali

Μερικές φορές είναι χρήσιμο να **τροποποιήσετε τον κώδικα της εφαρμογής** για να αποκτήσετε πρόσβαση σε **κρυφές πληροφορίες** (π.χ. καλά συγκαλυμμένοι κωδικοί ή flags). Στη συνέχεια, μπορεί να είναι ενδιαφέρον να decompile το APK, να τροποποιήσετε τον κώδικα και να το recompile.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). This could be very useful as an **alternative for several tests during the dynamic analysis** that are going to presented. Then, **keep always in mid this possibility**.

## Άλλα ενδιαφέροντα κόλπα

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [Android IME / InputMethodService Abuse (Malicious Keyboards)](inputmethodservice-ime-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **Λήψη APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Εξαγωγή APK από τη συσκευή:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Συγχώνευση όλων των splits και base apks με [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Επιθέσεις Android Enterprise & Work Profile

{{#ref}}
android-enterprise-work-profile-bypass.md
{{#endref}}

## Μελέτες περίπτωσης & Ευπάθειες


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}


{{#ref}}
../../binary-exploitation/linux-kernel-exploitation/arm64-static-linear-map-kaslr-bypass.md
{{#endref}}

## Στατική Ανάλυση

Πρώτα απ' όλα, για να αναλύσετε ένα APK θα πρέπει να **ρίξετε μια ματιά στον Java κώδικα** χρησιμοποιώντας έναν decompiler.\
Παρακαλώ, [**read here to find information about different available decompilers**](apk-decompilers.md).

### Αναζήτηση ενδιαφέρουσας πληροφορίας

Απλώς ρίχνοντας μια ματιά στα **strings** του APK μπορείτε να αναζητήσετε **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** και οτιδήποτε ενδιαφέρον... ψάξτε ακόμη για code execution **backdoors** ή authentication backdoors (hardcoded admin credentials στην εφαρμογή).

**Firebase**

Δώστε ιδιαίτερη προσοχή σε **firebase URLs** και ελέγξτε αν έχει κακή ρύθμιση. [More information about whats is FIrebase and how to exploit it here.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Βασική κατανόηση της εφαρμογής - Manifest.xml, strings.xml

Η **εξέταση των αρχείων _Manifest.xml_ και **_strings.xml_** μιας εφαρμογής μπορεί να αποκαλύψει πιθανά ευπάθειας ασφαλείας**. Αυτά τα αρχεία μπορούν να προσεγγιστούν χρησιμοποιώντας decompilers ή με μετονομασία της επέκτασης του αρχείου APK σε .zip και στη συνέχεια αποσυμπίεση.

**Ευπάθειες** που εντοπίζονται από το **Manifest.xml** περιλαμβάνουν:

- **Debuggable Applications**: Οι εφαρμογές που έχουν οριστεί ως debuggable (`debuggable="true"`) στο αρχείο _Manifest.xml_ αποτελούν κίνδυνο καθώς επιτρέπουν συνδέσεις που μπορούν να οδηγήσουν σε εκμετάλλευση. Για περαιτέρω κατανόηση σχετικά με το πώς να εκμεταλλευτείτε debuggable applications, ανατρέξτε σε ένα tutorial για την εύρεση και εκμετάλλευση debuggable applications σε μια συσκευή.
- **Backup Settings**: Το `android:allowBackup="false"` πρέπει να ορίζεται ρητά για εφαρμογές που χειρίζονται ευαίσθητες πληροφορίες ώστε να αποτρέπονται μη εξουσιοδοτημένα backups δεδομένων μέσω adb, ειδικά όταν είναι ενεργοποιημένο το usb debugging.
- **Network Security**: Οι custom network security ρυθμίσεις (`android:networkSecurityConfig="@xml/network_security_config"`) στο _res/xml/_ μπορούν να καθορίσουν λεπτομέρειες ασφαλείας όπως certificate pins και ρυθμίσεις για HTTP traffic. Ένα παράδειγμα είναι η επιτρεπτότητα HTTP traffic για συγκεκριμένους domains.
- **Exported Activities and Services**: Η αναγνώριση exported activities και services στο manifest μπορεί να επισημάνει components που ενδέχεται να καταχραστούν. Περαιτέρω ανάλυση κατά τη διάρκεια dynamic testing μπορεί να αποκαλύψει πώς να εκμεταλλευτείτε αυτά τα components.
- **Content Providers and FileProviders**: Οι εκτεθειμένοι content providers θα μπορούσαν να επιτρέψουν μη εξουσιοδοτημένη πρόσβαση ή τροποποίηση δεδομένων. Η διαμόρφωση των FileProviders πρέπει επίσης να ελεγχθεί προσεκτικά.
- **Broadcast Receivers and URL Schemes**: Αυτά τα components θα μπορούσαν να αξιοποιηθούν για εκμετάλλευση, με ιδιαίτερη προσοχή στον τρόπο που διαχειρίζονται τα URL schemes για εισαγωγή δεδομένων.
- **SDK Versions**: Τα `minSdkVersion`, `targetSDKVersion`, και `maxSdkVersion` υποδεικνύουν τις υποστηριζόμενες εκδόσεις Android, υπογραμμίζοντας τη σημασία να μην υποστηρίζονται ξεπερασμένες, ευάλωτες εκδόσεις Android για λόγους ασφάλειας.

Από το αρχείο **strings.xml**, μπορούν να ανευρεθούν ευαίσθητες πληροφορίες όπως API keys, custom schemas και άλλες σημειώσεις προγραμματιστών, τονίζοντας την ανάγκη για προσεκτική ανασκόπηση αυτών των πόρων.

### Tapjacking

**Tapjacking** είναι μια επίθεση όπου μια **κακόβουλη** **εφαρμογή** εκκινείται και **τοποθετείται πάνω από μια εφαρμογή-θύμα**. Μόλις οπτικά αποκρύψει την εφαρμογή-θύμα, το user interface της σχεδιάζεται με τέτοιο τρόπο ώστε να παραπλανά τον χρήστη να αλληλεπιδράσει με αυτή, ενώ μεταβιβάζει την αλληλεπίδραση στην εφαρμογή-θύμα.\
Στην ουσία, πρόκειται για **την τύφλωση του χρήστη ώστε να μην γνωρίζει ότι στην πραγματικότητα εκτελεί ενέργειες στην εφαρμογή-θύμα**.

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Μια **activity** με το **`launchMode`** ορισμένο σε **`singleTask` χωρίς να έχει οριστεί `taskAffinity`** είναι ευάλωτη σε Task Hijacking. Αυτό σημαίνει ότι μια **εφαρμογή** μπορεί να εγκατασταθεί και αν εκκινηθεί πριν από την πραγματική εφαρμογή θα μπορούσε **να απαλλοτριώσει το task της πραγματικής εφαρμογής** (έτσι ο χρήστης θα αλληλεπιδρά με την **κακόβουλη εφαρμογή νομίζοντας ότι χρησιμοποιεί την πραγματική**).

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Μη ασφαλής αποθήκευση δεδομένων

**Internal Storage**

Στο Android, τα αρχεία που **αποθηκεύονται** στην **internal** storage έχουν σχεδιαστεί ώστε να είναι **προσβάσιμα** αποκλειστικά από την **εφαρμογή** που τα **δημιούργησε**. Αυτό το μέτρο ασφαλείας **επιβάλλεται** από το λειτουργικό σύστημα Android και είναι γενικά επαρκές για τις ανάγκες ασφάλειας των περισσότερων εφαρμογών. Ωστόσο, οι προγραμματιστές μερικές φορές χρησιμοποιούν modes όπως `MODE_WORLD_READABLE` και `MODE_WORLD_WRITABLE` για να **επιτρέψουν** την κοινή χρήση αρχείων μεταξύ διαφορετικών εφαρμογών. Αυτά τα modes **δεν περιορίζουν την πρόσβαση** σε αυτά τα αρχεία από άλλες εφαρμογές, συμπεριλαμβανομένων πιθανώς κακόβουλων.

1. **Static Analysis:**
- **Επιβεβαιώστε** ότι η χρήση των `MODE_WORLD_READABLE` και `MODE_WORLD_WRITABLE` εξετάζεται προσεκτικά. Αυτά τα modes **μπορούν ενδεχομένως να εκθέσουν** αρχεία σε **μη επιθυμητή ή μη εξουσιοδοτημένη πρόσβαση**.
2. **Dynamic Analysis:**
- **Επαληθεύστε** τα **permissions** που ορίζονται στα αρχεία που δημιουργούνται από την εφαρμογή. Ειδικότερα, **ελέγξτε** αν κάποια αρχεία έχουν ρυθμιστεί ώστε να είναι αναγνώσιμα ή εγγράψιμα από όλους. Αυτό μπορεί να αποτελέσει σημαντικό κίνδυνο ασφαλείας, καθώς θα επέτρεπε **σε οποιαδήποτε εφαρμογή** εγκατεστημένη στη συσκευή, ανεξάρτητα από την προέλευσή της ή τον σκοπό της, να **διαβάσει ή να τροποποιήσει** αυτά τα αρχεία.

**External Storage**

Όταν χειρίζεστε αρχεία σε **external storage**, όπως SD Cards, πρέπει να ληφθούν υπόψη τα εξής:

1. **Accessibility**:
- Τα αρχεία στην external storage είναι **προσβάσιμα για ανάγνωση και εγγραφή από όλους**. Αυτό σημαίνει ότι οποιαδήποτε εφαρμογή ή χρήστης μπορεί να έχει πρόσβαση σε αυτά τα αρχεία.
2. **Security Concerns**:
- Δεδομένης της ευκολίας πρόσβασης, συνιστάται **να μην αποθηκεύετε ευαίσθητες πληροφορίες** στην external storage.
- Η external storage μπορεί να αφαιρεθεί ή να προσπελαστεί από οποιαδήποτε εφαρμογή, καθιστώντας την λιγότερο ασφαλή.
3. **Handling Data from External Storage**:
- Πάντα **εκτελέστε validation εισόδου** στα δεδομένα που ανακτώνται από την external storage. Αυτό είναι κρίσιμο επειδή τα δεδομένα προέρχονται από ανεξακριβωμένη πηγή.
- Αποφεύγετε την αποθήκευση εκτελέσιμων ή class files στην external storage για dynamic loading.
- Αν η εφαρμογή σας πρέπει οπωσδήποτε να ανακτήσει εκτελέσιμα αρχεία από την external storage, βεβαιωθείτε ότι αυτά τα αρχεία είναι **υπογεγραμμένα και κρυπτογραφικά επαληθευμένα** πριν φορτωθούν δυναμικά. Αυτό το βήμα είναι ζωτικής σημασίας για τη διατήρηση της ασφάλειας της εφαρμογής σας.

Η external storage μπορεί να **προσπελαστεί** σε `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> Ξεκινώντας από το Android 4.4 (**API 17**), η SD card έχει μια δομή καταλόγων που **περιορίζει την πρόσβαση μιας εφαρμογής στον κατάλογο που είναι ειδικά για αυτήν την εφαρμογή**. Αυτό αποτρέπει την κακόβουλη εφαρμογή από το να αποκτήσει πρόσβαση ανάγνωσης ή εγγραφής στα αρχεία άλλης εφαρμογής.

**Sensitive data stored in clear-text**

- **Shared preferences**: Το Android επιτρέπει σε κάθε εφαρμογή να αποθηκεύει εύκολα αρχεία xml στη διαδρομή `/data/data/<packagename>/shared_prefs/` και μερικές φορές είναι δυνατό να βρεθούν ευαίσθητες πληροφορίες σε clear-text σε αυτόν τον φάκελο.
- **Databases**: Το Android επιτρέπει σε κάθε εφαρμογή να αποθηκεύει εύκολα sqlite databases στη διαδρομή `/data/data/<packagename>/databases/` και μερικές φορές είναι δυνατό να βρεθούν ευαίσθητες πληροφορίες σε clear-text σε αυτόν τον φάκελο.

### Broken TLS

**Accept All Certificates**

Για κάποιο λόγο, μερικές φορές οι developers αποδέχονται όλα τα certificates ακόμα και αν, για παράδειγμα, το hostname δεν ταιριάζει, με γραμμές κώδικα όπως η ακόλουθη:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Σπασμένη Κρυπτογραφία

**Κακές Διαδικασίες Διαχείρισης Κλειδιών**

Κάποιοι developers αποθηκεύουν ευαίσθητα δεδομένα στο local storage και τα κρυπτογραφούν με ένα key hardcoded/predictable στον code. Αυτό δεν θα έπρεπε να γίνεται καθώς κάποιο reversing μπορεί να επιτρέψει σε attackers να εξάγουν εμπιστευτικές πληροφορίες.

**Χρήση Ανασφαλών και/ή Αποσυρμένων Αλγορίθμων**

Οι developers δεν θα πρέπει να χρησιμοποιούν **deprecated algorithms** για να εκτελούν authorisation **checks**, να **store** ή να **send** δεδομένα. Κάποιοι από αυτούς τους αλγόριθμους είναι: RC4, MD4, MD5, SHA1... Εάν χρησιμοποιούνται **hashes** για να αποθηκεύονται passwords για παράδειγμα, πρέπει να χρησιμοποιηθούν hashes **brute-force resistant** σε συνδυασμό με salt.

### Άλλοι έλεγχοι

- Συνιστάται να **obfuscate το APK** ώστε να δυσκολέψετε το έργο των reverse engineers.
- Εάν η εφαρμογή είναι ευαίσθητη (π.χ. τραπεζικές εφαρμογές), θα πρέπει να εκτελεί τους δικούς της ελέγχους για να διαπιστώσει αν το mobile είναι rooted και να ενεργεί αναλόγως.
- Εάν η εφαρμογή είναι ευαίσθητη (π.χ. τραπεζικές εφαρμογές), θα πρέπει να ελέγχει αν χρησιμοποιείται **emulator**.
- Εάν η εφαρμογή είναι ευαίσθητη (π.χ. τραπεζικές εφαρμογές), θα πρέπει να **ελέγχει την ακεραιότητά της πριν την εκτέλεση** για να διαπιστώσει αν έχει τροποποιηθεί.
- Χρησιμοποιήστε [**APKiD**](https://github.com/rednaga/APKiD) για να δείτε ποιος compiler/packer/obfuscator χρησιμοποιήθηκε για να χτιστεί το APK

### Εφαρμογή React Native

Διαβάστε την ακόλουθη σελίδα για να μάθετε πώς να αποκτάτε εύκολα πρόσβαση στον javascript κώδικα των React εφαρμογών:


{{#ref}}
react-native-application.md
{{#endref}}

### Εφαρμογές Xamarin

Διαβάστε την ακόλουθη σελίδα για να μάθετε πώς να αποκτάτε εύκολα πρόσβαση στον C# κώδικα μιας εφαρμογής xamarin:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Εφαρμογές

Σύμφωνα με αυτό το [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) το superpacked είναι ένας Meta αλγόριθμος που συμπιέζει το περιεχόμενο μιας εφαρμογής σε ένα ενιαίο αρχείο. Το blog αναφέρεται στην πιθανότητα δημιουργίας μιας εφαρμογής που αποσυμπιέζει αυτό το είδος εφαρμογών... και σε έναν ταχύτερο τρόπο που περιλαμβάνει την **εκτέλεση της εφαρμογής και τη συγκέντρωση των αποσυμπιεσμένων αρχείων από το filesystem.**

### Αυτοματοποιημένη Στατική Ανάλυση Κώδικα

Το εργαλείο [**mariana-trench**](https://github.com/facebook/mariana-trench) είναι ικανό να εντοπίζει **vulnerabilities** σαρώνοντας τον **code** της εφαρμογής. Αυτό το εργαλείο περιλαμβάνει μια σειρά από **known sources** (που υποδεικνύουν στο εργαλείο τα **places** όπου το **input** είναι **controlled by the user**), **sinks** (που υποδεικνύουν τα **dangerous** **places** όπου το κακόβουλο user input θα μπορούσε να προκαλέσει ζημιά) και **rules**. Αυτοί οι κανόνες υποδεικνύουν τους **συνδυασμούς** **sources-sinks** που δηλώνουν μια ευπάθεια.

Με αυτή τη γνώση, **mariana-trench θα ανασκοπήσει τον κώδικα και θα βρει πιθανές ευπάθειες σε αυτόν**.

### Secrets leaked

Μια εφαρμογή μπορεί να περιέχει secrets (API keys, passwords, hidden urls, subdomains...) μέσα της που μπορεί να καταφέρετε να ανακαλύψετε. Μπορείτε να χρησιμοποιήσετε ένα εργαλείο όπως [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Παράκαμψη Βιομετρικής Αυθεντικοποίησης


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Άλλες ενδιαφέρουσες λειτουργίες

- **Εκτέλεση κώδικα**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Αποστολή SMS**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** δηλωμένες ως `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)
- Εκτέλεση native κώδικα in-memory μέσω JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Άλλα κόλπα**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Δυναμική Ανάλυση

> Πρώτα απ' όλα, χρειάζεστε ένα περιβάλλον όπου μπορείτε να εγκαταστήσετε την εφαρμογή και όλο το απαραίτητο περιβάλλον (Burp CA cert, Drozer and Frida κυρίως). Επομένως, μια rooted συσκευή (emulated ή όχι) είναι ιδιαίτερα συνιστώμενη.

### Online Δυναμική ανάλυση

Μπορείτε να δημιουργήσετε έναν **free account** στο: [https://appetize.io/](https://appetize.io). Αυτή η πλατφόρμα σας επιτρέπει να **upload** και να **execute** APKs, επομένως είναι χρήσιμη για να δείτε πώς συμπεριφέρεται ένα apk.

Μπορείτε ακόμη να **δειτε τα logs της εφαρμογής σας** στο web και να συνδεθείτε μέσω **adb**.

![](<../../images/image (831).png>)

Χάρη στην ADB σύνδεση μπορείτε να χρησιμοποιήσετε **Drozer** και **Frida** μέσα στους emulators.

### Τοπική Δυναμική Ανάλυση

#### Χρήση emulator

- [**Android Studio**](https://developer.android.com/studio) (Μπορείτε να δημιουργήσετε **x86** και **arm** συσκευές, και σύμφωνα με [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**οι νεότερες x86** εκδόσεις **υποστηρίζουν ARM βιβλιοθήκες** χωρίς να χρειάζεται ένας αργός arm emulator).
- Μάθετε πώς να το ρυθμίσετε σε αυτή τη σελίδα:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, πρέπει να δημιουργήσετε account. _Συνιστάται να **κατεβάσετε** την έκδοση **ΜΕ**_ _**VirtualBox** για να αποφύγετε πιθανά σφάλματα._)
- [**Nox**](https://es.bignox.com) (Free, αλλά δεν υποστηρίζει Frida ή Drozer).

> [!TIP]
> Όταν δημιουργείτε έναν νέο emulator σε οποιαδήποτε πλατφόρμα θυμηθείτε ότι όσο μεγαλύτερη είναι η οθόνη τόσο πιο αργά θα τρέχει ο emulator. Οπότε επιλέξτε μικρές οθόνες αν είναι δυνατό.

Για να **εγκαταστήσετε google services** (όπως AppStore) στο Genymotion χρειάζεται να πατήσετε το κουμπί που είναι μαρκαρισμένο με κόκκινο στην παρακάτω εικόνα:

![](<../../images/image (277).png>)

Επίσης, σημειώστε ότι στις **ρυθμίσεις του Android VM στο Genymotion** μπορείτε να επιλέξετε **Bridge Network mode** (αυτό θα είναι χρήσιμο αν σκοπεύετε να συνδεθείτε στο Android VM από ένα διαφορετικό VM με τα εργαλεία).

#### Χρήση φυσικής συσκευής

Πρέπει να ενεργοποιήσετε τις **debugging** επιλογές και είναι καλό αν μπορείτε να την **root**:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Μόλις εγκαταστήσετε την εφαρμογή, το πρώτο πράγμα που πρέπει να κάνετε είναι να τη δοκιμάσετε και να ερευνήσετε τι κάνει, πώς λειτουργεί και να εξοικειωθείτε με αυτή.\
> Προτείνω να **εκτελέσετε αυτή την αρχική δυναμική ανάλυση χρησιμοποιώντας MobSF dynamic analysis + pidcat**, έτσι θα μπορέσουμε να **μάθουμε πώς λειτουργεί η εφαρμογή** ενώ το MobSF **συλλαμβάνει** πολλά **interesting** **δεδομένα** που μπορείτε να αναθεωρήσετε αργότερα.

Magisk/Zygisk quick notes (συνιστάται σε Pixel συσκευές)
- Patch boot.img με την εφαρμογή Magisk και κάντε flash μέσω fastboot για να αποκτήσετε systemless root
- Ενεργοποιήστε Zygisk + DenyList για απόκρυψη root; σκεφτείτε LSPosed/Shamiko όταν απαιτείται ισχυρότερη απόκρυψη
- Κρατήστε το original boot.img για να επαναφέρετε μετά από OTA updates; επανα-κάντε patch μετά από κάθε OTA
- Για screen mirroring, χρησιμοποιήστε scrcpy στον host

### Unintended Data Leakage

**Logging**

Οι developers πρέπει να είναι προσεκτικοί με την έκθεση **debugging information** δημόσια, καθώς αυτό μπορεί να οδηγήσει σε ευαίσθητες data leaks. Τα εργαλεία [**pidcat**](https://github.com/JakeWharton/pidcat) και `adb logcat` συνιστώνται για την παρακολούθηση των logs της εφαρμογής ώστε να εντοπίζονται και να προστατεύονται ευαίσθητες πληροφορίες. **Pidcat** προτιμάται για την ευχρηστία και την αναγνωσιμότητά του.

> [!WARNING]
> Σημειώστε ότι από **later newer than Android 4.0**, **οι εφαρμογές μπορούν να έχουν πρόσβαση μόνο στα δικά τους logs**. Έτσι οι εφαρμογές δεν μπορούν να έχουν πρόσβαση στα logs άλλων apps.\
> Παρ' όλα αυτά, εξακολουθεί να συνιστάται να **μην καταγράφονται ευαίσθητες πληροφορίες**.

**Copy/Paste Buffer Caching**

Το Android **clipboard-based** πλαίσιο ενεργοποιεί λειτουργικότητα copy-paste στις εφαρμογές, αλλά δημιουργεί ρίσκο καθώς **άλλες εφαρμογές** μπορούν να **access** το clipboard, ενδεχομένως εκθέτοντας ευαίσθητα δεδομένα. Είναι κρίσιμο να **απενεργοποιείτε τις λειτουργίες copy/paste** για ευαίσθητα τμήματα μιας εφαρμογής, όπως λεπτομέρειες πιστωτικών καρτών, για να αποτρέψετε data leaks.

**Crash Logs**

Αν μια εφαρμογή **crashes** και **αποθηκεύει logs**, αυτά τα logs μπορούν να βοηθήσουν attackers, ειδικά όταν η εφαρμογή δεν μπορεί να αναστραφεί εύκολα. Για να μειώσετε αυτόν τον κίνδυνο, αποφύγετε το logging σε crashes, και αν τα logs πρέπει να αποσταλούν μέσω δικτύου, βεβαιωθείτε ότι αποστέλλονται μέσω SSL καναλιού για ασφάλεια.

Ως pentester, **προσπαθήστε να ρίξετε μια ματιά σε αυτά τα logs**.

**Analytics Data Sent To 3rd Parties**

Οι εφαρμογές συχνά ενσωματώνουν υπηρεσίες όπως Google Adsense, οι οποίες μπορούν ακούσια να **leak sensitive data** λόγω ακατάλληλης υλοποίησης από developers. Για να εντοπίσετε πιθανές data leaks, είναι συνετό να **intercept the application's traffic** και να ελέγξετε αν αποστέλλονται ευαίσθητες πληροφορίες σε third-party υπηρεσίες.

### SQLite DBs

Οι περισσότερες εφαρμογές θα χρησιμοποιήσουν **internal SQLite databases** για να αποθηκεύσουν πληροφορίες. Κατά το pentest ρίξτε μια **ματιά** στις **βάσεις δεδομένων** που έχουν δημιουργηθεί, τα ονόματα των **πινάκων** και **στηλών** και σε όλα τα **δεδομένα** που έχουν αποθηκευτεί γιατί μπορεί να βρείτε **ευαίσθητες πληροφορίες** (οι οποίες θα αποτελέσουν ευπάθεια).\
Οι βάσεις δεδομένων θα πρέπει να βρίσκονται στο `/data/data/the.package.name/databases` όπως `/data/data/com.mwr.example.sieve/databases`

Αν η βάση δεδομένων αποθηκεύει εμπιστευτικές πληροφορίες και είναι **encrypted** αλλά μπορείτε να **find** το **password** μέσα στην εφαρμογή, αυτό εξακολουθεί να είναι **ευπάθεια**.

Επenumerate τους πίνακες χρησιμοποιώντας `.tables` και επenumerate τις στήλες των πινάκων με `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

Από τα [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** σας επιτρέπει να **assume the role of an Android app** και να αλληλεπιδράσετε με άλλες εφαρμογές. Μπορεί να κάνει **οτιδήποτε μπορεί να κάνει μια εγκατεστημένη εφαρμογή**, όπως να χρησιμοποιήσει τον μηχανισμό Inter-Process Communication (IPC) του Android και να αλληλεπιδράσει με το underlying operating system. .\
Drozer είναι ένα χρήσιμο εργαλείο για να **exploit exported activities, exported services and Content Providers** όπως θα μάθετε στις επόμενες ενότητες.

### Εκμετάλλευση exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Θυμηθείτε επίσης ότι ο κώδικας μιας activity ξεκινάει στη μέθοδο **`onCreate`**.

**Παράκαμψη αυθεντικοποίησης**

Όταν μια Activity είναι exported μπορείτε να καλέσετε την οθόνη της από μια εξωτερική εφαρμογή. Επομένως, αν μια activity που περιέχει **sensitive information** είναι **exported** θα μπορούσατε να **bypass** τους μηχανισμούς **authentication** για να αποκτήσετε πρόσβαση σε αυτήν.

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

Μπορείτε επίσης να ξεκινήσετε μια exported activity από adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: Το MobSF θα θεωρήσει ως κακόβουλη τη χρήση του _**singleTask/singleInstance**_ ως `android:launchMode` σε μια activity, αλλά λόγω [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), προφανώς αυτό είναι επικίνδυνο μόνο σε παλιές εκδόσεις (API versions < 21).

> [!TIP]
> Σημειώστε ότι ένα authorisation bypass δεν είναι πάντα ευπάθεια — εξαρτάται από το πώς λειτουργεί το bypass και ποιες πληροφορίες εκτίθενται.

**Sensitive information leakage**

**Activities can also return results**. Αν καταφέρετε να βρείτε μια exported και unprotected activity που καλεί τη μέθοδο **`setResult`** και **επιστρέφει sensitive information**, υπάρχει sensitive information leakage.

#### Tapjacking

Εάν το tapjacking δεν αποτραπεί, μπορείτε να καταχραστείτε την exported activity για να κάνετε τον **user perform unexpected actions**. Για περισσότερες πληροφορίες σχετικά με [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers χρησιμοποιούνται βασικά για να **μοιράζονται δεδομένα**. Εάν μια εφαρμογή έχει διαθέσιμους content providers μπορεί να μπορέσετε να **εξάγετε ευαίσθητα** δεδομένα από αυτούς. Είναι επίσης ενδιαφέρον να δοκιμάσετε πιθανές **SQL injections** και **Path Traversals** καθώς μπορεί να είναι ευάλωτες.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Θυμηθείτε ότι οι ενέργειες ενός Service ξεκινούν στη μέθοδο `onStartCommand`.

Ένα service είναι ουσιαστικά κάτι που **μπορεί να λαμβάνει δεδομένα**, **να τα επεξεργάζεται** και **να επιστρέφει** (ή όχι) μια απάντηση. Επομένως, αν μια εφαρμογή εξάγει κάποια services θα πρέπει να **ελέγξετε** τον **κώδικα** για να καταλάβετε τι κάνει και να το **δοκιμάσετε** **δυναμικά** για να εξάγετε εμπιστευτικές πληροφορίες, παρακάμπτοντας μέτρα αυθεντικοποίησης...\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Θυμηθείτε ότι οι ενέργειες ενός Broadcast Receiver ξεκινούν στη μέθοδο `onReceive`.

Ένας broadcast receiver θα περιμένει έναν τύπο μηνύματος. Ανάλογα με το πώς ο receiver χειρίζεται το μήνυμα, μπορεί να είναι ευάλωτος.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Μπορείτε να αναζητήσετε deep links χειροκίνητα, χρησιμοποιώντας εργαλεία όπως το MobSF ή scripts όπως [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Μπορείτε να **ανοίξετε** μια δηλωμένη **scheme** χρησιμοποιώντας **adb** ή έναν **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Σημειώστε ότι μπορείτε να **παραλείψετε το package name** και το κινητό θα καλέσει αυτόματα την εφαρμογή που πρέπει να ανοίξει αυτόν τον σύνδεσμο._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Κώδικας που θα εκτελεστεί**

Για να βρείτε τον **κώδικα που θα εκτελεστεί στην εφαρμογή**, πηγαίνετε στη δραστηριότητα που καλείται από το deeplink και αναζητήστε τη συνάρτηση **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Ευαίσθητες πληροφορίες**

Κάθε φορά που βρίσκετε ένα deep link ελέγξτε ότι **δεν λαμβάνει ευαίσθητα δεδομένα (όπως κωδικούς) μέσω παραμέτρων URL**, γιατί οποιαδήποτε άλλη εφαρμογή θα μπορούσε **να μιμηθεί το deep link και να κλέψει αυτά τα δεδομένα!**

**Παράμετροι στο path**

You **must check also if any deep link is using a parameter inside the path** of the URL like: `https://api.example.com/v1/users/{username}` , in that case you can force a path traversal accessing something like: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Σημειώστε ότι αν βρείτε τα σωστά endpoints μέσα στην εφαρμογή μπορεί να καταφέρετε να προκαλέσετε ένα **Open Redirect** (αν μέρος του path χρησιμοποιείται ως domain name), **account takeover** (αν μπορείτε να τροποποιήσετε λεπτομέρειες χρήστη χωρίς CSRF token και το ευάλωτο endpoint χρησιμοποιούσε τη σωστή μέθοδο) και οποιαδήποτε άλλη vuln. Περισσότερες [πληροφορίες εδώ](http://dphoeniixx.com/2020/12/13-2/).

**Περισσότερα παραδείγματα**

Μια [ενδιαφέρουσα αναφορά bug bounty](https://hackerone.com/reports/855618) σχετικά με links (_/.well-known/assetlinks.json_).

### Έλεγχος επιπέδου μεταφοράς και αποτυχίες επαλήθευσης

- **Certificates are not always inspected properly** από Android εφαρμογές. Είναι συνηθισμένο αυτές οι εφαρμογές να παραβλέπουν προειδοποιήσεις και να αποδέχονται self-signed certificates ή, σε ορισμένες περιπτώσεις, να επιστρέφουν σε χρήση HTTP συνδέσεων.
- **Negotiations during the SSL/TLS handshake are sometimes weak**, χρησιμοποιώντας insecure cipher suites. Αυτό το vulnerability κάνει τη σύνδεση ευάλωτη σε man-in-the-middle (MITM) attacks, επιτρέποντας σε επιτιθέμενους να αποκρυπτογραφήσουν τα δεδομένα.
- **Leakage of private information** is a risk when applications authenticate using secure channels but then communicate over non-secure channels for other transactions. Αυτή η προσέγγιση δεν προστατεύει ευαίσθητα δεδομένα, όπως session cookies ή στοιχεία χρήστη, από υποκλοπή από κακόβουλους φορείς.

#### Επαλήθευση πιστοποιητικού

Θα επικεντρωθούμε στην **επαλήθευση πιστοποιητικού**. Η ακεραιότητα του πιστοποιητικού του server πρέπει να επαληθεύεται για να ενισχυθεί η ασφάλεια. Αυτό είναι κρίσιμο επειδή ανεπαρκείς ρυθμίσεις TLS και η μεταφορά ευαίσθητων δεδομένων μέσω μη κρυπτογραφημένων καναλιών μπορεί να προκαλέσουν σημαντικούς κινδύνους. Για αναλυτικά βήματα σχετικά με την επαλήθευση των πιστοποιητικών server και την αντιμετώπιση ευπαθειών, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) παρέχει ολοκληρωμένες οδηγίες.

#### SSL Pinning

Το SSL Pinning είναι ένα μέτρο ασφαλείας όπου η εφαρμογή επαληθεύει το πιστοποιητικό του server σε σχέση με ένα γνωστό αντίγραφο αποθηκευμένο εντός της εφαρμογής. Αυτή η μέθοδος είναι απαραίτητη για την πρόληψη των man-in-the-middle (MITM) attacks. Συνιστάται έντονα η υλοποίηση του SSL Pinning για εφαρμογές που χειρίζονται ευαίσθητες πληροφορίες.

#### Επιθεώρηση κυκλοφορίας

Για να επιθεωρήσετε το HTTP traffic, είναι απαραίτητο να **εγκαταστήσετε το πιστοποιητικό του proxy tool** (π.χ. Burp). Χωρίς την εγκατάσταση αυτού του πιστοποιητικού, η κρυπτογραφημένη κίνηση μπορεί να μην είναι ορατή μέσω του proxy. Για οδηγό σχετικά με την εγκατάσταση custom CA certificate, [**κάντε κλικ εδώ**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Εφαρμογές που στοχεύουν **API Level 24 and above** απαιτούν τροποποιήσεις στο Network Security Config για να αποδεχτούν το CA certificate του proxy. Αυτό το βήμα είναι κρίσιμο για την επιθεώρηση κρυπτογραφημένης κυκλοφορίας. Για οδηγίες σχετικά με την τροποποίηση του Network Security Config, [**ανατρέξτε σε αυτό το tutorial**](make-apk-accept-ca-certificate.md).

Αν χρησιμοποιείται **Flutter** πρέπει να ακολουθήσετε τις οδηγίες στη [**σελίδα αυτή**](flutter.md). Αυτό συμβαίνει γιατί απλώς η προσθήκη του πιστοποιητικού στο store δεν θα λειτουργήσει αφού το Flutter έχει τη δική του λίστα έγκυρων CAs.

#### Στατική ανίχνευση του SSL/TLS pinning

Πριν επιχειρήσετε runtime bypasses, χαρτογραφήστε γρήγορα πού επιβάλλεται το pinning στο APK. Η στατική ανακάλυψη βοηθάει να σχεδιάσετε hooks/patches και να εστιάσετε στους σωστούς κώδικες.

Tool: SSLPinDetect
- Open-source static-analysis utility that decompiles the APK to Smali (via apktool) and scans for curated regex patterns of SSL/TLS pinning implementations.
- Reports exact file path, line number, and a code snippet for each match.
- Covers common frameworks and custom code paths: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

Εγκατάσταση
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Χρήση
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Παράδειγμα κανόνων προτύπων (JSON)

Χρησιμοποιήστε ή επεκτείνετε signatures για να εντοπίσετε proprietary/custom pinning styles. Μπορείτε να φορτώσετε το δικό σας JSON και να scan σε μεγάλη κλίμακα.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Σημειώσεις και συμβουλές
- Γρήγορη σάρωση σε μεγάλες εφαρμογές μέσω multi-threading και memory-mapped I/O· pre-compiled regex μειώνει το overhead/false positives.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Τυπικοί στόχοι εντοπισμού για περαιτέρω έλεγχο:
- OkHttp: χρήση CertificatePinner, setCertificatePinner, αναφορές πακέτου okhttp3/okhttp
- Custom TrustManagers: javax.net.ssl.X509TrustManager, overrides της checkServerTrusted
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init με custom managers
- Declarative pins σε res/xml network security config και αναφορές στο manifest
- Χρησιμοποιήστε τις αντιστοιχισμένες τοποθεσίες για να σχεδιάσετε Frida hooks, static patches ή αναθεωρήσεις config πριν από dynamic testing.



#### Bypassing SSL Pinning

Όταν το SSL Pinning είναι υλοποιημένο, το bypassing του γίνεται απαραίτητο για την επιθεώρηση του HTTPS traffic. Διάφορες μέθοδοι είναι διαθέσιμες για αυτόν τον σκοπό:

- Automatically **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Το μεγαλύτερο πλεονέκτημα αυτής της επιλογής είναι ότι δεν θα χρειαστείτε root για να bypass το SSL Pinning, αλλά θα χρειαστεί να διαγράψετε την εφαρμογή και να επανεγκαταστήσετε τη νέα, και αυτό δεν δουλεύει πάντα.
- You could use **Frida** (discussed below) to bypass this protection. Εδώ είναι ένας οδηγός για χρήση Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- You can also try to **automatically bypass SSL Pinning** using [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- You can also try to **automatically bypass SSL Pinning** using **MobSF dynamic analysis** (explained below)
- If you still think that there is some traffic that you aren't capturing you can try to **forward the traffic to burp using iptables**. Read this blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Looking for Common Web Vulnerabilities

Είναι σημαντικό επίσης να αναζητήσετε κοινές web ευπάθειες μέσα στην εφαρμογή. Αναλυτικές πληροφορίες για την ταυτοποίηση και την άμβλυνση αυτών των ευπαθειών υπερβαίνουν το πλαίσιο αυτής της περίληψης αλλά καλύπτονται εκτενώς αλλού.

### Frida

[Frida](https://www.frida.re) είναι ένα dynamic instrumentation toolkit για developers, reverse-engineers και security researchers.\
**Μπορείτε να προσπελάσετε την τρέχουσα εφαρμογή και να κάνετε hook μεθόδους σε runtime για να αλλάξετε τη συμπεριφορά, να αλλάξετε τιμές, να εξάγετε τιμές ή να εκτελέσετε διαφορετικό κώδικα...**\
Αν θέλετε να pentest εφαρμογές Android πρέπει να ξέρετε πώς να χρησιμοποιείτε Frida.

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Some "GUI" for actions with Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- You can find some Awesome Frida scripts here: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Try to bypass anti-debugging / anti-frida mechanisms loading Frida as in indicated in [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

Ελέγξτε αν η εφαρμογή αποθηκεύει ευαίσθητες πληροφορίες στη μνήμη που δεν θα έπρεπε να αποθηκεύει, όπως passwords ή mnemonics.

Using [**Fridump3**](https://github.com/rootbsd/fridump3) you can dump the memory of the app with:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Αυτό θα dump τη μνήμη στον φάκελο ./dump, και εκεί μπορείτε να κάνετε grep με κάτι σαν:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Ευαίσθητα δεδομένα στο Keystore**

Στο Android το Keystore είναι το καλύτερο μέρος για την αποθήκευση ευαίσθητων δεδομένων, όμως με αρκετά δικαιώματα **είναι ακόμη δυνατό να αποκτηθεί πρόσβαση σε αυτό**. Επειδή οι εφαρμογές τείνουν να αποθηκεύουν εδώ **sensitive data in clear text**, τα pentests πρέπει να το ελέγξουν ως root user ή κάποιος με φυσική πρόσβαση στη συσκευή θα μπορούσε να κλέψει αυτά τα δεδομένα.

Ακόμα κι αν μια εφαρμογή αποθήκευσε δεδομένα στο Keystore, τα δεδομένα πρέπει να είναι κρυπτογραφημένα.

Για πρόσβαση στα δεδομένα μέσα στο Keystore μπορείτε να χρησιμοποιήσετε αυτό το Frida script: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Χρησιμοποιώντας το ακόλουθο Frida script, μπορεί να είναι εφικτό να **bypass fingerprint authentication** που πιθανώς εκτελούν εφαρμογές Android για να **protect certain sensitive areas:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Εικόνες παρασκηνίου**

Όταν βάζετε μια εφαρμογή στο παρασκήνιο, το Android αποθηκεύει ένα **στιγμιότυπο της εφαρμογής**, οπότε όταν επανέλθει στο προσκήνιο αρχίζει να φορτώνει την εικόνα πριν από την εφαρμογή, ώστε να φαίνεται ότι η εφαρμογή φορτώθηκε πιο γρήγορα.

Ωστόσο, εάν αυτό το στιγμιότυπο περιέχει **ευαίσθητες πληροφορίες**, κάποιος με πρόσβαση στο στιγμιότυπο μπορεί να **υποκλέψει αυτές τις πληροφορίες** (σημείωση: χρειάζεστε root για να έχετε πρόσβαση).

Τα στιγμιότυπα συνήθως αποθηκεύονται στη διαδρομή: **`/data/system_ce/0/snapshots`**

Το Android παρέχει έναν τρόπο για να **αποτρέψετε τη λήψη screenshots ορίζοντας την FLAG_SECURE** παράμετρο διάταξης. Χρησιμοποιώντας αυτή τη σημαία, τα περιεχόμενα του παραθύρου θεωρούνται ασφαλή, αποτρέποντας την εμφάνισή τους σε screenshots ή την προβολή τους σε μη ασφαλείς οθόνες.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Αναλυτής Εφαρμογών Android**

This tool could help you managing different tools during the dynamic analysis: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Οι developers συχνά δημιουργούν proxy components όπως activities, services και broadcast receivers που χειρίζονται αυτά τα Intents και τα περνάνε σε μεθόδους όπως `startActivity(...)` ή `sendBroadcast(...)`, κάτι που μπορεί να είναι επικίνδυνο.

Ο κίνδυνος έγκειται στο να επιτραπεί σε επιτιθέμενους να ενεργοποιήσουν non-exported app components ή να αποκτήσουν πρόσβαση σε ευαίσθητους content providers κατευθύνοντας λανθασμένα αυτά τα Intents. Ένα αξιοσημείωτο παράδειγμα είναι το `WebView` component που μετατρέπει URLs σε αντικείμενα `Intent` μέσω `Intent.parseUri(...)` και στη συνέχεια τα εκτελεί, το οποίο μπορεί να οδηγήσει σε κακόβουλες Intent injections.

### Essential Takeaways

- **Intent Injection** είναι παρόμοιο με το Open Redirect στο web.
- Οι εκμεταλλεύσεις περιλαμβάνουν την αποστολή αντικειμένων `Intent` ως extras, τα οποία μπορούν να αναδρομολογηθούν για να εκτελέσουν μη ασφαλείς ενέργειες.
- Μπορεί να εκθέσει non-exported components και content providers σε επιτιθέμενους.
- Η μετατροπή URL σε `Intent` του `WebView` μπορεί να διευκολύνει ανεπιθύμητες ενέργειες.

### Android Client Side Injections and others

Πιθανότατα γνωρίζετε αυτού του είδους τις ευπάθειες από το Web. Πρέπει να είστε ιδιαίτερα προσεκτικοί με αυτές τις ευπάθειες σε μια Android εφαρμογή:

- **SQL Injection:** Όταν χειρίζεστε dynamic queries ή Content-Providers, βεβαιωθείτε ότι χρησιμοποιείτε parameterized queries.
- **JavaScript Injection (XSS):** Επαληθεύστε ότι η υποστήριξη JavaScript και Plugin είναι απενεργοποιημένη για οποιαδήποτε WebViews (απενεργοποιημένη από προεπιλογή). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** Τα WebViews θα πρέπει να έχουν απενεργοποιημένη την πρόσβαση στο file system (ενεργοποιημένη από προεπιλογή) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: Σε αρκετές περιπτώσεις όταν η Android εφαρμογή τελειώνει τη συνεδρία, το cookie δεν ανακαλείται ή μπορεί ακόμη και να αποθηκευτεί στο δίσκο
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Στατική ανάλυση**

![](<../../images/image (866).png>)

**Vulnerability assessment of the application** using a nice web-based frontend. You can also perform dynamic analysis (but you need to prepare the environment).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Βοηθημένη δυναμική ανάλυση με MobSF

**MobSF** can also be very helpful for **dynamic analysis** in **Android**, but in that case you will need to install MobSF and **genymotion** in your host (a VM or Docker won't work). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
The **MobSF dynamic analyser** can:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). All of this is done automatically except for the screenshots, you need to press when you want a screenshot or you need to press "**Exported Activity Tester**" to obtain screenshots of all the exported activities.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Frida scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: It will print all the loaded classes
- **Capture Strings**: It will print all the capture strings while using the application (super noisy)
- **Capture String Comparisons**: Could be very useful. It will **show the 2 strings being compared** and if the result was True or False.
- **Enumerate Class Methods**: Put the class name (like "java.io.File") and it will print all the methods of the class.
- **Search Class Pattern**: Search classes by pattern
- **Trace Class Methods**: **Trace** a **whole class** (see inputs and outputs of all methods of the class). Remember that by default MobSF traces several interesting Android Api methods.

Once you have selected the auxiliary module you want to use you need to press "**Start Instrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf also brings you a shell with some **adb** commands, **MobSF commands**, and common **shell** **commands** at the bottom of the dynamic analysis page. Some interesting commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP εργαλεία**

Όταν η HTTP κυκλοφορία καταγράφεται μπορείτε να δείτε μια άσχημη προβολή της καταγεγραμμένης κυκλοφορίας στο κουμπί "**HTTP(S) Traffic**" στο κάτω μέρος ή μια καλύτερη προβολή στο πράσινο κουμπί "**Start HTTPTools**". Από τη δεύτερη επιλογή, μπορείτε να **στείλετε** τα **καταγεγραμμένα requests** σε **proxies** όπως Burp ή Owasp ZAP.\
Για να το κάνετε, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> πατήστε "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Μόλις ολοκληρώσετε τη δυναμική ανάλυση με MobSF μπορείτε να πατήσετε "**Start Web API Fuzzer**" για να **fuzz http requests** και να αναζητήσετε ευπάθειες.

> [!TIP]
> Μετά από μια δυναμική ανάλυση με MobSF οι ρυθμίσεις proxy μπορεί να είναι εσφαλμένα διαμορφωμένες και να μην μπορείτε να τις διορθώσετε από το GUI. Μπορείτε να διορθώσετε τις ρυθμίσεις proxy κάνοντας:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

Μπορείτε να αποκτήσετε το εργαλείο από [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Αυτό το εργαλείο χρησιμοποιεί κάποια **Hooks** για να σας ενημερώνει **τι συμβαίνει στην εφαρμογή** ενώ εκτελείτε **δυναμική ανάλυση**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Αυτό είναι ένα **εξαιρετικό εργαλείο για να πραγματοποιήσετε στατική ανάλυση με GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Αυτό το εργαλείο έχει σχεδιαστεί για να εντοπίζει διάφορες **ευπάθειες ασφαλείας σε Android εφαρμογές**, είτε στον **πηγαίο κώδικα** είτε σε **πακεταρισμένα APKs**. Το εργαλείο είναι επίσης **ικανό να δημιουργήσει ένα "Proof-of-Concept" deployable APK** και **ADB commands**, για να εκμεταλλευτεί μερικές από τις εντοπισμένες ευπάθειες (Exposed activities, intents, tapjacking...). Όπως και με το Drozer, δεν υπάρχει ανάγκη να κάνετε root τη συσκευή δοκιμών.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Εμφανίζει όλα τα εξαγόμενα αρχεία για εύκολη αναφορά
- Αποσυμπιλοποιεί αυτόματα αρχεία APK σε μορφή Java και Smali
- Αναλύει το AndroidManifest.xml για κοινές ευπάθειες και συμπεριφορές
- Στατική ανάλυση πηγαίου κώδικα για κοινές ευπάθειες και συμπεριφορές
- Πληροφορίες συσκευής
- και άλλα
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

Το SUPER είναι μια εφαρμογή γραμμής εντολών που μπορεί να χρησιμοποιηθεί σε Windows, MacOS X και Linux, και αναλύει _.apk_ αρχεία αναζητώντας vulnerabilities. Το κάνει αυτό αποσυμπιέζοντας APKs και εφαρμόζοντας μια σειρά κανόνων για να εντοπίσει αυτές τις vulnerabilities.

Όλοι οι κανόνες είναι συγκεντρωμένοι στο αρχείο `rules.json`, και κάθε εταιρεία ή δοκιμαστής μπορεί να δημιουργήσει τους δικούς του κανόνες για να αναλύσει ό,τι χρειάζεται.

Κατεβάστε τα latest binaries από τη [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

Το StaCoAn είναι ένα **crossplatform** εργαλείο που βοηθά προγραμματιστές, bugbounty hunters και ethical hackers να πραγματοποιούν [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) σε εφαρμογές για κινητά.

Η ιδέα είναι ότι σύρετε και αφήνετε το αρχείο της mobile εφαρμογής σας (ένα αρχείο .apk ή .ipa) στην εφαρμογή StaCoAn και θα δημιουργήσει μια οπτική και φορητή αναφορά για εσάς. Μπορείτε να προσαρμόσετε τις ρυθμίσεις και τις wordlists για να έχετε μια εξατομικευμένη εμπειρία.

Λήψη[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

Το AndroBugs Framework είναι ένα σύστημα ανάλυσης ευπαθειών για Android που βοηθά τους προγραμματιστές ή τους hackers να εντοπίζουν πιθανές ευπάθειες ασφαλείας σε εφαρμογές Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** είναι ένα εργαλείο του οποίου ο κύριος στόχος είναι να εντοπίζει και να προειδοποιεί τον χρήστη για πιθανές κακόβουλες συμπεριφορές που αναπτύσσονται από μια Android εφαρμογή.

Ο εντοπισμός πραγματοποιείται με τη **static analysis** του Dalvik bytecode της εφαρμογής, που αναπαρίσταται ως **Smali**, με τη βιβλιοθήκη [`androguard`](https://github.com/androguard/androguard).

Αυτό το εργαλείο αναζητά **συνηθισμένες συμπεριφορές των "κακών" εφαρμογών** όπως: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** είναι ένα Framework για Mobile Application reverse engineering και analysis. Είναι ένα εργαλείο που συνδυάζει συνήθως χρησιμοποιούμενα εργαλεία reverse engineering και ανάλυσης mobile εφαρμογών, για να βοηθήσει στον έλεγχο mobile εφαρμογών απέναντι στις OWASP mobile security απειλές. Στόχος του είναι να κάνει αυτή τη δουλειά πιο εύκολη και φιλική προς τους mobile application developers και τους επαγγελματίες ασφάλειας.

Μπορεί να:

- Εξάγει Java και Smali κώδικα χρησιμοποιώντας διάφορα εργαλεία
- Αναλύει APKs χρησιμοποιώντας: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Εξάγει ιδιωτικές πληροφορίες από το APK χρησιμοποιώντας regexps.
- Αναλύει το Manifest.
- Αναλύει τα βρεθέντα domains χρησιμοποιώντας: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) και [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Χρήσιμο για την ανίχνευση malware: [https://koodous.com/](https://koodous.com)

## Obfuscating/Deobfuscating code

Σημειώστε ότι ανάλογα με την υπηρεσία και τη ρύθμιση που χρησιμοποιείτε για να obfuscate τον κώδικα, τα secrets μπορεί να είναι ή να μην είναι obfuscated.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** είναι ένα open source command-line εργαλείο που shrinks, optimizes και obfuscates Java κώδικα. Είναι ικανό να optimize bytecode καθώς και να εντοπίζει και να αφαιρεί unused instructions. ProGuard είναι free software και διανέμεται υπό την GNU General Public License, version 2.

Το ProGuard διανέμεται ως μέρος του Android SDK και τρέχει όταν γίνεται build της εφαρμογής σε release mode.

### [DexGuard](https://www.guardsquare.com/dexguard)

Βρείτε έναν οδηγό βήμα-βήμα για να deobfuscate το apk στο [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Last time we checked, the Dexguard mode of operation was:

- φορτώνει έναν πόρο ως InputStream;
- περνάει το αποτέλεσμα σε μια κλάση που κληρονομεί από FilterInputStream για να το αποκρυπτογραφήσει;
- κάνει κάποια άχρηστη obfuscation για να σπαταλήσει λίγα λεπτά από τον χρόνο ενός reverser;
- περνάει το αποκρυπτογραφημένο αποτέλεσμα σε ZipInputStream για να πάρει ένα αρχείο DEX;
- τελικά φορτώνει το προκύπτον DEX ως Resource χρησιμοποιώντας τη μέθοδο `loadDex`.

### [DeGuard](http://apk-deguard.com)

**DeGuard** αντιστρέφει τη διαδικασία της obfuscation που εκτελείται από εργαλεία obfuscation του Android. Αυτό επιτρέπει πολλές αναλύσεις ασφαλείας, συμπεριλαμβανομένης της επιθεώρησης κώδικα και της πρόβλεψης βιβλιοθηκών.

Μπορείτε να ανεβάσετε ένα obfuscated APK στην πλατφόρμα τους.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

Αυτό είναι ένα LLM εργαλείο για να εντοπίζει πιθανές ευπάθειες ασφαλείας σε android apps και να deobfuscate τον κώδικα των android app. Χρησιμοποιεί το Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

Είναι ένας **generic android deobfuscator.** Το Simplify **virtually executes an app** για να κατανοήσει τη συμπεριφορά του και στη συνέχεια **tries to optimize the code** ώστε να συμπεριφέρεται ταυτόσημα αλλά να είναι ευκολότερο για έναν άνθρωπο να το κατανοήσει. Κάθε τύπος optimization είναι απλός και generic, οπότε δεν έχει σημασία ποιος συγκεκριμένος τύπος obfuscation έχει χρησιμοποιηθεί.

### [APKiD](https://github.com/rednaga/APKiD)

Το APKiD σας δίνει πληροφορίες για **how an APK was made**. Αναγνωρίζει πολλούς **compilers**, **packers**, **obfuscators**, και άλλα περίεργα. Είναι [_PEiD_](https://www.aldeid.com/wiki/PEiD) για Android.

### Manual

[Διαβάστε αυτό το tutorial για να μάθετε μερικά κόλπα σχετικά με **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b είναι μια Android security virtual machine βασισμένη σε ubuntu-mate που περιλαμβάνει μια συλλογή από τα πιο πρόσφατα frameworks, tutorials και labs από διάφορους security geeks και researchers για reverse engineering και malware analysis.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Είναι μια εξαιρετική λίστα πόρων
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
