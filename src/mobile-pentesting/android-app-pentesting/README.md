# Pentesting aplikacji Android

{{#include ../../banners/hacktricks-training.md}}

## Podstawy aplikacji Android

Zaleca się rozpoczęcie od przeczytania tej strony, aby poznać **najważniejsze elementy związane z bezpieczeństwem Androida oraz najbardziej niebezpieczne komponenty w aplikacji Android**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

To główne narzędzie, którego potrzebujesz, aby połączyć się z urządzeniem Android (emulowanym lub fizycznym).\
**ADB** pozwala kontrolować urządzenia przez **USB** lub **Network** z komputera. To narzędzie umożliwia **kopiowanie** plików w obu kierunkach, **instalację** i **odinstalowanie** aplikacji, **wykonywanie** poleceń shell, **tworzenie kopii zapasowych** danych, **odczytywanie** logów oraz inne funkcje.

Zapoznaj się z następującą listą [**ADB Commands**](adb-commands.md), aby nauczyć się używać adb.

## Smali

Czasami warto **zmodyfikować kod aplikacji**, aby uzyskać dostęp do **ukrytych informacji** (np. dobrze z obfuskowanymi hasłami lub flagami). W takim przypadku warto zdekompilować apk, zmodyfikować kod i ponownie go skompilować.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Może to być bardzo przydatne jako **alternatywa dla kilku testów podczas dynamicznej analizy**, które zostaną przedstawione. Zawsze **miej na uwadze tę możliwość**.

## Inne ciekawe triki

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **Pobieranie APK**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Wyodrębnij APK z urządzenia:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Połącz wszystkie splits i base apks za pomocą [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Ataki na Android Enterprise i Work Profile

{{#ref}}
android-enterprise-work-profile-bypass.md
{{#endref}}

## Studia przypadków i podatności


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Analiza statyczna

Przede wszystkim, analizując APK powinieneś **przejrzeć kod Java** przy użyciu dekompilera.\
Proszę, [**przeczytaj tutaj aby znaleźć informacje o różnych dostępnych dekompilatorach**](apk-decompilers.md).

### Poszukiwanie interesujących informacji

Wystarczy spojrzeć na **strings** APK, aby wyszukać **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** i wszystko interesujące... sprawdź nawet obecność code execution **backdoors** lub authentication backdoors (hardcoded admin credentials w aplikacji).

**Firebase**

Zwróć szczególną uwagę na **firebase URLs** i sprawdź, czy są źle skonfigurowane. [Więcej informacji o tym czym jest Firebase i jak to wykorzystać tutaj.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Podstawowe zrozumienie aplikacji - Manifest.xml, strings.xml

Zbadanie plików aplikacji _Manifest.xml_ i _strings.xml_ może ujawnić potencjalne luki bezpieczeństwa. Do tych plików można uzyskać dostęp za pomocą dekompilera lub zmieniając rozszerzenie APK na .zip i rozpakowując je.

**Podatności** zidentyfikowane w **Manifest.xml** obejmują:

- **Debuggable Applications**: Aplikacje ustawione jako debuggable (`debuggable="true"`) w pliku _Manifest.xml_ stanowią ryzyko, ponieważ pozwalają na połączenia, które mogą prowadzić do eksploatacji. Aby lepiej zrozumieć, jak wykorzystać debuggable applications, odnieś się do samouczka dotyczącego znajdowania i eksploatacji aplikacji ustawionych jako debuggable na urządzeniu.
- **Backup Settings**: Atrybut `android:allowBackup="false"` powinien być jawnie ustawiony dla aplikacji przetwarzających wrażliwe informacje, aby zapobiec nieautoryzowanym backupom danych przez adb, zwłaszcza gdy usb debugging jest włączony.
- **Network Security**: Niestandardowe konfiguracje (`android:networkSecurityConfig="@xml/network_security_config"`) w katalogu _res/xml/_ mogą określać szczegóły bezpieczeństwa, takie jak certificate pins i ustawienia ruchu HTTP. Przykładem jest zezwalanie na ruch HTTP dla konkretnych domen.
- **Exported Activities and Services**: Identyfikacja exported activities i services w manifeście może ujawnić komponenty, które mogą być niewłaściwie użyte. Dalsza analiza podczas testów dynamicznych może pokazać, jak je eksploatować.
- **Content Providers and FileProviders**: Udostępnione content providers mogą umożliwić nieautoryzowany dostęp lub modyfikację danych. Konfiguracja FileProviders powinna być także poddana wnikliwej analizie.
- **Broadcast Receivers and URL Schemes**: Te komponenty mogą być wykorzystane do eksploatacji, ze szczególnym zwróceniem uwagi na to, jak URL schemes są obsługiwane pod kątem luk wejścia.
- **SDK Versions**: Atrybuty `minSdkVersion`, `targetSDKVersion` i `maxSdkVersion` wskazują obsługiwane wersje Androida, podkreślając znaczenie niewspierania przestarzałych, podatnych wersji Androida ze względu na bezpieczeństwo.

Z pliku **strings.xml** można znaleźć wrażliwe informacje takie jak API keys, custom schemas i inne notatki deweloperskie, co podkreśla potrzebę dokładnego przeglądu tych zasobów.

### Tapjacking

**Tapjacking** to atak, w którym złośliwa aplikacja jest uruchamiana i pozycjonuje się nad aplikacją ofiary. Gdy wizualnie zasłania aplikację ofiary, jej interfejs użytkownika jest zaprojektowany tak, aby oszukać użytkownika, skłaniając go do interakcji, podczas gdy ta interakcja jest przekazywana do aplikacji ofiary.\
W efekcie użytkownik jest oślepiany i nie zdaje sobie sprawy, że w rzeczywistości wykonuje akcje w aplikacji ofiary.

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Aktywność z `launchMode` ustawionym na `singleTask` bez zdefiniowanego `taskAffinity` jest podatna na task Hijacking. Oznacza to, że aplikacja może zostać zainstalowana i jeśli zostanie uruchomiona przed prawdziwą aplikacją, może przejąć task prawdziwej aplikacji (w rezultacie użytkownik będzie wchodził w interakcję ze złośliwą aplikacją, myśląc, że używa tej prawdziwej).

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Niezabezpieczone przechowywanie danych

**Internal Storage**

W Androidzie pliki przechowywane w internal storage są zaprojektowane tak, aby były dostępne wyłącznie dla aplikacji, która je utworzyła. Ten mechanizm bezpieczeństwa jest egzekwowany przez system operacyjny Android i zwykle jest wystarczający dla potrzeb bezpieczeństwa większości aplikacji. Jednak deweloperzy czasami korzystają z trybów takich jak `MODE_WORLD_READABLE` i `MODE_WORLD_WRITABLE`, aby pozwolić na udostępnianie plików między różnymi aplikacjami. Tryby te nie ograniczają jednak dostępu do tych plików przez inne aplikacje, w tym potencjalnie złośliwe.

1. **Static Analysis:**
- **Ensure** że użycie `MODE_WORLD_READABLE` i `MODE_WORLD_WRITABLE` jest **skrupulatnie sprawdzone**. Tryby te **mogą potencjalnie narażać** pliki na **niezamierzony lub nieautoryzowany dostęp**.
2. **Dynamic Analysis:**
- **Verify** uprawnienia ustawione na plikach tworzonych przez aplikację. Sprawdź konkretnie, czy jakieś pliki nie są ustawione jako czytelne lub zapisywalne przez wszystkich. To może stanowić poważne ryzyko bezpieczeństwa, ponieważ pozwoliłoby **każdej aplikacji** zainstalowanej na urządzeniu, niezależnie od jej pochodzenia czy zamiaru, na **odczytanie lub modyfikację** tych plików.

**External Storage**

W przypadku plików na external storage, takich jak SD Cards, należy zachować ostrożność:

1. **Accessibility**:
- Pliki na external storage są globalnie czytelne i zapisywalne. Oznacza to, że dowolna aplikacja lub użytkownik może uzyskać do nich dostęp.
2. **Security Concerns**:
- Ze względu na łatwy dostęp, zaleca się **nie przechowywać wrażliwych informacji** na external storage.
- External storage może zostać usunięty lub odczytany przez dowolną aplikację, co czyni go mniej bezpiecznym.
3. **Handling Data from External Storage**:
- Zawsze **waliduj dane wejściowe** pobrane z external storage. To kluczowe, ponieważ dane pochodzą z nieufnego źródła.
- Odradza się przechowywanie plików wykonywalnych lub klas na external storage w celu dynamicznego ładowania.
- Jeśli Twoja aplikacja musi pobierać pliki wykonywalne z external storage, upewnij się, że pliki te są **podpisane i kryptograficznie zweryfikowane** zanim zostaną dynamicznie załadowane. Ten krok jest kluczowy dla zachowania integralności bezpieczeństwa aplikacji.

External storage można uzyskać pod ścieżkami /storage/emulated/0 , /sdcard , /mnt/sdcard

> [!TIP]
> Począwszy od Android 4.4 (**API 17**) struktura katalogów na SD card ogranicza dostęp aplikacji do katalogu przeznaczonego specjalnie dla tej aplikacji. Zapobiega to uzyskaniu przez złośliwą aplikację dostępu odczytu lub zapisu do plików innej aplikacji.

**Sensitive data stored in clear-text**

- **Shared preferences**: Android pozwala każdej aplikacji na łatwe zapisywanie plików xml w ścieżce `/data/data/<packagename>/shared_prefs/` i czasami można znaleźć wrażliwe informacje w postaci jawnej w tym folderze.
- **Databases**: Android pozwala każdej aplikacji na łatwe zapisywanie sqlite databases w ścieżce `/data/data/<packagename>/databases/` i czasami można znaleźć wrażliwe informacje w postaci jawnej w tym folderze.

### Broken TLS

**Accept All Certificates**

Z jakiegoś powodu niektórzy deweloperzy akceptują wszystkie certyfikaty, nawet jeśli np. hostname nie pasuje, z użyciem fragmentów kodu takich jak poniższy:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Dobrym sposobem na przetestowanie tego jest próba przechwycenia ruchu za pomocą proxy takiego jak Burp bez autoryzowania Burp CA na urządzeniu. Możesz też wygenerować za pomocą Burp certyfikat dla innego hosta i go użyć.

### Broken Cryptography

**Poor Key Management Processes**

Niektórzy deweloperzy zapisują dane wrażliwe w local storage i szyfrują je kluczem zaszytym/wyszukiwalnym w kodzie. Nie powinno się tego robić, ponieważ analiza odwrotna może pozwolić atakującym na wyodrębnienie poufnych informacji.

**Use of Insecure and/or Deprecated Algorithms**

Deweloperzy nie powinni używać **deprecated algorithms** do wykonywania **checks** autoryzacyjnych, **store** lub **send** danych. Niektóre z tych algorytmów to: RC4, MD4, MD5, SHA1... Jeśli **hashes** są używane do przechowywania haseł na przykład, powinny być stosowane mechanizmy odporne na brute-force wraz z salt.

### Other checks

- Zaleca się **obfuskować APK**, aby utrudnić analizę odwrotną atakującym.
- Jeśli aplikacja jest wrażliwa (np. aplikacje bankowe), powinna wykonywać **własne sprawdzenia, czy urządzenie jest rootowane** i działać odpowiednio.
- Jeśli aplikacja jest wrażliwa (np. aplikacje bankowe), powinna sprawdzać, czy używany jest **emulator**.
- Jeśli aplikacja jest wrażliwa (np. aplikacje bankowe), powinna **sprawdzić swoją integralność przed uruchomieniem**, aby upewnić się, że nie została zmodyfikowana.
- Użyj [**APKiD**](https://github.com/rednaga/APKiD) aby sprawdzić, który compiler/packer/obfuscator został użyty do zbudowania APK

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

Narzędzie [**mariana-trench**](https://github.com/facebook/mariana-trench) potrafi znaleźć **vulnerabilities** poprzez **scanning** **code** aplikacji. To narzędzie zawiera zestaw **known sources** (wskazujących miejsc, gdzie **input** jest **kontrolowany przez użytkownika**), **sinks** (wskazujących **dangerous** **miejsca**, gdzie złośliwy input użytkownika może spowodować szkody) oraz **rules**. Te reguły wskazują **kombinacje** **sources-sinks** które oznaczają podatność.

Z tą wiedzą, **mariana-trench przeanalizuje kod i znajdzie możliwe podatności**.

### Secrets leaked

Aplikacja może zawierać secrets (API keys, hasła, ukryte URL-e, subdomeny...) wewnątrz, które możesz być w stanie odkryć. Możesz użyć narzędzia takiego jak [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)
- In-memory native code execution via JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> First of all, you need an environment where you can install the application and all the environment (Burp CA cert, Drozer and Frida mainly). Therefore, a rooted device (emulated or not) is extremely recommended.

### Online Dynamic analysis

Możesz założyć **darmowe konto** na: [https://appetize.io/](https://appetize.io). Ta platforma pozwala **upload** i **execute** APK, więc jest przydatna do obserwowania jak apk się zachowuje.

Możesz nawet **zobaczyć logi swojej aplikacji** w przeglądarce i połączyć się przez **adb**.

![](<../../images/image (831).png>)

Dzięki połączeniu ADB możesz używać **Drozer** i **Frida** wewnątrz emulatorów.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (Możesz tworzyć urządzenia **x86** i **arm**, i zgodnie z [**tym** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**najnowsze x86** wersje **wspierają biblioteki ARM** bez potrzeby używania wolnego emulatora ARM).
- Naucz się jak to skonfigurować na tej stronie:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, trzeba założyć konto. _Zaleca się **pobrać** wersję **WITH**_ _**VirtualBox** aby uniknąć potencjalnych błędów._)
- [**Nox**](https://es.bignox.com) (Darmowy, ale nie wspiera Frida ani Drozer).

> [!TIP]
> Przy tworzeniu nowego emulatora na dowolnej platformie pamiętaj, że im większy ekran, tym wolniej emulator będzie działać. Dlatego wybieraj małe ekrany, jeśli to możliwe.

Aby **zainstalować google services** (jak AppStore) w Genymotion musisz kliknąć na czerwony przycisk zaznaczony na poniższym obrazku:

![](<../../images/image (277).png>)

Zauważ też, że w **konfiguracji VM Androida w Genymotion** możesz wybrać **Bridge Network mode** (to będzie przydatne, jeśli będziesz łączyć się z Android VM z innej VM z narzędziami).

#### Use a physical device

Musisz włączyć **opcje debugowania**, a dobrze by było, gdybyś mógł je **zrootować**:

1. **Settings**.
2. (FromAndroid 8.0) Wybierz **System**.
3. Wybierz **About phone**.
4. Naciśnij **Build number** 7 razy.
5. Wróć i znajdziesz **Developer options**.

> Po zainstalowaniu aplikacji, pierwszą rzeczą, którą powinieneś zrobić, jest jej uruchomienie, zbadanie co robi, jak działa i zapoznanie się z nią.\
> Sugeruję wykonanie tej początkowej dynamicznej analizy używając MobSF dynamic analysis + pidcat, dzięki czemu będziemy w stanie **nauczyć się jak działa aplikacja**, podczas gdy MobSF **przechwyci** wiele **interesujących** **danych**, które będziesz mógł przeanalizować później.

Magisk/Zygisk quick notes (recommended on Pixel devices)
- Patch boot.img with the Magisk app and flash via fastboot to get systemless root
- Enable Zygisk + DenyList for root hiding; consider LSPosed/Shamiko when stronger hiding is required
- Keep original boot.img to recover from OTA updates; re-patch after each OTA
- For screen mirroring, use scrcpy on the host



### Unintended Data Leakage

**Logging**

Deweloperzy powinni uważać, aby nie ujawniać **debugging information** publicznie, ponieważ może to prowadzić do wycieku wrażliwych danych. Narzędzia [**pidcat**](https://github.com/JakeWharton/pidcat) i `adb logcat` są polecane do monitorowania logów aplikacji w celu identyfikacji i ochrony informacji wrażliwych. **Pidcat** jest preferowany ze względu na łatwość użycia i czytelność.

> [!WARNING]
> Zauważ, że od **wersji nowszych niż Android 4.0**, **aplikacje mają dostęp tylko do własnych logów**. Więc aplikacje nie mogą uzyskać dostępu do logów innych aplikacji.\
> Mimo to, nadal zaleca się **nie logować informacji wrażliwych**.

**Copy/Paste Buffer Caching**

Androidowy **clipboard-based** framework umożliwia funkcjonalność kopiuj-wklej w aplikacjach, jednak stwarza ryzyko, ponieważ **inne aplikacje** mogą **dostępować** się do schowka, potencjalnie ujawniając wrażliwe dane. Istotne jest, aby **wyłączyć funkcje kopiuj/wklej** dla wrażliwych sekcji aplikacji, takich jak dane karty kredytowej, aby zapobiec leakom.

**Crash Logs**

Jeśli aplikacja **crashuje** i **zapisuje logi**, te logi mogą pomóc atakującym, szczególnie gdy aplikacja nie może być odwrócona (reverse-engineered). Aby złagodzić to ryzyko, unikaj logowania przy crashach, a jeśli logi muszą być przesyłane przez sieć, upewnij się, że są wysyłane przez kanał SSL.

Jako pentester, **spróbuj przejrzeć te logi**.

**Analytics Data Sent To 3rd Parties**

Aplikacje często integrują serwisy takie jak Google Adsense, które mogą nieumyślnie **leak sensitive data** z powodu niewłaściwej implementacji przez deweloperów. Aby zidentyfikować potencjalne wycieki danych, warto **przechwycić ruch aplikacji** i sprawdzić, czy jakiekolwiek wrażliwe informacje są wysyłane do usług stron trzecich.

### SQLite DBs

Większość aplikacji używa **internal SQLite databases** do zapisywania informacji. Podczas pentestu przejrzyj **databases** utworzone, nazwy **tables** i **columns** oraz wszystkie zapisywane **data**, ponieważ możesz znaleźć **sensitive information** (co byłoby podatnością).\
Bazy danych powinny być zlokalizowane w `/data/data/the.package.name/databases` jak `/data/data/com.mwr.example.sieve/databases`

Jeśli baza danych przechowuje poufne informacje i jest **encrypted** ale możesz **znaleźć** **password** wewnątrz aplikacji, to nadal jest to **podatność**.

Wylicz tabele używając `.tables` i wyświetl schemat kolumn tabel używając `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** pozwala Ci **przyjąć rolę aplikacji Android** i wchodzić w interakcje z innymi aplikacjami. Może robić **wszystko, co może zrobić zainstalowana aplikacja**, takie jak używanie mechanizmu Inter-Process Communication (IPC) Androida oraz interakcję z systemem operacyjnym. .\
Drozer jest przydatnym narzędziem do **eksploatowania exported activities, exported services i Content Providers**, jak poznasz w kolejnych sekcjach.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Pamiętaj też, że kod activity zaczyna się w metodzie **`onCreate`**.

**Authorisation bypass**

Gdy Activity jest exported możesz wywołać jej ekran z zewnętrznej aplikacji. W związku z tym, jeśli activity z **sensitive information** jest **exported**, możesz **bypass** mechanizmy **authentication**, aby uzyskać do niej dostęp.

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

Możesz też uruchomić exported activity z adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**UWAGA**: MobSF będzie wykrywać jako złośliwe użycie _**singleTask/singleInstance**_ jako `android:launchMode` w activity, ale z powodu [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), najwyraźniej jest to niebezpieczne tylko na starych wersjach (API versions < 21).

> [!TIP]
> Zauważ, że an authorisation bypass nie zawsze jest podatnością — zależy to od tego, jak bypass działa i jakie informacje są ujawniane.

**Ujawnianie wrażliwych informacji**

Activities mogą również zwracać wyniki. Jeśli uda ci się znaleźć exported i niezabezpieczoną activity wywołującą metodę **`setResult`** i **zwracającą wrażliwe informacje**, występuje ujawnienie wrażliwych informacji.

#### Tapjacking

Jeśli Tapjacking nie jest zapobiegane, możesz wykorzystać exported activity, aby zmusić **użytkownika do wykonania nieoczekiwanych akcji**. Po więcej informacji o [**czym jest Tapjacking — zobacz**](#tapjacking).

### Wykorzystywanie Content Providers - Dostęp i manipulacja wrażliwymi informacjami

[**Przeczytaj to jeśli chcesz odświeżyć, czym jest Content Provider.**](android-applications-basics.md#content-provider)\
Content providers są zasadniczo używane do **dzielenia się danymi**. Jeśli aplikacja ma dostępne content providers, możesz być w stanie **wyekstrahować wrażliwe** dane z nich. Warto też przetestować możliwe **SQL injections** i **Path Traversals**, ponieważ mogą być podatne.

[**Dowiedz się, jak wykorzystać Content Providers za pomocą Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Przeczytaj to jeśli chcesz odświeżyć, czym jest Service.**](android-applications-basics.md#services)\
Pamiętaj, że działania Service zaczynają się w metodzie `onStartCommand`.

Service to w zasadzie coś, co **może otrzymywać dane**, **przetwarzać** je i **zwracać** (lub nie) odpowiedź. Jeśli aplikacja eksportuje jakieś services, powinieneś **sprawdzić** **kod**, aby zrozumieć, co robi, i **przetestować** go **dynamicznie** w celu wydobycia poufnych informacji, obejścia mechanizmów uwierzytelniania...
[**Dowiedz się jak wykorzystać Services za pomocą Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Przeczytaj to jeśli chcesz odświeżyć, czym jest Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Pamiętaj, że działania Broadcast Receiver zaczynają się w metodzie `onReceive`.

Broadcast receiver będzie oczekiwać na pewien typ wiadomości. W zależności od tego, jak receiver obsługuje wiadomość, może być podatny.\
[**Dowiedz się jak wykorzystać Broadcast Receivers za pomocą Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Możesz wyszukać deep links ręcznie, używając narzędzi takich jak MobSF lub skryptów takich jak [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Możesz **otworzyć** zadeklarowany **scheme** używając **adb** lub **przeglądarki**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Zauważ, że możesz **pominąć nazwę pakietu** i urządzenie mobilne automatycznie wywoła aplikację, która powinna otworzyć ten link._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Kod wykonywany**

Aby znaleźć **kod, który zostanie wykonany w aplikacji**, przejdź do activity wywołanej przez deeplink i wyszukaj funkcję **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Wrażliwe dane**

Za każdym razem, gdy znajdziesz deep link, sprawdź, czy **nie odbiera on wrażliwych danych (np. haseł) przez parametry URL**, ponieważ każda inna aplikacja mogłaby **podszyć się pod ten deep link i ukraść te dane!**

**Parametry w ścieżce**

Musisz również sprawdzić, czy któryś deep link nie używa parametru w ścieżce URL, np.: `https://api.example.com/v1/users/{username}` , w takim przypadku możesz wymusić path traversal uzyskując dostęp do czegoś takiego: `example://app/users?username=../../unwanted-endpoint%3fparam=value`.\
Zauważ, że jeśli znajdziesz odpowiednie endpoints w aplikacji, możesz spowodować **Open Redirect** (jeśli część ścieżki jest używana jako nazwa domeny), **account takeover** (jeśli możesz zmodyfikować dane użytkownika bez tokena CSRF i podatny endpoint użył właściwej metody) i inne luki. More [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Transport Layer Inspection and Verification Failures

- **Certificates are not always inspected properly** by Android applications. It's common for these applications to overlook warnings and accept self-signed certificates or, in some instances, revert to using HTTP connections.
- **Negotiations during the SSL/TLS handshake are sometimes weak**, employing insecure cipher suites. This vulnerability makes the connection susceptible to man-in-the-middle (MITM) attacks, allowing attackers to decrypt the data.
- **Wycieki informacji prywatnych** są ryzykiem, kiedy aplikacje uwierzytelniają się przy użyciu bezpiecznych kanałów, a następnie komunikują się przez kanały niezabezpieczone przy innych operacjach. Takie podejście nie chroni wrażliwych danych, takich jak session cookies czy dane użytkownika, przed przechwyceniem przez podmioty złośliwe.

#### Certificate Verification

Skoncentrujemy się na **certificate verification**. Integralność certyfikatu serwera musi być zweryfikowana, aby zwiększyć bezpieczeństwo. Jest to kluczowe, ponieważ niebezpieczne konfiguracje TLS i przesyłanie wrażliwych danych przez niezaszyfrowane kanały mogą stanowić poważne ryzyko. Dla szczegółowych kroków dotyczących weryfikacji certyfikatów serwera i naprawy luk, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) provides comprehensive guidance.

#### SSL Pinning

SSL Pinning to środek bezpieczeństwa, w którym aplikacja weryfikuje certyfikat serwera względem znanej kopii przechowywanej w samej aplikacji. Ta metoda jest istotna w zapobieganiu atakom MITM. Zdecydowanie zaleca się implementację SSL Pinning w aplikacjach przetwarzających wrażliwe informacje.

#### Traffic Inspection

Aby inspect HTTP traffic, konieczne jest **zainstalowanie certyfikatu narzędzia proxy** (np. Burp). Bez zainstalowania tego certyfikatu zaszyfrowany ruch może być niewidoczny przez proxy. Dla przewodnika instalacji custom CA certificate, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Aplikacje targetujące **API Level 24 and above** wymagają modyfikacji Network Security Config, aby zaakceptować CA certificate proxy. Ten krok jest kluczowy do inspekcji szyfrowanego ruchu. Aby uzyskać instrukcje dotyczące modyfikacji Network Security Config, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

Jeśli używany jest **Flutter**, musisz postępować zgodnie z instrukcjami na [**this page**](flutter.md). Jest tak, ponieważ samo dodanie certyfikatu do store nie wystarczy — Flutter ma własną listę zatwierdzonych CAs.

#### Static detection of SSL/TLS pinning

Zanim spróbujesz runtime bypasses, szybko zmapuj, gdzie pinning jest egzekwowany w APK. Wykrywanie statyczne pomaga zaplanować hooków/patchy i skupić się na właściwych ścieżkach kodu.

Tool: SSLPinDetect
- Open-source static-analysis utility that decompiles the APK to Smali (via apktool) and scans for curated regex patterns of SSL/TLS pinning implementations.
- Reports exact file path, line number, and a code snippet for each match.
- Covers common frameworks and custom code paths: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Użycie
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Przykładowe reguły wzorców (JSON)
Użyj lub rozszerz signatures, aby wykrywać własnościowe/niestandardowe style pinning. Możesz wczytać własne JSON i skanować na dużą skalę.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notatki i wskazówki
- Szybkie skanowanie dużych aplikacji przez wielowątkowość i memory-mapped I/O; pre-compiled regex zmniejsza narzut/false positives.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Typowe cele wykrywania do dalszej analizy:
- OkHttp: użycie CertificatePinner, setCertificatePinner, odwołania do pakietu okhttp3/okhttp
- Niestandardowe TrustManagers: javax.net.ssl.X509TrustManager, przeciążenia checkServerTrusted
- Niestandardowe konteksty SSL: SSLContext.getInstance + SSLContext.init z niestandardowymi managerami
- Deklaratywne piny w res/xml network security config i odwołania w manifeście
- Wykorzystaj dopasowane lokalizacje, aby zaplanować Frida hooks, statyczne łaty (static patches) lub przeglądy konfiguracji przed testami dynamicznymi.



#### Bypassing SSL Pinning

Gdy SSL Pinning jest zaimplementowany, jego obejście staje się konieczne, aby przeanalizować ruch HTTPS. Do tego celu dostępne są różne metody:

- Automatically **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). The best pro of this option, is that you won't need root to bypass the SSL Pinning, but you will need to delete the application and reinstall the new one, and this won't always work.
- You could use **Frida** (discussed below) to bypass this protection. Here you have a guide to use Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- You can also try to **automatically bypass SSL Pinning** using [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- You can also try to **automatically bypass SSL Pinning** using **MobSF dynamic analysis** (explained below)
- If you still think that there is some traffic that you aren't capturing you can try to **forward the traffic to burp using iptables**. Read this blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Looking for Common Web Vulnerabilities

Ważne jest również wyszukiwanie typowych podatności webowych w aplikacji. Szczegółowe informacje dotyczące identyfikacji i łagodzenia tych podatności wykraczają poza zakres tego podsumowania, ale są szeroko omówione w innych źródłach.

### Frida

[Frida](https://www.frida.re) to zestaw narzędzi do dynamicznej instrumentacji dla deweloperów, reverse-engineerów i badaczy bezpieczeństwa.\
**Możesz uzyskać dostęp do uruchomionej aplikacji i hookować metody w czasie wykonywania, aby zmieniać zachowanie, zmieniać wartości, wyodrębniać wartości, uruchamiać inny kod...**\
Jeśli chcesz pentestować aplikacje Android musisz umieć używać Frida.

- Naucz się korzystać z Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Some "GUI" for actions with Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- You can find some Awesome Frida scripts here: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Spróbuj obejść anti-debugging / anti-frida mechanizmy ładując Frida zgodnie z tym opisem: [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (narzędzie [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

Sprawdź, czy aplikacja nie przechowuje w pamięci poufnych informacji, których nie powinna trzymać, takich jak hasła czy mnemoniki.

Using [**Fridump3**](https://github.com/rootbsd/fridump3) you can dump the memory of the app with:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
To zrobi dump pamięci w folderze ./dump, a tam możesz użyć grep, na przykład:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Wrażliwe dane w Keystore**

W Androidzie Keystore jest najlepszym miejscem do przechowywania wrażliwych danych, jednak przy wystarczających uprawnieniach wciąż **możliwe jest uzyskanie do niego dostępu**.

Ponieważ aplikacje mają tendencję do przechowywania tutaj **wrażliwych danych w postaci jawnego tekstu**, pentests powinny to sprawdzić — root user lub osoba z fizycznym dostępem do urządzenia mogłaby ukraść te dane.

Nawet jeśli aplikacja przechowuje dane w keystore, dane te powinny być zaszyfrowane.

Aby uzyskać dostęp do danych wewnątrz keystore możesz użyć tego Frida script: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Używając poniższego Frida scriptu, możliwe jest **bypass fingerprint authentication**, które aplikacje Android mogą wymagać, aby **chronić określone wrażliwe obszary:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Obrazy w tle**

Kiedy umieścisz aplikację w tle, Android zapisuje **zrzut aplikacji** tak, że po przywróceniu na pierwszy plan zaczyna najpierw ładować obraz, zanim uruchomi się aplikacja, dzięki czemu wygląda, jakby aplikacja załadowała się szybciej.

Jednak jeśli ten zrzut zawiera **wrażliwe informacje**, ktoś mający dostęp do zrzutu może **ukraść te dane** (uwaga: dostęp do niego wymaga root).

Zrzuty są zwykle przechowywane w: **`/data/system_ce/0/snapshots`**

Android udostępnia sposób, aby **zapobiec przechwytywaniu zrzutów ekranu przez ustawienie parametru layout FLAG_SECURE**. Używając tej flagi, zawartość okna jest traktowana jako bezpieczna, co zapobiega jej pojawianiu się w zrzutach ekranu oraz wyświetlaniu na niezabezpieczonych wyświetlaczach.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

This tool could help you managing different tools during the dynamic analysis: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Deweloperzy często tworzą komponenty-proxy takie jak activities, services i broadcast receivers, które obsługują te Intents i przekazują je do metod takich jak `startActivity(...)` lub `sendBroadcast(...)`, co może być ryzykowne.

Niebezpieczeństwo polega na umożliwieniu atakującym wywołania non-exported app components lub dostępu do wrażliwych content providers przez przekierowanie tych Intents. Przykładem jest komponent `WebView` konwertujący URL-e na obiekty `Intent` za pomocą `Intent.parseUri(...)` i następnie je wykonujący, co może prowadzić do złośliwych Intent injections.

### Essential Takeaways

- **Intent Injection** jest podobne do web's Open Redirect issue.
- Exploits involve passing `Intent` objects as extras, which can be redirected to execute unsafe operations.
- It can expose non-exported components and content providers to attackers.
- `WebView`’s URL to `Intent` conversion can facilitate unintended actions.

### Android Client Side Injections and others

Pewnie znasz ten typ podatności z Weba. Musisz być szczególnie ostrożny wobec tych podatności w aplikacji Android:

- **SQL Injection:** W przypadku dynamicznych zapytań lub Content-Providers upewnij się, że używasz zapytań parametryzowanych.
- **JavaScript Injection (XSS):** Upewnij się, że obsługa JavaScript i Pluginów jest wyłączona dla wszystkich WebViews (domyślnie wyłączona). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews powinny mieć wyłączony dostęp do systemu plików (domyślnie włączony) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: W wielu przypadkach, gdy aplikacja Android kończy sesję, cookie nie jest unieważnione lub może być zapisane na dysku
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Analiza statyczna**

![](<../../images/image (866).png>)

**Ocena podatności aplikacji** z użyciem ładnego webowego frontendu. Możesz też przeprowadzić analizę dynamiczną (ale musisz przygotować środowisko).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Zauważ, że MobSF potrafi analizować **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Wspomagana analiza dynamiczna z MobSF

**MobSF** może też być bardzo pomocny przy **analiza dynamiczna** w **Android**, ale w tym przypadku musisz zainstalować MobSF i **genymotion** na hoście (a VM lub Docker won't work). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
The **MobSF dynamic analyser** can:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). All of this is done automatically except for the screenshots, you need to press when you want a screenshot or you need to press "**Exported Activity Tester**" to obtain screenshots of all the exported activities.
- Przechwytywać **ruch HTTPS**
- Użyć **Frida** do uzyskania informacji w czasie wykonywania

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: It will print all the loaded classes
- **Capture Strings**: It will print all the capture strings while using the application (super noisy)
- **Capture String Comparisons**: Could be very useful. It will **show the 2 strings being compared** and if the result was True or False.
- **Enumerate Class Methods**: Put the class name (like "java.io.File") and it will print all the methods of the class.
- **Search Class Pattern**: Search classes by pattern
- **Trace Class Methods**: **Trace** a **whole class** (see inputs and outputs of all methods of th class). Remember that by default MobSF traces several interesting Android Api methods.

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf also brings you a shell with some **adb** commands, **MobSF commands**, and common **shell** **commands** at the bottom of the dynamic analysis page. Some interesting commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**Narzędzia HTTP**

Kiedy ruch http jest przechwycony możesz zobaczyć nieładny widok przechwyconego ruchu na dolnym przycisku "**HTTP(S) Traffic**" lub ładniejszy widok w zielonym przycisku "**Start HTTPTools**". Z drugiej opcji możesz **wysłać** **przechwycone żądania** do **proxies** takich jak Burp lub Owasp ZAP.\
Aby to zrobić, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> naciśnij "**Send to Fuzzer**" --> _wybierz adres proxy_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Po zakończeniu analizy dynamicznej z MobSF możesz wcisnąć "**Start Web API Fuzzer**", aby **fuzzować http requests** i szukać podatności.

> [!TIP]
> Po przeprowadzeniu analizy dynamicznej z MobSF ustawienia proxy mogą być źle skonfigurowane i nie będziesz mógł ich naprawić z poziomu GUI. Możesz naprawić ustawienia proxy wykonując:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

Narzędzie można pobrać z [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
To narzędzie używa pewnych **Hooks**, aby poinformować Cię **co dzieje się w aplikacji** podczas przeprowadzania **dynamic analysis**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

To **świetne narzędzie do przeprowadzania statycznej analizy z GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Narzędzie to zostało zaprojektowane do wyszukiwania różnych **security related Android application vulnerabilities**, zarówno w **source code**, jak i w **packaged APKs**. Narzędzie jest również **capable of creating a "Proof-of-Concept" deployable APK** oraz **ADB commands**, aby wykorzystać niektóre z odnalezionych podatności (Exposed activities, intents, tapjacking...). Podobnie jak w przypadku Drozer, nie ma potrzeby rootowania urządzenia testowego.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Wyświetla wszystkie wyodrębnione pliki do szybkiego wglądu
- Automatycznie dekompiluje pliki APK do formatu Java i Smali
- Analizuje AndroidManifest.xml pod kątem typowych podatności i zachowań
- Statyczna analiza kodu źródłowego pod kątem typowych podatności i zachowań
- Informacje o urządzeniu
- i więcej
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER to aplikacja uruchamiana z linii poleceń, którą można używać w Windows, MacOS X i Linux; analizuje pliki _.apk_ w poszukiwaniu podatności. Robi to poprzez rozpakowywanie plików APK i stosowanie szeregu reguł w celu wykrycia tych podatności.

Wszystkie reguły znajdują się w pliku `rules.json`, a każda firma lub tester może stworzyć własne reguły, aby analizować to, czego potrzebują.

Pobierz najnowsze binaria ze [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn to narzędzie **wieloplatformowe**, które pomaga deweloperom, bugbounty hunters i ethical hackers przeprowadzać [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) aplikacji mobilnych.

Koncepcja polega na przeciągnięciu i upuszczeniu pliku aplikacji mobilnej (plik .apk lub .ipa) na aplikację StaCoAn, która wygeneruje dla Ciebie wizualny i przenośny raport. Możesz dostosować ustawienia i wordlists, aby uzyskać spersonalizowane doświadczenie.

Pobierz[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework to system analizy podatności dla Androida, który pomaga deweloperom i hakerom znaleźć potencjalne luki w zabezpieczeniach w aplikacjach Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** to narzędzie, którego głównym celem jest wykrywanie i ostrzeganie użytkownika o potencjalnie złośliwych zachowaniach przejawianych przez aplikację Android.

Wykrywanie odbywa się za pomocą **analizy statycznej** Dalvik bytecode aplikacji, reprezentowanego jako **Smali**, przy użyciu biblioteki [`androguard`](https://github.com/androguard/androguard).

Narzędzie poszukuje **typowych zachowań "złych" aplikacji** takich jak: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** to framework do reverse engineeringu i analizy aplikacji mobilnych (Mobile Application Reverse engineering and Analysis Framework). Jest to narzędzie łączące powszechnie używane narzędzia do reverse engineeringu i analizy aplikacji mobilnych, wspomagające testowanie aplikacji mobilnych pod kątem zagrożeń z OWASP mobile security. Jego celem jest ułatwienie tego zadania deweloperom aplikacji mobilnych oraz specjalistom ds. bezpieczeństwa.

Potrafi:

- Extract Java and Smali code using different tools
- Analizować APKi przy użyciu: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Wydobywać prywatne informacje z APK za pomocą regexps.
- Analizować Manifest.
- Analizować znalezione domeny przy użyciu: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) i [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuskować APK za pomocą [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Przydatne do wykrywania malware: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Zwróć uwagę, że w zależności od usługi i konfiguracji użytej do obfuskacji kodu, sekrety mogą, ale nie muszą być obfuskowane.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

Z [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** jest otwartoźródłowym narzędziem wiersza poleceń, które zmniejsza rozmiar, optymalizuje i obfuskije kod Java. Potrafi optymalizować bytecode oraz wykrywać i usuwać nieużywane instrukcje. ProGuard jest wolnym oprogramowaniem i jest dystrybuowany na licencji GNU General Public License, version 2.

ProGuard jest dystrybuowany jako część Android SDK i uruchamia się podczas budowania aplikacji w trybie release.

### [DexGuard](https://www.guardsquare.com/dexguard)

Znajdziesz przewodnik krok po kroku jak deobfuskować apk w [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(Z tego przewodnika) Ostatnio, gdy sprawdzano, tryb działania Dexguard był następujący:

- wczytać zasób jako InputStream;
- przekazać wynik do klasy dziedziczącej po FilterInputStream w celu jego odszyfrowania;
- wykonać bezsensowną obfuskację, żeby zmarnować kilka minut pracy reversera;
- przekazać odszyfrowany wynik do ZipInputStream, aby uzyskać plik DEX;
- na końcu załadować powstały DEX jako Resource używając metody `loadDex`.

### [DeGuard](http://apk-deguard.com)

**DeGuard odwraca proces obfuskacji wykonywany przez narzędzia do obfuskacji Androida. Umożliwia to liczne analizy bezpieczeństwa, w tym inspekcję kodu i identyfikację bibliotek.**

Możesz przesłać obfuskowany APK na ich platformę.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

To narzędzie LLM do znajdowania potencjalnych luk w zabezpieczeniach w aplikacjach android oraz deobfuskacji kodu aplikacji android. Używa publicznego API Gemini Google.

### [Simplify](https://github.com/CalebFenton/simplify)

To ogólny deobfuskator dla androida. Simplify **praktycznie wykonuje aplikację** aby zrozumieć jej zachowanie, a następnie **próbuje zoptymalizować kod**, tak żeby zachowywał się identycznie, ale był łatwiejszy do zrozumienia dla człowieka. Każdy typ optymalizacji jest prosty i ogólny, więc nie ma znaczenia jaki konkretny typ obfuskacji został użyty.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD dostarcza informacji o **tym, jak APK zostało stworzone**. Identyfikuje wiele **kompilatorów**, **packerów**, **obfuskatorów** i innych dziwnych rzeczy. To [_PEiD_](https://www.aldeid.com/wiki/PEiD) dla Androida.

### Manual

[Przeczytaj ten tutorial, aby nauczyć się kilku trików dotyczących **odwracania niestandardowej obfuskacji**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b to wirtualna maszyna do bezpieczeństwa Androida oparta na ubuntu-mate, zawierająca zbiór najnowszych frameworków, tutoriali i laboratoriów od różnych entuzjastów bezpieczeństwa i badaczy do reverse engineeringu i analizy malware.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) To świetna lista zasobów
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Krótkie wprowadzenie do reverse engineeringu aplikacji Android
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
