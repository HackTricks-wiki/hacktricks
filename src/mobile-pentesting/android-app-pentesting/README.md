# Android 애플리케이션 Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android 애플리케이션 기초

이 페이지를 먼저 읽어 Android 보안과 Android 애플리케이션에서 가장 위험한 구성 요소들과 관련된 **가장 중요한 부분들**에 대해 아는 것을 강력히 권장합니다:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

이것은 emulated 또는 physical Android device에 연결하기 위해 필요한 주요 도구입니다.\
**ADB**를 통해 컴퓨터에서 **USB** 또는 **Network**를 통해 장치를 제어할 수 있습니다. 이 유틸리티는 파일의 양방향 copying, 앱의 installation 및 uninstallation, shell commands의 execution, 데이터의 backing up, 로그의 reading 등 다양한 기능을 제공합니다.

adb 사용법을 배우려면 다음 [**ADB Commands**](adb-commands.md) 목록을 확인하세요.

## Smali

때때로 숨겨진 정보(예: 잘 난독화된 passwords 또는 flags)에 접근하기 위해 애플리케이션 코드를 modify하는 것이 유용할 수 있습니다. 이럴 경우 apk를 decompile하고 코드를 수정한 뒤 다시 recompile하는 것이 흥미로운 방법이 될 수 있습니다.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). 이 방법은 이후에 제시될 dynamic analysis 동안의 여러 테스트에 대한 대안으로 매우 유용할 수 있습니다. 항상 이 가능성을 염두에 두세요.

## 기타 흥미로운 트릭

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Play Integrity attestation spoofing (SafetyNet replacement)](play-integrity-attestation-bypass.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [Android IME / InputMethodService Abuse (Malicious Keyboards)](inputmethodservice-ime-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- 기기에서 APK 추출:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- 모든 splits 및 base apks를 [APKEditor](https://github.com/REAndroid/APKEditor)로 병합:
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Android Enterprise & Work Profile Attacks

{{#ref}}
android-enterprise-work-profile-bypass.md
{{#endref}}

## 사례 연구 및 취약점


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

{{#ref}}
abusing-android-media-pipelines-image-parsers.md
{{#endref}}

{{#ref}}
../../binary-exploitation/linux-kernel-exploitation/arm64-static-linear-map-kaslr-bypass.md
{{#endref}}

## 정적 분석

무엇보다도, APK를 분석할 때는 디컴파일러를 사용해 **Java 코드를 살펴보는 것**이 좋습니다.\
다양한 사용 가능한 디컴파일러에 관한 정보를 찾으려면 [**여기에서 읽어보세요**](apk-decompilers.md).

### 흥미로운 정보 찾기

APK의 **문자열**만 살펴봐도 **비밀번호**, **URL**, **API 키**, **암호화 관련 항목**, **bluetooth uuids**, **토큰** 등 흥미로운 것을 검색할 수 있습니다... 코드 실행용 **백도어**나 인증 백도어(앱에 하드코딩된 관리자 자격증명)도 찾아보세요.

**Firebase**

**firebase URLs**에 특히 주의하고 설정이 잘못되어 있는지 확인하세요. [Firebase가 무엇이며 이를 어떻게 악용할 수 있는지에 대한 자세한 정보는 여기에서 확인하세요.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### 애플리케이션의 기본 이해 - Manifest.xml, strings.xml

**애플리케이션의 _Manifest.xml_ 및 **_strings.xml_** 파일을 검사하면 잠재적인 보안 취약점을 드러낼 수 있습니다**. 이 파일들은 디컴파일러를 사용하거나 APK 파일 확장자를 .zip으로 바꾼 뒤 압축을 풀어 접근할 수 있습니다.

**Manifest.xml**에서 식별되는 취약점에는 다음이 포함됩니다:

- **Debuggable Applications**: _Manifest.xml_ 파일에서 `debuggable="true"`로 설정된 애플리케이션은 연결을 허용하여 악용될 수 있으므로 위험합니다. 디버깅 가능 애플리케이션을 찾아 장치에서 악용하는 방법에 대한 튜토리얼을 참조하세요.
- **Backup Settings**: 민감한 정보를 다루는 애플리케이션은 `android:allowBackup="false"` 속성을 명시적으로 설정해야 하며, 특히 USB 디버깅이 활성화된 경우 adb를 통한 무단 데이터 백업을 방지해야 합니다.
- **Network Security**: `android:networkSecurityConfig="@xml/network_security_config"` 같은 맞춤 네트워크 보안 구성(res/xml/)은 인증서 핀 및 HTTP 트래픽 설정 등 보안 세부사항을 지정할 수 있습니다. 예를 들어 특정 도메인에 대해 HTTP 트래픽을 허용할 수 있습니다.
- **Exported Activities and Services**: 매니페스트에서 내보내진 Activities와 Services를 식별하면 오용될 수 있는 구성 요소를 드러낼 수 있습니다. 동적 테스트 중 추가 분석을 통해 이러한 구성 요소를 어떻게 악용할 수 있는지 확인하세요.
- **Content Providers and FileProviders**: 노출된 content provider는 무단으로 데이터에 접근하거나 수정할 수 있게 할 수 있습니다. FileProviders의 구성도 면밀히 검토해야 합니다.
- **Broadcast Receivers and URL Schemes**: 이러한 구성 요소들은 악용에 사용될 수 있으며, 특히 URL 스킴이 입력 취약점에 어떻게 영향을 미치는지 주의 깊게 확인해야 합니다.
- **SDK Versions**: `minSdkVersion`, `targetSDKVersion`, `maxSdkVersion` 속성은 지원되는 Android 버전을 나타내며, 오래되고 취약한 Android 버전을 지원하지 않는 것이 중요함을 보여줍니다.

**strings.xml** 파일에서는 API 키, 커스텀 스키마 및 기타 개발자 노트와 같은 민감한 정보를 발견할 수 있으므로 이러한 리소스를 주의 깊게 검토해야 합니다.

### Tapjacking

**Tapjacking**은 **악성** **애플리케이션**이 실행되어 **피해자 애플리케이션 위에 자신을 위치시키는** 공격입니다. 피해자 앱을 시각적으로 가리고 나면, 공격자의 UI는 사용자를 속여 상호작용하도록 설계되어 있으며, 그 상호작용을 피해자 앱으로 전달합니다.\
결과적으로 사용자는 자신이 실제로 피해자 앱에서 동작을 수행하고 있다는 사실을 알지 못하게 됩니다.

자세한 내용은 다음을 참조하세요:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

`launchMode`가 **`singleTask`**로 설정되어 있고 `taskAffinity`가 정의되어 있지 않은 **activity**는 task Hijacking에 취약합니다. 즉, 악성 **application**이 설치되어 실제 애플리케이션보다 먼저 실행되면 **실제 애플리케이션의 태스크를 하이재킹할 수 있습니다** (사용자는 실제 애플리케이션을 사용하고 있다고 생각하면서 악성 애플리케이션과 상호작용하게 됩니다).

자세한 정보:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Insecure data storage

Internal Storage

Android에서 내부 저장소에 **저장된** 파일은 **이를 생성한 앱만 접근하도록 설계**되어 있습니다. 이 보안 조치는 Android OS에 의해 **강제되며** 대부분의 애플리케이션 보안 요구사항에 적절합니다. 그러나 개발자는 때때로 `MODE_WORLD_READABLE` 및 `MODE_WORLD_WRITABLE`과 같은 모드를 사용해 파일을 다른 애플리케이션 간에 **공유**하도록 허용합니다. 이 모드들은 잠재적으로 악성 애플리케이션을 포함한 다른 애플리케이션이 이러한 파일에 접근하는 것을 **제한하지 못합니다**.

1. **정적 분석:**
- `MODE_WORLD_READABLE` 및 `MODE_WORLD_WRITABLE`의 사용을 **신중히 검토**하세요. 이러한 모드는 파일을 **원치 않거나 무단인 접근**에 노출시킬 수 있습니다.
2. **동적 분석:**
- 앱이 생성한 파일에 설정된 **권한**을 **검증**하세요. 특히 어떤 파일이 **전역적으로 읽기 또는 쓰기가 가능하도록 설정되어 있는지** 확인하세요. 이는 장치에 설치된 **모든 애플리케이션**이 해당 파일을 읽거나 수정할 수 있게 하므로 심각한 보안 위험이 될 수 있습니다.

External Storage

SD 카드와 같은 **외부 저장소**의 파일을 다룰 때는 다음 점을 유의해야 합니다:

1. **접근성**:
- 외부 저장소의 파일은 **전역적으로 읽기 및 쓰기 가능**합니다. 이는 어떤 애플리케이션이나 사용자도 해당 파일에 접근할 수 있음을 의미합니다.
2. **보안 우려**:
- 접근이 쉬우므로 민감한 정보를 외부 저장소에 **저장하지 않는 것이 좋습니다**.
- 외부 저장소는 제거될 수 있거나 어떤 애플리케이션에 의해서든 접근될 수 있어 더 안전하지 않습니다.
3. **외부 저장소에서 가져온 데이터 처리**:
- 외부 저장소에서 가져온 데이터는 항상 **입력 검증**을 수행하세요. 이 데이터는 신뢰할 수 없는 소스에서 온 것이기 때문에 매우 중요합니다.
- 동적 로딩을 위해 외부 저장소에 실행 파일이나 클래스 파일을 저장하는 것은 강력히 권장되지 않습니다.
- 애플리케이션이 외부 저장소에서 실행 파일을 가져와야 한다면, 동적으로 로드하기 전에 이러한 파일이 **서명되어 있고 암호학적으로 검증되었는지** 확인하세요. 이는 애플리케이션의 보안 무결성을 유지하는 데 필수적입니다.

외부 저장소는 /storage/emulated/0 , /sdcard , /mnt/sdcard 에서 접근할 수 있습니다.

> [!TIP]
> Android 4.4(**API 17**)부터 SD 카드에는 앱별로 접근을 제한하는 디렉토리 구조가 도입되었습니다. 이는 악성 애플리케이션이 다른 앱의 파일을 읽거나 쓰는 것을 방지합니다.

**평문으로 저장된 민감한 데이터**

- **Shared preferences**: Android는 각 애플리케이션이 `/data/data/<packagename>/shared_prefs/` 경로에 XML 파일을 쉽게 저장할 수 있도록 허용하며, 때때로 해당 폴더에서 평문으로 된 민감한 정보를 찾을 수 있습니다.
- **Databases**: Android는 각 애플리케이션이 `/data/data/<packagename>/databases/` 경로에 sqlite 데이터베이스를 쉽게 저장할 수 있도록 허용하며, 때때로 해당 폴더에서 평문으로 된 민감한 정보를 찾을 수 있습니다.

### Broken TLS

**Accept All Certificates**

어떤 이유에서인지 개발자들이 호스트명이 일치하지 않더라도 모든 인증서를 수락하는 경우가 있습니다. 예를 들어 다음과 같은 코드 라인과 같이:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### 취약한 암호화

**비적절한 키 관리 절차**

일부 개발자는 민감한 데이터를 로컬 스토리지에 저장하고 코드에 하드코딩되었거나 예측 가능한 키로 암호화한다. 역공학으로 인해 공격자가 기밀 정보를 추출할 수 있으므로 이렇게 해서는 안 된다.

**안전하지 않거나/또는 폐기된 알고리즘 사용**

개발자는 권한 확인(**authorisation checks**), 데이터 **저장** 또는 **전송**에 **폐기된 알고리즘**을 사용해서는 안 된다. 예로 RC4, MD4, MD5, SHA1 등이 있다. 예를 들어 비밀번호 저장에 **해시**를 사용하는 경우 솔트와 함께 무차별 대입 공격에 **강한 해시**를 사용해야 한다.

### 기타 점검

- APK를 난독화하여 리버스 엔지니어링을 어렵게 만드는 것이 권장된다.
- 앱이 민감한 경우(예: 은행 앱) 자체적으로 **기기가 루팅되었는지 확인하는 검사**를 수행하고 그에 따라 동작해야 한다.
- 앱이 민감한 경우(예: 은행 앱) **에뮬레이터 사용 여부**를 확인해야 한다.
- 앱이 민감한 경우(예: 은행 앱) 실행 전에 **자체 무결성 검사**를 수행하여 수정되었는지 확인해야 한다.
- [**APKiD**](https://github.com/rednaga/APKiD)를 사용해 어떤 compiler/packer/obfuscator가 APK 빌드에 사용되었는지 확인하라.

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### 자동화된 정적 코드 분석

도구 [**mariana-trench**](https://github.com/facebook/mariana-trench)는 애플리케이션의 코드를 **스캔**하여 **취약점**을 찾아낼 수 있다. 이 도구는 도구에 **사용자에 의해 제어되는 입력이 있는 위치**를 지시하는 여러 **known sources**, 악의적 입력이 피해를 줄 수 있는 **위험한 위치**를 지시하는 **sinks**, 그리고 검출 규칙을 제공하는 **rules**를 포함한다. 이러한 규칙들은 취약점을 나타내는 **sources-sinks의 조합**을 정의한다.

이 지식을 바탕으로 **mariana-trench는 코드를 검토하여 가능한 취약점을 찾아낸다**.

### Secrets leaked

An application may contain secrets (API keys, passwords, hidden urls, subdomains...) inside of it that you might be able to discover. You could us a tool such as [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### 기타 흥미로운 기능

- **코드 실행**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **SMS 전송**: `sendTextMessage, sendMultipartTestMessage`
- `native`로 선언된 **네이티브 함수**: `public native, System.loadLibrary, System.load`
- [네이티브 함수를 리버스하는 방법을 읽어보라](reversing-native-libraries.md)
- JNI를 통한 메모리 내 네이티브 코드 실행(다운로드한 shellcode → mmap/mprotect → 호출):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## 동적 분석

> 무엇보다도 애플리케이션과 모든 환경(Burp CA cert, Drozer 및 Frida 등)을 설치할 수 있는 환경이 필요하다. 따라서 루팅된 기기(에뮬레이터 포함)가 강력히 권장된다.

### 온라인 동적 분석

다음에서 **무료 계정**을 만들 수 있다: [https://appetize.io/](https://appetize.io). 이 플랫폼은 APK를 **업로드**하고 **실행**할 수 있게 해주므로 APK의 동작을 확인하는 데 유용하다.

웹에서 **애플리케이션 로그를 볼 수** 있고 **adb**로 연결할 수도 있다.

![](<../../images/image (831).png>)

ADB 연결 덕분에 에뮬레이터 내에서 **Drozer**와 **Frida**를 사용할 수 있다.

### 로컬 동적 분석

#### 에뮬레이터 사용

- [**Android Studio**](https://developer.android.com/studio) (x86 및 arm 디바이스를 생성할 수 있으며, [**this**](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)에 따르면 최신 x86 버전은 느린 arm 에뮬레이터 없이도 ARM 라이브러리를 지원한다).
- 설정 방법은 다음 페이지를 참고하라:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, 계정 생성 필요. _잠재적 오류를 피하려면 **VirtualBox가 포함된** 버전을 **다운로드**하는 것을 권장한다._)
- [**Nox**](https://es.bignox.com) (무료지만 Frida나 Drozer를 지원하지 않는다).

> [!TIP]
> 새로운 에뮬레이터를 만들 때 화면이 클수록 에뮬레이터가 느려진다는 점을 기억하라. 가능하면 작은 화면을 선택하라.

Genymotion에 google services(예: AppStore)를 **설치**하려면 다음 이미지의 빨간 표시된 버튼을 클릭해야 한다:

![](<../../images/image (277).png>)

또한 Genymotion의 **Android VM 설정**에서 **Bridge Network mode**를 선택할 수 있다는 점에 유의하라(도구가 설치된 다른 VM에서 Android VM에 연결할 경우 유용하다).

#### 물리적 기기 사용

디버깅 옵션을 활성화해야 하며 가능하면 **루팅**하는 것이 좋다:

1. 설정.
2. (Android 8.0부터) **시스템**을 선택한다.
3. **전화 정보**를 선택한다.
4. **빌드 번호**를 7번 누른다.
5. 뒤로 가면 **개발자 옵션**을 찾을 수 있다.

> 애플리케이션을 설치한 후 가장 먼저 해야 할 일은 앱을 사용해보고 무엇을 하는지, 어떻게 동작하는지 조사하여 익숙해지는 것이다. 나는 이 초기 동적 분석을 MobSF dynamic analysis + pidcat을 사용해 수행할 것을 권장한다. 이렇게 하면 MobSF가 나중에 검토할 수 있는 많은 흥미로운 데이터를 캡처하는 동안 앱의 동작을 배울 수 있다.

Magisk/Zygisk 간단 메모 (Pixel 기기 권장)
- Magisk 앱으로 boot.img를 패치하고 fastboot로 플래시하여 systemless root를 얻는다
- 루트 숨기기를 위해 Zygisk + DenyList를 활성화하라; 더 강력한 숨김이 필요한 경우 LSPosed/Shamiko를 고려하라
- OTA 업데이트에서 복구할 수 있도록 원본 boot.img를 보관하고, OTA 후에는 다시 패치하라
- 스크린 미러링은 호스트에서 scrcpy를 사용하라

### Unintended Data Leakage

**Logging**

개발자는 **디버깅 정보**를 공개적으로 노출하지 않도록 주의해야 한다, 이는 민감한 데이터 leaks로 이어질 수 있다. 애플리케이션 로그를 모니터링하여 민감한 정보를 식별하고 보호하기 위해 [**pidcat**](https://github.com/JakeWharton/pidcat)과 `adb logcat`을 권장한다. **Pidcat**은 사용 편의성과 가독성 때문에 선호된다.

> [!WARNING]
> Android 4.0 이후 버전부터 애플리케이션은 **자신의 로그만 접근할 수 있다**. 따라서 앱은 다른 앱의 로그에 접근할 수 없다.\
> 어쨌든 민감한 정보를 **로그에 남기지 않는 것**이 권장된다.

**복사/붙여넣기 버퍼 캐싱**

Android의 **클립보드 기반** 프레임워크는 앱에서 복사-붙여넣기 기능을 가능하게 하지만, **다른 애플리케이션**이 클립보드에 접근할 수 있어 민감한 데이터가 노출될 위험이 있다. 신용카드 정보와 같은 민감한 섹션에 대해서는 복사/붙여넣기 기능을 비활성화하는 것이 중요하다.

**크래시 로그**

애플리케이션이 **크래시**하고 **로그를 저장**하면, 특히 애플리케이션을 역공학하기 어려운 경우 공격자에게 도움이 될 수 있다. 이 위험을 완화하려면 크래시 시 로깅을 피하고, 로그를 네트워크로 전송해야 할 경우 SSL 채널로 전송되도록 하라.

Pentester로서 이러한 로그를 확인해 보라.

**제3자에게 전송된 분석 데이터**

앱은 종종 Google Adsense와 같은 서비스를 통합하는데, 개발자의 잘못된 구현으로 인해 민감한 데이터가 의도치 않게 노출될 수 있다. 데이터 유출 가능성을 확인하려면 애플리케이션의 트래픽을 가로채 제3자 서비스로 민감한 정보가 전송되는지 확인하라.

### SQLite DBs

대부분의 애플리케이션은 정보를 저장하기 위해 **내부 SQLite 데이터베이스**를 사용한다. pentest 중에는 생성된 **데이터베이스**, **테이블** 및 **컬럼** 이름과 저장된 모든 **데이터**를 확인하라. 민감한 정보를 찾을 수 있으며 이는 취약점이다.\
데이터베이스는 `/data/data/the.package.name/databases`에 위치해야 하며 예: `/data/data/com.mwr.example.sieve/databases`

데이터베이스가 기밀 정보를 저장하고 암호화되어 있더라도 애플리케이션 내부에서 **비밀번호**를 찾아낼 수 있다면 여전히 **취약점**이다.

테이블은 `.tables`로 열거하고, 테이블의 컬럼은 `.schema <table_name>`로 확인하라

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer is s useful tool to **exploit exported activities, exported services and Content Providers** as you will learn in the following sections.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
또한 액티비티의 코드는 **`onCreate`** 메서드에서 시작한다.

**Authorisation bypass**

액티비티가 exported 되어 있으면 외부 앱에서 해당 화면을 호출할 수 있다. 따라서 **민감한 정보**를 포함한 액티비티가 **exported** 되어 있다면 **인증 메커니즘을 우회**하여 접근할 수 있다.

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

You can also start an exported activity from adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF는 액티비티에서 `android:launchMode`로 _**singleTask/singleInstance**_ 사용을 악성으로 감지하지만, [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750) 때문에, 보이는 바와 같이 이는 구버전(API versions < 21)에서만 위험합니다.

> [!TIP]
> 권한 우회(authorisation bypass)가 항상 취약점인 것은 아닙니다. 우회가 어떻게 동작하는지와 어떤 정보가 노출되는지에 따라 달라집니다.

**Sensitive information leakage**

**Activities도 결과를 반환할 수 있습니다**. export되어 있고 보호되지 않은 activity가 **`setResult`** 메서드를 호출하여 **민감한 정보를 반환(returning sensitive information)** 한다면, sensitive information leakage가 발생합니다.

#### Tapjacking

Tapjacking이 차단되지 않으면, export된 activity를 악용하여 **사용자가 예상치 못한 동작을 수행하게 만들 수 있습니다**. Tapjacking에 대한 자세한 정보는 [**what is Tapjacking follow the link**](#tapjacking)를 참조하세요.

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers는 기본적으로 **데이터를 공유(share data)**하는 데 사용됩니다. 앱에 사용 가능한 content providers가 있다면, 그들로부터 **민감한 데이터를 추출(extract sensitive)**할 수 있습니다. 또한 취약할 수 있으므로 가능한 **SQL injections** 및 **Path Traversals**도 테스트하는 것이 중요합니다.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Service의 동작은 `onStartCommand` 메서드에서 시작된다는 것을 기억하세요.

Service는 기본적으로 **데이터를 수신(receive data)**하고, **처리(process)**하며, 응답을 **반환(return)**(또는 반환하지 않을)할 수 있는 구성요소입니다. 따라서 애플리케이션이 일부 서비스를 export하고 있다면, 무엇을 하는지 이해하기 위해 해당 **코드**를 **검토(check)**하고 기밀 정보를 추출하거나 인증 우회를 시도하기 위해 **동적 테스트(test dynamically)**를 수행해야 합니다.\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Broadcast Receiver의 동작은 `onReceive` 메서드에서 시작된다는 것을 기억하세요.

Broadcast receiver는 특정 타입의 메시지를 기다립니다. 리시버가 메시지를 처리하는 방식에 따라 취약해질 수 있습니다.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

deep links를 수동으로 찾을 수 있으며, MobSF 같은 도구나 [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py) 같은 스크립트를 사용할 수 있습니다.\
선언된 **scheme**은 **adb**나 **browser**를 사용해 열 수 있습니다:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_참고: **omit the package name**을(를) 생략하면 모바일이 해당 링크를 열 앱을 자동으로 호출합니다._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**실행되는 코드**

앱에서 **실행될 코드**를 찾으려면 deeplink에 의해 호출되는 activity로 가서 함수 **`onNewIntent`**을 찾아보세요.

![](<../../images/image (436) (1) (1) (1).png>)

**민감한 정보**

deep link를 발견할 때마다 **URL parameters를 통해 비밀번호 같은 민감한 데이터를 수신하지 않는지** 확인해야 합니다. 다른 애플리케이션이 해당 deep link를 **가장해 그 데이터를 훔칠 수 있기 때문입니다!**

**경로 내 파라미터**

`https://api.example.com/v1/users/{username}` 같은 URL 경로 안에 파라미터를 사용하는 deep link가 있는지도 **반드시 확인**해야 합니다. 그런 경우에는 `example://app/users?username=../../unwanted-endpoint%3fparam=value` 같은 값을 이용해 path traversal을 유도할 수 있습니다.\
애플리케이션 내부에서 올바른 엔드포인트를 찾으면, 경로의 일부가 도메인 이름으로 사용될 때 **Open Redirect**를 유발하거나(또는), CSRF 토큰 없이 사용자 정보를 수정할 수 있고 취약한 엔드포인트가 올바른 메서드를 사용했다면 **account takeover**와 같은 다른 취약점을 발생시킬 수 있습니다. 자세한 내용은 [info about this here](http://dphoeniixx.com/2020/12/13-2/)를 참고하세요.

**추가 예시**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### 전송 계층 검사 및 검증 실패

- **Certificates가 항상 제대로 검사되는 것은 아니다** — Android 애플리케이션에서는 경고를 무시하고 self-signed certificates를 수락하거나, 경우에 따라 HTTP 연결로 되돌아가는 일이 흔합니다.
- **SSL/TLS 핸드셰이크 중 협상이 때때로 취약하다** — 취약한 cipher suites를 사용하면 연결이 man-in-the-middle (MITM) 공격에 취약해져 공격자가 데이터를 복호화할 수 있습니다.
- **Leakage of private information**은 애플리케이션이 인증은 보안 채널로 수행하면서 다른 통신은 비보안 채널로 할 경우 발생할 수 있는 위험입니다. 이 방식은 세션 쿠키나 사용자 정보 같은 민감한 데이터를 악의적 주체가 가로채는 것으로부터 보호하지 못합니다.

#### 인증서 검증

우리는 **인증서 검증**에 초점을 맞출 것입니다. 서버의 인증서 무결성을 검증하는 것은 보안을 강화하기 위해 필수적입니다. 불안전한 TLS 설정과 암호화되지 않은 채널을 통한 민감한 데이터 전송은 심각한 위험을 초래할 수 있습니다. 서버 인증서 검증 및 취약점 해결에 대한 자세한 단계는 [**this resource**](https://manifestsecurity.com/android-application-security-part-10/)를 참고하세요.

#### SSL Pinning

SSL Pinning은 애플리케이션이 서버의 인증서를 애플리케이션 내에 저장된 알려진 사본과 비교하여 검증하는 보안 기법입니다. 이 방법은 MITM 공격을 방지하는 데 필수적이며, 민감한 정보를 다루는 애플리케이션에는 SSL Pinning 구현을 강력히 권장합니다.

#### 트래픽 검사

HTTP 트래픽을 검사하려면 **프록시 도구의 인증서를 설치**(예: Burp)해야 합니다. 이 인증서를 설치하지 않으면 암호화된 트래픽이 프록시를 통해 보이지 않을 수 있습니다. 커스텀 CA 인증서 설치 가이드는 [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine)를 참고하세요.

API Level 24 이상을 타깃으로 하는 애플리케이션은 프록시의 CA 인증서를 수락하도록 Network Security Config를 수정해야 합니다. 이 단계는 암호화된 트래픽을 검사하는 데 중요합니다. Network Security Config 수정 방법은 [**refer to this tutorial**](make-apk-accept-ca-certificate.md)를 참조하세요.

만약 **Flutter**를 사용한다면 [**this page**](flutter.md)의 지침을 따라야 합니다. 단순히 인증서를 스토어에 추가하는 것만으로는 동작하지 않는데, Flutter는 자체 유효 CA 목록을 사용하기 때문입니다.

#### Static detection of SSL/TLS pinning

런타임 우회 시도를 하기 전에 APK에서 pinning이 적용된 위치를 빠르게 매핑하세요. 정적 탐지는 훅/패치 계획을 세우고 올바른 코드 경로에 집중하는 데 도움이 됩니다.

Tool: SSLPinDetect
- 오픈소스 정적 분석 유틸리티로, APK를 Smali로 디컴파일(apktool 사용)하고 SSL/TLS pinning 구현의 커레이팅된 regex 패턴을 스캔합니다.
- 각 매치에 대해 정확한 파일 경로, 라인 번호 및 코드 스니펫을 리포트합니다.
- 일반적인 프레임워크 및 커스텀 코드 경로를 다룹니다: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, 그리고 Network Security Config XML pins.

설치
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
사용법
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
예제 패턴 규칙 (JSON)
signatures를 사용하거나 확장하여 독점/커스텀 pinning 스타일을 탐지하세요. 자신의 JSON을 로드하여 대규모로 스캔할 수 있습니다.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
노트 및 팁
- 대규모 앱을 멀티스레딩 및 memory-mapped I/O로 빠르게 스캔; 미리 컴파일된 regex는 오버헤드와 오탐을 줄여준다.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- 다음으로 우선 분류할 일반적인 탐지 대상:
- OkHttp: CertificatePinner 사용, setCertificatePinner, okhttp3/okhttp 패키지 참조
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted 오버라이드
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- res/xml의 선언적 pins 및 manifest 참조
- 일치한 위치를 이용해 dynamic testing 전에 Frida hooks, static patches 또는 설정 리뷰를 계획하라.



#### SSL Pinning 우회

앱에 SSL Pinning이 구현되어 있으면 HTTPS 트래픽을 검사하기 위해 이를 우회해야 할 필요가 있다. 이를 위한 다양한 방법이 있다:

- 자동으로 **수정**하여 **apk**를 **우회**(bypass)하려면 [**apk-mitm**](https://github.com/shroudedcode/apk-mitm)을 사용하라. 이 옵션의 가장 큰 장점은 SSL Pinning을 우회하기 위해 root가 필요 없다는 점이지만, 애플리케이션을 삭제하고 새로 설치해야 하며 항상 작동하지는 않는다.
- 이 보호를 우회하려면 **Frida**(아래 참조)를 사용할 수 있다. Burp+Frida+Genymotion 사용 가이드는 다음을 참조: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- [**objection**](frida-tutorial/objection-tutorial.md)를 사용해 **자동으로 SSL Pinning을 우회**해볼 수도 있다:**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- **MobSF dynamic analysis**(아래 설명)로 **자동으로 SSL Pinning을 우회**해볼 수도 있다.
- 여전히 캡처하지 못하는 트래픽이 있다고 생각되면 **iptables를 사용해 트래픽을 burp로 포워딩**해 보라. 관련 블로그: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### 일반적인 웹 취약점 찾기

애플리케이션 내에서 일반적인 웹 취약점도 검색하는 것이 중요하다. 이러한 취약점을 식별하고 완화하는 방법에 대한 자세한 내용은 이 요약의 범위를 벗어나지만 다른 자료에서 광범위하게 다루고 있다.

### Frida

[Frida](https://www.frida.re)는 개발자, 리버스 엔지니어, 보안 연구자를 위한 동적 인스트루먼테이션 툴킷이다.\
**실행 중인 애플리케이션에 접근해 런타임에 메서드를 hook하여 동작을 변경하거나 값 추출·변경, 다른 코드를 실행할 수 있다...**\
Android 애플리케이션을 pentest하려면 Frida 사용법을 알아야 한다.

- Frida 사용법 배우기: [**Frida tutorial**](frida-tutorial/index.html)
- Frida 작업용 일부 "GUI": [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection은 Frida 사용 자동화에 좋다: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Awesome Frida 스크립트 모음: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- ptrace 없이 Frida를 로드하는 방식으로 anti-debugging / anti-frida 메커니즘을 우회해 보라(가이드: [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace), 툴: [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning 우회 워크플로우

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **메모리 덤프 - Fridump**

애플리케이션이 비밀번호나 니모닉 같은 메모리에 저장해서는 안 되는 민감한 정보를 메모리에 저장하고 있는지 확인하라.

[**Fridump3**](https://github.com/rootbsd/fridump3)를 사용하면 다음과 같이 앱의 메모리를 덤프할 수 있다:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
이것은 ./dump 폴더에 메모리를 dump합니다. 그리고 그 안에서 다음과 같이 grep할 수 있습니다:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Keystore의 민감한 데이터**

Android에서 Keystore는 민감한 데이터를 저장하기에 가장 적합한 장소이지만, 충분한 권한이 있으면 여전히 **접근할 수 있습니다**. 애플리케이션들은 여기에 **평문으로 민감한 데이터를** 저장하는 경향이 있으므로, pentests는 이를 root user 권한으로 확인해야 합니다. 기기에 물리적으로 접근할 수 있는 사람이 이 데이터를 훔칠 수 있습니다.

앱이 keystore에 데이터를 저장하더라도, 데이터는 암호화되어야 합니다.

keystore 내부의 데이터에 접근하려면 이 Frida script를 사용할 수 있습니다: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

다음 Frida 스크립트를 사용하면 Android 애플리케이션이 특정 민감한 영역을 보호하기 위해 수행할 수 있는 **bypass fingerprint authentication**을 우회할 수 있습니다:
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **백그라운드 이미지**

애플리케이션을 백그라운드로 보낼 때, Android는 애플리케이션의 **snapshot of the application**을 저장합니다. 포어그라운드로 복원될 때 앱이 로드되기 전에 해당 이미지를 먼저 불러와 앱이 더 빨리 로드된 것처럼 보이게 합니다.

그러나 이 **snapshot**에 **민감한 정보**가 포함되어 있다면, snapshot에 접근할 수 있는 누군가가 그 정보를 **탈취할 수 있습니다**(접근하려면 **root**가 필요합니다).

이 snapshot들은 보통 다음 경로에 저장됩니다: **`/data/system_ce/0/snapshots`**

Android는 FLAG_SECURE 레이아웃 파라미터를 설정하여 **screenshot capture를 방지하는** 방법을 제공합니다. 이 플래그를 사용하면 창 내용이 보안 처리되어 screenshots에 나타나거나 비보안 디스플레이에서 표시되는 것을 방지합니다.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

이 도구는 동적 분석 중 다양한 도구를 관리하는 데 도움이 됩니다: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

개발자들은 종종 activities, services, 그리고 broadcast receivers 같은 프록시 컴포넌트를 만들어 이러한 Intents를 처리하고 `startActivity(...)`나 `sendBroadcast(...)` 같은 메서드로 전달하는데, 이는 위험할 수 있습니다.

위험은 공격자가 이러한 Intents를 잘못 유도하여 non-exported app components를 트리거하거나 민감한 content providers에 접근할 수 있게 허용하는 데 있습니다. 대표적인 예로 `WebView` 컴포넌트가 URL을 `Intent` 객체로 변환하기 위해 `Intent.parseUri(...)`를 사용한 뒤 실행하면, 악의적인 Intent 주입으로 이어질 수 있습니다.

### 핵심 요점

- **Intent Injection**은 웹의 Open Redirect 문제와 유사합니다.
- 익스플로잇은 Intent 객체를 extras로 전달하여 안전하지 않은 동작을 실행하도록 리다이렉트하는 방식으로 이뤄집니다.
- 비노출(non-exported) 컴포넌트와 content providers를 공격자에게 노출시킬 수 있습니다.
- `WebView`의 URL → `Intent` 변환은 의도하지 않은 동작을 촉진할 수 있습니다.

### Android 클라이언트 측 인젝션 및 기타

아마 웹에서 이런 종류의 취약점을 접해보셨을 겁니다. Android 애플리케이션에서는 다음 취약점들에 특히 주의해야 합니다:

- **SQL Injection:** 동적 쿼리나 Content-Providers를 다룰 때는 파라미터화된 쿼리를 사용해야 합니다.
- **JavaScript Injection (XSS):** 모든 WebViews에 대해 JavaScript 및 Plugin 지원이 비활성화되어 있는지 확인하세요(기본적으로 비활성화되어 있음). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews는 파일 시스템 접근이 비활성화되어야 합니다(기본적으로 활성화되어 있음) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: 여러 경우에서 Android 애플리케이션이 세션을 종료할 때 쿠키가 취소되지 않거나 디스크에 저장될 수 있습니다.
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## 자동 분석

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**정적 분석**

![](<../../images/image (866).png>)

애플리케이션의 취약점 평가를 웹 기반 프론트엔드를 통해 제공합니다. 동적 분석도 수행할 수 있으나(동적 분석을 위해서는 환경을 준비해야 함) 환경 설정이 필요합니다.
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
주의: MobSF는 **Android**(apk)**, IOS**(ipa) **and Windows**(apx) 애플리케이션을 분석할 수 있습니다 (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
또한, **Android** 또는 **IOS** 앱의 소스 코드로 **ZIP** 파일을 만들면(애플리케이션의 루트 폴더로 이동해 모든 파일을 선택한 뒤 ZIPfile 생성) 그것도 분석할 수 있습니다.

MobSF는 또한 **diff/Compare** 분석을 지원하고 **VirusTotal**과 통합할 수 있습니다 (API 키를 _MobSF/settings.py_에 설정하고 활성화해야 합니다: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). `VT_UPLOAD`을 `False`로 설정하면 파일 대신 **hash**가 **upload**됩니다.

### Assisted Dynamic analysis with MobSF

**MobSF**는 **Android**의 **dynamic analysis**에서도 매우 유용하지만, 이 경우 호스트에 MobSF와 **genymotion**을 설치해야 합니다(가상머신 또는 Docker에서는 작동하지 않습니다). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
**MobSF dynamic analyser**는 다음을 수행할 수 있습니다:

- **Dump application data** (URLs, 로그, 클립보드, 사용자가 찍은 스크린샷, "**Exported Activity Tester**"로 생성한 스크린샷, 이메일, SQLite 데이터베이스, XML 파일 및 기타 생성된 파일). 이들 대부분은 자동으로 수행되지만, 스크린샷은 수동으로 찍어야 하며 모든 exported activities의 스크린샷을 얻으려면 "**Exported Activity Tester**"를 눌러야 합니다.
- **Capture HTTPS traffic**
- **Frida**를 사용해 **runtime** **information** 획득

android **versions > 5**부터는 **Frida**를 자동으로 시작하고 트래픽을 캡처하기 위해 전역 **proxy** 설정을 구성합니다. 이 설정은 테스트 중인 애플리케이션의 트래픽만 캡처합니다.

**Frida**

기본적으로 몇몇 Frida 스크립트를 사용해 **bypass SSL pinning**, **root detection**, **debugger detection**을 수행하고 흥미로운 API를 **monitor**합니다.\
MobSF는 또한 **invoke exported activities**하고 해당 활동의 **screenshots**을 캡처하여 보고서에 **save**할 수 있습니다.

동적 테스트를 **start**하려면 초록색 버튼: "**Start Instrumentation**"을 누르십시오. "**Frida Live Logs**"를 눌러 Frida 스크립트가 생성한 로그를 확인하고 "**Live API Monitor**"를 눌러 후킹된 메서드의 호출, 전달된 인수 및 반환값을 확인할 수 있습니다(이 기능은 "Start Instrumentation"을 누른 후 표시됩니다).\
MobSF는 자체 **Frida scripts**를 로드할 수도 있습니다(Frida 스크립트의 결과를 MobSF로 보내려면 `send()` 함수를 사용하십시오). 또한 몇몇 **pre-written scripts**를 로드할 수 있으며(추가 스크립트는 `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`에 추가 가능), 스크립트를 **select**한 뒤 "**Load**"와 "**Start Instrumentation**"을 누르면 해당 스크립트의 로그를 "**Frida Live Logs**"에서 볼 수 있습니다.

![](<../../images/image (419).png>)

또한 몇 가지 보조 Frida 기능이 있습니다:

- **Enumerate Loaded Classes**: 로드된 모든 클래스를 출력합니다
- **Capture Strings**: 애플리케이션 사용 중 캡처된 모든 문자열을 출력합니다(매우 많은 잡음 발생)
- **Capture String Comparisons**: 매우 유용할 수 있습니다. 비교되는 두 문자열과 그 결과(True/False)를 **show**합니다.
- **Enumerate Class Methods**: 클래스 이름(예: "java.io.File")을 입력하면 해당 클래스의 모든 메서드를 출력합니다.
- **Search Class Pattern**: 패턴으로 클래스 검색
- **Trace Class Methods**: **Trace** 전체 클래스를 기록합니다(클래스의 모든 메서드 입력과 출력 확인). 기본적으로 MobSF는 여러 흥미로운 Android Api 메서드를 trace합니다.

사용할 보조 모듈을 선택한 후 "**Start Intrumentation**"을 누르면 모든 출력이 "**Frida Live Logs**"에 표시됩니다.

**Shell**

MobSF는 동적 분석 페이지 하단에 몇 가지 **adb** 명령, **MobSF commands**, 그리고 일반적인 **shell** **commands**를 제공하는 shell을 포함합니다. 몇 가지 흥미로운 명령:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP 도구**

When http traffic is capture you can see an ugly view of the captured traffic on "**HTTP(S) Traffic**" bottom or a nicer view in "**Start HTTPTools**" green bottom. From the second option, you can **send** the **captured requests** to **proxies** like Burp or Owasp ZAP.\
To do so, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> press "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Once you finish the dynamic analysis with MobSF you can press on "**Start Web API Fuzzer**" to **fuzz http requests** an look for vulnerabilities.

> [!TIP]
> After performing a dynamic analysis with MobSF the proxy settings me be misconfigured and you won't be able to fix them from the GUI. You can fix the proxy settings by doing:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Inspeckage를 이용한 Assisted Dynamic Analysis

You can get the tool from [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
This tool with use some **Hooks** to let you know **what is happening in the application** while you perform a **dynamic analysis**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

This is a **great tool to perform static analysis with a GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

This tool is designed to look for several **security related Android application vulnerabilities**, either in **source code** or **packaged APKs**. The tool is also **capable of creating a "Proof-of-Concept" deployable APK** and **ADB commands**, to exploit some of the found vulnerabilities (Exposed activities, intents, tapjacking...). As with Drozer, there is no need to root the test device.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- 참고하기 쉽도록 추출된 모든 파일을 표시
- APK 파일을 Java 및 Smali 형식으로 자동으로 디컴파일
- AndroidManifest.xml을 분석하여 일반적인 취약점 및 동작 확인
- 정적 소스 코드 분석으로 일반적인 취약점 및 동작 검사
- 기기 정보
- 그 외
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER는 Windows, MacOS X 및 Linux에서 사용할 수 있는 커맨드라인 애플리케이션으로, 취약점을 찾기 위해 _.apk_ 파일을 분석합니다. 이는 APKs를 압축 해제하고 일련의 규칙을 적용하여 해당 취약점을 탐지합니다.

모든 규칙은 `rules.json` 파일에 집중되어 있으며, 각 회사나 테스터는 필요한 분석을 위해 자체 규칙을 생성할 수 있습니다.

최신 바이너리는 [download page](https://superanalyzer.rocks/download.html)에서 다운로드하세요.
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn은 모바일 애플리케이션에 대한 [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis)를 수행하는 개발자, bugbounty hunters 및 ethical hackers를 돕는 **crossplatform** 도구입니다.

개념은 모바일 애플리케이션 파일(.apk 또는 .ipa 파일)을 StaCoAn 애플리케이션으로 드래그 앤 드롭하면 시각적이고 휴대 가능한 보고서를 생성해 준다는 것입니다. 설정과 wordlists를 조정하여 맞춤형 경험을 얻을 수 있습니다.

다운로드[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework는 Android 애플리케이션의 잠재적인 security vulnerabilities를 개발자 또는 hackers가 찾을 수 있도록 돕는 vulnerability analysis 시스템입니다.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn**은 Android 애플리케이션이 개발한 잠재적인 악성 동작을 탐지하고 사용자에게 경고하는 것을 주된 목표로 하는 도구입니다.

탐지는 애플리케이션의 Dalvik bytecode를 **Smali**로 표현한 것을 [`androguard`](https://github.com/androguard/androguard) 라이브러리를 사용한 **static analysis**로 수행됩니다.

이 도구는 다음과 같은 **'악성' 애플리케이션의 일반적인 동작**을 찾습니다: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. 이 도구는 일반적으로 사용되는 mobile application reverse engineering and analysis tools를 모아 OWASP mobile security threats에 대해 모바일 애플리케이션을 테스트하는 것을 돕습니다. 목적은 모바일 애플리케이션 개발자와 보안 전문가들이 이 작업을 더 쉽고 친화적으로 수행할 수 있게 하는 것입니다.

It is able to:

- Extract Java and Smali code using different tools
- Analyze APKs using: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Extract private information from the APK using regexps.
- Analyze the Manifest.
- Analyze found domains using: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Useful to detect malware: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Note that depending the service and configuration you use to obfuscate the code. Secrets may or may not ended obfuscated.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. It is able to optimize bytecode as well as detect and remove unused instructions. ProGuard is free software and is distributed under the GNU General Public License, version 2.

ProGuard is distributed as part of the Android SDK and runs when building the application in release mode.

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Last time we checked, the Dexguard mode of operation was:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

You can upload an obfuscated APK to their platform.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

It is a **generic android deobfuscator.** Simplify **virtually executes an app** to understand its behavior and then **tries to optimize the code** so it behaves identically but is easier for a human to understand. Each optimization type is simple and generic, so it doesn't matter what the specific type of obfuscation is used.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD gives you information about **how an APK was made**. It identifies many **compilers**, **packers**, **obfuscators**, and other weird stuff. It's [_PEiD_](https://www.aldeid.com/wiki/PEiD) for Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b is an Android security virtual machine based on ubuntu-mate includes the collection of latest framework, tutorials and labs from different security geeks and researchers for reverse engineering and malware analysis.

## References

- [Play Integrity API: How It Works & How to Bypass It](https://m4kr0.vercel.app/posts/play-integrity-api-how-it-works--how-to-bypass-it/)
- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) It is a great list of resources
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
