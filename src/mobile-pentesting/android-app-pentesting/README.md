# Android Toepassings Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android Toepassings Basiese beginsels

Dit word sterk aanbeveel om eers hierdie bladsy te lees om te leer oor die **belangrijkste dele wat verband hou met Android-sekuriteit en die gevaarlikste komponente in 'n Android-toepassing**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Dit is die hoofhulpmiddel wat jy nodig het om met 'n Android-toestel te koppel (geëmuleer of fisies).\
**ADB** laat toe om toestelle te beheer óf oor **USB** óf oor **Network** vanaf 'n rekenaar. Hierdie hulpmiddel maak die **kopieer** van lêers in beide rigtings, **installasie** en **verwydering** van apps, die **uitvoering** van shell-opdragte, die **rugsteun** van data, die **lees** van logs en ander funksies moontlik.

Kyk na die volgende lys van [**ADB Commands**](adb-commands.md) om te leer hoe om adb te gebruik.

## Smali

Soms is dit interessant om die **toepassingskode te wysig** om by **verborgen inligting** te kom (miskien goed geobfuskede wagwoorde of flags). Dan kan dit sin maak om die apk te dekompileer, die kode te wysig en dit weer te recompileer.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Dit kan baie nuttig wees as 'n **alternatief vir verskeie toetse tydens die dinamiese ontleding** wat aangebied gaan word. Hou dus **altyd hierdie moontlikheid in gedagte**.

## Ander interessante truuks

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Extract APK from device:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Voeg alle splits en base apks saam met [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Gevallestudies & Kwesbaarhede


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Statiese Analise

Eerstens, om 'n APK te analiseer moet jy **kyk na die Java-kode** met 'n dekompilleerder.\
Asseblief, [**lees hier vir inligting oor verskillende beskikbare dekompilleerders**](apk-decompilers.md).

### Op soek na interessante inligting

Deur net in die **strings** van die APK te kyk kan jy soek na **wagwoorde**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **API-sleutels**, **enkripsie**, **bluetooth UUIDs**, **tokens** en enigiets interessant... kyk selfs vir code execution **backdoors** of authentication backdoors (hardcoded admin credentials in die app).

**Firebase**

Gee besondere aandag aan **Firebase URLs** en kontroleer of dit verkeerd gekonfigureer is. [Meer inligting oor wat Firebase is en hoe om dit te misbruik hier.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Basiese begrip van die toepassing - Manifest.xml, strings.xml

Die **ondersoek van 'n toepassing se _Manifest.xml_ en _strings.xml_ lêers kan potensiële sekuriteitskwesbaarhede openbaar**. Hierdie lêers is toeganklik met dekompilleerders of deur die APK-lêernaam na .zip te verander en dit dan uit te pak.

**Kwesbaarhede** geïdentifiseer in die **Manifest.xml** sluit in:

- **Debuggable Applications**: Toepassings gestel as debugbaar (`debuggable="true"`) in die _Manifest.xml_-lêer vorm 'n risiko aangesien dit verbindings toelaat wat tot uitbuiting kan lei. Vir meer begrip oor hoe om debugbare toepassings te misbruik, verwys na 'n handleiding oor die vind en misbruik van debugbare toepassings op 'n toestel.
- **Backup Settings**: Die `android:allowBackup="false"` attribuut moet eksplisiet gestel word vir toepassings wat met sensitiewe inligting werk om ongemagtigde databackups via adb te voorkom, veral wanneer usb debugging geaktiveer is.
- **Network Security**: Aangepaste netwerksekuriteitskonfigurasies (`android:networkSecurityConfig="@xml/network_security_config"`) in _res/xml/_ kan sekuriteitsbesonderhede spesifiseer soos sertifikaat-pins en HTTP-verkeerinstellings. 'n Voorbeeld is om HTTP-verkeer vir spesifieke domeine toe te laat.
- **Exported Activities and Services**: Die identifisering van geëksporteerde aktiwiteite en dienste in die manifest kan komponente uitlig wat misbruik kan word. Verdere ontleding tydens dinamiese toetsing kan openbaar hoe om hierdie komponente te misbruik.
- **Content Providers and FileProviders**: Blootgestelde content providers kan ongemagtigde toegang of wysiging van data toelaat. Die konfigurasie van FileProviders moet ook ondersoek word.
- **Broadcast Receivers and URL Schemes**: Hierdie komponente kan benut word vir uitbuiting, met besondere aandag op hoe URL-skemas bestuur word vir invoer-kwesbaarhede.
- **SDK Versions**: Die `minSdkVersion`, `targetSDKVersion`, en `maxSdkVersion` attribuutte dui die ondersteunde Android-weergawes aan, wat die belangrikheid beklemtoon om nie verouderde, kwesbare Android-weergawes te ondersteun nie.

Uit die **_strings.xml_**-lêer kan sensitiewe inligting soos API-sleutels, pasgemaakte schemas, en ander ontwikkelaarsnotas gevind word, wat die behoefte aan deeglike hersiening van hierdie hulpbronne beklemtoon.

### Tapjacking

Tapjacking is 'n aanval waar 'n kwaadaardige toepassing geloods word en homself bo-op 'n slagoffer-app posisioneer. Sodra dit die slagoffer-app visueel bedek, is sy gebruikerskoppelvlak ontwerp om die gebruiker te mislei om daarby te kommunikeer, terwyl dit die interaksie aan die slagoffer-app deurgee. In werklikheid verblind dit die gebruiker sodat hulle nie weet dat hulle eintlik aksies op die slagoffer-app uitvoer nie.

Vind meer inligting in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

'n **activity** met die **`launchMode`** gestel op **`singleTask` sonder enige `taskAffinity`** gedefinieer is kwesbaar vir Task Hijacking. Dit beteken dat 'n **application** geïnstalleer kan word en indien dit voor die werklike toepassing geopen word, kan dit die taak van die werklike toepassing kaap (sodat die gebruiker met die **kwaadaardige toepassing sal werk terwyl hy dink hy gebruik die werklike een**).

Meer info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Onveilige datastoor

**Interne stoorplek**

In Android is dit ontwerp dat lêers wat in interne stoorplek gestoor word uitsluitlik toeganklik is deur die app wat dit geskep het. Hierdie veiligheidsmaatreël word deur die Android-bedryfstelsel afgedwing en is oor die algemeen voldoende vir die veiligheidsbehoeftes van die meeste toepassings. Ontwikkelaars gebruik egter soms modusse soos `MODE_WORLD_READABLE` en `MODE_WORLD_WRITABLE` om lêers tussen verskillende toepassings te deel. Hierdie modusse beperk egter nie toegang tot hierdie lêers deur ander toepassings nie, insluitend moontlik kwaadwillige toepassings.

1. **Statiese Analise:**
- **Kontroleer** dat die gebruik van `MODE_WORLD_READABLE` en `MODE_WORLD_WRITABLE` noukeurig nagegaan word. Hierdie modusse **kan lêers moontlik aan onbedoelde of ongemagtigde toegang blootstel**.
2. **Dinamiese Analise:**
- **Verifieer** die **permitte** wat op lêers geskep deur die app gestel is. Spesifiek, **kontroleer** of enige lêers **gestel is om wêreldwyd lees- of skryfbaar te wees**. Dit kan 'n beduidende sekuriteitsrisiko inhou, aangesien dit enige toepassing wat op die toestel geïnstalleer is, ongeag oorsprong of bedoeling, toelaat om hierdie lêers te lees of te wysig.

**Eksterne stoorplek**

Wanneer jy met lêers op eksterne stoorwerk, soos SD-kaarte, werk, moet sekere voorsorgmaatreëls getref word:

1. **Toeganklikheid**:
- Lêers op eksterne stoorplek is **globaal lees- en skryfbaar**. Dit beteken enige toepassing of gebruiker kan toegang tot hierdie lêers kry.
2. **Sekuriteitskwessies**:
- Gegewe die maklike toegang, word dit aangeraai **om nie sensitiewe inligting op eksterne stoorplek te stoor nie**.
- Eksterne stoorplek kan verwyder of deur enige toepassing geakses word, wat dit minder veilig maak.
3. **Hantering van data van eksterne stoorplek**:
- Voer altyd **invoervalidatie** uit op data wat van eksterne stoorplek teruggehaal word. Dit is van kritieke belang want die data kom van 'n onbetroubare bron.
- Dit word sterk ontried om uitvoerbare of klaslêers op eksterne stoorplek te stoor vir dinamiese lading.
- As jou toepassing verplig is om uitvoerbare lêers van eksterne stoorplek te laai, maak seker dat hierdie lêers **onderteken en kriptografies geverifieer** is voordat hulle dinamies gelaai word. Hierdie stap is noodsaaklik om die sekuriteitsintegriteit van jou toepassing te handhaaf.

Eksterne stoorplek kan bereik word in `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> Vanaf Android 4.4 (**API 17**) het die SD-kaart 'n gidsstruktuur wat toegang van 'n app tot die gids wat spesifiek vir daardie app is beperk. Dit keer dat 'n kwaadwillige toepassing lees- of skryf toegang tot 'n ander app se lêers kry.

**Sensitiewe data wat in onversleutelde teks gestoor is**

- **Shared preferences**: Android laat elke toepassing toe om maklik xml-lêers te stoor in die pad `/data/data/<packagename>/shared_prefs/` en soms is dit moontlik om sensitiewe inligting in onversleutelde teks in daardie vouer te vind.
- **Databases**: Android laat elke toepassing toe om maklik sqlite-databasisse te stoor in die pad `/data/data/<packagename>/databases/` en soms is dit moontlik om sensitiewe inligting in onversleutelde teks in daardie vouer te vind.

### Broken TLS

**Accept All Certificates**

Om een of ander rede aanvaar ontwikkelaars soms alle sertifikate selfs al stem byvoorbeeld die gasheernaam nie ooreen nie met reëls van kode soos die volgende een:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Broken Cryptography

**Poor Key Management Processes**

Some developers save sensitive data in the local storage and encrypt it with a key hardcoded/predictable in the code. This shouldn't be done as some reversing could allow attackers to extract the confidential information.

**Use of Insecure and/or Deprecated Algorithms**

Developers shouldn't use **deprecated algorithms** to perform authorisation **checks**, **store** or **send** data. Some of these algorithms are: RC4, MD4, MD5, SHA1... If **hashes** are used to store passwords for example, hashes brute-force **resistant** should be used with salt.

### Other checks

- Dit word aanbeveel om die **APK te obfuskeer** om die reverse engineer se werk vir aanvallers moeiliker te maak.
- As die app sensitief is (soos bank apps), behoort dit sy **eie kontroles uit te voer om te sien of die mobile geroot is** en ooreenkomstig op te tree.
- As die app sensitief is (soos bank apps), behoort dit te kontroleer of 'n **emulator** gebruik word.
- As die app sensitief is (soos bank apps), behoort dit **sy eie integriteit te check voor uitvoering** om te kyk of dit gemodifiseer is.
- Gebruik [**APKiD**](https://github.com/rednaga/APKiD) om te kyk watter compiler/packer/obfuscator gebruik is om die APK te bou

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

The tool [**mariana-trench**](https://github.com/facebook/mariana-trench) is capable of finding **vulnerabilities** by **scanning** the **code** of the application. This tool contains a series of **known sources** (that indicates to the tool the **places** where the **input** is **controlled by the user**), **sinks** (which indicates to the tool **dangerous** **places** where malicious user input could cause damages) and **rules**. These rules indicates the **combination** of **sources-sinks** that indicates a vulnerability.

With this knowledge, **mariana-trench will review the code and find possible vulnerabilities on it**.

### Geheime leaked

An application may contain secrets (API keys, passwords, hidden urls, subdomains...) inside of it that you might be able to discover. You could us a tool such as [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Ander interessante funksies

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)
- In-memory native code execution via JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> First of all, you need an environment where you can install the application and all the environment (Burp CA cert, Drozer and Frida mainly). Therefore, a rooted device (emulated or not) is extremely recommended.

### Online Dynamic analysis

You can create a **free account** in: [https://appetize.io/](https://appetize.io). This platform allows you to **upload** and **execute** APKs, so it is useful to see how an apk is behaving.

You can even **see the logs of your application** in the web and connect through **adb**.

![](<../../images/image (831).png>)

Thanks to the ADB connection you can use **Drozer** and **Frida** inside the emulators.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (You can create **x86** and **arm** devices, and according to [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** versions **support ARM libraries** without needing an slow arm emulator).
- Learn to set it up in this page:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, you need to create an account. _It's recommend to **download** the version **WITH**_ _**VirtualBox** to avoid potential errors._)
- [**Nox**](https://es.bignox.com) (Free, but it doesn't support Frida or Drozer).

> [!TIP]
> When creating a new emulator on any platform remember that the bigger the screen is, the slower the emulator will run. So select small screens if possible.

To **install google services** (like AppStore) in Genymotion you need to click on the red marked button of the following image:

![](<../../images/image (277).png>)

Also, notice that in the **configuration of the Android VM in Genymotion** you can select **Bridge Network mode** (this will be useful if you will be connecting to the Android VM from a different VM with the tools).

#### Use a physical device

You need to activate the **debugging** options and it will be cool if you can **root** it:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Once you have installed the application, the first thing you should do is to try it and investigate what does it do, how does it work and get comfortable with it.\
> I will suggest to **perform this initial dynamic analysis using MobSF dynamic analysis + pidcat**, so we will be able to **learn how the application works** while MobSF **captures** a lot of **interesting** **data** you can review later on.

Magisk/Zygisk quick notes (recommended on Pixel devices)
- Patch boot.img with the Magisk app and flash via fastboot to get systemless root
- Enable Zygisk + DenyList for root hiding; consider LSPosed/Shamiko when stronger hiding is required
- Keep original boot.img to recover from OTA updates; re-patch after each OTA
- For screen mirroring, use scrcpy on the host



### Unintended Data Leakage

**Logging**

Developers should be cautious of exposing **debugging information** publicly, as it can lead to sensitive data leaks. The tools [**pidcat**](https://github.com/JakeWharton/pidcat) and `adb logcat` are recommended for monitoring application logs to identify and protect sensitive information. **Pidcat** is favored for its ease of use and readability.

> [!WARNING]
> Note that from **later newer than Android 4.0**, **applications are only able to access their own logs**. So applications cannot access other apps logs.\
> Anyway, it's still recommended to **not log sensitive information**.

**Copy/Paste Buffer Caching**

Android's **clipboard-based** framework enables copy-paste functionality in apps, yet poses a risk as **other applications** can **access** the clipboard, potentially exposing sensitive data. It's crucial to **disable copy/paste** functions for sensitive sections of an application, like credit card details, to prevent data leaks.

**Crash Logs**

If an application **crashes** and **saves logs**, these logs can assist attackers, particularly when the application cannot be reverse-engineered. To mitigate this risk, avoid logging on crashes, and if logs must be transmitted over the network, ensure they are sent via an SSL channel for security.

As pentester, **try to take a look to these logs**.

**Analytics Data Sent To 3rd Parties**

Applications often integrate services like Google Adsense, which can inadvertently **leak sensitive data** due to improper implementation by developers. To identify potential data leaks, it's advisable to **intercept the application's traffic** and check for any sensitive information being sent to third-party services.

### SQLite DBs

Most of the applications will use **internal SQLite databases** to save information. During the pentest take a **look** to the **databases** created, the names of **tables** and **columns** and all the **data** saved because you could find **sensitive information** (which would be a vulnerability).\
Databases should be located in `/data/data/the.package.name/databases` like `/data/data/com.mwr.example.sieve/databases`

If the database is saving confidential information and is **encrypted b**ut you can **find** the **password** inside the application it's still a **vulnerability**.

Enumerate the tables using `.tables` and enumerate the columns of the tables doing `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer is s useful tool to **exploit exported activities, exported services and Content Providers** as you will learn in the following sections.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Also remember that the code of an activity starts in the **`onCreate`** method.

**Authorisation bypass**

When an Activity is exported you can invoke its screen from an external app. Therefore, if an activity with **sensitive information** is **exported** you could **bypass** the **authentication** mechanisms **to access it.**

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

You can also start an exported activity from adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**LET WEL**: MobSF sal die gebruik van _**singleTask/singleInstance**_ as `android:launchMode` in 'n aktiwiteit as kwaadwillig beskou, maar weens [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), blyk dit net gevaarlik te wees op ouer weergawes (API versions < 21).

> [!TIP]
> Let wel dat 'n authorisation bypass nie altyd 'n kwesbaarheid is nie; dit hang af van hoe die bypass werk en watter inligting blootgestel word.

**Sensitiewe inligtingslek**

Aktiwiteite kan ook resultate teruggee. As jy daarin slaag om 'n geëksporteerde en onbeveiligde aktiwiteit te vind wat die **`setResult`** metode aanroep en **sensitiewe inligting teruggee**, is daar 'n sensitiewe inligtingslek.

#### Tapjacking

As Tapjacking nie voorkom word nie, kan jy die geëksporteerde aktiwiteit misbruik om die **gebruiker onverwagte aksies te laat uitvoer**. For more info about [**what is Tapjacking follow the link**](#tapjacking).

### Uitbuiting van Content Providers - Toegang tot en manipulasie van sensitiewe inligting

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers word hoofsaaklik gebruik om **data te deel**. As 'n app beskikbare content providers het, kan jy dalk **sensitiewe data onttrek** daaruit. Dit is ook interessant om moontlike **SQL injections** en **Path Traversals** te toets, aangesien hulle kwesbaar kan wees.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Uitbuiting van Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Onthou dat die aksies van 'n Service begin in die metode `onStartCommand`.

'n Service is basies iets wat **data kan ontvang**, dit **verwerk** en 'n antwoord **teruggee** (of nie). Dus, as 'n toepassing sekere services exporteer, moet jy die **kode** nagaan om te verstaan wat dit doen en dit **dynamies** toets om vertroulike inligting te onttrek, bypassing authentication measures...\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Uitbuiting van Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Onthou dat die aksies van 'n Broadcast Receiver begin in die metode `onReceive`.

'n Broadcast Receiver sal wag vir 'n tipe boodskap. Afhangend daarvan hoe die receiver die boodskap hanteer, kan dit kwesbaar wees.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Uitbuiting van Schemes / Deep links**

Jy kan handmatig na deep links soek, deur gereedskap soos MobSF of skripte soos [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py) te gebruik.\
Jy kan 'n verklaarde **scheme** oopmaak met **adb** of 'n **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Neem kennis dat jy die **pakketnaam kan weglaat** en die mobiele toestel sal outomaties die app oproep wat daardie skakel moet oopmaak._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Kode uitgevoer**

Om die **kode wat in die App uitgevoer sal word** te vind, gaan na die activity wat deur die deeplink aangeroep word en soek die funksie **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Gevoelige inligting**

Elke keer as jy 'n deep link vind, kontroleer dat dit **nie sensitiewe data (soos wagwoorde) via URL-parameters ontvang nie**, aangesien enige ander toepassing die deep link kan **impersonate en daardie data kan steel!**

**Parameters in path**

Jy **moet ook nakyk of enige deep link 'n parameter binne die pad van die URL gebruik** soos: `https://api.example.com/v1/users/{username}`, in daardie geval kan jy 'n path traversal afdwing deur iets soos: `example://app/users?username=../../unwanted-endpoint%3fparam=value` te gebruik.\
Let daarop dat as jy die korrekte endpoints binne die toepassing vind, jy moontlik 'n **Open Redirect** kan veroorsaak (as deel van die pad as domeinnaam gebruik word), **account takeover** (as jy gebruikersbesonderhede kan verander sonder 'n CSRF token en die vuln endpoint die korrekte metode gebruik) en enige ander vuln. Meer [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**Meer voorbeelde**

'n [Interessante bug bounty report](https://hackerone.com/reports/855618) oor links (_/.well-known/assetlinks.json_).

### Transport Layer Inspection and Verification Failures

- Sertifikate word nie altyd behoorlik geïnspekteer deur Android-toepassings nie. Dit is algemeen dat hierdie toepassings waarskuwings ignoreer en self-signed certificates aanvaar, of in sommige gevalle terugval op HTTP-verbindinge.
- Onderhandelinge tydens die SSL/TLS handshake is soms swak en gebruik onveilige cipher suites. Hierdie kwesbaarheid maak die verbinding vatbaar vir man-in-the-middle (MITM) aanvalle, wat aanvallers in staat stel om die data te ontsleutel.
- Leakage of private information is 'n risiko wanneer toepassings verifieer met veilige kanale maar dan oor nie-veilige kanale kommunikeer vir ander transaksies. Hierdie benadering beskerm nie sensitiewe data, soos sessie cookies of gebruikerbesonderhede, teen onderskep deur kwaadwilliges nie.

#### Certificate Verification

Ons sal fokus op **certificate verification**. Die integriteit van die bediener se sertifikaat moet geverifieer word om sekuriteit te verbeter. Dit is noodsaaklik omdat onveilige TLS-konfigurasies en die transmissie van sensitiewe data oor onbeveiligde kanale beduidende risiko's kan inhou. Vir gedetailleerde stappe oor die verifikasie van bedienersertifikate en die aanspreek van kwesbaarhede, bied [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) omvattende leiding.

#### SSL Pinning

SSL Pinning is 'n sekuriteitsmaatreël waar die toepassing die bediener se sertifikaat verifieer teen 'n bekende kopie wat binne die toepassing self gestoor is. Hierdie metode is noodsaaklik vir die voorkoming van MITM-aanvalle. Dit word sterk aanbeveel om SSL Pinning te implementeer vir toepassings wat sensitiewe inligting hanteer.

#### Traffic Inspection

Om HTTP-verkeer te inspekteer, is dit nodig om **die proxy tool se sertifikaat te installeer** (bv. Burp). Sonder die installasie van hierdie sertifikaat mag versleutelde verkeer nie deur die proxy sigbaar wees nie. Vir 'n gids oor die installasie van 'n custom CA-sertifikaat, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Toepassings wat gemik is op **API Level 24 and above** vereis wysigings aan die Network Security Config om die proxy se CA-sertifikaat te aanvaar. Hierdie stap is kritiek vir die inspeksie van versleutelde verkeer. Vir instruksies oor die wysiging van die Network Security Config, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

As **Flutter** gebruik word, moet jy die instruksies op [**this page**](flutter.md) volg. Dit is omdat net om die sertifikaat by die store te voeg nie sal werk nie, aangesien Flutter sy eie lys van valiede CAs het.

#### Static detection of SSL/TLS pinning

Voordat jy runtime-bypasses probeer, maak vinnig 'n kaart van waar pinning in die APK afgedwing word. Static discovery help jou om hooks/patches te beplan en om op die regte kodepaaie te fokus.

Tool: SSLPinDetect
- Open-source static-analysis utility wat die APK na Smali dekompileer (via apktool) en skandeer vir gekuratoreerde regex-patrone van SSL/TLS pinning implementasies.
- Rapporteer presiese lêerpad, lynnommer, en 'n kode-snippet vir elke match.
- Dek algemene frameworks en custom code paths: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init met custom TrustManagers/KeyManagers, en Network Security Config XML pins.

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Gebruik
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Voorbeeld patroonreëls (JSON)
Gebruik of brei signatures uit om proprietêre/aangepaste pinning styles op te spoor. Jy kan jou eie JSON laai en op skaal scan.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes and tips
- Vinnige skandering van groot apps deur multi-threading en memory-mapped I/O; pre-compiled regex verminder overhead/vals positiewe.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Tipiese detectie teikens om daarna te triage:
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Declarative pins in res/xml network security config and manifest references
- Gebruik die ooreenstemmende lokasies om Frida hooks, static patches, of config reviews te beplan voordat jy dinamiese toetsing doen.



#### Omseiling van SSL Pinning

Wanneer SSL Pinning geïmplementeer is, word dit nodig om dit te omseil om HTTPS-verkeer te inspekteer. Verskeie metodes is beskikbaar vir hierdie doel:

- Automatically **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). The best pro of this option, is that you won't need root to bypass the SSL Pinning, but you will need to delete the application and reinstall the new one, and this won't always work.
- Jy kan **Frida** gebruik (bespreek hieronder) om hierdie beskerming te omseil. Hier is 'n gids om Burp+Frida+Genymotion te gebruik: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Jy kan ook probeer om outomaties SSL Pinning te omseil deur [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Jy kan ook probeer om outomaties SSL Pinning te omseil deur **MobSF dynamic analysis** te gebruik (hieronder verduidelik)
- As jy steeds dink daar is verkeer wat jy nie vasvang nie, kan jy probeer om die verkeer na Burp deur te stuur met iptables. Lees hierdie blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Looking for Common Web Vulnerabilities

Dit is belangrik om ook binne die toepassing na algemene web kwesbaarhede te soek. Gedetaileerde inligting oor hoe om hierdie kwesbaarhede te identifiseer en te mitigereer val buite die bestek van hierdie opsomming, maar dit word elders uitgebreid behandel.

### Frida

[Frida](https://www.frida.re) is 'n dynamic instrumentation toolkit vir developers, reverse-engineers, en security researchers.\
**Jy kan toegang kry tot 'n lopende application en hook methods op runtime om die gedrag te verander, waardes te verander, waardes te onttrek, of ander kode uit te voer...**\
As jy Android applications wil pentest moet jy weet hoe om Frida te gebruik.

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Some "GUI" for actions with Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- You can find some Awesome Frida scripts here: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Probeer om anti-debugging / anti-frida meganismes te omseil deur Frida te laai soos aangedui in [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

Kontroleer of die toepassing sensitiewe inligting in die geheue stoor wat dit nie behoort te stoor nie, soos wagwoorde of mnemonics.

Deur [**Fridump3**](https://github.com/rootbsd/fridump3) te gebruik kan jy die geheue van die app dump met:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Dit sal die geheue in die ./dump-lêergids uitgooi, en daar kan jy iets soos grep gebruik:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Sensitiewe data in Keystore**

In Android is die Keystore die beste plek om sensitiewe data te stoor, maar met genoeg privileges is dit steeds **moontlik om toegang daartoe te kry**. Aangesien toepassings hier dikwels **sensitiewe data in onversleutelde teks** stoor, moet pentests dit as root user nagaan, aangesien iemand met fisiese toegang tot die toestel hierdie data kan steel.

Selfs as 'n app data in die keystore gestoor het, behoort die data versleuteld te wees.

Om toegang tot die data binne die keystore te kry, kan jy hierdie Frida script gebruik: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Met die volgende Frida-script kan dit moontlik wees om die **bypass fingerprint authentication** wat Android-toepassings dalk uitvoer om sekere sensitiewe gebiede te **beskerm:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Agtergrondbeelde**

Wanneer jy 'n toepassing op die agtergrond plaas, stoor Android 'n **snapshot van die toepassing** sodat wanneer dit na die voorgrond herstel word, dit eers die beeld laai voordat die app begin, sodat dit lyk asof die app vinniger gelaai is.

Indien hierdie snapshot egter **sensitiewe inligting** bevat, kan iemand met toegang tot die snapshot daardie inligting **steel** (let wel: jy benodig root-toegang om daartoe te kom).

Die snapshots word gewoonlik gestoor by: **`/data/system_ce/0/snapshots`**

Android bied 'n manier om **skermskootopname te voorkom deur die FLAG_SECURE** layout-parameter te stel. Deur hierdie vlag te gebruik word die vensterinhoud as veilig behandel, wat verhoed dat dit in skermskote verskyn of op onveilige skerms gesien word.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Hierdie hulpmiddel kan jou help om verskillende gereedskap tydens die dinamiese analise te bestuur: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Ontwikkelaars skep dikwels proxy-komponente soos activities, services, en broadcast receivers wat hierdie Intents hanteer en dit aan metodes soos `startActivity(...)` of `sendBroadcast(...)` deurgee, wat riskant kan wees.

Die gevaar lê daarin om aanvallers toe te laat om nie-geëksporteerde app-komponente te aktiveer of sensitiewe content providers te bereik deur hierdie Intents verkeerd te lei. 'n Opmerklike voorbeeld is die `WebView`-komponent wat URL's na `Intent`-objekte omskep via `Intent.parseUri(...)` en dit dan uitvoer, wat moontlik lei tot kwaadwillige Intent injections.

### Essential Takeaways

- **Intent Injection** is soortgelyk aan die web se Open Redirect-kwessie.
- Exploits behels die deurgee van `Intent`-objekte as extras, wat herlei kan word om onveilige operasies uit te voer.
- Dit kan nie-geëksporteerde komponente en content providers vir aanvallers blootstel.
- `WebView` se URL-naar-Intent omskakeling kan onbedoelde aksies fasiliteer.

### Android Client Side Injections and others

Jy ken waarskynlik hierdie soort kwesbaarhede van die Web. Jy moet besondere versigtigheid toepas met hierdie kwesbaarhede in 'n Android-toepassing:

- **SQL Injection:** Wanneer jy met dinamiese navrae of Content-Providers werk, maak seker jy gebruik geparametriseerde navrae.
- **JavaScript Injection (XSS):** Kontroleer dat JavaScript- en Plugin-ondersteuning gedeaktiveer is vir enige WebViews (standaard gedeaktiveer). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews moet toegang tot die lêerstelsel gedeaktiveer hê (standaard geaktiveer) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: In verskeie gevalle, wanneer die Android-toepassing die sessie beëindig, word die cookie nie herroep nie of dit kan selfs op skyf gestoor word
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Static analysis**

![](<../../images/image (866).png>)

**Kwetsbaarheidsassessering van die toepassing** met 'n netjiese webgebaseerde frontend. Jy kan ook dinamiese analise uitvoer (maar jy moet die omgewing voorberei).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Geassisteerde Dynamic analysis with MobSF

**MobSF** kan ook baie nuttig wees vir **dynamic analysis** in **Android**, maar in daardie geval sal jy MobSF en **genymotion** op jou gasheer moet installeer (n VM of Docker sal nie werk nie). _Nota: Jy moet eers 'n VM in genymotion begin en dan MobSF._\
Die **MobSF dynamic analyser** kan:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). Al hierdie word outomaties gedoen, behalwe vir die skermskote — jy moet druk wanneer jy 'n skermskoot wil hê of op "**Exported Activity Tester**" druk om skermskote van al die exported activities te kry.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: Dit sal al die gelaaide klasse afdruk.
- **Capture Strings**: Dit sal alle vasgevangde stringe afdruk terwyl jy die toepassing gebruik (baie lawaaierig).
- **Capture String Comparisons**: Kan baie nuttig wees. Dit sal die 2 stringe wat vergelyk word wys en of die resultaat True of False was.
- **Enumerate Class Methods**: Voer die klasnaam in (soos "java.io.File") en dit sal al die metodes van die klas afdruk.
- **Search Class Pattern**: Soek klasse op patroon.
- **Trace Class Methods**: **Trace** 'n hele klas (sien insette en uitsette van alle metodes van die klas). Onthou dat MobSF standaard verskeie interessante Android Api-metodes traceer.

Sodra jy die hulpmoduul gekies het wat jy wil gebruik, moet jy "**Start Intrumentation**" druk en jy sal al die uitsette in "**Frida Live Logs**" sien.

**Shell**

MobSF bring jou ook 'n shell met sommige **adb** commands, **MobSF commands**, en algemene **shell** **commands** onderaan die dynamic analysis-bladsy. Sommige interessante opdragte:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP gereedskap**

Wanneer HTTP-verkeer vasgevang word kan jy 'n lelike aansig van die vasgevangde verkeer sien op die "**HTTP(S) Traffic**" knoppie of 'n netter aansig in die "**Start HTTPTools**" groen knoppie. Vanuit die tweede opsie kan jy die **captured requests** na **proxies** soos Burp of Owasp ZAP **stuur**.\
Om dit te doen, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> press "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Sodra jy die dynamic analysis met MobSF voltooi het, kan jy op "**Start Web API Fuzzer**" druk om **fuzz http requests** en te soek na vulnerabilities.

> [!TIP]
> Na die uitvoering van 'n dynamic analysis met MobSF kan die proxy-instellings verkeerd gekonfigureer wees en jy sal dit nie vanuit die GUI kan herstel nie. Jy kan die proxy-instellings regmaak deur:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Geassisteerde Dynamic Analysis met Inspeckage

Jy kan die tool kry by [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Hierdie tool gebruik 'n paar **Hooks** om jou te laat weet **wat in die toepassing gebeur** terwyl jy 'n **dynamic analysis** uitvoer.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Dit is 'n **geweldige tool om static analysis met 'n GUI uit te voer**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Hierdie tool is ontwerp om verskeie **security related Android application vulnerabilities** op te spoor, hetsy in **source code** of in **packaged APKs**. Die tool is ook **capable of creating a "Proof-of-Concept" deployable APK** en **ADB commands**, om sommige van die gevonde vulnerabilities uit te buit (Exposed activities, intents, tapjacking...). Soos met Drozer, is daar geen behoefte om die toetsapparaat te root nie.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Wys alle uitgetrekte lêers vir maklike verwysing
- Dekompileer APK-lêers outomaties na Java- en Smali-formaat
- Analiseer AndroidManifest.xml vir algemene kwesbaarhede en gedrag
- Statiese bronkode-analise vir algemene kwesbaarhede en gedrag
- Toestelinligting
- en meer
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER is 'n command-line application wat in Windows, MacOS X en Linux gebruik kan word, en _.apk_ lêers ontleed op soek na vulnerabilities. Dit doen dit deur APKs te dekomprimeer en 'n reeks reëls toe te pas om daardie vulnerabilities op te spoor.

Alle reëls is gesentreer in 'n `rules.json` lêer, en elke maatskappy of toetser kan hul eie reëls skep om te ontleed wat hulle nodig het.

Download die nuutste binaries vanaf die [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn is 'n **crossplatform** hulpmiddel wat ontwikkelaars, bugbounty hunters en ethical hackers help om [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) op mobiele toepassings uit te voer.

Die konsep is dat jy jou mobiele toepassingslêer (.apk of .ipa lêer) na die StaCoAn-toepassing sleep en neergooi, en dit sal 'n visuele en draagbare verslag vir jou genereer. Jy kan die instellings en wordlists aanpas om 'n aangepaste ervaring te kry.

Laai af[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework is 'n Android-kwesbaarheid-analise stelsel wat ontwikkelaars of hackers help om potensiële sekuriteitskwesbaarhede in Android-toepassings te vind.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** is 'n hulpmiddel met die hoofdoel om potensiële kwaadwillige gedrag wat deur 'n Android-toepassing ontwikkel word op te spoor en die gebruiker te waarsku.

Die opsporing word uitgevoer deur middel van die **static analysis** van die toepassing se Dalvik bytecode, wat voorgestel word as **Smali**, met die [`androguard`](https://github.com/androguard/androguard) biblioteek.

Hierdie hulpmiddel soek na **algemene gedrag van "slegte" toepassings** soos: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. Dit is 'n hulpmiddel wat algemeen gebruikte mobile application reverse engineering and analysis tools bymekaarsit om te help met die toetsing van mobiele toepassings teen die OWASP mobile security threats. Die doel is om hierdie taak makliker en meer gebruikersvriendelik te maak vir mobiele toepassingontwikkelaars en sekuriteitsprofessionals.

It is able to:

- Extract Java and Smali code using different tools
- Analyze APKs using: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Extract private information from the APK using regexps.
- Analyze the Manifest.
- Analyze found domains using: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Nuttig om malware te bespeur: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Let daarop dat, afhangend van die diens en konfigurasie wat jy gebruik om die code te obfuscate, geheime wel of nie obfuscated kan eindig nie.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. It is able to optimize bytecode as well as detect and remove unused instructions. ProGuard is free software and is distributed under the GNU General Public License, version 2.

ProGuard is distributed as part of the Android SDK and runs when building the application in release mode.

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Last time we checked, the Dexguard mode of operation was:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

You can upload an obfuscated APK to their platform.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

It is a **generic android deobfuscator.** Simplify **virtually executes an app** to understand its behavior and then **tries to optimize the code** so it behaves identically but is easier for a human to understand. Each optimization type is simple and generic, so it doesn't matter what the specific type of obfuscation is used.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD gives you information about **how an APK was made**. It identifies many **compilers**, **packers**, **obfuscators**, and other weird stuff. It's [_PEiD_](https://www.aldeid.com/wiki/PEiD) for Android.

### Manual

[Lees hierdie tutorial om 'n paar truuks te leer oor **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b is an Android security virtual machine gebaseer op ubuntu-mate en sluit 'n versameling van die nuutste framework, tutorials en labs van verskeie security geeks en navorsers in vir reverse engineering en malware analysis.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Dit is 'n uitstekende lys van hulpbronne
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
