# Android Applications Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Основи Android-застосунків

It's highly recommended to start reading this page to know about the **most important parts related to Android security and the most dangerous components in an Android application**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Це основний інструмент, який потрібен для підключення до Android-пристрою (емуляторного або фізичного).\
**ADB** дозволяє керувати пристроями через **USB** або **Network** з комп'ютера. Ця утиліта дозволяє **копіювання** файлів в обох напрямках, **installation** та **uninstallation** додатків, **execution** of shell commands, **backing up** of data, **reading** of logs, серед інших функцій.

Take a look to the following list of [**ADB Commands**](adb-commands.md) to learn how to use adb.

## Smali

Іноді цікаво **модифікувати код застосунку**, щоб отримати доступ до **прихованої інформації** (наприклад, добре обфусцировані паролі або flags). Тоді може бути корисно декомпілювати APK, змінити код і знову зібрати його.\ 
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Це може бути дуже корисно як **альтернатива для кількох тестів під час dynamic analysis**, які будуть представлені. Тому **завжди майте на увазі цю можливість**.

## Інші цікаві трюки

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Витягти APK з пристрою:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Об'єднайте всі splits та base apks за допомогою [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Кейси та уразливості


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Статичний аналіз

По-перше, для аналізу APK ви повинні **переглянути Java code** за допомогою декомпілятора.\
Будь ласка, [**прочитайте тут, щоб знайти інформацію про різні доступні decompilers**](apk-decompilers.md).

### Пошук цікавої інформації

Просто переглядаючи **strings** APK, ви можете шукати **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** та будь-що цікаве... перевіряйте навіть на наявність виконувальних кодових **backdoors** або backdoors автентифікації (hardcoded admin credentials у додатку).

**Firebase**

Зверніть особливу увагу на **firebase URLs** і перевірте, чи не налаштовано його неправильно. [Більше інформації про те, що таке Firebase і як його експлуатувати тут.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Базове розуміння застосунку — Manifest.xml, strings.xml

**Перевірка файлів _Manifest.xml_ та _strings.xml_ додатку може виявити потенційні вразливості**. До цих файлів можна отримати доступ за допомогою декомпіляторів або перейменувавши розширення файлу APK на .zip і розпаковавши його.

**Уразливості**, які можна ідентифікувати з **Manifest.xml**, включають:

- **Debuggable Applications**: Застосунки, встановлені як debuggable (`debuggable="true"`) у _Manifest.xml_, становлять ризик, оскільки вони дозволяють підключення, які можуть призвести до експлуатації. Для кращого розуміння того, як експлуатувати debuggable-застосунки, зверніться до посібника з пошуку та експлуатації debuggable applications на пристрої.
- **Backup Settings**: Атрибут `android:allowBackup="false"` має бути явним для застосунків, що працюють з чутливою інформацією, щоб запобігти несанкціонованому резервному копіюванню через adb, особливо коли увімкнуто usb debugging.
- **Network Security**: Кастомні конфігурації мережевої безпеки (`android:networkSecurityConfig="@xml/network_security_config"`) у _res/xml/_ можуть вказувати деталі безпеки, такі як certificate pins і налаштування HTTP-трафіку. Приклад — дозволити HTTP-трафік для конкретних доменів.
- **Exported Activities and Services**: Ідентифікація exported activities та services у manifest може вказати на компоненти, які можуть бути зловживані. Подальший аналіз під час динамічного тестування може виявити, як експлуатувати ці компоненти.
- **Content Providers and FileProviders**: Відкриті content providers можуть дозволити несанкціонований доступ або модифікацію даних. Конфігурацію FileProviders також слід ретельно перевірити.
- **Broadcast Receivers and URL Schemes**: Ці компоненти можуть бути використані для експлуатації, з особливою увагою до того, як URL schemes обробляються на предмет уразливостей введення.
- **SDK Versions**: Атрибути `minSdkVersion`, `targetSDKVersion`, та `maxSdkVersion` вказують підтримувані версії Android, підкреслюючи важливість непідтримування застарілих, вразливих версій Android з міркувань безпеки.

З файлу **strings.xml** можна виявити чутливу інформацію, таку як API keys, custom schemas та інші нотатки розробника, що підкреслює необхідність уважного перегляду цих ресурсів.

### Tapjacking

**Tapjacking** — це атака, коли **malicious application** запускається і **позиціонує себе поверх жертви-application**. Після того як воно візуально затемнює застосунок-жертву, його інтерфейс спроектований так, щоб обдурити користувача і змусити його взаємодіяти з ним, при цьому події пересилаються застосунку-жертві.\
Фактично, це **осліплює користувача від того, що він насправді виконує дії в застосунку-жертві**.

Дізнайтеся більше в:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Активність з встановленим **`launchMode`** в значення **`singleTask` без визначеного `taskAffinity`** вразлива до Task Hijacking. Це означає, що **зловмисний application** може бути встановлений і, якщо його запустити до справжнього застосунку, він може **перехопити задачу реального застосунку** (тому користувач буде взаємодіяти з **malicious application**, думаючи, що використовує справжній).

Детальніше в:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Insecure data storage

**Internal Storage**

В Android файли, які **зберігаються** в **internal** сховищі, призначені бути **доступними** виключно для **застосунку**, який їх **створив**. Ця міра безпеки **забезпечується** операційною системою Android і зазвичай є адекватною для потреб безпеки більшості застосунків. Однак розробники іноді використовують режими, такі як `MODE_WORLD_READABLE` та `MODE_WORLD_WRITABLE`, щоб **дозволити** спільний доступ до файлів між різними застосунками. Проте ці режими **не обмежують доступ** до цих файлів іншими застосунками, включно з потенційно шкідливими.

1. **Static Analysis:**
- **Переконайтеся**, що використання `MODE_WORLD_READABLE` та `MODE_WORLD_WRITABLE` **ретельно перевірене**. Ці режими **можуть потенційно відкрити** файли для **непередбачуваного або несанкціонованого доступу**.
2. **Dynamic Analysis:**
- **Перевірте** права (permissions), встановлені на файлах, створених додатком. Зокрема, **перевірте**, чи якісь файли **встановлені як доступні для читання або запису для всіх**. Це може становити серйозний ризик безпеки, оскільки дозволило б **будь-якому application**, встановленому на пристрої, незалежно від його походження або намірів, **читати або змінювати** ці файли.

**External Storage**

Працюючи з файлами на **external storage**, таких як SD-карти, слід дотримуватись певних застережень:

1. **Доступність**:
- Файли на external storage є **загальночитаними та загальнозаписуваними**. Це означає, що будь-який застосунок або користувач може отримати до них доступ.
2. **Проблеми безпеки**:
- Через легкість доступу не рекомендовано **зберігати чутливу інформацію** на external storage.
- External storage може бути вилучено або доступно будь-якому застосунку, що робить його менш безпечним.
3. **Обробка даних з external storage**:
- Завжди **виконуйте валідацію введення** на даних, отриманих з external storage. Це критично, оскільки дані походять з недовіреного джерела.
- Не рекомендується зберігати виконувані файли або class-файли на external storage для динамічного завантаження.
- Якщо ваш додаток все ж має отримувати виконувані файли з external storage, переконайтеся, що ці файли **підписані та криптографічно перевірені** перед їх динамічним завантаженням. Цей крок є життєво важливим для збереження цілісності безпеки вашого додатку.

External storage можна **знайти** в `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> Починаючи з Android 4.4 (**API 17**), структура директорій на SD-карті **обмежує доступ додатка тільки до директорії, яка конкретно призначена для цього додатка**. Це запобігає отриманню шкідливим application доступу для читання або запису файлів іншого додатка.

**Sensitive data stored in clear-text**

- **Shared preferences**: Android дозволяє кожному додатку легко зберігати xml-файли в шляху `/data/data/<packagename>/shared_prefs/` і іноді в цій теці можна знайти чутливу інформацію у відкритому вигляді.
- **Databases**: Android дозволяє кожному додатку легко зберігати sqlite-бази даних в шляху `/data/data/<packagename>/databases/` і іноді в цій теці можна знайти чутливу інформацію у відкритому вигляді.

### Broken TLS

**Accept All Certificates**

З якоїсь причини іноді розробники приймають усі certificates навіть якщо, наприклад, hostname не збігається, з рядками коду, подібними до наступного:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Недоліки криптографії

**Неналежне управління ключами**

Деякі розробники зберігають чутливі дані у локальному сховищі та шифрують їх ключем, який захардкожений/передбачуваний у коді. Так робити не слід, оскільки зворотний інжиніринг може дозволити атакуючим витягти конфіденційну інформацію.

**Використання небезпечних та/або застарілих алгоритмів**

Розробникам не слід використовувати **застарілі алгоритми** для виконання перевірок авторизації, збереження або відправки даних. Деякі з таких алгоритмів: RC4, MD4, MD5, SHA1... Якщо для збереження паролів, наприклад, використовуються **хеші**, слід застосовувати стійкі до брутфорсу **хеші** з salt.

### Інші перевірки

- Рекомендується **обфусціювати APK**, щоб ускладнити роботу з реверс-інжинірингу для атакуючих.
- Якщо додаток є чутливим (наприклад банківський), він повинен виконувати власні перевірки, щоб визначити, чи пристрій є rooted, і діяти відповідно.
- Якщо додаток є чутливим (наприклад банківський), він повинен перевіряти, чи використовується **emulator**.
- Якщо додаток є чутливим (наприклад банківський), він повинен **перевіряти власну цілісність перед виконанням**, щоб упевнитися, що його не модифіковано.
- Використовуйте [**APKiD**](https://github.com/rednaga/APKiD), щоб перевірити, який compiler/packer/obfuscator був використаний для побудови APK

### React Native Application

Прочитайте наступну сторінку, щоб дізнатися, як легко отримати доступ до javascript-коду React-додатків:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Прочитайте наступну сторінку, щоб дізнатися, як легко отримати доступ до C# коду xamarin-додатків:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

Згідно з цим [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/), superpacked — це алгоритм Meta, який стискає вміст додатку в один файл. У блогу обговорюється можливість створення додатку, який розпаковує такого типу додатки... та більш швидкий спосіб, який полягає у **запуску додатку й зборі розпакованих файлів з файлової системи.**

### Automated Static Code Analysis

Інструмент [**mariana-trench**](https://github.com/facebook/mariana-trench) здатний знаходити **vulnerabilities**, скануючи **code** додатку. Цей інструмент містить низку **known sources** (які вказують інструменту **місця**, де **input** контролюється користувачем), **sinks** (які вказують інструменту **небезпечні** **місця**, де зловмисний ввід може завдати шкоди) та **rules**. Ці правила вказують **комбінації** **sources-sinks**, що означають наявність вразливості.

Завдяки цьому **mariana-trench перегляне код і знайде можливі вразливості в ньому**.

### Secrets leaked

Додаток може містити секрети (API keys, passwords, hidden urls, subdomains...) всередині, які ви можете виявити. Ви можете використати інструмент, наприклад [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Інші цікаві функції

- **Виконання коду**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Відправка SMS**: `sendTextMessage, sendMultipartTestMessage`
- **Нативні функції** оголошені як `native`: `public native, System.loadLibrary, System.load`
- [Прочитайте це, щоб дізнатися **як реверсити нативні функції**](reversing-native-libraries.md)
- Виконання нативного коду в пам’яті через JNI (завантажений shellcode → mmap/mprotect → виклик):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Інші трюки**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Динамічний аналіз

> Перш за все, вам потрібне середовище, де ви можете встановити додаток та все оточення (Burp CA cert, Drozer та Frida в першу чергу). Тому настійно рекомендується використовувати rooted пристрій (емулятор чи ні).

### Онлайн-динамічний аналіз

Ви можете створити **безкоштовний акаунт** на: [https://appetize.io/](https://appetize.io). Ця платформа дозволяє **завантажувати** та **запускати** APK, тому корисна для спостереження за поведінкою apk.

Ви навіть можете **переглядати логи вашого додатку** у вебі та підключатися через **adb**.

![](<../../images/image (831).png>)

Завдяки ADB-підключенню ви можете використовувати **Drozer** та **Frida** всередині емуляторів.

### Локальний динамічний аналіз

#### Використання емулятора

- [**Android Studio**](https://developer.android.com/studio) (Ви можете створювати **x86** та **arm** пристрої, і, згідно з [**цим**](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html), **останні x86** версії **підтримують ARM бібліотеки** без потреби у повільному arm емуляторі).
- Навчіться налаштовувати його на цій сторінці:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(безкоштовна версія:** Personal Edition, потрібно створити акаунт. _Рекомендується **завантажити** версію **З**_ _**VirtualBox**, щоб уникнути потенційних помилок._)
- [**Nox**](https://es.bignox.com) (Безкоштовний, але не підтримує Frida або Drozer).

> [!TIP]
> При створенні нового емулятора на будь-якій платформі пам’ятайте, що чим більший екран, тим повільніше працюватиме емулятор. Тому обирайте невеликі екрани, якщо це можливо.

Щоб **встановити google services** (наприклад AppStore) в Genymotion, потрібно натиснути на кнопку, позначену червоним на наступному зображенні:

![](<../../images/image (277).png>)

Також зверніть увагу, що в **конфігурації Android VM в Genymotion** ви можете обрати **Bridge Network mode** (це буде корисно, якщо ви підключатиметесь до Android VM з іншої VM з інструментами).

#### Використання фізичного пристрою

Потрібно активувати опції **debugging**, і було б добре, якщо ви зможете **root** його:

1. **Settings**.
2. (From Android 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Після встановлення додатку перше, що слід зробити — спробувати його і вивчити, що він робить, як працює та ознайомитися з ним.\
> Рекомендую **виконати цей початковий динамічний аналіз, використовуючи MobSF dynamic analysis + pidcat**, щоб ми могли **зрозуміти, як працює додаток**, поки MobSF **захоплює** багато **цікавих** **даних**, які ви зможете переглянути пізніше.

Magisk/Zygisk короткі нотатки (рекомендовано для Pixel пристроїв)
- Patch boot.img with the Magisk app and flash via fastboot to get systemless root
- Enable Zygisk + DenyList for root hiding; consider LSPosed/Shamiko when stronger hiding is required
- Keep original boot.img to recover from OTA updates; re-patch after each OTA
- For screen mirroring, use scrcpy on the host



### Ненавмисне витікання даних

**Logging**

Розробникам слід бути обережними з публічним розкриттям **debugging information**, оскільки це може призвести до витоку чутливих даних. Рекомендуються інструменти [**pidcat**](https://github.com/JakeWharton/pidcat) та `adb logcat` для моніторингу логів додатку з метою виявлення та захисту чутливої інформації. **Pidcat** віддається перевага за його зручність у використанні та читабельність.

> [!WARNING]
> Зауважте, що починаючи з версій **пізніших за Android 4.0**, **додатки можуть отримувати доступ лише до власних логів**. Отже, додатки не можуть читати логи інших додатків.\
> У будь-якому випадку, все ще рекомендується **не логувати чутливу інформацію**.

**Копіювання/вставка (буфер обміну)**

Фреймворк Android на основі буфера обміну забезпечує функціональність копіювання/вставки в додатках, проте несе ризик, оскільки **інші додатки** можуть **доступатися** до буфера обміну, потенційно розкриваючи чутливі дані. Важливо **відключати функції копіювання/вставки** для чутливих розділів додатку, наприклад деталей кредитної картки, щоб запобігти витоку даних.

**Crash Logs**

Якщо додаток **впаде** і **збере логи**, ці логи можуть допомогти атакуючим, особливо коли додаток важко піддається реверсу. Щоб зменшити цей ризик, уникайте логування при крашах, а якщо логи все ж надсилаються по мережі, забезпечте передачу через SSL-канал.

Як pentester, **спробуйте переглянути ці логи**.

**Відправка аналітики третім сторонам**

Додатки часто інтегрують сервіси, такі як Google Adsense, що через неправильну реалізацію може ненавмисно **витікати чутливі дані**. Щоб виявити потенційні витоки даних, радиться **перехопити трафік додатку** та перевірити, чи не надсилається чутлива інформація третім сторонам.

### SQLite DBs

Більшість додатків використовує **внутрішні SQLite бази даних** для збереження інформації. Під час pentest перегляньте **бази даних**, назви **таблиць** та **стовпців**, а також всі **збережені дані**, оскільки ви можете знайти **чутливу інформацію** (що буде вразливістю).\
Бази даних мають знаходитися в `/data/data/the.package.name/databases`, наприклад `/data/data/com.mwr.example.sieve/databases`

Якщо база даних зберігає конфіденційну інформацію і вона **зашифрована**, але ви можете **знайти** **пароль** всередині додатку, це все одно є **vulnerability**.

Перелічіть таблиці за допомогою `.tables` і перераховуйте стовпці таблиць командою `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

Згідно з [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** дозволяє вам **взяти на себе роль Android-додатку** та взаємодіяти з іншими додатками. Він може робити **будь-що, що може робити встановлений додаток**, наприклад використовувати механізм Inter-Process Communication (IPC) Android та взаємодіяти з базовою операційною системою.\
Drozer — корисний інструмент для **експлуатації exported activities, exported services та Content Providers**, як ви дізнаєтесь у наступних розділах.

### Експлуатація exported Activities

[**Прочитайте це, якщо хочете освіжити, що таке Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Також пам’ятайте, що код activity починається в методі **`onCreate`**.

**Обхід авторизації**

Коли Activity експортується, ви можете викликати її екран з зовнішнього додатку. Тому, якщо activity з **чутливою інформацією** є **exported**, ви можете **обійти** механізми **автентифікації** для доступу до неї.

[**Дізнайтеся, як експлуатувати exported activities за допомогою Drozer.**](drozer-tutorial/index.html#activities)

Ви також можете запустити exported activity з adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**ПРИМІТКА**: MobSF буде виявляти як шкідливе використання _**singleTask/singleInstance**_ як `android:launchMode` в activity, але через [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), схоже, це небезпечно лише на старих версіях (API versions < 21).

> [!TIP]
> Зверніть увагу, що an authorisation bypass не завжди є вразливістю — це залежить від того, як працює bypass і яка інформація стає доступною.

**Sensitive information leakage**

**Activities can also return results**. Якщо вам вдасться знайти експортований та незахищений activity, який викликає метод **`setResult`** і **повертає конфіденційну інформацію**, відбувається sensitive information leakage.

#### Tapjacking

Якщо tapjacking не запобігається, ви можете зловживати експортованим activity, щоб змусити **користувача виконувати непередбачувані дії**. Для детальнішої інформації про [**що таке Tapjacking — див. посилання**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Читайте це, якщо хочете оновити знання про Content Provider.**](android-applications-basics.md#content-provider)\
Content providers в основному використовуються для **обміну даними**. Якщо додаток має доступні content providers, ви можете мати змогу **витягти конфіденційні** дані з них. Також цікаво протестувати можливі **SQL injections** та **Path Traversals**, оскільки вони можуть бути вразливими.

[**Дізнайтеся, як експлуатувати Content Providers за допомогою Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Читайте це, якщо хочете освіжити, що таке Service.**](android-applications-basics.md#services)\
Пам'ятайте, що дії Service починаються в методі `onStartCommand`.

Оскільки service по суті може **отримувати дані**, **обробляти** їх і **повертати** (або ні) відповідь. Отже, якщо додаток експортує якісь services, вам слід **перевірити** **код**, щоб зрозуміти, що він робить, і **протестувати** його **динамічно** для витягнення конфіденційної інформації, обходу заходів аутентифікації тощо.\
[**Дізнайтеся, як експлуатувати Services за допомогою Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Читайте це, якщо хочете освіжити, що таке Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Пам'ятайте, що дії Broadcast Receiver починаються в методі `onReceive`.

Broadcast receiver чекатиме певного типу повідомлення. Залежно від того, як receiver обробляє повідомлення, він може бути вразливим.\
[**Дізнайтеся, як експлуатувати Broadcast Receivers за допомогою Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Ви можете шукати deep links вручну, використовуючи інструменти на кшталт MobSF або скрипти, як-от [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Ви можете **відкрити** оголошену **scheme** за допомогою **adb** або **браузера**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Зауважте, що ви можете **опустити назву пакета**, і мобільний пристрій автоматично викличе додаток, який має відкрити це посилання._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Code executed**

Щоб знайти **код, який буде виконаний в App**, перейдіть до activity, викликаної deeplink, і знайдіть функцію **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Sensitive info**

Щоразу, коли ви знаходите deep link, перевіряйте, що **він не отримує чутливих даних (наприклад паролів) через URL parameters**, тому що будь-який інший додаток може **видавати себе за deep link і вкрасти ці дані!**

**Parameters in path**

Ви **повинні також перевіряти, чи будь-який deep link використовує параметр всередині шляху** URL, наприклад: `https://api.example.com/v1/users/{username}` , у такому випадку ви можете спричинити path traversal, звернувшись до `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Note that if you find the correct endpoints inside the application you may be able to cause a **Open Redirect** (if part of the path is used as domain name), **account takeover** (if you can modify users details without CSRF token and the vuln endpoint used the correct method) and any other vuln. More [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Transport Layer Inspection and Verification Failures

- **Certificates are not always inspected properly** — додатки Android часто ігнорують warnings і приймають self-signed certificates або, в деяких випадках, повертаються до використання HTTP connections.
- **Negotiations during the SSL/TLS handshake are sometimes weak** — іноді переговори під час SSL/TLS handshake використовують ненадійні cipher suites. Це робить з'єднання вразливим до man-in-the-middle (MITM) атак, дозволяючи атакуючим розшифровувати дані.
- **Leakage of private information** is a risk when applications authenticate using secure channels but then communicate over non-secure channels for other transactions. This approach fails to protect sensitive data, such as session cookies or user details, from interception by malicious entities.

#### Certificate Verification

Ми зосередимось на **certificate verification**. Потрібно перевіряти цілісність server's certificate для підвищення безпеки. Це критично, оскільки insecure TLS configurations та передача чутливих даних через незашифровані канали можуть становити значні ризики. Для детальних кроків щодо перевірки серверних сертифікатів та усунення вразливостей, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) надає вичерпні рекомендації.

#### SSL Pinning

SSL Pinning — це міра безпеки, коли додаток перевіряє server's certificate проти відомої копії, збереженої всередині самого додатку. Цей метод є важливим для запобігання MITM атак. Рекомендується впроваджувати SSL Pinning для додатків, що обробляють чутливу інформацію.

#### Traffic Inspection

Щоб інспектувати HTTP трафік, необхідно **встановити proxy tool's certificate** (наприклад, Burp). Без встановлення цього сертифіката зашифрований трафік може бути невидимим через proxy. Для керівництва з встановлення custom CA certificate, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Applications targeting **API Level 24 and above** require modifications to the Network Security Config to accept the proxy's CA certificate. Цей крок є критичним для інспекції зашифрованого трафіку. Для інструкцій щодо зміни Network Security Config, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

Якщо використовується **Flutter**, вам потрібно слідувати інструкціям на [**this page**](flutter.md). Це тому, що просте додавання сертифіката в сховище не спрацює, оскільки Flutter має власний список валідних CAs.

#### Static detection of SSL/TLS pinning

Перед спробами runtime bypasses швидко замапьте, де pinning застосовується в APK. Статичне виявлення допомагає планувати hooks/patches і зосередитися на правильних code paths.

Tool: SSLPinDetect
- Open-source static-analysis utility that decompiles the APK to Smali (via apktool) and scans for curated regex patterns of SSL/TLS pinning implementations.
- Reports exact file path, line number, and a code snippet for each match.
- Covers common frameworks and custom code paths: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Використання
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Приклад правил шаблонів (JSON)
Використовуйте або розширюйте signatures для виявлення пропрієтарних/кастомних стилів pinning. Ви можете завантажити власний JSON і сканувати в масштабі.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes and tips
- Швидке сканування великих додатків через multi-threading і memory-mapped I/O; pre-compiled regex знижує накладні витрати/false positives.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Typical detection targets to triage next:
- OkHttp: використання CertificatePinner, setCertificatePinner, посилання на пакети okhttp3/okhttp
- Custom TrustManagers: javax.net.ssl.X509TrustManager, перевизначення checkServerTrusted
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init з custom managers
- Declarative pins у res/xml network security config та посилання в manifest
- Використовуйте matched locations для планування Frida hooks, static patches або перегляду конфігурацій перед динамічним тестуванням.



#### Bypassing SSL Pinning

Коли реалізовано SSL Pinning, його обходження стає необхідним для інспекції HTTPS-трафіку. Для цього доступні різні методи:

- Автоматично **modify** the **apk** щоб **bypass** SSLPinning з [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Найбільший плюс цього варіанту в тому, що не потрібен root для обходу SSL Pinning, але потрібно видалити додаток і перевстановити новий варіант, і це не завжди працює.
- Ви можете використовувати **Frida** (описано нижче) для обходу цього захисту. Ось гайд по використанню Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Також можна спробувати **automatically bypass SSL Pinning** використовуючи [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Також можна спробувати **automatically bypass SSL Pinning** за допомогою **MobSF dynamic analysis** (описано нижче)
- Якщо ви все ще вважаєте, що якийсь трафік не перехоплюється, можна спробувати **forward the traffic to burp using iptables**. Читайте цей блог: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Looking for Common Web Vulnerabilities

Важливо також шукати поширені веб-уразливості всередині додатку. Детальна інформація про ідентифікацію та пом'якшення цих уразливостей виходить за межі цього короткого огляду, але детально розглядається в інших джерелах.

### Frida

[Frida](https://www.frida.re) — інструмент динамічної інструменталізації для розробників, реверс-інженерів і дослідників безпеки.\
**Ви можете отримати доступ до запущеного додатку і hook methods під час run time, щоб змінювати поведінку, змінювати значення, витягувати значення, виконувати інший код...**\
Якщо ви хочете pentest Android applications вам потрібно знати, як використовувати Frida.

- Дізнайтеся, як використовувати Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Деякі "GUI" для дій з Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Ви можете знайти деякі Awesome Frida скрипти тут: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Спробуйте обходити anti-debugging / anti-frida механізми, завантажуючи Frida як показано в [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (інструмент [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Дамп пам'яті - Fridump**

Перевірте, чи додаток зберігає в пам'яті конфіденційну інформацію, яку він не повинен зберігати, наприклад паролі або мнемоніки.

Використовуючи [**Fridump3**](https://github.com/rootbsd/fridump3) ви можете зробити дамп пам'яті додатку за допомогою:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Це зробить dump пам'яті у папку ./dump, і там ви можете виконати grep приблизно так:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Чутливі дані в Keystore**

В Android Keystore — найкраще місце для зберігання чутливих даних, проте при наявності достатніх привілеїв все ще **можна отримати до нього доступ**. Оскільки додатки часто зберігають тут **чутливі дані у відкритому вигляді**, pentests повинні перевіряти це, оскільки користувач root або особа з фізичним доступом до пристрою може викрасти ці дані.

Навіть якщо додаток зберігає дані в Keystore, ці дані повинні бути зашифровані.

Щоб отримати доступ до даних у Keystore, можна використати цей Frida script: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

За допомогою наведеного нижче Frida-скрипта можливо здійснити **bypass fingerprint authentication**, яке Android-застосунки можуть використовувати для **protect certain sensitive areas:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Фонові зображення**

Коли ви переводите додаток у фоновий режим, Android зберігає **знімок додатку**, щоб при поверненні на передній план він спочатку завантажив це зображення перед самим додатком — так здається, ніби додаток завантажився швидше.

Однак, якщо цей знімок містить **чутливу інформацію**, людина з доступом до знімка може **викрасти цю інформацію** (зауважте, що для доступу потрібен root).

Знімки зазвичай зберігаються приблизно тут: **`/data/system_ce/0/snapshots`**

Android надає спосіб **запобігти захопленню скріншотів шляхом встановлення параметра розмітки FLAG_SECURE**. Використовуючи цей прапорець, вміст вікна позначається як захищений, що запобігає його появі у скріншотах або перегляду на ненадійних дисплеях.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Цей інструмент може допомогти вам керувати різними інструментами під час динамічного аналізу: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Розробники часто створюють проксі-компоненти, такі як activities, services і broadcast receivers, які обробляють ці Intents і передають їх у методи на кшталт `startActivity(...)` або `sendBroadcast(...)`, що може бути ризиковано.

Небезпека полягає в тому, що атака дозволяє зловмисникам викликати non-exported компоненти додатку або отримати доступ до чутливих content providers, перенаправивши ці Intents. Яскравим прикладом є компонент `WebView`, який конвертує URL у `Intent` об’єкти через `Intent.parseUri(...)` і потім виконує їх, що може призвести до шкідливих Intent ін’єкцій.

### Essential Takeaways

- **Intent Injection** схоже на web-ову проблему Open Redirect.
- Експлойти включають передачу `Intent` об’єктів як extras, які можуть бути перенаправлені для виконання небезпечних операцій.
- Це може відкрити non-exported компоненти та content providers для атаки.
- Конверсія URL у `Intent` у `WebView` може сприяти виконанню небажаних дій.

### Android Client Side Injections and others

Ймовірно, ви знаєте про цей тип вразливостей з Web. Особливо уважними потрібно бути з такими вразливостями в Android-застосунку:

- **SQL Injection:** При роботі з динамічними запитами або Content-Providers переконайтеся, що використовуєте параметризовані запити.
- **JavaScript Injection (XSS):** Перевірте, що підтримка JavaScript і Plugin вимкнена для всіх WebViews (за замовчуванням вимкнена). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews повинні мати доступ до файлової системи вимкненим (увімкнено за замовчуванням) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: У деяких випадках, коли android-застосунок завершує сесію, cookie не відкликається або навіть може бути збережений на диск.
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Static analysis**

![](<../../images/image (866).png>)

**Оцінка вразливостей застосунку** з використанням зручного web-based frontend. Ви також можете виконати dynamic analysis (але потрібно підготувати середовище).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Зауважте, що MobSF може аналізувати **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Також, якщо ви створите **ZIP** файл із вихідним кодом для **Android** або **IOS** додатка (перейдіть у кореневу теку застосунку, виділіть все й створіть ZIPfile), MobSF зможе проаналізувати і його.

MobSF також дозволяє робити **diff/Compare** аналізів та інтегрувати **VirusTotal** (вам потрібно встановити ваш API key у _MobSF/settings.py_ і увімкнути його: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). Ви також можете встановити `VT_UPLOAD` в `False`, тоді буде завантажено **hash** замість файлу.

### Assisted Dynamic analysis with MobSF

**MobSF** також може бути дуже корисним для **dynamic analysis** в **Android**, але в цьому випадку вам потрібно встановити MobSF і **genymotion** на ваш хост (VM або Docker не працюватимуть). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
**MobSF dynamic analyser** може:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). Усе це виконується автоматично, окрім скріншотів — вам потрібно натиснути, коли ви хочете зробити скріншот, або натиснути "**Exported Activity Tester**", щоб отримати скріншоти всіх експортованих activity.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

Для android **versions > 5**, він **automatically start Frida** і встановить глобальні налаштування **proxy** для **capture** трафіку. Він буде захоплювати трафік лише з тестованого застосунку.

**Frida**

За замовчуванням він також використовує деякі Frida Scripts для **bypass SSL pinning**, **root detection** і **debugger detection** та для **monitor interesting APIs**.\
MobSF також може **invoke exported activities**, захоплювати **screenshots** цих activity і **save** їх для звіту.

Щоб **start** dynamic testing натисніть зелену кнопку: "**Start Instrumentation**". Натисніть "**Frida Live Logs**", щоб побачити логи, які генерують Frida scripts, і "**Live API Monitor**", щоб бачити всі виклики hook-нутних методів, передані аргументи та повернуті значення (це з’явиться після натискання "Start Instrumentation").\
MobSF також дозволяє завантажувати ваші власні **Frida scripts** (щоб надіслати результати ваших Frida scripts до MobSF використовуйте функцію `send()`). Він також має **several pre-written scripts**, які можна завантажити (ви можете додати більше у `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), просто **select them**, натисніть "**Load**" і потім "**Start Instrumentation**" (ви зможете бачити логи цих скриптів у "**Frida Live Logs**").

![](<../../images/image (419).png>)

Крім того, у вас є кілька допоміжних функцій Frida:

- **Enumerate Loaded Classes**: виведе всі завантажені класи
- **Capture Strings**: виводитиме всі захоплені рядки під час використання застосунку (дуже шумно)
- **Capture String Comparisons**: може бути дуже корисним. Показуватиме 2 рядки, що порівнюються, і чи був результат True або False.
- **Enumerate Class Methods**: Введіть назву класу (наприклад "java.io.File") і він виведе всі методи класу.
- **Search Class Pattern**: пошук класів за шаблоном
- **Trace Class Methods**: **Trace** весь **class** (див. входи та виходи всіх методів класу). Пам’ятайте, що за замовчуванням MobSF трасує кілька цікавих Android Api методів.

Після того, як ви обрали допоміжний модуль, який хочете використовувати, потрібно натиснути "**Start Intrumentation**" і ви побачите всі виходи у "**Frida Live Logs**".

**Shell**

MobSF також надає shell із деякими командами **adb**, **MobSF commands**, та загальними **shell** **commands** унизу сторінки dynamic analysis. Деякі цікаві команди:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP інструменти**

When http traffic is capture you can see an ugly view of the captured traffic on "**HTTP(S) Traffic**" bottom or a nicer view in "**Start HTTPTools**" green bottom. From the second option, you can **send** the **captured requests** to **proxies** like Burp or Owasp ZAP.\
To do so, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> press "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Once you finish the dynamic analysis with MobSF you can press on "**Start Web API Fuzzer**" to **fuzz http requests** an look for vulnerabilities.

> [!TIP]
> Після виконання dynamic analysis з MobSF налаштування proxy settings можуть бути некоректними і ви не зможете виправити їх через GUI. Ви можете виправити proxy settings, виконавши:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

You can get the tool from [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
This tool with use some **Hooks** to let you know **what is happening in the application** while you perform a **dynamic analysis**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

This is a **great tool to perform static analysis with a GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

This tool is designed to look for several **security related Android application vulnerabilities**, either in **source code** or **packaged APKs**. The tool is also **capable of creating a "Proof-of-Concept" deployable APK** and **ADB commands**, to exploit some of the found vulnerabilities (Exposed activities, intents, tapjacking...). As with Drozer, there is no need to root the test device.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Показує всі вилучені файли для зручного перегляду
- Автоматично декомпілює APK файли у Java та Smali формат
- Аналізує AndroidManifest.xml на предмет поширених вразливостей та поведінки
- Static source code analysis for common vulnerabilities and behavior
- Інформація про пристрій
- та інше
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER — це консольний застосунок, який можна використовувати в Windows, MacOS X та Linux; він аналізує _.apk_ файли в пошуках вразливостей. Він робить це шляхом розпакування APKs та застосування ряду правил для виявлення цих вразливостей.

Усі правила зосереджені у файлі `rules.json`, і кожна компанія або тестувальник може створити власні правила для аналізу того, що їм потрібно.

Завантажте останні бінарні файли на сторінці [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn — це **crossplatform** інструмент, який допомагає розробникам, bugbounty hunters та ethical hackers виконувати [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) мобільних додатків.

Ідея полягає в тому, що ви перетягуєте свій файл мобільного додатку (файл .apk або .ipa) на застосунок StaCoAn, і він згенерує для вас візуальний та переносний звіт. Ви можете налаштувати параметри та wordlists, щоб отримати персоналізований досвід.

Завантажити[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework — система аналізу вразливостей Android, яка допомагає розробникам або hackers виявляти потенційні вразливості в Android-додатках.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** — інструмент, основна мета якого — виявляти та попереджувати користувача про потенційно шкідливу поведінку, реалізовану Android-додатком.

Виявлення виконується за допомогою **static analysis** байткоду Dalvik додатку, представленого як **Smali**, з використанням бібліотеки [`androguard`](https://github.com/androguard/androguard).

Цей інструмент шукає **common behavior of "bad" applications** такі, як: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. Це інструмент, який об'єднує часто використовувані інструменти для reverse engineering та analysis мобільних додатків, щоб допомогти тестувати мобільні додатки проти загроз безпеці OWASP. Його мета — зробити це завдання простішим і зручнішим для розробників мобільних додатків та фахівців із безпеки.

Він може:

- Витягувати Java та Smali code за допомогою різних інструментів
- Аналізувати APKs за допомогою: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Витягувати приватну інформацію з APK за допомогою regexps.
- Аналізувати Manifest.
- Аналізувати знайдені домени за допомогою: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Корисно для виявлення malware: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Зауважте, що залежно від сервісу та конфігурації, яку ви використовуєте для обфускації code, секрети можуть бути обфусковані або ні.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. It is able to optimize bytecode as well as detect and remove unused instructions. ProGuard is free software and is distributed under the GNU General Public License, version 2.

ProGuard is distributed as part of the Android SDK and runs when building the application in release mode.

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Last time we checked, the Dexguard mode of operation was:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

Ви можете завантажити обфускований APK на їх платформу.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

It is a **generic android deobfuscator.** Simplify **virtually executes an app** to understand its behavior and then **tries to optimize the code** so it behaves identically but is easier for a human to understand. Each optimization type is simple and generic, so it doesn't matter what the specific type of obfuscation is used.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD gives you information about **how an APK was made**. It identifies many **compilers**, **packers**, **obfuscators**, and other weird stuff. It's [_PEiD_](https://www.aldeid.com/wiki/PEiD) for Android.

### Manual

[Прочитайте цей підручник, щоб дізнатися кілька трюків про **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b is an Android security virtual machine based on ubuntu-mate includes the collection of latest framework, tutorials and labs from different security geeks and researchers for reverse engineering and malware analysis.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Це чудовий список ресурсів
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
