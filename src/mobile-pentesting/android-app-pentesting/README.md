# Android-Anwendungen Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android-Anwendungen Grundlagen

Es wird dringend empfohlen, diese Seite zuerst zu lesen, um die **wichtigsten Teile im Zusammenhang mit Android-Sicherheit und die gefährlichsten Komponenten in einer Android-Anwendung** zu kennen:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Dies ist das Haupttool, das Sie benötigen, um eine Verbindung zu einem Android-Gerät (emuliert oder physisch) herzustellen.\
**ADB** ermöglicht die Steuerung von Geräten entweder über **USB** oder **Netzwerk** von einem Computer aus. Dieses Tool erlaubt das **Kopieren** von Dateien in beide Richtungen, die **Installation** und **Deinstallation** von Apps, die **Ausführung** von Shell-Befehlen, das **Sichern** von Daten, das **Lesen** von Logs, sowie andere Funktionen.

Schauen Sie sich die folgende Liste der [**ADB Commands**](adb-commands.md) an, um zu lernen, wie man adb verwendet.

## Smali

Manchmal ist es interessant, **den Anwendungscode zu ändern**, um auf **versteckte Informationen** (z. B. stark obfuskierte Passwörter oder Flags) zuzugreifen. Dann kann es interessant sein, das apk zu dekompilieren, den Code zu ändern und es neu zu kompilieren.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Dies kann sehr nützlich als **Alternative für mehrere Tests während der dynamischen Analyse** sein, die vorgestellt werden. Dann, **behalten Sie diese Möglichkeit immer im Hinterkopf**.

## Weitere interessante Tricks

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **APKs herunterladen**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- APK vom Gerät extrahieren:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Führe alle splits und base apks mit [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Fallstudien & Schwachstellen


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Statische Analyse

Zuerst sollten Sie bei der Analyse einer APK **den Java-Code ansehen** mithilfe eines Decompilers.\
Bitte, [**lesen Sie hier, um Informationen über verschiedene verfügbare Decompiler zu finden**](apk-decompilers.md).

### Nach interessanten Informationen suchen

Allein durch einen Blick auf die **strings** der APK kann man nach **Passwörtern**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **API-Keys**, **Verschlüsselung**, **Bluetooth-UUIDs**, **Tokens** und allem Interessanten suchen... achte auch auf Code-Ausführungs-Backdoors oder Authentifizierungs-Backdoors (hartkodierte Admin-Zugangsdaten für die App).

**Firebase**

Achten Sie besonders auf **Firebase-URLs** und prüfen Sie, ob es falsch konfiguriert ist. [Mehr Informationen darüber, was Firebase ist und wie man es ausnutzen kann, finden Sie hier.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Grundlegendes Verständnis der Anwendung - Manifest.xml, strings.xml

Die **Untersuchung der _Manifest.xml_ und **_strings.xml_** einer Anwendung kann potenzielle Sicherheitslücken aufdecken**. Auf diese Dateien kann man mit Decompilern zugreifen oder indem man die Dateiendung der APK in .zip ändert und sie entpackt.

**Schwachstellen**, die aus der **Manifest.xml** identifiziert werden können, umfassen:

- **Als debuggable markierte Anwendungen**: Anwendungen, die im _Manifest.xml_ als debuggable (`debuggable="true"`) gesetzt sind, stellen ein Risiko dar, da sie Verbindungen erlauben, die zu einer Ausnutzung führen können. Zur weiteren Erläuterung, wie man debuggable Anwendungen ausnutzt, siehe ein Tutorial zum Finden und Ausnutzen debuggable Anwendungen auf einem Gerät.
- **Backup-Einstellungen**: Das Attribut `android:allowBackup="false"` sollte explizit für Anwendungen gesetzt werden, die mit sensiblen Informationen umgehen, um unautorisierte Daten-Backups über adb zu verhindern, besonders wenn USB-Debugging aktiviert ist.
- **Network Security**: Eigene Network-Security-Konfigurationen (`android:networkSecurityConfig="@xml/network_security_config"`) in _res/xml/_ können Sicherheitsdetails wie Certificate Pinning und HTTP-Traffic-Einstellungen spezifizieren. Ein Beispiel ist das Zulassen von HTTP-Traffic für bestimmte Domains.
- **Exportierte Activities und Services**: Das Identifizieren exportierter Activities und Services im Manifest kann Komponenten hervorheben, die missbraucht werden könnten. Eine weitergehende Analyse während dynamischer Tests kann aufdecken, wie diese Komponenten ausgenutzt werden können.
- **Content Providers und FileProviders**: Offen gelegte Content Provider könnten unautorisierte Zugriffe oder Änderungen an Daten erlauben. Die Konfiguration von FileProviders sollte ebenfalls geprüft werden.
- **Broadcast Receivers und URL-Schemata**: Diese Komponenten könnten für Exploits genutzt werden, mit besonderem Augenmerk darauf, wie URL-Schemata Eingaben verarbeiten.
- **SDK-Versionen**: Die Attribute `minSdkVersion`, `targetSDKVersion` und `maxSdkVersion` geben die unterstützten Android-Versionen an und machen deutlich, wie wichtig es ist, veraltete, verwundbare Android-Versionen nicht zu unterstützen.

Aus der **strings.xml**-Datei lassen sich sensible Informationen wie API-Keys, Custom Schemes und andere Entwicklerhinweise entdecken, was die Notwendigkeit einer sorgfältigen Überprüfung dieser Ressourcen unterstreicht.

### Tapjacking

Tapjacking ist ein Angriff, bei dem eine **bösartige Anwendung** gestartet wird und sich **oberhalb einer Opfer-Anwendung positioniert**. Sobald sie die Opfer-App sichtbar überlagert, ist ihre Benutzeroberfläche so gestaltet, dass sie den Benutzer dazu verleitet, mit ihr zu interagieren, während sie diese Interaktion an die Opfer-App weiterleitet.\
Effektiv blendet sie den Benutzer aus, sodass er nicht bemerkt, dass er tatsächlich Aktionen in der Opfer-App ausführt.

Weitere Informationen finden Sie in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Eine **Activity** mit dem **`launchMode`** auf **`singleTask`** gesetzt und ohne definierte `taskAffinity` ist anfällig für Task Hijacking. Das bedeutet, dass eine **maligne Anwendung** installiert werden kann und, wenn sie vor der echten Anwendung gestartet wird, **die Task der echten Anwendung kapern** könnte (so wird der Benutzer mit der **bösartigen Anwendung interagieren und denken, er benutzt die echte**).

Mehr Informationen in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Unsichere Datenspeicherung

**Internal Storage**

In Android sind Dateien, die im **internen** Speicher **gespeichert** werden, **dazu gedacht**, ausschließlich von der **App**, die sie **erstellt** hat, zugänglich zu sein. Diese Sicherheitsmaßnahme wird vom Android-Betriebssystem **durchgesetzt** und ist für die Sicherheitsanforderungen der meisten Anwendungen in der Regel ausreichend. Entwickler nutzen jedoch manchmal Modi wie `MODE_WORLD_READABLE` und `MODE_WORLD_WRITABLE`, um Dateien zwischen verschiedenen Anwendungen zu **teilen**. Diese Modi **begrenzen den Zugriff** auf diese Dateien jedoch **nicht** gegenüber anderen Anwendungen, einschließlich potenziell bösartiger.

1. **Statische Analyse:**
- **Prüfen** Sie genau den Einsatz von `MODE_WORLD_READABLE` und `MODE_WORLD_WRITABLE`. Diese Modi **können Dateien ungewollt oder unautorisiert zugänglich machen**.
2. **Dynamische Analyse:**
- **Verifizieren** Sie die **Berechtigungen** von Dateien, die von der App erstellt wurden. Insbesondere **prüfen** Sie, ob Dateien **weltweit les- oder schreibbar** gesetzt sind. Dies kann ein erhebliches Sicherheitsrisiko darstellen, da es **jeder auf dem Gerät installierten Anwendung** erlauben würde, diese Dateien zu **lesen oder zu verändern**, egal woher sie stammt.

**External Storage**

Beim Umgang mit Dateien auf dem **externen Speicher**, wie SD-Karten, sollten bestimmte Vorsichtsmaßnahmen beachtet werden:

1. **Zugänglichkeit**:
- Dateien auf externem Speicher sind **global les- und schreibbar**. Das bedeutet, dass jede Anwendung oder jeder Benutzer auf diese Dateien zugreifen kann.
2. **Sicherheitsbedenken**:
- Aufgrund der einfachen Zugänglichkeit wird empfohlen, **keine sensiblen Informationen** auf externem Speicher zu speichern.
- Externer Speicher kann entfernt oder von jeder Anwendung ausgelesen werden, was ihn weniger sicher macht.
3. **Umgang mit Daten vom externen Speicher**:
- Führen Sie immer **Eingabevalidierung** auf Daten durch, die vom externen Speicher abgerufen werden. Das ist wichtig, da die Daten aus einer untrusted Quelle stammen.
- Das Speichern von ausführbaren Dateien oder Klassen auf externem Speicher zum dynamischen Laden wird stark abgeraten.
- Wenn Ihre Anwendung ausführbare Dateien vom externen Speicher laden muss, stellen Sie sicher, dass diese Dateien **signiert und kryptografisch verifiziert** sind, bevor sie dynamisch geladen werden. Dieser Schritt ist entscheidend für die Wahrung der Sicherheitsintegrität Ihrer Anwendung.

Der externe Speicher kann unter `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`` zugegriffen werden.

> [!TIP]
> Beginnend mit Android 4.4 (**API 17**) hat die SD-Karte eine Verzeichnisstruktur, die **den Zugriff einer App auf das Verzeichnis einschränkt, das speziell für diese App vorgesehen ist**. Dies verhindert, dass eine bösartige Anwendung Lese- oder Schreibzugriff auf die Dateien einer anderen App erhält.

**Sensitive data stored in clear-text**

- **Shared preferences**: Android ermöglicht jeder Anwendung, XML-Dateien im Pfad `/data/data/<packagename>/shared_prefs/` zu speichern, und manchmal lassen sich in diesem Ordner sensible Informationen im Klartext finden.
- **Databases**: Android ermöglicht jeder Anwendung, sqlite-Datenbanken im Pfad `/data/data/<packagename>/databases/` zu speichern, und manchmal lassen sich in diesem Ordner sensible Informationen im Klartext finden.

### Broken TLS

**Accept All Certificates**

Aus irgendeinem Grund akzeptieren Entwickler manchmal alle Zertifikate, selbst wenn zum Beispiel der Hostname nicht übereinstimmt, mit Codezeilen wie der folgenden:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Fehlerhafte Kryptographie

**Schwache Prozesse zur Schlüsselverwaltung**

Manche Entwickler speichern sensible Daten im lokalen Speicher und verschlüsseln sie mit einem im Code hardcodierten/vorhersagbaren Key. Das sollte nicht gemacht werden, da ein Reverse Engineering Angreifern ermöglichen kann, die vertraulichen Informationen zu extrahieren.

**Verwendung unsicherer und/oder veralteter Algorithmen**

Entwickler sollten keine **deprecated algorithms** verwenden, um Autorisierungs-**checks** durchzuführen, Daten zu **store** oder zu **send**. Einige dieser Algorithmen sind: RC4, MD4, MD5, SHA1... Wenn **hashes** beispielsweise verwendet werden, um Passwörter zu speichern, sollten hashes verwendet werden, die **brute-force resistant** sind und Salt nutzen.

### Weitere Prüfungen

- Es wird empfohlen, das **APK zu obfuscate**, um die Arbeit von reverse engineer Angreifern zu erschweren.
- Wenn die App sensibel ist (z.B. Bank-Apps), sollte sie eigene **Checks durchführen, um zu prüfen, ob das Mobilgerät gerootet ist**, und entsprechend reagieren.
- Wenn die App sensibel ist (z.B. Bank-Apps), sollte sie prüfen, ob ein **emulator** verwendet wird.
- Wenn die App sensibel ist (z.B. Bank-Apps), sollte sie **ihre eigene Integrität vor der Ausführung prüfen**, um festzustellen, ob sie verändert wurde.
- Nutze [**APKiD**](https://github.com/rednaga/APKiD), um zu prüfen, welcher Compiler/Packer/Obfuscator zum Bauen des APK verwendet wurde

### React Native Anwendung

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Anwendungen

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automatisierte statische Code-Analyse

Das Tool [**mariana-trench**](https://github.com/facebook/mariana-trench) ist in der Lage, **vulnerabilities** zu finden, indem es den **Code** der Anwendung **scannt**. Dieses Tool enthält eine Reihe von **known sources** (die dem Tool anzeigen, an welchen **Stellen** die **Input** **vom Benutzer kontrolliert** wird), **sinks** (die dem Tool **gefährliche** **Stellen** anzeigen, an denen bösartige Benutzereingaben Schaden verursachen könnten) und **rules**. Diese Rules geben die **Kombination** von **sources-sinks** an, die auf eine Schwachstelle hinweist.

Mit diesem Wissen wird **mariana-trench** den Code überprüfen und mögliche Schwachstellen finden.

### Secrets leaked

An application may contain secrets (API keys, passwords, hidden urls, subdomains...) inside of it that you might be able to discover. You could us a tool such as [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Andere interessante Funktionen

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)

### **Weitere Tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamische Analyse

> Zuerst brauchst du eine Umgebung, in der du die Anwendung und alle benötigten Komponenten installieren kannst (Burp CA cert, Drozer und Frida hauptsächlich). Daher wird ein rooted device (emuliert oder nicht) dringend empfohlen.

### Online Dynamic analysis

Du kannst ein **kostenloses Konto** bei: [https://appetize.io/](https://appetize.io/) erstellen. Diese Plattform erlaubt dir, **APKs hochzuladen** und **auszuführen**, sodass sie nützlich ist, um zu sehen, wie sich ein APK verhält.

Du kannst sogar **die Logs deiner Anwendung im Web sehen** und dich per **adb** verbinden.

![](<../../images/image (831).png>)

Dank der ADB-Verbindung kannst du **Drozer** und **Frida** in den Emulatoren verwenden.

### Lokale dynamische Analyse

#### Verwendung eines Emulators

- [**Android Studio**](https://developer.android.com/studio) (Du kannst **x86** und **arm** Geräte erstellen, und laut [**diesem** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**Support für ARM-Bibliotheken** haben die neuesten x86-Versionen ohne die Notwendigkeit eines langsamen ARM-Emulators).
- Lerne, es auf dieser Seite einzurichten:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, du musst ein Konto erstellen. _Es wird empfohlen, die Version **MIT** _**VirtualBox** herunterzuladen, um potenzielle Fehler zu vermeiden._)
- [**Nox**](https://es.bignox.com) (Kostenlos, unterstützt jedoch Frida oder Drozer nicht).

> [!TIP]
> Wenn du einen neuen Emulator auf einer beliebigen Plattform erstellst, denke daran, dass je größer der Bildschirm ist, desto langsamer der Emulator läuft. Wähle daher nach Möglichkeit kleine Bildschirme.

Um **google services** (wie AppStore) in Genymotion zu installieren, musst du auf den rot markierten Button im folgenden Bild klicken:

![](<../../images/image (277).png>)

Beachte außerdem, dass du in der **Konfiguration der Android VM in Genymotion** den **Bridge Network mode** wählen kannst (das ist nützlich, wenn du von einer anderen VM mit den Tools auf die Android-VM zugreifst).

#### Verwende ein physisches Gerät

Du musst die **debugging** Optionen aktivieren und es ist gut, wenn du es **rooten** kannst:

1. **Settings**.
2. (Ab Android 8.0) Wähle **System**.
3. Wähle **About phone**.
4. Drücke **Build number** 7 Mal.
5. Gehe zurück und du findest die **Developer options**.

> Sobald du die Anwendung installiert hast, solltest du sie zuerst ausprobieren und untersuchen, was sie tut, wie sie funktioniert, und dich damit vertraut machen.\
> Ich empfehle, **diese initiale dynamische Analyse mit MobSF dynamic analysis + pidcat** durchzuführen, sodass wir **lernen, wie die Anwendung funktioniert**, während MobSF viele **interessante** **Daten** erfasst, die du später überprüfen kannst.

Magisk/Zygisk Quick Notes (empfohlen auf Pixel-Geräten)
- Patch das boot.img mit der Magisk-App und flash es via fastboot, um systemless root zu erhalten
- Aktiviere Zygisk + DenyList zum Root-Hiding; erwäge LSPosed/Shamiko, wenn stärkeres Hiding notwendig ist
- Bewahre das originale boot.img, um von OTA-Updates wiederherstellen zu können; erneut patchen nach jedem OTA
- Für Screen-Mirroring nutze scrcpy auf dem Host



### Unbeabsichtigte Datenweitergabe

**Logging**

Entwickler sollten vorsichtig sein, **Debugging-Informationen** öffentlich preiszugeben, da dies zu sensiblen Daten leaks führen kann. Die Tools [**pidcat**](https://github.com/JakeWharton/pidcat) und `adb logcat` werden empfohlen, um Anwendungs-Logs zu überwachen und sensible Informationen zu identifizieren und zu schützen. **Pidcat** wird wegen seiner Benutzerfreundlichkeit und Lesbarkeit bevorzugt.

> [!WARNING]
> Beachte, dass seit **neuer als Android 4.0** **Anwendungen nur noch auf ihre eigenen Logs zugreifen können**. Anwendungen können also nicht auf die Logs anderer Apps zugreifen.\
> Trotzdem wird empfohlen, **keine sensiblen Informationen zu loggen**.

**Copy/Paste Buffer Caching**

Das **clipboard-basierte** Framework von Android ermöglicht Copy-Paste-Funktionalität in Apps, birgt jedoch ein Risiko, da **andere Anwendungen** auf die Zwischenablage **access** können und dadurch sensible Daten exponieren könnten. Es ist wichtig, Copy/Paste-Funktionen für sensible Bereiche einer Anwendung (z. B. Kreditkartendaten) zu **disable**, um Daten leaks zu verhindern.

**Crash Logs**

Wenn eine Anwendung **crasht** und **Logs speichert**, können diese Logs Angreifern helfen, insbesondere wenn die Anwendung nicht reverse-engineered werden kann. Um dieses Risiko zu minimieren, vermeide Logging bei Crashes, und falls Logs über das Netzwerk gesendet werden müssen, stelle sicher, dass sie über einen SSL-Kanal übertragen werden.

Als pentester, **versuche, dir diese Logs anzusehen**.

**Analytics Data Sent To 3rd Parties**

Anwendungen integrieren oft Dienste wie Google Adsense, die unbeabsichtigt **sensitive data leak** können, wenn Entwickler sie falsch implementieren. Um mögliche Datenleaks zu identifizieren, ist es ratsam, den Traffic der Anwendung zu intercepten und zu überprüfen, ob sensible Informationen an Drittanbieter gesendet werden.

### SQLite DBs

Die meisten Anwendungen verwenden **interne SQLite-Datenbanken**, um Informationen zu speichern. Untersuche während des pentests die **erstellten Datenbanken**, die Namen der **Tables** und **Columns** sowie alle gespeicherten **Daten**, da du dort **sensitive information** finden könntest (was eine Schwachstelle wäre).\
Datenbanken sollten sich in `/data/data/the.package.name/databases` befinden, z. B. `/data/data/com.mwr.example.sieve/databases`

Wenn die Datenbank vertrauliche Informationen speichert und **verschlüsselt** ist, du aber das **Passwort** innerhalb der Anwendung **findest**, ist das dennoch eine **Schwachstelle**.

Zähle die Tabellen mit `.tables` auf und die Spalten der Tabellen mit `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer is s useful tool to **exploit exported activities, exported services and Content Providers** as you will learn in the following sections.

### Ausnutzen exportierter Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Denke auch daran, dass der Code einer Activity in der **`onCreate`**-Methode beginnt.

**Authorisation bypass**

Wenn eine Activity exported ist, kannst du ihren Screen von einer externen App aus aufrufen. Daher, wenn eine Activity mit **sensiblen Informationen** **exported** ist, könntest du die **authentication**-Mechanismen **bypassen**, um darauf zuzugreifen.

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

Du kannst auch eine exportierte Activity von adb starten:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**HINWEIS**: MobSF wird die Verwendung von _**singleTask/singleInstance**_ als `android:launchMode` in einer Activity als bösartig erkennen, aber aufgrund von [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750) scheint dies offenbar nur auf alten Versionen (API-Versionen < 21) gefährlich zu sein.

> [!TIP]
> Beachte, dass ein authorisation bypass nicht immer eine vulnerability ist; das hängt davon ab, wie der bypass funktioniert und welche Informationen offengelegt werden.

**Offenlegung sensibler Informationen**

**Activities können auch Ergebnisse zurückgeben**. Wenn es dir gelingt, eine exportierte und ungeschützte Activity zu finden, die die Methode **`setResult`** aufruft und **sensible Informationen zurückgibt**, liegt eine Offenlegung sensibler Informationen vor.

#### Tapjacking

Wenn Tapjacking nicht verhindert wird, könntest du die exportierte Activity missbrauchen, um den Benutzer dazu zu bringen, unerwartete Aktionen auszuführen.\
[**Was Tapjacking ist, folge dem Link**](#tapjacking)

### Exploiting Content Providers - Zugriff auf und Manipulation sensibler Informationen

[**Lies dies, wenn du auffrischen möchtest, was ein Content Provider ist.**](android-applications-basics.md#content-provider)\
Content providers werden grundsätzlich verwendet, um **Daten zu teilen**. Wenn eine App verfügbare Content providers hat, könntest du möglicherweise **sensible Daten extrahieren**. Es ist auch sinnvoll, mögliche **SQL injections** und **Path Traversals** zu testen, da diese verwundbar sein könnten.

[**Lerne, wie man Content Providers mit Drozer ausnutzt.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Lies dies, wenn du auffrischen möchtest, was ein Service ist.**](android-applications-basics.md#services)\
Beachte, dass die Aktionen eines Service in der Methode `onStartCommand` beginnen.

Ein Service ist im Grunde etwas, das **Daten empfangen**, **verarbeiten** und (oder nicht) eine Antwort **zurückgeben** kann. Wenn eine Anwendung also Services exportiert, solltest du den **Code** prüfen, um zu verstehen, was er tut, und ihn **dynamisch** testen, um vertrauliche Informationen zu extrahieren und Authentifizierungsmaßnahmen zu umgehen...\
[**Lerne, wie man Services mit Drozer ausnutzt.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Lies dies, wenn du auffrischen möchtest, was ein Broadcast Receiver ist.**](android-applications-basics.md#broadcast-receivers)\
Beachte, dass die Aktionen eines Broadcast Receiver in der Methode `onReceive` beginnen.

Ein Broadcast Receiver wartet auf eine Art von Nachricht. Je nachdem, wie der Receiver die Nachricht verarbeitet, kann er verwundbar sein.\
[**Lerne, wie man Broadcast Receivers mit Drozer ausnutzt.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Du kannst Deep links manuell suchen, mit Tools wie MobSF oder Skripten wie [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Du kannst ein deklariertes **scheme** mit **adb** oder einem **Browser** öffnen:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Beachte, dass du den **Paketnamen weglassen** kannst und das Mobilgerät automatisch die App aufruft, die diesen Link öffnen sollte._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Code executed**

Um den **Code zu finden, der in der App ausgeführt wird**, gehe zur Activity, die vom deeplink aufgerufen wird, und suche die Funktion **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Sensitive info**

Jedes Mal, wenn du einen deep link findest, überprüfe, dass **er keine sensiblen Daten (wie Passwörter) über URL-Parameter empfängt**, denn jede andere Anwendung könnte **den deep link nachahmen und diese Daten stehlen!**

**Parameters in path**

Du **musst auch prüfen, ob ein deep link einen Parameter innerhalb des Pfads** der URL verwendet, z. B.: `https://api.example.com/v1/users/{username}`. In diesem Fall kannst du einen Path Traversal erzwingen, indem du so etwas aufrufst: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Beachte, dass, wenn du die korrekten Endpoints in der Anwendung findest, du möglicherweise einen **Open Redirect** auslösen kannst (wenn ein Teil des Pfads als Domainname verwendet wird), eine **account takeover** (wenn du Benutzerdaten ohne CSRF-Token ändern kannst und der verwundbare Endpoint die richtige Methode verwendet) und jede andere Vulnerability. Mehr [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

Ein [interessanter bug bounty report](https://hackerone.com/reports/855618) über Links (_/.well-known/assetlinks.json_).

### Transport Layer Inspection and Verification Failures

- **Certificates are not always inspected properly** von Android-Anwendungen. Es ist üblich, dass diese Anwendungen Warnungen übersehen und self-signed certificates akzeptieren oder in einigen Fällen auf HTTP-Verbindungen zurückfallen.
- **Negotiations during the SSL/TLS handshake are sometimes weak**, es werden unsichere Cipher Suites verwendet. Diese Schwäche macht die Verbindung anfällig für man-in-the-middle (MITM) Angriffe, wodurch Angreifer die Daten entschlüsseln können.
- Leakage of private information ist ein Risiko, wenn Anwendungen sich über sichere Kanäle authentifizieren, dann aber für andere Transaktionen über nicht-sichere Kanäle kommunizieren. Dieser Ansatz schützt sensitive Daten wie Session-Cookies oder Nutzerdaten nicht vor Abfangen durch böswillige Akteure.

#### Certificate Verification

Wir konzentrieren uns auf die **Certificate Verification**. Die Integrität des Server-Zertifikats muss überprüft werden, um die Sicherheit zu erhöhen. Das ist entscheidend, denn unsichere TLS-Konfigurationen und die Übertragung sensibler Daten über unverschlüsselte Kanäle können erhebliche Risiken darstellen. Für detaillierte Schritte zur Überprüfung von Server-Zertifikaten und zur Behebung von Schwachstellen bietet [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) umfassende Anleitung.

#### SSL Pinning

SSL Pinning ist eine Sicherheitsmaßnahme, bei der die Anwendung das Server-Zertifikat gegen eine bekannte Kopie prüft, die innerhalb der Anwendung gespeichert ist. Diese Methode ist essentiell, um MITM-Angriffe zu verhindern. Die Implementierung von SSL Pinning wird dringend empfohlen für Anwendungen, die mit sensiblen Informationen arbeiten.

#### Traffic Inspection

Um HTTP-Traffic zu inspizieren, ist es notwendig, **das Zertifikat des Proxy-Tools** (z. B. Burp) zu installieren. Ohne die Installation dieses Zertifikats ist verschlüsselter Traffic möglicherweise nicht über den Proxy sichtbar. Für eine Anleitung zur Installation eines benutzerdefinierten CA-Zertifikats, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Anwendungen, die auf **API Level 24 und höher** abzielen, erfordern Änderungen an der Network Security Config, um das CA-Zertifikat des Proxys zu akzeptieren. Dieser Schritt ist entscheidend, um verschlüsselten Traffic zu inspizieren. Anweisungen zur Änderung der Network Security Config findest du in diesem Tutorial: [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

Wenn **Flutter** verwendet wird, musst du den Anweisungen auf [**this page**](flutter.md) folgen. Das liegt daran, dass das bloße Hinzufügen des Zertifikats zum Store nicht ausreicht, da Flutter seine eigene Liste gültiger CAs hat.

#### Static detection of SSL/TLS pinning

Bevor du Runtime-Bypässe versuchst, mappe schnell, wo Pinning im APK erzwungen wird. Statische Erkennung hilft dir, Hooks/Patches zu planen und dich auf die richtigen Codepfade zu konzentrieren.

Tool: SSLPinDetect
- Open-source static-analysis utility, die das APK nach Smali dekompiliert (via apktool) und nach kuratierten Regex-Patterns für SSL/TLS pinning Implementierungen scannt.
- Meldet exakten Dateipfad, Zeilennummer und einen Codeausschnitt für jeden Treffer.
- Deckt gängige Frameworks und Custom-Code-Pfade ab: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init mit custom TrustManagers/KeyManagers und Network Security Config XML pins.

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Verwendung
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Beispiel-Pattern-Regeln (JSON)
Verwende oder erweitere signatures, um proprietäre/custom pinning styles zu erkennen. Du kannst dein eigenes JSON laden und in großem Umfang scannen.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes and tips
- Schnelles Scannen großer Apps mittels multi-threading und memory-mapped I/O; vor-kompilierte regex reduziert Overhead/False Positives.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Typische Erkennungsziele für die weitere Triagierung:
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Declarative pins in res/xml network security config and manifest references
- Verwende die gefundenen Stellen, um Frida hooks, statische Patches oder Config-Reviews vor dem dynamischen Testing zu planen.



#### SSL Pinning umgehen

Wenn SSL Pinning implementiert ist, wird das Umgehen erforderlich, um HTTPS-Traffic zu untersuchen. Für diesen Zweck stehen verschiedene Methoden zur Verfügung:

- Automatisch die **apk** **modifizieren**, um SSLPinning mit [**apk-mitm**](https://github.com/shroudedcode/apk-mitm) zu **umgehen**. Der größte Vorteil dieser Option ist, dass du kein root brauchst, um SSL Pinning zu umgehen, aber du musst die Anwendung löschen und die neue installieren, und das funktioniert nicht immer.
- Du könntest **Frida** (weiter unten besprochen) verwenden, um diesen Schutz zu umgehen. Hier ist eine Anleitung für Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Du kannst auch versuchen, **SSL Pinning automatisch zu umgehen** mit [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Du kannst auch versuchen, **SSL Pinning automatisch zu umgehen** mit **MobSF dynamic analysis** (weiter unten erklärt)
- Falls du glaubst, dass es noch Traffic gibt, den du nicht erfasst, kannst du versuchen, den Traffic mittels iptables an burp weiterzuleiten. Lies diesen Blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Suche nach häufigen Web-Schwachstellen

Es ist wichtig, auch innerhalb der Anwendung nach häufigen Web-Schwachstellen zu suchen. Detaillierte Informationen zum Identifizieren und Beheben dieser Schwachstellen gehen über den Rahmen dieser Zusammenfassung hinaus, werden aber an anderer Stelle ausführlich behandelt.

### Frida

[Frida](https://www.frida.re) ist ein dynamic instrumentation toolkit für Entwickler, Reverse-Engineers und Security-Researcher.\
**Du kannst auf laufende Anwendungen zugreifen und Methoden zur Laufzeit hooken, um Verhalten zu ändern, Werte zu ändern, Werte zu extrahieren, anderen Code auszuführen...**\
Wenn du Android-Anwendungen pentest willst, musst du wissen, wie man Frida benutzt.

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Some "GUI" for actions with Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- You can find some Awesome Frida scripts here: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Versuche Anti-Debugging / Anti-Frida-Mechanismen zu umgehen, indem du Frida wie hier beschrieben lädst: [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (Tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL Pinning Umgehungs-Workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Speicher auslesen - Fridump**

Prüfe, ob die Anwendung sensible Informationen im Speicher ablegt, die dort nicht sein sollten, z. B. Passwörter oder mnemonics.

Using [**Fridump3**](https://github.com/rootbsd/fridump3) you can dump the memory of the app with:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Das wird den Speicher im Ordner ./dump ablegen, und dort könntest du mit etwas wie grep suchen:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Sensible Daten in Keystore**

In Android ist der Keystore der beste Ort, um sensible Daten zu speichern; mit ausreichenden Privilegien ist es jedoch immer noch **möglich, darauf zuzugreifen**. Da Anwendungen hier dazu neigen, **sensible Daten in clear text** zu speichern, sollten pentests dies überprüfen, da ein Root-User oder jemand mit physischem Zugriff auf das Gerät diese Daten stehlen könnte.

Selbst wenn eine App Daten im keystore speichert, sollten diese Daten verschlüsselt sein.

Um auf die Daten im keystore zuzugreifen, kann man dieses Frida-Skript verwenden: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Mit dem folgenden Frida-Skript kann möglicherweise die **bypass fingerprint authentication** durchgeführt werden, die Android-Anwendungen implementieren, um **bestimmte sensible Bereiche zu schützen:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Hintergrundbilder**

Wenn du eine Anwendung in den Hintergrund legst, speichert Android einen **Snapshot der Anwendung**, sodass beim Wiederherstellen in den Vordergrund zuerst das Bild geladen wird, bevor die App startet, wodurch es so aussieht, als wäre die App schneller geladen.

Wenn dieser Snapshot jedoch **sensible Informationen** enthält, könnte jemand mit Zugriff auf den Snapshot diese **Infos stehlen** (beachte, dass man dafür root benötigt).

Die Snapshots werden üblicherweise hier gespeichert: **`/data/system_ce/0/snapshots`**

Android bietet eine Möglichkeit, die **Erfassung von Screenshots durch Setzen des FLAG_SECURE** Layout-Parameters zu verhindern. Wenn dieses Flag verwendet wird, werden die Fensterinhalte als sicher behandelt, sodass sie nicht in Screenshots erscheinen oder auf nicht-sicheren Displays angezeigt werden können.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Dieses Tool kann dir helfen, verschiedene Tools während der dynamischen Analyse zu verwalten: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Entwickler erstellen häufig Proxy-Komponenten wie activities, services und broadcast receivers, die diese Intents verarbeiten und an Methoden wie `startActivity(...)` oder `sendBroadcast(...)` weiterreichen, was riskant sein kann.

Die Gefahr besteht darin, Angreifern zu erlauben, non-exported App-Komponenten zu triggern oder auf sensible content providers zuzugreifen, indem diese Intents fehlgeleitet werden. Ein bemerkenswertes Beispiel ist die `WebView`-Komponente, die URLs mittels `Intent.parseUri(...)` in `Intent`-Objekte konvertiert und diese dann ausführt, was zu bösartigen Intent-Injections führen kann.

### Essential Takeaways

- **Intent Injection** ist ähnlich dem Open Redirect-Problem im Web.
- Exploits beinhalten das Weiterreichen von `Intent`-Objekten als extras, die umgeleitet werden können, um unsichere Operationen auszuführen.
- Dadurch können non-exported Komponenten und content providers für Angreifer exponiert werden.
- Die URL-zu-`Intent`-Konvertierung von `WebView` kann unbeabsichtigte Aktionen ermöglichen.

### Android Client-seitige Injections und andere

Wahrscheinlich kennst du diese Art von Vulnerabilities bereits aus dem Web. Bei Android-Anwendungen musst du besonders vorsichtig mit folgenden Schwachstellen sein:

- **SQL Injection:** Beim Umgang mit dynamischen Queries oder Content-Providers stelle sicher, dass du parameterisierte Abfragen verwendest.
- **JavaScript Injection (XSS):** Stelle sicher, dass JavaScript- und Plugin-Unterstützung für alle WebViews deaktiviert ist (standardmäßig deaktiviert). [Mehr Infos hier](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews sollten keinen Zugriff auf das Dateisystem haben (standardmäßig erlaubt) - `(webview.getSettings().setAllowFileAccess(false);)`. [Mehr Infos hier](webview-attacks.md#javascript-enabled).
- **Eternal cookies:** In mehreren Fällen, wenn die Android-Anwendung die Session beendet, wird das Cookie nicht widerrufen oder es kann sogar auf die Festplatte gespeichert werden.
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatische Analyse

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Statische Analyse**

![](<../../images/image (866).png>)

**Vulnerability assessment of the application** unter Verwendung eines ansprechenden web-basierten Frontends. Du kannst auch dynamische Analyse durchführen (du musst jedoch die Umgebung vorbereiten).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **Hash** will be **hochgeladen** instead of the file.

### Assisted Dynamic analysis with MobSF

**MobSF** can also be very helpful for **dynamic analysis** in **Android**, but in that case you will need to install MobSF and **genymotion** in your host (a VM or Docker won't work). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
The **MobSF dynamic analyser** can:

- **Dump application data** (URLs, logs, Zwischenablage, Screenshots, die du machst, Screenshots, die vom "**Exported Activity Tester**" erstellt werden, E-Mails, SQLite-Datenbanken, XML-Dateien und andere erstellte Dateien). All of this is done automatically except for the screenshots, you need to press when you want a screenshot or you need to press "**Exported Activity Tester**" to obtain screenshots of all the exported activities.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: Gibt alle geladenen Klassen aus
- **Capture Strings**: Es wird während der Nutzung der Anwendung alle erfassten Strings ausgeben (sehr viel Output)
- **Capture String Comparisons**: Kann sehr nützlich sein. Es wird **die 2 Strings, die verglichen werden, anzeigen** und ob das Ergebnis True oder False war.
- **Enumerate Class Methods**: Gib den Klassennamen ein (z.B. "java.io.File") und es werden alle Methoden der Klasse ausgegeben.
- **Search Class Pattern**: Suche Klassen nach Pattern
- **Trace Class Methods**: **Trace** eine **gesamte Klasse** (siehe Eingaben und Ausgaben aller Methoden der Klasse). Denk daran, dass MobSF standardmäßig mehrere interessante Android API-Methoden trace't.

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf also brings you a shell with some **adb** commands, **MobSF commands**, and common **shell** **commands** at the bottom of the dynamic analysis page. Some interesting commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP-Tools**

Wenn HTTP traffic aufgezeichnet wird, siehst du eine rohe Ansicht des aufgezeichneten Verkehrs über den Button "**HTTP(S) Traffic**" unten oder eine schönere Ansicht über den grünen Button "**Start HTTPTools**". Über die zweite Option kannst du die **captured requests** an **proxies** wie Burp oder Owasp ZAP senden.  
Um das zu tun: _Burp einschalten -->_ _Intercept ausschalten --> in MobSB HTTPTools die Anfrage auswählen_ --> auf "**Send to Fuzzer**" klicken --> _die proxy address auswählen_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Sobald du die dynamic analysis mit MobSF beendet hast, kannst du auf "**Start Web API Fuzzer**" klicken, um **fuzz http requests** auszuführen und nach Schwachstellen zu suchen.

> [!TIP]
> Nach einer dynamic analysis mit MobSF können die proxy settings möglicherweise falsch konfiguriert sein und du kannst sie nicht über die GUI beheben. Du kannst die proxy settings folgendermaßen zurücksetzen:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Unterstützte dynamic analysis mit Inspeckage

Du kannst das Tool von [**Inspeckage**](https://github.com/ac-pm/Inspeckage) beziehen.  
Dieses Tool verwendet einige **Hooks**, um dir zu zeigen, **was in der Anwendung passiert**, während du eine **dynamic analysis** durchführst.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Dies ist ein **großartiges Tool, um static analysis mit einer GUI durchzuführen**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Dieses Tool ist darauf ausgelegt, mehrere **security related Android application vulnerabilities** zu finden, entweder im **source code** oder in **packaged APKs**. Das Tool kann außerdem ein **Proof-of-Concept deployable APK** und **ADB commands** erstellen, um einige der gefundenen Schwachstellen (Exposed activities, intents, tapjacking...) auszunutzen. Wie bei Drozer ist es nicht nötig, das Testgerät zu rooten.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Zeigt alle extrahierten Dateien zur einfachen Referenz an
- Decompiliert APK-Dateien automatisch in Java- und Smali-Format
- Analysiert AndroidManifest.xml auf häufige Schwachstellen und Verhaltensweisen
- Statische Quellcode-Analyse auf häufige Schwachstellen und Verhaltensweisen
- Geräteinformationen
- und mehr
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER ist eine Kommandozeilenanwendung, die unter Windows, MacOS X und Linux verwendet werden kann und _.apk_ Dateien auf der Suche nach Schwachstellen analysiert. Dazu dekomprimiert es APKs und wendet eine Reihe von Regeln an, um diese Schwachstellen zu erkennen.

Alle Regeln sind in einer `rules.json`-Datei zusammengefasst, und jedes Unternehmen oder jeder Tester kann eigene Regeln erstellen, um seine Anforderungen zu analysieren.

Lade die neuesten Binaries von der [download page](https://superanalyzer.rocks/download.html) herunter
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn ist ein **crossplatform** Tool, das Entwickler, bugbounty hunters und ethical hackers bei der Durchführung von [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) an mobilen Anwendungen unterstützt.

Das Konzept besteht darin, dass Sie Ihre mobile Anwendungsdatei (eine .apk- oder .ipa-Datei) per Drag & Drop auf die StaCoAn-Anwendung ziehen und es einen visuellen, portablen Bericht für Sie erstellt. Sie können die Einstellungen und wordlists anpassen, um ein individuelles Erlebnis zu erhalten.

Herunterladen[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework ist ein System zur Analyse von Android-Schwachstellen, das Entwicklern oder hackers hilft, potenzielle Sicherheitslücken in Android-Anwendungen zu finden.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** ist ein Tool, dessen Hauptzweck darin besteht, potenziell bösartiges Verhalten einer Android-Anwendung zu erkennen und den Benutzer davor zu warnen.

Die Erkennung erfolgt mittels **static analysis** des Dalvik-Bytecodes der Anwendung, dargestellt als **Smali**, mit der Bibliothek [`androguard`](https://github.com/androguard/androguard).

Dieses Tool sucht nach **häufigem Verhalten von "bösen" Anwendungen** wie: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. It is a tool that puts together commonly used mobile application reverse engineering and analysis tools, to assist in testing mobile applications against the OWASP mobile security threats. Its objective is to make this task easier and friendlier to mobile application developers and security professionals.

It is able to:

- Extract Java and Smali code using different tools
- Analyze APKs using: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Extract private information from the APK using regexps.
- Analyze the Manifest.
- Analyze found domains using: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Nützlich zur Erkennung von malware: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Beachte, dass abhängig vom Service und der Konfiguration, die du zum obfuscate des Codes verwendest, secrets möglicherweise obfuscated bleiben oder nicht.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. It is able to optimize bytecode as well as detect and remove unused instructions. ProGuard is free software and is distributed under the GNU General Public License, version 2.

ProGuard is distributed as part of the Android SDK and runs when building the application in release mode.

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Last time we checked, the Dexguard mode of operation was:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

You can upload an obfuscated APK to their platform.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

It is a **generic android deobfuscator.** Simplify **virtually executes an app** to understand its behavior and then **tries to optimize the code** so it behaves identically but is easier for a human to understand. Each optimization type is simple and generic, so it doesn't matter what the specific type of obfuscation is used.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD gives you information about **how an APK was made**. It identifies many **compilers**, **packers**, **obfuscators**, and other weird stuff. It's [_PEiD_](https://www.aldeid.com/wiki/PEiD) for Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b is an Android security virtual machine based on ubuntu-mate includes the collection of latest framework, tutorials and labs from different security geeks and researchers for reverse engineering and malware analysis.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) It is a great list of resources
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)

## Yet to try

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
