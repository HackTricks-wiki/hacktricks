# Android アプリケーション Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android Applications Basics

このページを最初に読むことを強く推奨します。**Android セキュリティに関連する最も重要な部分と、Android アプリケーションで最も危険なコンポーネント**について理解するためです:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

これは、エミュレータでも実機でも Android デバイスに接続するために必要な主要なツールです。\
**ADB** はコンピュータから **USB** または **Network** 経由でデバイスを制御できます。このユーティリティはファイルの双方向の **コピー**、アプリの **インストール** と **アンインストール**、シェルコマンドの **実行**、データの **バックアップ**、ログの **読み取り** などの機能を提供します。

adbの使用方法を学ぶには、次の[**ADB Commands**](adb-commands.md)のリストを参照してください。

## Smali

時には、**modify the application code** によって **hidden information**（難読化されたパスワードやフラグなど）にアクセスすることが有用です。その場合、APKを逆コンパイルしてコードを修正し、再コンパイルすることが役立つことがあります。\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). これは、これから紹介する動的解析中のいくつかのテストに対する**代替手段**として非常に有用です。したがって、この可能性を**常に念頭に置いて**ください。

## Other interesting tricks

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- デバイスからAPKを抽出:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- すべての splits と base apks を [APKEditor](https://github.com/REAndroid/APKEditor) でマージする:
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## ケーススタディと脆弱性


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## 静的解析

まず第一に、APK を解析するにはデコンパイラを使って **Java コードを確認する** 必要があります。\
[**ここを読んで利用可能な各種 decompiler に関する情報を見つけてください**](apk-decompilers.md)。

### 興味深い情報の探索

APK の **strings** を見るだけでも、**passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** などの興味深い情報を検索できます… コード実行の **backdoors** や認証 backdoors（アプリにハードコードされた管理者資格情報）も探してください。

Firebase

**firebase URLs** に特に注意を払い、設定が不適切でないか確認してください。 [More information about whats is FIrebase and how to exploit it here.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### アプリケーションの基本理解 - Manifest.xml, strings.xml

アプリケーションの _Manifest.xml_ と **_strings.xml_** ファイルを調査することで、潜在的なセキュリティ脆弱性が明らかになることがあります。これらのファイルはデコンパイラを使うか、APK の拡張子を .zip に変更して展開することでアクセスできます。

**Manifest.xml** から特定される脆弱性には次のものが含まれます:

- **Debuggable Applications**: _Manifest.xml_ 内で `debuggable="true"` に設定されたアプリは危険です。デバッグ接続が許可され、これにより悪用される可能性があります。デバッグ可能なアプリの発見と悪用方法については、デバイス上の debuggable アプリを見つけて悪用するチュートリアルを参照してください。
- **Backup Settings**: 機密情報を扱うアプリでは、`android:allowBackup="false"` を明示的に設定しておくべきです。特に usb debugging が有効な場合、adb 経由での無許可なデータバックアップを防ぐためです。
- **Network Security**: カスタムなネットワークセキュリティ設定（`android:networkSecurityConfig="@xml/network_security_config"`）は、res/xml/ にあり、証明書ピンや HTTP トラフィックの設定などのセキュリティ詳細を指定できます。例として、特定ドメインに対して HTTP トラフィックを許可する設定があります。
- **Exported Activities and Services**: マニフェスト内でエクスポートされた activities や services を特定すると、悪用される可能性のあるコンポーネントが明らかになります。ダイナミックテスト中にこれらのコンポーネントをどのように悪用できるかを詳しく分析してください。
- **Content Providers and FileProviders**: 公開された content providers はデータの無許可アクセスや改ざんを許す可能性があります。FileProviders の設定も精査すべきです。
- **Broadcast Receivers and URL Schemes**: これらのコンポーネントは悪用される可能性があり、特に URL スキームが入力に対してどのように扱われているかに注意してください。
- **SDK Versions**: `minSdkVersion`, `targetSDKVersion`, `maxSdkVersion` の属性はサポートされる Android バージョンを示します。古く脆弱な Android バージョンをサポートしないことがセキュリティ上重要です。

**strings.xml** ファイルからは、API キー、カスタムスキーマ、その他開発者メモなどの機密情報が見つかることがあり、これらのリソースを注意深く確認する必要があります。

### Tapjacking

Tapjacking は、悪意のあるアプリケーションが被害者アプリの上に位置して起動する攻撃です。被害者アプリを視覚的に覆った状態で、悪意のある UI がユーザを騙して操作させ、その操作を被害者アプリに透過的に渡すよう設計されています。\
結果的に、ユーザは実際には被害者アプリ上で操作を行っていることに気づかされないまま操作してしまいます。

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

`launchMode` が **singleTask** に設定され、かつ `taskAffinity` が定義されていない **activity** は Task Hijacking に対して脆弱です。これは、悪意のあるアプリをインストールして本物のアプリより先に起動すると、**本物のアプリのタスクを乗っ取る** 可能性があることを意味します（そのためユーザは本物のアプリを使っていると思い込み、実際には悪意のあるアプリとやり取りしていることになります）。

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### 安全でないデータ保存

Internal Storage

Android では、内部ストレージに格納されたファイルはそれを作成したアプリのみがアクセスできるように設計されています。このセキュリティ対策は OS により強制され、多くのアプリのセキュリティ要件には概ね十分です。しかし、開発者が `MODE_WORLD_READABLE` や `MODE_WORLD_WRITABLE` といったモードを利用してファイルを他のアプリ間で共有することがあります。これらのモードは、潜在的に悪意のあるアプリを含む他のアプリからのアクセスを制限しません。

1. **Static Analysis:**
- `MODE_WORLD_READABLE` と `MODE_WORLD_WRITABLE` の使用は注意深く精査してください。これらのモードはファイルを意図しない、または無許可のアクセスにさらす可能性があります。
2. **Dynamic Analysis:**
- アプリが作成するファイルに設定された権限を確認してください。特に、ファイルが世界中で読み取り可能または書き込み可能に設定されていないかをチェックします。これがあると、デバイスにインストールされた任意のアプリが、その出所や意図に関係なくこれらのファイルを読み取り・変更できる重大なリスクになります。

External Storage

SD カードなどの **external storage** 上のファイルを扱う際には、次の点に注意してください:

1. **Accessibility**:
- external storage 上のファイルはグローバルに読み書き可能です。つまり、任意のアプリやユーザがこれらのファイルにアクセスできます。
2. **Security Concerns**:
- アクセスが容易なため、機密情報を external storage に保存しないことが推奨されます。
- external storage は取り外されたり、任意のアプリによってアクセスされる可能性があり、より安全性が低くなります。
3. **Handling Data from External Storage**:
- external storage から取得したデータには常に入力検証を行ってください。これは、データが信頼できないソースから来るため重要です。
- external storage に実行ファイルや class ファイルを置き、動的にロードすることは強く非推奨です。
- アプリが external storage から実行可能ファイルを取得する必要がある場合、それらのファイルが動的にロードされる前に署名され暗号的に検証されていることを確認してください。これはアプリのセキュリティ整合性を維持するために重要です。

External storage は `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard` でアクセスできます

> [!TIP]
> Android 4.4（**API 17**）以降、SD カードにはアプリごとに専用のディレクトリ構造があり、アプリがアクセスできるのはそのアプリ専用のディレクトリに限定されます。これにより、悪意のあるアプリが別のアプリのファイルへ読み書きアクセスすることを防ぎます。

**平文で保存された機密データ**

- **Shared preferences**: Android は各アプリが簡単に xml ファイルを `/data/data/<packagename>/shared_prefs/` に保存できるようにしており、そのフォルダ内に平文で機密情報が保存されていることが時々あります。
- **Databases**: Android は各アプリが簡単に sqlite データベースを `/data/data/<packagename>/databases/` に保存できるようにしており、そのフォルダ内に平文で機密情報が保存されていることもあります。

### Broken TLS

Accept All Certificates

なぜか開発者がすべての証明書を受け入れてしまうことがあります。例えばホスト名が一致しなくても以下のようなコード行で受け入れてしまうことがあります：
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Broken Cryptography

**Poor Key Management Processes**

一部の開発者は機密データをローカルストレージに保存し、コード内にハードコード／予測可能なキーで暗号化します。これは推奨されません。リバースエンジニアリングによって攻撃者が機密情報を抽出できる可能性があるためです。

**Use of Insecure and/or Deprecated Algorithms**

開発者は認可の**checks**、データの**store**や**send**に**deprecated algorithms**を使用してはいけません。これらのアルゴリズムの例には RC4、MD4、MD5、SHA1 などがあります。例えばパスワードの保存に**hashes**を用いる場合、ソルト付きで総当たり攻撃に**resistant**なハッシュを使用するべきです。

### Other checks

- APKを**obfuscate**して、攻撃者によるリバースエンジニアリングの労力を増やすことを推奨します。
- アプリが機密性の高いものである場合（銀行アプリ等）、**own checks to see if the mobile is rooted** を実行し、それに応じて処理するべきです。
- アプリが機密性の高いものである場合（銀行アプリ等）、**emulator** が使用されているかどうかをチェックするべきです。
- アプリが機密性の高いものである場合（銀行アプリ等）、実行前に**check it's own integrity before executing**して改変されていないか確認するべきです。
- APKのビルドにどの compiler/packer/obfuscator が使われたかを確認するには [**APKiD**](https://github.com/rednaga/APKiD) を使用してください

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

ツール [**mariana-trench**](https://github.com/facebook/mariana-trench) はアプリケーションの**code**を**scanning**して**vulnerabilities**を発見することができます。このツールは一連の**known sources**（ツールに対して**places**を示し、そこでの**input**が**controlled by the user**である場所）、**sinks**（悪意あるユーザ入力が被害を引き起こす可能性のある**dangerous**な**places**）および**rules**を含みます。これらの**rules**は、脆弱性を示す**sources-sinks**の**combination**を指します。

この知識を基に、**mariana-trench will review the code and find possible vulnerabilities on it**。

### Secrets leaked

An application may contain secrets (API keys, passwords, hidden urls, subdomains...) inside of it that you might be able to discover. You could us a tool such as [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)
- In-memory native code execution via JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> First of all, you need an environment where you can install the application and all the environment (Burp CA cert, Drozer and Frida mainly). Therefore, a rooted device (emulated or not) is extremely recommended.

### Online Dynamic analysis

次のサイトで**free account**を作成できます: [https://appetize.io/](https://appetize.io). このプラットフォームでは APK を**upload**して**execute**できるため、APK の挙動を確認するのに便利です。

ウェブ上で**see the logs of your application**したり、**adb**を通じて接続することもできます。

![](<../../images/image (831).png>)

ADB 接続のおかげで、エミュレータ内で **Drozer** や **Frida** を使用できます。

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio)（**x86** と **arm** デバイスを作成できます。また、[**this**](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html) によれば**最新の x86** バージョンは遅い arm エミュレータを使わずとも **ARM libraries** をサポートします）。
- セットアップ方法は次のページを参照してください:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition、アカウント作成が必要です。_潜在的なエラーを避けるために_ _**VirtualBox**_ _付きのバージョンを**download**することを推奨します。_)_
- [**Nox**](https://es.bignox.com)（無料ですが、Frida や Drozer をサポートしていません）。

> [!TIP]
> どのプラットフォームで新しいエミュレータを作成する際も、画面が大きいほどエミュレータは遅くなります。可能であれば小さい画面を選んでください。

Genymotion に Google サービス（Play Store など）をインストールするには、以下画像の赤で示されたボタンをクリックしてください:

![](<../../images/image (277).png>)

また、**Genymotion の Android VM の configuration** では **Bridge Network mode** を選択できます（ツールを実行している別の VM から Android VM に接続する場合に有用です）。

#### Use a physical device

デバッグオプションを有効にし、可能であれば root を取得しておくと便利です:

1. 設定（Settings）。
2. （Android 8.0 以降）**System** を選択。
3. **About phone** を選択。
4. **Build number** を7回押す。
5. 戻ると **Developer options** が表示されます。

> 一度アプリをインストールしたら、まずはそのアプリを実行して何をするのか、どのように動作するのかを調査して慣れてください。\
> 初期の動的解析は MobSF dynamic analysis + pidcat を用いて行うことを推奨します。これにより、MobSF が多くの興味深いデータをキャプチャする一方で、アプリの動作を学ぶことができます。

Magisk/Zygisk quick notes (recommended on Pixel devices)
- Magisk アプリで boot.img をパッチし、fastboot 経由でフラッシュして systemless root を取得
- Zygisk を有効にし、DenyList を使って root を隠す；より強力な隠蔽が必要な場合は LSPosed/Shamiko の使用を検討
- OTA アップデートから回復するために元の boot.img を保管し、OTA 後に再パッチを行う
- 画面ミラーリングにはホストで scrcpy を使用

### Unintended Data Leakage

**Logging**

開発者は**debugging information**を公開しないよう注意するべきです。公開されると機密データの leaks に繋がる可能性があります。アプリケーションログを監視して機密情報を特定・保護するために、[**pidcat**](https://github.com/JakeWharton/pidcat) と `adb logcat` の使用を推奨します。**Pidcat** は使いやすさと可読性のために好まれます。

> [!WARNING]
> Note that from **later newer than Android 4.0**, **applications are only able to access their own logs**. So applications cannot access other apps logs.\
> Anyway, it's still recommended to **not log sensitive information**.

**Copy/Paste Buffer Caching**

Android の **clipboard-based** フレームワークはアプリ間のコピー＆ペーストを可能にしますが、他のアプリがクリップボードにアクセスできるため機密データが露出するリスクがあります。クレジットカード情報など機密性の高い部分についてはコピー/ペースト機能を無効にすることが重要です。

**Crash Logs**

アプリがクラッシュしてログを保存する場合、これらのログはリバースエンジニアリングが難しい場合でも攻撃者に有用な情報を与える可能性があります。このリスクを軽減するため、クラッシュ時にログを出力しないか、ネットワーク経由で送信する場合は SSL チャネルを使用するなどの対策を講じてください。

As pentester, **try to take a look to these logs**.

**Analytics Data Sent To 3rd Parties**

多くのアプリは Google Adsense のようなサービスを統合しており、開発者の不適切な実装により機密データを leak してしまう可能性があります。サードパーティに送信されるデータに機密情報が含まれていないかを確認するため、アプリのトラフィックをインターセプトしてチェックすることを推奨します。

### SQLite DBs

ほとんどのアプリは情報を保存するために内部の SQLite データベースを使用します。ペンテスト中は作成された**databases**、**tables**や**columns**の名前、保存されているすべての**data**を確認してください。そこに機密情報が見つかる可能性があり、それは脆弱性になり得ます。\
データベースは通常 `/data/data/the.package.name/databases` にあり、例: `/data/data/com.mwr.example.sieve/databases`

もしデータベースが機密情報を保存し**encrypted b**ut you can **find** the **password** inside the application it's still a **vulnerability**.

`.tables` を使ってテーブルを列挙し、`.schema <table_name>` を使ってテーブルのカラムを列挙します。

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer はエクスポートされた Activities、exported services、Content Providers を**exploit**するのに有用なツールです。以下のセクションで学びます。

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
また、アクティビティのコードは **`onCreate`** メソッドから始まることを忘れないでください。

**Authorisation bypass**

Activity が exported されている場合、外部アプリからその画面を呼び出すことができます。したがって、**sensitive information** を扱う Activity が **exported** されている場合、**authentication** メカニズムを **bypass** してアクセスできてしまう可能性があります。

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

ADB からも exported activity を起動できます:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF は activity の `android:launchMode` に _**singleTask/singleInstance**_ を使用していることを悪意のあるものとして検出しますが、[this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750) によれば、どうやらこれは古いバージョン（API versions < 21）でのみ危険なようです。

> [!TIP]
> authorisation bypass が常に脆弱性であるとは限らないことに注意してください。bypass の動作方法やどの情報が露出するかによって異なります。

**機密情報の漏洩**

**Activities can also return results**. エクスポートされ保護されていない activity が **`setResult`** メソッドを呼び出して**機密情報を返す**場合、機密情報の漏洩が発生します。

#### Tapjacking

Tapjacking が防止されていない場合、exported activity を悪用して**ユーザに予期しない操作をさせる**ことができます。詳細は [**Tapjacking とは（詳細）**](#tapjacking) を参照してください。

### Exploiting Content Providers - 機密情報へのアクセスと操作

[**Content Provider の復習をしたい場合はこちらを読む。**](android-applications-basics.md#content-provider)\
Content providers は基本的に**データを共有する**ために使用されます。アプリが利用可能な content providers を持っている場合、そこから**機密データを抽出**できる可能性があります。脆弱である可能性があるため、**SQL injections** や **Path Traversals** のテストを行うことも重要です。

[**Drozer を使って Content Providers を exploit する方法を学ぶ。**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Service の復習をしたい場合はこちらを読む。**](android-applications-basics.md#services)\
Service の処理は `onStartCommand` メソッドで開始されることを覚えておいてください。

Service は基本的にデータを受け取り、処理し、（場合によっては）応答を返すものです。したがってアプリがいくつかの services を export している場合は、何をしているかを理解するためにコードを確認し、機密情報の抽出や認証対策の bypass などを目的に動的にテストするべきです。\
[**Drozer で Services を exploit する方法を学ぶ。**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Broadcast Receiver の復習をしたい場合はこちらを読む。**](android-applications-basics.md#broadcast-receivers)\
Broadcast Receiver の処理は `onReceive` メソッドで開始されることを覚えておいてください。

Broadcast receiver は特定の種類のメッセージを待ち受けます。受信側がメッセージをどのように処理するかによって脆弱になる可能性があります。\
[**Drozer で Broadcast Receivers を exploit する方法を学ぶ。**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

手作業で deep links を探すこともできます。MobSF のようなツールや、[this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py) のようなスクリプトを使って探すことができます。\
宣言された **scheme** は **adb** や **browser** を使って開くことができます：
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_モバイルでは**パッケージ名を省略**すると、そのリンクを開くアプリが自動的に呼び出されます。_
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**実行されるコード**

アプリで実行される**コードを見つけるには**、deeplink によって呼び出される activity に移動し、関数 **`onNewIntent`** を探してください。

![](<../../images/image (436) (1) (1) (1).png>)

**Sensitive info**

deep link を見つけたら毎回、**URL パラメータ経由で機密データ（パスワードなど）を受け取っていないか**を確認してください。そうでないと、他のアプリが**deep link をなりすましてそのデータを盗む**可能性があります。

**Parameters in path**

URL のパス内にパラメータを使っている deep link がないかも**必ず確認してください**。例えば `https://api.example.com/v1/users/{username}` のような場合、`example://app/users?username=../../unwanted-endpoint%3fparam=value` のようにパストラバーサルを強制できることがあります。\
アプリ内部で正しいエンドポイントを発見できれば、パスの一部がドメイン名として使われている場合の **Open Redirect**、CSRF トークンなしでユーザ詳細を変更できる場合の **account takeover**（脆弱なエンドポイントが正しいメソッドを使っている場合）など、他の様々な脆弱性を誘発できる可能性があります。詳細は [http://dphoeniixx.com/2020/12/13-2/](http://dphoeniixx.com/2020/12/13-2/) を参照してください。

**More examples**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Transport Layer Inspection and Verification Failures

- **Certificates are not always inspected properly** by Android applications. 多くの場合、アプリは警告を無視して自己署名証明書を受け入れたり、場合によっては HTTP 接続にフォールバックしたりします。
- **Negotiations during the SSL/TLS handshake are sometimes weak**, insecure な cipher suite を使用していることがあります。この脆弱性により接続が man-in-the-middle (MITM) 攻撃に対して脆弱になり、攻撃者がデータを復号できる可能性があります。
- **Leakage of private information** は、アプリが認証に安全なチャネルを使っている一方で、他のやり取りで非暗号化チャネルを使う場合に発生するリスクです。この設計は、セッション Cookie やユーザ情報などの機密データを悪意ある者による傍受から守れません。

#### Certificate Verification

ここでは **certificate verification** に焦点を当てます。サーバの証明書の整合性を検証することはセキュリティ強化のために必須です。TLS の不適切な設定や機密データを暗号化されていないチャネルで送信することは重大なリスクを招きます。サーバ証明書の検証方法や脆弱性対応の詳細手順については、[**this resource**](https://manifestsecurity.com/android-application-security-part-10/) を参照してください。

#### SSL Pinning

SSL Pinning は、アプリがサーバ証明書をアプリ内に保存された既知のコピーと照合するセキュリティ手法です。この方法は MITM 攻撃を防ぐうえで重要です。機密情報を扱うアプリでは SSL Pinning の実装を強く推奨します。

#### Traffic Inspection

HTTP トラフィックを検査するには、プロキシツール（例: Burp）の証明書を**インストールする必要があります**。この証明書をインストールしないと、暗号化されたトラフィックはプロキシ上で見えない場合があります。カスタム CA 証明書のインストールガイドは [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine) を参照してください。

**API Level 24 and above** をターゲットにしたアプリケーションは、プロキシの CA 証明書を受け入れるよう Network Security Config の変更が必要です。暗号化トラフィックを検査するにはこの手順が重要です。Network Security Config の変更方法は [**refer to this tutorial**](make-apk-accept-ca-certificate.md) を参照してください。

もし **Flutter** を使用している場合は、[**this page**](flutter.md) の指示に従う必要があります。単に証明書をストアに追加するだけでは動作しないことがあり、Flutter は独自の有効な CA のリストを持っているためです。

#### Static detection of SSL/TLS pinning

runtime のバイパスを試す前に、APK 内でどこに pinning が強制されているかを静的に把握してください。静的検出はフックやパッチの計画を立て、正しいコードパスに集中するのに役立ちます。

Tool: SSLPinDetect
- オープンソースの静的解析ユーティリティで、APK を Smali（apktool 経由）にデコンパイルし、SSL/TLS pinning 実装のためにキュレーションされた正規表現パターンをスキャンします。
- 各マッチについて正確なファイルパス、行番号、コードスニペットを報告します。
- OkHttp CertificatePinner、カスタム javax.net.ssl.X509TrustManager.checkServerTrusted、SSLContext.init とカスタム TrustManagers/KeyManagers、Network Security Config XML のピンなど、一般的なフレームワークとカスタムコードパスをカバーします。

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
使い方
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
パターンルールの例 (JSON)
独自/カスタムの pinning スタイルを検出するために signatures を使用または拡張します。独自の JSON を読み込んで大規模に scan できます。
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes and tips
- 大規模なアプリを高速にスキャンするには、マルチスレッド処理とメモリマップド I/O を利用する。事前コンパイル済みの正規表現はオーバーヘッドと誤検出を減らす。
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- 次にトリアージすべき典型的な検出対象:
- OkHttp: CertificatePinner の使用、setCertificatePinner、okhttp3/okhttp パッケージ参照
- Custom TrustManagers: javax.net.ssl.X509TrustManager、checkServerTrusted のオーバーライド
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init をカスタムマネージャーで使用
- Declarative pins in res/xml network security config と manifest の参照
- 一致した箇所を利用して、動的テストの前に Frida フック、静的パッチ、または設定レビューを計画する。



#### SSL Pinning の回避

SSL Pinning が実装されている場合、HTTPS トラフィックを調査するためにこれを回避する必要がある。目的のためのさまざまな方法がある：

- Automatically **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). このオプションの最大の利点は、SSL Pinning を回避するのに root が不要な点だが、アプリを削除して再インストールする必要があり、常に動作するとは限らない。
- You could use **Frida** (discussed below) to bypass this protection. Here you have a guide to use Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- You can also try to **automatically bypass SSL Pinning** using [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- You can also try to **automatically bypass SSL Pinning** using **MobSF dynamic analysis** (explained below)
- If you still think that there is some traffic that you aren't capturing you can try to **forward the traffic to burp using iptables**. Read this blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### 一般的な Web 脆弱性の検索

アプリ内で一般的な Web 脆弱性を探すことも重要である。これらの脆弱性の特定と緩和に関する詳細はこの要約の範囲を超えるが、他の場所で広く扱われている。

### Frida

[Frida](https://www.frida.re) は開発者、リバースエンジニア、セキュリティ研究者向けの動的インストルメンテーションツールキットです。\
**実行中のアプリにアクセスして、ランタイムでメソッドを hook し、挙動を変更したり、値を変更・抽出したり、別コードを実行したりできます...**\
Android アプリを pentest するなら Frida の使い方を知っておく必要がある。

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Some "GUI" for actions with Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- You can find some Awesome Frida scripts here: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Try to bypass anti-debugging / anti-frida mechanisms loading Frida as in indicated in [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **メモリダンプ - Fridump**

アプリがパスワードやニーモニックなど、本来メモリに保存すべきでない機密情報をメモリ内に保持していないか確認する。

Using [**Fridump3**](https://github.com/rootbsd/fridump3) you can dump the memory of the app with:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
これは ./dump フォルダにメモリをダンプします。そこで次のようなコマンドで grep できます:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Keystore内の機密データ**

AndroidではKeystoreが機密データを保存する最適な場所ですが、十分な権限があれば依然として**アクセス可能**です。アプリケーションはここに**平文の機密データ**を保存しがちなので、pentestsではroot userとして、あるいはデバイスに物理的にアクセスできる者がこのデータを盗める可能性があるためチェックする必要があります。

アプリがkeystoreにデータを保存している場合でも、データは暗号化されているべきです。

Keystore内のデータにアクセスするには、このFridaスクリプトを使用できます: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

以下のFrida scriptを使用すると、Androidアプリケーションが**bypass fingerprint authentication**を実施して、**特定の機密領域を保護する**処理を回避できる可能性があります：
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Background Images**

アプリをバックグラウンドに移動すると、Androidは**アプリケーションのスナップショット**を保存します。これによりフォアグラウンドに戻したとき、アプリ本体より先にそのイメージを読み込むため、アプリがより早く起動したように見えます。

ただし、このスナップショットに**機密情報**が含まれている場合、スナップショットにアクセスできる者が**その情報を盗む**可能性があります（アクセスするにはrootが必要である点に注意）。

スナップショットは通常次の場所に保存されます: **`/data/system_ce/0/snapshots`**

Androidは、レイアウトパラメータに**FLAG_SECUREを設定することでスクリーンショットの取得を防ぐ**方法を提供します。このフラグを使用すると、ウィンドウの内容がセキュアとして扱われ、スクリーンショットに表示されたり、非セキュアなディスプレイで表示されるのを防ぎます。
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

このツールは動的解析中の異なるツールの管理に役立ちます: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

開発者はしばしば、activities、services、broadcast receivers のようなプロキシコンポーネントを作成し、これらの Intent を処理して `startActivity(...)` や `sendBroadcast(...)` のようなメソッドに渡しますが、これはリスクを伴います。

これらの Intent を誤誘導することで、攻撃者が非 export（non-exported）なアプリコンポーネントをトリガーしたり、機密性の高い content providers にアクセスしたりできる点に危険性があります。代表的な例として、`WebView` コンポーネントが URL を `Intent.parseUri(...)` で `Intent` オブジェクトに変換して実行することで、悪意ある Intent 注入を引き起こす可能性があります。

### Essential Takeaways

- **Intent Injection** は web の Open Redirect 問題に類似しています。
- 悪用は `Intent` オブジェクトを extras として渡すことに関係し、それらがリダイレクトされて安全でない操作を実行させる可能性があります。
- 非-exported コンポーネントや content providers を攻撃者に晒してしまう可能性があります。
- `WebView` の URL から `Intent` への変換により、意図しない動作が発生し得ます。

### Android Client Side Injections and others

おそらくこれらの脆弱性は Web で既に知っているでしょう。Android アプリでは特に以下の点に注意してください：

- **SQL Injection:** 動的クエリや Content-Providers を扱う際は、parameterized queries を使用していることを確認してください。
- **JavaScript Injection (XSS):** いかなる WebViews においても JavaScript と Plugin サポートが無効になっていることを確認してください（デフォルトで無効）。 [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews はファイルシステムへのアクセスを無効にするべきです（デフォルトでは有効） - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: 多くの場合、Android アプリがセッションを終了してもクッキーが取り消されなかったり、ディスクに保存されることがあります
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Static analysis**

![](<../../images/image (866).png>)

**アプリケーションの脆弱性評価** を使いやすい web ベースのフロントエンドで実行できます。動的解析も実行可能ですが、環境の準備が必要です。
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### 支援付き Dynamic analysis with MobSF

**MobSF**は**Android**の**dynamic analysis**でも非常に有用ですが、その場合はホストにMobSFと**genymotion**をインストールする必要があります（VMやDockerでは動作しません）。_Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
**MobSF dynamic analyser**は以下を実行できます:

- **Dump application data**（URLs、ログ、clipboard、あなたが撮ったスクリーンショット、"Exported Activity Tester"が撮ったスクリーンショット、emails、SQLiteデータベース、XMLファイル、その他作成されたファイル）。これらはスクリーンショットを除き自動で行われます。スクリーンショットは撮りたいときに自分で押すか、すべてのexported activitiesのスクリーンショットを取得するには"Exported Activity Tester"を押す必要があります。
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: ロードされた全てのクラスを表示します
- **Capture Strings**: アプリ使用中に検出されたすべての文字列を出力します（非常にノイジー）
- **Capture String Comparisons**: 非常に有用です。比較されている2つの文字列と結果がTrueかFalseかを**表示**します。
- **Enumerate Class Methods**: クラス名（例: "java.io.File"）を入力するとそのクラスの全メソッドを表示します。
- **Search Class Pattern**: パターンでクラスを検索します
- **Trace Class Methods**: クラス全体を**Trace**します（クラスの全メソッドの入力と出力を確認）。デフォルトでMobSFは複数の興味深い Android Api メソッドをトレースすることを覚えておいてください。

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf also brings you a shell with some **adb** commands, **MobSF commands**, and common **shell** **commands** at the bottom of the dynamic analysis page. Some interesting commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTPツール**

When http traffic is capture you can see an ugly view of the captured traffic on "**HTTP(S) Traffic**" bottom or a nicer view in "**Start HTTPTools**" green bottom. From the second option, you can **send** the **captured requests** to **proxies** like Burp or Owasp ZAP.\
To do so, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> press "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Once you finish the dynamic analysis with MobSF you can press on "**Start Web API Fuzzer**" to **fuzz http requests** an look for vulnerabilities.

> [!TIP]
> After performing a dynamic analysis with MobSF the proxy settings me be misconfigured and you won't be able to fix them from the GUI. You can fix the proxy settings by doing:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Inspeckage を使った支援付き動的解析

You can get the tool from [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
This tool with use some **Hooks** to let you know **what is happening in the application** while you perform a **dynamic analysis**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

This is a **great tool to perform static analysis with a GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

This tool is designed to look for several **security related Android application vulnerabilities**, either in **source code** or **packaged APKs**. The tool is also **capable of creating a "Proof-of-Concept" deployable APK** and **ADB commands**, to exploit some of the found vulnerabilities (Exposed activities, intents, tapjacking...). As with Drozer, there is no need to root the test device.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- 抽出されたすべてのファイルを表示して参照を容易にします
- APKファイルを自動的にJavaおよびSmali形式にデコンパイルします
- AndroidManifest.xmlを解析して一般的な脆弱性や挙動を検出します
- 一般的な脆弱性や挙動に対する静的ソースコード解析を行います
- デバイス情報
- など
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPERはWindows、MacOS X、Linuxで使用できるコマンドラインアプリケーションで、_.apk_ファイルを解析して脆弱性を検出します。これはAPKを展開し、一連のルールを適用して脆弱性を検出することで行います。

すべてのルールは `rules.json` ファイルにまとめられており、各企業やテスターは必要に応じて独自のルールを作成できます。

最新のバイナリは[download page](https://superanalyzer.rocks/download.html)からダウンロードしてください。
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn は、モバイルアプリに対して [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) を実施する開発者、bugbounty hunters、ethical hackers を支援する **クロスプラットフォーム** ツールです。

コンセプトは、モバイルアプリのファイル（.apk または .ipa ファイル）を StaCoAn アプリにドラッグ＆ドロップすると、視覚的で持ち運び可能なレポートを生成する、というものです。設定やワードリストを調整してカスタマイズした体験を得ることができます。

ダウンロード[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework は、Android アプリケーションの潜在的なセキュリティ脆弱性を開発者や hackers が見つけるのを支援する脆弱性解析システムです。\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** は、Android アプリケーションによって行われる可能性のある悪意のある振る舞いを検出し、ユーザーに警告することを主な目的としたツールです。

検出は [`androguard`](https://github.com/androguard/androguard) ライブラリを使用して、アプリケーションの Dalvik bytecode を **Smali** として表現したものに対する **static analysis** により行われます。

このツールは、**「悪質な」アプリケーションの一般的な挙動**（例: Telephony identifiers exfiltration、Audio/video flow interception、PIM data modification、Arbitrary code execution...）を検出します。
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** は **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework です。一般的に使用されるモバイルアプリの reverse engineering と analysis ツールをまとめ、OWASP mobile security の脅威に対するテストを支援します。目的はモバイルアプリ開発者とセキュリティ専門家にとってこの作業をより簡単で扱いやすくすることです。

It is able to:

- Extract Java and Smali code using different tools
- Analyze APKs using: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Extract private information from the APK using regexps.
- Analyze the Manifest.
- Analyze found domains using: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

マルウェア検出に有用: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Note that depending the service and configuration you use to obfuscate the code. Secrets may or may not ended obfuscated.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. It is able to optimize bytecode as well as detect and remove unused instructions. ProGuard is free software and is distributed under the GNU General Public License, version 2.

ProGuard is distributed as part of the Android SDK and runs when building the application in release mode.

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Last time we checked, the Dexguard mode of operation was:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

You can upload an obfuscated APK to their platform.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

It is a **generic android deobfuscator.** Simplify **virtually executes an app** to understand its behavior and then **tries to optimize the code** so it behaves identically but is easier for a human to understand. Each optimization type is simple and generic, so it doesn't matter what the specific type of obfuscation is used.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD gives you information about **how an APK was made**. It identifies many **compilers**, **packers**, **obfuscators**, and other weird stuff. It's [_PEiD_](https://www.aldeid.com/wiki/PEiD) for Android.

### Manual

[チュートリアルを読んで **how to reverse custom obfuscation** のいくつかの技を学んでください](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b is an Android security virtual machine based on ubuntu-mate includes the collection of latest framework, tutorials and labs from different security geeks and researchers for reverse engineering and malware analysis.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) 素晴らしいリソースの一覧です
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android クイックコース
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
