# Programu za Android Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Misingi ya Programu za Android

Inapendekezwa sana kuanza kusoma ukurasa huu ili kujua kuhusu sehemu muhimu zaidi zinazohusiana na usalama wa Android na sehemu hatari zaidi katika programu ya Android:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Hii ndiyo zana kuu unayohitaji kuunganishwa na kifaa cha Android (kilichoiga au cha kimwili).\
**ADB** inaruhusu kudhibiti vifaa kwa kutumia **USB** au **mtandao** kutoka kwa kompyuta. Huduma hii inafanya iwezekane **kunakili** faili pande zote mbili, **kufunga** na **kuondoa** apps, **kuendesha** amri za shell, **kusaidia kuhifadhi nakala** za data, **kusoma** logi, miongoni mwa kazi nyingine.

Tazama orodha ifuatayo ya [**ADB Commands**](adb-commands.md) ili kujifunza jinsi ya kutumia adb.

## Smali

Wakati mwingine inavutia **kubadilisha msimbo wa programu** ili kupata **taarifa zilizofichwa** (labda nywila zilizoobfuscated vizuri au flags). Kisha, inaweza kuwa ya kuvutia ku-decompile APK, kubadilisha msimbo na ku-recompile yake.\
[**Katika tutorial hii** unaweza **kujifunza jinsi ya ku-decompile APK, kubadilisha msimbo wa Smali na ku-recompile APK** kwa uwezo mpya](smali-changes.md). Hii inaweza kuwa muhimu sana kama **mbadala kwa vipimo vingi wakati wa dynamic analysis** vitakavyowasilishwa. Kwa hivyo, **kumbuka kila wakati uwezekano huu**.

## Mbinu nyingine za kuvutia

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **Pakua APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Toa APK kutoka kwenye kifaa:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Unganisha splits zote na base apks kwa kutumia [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Mfano za Kesi & Udhaifu


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Uchambuzi wa Static

Kwanza kabisa, kwa kuchambua APK unapaswa **kutazama msimbo wa Java** kwa kutumia decompiler.\
Tafadhali, [**soma hapa kupata taarifa kuhusu decompilers mbalimbali zinazopatikana**](apk-decompilers.md).

### Kutafuta Habari Zenye Kuvutia

Kwa kuangalia tu **strings** za APK unaweza kutafuta **nywila**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api keys**, **usimbaji**, **bluetooth uuids**, **tokens** na chochote kinachovutia... hata tafuta code execution **backdoors** au authentication backdoors (credentials za admin zilizowekwa ndani ya app).

**Firebase**

Lipa tahadhari maalum kwa **Firebase URLs** na angalia kama imewekwa vibaya. [Taarifa zaidi kuhusu ni nini Firebase na jinsi ya kuiexploit hapa.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Ufahamu wa msingi wa programu - Manifest.xml, strings.xml

Ukaguzi wa faili za programu _Manifest.xml_ na _strings.xml_ unaweza kufunua udhaifu wa usalama. Faili hizi zinaweza kufikiwa kwa kutumia decompilers au kwa kubadilisha nyongeza ya faili ya APK kuwa .zip kisha kuizifungua.

**Udhaifu** uliotambuliwa kutoka kwa **Manifest.xml** ni pamoja na:

- **Maombi yanayoweza kudebugiwa**: Maombi yaliyowekwa kama debuggable (`debuggable="true"`) katika _Manifest.xml_ yanaweka hatari kwa sababu yanaruhusu muunganisho ambao unaweza kusababisha exploit. Kwa kuelewa zaidi juu ya jinsi ya kuiexploit debuggable applications, rejea somo kuhusu kutafuta na kutumia debuggable applications kwenye kifaa.
- **Mipangilio ya Backup**: Sifa `android:allowBackup="false"` inapaswa kuwekwa wazi kwa maombi yanayoshughulikia taarifa nyeti ili kuzuia backups zisizoidhinishwa kupitia adb, hasa wakati usb debugging imewezeshwa.
- **Usalama wa Mtandao**: Mipangilio ya kawaida ya usalama wa mtandao (`android:networkSecurityConfig="@xml/network_security_config"`) katika _res/xml/_ inaweza kutaja maelezo ya usalama kama certificate pins na mipangilio ya trafiki ya HTTP. Mfano ni kuruhusu trafiki ya HTTP kwa domini maalum.
- **Exported Activities na Services**: Kutambua activities na services zilizo exported katika manifest kunaweza kuonyesha vipengele vinavyoweza kutumika vibaya. Uchambuzi zaidi wakati wa mtihani wa dynamique unaweza kufichua jinsi ya kuiexploit vipengele hivi.
- **Content Providers na FileProviders**: Content providers zilizo wazi zinaweza kuruhusu upatikanaji au urekebishaji wa data bila idhini. Usanidi wa FileProviders pia unapaswa kuchunguzwa kwa umakini.
- **Broadcast Receivers na URL Schemes**: Vipengele hivi vinaweza kutumika kwa matumizi ya udanganyifu, kwa kutilia mkazo jinsi URL schemes zinavyosimamiwa kwa udhaifu wa input.
- **SDK Versions**: Sifa za `minSdkVersion`, `targetSDKVersion`, na `maxSdkVersion` zinaonyesha toleo la Android linaloungwa mkono, zikionyesha umuhimu wa kuto support version za zamani ambazo zinaweza kuwa zenye udhaifu kwa masuala ya usalama.

Kutoka kwa faili ya **strings.xml**, taarifa nyeti kama API keys, custom schemas, na maelezo mengine ya watengenezaji zinaweza kugunduliwa, ikisisitiza umuhimu wa mapitio ya kina ya rasilimali hizi.

### Tapjacking

**Tapjacking** ni shambulio ambapo **application** **hasidi** inaanzishwa na **kujipanga juu ya application ya mwathiriwa**. Mara inapoificha app ya mwathiriwa, kiolesura chake kimeundwa kwa njia ambayo kinamdanganya mtumiaji kufanya mwingiliano nayo, wakati inapitisha mwingiliano huo kwa app ya mwathiriwa.\
Kwa ufanisi, inamficha mtumiaji kwamba kwa kweli anafanya vitendo kwenye app ya mwathiriwa.

Pata habari zaidi katika:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Activity yenye **`launchMode`** imewekwa kuwa **`singleTask` bila `taskAffinity`** imefafanuliwa imeathirika kwa task Hijacking. Hii inamaanisha, kwamba application inaweza kusanikishwa na ikiwa itaendeshwa kabla ya application halisi inaweza **kuhijack task ya application halisi** (hivyo mtumiaji atakuwa anaingiliana na **application hasidi akidhani anatumia ile halisi**).

Taarifa zaidi katika:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Uhifadhi wa data usio salama

Internal Storage

Katika Android, faili zilizohifadhiwa katika uhifadhi wa ndani zimetengenezwa kuwa kufikika pekee na app iliyozitengeneza. Kipimo hiki cha usalama kinatekelezwa na mfumo wa uendeshaji wa Android na kwa kawaida kinatosheleza mahitaji ya usalama ya wengi wa maombi. Hata hivyo, watengenezaji wakati mwingine hutumia modes kama `MODE_WORLD_READABLE` na `MODE_WORLD_WRITABLE` kuruhusu faili kushirikishwa kati ya maombi tofauti. Mode hizi hazizuii upatikanaji wa faili hizi na maombi mengine, ikijumuisha yale ambayo yanaweza kuwa na nia mbaya.

1. **Uchambuzi wa Static:**
- **Hakikisha** kwamba matumizi ya `MODE_WORLD_READABLE` na `MODE_WORLD_WRITABLE` yanachunguzwa kwa makini. Mode hizi **zinaweza kufichua** faili kwa upatikanaji usiotarajiwa au usioidhinishwa.
2. **Uchambuzi wa Dynamic:**
- **Thibitisha** ruhusa zilizowekwa kwenye faili zilizotengenezwa na app. Hasa, **angalia** kama faili yoyote imewekwa kuwa readable au writable kwa wote. Hii inaweza kuwa hatari kubwa ya usalama, kwani itaweka uwezo kwa **app yoyote** iliyosakinishwa kwenye kifaa, bila kujali asili yake au nia, kusoma au kubadilisha faili hizi.

External Storage

Wakati wa kushughulikia faili kwenye external storage, kama SD Cards, tahadhari fulani zinapaswa kuchukuliwa:

1. **Upatikanaji**:
- Faili kwenye external storage ni **zinazosomeka na kuandikwa na wote**. Hii inamaanisha app yoyote au mtumiaji anaweza kufikia faili hizi.
2. **Mambo ya Usalama**:
- Kwa kuzingatia urahisi wa upatikanaji, inashauriwa **kuto hifadhi taarifa nyeti** kwenye external storage.
- External storage inaweza kuondolewa au kufikiwa na app yoyote, ikifanya isiwe salama.
3. **Kuendesha Data kutoka External Storage**:
- Daima **fanya uthibitishaji wa input** juu ya data inayorekebishwa kutoka external storage. Hii ni muhimu kwa sababu data inatoka kwa chanzo kisichotegemewa.
- Hifadhi ya executables au class files kwenye external storage kwa ajili ya dynamic loading haipendekezwi.
- Ikiwa app yako lazima ipokee faili za executable kutoka external storage, hakikisha faili hizi zimesainiwa na kuthibitishwa kificho kabla ya kupakiwa kwa njia ya dynamic. Hatua hii ni muhimu kwa kudumisha uadilifu wa usalama wa app yako.

External storage inaweza kufikiwa katika `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> Kuanzia na Android 4.4 (**API 17**), SD card ina muundo wa directories unaopunguza upatikanaji wa app hadi directory ambayo ni maalum kwa app hiyo. Hii inazuia application hasidi kupata upatikanaji wa kusoma au kuandika kwa faili za app nyingine.

**Taarifa nyeti zilizohifadhiwa kwa maandishi wazi**

- **Shared preferences**: Android inaruhusu kila application kuhifadhi kwa urahisi faili za xml katika njia `/data/data/<packagename>/shared_prefs/` na wakati mwingine inawezekana kupata taarifa nyeti kwa maandishi wazi katika folder hiyo.
- **Databases**: Android inaruhusu kila application kuhifadhi kwa urahisi sqlite databases katika njia `/data/data/<packagename>/databases/` na wakati mwingine inawezekana kupata taarifa nyeti kwa maandishi wazi katika folder hiyo.

### Broken TLS

**Accept All Certificates**

Kwa sababu fulani wakati mwingine watengenezaji wanakubali certificates zote hata kama kwa mfano hostname haifanani na mistari ya msimbo kama ifuatavyo:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Njia nzuri ya kujaribu hili ni kujaribu kunasa trafiki kwa kutumia proxy kama Burp bila kuidhinisha Burp CA ndani ya kifaa. Pia, unaweza kuunda na Burp cheti kwa hostname tofauti na kukitumia.

### Kriptografia Iliyovunjika

**Mchakato duni wa usimamizi wa funguo**

Baadhi ya watengenezaji huhifadhi data nyeti kwenye local storage na kuiencrypt kwa kutumia funguo zilizowekwa moja kwa moja / predictable katika code. Hii haipaswi kufanywa kwani reversing inaweza kumruhusu mshambuliaji kutoa taarifa za siri.

**Matumizi ya Algorithimu Hatari na/au Zilizopitwa na Wakati**

Watengenezaji hawapaswi kutumia **deprecated algorithms** kufanya authorisation **checks**, **store** au **send** data. Baadhi ya algorithms hizi ni: RC4, MD4, MD5, SHA1... Ikiwa **hashes** zinatumiwa kuhifadhi passwords kwa mfano, inapaswa kutumiwa hashes ambazo zina upinzani dhidi ya brute-force pamoja na salt.

### Mambo mengine ya kuangalia

- Inapendekezwa **obfuscate the APK** ili kufanya kazi ya reverse engineer kuwa ngumu kwa mashambuliaji.
- Ikiwa app ni nyeti (kama bank apps), inapaswa kufanya check zake mwenyewe kuona kama mobile ime-rooted na kuchukua hatua ipasavyo.
- Ikiwa app ni nyeti (kama bank apps), inapaswa kuhakiki kama emulator inatumika.
- Ikiwa app ni nyeti (kama bank apps), inapaswa **check it's own integrity before executing** ili kuona kama ilibadilishwa.
- Tumia [**APKiD**](https://github.com/rednaga/APKiD) kuona compiler/packer/obfuscator gani ilitumika kujenga APK

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

Kulingana na hii [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked ni Meta algorithm inayobana (compress) yaliyomo ya application ndani ya faili moja. Blog inaelezea uwezekano wa kuunda app inayoweza decompress aina hizi za apps... na njia ya haraka zaidi inayohusisha **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

The tool [**mariana-trench**](https://github.com/facebook/mariana-trench) ina uwezo wa kupatikana **vulnerabilities** kwa **scanning** ya **code** ya application. Zana hii ina safu ya **known sources** (zinazorambia zana maeneo ambapo **input** inadhibitiwa na user), **sinks** (zinazorambia zana maeneo hatari ambapo input ya mtumiaji mbaya inaweza kusababisha uharibifu) na **rules**. Rules hizi zinaonyesha **mchanganyiko** wa **sources-sinks** unaoashiria udiwani wa usalama.

Kwa uelewa huu, **mariana-trench itapitia code na kupata vulnerabilities zinazowezekana ndani yake**.

### Secrets leaked

Application inaweza kuwa na secrets (API keys, passwords, hidden urls, subdomains...) ndani yake ambazo unaweza kugundua. Unaweza kutumia zana kama [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)
- In-memory native code execution via JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Uchambuzi wa Dinamiki

> Kwanza kabisa, unahitaji mazingira ambapo unaweza kusanidi application na mazingira yote (Burp CA cert, Drozer na Frida hasa). Kwa hivyo, kifaa kilicho rooted (emulated au sio) kinapendekezwa sana.

### Online Dynamic analysis

Unaweza kuunda **free account** kwenye: [https://appetize.io/](https://appetize.io). Jukwaa hili linakuwezesha **upload** na **execute** APKs, hivyo ni muhimu kuona jinsi apk inavyotendeka.

Unaweza hata **kuona logs za application yako** kwenye wavuti na kuungana kupitia **adb**.

![](<../../images/image (831).png>)

Shukrani kwa muunganisho wa ADB unaweza kutumia **Drozer** na **Frida** ndani ya emulators.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (Unaweza kuunda **x86** na **arm** devices, na kulingana na [**hii**](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** versions **support ARM libraries** bila kuhitaji emulator ya arm ambayo ni polepole).
- Jifunze jinsi ya kuisanidi kwenye ukurasa huu:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, utahitaji kuunda account. _Inapendekezwa **download** toleo **WITH** _**VirtualBox** ili kuepuka makosa yanayoweza kutokea._)
- [**Nox**](https://es.bignox.com) (Free, lakini haitegemei Frida au Drozer).

> [!TIP]
> Unapotengeneza emulator mpya kwenye jukwaa lolote kumbuka kuwa skrini kubwa inafanya emulator kuwa polepole. Hivyo chagua skrini ndogo inapowezekana.

Ili **install google services** (kama AppStore) kwenye Genymotion unahitaji kubofya kitufe kilicho alama nyekundu kwenye picha ifuatayo:

![](<../../images/image (277).png>)

Pia, kumbuka kwamba katika **configuration ya Android VM katika Genymotion** unaweza kuchagua **Bridge Network mode** (hii itakuwa muhimu ikiwa utakuwa unahitaji kuungana na Android VM kutoka VM tofauti yenye zana).

#### Use a physical device

Unahitaji kuwasha options za **debugging** na itakuwa vizuri ikiwa unaweza kuiroot:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Rudi nyuma na utapata **Developer options**.

> Mara tu unapoweka application, jambo la kwanza unalopaswa kufanya ni kuifanyia majaribio na kuchunguza inafanya nini, inafanya kazi vipi na kufahamika nayo.\
> Ninapendekeza **fanya uchambuzi huu wa awali wa dinamik kwa kutumia MobSF dynamic analysis + pidcat**, hivyo tutakuwa na uwezo wa **kujifunza jinsi application inavyofanya kazi** wakati MobSF **inachukua** data nyingi **zazovutia** ambazo unaweza kupitia baadaye.

Magisk/Zygisk quick notes (recommended on Pixel devices)
- Patch boot.img with the Magisk app and flash via fastboot to get systemless root
- Enable Zygisk + DenyList for root hiding; consider LSPosed/Shamiko when stronger hiding is required
- Keep original boot.img to recover from OTA updates; re-patch after each OTA
- For screen mirroring, use scrcpy on the host



### Unintended Data Leakage

**Logging**

Watengenezaji wanapaswa kuwa waangalifu kuhusu kuonyesha **debugging information** hadharani, kwa kuwa inaweza kusababisha data nyeti ku-leak. Zana za [**pidcat**](https://github.com/JakeWharton/pidcat) na `adb logcat` zinapendekezwa kwa kusimamia logs za application ili kubaini na kulinda taarifa nyeti. **Pidcat** inapendekezwa kwa urahisi wake wa matumizi na ufasaha wa kuonekana.

> [!WARNING]
> Kumbuka kwamba tangu **toleo za baadaye za Android juu ya 4.0**, **applications zinaweza kupiga logs za programu zao tu**. Hivyo applications haziwezi kupata logs za apps nyingine.\
> Hata hivyo, bado inashauriwa **kuto-log taarifa nyeti**.

**Copy/Paste Buffer Caching**

Mfumo wa Android unaotegemea **clipboard** unawezesha utendaji wa copy-paste katika apps, lakini una hatari kwani **applications nyingine** zinaweza **kupata** clipboard, na hivyo kuonyesha data nyeti. Ni muhimu **kuzima copy/paste** kwa sehemu nyeti za application, kama maelezo ya kadi za mkopo, ili kuzuia leak ya data.

**Crash Logs**

Ikiwa application **inaanguka (crashes)** na **inahifadhi logs**, logs hizi zinaweza kumsaidia mshambuliaji, hasa pale application haiwezi ku-reverse-engineered. Ili kupunguza hatari hii, epuka ku-log wakati wa crashes, na kama logs lazima zitumwe mtandaoni, hakikisha zinatumwa kupitia channel ya SSL kwa usalama.

Kama pentester, **jaribu kuangalia logs hizi**.

**Analytics Data Sent To 3rd Parties**

Applications mara nyingi hujumuisha huduma kama Google Adsense, ambazo kwa kutokukamilika kwa utekelezaji wa watengenezaji zinaweza kwa bahati mbaya leak sensitive data. Ili kubaini leak za data zinazowezekana, inashauriwa **kuingilia (intercept) trafiki ya application** na kuangalia kama kuna taarifa nyeti zinatumiwa kwenda kwa huduma za wa tatu.

### SQLite DBs

Mara nyingi applications hutatumia **internal SQLite databases** kuhifadhi taarifa. Wakati wa pentest angalia **databases** zilizoundwa, majina ya **tables** na **columns** na data zote zilizohifadhiwa kwani unaweza kupata **taarifa nyeti** (ambayo itakuwa udhaifu).\
Databases zinapaswa kuwa katika `/data/data/the.package.name/databases` kama `/data/data/com.mwr.example.sieve/databases`

Ikiwa database inahifadhi taarifa za siri na ime-**encrypted** lakini unaweza **kupata** password ndani ya application bado ni **udhaifu**.

Orodhesha tables kwa kutumia `.tables` na orodhesha columns za tables kwa kufanya `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** inakuwezesha kuchukua nafasi ya Android app na kuingiliana na apps nyingine. Inaweza kufanya chochote ambacho installed application inaweza kufanya, kama kutumia mfumo wa Android’s Inter-Process Communication (IPC) na kuingiliana na operating system iliyopo. .\
Drozer ni zana muhimu ya **kuchukua faida ya exported activities, exported services na Content Providers** kama utakavyojifunza katika sehemu zilizofuata.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Pia kumbuka kwamba code ya activity inaanza katika method ya **`onCreate`**.

**Authorisation bypass**

Wakati Activity ime-exported unaweza kuitisha screen yake kutoka app ya nje. Kwa hivyo, ikiwa activity yenye **taarifa nyeti** ime-exported unaweza **bypass** mekanismo za **authentication** ili kufikia.

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

Unaweza pia kuanza exported activity kutoka adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> Kumbuka kwamba authorisation bypass siyo kila mara ni vulnerability; itategemea jinsi bypass inavyofanya kazi na ni taarifa gani zinazoonyeshwa.

**Sensitive information leakage**

**Activities pia zinaweza kurudisha matokeo**. Ikiwa utaweza kupata activity iliyokuwa exported na isiyolindwa ikitumia method ya **`setResult`** na **kurudisha sensitive information**, kuna sensitive information leakage.

#### Tapjacking

Ikiwa Tapjacking haizuizwi, unaweza kutumia exported activity kusababisha **mtumiaji afanye vitendo visivyotarajiwa**. Kwa maelezo zaidi kuhusu [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)  
Content providers kwa msingi hutumiwa **kushiriki data**. Ikiwa app ina content providers zinapatikana unaweza kuwa na uwezo wa **kutoa data nyeti** kutoka kwao. Pia ni vyema kujaribu uwezekano wa **SQL injections** na **Path Traversals**, kwa sababu vinaweza kuwa dhaifu.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)  
Kumbuka kwamba vitendo vya Service huanza kwenye method `onStartCommand`.

Service kwa msingi ni kitu kinachoweza **kupokea data**, **kuchakata** na **kurudisha** (au la) majibu. Hivyo, ikiwa application ina services zilizochapishwa (exporting) unapaswa **kagua** **code** ili kuelewa inafanya nini na **iteste** kwa njia ya **dynamic** kwa lengo la kupata taarifa za siri, bypassing authentication measures...  
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)  
Kumbuka kwamba vitendo vya Broadcast Receiver huanza kwenye method `onReceive`.

Broadcast receiver itakuwa inasubiri aina fulani ya ujumbe. Kutegemea jinsi receiver inavyoshughulikia ujumbe huo inaweza kuwa dhaifu.  
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Unaweza kutafuta deep links kwa mkono, ukitumia tools kama MobSF au scripts kama [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).  
Unaweza **fungua** scheme iliyotangazwa kwa kutumia **adb** au **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Kumbuka kwamba unaweza **omit the package name** na kifaa cha rununu kitaita moja kwa moja app itakayofungua link hiyo._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Msimbo unaotekelezwa**

Ili kupata **msimbo utakao endeshwa katika App**, nenda kwa activity inayoitwa na deeplink na tafuta function **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Taarifa nyeti**

Kila unapokutana na deep link hakikisha kwamba **haina kupokea data nyeti (kama passwords) kupitia URL parameters**, kwa sababu programu nyingine yoyote inaweza **kuiga deep link na kuiba data hiyo!**

**Parameters in path**

Unapaswa pia kuangalia kama deep link yoyote inatumia parameter ndani ya path ya URL kama: `https://api.example.com/v1/users/{username}` , katika kesi hiyo unaweza kulazimisha path traversal kwa kufikia kitu kama: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Kumbuka kwamba ikiwa utapata endpoints sahihi ndani ya application unaweza kusababisha **Open Redirect** (ikiwa sehemu ya path inatumika kama domain name), **account takeover** (ikiwa unaweza kubadilisha maelezo ya watumiaji bila CSRF token na endpoint iliyo vuln ilitumia method sahihi) na aina nyingine yoyote ya vuln. Taarifa zaidi kuhusu hili [hapa](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

Ripoti ya bug bounty ya kuvutia: [hapa](https://hackerone.com/reports/855618) kuhusu links (_/.well-known/assetlinks.json_).

### Ukaguzi wa Transport Layer na Makosa ya Uthibitishaji

- **Vyeti hazichunguzwi kila mara ipasavyo** na applications za Android. Ni kawaida kwa applications hizi kupuuza onyo na kukubali self-signed certificates au, katika matukio mengine, kurudi kutumia HTTP connections.
- **Mazungumzo wakati wa SSL/TLS handshake wakati mwingine huwa dhaifu**, zikitumia insecure cipher suites. Udhurumvu huu unafanya connection kuwa nyeti kwa man-in-the-middle (MITM) attacks, kuruhusu attackers kufungua data.
- **Leakage of private information** ni hatari wakati applications zinathibitisha kwa kutumia secure channels lakini kisha kuwasiliana kupitia non-secure channels kwa miamala mingine. Njia hii inashindwa kulinda data nyeti, kama session cookies au maelezo ya mtumiaji, dhidi ya interception na entities zenye nia mbaya.

#### Uthibitishaji wa Cheti

Tutazingatia **certificate verification**. Lazima integrity ya cheti cha server ithibitishwe ili kuongeza usalama. Hii ni muhimu kwa sababu konfigurishaji zisizo salama za TLS na uwasilishaji wa data nyeti kupitia channels zisizosimbwa zinaweza kuleta hatari kubwa. Kwa hatua za kina za kuthibitisha vyeti vya server na kushughulikia udhaifu, [**rasilimali hii**](https://manifestsecurity.com/android-application-security-part-10/) inatoa mwongozo kamili.

#### SSL Pinning

SSL Pinning ni hatua ya usalama ambapo application inathibitisha cheti ya server dhidi ya nakala inayojulikana iliyohifadhiwa ndani ya application yenyewe. Njia hii ni muhimu kwa kuzuia MITM attacks. Kutekeleza SSL Pinning kunapendekezwa kwa nguvu kwa applications zinashughulikia taarifa nyeti.

#### Traffic Inspection

Ili kuchunguza HTTP traffic, ni lazima **uishe cheti cha proxy tool** (mfano, Burp). Bila kuisakinisha cheti hiki, trafiki iliyosimbwa inaweza isionekane kupitia proxy. Kwa mwongozo wa kusakinisha custom CA certificate, [**bonyeza hapa**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Applications zinazolenga **API Level 24 and above** zinahitaji marekebisho ya Network Security Config ili kukubali CA certificate ya proxy. Hatua hii ni muhimu kwa kuchunguza trafiki iliyosimbwa. Kwa maelekezo ya kubadilisha Network Security Config, [**rejea tutorial hii**](make-apk-accept-ca-certificate.md).

Ikiwa **Flutter** inatumiwa unahitaji kufuata maelekezo katika [**ukurasa huu**](flutter.md). Hii ni kwa sababu, kuongeza tu cheti kwenye store haitafanya kazi kwani Flutter ina orodha yake ya valid CAs.

#### Ugunduzi wa statiki wa SSL/TLS pinning

Kabla ya kujaribu runtime bypasses, chora haraka ni wapi pinning inatekelezwa ndani ya APK. Ugunduzi wa statiki hukusaidia kupanga hooks/patches na kuzingatia code paths sahihi.

Tool: SSLPinDetect
- Open-source utiliti ya uchambuzi wa statiki inayodecompile APK hadi Smali (via apktool) na kutafuta pattern za regex zilizotengwa za utekelezaji wa SSL/TLS pinning.
- Inaripoti path sahihi ya faili, nambari ya mstari, na kipande cha code kwa kila match.
- Inashughulikia frameworks za kawaida na custom code paths: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

Install
- Mahitaji ya awali: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Matumizi
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Mfano wa kanuni za pattern (JSON)
Tumia au ongeza signatures ili kugundua proprietary/custom pinning styles. Unaweza kupakia JSON yako mwenyewe na scan kwa wingi.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes and tips
- Kuchanganua haraka kwenye apps kubwa kupitia multi-threading na memory-mapped I/O; pre-compiled regex hupunguza overhead/false positives.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Malengo ya kawaida ya utambuzi kwa kuchunguza ifuatayo:
- OkHttp: matumizi ya CertificatePinner, setCertificatePinner, okhttp3/okhttp package references
- TrustManagers maalum: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- SSL contexts maalum: SSLContext.getInstance + SSLContext.init with custom managers
- Pins zilizotangazwa katika res/xml network security config na marejeo ya manifest
- Tumia maeneo yaliyoendana kupanga Frida hooks, static patches, au mapitio ya config kabla ya majaribio ya dynamic.



#### Kuepuka SSL Pinning

Wakati SSL Pinning imeanzishwa, kuepuka itakuwa muhimu ili kuchunguza trafiki ya HTTPS. Mbinu mbalimbali zinapatikana kwa madhumuni haya:

- Badilisha kwa otomatiki **apk** ili **kuepuka** SSLPinning kwa kutumia [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Faida kubwa ya chaguo hili ni kwamba hautahitaji root kuepuka SSL Pinning, lakini utahitaji kufuta programu na kusakinisha mpya, na hii si kila wakati itafanya kazi.
- Unaweza kutumia **Frida** (imejadiliwa hapa chini) kuepuka ulinzi huu. Hapa kuna mwongozo wa kutumia Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Unaweza pia kujaribu **kuepuka moja kwa moja SSL Pinning** ukitumia [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Unaweza pia kujaribu **kuepuka moja kwa moja SSL Pinning** ukitumia **MobSF dynamic analysis** (imeelezewa hapa chini)
- Ikiwa bado unaona kuna trafiki ambayo hauikamata, unaweza kujaribu **kupeleka trafiki kwa Burp kwa kutumia iptables**. Soma blogu hii: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Kutafuta Udhaifu wa Wavuti wa Kawaida

Ni muhimu pia kutafuta udhaifu wa kawaida wa wavuti ndani ya programu. Maelezo ya kina juu ya kutambua na kupunguza udhaifu hivi ni kubwa kuliko muhtasari huu lakini yameelezewa kwa undani mahali pengine.

### Frida

[Frida](https://www.frida.re) ni toolkit ya instrumentation ya dynamic kwa waendelezaji, wachambuzi wa reverse-engineering, na watafiti wa usalama.\
**Unaweza kufikia application inayokwama na ku-hook methods wakati wa runtime ili kubadilisha tabia, kubadilisha thamani, kutoa thamani, kuendesha code tofauti...**\
Ikiwa unataka kufanya pentest za Android applications unahitaji kujua jinsi ya kutumia Frida.

- Jifunze jinsi ya kutumia Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Baadhi ya "GUI" kwa vitendo na Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection ni nzuri kuendesha otomatiki matumizi ya Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Unaweza kupata baadhi ya Awesome Frida scripts hapa: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Jaribu kuepuka mekanismi za anti-debugging / anti-frida kwa kuanzisha Frida kama inavyoelezwa katika [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (zana [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

Angalia kama application inahifadhi taarifa nyeti ndani ya memory ambazo haipaswi kuhifadhi kama passwords au mnemonics.

Ukijumuisha [**Fridump3**](https://github.com/rootbsd/fridump3) unaweza kufanya dump ya memory ya app kwa:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Hii ita-dump kumbukumbu katika folda ./dump, na hapo unaweza kutumia grep kwa kitu kama:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Data nyeti katika Keystore**

Katika Android, Keystore ni mahali pazuri kuhifadhi data nyeti, hata hivyo, kwa ruhusa za kutosha bado inawezekana kuifikia. Kwa kuwa applications zinaweza kuhifadhi hapa sensitive data in clear text, pentests zinapaswa kuangalia hilo kwa mtumiaji root au mtu mwenye ufikiaji wa kimwili wa kifaa ambaye anaweza kuiba data hiyo.

Hata kama app ilihifadhi data katika keystore, data hiyo inapaswa kuwa encrypted.

Ili kufikia data ndani ya keystore unaweza kutumia script ya Frida: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Kwa kutumia Frida script ifuatayo inaweza kuwa inawezekana **bypass fingerprint authentication** Android applications zinaweza kufanya ili **kulinda maeneo fulani nyeti:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Picha za Mandharinyuma**

Unapoweka application kwa mandharinyuma, Android huhifadhi **snapshot ya application** ili inaporejeshwa mbele inaanza kupakia picha kabla ya app, hivyo inaonekana kama app ilipakia haraka.

Hata hivyo, ikiwa snapshot hii ina **taarifa nyeti**, mtu mwenye ufikiaji wa snapshot anaweza **kuiba taarifa hiyo** (kumbuka unahitaji root ili kuifikia).

Snapshots kawaida huhifadhiwa karibu: **`/data/system_ce/0/snapshots`**

Android inatoa njia ya **kuzuia the screenshot capture kwa kuweka parameter ya layout FLAG_SECURE**. Kwa kutumia flag hii, maudhui ya window yanachukuliwa kuwa salama, kuyazuia kuonekana kwenye screenshots au kuonekana kwenye non-secure displays.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Kifaa hiki kinaweza kukusaidia kusimamia zana mbalimbali wakati wa dynamic analysis: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Waundaji mara nyingi huunda proxy components kama activities, services, na broadcast receivers ambazo zinashughulikia Intent hizi na kuzipitisha kwa methods kama `startActivity(...)` au `sendBroadcast(...)`, jambo ambalo linaweza kuwa hatari.

Hatari iko katika kuruhusu attackers kuanzisha non-exported app components au kupata access kwa sensitive content providers kwa kupelekewa Intent hizi kwa njia isiyo sahihi. Mfano wa kuzingatia ni component ya `WebView` kubadilisha URLs kuwa `Intent` objects kupitia `Intent.parseUri(...)` kisha kuziendesha, jambo ambalo linaweza kusababisha malicious Intent injections.

### Vidokezo Muhimu

- **Intent Injection** ni sawa na Open Redirect ya web.
- Exploits involve passing `Intent` objects as extras, which can be redirected to execute unsafe operations.
- Inaweza kufichua non-exported components na content providers kwa attackers.
- `WebView`’s URL to `Intent` conversion inaweza kuwezesha vitendo visivyotarajiwa.

### Android Client Side Injections and others

Huenda unajua aina hizi za udhaifu kutoka Web. Lazima uwe makini hasa na udhaifu hizi katika application ya Android:

- **SQL Injection:** When dealing with dynamic queries or Content-Providers ensure you are using parameterized queries.
- **JavaScript Injection (XSS):** Verify that JavaScript and Plugin support is disabled for any WebViews (disabled by default). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews should have access to the file system disabled (enabled by default) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: In several cases when the android application finish the session the cookie isn't revoked or it could be even saved to disk
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Uchambuzi Otomatiki

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Uchambuzi wa statiki**

![](<../../images/image (866).png>)

**Tathmini ya udhaifu ya programu** kwa kutumia frontend nzuri ya wavuti. Unaweza pia kufanya dynamic analysis (lakini unahitaji kuandaa mazingira).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Kumbuka kwamba MobSF inaweza kuchambua **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Pia, ikiwa utaunda faili ya **ZIP** yenye msimbo wa chanzo wa app ya **Android** au **IOS** (nenda kwenye root folder ya application, chagua kila kitu na unda ZIPfile), itaweza kuichambua pia.

MobSF pia inakuwezesha kufanya **diff/Compare** za uchambuzi na kuunganisha **VirusTotal** (utahitaji kuweka API key yako katika _MobSF/settings.py_ na kuiwezesha: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). Unaweza pia kuweka `VT_UPLOAD` kuwa `False`, basi **hash** itaupload badala ya faili.

### Assisted Dynamic analysis with MobSF

**MobSF** pia inaweza kuwa msaada mkubwa kwa ajili ya **dynamic analysis** katika **Android**, lakini katika kesi hiyo utahitaji kusakinisha MobSF na **genymotion** kwenye host yako (a VM or Docker won't work). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
The **MobSF dynamic analyser** inaweza:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). Yote haya hufanywa kiotomatiki isipokuwa screenshots; unahitaji kubonyeza wakati unapotaka screenshot au unahitaji kubonyeza "**Exported Activity Tester**" kupata screenshots za exported activities zote.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: It will print all the loaded classes
- **Capture Strings**: It will print all the capture strings while using the application (super noisy)
- **Capture String Comparisons**: Could be very useful. It will **show the 2 strings being compared** and if the result was True or False.
- **Enumerate Class Methods**: Put the class name (like "java.io.File") and it will print all the methods of the class.
- **Search Class Pattern**: Search classes by pattern
- **Trace Class Methods**: **Trace** a **whole class** (see inputs and outputs of all methods of th class). Remember that by default MobSF traces several interesting Android Api methods.

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf pia inakuja na shell yenye baadhi ya amri za **adb**, **MobSF commands**, na amri za kawaida za **shell** chini ya ukurasa wa dynamic analysis. Baadhi ya amri zenye kuvutia:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**Vifaa vya HTTP**

Wakati traffic ya HTTP inapokamatwa unaweza kuona muonekano mbaya wa traffic iliyokamatwa kwenye kitufe cha chini "**HTTP(S) Traffic**" au muonekano mzuri kwenye kitufe cha kijani "**Start HTTPTools**". Kutoka chaguo la pili, unaweza **kutuma** **maombi yaliyokamatwa** kwa **proxies** kama Burp au Owasp ZAP.\
Ili kufanya hivyo, _amsha Burp -->_ _zima Intercept --> katika MobSB HTTPTools chagua request_ --> bonyeza "**Send to Fuzzer**" --> _chagua anwani ya proxy_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Mara utakapomaliza uchambuzi wa dynamic na MobSF unaweza kubonyeza "**Start Web API Fuzzer**" ili **fuzz http requests** na kutafuta vulnerabilities.

> [!TIP]
> Baada ya kufanya uchambuzi wa dynamic na MobSF mipangilio ya proxy inaweza kuwa imechanganikwa na hutaweza kuirekebisha kutoka GUI. Unaweza kurekebisha mipangilio ya proxy kwa kufanya:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

Unaweza kupata tool hii kutoka kwa [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Chombo hiki kinatumia baadhi ya **Hooks** kukujulisha **kinachotokea kwenye application** wakati unafanya **dynamic analysis**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Hii ni **tool nzuri ya kufanya static analysis kwa GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Tool hii imeundwa kutafuta aina mbalimbali za **security related Android application vulnerabilities**, iwe katika **source code** au **packaged APKs**. Tool pia ina uwezo wa **kuunda "Proof-of-Concept" deployable APK** na **ADB commands**, ili ku-exploit baadhi ya vulnerabilities zilizopatikana (Exposed activities, intents, tapjacking...). Kama ilivyo kwa Drozer, hakuna haja ya ku-root kifaa cha mtihani.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Inaonyesha mafaili yote yaliyotolewa kwa marejeo rahisi
- Moja kwa moja decompile APK files hadi format ya Java na Smali
- Huchambua AndroidManifest.xml kwa common vulnerabilities na tabia
- Static source code analysis kwa common vulnerabilities na tabia
- Taarifa za kifaa
- na zaidi
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER ni programu ya command-line inayoweza kutumiwa kwenye Windows, MacOS X na Linux, ambayo inachambua faili za _.apk_ ili kutafuta vulnerabilities. Inafanya hivyo kwa ku-decompress APKs na kutumia mfululizo wa sheria ili kugundua vulnerabilities hizo.

Sheria zote ziko kwenye faili `rules.json`, na kila kampuni au mjaribu anaweza kuunda sheria zake za kuchambua wanachohitaji.

Pakua binaries za hivi karibuni kutoka kwenye [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn ni zana ya **crossplatform** inayosaidia waendelezaji, bugbounty hunters na ethical hackers kufanya [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) kwenye programu za rununu.

Dhana ni kwamba unavuta na kuachilia faili ya programu yako ya rununu (faili ya .apk au .ipa) kwenye programu ya StaCoAn na itazalisha ripoti ya kuona na inayobebeka kwako. Unaweza kubadilisha mipangilio na wordlists ili kupata uzoefu uliobinafsishwa.

Download[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework ni mfumo wa uchambuzi wa udhaifu wa Android unaosaidia waendelezaji au hackers kugundua udhaifu za kiusalama zinazowezekana katika programu za Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** ni zana ambayo lengo lake kuu ni kugundua na kuonya mtumiaji kuhusu tabia hatarishi zinazoweza kufanywa na programu ya Android.

Utambuzi hufanywa kwa kutumia **static analysis** ya bytecode ya Dalvik ya programu, inayowakilishwa kama **Smali**, kwa kutumia maktaba ya [`androguard`](https://github.com/androguard/androguard).

Zana hii inatafuta **tabia za kawaida za programu "mbaya"** kama: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. Ni zana inayokusanya zana zinazotumika mara kwa mara za mobile application reverse engineering and analysis, kusaidia katika kujaribu programu za simu dhidi ya vitisho vya OWASP mobile security. Lengo lake ni kufanya kazi hii iwe rahisi na rafiki kwa watengenezaji wa programu za simu na wataalamu wa usalama.

Ina uwezo wa:

- Kutoa Java na Smali code kwa kutumia zana mbalimbali
- Fanya uchambuzi wa APKs kwa kutumia: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Kutoa taarifa za kibinafsi kutoka kwenye APK kwa kutumia regexps.
- Chunguza Manifest.
- Chunguza domains zilizopatikana kwa kutumia: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Inafaa kugundua malware: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Kumbuka kwamba, kulingana na huduma na usanidi unaotumika kuficha msimbo, siri zinaweza kuwa zimefichwa au siyo.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

Kutoka [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** ni zana ya open source ya command-line inayopunguza, kuboresha na kuficha Java code. Ina uwezo wa kuboresha bytecode pamoja na kugundua na kuondoa maelekezo yasiyotumika. ProGuard ni programu ya bure na imesambazwa chini ya GNU General Public License, version 2.

ProGuard inasambazwa kama sehemu ya Android SDK na hufanya kazi wakati wa kujenga application katika release mode.

### [DexGuard](https://www.guardsquare.com/dexguard)

Pata mwongozo hatua kwa hatua wa ku-deobfuscate apk katika [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(Kulingana na mwongozo huo) Wakati wa mwisho tulipopima, mode ya utekelezaji ya Dexguard ilikuwa:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

Unaweza kupakia APK iliyofichwa kwenye jukwaa lao.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

Hii ni zana ya LLM ya kugundua udhaifu wowote unaowezekana wa usalama katika android apps na ku-deobfuscate android app code. Inatumia Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

Ni generic android deobfuscator. Simplify virtually executes an app ili kuelewa tabia yake kisha inajaribu kuboresha code ili itendeke sawa lakini iwe rahisi kwa mwanadamu kuelewa. Kila aina ya uboreshaji ni rahisi na jumla, hivyo haijalishi ni aina gani mahsusi ya obfuscation ilitumika.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD inakupa taarifa kuhusu jinsi APK ilivyotengenezwa. Inatambua compilers, packers, obfuscators, na vitu vingine vya kushangaza. Ni [_PEiD_](https://www.aldeid.com/wiki/PEiD) kwa Android.

### Manual

[Soma mafunzo haya kujifunza mbinu za jinsi ya reverse custom obfuscation](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b ni virtual machine ya usalama wa Android inayotegemea ubuntu-mate inayojumuisha mkusanyiko wa mifumo ya hivi karibuni, mafunzo na maabara kutoka kwa wapenzi mbalimbali wa usalama na watafiti kwa reverse engineering na malware analysis.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Ni orodha nzuri ya rasilimali
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
