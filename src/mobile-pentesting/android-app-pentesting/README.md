# Android Applications Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android Applications Basics

强烈建议先阅读此页面，以了解与 **Android 安全相关的最重要部分以及 Android 应用中最危险的组件**：


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

这是连接 Android 设备（模拟或实体）所需的主要工具。\
**ADB** 允许从计算机通过 **USB** 或 **Network** 控制设备。此实用程序支持文件双向的 **copying**、应用的 **installation** 和 **uninstallation**、shell 命令的 **execution**、数据的 **backing up**、日志的 **reading**，以及其他功能。

查看下列 [**ADB Commands**](adb-commands.md) 列表以学习如何使用 adb。

## Smali

有时为了访问 **隐藏信息**（例如经过良好混淆的密码或 flags），对 **应用程序代码进行修改** 会很有用。然后，可能需要反编译 apk，修改代码并重新编译它。\
[**在本教程中** 您可以 **学习如何反编译 APK、修改 Smali 代码并重新编译 APK** 以添加新功能](smali-changes.md)。这在进行 **动态分析** 时作为若干测试的替代方法非常有用。请始终记住这种可能性。

## Other interesting tricks

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [Android IME / InputMethodService Abuse (Malicious Keyboards)](inputmethodservice-ime-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **下载 APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- 从设备提取 APK：
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- 使用 [APKEditor](https://github.com/REAndroid/APKEditor) 合并所有 splits 和 base apks:
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Android Enterprise & Work Profile Attacks

{{#ref}}
android-enterprise-work-profile-bypass.md
{{#endref}}

## 案例研究与漏洞


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

{{#ref}}
abusing-android-media-pipelines-image-parsers.md
{{#endref}}

{{#ref}}
../../binary-exploitation/linux-kernel-exploitation/arm64-static-linear-map-kaslr-bypass.md
{{#endref}}

## 静态分析

首先，分析 APK 时应使用反编译器**查看 Java 代码**。\
请[**在此阅读可用反编译器的相关信息**](apk-decompilers.md)。

### 查找有价值的信息

仅查看 APK 的 **字符串** 就可以搜索 **密码**、**URL**（[https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)）、**API 密钥**、**加密**、**Bluetooth UUIDs**、**令牌**以及其他任何有趣的内容……甚至要查找代码执行的**后门**或认证后门（应用的硬编码管理员凭证）。

**Firebase**

特别注意 **Firebase URLs** 并检查其配置是否错误。[关于什么是 Firebase 以及如何利用它的更多信息请见此处。](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### 对应用的基本理解 - Manifest.xml, strings.xml

**检查应用的 _Manifest.xml_ 和 _strings.xml_ 文件可以揭示潜在的安全漏洞**。这些文件可以使用反编译器访问，或者将 APK 文件扩展名改为 .zip 后解压来查看。

从 **Manifest.xml** 中可识别的 **漏洞** 包括：

- **Debuggable Applications**：在 _Manifest.xml_ 中将应用设置为可调试（`debuggable="true"`）会存在风险，因为这允许建立连接并可能导致利用。要了解如何利用可调试应用，请参考关于在设备上查找和利用可调试应用的教程。
- **Backup Settings**：对于处理敏感信息的应用，应显式设置 `android:allowBackup="false"` 属性，以防止在开启 usb debugging 时通过 adb 进行未经授权的数据备份。
- **Network Security**：自定义网络安全配置（`android:networkSecurityConfig="@xml/network_security_config"`）位于 _res/xml/_ 中，可以指定证书 pin、HTTP 流量设置等安全细节。例如，可以为特定域名允许 HTTP 流量。
- **Exported Activities and Services**：识别 manifest 中导出的 activities 和 services 可以突出可能被滥用的组件。在动态测试中进一步分析可以揭示如何利用这些组件。
- **Content Providers and FileProviders**：暴露的 content provider 可能允许未经授权的访问或修改数据。应仔细检查 FileProvider 的配置。
- **Broadcast Receivers and URL Schemes**：这些组件可能被用于利用，需特别注意 URL scheme 的处理以防输入相关的漏洞。
- **SDK Versions**：`minSdkVersion`、`targetSDKVersion` 和 `maxSdkVersion` 属性指示支持的 Android 版本，这强调了不要支持过时且存在漏洞的 Android 版本以维护安全。

从 **strings.xml** 文件中，可以发现敏感信息，例如 API 密钥、自定义 schema 和其他开发者备注，这凸显了对这些资源进行仔细审查的必要性。

### Tapjacking

**Tapjacking** 是一种攻击，攻击者启动一个**恶意** **应用**并**将其显示在受害者应用之上**。当它遮挡住受害应用时，其用户界面设计旨在欺骗用户与其交互，同时将交互传递给受害应用。\
实际上，它是**蒙蔽用户，使其不知道自己实际上是在对受害应用执行操作**。

更多信息见：


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

一个将 `launchMode` 设置为 `singleTask` 且未定义任何 `taskAffinity` 的 **activity** 易受 Task Hijacking 影响。这意味着，如果先安装并在真正的应用之前启动一个恶意应用，它可能**劫持真实应用的任务**（因此用户会以为自己在使用真实应用，实际上在与**恶意应用**交互）。

更多信息见：


{{#ref}}
android-task-hijacking.md
{{#endref}}

### 不安全的数据存储

**内部存储**

在 Android 中，存储在**内部**存储的文件设计为只能被**创建它们的应用**访问。这一安全措施由 Android 操作系统强制执行，通常能满足大多数应用的安全需求。然而，开发者有时会使用 `MODE_WORLD_READABLE` 和 `MODE_WORLD_WRITABLE` 模式来**允许**文件在不同应用之间**共享**。但这些模式**并不限制**其他应用（包括潜在的恶意应用）对这些文件的访问。

1. **静态分析：**
- **确保**仔细审查是否使用了 `MODE_WORLD_READABLE` 和 `MODE_WORLD_WRITABLE`。这些模式**可能会暴露**文件，导致**非预期或未经授权的访问**。
2. **动态分析：**
- **验证**应用创建的文件所设置的**权限**。特别是，**检查**是否有文件被设置为对全世界可读或可写。这会构成显著的安全风险，因为它允许**任何安装在设备上的应用**（无论来源或意图）**读取或修改**这些文件。

**外部存储**

处理外部存储（例如 SD 卡）上的文件时，应采取以下预防措施：

1. **可访问性：**
- 外部存储上的文件是**全局可读写的**。这意味着任何应用或用户都可以访问这些文件。
2. **安全性关注点：**
- 由于访问方便，建议**不要在外部存储上保存敏感信息**。
- 外部存储可以被移除或被任何应用访问，因此安全性较差。
3. **从外部存储处理数据：**
- 始终对从外部存储检索的数据执行**输入验证**。这很重要，因为这些数据来自不受信任的来源。
- 不建议将可执行文件或 class 文件存放在外部存储以供动态加载。
- 如果应用必须从外部存储检索可执行文件，确保这些文件在动态加载前已**签名并进行加密验证**。这一步对维护应用的安全完整性至关重要。

外部存储可在 /storage/emulated/0、/sdcard、/mnt/sdcard 访问

> [!TIP]
> 从 Android 4.4（**API 17**）开始，SD 卡有一个目录结构，**将应用的访问限制到专门为该应用分配的目录**。这可以防止恶意应用读取或写入其他应用的文件。

**以明文存储的敏感数据**

- **Shared preferences**：Android 允许每个应用轻松地在路径 `/data/data/<packagename>/shared_prefs/` 中保存 xml 文件，有时可以在该文件夹中发现以明文存储的敏感信息。
- **Databases**：Android 允许每个应用轻松地在路径 `/data/data/<packagename>/databases/` 中保存 sqlite 数据库，有时可以在该文件夹中发现以明文存储的敏感信息。

### Broken TLS

**Accept All Certificates**

出于某些原因，开发者有时会接受所有证书，例如即使主机名不匹配也接受，代码示例可能如下所示：
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
一种很好的测试方法是尝试使用像 Burp 这样的代理捕获流量，而不在设备内授权 Burp CA。你也可以用 Burp 为不同的主机名生成证书并使用它。

### 加密不当

**不良的密钥管理流程**

一些开发者把敏感数据保存在本地存储中，并使用硬编码/可预测的密钥在代码中进行加密。这不应该这样做，因为一些逆向工程可能允许攻击者提取机密信息。

**使用不安全和/或已弃用的算法**

开发者不应使用 **deprecated algorithms** 来执行授权 **checks**、**store** 或 **send** 数据。这些算法的一些例子有：RC4、MD4、MD5、SHA1……例如，如果使用 **hashes** 来存储密码，应该使用带 salt 的抗暴力破解 hash 算法。

### 其他检查

- 建议 **对 APK 进行混淆**，以增加逆向工程者的工作难度。
- 如果应用是敏感的（例如银行应用），应进行自身检查以确定设备是否已 root，并据此采取相应措施。
- 如果应用是敏感的（例如银行应用），应检查是否正在使用 emulator。
- 如果应用是敏感的（例如银行应用），应**在执行前检查自身完整性**以确认是否被修改。
- 使用 [**APKiD**](https://github.com/rednaga/APKiD) 来检查用于构建 APK 的 compiler/packer/obfuscator

### React Native Application

阅读以下页面以了解如何轻松访问 React 应用的 javascript 代码：


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

阅读以下页面以了解如何轻松访问 xamarin 应用的 C# 代码：


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

根据这篇 [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/)，superpacked 是一种 Meta 算法，它将应用的内容压缩到单个文件中。该博文讨论了创建一个可以解压这类应用的应用的可能性……以及一种更快的方法，涉及**执行应用并从文件系统收集解压后的文件。**

### 自动化静态代码分析

工具 [**mariana-trench**](https://github.com/facebook/mariana-trench) 能通过**扫描**应用的**代码**来发现**漏洞**。该工具包含一系列的 **known sources**（指示工具输入由用户控制的**位置**）、**sinks**（指示工具潜在危险的**位置**，恶意用户输入可能在这些位置造成损害）和 **rules**。这些 rules 指示哪些 **sources-sinks** 的组合表示存在漏洞。

有了这些信息，**mariana-trench 会审阅代码并发现其中可能的漏洞**。

### Secrets leaked

应用可能包含 secrets（API keys、passwords、hidden urls、subdomains……）在其中，你可能能够发现它们。你可以使用诸如 [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks) 的工具。

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### 其他有趣的函数

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)
- In-memory native code execution via JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **其他技巧**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## 动态分析

> First of all, you need an environment where you can install the application and all the environment (Burp CA cert, Drozer and Frida mainly). Therefore, a rooted device (emulated or not) is extremely recommended.

### 在线动态分析

你可以在这里创建一个 **free account**: [https://appetize.io/](https://appetize.io)。该平台允许你 **upload** 和 **execute** APKs，因此对于查看 apk 的行为很有用。

你甚至可以在网页中 **查看应用的日志** 并通过 **adb** 连接。

![](<../../images/image (831).png>)

借助 ADB 连接，你可以在 emulators 内使用 **Drozer** 和 **Frida**。

### 本地动态分析

#### 使用 emulator

- [**Android Studio**](https://developer.android.com/studio)（你可以创建 **x86** 和 **arm** 设备，根据 [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html) **最新 x86** 版本 **支持 ARM libraries**，无需使用较慢的 arm emulator）。
- 在此页面学习如何设置：


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **（免费版：Personal Edition，需要创建账户。建议** 下载 **包含** _VirtualBox_ 的版本以避免潜在错误。）**
- [**Nox**](https://es.bignox.com)（免费，但不支持 Frida 或 Drozer）。

> [!TIP]
> 在任何平台上创建新的 emulator 时请记住，屏幕越大，emulator 运行得越慢。因此尽量选择小屏幕。

要在 Genymotion 中**安装 google services**（例如 AppStore），需要点击下图中标记为红色的按钮：

![](<../../images/image (277).png>)

另外，请注意在 **Genymotion 的 Android VM 配置** 中可以选择 **Bridge Network mode**（如果你要从另一台有相关工具的 VM 连接到 Android VM，这会很有用）。

#### 使用真实设备

你需要激活 **debugging** 选项，如果能 **root** 设备会更好：

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Once you have installed the application, the first thing you should do is to try it and investigate what does it do, how does it work and get comfortable with it.\
> I will suggest to **perform this initial dynamic analysis using MobSF dynamic analysis + pidcat**, so we will be able to **learn how the application works** while MobSF **captures** a lot of **interesting** **data** you can review later on.

Magisk/Zygisk 快速笔记（在 Pixel 设备上推荐）
- 使用 Magisk 应用 patch boot.img 并通过 fastboot flash 获取 systemless root
- 启用 Zygisk + DenyList 以隐藏 root；在需要更强隐藏时考虑 LSPosed/Shamiko
- 保留原始 boot.img 以便从 OTA 恢复；每次 OTA 后重新 patch
- 对于屏幕镜像，在主机上使用 scrcpy

### Unintended Data Leakage

**Logging**

开发者应谨慎避免将 **debugging information** 公开暴露，因为这可能导致敏感数据 leak。推荐使用工具 [**pidcat**](https://github.com/JakeWharton/pidcat) 和 `adb logcat` 来监控应用日志，以识别并保护敏感信息。**Pidcat** 因其易用性和可读性而受青睐。

> [!WARNING]
> 注意，从 **later newer than Android 4.0** 开始，**应用只能访问自己的日志**。因此应用无法访问其他应用的日志。\
> 无论如何，仍建议 **不要记录敏感信息**。

**Copy/Paste Buffer Caching**

Android 的 **clipboard-based** 框架支持应用间复制粘贴功能，但也存在风险，因为**其他应用**可以**访问**剪贴板，可能暴露敏感数据。对于应用中的敏感区域（如信用卡信息），务必**禁用复制/粘贴**功能以防止数据泄露。

**Crash Logs**

如果应用 **崩溃** 并且 **保存日志**，这些日志可能会帮助攻击者，尤其是在应用无法被逆向工程时。为降低此风险，应避免在崩溃时记录过多信息；如果必须通过网络传输日志，请确保通过 SSL 通道发送以保证安全。

作为 pentester，**尝试查看这些日志**。

**Analytics Data Sent To 3rd Parties**

应用通常会集成类似 Google Adsense 的服务，这些服务如果被开发者错误实现，可能会无意中 **leak** 敏感数据。要识别潜在的数据泄露，建议**拦截应用的流量**并检查是否有敏感信息被发送给第三方服务。

### SQLite DBs

大多数应用会使用 **internal SQLite databases** 来保存信息。在进行 pentest 时，请查看创建的 **databases**、**表名** 和 **列名** 以及所有保存的数据，因为你可能会发现 **敏感信息**（这将构成漏洞）。\
数据库应位于 `/data/data/the.package.name/databases`，例如 `/data/data/com.mwr.example.sieve/databases`

如果数据库保存机密信息并且是 **encrypted**，但你能在应用中**找到密码**，这仍然是一个 **漏洞**。

使用 `.tables` 列出表，使用 `.schema <table_name>` 列出表的列。

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer 是一个有用的工具，能够**利用 exported activities、exported services 和 Content Providers**，你将在下面的章节中学习到这些内容。

### 利用已导出的 Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
还要记住，activity 的代码在 **`onCreate`** 方法中开始执行。

**Authorisation bypass**

当一个 Activity 被导出（exported）时，你可以从外部应用调用其界面。因此，如果一个包含 **敏感信息** 的 activity 被 **exported**，你可能能够**绕过****认证**机制**访问它**。

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

你也可以通过 adb 启动一个 exported activity：

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF 会将 activity 中将 `android:launchMode` 设置为 _**singleTask/singleInstance**_ 的用法检测为恶意，但根据 [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750)，显然这只在旧版本（API versions < 21）上危险。

> [!TIP]
> 注意，authorisation bypass 并不总是意味着存在漏洞，这取决于绕过的方式以及暴露了哪些信息。

**Sensitive information leakage**

**Activities can also return results**。如果你发现一个 exported 且未受保护的 activity 调用了 **`setResult`** 方法并**返回敏感信息**，则会发生 sensitive information leakage。

#### Tapjacking

如果没有防止 Tapjacking，你可以滥用该 exported activity 使 **用户执行意外操作**。关于 [**Tapjacking 是什么，请点击此处**](#tapjacking) 的更多信息。

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**如果你想回顾什么是 Content Provider，请阅读此处。**](android-applications-basics.md#content-provider)\
Content providers 基本上用于 **共享数据**。如果应用提供了 content providers，你可能能够从中 **提取敏感** 数据。还值得测试可能的 **SQL injections** 和 **Path Traversals**，因为它们可能存在漏洞。

[**学习如何使用 Drozer 利用 Content Providers。**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**如果你想回顾什么是 Service，请阅读此处。**](android-applications-basics.md#services)\
记住，Service 的操作在方法 `onStartCommand` 中开始。

Service 基本上是可以 **接收数据**、**处理** 它并**返回**（或不返回）响应的东西。因此，如果一个应用在导出 exporting 一些 services，你应该 **检查** 其 **代码** 以了解它在做什么，并对其进行 **动态** 测试以提取机密信息、绕过认证措施……\
[**学习如何使用 Drozer 利用 Services。**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**如果你想回顾什么是 Broadcast Receiver，请阅读此处。**](android-applications-basics.md#broadcast-receivers)\
记住，Broadcast Receiver 的操作在方法 `onReceive` 中开始。

Broadcast receiver 会等待某种类型的消息。根据接收器如何处理消息，它可能存在漏洞。\
[**学习如何使用 Drozer 利用 Broadcast Receivers。**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

你可以手动查找 deep links，使用像 MobSF 这样的工具或像 [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py) 这样的脚本。\
你可以使用 **adb** 或 **浏览器** 打开已声明的 **scheme**：
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_请注意，你可以 **省略包名**，移动设备会自动调用应该打开该链接的应用。_
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**执行的代码**

为了找到 **code that will be executed in the App**，转到由 deeplink 调用的 activity 并搜索函数 **`onNewIntent`**。

![](<../../images/image (436) (1) (1) (1).png>)

**敏感信息**

每次发现 deep link 时，都要检查 **它是否没有通过 URL 参数接收敏感数据（比如密码）**，因为任何其他应用都可能 **冒充该 deep link 并窃取这些数据！**

**路径中的参数**

你 **还必须检查是否有 deep link 在 URL 的 path 中使用参数**，例如：`https://api.example.com/v1/users/{username}`，在这种情况下你可以通过路径遍历强制访问类似于：`example://app/users?username=../../unwanted-endpoint%3fparam=value`。\
注意，如果你在应用中找到正确的端点，可能可以导致 **Open Redirect**（如果 path 的一部分被用作域名）、**account takeover**（如果可以在没有 CSRF token 的情况下修改用户详情并且易受影响的端点使用了正确的方法）以及任何其他漏洞。More [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**更多示例**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### 传输层检查和验证失败

- **Certificates 并不总是被 Android 应用正确检查。** 这些应用常常忽略警告并接受 self-signed certificates，或者在某些情况下回退到使用 HTTP 连接。
- **在 SSL/TLS handshake 期间的协商有时很脆弱，** 使用不安全的 cipher suites。这使得连接易受 man-in-the-middle (MITM) 攻击，允许攻击者解密数据。
- **Leakage of private information** 是一种风险，当应用使用安全通道进行认证但随后在其他事务中通过非安全通道通信时，会出现这种情况。这种做法无法保护诸如会话 cookie 或用户详细信息等敏感数据，免受恶意实体的拦截。

#### 证书验证

我们将重点关注 **certificate verification**。必须验证服务器证书的完整性以增强安全性。这一点非常关键，因为不安全的 TLS 配置和在未加密通道上发送敏感数据可能带来重大风险。关于验证服务器证书和修复漏洞的详细步骤，[**this resource**](https://manifestsecurity.com/android-application-security-part-10/) 提供了全面的指导。

#### SSL Pinning

SSL Pinning 是一种安全措施，应用会将服务器的证书与存储在应用内的已知副本进行比对以进行验证。该方法对于防止 MITM 攻击至关重要。对于处理敏感信息的应用，强烈建议实现 SSL Pinning。

#### 流量检查

要检查 HTTP 流量，需要 **安装代理工具的证书**（例如 Burp）。如果不安装该证书，加密流量可能无法通过代理可见。有关安装自定义 CA 证书的指南，请[**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine)。

针对 **API Level 24 and above** 的应用需要修改 Network Security Config 以接受代理的 CA 证书。此步骤对于检查加密流量至关重要。有关修改 Network Security Config 的说明，请[**refer to this tutorial**](make-apk-accept-ca-certificate.md)。

如果正在使用 **Flutter**，你需要按照 [**this page**](flutter.md) 中的说明进行操作。This is becasue，单纯将证书添加到证书库中并不起作用，因为 Flutter 有它自己的有效 CA 列表。

#### SSL/TLS pinning 的静态检测

在尝试运行时绕过之前，先快速映射 APK 中强制执行 pinning 的位置。静态发现可帮助你规划 hooks/patches 并集中在正确的代码路径上。

Tool: SSLPinDetect
- 开源的静态分析工具，将 APK 反编译为 Smali（通过 apktool），并扫描精心挑选的 SSL/TLS pinning 实现的正则模式。
- 报告每个匹配项的确切文件路径、行号和代码片段。
- 覆盖常见框架和自定义代码路径：OkHttp CertificatePinner、custom javax.net.ssl.X509TrustManager.checkServerTrusted、SSLContext.init with custom TrustManagers/KeyManagers，以及 Network Security Config XML pins。

安装
- 前置要求：Python >= 3.8、Java on PATH、apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
用法
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
示例模式规则 (JSON)
使用或扩展 signatures 来检测专有/自定义 pinning 风格。你可以加载自己的 JSON 并进行大规模扫描。
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes and tips
- 通过多线程和 memory-mapped I/O 对大型应用进行快速扫描；预编译的 regex 可降低开销/误报。
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- 接下来应优先排查的典型检测目标：
- OkHttp：CertificatePinner 使用、setCertificatePinner、okhttp3/okhttp 包引用
- 自定义 TrustManagers：javax.net.ssl.X509TrustManager、checkServerTrusted 覆写
- 自定义 SSL 上下文：SSLContext.getInstance + SSLContext.init 与自定义 managers
- 在 res/xml network security config 和 manifest 中的声明式 pins
- 使用匹配到的位置在动态测试前规划 Frida hooks、静态补丁或配置审查。



#### 绕过 SSL Pinning

当实现了 SSL Pinning 时，为了检查 HTTPS 流量需要绕过它。可用的方法有多种：

- 使用 [**apk-mitm**](https://github.com/shroudedcode/apk-mitm) 自动**修改** **apk** 来**绕过** SSLPinning。这个选项的最大优点是你不需要 root 来绕过 SSL Pinning，但你需要删除应用并重新安装新的应用，而且这并不总是有效。
- 你可以使用 **Frida**（下文讨论）来绕过此保护。这里有一篇使用 Burp+Frida+Genymotion 的指南： [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- 你也可以尝试使用 [**objection**](frida-tutorial/objection-tutorial.md)** 自动绕过 SSL Pinning**： `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- 你也可以尝试使用 **MobSF dynamic analysis**（下文解释）**自动绕过 SSL Pinning**
- 如果你仍然认为有一些流量没有被捕获，可以尝试使用 iptables **将流量转发到 burp**。阅读这篇博客： [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### 查找常见 Web 漏洞

也应在应用中搜索常见的 Web 漏洞。关于识别和缓解这些漏洞的详细信息超出本摘要范围，但在其他地方有广泛讨论。

### Frida

[Frida](https://www.frida.re) 是一个面向开发者、逆向工程师和安全研究人员的动态插装工具包。\
**你可以访问正在运行的应用并在运行时 hook 方法，以改变行为、变更值、提取值、执行不同的代码……**\
如果你想对 Android 应用进行 pentest，你需要知道如何使用 Frida。

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Some "GUI" for actions with Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- You can find some Awesome Frida scripts here: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- 尝试按照 [https://erfur.github.io/blog/dev/code-injection-without-ptrace] 中所示，通过加载 Frida 来绕过 anti-debugging / anti-frida 机制（工具 [linjector](https://github.com/erfur/linjector-rs)）

#### Anti-instrumentation & SSL pinning 绕过工作流程

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

检查应用是否在内存中存储了不应存储的敏感信息，例如密码或助记词。

使用 [**Fridump3**](https://github.com/rootbsd/fridump3) 可以通过以下方式导出应用内存：
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
这会将内存转储到 ./dump 文件夹，你可以在那里用类似下面的 grep：
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Keystore 中的敏感数据**

在 Android 中，Keystore 是存储敏感数据的最佳位置，但在拥有足够权限的情况下仍然有可能被访问。由于应用往往在这里以 **sensitive data in clear text** 的形式存储数据，pentests 应以 root user 身份检查这一点，否则拥有 physical access 设备的人可能能够窃取这些数据。

即使应用将数据存放在 Keystore 中，数据也应该被加密。

要访问 keystore 内的数据，你可以使用这个 Frida script: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

使用下面的 Frida 脚本，可能可以 **bypass fingerprint authentication**，绕过 Android 应用为 **保护某些敏感区域** 而执行的认证：
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **后台图像**

当你将应用置于后台时，Android 会存储应用的**快照**，这样当它恢复到前台时，系统会先加载该图片，再加载应用，从而看起来应用启动更快。

但是，如果该快照包含**敏感信息**，有权限访问该快照的人可能会**窃取这些信息**（注意：需要 root 权限才能访问）。

这些快照通常存储在：**`/data/system_ce/0/snapshots`**

Android 提供了一种方法，通过设置布局参数 **FLAG_SECURE** 来**防止截屏**。使用该标志后，窗口内容将被视为安全，从而防止其出现在截图中或在非安全显示设备上被查看。
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android 应用 分析器**

此工具可在动态分析期间帮助你管理不同的工具: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

开发者经常创建像 activities、services 和 broadcast receivers 这样的代理组件来处理这些 Intents，并将它们传递给诸如 `startActivity(...)` 或 `sendBroadcast(...)` 这样的调用，这可能存在风险。

危险在于允许攻击者通过误导这些 Intents 来触发未导出的应用组件或访问敏感的 content providers。一个显著的例子是 `WebView` 组件通过 `Intent.parseUri(...)` 将 URL 转换为 `Intent` 对象并执行它们，可能导致恶意 Intent 注入。

### 重要要点

- **Intent Injection** 类似于 web 的 Open Redirect 问题。
- 利用方式涉及将 `Intent` 对象作为 extras 传递，这些对象可被重定向以执行不安全的操作。
- 它可能将未导出组件和 content providers 暴露给攻击者。
- `WebView` 将 URL 转换为 `Intent` 的行为可能促成未预期的操作。

### Android 客户端注入及其他

你可能在 Web 安全中见过这类漏洞。在 Android 应用中需要特别注意以下漏洞：

- **SQL Injection:** 处理动态查询或 Content-Providers 时，确保使用参数化查询。
- **JavaScript Injection (XSS):** 确认任何 WebViews 的 JavaScript 和 Plugin 支持已被禁用（默认禁用）。 [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews 应禁用对文件系统的访问（默认启用） - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: 在若干情况下，当 android 应用结束会话时，cookie 未被撤销，甚至可能被保存到磁盘
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## 自动化分析

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**静态分析**

![](<../../images/image (866).png>)

通过友好的 web 前端对应用进行漏洞评估。你也可以执行动态分析（但需要准备环境）。
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Assisted Dynamic analysis with MobSF

**MobSF** can also be very helpful for **dynamic analysis** in **Android**, but in that case you will need to install MobSF and **genymotion** in your host (a VM or Docker won't work). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
The **MobSF dynamic analyser** can:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). All of this is done automatically except for the screenshots, you need to press when you want a screenshot or you need to press "**Exported Activity Tester**" to obtain screenshots of all the exported activities.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: It will print all the loaded classes
- **Capture Strings**: It will print all the capture strings while using the application (super noisy)
- **Capture String Comparisons**: Could be very useful. It will **show the 2 strings being compared** and if the result was True or False.
- **Enumerate Class Methods**: Put the class name (like "java.io.File") and it will print all the methods of the class.
- **Search Class Pattern**: Search classes by pattern
- **Trace Class Methods**: **Trace** a **whole class** (see inputs and outputs of all methods of th class). Remember that by default MobSF traces several interesting Android Api methods.

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf also brings you a shell with some **adb** commands, **MobSF commands**, and common **shell** **commands** at the bottom of the dynamic analysis page. Some interesting commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP 工具**

When http traffic is capture you can see an ugly view of the captured traffic on "**HTTP(S) Traffic**" bottom or a nicer view in "**Start HTTPTools**" green bottom. From the second option, you can **send** the **captured requests** to **proxies** like Burp or Owasp ZAP.\
要做到这一点，_power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> 按下 "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080))。

Once you finish the dynamic analysis with MobSF you can press on "**Start Web API Fuzzer**" to **fuzz http requests** an look for vulnerabilities.
完成 MobSF 的 dynamic analysis 后，你可以点击 "**Start Web API Fuzzer**" 来 **fuzz http requests** 并查找漏洞。

> [!TIP]
> After performing a dynamic analysis with MobSF the proxy settings me be misconfigured and you won't be able to fix them from the GUI. You can fix the proxy settings by doing:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### 使用 Inspeckage 进行辅助 dynamic analysis

You can get the tool from [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
该工具会使用一些 **Hooks**，在你执行 **dynamic analysis** 时让你了解 **应用中发生了什么**。

### [Yaazhini](https://www.vegabird.com/yaazhini/)

This is a **great tool to perform static analysis with a GUI**
这是一个通过 GUI 执行 **static analysis** 的优秀工具

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

This tool is designed to look for several **security related Android application vulnerabilities**, either in **source code** or **packaged APKs**. The tool is also **capable of creating a "Proof-of-Concept" deployable APK** and **ADB commands**, to exploit some of the found vulnerabilities (Exposed activities, intents, tapjacking...). As with Drozer, there is no need to root the test device.
该工具旨在查找多种 **security related Android application vulnerabilities**，可针对 **source code** 或 **packaged APKs** 进行检测。该工具还可以生成 **capable of creating a "Proof-of-Concept" deployable APK** 和 **ADB commands**，用于利用某些发现的漏洞（Exposed activities、intents、tapjacking...）。与 Drozer 类似，无需对测试设备进行 root。
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- 显示所有提取的文件，便于参考
- 自动将 APK 文件反编译为 Java 和 Smali 格式
- 分析 AndroidManifest.xml 以查找常见漏洞和行为
- 对静态源代码进行分析，以发现常见漏洞和行为
- 设备信息
- 以及更多
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER 是一个命令行应用，可在 Windows、MacOS X 和 Linux 上使用，用于分析 _.apk_ 文件以查找漏洞。它通过解压 APK 并应用一系列规则来检测这些漏洞。

所有规则集中在 `rules.json` 文件中，每个公司或测试人员都可以创建自己的规则以分析他们需要的内容。

可从 [download page](https://superanalyzer.rocks/download.html) 下载最新的二进制文件。
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn 是一个 **crossplatform** 工具，帮助 developers、bugbounty hunters 和 ethical hackers 在移动应用上执行 [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis)。

其概念是你将移动应用文件（.apk 或 .ipa 文件）拖放到 StaCoAn 应用上，它会为你生成一个可视化且便于携带的报告。你可以调整设置和 wordlists 来获得定制化的体验。

下载[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework 是一个 Android 漏洞分析系统，帮助开发者或 hackers 发现 Android 应用中的潜在安全漏洞。\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** 是一个工具，主要用于检测并提醒用户 Android 应用可能的恶意行为。

检测通过使用 [`androguard`](https://github.com/androguard/androguard) 库对应用的 Dalvik bytecode（以 **Smali** 表示）进行 **static analysis** 来完成。

该工具查找 **“恶意”应用的常见行为**，例如：Telephony identifiers exfiltration、Audio/video flow interception、PIM data modification、Arbitrary code execution 等。
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** 是一个 **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework。它将常用的移动应用逆向工程与分析工具汇集在一起，帮助针对 OWASP 移动安全威胁 对移动应用进行测试。其目标是让移动应用开发者和安全专业人员更容易、更友好地完成这项工作。

It is able to:

- 使用不同的工具提取 Java 和 Smali 代码
- 使用以下工具分析 APK: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- 使用正则表达式从 APK 中提取敏感信息。
- 分析 Manifest。
- 使用以下工具分析发现的域名: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- 通过 [apk-deguard.com](http://www.apk-deguard.com) 对 APK 进行反混淆。

### Koodous

用于检测恶意软件: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

请注意，取决于你用于混淆代码的服务和配置，敏感信息（secrets）可能会被混淆，也可能不会。

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** 是一个开源的命令行工具，用于缩小、优化和混淆 Java 代码。它能够优化字节码，并检测和移除未使用的指令。ProGuard 是自由软件，并根据 GNU General Public License 第2版 分发。

ProGuard 随 Android SDK 一起分发，并在以 release 模式构建应用时运行。

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(根据该指南) 我们上次检查时，Dexguard 的运行模式是：

- 将资源作为 InputStream 加载；
- 将结果传给继承自 FilterInputStream 的类以解密；
- 做一些无用的混淆以浪费逆向工程者几分钟时间；
- 将解密后的结果传给 ZipInputStream 来获取 DEX 文件；
- 最后使用 `loadDex` 方法将得到的 DEX 作为 Resource 加载。

### [DeGuard](http://apk-deguard.com)

**DeGuard 逆转 Android 混淆工具执行的混淆过程。这使得多种安全分析成为可能，包括代码检查和库识别。**

你可以将混淆后的 APK 上传到他们的平台。

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

It is a **generic android deobfuscator.** Simplify **virtually executes an app** to understand its behavior and then **tries to optimize the code** so it behaves identically but is easier for a human to understand. Each optimization type is simple and generic, so it doesn't matter what the specific type of obfuscation is used.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD gives you information about **how an APK was made**. It identifies many **compilers**, **packers**, **obfuscators**, and other weird stuff. It's [_PEiD_](https://www.aldeid.com/wiki/PEiD) for Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b 是一个基于 ubuntu-mate 的 Android 安全虚拟机，包含来自不同安全极客和研究人员的最新框架、教程和用于逆向工程与恶意软件分析的实验集合。

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) 这是一个很棒的资源列表
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android 快速课程
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
