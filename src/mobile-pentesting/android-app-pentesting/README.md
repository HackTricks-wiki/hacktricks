# Android 应用程序 Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android 应用基础

强烈建议先阅读此页面，以了解与 Android 安全相关的 **最重要的部分** 以及 Android 应用中 **最危险的组件**：


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

这是连接 Android 设备（模拟或真实设备）所需的主要工具。\
**ADB** 允许从计算机通过 **USB** 或 **Network** 控制设备。该工具支持双向 **复制** 文件、**安装** 和 **卸载** 应用、**执行** shell 命令、**备份** 数据、**读取** 日志等功能。

查看以下 [**ADB Commands**](adb-commands.md) 列表以学习如何使用 adb。

## Smali

有时对应用的代码进行修改以获取 **隐藏的信息**（例如被严重混淆的密码或 flags）是有意义的。此时，反编译 apk、修改代码并重新编译可能非常有用。\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md)。这可以作为在即将进行的 dynamic analysis 中若干测试的 **替代方法**。请 **始终记住这一可能性**。

## Other interesting tricks

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **下载 APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- 从设备提取 APK:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- 使用 [APKEditor](https://github.com/REAndroid/APKEditor) 合并所有 splits 和 base apks：
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## 案例研究与漏洞


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Static Analysis

首先，分析 APK 时你应该使用反编译器**查看 Java 代码**。\
请, [**read here to find information about different available decompilers**](apk-decompilers.md).

### Looking for interesting Info

仅仅查看 APK 的 **strings** 就可以搜索 **passwords**、**URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep))、**api** keys、**encryption**、**bluetooth uuids**、**tokens** 以及其他任何有趣的信息……甚至要留意代码执行的 **backdoors** 或认证后门（应用中硬编码的管理员凭据）。

**Firebase**

特别注意 **Firebase** URL 并检查其是否配置不当。[More information about whats is FIrebase and how to exploit it here.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Basic understanding of the application - Manifest.xml, strings.xml

**检查应用的 _Manifest.xml_ 和 **_strings.xml_** 文件可以揭示潜在的安全漏洞**。这些文件可以通过反编译器访问，也可以将 APK 重命名为 .zip 然后解压来获取。

从 **Manifest.xml** 中可识别的**漏洞**包括：

- **Debuggable Applications**: 如果在 _Manifest.xml_ 中将应用设置为 debuggable（`debuggable="true"`），则存在风险，因为这允许连接并可能被利用。有关如何利用 debuggable 应用的更多信息，请参考关于在设备上查找和利用 debuggable applications 的教程。
- **Backup Settings**: 对于处理敏感信息的应用，应显式设置 `android:allowBackup="false"`，以防止通过 adb 在 usb debugging 启用时进行未授权的数据备份。
- **Network Security**: 自定义网络安全配置（`android:networkSecurityConfig="@xml/network_security_config"`）位于 _res/xml/_ 中，可指定证书 pin、HTTP 流量设置等安全细节。例如，可以为特定域允许 HTTP 流量。
- **Exported Activities and Services**: 在 manifest 中识别 exported activities 和 services 可以突出可能被滥用的组件。在动态测试阶段的进一步分析可以揭示如何利用这些组件。
- **Content Providers and FileProviders**: 暴露的 content providers 可能允许未授权访问或修改数据。还应仔细检查 FileProviders 的配置。
- **Broadcast Receivers and URL Schemes**: 这些组件可能被用来进行利用，尤其要关注 URL scheme 的处理方式以防止输入相关漏洞。
- **SDK Versions**: `minSdkVersion`、`targetSDKVersion` 和 `maxSdkVersion` 属性指示支持的 Android 版本，强调不应支持过时且存在漏洞的 Android 版本以确保安全性。

从 **strings.xml** 文件中，可以发现敏感信息，如 API keys、自定义 schema 以及开发者备注，说明需要仔细检查这些资源。

### Tapjacking

**Tapjacking** 是一种攻击，攻击者启动一个**恶意** **应用** 并**将其置于受害者应用之上**。一旦它遮挡了受害应用，其用户界面设计会诱导用户与其交互，同时将交互传递给受害应用。\
实际上，它是**让用户无法察觉自己实际上是在对受害应用执行操作**。

更多信息请见：


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

如果一个 **activity** 的 **`launchMode`** 设置为 **`singleTask` 且未定义 `taskAffinity`**，则会容易受到 Task Hijacking。也就是说，如果在真实应用之前安装并启动了另一个应用，该应用可能**劫持真实应用的任务**（用户会以为自己在使用真实应用，实际上在与**恶意应用**交互）。

更多信息见：


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Insecure data storage

**Internal Storage**

在 Android 中，存储在 **internal** 存储中的文件设计为仅可被**创建它们的应用**访问。这一安全措施由 Android 操作系统强制执行，通常足以满足大多数应用的安全需求。然而，开发者有时会使用诸如 `MODE_WORLD_READABLE` 和 `MODE_WORLD_WRITABLE` 的模式来**允许**不同应用之间**共享**文件。但这些模式**不会限制**其他应用（包括潜在的恶意应用）对这些文件的访问。

1. **Static Analysis:**
- **检查** 是否使用了 `MODE_WORLD_READABLE` 和 `MODE_WORLD_WRITABLE`。这些模式**可能会暴露**文件，导致**非预期或未授权访问**。
2. **Dynamic Analysis:**
- **验证** 应用创建的文件的**权限设置**。特别是，**检查**是否有文件被设置为可被全局读取或写入。这会带来重大安全风险，因为这将允许安装在设备上的**任何应用**（无论来源或目的）**读取或修改**这些文件。

**External Storage**

处理外部存储（如 SD 卡）上的文件时，应采取以下预防措施：

1. **可访问性**:
- 外部存储上的文件是**全局可读可写**的。这意味着任何应用或用户都可以访问这些文件。
2. **安全顾虑**:
- 鉴于访问便利，建议**不要将敏感信息存储在外部存储上**。
- 外部存储可以被移除或被任何应用访问，因此安全性较低。
3. **处理来自外部存储的数据**:
- 从外部存储读取数据时**始终进行输入验证**。这是关键，因为这些数据来自不受信任的来源。
- 强烈不建议将可执行文件或 class 文件存放在外部存储以供动态加载。
- 如果应用必须从外部存储检索可执行文件，确保这些文件在动态加载前**已签名并经过加密校验**。此步骤对于维护应用的安全完整性至关重要。

外部存储可在 /storage/emulated/0 , /sdcard , /mnt/sdcard 访问

> [!TIP]
> 从 Android 4.4（**API 17**）开始，SD 卡有一个目录结构，**限制应用只能访问专属于该应用的目录**。这可防止恶意应用获取对其他应用文件的读写访问。

**以明文存储的敏感数据**

- **Shared preferences**: Android 允许每个应用轻松将 xml 文件保存在路径 `/data/data/<packagename>/shared_prefs/`，有时可以在该文件夹中发现明文的敏感信息。
- **Databases**: Android 允许每个应用轻松将 sqlite 数据库存储在路径 `/data/data/<packagename>/databases/`，有时可以在该文件夹中发现明文的敏感信息。

### Broken TLS

**Accept All Certificates**

有时开发者会接受所有证书，即使例如 hostname 不匹配，也会出现类似如下代码行：
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### 加密学缺陷

**密钥管理不当**

一些开发者将敏感数据保存在本地存储中，并使用硬编码/可预测的密钥进行加密。这不应该这样做，因为一些逆向工程可能允许攻击者提取机密信息。

**使用不安全和/或已废弃的算法**

开发者不应使用**已废弃的算法**来执行授权**检查**、**存储**或**发送**数据。这些算法中的一些有：RC4、MD4、MD5、SHA1……例如，如果使用**hashes**来存储密码，应使用对暴力破解具有抵抗力的哈希并加盐。

### 其他检查

- 建议**对 APK 进行混淆**，以增加逆向工程的难度。
- 如果应用是敏感应用（如银行应用），应执行**自己的检测来判断手机是否已 root**，并据此采取措施。
- 如果应用是敏感应用（如银行应用），应检测是否在**emulator**上运行。
- 如果应用是敏感应用（如银行应用），应**在执行前检查自身完整性**以判断是否被修改。
- 使用 [**APKiD**](https://github.com/rednaga/APKiD) 来检查构建 APK 时使用了哪个 compiler/packer/obfuscator

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

The tool [**mariana-trench**](https://github.com/facebook/mariana-trench) is capable of finding **vulnerabilities** by **scanning** the **code** of the application. This tool contains a series of **known sources** (that indicates to the tool the **places** where the **input** is **controlled by the user**), **sinks** (which indicates to the tool **dangerous** **places** where malicious user input could cause damages) and **rules**. These rules indicates the **combination** of **sources-sinks** that indicates a vulnerability.

With this knowledge, **mariana-trench will review the code and find possible vulnerabilities on it**.

### Secrets leaked

An application may contain secrets (API keys, passwords, hidden urls, subdomains...) inside of it that you might be able to discover. You could us a tool such as [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### 其他有趣的函数

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)

### **其他技巧**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## 动态分析

> 首先，你需要一个可以安装应用并配置好所需环境（主要是 Burp CA cert、Drozer 和 Frida）的环境。因此，强烈建议使用已 root 的设备（无论是否为模拟器）。

### 在线动态分析

你可以在 [https://appetize.io/](https://appetize.io/) 创建一个**免费账号**。该平台允许你**上传**并**执行** APK，因此有助于观察 APK 的行为。

你甚至可以在网页中**查看应用的日志**并通过 **adb** 连接。

![](<../../images/image (831).png>)

借助 ADB 连接，你可以在模拟器内使用 **Drozer** 和 **Frida**。

### 本地动态分析

#### 使用模拟器

- [**Android Studio**](https://developer.android.com/studio)（你可以创建 **x86** 和 **arm** 设备，并且根据[**此处**](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html) **最新 x86** 版本 **支持 ARM 库**，无需使用缓慢的 ARM 模拟器）。
- 在此页面学习如何设置：


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **（免费版：Personal Edition，需要创建账号。建议**下载**包含**VirtualBox**的版本以避免潜在错误。）**
- [**Nox**](https://es.bignox.com)（免费，但不支持 Frida 或 Drozer）。

> [!TIP]
> 在任何平台创建新模拟器时，请记住屏幕越大，模拟器运行越慢。因此尽可能选择小屏幕。

要在 Genymotion 中**安装 google services**（如 AppStore），需要点击下图中红色标记的按钮：

![](<../../images/image (277).png>)

另外，请注意在 **Genymotion 的 Android VM 配置** 中可以选择 **Bridge Network mode**（如果你要从另一个带有工具的 VM 连接到该 Android VM，这会很有用）。

#### 使用实体设备

你需要激活**调试**选项，如果能**root**设备会更好：

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> 一旦安装了应用，第一件事应该是尝试使用它，调查它的行为、工作方式并熟悉它。\
> 建议使用 MobSF dynamic analysis + pidcat 执行此初步动态分析，这样我们在学习应用如何工作的同时，MobSF 会**捕获**许多稍后可以查看的**有趣数据**。

### 非预期的数据泄露

**日志记录**

开发者应谨慎避免公开暴露**调试信息**，因为这可能导致敏感数据泄露。推荐使用工具 [**pidcat**](https://github.com/JakeWharton/pidcat) 和 `adb logcat` 来监控应用日志，以识别并保护敏感信息。**Pidcat** 因其易用性和可读性而更受欢迎。

> [!WARNING]
> 请注意，从**Android 4.0 及更高版本**开始，**应用只能访问自身的日志**，因此无法访问其他应用的日志。\
> 无论如何，仍建议**不要记录敏感信息**。

**剪贴板缓冲**

Android 的**基于剪贴板**的框架支持应用间的复制粘贴功能，但存在风险，因为**其他应用**可以**访问**剪贴板，可能会暴露敏感数据。对于应用中的敏感部分（例如信用卡信息），应**禁用复制/粘贴**功能以防止数据泄露。

**崩溃日志**

如果应用**崩溃**并**保存日志**，这些日志可能会帮助攻击者，特别是在应用无法被逆向时。为降低风险，应避免在崩溃时记录日志；如果必须将日志通过网络传输，确保通过 SSL 通道发送以保证安全。

作为 pentester，**尝试查看这些日志**。

**发送给第三方的分析数据**

应用常常集成像 Google Adsense 这样的服务，如果开发者实现不当，可能会无意中**leak**敏感数据。要识别潜在的数据泄露，建议**拦截应用流量**并检查是否有敏感信息被发送到第三方服务。

### SQLite DBs

大多数应用会使用**内部 SQLite 数据库**来保存信息。在渗透测试期间，查看创建的**数据库**、**表名**和**列名**以及所有保存的数据，因为你可能会发现**敏感信息**（这将构成一个漏洞）。\
数据库应该位于 `/data/data/the.package.name/databases`，例如 `/data/data/com.mwr.example.sieve/databases`

如果数据库保存机密信息并且是 **encrypted b**ut you can **find** the **password** inside the application it's still a **vulnerability**.

使用 `.tables` 枚举表，使用 `.schema <table_name>` 枚举表的列。

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer is s useful tool to **exploit exported activities, exported services and Content Providers** as you will learn in the following sections.

### 利用已导出的 Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
也请记住，Activity 的代码从 **`onCreate`** 方法开始执行。

**Authorisation bypass**

当一个 Activity 被导出（exported）时，你可以从外部应用调用其界面。因此，如果一个包含**敏感信息**的 activity 被**导出**，你可能可以**绕过****认证**机制**访问**它。

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

你也可以通过 adb 启动一个已导出的 activity：

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> 注意：授权绕过不一定就是一个漏洞，这取决于绕过的工作原理以及暴露了哪些信息。

**Sensitive information leakage**

**Activities can also return results**。如果你能找到一个 exported 且未受保护的 activity 调用 **`setResult`** 方法并**返回敏感信息**，则会发生敏感信息泄露。

#### Tapjacking

如果没有防止 Tapjacking，你可以滥用已导出的 activity 使 **user perform unexpected actions**。有关更多信息，请参见 [**what is Tapjacking follow the link**](#tapjacking)。

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers 基本上用于 **share data**。如果一个 app 存在可用的 content providers，你可能能够从中 **extract sensitive** 数据。也建议测试可能存在漏洞的 **SQL injections** 和 **Path Traversals**。

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
记住，Service 的动作从 `onStartCommand` 方法开始。

Service 本质上是可以接收数据、处理数据并（可选地）返回响应的组件。因此，如果应用导出了一些 services，你应该检查其代码以了解其行为，并对其进行动态测试以提取机密信息、绕过认证措施等。\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
记住，Broadcast Receiver 的动作从 `onReceive` 方法开始。

广播接收器会等待某种类型的消息。取决于接收器如何处理该消息，它可能存在漏洞。\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

你可以手动查找 deep links，使用像 MobSF 这样的工具或像 [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py) 这样的脚本。\
你可以使用 **adb** 或 **浏览器** 打开已声明的 **scheme**：
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_请注意，您可以**省略包名**，手机会自动调用应打开该链接的应用。_
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**执行的代码**

为了找到应用中将被执行的**代码**, 转到 deeplink 所调用的 activity 并搜索函数 **`onNewIntent`**。

![](<../../images/image (436) (1) (1) (1).png>)

**敏感信息**

每次找到 deep link 时，检查**它不会通过 URL 参数接收敏感数据（例如密码）**，因为任何其他应用都可能**冒充该 deep link 并窃取这些数据！**

**Parameters in path**

你**还必须检查是否有 deep link 在 URL 的 path 内使用参数**，例如：`https://api.example.com/v1/users/{username}`，在这种情况下你可以通过访问类似 `example://app/users?username=../../unwanted-endpoint%3fparam=value` 来强制进行 path traversal。\
注意，如果你在应用内部找到正确的 endpoints，你可能能够触发一个 **Open Redirect**（如果路径的一部分被用作域名）、**account takeover**（如果你能在没有 CSRF token 的情况下修改用户详情且该 vuln endpoint 使用了正确的方法）以及其他任何 vuln。更多信息请见 [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### 传输层检查与验证失败

- **证书并不总是被正确检查**，Android 应用中常见忽略警告并接受 self-signed certificates，或在某些情况下退回使用 HTTP 连接。
- **SSL/TLS 握手期间的协商有时较弱**，使用不安全的 cipher suites。该漏洞使连接易受 man-in-the-middle (MITM) 攻击，允许攻击者解密数据。
- **Leakage of private information** 是一种风险，当应用使用安全通道进行认证但随后在其他事务上通过非安全通道通信时，会导致未能保护敏感数据（例如 session cookies 或用户信息）免遭恶意实体拦截。

#### 证书验证

我们将关注 **证书验证**。必须验证服务器证书的完整性以提高安全性。这一点至关重要，因为不安全的 TLS 配置和通过未加密通道传输敏感数据可能带来重大风险。有关验证服务器证书和修复漏洞的详细步骤，[**this resource**](https://manifestsecurity.com/android-application-security-part-10/) 提供了全面的指导。

#### SSL Pinning

SSL Pinning 是一种安全措施，应用将服务器证书与存储在应用中的已知副本进行比对。此方法对于防止 MITM 攻击至关重要。强烈建议在处理敏感信息的应用中实现 SSL Pinning。

#### 流量检查

要检查 HTTP 流量，需要**安装代理工具的证书**（例如 Burp）。如果不安装此证书，经过加密的流量可能无法通过代理可见。有关安装自定义 CA 证书的指南，[**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine)。

针对 **API Level 24 and above** 的应用需要修改 Network Security Config 以接受代理的 CA 证书。此步骤对于检查加密流量至关重要。有关修改 Network Security Config 的说明，[**refer to this tutorial**](make-apk-accept-ca-certificate.md)。

如果使用 **Flutter**，需要按照 [**this page**](flutter.md) 的说明操作。这是因为仅将证书添加到存储中不起作用，Flutter 有其自己的有效 CA 列表。

#### 静态检测 SSL/TLS pinning

在尝试运行时绕过之前，先快速映射 APK 中强制 pinning 的位置。静态发现有助于你规划 hooks/patches 并专注于正确的代码路径。

Tool: SSLPinDetect
- Open-source static-analysis utility that decompiles the APK to Smali (via apktool) and scans for curated regex patterns of SSL/TLS pinning implementations.
- Reports exact file path, line number, and a code snippet for each match.
- Covers common frameworks and custom code paths: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
使用
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
示例模式规则 (JSON)
使用或扩展 signatures 来检测专有/自定义 pinning 样式。你可以加载自己的 JSON 并进行大规模 scan。
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
注意事项和技巧
- 在大型应用上通过 multi-threading 和 memory-mapped I/O 进行快速扫描；预编译的 regex 可以减少开销/误报。
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- 接下来需要分流的典型检测目标：
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Declarative pins in res/xml network security config and manifest references
- 使用匹配到的位置来在动态测试之前规划 Frida hooks、静态补丁或配置审查。



#### 绕过 SSL Pinning

当实现了 SSL Pinning 时，为了检查 HTTPS 流量需要绕过它。对此有多种方法可用：

- Automatically **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). The best pro of this option, is that you won't need root to bypass the SSL Pinning, but you will need to delete the application and reinstall the new one, and this won't always work.
- You could use **Frida** (discussed below) to bypass this protection. Here you have a guide to use Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- You can also try to **automatically bypass SSL Pinning** using [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- You can also try to **automatically bypass SSL Pinning** using **MobSF dynamic analysis** (explained below)
- If you still think that there is some traffic that you aren't capturing you can try to **forward the traffic to burp using iptables**. Read this blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### 寻找常见的 Web 漏洞

同样重要的是在应用内搜索常见的 Web 漏洞。关于识别和缓解这些漏洞的详细信息超出本摘要的范围，但在其他地方有详尽覆盖。

### Frida

[Frida](https://www.frida.re) 是一个面向开发者、逆向工程师和安全研究人员的动态插装工具包。\
**你可以访问运行中的应用并在运行时 hook 方法来改变行为、修改值、提取值或执行不同的代码...**\
如果你想 pentest Android 应用，你需要知道如何使用 Frida。

- 学习如何使用 Frida: [**Frida 教程**](frida-tutorial/index.html)
- 用于 Frida 操作的一些 "GUI": [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection 很适合自动化使用 Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- 你可以在这里找到一些优秀的 Frida 脚本: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- 尝试按照 [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) 中所示将 Frida 以此方式加载以绕过 anti-debugging / anti-frida 机制（工具 [linjector](https://github.com/erfur/linjector-rs)）

#### 反插装 & SSL pinning 绕过 工作流程

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **转储内存 - Fridump**

检查应用是否在内存中存储了不应该存储的敏感信息，例如密码或助记词。

使用 [**Fridump3**](https://github.com/rootbsd/fridump3) 可以用以下命令转储应用的内存：
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
这将把内存转储到 ./dump 文件夹，之后你可以在其中使用 grep，例如：
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Keystore 中的敏感数据**

在 Android 中，Keystore 是存放敏感数据的最佳位置，但在拥有足够权限的情况下，仍然**可能访问它**。由于应用倾向于在此处**以明文存储的敏感数据**，因此 pentests 应作为 root user 检查此项，否则有物理访问设备的人可能会窃取这些数据。

即使应用将数据存储在 Keystore 中，数据也应当被加密。

要访问 keystore 中的数据，你可以使用这个 Frida 脚本: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

使用下面的 Frida 脚本，可能可以 **bypass fingerprint authentication**，这是 Android applications 为了 **protect certain sensitive areas:** 所采取的措施。
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **后台快照**

当你把应用置于后台时，Android 会存储该应用的**快照**，以便在恢复到前台时先加载该图像，从而看起来像应用更快地启动。

然而，如果该**快照**包含**敏感信息**，有权限访问该快照的人可能会**窃取这些信息**（注意，需要 root 权限才能访问）。

快照通常存储在： **`/data/system_ce/0/snapshots`**

Android 提供了一种方法，即通过设置 **FLAG_SECURE 布局参数来防止屏幕截图**。使用该 flag 后，窗口内容将被视为安全，阻止其出现在屏幕截图中或在非安全显示设备上被查看。
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

这个工具可以在动态分析期间帮助你管理不同的工具： [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

开发者经常创建代理组件，例如 activities、services 和 broadcast receivers 来处理这些 Intents，并将它们传递给诸如 `startActivity(...)` 或 `sendBroadcast(...)` 之类的方法，这可能存在风险。

危险在于允许攻击者通过误导这些 Intents 来触发非导出的 app 组件或访问敏感的 content providers。一个显著的例子是 `WebView` 组件通过 `Intent.parseUri(...)` 将 URL 转换为 `Intent` 对象并随后执行它们，这可能导致恶意的 Intent 注入。

### Essential Takeaways

- **Intent Injection** 类似于 web 的 Open Redirect 问题。
- 利用通常涉及将 `Intent` 对象作为 extras 传递，这些 Intent 可能被重定向以执行不安全的操作。
- 它可能将非导出组件和 content providers 暴露给攻击者。
- `WebView` 将 URL 转换为 `Intent` 的行为可能促使发生非预期的操作。

### Android Client Side Injections and others

你可能在 Web 上见过这类漏洞。在 Android 应用中必须对这些漏洞格外小心：

- **SQL Injection:** 在处理动态查询或 Content-Providers 时，确保使用参数化查询。
- **JavaScript Injection (XSS):** 请确认任何 WebViews 的 JavaScript 与 Plugin 支持已禁用（默认禁用）。 [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews 应禁用对文件系统的访问（默认启用） - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: 在某些情况下，当 android application 结束会话时，cookie 未被撤销，甚至可能被保存到磁盘
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**静态分析**

![](<../../images/image (866).png>)

**对应用的漏洞评估** 使用漂亮的基于 Web 的前端。你也可以执行动态分析（但需要准备好环境）。
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF 还允许你对分析结果进行 **diff/Compare** 并集成 **VirusTotal**（你需要在 _MobSF/settings.py_ 中设置你的 API key 并启用：`VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`）。你也可以将 `VT_UPLOAD` 设置为 `False`，此时将上传 **hash** 而不是文件。

### Assisted Dynamic analysis with MobSF

**MobSF** 在 **Android** 的 **dynamic analysis** 方面也非常有用，但在这种情况下你需要在宿主机上安装 MobSF 和 **genymotion**（VM 或 Docker 无法工作）。_Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
**MobSF dynamic analyser** 可以：

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). 以上内容均会自动完成，除了 screenshots，截图需要你在想要截图时手动按下（按钮），或者按下 "**Exported Activity Tester**" 来获取所有导出 activity 的截图。
- 捕获 **HTTPS traffic**
- 使用 **Frida** 获取 **runtime** **information**

从 Android **versions > 5** 开始，它会 **automatically start Frida** 并设置全局 **proxy** 设置以 **capture** 流量。它只会捕获被测试应用的流量。

**Frida**

默认情况下，它还会使用一些 Frida Scripts 来 **bypass SSL pinning**、**root detection** 和 **debugger detection**，并 **monitor interesting APIs**。\
MobSF 还可以 **invoke exported activities**，抓取它们的 **screenshots** 并 **save** 到报告中。

要开始动态测试，按绿色按钮：“**Start Instrumentation**”。按 “**Frida Live Logs**” 可查看 Frida 脚本生成的日志，按 “**Live API Monitor**” 可查看所有对 hook 方法的调用、传入参数和返回值（这些将在按下 "Start Instrumentation" 后出现）。\
MobSF 还允许你加载自定义的 **Frida scripts**（要将你的 Frida 脚本结果发送到 MobSF，请使用函数 `send()`）。它也有 **several pre-written scripts** 可供加载（你可以在 `MobSF/DynamicAnalyzer/tools/frida_scripts/others/` 中添加更多），只需选择它们，按 “**Load**”，然后按 “**Start Instrumentation**”（你将能在 “**Frida Live Logs**” 中看到这些脚本的日志）。

![](<../../images/image (419).png>)

此外，你还有一些辅助的 Frida 功能：

- **Enumerate Loaded Classes**: 它会列出所有加载的 classes
- **Capture Strings**: 在使用应用时会打印捕获到的所有 strings（非常嘈杂）
- **Capture String Comparisons**: 非常有用。它会 **show the 2 strings being compared** 并显示比较结果为 True 还是 False。
- **Enumerate Class Methods**: 输入类名（例如 "java.io.File"），它会打印该类的所有方法。
- **Search Class Pattern**: 按模式搜索类
- **Trace Class Methods**: **Trace** 整个类（查看该类所有方法的输入和输出）。请记住，默认情况下 MobSF 会跟踪若干有趣的 Android API 方法。

选择好要使用的辅助模块后，按下 "**Start Intrumentation**"，你就会在 "**Frida Live Logs**" 中看到所有输出。

**Shell**

MobSF 还在动态分析页面底部提供了一个 shell，其中包含一些 **adb** commands、**MobSF commands** 和常见的 **shell** **commands**。一些有趣的命令：
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP 工具**

When http traffic is capture you can see an ugly view of the captured traffic on "**HTTP(S) Traffic**" bottom or a nicer view in "**Start HTTPTools**" green bottom. From the second option, you can **send** the **captured requests** to **proxies** like Burp or Owasp ZAP.\
要做到这点，_power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> 按 "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080))。

Once you finish the dynamic analysis with MobSF you can press on "**Start Web API Fuzzer**" to **fuzz http requests** an look for vulnerabilities.  
完成使用 MobSF 的 dynamic analysis 后，你可以点击 "**Start Web API Fuzzer**" 来 **fuzz http requests** 并查找漏洞。

> [!TIP]
> After performing a dynamic analysis with MobSF the proxy settings me be misconfigured and you won't be able to fix them from the GUI. You can fix the proxy settings by doing:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### 使用 Inspeckage 辅助 Dynamic Analysis

You can get the tool from [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
该工具会使用一些 **Hooks**，在你进行 **dynamic analysis** 时帮助你了解**应用内部正在发生的事情**。

### [Yaazhini](https://www.vegabird.com/yaazhini/)

这是一个**用于通过 GUI 执行 static analysis 的出色工具**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

This tool is designed to look for several **security related Android application vulnerabilities**, either in **source code** or **packaged APKs**. 该工具还可以**生成可部署的 "Proof-of-Concept" APK**和**ADB commands**，用于利用发现的一些漏洞（Exposed activities、intents、tapjacking 等）。如同 Drozer，无需对测试设备进行 root。
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- 显示所有提取的文件以便参考
- 自动将 APK 文件反编译为 Java 和 Smali 格式
- 分析 AndroidManifest.xml 以查找常见漏洞和行为
- 对源代码进行静态分析以识别常见漏洞和行为
- 设备信息
- 以及更多
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER 是一个命令行应用程序，可在 Windows、MacOS X 和 Linux 上使用，用于分析 _.apk_ 文件以寻找漏洞。它通过解压 APKs 并应用一系列规则来检测这些漏洞。

所有规则集中在 `rules.json` 文件中，每个公司或测试人员都可以创建自己的规则来分析他们需要的内容。

从 [download page](https://superanalyzer.rocks/download.html) 下载最新的二进制文件
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn 是一个 **跨平台** 工具，帮助开发者、bugbounty hunters 和 ethical hackers 对移动应用执行 [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis)。

其理念是你将移动应用文件（.apk 或 .ipa 文件）拖放到 StaCoAn 应用上，它会为你生成一个可视化且可携带的报告。你可以调整设置和词表以获得定制化体验。

下载[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework 是一个 Android 漏洞分析系统，帮助开发者或 hackers 发现 Android 应用程序中的潜在安全漏洞。\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** 是一个工具，其主要目的是检测并警告用户 Android 应用可能产生的潜在恶意行为。

检测是通过对应用的 Dalvik bytecode（以 **Smali** 表示）进行 **static analysis**，并使用 [`androguard`](https://github.com/androguard/androguard) 库来实现。

该工具寻找类似以下的 **common behavior of "bad" applications**：Telephony identifiers exfiltration、Audio/video flow interception、PIM data modification、Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** 是一个 Mobile Application Reverse engineering and Analysis Framework。它将常用的移动应用逆向工程和分析工具整合在一起，帮助针对 OWASP 移动安全威胁对移动应用进行测试。其目标是让这项工作对移动应用开发者和安全专业人员更简单、更友好。

它能够：

- 使用不同工具提取 Java 和 Smali 代码
- Analyze APKs using: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- 使用正则表达式从 APK 中提取敏感信息。
- 分析 Manifest。
- Analyze found domains using: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- 通过 [apk-deguard.com](http://www.apk-deguard.com) 进行 APK 反混淆

### Koodous

用于检测恶意软件： [https://koodous.com/](https://koodous.com/)

## 代码混淆/反混淆

注意：根据用于混淆代码的服务和配置不同，敏感信息可能被混淆，也可能未被混淆。

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** 是一个开源命令行工具，用于缩小、优化并混淆 Java 代码。它能够优化字节码并检测和移除未使用的指令。ProGuard 是自由软件，依据 GNU General Public License 第2版分发。

ProGuard 随 Android SDK 一同分发，并在以 release 模式构建应用时运行。

### [DexGuard](https://www.guardsquare.com/dexguard)

在 [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html) 可以找到一步步的 apk 反混淆指南。

（摘自该指南）我们上次检查时，Dexguard 的运行模式是：

- 将资源加载为 InputStream；
- 将结果传入继承自 FilterInputStream 的类以对其解密；
- 做一些无用的混淆以浪费逆向者的时间；
- 将解密后的结果传入 ZipInputStream 以获得 DEX 文件；
- 最后使用 `loadDex` 方法将生成的 DEX 作为资源加载。

### [DeGuard](http://apk-deguard.com)

**DeGuard 可逆转 Android 混淆工具执行的混淆过程。这使得多种安全分析成为可能，包括代码检查和库识别。**

你可以将混淆后的 APK 上传到他们的平台。

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

这是一个用于发现 Android 应用潜在安全漏洞并对 Android 应用代码进行反混淆的 LLM 工具。使用 Google's Gemini public API。

### [Simplify](https://github.com/CalebFenton/simplify)

它是一个通用的 android 反混淆器。Simplify 通过“虚拟执行”应用来理解其行为，然后尝试优化代码，使其行为保持一致但更易于人工理解。每种优化类型都很简单且通用，因此所使用的具体混淆类型并不重要。

### [APKiD](https://github.com/rednaga/APKiD)

APKiD 会告诉你 **APK 是如何构建的**。它能识别许多 **compilers**, **packers**, **obfuscators** 以及其他奇怪的东西。它是 Android 版的 [_PEiD_](https://www.aldeid.com/wiki/PEiD)。

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## 实验

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b 是一个基于 ubuntu-mate 的 Android 安全虚拟机，包含来自不同安全爱好者和研究者的最新框架、教程和用于逆向工程与恶意软件分析的实验。

## 参考资料

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) 这是一个很棒的资源列表
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android 快速课程
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)

## 有待尝试

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
