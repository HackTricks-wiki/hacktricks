# Android Applications Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Βασικά εφαρμογών Android

Συνιστάται θερμά να ξεκινήσετε διαβάζοντας αυτή τη σελίδα για να μάθετε σχετικά με τα **πιο σημαντικά μέρη που σχετίζονται με την ασφάλεια του Android και τα πιο επικίνδυνα συστατικά σε μια εφαρμογή Android**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Αυτό είναι το κύριο εργαλείο που χρειάζεστε για να συνδεθείτε με μια συσκευή Android (εξομοιωμένη ή φυσική).\
**ADB** σας επιτρέπει να ελέγχετε συσκευές είτε μέσω **USB** είτε μέσω **Network** από έναν υπολογιστή. Αυτό το εργαλείο επιτρέπει την **αντιγραφή** αρχείων και στις δύο κατευθύνσεις, την **εγκατάσταση** και **απεγκατάσταση** εφαρμογών, την **εκτέλεση** εντολών shell, τη **δημιουργία αντιγράφων ασφαλείας** δεδομένων, την **ανάγνωση** logs, μεταξύ άλλων λειτουργιών.

Ρίξτε μια ματιά στην ακόλουθη λίστα των [**ADB Commands**](adb-commands.md) για να μάθετε πώς να χρησιμοποιείτε το adb.

## Smali

Μερικές φορές είναι ενδιαφέρον να **τροποποιήσετε τον κώδικα της εφαρμογής** για να αποκτήσετε πρόσβαση σε **κρυφές πληροφορίες** (π.χ. καλά obfuscated passwords ή flags). Τότε, μπορεί να είναι χρήσιμο να κάνετε decompile το apk, να τροποποιήσετε τον κώδικα και να το recompile.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Αυτό μπορεί να είναι πολύ χρήσιμο ως **εναλλακτική λύση για διάφορες δοκιμές κατά τη διάρκεια του dynamic analysis** που πρόκειται να παρουσιαστούν. Έτσι, **κρατήστε πάντα στο μυαλό σας αυτή τη δυνατότητα**.

## Άλλα ενδιαφέροντα κόλπα

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **Λήψη APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Εξαγωγή APK από τη συσκευή:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Συγχώνευσε όλα τα splits και τα base apks με [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Μελέτες Περίπτωσης & Ευπάθειες


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Στατική Ανάλυση

Πρώτα απ' όλα, για την ανάλυση ενός APK θα πρέπει να **ρίξετε μια ματιά στον Java κώδικα** χρησιμοποιώντας έναν decompiler.\
Παρακαλώ, [**διαβάστε εδώ για να βρείτε πληροφορίες σχετικά με διαφορετικούς διαθέσιμους decompilers**](apk-decompilers.md).

### Αναζήτηση ενδιαφερόντων πληροφοριών

Απλώς κοιτώντας τις **strings** του APK μπορείτε να αναζητήσετε **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **API** keys, **encryption**, **bluetooth uuids**, **tokens** και οτιδήποτε ενδιαφέρον... ψάξτε ακόμη για code execution **backdoors** ή authentication backdoors (hardcoded admin credentials στην εφαρμογή).

**Firebase**

Δώστε ιδιαίτερη προσοχή σε **firebase URLs** και ελέγξτε αν είναι κακώς διαμορφωμένα. [Περισσότερες πληροφορίες για το τι είναι το Firebase και πώς να το εκμεταλλευτείτε εδώ.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Βασική κατανόηση της εφαρμογής - Manifest.xml, strings.xml

Η **εξέταση των αρχείων _Manifest.xml_ και **_strings.xml_** μιας εφαρμογής μπορεί να αποκαλύψει πιθανά θέματα ασφάλειας**. Αυτά τα αρχεία μπορούν να προσπελαστούν με decompilers ή αλλάζοντας την επέκταση του APK σε .zip και κάνοντας unzip.

**Ευπάθειες** που μπορούν να εντοπιστούν από το **Manifest.xml** περιλαμβάνουν:

- **Debuggable Applications**: Εφαρμογές που έχουν οριστεί ως debuggable (`debuggable="true"`) στο _Manifest.xml_ αποτελούν ρίσκο καθώς επιτρέπουν συνδέσεις που μπορούν να οδηγήσουν σε εκμετάλλευση. Για περαιτέρω κατανόηση σχετικά με το πώς να εκμεταλλευτείτε debuggable εφαρμογές, ανατρέξτε σε ένα tutorial για την ανεύρεση και εκμετάλλευση debuggable εφαρμογών σε μια συσκευή.
- **Backup Settings**: Το `android:allowBackup="false"` πρέπει να ορίζεται ρητά για εφαρμογές που χειρίζονται ευαίσθητες πληροφορίες για να αποτρέπεται μη εξουσιοδοτημένο backup δεδομένων μέσω adb, ειδικά όταν είναι ενεργοποιημένο το usb debugging.
- **Network Security**: Προσαρμοσμένες ρυθμίσεις network security (`android:networkSecurityConfig="@xml/network_security_config"`) στο _res/xml/_ μπορούν να καθορίσουν λεπτομέρειες ασφάλειας όπως certificate pins και ρυθμίσεις HTTP traffic. Ένα παράδειγμα είναι η επιτρεπόμενη HTTP κίνηση για συγκεκριμένα domains.
- **Exported Activities and Services**: Ο εντοπισμός exported activities και services στο manifest μπορεί να υποδείξει components που ενδέχεται να κακοχρησιμοποιηθούν. Περαιτέρω ανάλυση κατά τη διάρκεια δυναμικών δοκιμών μπορεί να αποκαλύψει πώς να εκμεταλλευτείτε αυτά τα components.
- **Content Providers and FileProviders**: Εκτεθειμένοι content providers θα μπορούσαν να επιτρέψουν μη εξουσιοδοτημένη πρόσβαση ή τροποποίηση δεδομένων. Η διαμόρφωση των FileProviders πρέπει επίσης να ελεγχθεί προσεκτικά.
- **Broadcast Receivers and URL Schemes**: Αυτά τα components θα μπορούσαν να αξιοποιηθούν για εκμετάλλευση, δίνοντας ιδιαίτερη προσοχή στο πώς διαχειρίζονται τα URL schemes για τυχόν ευπάθειες εισόδου.
- **SDK Versions**: Τα attributes `minSdkVersion`, `targetSDKVersion` και `maxSdkVersion` υποδεικνύουν τις υποστηριζόμενες εκδόσεις Android, τονίζοντας τη σημασία να μην υποστηρίζονται ξεπερασμένες, ευάλωτες εκδόσεις Android για λόγους ασφαλείας.

Από το αρχείο **strings.xml**, μπορούν να ανακαλυφθούν ευαίσθητες πληροφορίες όπως API keys, custom schemas και άλλες σημειώσεις προγραμματιστή, τονίζοντας την ανάγκη προσεκτικής ανασκόπησης αυτών των πόρων.

### Tapjacking

Το **Tapjacking** είναι μια επίθεση όπου μια **malicious** **application** εκκινείται και **τοποθετείται πάνω από μια εφαρμογή-θύμα**. Μόλις καλύψει οπτικά την εφαρμογή-θύμα, το UI της έχει σχεδιαστεί έτσι ώστε να ξεγελάει τον χρήστη να αλληλεπιδράσει με αυτό, ενώ ταυτόχρονα προωθεί την αλληλεπίδραση στην εφαρμογή-θύμα.\
Στην ουσία, **τυφλώνει τον χρήστη ώστε να μην γνωρίζει ότι εκτελεί πραγματικά ενέργειες στην εφαρμογή-θύμα**.

Βρείτε περισσότερες πληροφορίες σε:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Μια **activity** με το `launchMode` ρυθμισμένο σε **`singleTask` χωρίς να έχει οριστεί `taskAffinity`** είναι ευάλωτη σε Task Hijacking. Αυτό σημαίνει ότι μια **application** μπορεί να εγκατασταθεί και αν εκκινηθεί πριν από την πραγματική εφαρμογή, θα μπορούσε **να hijack-άρει το task της πραγματικής εφαρμογής** (έτσι ο χρήστης θα αλληλεπιδρά με την **malicious application** πιστεύοντας ότι χρησιμοποιεί την πραγματική).

Περισσότερες πληροφορίες σε:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Insecure data storage

Internal Storage

Στο Android, τα αρχεία που **αποθηκεύονται** στην **internal storage** έχουν σχεδιαστεί ώστε να είναι προσπελάσιμα αποκλειστικά από την **εφαρμογή** που τα **δημιούργησε**. Αυτό το μέτρο ασφαλείας **επιβάλλεται** από το λειτουργικό σύστημα Android και είναι γενικά επαρκές για τις ανάγκες ασφαλείας των περισσότερων εφαρμογών. Ωστόσο, οι προγραμματιστές μερικές φορές χρησιμοποιούν modes όπως τα `MODE_WORLD_READABLE` και `MODE_WORLD_WRITABLE` για να **επιτρέψουν** την κοινή χρήση αρχείων μεταξύ διαφορετικών εφαρμογών. Αυτά τα modes **δεν περιορίζουν την πρόσβαση** σε αυτά τα αρχεία από άλλες εφαρμογές, συμπεριλαμβανομένων πιθανώς κακόβουλων.

1. **Static Analysis:**
- **Ελέγξτε** προσεκτικά τη χρήση των `MODE_WORLD_READABLE` και `MODE_WORLD_WRITABLE`. Αυτά τα modes **μπορεί να εκθέσουν** αρχεία σε **μη προοριζόμενη ή μη εξουσιοδοτημένη πρόσβαση**.
2. **Dynamic Analysis:**
- **Επιβεβαιώστε** τα **permissions** που έχουν οριστεί σε αρχεία που δημιουργούνται από την εφαρμογή. Συγκεκριμένα, **ελέγξτε** αν κάποια αρχεία έχουν οριστεί να είναι readable ή writable worldwide. Αυτό μπορεί να αποτελέσει σημαντικό ρίσκο ασφαλείας, καθώς θα επέτρεπε **οποιαδήποτε εφαρμογή** εγκατεστημένη στη συσκευή, ανεξάρτητα από την προέλευση ή τη πρόθεσή της, να **διαβάσει ή να τροποποιήσει** αυτά τα αρχεία.

External Storage

Όταν χειρίζεστε αρχεία σε **external storage**, όπως SD Cards, πρέπει να ληφθούν υπόψη τα εξής:

1. **Accessibility**:
- Τα αρχεία στην external storage είναι **παγκοσμίως αναγνώσιμα και εγγράψιμα**. Αυτό σημαίνει ότι οποιαδήποτε εφαρμογή ή χρήστης μπορεί να έχει πρόσβαση σε αυτά τα αρχεία.
2. **Security Concerns**:
- Δε συνίσταται η αποθήκευση ευαίσθητων πληροφοριών στην external storage λόγω της ευκολίας πρόσβασης.
- Η external storage μπορεί να αφαιρεθεί ή να προσπελαστεί από οποιαδήποτε εφαρμογή, καθιστώντας την λιγότερο ασφαλή.
3. **Handling Data from External Storage**:
- Πάντα **εκτελέστε validation εισόδου** στα δεδομένα που ανακτώνται από external storage. Αυτό είναι κρίσιμο επειδή τα δεδομένα προέρχονται από μια μη αξιόπιστη πηγή.
- Η αποθήκευση εκτελέσιμων αρχείων ή class files στην external storage για dynamic loading δεν συνιστάται.
- Εάν η εφαρμογή σας πρέπει να ανακτήσει εκτελέσιμα αρχεία από την external storage, βεβαιωθείτε ότι αυτά τα αρχεία είναι **signed και cryptographically verified** πριν από το dynamic loading. Αυτό το βήμα είναι ζωτικής σημασίας για τη διατήρηση της ακεραιότητας ασφαλείας της εφαρμογής σας.

Η external storage μπορεί να προσπελαστεί σε `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> Από το Android 4.4 (**API 17**) και μετά, η SD card έχει μια δομή φακέλων που **περιορίζει την πρόσβαση μιας εφαρμογής στον κατάλογο που προορίζεται ειδικά για αυτήν**. Αυτό αποτρέπει μια malicious application από το να αποκτήσει ανάγνωση ή εγγραφή στα αρχεία άλλης εφαρμογής.

**Ευαίσθητα δεδομένα αποθηκευμένα σε clear-text**

- **Shared preferences**: Το Android επιτρέπει σε κάθε εφαρμογή να αποθηκεύει εύκολα xml αρχεία στο μονοπάτι `/data/data/<packagename>/shared_prefs/` και μερικές φορές είναι δυνατό να βρεθούν ευαίσθητες πληροφορίες σε clear-text σε αυτόν το φάκελο.
- **Databases**: Το Android επιτρέπει σε κάθε εφαρμογή να αποθηκεύει sqlite βάσεις δεδομένων στο μονοπάτι `/data/data/<packagename>/databases/` και μερικές φορές είναι δυνατό να βρεθούν ευαίσθητες πληροφορίες σε clear-text σε αυτόν το φάκελο.

### Broken TLS

Accept All Certificates

Για κάποιο λόγο, μερικές φορές οι προγραμματιστές αποδέχονται όλα τα πιστοποιητικά ακόμα και αν, για παράδειγμα, το hostname δεν ταιριάζει, με γραμμές κώδικα όπως η ακόλουθη:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Ελαττωματική Κρυπτογραφία

**Κακές διαδικασίες διαχείρισης κλειδιών**

Κάποιοι προγραμματιστές αποθηκεύουν ευαίσθητα δεδομένα στην τοπική αποθήκευση και τα κρυπτογραφούν με ένα κλειδί hardcoded/predictable μέσα στον code. Αυτό δεν θα έπρεπε να γίνεται καθώς κάποιο reversing μπορεί να επιτρέψει σε attackers να εξάγουν τις εμπιστευτικές πληροφορίες.

**Χρήση ανασφαλών και/ή παρωχημένων αλγορίθμων**

Οι προγραμματιστές δεν πρέπει να χρησιμοποιούν **deprecated algorithms** για να εκτελούν authorisation **checks**, να **αποθηκεύουν** ή να **στέλνουν** δεδομένα. Μερικοί από αυτούς τους αλγορίθμους είναι: RC4, MD4, MD5, SHA1... Αν χρησιμοποιούνται **hashes** για να αποθηκεύονται passwords για παράδειγμα, πρέπει να χρησιμοποιηθούν hashes brute-force **resistant** με salt.

### Άλλοι έλεγχοι

- Συνιστάται να **obfuscate το APK** ώστε να δυσκολεύεται η εργασία των reverse engineers και των attackers.
- Αν η εφαρμογή είναι ευαίσθητη (όπως bank apps), θα πρέπει να πραγματοποιεί δικούς της ελέγχους για να διαπιστώνει αν το mobile είναι rooted και να ενεργεί ανάλογα.
- Αν η εφαρμογή είναι ευαίσθητη (όπως bank apps), θα πρέπει να ελέγχει αν χρησιμοποιείται **emulator**.
- Αν η εφαρμογή είναι ευαίσθητη (όπως bank apps), θα πρέπει να **ελέγχει την ακεραιότητά της πριν την εκτέλεση** ώστε να διαπιστώνει αν έχει τροποποιηθεί.
- Χρησιμοποιήστε [**APKiD**](https://github.com/rednaga/APKiD) για να ελέγξετε ποιος compiler/packer/obfuscator χρησιμοποιήθηκε για το build του APK

### Εφαρμογή React Native

Διαβάστε την παρακάτω σελίδα για να μάθετε πώς να αποκτάτε εύκολα πρόσβαση στο javascript code των React εφαρμογών:


{{#ref}}
react-native-application.md
{{#endref}}

### Εφαρμογές Xamarin

Διαβάστε την παρακάτω σελίδα για να μάθετε πώς να αποκτάτε εύκολα πρόσβαση στο C# code μιας xamarin εφαρμογής:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Εφαρμογές

Σύμφωνα με αυτό το [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) το superpacked είναι ένας Meta αλγόριθμος που συμπιέζει το περιεχόμενο μιας εφαρμογής σε ένα μοναδικό αρχείο. Το blog περιγράφει την πιθανότητα δημιουργίας μιας εφαρμογής που αποσυμπιέζει αυτού του είδους τις εφαρμογές... και έναν ταχύτερο τρόπο που περιλαμβάνει να **εκτελέσετε την εφαρμογή και να συλλέξετε τα αποσυμπιεσμένα αρχεία από το filesystem.**

### Αυτοματοποιημένη Στατική Code Ανάλυση

Το εργαλείο [**mariana-trench**](https://github.com/facebook/mariana-trench) είναι ικανό να εντοπίζει **vulnerabilities** κάνοντας **scanning** του **code** της εφαρμογής. Αυτό το εργαλείο περιέχει μια σειρά από **known sources** (που υποδεικνύουν στο εργαλείο τα **places** όπου το **input** είναι **controlled by the user**), **sinks** (που υποδεικνύουν στο εργαλείο **dangerous** **places** όπου κακόβουλο user input θα μπορούσε να προκαλέσει βλάβες) και **rules**. Αυτοί οι κανόνες υποδεικνύουν τον **συνδυασμό** **sources-sinks** που δηλώνει μια vulnerability.

Με αυτή τη γνώση, **mariana-trench θα ανασκοπήσει τον code και θα βρει πιθανές vulnerabilities σε αυτόν**.

### Secrets leaked

Μια εφαρμογή μπορεί να περιέχει secrets (API keys, passwords, hidden urls, subdomains...) μέσα της που μπορεί να ανακαλύψετε. Μπορείτε να χρησιμοποιήσετε ένα εργαλείο όπως [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Άλλες ενδιαφέρουσες λειτουργίες

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)

### **Άλλα κόλπα**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Δυναμική Ανάλυση

> Πρώτα απ' όλα, χρειάζεστε ένα περιβάλλον όπου μπορείτε να εγκαταστήσετε την εφαρμογή και όλο το απαραίτητο περιβάλλον (Burp CA cert, Drozer και Frida κυρίως). Επομένως, μια rooted συσκευή (emulated ή όχι) συνιστάται ιδιαίτερα.

### Online Dynamic analysis

Μπορείτε να δημιουργήσετε ένα **free account** στο: [https://appetize.io/](https://appetize.io). Αυτή η πλατφόρμα σας επιτρέπει να **upload** και να **execute** APKs, οπότε είναι χρήσιμη για να δείτε πώς συμπεριφέρεται ένα apk.

Μπορείτε ακόμη να **δειτε τα logs της εφαρμογής σας** στο web και να συνδεθείτε μέσω **adb**.

![](<../../images/image (831).png>)

Χάρη στη σύνδεση ADB μπορείτε να χρησιμοποιήσετε **Drozer** και **Frida** μέσα στα emulators.

### Τοπική Δυναμική Ανάλυση

#### Χρήση emulator

- [**Android Studio**](https://developer.android.com/studio) (Μπορείτε να δημιουργήσετε **x86** και **arm** συσκευές, και σύμφωνα με [**αυτό**](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**οι τελευταίες x86** εκδόσεις **υποστηρίζουν ARM βιβλιοθήκες** χωρίς να χρειάζεται ένας αργός arm emulator).
- Μάθετε πώς να το ρυθμίσετε σε αυτή τη σελίδα:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, χρειάζεται να δημιουργήσετε account. _Συνιστάται να **κατεβάσετε** την έκδοση **ΜΕ**_ _**VirtualBox** για να αποφύγετε πιθανά σφάλματα._)
- [**Nox**](https://es.bignox.com) (Δωρεάν, αλλά δεν υποστηρίζει Frida ή Drozer).

> [!TIP]
> Όταν δημιουργείτε ένα νέο emulator σε οποιαδήποτε πλατφόρμα, θυμηθείτε ότι όσο μεγαλύτερη είναι η οθόνη τόσο πιο αργά θα τρέχει ο emulator. Επομένως επιλέξτε μικρές οθόνες αν είναι δυνατόν.

Για να **install google services** (όπως AppStore) στο Genymotion πρέπει να πατήσετε το κόκκινο κουμπί που φαίνεται στην παρακάτω εικόνα:

![](<../../images/image (277).png>)

Επίσης, σημειώστε ότι στις **ρυθμίσεις του Android VM στο Genymotion** μπορείτε να επιλέξετε **Bridge Network mode** (αυτό θα είναι χρήσιμο αν θα συνδέεστε στο Android VM από ένα διαφορετικό VM με τα εργαλεία).

#### Χρήση φυσικής συσκευής

Πρέπει να ενεργοποιήσετε τις **επιλογές debugging** και είναι προτιμότερο αν μπορείτε να την **root**:

1. **Settings**.
2. (FromAndroid 8.0) Επιλέξτε **System**.
3. Επιλέξτε **About phone**.
4. Πατήστε **Build number** 7 φορές.
5. Επιστρέψτε πίσω και θα βρείτε τις **Developer options**.

> Μόλις εγκαταστήσετε την εφαρμογή, το πρώτο που πρέπει να κάνετε είναι να τη δοκιμάσετε και να εξερευνήσετε τι κάνει, πώς λειτουργεί και να εξοικειωθείτε με αυτήν.\
> Προτείνω να **εκτελέσετε αυτή την αρχική dynamic analysis χρησιμοποιώντας MobSF dynamic analysis + pidcat**, έτσι θα μπορέσουμε να **μάθουμε πώς λειτουργεί η εφαρμογή** ενώ το MobSF **συλλαμβάνει** πολλά **interesting** **data** που μπορείτε να ελέγξετε αργότερα.

Magisk/Zygisk quick notes (συνιστάται σε Pixel devices)
- Patch το boot.img με την εφαρμογή Magisk και flash μέσω fastboot για να αποκτήσετε systemless root
- Ενεργοποιήστε Zygisk + DenyList για απόκρυψη root; σκεφτείτε LSPosed/Shamiko όταν απαιτείται ισχυρότερη απόκρυψη
- Κρατήστε το original boot.img για ανάκτηση μετά από OTA updates; επανα-παστάρετε μετά από κάθε OTA
- Για screen mirroring, χρησιμοποιήστε scrcpy στον host



### Unintended Data Leakage

**Logging**

Οι προγραμματιστές θα πρέπει να είναι προσεκτικοί ώστε να μην εκθέτουν **debugging information** δημόσια, καθώς αυτό μπορεί να οδηγήσει σε ευαίσθητα data leaks. Τα εργαλεία [**pidcat**](https://github.com/JakeWharton/pidcat) και `adb logcat` συνιστώνται για παρακολούθηση των logs της εφαρμογής ώστε να εντοπιστούν και να προστατευθούν ευαίσθητες πληροφορίες. **Pidcat** προτιμάται για την ευκολία χρήσης και την αναγνωσιμότητα.

> [!WARNING]
> Σημειώστε ότι από **later newer than Android 4.0**, **οι εφαρμογές μπορούν να έχουν πρόσβαση μόνο στα δικά τους logs**. Επομένως οι εφαρμογές δεν μπορούν να αποκτήσουν πρόσβαση στα logs άλλων εφαρμογών.\
> Παρ' όλα αυτά, εξακολουθεί να συνιστάται **να μην καταγράφονται ευαίσθητες πληροφορίες**.

**Copy/Paste Buffer Caching**

Το **clipboard-based** πλαίσιο του Android επιτρέπει λειτουργίες copy-paste στις εφαρμογές, ωστόσο εγκυμονεί ρίσκο καθώς **άλλες εφαρμογές** μπορούν να έχουν **πρόσβαση** στο clipboard, ενδεχομένως εκθέτοντας ευαίσθητα δεδομένα. Είναι κρίσιμο να **απενεργοποιείτε τις λειτουργίες copy/paste** σε ευαίσθητα τμήματα μιας εφαρμογής, όπως στοιχεία πιστωτικών καρτών, για να αποτρέψετε data leaks.

**Crash Logs**

Αν μια εφαρμογή **crashes** και **αποθηκεύει logs**, αυτά τα logs μπορούν να βοηθήσουν attackers, ιδιαίτερα όταν η εφαρμογή δεν μπορεί να γίνει reverse-engineering. Για να μειώσετε αυτόν τον κίνδυνο, αποφύγετε την καταγραφή σε crashes, και αν logs πρέπει να σταλούν μέσω δικτύου, βεβαιωθείτε ότι αποστέλλονται μέσω SSL channel για ασφάλεια.

Ως pentester, **προσπαθήστε να ρίξετε μια ματιά στα logs αυτά**.

**Analytics Data Sent To 3rd Parties**

Οι εφαρμογές συχνά ενσωματώνουν υπηρεσίες όπως Google Adsense, οι οποίες μπορούν κατά λάθος να **leak** ευαίσθητα δεδομένα λόγω ακατάλληλης υλοποίησης από τους προγραμματιστές. Για να εντοπίσετε πιθανές διαρροές δεδομένων, είναι συνετό να **παρεμβαίνετε στην κίνηση της εφαρμογής** και να ελέγχετε για οποιεσδήποτε ευαίσθητες πληροφορίες που αποστέλλονται σε τρίτους.

### SQLite DBs

Οι περισσότερες εφαρμογές θα χρησιμοποιήσουν **internal SQLite databases** για να αποθηκεύσουν πληροφορίες. Κατά τη διάρκεια του pentest ρίξτε μια **ματιά** στις **βάσεις δεδομένων** που δημιουργούνται, τα ονόματα των **πινάκων** και των **στηλών** και όλα τα **δεδομένα** που αποθηκεύονται γιατί μπορεί να βρείτε **ευαίσθητες πληροφορίες** (που θα ήταν vulnerability).\
Οι βάσεις δεδομένων θα πρέπει να βρίσκονται στο `/data/data/the.package.name/databases` όπως `/data/data/com.mwr.example.sieve/databases`

Εάν η βάση δεδομένων αποθηκεύει εμπιστευτικές πληροφορίες και είναι **encrypted** αλλά μπορείτε να **βρείτε** το **password** μέσα στην εφαρμογή, αυτό εξακολουθεί να αποτελεί **vulnerability**.

Απαριθμήστε τους πίνακες χρησιμοποιώντας `.tables` και απαριθμήστε τις στήλες των πινάκων με `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

Από τα [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** σας επιτρέπει να **υποδυθείτε τον ρόλο μιας Android app** και να αλληλεπιδράσετε με άλλες εφαρμογές. Μπορεί να κάνει **οτιδήποτε μπορεί να κάνει μια εγκατεστημένη εφαρμογή**, όπως να χρησιμοποιήσει τον μηχανισμό Inter-Process Communication (IPC) του Android και να αλληλεπιδράσει με το underlying operating system. .\
Το Drozer είναι ένα χρήσιμο εργαλείο για να **εκμεταλλευτείτε exported activities, exported services και Content Providers** όπως θα μάθετε στις επόμενες ενότητες.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Θυμηθείτε επίσης ότι ο κώδικας μιας activity ξεκινάει στη μέθοδο **`onCreate`**.

**Authorisation bypass**

Όταν μια Activity είναι exported μπορείτε να καλέσετε την οθόνη της από μια εξωτερική app. Επομένως, αν μια activity με **ευαίσθητες πληροφορίες** είναι **exported** θα μπορούσατε να **bypass** τους μηχανισμούς authentication για να έχετε πρόσβαση σε αυτήν.

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

Μπορείτε επίσης να ξεκινήσετε μια exported activity από adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> Σημειώστε ότι ένα authorisation bypass δεν είναι πάντα ευπάθεια — εξαρτάται από το πώς λειτουργεί το bypass και ποιες πληροφορίες εκτίθενται.

**Sensitive information leakage**

**Activities can also return results**. Εάν καταφέρετε να βρείτε μια exported και unprotected activity που καλεί την μέθοδο **`setResult`** και **επιστρέφει ευαίσθητες πληροφορίες**, υπάρχει sensitive information leakage.

#### Tapjacking

If tapjacking isn't prevented, μπορείτε να καταχραστείτε την exported activity για να κάνετε τον χρήστη να εκτελέσει **απρόσμενες ενέργειες**. Για περισσότερες πληροφορίες σχετικά με [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Διαβάστε αυτό αν θέλετε να επαναλάβετε τι είναι ένας Content Provider.**](android-applications-basics.md#content-provider)\
Οι Content providers χρησιμοποιούνται βασικά για το **μοιράσμα δεδομένων**. Εάν μια εφαρμογή διαθέτει content providers, μπορεί να καταφέρετε να **εξάγετε ευαίσθητα** δεδομένα από αυτά. Είναι επίσης ενδιαφέρον να δοκιμάσετε πιθανές **SQL injections** και **Path Traversals** καθώς μπορεί να είναι ευάλωτες.

[**Μάθετε πώς να εκμεταλλευτείτε Content Providers με το Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Διαβάστε αυτό αν θέλετε να επαναλάβετε τι είναι ένα Service.**](android-applications-basics.md#services)\
Θυμηθείτε ότι οι ενέργειες ενός Service ξεκινούν στη μέθοδο `onStartCommand`.

Ένα Service είναι βασικά κάτι που **μπορεί να λαμβάνει δεδομένα**, να τα **επεξεργάζεται** και να **επιστρέφει** (ή όχι) μια απάντηση. Επομένως, αν μια εφαρμογή exports κάποια services θα πρέπει να **ελέγξετε** τον **κώδικα** για να καταλάβετε τι κάνει και να τα **δοκιμάσετε** **δυναμικά** για εξαγωγή εμπιστευτικών πληροφοριών, παράκαμψη μέτρων authentication...\
[**Μάθετε πώς να εκμεταλλευτείτε Services με το Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Διαβάστε αυτό αν θέλετε να επαναλάβετε τι είναι ένα Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Θυμηθείτε ότι οι ενέργειες ενός Broadcast Receiver ξεκινούν στη μέθοδο `onReceive`.

Ένας Broadcast Receiver θα περιμένει έναν τύπο μηνύματος. Ανάλογα με το πώς ο receiver χειρίζεται το μήνυμα, μπορεί να είναι ευάλωτος.\
[**Μάθετε πώς να εκμεταλλευτείτε Broadcast Receivers με το Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Μπορείτε να ψάξετε για deep links χειροκίνητα, χρησιμοποιώντας εργαλεία όπως το MobSF ή scripts όπως [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Μπορείτε να **ανοίξετε** ένα δηλωμένο **scheme** χρησιμοποιώντας **adb** ή έναν **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Σημειώστε ότι μπορείτε να **παραλείψετε το όνομα του πακέτου** και το κινητό θα καλέσει αυτόματα την εφαρμογή που πρέπει να ανοίξει αυτόν τον σύνδεσμο._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Εκτελούμενος κώδικας**

Για να βρείτε τον **κώδικα που θα εκτελεστεί στην App**, μεταβείτε στη δραστηριότητα που καλείται από το deeplink και αναζητήστε τη συνάρτηση **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Ευαίσθητες πληροφορίες**

Κάθε φορά που βρίσκετε ένα deep link ελέγξτε ότι **δεν λαμβάνει ευαίσθητα δεδομένα (όπως κωδικούς πρόσβασης) μέσω URL παραμέτρων**, γιατί οποιαδήποτε άλλη εφαρμογή θα μπορούσε να **μιμηθεί το deep link και να κλέψει αυτά τα δεδομένα!**

**Παράμετροι στο path**

Πρέπει επίσης να **ελέγξετε αν κάποιο deep link χρησιμοποιεί παράμετρο μέσα στο path** του URL όπως: `https://api.example.com/v1/users/{username}` , σε αυτή την περίπτωση μπορείτε να αναγκάσετε path traversal προσπελάζοντας κάτι σαν: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Σημειώστε ότι αν βρείτε τα σωστά endpoints μέσα στην εφαρμογή ίσως να μπορείτε να προκαλέσετε ένα **Open Redirect** (εάν μέρος του path χρησιμοποιείται ως domain name), **account takeover** (αν μπορείτε να τροποποιήσετε λεπτομέρειες χρηστών χωρίς CSRF token και το vuln endpoint χρησιμοποιούσε τη σωστή μέθοδο) και οποιοδήποτε άλλο vuln. More [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**Περισσότερα παραδείγματα**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Έλεγχος Επιπέδου Μεταφοράς και Σφάλματα Επαλήθευσης

- **Τα certificates δεν ελέγχονται πάντα σωστά** από εφαρμογές Android. Είναι συνηθισμένο αυτές οι εφαρμογές να παραβλέπουν προειδοποιήσεις και να αποδέχονται self-signed certificates ή, σε ορισμένες περιπτώσεις, να επανέρχονται στη χρήση HTTP συνδέσεων.
- **Οι διαπραγματεύσεις κατά το SSL/TLS handshake μερικές φορές είναι αδύναμες**, χρησιμοποιώντας μη ασφαλείς cipher suites. Αυτή η ευαλωτότητα κάνει τη σύνδεση ευάλωτη σε man-in-the-middle (MITM) επιθέσεις, επιτρέποντας σε επιτιθέμενους να αποκρυπτογραφήσουν τα δεδομένα.
- **Διαρροή ιδιωτικών πληροφοριών** είναι κίνδυνος όταν εφαρμογές ταυτοποιούνται μέσω ασφαλών καναλιών αλλά στη συνέχεια επικοινωνούν μέσω μη ασφαλών καναλιών για άλλες συναλλαγές. Αυτή η προσέγγιση δεν προστατεύει ευαίσθητα δεδομένα, όπως session cookies ή λεπτομέρειες χρηστών, από υποκλοπή από κακόβουλες οντότητες.

#### Επαλήθευση Πιστοποιητικού

Θα επικεντρωθούμε σε **certificate verification**. Η ακεραιότητα του πιστοποιητικού του server πρέπει να επαληθεύεται για να ενισχυθεί η ασφάλεια. Αυτό είναι κρίσιμο επειδή μη ασφαλείς TLS ρυθμίσεις και η μετάδοση ευαίσθητων δεδομένων μέσω μη κρυπτογραφημένων καναλιών μπορούν να προκαλέσουν σημαντικούς κινδύνους. Για λεπτομερή βήματα σχετικά με την επαλήθευση server certificates και την αντιμετώπιση ευπαθειών, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) παρέχει ολοκληρωμένες οδηγίες.

#### SSL Pinning

SSL Pinning είναι ένα μέτρο ασφαλείας όπου η εφαρμογή επαληθεύει το πιστοποιητικό του server με αντίγραφο γνωστό και αποθηκευμένο εντός της ίδιας της εφαρμογής. Αυτή η μέθοδος είναι ουσιώδης για την αποτροπή MITM επιθέσεων. Η υλοποίηση SSL Pinning συστήνεται έντονα για εφαρμογές που χειρίζονται ευαίσθητες πληροφορίες.

#### Traffic Inspection

Για να ελέγξετε το HTTP traffic, είναι απαραίτητο να **εγκαταστήσετε το πιστοποιητικό του proxy tool** (π.χ. Burp). Χωρίς την εγκατάσταση αυτού του πιστοποιητικού, πιθανότατα η κρυπτογραφημένη κίνηση δεν θα είναι ορατή μέσω του proxy. Για οδηγό εγκατάστασης ενός custom CA certificate, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Εφαρμογές που στοχεύουν **API Level 24 and above** απαιτούν τροποποιήσεις στο Network Security Config για να αποδεχτούν το CA certificate του proxy. Αυτό το βήμα είναι κρίσιμο για την επιθεώρηση κρυπτογραφημένης κίνησης. Για οδηγίες σχετικά με την τροποποίηση του Network Security Config, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

If **Flutter** is being used you need to to follow the instructions in [**this page**](flutter.md). This is becasue, just adding the certificate into the store won't work as Flutter has its own list of valid CAs.

#### Static detection of SSL/TLS pinning

Πριν επιχειρήσετε runtime bypasses, χαρτογραφήστε γρήγορα πού εφαρμόζεται το pinning στο APK. Η στατική ανίχνευση βοηθά στο να σχεδιάσετε hooks/patches και να εστιάσετε στα σωστά code paths.

Tool: SSLPinDetect
- Open-source static-analysis utility that decompiles the APK to Smali (via apktool) and scans for curated regex patterns of SSL/TLS pinning implementations.
- Reports exact file path, line number, and a code snippet for each match.
- Covers common frameworks and custom code paths: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

Εγκατάσταση
- Προαπαιτούμενα: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Χρήση
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Παραδείγματα κανόνων προτύπων (JSON)
Χρησιμοποιήστε ή επεκτείνετε signatures για να εντοπίσετε ιδιόκτητα/προσαρμοσμένα στυλ pinning. Μπορείτε να φορτώσετε το δικό σας JSON και να scan σε μεγάλη κλίμακα.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Σημειώσεις και συμβουλές
- Γρήγορο σκανάρισμα σε μεγάλες εφαρμογές μέσω multi-threading και memory-mapped I/O; pre-compiled regex μειώνει το overhead/false positives.
- Συλλογή patterns: https://github.com/aancw/smali-sslpin-patterns
- Τυπικοί στόχοι ανίχνευσης για περαιτέρω αξιολόγηση:
- OkHttp: χρήση CertificatePinner, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, overrides του checkServerTrusted
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init με custom managers
- Declarative pins σε res/xml network security config και αναφορές στο manifest
- Χρησιμοποιήστε τις εντοπισμένες θέσεις για να σχεδιάσετε Frida hooks, static patches ή ανασκοπήσεις config πριν από dynamic testing.



#### Παράκαμψη SSL Pinning

Όταν εφαρμόζεται SSL Pinning, η παράκαμψή του γίνεται απαραίτητη για την επιθεώρηση του HTTPS traffic. Υπάρχουν διάφορες μέθοδοι διαθέσιμες για αυτόν τον σκοπό:

- Αυτόματα **τροποποιήσετε** το **apk** για να **παρακάμψετε** SSLPinning με [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Το κύριο πλεονέκτημα αυτής της επιλογής είναι ότι δεν θα χρειαστείτε root για να παρακάμψετε το SSL Pinning, αλλά θα χρειαστεί να διαγράψετε την εφαρμογή και να εγκαταστήσετε τη νέα, και αυτό δεν δουλεύει πάντα.
- Μπορείτε να χρησιμοποιήσετε **Frida** (συζητιέται παρακάτω) για να παρακάμψετε αυτήν την προστασία. Εδώ υπάρχει ένας οδηγός για χρήση Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Μπορείτε επίσης να δοκιμάσετε να **παρακάμψετε αυτόματα το SSL Pinning** χρησιμοποιώντας [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Μπορείτε επίσης να δοκιμάσετε να **παρακάμψετε αυτόματα το SSL Pinning** χρησιμοποιώντας **MobSF dynamic analysis** (εξηγείται παρακάτω)
- Αν νομίζετε ότι υπάρχει ακόμα κίνηση που δεν καταγράφετε, μπορείτε να δοκιμάσετε να **προωθήσετε την κίνηση στο Burp χρησιμοποιώντας iptables**. Διαβάστε αυτό το blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Αναζήτηση κοινών web ευπαθειών

Είναι σημαντικό επίσης να αναζητήσετε κοινές web ευπάθειες μέσα στην εφαρμογή. Λεπτομέρειες για τον εντοπισμό και την αντιμετώπιση αυτών των ευπαθειών υπερβαίνουν το πλαίσιο αυτής της περίληψης αλλά καλύπτονται εκτενώς αλλού.

### Frida

[Frida](https://www.frida.re) είναι ένα dynamic instrumentation toolkit για developers, reverse-engineers και security researchers.\
**Μπορείτε να αποκτήσετε πρόσβαση σε τρέχουσα εφαρμογή και να κάνετε hook μεθόδους κατά το runtime για να αλλάξετε τη συμπεριφορά, να αλλάξετε τιμές, να εξάγετε τιμές, να εκτελέσετε διαφορετικό κώδικα...**\
Αν θέλετε να pentest Android applications πρέπει να ξέρετε πώς να χρησιμοποιείτε Frida.

- Μάθετε πώς να χρησιμοποιείτε Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Κάποια "GUI" για ενέργειες με Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection είναι εξαιρετικό για την αυτοματοποίηση της χρήσης του Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Μπορείτε να βρείτε μερικά Awesome Frida scripts εδώ: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Προσπαθήστε να παρακάμψετε anti-debugging / anti-frida μηχανισμούς φορτώνοντας το Frida όπως υποδεικνύεται στο [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (εργαλείο [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

Ελέγξτε αν η εφαρμογή αποθηκεύει ευαίσθητες πληροφορίες στη μνήμη που δεν θα έπρεπε να αποθηκεύει, όπως passwords ή mnemonics.

Χρησιμοποιώντας [**Fridump3**](https://github.com/rootbsd/fridump3) μπορείτε να κάνετε dump τη μνήμη της εφαρμογής με:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Αυτό θα κάνει dump τη μνήμη στον φάκελο ./dump, και εκεί μπορείτε να κάνετε grep με κάτι σαν:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Ευαίσθητα δεδομένα στο Keystore**

Στο Android το Keystore είναι το καλύτερο μέρος για την αποθήκευση ευαίσθητων δεδομένων, ωστόσο, με επαρκή προνόμια εξακολουθεί να είναι **εφικτό να αποκτηθεί πρόσβαση σε αυτό**. Καθώς οι εφαρμογές τείνουν να αποθηκεύουν εδώ **ευαίσθητα δεδομένα σε clear text**, οι pentests θα πρέπει να το ελέγχουν, καθώς ένας root user ή κάποιος με φυσική πρόσβαση στη συσκευή θα μπορούσε να κλέψει αυτά τα δεδομένα.

Ακόμη και αν μια εφαρμογή αποθήκευε δεδομένα στο keystore, τα δεδομένα πρέπει να είναι κρυπτογραφημένα.

Για να αποκτήσετε πρόσβαση στα δεδομένα μέσα στο keystore μπορείτε να χρησιμοποιήσετε αυτό το Frida script: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Χρησιμοποιώντας το ακόλουθο Frida script, είναι πιθανό να γίνει **bypass fingerprint authentication** που μπορεί να εκτελούν οι εφαρμογές Android, προκειμένου να **προστατέψουν ορισμένες ευαίσθητες περιοχές:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Εικόνες παρασκηνίου**

Όταν βάζετε μια εφαρμογή στο παρασκήνιο, το Android αποθηκεύει ένα **στιγμιότυπο της εφαρμογής** ώστε όταν επανέλθει στο προσκήνιο να αρχίζει να φορτώνει την εικόνα πριν από την εφαρμογή, έτσι φαίνεται σαν να φορτώθηκε η εφαρμογή πιο γρήγορα.

Ωστόσο, αν αυτό το στιγμιότυπο περιέχει **ευαίσθητες πληροφορίες**, κάποιος με πρόσβαση στο στιγμιότυπο μπορεί να **κλέψει αυτές τις πληροφορίες** (σημείωση: χρειάζεστε root για να αποκτήσετε πρόσβαση).

Τα στιγμιότυπα συνήθως αποθηκεύονται στο: **`/data/system_ce/0/snapshots`**

Το Android παρέχει έναν τρόπο για **να αποτρέψει τη λήψη στιγμιότυπων οθόνης θέτοντας την παράμετρο layout FLAG_SECURE**. Χρησιμοποιώντας αυτή τη σημαία, τα περιεχόμενα του παραθύρου αντιμετωπίζονται ως ασφαλή, αποτρέποντας την εμφάνισή τους σε στιγμιότυπα οθόνης ή να προβληθούν σε μη ασφαλείς οθόνες.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

This tool could help you managing different tools during the dynamic analysis: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Οι developers συχνά δημιουργούν proxy components όπως activities, services, και broadcast receivers που χειρίζονται αυτά τα Intents και τα περνούν σε μεθόδους όπως `startActivity(...)` ή `sendBroadcast(...)`, κάτι που μπορεί να είναι επικίνδυνο.

Ο κίνδυνος έγκειται στο ότι επιτρέπεται σε επιτιθέμενους να ενεργοποιούν μη-exported components της εφαρμογής ή να αποκτούν πρόσβαση σε ευαίσθητους content providers παραπλανώντας αυτά τα Intents. Ένα χαρακτηριστικό παράδειγμα είναι το `WebView` component που μετατρέπει URLs σε αντικείμενα `Intent` μέσω `Intent.parseUri(...)` και στη συνέχεια τα εκτελεί, ενδεχομένως οδηγώντας σε κακόβουλες Intent injections.

### Essential Takeaways

- **Intent Injection** είναι παρόμοιο με το Open Redirect στο web.
- Οι εκμεταλλεύσεις περιλαμβάνουν τη μεταβίβαση αντικειμένων `Intent` ως extras, τα οποία μπορούν να ανακατευθυνθούν ώστε να εκτελέσουν μη ασφαλείς ενέργειες.
- Μπορεί να εκθέσει μη-exported components και content providers σε επιτιθέμενους.
- Η μετατροπή URL σε `Intent` από το `WebView` μπορεί να διευκολύνει ανεπιθύμητες ενέργειες.

### Android Client Side Injections and others

Πιθανόν να γνωρίζετε αυτό το είδος ευπαθειών από τον Web. Πρέπει να είστε ιδιαίτερα προσεκτικοί με αυτές τις ευπάθειες σε μια Android εφαρμογή:

- **SQL Injection:** Όταν χειρίζεστε δυναμικά queries ή Content-Providers, βεβαιωθείτε ότι χρησιμοποιείτε parameterized queries.
- **JavaScript Injection (XSS):** Επαληθεύστε ότι το JavaScript και η υποστήριξη Plugin είναι απενεργοποιημένα για οποιαδήποτε WebViews (απενεργοποιημένα από προεπιλογή). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** Τα WebViews θα πρέπει να έχουν απενεργοποιημένη την πρόσβαση στο file system (ενεργοποιημένη εξ ορισμού) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: Σε αρκετές περιπτώσεις όταν η android εφαρμογή τερματίζει τη συνεδρία το cookie δεν ανακαλείται ή μπορεί ακόμη να αποθηκευτεί στο δίσκο
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Στατική ανάλυση**

![](<../../images/image (866).png>)

**Αξιολόγηση ευπαθειών της εφαρμογής** χρησιμοποιώντας ένα ωραίο web-based frontend. Μπορείτε επίσης να εκτελέσετε δυναμική ανάλυση (αλλά πρέπει να προετοιμάσετε το περιβάλλον).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Βοηθούμενη Dynamic analysis με MobSF

Το MobSF μπορεί επίσης να είναι πολύ χρήσιμο για Dynamic analysis σε **Android**, αλλά σε αυτή την περίπτωση θα χρειαστεί να εγκαταστήσετε το MobSF και **genymotion** στο host σας (a VM or Docker won't work). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
Ο **MobSF dynamic analyser** μπορεί:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). Όλα αυτά γίνονται αυτόματα εκτός από τα screenshots — πρέπει να πατήσετε όταν θέλετε ένα screenshot ή να πατήσετε "**Exported Activity Tester**" για να λάβετε screenshots όλων των exported activities.
- Καταγραφή **HTTPS traffic**
- Χρήση **Frida** για να αποκτήσει **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: Θα εμφανίσει όλες τις loaded classes
- **Capture Strings**: Θα εμφανίσει όλα τα captured strings ενώ χρησιμοποιείτε την εφαρμογή (super noisy)
- **Capture String Comparisons**: Μπορεί να είναι πολύ χρήσιμο. Θα **δείξει τα 2 strings που συγκρίνονται** και αν το αποτέλεσμα ήταν True ή False.
- **Enumerate Class Methods**: Βάλτε το όνομα της κλάσης (π.χ. "java.io.File") και θα εμφανίσει όλες τις methods της κλάσης.
- **Search Class Pattern**: Αναζήτηση classes με βάση pattern
- **Trace Class Methods**: Trace μια ολόκληρη κλάση (δείτε τα inputs και outputs όλων των methods της κλάσης). Θυμηθείτε ότι εξ ορισμού το MobSF traces αρκετές ενδιαφέρουσες Android Api methods.

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

MobSF also brings you a shell with some **adb** commands, **MobSF commands**, and common **shell** **commands** at the bottom of the dynamic analysis page. Some interesting commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP tools**

Όταν η κίνηση http καταγράφεται, μπορείτε να δείτε μια άσχημη προβολή της καταγεγραμμένης κίνησης στο κουμπί "**HTTP(S) Traffic**" στο κάτω μέρος ή μια πιο ευχάριστη προβολή στο πράσινο κουμπί "**Start HTTPTools**". Από τη δεύτερη επιλογή, μπορείτε να **send** τα **captured requests** σε **proxies** όπως το Burp ή το Owasp ZAP.\
Για να το κάνετε, _power on Burp -->_ _turn off Intercept --> στο MobSB HTTPTools επιλέξτε το request_ --> πατήστε "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Once you finish the dynamic analysis with MobSF you can press on "**Start Web API Fuzzer**" to **fuzz http requests** an look for vulnerabilities.

> [!TIP]
> Μετά την εκτέλεση δυναμικής ανάλυσης με MobSF, οι ρυθμίσεις proxy μπορεί να είναι λανθασμένες και να μην μπορείτε να τις διορθώσετε από το GUI. Μπορείτε να διορθώσετε τις ρυθμίσεις proxy κάνοντας:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

Μπορείτε να αποκτήσετε το εργαλείο από [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Αυτό το εργαλείο θα χρησιμοποιήσει κάποια **Hooks** για να σας ενημερώσει **τι συμβαίνει στην εφαρμογή** ενώ εκτελείτε μια **δυναμική ανάλυση**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Αυτό είναι ένα **εξαιρετικό εργαλείο για την εκτέλεση στατικής ανάλυσης με GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Αυτό το εργαλείο έχει σχεδιαστεί για να εντοπίζει διάφορες **security related Android application vulnerabilities**, είτε στον **source code** είτε σε **packaged APKs**. Το εργαλείο είναι επίσης **capable of creating a "Proof-of-Concept" deployable APK** και **ADB commands**, για να εκμεταλλευτεί μερικές από τις εντοπισμένες ευπάθειες (Exposed activities, intents, tapjacking...). Όπως και με το Drozer, δεν υπάρχει ανάγκη να κάνετε root τη συσκευή δοκιμών.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Εμφανίζει όλα τα εξαγόμενα αρχεία για εύκολη αναφορά
- Απομεταγλωττίζει αρχεία APK αυτόματα σε μορφή Java και Smali
- Αναλύει το AndroidManifest.xml για κοινές ευπάθειες και συμπεριφορά
- Στατική ανάλυση πηγαίου κώδικα για κοινές ευπάθειες και συμπεριφορά
- Πληροφορίες συσκευής
- και άλλα
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

Το SUPER είναι μια εφαρμογή γραμμής εντολών που μπορεί να χρησιμοποιηθεί σε Windows, MacOS X και Linux, και αναλύει αρχεία _.apk_ αναζητώντας ευπάθειες. Το κάνει αυτό αποσυμπιέζοντας APKs και εφαρμόζοντας μια σειρά κανόνων για να εντοπίσει αυτές τις ευπάθειες.

Όλοι οι κανόνες βρίσκονται σε ένα αρχείο `rules.json`, και κάθε εταιρεία ή δοκιμαστής μπορεί να δημιουργήσει τους δικούς της κανόνες για να αναλύσει ό,τι χρειάζεται.

Κατεβάστε τα τελευταία binaries από τη [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn είναι ένα **crossplatform** εργαλείο που βοηθά προγραμματιστές, bugbounty hunters και ethical hackers να πραγματοποιούν [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) σε εφαρμογές για κινητά.

Η ιδέα είναι ότι σύρετε και αφήνετε το αρχείο της εφαρμογής σας για κινητά (ένα .apk ή .ipa αρχείο) στην εφαρμογή StaCoAn και αυτή θα δημιουργήσει για εσάς μια οπτική και φορητή αναφορά. Μπορείτε να τροποποιήσετε τις ρυθμίσεις και τα wordlists για να έχετε μια εξατομικευμένη εμπειρία.

Λήψη[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

Το AndroBugs Framework είναι ένα Android vulnerability analysis σύστημα που βοηθά προγραμματιστές ή hackers να εντοπίσουν πιθανές security vulnerabilities σε Android εφαρμογές.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** είναι ένα εργαλείο του οποίου ο κύριος στόχος είναι να εντοπίζει και να προειδοποιεί τον χρήστη για πιθανές κακόβουλες συμπεριφορές που μπορεί να αναπτύξει μια Android εφαρμογή.

Η ανίχνευση πραγματοποιείται με την **static analysis** του Dalvik bytecode της εφαρμογής, που αντιπροσωπεύεται ως **Smali**, χρησιμοποιώντας τη βιβλιοθήκη [`androguard`](https://github.com/androguard/androguard).

Το εργαλείο αυτό αναζητά **συνηθισμένες συμπεριφορές των «κακόβουλων» εφαρμογών** όπως: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** είναι ένα Framework για Mobile Application Reverse engineering και Analysis. Είναι ένα εργαλείο που συγκεντρώνει κοινώς χρησιμοποιούμενα εργαλεία για reverse engineering και ανάλυση mobile εφαρμογών, για να βοηθήσει στη δοκιμή mobile εφαρμογών έναντι των OWASP mobile security threats. Στόχος του είναι να κάνει αυτή την εργασία πιο εύκολη και φιλική για προγραμματιστές mobile εφαρμογών και security professionals.

Μπορεί να:

- Εξάγει Java και Smali κώδικα χρησιμοποιώντας διάφορα εργαλεία
- Αναλύει APKs χρησιμοποιώντας: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Εξάγει ιδιωτικές πληροφορίες από το APK χρησιμοποιώντας regexps.
- Αναλύει το Manifest.
- Αναλύει τα εντοπισμένα domains χρησιμοποιώντας: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) και [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK μέσω [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Χρήσιμο για τον εντοπισμό malware: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Note that depending the service and configuration you use to obfuscate the code. Secrets may or may not ended obfuscated.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. It is able to optimize bytecode as well as detect and remove unused instructions. ProGuard is free software and is distributed under the GNU General Public License, version 2.

ProGuard is distributed as part of the Android SDK and runs when building the application in release mode.

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Last time we checked, the Dexguard mode of operation was:

- φορτώνει ένα resource ως InputStream;
- τροφοδοτεί το αποτέλεσμα σε μια κλάση που κληρονομεί από FilterInputStream για να το decrypt;
- κάνει κάποια άχρηστη obfuscation για να σπαταλήσει μερικά λεπτά από τον reverser;
- τροφοδοτεί το decrypted αποτέλεσμα σε ένα ZipInputStream για να πάρει ένα DEX αρχείο;
- τέλος φορτώνει το προκύπτον DEX ως Resource χρησιμοποιώντας τη μέθοδο `loadDex`.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

Μπορείτε να ανεβάσετε ένα obfuscated APK στην πλατφόρμα τους.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

It is a **generic android deobfuscator.** Simplify **virtually executes an app** to understand its behavior and then **tries to optimize the code** so it behaves identically but is easier for a human to understand. Each optimization type is simple and generic, so it doesn't matter what the specific type of obfuscation is used.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD gives you information about **how an APK was made**. It identifies many **compilers**, **packers**, **obfuscators**, and other weird stuff. It's [_PEiD_](https://www.aldeid.com/wiki/PEiD) for Android.

### Manual

[Διαβάστε αυτό το tutorial για να μάθετε μερικά κόλπα στο **πώς να reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b είναι μια Android security virtual machine βασισμένη σε ubuntu-mate που περιλαμβάνει μια συλλογή από τα πιο πρόσφατα framework, tutorials και labs από διάφορους security geeks και researchers για reverse engineering και malware analysis.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Είναι μια εξαιρετική λίστα πόρων
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Σύντομο μάθημα Android
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)

## Yet to try

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
