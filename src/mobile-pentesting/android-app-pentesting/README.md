# Pentesting di Applicazioni Android

{{#include ../../banners/hacktricks-training.md}}

## Nozioni di base sulle Applicazioni Android

Si consiglia vivamente di iniziare leggendo questa pagina per conoscere le **parti più importanti relative alla sicurezza Android e i componenti più pericolosi in un'applicazione Android**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Questo è lo strumento principale di cui hai bisogno per connetterti a un dispositivo Android (emulato o fisico).\
**ADB** permette di controllare i dispositivi sia via **USB** che tramite **Network** da un computer. Questa utility consente la **copia** di file in entrambe le direzioni, l'**installazione** e la **disinstallazione** di app, l'**esecuzione** di comandi shell, il **backup** dei dati, la **lettura** dei log, tra le altre funzioni.

Dai un'occhiata alla seguente lista di [**ADB Commands**](adb-commands.md) per imparare come usare adb.

## Smali

A volte è utile **modificare il codice dell'applicazione** per accedere a **informazioni nascoste** (magari password molto offuscate o flag). In tal caso, può essere interessante decompilare l'apk, modificare il codice e ricompilarlo.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Questo può essere molto utile come **alternativa per diversi test durante l'analisi dinamica** che verranno presentati. Quindi, **tieni sempre presente questa possibilità**.

## Altri trucchi interessanti

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Play Integrity attestation spoofing (SafetyNet replacement)](play-integrity-attestation-bypass.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [Android IME / InputMethodService Abuse (Malicious Keyboards)](inputmethodservice-ime-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Extract APK from device:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Unisci tutti gli splits e gli apks di base con [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Android Enterprise & Work Profile Attacks

{{#ref}}
android-enterprise-work-profile-bypass.md
{{#endref}}

## Casi di studio e vulnerabilità


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

{{#ref}}
abusing-android-media-pipelines-image-parsers.md
{{#endref}}

{{#ref}}
../../binary-exploitation/linux-kernel-exploitation/arm64-static-linear-map-kaslr-bypass.md
{{#endref}}

## Analisi statica

Per prima cosa, per analizzare un APK dovresti **dare un'occhiata al codice Java** usando un decompiler.\
Per favore, [**leggi qui per trovare informazioni sui diversi decompiler disponibili**](apk-decompilers.md).

### Ricerca di informazioni interessanti

Semplicemente esaminando le **strings** dell'APK puoi cercare **password**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** e qualsiasi cosa interessante... cerca anche backdoor di esecuzione di codice o backdoor di autenticazione (credenziali admin hardcoded nell'app).

**Firebase**

Presta particolare attenzione agli **firebase URLs** e verifica se è mal configurato. [Maggiori informazioni su cos'è Firebase e come sfruttarlo qui.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Comprensione di base dell'applicazione - Manifest.xml, strings.xml

L'**esame del _Manifest.xml_ e dei file **_strings.xml_** di un'applicazione può rivelare potenziali vulnerabilità di sicurezza**. Questi file possono essere accessi usando decompiler o rinominando l'estensione dell'APK in .zip e poi decomprimendo.

Le **vulnerabilità** identificate dal **Manifest.xml** includono:

- **Debuggable Applications**: Le applicazioni impostate come debuggable (`debuggable="true"`) nel file _Manifest.xml_ rappresentano un rischio poiché permettono connessioni che possono portare a sfruttamenti. Per approfondire come sfruttare applicazioni debuggable, consulta un tutorial su come trovare e sfruttare applicazioni debuggable su un dispositivo.
- **Backup Settings**: L'attributo `android:allowBackup="false"` dovrebbe essere esplicitamente impostato per le applicazioni che trattano informazioni sensibili per prevenire backup non autorizzati dei dati tramite adb, specialmente quando usb debugging è abilitato.
- **Network Security**: Le configurazioni di sicurezza di rete personalizzate (`android:networkSecurityConfig="@xml/network_security_config"`) in _res/xml/_ possono specificare dettagli di sicurezza come certificate pins e impostazioni per il traffico HTTP. Un esempio è permettere traffico HTTP per domini specifici.
- **Exported Activities and Services**: Identificare le attività e i servizi esportati nel manifest può evidenziare componenti che potrebbero essere abusati. Un'analisi più approfondita durante i test dinamici può rivelare come sfruttare questi componenti.
- **Content Providers and FileProviders**: I content provider esposti potrebbero consentire accessi non autorizzati o modifiche ai dati. Anche la configurazione dei FileProviders dovrebbe essere esaminata.
- **Broadcast Receivers and URL Schemes**: Questi componenti potrebbero essere sfruttati per attacchi, con particolare attenzione a come gli URL schemes gestiscono l'input e alle possibili vulnerabilità.
- **SDK Versions**: Gli attributi `minSdkVersion`, `targetSDKVersion` e `maxSdkVersion` indicano le versioni Android supportate, sottolineando l'importanza di non supportare versioni Android obsolete e vulnerabili.

Dal file **strings.xml** possono essere scoperte informazioni sensibili come chiavi API, custom schemas e altre note degli sviluppatori, sottolineando la necessità di un'attenta revisione di queste risorse.

### Tapjacking

**Tapjacking** è un attacco in cui una **malicious application** viene lanciata e **si posiziona sopra una victim application**. Una volta che oscura visibilmente l'app vittima, la sua interfaccia utente è progettata in modo da ingannare l'utente affinché interagisca con essa, mentre inoltra l'interazione all'app vittima.\
Di fatto, sta **accecando l'utente impedendogli di sapere che sta effettivamente eseguendo azioni sull'app vittima**.

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Un'**activity** con il **`launchMode`** impostato su **`singleTask` senza alcun `taskAffinity`** definito è vulnerabile al task Hijacking. Questo significa che un'**application** può essere installata e, se lanciata prima della vera applicazione, potrebbe **hijackare il task della vera applicazione** (quindi l'utente interagirà con la **malicious application pensando di usare quella reale**).

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Archiviazione dati non sicura

**Internal Storage**

In Android, i file **stored** in **internal** storage sono **designed** per essere **accessible** esclusivamente dall'**app** che li ha **created**. Questa misura di sicurezza è **enforced** dal sistema operativo Android ed è generalmente adeguata per le esigenze di sicurezza della maggior parte delle applicazioni. Tuttavia, gli sviluppatori a volte utilizzano modalità come `MODE_WORLD_READABLE` e `MODE_WORLD_WRITABLE` per **allow** la condivisione di file tra diverse applicazioni. Queste modalità però **non limitano l'accesso** a questi file da altre applicazioni, incluse potenzialmente applicazioni malevole.

1. **Analisi statica:**
- **Verifica** che l'uso di `MODE_WORLD_READABLE` e `MODE_WORLD_WRITABLE` sia **attentamente scrutinato**. Queste modalità **possono esporre** i file a **accessi non intenzionati o non autorizzati**.
2. **Analisi dinamica:**
- **Controlla** i **permessi** impostati sui file creati dall'app. In particolare, **verifica** se qualche file è **impostato come leggibile o scrivibile worldwide**. Questo può rappresentare un rischio significativo per la sicurezza, poiché consentirebbe a **qualsiasi applicazione** installata sul dispositivo, indipendentemente dalla sua origine o intenzione, di **leggere o modificare** tali file.

**External Storage**

Quando si lavora con file su **external storage**, come SD Card, è opportuno prendere alcune precauzioni:

1. **Accessibilità**:
- I file su external storage sono **globalmente leggibili e scrivibili**. Ciò significa che qualsiasi applicazione o utente può accedere a questi file.
2. **Problemi di sicurezza**:
- Data la facilità di accesso, è consigliato **non memorizzare informazioni sensibili** su external storage.
- L'external storage può essere rimosso o accessibile da qualsiasi applicazione, rendendolo meno sicuro.
3. **Gestione dei dati provenienti da external storage**:
- Esegui sempre **input validation** sui dati recuperati dall'external storage. Questo è cruciale perché i dati provengono da una fonte non attendibile.
- È fortemente sconsigliato memorizzare eseguibili o class files su external storage per il dynamic loading.
- Se la tua applicazione deve recuperare file eseguibili da external storage, assicurati che questi file siano **signed and cryptographically verified** prima di essere caricati dinamicamente. Questo passaggio è vitale per mantenere l'integrità di sicurezza della tua applicazione.

External storage può essere **accessed** in /storage/emulated/0 , /sdcard , /mnt/sdcard

> [!TIP]
> A partire da Android 4.4 (**API 17**), la SD card ha una struttura di directory che **limita l'accesso da un'app alla directory specifica per quell'app**. Questo impedisce a un'applicazione malevola di ottenere accesso in lettura o scrittura ai file di un'altra app.

**Sensitive data stored in clear-text**

- **Shared preferences**: Android permette a ogni applicazione di salvare facilmente file xml nel percorso `/data/data/<packagename>/shared_prefs/` e talvolta è possibile trovare informazioni sensibili in clear-text in quella cartella.
- **Databases**: Android permette a ogni applicazione di salvare facilmente database sqlite nel percorso `/data/data/<packagename>/databases/` e talvolta è possibile trovare informazioni sensibili in clear-text in quella cartella.

### Broken TLS

**Accept All Certificates**

Per qualche motivo a volte gli sviluppatori accettano tutti i certificati anche se, ad esempio, l'hostname non corrisponde, con righe di codice come la seguente:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Un buon modo per testare questo è provare a catturare il traffico usando un proxy come Burp senza autorizzare Burp CA sul dispositivo. Inoltre, puoi generare con Burp un certificato per un hostname diverso e usarlo.

### Crittografia debole

**Processi di gestione delle chiavi inadeguati**

Alcuni sviluppatori salvano dati sensibili nello storage locale e li criptano con una chiave hardcoded/prevedibile nel codice. Questo non dovrebbe essere fatto, perché il reverse engineering potrebbe permettere agli attaccanti di estrarre le informazioni riservate.

**Uso di algoritmi insicuri e/o deprecati**

Gli sviluppatori non dovrebbero usare **algoritmi deprecati** per eseguire controlli di autorizzazione, **memorizzare** o **inviare** dati. Alcuni di questi algoritmi sono: RC4, MD4, MD5, SHA1... Se vengono usati gli **hash** per memorizzare le password per esempio, dovrebbero essere usati hash resistenti al brute-force con salt.

### Altri controlli

- È consigliato **offuscare l'APK** per rendere più difficile il lavoro di reverse engineering agli attaccanti.
- Se l'app è sensibile (come le app bancarie), dovrebbe eseguire i propri controlli per verificare se il dispositivo è rooted e comportarsi di conseguenza.
- Se l'app è sensibile (come le app bancarie), dovrebbe verificare se viene usato un **emulatore**.
- Se l'app è sensibile (come le app bancarie), dovrebbe **verificare la propria integrità prima dell'esecuzione** per controllare se è stata modificata.
- Use [**APKiD**](https://github.com/rednaga/APKiD) to check which compiler/packer/obfuscator was used to build the APK

### Applicazione React Native

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Applicazioni Xamarin

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

Lo strumento [**mariana-trench**](https://github.com/facebook/mariana-trench) è capace di trovare **vulnerabilità** scansionando il **codice** dell'applicazione. Questo strumento contiene una serie di **known sources** (che indicano allo strumento i **punti** dove l'**input** è **controllato dall'utente**), **sinks** (che indicano allo strumento i **punti pericolosi** dove input malevoli potrebbero causare danni) e **regole**. Queste regole indicano la **combinazione** di **sources-sinks** che segnala una vulnerabilità.

Con questa conoscenza, **mariana-trench esaminerà il codice e troverà possibili vulnerabilità al suo interno**.

### Secrets leaked

An application may contain secrets (API keys, passwords, hidden urls, subdomains...) inside of it that you might be able to discover. You could us a tool such as [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Altre funzioni interessanti

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)
- In-memory native code execution via JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Analisi dinamica

> Innanzitutto, hai bisogno di un ambiente dove poter installare l'applicazione e tutto l'ambiente (Burp CA cert, Drozer e Frida principalmente). Pertanto, un dispositivo rooted (emulato o meno) è estremamente raccomandato.

### Analisi dinamica online

You can create a **free account** in: [https://appetize.io/](https://appetize.io). This platform allows you to **upload** and **execute** APKs, so it is useful to see how an apk is behaving.

You can even **see the logs of your application** in the web and connect through **adb**.

![](<../../images/image (831).png>)

Grazie alla connessione ADB puoi usare **Drozer** e **Frida** all'interno degli emulatori.

### Analisi dinamica locale

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (Puoi creare **x86** e **arm** devices, and according to [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** versions **support ARM libraries** without needing an slow arm emulator).
- Learn to set it up in this page:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, you need to create an account. _It's recommend to **download** the version **WITH**_ _**VirtualBox** to avoid potential errors._)
- [**Nox**](https://es.bignox.com) (Free, but it doesn't support Frida or Drozer).

> [!TIP]
> Quando crei un nuovo emulatore su qualsiasi piattaforma ricordati che più lo schermo è grande, più lento sarà l'emulatore. Quindi seleziona schermi piccoli, se possibile.

Per **installare google services** (like AppStore) in Genymotion devi cliccare sul pulsante evidenziato in rosso nell'immagine seguente:

![](<../../images/image (277).png>)

Inoltre, nota che nella **configurazione della VM Android in Genymotion** puoi selezionare **Bridge Network mode** (questo sarà utile se ti connetterai alla VM Android da un'altra VM con gli strumenti).

#### Uso di un dispositivo fisico

Hai bisogno di attivare le opzioni di **debugging** e sarebbe utile se potessi **rootarlo**:

1. **Settings**.
2. (Da Android 8.0) Seleziona **System**.
3. Seleziona **About phone**.
4. Premi **Build number** 7 volte.
5. Torna indietro e troverai le **Developer options**.

> Una volta installata l'applicazione, la prima cosa che dovresti fare è provarla, investigare cosa fa, come funziona e prenderti confidenza con essa.\
> Ti suggerisco di **eseguire questa analisi dinamica iniziale usando MobSF dynamic analysis + pidcat**, così saremo in grado di **imparare come funziona l'applicazione** mentre MobSF **cattura** molti **dati** **interessanti** che potrai rivedere in seguito.

Note rapide Magisk/Zygisk (raccomandato su dispositivi Pixel)
- Applica una patch a boot.img con l'app Magisk e flashala via fastboot per ottenere systemless root
- Enable Zygisk + DenyList per nascondere il root; considera LSPosed/Shamiko quando è richiesto un hiding più forte
- Conserva il boot.img originale per recuperare dopo gli OTA; esegui nuovamente la patch dopo ogni OTA
- Per il mirroring dello schermo, usa scrcpy sull'host



### Unintended Data Leakage

**Logging**

Gli sviluppatori dovrebbero fare attenzione a esporre pubblicamente **debugging information**, poiché può portare a sensitive data leaks. Gli strumenti [**pidcat**](https://github.com/JakeWharton/pidcat) e `adb logcat` sono raccomandati per monitorare i log dell'applicazione per identificare e proteggere informazioni sensibili. **Pidcat** è preferito per la sua facilità d'uso e leggibilità.

> [!WARNING]
> Nota che da **versioni successive a Android 4.0**, **le applicazioni possono accedere solamente ai propri log**. Quindi le applicazioni non possono accedere ai log di altre app.\
> Comunque, è comunque raccomandato di **non loggare informazioni sensibili**.

**Copy/Paste Buffer Caching**

Il framework **clipboard-based** di Android abilita la funzionalità di copia/incolla nelle app, ma presenta un rischio poiché **altre applicazioni** possono **accedere** agli appunti, esponendo potenzialmente dati sensibili. È cruciale **disabilitare le funzioni di copia/incolla** per sezioni sensibili dell'applicazione, come i dettagli delle carte di credito, per prevenire data leaks.

**Crash Logs**

Se un'applicazione **crasha** e **salva log**, questi log possono aiutare gli attaccanti, particolarmente quando l'app non può essere reverse-engineered. Per mitigare questo rischio, evita di loggare in caso di crash, e se i log devono essere trasmessi sulla rete, assicurati che siano inviati tramite un canale SSL per sicurezza.

As pentester, **cerca di dare un'occhiata a questi log**.

**Analytics Data Sent To 3rd Parties**

Le applicazioni spesso integrano servizi come Google Adsense, che possono involontariamente **leak sensitive data** a causa di implementazioni improprie da parte degli sviluppatori. Per identificare potenziali data leaks, è consigliabile **intercettare il traffico dell'applicazione** e verificare se informazioni sensibili vengono inviate a servizi di terze parti.

### SQLite DBs

La maggior parte delle applicazioni userà **internal SQLite databases** per salvare informazioni. Durante il pentest dai un'occhiata alle **databases** create, ai nomi delle **tables** e delle **columns** e a tutti i **data** salvati perché potresti trovare **informazioni sensibili** (che costituirebbero una vulnerabilità).\
I database dovrebbero trovarsi in `/data/data/the.package.name/databases` come `/data/data/com.mwr.example.sieve/databases`

Se il database salva informazioni riservate ed è **crittografato**, ma puoi **trovare** la **password** all'interno dell'applicazione, è comunque una **vulnerabilità**.

Enumera le tables usando `.tables` ed enumera le columns delle tables usando `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer è uno strumento utile per **exploitare exported activities, exported services and Content Providers** come imparerai nelle sezioni seguenti.

### Sfruttare le Activity esportate

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Ricorda anche che il codice di un'Activity inizia nel metodo **`onCreate`**.

**Authorisation bypass**

Quando un'Activity è exported puoi richiamare la sua schermata da un'app esterna. Quindi, se un'Activity contenente **informazioni sensibili** è **exported** potresti **bypassare** i meccanismi di **authentication** per **accedervi**.

[**Scopri come sfruttare le activity esportate con Drozer.**](drozer-tutorial/index.html#activities)

Puoi anche avviare un'attività exported da adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF rileverà come malicious l'uso di _**singleTask/singleInstance**_ come `android:launchMode` in un activity, ma a causa di [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparentemente questo è pericoloso solo su versioni vecchie (API versions < 21).

> [!TIP]
> Nota che un authorisation bypass non è sempre una vulnerabilità; dipende da come funziona il bypass e quali informazioni sono esposte.

**Perdita di informazioni sensibili**

**Activities can also return results**. Se riesci a trovare un'activity esportata e non protetta che chiama il metodo **`setResult`** e **restituisce informazioni sensibili**, si verifica una perdita di informazioni sensibili.

#### Tapjacking

Se Tapjacking non è prevenuto, potresti abusare dell'activity esportata per far sì che l'**utente esegua azioni inaspettate**. Per maggiori informazioni su [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers sono fondamentalmente usati per **condividere dati**. Se un'app ha content providers disponibili potresti essere in grado di **estrarre dati sensibili** da essi. È anche interessante testare possibili **SQL injections** e **Path Traversals** poiché potrebbero essere vulnerabili.

[**Scopri come sfruttare i Content Providers con Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Ricorda che le azioni di un Service iniziano nel metodo `onStartCommand`.

Un Service è fondamentalmente qualcosa che **può ricevere dati**, **elaborarli** e **restituire** (o no) una risposta. Quindi, se un'applicazione esporta dei services dovresti **controllare** il **codice** per capire cosa sta facendo e **testarlo** **dinamicamente** per estrarre informazioni riservate, eludere misure di autenticazione...\
[**Scopri come sfruttare i Services con Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Ricorda che le azioni di un Broadcast Receiver iniziano nel metodo `onReceive`.

Un broadcast receiver aspetta un tipo di messaggio. A seconda di come il receiver gestisce il messaggio, potrebbe essere vulnerabile.\
[**Scopri come sfruttare i Broadcast Receivers con Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Puoi cercare i deep links manualmente, usando strumenti come MobSF o script come [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Puoi **aprire** uno **scheme** dichiarato usando **adb** o un **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Nota che puoi **omettere il nome del package** e il dispositivo mobile chiamerà automaticamente l'app che dovrebbe aprire quel link._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Codice eseguito**

Per trovare il **codice che verrà eseguito nell'App**, vai all'activity chiamata dal deeplink e cerca la funzione **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Informazioni sensibili**

Ogni volta che trovi un deep link verifica che **non stia ricevendo dati sensibili (come password) tramite parametri URL**, perché qualsiasi altra applicazione potrebbe **impersonate the deep link and steal that data!**

**Parametri nel path**

Devi anche verificare se un deep link sta usando un parametro all'interno del path dell'URL come: `https://api.example.com/v1/users/{username}` , in tal caso puoi forzare un path traversal accedendo a qualcosa come: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Nota che se trovi gli endpoint corretti all'interno dell'applicazione potresti essere in grado di causare un **Open Redirect** (se parte del path è usata come domain name), **account takeover** (se puoi modificare i dettagli degli utenti senza CSRF token e l'endpoint vuln usava il metodo corretto) e qualsiasi altra vuln. More [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Transport Layer Inspection and Verification Failures

- **I certificati non sono sempre ispezionati correttamente** dalle applicazioni Android. È comune che queste applicazioni ignorino gli avvisi e accettino certificati self-signed o, in alcuni casi, tornino a usare connessioni HTTP.
- **Le negoziazioni durante l'handshake SSL/TLS sono talvolta deboli**, impiegando cipher suite insicure. Questa vulnerabilità rende la connessione suscettibile ad attacchi man-in-the-middle (MITM), permettendo agli attaccanti di decrittare i dati.
- **La perdita di informazioni private** è un rischio quando le applicazioni si autenticano usando canali sicuri ma poi comunicano su canali non sicuri per altre transazioni. Questo approccio non protegge i dati sensibili, come i cookie di sessione o i dettagli dell'utente, dall'intercettazione da parte di entità malevole.

#### Certificate Verification

Ci concentreremo su **certificate verification**. L'integrità del certificato del server deve essere verificata per aumentare la sicurezza. Questo è cruciale perché configurazioni TLS insicure e la trasmissione di dati sensibili su canali non cifrati possono rappresentare rischi significativi. Per passaggi dettagliati su come verificare i certificati del server e affrontare le vulnerabilità, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) fornisce una guida completa.

#### SSL Pinning

SSL Pinning è una misura di sicurezza in cui l'applicazione verifica il certificato del server contro una copia nota memorizzata all'interno dell'app stessa. Questo metodo è essenziale per prevenire attacchi MITM. Implementare SSL Pinning è fortemente raccomandato per le applicazioni che gestiscono informazioni sensibili.

#### Traffic Inspection

Per ispezionare il traffico HTTP è necessario **installare il certificato dello strumento proxy** (es. Burp). Senza installare questo certificato, il traffico cifrato potrebbe non essere visibile tramite il proxy. Per una guida su come installare una CA custom, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Le applicazioni targettizzate a **API Level 24 and above** richiedono modifiche alla Network Security Config per accettare la CA del proxy. Questo passaggio è critico per ispezionare il traffico cifrato. Per istruzioni su come modificare la Network Security Config, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

Se viene usato **Flutter** devi seguire le istruzioni in [**this page**](flutter.md). Questo perché, aggiungere semplicemente il certificato nello store non funzionerà poiché Flutter ha la propria lista di CA valide.

#### Static detection of SSL/TLS pinning

Prima di tentare bypass a runtime, mappa rapidamente dove il pinning è applicato nell'APK. La scoperta statica ti aiuta a pianificare hooks/patches e a concentrarti sui percorsi di codice corretti.

Tool: SSLPinDetect
- Utility open-source di static-analysis che decompila l'APK in Smali (via apktool) e scansiona pattern regex curati di implementazioni di SSL/TLS pinning.
- Riporta il percorso file esatto, il numero di riga e uno snippet di codice per ogni match.
- Copre framework comuni e percorsi di codice custom: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init con custom TrustManagers/KeyManagers, e pin in Network Security Config XML.

Installazione
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Uso
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Esempio di regole di pattern (JSON)
Usa o estendi signatures per rilevare stili di pinning proprietari/personalizzati. Puoi caricare il tuo JSON e scansionare su larga scala.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Note e suggerimenti
- Scansione veloce di app di grandi dimensioni tramite multi-threading e I/O memory-mapped; regex pre-compilate riducono overhead e falsi positivi.
- Raccolta pattern: https://github.com/aancw/smali-sslpin-patterns
- Target tipici da analizzare successivamente:
- OkHttp: uso di CertificatePinner, setCertificatePinner, riferimenti al package okhttp3/okhttp
- TrustManager personalizzati: javax.net.ssl.X509TrustManager, override di checkServerTrusted
- Contesti SSL personalizzati: SSLContext.getInstance + SSLContext.init con manager personalizzati
- Pin dichiarative in res/xml network security config e riferimenti nel manifest
- Usa le posizioni corrispondenti per pianificare Frida hooks, patch statici, o revisioni della configurazione prima del testing dinamico.



#### Bypassare SSL Pinning

Quando SSL Pinning è implementato, diventa necessario bypassarlo per ispezionare il traffico HTTPS. Sono disponibili vari metodi per questo scopo:

- **Modifica** automaticamente l'**apk** per **bypassare** SSLPinning con [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Il vantaggio principale di questa opzione è che non servirà root per bypassare SSL Pinning, ma dovrai eliminare l'applicazione e reinstallare quella modificata, e non sempre funzionerà.
- Puoi usare **Frida** (discusso sotto) per bypassare questa protezione. Qui trovi una guida per usare Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Puoi anche provare a bypassare automaticamente SSL Pinning usando [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Puoi anche provare a bypassare automaticamente SSL Pinning usando **MobSF dynamic analysis** (spiegato sotto)
- Se pensi che ci sia traffico che non stai catturando, puoi provare a inoltrare il traffico a Burp usando iptables. Leggi questo blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Ricerca di vulnerabilità web comuni

È importante cercare anche vulnerabilità web comuni all'interno dell'applicazione. Informazioni dettagliate sull'identificazione e la mitigazione di queste vulnerabilità esulano dal campo di questo riepilogo ma sono trattate estensivamente altrove.

### Frida

[Frida](https://www.frida.re) è un toolkit di instrumentazione dinamica per sviluppatori, reverse-engineers e ricercatori della sicurezza.\
**Puoi accedere all'applicazione in esecuzione e hookare i metodi a runtime per cambiare il comportamento, modificare valori, estrarre valori, eseguire codice diverso...**\
Se vuoi fare pentesting su applicazioni Android devi sapere come usare Frida.

- Impara a usare Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Alcune "GUI" per azioni con Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection è ottimo per automatizzare l'uso di Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Puoi trovare alcuni script Frida qui: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Prova a bypassare meccanismi anti-debug / anti-frida caricando Frida come indicato in [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & workflow di bypass SSL Pinning

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump della memoria - Fridump**

Verifica se l'applicazione sta memorizzando informazioni sensibili nella memoria che non dovrebbe conservare, come password o mnemoniche.

Usando [**Fridump3**](https://github.com/rootbsd/fridump3) puoi effettuare il dump della memoria dell'app con:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Questo eseguirà il dump della memoria nella cartella ./dump, e lì puoi usare grep con qualcosa del tipo:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Dati sensibili nel Keystore**

Su Android il Keystore è il posto migliore per memorizzare dati sensibili; tuttavia, con privilegi sufficienti è ancora **possibile accedervi**. Poiché le applicazioni tendono a memorizzare qui **sensitive data in clear text**, i pentests dovrebbero verificarlo come root user o qualcuno con accesso fisico al dispositivo potrebbe riuscire a rubare questi dati.

Anche se un'app memorizza dati nel keystore, i dati dovrebbero essere criptati.

Per accedere ai dati all'interno del keystore puoi usare questo Frida script: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Usando il seguente script Frida potrebbe essere possibile eseguire un **bypass fingerprint authentication** su applicazioni Android che servono a **proteggere alcune aree sensibili:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Immagini di sfondo**

Quando metti un'applicazione in background, Android memorizza una **snapshot of the application**, così quando viene riportata in foreground inizia a caricare l'immagine prima dell'app in modo che sembri che l'app sia stata caricata più velocemente.

Tuttavia, se questa snapshot contiene **informazioni sensibili**, qualcuno con accesso alla snapshot potrebbe **rubare quelle informazioni** (nota che è necessario root per accedervi).

Gli snapshot sono solitamente memorizzati in: **`/data/system_ce/0/snapshots`**

Android fornisce un modo per **impedire la cattura di screenshot impostando il parametro di layout FLAG_SECURE**. Usando questo flag, il contenuto della finestra viene trattato come sicuro, impedendone l'apparizione negli screenshot o la visualizzazione su display non sicuri.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Questo strumento può aiutarti a gestire diversi strumenti durante l'analisi dinamica: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Gli sviluppatori spesso creano componenti proxy come activities, services e broadcast receivers che gestiscono questi Intents e li passano a metodi come `startActivity(...)` o `sendBroadcast(...)`, il che può essere rischioso.

Il pericolo consiste nel permettere ad un attacker di triggerare componenti non-exported dell'app o accedere a content providers sensibili reindirizzando questi Intents. Un esempio notevole è il componente `WebView` che converte URL in oggetti `Intent` tramite `Intent.parseUri(...)` e poi li esegue, potenzialmente portando a malicious Intent injections.

### Essential Takeaways

- **Intent Injection** è simile al problema Open Redirect del web.
- Gli exploit prevedono il passaggio di oggetti `Intent` come extras, che possono essere reindirizzati per eseguire operazioni unsafe.
- Può esporre componenti non-exported e content providers ad attacker.
- La conversione URL -> `Intent` di `WebView` può facilitare azioni non intenzionali.

### Android Client Side Injections and others

Probabilmente conosci questo tipo di vulnerabilità dal Web. Devi essere particolarmente cauto con queste vulnerabilità in un'app Android:

- **SQL Injection:** When dealing with dynamic queries or Content-Providers ensure you are using parameterized queries.
- **JavaScript Injection (XSS):** Verifica che il supporto JavaScript e dei Plugin sia disabilitato per qualsiasi WebView (disabilitato di default). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** Le WebView dovrebbero avere l'accesso al file system disabilitato (abilitato di default) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: In diversi casi, quando l'app Android termina la sessione il cookie non viene revocato o può addirittura essere salvato su disco
- [**Secure Flag** nei cookie](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Analisi statica**

![](<../../images/image (866).png>)

Valutazione delle vulnerabilità dell'applicazione tramite una comoda interfaccia web. È anche possibile eseguire analisi dinamica (ma è necessario preparare l'ambiente).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Le applicazioni Windows devono essere analizzate da un MobSF installato su un host Windows_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Analisi dinamica assistita con MobSF

**MobSF** può anche essere molto utile per la **dynamic analysis** su **Android**, ma in questo caso dovrai installare MobSF e **genymotion** sul tuo host (una VM o Docker non funzioneranno). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
Il **MobSF dynamic analyser** può:

- **Dump application data** (URLs, logs, clipboard, screenshots fatte da te, screenshots fatte da "**Exported Activity Tester**", email, SQLite databases, file XML e altri file creati). Tutto questo viene fatto automaticamente eccetto per gli screenshot: devi premere quando vuoi uno screenshot oppure premere "**Exported Activity Tester**" per ottenere screenshot di tutte le attività esportate.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: It will print all the loaded classes
- **Capture Strings**: It will print all the capture strings while using the application (super noisy)
- **Capture String Comparisons**: Could be very useful. It will **show the 2 strings being compared** and if the result was True or False.
- **Enumerate Class Methods**: Put the class name (like "java.io.File") and it will print all the methods of the class.
- **Search Class Pattern**: Search classes by pattern
- **Trace Class Methods**: **Trace** a **whole class** (see inputs and outputs of all methods of th class). Remember that by default MobSF traces several interesting Android Api methods.

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf ti fornisce anche una shell con alcuni comandi **adb**, comandi **MobSF** e comandi comuni di **shell** nella parte bassa della pagina di dynamic analysis. Alcuni comandi interessanti:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP tools**

Quando il traffico http viene catturato puoi vedere una vista brutta del traffico catturato sul pulsante "**HTTP(S) Traffic**" in basso oppure una vista più gradevole nel pulsante verde "**Start HTTPTools**". Dalla seconda opzione, puoi **inviare** le **richieste catturate** a **proxies** come Burp o Owasp ZAP.\
Per farlo, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> premi "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Una volta terminata l'analisi dinamica con MobSF puoi premere su "**Start Web API Fuzzer**" per **fuzz http requests** e cercare vulnerabilità.

> [!TIP]
> Dopo aver eseguito un'analisi dinamica con MobSF le impostazioni del proxy potrebbero essere malconfigurate e non potrai sistemarle dall'interfaccia grafica. Puoi ripristinare le impostazioni del proxy eseguendo:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

Puoi ottenere lo strumento da [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Questo tool utilizza alcuni **Hooks** per farti sapere **cosa sta succedendo nell'applicazione** mentre esegui un'**analisi dinamica**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Questo è un **ottimo strumento per eseguire analisi statica con una GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Questo strumento è progettato per cercare diverse **vulnerabilità di sicurezza relative ad applicazioni Android**, sia nel **codice sorgente** sia negli **APK pacchettizzati**. Lo strumento è anche **in grado di creare un "Proof-of-Concept" deployable APK** e comandi **ADB**, per sfruttare alcune delle vulnerabilità trovate (Exposed activities, intents, tapjacking...). Come con Drozer, non è necessario rootare il dispositivo di test.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Visualizza tutti i file estratti per consultazione rapida
- Decompila automaticamente i file APK in formato Java e Smali
- Analizza AndroidManifest.xml alla ricerca di vulnerabilità e comportamenti comuni
- Analisi statica del codice sorgente per vulnerabilità e comportamenti comuni
- Informazioni sul dispositivo
- e altro
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER è un'applicazione da riga di comando utilizzabile su Windows, MacOS X e Linux, che analizza file _.apk_ alla ricerca di vulnerabilità. Lo fa decomprimendo gli APK e applicando una serie di regole per rilevare queste vulnerabilità.

Tutte le regole sono centralizzate in un file `rules.json`, e ogni azienda o tester può creare le proprie regole per analizzare ciò di cui ha bisogno.

Scarica i binari più recenti dalla [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn è uno strumento **crossplatform** che aiuta sviluppatori, bugbounty hunters e ethical hackers a eseguire [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) su applicazioni mobili.

Il concetto è che trascini e rilasci il file della tua applicazione mobile (un .apk o .ipa file) sull'applicazione StaCoAn e questa genererà per te un report visivo e portatile. Puoi modificare le impostazioni e le wordlists per ottenere un'esperienza personalizzata.

Scarica[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework è un sistema di analisi delle vulnerabilità per Android che aiuta sviluppatori o hackers a trovare potenziali vulnerabilità di sicurezza nelle applicazioni Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** è uno strumento il cui scopo principale è rilevare e avvisare l'utente riguardo potenziali comportamenti dannosi sviluppati da un'applicazione Android.

La rilevazione viene eseguita tramite la **static analysis** del Dalvik bytecode dell'applicazione, rappresentato come **Smali**, con la libreria [`androguard`](https://github.com/androguard/androguard).

Questo strumento cerca **comportamenti comuni di applicazioni "maligne"** come: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** è un framework per Mobile Application Reverse engineering and Analysis. È uno strumento che mette insieme strumenti comunemente usati per il reverse engineering e l'analisi di mobile application, per assistere nei test delle applicazioni mobili contro le minacce di sicurezza mobile OWASP. Il suo obiettivo è rendere questo compito più semplice e amichevole per gli sviluppatori di applicazioni mobili e i professionisti della sicurezza.

È in grado di:

- Estrarre codice Java e Smali usando diversi strumenti
- Analizzare APK usando: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Estrarre informazioni private dall'APK usando regexp.
- Analizzare il Manifest.
- Analizzare i domini trovati usando: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) e [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscare APK tramite [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Utile per rilevare malware: [https://koodous.com/](https://koodous.com/)

## Offuscamento/Deoffuscamento del codice

Nota che, a seconda del servizio e della configurazione che usi per offuscare il codice, i secrets potrebbero essere o meno offuscati.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

Da [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** è uno strumento open source da linea di comando che riduce, ottimizza e offusca il codice Java. È in grado di ottimizzare il bytecode e di rilevare e rimuovere istruzioni non utilizzate. ProGuard è software libero e viene distribuito sotto la GNU General Public License, versione 2.

ProGuard è distribuito come parte dell'Android SDK e viene eseguito quando si builda l'applicazione in modalità release.

### [DexGuard](https://www.guardsquare.com/dexguard)

Trova una guida passo-passo per deobfuscare l'apk su [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(Da quella guida) L'ultima volta che abbiamo verificato, la modalità di funzionamento di DexGuard era:

- caricare una risorsa come InputStream;
- passare il risultato a una classe che eredita da FilterInputStream per decriptarlo;
- fare qualche offuscamento inutile per far perdere qualche minuto al reverser;
- passare il risultato decriptato a ZipInputStream per ottenere un file DEX;
- infine caricare il DEX risultante come Resource usando il metodo `loadDex`.

### [DeGuard](http://apk-deguard.com)

**DeGuard inverte il processo di offuscamento eseguito dagli strumenti di offuscamento Android. Questo abilita numerose analisi di sicurezza, inclusa l'ispezione del codice e l'identificazione delle librerie.**

È possibile caricare un APK offuscato sulla loro piattaforma.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

Questo è uno strumento LLM per individuare potenziali vulnerabilità di sicurezza in app Android e deoffuscare il codice delle app. Usa la public API di Google Gemini.

### [Simplify](https://github.com/CalebFenton/simplify)

È un **deobfuscator Android generico.** Simplify **esegue virtualmente un'app** per capirne il comportamento e poi **cerca di ottimizzare il codice** in modo che si comporti in modo identico ma sia più facile da capire per un umano. Ogni tipo di ottimizzazione è semplice e generico, quindi non importa quale specifico tipo di offuscamento sia stato usato.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD fornisce informazioni su **come è stato creato un APK**. Identifica molti **compilers**, **packers**, **obfuscators**, e altre cose strane. È il [_PEiD_] per Android.

### Manuale

[Leggi questo tutorial per imparare alcuni trucchi su **come eseguire il reverse di offuscamenti personalizzati**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b è una virtual machine per la sicurezza Android basata su ubuntu-mate che include una raccolta degli ultimi framework, tutorial e lab da vari security geeks e ricercatori per reverse engineering e malware analysis.

## Riferimenti

- [Play Integrity API: How It Works & How to Bypass It](https://m4kr0.vercel.app/posts/play-integrity-api-how-it-works--how-to-bypass-it/)
- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) È una grande lista di risorse
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Corso rapido di Android RE
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
