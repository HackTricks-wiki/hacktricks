# Pentesting aplikacji Android

{{#include ../../banners/hacktricks-training.md}}

## Podstawy aplikacji Android

Zdecydowanie zaleca się rozpocząć od przeczytania tej strony, aby poznać **najważniejsze elementy związane z bezpieczeństwem Androida oraz najbardziej niebezpieczne komponenty aplikacji Android**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

To główne narzędzie, którego potrzebujesz, aby połączyć się z urządzeniem Android (emulowanym lub fizycznym).\
**ADB** pozwala kontrolować urządzenia przez **USB** lub **Network** z komputera. To narzędzie umożliwia **kopiowanie** plików w obie strony, **instalację** i **odinstalowanie** aplikacji, **wykonywanie** poleceń shell, **tworzenie kopii zapasowych** danych, **odczytywanie** logów oraz inne funkcje.

Zapoznaj się z następującą listą [**ADB Commands**](adb-commands.md), aby nauczyć się używać adb.

## Smali

Czasami warto **zmodyfikować kod aplikacji**, aby uzyskać dostęp do **ukrytych informacji** (np. dobrze obfuskowanych haseł lub flags). Wtedy może być przydatne zdekompilowanie apk, modyfikacja kodu i ponowne skompilowanie.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Może to być bardzo użyteczne jako **alternatywa dla kilku testów podczas analizy dynamicznej**, które zostaną przedstawione. Więc **zawsze miej tę możliwość na uwadze**.

## Inne ciekawe triki

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **Pobierz APK**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Wyodrębnij APK z urządzenia:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Scal wszystkie splits i base apks za pomocą [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Case Studies & Vulnerabilities


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Static Analysis

First of all, for analysing an APK you should **take a look to the to the Java code** using a decompiler.\
Please, [**read here to find information about different available decompilers**](apk-decompilers.md).

### Looking for interesting Info

Just taking a look to the **strings** of the APK you can search for **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** and anything interesting... look even for code execution **backdoors** or authentication backdoors (hardcoded admin credentials to the app).

**Firebase**

Pay special attention to **firebase URLs** and check if it is bad configured. [More information about whats is FIrebase and how to exploit it here.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Basic understanding of the application - Manifest.xml, strings.xml

The **examination of an application's _Manifest.xml_ and **_strings.xml_** files can reveal potential security vulnerabilities**. These files can be accessed using decompilers or by renaming the APK file extension to .zip and then unzipping it.

**Vulnerabilities** identified from the **Manifest.xml** include:

- **Debuggable Applications**: Applications set as debuggable (`debuggable="true"`) in the _Manifest.xml_ file pose a risk as they allow connections that can lead to exploitation. For further understanding on how to exploit debuggable applications, refer to a tutorial on finding and exploiting debuggable applications on a device.
- **Backup Settings**: The `android:allowBackup="false"` attribute should be explicitly set for applications dealing with sensitive information to prevent unauthorized data backups via adb, especially when usb debugging is enabled.
- **Network Security**: Custom network security configurations (`android:networkSecurityConfig="@xml/network_security_config"`) in _res/xml/_ can specify security details like certificate pins and HTTP traffic settings. An example is allowing HTTP traffic for specific domains.
- **Exported Activities and Services**: Identifying exported activities and services in the manifest can highlight components that might be misused. Further analysis during dynamic testing can reveal how to exploit these components.
- **Content Providers and FileProviders**: Exposed content providers could allow unauthorized access or modification of data. The configuration of FileProviders should also be scrutinized.
- **Broadcast Receivers and URL Schemes**: These components could be leveraged for exploitation, with particular attention to how URL schemes are managed for input vulnerabilities.
- **SDK Versions**: The `minSdkVersion`, `targetSDKVersion`, and `maxSdkVersion` attributes indicate the supported Android versions, highlighting the importance of not supporting outdated, vulnerable Android versions for security reasons.

From the **strings.xml** file, sensitive information such as API keys, custom schemas, and other developer notes can be discovered, underscoring the need for careful review of these resources.

### Tapjacking

**Tapjacking** is an attack where a **malicious** **application** is launched and **positions itself on top of a victim application**. Once it visibly obscures the victim app, its user interface is designed in such a way as to trick the user to interact with it, while it is passing the interaction along to the victim app.\
In effect, it is **blinding the user from knowing they are actually performing actions on the victim app**.

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

An **activity** with the **`launchMode`** set to **`singleTask` without any `taskAffinity`** defined is vulnerable to task Hijacking. This means, that an **application** can be installed and if launched before the real application it could **hijack the task of the real application** (so the user will be interacting with the **malicious application thinking he is using the real one**).

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Insecure data storage

**Internal Storage**

In Android, files **stored** in **internal** storage are **designed** to be **accessible** exclusively by the **app** that **created** them. This security measure is **enforced** by the Android operating system and is generally adequate for the security needs of most applications. However, developers sometimes utilize modes such as `MODE_WORLD_READABLE` and `MODE_WORLD_WRITABLE` to **allow** files to be **shared** between different applications. Yet, these modes **do not restrict access** to these files by other applications, including potentially malicious ones.

1. **Static Analysis:**
- **Ensure** that the use of `MODE_WORLD_READABLE` and `MODE_WORLD_WRITABLE` is **carefully scrutinized**. These modes **can potentially expose** files to **unintended or unauthorized access**.
2. **Dynamic Analysis:**
- **Verify** the **permissions** set on files created by the app. Specifically, **check** if any files are **set to be readable or writable worldwide**. This can pose a significant security risk, as it would allow **any application** installed on the device, regardless of its origin or intent, to **read or modify** these files.

**External Storage**

When dealing with files on **external storage**, such as SD Cards, certain precautions should be taken:

1. **Accessibility**:
- Files on external storage are **globally readable and writable**. This means any application or user can access these files.
2. **Security Concerns**:
- Given the ease of access, it's advised **not to store sensitive information** on external storage.
- External storage can be removed or accessed by any application, making it less secure.
3. **Handling Data from External Storage**:
- Always **perform input validation** on data retrieved from external storage. This is crucial because the data is from an untrusted source.
- Storing executables or class files on external storage for dynamic loading is strongly discouraged.
- If your application must retrieve executable files from external storage, ensure these files are **signed and cryptographically verified** before they are dynamically loaded. This step is vital for maintaining the security integrity of your application.

External storage can be **accessed** in `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> Starting with Android 4.4 (**API 17**), the SD card has a directory structure which **limits access from an app to the directory which is specifically for that app**. This prevents malicious application from gaining read or write access to another app's files.

**Sensitive data stored in clear-text**

- **Shared preferences**: Android allow to each application to easily save xml files in the path `/data/data/<packagename>/shared_prefs/` and sometimes it's possible to find sensitive information in clear-text in that folder.
- **Databases**: Android allow to each application to easily save sqlite databases in the path `/data/data/<packagename>/databases/` and sometimes it's possible to find sensitive information in clear-text in that folder.

### Broken TLS

**Accept All Certificates**

For some reason sometimes developers accept all the certificates even if for example the hostname does not match with lines of code like the following one:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Zła kryptografia

**Słabe procesy zarządzania kluczami**

Niektórzy deweloperzy zapisują dane wrażliwe w local storage i szyfrują je z użyciem klucza hardcoded/predictable w kodzie. Nie powinno się tego robić, ponieważ pewne techniki reversingowe mogą pozwolić atakującym na wydobycie poufnych informacji.

**Użycie niebezpiecznych i/lub przestarzałych algorytmów**

Deweloperzy nie powinni używać **przestarzałych algorytmów** do wykonywania **sprawdzeń autoryzacji**, **przechowywania** lub **wysyłania** danych. Niektóre z tych algorytmów to: RC4, MD4, MD5, SHA1... Jeśli **hashes** są używane do przechowywania haseł na przykład, powinny być stosowane hashe odporne na **brute-force** z użyciem salt.

### Inne kontrole

- Zaleca się **obfuskować APK**, aby utrudnić pracę reverse engineerom.
- Jeśli aplikacja jest wrażliwa (np. aplikacje bankowe), powinna wykonywać **własne kontrole, czy urządzenie jest rooted** i działać odpowiednio.
- Jeśli aplikacja jest wrażliwa (np. aplikacje bankowe), powinna sprawdzać, czy używany jest **emulator**.
- Jeśli aplikacja jest wrażliwa (np. aplikacje bankowe), powinna **sprawdzić swoją integralność przed uruchomieniem**, aby wykryć, czy została zmodyfikowana.
- Użyj [**APKiD**](https://github.com/rednaga/APKiD) aby sprawdzić, który compiler/packer/obfuscator został użyty do zbudowania APK

### Aplikacja React Native

Przeczytaj następującą stronę aby dowiedzieć się jak w prosty sposób uzyskać dostęp do kodu javascript aplikacji React:


{{#ref}}
react-native-application.md
{{#endref}}

### Aplikacje Xamarin

Przeczytaj następującą stronę aby dowiedzieć się jak w prosty sposób uzyskać dostęp do kodu C# aplikacji xamarin:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

Zgodnie z tym [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked to algorytm Meta, który kompresuje zawartość aplikacji do pojedynczego pliku. Blog opisuje możliwość stworzenia aplikacji, która dekompresuje tego typu aplikacje... oraz szybszy sposób polegający na **uruchomieniu aplikacji i zebraniu zdekompresowanych plików z filesystemu.**

### Zautomatyzowana statyczna analiza kodu

Narzędzie [**mariana-trench**](https://github.com/facebook/mariana-trench) jest w stanie znaleźć **vulnerabilities** poprzez **skanowanie** **kodu** aplikacji. To narzędzie zawiera serię **known sources** (które wskazują narzędziu **miejsce**, gdzie **wejście** jest **kontrolowane przez użytkownika**), **sinks** (które wskazują narzędziu **niebezpieczne** **miejsca**, gdzie złośliwe dane wejściowe mogą wyrządzić szkody) oraz **rules**. Te rules wskazują **kombinacje** **sources-sinks**, które sygnalizują podatność.

Z tą wiedzą, **mariana-trench przejrzy kod i znajdzie możliwe podatności w nim**.

### Secrets leaked

Aplikacja może zawierać secrets (API keys, passwords, hidden urls, subdomains...) wewnątrz, które możesz być w stanie odkryć. Możesz użyć narzędzia takiego jak [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Obejście uwierzytelniania biometrycznego


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Inne interesujące funkcje

- **Wykonanie kodu**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Wysyłanie SMS-ów**: `sendTextMessage, sendMultipartTestMessage`
- **Funkcje natywne** zadeklarowane jako `native`: `public native, System.loadLibrary, System.load`
- [Przeczytaj to aby dowiedzieć się **jak reverse native functions**](reversing-native-libraries.md)

### **Inne sztuczki**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Analiza dynamiczna

> Przede wszystkim potrzebujesz środowiska, w którym możesz zainstalować aplikację i całe otoczenie (Burp CA cert, Drozer and Frida głównie). Dlatego zalecane jest użycie rooted device (emulowane lub nie).

### Analiza dynamiczna online

Możesz założyć **darmowe konto** na: [https://appetize.io/](https://appetize.io). Ta platforma pozwala **upload** i **execute** APKs, więc jest przydatna do obserwowania zachowania apk.

Możesz nawet **zobaczyć logi swojej aplikacji** w przeglądarce i połączyć się przez **adb**.

![](<../../images/image (831).png>)

Dzięki połączeniu ADB możesz używać **Drozer** i **Frida** wewnątrz emulatorów.

### Lokalna analiza dynamiczna

#### Używanie emulatora

- [**Android Studio**](https://developer.android.com/studio) (Możesz tworzyć urządzenia **x86** i **arm**, i zgodnie z [**tym** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**najnowsze x86** wersje **wspierają biblioteki ARM** bez potrzeby używania wolnego emulátora ARM).
- Naucz się jak je skonfigurować na tej stronie:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(wersja darmowa:** Personal Edition, trzeba założyć konto. _Zaleca się **pobrać** wersję **Z**_ _**VirtualBox** aby uniknąć potencjalnych błędów._)
- [**Nox**](https://es.bignox.com) (Darmowy, ale nie wspiera Frida ani Drozer).

> [!TIP]
> Przy tworzeniu nowego emulatora na jakiejkolwiek platformie pamiętaj, że im większy ekran, tym emulator będzie działał wolniej. Wybieraj więc małe ekrany, jeśli to możliwe.

Aby **zainstalować google services** (jak AppStore) w Genymotion musisz kliknąć w czerwony przycisk zaznaczony na poniższym obrazie:

![](<../../images/image (277).png>)

Zauważ też, że w **konfiguracji maszyny Android w Genymotion** możesz wybrać **Bridge Network mode** (to będzie przydatne jeśli będziesz łączyć się z Android VM z innej VM z narzędziami).

#### Użycie urządzenia fizycznego

Musisz aktywować **opcje debugowania**, a będzie dobrze, jeśli będziesz mógł je **zrootować**:

1. **Ustawienia**.
2. (Od Android 8.0) Wybierz **System**.
3. Wybierz **Informacje o telefonie**.
4. Naciśnij **Numer kompilacji** 7 razy.
5. Wróć i znajdziesz **Opcje programisty**.

> Po zainstalowaniu aplikacji, pierwszą rzeczą jaką powinieneś zrobić jest jej przetestowanie i zbadanie co robi, jak działa i oswojenie się z nią.\
> Sugeruję wykonanie tej początkowej analizy dynamicznej używając MobSF dynamic analysis + pidcat, dzięki czemu będziemy w stanie **nauczyć się jak aplikacja działa** podczas gdy MobSF **zbiera** wiele **interesujących** **danych**, które możesz później przejrzeć.

Magisk/Zygisk quick notes (recommended on Pixel devices)
- Patchuj boot.img przy użyciu aplikacji Magisk i flashuj przez fastboot, aby uzyskać systemless root
- Włącz Zygisk + DenyList dla ukrywania roota; rozważ LSPosed/Shamiko gdy potrzebne jest silniejsze ukrywanie
- Zachowaj oryginalny boot.img aby móc odzyskać się po OTA; ponownie patchuj po każdym OTA
- Do mirrorowania ekranu użyj scrcpy na hoście



### Unintended Data Leakage

**Logging**

Deweloperzy powinni być ostrożni, aby nie ujawniać **informacji debugowych** publicznie, ponieważ może to prowadzić do wycieku danych wrażliwych. Narzędzia [**pidcat**](https://github.com/JakeWharton/pidcat) oraz `adb logcat` są rekomendowane do monitorowania logów aplikacji w celu identyfikacji i ochrony informacji wrażliwych. **Pidcat** jest preferowany ze względu na łatwość użycia i czytelność.

> [!WARNING]
> Zauważ, że od **wersji nowszych niż Android 4.0**, **aplikacje mogą uzyskiwać dostęp tylko do własnych logów**. Więc aplikacje nie mogą odczytywać logów innych aplikacji.\
> Mimo to, nadal zaleca się **nie logować informacji wrażliwych**.

**Bufor kopiuj/wklej**

Androidowy framework oparty na **schowku** umożliwia funkcjonalność kopiuj-wklej w aplikacjach, ale stwarza ryzyko, ponieważ **inne aplikacje** mogą **uzyskać dostęp** do schowka, potencjalnie ujawniając dane wrażliwe. Ważne jest, aby **wyłączyć funkcje kopiuj/wklej** dla wrażliwych sekcji aplikacji, takich jak dane karty kredytowej, aby zapobiec leakom.

**Crash Logs**

Jeśli aplikacja **crashuje** i **zapisuje logi**, te logi mogą pomóc atakującym, szczególnie gdy aplikacji nie da się odwrócić (reverse-engineer). Aby zmniejszyć to ryzyko, unikaj logowania przy awariach, a jeśli logi muszą być przesyłane przez sieć, upewnij się, że są wysyłane przez kanał SSL dla bezpieczeństwa.

Jako pentester, **spróbuj spojrzeć na te logi**.

**Dane analityczne wysyłane do 3rd Parties**

Aplikacje często integrują serwisy takie jak Google Adsense, które mogą przypadkowo **leakować dane wrażliwe** z powodu nieprawidłowej implementacji przez deweloperów. Aby zidentyfikować potencjalne wycieki danych, warto **przechwycić ruch aplikacji** i sprawdzić, czy jakiekolwiek informacje wrażliwe są wysyłane do usług zewnętrznych.

### Bazy danych SQLite

Większość aplikacji używa **wewnętrznych baz SQLite** do zapisu informacji. Podczas pentestu sprawdź **bazy danych** które zostały utworzone, nazwy **tabel** i **kolumn** oraz wszystkie zapisywane **dane**, ponieważ możesz znaleźć **informacje wrażliwe** (co byłoby podatnością).\
Bazy danych powinny znajdować się w `/data/data/the.package.name/databases` np. `/data/data/com.mwr.example.sieve/databases`

Jeśli baza danych zapisuje poufne informacje i jest **zaszyfrowana**, ale możesz **odnaleźć** **hasło** w aplikacji, to nadal jest to **podatność**.

Wyenumeruj tabele używając `.tables` oraz wyenumeruj kolumny tabel używając `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

Zgodnie z [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** pozwala **przyjąć rolę aplikacji Android** i współdziałać z innymi aplikacjami. Może robić **wszystko, co może zrobić zainstalowana aplikacja**, takie jak korzystanie z mechanizmu Inter-Process Communication (IPC) Androida oraz interakcję z warstwą systemu operacyjnego. .\
Drozer jest użytecznym narzędziem do **eksploatowania exported activities, exported services oraz Content Providers**, jak poznasz w kolejnych sekcjach.

### Eksploatacja eksportowanych Activities

[**Przeczytaj to jeśli chcesz odświeżyć czym jest Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Pamiętaj też, że kod activity zaczyna się w metodzie **`onCreate`**.

**Ominięcie autoryzacji**

Gdy Activity jest eksportowana, możesz wywołać jej ekran z zewnętrznej aplikacji. Zatem, jeśli activity zawierające **informacje wrażliwe** jest **eksportowane**, możesz **ominąć** mechanizmy **autoryzacji** aby uzyskać do niego dostęp.

[**Dowiedz się jak eksploatować eksportowane activities przy użyciu Drozer.**](drozer-tutorial/index.html#activities)

Możesz także uruchomić eksportowane activity z adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**UWAGA**: MobSF wykryje jako złośliwe użycie _**singleTask/singleInstance**_ jako `android:launchMode` w activity, ale zgodnie z [tym](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), najwyraźniej jest to niebezpieczne tylko w starych wersjach (API versions < 21).

> [!TIP]
> Należy pamiętać, że an authorisation bypass nie zawsze jest podatnością — zależy to od tego, jak bypass działa i jakie informacje są ujawniane.

**Sensitive information leakage**

**Activities can also return results**. Jeśli uda Ci się znaleźć eksportowaną i niechronioną activity wywołującą metodę **`setResult`** i **zwracającą poufne informacje**, występuje sensitive information leakage.

#### Tapjacking

Jeśli Tapjacking nie jest zapobiegany, możesz nadużyć eksportowanej activity, aby zmusić **użytkownika do wykonania nieoczekiwanych działań**. Po więcej informacji o [**czym jest Tapjacking, kliknij link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Przeczytaj to, jeśli chcesz odświeżyć, czym jest Content Provider.**](android-applications-basics.md#content-provider)\
Content providers są zasadniczo używane do **udostępniania danych**. Jeśli aplikacja ma dostępne content providers, możesz być w stanie **wyodrębnić poufne** dane z nich. Warto również przetestować możliwe **SQL injections** i **Path Traversals**, ponieważ mogą być podatne.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Przeczytaj to, jeśli chcesz odświeżyć, czym jest Service.**](android-applications-basics.md#services)\
Pamiętaj, że działania Service zaczynają się w metodzie `onStartCommand`.

Service to w zasadzie coś, co **może otrzymywać dane**, **przetwarzać** je i **zwracać** (lub nie) odpowiedź. Jeśli aplikacja eksportuje jakieś services, powinieneś **sprawdzić** **kod**, aby zrozumieć, co robi, i **przetestować** go **dynamicznie** w celu wydobycia poufnych informacji, obejścia mechanizmów uwierzytelniania...\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Przeczytaj to, jeśli chcesz odświeżyć, czym jest Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Pamiętaj, że działania Broadcast Receiver zaczynają się w metodzie `onReceive`.

Broadcast receiver będzie oczekiwał na określony typ wiadomości. W zależności od tego, jak receiver obsługuje wiadomość, może być podatny.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Możesz wyszukiwać deep links ręcznie, używając narzędzi takich jak MobSF lub skryptów takich jak [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Możesz **otworzyć** zadeklarowane **scheme** używając **adb** lub **przeglądarki**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Zauważ, że możesz **pominąć nazwę pakietu** i urządzenie mobilne automatycznie uruchomi aplikację, która powinna otworzyć ten link._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Wykonywany kod**

Aby znaleźć **kod, który zostanie wykonany w aplikacji**, przejdź do activity wywołanej przez deeplink i wyszukaj funkcję **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Wrażliwe informacje**

Za każdym razem, gdy znajdziesz deep link, sprawdź, czy **nie odbiera on wrażliwych danych (np. haseł) przez parametry URL**, ponieważ każda inna aplikacja mogłaby **podszyć się pod deep link i ukraść te dane!**

**Parametry w ścieżce**

Musisz także sprawdzić, czy **którykolwiek deep link nie używa parametru w obrębie ścieżki** URL, na przykład: `https://api.example.com/v1/users/{username}` , w takim przypadku możesz wymusić path traversal uzyskując dostęp do czegoś w stylu: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Zauważ, że jeśli znajdziesz poprawne endpointy w aplikacji, możesz być w stanie spowodować **Open Redirect** (jeśli część ścieżki jest używana jako nazwa domeny), **account takeover** (jeśli możesz modyfikować dane użytkowników bez tokena CSRF i podatny endpoint używał właściwej metody) oraz inne luki. Więcej [informacji znajdziesz tutaj](http://dphoeniixx.com/2020/12/13-2/).

**Więcej przykładów**

Ciekawy [raport bug bounty](https://hackerone.com/reports/855618) dotyczący linków (_/.well-known/assetlinks.json_).

### Inspekcja warstwy transportowej i błędy weryfikacji

- **Certyfikaty nie zawsze są poprawnie weryfikowane** przez aplikacje Android. Często aplikacje ignorują ostrzeżenia i akceptują certyfikaty self-signed lub, w niektórych przypadkach, wracają do używania połączeń HTTP.
- **Negocjacje podczas SSL/TLS handshake bywają słabe**, używając niebezpiecznych cipher suites. Ta luka sprawia, że połączenie jest podatne na ataki man-in-the-middle (MITM), umożliwiając atakującemu odszyfrowanie danych.
- **Leakage of private information** jest ryzykiem, gdy aplikacje uwierzytelniają się przy użyciu bezpiecznych kanałów, ale potem komunikują się przez kanały niezabezpieczone w innych transakcjach. Takie podejście nie chroni wrażliwych danych, takich jak ciasteczka sesyjne lub dane użytkownika, przed przechwyceniem przez złośliwe podmioty.

#### Weryfikacja certyfikatu

Skoncentrujemy się na **weryfikacji certyfikatów**. Integralność certyfikatu serwera musi być weryfikowana, aby zwiększyć bezpieczeństwo. To kluczowe, ponieważ niebezpieczne konfiguracje TLS i przesyłanie wrażliwych danych przez kanały niezaszyfrowane mogą stwarzać poważne zagrożenia. Dla szczegółowych kroków dotyczących weryfikacji certyfikatów serwera i naprawy luk, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) zapewnia kompleksowe wskazówki.

#### SSL Pinning

SSL Pinning to środek bezpieczeństwa, w którym aplikacja weryfikuje certyfikat serwera względem znanej kopii przechowywanej w samej aplikacji. Ta metoda jest niezbędna do zapobiegania atakom MITM. Zdecydowanie zaleca się implementację SSL Pinning w aplikacjach przetwarzających wrażliwe informacje.

#### Inspekcja ruchu

Aby przejrzeć ruch HTTP, konieczne jest **zainstalowanie certyfikatu narzędzia proxy** (np. Burp). Bez instalacji tego certyfikatu zaszyfrowany ruch może nie być widoczny przez proxy. Instrukcję instalacji niestandardowego certyfikatu CA znajdziesz w: [**kliknij tutaj**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Aplikacje targetujące **API Level 24 i nowsze** wymagają modyfikacji Network Security Config, aby zaakceptować certyfikat CA proxy. Ten krok jest krytyczny do inspekcji szyfrowanego ruchu. Instrukcje dotyczące modyfikacji Network Security Config znajdziesz w [**tym tutorialu**](make-apk-accept-ca-certificate.md).

Jeśli używany jest **Flutter**, musisz postępować zgodnie z instrukcjami na [**tej stronie**](flutter.md). Wynika to z faktu, że samo dodanie certyfikatu do magazynu nie zadziała, ponieważ Flutter ma własną listę zaufanych CA.

#### Statyczne wykrywanie SSL/TLS pinning

Zanim spróbujesz obejść mechanizmy w czasie wykonywania, szybko zmapuj, gdzie pinning jest wymuszany w APK. Odkrywanie statyczne pomaga zaplanować hooki/łatki i skupić się na właściwych ścieżkach kodu.

Narzędzie: SSLPinDetect
- Otwarte narzędzie do analizy statycznej, które dekompiluje APK do Smali (przez apktool) i skanuje przygotowane wzorce regex dotyczące implementacji SSL/TLS pinning.
- Zgłasza dokładną ścieżkę pliku, numer linii i fragment kodu dla każdego dopasowania.
- Obejmuje popularne frameworki i niestandardowe ścieżki kodu: OkHttp CertificatePinner, niestandardowy javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init z niestandardowymi TrustManagers/KeyManagers oraz piny w Network Security Config XML.

Instalacja
- Wymagania: Python >= 3.8, Java w PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Użycie
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Przykładowe reguły wzorców (JSON)
Użyj lub rozszerzaj sygnatury, aby wykrywać proprietarne/niestandardowe style pinning. Możesz załadować własny JSON i skanować na dużą skalę.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notatki i wskazówki
- Szybkie skanowanie dużych aplikacji przy użyciu wielowątkowości i mapowanego w pamięci I/O; pre-kompilowane wyrażenia regularne zmniejszają narzut/fałszywe pozytywy.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Typowe cele detekcji do dalszej weryfikacji:
- OkHttp: użycie CertificatePinner, setCertificatePinner, odwołania do pakietu okhttp3/okhttp
- Niestandardowe TrustManagers: javax.net.ssl.X509TrustManager, nadpisania checkServerTrusted
- Niestandardowe konteksty SSL: SSLContext.getInstance + SSLContext.init z niestandardowymi managerami
- Deklaratywne pins w res/xml (network security config) oraz odwołania w manifest
- Wykorzystaj dopasowane lokalizacje do zaplanowania hooków Frida, statycznych patchy lub przeglądu konfiguracji przed testami dynamicznymi.



#### Omijanie SSL Pinning

Gdy SSL Pinning jest zaimplementowany, konieczne staje się jego ominięcie, aby przeanalizować ruch HTTPS. Istnieje kilka metod do tego celu:

- Automatycznie **zmodyfikuj** **apk**, aby **obejść** SSLPinning za pomocą [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Największą zaletą tej opcji jest to, że nie będziesz potrzebować root, aby obejść SSL Pinning, ale będziesz musiał usunąć aplikację i zainstalować zmodyfikowaną wersję, a to nie zawsze zadziała.
- Możesz użyć **Frida** (omawiane poniżej), aby obejść tę ochronę. Tutaj jest przewodnik użycia Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Możesz też spróbować **automatycznie obejść SSL Pinning** za pomocą [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Możesz też spróbować **automatycznie obejść SSL Pinning** używając **MobSF dynamic analysis** (omówione poniżej)
- Jeśli nadal uważasz, że część ruchu nie jest przechwytywana, możesz spróbować **przekierować ruch do burp za pomocą iptables**. Przeczytaj ten wpis na blogu: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Poszukiwanie typowych podatności webowych

Ważne jest również poszukiwanie typowych podatności webowych w aplikacji. Szczegółowe informacje na temat identyfikacji i łagodzenia tych podatności wykraczają poza zakres tego streszczenia, ale są szeroko omówione gdzie indziej.

### Frida

[Frida](https://www.frida.re) to dynamiczne narzędzie do instrumentacji dla deweloperów, reverse-engineerów i badaczy bezpieczeństwa.\
**Możesz uzyskać dostęp do uruchomionej aplikacji i hookować metody w czasie wykonania, aby zmieniać zachowanie, zmieniać wartości, wyodrębniać wartości, uruchamiać inny kod...**\
Jeśli chcesz pentestować aplikacje Android musisz umieć używać Frida.

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Niektóre "GUI" do pracy z Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection jest świetny do automatyzacji użycia Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Możesz znaleźć kilka świetnych skryptów Frida tutaj: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Spróbuj obejść mechanizmy anti-debugging / anti-frida ładując Frida jak wskazano w [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (narzędzie [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Zrzut pamięci - Fridump**

Sprawdź, czy aplikacja nie przechowuje w pamięci wrażliwych informacji, których nie powinna przechowywać, takich jak hasła lub frazy mnemoniczne.

Korzystając z [**Fridump3**](https://github.com/rootbsd/fridump3) możesz zrzucić pamięć aplikacji za pomocą:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
To zrzuci pamięć do folderu ./dump, a następnie możesz użyć grep, na przykład:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Wrażliwe dane w Keystore**

W Androidzie Keystore to najlepsze miejsce do przechowywania wrażliwych danych, jednak przy odpowiednich uprawnieniach nadal jest **możliwe uzyskanie do nich dostępu**. Ponieważ aplikacje często zapisują tu **wrażliwe dane w postaci niezaszyfrowanej**, pentests powinny to sprawdzić jako użytkownik root albo ktoś z fizycznym dostępem do urządzenia mógłby ukraść te dane.

Nawet jeśli aplikacja zapisuje dane w keystore, dane powinny być zaszyfrowane.

Aby uzyskać dostęp do danych w keystore, możesz użyć tego skryptu Frida: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Używając poniższego skryptu Frida może być możliwe **bypass fingerprint authentication**, które aplikacje Android mogą wykonywać, aby **chronić pewne wrażliwe obszary:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Obrazy w tle**

Kiedy umieścisz aplikację w tle, Android zapisuje **snapshot aplikacji**, więc gdy zostanie przywrócona na pierwszy plan, zaczyna najpierw ładować obraz, aby wyglądało, że aplikacja uruchomiła się szybciej.

Jeśli jednak ten snapshot zawiera **wrażliwe informacje**, osoba mająca dostęp do snapshotu może **ukraść te informacje** (uwaga: potrzebujesz root, aby uzyskać dostęp).

Snapshoty są zwykle przechowywane w: **`/data/system_ce/0/snapshots`**

Android udostępnia sposób na **zablokowanie przechwytywania screenshotów przez ustawienie parametru layout FLAG_SECURE**. Używając tej flagi, zawartość okna jest traktowana jako bezpieczna, co zapobiega jej pojawianiu się na screenshotach lub wyświetlaniu na niezabezpieczonych wyświetlaczach.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

To narzędzie może pomóc w zarządzaniu różnymi narzędziami podczas analizy dynamicznej: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Developerzy często tworzą komponenty pośredniczące, takie jak activities, services i broadcast receivers, które obsługują te Intents i przekazują je do metod takich jak `startActivity(...)` lub `sendBroadcast(...)`, co może być ryzykowne.

Niebezpieczeństwo polega na umożliwieniu atakującym wywołania nieeksportowanych komponentów aplikacji lub dostępu do wrażliwych content providerów poprzez przekierowanie tych Intents. Dobrym przykładem jest komponent `WebView`, który konwertuje URL-e na obiekty `Intent` przy pomocy `Intent.parseUri(...)` i następnie je wykonuje, co potencjalnie prowadzi do złośliwych Intent injections.

### Essential Takeaways

- **Intent Injection** is similar to web's Open Redirect issue.
- Eksploity polegają na przekazywaniu obiektów `Intent` jako extras, które mogą być przekierowane do wykonania niebezpiecznych operacji.
- Może ujawnić nieeksportowane komponenty i content providerów atakującym.
- Konwersja URL → `Intent` przez `WebView` może umożliwić niezamierzone działania.

### Android Client Side Injections and others

Prawdopodobnie znasz tego rodzaju podatności z web. W aplikacji Android musisz zachować szczególną ostrożność w przypadku tych podatności:

- **SQL Injection:** Przy pracy z dynamicznymi zapytaniami lub Content-Providers upewnij się, że używasz zapytań parametryzowanych.
- **JavaScript Injection (XSS):** Upewnij się, że obsługa JavaScript i pluginów jest wyłączona dla każdego WebView (domyślnie wyłączona). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews powinny mieć dostęp do systemu plików wyłączony (domyślnie włączony) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: W wielu przypadkach po zakończeniu sesji aplikacja android nie unieważnia cookie lub zostaje ono zapisane na dysku
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Analiza statyczna**

![](<../../images/image (866).png>)

**Ocena podatności aplikacji** za pomocą ładnego webowego interfejsu. Możesz też wykonać analizę dynamiczną (ale musisz przygotować środowisko).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Zauważ, że MobSF potrafi analizować **Android**(apk)**, IOS**(ipa) **and Windows**(apx) aplikacje (_Aplikacje Windows muszą być analizowane z MobSF zainstalowanym na hoście Windows_).\
Również, jeśli utworzysz plik **ZIP** zawierający kod źródłowy aplikacji **Android** lub **IOS** (przejdź do folderu głównego aplikacji, zaznacz wszystko i utwórz ZIPfile), MobSF będzie w stanie również go przeanalizować.

MobSF pozwala także na **diff/Compare** analiz oraz na integrację z **VirusTotal** (musisz ustawić swój klucz API w _MobSF/settings.py_ i włączyć to: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). Możesz też ustawić `VT_UPLOAD` na `False`, wtedy zamiast pliku zostanie przesłany **hash**.

### Assisted Dynamic analysis with MobSF

**MobSF** może być również bardzo pomocny przy **dynamic analysis** na **Android**, ale w tym przypadku musisz zainstalować MobSF oraz **genymotion** na swoim hoście (VM lub Docker nie zadziałają). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
Dynamiczny analyzer MobSF może:

- **Dump application data** (URL-e, logi, clipboard, zrzuty ekranu wykonane przez Ciebie, zrzuty ekranu wykonane przez "**Exported Activity Tester**", e-maile, bazy danych SQLite, pliki XML i inne wygenerowane pliki). Wszystko to jest robione automatycznie z wyjątkiem zrzutów ekranu — musisz nacisnąć, gdy chcesz wykonać zrzut, lub nacisnąć "**Exported Activity Tester**", aby uzyskać zrzuty wszystkich exported activities.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

Od wersji **Android** > 5, automatycznie uruchomi Frida i ustawi globalne ustawienia proxy, aby przechwytywać ruch. Będzie przechwytywać tylko ruch z testowanej aplikacji.

**Frida**

Domyślnie użyje także kilku Frida Scripts do **bypass SSL pinning**, **root detection** i **debugger detection** oraz do **monitor interesting APIs**.\
MobSF może również **invoke exported activities**, robić **screenshots** tych aktywności i **save** je do raportu.

Aby **start** testów dynamicznych naciśnij zielony przycisk: "**Start Instrumentation**". Naciśnij "**Frida Live Logs**", aby zobaczyć logi generowane przez skrypty Frida oraz "**Live API Monitor**", aby zobaczyć wszystkie wywołania zahookowanych metod, przekazane argumenty i wartości zwracane (pojawi się to po naciśnięciu "Start Instrumentation").\
MobSF pozwala też na załadowanie własnych **Frida scripts** (aby wysłać wyniki swoich Friday scripts do MobSF użyj funkcji `send()`). Ma też **kilka wstępnie napisanych skryptów**, które możesz załadować (możesz dodać więcej w `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), po prostu je **wybierz**, naciśnij "**Load**" i potem "**Start Instrumentation**" (logi tych skryptów zobaczysz w "**Frida Live Logs**").

![](<../../images/image (419).png>)

Co więcej, masz kilka dodatkowych funkcjonalności Frida:

- **Enumerate Loaded Classes**: Wydrukuje wszystkie załadowane klasy
- **Capture Strings**: Wydrukuje wszystkie przechwycone strings podczas używania aplikacji (bardzo dużo logów)
- **Capture String Comparisons**: Może być bardzo użyteczne. Pokaże 2 porównywane strings oraz czy wynik był True czy False.
- **Enumerate Class Methods**: Wpisz nazwę klasy (np. "java.io.File") i wydrukuje wszystkie metody tej klasy.
- **Search Class Pattern**: Wyszukuje klasy według wzorca
- **Trace Class Methods**: **Trace** całej klasy (zobacz wejścia i wyjścia wszystkich metod klasy). Pamiętaj, że domyślnie MobSF trace'uje kilka interesujących Android Api methods.

Gdy wybierzesz moduł pomocniczy, którego chcesz użyć, musisz nacisnąć "**Start Intrumentation**" i zobaczysz wszystkie wyjścia w "**Frida Live Logs**".

**Shell**

MobSF dostarcza także shell z kilkoma komendami **adb**, **MobSF commands** oraz typowymi komendami **shell** na dole strony dynamic analysis. Kilka interesujących poleceń:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**Narzędzia HTTP**

Gdy ruch HTTP zostanie przechwycony, możesz zobaczyć surowy widok przechwyconego ruchu na przycisku "**HTTP(S) Traffic**" lub ładniejszy widok w zielonym przycisku "**Start HTTPTools**". Z tej drugiej opcji możesz **wysłać** **przechwycone żądania** do **proxies** takich jak Burp lub Owasp ZAP.\
Aby to zrobić, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> naciśnij "**Send to Fuzzer**" --> _wybierz adres proxy_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Po zakończeniu analizy dynamicznej z MobSF możesz kliknąć "**Start Web API Fuzzer**", aby **fuzzować żądania http** i szukać podatności.

> [!TIP]
> Po przeprowadzeniu analizy dynamicznej z MobSF ustawienia proxy mogą być źle skonfigurowane i nie będzie można ich naprawić z poziomu GUI. Możesz naprawić ustawienia proxy wykonując:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Wspomagana analiza dynamiczna za pomocą Inspeckage

Narzędzie można pobrać z [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
To narzędzie używa pewnych **Hooks**, aby informować cię **co się dzieje w aplikacji** podczas wykonywania **analizy dynamicznej**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

To **świetne narzędzie do przeprowadzania analizy statycznej z GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

To narzędzie zostało zaprojektowane do wyszukiwania różnych **security related Android application vulnerabilities**, zarówno w **source code**, jak i w **packaged APKs**. Narzędzie jest także **capable of creating a "Proof-of-Concept" deployable APK** oraz generowania **ADB commands**, aby wykorzystać niektóre z odnalezionych podatności (Exposed activities, intents, tapjacking...). Podobnie jak w przypadku Drozer, nie ma potrzeby rootowania urządzenia testowego.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Wyświetla wszystkie wyodrębnione pliki do szybkiego wglądu
- Automatycznie dekompiluje pliki APK do formatu Java i Smali
- Analizuje AndroidManifest.xml pod kątem powszechnych podatności i zachowań
- Statyczna analiza kodu źródłowego pod kątem powszechnych podatności i zachowań
- Informacje o urządzeniu
- i więcej
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER to aplikacja wiersza poleceń, którą można używać w Windows, MacOS X i Linux, analizująca _.apk_ files w poszukiwaniu podatności. Robi to przez dekompresję APK i zastosowanie serii reguł w celu wykrycia tych podatności.

Wszystkie reguły są zdefiniowane w pliku `rules.json`, a każda firma lub tester może stworzyć własne reguły, aby analizować to, czego potrzebuje.

Pobierz najnowsze binaria z [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn to narzędzie **crossplatform**, które wspomaga developerów, bugbounty hunters i ethical hackers w przeprowadzaniu [statycznej analizy kodu](https://en.wikipedia.org/wiki/Static_program_analysis) aplikacji mobilnych.

Koncepcja polega na tym, że przeciągasz i upuszczasz plik aplikacji mobilnej (plik .apk lub .ipa) na aplikację StaCoAn, a ona wygeneruje dla Ciebie wizualny i przenośny raport. Możesz dostosować ustawienia i wordlists, aby uzyskać spersonalizowane doświadczenie.

Pobierz[ najnowsze wydanie](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework to system analizy podatności aplikacji Android, który pomaga deweloperom oraz hackersom znaleźć potencjalne luki bezpieczeństwa.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** to narzędzie, którego głównym celem jest wykrywanie i ostrzeganie użytkownika o potencjalnych złośliwych zachowaniach wykazywanych przez aplikację Android.

Detekcja jest przeprowadzana za pomocą **static analysis** Dalvik bytecode aplikacji, reprezentowanego jako **Smali**, przy użyciu biblioteki [`androguard`](https://github.com/androguard/androguard).

Narzędzie wyszukuje **common behavior of "bad" applications** takich jak: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** to framework do **M**obile **A**pplication **R**everse engineering and **A**nalysis. Jest to narzędzie, które łączy powszechnie używane narzędzia do reverse engineeringu i analizy aplikacji mobilnych, aby wspomóc testowanie aplikacji mobilnych pod kątem zagrożeń bezpieczeństwa OWASP. Jego celem jest ułatwienie tego zadania deweloperom aplikacji mobilnych oraz specjalistom ds. bezpieczeństwa.

Jest w stanie:

- Wyodrębniać kod Java i Smali przy użyciu różnych narzędzi
- Analizować APKi przy użyciu: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Wyodrębniać prywatne informacje z APK przy użyciu regexps.
- Analizować Manifest.
- Analizować znalezione domeny przy użyciu: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) i [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuskować APK za pomocą [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Przydatne do wykrywania malware: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Zwróć uwagę, że w zależności od usługi i konfiguracji użytej do obfuskacji kodu, secrets mogą być obfuskowane lub nie.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

Z [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** to open source narzędzie wiersza poleceń, które zmniejsza, optymalizuje i obfuskikuje kod Java. Potrafi optymalizować bytecode oraz wykrywać i usuwać nieużywane instrukcje. ProGuard jest wolnym oprogramowaniem i jest dystrybuowany na licencji GNU General Public License, wersja 2.

ProGuard jest dystrybuowany jako część Android SDK i uruchamia się podczas budowania aplikacji w trybie release.

### [DexGuard](https://www.guardsquare.com/dexguard)

Znajdź przewodnik krok po kroku jak deobfuskować APK na [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(Z tego przewodnika) Ostatnim razem, gdy sprawdzano, tryb działania DexGuard był następujący:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard odwraca proces obfuskacji wykonywany przez narzędzia obfuskacyjne dla Androida. Umożliwia to liczne analizy bezpieczeństwa, w tym inspekcję kodu i rozpoznawanie bibliotek.**

Możesz przesłać obfuskowane APK na ich platformę.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

To narzędzie LLM do znajdowania potencjalnych podatności w android apps i deobfuskacji kodu aplikacji android. Używa publicznego API Google's Gemini.

### [Simplify](https://github.com/CalebFenton/simplify)

To ogólny deobfuskator dla Androida. Simplify virtually executes an app, aby zrozumieć jej zachowanie, a następnie próbuje zoptymalizować kod tak, aby zachowywał się identycznie, ale był łatwiejszy do zrozumienia przez człowieka. Każdy typ optymalizacji jest prosty i uniwersalny, więc nie ma znaczenia, jaki konkretny typ obfuskacji został użyty.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD dostarcza informacji o **tym, jak został stworzony APK**. Identyfikuje wiele **compilers**, **packers**, **obfuscators** i innych dziwnych rzeczy. To _PEiD_ dla Androida.

### Manual

[Przeczytaj ten tutorial, aby poznać kilka sztuczek dotyczących **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b to wirtualna maszyna do bezpieczeństwa Androida oparta na ubuntu-mate; zawiera zbiór najnowszych frameworków, tutoriali i laboratoriów od różnych badaczy i pasjonatów bezpieczeństwa, przeznaczonych do reverse engineeringu i analizy malware.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) To świetna lista zasobów
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Szybki kurs Androida
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)

## Yet to try

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
