# AndroidアプリケーションのPentesting

{{#include ../../banners/hacktricks-training.md}}

## Androidアプリケーションの基本

このページを最初に読むことを強くおすすめします。**Androidのセキュリティに関連する最も重要な部分と、Androidアプリケーション内で最も危険なコンポーネント**について知ることができます:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

これは、Androidデバイス（エミュレータまたは実機）に接続するために必要な主要なツールです。\
ADBにより、コンピュータからUSBまたはNetwork経由でデバイスを制御できます。このユーティリティは、ファイルの双方向コピー、アプリのインストールとアンインストール、シェルコマンドの実行、データのバックアップ、ログの読み取りなどの機能を提供します。

adbの使い方を学ぶには、次の[**ADB Commands**](adb-commands.md)の一覧を参照してください。

## Smali

時には、**アプリケーションのコードを修正**して**隠された情報**（難読化されたパスワードやフラグなど）にアクセスすることが有用です。その場合、apkをデコンパイルしてコードを修正し、再コンパイルすることが有用なことがあります。\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md)。これは、これから説明する動的解析中のいくつかのテストに対する**代替手段**として非常に有用です。したがって、**常にこの可能性を念頭に置いてください**。

## その他の興味深いトリック

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [Android IME / InputMethodService Abuse (Malicious Keyboards)](inputmethodservice-ime-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **APKのダウンロード**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- デバイスからAPKを抽出:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- すべての splits と base apks を [APKEditor](https://github.com/REAndroid/APKEditor) でマージする:
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Android Enterprise & Work Profile Attacks

{{#ref}}
android-enterprise-work-profile-bypass.md
{{#endref}}

## ケーススタディ & 脆弱性


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

{{#ref}}
abusing-android-media-pipelines-image-parsers.md
{{#endref}}

{{#ref}}
../../binary-exploitation/linux-kernel-exploitation/arm64-static-linear-map-kaslr-bypass.md
{{#endref}}

## 静的解析

まず最初に、APK を解析する際は **decompiler を使って Java コードを確認する**べきです。\
[**さまざまな利用可能な decompiler に関する情報はこちらを参照してください**](apk-decompilers.md)。

### 興味深い情報の探索

APK の **strings** を見るだけでも、**パスワード**、**URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep))、**api** キー、**暗号化に関する情報**、**bluetooth uuids**、**tokens** などの興味深いものを検索できます。コード実行用の **backdoors** や認証 backdoor（アプリにハードコードされた管理者資格情報）も探してください。

**Firebase**

特に **firebase URLs** に注意を払って、設定ミスがないか確認してください。[Firebase が何であるか、どのように悪用するかの詳細はこちら。](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### アプリケーションの基本理解 - Manifest.xml, strings.xml

アプリケーションの _Manifest.xml_ および **_strings.xml_** ファイルの検査は、潜在的なセキュリティ脆弱性を明らかにすることがあります。これらのファイルは decompiler を使ってアクセスするか、APK の拡張子を .zip に変更して展開することで取得できます。

**Manifest.xml** から識別される可能性のある脆弱性には以下が含まれます:

- **Debuggable Applications**: _Manifest.xml_ 内で `debuggable="true"` に設定されたアプリは、接続を許可してしまい悪用される可能性があるためリスクとなります。デバッガブルなアプリの見つけ方や悪用方法については、デバイス上で debuggable なアプリを見つけて悪用するチュートリアルを参照してください。
- **Backup Settings**: `android:allowBackup="false"` 属性は、特に機密情報を扱うアプリでは明示的に設定しておくべきです。そうしないと、usb debugging が有効な場合に adb を通じて不正なデータバックアップが可能になります。
- **Network Security**: カスタムの network security configuration (`android:networkSecurityConfig="@xml/network_security_config"`) は、res/xml/ 内で証明書ピンや HTTP トラフィックの設定などのセキュリティ詳細を指定できます。例として特定のドメインに対して HTTP を許可する設定などがあります。
- **Exported Activities and Services**: マニフェストで exported な activities や services を特定することで、悪用される可能性のあるコンポーネントを洗い出せます。動的テスト中のさらなる解析により、これらのコンポーネントの悪用方法が明らかになることがあります。
- **Content Providers and FileProviders**: 公開された content provider はデータへの不正アクセスや改ざんを許す可能性があります。FileProvider の設定も注意深く確認してください。
- **Broadcast Receivers and URL Schemes**: これらのコンポーネントは悪用される可能性があり、特に URL スキームの扱いに関して入力に対する脆弱性に注意を払う必要があります。
- **SDK Versions**: `minSdkVersion`、`targetSDKVersion`、`maxSdkVersion` の属性はサポートされている Android バージョンを示します。古い脆弱な Android バージョンをサポートしていないことが重要です。

**strings.xml** ファイルからは、API キーやカスタムスキーマ、開発者のメモなどの機密情報が見つかる場合があり、これらのリソースを注意深く確認する必要があることを示しています。

### Tapjacking

Tapjacking は、悪意あるアプリケーションが起動して被害対象アプリの上に自分自身を配置する攻撃です。被害者アプリを目に見えて覆い隠した後、その UI を工夫してユーザを騙し、ユーザの操作を被害者アプリへ渡すように設計されます。\
この攻撃は、ユーザが実際には被害者アプリ上で操作を行っていることに気づかせない（事実上ユーザを“目くらまし”する）ものです。

詳細は以下を参照してください:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

`launchMode` が `singleTask` に設定され、かつ `taskAffinity` が定義されていない activity は Task Hijacking の脆弱性があります。これは、悪意あるアプリケーションをインストールしてそれが本物のアプリより先に起動された場合、その本物アプリのタスクをハイジャックできる可能性があることを意味します（ユーザは本物のアプリを使っていると思っているが、実際には悪意あるアプリとやり取りしていることになります）。

詳細は以下を参照してください:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### 不適切なデータ保存

Internal Storage

Android では、internal storage に保存されたファイルはそれを作成したアプリのみがアクセスできるように設計されています。このセキュリティ対策は Android OS によって強制されており、ほとんどのアプリのセキュリティ要件に対しては十分です。しかし、開発者が `MODE_WORLD_READABLE` や `MODE_WORLD_WRITABLE` といったモードを利用してアプリ間でファイルを共有することがあります。これらのモードは他のアプリ（潜在的に悪意あるもの）によるアクセスを制限しません。

1. 静的解析:
- `MODE_WORLD_READABLE` や `MODE_WORLD_WRITABLE` の使用は慎重に確認してください。これらのモードはファイルを意図しない、または不正なアクセスに晒す可能性があります。
2. 動的解析:
- アプリが作成するファイルの権限を確認してください。特に、ファイルが世界中で読み取り/書き込み可能に設定されていないかをチェックしてください。これは重大なセキュリティリスクとなり、インストールされている任意のアプリがこれらのファイルを読み取ったり変更したりできることを意味します。

External Storage

SD カードなどの external storage 上のファイルを扱う際には、以下の点に注意してください:

1. アクセシビリティ:
- external storage 上のファイルはグローバルに読み書き可能です。これは任意のアプリやユーザがこれらのファイルにアクセスできることを意味します。
2. セキュリティの懸念:
- アクセスが容易なため、機密情報を external storage に保存しないことが推奨されます。
- external storage は取り外し可能であり、任意のアプリによってアクセスされ得るため、安全性は低くなります。
3. External Storage からのデータの扱い:
- external storage から取得したデータは必ず入力検証を行ってください。これはデータが信頼できないソースから来ているため重要です。
- external storage に実行ファイルや class ファイルを保存して動的に読み込むことは強く推奨されません。
- アプリが external storage から実行ファイルを取得する必要がある場合、それらのファイルが動的に読み込まれる前に署名され暗号的に検証されていることを確認してください。これはアプリのセキュリティ整合性を保つために重要です。

External storage は以下でアクセスできます: /storage/emulated/0 , /sdcard , /mnt/sdcard

> [!TIP]
> Android 4.4（**API 17**）以降、SD カードにはディレクトリ構造があり、アプリからアクセスできるのはそのアプリ専用のディレクトリに限定されます。これにより、悪意あるアプリが他のアプリのファイルを読み書きすることを防ぎます。

**平文で保存された機密データ**

- **Shared preferences**: Android は各アプリが `/data/data/<packagename>/shared_prefs/` に簡単に xml ファイルを保存できるようにしており、時にそのフォルダ内に機密情報が平文で見つかることがあります。
- **Databases**: Android は各アプリが `/data/data/<packagename>/databases/` に sqlite データベースを簡単に保存できるようにしており、時にそのフォルダ内に機密情報が平文で見つかることがあります。

### Broken TLS

Accept All Certificates

何らかの理由で、開発者がホスト名が一致しない場合でもすべての証明書を受け入れてしまうことがあります。例えば以下のようなコード行で:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Broken Cryptography

**Poor Key Management Processes**

一部の開発者は機密データをローカルストレージに保存し、コード内にハードコードされた／予測可能なキーで暗号化します。これは避けるべきで、なぜならreversingにより攻撃者が機密情報を抽出できる可能性があるからです。

**Use of Insecure and/or Deprecated Algorithms**

開発者は認可チェック、データの保存や送信に**非推奨のアルゴリズム**を使用すべきではありません。これらのアルゴリズムには RC4, MD4, MD5, SHA1 などがあります。例えばパスワード保存に**hashes**を使用する場合は、salt を用いた brute-force 抵抗性のあるハッシュを使うべきです。

### Other checks

- 攻撃者のリバースエンジニアリングを困難にするため、APKを**obfuscate**することが推奨されます。
- アプリが機密性の高いものであれば（銀行系アプリなど）、モバイルが**rooted**かどうかを**独自にチェック**し、その結果に応じた処理を行うべきです。
- アプリが機密性の高いものであれば（銀行系アプリなど）、**emulator**が使用されているかをチェックするべきです。
- アプリが機密性の高いものであれば（銀行系アプリなど）、実行前に**自身の整合性をチェック**して改ざんされていないか確認するべきです。
- APK がどのコンパイラ／パッカー／オブフスクレータでビルドされたかを確認するには [**APKiD**](https://github.com/rednaga/APKiD) を使用してください。

### React Native Application

React アプリケーションの javascript コードに簡単にアクセスする方法を知るには、次のページを読んでください：


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Xamarin アプリケーションの C# コードに簡単にアクセスする方法を知るには、次のページを読んでください：


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

ツール [**mariana-trench**](https://github.com/facebook/mariana-trench) はアプリケーションの**コード**を**スキャン**して**脆弱性**を見つけることができます。このツールは一連の**known sources**（ツールに対して**入力**が**ユーザにより制御されている場所**を示す）、**sinks**（悪意ある入力が被害を起こしうる**危険な場所**を示す）、および **rules** を含みます。これらのルールは脆弱性を示す**sources-sinks の組み合わせ**を指示します。

この知識に基づいて、**mariana-trench はコードをレビューして可能性のある脆弱性を見つけます**。

### Secrets leaked

アプリケーションには機密情報（API keys、パスワード、隠し URL、サブドメインなど）が含まれていることがあり、それらを発見できる場合があります。例えば次のツールを使用できます: [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)
- In-memory native code execution via JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> First of all, you need an environment where you can install the application and all the environment (Burp CA cert, Drozer and Frida mainly). Therefore, a rooted device (emulated or not) is extremely recommended.

### Online Dynamic analysis

無料アカウントを作成できるサービスとして [https://appetize.io/](https://appetize.io) があります。このプラットフォームでは APK を**アップロード**して**実行**できるため、APK の挙動を確認するのに便利です。

ウェブ上でアプリのログを確認したり、**adb**経由で接続することもできます。

![](<../../images/image (831).png>)

ADB 接続のおかげでエミュレータ内で **Drozer** や **Frida** を使用できます。

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio)（**x86** と **arm** デバイスを作成できます。かつ [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html) によれば **最新の x86** バージョンは遅い arm エミュレータを使わずとも **ARM ライブラリをサポート**します）。
- セットアップ方法は次のページで学べます：


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition、アカウント作成が必要です。潜在的なエラーを避けるために**VirtualBox 含む**バージョンを**ダウンロード**することを推奨します。)
- [**Nox**](https://es.bignox.com)（無料。ただし Frida や Drozer はサポートされていません）。

> [!TIP]
> どのプラットフォームで新しいエミュレータを作成する場合でも、画面が大きいほどエミュレータは遅くなります。可能な限り小さい画面を選択してください。

Genymotion に Google サービス（例：AppStore）をインストールするには、以下画像の赤でマークされたボタンをクリックしてください：

![](<../../images/image (277).png>)

また、**Genymotion の Android VM の設定**で **Bridge Network mode** を選択できることに注意してください（これは別の VM からツールで Android VM に接続する場合に便利です）。

#### Use a physical device

デバッグオプションを有効にする必要があり、可能であれば root 化しておくと良いでしょう：

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> アプリをインストールしたら、まずそのアプリを実行して何をするのか、どのように動作するのかを調べて慣れてください。\
> 最初の動的解析は MobSF dynamic analysis + pidcat を使って行うことをおすすめします。そうすることで、MobSF が後で確認できる多くの興味深いデータを**キャプチャ**している間に、アプリの動作を学ぶことができます。

Magisk/Zygisk quick notes (recommended on Pixel devices)
- Patch boot.img with the Magisk app and flash via fastboot to get systemless root
- Enable Zygisk + DenyList for root hiding; consider LSPosed/Shamiko when stronger hiding is required
- Keep original boot.img to recover from OTA updates; re-patch after each OTA
- For screen mirroring, use scrcpy on the host



### Unintended Data Leakage

**Logging**

開発者は**デバッグ情報**を公開すると機密データの漏洩につながる可能性があるため注意する必要があります。アプリケーションログを監視して機密情報を特定・保護するには [**pidcat**](https://github.com/JakeWharton/pidcat) や `adb logcat` が推奨されます。可読性や使いやすさの点で **Pidcat** が好まれます。

> [!WARNING]
> Android 4.0 より新しいバージョンでは、**アプリは自分自身のログのみしか参照できません**。したがって、他のアプリのログにはアクセスできません。\
> とはいえ、機密情報をログに残さないことが依然として推奨されます。

**Copy/Paste Buffer Caching**

Android の **clipboard** ベースのフレームワークはアプリ間のコピー＆ペースト機能を可能にしますが、他のアプリがクリップボードにアクセスできるため機密データが露出するリスクがあります。クレジットカード情報など機密性の高いセクションではコピー／ペースト機能を無効にすることが重要です。

**Crash Logs**

アプリが**クラッシュ**してログを保存する場合、特にアプリを逆解析できない場合には攻撃者にとって有用な情報源となることがあります。このリスクを軽減するため、クラッシュ時のログ出力を避ける、あるいはネットワーク経由でログを送信する必要がある場合は SSL チャネルを使用して送信するようにしてください。

pentester として、これらのログを確認するようにしてください。

**Analytics Data Sent To 3rd Parties**

アプリはしばしば Google Adsense のようなサービスを統合しており、開発者の不適切な実装により機密データが第三者に漏洩することがあります。潜在的なデータ漏洩を特定するために、アプリのトラフィックをインターセプトし、第三者サービスへ送信されている機密情報がないか確認することを推奨します。

### SQLite DBs

ほとんどのアプリは情報を保存するために**内部 SQLite データベース**を使用します。pentest の際には作成された**データベース**、テーブルやカラムの名前、保存されている**データ**を確認してください。機密情報が見つかることがあり、それは脆弱性に該当します。\
データベースは通常 `/data/data/the.package.name/databases`（例: `/data/data/com.mwr.example.sieve/databases`）にあります。

データベースが暗号化されていても、アプリ内にパスワードが見つかる場合はそれは依然として脆弱性です。

テーブルの列挙は `.tables`、テーブルのカラム確認は `.schema <table_name>` を使用してください。

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer is s useful tool to **exploit exported activities, exported services and Content Providers** as you will learn in the following sections.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
また、Activity のコードは **`onCreate`** メソッドから始まることを覚えておいてください。

**Authorisation bypass**

Activity が exported されている場合、外部アプリからその画面を呼び出すことができます。したがって、**機密情報を扱う Activity が exported されている**場合、認証メカニズムを**bypass**してアクセスできる可能性があります。

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

また、adb から exported な activity を起動することもできます：

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSFはアクティビティで`android:launchMode`として_**singleTask/singleInstance**_を使用していることを悪意のあるものと検出しますが、[this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750)によると、これは古いバージョン（API versions < 21）でのみ危険なようです。

> [!TIP]
> Note that an authorisation bypass is not always a vulnerability, it would depend on how the bypass works and which information is exposed.

**Sensitive information leakage**

**Activities can also return results**. エクスポートされ保護されていない activity が **`setResult`** メソッドを呼び出して機密情報を返しているのを見つけられた場合、sensitive information leakage が発生します。

#### Tapjacking

Tapjacking が防止されていない場合、エクスポートされた activity を悪用して**ユーザに予期しない操作を行わせる**ことができます。詳細については [**what is Tapjacking follow the link**](#tapjacking) を参照してください。

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers は基本的に **データを共有する** ために使われます。アプリに content providers が存在する場合、それらから機密データを**抽出**できる可能性があります。また、脆弱である可能性があるため、**SQL injections** や **Path Traversals** のテストを行うことも重要です。

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Service の処理は `onStartCommand` メソッドから始まることを覚えておいてください。

Service は基本的に **データを受け取り**、**処理**し、（場合によっては）**応答を返す**ものです。したがって、アプリがサービスをエクスポートしている場合は、何をしているのかを理解するために**コードを確認**し、機密情報の抽出や認証回避などを動的に**テスト**するべきです。\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Broadcast Receiver の処理は `onReceive` メソッドから始まることを覚えておいてください。

Broadcast receiver は特定のタイプのメッセージを待ち受けています。受信したメッセージの処理方法によっては脆弱になる可能性があります。\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

deep links は手動で探すこともできます。MobSF のようなツールや [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py) のようなスクリプトを使って探せます。\
宣言された **scheme** は **adb** や **browser** で**open**できます：
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_パッケージ名を**省略できる**ことに注意してください。モバイル端末はそのリンクを開くべきアプリを自動的に呼び出します。_
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**実行されるコード**

アプリ内で**実行されるコード**を見つけるには、deeplink によって呼ばれる activity に移動して、関数 **`onNewIntent`** を検索してください。

![](<../../images/image (436) (1) (1) (1).png>)

**機密情報**

deep link を見つけたら毎回、**URL パラメータ経由で機密データ（例: passwords）を受け取っていないか**を確認してください。なぜなら他のアプリが **deep link をなりすましてそのデータを盗む** 可能性があるからです。

**パス内のパラメータ**

URL のパス内でパラメータを使用している deep link がないかも**必ず確認してください**。例: `https://api.example.com/v1/users/{username}` のような場合、`example://app/users?username=../../unwanted-endpoint%3fparam=value` のようにアクセスしてパストラバーサルを強制できることがあります。\
アプリ内で正しいエンドポイントを見つければ、パスの一部がドメイン名として使用されている場合の **Open Redirect**、CSRF トークンなしでユーザ情報を変更できる場合の **account takeover**、その他の脆弱性を引き起こせる可能性があります。詳細は [info about this here](http://dphoeniixx.com/2020/12/13-2/) を参照してください。

**More examples**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### トランスポート層の検査と検証の失敗

- **Certificates are not always inspected properly** by Android applications. 多くのアプリは警告を無視して自己署名証明書を受け入れたり、場合によっては HTTP 接続にフォールバックすることがあります。
- **Negotiations during the SSL/TLS handshake are sometimes weak**, 暗号スイートが不十分であることがあり、この脆弱性により接続が man-in-the-middle (MITM) 攻撃に対して脆弱になり、攻撃者がデータを復号できる場合があります。
- **Leakage of private information** is a risk when applications authenticate using secure channels but then communicate over non-secure channels for other transactions. この手法ではセッション cookie やユーザ詳細などの機密データを悪意ある第三者による傍受から保護できません。

#### 証明書検証

ここでは **certificate verification** に焦点を当てます。サーバの証明書の整合性を検証することはセキュリティ強化のために不可欠です。不適切な TLS 設定や暗号化されていないチャネルでの機密データ送信は重大なリスクをもたらします。サーバ証明書の検証と脆弱性対処手順の詳細は、[**this resource**](https://manifestsecurity.com/android-application-security-part-10/) を参照してください。

#### SSL Pinning

SSL Pinning は、アプリがサーバ証明書をアプリ内に格納された既知のコピーと照合するセキュリティ対策です。これは MITM 攻撃を防ぐために重要で、機密情報を扱うアプリでは SSL Pinning の実装が強く推奨されます。

#### Traffic Inspection

HTTP トラフィックを検査するには、プロキシツールの証明書（例: Burp）を**インストールする必要があります**。この証明書をインストールしないと、暗号化されたトラフィックはプロキシ経由で見えない場合があります。カスタム CA 証明書のインストール手順は [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine) を参照してください。

**API Level 24 以上** をターゲットにしているアプリでは、プロキシの CA 証明書を受け入れるように Network Security Config の変更が必要です。暗号化トラフィックを検査するために重要なステップです。Network Security Config の変更方法は [**refer to this tutorial**](make-apk-accept-ca-certificate.md) を参照してください。

もし **Flutter** を使用している場合は、[**this page**](flutter.md) の指示に従う必要があります。単に証明書をストアに追加するだけでは機能しないことがあり、Flutter は独自の有効な CA のリストを持っているためです。

#### SSL/TLS pinning の静的検出

runtime bypasses を試みる前に、APK 内で pinning がどこで強制されているかを素早くマップしてください。静的検出はフックやパッチの計画を助け、正しいコードパスに集中するのに役立ちます。

Tool: SSLPinDetect
- Open-source static-analysis utility that decompiles the APK to Smali (via apktool) and scans for curated regex patterns of SSL/TLS pinning implementations.
- 各マッチについて正確なファイルパス、行番号、およびコードスニペットを報告します。
- 共通フレームワークやカスタムのコードパスをカバーします: OkHttp CertificatePinner、カスタム javax.net.ssl.X509TrustManager.checkServerTrusted、SSLContext.init（カスタム TrustManagers/KeyManagers を使用）および Network Security Config XML pins。

インストール
- 事前要件: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
使い方
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
パターンルールの例 (JSON)
独自/カスタムの pinning スタイルを検出するために signatures を使用または拡張します。独自の JSON をロードして大規模にスキャンできます。
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes and tips
- 大きなアプリをマルチスレッドとメモリマップドI/Oで高速にスキャン。事前にコンパイルされたregexはオーバーヘッドと誤検知を減らす。
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Typical detection targets to triage next:
- OkHttp: CertificatePinner の使用、setCertificatePinner、okhttp3/okhttp パッケージ参照
- Custom TrustManagers: javax.net.ssl.X509TrustManager、checkServerTrusted のオーバーライド
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init とカスタムマネージャの組み合わせ
- Declarative pins in res/xml network security config and manifest references
- 一致した箇所を利用して、動的テスト前に Frida フック、静的パッチ、または設定レビューを計画する。



#### SSL Pinning のバイパス

SSL Pinning が実装されている場合、HTTPS トラフィックを調査するためにそれをバイパスする必要が出てくる。目的達成のためにいくつかの方法がある:

- Automatically **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). The best pro of this option, is that you won't need root to bypass the SSL Pinning, but you will need to delete the application and reinstall the new one, and this won't always work.
- You could use **Frida** (discussed below) to bypass this protection. Here you have a guide to use Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- You can also try to **automatically bypass SSL Pinning** using [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- You can also try to **automatically bypass SSL Pinning** using **MobSF dynamic analysis** (explained below)
- If you still think that there is some traffic that you aren't capturing you can try to **forward the traffic to burp using iptables**. Read this blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Looking for Common Web Vulnerabilities

アプリ内の一般的な Web 脆弱性も検索することが重要である。これらの脆弱性の特定や緩和に関する詳細な情報はこの要約の範囲外だが、他所で広く扱われている。

### Frida

[Frida](https://www.frida.re) is a dynamic instrumentation toolkit for developers, reverse-engineers, and security researchers.\
**実行中のアプリケーションにアクセスして実行時にメソッドをフックし、動作を変更したり、値を変更したり、値を抽出したり、別のコードを実行したりできます...**\
Android アプリを pentest するなら Frida の使い方を知っておく必要がある。

- Fridaの使い方を学ぶ: [**Frida tutorial**](frida-tutorial/index.html)
- Frida による操作のための "GUI" 的ツール: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection は Frida の自動化に便利: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- いくつかの Awesome Frida スクリプトはこちら: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- anti-debugging / anti-frida の仕組みを回避するために、Frida を以下で示すようにロードしてみること（参考）: [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning バイパスのワークフロー

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **メモリダンプ - Fridump**

パスワードやニーモニックなど、アプリがメモリ内に保存すべきでない機密情報を保存していないか確認する。

Using [**Fridump3**](https://github.com/rootbsd/fridump3) you can dump the memory of the app with:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
これによりメモリが ./dump フォルダにダンプされ、そこで次のように grep できます：
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Keystoreの機密データ**

AndroidではKeystoreが機密データを保存する最適な場所ですが、十分な権限があれば **アクセスすることが可能** です。アプリはここに **平文の機密データ** を保存しがちであるため、pentestsではroot userとして確認すべきです。デバイスに物理的にアクセスできる者がこのデータを盗む可能性があります。

アプリがKeystoreにデータを保存している場合でも、そのデータは暗号化されているべきです。

Keystore内のデータにアクセスするには、このFridaスクリプトを使用できます: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

以下のFridaスクリプトを使用すると、Androidアプリケーションが特定の機密領域を保護するために実行している **bypass fingerprint authentication** を回避できる可能性があります：
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **バックグラウンド画像**

アプリをバックグラウンドにすると、Androidはアプリの**スナップショット**を保存します。これによりフォアグラウンドに復帰したとき、アプリ本体より先に画像を読み込んでアプリがより速く読み込まれたように見えます。

ただし、このスナップショットに**機密情報**が含まれている場合、スナップショットにアクセスできる者がその情報を**盗む**可能性があります（アクセスにはrootが必要である点に注意してください）。

スナップショットは通常次の場所に保存されます: **`/data/system_ce/0/snapshots`**

Androidは、レイアウトパラメータに**FLAG_SECUREを設定することでスクリーンショットの取得を防ぐ**方法を提供しています。このフラグを使用すると、ウィンドウの内容はセキュアとして扱われ、スクリーンショットに表示されたり、非セキュアなディスプレイで表示されることを防ぎます。
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

このツールは動的解析中に異なるツールを管理するのに役立ちます: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

開発者はしばしば、これらのIntentを処理して`startActivity(...)`や`sendBroadcast(...)`のようなメソッドに渡すactivities、services、broadcast receiversのようなプロキシコンポーネントを作成しますが、これは危険になり得ます。

危険なのは、攻撃者がこれらのIntentを誤誘導することで、non-exportedなアプリコンポーネントをトリガーしたり、機密性の高いcontent providersにアクセスしたりできる点です。代表的な例として、`WebView`コンポーネントがURLを`Intent`オブジェクトに`Intent.parseUri(...)`で変換し、それを実行して悪意あるIntent injectionsを引き起こす可能性があります。

### Essential Takeaways

- **Intent Injection** はWebのOpen Redirect問題に似ています。
- エクスプロイトは`Intent`オブジェクトをextrasとして渡し、それがリダイレクトされて安全でない操作を実行するようにすることを含みます。
- non-exportedなコンポーネントやcontent providersを攻撃者に露出させる可能性があります。
- `WebView`のURLから`Intent`への変換は、意図しない動作を助長することがあります。

### Android Client Side Injections and others

この種の脆弱性はWebで見たことがあるかもしれません。Androidアプリケーションでは特に以下の脆弱性に注意する必要があります:

- **SQL Injection:** 動的クエリやContent-Providersを扱う場合は、パラメータ化されたクエリを使用していることを確認してください。
- **JavaScript Injection (XSS):** すべてのWebViewsでJavaScriptとPluginのサポートが無効になっていることを確認してください（デフォルトでは無効）。 [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViewsはファイルシステムへのアクセスを無効にするべきです（デフォルトで有効） - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: 場合によっては、Androidアプリがセッションを終了してもcookieが取り消されなかったり、ディスクに保存されてしまうことがあります。
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Static analysis**

![](<../../images/image (866).png>)

**アプリケーションの脆弱性評価** は使いやすいwebベースのフロントエンドを利用して行われます。動的解析も実行できます（ただし環境の準備が必要です）。
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Assisted Dynamic analysis with MobSF

**MobSF** は **Android** の **dynamic analysis** に非常に便利ですが、その場合はホストに MobSF と **genymotion** をインストールする必要があります（VM や Docker では動作しません）。_Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
**MobSF dynamic analyser** は次のことができます:

- **Dump application data**（URLs、logs、clipboard、あなたが撮った screenshots、"Exported Activity Tester" が撮った screenshots、emails、SQLite databases、XML files、その他生成されたファイル）。これらはスクリーンショット以外は自動で実行されます。スクリーンショットは自分で撮るか、すべての exported activities のスクリーンショットを取得するには "**Exported Activity Tester**" を押す必要があります。
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: ロードされた全クラスを表示します
- **Capture Strings**: アプリ使用中にキャプチャされた文字列をすべて表示します（非常にノイジー）
- **Capture String Comparisons**: 非常に役立つ可能性があります。比較されている2つの文字列と、その結果が True か False かを**表示**します。
- **Enumerate Class Methods**: クラス名（例: "java.io.File"）を入力すると、そのクラスの全メソッドを表示します。
- **Search Class Pattern**: パターンでクラスを検索します
- **Trace Class Methods**: クラス全体を**Trace**します（そのクラスの全メソッドの入力と出力を確認できます）。デフォルトで MobSF はいくつかの興味深い Android Api メソッドをトレースすることを覚えておいてください。

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf also brings you a shell with some **adb** commands, **MobSF commands**, and common **shell** **commands** at the bottom of the dynamic analysis page. Some interesting commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTPツール**

HTTPトラフィックがキャプチャされると、下部の「**HTTP(S) Traffic**」ボタンで生の表示を、緑の「**Start HTTPTools**」ボタンで見やすい表示を見ることができます。後者のオプションからは、キャプチャしたリクエストをBurpやOwasp ZAPのような**プロキシ**に**送信**できます。\
その手順は、_Burpを起動 -->_ _Interceptをオフ --> MobSBのHTTPToolsで該当リクエストを選択_ --> 「**Send to Fuzzer**」を押す --> _プロキシアドレスを選択_ ([http://127.0.0.1:8080](http://127.0.0.1:8080))。

MobSFでの動的解析が完了したら、「**Start Web API Fuzzer**」を押してHTTPリクエストをfuzzし、脆弱性を探すことができます。

> [!TIP]
> MobSFで動的解析を行った後、プロキシ設定が誤って変更され、GUIから修正できないことがあります。次のコマンドでプロキシ設定を修正できます:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

ツールは[**Inspeckage**](https://github.com/ac-pm/Inspeckage)から入手できます。\
このツールはいくつかの**Hooks**を使って、動的解析を行っている間にアプリ内で**何が起きているか**を把握させてくれます。

### [Yaazhini](https://www.vegabird.com/yaazhini/)

これはGUIでの静的解析を行うための**優れたツール**です

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

このツールは、**source code**または**packaged APKs**内の複数の**security related Android application vulnerabilities**を検出するよう設計されています。さらに、検出した脆弱性（Exposed activities、intents、tapjacking...）を悪用するための「Proof-of-Concept」展開可能なAPKや**ADB commands**を生成することも可能です。Drozerと同様に、テストデバイスをrootする必要はありません。
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- 参照しやすいように抽出されたすべてのファイルを表示します
- APKファイルを自動的にJavaおよびSmali形式にデコンパイルします
- AndroidManifest.xmlを解析し、一般的な脆弱性や挙動を検出します
- 静的ソースコード解析により、一般的な脆弱性や挙動を検出します
- デバイス情報
- など
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPERはWindows、MacOS X、Linuxで使用できるコマンドラインアプリケーションで、_.apk_ファイルを解析して脆弱性を検出します。APKを展開し、一連のルールを適用して脆弱性を検出します。

すべてのルールは`rules.json`ファイルに集約されており、各企業やテスターは必要に応じて独自のルールを作成できます。

Download the latest binaries from in the [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAnは、モバイルアプリケーションの[static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis)を行う開発者、bugbounty hunters、ethical hackersを支援する**クロスプラットフォーム**ツールです。

概念は、モバイルアプリケーションファイル（.apk や .ipa ファイル）を StaCoAn アプリにドラッグアンドドロップすると、視覚的で持ち運び可能なレポートを生成するというものです。設定や wordlists を調整して、カスタマイズされた体験を得ることができます。

Download[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework は、Android アプリケーションの潜在的なセキュリティ脆弱性を開発者や hackers が発見するのを支援する脆弱性解析システムです。\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** は、Android アプリケーションによって発生する可能性のある悪意のある振る舞いを検出し、ユーザーに警告することを主目的としたツールです。

検出は、アプリケーションの Dalvik バイトコード（**Smali** で表現）に対する **static analysis** を [`androguard`](https://github.com/androguard/androguard) ライブラリで行います。

このツールは、**悪意のあるアプリケーションの一般的な挙動**（例：Telephony identifiers exfiltration、Audio/video flow interception、PIM data modification、Arbitrary code execution...）を探します。
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. モバイルアプリのリバースエンジニアリングおよび解析で一般的に使用されるツールをまとめ、OWASP のモバイルセキュリティ脅威に対するテストを支援するツールです。目的はモバイルアプリ開発者やセキュリティ専門家がこの作業をより簡単かつ扱いやすくすることです。

It is able to:

- さまざまなツールを使って Java と Smali のコードを抽出する
- Analyze APKs using: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- regexps を使って APK から private information を抽出する
- Manifest を解析する
- 検出されたドメインを以下で解析する: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Useful to detect malware: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

コードを難読化するために使用するサービスや設定によっては、Secrets が難読化されたままになったり、そうでなかったりします。

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. It is able to optimize bytecode as well as detect and remove unused instructions. ProGuard is free software and is distributed under the GNU General Public License, version 2.

ProGuard は Android SDK の一部として配布されており、アプリケーションを release モードでビルドする際に実行されます。

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Last time we checked, the Dexguard mode of operation was:

- リソースを InputStream として読み込む;
- 結果を FilterInputStream を継承するクラスに渡して復号する;
- リバースエンジニアの時間を数分浪費させるために無意味な難読化を行う;
- 復号した結果を ZipInputStream に渡して DEX ファイルを取得する;
- 最後に `loadDex` メソッドを使って得られた DEX を Resource としてロードする。

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

難読化されたプロセスを逆にすることで、コードの検査やライブラリ推定など、多数のセキュリティ解析を可能にします。

You can upload an obfuscated APK to their platform.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

It is a **generic android deobfuscator.** Simplify **virtually executes an app** to understand its behavior and then **tries to optimize the code** so it behaves identically but is easier for a human to understand. Each optimization type is simple and generic, so it doesn't matter what the specific type of obfuscation is used.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD gives you information about **how an APK was made**. It identifies many **compilers**, **packers**, **obfuscators**, and other weird stuff. It's [_PEiD_](https://www.aldeid.com/wiki/PEiD) for Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b is an Android security virtual machine based on ubuntu-mate includes the collection of latest framework, tutorials and labs from different security geeks and researchers for reverse engineering and malware analysis.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) 素晴らしいリソース一覧です
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android のクイックコース
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
