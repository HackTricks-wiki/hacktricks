# Pentesting d'applications Android

{{#include ../../banners/hacktricks-training.md}}

## Principes de base des applications Android

Il est fortement recommandé de commencer par lire cette page pour connaître les **parties les plus importantes liées à la sécurité Android et les composants les plus dangereux d'une application Android** :


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

C'est l'outil principal dont vous avez besoin pour vous connecter à un appareil Android (émulé ou physique).\
**ADB** permet de contrôler les appareils soit via **USB** soit via le **réseau** depuis un ordinateur. Cet utilitaire permet le **copiage** de fichiers dans les deux sens, l'**installation** et la **désinstallation** d'apps, l'**exécution** de commandes shell, la **sauvegarde** des données, la **lecture** des logs, entre autres fonctions.

Consultez la liste suivante de [**ADB Commands**](adb-commands.md) pour apprendre à utiliser adb.

## Smali

Parfois il est intéressant de **modifier le code de l'application** pour accéder à des **informations cachées** (peut-être des mots de passe bien obfusqués ou des flags). Dans ce cas, il peut être utile de décompiler l'apk, modifier le code et le recompiler.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Cela peut être très utile comme **alternative pour plusieurs tests pendant l'analyse dynamique** qui vont être présentés. Donc, **gardez toujours cette possibilité à l'esprit**.

## Autres astuces intéressantes

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [Android IME / InputMethodService Abuse (Malicious Keyboards)](inputmethodservice-ime-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **Télécharger des APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Extract APK from device:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Fusionner tous les splits et les apks de base avec [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Attaques Android Enterprise & Work Profile

{{#ref}}
android-enterprise-work-profile-bypass.md
{{#endref}}

## Études de cas & Vulnérabilités


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}


{{#ref}}
../../binary-exploitation/linux-kernel-exploitation/arm64-static-linear-map-kaslr-bypass.md
{{#endref}}

## Analyse statique

Tout d'abord, pour analyser un APK vous devriez **regarder le code Java** en utilisant un decompiler.\
S'il vous plaît, [**lisez ici pour trouver des informations sur les différents decompilers disponibles**](apk-decompilers.md).

### Recherche d'informations intéressantes

En regardant simplement les **strings** de l'APK vous pouvez rechercher des **mots de passe**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), des clés **API**, du **chiffrement**, des **bluetooth uuids**, des **tokens** et tout ce qui est intéressant... cherchez même des **backdoors** d'exécution de code ou des backdoors d'authentification (identifiants admin hardcodés dans l'app).

**Firebase**

Faites particulièrement attention aux **firebase URLs** et vérifiez si elles sont mal configurées. [Plus d'informations sur ce qu'est Firebase et comment l'exploiter ici.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Compréhension de base de l'application - Manifest.xml, strings.xml

L'**examen des fichiers _Manifest.xml_ et _strings.xml_ d'une application peut révéler des vulnérabilités de sécurité potentielles**. Ces fichiers peuvent être accessibles via des decompilers ou en renommant l'extension de l'APK en .zip puis en le dézippant.

**Vulnérabilités** identifiées depuis le **Manifest.xml** incluent :

- **Applications débogables** : Les applications définies comme debuggable (`debuggable="true"`) dans le _Manifest.xml_ présentent un risque car elles autorisent des connexions pouvant mener à une exploitation. Pour comprendre comment exploiter des applications debuggables, consultez un tutoriel sur la recherche et l'exploitation d'applications debuggables sur un appareil.
- **Paramètres de backup** : L'attribut `android:allowBackup="false"` devrait être explicitement défini pour les applications traitant des informations sensibles afin d'empêcher des sauvegardes de données non autorisées via adb, surtout lorsque le débogage USB est activé.
- **Sécurité réseau** : Les configurations réseau personnalisées (`android:networkSecurityConfig="@xml/network_security_config"`) dans _res/xml/_ peuvent spécifier des détails de sécurité comme des certificate pins et les paramètres de trafic HTTP. Un exemple est l'autorisation du trafic HTTP pour des domaines spécifiques.
- **Activities et Services exportés** : Identifier les activities et services exportés dans le manifest peut mettre en évidence des composants qui pourraient être détournés. Une analyse plus poussée lors des tests dynamiques peut révéler comment exploiter ces composants.
- **Content Providers et FileProviders** : Des content providers exposés pourraient permettre un accès non autorisé ou la modification de données. La configuration des FileProviders doit également être scrutée.
- **Broadcast Receivers et URL Schemes** : Ces composants pourraient être exploités, avec une attention particulière à la manière dont les URL schemes sont gérés pour les vulnérabilités d'entrée.
- **Versions SDK** : Les attributs `minSdkVersion`, `targetSDKVersion`, et `maxSdkVersion` indiquent les versions Android supportées, soulignant l'importance de ne pas supporter des versions Android obsolètes et vulnérables pour des raisons de sécurité.

Depuis le fichier **strings.xml**, des informations sensibles telles que des clés API, des schémas personnalisés et d'autres notes de développeur peuvent être découvertes, ce qui souligne la nécessité d'un examen attentif de ces ressources.

### Tapjacking

Tapjacking est une attaque où une **application** **malveillante** est lancée et **se positionne au-dessus d'une application victime**. Une fois qu'elle masque visiblement l'application cible, son interface utilisateur est conçue de manière à tromper l'utilisateur pour qu'il interagisse avec elle, tandis qu'elle transmet l'interaction à l'application victime.\
En pratique, cela **empêche l'utilisateur de savoir qu'il effectue en réalité des actions sur l'application victime**.

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Une **activity** avec le **`launchMode`** défini sur **`singleTask` sans aucun `taskAffinity`** défini est vulnérable au Task Hijacking. Cela signifie qu'une **application** peut être installée et, si elle est lancée avant la vraie application, elle pourrait **détourner la tâche de la véritable application** (ainsi l'utilisateur interagira avec la **malicious application en pensant utiliser la vraie**).

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Stockage de données non sécurisé

**Stockage interne**

Sur Android, les fichiers **stockés** en **stockage interne** sont **conçus** pour être **accessibles** exclusivement par l'**app** qui les a **créés**. Cette mesure de sécurité est **appliquée** par le système Android et est généralement suffisante pour les besoins de sécurité de la plupart des applications. Cependant, les développeurs utilisent parfois des modes tels que `MODE_WORLD_READABLE` et `MODE_WORLD_WRITABLE` pour **autoriser** le partage de fichiers entre différentes applications. Ces modes **n'empêchent pas l'accès** à ces fichiers par d'autres applications, y compris des applications potentiellement malveillantes.

1. Static Analysis :
- **Vérifiez** attentivement l'utilisation de `MODE_WORLD_READABLE` et `MODE_WORLD_WRITABLE`. Ces modes **peuvent exposer** des fichiers à des accès non désirés ou non autorisés.
2. Dynamic Analysis :
- **Vérifiez** les **permissions** définies sur les fichiers créés par l'app. En particulier, **contrôlez** si des fichiers sont **mis en lecture ou écriture pour le monde entier**. Cela peut représenter un risque de sécurité majeur, car cela permettrait à **toute application** installée sur l'appareil, quel que soit son origine ou son intention, de **lire ou modifier** ces fichiers.

**Stockage externe**

Lorsqu'on manipule des fichiers sur le **stockage externe**, comme les cartes SD, certaines précautions doivent être prises :

1. **Accessibilité** :
- Les fichiers sur le stockage externe sont **globalement lisibles et modifiables**. Cela signifie que toute application ou utilisateur peut accéder à ces fichiers.
2. **Problèmes de sécurité** :
- Étant donné la facilité d'accès, il est conseillé **de ne pas stocker d'informations sensibles** sur le stockage externe.
- Le stockage externe peut être retiré ou accédé par n'importe quelle application, ce qui le rend moins sécurisé.
3. **Traitement des données provenant du stockage externe** :
- Effectuez toujours une **validation d'entrée** sur les données récupérées depuis le stockage externe. C'est crucial car les données proviennent d'une source non fiable.
- Il est fortement déconseillé de stocker des exécutables ou des fichiers de classes sur le stockage externe pour un chargement dynamique.
- Si votre application doit récupérer des fichiers exécutables depuis le stockage externe, assurez-vous que ces fichiers sont **signés et vérifiés cryptographiquement** avant leur chargement dynamique. Cette étape est vitale pour maintenir l'intégrité de sécurité de votre application.

External storage can be **accessed** in `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> À partir d'Android 4.4 (**API 17**), la carte SD possède une structure de répertoires qui **limite l'accès d'une app au répertoire qui lui est spécifiquement destiné**. Cela empêche une application malveillante d'obtenir un accès en lecture ou écriture aux fichiers d'une autre app.

**Données sensibles stockées en texte clair**

- **Shared preferences** : Android permet à chaque application d'enregistrer facilement des fichiers xml dans le chemin `/data/data/<packagename>/shared_prefs/` et parfois il est possible de trouver des informations sensibles en clair dans ce dossier.
- **Databases** : Android permet à chaque application d'enregistrer facilement des bases sqlite dans le chemin `/data/data/<packagename>/databases/` et parfois il est possible de trouver des informations sensibles en clair dans ce dossier.

### TLS cassé

**Accept All Certificates**

Pour une raison ou une autre, parfois les développeurs acceptent tous les certificats même si, par exemple, le hostname ne correspond pas, avec des lignes de code comme la suivante :
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Cryptographie défaillante

**Mauvaises pratiques de gestion des clés**

Certains développeurs enregistrent des données sensibles dans le stockage local et les chiffrent avec une clé hardcodée/prédictible dans le code. Cela ne devrait pas être fait car un reverse engineering pourrait permettre à des attaquants d'extraire les informations confidentielles.

**Utilisation d'algorithmes non sécurisés et/ou dépréciés**

Les développeurs ne devraient pas utiliser des **algorithmes dépréciés** pour effectuer des **vérifications** d'**autorisation**, **stocker** ou **envoyer** des données. Certains de ces algorithmes sont : RC4, MD4, MD5, SHA1... Si des **hashes** sont utilisés pour stocker des mots de passe par exemple, des hashes **résistants au brute-force** devraient être utilisés avec du salt.

### Autres vérifications

- Il est recommandé d'**obfusquer l'APK** pour rendre le travail de reverse engineering plus difficile aux attaquants.
- Si l'app est sensible (comme les bank apps), elle devrait effectuer **ses propres vérifications pour détecter si le mobile est rooté** et agir en conséquence.
- Si l'app est sensible (comme les bank apps), elle devrait vérifier si un **emulator** est utilisé.
- Si l'app est sensible (comme les bank apps), elle devrait **vérifier son intégrité avant exécution** pour s'assurer qu'elle n'a pas été modifiée.
- Utilisez [**APKiD**](https://github.com/rednaga/APKiD) pour vérifier quel compiler/packer/obfuscator a été utilisé pour construire l'APK

### React Native Application

Lisez la page suivante pour apprendre comment accéder facilement au code javascript des applications React :


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Lisez la page suivante pour apprendre comment accéder facilement au code C# d'une application xamarin :


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

The tool [**mariana-trench**](https://github.com/facebook/mariana-trench) is capable of finding **vulnerabilities** by **scanning** the **code** of the application. This tool contains a series of **known sources** (that indicates to the tool the **places** where the **input** is **controlled by the user**), **sinks** (which indicates to the tool **dangerous** **places** where malicious user input could cause damages) and **rules**. These rules indicates the **combination** of **sources-sinks** that indicates a vulnerability.

With this knowledge, **mariana-trench will review the code and find possible vulnerabilities on it**.

### Secrets leaked

An application may contain secrets (API keys, passwords, hidden urls, subdomains...) inside of it that you might be able to discover. You could us a tool such as [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Exécution de code**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Envoi de SMS**: `sendTextMessage, sendMultipartTestMessage`
- **Fonctions natives** déclarées comme `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)
- Exécution de code natif en mémoire via JNI (shellcode téléchargé → mmap/mprotect → appel):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Analyse dynamique

> Tout d'abord, vous avez besoin d'un environnement où vous pouvez installer l'application et tout l'environnement (Burp CA cert, Drozer and Frida mainly). Par conséquent, un appareil rooté (émulé ou non) est fortement recommandé.

### Analyse dynamique en ligne

Vous pouvez créer un **compte gratuit** sur : [https://appetize.io/](https://appetize.io). Cette plateforme vous permet de **uploader** et **exécuter** des APKs, elle est donc utile pour voir le comportement d'un apk.

Vous pouvez même **voir les logs de votre application** sur le web et vous connecter via **adb**.

![](<../../images/image (831).png>)

Grâce à la connexion ADB vous pouvez utiliser **Drozer** et **Frida** à l'intérieur des émulateurs.

### Analyse dynamique locale

#### Utiliser un émulateur

- [**Android Studio**](https://developer.android.com/studio) (Vous pouvez créer des devices **x86** et **arm**, et selon [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**les dernières versions x86** **supportent les librairies ARM** sans nécessiter un émulateur arm lent).
- Apprenez à le configurer sur cette page :


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Version gratuite :** Personal Edition, vous devez créer un compte. _Il est recommandé de **télécharger** la version **AVEC**_ _**VirtualBox** pour éviter d'éventuelles erreurs._)
- [**Nox**](https://es.bignox.com) (Gratuit, mais il ne supporte pas Frida ou Drozer).

> [!TIP]
> Lorsque vous créez un nouvel émulateur sur n'importe quelle plateforme, rappelez-vous que plus l'écran est grand, plus l'émulateur sera lent. Choisissez donc des écrans petits si possible.

Pour **installer les services google** (comme AppStore) dans Genymotion, vous devez cliquer sur le bouton marqué en rouge dans l'image suivante :

![](<../../images/image (277).png>)

De plus, notez que dans la **configuration de la VM Android dans Genymotion** vous pouvez sélectionner le **Bridge Network mode** (cela sera utile si vous vous connectez à la VM Android depuis une autre VM avec les outils).

#### Utiliser un appareil physique

Vous devez activer les options de **debugging** et il serait souhaitable de pouvoir le **rooter** :

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Une fois que vous avez installé l'application, la première chose à faire est de l'essayer, d'étudier ce qu'elle fait, comment elle fonctionne et de vous familiariser avec elle.\
> Je suggère de **réaliser cette analyse dynamique initiale en utilisant MobSF dynamic analysis + pidcat**, ainsi nous pourrons **apprendre comment l'application fonctionne** pendant que MobSF **capture** beaucoup de **données intéressantes** que vous pourrez revoir plus tard.

Magisk/Zygisk quick notes (recommended on Pixel devices)
- Patch boot.img with the Magisk app and flash via fastboot to get systemless root
- Enable Zygisk + DenyList for root hiding; consider LSPosed/Shamiko when stronger hiding is required
- Keep original boot.img to recover from OTA updates; re-patch after each OTA
- For screen mirroring, use scrcpy on the host



### Fuites de données involontaires

**Logging**

Les développeurs doivent être prudents quant à l'exposition d'**informations de debug** publiquement, car cela peut conduire à des fuites de données sensibles. Les outils [**pidcat**](https://github.com/JakeWharton/pidcat) et `adb logcat` sont recommandés pour surveiller les logs des applications afin d'identifier et protéger les informations sensibles. **Pidcat** est privilégié pour sa facilité d'utilisation et sa lisibilité.

> [!WARNING]
> Notez que depuis **les versions postérieures à Android 4.0**, **les applications ne peuvent accéder qu'à leurs propres logs**. Ainsi, une application ne peut pas accéder aux logs d'autres apps.\
> Quoi qu'il en soit, il est toujours recommandé de **ne pas logger d'informations sensibles**.

**Copy/Paste Buffer Caching**

Le framework **basé sur le clipboard** d'Android permet la fonctionnalité de copy-paste dans les apps, mais présente un risque car **d'autres applications** peuvent **accéder** au clipboard, exposant potentiellement des données sensibles. Il est crucial de **désactiver les fonctions de copy/paste** pour les sections sensibles d'une application, comme les numéros de carte, afin d'éviter les fuites de données.

**Crash Logs**

Si une application **crashe** et **sauvegarde des logs**, ces logs peuvent aider des attaquants, en particulier lorsque l'application ne peut pas être reverse-engineered. Pour atténuer ce risque, évitez de logger lors de crashs, et si des logs doivent être transmis sur le réseau, assurez-vous qu'ils sont envoyés via un canal SSL pour la sécurité.

En tant que pentester, **essayez de jeter un coup d'œil à ces logs**.

**Analytics Data Sent To 3rd Parties**

Les applications intègrent souvent des services comme Google Adsense, qui peuvent involontairement **leak** des données sensibles à cause d'une mise en œuvre incorrecte par les développeurs. Pour identifier d'éventuelles fuites, il est conseillé d'**intercepter le trafic de l'application** et de vérifier si des informations sensibles sont envoyées à des services tiers.

### SQLite DBs

La plupart des applications utilisent des **bases de données SQLite internes** pour sauvegarder des informations. Pendant le pentest, jetez **un coup d'œil** aux **bases de données** créées, aux noms des **tables** et des **colonnes** et à toutes les **données** enregistrées car vous pourriez trouver des **informations sensibles** (ce qui constituerait une vulnérabilité).\
Les bases de données devraient se trouver dans `/data/data/the.package.name/databases` comme `/data/data/com.mwr.example.sieve/databases`

Si la base de données contient des informations confidentielles et est **chiffrée** mais que vous pouvez **trouver** le **mot de passe** à l'intérieur de l'application, c'est toujours une **vulnérabilité**.

Enumérez les tables en utilisant `.tables` et énumérez les colonnes des tables avec `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer is s useful tool to **exploit exported activities, exported services and Content Providers** as you will learn in the following sections.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Also remember that the code of an activity starts in the **`onCreate`** method.

**Authorisation bypass**

When an Activity is exported you can invoke its screen from an external app. Therefore, if an activity with **sensitive information** is **exported** you could **bypass** the **authentication** mechanisms **to access it.**

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

You can also start an exported activity from adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE** : MobSF détectera comme malveillant l'utilisation de _**singleTask/singleInstance**_ comme `android:launchMode` dans une activity, mais d'après [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparemment c'est seulement dangereux sur les anciennes versions (API versions < 21).

> [!TIP]
> Notez qu'un authorisation bypass n'est pas toujours une vulnérabilité, cela dépendra de la façon dont le bypass fonctionne et des informations exposées.

**Fuite d'informations sensibles**

**Les Activities peuvent aussi renvoyer des résultats**. Si vous parvenez à trouver une activity exportée et non protégée appelant la méthode **`setResult`** et **renvoyant des informations sensibles**, il y a une fuite d'informations sensibles.

#### Tapjacking

Si le tapjacking n'est pas empêché, vous pouvez abuser de l'activité exportée pour faire en sorte que **l'utilisateur effectue des actions inattendues**. Pour plus d'infos sur [**ce qu'est Tapjacking, suivez le lien**](#tapjacking).

### Exploiter les Content Providers - Accéder et manipuler des informations sensibles

[**Lisez ceci si vous voulez rafraîchir ce qu'est un Content Provider.**](android-applications-basics.md#content-provider)\
Les content providers sont essentiellement utilisés pour **partager des données**. Si une app dispose de content providers disponibles, il se peut que vous puissiez **extraire des données sensibles** d'eux. Il est aussi intéressant de tester d'éventuelles **SQL injections** et **Path Traversals** car ils pourraient être vulnérables.

[**Apprenez comment exploiter les Content Providers avec Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiter les Services**

[**Lisez ceci si vous voulez rafraîchir ce qu'est un Service.**](android-applications-basics.md#services)\
Rappelez-vous que les actions d'un Service démarrent dans la méthode `onStartCommand`.

Un Service est essentiellement quelque chose qui **peut recevoir des données**, **les traiter** et **retourner** (ou non) une réponse. Donc, si une application exporte des services, vous devriez **vérifier** le **code** pour comprendre ce qu'il fait et le **tester** **dynamiquement** pour extraire des infos confidentielles, contourner les mesures d'authentification...\
[**Apprenez comment exploiter les Services avec Drozer.**](drozer-tutorial/index.html#services)

### **Exploiter les Broadcast Receivers**

[**Lisez ceci si vous voulez rafraîchir ce qu'est un Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Rappelez-vous que les actions d'un Broadcast Receiver commencent dans la méthode `onReceive`.

Un broadcast receiver attendra un type de message. Selon la façon dont le receiver traite le message, il pourrait être vulnérable.\
[**Apprenez comment exploiter les Broadcast Receivers avec Drozer.**](#exploiting-broadcast-receivers)

### **Exploiter les Schemes / Deep links**

Vous pouvez chercher des deep links manuellement, en utilisant des outils comme MobSF ou des scripts comme [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Vous pouvez **ouvrir** un **scheme** déclaré en utilisant **adb** ou un **navigateur** :
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Notez que vous pouvez **omettre le nom du package** et que le mobile appellera automatiquement l'application qui doit ouvrir ce lien._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Code executed**

Pour trouver le **code that will be executed in the App**, allez à l'activité appelée par le deeplink et cherchez la fonction **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Informations sensibles**

Chaque fois que vous trouvez un deep link, vérifiez qu'**il ne reçoit pas de données sensibles (comme des mots de passe) via des paramètres d'URL**, car toute autre application pourrait **usurper le deep link et voler ces données !**

**Paramètres dans le chemin**

Vous **devez également vérifier si un deep link utilise un paramètre dans le chemin** de l'URL comme : `https://api.example.com/v1/users/{username}`, dans ce cas vous pouvez forcer un path traversal en accédant à quelque chose comme : `example://app/users?username=../../unwanted-endpoint%3fparam=value`.  
Notez que si vous trouvez les endpoints corrects dans l'application, vous pourriez provoquer un **Open Redirect** (si une partie du chemin est utilisée comme nom de domaine), un **account takeover** (si vous pouvez modifier les détails des utilisateurs sans token CSRF et que l'endpoint vulnérable utilise la bonne méthode) et toute autre vuln. More [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Transport Layer Inspection and Verification Failures

- **Certificates are not always inspected properly** by Android applications. Il est courant que ces applications ignorent les avertissements et acceptent des certificats auto-signés ou, dans certains cas, reviennent à des connexions HTTP.
- **Negotiations during the SSL/TLS handshake are sometimes weak**, utilisant des suites de chiffrement non sécurisées. Cette vulnérabilité rend la connexion vulnérable aux attaques man-in-the-middle (MITM), permettant aux attaquants de déchiffrer les données.
- **Leakage of private information** est un risque lorsque les applications s'authentifient via des canaux sécurisés mais communiquent ensuite sur des canaux non sécurisés pour d'autres transactions. Cette approche ne protège pas les données sensibles, comme les cookies de session ou les informations utilisateur, contre l'interception par des entités malveillantes.

#### Certificate Verification

Nous allons nous concentrer sur la **vérification des certificats**. L'intégrité du certificat du serveur doit être vérifiée pour renforcer la sécurité. Ceci est crucial car des configurations TLS non sécurisées et la transmission de données sensibles sur des canaux non chiffrés peuvent présenter des risques importants. Pour des étapes détaillées sur la vérification des certificats serveurs et la correction des vulnérabilités, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) fournit des conseils complets.

#### SSL Pinning

SSL Pinning est une mesure de sécurité où l'application vérifie le certificat du serveur par rapport à une copie connue stockée dans l'application elle-même. Cette méthode est essentielle pour prévenir les attaques MITM. Il est fortement recommandé d'implémenter SSL Pinning pour les applications traitant des informations sensibles.

#### Traffic Inspection

Pour inspecter le trafic HTTP, il est nécessaire d'**installer le certificat de l'outil proxy** (par ex., Burp). Sans l'installation de ce certificat, le trafic chiffré pourrait ne pas être visible via le proxy. Pour un guide sur l'installation d'un certificat CA personnalisé, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Les applications ciblant **API Level 24 and above** nécessitent des modifications du Network Security Config pour accepter le certificat CA du proxy. Cette étape est critique pour inspecter le trafic chiffré. Pour des instructions sur la modification du Network Security Config, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

Si **Flutter** est utilisé, vous devez suivre les instructions sur [**this page**](flutter.md). En effet, l'ajout du certificat dans le store ne suffira pas car Flutter possède sa propre liste de CAs valides.

#### Static detection of SSL/TLS pinning

Avant d'essayer des contournements à l'exécution, cartographiez rapidement où le pinning est appliqué dans l'APK. La découverte statique vous aide à planifier les hooks/patches et à vous concentrer sur les bons chemins de code.

Tool: SSLPinDetect
- Utilitaire d'analyse statique open-source qui décompile l'APK en Smali (via apktool) et scanne des patterns regex sélectionnés des implémentations de SSL/TLS pinning.
- Rapporte le chemin de fichier exact, le numéro de ligne et un extrait de code pour chaque correspondance.
- Couvre les frameworks courants et les chemins de code personnalisés : OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

Install
- Pré-requis : Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Utilisation
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Exemple de règles de motifs (JSON)
Utilisez ou étendez les signatures pour détecter des styles de pinning propriétaires/personnalisés. Vous pouvez charger votre propre JSON et lancer des scans à grande échelle.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Remarques et conseils
- Analyse rapide des grandes applications via le multi-threading et l'I/O mappée en mémoire ; des regex précompilées réduisent la surcharge/les faux positifs.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Cibles typiques à prioriser pour le triage :
- OkHttp: utilisation de CertificatePinner, setCertificatePinner, références aux packages okhttp3/okhttp
- TrustManagers personnalisés: javax.net.ssl.X509TrustManager, redéfinitions de checkServerTrusted
- Contextes SSL personnalisés: SSLContext.getInstance + SSLContext.init avec des managers personnalisés
- Pins déclaratifs dans res/xml network security config et références dans le manifest
- Utilisez les emplacements trouvés pour planifier des hooks Frida, des patchs statiques ou des revues de config avant les tests dynamiques.

#### Contournement de SSL Pinning

Lorsque le SSL Pinning est implémenté, le contourner devient nécessaire pour inspecter le trafic HTTPS. Différentes méthodes sont disponibles pour cela :

- Automatiquement **modifier** le **apk** pour **contourner** SSLPinning avec [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Le principal avantage de cette option est que vous n'aurez pas besoin de root pour contourner le SSL Pinning, mais vous devrez supprimer l'application et réinstaller la nouvelle, et cela ne fonctionnera pas toujours.
- Vous pouvez utiliser **Frida** (décrit ci-dessous) pour contourner cette protection. Voici un guide pour utiliser Burp+Frida+Genymotion : [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Vous pouvez aussi essayer de **contourner automatiquement SSL Pinning** en utilisant [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Vous pouvez aussi essayer de **contourner automatiquement SSL Pinning** en utilisant **MobSF dynamic analysis** (expliqué ci-dessous)
- Si vous pensez toujours qu'il y a du trafic que vous ne capturez pas, vous pouvez essayer de **rediriger le trafic vers Burp en utilisant iptables**. Lisez ce blog : [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Recherche de vulnérabilités Web courantes

Il est également important de rechercher des vulnérabilités web courantes au sein de l'application. Des informations détaillées sur l'identification et l'atténuation de ces vulnérabilités dépassent le cadre de ce résumé mais sont largement couvertes ailleurs.

### Frida

[Frida](https://www.frida.re) est un toolkit d'instrumentation dynamique pour développeurs, reverse-engineers, et chercheurs en sécurité.\
**Vous pouvez accéder à l'application en cours d'exécution et intercepter des méthodes à l'exécution pour modifier le comportement, changer des valeurs, extraire des valeurs, exécuter un code différent...**\
Si vous voulez pentest des applications Android vous devez savoir comment utiliser Frida.

- Apprenez à utiliser Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Des "GUI" pour interagir avec Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection est great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Vous pouvez trouver quelques scripts Frida remarquables ici: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Essayez de contourner les mécanismes anti-debugging / anti-frida en chargeant Frida comme indiqué dans [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (outil [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump de mémoire - Fridump**

Vérifiez si l'application stocke des informations sensibles en mémoire qu'elle ne devrait pas, comme des mots de passe ou des mnémoniques.

En utilisant [**Fridump3**](https://github.com/rootbsd/fridump3) vous pouvez dumper la mémoire de l'app avec:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Cela va dumper la mémoire dans le dossier ./dump, et vous pouvez y effectuer un grep avec quelque chose comme :
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Données sensibles dans Keystore**

Sur Android, le Keystore est l'endroit idéal pour stocker des données sensibles, cependant, avec des privilèges suffisants il est toujours **possible d'y accéder**. Comme les applications ont tendance à y stocker **des données sensibles en clair**, les pentests devraient vérifier cela en tant que root user ou une personne ayant un accès physique à l'appareil pourrait être capable de voler ces données.

Même si une app stocke des données dans le Keystore, les données devraient être chiffrées.

Pour accéder aux données à l'intérieur du Keystore vous pouvez utiliser ce Frida script: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

En utilisant le script Frida suivant, il peut être possible de **bypass fingerprint authentication** qu'effectuent certaines applications Android pour **protéger certaines zones sensibles :**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Images d'arrière-plan**

Lorsque vous mettez une application en arrière-plan, Android enregistre un **instantané de l'application** afin que, lorsqu'elle est ramenée au premier plan, elle commence par charger l'image avant l'application, donnant l'impression que l'application s'est lancée plus rapidement.

Cependant, si cet instantané contient des **informations sensibles**, quelqu'un ayant accès à l'instantané pourrait **voler ces informations** (note : il faut root pour y accéder).

Les instantanés sont généralement stockés à : **`/data/system_ce/0/snapshots`**

Android fournit un moyen de **prévenir la capture d'écran en définissant le paramètre de layout FLAG_SECURE**. En utilisant ce flag, le contenu de la fenêtre est traité comme sécurisé, empêchant qu'il apparaisse dans des captures d'écran ou qu'il soit affiché sur des écrans non sécurisés.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Analyseur d'applications Android**

Cet outil peut vous aider à gérer différents outils pendant l'analyse dynamique : [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Injection d'Intent

Les développeurs créent souvent des composants proxy comme des activities, des services et des broadcast receivers qui traitent ces Intents et les transmettent à des méthodes telles que `startActivity(...)` ou `sendBroadcast(...)`, ce qui peut être risqué.

Le danger réside dans le fait de permettre à des attaquants de déclencher des composants d'application non exportés ou d'accéder à des content providers sensibles en détournant ces Intents. Un exemple notable est le composant `WebView` qui convertit des URL en objets `Intent` via `Intent.parseUri(...)` puis les exécute, ce qui peut mener à des injections d'Intent malveillantes.

### Points essentiels

- **Intent Injection** est similaire au problème d'Open Redirect sur le web.
- Les exploits consistent à passer des objets `Intent` en tant qu'extras, qui peuvent être redirigés pour exécuter des opérations non sûres.
- Cela peut exposer des composants non-exportés et des content providers aux attaquants.
- La conversion d'URL en `Intent` par `WebView` peut faciliter des actions non intentionnelles.

### Injections côté client Android et autres

Vous connaissez probablement ce type de vulnérabilités depuis le web. Il faut être particulièrement vigilant avec ces vulnérabilités dans une application Android :

- **SQL Injection:** Lors du traitement de requêtes dynamiques ou de Content-Providers, assurez-vous d'utiliser des requêtes paramétrées.
- **JavaScript Injection (XSS):** Vérifiez que le support JavaScript et des plugins est désactivé pour tout WebViews (disabled by default). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews should have access to the file system disabled (enabled by default) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies** : Dans plusieurs cas, lorsqu'une application Android termine la session, le cookie n'est pas révoqué ou peut même être enregistré sur le disque
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Analyse automatique

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Analyse statique**

![](<../../images/image (866).png>)

Évaluation des vulnérabilités de l'application via une interface web conviviale. Vous pouvez aussi effectuer une analyse dynamique (mais il faut préparer l'environnement).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Assisted Dynamic analysis with MobSF

**MobSF** can also be very helpful for **dynamic analysis** in **Android**, but in that case you will need to install MobSF and **genymotion** in your host (a VM or Docker won't work). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
The **MobSF dynamic analyser** can:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). All of this is done automatically except for the screenshots, you need to press when you want a screenshot or you need to press "**Exported Activity Tester**" to obtain screenshots of all the exported activities.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: It will print all the loaded classes
- **Capture Strings**: It will print all the capture strings while using the application (super noisy)
- **Capture String Comparisons**: Could be very useful. It will **show the 2 strings being compared** and if the result was True or False.
- **Enumerate Class Methods**: Put the class name (like "java.io.File") and it will print all the methods of the class.
- **Search Class Pattern**: Search classes by pattern
- **Trace Class Methods**: **Trace** a **whole class** (see inputs and outputs of all methods of th class). Remember that by default MobSF traces several interesting Android Api methods.

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf also brings you a shell with some **adb** commands, **MobSF commands**, and common **shell** **commands** at the bottom of the dynamic analysis page. Some interesting commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**Outils HTTP**

Lorsque le trafic HTTP est capturé, vous pouvez voir une vue brute du trafic capturé sur le bouton "**HTTP(S) Traffic**" en bas ou une vue plus agréable dans le bouton vert "**Start HTTPTools**". Depuis la deuxième option, vous pouvez **send** les **captured requests** vers des **proxies** comme Burp ou Owasp ZAP.\
Pour ce faire, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> appuyez sur "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Une fois l'analyse dynamique terminée avec MobSF, vous pouvez cliquer sur "**Start Web API Fuzzer**" pour **fuzz** les requêtes HTTP et rechercher des vulnérabilités.

> [!TIP]
> Après avoir effectué une analyse dynamique avec MobSF, les paramètres de proxy peuvent être mal configurés et vous ne pourrez pas les corriger depuis la GUI. Vous pouvez corriger les paramètres de proxy en exécutant :
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Analyse dynamique assistée avec Inspeckage

Vous pouvez obtenir l'outil depuis [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Cet outil utilisera certains **Hooks** pour vous indiquer **ce qui se passe dans l'application** pendant que vous effectuez une **dynamic analysis**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

C'est un **excellent outil pour effectuer du static analysis avec une GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Cet outil est conçu pour rechercher plusieurs **vulnérabilités liées à la sécurité des applications Android**, soit dans le **source code** soit dans des **packaged APKs**. L'outil est également **capable of creating a "Proof-of-Concept" deployable APK** et des **ADB commands**, pour exploiter certaines des vulnérabilités trouvées (Exposed activities, intents, tapjacking...). Comme avec Drozer, il n'est pas nécessaire de rooter l'appareil de test.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Affiche tous les fichiers extraits pour une consultation facile
- Décompile automatiquement les fichiers APK aux formats Java et Smali
- Analyse AndroidManifest.xml pour les vulnérabilités et comportements courants
- Analyse statique du code source pour les vulnérabilités et comportements courants
- Informations sur l'appareil
- et plus encore
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER est une application en ligne de commande utilisable sous Windows, MacOS X et Linux, qui analyse les fichiers _.apk_ à la recherche de vulnérabilités. Elle procède en décompressant les APKs et en appliquant une série de règles pour détecter ces vulnérabilités.

Toutes les règles sont centralisées dans un fichier `rules.json`, et chaque entreprise ou testeur peut créer ses propres règles pour analyser ce dont il a besoin.

Téléchargez les binaires les plus récents depuis la [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn est un outil **crossplatform** qui aide les développeurs, les bugbounty hunters et les ethical hackers à effectuer des [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) sur des applications mobiles.

Le principe est que vous glissez-déposez le fichier de votre application mobile (un .apk ou .ipa file) sur l'application StaCoAn, qui générera pour vous un rapport visuel et portable. Vous pouvez ajuster les paramètres et les wordlists pour obtenir une expérience personnalisée.

Télécharger[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework est un système d'analyse des vulnérabilités Android qui aide les développeurs ou les hackers à trouver des vulnérabilités potentielles dans les applications Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** est un outil dont l'objectif principal est de détecter et d'avertir l'utilisateur des comportements potentiellement malveillants développés par une application Android.

La détection est effectuée par la **static analysis** du Dalvik bytecode de l'application, représenté en **Smali**, avec la bibliothèque [`androguard`](https://github.com/androguard/androguard).

Cet outil recherche les **comportements courants d'applications "malveillantes"** tels que : Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** est un **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. C'est un outil qui regroupe des outils couramment utilisés pour le reverse engineering et l'analyse d'applications mobiles, afin d'aider à tester les applications mobiles contre les menaces de sécurité mobile d'OWASP. Son objectif est de faciliter cette tâche et de la rendre plus accessible aux développeurs d'applications mobiles et aux professionnels de la sécurité.

Il peut :

- Extraire du code Java et Smali en utilisant différents outils
- Analyser des APKs en utilisant : [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Extraire des informations privées depuis l'APK en utilisant des regexps.
- Analyser le Manifest.
- Analyser les domaines trouvés en utilisant : [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) et [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Déobfusquer l'APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Utile pour détecter des malwares : [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Notez que, selon le service et la configuration que vous utilisez pour obfusquer le code, les secrets peuvent ou non rester obfusqués.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** est un outil en ligne de commande open source qui réduit, optimise et obfusque le code Java. Il est capable d'optimiser le bytecode ainsi que de détecter et supprimer les instructions non utilisées. ProGuard est un logiciel libre distribué sous la GNU General Public License, version 2.

ProGuard est distribué dans l'Android SDK et s'exécute lors de la compilation de l'application en mode release.

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) La dernière fois que nous avons vérifié, le mode de fonctionnement de Dexguard était :

- charger une ressource en tant qu'InputStream ;
- passer le résultat à une classe héritant de FilterInputStream pour le déchiffrer ;
- effectuer une obfuscation inutile pour faire perdre quelques minutes à un reverser ;
- passer le résultat déchiffré à un ZipInputStream pour obtenir un fichier DEX ;
- enfin charger le DEX résultant en tant que Resource en utilisant la méthode `loadDex`.

### [DeGuard](http://apk-deguard.com)

**DeGuard inverse le processus d'obfuscation réalisé par les outils d'obfuscation Android. Cela permet de nombreuses analyses de sécurité, y compris l'inspection du code et l'identification des bibliothèques.**

Vous pouvez téléverser un APK obfusqué sur leur plateforme.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

C'est un déobfuscateur Android générique. Simplify exécute virtuellement une app pour comprendre son comportement, puis essaie d'optimiser le code afin qu'il se comporte de manière identique mais soit plus facile à comprendre pour un humain. Chaque type d'optimisation est simple et générique, donc le type spécifique d'obfuscation utilisé n'a pas d'importance.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD vous fournit des informations sur la façon dont un APK a été réalisé. Il identifie de nombreux compilers, packers, obfuscators, et autres trucs bizarres. C'est le [_PEiD_](https://www.aldeid.com/wiki/PEiD) pour Android.

### Manual

[Lisez ce tutoriel pour apprendre quelques astuces sur comment reverse custom obfuscation](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b est une machine virtuelle de sécurité Android basée sur ubuntu-mate qui inclut une collection des derniers frameworks, tutoriels et labs de différents passionnés et chercheurs en sécurité pour le reverse engineering et l'analyse de malware.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) C'est une excellente liste de ressources
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Cours rapide Android
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
