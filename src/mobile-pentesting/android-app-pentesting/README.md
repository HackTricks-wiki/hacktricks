# Android-toepassings Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android-toepassings Basiese beginsels

Dit word sterk aanbeveel om eers hierdie bladsy te lees om te weet oor die **belangrikste dele wat met Android-sekuriteit verband hou en die gevaarlikste komponente in 'n Android-toepassing**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Dit is die hoofinstrument wat jy nodig het om verbinding te maak met 'n Android-toestel (geëmuleer of fisies).\
**ADB** laat toe om toestelle te beheer óf via **USB** óf via **Netwerk** vanaf 'n rekenaar. Hierdie hulpmiddel maak moontlik die **kopieer** van lêers in beide rigtings, die **installering** en **verwydering** van apps, die **uitvoering** van shell-opdragte, die **rugsteun** van data, die **lees** van logs, en ander funksies.

Kyk na die volgende lys van [**ADB Commands**](adb-commands.md) om te leer hoe om adb te gebruik.

## Smali

Soms is dit interessant om die **aansoekkode te wysig** om toegang te kry tot **verborgte inligting** (miskien goed verdoeselde wagwoorde of flags). Dan kan dit sin maak om die apk te dekompileer, die kode te wysig en dit weer te compileer.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Dit kan baie nuttig wees as 'n **alternatief vir verskeie toetse tydens die dinamiese ontleding** wat aangebied gaan word. Hou dus hierdie moontlikheid altyd in gedagte.

## Ander interessante truuks

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [Android IME / InputMethodService Abuse (Malicious Keyboards)](inputmethodservice-ime-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Onttrek APK van toestel:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Voeg alle split- en base-apks saam met [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Android Enterprise & Work Profile Aanvalle

{{#ref}}
android-enterprise-work-profile-bypass.md
{{#endref}}

## Gevallestudies & Kwesbaarhede


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

{{#ref}}
abusing-android-media-pipelines-image-parsers.md
{{#endref}}

{{#ref}}
../../binary-exploitation/linux-kernel-exploitation/arm64-static-linear-map-kaslr-bypass.md
{{#endref}}

## Statiese Analise

Eerstens, vir die ontleding van 'n APK moet jy **na die Java-kode kyk** met 'n dekompiler.\
Lees asseblief [**hier om inligting te vind oor verskillende beskikbare dekompilers**](apk-decompilers.md).

### Soek na interessante inligting

Deur net na die **strings** van die APK te kyk kan jy soek na **wagwoorde**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** sleutels, **enkripsie**, **bluetooth uuids**, **tokens** en enigiets interessant... kyk selfs vir kode-uitvoerings **backdoors** of outhentisering backdoors (hardcoded admin credentials in die app).

**Firebase**

Gee spesiale aandag aan **firebase URLs** en kontroleer of dit verkeerd gekonfigureer is. [Meer inligting oor wat Firebase is en hoe om dit uit te buit hier.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Basiese begrip van die toepassing - Manifest.xml, strings.xml

Die **ondersoek van 'n toepassing se _Manifest.xml_ en **_strings.xml_** lêers kan potensiële sekuriteitskwesbaarhede openbaar**. Hierdie lêers kan benader word deur dekompilers of deur die APK-lêeruitbreiding na .zip te hernoem en dit dan uit te pak.

**Kwesbaarhede** geïdentifiseer uit die **Manifest.xml** sluit in:

- **Debuggable Applications**: Toepassings wat as debuggable (`debuggable="true"`) in die _Manifest.xml_ gesetel is, vorm 'n risiko aangesien dit verbindings toelaat wat tot uitbuiting kan lei. Vir meer begrip oor hoe om debuggable applications uit te buit, verwys na 'n handleiding oor die vind en uitbuiting van debuggable applications op 'n toestel.
- **Backup Settings**: Die `android:allowBackup="false"` attribuut moet uitdruklik gestel wees vir toepassings wat met sensitiewe inligting handel om ongemagtigde databackups via adb te voorkom, veral wanneer usb debugging aangeskakel is.
- **Network Security**: Pasgemaakte network security-konfigurasies (`android:networkSecurityConfig="@xml/network_security_config"`) in _res/xml/_ kan sekuriteitsbesonderhede soos sertifikaat-pins en HTTP-verkeer-instellings spesifiseer. 'n Voorbeeld is die toelaat van HTTP-verkeer vir spesifieke domeine.
- **Exported Activities and Services**: Identifisering van exported activities en services in die manifest kan komponente uitlig wat misbruik kan word. Verdere analise tydens dinamiese toetsing kan openbaar hoe om hierdie komponente uit te buit.
- **Content Providers and FileProviders**: Blootgestelde content providers kan ongemagtigde toegang of wysiging van data toelaat. Die konfigurasie van FileProviders moet ook ondersoek word.
- **Broadcast Receivers and URL Schemes**: Hierdie komponente kan benut word vir uitbuiting, met besondere aandag aan hoe URL schemes bestuur word vir invoer-kwesbaarhede.
- **SDK Versions**: Die `minSdkVersion`, `targetSDKVersion`, en `maxSdkVersion` attribuite dui die ondersteunde Android-weergawes aan, wat die belangrikheid beklemtoon om geen verouderde, kwesbare Android-weergawes te ondersteun nie.

Uit die **strings.xml** lêer kan sensitiewe inligting soos API-sleutels, pasgemaakte schemas, en ander ontwikkelaar aantekeninge ontdek word, wat die noodsaaklikheid van deeglike hersiening van hierdie hulpbronne beklemtoon.

### Tapjacking

**Tapjacking** is 'n aanval waar 'n **malicious** **application** geloods word en **sigself bo-op 'n slagoffer-toepassing posisioneer**. Sodra dit die slagoffer-app sigbaar bedek, is sy gebruikerskoppelvlak so ontwerp om die gebruiker te mislei om daarmee te interaksie terwyl dit die interaksie aan die slagoffer-app deurgee.\
In werklikheid is dit dat dit **die gebruiker blind maak vir die feit dat hulle eintlik aksies op die slagoffer-app uitvoer**.

Vind meer inligting in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

'n **Activity** met die **`launchMode`** gestel op **`singleTask` sonder enige `taskAffinity`** gedefinieer is kwesbaar vir Task Hijacking. Dit beteken dat 'n **application** geïnstalleer kan word en as dit voor die werklike toepassing geloods word dit die **task van die werklike toepassing kan kaap** (sodat die gebruiker met die **malicious application sal werk terwyl hy dink hy gebruik die werklike een**).

Meer inligting in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Onveilige data berging

**Internal Storage**

In Android is lêers **gestoor** in **internal** storage **ontwerp** om uitsluitlik deur die **app** wat dit **geskep** het toeganklik te wees. Hierdie sekuriteitsmaatreël word deur die Android-bedryfstelsel **afgedwing** en is oor die algemeen voldoende vir die sekuriteitsbehoeftes van meeste toepassings. Ontwikkelaars gebruik egter soms modes soos `MODE_WORLD_READABLE` en `MODE_WORLD_WRITABLE` om lêers tussen verskillende toepassings te **deel**. Hierdie modes **beperk egter nie toegang** tot hierdie lêers deur ander toepassings, insluitend moontlik kwaadwillige nie.

1. **Static Analysis:**
- **Maak seker** dat die gebruik van `MODE_WORLD_READABLE` en `MODE_WORLD_WRITABLE` **noukeurig ondersoek** word. Hierdie modes **kan moontlik lêers blootstel** aan **ontekende of ongemagtigde toegang**.
2. **Dynamic Analysis:**
- **Verifieer** die **permitte** wat op lêers geskep deur die app gestel is. Kontroleer spesifiek of enige lêers **gestel is om wêreldwyd leesbaar of skryfbaar te wees**. Dit kan 'n beduidende sekuriteitsrisiko inhou, aangesien dit **enige toepassing** geïnstalleer op die toestel, ongeag oorsprong of bedoeling, sal toelaat om hierdie lêers te **lees of te wysig**.

**External Storage**

Wanneer daar met lêers op **external storage** gewerk word, soos SD Cards, moet sekere voorsorgmaatreëls getref word:

1. **Toeganklikheid**:
- Lêers op external storage is **globals leesbaar en skryfbaar**. Dit beteken enige toepassing of gebruiker kan toegang hê tot hierdie lêers.
2. **Sekuriteitskwessies**:
- Gegewe die maklike toegang, word dit aanbeveel **nie om sensitiewe inligting op external storage te stoor nie**.
- External storage kan verwyder word of deur enige toepassing toeganklik wees, wat dit minder veilig maak.
3. **Hanering van data van External Storage**:
- Voer altyd **invoervalidatie** uit op data wat van external storage gehaal word. Dit is kritiek omdat die data van 'n nie-vertroude bron is.
- Dit word sterk ontraden om uitvoerbare of klaslêers op external storage te stoor vir dinamiese laai.
- As jou toepassing uitvoerbare lêers van external storage moet laai, maak seker dat hierdie lêers **gesigneer en kriptografies geverifieer** is voordat dit dinamies gelaai word. Hierdie stap is noodsaaklik om die sekuriteitsintegriteit van jou toepassing te handhaaf.

External storage kan **geakses** word in `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> Vanaf Android 4.4 (**API 17**) het die SD-kaart 'n gidsstruktuur wat **toegang van 'n app beperk tot die gids wat spesifiek vir daardie app is**. Dit voorkom dat kwaadwillige toepassings lees- of skryf toegang tot 'n ander app se lêers kry.

**Sensitive data stored in clear-text**

- **Shared preferences**: Android laat elke toepassing maklik toe om xml-lêers te stoor in die pad `/data/data/<packagename>/shared_prefs/` en soms is dit moontlik om sensitiewe inligting in clear-text in daardie gids te vind.
- **Databases**: Android laat elke toepassing maklik toe om sqlite databases te stoor in die pad `/data/data/<packagename>/databases/` en soms is dit moontlik om sensitiewe inligting in clear-text in daardie gids te vind.

### Broken TLS

**Accept All Certificates**

Om een of ander rede aanvaar ontwikkelaars soms alle sertifikate selfs al stem byvoorbeeld die hostname nie ooreen nie met reëls van kode soos die volgende een:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
'n Goeie manier om dit te toets is om die verkeer vas te vang met 'n proxy soos Burp sonder om die Burp CA binne die toestel te authoriseer. Ook kan jy met Burp 'n sertifikaat vir 'n ander hostname genereer en dit gebruik.

### Gebroke Kriptografie

**Swak Sleutelbestuursprosesse**

Sommige ontwikkelaars stoor sensitiewe data in die plaaslike stoorplek en enkripteer dit met 'n sleutel hardgekodeer/voorspelbaar in die kode. Dit behoort nie gedoen te word nie aangesien reversing aanvallers kan toelaat om die vertroulike inligting te onttrek.

**Gebruik van Onseker en/of Verouderde Algoritmes**

Ontwikkelaars moet nie verouderde algoritmes gebruik om authorisasie-kontroles uit te voer, data te stoor of te stuur nie. Sommige van hierdie algoritmes is: RC4, MD4, MD5, SHA1... As hashes byvoorbeeld gebruik word om wagwoorde te stoor, moet hashes wat brute-force resistant is saam met salt gebruik word.

### Ander kontroles

- Dit word aanbeveel om die APK te obfuscate om die reverse engineer se werk vir aanvallers moeiliker te maak.
- Indien die app sensitief is (soos bankapps), moet dit sy eie kontroles uitvoer om te sien of die mobiele toestel geroot is en dienooreenkomstig optree.
- Indien die app sensitief is (soos bankapps), moet dit nagaan of 'n **emulator** gebruik word.
- Indien die app sensitief is (soos bankapps), moet dit sy eie integriteit kontroleer voordat dit uitgevoer word om te sien of dit gewysig is.
- Gebruik [**APKiD**](https://github.com/rednaga/APKiD) om te kontroleer watter compiler/packer/obfuscator gebruik is om die APK te bou

### React Native Application

Lees die volgende bladsy om te leer hoe om maklik toegang te kry tot javascript code van React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Lees die volgende bladsy om te leer hoe om maklik toegang te kry tot C# code van 'n Xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

Volgens hierdie [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) is superpacked 'n Meta-algoritme wat die inhoud van 'n toepassing in 'n enkele lêer saamdruk. Die blog praat oor die moontlikheid om 'n app te skep wat hierdie tipe apps ontpak... en 'n vinniger manier wat behels om die toepassing uit te voer en die ontpakte lêers van die lêerstelsel te versamel.

### Outomatiese Statiese Kode-analise

Die tool [**mariana-trench**](https://github.com/facebook/mariana-trench) is in staat om kwesbaarhede te vind deur die code van die toepassing te scan. Hierdie tool bevat 'n reeks **known sources** (wat aan die tool aandui die plekke waar die **input** deur die gebruiker beheer word), **sinks** (wat aan die tool gevaarlike plekke aandui waar kwaadwillige gebruikersinvoer skade kan veroorsaak) en **rules**. Hierdie rules dui die kombinasie van **sources-sinks** aan wat 'n kwesbaarheid aandui.

Met hierdie kennis sal **mariana-trench die code hersien en moontlike kwesbaarhede daarin vind**.

### Secrets leaked

'n Toepassing kan geheimenisse (API keys, passwords, hidden urls, subdomains...) daarin bevat wat jy dalk kan ontdek. Jy kan 'n tool gebruik soos [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Ander interessante funksies

- **Kode-uitvoering**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Stuur SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native funksies** verklaar as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)
- In-memory native code execution via JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Ander truuks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamiese Analise

> Eerstens benodig jy 'n omgewing waarin jy die toepassing en al die nodige komponente (Burp CA cert, Drozer en Frida hoofsaaklik) kan installeer. Daarom word 'n gerootte toestel (geëmuleer of nie) sterk aanbeveel.

### Aanlyn Dynamiese analise

Jy kan 'n **gratis rekening** skep by: [https://appetize.io/](https://appetize.io). Hierdie platform laat jou toe om APKs te **upload** en te **execute**, dus is dit nuttig om te sien hoe 'n apk optree.

Jy kan selfs **die logs van jou toepassing** op die web sien en deur **adb** verbind.

![](<../../images/image (831).png>)

Dankie aan die ADB-verbinding kan jy **Drozer** en **Frida** binne die emulators gebruik.

### Lokale Dynamiese Analise

#### Gebruik van 'n emulator

- [**Android Studio**](https://developer.android.com/studio) (Jy kan **x86** en **arm** toestelle skep, en volgens [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html) ondersteun die nuutste x86 weergawes ARM libraries sonder om 'n stadige arm emulator te benodig).
- Leer om dit op te stel op hierdie bladsy:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Gratis weergawe:** Personal Edition, jy moet 'n rekening skep. _Dit word aanbeveel om die weergawe **MET**_ _**VirtualBox** af te laai om potensiële foute te voorkom._)
- [**Nox**](https://es.bignox.com) (Gratis, maar dit ondersteun nie Frida of Drozer nie).

> [!TIP]
> Wanneer jy 'n nuwe emulator op enige platform skep, onthou dat hoe groter die skerm is, hoe stadiger die emulator sal loop. Kies dus klein skerms indien moontlik.

Om **Google services** (soos AppStore) in Genymotion te installeer, moet jy op die rooi gemerkte knoppie in die volgende beeld klik:

![](<../../images/image (277).png>)

Let ook daarop dat in die **konfigurasie van die Android VM in Genymotion** jy **Bridge Network mode** kan kies (dit sal nuttig wees as jy van 'n ander VM met die gereedskap na die Android VM wil koppel).

#### Gebruik van 'n fisiese toestel

Jy moet die **debugging** opsies aktiveer en dit sal goed wees as jy dit kan **root**:

1. **Settings**.
2. (Vanaf Android 8.0) Kies **System**.
3. Kies **About phone**.
4. Druk **Build number** 7 keer.
5. Gaan terug en jy sal die **Developer options** vind.

> Sodra jy die toepassing geïnstalleer het, is die eerste ding wat jy moet doen om dit te probeer en ondersoek wat dit doen, hoe dit werk en gemaklik te raak daarmee.\
> Ek stel voor om **daardie aanvanklike dinamiese analise met MobSF dynamic analysis + pidcat** uit te voer, sodat ons kan **leer hoe die toepassing werk** terwyl MobSF 'n groot hoeveelheid **interessante** **data** vasvang wat jy later kan nagaan.

Magisk/Zygisk vinnige notas (aanbeveel op Pixel-toestelle)
- Patch boot.img met die Magisk app en flash via fastboot om systemless root te kry
- Aktiveer Zygisk + DenyList vir root-versteeking; oorweeg LSPosed/Shamiko wanneer sterker versteeking benodig word
- Hou die oorspronklike boot.img om van OTA-opdaterings te herstel; her-patch na elke OTA
- Vir skermspieël, gebruik scrcpy op die host

### Unintended Data Leakage

**Logging**

Ontwikkelaars moet versigtig wees om **debugging information** openbaar te maak, aangesien dit tot sensitiewe data leaks kan lei. Die gereedskap [**pidcat**](https://github.com/JakeWharton/pidcat) en `adb logcat` word aanbeveel om toepassingslogs te monitor om sensitiewe inligting te identifiseer en te beskerm. **Pidcat** word verkies vir sy gebruiksgemak en leesbaarheid.

> [!WARNING]
> Let daarop dat vanaf weergawes later as Android 4.0, **toepassings slegs toegang tot hul eie logs het**. Dus kan toepassings nie toegang kry tot ander apps se logs nie.\
> Dit word nog steeds aanbeveel om **nie sensitiewe inligting te log nie**.

**Kopieer/Plak Klembord-kas**

Android se **clipboard-based** raamwerk maak kopiër-plak funksionaliteit in apps moontlik, maar hou 'n risiko in dat **ander toepassings** die klembord kan **access**, wat moontlik sensitiewe data blootstel. Dit is noodsaaklik om kopiër/plak funksies vir sensitiewe gedeeltes van 'n toepassing, soos kredietkaartbesonderhede, te deaktiveer om data leaks te voorkom.

**Crash Logs**

Indien 'n toepassing **crashes** en **stoor logs**, kan hierdie logs aanvallers help, veral wanneer die toepassing nie reverse-engineered kan word nie. Om hierdie risiko te versag, vermy om by crashes te log, en as logs oor die netwerk gestuur moet word, verseker dat dit via 'n SSL-kanaal gestuur word vir sekuriteit.

As pentester, **probeer om na hierdie logs te kyk**.

**Analytics Data Sent To 3rd Parties**

Toepassings integreer dikwels dienste soos Google Adsense, wat onbedoeld **leak sensitive data** kan veroorsaak as gevolg van onvanpaste implementering deur ontwikkelaars. Om potensiële data leaks te identifiseer, is dit raadsaam om die toepassing se verkeer te **intercept** en te kontroleer vir enige sensitiewe inligting wat na derdeparty-dienste gestuur word.

### SQLite DBs

Die meeste toepassings sal **internal SQLite databases** gebruik om inligting te stoor. Tydens die pentest neem 'n kyk na die geskepte **databases**, die name van **tables** en **columns** en al die **data** wat gestoor is omdat jy moontlik **sensitive information** kan vind (wat 'n kwesbaarheid sou wees).\
Databases behoort te wees geleë in `/data/data/the.package.name/databases` soos `/data/data/com.mwr.example.sieve/databases`

Indien die databasis vertroulike inligting stoor en **encrypted** is maar jy kan die **password** binne die toepassing **find**, is dit steeds 'n **vulnerability**.

Enumereer die tables met `.tables` en enumereer die kolomme van die tables deur `.schema <table_name>` uit te voer

### Drozer (Exploit Activities, Content Providers and Services)

Van [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** laat jou toe om die rol van 'n Android app aan te neem en met ander apps te interakteer. Dit kan **alles doen wat 'n geïnstalleerde toepassing kan doen**, soos gebruik maak van Android se Inter-Process Communication (IPC) meganisme en met die onderliggende bedryfstelsel interakteer. \
Drozer is 'n nuttige tool om **exploit exported activities, exported services and Content Providers** soos jy in die volgende afdelings sal leer.

### Exploiting exported Activities

[**Lees dit as jy wil verfris wat 'n Android Activity is.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Onthou ook dat die kode van 'n activity begin in die **`onCreate`** metode.

**Authorisation bypass**

Wanneer 'n Activity exported is kan jy sy skerm vanuit 'n eksterne app oproep. Daarom, as 'n activity met **sensitive information** **exported** is, kan jy die **authentication** meganismes **bypass** om toegang daartoe te kry.

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

Jy kan ook 'n exported activity vanaf adb begin:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF sal die gebruik van _**singleTask/singleInstance**_ as `android:launchMode` in 'n activity as kwaadwillig beskou, maar weens [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), blyk dit schynbaar slegs gevaarlik op ouer weergawes (API versions < 21).

> [!TIP]
> Let wel dat 'n authorisation bypass nie altyd 'n kwesbaarheid is nie; dit hang af van hoe die bypass werk en watter inligting blootgestel word.

**Gevoelige inligting lekkasie**

**Activities kan ook resultate teruggee**. As jy daarin slaag om 'n exported en onbeveiligde activity te vind wat die **`setResult`** metode aanroep en **sensitiewe inligting** teruggee, is daar 'n gevoelige inligting-lekkasie.

#### Tapjacking

As Tapjacking nie voorkom word nie, kan jy die exported activity misbruik om die **gebruiker onvoorsiene aksies te laat uitvoer**. Vir meer inligting oor [**wat Tapjacking is volg die skakel**](#tapjacking).

### Exploiting Content Providers - Toegang tot en manipulasie van sensitiewe inligting

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers word hoofsaaklik gebruik om **data te deel**. As 'n app beskikbare content providers het, kan jy moontlik **sensitiewe data onttrek** uit hulle. Dit is ook interessant om moontlike **SQL injections** en **Path Traversals** te toets aangesien dit kwesbaar kan wees.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Onthou dat die aksies van 'n Service begin in die metode `onStartCommand`.

'n Service is basies iets wat **data kan ontvang**, dit **verwerk** en 'n antwoord **terugstuur** (of nie). As 'n toepassing dus sekere services exporteer, moet jy die **kode** nagaan om te verstaan wat dit doen en dit **dinamies** toets om vertroulike inligting te onttrek, authorisation bypasses te omseil...

[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Onthou dat die aksies van 'n Broadcast Receiver begin in die metode `onReceive`.

'n Broadcast Receiver sal wag vir 'n tipe boodskap. Afhangend daarvan hoe die receiver die boodskap hanteer, kan dit kwesbaar wees.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Jy kan handmatig na deep links soek met behulp van gereedskap soos MobSF of skripte soos [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Jy kan 'n verklaarde **scheme** oopmaak met **adb** of 'n **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Let wel dat jy die **package name** kan weglaat en die mobiele toestel sal outomaties die app oproep wat daardie skakel behoort oop te maak._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Kode wat uitgevoer word**

Om die **kode wat in die App uitgevoer sal word** te vind, gaan na die activity wat deur die deeplink aangeroep word en soek die funksie **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Sensitiewe inligting**

Elke keer as jy 'n deep link vind, kontroleer dat **dit nie sensitiewe data (soos wagwoorde) via URL-parameters ontvang nie**, want enige ander toepassing kan **die deep link naboots en daardie data steel!**

**Parameters in path**

Jy **moet ook nagaan of enige deep link 'n parameter binne die path** van die URL gebruik, byvoorbeeld: `https://api.example.com/v1/users/{username}`, in daardie geval kan jy 'n path traversal afdwing deur iets soos te benader: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Let daarop as jy die korrekte endpoints in die toepassing vind, mag jy 'n **Open Redirect** veroorsaak (as deel van die path as domeinnaam gebruik word), **account takeover** (as jy gebruikersdetails kan verander sonder 'n CSRF-token en die kwesbare endpoint die korrekte method gebruik) en enige ander vuln. Meer [info about this here](http://dphoeniixx.com/2020/12/13-2/).

'Maar voorbeelde'

'n [Interessante bug bounty-rapport](https://hackerone.com/reports/855618) oor links (_/.well-known/assetlinks.json_).

### Transport Layer Inspection and Verification Failures

- **Sertifikate word nie altyd behoorlik geïnspekteer nie** deur Android-toepassings. Dit is algemeen dat hierdie toepassings waarskuwings ignoreer en self-signed sertifikate aanvaar of, in sekere gevalle, terugval na HTTP-verbindinge.
- **Onderhandelings tydens die SSL/TLS-handshake is soms swak**, en onveilige cipher suites word gebruik. Hierdie kwesbaarheid maak die verbinding vatbaar vir man-in-the-middle (MITM)-aanvalle, waardeur aanvallers die data kan ontsleutel.
- **Leakage of private information** is 'n risiko wanneer toepassings met veilige kanale autentiseer maar dan oor nie-geslote kanale vir ander transaksies kommunikeer. Hierdie benadering beskerm nie sensitiewe data, soos sessie-cookies of gebruikersbesonderhede, teen onderskeping deur kwaadwilliges nie.

#### Certificate Verification

Ons gaan fokus op **certificate verification**. Die integriteit van die bediener se sertifikaat moet geverifieer word om sekuriteit te verbeter. Dit is krities omdat onveilige TLS-konfigurasies en die oordrag van sensitiewe data oor onversleutelde kanale beduidende risiko's kan veroorsaak. Vir gedetailleerde stappe oor hoe om bediener-sertifikate te verifieer en kwesbaarhede aan te spreek, bied [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) omvattende leiding.

#### SSL Pinning

SSL Pinning is 'n sekuriteitsmaatreël waar die toepassing die bediener se sertifikaat verifieer teen 'n bekende kopie wat binne die toepassing gestoor is. Hierdie metode is noodsaaklik om MITM-aanvalle te voorkom. Implementering van SSL Pinning word sterk aanbeveel vir toepassings wat sensitiewe inligting hanteer.

#### Traffic Inspection

Om HTTP-verkeer te ondersoek, is dit nodig om **die proxy-tool se sertifikaat** (bv. Burp) te installeer. Sonder die installasie van hierdie sertifikaat, mag versleutelde verkeer nie deur die proxy sigbaar wees nie. Vir 'n gids oor die installering van 'n eie CA-sertifikaat, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Toepassings wat **API Level 24 and above** teiken, vereis wysigings aan die Network Security Config om die proxy se CA-sertifikaat te aanvaar. Hierdie stap is kritiek vir die inspeksie van versleutelde verkeer. Vir instruksies oor die wysiging van die Network Security Config, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

As **Flutter** gebruik word, moet jy die instruksies op [**this page**](flutter.md) volg. Dit is omdat net om die sertifikaat by die store te voeg nie sal werk nie—Flutter gebruik sy eie lys van geldige CAs.

#### Statiese opsporing van SSL/TLS pinning

Voordat jy runtime-bypasses probeer, kaartjie vinnig waar pinning afgedwing word in die APK. Statiese ontdekking help jou om hooks/patches te beplan en op die regte kodepaaie te fokus.

Tool: SSLPinDetect
- Open-source static-analysis utility wat die APK na Smali dekompileer (via apktool) en soek na gekuurde regex-patrone van SSL/TLS pinning-implementasies.
- Rapporteer die presiese lêerpad, lynnommer en 'n kodefragment vir elke treffert.
- Dek algemene frameworks en custom code paths: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init met custom TrustManagers/KeyManagers, en Network Security Config XML pins.

Install
- Vereistes: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Gebruik
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Voorbeeld patroonreëls (JSON)
Gebruik of brei signatures uit om eienaar-/aangepaste pinning-styles te detecteer. Jy kan jou eie JSON laai en op skaal skandeer.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes and tips
- Vinnige skandering op groot apps deur multi-threading en memory-mapped I/O; vooraf-gekompileerde regex verminder oorhoofse laste en vals positiewe.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Tipiese deteksie-teikens om daarna te triage:
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Declarative pins in res/xml network security config and manifest references
- Gebruik die ooreenstemmende lokasies om Frida hooks, statiese patches, of config-oorsigte te beplan voor dinamiese toetsing.



#### Bypassing SSL Pinning

Wanneer SSL Pinning geïmplementeer is, word dit nodig om dit te omseil om HTTPS-verkeer te inspekteer. Verskeie metodes is beskikbaar vir hierdie doel:

- Outomaties **modify** die **apk** om **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Die grootste voordeel van hierdie opsie is dat jy nie root nodig het om die SSL Pinning te omseil nie, maar jy sal die toepassing moet verwyder en die nuwe een herinstalleer, en dit werk nie altyd nie.
- Jy kan **Frida** (bespreek hieronder) gebruik om hierdie beskerming te omseil. Hier is 'n gids om Burp+Frida+Genymotion te gebruik: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Jy kan ook probeer om **automatically bypass SSL Pinning** using [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Jy kan ook probeer om **automatically bypass SSL Pinning** using **MobSF dynamic analysis** (explained below)
- As jy steeds dink daar is verkeer wat jy nie vang nie, kan jy probeer om die verkeer na burp te stuur met iptables. Lees hierdie blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Looking for Common Web Vulnerabilities

Dit is belangrik om ook binne die toepassing na algemene web-kwesbaarhede te soek. Gedetailleerde inligting oor die identifisering en mitigering van hierdie kwesbaarhede val buite die bestek van hierdie samevatting, maar word elders uitvoerig behandel.

### Frida

[Frida](https://www.frida.re) is 'n dynamic instrumentation toolkit vir developers, reverse-engineers, en security researchers.\
**You can access running application and hook methods on run time to change the behaviour, change values, extract values, run different code...**\
As jy Android-toepassings wil pentest, moet jy weet hoe om Frida te gebruik.

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Some "GUI" for actions with Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- You can find some Awesome Frida scripts here: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Probeer om anti-debugging / anti-frida-meganismes te omseil deur Frida te laai soos aangedui in [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

Kontroleer of die toepassing sensitiewe inligting in die geheue stoor wat dit nie behoort te stoor nie, soos wagwoorde of mnemonics.

Using [**Fridump3**](https://github.com/rootbsd/fridump3) you can dump the memory of the app with:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Dit sal die geheue in die ./dump gids dump, en jy kan daar met iets soos grep soek:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Sensitiewe data in Keystore**

In Android is die Keystore die beste plek om sensitiewe data te stoor, maar met genoeg voorregte is dit steeds **moontlik om daartoe toegang te kry**. Aangesien toepassings geneig is om hier **sensitiewe data in duidelike teks** te stoor, moet pentests dit as root user nagaan, aangesien iemand met fisiese toegang tot die toestel hierdie data kan steel.

Selfs as 'n app data in die Keystore stoor, moet die data versleuteld wees.

Om toegang tot die data binne die Keystore te kry, kan jy hierdie Frida-skrip gebruik: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Deur die volgende Frida-script te gebruik, kan dit moontlik wees om die **bypass fingerprint authentication** wat Android-toepassings mag uitvoer om **sekere sensitiewe gebiede te beskerm:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Agtergrondbeelde**

Wanneer jy 'n toepassing na die agtergrond sit, stoor Android 'n **snapshot van die toepassing** sodat wanneer dit na die voorgrond herstel word dit die beeld laai voordat die app begin, sodat dit lyk asof die app vinniger gelaai is.

As hierdie snapshot egter **gevoelige inligting** bevat, kan iemand met toegang tot die snapshot daardie inligting **steel** (let wel: jy benodig root-toegang om dit te bereik).

Die snapshots word gewoonlik gestoor by: **`/data/system_ce/0/snapshots`**

Android bied 'n manier om die **opname van skermkiekies te voorkom deur die FLAG_SECURE** layout-parameter te stel. Deur hierdie vlag te gebruik, word die vensterinhoud as veilig behandel, wat verhoed dat dit in skermkiekies verskyn of op nie-veilige skerms besigtig kan word.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Hierdie hulpmiddel kan jou help om verskillende gereedskap tydens die dinamiese analise te bestuur: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Ontwikkelaars skep dikwels proxy-komponente soos activities, services en broadcast receivers wat hierdie Intents hanteer en aan metodes soos `startActivity(...)` of `sendBroadcast(...)` deurgee, wat riskant kan wees.

Die gevaar lê daarin om aanvallers toe te laat om nie-geëxporteerde app-komponente te aktiveer of sensitiewe content providers te bereik deur hierdie Intents verkeerd te rig. ’n Opvallende voorbeeld is die `WebView` komponent wat URLs na `Intent`-objekte omskakel via `Intent.parseUri(...)` en dit dan uitvoer, wat moontlik tot malicious Intent injections kan lei.

### Essensiële punte

- **Intent Injection** is soortgelyk aan die web se Open Redirect-kwessie.
- Eksploite behels die deurgee van `Intent`-objekte as extras, wat omgerig kan word om onveilige bedrywighede uit te voer.
- Dit kan nie-geëxporteerde komponente en content providers aan aanvallers blootstel.
- `WebView` se omskakeling van URL's na `Intent` kan onbedoelde aksies vergemaklik.

### Android Client Side Injections en ander

Jy ken waarskynlik hierdie soort kwesbaarhede van die Web. Jy moet besonder versigtig wees met hierdie kwesbaarhede in 'n Android-toepassing:

- **SQL Injection:** Wanneer jy met dinamiese navrae of Content-Providers werk, maak seker jy gebruik geparametriseerde navrae.
- **JavaScript Injection (XSS):** Kontroleer dat JavaScript- en plugin-ondersteuning vir enige WebViews gedeaktiveer is (per verstek gedeaktiveer). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews moet toegang tot die lêerstelsel gedeaktiveer hê (per verstek geaktiveer) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: In verskeie gevalle, wanneer die Android-toepassing die sessie beëindig, word die cookie nie herroep nie of dit kan selfs na skyf geskryf word
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Outomatiese analise

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Statiese analise**

![](<../../images/image (866).png>)

**Kwetsbaarheidsassessering van die toepassing** deur 'n netjiese web-gebaseerde frontend. Jy kan ook dinamiese analise uitvoer (maar jy moet die omgewing voorberei).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Let daarop dat MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Ook, as jy 'n **ZIP**-lêer skep met die bronkode van 'n **Android** of 'n **IOS** app (gaan na die root folder van die toepassing, kies alles en skep 'n ZIPfile), sal dit dit ook kan ontleed.

MobSF laat jou ook toe om **diff/Compare** analises te doen en om **VirusTotal** te integreer (jy sal jou API-sleutel in _MobSF/settings.py_ moet instel en dit aktiveer: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). Jy kan ook `VT_UPLOAD` op `False` stel, dan sal die **hash** in plaas van die lêer **opgelaai** word.

### Bygestaande dinamiese ontleding met MobSF

MobSF kan ook baie nuttig wees vir dinamiese ontleding op **Android**, maar in daardie geval moet jy MobSF en **genymotion** op jou host installeer (’n VM of Docker gaan nie werk nie). _Nota: Jy moet eers 'n VM in genymotion start en dan MobSF._\
Die **MobSF dynamic analyser** kan:

- **Dump application data** (URLs, logs, klembord, skermkiekies deur jou geneem, skermkiekies gemaak deur "**Exported Activity Tester**", e-posse, SQLite databases, XML-lêers, en ander geskepte lêers). Dit gebeur alles outomaties behalwe vir die skermkiekies — jy moet druk wanneer jy 'n skermkiekie wil hê of jy moet op "**Exported Activity Tester**" druk om skermkiekies van al die geëksporteerde aktiwiteite te verkry.
- Vang **HTTPS-traffic**
- Gebruik **Frida** om **runtime** **information** te bekom

Vanaf Android weergawes > 5 sal dit **automatically start Frida** en globale **proxy**-instellings stel om verkeer te **capture**. Dit sal slegs verkeer van die getoetste toepassing vasvang.

**Frida**

Standaard sal dit ook sommige Frida-skripte gebruik om **bypass SSL pinning**, **root detection** en **debugger detection** te omseil en om interessante APIs te monitor.\
MobSF kan ook **invoke exported activities**, skermkiekies daarvan gryp en dit vir die verslag **save**.

Om die dinamiese toetsing te begin druk die groen knoppie: "**Start Instrumentation**". Druk die "**Frida Live Logs**" om die logs wat deur die Frida-skripte gegenereer is te sien en "**Live API Monitor**" om alle oproepe na hooked methods, die deurgegewe argumente en teruggegewe waardes te sien (dit sal verskyn nadat jy "Start Instrumentation" gedruk het).\
MobSF laat jou ook toe om jou eie **Frida scripts** te laai (om die resultate van jou Frida scripts na MobSF te stuur gebruik die funksie `send()`). Dit het ook **several pre-written scripts** wat jy kan laai (jy kan meer byvoeg in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), kies hulle net, druk "**Load**" en druk "**Start Instrumentation**" (jy sal die logs van daardie skripte binne "**Frida Live Logs**" kan sien).

![](<../../images/image (419).png>)

Daarbenewens het jy 'n paar bykomende Frida-funksionaliteite:

- **Enumerate Loaded Classes**: Dit sal al die gelaaide klasse uitdruk
- **Capture Strings**: Dit sal al die vasgevangde strings uitdruk terwyl jy die toepassing gebruik (baie lawaaierig)
- **Capture String Comparisons**: Kan baie nuttig wees. Dit sal die twee strings wat vergelyk word wys en of die resultaat True of False was.
- **Enumerate Class Methods**: Sit die klassenaam in (bv. "java.io.File") en dit sal al die metodes van die klas uitdruk.
- **Search Class Pattern**: Soek klasse volgens patroon
- **Trace Class Methods**: Trace 'n hele klas (sien insette en uitsette van alle metodes van die klas). Onthou dat standaard MobSF verskeie interessante Android API-metodes trace.

Sodra jy die bykomende module gekies het wat jy wil gebruik, moet jy op "**Start Intrumentation**" druk en jy sal al die uitsette in "**Frida Live Logs**" sien.

**Shell**

MobSF gee jou ook 'n shell met sommige **adb** commands, **MobSF commands**, en algemene **shell** **commands** onderaan die dinamiese analise-bladsy. 'n Paar interessante opdragte:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP gereedskap**

Wanneer HTTP-verkeer vasgelê word, kan jy ’n lelike uitsig van die vasgelêde verkeer sien op die "**HTTP(S) Traffic**" knoppie onder of ’n netter uitsig in die "**Start HTTPTools**" groen knoppie. Vanaf die tweede opsie kan jy die **vasgelêde versoeke** stuur na **proxies** soos Burp of Owasp ZAP.\
Om dit te doen, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> press "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Sodra jy die dinamiese analise met MobSF voltooi het, kan jy op "**Start Web API Fuzzer**" druk om **fuzz http requests** en na kwesbaarhede te soek.

> [!TIP]
> Na ’n dinamiese analise met MobSF kan die proxy-instellings verkeerd gekonfigureer wees en jy sal dit nie vanaf die GUI kan regmaak nie. Jy kan die proxy-instellings regmaak deur:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

You can get the tool from [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Hierdie tool sal sommige **Hooks** gebruik om jou te laat weet **wat in die toepassing gebeur** terwyl jy ’n **dynamiese analise** uitvoer.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Dit is ’n **uitstekende tool om statiese analise met ’n GUI uit te voer**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

This tool is designed to look for several **security related Android application vulnerabilities**, either in **source code** or **packaged APKs**. The tool is also **capable of creating a "Proof-of-Concept" deployable APK** and **ADB commands**, to exploit some of the found vulnerabilities (Exposed activities, intents, tapjacking...). As with Drozer, there is no need to root the test device.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Wys alle ekstraheerde lêers vir maklike verwysing
- Decompileer APK-lêers outomaties na Java- en Smali-formaat
- Ontleed AndroidManifest.xml vir algemene kwesbaarhede en gedrag
- Statiese bronkode-analise vir algemene kwesbaarhede en gedrag
- Toestelinligting
- en meer
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER is 'n opdragreëltoepassing wat in Windows, MacOS X en Linux gebruik kan word en _.apk_ lêers ontleed om na kwesbaarhede te soek. Dit doen dit deur APKs uit te pak en 'n reeks reëls toe te pas om daardie kwesbaarhede te ontdek.

Alle reëls is sentraal in 'n `rules.json` lêer, en elke maatskappy of toetser kan hul eie reëls skep om te analiseer wat hulle benodig.

Laai die nuutste binaries af vanaf die [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn is 'n **crossplatform** hulpmiddel wat ontwikkelaars, bugbounty hunters en ethical hackers help om [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) op mobiele toepassings uit te voer.

Die konsep is dat jy jou mobiele toepassingslêer (an .apk or .ipa file) op die StaCoAn-toepassing sleep en los, en dit sal 'n visuele en draagbare verslag vir jou genereer. Jy kan die instellings en wordlists aanpas om 'n aangepaste ervaring te kry.

Laai af[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework is 'n stelsel vir Android-kwesbaarheidsanalise wat ontwikkelaars of hackers help om potensiële sekuriteitskwesbaarhede in Android-toepassings te vind.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** is 'n hulpmiddel waarvan die hoofdoel is om die gebruiker te identifiseer en te waarsku oor potensieel kwaadwillige gedrag wat deur 'n Android-toepassing ontwikkel is.

Die opsporing word uitgevoer deur middel van die **static analysis** van die toepassing se Dalvik bytecode, voorgestel as **Smali**, met die [`androguard`](https://github.com/androguard/androguard) biblioteek.

Hierdie hulpmiddel soek na **common behavior of "bad" applications** soos: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. Dit is 'n hulpmiddel wat algemeen gebruikte mobile application reverse engineering- en analysis-instrumente saamvoeg om te help met die toetsing van mobiele toepassings teen OWASP se mobiele sekuriteitsbedreigings. Die doel is om hierdie taak vir mobiele toepassingsontwikkelaars en sekuriteitsprofessionals makliker en gebruikersvriendeliker te maak.

Dit kan:

- Onttrek Java- en Smali-kode met verskeie gereedskap
- Ontleed APK's met: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Onttrek private inligting uit die APK met regexps.
- Ontleed die Manifest.
- Ontleed gevonde domeine met: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) en [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Nuttig om malware op te spoor: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Let daarop dat, afhangend van die diens en konfigurasie wat jy gebruik om die kode te obfuskeer, kan geheime wel of nie geobfuskeer wees nie.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

Van [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is 'n open source command-line hulpmiddel wat Java-kode verklein, optimaliseer en obfuskeer. Dit kan bytecode optimaliseer en ook ongebruikte instruksies opspoor en verwyder. ProGuard is vrye sagteware en word versprei onder die GNU General Public License, weergawe 2.

ProGuard word as deel van die Android SDK versprei en loop wanneer die toepassing in release-modus gebou word.

### [DexGuard](https://www.guardsquare.com/dexguard)

Vind 'n stap-vir-stap gids om die APK te deobfuskeer by [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(Uit daardie gids) Laas toe ons gekyk het, was die Dexguard-bedryfswyse:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard keer die proses van obfuskering wat deur Android obfuskering-instrumente uitgevoer word om. Dit maak talle sekuriteitsanalises moontlik, insluitend kode-inspeksie en die voorspelling van biblioteke.**

Jy kan 'n geobfuskede APK na hul platform oplaai.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

Dit is 'n generiese android deobfuscator. Simplify voer 'n app virtueel uit om die gedrag te verstaan en probeer dan die kode optimaliseer sodat dit identies optree maar makliker vir 'n mens is om te verstaan. Elke tipe optimalisering is eenvoudig en generies, so dit maak nie saak watter spesifieke tipe obfuscation gebruik is nie.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD gee jou inligting oor hoe 'n APK gemaak is. Dit identifiseer baie compilers, packers, obfuscators, en ander snaakse dinge. Dit is die [_PEiD_](https://www.aldeid.com/wiki/PEiD) vir Android.

### Manual

[Lees hierdie handleiding om 'n paar truuks te leer oor **hoe om aangepaste obfuskering om te keer**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b is 'n Android-sekuriteits-virtuale masjien gebaseer op ubuntu-mate wat 'n versameling van die nuutste framework, tutorials en labs van verskillende sekuriteitsentoesiaste en navorsers vir reverse engineering en malware analysis insluit.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Dit is 'n wonderlike lys hulpbronne
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android vinnige kursus
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
