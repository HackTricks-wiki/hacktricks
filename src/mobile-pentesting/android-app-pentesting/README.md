# Pentesting aplikacji Android

{{#include ../../banners/hacktricks-training.md}}

## Podstawy aplikacji Android

Gorąco zaleca się rozpocząć od przeczytania tej strony, aby poznać **najważniejsze elementy związane z bezpieczeństwem Androida oraz najbardziej niebezpieczne komponenty w aplikacji na Androida**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

To główne narzędzie potrzebne do połączenia z urządzeniem z Androidem (emulowanym lub fizycznym).\
**ADB** pozwala kontrolować urządzenia zarówno przez **USB**, jak i **sieć** z komputera. To narzędzie umożliwia **kopiowanie** plików w obu kierunkach, **instalację** i **odinstalowanie** aplikacji, **wykonywanie** poleceń shell, **tworzenie kopii zapasowych** danych, **odczytywanie** logów i inne funkcje.

Zapoznaj się z następującą listą [**Polecenia ADB**](adb-commands.md), aby nauczyć się używać adb.

## Smali

Czasami warto **zmodyfikować kod aplikacji**, aby uzyskać dostęp do **ukrytych informacji** (np. dobrze obfuskowanych haseł lub flag). W takim przypadku warto zdekompilować APK, zmodyfikować kod i ponownie skompilować aplikację.\
[**W tym tutorialu** możesz **nauczyć się dekompilować APK, modyfikować kod Smali i rekompilować APK** z nową funkcjonalnością](smali-changes.md). Może to być bardzo przydatne jako **alternatywa dla kilku testów podczas analizy dynamicznej**, które zostaną przedstawione. Dlatego **zawsze miej tę możliwość na uwadze**.

## Inne ciekawe triki

- [Spoofing lokalizacji w Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (uprzywilejowany dostęp bez root oparty na ADB)](shizuku-privileged-api.md)
- [Wykorzystywanie niebezpiecznych mechanizmów aktualizacji In-App](insecure-in-app-update-rce.md)
- [Nadużywanie Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [NFC/EMV Relay via HCE (nadużycie Android Tap-to-Pay)](android-hce-nfc-emv-relay-attacks.md)
- **Pobieranie APK**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Wyodrębnij APK z urządzenia:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Połącz wszystkie splits i base apks przy użyciu [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Case Studies & Vulnerabilities


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Analiza statyczna

Przede wszystkim, analizując APK powinieneś **przejrzeć kod Java** przy użyciu dekompilera.\
Proszę, [**przeczytaj tutaj, aby znaleźć informacje o różnych dostępnych dekompilatorach**](apk-decompilers.md).

### Szukanie interesujących informacji

Spoglądając tylko na **strings** w APK możesz wyszukać **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** i wszystko, co interesujące... sprawdź nawet pod kątem code execution **backdoors** lub authentication backdoors (hardcoded admin credentials do aplikacji).

**Firebase**

Zwróć szczególną uwagę na **firebase URLs** i sprawdź, czy nie są źle skonfigurowane. [Więcej informacji o tym, czym jest Firebase i jak to wykorzystać tutaj.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Podstawowe zrozumienie aplikacji - Manifest.xml, strings.xml

To **badanie plików aplikacji _Manifest.xml_ i **_strings.xml_** może ujawnić potencjalne luki w zabezpieczeniach**. Te pliki można uzyskać za pomocą dekompilatorów lub poprzez zmianę rozszerzenia pliku APK na .zip i rozpakowanie go.

**Vulnerabilities** identified from the **Manifest.xml** include:

- **Debuggable Applications**: Aplikacje ustawione jako debuggable (`debuggable="true"`) w pliku _Manifest.xml_ stanowią ryzyko, ponieważ umożliwiają połączenia, które mogą prowadzić do exploitacji. Aby lepiej zrozumieć, jak wykorzystywać aplikacje z włączonym debugowaniem, odnieś się do tutorialu dotyczącego znajdowania i eksploatacji debuggable applications na urządzeniu.
- **Backup Settings**: Atrybut `android:allowBackup="false"` powinien być jawnie ustawiony dla aplikacji przetwarzających wrażliwe informacje, aby zapobiec nieautoryzowanym backupom danych przez adb, szczególnie gdy usb debugging jest włączone.
- **Network Security**: Niestandardowe konfiguracje bezpieczeństwa sieci (`android:networkSecurityConfig="@xml/network_security_config"`) w _res/xml/_ mogą określać szczegóły bezpieczeństwa, takie jak pinowanie certyfikatów i ustawienia ruchu HTTP. Przykładem jest zezwolenie na ruch HTTP dla określonych domen.
- **Exported Activities and Services**: Identyfikacja eksportowanych aktywności i serwisów w manifeście może ujawnić komponenty, które mogą być niewłaściwie użyte. Dalsza analiza podczas testów dynamicznych może wykazać sposoby ich eksploatacji.
- **Content Providers and FileProviders**: Udostępnione content providers mogą umożliwić nieautoryzowany dostęp lub modyfikację danych. Konfiguracja FileProviders również powinna być dokładnie sprawdzona.
- **Broadcast Receivers and URL Schemes**: Te komponenty mogą zostać wykorzystane do ataku, ze szczególnym uwzględnieniem sposobu obsługi schematów URL pod kątem podatności na wstrzyknięcie wejścia.
- **SDK Versions**: Atrybuty `minSdkVersion`, `targetSDKVersion` i `maxSdkVersion` wskazują obsługiwane wersje Androida, co podkreśla znaczenie nieobsługiwania przestarzałych, podatnych wersji Androida ze względów bezpieczeństwa.

Z pliku **strings.xml** można odkryć wrażliwe informacje, takie jak API keys, custom schemas i inne notatki deweloperskie, co podkreśla konieczność dokładnego przeglądu tych zasobów.

### Tapjacking

**Tapjacking** to atak, w którym **złośliwa** **aplikacja** jest uruchamiana i **pozycjonuje się nad aplikacją ofiary**. Gdy widocznie przesłoni aplikację ofiary, jej interfejs użytkownika jest zaprojektowany w taki sposób, aby nakłonić użytkownika do interakcji, podczas gdy sama przekazuje tę interakcję dalej do aplikacji ofiary.\
W efekcie **oślepia użytkownika, przez co nie wie, że faktycznie wykonuje akcje w aplikacji ofiary**.

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Aktywność z ustawionym **`launchMode`** na **`singleTask` bez zdefiniowanego `taskAffinity`** jest podatna na task Hijacking. Oznacza to, że aplikacja może zostać zainstalowana i jeśli zostanie uruchomiona przed prawdziwą aplikacją, może **przechwycić task prawdziwej aplikacji** (tak, że użytkownik będzie wchodził w interakcję z **złośliwą aplikacją myśląc, że używa prawdziwej**).

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Niezabezpieczone przechowywanie danych

**Pamięć wewnętrzna**

W Androidzie pliki **przechowywane** w **internal** storage są **zaprojektowane** tak, aby były **dostępne** wyłącznie dla **aplikacji**, która je **utworzyła**. Ten mechanizm bezpieczeństwa jest **wymuszany** przez system Android i zazwyczaj wystarcza dla potrzeb bezpieczeństwa większości aplikacji. Jednak deweloperzy czasami korzystają z trybów takich jak `MODE_WORLD_READABLE` i `MODE_WORLD_WRITABLE`, aby **pozwolić** na **udostępnianie** plików między różnymi aplikacjami. Te tryby **nie ograniczają dostępu** do tych plików przez inne aplikacje, w tym potencjalnie złośliwe.

1. **Static Analysis:**
- **Upewnij się**, że użycie `MODE_WORLD_READABLE` i `MODE_WORLD_WRITABLE` jest **dokładnie sprawdzone**. Te tryby **mogą potencjalnie ujawniać** pliki dla **niezamierzonego lub nieautoryzowanego dostępu**.
2. **Dynamic Analysis:**
- **Zweryfikuj** uprawnienia ustawione na plikach tworzonych przez aplikację. W szczególności **sprawdź**, czy jakiekolwiek pliki nie są **ustawione jako czytelne lub zapisywalne globalnie**. To może stanowić istotne ryzyko bezpieczeństwa, ponieważ pozwoli **dowolnej aplikacji** zainstalowanej na urządzeniu, niezależnie od jej pochodzenia czy zamiaru, **odczytać lub zmodyfikować** te pliki.

**Pamięć zewnętrzna**

W przypadku pracy z plikami na **external storage**, takich jak SD Cards, należy zachować pewne środki ostrożności:

1. **Dostępność**:
- Pliki na external storage są **globalnie czytelne i zapisywalne**. Oznacza to, że dowolna aplikacja lub użytkownik może mieć do nich dostęp.
2. **Obawy bezpieczeństwa**:
- Ze względu na łatwość dostępu, zaleca się **nie przechowywać wrażliwych informacji** na external storage.
- External storage może zostać usunięty lub uzyskany przez dowolną aplikację, co czyni go mniej bezpiecznym.
3. **Obsługa danych z external storage**:
- Zawsze **waliduj wejście** na podstawie danych pobieranych z external storage. Jest to kluczowe, ponieważ dane pochodzą ze źródła nieufnego.
- Przechowywanie plików wykonywalnych lub plików klas na external storage w celu dynamicznego ładowania jest zdecydowanie odradzane.
- Jeśli aplikacja musi pobierać pliki wykonywalne z external storage, upewnij się, że pliki te są **podpisane i kryptograficznie zweryfikowane** zanim zostaną dynamicznie załadowane. Ten krok jest kluczowy dla zachowania integralności bezpieczeństwa aplikacji.

External storage można **uzyskać** w `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> Począwszy od Android 4.4 (**API 17**), SD card ma strukturę katalogów, która **ogranicza dostęp aplikacji do katalogu przeznaczonego specjalnie dla tej aplikacji**. Zapobiega to temu, by złośliwa aplikacja uzyskała dostęp do odczytu lub zapisu plików innej aplikacji.

Wrażliwe dane przechowywane w jawnej postaci

- **Shared preferences**: Android pozwala każdej aplikacji na łatwe zapisywanie plików xml w ścieżce `/data/data/<packagename>/shared_prefs/` i czasami można znaleźć w tym folderze wrażliwe informacje w postaci jawnej.
- **Databases**: Android pozwala każdej aplikacji na łatwe zapisywanie baz sqlite w ścieżce `/data/data/<packagename>/databases/` i czasami można znaleźć w tym folderze wrażliwe informacje w postaci jawnej.

### Broken TLS

#### Akceptowanie wszystkich certyfikatów

Z jakiegoś powodu czasami deweloperzy akceptują wszystkie certyfikaty, nawet jeśli na przykład hostname nie zgadza się, z użyciem fragmentów kodu takich jak poniższy:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Słaba kryptografia

**Słabe procesy zarządzania kluczami**

Niektórzy deweloperzy zapisują dane wrażliwe w local storage i szyfrują je kluczem zakodowanym na stałe/przewidywalnym w kodzie. Nie powinno się tego robić, ponieważ pewne techniki reversingowe mogą pozwolić atakującym na wyodrębnienie poufnych informacji.

**Używanie niebezpiecznych i/lub przestarzałych algorytmów**

Deweloperzy nie powinni używać **deprecated algorithms** do przeprowadzania authorisation **checks**, **store** lub **send** danych. Niektóre z tych algorytmów to: RC4, MD4, MD5, SHA1... Jeśli **hashes** są używane do przechowywania haseł na przykład, powinny być stosowane hashe odporne na brute-force wraz z salt.

### Inne sprawdzenia

- Zaleca się **obfuskować APK**, aby utrudnić pracę reverse engineerom i potencjalnym atakującym.
- Jeśli aplikacja jest wrażliwa (np. aplikacje bankowe), powinna wykonywać własne **sprawdzenia, czy mobile jest rooted** i działać odpowiednio.
- Jeśli aplikacja jest wrażliwa (np. aplikacje bankowe), powinna sprawdzać, czy używany jest **emulator**.
- Jeśli aplikacja jest wrażliwa (np. aplikacje bankowe), powinna **sprawdzić swoją integralność przed uruchomieniem**, aby zweryfikować, czy została zmodyfikowana.
- Użyj [**APKiD**](https://github.com/rednaga/APKiD) aby sprawdzić, który compiler/packer/obfuscator został użyty do zbudowania APK

### Aplikacja React Native

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Aplikacje Xamarin

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Aplikacje Superpacked

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Zautomatyzowana statyczna analiza kodu

Narzędzie [**mariana-trench**](https://github.com/facebook/mariana-trench) potrafi znajdować **vulnerabilities** przez **scanning** **code** aplikacji. To narzędzie zawiera serię **known sources** (które wskazują narzędziu **miejsca**, gdzie **input** jest **controlled by the user**), **sinks** (które wskazują narzędziu **dangerous** **places**, gdzie złośliwy input użytkownika mógłby wyrządzić szkody) oraz **rules**. Te rules wskazują **kombinacje** **sources-sinks**, które sygnalizują podatność.

Mając tę wiedzę, **mariana-trench przeanalizuje kod i znajdzie możliwe vulnerabilities w nim**.

### Secrets leaked

An application may contain secrets (API keys, passwords, hidden urls, subdomains...) inside of it that you might be able to discover. You could us a tool such as [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Obejście uwierzytelniania biometrycznego


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Inne ciekawe funkcje

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)
- In-memory native code execution via JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> First of all, you need an environment where you can install the application and all the environment (Burp CA cert, Drozer and Frida mainly). Therefore, a rooted device (emulated or not) is extremely recommended.

### Online Dynamic analysis

Możesz założyć **bezpłatne konto** na: [https://appetize.io/](https://appetize.io). Ta platforma pozwala **upload** i **execute** APKs, więc jest przydatna, aby zobaczyć jak apk się zachowuje.

Możesz nawet **zobaczyć logi swojej aplikacji** w sieci i połączyć się przez **adb**.

![](<../../images/image (831).png>)

Dzięki połączeniu ADB możesz używać **Drozer** i **Frida** wewnątrz emulatorów.

### Lokalna analiza dynamiczna

#### Używanie emulatora

- [**Android Studio**](https://developer.android.com/studio) (Możesz tworzyć urządzenia **x86** i **arm**, a zgodnie z [**tym** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**najnowsze wersje x86** wspierają **biblioteki ARM** bez potrzeby używania wolnego emulatora arm).
- Naucz się jak to skonfigurować na tej stronie:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(wersja darmowa:** Personal Edition, trzeba założyć konto. _Zaleca się **pobrać** wersję **Z**_ _**VirtualBox** aby uniknąć potencjalnych błędów._)
- [**Nox**](https://es.bignox.com) (Darmowy, ale nie wspiera Frida ani Drozer).

> [!TIP]
> Przy tworzeniu nowego emulatora na dowolnej platformie pamiętaj, że im większy ekran, tym wolniej będzie działać emulator. Dlatego wybieraj małe ekrany, jeśli to możliwe.

Aby **zainstalować google services** (jak AppStore) w Genymotion trzeba kliknąć przycisk oznaczony na czerwono na poniższym obrazku:

![](<../../images/image (277).png>)

Zauważ także, że w **konfiguracji VM Android w Genymotion** możesz wybrać **Bridge Network mode** (to będzie przydatne jeśli będziesz łączyć się z Android VM z innej VM z narzędziami).

#### Użycie urządzenia fizycznego

Musisz aktywować **debugging** opcje i warto jeśli możesz je **zrootować**:

1. **Settings**.
2. (FromAndroid 8.0) Wybierz **System**.
3. Wybierz **About phone**.
4. Naciśnij **Build number** 7 razy.
5. Wróć i znajdziesz **Developer options**.

> Po zainstalowaniu aplikacji, pierwszą rzeczą którą powinieneś zrobić jest spróbować jej użyć, zbadać co robi, jak działa i oswoić się z nią.\
> Sugeruję wykonanie tej początkowej analizy dynamicznej używając MobSF dynamic analysis + pidcat, dzięki czemu będziemy mogli **nauczyć się jak aplikacja działa**, podczas gdy MobSF **przechwyci** dużo **interesujących** **danych**, które możesz później przeglądać.

Magisk/Zygisk krótkie notatki (zalecane na urządzeniach Pixel)
- Zepatchuj boot.img przy użyciu aplikacji Magisk i flashuj przez fastboot, aby uzyskać systemless root
- Włącz Zygisk + DenyList dla ukrywania roota; rozważ LSPosed/Shamiko gdy wymagane jest silniejsze ukrywanie
- Zachowaj oryginalny boot.img, aby odzyskać się po OTA; zepatchuj ponownie po każdym OTA
- Do mirrorowania ekranu użyj scrcpy na hoście

### Unintended Data Leakage

**Logging**

Deweloperzy powinni uważać, aby nie ujawniać **informacji debugowych** publicznie, ponieważ może to prowadzić do wycieków danych wrażliwych. Narzędzia [**pidcat**](https://github.com/JakeWharton/pidcat) oraz `adb logcat` są rekomendowane do monitorowania logów aplikacji w celu identyfikacji i ochrony danych wrażliwych. **Pidcat** jest preferowany ze względu na łatwość użycia i czytelność.

> [!WARNING]
> Zauważ, że od **wersji nowszych niż Android 4.0**, **aplikacje mogą uzyskiwać dostęp tylko do swoich własnych logów**. Więc aplikacje nie mogą uzyskać dostępu do logów innych aplikacji.\
> Mimo to, nadal zaleca się **nie logować informacji wrażliwych**.

**Copy/Paste Buffer Caching**

Androidowy framework **oparty na schowku** umożliwia funkcjonalność kopiuj-wklej w aplikacjach, ale stanowi ryzyko, ponieważ **inne aplikacje** mogą **dostępować do schowka**, potencjalnie ujawniając dane wrażliwe. Ważne jest, aby **wyłączyć funkcje kopiuj/wklej** dla wrażliwych sekcji aplikacji, takich jak dane karty kredytowej, aby zapobiec wyciekom.

**Crash Logs**

Jeśli aplikacja **crashuje** i **zapisuje logi**, te logi mogą pomóc atakującym, szczególnie gdy aplikacja nie może być zreverse'owana. Aby zminimalizować to ryzyko, unikaj logowania przy awariach, a jeśli logi muszą być przesyłane przez sieć, upewnij się, że są wysyłane przez kanał SSL.

As pentester, **spróbuj rzucić okiem na te logi**.

**Analytics Data Sent To 3rd Parties**

Aplikacje często integrują usługi takie jak Google Adsense, które mogą niezamierzenie **leakować sensitive data** z powodu nieprawidłowej implementacji przez deweloperów. Aby zidentyfikować potencjalne wycieki, warto **przechwycić ruch aplikacji** i sprawdzić, czy jakiekolwiek wrażliwe informacje są wysyłane do usług zewnętrznych.

### SQLite DBs

Większość aplikacji będzie używać **wewnętrznych baz SQLite** do zapisywania informacji. Podczas pentestu przejrzyj **bazy danych**, nazwy **tabel** i **kolumn** oraz wszystkie zapisywane **dane**, ponieważ możesz znaleźć **wrażliwe informacje** (co stanowiłoby podatność).\
Bazy danych powinny znajdować się w `/data/data/the.package.name/databases` jak `/data/data/com.mwr.example.sieve/databases`

Jeśli baza danych zapisuje poufne informacje i jest **zaszyfrowana**, ale możesz **znaleźć** **hasło** wewnątrz aplikacji, to nadal jest to **podatność**.

Wypisz tabele używając `.tables` i wypisz schemat tabel używając `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** pozwala **przyjąć rolę aplikacji Android** i wchodzić w interakcje z innymi aplikacjami. Może robić **wszystko to, co zainstalowana aplikacja może zrobić**, takie jak korzystanie z mechanizmu Inter-Process Communication (IPC) Androida i interakcję z systemem operacyjnym. .\
Drozer jest użytecznym narzędziem do **eksploatacji exported activities, exported services i Content Providers**, jak dowiesz się w kolejnych sekcjach.

### Wykorzystywanie eksportowanych Activity

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Pamiętaj też, że kod aktywności zaczyna się w metodzie **`onCreate`**.

**Authorisation bypass**

Gdy Activity jest exported, możesz wywołać jej ekran z zewnętrznej aplikacji. W związku z tym, jeśli aktywność zawierająca **informacje wrażliwe** jest **exported**, możesz **bypass** mechanizmy **autoryzacji**, aby uzyskać do niej dostęp.

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

Możesz też uruchomić exported activity z adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> Należy pamiętać, że obejście autoryzacji nie zawsze jest podatnością — zależy to od tego, jak działa obejście i jakie informacje są ujawniane.

**Sensitive information leakage**

**Activities can also return results**. Jeśli uda Ci się znaleźć eksportowaną i niechronioną activity wywołującą metodę **`setResult`** i **zwracającą informacje wrażliwe**, dochodzi do ujawnienia informacji wrażliwych.

#### Tapjacking

Jeśli tapjacking nie jest zapobiegany, możesz nadużyć eksportowanej activity, aby zmusić **użytkownika do wykonania nieoczekiwanych akcji**. For more info about [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers are basically used to **share data**. Jeśli aplikacja ma dostępne content providers możesz być w stanie **wyodrębnić wrażliwe** dane z nich. Warto także przetestować możliwe **SQL injections** i **Path Traversals**, ponieważ mogą być podatne.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Pamiętaj, że działania Service zaczynają się w metodzie `onStartCommand`.

Service to w zasadzie coś, co **może otrzymywać dane**, **przetwarzać** je i **zwracać** (lub nie) odpowiedź. Jeśli aplikacja eksportuje jakieś services, powinieneś **sprawdzić** **kod**, aby zrozumieć, co on robi oraz **przetestować** go **dynamicznie**, aby wyodrębnić poufne informacje, obejść mechanizmy uwierzytelniania...\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Pamiętaj, że działania Broadcast Receiver zaczynają się w metodzie `onReceive`.

Broadcast receiver będzie oczekiwać na określony typ wiadomości. W zależności od tego, jak receiver obsługuje wiadomość, może być podatny.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

You can look for deep links manually, using tools like MobSF or scripts like [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Możesz **otworzyć** zadeklarowany **scheme** używając **adb** lub **przeglądarki**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Zauważ, że możesz **pominąć nazwę pakietu** i urządzenie mobilne automatycznie uruchomi aplikację, która powinna otworzyć ten link._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Wykonywany kod**

Aby znaleźć **kod, który zostanie wykonany w aplikacji**, przejdź do activity wywoływanej przez deeplink i wyszukaj funkcję **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Poufne informacje**

Za każdym razem, gdy znajdziesz deep link, sprawdź, czy **nie otrzymuje on wrażliwych danych (np. haseł) przez parametry URL**, ponieważ każda inna aplikacja mogłaby **podszyć się pod ten deep link i ukraść te dane!**

**Parametry w ścieżce**

Musisz również sprawdzić, czy którykolwiek deep link **używa parametru wewnątrz ścieżki** URL, np.: `https://api.example.com/v1/users/{username}` — w takim przypadku możesz wymusić path traversal, uzyskując dostęp do czegoś w stylu: `example://app/users?username=../../unwanted-endpoint%3fparam=value`.\
Zwróć uwagę, że jeśli znajdziesz poprawne endpointy w aplikacji, możesz spowodować **Open Redirect** (jeśli część ścieżki jest używana jako nazwa domeny), **account takeover** (jeśli możesz zmodyfikować dane użytkowników bez tokena CSRF i podatny endpoint używał odpowiedniej metody) oraz inne luki. More [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**Więcej przykładów**

Przykład: [interesting bug bounty report](https://hackerone.com/reports/855618) o linkach (_/.well-known/assetlinks.json_).

### Inspekcja warstwy transportowej i błędy weryfikacji

- **Certyfikaty nie zawsze są prawidłowo weryfikowane** przez aplikacje Android. Często aplikacje ignorują ostrzeżenia i akceptują certyfikaty samopodpisane lub, w niektórych przypadkach, przełączają się na połączenia HTTP.
- **Negocjacje podczas handshake SSL/TLS bywają czasami słabe**, używając niebezpiecznych zestawów szyfrów. Ta luka sprawia, że połączenie jest podatne na ataki man-in-the-middle (MITM), umożliwiając atakującym odszyfrowanie danych.
- **Leakage of private information** stanowi ryzyko, gdy aplikacje uwierzytelniają się przy użyciu bezpiecznych kanałów, ale potem komunikują się przez kanały niezabezpieczone dla innych transakcji. Takie podejście nie chroni wrażliwych danych, takich jak session cookies czy dane użytkownika, przed przechwyceniem przez podmioty złośliwe.

#### Weryfikacja certyfikatu

Skoncentrujemy się na **certificate verification**. Należy weryfikować integralność certyfikatu serwera, aby zwiększyć bezpieczeństwo. Jest to kluczowe, ponieważ niebezpieczne konfiguracje TLS oraz przesyłanie wrażliwych danych przez niezaszyfrowane kanały mogą stwarzać poważne ryzyka. Dla szczegółowych kroków dotyczących weryfikacji certyfikatów serwera i naprawy luk, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) zapewnia wyczerpujące wskazówki.

#### SSL Pinning

SSL Pinning to środek bezpieczeństwa, w którym aplikacja weryfikuje certyfikat serwera względem znanej kopii przechowywanej wewnątrz aplikacji. Ta metoda jest niezbędna do zapobiegania atakom MITM. Zdecydowanie zaleca się implementację SSL Pinning w aplikacjach przetwarzających wrażliwe informacje.

#### Inspekcja ruchu

Aby przeprowadzić inspekcję ruchu HTTP, konieczne jest **zainstalowanie certyfikatu narzędzia proxy** (np. Burp). Bez zainstalowania tego certyfikatu szyfrowany ruch może nie być widoczny przez proxy. Instrukcję instalacji własnego certyfikatu CA znajdziesz [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Aplikacje targetujące **API Level 24 and above** wymagają modyfikacji Network Security Config, aby zaakceptować certyfikat CA proxy. Ten krok jest kluczowy do inspekcji szyfrowanego ruchu. Instrukcje dotyczące modyfikacji Network Security Config znajdziesz w [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

Jeśli używane jest **Flutter**, musisz postępować zgodnie z instrukcjami na [**this page**](flutter.md). Dzieje się tak, ponieważ samo dodanie certyfikatu do store nie wystarczy — Flutter ma własną listę zaufanych CAs.

#### Statyczne wykrywanie SSL/TLS pinning

Zanim spróbujesz runtime bypasses, szybko zmapuj miejsca, w których pinning jest wymuszany w APK. Odkrywanie statyczne pomaga zaplanować hooks/patches i skupić się na właściwych ścieżkach kodu.

Tool: SSLPinDetect
- Narzędzie open-source do analizy statycznej, które dekompiluje APK do Smali (via apktool) i skanuje przygotowane wzorce regex implementacji SSL/TLS pinning.
- Zgłasza dokładną ścieżkę pliku, numer linii i fragment kodu dla każdego dopasowania.
- Obejmuje popularne frameworki i niestandardowe ścieżki kodu: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

Instalacja
- Wymagania: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Użycie
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Przykładowe reguły wzorców (JSON)
Użyj lub rozbuduj signatures, aby wykrywać własnościowe/niestandardowe style pinning. Możesz wczytać własny JSON i skanować na dużą skalę.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes and tips
- Szybkie skanowanie dużych aplikacji przy użyciu wielowątkowości i memory-mapped I/O; pre-compiled regex zmniejsza narzut/fałszywe pozytywy.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Typical detection targets to triage next:
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Declarative pins in res/xml network security config and manifest references
- Use the matched locations to plan Frida hooks, static patches, or config reviews before dynamic testing.



#### Bypassing SSL Pinning

Gdy SSL Pinning jest zaimplementowany, konieczne staje się jego obejście, aby przeanalizować ruch HTTPS. Do tego celu dostępne są różne metody:

- Automatically **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). The best pro of this option, is that you won't need root to bypass the SSL Pinning, but you will need to delete the application and reinstall the new one, and this won't always work.
- You could use **Frida** (discussed below) to bypass this protection. Here you have a guide to use Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- You can also try to **automatically bypass SSL Pinning** using [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- You can also try to **automatically bypass SSL Pinning** using **MobSF dynamic analysis** (explained below)
- If you still think that there is some traffic that you aren't capturing you can try to **forward the traffic to burp using iptables**. Read this blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Looking for Common Web Vulnerabilities

Ważne jest także poszukiwanie typowych podatności webowych wewnątrz aplikacji. Szczegółowe informacje na temat identyfikacji i łagodzenia tych podatności wykraczają poza zakres tego streszczenia, ale są szeroko omówione gdzie indziej.

### Frida

[Frida](https://www.frida.re) is a dynamic instrumentation toolkit for developers, reverse-engineers, and security researchers.\
**You can access running application and hook methods on run time to change the behaviour, change values, extract values, run different code...**\
If you want to pentest Android applications you need to know how to use Frida.

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Some "GUI" for actions with Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- You can find some Awesome Frida scripts here: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Try to bypass anti-debugging / anti-frida mechanisms loading Frida as in indicated in [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Zrzut pamięci - Fridump**

Sprawdź, czy aplikacja nie przechowuje w pamięci informacji wrażliwych, których nie powinna przechowywać, takich jak hasła czy mnemoniki.

Using [**Fridump3**](https://github.com/rootbsd/fridump3) you can dump the memory of the app with:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
To wykona dump pamięci w folderze ./dump, a tam możesz przeszukać za pomocą grep, na przykład:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Wrażliwe dane w Keystore**

W Androidzie Keystore jest najlepszym miejscem do przechowywania wrażliwych danych, jednak przy wystarczających uprawnieniach wciąż jest **możliwe uzyskanie do niego dostępu**. Ponieważ aplikacje mają tendencję do przechowywania tutaj **wrażliwych danych w postaci jawnej**, podczas pentests należy to sprawdzić, ponieważ root user lub osoba z fizycznym dostępem do urządzenia może być w stanie ukraść te dane.

Nawet jeśli aplikacja przechowuje dane w Keystore, dane powinny być zaszyfrowane.

Aby uzyskać dostęp do danych w Keystore możesz użyć tego skryptu Frida: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Używając poniższego skryptu Frida może być możliwe **bypass fingerprint authentication**, które aplikacje Android mogą stosować w celu **protect certain sensitive areas:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Obrazy w tle**

Kiedy umieścisz aplikację w tle, Android zapisuje migawkę aplikacji, dzięki czemu po przywróceniu do pierwszego planu zaczyna najpierw ładować ten obraz, co sprawia, że aplikacja wydaje się ładować szybciej.

Jednak jeśli ta migawka zawiera wrażliwe informacje, osoba mająca do niej dostęp może je ukraść (uwaga: dostęp wymaga uprawnień root).

Migawki są zwykle przechowywane w: **`/data/system_ce/0/snapshots`**

Android oferuje sposób na **zapobieganie przechwytywaniu zrzutów ekranu poprzez ustawienie parametru layoutu FLAG_SECURE**. Używając tej flagi, zawartość okna jest traktowana jako bezpieczna, co zapobiega jej pojawianiu się na zrzutach ekranu oraz wyświetlaniu na niezabezpieczonych ekranach.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

To narzędzie może pomóc w zarządzaniu różnymi narzędziami podczas analizy dynamicznej: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Deweloperzy często tworzą komponenty pośredniczące takie jak activities, services i broadcast receivers, które obsługują te Intents i przekazują je do metod takich jak `startActivity(...)` czy `sendBroadcast(...)`, co może być ryzykowne.

Zagrożenie polega na tym, że atakujący mogą sprowokować uruchomienie nie-eksportowanych komponentów aplikacji lub uzyskać dostęp do wrażliwych content providers poprzez przekierowanie tych Intents. Przykładem jest komponent `WebView`, który konwertuje URL-e na obiekty `Intent` za pomocą `Intent.parseUri(...)`, a następnie je wykonuje, co może prowadzić do złośliwych Intent injections.

### Essential Takeaways

- **Intent Injection** jest podobny do webowego problemu Open Redirect.
- Eksploity polegają na przekazywaniu obiektów `Intent` jako extras, które mogą zostać przekierowane do wykonania niebezpiecznych operacji.
- Może ujawnić nie-eksportowane komponenty oraz content providers atakującym.
- Konwersja URL-i do `Intent` przez `WebView` może ułatwiać wykonanie niezamierzonych akcji.

### Android Client Side Injections and others

Prawdopodobnie znasz tego typu podatności z Weba. Należy zachować szczególną ostrożność względem tych podatności w aplikacji Android:

- **SQL Injection:** Podczas operowania na zapytaniach dynamicznych lub Content-Providers upewnij się, że używasz zapytań parametryzowanych.
- **JavaScript Injection (XSS):** Sprawdź, czy wsparcie dla JavaScript i Pluginów jest wyłączone dla wszystkich WebViews (domyślnie wyłączone). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews powinny mieć dostęp do systemu plików wyłączony (domyślnie włączony) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: W wielu przypadkach, gdy aplikacja Android kończy sesję, cookie nie jest unieważniane lub może być nawet zapisane na dysku
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Analiza statyczna**

![](<../../images/image (866).png>)

Ocena podatności aplikacji za pomocą przyjaznego webowego frontendu. Możesz też przeprowadzić analizę dynamiczną (ale musisz przygotować środowisko).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Zauważ, że MobSF potrafi analizować **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Również, jeśli utworzysz plik **ZIP** z kodem źródłowym aplikacji **Android** lub **IOS** (wejdź do katalogu głównego aplikacji, zaznacz wszystko i utwórz ZIPfile), będzie on również w stanie go przeanalizować.

MobSF pozwala także na **diff/Compare** analiz oraz na integrację z **VirusTotal** (będziesz musiał ustawić swój klucz API w _MobSF/settings.py_ i włączyć go: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). Możesz też ustawić `VT_UPLOAD` na `False`, wtedy zamiast pliku zostanie **upload**owany **hash**.

### Wspomagana analiza dynamiczna z MobSF

**MobSF** może być również bardzo pomocny przy **dynamic analysis** w **Android**, ale w tym przypadku będziesz musiał zainstalować MobSF oraz **genymotion** na hoście (VM lub Docker nie zadziałają). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
**MobSF dynamic analyser** może:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). Wszystko to jest wykonywane automatycznie z wyjątkiem screenshotów — musisz nacisnąć, kiedy chcesz zrobić screenshot albo nacisnąć "**Exported Activity Tester**", aby uzyskać zrzuty wszystkich eksportowanych aktywności.
- Przechwytywać **HTTPS traffic**
- Używać **Frida** do uzyskania **runtime** **information**

Od wersji android **> 5**, automatycznie uruchomi **Frida** i ustawi globalne ustawienia **proxy** w celu przechwycenia ruchu. Będzie przechwytywać ruch tylko z testowanej aplikacji.

**Frida**

Domyślnie używane są też niektóre skrypty Frida do **bypass SSL pinning**, **root detection** i **debugger detection** oraz do **monitorowania interesujących API**.\
MobSF może również **invoke exported activities**, zrobić ich **screenshots** i **zapisć** je w raporcie.

Aby **rozpocząć** testowanie dynamiczne naciśnij zielony przycisk: "**Start Instrumentation**". Naciśnij "**Frida Live Logs**", aby zobaczyć logi generowane przez skrypty Frida oraz "**Live API Monitor**", aby zobaczyć wszystkie wywołania do zahakowanych metod, przekazywane argumenty i zwracane wartości (pojawi się to po naciśnięciu "Start Instrumentation").\
MobSF pozwala także załadować własne **Frida scripts** (aby wysłać wyniki swoich skryptów Frida do MobSF użyj funkcji `send()`). Ma też **kilka predefiniowanych skryptów**, które możesz załadować (możesz dodać więcej w `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), po prostu **wybierz je**, naciśnij "**Load**" i następnie "**Start Instrumentation**" (będziesz mógł zobaczyć logi tych skryptów w "**Frida Live Logs**").

![](<../../images/image (419).png>)

Ponadto masz kilka pomocniczych funkcji Frida:

- **Enumerate Loaded Classes**: Wypisze wszystkie załadowane klasy
- **Capture Strings**: Wypisuje wszystkie przechwycone stringi podczas używania aplikacji (bardzo głośne)
- **Capture String Comparisons**: Może być bardzo przydatne. Pokaże **dwa porównywane stringi** i czy wynik był True czy False.
- **Enumerate Class Methods**: Wpisz nazwę klasy (np. "java.io.File") i wypisze wszystkie metody klasy.
- **Search Class Pattern**: Szuka klas po wzorcu
- **Trace Class Methods**: **Trace** całej klasy (zobacz wejścia i wyjścia wszystkich metod klasy). Pamiętaj, że domyślnie MobSF trace'uje kilka interesujących metod Android API.

Gdy wybierzesz moduł pomocniczy, który chcesz użyć, musisz nacisnąć "**Start Intrumentation**" i zobaczysz wszystkie wyjścia w "**Frida Live Logs**".

**Shell**

Mobsf dostarcza także shell z kilkoma poleceniami **adb**, **MobSF commands**, i typowymi **shell** **commands** na dole strony analizy dynamicznej. Kilka ciekawych poleceń:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP tools**

Kiedy ruch HTTP zostanie przechwycony, możesz zobaczyć surowy widok przechwyconego ruchu w przycisku "**HTTP(S) Traffic**" u dołu lub ładniejszy widok w zielonym przycisku "**Start HTTPTools**". Z drugiej opcji możesz **wysłać** **przechwycone żądania** do **proxies** takich jak Burp lub Owasp ZAP.\
Aby to zrobić, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> naciśnij "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Po zakończeniu analizy dynamicznej za pomocą MobSF możesz nacisnąć "**Start Web API Fuzzer**", aby **fuzz http requests** i poszukać podatności.

> [!TIP]
> Po wykonaniu analizy dynamicznej z MobSF ustawienia proxy mogą być nieprawidłowo skonfigurowane i nie będziesz w stanie ich naprawić z poziomu GUI. Możesz naprawić ustawienia proxy wykonując:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

Narzędzie można pobrać z [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
To narzędzie używa pewnych **Hooks**, żeby poinformować Cię **co dzieje się w aplikacji** podczas przeprowadzania **analizy dynamicznej**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

To **świetne narzędzie do przeprowadzania analizy statycznej z GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

To narzędzie zostało zaprojektowane do wyszukiwania różnych **security related Android application vulnerabilities**, zarówno w **source code**, jak i w **packaged APKs**. Narzędzie jest także **capable of creating a "Proof-of-Concept" deployable APK** oraz **ADB commands**, aby wykorzystać niektóre z odnalezionych podatności (Exposed activities, intents, tapjacking...). Podobnie jak w przypadku Drozer, nie ma potrzeby rootowania urządzenia testowego.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Wyświetla wszystkie wyodrębnione pliki dla łatwego przeglądu
- Automatycznie dekompiluje pliki APK do formatu Java i Smali
- Analizuje AndroidManifest.xml pod kątem typowych podatności i zachowań
- Statyczna analiza kodu źródłowego pod kątem typowych podatności i zachowań
- Informacje o urządzeniu
- i inne
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER jest aplikacją wiersza poleceń, którą można używać w Windows, MacOS X i Linux, analizującą pliki _.apk_ w poszukiwaniu podatności. Robi to przez dekompresję APKs i zastosowanie serii reguł w celu wykrycia tych podatności.

Wszystkie reguły są umieszczone w pliku `rules.json`, a każda firma lub tester może stworzyć własne reguły, aby analizować to, czego potrzebuje.

Pobierz najnowsze binaria ze [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn to **crossplatform** narzędzie, które pomaga developerom, bugbounty hunters i ethical hackers przeprowadzać [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) na aplikacjach mobilnych.

Koncepcja polega na tym, że przeciągasz i upuszczasz plik aplikacji mobilnej (plik .apk lub .ipa) na aplikację StaCoAn, a ona wygeneruje dla Ciebie wizualny i przenośny raport. Możesz dostosować ustawienia i wordlists, aby uzyskać spersonalizowane doświadczenie.

Pobierz[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework to system analizy podatności Androida, który pomaga deweloperom lub hackers znaleźć potencjalne luki bezpieczeństwa w aplikacjach Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** to narzędzie, którego głównym celem jest wykrywanie i ostrzeganie użytkownika przed potencjalnymi złośliwymi zachowaniami wykonywanymi przez aplikację Android.

Wykrywanie odbywa się za pomocą **static analysis** Dalvik bytecode aplikacji, reprezentowanego jako **Smali**, przy użyciu biblioteki [`androguard`](https://github.com/androguard/androguard).

To narzędzie wyszukuje **powszechne zachowania 'złych' aplikacji** takie jak: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** to framework do inżynierii wstecznej i analizy aplikacji mobilnych. Jest to narzędzie, które łączy powszechnie używane narzędzia do reverse engineeringu i analizy aplikacji mobilnych, aby wspomóc testowanie aplikacji mobilnych pod kątem zagrożeń bezpieczeństwa mobilnego OWASP. Jego celem jest ułatwienie tego zadania i uczynienie go bardziej przyjaznym dla deweloperów aplikacji mobilnych oraz specjalistów ds. bezpieczeństwa.

Potrafi:

- Extract Java and Smali code using different tools
- Analizować pliki APK przy użyciu: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Wydobywać prywatne informacje z APK za pomocą regexps.
- Analizować Manifest.
- Analizować znalezione domeny przy użyciu: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuskować APK za pomocą [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Przydatne do wykrywania malware: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Zauważ, że w zależności od usługi i konfiguracji użytej do obfuskacji kodu, sekrety mogą, ale nie muszą być obfuskowane.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. It is able to optimize bytecode as well as detect and remove unused instructions. ProGuard is free software and is distributed under the GNU General Public License, version 2.

ProGuard jest dystrybuowany jako część Android SDK i uruchamia się podczas budowania aplikacji w trybie release.

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Ostatnim razem, gdy sprawdzaliśmy, tryb działania Dexguard wyglądał następująco:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

Możesz przesłać obfuskowany APK na ich platformę.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

It is a **generic android deobfuscator.** Simplify **virtually executes an app** to understand its behavior and then **tries to optimize the code** so it behaves identically but is easier for a human to understand. Each optimization type is simple and generic, so it doesn't matter what the specific type of obfuscation is used.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD daje informacje o tym, **jak stworzono APK**. Identyfikuje wiele **kompilerów**, **packerów**, **obfuskatorów** i innych dziwnych rzeczy. To [_PEiD_](https://www.aldeid.com/wiki/PEiD) dla Androida.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b to wirtualna maszyna bezpieczeństwa Android oparta na ubuntu-mate, zawierająca zbiór najnowszych frameworków, samouczków i laboratoriów od różnych entuzjastów i badaczy bezpieczeństwa do reverse engineeringu i analizy malware.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) To świetna lista zasobów
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
