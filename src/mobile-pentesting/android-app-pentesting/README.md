# Android एप्लिकेशन Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android एप्लिकेशन मूल बातें

यह पृष्ठ पढ़ना अत्यंत अनुशंसित है ताकि आप **Android सुरक्षा से संबंधित सबसे महत्वपूर्ण हिस्सों और किसी Android एप्लिकेशन में मौजूद सबसे खतरनाक घटकों** के बारे में जान सकें:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

यह मुख्य टूल है जिसकी आपको किसी android device (emulated या physical) से कनेक्ट करने के लिए आवश्यकता होती है.\
**ADB** कंप्यूटर से **USB** या **Network** के माध्यम से डिवाइस को नियंत्रित करने की अनुमति देता है। यह utility दोनों दिशाओं में फ़ाइलों की **कॉपी**, ऐप्स की **installation** और **uninstallation**, शेल कमांड्स का **execution**, डेटा का **backup**, लॉग्स का **reading**, और अन्य कार्यों को सक्षम बनाता है।

ADB का उपयोग कैसे करना है यह सीखने के लिए [**ADB Commands**](adb-commands.md) की निम्नलिखित सूची देखें।


## Smali

कभी-कभी यह दिलचस्प होता है कि एप्लिकेशन कोड को **modify** किया जाए ताकि **hidden information** (शायद अच्छी तरह obfuscated passwords या flags) तक पहुंचा जा सके। फिर, apk को decompile करना, कोड modify करना और उसे फिर से recompile करना दिलचस्प हो सकता है.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). यह dynamic analysis के दौरान किए जाने वाले कई परीक्षणों के लिए एक उपयोगी विकल्प हो सकता है। इसलिए, **इस संभावना को हमेशा ध्यान में रखें**।

## Other interesting tricks

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **APKs डाउनलोड करें**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- डिवाइस से APK निकालें:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- सभी splits और base apks को [APKEditor](https://github.com/REAndroid/APKEditor) के साथ मर्ज करें:
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## केस स्टडीज़ और कमजोरियाँ


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## स्थैतिक विश्लेषण

सबसे पहले, APK का विश्लेषण करने के लिए आपको decompiler का उपयोग करके Java कोड को देखना चाहिए।\
Please, [**read here to find information about different available decompilers**](apk-decompilers.md).

### दिलचस्प जानकारी की तलाश

APK की **strings** को देखकर आप **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** और कोई भी रोचक चीज़ खोज सकते हैं... यहां तक कि code execution **backdoors** या authentication backdoors (app के लिए hardcoded admin credentials) भी देखें।

**Firebase**

विशेष ध्यान दें **firebase URLs** पर और जाँचें कि क्या यह गलत कॉन्फ़िगर है। [More information about whats is FIrebase and how to exploit it here.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### एप्लिकेशन की बुनियादी समझ - Manifest.xml, strings.xml

किसी एप्लिकेशन की _Manifest.xml_ और _strings.xml_ फ़ाइलों की जाँच संभावित सुरक्षा कमजोरियों का खुलासा कर सकती है। इन फ़ाइलों को decompilers से एक्सेस किया जा सकता है या APK की फ़ाइल एक्सटेंशन को .zip में बदलकर और फिर उसे unzip करके भी निकाला जा सकता है।

**कमजोरियाँ** जो **Manifest.xml** से पहचानी जा सकती हैं, उनमें शामिल हैं:

- **Debuggable Applications**: Manifest.xml में `debuggable="true"` के रूप में सेट applications जोखिम पैदा करते हैं क्योंकि ये ऐसे कनेक्शनों की अनुमति देते हैं जो exploitation की ओर ले जा सकते हैं। debuggable applications को कैसे exploit करना है, इस पर समझ के लिए device पर debuggable applications को ढूँढने और exploit करने वाले tutorial देखें।
- **Backup Settings**: संवेदनशील जानकारी वाले applications के लिए `android:allowBackup="false"` attribute को स्पष्ट रूप से सेट किया जाना चाहिए ताकि adb के माध्यम से unauthorized data backups को रोका जा सके, खासकर जब usb debugging enabled हो।
- **Network Security**: _res/xml/_ में custom network security configurations (`android:networkSecurityConfig="@xml/network_security_config"`) certificate pins और HTTP traffic settings जैसे security विवरण निर्दिष्ट कर सकते हैं। एक उदाहरण कुछ domains के लिए HTTP traffic की अनुमति देना है।
- **Exported Activities and Services**: मैनिफेस्ट में exported activities और services की पहचान ऐसे components को उजागर कर सकती है जो misuse किए जा सकते हैं। dynamic testing के दौरान आगे की analysis यह बता सकती है कि इन components को कैसे exploit किया जा सकता है।
- **Content Providers and FileProviders**: exposed content providers unauthorized access या data modification की अनुमति दे सकते हैं। FileProviders की configuration का भी ध्यानपूर्वक परीक्षण किया जाना चाहिए।
- **Broadcast Receivers and URL Schemes**: ये components exploitation के लिए leverage किए जा सकते हैं, विशेष रूप से यह देखने के लिए कि URL schemes को input vulnerabilities के संदर्भ में कैसे manage किया जा रहा है।
- **SDK Versions**: `minSdkVersion`, `targetSDKVersion`, और `maxSdkVersion` attributes supported Android versions को दर्शाते हैं, और सुरक्षा कारणों से outdated, vulnerable Android versions का समर्थन न करने के महत्व को उजागर करते हैं।

_Strings.xml_ फ़ाइल से, API keys, custom schemas और अन्य developer notes जैसी संवेदनशील जानकारी मिल सकती है, जो इन resources की सावधानीपूर्वक समीक्षा की आवश्यकता को रेखांकित करती है।

### Tapjacking

Tapjacking एक attack है जहाँ एक malicious application लॉन्च किया जाता है और वह खुद को victim application के ऊपर स्थित कर देता है। एक बार जब यह victim app को दृश्य रूप से ढक देता है, तो इसका user interface इस तरह डिजाइन किया जाता है कि वह user को इसके साथ interact करने के लिए धोखा दे, जबकि यह interaction victim app तक पास कर दिया जाता है।\
प्रभावत: यह user को यह जानने से अंधा कर देता है कि वे असल में victim app पर ही क्रियाएँ कर रहे हैं।

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

यदि किसी activity का `launchMode` `singleTask` पर सेट है और कोई `taskAffinity` परिभाषित नहीं है तो वह task Hijacking के लिये vulnerable होती है। इसका अर्थ है कि एक malicious application install करके और यदि वह real application से पहले launch किया जाए तो वह real application का task hijack कर सकता है (इससे user यह सोचकर malicious application के साथ interact करेगा कि वह real application उपयोग कर रहा है)।

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### असुरक्षित डेटा स्टोरेज

**Internal Storage**

Android में, internal storage में store की गई फ़ाइलें उस app द्वारा ही एक्सेस करने के लिए डिज़ाइन की जाती हैं जिसने उन्हें बनाया था। यह security measure Android operating system द्वारा लागू होती है और अधिकांश applications की security आवश्यकताओं के लिए आम तौर पर पर्याप्त है। हालाँकि, developers कभी-कभी `MODE_WORLD_READABLE` और `MODE_WORLD_WRITABLE` जैसे modes का उपयोग करते हैं ताकि फ़ाइलें विभिन्न applications के बीच share की जा सकें। फिर भी, ये modes अन्य applications, जिनमें potentially malicious ones भी शामिल हैं, द्वारा इन फ़ाइलों तक access को रोकते नहीं हैं।

1. **Static Analysis:**
- **सुनिश्चित करें** कि `MODE_WORLD_READABLE` और `MODE_WORLD_WRITABLE` के उपयोग की **सावधानीपूर्वक जाँच** की गई है। ये modes फ़ाइलों को **अनपेक्षित या unauthorized access** के लिए **संभावित रूप से एक्सपोज़** कर सकते हैं।
2. **Dynamic Analysis:**
- **सत्यापित करें** कि app द्वारा बनाई गई फ़ाइलों पर जो **permissions** सेट हैं वे क्या हैं। विशेष रूप से, **जाँच करें** कि क्या कोई फ़ाइलें **दुनिया भर में readable या writable के रूप में सेट** हैं। यह एक महत्वपूर्ण सुरक्षा जोखिम पैदा कर सकता है, क्योंकि यह डिवाइस पर install किसी भी application को, उसके स्रोत या उद्देश्य की परवाह किए बिना, इन फ़ाइलों को **read या modify** करने की अनुमति देगा।

**External Storage**

External storage, जैसे SD Cards पर फ़ाइलों के मामले में, कुछ सावधानियाँ बरतनी चाहिए:

1. **Accessibility**:
- External storage पर फ़ाइलें **वैश्विक रूप से readable और writable** होती हैं। इसका मतलब है कि कोई भी application या user इन फ़ाइलों तक पहुँच सकता है।
2. **Security Concerns**:
- इतनी आसान पहुँच होने के कारण संवेदनशील जानकारी को external storage पर स्टोर न करने की सलाह दी जाती है।
- External storage को हटाया जा सकता है या कोई भी application उसे एक्सेस कर सकता है, जिससे यह कम सुरक्षित बन जाता है।
3. **Handling Data from External Storage**:
- हमेशा external storage से प्राप्त डेटा पर input validation करें। यह महत्वपूर्ण है क्योंकि यह डेटा एक untrusted स्रोत से आता है।
- External storage पर executables या class files को dynamic loading के लिए स्टोर करना सख्त तौर पर अनुशंसित नहीं है।
- यदि आपका application external storage से executable फ़ाइलें प्राप्त करता है, तो सुनिश्चित करें कि ये फ़ाइलें signature के साथ signed और cryptographically verified हों इससे पहले कि उन्हें dynamically load किया जाए। यह आपके application की security integrity बनाए रखने के लिए आवश्यक है।

External storage को `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard` में access किया जा सकता है

> [!TIP]
> एंड्रॉइड 4.4 (**API 17**) से शुरू होकर, SD card में ऐसी directory structure है जो किसी app की पहुँच को केवल उसी app के लिये specific directory तक सीमित करती है। इससे malicious application को किसी अन्य app की फ़ाइलों तक read या write access प्राप्त करने से रोका जाता है।

**साफ़-पाठ में संग्रहीत संवेदनशील डेटा**

- **Shared preferences**: Android प्रत्येक application को आसानी से xml फ़ाइलें पाथ `/data/data/<packagename>/shared_prefs/` में save करने की अनुमति देता है और कभी-कभी उस फ़ोल्डर में clear-text में संवेदनशील जानकारी मिल सकती है।
- **Databases**: Android प्रत्येक application को आसानी से sqlite databases पाथ `/data/data/<packagename>/databases/` में save करने की अनुमति देता है और कभी-कभी उस फ़ोल्डर में clear-text में संवेदनशील जानकारी मिल सकती है।

### Broken TLS

**Accept All Certificates**

कभी-कभी कुछ developers सभी certificates स्वीकार कर लेते हैं भले ही उदाहरण के लिए hostname match न करता हो, ऐसे lines of code के साथ जैसे निम्नलिखित:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### खराब क्रिप्टोग्राफी

**Poor Key Management Processes**

कुछ developers संवेदनशील डेटा को local storage में सेव करते हैं और इसे उस key से encrypt करते हैं जो code में hardcoded/ predictable होती है। ऐसा नहीं किया जाना चाहिए क्योंकि कुछ reversing से attackers confidential जानकारी extract कर सकते हैं।

**Use of Insecure and/or Deprecated Algorithms**

Developers को authorization **checks**, data **store** या **send** करने के लिए **deprecated algorithms** का उपयोग नहीं करना चाहिए। इनमें से कुछ algorithms हैं: RC4, MD4, MD5, SHA1... यदि पासवर्ड स्टोर करने के लिए **hashes** का उपयोग किया जाता है, तो salt के साथ brute-force प्रतिरोधी hashes का उपयोग किया जाना चाहिए।

### अन्य जाँचें

- यह सुझाव दिया जाता है कि **APK को obfuscate** किया जाए ताकि attackers के लिए reverse engineer का काम मुश्किल हो।
- यदि ऐप संवेदनशील है (जैसे bank apps), तो उसे अपने **स्वयं के checks यह देखने के लिए कि mobile rooted है या नहीं** करने चाहिए और उसके अनुसार कारवाई करनी चाहिए।
- यदि ऐप संवेदनशील है (जैसे bank apps), तो उसे यह चेक करना चाहिए कि कोई **emulator** उपयोग हो रहा है या नहीं।
- यदि ऐप संवेदनशील है (जैसे bank apps), तो उसे **execute करने से पहले अपनी integrity चेक** करनी चाहिए ताकि जाँचा जा सके कि इसे modify तो नहीं किया गया।
- Use [**APKiD**](https://github.com/rednaga/APKiD) to check which compiler/packer/obfuscator was used to build the APK

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

Tool [**mariana-trench**](https://github.com/facebook/mariana-trench) को application के **code** को **scan** करके **vulnerabilities** खोजने के लिए इस्तेमाल किया जा सकता है। यह tool एक series of **known sources** (जो tool को बताते हैं कि किस **places** पर **input** user द्वारा **control** होता है), **sinks** (जो tool को बताते हैं कि कौन से **dangerous** **places** हैं जहाँ malicious user input नुकसान कर सकता है) और **rules** रखता है। ये rules sources-sinks के **combination** को indicate करते हैं जो vulnerability की ओर इशारा करते हैं।

इन जानकारी के साथ, **mariana-trench कोड की समीक्षा करेगा और उस पर संभावित vulnerabilities ढूँढेगा।**

### Secrets leaked

एक application में secrets (API keys, passwords, hidden urls, subdomains...) हो सकते हैं जिन्हें आप खोज सकते हैं। आप ऐसे tool का उपयोग कर सकते हैं जैसे [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)
- In-memory native code execution via JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> सबसे पहले, आपको एक ऐसा environment चाहिए जहाँ आप application और सभी environment (Burp CA cert, Drozer और Frida मुख्य रूप से) install कर सकें। इसलिए, एक rooted device (emulated हो या नहीं) बहुत सलाहयोग्य है।

### Online Dynamic analysis

आप एक **free account** बना सकते हैं: [https://appetize.io/](https://appetize.io). यह platform आपको APKs **upload** और **execute** करने की अनुमति देता है, इसलिए यह यह देखने के लिए उपयोगी है कि apk कैसे behave कर रहा है।

आप web में अपनी application के logs भी **देख** सकते हैं और **adb** के माध्यम से connect कर सकते हैं।

![](<../../images/image (831).png>)

ADB connection के कारण आप emulators के अंदर **Drozer** और **Frida** का उपयोग कर सकते हैं।

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (You can create **x86** and **arm** devices, and according to [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** versions **support ARM libraries** without needing an slow arm emulator).
- Learn to set it up in this page:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, you need to create an account. _It's recommend to **download** the version **WITH**_ _**VirtualBox** to avoid potential errors._)
- [**Nox**](https://es.bignox.com) (Free, but it doesn't support Frida or Drozer).

> [!TIP]
> जब किसी भी platform पर नया emulator बना रहे हों तो ध्यान रखें कि स्क्रीन जितनी बड़ी होगी, emulator उतना ही धीमा चलेगा। इसलिए संभव हो तो छोटे स्क्रीन चुनें।

To **install google services** (like AppStore) in Genymotion you need to click on the red marked button of the following image:

![](<../../images/image (277).png>)

इसके अलावा, **Genymotion में Android VM की configuration** में आप **Bridge Network mode** चुन सकते हैं (यह उपयोगी होगा यदि आप tools के साथ किसी अलग VM से Android VM से connect कर रहे हों)।

#### Use a physical device

आपको **debugging** options सक्रिय करनी होंगी और अच्छा रहेगा यदि आप इसे **root** कर सकें:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> एक बार जब आपने application install कर ली, तो सबसे पहले आपको इसे चलाकर जांचना चाहिए कि यह क्या करता है, यह कैसे काम करता है और इसके साथ सहज होना चाहिए.\
> मैं सुझाव दूँगा कि इस प्रारंभिक dynamic analysis को MobSF dynamic analysis + pidcat का उपयोग करके करें, ताकि हम यह सीख सकें कि application कैसे काम करता है जबकि MobSF बहुत सारी interesting data capture कर रहा होगा जिन्हें आप बाद में review कर सकते हैं।

Magisk/Zygisk quick notes (recommended on Pixel devices)
- Magisk app से boot.img को patch करें और systemless root पाने के लिए fastboot के माध्यम से flash करें
- Zygisk + DenyList को root hiding के लिए सक्षम करें; जब अधिक मजबूत hiding आवश्यक हो तो LSPosed/Shamiko पर विचार करें
- OTA updates से recover करने के लिए original boot.img रखें; प्रत्येक OTA के बाद पुनः patch करें
- screen mirroring के लिए, host पर scrcpy का उपयोग करें



### Unintended Data Leakage

**Logging**

Developers को सार्वजनिक रूप से **debugging information** उजागर करने में सावधान रहना चाहिए, क्योंकि इससे संवेदनशील data leak हो सकती है। application logs मॉनिटर करने के लिए tools [**pidcat**](https://github.com/JakeWharton/pidcat) और `adb logcat` की सिफारिश की जाती है ताकि संवेदनशील जानकारी की पहचान और सुरक्षा की जा सके। **Pidcat** अपने उपयोग में सरलता और readability के कारण पसंद किया जाता है।

> [!WARNING]
> ध्यान दें कि **Android 4.0 के बाद के संस्करणों** से, **applications केवल अपने स्वयं के logs तक ही access कर पाने में सक्षम हैं**। इसलिए applications अन्य apps के logs access नहीं कर सकतीं।\
> फिर भी, संवेदनशील जानकारी log न करने की सलाह दी जाती है।

**Copy/Paste Buffer Caching**

Android का **clipboard-based** framework apps में copy-paste की सुविधा देता है, पर यह जोखिम भी उत्पन्न करता है क्योंकि **अन्य applications** clipboard तक **access** कर सकती हैं, जिससे संवेदनशील डेटा expose हो सकता है। इसलिए application के संवेदनशील हिस्सों (जैसे credit card विवरण) के लिए copy/paste functions disabled रखने चाहिए ताकि data leak से बचा जा सके।

**Crash Logs**

यदि कोई application **crash** होता है और logs save करता है, तो ये logs attackers की मदद कर सकते हैं, खासकर जब application का reverse-engineering संभव न हो। इस जोखिम को कम करने के लिए crash पर logging से बचें, और यदि logs नेटवर्क पर भेजने आवश्यक हों तो उन्हें SSL चैनल के माध्यम से भेजें।

As pentester, **try to take a look to these logs**.

**Analytics Data Sent To 3rd Parties**

Applications अक्सर Google Adsense जैसी services integrate करते हैं, जो गलत implementation की वजह से संवेदनशील डेटा unintentionally **leak** कर सकती हैं। संभावित data leaks पहचानने के लिए, यह सलाह दी जाती है कि आप application's traffic intercept करें और जाँच करें कि क्या कोई sensitive information third-party services को भेजी जा रही है।

### SQLite DBs

अधिकांश applications जानकारी सेव करने के लिए **internal SQLite databases** का उपयोग करेंगे। pentest के दौरान बनाए गए **databases**, **tables** और **columns** के नामों तथा सभी saved **data** को देखें क्योंकि आप वहां **sensitive information** पा सकते हैं (जो vulnerability होगी)।\
Databases सामान्यतः `/data/data/the.package.name/databases` में स्थित होते हैं जैसे `/data/data/com.mwr.example.sieve/databases`

यदि database confidential जानकारी सेव कर रहा है और वह **encrypted** है पर आप application के अंदर password **find** कर लेते हैं तो यह अभी भी एक **vulnerability** है।

तालिकाओं की सूची देखने के लिए `.tables` का उपयोग करें और तालिकाओं के columns को enumerate करने के लिए `.schema <table_name>` चलाएँ

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** आपको **एक Android app की भूमिका अपनाने** और अन्य apps के साथ interact करने की अनुमति देता है। यह वह सब कुछ कर सकता है जो एक installed application कर सकती है, जैसे Android की Inter-Process Communication (IPC) mechanism का उपयोग करना और underlying operating system के साथ interact करना। .\
Drozer एक उपयोगी tool है जो **exported activities, exported services और Content Providers** को exploit करने में सहायक है जैसा कि आप निम्न sections में सीखेंगे।

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
साथ ही याद रखें कि किसी activity का कोड **`onCreate`** method में शुरू होता है।

**Authorisation bypass**

जब कोई Activity exported होती है आप उसकी स्क्रीन को किसी external app से invoke कर सकते हैं। इसलिए, यदि किसी activity में **sensitive information** है और वह **exported** है तो आप authentication mechanisms को bypass करके उसे access कर सकते हैं।

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

आप adb से भी एक exported activity start कर सकते हैं:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF किसी activity में `android:launchMode` के रूप में _**singleTask/singleInstance**_ के उपयोग को malicious के रूप में पहचान करेगा, लेकिन [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750) के कारण, स्पष्ट रूप से यह केवल पुराने versions (API versions < 21) पर ही खतरनाक है।

> [!TIP]
> ध्यान रखें कि an authorisation bypass हमेशा एक vulnerability नहीं होता — यह निर्भर करेगा कि bypass कैसे काम करता है और कौन-सी जानकारी exposed होती है।

**Sensitive information leakage**

**Activities can also return results**. यदि आप कोई exported और unprotected activity ढूँढ लेते हैं जो **`setResult`** method को कॉल कर रही हो और **returning sensitive information**, तो वहां sensitive information leakage मौजूद होगा।

#### Tapjacking

यदि Tapjacking रोका नहीं गया है, तो आप exported activity का दुरुपयोग करके **user को unexpected actions करने के लिए मजबूर** कर सकते हैं। Tapjacking के बारे में अधिक जानकारी के लिए [**what is Tapjacking follow the link**](#tapjacking) देखें।

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers मूलतः **share data** करने के लिए उपयोग होते हैं। यदि किसी app के पास उपलब्ध content providers हैं, तो आप उनसे **extract sensitive** डेटा निकाल पाते हैं। साथ ही यह जांचना भी उपयोगी है कि संभवतः **SQL injections** और **Path Traversals** के लिए वे vulnerable तो नहीं।

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
ध्यान रखें कि एक Service की क्रियाएं method `onStartCommand` में शुरू होती हैं।

एक Service मूलतः कुछ ऐसा है जो **can receive data**, उसे **process** करता है और (या नहीं) एक response **returns** करता है। इसलिए, यदि कोई application कुछ services export कर रहा है तो आपको **code** की जाँच करनी चाहिए कि यह क्या कर रहा है और confidential जानकारी निकालने, authentication measures bypass करने आदि के लिए इसे **dynamically** टेस्ट करना चाहिए...\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
ध्यान रखें कि एक Broadcast Receiver की क्रियाएं method `onReceive` में शुरू होती हैं।

एक broadcast receiver किसी प्रकार के message के लिए इंतज़ार करेगा। यह इस बात पर निर्भर करता है कि receiver message को कैसे handle करता है — यह vulnerable हो सकता है।\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

आप manually deep links ढूँढ सकते हैं, tools जैसे MobSF या scripts जैसे [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py) का उपयोग करके।\
आप **open** कर सकते हैं किसी declared **scheme** को **adb** या किसी **browser** से:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_ध्यान दें कि आप **पैकेज नाम** को छोड़ सकते हैं और मोबाइल स्वचालित रूप से उस ऐप को कॉल करेगा जो उस लिंक को खोलना चाहिए._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**निष्पादित कोड**

ऐप में निष्पादित होने वाले **कोड को खोजने के लिए**, deeplink द्वारा कॉल की गई activity में जाएँ और function **`onNewIntent`** खोजें।

![](<../../images/image (436) (1) (1) (1).png>)

**Sensitive info**

हर बार जब आप कोई deep link पाते हैं तो जांचें कि i**यह URL parameters के माध्यम से संवेदनशील डेटा (जैसे पासवर्ड) प्राप्त तो नहीं कर रहा है**, क्योंकि कोई भी अन्य application उस deep link का **impersonate** कर सकता है और उन डेटा को चुरा सकता है!

**Parameters in path**

आप **यह भी चेक करना चाहिए कि कोई भी deep link URL के path के अंदर parameter तो उपयोग नहीं कर रहा है** जैसे: `https://api.example.com/v1/users/{username}` , ऐसे मामले में आप path traversal जबरदस्ती कर सकते हैं जैसे: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
ध्यान दें कि यदि आप application के अंदर सही endpoints ढूँढ लेते हैं तो आप **Open Redirect** (यदि path का हिस्सा domain name के रूप में उपयोग हो रहा हो), **account takeover** (यदि आप users के विवरण बिना CSRF token के modify कर सकें और vulnerable endpoint ने सही method उपयोग किया हो) और किसी भी अन्य vuln का कारण बन सकते हैं। अधिक जानकारी के लिए [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

एक [दिलचस्प bug bounty रिपोर्ट](https://hackerone.com/reports/855618) links के बारे में (_/.well-known/assetlinks.json_).

### Transport Layer Inspection and Verification Failures

- **Certificates हमेशा ठीक से.inspect नहीं होते** Android applications द्वारा। अक्सर ये applications warnings को अनदेखा कर self-signed certificates स्वीकार कर लेते हैं या कुछ मामलों में HTTP connections पर वापस लौट जाते हैं।
- **SSL/TLS handshake के दौरान negotiations कभी-कभी कमजोर होती हैं**, और insecure cipher suites का उपयोग किया जाता है। यह vulnerability connection को man-in-the-middle (MITM) attacks के प्रति संवेदनशील बनाती है, जिससे attackers डेटा को decrypt कर सकते हैं।
- **Private information का रिसाव** एक जोखिम है जब applications secure channels का उपयोग कर authenticate करती हैं पर अन्य लेन-देन के लिए non-secure channels पर communicate करती हैं। यह तरीका संवेदनशील डेटा जैसे session cookies या user details को malicious entities द्वारा interception से सुरक्षित रखने में विफल रहता है।

#### Certificate Verification

हम certificate verification पर ध्यान केंद्रित करेंगे। सर्वर के certificate की integrity को verify करना सुरक्षा बढ़ाने के लिए आवश्यक है। यह जरूरी है क्योंकि insecure TLS configurations और संवेदनशील डेटा का unencrypted चैनलों पर संचरण गंभीर जोखिम पैदा कर सकता है। सर्वर certificates की verification और कमजोरियों के समाधान के विस्तृत कदमों के लिए, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) व्यापक मार्गदर्शन प्रदान करता है।

#### SSL Pinning

SSL Pinning एक security measure है जहाँ application सर्वर के certificate को application के भीतर स्टोर की गई ज्ञात कॉपी के खिलाफ verify करती है। यह तरीका MITM attacks को रोकने के लिए महत्वपूर्ण है। SSL Pinning को संवेदनशील जानकारी हैंडल करने वाली applications के लिए लागू करने की कड़े तौर पर अनुशंसा की जाती है।

#### Traffic Inspection

HTTP traffic को निरीक्षण करने के लिए, जरूरी है कि **proxy tool का certificate install किया जाए** (उदाहरण के लिए, Burp)। इस certificate को install किए बिना, encrypted traffic proxy के माध्यम से दिखाई नहीं दे सकती। custom CA certificate install करने के लिए मार्गदर्शिका के लिए, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

API Level 24 and above लक्ष्य करने वाली applications को proxy के CA certificate को स्वीकार करने के लिए Network Security Config में संशोधन करने की आवश्यकता होती है। यह कदम encrypted traffic का निरीक्षण करने के लिए महत्वपूर्ण है। Network Security Config बदलने के निर्देशों के लिए, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

यदि **Flutter** उपयोग किया जा रहा है तो आपको [**this page**](flutter.md) में दिए निर्देशों का पालन करना होगा। ऐसा इसलिए है क्योंकि केवल certificate को store में जोड़ने से काम नहीं चलेगा — Flutter की अपनी valid CAs की सूची होती है।

#### Static detection of SSL/TLS pinning

runtime bypasses का प्रयास करने से पहले, जल्दी से मैप करें कि APK में कहाँ pinning लागू है। Static discovery आपको hooks/patches प्लान करने और सही code paths पर ध्यान केंद्रित करने में मदद करती है।

Tool: SSLPinDetect
- Open-source static-analysis utility जो APK को Smali (via apktool) में decompile करती है और SSL/TLS pinning implementations के curated regex patterns के लिए scan करती है।
- Reports exact file path, line number, और प्रत्येक match के लिए एक code snippet दिखाती है।
- Covers common frameworks और custom code paths: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, और Network Security Config XML pins।

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
उपयोग
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
उदाहरण पैटर्न नियम (JSON)
signatures का उपयोग करें या इन्हें विस्तारित करें ताकि proprietary/custom pinning styles का पता चल सके। आप अपना JSON लोड कर सकते हैं और बड़े पैमाने पर स्कैन कर सकते हैं।
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes and tips
- बड़े ऐप्स पर तेज़ स्कैनिंग के लिए multi-threading और memory-mapped I/O का उपयोग करें; pre-compiled regex ओवरहेड/false positives कम करता है।
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Typical detection targets to triage next:
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Declarative pins in res/xml network security config and manifest references
- मैचे हुए लोकेशन्स का उपयोग dynamic testing से पहले Frida hooks, static patches, या config reviews की योजना बनाने के लिए करें।



#### Bypassing SSL Pinning

जब SSL Pinning लागू होता है, तो HTTPS ट्रैफिक की जाँच के लिए इसे bypass करना आवश्यक हो जाता है। इसके लिए अलग‑अलग तरीके उपलब्ध हैं:

- Automatically **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). इस विकल्प का सबसे बड़ा फायदा यह है कि SSL Pinning bypass करने के लिए root की जरूरत नहीं पड़ेगी, लेकिन आपको एप्लिकेशन को डिलीट करके नया इंस्टॉल करना होगा, और यह हमेशा काम नहीं करेगा।
- आप इस प्रोटेक्शन को bypass करने के लिए **Frida** (नीचे चर्चा की गयी है) का उपयोग कर सकते हैं। Burp+Frida+Genymotion इस्तेमाल करने का गाइड यहाँ है: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- आप [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"` का उपयोग करके SSL Pinning को automatically bypass करने की कोशिश भी कर सकते हैं।
- आप **MobSF dynamic analysis** (नीचे समझाया गया है) का उपयोग करके SSL Pinning को automatically bypass करने की कोशिश कर सकते हैं।
- यदि आपको अभी भी लगता है कि कुछ ट्रैफिक कैप्चर नहीं हो रहा है, तो आप iptables का उपयोग करके ट्रैफिक को burp की ओर forward करके देख सकते हैं। इस ब्लॉग को पढ़ें: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Looking for Common Web Vulnerabilities

ऐप्लिकेशन के भीतर common web vulnerabilities की भी खोज करना महत्वपूर्ण है। इन vuln को पहचानने और mitigate करने की विस्तृत जानकारी इस सारांश के दायरे से बाहर है लेकिन अन्य जगहों पर व्यापक रूप से कवर की गई है।

### Frida

[Frida](https://www.frida.re) developers, रिवर्स-इंजीनियरों, और security researchers के लिए एक dynamic instrumentation toolkit है.\
**आप रनिंग एप्लिकेशन तक access कर सकते हैं और runtime पर मेथड्स को hook करके behavior बदल सकते हैं, values बदल/extract कर सकते हैं, अलग कोड चला सकते हैं...**\
यदि आप Android applications पर pentest करना चाहते हैं तो आपको Frida का उपयोग करना आना चाहिए।

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Some "GUI" for actions with Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- You can find some Awesome Frida scripts here: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- anti-debugging / anti-frida mechanisms को bypass करने की कोशिश करें जैसे कि Frida को load करना जैसा कि यहाँ बताया गया है: [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

देखें कि क्या एप्लिकेशन memory के अंदर ऐसी संवेदनशील जानकारी स्टोर कर रहा है जो उसे नहीं करनी चाहिए, जैसे passwords या mnemonics।

Using [**Fridump3**](https://github.com/rootbsd/fridump3) you can dump the memory of the app with:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
यह मेमोरी को ./dump फ़ोल्डर में dump कर देगा, और वहाँ आप इस तरह grep कर सकते हैं:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Keystore में संवेदनशील डेटा**

Android में Keystore संवेदनशील डेटा स्टोर करने के लिए सबसे अच्छा स्थान है, हालांकि पर्याप्त privileges होने पर इसे फिर भी **पहुँच संभव है**। क्योंकि applications अक्सर यहाँ **sensitive data in clear text** स्टोर करती हैं, pentests को इसे root user के रूप में जांचना चाहिए — अन्यथा जिनके पास डिवाइस की physical access है वे यह डेटा चुरा सकते हैं।

भले ही कोई app keystore में data स्टोर करे, उस डेटा को encrypted होना चाहिए।

Keystore के अंदर के डेटा को access करने के लिए आप यह Frida script उपयोग कर सकते हैं: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

नीचे दिए गए Frida script का उपयोग करके संभव है कि Android applications द्वारा लागू की जा रही **bypass fingerprint authentication** को बाईपास किया जा सके, जो कि **कुछ संवेदनशील क्षेत्रों की सुरक्षा के लिए:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **पृष्ठभूमि छवियाँ**

जब आप किसी ऐप को बैकग्राउंड में भेजते हैं, Android उस ऐप का एक **snapshot** संग्रहीत करता है ताकि जब इसे foreground में वापस लाया जाए तो यह ऐप के शुरू होने से पहले उस image को लोड करना शुरू कर दे, जिससे ऐसा लगे कि ऐप तेज़ी से लोड हुआ।

हालाँकि, अगर यह snapshot किसी **संवेदनशील जानकारी** को रखता है, तो snapshot तक पहुँच रखने वाला कोई भी व्यक्ति वह जानकारी **चुरा** सकता है (ध्यान दें कि इसे एक्सेस करने के लिए root की आवश्यकता होती है)।

स्नैपशॉट आमतौर पर यहाँ संग्रहीत होते हैं: **`/data/system_ce/0/snapshots`**

Android एक तरीका प्रदान करता है जिससे **screenshot capture को रोकने के लिए `FLAG_SECURE` layout parameter सेट किया जा सकता है**। इस flag का उपयोग करने पर, विंडो की सामग्री को secure माना जाता है, जिससे यह screenshots में दिखाई नहीं देती और non-secure displays पर देखी नहीं जा सकती।
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

यह टूल dynamic analysis के दौरान विभिन्न tools को प्रबंधित करने में मदद कर सकता है: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

डेवलपर अक्सर activities, services, और broadcast receivers जैसे proxy components बनाते हैं जो इन Intents को handle करते हैं और उन्हें `startActivity(...)` या `sendBroadcast(...)` जैसे methods को पास कर देते हैं, जो जोखिम भरा हो सकता है।

खतरा इस बात से पैदा होता है कि attackers इन Intents को misdirect करके non-exported app components को trigger कर सकें या sensitive content providers तक access प्राप्त कर लें। एक प्रमुख उदाहरण `WebView` component है जो URLs को `Intent` objects में `Intent.parseUri(...)` के माध्यम से convert करता है और फिर उन्हें execute करता है, जिससे संभावित रूप से malicious Intent injections हो सकते हैं।

### Essential Takeaways

- **Intent Injection** वेब के Open Redirect issue के समान है।
- Exploits में `Intent` objects को extras के रूप में पास करना शामिल है, जिन्हें redirect करके असुरक्षित operations execute किए जा सकते हैं।
- यह non-exported components और content providers को attackers के लिए उजागर कर सकता है।
- `WebView` का URL से `Intent` में conversion अनचाहे actions को सक्षम कर सकता है।

### Android Client Side Injections and others

शायद आप Web से इस तरह की vulnerabilities के बारे में जानते होंगे। Android application में इन vulnerabilities के साथ विशेष सावधानी बरतनी चाहिए:

- **SQL Injection:** जब dynamic queries या Content-Providers के साथ काम कर रहे हों तो parameterized queries का उपयोग सुनिश्चित करें।
- **JavaScript Injection (XSS):** सुनिश्चित करें कि किसी भी WebViews के लिए JavaScript और Plugin support disabled हो (डिफ़ॉल्ट रूप से disabled)। [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews के लिए file system access disabled होना चाहिए (डिफ़ॉल्ट रूप से enabled) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: कई मामलों में जब android application session समाप्त करता है, cookie revoke नहीं की जाती या इसे disk पर भी save किया जा सकता है
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Static analysis**

![](<../../images/image (866).png>)

**Vulnerability assessment of the application** using a nice web-based frontend. You can also perform dynamic analysis (but you need to prepare the environment).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### MobSF के साथ सहायक Dynamic analysis

**MobSF** Android में **dynamic analysis** के लिए बहुत मददगार हो सकता है, लेकिन उस स्थिति में आपको अपने host पर MobSF और **genymotion** इंस्टॉल करना होगा (a **VM** या **Docker** काम नहीं करेगा)। _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
The **MobSF dynamic analyser** कर सकता है:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). यह सब ऑटोमैटिकली होता है सिवाय screenshots के — screenshots के लिए आपको जब चाहिए तब प्रेस करना होगा या सभी exported activities के screenshots पाने के लिए "**Exported Activity Tester**" प्रेस करना होगा।
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: यह सभी loaded classes प्रिंट करेगा
- **Capture Strings**: application इस्तेमाल करते समय यह सभी captured strings प्रिंट करेगा (बहुत noisy)
- **Capture String Comparisons**: बहुत उपयोगी हो सकता है। यह तुलना की जा रही 2 strings दिखाएगा और यह भी बताएगा कि परिणाम True था या False।
- **Enumerate Class Methods**: class नाम डालें (जैसे "java.io.File") और यह उस class के सभी methods प्रिंट करेगा।
- **Search Class Pattern**: पैटर्न से classes खोजें
- **Trace Class Methods**: किसी पूरे class को **Trace** करें (सभी methods के inputs और outputs देखें)। याद रखें कि default में MobSF कई दिलचस्प Android Api methods को trace करता है।

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf आपको dynamic analysis पेज के नीचे कुछ **adb** commands, **MobSF commands**, और सामान्य **shell** **commands** के साथ एक shell भी देता है। कुछ दिलचस्प commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP tools**

जब http ट्रैफिक कैप्चर होता है तो आप कैप्चर किए गए ट्रैफिक का एक ख़राब व्यू "**HTTP(S) Traffic**" बटन में देख सकते हैं या एक बेहतर व्यू "**Start HTTPTools**" हरे बटन में। दूसरे विकल्प से, आप **captured requests** को **proxies** जैसे Burp या Owasp ZAP पर **send** कर सकते हैं।\
ऐसा करने के लिए, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> press "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Once you finish the dynamic analysis with MobSF you can press on "**Start Web API Fuzzer**" to **fuzz http requests** an look for vulnerabilities.

> [!TIP]
> MobSF के साथ dynamic analysis करने के बाद proxy settings misconfigured हो सकती हैं और आप GUI से उन्हें ठीक नहीं कर पाएंगे। आप proxy settings को ठीक करने के लिए यह कर सकते हैं:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

You can get the tool from [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
यह tool कुछ **Hooks** का उपयोग करेगा ताकि आपको यह पता चल सके **what is happening in the application** जबकि आप **dynamic analysis** कर रहे हों।

### [Yaazhini](https://www.vegabird.com/yaazhini/)

यह **GUI के साथ static analysis करने के लिए एक शानदार tool है**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

यह tool कई प्रकार की **security related Android application vulnerabilities** खोजने के लिए डिज़ाइन किया गया है, चाहे वो **source code** में हों या **packaged APKs** में। यह tool **capable of creating a "Proof-of-Concept" deployable APK** और **ADB commands** भी बना सकता है, ताकि पाए गए कुछ vulnerabilities (Exposed activities, intents, tapjacking...) का exploit किया जा सके। Drozer की तरह, test device को root करने की जरूरत नहीं है।
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- आसान संदर्भ के लिए सभी निकाली गई फ़ाइलें प्रदर्शित करता है
- APK फ़ाइलों को Java और Smali फ़ॉर्मेट में स्वचालित रूप से decompile करता है
- AndroidManifest.xml को सामान्य कमजोरियों और व्यवहार के लिए विश्लेषण करता है
- सामान्य कमजोरियों और व्यवहार के लिए स्थैतिक स्रोत कोड का विश्लेषण करता है
- डिवाइस जानकारी प्रदर्शित करता है
- और भी बहुत कुछ
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER एक command-line application है जिसे Windows, MacOS X और Linux पर इस्तेमाल किया जा सकता है, जो _.apk_ फ़ाइलों में vulnerabilities की तलाश के लिए उनका विश्लेषण करता है। यह APKs को अनज़िप करके और vulnerabilities का पता लगाने के लिए rules की एक श्रृंखला लागू करके ऐसा करता है।

सभी rules एक `rules.json` फ़ाइल में केंद्रीकृत हैं, और प्रत्येक company या tester अपनी ज़रूरत के मुताबिक़ अपने rules बना सकते हैं।

नवीनतम binaries को [download page](https://superanalyzer.rocks/download.html) से डाउनलोड करें।
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn एक **crossplatform** टूल है जो डेवलपर्स, bugbounty hunters और ethical hackers को मोबाइल एप्लिकेशन्स पर [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) करने में मदद करता है।

कॉन्सेप्ट यह है कि आप अपनी मोबाइल एप्लिकेशन फ़ाइल (.apk या .ipa फ़ाइल) को StaCoAn एप्लिकेशन पर ड्रैग और ड्रॉप करेंगे और यह आपके लिए एक visual और portable रिपोर्ट जेनरेट करेगा। आप settings और wordlists को tweak करके एक customized अनुभव प्राप्त कर सकते हैं।

Download[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework एक Android vulnerability analysis system है जो डेवलपर्स या hackers को Android applications में संभावित security vulnerabilities खोजने में मदद करता है.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** एक tool है जिसका मुख्य उद्देश्य Android application द्वारा विकसित संभावित malicious behaviours का पता लगाना और उपयोगकर्ता को चेतावनी देना है।

डिटेक्शन एप्लिकेशन के Dalvik bytecode के **static analysis** के साथ किया जाता है, जो **Smali** के रूप में प्रस्तुत होता है, [`androguard`](https://github.com/androguard/androguard) लाइब्रेरी के साथ।

यह tool **common behavior of "bad" applications** जैसे निम्न चीज़ों की तलाश करता है: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. यह एक ऐसा टूल है जो commonly used mobile application reverse engineering और analysis tools को एक साथ लाता है, ताकि OWASP mobile security threats के खिलाफ mobile applications का परीक्षण करने में सहायता मिल सके। इसका उद्देश्य mobile application developers और security professionals के लिए यह कार्य आसान और अधिक user-friendly बनाना है।

It is able to:

- Extract Java and Smali code using different tools
- Analyze APKs using: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Extract private information from the APK using regexps.
- Analyze the Manifest.
- Analyze found domains using: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

malware का पता लगाने के लिए उपयोगी: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

ध्यान दें कि जिस service और configuration का आप उपयोग कर code को obfuscate करते हैं उसके अनुसार secrets obfuscated हो भी सकते हैं और नहीं भी।

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. यह bytecode को optimize करने के साथ-साथ unused instructions का पता लगा कर उन्हें हटाने में सक्षम है। ProGuard free software है और GNU General Public License, version 2 के तहत वितरित किया जाता है।

ProGuard Android SDK का हिस्सा के रूप में वितरित होता है और application को release mode में build करने पर चलता है।

### [DexGuard](https://www.guardsquare.com/dexguard)

Deobfuscate करने के लिए step-by-step guide देखें: [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) पिछली बार हमने चेक किया था, Dexguard का operation mode इस प्रकार था:

- किसी resource को InputStream के रूप में load करना;
- परिणाम को decrypt करने के लिए FilterInputStream से inherit करने वाली class को feed करना;
- reverser का कुछ समय बर्बाद करने के लिए कुछ बेकार obfuscation करना;
- decrypted result को ZipInputStream को feed करना ताकि DEX file मिल सके;
- अंत में resulting DEX को Resource के रूप में `loadDex` method का उपयोग कर load करना।

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

आप obfuscated APK को उनके platform पर upload कर सकते हैं।

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

यह एक generic android deobfuscator है। Simplify लगभग app को virtually execute करता है ताकि उसके behavior को समझा जा सके और फिर code को optimize करने की कोशिश करता है ताकि वह same तरीके से चले पर इंसान के लिए समझना आसान हो। हर optimization type सरल और generic है, इसलिए किस specific type की obfuscation use हुई है वह मायने नहीं रखता।

### [APKiD](https://github.com/rednaga/APKiD)

APKiD आपको यह जानकारी देता है कि **how an APK was made**. यह कई compilers, packers, obfuscators और अन्य अजीब चीज़ों की पहचान करता है। यह Android के लिए [_PEiD_](https://www.aldeid.com/wiki/PEiD) जैसा है।

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b एक Android security virtual machine है जो ubuntu-mate पर आधारित है और इसमें विभिन्न security geeks और researchers द्वारा बनाए गए latest frameworks, tutorials और labs का संग्रह शामिल है, जो reverse engineering और malware analysis के लिए उपयोगी हैं।

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) यह संसाधनों की एक शानदार सूची है
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
