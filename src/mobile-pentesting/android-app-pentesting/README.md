# Applicazioni Android Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Fondamenti delle Applicazioni Android

Si consiglia vivamente di iniziare leggendo questa pagina per conoscere le **parti più importanti relative alla sicurezza Android e i componenti più pericolosi in un'applicazione Android**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

This is the main tool you need to connect to an android device (emulated or physical).\
**ADB** permette di controllare i dispositivi sia tramite **USB** che **Network** da un computer. Questa utility abilita la **copia** di file in entrambe le direzioni, l'**installazione** e la **disinstallazione** di app, l'**esecuzione** di comandi shell, il **backup** dei dati, la **lettura** dei log, tra le altre funzioni.

Take a look to the following list of [**ADB Commands**](adb-commands.md) to learn how to use adb.

## Smali

Sometimes it is interesting to **modify the application code** to access **hidden information** (maybe well obfuscated passwords or flags). Then, it could be interesting to decompile the apk, modify the code and recompile it.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). This could be very useful as an **alternative for several tests during the dynamic analysis** that are going to presented. Then, **keep always in mid this possibility**.

## Other interesting tricks

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [Android IME / InputMethodService Abuse (Malicious Keyboards)](inputmethodservice-ime-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Estrai APK dal dispositivo:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Unisci tutti i splits e i base apks con [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Android Enterprise & Work Profile Attacks

{{#ref}}
android-enterprise-work-profile-bypass.md
{{#endref}}

## Case Studies & Vulnerabilities


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

{{#ref}}
abusing-android-media-pipelines-image-parsers.md
{{#endref}}

{{#ref}}
../../binary-exploitation/linux-kernel-exploitation/arm64-static-linear-map-kaslr-bypass.md
{{#endref}}

## Static Analysis

Prima di tutto, per analizzare un APK dovresti **dare un'occhiata al codice Java** usando un decompiler.\
Please, [**read here to find information about different available decompilers**](apk-decompilers.md).

### Looking for interesting Info

Bastano poche osservazioni alle **strings** dell'APK per cercare **password**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** e qualsiasi cosa interessante... cerca anche eventuali code execution **backdoors** o authentication backdoors (hardcoded admin credentials to the app).

**Firebase**

Presta particolare attenzione alle URL di **Firebase** e verifica se è mal configurato. [More information about whats is FIrebase and how to exploit it here.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Basic understanding of the application - Manifest.xml, strings.xml

L'**esame di un'applicazione _Manifest.xml_ e **_strings.xml_** file può rivelare potenziali vulnerabilità di sicurezza**. Questi file possono essere ottenuti usando decompiler o rinominando l'estensione dell'APK in .zip e poi decomprimendolo.

**Vulnerabilities** identificate dal **Manifest.xml** includono:

- **Debuggable Applications**: Applicazioni impostate come debuggable (`debuggable="true"`) nel file _Manifest.xml_ rappresentano un rischio poiché permettono connessioni che possono portare a exploit. Per capire meglio come sfruttare applicazioni debuggable, consulta un tutorial su come trovare e sfruttare applicazioni debuggable su un dispositivo.
- **Backup Settings**: L'attributo `android:allowBackup="false"` dovrebbe essere impostato esplicitamente per le applicazioni che trattano informazioni sensibili per prevenire backup non autorizzati dei dati via adb, specialmente quando usb debugging è abilitato.
- **Network Security**: Le configurazioni di network security personalizzate (`android:networkSecurityConfig="@xml/network_security_config"`) in _res/xml/_ possono specificare dettagli di sicurezza come certificate pins e impostazioni del traffico HTTP. Un esempio è consentire traffico HTTP per domini specifici.
- **Exported Activities and Services**: Identificare attività e servizi esportati nel manifest può mettere in evidenza componenti che potrebbero essere abusati. Un'analisi dinamica può rivelare come sfruttare questi componenti.
- **Content Providers and FileProviders**: Content provider esposti potrebbero permettere accessi o modifiche non autorizzate ai dati. Anche la configurazione dei FileProviders dovrebbe essere esaminata attentamente.
- **Broadcast Receivers and URL Schemes**: Questi componenti potrebbero essere sfruttati per exploit, con particolare attenzione a come gli schemi URL gestiscono l'input per eventuali vulnerabilità.
- **SDK Versions**: Gli attributi `minSdkVersion`, `targetSDKVersion`, e `maxSdkVersion` indicano le versioni Android supportate, sottolineando l'importanza di non supportare versioni Android obsolete e vulnerabili per motivi di sicurezza.

Dal file **strings.xml** è possibile scovare informazioni sensibili come API keys, schemi custom e altre note degli sviluppatori, il che rende necessaria una revisione accurata di queste risorse.

### Tapjacking

**Tapjacking** è un attacco in cui una **malicious** **application** viene lanciata e **si posiziona sopra un'app vittima**. Una volta che oscura visivamente l'app vittima, la sua interfaccia utente è progettata in modo da ingannare l'utente inducendolo ad interagire con essa, mentre inoltra l'interazione all'app vittima.\
In pratica, **ci si impedisce all'utente di sapere che sta effettivamente compiendo azioni sull'app vittima**.

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Un'**activity** con il `launchMode` impostato su **`singleTask` senza alcun `taskAffinity`** definito è vulnerabile al Task Hijacking. Questo significa che un'**application** può essere installata e, se lanciata prima della vera applicazione, potrebbe **hijackare il task della reale applicazione** (quindi l'utente interagirà con la **malicious application pensando di usare quella reale**).

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Insecure data storage

**Internal Storage**

In Android, i file **salvati** nello **storage interno** sono **progettati** per essere **accessibili** esclusivamente dall'**app** che li **ha creati**. Questa misura di sicurezza è **enforced** dal sistema operativo Android ed è generalmente adeguata per le esigenze di sicurezza della maggior parte delle applicazioni. Tuttavia, gli sviluppatori a volte utilizzano modalità come `MODE_WORLD_READABLE` e `MODE_WORLD_WRITABLE` per **permettere** la condivisione di file tra diverse applicazioni. Queste modalità **non limitano l'accesso** a tali file da parte di altre applicazioni, incluse quelle potenzialmente malevole.

1. **Static Analysis:**
- **Verifica** attentamente l'uso di `MODE_WORLD_READABLE` e `MODE_WORLD_WRITABLE`. Queste modalità **possono esporre** i file ad accessi non intenzionali o non autorizzati.
2. **Dynamic Analysis:**
- **Controlla** i permessi impostati sui file creati dall'app. Nello specifico, **verifica** se qualche file è impostato come leggibile o scrivibile da tutti. Questo può rappresentare un rischio significativo perché permetterebbe a **qualsiasi application** installata sul dispositivo, indipendentemente dalla sua origine o intento, di **leggere o modificare** questi file.

**External Storage**

Quando si gestiscono file su **external storage**, come SD Card, vanno prese alcune precauzioni:

1. **Accessibility**:
- I file su external storage sono **globalmente leggibili e scrivibili**. Questo significa che qualsiasi application o utente può accedere a questi file.
2. **Security Concerns**:
- Data la facilità di accesso, è consigliabile **non memorizzare informazioni sensibili** su external storage.
- L'external storage può essere rimosso o accessibile da qualsiasi application, rendendolo meno sicuro.
3. **Handling Data from External Storage**:
- Esegui sempre una **validazione dell'input** sui dati recuperati da external storage. Questo è cruciale perché i dati provengono da una fonte non affidabile.
- Evita di memorizzare eseguibili o file di class su external storage per il caricamento dinamico.
- Se la tua applicazione deve recuperare file eseguibili da external storage, assicurati che questi file siano **signed and cryptographically verified** prima che vengano caricati dinamicamente. Questo passaggio è vitale per mantenere l'integrità di sicurezza della tua applicazione.

External storage può essere **accessed** in `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> Starting with Android 4.4 (**API 17**), the SD card has a directory structure which **limits access from an app to the directory which is specifically for that app**. This prevents malicious application from gaining read or write access to another app's files.

**Sensitive data stored in clear-text**

- **Shared preferences**: Android permette a ogni application di salvare facilmente file xml nel percorso `/data/data/<packagename>/shared_prefs/` e a volte è possibile trovare informazioni sensibili in chiaro in quella cartella.
- **Databases**: Android permette a ogni application di salvare facilmente database sqlite nel percorso `/data/data/<packagename>/databases/` e a volte è possibile trovare informazioni sensibili in chiaro in quella cartella.

### Broken TLS

**Accept All Certificates**

Per qualche motivo a volte gli sviluppatori accettano tutti i certificati anche se, ad esempio, l'hostname non corrisponde, con righe di codice come la seguente:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Un buon modo per testare questo è provare a catturare il traffico usando un proxy come Burp senza autorizzare Burp CA all'interno del dispositivo. Inoltre, puoi generare con Burp un certificato per un nome host diverso e usarlo.

### Criptografia debole

**Processi di gestione delle chiavi inadeguati**

Alcuni sviluppatori salvano dati sensibili nello storage locale e li criptano con una chiave hardcoded/predicibile nel codice. Questo non dovrebbe essere fatto in quanto il reversing potrebbe permettere ad attaccanti di estrarre le informazioni confidenziali.

**Uso di algoritmi insicuri e/o deprecati**

Gli sviluppatori non dovrebbero usare **algoritmi deprecati** per eseguire controlli di autorizzazione, **memorizzare** o **inviare** dati. Alcuni di questi algoritmi sono: RC4, MD4, MD5, SHA1... Se vengono usati **hash** per memorizzare password, per esempio, dovrebbero essere usati hash resistenti al brute-force con salt.

### Altri controlli

- Si raccomanda di **offuscare l'APK** per rendere più difficile il lavoro di reverse engineering agli attaccanti.
- Se l'app è sensibile (es. app bancarie), dovrebbe eseguire i propri **controlli per verificare se il dispositivo è rooted** e agire di conseguenza.
- Se l'app è sensibile (es. app bancarie), dovrebbe verificare se è in esecuzione su un **emulator**.
- Se l'app è sensibile (es. app bancarie), dovrebbe **verificare la propria integrità prima di eseguirla** per controllare se è stata modificata.
- Usa [**APKiD**](https://github.com/rednaga/APKiD) per verificare quale compiler/packer/obfuscator è stato usato per costruire l'APK

### Applicazioni React Native

Leggi la seguente pagina per imparare come accedere facilmente al codice javascript delle applicazioni React:


{{#ref}}
react-native-application.md
{{#endref}}

### Applicazioni Xamarin

Leggi la seguente pagina per imparare come accedere facilmente al codice C# di applicazioni Xamarin:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Applicazioni Superpacked

Secondo questo [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked è un algoritmo Meta che comprime il contenuto di un'applicazione in un unico file. Il blog parla della possibilità di creare un'app che decomprime questo tipo di app... e di un metodo più veloce che comporta **l'esecuzione dell'applicazione e la raccolta dei file decompressi dal filesystem.**

### Analisi statica del codice automatizzata

Lo strumento [**mariana-trench**](https://github.com/facebook/mariana-trench) è in grado di trovare **vulnerabilità** scansionando il **codice** dell'applicazione. Questo strumento contiene una serie di **known sources** (che indicano allo strumento i **luoghi** in cui l'**input** è **controllato dall'utente**), **sinks** (che indicano allo strumento i **punti** **pericolosi** dove un input malevolo dell'utente potrebbe causare danni) e **rules**. Queste regole indicano la **combinazione** di **sources-sinks** che segnala una vulnerabilità.

Con queste informazioni, **mariana-trench rivedrà il codice e troverà possibili vulnerabilità**.

### Secrets leaked

Un'applicazione può contenere secrets (API keys, passwords, hidden urls, subdomains...) al suo interno che potresti essere in grado di scoprire. Puoi usare uno strumento come [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass dell'autenticazione biometrica


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Altre funzioni interessanti

- **Esecuzione di codice**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Invio SMS**: `sendTextMessage, sendMultipartTestMessage`
- **Funzioni native** dichiarate come `native`: `public native, System.loadLibrary, System.load`
- [Leggi questo per imparare **come fare reverse delle funzioni native**](reversing-native-libraries.md)
- Esecuzione in-memory di codice nativo via JNI (shellcode scaricato → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Altri trucchi**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Analisi dinamica

> Innanzitutto, hai bisogno di un ambiente dove puoi installare l'applicazione e tutto l'ambiente (Burp CA cert, Drozer e Frida principalmente). Pertanto, un dispositivo rooted (emulato o meno) è altamente raccomandato.

### Analisi dinamica online

Puoi creare un **account gratuito** su: [https://appetize.io/](https://appetize.io). Questa piattaforma ti permette di **caricare** ed **eseguire** APK, quindi è utile per vedere come si comporta un apk.

Puoi persino **vedere i log della tua applicazione** sul web e connetterti tramite **adb**.

![](<../../images/image (831).png>)

Grazie alla connessione ADB puoi usare **Drozer** e **Frida** all'interno degli emulatori.

### Analisi dinamica locale

#### Usare un emulatore

- [**Android Studio**](https://developer.android.com/studio) (Puoi creare dispositivi **x86** e **arm**, e secondo [**this**](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html) le **ultime versioni x86** **supportano le librerie ARM** senza necessità di un emulatore arm lento).
- Impara a configurarlo in questa pagina:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Versione gratuita:** Personal Edition, è necessario creare un account. _Si raccomanda di **scaricare** la versione **CON**_ _**VirtualBox** per evitare potenziali errori._)
- [**Nox**](https://es.bignox.com) (Gratuito, ma non supporta Frida o Drozer).

> [!TIP]
> Quando crei un nuovo emulatore su qualsiasi piattaforma ricordati che più grande è lo schermo, più lento sarà l'emulatore. Quindi scegli schermi piccoli se possibile.

Per **installare i servizi Google** (come AppStore) in Genymotion devi cliccare il pulsante evidenziato in rosso nell'immagine seguente:

![](<../../images/image (277).png>)

Inoltre, nota che nella **configurazione della VM Android in Genymotion** puoi selezionare la modalità **Bridge Network** (utile se ti connetterai alla VM Android da un'altra VM con gli strumenti).

#### Usare un dispositivo fisico

Devi attivare le opzioni di **debugging** e sarebbe utile se potessi **rootarlo**:

1. **Settings**.
2. (Da Android 8.0) Seleziona **System**.
3. Seleziona **About phone**.
4. Premi **Build number** 7 volte.
5. Torna indietro e troverai le **Developer options**.

> Una volta installata l'applicazione, la prima cosa da fare è provarla, investigare cosa fa, come funziona e prendere confidenza con essa.\
> Suggerisco di **eseguire questa analisi dinamica iniziale usando MobSF dynamic analysis + pidcat**, così saremo in grado di **capire come funziona l'applicazione** mentre MobSF **cattura** molti **dati** **interessanti** che potrai rivedere in seguito.

Magisk/Zygisk quick notes (recommended on Pixel devices)
- Patchare boot.img con l'app Magisk e flashare via fastboot per ottenere systemless root
- Abilitare Zygisk + DenyList per nascondere il root; considerare LSPosed/Shamiko quando è richiesto un hiding più forte
- Conservare il boot.img originale per recuperare dopo OTA; ri-patchare dopo ogni OTA
- Per il mirroring dello schermo, usa scrcpy sull'host



### Perdita involontaria di dati

**Logging**

Gli sviluppatori dovrebbero essere cauti nell'esporre pubblicamente informazioni di **debugging**, poiché possono portare a leak di dati sensibili. Gli strumenti [**pidcat**](https://github.com/JakeWharton/pidcat) e `adb logcat` sono consigliati per monitorare i log dell'applicazione e identificare e proteggere informazioni sensibili. **Pidcat** è preferito per la sua semplicità d'uso e leggibilità.

> [!WARNING]
> Nota che da **versioni successive ad Android 4.0**, **le applicazioni possono accedere solo ai propri log**. Quindi le applicazioni non possono accedere ai log di altre app.\
> In ogni caso, è comunque consigliato **non loggare informazioni sensibili**.

**Cache del buffer Copia/Incolla**

Il framework **clipboard-based** di Android abilita la funzionalità copia-incolla nelle app, ma rappresenta un rischio poiché **altre applicazioni** possono **accedere** agli appunti, esponendo potenzialmente dati sensibili. È cruciale **disabilitare le funzioni di copia/incolla** per sezioni sensibili di un'applicazione, come i dettagli della carta di credito, per prevenire data leaks.

**Crash Logs**

Se un'applicazione **crasha** e **salva log**, questi log possono aiutare gli attaccanti, in particolare quando l'applicazione non può essere reverse-engineered. Per mitigare questo rischio, evitare di loggare durante i crash, e se i log devono essere trasmessi via rete, assicurarsi che siano inviati tramite un canale SSL per sicurezza.

Come pentester, **prova a dare un'occhiata a questi log**.

**Analytics Data Sent To 3rd Parties**

Le applicazioni spesso integrano servizi come Google Adsense, che possono involontariamente causare leak di dati sensibili a causa di implementazioni errate da parte degli sviluppatori. Per identificare potenziali leak, è consigliabile intercettare il traffico dell'applicazione e verificare se informazioni sensibili vengono inviate a servizi di terze parti.

### SQLite DBs

La maggior parte delle applicazioni utilizzerà **database SQLite interni** per salvare informazioni. Durante il pentest dai **un'occhiata** ai **database** creati, ai nomi delle **tabelle** e delle **colonne** e a tutti i **dati** salvati perché potresti trovare **informazioni sensibili** (che sarebbero una vulnerabilità).\
I database dovrebbero trovarsi in `/data/data/the.package.name/databases` come `/data/data/com.mwr.example.sieve/databases`

Se il database salva informazioni confidenziali ed è **criptato** ma puoi **trovare** la **password** all'interno dell'applicazione, è comunque una **vulnerabilità**.

Enumera le tabelle usando `.tables` ed enumera le colonne delle tabelle con `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

Dai [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** permette di **assumere il ruolo di un'app Android** e interagire con altre app. Può fare **qualsiasi cosa che un'app installata può fare**, come utilizzare il meccanismo di Inter-Process Communication (IPC) di Android e interagire con il sistema operativo sottostante. \
Drozer è uno strumento utile per **sfruttare exported activities, exported services e Content Providers** come imparerai nelle sezioni seguenti.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Ricorda anche che il codice di un'activity inizia nel metodo **`onCreate`**.

**Authorisation bypass**

Quando un'Activity è esportata puoi invocare la sua schermata da un'app esterna. Pertanto, se un'activity con **informazioni sensibili** è **esportata** potresti **bypassare** i meccanismi di **autenticazione** per **accedervi.**

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

Puoi anche avviare un'activity esportata tramite adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> Nota che un authorisation bypass non è sempre una vulnerability: dipende da come funziona il bypass e quali informazioni vengono esposte.

**Perdita di informazioni sensibili**

**Activities can also return results**. If you manage to find an exported and unprotected activity calling the **`setResult`** method and **returning sensitive information**, there is a perdita di informazioni sensibili.

#### Tapjacking

If Tapjacking isn't prevented, you could abuse the exported activity to make the **user perform unexpected actions**. For more info about [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers are basically used to **share data**. If an app has available content providers you may be able to **extract sensitive** data from them. It’s also interesting to test possible **SQL injections** and **Path Traversals** as they could be vulnerable.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Ricorda che le azioni di un Service iniziano nel metodo `onStartCommand`.

A service is basically something that **can receive data**, **process** it and **returns** (or not) a response. Then, if an application is exporting some services you should **check** the **code** to understand what it is doing and **test** it **dynamically** to extract informazioni riservate, eludere le misure di autenticazione...
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Ricorda che le azioni di un Broadcast Receiver iniziano nel metodo `onReceive`.

A broadcast receiver will be waiting for a type of message. Depending on how the receiver handles the message it could be vulnerable.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

You can look for deep links manually, using tools like MobSF or scripts like [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
You can **open** a declared **scheme** using **adb** or a **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Nota che puoi **omettere il nome del pacchetto** e il dispositivo mobile chiamerà automaticamente l'app che dovrebbe aprire quel link._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Codice eseguito**

Per trovare il **codice che sarà eseguito nell'App**, vai all'activity chiamata dal deeplink e cerca la funzione **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Informazioni sensibili**

Ogni volta che trovi un deep link verifica che **non stia ricevendo dati sensibili (come password) tramite parametri URL**, perché qualsiasi altra applicazione potrebbe **impersonate the deep link and steal that data!**

**Parametri nel path**

Devi anche verificare se un deep link sta usando un parametro all'interno del path dell'URL come: `https://api.example.com/v1/users/{username}` , in tal caso puoi forzare un path traversal accedendo a qualcosa come: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Nota che se trovi gli endpoint corretti all'interno dell'applicazione potresti riuscire a causare un **Open Redirect** (se parte del path è usata come domain name), **account takeover** (se puoi modificare i dettagli degli utenti senza token CSRF e l'endpoint vuln usa il metodo corretto) e qualsiasi altra vuln. Ulteriori [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Transport Layer Inspection and Verification Failures

- **I certificati non vengono sempre ispezionati correttamente** dalle applicazioni Android. È comune che queste applicazioni ignorino gli avvisi e accettino certificati self-signed o, in alcuni casi, tornino a usare connessioni HTTP.
- **Le negoziazioni durante il handshake SSL/TLS sono talvolta deboli**, impiegando cipher suites insecure. Questa vulnerabilità rende la connessione suscettibile ad attacchi man-in-the-middle (MITM), permettendo agli attaccanti di decrittare i dati.
- **Perdita di informazioni private** è un rischio quando le applicazioni si autenticano usando canali sicuri ma poi comunicano su canali non sicuri per altre transazioni. Questo approccio non protegge i dati sensibili, come session cookies o dettagli utente, dall'intercettazione da parte di entità malevole.

#### Certificate Verification

Ci concentreremo sulla **verifica dei certificati**. L'integrità del certificato del server deve essere verificata per aumentare la sicurezza. Questo è cruciale perché configurazioni TLS insicure e la trasmissione di dati sensibili su canali non cifrati possono comportare rischi significativi. Per passi dettagliati sulla verifica dei certificati server e sulla risoluzione delle vulnerabilità, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) fornisce una guida completa.

#### SSL Pinning

SSL Pinning è una misura di sicurezza in cui l'app verifica il certificato del server rispetto a una copia nota memorizzata all'interno dell'app stessa. Questo metodo è essenziale per prevenire attacchi MITM. Implementare SSL Pinning è fortemente raccomandato per applicazioni che trattano informazioni sensibili.

#### Traffic Inspection

Per ispezionare il traffico HTTP è necessario installare il certificato dello strumento proxy (es. Burp). Senza installare questo certificato, il traffico cifrato potrebbe non essere visibile tramite il proxy. Per una guida sull'installazione di un certificato CA personalizzato, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Le applicazioni targettizzate a **API Level 24 and above** richiedono modifiche al Network Security Config per accettare il certificato CA del proxy. Questo passaggio è critico per ispezionare il traffico cifrato. Per istruzioni su come modificare il Network Security Config, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

Se viene usato **Flutter** devi seguire le istruzioni in [**this page**](flutter.md). Questo perché aggiungere semplicemente il certificato nello store non funzionerà, dato che Flutter ha la propria lista di CA valide.

#### Static detection of SSL/TLS pinning

Prima di tentare bypass runtime, mappa rapidamente dove il pinning è applicato nell'APK. La scoperta statica ti aiuta a pianificare hook/patch e a concentrarti sui percorsi di codice giusti.

Tool: SSLPinDetect
- Open-source static-analysis utility that decompiles the APK to Smali (via apktool) and scans for curated regex patterns of SSL/TLS pinning implementations.
- Reports exact file path, line number, and a code snippet for each match.
- Covers common frameworks and custom code paths: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

Installazione
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Uso
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Esempio di pattern rules (JSON)
Usa o estendi le signatures per rilevare stili di pinning proprietari/personalizzati. Puoi caricare il tuo JSON e fare scan su larga scala.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Note e consigli
- Scansione rapida su app di grandi dimensioni tramite multi-threading e I/O mappata in memoria; regex precompilate riducono l'overhead/falsi positivi.
- Raccolta di pattern: https://github.com/aancw/smali-sslpin-patterns
- Obiettivi tipici da esaminare successivamente:
- OkHttp: uso di CertificatePinner, setCertificatePinner, riferimenti ai package okhttp3/okhttp
- TrustManager personalizzati: javax.net.ssl.X509TrustManager, override di checkServerTrusted
- Contesti SSL personalizzati: SSLContext.getInstance + SSLContext.init con manager personalizzati
- Pin dichiarativi in res/xml network security config e riferimenti nel manifest
- Usa le posizioni corrispondenti per pianificare Frida hooks, patch statiche o revisioni di configurazione prima dei test dinamici.



#### Bypassing SSL Pinning

When SSL Pinning is implemented, bypassing it becomes necessary to inspect HTTPS traffic. Various methods are available for this purpose:

- Automatically **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). The best pro of this option, is that you won't need root to bypass the SSL Pinning, but you will need to delete the application and reinstall the new one, and this won't always work.
- You could use **Frida** (discussed below) to bypass this protection. Here you have a guide to use Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- You can also try to **automatically bypass SSL Pinning** using [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- You can also try to **automatically bypass SSL Pinning** using **MobSF dynamic analysis** (explained below)
- If you still think that there is some traffic that you aren't capturing you can try to **forward the traffic to burp using iptables**. Read this blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Ricerca di vulnerabilità web comuni

È importante cercare anche vulnerabilità web comuni all'interno dell'applicazione. Informazioni dettagliate sull'identificazione e la mitigazione di queste vulnerabilità sono oltre lo scopo di questo sommario ma sono trattate estensivamente altrove.

### Frida

[Frida](https://www.frida.re) è un toolkit di instrumentazione dinamica per sviluppatori, reverse-engineer e ricercatori della sicurezza.\
**Puoi accedere all'applicazione in esecuzione e hookare i metodi a runtime per cambiare il comportamento, modificare valori, estrarre valori, eseguire codice diverso...**\
Se vuoi pentestare applicazioni Android devi sapere come usare Frida.

- Impara a usare Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Alcune "GUI" per interagire con Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection è ottimo per automatizzare l'uso di Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Puoi trovare alcuni Awesome Frida scripts qui: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Prova a bypassare meccanismi anti-debugging / anti-frida caricando Frida come indicato in [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

Verifica se l'applicazione sta memorizzando informazioni sensibili nella memoria che non dovrebbe memorizzare, come password o mnemoniche.

Using [**Fridump3**](https://github.com/rootbsd/fridump3) you can dump the memory of the app with:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Questo effettuerà un dump della memoria nella cartella ./dump, e lì potresti usare grep con qualcosa del genere:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Dati sensibili in Keystore**

Su Android il Keystore è il posto migliore per memorizzare dati sensibili; tuttavia, con privilegi sufficienti è comunque possibile accedervi. Poiché le applicazioni tendono a memorizzare qui dati sensibili in clear text, i pentests dovrebbero verificarne la presenza, dato che un utente root o qualcuno con accesso fisico al dispositivo potrebbe rubare questi dati.

Anche se un'app memorizza dati nel keystore, i dati dovrebbero essere crittografati.

Per accedere ai dati all'interno del keystore puoi usare questo Frida script: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Usando il seguente script Frida, potrebbe essere possibile effettuare un **bypass fingerprint authentication** che le applicazioni Android potrebbero utilizzare per **proteggere determinate aree sensibili:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Immagini di sfondo**

Quando metti un'applicazione in background, Android memorizza una **istantanea dell'applicazione** così quando viene riportata in primo piano inizia a caricare l'immagine prima dell'app, così sembra che l'app sia stata caricata più velocemente.

Tuttavia, se questa istantanea contiene **informazioni sensibili**, qualcuno con accesso all'istantanea potrebbe **rubare quelle informazioni** (nota che è necessario avere i privilegi di root per accedervi).

Le istantanee sono solitamente memorizzate in: **`/data/system_ce/0/snapshots`**

Android fornisce un modo per **impedire la cattura di screenshot impostando il parametro di layout FLAG_SECURE**. Usando questo flag, il contenuto della finestra viene trattato come sicuro, impedendone l'apparizione negli screenshot o la visualizzazione su display non sicuri.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Analizzatore di applicazioni Android**

Questo strumento può aiutarti a gestire diversi strumenti durante l'analisi dinamica: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Gli sviluppatori spesso creano componenti proxy come activities, services e broadcast receivers che gestiscono questi Intent e li passano a metodi come `startActivity(...)` o `sendBroadcast(...)`, il che può essere rischioso.

Il pericolo risiede nel permettere agli attacker di innescare componenti dell'app non-exported o accedere a content providers sensibili reindirizzando questi Intent. Un esempio rilevante è il componente `WebView` che converte gli URL in oggetti `Intent` tramite `Intent.parseUri(...)` e poi li esegue, potenzialmente portando a malicious Intent injections.

### Punti essenziali

- **Intent Injection** è simile al problema web di Open Redirect.
- Gli exploit comportano il passaggio di oggetti `Intent` come extras, che possono essere reindirizzati per eseguire operazioni non sicure.
- Può esporre componenti non-exported e content providers agli attacker.
- La conversione degli URL in `Intent` da parte di WebView può facilitare azioni non intenzionate.

### Iniezioni lato client Android e altro

Probabilmente conosci questo tipo di vulnerabilità dal Web. Devi prestare particolare attenzione a queste vulnerabilità in un'app Android:

- **SQL Injection:** Quando gestisci query dinamiche o Content-Providers assicurati di usare query parametrizzate.
- **JavaScript Injection (XSS):** Verifica che il supporto a JavaScript e Plugin sia disabilitato per qualsiasi WebView (disabilitato di default). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** Le WebView dovrebbero avere l'accesso al file system disabilitato (abilitato di default) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Cookie persistenti:** In diversi casi, quando l'app Android termina la sessione il cookie non viene revocato oppure può essere salvato su disco.
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Analisi automatica

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Analisi statica**

![](<../../images/image (866).png>)

**Valutazione delle vulnerabilità dell'applicazione** usando una comoda interfaccia web. Puoi anche eseguire analisi dinamiche (ma devi preparare l'ambiente).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Nota che MobSF può analizzare **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Inoltre, se crei un file **ZIP** con il codice sorgente di un'app **Android** o **IOS** (vai nella cartella root dell'applicazione, seleziona tutto e crea un ZIPfile), sarà in grado di analizzarlo comunque.

MobSF permette anche di fare **diff/Compare** delle analisi e di integrare **VirusTotal** (dovrai impostare la tua API key in _MobSF/settings.py_ e abilitarla: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). Puoi anche impostare `VT_UPLOAD` a `False`, in quel caso l'**hash** verrà **upload** invece del file.

### Analisi dinamica assistita con MobSF

MobSF può essere molto utile anche per l'analisi dinamica su **Android**, ma in quel caso dovrai installare MobSF e **genymotion** sull'host (una VM o Docker non funzioneranno). _Nota: Devi **avviare prima una VM in genymotion** e **poi MobSF.**_\
Il dynamic analyser di MobSF può:

- **Dump application data** (URLs, logs, clipboard, screenshot fatti da te, screenshot fatti da "**Exported Activity Tester**", email, database SQLite, file XML e altri file creati). Tutto questo viene fatto automaticamente tranne per gli screenshot: devi premere quando vuoi uno screenshot oppure devi premere "**Exported Activity Tester**" per ottenere screenshot di tutte le attività esportate.
- Catturare il traffico **HTTPS**
- Usare **Frida** per ottenere informazioni di **runtime**

Dalle versioni Android > 5, verrà **avviato automaticamente Frida** e verranno impostate le impostazioni globali di **proxy** per **catturare** il traffico. Catturerà solo il traffico dell'applicazione testata.

**Frida**

Per default, userà anche alcuni Frida Scripts per bypassare **SSL pinning**, **root detection** e **debugger detection** e per **monitorare API interessanti**.\
MobSF può anche **invocare exported activities**, catturare **screenshots** di esse e **salvarli** per il report.

Per **avviare** il testing dinamico premi il bottone verde: "**Start Instrumentation**". Premi "**Frida Live Logs**" per vedere i log generati dagli script Frida e "**Live API Monitor**" per vedere tutte le invocazioni ai metodi hookati, gli argomenti passati e i valori ritornati (questo apparirà dopo aver premuto "Start Instrumentation").\
MobSF ti permette anche di caricare i tuoi **Frida scripts** (per inviare i risultati dei tuoi Frida scripts a MobSF usa la funzione `send()`). Ha inoltre **diversi script pre-scritti** che puoi caricare (puoi aggiungerne altri in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), basta **selezionarli**, premere "**Load**" e poi "**Start Instrumentation**" (potrai vedere i log di quegli script dentro "**Frida Live Logs**").

![](<../../images/image (419).png>)

Inoltre, hai alcune funzionalità ausiliarie di Frida:

- **Enumerate Loaded Classes**: stamperà tutte le classi caricate
- **Capture Strings**: stamperà tutte le stringhe catturate durante l'uso dell'applicazione (molto rumoroso)
- **Capture String Comparisons**: può essere molto utile. Mostrerà le 2 stringhe messe a confronto e se il risultato è stato True o False.
- **Enumerate Class Methods**: inserisci il nome della classe (es. "java.io.File") e stamperà tutti i metodi della classe.
- **Search Class Pattern**: cerca classi per pattern
- **Trace Class Methods**: **Trace** di una **intera classe** (vedi input e output di tutti i metodi della classe). Ricorda che di default MobSF traccia diversi metodi Android interessanti.

Una volta selezionato il modulo ausiliario che vuoi usare devi premere "**Start Intrumentation**" e vedrai tutti gli output in "**Frida Live Logs**".

**Shell**

MobSF porta anche una shell con alcuni comandi **adb**, comandi **MobSF**, e comandi comuni di **shell** nella parte bassa della pagina di analisi dinamica. Alcuni comandi interessanti:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**Strumenti HTTP**

Quando il traffico http viene catturato puoi vedere una vista brutta del traffico catturato nel pulsante "**HTTP(S) Traffic**" in basso o una vista più pulita nel pulsante verde "**Start HTTPTools**". Dalla seconda opzione, puoi **inviare** le **richieste catturate** a **proxies** come Burp o Owasp ZAP.\
Per farlo, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> premi "**Send to Fuzzer**" --> _seleziona l'indirizzo del proxy_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Una volta terminata l'analisi dinamica con MobSF puoi premere "**Start Web API Fuzzer**" per **fuzz http requests** e cercare vulnerabilità.

> [!TIP]
> Dopo aver eseguito un'analisi dinamica con MobSF le impostazioni del proxy potrebbero essere mal configurate e potresti non essere in grado di correggerle dalla GUI. Puoi sistemare le impostazioni del proxy eseguendo:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Analisi dinamica assistita con Inspeckage

Puoi ottenere lo strumento da [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Questo strumento utilizza alcuni **Hooks** per farti sapere **cosa sta succedendo nell'applicazione** mentre esegui un'**analisi dinamica**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Questo è un **ottimo tool per eseguire static analysis con una GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Questo tool è progettato per cercare diverse **vulnerabilità di sicurezza relative alle applicazioni Android**, sia nel **source code** sia negli **packaged APKs**. Il tool è anche **capace di creare un "Proof-of-Concept" deployable APK** e **ADB commands**, per sfruttare alcune delle vulnerabilità trovate (Exposed activities, intents, tapjacking...). Come con Drozer, non è necessario rootare il device di test.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Mostra tutti i file estratti per un facile riferimento
- Decompila automaticamente file APK in formato Java e Smali
- Analizza AndroidManifest.xml per vulnerabilità e comportamenti comuni
- Analisi statica del codice sorgente per vulnerabilità e comportamenti comuni
- Informazioni sul dispositivo
- e altro ancora
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER è un'applicazione da riga di comando utilizzabile su Windows, MacOS X e Linux, che analizza i file _.apk_ alla ricerca di vulnerabilità. Lo fa decomprimendo gli APK e applicando una serie di regole per rilevare queste vulnerabilità.

Tutte le regole sono contenute in un file `rules.json`, e ogni azienda o tester può creare regole proprie per analizzare ciò di cui ha bisogno.

Scarica i binari più recenti dalla [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn è uno strumento **crossplatform** che aiuta gli sviluppatori, bugbounty hunters e ethical hackers nello svolgimento di [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) su applicazioni mobile.

Il concetto è che trascini e rilasci il file della tua applicazione mobile (un file .apk o .ipa) sull'applicazione StaCoAn e genererà per te un report visuale e portatile. Puoi modificare le impostazioni e le wordlists per ottenere un'esperienza personalizzata.

Scarica[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework è un sistema di analisi delle vulnerabilità per Android che aiuta gli sviluppatori o hackers a trovare potenziali vulnerabilità di sicurezza nelle applicazioni Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** è uno strumento il cui scopo principale è rilevare e avvisare l'utente riguardo potenziali comportamenti malevoli sviluppati da un'applicazione Android.

La rilevazione viene eseguita tramite la **static analysis** del bytecode Dalvik dell'applicazione, rappresentato come **Smali**, con la libreria [`androguard`](https://github.com/androguard/androguard).

Questo strumento cerca **comportamenti comuni di applicazioni "cattive"** come: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** è un framework per Mobile Application Reverse engineering and Analysis. È uno strumento che mette insieme strumenti comunemente usati per il reverse engineering e l'analisi di applicazioni mobile, per assistere nel testing delle applicazioni mobili contro le minacce di sicurezza OWASP per mobile. Il suo obiettivo è rendere questo compito più semplice e più accessibile per gli sviluppatori di applicazioni mobile e i professionisti della sicurezza.

È in grado di:

- Estrarre codice Java e Smali usando diversi strumenti
- Analizzare APK usando: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Estrarre informazioni private dall'APK usando regexps.
- Analizzare il Manifest.
- Analizzare i domini trovati usando: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate l'APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Utile per rilevare malware: [https://koodous.com/](https://koodous.com/)

## Offuscamento/Deoffuscamento del codice

Nota che, a seconda del servizio e della configurazione che usi per offuscare il codice, secrets potrebbero o meno risultare offuscati.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. It is able to optimize bytecode as well as detect and remove unused instructions. ProGuard is free software and is distributed under the GNU General Public License, version 2.

ProGuard è distribuito come parte dell'Android SDK e viene eseguito quando si builda l'applicazione in modalità release.

### [DexGuard](https://www.guardsquare.com/dexguard)

Trova una guida passo-passo per deobfuscate l'apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(Dalla guida) L'ultima volta che abbiamo controllato, la modalità di funzionamento di Dexguard era:

- caricare una risorsa come InputStream;
- fornire il risultato a una classe che eredita da FilterInputStream per decrittarlo;
- eseguire qualche offuscamento inutile per far perdere qualche minuto a un reverser;
- fornire il risultato decrittato a un ZipInputStream per ottenere un file DEX;
- infine caricare il DEX risultante come Resource usando il metodo `loadDex`.

### [DeGuard](http://apk-deguard.com)

**DeGuard inverte il processo di offuscamento eseguito dagli strumenti di offuscamento Android. Questo abilita numerose analisi di sicurezza, inclusa l'ispezione del codice e l'identificazione delle librerie.**

Puoi caricare un APK offuscato sulla loro piattaforma.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

Questo è uno strumento LLM per trovare eventuali potenziali vulnerabilità di sicurezza nelle app Android e deobfuscate il codice delle app Android. Usa l'API pubblica Gemini di Google.

### [Simplify](https://github.com/CalebFenton/simplify)

È un deobfuscator android generico. Simplify **virtually executes an app** per comprenderne il comportamento e poi **tries to optimize the code** in modo che si comporti in modo identico ma sia più facile da comprendere per un umano. Ogni tipo di ottimizzazione è semplice e generica, quindi non importa quale specifico tipo di offuscamento venga usato.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD ti dà informazioni su **how an APK was made**. Identifica molti **compilers**, **packers**, **obfuscators**, e altre cose strane. È [_PEiD_](https://www.aldeid.com/wiki/PEiD) per Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b è una virtual machine per Android security basata su ubuntu-mate che include la raccolta degli ultimi framework, tutorial e lab da diversi security geeks e ricercatori per reverse engineering e analisi di malware.

## Riferimenti

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) È una grande lista di risorse
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
