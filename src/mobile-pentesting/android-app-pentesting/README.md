# Android एप्लिकेशन Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android एप्लिकेशन मूल बातें

यह पृष्ठ पढ़ना अत्यधिक अनुशंसित है ताकि आप **Android सुरक्षा से संबंधित सबसे महत्वपूर्ण भाग और किसी Android एप्लिकेशन के सबसे खतरनाक घटकों** के बारे में जान सकें:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

यह मुख्य टूल है जिसकी आपको किसी Android डिवाइस (emulated or physical) से कनेक्ट होने के लिए आवश्यकता होती है.\
**ADB** कंप्यूटर से **USB** या **Network** के माध्यम से डिवाइस को नियंत्रित करने की अनुमति देता है। यह यूटिलिटी दोनों दिशाओं में फाइलों की **कॉपीिंग**, ऐप्स की **installation** और **uninstallation**, shell commands के **execution**, डेटा का **backing up**, लॉग्स का **reading**, और अन्य कार्यों को सक्षम बनाती है।

Take a look to the following list of [**ADB Commands**](adb-commands.md) to learn how to use adb.

## Smali

कभी-कभी यह उपयोगी होता है कि आप **application code को modify** करें ताकि **छिपी हुई जानकारी** (शायद अच्छी तरह obfuscated passwords या flags) तक पहुंचा जा सके। तब, apk को decompile करना, कोड modify करना और फिर इसे recompile करना दिलचस्प हो सकता है.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). यह dynamic analysis के दौरान किए जाने वाले कई परीक्षणों के लिए एक **वैकल्पिक तरीका** के रूप में बहुत उपयोगी हो सकता है। इसलिए, **इस संभावना को हमेशा ध्यान में रखें**।

## Other interesting tricks

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **APK डाउनलोड करें**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- डिवाइस से APK निकालें:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- सभी splits और base apks को [APKEditor](https://github.com/REAndroid/APKEditor) के साथ मर्ज करें:
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## केस स्टडीज़ & Vulnerabilities


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Static Analysis

सबसे पहले, किसी APK का विश्लेषण करने के लिए आपको एक decompiler का उपयोग करके **Java कोड** देखना चाहिए.\
कृपया, [**विभिन्न उपलब्ध decompilers के बारे में जानकारी के लिए यहाँ पढ़ें**](apk-decompilers.md).

### Looking for interesting Info

सिर्फ APK की **strings** देखकर आप **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** और अन्य दिलचस्प चीज़ें खोज सकते हैं... कोड निष्पादन के **backdoors** या authentication backdoors (ऐप में hardcoded admin credentials) की भी जांच करें।

**Firebase**

विशेष ध्यान दें **firebase URLs** पर और देखें कि क्या यह गलत कॉन्फ़िगर हुआ है। [More information about whats is FIrebase and how to exploit it here.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Basic understanding of the application - Manifest.xml, strings.xml

**किसी application's _Manifest.xml_ और **_strings.xml_** फ़ाइलों की जाँच संभावित सुरक्षा कमजोरियाँ उजागर कर सकती है**। इन फाइलों तक decompilers से पहुंचा जा सकता है या APK की file extension को .zip में बदलकर और उसे unzip करके भी प्राप्त किया जा सकता है।

**Manifest.xml** से पहचानी गई **Vulnerabilities** में शामिल हैं:

- **Debuggable Applications**: Manifest.xml में `debuggable="true"` सेट किए गए applications जोखिम पैदा करते हैं क्योंकि वे ऐसे कनेक्शनों की अनुमति देते हैं जो exploit करने का रास्ता खोल सकते हैं। debuggable applications को ढूँढने और exploit करने पर विस्तृत समझ के लिए संबंधित ट्यूटोरियल देखें।
- **Backup Settings**: संवेदनशील जानकारी वाले applications के लिए `android:allowBackup="false"` attribute को स्पष्ट रूप से सेट किया जाना चाहिए ताकि adb के माध्यम से अनाधिकृत डेटा backups से बचा जा सके, खासकर जब USB debugging सक्षम हो।
- **Network Security**: कस्टम नेटवर्क security configurations (`android:networkSecurityConfig="@xml/network_security_config"`) जो _res/xml/_ में होते हैं, certificate pins और HTTP ट्रैफ़िक सेटिंग्स जैसी सुरक्षा विवरण निर्दिष्ट कर सकते हैं। उदाहरण के लिए, कुछ डोमेन के लिए HTTP ट्रैफ़िक की अनुमति देना।
- **Exported Activities and Services**: Manifest में exported activities और services की पहचान ऐसे components को उजागर कर सकती है जिन्हें दुरुपयोग किया जा सकता है। dynamic testing के दौरान आगे की जांच से पता चल सकता है कि इन components का exploit कैसे किया जा सकता है।
- **Content Providers and FileProviders**: exposed content providers अनाधिकृत पहुँच या डेटा में संशोधन की अनुमति दे सकते हैं। FileProviders की configuration की भी बारीकी से जाँच की जानी चाहिए।
- **Broadcast Receivers and URL Schemes**: ये components exploitation के लिए उपयोग किए जा सकते हैं, खासकर यह ध्यान रखते हुए कि URL schemes इनपुट के लिए कैसे manage किए जा रहे हैं।
- **SDK Versions**: `minSdkVersion`, `targetSDKVersion`, और `maxSdkVersion` attributes समर्थित Android versions दिखाते हैं, जो पुराने, vulnerable Android versions को समर्थन न देने के महत्व को रेखांकित करते हैं।

**strings.xml** फ़ाइल से API keys, custom schemas और अन्य developer नोट्स जैसी संवेदनशील जानकारी मिल सकती है, इसलिए इन resources की सावधानीपूर्वक समीक्षा आवश्यक है।

### Tapjacking

Tapjacking एक हमला है जहाँ एक **malicious** **application** लॉन्च होता है और **victim application** के ऊपर अपने आप को रख देता है। जब यह विजिबली victim app को अस्पष्ट कर देता है, तो इसका user interface इस तरह डिज़ाइन किया जाता है कि उपयोगकर्ता को धोखा देकर इससे इंटरैक्ट कराया जा सके, जबकि यह इंटरैक्शन victim app को पास कर देता है।\
प्रभावतः, यह उपयोगकर्ता को अंधा कर देता है कि वे वास्तव में victim app पर ही कार्रवाई कर रहे हैं।

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

यदि किसी **activity** का **`launchMode`** `singleTask` पर सेट है और कोई भी `taskAffinity` परिभाषित नहीं है तो वह task Hijacking के लिए vulnerable होता है। इसका मतलब यह है कि एक **malicious application** install होकर और वास्तविक application से पहले launch होने पर **real application का task hijack कर सकता है** (तो उपयोगकर्ता **malicious application** के साथ इंटरैक्ट करते हुए सोचेंगे कि वे वास्तविक ऐप का उपयोग कर रहे हैं)।

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Insecure data storage

**Internal Storage**

Android में, internal storage में **store** की गई फाइलें सामान्यतः उन ही ऐप द्वारा पहुँचने योग्य होती हैं जिन्होंने उन्हें बनाया है। यह सुरक्षा उपाय Android operating system द्वारा लागू किया जाता है और अधिकांश applications की सुरक्षा आवश्यकताओं के लिए पर्याप्त होता है। फिर भी, developer कभी-कभी `MODE_WORLD_READABLE` और `MODE_WORLD_WRITABLE` जैसे modes का उपयोग करते हैं ताकि फ़ाइलें विभिन्न applications के बीच **share** की जा सकें। ये modes अन्य applications, जिनमें संभवतः malicious ones भी शामिल हैं, द्वारा इन फाइलों की पहुँच को रोकते नहीं हैं।

1. **Static Analysis:**
- `MODE_WORLD_READABLE` और `MODE_WORLD_WRITABLE` के उपयोग की **सावधानीपूर्वक जाँच** सुनिश्चित करें। ये modes फ़ाइलों को **अनचाही या अनधिकृत पहुँच** के लिए उजागर कर सकते हैं।
2. **Dynamic Analysis:**
- ऐप द्वारा बनाई गई फाइलों पर सेट की गई **permissions** को verify करें। विशेष रूप से जाँचें कि क्या कोई फाइलें **world-readable या world-writable** के रूप में सेट हैं। यह एक महत्वपूर्ण सुरक्षा जोखिम हो सकता है, क्योंकि इससे **किसी भी application** (जिसे डिवाइस पर इंस्टॉल किया गया है), चाहे उसका स्रोत या इरादा कुछ भी हो, उन फाइलों को **read या modify** करने की अनुमति मिल सकती है।

**External Storage**

जब आप SD Cards जैसे external storage पर फ़ाइलों से निपटते हैं, तो कुछ सावधानियाँ बरतनी चाहिए:

1. **Accessibility**:
- External storage पर फ़ाइलें **globally readable और writable** होती हैं। इसका मतलब है कि कोई भी application या user इन फाइलों तक पहुँच सकता है।
2. **Security Concerns**:
- आसान पहुँच के कारण, संवेदनशील जानकारी को external storage पर रखने से बचें।
- External storage हटाई या किसी भी application द्वारा एक्सेस की जा सकती है, इसलिए यह कम सुरक्षित है।
3. **Handling Data from External Storage**:
- External storage से प्राप्त डेटा पर हमेशा **input validation** करें। यह महत्वपूर्ण है क्योंकि डेटा एक untrusted स्रोत से आता है।
- Executables या class files को dynamic loading के लिए external storage पर रखना दृढ़ता से discouraged है।
- यदि आपकी application को external storage से executable files प्राप्त करने ही पड़ते हैं, तो सुनिश्चित करें कि ये फाइलें **signed और cryptographically verified** हों इससे पहले कि वे dynamically loaded हों। यह कदम आपकी application की सुरक्षा अखंडता बनाए रखने के लिए आवश्यक है।

External storage को `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard` में access किया जा सकता है

> [!TIP]
> Android 4.4 (**API 17**) से शुरू होकर, SD card में एक directory structure है जो किसी ऐप की पहुँच को उस directory तक सीमित कर देता है जो विशेष रूप से उस ऐप के लिए है। यह किसी malicious application को किसी अन्य ऐप की फ़ाइलों पर read या write पहुँच प्राप्त करने से रोकता है।

**Sensitive data stored in clear-text**

- **Shared preferences**: Android प्रत्येक application को आसानी से xml फाइलें `/data/data/<packagename>/shared_prefs/` path में save करने की अनुमति देता है और कभी-कभी उस फ़ोल्डर में clear-text में संवेदनशील जानकारी मिल सकती है।
- **Databases**: Android प्रत्येक application को आसानी से sqlite databases `/data/data/<packagename>/databases/` path में save करने की अनुमति देता है और कभी-कभी उस फ़ोल्डर में clear-text में संवेदनशील जानकारी मिल सकती है।

### Broken TLS

**Accept All Certificates**

कई बार developers सभी certificates को स्वीकार कर लेते हैं, यहाँ तक कि जब hostname मेल भी नहीं खाता हो, उदाहरण के लिए नीचे दिए गए जैसे कोड की लाइनों के साथ:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### टूटी क्रिप्टोग्राफी

**Poor Key Management Processes**

कुछ developers स्थानीय storage में संवेदनशील डेटा सेव करते हैं और उसे code में hardcoded/predictable key से encrypt कर देते हैं। यह नहीं किया जाना चाहिए क्योंकि कुछ reversing से attackers confidential जानकारी निकाल सकते हैं।

**Insecure और/या Deprecated Algorithms का उपयोग**

Developers को authorization **checks**, **store** या **send** करने के लिए **deprecated algorithms** का उपयोग नहीं करना चाहिए। इन में से कुछ algorithms हैं: RC4, MD4, MD5, SHA1... अगर उदाहरण के लिए passwords को store करने के लिए **hashes** का उपयोग किया जाता है, तो salt के साथ brute-force के प्रति **resistant** hashes का उपयोग किया जाना चाहिए।

### अन्य जांच

- यह recommend किया जाता है कि **APK को obfuscate** किया जाए ताकि attackers के लिए reverse engineer का काम मुश्किल हो।
- यदि ऐप sensitive है (जैसे bank apps), तो उसे अपने **own checks to see if the mobile is rooted** करने चाहिए और उसके अनुसार act करना चाहिए।
- यदि ऐप sensitive है (जैसे bank apps), तो उसे चेक करना चाहिए कि कोई **emulator** उपयोग हो रहा है।
- यदि ऐप sensitive है (जैसे bank apps), तो उसे **execute करने से पहले अपनी integrity जांचनी चाहिए** ताकि पता चल सके कि उसे modify किया गया है या नहीं।
- किस compiler/packer/obfuscator का उपयोग करके APK बनाया गया था यह जांचने के लिए [**APKiD**](https://github.com/rednaga/APKiD) का उपयोग करें

### React Native Application

React applications के javascript code तक आसानी से पहुँचने के लिए निम्न पृष्ठ पढ़ें:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Xamarin applications के C# code तक आसानी से पहुँचने के लिए निम्न पृष्ठ पढ़ें:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

इस [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) के अनुसार superpacked एक Meta algorithm है जो application की content को एक single file में compress करता है। ब्लॉग में चर्चा है कि ऐसे apps को decompress करने के लिये एक ऐप बनाना संभव है... और एक तेज़ तरीका जो involve करता है **application को execute करना और filesystem से decompressed files इकट्ठा करना.**

### Automated Static Code Analysis

टूल [**mariana-trench**](https://github.com/facebook/mariana-trench) application के **code** को **scan** करके **vulnerabilities** खोजने में सक्षम है। इस tool में कई **known sources** (जो tool को बताती हैं कि वे **places** कहाँ हैं जहाँ **input** **user द्वारा control** होता है), **sinks** (जो tool को बताती हैं कि वे **dangerous** **places** कौन से हैं जहाँ malicious user input नुकसान कर सकता है) और **rules** शामिल हैं। ये rules उन **sources-sinks** के **combination** को इंगित करते हैं जो vulnerability की निशानी होती है।

इन जानकारियों के साथ, **mariana-trench कोड की समीक्षा करेगा और संभावित vulnerabilities पाएगा।**

### Secrets leaked

एक application में secrets (API keys, passwords, hidden urls, subdomains...) हो सकते हैं जिन्हें आप discover कर सकते हैं। आप ऐसे tool का उपयोग कर सकते हैं जैसे [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### अन्य दिलचस्प फ़ंक्शन्स

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [इसे पढ़ें ताकि आप जान सकें **native functions को कैसे reverse करें**](reversing-native-libraries.md)
- JNI के माध्यम से इन-मेमोरी native code निष्पादन (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## डायनामिक एनालिसिस

> सबसे पहले, आपको एक ऐसा environment चाहिए जहा आप application और सभी आवश्यक environment (Burp CA cert, Drozer और Frida मुख्य रूप से) install कर सकें। इसलिए, एक rooted device (emulated हो या नहीं) अत्यधिक recommend किया जाता है।

### Online Dynamic analysis

आप एक **free account** बना सकते हैं: [https://appetize.io/](https://appetize.io/). यह platform आपको APKs **upload** और **execute** करने की अनुमति देता है, इसलिए यह यह देखने में उपयोगी है कि एक apk कैसे behave कर रहा है।

आप वेब पर अपने application के logs भी देख सकते हैं और **adb** के जरिए connect कर सकते हैं।

![](<../../images/image (831).png>)

ADB connection की वजह से आप emulators के अंदर **Drozer** और **Frida** का उपयोग कर सकते हैं।

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (आप **x86** और **arm** devices बना सकते हैं, और [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** versions **support ARM libraries** बिना slow arm emulator की ज़रूरत के).
- इसे सेटअप करना सीखने के लिए इस पृष्ठ को देखें:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, आपको एक account बनाना होगा. _यह recommend किया जाता है कि आप उस version को **download** करें जो **WITH** _**VirtualBox** हो ताकि संभावित errors से बचा जा सके._)
- [**Nox**](https://es.bignox.com) (Free, पर यह Frida या Drozer को support नहीं करता).

> [!TIP]
> जब किसी भी platform पर नया emulator बनाते हैं तो ध्यान रखें कि स्क्रीन जितनी बड़ी होगी, emulator उतना ही धीमा चलेगा। इसलिए संभव हो तो छोटे स्क्रीन चुनें।

Genymotion में google services (जैसे AppStore) install करने के लिए निम्न चित्र के लाल चिन्हित बटन पर क्लिक करना होगा:

![](<../../images/image (277).png>)

साथ ही, ध्यान दें कि **Genymotion में Android VM की configuration** में आप **Bridge Network mode** चुन सकते हैं (यह उपयोगी होगा यदि आप किसी अलग VM से Android VM से जुड़ रहे हैं जिसमें tools हैं)।

#### Use a physical device

आपको **debugging** options को सक्रिय करना होगा और अच्छा होगा अगर आप उसे **root** कर सकें:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> एक बार जब आपने application install कर ली है, तो पहली चीज जो आपको करनी चाहिए वह है इसे चलाकर देखना और जाँचना कि यह क्या करता है, यह कैसे काम करता है और इससे comfortable होना।\
> मैं सलाह दूंगा कि इस प्रारम्भिक डायनामिक एनालिसिस को MobSF dynamic analysis + pidcat का उपयोग करके करें, ताकि हम सीख सकें कि application कैसे काम करता है जबकि MobSF बहुत सारी interesting डेटा capture कर रहा होगा जिसे आप बाद में review कर सकते हैं।

Magisk/Zygisk quick notes (Pixel devices पर recommended)
- Magisk app से boot.img patch करें और fastboot के जरिए flash करके systemless root पाएं
- Zygisk + DenyList enable करके root hide करें; जब मजबूत hiding चाहिए तो LSPosed/Shamiko पर विचार करें
- OTA updates से recover करने के लिए original boot.img रखें; हर OTA के बाद re-patch करें
- स्क्रीन mirroring के लिए host पर scrcpy का उपयोग करें

### Unintended Data Leakage

**Logging**

Developers को सार्वजनिक रूप से **debugging information** उजागर करने में सावधान रहना चाहिए, क्योंकि इससे संवेदनशील डेटा leaks हो सकते हैं। application logs मॉनिटर करने के लिए [**pidcat**](https://github.com/JakeWharton/pidcat) और `adb logcat` की सिफारिश की जाती है ताकि संवेदनशील जानकारी की पहचान और सुरक्षा की जा सके। **Pidcat** को उसकी ease of use और readability के कारण प्राथमिकता दी जाती है।

> [!WARNING]
> ध्यान दें कि **Android 4.0 से नई versions** में, **applications केवल अपने ही logs तक पहुँच सकती हैं**। इसलिए applications अन्य apps के logs तक access नहीं कर सकतीं।\
> फिर भी, यह सुझाया जाता है कि संवेदनशील जानकारी को **log न करें**।

**Copy/Paste Buffer Caching**

Android का **clipboard-based** framework apps में copy-paste functionality सक्षम करता है, फिर भी यह जोखिम पैदा करता है क्योंकि **अन्य applications** clipboard को access कर सकती हैं और संभावित रूप से संवेदनशील डेटा expose कर सकती हैं। इसलिए किसी application के संवेदनशील हिस्सों (जैसे credit card details) के लिए copy/paste functions को disable करना महत्वपूर्ण है ताकि डेटा leak होने से रोका जा सके।

**Crash Logs**

यदि कोई application **crash** करता है और logs save करता है, तो ये logs attackers के लिए मददगार हो सकते हैं, खासकर जब application reverse-engineer नहीं की जा सकती। इस जोखिम को कम करने के लिए, crash पर logging से बचें, और यदि logs network पर भेजने ही हों तो उन्हें SSL चैनल के माध्यम से भेजें।

As pentester, **try to take a look to these logs**.

**Analytics Data Sent To 3rd Parties**

Applications अक्सर Google Adsense जैसी services integrate करते हैं, जो गलत implementation की वजह से अनजाने में **sensitive data leak** कर सकती हैं। संभावित data leaks की पहचान करने के लिए, यह सलाह दी जाती है कि आप application's traffic intercept करें और देखें कि क्या कोई संवेदनशील जानकारी third-party services को भेजी जा रही है।

### SQLite DBs

अधिकतर applications internal SQLite databases का उपयोग जानकारी save करने के लिए करते हैं। pentest के दौरान बनाए गए **databases**, **tables** और **columns** के नाम और उसमें saved सभी **data** को ध्यान से देखें क्योंकि आप वहां **sensitive information** पा सकते हैं (जो vulnerability होगी).\
Databases को सामान्यतः `/data/data/the.package.name/databases` में पाया जाता है जैसे `/data/data/com.mwr.example.sieve/databases`

यदि database confidential information save कर रहा है और वह **encrypted** है पर आप application के अंदर password पा लेते हैं तो यह फिर भी एक **vulnerability** है।

.tables का उपयोग करके tables enumerate करें और .schema <table_name> करके table के columns enumerate करें।

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** आपको **एक Android app की भूमिका अपनाने** और अन्य apps के साथ interact करने की अनुमति देता है। यह installed application जो कुछ भी कर सकती है, वह कर सकता है, जैसे Android’s Inter-Process Communication (IPC) mechanism का उपयोग करना और underlying operating system के साथ interact करना। .\
Drozer एक उपयोगी tool है जो **exported activities, exported services और Content Providers** को exploit करने में मदद करता है जैसा कि आप निम्न sections में सीखेंगे।

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
और याद रखें कि किसी activity का code **`onCreate`** method में शुरू होता है।

**Authorisation bypass**

जब कोई Activity exported होती है तो आप उसकी स्क्रीन को किसी external app से invoke कर सकते हैं। इसलिए, यदि किसी activity में **sensitive information** है और वह **exported** है तो आप authentication mechanisms को **bypass** करके उसे access कर सकते हैं।

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

आप adb से भी एक exported activity start कर सकते हैं:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF किसी activity में `android:launchMode` के रूप में _**singleTask/singleInstance**_ के उपयोग को malicious के रूप में डिटेक्ट करेगा, लेकिन [यहाँ](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750) के कारण ऐसा प्रतीत होता है कि यह केवल पुराने वर्शन (API versions < 21) पर ही खतरनाक है।

> [!TIP]
> ध्यान दें कि एक authorisation bypass हमेशा एक vulnerability नहीं होता, यह निर्भर करेगा कि bypass कैसे काम करता है और कौन सी जानकारी exposed होती है।

**Sensitive information leakage**

**Activities can also return results**. यदि आप कोई exported और unprotected activity पाते हैं जो **`setResult`** method को कॉल करके **returning sensitive information** कर रही है, तो यह एक sensitive information leakage है।

#### Tapjacking

यदि Tapjacking रोका नहीं गया है, तो आप exported activity का दुरुपयोग करके **user perform unexpected actions** करवा सकते हैं। अधिक जानकारी के लिए [**what is Tapjacking follow the link**](#tapjacking) देखें।

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**यदि आप refresh करना चाहते हैं कि Content Provider क्या है तो यह पढ़ें।**](android-applications-basics.md#content-provider)\
Content providers मूलतः **share data** के लिए उपयोग होते हैं। यदि किसी app में available content providers हैं तो आप उनसे **extract sensitive** डेटा कर पाने में सक्षम हो सकते हैं। साथ ही संभावित **SQL injections** और **Path Traversals** की जाँच करना महत्वपूर्ण है क्योंकि वे vulnerable हो सकते हैं।

[**Drozer के साथ Content Providers को exploit करने का तरीका सीखें।**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**यदि आप refresh करना चाहते हैं कि Service क्या है तो यह पढ़ें।**](android-applications-basics.md#services)\
याद रखें कि Service की actions `onStartCommand` method में शुरू होती हैं।

Service मूलतः ऐसा component है जो **can receive data**, उसे **process** कर सकता है और (या नहीं) एक response **returns** करता है। इसलिए, यदि कोई application कुछ services export कर रहा है तो आपको उसका **code** **check** करके समझना चाहिए कि वह क्या कर रहा है और उसे confidential info निकालने, authentication measures bypass करने आदि के लिए **dynamically test** करना चाहिए।\
[**Drozer के साथ Services को exploit करने का तरीका सीखें।**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**यदि आप refresh करना चाहते हैं कि Broadcast Receiver क्या है तो यह पढ़ें।**](android-applications-basics.md#broadcast-receivers)\
याद रखें कि Broadcast Receiver की actions `onReceive` method में शुरू होती हैं।

एक broadcast receiver किसी विशेष प्रकार के message का इंतजार करेगा। यह इस पर निर्भर करता है कि receiver message को कैसे handle करता है कि वह vulnerable हो सकता है।\
[**Drozer के साथ Broadcast Receivers को exploit करने का तरीका सीखें।**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

आप deep links मैन्युअली ढूँढ सकते हैं, MobSF जैसे tools या [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py) जैसे scripts का उपयोग करके।\
आप घोषित किए गए किसी **scheme** को **adb** या **browser** का उपयोग करके **open** कर सकते हैं:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_ध्यान दें कि आप **package name को छोड़ सकते हैं** और मोबाइल स्वचालित रूप से उस app को कॉल करेगा जो उस लिंक को खोलना चाहिए._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**निष्पादित कोड**

App में वह **code that will be executed in the App** खोजने के लिए, उस activity पर जाएँ जिसे deeplink कॉल कर रहा है और फ़ंक्शन **`onNewIntent`** खोजें।

![](<../../images/image (436) (1) (1) (1).png>)

**Sensitive info**

हर बार जब आप किसी deep link को पाते हैं, जाँच करें कि i**t's not receiving sensitive data (like passwords) via URL parameters**, क्योंकि कोई भी दूसरी application उस deep link को **impersonate** करके उस डेटा को चुरा सकती है!

**Parameters in path**

आपको यह भी जांचना **ज़रूरी** है कि कोई deep link URL के path के अंदर parameter का उपयोग कर रहा है या नहीं, जैसे: `https://api.example.com/v1/users/{username}` , ऐसे मामलों में आप path traversal को मजबूर कर सकते हैं, जैसे: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
ध्यान दें कि अगर आप application के अंदर सही endpoints खोज लेते हैं तो आप **Open Redirect** (अगर path का हिस्सा domain name के रूप में उपयोग हो रहा हो), **account takeover** (अगर आप users के विवरण को CSRF token के बिना बदल सकते हैं और vulnerable endpoint ने सही method उपयोग किया हो) और अन्य किसी भी vuln को उत्पन्न कर सकते हैं। More [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Transport Layer Inspection and Verification Failures

- **Certificates को हमेशा ठीक से जांचा नहीं जाता** Android applications द्वारा। अक्सर ये applications warnings को नजरअंदाज कर self-signed certificates स्वीकार कर लेते हैं या कुछ मामलों में HTTP connections पर वापस लौट जाते हैं।
- **SSL/TLS handshake के दौरान negotiations कभी-कभी कमजोर होती हैं**, जिसमें insecure cipher suites का उपयोग होता है। यह कमजोरी connection को man-in-the-middle (MITM) हमलों के लिए संवेदनशील बनाती है, जिससे attackers डेटा को decrypt कर सकते हैं।
- **गोपनीय जानकारी का रिसाव** एक जोखिम है जब applications secure channels का उपयोग करके authenticate करती हैं लेकिन अन्य transactions के लिए non-secure channels पर communicate करती हैं। यह तरीका sensitive डेटा—जैसे session cookies या user details—को malicious entities द्वारा इंटरसेप्ट होने से सुरक्षित नहीं रख पाता।

#### Certificate Verification

हम **certificate verification** पर ध्यान देंगे। server के certificate की integrity को verify करना सुरक्षा बढ़ाने के लिए आवश्यक है। यह महत्वपूर्ण है क्योंकि insecure TLS configurations और unencrypted channels पर sensitive data का transmission गंभीर जोखिम पैदा कर सकता है। server certificates verify करने और vulnerabilities को संबोधित करने के लिए विस्तृत कदमों के लिए, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) व्यापक मार्गदर्शन प्रदान करता है।

#### SSL Pinning

SSL Pinning एक security measure है जहाँ application server के certificate को उसके अंदर संग्रहित ज्ञात copy के खिलाफ verify करती है। यह विधि MITM attacks को रोकने के लिए अनिवार्य है। संवेदनशील जानकारी संभालने वाली applications के लिए SSL Pinning लागू करने की दृढ़ सिफारिश की जाती है।

#### Traffic Inspection

HTTP traffic inspect करने के लिए, यह आवश्यक है कि **proxy tool का certificate इंस्टॉल** किया जाए (उदा., Burp)। इस certificate को इंस्टॉल किए बिना, encrypted traffic proxy के माध्यम से दिखाई नहीं दे सकती। custom CA certificate इंस्टॉल करने के निर्देशों के लिए, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine)।

API Level 24 और उससे ऊपर target करने वाली applications को proxy के CA certificate को स्वीकार करने के लिए Network Security Config में संशोधन की आवश्यकता होती है। यह कदम encrypted traffic inspect करने के लिए महत्वपूर्ण है। Network Security Config में संशोधन करने के निर्देशों के लिए, [**refer to this tutorial**](make-apk-accept-ca-certificate.md)।

यदि **Flutter** उपयोग किया जा रहा है तो आपको [**this page**](flutter.md) में दिए निर्देशों का पालन करना होगा। ऐसा इसलिए है क्योंकि केवल certificate को store में जोड़ना काम नहीं करेगा क्योंकि Flutter के पास अपने valid CAs की अलग सूची होती है।

#### Static detection of SSL/TLS pinning

Runtime bypasses का प्रयास करने से पहले, जल्दी से map करें कि APK में कहाँ pinning लागू किया गया है। Static discovery आपको hooks/patches की योजना बनाने और सही code paths पर ध्यान केंद्रित करने में मदद करता है।

Tool: SSLPinDetect
- Open-source static-analysis utility जो APK को Smali (via apktool) में decompile करता है और SSL/TLS pinning implementations के curated regex patterns के लिए scan करता है।
- प्रत्येक match के लिए exact file path, line number, और code snippet रिपोर्ट करता है।
- सामान्य frameworks और custom code paths को कवर करता है: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, और Network Security Config XML pins।

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
उपयोग
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
उदाहरण पैटर्न नियम (JSON)

signatures का उपयोग करें या उन्हें बढ़ाएँ ताकि proprietary/custom pinning styles का पता लगाया जा सके। आप अपना खुद का JSON लोड कर सकते हैं और बड़े पैमाने पर scan कर सकते हैं।
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes and tips
- बड़े ऐप्स पर तेज़ स्कैनिंग के लिए multi-threading और memory-mapped I/O का उपयोग; pre-compiled regex ओवरहेड/false positives कम करता है।
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- अगले ट्रायेज़ के लिए सामान्य लक्ष्य:
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Declarative pins in res/xml network security config and manifest references
- मैच हुए लोकेशन्स का उपयोग Frida hooks, static patches, या config reviews की योजना बनाने के लिए करें, dynamic testing से पहले।

#### SSL Pinning को बायपास करना

जब SSL Pinning लागू होता है, तो HTTPS ट्रैफिक का निरीक्षण करने के लिए इसे बायपास करना आवश्यक हो जाता है। इसके लिए विभिन्न तरीके उपलब्ध हैं:

- अपने apk को स्वचालित रूप से modify करके SSLPinning को bypass करने के लिए [**apk-mitm**](https://github.com/shroudedcode/apk-mitm) का उपयोग करें। इस विकल्प का बड़ा फायदा यह है कि SSL Pinning बायपास करने के लिए आपको root की आवश्यकता नहीं होगी, लेकिन आपको application को डिलीट करके नया इंस्टॉल करना होगा, और यह हमेशा काम नहीं करेगा।
- आप इस सुरक्षा को bypass करने के लिए **Frida** का उपयोग कर सकते हैं (नीचे बताया गया है)। यहाँ Burp+Frida+Genymotion का उपयोग करने का गाइड है: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- आप [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"` का उपयोग करके SSL Pinning को स्वचालित रूप से bypass करने की कोशिश कर सकते हैं।
- आप **MobSF dynamic analysis** (नीचे समझाया गया) का उपयोग करके भी SSL Pinning स्वचालित रूप से bypass करने का प्रयास कर सकते हैं।
- यदि आपको फिर भी लगता है कि कुछ ट्रैफ़िक कैप्चर नहीं हो रहा है तो आप ट्रैफ़िक को burp पर फॉरवर्ड करने के लिए iptables का उपयोग कर सकते हैं। इस ब्लॉग को पढ़ें: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### सामान्य वेब कमजोरियों की तलाश

ऐप के भीतर सामान्य वेब कमजोरियों की भी खोज करना महत्वपूर्ण है। इन कमजोरियों की पहचान और उनका निवारण करने की विस्तृत जानकारी इस सारांश के बाहर है पर अन्य स्थानों पर व्यापक रूप से कवर की गई है।

### Frida

[Frida](https://www.frida.re) developers, reverse-engineers, और security researchers के लिए एक dynamic instrumentation toolkit है.\
**आप रनिंग application तक पहुँच कर runtime पर methods को hook कर सकते हैं, व्यवहार बदल सकते हैं, मान बदल सकते हैं, वैल्यू एक्सट्रैक्ट कर सकते हैं, अलग कोड चला सकते हैं...**\
यदि आप Android applications का pentest कर रहे हैं तो आपको Frida का उपयोग करना आना चाहिए।

- Frida सीखें: [**Frida tutorial**](frida-tutorial/index.html)
- Frida के साथ actions के लिए कुछ "GUI": [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection Frida के उपयोग को automate करने के लिए बढ़िया है: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- कुछ Awesome Frida scripts यहाँ मिलेगी: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- anti-debugging / anti-frida mechanisms को bypass करने की कोशिश करें, Frida को ऐसे लोड करके जैसा बताया गया है: [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

जाँचें कि क्या application मेमोरी में संवेदनशील जानकारी स्टोर कर रहा है जिसे स्टोर नहीं करना चाहिए, जैसे passwords या mnemonics।

Using [**Fridump3**](https://github.com/rootbsd/fridump3) you can dump the memory of the app with:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
यह memory को ./dump फ़ोल्डर में dump कर देगा, और वहाँ आप कुछ इस तरह grep कर सकते हैं:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Keystore में संवेदनशील डेटा**

Android में Keystore संवेदनशील डेटा रखने के लिए सबसे अच्छा स्थान है, हालांकि पर्याप्त privileges होने पर इसे फिर भी **एक्सेस करना संभव है**। चूंकि applications यहाँ अक्सर **सादा टेक्स्ट में संवेदनशील डेटा** स्टोर कर देती हैं, pentests को इसे root user के रूप में जाँचना चाहिए क्योंकि किसी के पास डिवाइस तक भौतिक पहुँच होने पर वे यह डेटा चुरा सकते हैं।

भले ही किसी app ने Keystore में डेटा संग्रहीत किया हो, डेटा एन्क्रिप्ट किया जाना चाहिए।

Keystore के अंदर के डेटा को एक्सेस करने के लिए आप यह Frida script उपयोग कर सकते हैं: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

निम्नलिखित Frida script का उपयोग करके यह संभव हो सकता है कि Android applications द्वारा कुछ संवेदनशील क्षेत्रों की सुरक्षा के लिए लागू की जा रही **bypass fingerprint authentication** को दरकिनार किया जा सके:
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **पृष्ठभूमि छवियाँ**

जब आप किसी एप्लिकेशन को बैकग्राउंड में डालते हैं, Android एप्लिकेशन का एक **snapshot** स्टोर करता है ताकि जब वह foreground में लौटे तो यह ऐप के लोड होने से पहले image लोड करना शुरू कर दे ताकि ऐसा लगे कि ऐप तेज़ी से लोड हुआ।

हालाँकि, अगर यह snapshot किसी **संवेदनशील जानकारी** को समाहित करता है, तो snapshot तक पहुँच रखने वाला कोई व्यक्ति वह जानकारी **चुरा सकता है** (ध्यान दें कि इसे एक्सेस करने के लिए आपको root की आवश्यकता होती है)।

Snapshots आमतौर पर इस पथ पर स्टोर होते हैं: **`/data/system_ce/0/snapshots`**

Android एक तरीका देता है जिससे आप layout parameter में **FLAG_SECURE सेट करके screenshot capture को रोक** सकते हैं। इस flag का उपयोग करने पर, window के contents को secure माना जाता है, जिससे वे screenshots में दिखाई नहीं देते और non-secure displays पर नहीं दिखते।
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

यह टूल डायनामिक विश्लेषण के दौरान विभिन्न टूल्स को मैनेज करने में मदद कर सकता है: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

डेवलपर्स अक्सर activities, services, और broadcast receivers जैसे proxy components बनाते हैं जो इन Intents को हैंडल करते हैं और उन्हें `startActivity(...)` या `sendBroadcast(...)` जैसे मेथड्स को पास करते हैं, जो जोखिम भरा हो सकता है।

खतरा इस बात में है कि attackers इन Intents को गलत दिशा में भेजकर non-exported app components को trigger कर सकते हैं या sensitive content providers तक पहुँच बना सकते हैं। एक ध्यान देने योग्य उदाहरण `WebView` component है जो URLs को `Intent.parseUri(...)` के माध्यम से `Intent` objects में बदलता है और फिर उन्हें execute कर सकता है, जिससे संभावित रूप से malicious Intent injections हो सकते हैं।

### आवश्यक निष्कर्ष

- **Intent Injection** web के Open Redirect issue के समान है।
- Exploits में `Intent` objects को extras के रूप में पास करना शामिल है, जिन्हें redirect करके unsafe operations execute किए जा सकते हैं।
- यह non-exported components और content providers को attackers के लिए उजागर कर सकता है।
- `WebView` की URL से `Intent` conversion अनचाही क्रियाओं की सुविधा दे सकता है।

### Android Client Side Injections and others

शायद आप Web से इस तरह की vulnerabilities के बारे में जानते होंगे। Android application में इन vulnerabilities के प्रति विशेष सावधानी बरतनी चाहिए:

- **SQL Injection:** जब dynamic queries या Content-Providers के साथ काम कर रहे हों तो सुनिश्चित करें कि आप parameterized queries का उपयोग कर रहे हैं।
- **JavaScript Injection (XSS):** किसी भी WebViews के लिए JavaScript और Plugin support disabled है यह सत्यापित करें (disabled by default). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews को file system तक access disabled होना चाहिए (enabled by default) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: कई मामलों में जब android application session समाप्त करती है तो cookie revoke नहीं होती या वह disk पर भी saved हो सकती है
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Static analysis**

![](<../../images/image (866).png>)

**Vulnerability assessment of the application** एक अच्छी वेब-आधारित frontend के जरिए किया जा सकता है। आप डायनामिक विश्लेषण भी कर सकते हैं (लेकिन आपको environment तैयार करना होगा)।
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### MobSF के साथ सहायक Dynamic analysis

**MobSF** Android में **dynamic analysis** के लिए भी बहुत मददगार हो सकता है, लेकिन उस स्थिति में आपको अपने host पर MobSF और **genymotion** इंस्टॉल करना होगा (a VM or Docker won't work). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
The **MobSF dynamic analyser** can:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). ये सब स्वचालित रूप से किया जाता है सिवाय screenshots के — screenshots लेने के लिए आपको जब screenshot चाहिए तब दबाना होगा या सभी exported activities के screenshots पाने के लिए "**Exported Activity Tester**" दबाना होगा।
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Frida scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: यह सभी loaded classes प्रिंट करेगा
- **Capture Strings**: यह application उपयोग करते समय सभी captured strings प्रिंट करेगा (super noisy)
- **Capture String Comparisons**: बहुत उपयोगी हो सकता है। यह तुलना की जा रही दोनों strings दिखाएगा और बताएगा कि result True था या False।
- **Enumerate Class Methods**: class name डालें (like "java.io.File") और यह class के सभी methods प्रिंट करेगा।
- **Search Class Pattern**: pattern के द्वारा classes खोजें
- **Trace Class Methods**: **Trace** a **whole class** (क्लास के सभी methods के inputs और outputs देखें)। ध्यान रखें कि डिफ़ॉल्ट रूप से MobSF कई interesting Android Api methods को trace करता है।

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

MobSF आपको dynamic analysis पेज के नीचे कुछ **adb** commands, **MobSF commands**, और आम **shell** **commands** के साथ एक shell भी देता है। कुछ दिलचस्प commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP टूल्स**

जब HTTP ट्रैफिक कैप्चर होता है तो आप कैप्चर्ड ट्रैफिक का एक कच्चा व्यू "**HTTP(S) Traffic**" बॉटम में देख सकते हैं या एक बेहतर व्यू "**Start HTTPTools**" हरे बॉटन में। दूसरे ऑप्शन से आप कैप्चर्ड requests को Burp या Owasp ZAP जैसे proxies को **send** कर सकते हैं।\
ऐसा करने के लिए, _Burp on करें -->_ _Intercept off करें --> MobSB HTTPTools में request select करें_ --> "**Send to Fuzzer**" दबाएँ --> _proxy address चुनें_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080))।

MobSF के साथ dynamic analysis खत्म करने के बाद आप "**Start Web API Fuzzer**" दबाकर **fuzz http requests** कर सकते हैं और vulnerabilities ढूँढ सकते हैं।

> [!TIP]
> MobSF के साथ dynamic analysis करने के बाद proxy settings misconfigured हो सकती हैं और आप उन्हें GUI से ठीक नहीं कर पाएँगे। आप proxy settings को इस कमांड से ठीक कर सकते हैं:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

आप यह टूल [**Inspeckage**](https://github.com/ac-pm/Inspeckage) से ले सकते हैं।\
यह टूल कुछ **Hooks** का उपयोग करके यह बताता है **application में क्या हो रहा है** जबकि आप **dynamic analysis** कर रहे होते हैं।

### [Yaazhini](https://www.vegabird.com/yaazhini/)

यह एक **GUI के साथ static analysis करने के लिए शानदार टूल** है

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

यह टूल कई प्रकार की **security related Android application vulnerabilities** खोजने के लिए बनाया गया है, चाहे वह **source code** में हों या **packaged APKs** में। यह टूल कुछ पाए गए vulnerabilities (Exposed activities, intents, tapjacking...) को exploit करने के लिए **"Proof-of-Concept" deployable APK** और **ADB commands** भी बना सकता है। Drozer की तरह, टेस्ट डिवाइस को root करने की ज़रूरत नहीं है।
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- सभी निकाले गए फाइलों को आसान संदर्भ के लिए प्रदर्शित करता है
- APK फाइलों को स्वचालित रूप से Java और Smali फॉर्मेट में decompile करता है
- AndroidManifest.xml का विश्लेषण common vulnerabilities और व्यवहार के लिए करता है
- Static source code analysis — common vulnerabilities और व्यवहार के लिए
- डिवाइस जानकारी
- और अधिक
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER एक command-line application है जिसे Windows, MacOS X और Linux पर इस्तेमाल किया जा सकता है, और यह _.apk_ फ़ाइलों का विश्लेषण करके vulnerabilities की तलाश करता है। यह APKs को decompress करके और उन vulnerabilities का पता लगाने के लिए नियमों की एक श्रृंखला लागू करके ऐसा करता है।

सारे नियम `rules.json` फ़ाइल में केंद्रीकृत हैं, और हर कंपनी या टेस्टर अपनी ज़रूरत के मुताबिक़ विश्लेषण के लिए अपने नियम बना सकता/सकती है।

लेटेस्ट binaries को [download page](https://superanalyzer.rocks/download.html) से डाउनलोड करें
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn एक **crossplatform** टूल है जो डेवलपर्स, bugbounty hunters और ethical hackers को मोबाइल एप्लिकेशनों पर [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) करने में मदद करता है।

विचार यह है कि आप अपनी मोबाइल एप्लिकेशन फ़ाइल (.apk या .ipa फ़ाइल) को StaCoAn application पर drag and drop करें और यह आपके लिए एक visual और portable रिपोर्ट जेनरेट करेगा। आप सेटिंग्स और wordlists को tweak करके एक customized अनुभव प्राप्त कर सकते हैं।

Download[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework एक Android vulnerability analysis system है जो developers या hackers को Android applications में potential security vulnerabilities खोजने में मदद करता है.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** एक ऐसा टूल है जिसका मुख्य उद्देश्य किसी Android application द्वारा विकसित संभावित malicious व्यवहारों का पता लगाना और उपयोगकर्ता को चेतावनी देना है।

यह detection application's Dalvik bytecode के **static analysis** के साथ किया जाता है, जो **Smali** के रूप में प्रदर्शित होता है, और इसके लिए [`androguard`](https://github.com/androguard/androguard) library का उपयोग किया जाता है।

यह टूल निम्न जैसी चीज़ों के लिए **common behavior of "bad" applications** ढूँढ़ता है: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. यह एक टूल है जो सामान्यतः इस्तेमाल किए जाने वाले mobile application reverse engineering और analysis tools को एक साथ जोड़ता है, ताकि OWASP mobile security threats के खिलाफ mobile applications का परीक्षण करने में मदद मिल सके। इसका उद्देश्य mobile application developers और security professionals के लिए यह कार्य आसान और अधिक उपयोगकर्ता-मित्रवत बनाना है।

It is able to:

- Extract Java and Smali code using different tools
- Analyze APKs using: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- APK से private information को regexps का उपयोग करके निकालना।
- Manifest का विश्लेषण करना।
- Analyze found domains using: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

मैलवेयर का पता लगाने के लिए उपयोगी: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

ध्यान दें कि जिस service और configuration का आप उपयोग करते हैं कोड को obfuscate करने के लिए, उसके अनुसार secrets obfuscated हो सकते हैं या नहीं भी हो सकते हैं।

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** एक open source command-line tool है जो Java code को shrink, optimize और obfuscate करता है। यह bytecode को optimize करने के साथ-साथ अनउपयोगी instructions का पता लगाने और हटाने में सक्षम है। ProGuard free software है और GNU General Public License, version 2 के अंतर्गत वितरित किया जाता है।

ProGuard Android SDK के हिस्से के रूप में वितरित होता है और application को release mode में बिल्ड करते समय चलता है।

### [DexGuard](https://www.guardsquare.com/dexguard)

APK को deobfuscate करने के लिए step-by-step गाइड यहाँ देखें: [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Last time we checked, the Dexguard mode of operation was:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

आप obfuscated APK को उनके platform पर upload कर सकते हैं।

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

It is a **generic android deobfuscator.** Simplify **virtually executes an app** to understand its behavior and then **tries to optimize the code** so it behaves identically but is easier for a human to understand. Each optimization type is simple and generic, so it doesn't matter what the specific type of obfuscation is used.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD gives you information about **how an APK was made**. It identifies many **compilers**, **packers**, **obfuscators**, and other weird stuff. It's [_PEiD_](https://www.aldeid.com/wiki/PEiD) for Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b एक Android security virtual machine है जो ubuntu-mate पर आधारित है और इसमें latest framework, tutorials और labs का संग्रह शामिल है, जो विभिन्न security geeks और researchers द्वारा reverse engineering और malware analysis के लिए तैयार किए गए हैं।

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) यह संसाधनों की एक शानदार सूची है
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
