# Εφαρμογές Android Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Βασικά για Εφαρμογές Android

Συνιστάται ιδιαίτερα να ξεκινήσετε διαβάζοντας αυτή τη σελίδα για να μάθετε σχετικά με τα **πιο σημαντικά μέρη που σχετίζονται με την ασφάλεια Android και τα πιο επικίνδυνα συστατικά σε μια εφαρμογή Android**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Αυτό είναι το κύριο εργαλείο που χρειάζεστε για να συνδεθείτε με μια συσκευή Android (εξομοιωμένη ή φυσική).\
**ADB** επιτρέπει τον έλεγχο συσκευών είτε μέσω **USB** είτε μέσω **Network** από έναν υπολογιστή. Αυτό το εργαλείο επιτρέπει την **αντιγραφή** αρχείων και στις δύο κατευθύνσεις, την **εγκατάσταση** και **απεγκατάσταση** εφαρμογών, την **εκτέλεση** εντολών shell, την **εφεδρική αποθήκευση** δεδομένων, την **ανάγνωση** αρχείων καταγραφής, μεταξύ άλλων λειτουργιών.

Ρίξτε μια ματιά στην παρακάτω λίστα με [**ADB Commands**](adb-commands.md) για να μάθετε πώς να χρησιμοποιείτε το adb.

## Smali

Μερικές φορές είναι ενδιαφέρον να **τροποποιήσετε τον κώδικα της εφαρμογής** για να αποκτήσετε πρόσβαση σε **κρυφές πληροφορίες** (π.χ. καλά obfuscated passwords ή flags). Σε αυτή την περίπτωση, μπορεί να είναι χρήσιμο να decompile το apk, να τροποποιήσετε τον κώδικα και να το επανασυνθέσετε.\
[**Σε αυτό το tutorial** μπορείτε να **μάθετε πώς να decompile ένα APK, να τροποποιήσετε Smali code και να επανασυνθέσετε το APK** με τη νέα λειτουργικότητα](smali-changes.md). Αυτό μπορεί να είναι πολύ χρήσιμο ως **εναλλακτική για πολλούς ελέγχους κατά τη διάρκεια του dynamic analysis** που πρόκειται να παρουσιαστούν. Έτσι, **κρατήστε πάντα στο μυαλό αυτή τη δυνατότητα**.

## Άλλα ενδιαφέροντα tricks

- [Spoofing της τοποθεσίας σας στο Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [Android IME / InputMethodService Abuse (Malicious Keyboards)](inputmethodservice-ime-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **Λήψη APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Εξαγωγή APK από συσκευή:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Συγχώνευση όλων των splits και base apks με [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Android Enterprise & Work Profile Attacks

{{#ref}}
android-enterprise-work-profile-bypass.md
{{#endref}}

## Case Studies & Vulnerabilities


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

{{#ref}}
abusing-android-media-pipelines-image-parsers.md
{{#endref}}

{{#ref}}
../../binary-exploitation/linux-kernel-exploitation/arm64-static-linear-map-kaslr-bypass.md
{{#endref}}

## Static Analysis

Πρώτα απ' όλα, για την ανάλυση ενός APK θα πρέπει να **ρίξετε μια ματιά στον Java code** χρησιμοποιώντας έναν decompiler.\
Παρακαλώ, [**διάβασε εδώ για πληροφορίες σχετικά με τους διαθέσιμους decompilers**](apk-decompilers.md).

### Looking for interesting Info

Απλώς κοιτάζοντας τα **strings** του APK μπορείς να αναζητήσεις **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** και οτιδήποτε ενδιαφέρον... ψάξε ακόμα για code execution **backdoors** ή authentication backdoors (hardcoded admin credentials στην εφαρμογή).

**Firebase**

Δώσε ιδιαίτερη προσοχή στα **firebase URLs** και έλεγξε αν είναι κακώς διαμορφωμένα. [Περισσότερες πληροφορίες για το τι είναι το Firebase και πώς να το εκμεταλλευτείς εδώ.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Basic understanding of the application - Manifest.xml, strings.xml

Η **εξέταση των αρχείων _Manifest.xml_ και _strings.xml_ μιας εφαρμογής μπορεί να αποκαλύψει πιθανές ευπάθειες ασφάλειας**. Αυτά τα αρχεία μπορούν να ανακτηθούν χρησιμοποιώντας decompilers ή αλλάζοντας την επέκταση του αρχείου APK σε .zip και αποσυμπιέζοντάς το.

**Ευπάθειες** που εντοπίζονται από το **Manifest.xml** περιλαμβάνουν:

- **Debuggable Applications**: Εφαρμογές που έχουν οριστεί ως debuggable (`debuggable="true"`) στο _Manifest.xml_ αποτελούν κίνδυνο καθώς επιτρέπουν συνδέσεις που μπορούν να οδηγήσουν σε εκμετάλλευση. Για περαιτέρω κατανόηση σχετικά με το πώς να εκμεταλλευτείς debuggable applications, ανατρέξτε σε ένα tutorial για την εύρεση και εκμετάλλευση debuggable applications σε μια συσκευή.
- **Backup Settings**: Το attribute `android:allowBackup="false"` θα πρέπει να ορίζεται ρητά για εφαρμογές που χειρίζονται ευαίσθητες πληροφορίες ώστε να αποτρέπονται μη εξουσιοδοτημένα backups δεδομένων μέσω adb, ειδικά όταν το usb debugging είναι ενεργοποιημένο.
- **Network Security**: Εξατομικευμένες ρυθμίσεις network security (`android:networkSecurityConfig="@xml/network_security_config"`) στο _res/xml/_ μπορούν να καθορίσουν λεπτομέρειες ασφάλειας όπως certificate pins και ρυθμίσεις HTTP traffic. Ένα παράδειγμα είναι η επιτρεπόμενη χρήση HTTP traffic για συγκεκριμένα domains.
- **Exported Activities and Services**: Η αναγνώριση exported activities και services στο manifest μπορεί να αναδείξει components που ενδέχεται να αφεθούν σε κακόβουλη χρήση. Περαιτέρω ανάλυση κατά το dynamic testing μπορεί να αποκαλύψει πώς να εκμεταλλευτεί κανείς αυτά τα components.
- **Content Providers and FileProviders**: Εκτεθειμένοι content providers θα μπορούσαν να επιτρέψουν μη εξουσιοδοτημένη πρόσβαση ή τροποποίηση δεδομένων. Η διαμόρφωση των FileProviders πρέπει επίσης να εξεταστεί προσεκτικά.
- **Broadcast Receivers and URL Schemes**: Αυτά τα components θα μπορούσαν να χρησιμοποιηθούν για εκμετάλλευση, με ιδιαίτερη προσοχή στον τρόπο διαχείρισης των URL schemes για πιθανές ευπάθειες εισόδου.
- **SDK Versions**: Τα attributes `minSdkVersion`, `targetSDKVersion`, και `maxSdkVersion` υποδεικνύουν τις υποστηριζόμενες εκδόσεις Android, αναδεικνύοντας τη σημασία του να μην υποστηρίζονται παρωχημένες, ευάλωτες εκδόσεις για λόγους ασφαλείας.

Από το αρχείο **strings.xml**, μπορεί να ανακαλυφθεί ευαίσθητη πληροφορία όπως API keys, custom schemas και άλλες developer σημειώσεις, υπογραμμίζοντας την ανάγκη για προσεκτική επανεξέταση αυτών των πόρων.

### Tapjacking

**Tapjacking** είναι μια επίθεση όπου μια **κακόβουλη** **εφαρμογή** εκκινείται και **τοποθετείται πάνω από μια εφαρμογή-θύμα**. Μόλις επισκιάσει οπτικά την εφαρμογή-θύμα, το user interface της είναι σχεδιασμένο έτσι ώστε να ξεγελά τον χρήστη να αλληλεπιδράσει με αυτό, ενώ ταυτόχρονα μεταβιβάζει την αλληλεπίδραση στην εφαρμογή-θύμα.\
Στην ουσία, **τυφλώνει τον χρήστη ώστε να μην γνωρίζει ότι εκτελεί ενέργειες στην εφαρμογή-θύμα**.

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Μια **activity** με το **`launchMode`** ορισμένο σε **`singleTask` χωρίς καθορισμένο `taskAffinity`** είναι ευάλωτη σε task Hijacking. Αυτό σημαίνει ότι μια **εφαρμογή** μπορεί να εγκατασταθεί και αν εκκινήσει πριν από τη πραγματική εφαρμογή, θα μπορούσε **να αρπάξει το task της πραγματικής εφαρμογής** (έτσι ο χρήστης θα αλληλεπιδρά με την **κακόβουλη εφαρμογή νομίζοντας ότι χρησιμοποιεί τη πραγματική**).

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Insecure data storage

**Internal Storage**

Στο Android, τα αρχεία **αποθηκευμένα** στην **internal** storage σχεδιάζονται να είναι προσβάσιμα αποκλειστικά από την **εφαρμογή** που τα **δημιούργησε**. Αυτό το μέτρο ασφαλείας επιβάλλεται από το λειτουργικό σύστημα και γενικά είναι επαρκές για τις ανάγκες ασφαλείας των περισσοτέρων εφαρμογών. Ωστόσο, οι developers μερικές φορές χρησιμοποιούν modes όπως `MODE_WORLD_READABLE` και `MODE_WORLD_WRITABLE` για να **επιτρέψουν** το μοίρασμα αρχείων μεταξύ διαφορετικών εφαρμογών. Αυτά τα modes **δεν περιορίζουν την πρόσβαση** σε αυτά τα αρχεία από άλλες εφαρμογές, συμπεριλαμβανομένων πιθανώς κακόβουλων.

1. **Static Analysis:**
- **Εξέταση** της χρήσης των `MODE_WORLD_READABLE` και `MODE_WORLD_WRITABLE`. Αυτά τα modes **μπορεί να εκθέσουν** αρχεία σε **μη επιθυμητή ή μη εξουσιοδοτημένη πρόσβαση**.
2. **Dynamic Analysis:**
- **Επαληθεύστε** τα **permissions** που έχουν οριστεί σε αρχεία που δημιουργεί η εφαρμογή. Ειδικά, **ελέγξτε** αν κάποια αρχεία έχει οριστεί να είναι readable ή writable για όλους. Αυτό μπορεί να αποτελεί σημαντικό κίνδυνο ασφάλειας, καθώς θα επέτρεπε **σε οποιαδήποτε εφαρμογή** εγκατεστημένη στη συσκευή, ανεξάρτητα από την προέλευσή της, να **διαβάσει ή να τροποποιήσει** αυτά τα αρχεία.

**External Storage**

Όταν χειρίζεστε αρχεία σε **external storage**, όπως SD Cards, θα πρέπει να ληφθούν ορισμένες προφυλάξεις:

1. **Accessibility**:
- Τα αρχεία στην external storage είναι **προσβάσιμα παγκοσμίως για ανάγνωση και εγγραφή**. Αυτό σημαίνει ότι οποιαδήποτε εφαρμογή ή χρήστης μπορεί να έχει πρόσβαση σε αυτά τα αρχεία.
2. **Security Concerns**:
- Δε συνιστάται να αποθηκεύετε ευαίσθητες πληροφορίες στην external storage λόγω της ευκολίας πρόσβασης.
- Η external storage μπορεί να αφαιρεθεί ή να προσπελαστεί από οποιαδήποτε εφαρμογή, καθιστώντας την λιγότερο ασφαλή.
3. **Handling Data from External Storage**:
- Πάντοτε πραγματοποιείτε **έλεγχο εισόδου (input validation)** στα δεδομένα που ανακτώνται από την external storage. Αυτό είναι κρίσιμο γιατί τα δεδομένα προέρχονται από μη αξιόπιστη πηγή.
- Η αποθήκευση εκτελέσιμων αρχείων ή αρχείων κλάσεων στην external storage για dynamic loading αποθαρρύνεται έντονα.
- Εάν η εφαρμογή σας πρέπει να ανακτά εκτελέσιμα από την external storage, βεβαιωθείτε ότι αυτά τα αρχεία είναι **υπογεγραμμένα και κρυπτογραφικά επαληθευμένα** πριν να φορτωθούν δυναμικά. Αυτό το βήμα είναι ζωτικής σημασίας για τη διατήρηση της ασφάλειας της εφαρμογής σας.

External storage μπορεί να **προσπελαστεί** σε `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> Ξεκινώντας από το Android 4.4 (**API 17**), η SD κάρτα έχει μια δομή φακέλων που **περιορίζει την πρόσβαση μιας app μόνο στον κατάλογο που είναι αφιερωμένος στην εν λόγω app**. Αυτό αποτρέπει μια κακόβουλη εφαρμογή από το να αποκτήσει read ή write πρόσβαση στα αρχεία μιας άλλης εφαρμογής.

**Sensitive data stored in clear-text**

- **Shared preferences**: Το Android επιτρέπει σε κάθε εφαρμογή να αποθηκεύει εύκολα xml αρχεία στη διαδρομή `/data/data/<packagename>/shared_prefs/` και μερικές φορές είναι πιθανό να βρεθεί ευαίσθητη πληροφορία σε απλό κείμενο σε αυτόν τον φάκελο.
- **Databases**: Το Android επιτρέπει σε κάθε εφαρμογή να αποθηκεύει εύκολα sqlite βάσεις δεδομένων στη διαδρομή `/data/data/<packagename>/databases/` και μερικές φορές είναι πιθανό να βρεθεί ευαίσθητη πληροφορία σε απλό κείμενο σε αυτόν τον φάκελο.

### Broken TLS

**Accept All Certificates**

Για κάποιο λόγο μερικές φορές οι developers αποδέχονται όλα τα πιστοποιητικά ακόμα και αν, για παράδειγμα, το hostname δεν ταιριάζει, με γραμμές κώδικα όπως η παρακάτω:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Broken Cryptography

**Poor Key Management Processes**

Κάποιοι developers αποθηκεύουν ευαίσθητα δεδομένα στο local storage και τα κρυπτογραφούν με ένα key hardcoded/προβλέψιμο στον κώδικα. Αυτό δεν θα έπρεπε να γίνεται, διότι κάποια reversing θα μπορούσε να επιτρέψει σε attackers να εξάγουν τις confidential πληροφορίες.

**Use of Insecure and/or Deprecated Algorithms**

Developers δεν θα έπρεπε να χρησιμοποιούν **deprecated algorithms** για να πραγματοποιούν authorisation **checks**, **store** ή **send** δεδομένα. Μερικοί από αυτούς τους αλγορίθμους είναι: RC4, MD4, MD5, SHA1... Αν χρησιμοποιούνται **hashes** για να αποθηκεύσουν passwords για παράδειγμα, θα πρέπει να χρησιμοποιούνται hash algorithms ανθεκτικοί σε brute-force με salt.

### Other checks

- It's recommended to **obfuscate the APK** to difficult the reverse engineer labour to attackers.
- Αν η app είναι sensitive (όπως bank apps), θα πρέπει να εκτελεί δικούς της **checks για να δει αν το mobile είναι rooted** και να ενεργεί ανάλογα.
- Αν η app είναι sensitive (όπως bank apps), θα πρέπει να ελέγχει αν χρησιμοποιείται **emulator**.
- Αν η app είναι sensitive (όπως bank apps), θα πρέπει να **ελέγχει την integrity της πριν την εκτέλεση** για να διαπιστώσει αν έχει τροποποιηθεί.
- Use [**APKiD**](https://github.com/rednaga/APKiD) για να ελέγξετε ποιος compiler/packer/obfuscator χρησιμοποιήθηκε για να χτιστεί το APK

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. Το blog αναφέρεται στην πιθανότητα δημιουργίας μιας app που θα decompress αυτούς τους τύπους εφαρμογών... και σε έναν ταχύτερο τρόπο που περιλαμβάνει το **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

Το εργαλείο [**mariana-trench**](https://github.com/facebook/mariana-trench) μπορεί να βρει **vulnerabilities** κάνοντας **scanning** του **code** της εφαρμογής. Αυτό το εργαλείο περιέχει μια σειρά από **known sources** (που υποδεικνύουν στο εργαλείο τα **places** όπου το **input** **ελέγχεται από τον χρήστη**), **sinks** (που υποδεικνύουν στο εργαλείο **dangerous** **places** όπου malicious user input θα μπορούσε να προκαλέσει ζημιά) και **rules**. Αυτοί οι κανόνες υποδεικνύουν τον **συνδυασμό** **sources-sinks** που σηματοδοτεί μια vulnerability.

Με αυτή τη γνώση, **mariana-trench θα αναθεωρήσει τον κώδικα και θα βρει πιθανές vulnerabilities πάνω σε αυτόν**.

### Secrets leaked

Μια εφαρμογή μπορεί να περιέχει secrets (API keys, passwords, hidden urls, subdomains...) μέσα της που μπορεί να ανακαλύψετε. Μπορείτε να χρησιμοποιήσετε ένα εργαλείο όπως [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)
- In-memory native code execution via JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> First of all, you need an environment where you can install the application and all the environment (Burp CA cert, Drozer and Frida mainly). Therefore, a rooted device (emulated or not) is extremely recommended.

### Online Dynamic analysis

Μπορείτε να δημιουργήσετε ένα **free account** σε: [https://appetize.io/](https://appetize.io). Αυτή η πλατφόρμα σας επιτρέπει να **upload** και να **execute** APKs, οπότε είναι χρήσιμη για να δείτε πώς συμπεριφέρεται ένα apk.

Μπορείτε ακόμη να **δείτε τα logs της εφαρμογής σας** στο web και να συνδεθείτε μέσω **adb**.

![](<../../images/image (831).png>)

Χάρη στη σύνδεση ADB μπορείτε να χρησιμοποιήσετε **Drozer** και **Frida** μέσα στους emulators.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (Μπορείτε να δημιουργήσετε **x86** και **arm** συσκευές, και σύμφωνα με [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** versions **support ARM libraries** χωρίς να χρειάζεται ο αργός arm emulator).
- Learn to set it up in this page:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, χρειάζεται να δημιουργήσετε account. _Συστήνεται να **download** την έκδοση **WITH**_ _**VirtualBox** για να αποφύγετε πιθανά errors._)
- [**Nox**](https://es.bignox.com) (Free, αλλά δεν υποστηρίζει Frida ή Drozer).

> [!TIP]
> Όταν δημιουργείτε νέο emulator σε οποιαδήποτε πλατφόρμα θυμηθείτε ότι όσο μεγαλύτερη είναι η οθόνη, τόσο πιο αργά θα τρέχει ο emulator. Οπότε επιλέξτε μικρές οθόνες αν είναι δυνατόν.

Για να **install google services** (όπως AppStore) σε Genymotion χρειάζεται να κάνετε κλικ στο κόκκινο κουμπί της επόμενης εικόνας:

![](<../../images/image (277).png>)

Επίσης, σημειώστε ότι στην **configuration του Android VM στο Genymotion** μπορείτε να επιλέξετε **Bridge Network mode** (αυτό θα είναι χρήσιμο αν θα συνδέεστε στο Android VM από διαφορετικό VM με τα tools).

#### Use a physical device

Πρέπει να ενεργοποιήσετε τις επιλογές **debugging** και είναι προτιμότερο αν μπορείτε να το **root**:

1. **Settings**.
2. (FromAndroid 8.0) Επιλέξτε **System**.
3. Επιλέξτε **About phone**.
4. Πατήστε **Build number** 7 φορές.
5. Επιστρέψτε πίσω και θα βρείτε τις **Developer options**.

> Μόλις εγκαταστήσετε την εφαρμογή, το πρώτο που πρέπει να κάνετε είναι να τη δοκιμάσετε και να ερευνήσετε τι κάνει, πώς λειτουργεί και να εξοικειωθείτε με αυτή.\
> Προτείνω να **perform this initial dynamic analysis using MobSF dynamic analysis + pidcat**, ώστε να μπορέσουμε να **learn how the application works** ενώ το MobSF **captures** πολλά **interesting** **data** που μπορείτε να εξετάσετε αργότερα.

Magisk/Zygisk quick notes (recommended on Pixel devices)
- Patch boot.img with the Magisk app and flash via fastboot to get systemless root
- Enable Zygisk + DenyList for root hiding; consider LSPosed/Shamiko when stronger hiding is required
- Keep original boot.img to recover from OTA updates; re-patch after each OTA
- For screen mirroring, use scrcpy on the host



### Unintended Data Leakage

**Logging**

Οι developers πρέπει να είναι προσεκτικοί να μην εκθέτουν **debugging information** δημόσια, καθώς αυτό μπορεί να οδηγήσει σε sensitive data leaks. Τα εργαλεία [**pidcat**](https://github.com/JakeWharton/pidcat) και `adb logcat` συνιστώνται για monitoring των application logs ώστε να εντοπίζονται και να προστατεύονται ευαίσθητες πληροφορίες. Το **Pidcat** προτιμάται για την ευκολία χρήσης και την αναγνωσιμότητα.

> [!WARNING]
> Σημειώστε ότι από **later newer than Android 4.0**, **applications are only able to access their own logs**. Έτσι οι εφαρμογές δεν μπορούν να έχουν πρόσβαση σε logs άλλων apps.\
> Παρ' όλα αυτά, εξακολουθεί να συνιστάται να **μην καταγράφονται ευαίσθητες πληροφορίες**.

**Copy/Paste Buffer Caching**

Το **clipboard-based** framework του Android επιτρέπει λειτουργίες αντιγραφής-επικόλλησης στις εφαρμογές, αλλά αποτελεί ρίσκο καθώς **other applications** μπορούν να **access** το clipboard, ενδεχομένως εκθέτοντας ευαίσθητα δεδομένα. Είναι κρίσιμο να **disable copy/paste** λειτουργίες για ευαίσθητα τμήματα της εφαρμογής, όπως στοιχεία πιστωτικής κάρτας, για να αποφευχθούν data leaks.

**Crash Logs**

Αν μια εφαρμογή **crashes** και **saves logs**, αυτά τα logs μπορούν να βοηθήσουν attackers, ιδίως όταν η εφαρμογή δεν μπορεί να γίνει reverse-engineered. Για να μειώσετε αυτόν τον κίνδυνο, αποφύγετε το logging κατά τα crashes, και αν logs πρέπει να σταλούν μέσω δικτύου, βεβαιωθείτε ότι αποστέλλονται μέσω κανάλι SSL για ασφάλεια.

Ως pentester, **try to take a look to these logs**.

**Analytics Data Sent To 3rd Parties**

Οι εφαρμογές συχνά ενσωματώνουν services όπως Google Adsense, τα οποία μπορούν ακούσια να **leak sensitive data** λόγω εσφαλμένης υλοποίησης από τους developers. Για να εντοπίσετε πιθανές διαρροές, συνιστάται να **intercept the application's traffic** και να ελέγξετε αν αποστέλλονται ευαίσθητες πληροφορίες σε third-party services.

### SQLite DBs

Οι περισσότερες εφαρμογές θα χρησιμοποιήσουν **internal SQLite databases** για να αποθηκεύσουν πληροφορίες. Κατά το pentest κοιτάξτε τις **databases** που δημιουργούνται, τα ονόματα των **tables** και **columns** και όλα τα **data** που αποθηκεύονται γιατί μπορεί να βρείτε **sensitive information** (που θα ήταν vulnerability).\
Οι βάσεις δεδομένων θα πρέπει να βρίσκονται στο `/data/data/the.package.name/databases` όπως `/data/data/com.mwr.example.sieve/databases`

Αν η βάση δεδομένων αποθηκεύει confidential πληροφορίες και είναι **encrypted b**ut μπορείτε να **find** το **password** μέσα στην εφαρμογή είναι ακόμα μια **vulnerability**.

Καταγράψτε τα tables χρησιμοποιώντας `.tables` και τις στήλες των tables με `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

Από τα [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** σας επιτρέπει να **assume the role of an Android app** και να αλληλεπιδράσετε με άλλες apps. Μπορεί να κάνει **anything that an installed application can do**, όπως να χρησιμοποιήσει το Android’s Inter-Process Communication (IPC) μηχανισμό και να αλληλεπιδράσει με το underlying operating system. .\
Το Drozer είναι ένα χρήσιμο εργαλείο για να **exploit exported activities, exported services and Content Providers** όπως θα μάθετε στις επόμενες ενότητες.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Θυμηθείτε επίσης ότι ο κώδικας μιας activity ξεκινάει στη μέθοδο **`onCreate`**.

**Authorisation bypass**

Όταν μια Activity είναι exported μπορείτε να καλέσετε την οθόνη της από μια εξωτερική app. Επομένως, αν μια activity με **sensitive information** είναι **exported** θα μπορούσατε να **bypass** τους **authentication** μηχανισμούς για να έχετε πρόσβαση σε αυτήν.

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

Μπορείτε επίσης να ξεκινήσετε μια exported activity από adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**ΣΗΜΕΙΩΣΗ**: Το MobSF θα ανιχνεύσει ως κακόβουλη τη χρήση του _**singleTask/singleInstance**_ ως `android:launchMode` σε μια activity, αλλά λόγω [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), προφανώς αυτό είναι επικίνδυνο μόνο σε παλιές εκδόσεις (API versions < 21).

> [!TIP]
> Σημείωσε ότι μια παράκαμψη εξουσιοδότησης δεν είναι πάντα μια ευπάθεια — εξαρτάται από το πώς λειτουργεί η παράκαμψη και ποιες πληροφορίες εκτίθενται.

**Διαρροή ευαίσθητων πληροφοριών**

**Activities μπορούν επίσης να επιστρέψουν αποτελέσματα**. Αν καταφέρεις να βρεις μια exported και μη προστατευμένη activity που καλεί τη μέθοδο **`setResult`** και **επιστρέφει ευαίσθητες πληροφορίες**, υπάρχει διαρροή ευαίσθητων πληροφοριών.

#### Tapjacking

Εάν το tapjacking δεν αποτρέπεται, μπορείς να καταχραστείς την exported activity για να κάνεις τον **χρήστη να εκτελέσει απροσδόκητες ενέργειες**. Για περισσότερες πληροφορίες σχετικά με [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Πρόσβαση και χειρισμός ευαίσθητων πληροφοριών

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Οι Content providers χρησιμοποιούνται βασικά για να μοιράζονται δεδομένα. Αν μια εφαρμογή διαθέτει content providers μπορεί να καταφέρεις να **εξάγεις ευαίσθητα** δεδομένα από αυτούς. Επίσης είναι ενδιαφέρον να δοκιμάσεις πιθανές **SQL injections** και **Path Traversals** καθώς μπορεί να είναι ευάλωτες.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Θυμήσου ότι οι ενέργειες ενός Service αρχίζουν στη μέθοδο `onStartCommand`.

Ένα service είναι βασικά κάτι που **μπορεί να λαμβάνει δεδομένα**, τα **επεξεργάζεται** και **επιστρέφει** (ή όχι) μια απάντηση. Επομένως, αν μια εφαρμογή εξάγει κάποια services, πρέπει να **ελέγξεις** τον **κώδικα** για να καταλάβεις τι κάνει και να το **δοκιμάσεις** **δυναμικά** για εξαγωγή εμπιστευτικών πληροφοριών, παράκαμψη μέτρων αυθεντικοποίησης...\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Θυμήσου ότι οι ενέργειες ενός Broadcast Receiver ξεκινούν στη μέθοδο `onReceive`.

Ένας broadcast receiver θα περιμένει έναν τύπο μηνύματος. Ανάλογα με το πώς ο receiver χειρίζεται το μήνυμα, μπορεί να είναι ευάλωτος.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Μπορείς να ψάξεις για deep links χειροκίνητα, χρησιμοποιώντας εργαλεία όπως το MobSF ή scripts όπως [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Μπορείς να **ανοίξεις** ένα δηλωμένο **scheme** χρησιμοποιώντας **adb** ή έναν **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Σημειώστε ότι μπορείτε να **παραλείψετε το όνομα του πακέτου** και το κινητό θα καλέσει αυτόματα την εφαρμογή που πρέπει να ανοίξει αυτόν τον σύνδεσμο._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Κώδικας που εκτελείται**

Για να βρείτε τον **κώδικα που θα εκτελεστεί στην App**, πηγαίνετε στην activity που καλείται από το deeplink και αναζητήστε τη συνάρτηση **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Ευαίσθητες πληροφορίες**

Κάθε φορά που βρίσκετε ένα deep link ελέγξτε ότι **δεν λαμβάνει ευαίσθητα δεδομένα (όπως passwords) μέσω URL parameters**, γιατί οποιαδήποτε άλλη εφαρμογή θα μπορούσε να **προσποιηθεί το deep link και να κλέψει αυτά τα δεδομένα!**

**Παράμετροι στο path**

You **must check also if any deep link is using a parameter inside the path** of the URL like: `https://api.example.com/v1/users/{username}` , in that case you can force a path traversal accessing something like: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Note that if you find the correct endpoints inside the application you may be able to cause a **Open Redirect** (if part of the path is used as domain name), **account takeover** (if you can modify users details without CSRF token and the vuln endpoint used the correct method) and any other vuln. More [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Transport Layer Inspection and Verification Failures

- **Τα certificates δεν επιθεωρούνται πάντα σωστά** από Android applications. Είναι σύνηθες αυτές οι εφαρμογές να αγνοούν προειδοποιήσεις και να αποδέχονται self-signed certificates ή, σε ορισμένες περιπτώσεις, να επανέρχονται σε HTTP connections.
- **Negotiations during the SSL/TLS handshake are sometimes weak**, χρησιμοποιώντας μη ασφαλείς cipher suites. Αυτή η ευπάθεια καθιστά τη σύνδεση ευάλωτη σε man-in-the-middle (MITM) attacks, επιτρέποντας στους επιτιθέμενους να αποκρυπτογραφήσουν τα δεδομένα.
- **Διαρροή ιδιωτικών πληροφοριών** αποτελεί ρίσκο όταν οι εφαρμογές αυθεντικοποιούνται χρησιμοποιώντας secure channels αλλά στη συνέχεια επικοινωνούν μέσω non-secure channels για άλλες συναλλαγές. Αυτή η προσέγγιση δεν προστατεύει sensitive data, όπως session cookies ή στοιχεία χρήστη, από υποκλοπή από κακόβουλους παράγοντες.

#### Certificate Verification

We will focus on **certificate verification**. The integrity of the server's certificate must be verified to enhance security. This is crucial because insecure TLS configurations and the transmission of sensitive data over unencrypted channels can pose significant risks. For detailed steps on verifying server certificates and addressing vulnerabilities, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) provides comprehensive guidance.

#### SSL Pinning

SSL Pinning is a security measure where the application verifies the server's certificate against a known copy stored within the application itself. This method is essential for preventing MITM attacks. Implementing SSL Pinning is strongly recommended for applications handling sensitive information.

#### Traffic Inspection

Για να επιθεωρήσετε HTTP traffic, είναι απαραίτητο να **εγκαταστήσετε το proxy tool's certificate** (π.χ. Burp). Χωρίς την εγκατάσταση αυτού του certificate, το κρυπτογραφημένο traffic ενδέχεται να μην είναι ορατό μέσω του proxy. Για οδηγίες σχετικά με την εγκατάσταση ενός custom CA certificate, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Applications targeting **API Level 24 and above** require modifications to the Network Security Config to accept the proxy's CA certificate. This step is critical for inspecting encrypted traffic. For instructions on modifying the Network Security Config, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

If **Flutter** is being used you need to to follow the instructions in [**this page**](flutter.md). This is becasue, just adding the certificate into the store won't work as Flutter has its own list of valid CAs.

#### Static detection of SSL/TLS pinning

Πριν επιχειρήσετε runtime bypasses, χαρτογραφήστε γρήγορα πού επιβάλλεται το pinning στο APK. Η στατική ανακάλυψη βοηθά να σχεδιάσετε hooks/patches και να επικεντρωθείτε στα σωστά code paths.

Tool: SSLPinDetect
- Open-source static-analysis utility that decompiles the APK to Smali (via apktool) and scans for curated regex patterns of SSL/TLS pinning implementations.
- Reports exact file path, line number, and a code snippet for each match.
- Covers common frameworks and custom code paths: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

Εγκατάσταση
- Απαιτούμενα: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Χρήση
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Παραδείγματα κανόνων pattern (JSON)
Χρησιμοποιήστε ή επεκτείνετε τις signatures για να εντοπίσετε proprietary/custom pinning styles. Μπορείτε να φορτώσετε το δικό σας JSON και να κάνετε scan σε μεγάλη κλίμακα.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Σημειώσεις και συμβουλές
- Fast scanning on large apps via multi-threading and memory-mapped I/O; pre-compiled regex reduces overhead/false positives.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Typical detection targets to triage next:
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Declarative pins in res/xml network security config and manifest references
- Use the matched locations to plan Frida hooks, static patches, or config reviews before dynamic testing.



#### Παράκαμψη SSL Pinning

Όταν έχει εφαρμοστεί SSL Pinning, η παράκαμψή του γίνεται απαραίτητη για την επιθεώρηση της HTTPS κίνησης. Υπάρχουν διάφορες μέθοδοι για αυτόν τον σκοπό:

- Automatically **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). The best pro of this option, is that you won't need root to bypass the SSL Pinning, but you will need to delete the application and reinstall the new one, and this won't always work.
- You could use **Frida** (discussed below) to bypass this protection. Here you have a guide to use Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- You can also try to **automatically bypass SSL Pinning** using [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- You can also try to **automatically bypass SSL Pinning** using **MobSF dynamic analysis** (explained below)
- If you still think that there is some traffic that you aren't capturing you can try to **forward the traffic to burp using iptables**. Read this blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Looking for Common Web Vulnerabilities

Είναι σημαντικό να ψάξετε επίσης για κοινές web ευπάθειες μέσα στην εφαρμογή. Λεπτομέρειες σχετικά με τον εντοπισμό και την αντιμετώπιση αυτών των ευπαθειών ξεπερνούν το πεδίο αυτής της περίληψης, αλλά καλύπτονται εκτενώς αλλού.

### Frida

[Frida](https://www.frida.re) είναι ένα δυναμικό instrumentation toolkit για προγραμματιστές, αναλυτές αντίστροφης μηχανικής και ερευνητές ασφαλείας.\
**Μπορείτε να έχετε πρόσβαση στην τρέχουσα εφαρμογή και να κάνετε hook μεθόδους κατά το runtime για να αλλάξετε τη συμπεριφορά, να αλλάξετε τιμές, να εξάγετε τιμές, να τρέξετε διαφορετικό κώδικα...**\
Αν θέλεις να pentest εφαρμογές Android πρέπει να ξέρεις να χρησιμοποιείς Frida.

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Some "GUI" for actions with Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- You can find some Awesome Frida scripts here: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Try to bypass anti-debugging / anti-frida mechanisms loading Frida as in indicated in [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump μνήμης - Fridump**

Έλεγξε αν η εφαρμογή αποθηκεύει ευαίσθητες πληροφορίες στη μνήμη που δεν θα έπρεπε, όπως passwords ή mnemonics.

Using [**Fridump3**](https://github.com/rootbsd/fridump3) you can dump the memory of the app with:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Αυτό θα dump τη μνήμη στον φάκελο ./dump, και εκεί μπορείτε να κάνετε grep με κάτι σαν:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Ευαίσθητα δεδομένα στο Keystore**

Στο Android το Keystore είναι το καλύτερο μέρος για αποθήκευση ευαίσθητων δεδομένων, όμως με επαρκή προνόμια είναι ακόμα **δυνατό να αποκτηθεί πρόσβαση σε αυτό**. Καθώς οι εφαρμογές τείνουν να αποθηκεύουν εδώ **ευαίσθητα δεδομένα σε απλό κείμενο**, οι pentests πρέπει να το ελέγξουν, καθώς ένας root user ή κάποιος με φυσική πρόσβαση στη συσκευή θα μπορούσε να κλέψει αυτά τα δεδομένα.

Ακόμα κι αν μια εφαρμογή αποθήκευσε δεδομένα στο keystore, τα δεδομένα πρέπει να είναι κρυπτογραφημένα.

Για να αποκτήσετε πρόσβαση στα δεδομένα μέσα στο keystore μπορείτε να χρησιμοποιήσετε αυτό το Frida script: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Χρησιμοποιώντας το παρακάτω Frida script, μπορεί να είναι δυνατό να **bypass fingerprint authentication** που ίσως εκτελούν οι εφαρμογές Android προκειμένου να **προστατεύσουν ορισμένες ευαίσθητες περιοχές:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Εικόνες στο παρασκήνιο**

Όταν βάζεις μια εφαρμογή στο παρασκήνιο, Android αποθηκεύει ένα **snapshot της εφαρμογής**, έτσι ώστε όταν επανέλθει στο προσκήνιο να φορτώνει πρώτα την εικόνα πριν την εφαρμογή, κάνοντας να φαίνεται ότι η εφαρμογή φόρτωσε πιο γρήγορα.

Ωστόσο, αν αυτό το snapshot περιέχει **ευαίσθητες πληροφορίες**, κάποιος με πρόσβαση στο snapshot μπορεί να **κλέψει αυτές τις πληροφορίες** (σημείωση ότι χρειάζεσαι root για να έχεις πρόσβαση).

Τα snapshots συνήθως αποθηκεύονται στο: **`/data/system_ce/0/snapshots`**

Το Android παρέχει έναν τρόπο να **αποτρέψει την καταγραφή screenshots θέτοντας την παράμετρο διάταξης FLAG_SECURE**. Χρησιμοποιώντας αυτή τη σημαία, το περιεχόμενο του παραθύρου θεωρείται ασφαλές, αποτρέποντας την εμφάνισή του σε screenshots ή την προβολή του σε μη ασφαλείς οθόνες.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Αναλυτής Εφαρμογών Android**

Αυτό το εργαλείο μπορεί να σας βοηθήσει στη διαχείριση διαφόρων εργαλείων κατά τη δυναμική ανάλυση: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Οι προγραμματιστές συχνά δημιουργούν proxy components όπως activities, services και broadcast receivers που χειρίζονται αυτά τα Intents και τα περνούν σε μεθόδους όπως `startActivity(...)` ή `sendBroadcast(...)`, κάτι που μπορεί να είναι επικίνδυνο.

Ο κίνδυνος προκύπτει από το να επιτρέπεις σε επιτιθέμενους να ενεργοποιήσουν non-exported app components ή να έχουν πρόσβαση σε ευαίσθητους content providers κατευθύνοντας λανθασμένα αυτά τα Intents. Ένα αξιοσημείωτο παράδειγμα είναι το `WebView` component που μετατρέπει URLs σε `Intent` αντικείμενα μέσω `Intent.parseUri(...)` και στη συνέχεια τα εκτελεί, οδηγώντας ενδεχομένως σε malicious Intent injections.

### Essential Takeaways

- **Intent Injection** είναι παρόμοιο με το Open Redirect στο web.
- Τα exploits περιλαμβάνουν τη διέλευση `Intent` αντικειμένων ως extras, τα οποία μπορούν να ανακατευθυνθούν για να εκτελέσουν unsafe operations.
- Μπορεί να εκθέσει non-exported components και content providers σε attackers.
- Η μετατροπή URL σε `Intent` από το `WebView` μπορεί να διευκολύνει ανεπιθύμητες ενέργειες.

### Android Client Side Injections and others

Πιθανόν να γνωρίζετε αυτό το είδος ευπαθειών από τον Web. Πρέπει να είστε ιδιαίτερα προσεκτικοί με αυτές τις ευπάθειες σε μια Android εφαρμογή:

- **SQL Injection:** Όταν χειρίζεστε δυναμικά queries ή Content-Providers, βεβαιωθείτε ότι χρησιμοποιείτε parameterized queries.
- **JavaScript Injection (XSS):** Επαληθεύστε ότι το JavaScript και η υποστήριξη Plugin είναι disabled για οποιαδήποτε WebViews (disabled by default). [Περισσότερα εδώ](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** Τα WebViews θα πρέπει να έχουν απενεργοποιημένη την πρόσβαση στο file system (enabled by default) - `(webview.getSettings().setAllowFileAccess(false);)`. [Περισσότερα εδώ](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: Σε αρκετές περιπτώσεις όταν η Android εφαρμογή τερματίζει τη συνεδρία, το cookie δεν ανακαλείται ή μπορεί ακόμη να αποθηκευτεί στο δίσκο.
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Αυτόματη Ανάλυση

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Στατική ανάλυση**

![](<../../images/image (866).png>)

**Αξιολόγηση ευπαθειών της εφαρμογής** χρησιμοποιώντας ένα ωραίο διαδικτυακό frontend. Μπορείτε επίσης να εκτελέσετε δυναμική ανάλυση (αλλά πρέπει να προετοιμάσετε το περιβάλλον).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Assisted Dynamic analysis with MobSF

**MobSF** can also be very helpful for **dynamic analysis** in **Android**, but in that case you will need to install MobSF and **genymotion** in your host (a VM or Docker won't work). _Σημείωση: Πρέπει να **start first a VM in genymotion** and **then MobSF.**_\
The **MobSF dynamic analyser** can:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). Όλα αυτά γίνονται αυτόματα εκτός από τα screenshots — πρέπει να πατήσετε όταν θέλετε ένα screenshot ή να πατήσετε "**Exported Activity Tester**" για να πάρετε screenshots όλων των exported activities.
- Καταγράψει **HTTPS traffic**
- Χρησιμοποιήσει **Frida** για να αποκτήσει **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: Εκτυπώνει όλες τις φορτωμένες κλάσεις
- **Capture Strings**: Εκτυπώνει όλα τα capture strings όσο χρησιμοποιείτε την εφαρμογή (πολύ θορυβώδες)
- **Capture String Comparisons**: Μπορεί να είναι πολύ χρήσιμο. Θα **show the 2 strings being compared** και αν το αποτέλεσμα ήταν True ή False.
- **Enumerate Class Methods**: Βάλτε το όνομα της κλάσης (π.χ. "java.io.File") και θα εκτυπώσει όλες τις μεθόδους της κλάσης.
- **Search Class Pattern**: Αναζητά κλάσεις με pattern
- **Trace Class Methods**: **Trace** μια **whole class** (βλέπε εισόδους και εξόδους όλων των μεθόδων της κλάσης). Θυμηθείτε ότι από προεπιλογή το MobSF traces αρκετές ενδιαφέρουσες Android Api methods.

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf also brings you a shell with some **adb** commands, **MobSF commands**, and common **shell** **commands** at the bottom of the dynamic analysis page. Some interesting commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP εργαλεία**

When http traffic is capture you can see an ugly view of the captured traffic on "**HTTP(S) Traffic**" bottom or a nicer view in "**Start HTTPTools**" green bottom. From the second option, you can **send** the **captured requests** to **proxies** like Burp or Owasp ZAP.\
To do so, _ενεργοποίησε Burp -->_ _απενεργοποίησε το Intercept --> στο MobSB HTTPTools επίλεξε το request_ --> πάτησε "**Send to Fuzzer**" --> _επίλεξε τη διεύθυνση proxy_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Once you finish the dynamic analysis with MobSF you can press on "**Start Web API Fuzzer**" to **fuzz http requests** an look for vulnerabilities.

> [!TIP]
> Μετά από dynamic analysis με MobSF οι ρυθμίσεις proxy μπορεί να είναι misconfigured και δεν θα μπορείς να τις διορθώσεις από το GUI. Μπορείς να διορθώσεις τις ρυθμίσεις proxy εκτελώντας:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Βοηθημένη Dynamic Analysis με Inspeckage

You can get the tool from [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Το εργαλείο αυτό θα χρησιμοποιήσει ορισμένα **Hooks** για να σε ενημερώνει **για το τι συμβαίνει στην εφαρμογή** ενώ εκτελείς **dynamic analysis**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Αυτό είναι ένα **εξαιρετικό εργαλείο για να πραγματοποιήσεις static analysis με GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Αυτό το εργαλείο έχει σχεδιαστεί για να εντοπίζει διάφορες **security related Android application vulnerabilities**, είτε σε **source code** είτε σε **packaged APKs**. Το εργαλείο είναι επίσης **capable of creating a "Proof-of-Concept" deployable APK** και **ADB commands**, για να εκμεταλλευτεί μερικές από τις ευπάθειες που βρέθηκαν (Exposed activities, intents, tapjacking...). Όπως με το Drozer, δεν υπάρχει ανάγκη να κάνεις root τη συσκευή δοκιμής.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Εμφανίζει όλα τα εξαγόμενα αρχεία για εύκολη αναφορά
- Απομεταγλωττίζει αυτόματα αρχεία APK σε μορφή Java και Smali
- Αναλύει το AndroidManifest.xml για κοινές ευπάθειες και συμπεριφορά
- Στατική ανάλυση πηγαίου κώδικα για κοινές ευπάθειες και συμπεριφορά
- Πληροφορίες συσκευής
- και άλλα
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

Το SUPER είναι μια εφαρμογή γραμμής εντολών που μπορεί να χρησιμοποιηθεί σε Windows, MacOS X και Linux, η οποία αναλύει αρχεία _.apk_ αναζητώντας ευπάθειες. Το κάνει αποσυμπιέζοντας τα APKs και εφαρμόζοντας μια σειρά κανόνων για να εντοπίσει αυτές τις ευπάθειες.

Όλοι οι κανόνες βρίσκονται σε ένα αρχείο `rules.json`, και κάθε εταιρεία ή tester μπορεί να δημιουργήσει τους δικούς της κανόνες για να αναλύσει ό,τι χρειάζεται.

Κατεβάστε τα τελευταία binaries από τη [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn είναι ένα **crossplatform** εργαλείο που βοηθά προγραμματιστές, bugbounty hunters και ethical hackers να εκτελούν [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) σε mobile εφαρμογές.

Η ιδέα είναι ότι σύρεις και αποθέτεις το αρχείο της mobile εφαρμογής σου (.apk ή .ipa) στην εφαρμογή StaCoAn και αυτή θα δημιουργήσει για εσένα μια οπτική και φορητή αναφορά. Μπορείς να προσαρμόσεις τις ρυθμίσεις και τις wordlists για να έχεις μια εξατομικευμένη εμπειρία.

Λήψη[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework είναι ένα σύστημα ανάλυσης ευπαθειών για Android που βοηθά προγραμματιστές ή hackers να εντοπίσουν πιθανές ευπάθειες ασφαλείας σε εφαρμογές Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** είναι ένα εργαλείο του οποίου ο κύριος στόχος είναι να εντοπίζει και να προειδοποιεί τον χρήστη για πιθανές κακόβουλες συμπεριφορές που αναπτύσσονται από μια Android εφαρμογή.

Η ανίχνευση γίνεται μέσω της **static analysis** του Dalvik bytecode της εφαρμογής, που αναπαρίσταται ως **Smali**, χρησιμοποιώντας τη βιβλιοθήκη [`androguard`](https://github.com/androguard/androguard).

Το εργαλείο αυτό αναζητά **κοινή συμπεριφορά των «κακόβουλων» εφαρμογών** όπως: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. Είναι ένα εργαλείο που συγκεντρώνει συνήθως χρησιμοποιούμενα εργαλεία mobile application reverse engineering και analysis, για να βοηθήσει στον έλεγχο mobile applications απέναντι στις OWASP mobile security απειλές. Στόχος του είναι να κάνει αυτή την εργασία πιο εύκολη και φιλική προς τους mobile application developers και security professionals.

Μπορεί να:

- Extract Java and Smali code using different tools
- Analyze APKs using: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Extract private information from the APK using regexps.
- Analyze the Manifest.
- Analyze found domains using: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Χρήσιμο για την ανίχνευση malware: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Σημειώστε ότι, ανάλογα με την υπηρεσία και τη διαμόρφωση που χρησιμοποιείτε για να obfuscate τον κώδικα, τα secrets μπορεί ή να μην καταλήξουν obfuscated.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. It is able to optimize bytecode as well as detect and remove unused instructions. ProGuard is free software and is distributed under the GNU General Public License, version 2.

Το ProGuard διανέμεται ως μέρος του Android SDK και εκτελείται όταν γίνεται build της εφαρμογής σε release mode.

### [DexGuard](https://www.guardsquare.com/dexguard)

Βρείτε έναν οδηγό βήμα-προς-βήμα για να deobfuscate το apk στο [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Last time we checked, the Dexguard mode of operation was:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

Μπορείτε να ανεβάσετε ένα obfuscated APK στην πλατφόρμα τους.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

Αυτό είναι ένα LLM εργαλείο για να εντοπίσει πιθανές security vulnerabilities σε android apps και να deobfuscate τον κώδικα android εφαρμογών. Χρησιμοποιεί το Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

Είναι ένας **generic android deobfuscator.** Το Simplify **virtually executes an app** για να κατανοήσει τη συμπεριφορά της και έπειτα **προσπαθεί να optimize τον κώδικα** ώστε να συμπεριφέρεται αναπαραγωγικά αλλά να είναι πιο εύκολος για έναν άνθρωπο να τον καταλάβει. Κάθε τύπος optimization είναι απλός και generic, οπότε δεν έχει σημασία τι συγκεκριμένος τύπος obfuscation έχει χρησιμοποιηθεί.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD σας δίνει πληροφορίες για **how an APK was made**. Αναγνωρίζει πολλούς compilers, packers, obfuscators, και άλλα περίεργα. Είναι το [_PEiD_](https://www.aldeid.com/wiki/PEiD) για Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b is an Android security virtual machine based on ubuntu-mate includes the collection of latest framework, tutorials and labs from different security geeks and researchers for reverse engineering and malware analysis.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Είναι μια εξαιρετική λίστα πόρων
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
