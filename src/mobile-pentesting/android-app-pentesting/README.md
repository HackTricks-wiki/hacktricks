# Pentesting di Applicazioni Android

{{#include ../../banners/hacktricks-training.md}}

## Fondamenti delle Applicazioni Android

It's highly recommended to start reading this page to know about the **most important parts related to Android security and the most dangerous components in an Android application**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Questo è lo strumento principale di cui hai bisogno per connetterti a un dispositivo android (emulato o fisico).\
**ADB** permette di controllare i dispositivi sia via **USB** che via **rete** da un computer. Questa utility consente la **copia** di file in entrambe le direzioni, **installazione** e **disinstallazione** di app, **esecuzione** di comandi shell, **backup** dei dati, **lettura** dei log, tra le altre funzioni.

Dai un'occhiata alla seguente lista di [**ADB Commands**](adb-commands.md) per imparare come usare adb.

## Smali

A volte è interessante **modificare il codice dell'applicazione** per accedere a **informazioni nascoste** (forse password ben offuscate o flag). In tal caso, può essere utile decompilare l'apk, modificare il codice e ricompilarlo.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Questo può essere molto utile come **alternativa per diversi test durante l'analisi dinamica** che verranno presentati. Quindi, **tieni sempre presente questa possibilità**.

## Altri trucchi interessanti

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Estrarre l'APK dal dispositivo:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Unisci tutti gli splits e i base apks con [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Casi di studio & Vulnerabilità


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Analisi statica

Prima di tutto, per analizzare un APK dovresti **dare un'occhiata al codice Java** usando un decompiler.\
Per favore, [**leggi qui per trovare informazioni sui diversi decompiler disponibili**](apk-decompilers.md).

### Ricerca di informazioni interessanti

Bastano poche osservazioni delle **stringhe** dell'APK per cercare **password**, **URL** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** e qualsiasi elemento interessante... cerca anche eventuali **backdoor** di esecuzione di codice o backdoor di autenticazione (credenziali admin hardcoded nell'app).

**Firebase**

Presta particolare attenzione agli **URL di Firebase** e verifica se è configurato male. [Maggiori informazioni su cos'è Firebase e come sfruttarlo qui.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Comprensione di base dell'applicazione - Manifest.xml, strings.xml

L'**esame del _Manifest.xml_ e dei file **_strings.xml_** di un'applicazione può rivelare potenziali vulnerabilità di sicurezza**. Questi file possono essere accessi usando decompiler o rinominando l'estensione dell'APK in .zip e poi estraendolo.

Le **vulnerabilità** identificate dal **Manifest.xml** includono:

- **Debuggable Applications**: Le applicazioni impostate come debuggable (`debuggable="true"`) nel file _Manifest.xml_ rappresentano un rischio poiché consentono connessioni che possono portare a sfruttamenti. Per capire meglio come sfruttare applicazioni debuggable, fai riferimento a un tutorial su come trovare e sfruttare applicazioni debuggable su un dispositivo.
- **Backup Settings**: L'attributo `android:allowBackup="false"` dovrebbe essere impostato esplicitamente per le applicazioni che trattano informazioni sensibili per prevenire backup non autorizzati dei dati tramite adb, specialmente quando usb debugging è abilitato.
- **Network Security**: Configurazioni di network security personalizzate (`android:networkSecurityConfig="@xml/network_security_config"`) in _res/xml/_ possono specificare dettagli di sicurezza come certificate pins e impostazioni per il traffico HTTP. Un esempio è permettere traffico HTTP per domini specifici.
- **Exported Activities and Services**: Identificare attività e servizi esportati nel manifest può mettere in evidenza componenti che potrebbero essere abusati. Un'analisi più approfondita durante i test dinamici può rivelare come sfruttare questi componenti.
- **Content Providers and FileProviders**: I content provider esposti potrebbero consentire accesso o modifica non autorizzata dei dati. Anche la configurazione dei FileProvider dovrebbe essere scrupolosamente esaminata.
- **Broadcast Receivers and URL Schemes**: Questi componenti potrebbero essere sfruttati per attacchi, prestando particolare attenzione a come gli schemi URL sono gestiti per possibili vulnerabilità di input.
- **SDK Versions**: Gli attributi `minSdkVersion`, `targetSDKVersion` e `maxSdkVersion` indicano le versioni Android supportate, sottolineando l'importanza di non supportare versioni Android obsolete e vulnerabili per ragioni di sicurezza.

Dal file **strings.xml**, possono emergere informazioni sensibili come API keys, custom schemas e altre note degli sviluppatori, evidenziando la necessità di una revisione attenta di queste risorse.

### Tapjacking

**Tapjacking** è un attacco dove una **malicious** **application** viene lanciata e **si posiziona sopra un'applicazione vittima**. Una volta che oscura visibilmente l'app vittima, la sua interfaccia utente è progettata in modo da ingannare l'utente a interagire con essa, mentre inoltra l'interazione all'app vittima.\
Di fatto, sta **accecando l'utente sul fatto che sta veramente eseguendo azioni sull'app vittima**.

Trova più informazioni in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Un'**activity** con il **`launchMode`** impostato a **`singleTask` senza alcun `taskAffinity`** definito è vulnerabile al Task Hijacking. Questo significa che un'**application** può essere installata e, se lanciata prima della vera applicazione, potrebbe **hijackare il task dell'app reale** (quindi l'utente interagirà con la **malicious application pensando di usare quella reale**).

Maggiori informazioni in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Archiviazione dati insicura

**Internal Storage**

In Android, i file **memorizzati** in **internal** storage sono **progettati** per essere accessibili esclusivamente dall'**app** che li ha **creati**. Questa misura di sicurezza è **forzata** dal sistema operativo Android ed è generalmente adeguata per le esigenze di sicurezza della maggior parte delle applicazioni. Tuttavia, gli sviluppatori a volte utilizzano modalità come `MODE_WORLD_READABLE` e `MODE_WORLD_WRITABLE` per **consentire** che i file siano **condivisi** tra diverse applicazioni. Queste modalità **non limitano però l'accesso** a tali file da parte di altre applicazioni, incluse potenzialmente quelle maligne.

1. **Analisi statica:**
- **Verifica** che l'uso di `MODE_WORLD_READABLE` e `MODE_WORLD_WRITABLE` sia **accuratamente controllato**. Queste modalità **possono potenzialmente esporre** i file a **accessi non intenzionati o non autorizzati**.
2. **Analisi dinamica:**
- **Controlla** i **permessi** impostati sui file creati dall'app. In particolare, **verifica** se alcuni file sono **impostati come leggibili o scrivibili da tutti**. Questo può rappresentare un rischio di sicurezza significativo, poiché permetterebbe a **qualsiasi applicazione** installata sul dispositivo, indipendentemente dalla sua origine o intenzione, di **leggere o modificare** questi file.

**External Storage**

Quando si trattano file su **external storage**, come le SD Card, vanno prese alcune precauzioni:

1. **Accessibilità**:
- I file su external storage sono **leggibili e scrivibili globalmente**. Ciò significa che qualsiasi applicazione o utente può accedere a questi file.
2. **Preoccupazioni di sicurezza**:
- Data la facilità di accesso, è sconsigliato **memorizzare informazioni sensibili** su external storage.
- L'external storage può essere rimosso o accessibile da qualsiasi applicazione, rendendolo meno sicuro.
3. **Gestione dei dati provenienti da external storage**:
- Esegui sempre la **validazione dell'input** sui dati recuperati da external storage. Questo è cruciale perché i dati provengono da una fonte non attendibile.
- È fortemente sconsigliato memorizzare eseguibili o class files su external storage per il caricamento dinamico.
- Se la tua applicazione deve comunque recuperare file eseguibili da external storage, assicurati che tali file siano **firmati e verificati crittograficamente** prima di essere caricati dinamicamente. Questo passaggio è vitale per mantenere l'integrità di sicurezza della tua applicazione.

External storage può essere **accessed** in `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> A partire da Android 4.4 (**API 17**), la SD card ha una struttura di directory che **limita l'accesso di un'app alla directory specificamente destinata a quell'app**. Questo previene che applicazioni maligne ottengano accesso in lettura o scrittura ai file di un'altra app.

**Dati sensibili memorizzati in chiaro**

- **Shared preferences**: Android permette a ciascuna applicazione di salvare facilmente file xml nel percorso `/data/data/<packagename>/shared_prefs/` e a volte è possibile trovare informazioni sensibili in chiaro in quella cartella.
- **Databases**: Android permette a ciascuna applicazione di salvare facilmente database sqlite nel percorso `/data/data/<packagename>/databases/` e a volte è possibile trovare informazioni sensibili in chiaro in quella cartella.

### Broken TLS

**Accept All Certificates**

Per qualche motivo a volte gli sviluppatori accettano tutti i certificati anche se, per esempio, l'hostname non corrisponde, con righe di codice come le seguenti:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Un buon modo per testare questo è provare a catturare il traffico usando un proxy come Burp senza autorizzare Burp CA all'interno del dispositivo. Inoltre, puoi generare con Burp un certificato per un hostname diverso e usarlo.

### Crittografia compromessa

**Processi di gestione delle chiavi inadeguati**

Alcuni sviluppatori salvano dati sensibili nello storage locale e li cifrano con una chiave hardcoded/predictable nel codice. Questo non dovrebbe essere fatto, poiché del reversing potrebbe permettere agli attackers di estrarre le informazioni riservate.

**Uso di algoritmi insicuri e/o deprecati**

Gli sviluppatori non dovrebbero usare **deprecated algorithms** per eseguire controlli di autorizzazione, per **store** o **send** dati. Alcuni di questi algoritmi sono: RC4, MD4, MD5, SHA1... Se vengono usati **hashes** per salvare le password, ad esempio, dovrebbero essere impiegati hashes resistenti al brute-force con salt.

### Altri controlli

- È consigliato **obfuscate the APK** per rendere più difficile il lavoro di reverse engineer agli attackers.
- Se l'app è sensibile (come le app bancarie), dovrebbe eseguire i propri controlli per verificare se il dispositivo è **rooted** e agire di conseguenza.
- Se l'app è sensibile (come le app bancarie), dovrebbe verificare se è in uso un **emulator**.
- Se l'app è sensibile (come le app bancarie), dovrebbe **check it's own integrity before executing** per verificare se è stata modificata.
- Usa [**APKiD**](https://github.com/rednaga/APKiD) per verificare quale compiler/packer/obfuscator è stato usato per buildare l'APK

### React Native Application

Leggi la pagina seguente per imparare come accedere facilmente al javascript delle applicazioni React:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Leggi la pagina seguente per imparare come accedere facilmente al codice C# di un'applicazione xamarin:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

Secondo questo [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked è un algoritmo Meta che comprime il contenuto di un'applicazione in un singolo file. Il blog parla della possibilità di creare un'app che decomprima questo tipo di applicazioni... e di un modo più veloce che implica **eseguire l'applicazione e raccogliere i file decompressi dal filesystem.**

### Automated Static Code Analysis

Lo strumento [**mariana-trench**](https://github.com/facebook/mariana-trench) è in grado di trovare **vulnerabilities** scansionando il **code** dell'applicazione. Questo strumento contiene una serie di **known sources** (che indicano allo strumento i **places** dove l'**input** è **controlled by the user**), **sinks** (che indicano al tool i **dangerous** **places** dove l'input malevolo potrebbe causare danni) e **rules**. Queste regole indicano la **combination** di **sources-sinks** che segnala una vulnerabilità.

Con questa conoscenza, **mariana-trench will review the code and find possible vulnerabilities on it**.

### Secrets leaked

Un'applicazione può contenere secrets (API keys, password, hidden urls, subdomains...) al suo interno che potresti essere in grado di scoprire. Potresti usare uno strumento come [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Altre funzioni interessanti

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** dichiarate come `native`: `public native, System.loadLibrary, System.load`
- [Leggi questo per imparare **how to reverse native functions**](reversing-native-libraries.md)

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> Prima di tutto, ti serve un ambiente dove poter installare l'applicazione e tutta la configurazione (Burp CA cert, Drozer e Frida principalmente). Pertanto, un dispositivo rooted (emulato o no) è fortemente raccomandato.

### Online Dynamic analysis

Puoi creare un **free account** su: [https://appetize.io/](https://appetize.io). Questa piattaforma ti permette di **upload** e **execute** APK, quindi è utile per vedere come si comporta un apk.

Puoi anche **vedere i log della tua applicazione** sul web e connetterti tramite **adb**.

![](<../../images/image (831).png>)

Grazie alla connessione ADB puoi usare **Drozer** e **Frida** all'interno degli emulatori.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (Puoi creare dispositivi **x86** e **arm**, e secondo [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**le ultime versioni x86** supportano librerie **ARM** senza bisogno di un lento emulatore arm).
- Impara a configurarlo in questa pagina:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, è necessario creare un account. _È raccomandato **download** la versione **WITH** _**VirtualBox** per evitare potenziali errori._)
- [**Nox**](https://es.bignox.com) (Free, ma non supporta Frida o Drozer).

> [!TIP]
> Quando crei un nuovo emulator su qualunque piattaforma ricorda che quanto più grande è lo schermo, tanto più lento sarà l'emulatore. Quindi seleziona schermi piccoli se possibile.

Per **installare google services** (come AppStore) in Genymotion devi cliccare sul pulsante segnato in rosso nell'immagine seguente:

![](<../../images/image (277).png>)

Inoltre, nota che nella **configurazione della VM Android in Genymotion** puoi selezionare la modalità **Bridge Network** (questo sarà utile se ti connetterai alla VM Android da una VM diversa con gli strumenti).

#### Use a physical device

Devi attivare le opzioni di **debugging** e sarebbe utile poterlo **root**:

1. **Settings**.
2. (FromAndroid 8.0) Seleziona **System**.
3. Seleziona **About phone**.
4. Premi **Build number** 7 volte.
5. Torna indietro e troverai le **Developer options**.

> Una volta installata l'applicazione, la prima cosa che dovresti fare è provarla e investigare cosa fa, come funziona e prendere confidenza con essa.\
> Suggerisco di **effettuare questa analisi dinamica iniziale usando MobSF dynamic analysis + pidcat**, così saremo in grado di **imparare come l'applicazione funziona** mentre MobSF **captures** molti dati **interessanti** che puoi rivedere più tardi.

Magisk/Zygisk quick notes (raccomandato su dispositivi Pixel)
- Patchare boot.img con l'app Magisk e flashare via fastboot per ottenere root systemless
- Abilitare Zygisk + DenyList per nascondere il root; considera LSPosed/Shamiko quando è necessario un hiding più robusto
- Conservare il boot.img originale per recuperare dopo gli OTA; ripatchare dopo ogni OTA
- Per il mirroring dello schermo, usa scrcpy sull'host



### Unintended Data Leakage

**Logging**

Gli sviluppatori devono essere cauti nell'esporre informazioni di **debugging** pubblicamente, poiché ciò può portare a leak di dati sensibili. Gli strumenti [**pidcat**](https://github.com/JakeWharton/pidcat) e `adb logcat` sono raccomandati per monitorare i log delle applicazioni e identificare/proteggere informazioni sensibili. **Pidcat** è preferito per la sua facilità d'uso e leggibilità.

> [!WARNING]
> Nota che da **versioni successive a Android 4.0**, **le applicazioni possono accedere solo ai propri log**. Quindi le applicazioni non possono accedere ai log di altre app.\
> Comunque, è sempre consigliato **non loggare informazioni sensibili**.

**Copy/Paste Buffer Caching**

Il framework basato sulla **clipboard** di Android abilita la funzionalità copy-paste nelle app, ma rappresenta un rischio in quanto **altre applicazioni** possono **accedere** alla clipboard, esponendo potenzialmente dati sensibili. È cruciale **disabilitare copy/paste** nelle sezioni sensibili di un'applicazione, come i dati della carta di credito, per prevenire leak.

**Crash Logs**

Se un'applicazione **crasha** e **salva log**, questi log possono aiutare gli attackers, specialmente quando l'app non può essere reverse-engineerata. Per mitigare questo rischio, evitare di loggare sui crash e, se i log devono essere trasmessi in rete, assicurarsi che vengano inviati tramite un canale SSL per sicurezza.

Come pentester, **cerca di dare un'occhiata a questi log**.

**Analytics Data Sent To 3rd Parties**

Le applicazioni spesso integrano servizi come Google Adsense, che possono involontariamente causare **leak di dati sensibili** a causa di un'implementazione scorretta degli sviluppatori. Per identificare potenziali leak di dati, è consigliabile **intercettare il traffico dell'applicazione** e verificare se informazioni sensibili vengono inviate a servizi di terze parti.

### SQLite DBs

La maggior parte delle applicazioni utilizzerà **database SQLite interni** per salvare informazioni. Durante il pentest controlla i **databases** creati, i nomi delle **tables** e delle **columns** e tutti i **data** salvati perché potresti trovare informazioni sensibili (che costituirebbero una vulnerabilità).\
I database dovrebbero trovarsi in /data/data/the.package.name/databases come /data/data/com.mwr.example.sieve/databases

Se il database salva informazioni confidenziali ed è **encrypted** ma puoi **find** la **password** all'interno dell'applicazione è comunque una **vulnerability**.

Enumera le tabelle usando `.tables` ed enumera le colonne delle tabelle con `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

Dai [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** permette di **assumere il ruolo di un'app Android** e interagire con altre app. Può fare **qualsiasi cosa che un'app installata può fare**, come utilizzare il meccanismo IPC di Android e interagire con il sistema operativo sottostante. .\
Drozer è uno strumento utile per **exploitare exported activities, exported services e Content Providers** come imparerai nelle sezioni seguenti.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Ricorda inoltre che il codice di un'attività inizia nel metodo **`onCreate`**.

**Authorisation bypass**

Quando un'Activity è exported puoi invocare la sua schermata da un'app esterna. Pertanto, se un'activity con **informazioni sensibili** è **exported** potresti **bypassare** i meccanismi di **authentication** per accedervi.

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

Puoi anche avviare un'activity exported da adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF rileverà come dannoso l'uso di _**singleTask/singleInstance**_ come `android:launchMode` in un'activity, ma a causa di [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparentemente questo è pericoloso solo su vecchie versioni (API versions < 21).

> [!TIP]
> Nota che un authorisation bypass non è sempre una vulnerabilità: dipende da come il bypass funziona e quali informazioni vengono esposte.

**Sensitive information leakage**

**Activities can also return results**. Se riesci a trovare un'activity esportata e non protetta che invoca il metodo **`setResult`** e **restituisce informazioni sensibili**, si verifica una sensitive information leakage.

#### Tapjacking

Se il Tapjacking non è prevenuto, potresti abusare dell'activity esportata per far eseguire all'**user azioni inaspettate**. Per maggiori informazioni su [**cos'è Tapjacking segui il link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Leggi questo se vuoi rinfrescare cosa sia un Content Provider.**](android-applications-basics.md#content-provider)\
I Content providers sono fondamentalmente usati per **condividere dati**. Se un'app ha content providers disponibili potresti essere in grado di **estrarre dati sensibili** da essi. È inoltre interessante testare possibili **SQL injections** e **Path Traversals**, poiché potrebbero essere vulnerabili.

[**Scopri come sfruttare i Content Providers con Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Leggi questo se vuoi rinfrescare cosa sia un Service.**](android-applications-basics.md#services)\
Ricorda che le azioni di un Service iniziano nel metodo `onStartCommand`.

Un Service è fondamentalmente qualcosa che **può ricevere dati**, **elaborarli** e **restituire** (o meno) una risposta. Quindi, se un'applicazione esporta dei Service dovresti **controllare** il **codice** per capire cosa fa e **testarlo** **dinamicamente** per estrarre informazioni riservate, bypassing le misure di autenticazione...\
[**Scopri come sfruttare i Service con Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Leggi questo se vuoi rinfrescare cosa sia un Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Ricorda che le azioni di un Broadcast Receiver iniziano nel metodo `onReceive`.

Un Broadcast Receiver rimarrà in attesa di un tipo di messaggio. A seconda di come il receiver gestisce il messaggio, potrebbe essere vulnerabile.\
[**Scopri come sfruttare i Broadcast Receivers con Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Puoi cercare deep links manualmente, usando strumenti come MobSF o script come [questo](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Puoi **aprire** uno **scheme** dichiarato usando **adb** o un **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Nota che puoi **omettere il nome del package** e il dispositivo mobile chiamerà automaticamente l'app che dovrebbe aprire quel link._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Codice eseguito**

Per trovare il **codice che verrà eseguito nell'App**, vai all'activity chiamata dal deeplink e cerca la funzione **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Informazioni sensibili**

Ogni volta che trovi un deep link verifica che **non stia ricevendo dati sensibili (come password) tramite i parametri URL**, perché qualsiasi altra applicazione potrebbe **impersonare il deep link e rubare quei dati!**

**Parametri nel path**

Devi anche verificare se un deep link sta usando un parametro dentro il path dell'URL come: `https://api.example.com/v1/users/{username}` , in tal caso puoi forzare un path traversal accedendo a qualcosa come: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Nota che se trovi gli endpoint corretti dentro l'applicazione potresti essere in grado di causare un **Open Redirect** (se parte del path è usata come nome di dominio), **account takeover** (se puoi modificare i dettagli degli utenti senza token CSRF e l'endpoint vulnerabile usa il metodo corretto) e qualsiasi altra vuln. Maggiori [info su questo qui](http://dphoeniixx.com/2020/12/13-2/).

**Altri esempi**

Un [interessante bug bounty report](https://hackerone.com/reports/855618) sui link (_/.well-known/assetlinks.json_).

### Ispezione del livello di trasporto e fallimenti di verifica

- **I certificati non vengono sempre ispezionati correttamente** dalle applicazioni Android. È comune che queste applicazioni ignorino gli avvisi e accettino certificati self-signed o, in alcuni casi, tornino a usare connessioni HTTP.
- **Le negoziazioni durante l'handshake SSL/TLS sono a volte deboli**, impiegando cipher suite insicure. Questa vulnerabilità rende la connessione suscettibile ad attacchi man-in-the-middle (MITM), permettendo agli attaccanti di decriptare i dati.
- **Perdita di informazioni private** è un rischio quando le applicazioni si autenticano usando canali sicuri ma poi comunicano su canali non sicuri per altre transazioni. Questo approccio non protegge i dati sensibili, come cookie di sessione o dettagli utente, dall'intercettazione da parte di entità malevole.

#### Verifica del certificato

Ci concentreremo sulla **verifica del certificato**. L'integrità del certificato del server deve essere verificata per migliorare la sicurezza. Questo è cruciale perché configurazioni TLS insicure e la trasmissione di dati sensibili su canali non cifrati possono comportare rischi significativi. Per passaggi dettagliati sulla verifica dei certificati server e la risoluzione delle vulnerabilità, [**questa risorsa**](https://manifestsecurity.com/android-application-security-part-10/) fornisce linee guida complete.

#### SSL Pinning

Lo **SSL Pinning** è una misura di sicurezza in cui l'applicazione verifica il certificato del server rispetto a una copia nota memorizzata all'interno dell'app stessa. Questo metodo è essenziale per prevenire attacchi MITM. Implementare SSL Pinning è fortemente raccomandato per applicazioni che gestiscono informazioni sensibili.

#### Ispezione del traffico

Per ispezionare il traffico HTTP è necessario **installare il certificato dello strumento proxy** (es. Burp). Senza installare questo certificato, il traffico cifrato potrebbe non essere visibile tramite il proxy. Per una guida sull'installazione di un certificato CA custom, [**clicca qui**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Le applicazioni targettizzate per **API Level 24 and above** richiedono modifiche alla Network Security Config per accettare il certificato CA del proxy. Questo passaggio è critico per ispezionare il traffico cifrato. Per istruzioni su come modificare la Network Security Config, [**consulta questo tutorial**](make-apk-accept-ca-certificate.md).

Se viene usato **Flutter** devi seguire le istruzioni in [**questa pagina**](flutter.md). Questo perché, semplicemente aggiungendo il certificato nello store non funzionerà dato che Flutter ha la sua propria lista di CA valide.

#### Rilevamento statico dello SSL/TLS pinning

Prima di tentare bypass a runtime, mappa rapidamente dove il pinning è applicato nell'APK. La scoperta statica ti aiuta a pianificare hook/patch e a concentrarti sui percorsi di codice corretti.

Tool: SSLPinDetect
- Utilità open-source di static-analysis che decompila l'APK in Smali (via apktool) e scansiona pattern regex curati per implementazioni di SSL/TLS pinning.
- Riporta il percorso file esatto, il numero di riga e un estratto di codice per ogni corrispondenza.
- Copre framework comuni e percorsi di codice custom: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init con custom TrustManagers/KeyManagers, e pin in Network Security Config XML.

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Uso
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Esempi di regole di pattern (JSON)
Usa o estendi le signatures per rilevare stili di pinning proprietari/custom. Puoi caricare il tuo JSON ed effettuare scan su larga scala.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Note e suggerimenti
- Scansione veloce di app di grandi dimensioni tramite multi-threading e memory-mapped I/O; regex precompilate riducono overhead/falsi positivi.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Obiettivi tipici di rilevamento da valutare successivamente:
- OkHttp: uso di CertificatePinner, setCertificatePinner, riferimenti ai package okhttp3/okhttp
- TrustManagers personalizzati: javax.net.ssl.X509TrustManager, override di checkServerTrusted
- Contesti SSL personalizzati: SSLContext.getInstance + SSLContext.init con manager personalizzati
- Pin dichiarativi in res/xml network security config e riferimenti nel manifest
- Usa le posizioni corrispondenti per pianificare Frida hooks, patch statiche, o revisioni di config prima dei test dinamici.



#### Bypassare SSL Pinning

Quando SSL Pinning è implementato, diventa necessario bypassarlo per ispezionare il traffico HTTPS. Sono disponibili vari metodi per questo scopo:

- Modifica automaticamente l'**apk** per **bypassare** SSLPinning con [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Il principale vantaggio di questa opzione è che non servirà root per bypassare lo SSL Pinning, ma dovrai eliminare l'applicazione e reinstallare la nuova, e questo non funziona sempre.
- Puoi usare **Frida** (discusso sotto) per bypassare questa protezione. Qui c'è una guida per usare Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Puoi anche provare a bypassare automaticamente SSL Pinning usando [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Puoi anche provare a bypassare automaticamente SSL Pinning usando **MobSF dynamic analysis** (spiegato sotto)
- Se pensi che ci sia traffico che non stai catturando puoi provare a **inoltrare il traffico a burp usando iptables**. Leggi questo blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Ricerca di vulnerabilità web comuni

È importante cercare anche le comuni vulnerabilità web all'interno dell'applicazione. Informazioni dettagliate sull'identificazione e la mitigazione di queste vulnerabilità sono oltre lo scopo di questo riassunto ma sono trattate estensivamente altrove.

### Frida

[Frida](https://www.frida.re) è un toolkit di instrumentazione dinamica per sviluppatori, reverse-engineer e ricercatori di sicurezza.\
**Puoi accedere all'applicazione in esecuzione e hookare metodi a runtime per cambiare il comportamento, modificare valori, estrarre valori, eseguire codice diverso...**\
Se vuoi fare pentesting su applicazioni Android devi sapere come usare Frida.

- Impara a usare Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Alcune "GUI" per le azioni con Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection è ottimo per automatizzare l'uso di Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Puoi trovare alcuni script Awesome Frida qui: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Prova a bypassare meccanismi anti-debugging / anti-frida caricando Frida come indicato in [https://erfur.github.io/blog/dev/code-injection-without-ptrace] (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump della memoria - Fridump**

Controlla se l'applicazione sta memorizzando informazioni sensibili nella memoria che non dovrebbe contenere, come password o mnemonic.

Usando [**Fridump3**](https://github.com/rootbsd/fridump3) puoi dumpare la memoria dell'app con:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Questo scaricherà la memoria nella cartella ./dump, e lì puoi usare grep con qualcosa del tipo:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Dati sensibili nel Keystore**

Su Android il Keystore è il posto migliore per memorizzare dati sensibili, tuttavia, con privilegi sufficienti è ancora **possibile accedervi**. Poiché le applicazioni tendono a memorizzare qui **dati sensibili in chiaro**, i pentests dovrebbero verificarne la presenza come root user oppure qualcuno con accesso fisico al dispositivo potrebbe essere in grado di rubare questi dati.

Anche se un'app memorizzasse dati nel Keystore, i dati dovrebbero essere cifrati.

Per accedere ai dati all'interno del Keystore puoi usare questo Frida script: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Utilizzando il seguente script Frida potrebbe essere possibile eseguire un **bypass fingerprint authentication** che le applicazioni Android potrebbero adottare per **proteggere alcune aree sensibili:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Immagini di sfondo**

Quando mandi un'applicazione in background, Android salva una **istantanea dell'applicazione** così quando viene ripristinata in primo piano inizia a caricare l'immagine prima dell'app, dando l'impressione che l'app si sia caricata più velocemente.

Tuttavia, se questa istantanea contiene **informazioni sensibili**, qualcuno con accesso all'istantanea potrebbe **rubare quelle informazioni** (nota: è necessario il root per accedervi).

Le istantanee sono solitamente memorizzate in: **`/data/system_ce/0/snapshots`**

Android fornisce un modo per **impedire la cattura dello screenshot impostando il parametro di layout FLAG_SECURE**. Usando questo flag, il contenuto della finestra viene trattato come sicuro, impedendone la comparsa negli screenshot o la visualizzazione su display non sicuri.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

This tool could help you managing different tools during the dynamic analysis: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Gli sviluppatori spesso creano proxy components come activities, services, e broadcast receivers che gestiscono questi Intents e li passano a metodi come `startActivity(...)` o `sendBroadcast(...)`, il che può essere rischioso.

Il pericolo sta nel permettere ad un attacker di triggerare componenti dell'app non-exported o accedere a content providers sensibili deviando questi Intents. Un esempio notevole è il componente `WebView` che converte URL in oggetti `Intent` tramite `Intent.parseUri(...)` e poi li esegue, potenzialmente portando a malicious Intent injections.

### Essential Takeaways

- **Intent Injection** is similar to web's Open Redirect issue.
- Exploits involve passing `Intent` objects as extras, which can be redirected to execute unsafe operations.
- It can expose non-exported components and content providers to attackers.
- `WebView`’s URL to `Intent` conversion can facilitate unintended actions.

### Android Client Side Injections and others

Probabilmente conosci questo tipo di vulnerabilità dal Web. Devi essere particolarmente attento a queste vulnerabilità in un'app Android:

- **SQL Injection:** When dealing with dynamic queries or Content-Providers ensure you are using parameterized queries.
- **JavaScript Injection (XSS):** Verify that JavaScript and Plugin support is disabled for any WebViews (disabled by default). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews should have access to the file system disabled (enabled by default) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: In several cases when the Android application finish the session the cookie isn't revoked or it could be even saved to disk
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Static analysis**

![](<../../images/image (866).png>)

**Vulnerability assessment of the application** using a nice web-based frontend. You can also perform dynamic analysis (but you need to prepare the environment).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Nota che MobSF può analizzare **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Le applicazioni Windows devono essere analizzate da un MobSF installato su un host Windows_).\
Inoltre, se crei un file **ZIP** con il codice sorgente di un'app **Android** o un'app **IOS** (vai alla cartella root dell'applicazione, seleziona tutto e crea un file ZIP), sarà in grado di analizzarlo anche.

MobSF permette anche di fare il **diff/Compare** delle analisi e di integrare **VirusTotal** (dovrai impostare la tua API key in _MobSF/settings.py_ e abilitarla: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). Puoi anche impostare `VT_UPLOAD` su `False`, in tal caso verrà caricato l'**hash** invece del file.

### Assisted Dynamic analysis with MobSF

**MobSF** può essere molto utile anche per l'analisi dinamica su **Android**, ma in questo caso dovrai installare MobSF e **genymotion** sul tuo host (una VM o Docker non funzioneranno). _Nota: devi **avviare prima una VM in genymotion** e **poi MobSF.**_\  
L'analizzatore dinamico di **MobSF** può:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). Tutto questo viene fatto automaticamente eccetto per gli screenshot: devi premere quando vuoi uno screenshot o devi premere "**Exported Activity Tester**" per ottenere gli screenshot di tutte le attività esportate.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

Dalle versioni Android > 5, avvierà automaticamente Frida e imposterà il proxy globale per catturare il traffico. Catturerà solo il traffico dell'applicazione testata.

**Frida**

Di default, utilizzerà anche alcuni Frida Scripts per bypassare SSL pinning, root detection e debugger detection e per monitorare API interessanti.\
MobSF può anche invocare exported activities, catturare screenshot di esse e salvarli per il report.

Per **avviare** il testing dinamico premi il bottone verde: "**Start Instrumentation**". Premi "**Frida Live Logs**" per vedere i log generati dagli script Frida e "**Live API Monitor**" per vedere tutte le invocazioni ai metodi hooked, gli argomenti passati e i valori restituiti (questo apparirà dopo aver premuto "Start Instrumentation").\
MobSF permette anche di caricare i tuoi **Frida scripts** (per inviare i risultati dei tuoi Frida scripts a MobSF usa la funzione `send()`). Ha anche **diversi script pre-scritti** che puoi caricare (puoi aggiungerne altri in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), basta **selezionarli**, premere "**Load**" e poi "**Start Instrumentation**" (potrai vedere i log di quegli script dentro "**Frida Live Logs**").

![](<../../images/image (419).png>)

Inoltre, hai alcune funzionalità ausiliarie di Frida:

- **Enumerate Loaded Classes**: Mostrerà tutte le classi caricate
- **Capture Strings**: Mostrerà tutte le stringhe catturate mentre usi l'applicazione (molto rumoroso)
- **Capture String Comparisons**: Può essere molto utile. Mostrerà le 2 stringhe confrontate e se il risultato è True o False.
- **Enumerate Class Methods**: Inserisci il nome della classe (come "java.io.File") e mostrerà tutti i metodi della classe.
- **Search Class Pattern**: Cerca classi per pattern
- **Trace Class Methods**: Traccia un'intera classe (vedi input e output di tutti i metodi della classe). Ricorda che di default MobSF traccia diversi metodi interessanti delle Android API.

Una volta selezionato il modulo ausiliario che vuoi utilizzare devi premere "**Start Intrumentation**" e vedrai tutti gli output in "**Frida Live Logs**".

**Shell**

MobSF fornisce anche una shell con alcuni comandi **adb**, comandi MobSF, e comandi di shell comuni nella parte inferiore della pagina di analisi dinamica. Alcuni comandi interessanti:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**Strumenti HTTP**

Quando il traffico http viene catturato puoi vedere una visualizzazione brutta del traffico catturato nel pulsante "**HTTP(S) Traffic**" oppure una visualizzazione migliore nel pulsante verde "**Start HTTPTools**". Dalla seconda opzione, puoi **inviare** le **richieste catturate** a **proxies** come Burp o Owasp ZAP.\
Per fare ciò, _avvia Burp -->_ _disabilita Intercept --> in MobSB HTTPTools seleziona la richiesta_ --> premi "**Send to Fuzzer**" --> _seleziona l'indirizzo del proxy_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Una volta terminata la dynamic analysis con MobSF puoi premere "**Start Web API Fuzzer**" per **fuzz http requests** e cercare vulnerabilità.

> [!TIP]
> Dopo aver eseguito una dynamic analysis con MobSF le impostazioni del proxy potrebbero essere mal configurate e potresti non riuscire a correggerle dalla GUI. Puoi ripristinare le impostazioni del proxy eseguendo:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

You can get the tool from [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Questo strumento utilizza alcuni **Hooks** per farti sapere **cosa sta succedendo nell'applicazione** mentre esegui una **dynamic analysis**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

This is a **great tool to perform static analysis with a GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

This tool is designed to look for several **security related Android application vulnerabilities**, either in **source code** or **packaged APKs**. The tool is also **capable of creating a "Proof-of-Concept" deployable APK** and **ADB commands**, to exploit some of the found vulnerabilities (Exposed activities, intents, tapjacking...). As with Drozer, there is no need to root the test device.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Mostra tutti i file estratti per riferimento rapido
- Decompila automaticamente file APK in formato Java e Smali
- Analizza AndroidManifest.xml per vulnerabilità e comportamenti comuni
- Analisi statica del codice sorgente per vulnerabilità e comportamenti comuni
- Informazioni sul dispositivo
- e altro
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER è un'applicazione da riga di comando utilizzabile su Windows, MacOS X e Linux, che analizza file _.apk_ alla ricerca di vulnerabilità. Lo fa decomprimendo gli APK e applicando una serie di regole per rilevare queste vulnerabilità.

Tutte le regole sono raccolte in un file `rules.json`, e ogni azienda o tester può creare le proprie regole per analizzare ciò di cui ha bisogno.

Scarica i binari più recenti dalla [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn è uno strumento **crossplatform** che aiuta sviluppatori, bugbounty hunters e ethical hackers nello svolgere [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) su applicazioni mobili.

Il concetto è che trascini e rilasci il file della tua applicazione mobile (un file .apk o .ipa) nell'applicazione StaCoAn e otterrai un report visuale e portatile. Puoi modificare le impostazioni e le wordlists per ottenere un'esperienza personalizzata.

Download[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework è un sistema di analisi delle vulnerabilità per Android che aiuta gli sviluppatori o gli hackers a trovare potenziali vulnerabilità di sicurezza nelle applicazioni Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** è uno strumento il cui obiettivo principale è rilevare e avvertire l'utente riguardo a potenziali comportamenti malevoli sviluppati da un'applicazione Android.

La rilevazione viene effettuata tramite la **static analysis** del bytecode Dalvik dell'applicazione, rappresentato come **Smali**, utilizzando la libreria [`androguard`](https://github.com/androguard/androguard).

Questo strumento cerca i **comportamenti comuni delle applicazioni "malevoli"** come: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** è un framework di **M**obile **A**pplication **R**everse engineering and **A**nalysis. È uno strumento che mette insieme tool comunemente usati per il reverse engineering e l'analisi di applicazioni mobile, per aiutare nel testing delle applicazioni contro le minacce di sicurezza mobile OWASP. L'obiettivo è rendere questo compito più semplice e accessibile agli sviluppatori di applicazioni mobile e ai professionisti della sicurezza.

È in grado di:

- Estrarre codice Java e Smali usando diversi tool
- Analizzare APK usando: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Estrarre informazioni private dall'APK usando regexps.
- Analizzare il Manifest.
- Analizzare i domini trovati usando: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) e [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscare APK tramite [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Utile per rilevare malware: [https://koodous.com/](https://koodous.com/)

## Offuscare/Deoffuscare il codice

Nota che, a seconda del servizio e della configurazione usata per offuscare il codice, i segreti possono risultare offuscati oppure no.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

Da [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** è uno strumento open source da riga di comando che riduce, ottimizza e offusca codice Java. È capace di ottimizzare il bytecode così come di rilevare e rimuovere istruzioni inutilizzate. ProGuard è software libero distribuito sotto la GNU General Public License, versione 2.

ProGuard è distribuito come parte dell'Android SDK e viene eseguito quando si builda l'applicazione in modalità release.

### [DexGuard](https://www.guardsquare.com/dexguard)

Trovi una guida passo-passo per deoffuscare l'apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(Dalla guida) L'ultima volta che abbiamo verificato, la modalità di funzionamento di Dexguard era:

- caricare una risorsa come InputStream;
- passare il risultato a una classe che eredita da FilterInputStream per decrittarla;
- fare qualche obfuscation inutile per far perdere tempo a un reverser;
- passare il risultato decrittato a un ZipInputStream per ottenere un file DEX;
- infine caricare il DEX risultante come Resource usando il metodo `loadDex`.

### [DeGuard](http://apk-deguard.com)

**DeGuard inverte il processo di offuscamento eseguito dagli strumenti di offuscamento Android. Questo abilita numerose analisi di sicurezza, inclusa l'ispezione del codice e la predizione delle librerie.**

Puoi caricare un APK offuscato sulla loro piattaforma.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

Questo è uno strumento LLM per trovare potenziali vulnerabilità di sicurezza in app android e deoffuscare il codice di app android. Usa l'API pubblica Google Gemini.

### [Simplify](https://github.com/CalebFenton/simplify)

È un deobfuscator android generico. Simplify **esegue praticamente un'app** per capirne il comportamento e poi **cerca di ottimizzare il codice** in modo che si comporti in modo identico ma sia più comprensibile per un umano. Ogni tipo di ottimizzazione è semplice e generica, quindi non importa quale specifico tipo di offuscamento sia stato usato.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD ti dà informazioni su **come è stato creato un APK**. Identifica molti **compilers**, **packers**, **obfuscators**, e altre cose strane. È lo [_PEiD_](https://www.aldeid.com/wiki/PEiD) per Android.

### Manuale

[Leggi questo tutorial per imparare alcuni trucchi su **come reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b è una virtual machine per sicurezza Android basata su ubuntu-mate che include una raccolta degli ultimi framework, tutorial e lab di diversi security geeks e ricercatori per reverse engineering e malware analysis.

## Riferimenti

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) È una grande lista di risorse
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Corso rapido su Android
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)

## Da provare

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
