# Android Applications Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Conceitos Básicos de Aplicações Android

É altamente recomendado começar lendo esta página para conhecer as **partes mais importantes relacionadas à segurança do Android e os componentes mais perigosos em uma aplicação Android**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

This is the main tool you need to connect to an android device (emulated or physical).\
**ADB** permite controlar dispositivos tanto via **USB** quanto via **Network** a partir de um computador. Esta utilidade possibilita a **cópia** de arquivos em ambas as direções, **instalação** e **desinstalação** de apps, **execução** de comandos de shell, **backup** de dados, **leitura** de logs, entre outras funções.

Take a look to the following list of [**ADB Commands**](adb-commands.md) to learn how to use adb.

## Smali

Às vezes é interessante **modificar o código da aplicação** para acessar **informações ocultas** (talvez senhas bem ofuscadas ou flags). Então, pode ser interessante descompilar o apk, modificar o código e recompilá-lo.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Isto pode ser muito útil como uma **alternativa para vários testes durante a análise dinâmica** que serão apresentados. Portanto, **mantenha sempre em mente essa possibilidade**.

## Outras técnicas interessantes

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [Android IME / InputMethodService Abuse (Malicious Keyboards)](inputmethodservice-ime-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Extrair APK do dispositivo:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Mescle todos os splits e base apks com [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Android Enterprise & Work Profile Attacks

{{#ref}}
android-enterprise-work-profile-bypass.md
{{#endref}}

## Case Studies & Vulnerabilities


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

{{#ref}}
abusing-android-media-pipelines-image-parsers.md
{{#endref}}

{{#ref}}
../../binary-exploitation/linux-kernel-exploitation/arm64-static-linear-map-kaslr-bypass.md
{{#endref}}

## Static Analysis

First of all, for analysing an APK you should **take a look to the to the Java code** using a decompiler.\
Please, [**read here to find information about different available decompilers**](apk-decompilers.md).

### Looking for interesting Info

Just taking a look to the **strings** of the APK you can search for **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** and anything interesting... look even for code execution **backdoors** or authentication backdoors (hardcoded admin credentials to the app).

**Firebase**

Pay special attention to **firebase URLs** and check if it is bad configured. [More information about whats is FIrebase and how to exploit it here.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Basic understanding of the application - Manifest.xml, strings.xml

The **examination of an application's _Manifest.xml_ and **_strings.xml_** files can reveal potential security vulnerabilities**. These files can be accessed using decompilers or by renaming the APK file extension to .zip and then unzipping it.

**Vulnerabilities** identified from the **Manifest.xml** include:

- **Debuggable Applications**: Applications set as debuggable (`debuggable="true"`) in the _Manifest.xml_ file pose a risk as they allow connections that can lead to exploitation. For further understanding on how to exploit debuggable applications, refer to a tutorial on finding and exploiting debuggable applications on a device.
- **Backup Settings**: The `android:allowBackup="false"` attribute should be explicitly set for applications dealing with sensitive information to prevent unauthorized data backups via adb, especially when usb debugging is enabled.
- **Network Security**: Custom network security configurations (`android:networkSecurityConfig="@xml/network_security_config"`) in _res/xml/_ can specify security details like certificate pins and HTTP traffic settings. An example is allowing HTTP traffic for specific domains.
- **Exported Activities and Services**: Identifying exported activities and services in the manifest can highlight components that might be misused. Further analysis during dynamic testing can reveal how to exploit these components.
- **Content Providers and FileProviders**: Exposed content providers could allow unauthorized access or modification of data. The configuration of FileProviders should also be scrutinized.
- **Broadcast Receivers and URL Schemes**: These components could be leveraged for exploitation, with particular attention to how URL schemes are managed for input vulnerabilities.
- **SDK Versions**: The `minSdkVersion`, `targetSDKVersion`, and `maxSdkVersion` attributes indicate the supported Android versions, highlighting the importance of not supporting outdated, vulnerable Android versions for security reasons.

From the **strings.xml** file, sensitive information such as API keys, custom schemas, and other developer notes can be discovered, underscoring the need for careful review of these resources.

### Tapjacking

**Tapjacking** is an attack where a **malicious** **application** is launched and **positions itself on top of a victim application**. Once it visibly obscures the victim app, its user interface is designed in such a way as to trick the user to interact with it, while it is passing the interaction along to the victim app.\
In effect, it is **blinding the user from knowing they are actually performing actions on the victim app**.

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

An **activity** with the **`launchMode`** set to **`singleTask` without any `taskAffinity`** defined is vulnerable to task Hijacking. This means, that an **application** can be installed and if launched before the real application it could **hijack the task of the real application** (so the user will be interacting with the **malicious application thinking he is using the real one**).

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Insecure data storage

**Internal Storage**

In Android, files **stored** in **internal** storage are **designed** to be **accessible** exclusively by the **app** that **created** them. This security measure is **enforced** by the Android operating system and is generally adequate for the security needs of most applications. However, developers sometimes utilize modes such as `MODE_WORLD_READABLE` and `MODE_WORLD_WRITABLE` to **allow** files to be **shared** between different applications. Yet, these modes **do not restrict access** to these files by other applications, including potentially malicious ones.

1. **Static Analysis:**
- **Ensure** that the use of `MODE_WORLD_READABLE` and `MODE_WORLD_WRITABLE` is **carefully scrutinized**. These modes **can potentially expose** files to **unintended or unauthorized access**.
2. **Dynamic Analysis:**
- **Verify** the **permissions** set on files created by the app. Specifically, **check** if any files are **set to be readable or writable worldwide**. This can pose a significant security risk, as it would allow **any application** installed on the device, regardless of its origin or intent, to **read or modify** these files.

**External Storage**

When dealing with files on **external storage**, such as SD Cards, certain precautions should be taken:

1. **Accessibility**:
- Files on external storage are **globally readable and writable**. This means any application or user can access these files.
2. **Security Concerns**:
- Given the ease of access, it's advised **not to store sensitive information** on external storage.
- External storage can be removed or accessed by any application, making it less secure.
3. **Handling Data from External Storage**:
- Always **perform input validation** on data retrieved from external storage. This is crucial because the data is from an untrusted source.
- Storing executables or class files on external storage for dynamic loading is strongly discouraged.
- If your application must retrieve executable files from external storage, ensure these files are **signed and cryptographically verified** before they are dynamically loaded. This step is vital for maintaining the security integrity of your application.

External storage can be **accessed** in `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> Starting with Android 4.4 (**API 17**), the SD card has a directory structure which **limits access from an app to the directory which is specifically for that app**. This prevents malicious application from gaining read or write access to another app's files.

**Sensitive data stored in clear-text**

- **Shared preferences**: Android allow to each application to easily save xml files in the path `/data/data/<packagename>/shared_prefs/` and sometimes it's possible to find sensitive information in clear-text in that folder.
- **Databases**: Android allow to each application to easily save sqlite databases in the path `/data/data/<packagename>/databases/` and sometimes it's possible to find sensitive information in clear-text in that folder.

### Broken TLS

**Accept All Certificates**

For some reason sometimes developers accept all the certificates even if for example the hostname does not match with lines of code like the following one:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Uma boa forma de testar isso é tentar capturar o tráfego usando um proxy como Burp sem autorizar o Burp CA dentro do dispositivo. Também, você pode gerar com Burp um certificado para um hostname diferente e usá-lo.

### Criptografia quebrada

**Processos pobres de gerenciamento de chaves**

Alguns desenvolvedores salvam dados sensíveis no armazenamento local e os criptografam com uma chave hardcoded/predictable no código. Isso não deve ser feito, pois alguma engenharia reversa poderia permitir que atacantes extraiam a informação confidencial.

**Uso de algoritmos inseguros e/ou obsoletos**

Desenvolvedores não devem usar **algoritmos obsoletos** para realizar verificações de autorização, **armazenar** ou **enviar** dados. Alguns desses algoritmos são: RC4, MD4, MD5, SHA1... Se **hashes** são usados para armazenar senhas, por exemplo, devem-se usar hashes resistentes a brute-force com salt.

### Outras verificações

- É recomendado **ofuscar o APK** para dificultar o trabalho de engenharia reversa dos atacantes.
- Se o app for sensível (como bank apps), ele deve realizar suas **próprias verificações para ver se o dispositivo está rootado** e agir em consequência.
- Se o app for sensível (como bank apps), ele deve verificar se um **emulador** está sendo usado.
- Se o app for sensível (como bank apps), ele deve **verificar sua própria integridade antes de executar** para checar se foi modificado.
- Use [**APKiD**](https://github.com/rednaga/APKiD) para verificar qual compiler/packer/obfuscator foi usado para construir o APK

### Aplicação React Native

Leia a página a seguir para aprender como acessar facilmente o código javascript de aplicações React:


{{#ref}}
react-native-application.md
{{#endref}}

### Aplicações Xamarin

Leia a página a seguir para aprender como acessar facilmente o código C# de aplicações Xamarin:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Aplicações Superpacked

De acordo com este [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/), superpacked é um algoritmo Meta que comprime o conteúdo de uma aplicação em um único arquivo. O blog fala sobre a possibilidade de criar um app que descomprima esse tipo de apps... e uma forma mais rápida que envolve **executar a aplicação e coletar os arquivos descomprimidos do sistema de arquivos.**

### Análise Estática Automatizada de Código

A ferramenta [**mariana-trench**](https://github.com/facebook/mariana-trench) é capaz de encontrar **vulnerabilidades** ao **scanear** o **código** da aplicação. Esta ferramenta contém uma série de **known sources** (que indicam à ferramenta os **lugares** onde a **input** é **controlada pelo usuário**), **sinks** (que indicam à ferramenta **lugares perigosos** onde a entrada maliciosa do usuário poderia causar danos) e **rules**. Essas regras indicam a **combinação** de **sources-sinks** que sinaliza uma vulnerabilidade.

Com esse conhecimento, **mariana-trench irá revisar o código e encontrar possíveis vulnerabilidades nele**.

### Segredos leaked

Uma aplicação pode conter segredos (API keys, senhas, hidden urls, subdomínios...) dentro dela que você pode descobrir. Você pode usar uma ferramenta como [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass da Autenticação Biométrica


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Outras funções interessantes

- **Execução de código**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Enviar SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Funções nativas** declaradas como `native`: `public native, System.loadLibrary, System.load`
- [Leia isto para aprender **como reverter funções nativas**](reversing-native-libraries.md)
- Execução de código nativo em memória via JNI (shellcode baixado → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Outros truques**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Análise Dinâmica

> Primeiro, você precisa de um ambiente onde possa instalar a aplicação e todo o ambiente (Burp CA cert, Drozer and Frida principalmente). Portanto, um dispositivo rootado (emulado ou não) é extremamente recomendado.

### Análise dinâmica online

Você pode criar uma **conta grátis** em: [https://appetize.io/](https://appetize.io). Esta plataforma permite **fazer upload** e **executar** APKs, então é útil para ver como um apk está se comportando.

Você pode até **ver os logs da sua aplicação** na web e conectar através de **adb**.

![](<../../images/image (831).png>)

Graças à conexão ADB você pode usar **Drozer** e **Frida** dentro dos emuladores.

### Análise dinâmica local

#### Usando um emulador

- [**Android Studio**](https://developer.android.com/studio) (Você pode criar dispositivos **x86** e **arm**, e de acordo com [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**as versões x86 mais recentes** **suportam bibliotecas ARM** sem precisar de um emulador arm lento).
- Aprenda a configurá-lo nesta página:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Versão gratuita:** Personal Edition, é necessário criar uma conta. _Recomenda-se **baixar** a versão **COM**_ _**VirtualBox** para evitar erros potenciais._)
- [**Nox**](https://es.bignox.com) (Gratuito, mas não suporta Frida ou Drozer).

> [!TIP]
> Ao criar um novo emulador em qualquer plataforma, lembre-se de que quanto maior a tela, mais lento o emulador ficará. Portanto, selecione telas pequenas se possível.

Para **instalar google services** (como AppStore) no Genymotion você precisa clicar no botão marcado em vermelho na imagem a seguir:

![](<../../images/image (277).png>)

Além disso, note que na **configuração da VM Android no Genymotion** você pode selecionar **Bridge Network mode** (isso será útil se você for conectar à VM Android a partir de outra VM com as ferramentas).

#### Usar um dispositivo físico

Você precisa ativar as opções de **depuração** e é bom se você puder dar **root** no dispositivo:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Uma vez que você tenha instalado o aplicativo, a primeira coisa que deve fazer é testá-lo e investigar o que ele faz, como funciona e se familiarizar com ele.\
> Sugiro **realizar essa análise dinâmica inicial usando MobSF dynamic analysis + pidcat**, assim seremos capazes de **aprender como a aplicação funciona** enquanto o MobSF **captura** muitos **dados** **interessantes** que você pode revisar depois.

Magisk/Zygisk quick notes (recommended on Pixel devices)
- Patch boot.img with the Magisk app and flash via fastboot to get systemless root
- Enable Zygisk + DenyList for root hiding; consider LSPosed/Shamiko when stronger hiding is required
- Keep original boot.img to recover from OTA updates; re-patch after each OTA
- For screen mirroring, use scrcpy on the host



### Unintended Data Leakage

**Logging**

Os desenvolvedores devem ter cautela ao expor **informações de depuração** publicamente, pois isso pode levar a sensitive data leaks. As ferramentas [**pidcat**](https://github.com/JakeWharton/pidcat) e `adb logcat` são recomendadas para monitorar os logs da aplicação para identificar e proteger informações sensíveis. **Pidcat** é preferida por sua facilidade de uso e legibilidade.

> [!WARNING]
> Note que a partir de versões mais novas do que Android 4.0, **aplicações só conseguem acessar seus próprios logs**. Então aplicações não podem acessar logs de outros apps.\
> De qualquer forma, ainda é recomendado **não registrar informações sensíveis**.

**Copy/Paste Buffer Caching**

O framework baseado em **clipboard** do Android possibilita a funcionalidade de copiar/colar em apps, porém representa um risco pois **outros aplicativos** podem **acessar** o clipboard, potencialmente expondo dados sensíveis. É crucial **desabilitar funções de copy/paste** para seções sensíveis da aplicação, como detalhes de cartão de crédito, para prevenir data leaks.

**Crash Logs**

Se uma aplicação **crasha** e **salva logs**, esses logs podem auxiliar atacantes, particularmente quando a aplicação não pode ser invertida por engenharia reversa. Para mitigar esse risco, evite registrar em crashes, e se logs precisarem ser transmitidos pela rede, assegure que sejam enviados via um canal SSL para segurança.

Como pentester, **tente dar uma olhada nesses logs**.

**Analytics Data Sent To 3rd Parties**

Aplicações frequentemente integram serviços como Google Adsense, o que pode inadvertidamente leak sensitive data devido a uma implementação incorreta pelos desenvolvedores. Para identificar potenciais leaks, é recomendável **interceptar o tráfego da aplicação** e verificar qualquer informação sensível sendo enviada para serviços de terceiros.

### SQLite DBs

A maioria das aplicações usará **bancos de dados SQLite internos** para salvar informação. Durante o pentest, dê uma **olhada** nos **databases** criados, nos nomes de **tables** e **columns** e em todos os **dados** salvos porque você pode encontrar **informação sensível** (o que seria uma vulnerabilidade).\
Os bancos de dados devem estar localizados em `/data/data/the.package.name/databases` como `/data/data/com.mwr.example.sieve/databases`

Se o database está salvando informação confidencial e está **encrypted** mas você pode **find** a **password** dentro da aplicação, isso ainda é uma **vulnerabilidade**.

Enumere as tabelas usando `.tables` e enumere as colunas das tabelas usando `.schema <table_name>`

### Drozer (Exploração de Activities, Content Providers e Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer is a useful tool to **exploit exported activities, exported services and Content Providers** as you will learn in the following sections.

### Explorando Activities exportadas

[**Leia isto se quiser relembrar o que é uma Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Lembre-se também que o código de uma activity começa no método **`onCreate`**.

**Bypass de autorização**

Quando uma Activity está exportada você pode invocar sua tela a partir de um app externo. Portanto, se uma activity com **informação sensível** estiver **exportada**, você poderia **bypass** os mecanismos de **autenticação** **para acessá-la.**

[**Aprenda como explorar activities exportadas com o Drozer.**](drozer-tutorial/index.html#activities)

Você também pode iniciar uma activity exportada a partir do adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTA**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [este PR](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), aparentemente isso é perigoso apenas em versões antigas (versões da API < 21).

> [!TIP]
> Note that an authorisation bypass nem sempre é uma vulnerabilidade; dependerá de como o bypass funciona e quais informações são expostas.

**Sensitive information leakage**

**Activities can also return results**. Se você conseguir encontrar uma activity exportada e desprotegida que chame o método **`setResult`** e **retorne informações sensíveis**, ocorre um Sensitive information leakage.

#### Tapjacking

Se Tapjacking não for prevenido, você pode abusar da activity exportada para fazer o **usuário executar ações inesperadas**. Para mais informações sobre [**o que é Tapjacking — siga o link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Leia isto se quiser revisar o que é um Content Provider.**](android-applications-basics.md#content-provider)\
Content providers são basicamente usados para **compartilhar dados**. Se um app tem content providers disponíveis você pode ser capaz de **extrair dados sensíveis** deles. Também é interessante testar possíveis **SQL injections** e **Path Traversals**, pois eles podem ser vulneráveis.

[**Aprenda como explorar Content Providers com Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Leia isto se quiser revisar o que é um Service.**](android-applications-basics.md#services)\
Lembre-se que as ações de um Service começam no método `onStartCommand`.

Um Service é basicamente algo que **pode receber dados**, **processá-los** e **retornar** (ou não) uma resposta. Então, se um aplicativo estiver exportando alguns services você deve **verificar** o **código** para entender o que ele está fazendo e **testá-lo** **dinamicamente** para extrair informações confidenciais, contornar medidas de autenticação...\
[**Aprenda como explorar Services com Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Leia isto se quiser revisar o que é um Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Lembre-se que as ações de um Broadcast Receiver começam no método `onReceive`.

Um Broadcast Receiver ficará esperando por um tipo de mensagem. Dependendo de como o receiver trata a mensagem, ele pode ser vulnerável.\
[**Aprenda como explorar Broadcast Receivers com Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Você pode procurar por deep links manualmente, usando ferramentas como MobSF ou scripts como [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Você pode **abrir** um **scheme** declarado usando **adb** ou um **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Observe que você pode **omitir o nome do pacote** e o dispositivo móvel chamará automaticamente o app que deve abrir esse link._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Código executado**

Para encontrar o **código que será executado no App**, vá até a activity chamada pelo deeplink e procure a função **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Informações sensíveis**

Toda vez que encontrar um deep link verifique se ele **não está recebendo dados sensíveis (como senhas) via parâmetros de URL**, porque qualquer outro aplicativo poderia **se passar pelo deep link e roubar esses dados!**

**Parâmetros no path**

Você **deve também verificar se algum deep link está usando um parâmetro dentro do path** da URL como: `https://api.example.com/v1/users/{username}`, nesse caso você pode forçar um path traversal acessando algo como: `example://app/users?username=../../unwanted-endpoint%3fparam=value`.\
Observe que se você encontrar os endpoints corretos dentro da aplicação, pode ser capaz de causar um **Open Redirect** (se parte do path for usada como nome de domínio), **account takeover** (se você puder modificar detalhes de usuários sem token CSRF e o vuln endpoint usar o método correto) e qualquer outra vuln. Mais [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**Mais exemplos**

Um [relatório de bug bounty interessante](https://hackerone.com/reports/855618) sobre links (_/.well-known/assetlinks.json_).

### Inspeção da camada de transporte e falhas de verificação

- **Certificados nem sempre são verificados corretamente** por aplicações Android. É comum que essas aplicações ignorem avisos e aceitem certificados self-signed ou, em alguns casos, revertam para conexões HTTP.
- **As negociações durante o handshake SSL/TLS às vezes são fracas**, usando cipher suites inseguras. Essa vulnerabilidade torna a conexão suscetível a ataques man-in-the-middle (MITM), permitindo que atacantes decifrem os dados.
- **Leakage of private information** é um risco quando aplicações autenticam usando canais seguros mas depois se comunicam por canais não seguros para outras transações. Essa abordagem falha em proteger dados sensíveis, como cookies de sessão ou detalhes do usuário, contra interceptação por agentes maliciosos.

#### Verificação de Certificado

Nós vamos nos concentrar na **verificação de certificados**. A integridade do certificado do servidor deve ser verificada para aumentar a segurança. Isso é crucial porque configurações TLS inseguras e a transmissão de dados sensíveis por canais não criptografados podem representar riscos significativos. Para passos detalhados sobre verificação de certificados de servidor e correção de vulnerabilidades, [**este recurso**](https://manifestsecurity.com/android-application-security-part-10/) fornece orientações abrangentes.

#### SSL Pinning

SSL Pinning é uma medida de segurança onde o aplicativo verifica o certificado do servidor contra uma cópia conhecida armazenada dentro do próprio aplicativo. Esse método é essencial para prevenir ataques MITM. Recomenda-se fortemente implementar SSL Pinning em aplicações que lidam com informações sensíveis.

#### Inspeção de Tráfego

Para inspecionar o tráfego HTTP, é necessário **instalar o certificado da ferramenta proxy** (por exemplo, Burp). Sem instalar esse certificado, o tráfego criptografado pode não ser visível pelo proxy. Para um guia sobre como instalar um certificado CA customizado, [**clique aqui**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Aplicações direcionadas para **API Level 24 and above** exigem modificações no Network Security Config para aceitar o CA certificate do proxy. Esse passo é crítico para inspecionar tráfego criptografado. Para instruções sobre modificar o Network Security Config, [**consulte este tutorial**](make-apk-accept-ca-certificate.md).

Se **Flutter** estiver sendo usado, você precisa seguir as instruções em [**esta página**](flutter.md). Isso porque apenas adicionar o certificado ao store não funcionará, já que Flutter tem sua própria lista de CAs válidas.

#### Detecção estática de SSL/TLS pinning

Antes de tentar bypasses em tempo de execução, mapeie rapidamente onde o pinning é aplicado no APK. A descoberta estática ajuda a planejar hooks/patches e a focar nos caminhos de código corretos.

Tool: SSLPinDetect
- Utilitário de análise estática open-source que decompila o APK para Smali (via apktool) e varre por padrões regex curados de implementações de SSL/TLS pinning.
- Reporta o caminho de arquivo exato, número da linha e um snippet de código para cada correspondência.
- Cobre frameworks comuns e caminhos de código customizados: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init com TrustManagers/KeyManagers customizados, e pins no Network Security Config XML.

Install
- Pré-requisitos: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Uso
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Exemplo de regras de padrão (JSON)
Use ou estenda signatures para detectar estilos de pinning proprietários/personalizados. Você pode carregar seu próprio JSON e realizar varredura em escala.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes and tips
- Fast scanning on large apps via multi-threading and memory-mapped I/O; pre-compiled regex reduces overhead/false positives.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Typical detection targets to triage next:
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Declarative pins in res/xml network security config and manifest references
- Use the matched locations to plan Frida hooks, static patches, or config reviews before dynamic testing.



#### Contornando SSL Pinning

When SSL Pinning is implemented, bypassing it becomes necessary to inspect HTTPS traffic. Various methods are available for this purpose:

- Automatically **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). The best pro of this option, is that you won't need root to bypass the SSL Pinning, but you will need to delete the application and reinstall the new one, and this won't always work.
- You could use **Frida** (discussed below) to bypass this protection. Here you have a guide to use Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- You can also try to **automatically bypass SSL Pinning** using [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- You can also try to **automatically bypass SSL Pinning** using **MobSF dynamic analysis** (explained below)
- If you still think that there is some traffic that you aren't capturing you can try to **forward the traffic to burp using iptables**. Read this blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Procurando vulnerabilidades web comuns

É importante também procurar por vulnerabilidades web comuns dentro da aplicação. Informações detalhadas sobre identificação e mitigação dessas vulnerabilidades estão além do escopo deste resumo, mas são amplamente cobertas em outros locais.

### Frida

[Frida](https://www.frida.re) is a dynamic instrumentation toolkit for developers, reverse-engineers, and security researchers.\
**You can access running application and hook methods on run time to change the behaviour, change values, extract values, run different code...**\
If you want to pentest Android applications you need to know how to use Frida.

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Some "GUI" for actions with Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- You can find some Awesome Frida scripts here: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Try to bypass anti-debugging / anti-frida mechanisms loading Frida as in indicated in [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

Check if the application is storing sensitive information inside the memory that it shouldn't be storing like passwords or mnemonics.

Using [**Fridump3**](https://github.com/rootbsd/fridump3) you can dump the memory of the app with:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Isso fará o dump da memória na pasta ./dump, e lá você pode usar grep com algo como:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Dados sensíveis no Keystore**

No Android, o Keystore é o melhor lugar para armazenar dados sensíveis; no entanto, com privilégios suficientes ainda é **possível acessá-lo**. Como as aplicações tendem a armazenar aqui **dados sensíveis em texto claro**, os pentests devem verificar isso, pois um usuário root ou alguém com acesso físico ao dispositivo pode roubar esses dados.

Mesmo que um app armazene dados no keystore, os dados devem ser criptografados.

Para acessar os dados dentro do keystore você pode usar este Frida script: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Usando o seguinte script do Frida, pode ser possível **bypass fingerprint authentication** que aplicativos Android possam estar implementando para **proteger certas áreas sensíveis:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Imagens de Fundo**

Quando você coloca um aplicativo em segundo plano, o Android armazena um **snapshot do aplicativo** para que, ao ser restaurado para primeiro plano, ele comece a carregar a imagem antes do app, fazendo parecer que o aplicativo foi carregado mais rápido.

No entanto, se esse snapshot contiver **informações sensíveis**, alguém com acesso ao snapshot pode **roubar essa informação** (observe que é necessário root para acessá-lo).

Os snapshots geralmente são armazenados em: **`/data/system_ce/0/snapshots`**

O Android fornece uma forma de **impedir a captura de tela definindo o parâmetro de layout FLAG_SECURE**. Ao usar essa flag, o conteúdo da janela é tratado como seguro, impedindo que apareça em screenshots ou que seja visualizado em displays não seguros.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Esta ferramenta pode ajudar você a gerenciar diferentes ferramentas durante a análise dinâmica: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Desenvolvedores frequentemente criam componentes proxy como activities, services e broadcast receivers que manipulam esses Intents e os passam para métodos como `startActivity(...)` ou `sendBroadcast(...)`, o que pode ser arriscado.

O perigo está em permitir que atacantes acionem componentes da app não-exportados ou acessem content providers sensíveis ao redirecionar esses Intents. Um exemplo notável é o componente `WebView` converter URLs em objetos `Intent` via `Intent.parseUri(...)` e então executá-los, potencialmente levando a injeções de Intent maliciosas.

### Essential Takeaways

- **Intent Injection** é similar ao problema Open Redirect da web.
- Exploits envolvem passar objetos `Intent` como extras, que podem ser redirecionados para executar operações inseguras.
- Pode expor componentes não-exportados e content providers a atacantes.
- A conversão de URL para `Intent` do `WebView` pode facilitar ações não intencionadas.

### Android Client Side Injections and others

Provavelmente você conhece esse tipo de vulnerabilidade da Web. É preciso ter cuidado especial com essas vulnerabilidades em uma aplicação Android:

- **SQL Injection:** Ao lidar com consultas dinâmicas ou Content-Providers, certifique-se de usar consultas parametrizadas.
- **JavaScript Injection (XSS):** Verifique se o suporte a JavaScript e Plugins está desabilitado para quaisquer WebViews (desabilitado por padrão). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** O acesso de WebViews ao sistema de arquivos deve ser desativado (ativado por padrão) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: Em vários casos, quando a aplicação Android encerra a sessão, o cookie não é revogado ou pode até ser salvo no disco
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Análise estática**

![](<../../images/image (866).png>)

**Avaliação de vulnerabilidades da aplicação** usando uma interface web agradável. Você também pode realizar análise dinâmica (mas precisa preparar o ambiente).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Assisted Dynamic analysis with MobSF

**MobSF** can also be very helpful for **dynamic analysis** in **Android**, but in that case you will need to install MobSF and **genymotion** in your host (a VM or Docker won't work). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
The **MobSF dynamic analyser** can:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). All of this is done automatically except for the screenshots, you need to press when you want a screenshot or you need to press "**Exported Activity Tester**" to obtain screenshots of all the exported activities.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: It will print all the loaded classes
- **Capture Strings**: It will print all the capture strings while using the application (super noisy)
- **Capture String Comparisons**: Could be very useful. It will **show the 2 strings being compared** and if the result was True or False.
- **Enumerate Class Methods**: Put the class name (like "java.io.File") and it will print all the methods of the class.
- **Search Class Pattern**: Search classes by pattern
- **Trace Class Methods**: **Trace** a **whole class** (see inputs and outputs of all methods of th class). Remember that by default MobSF traces several interesting Android Api methods.

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf also brings you a shell with some **adb** commands, **MobSF commands**, and common **shell** **commands** at the bottom of the dynamic analysis page. Some interesting commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**Ferramentas HTTP**

Quando o tráfego HTTP é capturado você pode ver uma visão feia do tráfego capturado no botão "**HTTP(S) Traffic**" ou uma visualização mais agradável no botão verde "**Start HTTPTools**". A partir da segunda opção, você pode **enviar** as **requisições capturadas** para **proxies** como Burp ou Owasp ZAP.\
Para isso, _ligue o Burp -->_ _desative o Intercept --> no MobSB HTTPTools selecione a requisição_ --> pressione "**Send to Fuzzer**" --> _selecione o endereço do proxy_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Depois de terminar a análise dinâmica com MobSF você pode pressionar "**Start Web API Fuzzer**" para **fuzz http requests** e procurar vulnerabilidades.

> [!TIP]
> Após realizar uma análise dinâmica com MobSF as configurações de proxy podem ficar mal configuradas e você não conseguirá corrigi-las pela GUI. Você pode corrigir as configurações de proxy executando:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Análise Dinâmica Assistida com Inspeckage

Você pode obter a ferramenta em [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Esta ferramenta usa alguns **Hooks** para mostrar **o que está acontecendo na aplicação** enquanto você realiza uma **análise dinâmica**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Esta é uma **ótima ferramenta para realizar análise estática com uma GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Esta ferramenta foi projetada para procurar diversas **vulnerabilidades relacionadas à segurança em aplicações Android**, seja em **código-fonte** ou em **APKs empacotados**. A ferramenta também é **capaz de criar um APK implantável "Proof-of-Concept"** e **ADB commands**, para explorar algumas das vulnerabilidades encontradas (Exposed activities, intents, tapjacking...). Como no caso do Drozer, não é necessário root no dispositivo de teste.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Exibe todos os arquivos extraídos para fácil referência
- Descompila automaticamente arquivos APK para os formatos Java e Smali
- Analisa o AndroidManifest.xml em busca de vulnerabilidades comuns e comportamentos
- Análise estática do código-fonte em busca de vulnerabilidades comuns e comportamentos
- Informações do dispositivo
- e mais
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER é uma aplicação de linha de comando que pode ser usada no Windows, MacOS X e Linux, que analisa arquivos _.apk_ em busca de vulnerabilidades. Ele faz isso descompactando APKs e aplicando uma série de regras para detectar essas vulnerabilidades.

Todas as regras estão centralizadas em um arquivo `rules.json`, e cada empresa ou testador pode criar suas próprias regras para analisar o que for necessário.

Baixe os binários mais recentes na [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn é uma ferramenta **crossplatform** que auxilia desenvolvedores, bugbounty hunters e ethical hackers na realização de [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) em aplicações móveis.

O conceito é que você arraste e solte o arquivo da sua aplicação móvel (um arquivo .apk ou .ipa) na aplicação StaCoAn e ela gerará um relatório visual e portátil para você. Você pode ajustar as configurações e wordlists para obter uma experiência personalizada.

Baixar[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework é um sistema de análise de vulnerabilidades do Android que ajuda desenvolvedores ou hackers a encontrar potenciais vulnerabilidades de segurança em aplicações Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** é uma ferramenta cujo objetivo principal é detectar e alertar o usuário sobre potenciais comportamentos maliciosos desenvolvidos por uma aplicação Android.

A detecção é realizada com a **static analysis** do Dalvik bytecode da aplicação, representado como **Smali**, com a biblioteca [`androguard`](https://github.com/androguard/androguard).

Esta ferramenta procura por **comportamentos comuns de aplicações "maliciosas"** como: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** é um Framework de **M**obile **A**pplication **R**everse engineering and **A**nalysis. É uma ferramenta que reúne ferramentas comumente usadas para reverse engineering e análise de aplicações móveis, para ajudar a testar aplicações móveis contra as ameaças de segurança móvel do OWASP. Seu objetivo é tornar essa tarefa mais fácil e amigável para desenvolvedores de aplicativos móveis e profissionais de segurança.

É capaz de:

- Extrair código Java e Smali usando diferentes ferramentas
- Analisar APKs usando: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Extrair informações privadas do APK usando regexps.
- Analisar o Manifest.
- Analisar domínios encontrados usando: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) e [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscar APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Útil para detectar malware: [https://koodous.com/](https://koodous.com)

## Obfuscating/Deobfuscating code

Note que, dependendo do serviço e da configuração que você usa para ofuscar o código, segredos podem ou não acabar ofuscados.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** é uma ferramenta de linha de comando open source que reduz, otimiza e ofusca código Java. Ela é capaz de otimizar bytecode assim como detectar e remover instruções não utilizadas. ProGuard é software livre e é distribuído sob a GNU General Public License, versão 2.

ProGuard é distribuído como parte do Android SDK e é executado ao construir a aplicação em modo release.

### [DexGuard](https://www.guardsquare.com/dexguard)

Encontre um guia passo a passo para deobfuscar o apk em [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Na última vez em que conferimos, o modo de operação do Dexguard era:

- carregar um recurso como um InputStream;
- passar o resultado para uma classe que herda de FilterInputStream para descriptografá-lo;
- fazer alguma ofuscação inútil para gastar alguns minutos do tempo de um reverser;
- passar o resultado descriptografado para um ZipInputStream para obter um arquivo DEX;
- finalmente carregar o DEX resultante como um Resource usando o método `loadDex`.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverte o processo de ofuscação executado por ferramentas de ofuscação Android. Isso possibilita diversas análises de segurança, incluindo inspeção de código e predição de bibliotecas.**

Você pode fazer upload de um APK ofuscado para a plataforma deles.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

Esta é uma ferramenta LLM para encontrar quaisquer potenciais vulnerabilidades de segurança em apps Android e deobfuscar código de aplicativos Android. Usa a API pública Gemini do Google.

### [Simplify](https://github.com/CalebFenton/simplify)

É um **deobfuscador genérico para android.** Simplify **executa virtualmente um app** para entender seu comportamento e então **tenta otimizar o código** para que se comporte de forma idêntica, mas seja mais fácil para um humano entender. Cada tipo de otimização é simples e genérica, então não importa qual tipo específico de ofuscação foi usado.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD te dá informações sobre **como um APK foi feito**. Identifica muitos **compilers**, **packers**, **obfuscators**, e outras coisas estranhas. É o [_PEiD_](https://www.aldeid.com/wiki/PEiD) para Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b é uma máquina virtual de segurança Android baseada em ubuntu-mate que inclui a coleção dos frameworks, tutoriais e labs mais recentes de diferentes security geeks e pesquisadores para reverse engineering e análise de malware.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) É uma ótima lista de recursos
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Curso rápido de Android
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
