# Pentesting des Applications Android

{{#include ../../banners/hacktricks-training.md}}

## Notions de base des Applications Android

C'est fortement recommandé de commencer par lire cette page pour connaître les **parties les plus importantes liées à la sécurité Android et les composants les plus dangereux dans une application Android** :


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

C'est l'outil principal dont vous avez besoin pour vous connecter à un appareil Android (émulé ou physique).\
**ADB** permet de contrôler des appareils soit via **USB** soit via **réseau** depuis un ordinateur. Cet utilitaire permet la **copie** de fichiers dans les deux sens, l'**installation** et la **désinstallation** d'applications, l'**exécution** de commandes shell, la **sauvegarde** de données, la **lecture** des logs, entre autres fonctions.

Consultez la liste suivante de [**ADB Commands**](adb-commands.md) pour apprendre à utiliser adb.

## Smali

Il est parfois intéressant de **modifier le code de l'application** pour accéder à des **informations cachées** (par exemple des mots de passe fortement obfusqués ou des flags). Dans ce cas, il peut être utile de décompiler l'apk, modifier le code et recompiler l'apk.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Cela peut être très utile comme **alternative pour plusieurs tests lors de l'analyse dynamique** qui vont être présentés. Ensuite, **gardez toujours à l'esprit cette possibilité**.

## Autres astuces intéressantes

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **Télécharger des APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Extraire l'APK depuis l'appareil:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Fusionnez tous les splits et les apks de base avec [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Études de cas & Vulnérabilités


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Analyse statique

Tout d'abord, pour analyser un APK vous devriez **regarder le code Java** en utilisant un décompilateur.\
Veuillez [**lire ici pour trouver des informations sur les différents décompilateurs disponibles**](apk-decompilers.md).

### Recherche d'informations intéressantes

En regardant simplement les **strings** de l'APK, vous pouvez rechercher des **passwords**, des **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), des **api keys**, de **l'encryption**, des **bluetooth uuids**, des **tokens** et tout ce qui est intéressant... recherchez même des **backdoors** d'exécution de code ou des backdoors d'authentification (hardcoded admin credentials dans l'app).

**Firebase**

Portez une attention particulière aux **firebase URLs** et vérifiez si elles sont mal configurées. [Plus d'informations sur ce qu'est Firebase et comment l'exploiter ici.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Compréhension de base de l'application - Manifest.xml, strings.xml

L'**examen des fichiers _Manifest.xml_ et _strings.xml_ d'une application peut révéler des vulnérabilités potentielles**. Ces fichiers peuvent être consultés via des décompilateurs ou en renommant l'extension du fichier APK en .zip puis en le décompressant.

Les **vulnérabilités** identifiables à partir du **Manifest.xml** incluent :

- Applications débogables : Les applications définies comme debuggable (`debuggable="true"`) dans le fichier _Manifest.xml_ présentent un risque car elles permettent des connexions pouvant mener à une exploitation. Pour mieux comprendre comment exploiter des applications debuggables, consultez un tutoriel sur la recherche et l'exploitation d'applications debuggables sur un device.
- Backup Settings : L'attribut `android:allowBackup="false"` doit être défini explicitement pour les applications traitant des informations sensibles afin d'empêcher des backups non autorisés via adb, surtout lorsque le debug USB est activé.
- Network Security : Les configurations de sécurité réseau personnalisées (`android:networkSecurityConfig="@xml/network_security_config"`) dans _res/xml/_ peuvent spécifier des détails de sécurité tels que les certificate pins et les paramètres de trafic HTTP. Un exemple est d'autoriser le trafic HTTP pour des domaines spécifiques.
- Exported Activities and Services : Identifier les activities et services exportés dans le manifest peut mettre en évidence des composants susceptibles d'être détournés. Une analyse plus poussée en test dynamique peut révéler comment exploiter ces composants.
- Content Providers and FileProviders : Des content providers exposés peuvent permettre un accès ou une modification non autorisés des données. La configuration des FileProviders doit également être scrutée.
- Broadcast Receivers and URL Schemes : Ces composants peuvent être exploités, en portant une attention particulière à la façon dont les URL schemes sont gérés pour les vulnérabilités d'entrée.
- SDK Versions : Les attributs `minSdkVersion`, `targetSDKVersion` et `maxSdkVersion` indiquent les versions Android supportées, soulignant l'importance de ne pas supporter des versions Android obsolètes et vulnérables pour des raisons de sécurité.

Depuis le fichier **strings.xml**, des informations sensibles telles que des API keys, des schémas personnalisés et d'autres notes de développeur peuvent être découvertes, ce qui souligne la nécessité d'un examen attentif de ces ressources.

### Tapjacking

**Tapjacking** est une attaque où une **application** **malicious** est lancée et **se positionne au-dessus d'une application victime**. Une fois qu'elle masque visiblement l'application victime, son interface utilisateur est conçue de manière à tromper l'utilisateur pour qu'il interagisse avec elle, tandis qu'elle transmet l'interaction à l'application victime.\
En pratique, elle **empêche l'utilisateur de savoir qu'il effectue en réalité des actions sur l'application victime**.

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Une **activity** avec le **`launchMode`** réglé sur **`singleTask` sans aucun `taskAffinity`** défini est vulnérable au Task Hijacking. Cela signifie qu'une **application** peut être installée et si elle est lancée avant la vraie application, elle pourrait **détourner la task de la vraie application** (l'utilisateur interagira donc avec la **malicious application en pensant utiliser la vraie**).

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Insecure data storage

**Stockage interne**

Dans Android, les fichiers **stockés** dans le **stockage interne** sont **conçus** pour être **accessibles** exclusivement par l'**app** qui les a **créés**. Cette mesure de sécurité est **appliquée** par le système Android et est généralement adéquate pour les besoins de sécurité de la plupart des applications. Cependant, les développeurs utilisent parfois des modes tels que `MODE_WORLD_READABLE` et `MODE_WORLD_WRITABLE` pour **permettre** le partage de fichiers entre différentes applications. Ces modes **ne restreignent pas l'accès** à ces fichiers par d'autres applications, y compris potentiellement des applications malveillantes.

1. **Analyse statique :**
- **Vérifiez** attentivement l'utilisation de `MODE_WORLD_READABLE` et `MODE_WORLD_WRITABLE`. Ces modes **peuvent exposer** des fichiers à des accès **non intentionnés ou non autorisés**.
2. **Analyse dynamique :**
- **Vérifiez** les **permissions** définies sur les fichiers créés par l'app. En particulier, **contrôlez** si des fichiers sont définis comme lisibles ou modifiables worldwide. Cela peut représenter un risque de sécurité important, car cela permettrait à **n'importe quelle application** installée sur le device, quelle que soit son origine ou son intention, de **lire ou modifier** ces fichiers.

**Stockage externe**

Lorsqu'on traite des fichiers sur le **stockage externe**, comme les SD Cards, certaines précautions doivent être prises :

1. **Accessibilité** :
- Les fichiers sur le stockage externe sont **globalement lisibles et modifiables**. Cela signifie que n'importe quelle application ou utilisateur peut y accéder.
2. **Problèmes de sécurité** :
- Étant donné la facilité d'accès, il est conseillé **de ne pas stocker d'informations sensibles** sur le stockage externe.
- Le stockage externe peut être retiré ou accédé par n'importe quelle application, le rendant moins sécurisé.
3. **Traitement des données provenant du stockage externe** :
- Effectuez toujours une **validation d'entrée** sur les données récupérées depuis le stockage externe. Ceci est crucial car les données proviennent d'une source non fiable.
- Il est fortement déconseillé de stocker des exécutables ou des fichiers de classes sur le stockage externe pour un chargement dynamique.
- Si votre application doit récupérer des fichiers exécutables depuis le stockage externe, assurez-vous que ces fichiers sont **signés et vérifiés cryptographiquement** avant de les charger dynamiquement. Cette étape est vitale pour maintenir l'intégrité de sécurité de votre application.

Le stockage externe peut être **accédé** dans `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> À partir d'Android 4.4 (**API 17**), la SD card a une structure de répertoires qui **limite l'accès d'une app au répertoire qui est spécifiquement pour cette app**. Cela empêche une application malveillante d'obtenir un accès en lecture ou écriture aux fichiers d'une autre app.

**Données sensibles stockées en clair**

- **Shared preferences** : Android permet à chaque application de sauvegarder facilement des fichiers xml dans le chemin `/data/data/<packagename>/shared_prefs/` et parfois il est possible de trouver des informations sensibles en clair dans ce dossier.
- **Databases** : Android permet à chaque application de sauvegarder facilement des bases sqlite dans le chemin `/data/data/<packagename>/databases/` et parfois il est possible de trouver des informations sensibles en clair dans ce dossier.

### Broken TLS

**Accept All Certificates**

Pour une raison quelconque, parfois les développeurs acceptent tous les certificats même si, par exemple, le hostname ne correspond pas, avec des lignes de code comme la suivante :
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Une bonne façon de tester cela est d'essayer de capturer le trafic en utilisant un proxy comme Burp sans autoriser le Burp CA sur l'appareil. Aussi, vous pouvez générer avec Burp un certificat pour un different hostname et l'utiliser.

### Broken Cryptography

**Poor Key Management Processes**

Certains développeurs enregistrent des données sensibles dans le stockage local et les chiffrent avec une clé hardcodée/prédictible dans le code. Cela ne devrait pas être fait car un peu de reversing pourrait permettre à des attaquants d'extraire l'information confidentielle.

**Use of Insecure and/or Deprecated Algorithms**

Les développeurs ne devraient pas utiliser des **deprecated algorithms** pour effectuer des authorisation **checks**, **store** ou **send** des données. Certains de ces algorithmes sont : RC4, MD4, MD5, SHA1... Si des **hashes** sont utilisés pour stocker des mots de passe par exemple, des hashes résistants au brute-force devraient être utilisés avec du salt.

### Other checks

- It's recommended to **obfuscate the APK** to difficult the reverse engineer labour to attackers.
- If the app is sensitive (like bank apps), it should perform it's **own checks to see if the mobile is rooted** and act in consequence.
- If the app is sensitive (like bank apps), it should check if an **emulator** is being used.
- If the app is sensitive (like bank apps), it should **check it's own integrity before executing** it to check if it was modified.
- Use [**APKiD**](https://github.com/rednaga/APKiD) to check which compiler/packer/obfuscator was used to build the APK

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

The tool [**mariana-trench**](https://github.com/facebook/mariana-trench) is capable of finding **vulnerabilities** by **scanning** the **code** of the application. This tool contains a series of **known sources** (that indicates to the tool the **places** where the **input** is **controlled by the user**), **sinks** (which indicates to the tool **dangerous** **places** where malicious user input could cause damages) and **rules**. These rules indicates the **combination** of **sources-sinks** that indicates a vulnerability.

With this knowledge, **mariana-trench will review the code and find possible vulnerabilities on it**.

### Secrets leaked

Une application peut contenir des secrets (API keys, passwords, hidden urls, subdomains...) à l'intérieur qu'il est possible de découvrir. Vous pouvez utiliser un outil tel que [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)
- In-memory native code execution via JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> First of all, you need an environment where you can install the application and all the environment (Burp CA cert, Drozer and Frida mainly). Therefore, a rooted device (emulated or not) is extremely recommended.

### Online Dynamic analysis

You can create a **free account** in: [https://appetize.io/](https://appetize.io). This platform allows you to **upload** and **execute** APKs, so it is useful to see how an apk is behaving.

You can even **see the logs of your application** in the web and connect through **adb**.

![](<../../images/image (831).png>)

Thanks to the ADB connection you can use **Drozer** and **Frida** inside the emulators.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (You can create **x86** and **arm** devices, and according to [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** versions **support ARM libraries** without needing an slow arm emulator).
- Learn to set it up in this page:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, you need to create an account. _It's recommend to **download** the version **WITH**_ _**VirtualBox** to avoid potential errors._)
- [**Nox**](https://es.bignox.com) (Free, but it doesn't support Frida or Drozer).

> [!TIP]
> When creating a new emulator on any platform remember that the bigger the screen is, the slower the emulator will run. So select small screens if possible.

To **install google services** (like AppStore) in Genymotion you need to click on the red marked button of the following image:

![](<../../images/image (277).png>)

Also, notice that in the **configuration of the Android VM in Genymotion** you can select **Bridge Network mode** (this will be useful if you will be connecting to the Android VM from a different VM with the tools).

#### Use a physical device

You need to activate the **debugging** options and it will be cool if you can **root** it:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Once you have installed the application, the first thing you should do is to try it and investigate what does it do, how does it work and get comfortable with it.\
> I will suggest to **perform this initial dynamic analysis using MobSF dynamic analysis + pidcat**, so we will be able to **learn how the application works** while MobSF **captures** a lot of **interesting** **data** you can review later on.

Magisk/Zygisk quick notes (recommended on Pixel devices)
- Patch boot.img with the Magisk app and flash via fastboot to get systemless root
- Enable Zygisk + DenyList for root hiding; consider LSPosed/Shamiko when stronger hiding is required
- Keep original boot.img to recover from OTA updates; re-patch after each OTA
- For screen mirroring, use scrcpy on the host



### Unintended Data Leakage

**Logging**

Developers should be cautious of exposing **debugging information** publicly, as it can lead to sensitive data leaks. The tools [**pidcat**](https://github.com/JakeWharton/pidcat) and `adb logcat` are recommended for monitoring application logs to identify and protect sensitive information. **Pidcat** is favored for its ease of use and readability.

> [!WARNING]
> Note that from **later newer than Android 4.0**, **applications are only able to access their own logs**. So applications cannot access other apps logs.\
> Anyway, it's still recommended to **not log sensitive information**.

**Copy/Paste Buffer Caching**

Android's **clipboard-based** framework enables copy-paste functionality in apps, yet poses a risk as **other applications** can **access** the clipboard, potentially exposing sensitive data. It's crucial to **disable copy/paste** functions for sensitive sections of an application, like credit card details, to prevent data leaks.

**Crash Logs**

If an application **crashes** and **saves logs**, these logs can assist attackers, particularly when the application cannot be reverse-engineered. To mitigate this risk, avoid logging on crashes, and if logs must be transmitted over the network, ensure they are sent via an SSL channel for security.

As pentester, **try to take a look to these logs**.

**Analytics Data Sent To 3rd Parties**

Applications often integrate services like Google Adsense, which can inadvertently **leak sensitive data** due to improper implementation by developers. To identify potential data leaks, it's advisable to **intercept the application's traffic** and check for any sensitive information being sent to third-party services.

### SQLite DBs

Most of the applications will use **internal SQLite databases** to save information. During the pentest take a **look** to the **databases** created, the names of **tables** and **columns** and all the **data** saved because you could find **sensitive information** (which would be a vulnerability).\
Databases should be located in `/data/data/the.package.name/databases` like `/data/data/com.mwr.example.sieve/databases`

If the database is saving confidential information and is **encrypted b**ut you can **find** the **password** inside the application it's still a **vulnerability**.

Enumerate the tables using `.tables` and enumerate the columns of the tables doing `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer is s useful tool to **exploit exported activities, exported services and Content Providers** as you will learn in the following sections.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Also remember that the code of an activity starts in the **`onCreate`** method.

**Authorisation bypass**

When an Activity is exported you can invoke its screen from an external app. Therefore, if an activity with **sensitive information** is **exported** you could **bypass** the **authentication** mechanisms **to access it.**

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

You can also start an exported activity from adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> Notez qu'un authorisation bypass n'est pas toujours une vulnérabilité ; cela dépend de la façon dont le bypass fonctionne et des informations exposées.

**Sensitive information leakage**

**Activities can also return results**. Si vous parvenez à trouver une activity exportée et non protégée appelant la méthode **`setResult`** et **renvoyant des informations sensibles**, il y a une sensitive information leakage.

#### Tapjacking

Si Tapjacking n'est pas empêché, vous pourriez abuser de l'activité exportée pour amener **l'utilisateur à effectuer des actions inattendues**. Pour plus d'infos sur [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers are basically used to **share data**. Si une app dispose de content providers accessibles, vous pourriez être capable d'**extraire des données sensibles** depuis ceux-ci. Il est aussi intéressant de tester d'éventuelles **SQL injections** et **Path Traversals** car elles pourraient être vulnérables.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Rappelez-vous que les actions d'un Service démarrent dans la méthode `onStartCommand`.

Un Service est essentiellement quelque chose qui **peut recevoir des données**, les **traiter** et **renvoyer** (ou non) une réponse. Donc, si une application exporte des services, vous devriez **vérifier** le **code** pour comprendre ce qu'il fait et le **tester** **dynamiquement** pour extraire des informations confidentielles, contourner les mesures d'authentification...\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Rappelez-vous que les actions d'un Broadcast Receiver commencent dans la méthode `onReceive`.

Un broadcast receiver attendra un type de message. Selon la façon dont le receiver gère le message, il pourrait être vulnérable.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

You can look for deep links manually, using tools like MobSF or scripts like [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Vous pouvez **ouvrir** un **scheme** déclaré en utilisant **adb** ou un **navigateur**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Notez que vous pouvez **omettre le nom du package** et le mobile appellera automatiquement l'application qui doit ouvrir ce lien._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Code exécuté**

Pour trouver le **code qui sera exécuté dans l'App**, allez à l'activité appelée par le deeplink et recherchez la fonction **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Informations sensibles**

Chaque fois que vous trouvez un deep link, vérifiez qu'**il ne reçoit pas de données sensibles (comme des mots de passe) via des paramètres d'URL**, car toute autre application pourrait **usurper le deep link et voler ces données !**

**Paramètres dans le chemin**

Vous **devez aussi vérifier si un deep link utilise un paramètre à l'intérieur du chemin** de l'URL comme : `https://api.example.com/v1/users/{username}`, dans ce cas vous pouvez forcer un path traversal en accédant à quelque chose comme : `example://app/users?username=../../unwanted-endpoint%3fparam=value`.\
Remarquez que si vous trouvez les endpoints corrects dans l'application vous pourriez provoquer un **Open Redirect** (si une partie du chemin est utilisée comme nom de domaine), une **account takeover** (si vous pouvez modifier les détails des utilisateurs sans CSRF token et que le vuln endpoint utilisait la méthode correcte) et toute autre vuln. Plus d'[info à ce sujet ici](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

Un [rapport bug bounty intéressant](https://hackerone.com/reports/855618) au sujet des liens (_/.well-known/assetlinks.json_).

### Inspection de la couche transport et échecs de vérification

- **Les certificats ne sont pas toujours correctement inspectés** par les applications Android. Il est courant que ces applications ignorent les avertissements et acceptent des certificats autosignés ou, dans certains cas, repassent aux connexions HTTP.
- **Les négociations pendant le handshake SSL/TLS sont parfois faibles**, utilisant des cipher suites non sécurisées. Cette vulnérabilité rend la connexion susceptible aux attaques man-in-the-middle (MITM), permettant aux attaquants de déchiffrer les données.
- **Leakage of private information** constitue un risque lorsque les applications s'authentifient via des canaux sécurisés mais communiquent ensuite sur des canaux non sécurisés pour d'autres transactions. Cette approche ne protège pas les données sensibles, comme les cookies de session ou les informations utilisateur, contre l'interception par des entités malveillantes.

#### Vérification des certificats

Nous allons nous concentrer sur la **vérification des certificats**. L'intégrité du certificat du serveur doit être vérifiée pour renforcer la sécurité. C'est crucial car des configurations TLS non sécurisées et la transmission de données sensibles sur des canaux non chiffrés peuvent entraîner des risques importants. Pour des étapes détaillées sur la vérification des certificats serveur et la correction des vulnérabilités, [**cette ressource**](https://manifestsecurity.com/android-application-security-part-10/) fournit des directives complètes.

#### SSL Pinning

SSL Pinning est une mesure de sécurité où l'application vérifie le certificat du serveur par rapport à une copie connue stockée dans l'application elle-même. Cette méthode est essentielle pour prévenir les attaques MITM. La mise en œuvre de SSL Pinning est fortement recommandée pour les applications traitant des informations sensibles.

#### Inspection du trafic

Pour inspecter le trafic HTTP, il est nécessaire d'**installer le certificat de l'outil proxy** (par ex., Burp). Sans l'installation de ce certificat, le trafic chiffré pourrait ne pas être visible via le proxy. Pour un guide sur l'installation d'un certificat CA personnalisé, [**cliquez ici**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Les applications ciblant **API Level 24 and above** requièrent des modifications du Network Security Config pour accepter le certificat CA du proxy. Cette étape est critique pour inspecter le trafic chiffré. Pour des instructions sur la modification du Network Security Config, [**consultez ce tutoriel**](make-apk-accept-ca-certificate.md).

Si **Flutter** est utilisé, vous devez suivre les instructions sur [**cette page**](flutter.md). En effet, ajouter simplement le certificat dans le magasin ne fonctionnera pas car Flutter possède sa propre liste de CAs valides.

#### Détection statique du SSL/TLS pinning

Avant d'essayer des runtime bypasses, cartographiez rapidement où le pinning est appliqué dans l'APK. La découverte statique vous aide à planifier les hooks/patches et à vous concentrer sur les bons chemins de code.

Outil: SSLPinDetect
- Utilitaire open-source d'analyse statique qui décompile l'APK en Smali (via apktool) et scanne des motifs regex sélectionnés d'implémentations de SSL/TLS pinning.
- Rapporte le chemin de fichier exact, le numéro de ligne et un extrait de code pour chaque correspondance.
- Couvre les frameworks courants et les chemins de code personnalisés : OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, et les pins Network Security Config XML.

Installation
- Prérequis : Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Utilisation
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Exemples de règles de pattern (JSON)
Utilisez ou étendez des signatures pour détecter des styles de pinning propriétaires/personnalisés. Vous pouvez charger votre propre JSON et analyser à grande échelle.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes et conseils
- Analyse rapide des grandes applications via multi-threading et I/O mémoire mappée ; les regex précompilées réduisent la surcharge/les faux positifs.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Cibles typiques à prioriser ensuite :
- OkHttp : utilisation de CertificatePinner, setCertificatePinner, références de package okhttp3/okhttp
- Custom TrustManagers : javax.net.ssl.X509TrustManager, surcharges de checkServerTrusted
- Custom SSL contexts : SSLContext.getInstance + SSLContext.init avec des managers personnalisés
- Declarative pins dans res/xml network security config et références du manifest
- Utilisez les emplacements trouvés pour planifier des Frida hooks, des patches statiques ou des revues de config avant les tests dynamiques.



#### Contourner SSL Pinning

Lorsque SSL Pinning est implémenté, le contourner devient nécessaire pour inspecter le trafic HTTPS. Plusieurs méthodes sont disponibles pour cela :

- Automatically **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Le principal avantage de cette option est que vous n'aurez pas besoin de root pour bypasser le SSL Pinning, mais vous devrez supprimer l'application et réinstaller la nouvelle, et cela ne fonctionnera pas toujours.
- You could use **Frida** (discussed below) to bypass this protection. Here you have a guide to use Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- You can also try to **automatically bypass SSL Pinning** using [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- You can also try to **automatically bypass SSL Pinning** using **MobSF dynamic analysis** (explained below)
- If you still think that there is some traffic that you aren't capturing you can try to **forward the traffic to burp using iptables**. Read this blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Recherche de vulnérabilités web courantes

Il est important de rechercher aussi les vulnérabilités web courantes au sein de l'application. Les informations détaillées pour identifier et atténuer ces vulnérabilités dépassent le cadre de ce résumé mais sont traitées en profondeur ailleurs.

### Frida

[Frida](https://www.frida.re) est un toolkit d'instrumentation dynamique pour développeurs, reverse-engineers, et chercheurs en sécurité.\
**Vous pouvez accéder à l'application en cours d'exécution et hooker des méthodes au runtime pour changer le comportement, modifier des valeurs, extraire des valeurs, exécuter du code différent...**\
Si vous voulez pentest des applications Android vous devez savoir comment utiliser Frida.

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Some "GUI" for actions with Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- You can find some Awesome Frida scripts here: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Try to bypass anti-debugging / anti-frida mechanisms loading Frida as in indicated in [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Vidage mémoire - Fridump**

Vérifiez si l'application stocke des informations sensibles en mémoire qu'elle ne devrait pas conserver, comme des mots de passe ou des mnémoniques.

Using [**Fridump3**](https://github.com/rootbsd/fridump3) you can dump the memory of the app with:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Cela va effectuer un dump de la mémoire dans le dossier ./dump, et vous pouvez y faire un grep avec quelque chose comme :
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Données sensibles dans Keystore**

Sur Android, le Keystore est l'endroit le plus sûr pour stocker des données sensibles ; toutefois, avec des privilèges suffisants, il est toujours **possible d'y accéder**. Comme les applications ont tendance à stocker ici des **données sensibles en clair**, les pentests doivent le vérifier en tant que root user, car quelqu'un ayant un accès physique à l'appareil pourrait voler ces données.

Même si une app stocke des données dans le keystore, les données doivent être chiffrées.

Pour accéder aux données à l'intérieur du keystore, vous pouvez utiliser ce script Frida: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

En utilisant le script Frida suivant, il pourrait être possible de **bypass fingerprint authentication** qu'effectuent des applications Android pour **protéger certaines zones sensibles :**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Images d'arrière-plan**

Lorsque vous mettez une application en arrière-plan, Android stocke un **instantané de l'application** ; lorsqu'elle est ramenée au premier plan, il commence à charger l'image avant l'application pour donner l'impression que l'application s'est chargée plus rapidement.

Cependant, si cet instantané contient des **informations sensibles**, quelqu'un ayant accès à l'instantané pourrait **voler ces informations** (notez qu'il faut root pour y accéder).

Les instantanés sont généralement stockés à : **`/data/system_ce/0/snapshots`**

Android fournit un moyen de **prévenir la capture d'écran en définissant le paramètre de layout FLAG_SECURE**. En utilisant ce flag, le contenu de la fenêtre est traité comme sécurisé, l'empêchant d'apparaître dans les captures d'écran ou d'être affiché sur des écrans non sécurisés.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Cet outil peut vous aider à gérer différents outils lors de l'analyse dynamique : [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Les développeurs créent souvent des composants proxy comme activities, services et broadcast receivers qui traitent ces Intents et les transmettent à des méthodes telles que `startActivity(...)` ou `sendBroadcast(...)`, ce qui peut être risqué.

Le danger réside dans le fait de permettre à des attaquants de déclencher des composants d'application non exportés ou d'accéder à des content providers sensibles en détournant ces Intents. Un exemple notable est le composant `WebView` convertissant des URLs en objets `Intent` via `Intent.parseUri(...)` puis les exécutant, ce qui peut conduire à des injections d'Intent malveillantes.

### Essential Takeaways

- **Intent Injection** est similaire au problème d'Open Redirect sur le web.
- Les exploits consistent à passer des objets `Intent` en tant qu'extras, qui peuvent être redirigés pour exécuter des opérations non sécurisées.
- Cela peut exposer des composants non exportés et des content providers aux attaquants.
- La conversion d'URL en `Intent` par `WebView` peut faciliter des actions non prévues.

### Android Client Side Injections and others

Vous connaissez probablement ce type de vulnérabilités depuis le Web. Il faut être particulièrement vigilant avec ces vulnérabilités dans une application Android :

- **SQL Injection:** Lors de la gestion de requêtes dynamiques ou de Content-Providers, assurez-vous d'utiliser des requêtes paramétrées.
- **JavaScript Injection (XSS):** Vérifiez que le support JavaScript et Plugin est désactivé pour tout WebView (désactivé par défaut). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** Les WebViews devraient avoir l'accès au système de fichiers désactivé (activé par défaut) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: Dans plusieurs cas, lorsque l'application Android termine la session, le cookie n'est pas révoqué ou peut même être enregistré sur le disque.
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Analyse statique**

![](<../../images/image (866).png>)

**Évaluation des vulnérabilités de l'application** via une interface web conviviale. Vous pouvez aussi effectuer une analyse dynamique (mais il faut préparer l'environnement).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Assisted Dynamic analysis with MobSF

**MobSF** can also be very helpful for **dynamic analysis** in **Android**, but in that case you will need to install MobSF and **genymotion** in your host (a VM or Docker won't work). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
The **MobSF dynamic analyser** can:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). All of this is done automatically except for the screenshots, you need to press when you want a screenshot or you need to press "**Exported Activity Tester**" to obtain screenshots of all the exported activities.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: It will print all the loaded classes
- **Capture Strings**: It will print all the capture strings while using the application (super noisy)
- **Capture String Comparisons**: Could be very useful. It will **show the 2 strings being compared** and if the result was True or False.
- **Enumerate Class Methods**: Put the class name (like "java.io.File") and it will print all the methods of the class.
- **Search Class Pattern**: Search classes by pattern
- **Trace Class Methods**: **Trace** a **whole class** (see inputs and outputs of all methods of th class). Remember that by default MobSF traces several interesting Android Api methods.

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf also brings you a shell with some **adb** commands, **MobSF commands**, and common **shell** **commands** at the bottom of the dynamic analysis page. Some interesting commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**Outils HTTP**

Lorsque le trafic http est capturé, vous pouvez voir une vue brute du trafic capturé sur le bouton "**HTTP(S) Traffic**" en bas ou une vue plus agréable sur le bouton vert "**Start HTTPTools**". Depuis la seconde option, vous pouvez **envoyer** les **requêtes capturées** vers des proxies comme Burp ou Owasp ZAP.\
Pour ce faire, _allumez Burp -->_ _désactivez Intercept --> dans MobSB HTTPTools sélectionnez la requête_ --> appuyez sur "**Send to Fuzzer**" --> _sélectionnez l'adresse du proxy_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Une fois que vous avez terminé l'analyse dynamique avec MobSF, vous pouvez appuyer sur "**Start Web API Fuzzer**" pour **fuzz http requests** et rechercher des vulnérabilités.

> [!TIP]
> Après avoir effectué une analyse dynamique avec MobSF, les paramètres du proxy peuvent être mal configurés et vous ne pourrez pas les corriger depuis la GUI. Vous pouvez corriger les paramètres du proxy en exécutant :
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Analyse dynamique assistée avec Inspeckage

Vous pouvez obtenir l'outil depuis [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Cet outil utilisera des **Hooks** pour vous indiquer **ce qui se passe dans l'application** pendant que vous effectuez une **dynamic analysis**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

C'est un **excellent outil pour effectuer une static analysis avec une GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Cet outil est conçu pour rechercher plusieurs **security related Android application vulnerabilities**, que ce soit dans le **source code** ou dans des **packaged APKs**. L'outil est également **capable of creating a "Proof-of-Concept" deployable APK** et des **ADB commands**, pour exploiter certaines des vulnérabilités trouvées (Exposed activities, intents, tapjacking...). Comme avec Drozer, il n'est pas nécessaire de rooter l'appareil de test.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Affiche tous les fichiers extraits pour une consultation facile
- Décompile automatiquement les fichiers APK en Java et Smali
- Analyse AndroidManifest.xml à la recherche de vulnérabilités courantes et de comportements
- Analyse statique du code source pour détecter des vulnérabilités courantes et des comportements
- Informations sur l'appareil
- et plus encore
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER est une application en ligne de commande qui peut être utilisée sur Windows, MacOS X et Linux, et qui analyse des fichiers _.apk_ à la recherche de vulnérabilités. Elle le fait en décompressant les APKs et en appliquant une série de règles pour détecter ces vulnérabilités.

Toutes les règles sont centralisées dans un fichier `rules.json`, et chaque entreprise ou testeur peut créer ses propres règles selon ses besoins.

Téléchargez les derniers binaires depuis la [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn est un outil **multiplateforme** qui aide les développeurs, bugbounty hunters et ethical hackers à effectuer [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) sur les applications mobiles.

Le principe est que vous glissez-déposez le fichier de votre application mobile (un fichier .apk ou .ipa) sur l'application StaCoAn, et elle générera pour vous un rapport visuel et portable. Vous pouvez ajuster les paramètres et les wordlists pour obtenir une expérience personnalisée.

Télécharger[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework est un système d'analyse des vulnérabilités Android qui aide les développeurs ou les hackers à détecter d'éventuelles failles de sécurité dans les applications Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** est un outil dont l'objectif principal est de détecter et d'alerter l'utilisateur sur les comportements potentiellement malveillants développés par une application Android.

La détection est effectuée via la **static analysis** du Dalvik bytecode de l'application, représenté en **Smali**, à l'aide de la bibliothèque [`androguard`](https://github.com/androguard/androguard).

Cet outil recherche les **comportements courants des applications "malveillantes"** tels que : Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** est un **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. C'est un outil qui regroupe des outils couramment utilisés pour la rétro-ingénierie et l'analyse d'applications mobiles, afin d'aider à tester les applications mobiles contre les menaces de sécurité mobile d'OWASP. Son objectif est de rendre cette tâche plus simple et plus accessible pour les développeurs d'applications mobiles et les professionnels de la sécurité.

Il est capable de :

- Extraire du code Java et Smali en utilisant différents outils
- Analyser des APKs en utilisant : [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Extraire des informations privées de l'APK en utilisant des regexps.
- Analyser le Manifest.
- Analyser les domaines trouvés en utilisant : [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) et [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Déobfusquer l'APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Utile pour détecter du malware : [https://koodous.com/](https://koodous.com)

## Obfuscating/Deobfuscating code

Notez que, selon le service et la configuration que vous utilisez pour obfusquer le code, les secrets peuvent ou non finir obfusqués.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. It is able to optimize bytecode as well as detect and remove unused instructions. ProGuard is free software and is distributed under the GNU General Public License, version 2.

ProGuard is distributed as part of the Android SDK and runs when building the application in release mode.

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Last time we checked, the Dexguard mode of operation was:

- charger une ressource en tant qu'InputStream ;
- fournir le résultat à une classe héritant de FilterInputStream pour la décrypter ;
- effectuer quelques obfuscations inutiles pour faire perdre du temps au reverseur ;
- fournir le résultat déchiffré à un ZipInputStream pour obtenir un fichier DEX ;
- enfin charger le DEX résultant en tant que Resource en utilisant la méthode `loadDex`.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

Vous pouvez uploader un APK obfusqué sur leur plateforme.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

It is a **generic android deobfuscator.** Simplify **virtually executes an app** to understand its behavior and then **tries to optimize the code** so it behaves identically but is easier for a human to understand. Each optimization type is simple and generic, so it doesn't matter what the specific type of obfuscation is used.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD gives you information about **how an APK was made**. It identifies many **compilers**, **packers**, **obfuscators**, and other weird stuff. It's [_PEiD_](https://www.aldeid.com/wiki/PEiD) for Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b est une machine virtuelle de sécurité Android basée sur ubuntu-mate qui inclut une collection des derniers frameworks, tutoriels et labs provenant de différents passionnés et chercheurs en sécurité pour la rétro-ingénierie et l'analyse de malware.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) C'est une excellente liste de ressources
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Cours rapide pour Android
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
