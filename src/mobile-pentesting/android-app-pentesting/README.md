# Pentesting Android aplikacija

{{#include ../../banners/hacktricks-training.md}}

## Osnove Android aplikacija

Preporučuje se da prvo pročitate ovu stranicu kako biste saznali o **najvažnijim delovima vezanim za Android bezbednost i najopasnijim komponentama u Android aplikaciji**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Ovo je glavni alat koji vam treba da se povežete na Android uređaj (emulirani ili fizički).\
**ADB** omogućava kontrolu uređaja preko **USB** ili **Network** sa računara. Ovaj alat omogućava **kopiranje** fajlova u oba smera, **instalaciju** i **deinstalaciju** aplikacija, **izvođenje** shell komandi, **pravljenje backup-a** podataka, **čitanje** logova, između ostalih funkcija.

Pogledajte sledeću listu [**ADB komande**](adb-commands.md) da naučite kako da koristite adb.

## Smali

Ponekad je zanimljivo **izmeniti kod aplikacije** da biste pristupili **skrivenim informacijama** (možda dobro obfuskovane lozinke ili flagovi). U tom slučaju može biti korisno dekompilovati APK, izmeniti kod i ponovo ga kompajlirati.\
[**U ovom tutorijalu** možete **naučiti kako dekompilovati APK, izmeniti Smali kod i ponovo kompajlirati APK** sa novom funkcionalnošću](smali-changes.md). Ovo može biti vrlo korisno kao **alternativa za nekoliko testova tokom dinamičke analize** koja će biti predstavljena. Dakle, **uvek imajte na umu ovu mogućnost**.

## Ostali zanimljivi trikovi

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **Preuzimanje APK-ova**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Ekstraktovanje APK-a sa uređaja:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Spojite sve splits i base apks pomoću [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Studije slučaja i ranjivosti


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Statička analiza

Prvo, za analizu APK-a trebalo bi da **pogledate Java kod** koristeći dekompajler.\
Molimo, [**pročitajte ovde za informacije o različitim dostupnim dekompajlerima**](apk-decompilers.md).

### Traženje zanimljivih informacija

Samo pregledanjem **strings** iz APK-a možete tražiti **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** i sve što je interesantno... tražite čak i code execution **backdoors** ili authentication backdoors (hardcoded admin credentials u aplikaciji).

**Firebase**

Obratite posebnu pažnju na **firebase URLs** i proverite da li je loše konfigurisan. [More information about whats is FIrebase and how to exploit it here.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Osnovno razumevanje aplikacije - Manifest.xml, strings.xml

Ispitivanje aplikacionih _Manifest.xml_ i **_strings.xml_** fajlova može otkriti potencijalne bezbednosne ranjivosti. Ovi fajlovi se mogu pristupiti pomoću dekompajlera ili preimenovanjem APK fajla u .zip i njegovim raspakivanjem.

Ranjivosti identifikovane iz **Manifest.xml** uključuju:

- **Debuggable Applications**: Aplikacije označene kao debuggable (`debuggable="true"`) u _Manifest.xml_ predstavljaju rizik jer omogućavaju konekcije koje mogu dovesti do eksploatacije. Za dodatno razumevanje kako eksploatisati debuggable aplikacije, pogledajte tutorijal o pronalaženju i eksploatisanju debuggable aplikacija na uređaju.
- **Backup Settings**: Atribut `android:allowBackup="false"` treba eksplicitno podesiti za aplikacije koje rade sa osetljivim informacijama kako bi se sprečili neovlašćeni backupi podataka putem adb-a, posebno kada je USB debugging omogućen.
- **Network Security**: Custom network security konfiguracije (`android:networkSecurityConfig="@xml/network_security_config"`) u _res/xml/_ mogu specificirati detalje bezbednosti kao što su certificate pins i podešavanja za HTTP saobraćaj. Primer je dozvoljavanje HTTP saobraćaja za specifične domene.
- **Exported Activities and Services**: Identifikovanje exported activities i services u manifestu može otkriti komponente koje se mogu zloupotrebiti. Dalja analiza tokom dinamičkog testiranja može pokazati kako te komponente eksploatisati.
- **Content Providers and FileProviders**: Izloženi content providers mogu omogućiti neovlašćen pristup ili izmenu podataka. Konfiguracija FileProviders takođe zahteva detaljnu proveru.
- **Broadcast Receivers and URL Schemes**: Ove komponente se mogu iskoristiti za eksploataciju, sa posebnom pažnjom na način na koji su URL schemes upravljane zbog mogućih input ranjivosti.
- **SDK Versions**: Atributi `minSdkVersion`, `targetSDKVersion`, i `maxSdkVersion` ukazuju na podržane Android verzije, naglašavajući važnost nepodrške zastarelih, ranjivih Android verzija iz bezbednosnih razloga.

Iz **strings.xml** fajla mogu se otkriti osetljive informacije kao što su API keys, custom schemas i drugi developer notes, što ističe potrebu za pažljivim pregledom ovih resursa.

### Tapjacking

**Tapjacking** je napad gde se pokrene maliciozna aplikacija i postavi iznad ciljane aplikacije. Kada vizuelno zakloni ciljnu aplikaciju, njen korisnički interfejs je dizajniran tako da prevari korisnika da interaguje sa njim, dok se ta interakcija prosleđuje ciljnoj aplikaciji.\
U suštini, to zaslepljuje korisnika pa ne zna da zapravo izvodi radnje u ciljnoj aplikaciji.

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Aktivnost sa `launchMode` postavljenim na `singleTask` bez definisanog `taskAffinity` je ranjiva na Task Hijacking. To znači da se može instalirati aplikacija koja, ako se pokrene pre prave aplikacije, može preuzeti task prave aplikacije (tako da će korisnik interagovati sa malicioznom aplikacijom misleći da koristi pravu).

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Nezaštićeno čuvanje podataka

Internal Storage

U Androidu, fajlovi koji se čuvaju u internal storage su dizajnirani da budu dostupni isključivo aplikaciji koja ih je kreirala. Ova bezbednosna mera je sprovođena od strane Android operativnog sistema i generalno je dovoljna za bezbednosne potrebe većine aplikacija. Međutim, developeri ponekad koriste režime kao što su `MODE_WORLD_READABLE` i `MODE_WORLD_WRITABLE` da bi omogućili deljenje fajlova između različitih aplikacija. Ipak, ovi režimi ne ograničavaju pristup tim fajlovima drugim aplikacijama, uključujući potencijalno maliciozne.

1. **Static Analysis:**
- **Ensure** da se upotreba `MODE_WORLD_READABLE` i `MODE_WORLD_WRITABLE` pažljivo proveri. Ovi režimi **mogu potencijalno izložiti** fajlove neželjenom ili neautorizovanom pristupu.
2. **Dynamic Analysis:**
- **Verify** permisije postavljene na fajlovima koje aplikacija kreira. Konkretno, **proverite** da li su neki fajlovi **postavljeni kao readable ili writable worldwide**. Ovo može predstavljati značajan bezbednosni rizik, jer bi omogućilo **bilo kojoj aplikaciji** instaliranoj na uređaju, bez obzira na poreklo ili nameru, da **čita ili menja** te fajlove.

External Storage

Kada se radi sa fajlovima na external storage, kao što su SD kartice, treba preduzeti određene mere opreza:

1. **Accessibility**:
- Fajlovi na external storage su **globalno readable i writable**. To znači da bilo koja aplikacija ili korisnik može pristupiti tim fajlovima.
2. **Security Concerns**:
- S obzirom na laku dostupnost, savetuje se **ne čuvati osetljive informacije** na external storage.
- External storage može biti uklonjen ili pristupljen od strane bilo koje aplikacije, što ga čini manje sigurnim.
3. **Handling Data from External Storage**:
- Uvek **izvršite validaciju inputa** na podacima dobijenim iz external storage. Ovo je ključno jer podaci dolaze iz nepouzdanog izvora.
- Snažno se ne preporučuje čuvanje izvršnih fajlova ili class fajlova na external storage radi dinamičkog učitavanja.
- Ako aplikacija mora da učitava izvršne fajlove iz external storage, osigurajte da su ti fajlovi **potpisani i kriptografski verifikovani** pre dinamičkog učitavanja. Ovaj korak je vitalan za očuvanje bezbednosnog integriteta aplikacije.

External storage može se pristupiti u /storage/emulated/0 , /sdcard , /mnt/sdcard

> [!TIP]
> Počevši od Android 4.4 (**API 17**), SD kartica ima strukturu direktorijuma koja **ograničava pristup aplikacije na direktorijum koji je specifičan za tu aplikaciju**. Ovo sprečava malicioznu aplikaciju da dobije read ili write pristup fajlovima druge aplikacije.

**Osetljivi podaci čuvani u plain-textu**

- **Shared preferences**: Android omogućava svakoj aplikaciji da lako sačuva xml fajlove u putanji `/data/data/<packagename>/shared_prefs/` i ponekad je moguće naći osetljive informacije u clear-textu u tom folderu.
- **Databases**: Android omogućava svakoj aplikaciji da lako sačuva sqlite baze podataka u putanji `/data/data/<packagename>/databases/` i ponekad je moguće naći osetljive informacije u clear-textu u tom folderu.

### Broken TLS

**Accept All Certificates**

Iz nekog razloga, ponekad developeri prihvataju sve sertifikate čak i kada, na primer, hostname ne odgovara, sa linijama koda kao u sledećem primeru:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Neispravna kriptografija

**Loši procesi upravljanja ključevima**

Neki developeri čuvaju osetljive podatke u lokalnoj memoriji i enkriptuju ih ključem hardcodiranim/predvidivim u kodu. Ovo ne bi trebalo raditi jer bi neki reversing mogao omogućiti napadačima da izvuku poverljive informacije.

**Korišćenje nesigurnih i/ili zastarelih algoritama**

Developeri ne bi trebalo da koriste **deprecated algorithms** za izvođenje autorizacionih **checks**, za **store** ili **send** podataka. Neki od ovih algoritama su: RC4, MD4, MD5, SHA1... Ako se koriste **hashes** za čuvanje lozinki, na primer, treba koristiti **hashes brute-force resistant** sa salt-om.

### Ostale provere

- Preporučuje se da **obfuscate the APK** kako bi se otežao reverse engineer labour napadačima.
- Ako je aplikacija osetljiva (poput bank apps), treba da izvrši svoje sopstvene provere da li je mobilni **rooted** i da postupi u skladu s tim.
- Ako je aplikacija osetljiva (poput bank apps), treba da proveri da li se koristi **emulator**.
- Ako je aplikacija osetljiva (poput bank apps), treba da **check it's own integrity before executing** kako bi proverila da li je izmenjena.
- Koristite [**APKiD**](https://github.com/rednaga/APKiD) da proverite koji compiler/packer/obfuscator je korišćen za izgradnju APK-a

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

The tool [**mariana-trench**](https://github.com/facebook/mariana-trench) is capable of finding **vulnerabilities** by **scanning** the **code** of the application. This tool contains a series of **known sources** (that indicates to the tool the **places** where the **input** is **controlled by the user**), **sinks** (which indicates to the tool **dangerous** **places** where malicious user input could cause damages) and **rules**. These rules indicates the **combination** of **sources-sinks** that indicates a vulnerability.

With this knowledge, **mariana-trench will review the code and find possible vulnerabilities on it**.

### Secrets leaked

An application may contain secrets (API keys, passwords, hidden urls, subdomains...) inside of it that you might be able to discover. You could us a tool such as [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> Prvo, potrebno je okruženje u kojem možete instalirati aplikaciju i sva okruženja (Burp CA cert, Drozer and Frida prvenstveno). Stoga je veoma preporučljivo imati rooted device (emuliran ili ne).

### Online Dynamic analysis

You can create a **free account** in: [https://appetize.io/](https://appetize.io). This platform allows you to **upload** and **execute** APKs, so it is useful to see how an apk is behaving.

You can even **see the logs of your application** in the web and connect through **adb**.

![](<../../images/image (831).png>)

Thanks to the ADB connection you can use **Drozer** and **Frida** inside the emulators.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (You can create **x86** and **arm** devices, and according to [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** versions **support ARM libraries** without needing an slow arm emulator).
- Learn to set it up in this page:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, you need to create an account. _It's recommend to **download** the version **WITH**_ _**VirtualBox** to avoid potential errors._)
- [**Nox**](https://es.bignox.com) (Free, but it doesn't support Frida or Drozer).

> [!TIP]
> When creating a new emulator on any platform remember that the bigger the screen is, the slower the emulator will run. So select small screens if possible.

To **install google services** (like AppStore) in Genymotion you need to click on the red marked button of the following image:

![](<../../images/image (277).png>)

Also, notice that in the **configuration of the Android VM in Genymotion** you can select **Bridge Network mode** (this will be useful if you will be connecting to the Android VM from a different VM with the tools).

#### Use a physical device

You need to activate the **debugging** options and it will be cool if you can **root** it:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Once you have installed the application, the first thing you should do is to try it and investigate what does it do, how does it work and get comfortable with it.\
> I will suggest to **perform this initial dynamic analysis using MobSF dynamic analysis + pidcat**, so we will be able to **learn how the application works** while MobSF **captures** a lot of **interesting** **data** you can review later on.

### Unintended Data Leakage

**Logging**

Developers should be cautious of exposing **debugging information** publicly, as it can lead to sensitive data leaks. The tools [**pidcat**](https://github.com/JakeWharton/pidcat) and `adb logcat` are recommended for monitoring application logs to identify and protect sensitive information. **Pidcat** is favored for its ease of use and readability.

> [!WARNING]
> Note that from **later newer than Android 4.0**, **applications are only able to access their own logs**. So applications cannot access other apps logs.\
> Anyway, it's still recommended to **not log sensitive information**.

**Copy/Paste Buffer Caching**

Android's **clipboard-based** framework enables copy-paste functionality in apps, yet poses a risk as **other applications** can **access** the clipboard, potentially exposing sensitive data. It's crucial to **disable copy/paste** functions for sensitive sections of an application, like credit card details, to prevent data leaks.

**Crash Logs**

If an application **crashes** and **saves logs**, these logs can assist attackers, particularly when the application cannot be reverse-engineered. To mitigate this risk, avoid logging on crashes, and if logs must be transmitted over the network, ensure they are sent via an SSL channel for security.

As pentester, **try to take a look to these logs**.

**Analytics Data Sent To 3rd Parties**

Applications often integrate services like Google Adsense, which can inadvertently **leak sensitive data** due to improper implementation by developers. To identify potential data leaks, it's advisable to **intercept the application's traffic** and check for any sensitive information being sent to third-party services.

### SQLite DBs

Most of the applications will use **internal SQLite databases** to save information. During the pentest take a **look** to the **databases** created, the names of **tables** and **columns** and all the **data** saved because you could find **sensitive information** (which would be a vulnerability).\
Databases should be located in `/data/data/the.package.name/databases` like `/data/data/com.mwr.example.sieve/databases`

If the database is saving confidential information and is **encrypted b**ut you can **find** the **password** inside the application it's still a **vulnerability**.

Enumerate the tables using `.tables` and enumerate the columns of the tables doing `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer is s useful tool to **exploit exported activities, exported services and Content Providers** as you will learn in the following sections.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Also remember that the code of an activity starts in the **`onCreate`** method.

**Authorisation bypass**

When an Activity is exported you can invoke its screen from an external app. Therefore, if an activity with **sensitive information** is **exported** you could **bypass** the **authentication** mechanisms **to access it.**

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

You can also start an exported activity from adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> Imajte na umu da authorisation bypass nije uvek ranjivost — to zavisi od toga kako bypass funkcioniše i koje informacije su izložene.

**Sensitive information leakage**

**Activities can also return results**. Ako uspete da pronađete exported i nezaštićenu activity koja poziva metodu **`setResult`** i koja vraća osetljive informacije, postoji sensitive information leakage.

#### Tapjacking

Ako tapjacking nije sprečen, možete zloupotrebiti exported activity da naterate **korisnika da izvrši neočekivane radnje**. For more info about [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers se koriste uglavnom za **deljenje podataka**. Ako aplikacija ima dostupne content providers, možda ćete moći da **izvučete osetljive** podatke iz njih. Takođe je interesantno testirati moguće **SQL injections** i **Path Traversals** jer bi mogli biti ranjivi.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Zapamtite da se akcije Service-a pokreću u metodi `onStartCommand`.

Service je u suštini nešto što **može primati podatke**, **procesuirati** ih i (ili ne) **vraća** odgovor. Dakle, ako aplikacija eksportuje neke servise, trebalo bi da **proverite** kod da biste razumeli šta radi i **testirate** ga **dinamički** radi izvlačenja poverljivih informacija, zaobilaženja autentifikacionih mera...
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Zapamtite da se akcije Broadcast Receiver-a pokreću u metodi `onReceive`.

Broadcast receiver će čekati određenu vrstu poruke. U zavisnosti od toga kako receiver obrađuje poruku, može biti ranjiv.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Možete tražiti deep links ručno, koristeći alate kao što su MobSF ili skripte kao [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Možete **open** deklarisani **scheme** koristeći **adb** ili **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Imajte na umu da možete **omit the package name** i mobilni uređaj će automatski pozvati app koji treba da otvori taj link._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Kod koji će biti izvršen**

Da biste pronašli **kod koji će biti izvršen u App**, otiđite na aktivnost koju poziva deeplink i potražite funkciju **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Osetljive informacije**

Svaki put kada nađete deep link, proverite da li **ne prima osetljive podatke (poput lozinki) putem URL parametara**, jer bilo koja druga aplikacija može **lažno predstavljati deep link i ukrasti te podatke!**

**Parametri u putanji**

Takođe **morate proveriti da li neki deep link koristi parametar unutar putanje** URL-a kao: `https://api.example.com/v1/users/{username}`, u tom slučaju možete naterati path traversal pristupom nečemu poput: `example://app/users?username=../../unwanted-endpoint%3fparam=value`.\
Napomena: ako pronađete odgovarajuće endpoint-e unutar aplikacije možda ćete moći da izazovete **Open Redirect** (ako je deo putanje korišćen kao domain name), **account takeover** (ako možete izmeniti podatke korisnika bez CSRF token i ranjivi endpoint je koristio odgovarajući metod) i bilo koju drugu ranjivost. Više informacija o ovome [ovde](http://dphoeniixx.com/2020/12/13-2/).

**Još primera**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Inspekcija transportnog sloja i greške verifikacije

- **Sertifikati nisu uvek pravilno proveravani** od strane Android aplikacija. Često ove aplikacije zanemare upozorenja i prihvate samopotpisane sertifikate ili, u nekim slučajevima, pređu na HTTP konekcije.
- **Pregovori tokom SSL/TLS handshaka ponekad su slabi**, koristeći nesigurne cipher suite-ove. Ova ranjivost čini konekciju podložnom man-in-the-middle (MITM) napadima, dopuštajući napadačima da dešifruju podatke.
- **Iscurivanje privatnih informacija** je rizik kada se aplikacije autentifikuju koristeći sigurne kanale, a zatim komuniciraju preko nesigurnih kanala za druge transakcije. Ovakav pristup ne štiti osetljive podatke, poput session cookies ili podataka korisnika, od presretanja od strane zlonamernih entiteta.

#### Verifikacija sertifikata

Fokusiraćemo se na **verifikaciju sertifikata**. Integritet serverskog sertifikata mora biti verifikovan radi povećanja bezbednosti. Ovo je ključno zato što nesigurne TLS konfiguracije i prenos osetljivih podataka preko nekriptovanih kanala mogu predstavljati značajne rizike. Za detaljne korake kako verifikovati serverske sertifikate i otkloniti ranjivosti, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) pruža obuhvatne smernice.

#### SSL Pinning

SSL Pinning je bezbednosna mera gde aplikacija proverava serverski sertifikat naspram poznate kopije koje su smeštene unutar same aplikacije. Ova metoda je ključna za sprečavanje MITM napada. Preporučuje se implementacija SSL Pinning-a za aplikacije koje obrađuju osetljive informacije.

#### Inspekcija saobraćaja

Za inspekciju HTTP saobraćaja neophodno je **instalirati sertifikat proxy alata** (npr. Burp). Bez instaliranja ovog sertifikata, enkriptovani saobraćaj možda neće biti vidljiv kroz proxy. Za vodič o instaliranju custom CA sertifikata, [**kliknite ovde**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Aplikacije koje ciljaju **API Level 24 and above** zahtevaju izmene Network Security Config da bi prihvatile proxy-jev CA sertifikat. Ovaj korak je kritičan za inspekciju enkriptovanog saobraćaja. Za instrukcije o izmeni Network Security Config, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

Ako se koristi **Flutter**, potrebno je pratiti instrukcije na [**ovoj stranici**](flutter.md). To je zato što samo dodavanje sertifikata u store neće raditi jer Flutter ima sopstvenu listu validnih CA.

#### Statičko otkrivanje SSL/TLS pinning

Pre nego što pokušate runtime bypass-ove, brzo mapirajte gde je pinning primenjen u APK-u. Statičko otkrivanje pomaže da isplanirate hooks/patches i fokusirate se na prave kodne putanje.

Tool: SSLPinDetect
- Open-source static-analysis utility that decompiles the APK to Smali (via apktool) and scans for curated regex patterns of SSL/TLS pinning implementations.
- Reports exact file path, line number, and a code snippet for each match.
- Covers common frameworks and custom code paths: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Upotreba
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Primer pravila obrazaca (JSON)
Koristite ili proširite signatures za otkrivanje vlasničkih/prilagođenih pinning styles. Možete učitati sopstveni JSON i scan at scale.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Beleške i saveti
- Brzo skeniranje velikih aplikacija pomoću višestrukih niti i memorijski mapiranog I/O; pre-kompajlirani regex smanjuje režijske troškove i lažne pozitivne rezultate.
- Kolekcija patterna: https://github.com/aancw/smali-sslpin-patterns
- Tipične mete za sledeću trijažu:
- OkHttp: korišćenje CertificatePinner, setCertificatePinner, reference paketa okhttp3/okhttp
- Prilagođeni TrustManagers: javax.net.ssl.X509TrustManager, override-ovi checkServerTrusted
- Prilagođeni SSL konteksti: SSLContext.getInstance + SSLContext.init sa prilagođenim menadžerima
- Deklarativni pins u res/xml network security config i reference u manifestu
- Koristite podudarne lokacije da planirate Frida hook-ove, statičke zakrpe ili preglede konfiguracije pre dinamičkog testiranja.



#### Bypassing SSL Pinning

Kada je implementiran SSL Pinning, za inspekciju HTTPS saobraćaja postaje neophodno zaobići ga. Postoji više metoda za to:

- Automatically **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Najveća prednost ove opcije je da vam neće trebati root da zaobiđete SSL Pinning, ali ćete morati obrisati aplikaciju i ponovo instalirati novu, i to ne radi uvek.
- You could use **Frida** (discussed below) to bypass this protection. Ovde imate vodič za korišćenje Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- You can also try to **automatically bypass SSL Pinning** using [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- You can also try to **automatically bypass SSL Pinning** using **MobSF dynamic analysis** (explained below)
- If you still think that there is some traffic that you aren't capturing you can try to **forward the traffic to burp using iptables**. Pročitajte ovaj blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Looking for Common Web Vulnerabilities

Važno je takođe tražiti uobičajene web ranjivosti unutar aplikacije. Detaljne informacije o identifikaciji i ublažavanju ovih ranjivosti su izvan opsega ovog sažetka, ali su obimno pokrivene drugde.

### Frida

[Frida](https://www.frida.re) je dynamic instrumentation toolkit za developere, reverse-engineere i security istraživače.\
**Možete pristupiti pokrenutoj aplikaciji i hook-ovati metode u runtime-u da promenite ponašanje, promenite vrednosti, izvučete vrednosti, pokrenete drugačiji kod...**\
Ako želite pentest Android applications morate znati kako koristiti Frida.

- Naučite kako koristiti Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Neki "GUI" za rad sa Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection je odličan za automatizaciju upotrebe Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Možete pronaći neke Awesome Frida skripte ovde: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Pokušajte zaobići anti-debugging / anti-frida mehanizme učitavanjem Frida kako je prikazano u [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (alat [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

Proverite da li aplikacija skladišti osetljive informacije u memoriji koje ne bi trebala da čuva, kao što su lozinke ili mnemonici.

Korišćenjem [**Fridump3**](https://github.com/rootbsd/fridump3) možete izdumpovati memoriju aplikacije pomoću:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Ovo će napraviti dump memorije u folder ./dump, i tamo možeš pokrenuti grep sa nečim poput:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Osetljivi podaci u Keystore**

Na Androidu je Keystore najbolje mesto za čuvanje osetljivih podataka, međutim, sa dovoljno privilegija i dalje je **moguće pristupiti njemu**. Pošto aplikacije često ovde čuvaju **osetljive podatke u clear text**, pentests bi trebalo da to provere koristeći root user, jer neko sa fizičkim pristupom uređaju može da ukrade te podatke.

Čak i ako aplikacija skladišti podatke u Keystore, podaci bi trebalo da budu šifrovani.

Za pristup podacima unutar Keystore možete koristiti ovaj Frida script: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Korišćenjem sledećeg Frida skripta moguće je **bypass fingerprint authentication** koje Android aplikacije sprovode kako bi **zaštitile određene osetljive oblasti:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Pozadinske slike**

Kada aplikaciju pošaljete u pozadinu, Android čuva **snimak aplikacije** tako da, kada se vrati u prvi plan, najpre učitava tu sliku pre same aplikacije pa izgleda kao da se aplikacija brže učitala.

Međutim, ako taj snimak sadrži **osetljive informacije**, neko ko ima pristup snimku može **ukrasti te podatke** (napomena: za pristup je potreban root).

Snimci se obično nalaze na: **`/data/system_ce/0/snapshots`**

Android pruža način da se **spreči snimanje ekrana postavljanjem FLAG_SECURE** layout parametra. Korišćenjem ovog flag-a, sadržaj prozora se tretira kao zaštićen, čime se sprečava njegovo pojavljivanje u screenshot-ovima ili pregledanje na nesigurnim prikazima.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Ovaj alat može pomoći u upravljanju različitim alatima tokom dinamičke analize: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Developeri često kreiraju proxy komponente kao što su activities, services i broadcast receivers koje obrađuju ove Intent-e i prosleđuju ih metodama kao što su `startActivity(...)` ili `sendBroadcast(...)`, što može biti rizično.

Opasnost je u tome što napadačima može biti omogućeno da pokrenu non-exported app components ili pristupe osetljivim content providers preusmeravanjem ovih Intent-a. Istaknut primer je `WebView` komponenta koja konvertuje URL-ove u `Intent` objekte preko `Intent.parseUri(...)` i zatim ih izvršava, što može dovesti do malicious Intent injections.

### Ključne napomene

- **Intent Injection** je sličan Open Redirect issue na webu.
- Exploiti uključuju prosleđivanje `Intent` objekata kao extras, koji mogu biti preusmereni da izvrše unsafe operacije.
- Može izložiti non-exported components i content providers napadačima.
- `WebView`-ova konverzija URL-a u `Intent` može omogućiti neželjene akcije.

### Android Client Side Injections and others

Verovatno već znate za ovu vrstu ranjivosti sa Weba. Posebno morate biti pažljivi sa ovim ranjivostima u Android aplikaciji:

- **SQL Injection:** Kada radite sa dinamičkim upitima ili Content-Providers, osigurajte da koristite parametrizovane upite.
- **JavaScript Injection (XSS):** Proverite da li je podrška za JavaScript i Plugin onemogućena za sve WebViews (onemogućeno po defaultu). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews bi trebalo da imaju onemogućen pristup file system-u (po defaultu omogućeno) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: U nekoliko slučajeva, kada android aplikacija završi sesiju, cookie nije opozvan ili čak može biti sačuvan na disku
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatska analiza

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Staticka analiza**

![](<../../images/image (866).png>)

**Procena ranjivosti aplikacije** koristeći lep web-based frontend. Možete takođe izvesti dinamičku analizu (ali morate pripremiti okruženje).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Assisted Dynamic analysis with MobSF

**MobSF** can also be very helpful for **dynamic analysis** in **Android**, but in that case you will need to install MobSF and **genymotion** in your host (a VM or Docker won't work). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
The **MobSF dynamic analyser** can:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). All of this is done automatically except for the screenshots, you need to press when you want a screenshot or you need to press "**Exported Activity Tester**" to obtain screenshots of all the exported activities.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: It will print all the loaded classes
- **Capture Strings**: It will print all the capture strings while using the application (super noisy)
- **Capture String Comparisons**: Could be very useful. It will **show the 2 strings being compared** and if the result was True or False.
- **Enumerate Class Methods**: Put the class name (like "java.io.File") and it will print all the methods of the class.
- **Search Class Pattern**: Search classes by pattern
- **Trace Class Methods**: **Trace** a **whole class** (see inputs and outputs of all methods of th class). Remember that by default MobSF traces several interesting Android Api methods.

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf also brings you a shell with some **adb** commands, **MobSF commands**, and common **shell** **commands** at the bottom of the dynamic analysis page. Some interesting commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP tools**

Kada se HTTP saobraćaj snimi, možete videti ružan prikaz uhvaćenog saobraćaja na dnu "**HTTP(S) Traffic**" dugmeta ili lepši prikaz na zelenom dugmetu "**Start HTTPTools**". Iz druge opcije možete **poslati** **uhvaćene zahteve** na **proxies** kao što su Burp ili Owasp ZAP.\
Da biste to uradili, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> pritisnite "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Kada završite dynamic analysis sa MobSF, možete pritisnuti "**Start Web API Fuzzer**" da **fuzz http requests** i tražite ranjivosti.

> [!TIP]
> Nakon izvođenja dynamic analysis sa MobSF proxy podešavanja mogu biti pogrešno konfigurisana i nećete moći da ih popravite iz GUI-ja. Možete popraviti proxy podešavanja izvršavanjem:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

You can get the tool from [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Ovaj alat koristi neke **Hooks** kako bi vam pokazao **šta se dešava u aplikaciji** dok izvršavate **dynamic analysis**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Ovo je odličan alat za izvođenje static analysis pomoću GUI-ja

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Ovaj alat je dizajniran da pronađe različite **security related Android application vulnerabilities**, bilo u **source code** ili u **packaged APKs**. Alat je takođe **capable of creating a "Proof-of-Concept" deployable APK** i **ADB commands**, za iskorišćavanje nekih od pronađenih ranjivosti (Exposed activities, intents, tapjacking...). Kao i kod Drozer, nije potrebno root-ovati test uređaj.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Prikazuje sve izvađene datoteke radi lakšeg pregleda
- Automatski dekompajlira APK datoteke u Java i Smali format
- Analizira AndroidManifest.xml zbog uobičajenih ranjivosti i ponašanja
- Statička analiza izvornog koda radi uobičajenih ranjivosti i ponašanja
- Informacije o uređaju
- i još mnogo toga
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER je aplikacija komandne linije koja se može koristiti na Windows, MacOS X i Linux, i koja analizira _.apk_ fajlove u potrazi za ranjivostima. To radi dekompresovanjem APK-ova i primenom niza pravila kako bi otkrila te ranjivosti.

Sva pravila su sadržana u fajlu `rules.json`, i svaka kompanija ili tester može kreirati sopstvena pravila za analizu onoga što im je potrebno.

Preuzmite najnovije binarne fajlove sa [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn je **crossplatform** alat koji pomaže programerima, bugbounty hunters i ethical hackers pri izvođenju [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) na mobilnim aplikacijama.

Koncept je da prevučete i ispustite fajl vaše mobilne aplikacije (an .apk or .ipa file) na StaCoAn aplikaciju i on će za vas generisati vizuelan i prenosiv izveštaj. Možete prilagoditi podešavanja i wordlists da biste dobili prilagođeno iskustvo.

Preuzmi[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework je sistem za analizu ranjivosti za Android koji pomaže developers or hackers da pronađu potencijalne sigurnosne ranjivosti u Android aplikacijama.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** je alat čija je glavna svrha da detektuje i upozori korisnika na potencijalno maliciozna ponašanja koja potiču iz Android aplikacije.

Detekcija se vrši pomoću **static analysis** Dalvik bytecode-a aplikacije, predstavljenog kao **Smali**, koristeći biblioteku [`androguard`](https://github.com/androguard/androguard).

Ovaj alat traži **uobičajena ponašanja "loših" aplikacija** kao što su: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. To je alat koji okuplja često korišćene alate za reverse engineering i analizu mobilnih aplikacija, kako bi pomogao u testiranju mobilnih aplikacija protiv OWASP mobile security threats. Njegov cilj je da ovaj zadatak učini jednostavnijim i pristupačnijim za developere mobilnih aplikacija i bezbednosne profesionalce.

It is able to:

- Extract Java and Smali code using different tools
- Analyze APKs using: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Extract private information from the APK using regexps.
- Analyze the Manifest.
- Analyze found domains using: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Korisno za otkrivanje malvera: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Imajte na umu da, u zavisnosti od servisa i konfiguracije koje koristite za obfuskaciju koda, tajne mogu ili ne moraju biti obfuskirane.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** je alat otvorenog koda komandne linije koji smanjuje, optimizuje i obfuskira Java kod. U mogućnosti je da optimizuje bytecode kao i da detektuje i ukloni neiskorišćena uputstva. ProGuard je slobodan softver i distribuira se pod GNU General Public License, verzija 2.

ProGuard se isporučuje kao deo Android SDK-a i pokreće se pri buildovanju aplikacije u release modu.

### [DexGuard](https://www.guardsquare.com/dexguard)

Pronađite korak-po-korak vodič za deobfuskaciju apk-a na [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(Iz tog vodiča) Poslednji put kada smo proveravali, Dexguard režim rada je bio:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

Možete otpremiti obfuskovani APK na njihovu platformu.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

To je **generički android deobfuscator.** Simplify **virtually executes an app** da bi razumeo njeno ponašanje i zatim **tries to optimize the code** tako da se ponaša identično, ali bude lakše razumljiv čoveku. Svaka vrsta optimizacije je jednostavna i generička, tako da nije bitno koja specifična vrsta obfuskacije je korišćena.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD gives you information about **how an APK was made**. Identifikuje mnoge **compilers**, **packers**, **obfuscators**, i druge neobične stvari. It's [_PEiD_](https://www.aldeid.com/wiki/PEiD) for Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b je Android security virtual machine bazirana na ubuntu-mate koja uključuje kolekciju najnovijih framework-a, tutorijala i labova od različitih security entuzijasta i istraživača za reverse engineering i analizu malvera.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) To je odlična lista resursa
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)

## Yet to try

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
