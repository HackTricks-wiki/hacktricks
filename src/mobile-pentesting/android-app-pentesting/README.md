# Aplicaciones Android Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Fundamentos de Aplicaciones Android

It's highly recommended to start reading this page to know about the **most important parts related to Android security and the most dangerous components in an Android application**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Esta es la herramienta principal que necesitas para conectarte a un dispositivo Android (emulado o físico).\
**ADB** permite controlar dispositivos ya sea por **USB** o **Network** desde un ordenador. Esta utilidad permite la **copia** de archivos en ambas direcciones, la **instalación** y **desinstalación** de apps, la **ejecución** de comandos shell, la **copia de seguridad** de datos, la **lectura** de logs, entre otras funciones.

Echa un vistazo a la siguiente lista de [**ADB Commands**](adb-commands.md) para aprender a usar adb.

## Smali

En ocasiones es interesante **modificar el código de la aplicación** para acceder a **información oculta** (por ejemplo contraseñas bien ofuscadas o flags). Entonces, puede ser útil descompilar el apk, modificar el código y recompilarlo.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Esto puede ser muy útil como **alternativa para varias pruebas durante el análisis dinámico** que se van a presentar. Por tanto, **ten siempre en mente esta posibilidad**.

## Other interesting tricks

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [Android IME / InputMethodService Abuse (Malicious Keyboards)](inputmethodservice-ime-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Extraer APK del dispositivo:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Fusiona todos los splits y apks base con [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Android Enterprise & Work Profile Attacks

{{#ref}}
android-enterprise-work-profile-bypass.md
{{#endref}}

## Casos de estudio y vulnerabilidades


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}


{{#ref}}
../../binary-exploitation/linux-kernel-exploitation/arm64-static-linear-map-kaslr-bypass.md
{{#endref}}

## Análisis estático

Primero, para analizar un APK deberías **echar un vistazo al código Java** usando un decompilador.\
Por favor, [**lee aquí para encontrar información sobre los diferentes decompiladores disponibles**](apk-decompilers.md).

### Buscando información interesante

Con solo mirar las **strings** del APK puedes buscar **contraseñas**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **claves API**, **encryption**, **bluetooth uuids**, **tokens** y cualquier cosa interesante... busca incluso **backdoors** de ejecución de código o backdoors de autenticación (credenciales de admin hardcoded en la app).

**Firebase**

Presta especial atención a las **URLs de Firebase** y verifica si está mal configurado. [Más información sobre qué es Firebase y cómo explotarlo aquí.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Comprensión básica de la aplicación - Manifest.xml, strings.xml

El **examen del _Manifest.xml_ y de los archivos **_strings.xml_** de una aplicación puede revelar posibles vulnerabilidades de seguridad**. Estos archivos pueden accederse usando decompiladores o renombrando la extensión del APK a .zip y luego descomprimiéndolo.

**Vulnerabilidades** identificables desde el **Manifest.xml** incluyen:

- **Aplicaciones depurables**: Las aplicaciones marcadas como debuggable (`debuggable="true"`) en el _Manifest.xml_ representan un riesgo ya que permiten conexiones que pueden llevar a explotación. Para entender mejor cómo explotar aplicaciones debuggables, consulta un tutorial sobre cómo encontrarlas y explotarlas en un dispositivo.
- **Configuración de backup**: El atributo `android:allowBackup="false"` debería establecerse explícitamente para aplicaciones que manejan información sensible para prevenir backups no autorizados vía adb, especialmente cuando usb debugging está habilitado.
- **Seguridad de red**: Configuraciones de seguridad de red personalizadas (`android:networkSecurityConfig="@xml/network_security_config"`) en _res/xml/_ pueden especificar detalles de seguridad como certificate pins y ajustes de tráfico HTTP. Un ejemplo es permitir tráfico HTTP para dominios específicos.
- **Activities y Services exportados**: Identificar activities y services exportados en el manifest puede destacar componentes que podrían ser mal usados. Un análisis más profundo durante pruebas dinámicas puede revelar cómo explotar estos componentes.
- **Content Providers y FileProviders**: Los content providers expuestos podrían permitir acceso o modificación no autorizada de datos. También debe analizarse la configuración de los FileProviders.
- **Broadcast Receivers y URL Schemes**: Estos componentes podrían aprovecharse para explotación, prestando especial atención a cómo se gestionan los URL schemes para vulnerabilidades de entrada.
- **Versiones del SDK**: Los atributos `minSdkVersion`, `targetSDKVersion`, y `maxSdkVersion` indican las versiones de Android soportadas, lo que resalta la importancia de no soportar versiones antiguas y vulnerables de Android por razones de seguridad.

Desde el archivo **strings.xml**, se puede descubrir información sensible como claves API, esquemas personalizados y otras notas de desarrollador, subrayando la necesidad de revisar cuidadosamente estos recursos.

### Tapjacking

**Tapjacking** es un ataque donde se lanza una **aplicación maliciosa** y **se posiciona encima de una aplicación víctima**. Una vez que oscurece visualmente la app víctima, su interfaz de usuario está diseñada de forma que engaña al usuario para que interactúe con ella, mientras pasa la interacción a la app víctima.\
En efecto, está **impidiendo que el usuario sepa que en realidad está realizando acciones en la aplicación víctima**.

Encuentra más información en:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Una **activity** con el **`launchMode`** configurado como **`singleTask` sin ningún `taskAffinity`** definido es vulnerable a Task Hijacking. Esto significa que una **aplicación** puede ser instalada y, si se lanza antes que la aplicación real, podría **secuestrar la task de la aplicación real** (por lo que el usuario interactuará con la **aplicación maliciosa creyendo que está usando la real**).

Más info en:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Almacenamiento de datos inseguro

**Internal Storage**

En Android, los archivos **almacenados** en **internal** storage están **diseñados** para ser **accesibles** exclusivamente por la **app** que los **creó**. Esta medida de seguridad es **impuesta** por el sistema operativo Android y suele ser adecuada para la mayoría de las aplicaciones. Sin embargo, los desarrolladores a veces utilizan modos como `MODE_WORLD_READABLE` y `MODE_WORLD_WRITABLE` para **permitir** que los archivos sean **compartidos** entre diferentes aplicaciones. Estos modos, no obstante, **no restringen el acceso** a dichos archivos por otras aplicaciones, incluidas las potencialmente maliciosas.

1. **Análisis estático:**
- **Asegúrate** de que el uso de `MODE_WORLD_READABLE` y `MODE_WORLD_WRITABLE` sea **examinado cuidadosamente**. Estos modos **pueden exponer** archivos a **accesos no intencionados o no autorizados**.
2. **Análisis dinámico:**
- **Verifica** los **permisos** establecidos en los archivos creados por la app. Específicamente, **revisa** si algún archivo está **configurado como legible o escribible por todo el mundo**. Esto puede suponer un riesgo significativo de seguridad, ya que permitiría que **cualquier aplicación** instalada en el dispositivo, independientemente de su origen o intención, **lea o modifique** dichos archivos.

**External Storage**

Al tratar con archivos en **external storage**, como tarjetas SD, deben tomarse ciertas precauciones:

1. **Accesibilidad**:
- Los archivos en external storage son **globalmente legibles y escribibles**. Esto significa que cualquier aplicación o usuario puede acceder a ellos.
2. **Preocupaciones de seguridad**:
- Dada la facilidad de acceso, se recomienda **no almacenar información sensible** en external storage.
- El storage externo puede extraerse o ser accedido por cualquier aplicación, lo que lo hace menos seguro.
3. **Manejo de datos desde external storage**:
- Siempre **realiza validación de entrada** en los datos recuperados desde external storage. Esto es crucial porque los datos provienen de una fuente no confiable.
- Desaconsejado almacenar ejecutables o class files en external storage para carga dinámica.
- Si tu aplicación debe recuperar archivos ejecutables desde external storage, asegúrate de que esos archivos estén **firmados y verificados criptográficamente** antes de cargarlos dinámicamente. Este paso es vital para mantener la integridad de seguridad de tu aplicación.

External storage puede ser **accedido** en `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> A partir de Android 4.4 (**API 17**), la tarjeta SD tiene una estructura de directorios que **limita el acceso de una app al directorio que está específicamente para esa app**. Esto evita que una aplicación maliciosa obtenga acceso de lectura o escritura a los archivos de otra app.

**Datos sensibles almacenados en texto plano**

- **Shared preferences**: Android permite a cada aplicación guardar fácilmente archivos xml en la ruta `/data/data/<packagename>/shared_prefs/` y a veces es posible encontrar información sensible en texto plano en esa carpeta.
- **Databases**: Android permite a cada aplicación guardar fácilmente bases de datos sqlite en la ruta `/data/data/<packagename>/databases/` y a veces es posible encontrar información sensible en texto plano en esa carpeta.

### Broken TLS

**Accept All Certificates**

Por alguna razón, a veces los desarrolladores aceptan todos los certificados incluso si, por ejemplo, el hostname no coincide con líneas de código como la siguiente:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Una buena forma de probar esto es intentar capturar el tráfico usando un proxy como Burp sin autorizar Burp CA dentro del dispositivo. Además, puedes generar con Burp un certificado para un hostname diferente y usarlo.

### Criptografía rota

**Procesos deficientes de gestión de claves**

Algunos desarrolladores guardan datos sensibles en el almacenamiento local y los cifran con una clave hardcoded/predictable en el código. No debería hacerse, ya que cierto reversing podría permitir a atacantes extraer la información confidencial.

**Uso de algoritmos inseguros y/o obsoletos**

Los desarrolladores no deberían usar **algoritmos obsoletos** para realizar **checks** de autorización, **almacenar** o **enviar** datos. Algunos de estos algoritmos son: RC4, MD4, MD5, SHA1... Si se usan **hashes** para almacenar contraseñas, por ejemplo, deben utilizarse hashes resistentes a brute-force con salt.

### Otras comprobaciones

- Se recomienda **obfuscar el APK** para dificultar el trabajo de reverse engineering a los atacantes.
- Si la app es sensible (como apps bancarias), debe realizar sus **propias comprobaciones para ver si el móvil está rooted** y actuar en consecuencia.
- Si la app es sensible (como apps bancarias), debe comprobar si se está usando un **emulator**.
- Si la app es sensible (como apps bancarias), debe **comprobar su propia integridad antes de ejecutarse** para verificar si fue modificada.
- Usa [**APKiD**](https://github.com/rednaga/APKiD) para comprobar qué compiler/packer/obfuscator se usó para construir el APK

### Aplicación React Native

Lee la siguiente página para aprender cómo acceder fácilmente al código javascript de aplicaciones React:


{{#ref}}
react-native-application.md
{{#endref}}

### Aplicaciones Xamarin

Lee la siguiente página para aprender cómo acceder fácilmente al código C# de aplicaciones Xamarin:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Aplicaciones Superpacked

Según este [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/), superpacked es un algoritmo Meta que comprime el contenido de una aplicación en un único archivo. El blog habla sobre la posibilidad de crear una app que descomprima este tipo de aplicaciones... y una forma más rápida que implica **ejecutar la aplicación y recoger los archivos descomprimidos del sistema de archivos.**

### Análisis estático de código automatizado

La herramienta [**mariana-trench**](https://github.com/facebook/mariana-trench) es capaz de encontrar **vulnerabilidades** escaneando el **código** de la aplicación. Esta herramienta contiene una serie de **known sources** (que indican al tool los **lugares** donde la **input** está **controlada por el usuario**), **sinks** (que indican al tool **lugares peligrosos** donde la entrada maliciosa del usuario podría causar daños) y **rules**. Estas reglas indican la **combinación** de **sources-sinks** que señalan una vulnerabilidad.

Con este conocimiento, **mariana-trench revisará el código y encontrará posibles vulnerabilidades en él**.

### Secrets leaked

Una aplicación puede contener secrets (API keys, contraseñas, URLs ocultas, subdominios...) en su interior que podrías descubrir. Puedes usar una herramienta como [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Eludir la autenticación biométrica


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Otras funciones interesantes

- **Ejecución de código**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Enviar SMS**: `sendTextMessage, sendMultipartTestMessage`
- **Funciones nativas** declaradas como `native`: `public native, System.loadLibrary, System.load`
- [Lee esto para aprender **how to reverse native functions**](reversing-native-libraries.md)
- Ejecución de código nativo en memoria vía JNI (shellcode descargado → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Otros trucos**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Análisis Dinámico

> Primero, necesitas un entorno donde puedas instalar la aplicación y todo el entorno (Burp CA cert, Drozer y Frida principalmente). Por lo tanto, se recomienda encarecidamente un dispositivo rooteado (emulado o no).

### Análisis dinámico online

Puedes crear una **cuenta gratuita** en: [https://appetize.io/](https://appetize.io). Esta plataforma te permite **subir** y **ejecutar** APKs, por lo que es útil para ver cómo se comporta un apk.

Incluso puedes **ver los logs de tu aplicación** en la web y conectarte a través de **adb**.

![](<../../images/image (831).png>)

Gracias a la conexión ADB puedes usar **Drozer** y **Frida** dentro de los emuladores.

### Análisis dinámico local

#### Usando un emulador

- [**Android Studio**](https://developer.android.com/studio) (Puedes crear dispositivos **x86** y **arm**, y según [**esta** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**las últimas versiones x86** soportan **librerías ARM** sin necesitar un emulador ARM lento).
- Aprende a configurarlo en esta página:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Versión gratuita:** Personal Edition, necesitas crear una cuenta. _Se recomienda **descargar** la versión **CON** _**VirtualBox** para evitar errores potenciales._)
- [**Nox**](https://es.bignox.com) (Gratis, pero no soporta Frida ni Drozer).

> [!TIP]
> Al crear un nuevo emulador en cualquier plataforma recuerda que cuanto mayor sea la pantalla, más lento funcionará el emulador. Así que selecciona pantallas pequeñas si es posible.

Para **instalar google services** (como AppStore) en Genymotion necesitas hacer clic en el botón marcado en rojo de la imagen siguiente:

![](<../../images/image (277).png>)

Además, fíjate que en la **configuración de la VM Android en Genymotion** puedes seleccionar **Bridge Network mode** (esto será útil si te conectarás a la VM Android desde otra VM con las herramientas).

#### Usar un dispositivo físico

Necesitas activar las opciones de **depuración** y sería conveniente si puedes **rootear** el dispositivo:

1. **Ajustes**.
2. (Desde Android 8.0) Selecciona **Sistema**.
3. Selecciona **Acerca del teléfono**.
4. Pulsa **Número de compilación** 7 veces.
5. Vuelve atrás y encontrarás las **Opciones de desarrollador**.

> Una vez instalada la aplicación, lo primero que debes hacer es probarla e investigar qué hace, cómo funciona y familiarizarte con ella.\
> Sugiero **realizar este análisis dinámico inicial usando MobSF dynamic analysis + pidcat**, así podremos **aprender cómo funciona la aplicación** mientras MobSF **captura** muchos **datos** **interesantes** que podrás revisar más tarde.

Magisk/Zygisk quick notes (recommended on Pixel devices)
- Parchea boot.img con la app Magisk y flashea vía fastboot para obtener systemless root
- Activa Zygisk + DenyList para ocultar root; considera LSPosed/Shamiko cuando se requiera ocultación más fuerte
- Conserva el boot.img original para recuperar tras actualizaciones OTA; re-parchea después de cada OTA
- Para duplicar pantalla, usa scrcpy en el host



### Filtración de datos no intencionada

**Logging**

Los desarrolladores deben tener cuidado de exponer información de **debugging** públicamente, ya que puede provocar sensitive data leaks. Se recomiendan las herramientas [**pidcat**](https://github.com/JakeWharton/pidcat) y `adb logcat` para monitorizar los logs de la aplicación e identificar y proteger información sensible. **Pidcat** se prefiere por su facilidad de uso y legibilidad.

> [!WARNING]
> Ten en cuenta que desde **Android 4.0 en adelante**, **las aplicaciones solo pueden acceder a sus propios logs**. Por lo tanto, las aplicaciones no pueden acceder a los logs de otras apps.\
> De todas formas, se recomienda **no loggear información sensible**.

**Copy/Paste Buffer Caching**

El framework basado en clipboard de Android habilita la funcionalidad de copiar-pegar en apps, pero plantea un riesgo ya que **otras aplicaciones** pueden **acceder** al clipboard, exponiendo potencialmente datos sensibles. Es crucial desactivar las funciones de copy/paste para secciones sensibles de una aplicación, como datos de tarjeta de crédito, para prevenir leaks.

**Crash Logs**

Si una aplicación **crashea** y **guarda logs**, estos logs pueden ayudar a atacantes, particularmente cuando la aplicación no puede ser reverse-engineered. Para mitigar este riesgo, evita loggear en crashes, y si los logs deben transmitirse por la red, asegúrate de enviarlos vía un canal SSL por seguridad.

Como pentester, **intenta echar un vistazo a estos logs**.

**Analytics Data Sent To 3rd Parties**

Las aplicaciones suelen integrar servicios como Google Adsense, que pueden inadvertidamente leak datos sensibles debido a una implementación incorrecta por parte de los desarrolladores. Para identificar posibles leaks, es recomendable interceptar el tráfico de la aplicación y comprobar si se envía información sensible a servicios de terceros.

### SQLite DBs

La mayoría de las aplicaciones usarán **bases de datos SQLite internas** para guardar información. Durante el pentest echa un **vistazo** a las **bases de datos** creadas, los nombres de **tablas** y **columnas** y todos los **datos** guardados porque podrías encontrar **información sensible** (lo que sería una vulnerabilidad).\
Las bases de datos deberían estar ubicadas en `/data/data/the.package.name/databases` como `/data/data/com.mwr.example.sieve/databases`

Si la base de datos guarda información confidencial y está **encriptada** pero puedes **encontrar** la **contraseña** dentro de la aplicación, sigue siendo una **vulnerabilidad**.

Enumera las tablas usando `.tables` y enumera las columnas de las tablas haciendo `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** te permite **asumir el rol de una aplicación Android** e interactuar con otras apps. Puede hacer **todo lo que una aplicación instalada puede hacer**, como utilizar el mecanismo de Inter-Process Communication (IPC) de Android e interactuar con el sistema operativo subyacente.\
Drozer es una herramienta útil para **explotar exported activities, exported services y Content Providers** como aprenderás en las siguientes secciones.

### Explotación de Activities exportadas

[**Lee esto si quieres repasar qué es una Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
También recuerda que el código de una activity comienza en el método **`onCreate`**.

**Bypass de autorización**

Cuando una Activity está exportada puedes invocar su pantalla desde una aplicación externa. Por lo tanto, si una activity con **información sensible** está **exportada** podrías **eludir** los mecanismos de **autenticación** para acceder a ella.

[**Aprende cómo explotar activities exportadas con Drozer.**](drozer-tutorial/index.html#activities)

También puedes iniciar una activity exportada desde adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> Ten en cuenta que un authorisation bypass no siempre es una vulnerabilidad; depende de cómo funcione el bypass y qué información se exponga.

**Sensitive information leakage**

Activities can also return results. If you manage to find an exported and unprotected activity calling the **`setResult`** method and **returning sensitive information**, there is a sensitive information leakage.

#### Tapjacking

If tapjacking isn't prevented, you could abuse the exported activity to make the **user perform unexpected actions**. For more info about [**qué es Tapjacking — sigue el enlace**](#tapjacking).

### Explotando Content Providers - Accediendo y manipulando información sensible

[**Lee esto si quieres repasar qué es un Content Provider.**](android-applications-basics.md#content-provider)\
Los Content providers se usan básicamente para **compartir datos**. Si una app tiene content providers disponibles, quizá puedas **extraer datos sensibles** de ellos. También es interesante probar posibles **SQL injections** y **Path Traversals** ya que podrían ser vulnerables.

[**Aprende cómo explotar Content Providers con Drozer.**](drozer-tutorial/index.html#content-providers)

### **Explotando Services**

[**Lee esto si quieres repasar qué es un Service.**](android-applications-basics.md#services)\
Recuerda que las acciones de un Service empiezan en el método `onStartCommand`.

Un Service es básicamente algo que **puede recibir datos**, **procesarlos** y **devolver** (o no) una respuesta. Por tanto, si una aplicación exporta algunos services deberías **revisar** el **código** para entender qué hace y **probarlo** **dinámicamente** para extraer información confidencial, eludir medidas de autenticación...\
[**Aprende cómo explotar Services con Drozer.**](drozer-tutorial/index.html#services)

### **Explotando Broadcast Receivers**

[**Lee esto si quieres repasar qué es un Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Recuerda que las acciones de un Broadcast Receiver comienzan en el método `onReceive`.

Un Broadcast Receiver esperará un tipo de mensaje. Dependiendo de cómo el receiver maneje el mensaje, podría ser vulnerable.\
[**Aprende cómo explotar Broadcast Receivers con Drozer.**](#exploiting-broadcast-receivers)

### **Explotando Schemes / Deep links**

Puedes buscar deep links manualmente, usando herramientas como MobSF o scripts como [este](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Puedes **abrir** un **scheme** declarado usando **adb** o un **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Ten en cuenta que puedes **omitir el nombre del paquete** y el móvil llamará automáticamente a la app que debería abrir ese enlace._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Código ejecutado**

Para encontrar el **código que se ejecutará en la App**, ve a la activity llamada por el deeplink y busca la función **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Información sensible**

Cada vez que encuentres un deep link comprueba que **no esté recibiendo datos sensibles (como contraseñas) vía parámetros URL**, porque cualquier otra aplicación podría **suplantar el deep link y robar esos datos!**

**Parámetros en la ruta**

También **debes comprobar si algún deep link está usando un parámetro dentro de la ruta** de la URL como: `https://api.example.com/v1/users/{username}` , en ese caso puedes forzar un path traversal accediendo a algo como: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Ten en cuenta que si encuentras los endpoints correctos dentro de la aplicación podrías provocar un **Open Redirect** (si parte de la ruta se usa como nombre de dominio), **account takeover** (si puedes modificar los detalles de usuarios sin token CSRF y el vuln endpoint usó el método correcto) y cualquier otra vuln. More [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Inspección de la capa de transporte y fallos de verificación

- **Los certificados no siempre son inspeccionados correctamente** por las aplicaciones Android. Es común que estas aplicaciones ignoren advertencias y acepten certificados autofirmados o, en algunos casos, vuelvan a usar conexiones HTTP.
- **Las negociaciones durante el handshake SSL/TLS a veces son débiles**, empleando suites de cifrado inseguras. Esta vulnerabilidad hace la conexión susceptible a ataques man-in-the-middle (MITM), permitiendo a los atacantes descifrar los datos.
- **La filtración de información privada** es un riesgo cuando las aplicaciones se autentican usando canales seguros pero luego se comunican por canales no seguros para otras transacciones. Este enfoque no protege datos sensibles, como cookies de sesión o detalles de usuario, de la intercepción por actores maliciosos.

#### Verificación de Certificados

Nos centraremos en la **verificación de certificados**. La integridad del certificado del servidor debe verificarse para mejorar la seguridad. Esto es crucial porque configuraciones TLS inseguras y la transmisión de datos sensibles por canales no cifrados pueden suponer riesgos importantes. Para pasos detallados sobre cómo verificar certificados de servidor y abordar vulnerabilidades, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) ofrece una guía completa.

#### SSL Pinning

SSL Pinning es una medida de seguridad donde la aplicación verifica el certificado del servidor contra una copia conocida almacenada dentro de la propia aplicación. Este método es esencial para prevenir ataques MITM. Se recomienda encarecidamente implementar SSL Pinning en aplicaciones que manejan información sensible.

#### Inspección de tráfico

Para inspeccionar el tráfico HTTP, es necesario **instalar el certificado de la herramienta proxy** (e.g., Burp). Sin instalar este certificado, el tráfico cifrado podría no ser visible a través del proxy. Para una guía sobre cómo instalar un certificado CA personalizado, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Las aplicaciones dirigidas a **API Level 24 and above** requieren modificaciones en el Network Security Config para aceptar el certificado CA del proxy. Este paso es crítico para inspeccionar tráfico cifrado. Para instrucciones sobre cómo modificar el Network Security Config, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

Si se está usando **Flutter** necesitas seguir las instrucciones en [**this page**](flutter.md). Esto se debe a que, simplemente añadir el certificado al almacén no funcionará, ya que Flutter tiene su propia lista de CAs válidas.

#### Detección estática de SSL/TLS pinning

Antes de intentar bypasses en tiempo de ejecución, mapea rápidamente dónde se aplica el pinning en el APK. El descubrimiento estático te ayuda a planear hooks/patches y a centrarte en las rutas de código correctas.

Tool: SSLPinDetect
- Open-source static-analysis utility that decompiles the APK to Smali (via apktool) and scans for curated regex patterns of SSL/TLS pinning implementations.
- Reports exact file path, line number, and a code snippet for each match.
- Covers common frameworks and custom code paths: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

Instalación
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Uso
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Ejemplo de reglas de patrones (JSON)
Usa o amplía signatures para detectar estilos de pinning propietarios/personalizados. Puedes cargar tu propio JSON y escanear a gran escala.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notas y consejos
- Escaneo rápido en aplicaciones grandes mediante multi-threading y memory-mapped I/O; regex precompilado reduce overhead/false positives.
- Colección de patrones: https://github.com/aancw/smali-sslpin-patterns
- Objetivos típicos de detección para priorizar a continuación:
  - OkHttp: uso de CertificatePinner, setCertificatePinner, referencias a los paquetes okhttp3/okhttp
  - Custom TrustManagers: javax.net.ssl.X509TrustManager, overrides de checkServerTrusted
  - Custom SSL contexts: SSLContext.getInstance + SSLContext.init con managers personalizados
  - Pins declarativos en res/xml network security config y referencias en el manifest
- Usa las ubicaciones coincidentes para planear Frida hooks, parches estáticos o revisiones de configuración antes de las pruebas dinámicas.



#### Evadiendo SSL Pinning

Cuando SSL Pinning está implementado, es necesario eludirlo para inspeccionar el tráfico HTTPS. Hay varios métodos disponibles para este propósito:

- Modificar automáticamente el **apk** para **eludir** SSLPinning con [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). La principal ventaja de esta opción es que no necesitarás root para eludir SSL Pinning, pero tendrás que eliminar la aplicación e instalar la nueva, y esto no siempre funcionará.
- Puedes usar **Frida** (discutido más abajo) para eludir esta protección. Aquí tienes una guía para usar Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- También puedes intentar **eludir automáticamente SSL Pinning** usando [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- También puedes intentar **eludir automáticamente SSL Pinning** usando **MobSF dynamic analysis** (explicado más abajo)
- Si aún crees que hay tráfico que no estás capturando, puedes intentar **redirigir el tráfico a burp usando iptables**. Lee este blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Buscando vulnerabilidades web comunes

También es importante buscar vulnerabilidades web comunes dentro de la aplicación. La información detallada sobre identificación y mitigación de estas vulnerabilidades excede el alcance de este resumen, pero está ampliamente cubierta en otros recursos.

### Frida

[Frida](https://www.frida.re) es un toolkit de instrumentación dinámica para developers, reverse-engineers y security researchers.\
Puedes acceder a la aplicación en ejecución y hookear métodos en tiempo de ejecución para cambiar el comportamiento, modificar valores, extraer valores, ejecutar código distinto...\
Si quieres pentestear aplicaciones Android necesitas saber usar Frida.

- Aprende a usar Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Algunas "GUI" para acciones con Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Objection es genial para automatizar el uso de Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Puedes encontrar algunos Awesome Frida scripts aquí: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Intenta eludir mecanismos anti-debugging / anti-frida cargando Frida como se indica en [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (herramienta [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

Comprueba si la aplicación está almacenando información sensible en la memoria que no debería, como passwords o mnemonics.

Usando [**Fridump3**](https://github.com/rootbsd/fridump3) puedes volcar la memoria de la app con:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Esto volcará la memoria en la carpeta ./dump, y allí podrías usar grep con algo como:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Datos sensibles en Keystore**

En Android el Keystore es el mejor lugar para almacenar datos sensibles, sin embargo, con suficientes privilegios sigue siendo **posible acceder a él**. Como las aplicaciones tienden a almacenar aquí **datos sensibles en clear text** los pentests deberían comprobarlo como root user o alguien con acceso físico al dispositivo podría robar estos datos.

Incluso si una app almacena datos en el keystore, los datos deberían estar cifrados.

Para acceder a los datos dentro del keystore puedes usar este Frida script: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Usando el siguiente Frida script, podría ser posible **bypass fingerprint authentication** que las aplicaciones Android podrían estar realizando para **proteger ciertas áreas sensibles:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Imágenes de fondo**

Cuando pones una aplicación en segundo plano, Android guarda una **instantánea de la aplicación** para que, cuando se recupere al primer plano, empiece cargando la imagen antes que la app y parezca que la aplicación se cargó más rápido.

Sin embargo, si esta instantánea contiene **información sensible**, alguien con acceso a la instantánea podría **robar esa información** (ten en cuenta que necesitas root para acceder a ella).

Las instantáneas suelen almacenarse en: **`/data/system_ce/0/snapshots`**

Android proporciona una forma de **evitar la captura de capturas de pantalla estableciendo el parámetro de layout FLAG_SECURE**. Al usar este flag, el contenido de la ventana se trata como seguro, impidiendo que aparezca en capturas de pantalla o que se muestre en pantallas no seguras.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Analizador de Aplicaciones Android**

Esta herramienta puede ayudarte a gestionar distintas herramientas durante el análisis dinámico: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Los desarrolladores a menudo crean componentes proxy como activities, services y broadcast receivers que manejan estos Intents y los pasan a métodos como `startActivity(...)` o `sendBroadcast(...)`, lo que puede ser arriesgado.

El peligro radica en permitir que atacantes activen componentes de la app no exportados o accedan a content providers sensibles al redirigir maliciosamente estos Intents. Un ejemplo notable es el componente `WebView` que convierte URLs en objetos `Intent` vía `Intent.parseUri(...)` y luego los ejecuta, potencialmente conduciendo a inyecciones maliciosas de Intent.

### Essential Takeaways

- **Intent Injection** es similar al Open Redirect de la web.
- Los exploits implican pasar objetos `Intent` como extras, que pueden redirigirse para ejecutar operaciones inseguras.
- Puede exponer componentes no exportados y content providers a atacantes.
- La conversión de URLs a `Intent` de `WebView` puede facilitar acciones no deseadas.

### Android Client Side Injections and others

Probablemente conozcas este tipo de vulnerabilidades por la Web. Debes tener especial cuidado con estas vulnerabilidades en una aplicación Android:

- **SQL Injection:** Cuando manejes consultas dinámicas o Content-Providers, asegúrate de usar consultas parametrizadas.
- **JavaScript Injection (XSS):** Verifica que el soporte de JavaScript y de Plugin esté deshabilitado para cualquier WebView (deshabilitado por defecto). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** En WebViews debería deshabilitarse el acceso al sistema de archivos (habilitado por defecto) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: En varios casos cuando la aplicación Android termina la sesión la cookie no se revoca o incluso puede guardarse en disco
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Análisis estático**

![](<../../images/image (866).png>)

**Evaluación de vulnerabilidades de la aplicación** usando una interfaz web amigable. También puedes realizar análisis dinámico (pero necesitas preparar el entorno).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Assisted Dynamic analysis with MobSF

**MobSF** también puede ser muy útil para el **análisis dinámico** en **Android**, pero en ese caso necesitará instalar MobSF y **genymotion** en su host (una VM o Docker no funcionarán). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
El **analizador dinámico de MobSF** puede:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). Todo esto se hace automáticamente excepto las capturas de pantalla: necesitas pulsar cuando quieras una captura o pulsar "**Exported Activity Tester**" para obtener capturas de todas las actividades exportadas.
- Capturar **tráfico HTTPS**
- Usar **Frida** para obtener **información en tiempo de ejecución**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Frida scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: Imprimirá todas las clases cargadas
- **Capture Strings**: Imprimirá todas las cadenas capturadas mientras usas la aplicación (muy ruidoso)
- **Capture String Comparisons**: Puede ser muy útil. Mostrará **las 2 cadenas que se están comparando** y si el resultado fue True o False.
- **Enumerate Class Methods**: Introduce el nombre de la clase (como "java.io.File") e imprimirá todos los métodos de la clase.
- **Search Class Pattern**: Buscar clases por patrón
- **Trace Class Methods**: **Trace** una **clase completa** (ver entradas y salidas de todos los métodos de la clase). Recuerda que por defecto MobSF traza varios métodos interesantes del Android Api.

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf also brings you a shell with some **adb** commands, **MobSF commands**, and common **shell** **commands** at the bottom of the dynamic analysis page. Some interesting commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**Herramientas HTTP**

Cuando se captura tráfico HTTP puedes ver una vista fea del tráfico capturado en el botón "**HTTP(S) Traffic**" inferior o una vista más agradable en el botón verde "**Start HTTPTools**". Desde la segunda opción, puedes **send** las **captured requests** a **proxies** como Burp u Owasp ZAP.\
Para hacerlo, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> pulsa "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Una vez que termines el análisis dinámico con MobSF puedes pulsar "**Start Web API Fuzzer**" para **fuzz http requests** y buscar vulnerabilidades.

> [!TIP]
> After performing a dynamic analysis with MobSF the proxy settings me be misconfigured and you won't be able to fix them from the GUI. You can fix the proxy settings by doing:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

Puedes obtener la herramienta desde [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Esta herramienta usará algunos **Hooks** para informarte **qué está pasando en la aplicación** mientras realizas un **análisis dinámico**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Esta es una **herramienta excelente para realizar static analysis con una GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Esta herramienta está diseñada para buscar varias **security related Android application vulnerabilities**, ya sea en **source code** o en **packaged APKs**. La herramienta también es **capable of creating a "Proof-of-Concept" deployable APK** y **ADB commands**, para explotar algunas de las vulnerabilidades encontradas (Exposed activities, intents, tapjacking...). Como con Drozer, no es necesario rootear el dispositivo de prueba.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Muestra todos los archivos extraídos para referencia rápida
- Descompila automáticamente archivos APK a formato Java y Smali
- Analiza AndroidManifest.xml en busca de vulnerabilidades y comportamientos comunes
- Análisis estático del código fuente en busca de vulnerabilidades y comportamientos comunes
- Información del dispositivo
- y más
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER es una aplicación de línea de comandos que puede usarse en Windows, MacOS X y Linux, que analiza _.apk_ files en busca de vulnerabilidades. Hace esto descomprimiendo APKs y aplicando una serie de reglas para detectar esas vulnerabilidades.

Todas las reglas están centralizadas en un archivo `rules.json`, y cada empresa o tester puede crear sus propias reglas para analizar lo que necesiten.

Descarga los binarios más recientes desde la [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn es una herramienta **multiplataforma** que ayuda a desarrolladores, bugbounty hunters y ethical hackers a realizar [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) en aplicaciones móviles.

El concepto es que arrastres y sueltes el archivo de tu aplicación móvil (un .apk o .ipa) en la aplicación StaCoAn y esta generará un informe visual y portable para ti. Puedes ajustar la configuración y las wordlists para obtener una experiencia personalizada.

Descargar [última versión](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework es un sistema de análisis de vulnerabilidades para Android que ayuda a desarrolladores o hackers a encontrar posibles vulnerabilidades de seguridad en aplicaciones Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** es una herramienta cuyo objetivo principal es detectar y avisar al usuario sobre posibles comportamientos maliciosos desarrollados por una aplicación Android.

La detección se realiza mediante **static analysis** del bytecode Dalvik de la aplicación, representado como **Smali**, con la biblioteca [`androguard`](https://github.com/androguard/androguard).

Esta herramienta busca **comportamiento común de aplicaciones "malas"** como: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** es un Framework de Ingeniería Inversa y Análisis de Aplicaciones Móviles. Es una herramienta que reúne las herramientas comúnmente usadas para reverse engineering y análisis de aplicaciones móviles, para asistir en las pruebas de aplicaciones móviles frente a las amenazas de seguridad móvil de OWASP. Su objetivo es facilitar esta tarea y hacerla más accesible para desarrolladores de aplicaciones móviles y profesionales de seguridad.

Es capaz de:

- Extraer código Java y Smali usando distintas herramientas
- Analizar APKs usando: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Extraer información privada del APK usando regexps.
- Analizar el Manifest.
- Analizar dominios encontrados usando: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Desofuscar APK vía [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Útil para detectar malware: [https://koodous.com/](https://koodous.com/)

## Ofuscación/Desofuscación de código

Ten en cuenta que, dependiendo del servicio y la configuración que uses para ofuscar el código, los secretos pueden o no quedar ofuscados.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

Desde [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** es una herramienta de línea de comandos de código abierto que reduce, optimiza y ofusca código Java. Es capaz de optimizar bytecode y de detectar y eliminar instrucciones no usadas. ProGuard es software libre y se distribuye bajo la GNU General Public License, versión 2.

ProGuard se distribuye como parte del Android SDK y se ejecuta cuando se construye la aplicación en modo release.

### [DexGuard](https://www.guardsquare.com/dexguard)

Encuentra una guía paso a paso para desofuscar el apk en [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(De esa guía) La última vez que comprobamos, el modo de operación de Dexguard era:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard invierte el proceso de ofuscación realizado por herramientas de ofuscación de Android. Esto permite numerosos análisis de seguridad, incluyendo inspección de código y predicción de librerías.**

Puedes subir un APK ofuscado a su plataforma.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

Esta es una herramienta LLM para encontrar posibles vulnerabilidades de seguridad en aplicaciones android y desofuscar el código de aplicaciones android. Usa la API pública Gemini de Google.

### [Simplify](https://github.com/CalebFenton/simplify)

Es un **deobfuscador genérico para android.** Simplify **ejecuta virtualmente una app** para entender su comportamiento y luego **intenta optimizar el código** para que se comporte de forma idéntica pero sea más fácil de entender para un humano. Cada tipo de optimización es simple y genérica, por lo que no importa qué tipo específico de ofuscación se haya usado.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD te da información sobre **cómo se hizo un APK**. Identifica muchos **compilers**, **packers**, **obfuscators**, y otras cosas raras. Es [_PEiD_](https://www.aldeid.com/wiki/PEiD) para Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b es una máquina virtual de seguridad Android basada en ubuntu-mate que incluye una colección de los últimos frameworks, tutoriales y laboratorios de distintos expertos e investigadores en seguridad para ingeniería inversa y análisis de malware.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Es una gran lista de recursos
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
