# Android Applications Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android Applications Basics

Preporučuje se da prvo pročitate ovu stranicu kako biste se upoznali sa **najvažnijim delovima vezanim za Android sigurnost i najozbiljnijim komponentama u Android aplikaciji**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Ovo je glavni alat koji vam treba za povezivanje sa Android uređajem (emuliranim ili fizičkim).\
**ADB** omogućava kontrolu uređaja ili preko **USB** ili preko **mreže** sa računara. Ovaj alat omogućava **kopiranje** fajlova u oba smera, **instalaciju** i **deinstalaciju** aplikacija, **izvršavanje** shell komandi, **pravljenje backup-a** podataka, **čitanje** logova, između ostalih funkcija.

Pogledajte sledeću listu [**ADB Commands**](adb-commands.md) da naučite kako da koristite adb.

## Smali

Ponekad je korisno **izmeniti kod aplikacije** kako biste pristupili **skrivenim informacijama** (npr. veoma obfuskovanim lozinkama ili flagovima). U tom slučaju može biti korisno dekompilovati APK, izmeniti kod i rekompajlirati ga.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Ovo može biti veoma korisno kao **alternativa za nekoliko testova tokom dinamičke analize** koji će biti predstavljeni. Zato **uvek imajte ovu mogućnost na umu**.

## Other interesting tricks

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [Android IME / InputMethodService Abuse (Malicious Keyboards)](inputmethodservice-ime-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Extract APK from device:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Spojite sve splits i base apks pomoću [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Napadi na Android Enterprise i Work Profile

{{#ref}}
android-enterprise-work-profile-bypass.md
{{#endref}}

## Studije slučaja i ranjivosti


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

{{#ref}}
abusing-android-media-pipelines-image-parsers.md
{{#endref}}

{{#ref}}
../../binary-exploitation/linux-kernel-exploitation/arm64-static-linear-map-kaslr-bypass.md
{{#endref}}

## Statička analiza

Prvo, za analizu APK-a treba **pogledati Java kod** koristeći dekompajler.\
Please, [**read here to find information about different available decompilers**](apk-decompilers.md).

### Potraga za zanimljivim informacijama

Već samim pregledom **strings** iz APK-a možete tražiti **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** i sve što deluje interesantno... tražite čak i kod za izvršavanje **backdoors** ili backdoore za autentikaciju (hardcoded admin kredencijali u aplikaciji).

**Firebase**

Obratite posebnu pažnju na **Firebase** URLs i proverite da li je loše konfigurisan. [More information about whats is FIrebase and how to exploit it here.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Osnovno razumevanje aplikacije - Manifest.xml, strings.xml

**Pregled aplikacionih fajlova _Manifest.xml_ i **_strings.xml_** može otkriti potencijalne bezbednosne ranjivosti**. Ovi fajlovi su dostupni pomoću dekompajlera ili preimenovanjem APK fajla u .zip i raspakivanjem.

**Ranjivosti** identifikovane iz **Manifest.xml** uključuju:

- **Debuggable Applications**: Aplikacije označene kao debuggable (`debuggable="true"`) u _Manifest.xml_ predstavljaju rizik jer omogućavaju konekcije koje mogu dovesti do eksploatacije. Za dodatno razumevanje kako eksploatisati debuggable aplikacije, pogledajte tutorijal o pronalaženju i eksploatisanju debuggable aplikacija na uređaju.
- **Backup Settings**: Atribut `android:allowBackup="false"` treba eksplicitno postaviti za aplikacije koje rade sa osetljivim informacijama da bi se sprečili neautorizovani backup-i podataka putem adb, posebno kada je usb debugging omogućen.
- **Network Security**: Custom network security konfiguracije (`android:networkSecurityConfig="@xml/network_security_config"`) u _res/xml/_ mogu specificirati detalje poput certificate pin-ova i podešavanja HTTP saobraćaja. Primer je dozvoljavanje HTTP saobraćaja za određene domene.
- **Exported Activities and Services**: Identifikovanje exported activities i services u manifestu može ukazati na komponente koje se mogu zloupotrebiti. Dalja analiza tokom dinamičkog testiranja može otkriti kako eksploatisati ove komponente.
- **Content Providers and FileProviders**: Izloženi content provider-i mogu dozvoliti neautorizovan pristup ili modifikaciju podataka. Konfiguracija FileProvider-a takođe zahteva pažljivu proveru.
- **Broadcast Receivers and URL Schemes**: Ove komponente mogu biti iskorišćene za eksploataciju, sa posebnom pažnjom na način na koji su URL scheme-ovi implementirani za moguće input ranjivosti.
- **SDK Versions**: Atributi `minSdkVersion`, `targetSDKVersion`, i `maxSdkVersion` ukazuju na podržane Android verzije, naglašavajući važnost ne podržavanja zastarelih, ranjivih Android verzija iz bezbednosnih razloga.

Iz **strings.xml** fajla mogu se otkriti osetljive informacije kao što su API keys, custom schemas i druge developerske napomene, što podvlači potrebu za pažljivim pregledom ovih resursa.

### Tapjacking

**Tapjacking** is an attack where a **malicious** **application** is launched and **positions itself on top of a victim application**. Once it visibly obscures the victim app, its user interface is designed in such a way as to trick the user to interact with it, while it is passing the interaction along to the victim app.\
In effect, it is **blinding the user from knowing they are actually performing actions on the victim app**.

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

An **activity** with the **`launchMode`** set to **`singleTask` without any `taskAffinity`** defined is vulnerable to task Hijacking. This means, that an **application** can be installed and if launched before the real application it could **hijack the task of the real application** (so the user will be interacting with the **malicious application thinking he is using the real one**).

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Nesigurno skladištenje podataka

**Interna memorija**

U Androidu, fajlovi **smešteni** u **internoj** memoriji su **dizajnirani** da budu **pristupačni** isključivo aplikaciji koja ih je **kreirala**. Ova mera bezbednosti je **sprovodena** od strane Android operativnog sistema i generalno zadovoljava bezbednosne potrebe većine aplikacija. Međutim, developeri ponekad koriste režime kao što su `MODE_WORLD_READABLE` i `MODE_WORLD_WRITABLE` da **dozvole** deljenje fajlova između različitih aplikacija. Ipak, ovi režimi **ne ograničavaju pristup** tim fajlovima drugim aplikacijama, uključujući potencijalno maliciozne.

1. **Statička analiza:**
- **Proverite** da li se upotreba `MODE_WORLD_READABLE` i `MODE_WORLD_WRITABLE` **pažljivo preispituje**. Ovi režimi **mogu potencijalno izložiti** fajlove **neželjenom ili neautorizovanom pristupu**.
2. **Dinamička analiza:**
- **Verifikujte** permisije postavljene na fajlovima koje aplikacija kreira. Konkretno, **proverite** da li su neki fajlovi **postavljeni kao readable ili writable worldwide**. Ovo predstavlja značajan bezbednosni rizik, jer bi omogućilo **bilo kojoj aplikaciji** instaliranoj na uređaju, bez obzira na poreklo ili nameru, da **pročita ili izmeni** te fajlove.

**Eksterno skladište**

Pri radu sa fajlovima na **eksternom skladištu**, kao što su SD kartice, treba preduzeti određene mere opreza:

1. **Pristupačnost**:
- Fajlovi na eksternom skladištu su **globalno readable i writable**. To znači da bilo koja aplikacija ili korisnik može pristupiti tim fajlovima.
2. **Bezbednosni problemi**:
- S obzirom na jednostavnost pristupa, savetuje se **ne čuvati osetljive informacije** na eksternom skladištu.
- Eksterno skladište može biti uklonjeno ili mu može pristupiti bilo koja aplikacija, što ga čini manje sigurnim.
3. **Rukovanje podacima sa eksternog skladišta**:
- Uvek **izvršite validaciju ulaza** podataka dobijenih sa eksternog skladišta. Ovo je ključno jer podaci dolaze iz nepoverljivog izvora.
- Snažno se ne preporučuje skladištenje izvršnih fajlova ili class fajlova na eksternom skladištu za dinamičko učitavanje.
- Ako vaša aplikacija mora da preuzme izvršne fajlove sa eksternog skladišta, osigurajte da su ti fajlovi **potpisani i kriptografski verifikovani** pre dinamičkog učitavanja. Ovaj korak je vitalan za održavanje bezbednosnog integriteta aplikacije.

Eksterno skladište može se **pristupiti** u `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> Starting with Android 4.4 (**API 17**), the SD card has a directory structure which **limits access from an app to the directory which is specifically for that app**. This prevents malicious application from gaining read or write access to another app's files.

**Osetljivi podaci sačuvani u plain-textu**

- **Shared preferences**: Android omogućava svakoj aplikaciji da lako sačuva xml fajlove u putanji `/data/data/<packagename>/shared_prefs/` i ponekad je moguće pronaći osetljive informacije u plain-textu u tom direktorijumu.
- **Databases**: Android omogućava svakoj aplikaciji da lako sačuva sqlite baze podataka u putanji `/data/data/<packagename>/databases/` i ponekad je moguće pronaći osetljive informacije u plain-textu u tom direktorijumu.

### Broken TLS

**Accept All Certificates**

Iz nekog razloga ponekad developeri prihvataju sve certificate čak i ako, na primer, hostname ne odgovara, sa linijama koda kao u sledećem primeru:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Dobar način da se ovo testira je pokušati da presretnete saobraćaj koristeći neki proxy kao Burp bez autorizovanja Burp CA unutar uređaja. Takođe, možete generisati u Burp sertifikat za drugo ime hosta i koristiti ga.

### Neispravna kriptografija

**Loši procesi upravljanja ključevima**

Neki developeri čuvaju osetljive podatke u lokalnom skladištu i enkriptuju ih ključem hardkodovanim/predvidivim u kodu. To se ne bi smelo raditi jer neko reverzno inženjerstvo može omogućiti napadačima da izvuku poverljive informacije.

**Korišćenje nesigurnih i/ili zastarelih algoritama**

Developeri ne bi trebalo da koriste **deprecated algorithms** za izvršavanje autorizacionih **checks**, **store** ili **send** podataka. Neki od ovih algoritama su: RC4, MD4, MD5, SHA1... Ako se **hashes** koriste za čuvanje lozinki, na primer, treba koristiti hešove otporne na brute-force sa salt-om.

### Ostale provere

- Preporučuje se da **obfuscate the APK** kako biste otežali posao reverznim inženjerima napadačima.
- Ako je aplikacija osetljiva (kao bankarske aplikacije), treba da izvrši svoje **provere da li je uređaj rooted** i postupi u skladu sa tim.
- Ako je aplikacija osetljiva (kao bankarske aplikacije), treba da proveri da li se koristi **emulator**.
- Ako je aplikacija osetljiva (kao bankarske aplikacije), treba da **proveri sopstveni integritet pre izvršavanja** da bi utvrdila da li je bila izmenjena.
- Koristite [**APKiD**](https://github.com/rednaga/APKiD) da proverite koji compiler/packer/obfuscator je korišćen za izgradnju APK-a

### React Native Application

Pročitajte sledeću stranicu da naučite kako lako pristupiti javascript kodu React aplikacija:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Pročitajte sledeću stranicu da naučite kako lako pristupiti C# kodu Xamarin aplikacija:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

Prema ovom [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/), superpacked je Meta algoritam koji kompresuje sadržaj aplikacije u jednu datoteku. Blog govori o mogućnosti kreiranja aplikacije koja dekompresuje ovakve aplikacije... i o bržem načinu koji podrazumeva **pokretanje aplikacije i prikupljanje dekompresovanih fajlova iz filesystema.**

### Automated Static Code Analysis

Alat [**mariana-trench**](https://github.com/facebook/mariana-trench) je sposoban da pronađe ranjivosti skeniranjem koda aplikacije. Ovaj alat sadrži seriju **known sources** (koji označavaju alatima **mesta** gde je **input** **kontrolisan od strane korisnika**), **sinks** (koji označavaju **opasna** **mesta** gde maliciozni korisnički input može prouzrokovati štetu) i **rules**. Ove rules pokazuju **kombinaciju** **sources-sinks** koja ukazuje na ranjivost.

Sa ovim znanjem, **mariana-trench će pregledati kod i pronaći moguće ranjivosti u njemu**.

### Secrets leaked

Aplikacija može sadržati secrets (API keys, passwords, hidden urls, subdomains...) unutar sebe koje možete otkriti. Možete koristiti alat kao što je [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Ostale zanimljive funkcije

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)
- In-memory native code execution via JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dinamička analiza

> Prvo, potrebno vam je okruženje u kojem možete instalirati aplikaciju i sve potrebe (Burp CA cert, Drozer i Frida pre svega). Stoga je veoma preporučljivo koristiti root-ovan uređaj (emuliran ili ne).

### Online dinamička analiza

Možete napraviti **besplatan nalog** na: [https://appetize.io/](https://appetize.io). Ova platforma vam omogućava da **upload** i **execute** APK-ove, pa je korisna da vidite kako se APK ponaša.

Možete čak **videti logove svoje aplikacije** na webu i povezati se preko **adb**.

![](<../../images/image (831).png>)

Zahvaljujući ADB konekciji možete koristiti **Drozer** i **Frida** unutar emulatora.

### Lokalna dinamička analiza

#### Korišćenje emulatora

- [**Android Studio**](https://developer.android.com/studio) (Možete kreirati **x86** i **arm** uređaje, i prema [**this**](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html) najnovije **x86** verzije **podržavaju ARM biblioteke** bez potrebe za sporim ARM emulatorom).
- Naučite kako to podesiti na ovoj stranici:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Besplatna verzija:** Personal Edition, potrebno je napraviti nalog. _Preporučuje se da **download** verziju **WITH** _**VirtualBox** kako biste izbegli potencijalne greške._)
- [**Nox**](https://es.bignox.com) (Besplatan, ali ne podržava Frida ili Drozer).

> [!TIP]
> Kada kreirate novi emulator na bilo kojoj platformi, imajte na umu da što je veći ekran, to će emulator raditi sporije. Zato, po mogućstvu, izaberite manje ekrane.

Da biste **install google services** (kao AppStore) u Genymotion potrebno je da kliknete na crveno označeno dugme na sledećoj slici:

![](<../../images/image (277).png>)

Takođe, obratite pažnju da u **konfiguraciji Android VM u Genymotion-u** možete izabrati **Bridge Network mode** (ovo će biti korisno ako se povezujete na Android VM sa neke druge VM gde su alati).

#### Korišćenje fizičkog uređaja

Potrebno je aktivirati opcije za **debugging** i poželjno je da uređaj bude **root**-ovan:

1. **Settings**.
2. (FromAndroid 8.0) Izaberite **System**.
3. Izaberite **About phone**.
4. Pritisnite **Build number** 7 puta.
5. Vratite se nazad i naći ćete **Developer options**.

> Kada instalirate aplikaciju, prvo što treba da uradite je da je isprobate, istražite šta radi, kako radi i da se upoznate sa njom.\
> Predlažem da **izvršite ovu inicijalnu dinamičku analizu koristeći MobSF dynamic analysis + pidcat**, tako da možemo **naučiti kako aplikacija radi** dok MobSF **hvata** mnogo **zanimljivih** **podataka** koje možete pregledati kasnije.

Magisk/Zygisk napomene (preporučeno na Pixel uređajima)
- Patch-ujte boot.img pomoću Magisk aplikacije i flash-ujte preko fastboot-a da biste dobili systemless root
- Omogućite Zygisk + DenyList za skrivanje roota; razmotrite LSPosed/Shamiko kada je potrebno jače skrivanje
- Sačuvajte originalni boot.img da biste se oporavili nakon OTA ažuriranja; ponovo patch-ujte nakon svakog OTA
- Za mirror ekrana, koristite scrcpy na hostu

### Nenameravano curenje podataka

**Logovanje**

Developeri bi trebali biti oprezni pri izlaganju **debugging information** javno, jer to može dovesti do curenja osetljivih podataka. Preporučuju se alati [**pidcat**](https://github.com/JakeWharton/pidcat) i `adb logcat` za nadzor logova aplikacije kako biste identifikovali i zaštitili osetljive informacije. **Pidcat** je omiljen zbog jednostavnosti korišćenja i čitljivosti.

> [!WARNING]
> Imajte na umu da od **kasnijih verzija novijih od Android 4.0**, **aplikacije mogu pristupiti samo svojim sopstvenim logovima**. Dakle, aplikacije ne mogu pristupiti logovima drugih aplikacija.\
> U svakom slučaju, i dalje se preporučuje da **ne logujete osetljive informacije**.

**Copy/Paste Buffer Caching**

Android-ov sistem zasnovan na clipboard-u omogućava funkcionalnost kopiranja/lepljenja u aplikacijama, ali predstavlja rizik jer **druge aplikacije** mogu pristupiti clipboard-u, potencijalno otkrivajući osetljive podatke. Važno je onemogućiti funkcije kopiranja/lepljenja za osetljive delove aplikacije, poput podataka o kreditnim karticama, kako biste sprečili curenje podataka.

**Crash Logs**

Ako aplikacija **crash-uje** i **sačuva logove**, ti logovi mogu pomoći napadačima, naročito kada aplikacija ne može biti reverzno inženjerisana. Da biste umanjili ovaj rizik, izbegavajte logovanje prilikom padova, a ako logovi moraju biti poslati preko mreže, obezbedite da se šalju preko SSL kanala.

Kao pentester, **pogledajte ove logove**.

**Analytics Data Sent To 3rd Parties**

Aplikacije često integrišu servise kao Google Adsense, koji mogu nenamerno dovesti do curenja osetljivih podataka zbog nepravilne implementacije od strane developera. Da biste identifikovali potencijalna curenja podataka, preporučuje se da **presretnete saobraćaj aplikacije** i proverite da li se osetljive informacije šalju trećim stranama.

### SQLite DBs

Većina aplikacija koristi **internu SQLite bazu** za čuvanje informacija. Tokom pentesta pregledajte **baze podataka** koje su kreirane, imena **tabela** i **kolona** i sve sačuvane **podatke**, jer možete pronaći **osetljive informacije** (što bi predstavljalo ranjivost).\
Baze podataka bi trebale biti locirane u `/data/data/the.package.name/databases` kao npr. `/data/data/com.mwr.example.sieve/databases`

Ako baza čuva poverljive informacije i **encrypted** je, ali možete **naći** **password** unutar aplikacije, to je i dalje **vulnerability**.

Enumerišite tabele koristeći `.tables` i enumerišite kolone tabela pomoću `.schema <table_name>`

### Drozer (Eksploit aktivnosti, Content Providers i servisi)

Iz [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** vam omogućava da **preuzmete ulogu Android aplikacije** i interagujete sa drugim aplikacijama. Može raditi **bilo šta što instalirana aplikacija može raditi**, kao što je korišćenje Android-ovog mehanizma Inter-Process Communication (IPC) i interakcija sa osnovnim operativnim sistemom. \
Drozer je koristan alat za **eksploatisanje exported activities, exported services i Content Providers** kao što ćete naučiti u narednim sekcijama.

### Eksploatisanje exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Takođe zapamtite da kod Activity-ja počinje u metodi **`onCreate`**.

**Zaobilaženje autorizacije**

Kada je Activity eksportovan, možete pozvati njegov ekran iz eksterne aplikacije. Dakle, ako je aktivnost sa **osetljivim informacijama** **exported**, mogli biste **bypass** mehanizme **authentication** da biste joj pristupili.

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

Takođe možete pokrenuti exported activity preko adb:

- PackageName је com.example.demo
- Exported ActivityName је com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> Imajte na umu da authorisation bypass nije uvek ranjivost; zavisi kako bypass funkcioniše i koje informacije su izložene.

**Curanje osetljivih informacija**

**Activities can also return results**. If you manage to find an exported and unprotected activity calling the **`setResult`** method and **returning sensitive information**, there is a sensitive information leakage.

#### Tapjacking

If tapjacking isn't prevented, you could abuse the exported activity to make the **user perform unexpected actions**. For more info about [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers are basically used to **share data**. If an app has available content providers you may be able to **extract sensitive** data from them. It also interesting to test possible **SQL injections** and **Path Traversals** as they could be vulnerable.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Remember that a the actions of a Service start in the method `onStartCommand`.

As service is basically something that **can receive data**, **process** it and **returns** (or not) a response. Then, if an application is exporting some services you should **check** the **code** to understand what is it doing and **test** it **dynamically** for extracting confidential info, bypassing authentication measures...\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Remember that a the actions of a Broadcast Receiver start in the method `onReceive`.

A broadcast receiver will be waiting for a type of message. Depending on ho the receiver handles the message it could be vulnerable.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

You can look for deep links manually, using tools like MobSF or scripts like [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
You can **open** a declared **scheme** using **adb** or a **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Имајте на уму да можете **изоставити име пакета** и мобилни уређај ће аутоматски позвати апликацију која треба да отвори ту везу._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Izvršeni kod**

Da biste pronašli **kod koji će biti izvršen u App-u**, idite na aktivnost koju poziva deeplink i potražite funkciju **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Osetljive informacije**

Kad god nađete deep link, proverite da li **ne prima osetljive podatke (npr. lozinke) putem URL parametara**, jer bilo koja druga aplikacija može **imitirati deep link i ukrasti te podatke!**

**Parametri u path-u**

Takođe morate proveriti da li neki deep link koristi parametar unutar putanje URL-a kao na primer: `https://api.example.com/v1/users/{username}` , u tom slučaju možete prouzrokovati path traversal pristupom nečemu poput: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Imajte na umu da ako pronađete odgovarajuće endpoint-e unutar aplikacije, možete izazvati **Open Redirect** (ako se deo putanje koristi kao domen), **account takeover** (ako možete izmeniti podatke korisnika bez CSRF tokena i ranjivi endpoint koristi odgovarajući metod) i bilo koju drugu vuln. Više [informacija o ovome](http://dphoeniixx.com/2020/12/13-2/).

**Još primera**

Jedan [zanimljiv bug bounty izveštaj](https://hackerone.com/reports/855618) o linkovima (_/.well-known/assetlinks.json_).

### Inspekcija transportnog sloja i greške u verifikaciji

- **Sertifikati nisu uvek ispravno proveravani** od strane Android aplikacija. Često ove aplikacije zanemare upozorenja i prihvate samopotpisane sertifikate ili, u nekim slučajevima, pređu na korišćenje HTTP konekcija.
- **Pregovori tokom SSL/TLS handshake-a ponekad su slabi**, koristeći nesigurne cipher suite-ove. Ova ranjivost čini vezu podložnom man-in-the-middle (MITM) napadima, omogućavajući napadačima da dešifruju podatke.
- **Leakage of private information** predstavlja rizik kada aplikacije autentifikuju koristeći sigurne kanale ali zatim komuniciraju preko nesigurnih kanala za druge transakcije. Ovakav pristup ne štiti osetljive podatke, kao što su session cookies ili korisnički podaci, od presretanja od strane malicioznih entiteta.

#### Verifikacija sertifikata

Usredsredićemo se na **verifikaciju sertifikata**. Integritet sertifikata servera mora biti verifikovan radi povećanja bezbednosti. Ovo je ključno jer nesigurne TLS konfiguracije i prenos osetljivih podataka preko nekriptovanih kanala mogu predstavljati značajne rizike. Za detaljne korake o verifikaciji sertifikata servera i otklanjanju ranjivosti, [**ovaj izvor**](https://manifestsecurity.com/android-application-security-part-10/) pruža obuhvatne smernice.

#### SSL Pinning

SSL Pinning je mera bezbednosti gde aplikacija verifikuje sertifikat servera naspram poznate kopije koja je smeštena unutar same aplikacije. Ova metoda je ključna za sprečavanje MITM napada. Preporučuje se implementacija SSL Pinning-a za aplikacije koje obrađuju osetljive informacije.

#### Pregled saobraćaja

Da biste pregledali HTTP traffic, neophodno je **instalirati sertifikat proxy alata** (npr. Burp). Bez instaliranja tog sertifikata, enkriptovan saobraćaj možda neće biti vidljiv preko proxy-a. Za vodič o instaliranju custom CA sertifikata, [**kliknite ovde**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Aplikacije koje ciljaju **API Level 24 and above** zahtevaju izmene u Network Security Config da bi prihvatile CA sertifikat proxy-a. Ovaj korak je ključan za pregled enkriptovanog saobraćaja. Za uputstva kako izmeniti Network Security Config, [**pogledajte ovaj tutorijal**](make-apk-accept-ca-certificate.md).

Ako se koristi **Flutter**, potrebno je pratiti uputstva na [**ovoj stranici**](flutter.md). Razlog je što samo dodavanje sertifikata u store neće funkcionisati jer Flutter ima svoj sopstveni spisak validnih CAs.

#### Statička detekcija SSL/TLS pinning

Pre nego što pokušate runtime bypass-ove, brzo mapirajte gde se pinning primenjuje u APK-u. Statičko otkrivanje pomaže da isplanirate hooks/patches i fokusirate se na prave code path-ove.

Tool: SSLPinDetect
- Open-source static-analysis utility koja dekompajlira APK u Smali (preko apktool) i skenira za kurirane regex obrasce implementacija SSL/TLS pinning-a.
- Prijavljuje tačnu putanju fajla, broj linije i code snippet za svaki match.
- Pokriva uobičajene framework-e i custom code paths: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

Instalacija
- Zahtevi: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Upotreba
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Primer pravila obrasca (JSON)
Koristite ili proširite signatures da biste detektovali proprietary/custom pinning styles. Možete učitati svoj JSON i scan at scale.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Napomene i saveti
- Brzo skeniranje velikih aplikacija pomoću multi-threading i memory-mapped I/O; pre-compiled regex smanjuje overhead i lažno pozitivne rezultate.
- Kolekcija patterna: https://github.com/aancw/smali-sslpin-patterns
- Tipični ciljevi detekcije za dalju trijažu:
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Declarative pins in res/xml network security config and manifest references
- Koristite pronađene lokacije za planiranje Frida hooks, static patches, or config reviews pre dynamic testing.



#### Zaobilaženje SSL Pinning

Kada je SSL Pinning implementiran, njegovo zaobilaženje postaje neophodno za inspekciju HTTPS saobraćaja. Za ovu svrhu dostupne su različite metode:

- Automatski **izmenite** **apk** da **zaobiđete** SSLPinning pomoću [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Najveća prednost ove opcije je da nećete trebati root da zaobiđete SSL Pinning, ali ćete morati obrisati aplikaciju i ponovo instalirati novu, i ovo neće uvek raditi.
- Možete koristiti **Frida** (opisana ispod) da zaobiđete ovu zaštitu. Ovde je vodič za korišćenje Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Takođe možete pokušati **automatski zaobići SSL Pinning** koristeći [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Takođe možete pokušati **automatski zaobići SSL Pinning** koristeći **MobSF dynamic analysis** (objašnjeno ispod)
- Ako i dalje mislite da postoji neki saobraćaj koji ne presrećete, možete pokušati da **prosledite saobraćaj do Burp-a koristeći iptables**. Pročitajte ovaj blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Potraga za uobičajenim web ranjivostima

Važno je takođe tražiti uobičajene web ranjivosti unutar aplikacije. Detaljne informacije o identifikaciji i ublažavanju ovih ranjivosti su van opsega ovog sažetka, ali su obimno pokrivene drugde.

### Frida

[Frida](https://www.frida.re) je toolkit za dinamičku instrumentaciju za developere, reverse-engineere i security istraživače.\
**Možete pristupiti pokrenutoj aplikaciji i hook-ovati metode u runtime-u da promenite ponašanje, promenite vrednosti, ekstraktujete vrednosti, pokrenete drugi kod...**\
Ako želite pentest Android aplikacije, morate znati kako da koristite Frida.

- Naučite kako da koristite Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Neki "GUI" za rad sa Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection je odličan za automatizaciju korišćenja Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Možete pronaći neke Awesome Frida skripte ovde: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Pokušajte zaobići anti-debugging / anti-frida mehanizme učitavanjem Frida na način prikazan u [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (alat [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

Proverite da li aplikacija čuva osetljive informacije u memoriji koje ne bi trebala čuvati, kao što su lozinke ili mnemonici.

Koristeći [**Fridump3**](https://github.com/rootbsd/fridump3) možete dump-ovati memoriju aplikacije sa:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Ovo će dump the memory u ./dump folder, i tamo možete koristiti grep sa nečim poput:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Osetljivi podaci u Keystore**

U Androidu Keystore je najbolje mesto za čuvanje osetljivih podataka, ali uz dovoljno privilegija i dalje je **moguće mu pristupiti**. Pošto aplikacije često ovde čuvaju **osetljive podatke u clear text**, pentests bi trebalo da to provere kao root user, jer neko sa fizičkim pristupom uređaju može da ukrade te podatke.

Čak i ako aplikacija skladišti podatke u Keystore, ti podaci bi trebalo da budu šifrovani.

Za pristup podacima unutar Keystore-a možete koristiti ovaj Frida script: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Korišćenjem sledećeg Frida skripta može biti moguće **bypass fingerprint authentication** koje Android aplikacije mogu koristiti da bi **zaštitile određene osetljive oblasti:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Pozadinske slike**

Kada stavite aplikaciju u pozadinu, Android čuva **snimak aplikacije** tako da kada se vrati u prvi plan počne da učitava sliku pre same aplikacije, pa izgleda kao da se aplikacija brže učitala.

Međutim, ako taj snimak sadrži **osetljive informacije**, neko ko ima pristup snimku bi mogao **ukrasti te informacije** (napomena: potreban je root pristup da biste mu pristupili).

Snimci se obično čuvaju na lokaciji: **`/data/system_ce/0/snapshots`**

Android nudi način da se **spreči pravljenje snimka ekrana postavljanjem FLAG_SECURE** layout parametra. Korišćenjem ovog flag-a, sadržaj prozora se tretira kao siguran, čime se sprečava njegovo pojavljivanje na snimcima ekrana ili pregledanje na nesigurnim prikazima.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Ovaj alat može pomoći pri upravljanju različitim alatima tokom dynamic analysis: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Programeri često kreiraju proxy components poput activities, services i broadcast receivers koje obrađuju ove Intents i prosleđuju ih metodama kao što su `startActivity(...)` ili `sendBroadcast(...)`, što može biti rizično.

Opasnost leži u tome što napadači mogu pokrenuti non-exported app components ili pristupiti osetljivim content providers preusmeravanjem ovih Intents. Značajan primer je `WebView` component koji konvertuje URL-ove u `Intent` objekte preko `Intent.parseUri(...)` i zatim ih izvršava, što potencijalno može dovesti do malicious Intent injections.

### Essential Takeaways

- **Intent Injection** je sličan web Open Redirect issue-u.
- Eksploati uključuju prosleđivanje `Intent` objekata kao extras, koji mogu biti preusmereni da izvrše unsafe operacije.
- Može izložiti non-exported components i content providers napadačima.
- `WebView` konverzija URL-a u `Intent` može omogućiti neželjene akcije.

### Android Client Side Injections and others

Verovatno poznajete ovaj tip vulnerabilities sa Web-a. Morate biti posebno oprezni sa ovim vulnerabilities u Android aplikaciji:

- **SQL Injection:** Kada radite sa dynamic queries ili Content-Providers, uverite se da koristite parameterized queries.
- **JavaScript Injection (XSS):** Proverite da li je podrška za JavaScript i Plugin onemogućena za sve WebViews (po default-u onemogućeno). [Više informacija ovde](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** Pristup datotečnom sistemu za WebViews bi trebao biti onemogućen (po default-u omogućeno) - `(webview.getSettings().setAllowFileAccess(false);)`. [Više informacija ovde](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: U nekoliko slučajeva, kada android aplikacija završi sesiju, cookie nije opozvan ili čak može biti sačuvan na disku
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Static analysis**

![](<../../images/image (866).png>)

**Vulnerability assessment of the application** koristeći prijatan web-based frontend. Takođe možete izvršiti dynamic analysis (ali morate pripremiti environment).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Primetite da MobSF može da analizuje **Android**(apk)**, IOS**(ipa) i **Windows**(apx) aplikacije (_Windows aplikacije moraju biti analizirane sa MobSF instaliranim na Windows hostu_).\
Takođe, ako napravite **ZIP** fajl sa source code-om neke **Android** ili **IOS** app (otiđite u root folder aplikacije, selektujte sve i kreirajte ZIPfile), moći će da ga analizira takođe.

MobSF takođe omogućava da uradite **diff/Compare** analiza i da integrišete **VirusTotal** (biće potrebno da podesite vaš API key u _MobSF/settings.py_ i omogućite ga: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). Takođe možete podesiti `VT_UPLOAD` na `False`, tada će se umesto fajla **upload-ovati** **hash**.

### Assisted Dynamic analysis with MobSF

**MobSF** može biti vrlo koristan i za **dynamic analysis** na **Android**, ali u tom slučaju ćete morati da instalirate MobSF i **genymotion** na vaš host (VM ili Docker neće raditi). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
**MobSF dynamic analyser** može:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, i drugi kreirani fajlovi). Sve ovo se radi automatski osim screenshots — morate pritisnuti kada želite screenshot ili pritisnuti "**Exported Activity Tester**" da biste dobili screenshot-ove svih exportovanih aktivnosti.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

Od android **versions > 5**, automatski će **start Frida** i postaviće globalna **proxy** podešavanja da bi **capture-ovao** saobraćaj. Biće uhvaćen samo saobraćaj testirane aplikacije.

**Frida**

Po defaultu, takođe će koristiti neke Frida Scripts da **bypass-uje SSL pinning**, **root detection** i **debugger detection** i da **monitor-uje interesting APIs**.\
MobSF takođe može da **invoke-exported activities**, uzme **screenshots** istih i **save**-uje ih za izveštaj.

Da biste **start**-ovali dynamic testing pritisnite zeleni button: "**Start Instrumentation**". Pritisnite "**Frida Live Logs**" da vidite logove koje generišu Frida scripts i "**Live API Monitor**" da vidite sve invokacije hook-ovanih metoda, prosleđene argumente i vraćene vrednosti (ovo će se pojaviti nakon pritiskanja "Start Instrumentation").\
MobSF takođe dozvoljava da učitate sopstvene **Frida scripts** (da pošaljete rezultate vaših Friday scripts u MobSF koristite funkciju `send()`). Takođe ima **nekoliko prethodno napisanih skripti** koje možete učitati (možete dodati više u `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), samo ih **selektujte**, pritisnite "**Load**" i pritisnite "**Start Instrumentation**" (moći ćete da vidite logove tih skripti u "**Frida Live Logs**").

![](<../../images/image (419).png>)

Pored toga, imate neke pomoćne Frida funkcionalnosti:

- **Enumerate Loaded Classes**: Ispisaće sve učitane klase
- **Capture Strings**: Ispisuje sve capture strings dok koristite aplikaciju (veoma nois-y)
- **Capture String Comparisons**: Može biti veoma korisno. **Prikazaće 2 stringa koja se porede** i da li je rezultat bio True ili False.
- **Enumerate Class Methods**: Unesite ime klase (npr. "java.io.File") i ispišaće sve metode te klase.
- **Search Class Pattern**: Pretražuje klase po pattern-u
- **Trace Class Methods**: **Trace-uje** celu **klasu** (vidite input-e i output-e svih metoda te klase). Zapamtite da po defaultu MobSF trace-uje nekoliko interesantnih Android Api metoda.

Kada odaberete pomoćni modul koji želite da koristite, potrebno je da pritisnete "**Start Intrumentation**" i videćete sve izlaze u "**Frida Live Logs**".

**Shell**

Mobsf takođe donosi shell sa nekim **adb** komandama, **MobSF commands**, i uobičajenim **shell** **commands** pri dnu stranice za dynamic analysis. Neke interesantne komande:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP alati**

Kada se http saobraćaj uhvati, možete videti ružan prikaz uhvaćenog saobraćaja na "**HTTP(S) Traffic**" dugmetu dole ili lepši prikaz na zelenom dugmetu "**Start HTTPTools**". Iz druge opcije možete **send** **captured requests** na **proxies** kao što su Burp ili Owasp ZAP.\
Da biste to uradili, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> pritisnite "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Kada završite dinamičku analizu sa MobSF možete pritisnuti "**Start Web API Fuzzer**" da biste **fuzz** http zahteve i tražili ranjivosti.

> [!TIP]
> Nakon izvršene dinamičke analize sa MobSF proxy podešavanja mogu biti pogrešno konfigurisana i nećete moći da ih popravite iz GUI-ja. Možete popraviti proxy podešavanja izvršavanjem:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Pomoćna dinamička analiza sa Inspeckage

Alat možete preuzeti sa [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Ovaj alat koristi neke **Hooks** da vam pokaže **what is happening in the application** dok obavljate **dynamic analysis**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Ovo je **great tool to perform static analysis with a GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Ovaj alat je dizajniran da traži nekoliko **security related Android application vulnerabilities**, bilo u **source code** ili **packaged APKs**. Alat je takođe **capable of creating a "Proof-of-Concept" deployable APK** i **ADB commands**, da bi iskoristio neke od pronađenih ranjivosti (Exposed activities, intents, tapjacking...). Kao i sa Drozer, nema potrebe da root-ujete test uređaj.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Prikazuje sve izvađene datoteke radi lakšeg pregleda
- Automatski dekompajlira APK fajlove u Java i Smali format
- Analizira AndroidManifest.xml u potrazi za uobičajenim ranjivostima i ponašanjem
- Statička analiza izvornog koda u potrazi za uobičajenim ranjivostima i ponašanjem
- Informacije o uređaju
- i još
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER je aplikacija komandne linije koja se može koristiti na Windows, MacOS X i Linux i koja analizira _.apk_ fajlove u potrazi za ranjivostima. To radi dekompresovanjem APK fajlova i primenom niza pravila kako bi otkrila te ranjivosti.

Sva pravila su sadržana u fajlu `rules.json`, i svaka kompanija ili tester može kreirati sopstvena pravila da analizira ono što im treba.

Preuzmite najnovije binarne datoteke sa [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn je **crossplatform** alat koji pomaže developerima, bugbounty hunterima i ethical hackerima pri izvođenju [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) na mobilnim aplikacijama.

Koncept je da prevučete (drag and drop) fajl vaše mobilne aplikacije (an .apk or .ipa file) na StaCoAn aplikaciju i ona će za vas generisati vizuelni i prenosivi izveštaj. Možete podesiti settings i wordlists da biste dobili prilagođeno iskustvo.

Preuzmi[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework je sistem za analizu ranjivosti za Android koji pomaže programerima ili hakerima da pronađu potencijalne bezbednosne ranjivosti u Android aplikacijama.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** je alat čiji je glavni cilj da otkrije i upozori korisnika na potencijalno maliciozno ponašanje koje razvija Android aplikacija.

Detekcija se vrši pomoću **static analysis** Dalvik bytecode-a aplikacije, predstavljenog kao **Smali**, koristeći biblioteku [`androguard`](https://github.com/androguard/androguard).

Ovaj alat traži **uobičajeno ponašanje "loših" aplikacija** kao što su: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** je okvir za reverzni inženjering i analizu mobilnih aplikacija. To je alat koji okuplja često korišćene alate za reverse engineering i analizu mobilnih aplikacija, kako bi pomogao u testiranju mobilnih aplikacija protiv OWASP mobile security pretnji. Njegov cilj je da ovu aktivnost učini jednostavnijom i pristupačnijom za developere mobilnih aplikacija i bezbednosne profesionalce.

Može da:

- Extract Java and Smali code using different tools
- Analyze APKs using: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Extract private information from the APK using regexps.
- Analyze the Manifest.
- Analyze found domains using: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Koristan za detekciju malware-a: [https://koodous.com/](https://koodous.com)

## Obfuscating/Deobfuscating code

Imajte na umu da, u zavisnosti od servisa i konfiguracije koje koristite za obfuskaciju koda, sekreti mogu ili ne moraju ostati obfuskovani.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. It is able to optimize bytecode as well as detect and remove unused instructions. ProGuard is free software and is distributed under the GNU General Public License, version 2.

ProGuard se distribuira kao deo Android SDK-a i pokreće se pri buildovanju aplikacije u release mode.

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Last time we checked, the Dexguard mode of operation was:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard poništava proces obfuskacije koji vrše Android obfuscation alati. To omogućava brojne bezbednosne analize, uključujući inspekciju koda i predviđanje biblioteka.**

Možete upload-ovati obfuskovani APK na njihovu platformu.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

Ovo je LLM alat za pronalaženje potencijalnih sigurnosnih ranjivosti u android aplikacijama i deobfuskaciju android app koda. Koristi Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

To je generic android deobfuscator. Simplify virtually executes an app to understand its behavior and then tries to optimize the code so it behaves identically but is easier for a human to understand. Each optimization type is simple and generic, so it doesn't matter what the specific type of obfuscation is used.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD gives you information about **how an APK was made**. It identifies many **compilers**, **packers**, **obfuscators**, and other weird stuff. It's [_PEiD_](https://www.aldeid.com/wiki/PEiD) for Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b je Android security virtual machine bazirana na ubuntu-mate koja uključuje kolekciju najnovijih framework-a, tutorijala i labova od različitih security geeka i istraživača za reverse engineering i malware analysis.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) To je odlična lista resursa
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
