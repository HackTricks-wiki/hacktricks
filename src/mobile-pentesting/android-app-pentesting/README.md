# Androidアプリケーション Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Androidアプリケーションの基本

このページを最初に読むことを強くおすすめします。**Androidセキュリティに関連する最も重要な部分と、Androidアプリケーション内で最も危険なコンポーネント**について知るためです：


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

これはAndroidデバイス（エミュレートされたものまたは実機）に接続するために必要な主要なツールです。\
**ADB** を使うと、コンピュータから **USB** または **Network** 経由でデバイスを制御できます。このユーティリティは、ファイルの双方向の **コピー**、アプリの **インストール** と **アンインストール**、シェルコマンドの **実行**、データの **バックアップ**、ログの **読み取り** などの機能を提供します。

adbの使い方を学ぶには、以下の [**ADB Commands**](adb-commands.md) の一覧を参照してください。

## Smali

時には、**アプリケーションのコードを変更する**ことで**隠された情報**（巧妙に難読化されたパスワードやフラグなど）にアクセスすることが有用です。その場合、apkをデコンパイルしてコードを修正し、再コンパイルすることが有効かもしれません。\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md)。これは、これから紹介する動的解析中の複数のテストに対する**代替手段として非常に有用**です。したがって、この可能性を**常に念頭に置いておいてください**。

## その他の興味深いトリック

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Play Integrity attestation spoofing (SafetyNet replacement)](play-integrity-attestation-bypass.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [Android IME / InputMethodService Abuse (Malicious Keyboards)](inputmethodservice-ime-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **APKをダウンロード**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- デバイスからAPKを抽出する:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- すべての splits と base apks を [APKEditor](https://github.com/REAndroid/APKEditor) でマージする:
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Android Enterprise と Work Profile の攻撃

{{#ref}}
android-enterprise-work-profile-bypass.md
{{#endref}}

## ケーススタディ & 脆弱性


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

{{#ref}}
abusing-android-media-pipelines-image-parsers.md
{{#endref}}

{{#ref}}
../../binary-exploitation/linux-kernel-exploitation/arm64-static-linear-map-kaslr-bypass.md
{{#endref}}

## 静的解析

まず、APK を解析するにはデコンパイラを使って**Java コードを確認する**べきです。\
[**利用可能な各種デコンパイラの情報はこちらを参照してください**](apk-decompilers.md)。

### 興味深い情報の探索

APK の **strings** を見るだけで、**passwords**、**URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep))、**api** keys、**encryption**、**bluetooth uuids**、**tokens** などや興味深いものを検索できます。コード実行の **backdoors** や認証 backdoors（アプリにハードコーディングされた管理者資格情報）も探してください。

**Firebase**

特に **firebase URLs** に注意し、設定ミスがないか確認してください。 [More information about whats is FIrebase and how to exploit it here.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### アプリケーションの基本的理解 - Manifest.xml、strings.xml

アプリケーションの _Manifest.xml_ と _strings.xml_ ファイルの**調査は潜在的なセキュリティ脆弱性を明らかにすることがあります**。これらのファイルはデコンパイラを使用するか、APK の拡張子を .zip に変更して展開することで取得できます。

**Manifest.xml** から特定される脆弱性には次のものがあります:

- **Debuggable Applications**: _Manifest.xml_ に `debuggable="true"` が設定されたアプリはリスクがあります。外部からの接続を許してしまい、悪用につながる可能性があります。デバイス上で debuggable なアプリを発見・悪用する方法についてはチュートリアルを参照してください。
- **Backup Settings**: `android:allowBackup="false"` 属性は、機密情報を扱うアプリでは明示的に設定しておくべきです。特に usb debugging が有効な場合、adb 経由での不正なデータバックアップを防ぐため重要です。
- **Network Security**: カスタムのネットワークセキュリティ設定（`android:networkSecurityConfig="@xml/network_security_config"`）は _res/xml/_ に置かれ、証明書ピンや HTTP トラフィックの許可設定などのセキュリティ詳細を指定できます。例えば特定ドメイン向けに HTTP トラフィックを許可する設定などがあります。
- **Exported Activities and Services**: マニフェスト内の exported な activities や services を特定することで、不正利用される可能性のあるコンポーネントが明らかになります。動的テスト中の追加解析でこれらをどのように悪用できるかが分かります。
- **Content Providers and FileProviders**: 公開された content provider はデータへの不正なアクセスや改ざんを許す可能性があります。FileProvider の設定も注意深く確認する必要があります。
- **Broadcast Receivers and URL Schemes**: これらのコンポーネントは悪用に使われることがあり、特に URL スキームの入力処理に注意が必要です。
- **SDK Versions**: `minSdkVersion`、`targetSDKVersion`、`maxSdkVersion` 属性はサポートする Android バージョンを示します。古い脆弱な Android バージョンをサポートし続けることの危険性を示します。

_strings.xml_ からは API keys、custom schemas、およびその他の開発者メモなどの機密情報が見つかることがあり、これらのリソースを慎重にレビューする必要があります。

### Tapjacking

Tapjacking は、悪意のあるアプリが起動され、被害者アプリの上に自身を配置する攻撃です。被害アプリを視覚的に覆い隠した後、悪意あるアプリの UI はユーザーを騙して操作させつつ、その操作を被害アプリへ透過的に渡すように設計されます。結果としてユーザーは、実際には被害アプリ上で操作を行っていることに気づかなくなります。

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

`launchMode` が `singleTask` に設定され、かつ `taskAffinity` が定義されていない **activity** は Task Hijacking の影響を受けます。これは、悪意のある **application** をインストールして本物のアプリより先に起動すると、本物のアプリのタスクを **hijack** してしまう可能性があることを意味します（ユーザーは本物のアプリを使っているつもりで悪意あるアプリとやり取りしていることになります）。

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### 不適切なデータ保存

**内部ストレージ (Internal Storage)**

Android では、内部ストレージに保存されたファイルはそれを作成したアプリのみがアクセスできるように設計されています。このセキュリティ対策は OS によって強制され、多くのアプリのセキュリティ要件には十分です。しかし、開発者が `MODE_WORLD_READABLE` や `MODE_WORLD_WRITABLE` といったモードを利用してファイルを他のアプリ間で共有することがあります。これらのモードは他のアプリ、場合によっては悪意あるアプリによるアクセスを制限しません。

1. **静的解析:**
- `MODE_WORLD_READABLE` と `MODE_WORLD_WRITABLE` の使用を慎重に確認してください。これらのモードはファイルを意図しない、または不正なアクセスに晒す可能性があります。
2. **動的解析:**
- アプリが作成するファイルの権限を検証してください。特に、ファイルが世界中で読み取りまたは書き込み可能に設定されていないかを確認します。これは重大なセキュリティリスクとなり、デバイス上のどのアプリからでもファイルを読み書きされる可能性があります。

**外部ストレージ (External Storage)**

SD カードなどの外部ストレージのファイルを扱う際の注意点:

1. **アクセス性**:
- 外部ストレージ上のファイルは一般にグローバルに読み書き可能です。つまり、任意のアプリやユーザーがアクセスできます。
2. **セキュリティ上の懸念**:
- アクセスが容易なため、外部ストレージに機密情報を保存しないことが推奨されます。
- 外部ストレージは取り外されたり、任意のアプリからアクセスされ得るため安全性が低くなります。
3. **外部ストレージからのデータ扱い**:
- 外部ストレージから取得するデータは常に入力検証を行ってください。外部ストレージ上のデータは信頼できないソースから来る可能性があるため重要です。
- 外部ストレージに executables や class ファイルを置いて動的にロードすることは強く推奨されません。
- どうしても外部ストレージから実行ファイルを取得する必要がある場合は、それらのファイルが署名され暗号的に検証されていることを確認してから動的にロードしてください。これはアプリのセキュリティ整合性を保つために不可欠です。

外部ストレージは /storage/emulated/0、/sdcard、/mnt/sdcard でアクセスできます

> [!TIP]
> Android 4.4（**API 17**）以降、SD カードはアプリごとに割り当てられたディレクトリに対するアクセスのみを制限するディレクトリ構造を持つようになりました。これにより、悪意あるアプリが別のアプリのファイルに読み書きアクセスすることを防ぎます。

### 平文で保存された機密データ

- **Shared preferences**: Android は各アプリが `/data/data/<packagename>/shared_prefs/` に簡単に xml ファイルを保存できるようにしており、そのフォルダ内に平文で機密情報が見つかることがあります。
- **Databases**: Android は各アプリが `/data/data/<packagename>/databases/` に sqlite データベースを簡単に保存できるようにしており、そのフォルダ内に平文で機密情報が見つかることがあります。

### TLS の不備

**Accept All Certificates**

なぜか開発者が、例えばホスト名が一致しない場合でも、すべての証明書を受け入れてしまうことがあります。以下のようなコード行がその例です：
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### 暗号の脆弱性

**不適切なキー管理プロセス**

一部の開発者は、機密データをローカルストレージに保存し、コード内にハードコード／予測可能なキーで暗号化しています。これは避けるべきで、リバースエンジニアリングにより攻撃者が機密情報を抽出できる可能性があります。

**Insecure および/または Deprecated なアルゴリズムの使用**

開発者は認証チェック、データの保存や送信に **deprecated algorithms** を使用すべきではありません。例として RC4、MD4、MD5、SHA1 などがあります。例えばパスワードの保存に **hashes** を使う場合は、salt を使った brute-force resistant なハッシュを利用してください。

### その他のチェック

- 逆解析の難易度を上げるために、**APK を obfuscate** することが推奨されます。
- アプリが機密性の高いもの（bank apps のような）であれば、モバイルが **rooted** かどうかをアプリ自身でチェックし、それに応じた対処を行うべきです。
- アプリが機密性の高いもの（bank apps のような）であれば、**emulator** が使われているかどうかをチェックするべきです。
- アプリが機密性の高いもの（bank apps のような）であれば、実行前に **自身の整合性をチェック** して改変されていないか確認するべきです。
- APK をビルドする際に使われたコンパイラ／パッカー／obfuscator を確認するには [**APKiD**](https://github.com/rednaga/APKiD) を使用してください

### React Native アプリケーション

React アプリケーションの javascript コードに簡単にアクセスする方法については、次のページを参照してください：


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin アプリケーション

Xamarin アプリケーションの C# コードに簡単にアクセスする方法については、次のページを参照してください：


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

この [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) によると、superpacked はアプリのコンテンツを単一ファイルに圧縮する Meta アルゴリズムです。ブログではこの種のアプリを展開するアプリを作れる可能性について述べられており、ファイルシステムから展開済みファイルを収集するために **アプリを実行して展開されたファイルを取得する** より高速な方法についても触れられています。

### 自動静的コード解析

ツール [**mariana-trench**](https://github.com/facebook/mariana-trench) はアプリケーションの **code** を **scanning** することで **vulnerabilities** を検出することができます。このツールは **known sources**（ユーザが制御する **input** が入る **場所** をツールに示すもの）、**sinks**（悪意ある入力がダメージを与えうる **危険な場所** を示すもの）、および **rules** を含みます。これらの rules は脆弱性を示す **sources-sinks の組み合わせ** を定義します。

この知識により、**mariana-trench はコードをレビューして潜在的な脆弱性を発見します**。

### Secrets leaked

アプリケーションには API keys、パスワード、隠し URL、サブドメインなどの secrets が含まれていることがあり、これらを発見できる可能性があります。例えば次のようなツールを使えます: [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### その他の興味深い関数

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** 宣言は `native`: `public native, System.loadLibrary, System.load`
- [ネイティブ関数をリバースする方法はこちらを参照](reversing-native-libraries.md)
- JNI を介したメモリ内ネイティブコード実行（ダウンロードした shellcode → mmap/mprotect → 呼び出し）:

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> まず第一に、アプリケーションおよび必要な環境（Burp CA cert、Drozer、Frida など）をインストールできる環境が必要です。したがって、rooted デバイス（エミュレートされたものでも）は強く推奨されます。

### Online Dynamic analysis

無料アカウントを作成できるサービスの一つに: [https://appetize.io/](https://appetize.io) があります。このプラットフォームは APK を **upload** して **execute** できるため、APK の挙動を確認するのに便利です。

Web 上でアプリケーションのログを **見る** こともでき、**adb** を通じて接続することもできます。

![](<../../images/image (831).png>)

ADB 接続により、エミュレータ内で **Drozer** や **Frida** を使用できます。

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio)（**x86** と **arm** デバイスを作成できます。また [**この情報**](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html) によれば **最新の x86** では遅い arm エミュレータを使わずに ARM ライブラリをサポートしています）。
- セットアップ方法は次のページを参照してください：


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition、アカウント作成が必要です。_エラー回避のために_ _**VirtualBox と一緒の**_ バージョンを **download** することを推奨します。_)
- [**Nox**](https://es.bignox.com)（無料ですが、Frida や Drozer をサポートしません）。

> [!TIP]
> どのプラットフォームで新しいエミュレータを作成する場合でも、画面が大きいほどエミュレータは遅くなります。可能であれば小さい画面を選択してください。

Genymotion に Google サービス（Play Store 等）をインストールするには、次の画像の赤いボタンをクリックしてください：

![](<../../images/image (277).png>)

また、**Genymotion の Android VM の設定**で **Bridge Network mode** を選択できることに注意してください（これは別の VM からツールで Android VM に接続する場合に有用です）。

#### Use a physical device

**debugging** オプションを有効にし、可能であれば **root** することが望ましいです：

1. **Settings**。
2. (FromAndroid 8.0) **System** を選択。
3. **About phone** を選択。
4. **Build number** を7回押す。
5. 戻ると **Developer options** が表示されます。

> アプリをインストールしたら、最初に行うべきことはアプリを使って何をするのか、どのように動作するのかを調べ、慣れることです。\
> まずは MobSF dynamic analysis + pidcat を使ってこの初期の動的解析を行うことを推奨します。これによりアプリの動作を学びつつ、MobSF が後でレビューできる多くの興味深いデータを capture してくれます。

Magisk/Zygisk quick notes (Pixel デバイスで推奨)
- Magisk アプリで boot.img を patch し、fastboot 経由で flash して systemless root を取得
- Zygisk を有効化し DenyList で root 隠蔽を行う；より強力な隠蔽が必要な場合は LSPosed/Shamiko を検討
- OTA 更新からの復旧用に元の boot.img を保持；OTA 毎に再 patch
- 画面ミラーリングにはホストで scrcpy を使用

### Unintended Data Leakage

**Logging**

開発者は **debugging information** を公開しないよう注意するべきです。公開されると機密データの leak に繋がる可能性があります。アプリログの監視には [**pidcat**](https://github.com/JakeWharton/pidcat) や `adb logcat` を推奨します。**Pidcat** は使いやすさと可読性から好まれます。

> [!WARNING]
> **Android 4.0 より新しいバージョン以降**では、**アプリケーションは自分自身のログにしかアクセスできません**。したがって、他のアプリのログにはアクセスできません。\
> それでもなお、機密情報をログに出力しないことが推奨されます。

**Copy/Paste Buffer Caching**

Android の **clipboard-based** フレームワークはアプリ間でのコピー＆ペーストを可能にしますが、他のアプリがクリップボードにアクセスできるため、機密データが露出するリスクがあります。クレジットカード情報など機密性の高いセクションでは copy/paste 機能を無効にすることが重要です。

**Crash Logs**

アプリがクラッシュしてログを保存している場合、これらのログはリバースできないアプリに対しても攻撃者を助けることがあります。対策としては、クラッシュ時のログ出力を避けるか、ログをネットワーク経由で送信する必要がある場合は SSL チャネルを使用してください。

pentester として、**これらのログを確認する**ようにしてください。

**Analytics Data Sent To 3rd Parties**

アプリはしばしば Google Adsense のようなサービスを統合しており、開発者の実装不備により機密データが第三者に leak する可能性があります。第三者サービスに送信されている機密情報を確認するには、アプリのトラフィックを intercept してチェックすることを推奨します。

### SQLite DBs

ほとんどのアプリは情報を保存するために **internal SQLite databases** を使用します。ペンテスト中は作成された **databases**、**tables** と **columns** の名前、保存されているすべての **data** を確認してください。ここに機密情報が見つかることがあります（脆弱性となります）。\
データベースは通常 `/data/data/the.package.name/databases` にあります。例えば `/data/data/com.mwr.example.sieve/databases`

データベースが機密情報を保存していて **encrypted** されていても、アプリ内にパスワードが見つかる場合はそれは依然として **脆弱性** です。

.tables を使ってテーブルを列挙し、`.schema <table_name>` でテーブルのカラムを列挙してください。

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** を使うと **Android アプリの役割を担い**、他のアプリとやり取りできます。インストール済みアプリができることなら何でも実行でき、Android の Inter-Process Communication (IPC) 機構を利用したり、基盤となる OS とやり取りできます。\
Drozer は **exported activities、exported services、Content Providers** を exploit するための有用なツールです。以下のセクションで学べます。

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
また、Activity のコードは **`onCreate`** メソッドから開始することを覚えておいてください。

**Authorisation bypass**

Activity が exported されている場合、外部アプリからその画面を呼び出すことができます。したがって、**sensitive information** を扱う Activity が exported されていると、認証機構を bypass してアクセスされる可能性があります。

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

adb から exported activity を起動することもできます:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**注意**: MobSF はアクティビティで _**singleTask/singleInstance**_ を `android:launchMode` として使用していると悪意あるものと検出しますが、[this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750) によると、これは古いバージョン（API バージョン < 21）のみで危険なようです。

> [!TIP]
> Note that an authorisation bypass is not always a vulnerability, it would depend on how the bypass works and which information is exposed.

**機密情報の漏洩**

**Activities can also return results**. If you manage to find an exported and unprotected activity calling the **`setResult`** method and **returning sensitive information**, there is a sensitive information leakage.

#### Tapjacking

If tapjacking isn't prevented, you could abuse the exported activity to make the **user perform unexpected actions**. For more info about [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers are basically used to **share data**. If an app has available content providers you may be able to **extract sensitive** data from them. It also interesting to test possible **SQL injections** and **Path Traversals** as they could be vulnerable.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Remember that a the actions of a Service start in the method `onStartCommand`.

As service is basically something that **can receive data**, **process** it and **returns** (or not) a response. Then, if an application is exporting some services you should **check** the **code** to understand what is it doing and **test** it **dynamically** for extracting confidential info, bypassing authentication measures...\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Remember that a the actions of a Broadcast Receiver start in the method `onReceive`.

A broadcast receiver will be waiting for a type of message. Depending on how the receiver handles the message it could be vulnerable.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

You can look for deep links manually, using tools like MobSF or scripts like [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
You can **open** a declared **scheme** using **adb** or a **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_注意：**omit the package name** を行うと、モバイルはそのリンクを開くべきアプリを自動的に呼び出します._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Code executed**

アプリで実行される**コードを見つけるために**、deeplink によって呼び出される activity に移動し、関数 **`onNewIntent`** を検索してください。

![](<../../images/image (436) (1) (1) (1).png>)

**Sensitive info**

deep link を見つけるたびに、**URL パラメータ経由でパスワードのような sensitive data を受け取っていないか**確認してください。さもないと、他のアプリケーションが deep link を**偽装してそのデータを盗む**可能性があります！

**Parameters in path**

URL のパス内でパラメータを使用している deep link がないかも**必ず確認**してください。例えば: `https://api.example.com/v1/users/{username}` 。その場合、`example://app/users?username=../../unwanted-endpoint%3fparam=value` のように path traversal を強制できることがあります。\
アプリ内で該当のエンドポイントを見つけた場合、（パスの一部がドメイン名として使われると）**Open Redirect** を引き起こしたり、（CSRF token がなく、脆弱なエンドポイントが正しいメソッドを使用している場合）**account takeover** を引き起こしたり、その他の脆弱性に繋がる可能性がある点に注意してください。More [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Transport Layer Inspection and Verification Failures

- **Certificates are not always inspected properly** by Android applications. これらのアプリが警告を見落として self-signed certificates を受け入れたり、場合によっては HTTP 接続に戻したりするのはよくあることです。
- **Negotiations during the SSL/TLS handshake are sometimes weak**, insecure な cipher suites を使用していることがあります。この脆弱性により接続が man-in-the-middle (MITM) 攻撃に対して脆弱になり、攻撃者がデータを復号できる可能性があります。
- **Leakage of private information** は、アプリが安全なチャネルで認証した後に他の取引で非安全なチャネルを使用する場合にリスクとなります。このやり方はセッション cookie やユーザー詳細などの機密データを悪意ある第三者による傍受から保護できません。

#### Certificate Verification

ここでは **certificate verification** に焦点を当てます。サーバー証明書の整合性を検証することはセキュリティを高める上で非常に重要です。なぜなら、不適切な TLS 設定や暗号化されていないチャネルでの機密データ送信は重大なリスクを引き起こす可能性があるためです。サーバー証明書の検証や脆弱性対応に関する詳細な手順は、[**this resource**](https://manifestsecurity.com/android-application-security-part-10/) を参照してください。

#### SSL Pinning

SSL Pinning は、アプリがサーバー証明書をアプリ内に保存された既知のコピーと照合して検証するセキュリティ手法です。この方法は MITM 攻撃を防ぐために重要です。機密情報を扱うアプリケーションには SSL Pinning の実装を強く推奨します。

#### Traffic Inspection

HTTP トラフィックを検査するには、**proxy tool の証明書をインストール**する必要があります（例: Burp）。この証明書をインストールしなければ、暗号化されたトラフィックはプロキシ上で可視化されないことがあります。カスタム CA 証明書のインストール手順は [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine) を参照してください。

**API Level 24 and above** をターゲットにしているアプリケーションは、proxy の CA 証明書を受け入れるよう Network Security Config の変更が必要です。これは暗号化トラフィックを検査する上で重要な手順です。Network Security Config の変更手順は [**refer to this tutorial**](make-apk-accept-ca-certificate.md) を参照してください。

もし **Flutter** を使用している場合は [**this page**](flutter.md) の指示に従う必要があります。単に証明書をストアに追加するだけでは動作しないことがあり、Flutter は独自の有効な CA リストを持っているためです。

#### Static detection of SSL/TLS pinning

ランタイムでのバイパスを試みる前に、APK 内でどこに pinning が強制されているかを素早くマッピングしてください。静的解析で発見しておくことで、フックやパッチの計画を立て、正しいコードパスに集中できます。

Tool: SSLPinDetect
- Open-source static-analysis utility that decompiles the APK to Smali (via apktool) and scans for curated regex patterns of SSL/TLS pinning implementations.
- Reports exact file path, line number, and a code snippet for each match.
- Covers common frameworks and custom code paths: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

Install
- 前提条件: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
使い方
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
パターンルールの例（JSON）
signatures を使用または拡張して、プロプライエタリ/カスタムな pinning スタイルを検出します。独自の JSON を読み込み、大規模にスキャンできます。
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes and tips
- 大規模なアプリをマルチスレッディングとメモリマップド I/O で高速スキャン; 事前コンパイルした正規表現はオーバーヘッド／誤検知を減らす。
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Typical detection targets to triage next:
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Declarative pins in res/xml network security config and manifest references
- Use the matched locations to plan Frida hooks, static patches, or config reviews before dynamic testing.



#### SSL Pinning の回避

When SSL Pinning is implemented, bypassing it becomes necessary to inspect HTTPS traffic. Various methods are available for this purpose:

- Automatically **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). The best pro of this option, is that you won't need root to bypass the SSL Pinning, but you will need to delete the application and reinstall the new one, and this won't always work.
- You could use **Frida** (discussed below) to bypass this protection. Here you have a guide to use Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- You can also try to **automatically bypass SSL Pinning** using [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- You can also try to **automatically bypass SSL Pinning** using **MobSF dynamic analysis** (explained below)
- If you still think that there is some traffic that you aren't capturing you can try to **forward the traffic to burp using iptables**. Read this blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Looking for Common Web Vulnerabilities

It's important to also search for common web vulnerabilities within the application. Detailed information on identifying and mitigating these vulnerabilities is beyond the scope of this summary but is extensively covered elsewhere.

### Frida

[Frida](https://www.frida.re) is a dynamic instrumentation toolkit for developers, reverse-engineers, and security researchers.\
**You can access running application and hook methods on run time to change the behaviour, change values, extract values, run different code...**\
If you want to pentest Android applications you need to know how to use Frida.

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Some "GUI" for actions with Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- You can find some Awesome Frida scripts here: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Try to bypass anti-debugging / anti-frida mechanisms loading Frida as in indicated in [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **メモリダンプ - Fridump**

Check if the application is storing sensitive information inside the memory that it shouldn't be storing like passwords or mnemonics.

Using [**Fridump3**](https://github.com/rootbsd/fridump3) you can dump the memory of the app with:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
これはメモリを ./dump フォルダにダンプします。そこで次のような grep を使って検索できます:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Keystore内の機密データ**

AndroidではKeystoreが機密データを保存する最良の場所ですが、十分な権限があれば依然としてアクセス可能です。多くのアプリケーションはここに機密データをclear textで保存しがちであるため、pentestsではroot userとして確認する必要があります。deviceにphysical accessを持つ者はこのデータを盗むことができます。

たとえアプリがKeystoreにデータを保存していても、そのデータは暗号化されているべきです。

Keystore内のデータにアクセスするには、次のFridaスクリプトを使用できます: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

次の Frida スクリプトを使用すると、Android アプリが特定の機密領域を保護するために行っている **bypass fingerprint authentication** を回避できる可能性があります:
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **バックグラウンド画像**

アプリケーションをバックグラウンドにすると、Androidはアプリケーションの**スナップショット**を保存します。フォアグラウンドに復帰したとき、アプリの読み込み前にそのイメージを読み込むため、アプリがより速く起動したように見えます。

しかし、この**スナップショット**に**機密情報**が含まれている場合、スナップショットにアクセスできる者がその情報を**盗む**可能性があります（アクセスするにはroot権限が必要である点に注意してください）。

スナップショットは通常次の場所に保存されます： **`/data/system_ce/0/snapshots`**

Androidは**FLAG_SECUREを設定してスクリーンショットの取得を防ぐ**方法を提供します。このフラグを使用すると、ウィンドウの内容がセキュアとして扱われ、スクリーンショットに表示されたり非セキュアなディスプレイで表示されたりすることを防ぎます。
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

このツールは dynamic analysis 中に複数のツールを管理するのに役立ちます: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Developers often create proxy components like activities, services, and broadcast receivers that handle these Intents and pass them to methods such as `startActivity(...)` or `sendBroadcast(...)`, which can be risky.

危険なのは、攻撃者がこれらの Intents を誤誘導することで、非エクスポートのアプリコンポーネントを起動させたり、機密性の高い Content-Providers にアクセスさせたりできる点にあります。顕著な例として、`WebView` コンポーネントが URL を `Intent.parseUri(...)` を使って `Intent` オブジェクトに変換し、それを実行してしまうことで、悪意ある Intent 注入につながる可能性があります。

### Essential Takeaways

- **Intent Injection** は web の Open Redirect 問題に類似しています。
- エクスプロイトは `Intent` オブジェクトを extras として渡し、それをリダイレクトして安全でない操作を実行させることを伴います。
- 非エクスポートのコンポーネントや Content-Providers が攻撃者に露出する可能性があります。
- `WebView` の URL から `Intent` への変換は、意図しない動作を引き起こす可能性があります。

### Android Client Side Injections and others

おそらくこれらの脆弱性は Web でも見慣れていると思います。Android アプリでは特に以下に注意してください:

- **SQL Injection:** 動的なクエリや Content-Providers を扱う際は、必ずパラメータ化されたクエリを使用してください。
- **JavaScript Injection (XSS):** JavaScript と Plugin のサポートが WebViews で無効になっていることを確認してください（デフォルトで無効）。[More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews はファイルシステムへのアクセスを無効にするべきです（デフォルトでは有効） - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: 多くの場合、Android アプリがセッションを終了してもクッキーが無効化されなかったり、ディスクに保存されてしまうことがあります
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Static analysis**

![](<../../images/image (866).png>)

**Vulnerability assessment of the application** は使いやすい web ベースのフロントエンドを使って行われます。You can also perform dynamic analysis (but you need to prepare the environment).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Assisted Dynamic analysis with MobSF

**MobSF** can also be very helpful for **dynamic analysis** in **Android**, but in that case you will need to install MobSF and **genymotion** in your host (a VM or Docker won't work). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
The **MobSF dynamic analyser** can:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). All of this is done automatically except for the screenshots, you need to press when you want a screenshot or you need to press "**Exported Activity Tester**" to obtain screenshots of all the exported activities.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: It will print all the loaded classes
- **Capture Strings**: It will print all the capture strings while using the application (super noisy)
- **Capture String Comparisons**: Could be very useful. It will **show the 2 strings being compared** and if the result was True or False.
- **Enumerate Class Methods**: Put the class name (like "java.io.File") and it will print all the methods of the class.
- **Search Class Pattern**: Search classes by pattern
- **Trace Class Methods**: **Trace** a **whole class** (see inputs and outputs of all methods of th class). Remember that by default MobSF traces several interesting Android Api methods.

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf also brings you a shell with some **adb** commands, **MobSF commands**, and common **shell** **commands** at the bottom of the dynamic analysis page. Some interesting commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP tools**

When http traffic is capture you can see an ugly view of the captured traffic on "**HTTP(S) Traffic**" bottom or a nicer view in "**Start HTTPTools**" green bottom. From the second option, you can **send** the **captured requests** to **proxies** like Burp or Owasp ZAP.\
To do so, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> press "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Once you finish the dynamic analysis with MobSF you can press on "**Start Web API Fuzzer**" to **fuzz http requests** an look for vulnerabilities.

> [!TIP]
> After performing a dynamic analysis with MobSF the proxy settings me be misconfigured and you won't be able to fix them from the GUI. You can fix the proxy settings by doing:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

You can get the tool from [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
This tool with use some **Hooks** to let you know **what is happening in the application** while you perform a **dynamic analysis**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

This is a **great tool to perform static analysis with a GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

This tool is designed to look for several **security related Android application vulnerabilities**, either in **source code** or **packaged APKs**. The tool is also **capable of creating a "Proof-of-Concept" deployable APK** and **ADB commands**, to exploit some of the found vulnerabilities (Exposed activities, intents, tapjacking...). As with Drozer, there is no need to root the test device.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- 参照しやすいように抽出されたすべてのファイルを表示する
- APKファイルを自動的にJavaおよびSmali形式にデコンパイルする
- AndroidManifest.xmlを解析して一般的な脆弱性や挙動を検出する
- 静的なソースコード解析で一般的な脆弱性や挙動を検出する
- デバイス情報を表示する
- その他
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPERは、Windows、MacOS X、Linuxで使用できるコマンドラインアプリケーションで、脆弱性を探すために _.apk_ ファイルを解析します。これはAPKを展開し、一連のルールを適用してこれらの脆弱性を検出することで行われます。

すべてのルールは `rules.json` ファイルに集中しており、各企業やテスターは必要に応じて独自のルールを作成して解析できます。

最新のバイナリは [download page](https://superanalyzer.rocks/download.html) からダウンロードしてください。
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAnはモバイルアプリケーションの[static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis)を行う開発者、bugbounty hunters、ethical hackersを支援する**クロスプラットフォーム**ツールです。

コンセプトは、モバイルアプリケーションファイル（.apk または .ipa ファイル）を StaCoAn アプリにドラッグ＆ドロップすると、視覚的で持ち運び可能なレポートを生成するというものです。設定や wordlists を調整してカスタマイズした体験を得ることができます。

ダウンロード[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Frameworkは、Androidアプリケーションの潜在的なセキュリティ脆弱性を開発者や hackers が発見するのを支援する解析システムです。\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** は、Androidアプリケーションによって引き起こされる可能性のある悪意のある振る舞いを検出し、ユーザーに警告することを主目的としたツールです。

検出は、アプリケーションの Dalvik バイトコード（**Smali** で表現）に対する **static analysis** を [`androguard`](https://github.com/androguard/androguard) ライブラリを用いて行います。

このツールは、**「悪意のあるアプリに共通する振る舞い」** を検出します。例: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** は **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework です。一般的に使われるモバイルアプリのリバースエンジニアリングおよび解析ツールをまとめて、OWASP の mobile security 脅威に対するモバイルアプリのテストを支援するためのツールです。目的は、この作業をモバイルアプリ開発者やセキュリティ専門家にとってより簡単で扱いやすくすることです。

できること：

- さまざまなツールを使って Java と Smali のコードを抽出する
- 以下を使用して APK を解析する: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- 正規表現を使用して APK からプライベート情報を抽出する
- Manifest を解析する
- 発見したドメインを以下で解析する: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- [apk-deguard.com](http://www.apk-deguard.com) 経由で APK の逆難読化を行う

### Koodous

マルウェア検出に有用: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

コードを難読化するサービスや設定によって、シークレットが難読化される場合とされない場合がある点に注意してください。

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** は Java コードを縮小、最適化、難読化するオープンソースのコマンドラインツールです。バイトコードの最適化や未使用命令の検出・削除が可能です。ProGuard はフリーソフトウェアで、GNU General Public License version 2 の下で配布されています。

ProGuard は Android SDK の一部として配布され、アプリをリリースモードでビルドする際に実行されます。

### [DexGuard](https://www.guardsquare.com/dexguard)

APK を逆難読化するステップバイステップのガイドは [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html) にあります。

（そのガイドより）最終確認時点での Dexguard の動作は次のとおりでした:

- リソースを InputStream として読み込む;
- FilterInputStream を継承したクラスに結果を渡して復号する;
- リバースエンジニアの時間を浪費するためにいくつかの無意味な難読化を行う;
- 復号した結果を ZipInputStream に渡して DEX ファイルを取得する;
- 最後に、`loadDex` メソッドを使って生成された DEX を Resource としてロードする。

### [DeGuard](http://apk-deguard.com)

**DeGuard は Android の難読化ツールによって行われた難読化プロセスを逆転します。これによりコード検査やライブラリの予測など、多数のセキュリティ解析が可能になります。**

難読化された APK をプラットフォームにアップロードできます。

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

これは Android アプリ内の潜在的なセキュリティ脆弱性を見つけ、Android アプリのコードを逆難読化するための LLM ツールです。Google の Gemini public API を使用します。

### [Simplify](https://github.com/CalebFenton/simplify)

これは汎用の Android 逆難読化ツールです。Simplify はアプリを事実上実行してその振る舞いを理解し、その後コードを最適化して、同一の振る舞いを維持しつつ人間にとって理解しやすくしようとします。各最適化タイプは単純かつ汎用的であるため、具体的にどのタイプの難読化が使われているかは問題になりません。

### [APKiD](https://github.com/rednaga/APKiD)

APKiD は APK がどのように作られたかの情報を提供します。多くのコンパイラ、パッカー、オブフuscator（難読化ツール）、その他の怪しげなものを識別します。Android 用の [_PEiD_](https://www.aldeid.com/wiki/PEiD) のようなツールです。

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b は ubuntu-mate ベースの Android セキュリティ仮想マシンで、リバースエンジニアリングやマルウェア解析のための最新フレームワーク、チュートリアル、ラボをさまざまなセキュリティ研究者や愛好家から収集しています。

## References

- [Play Integrity API: How It Works & How to Bypass It](https://m4kr0.vercel.app/posts/play-integrity-api-how-it-works--how-to-bypass-it/)
- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) 素晴らしいリソースの一覧です
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android のクイックコース
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
