# Programu za Android Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Misingi ya Programu za Android

Inapendekezwa sana kuanza kusoma ukurasa huu ili kujua kuhusu **sehemu muhimu zaidi zinazohusiana na usalama wa Android na vipengele hatari zaidi katika programu ya Android**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Hii ni zana kuu unayohitaji kuunganishwa na kifaa cha Android (kilichoemulated au cha kimwili).\
**ADB** inaruhusu kudhibiti vifaa kupitia **USB** au **Network** kutoka kwa kompyuta. Zana hii inafanya iwezekane **kunakili** faili kwa pande zote mbili, **kufunga** na **kuondoa** apps, **kutekeleza** amri za shell, **kuhifadhi** data, **kusoma** logs, miongoni mwa kazi nyingine.

Angalia orodha ifuatayo ya [**ADB Commands**](adb-commands.md) ili ujifunze jinsi ya kutumia adb.

## Smali

Wakati mwingine ni ya kuvutia **kubadilisha msimbo wa programu** ili kupata **taarifa zilizofichwa** (labda nywila zilizoobfuscated vizuri au flags). Basi, inaweza kuwa ya kuvutia kudecopile APK, kubadilisha msimbo na kuirecompile.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Hii inaweza kuwa muhimu sana kama **mbadala kwa majaribio kadhaa wakati wa dynamic analysis** yatakayowasilishwa. Kwa hiyo, **kumbuka kila mara uwezekano huu**.

## Other interesting tricks

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **Pakua APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Extract APK from device:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Unganisha splits zote na base apks kwa kutumia [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Android Enterprise & Work Profile Shambulio

{{#ref}}
android-enterprise-work-profile-bypass.md
{{#endref}}

## Masomo ya Kesi & Udhaifu


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Uchambuzi wa Static

Kwanza kabisa, kwa kuchambua APK unapaswa **kutazama msimbo wa Java** kwa kutumia decompiler.\
Tafadhali, [**soma hapa ili kupata taarifa kuhusu decompilers tofauti zilizopo**](apk-decompilers.md).

### Kutafuta Taarifa Zinazovutia

Kwa kuangalia tu **strings** za APK unaweza kutafuta **nywila**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api keys**, **ufichaji**, **bluetooth uuids**, **tokens** na chochote kinachovutia... angalia hata kwa code execution **backdoors** au authentication backdoors (cheo cha admin kilicho hardcoded ndani ya app).

**Firebase**

Lipa kipaumbele maalum kwa **Firebase URLs** na angalia kama imewekwa vibaya. [Taarifa zaidi kuhusu nini ni Firebase na jinsi ya kuitumia hapa.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Uelewa wa Msingi wa Programu - Manifest.xml, strings.xml

**Uchunguzi wa faili za programu _Manifest.xml_ na _strings.xml_ unaweza kufichua udhaifu wa usalama**. Faili hizi zinaweza kupatikana kwa kutumia decompilers au kwa kubadilisha extension ya APK kuwa .zip kisha kuizifungua.

**Udhaifu** unaoweza kubainika kutoka kwa **Manifest.xml** ni pamoja na:

- **Debuggable Applications**: Programu zilizowekwa kama debuggable (`debuggable="true"`) katika _Manifest.xml_ zinaweza kuwa hatari kwani zinaruhusu connections ambazo zinaweza kusababisha kutumiwa vibaya. Kwa uelewa zaidi juu ya jinsi ya kutumia programu zilizo debuggable, rejea mwongozo wa kupata na kutumia programu zilizo debuggable kwenye kifaa.
- **Backup Settings**: Sifa `android:allowBackup="false"` inapaswa kuwekwa wazi kwa programu zinazoshughulikia taarifa nyeti ili kuzuia backups zisizoidhinishwa kupitia adb, hasa wakati usb debugging imewezeshwa.
- **Network Security**: Custom network security configurations (`android:networkSecurityConfig="@xml/network_security_config"`) katika _res/xml/_ zinaweza kuelezea maelezo ya usalama kama certificate pins na mipangilio ya trafiki ya HTTP. Mfano ni kuruhusu trafiki ya HTTP kwa domain maalum.
- **Exported Activities and Services**: Kutambua activities na services zilizoorodheshwa kama exported kwenye manifest kunaweza kuonyesha vipengele vinavyoweza kutumiwa vibaya. Uchambuzi zaidi wakati wa majaribio ya dynamic unaweza kufichua jinsi ya kutumia vipengele hivyo.
- **Content Providers and FileProviders**: content providers zilizofunguliwa zinaweza kuruhusu upatikanaji au mabadiliko yasiyoidhinishwa ya data. Mpangilio wa FileProviders pia unapaswa kuchunguzwa kwa umakini.
- **Broadcast Receivers and URL Schemes**: Vipengele hivi vinaweza kutumika kwa ajili ya kutekeleza shambulio, hasa ukizingatia jinsi URL schemes zinavyosimamiwa kwa udhaifu wa input.
- **SDK Versions**: `minSdkVersion`, `targetSDKVersion`, na `maxSdkVersion` zinaonyesha toleo za Android zinazoungwa mkono, zikibainisha umuhimu wa kuto support toleo la Android lililo zamani na lenye udhaifu kwa sababu za usalama.

Kutoka kwa faili ya **strings.xml**, taarifa nyeti kama API keys, schemas za kawaida, na noti nyingine za developer zinaweza kugunduliwa, ikisisitiza umuhimu wa kupitia rasilimali hizi kwa uangalifu.

### Tapjacking

**Tapjacking** ni shambulio ambalo programu ya **malicious** inazinduliwa na **kujipanga juu ya programu ya mwathiri**. Mara inapozaa muonekano juu ya app ya mwathiri, interface yake imeundwa ili kumdanganya mtumiaji kuingiliana nayo, huku ikipitisha mwingiliano huo kwa app ya mwathiri.\
Kwa vitendo, inamficha mtumiaji akidhani anafanya shughuli kwenye programu yake, wakati kwa kweli anafanya vitendo kwenye app ya mwathiri.

Pata taarifa zaidi katika:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Activity ikiwa na `launchMode` imewekwa kwa `singleTask` bila `taskAffinity` yoyote iliyoelezwa ni dhaifu kwa task Hijacking. Hii inamaanisha, kwamba programu inaweza kusakinishwa na ikiwa itaendeshwa kabla ya programu halisi inaweza **hijack task ya programu halisi** (hivyo mtumiaji atakuwa akielewa kuwa anaingiliana na **programu ya malicious akidhani anatumia ile halisi**).

Taarifa zaidi katika:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Uhifadhi wa Data Usio Salama

**Internal Storage**

Katika Android, faili **zilizo hifadhiwa** kwenye **internal** storage zimetengenezwa kuwa zinapatikana pekee kwa **app** iliyozitengeneza. Kipimo hiki cha usalama kinatekelezwa na mfumo wa uendeshaji wa Android na kwa ujumla kinatosheleza mahitaji ya usalama ya programu nyingi. Hata hivyo, waendelezaji wakati mwingine hutumia modes kama `MODE_WORLD_READABLE` na `MODE_WORLD_WRITABLE` kuruhusu faili kushirikiwa kati ya programu tofauti. Modes hizi hazizuii upatikanaji wa faili hizi na programu nyingine, ikiwa ni pamoja na zile zinazoweza kuwa malicious.

1. **Static Analysis:**
- **Hakikisha** matumizi ya `MODE_WORLD_READABLE` na `MODE_WORLD_WRITABLE` yanachunguzwa kwa uangalifu. Modes hizi **zinaweza kufichua** faili kwa upatikanaji usiokusudiwa au usioidhinishwa.
2. **Dynamic Analysis:**
- **Thibitisha** ruhusa zilizowekwa kwa faili zinazotengenezwa na app. Kabla ya yote, **angalia** kama faili zozote zimeruhusiwa kusomwa au kuandikwa kwa ulimwengu wote. Hii inaweza kuwa hatari sana kwa usalama, kwani itamruhusu **app yoyote** iliyosakinishwa kwenye kifaa, bila kujali asili yake au nia, **kusoma au kubadilisha** faili hizi.

**External Storage**

Unaposhughulika na faili kwenye **external storage**, kama SD Cards, tahadhari fulani zinapaswa kuchukuliwa:

1. **Accessibility**:
- Faili kwenye external storage ni **zinazosomwa na kuandikwa kwa wote**. Hii inamaanisha programu au mtumiaji yeyote anaweza kufikia faili hizi.
2. **Security Concerns**:
- Kutokana na upatikanaji rahisi, inapendekezwa **kutoweka taarifa nyeti** kwenye external storage.
- External storage inaweza kuondolewa au kufikiwa na programu yoyote, hivyo kufanya kuwa isiyo salama.
3. **Handling Data from External Storage**:
- Daima **fanya input validation** kwa data inayotokana na external storage. Hii ni muhimu kwa sababu data inatoka kwenye chanzo kisichoaminika.
- Kuhifadhi executables au class files kwenye external storage kwa ajili ya dynamic loading ni jambo linaloshauriwa kuepukwa.
- Ikiwa app yako lazima ipokee faili za executable kutoka external storage, hakikisha faili hizi zimesainiwa na kuthibitishwa kwa cryptographic kabla ya kuzipakia kwa dynamic. Hatua hii ni muhimu kwa kudumisha uadilifu wa usalama wa programu yako.

External storage inaweza kupatikana katika /storage/emulated/0 , /sdcard , /mnt/sdcard

> [!TIP]
> Kuanzia Android 4.4 (**API 17**), SD card ina muundo wa directory ambao **unapunguza upatikanaji kutoka kwa app hadi directory iliyotengwa mahsusi kwa app hiyo**. Hii inazuia application malicious kupata upatikanaji wa kusoma au kuandika faili za app nyingine.

**Taarifa nyeti zilizo hifadhiwa kwa maandishi wazi**

- **Shared preferences**: Android inaruhusu kila application kuhifadhi kwa urahisi faili za xml kwenye njia `/data/data/<packagename>/shared_prefs/` na wakati mwingine inawezekana kupata taarifa nyeti kwa maandishi wazi katika folda hiyo.
- **Databases**: Android inaruhusu kila application kuhifadhi kwa urahisi databases za sqlite kwenye njia `/data/data/<packagename>/databases/` na wakati mwingine inawezekana kupata taarifa nyeti kwa maandishi wazi katika folda hiyo.

### TLS Iliyovunjika

**Kupokea Vyeti Vyote**

Kwa sababu fulani wakati mwingine developers wanakubali vyeti vyote hata kama kwa mfano hostname haitolingani na mistari ya msimbo kama ifuatavyo:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Njia nzuri ya kujaribu hili ni kukamata trafiki kwa kutumia proxy kama Burp bila kuidhinisha Burp CA ndani ya kifaa. Pia, unaweza kuunda na Burp cheti kwa hostname tofauti na kukitumia.

### Kriptografia iliyovunjika

**Mchakato mbaya wa usimamizi wa funguo**

Baadhi ya watengenezaji huhifadhi data nyeti kwenye storage ya ndani na kuiweka kwa encryption kwa funguo iliyowekwa ndani/kutabirika kwenye code. Hili halipaswi kufanywa kwani reverse engineering inaweza kumruhusu mshambuliaji kutoa taarifa nyeti.

**Matumizi ya Algorithms zisizo salama na/au zilizopitwa na wakati**

Watengenezaji hawapaswi kutumia **algorithms zilizopitwa na wakati** kufanya ukaguzi wa **idhinishaji**, **kuhifadhi** au **kutuma** data. Baadhi ya algorithms hizi ni: RC4, MD4, MD5, SHA1... Ikiwa **hashes** zinatumika kuhifadhi nywila kwa mfano, ni vyema kutumia hashes **zisizo rahisi kwa brute-force** pamoja na salt.

### Other checks

- Inashauriwa **kuficha (obfuscate) APK** ili kuleta ugumu kwa kazi ya reverse engineer kwa washambuliaji.
- Ikiwa app ni nyeti (kama app za benki), inapaswa kufanya **ukaguzi wake kuona kama mobile ime-rooted** na kuchukua hatua ipasavyo.
- Ikiwa app ni nyeti (kama app za benki), inapaswa kuangalia kama **emulator** inatumiwa.
- Ikiwa app ni nyeti (kama app za benki), inapaswa **kuangalia uadilifu wake mwenyewe kabla ya kutekeleza** ili kuangalia kama imebadilishwa.
- Tumia [**APKiD**](https://github.com/rednaga/APKiD) kuangalia compiler/packer/obfuscator gani ilitumiwa kujenga APK

### React Native Application

Soma ukurasa ufuatao ili kujifunza jinsi ya kupata kwa urahisi javascript code ya React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Soma ukurasa ufuatao ili kujifunza jinsi ya kupata kwa urahisi C# code ya xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

Kulingana na [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked ni algorithm ya Meta inayobanisha compress ya maudhui ya application ndani ya faili moja. Blogu inazungumzia uwezekano wa kuunda app inayo decompress aina hizi za apps... na njia ya haraka ambayo inahusisha **kutekeleza application na kukusanya faili zilizookolewa kwenye filesystem.**

### Uchambuzi wa msimbo wa staitiki uliotautomatika

Chombo [**mariana-trench**](https://github.com/facebook/mariana-trench) kina uwezo wa kupata **vulnerabilities** kwa **skanning** ya **code** ya application. Chombo hiki kina mfululizo wa **known sources** (ambazo zinaonyesha kwa chombo **maeneo** ambapo **input** iko **kikontrolwa na mtumiaji**), **sinks** (ambazo zinaonyesha kwa chombo **maeneo hatari** ambapo input ya mtumiaji mharibu inaweza kusababisha madhara) na **rules**. Kanuni hizi zinaonyesha **mchanganyiko** wa **sources-sinks** unaoonyesha udhaifu.

Kwa maarifa haya, **mariana-trench itapitia code na kupata udhaifu unaowezekana ndani yake**.

### Secrets leaked

Programu inaweza kuwa na siri (API keys, passwords, urls zilizofichwa, subdomains...) ndani yake ambazo unaweza kuweza kugundua. Unaweza kutumia chombo kama [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Kazi nyingine za kuvutia

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Soma hii ili kujifunza **jinsi ya kuweka reverse native functions**](reversing-native-libraries.md)
- In-memory native code execution via JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Uchambuzi Dinamiki

> Kwanza kabisa, unahitaji mazingira ambapo unaweza kusanidi application na mazingira yote (Burp CA cert, Drozer na Frida hasa). Kwa hivyo, kifaa kilicho-root (emulated au siyo) kinapendekezwa sana.

### Online Dynamic analysis

Unaweza kuunda akaunti ya **bure** kwa: [https://appetize.io/](https://appetize.io). Jukwaa hili linakuwezesha **kupakia** na **kutekeleza** APKs, hivyo ni muhimu kuona jinsi apk inavyoenda.

Unaweza hata **kuona logs za application yako** kwenye wavuti na kuungana kupitia **adb**.

![](<../../images/image (831).png>)

Shukrani kwa muunganisho wa ADB unaweza kutumia **Drozer** na **Frida** ndani ya emulators.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (Unaweza kuunda vifaa **x86** na **arm**, na kulingana na [**hii** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**matoleo ya hivi karibuni ya x86** yanaunga mkono maktaba za **ARM** bila hitaji la emulator polepole ya arm).
- Jifunze jinsi ya kuiweka kwenye ukurasa huu:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Toleo la bure:** Personal Edition, unahitaji kuunda akaunti. _Inapendekezwa **kupakua** toleo **NA**_ _**VirtualBox** ili kuepuka makosa ya uwezekano._)
- [**Nox**](https://es.bignox.com) (Bure, lakini haiungi mkono Frida au Drozer).

> [!TIP]
> Unapotengeneza emulator mpya kwenye jukwaa lolote kumbuka kuwa skrini kubwa, emulator itafanya kazi polepole. Hivyo chagua skrini ndogo inapowezekana.

Ili **kuweka huduma za google** (kama AppStore) katika Genymotion unahitaji kubonyeza kitufe kilicho na alama nyekundu kwenye picha ifuatayo:

![](<../../images/image (277).png>)

Pia, kumbuka kuwa katika **config ya Android VM katika Genymotion** unaweza kuchagua **Bridge Network mode** (hili litakuwa muhimu ikiwa utakuwa unakuza kuungana kwenye Android VM kutoka VM tofauti yenye zana).

#### Use a physical device

Unahitaji kuwezesha chaguo za **debugging** na itakuwa nzuri ukiona kama unaweza kui **root**:

1. **Settings**.
2. (Kuanzia Android 8.0) Chagua **System**.
3. Chagua **About phone**.
4. Bonyeza **Build number** mara 7.
5. Rudi nyuma utaona **Developer options**.

> Mara tu utakapokuwa umesanidi application, jambo la kwanza unapaswa kufanya ni kuijaribu na kuchunguza inafanya nini, jinsi inavyofanya kazi na kujisikia mwenye raha nayo.\
> Ninapendekeza **kufanya uchambuzi huu wa awali wa dinamiki kwa kutumia MobSF dynamic analysis + pidcat**, hivyo tutaweza **kujifunza jinsi application inavyofanya kazi** wakati MobSF inakayamata data nyingi **zinazovutia** ambazo unaweza kupitia baadaye.

Magisk/Zygisk quick notes (inayopendekezwa kwenye vifaa vya Pixel)
- Patch boot.img na app ya Magisk na flash kwa fastboot kupata systemless root
- Washa Zygisk + DenyList kwa kuficha root; fikiria LSPosed/Shamiko wakati kuficha kwa nguvu zaidi kunahitajika
- Hifadhi boot.img ya asili ili kurejesha baada ya OTA updates; re-patch baada ya kila OTA
- Kwa mirror ya screen, tumia scrcpy kwenye host



### Unintended Data Leakage

**Logging**

Watengenezaji wanapaswa kuwa waangalifu kutoonyesha **taarifa za debugging** hadharani, kwani inaweza kusababisha data nyeti ku-leak. Zana [**pidcat**](https://github.com/JakeWharton/pidcat) na `adb logcat` zinapendekezwa kwa kusimamia logs za application ili kubaini na kulinda taarifa nyeti. **Pidcat** inapendekezwa kwa urahisi wake wa matumizi na kusomeka.

> [!WARNING]
> Kumbuka kuwa kuanzia **matoleo mapya kuliko Android 4.0**, **programu zinaweza kufikia logi zao wenyewe tu**. Hivyo programu haziwezi kufikia logi za apps nyingine.\
> Hata hivyo, bado inashauriwa **kutoandika taarifa nyeti kwenye logi**.

**Copy/Paste Buffer Caching**

Mfumo wa **clipboard-based** wa Android unawezesha utendaji wa copy-paste katika apps, lakini unaweka hatari kwani **apps nyingine** zinaweza **kupata** clipboard, na hivyo kuonyesha data nyeti. Ni muhimu **kuzima kazi za copy/paste** kwa sehemu nyeti za app, kama taarifa za kadi ya mkopo, ili kuzuia data ku-leak.

**Crash Logs**

Iwapo application **inagyuka (crashes)** na **inaweka logi**, logi hizi zinaweza kumsaidia mshambuliaji, hasa wakati application haiwezi kureverse-engineered. Ili kupunguza hatari hii, epuka logging wakati wa crashes, na ikiwa logi lazima zitumiwe mtandaoni, hakikisha zinatumwa kupitia channel ya SSL kwa usalama.

Kama pentester, **jaribu kuangalia logi hizi**.

**Analytics Data Sent To 3rd Parties**

Applications mara nyingi hujumuisha huduma kama Google Adsense, ambayo kwa bahati mbaya inaweza **ku-leak** data nyeti kutokana na utekelezaji usio sahihi na watengenezaji. Ili kubaini uwezekano wa ku-leak kwa data, inashauriwa **kusimamia trafiki ya application** na kuangalia kama taarifa nyeti zinatumwa kwa huduma za watu wa tatu.

### SQLite DBs

Programu nyingi zitakuwa zikitumia **internal SQLite databases** kuhifadhi taarifa. Wakati wa pentest tazama **databases** zilizotengenezwa, majina ya **meza** na **safuku** na data zote zilizohifadhiwa kwa sababu unaweza kupata **taarifa nyeti** (ambazo zingekuwa udhaifu).\
Databases zinapaswa kupatikana katika `/data/data/the.package.name/databases` kama `/data/data/com.mwr.example.sieve/databases`

Ikiwa database inahifadhi taarifa za siri na ime **encrypted** lakini unaweza **kupata** **nywila** ndani ya application bado ni **udhaifu**.

Taja meza kwa kutumia `.tables` na taja safu za meza kwa kufanya `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

Kutoka [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** inakuwezesha **kuchukua nafasi ya Android app** na kuingiliana na apps nyingine. Inaweza kufanya **kila kitu ambacho app iliyowekwa inaweza kufanya**, kama kutumia mekanismo ya Inter-Process Communication (IPC) ya Android na kuingiliana na operating system inayozingatia. .\
Drozer ni zana muhimu ya **kufanya exploit kwa exported activities, exported services na Content Providers** kama utakavyojifunza katika sehemu zilizo hapa chini.

### Exploiting exported Activities

[**Soma hii ikiwa unataka kukumbusha ni nini Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Kumbuka pia kuwa code ya activity inaanza katika method ya **`onCreate`**.

**Authorisation bypass**

Wakati Activity ime-exported unaweza kuitisha skrini yake kutoka kwa app ya nje. Hivyo, ikiwa activity yenye **taarifa nyeti** ime **exported** unaweza **kupitishwa** kwa **authentication** ili kuiingia.

[**Jifunze jinsi ya kutumia exported activities na Drozer.**](drozer-tutorial/index.html#activities)

Unaweza pia kuanza exported activity kutoka adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**TAARIFA**: MobSF itatafuta kama hatari matumizi ya _**singleTask/singleInstance**_ kama `android:launchMode` katika activity, lakini kutokana na [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), inaonekana hii ni hatari tu katika toleo za zamani (API versions < 21).

> [!TIP]
> Kumbuka kwamba authorisation bypass si kila mara udhaifu, itategemea jinsi bypass inavyofanya kazi na ni taarifa gani zinafunuliwa.

**Uvujaji wa taarifa nyeti**

**Activities can also return results**. Ikiwa utafanikiwa kupata exported na isiyolindwa activity inayoita method ya **`setResult`** na **kurudisha taarifa nyeti**, kuna uvujaji wa taarifa nyeti.

#### Tapjacking

Ikiwa tapjacking haizuiziwi, unaweza kutumia exported activity kufanya **mtumiaji afanye vitendo visivyotarajiwa**. Kwa taarifa zaidi kuhusu [**nini Tapjacking fuata kiungo**](#tapjacking).

### Exploiting Content Providers - Kupata na kuhariri taarifa nyeti

[**Soma hii ikiwa unataka kukumbusha ni nini Content Provider.**](android-applications-basics.md#content-provider)\
Content providers kwa msingi hutumika kushiriki data. Ikiwa app ina content providers zinazopatikana unaweza kuwa na uwezo wa kutoa data nyeti kutoka kwazo. Pia ni muhimu kujaribu SQL injections na Path Traversals kwani zinaweza kuwa zenye udhaifu.

[**Jifunze jinsi ya exploit Content Providers na Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Soma hii ikiwa unataka kukumbusha ni nini Service.**](android-applications-basics.md#services)\
Kumbuka kwamba vitendo vya Service huanza katika method `onStartCommand`.

Service kwa msingi ni kitu ambacho kinaweza kupokea data, kui-process na kurudisha (au la) jibu. Hivyo, ikiwa application inatoa services fulani unapaswa **kagua** `code` ili kuelewa inafanya nini na kuifanyia **test** kwa **dinamiki** ili kutoa taarifa za siri, kupita hatua za uthibitishaji...\
[**Jifunze jinsi ya exploit Services na Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Soma hii ikiwa unataka kukumbusha ni nini Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Kumbuka kwamba vitendo vya Broadcast Receiver huanza katika method `onReceive`.

Broadcast receiver itakuwa inasubiri aina fulani ya ujumbe. Kulingana na jinsi receiver inavyoshughulikia ujumbe inaweza kuwa na udhaifu.\
[**Jifunze jinsi ya exploit Broadcast Receivers na Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Unaweza kutafuta deep links kwa mkono, ukitumia zana kama MobSF au scripts kama [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Unaweza **ku-fungua** scheme iliyotangazwa kwa kutumia **adb** au **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Kumbuka kwamba unaweza **kuacha jina la kifurushi** na simu itaitisha moja kwa moja app inayofaa kufungua kiungo hicho._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Msimbo unaotekelezwa**

Ili kupata **msimbo utakaoendeshwa kwenye App**, nenda kwenye activity inayoitwa na deeplink na tafuta function **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Taarifa nyeti**

Kila mara unapopata deep link hakikisha haipoki **taarifa nyeti (kama nywila) kupitia URL parameters**, kwa sababu programu nyingine yoyote inaweza **kuiga deep link na kuiba data hiyo!**

**Parameters in path**

Lazima pia ukague kama deep link yoyote inatumia parameter ndani ya path ya URL kama: `https://api.example.com/v1/users/{username}` , katika hali hiyo unaweza kulazimisha path traversal kwa kufikia kitu kama: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Kumbuka kwamba ikiwa utapata endpoints sahihi ndani ya application unaweza kusababisha **Open Redirect** (ikiwa sehemu ya path inatumika kama domain name), **account takeover** (ikiwa unaweza kubadilisha maelezo ya watumiaji bila CSRF token na endpoint yenye udhaifu ilitumia method sahihi) na udhaifu mwingine wowote. More [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Transport Layer Inspection and Verification Failures

- **Certificates hazichunguzwi kila mara kwa usahihi** na applications za Android. Ni kawaida kwa applications hizi kupuuza onyo na kukubali self-signed certificates au, wakati mwingine, kurudi kutumia HTTP connections.
- **Mizwada wakati wa SSL/TLS handshake mara nyingine huwa dhaifu**, ikitumia insecure cipher suites. Udhaifu huu unafanya connection iwe nyeti kwa man-in-the-middle (MITM) attacks, kuruhusu mashambulizi kuvunja usimbuaji wa data.
- **Leakage of private information** ni hatari wakati applications zinathibitisha kwa kutumia channels salama kisha kuwasiliana kwa channels zisizo salama kwa miamala mingine. Njia hii haifanyi ulinzi wa data nyeti, kama session cookies au maelezo ya mtumiaji, dhidi ya kupigwa mkono na wadudu.

#### Certificate Verification

Tutazingatia **certificate verification**. Uadilifu wa cheti cha server lazima uthibitishe ili kuongeza usalama. Hii ni muhimu kwa sababu misanidi miiko isiyo salama ya TLS na usafirishaji wa data nyeti kupitia channels zisizoencrypted inaweza kusababisha hatari kubwa. Kwa hatua za kina juu ya jinsi ya kuthibitisha server certificates na kutatua udhaifu, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) inatoa mwongozo kamili.

#### SSL Pinning

SSL Pinning ni hatua ya usalama ambapo application inathibitisha cheti la server dhidi ya nakala inayojulikana iliyohifadhiwa ndani ya application yenyewe. Njia hii ni muhimu kwa kuzuia MITM attacks. Inashauriwa sana kutekeleza SSL Pinning kwa applications zinazoshughulikia taarifa nyeti.

#### Traffic Inspection

Ili kuchunguza trafiki ya HTTP, inahitajika **kuuza/install cheti cha proxy tool** (mfano, Burp). Bila kuingiza cheti hiki, trafiki iliyosimbazwa inaweza isionekane kupitia proxy. Kwa mwongozo juu ya jinsi ya kuinstall custom CA certificate, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Applications zinazolenga **API Level 24 and above** zinahitaji mabadiliko kwenye Network Security Config ili kukubali CA certificate ya proxy. Hatua hii ni muhimu kwa kuchunguza trafiki iliyosimbazwa. Kwa maelekezo ya kubadilisha Network Security Config, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

Ikiwa **Flutter** inatumiwa unahitaji kufuata maagizo kwenye [**this page**](flutter.md). Hii ni kwa sababu, kuongeza cheti tu kwenye store haitafanya kazi kwani Flutter ina orodha yake ya CA halali.

#### Static detection of SSL/TLS pinning

Kabla ya kujaribu runtime bypasses, panga kwa haraka maeneo ambapo pinning inatekelezwa ndani ya APK. Ugunduzi wa static utakusaidia kupanga hooks/patches na kuzingatia code paths sahihi.

Tool: SSLPinDetect
- Open-source static-analysis utility inayofanya decompile ya APK hadi Smali (kupitia apktool) na kuchunguza patterns za regex zilizokusanywa za utekelezaji wa SSL/TLS pinning.
- Inaripoti file path halisi, namba ya mstari, na snippet ya code kwa kila match.
- Inafunika frameworks za kawaida na custom code paths: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, na Network Security Config XML pins.

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Matumizi
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Mifano ya kanuni za pattern (JSON)
Tumia au ongeza signatures ili kugundua mitindo ya pinning ya proprietary/custom. Unaweza kupakia JSON yako mwenyewe na kukagua kwa wingi.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Vidokezo na ushauri
- Usaka wa haraka kwenye apps kubwa kupitia multi-threading na memory-mapped I/O; pre-compiled regex hupunguza mzigo na false positives.
- Mkusanyiko wa patterni: https://github.com/aancw/smali-sslpin-patterns
- Lengo la utambuzi la kawaida kwa triage inayofuata:
- OkHttp: matumizi ya CertificatePinner, setCertificatePinner, marejeo ya package okhttp3/okhttp
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Declarative pins katika res/xml network security config na marejeo kwenye manifest
- Tumia maeneo yaliyopatikana kupanga Frida hooks, static patches, au mapitio ya config kabla ya dynamic testing.



#### Kuepuka SSL Pinning

Wakati SSL Pinning imetekelezwa, kuepuka kunakuwa muhimu ili kuchunguza trafiki ya HTTPS. Mbinu mbalimbali zinapatikana kwa madhumuni haya:

- Automatically **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Faida kuu ya chaguo hili ni kwamba huna haja ya root ili bypass the SSL Pinning, lakini utahitaji kufuta application na kuiweka upya, na hii haitafanya kazi kila wakati.
- Unaweza kutumia **Frida** (discussed below) ku-bypass protection hii. Hapa kuna mwongozo wa kutumia Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Unaweza pia kujaribu **automatically bypass SSL Pinning** using [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Unaweza pia kujaribu **automatically bypass SSL Pinning** using **MobSF dynamic analysis** (explained below)
- Ikiwa bado unadhani kuna trafiki ambayo hauikamata unaweza kujaribu **forward the traffic to burp using iptables**. Soma blogu hii: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Kutafuta Web Vulnerabilities za Kawaida

Ni muhimu pia kutafuta web vulnerabilities za kawaida ndani ya application. Taarifa za kina kuhusu kutambua na kupunguza vulnerabilities hizi ziko nje ya muhtasari huu lakini zimeelezewa kwa undani mahali pengine.

### Frida

[Frida](https://www.frida.re) ni dynamic instrumentation toolkit kwa developers, reverse-engineers, na security researchers.\
**Unaweza kufikia application inayoendesha na hook methods wakati wa run time kubadilisha tabia, kubadilisha thamani, kutoa thamani, kuendesha code tofauti...**\
Kama unataka pentest Android applications lazima ujue jinsi ya kutumia Frida.

- Jifunze jinsi ya kutumia Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Baadhi ya "GUI" kwa vitendo na Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection ni nzuri kuendesha Frida kiotomatiki: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Unaweza kupata baadhi ya Awesome Frida scripts hapa: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Jaribu bypass anti-debugging / anti-frida mechanisms kwa kuendesha Frida kama ilivyoonyeshwa katika [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

Angalia kama application inahifadhi taarifa nyeti ndani ya memory ambazo haipaswi kuhifadhi kama passwords au mnemonics.

Kutumia [**Fridump3**](https://github.com/rootbsd/fridump3) unaweza dump memory ya app na:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Hii itafanya dump ya memory kwenye folda ./dump, na huko unaweza grep kwa kitu kama:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Data nyeti katika Keystore**

Katika Android Keystore ni mahali bora kuhifadhi data nyeti, hata hivyo, kwa ruhusa za kutosha bado ni **inawezekana kuifikia**. Kwa kuwa programu huwa zinaweka hapa **data nyeti kwa maandishi wazi**, pentests zinapaswa kuikagua kwa mtumiaji root au mtu mwenye ufikiaji wa kimwili kwa kifaa ambaye anaweza kuiba data hii.

Hata kama app imehifadhi data katika Keystore, data inapaswa kuwa imesimbwa.

To access the data inside the keystore you could use this Frida script: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Kwa kutumia Frida script ifuatayo inaweza kuwa inawezekana **bypass fingerprint authentication** ambayo programu za Android zinaweza kufanyia ili **kulinda maeneo nyeti fulani:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Picha za Mandharinyuma**

Unapoweka app kwa mandharinyuma, Android huhifadhi **snapshot ya app** ili inaporejeshwa kwenye foreground inaanza kupakia picha kabla ya app, hivyo inaonekana kama app ilifunguliwa haraka zaidi.

Hata hivyo, ikiwa snapshot hii ina **taarifa nyeti**, mtu mwenye ufikiaji wa snapshot anaweza **kuiba taarifa hiyo** (kumbuka: unahitaji root ili kuifikia).

Snapshots kawaida huhifadhiwa katika: **`/data/system_ce/0/snapshots`**

Android inatoa njia ya **kuzuia kuchukuliwa kwa screenshot kwa kuweka parameter ya layout FLAG_SECURE**. Kwa kutumia flag hii, maudhui ya window yanachukuliwa kuwa salama, zikizuia kuonekana kwenye screenshots au kutazamwa kwenye displays zisizo salama.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Zana hii inaweza kukusaidia kusimamia zana mbalimbali wakati wa dynamic analysis: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Waundaji mara nyingi huunda proxy components kama activities, services, na broadcast receivers vinavyoshughulikia Intents hizi na kuzipitisha kwa methods kama `startActivity(...)` au `sendBroadcast(...)`, jambo ambalo linaweza kuwa hatari.

Hatari iko katika kuruhusu washambuliaji kuzindua non-exported app components au kupata access kwa sensitive content providers kwa kumrudisha Intents hizi kwa njia isiyo sahihi. Mfano mmoja ni component ya `WebView` inayobadilisha URLs kuwa `Intent` objects kupitia `Intent.parseUri(...)` kisha kuvitekeleza, jambo ambalo linaweza kusababisha malicious Intent injections.

### Essential Takeaways

- **Intent Injection** ni sawa na Open Redirect ya web.
- Exploits zinahusisha kupitisha `Intent` objects kama extras, ambazo zinaweza kurekebishwa ili kutekeleza operesheni zisizokuwa salama.
- Inaweza kufichua non-exported components na content providers kwa washambuliaji.
- Mabadiliko ya URL hadi `Intent` katika `WebView` yanaweza kuwezesha vitendo visivyokusudiwa.

### Android Client Side Injections and others

Huenda unajua aina hizi za vulnerabilities kutoka kwa Web. Lazima uwe makini sana na vulnerabilities hizi katika Android application:

- **SQL Injection:** Unaposhughulika na dynamic queries au Content-Providers hakikisha unatumia parameterized queries.
- **JavaScript Injection (XSS):** Hakikisha JavaScript na Plugin support zimezimwa kwa WebViews zote (zimelizwa kwa default). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews zinapaswa kutopewa access kwenye file system (zinaamilishwa kwa default) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: Katika matukio kadhaa wakati android application inamaliza session cookie haifutwi au inaweza hata kuokolewa kwenye disk
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Uchambuzi wa Kiotomatiki

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Uchambuzi statiki**

![](<../../images/image (866).png>)

**Tathmini ya vulnerabilities ya application** kwa kutumia frontend nzuri ya web. Unaweza pia kufanya dynamic analysis (lakini unahitaji kuandaa mazingira).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Tafadhali kumbuka kwamba MobSF inaweza kuchambua **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Pia, ikiwa utaunda faili ya **ZIP** yenye source code ya app ya **Android** au **IOS** (enda kwenye root folder ya application, chagua kila kitu na tengeneza ZIPfile), itakuwa inayo uwezo wa kuichambua pia.

MobSF pia inakuwezesha kufanya **diff/Compare** analysis na kuingiza **VirusTotal** (utahitaji kuweka API key yako katika _MobSF/settings.py_ na kuiwezesha: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). Unaweza pia kuweka `VT_UPLOAD` kuwa `False`, basi **hash** itakuwa **upload** badala ya faili.

### Iliyosaidiwa Dynamic analysis na MobSF

**MobSF** pia inaweza kuwa msaada mkubwa kwa **dynamic analysis** kwenye **Android**, lakini katika kesi hiyo utahitaji kusanidi MobSF na **genymotion** kwenye host yako (a **VM** or **Docker** won't work). _Kumbuka: Unahitaji **kuanza kwanza a VM in genymotion** na **kisha MobSF.**_\ 
The **MobSF dynamic analyser** inaweza:

- **Dump application data** (URLs, logs, clipboard, screenshots ulizotamka mwenyewe, screenshots zilizofanywa na "**Exported Activity Tester**", emails, SQLite databases, XML files, na faili nyingine zilizoundwa). Haya yote hufanyika kwa kiotomatiki isipokuwa screenshots; lazima ubofye unapotaka screenshot au ubofye "**Exported Activity Tester**" ili kupata screenshots za exported activities zote.
- Kukamata **HTTPS traffic**
- Tumia **Frida** kupata **runtime** **information**

Kuanzia **android** **versions > 5**, itatazama **automatically start Frida** na itaweka global **proxy** settings ili **capture** traffic. It itakamata traffic tu kutoka kwa tested application.

**Frida**

Kwa chaguo-msingi, itatumia baadhi ya **Frida Scripts** ili **bypass SSL pinning**, **root detection** na **debugger detection** na **monitor interesting APIs**.\
MobSF pia inaweza **invoke exported activities**, kupiga **screenshots** zao na **save** kwa ajili ya ripoti.

Ili **start** dynamic testing bonyeza kitufe cha kijani: "**Start Instrumentation**". Bonyeza "**Frida Live Logs**" kuona logs zinazozalishwa na Frida scripts na "**Live API Monitor**" kuona invocation zote za hooked methods, arguments passed na returned values (hii itaonekana baada ya kubonyeza "Start Instrumentation").\
MobSF pia inakuwezesha ku-load **Frida scripts** zako mwenyewe (kutuma matokeo ya Frida scripts zako kwa MobSF tumia function `send()`). Pia ina **several pre-written scripts** unazoweza ku-load (unaweza kuongeza zaidi katika `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), chagua tu, bonyeza "**Load**" na bonyeza "**Start Instrumentation**" (utaweza kuona logs za scripts hizo ndani ya "**Frida Live Logs**").

![](<../../images/image (419).png>)

Zaidi ya hayo, kuna baadhi ya Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: Itataja classes zote zilizopakiwa
- **Capture Strings**: Itaonyesha strings zote zinazopatikana wakati wa kutumia application (sana noisy)
- **Capture String Comparisons**: Inaweza kuwa ya msaada mkubwa. Itataja **the 2 strings being compared** na kama matokeo yalikuwa True au False.
- **Enumerate Class Methods**: Weka class name (kama "java.io.File") na itaonyesha methods zote za class.
- **Search Class Pattern**: Tafuta classes kwa pattern
- **Trace Class Methods**: **Trace** class nzima (ona inputs na outputs za methods zote za class). Kumbuka kwamba kwa default MobSF traces several interesting Android Api methods.

Mara utakapochagua module ya ziada unayotaka kutumia unahitaji kubonyeza "**Start Intrumentation**" na utaona outputs zote ndani ya "**Frida Live Logs**".

**Shell**

MobSF pia inakuja na shell yenye baadhi ya **adb** commands, **MobSF commands**, na common **shell** **commands** chini ya ukurasa wa dynamic analysis. Baadhi ya commands za kuvutia:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**Zana za HTTP**

Wakati traffic ya HTTP inakamatwa unaweza kuona mtazamo mbaya wa traffic iliyokamatwa kwenye kitufe cha "**HTTP(S) Traffic**" au mtazamo mzuri kwenye kitufe cha kijani cha "**Start HTTPTools**". Kutoka kwenye chaguo la pili, unaweza **kutuma** **maombi yaliyokamatwa** kwa **proxies** kama Burp au Owasp ZAP.\
Ili kufanya hivyo, _washa Burp -->_ _zima Intercept --> katika MobSB HTTPTools chagua request_ --> bonyeza "**Send to Fuzzer**" --> _chagua anwani ya proxy_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Mara utakapo maliza dynamic analysis na MobSF unaweza kubonyeza "**Start Web API Fuzzer**" ili **fuzz http requests** na kutafuta vulnerabilities.

> [!TIP]
> Baada ya kufanya dynamic analysis na MobSF mipangilio ya proxy inaweza kuwa imepangwa vibaya na hutaweza kuirekebisha kutoka GUI. Unaweza kurekebisha mipangilio ya proxy kwa kufanya:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

Unaweza kupata zana kutoka [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Zana hii itatumia baadhi ya **Hooks** kukujulisha **ni nini kinatokea katika application** wakati unafanya **dynamic analysis**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Hii ni zana nzuri ya kufanya **static analysis** kwa GUI

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Zana hii imeundwa kutafuta tofauti za **security related Android application vulnerabilities**, ama kwenye **source code** au **packaged APKs**. Zana pia ina uwezo wa **kuzalisha APK ya "Proof-of-Concept" inayoweza ku-deploy** na **ADB commands**, ili ku-exploit baadhi ya vulnerabilities zilizopatikana (Exposed activities, intents, tapjacking...). Kama ilivyo kwa Drozer, hakuna haja ya ku-root kifaa cha mtihani.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Inaonyesha faili zote zilizotolewa kwa marejeleo rahisi
- Ina-decompile faili za APK kwa otomatiki hadi muundo wa Java na Smali
- Inachambua AndroidManifest.xml kwa udhaifu wa kawaida na tabia
- Static source code analysis kwa ajili ya udhaifu wa kawaida na tabia
- Taarifa za kifaa
- na zaidi
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER ni programu ya mstari wa amri inayoweza kutumiwa kwenye Windows, MacOS X na Linux, ambayo inachambua faili za _.apk_ kwa ajili ya kutafuta udhaifu. Hufanya hivyo kwa kukunja APKs na kutekeleza mfululizo wa sheria ili kugundua udhaifu.

Sheria zote ziko katika faili `rules.json`, na kila kampuni au mjaribu anaweza kuunda sheria zake ili kuchambua wanachohitaji.

Pakua binaries za hivi karibuni kutoka kwenye [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn ni zana **inayofanya kazi kwenye majukwaa mbalimbali** inayowawezesha waendelezaji, bugbounty hunters na ethical hackers kufanya [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) kwenye programu za simu.

Dhana ni kwamba unavuta na kuachilia faili ya programu yako ya simu (faili ya .apk au .ipa) kwenye programu ya StaCoAn, na itatengeneza ripoti ya kuona inayobebeka kwa ajili yako. Unaweza kubadilisha mipangilio na wordlists ili kupata uzoefu uliobinafsishwa.

Pakua [latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework ni mfumo wa uchambuzi wa udhaifu wa Android unaosaidia waendelezaji au hackers kupata udhaifu wa usalama unaowezekana katika programu za Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** ni zana ambayo lengo kuu ni kugundua na kuwaonya mtumiaji kuhusu tabia zinazoweza kuharibu zinazotengenezwa na programu ya Android.

Uchunguzi unafanywa kwa **static analysis** ya Dalvik bytecode ya programu, inayowakilishwa kama **Smali**, kwa kutumia maktaba ya [`androguard`](https://github.com/androguard/androguard).

Zana hii inatafuta **tabia za kawaida za programu "mbaya"** kama: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. Ni chombo kinachoiweka pamoja zana zinazotumika mara kwa mara za mobile application reverse engineering na analysis, kusaidia katika kupima mobile applications dhidi ya vitisho vya usalama vya OWASP. Lengo lake ni kufanya kazi hii iwe rahisi na rafiki kwa watengenezaji wa mobile applications na wataalamu wa usalama.

Inaweza:

- Extract Java and Smali code using different tools
- Analyze APKs using: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Extract private information from the APK using regexps.
- Analyze the Manifest.
- Analyze found domains using: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Useful to detect malware: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Kumbuka kwamba, kulingana na huduma na usanidi unayotumia kuobfuscate msimbo, Secrets zinaweza au zisiwe zimeobfuscated.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. Ina uwezo wa kuboresha bytecode pamoja na kugundua na kuondoa maagizo yasiyotumika. ProGuard ni programu ya bure na inasambazwa chini ya GNU General Public License, version 2.

ProGuard inasambazwa kama sehemu ya Android SDK na inafanya kazi wakati wa kujenga application katika release mode.

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(Kutoka kwenye mwongozo huo) Mara ya mwisho tulipokagua, Dexguard mode of operation ilikuwa:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

Unaweza kupakia APK iliyobfuscated kwenye platform yao.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

It is a **generic android deobfuscator.** Simplify **virtually executes an app** to understand its behavior and then **tries to optimize the code** so it behaves identically but is easier for a human to understand. Each optimization type is simple and generic, so it doesn't matter what the specific type of obfuscation is used.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD gives you information about **how an APK was made**. It identifies many **compilers**, **packers**, **obfuscators**, and other weird stuff. It's [_PEiD_](https://www.aldeid.com/wiki/PEiD) for Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b ni mashine pepe ya usalama ya Android (Android security virtual machine) inayotokana na ubuntu-mate na inajumuisha mkusanyiko wa frameworks, tutorials na labs za kisasa kutoka kwa wapendaji wa usalama na watafiti mbalimbali kwa ajili ya reverse engineering na malware analysis.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Ni orodha nzuri ya rasilimali
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
