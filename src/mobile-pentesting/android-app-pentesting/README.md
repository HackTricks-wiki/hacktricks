# Android Applications Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android Applications Basics

यह पृष्ठ पढ़ना अत्यधिक अनुशंसित है ताकि आप **Android सुरक्षा से संबंधित सबसे महत्वपूर्ण भागों और एक Android एप्लिकेशन में सबसे खतरनाक घटकों** के बारे में जान सकें:

{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

यह मुख्य उपकरण है जिसकी आपको एक Android डिवाइस (अनुकरणीय या भौतिक) से कनेक्ट करने की आवश्यकता है।\
**ADB** आपको **USB** या **Network** के माध्यम से कंप्यूटर से उपकरणों को नियंत्रित करने की अनुमति देता है। यह उपयोगिता **फाइलों** की दोनों दिशाओं में **कॉपी**, **ऐप्स** की **स्थापना** और **अनइंस्टॉलेशन**, **शेल कमांड्स** का **निष्पादन**, **डेटा** का **बैकअप**, **लॉग्स** को **पढ़ने** जैसी अन्य कार्यों को सक्षम बनाती है।

ADB का उपयोग कैसे करें, यह जानने के लिए [**ADB Commands**](adb-commands.md) की निम्नलिखित सूची पर एक नज़र डालें।

## Smali

कभी-कभी **छिपी हुई जानकारी** (शायद अच्छी तरह से ओबफस्केटेड पासवर्ड या फ्लैग) तक पहुँचने के लिए **एप्लिकेशन कोड को संशोधित करना** दिलचस्प होता है। फिर, APK को डिकंपाइल करना, कोड को संशोधित करना और इसे फिर से संकलित करना दिलचस्प हो सकता है।\
[**इस ट्यूटोरियल में** आप **APK को डिकंपाइल करना, Smali कोड को संशोधित करना और नए कार्यक्षमता के साथ APK को फिर से संकलित करना** सीख सकते हैं](smali-changes.md)। यह **गतिशील विश्लेषण** के दौरान कई परीक्षणों के लिए एक **वैकल्पिक** के रूप में बहुत उपयोगी हो सकता है जो प्रस्तुत किए जाने वाले हैं। फिर, **इस संभावना को हमेशा ध्यान में रखें**।

## Other interesting tricks

- [Play Store में अपनी स्थिति को स्पूफ करना](spoofing-your-location-in-play-store.md)
- **APK डाउनलोड करें**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Extract APK from device:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- सभी स्प्लिट और बेस एपीके को [APKEditor](https://github.com/REAndroid/APKEditor) के साथ मिलाएं:
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Static Analysis

सबसे पहले, एक APK का विश्लेषण करने के लिए आपको **decompiler** का उपयोग करके **Java कोड** पर एक नज़र डालनी चाहिए।\
कृपया, [**विभिन्न उपलब्ध decompilers के बारे में जानकारी के लिए यहाँ पढ़ें**](apk-decompilers.md).

### Looking for interesting Info

APK के **strings** पर एक नज़र डालकर आप **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** और कुछ भी दिलचस्प खोज सकते हैं... यहां तक कि कोड निष्पादन **backdoors** या प्रमाणीकरण backdoors (ऐप के लिए हार्डकोडेड व्यवस्थापक क्रेडेंशियल) के लिए भी देखें।

**Firebase**

**firebase URLs** पर विशेष ध्यान दें और जांचें कि क्या यह गलत तरीके से कॉन्फ़िगर किया गया है। [यहाँ FIrebase के बारे में अधिक जानकारी और इसे कैसे शोषण करें।](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Basic understanding of the application - Manifest.xml, strings.xml

**एक एप्लिकेशन के \_Manifest.xml**_\*\* और \*\*_**strings.xml**\_\*\* फ़ाइलों की जांच संभावित सुरक्षा कमजोरियों को उजागर कर सकती है\*\*. इन फ़ाइलों को decompilers का उपयोग करके या APK फ़ाइल एक्सटेंशन को .zip में बदलकर और फिर इसे अनज़िप करके एक्सेस किया जा सकता है।

**Manifest.xml** से पहचानी गई **Vulnerabilities** में शामिल हैं:

- **Debuggable Applications**: _Manifest.xml_ फ़ाइल में `debuggable="true"` के रूप में सेट की गई एप्लिकेशन जोखिम पैदा करती हैं क्योंकि वे ऐसे कनेक्शन की अनुमति देती हैं जो शोषण की ओर ले जा सकते हैं। डिबग करने योग्य एप्लिकेशन को शोषित करने के तरीके को समझने के लिए, एक ट्यूटोरियल देखें जिसमें डिवाइस पर डिबग करने योग्य एप्लिकेशन को खोजने और शोषित करने के बारे में बताया गया है।
- **Backup Settings**: संवेदनशील जानकारी से निपटने वाले एप्लिकेशनों के लिए `android:allowBackup="false"` विशेष रूप से सेट किया जाना चाहिए ताकि adb के माध्यम से अनधिकृत डेटा बैकअप को रोका जा सके, विशेष रूप से जब usb debugging सक्षम हो।
- **Network Security**: _res/xml/_ में कस्टम नेटवर्क सुरक्षा कॉन्फ़िगरेशन (`android:networkSecurityConfig="@xml/network_security_config"`) सुरक्षा विवरण जैसे प्रमाणपत्र पिन और HTTP ट्रैफ़िक सेटिंग्स को निर्दिष्ट कर सकते हैं। एक उदाहरण विशेष डोमेन के लिए HTTP ट्रैफ़िक की अनुमति देना है।
- **Exported Activities and Services**: मैनिफेस्ट में निर्यातित गतिविधियों और सेवाओं की पहचान करना उन घटकों को उजागर कर सकता है जिन्हें दुरुपयोग किया जा सकता है। गतिशील परीक्षण के दौरान आगे के विश्लेषण से यह पता चल सकता है कि इन घटकों का शोषण कैसे किया जाए।
- **Content Providers and FileProviders**: उजागर सामग्री प्रदाता अनधिकृत पहुंच या डेटा में संशोधन की अनुमति दे सकते हैं। FileProviders की कॉन्फ़िगरेशन की भी जांच की जानी चाहिए।
- **Broadcast Receivers and URL Schemes**: ये घटक शोषण के लिए उपयोग किए जा सकते हैं, विशेष रूप से इनपुट कमजोरियों के लिए URL योजनाओं के प्रबंधन के तरीके पर ध्यान दिया जाना चाहिए।
- **SDK Versions**: `minSdkVersion`, `targetSDKVersion`, और `maxSdkVersion` विशेषताएँ समर्थित Android संस्करणों को इंगित करती हैं, सुरक्षा कारणों से पुराने, कमजोर Android संस्करणों का समर्थन न करने के महत्व को उजागर करती हैं।

**strings.xml** फ़ाइल से संवेदनशील जानकारी जैसे API keys, कस्टम स्कीमा, और अन्य डेवलपर नोट्स का पता लगाया जा सकता है, जो इन संसाधनों की सावधानीपूर्वक समीक्षा की आवश्यकता को उजागर करता है।

### Tapjacking

**Tapjacking** एक हमला है जहां एक **malicious** **application** लॉन्च किया जाता है और **एक पीड़ित एप्लिकेशन के शीर्ष पर खुद को रखता है**। जब यह पीड़ित ऐप को दृश्यमान रूप से अस्पष्ट करता है, तो इसका उपयोगकर्ता इंटरफ़ेस इस तरह से डिज़ाइन किया गया है कि उपयोगकर्ता को इसके साथ बातचीत करने के लिए धोखा दिया जाए, जबकि यह बातचीत को पीड़ित ऐप के पास भेज रहा है।\
प्रभाव में, यह **उपयोगकर्ता को यह जानने से अंधा कर रहा है कि वे वास्तव में पीड़ित ऐप पर क्रियाएँ कर रहे हैं**।

अधिक जानकारी प्राप्त करें:

{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

एक **activity** जिसमें **`launchMode`** **`singleTask`** पर सेट है और कोई `taskAffinity` परिभाषित नहीं है, कार्य हाइजैकिंग के लिए संवेदनशील है। इसका मतलब है कि एक **application** स्थापित की जा सकती है और यदि इसे वास्तविक एप्लिकेशन से पहले लॉन्च किया जाता है, तो यह **वास्तविक एप्लिकेशन के कार्य को हाइजैक कर सकती है** (इसलिए उपयोगकर्ता **malicious application** के साथ बातचीत कर रहा होगा, सोचते हुए कि वह असली का उपयोग कर रहा है)।

अधिक जानकारी में:

{{#ref}}
android-task-hijacking.md
{{#endref}}

### Insecure data storage

**Internal Storage**

Android में, फ़ाइलें **internal** storage में **stored** की जाती हैं ताकि वे केवल उस **app** द्वारा **accessible** हों जिसने उन्हें **created** किया है। यह सुरक्षा उपाय Android ऑपरेटिंग सिस्टम द्वारा **enforced** किया गया है और सामान्यतः अधिकांश एप्लिकेशनों की सुरक्षा आवश्यकताओं के लिए पर्याप्त है। हालाँकि, डेवलपर्स कभी-कभी `MODE_WORLD_READABLE` और `MODE_WORLD_WRITABLE` जैसे मोड का उपयोग करते हैं ताकि फ़ाइलों को विभिन्न एप्लिकेशनों के बीच **shared** किया जा सके। फिर भी, ये मोड अन्य एप्लिकेशनों द्वारा इन फ़ाइलों तक पहुँच को **restrict** नहीं करते हैं, जिसमें संभावित रूप से दुर्भावनापूर्ण एप्लिकेशन भी शामिल हैं।

1. **Static Analysis:**
- **Ensure** करें कि `MODE_WORLD_READABLE` और `MODE_WORLD_WRITABLE` का उपयोग **carefully scrutinized** किया गया है। ये मोड फ़ाइलों को **unintended या unauthorized access** के लिए **potentially expose** कर सकते हैं।
2. **Dynamic Analysis:**
- ऐप द्वारा बनाई गई फ़ाइलों पर सेट की गई **permissions** की **verify** करें। विशेष रूप से, **check** करें कि क्या कोई फ़ाइलें **विश्व स्तर पर पढ़ने या लिखने के लिए सेट की गई हैं**। यह एक महत्वपूर्ण सुरक्षा जोखिम पैदा कर सकता है, क्योंकि यह **किसी भी एप्लिकेशन** को जो डिवाइस पर स्थापित है, उसकी उत्पत्ति या इरादे की परवाह किए बिना, इन फ़ाइलों को **read या modify** करने की अनुमति देगा।

**External Storage**

**External storage** पर फ़ाइलों से निपटने के दौरान, कुछ सावधानियाँ बरतनी चाहिए:

1. **Accessibility**:
- बाहरी संग्रहण पर फ़ाइलें **globally readable और writable** होती हैं। इसका मतलब है कि कोई भी एप्लिकेशन या उपयोगकर्ता इन फ़ाइलों तक पहुँच सकता है।
2. **Security Concerns**:
- पहुँच की आसानी को देखते हुए, **संवेदनशील जानकारी** को बाहरी संग्रहण पर **store** न करने की सलाह दी जाती है।
- बाहरी संग्रहण को किसी भी एप्लिकेशन द्वारा हटाया या एक्सेस किया जा सकता है, जिससे यह कम सुरक्षित हो जाता है।
3. **Handling Data from External Storage**:
- हमेशा बाहरी संग्रहण से प्राप्त डेटा पर **input validation** करें। यह महत्वपूर्ण है क्योंकि डेटा एक अविश्वसनीय स्रोत से है।
- बाहरी संग्रहण पर executable या class फ़ाइलों को गतिशील लोडिंग के लिए **store** करना दृढ़ता से हतोत्साहित किया जाता है।
- यदि आपके एप्लिकेशन को बाहरी संग्रहण से executable फ़ाइलें प्राप्त करनी हैं, तो सुनिश्चित करें कि ये फ़ाइलें **signed और cryptographically verified** हैं इससे पहले कि उन्हें गतिशील रूप से लोड किया जाए। यह आपके एप्लिकेशन की सुरक्षा अखंडता बनाए रखने के लिए महत्वपूर्ण है।

बाहरी संग्रहण को `/storage/emulated/0`, `/sdcard`, `/mnt/sdcard` में **access** किया जा सकता है।

> [!NOTE]
> Android 4.4 (**API 17**) से शुरू होकर, SD कार्ड में एक निर्देशिका संरचना है जो **एक ऐप से उस ऐप के लिए विशेष रूप से निर्देशिका तक पहुँच को सीमित करती है**। यह दुर्भावनापूर्ण एप्लिकेशन को किसी अन्य ऐप की फ़ाइलों को पढ़ने या लिखने की अनुमति नहीं देता है।

**Sensitive data stored in clear-text**

- **Shared preferences**: Android प्रत्येक एप्लिकेशन को `/data/data/<packagename>/shared_prefs/` पथ में xml फ़ाइलें आसानी से सहेजने की अनुमति देता है और कभी-कभी उस फ़ोल्डर में स्पष्ट पाठ में संवेदनशील जानकारी मिल सकती है।
- **Databases**: Android प्रत्येक एप्लिकेशन को `/data/data/<packagename>/databases/` पथ में sqlite डेटाबेस को आसानी से सहेजने की अनुमति देता है और कभी-कभी उस फ़ोल्डर में स्पष्ट पाठ में संवेदनशील जानकारी मिल सकती है।

### Broken TLS

**Accept All Certificates**

किसी कारण से कभी-कभी डेवलपर्स सभी प्रमाणपत्रों को स्वीकार करते हैं, भले ही उदाहरण के लिए होस्टनाम कोड की निम्नलिखित पंक्तियों के साथ मेल न खाता हो:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
एक अच्छा तरीका यह परीक्षण करने का है कि आप किसी प्रॉक्सी जैसे Burp का उपयोग करके ट्रैफ़िक कैप्चर करने की कोशिश करें बिना डिवाइस के अंदर Burp CA को अधिकृत किए। इसके अलावा, आप Burp के साथ एक अलग होस्टनाम के लिए एक प्रमाणपत्र उत्पन्न कर सकते हैं और इसका उपयोग कर सकते हैं।

### टूटी हुई क्रिप्टोग्राफी

**खराब कुंजी प्रबंधन प्रक्रियाएँ**

कुछ डेवलपर्स संवेदनशील डेटा को स्थानीय संग्रहण में सहेजते हैं और इसे कोड में हार्डकोडेड/पूर्वानुमानित कुंजी के साथ एन्क्रिप्ट करते हैं। ऐसा नहीं किया जाना चाहिए क्योंकि कुछ रिवर्सिंग हमलावरों को गोपनीय जानकारी निकालने की अनुमति दे सकती है।

**असुरक्षित और/या अप्रचलित एल्गोरिदम का उपयोग**

डेवलपर्स को **अप्रचलित एल्गोरिदम** का उपयोग करके प्राधिकरण **जांच**, **डेटा सहेजने** या **भेजने** से बचना चाहिए। इनमें से कुछ एल्गोरिदम हैं: RC4, MD4, MD5, SHA1... यदि **हैश** का उपयोग पासवर्ड को सहेजने के लिए किया जाता है, तो हैश ब्रूट-फोर्स **प्रतिरोधी** होना चाहिए और नमक के साथ होना चाहिए।

### अन्य जांचें

- यह अनुशंसा की जाती है कि **APK को ओबफस्केट** किया जाए ताकि हमलावरों के लिए रिवर्स इंजीनियरिंग का कार्य कठिन हो सके।
- यदि ऐप संवेदनशील है (जैसे बैंक ऐप), तो इसे **जांच करनी चाहिए कि मोबाइल रूटेड है** और इसके अनुसार कार्य करना चाहिए।
- यदि ऐप संवेदनशील है (जैसे बैंक ऐप), तो इसे जांच करनी चाहिए कि क्या **इम्यूलेटर** का उपयोग किया जा रहा है।
- यदि ऐप संवेदनशील है (जैसे बैंक ऐप), तो इसे **कार्यक्रम को निष्पादित करने से पहले अपनी अखंडता की जांच करनी चाहिए** कि क्या इसे संशोधित किया गया है।
- [**APKiD**](https://github.com/rednaga/APKiD) का उपयोग करें यह जांचने के लिए कि APK बनाने के लिए कौन सा कंपाइलर/पैकर/ओबफस्केटर का उपयोग किया गया था।

### रिएक्ट नेटिव एप्लिकेशन

रिएक्ट एप्लिकेशनों के जावास्क्रिप्ट कोड तक आसानी से पहुँचने के लिए निम्नलिखित पृष्ठ पढ़ें:

{{#ref}}
react-native-application.md
{{#endref}}

### ज़ामरिन एप्लिकेशन

ज़ामरिन एप्लिकेशनों के C# कोड तक आसानी से पहुँचने के लिए निम्नलिखित पृष्ठ पढ़ें:

{{#ref}}
../xamarin-apps.md
{{#endref}}

### सुपरपैक्ड एप्लिकेशन

इस [**ब्लॉग पोस्ट**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) के अनुसार सुपरपैक्ड एक मेटा एल्गोरिदम है जो एक एप्लिकेशन की सामग्री को एकल फ़ाइल में संकुचित करता है। ब्लॉग इस संभावना के बारे में बात करता है कि एक ऐप बनाया जा सकता है जो इन प्रकार के ऐप्स को अनसंकुचित करता है... और एक तेज़ तरीका जो एप्लिकेशन को **निष्पादित करने और फ़ाइल सिस्टम से अनसंकुचित फ़ाइलों को इकट्ठा करने** में शामिल है।

### स्वचालित स्थैतिक कोड विश्लेषण

उपकरण [**mariana-trench**](https://github.com/facebook/mariana-trench) **कोड** के **स्कैनिंग** द्वारा **कमजोरियों** को खोजने में सक्षम है। यह उपकरण **ज्ञात स्रोतों** की एक श्रृंखला को शामिल करता है (जो उपकरण को **जगहें** बताता है जहाँ **इनपुट** **उपयोगकर्ता द्वारा नियंत्रित** है), **सिंक** (जो उपकरण को **खतरनाक** **जगहें** बताता है जहाँ दुर्भावनापूर्ण उपयोगकर्ता इनपुट नुकसान पहुंचा सकता है) और **नियम**। ये नियम **स्रोत-सिंक** के **संयोग** को इंगित करते हैं जो एक कमजोरी को इंगित करते हैं।

इस ज्ञान के साथ, **mariana-trench कोड की समीक्षा करेगा और इसमें संभावित कमजोरियों को खोजेगा**।

### लीक हुए रहस्य

एक एप्लिकेशन में रहस्य (API कुंजी, पासवर्ड, छिपे हुए यूआरएल, उपडोमेन...) हो सकते हैं जिन्हें आप खोजने में सक्षम हो सकते हैं। आप एक उपकरण का उपयोग कर सकते हैं जैसे [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### बायपास बायोमेट्रिक प्रमाणीकरण

{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### अन्य दिलचस्प कार्य

- **कोड निष्पादन**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **SMS भेजें**: `sendTextMessage, sendMultipartTestMessage`
- **घरेलू कार्य** घोषित किए गए हैं `native`: `public native, System.loadLibrary, System.load`
- [यह पढ़ें **कैसे रिवर्स करें घरेलू कार्य**](reversing-native-libraries.md)

### **अन्य तरकीबें**

{{#ref}}
content-protocol.md
{{#endref}}

---

---

## गतिशील विश्लेषण

> सबसे पहले, आपको एक ऐसा वातावरण चाहिए जहाँ आप एप्लिकेशन और सभी वातावरण (Burp CA प्रमाणपत्र, Drozer और Frida मुख्य रूप से) स्थापित कर सकें। इसलिए, एक रूटेड डिवाइस (अनुकरणीय या नहीं) अत्यधिक अनुशंसित है।

### ऑनलाइन गतिशील विश्लेषण

आप [https://appetize.io/](https://appetize.io) पर एक **मुफ्त खाता** बना सकते हैं। यह प्लेटफ़ॉर्म आपको **APK अपलोड** और **निष्पादित** करने की अनुमति देता है, इसलिए यह देखने के लिए उपयोगी है कि एक APK कैसे व्यवहार कर रहा है।

आप यहां तक कि **अपने एप्लिकेशन के लॉग** को वेब पर देख सकते हैं और **adb** के माध्यम से कनेक्ट कर सकते हैं।

![](<../../images/image (831).png>)

ADB कनेक्शन के लिए धन्यवाद, आप **Drozer** और **Frida** का उपयोग अनुकरणकर्ताओं के अंदर कर सकते हैं।

### स्थानीय गतिशील विश्लेषण

#### एक इम्यूलेटर का उपयोग करना

- [**Android Studio**](https://developer.android.com/studio) (आप **x86** और **arm** उपकरण बना सकते हैं, और [**इस** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**नवीनतम x86** संस्करण **ARM पुस्तकालयों** का समर्थन करते हैं बिना धीमे आर्म इम्यूलेटर की आवश्यकता के)।
- इसे सेट करने के लिए इस पृष्ठ पर सीखें:

{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(मुफ्त संस्करण:** व्यक्तिगत संस्करण, आपको एक खाता बनाना होगा। _यह अनुशंसा की जाती है कि **संस्करण डाउनलोड करें** **WITH**_ _**VirtualBox** संभावित त्रुटियों से बचने के लिए।_)
- [**Nox**](https://es.bignox.com) (मुफ्त, लेकिन यह Frida या Drozer का समर्थन नहीं करता)।

> [!NOTE]
> किसी भी प्लेटफ़ॉर्म पर नया इम्यूलेटर बनाते समय याद रखें कि स्क्रीन जितनी बड़ी होगी, इम्यूलेटर उतना ही धीमा चलेगा। इसलिए यदि संभव हो तो छोटे स्क्रीन का चयन करें।

Genymotion में **गूगल सेवाओं** (जैसे AppStore) को स्थापित करने के लिए, आपको निम्नलिखित छवि के लाल चिह्नित बटन पर क्लिक करना होगा:

![](<../../images/image (277).png>)

इसके अलावा, ध्यान दें कि **Genymotion में Android VM की कॉन्फ़िगरेशन** में आप **ब्रिज नेटवर्क मोड** का चयन कर सकते हैं (यह उपयोगी होगा यदि आप उपकरणों के साथ विभिन्न VM से Android VM से कनेक्ट कर रहे हैं)।

#### एक भौतिक उपकरण का उपयोग करें

आपको **डीबगिंग** विकल्पों को सक्रिय करना होगा और यदि आप इसे **रूट** कर सकते हैं तो यह अच्छा होगा:

1. **सेटिंग्स**।
2. (Android 8.0 से) **सिस्टम** का चयन करें।
3. **फोन के बारे में** का चयन करें।
4. **बिल्ड नंबर** पर 7 बार दबाएं।
5. वापस जाएं और आप **डेवलपर विकल्प** पाएंगे।

> एक बार जब आपने एप्लिकेशन स्थापित कर लिया है, तो आपको सबसे पहले इसे आजमाना चाहिए और यह जांचना चाहिए कि यह क्या करता है, यह कैसे काम करता है और इसके साथ सहज होना चाहिए।\
> मैं सुझाव दूंगा कि **इस प्रारंभिक गतिशील विश्लेषण को MobSF गतिशील विश्लेषण + pidcat का उपयोग करके करें**, ताकि हम **सीख सकें कि एप्लिकेशन कैसे काम करता है** जबकि MobSF **कई** **दिलचस्प** **डेटा** को कैप्चर करता है जिसे आप बाद में देख सकते हैं।

### अनपेक्षित डेटा लीक

**लॉगिंग**

डेवलपर्स को **डीबगिंग जानकारी** को सार्वजनिक रूप से उजागर करने के प्रति सतर्क रहना चाहिए, क्योंकि इससे संवेदनशील डेटा लीक हो सकता है। एप्लिकेशन लॉग की निगरानी के लिए उपकरण [**pidcat**](https://github.com/JakeWharton/pidcat) और `adb logcat` की सिफारिश की जाती है ताकि संवेदनशील जानकारी की पहचान और सुरक्षा की जा सके। **Pidcat** को इसके उपयोग में आसानी और पठनीयता के लिए पसंद किया जाता है।

> [!WARNING]
> ध्यान दें कि **Android 4.0 से नए संस्करणों में**, **एप्लिकेशन केवल अपने स्वयं के लॉग तक पहुँचने में सक्षम होते हैं**। इसलिए एप्लिकेशन अन्य ऐप्स के लॉग तक पहुँच नहीं सकते।\
> फिर भी, यह अनुशंसा की जाती है कि **संवेदनशील जानकारी को लॉग न करें**।

**कॉपी/पेस्ट बफर कैशिंग**

Android का **क्लिपबोर्ड-आधारित** ढांचा ऐप्स में कॉपी-पेस्ट कार्यक्षमता को सक्षम करता है, फिर भी यह एक जोखिम प्रस्तुत करता है क्योंकि **अन्य एप्लिकेशन** क्लिपबोर्ड तक **पहुँच** सकते हैं, जिससे संवेदनशील डेटा उजागर हो सकता है। यह महत्वपूर्ण है कि संवेदनशील एप्लिकेशन के अनुभागों के लिए कॉपी/पेस्ट कार्यों को **अक्षम** किया जाए, जैसे कि क्रेडिट कार्ड विवरण, डेटा लीक को रोकने के लिए।

**क्रैश लॉग**

यदि एक एप्लिकेशन **क्रैश** होता है और **लॉग्स** सहेजता है, तो ये लॉग हमलावरों की सहायता कर सकते हैं, विशेष रूप से जब एप्लिकेशन को रिवर्स-इंजीनियर नहीं किया जा सकता। इस जोखिम को कम करने के लिए, क्रैश पर लॉगिंग से बचें, और यदि लॉग को नेटवर्क के माध्यम से भेजा जाना चाहिए, तो सुनिश्चित करें कि उन्हें सुरक्षा के लिए SSL चैनल के माध्यम से भेजा जाए।

एक पेंटेस्टर के रूप में, **इन लॉग्स पर एक नज़र डालने की कोशिश करें**।

**तीसरे पक्षों को भेजा गया विश्लेषण डेटा**

एप्लिकेशन अक्सर Google Adsense जैसी सेवाओं को एकीकृत करते हैं, जो डेवलपर्स द्वारा अनुचित कार्यान्वयन के कारण अनजाने में **संवेदनशील डेटा लीक** कर सकते हैं। संभावित डेटा लीक की पहचान करने के लिए, यह सलाह दी जाती है कि **एप्लिकेशन के ट्रैफ़िक को इंटरसेप्ट करें** और देखें कि क्या कोई संवेदनशील जानकारी तीसरे पक्ष की सेवाओं को भेजी जा रही है।

### SQLite DBs

अधिकांश एप्लिकेशन **आंतरिक SQLite डेटाबेस** का उपयोग जानकारी को सहेजने के लिए करेंगे। पेंटेस्ट के दौरान, बनाए गए **डेटाबेस**, **तालिकाओं** और **स्तंभों** के नामों और सभी **डेटा** को देखें क्योंकि आप **संवेदनशील जानकारी** (जो एक कमजोरी होगी) पा सकते हैं।\
डेटाबेस `/data/data/the.package.name/databases` में स्थित होना चाहिए जैसे `/data/data/com.mwr.example.sieve/databases`

यदि डेटाबेस संवेदनशील जानकारी को सहेज रहा है और **एन्क्रिप्टेड है** लेकिन आप एप्लिकेशन के अंदर **पासवर्ड** पा सकते हैं, तो यह अभी भी एक **कमजोरी** है।

`.tables` का उपयोग करके तालिकाओं को सूचीबद्ध करें और तालिकाओं के स्तंभों को `.schema <table_name>` करके सूचीबद्ध करें।

### Drozer (एक्सप्लॉइट गतिविधियाँ, सामग्री प्रदाता और सेवाएँ)

[Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf) से: **Drozer** आपको **Android ऐप की भूमिका ग्रहण करने** और अन्य ऐप्स के साथ बातचीत करने की अनुमति देता है। यह **किसी भी चीज़ को कर सकता है जो एक स्थापित एप्लिकेशन कर सकता है**, जैसे Android के इंटर-प्रोसेस संचार (IPC) तंत्र का उपयोग करना और अंतर्निहित ऑपरेटिंग सिस्टम के साथ बातचीत करना।\
Drozer निर्यातित गतिविधियों, निर्यातित सेवाओं और सामग्री प्रदाताओं का **शोषण** करने के लिए एक उपयोगी उपकरण है जैसा कि आप अगले अनुभागों में सीखेंगे।

### निर्यातित गतिविधियों का शोषण

[**यह पढ़ें यदि आप यह ताज़ा करना चाहते हैं कि Android गतिविधि क्या है।**](android-applications-basics.md#launcher-activity-and-other-activities)\
यह भी याद रखें कि एक गतिविधि का कोड **`onCreate`** विधि में शुरू होता है।

**प्राधिकरण बायपास**

जब एक गतिविधि निर्यातित होती है, तो आप इसे एक बाहरी ऐप से उसके स्क्रीन को आमंत्रित कर सकते हैं। इसलिए, यदि एक गतिविधि जिसमें **संवेदनशील जानकारी** है **निर्यातित** है, तो आप **प्रमाणीकरण** तंत्र को **बायपास** कर सकते हैं **इस तक पहुँचने के लिए।**

[**Drozer के साथ निर्यातित गतिविधियों का शोषण कैसे करें, यह जानें।**](drozer-tutorial/#activities)

आप adb से एक निर्यातित गतिविधि भी शुरू कर सकते हैं:

- पैकेज नाम com.example.demo है
- निर्यातित गतिविधि नाम com.example.test.MainActivity है
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF _**singleTask/singleInstance**_ के उपयोग को `android:launchMode` में एक गतिविधि के रूप में दुर्भावनापूर्ण के रूप में पहचानता है, लेकिन [इस](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750) के कारण, यह स्पष्ट रूप से केवल पुराने संस्करणों (API संस्करण < 21) पर खतरनाक है।

> [!NOTE]
> ध्यान दें कि एक प्राधिकरण बाईपास हमेशा एक कमजोर बिंदु नहीं होता है, यह इस पर निर्भर करेगा कि बाईपास कैसे काम करता है और कौन सी जानकारी उजागर होती है।

**संवेदनशील जानकारी का रिसाव**

**गतिविधियाँ परिणाम भी लौटा सकती हैं**। यदि आप एक निर्यातित और असुरक्षित गतिविधि को खोजने में सफल होते हैं जो **`setResult`** विधि को कॉल करती है और **संवेदनशील जानकारी** लौटाती है, तो यह संवेदनशील जानकारी का रिसाव है।

#### Tapjacking

यदि tapjacking को रोका नहीं गया, तो आप निर्यातित गतिविधि का दुरुपयोग कर सकते हैं ताकि **उपयोगकर्ता अप्रत्याशित क्रियाएँ** कर सके। [**Tapjacking क्या है, इसके बारे में अधिक जानकारी के लिए लिंक का पालन करें**](./#tapjacking)।

### सामग्री प्रदाताओं का शोषण - संवेदनशील जानकारी तक पहुँच और हेरफेर

[**यदि आप सामग्री प्रदाता क्या है, इसे ताज़ा करना चाहते हैं तो इसे पढ़ें।**](android-applications-basics.md#content-provider)\
सामग्री प्रदाता मूल रूप से **डेटा साझा करने** के लिए उपयोग किए जाते हैं। यदि किसी ऐप में उपलब्ध सामग्री प्रदाता हैं, तो आप उनसे **संवेदनशील** डेटा निकालने में सक्षम हो सकते हैं। यह भी **SQL इंजेक्शन** और **पथ Traversals** का परीक्षण करना दिलचस्प है क्योंकि वे कमजोर हो सकते हैं।

[**Drozer के साथ सामग्री प्रदाताओं का शोषण कैसे करें, यह जानें।**](drozer-tutorial/#content-providers)

### **सेवाओं का शोषण**

[**यदि आप सेवा क्या है, इसे ताज़ा करना चाहते हैं तो इसे पढ़ें।**](android-applications-basics.md#services)\
याद रखें कि एक सेवा की क्रियाएँ `onStartCommand` विधि में शुरू होती हैं।

एक सेवा मूल रूप से कुछ ऐसा है जो **डेटा प्राप्त कर सकता है**, **प्रसंस्कृत** कर सकता है और **एक प्रतिक्रिया** (या नहीं) लौटा सकता है। फिर, यदि कोई एप्लिकेशन कुछ सेवाएँ निर्यात कर रहा है, तो आपको **कोड** की **जांच** करनी चाहिए ताकि यह समझ सकें कि यह क्या कर रहा है और **गोपनीय जानकारी निकालने**, प्रमाणीकरण उपायों को बाईपास करने के लिए इसे **गतिशील रूप से** **परीक्षण** करें...\
[**Drozer के साथ सेवाओं का शोषण कैसे करें, यह जानें।**](drozer-tutorial/#services)

### **ब्रॉडकास्ट रिसीवर्स का शोषण**

[**यदि आप ब्रॉडकास्ट रिसीवर क्या है, इसे ताज़ा करना चाहते हैं तो इसे पढ़ें।**](android-applications-basics.md#broadcast-receivers)\
याद रखें कि एक ब्रॉडकास्ट रिसीवर की क्रियाएँ `onReceive` विधि में शुरू होती हैं।

एक ब्रॉडकास्ट रिसीवर एक प्रकार के संदेश की प्रतीक्षा करेगा। रिसीवर जिस तरह से संदेश को संभालता है, उसके आधार पर यह कमजोर हो सकता है।\
[**Drozer के साथ ब्रॉडकास्ट रिसीवर्स का शोषण कैसे करें, यह जानें।**](./#exploiting-broadcast-receivers)

### **स्कीमों / डीप लिंक का शोषण**

आप मैन्युअल रूप से गहरे लिंक की तलाश कर सकते हैं, MobSF जैसे उपकरणों का उपयोग करके या [इस स्क्रिप्ट](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py) का उपयोग करके।\
आप **adb** या एक **ब्राउज़र** का उपयोग करके एक घोषित **स्कीम** को **खोल** सकते हैं:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_ध्यान दें कि आप **पैकेज नाम को छोड़ सकते हैं** और मोबाइल स्वचालित रूप से उस ऐप को कॉल करेगा जो उस लिंक को खोलना चाहिए._
```markup
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**कोड निष्पादित**

**ऐप में निष्पादित होने वाले कोड** को खोजने के लिए, उस गतिविधि पर जाएं जिसे डीप लिंक द्वारा बुलाया गया है और फ़ंक्शन **`onNewIntent`** को खोजें।

![](<../../images/image (436) (1) (1) (1).png>)

**संवेदनशील जानकारी**

हर बार जब आप एक डीप लिंक पाते हैं, तो जांचें कि **यह URL पैरामीटर के माध्यम से संवेदनशील डेटा (जैसे पासवर्ड) प्राप्त नहीं कर रहा है**, क्योंकि कोई अन्य एप्लिकेशन **डीप लिंक का अनुकरण कर सकता है और उस डेटा को चुरा सकता है!**

**पैरामीटर पथ में**

आपको **यह भी जांचना चाहिए कि क्या कोई डीप लिंक URL के पथ के अंदर एक पैरामीटर का उपयोग कर रहा है** जैसे: `https://api.example.com/v1/users/{username}` , इस मामले में आप एक पथ यात्रा को मजबूर कर सकते हैं जैसे: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
ध्यान दें कि यदि आप एप्लिकेशन के अंदर सही एंडपॉइंट्स पाते हैं, तो आप **Open Redirect** (यदि पथ का एक भाग डोमेन नाम के रूप में उपयोग किया जाता है), **खाता अधिग्रहण** (यदि आप CSRF टोकन के बिना उपयोगकर्ता विवरण को संशोधित कर सकते हैं और कमजोर एंडपॉइंट ने सही विधि का उपयोग किया) और किसी अन्य कमजोरियों का कारण बन सकते हैं। इसके बारे में अधिक [जानकारी यहाँ](http://dphoeniixx.com/2020/12/13-2/) है।

**अधिक उदाहरण**

एक [दिलचस्प बग बाउंटी रिपोर्ट](https://hackerone.com/reports/855618) लिंक के बारे में (_/.well-known/assetlinks.json_).

### ट्रांसपोर्ट लेयर निरीक्षण और सत्यापन विफलताएँ

- **प्रमाणपत्रों की हमेशा सही तरीके से जांच नहीं की जाती** Android एप्लिकेशनों द्वारा। इन एप्लिकेशनों के लिए चेतावनियों की अनदेखी करना और स्व-हस्ताक्षरित प्रमाणपत्रों को स्वीकार करना या कुछ मामलों में HTTP कनेक्शन का उपयोग करना सामान्य है।
- **SSL/TLS हैंडशेक के दौरान बातचीत कभी-कभी कमजोर होती है**, असुरक्षित सिफर सूट का उपयोग करते हुए। यह कमजोरी कनेक्शन को मैन-इन-द-मिडल (MITM) हमलों के प्रति संवेदनशील बनाती है, जिससे हमलावर डेटा को डिक्रिप्ट कर सकते हैं।
- **निजी जानकारी का लीक होना** एक जोखिम है जब एप्लिकेशन सुरक्षित चैनलों का उपयोग करके प्रमाणीकरण करते हैं लेकिन फिर अन्य लेनदेन के लिए असुरक्षित चैनलों के माध्यम से संवाद करते हैं। यह दृष्टिकोण संवेदनशील डेटा, जैसे सत्र कुकीज़ या उपयोगकर्ता विवरण, को दुर्भावनापूर्ण संस्थाओं द्वारा इंटरसेप्शन से बचाने में विफल रहता है।

#### प्रमाणपत्र सत्यापन

हम **प्रमाणपत्र सत्यापन** पर ध्यान केंद्रित करेंगे। सुरक्षा बढ़ाने के लिए सर्वर के प्रमाणपत्र की अखंडता की जांच की जानी चाहिए। यह महत्वपूर्ण है क्योंकि असुरक्षित TLS कॉन्फ़िगरेशन और असुरक्षित चैनलों के माध्यम से संवेदनशील डेटा का संचरण महत्वपूर्ण जोखिम पैदा कर सकता है। सर्वर प्रमाणपत्रों की जांच करने और कमजोरियों को संबोधित करने के लिए विस्तृत कदमों के लिए, [**यह संसाधन**](https://manifestsecurity.com/android-application-security-part-10/) व्यापक मार्गदर्शन प्रदान करता है।

#### SSL पिनिंग

SSL पिनिंग एक सुरक्षा उपाय है जहां एप्लिकेशन सर्वर के प्रमाणपत्र की जांच एक ज्ञात प्रति के खिलाफ करता है जो एप्लिकेशन के भीतर संग्रहीत होती है। यह विधि MITM हमलों को रोकने के लिए आवश्यक है। संवेदनशील जानकारी को संभालने वाले एप्लिकेशनों के लिए SSL पिनिंग को लागू करना अत्यधिक अनुशंसित है।

#### ट्रैफ़िक निरीक्षण

HTTP ट्रैफ़िक का निरीक्षण करने के लिए, **प्रॉक्सी टूल का प्रमाणपत्र स्थापित करना आवश्यक है** (जैसे, Burp)। इस प्रमाणपत्र को स्थापित किए बिना, एन्क्रिप्टेड ट्रैफ़िक प्रॉक्सी के माध्यम से दिखाई नहीं दे सकता है। कस्टम CA प्रमाणपत्र स्थापित करने के लिए एक गाइड के लिए, [**यहाँ क्लिक करें**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine)।

**API स्तर 24 और उससे ऊपर** को लक्षित करने वाले एप्लिकेशनों को प्रॉक्सी के CA प्रमाणपत्र को स्वीकार करने के लिए नेटवर्क सुरक्षा कॉन्फ़िग को संशोधित करने की आवश्यकता होती है। एन्क्रिप्टेड ट्रैफ़िक का निरीक्षण करने के लिए यह कदम महत्वपूर्ण है। नेटवर्क सुरक्षा कॉन्फ़िग को संशोधित करने के लिए निर्देशों के लिए, [**इस ट्यूटोरियल का संदर्भ लें**](make-apk-accept-ca-certificate.md)।

#### SSL पिनिंग को बायपास करना

जब SSL पिनिंग लागू होती है, तो HTTPS ट्रैफ़िक का निरीक्षण करने के लिए इसे बायपास करना आवश्यक हो जाता है। इस उद्देश्य के लिए विभिन्न विधियाँ उपलब्ध हैं:

- स्वचालित रूप से **संशोधित करें** **apk** को **SSL पिनिंग को बायपास** करने के लिए [**apk-mitm**](https://github.com/shroudedcode/apk-mitm) के साथ। इस विकल्प का सबसे बड़ा लाभ यह है कि आपको SSL पिनिंग को बायपास करने के लिए रूट की आवश्यकता नहीं होगी, लेकिन आपको एप्लिकेशन को हटाना और नए को फिर से स्थापित करना होगा, और यह हमेशा काम नहीं करेगा।
- आप **Frida** का उपयोग कर सकते हैं (नीचे चर्चा की गई) इस सुरक्षा को बायपास करने के लिए। यहाँ Burp+Frida+Genymotion का उपयोग करने के लिए एक गाइड है: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- आप **स्वचालित रूप से SSL पिनिंग को बायपास करने** के लिए [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"` का प्रयास कर सकते हैं।
- आप **MobSF डायनामिक एनालिसिस** का उपयोग करके भी **स्वचालित रूप से SSL पिनिंग को बायपास करने** का प्रयास कर सकते हैं (नीचे समझाया गया)।
- यदि आप अभी भी सोचते हैं कि कुछ ट्रैफ़िक है जिसे आप कैप्चर नहीं कर रहे हैं, तो आप **iptables का उपयोग करके ट्रैफ़िक को burp की ओर अग्रेषित करने** का प्रयास कर सकते हैं। इस ब्लॉग को पढ़ें: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### सामान्य वेब कमजोरियों की खोज

यह भी महत्वपूर्ण है कि आप एप्लिकेशन के भीतर सामान्य वेब कमजोरियों की खोज करें। इन कमजोरियों की पहचान और शमन के बारे में विस्तृत जानकारी इस सारांश के दायरे से परे है लेकिन इसे अन्यत्र व्यापक रूप से कवर किया गया है।

### Frida

[Frida](https://www.frida.re) डेवलपर्स, रिवर्स-इंजीनियर्स और सुरक्षा शोधकर्ताओं के लिए एक डायनामिक इंस्ट्रुमेंटेशन टूलकिट है।\
**आप चल रहे एप्लिकेशन तक पहुँच सकते हैं और रन टाइम पर विधियों को हुक कर सकते हैं ताकि व्यवहार को बदल सकें, मान बदल सकें, मान निकाल सकें, विभिन्न कोड चला सकें...**\
यदि आप Android एप्लिकेशनों का परीक्षण करना चाहते हैं, तो आपको Frida का उपयोग करना सीखना होगा।

- Frida का उपयोग कैसे करें: [**Frida ट्यूटोरियल**](frida-tutorial/)
- Frida के साथ क्रियाओं के लिए कुछ "GUI": [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection Frida के उपयोग को स्वचालित करने के लिए शानदार है: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- आप यहाँ कुछ शानदार Frida स्क्रिप्ट्स पा सकते हैं: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- एंटी-डिबगिंग / एंटी-Frida तंत्रों को बायपास करने का प्रयास करें Frida को [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) में इंगित किए गए अनुसार लोड करके (उपकरण [linjector](https://github.com/erfur/linjector-rs))

### **Dump Memory - Fridump**

जांचें कि क्या एप्लिकेशन संवेदनशील जानकारी को मेमोरी में संग्रहीत कर रहा है जिसे इसे संग्रहीत नहीं करना चाहिए जैसे पासवर्ड या म्नेमोनिक्स।

[**Fridump3**](https://github.com/rootbsd/fridump3) का उपयोग करके आप एप्लिकेशन की मेमोरी को डंप कर सकते हैं:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
यह ./dump फ़ोल्डर में मेमोरी को डंप करेगा, और वहाँ आप कुछ इस तरह grep कर सकते हैं:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Keystore में संवेदनशील डेटा**

Android में Keystore संवेदनशील डेटा को स्टोर करने के लिए सबसे अच्छा स्थान है, हालाँकि, पर्याप्त विशेषाधिकारों के साथ इसे **एक्सेस करना संभव है**। चूंकि एप्लिकेशन यहाँ **स्पष्ट पाठ में संवेदनशील डेटा** स्टोर करने की प्रवृत्ति रखते हैं, इसलिए pentests को इसे रूट उपयोगकर्ता के रूप में जांचना चाहिए या किसी के पास डिवाइस तक भौतिक पहुंच हो सकती है जो इस डेटा को चुरा सकता है।

यहां तक कि अगर एक ऐप ने keystore में डेटा स्टोर किया है, तो डेटा को एन्क्रिप्ट किया जाना चाहिए।

Keystore के अंदर डेटा तक पहुँचने के लिए आप इस Frida स्क्रिप्ट का उपयोग कर सकते हैं: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **फिंगरप्रिंट/बायोमेट्रिक्स बाईपास**

निम्नलिखित Frida स्क्रिप्ट का उपयोग करके यह संभव हो सकता है कि **फिंगरप्रिंट प्रमाणीकरण** को बाईपास किया जा सके जो Android अनुप्रयोगों द्वारा **कुछ संवेदनशील क्षेत्रों की सुरक्षा** के लिए किया जा रहा है:
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **पृष्ठभूमि छवियाँ**

जब आप एक एप्लिकेशन को पृष्ठभूमि में डालते हैं, तो Android **एप्लिकेशन का एक स्नैपशॉट** स्टोर करता है ताकि जब इसे अग्रभूमि में पुनर्प्राप्त किया जाए, तो यह एप्लिकेशन से पहले छवि लोड करना शुरू कर दे, जिससे ऐसा लगता है कि एप्लिकेशन तेजी से लोड हुआ।

हालांकि, यदि इस स्नैपशॉट में **संवेदनशील जानकारी** होती है, तो स्नैपशॉट तक पहुँच रखने वाला कोई व्यक्ति उस जानकारी को **चुरा सकता है** (ध्यान दें कि इसे एक्सेस करने के लिए आपको रूट की आवश्यकता है)।

स्नैपशॉट आमतौर पर यहाँ स्टोर होते हैं: **`/data/system_ce/0/snapshots`**

Android **FLAG_SECURE** लेआउट पैरामीटर सेट करके **स्क्रीनशॉट कैप्चर को रोकने** का एक तरीका प्रदान करता है। इस फ्लैग का उपयोग करके, विंडो की सामग्री को सुरक्षित के रूप में माना जाता है, जिससे यह स्क्रीनशॉट में दिखाई नहीं देती या असुरक्षित डिस्प्ले पर नहीं देखी जा सकती।
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

यह उपकरण आपको गतिशील विश्लेषण के दौरान विभिन्न उपकरणों का प्रबंधन करने में मदद कर सकता है: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

डेवलपर्स अक्सर प्रॉक्सी घटक जैसे गतिविधियाँ, सेवाएँ, और प्रसारण रिसीवर बनाते हैं जो इन Intents को संभालते हैं और उन्हें `startActivity(...)` या `sendBroadcast(...)` जैसे तरीकों में पास करते हैं, जो जोखिम भरा हो सकता है।

खतरा इस बात में है कि हमलावरों को गैर-निर्यातित ऐप घटकों को ट्रिगर करने या संवेदनशील सामग्री प्रदाताओं तक पहुँचने की अनुमति दी जाती है, इन Intents को गलत दिशा में भेजकर। एक उल्लेखनीय उदाहरण `WebView` घटक है जो URLs को `Intent` वस्तुओं में `Intent.parseUri(...)` के माध्यम से परिवर्तित करता है और फिर उन्हें निष्पादित करता है, जो संभावित रूप से दुर्भावनापूर्ण Intent इंजेक्शन की ओर ले जा सकता है।

### Essential Takeaways

- **Intent Injection** वेब के Open Redirect समस्या के समान है।
- शोषण में `Intent` वस्तुओं को अतिरिक्त के रूप में पास करना शामिल है, जिन्हें असुरक्षित संचालन निष्पादित करने के लिए पुनर्निर्देशित किया जा सकता है।
- यह गैर-निर्यातित घटकों और सामग्री प्रदाताओं को हमलावरों के लिए उजागर कर सकता है।
- `WebView` का URL से `Intent` में रूपांतरण अनपेक्षित क्रियाओं को सुविधाजनक बना सकता है।

### Android Client Side Injections and others

संभवतः आप वेब से इस प्रकार की कमजोरियों के बारे में जानते हैं। आपको Android एप्लिकेशन में इन कमजोरियों के प्रति विशेष रूप से सतर्क रहना चाहिए:

- **SQL Injection:** गतिशील प्रश्नों या सामग्री-प्रदाताओं के साथ काम करते समय सुनिश्चित करें कि आप पैरामीटरयुक्त प्रश्नों का उपयोग कर रहे हैं।
- **JavaScript Injection (XSS):** सुनिश्चित करें कि किसी भी WebViews के लिए JavaScript और प्लगइन समर्थन बंद है (डिफ़ॉल्ट रूप से बंद)। [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews को फ़ाइल प्रणाली तक पहुँच को बंद करना चाहिए (डिफ़ॉल्ट रूप से सक्षम) - `(webview.getSettings().setAllowFileAccess(false);)`। [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: कई मामलों में जब Android एप्लिकेशन सत्र समाप्त करता है, तो कुकी को रद्द नहीं किया जाता है या इसे डिस्क पर भी सहेजा जा सकता है।
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Static analysis**

![](<../../images/image (866).png>)

**ऐप्लिकेशन का कमजोरियों का आकलन** एक अच्छे वेब-आधारित फ्रंटेंड का उपयोग करके। आप गतिशील विश्लेषण भी कर सकते हैं (लेकिन आपको वातावरण तैयार करने की आवश्यकता है)।
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
ध्यान दें कि MobSF **Android**(apk)**, IOS**(ipa) **और Windows**(apx) अनुप्रयोगों का विश्लेषण कर सकता है (_Windows अनुप्रयोगों का विश्लेषण Windows होस्ट में स्थापित MobSF से किया जाना चाहिए_)।\
इसके अलावा, यदि आप एक **ZIP** फ़ाइल बनाते हैं जिसमें एक **Android** या **IOS** ऐप का स्रोत कोड होता है (अनुप्रयोग के रूट फ़ोल्डर पर जाएं, सब कुछ चुनें और एक ZIP फ़ाइल बनाएं), तो यह इसका विश्लेषण भी कर सकेगा।

MobSF आपको **diff/Compare** विश्लेषण करने और **VirusTotal** को एकीकृत करने की अनुमति भी देता है (आपको _MobSF/settings.py_ में अपना API कुंजी सेट करने की आवश्यकता होगी और इसे सक्षम करना होगा: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`)। आप `VT_UPLOAD` को `False` पर भी सेट कर सकते हैं, तब **hash** फ़ाइल के बजाय **upload** किया जाएगा।

### MobSF के साथ सहायक गतिशील विश्लेषण

**MobSF** **Android** में **गतिशील विश्लेषण** के लिए भी बहुत सहायक हो सकता है, लेकिन इस मामले में आपको अपने होस्ट पर MobSF और **genymotion** स्थापित करने की आवश्यकता होगी (एक VM या Docker काम नहीं करेगा)। _नोट: आपको **पहले genymotion में एक VM शुरू करना होगा** और **फिर MobSF।**_\
**MobSF गतिशील विश्लेषक** कर सकता है:

- **अनुप्रयोग डेटा डंप करें** (URLs, लॉग, क्लिपबोर्ड, आपके द्वारा बनाए गए स्क्रीनशॉट, "**Exported Activity Tester**" द्वारा बनाए गए स्क्रीनशॉट, ईमेल, SQLite डेटाबेस, XML फ़ाइलें, और अन्य बनाई गई फ़ाइलें)। इनमें से सभी स्वचालित रूप से किया जाता है सिवाय स्क्रीनशॉट के, आपको तब दबाना होगा जब आप एक स्क्रीनशॉट चाहते हैं या आपको सभी निर्यातित गतिविधियों के स्क्रीनशॉट प्राप्त करने के लिए "**Exported Activity Tester**" पर दबाना होगा।
- **HTTPS ट्रैफ़िक कैप्चर करें**
- **Frida** का उपयोग करके **runtime** **जानकारी** प्राप्त करें

Android **संस्करण > 5** से, यह **स्वचालित रूप से Frida** शुरू करेगा और **ट्रैफ़िक कैप्चर** करने के लिए वैश्विक **proxy** सेटिंग्स सेट करेगा। यह केवल परीक्षण किए गए अनुप्रयोग से ट्रैफ़िक कैप्चर करेगा।

**Frida**

डिफ़ॉल्ट रूप से, यह **SSL पिनिंग**, **root detection** और **debugger detection** को **बायपास** करने और **दिलचस्प APIs** की निगरानी करने के लिए कुछ Frida स्क्रिप्ट का भी उपयोग करेगा।\
MobSF **निर्यातित गतिविधियों** को **invoke** कर सकता है, उनके **स्क्रीनशॉट** ले सकता है और उन्हें रिपोर्ट के लिए **सहेज** सकता है।

गतिशील परीक्षण **शुरू** करने के लिए हरे बटन पर दबाएं: "**Start Instrumentation**"। **Frida Live Logs** पर दबाएं ताकि Frida स्क्रिप्ट द्वारा उत्पन्न लॉग देख सकें और "**Live API Monitor**" पर दबाएं ताकि सभी हुक किए गए तरीकों, पास किए गए तर्कों और लौटाए गए मानों के आवाहनों को देख सकें (यह "Start Instrumentation" दबाने के बाद दिखाई देगा)।\
MobSF आपको अपनी **Frida स्क्रिप्ट** लोड करने की भी अनुमति देता है (अपने शुक्रवार स्क्रिप्ट के परिणाम MobSF को भेजने के लिए `send()` फ़ंक्शन का उपयोग करें)। इसमें **कई पूर्व-लिखित स्क्रिप्ट** भी हैं जिन्हें आप लोड कर सकते हैं (आप `MobSF/DynamicAnalyzer/tools/frida_scripts/others/` में और जोड़ सकते हैं), बस **उन्हें चुनें**, "**Load**" पर दबाएं और "**Start Instrumentation**" पर दबाएं (आप उस स्क्रिप्ट के लॉग "**Frida Live Logs**" के अंदर देख सकेंगे)।

![](<../../images/image (419).png>)

इसके अलावा, आपके पास कुछ सहायक Frida कार्यक्षमताएँ हैं:

- **लोड की गई कक्षाओं की गणना करें**: यह सभी लोड की गई कक्षाओं को प्रिंट करेगा
- **स्ट्रिंग कैप्चर करें**: यह अनुप्रयोग का उपयोग करते समय सभी कैप्चर की गई स्ट्रिंग्स को प्रिंट करेगा (बहुत शोर)
- **स्ट्रिंग तुलना कैप्चर करें**: यह बहुत उपयोगी हो सकता है। यह **2 स्ट्रिंग्स को दिखाएगा जो तुलना की जा रही हैं** और यदि परिणाम सत्य या असत्य था।
- **कक्षा विधियों की गणना करें**: कक्षा का नाम डालें (जैसे "java.io.File") और यह कक्षा की सभी विधियों को प्रिंट करेगा।
- **कक्षा पैटर्न खोजें**: पैटर्न द्वारा कक्षाओं की खोज करें
- **कक्षा विधियों को ट्रेस करें**: **पूरी कक्षा को ट्रेस करें** (कक्षा की सभी विधियों के इनपुट और आउटपुट देखें)। याद रखें कि डिफ़ॉल्ट रूप से MobSF कई दिलचस्प Android API विधियों को ट्रेस करता है।

एक बार जब आप सहायक मॉड्यूल का चयन कर लेते हैं जिसे आप उपयोग करना चाहते हैं, तो आपको "**Start Intrumentation**" पर दबाना होगा और आप सभी आउटपुट "**Frida Live Logs**" में देखेंगे।

**Shell**

Mobsf आपको गतिशील विश्लेषण पृष्ठ के नीचे कुछ **adb** कमांड, **MobSF कमांड**, और सामान्य **shell** **commands** के साथ एक शेल भी लाता है। कुछ दिलचस्प कमांड:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP उपकरण**

जब http ट्रैफ़िक कैप्चर किया जाता है, तो आप "**HTTP(S) ट्रैफ़िक**" के नीचे कैप्चर किए गए ट्रैफ़िक का एक भद्दा दृश्य देख सकते हैं या "**Start HTTPTools**" हरे बटन में एक बेहतर दृश्य देख सकते हैं। दूसरे विकल्प से, आप **कैप्चर किए गए अनुरोधों** को **प्रॉक्सी** जैसे Burp या Owasp ZAP को **भेज** सकते हैं।\
इसके लिए, _Burp चालू करें -->_ _Intercept बंद करें --> MobSB HTTPTools में अनुरोध का चयन करें_ --> "**Send to Fuzzer**" दबाएं --> _प्रॉक्सी पता चुनें_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080))।

एक बार जब आप MobSF के साथ गतिशील विश्लेषण समाप्त कर लेते हैं, तो आप "**Start Web API Fuzzer**" पर दबा सकते हैं ताकि **http अनुरोधों को फज़** किया जा सके और कमजोरियों की तलाश की जा सके।

> [!NOTE]
> MobSF के साथ गतिशील विश्लेषण करने के बाद प्रॉक्सी सेटिंग्स गलत हो सकती हैं और आप उन्हें GUI से ठीक नहीं कर पाएंगे। आप निम्नलिखित करके प्रॉक्सी सेटिंग्स को ठीक कर सकते हैं:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Inspeckage के साथ सहायक गतिशील विश्लेषण

आप [**Inspeckage**](https://github.com/ac-pm/Inspeckage) से उपकरण प्राप्त कर सकते हैं।\
यह उपकरण कुछ **हुक्स** का उपयोग करेगा ताकि आपको पता चल सके **क्या हो रहा है आवेदन में** जब आप **गतिशील विश्लेषण** करते हैं।

### [Yaazhini](https://www.vegabird.com/yaazhini/)

यह एक **ग्रेट टूल है स्टैटिक एनालिसिस करने के लिए GUI के साथ**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

यह उपकरण कई **सुरक्षा संबंधित Android अनुप्रयोग कमजोरियों** की तलाश करने के लिए डिज़ाइन किया गया है, चाहे वह **स्रोत कोड** में हो या **पैक किए गए APKs** में। यह उपकरण एक "प्रूफ-ऑफ-कॉन्सेप्ट" तैनात करने योग्य APK और **ADB कमांड** बनाने में भी **सक्षम है**, ताकि कुछ पाए गए कमजोरियों (Exposed activities, intents, tapjacking...) का शोषण किया जा सके। Drozer के साथ, परीक्षण उपकरण को रूट करने की आवश्यकता नहीं है।
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- सभी निकाले गए फ़ाइलों को आसान संदर्भ के लिए प्रदर्शित करता है
- APK फ़ाइलों को स्वचालित रूप से Java और Smali प्रारूप में डिकंपाइल करता है
- सामान्य कमजोरियों और व्यवहार के लिए AndroidManifest.xml का विश्लेषण करें
- सामान्य कमजोरियों और व्यवहार के लिए स्थैतिक स्रोत कोड विश्लेषण
- डिवाइस जानकारी
- और अधिक
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER एक कमांड-लाइन एप्लिकेशन है जिसे Windows, MacOS X और Linux में उपयोग किया जा सकता है, जो _.apk_ फ़ाइलों का विश्लेषण करता है ताकि कमजोरियों की खोज की जा सके। यह APKs को डिकंप्रेस करके और उन कमजोरियों का पता लगाने के लिए नियमों की एक श्रृंखला लागू करके करता है।

सभी नियम `rules.json` फ़ाइल में केंद्रित हैं, और प्रत्येक कंपनी या परीक्षक अपने आवश्यक विश्लेषण के लिए अपने नियम बना सकता है।

नवीनतम बाइनरीज़ [download page](https://superanalyzer.rocks/download.html) से डाउनलोड करें।
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn एक **क्रॉसप्लेटफ़ॉर्म** उपकरण है जो डेवलपर्स, बग बाउंटी शिकारियों और नैतिक हैकरों को मोबाइल अनुप्रयोगों पर [स्टैटिक कोड विश्लेषण](https://en.wikipedia.org/wiki/Static_program_analysis) करने में मदद करता है।

विचार यह है कि आप अपने मोबाइल अनुप्रयोग फ़ाइल (एक .apk या .ipa फ़ाइल) को StaCoAn अनुप्रयोग पर खींचते और छोड़ते हैं और यह आपके लिए एक दृश्य और पोर्टेबल रिपोर्ट उत्पन्न करेगा। आप सेटिंग्स और वर्डलिस्ट को समायोजित कर सकते हैं ताकि एक अनुकूलित अनुभव प्राप्त कर सकें।

डाउनलोड[ नवीनतम रिलीज़](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework एक Android कमजोरियों का विश्लेषण प्रणाली है जो डेवलपर्स या हैकर्स को Android अनुप्रयोगों में संभावित सुरक्षा कमजोरियों को खोजने में मदद करती है।\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** एक उपकरण है जिसका मुख्य उद्देश्य Android एप्लिकेशन द्वारा विकसित संभावित दुर्भावनापूर्ण व्यवहारों का पता लगाना और उपयोगकर्ता को चेतावनी देना है।

पता लगाने की प्रक्रिया एप्लिकेशन के Dalvik बाइटकोड का **स्थैतिक विश्लेषण** करके की जाती है, जिसे **Smali** के रूप में दर्शाया गया है, [`androguard`](https://github.com/androguard/androguard) पुस्तकालय के साथ।

यह उपकरण **"खराब" एप्लिकेशनों के सामान्य व्यवहार** की तलाश करता है जैसे: टेलीफोनी पहचानकर्ता का बहिर्वाह, ऑडियो/वीडियो प्रवाह का अवरोधन, PIM डेटा में संशोधन, मनमाने कोड का निष्पादन...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** एक **M**obile **A**pplication **R**everse engineering और **A**nalysis Framework है। यह एक उपकरण है जो सामान्यतः उपयोग किए जाने वाले मोबाइल एप्लिकेशन रिवर्स इंजीनियरिंग और विश्लेषण उपकरणों को एक साथ लाता है, ताकि OWASP मोबाइल सुरक्षा खतरों के खिलाफ मोबाइल एप्लिकेशनों का परीक्षण करने में सहायता मिल सके। इसका उद्देश्य इस कार्य को मोबाइल एप्लिकेशन डेवलपर्स और सुरक्षा पेशेवरों के लिए आसान और मित्रवत बनाना है।

यह सक्षम है:

- विभिन्न उपकरणों का उपयोग करके Java और Smali कोड निकालना
- [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD) का उपयोग करके APKs का विश्लेषण करना
- regexps का उपयोग करके APK से निजी जानकारी निकालना।
- मैनिफेस्ट का विश्लेषण करना।
- [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) और [whatweb](https://github.com/urbanadventurer/WhatWeb) का उपयोग करके पाए गए डोमेन का विश्लेषण करना
- [apk-deguard.com](http://www.apk-deguard.com) के माध्यम से APK को डिओबफस्केट करना

### Koodous

मैलवेयर का पता लगाने के लिए उपयोगी: [https://koodous.com/](https://koodous.com)

## Obfuscating/Deobfuscating code

ध्यान दें कि आप जिस सेवा और कॉन्फ़िगरेशन का उपयोग करते हैं, उसके आधार पर कोड को ओबफस्केट करने के लिए। रहस्य ओबफस्केटेड हो सकते हैं या नहीं।

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

[विकिपीडिया](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** एक ओपन-सोर्स कमांड-लाइन उपकरण है जो Java कोड को संकुचित, अनुकूलित और ओबफस्केट करता है। यह बाइटकोड को अनुकूलित करने के साथ-साथ अप्रयुक्त निर्देशों का पता लगाने और उन्हें हटाने में सक्षम है। ProGuard मुफ्त सॉफ़्टवेयर है और इसे GNU जनरल पब्लिक लाइसेंस, संस्करण 2 के तहत वितरित किया जाता है।

ProGuard Android SDK का एक हिस्सा है और रिलीज़ मोड में एप्लिकेशन बनाते समय चलता है।

### [DexGuard](https://www.guardsquare.com/dexguard)

APK को डिओबफस्केट करने के लिए चरण-दर-चरण गाइड [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html) में खोजें

(उस गाइड से) आखिरी बार जब हमने जांचा, Dexguard का संचालन मोड था:

- एक संसाधन को InputStream के रूप में लोड करें;
- इसे डिक्रिप्ट करने के लिए FilterInputStream से विरासत में मिली एक कक्षा को परिणाम दें;
- एक रिवर्सर के समय को बर्बाद करने के लिए कुछ बेकार ओबफस्केशन करें;
- DEX फ़ाइल प्राप्त करने के लिए डिक्रिप्टेड परिणाम को ZipInputStream में दें;
- अंततः `loadDex` विधि का उपयोग करके परिणामस्वरूप DEX को एक संसाधन के रूप में लोड करें।

### [DeGuard](http://apk-deguard.com)

**DeGuard Android ओबफस्केशन उपकरणों द्वारा किए गए ओबफस्केशन की प्रक्रिया को उलटता है। यह कोड निरीक्षण और पुस्तकालयों की भविष्यवाणी सहित कई सुरक्षा विश्लेषणों को सक्षम बनाता है।**

आप उनके प्लेटफॉर्म पर एक ओबफस्केटेड APK अपलोड कर सकते हैं।

### [Deobfuscate android App](https://github.com/In3tinct/deobfuscate-android-app)

यह एक LLM उपकरण है जो Android ऐप्स में किसी भी संभावित सुरक्षा कमजोरियों को खोजने और Android ऐप कोड को डिओबफस्केट करने के लिए है। Google के Gemini सार्वजनिक API का उपयोग करता है।

### [Simplify](https://github.com/CalebFenton/simplify)

यह एक **generic android deobfuscator** है। Simplify **virtually executes an app** ताकि इसके व्यवहार को समझा जा सके और फिर **कोड को अनुकूलित करने की कोशिश करता है** ताकि यह समान रूप से व्यवहार करे लेकिन इसे मानव के लिए समझना आसान हो। प्रत्येक अनुकूलन प्रकार सरल और सामान्य है, इसलिए यह मायने नहीं रखता कि उपयोग की जाने वाली ओबफस्केशन का विशिष्ट प्रकार क्या है।

### [APKiD](https://github.com/rednaga/APKiD)

APKiD आपको **यह जानकारी देता है कि एक APK कैसे बनाई गई थी**। यह कई **कंपाइलर्स**, **पैकर**, **ओबफस्केटर्स**, और अन्य अजीब चीजों की पहचान करता है। यह Android के लिए [_PEiD_](https://www.aldeid.com/wiki/PEiD) है।

### Manual

[कस्टम ओबफस्केशन को रिवर्स करने के कुछ ट्रिक्स सीखने के लिए इस ट्यूटोरियल को पढ़ें](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b एक Android सुरक्षा वर्चुअल मशीन है जो ubuntu-mate पर आधारित है जिसमें रिवर्स इंजीनियरिंग और मैलवेयर विश्लेषण के लिए विभिन्न सुरक्षा गीक और शोधकर्ताओं से नवीनतम फ्रेमवर्क, ट्यूटोरियल और प्रयोगशालाओं का संग्रह शामिल है।

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) यह संसाधनों की एक शानदार सूची है
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android त्वरित पाठ्यक्रम
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)

## Yet to try

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
