# Android Uygulamaları Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android Uygulamaları Temelleri

Bu sayfayı okumaya başlamanız şiddetle tavsiye edilir; Android güvenliğiyle ilgili **en önemli bölümler ve bir Android uygulamasındaki en tehlikeli bileşenler** hakkında bilgi edinmek için:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Bu, bir Android cihaza (emüle edilmiş veya fiziksel) bağlanmak için ihtiyacınız olan ana araçtır.\
**ADB**, bilgisayardan cihazları ya **USB** ya da **Network** üzerinden kontrol etmeye imkân verir. Bu yardımcı program; dosyaların her iki yönde **kopyalanması**, uygulamaların **yüklenmesi** ve **kaldırılması**, shell komutlarının **çalıştırılması**, verilerin **yedeklenmesi**, logların **okunması** gibi işlevlerin yanı sıra diğer işler için de kullanılabilir.

adb'nin nasıl kullanılacağını öğrenmek için aşağıdaki [**ADB Commands**](adb-commands.md) listesine göz atın.

## Smali

Bazen **uygulama kodunu değiştirmek**, **gizli bilgilere** (ör. iyi şekilde obfuscate edilmiş şifreler veya flag'ler) erişmek için ilginç olabilir. Bu yüzden, apk'yi decompile etmek, kodu değiştirmek ve yeniden derlemek ilginç olabilir.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Bu, dinamik analiz sırasında yapılacak çeşitli testler için çok yararlı bir **alternatif** olabilir. Bu olasılığı her zaman aklınızda bulundurun.

## Diğer ilginç hileler

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Cihazdan APK çıkarma:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Tüm splits ve base apks'i [APKEditor](https://github.com/REAndroid/APKEditor) ile birleştirin:
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Vaka Çalışmaları ve Güvenlik Açıkları


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Statik Analiz

Öncelikle, bir APK'yı analiz etmek için bir decompiler kullanarak **Java koduna göz atmalısınız**.\
Lütfen, [**farklı kullanılabilir decompiler'lar hakkında bilgi almak için burayı okuyun**](apk-decompilers.md).

### İlginç Bilgiler Arama

APK'nın **strings**'lerine bakarak **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** ve ilginç olabilecek her şeyi arayabilirsiniz... hatta kod yürütme **backdoors** veya kimlik doğrulama backdoor'ları (uygulamaya gömülü admin credentials) arayın.

**Firebase**

Özellikle **firebase URLs**'lerine dikkat edin ve kötü yapılandırılıp yapılandırılmadığını kontrol edin. [Firebase'in ne olduğu ve nasıl istismar edileceği hakkında daha fazla bilgi için burayı okuyun.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Uygulamayı Temel Düzeyde Anlama - Manifest.xml, strings.xml

Bir uygulamanın _Manifest.xml_ ve _strings.xml_ dosyalarının **incelenmesi potansiyel güvenlik zafiyetlerini ortaya çıkarabilir**. Bu dosyalara decompiler'lar ile erişilebileceği gibi APK dosya uzantısını .zip olarak değiştirip açarak da ulaşabilirsiniz.

Manifest.xml'den tespit edilebilecek **zafiyetler** şunlardır:

- **Debuggable Uygulamalar**: _Manifest.xml_ dosyasında `debuggable="true"` olarak ayarlanmış uygulamalar, bağlantılara izin verdikleri için istismar riski taşır. Debuggable uygulamaların nasıl bulunup istismar edileceği konusunda bir eğitim materyaline bakın.
- **Backup Ayarları**: Hassas bilgi işleyen uygulamalar için `android:allowBackup="false"` özniteliğinin açıkça ayarlanması gerekir; aksi halde, özellikle usb debugging etkinse adb üzerinden yetkisiz veri yedeklemeleri yapılabilir.
- **Network Güvenliği**: _res/xml/_ içindeki özel network security konfigürasyonları (`android:networkSecurityConfig="@xml/network_security_config"`) sertifika pinleri ve HTTP trafiği ayarları gibi güvenlik detaylarını belirtebilir. Örneğin belirli domain'ler için HTTP trafiğine izin verilebilir.
- **Export Edilmiş Activities ve Services**: Manifest'te export edilmiş activity ve service'leri belirlemek, kötüye kullanılabilecek bileşenleri ortaya çıkarabilir. Dinamik testler sırasında bu bileşenlerin nasıl istismar edilebileceği daha ayrıntılı olarak analiz edilmelidir.
- **Content Providers ve FileProviders**: Açıkta kalan content provider'lar yetkisiz erişime veya veri değişikliğine izin verebilir. FileProvider konfigürasyonları da dikkatle incelenmelidir.
- **Broadcast Receiver'lar ve URL Şemaları**: Bu bileşenler istismar için kullanılabilir; özellikle URL şemalarının input açısından nasıl yönetildiğine dikkat edilmelidir.
- **SDK Versiyonları**: `minSdkVersion`, `targetSDKVersion` ve `maxSdkVersion` öznitelikleri desteklenen Android sürümlerini gösterir; eski ve zafiyetli Android sürümlerini desteklemenin güvenlik riskleri olduğu unutulmamalıdır.

**strings.xml** dosyasından API keys, custom schemas ve diğer geliştirici notları gibi hassas bilgiler bulunabilir; bu nedenle bu kaynakların dikkatli incelenmesi önemlidir.

### Tapjacking

**Tapjacking** bir saldırıdır; burada bir **kötü niyetli** **uygulama** başlatılır ve **hedef uygulamanın üzerine kendini konumlandırır**. Kurban uygulamayı görünür şekilde örttüğünde, kullanıcıyı yanıltacak şekilde bir kullanıcı arayüzü tasarlanır ve yapılan etkileşimler arka plandaki hedef uygulamaya iletilir.\
Böylece kullanıcı **gerçekte hedef uygulama üzerinde işlem yaptığını bilmeden** harekete geçirilmiş olur.

Daha fazla bilgi için bakınız:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

`launchMode`'u `singleTask` olarak ayarlanmış ve herhangi bir `taskAffinity` tanımlanmamış bir **activity** task Hijacking'e karşı savunmasızdır. Bu durum, kötü amaçlı bir **uygulamanın** yüklendikten sonra gerçek uygulamadan önce başlatılması halinde **gerçek uygulamanın task'ını kaçırabilmesi** (kullanıcının gerçek uygulamayı kullandığını düşünürken kötü amaçlı uygulama ile etkileşimde bulunması) anlamına gelir.

Daha fazla bilgi:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Güvenli Olmayan Veri Depolama

**Internal Storage**

Android'de dahili depolamada **saklanan** dosyalar, **oluşturan uygulama tarafından erişilebilir** olacak şekilde tasarlanmıştır. Bu güvenlik mekanizması Android işletim sistemi tarafından uygulanır ve çoğu uygulamanın güvenlik gereksinimleri için genellikle yeterlidir. Ancak geliştiriciler bazen dosyaların farklı uygulamalar arasında paylaşılmasına izin vermek için `MODE_WORLD_READABLE` ve `MODE_WORLD_WRITABLE` gibi modları kullanır. Bu modlar, söz konusu dosyalara diğer uygulamaların, kötü niyetli uygulamalar dahil olmak üzere, erişimini kısıtlamaz.

1. **Statik Analiz:**
- `MODE_WORLD_READABLE` ve `MODE_WORLD_WRITABLE` kullanımının **dikkatle incelenmesini** sağlayın. Bu modlar dosyaların **istenmeyen veya yetkisiz erişime** maruz kalmasına yol açabilir.
2. **Dinamik Analiz:**
- Uygulama tarafından oluşturulan dosyalarda ayarlanan **izinleri doğrulayın**. Özellikle herhangi bir dosyanın **dünya tarafından okunabilir veya yazılabilir** olarak ayarlanıp ayarlanmadığını kontrol edin. Bu, cihazda yüklü herhangi bir uygulamanın, kaynağı veya amacı ne olursa olsun, bu dosyaları **okumasına veya değiştirmesine** izin verebilir ve ciddi bir güvenlik riski oluşturur.

**External Storage**

SD kart gibi **harici depolama** ile çalışırken bazı önlemler alınmalıdır:

1. **Erişilebilirlik**:
- Harici depolamadaki dosyalar **genel olarak okunabilir ve yazılabilir** durumdadır. Bu, herhangi bir uygulamanın veya kullanıcının bu dosyalara erişebileceği anlamına gelir.
2. **Güvenlik Endişeleri**:
- Kolay erişim nedeniyle hassas bilgileri harici depolamada saklamamak önerilir.
- Harici depolama çıkarılabilir veya herhangi bir uygulama tarafından erişilebilir olduğundan daha az güvenlidir.
3. **Harici Depolamadan Veri Alma**:
- Harici depolamadan alınan veriler üzerinde her zaman **girdi doğrulaması** yapın. Bu, verinin güvenilmeyen bir kaynaktan geldiği için kritik önemdedir.
- Harici depolamada yürütülebilir veya sınıf dosyalarını dinamik yükleme amacıyla saklamak şiddetle tavsiye edilmez.
- Uygulamanız harici depolamadan yürütülebilir dosyalar almak zorundaysa, bu dosyaların dinamik olarak yüklenmeden önce **imzalanmış ve kriptografik olarak doğrulanmış** olduğundan emin olun. Bu adım uygulamanızın güvenlik bütünlüğünü korumak için hayati öneme sahiptir.

Harici depolamaya şu yollarla erişilebilir: /storage/emulated/0 , /sdcard , /mnt/sdcard

> [!TIP]
> Android 4.4 (**API 17**) ile başlayarak, SD kartın bir dizin yapısı vardır ve bu yapı **bir uygulamanın yalnızca o uygulamaya özel dizine erişimini sınırlar**. Bu, kötü amaçlı uygulamaların başka bir uygulamanın dosyalarına okuma veya yazma erişimi kazanmasını engeller.

**Açık metin olarak saklanan hassas veriler**

- **Shared preferences**: Android her uygulamanın kolayca xml dosyaları kaydetmesine izin verir; bu dosyalar genellikle `/data/data/<packagename>/shared_prefs/` yolunda bulunur ve bazen bu klasörde açık metin halinde hassas bilgiler bulunabilir.
- **Databases**: Android her uygulamanın sqlite veri tabanlarını kolayca kaydetmesine izin verir; bu dosyalar genellikle `/data/data/<packagename>/databases/` yolunda bulunur ve bazen bu klasörde açık metin halinde hassas bilgiler bulunabilir.

### Broken TLS

**Accept All Certificates**

Nedeni her ne olursa olsun bazen geliştiriciler, örneğin hostname eşleşmesi olmasa bile tüm sertifikaları kabul ederler; bunu yapan kod satırlarına örnek olarak aşağıdaki gibi bir kullanım verilebilir:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Broken Cryptography

**Zayıf Anahtar Yönetimi Süreçleri**

Bazı geliştiriciler hassas verileri yerel depolamada saklar ve kod içinde hardcoded/predictable bir anahtar ile şifreler. Bu yapılmamalıdır çünkü bazı reversing işlemleri saldırganların gizli bilgileri çıkarmasına olanak sağlayabilir.

**Use of Insecure and/or Deprecated Algorithms**

Geliştiriciler yetkilendirme **checks** yapmak, verileri **store** veya **send** etmek için **deprecated algorithms** kullanmamalıdır. Bu algoritmalardan bazıları: RC4, MD4, MD5, SHA1... Örneğin şifreleri saklamak için **hashes** kullanılıyorsa, salt ile birlikte brute-force **resistant** hash'ler kullanılmalıdır.

### Diğer kontroller

- It's recommended to **obfuscate the APK** to difficult the reverse engineer labour to attackers.
- Eğer uygulama hassassa (ör. bank apps), kendi kontrollerini yapmalı; mobil cihazın **rooted** olup olmadığını kontrol etmeli ve buna göre davranmalıdır.
- Eğer uygulama hassassa (ör. bank apps), bir **emulator** kullanılıp kullanılmadığını kontrol etmelidir.
- Eğer uygulama hassassa (ör. bank apps), çalıştırmadan önce **check it's own integrity before executing** yaparak değiştirip değiştirilmediğini doğrulamalıdır.
- Use [**APKiD**](https://github.com/rednaga/APKiD) to check which compiler/packer/obfuscator was used to build the APK

### React Native Application

Aşağıdaki sayfayı okuyun; React uygulamalarının javascript kodlarına nasıl kolayca erişileceğini öğrenebilirsiniz:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Aşağıdaki sayfayı okuyun; bir xamarin uygulamasının C# kodlarına nasıl kolayca erişileceğini öğrenebilirsiniz:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

The tool [**mariana-trench**](https://github.com/facebook/mariana-trench) is capable of finding **vulnerabilities** by **scanning** the **code** of the application. This tool contains a series of **known sources** (that indicates to the tool the **places** where the **input** is **controlled by the user**), **sinks** (which indicates to the tool **dangerous** **places** where malicious user input could cause damages) and **rules**. These rules indicates the **combination** of **sources-sinks** that indicates a vulnerability.

Bu bilgi ile **mariana-trench kodu inceleyip mümkün olan vulnerabilities'leri bulacaktır.**

### Secrets leaked

Bir uygulama içinde keşfedebileceğiniz gizli bilgiler (API anahtarları, parolalar, gizli url'ler, subdomain'ler...) olabilir. Şunu kullanabilirsiniz: [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Diğer ilginç fonksiyonlar

- **Kod yürütme**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **SMS Gönderme**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)

### **Diğer tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> First of all, you need an environment where you can install the application and all the environment (Burp CA cert, Drozer and Frida mainly). Therefore, a rooted device (emulated or not) is extremely recommended.

### Online Dynamic analysis

You can create a **free account** in: [https://appetize.io/](https://appetize.io). This platform allows you to **upload** and **execute** APKs, so it is useful to see how an apk is behaving.

You can even **see the logs of your application** in the web and connect through **adb**.

![](<../../images/image (831).png>)

Thanks to the ADB connection you can use **Drozer** and **Frida** inside the emulators.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (You can create **x86** and **arm** devices, and according to [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** versions **support ARM libraries** without needing an slow arm emulator).
- Kurulumunu bu sayfada öğrenin:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, you need to create an account. _It's recommend to **download** the version **WITH**_ _**VirtualBox** to avoid potential errors._)
- [**Nox**](https://es.bignox.com) (Free, but it doesn't support Frida or Drozer).

> [!TIP]
> Yeni bir emulator oluştururken ekran ne kadar büyükse emulator o kadar yavaş çalışır. Mümkünse küçük ekranları seçin.

Genymotion'da google servislerini (ör. AppStore) yüklemek için aşağıdaki görüntüde kırmızı ile işaretlenmiş butona tıklamanız gerekir:

![](<../../images/image (277).png>)

Ayrıca, **Genymotion içindeki Android VM'in konfigürasyonunda** **Bridge Network mode** seçebileceğinizi unutmayın (bu, araçların bulunduğu farklı bir VM'den Android VM'e bağlanacaksanız faydalı olacaktır).

#### Use a physical device

Geliştirici seçeneklerini aktifleştirmeniz gerekir ve cihazı **root** yapmanız iyi olur:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Uygulamayı kurduktan sonra yapmanız gereken ilk şey onu denemek, ne yaptığını ve nasıl çalıştığını araştırmak ve alışmaktır.\
> İlk dinamik analizi MobSF dynamic analysis + pidcat kullanarak yapmanızı öneririm; böylece MobSF birçok ilginç veriyi **captures** ederken uygulamanın nasıl çalıştığını öğrenebileceksiniz.

Magisk/Zygisk quick notes (recommended on Pixel devices)
- Patch boot.img with the Magisk app and flash via fastboot to get systemless root
- Enable Zygisk + DenyList for root hiding; consider LSPosed/Shamiko when stronger hiding is required
- Keep original boot.img to recover from OTA updates; re-patch after each OTA
- For screen mirroring, use scrcpy on the host



### Unintended Data Leakage

**Logging**

Geliştiriciler hata ayıklama bilgilerini herkese açık olarak ifşa etme konusunda dikkatli olmalıdır; çünkü bu hassas veri leaks ile sonuçlanabilir. Uygulama loglarını izlemek ve hassas bilgileri tespit etmek için [**pidcat**](https://github.com/JakeWharton/pidcat) ve `adb logcat` araçları önerilir. **Pidcat** kullanışlılığı ve okunabilirliği nedeniyle tercih edilir.

> [!WARNING]
> Android 4.0'dan **later newer than Android 4.0** itibaren **applications are only able to access their own logs**. Yani uygulamalar diğer uygulamaların loglarına erişemez.\
> Yine de hassas bilgileri loglamamaya dikkat edilmelidir.

**Copy/Paste Buffer Caching**

Android'in **clipboard-based** çerçevesi uygulamalarda kopyala-yapıştır işlevselliği sağlar, ancak diğer uygulamaların clipboard'a erişebilmesi nedeniyle hassas verilerin açığa çıkma riski vardır. Kredi kartı bilgileri gibi hassas bölümler için copy/paste fonksiyonlarını devre dışı bırakmak önemlidir.

**Crash Logs**

Bir uygulama **crash** yaparsa ve loglar kaydedilirse, bu loglar özellikle uygulama tersine mühendislik yapılamıyorsa saldırganlara yardımcı olabilir. Bu riski azaltmak için çökme durumlarında loglama yapmaktan kaçının ve logların ağ üzerinden gönderilmesi gerekiyorsa SSL kanalı üzerinden gönderildiğinden emin olun.

As pentester, **try to take a look to these logs**.

**Analytics Data Sent To 3rd Parties**

Uygulamalar genellikle Google Adsense gibi servisleri entegre eder; geliştiricinin yanlış uygulaması nedeniyle bu servisler istemeden hassas veri leaks oluşturabilir. Olası veri leaks'leri belirlemek için uygulamanın trafiğini intercept edip üçüncü taraflara gönderilen hassas bilgileri kontrol etmek önerilir.

### SQLite DBs

Çoğu uygulama bilgi saklamak için **internal SQLite databases** kullanacaktır. Pentest sırasında oluşturulan veritabanlarına, tablo isimlerine, sütunlara ve kaydedilen tüm verilere bakın; çünkü hassas bilgiler (bir zafiyet olacak şekilde) bulabilirsiniz.\
Veritabanları genellikle `/data/data/the.package.name/databases` altında bulunur, örneğin `/data/data/com.mwr.example.sieve/databases`

Eğer veritabanı gizli bilgi saklıyorsa ve **encrypted** ise fakat uygulama içinde **password**'u bulabiliyorsanız, bu hâlâ bir **vulnerability**'dir.

Tabloları listelemek için `.tables` kullanın ve tablonun sütunlarını görmek için `.schema <table_name>` çalıştırın.

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer is s useful tool to **exploit exported activities, exported services and Content Providers** as you will learn in the following sections.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Ayrıca bir activity'nin kodunun **`onCreate`** metodunda başladığını unutmayın.

**Authorisation bypass**

Eğer bir Activity **exported** ise, ekranını dışarıdan bir uygulamadan çağırabilirsiniz. Bu nedenle, eğer hassas bilgi içeren bir activity exported ise, erişmek için authentication mekanizmalarını bypass edebilirsiniz.

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

Ayrıca adb'den bir exported activity başlatabilirsiniz:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> Bu durumda, bir authorisation bypass her zaman bir zafiyet değildir; bypass'ın nasıl çalıştığına ve hangi bilgilerin açığa çıktığına bağlıdır.

**Hassas bilgi sızıntısı**

Activities ayrıca sonuç döndürebilir. Eğer export edilmiş ve korunmasız bir activity bulur, **`setResult`** metodunu çağırdığını ve **hassas bilgi döndürdüğünü** görürseniz, bir hassas bilgi sızıntısı vardır.

#### Tapjacking

Eğer Tapjacking engellenmemişse, export edilmiş activity'yi kötüye kullanarak **kullanıcının beklenmedik işlemler yapmasını** sağlayabilirsiniz. Tapjacking hakkında daha fazla bilgi için [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers temelde **veri paylaşımı** için kullanılır. Bir uygulamanın erişilebilir content provider'ları varsa, bunlardan **hassas** verileri çıkarabiliyor olabilirsiniz. Ayrıca muhtemel **SQL injections** ve **Path Traversals**'ı test etmek ilginçtir çünkü bunlar zafiyete açık olabilir.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Unutmayın ki bir Service'in işlemleri `onStartCommand` metodunda başlar.

Service temelde **veri alabilen**, **işleyebilen** ve **(isterse) bir cevap döndürebilen** bir yapıdır. Eğer bir uygulama bazı servisleri export ediyorsa, ne yaptığını anlamak için **kodu** incelemeli ve gizli bilgileri çıkarmak, yetkilendirme önlemlerini aşmak vb. için dinamik olarak **test** etmelisiniz.\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Unutmayın ki bir Broadcast Receiver'ın işlemleri `onReceive` metodunda başlar.

Bir broadcast receiver belirli bir tür mesajı bekler. Alıcının mesajı nasıl işlemesine bağlı olarak zafiyet ortaya çıkabilir.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Deep link'leri elle arayabilirsiniz; MobSF gibi araçlar veya [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py) gibi script'ler kullanabilirsiniz.\
Deklar edilmiş bir **scheme**'i **adb** veya bir **browser** ile **açabilirsiniz**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Paket adını **omit the package name** bırakabileceğinizi unutmayın; mobil cihaz o linki açması gereken app'i otomatik olarak çağıracaktır._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Code executed**

Uygulamada çalıştırılacak **kodu bulmak için**, deeplink tarafından çağrılan activity'ye gidin ve **`onNewIntent`** fonksiyonunu arayın.

![](<../../images/image (436) (1) (1) (1).png>)

**Sensitive info**

Her deeplink bulduğunuzda, **URL parametreleri aracılığıyla hassas veri (ör. şifreler) almadığından emin olun**, çünkü başka herhangi bir uygulama **deeplink'i taklit edip bu verileri çalabilir!**

**Parameters in path**

Ayrıca **herhangi bir deeplink'in URL yolunun içinde parametre kullanıp kullanmadığını** kontrol etmelisiniz; örneğin: `https://api.example.com/v1/users/{username}` . Bu durumda path traversal zorlayarak şu gibi bir erişim yapabilirsiniz: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Doğru endpointleri uygulama içinde bulursanız, path'in bir kısmı domain adı olarak kullanılıyorsa **Open Redirect**, CSRF token olmadan kullanıcı bilgilerini değiştirip doğru HTTP metodunu kullanabiliyorsanız **account takeover** ve başka zafiyetlere yol açabilirsiniz. More [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Transport Layer Inspection and Verification Failures

- **Certificates are not always inspected properly** by Android applications. Bu uygulamaların uyarıları göz ardı edip self-signed sertifikaları kabul etmesi ya da bazı durumlarda HTTP'ye geri dönmesi yaygındır.
- **Negotiations during the SSL/TLS handshake are sometimes weak**, zayıf cipher suite'lerin kullanılması görülebilir. Bu zafiyet, bağlantıyı man-in-the-middle (MITM) saldırılarına açık hale getirir ve saldırganların veriyi deşifre etmesine izin verir.
- **Leakage of private information** uygulamalar güvenli kanallarla kimlik doğrulaması yapıp diğer işlemler için daha sonra güvenli olmayan kanallar üzerinden iletişim kurduğunda risk oluşur. Bu yöntem, oturum çerezleri veya kullanıcı bilgileri gibi hassas verilerin kötü niyetli kişilerce ele geçirilmesini önlemez.

#### Certificate Verification

Biz **certificate verification** üzerinde yoğunlaşacağız. Sunucunun sertifika bütünlüğü güvenliği artırmak için doğrulanmalıdır. Bu önemlidir çünkü zayıf TLS yapılandırmaları ve hassas verilerin şifrelenmemiş kanallarda iletilmesi önemli riskler oluşturabilir. Sunucu sertifikalarının doğrulanması ve zafiyetlerin giderilmesi için adım adım rehberlik sağlayan daha fazla bilgi için [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) adresine bakın.

#### SSL Pinning

SSL Pinning, uygulamanın sunucunun sertifikasını uygulama içinde saklanan bilinen bir kopyaya karşı doğruladığı bir güvenlik önlemidir. Bu yöntem MITM saldırılarını önlemek için kritiktir. Hassas bilgi işleyen uygulamalar için SSL Pinning uygulanması şiddetle tavsiye edilir.

#### Traffic Inspection

HTTP trafiğini incelemek için proxy aracının sertifikasını (ör. Burp) **yüklemeniz** gerekir. Bu sertifika yüklenmeden şifreli trafik proxy üzerinden görünmeyebilir. Özel CA sertifikası yükleme rehberi için [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine) bakın.

Uygulamalar **API Level 24 and above** hedefliyorsa, proxy'nin CA sertifikasını kabul etmek için Network Security Config üzerinde değişiklik yapılması gerekir. Şifreli trafiği incelemek için Network Security Config'i nasıl değiştireceğinize dair talimatlar için [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

Eğer **Flutter** kullanılıyorsa, [**this page**](flutter.md) içindeki talimatları takip etmeniz gerekir. Sadece sertifikayı store'a eklemek işe yaramaz çünkü Flutter'ın kendi geçerli CA listesi vardır.

#### Static detection of SSL/TLS pinning

Runtime bypass denemeden önce, pinning'in APK içinde nerede uygulandığını hızlıca haritalandırın. Statik keşif, hook/patch planlamanıza ve doğru kod yollarına odaklanmanıza yardımcı olur.

Tool: SSLPinDetect
- Open-source static-analysis utility that decompiles the APK to Smali (via apktool) and scans for curated regex patterns of SSL/TLS pinning implementations.
- Reports exact file path, line number, and a code snippet for each match.
- Covers common frameworks and custom code paths: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Kullanım
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Örnek desen kuralları (JSON)
Özel/özelleştirilmiş pinning stillerini tespit etmek için signatures kullanın veya genişletin. Kendi JSON'unuzu yükleyip büyük ölçekte tarama yapabilirsiniz.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notlar ve ipuçları
- Büyük uygulamalarda çoklu iş parçacığı ve memory-mapped I/O ile hızlı tarama; önceden derlenmiş regex, yükü/yanlış pozitifleri azaltır.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Sonraki triage için tipik tespit hedefleri:
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Declarative pins in res/xml network security config and manifest references
- Eşleşen konumları Frida hook'ları, statik yamalar veya konfigürasyon incelemeleri planlamak için kullanın; dinamik testten önce bu adımları yapın.



#### SSL Pinning'i Atlama

SSL Pinning uygulandığında, HTTPS trafiğini incelemek için bunu atlamak gerekebilir. Bu amaçla çeşitli yöntemler mevcuttur:

- [**apk-mitm**](https://github.com/shroudedcode/apk-mitm) ile **apk**'yı otomatik olarak **değiştirip** SSLPinning'i **atlayabilirsiniz**. Bu seçeneğin en büyük artısı, SSL Pinning'i atlamak için root'a ihtiyacınız olmamasıdır; ancak uygulamayı silip yeni sürümünü yeniden yüklemeniz gerekir ve her zaman işe yaramayabilir.
- Bu korumayı atlamak için **Frida** (aşağıda tartışılıyor) kullanabilirsiniz. Burp+Frida+Genymotion kullanımı için bir rehber: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- [**objection**](frida-tutorial/objection-tutorial.md) kullanarak SSL Pinning'i **otomatik olarak atlamayı** da deneyebilirsiniz:**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- **MobSF dynamic analysis** kullanarak SSL Pinning'i **otomatik atlamayı** da deneyebilirsiniz (aşağıda açıklanmıştır)
- Eğer hala yakalayamadığınız trafik olduğunu düşünüyorsanız, trafiği iptables ile burp'a **yönlendirmeyi** deneyebilirsiniz. Bu blogu okuyun: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Yaygın Web Zafiyetlerini Arama

Uygulama içinde yaygın web zafiyetlerini de aramak önemlidir. Bu zafiyetleri tespit etme ve hafifletme konusundaki detaylı bilgiler bu özetin kapsamı dışında olup başka kaynaklarda ayrıntılı şekilde ele alınmıştır.

### Frida

[Frida](https://www.frida.re) geliştiriciler, reverse-engineers ve güvenlik araştırmacıları için dinamik enstrümantasyon toolkit'idir.\
**Çalışan uygulamaya erişip çalışma zamanında yöntemleri hooklayarak davranışı değiştirebilir, değerleri değiştirebilir, değerleri çıkarabilir, farklı kod çalıştırabilirsiniz...**\
Android uygulamalarını pentest etmek istiyorsanız Frida'yı nasıl kullanacağınızı bilmeniz gerekir.

- Frida'yı nasıl kullanacağınızı öğrenin: [**Frida tutorial**](frida-tutorial/index.html)
- Frida ile yapılacak işlemler için bazı "GUI"ler: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection, Frida kullanımını otomatikleştirmek için harikadır: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Bazı Awesome Frida script'lerini burada bulabilirsiniz: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Frida/anti-debugging mekanizmalarını atlatmaya çalışın; Frida'yı şu kaynakta gösterildiği gibi yükleyerek atlatmayı deneyin: [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (araç: [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Belleği Dökme - Fridump**

Uygulamanın şifreler veya mnemonic'ler gibi saklamaması gereken hassas bilgileri bellekte tutup tutmadığını kontrol edin.

[**Fridump3**](https://github.com/rootbsd/fridump3) kullanarak uygulamanın belleğini şu komutla dökebilirsiniz:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Bu, belleği ./dump klasörüne dump edecek; orada şu gibi bir komutla grep yapabilirsiniz:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Keystore'da hassas veriler**

Android'de Keystore hassas verileri saklamak için en iyi yerdir, ancak yeterli ayrıcalıkla yine de **erişmek mümkün** olabilir. Uygulamalar genellikle burada **hassas verileri açık metin olarak** saklama eğiliminde olduğundan, pentests bunu kontrol etmelidir; kök kullanıcı veya cihaza fiziksel erişimi olan birisi bu verileri çalabilir.

Bir uygulama keystore'a veri depolasa bile, veriler şifrelenmiş olmalıdır.

Keystore içindeki verilere erişmek için bu Frida script'ini kullanabilirsiniz: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Aşağıdaki Frida script'ini kullanarak, Android uygulamalarının **belirli hassas alanları korumak** amacıyla uyguluyor olabileceği **bypass fingerprint authentication** işlemi mümkün olabilir:
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Arka Plan Görüntüleri**

Bir uygulamayı arka plana attığınızda, Android uygulamanın bir **snapshot'ını** saklar; böylece uygulama tekrar ön plana geldiğinde, uygulama yüklenmeden önce görüntüyü yükleyerek uygulamanın daha hızlı açılmış gibi görünmesini sağlar.

Ancak, eğer bu snapshot içinde **hassas bilgiler** bulunuyorsa, snapshot'a erişimi olan biri bu bilgileri **çalabilir** (erişim için root gerektiğini unutmayın).

Bu snapshot'lar genellikle şu konumda saklanır: **`/data/system_ce/0/snapshots`**

Android, layout parametresi olarak **FLAG_SECURE'i ayarlayarak screenshot alınmasını engelleme** imkanı sağlar. Bu flag kullanıldığında, pencere içeriği güvenli olarak değerlendirilir; böylece içerik screenshot'larda görünmesi veya güvenli olmayan ekranlarda görüntülenmesi engellenir.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Uygulama Analizörü**

Bu araç, dinamik analiz sırasında farklı araçları yönetmenize yardımcı olabilir: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Geliştiriciler sıklıkla bu Intents'i işleyen ve `startActivity(...)` veya `sendBroadcast(...)` gibi metodlara ileten activity, service ve broadcast receiver gibi proxy bileşenleri oluştururlar; bu durum riskli olabilir.

Tehlike, saldırganların bu Intents'i yanlış yönlendirerek non-exported uygulama bileşenlerini tetiklemesine veya hassas content providers'a erişimine izin verilmesinde yatar. Örnek olarak, `WebView` bileşeninin URL'leri `Intent.parseUri(...)` ile `Intent` nesnelerine dönüştürmesi ve ardından bunları çalıştırması, kötü amaçlı Intent enjeksiyonlarına yol açabilir.

### Temel Çıkarımlar

- **Intent Injection** webdeki Open Redirect sorununa benzer.
- Sömürüler, `Intent` nesnelerinin extras olarak geçirilmesini ve bu şekilde tehlikeli işlemlere yönlendirilmesini içerir.
- Bu, non-exported bileşenleri ve content providers'ı saldırganlara maruz bırakabilir.
- `WebView`’in URL'den `Intent`'e dönüşümü istenmeyen eylemleri kolaylaştırabilir.

### Android Client Side Injections and others

Muhtemelen bu tür açıklıkları Web'den biliyorsunuzdur. Android uygulamalarında bu tür açıklıklara karşı özellikle dikkatli olmanız gerekir:

- **SQL Injection:** Dinamik sorgular veya Content-Providers ile çalışırken parameterized queries kullandığınızdan emin olun.
- **JavaScript Injection (XSS):** Herhangi bir WebView için JavaScript ve Plugin desteğinin devre dışı olduğundan emin olun (varsayılan olarak devre dışı). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebView'ların dosya sistemine erişimi kapalı olmalıdır (varsayılan olarak açık) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies:** Birçok durumda Android uygulaması oturumu kapattığında cookie iptal edilmez veya diske kaydedilebilir.
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Otomatik Analiz

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Statik analiz**

![](<../../images/image (866).png>)

Uygulamanın zafiyet değerlendirmesi hoş bir web tabanlı frontend üzerinden yapılır. Dinamik analiz de gerçekleştirebilirsiniz (ancak ortamı hazırlamanız gerekir).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Assisted Dynamic analysis with MobSF

**MobSF** can also be very helpful for **dynamic analysis** in **Android**, but in that case you will need to install MobSF and **genymotion** in your host (a VM or Docker won't work). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
The **MobSF dynamic analyser** can:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). Bu öğelerin tamamı otomatik olarak toplanır; ekran görüntüleri hariç, bir ekran görüntüsü almak istediğinizde manuel olarak basmanız gerekir veya tüm exported aktivitelerin ekran görüntülerini elde etmek için "**Exported Activity Tester**" ı kullanmanız gerekir.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Frida scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: Yüklü tüm sınıfları yazdırır.
- **Capture Strings**: Uygulamayı kullanırken yakalanan tüm stringleri yazdırır (çok gürültülü, çok fazla çıktı üretir).
- **Capture String Comparisons**: Çok kullanışlı olabilir. Karşılaştırılan 2 stringi ve sonucun True mu yoksa False mı olduğunu gösterir.
- **Enumerate Class Methods**: Sınıf adını girin (ör. "java.io.File") ve sınıfın tüm metodlarını yazdırır.
- **Search Class Pattern**: Sınıfları pattern ile arar.
- **Trace Class Methods**: Bir sınıfı tamamen **trace** eder (sınıftaki tüm metodların giriş ve çıkışlarını görür). Unutmayın ki varsayılan olarak MobSF bir dizi ilginç Android Api metodunu trace eder.

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf ayrıca dynamic analysis sayfasının altında bazı **adb** komutları, **MobSF** komutları ve yaygın **shell** komutları içeren bir shell de sunar. Bazı ilginç komutlar:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP tools**

When http traffic is capture you can see an ugly view of the captured traffic on "**HTTP(S) Traffic**" bottom or a nicer view in "**Start HTTPTools**" green bottom. From the second option, you can **send** the **captured requests** to **proxies** like Burp or Owasp ZAP.\
To do so, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> press "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Once you finish the dynamic analysis with MobSF you can press on "**Start Web API Fuzzer**" to **fuzz http requests** an look for vulnerabilities.

> [!TIP]
> After performing a dynamic analysis with MobSF the proxy settings me be misconfigured and you won't be able to fix them from the GUI. You can fix the proxy settings by doing:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

You can get the tool from [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
This tool with use some **Hooks** to let you know **what is happening in the application** while you perform a **dynamic analysis**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

This is a **great tool to perform static analysis with a GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

This tool is designed to look for several **security related Android application vulnerabilities**, either in **source code** or **packaged APKs**. The tool is also **capable of creating a "Proof-of-Concept" deployable APK** and **ADB commands**, to exploit some of the found vulnerabilities (Exposed activities, intents, tapjacking...). As with Drozer, there is no need to root the test device.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Kolay başvuru için tüm çıkarılan dosyaları gösterir
- APK dosyalarını otomatik olarak Java ve Smali formatına decompile eder
- AndroidManifest.xml'i yaygın zafiyetler ve davranış açısından analiz eder
- Yaygın zafiyetler ve davranışlar için statik kaynak kodu analizi yapar
- Cihaz bilgileri
- ve daha fazlası
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER, Windows, MacOS X ve Linux'ta kullanılabilen bir komut satırı uygulamasıdır; _.apk_ dosyalarını güvenlik açıkları açısından analiz eder. Bunu APK'ları açarak ve bu güvenlik açıklarını tespit etmek için bir dizi kural uygulayarak yapar.

Tüm kurallar `rules.json` dosyasında toplanmıştır ve her şirket veya tester ihtiyaçlarına göre kendi kurallarını oluşturabilir.

En son ikili dosyaları [download page](https://superanalyzer.rocks/download.html) üzerinden indirin.
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn, mobil uygulamalarda [static code analysis] yapan geliştiriciler ile bugbounty hunters ve ethical hackers için faydalı olan **çok platformlu** bir araçtır.

Konsept, mobil uygulama dosyanızı (.apk veya .ipa dosyası) StaCoAn uygulamasına sürükleyip bırakmanız ve uygulamanın sizin için görsel ve taşınabilir bir rapor oluşturmasıdır. Ayarları ve wordlists'i düzenleyerek özelleştirilmiş bir deneyim elde edebilirsiniz.

İndir[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework, geliştiricilerin veya hackers'ın Android uygulamalarındaki potansiyel güvenlik açıklarını bulmasına yardımcı olan bir analiz sistemidir.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** Android uygulamalarının oluşturabileceği potansiyel kötü amaçlı davranışları tespit edip kullanıcıyı uyarmayı amaçlayan bir araçtır.

Tespit, uygulamanın Dalvik bytecode'unun **Smali** olarak temsil edildiği ve [`androguard`](https://github.com/androguard/androguard) kütüphanesi ile **static analysis** yapıldığı yöntemle gerçekleştirilir.

Bu araç şu tür **"kötü" uygulamaların ortak davranışları** arar: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. Mobil uygulamaların OWASP mobile security tehditlerine karşı test edilmesine yardımcı olmak için yaygın kullanılan mobile application reverse engineering ve analysis araçlarını bir araya getiren bir araçtır. Amacı, bu görevi mobil uygulama geliştiricileri ve güvenlik profesyonelleri için daha kolay ve kullanıcı dostu hale getirmektir.

It is able to:

- Farklı araçlar kullanarak Java ve Smali kodu çıkarır
- APK'ları analiz eder using: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- APK'den regexp'ler kullanarak özel bilgileri çıkarır
- Manifest'i analiz eder
- Bulunan domainleri analiz eder using: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- APK'yı [apk-deguard.com](http://www.apk-deguard.com) üzerinden deobfuscate eder

### Koodous

Malware tespiti için kullanışlı: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Kodu obfuscate etmek için kullandığınız servis ve yapılandırmaya bağlı olarak, gizli bilgiler obfuscated olabilir ya da olmayabilir.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. Bytecode'u optimize edebilir ve kullanılmayan talimatları tespit edip kaldırabilir. ProGuard ücretsiz bir yazılımdır ve GNU General Public License, version 2 altında dağıtılmaktadır.

ProGuard, Android SDK'nın bir parçası olarak dağıtılır ve uygulama release modunda derlenirken çalışır.

### [DexGuard](https://www.guardsquare.com/dexguard)

DexGuard ile ilgili adım adım bir deobfuscation rehberini şu adreste bulabilirsiniz: [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(O rehbere göre) Son kontrol ettiğimizde, Dexguard'in çalışma modu şu şekildeydi:

- bir kaynağı InputStream olarak yükle;
- sonucu decrypt etmek için FilterInputStream'ten türeyen bir sınıfa ver;
- reverser'ın birkaç dakikasını boşa harcamak için bazı anlamsız obfuskasyonlar yap;
- decrypted sonucu bir ZipInputStream'e vererek bir DEX dosyası elde et;
- sonunda oluşan DEX'i `loadDex` metodu kullanarak bir Resource olarak yükle.

### [DeGuard](http://apk-deguard.com)

**DeGuard, Android obfuscation araçları tarafından uygulanan obfuskasyon sürecini tersine çevirir. Bu, kod incelemesi ve kütüphane tahmini dahil olmak üzere birçok güvenlik analizini mümkün kılar.**

Obfuscated bir APK'yı platformlarına yükleyebilirsiniz.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

Bu, Android uygulamalarındaki potansiyel güvenlik açıklarını bulmak ve Android uygulama kodlarını deobfuscate etmek için bir LLM aracıdır. Google'ın Gemini public API'sini kullanır.

### [Simplify](https://github.com/CalebFenton/simplify)

Bu, generic bir android deobfuscator'dur. Simplify, bir uygulamayı virtually executes ederek davranışını anlar ve sonra kodu optimize etmeye çalışır; böylece davranış aynı kalır ama insan tarafından anlaşılması daha kolay olur. Her optimizasyon türü basit ve genel olduğundan, hangi spesifik obfuscation türünün kullanıldığı önemli değildir.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD size bir **APK'ın nasıl yapıldığı** hakkında bilgi verir. Birçok **compilers**, **packers**, **obfuscators** ve diğer tuhaf şeyleri tespit eder. Android için [_PEiD_](https://www.aldeid.com/wiki/PEiD) gibidir.

### Manual

[Bu öğreticiyi okuyarak özelleştirilmiş obfuskasyonu tersine çevirme ile ilgili bazı püf noktalarını öğrenin](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b, ubuntu-mate tabanlı bir Android security virtual machine'dir; reverse engineering ve malware analysis için farklı güvenlik meraklıları ve araştırmacılardan gelen en güncel framework, eğitim ve lab koleksiyonlarını içerir.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Harika bir kaynak listesi
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android hızlı kursu
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)

## Yet to try

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
