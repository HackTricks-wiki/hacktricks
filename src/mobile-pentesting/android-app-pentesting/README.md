# Εφαρμογές Android Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Βασικά για Εφαρμογές Android

Συνιστάται ιδιαίτερα να ξεκινήσετε διαβάζοντας αυτή τη σελίδα για να γνωρίσετε τα **πιο σημαντικά στοιχεία σχετικά με την ασφάλεια Android και τα πιο επικίνδυνα συστατικά σε μια εφαρμογή Android**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Αυτό είναι το κύριο εργαλείο που χρειάζεστε για να συνδεθείτε με μια συσκευή Android (εξομοιωμένη ή φυσική).\
**ADB** επιτρέπει τον έλεγχο συσκευών είτε μέσω **USB** είτε μέσω **Network** από έναν υπολογιστή. Αυτό το εργαλείο επιτρέπει την **αντιγραφή** αρχείων και στις δύο κατευθύνσεις, την **εγκατάσταση** και **απεγκατάσταση** εφαρμογών, την **εκτέλεση** εντολών shell, τη **δημιουργία αντιγράφων ασφαλείας** δεδομένων, την **ανάγνωση** των logs, μεταξύ άλλων λειτουργιών.

Ρίξτε μια ματιά στην παρακάτω λίστα των [**ADB Commands**](adb-commands.md) για να μάθετε πώς να χρησιμοποιείτε το adb.

## Smali

Μερικές φορές είναι ενδιαφέρον να **τροποποιήσετε τον κώδικα της εφαρμογής** για να αποκτήσετε πρόσβαση σε **κρυφές πληροφορίες** (π.χ. πολύ καλά obfuscated passwords ή flags). Σε αυτή την περίπτωση, μπορεί να είναι ενδιαφέρον να αποσυμπιλέξετε το apk, να τροποποιήσετε τον κώδικα και να το επανασυμπιέσετε.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Αυτό μπορεί να είναι πολύ χρήσιμο ως **εναλλακτική για αρκετές δοκιμές κατά τη διάρκεια της dynamic analysis** που πρόκειται να παρουσιαστούν. Επομένως, **έχετε πάντα υπόψη αυτήν την πιθανότητα**.

## Άλλα ενδιαφέροντα κόλπα

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Εξαγωγή APK από τη συσκευή:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Συγχώνευσε όλα τα splits και τα base apks με [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Μελέτες Περιπτώσεων & Ευπάθειες


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Στατική Ανάλυση

Πρώτα απ' όλα, για την ανάλυση ενός APK πρέπει **να ρίξετε μια ματιά στον κώδικα Java** χρησιμοποιώντας έναν decompiler.\
Παρακαλώ, [**διαβάστε εδώ για να βρείτε πληροφορίες σχετικά με διαφορετικούς διαθέσιμους decompilers**](apk-decompilers.md).

### Αναζήτηση ενδιαφέρουσων πληροφοριών

Απλά κοιτάζοντας τα **strings** του APK μπορείτε να ψάξετε για **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** και οτιδήποτε ενδιαφέρον... ψάξτε ακόμα για code execution **backdoors** ή authentication backdoors (hardcoded admin credentials στην εφαρμογή).

**Firebase**

Δώστε ιδιαίτερη προσοχή στα **firebase URLs** και ελέγξτε αν είναι κακώς ρυθμισμένα. [Περισσότερες πληροφορίες σχετικά με το τι είναι το Firebase και πώς να το εκμεταλλευτείτε εδώ.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Βασική κατανόηση της εφαρμογής - Manifest.xml, strings.xml

Η **εξέταση των αρχείων _Manifest.xml_ και _strings.xml_ μιας εφαρμογής μπορεί να αποκαλύψει πιθανούς κινδύνους ασφαλείας**. Αυτά τα αρχεία μπορούν να προσπελαστούν χρησιμοποιώντας decompilers ή με την αλλαγή της επέκτασης αρχείου του APK σε .zip και αποσυμπίεση.

**Οι ευπάθειες** που εντοπίζονται από το **Manifest.xml** περιλαμβάνουν:

- **Debuggable Applications**: Εφαρμογές που ορίζονται ως debuggable (`debuggable="true"`) στο _Manifest.xml_ αποτελούν κίνδυνο καθώς επιτρέπουν συνδέσεις που μπορούν να οδηγήσουν σε εκμετάλλευση. Για περισσότερη κατανόηση σχετικά με το πώς να εκμεταλλευτείτε debuggable εφαρμογές, ανατρέξτε σε έναν οδηγό για την εύρεση και εκμετάλλευση debuggable εφαρμογών σε μια συσκευή.
- **Backup Settings**: Το attribute `android:allowBackup="false"` πρέπει να ορίζεται ρητά για εφαρμογές που διαχειρίζονται ευαίσθητες πληροφορίες ώστε να αποτρέπονται μη εξουσιοδοτημένα backups δεδομένων μέσω adb, ειδικά όταν το usb debugging είναι ενεργοποιημένο.
- **Network Security**: Προσαρμοσμένες ρυθμίσεις network security (`android:networkSecurityConfig="@xml/network_security_config"`) σε _res/xml/_ μπορούν να καθορίσουν λεπτομέρειες ασφαλείας όπως certificate pins και ρυθμίσεις HTTP traffic. Ένα παράδειγμα είναι η επιτρεψή του HTTP traffic για συγκεκριμένα domains.
- **Exported Activities and Services**: Ο εντοπισμός exported activities και services στο manifest μπορεί να αναδείξει components που θα μπορούσαν να χρησιμοποιηθούν καταχρηστικά. Περαιτέρω ανάλυση κατά τη διάρκεια dynamic testing μπορεί να αποκαλύψει πώς να εκμεταλλευτείτε αυτά τα components.
- **Content Providers and FileProviders**: Εκτεθειμένοι content providers θα μπορούσαν να επιτρέψουν μη εξουσιοδοτημένη πρόσβαση ή τροποποίηση δεδομένων. Η διαμόρφωση των FileProviders πρέπει επίσης να ελεγχθεί προσεκτικά.
- **Broadcast Receivers and URL Schemes**: Αυτά τα components θα μπορούσαν να αξιοποιηθούν για εκμετάλλευση, με ιδιαίτερη προσοχή στο πώς τα URL schemes διαχειρίζονται καθώς μπορεί να έχουν input vulnerabilities.
- **SDK Versions**: Τα attributes `minSdkVersion`, `targetSDKVersion`, και `maxSdkVersion` υποδεικνύουν τις υποστηριζόμενες εκδόσεις Android, τονίζοντας τη σημασία να μην υποστηρίζονται παρωχημένες, ευάλωτες εκδόσεις Android για λόγους ασφάλειας.

Από το αρχείο **strings.xml** μπορούν να εντοπιστούν ευαίσθητες πληροφορίες όπως API keys, custom schemas και άλλες σημειώσεις των developers, υπογραμμίζοντας την ανάγκη προσεκτικής αναθεώρησης αυτών των resources.

### Tapjacking

**Tapjacking** είναι μια επίθεση όπου μια κακόβουλη εφαρμογή εκκινείται και τοποθετείται πάνω από μια εφαρμογή-θύμα. Μόλις καλύψει ορατά την εφαρμογή-θύμα, η διεπαφή χρήστη της σχεδιάζεται έτσι ώστε να παραπλανά τον χρήστη να αλληλεπιδράσει με αυτήν, ενώ παράλληλα προωθεί την αλληλεπίδραση στην εφαρμογή-θύμα.\
Στην ουσία, τυφλώνει τον χρήστη ώστε να μην γνωρίζει ότι πραγματικά εκτελεί ενέργειες στην εφαρμογή-θύμα.

Βρείτε περισσότερες πληροφορίες στο:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Μια **activity** με το **`launchMode`** ορισμένο σε **`singleTask` χωρίς να έχει οριστεί `taskAffinity`** είναι ευάλωτη σε task Hijacking. Αυτό σημαίνει ότι μια εφαρμογή μπορεί να εγκατασταθεί και αν εκκινηθεί πριν από την πραγματική εφαρμογή να **καταλάβει το task της πραγματικής εφαρμογής** (ώστε ο χρήστης να αλληλεπιδρά με την **κακόβουλη εφαρμογή νομίζοντας ότι χρησιμοποιεί την πραγματική**).

Περισσότερες πληροφορίες στο:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Μη ασφαλής αποθήκευση δεδομένων

**Internal Storage**

Στο Android, αρχεία που **αποθηκεύονται** στην **internal** storage έχουν σχεδιαστεί ώστε να είναι προσβάσιμα αποκλειστικά από την **εφαρμογή** που τα **δημιούργησε**. Αυτό το μέτρο ασφάλειας επιβάλλεται από το Android operating system και είναι γενικά επαρκές για τις ανάγκες ασφάλειας των περισσοτέρων εφαρμογών. Ωστόσο, οι developers μερικές φορές χρησιμοποιούν modes όπως `MODE_WORLD_READABLE` και `MODE_WORLD_WRITABLE` για να **επιτρέψουν** την κοινή χρήση αρχείων μεταξύ διαφορετικών εφαρμογών. Αυτά τα modes, όμως, **δεν περιορίζουν την πρόσβαση** σε αυτά τα αρχεία από άλλες εφαρμογές, συμπεριλαμβανομένων πιθανώς κακόβουλων.

1. **Static Analysis:**
- **Βεβαιωθείτε** ότι η χρήση των `MODE_WORLD_READABLE` και `MODE_WORLD_WRITABLE` εξετάζεται **προσεκτικά**. Αυτά τα modes **μπορούν ενδεχομένως να εκθέσουν** αρχεία σε **μη επιθυμητή ή μη εξουσιοδοτημένη πρόσβαση**.
2. **Dynamic Analysis:**
- **Επαληθεύστε** τα **permissions** που έχουν οριστεί στα αρχεία που δημιουργεί η εφαρμογή. Συγκεκριμένα, **ελέγξτε** αν κάποια αρχεία είναι **ρυθμισμένα ώστε να είναι readable ή writable worldwide**. Αυτό μπορεί να αποτελεί σημαντικό κίνδυνο ασφαλείας, καθώς θα επέτρεπε σε **οποιαδήποτε εφαρμογή** εγκατεστημένη στη συσκευή, ανεξαρτήτως προέλευσης ή σκοπού, να **διαβάσει ή να τροποποιήσει** αυτά τα αρχεία.

**External Storage**

Όταν χειρίζεστε αρχεία σε **external storage**, όπως SD Cards, πρέπει να ληφθούν υπόψη ορισμένες προφυλάξεις:

1. **Accessibility**:
- Τα αρχεία στο external storage είναι **globally readable and writable**. Αυτό σημαίνει ότι οποιαδήποτε εφαρμογή ή χρήστης μπορεί να έχει πρόσβαση σε αυτά τα αρχεία.
2. **Security Concerns**:
- Δε συνιστάται να αποθηκεύετε ευαίσθητες πληροφορίες στο external storage λόγω της εύκολης πρόσβασης.
- Το external storage μπορεί να αφαιρεθεί ή να προσπελαστεί από οποιαδήποτε εφαρμογή, καθιστώντας το λιγότερο ασφαλές.
3. **Handling Data from External Storage**:
- Πάντα **εκτελέστε input validation** στα δεδομένα που ανακτώνται από το external storage. Αυτό είναι κρίσιμο επειδή τα δεδομένα προέρχονται από μια μη αξιόπιστη πηγή.
- Η αποθήκευση εκτελέσιμων ή class files στο external storage για dynamic loading αποθαρρύνεται έντονα.
- Αν η εφαρμογή σας πρέπει να ανακτήσει εκτελέσιμα αρχεία από το external storage, βεβαιωθείτε ότι αυτά τα αρχεία είναι **signed και cryptographically verified** πριν γίνουν dynamic loaded. Αυτό το βήμα είναι ζωτικής σημασίας για τη διατήρηση της ακεραιότητας ασφάλειας της εφαρμογής σας.

External storage μπορεί να **προσπελαστεί** στα `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> Από το Android 4.4 (**API 17**) και μετά, η SD card έχει μια δομή directories που **περιορίζει την πρόσβαση μιας εφαρμογής στον κατάλογο που είναι ειδικά για αυτήν την εφαρμογή**. Αυτό αποτρέπει κακόβουλες εφαρμογές από το να αποκτήσουν read ή write πρόσβαση στα αρχεία άλλης εφαρμογής.

**Ευαίσθητα δεδομένα αποθηκευμένα σε απλό κείμενο**

- **Shared preferences**: Το Android επιτρέπει σε κάθε εφαρμογή να αποθηκεύει εύκολα αρχεία xml στη διαδρομή `/data/data/<packagename>/shared_prefs/` και μερικές φορές είναι δυνατόν να βρεθούν ευαίσθητες πληροφορίες σε clear-text σε αυτόν τον φάκελο.
- **Databases**: Το Android επιτρέπει σε κάθε εφαρμογή να αποθηκεύει εύκολα sqlite databases στη διαδρομή `/data/data/<packagename>/databases/` και μερικές φορές είναι δυνατόν να βρεθούν ευαίσθητες πληροφορίες σε clear-text σε αυτόν τον φάκελο.

### Σπασμένο TLS

**Accept All Certificates**

Για κάποιο λόγο, μερικές φορές οι developers αποδέχονται όλα τα πιστοποιητικά ακόμα και αν, για παράδειγμα, το hostname δεν ταιριάζει, με γραμμές κώδικα όπως η ακόλουθη:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a πιστοποιητικό for a different hostname and use it.

### Ελαττωματική Κρυπτογραφία

**Κακές διαδικασίες διαχείρισης κλειδιών**

Κάποιοι developers αποθηκεύουν ευαίσθητα δεδομένα στο local storage και τα κρυπτογραφούν με ένα key hardcoded/predictable στον κώδικα. Αυτό δεν πρέπει να γίνεται καθώς κάποιο reversing θα μπορούσε να επιτρέψει σε attackers να εξάγουν τις εμπιστευτικές πληροφορίες.

**Use of Insecure and/or Deprecated Algorithms**

Οι developers δεν πρέπει να χρησιμοποιούν **deprecated algorithms** για να πραγματοποιούν authorisation **checks**, **store** ή **send** δεδομένα. Μερικοί από αυτούς τους αλγορίθμους είναι: RC4, MD4, MD5, SHA1... Αν χρησιμοποιούνται **hashes** για να αποθηκεύσουν passwords για παράδειγμα, πρέπει να χρησιμοποιούνται hashes ανθεκτικά σε brute-force με salt.

### Άλλοι έλεγχοι

- Συνιστάται να **obfuscate the APK** για να δυσκολέψετε το έργο του reverse engineer στους attackers.
- Αν η app είναι ευαίσθητη (όπως bank apps), θα πρέπει να πραγματοποιεί δικούς της ελέγχους για να δει αν το mobile είναι **rooted** και να ενεργεί ανάλογα.
- Αν η app είναι ευαίσθητη (όπως bank apps), θα πρέπει να ελέγχει αν χρησιμοποιείται **emulator**.
- Αν η app είναι ευαίσθητη (όπως bank apps), θα πρέπει να **ελέγχει την ακεραιότητά της πριν την εκτέλεση** για να διαπιστώσει αν έχει τροποποιηθεί.
- Χρησιμοποιήστε [**APKiD**](https://github.com/rednaga/APKiD) για να δείτε ποιος compiler/packer/obfuscator χρησιμοποιήθηκε για να χτιστεί το APK

### Εφαρμογή React Native

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Εφαρμογές Xamarin

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

Το εργαλείο [**mariana-trench**](https://github.com/facebook/mariana-trench) είναι ικανό να εντοπίζει **vulnerabilities** σαρώνοντας τον **code** της εφαρμογής. Αυτό το εργαλείο περιέχει μια σειρά από **known sources** (που δείχνουν στο εργαλείο τα **σημεία** όπου το **input** ελέγχεται από τον χρήστη), **sinks** (που δείχνουν στο εργαλείο **επικίνδυνα** **σημεία** όπου κακόβουλο input χρήστη μπορεί να προκαλέσει ζημιά) και **rules**. Αυτοί οι κανόνες υποδεικνύουν τον **συνδυασμό** **sources-sinks** που υποδηλώνει μια vulnerability.

Με αυτή τη γνώση, **mariana-trench will review the code and find possible vulnerabilities on it**.

### Secrets leaked

An application may contain secrets (API keys, passwords, hidden urls, subdomains...) inside of it that you might be able to discover. You could us a tool such as [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> First of all, you need an environment where you can install the application and all the environment (Burp CA cert, Drozer and Frida mainly). Therefore, a rooted device (emulated or not) is extremely recommended.

### Online Dynamic analysis

Μπορείτε να δημιουργήσετε έναν **free account** στο: [https://appetize.io/](https://appetize.io). Αυτή η πλατφόρμα επιτρέπει να **upload** και να **execute** APKs, οπότε είναι χρήσιμη για να δείτε πώς συμπεριφέρεται ένα apk.

Μπορείτε ακόμα να **δειτε τα logs της εφαρμογής** στο web και να συνδεθείτε μέσω **adb**.

![](<../../images/image (831).png>)

Χάρη στη σύνδεση ADB μπορείτε να χρησιμοποιήσετε **Drozer** και **Frida** μέσα στους emulators.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (Μπορείτε να δημιουργήσετε **x86** και **arm** συσκευές, και σύμφωνα με [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** versions **support ARM libraries** without needing an slow arm emulator).
- Learn to set it up in this page:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, χρειάζεται να δημιουργήσετε account. _It's recommend to **download** the version **WITH**_ _**VirtualBox** to avoid potential errors._)
- [**Nox**](https://es.bignox.com) (Free, αλλά δεν υποστηρίζει Frida ή Drozer).

> [!TIP]
> Όταν δημιουργείτε ένα νέο emulator σε οποιαδήποτε πλατφόρμα θυμηθείτε ότι όσο μεγαλύτερη είναι η οθόνη τόσο πιο αργά θα τρέχει ο emulator. Οπότε επιλέξτε μικρές οθόνες αν είναι δυνατό.

Για να **install google services** (όπως AppStore) στο Genymotion πρέπει να κάνετε κλικ στο κόκκινο κουμπί όπως στην εικόνα:

![](<../../images/image (277).png>)

Επίσης, παρατηρήστε ότι στην **διαμόρφωση του Android VM στο Genymotion** μπορείτε να επιλέξετε **Bridge Network mode** (αυτό θα είναι χρήσιμο αν σκοπεύετε να συνδεθείτε στο Android VM από ένα διαφορετικό VM με τα εργαλεία).

#### Use a physical device

Πρέπει να ενεργοποιήσετε τις **debugging** επιλογές και θα είναι καλό αν μπορέσετε να το **root**:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Μόλις εγκαταστήσετε την εφαρμογή, το πρώτο πράγμα που πρέπει να κάνετε είναι να τη δοκιμάσετε, να διερευνήσετε τι κάνει, πώς λειτουργεί και να εξοικειωθείτε με αυτή.\
> Προτείνω να **εκτελέσετε αυτή την αρχική δυναμική ανάλυση χρησιμοποιώντας MobSF dynamic analysis + pidcat**, έτσι ώστε να μπορέσουμε να **μάθουμε πώς λειτουργεί η εφαρμογή** ενώ το MobSF **captures** πολλά **interesting** **data** που μπορείτε να εξετάσετε αργότερα.

### Unintended Data Leakage

**Logging**

Οι developers πρέπει να είναι προσεκτικοί με την έκθεση **debugging information** δημόσια, καθώς μπορεί να οδηγήσει σε ευαίσθητα data leaks. Τα εργαλεία [**pidcat**](https://github.com/JakeWharton/pidcat) και `adb logcat` συνιστώνται για την παρακολούθηση των application logs ώστε να εντοπιστούν και να προστατευθούν ευαίσθητες πληροφορίες. Το **Pidcat** προτιμάται για την ευκολία χρήσης και την αναγνωσιμότητα.

> [!WARNING]
> Σημειώστε ότι από **εκδόσεις μεταγενέστερες του Android 4.0**, **οι εφαρμογές μπορούν να έχουν πρόσβαση μόνο στα δικά τους logs**. Έτσι, οι εφαρμογές δεν μπορούν να προσεγγίσουν logs άλλων apps.\
> Παρ' όλα αυτά, εξακολουθεί να συνιστάται να **μην καταγράφετε ευαίσθητες πληροφορίες**.

**Copy/Paste Buffer Caching**

Το Android **clipboard-based** framework επιτρέπει λειτουργίες copy-paste στις εφαρμογές, αλλά αποτελεί ρίσκο καθώς **άλλες εφαρμογές** μπορούν να έχουν **access** στο clipboard, εκθέτοντας ενδεχομένως ευαίσθητα δεδομένα. Είναι κρίσιμο να **απενεργοποιούνται οι copy/paste** λειτουργίες για ευαίσθητες ενότητες μιας εφαρμογής, όπως λεπτομέρειες πιστωτικών καρτών, για να αποφευχθούν data leaks.

**Crash Logs**

Αν μια εφαρμογή **crashes** και **αποθηκεύει logs**, αυτά τα logs μπορούν να βοηθήσουν attackers, ιδιαίτερα όταν η εφαρμογή δεν μπορεί να γίνει reverse-engineered. Για να μετριάσετε αυτόν τον κίνδυνο, αποφύγετε το logging σε crashes, και αν πρέπει να μεταδοθούν logs μέσω δικτύου βεβαιωθείτε ότι αποστέλλονται μέσω SSL καναλιού για ασφάλεια.

Ως pentester, **try to take a look to these logs**.

**Analytics Data Sent To 3rd Parties**

Οι εφαρμογές συχνά ενσωματώνουν υπηρεσίες όπως Google Adsense, που μπορεί ακούσια να **leak sensitive data** λόγω εσφαλμένης υλοποίησης από τους developers. Για να εντοπίσετε πιθανές διαρροές, είναι χρήσιμο να **intercept the application's traffic** και να ελέγξετε αν ευαίσθητες πληροφορίες αποστέλλονται σε third-party services.

### SQLite DBs

Οι περισσότερες εφαρμογές θα χρησιμοποιήσουν **internal SQLite databases** για να αποθηκεύσουν πληροφορίες. Κατά το pentest ρίξτε μια **ματιά** στις **databases** που δημιουργούνται, στα ονόματα των **tables** και **columns** και σε όλα τα **δεδομένα** που αποθηκεύονται γιατί μπορεί να βρείτε **ευαίσθητες πληροφορίες** (που θα αποτελούσαν vulnerability).\
Οι βάσεις δεδομένων θα πρέπει να βρίσκονται στο `/data/data/the.package.name/databases` όπως `/data/data/com.mwr.example.sieve/databases`

Αν η βάση δεδομένων αποθηκεύει εμπιστευτικές πληροφορίες και είναι **encrypted** αλλά μπορείτε να **find** τον **password** μέσα στην εφαρμογή, αυτό εξακολουθεί να είναι μια **vulnerability**.

Καταγράψτε τα tables με `.tables` και τις στήλες των tables με `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer is s useful tool to **exploit exported activities, exported services and Content Providers** as you will learn in the following sections.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Also remember that the code of an activity starts in the **`onCreate`** method.

**Authorisation bypass**

When an Activity is exported you can invoke its screen from an external app. Therefore, if an activity with **sensitive information** is **exported** you could **bypass** the **authentication** mechanisms **to access it.**

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

You can also start an exported activity from adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> Σημειώστε ότι ένα authorisation bypass δεν είναι πάντα μια ευπάθεια — εξαρτάται από το πώς λειτουργεί το bypass και ποιες πληροφορίες εκτίθενται.

**Sensitive information leakage**

**Activities can also return results**. Εάν καταφέρετε να εντοπίσετε μια exported και unprotected activity που καλεί τη μέθοδο **`setResult`** και **επιστρέφει ευαίσθητες πληροφορίες**, υπάρχει sensitive information leakage.

#### Tapjacking

Εάν το Tapjacking δεν αποτρέπεται, μπορείτε να καταχραστείτε την exported activity για να κάνετε τον **user να εκτελέσει απροσδόκητες ενέργειες**. For more info about [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Οι Content providers χρησιμοποιούνται βασικά για να **share data**. Εάν μια εφαρμογή έχει διαθέσιμους content providers μπορεί να είστε ικανοί να **εξάγετε ευαίσθητα** δεδομένα από αυτούς. Επίσης είναι ενδιαφέρον να ελέγξετε για πιθανές **SQL injections** και **Path Traversals** καθώς μπορεί να είναι ευάλωτοι.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Θυμηθείτε ότι οι ενέργειες ενός Service ξεκινούν στη μέθοδο `onStartCommand`.

Ένα Service είναι βασικά κάτι που **can receive data**, **process** it και **returns** (ή όχι) μια απάντηση. Έτσι, εάν μια εφαρμογή εξάγει κάποια services θα πρέπει να **ελέγξετε** τον **κώδικα** για να καταλάβετε τι κάνει και να το **δοκιμάσετε** **δυναμικά** για να εξάγετε εμπιστευτικές πληροφορίες, να παρακάμψετε μέτρα authentication...\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Θυμηθείτε ότι οι ενέργειες ενός Broadcast Receiver ξεκινούν στη μέθοδο `onReceive`.

Ένας broadcast receiver θα περιμένει έναν τύπο μηνύματος. Ανάλογα με το πώς ο receiver χειρίζεται το μήνυμα, θα μπορούσε να είναι ευάλωτος.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Μπορείτε να ψάξετε για deep links χειροκίνητα, χρησιμοποιώντας εργαλεία όπως το MobSF ή scripts όπως [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Μπορείτε να **open** ένα δηλωμένο **scheme** χρησιμοποιώντας **adb** ή έναν **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Σημειώστε ότι μπορείτε να **παραλείψετε το package name** και το κινητό θα καλέσει αυτόματα την εφαρμογή που θα πρέπει να ανοίξει αυτόν τον σύνδεσμο._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Κώδικας που εκτελείται**

Για να βρεις τον **κώδικα που θα εκτελεστεί στην App**, πήγαινε στην activity που καλείται από το deeplink και ψάξε τη συνάρτηση **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Ευαίσθητες πληροφορίες**

Κάθε φορά που βρίσκεις ένα deep link, έλεγξε ότι **δεν λαμβάνει ευαίσθητα δεδομένα (π.χ. κωδικούς) μέσω παραμέτρων URL**, γιατί οποιαδήποτε άλλη εφαρμογή θα μπορούσε **να μιμηθεί το deep link και να κλέψει αυτά τα δεδομένα!**

**Parameters in path**

Πρέπει επίσης να ελέγξεις αν κάποιο deep link χρησιμοποιεί παράμετρο μέσα στο path της URL όπως: `https://api.example.com/v1/users/{username}` , σε αυτή την περίπτωση μπορείς να προκαλέσεις path traversal προσπελάζοντας κάτι σαν: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Σημείωσε ότι αν βρεις τα σωστά endpoints μέσα στην εφαρμογή μπορεί να καταφέρεις να προκαλέσεις ένα **Open Redirect** (αν μέρος του path χρησιμοποιείται ως domain name), **account takeover** (αν μπορείς να τροποποιήσεις στοιχεία χρηστών χωρίς CSRF token και το vuln endpoint χρησιμοποιούσε τη σωστή μέθοδο) και οποιοδήποτε άλλο vuln. Περισσότερες [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Transport Layer Inspection and Verification Failures

- **Certificates are not always inspected properly** από τις Android εφαρμογές. Είναι συνηθισμένο αυτές οι εφαρμογές να αγνοούν προειδοποιήσεις και να αποδέχονται self-signed certificates ή, σε κάποιες περιπτώσεις, να επιστρέφουν στη χρήση HTTP connections.
- **Negotiations during the SSL/TLS handshake are sometimes weak**, χρησιμοποιώντας insecure cipher suites. Αυτή η ευπάθεια κάνει τη σύνδεση επιρρεπή σε man-in-the-middle (MITM) attacks, επιτρέποντας σε επιτιθέμενους να αποκρυπτογραφήσουν τα δεδομένα.
- **Leakage of private information** είναι ένας κίνδυνος όταν εφαρμογές αυθεντικοποιούνται χρησιμοποιώντας secure channels αλλά μετά επικοινωνούν μέσω non-secure channels για άλλες συναλλαγές. Αυτή η προσέγγιση δεν προστατεύει ευαίσθητα δεδομένα, όπως session cookies ή στοιχεία χρηστών, από την υποκλοπή από κακόβουλους φορείς.

#### Certificate Verification

Θα επικεντρωθούμε στην **certificate verification**. Η ακεραιότητα του server's certificate πρέπει να επαληθεύεται για να ενισχυθεί η ασφάλεια. Αυτό είναι κρίσιμο επειδή insecure TLS configurations και η μετάδοση ευαίσθητων δεδομένων πάνω από μη κρυπτογραφημένα κανάλια μπορούν να θέσουν σημαντικούς κινδύνους. Για αναλυτικά βήματα σχετικά με την επαλήθευση server certificates και την επιδιόρθωση ευπαθειών, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) παρέχει πλήρεις οδηγίες.

#### SSL Pinning

SSL Pinning είναι ένα μέτρο ασφαλείας όπου η εφαρμογή επαληθεύει το server's certificate σε σχέση με ένα γνωστό αντίγραφο που αποθηκεύεται μέσα στην εφαρμογή. Αυτή η μέθοδος είναι απαραίτητη για την πρόληψη MITM attacks. Η υλοποίηση SSL Pinning συνιστάται έντονα για εφαρμογές που χειρίζονται ευαίσθητες πληροφορίες.

#### Traffic Inspection

Για να ελέγξεις HTTP traffic, είναι απαραίτητο να **εγκαταστήσεις το certificate του proxy tool** (π.χ. Burp). Χωρίς την εγκατάσταση αυτού του πιστοποιητικού, το κρυπτογραφημένο traffic μπορεί να μην είναι ορατό μέσω του proxy. Για οδηγό σχετικά με την εγκατάσταση custom CA certificate, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Εφαρμογές που στοχεύουν **API Level 24 and above** απαιτούν τροποποιήσεις στο Network Security Config για να αποδεχθούν το proxy's CA certificate. Αυτό το βήμα είναι κρίσιμο για την επιθεώρηση κρυπτογραφημένου traffic. Για οδηγίες σχετικά με την τροποποίηση του Network Security Config, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

Αν χρησιμοποιείται **Flutter** πρέπει να ακολουθήσεις τις οδηγίες στη [**this page**](flutter.md). Αυτό συμβαίνει επειδή, απλά προσθέτοντας το certificate στο store δεν θα λειτουργήσει καθώς το Flutter έχει τη δική του λίστα με έγκυρα CAs.

#### Static detection of SSL/TLS pinning

Πριν επιχειρήσεις runtime bypasses, κάνε γρήγορο mapping του που εφαρμόζεται pinning στο APK. Η στατική ανακάλυψη βοηθά να σχεδιάσεις hooks/patches και να επικεντρωθείς στα σωστά code paths.

Tool: SSLPinDetect
- Open-source static-analysis utility που decompiles το APK σε Smali (via apktool) και σαρώνει για curated regex patterns υλοποιήσεων SSL/TLS pinning.
- Αναφέρει ακριβές file path, αριθμό γραμμής, και ένα code snippet για κάθε match.
- Καλύπτει κοινά frameworks και custom code paths: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Χρήση
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Παραδείγματα κανόνων pattern (JSON)
Χρησιμοποιήστε ή επεκτείνετε signatures για να εντοπίσετε proprietary/custom pinning styles. Μπορείτε να φορτώσετε το δικό σας JSON και να σαρώσετε σε μεγάλη κλίμακα.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes and tips
- Γρήγορη σάρωση μεγάλων εφαρμογών μέσω multi-threading και memory-mapped I/O; προ-συμπιεσμένα regex μειώνουν την επιβάρυνση και τα ψευδώς θετικά.
- Συλλογή patterns: https://github.com/aancw/smali-sslpin-patterns
- Τυπικοί στόχοι ανίχνευσης για περαιτέρω αξιολόγηση:
- OkHttp: χρήση CertificatePinner, setCertificatePinner, αναφορές πακέτου okhttp3/okhttp
- Custom TrustManagers: javax.net.ssl.X509TrustManager, overrides του checkServerTrusted
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init με custom managers
- Declarative pins στο res/xml network security config και αναφορές στο manifest
- Χρησιμοποιήστε τις αντιστοιχισμένες τοποθεσίες για να σχεδιάσετε Frida hooks, static patches ή ελέγχους config πριν από dynamic testing.



#### Bypassing SSL Pinning

Όταν το SSL Pinning εφαρμόζεται, η παράκαμψή του γίνεται απαραίτητη για την επιθεώρηση της HTTPS κίνησης. Υπάρχουν διάφορες μέθοδοι για αυτό:

- Αυτόματη **τροποποίηση** του **apk** για **παράκαμψη** SSLPinning με [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Το μεγαλύτερο πλεονέκτημα αυτής της επιλογής είναι ότι δεν θα χρειαστείτε root για να παρακάμψετε το SSL Pinning, αλλά θα χρειαστεί να διαγράψετε την εφαρμογή και να εγκαταστήσετε ξανά τη νέα, και αυτό δεν δουλεύει πάντα.
- Μπορείτε να χρησιμοποιήσετε **Frida** (αναφέρεται παρακάτω) για να παρακάμψετε αυτήν την προστασία. Εδώ έχετε έναν οδηγό για τη χρήση Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Μπορείτε επίσης να δοκιμάσετε να **αυτόματα παρακάμψετε** το SSL Pinning χρησιμοποιώντας [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Μπορείτε επίσης να δοκιμάσετε να **αυτόματα παρακάμψετε** το SSL Pinning χρησιμοποιώντας **MobSF dynamic analysis** (εξηγείται παρακάτω)
- Εάν ακόμα νομίζετε ότι υπάρχει κίνηση που δεν καταγράφετε, μπορείτε να δοκιμάσετε να **προωθήσετε την κίνηση στο burp χρησιμοποιώντας iptables**. Διαβάστε αυτό το blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Looking for Common Web Vulnerabilities

Είναι σημαντικό επίσης να αναζητήσετε κοινές web ευπάθειες μέσα στην εφαρμογή. Αναλυτικές πληροφορίες για τον εντοπισμό και την αντιμετώπιση αυτών των ευπαθειών υπερβαίνουν το πεδίο αυτής της περίληψης αλλά καλύπτονται εκτενώς αλλού.

### Frida

[Frida](https://www.frida.re) είναι ένα dynamic instrumentation toolkit για developers, reverse-engineers και security researchers.\
**Μπορείτε να έχετε πρόσβαση σε μια τρέχουσα εφαρμογή και να κάνετε hook μεθόδους σε runtime για να αλλάξετε τη συμπεριφορά, να αλλάξετε τιμές, να εξάγετε τιμές, να τρέξετε διαφορετικό κώδικα...**\
Αν θέλετε να pentest εφαρμογές Android πρέπει να ξέρετε πώς να χρησιμοποιείτε το Frida.

- Μάθετε πώς να χρησιμοποιείτε το Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Κάποιες "GUI" λύσεις για ενέργειες με Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection είναι εξαιρετικό για την αυτοματοποίηση της χρήσης του Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Μπορείτε να βρείτε μερικά Awesome Frida scripts εδώ: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Δοκιμάστε να παρακάμψετε anti-debugging / anti-frida μηχανισμούς φορτώνοντας το Frida όπως υποδεικνύεται στο [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (εργαλείο [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

Ελέγξτε αν η εφαρμογή αποθηκεύει ευαίσθητες πληροφορίες στη μνήμη που δεν θα έπρεπε, όπως passwords ή mnemonics.

Χρησιμοποιώντας [**Fridump3**](https://github.com/rootbsd/fridump3) μπορείτε να κάνετε dump τη μνήμη της εφαρμογής με:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Αυτό θα κάνει dump τη μνήμη στον φάκελο ./dump, και εκεί μπορείτε να κάνετε grep με κάτι σαν:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Ευαίσθητα δεδομένα στο Keystore**

Στο Android, το Keystore είναι το καλύτερο μέρος για να αποθηκεύσετε ευαίσθητα δεδομένα, ωστόσο, με επαρκή προνόμια εξακολουθεί να είναι **δυνατό να αποκτηθεί πρόσβαση σε αυτό**.

Δεδομένου ότι οι εφαρμογές τείνουν να αποθηκεύουν εδώ **ευαίσθητα δεδομένα σε απλό κείμενο**, τα pentests πρέπει να το ελέγχουν ως root χρήστης, διότι κάποιος με φυσική πρόσβαση στη συσκευή μπορεί να καταφέρει να κλέψει αυτά τα δεδομένα.

Ακόμα κι αν μια εφαρμογή αποθήκευσε δεδομένα στο keystore, αυτά θα πρέπει να είναι κρυπτογραφημένα.

Για να αποκτήσετε πρόσβαση στα δεδομένα μέσα στο keystore μπορείτε να χρησιμοποιήσετε αυτό το Frida script: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Χρησιμοποιώντας το παρακάτω Frida script, ενδέχεται να είναι δυνατό να **bypass fingerprint authentication** που πιθανώς εφαρμόζουν οι Android εφαρμογές για να **προστατεύσουν ορισμένες ευαίσθητες περιοχές:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Εικόνες φόντου**

Όταν τοποθετείτε μια εφαρμογή στο παρασκήνιο, το Android αποθηκεύει ένα **στιγμιότυπο της εφαρμογής** ώστε όταν επανέλθει στο προσκήνιο να αρχίσει να φορτώνει την εικόνα πριν από την εφαρμογή, ώστε να φαίνεται ότι η εφαρμογή φορτώθηκε πιο γρήγορα.

Ωστόσο, αν αυτό το στιγμιότυπο περιέχει **ευαίσθητες πληροφορίες**, κάποιος με πρόσβαση στο στιγμιότυπο μπορεί να **κλέψει αυτές τις πληροφορίες** (σημείωση: χρειάζεστε root για να έχετε πρόσβαση).

Τα στιγμιότυπα συνήθως αποθηκεύονται στο: **`/data/system_ce/0/snapshots`**

Το Android παρέχει έναν τρόπο για **να αποτρέψει τη λήψη στιγμιότυπων οθόνης ρυθμίζοντας το layout parameter FLAG_SECURE**. Χρησιμοποιώντας αυτή τη σημαία, το περιεχόμενο του παραθύρου θεωρείται ασφαλές, αποτρέποντας την εμφάνισή του σε στιγμιότυπα οθόνης ή την προβολή του σε μη ασφαλείς οθόνες.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Αυτό το εργαλείο μπορεί να σας βοηθήσει να διαχειριστείτε διαφορετικά εργαλεία κατά τη dynamic analysis: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Οι developers συχνά δημιουργούν proxy components όπως activities, services και broadcast receivers που χειρίζονται αυτά τα Intents και τα περνούν σε μεθόδους όπως `startActivity(...)` ή `sendBroadcast(...)`, κάτι που μπορεί να είναι επικίνδυνο.

Ο κίνδυνος έγκειται στο να επιτρέπονται σε επιτιθέμενους να ενεργοποιούν non-exported app components ή να αποκτούν πρόσβαση σε ευαίσθητους content providers παραπλανώντας αυτά τα Intents. Ένα αξιοσημείωτο παράδειγμα είναι το `WebView` component που μετατρέπει URLs σε αντικείμενα `Intent` μέσω `Intent.parseUri(...)` και στη συνέχεια τα εκτελεί, ενδεχομένως οδηγώντας σε malicious Intent injections.

### Essential Takeaways

- **Intent Injection** είναι παρόμοιο με το web Open Redirect issue.
- Exploits περιλαμβάνουν το πέρασμα αντικειμένων `Intent` ως extras, τα οποία μπορούν να ανακατευθυνθούν για να εκτελέσουν μη ασφαλείς ενέργειες.
- Μπορεί να εκθέσει non-exported components και content providers σε επιτιθέμενους.
- Η μετατροπή URL σε `Intent` από το `WebView` μπορεί να διευκολύνει ανεπιθύμητες ενέργειες.

### Android Client Side Injections and others

Πιθανώς γνωρίζετε αυτού του είδους τις ευπάθειες από το Web. Πρέπει να είστε ιδιαιτέρως προσεκτικοί με αυτές τις ευπάθειες σε μια Android εφαρμογή:

- **SQL Injection:** Όταν χειρίζεστε dynamic queries ή Content-Providers βεβαιωθείτε ότι χρησιμοποιείτε parameterized queries.
- **JavaScript Injection (XSS):** Επιβεβαιώστε ότι το JavaScript και το Plugin support είναι απενεργοποιημένα για οποιαδήποτε WebViews (απενεργοποιημένα από προεπιλογή). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** Οι WebViews θα πρέπει να έχουν την πρόσβαση στο file system απενεργοποιημένη (ενεργοποιημένη από προεπιλογή) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: Σε αρκετές περιπτώσεις όταν η android εφαρμογή τελειώνει το session, το cookie δεν ανακαλείται ή μπορεί ακόμη και να αποθηκευτεί στο δίσκο
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Static analysis**

![](<../../images/image (866).png>)

Αξιολόγηση ευπαθειών της εφαρμογής χρησιμοποιώντας ένα όμορφο web-based frontend. Μπορείτε επίσης να πραγματοποιήσετε dynamic analysis (αλλά πρέπει να προετοιμάσετε το περιβάλλον).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Σημειώστε ότι το MobSF μπορεί να αναλύσει **Android**(apk), **IOS**(ipa) και **Windows**(apx) εφαρμογές (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Επίσης, αν δημιουργήσετε ένα **ZIP** αρχείο με τον source code μιας **Android** ή μιας **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), θα μπορεί να το αναλύσει κι αυτό.

MobSF επίσης επιτρέπει να κάνετε **diff/Compare** analysis και να ενσωματώσετε το **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). Μπορείτε επίσης να θέσετε `VT_UPLOAD` σε `False`, τότε το **hash** θα γίνει **upload** αντί του αρχείου.

### Βοηθούμενη Dynamic analysis με MobSF

**MobSF** μπορεί επίσης να είναι πολύ χρήσιμο για **dynamic analysis** σε **Android**, αλλά σε αυτή την περίπτωση θα χρειαστεί να εγκαταστήσετε το MobSF και το **genymotion** στον host σας (a VM or Docker won't work). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
Ο **MobSF dynamic analyser** μπορεί να:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). Όλα αυτά γίνονται αυτόματα εκτός από τα screenshots — πρέπει να πατήσετε όταν θέλετε ένα screenshot ή να πατήσετε "**Exported Activity Tester**" για να λάβετε screenshots όλων των exported activities.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

Από Android **versions > 5**, θα **ξεκινήσει αυτόματα Frida** και θα ορίσει global **proxy** settings για να **capture** το traffic. Θα καταγράφει μόνο το traffic από την εφαρμογή υπό δοκιμή.

**Frida**

Εξ ορισμού, θα χρησιμοποιήσει επίσης μερικά Frida Scripts για να **bypass SSL pinning**, **root detection** και **debugger detection** και για να **monitor interesting APIs**.\
Το MobSF μπορεί επίσης να **invoke exported activities**, να τραβήξει **screenshots** από αυτές και να τα **save** για την αναφορά.

Για να **start** το dynamic testing πατήστε το πράσινο κουμπί: "**Start Instrumentation**". Πατήστε τα "**Frida Live Logs**" για να δείτε τα logs που δημιουργούνται από τα Frida scripts και το "**Live API Monitor**" για να δείτε όλες τις invocation σε hooked methods, τα arguments που περνάνε και τις τιμές που επιστρέφονται (this will appear after pressing "Start Instrumentation").\
Το MobSF επίσης επιτρέπει να φορτώσετε τα δικά σας **Frida scripts** (to send the results of your Frida scripts to MobSF use the function `send()`). Έχει επίσης **several pre-written scripts** που μπορείτε να φορτώσετε (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), απλώς **select them**, πατήστε "**Load**" και πατήστε "**Start Instrumentation**" (θα μπορείτε να δείτε τα logs αυτών των scripts μέσα στα "**Frida Live Logs**").

![](<../../images/image (419).png>)

Επιπλέον, υπάρχουν μερικές βοηθητικές λειτουργίες Frida:

- **Enumerate Loaded Classes**: Εκτυπώνει όλες τις loaded classes
- **Capture Strings**: Εκτυπώνει όλα τα captured strings κατά τη χρήση της εφαρμογής (super noisy)
- **Capture String Comparisons**: Μπορεί να είναι πολύ χρήσιμο. Θα **δείξει τα 2 strings που συγκρίνονται** και αν το αποτέλεσμα ήταν True ή False.
- **Enumerate Class Methods**: Βάλτε το όνομα της κλάσης (όπως "java.io.File") και θα εκτυπώσει όλες τις μεθόδους της κλάσης.
- **Search Class Pattern**: Ψάχνει classes by pattern
- **Trace Class Methods**: **Trace** ολόκληρη μια **class** (βλέπει inputs και outputs όλων των μεθόδων της κλάσης). Θυμηθείτε ότι εξ ορισμού το MobSF traces αρκετές ενδιαφέρουσες Android Api methods.

Μόλις επιλέξετε το auxiliary module που θέλετε να χρησιμοποιήσετε πρέπει να πατήσετε "**Start Instrumentation**" και θα δείτε όλα τα outputs στα "**Frida Live Logs**".

**Shell**

Mobsf παρέχει επίσης ένα shell με μερικές εντολές **adb**, **MobSF commands**, και κοινές **shell** **commands** στο κάτω μέρος της σελίδας dynamic analysis. Κάποιες ενδιαφέρουσες εντολές:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP tools**

Όταν το http traffic καταγράφεται μπορείτε να δείτε μια άσχημη προβολή του καταγεγραμμένου traffic στο "**HTTP(S) Traffic**" κουμπί ή μια πιο όμορφη προβολή στο πράσινο κουμπί "**Start HTTPTools**". Από τη δεύτερη επιλογή, μπορείτε να **send** τα **captured requests** σε **proxies** όπως Burp ή Owasp ZAP.\
Για να το κάνετε, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> πατήστε "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Μόλις τελειώσετε την dynamic analysis με MobSF μπορείτε να πατήσετε "**Start Web API Fuzzer**" για να **fuzz http requests** και να αναζητήσετε ευπάθειες.

> [!TIP]
> Μετά την εκτέλεση μιας dynamic analysis με MobSF, οι ρυθμίσεις proxy ενδέχεται να είναι misconfigured και να μην μπορείτε να τις διορθώσετε από το GUI. Μπορείτε να διορθώσετε τις ρυθμίσεις proxy κάνοντας:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

Μπορείτε να λάβετε το εργαλείο από [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Αυτό το εργαλείο θα χρησιμοποιήσει μερικά **Hooks** για να σας δείξει **what is happening in the application** ενώ εκτελείτε **dynamic analysis**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Αυτό είναι ένα **great tool to perform static analysis with a GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Αυτό το εργαλείο έχει σχεδιαστεί για να αναζητά διάφορες **security related Android application vulnerabilities**, είτε σε **source code** είτε σε **packaged APKs**. Το εργαλείο είναι επίσης **capable of creating a "Proof-of-Concept" deployable APK** και **ADB commands**, για να εκμεταλλευτεί κάποιες από τις βρεθείσες ευπάθειες (Exposed activities, intents, tapjacking...). Όπως και με Drozer, δεν απαιτείται root στη συσκευή δοκιμής.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Εμφανίζει όλα τα αρχεία που εξάχθηκαν για εύκολη αναφορά
- Αυτόματη decompile των αρχείων APK σε μορφή Java και Smali
- Αναλύει το AndroidManifest.xml για κοινές ευπάθειες και συμπεριφορά
- Στατική ανάλυση του source code για κοινές ευπάθειες και συμπεριφορά
- Στοιχεία συσκευής
- και περισσότερα
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

Το SUPER είναι μια εφαρμογή γραμμής εντολών που μπορεί να χρησιμοποιηθεί σε Windows, MacOS X και Linux, η οποία αναλύει αρχεία _.apk_ αναζητώντας ευπάθειες. Το κάνει αυτό αποσυμπιέζοντας τα APKs και εφαρμόζοντας μια σειρά κανόνων για να εντοπίσει αυτές τις ευπάθειες.

Όλοι οι κανόνες συγκεντρώνονται στο αρχείο `rules.json`, και κάθε εταιρεία ή tester μπορεί να δημιουργήσει τους δικούς της κανόνες για να αναλύσει ό,τι χρειάζεται.

Κατεβάστε τα πιο πρόσφατα binaries από τη [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn είναι ένα **crossplatform** εργαλείο που βοηθά προγραμματιστές, bugbounty hunters και ethical hackers να πραγματοποιούν [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) σε mobile applications.

Η ιδέα είναι ότι σύρετε και αποθέτετε το αρχείο της εφαρμογής κινητού σας (ένα .apk ή .ipa file) στην εφαρμογή StaCoAn και θα δημιουργήσει για εσάς μια οπτική και φορητή αναφορά. Μπορείτε να προσαρμόσετε τις ρυθμίσεις και τα wordlists για μια εξατομικευμένη εμπειρία.

Λήψη[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

Το AndroBugs Framework είναι ένα σύστημα ανάλυσης ευπαθειών για Android που βοηθά προγραμματιστές ή hackers να εντοπίσουν πιθανές ευπάθειες ασφαλείας σε εφαρμογές Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** είναι ένα εργαλείο του οποίου ο κύριος στόχος είναι να ανιχνεύει και να ειδοποιεί τον χρήστη για πιθανές κακόβουλες συμπεριφορές που αναπτύσσονται από μια εφαρμογή Android.

Η ανίχνευση γίνεται μέσω της **static analysis** του Dalvik bytecode της εφαρμογής, που αναπαρίσταται ως **Smali**, χρησιμοποιώντας τη βιβλιοθήκη [`androguard`](https://github.com/androguard/androguard).

Αυτό το εργαλείο αναζητά **συνηθισμένες συμπεριφορές των "bad" applications** όπως: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. Είναι ένα εργαλείο που συγκεντρώνει κοινά χρησιμοποιούμενα εργαλεία reverse engineering και analysis για mobile applications, ώστε να βοηθήσει στο testing mobile applications απέναντι στις OWASP mobile security threats. Στόχος του είναι να κάνει αυτήν την εργασία πιο εύκολη και φιλική προς τους mobile application developers και security professionals.

Μπορεί να:

- Extract Java and Smali code using different tools
- Αναλύει APKs χρησιμοποιώντας: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Εξάγει private information από το APK χρησιμοποιώντας regexps.
- Αναλύει το Manifest.
- Αναλύει τα domains που βρίσκει χρησιμοποιώντας: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) και [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Χρήσιμο για την ανίχνευση malware: [https://koodous.com/](https://koodous.com/)

## Απόκρυψη/Αποκρυπτογράφηση κώδικα

Σημειώστε ότι, ανάλογα με την υπηρεσία και τη διαμόρφωση που χρησιμοποιείτε για την απόκρυψη του κώδικα, τα μυστικά μπορεί να είναι obfuscated ή όχι.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. It is able to optimize bytecode as well as detect and remove unused instructions. ProGuard is free software and is distributed under the GNU General Public License, version 2.

Το ProGuard διανέμεται ως μέρος του Android SDK και τρέχει κατά τη διάρκεια του build της εφαρμογής σε release mode.

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(Από αυτόν τον οδηγό) Την τελευταία φορά που ελέγξαμε, ο τρόπος λειτουργίας του Dexguard ήταν:

- φορτώνει έναν resource ως InputStream;
- περνάει το αποτέλεσμα σε μια κλάση που κληρονομεί από FilterInputStream για να το αποκρυπτογραφήσει;
- κάνει κάποια άχρηστη obfuscation για να σπαταλήσει μερικά λεπτά από το χρόνο ενός reverser;
- περνάει το αποκρυπτογραφημένο αποτέλεσμα σε ένα ZipInputStream για να πάρει ένα DEX αρχείο;
- τέλος φορτώνει το προκύπτον DEX ως Resource χρησιμοποιώντας τη μέθοδο `loadDex`.

### [DeGuard](http://apk-deguard.com)

**DeGuard αντιστρέφει τη διαδικασία της απόκρυψης που εκτελούν τα Android obfuscation tools. Αυτό επιτρέπει πλήθος security analyses, συμπεριλαμβανομένης της επιθεώρησης κώδικα και της πρόβλεψης βιβλιοθηκών.**

Μπορείτε να ανεβάσετε ένα obfuscated APK στην πλατφόρμα τους.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

Είναι ένας generic android deobfuscator. Το Simplify virtually executes an app για να κατανοήσει τη συμπεριφορά του και στη συνέχεια προσπαθεί να optimize τον κώδικα έτσι ώστε να συμπεριφέρεται ταυτόσημα αλλά να είναι πιο εύκολος στην κατανόηση από άνθρωπο. Κάθε τύπος optimization είναι απλός και generic, οπότε δεν έχει σημασία τι συγκεκριμένο είδος obfuscation χρησιμοποιήθηκε.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD σας δίνει πληροφορίες για το πώς δημιουργήθηκε ένα APK. Αναγνωρίζει πολλούς compilers, packers, obfuscators και άλλα περίεργα πράγματα. Είναι [_PEiD_](https://www.aldeid.com/wiki/PEiD) για Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b είναι μια Android security virtual machine βασισμένη σε ubuntu-mate που περιλαμβάνει μια συλλογή από τα πιο πρόσφατα framework, tutorials και labs από διάφορους security geeks και researchers για reverse engineering και malware analysis.

## Αναφορές

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Είναι μια εξαιρετική λίστα πόρων
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Σύντομο μάθημα για Android
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)

## Ακόμα να δοκιμαστούν

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
