# Aplikacje Android Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Podstawy aplikacji Android

Zaleca się rozpocząć od przeczytania tej strony, aby poznać **najważniejsze elementy związane z bezpieczeństwem Androida oraz najbardziej niebezpieczne komponenty w aplikacji Android**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

To jest główne narzędzie, którego potrzebujesz, aby połączyć się z urządzeniem android (emulowanym lub fizycznym).\
**ADB** pozwala kontrolować urządzenia zarówno przez **USB** jak i **Network** z komputera. To narzędzie umożliwia **kopiowanie** plików w obu kierunkach, **instalację** i **deinstalację** aplikacji, **wykonywanie** poleceń shell, **backup** danych, **odczyt** logów, oraz inne funkcje.

Rzuć okiem na następującą listę [**ADB Commands**](adb-commands.md), aby nauczyć się jak używać adb.

## Smali

Czasami warto **zmodyfikować kod aplikacji**, aby uzyskać dostęp do **ukrytych informacji** (np. dobrze obfuskowane hasła lub flagi). W takim wypadku może być przydatne zdekompilowanie apk, modyfikacja kodu i ponowna kompilacja.\
[**W tym samouczku** możesz **nauczyć się jak zdekompilować APK, zmodyfikować kod Smali i ponownie skompilować APK** z nową funkcjonalnością](smali-changes.md). Może to być bardzo użyteczne jako **alternatywa dla kilku testów podczas analizy dynamicznej**, które zostaną przedstawione. Dlatego **zawsze miej na uwadze tę możliwość**.

## Inne interesujące triki

- [Fałszowanie lokalizacji w Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Wykorzystywanie niebezpiecznych mechanizmów In-App Update](insecure-in-app-update-rce.md)
- [Wykorzystywanie Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **Pobieranie APKów**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Wyodrębnij APK z urządzenia:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Połącz wszystkie splits i base apks za pomocą [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Studia przypadków i podatności


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Analiza statyczna

Po pierwsze, aby analizować APK powinieneś **przejrzeć kod Java** używając dekompilatora.\
Proszę, [**read here to find information about different available decompilers**](apk-decompilers.md).

### Poszukiwanie ciekawych informacji

Już samo przejrzenie **strings** w APK pozwala szukać **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** i wszystkiego interesującego... sprawdź nawet obecność wykonania kodu **backdoors** lub uwierzytelniających backdoorów (hardcoded admin credentials to the app).

**Firebase**

Zwróć szczególną uwagę na **firebase URLs** i sprawdź, czy jest źle skonfigurowany. [More information about whats is FIrebase and how to exploit it here.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Podstawowe zrozumienie aplikacji - Manifest.xml, strings.xml

**Przegląd plików _Manifest.xml_ i **_strings.xml_** aplikacji może ujawnić potencjalne luki bezpieczeństwa**. Do tych plików można uzyskać dostęp używając dekompilatorów lub zmieniając rozszerzenie pliku APK na .zip i rozpakowując go.

**Podatności** wykrywane z **Manifest.xml** obejmują:

- **Debuggable Applications**: Aplikacje ustawione jako debuggable (`debuggable="true"`) w pliku _Manifest.xml_ stanowią ryzyko, ponieważ umożliwiają połączenia, które mogą prowadzić do eksploatacji. Aby lepiej zrozumieć, jak eksploatować aplikacje oznaczone jako debuggable, odnieś się do samouczka o wyszukiwaniu i eksploatowaniu debuggable aplikacji na urządzeniu.
- **Backup Settings**: Atrybut `android:allowBackup="false"` powinien być ustawiony wyraźnie dla aplikacji przetwarzających wrażliwe informacje, aby zapobiec nieautoryzowanym backupom danych przez adb, szczególnie gdy włączone jest usb debugging.
- **Network Security**: Niestandardowe konfiguracje bezpieczeństwa sieci (`android:networkSecurityConfig="@xml/network_security_config"`) w _res/xml/_ mogą określać szczegóły bezpieczeństwa, takie jak pinowanie certyfikatów i ustawienia ruchu HTTP. Przykładem może być zezwolenie na ruch HTTP dla określonych domen.
- **Exported Activities and Services**: Identyfikacja eksportowanych aktywności i serwisów w manifeście może ujawnić komponenty, które mogą być nadużyte. Dalsza analiza podczas testów dynamicznych może pokazać sposoby ich wykorzystania.
- **Content Providers and FileProviders**: Udostępnione content providery mogą pozwolić na nieautoryzowany dostęp lub modyfikację danych. Konfiguracja FileProviders również powinna zostać dokładnie przeanalizowana.
- **Broadcast Receivers and URL Schemes**: Te komponenty mogą zostać wykorzystane do eksploatacji, ze szczególną uwagą na to, jak zarządzane są URL schemes pod kątem podatności wejścia.
- **SDK Versions**: Atrybuty `minSdkVersion`, `targetSDKVersion` i `maxSdkVersion` wskazują obsługiwane wersje Androida, podkreślając znaczenie niewspierania przestarzałych, podatnych wersji Androida ze względów bezpieczeństwa.

Z pliku **strings.xml** można odkryć wrażliwe informacje, takie jak API keys, custom schemas i inne notatki deweloperskie, co podkreśla potrzebę dokładnego przeglądu tych zasobów.

### Tapjacking

**Tapjacking** to atak, w którym **malicious** **application** jest uruchamiana i **pozycjonuje się nad aplikacją ofiary**. Gdy zasłania ona widocznie aplikację ofiary, jej interfejs użytkownika jest zaprojektowany tak, aby oszukać użytkownika, by wchodził w interakcję z nim, podczas gdy interakcja jest przekazywana do aplikacji ofiary.\
W efekcie, **użytkownik jest oślepiony i nie wie, że faktycznie wykonuje działania w aplikacji ofiary**.

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Aktywność z ustawionym **`launchMode`** na **`singleTask` bez zdefiniowanego `taskAffinity`** jest podatna na Task Hijacking. Oznacza to, że aplikacja może zostać zainstalowana i jeśli zostanie uruchomiona przed prawdziwą aplikacją, może **przejąć task prawdziwej aplikacji** (w rezultacie użytkownik będzie wchodził w interakcję z **malicious application** myśląc, że używa prawdziwej).

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Niezabezpieczone przechowywanie danych

**Pamięć wewnętrzna**

W Androidzie pliki **przechowywane** w **internal** storage są **zaprojektowane** tak, aby były **dostępne** wyłącznie dla **aplikacji**, która je **utworzyła**. Ten mechanizm bezpieczeństwa jest **wymuszony** przez system Android i zazwyczaj wystarcza do zabezpieczenia większości aplikacji. Jednak deweloperzy czasem używają trybów takich jak `MODE_WORLD_READABLE` i `MODE_WORLD_WRITABLE`, aby **pozwolić** na **udostępnianie** plików między różnymi aplikacjami. Te tryby **nie ograniczają dostępu** do tych plików przez inne aplikacje, w tym potencjalnie złośliwe.

1. **Static Analysis:**
- **Upewnij się**, że użycie `MODE_WORLD_READABLE` i `MODE_WORLD_WRITABLE` jest **dokładnie ocenione**. Te tryby **mogą potencjalnie ujawnić** pliki **niezamierzonemu lub nieautoryzowanemu dostępowi**.
2. **Dynamic Analysis:**
- **Zweryfikuj** uprawnienia ustawione na plikach tworzonych przez aplikację. W szczególności **sprawdź**, czy jakiekolwiek pliki nie są **ustawione jako czytelne lub zapisywalne dla wszystkich**. Może to stanowić istotne ryzyko bezpieczeństwa, ponieważ pozwoliłoby **każdej aplikacji** zainstalowanej na urządzeniu, niezależnie od jej pochodzenia czy intencji, **odczytywać lub modyfikować** te pliki.

**Pamięć zewnętrzna**

W przypadku plików na **external storage**, takich jak karty SD, należy zachować ostrożność:

1. **Dostępność**:
- Pliki na external storage są **globalnie czytelne i zapisywalne**. Oznacza to, że każda aplikacja lub użytkownik może mieć do nich dostęp.
2. **Obawy dotyczące bezpieczeństwa**:
- Ze względu na łatwość dostępu, zaleca się **nie przechowywać wrażliwych informacji** na external storage.
- External storage może zostać usunięty lub dostęp do niego może uzyskać dowolna aplikacja, co czyni go mniej bezpiecznym.
3. **Obsługa danych z external storage**:
- Zawsze **przeprowadzaj walidację wejścia** dla danych pobranych z external storage. To kluczowe, ponieważ dane pochodzą z nieufnego źródła.
- Zdecydowanie odradza się przechowywanie plików wykonywalnych lub klas na external storage w celu dynamicznego ładowania.
- Jeżeli aplikacja musi pobierać pliki wykonywalne z external storage, upewnij się, że te pliki są **podpisane i kryptograficznie weryfikowane** przed dynamicznym załadowaniem. Ten krok jest kluczowy dla zachowania integralności bezpieczeństwa aplikacji.

External storage można **uzyskać** w /storage/emulated/0 , /sdcard , /mnt/sdcard

> [!TIP]
> Starting with Android 4.4 (**API 17**), the SD card has a directory structure which **limits access from an app to the directory which is specifically for that app**. This prevents malicious application from gaining read or write access to another app's files.

**Wrażliwe dane przechowywane jawnie**

- **Shared preferences**: Android pozwala każdej aplikacji na łatwe zapisywanie plików xml w ścieżce `/data/data/<packagename>/shared_prefs/` i czasem można znaleźć wrażliwe informacje w postaci jawnej w tym folderze.
- **Databases**: Android pozwala każdej aplikacji na łatwe zapisywanie baz sqlite w ścieżce `/data/data/<packagename>/databases/` i czasem można znaleźć wrażliwe informacje w postaci jawnej w tym folderze.

### Błędna konfiguracja TLS

**Accept All Certificates**

Z jakiegoś powodu deweloperzy czasem akceptują wszystkie certyfikaty, nawet jeśli na przykład hostname nie pasuje, używając linii kodu podobnych do następującej:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Dobrym sposobem przetestowania tego jest próba przechwycenia ruchu za pomocą proxy, takiego jak Burp, bez autoryzowania Burp CA na urządzeniu. Możesz też wygenerować w Burp certyfikat dla innej nazwy hosta i go użyć.

### Błędna kryptografia

**Słabe procesy zarządzania kluczami**

Niektórzy deweloperzy zapisują dane wrażliwe w lokalnej pamięci i szyfrują je kluczem zakodowanym na stałe/przewidywalnym w kodzie. Nie powinno się tego robić, ponieważ analiza odwrotna może umożliwić atakującym wyodrębnienie poufnych informacji.

**Użycie niebezpiecznych i/lub przestarzałych algorytmów**

Deweloperzy nie powinni używać **deprecated algorithms** do przeprowadzania autoryzacyjnych **checks**, **store** lub **send** danych. Niektóre z tych algorytmów to: RC4, MD4, MD5, SHA1... Jeśli do przechowywania haseł używane są **hashes**, powinno się stosować odporne na brute-force algorytmy z salt.

### Inne kontrole

- Zaleca się **obfuskować APK**, aby utrudnić pracę reverse engineerów atakującym.
- Jeśli aplikacja jest wrażliwa (np. aplikacje bankowe), powinna wykonać swoje własne **sprawdzenia, czy urządzenie jest rooted** i działać odpowiednio.
- Jeśli aplikacja jest wrażliwa (np. aplikacje bankowe), powinna sprawdzać, czy używany jest **emulator**.
- Jeśli aplikacja jest wrażliwa (np. aplikacje bankowe), powinna **sprawdzić swoją integralność przed uruchomieniem**, aby upewnić się, czy nie została zmodyfikowana.
- Użyj [**APKiD**](https://github.com/rednaga/APKiD) aby sprawdzić, który compiler/packer/obfuscator został użyty do zbudowania APK

### Aplikacja React Native

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Aplikacje Xamarin

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automatyczna analiza statyczna kodu

Narzędzie [**mariana-trench**](https://github.com/facebook/mariana-trench) jest w stanie znaleźć **vulnerabilities** przez **scanning** **code** aplikacji. To narzędzie zawiera zbiór **known sources** (które wskazują narzędziu **places** gdzie **input** jest **controlled by the user**), **sinks** (które wskazują narzędziu **dangerous** **places** gdzie złośliwy input użytkownika może spowodować szkody) oraz **rules**. Te rules wskazują **combination** **sources-sinks**, które oznaczają podatność.

Z tą wiedzą, **mariana-trench will review the code and find possible vulnerabilities on it**.

### Secrets leaked

Aplikacja może zawierać sekrety (API keys, passwords, hidden urls, subdomains...) wewnątrz, które możesz odkryć. Możesz użyć narzędzia takiego jak [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Inne ciekawe funkcje

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Analiza dynamiczna

> Przede wszystkim potrzebujesz środowiska, w którym możesz zainstalować aplikację i całe środowisko (Burp CA cert, Drozer i Frida głównie). Dlatego zdecydowanie zalecane jest użycie urządzenia rooted (emuowane lub nie).

### Online dynamic analysis

Możesz utworzyć darmowe konto na: [https://appetize.io/](https://appetize.io). Ta platforma pozwala na przesyłanie i uruchamianie APK, więc jest przydatna do obserwowania, jak APK się zachowuje.

Możesz nawet **zobaczyć logi swojej aplikacji** w sieci i połączyć się przez **adb**.

![](<../../images/image (831).png>)

Dzięki połączeniu ADB możesz używać **Drozer** i **Frida** wewnątrz emulatorów.

### Lokalna analiza dynamiczna

#### Użycie emulatora

- [**Android Studio**](https://developer.android.com/studio) (Możesz stworzyć urządzenia **x86** i **arm**, a zgodnie z [**this**](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html) **latest x86** versions **support ARM libraries** bez konieczności używania wolnego emulatora arm).
- Naucz się jak to skonfigurować na tej stronie:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) (Bezpłatna wersja: Personal Edition, trzeba utworzyć konto. Zaleca się pobranie wersji Z **VirtualBox**, aby uniknąć potencjalnych błędów.)
- [**Nox**](https://es.bignox.com) (Darmowy, ale nie obsługuje Frida ani Drozer).

> [!TIP]
> Tworząc nowy emulator na dowolnej platformie pamiętaj, że im większy ekran, tym wolniej będzie działać emulator. Wybieraj więc, jeśli to możliwe, mniejsze ekrany.

Aby **zainstalować google services** (np. AppStore) w Genymotion, musisz kliknąć przycisk oznaczony na czerwono na poniższym obrazku:

![](<../../images/image (277).png>)

Zwróć też uwagę, że w **konfiguracji Android VM w Genymotion** możesz wybrać **Bridge Network mode** (przydatne, jeśli będziesz łączyć się z Android VM z innej VM z narzędziami).

#### Użycie urządzenia fizycznego

Musisz aktywować opcje **debugowania**, a dobrze byłoby, gdybyś mógł je **root**:

1. **Ustawienia**.
2. (Od Android 8.0) Wybierz **System**.
3. Wybierz **Informacje o telefonie**.
4. Naciśnij **Numer kompilacji** 7 razy.
5. Wróć i znajdziesz **Opcje programisty**.

> Po zainstalowaniu aplikacji, pierwszą rzeczą, którą powinieneś zrobić, jest wypróbować ją, zbadać, co robi, jak działa i oswoić się z nią. Zalecam **wykonanie tej początkowej analizy dynamicznej przy użyciu MobSF dynamic analysis + pidcat**, dzięki czemu będziemy mogli **dowiedzieć się, jak działa aplikacja**, podczas gdy MobSF **zbiera** mnóstwo **interesujących** **danych**, które możesz później przejrzeć.

### Unintended Data Leakage

**Logging**

Deweloperzy powinni zachować ostrożność przy ujawnianiu **debugging information** publicznie, ponieważ może to prowadzić do sensitive data leaks. Narzędzia [**pidcat**](https://github.com/JakeWharton/pidcat) oraz `adb logcat` są zalecane do monitorowania logów aplikacji w celu identyfikacji i ochrony informacji wrażliwych. **Pidcat** jest preferowany ze względu na łatwość użycia i czytelność.

> [!WARNING]
> Zauważ, że od **wersji nowszej niż Android 4.0**, **aplikacje mogą uzyskiwać dostęp tylko do swoich własnych logów**. Więc aplikacje nie mogą uzyskać dostępu do logów innych aplikacji.\
> Mimo to nadal zaleca się **nie logować informacji wrażliwych**.

**Copy/Paste Buffer Caching**

Androidowy framework oparty na **clipboard-based** umożliwia funkcję kopiuj-wklej w aplikacjach, jednak stwarza ryzyko, ponieważ **inne aplikacje** mogą **access** schowka, potencjalnie ujawniając wrażliwe dane. Kluczowe jest **wyłączenie funkcji copy/paste** dla wrażliwych sekcji aplikacji, takich jak dane karty kredytowej, aby zapobiec data leaks.

**Crash Logs**

Jeśli aplikacja **crashes** i **saves logs**, te logi mogą pomóc atakującym, szczególnie gdy aplikacja nie może być reverse-engineerowana. Aby złagodzić to ryzyko, unikaj logowania przy crashach, a jeśli logi muszą być przesyłane przez sieć, upewnij się, że są wysyłane przez kanał SSL dla bezpieczeństwa.

Jako pentester, **spróbuj rzucić okiem na te logi**.

**Analytics Data Sent To 3rd Parties**

Aplikacje często integrują usługi takie jak Google Adsense, które mogą niezamiernie **leak sensitive data** z powodu nieprawidłowej implementacji przez deweloperów. Aby zidentyfikować potencjalne data leaks, zaleca się **intercept the application's traffic** i sprawdzić, czy jakiekolwiek wrażliwe informacje są wysyłane do usług stron trzecich.

### SQLite DBs

Większość aplikacji będzie używać **internal SQLite databases** do zapisywania informacji. Podczas pentest zwróć uwagę na **databases** utworzone, nazwy **tables** i **columns** oraz wszystkie zapisane **data**, ponieważ możesz znaleźć **sensitive information** (co byłoby podatnością).\
Bazy danych powinny być zlokalizowane w `/data/data/the.package.name/databases` na przykład `/data/data/com.mwr.example.sieve/databases`

Jeśli baza danych przechowuje poufne informacje i jest **encrypted** ale możesz **find** **password** wewnątrz aplikacji, to nadal jest **vulnerability**.

Wyenumeruj tabele używając `.tables` i wyświetl kolumny tabel poleceniem `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer is s useful tool to **exploit exported activities, exported services and Content Providers** as you will learn in the following sections.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Also remember that the code of an activity starts in the **`onCreate`** method.

**Authorisation bypass**

When an Activity is exported you can invoke its screen from an external app. Therefore, if an activity with **sensitive information** is **exported** you could **bypass** the **authentication** mechanisms **to access it.**

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

You can also start an exported activity from adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**UWAGA**: MobSF wykryje jako złośliwe użycie _**singleTask/singleInstance**_ jako `android:launchMode` w aktywności, ale zgodnie z [tym](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), najwyraźniej jest to niebezpieczne tylko w starych wersjach (API versions < 21).

> [!TIP]
> Należy pamiętać, że obejście autoryzacji nie zawsze jest podatnością — zależy to od sposobu działania bypassu i jakie informacje są ujawniane.

**Ujawnianie wrażliwych informacji**

**Aktywności mogą również zwracać wyniki**. Jeśli uda Ci się znaleźć eksportowaną i niechronioną aktywność wywołującą metodę **`setResult`** i **zwracającą wrażliwe informacje**, dochodzi do ujawnienia wrażliwych informacji.

#### Tapjacking

Jeśli Tapjacking nie jest zapobiegany, możesz wykorzystać eksportowaną aktywność, aby spowodować, że **użytkownik wykona nieoczekiwane akcje**. Więcej informacji o [**czym jest Tapjacking — zobacz link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Przeczytaj to, jeśli chcesz odświeżyć, czym jest Content Provider.**](android-applications-basics.md#content-provider)\
Content providers służą zasadniczo do **udostępniania danych**. Jeśli aplikacja udostępnia content providers, możesz być w stanie **wyodrębnić wrażliwe** dane z nich. Warto także przetestować możliwe **SQL injections** i **Path Traversals**, ponieważ mogą być podatne.

[**Dowiedz się, jak wykorzystać Content Providers przy użyciu Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Przeczytaj to, jeśli chcesz odświeżyć, czym jest Service.**](android-applications-basics.md#services)\
Pamiętaj, że działania Service rozpoczynają się w metodzie `onStartCommand`.

Service to w zasadzie coś, co **może otrzymywać dane**, **przetwarzać** je i **zwracać** (lub nie) odpowiedź. Zatem jeśli aplikacja eksportuje jakieś services, powinieneś **sprawdzić** **kod**, aby zrozumieć, co robi, i **przetestować** go **dynamicznie** w celu wyciągnięcia informacji poufnych, obejścia mechanizmów uwierzytelniania itp.\  
[**Dowiedz się, jak wykorzystać Services przy użyciu Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Przeczytaj to, jeśli chcesz odświeżyć, czym jest Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Pamiętaj, że działania Broadcast Receiver rozpoczynają się w metodzie `onReceive`.

Broadcast Receiver będzie oczekiwał na określony typ komunikatu. W zależności od tego, jak odbiornik obsługuje komunikat, może być podatny.\  
[**Dowiedz się, jak wykorzystać Broadcast Receivers przy użyciu Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Możesz wyszukiwać deep links ręcznie, używając narzędzi takich jak MobSF lub skryptów, takich jak [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Możesz **otworzyć** zadeklarowany **scheme** za pomocą **adb** lub **przeglądarki**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Zauważ, że możesz **pominąć nazwę pakietu** i urządzenie mobilne automatycznie uruchomi aplikację, która powinna otworzyć ten link._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Kod wykonywany**

Aby znaleźć **kod, który zostanie wykonany w aplikacji**, przejdź do activity wywoływanej przez deeplink i wyszukaj funkcję **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Wrażliwe informacje**

Za każdym razem, gdy znajdziesz deep link, sprawdź, czy **nie przyjmuje wrażliwych danych (np. haseł) przez parametry URL**, ponieważ każda inna aplikacja mogłaby **podszyć się pod ten deep link i ukraść te dane!**

**Parametry w ścieżce**

Musisz też sprawdzić, czy któryś deep link nie używa parametru w samej ścieżce URL, np.: `https://api.example.com/v1/users/{username}` — w takim przypadku możesz wymusić path traversal, uzyskując dostęp do czegoś takiego: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Zauważ, że jeśli znajdziesz poprawne endpointy w aplikacji, możesz spowodować **Open Redirect** (jeśli część ścieżki jest używana jako nazwa domeny), **przejęcie konta** (jeśli możesz modyfikować dane użytkowników bez tokenu CSRF i podatny endpoint używał odpowiedniej metody) oraz inne podatności. Więcej [informacji znajdziesz tutaj](http://dphoeniixx.com/2020/12/13-2/).

**Więcej przykładów**

Interesujący [raport bug bounty](https://hackerone.com/reports/855618) dotyczący linków (_/.well-known/assetlinks.json_).

### Inspekcja warstwy transportowej i błędy weryfikacji

- **Certyfikaty nie zawsze są właściwie sprawdzane** przez aplikacje Android. Często aplikacje te ignorują ostrzeżenia i akceptują certyfikaty self-signed lub, w niektórych przypadkach, przechodzą na połączenia HTTP.
- **Negocjacje podczas handshake SSL/TLS bywają słabe**, używając niebezpiecznych zestawów szyfrów. Ta podatność naraża połączenie na ataki man-in-the-middle (MITM), pozwalając atakującym odszyfrować dane.
- **Wycieki informacji prywatnych** stanowią ryzyko, gdy aplikacje uwierzytelniają się przez bezpieczne kanały, a następnie komunikują się przez niezaszyfrowane kanały w innych operacjach. Takie podejście nie chroni wrażliwych danych, takich jak ciasteczka sesyjne czy dane użytkownika, przed przechwyceniem przez złośliwe podmioty.

#### Weryfikacja certyfikatu

Skupimy się na **weryfikacji certyfikatu**. Należy weryfikować integralność certyfikatu serwera, aby zwiększyć bezpieczeństwo. To kluczowe, ponieważ niebezpieczne konfiguracje TLS i przesyłanie wrażliwych danych przez niezaszyfrowane kanały niosą znaczące ryzyko. Dla szczegółowych kroków dotyczących weryfikacji certyfikatów serwera i łatania podatności, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) zawiera obszerne wskazówki.

#### SSL Pinning

SSL Pinning to mechanizm bezpieczeństwa, w którym aplikacja weryfikuje certyfikat serwera względem znanej kopii przechowywanej wewnątrz aplikacji. Metoda ta jest istotna w zapobieganiu atakom MITM. Zdecydowanie zaleca się wdrożenie SSL Pinning w aplikacjach przetwarzających wrażliwe informacje.

#### Inspekcja ruchu

Aby inspekcjonować ruch HTTP, konieczne jest **zainstalowanie certyfikatu narzędzia proxy** (np. Burp). Bez zainstalowania tego certyfikatu zaszyfrowany ruch może być niewidoczny przez proxy. Po instrukcję instalacji własnego certyfikatu CA, [**kliknij tutaj**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Aplikacje celujące w **API Level 24 i wyżej** wymagają modyfikacji Network Security Config, aby zaakceptować certyfikat CA proxy. Ten krok jest krytyczny dla inspekcji zaszyfrowanego ruchu. Instrukcje dotyczące modyfikacji Network Security Config znajdziesz w [**this tutorial**](make-apk-accept-ca-certificate.md).

Jeśli używane jest **Flutter**, musisz postępować zgodnie z instrukcjami na [**tej stronie**](flutter.md). Dzieje się tak dlatego, że samo dodanie certyfikatu do magazynu nie zadziała — Flutter ma własną listę zaufanych CA.

#### Statyczne wykrywanie SSL/TLS pinning

Zanim spróbujesz obejść mechanizmy w czasie wykonywania, szybko zmapuj miejsca, w których pinning jest egzekwowany w APK. Wykrywanie statyczne pomaga zaplanować hooki/łatki i skupić się na właściwych ścieżkach kodu.

Narzędzie: SSLPinDetect
- Open-sourceowe narzędzie do analizy statycznej, które dekompiluje APK do Smali (przez apktool) i skanuje pod kątem wyselekcjonowanych wzorców regex implementacji SSL/TLS pinning.
- Raportuje dokładną ścieżkę pliku, numer linii i fragment kodu dla każdego dopasowania.
- Obejmuje popularne frameworki i niestandardowe ścieżki kodu: OkHttp CertificatePinner, niestandardowy javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init z niestandardowymi TrustManagers/KeyManagers oraz piny w Network Security Config XML.

Instalacja
- Wymagania wstępne: Python >= 3.8, Java w PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Użycie
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Przykładowe reguły wzorców (JSON)
Użyj lub rozszerz sygnatury, aby wykrywać zastrzeżone/własne style pinning. Możesz załadować własny plik JSON i skanować na dużą skalę.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes and tips
- Szybkie skanowanie dużych aplikacji przy użyciu wielowątkowości i memory-mapped I/O; prekompilowane regexy zmniejszają narzut/fałszywe pozytywy.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Typowe cele do dalszej analizy:
- OkHttp: użycie CertificatePinner, setCertificatePinner, odwołania do pakietu okhttp3/okhttp
- Własne TrustManagery: javax.net.ssl.X509TrustManager, nadpisania checkServerTrusted
- Niestandardowe konteksty SSL: SSLContext.getInstance + SSLContext.init z niestandardowymi managerami
- Deklaratywne piny w res/xml network security config oraz odwołania w manifest
- Użyj znalezionych lokalizacji do zaplanowania Frida hooks, statycznych patchy lub przeglądu konfiguracji przed testami dynamicznymi.



#### Bypassing SSL Pinning

Gdy SSL Pinning jest zaimplementowany, konieczne staje się jego ominięcie, aby przeanalizować ruch HTTPS. Istnieje kilka metod do tego celu:

- Automatically **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Największą zaletą tej opcji jest to, że nie będziesz potrzebować roota, aby obejść SSL Pinning, ale będziesz musiał usunąć aplikację i zainstalować nową — i nie zawsze to zadziała.
- Możesz użyć **Frida** (opisane poniżej) do obejścia tej ochrony. Oto przewodnik dotyczący użycia Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Możesz też spróbować **automatycznie ominąć SSL Pinning** używając [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Możesz także spróbować **automatycznie ominąć SSL Pinning** używając **MobSF dynamic analysis** (opisane poniżej)
- Jeśli nadal uważasz, że nie przechwytujesz części ruchu, możesz spróbować **przekierować ruch do Burp przy użyciu iptables**. Przeczytaj ten wpis: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Looking for Common Web Vulnerabilities

Ważne jest również poszukiwanie typowych podatności webowych w aplikacji. Szczegółowe informacje o identyfikacji i łagodzeniu tych podatności wykraczają poza zakres tego podsumowania, ale są szeroko omówione w innych materiałach.

### Frida

[Frida](https://www.frida.re) to dynamiczny zestaw narzędzi do instrumentacji dla deweloperów, reverse-engineerów i badaczy bezpieczeństwa.\
**Możesz uzyskać dostęp do uruchomionej aplikacji i hookować metody w czasie wykonywania, aby zmieniać zachowanie, wartości, wydobywać wartości, uruchamiać inny kod...**\
Jeśli chcesz pentestować aplikacje Android, musisz umieć używać Frida.

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Some "GUI" for actions with Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- You can find some Awesome Frida scripts here: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Spróbuj obejść mechanizmy anti-debugging / anti-frida, ładując Frida jak wskazano w [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (narzędzie [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

Sprawdź, czy aplikacja przechowuje w pamięci wrażliwe informacje, których nie powinna przechowywać, takie jak hasła czy mnemoniki.

Używając [**Fridump3**](https://github.com/rootbsd/fridump3) możesz zrzucić pamięć aplikacji poleceniem:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
To zrzuci pamięć do folderu ./dump, a tam możesz użyć grep, na przykład:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Poufne dane w Keystore**

W Androidzie Keystore jest najlepszym miejscem do przechowywania poufnych danych, jednak przy odpowiednich uprawnieniach wciąż **możliwe jest uzyskanie do niego dostępu**.

Ponieważ aplikacje mają tendencję do przechowywania tutaj **poufnych danych w clear text**, pentests powinny to zweryfikować, gdyż root user lub ktoś z fizycznym dostępem do urządzenia mógłby te dane ukraść.

Nawet jeśli aplikacja przechowała dane w keystore, dane powinny być zaszyfrowane.

Aby uzyskać dostęp do danych wewnątrz keystore możesz użyć tego Frida script: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Użycie poniższego Frida scriptu może umożliwić **bypass fingerprint authentication** stosowany przez aplikacje Android w celu **ochrony pewnych wrażliwych obszarów:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Obrazy w tle**

Gdy przeniesiesz aplikację do tła, Android zapisuje **snapshot aplikacji**, dzięki czemu po przywróceniu do pierwszego planu zaczyna najpierw ładować obraz, aby wydawało się, że aplikacja uruchomiła się szybciej.

Jednak jeśli ten snapshot zawiera **poufne informacje**, ktoś mający dostęp do snapshotu może **ukraść te informacje** (uwaga: wymagany jest root, aby uzyskać do niego dostęp).

Snapshoty są zwykle przechowywane pod ścieżką: **`/data/system_ce/0/snapshots`**

Android oferuje sposób na **zapobieganie przechwytywaniu zrzutów ekranu przez ustawienie parametru layout FLAG_SECURE**. Użycie tej flagi powoduje, że zawartość okna jest traktowana jako bezpieczna, uniemożliwiając pojawienie się na zrzutach ekranu lub wyświetlanie na niezabezpieczonych ekranach.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

To narzędzie może pomóc w zarządzaniu różnymi narzędziami podczas analizy dynamicznej: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Deweloperzy często tworzą komponenty proxy takie jak activities, services i broadcast receivers, które obsługują te Intents i przekazują je do metod takich jak `startActivity(...)` lub `sendBroadcast(...)`, co może być ryzykowne.

Niebezpieczeństwo polega na pozwoleniu atakującym na wywoływanie nie-exportowanych komponentów aplikacji lub dostęp do wrażliwych content providers poprzez przekierowanie tych Intents. Przykładem jest komponent `WebView` konwertujący URL-e na obiekty `Intent` za pomocą `Intent.parseUri(...)`, a następnie je wykonujący, co może prowadzić do złośliwych Intent injections.

### Kluczowe wnioski

- **Intent Injection** jest podobny do webowego problemu Open Redirect.
- Eksploity polegają na przekazywaniu obiektów `Intent` jako extras, które mogą być przekierowane do wykonania niebezpiecznych operacji.
- Może to wystawić atakującym nie-exportowane komponenty i content providers.
- Konwersja URL-i na `Intent` przez `WebView` może ułatwić niezamierzone działania.

### Android Client Side Injections and others

Prawdopodobnie znasz tego rodzaju podatności z Weba. W aplikacji Android należy zachować szczególną ostrożność w związku z tymi podatnościami:

- **SQL Injection:** Jeśli używasz dynamicznych zapytań lub Content-Providers, upewnij się, że stosujesz zapytania parametryzowane.
- **JavaScript Injection (XSS):** Sprawdź, czy obsługa JavaScript i Pluginów jest wyłączona dla wszelkich WebViews (domyślnie wyłączona). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** Dostęp WebView do systemu plików powinien być wyłączony (domyślnie włączony) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: W kilku przypadkach po zakończeniu sesji przez aplikację Android cookie nie jest unieważniane lub może być nawet zapisane na dysku
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatyczna analiza

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Analiza statyczna**

![](<../../images/image (866).png>)

**Ocena podatności aplikacji** z użyciem ładnego interfejsu webowego. Możesz również przeprowadzić analizę dynamiczną (ale musisz przygotować środowisko).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Zwróć uwagę, że MobSF potrafi analizować **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Również, jeśli utworzysz plik **ZIP** z kodem źródłowym aplikacji **Android** lub **IOS** (przejdź do katalogu głównego aplikacji, zaznacz wszystko i utwórz plik ZIP), będzie on również możliwy do analizy.

MobSF pozwala także na **diff/Compare** analizę oraz integrację z **VirusTotal** (musisz ustawić swój klucz API w _MobSF/settings.py_ i włączyć to: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). Możesz także ustawić `VT_UPLOAD` na `False`, wtedy zamiast pliku zostanie przesłany **hash**.

### Asystowana analiza dynamiczna z MobSF

**MobSF** może być również bardzo pomocne przy analizie dynamicznej na **Android**, ale w takim przypadku musisz zainstalować **MobSF** i **genymotion** na hoście (VM lub Docker nie zadziałają). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
Analizator dynamiczny MobSF może:

- **Dump application data** (URL-e, logi, schowek, zrzuty ekranu robione przez Ciebie, zrzuty ekranu robione przez "**Exported Activity Tester**", e-maile, bazy SQLite, pliki XML i inne utworzone pliki). Wszystko to jest wykonywane automatycznie z wyjątkiem zrzutów ekranu — musisz nacisnąć, gdy chcesz zrzut ekranu lub nacisnąć "**Exported Activity Tester**", aby uzyskać zrzuty wszystkich eksportowanych aktywności.
- Przechwytywać **HTTPS traffic**
- Wykorzystać **Frida** do uzyskania informacji w czasie wykonania (runtime)

Od wersji Android > 5, automatycznie uruchomi Frida i ustawi globalne ustawienia proxy, aby przechwycić ruch. Będzie przechwytywać tylko ruch z testowanej aplikacji.

**Frida**

Domyślnie będzie też używać niektórych **Frida Scripts** do **bypass SSL pinning**, **root detection** i **debugger detection** oraz do monitorowania interesujących API.\
MobSF może także **invoke exported activities**, pobierać ich **screenshots** i **save** je do raportu.

Aby **start** testów dynamicznych naciśnij zielony przycisk: "**Start Instrumentation**". Naciśnij "**Frida Live Logs**", aby zobaczyć logi generowane przez Frida scripts i "**Live API Monitor**", aby zobaczyć wszystkie wywołania do zahaczonych metod, przekazane argumenty i zwracane wartości (pojawi się to po naciśnięciu "Start Instrumentation").\
MobSF pozwala także na załadowanie własnych **Frida scripts** (aby wysłać wyniki swoich Frida scripts do MobSF użyj funkcji `send()`). Ma też kilka predefiniowanych skryptów, które możesz załadować (możesz dodać więcej w `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), po prostu wybierz je, naciśnij "**Load**" i "**Start Instrumentation**" (będziesz mógł zobaczyć logi tych skryptów w "**Frida Live Logs**").

![](<../../images/image (419).png>)

Ponadto masz kilka pomocniczych funkcjonalności Frida:

- **Enumerate Loaded Classes**: Wypisze wszystkie załadowane klasy
- **Capture Strings**: Wypisze wszystkie przechwycone stringi podczas korzystania z aplikacji (bardzo hałaśliwe)
- **Capture String Comparisons**: Może być bardzo przydatne. Pokaże dwa porównywane stringi oraz czy wynik był True czy False.
- **Enumerate Class Methods**: Wprowadź nazwę klasy (np. "java.io.File"), a wypisze wszystkie metody tej klasy.
- **Search Class Pattern**: Wyszukuje klasy według wzorca
- **Trace Class Methods**: **Trace** całej klasy (zobacz wejścia i wyjścia wszystkich metod klasy). Pamiętaj, że domyślnie MobSF śledzi kilka interesujących metod Android Api.

Gdy wybierzesz moduł pomocniczy, którego chcesz użyć, musisz nacisnąć "**Start Intrumentation**" i zobaczysz wszystkie wyjścia w "**Frida Live Logs**".

**Shell**

MobSF dostarcza również shell z kilkoma poleceniami **adb**, **MobSF commands** oraz typowymi poleceniami **shell** na dole strony analizy dynamicznej. Kilka ciekawych poleceń:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**Narzędzia HTTP**

Gdy ruch HTTP zostanie przechwycony, możesz zobaczyć toporny widok przechwyconego ruchu na przycisku "**HTTP(S) Traffic**" u dołu albo ładniejszy widok po naciśnięciu zielonego przycisku "**Start HTTPTools**". Z drugiej opcji możesz **wysyłać** **przechwycone żądania** do **proxies** takich jak Burp lub Owasp ZAP.\
Aby to zrobić, _włącz Burp -->_ _wyłącz Intercept --> w MobSB HTTPTools wybierz żądanie_ --> naciśnij "**Send to Fuzzer**" --> _wybierz adres proxy_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Po zakończeniu dynamicznej analizy z MobSF możesz nacisnąć "**Start Web API Fuzzer**", aby **fuzzować http requests** i szukać podatności.

> [!TIP]
> Po wykonaniu dynamicznej analizy z MobSF ustawienia proxy mogą zostać źle skonfigurowane i nie będzie można ich naprawić z poziomu GUI. Możesz naprawić ustawienia proxy wykonując:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Wspomagana analiza dynamiczna z Inspeckage

Narzędzie można pobrać z [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
To narzędzie używa pewnych **Hooks**, aby informować, **co dzieje się w aplikacji**, podczas gdy wykonujesz **dynamic analysis**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

To **świetne narzędzie do przeprowadzania static analysis z GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Narzędzie zostało zaprojektowane do wyszukiwania różnych **security related Android application vulnerabilities**, zarówno w **source code**, jak i w **packaged APKs**. Narzędzie jest również **zdolne do tworzenia "Proof-of-Concept" deployable APK** oraz generowania **ADB commands**, aby wykorzystać niektóre ze znalezionych podatności (Exposed activities, intents, tapjacking...). Podobnie jak w przypadku Drozer, nie ma potrzeby rootowania urządzenia testowego.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Wyświetla wszystkie wyodrębnione pliki do szybkiego przeglądu
- Automatycznie dekompiluje pliki APK do formatu Java i Smali
- Analizuje AndroidManifest.xml pod kątem typowych podatności i zachowania
- Statyczna analiza kodu źródłowego pod kątem typowych podatności i zachowań
- Informacje o urządzeniu
- i więcej
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER to aplikacja wiersza poleceń, którą można używać na Windows, MacOS X i Linux, analizująca pliki _.apk_ w poszukiwaniu podatności. Robi to poprzez rozpakowywanie APK i stosowanie zestawu reguł w celu wykrycia tych podatności.

Wszystkie reguły są umieszczone w pliku `rules.json`, a każda firma lub tester może stworzyć własne reguły, aby analizować to, czego potrzebują.

Pobierz najnowsze binaria ze [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn to **crossplatform** narzędzie, które wspomaga programistów, bugbounty hunters i ethical hackers w przeprowadzaniu [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) aplikacji mobilnych.

Koncepcja polega na tym, że przeciągasz i upuszczasz plik swojej aplikacji mobilnej (an .apk or .ipa file) na aplikację StaCoAn, a ona wygeneruje dla Ciebie wizualny i przenośny raport. Możesz dostosować ustawienia i wordlists, aby uzyskać spersonalizowane doświadczenie.

Pobierz[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework to system analizy podatności dla Androida, który pomaga deweloperom lub hackers znaleźć potencjalne luki w zabezpieczeniach aplikacji Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** to narzędzie, którego głównym celem jest wykrywanie i ostrzeganie użytkownika o potencjalnie złośliwych zachowaniach wykonywanych przez aplikację na Androida.

Wykrywanie odbywa się za pomocą static analysis Dalvik bytecode aplikacji, reprezentowanego jako Smali, z użyciem biblioteki androguard.

To narzędzie poszukuje typowych zachowań "złych" aplikacji, takich jak: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** to framework do reverse engineeringu i analizy aplikacji mobilnych. Jest to narzędzie, które łączy powszechnie używane narzędzia do reverse engineeringu i analizy aplikacji mobilnych, aby wspomóc testowanie aplikacji mobilnych pod kątem zagrożeń bezpieczeństwa OWASP mobile. Jego celem jest ułatwienie tej pracy deweloperom aplikacji mobilnych oraz specjalistom ds. bezpieczeństwa.

Potrafi:

- Wyodrębniać kod Java i Smali przy użyciu różnych narzędzi
- Analizować APKi za pomocą: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Wydobywać informacje prywatne z APK za pomocą regexów.
- Analizować Manifest.
- Analizować znalezione domeny przy użyciu: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) i [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuskować APK przez [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Przydatne do wykrywania malware: [https://koodous.com/](https://koodous.com)

## Obfuskacja/Deobfuskacja kodu

Zwróć uwagę, że w zależności od usługi i konfiguracji użytej do obfuskacji kodu, sekrety mogą, ale nie muszą być obfuskowane.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

Z [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** jest open source'owym narzędziem konsolowym, które zmniejsza, optymalizuje i obfuskje kod Java. Potrafi optymalizować bytecode oraz wykrywać i usuwać nieużywane instrukcje. ProGuard jest wolnym oprogramowaniem rozpowszechnianym na licencji GNU General Public License, wersja 2.

ProGuard jest dostarczany jako część Android SDK i uruchamia się podczas budowania aplikacji w trybie release.

### [DexGuard](https://www.guardsquare.com/dexguard)

Znajdź krok po kroku przewodnik jak deobfuskować apk w [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(Z tego przewodnika) Ostatnio, gdy sprawdzaliśmy, tryb działania Dexguard wyglądał następująco:

- załaduj zasób jako InputStream;
- przekaż wynik do klasy dziedziczącej po FilterInputStream, aby go odszyfrować;
- wykonaj pewną bezużyteczną obfuskację, żeby zmarnować kilka minut czasu reversera;
- przekaż odszyfrowany wynik do ZipInputStream, aby uzyskać plik DEX;
- w końcu załaduj powstały DEX jako zasób używając metody `loadDex`.

### [DeGuard](http://apk-deguard.com)

**DeGuard odwraca proces obfuskacji wykonywany przez narzędzia obfuskacyjne dla Androida. Umożliwia to liczne analizy bezpieczeństwa, w tym inspekcję kodu i identyfikację bibliotek.**

Możesz przesłać obfuskowany APK na ich platformę.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

To narzędzie LLM do znajdowania potencjalnych luk bezpieczeństwa w aplikacjach android oraz deobfuskacji kodu aplikacji android. Wykorzystuje publiczne API Google Gemini.

### [Simplify](https://github.com/CalebFenton/simplify)

To **ogólny deobfuskator dla Androida.** Simplify **wirtualnie wykonuje aplikację**, aby zrozumieć jej zachowanie, a następnie **stara się zoptymalizować kod**, tak aby zachowywał się identycznie, ale był łatwiejszy do zrozumienia przez człowieka. Każdy typ optymalizacji jest prosty i ogólny, więc nie ma znaczenia, jaki konkretny typ obfuskacji został użyty.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD dostarcza informacji o **tym, jak APK zostało stworzone**. Identyfikuje wiele **kompilatorów**, **packerów**, **obfuskatorów** i innych dziwnych rzeczy. To [_PEiD_](https://www.aldeid.com/wiki/PEiD) dla Androida.

### Manual

[Przeczytaj ten poradnik, aby poznać kilka trików dotyczących **odwracania niestandardowej obfuskacji**](manual-deobfuscation.md)

## Laboratoria

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b to wirtualna maszyna bezpieczeństwa Android oparta na ubuntu-mate, zawierająca kolekcję najnowszych frameworków, tutoriali i laboratoriów od różnych entuzjastów i badaczy bezpieczeństwa do reverse engineeringu i analizy malware.

## Referencje

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) To świetna lista zasobów
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)

## Do wypróbowania

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
