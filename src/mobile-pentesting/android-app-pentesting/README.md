# Pentesting εφαρμογών Android

{{#include ../../banners/hacktricks-training.md}}

## Βασικά των εφαρμογών Android

Συνιστάται ανεπιφύλακτα να ξεκινήσετε διαβάζοντας αυτή τη σελίδα για να μάθετε για τα **σημαντικότερα μέρη που σχετίζονται με την ασφάλεια του Android και τα πιο επικίνδυνα στοιχεία σε μια εφαρμογή Android**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

This is the main tool you need to connect to an android device (emulated or physical).\
**ADB** allows to control devices either over **USB** or **Network** from a computer. This utility enables the **copying** of files in both directions, **installation** and **uninstallation** of apps, **execution** of shell commands, **backing up** of data, **reading** of logs, among other functions.

Ρίξτε μια ματιά στην παρακάτω λίστα με [**ADB Commands**](adb-commands.md) για να μάθετε πώς να χρησιμοποιείτε το adb.

## Smali

Μερικές φορές είναι χρήσιμο να **τροποποιήσετε τον κώδικα της εφαρμογής** για να αποκτήσετε πρόσβαση σε **κρυφές πληροφορίες** (π.χ. καλά obfuscated passwords ή flags). Σε αυτές τις περιπτώσεις μπορεί να είναι χρήσιμο να αποσυμπιέσετε/αποκωδικοποιήσετε το APK, να τροποποιήσετε τον κώδικα και να το επανασυναρμολογήσετε.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Αυτό μπορεί να είναι πολύ χρήσιμο ως **εναλλακτική για διάφορες δοκιμές κατά τη διάρκεια της δυναμικής ανάλυσης** που πρόκειται να παρουσιαστούν. Συνεπώς, **έχετε πάντα κατά νου αυτή την πιθανότητα**.

## Άλλα ενδιαφέροντα κόλπα

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **Λήψη APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Εξαγωγή APK από συσκευή:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Συγχώνευσε όλα τα splits και τα base apks με [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Android Enterprise & Work Profile Attacks

{{#ref}}
android-enterprise-work-profile-bypass.md
{{#endref}}

## Case Studies & Vulnerabilities


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Static Analysis

Πρώτα απ' όλα, για την ανάλυση ενός APK θα πρέπει να **ρίξετε μια ματιά στον Java κώδικα** χρησιμοποιώντας έναν decompiler.\
Παρακαλώ, [**διαβάστε εδώ για να βρείτε πληροφορίες σχετικά με τους διαθέσιμους decompilers**](apk-decompilers.md).

### Looking for interesting Info

Απλώς κοιτάζοντας τα **strings** του APK μπορείτε να ψάξετε για **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** και οτιδήποτε ενδιαφέρον... ψάξτε ακόμα για code execution **backdoors** ή authentication backdoors (hardcoded admin credentials στην εφαρμογή).

**Firebase**

Δώστε ιδιαίτερη προσοχή στα **Firebase URLs** και ελέγξτε αν είναι κακώς διαμορφωμένο. [Περισσότερες πληροφορίες για το τι είναι το Firebase και πώς να το εκμεταλλευτείτε εδώ.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Basic understanding of the application - Manifest.xml, strings.xml

Η **εξέταση των αρχείων _Manifest.xml_ και **_strings.xml_** μιας εφαρμογής μπορεί να αποκαλύψει πιθανούς ευπαθείς χώρους ασφαλείας**. Αυτά τα αρχεία μπορούν να προσπελαστούν με decompilers ή με την μετονομασία της επέκτασης του APK σε .zip και έπειτα αποσυμπίεση.

**Ευπάθειες** που μπορούν να εντοπιστούν από το **Manifest.xml** περιλαμβάνουν:

- **Debuggable Applications**: Εφαρμογές που έχουν ρυθμιστεί ως debuggable (`debuggable="true"`) στο _Manifest.xml_ αποτελούν κίνδυνο καθώς επιτρέπουν συνδέσεις που μπορούν να οδηγήσουν σε εκμετάλλευση. Για περαιτέρω κατανόηση του πώς να εκμεταλλευτείτε debuggable εφαρμογές, ανατρέξτε σε ένα tutorial για την εύρεση και εκμετάλλευση debuggable εφαρμογών σε μια συσκευή.
- **Backup Settings**: Το attribute `android:allowBackup="false"` πρέπει να ορίζεται ρητά για εφαρμογές που χειρίζονται ευαίσθητες πληροφορίες για να αποτραπούν μη εξουσιοδοτημένα backups δεδομένων μέσω adb, ειδικά όταν το usb debugging είναι ενεργοποιημένο.
- **Network Security**: Custom network security configurations (`android:networkSecurityConfig="@xml/network_security_config"`) στο _res/xml/_ μπορούν να καθορίσουν λεπτομέρειες ασφαλείας όπως certificate pins και ρυθμίσεις HTTP traffic. Ένα παράδειγμα είναι η επιτρεπτότητα HTTP traffic για συγκεκριμένα domains.
- **Exported Activities and Services**: Ο εντοπισμός exported activities και services στο manifest μπορεί να αναδείξει components που μπορεί να καταχραστούν. Περαιτέρω ανάλυση κατά το dynamic testing μπορεί να αποκαλύψει πώς να εκμεταλλευτείτε αυτά τα components.
- **Content Providers and FileProviders**: Εκτεθειμένοι content providers θα μπορούσαν να επιτρέψουν μη εξουσιοδοτημένη πρόσβαση ή τροποποίηση δεδομένων. Η διαμόρφωση των FileProviders θα πρέπει επίσης να εξεταστεί προσεκτικά.
- **Broadcast Receivers and URL Schemes**: Αυτά τα components θα μπορούσαν να αξιοποιηθούν για εκμετάλλευση, με ιδιαίτερη προσοχή στον τρόπο διαχείρισης των URL schemes για input vulnerabilities.
- **SDK Versions**: Τα attributes `minSdkVersion`, `targetSDKVersion`, και `maxSdkVersion` δείχνουν τις υποστηριζόμενες εκδόσεις Android, υπογραμμίζοντας τη σημασία του να μην υποστηρίζονται παρωχημένες, ευπαθείς εκδόσεις Android.

Από το **strings.xml** αρχείο, μπορούν να ανακαλυφθούν ευαίσθητες πληροφορίες όπως API keys, custom schemas και άλλες σημειώσεις των developers, επισημαίνοντας την ανάγκη για προσεκτική ανασκόπηση αυτών των πόρων.

### Tapjacking

Το **Tapjacking** είναι μια επίθεση όπου μια **malicious** **application** ξεκινάει και **τοποθετείται πάνω από μια θύμα εφαρμογή**. Μόλις καλύψει οπτικά την εφαρμογή-θύμα, το UI της σχεδιάζεται έτσι ώστε να ξεγελάσει τον χρήστη να αλληλεπιδράσει με αυτήν, ενώ ταυτόχρονα περνά την αλληλεπίδραση στην εφαρμογή-θύμα.\
Στην ουσία, **τυφλώνει τον χρήστη ώστε να μην ξέρει ότι στην πραγματικότητα εκτελεί ενέργειες στην εφαρμογή-θύμα**.

Βρείτε περισσότερες πληροφορίες σε:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Μια **activity** με το **`launchMode`** ορισμένο σε **`singleTask` without any `taskAffinity`** defined είναι ευάλωτη σε Task Hijacking. Αυτό σημαίνει ότι μια **application** μπορεί να εγκατασταθεί και αν ξεκινήσει πριν από την πραγματική εφαρμογή, θα μπορούσε να **hijack the task of the real application** (οπότε ο χρήστης θα αλληλεπιδρά με την **malicious application νομίζοντας ότι χρησιμοποιεί την πραγματική**).

Περισσότερες πληροφορίες σε:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Insecure data storage

Internal Storage

Στο Android, τα αρχεία που **αποθηκεύονται** στο **internal** storage είναι **σχεδιασμένα** να είναι προσβάσιμα αποκλειστικά από την **app** που τα **δημιούργησε**. Αυτό το μέτρο ασφαλείας **επιβάλλεται** από το λειτουργικό σύστημα Android και είναι γενικά επαρκές για τις ανάγκες ασφάλειας των περισσότερων εφαρμογών. Ωστόσο, οι developers μερικές φορές χρησιμοποιούν modes όπως `MODE_WORLD_READABLE` και `MODE_WORLD_WRITABLE` για να **επιτρέψουν** τα αρχεία να **μοιράζονται** μεταξύ διαφορετικών εφαρμογών. Αυτά τα modes όμως **δεν περιορίζουν την πρόσβαση** σε αυτά τα αρχεία από άλλες εφαρμογές, συμπεριλαμβανομένων πιθανώς κακόβουλων.

1. **Static Analysis:**
- **Ensure** ότι η χρήση των `MODE_WORLD_READABLE` και `MODE_WORLD_WRITABLE` **εξετάζεται προσεκτικά**. Αυτά τα modes **μπορεί να εκθέσουν** αρχεία σε **μη επιθυμητή ή μη εξουσιοδοτημένη πρόσβαση**.
2. **Dynamic Analysis:**
- **Verify** τα **permissions** που ορίζονται σε αρχεία που δημιουργεί η εφαρμογή. Ειδικά, **ελέγξτε** αν κάποια αρχεία είναι **ρυθμισμένα να είναι readable ή writable worldwide**. Αυτό μπορεί να αποτελεί σημαντικό κίνδυνο ασφάλειας, καθώς θα επέτρεπε **σε οποιαδήποτε εφαρμογή** εγκατεστημένη στη συσκευή, ανεξαρτήτως προέλευσης ή πρόθεσης, να **διαβάσει ή να τροποποιήσει** αυτά τα αρχεία.

External Storage

Όταν χειρίζεστε αρχεία στο **external storage**, όπως SD Cards, πρέπει να λάβετε υπόψη τα εξής:

1. **Accessibility**:
- Τα αρχεία στο external storage είναι **global readable and writable**. Αυτό σημαίνει ότι οποιαδήποτε εφαρμογή ή χρήστης μπορεί να έχει πρόσβαση σε αυτά.
2. **Security Concerns**:
- Δεδομένης της εύκολης πρόσβασης, συνιστάται **να μην αποθηκεύετε ευαίσθητες πληροφορίες** στο external storage.
- Το external storage μπορεί να αφαιρεθεί ή να προσπελαστεί από οποιαδήποτε εφαρμογή, καθιστώντας το λιγότερο ασφαλές.
3. **Handling Data from External Storage**:
- Πάντα **εκτελέστε input validation** στα δεδομένα που λαμβάνονται από το external storage. Αυτό είναι κρίσιμο επειδή τα δεδομένα προέρχονται από μη αξιόπιστη πηγή.
- Η αποθήκευση εκτελέσιμων ή class files στο external storage για dynamic loading αποθαρρύνεται έντονα.
- Αν η εφαρμογή σας πρέπει να ανακτήσει εκτελέσιμα αρχεία από το external storage, βεβαιωθείτε ότι αυτά τα αρχεία είναι **signed και cryptographically verified** πριν να γίνει dynamic load. Αυτό το βήμα είναι σημαντικό για τη διατήρηση της ασφάλειας της εφαρμογής σας.

Το external storage μπορεί να **προσπελαστεί** σε `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> Από την έκδοση Android 4.4 (**API 17**), η SD card έχει μια δομή φακέλων που **περιορίζει την πρόσβαση από μια app στον φάκελο που είναι ειδικά για αυτήν την app**. Αυτό αποτρέπει κακόβουλες εφαρμογές από το να αποκτήσουν read ή write πρόσβαση στα αρχεία άλλης εφαρμογής.

**Sensitive data stored in clear-text**

- **Shared preferences**: Το Android επιτρέπει σε κάθε εφαρμογή να αποθηκεύει εύκολα xml αρχεία στη διαδρομή `/data/data/<packagename>/shared_prefs/` και μερικές φορές είναι δυνατό να βρεθούν ευαίσθητες πληροφορίες σε clear-text σε αυτόν τον φάκελο.
- **Databases**: Το Android επιτρέπει σε κάθε εφαρμογή να αποθηκεύει εύκολα sqlite βάσεις δεδομένων στη διαδρομή `/data/data/<packagename>/databases/` και μερικές φορές είναι δυνατό να βρεθούν ευαίσθητες πληροφορίες σε clear-text σε αυτόν τον φάκελο.

### Broken TLS

Accept All Certificates

Για κάποιο λόγο μερικές φορές οι developers αποδέχονται όλα τα certificates ακόμα και αν για παράδειγμα το hostname δεν ταιριάζει με γραμμές κώδικα όπως η ακόλουθη:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Μια καλή μέθοδος για να το δοκιμάσετε είναι να προσπαθήσετε να καταγράψετε την κίνηση χρησιμοποιώντας κάποιο proxy όπως το Burp χωρίς να εξουσιοδοτήσετε το Burp CA μέσα στη συσκευή. Επίσης, μπορείτε να δημιουργήσετε με το Burp ένα πιστοποιητικό για διαφορετικό hostname και να το χρησιμοποιήσετε.

### Σπασμένη Κρυπτογραφία

**Κακές Διαδικασίες Διαχείρισης Κλειδιών**

Κάποιοι προγραμματιστές αποθηκεύουν ευαίσθητα δεδομένα στο local storage και τα κρυπτογραφούν με ένα κλειδί hardcoded/predictable στον κώδικα. Αυτό δεν θα έπρεπε να γίνεται καθώς κάποιο reversing μπορεί να επιτρέψει σε attackers να εξάγουν τις εμπιστευτικές πληροφορίες.

**Χρήση Μη Ασφαλών και/ή Deprecated Αλγορίθμων**

Οι προγραμματιστές δεν θα έπρεπε να χρησιμοποιούν **deprecated algorithms** για να πραγματοποιούν έλεγχους εξουσιοδότησης, να **αποθηκεύουν** ή να **στέλνουν** δεδομένα. Μερικοί από αυτούς τους αλγορίθμους είναι: RC4, MD4, MD5, SHA1... Αν χρησιμοποιούνται **hashes** για να αποθηκεύονται passwords για παράδειγμα, θα πρέπει να χρησιμοποιούνται hashes resistant σε brute-force με salt.

### Άλλοι έλεγχοι

- Συνιστάται να **obfuscate the APK** για να δυσκολέψετε την εργασία του reverse engineer στους attackers.
- Αν η εφαρμογή είναι ευαίσθητη (όπως bank apps), θα πρέπει να πραγματοποιεί τους δικούς της **ελέγχους για να διαπιστώσει αν το κινητό είναι rooted** και να ενεργεί ανάλογα.
- Αν η εφαρμογή είναι ευαίσθητη (όπως bank apps), θα πρέπει να ελέγχει αν χρησιμοποιείται **emulator**.
- Αν η εφαρμογή είναι ευαίσθητη (όπως bank apps), θα πρέπει να **ελέγχει την ακεραιότητά της πριν την εκτέλεση** για να διαπιστώσει αν έχει τροποποιηθεί.
- Χρησιμοποιήστε [**APKiD**](https://github.com/rednaga/APKiD) για να ελέγξετε ποιος compiler/packer/obfuscator χρησιμοποιήθηκε για να χτιστεί το APK

### React Native Εφαρμογή

Διαβάστε την παρακάτω σελίδα για να μάθετε πώς να αποκτάτε εύκολα πρόσβαση στον javascript κώδικα των React εφαρμογών:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Εφαρμογές

Διαβάστε την παρακάτω σελίδα για να μάθετε πώς να αποκτάτε εύκολα πρόσβαση στον C# κώδικα μιας xamarin εφαρμογής:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Εφαρμογές

Σύμφωνα με αυτό το [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) το superpacked είναι ένας Meta αλγόριθμος που συμπιέζει το περιεχόμενο μιας εφαρμογής σε ένα ενιαίο αρχείο. Το blog αναφέρεται στην πιθανότητα δημιουργίας μιας εφαρμογής που αποσυμπιέζει αυτού του είδους τις εφαρμογές... και σε έναν ταχύτερο τρόπο που περιλαμβάνει την εκτέλεση της εφαρμογής και τη συλλογή των αποσυμπιεσμένων αρχείων από το filesystem.

### Αυτόματη Στατική Ανάλυση Κώδικα

Το εργαλείο [**mariana-trench**](https://github.com/facebook/mariana-trench) είναι ικανό να εντοπίζει **vulnerabilities** μέσω **scanning** του **code** της εφαρμογής. Αυτό το εργαλείο περιέχει μια σειρά από **known sources** (που υποδεικνύουν στο εργαλείο τα **σημεία** όπου το **input** **ελέγχεται από τον χρήστη**), **sinks** (που υποδεικνύουν στο εργαλείο **επικίνδυνα** **σημεία** όπου κακόβουλο user input μπορεί να προκαλέσει ζημιά) και **rules**. Αυτοί οι κανόνες υποδεικνύουν τον **συνδυασμό** **sources-sinks** που υποδεικνύει μια ευπάθεια.

Με αυτά τα δεδομένα, **mariana-trench θα εξετάσει τον κώδικα και θα εντοπίσει πιθανές ευπάθειες σε αυτόν**.

### Secrets leaked

Μια εφαρμογή μπορεί να περιέχει secrets (API keys, passwords, hidden urls, subdomains...) μέσα της που μπορεί να καταφέρετε να ανακαλύψετε. Μπορείτε να χρησιμοποιήσετε ένα εργαλείο όπως [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Άλλες ενδιαφέρουσες λειτουργίες

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Διαβάστε αυτό για να μάθετε **πώς να reverse native functions**](reversing-native-libraries.md)
- Εκτέλεση native κώδικα στη μνήμη μέσω JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Άλλα κόλπα**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Δυναμική Ανάλυση

> Πρωτίστως, χρειάζεστε ένα περιβάλλον όπου μπορείτε να εγκαταστήσετε την εφαρμογή και όλο το περιβάλλον (Burp CA cert, Drozer και Frida κυρίως). Επομένως, μια rooted συσκευή (emulated ή όχι) συνιστάται έντονα.

### Online Dynamic analysis

Μπορείτε να δημιουργήσετε έναν **free account** σε: [https://appetize.io/](https://appetize.io). Αυτή η πλατφόρμα σας επιτρέπει να **upload** και να **execute** APKs, οπότε είναι χρήσιμη για να δείτε πώς συμπεριφέρεται ένα apk.

Μπορείτε ακόμη να **δειτε τα logs της εφαρμογής σας** στο web και να συνδεθείτε μέσω **adb**.

![](<../../images/image (831).png>)

Χάρη στη σύνδεση ADB μπορείτε να χρησιμοποιήσετε **Drozer** και **Frida** μέσα στους emulators.

### Τοπική Δυναμική Ανάλυση

#### Χρήση emulator

- [**Android Studio**](https://developer.android.com/studio) (Μπορείτε να δημιουργήσετε **x86** και **arm** συσκευές, και σύμφωνα με [**αυτό**](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**οι νεότερες x86** εκδόσεις **υποστηρίζουν ARM βιβλιοθήκες** χωρίς να χρειάζεται ένας αργός arm emulator).
- Μάθετε πώς να το ρυθμίσετε σε αυτή τη σελίδα:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Δωρεάν έκδοση:** Personal Edition, χρειάζεται να δημιουργήσετε account. _Συνιστάται να **κατεβάσετε** την έκδοση **WITH**_ _**VirtualBox** για να αποφύγετε πιθανά σφάλματα._)
- [**Nox**](https://es.bignox.com) (Δωρεάν, αλλά δεν υποστηρίζει Frida ή Drozer).

> [!TIP]
> Όταν δημιουργείτε ένα νέο emulator σε οποιαδήποτε πλατφόρμα να θυμάστε ότι όσο μεγαλύτερη είναι η οθόνη, τόσο πιο αργά θα τρέχει ο emulator. Οπότε επιλέξτε μικρές οθόνες αν είναι δυνατόν.

Για να **εγκαταστήσετε google services** (όπως AppStore) στο Genymotion πρέπει να κάνετε κλικ στο κόκκινο κουμπί όπως στην εικόνα:

![](<../../images/image (277).png>)

Επίσης, σημειώστε ότι στην **διαμόρφωση του Android VM στο Genymotion** μπορείτε να επιλέξετε **Bridge Network mode** (αυτό θα είναι χρήσιμο αν θα συνδέεστε στο Android VM από ένα διαφορετικό VM με τα εργαλεία).

#### Χρήση φυσικής συσκευής

Πρέπει να ενεργοποιήσετε τις **επιλογές αποσφαλμάτωσης (debugging)** και είναι χρήσιμο αν μπορείτε να την **root**:

1. **Settings**.
2. (Από Android 8.0) Επιλέξτε **System**.
3. Επιλέξτε **About phone**.
4. Πατήστε **Build number** 7 φορές.
5. Επιστρέψτε και θα βρείτε τις **Developer options**.

> Αφού εγκαταστήσετε την εφαρμογή, το πρώτο πράγμα που πρέπει να κάνετε είναι να τη δοκιμάσετε και να διερευνήσετε τι κάνει, πώς λειτουργεί και να εξοικειωθείτε με αυτήν.\
> Προτείνω να **κάνετε αυτήν την αρχική δυναμική ανάλυση χρησιμοποιώντας MobSF dynamic analysis + pidcat**, ώστε να μπορέσουμε να **μάθουμε πώς λειτουργεί η εφαρμογή** ενώ το MobSF **συλλαμβάνει** πολλά **ενδιαφέροντα** **δεδομένα** που μπορείτε να ανασκοπήσετε αργότερα.

Magisk/Zygisk quick notes (συνιστάται σε Pixel συσκευές)
- Patch boot.img με την εφαρμογή Magisk και flash μέσω fastboot για να αποκτήσετε systemless root
- Ενεργοποιήστε Zygisk + DenyList για απόκρυψη root; σκεφτείτε LSPosed/Shamiko όταν χρειάζεται ισχυρότερη απόκρυψη
- Κρατήστε το αρχικό boot.img για ανάκτηση από OTA ενημερώσεις; επανα-φτιάξτε το μετά από κάθε OTA
- Για mirroring οθόνης, χρησιμοποιήστε scrcpy στον host



### Unintended Data Leakage

**Logging**

Οι προγραμματιστές πρέπει να είναι προσεκτικοί στο να μην εκθέτουν δημόσια **debugging information**, καθώς αυτό μπορεί να οδηγήσει σε sensitive data leaks. Τα εργαλεία [**pidcat**](https://github.com/JakeWharton/pidcat) και `adb logcat` συνιστώνται για την παρακολούθηση των logs της εφαρμογής ώστε να εντοπιστούν και να προστατευτούν ευαίσθητες πληροφορίες. **Pidcat** προτιμάται για την ευκολία χρήσης και την αναγνωσιμότητά του.

> [!WARNING]
> Σημειώστε ότι από **εκδόσεις μεταγενέστερες του Android 4.0**, **οι εφαρμογές μπορούν να έχουν πρόσβαση μόνο στα δικά τους logs**. Έτσι οι εφαρμογές δεν μπορούν να έχουν πρόσβαση στα logs άλλων εφαρμογών.\
> Παρ' όλα αυτά, συνιστάται να **μην καταγράφεται ευαίσθητη πληροφορία**.

**Copy/Paste Buffer Caching**

Το **clipboard-based** πλαίσιο του Android επιτρέπει λειτουργίες αντιγραφής-επικόλλησης στις εφαρμογές, αλλά ενέχει κίνδυνο καθώς **άλλες εφαρμογές** μπορούν να **έχουν πρόσβαση** στο clipboard, εκθέτοντας ενδεχομένως ευαίσθητα δεδομένα. Είναι κρίσιμο να **απενεργοποιούνται οι λειτουργίες copy/paste** για ευαίσθητες ενότητες μιας εφαρμογής, όπως στοιχεία πιστωτικών καρτών, για να αποφευχθούν leak.

**Crash Logs**

Αν μια εφαρμογή **crashes** και **αποθηκεύει logs**, αυτά τα logs μπορούν να βοηθήσουν attackers, ειδικά όταν η εφαρμογή δεν μπορεί να ανασυγκροτηθεί (reverse-engineered). Για να μετριαστεί ο κίνδυνος, αποφύγετε την καταγραφή κατά τα crashes, και αν τα logs πρέπει να αποστέλλονται μέσω δικτύου, βεβαιωθείτε ότι αποστέλλονται μέσω SSL καναλιού για ασφάλεια.

Ως pentester, **προσπαθήστε να ρίξετε μια ματιά σε αυτά τα logs**.

**Analytics Data Sent To 3rd Parties**

Οι εφαρμογές συχνά ενσωματώνουν υπηρεσίες όπως Google Adsense, οι οποίες ενδέχεται να **leak sensitive data** λόγω ακατάλληλης υλοποίησης από τους προγραμματιστές. Για να εντοπίσετε πιθανές διαρροές, συνιστάται να **παρατηρήσετε την κίνηση της εφαρμογής** και να ελέγξετε για οποιαδήποτε sensitive πληροφορία που στέλνεται σε τρίτους.

### SQLite DBs

Οι περισσότερες εφαρμογές θα χρησιμοποιούν **εσωτερικές SQLite βάσεις δεδομένων** για να αποθηκεύουν πληροφορίες. Κατά τη διάρκεια του pentest κοιτάξτε τις **βάσεις δεδομένων** που δημιουργούνται, τα ονόματα των **πινάκων** και **στηλών** και όλα τα **δεδομένα** που αποθηκεύονται γιατί μπορεί να βρείτε **ευαίσθητες πληροφορίες** (που θα συνιστούσαν ευπάθεια).\
Οι βάσεις δεδομένων θα πρέπει να βρίσκονται στο `/data/data/the.package.name/databases` όπως `/data/data/com.mwr.example.sieve/databases`

Αν η βάση δεδομένων αποθηκεύει εμπιστευτικές πληροφορίες και είναι **encrypted** αλλά μπορείτε να **βρείτε** το **password** μέσα στην εφαρμογή, είναι ακόμα μια **ευπάθεια**.

Καταγράψτε τους πίνακες χρησιμοποιώντας `.tables` και καταγράψτε τις στήλες των πινάκων με `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

Από τα [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** σας επιτρέπει να **υποδυθείτε τον ρόλο μιας Android app** και να αλληλεπιδράσετε με άλλες εφαρμογές. Μπορεί να κάνει **οτιδήποτε μπορεί να κάνει μια εγκατεστημένη εφαρμογή**, όπως να χρησιμοποιήσει τον μηχανισμό Inter-Process Communication (IPC) του Android και να αλληλεπιδράσει με το υποκείμενο λειτουργικό σύστημα. .\
Το Drozer είναι ένα χρήσιμο εργαλείο για να **εκμεταλλευτεί exported activities, exported services και Content Providers** όπως θα μάθετε στις ακόλουθες ενότητες.

### Εκμετάλλευση exported Activities

[**Διαβάστε αυτό αν θέλετε να ανανεώσετε τι είναι ένα Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Θυμηθείτε επίσης ότι ο κώδικας μιας activity ξεκινά στη μέθοδο **`onCreate`**.

**Παράκαμψη εξουσιοδότησης**

Όταν μια Activity είναι exported μπορείτε να καλέσετε την οθόνη της από μια εξωτερική εφαρμογή. Επομένως, αν μια activity με **ευαίσθητες πληροφορίες** είναι **exported** μπορείτε να **παρακάμψετε** τους μηχανισμούς **authentication** για να αποκτήσετε πρόσβαση σε αυτήν.

[**Μάθετε πώς να εκμεταλλευτείτε exported activities με Drozer.**](drozer-tutorial/index.html#activities)

Μπορείτε επίσης να ξεκινήσετε μια exported activity από adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF θα ανιχνεύσει ως κακόβουλη τη χρήση των _**singleTask/singleInstance**_ ως `android:launchMode` σε μια activity, αλλά λόγω [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), φαινομενικά αυτό είναι επικίνδυνο μόνο σε παλιές εκδόσεις (API versions < 21).

> [!TIP]
> Σημειώστε ότι ένα authorisation bypass δεν είναι πάντα ευπάθεια — εξαρτάται από τον τρόπο που λειτουργεί το bypass και ποιες πληροφορίες αποκαλύπτονται.

**Sensitive information leakage**

**Activities can also return results**. Αν καταφέρετε να βρείτε μια exported και unprotected activity που καλεί τη μέθοδο **`setResult`** και **επιστρέφει ευαίσθητες πληροφορίες**, υπάρχει sensitive information leakage.

#### Tapjacking

If tapjacking isn't prevented, μπορείτε να καταχραστείτε την exported activity για να κάνετε τον χρήστη να εκτελέσει απροσδόκητες ενέργειες. Για περισσότερες πληροφορίες σχετικά με [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Οι Content providers χρησιμοποιούνται βασικά για να **share data**. Αν μια εφαρμογή διαθέτει content providers, μπορεί να καταφέρετε να **extract sensitive** δεδομένα από αυτούς. Είναι επίσης σημαντικό να δοκιμάσετε πιθανές **SQL injections** και **Path Traversals**, καθώς μπορεί να είναι ευάλωτοι.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Θυμηθείτε ότι οι ενέργειες ενός Service ξεκινούν στη μέθοδο `onStartCommand`.

Ένα Service είναι βασικά κάτι που **can receive data**, **process** it και **returns** (ή όχι) μια απάντηση. Επομένως, αν μια εφαρμογή εξάγει κάποια services θα πρέπει να **check** τον **code** για να καταλάβετε τι κάνει και να το **test** **dynamically** για εξαγωγή εμπιστευτικών πληροφοριών, bypassing authentication measures...\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Θυμηθείτε ότι οι ενέργειες ενός Broadcast Receiver ξεκινούν στη μέθοδο `onReceive`.

Ένας broadcast receiver θα περιμένει έναν τύπο μηνύματος. Ανάλογα με τον τρόπο που ο receiver χειρίζεται το μήνυμα, μπορεί να είναι ευάλωτος.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Μπορείτε να ψάξετε για deep links χειροκίνητα, χρησιμοποιώντας εργαλεία όπως το MobSF ή scripts όπως [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Μπορείτε να **open** ένα δηλωμένο **scheme** χρησιμοποιώντας **adb** ή έναν **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Σημειώστε ότι μπορείτε να **omit the package name** και το κινητό θα καλέσει αυτόματα την εφαρμογή που πρέπει να ανοίξει αυτόν τον σύνδεσμο._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Εκτελούμενος κώδικας**

Για να βρείτε τον **κώδικα που θα εκτελεστεί στην App**, μεταβείτε στην activity που καλείται από το deeplink και αναζητήστε τη συνάρτηση **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Ευαίσθητες πληροφορίες**

Κάθε φορά που βρίσκετε ένα deep link ελέγξτε ότι **δεν λαμβάνει ευαίσθητα δεδομένα (όπως passwords) μέσω των URL παραμέτρων**, γιατί οποιαδήποτε άλλη εφαρμογή θα μπορούσε **να impersonate το deep link και να κλέψει αυτά τα δεδομένα!**

**Παράμετροι στο path**

Πρέπει επίσης να ελέγξετε αν κάποιο deep link χρησιμοποιεί παράμετρο μέσα στο path του URL, π.χ.: `https://api.example.com/v1/users/{username}`. Σε αυτή την περίπτωση μπορείτε να αναγκάσετε ένα path traversal προσπελάζοντας κάτι σαν: `example://app/users?username=../../unwanted-endpoint%3fparam=value`.\
Σημειώστε ότι αν βρείτε τα σωστά endpoints μέσα στην εφαρμογή μπορεί να καταφέρετε να προκαλέσετε ένα **Open Redirect** (αν μέρος του path χρησιμοποιείται ως domain name), **account takeover** (αν μπορείτε να τροποποιήσετε στοιχεία χρήστη χωρίς CSRF token και το ευπαθές endpoint χρησιμοποιούσε τη σωστή μέθοδο) και οποιαδήποτε άλλη ευπάθεια. Περισσότερες [πληροφορίες εδώ](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Transport Layer Inspection and Verification Failures

- **Τα certificates δεν ελέγχονται πάντα σωστά** από Android εφαρμογές. Είναι κοινό αυτές οι εφαρμογές να αγνοούν προειδοποιήσεις και να αποδέχονται self-signed certificates ή, σε κάποιες περιπτώσεις, να επανέρχονται σε HTTP συνδέσεις.
- **Οι διαπραγματεύσεις κατά το SSL/TLS handshake είναι μερικές φορές αδύναμες**, χρησιμοποιώντας ανασφαλείς cipher suites. Αυτή η ευπάθεια καθιστά τη σύνδεση ευάλωτη σε man-in-the-middle (MITM) επιθέσεις, επιτρέποντας σε επιτιθέμενους να αποκρυπτογραφήσουν τα δεδομένα.
- Leakage of private information είναι ρίσκο όταν οι εφαρμογές κάνουν authentication χρησιμοποιώντας secure channels αλλά μετά επικοινωνούν μέσω μη ασφαλών καναλιών για άλλες συναλλαγές. Αυτή η προσέγγιση δεν προστατεύει ευαίσθητα δεδομένα, όπως session cookies ή στοιχεία χρηστών, από υποκλοπή από κακόβουλες οντότητες.

#### Certificate Verification

Θα επικεντρωθούμε στον **έλεγχο των certificates**. Η ακεραιότητα του certificate του server πρέπει να επαληθεύεται για να ενισχυθεί η ασφάλεια. Αυτό είναι κρίσιμο γιατί οι ανασφαλείς TLS ρυθμίσεις και η μετάδοση ευαίσθητων δεδομένων μέσω μη κρυπτογραφημένων καναλιών μπορούν να προκαλέσουν σημαντικούς κινδύνους. Για λεπτομερή βήματα σχετικά με την επαλήθευση των server certificates και την αντιμετώπιση ευπαθειών, [**αυτή η πηγή**](https://manifestsecurity.com/android-application-security-part-10/) παρέχει ολοκληρωμένες οδηγίες.

#### SSL Pinning

Το SSL Pinning είναι ένα μέτρο ασφαλείας όπου η εφαρμογή επαληθεύει το certificate του server έναντι ενός γνωστού αντιγράφου που είναι αποθηκευμένο μέσα στην εφαρμογή. Αυτή η μέθοδος είναι ουσιώδης για την αποτροπή MITM επιθέσεων. Η υλοποίηση SSL Pinning συνιστάται έντονα για εφαρμογές που χειρίζονται ευαίσθητες πληροφορίες.

#### Traffic Inspection

Για να ελέγξετε το HTTP traffic, είναι απαραίτητο να **εγκαταστήσετε το certificate του proxy tool** (π.χ. Burp). Χωρίς την εγκατάσταση αυτού του certificate, το κρυπτογραφημένο traffic μπορεί να μην είναι ορατό μέσω του proxy. Για οδηγίες σχετικά με την εγκατάσταση ενός custom CA certificate, [**κάντε κλικ εδώ**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Εφαρμογές που στοχεύουν **API Level 24 and above** απαιτούν τροποποιήσεις στο Network Security Config για να αποδεχτούν το CA certificate του proxy. Αυτό το βήμα είναι κρίσιμο για την επιθεώρηση κρυπτογραφημένου traffic. Για οδηγίες σχετικά με την τροποποίηση του Network Security Config, [**ανατρέξτε σε αυτό το tutorial**](make-apk-accept-ca-certificate.md).

Αν χρησιμοποιείται **Flutter** πρέπει να ακολουθήσετε τις οδηγίες στη [**σελίδα αυτή**](flutter.md). Αυτό οφείλεται στο ότι απλά η προσθήκη του certificate στο store δεν θα λειτουργήσει, καθώς το Flutter έχει τη δική του λίστα με έγκυρα CAs.

#### Static detection of SSL/TLS pinning

Πριν επιχειρήσετε runtime bypasses, κάντε γρήγορο mapping για το πού εφαρμόζεται το pinning στο APK. Η static discovery βοηθάει να σχεδιάσετε hooks/patches και να επικεντρωθείτε στα σωστά μονοπάτια κώδικα.

Tool: SSLPinDetect
- Open-source static-analysis utility που decompiles το APK σε Smali (via apktool) και σαρώνει για curated regex patterns υλοποιήσεων SSL/TLS pinning.
- Αναφέρει το ακριβές file path, αριθμό γραμμής και ένα snippet κώδικα για κάθε match.
- Καλύπτει κοινούς frameworks και custom code paths: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, και Network Security Config XML pins.

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Χρήση
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Παραδείγματα κανόνων μοτίβων (JSON)
Χρησιμοποιήστε ή επεκτείνετε signatures για να ανιχνεύσετε proprietary/custom pinning styles. Μπορείτε να φορτώσετε το δικό σας JSON και να σαρώσετε σε μεγάλη κλίμακα.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Σημειώσεις και συμβουλές
- Fast scanning on large apps via multi-threading and memory-mapped I/O; pre-compiled regex reduces overhead/false positives.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Τυπικοί στόχοι ανίχνευσης για περαιτέρω διερεύνηση:
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Declarative pins in res/xml network security config and manifest references
- Use the matched locations to plan Frida hooks, static patches, or config reviews before dynamic testing.



#### Παράκαμψη SSL Pinning

Όταν το SSL Pinning είναι υλοποιημένο, η παράκαμψή του γίνεται απαραίτητη για να επιθεωρήσετε το HTTPS traffic. Υπάρχουν διάφορες μέθοδοι για αυτό το σκοπό:

- Automatically **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Το κύριο πλεονέκτημα αυτής της επιλογής είναι ότι δεν θα χρειαστείτε root για να παρακάμψετε το SSL Pinning, αλλά θα χρειαστεί να διαγράψετε την εφαρμογή και να εγκαταστήσετε ξανά τη νέα, και αυτό δεν λειτουργεί πάντα.
- Μπορείτε να χρησιμοποιήσετε **Frida** (συζητείται παρακάτω) για να παρακάμψετε αυτήν την προστασία. Εδώ υπάρχει ένας οδηγός για χρήση Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Μπορείτε επίσης να δοκιμάσετε να **παρακάμψετε αυτόματα το SSL Pinning** χρησιμοποιώντας [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Μπορείτε επίσης να δοκιμάσετε να **παρακάμψετε αυτόματα το SSL Pinning** χρησιμοποιώντας **MobSF dynamic analysis** (εξηγείται παρακάτω)
- Αν εξακολουθείτε να νομίζετε ότι υπάρχει κίνηση που δεν καταγράφεται, μπορείτε να δοκιμάσετε να **προωθήσετε την κίνηση προς Burp χρησιμοποιώντας iptables**. Διαβάστε αυτό το blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Αναζήτηση Συνήθων Web Ευπαθειών

Είναι σημαντικό επίσης να αναζητήσετε κοινές web ευπάθειες μέσα στην εφαρμογή. Λεπτομερείς πληροφορίες για την αναγνώριση και την αντιμετώπιση αυτών των ευπαθειών υπερβαίνουν το πεδίο αυτής της σύνοψης αλλά καλύπτονται εκτενώς αλλού.

### Frida

[Frida](https://www.frida.re) είναι μια dynamic instrumentation toolkit για developers, reverse-engineers, και security researchers.\
**Μπορείτε να έχετε πρόσβαση σε μια τρέχουσα εφαρμογή και να κάνετε hook μεθόδους κατά το run time για να αλλάξετε τη συμπεριφορά, να αλλάξετε τιμές, να εξάγετε τιμές, να τρέξετε διαφορετικό κώδικα...**\
Αν θέλετε να pentest Android applications πρέπει να ξέρετε πώς να χρησιμοποιείτε το Frida.

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Some "GUI" for actions with Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- You can find some Awesome Frida scripts here: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Try to bypass anti-debugging / anti-frida mechanisms loading Frida as in indicated in [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

Ελέγξτε αν η εφαρμογή αποθηκεύει ευαίσθητες πληροφορίες στη μνήμη που δεν θα έπρεπε να αποθηκεύει, όπως passwords ή mnemonics.

Using [**Fridump3**](https://github.com/rootbsd/fridump3) you can dump the memory of the app with:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Αυτό θα κάνει dump της μνήμης στο φάκελο ./dump, και εκεί μπορείτε να κάνετε grep με κάτι σαν:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Ευαίσθητα δεδομένα στο Keystore**

Στο Android το Keystore είναι ο καλύτερος χώρος για την αποθήκευση ευαίσθητων δεδομένων, ωστόσο με επαρκή προνόμια εξακολουθεί να είναι **πιθανό να αποκτηθεί πρόσβαση σε αυτό**. Δεδομένου ότι οι εφαρμογές τείνουν να αποθηκεύουν εδώ **ευαίσθητα δεδομένα σε clear text**, οι pentests θα πρέπει να το ελέγχουν ως root user ή κάποιος με physical access στη συσκευή θα μπορούσε να κλέψει αυτά τα δεδομένα.

Ακόμη και αν μια εφαρμογή αποθήκευσε δεδομένα στο keystore, τα δεδομένα πρέπει να είναι κρυπτογραφημένα.

Για πρόσβαση στα δεδομένα μέσα στο keystore μπορείτε να χρησιμοποιήσετε αυτό το Frida script: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Χρησιμοποιώντας το παρακάτω Frida script, μπορεί να είναι δυνατό να **bypass fingerprint authentication** που μπορεί να πραγματοποιούν εφαρμογές Android προκειμένου να **προστατεύσουν ορισμένες ευαίσθητες περιοχές:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Εικόνες φόντου**

Όταν βάζετε μια εφαρμογή στο παρασκήνιο, το Android αποθηκεύει ένα **snapshot της εφαρμογής** ώστε όταν επανέλθει στο προσκήνιο να ξεκινήσει φορτώνοντας την εικόνα πριν την ίδια την εφαρμογή, έτσι φαίνεται ότι η εφαρμογή φόρτωσε πιο γρήγορα.

Ωστόσο, αν αυτό το **snapshot** περιέχει **ευαίσθητες πληροφορίες**, κάποιος με πρόσβαση στο snapshot μπορεί να **κλέψει αυτές τις πληροφορίες** (σημείωση: χρειάζεστε root για να έχετε πρόσβαση).

Τα snapshots αποθηκεύονται συνήθως εδώ: **`/data/system_ce/0/snapshots`**

Το Android παρέχει έναν τρόπο να **αποτρέψετε τη λήψη στιγμιότυπων οθόνης θέτοντας την FLAG_SECURE** παράμετρο διάταξης. Χρησιμοποιώντας αυτή τη σημαία, το περιεχόμενο του παραθύρου αντιμετωπίζεται ως ασφαλές, αποτρέποντας την εμφάνισή του σε στιγμιότυπα οθόνης ή την προβολή του σε μη ασφαλείς οθόνες.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Αυτό το εργαλείο μπορεί να σας βοηθήσει στη διαχείριση διαφόρων εργαλείων κατά τη διάρκεια της δυναμικής ανάλυσης: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Οι προγραμματιστές συχνά δημιουργούν proxy components όπως activities, services και broadcast receivers που χειρίζονται αυτά τα Intents και τα περνάνε σε μεθόδους όπως `startActivity(...)` ή `sendBroadcast(...)`, κάτι που μπορεί να είναι επικίνδυνο.

Ο κίνδυνος έγκειται στο να επιτρέπεται σε επιτιθέμενους να ενεργοποιούν μη-exported app components ή να αποκτούν πρόσβαση σε sensitive content providers παραπλανώντας αυτά τα Intents. Ένα αξιοσημείωτο παράδειγμα είναι το `WebView` component που μετατρέπει URLs σε `Intent` objects μέσω `Intent.parseUri(...)` και στη συνέχεια τα εκτελεί, οδηγώντας ενδεχομένως σε κακόβουλες Intent injections.

### Βασικά Συμπεράσματα

- **Intent Injection** είναι παρόμοιο με το web Open Redirect issue.
- Οι εκμεταλλεύσεις περιλαμβάνουν τη μεταβίβαση `Intent` objects ως extras, τα οποία μπορούν να ανακατευθυνθούν για να εκτελέσουν επικίνδυνες λειτουργίες.
- Μπορεί να εκθέσει non-exported components και content providers σε επιτιθέμενους.
- Η μετατροπή URL σε `Intent` από το `WebView` μπορεί να διευκολύνει μη επιθυμητές ενέργειες.

### Android Client Side Injections and others

Πιθανώς γνωρίζετε αυτό το είδος ευπαθειών από το Web. Πρέπει να είστε ιδιαίτερα προσεκτικοί με αυτές τις ευπάθειες σε μια εφαρμογή Android:

- **SQL Injection:** Όταν χειρίζεστε δυναμικά ερωτήματα ή Content-Providers, βεβαιωθείτε ότι χρησιμοποιείτε παραμετροποιημένες ερωτήσεις.
- **JavaScript Injection (XSS):** Επιβεβαιώστε ότι η υποστήριξη JavaScript και των Plugin είναι απενεργοποιημένη για οποιοδήποτε WebViews (απενεργοποιημένη από προεπιλογή). [Περισσότερες πληροφορίες εδώ](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** Οι WebViews θα πρέπει να έχουν την πρόσβαση στο file system απενεργοποιημένη (ενεργοποιημένη από προεπιλογή) - `(webview.getSettings().setAllowFileAccess(false);)`. [Περισσότερες πληροφορίες εδώ](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: Σε αρκετές περιπτώσεις όταν η android εφαρμογή τερματίζει τη συνεδρία το cookie δεν ανακαλείται ή μπορεί ακόμα και να αποθηκευτεί στο δίσκο
- [Flag ασφαλείας στα cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Αυτόματη Ανάλυση

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Στατική ανάλυση**

![](<../../images/image (866).png>)

**Αξιολόγηση ευπαθειών της εφαρμογής** χρησιμοποιώντας ένα όμορφο διαδικτυακό frontend. Μπορείτε επίσης να πραγματοποιήσετε δυναμική ανάλυση (αλλά χρειάζεται να προετοιμάσετε το περιβάλλον).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Σημειώστε ότι το MobSF μπορεί να αναλύσει **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Επίσης, αν δημιουργήσετε ένα **ZIP** αρχείο με τον πηγαίο κώδικα μιας **Android** ή μιας **IOS** εφαρμογής (πηγαίνετε στον root φάκελο της εφαρμογής, επιλέξτε τα πάντα και δημιουργήστε ένα ZIPfile), θα μπορεί επίσης να το αναλύσει.

MobSF επίσης σας επιτρέπει να κάνετε **diff/Compare** αναλύσεις και να ενσωματώσετε το **VirusTotal** (θα χρειαστεί να ορίσετε το API key σας στο _MobSF/settings.py_ και να το ενεργοποιήσετε: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). Μπορείτε επίσης να ορίσετε `VT_UPLOAD` σε `False`, οπότε το **hash** θα γίνει **upload** αντί για το αρχείο.

### Βοηθούμενη Dynamic analysis με MobSF

**MobSF** μπορεί επίσης να είναι πολύ χρήσιμο για **dynamic analysis** σε **Android**, αλλά σε αυτή την περίπτωση θα χρειαστεί να εγκαταστήσετε MobSF και **genymotion** στον host σας (μια VM ή Docker δεν θα δουλέψει). _Σημείωση: Πρέπει να **start first a VM in genymotion** και **then MobSF.**_\
Ο **MobSF dynamic analyser** μπορεί να:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). Όλα αυτά γίνονται αυτόματα εκτός από τα screenshots — χρειάζεται να πατήσετε όταν θέλετε ένα screenshot ή να πατήσετε το "**Exported Activity Tester**" για να πάρετε screenshots όλων των exported activities.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: Θα εκτυπώσει όλες τις loaded classes
- **Capture Strings**: Θα εκτυπώσει όλες τις captured strings ενώ χρησιμοποιείτε την εφαρμογή (πολύ θορυβώδες)
- **Capture String Comparisons**: Μπορεί να είναι πολύ χρήσιμο. Θα **show the 2 strings being compared** και αν το αποτέλεσμα ήταν True ή False.
- **Enumerate Class Methods**: Βάλτε το όνομα της κλάσης (π.χ. "java.io.File") και θα εκτυπώσει όλες τις μεθόδους της κλάσης.
- **Search Class Pattern**: Αναζήτηση classes με pattern
- **Trace Class Methods**: **Trace** μια **whole class** (βλέπε inputs και outputs όλων των methods της class). Θυμηθείτε ότι από προεπιλογή το MobSF traces αρκετές ενδιαφέρουσες Android Api methods.

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf παρέχει επίσης ένα shell με μερικές **adb** εντολές, **MobSF commands**, και κοινές **shell** **commands** στο κάτω μέρος της σελίδας dynamic analysis. Μερικές ενδιαφέρουσες εντολές:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP tools**

Όταν η κίνηση HTTP καταγραφεί μπορείτε να δείτε μια άσχημη προβολή της καταγεγραμμένης κίνησης στο κάτω μέρος στο "**HTTP(S) Traffic**" ή μια πιο όμορφη προβολή στο πράσινο κουμπί "**Start HTTPTools**". Από τη δεύτερη επιλογή, μπορείτε να **στείλετε** τις **καταγεγραμμένες αιτήσεις** σε **proxies** όπως Burp ή Owasp ZAP.\
Για να το κάνετε, _ενεργοποιήστε το Burp -->_ _απενεργοποιήστε το Intercept --> στο MobSB HTTPTools επιλέξτε το request_ --> πατήστε "**Send to Fuzzer**" --> _επιλέξτε τη διεύθυνση proxy_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Μόλις ολοκληρώσετε τη δυναμική ανάλυση με MobSF μπορείτε να πατήσετε στο "**Start Web API Fuzzer**" για να **fuzz** αιτήσεις HTTP και να αναζητήσετε ευπάθειες.

> [!TIP]
> Μετά την εκτέλεση δυναμικής ανάλυσης με MobSF οι ρυθμίσεις proxy ενδέχεται να είναι λανθασμένες και να μην μπορείτε να τις διορθώσετε από το GUI. Μπορείτε να διορθώσετε τις ρυθμίσεις proxy κάνοντας:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

Μπορείτε να αποκτήσετε το εργαλείο από [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Αυτό το εργαλείο θα χρησιμοποιήσει μερικά **Hooks** για να σας ενημερώσει **τι συμβαίνει στην εφαρμογή** ενώ εκτελείτε **δυναμική ανάλυση**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Αυτό είναι ένα **εξαιρετικό εργαλείο για την εκτέλεση στατικής ανάλυσης με GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Αυτό το εργαλείο έχει σχεδιαστεί για να εντοπίζει διάφορες **ευπάθειες σχετικές με την ασφάλεια σε Android εφαρμογές**, είτε στον **πηγαίο κώδικα** είτε σε **packaged APKs**. Το εργαλείο είναι επίσης **ικανοποιητικό στο να δημιουργεί ένα "Proof-of-Concept" deployable APK** και **ADB commands**, για να εκμεταλλευτεί ορισμένες από τις εντοπισμένες ευπάθειες (Exposed activities, intents, tapjacking...). Όπως και με το Drozer, δεν υπάρχει ανάγκη να κάνετε root τη συσκευή δοκιμών.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Εμφανίζει όλα τα εξαγόμενα αρχεία για εύκολη αναφορά
- Απομεταγλωττίζει αυτόματα αρχεία APK σε μορφή Java και Smali
- Αναλύει το AndroidManifest.xml για κοινές ευπάθειες και συμπεριφορές
- Στατική ανάλυση πηγαίου κώδικα για κοινές ευπάθειες και συμπεριφορές
- Πληροφορίες συσκευής
- και άλλα
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

Το SUPER είναι μια εφαρμογή γραμμής εντολών που μπορεί να χρησιμοποιηθεί σε Windows, MacOS X και Linux, που αναλύει αρχεία _.apk_ αναζητώντας ευπάθειες. Το κάνει αυτό αποσυμπιέζοντας τα APKs και εφαρμόζοντας μια σειρά κανόνων για να εντοπίσει αυτές τις ευπάθειες.

Όλοι οι κανόνες βρίσκονται συγκεντρωμένοι σε ένα αρχείο `rules.json`, και κάθε εταιρεία ή tester μπορεί να δημιουργήσει τους δικούς της/του κανόνες για να αναλύσει ό,τι χρειάζεται.

Κατεβάστε τα τελευταία binaries από την [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

Το StaCoAn είναι ένα **crossplatform** εργαλείο που βοηθά προγραμματιστές, bugbounty hunters και ethical hackers να πραγματοποιούν [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) σε κινητές εφαρμογές.

Η ιδέα είναι ότι σύρετε και αφήνετε το αρχείο της mobile εφαρμογής σας (.apk ή .ipa) στην εφαρμογή StaCoAn και αυτή θα δημιουργήσει για εσάς μια οπτική και φορητή αναφορά. Μπορείτε να προσαρμόσετε τις ρυθμίσεις και τα wordlists για μια εξατομικευμένη εμπειρία.

Κατεβάστε[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

Το AndroBugs Framework είναι ένα σύστημα ανάλυσης ευπαθειών για Android που βοηθά προγραμματιστές ή hackers να εντοπίσουν πιθανές ευπάθειες ασφάλειας σε εφαρμογές Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** είναι ένα εργαλείο cuyo κύριος σκοπός είναι να ανιχνεύει και να προειδοποιεί τον χρήστη για πιθανούς κακόβουλους τρόπους συμπεριφοράς που αναπτύσσονται από μια εφαρμογή Android.

Η ανίχνευση εκτελείται με την **static analysis** του Dalvik bytecode της εφαρμογής, που αναπαριστάται ως **Smali**, χρησιμοποιώντας τη βιβλιοθήκη [`androguard`](https://github.com/androguard/androguard).

Αυτό το εργαλείο εντοπίζει **συνηθισμένες συμπεριφορές «κακών» εφαρμογών** όπως: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** είναι ένα πλαίσιο για **M**obile **A**pplication **R**everse engineering and **A**nalysis. Είναι ένα εργαλείο που συγκεντρώνει κοινά χρησιμοποιούμενα εργαλεία για mobile application reverse engineering και analysis, για να βοηθήσει στον έλεγχο mobile applications ενάντια στις OWASP mobile security threats. Στόχος του είναι να κάνει αυτή την εργασία πιο εύκολη και φιλική για τους mobile application developers και τους ειδικούς ασφάλειας.

Μπορεί να:

- Extract Java and Smali code using different tools
- Analyze APKs using: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Extract private information from the APK using regexps.
- Analyze the Manifest.
- Analyze found domains using: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Χρήσιμο για τον εντοπισμό malware: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Σημειώστε ότι, ανάλογα με την υπηρεσία και τη διαμόρφωση που χρησιμοποιείτε για να obfuscate τον κώδικα, τα secrets ενδέχεται να είναι ή να μην είναι obfuscated.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** είναι ένα open source command-line εργαλείο που συρρικνώνει, βελτιστοποιεί και obfuscates Java code. Είναι ικανό να βελτιστοποιήσει bytecode καθώς και να εντοπίσει και να αφαιρέσει αχρησιμοποίητες εντολές. Το ProGuard είναι ελεύθερο λογισμικό και διανέμεται υπό την άδεια GNU General Public License, έκδοση 2.

Το ProGuard διανέμεται ως μέρος του Android SDK και εκτελείται κατά το build της εφαρμογής σε release mode.

### [DexGuard](https://www.guardsquare.com/dexguard)

Βρείτε έναν βήμα-προς-βήμα οδηγό για την deobfuscate του apk στο [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(Από εκείνο τον οδηγό) Την τελευταία φορά που ελέγξαμε, η λειτουργία του Dexguard ήταν:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard αντιστρέφει τη διαδικασία obfuscation που εκτελούν τα Android obfuscation tools. Αυτό επιτρέπει πλήθος security analyses, συμπεριλαμβανομένης της inspection του κώδικα και της πρόβλεψης βιβλιοθηκών.**

Μπορείτε να ανεβάσετε ένα obfuscated APK στην πλατφόρμα τους.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

It is a **generic android deobfuscator.** Simplify **virtually executes an app** to understand its behavior and then **tries to optimize the code** so it behaves identically but is easier for a human to understand. Each optimization type is simple and generic, so it doesn't matter what the specific type of obfuscation is used.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD gives you information about **how an APK was made**. It identifies many **compilers**, **packers**, **obfuscators**, and other weird stuff. It's [_PEiD_](https://www.aldeid.com/wiki/PEiD) for Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b είναι μια Android security virtual machine βασισμένη σε ubuntu-mate που περιλαμβάνει μια συλλογή από τα πιο πρόσφατα framework, tutorials και labs από διάφορους security geeks και researchers για reverse engineering και malware analysis.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Είναι μια εξαιρετική λίστα πόρων
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
