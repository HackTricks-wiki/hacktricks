# Pentesting delle Applicazioni Android

{{#include ../../banners/hacktricks-training.md}}

## Nozioni di Base sulle Applicazioni Android

È altamente consigliato iniziare a leggere questa pagina per conoscere le **parti più importanti relative alla sicurezza di Android e i componenti più pericolosi in un'applicazione Android**:

{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Questo è lo strumento principale di cui hai bisogno per connetterti a un dispositivo Android (emulato o fisico).\
**ADB** consente di controllare i dispositivi sia tramite **USB** che tramite **rete** da un computer. Questa utility abilita la **copia** di file in entrambe le direzioni, **installazione** e **disinstallazione** di app, **esecuzione** di comandi shell, **backup** di dati, **lettura** di log, tra le altre funzioni.

Dai un'occhiata alla seguente lista di [**Comandi ADB**](adb-commands.md) per imparare come utilizzare adb.

## Smali

A volte è interessante **modificare il codice dell'applicazione** per accedere a **informazioni nascoste** (forse password o flag ben offuscati). Quindi, potrebbe essere interessante decompilare l'apk, modificare il codice e ricompilarlo.\
[**In questo tutorial** puoi **imparare come decompilare un APK, modificare il codice Smali e ricompilare l'APK** con la nuova funzionalità](smali-changes.md). Questo potrebbe essere molto utile come **alternativa per diversi test durante l'analisi dinamica** che verranno presentati. Quindi, **tieni sempre a mente questa possibilità**.

## Altri trucchi interessanti

- [Falsificare la tua posizione nel Play Store](spoofing-your-location-in-play-store.md)
- [API Privilegiata Shizuku (accesso privilegiato non root basato su ADB)](shizuku-privileged-api.md)
- [Sfruttare meccanismi di aggiornamento in-app insicuri](insecure-in-app-update-rce.md)
- **Scarica APK**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Estrai APK dal dispositivo:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Unisci tutti gli APK divisi e di base con [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Case Studies & Vulnerabilities

{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}

## Static Analysis

Prima di tutto, per analizzare un APK dovresti **dare un'occhiata al codice Java** utilizzando un decompilatore.\
Per favore, [**leggi qui per trovare informazioni sui diversi decompilatori disponibili**](apk-decompilers.md).

### Looking for interesting Info

Basta dare un'occhiata alle **stringhe** dell'APK per cercare **password**, **URL** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **chiavi** **api**, **crittografia**, **bluetooth uuids**, **token** e qualsiasi cosa interessante... cerca anche **backdoor** di esecuzione del codice o backdoor di autenticazione (credenziali admin hardcoded per l'app).

**Firebase**

Presta particolare attenzione agli **URL di firebase** e controlla se è configurato male. [Maggiore informazione su cosa è Firebase e come sfruttarlo qui.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Basic understanding of the application - Manifest.xml, strings.xml

L'**esame dei file _Manifest.xml_ e **_strings.xml_** di un'applicazione può rivelare potenziali vulnerabilità di sicurezza**. Questi file possono essere accessibili utilizzando decompilatori o rinominando l'estensione del file APK in .zip e poi decomprimendolo.

**Vulnerabilità** identificate dal **Manifest.xml** includono:

- **Applicazioni Debuggable**: Le applicazioni impostate come debuggable (`debuggable="true"`) nel file _Manifest.xml_ rappresentano un rischio poiché consentono connessioni che possono portare a sfruttamenti. Per ulteriori informazioni su come sfruttare le applicazioni debuggable, fai riferimento a un tutorial su come trovare e sfruttare applicazioni debuggable su un dispositivo.
- **Impostazioni di Backup**: L'attributo `android:allowBackup="false"` dovrebbe essere impostato esplicitamente per le applicazioni che trattano informazioni sensibili per prevenire backup non autorizzati dei dati tramite adb, specialmente quando il debug USB è abilitato.
- **Sicurezza della Rete**: Le configurazioni di sicurezza della rete personalizzate (`android:networkSecurityConfig="@xml/network_security_config"`) in _res/xml/_ possono specificare dettagli di sicurezza come i pin dei certificati e le impostazioni del traffico HTTP. Un esempio è consentire il traffico HTTP per domini specifici.
- **Attività e Servizi Esportati**: Identificare attività e servizi esportati nel manifest può evidenziare componenti che potrebbero essere abusati. Ulteriori analisi durante i test dinamici possono rivelare come sfruttare questi componenti.
- **Content Providers e FileProviders**: I content provider esposti potrebbero consentire accessi o modifiche non autorizzate ai dati. Anche la configurazione dei FileProviders dovrebbe essere scrutinata.
- **Broadcast Receivers e URL Schemes**: Questi componenti potrebbero essere sfruttati, prestando particolare attenzione a come vengono gestiti gli URL schemes per le vulnerabilità di input.
- **Versioni SDK**: Gli attributi `minSdkVersion`, `targetSDKVersion` e `maxSdkVersion` indicano le versioni Android supportate, evidenziando l'importanza di non supportare versioni Android obsolete e vulnerabili per motivi di sicurezza.

Dal file **strings.xml**, possono essere scoperte informazioni sensibili come chiavi API, schemi personalizzati e altre note degli sviluppatori, sottolineando la necessità di una revisione attenta di queste risorse.

### Tapjacking

**Tapjacking** è un attacco in cui un'**applicazione** **maligna** viene lanciata e **si posiziona sopra un'applicazione vittima**. Una volta che oscura visibilmente l'app vittima, la sua interfaccia utente è progettata in modo da ingannare l'utente a interagire con essa, mentre passa l'interazione all'app vittima.\
In effetti, sta **accecando l'utente dal sapere che sta effettivamente eseguendo azioni sull'app vittima**.

Trova maggiori informazioni in:

{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Un'**attività** con il **`launchMode`** impostato su **`singleTask` senza alcun `taskAffinity`** definito è vulnerabile al task hijacking. Questo significa che un'**applicazione** può essere installata e, se lanciata prima dell'applicazione reale, potrebbe **dirottare il task dell'applicazione reale** (quindi l'utente interagirà con l'**applicazione maligna pensando di utilizzare quella reale**).

Maggiore info in:

{{#ref}}
android-task-hijacking.md
{{#endref}}

### Insecure data storage

**Internal Storage**

In Android, i file **memorizzati** nella **memoria interna** sono **progettati** per essere **accessibili** esclusivamente dall'**app** che li **ha creati**. Questa misura di sicurezza è **imposta** dal sistema operativo Android ed è generalmente adeguata per le esigenze di sicurezza della maggior parte delle applicazioni. Tuttavia, gli sviluppatori a volte utilizzano modalità come `MODE_WORLD_READABLE` e `MODE_WORLD_WRITABLE` per **consentire** la condivisione di file tra diverse applicazioni. Tuttavia, queste modalità **non limitano l'accesso** a questi file da parte di altre applicazioni, comprese quelle potenzialmente dannose.

1. **Static Analysis:**
- **Assicurati** che l'uso di `MODE_WORLD_READABLE` e `MODE_WORLD_WRITABLE` sia **scrutinato attentamente**. Queste modalità **possono potenzialmente esporre** file a **accessi non intenzionati o non autorizzati**.
2. **Dynamic Analysis:**
- **Verifica** le **permissive** impostate sui file creati dall'app. In particolare, **controlla** se ci sono file **impostati per essere leggibili o scrivibili a livello globale**. Questo può rappresentare un rischio significativo per la sicurezza, poiché consentirebbe a **qualsiasi applicazione** installata sul dispositivo, indipendentemente dalla sua origine o intento, di **leggere o modificare** questi file.

**External Storage**

Quando si trattano file su **memoria esterna**, come schede SD, dovrebbero essere adottate alcune precauzioni:

1. **Accessibilità**:
- I file su memoria esterna sono **globalmente leggibili e scrivibili**. Questo significa che qualsiasi applicazione o utente può accedere a questi file.
2. **Preoccupazioni di Sicurezza**:
- Data la facilità di accesso, è consigliato **non memorizzare informazioni sensibili** su memoria esterna.
- La memoria esterna può essere rimossa o accessibile da qualsiasi applicazione, rendendola meno sicura.
3. **Gestione dei Dati dalla Memoria Esterna**:
- Esegui sempre **validazione degli input** sui dati recuperati dalla memoria esterna. Questo è cruciale poiché i dati provengono da una fonte non attendibile.
- Memorizzare eseguibili o file di classe su memoria esterna per il caricamento dinamico è fortemente sconsigliato.
- Se la tua applicazione deve recuperare file eseguibili dalla memoria esterna, assicurati che questi file siano **firmati e verificati crittograficamente** prima di essere caricati dinamicamente. Questo passaggio è vitale per mantenere l'integrità della sicurezza della tua applicazione.

La memoria esterna può essere **accessibile** in `/storage/emulated/0`, `/sdcard`, `/mnt/sdcard`

> [!TIP]
> A partire da Android 4.4 (**API 17**), la scheda SD ha una struttura di directory che **limita l'accesso da un'app alla directory specificamente per quell'app**. Questo impedisce a un'applicazione malevola di ottenere accesso in lettura o scrittura ai file di un'altra app.

**Dati sensibili memorizzati in chiaro**

- **Shared preferences**: Android consente a ciascuna applicazione di salvare facilmente file xml nel percorso `/data/data/<packagename>/shared_prefs/` e a volte è possibile trovare informazioni sensibili in chiaro in quella cartella.
- **Database**: Android consente a ciascuna applicazione di salvare facilmente database sqlite nel percorso `/data/data/<packagename>/databases/` e a volte è possibile trovare informazioni sensibili in chiaro in quella cartella.

### Broken TLS

**Accept All Certificates**

Per qualche motivo, a volte gli sviluppatori accettano tutti i certificati anche se, ad esempio, il nome host non corrisponde a righe di codice come la seguente:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Un buon modo per testare questo è provare a catturare il traffico utilizzando un proxy come Burp senza autorizzare il certificato CA di Burp all'interno del dispositivo. Inoltre, puoi generare con Burp un certificato per un hostname diverso e usarlo.

### Criptografia compromessa

**Processi di gestione delle chiavi scadenti**

Alcuni sviluppatori salvano dati sensibili nello storage locale e li crittografano con una chiave hardcoded/predicibile nel codice. Questo non dovrebbe essere fatto poiché alcune operazioni di reverse engineering potrebbero consentire agli attaccanti di estrarre le informazioni riservate.

**Utilizzo di algoritmi insicuri e/o deprecati**

Gli sviluppatori non dovrebbero utilizzare **algoritmi deprecati** per eseguire **controlli di autorizzazione**, **memorizzare** o **inviare** dati. Alcuni di questi algoritmi sono: RC4, MD4, MD5, SHA1... Se si utilizzano **hash** per memorizzare le password, ad esempio, dovrebbero essere utilizzati hash resistenti al brute-force con sale.

### Altri controlli

- È consigliato **offuscare l'APK** per rendere più difficile il lavoro di reverse engineering per gli attaccanti.
- Se l'app è sensibile (come le app bancarie), dovrebbe eseguire i propri **controlli per vedere se il mobile è rootato** e agire di conseguenza.
- Se l'app è sensibile (come le app bancarie), dovrebbe controllare se viene utilizzato un **emulatore**.
- Se l'app è sensibile (come le app bancarie), dovrebbe **controllare la propria integrità prima di eseguire** per verificare se è stata modificata.
- Usa [**APKiD**](https://github.com/rednaga/APKiD) per controllare quale compilatore/pacchetto/offuscatore è stato utilizzato per costruire l'APK.

### Applicazione React Native

Leggi la seguente pagina per imparare come accedere facilmente al codice javascript delle applicazioni React:

{{#ref}}
react-native-application.md
{{#endref}}

### Applicazioni Xamarin

Leggi la seguente pagina per imparare come accedere facilmente al codice C# delle applicazioni xamarin:

{{#ref}}
../xamarin-apps.md
{{#endref}}

### Applicazioni Superpacked

Secondo questo [**post del blog**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/), superpacked è un algoritmo Meta che comprime il contenuto di un'applicazione in un unico file. Il blog parla della possibilità di creare un'app che decomprime questo tipo di app... e di un modo più veloce che implica **eseguire l'applicazione e raccogliere i file decompressi dal filesystem.**

### Analisi statica automatizzata del codice

Lo strumento [**mariana-trench**](https://github.com/facebook/mariana-trench) è in grado di trovare **vulnerabilità** eseguendo la **scansione** del **codice** dell'applicazione. Questo strumento contiene una serie di **fonti note** (che indicano allo strumento i **luoghi** in cui l'**input** è **controllato dall'utente**), **sink** (che indicano allo strumento **luoghi pericolosi** in cui l'input malevolo dell'utente potrebbe causare danni) e **regole**. Queste regole indicano la **combinazione** di **fonti-sink** che indica una vulnerabilità.

Con questa conoscenza, **mariana-trench esaminerà il codice e troverà possibili vulnerabilità in esso**.

### Segreti trapelati

Un'applicazione può contenere segreti (chiavi API, password, URL nascosti, sottodomini...) al suo interno che potresti essere in grado di scoprire. Potresti usare uno strumento come [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks).

### Bypass dell'autenticazione biometrica

{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Altre funzioni interessanti

- **Esecuzione di codice**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Invio SMS**: `sendTextMessage, sendMultipartTestMessage`
- **Funzioni native** dichiarate come `native`: `public native, System.loadLibrary, System.load`
- [Leggi questo per imparare **come fare il reverse delle funzioni native**](reversing-native-libraries.md)

### **Altri trucchi**

{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Analisi dinamica

> Prima di tutto, hai bisogno di un ambiente in cui puoi installare l'applicazione e tutto l'ambiente (certificato CA di Burp, Drozer e Frida principalmente). Pertanto, è estremamente consigliato un dispositivo rootato (emulato o meno).

### Analisi dinamica online

Puoi creare un **account gratuito** in: [https://appetize.io/](https://appetize.io). Questa piattaforma ti consente di **caricare** e **eseguire** APK, quindi è utile per vedere come si comporta un apk.

Puoi persino **vedere i log della tua applicazione** sul web e connetterti tramite **adb**.

![](<../../images/image (831).png>)

Grazie alla connessione ADB puoi utilizzare **Drozer** e **Frida** all'interno degli emulatori.

### Analisi dinamica locale

#### Utilizzando un emulatore

- [**Android Studio**](https://developer.android.com/studio) (Puoi creare dispositivi **x86** e **arm**, e secondo [**questo**](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html) **ultimi versioni x86** supportano le librerie ARM senza necessità di un emulatore arm lento).
- Impara a configurarlo in questa pagina:

{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Versione gratuita:** Edizione personale, devi creare un account. _È consigliato **scaricare** la versione **CON** _**VirtualBox** per evitare potenziali errori._)
- [**Nox**](https://es.bignox.com) (Gratuito, ma non supporta Frida o Drozer).

> [!TIP]
> Quando crei un nuovo emulatore su qualsiasi piattaforma ricorda che più grande è lo schermo, più lento sarà l'emulatore. Quindi seleziona schermi piccoli se possibile.

Per **installare i servizi google** (come AppStore) in Genymotion devi cliccare sul pulsante contrassegnato in rosso nell'immagine seguente:

![](<../../images/image (277).png>)

Inoltre, nota che nella **configurazione della VM Android in Genymotion** puoi selezionare **Modalità rete Bridge** (questo sarà utile se ti connetterai alla VM Android da una VM diversa con gli strumenti).

#### Usa un dispositivo fisico

Devi attivare le **opzioni di debug** e sarebbe utile se potessi **rootarlo**:

1. **Impostazioni**.
2. (Da Android 8.0) Seleziona **Sistema**.
3. Seleziona **Informazioni sul telefono**.
4. Premi **Numero di build** 7 volte.
5. Torna indietro e troverai le **Opzioni sviluppatore**.

> Una volta installata l'applicazione, la prima cosa che dovresti fare è provarla e indagare su cosa fa, come funziona e familiarizzare con essa.\
> Ti suggerisco di **eseguire questa analisi dinamica iniziale utilizzando l'analisi dinamica di MobSF + pidcat**, così saremo in grado di **imparare come funziona l'applicazione** mentre MobSF **cattura** molti **dati interessanti** che puoi rivedere in seguito.

### Perdita di dati non intenzionale

**Logging**

Gli sviluppatori dovrebbero prestare attenzione a non esporre **informazioni di debug** pubblicamente, poiché ciò può portare a perdite di dati sensibili. Gli strumenti [**pidcat**](https://github.com/JakeWharton/pidcat) e `adb logcat` sono raccomandati per monitorare i log dell'applicazione per identificare e proteggere le informazioni sensibili. **Pidcat** è preferito per la sua facilità d'uso e leggibilità.

> [!WARNING]
> Nota che da **versioni successive ad Android 4.0**, **le applicazioni possono accedere solo ai propri log**. Quindi le applicazioni non possono accedere ai log di altre app.\
> Comunque, è ancora consigliato **non registrare informazioni sensibili**.

**Caching del buffer di copia/incolla**

Il framework **basato su clipboard** di Android consente la funzionalità di copia e incolla nelle app, ma presenta un rischio poiché **altre applicazioni** possono **accedere** alla clipboard, esponendo potenzialmente dati sensibili. È fondamentale **disabilitare le funzioni di copia/incolla** per sezioni sensibili di un'applicazione, come i dettagli della carta di credito, per prevenire perdite di dati.

**Log di crash**

Se un'applicazione **crasha** e **salva log**, questi log possono assistere gli attaccanti, in particolare quando l'applicazione non può essere sottoposta a reverse engineering. Per mitigare questo rischio, evita di registrare in caso di crash e, se i log devono essere trasmessi attraverso la rete, assicurati che vengano inviati tramite un canale SSL per la sicurezza.

Come pentester, **cerca di dare un'occhiata a questi log**.

**Dati analitici inviati a terzi**

Le applicazioni integrano spesso servizi come Google Adsense, che possono involontariamente **trapelare dati sensibili** a causa di un'implementazione impropria da parte degli sviluppatori. Per identificare potenziali perdite di dati, è consigliabile **intercettare il traffico dell'applicazione** e controllare eventuali informazioni sensibili inviate a servizi di terze parti.

### DB SQLite

La maggior parte delle applicazioni utilizzerà **database SQLite interni** per salvare informazioni. Durante il pentest, dai un'occhiata ai **database** creati, ai nomi delle **tabelle** e delle **colonne** e a tutti i **dati** salvati perché potresti trovare **informazioni sensibili** (che costituirebbero una vulnerabilità).\
I database dovrebbero trovarsi in `/data/data/the.package.name/databases` come `/data/data/com.mwr.example.sieve/databases`.

Se il database sta salvando informazioni riservate ed è **crittografato** ma puoi **trovare** la **password** all'interno dell'applicazione, è comunque una **vulnerabilità**.

Enumera le tabelle utilizzando `.tables` e enumera le colonne delle tabelle eseguendo `.schema <table_name>`.

### Drozer (Attività di sfruttamento, Content Providers e Servizi)

Da [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** ti consente di **assumere il ruolo di un'app Android** e interagire con altre app. Può fare **qualsiasi cosa che un'applicazione installata può fare**, come utilizzare il meccanismo di comunicazione interprocesso (IPC) di Android e interagire con il sistema operativo sottostante.\
Drozer è uno strumento utile per **sfruttare attività esportate, servizi esportati e Content Providers** come imparerai nelle sezioni seguenti.

### Sfruttare attività esportate

[**Leggi questo se vuoi rinfrescare cosa sia un'Activity Android.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Ricorda anche che il codice di un'attività inizia nel metodo **`onCreate`**.

**Bypass dell'autorizzazione**

Quando un'Activity è esportata, puoi invocare il suo schermo da un'app esterna. Pertanto, se un'attività con **informazioni sensibili** è **esportata**, potresti **bypassare** i meccanismi di **autenticazione** **per accedervi**.

[**Scopri come sfruttare le attività esportate con Drozer.**](drozer-tutorial/index.html#activities)

Puoi anche avviare un'attività esportata da adb:

- PackageName è com.example.demo
- Exported ActivityName è com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTA**: MobSF rileverà come malevolo l'uso di _**singleTask/singleInstance**_ come `android:launchMode` in un'attività, ma a causa di [questo](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparentemente questo è pericoloso solo su versioni obsolete (versioni API < 21).

> [!TIP]
> Nota che un bypass di autorizzazione non è sempre una vulnerabilità, dipenderebbe da come funziona il bypass e quali informazioni vengono esposte.

**Perdita di informazioni sensibili**

**Le attività possono anche restituire risultati**. Se riesci a trovare un'attività esportata e non protetta che chiama il metodo **`setResult`** e **restituisce informazioni sensibili**, c'è una perdita di informazioni sensibili.

#### Tapjacking

Se il tapjacking non è prevenuto, potresti abusare dell'attività esportata per far **eseguire azioni inaspettate all'utente**. Per ulteriori informazioni su [**cosa è il Tapjacking segui il link**](#tapjacking).

### Sfruttare i Content Providers - Accesso e manipolazione di informazioni sensibili

[**Leggi questo se vuoi rinfrescare cosa è un Content Provider.**](android-applications-basics.md#content-provider)\
I content provider sono fondamentalmente utilizzati per **condividere dati**. Se un'app ha content provider disponibili, potresti essere in grado di **estrarre dati sensibili** da essi. È anche interessante testare possibili **SQL injection** e **Path Traversals** poiché potrebbero essere vulnerabili.

[**Scopri come sfruttare i Content Providers con Drozer.**](drozer-tutorial/index.html#content-providers)

### **Sfruttare i Servizi**

[**Leggi questo se vuoi rinfrescare cosa è un Servizio.**](android-applications-basics.md#services)\
Ricorda che le azioni di un Servizio iniziano nel metodo `onStartCommand`.

Un servizio è fondamentalmente qualcosa che **può ricevere dati**, **elaborarli** e **restituire** (o meno) una risposta. Quindi, se un'applicazione sta esportando alcuni servizi, dovresti **controllare** il **codice** per capire cosa sta facendo e **testarlo** **dinamicamente** per estrarre informazioni riservate, bypassare misure di autenticazione...\
[**Scopri come sfruttare i Servizi con Drozer.**](drozer-tutorial/index.html#services)

### **Sfruttare i Broadcast Receivers**

[**Leggi questo se vuoi rinfrescare cosa è un Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Ricorda che le azioni di un Broadcast Receiver iniziano nel metodo `onReceive`.

Un broadcast receiver attenderà un tipo di messaggio. A seconda di come il receiver gestisce il messaggio, potrebbe essere vulnerabile.\
[**Scopri come sfruttare i Broadcast Receivers con Drozer.**](#exploiting-broadcast-receivers)

### **Sfruttare Schemi / Deep links**

Puoi cercare deep links manualmente, utilizzando strumenti come MobSF o script come [questo](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Puoi **aprire** uno **schema** dichiarato usando **adb** o un **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Nota che puoi **omettere il nome del pacchetto** e il mobile chiamerà automaticamente l'app che dovrebbe aprire quel link._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Codice eseguito**

Per trovare il **codice che verrà eseguito nell'App**, vai all'attività chiamata dal deeplink e cerca la funzione **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Informazioni sensibili**

Ogni volta che trovi un deep link, controlla che **non stia ricevendo dati sensibili (come password) tramite parametri URL**, perché qualsiasi altra applicazione potrebbe **fingere di essere il deep link e rubare quei dati!**

**Parametri nel percorso**

Devi **controllare anche se qualche deep link sta usando un parametro all'interno del percorso** dell'URL come: `https://api.example.com/v1/users/{username}`, in tal caso puoi forzare un traversamento del percorso accedendo a qualcosa come: `example://app/users?username=../../unwanted-endpoint%3fparam=value`.\
Nota che se trovi i corretti endpoint all'interno dell'applicazione potresti essere in grado di causare un **Open Redirect** (se parte del percorso è usata come nome di dominio), **account takeover** (se puoi modificare i dettagli degli utenti senza token CSRF e l'endpoint vulnerabile usava il metodo corretto) e qualsiasi altra vulnerabilità. Maggiori [info su questo qui](http://dphoeniixx.com/2020/12/13-2/).

**Altri esempi**

Un [interessante rapporto di bug bounty](https://hackerone.com/reports/855618) sui link (_/.well-known/assetlinks.json_).

### Ispezione e verifiche del livello di trasporto

- **I certificati non vengono sempre ispezionati correttamente** dalle applicazioni Android. È comune che queste applicazioni trascurino gli avvisi e accettino certificati autofirmati o, in alcuni casi, tornino a utilizzare connessioni HTTP.
- **Le negoziazioni durante il handshake SSL/TLS sono a volte deboli**, impiegando suite crittografiche insicure. Questa vulnerabilità rende la connessione suscettibile ad attacchi man-in-the-middle (MITM), consentendo agli attaccanti di decrittare i dati.
- **La perdita di informazioni private** è un rischio quando le applicazioni si autenticano utilizzando canali sicuri ma poi comunicano tramite canali non sicuri per altre transazioni. Questo approccio non riesce a proteggere i dati sensibili, come i cookie di sessione o i dettagli degli utenti, dall'intercettazione da parte di entità malevole.

#### Verifica del certificato

Ci concentreremo sulla **verifica del certificato**. L'integrità del certificato del server deve essere verificata per migliorare la sicurezza. Questo è cruciale perché configurazioni TLS insicure e la trasmissione di dati sensibili su canali non crittografati possono comportare rischi significativi. Per passaggi dettagliati sulla verifica dei certificati del server e sulla risoluzione delle vulnerabilità, [**questa risorsa**](https://manifestsecurity.com/android-application-security-part-10/) fornisce indicazioni complete.

#### SSL Pinning

SSL Pinning è una misura di sicurezza in cui l'applicazione verifica il certificato del server rispetto a una copia nota memorizzata all'interno dell'applicazione stessa. Questo metodo è essenziale per prevenire attacchi MITM. Si raccomanda vivamente di implementare SSL Pinning per le applicazioni che gestiscono informazioni sensibili.

#### Ispezione del traffico

Per ispezionare il traffico HTTP, è necessario **installare il certificato dello strumento proxy** (ad es., Burp). Senza installare questo certificato, il traffico crittografato potrebbe non essere visibile attraverso il proxy. Per una guida sull'installazione di un certificato CA personalizzato, [**clicca qui**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Le applicazioni destinate a **API Level 24 e superiori** richiedono modifiche alla Configurazione della Sicurezza di Rete per accettare il certificato CA del proxy. Questo passaggio è fondamentale per ispezionare il traffico crittografato. Per istruzioni su come modificare la Configurazione della Sicurezza di Rete, [**fai riferimento a questo tutorial**](make-apk-accept-ca-certificate.md).

Se **Flutter** viene utilizzato, devi seguire le istruzioni in [**questa pagina**](flutter.md). Questo perché, aggiungere semplicemente il certificato nel negozio non funzionerà poiché Flutter ha la propria lista di CAs validi.

#### Bypassare SSL Pinning

Quando SSL Pinning è implementato, bypassarlo diventa necessario per ispezionare il traffico HTTPS. Sono disponibili vari metodi per questo scopo:

- Modifica automaticamente l'**apk** per **bypassare** SSLPinning con [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Il miglior vantaggio di questa opzione è che non avrai bisogno di root per bypassare l'SSL Pinning, ma dovrai eliminare l'applicazione e reinstallare quella nuova, e questo non funzionerà sempre.
- Potresti usare **Frida** (discusso di seguito) per bypassare questa protezione. Qui hai una guida per usare Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Puoi anche provare a **bypassare automaticamente SSL Pinning** usando [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Puoi anche provare a **bypassare automaticamente SSL Pinning** usando **l'analisi dinamica di MobSF** (spiegato di seguito)
- Se pensi ancora che ci sia del traffico che non stai catturando, puoi provare a **inoltrare il traffico a burp usando iptables**. Leggi questo blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Ricerca di vulnerabilità web comuni

È importante cercare anche vulnerabilità web comuni all'interno dell'applicazione. Informazioni dettagliate su come identificare e mitigare queste vulnerabilità vanno oltre l'ambito di questo riepilogo, ma sono ampiamente trattate altrove.

### Frida

[Frida](https://www.frida.re) è un toolkit di strumentazione dinamica per sviluppatori, ingegneri inversi e ricercatori di sicurezza.\
**Puoi accedere all'applicazione in esecuzione e agganciare metodi in tempo reale per cambiare il comportamento, cambiare valori, estrarre valori, eseguire codice diverso...**\
Se vuoi fare pentesting su applicazioni Android, devi sapere come usare Frida.

- Impara a usare Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Alcuni "GUI" per azioni con Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection è ottimo per automatizzare l'uso di Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Puoi trovare alcuni fantastici script Frida qui: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Prova a bypassare meccanismi anti-debugging / anti-frida caricando Frida come indicato in [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

### **Dump della memoria - Fridump**

Controlla se l'applicazione sta memorizzando informazioni sensibili all'interno della memoria che non dovrebbe memorizzare, come password o mnemonici.

Utilizzando [**Fridump3**](https://github.com/rootbsd/fridump3) puoi dumpare la memoria dell'app con:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Questo dump sarà memorizzato nella cartella ./dump, e lì potresti usare grep con qualcosa come:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Dati sensibili nel Keystore**

In Android, il Keystore è il miglior posto per memorizzare dati sensibili, tuttavia, con privilegi sufficienti è ancora **possibile accedervi**. Poiché le applicazioni tendono a memorizzare qui **dati sensibili in chiaro**, i pentest dovrebbero controllare per questo come utente root o qualcuno con accesso fisico al dispositivo potrebbe essere in grado di rubare questi dati.

Anche se un'app ha memorizzato dati nel keystore, i dati dovrebbero essere crittografati.

Per accedere ai dati all'interno del keystore, puoi utilizzare questo script Frida: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Utilizzando il seguente script Frida potrebbe essere possibile **bypassare l'autenticazione tramite impronta digitale** che le applicazioni Android potrebbero eseguire per **proteggere determinate aree sensibili:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Immagini di Sfondo**

Quando metti un'applicazione in background, Android memorizza un **istantanea dell'applicazione** in modo che, quando viene ripristinata in primo piano, inizi a caricare l'immagine prima dell'app, quindi sembra che l'app sia stata caricata più velocemente.

Tuttavia, se questa istantanea contiene **informazioni sensibili**, qualcuno con accesso all'istantanea potrebbe **rubare quelle informazioni** (nota che è necessario avere i permessi di root per accedervi).

Le istantanee sono solitamente memorizzate in: **`/data/system_ce/0/snapshots`**

Android fornisce un modo per **prevenire la cattura dello screenshot impostando il parametro di layout FLAG_SECURE**. Utilizzando questo flag, i contenuti della finestra vengono trattati come sicuri, impedendo loro di apparire negli screenshot o di essere visualizzati su display non sicuri.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Analizzatore di Applicazioni Android**

Questo strumento può aiutarti a gestire diversi strumenti durante l'analisi dinamica: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Iniezione di Intent

Gli sviluppatori spesso creano componenti proxy come attività, servizi e ricevitori di broadcast che gestiscono questi Intent e li passano a metodi come `startActivity(...)` o `sendBroadcast(...)`, il che può essere rischioso.

Il pericolo risiede nel consentire agli attaccanti di attivare componenti dell'app non esportati o accedere a provider di contenuti sensibili deviando questi Intent. Un esempio notevole è il componente `WebView` che converte URL in oggetti `Intent` tramite `Intent.parseUri(...)` e poi li esegue, portando potenzialmente a iniezioni di Intent malevoli.

### Punti Essenziali

- **Iniezione di Intent** è simile al problema di Open Redirect del web.
- Gli exploit coinvolgono il passaggio di oggetti `Intent` come extra, che possono essere deviati per eseguire operazioni non sicure.
- Può esporre componenti non esportati e provider di contenuti agli attaccanti.
- La conversione di URL in `Intent` di `WebView` può facilitare azioni indesiderate.

### Iniezioni lato Client Android e altri

Probabilmente conosci questo tipo di vulnerabilità dal Web. Devi essere particolarmente attento a queste vulnerabilità in un'applicazione Android:

- **Iniezione SQL:** Quando gestisci query dinamiche o Content-Providers assicurati di utilizzare query parametrizzate.
- **Iniezione JavaScript (XSS):** Verifica che il supporto per JavaScript e Plugin sia disabilitato per qualsiasi WebView (disabilitato per impostazione predefinita). [Ulteriori informazioni qui](webview-attacks.md#javascript-enabled).
- **Inclusione di File Locali:** Le WebView dovrebbero avere l'accesso al file system disabilitato (abilitato per impostazione predefinita) - `(webview.getSettings().setAllowFileAccess(false);)`. [Ulteriori informazioni qui](webview-attacks.md#javascript-enabled).
- **Cookie Eterni**: In diversi casi, quando l'applicazione android termina la sessione, il cookie non viene revocato o potrebbe essere persino salvato su disco.
- [**Flag Sicuro** nei cookie](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Analisi Automatica

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Analisi statica**

![](<../../images/image (866).png>)

**Valutazione delle vulnerabilità dell'applicazione** utilizzando un bel frontend web-based. Puoi anche eseguire analisi dinamica (ma devi preparare l'ambiente).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Nota che MobSF può analizzare **Android**(apk)**, IOS**(ipa) **e Windows**(apx) applicazioni (_Le applicazioni Windows devono essere analizzate da un MobSF installato su un host Windows_).\
Inoltre, se crei un file **ZIP** con il codice sorgente di un'app **Android** o di un'app **IOS** (vai alla cartella radice dell'applicazione, seleziona tutto e crea un file ZIP), sarà in grado di analizzarlo anche.

MobSF consente anche di **diff/Confrontare** analisi e di integrare **VirusTotal** (dovrai impostare la tua chiave API in _MobSF/settings.py_ e abilitarla: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). Puoi anche impostare `VT_UPLOAD` su `False`, quindi l'**hash** sarà **caricato** invece del file.

### Analisi dinamica assistita con MobSF

**MobSF** può essere molto utile per l'**analisi dinamica** in **Android**, ma in quel caso dovrai installare MobSF e **genymotion** sul tuo host (una VM o Docker non funzionerà). _Nota: Devi **avviare prima una VM in genymotion** e **poi MobSF.**_\
L'**analizzatore dinamico MobSF** può:

- **Dump dei dati dell'applicazione** (URL, log, appunti, screenshot fatti da te, screenshot fatti da "**Exported Activity Tester**", email, database SQLite, file XML e altri file creati). Tutto questo viene fatto automaticamente tranne per gli screenshot, devi premere quando vuoi uno screenshot o devi premere "**Exported Activity Tester**" per ottenere screenshot di tutte le attività esportate.
- Catturare il **traffico HTTPS**
- Usare **Frida** per ottenere **informazioni** **runtime**

Dalle versioni di Android **> 5**, avvierà **automaticamente Frida** e imposterà le impostazioni **proxy** globali per **catturare** il traffico. Catturerà solo il traffico dall'applicazione testata.

**Frida**

Per impostazione predefinita, utilizzerà anche alcuni script Frida per **bypassare SSL pinning**, **rilevamento root** e **rilevamento debugger** e per **monitorare API interessanti**.\
MobSF può anche **invocare attività esportate**, acquisire **screenshot** di esse e **salvarle** per il rapporto.

Per **iniziare** il test dinamico premi il pulsante verde: "**Start Instrumentation**". Premi "**Frida Live Logs**" per vedere i log generati dagli script Frida e "**Live API Monitor**" per vedere tutte le invocazioni ai metodi hookati, gli argomenti passati e i valori restituiti (questo apparirà dopo aver premuto "Start Instrumentation").\
MobSF consente anche di caricare i propri **script Frida** (per inviare i risultati dei tuoi script Frida a MobSF usa la funzione `send()`). Ha anche **diversi script pre-scritti** che puoi caricare (puoi aggiungerne di più in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), basta **selezionarli**, premere "**Load**" e premere "**Start Instrumentation**" (sarai in grado di vedere i log di quegli script all'interno di "**Frida Live Logs**").

![](<../../images/image (419).png>)

Inoltre, hai alcune funzionalità ausiliarie di Frida:

- **Enumerare Classi Caricate**: Stampa tutte le classi caricate
- **Catturare Stringhe**: Stampa tutte le stringhe catturate mentre utilizzi l'applicazione (super rumoroso)
- **Catturare Confronti di Stringhe**: Potrebbe essere molto utile. Mostrerà **le 2 stringhe confrontate** e se il risultato è stato Vero o Falso.
- **Enumerare Metodi di Classe**: Inserisci il nome della classe (come "java.io.File") e stamperà tutti i metodi della classe.
- **Cerca Modello di Classe**: Cerca classi per modello
- **Traccia Metodi di Classe**: **Traccia** un'**intera classe** (vedi input e output di tutti i metodi della classe). Ricorda che per impostazione predefinita MobSF traccia diversi metodi API Android interessanti.

Una volta selezionato il modulo ausiliario che desideri utilizzare, devi premere "**Start Intrumentation**" e vedrai tutti gli output in "**Frida Live Logs**".

**Shell**

Mobsf ti offre anche una shell con alcuni comandi **adb**, **comandi MobSF** e comandi **shell** comuni nella parte inferiore della pagina di analisi dinamica. Alcuni comandi interessanti:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**Strumenti HTTP**

Quando il traffico http viene catturato, puoi vedere una vista brutta del traffico catturato in "**HTTP(S) Traffic**" in basso o una vista più bella nel pulsante verde "**Start HTTPTools**". Dalla seconda opzione, puoi **inviare** le **richieste catturate** a **proxy** come Burp o Owasp ZAP.\
Per farlo, _accendi Burp -->_ _disattiva Intercept --> in MobSB HTTPTools seleziona la richiesta_ --> premi "**Send to Fuzzer**" --> _seleziona l'indirizzo del proxy_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Una volta terminata l'analisi dinamica con MobSF, puoi premere su "**Start Web API Fuzzer**" per **fuzzare le richieste http** e cercare vulnerabilità.

> [!TIP]
> Dopo aver eseguito un'analisi dinamica con MobSF, le impostazioni del proxy potrebbero essere mal configurate e non sarai in grado di correggerle dalla GUI. Puoi correggere le impostazioni del proxy eseguendo:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Analisi Dinamica Assistita con Inspeckage

Puoi ottenere lo strumento da [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Questo strumento utilizzerà alcuni **Hooks** per farti sapere **cosa sta succedendo nell'applicazione** mentre esegui un'**analisi dinamica**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Questo è un **ottimo strumento per eseguire analisi statiche con un'interfaccia grafica**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Questo strumento è progettato per cercare diverse **vulnerabilità relative alla sicurezza delle applicazioni Android**, sia nel **codice sorgente** che nei **APK confezionati**. Lo strumento è anche **capace di creare un APK "Proof-of-Concept" deployabile** e **comandi ADB**, per sfruttare alcune delle vulnerabilità trovate (Attività esposte, intenti, tapjacking...). Come con Drozer, non è necessario rootare il dispositivo di test.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Mostra tutti i file estratti per un facile riferimento
- Decompila automaticamente i file APK in formato Java e Smali
- Analizza AndroidManifest.xml per vulnerabilità e comportamenti comuni
- Analisi statica del codice sorgente per vulnerabilità e comportamenti comuni
- Informazioni sul dispositivo
- e altro ancora
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER è un'applicazione da riga di comando che può essere utilizzata in Windows, MacOS X e Linux, che analizza i file _.apk_ in cerca di vulnerabilità. Lo fa decomprimendo gli APK e applicando una serie di regole per rilevare quelle vulnerabilità.

Tutte le regole sono centrate in un file `rules.json`, e ogni azienda o tester può creare le proprie regole per analizzare ciò di cui hanno bisogno.

Scarica gli ultimi binari dalla [pagina di download](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn è uno strumento **crossplatform** che aiuta sviluppatori, cacciatori di bug e hacker etici a eseguire [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) su applicazioni mobili.

Il concetto è che puoi trascinare e rilasciare il file della tua applicazione mobile (un file .apk o .ipa) sull'applicazione StaCoAn e genererà un report visivo e portatile per te. Puoi modificare le impostazioni e le wordlist per ottenere un'esperienza personalizzata.

Scarica[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework è un sistema di analisi delle vulnerabilità Android che aiuta sviluppatori o hacker a trovare potenziali vulnerabilità di sicurezza nelle applicazioni Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** è uno strumento il cui obiettivo principale è rilevare e avvisare l'utente riguardo a potenziali comportamenti malevoli sviluppati da un'applicazione Android.

Il rilevamento viene eseguito con l'**analisi statica** del bytecode Dalvik dell'applicazione, rappresentato come **Smali**, utilizzando la libreria [`androguard`](https://github.com/androguard/androguard).

Questo strumento cerca **comportamenti comuni delle applicazioni "cattive"** come: esfiltrazione di identificatori di telefonia, intercettazione di flussi audio/video, modifica dei dati PIM, esecuzione di codice arbitrario...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** è un **M**obile **A**pplication **R**everse engineering e **A**nalysis Framework. È uno strumento che riunisce strumenti comunemente usati per il reverse engineering e l'analisi delle applicazioni mobili, per assistere nel test delle applicazioni mobili contro le minacce alla sicurezza mobile di OWASP. Il suo obiettivo è rendere questo compito più facile e accessibile per gli sviluppatori di applicazioni mobili e i professionisti della sicurezza.

È in grado di:

- Estrarre codice Java e Smali utilizzando diversi strumenti
- Analizzare APK utilizzando: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Estrarre informazioni private dall'APK utilizzando regexps.
- Analizzare il Manifest.
- Analizzare i domini trovati utilizzando: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) e [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK tramite [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Utile per rilevare malware: [https://koodous.com/](https://koodous.com)

## Offuscare/Deoffuscare codice

Nota che a seconda del servizio e della configurazione che utilizzi per offuscare il codice. I segreti potrebbero essere o meno offuscati.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

Da [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** è uno strumento open source da riga di comando che riduce, ottimizza e offusca il codice Java. È in grado di ottimizzare il bytecode e di rilevare e rimuovere istruzioni non utilizzate. ProGuard è software gratuito ed è distribuito sotto la GNU General Public License, versione 2.

ProGuard è distribuito come parte dell'Android SDK e viene eseguito durante la costruzione dell'applicazione in modalità release.

### [DexGuard](https://www.guardsquare.com/dexguard)

Trova una guida passo-passo per deoffuscare l'apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(Da quella guida) L'ultima volta che abbiamo controllato, il modo di operare di Dexguard era:

- caricare una risorsa come InputStream;
- fornire il risultato a una classe che eredita da FilterInputStream per decrittarlo;
- fare un po' di offuscazione inutile per far perdere qualche minuto a un reverser;
- fornire il risultato decrittato a un ZipInputStream per ottenere un file DEX;
- infine caricare il DEX risultante come Risorsa utilizzando il metodo `loadDex`.

### [DeGuard](http://apk-deguard.com)

**DeGuard inverte il processo di offuscazione eseguito dagli strumenti di offuscazione Android. Questo consente numerose analisi di sicurezza, inclusa l'ispezione del codice e la previsione delle librerie.**

Puoi caricare un APK offuscato sulla loro piattaforma.

### [Deobfuscate android App](https://github.com/In3tinct/deobfuscate-android-app)

Questo è uno strumento LLM per trovare potenziali vulnerabilità di sicurezza nelle app Android e deoffuscare il codice delle app Android. Utilizza l'API pubblica di Google Gemini.

### [Simplify](https://github.com/CalebFenton/simplify)

È un **deoffuscatore android generico.** Simplify **esegue virtualmente un'app** per comprendere il suo comportamento e poi **cerca di ottimizzare il codice** in modo che si comporti in modo identico ma sia più facile da comprendere per un umano. Ogni tipo di ottimizzazione è semplice e generico, quindi non importa quale sia il tipo specifico di offuscazione utilizzato.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD ti fornisce informazioni su **come è stato creato un APK**. Identifica molti **compilatori**, **packer**, **offuscatori** e altre cose strane. È [_PEiD_](https://www.aldeid.com/wiki/PEiD) per Android.

### Manuale

[Leggi questo tutorial per imparare alcuni trucchi su **come fare il reverse engineering di offuscazioni personalizzate**](manual-deobfuscation.md)

## Laboratori

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b è una macchina virtuale di sicurezza Android basata su ubuntu-mate che include la raccolta degli ultimi framework, tutorial e laboratori da diversi esperti di sicurezza e ricercatori per il reverse engineering e l'analisi del malware.

## Riferimenti

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) È una grande lista di risorse
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Corso rapido Android
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)

## Ancora da provare

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
