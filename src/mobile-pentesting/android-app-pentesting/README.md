# Pentesting des Applications Android

{{#include ../../banners/hacktricks-training.md}}

## Bases des Applications Android

Il est fortement recommandé de commencer par lire cette page pour connaître les **parties les plus importantes liées à la sécurité Android et les composants les plus dangereux d'une application Android** :

{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

C'est l'outil principal dont vous avez besoin pour vous connecter à un appareil Android (émulé ou physique).\
**ADB** permet de contrôler les appareils soit via **USB** soit via **réseau** depuis un ordinateur. Cet utilitaire permet le **copie** de fichiers dans les deux sens, **installation** et **désinstallation** d'applications, **exécution** de commandes shell, **sauvegarde** de données, **lecture** de journaux, entre autres fonctions.

Consultez la liste suivante de [**Commandes ADB**](adb-commands.md) pour apprendre à utiliser adb.

## Smali

Parfois, il est intéressant de **modifier le code de l'application** pour accéder à des **informations cachées** (peut-être des mots de passe ou des drapeaux bien obfusqués). Ensuite, il pourrait être intéressant de décompiler l'apk, de modifier le code et de le recompiler.\
[**Dans ce tutoriel**, vous pouvez **apprendre à décompiler un APK, modifier le code Smali et recompiler l'APK** avec la nouvelle fonctionnalité](smali-changes.md). Cela pourrait être très utile comme **alternative pour plusieurs tests lors de l'analyse dynamique** qui vont être présentés. Ensuite, **gardez toujours à l'esprit cette possibilité**.

## Autres astuces intéressantes

- [Usurpation de votre emplacement dans le Play Store](spoofing-your-location-in-play-store.md)
- **Télécharger des APK** : [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Extraire l'APK de l'appareil :
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Fusionnez tous les splits et les APK de base avec [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Analyse statique

Tout d'abord, pour analyser un APK, vous devriez **jeter un œil au code Java** en utilisant un décompilateur.\
Veuillez, [**lire ici pour trouver des informations sur les différents décompilateurs disponibles**](apk-decompilers.md).

### Recherche d'informations intéressantes

En jetant simplement un œil aux **chaînes** de l'APK, vous pouvez rechercher des **mots de passe**, des **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), des clés **api**, des **chiffrements**, des **UUIDs Bluetooth**, des **tokens** et tout ce qui est intéressant... cherchez même des **backdoors** d'exécution de code ou des backdoors d'authentification (identifiants administratifs codés en dur dans l'application).

**Firebase**

Faites particulièrement attention aux **URLs Firebase** et vérifiez si elles sont mal configurées. [Plus d'informations sur ce qu'est Firebase et comment l'exploiter ici.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Compréhension de base de l'application - Manifest.xml, strings.xml

L'**examen des fichiers \_Manifest.xml**_\*\* et \*\*_**strings.xml**\_\*\* d'une application peut révéler des vulnérabilités de sécurité potentielles\*\*. Ces fichiers peuvent être accessibles en utilisant des décompilateurs ou en renommant l'extension du fichier APK en .zip puis en le décompressant.

Les **vulnérabilités** identifiées dans le **Manifest.xml** incluent :

- **Applications débogables** : Les applications définies comme débogables (`debuggable="true"`) dans le fichier _Manifest.xml_ posent un risque car elles permettent des connexions pouvant mener à une exploitation. Pour une compréhension plus approfondie sur la façon d'exploiter les applications débogables, référez-vous à un tutoriel sur la recherche et l'exploitation des applications débogables sur un appareil.
- **Paramètres de sauvegarde** : L'attribut `android:allowBackup="false"` doit être explicitement défini pour les applications traitant des informations sensibles afin d'empêcher les sauvegardes de données non autorisées via adb, surtout lorsque le débogage USB est activé.
- **Sécurité réseau** : Les configurations de sécurité réseau personnalisées (`android:networkSecurityConfig="@xml/network_security_config"`) dans _res/xml/_ peuvent spécifier des détails de sécurité comme les certificats et les paramètres de trafic HTTP. Un exemple est de permettre le trafic HTTP pour des domaines spécifiques.
- **Activités et services exportés** : Identifier les activités et services exportés dans le manifeste peut mettre en évidence des composants qui pourraient être mal utilisés. Une analyse plus approfondie lors des tests dynamiques peut révéler comment exploiter ces composants.
- **Fournisseurs de contenu et FileProviders** : Les fournisseurs de contenu exposés pourraient permettre un accès ou une modification non autorisés des données. La configuration des FileProviders doit également être examinée.
- **Receveurs de diffusion et schémas d'URL** : Ces composants pourraient être exploités, en prêtant une attention particulière à la façon dont les schémas d'URL sont gérés pour les vulnérabilités d'entrée.
- **Versions SDK** : Les attributs `minSdkVersion`, `targetSDKVersion` et `maxSdkVersion` indiquent les versions Android prises en charge, soulignant l'importance de ne pas prendre en charge des versions Android obsolètes et vulnérables pour des raisons de sécurité.

À partir du fichier **strings.xml**, des informations sensibles telles que des clés API, des schémas personnalisés et d'autres notes de développeur peuvent être découvertes, soulignant la nécessité d'un examen attentif de ces ressources.

### Tapjacking

Le **tapjacking** est une attaque où une **application malveillante** est lancée et **se positionne au-dessus d'une application victime**. Une fois qu'elle obscurcit visiblement l'application victime, son interface utilisateur est conçue de manière à tromper l'utilisateur pour qu'il interagisse avec elle, tout en transmettant l'interaction à l'application victime.\
En effet, cela **aveugle l'utilisateur sur le fait qu'il effectue réellement des actions sur l'application victime**.

Trouvez plus d'informations dans :

{{#ref}}
tapjacking.md
{{#endref}}

### Détournement de tâche

Une **activité** avec le **`launchMode`** défini sur **`singleTask` sans aucune `taskAffinity`** définie est vulnérable au détournement de tâche. Cela signifie qu'une **application** peut être installée et si elle est lancée avant la véritable application, elle pourrait **détourner la tâche de la véritable application** (de sorte que l'utilisateur interagira avec l'**application malveillante en pensant qu'il utilise la véritable**).

Plus d'infos dans :

{{#ref}}
android-task-hijacking.md
{{#endref}}

### Stockage de données non sécurisé

**Stockage interne**

Dans Android, les fichiers **stockés** dans le **stockage interne** sont **conçus** pour être **accessibles** exclusivement par l'**application** qui les **a créés**. Cette mesure de sécurité est **appliquée** par le système d'exploitation Android et est généralement adéquate pour les besoins de sécurité de la plupart des applications. Cependant, les développeurs utilisent parfois des modes tels que `MODE_WORLD_READABLE` et `MODE_WORLD_WRITABLE` pour **permettre** le partage de fichiers entre différentes applications. Pourtant, ces modes **ne restreignent pas l'accès** à ces fichiers par d'autres applications, y compris celles potentiellement malveillantes.

1. **Analyse statique :**
- **Assurez-vous** que l'utilisation de `MODE_WORLD_READABLE` et `MODE_WORLD_WRITABLE` est **soigneusement examinée**. Ces modes **peuvent potentiellement exposer** des fichiers à un **accès non intentionnel ou non autorisé**.
2. **Analyse dynamique :**
- **Vérifiez** les **permissions** définies sur les fichiers créés par l'application. En particulier, **vérifiez** si des fichiers sont **définis comme lisibles ou modifiables par tout le monde**. Cela peut poser un risque de sécurité significatif, car cela permettrait à **n'importe quelle application** installée sur l'appareil, quelle que soit son origine ou son intention, de **lire ou modifier** ces fichiers.

**Stockage externe**

Lorsqu'il s'agit de fichiers sur le **stockage externe**, comme les cartes SD, certaines précautions doivent être prises :

1. **Accessibilité** :
- Les fichiers sur le stockage externe sont **globalement lisibles et modifiables**. Cela signifie que n'importe quelle application ou utilisateur peut accéder à ces fichiers.
2. **Préoccupations de sécurité** :
- Étant donné la facilité d'accès, il est conseillé de **ne pas stocker d'informations sensibles** sur le stockage externe.
- Le stockage externe peut être retiré ou accessible par n'importe quelle application, ce qui le rend moins sécurisé.
3. **Gestion des données provenant du stockage externe** :
- Toujours **effectuer une validation des entrées** sur les données récupérées du stockage externe. Cela est crucial car les données proviennent d'une source non fiable.
- Il est fortement déconseillé de stocker des exécutables ou des fichiers de classe sur le stockage externe pour un chargement dynamique.
- Si votre application doit récupérer des fichiers exécutables à partir du stockage externe, assurez-vous que ces fichiers sont **signés et vérifiés cryptographiquement** avant d'être chargés dynamiquement. Cette étape est vitale pour maintenir l'intégrité de la sécurité de votre application.

Le stockage externe peut être **accédé** dans `/storage/emulated/0`, `/sdcard`, `/mnt/sdcard`

> [!NOTE]
> À partir d'Android 4.4 (**API 17**), la carte SD a une structure de répertoire qui **limite l'accès d'une application au répertoire spécifiquement destiné à cette application**. Cela empêche une application malveillante d'obtenir un accès en lecture ou en écriture aux fichiers d'une autre application.

**Données sensibles stockées en texte clair**

- **Préférences partagées** : Android permet à chaque application de facilement sauvegarder des fichiers xml dans le chemin `/data/data/<packagename>/shared_prefs/` et il est parfois possible de trouver des informations sensibles en texte clair dans ce dossier.
- **Bases de données** : Android permet à chaque application de facilement sauvegarder des bases de données sqlite dans le chemin `/data/data/<packagename>/databases/` et il est parfois possible de trouver des informations sensibles en texte clair dans ce dossier.

### TLS cassé

**Accepter tous les certificats**

Pour une raison quelconque, parfois les développeurs acceptent tous les certificats même si, par exemple, le nom d'hôte ne correspond pas à des lignes de code comme celle-ci :
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Une bonne façon de tester cela est d'essayer de capturer le trafic en utilisant un proxy comme Burp sans autoriser le certificat CA de Burp sur l'appareil. De plus, vous pouvez générer avec Burp un certificat pour un nom d'hôte différent et l'utiliser.

### Cryptographie cassée

**Mauvais processus de gestion des clés**

Certains développeurs enregistrent des données sensibles dans le stockage local et les cryptent avec une clé codée en dur/prévisible dans le code. Cela ne devrait pas être fait car un certain reverse engineering pourrait permettre aux attaquants d'extraire les informations confidentielles.

**Utilisation d'algorithmes non sécurisés et/ou obsolètes**

Les développeurs ne devraient pas utiliser **d'algorithmes obsolètes** pour effectuer des **vérifications d'autorisation**, **stocker** ou **envoyer** des données. Certains de ces algorithmes sont : RC4, MD4, MD5, SHA1... Si des **hashs** sont utilisés pour stocker des mots de passe par exemple, des hashs résistants à la force brute devraient être utilisés avec du sel.

### Autres vérifications

- Il est recommandé de **d'obfusquer l'APK** pour rendre le travail de reverse engineering plus difficile pour les attaquants.
- Si l'application est sensible (comme les applications bancaires), elle devrait effectuer ses **propres vérifications pour voir si le mobile est rooté** et agir en conséquence.
- Si l'application est sensible (comme les applications bancaires), elle devrait vérifier si un **émulateur** est utilisé.
- Si l'application est sensible (comme les applications bancaires), elle devrait **vérifier sa propre intégrité avant de s'exécuter** pour vérifier si elle a été modifiée.
- Utilisez [**APKiD**](https://github.com/rednaga/APKiD) pour vérifier quel compilateur/emballeur/obfuscateur a été utilisé pour construire l'APK.

### Application React Native

Lisez la page suivante pour apprendre comment accéder facilement au code javascript des applications React :

{{#ref}}
react-native-application.md
{{#endref}}

### Applications Xamarin

Lisez la page suivante pour apprendre comment accéder facilement au code C# des applications xamarin :

{{#ref}}
../xamarin-apps.md
{{#endref}}

### Applications Superpackées

Selon ce [**post de blog**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/), superpacké est un algorithme Meta qui compresse le contenu d'une application en un seul fichier. Le blog parle de la possibilité de créer une application qui décompresse ce type d'applications... et d'une méthode plus rapide qui consiste à **exécuter l'application et à rassembler les fichiers décompressés à partir du système de fichiers.**

### Analyse statique automatisée du code

L'outil [**mariana-trench**](https://github.com/facebook/mariana-trench) est capable de trouver des **vulnérabilités** en **scannant** le **code** de l'application. Cet outil contient une série de **sources connues** (qui indiquent à l'outil les **endroits** où l'**entrée** est **contrôlée par l'utilisateur**), des **puits** (qui indiquent à l'outil les **endroits dangereux** où une entrée malveillante pourrait causer des dommages) et des **règles**. Ces règles indiquent la **combinaison** de **sources-puits** qui indique une vulnérabilité.

Avec cette connaissance, **mariana-trench examinera le code et trouvera d'éventuelles vulnérabilités.**

### Secrets divulgués

Une application peut contenir des secrets (clés API, mots de passe, URLs cachées, sous-domaines...) à l'intérieur que vous pourriez être en mesure de découvrir. Vous pourriez utiliser un outil tel que [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks).

### Contournement de l'authentification biométrique

{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Autres fonctions intéressantes

- **Exécution de code** : `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Envoyer des SMS** : `sendTextMessage, sendMultipartTestMessage`
- **Fonctions natives** déclarées comme `native` : `public native, System.loadLibrary, System.load`
- [Lisez ceci pour apprendre **comment inverser les fonctions natives**](reversing-native-libraries.md)

### **Autres astuces**

{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Analyse dynamique

> Tout d'abord, vous avez besoin d'un environnement où vous pouvez installer l'application et tout l'environnement (certificat CA de Burp, Drozer et Frida principalement). Par conséquent, un appareil rooté (émulé ou non) est fortement recommandé.

### Analyse dynamique en ligne

Vous pouvez créer un **compte gratuit** sur : [https://appetize.io/](https://appetize.io). Cette plateforme vous permet de **télécharger** et **d'exécuter** des APK, ce qui est utile pour voir comment un APK se comporte.

Vous pouvez même **voir les journaux de votre application** sur le web et vous connecter via **adb**.

![](<../../images/image (831).png>)

Grâce à la connexion ADB, vous pouvez utiliser **Drozer** et **Frida** à l'intérieur des émulateurs.

### Analyse dynamique locale

#### Utilisation d'un émulateur

- [**Android Studio**](https://developer.android.com/studio) (Vous pouvez créer des appareils **x86** et **arm**, et selon [**ceci**](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html), les **dernières versions x86** prennent en charge les bibliothèques ARM sans avoir besoin d'un émulateur ARM lent).
- Apprenez à le configurer sur cette page :

{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Version gratuite :** Édition personnelle, vous devez créer un compte. _Il est recommandé de **télécharger** la version **AVEC** _ _**VirtualBox** pour éviter des erreurs potentielles._)
- [**Nox**](https://es.bignox.com) (Gratuit, mais il ne prend pas en charge Frida ou Drozer).

> [!NOTE]
> Lors de la création d'un nouvel émulateur sur n'importe quelle plateforme, rappelez-vous que plus l'écran est grand, plus l'émulateur fonctionnera lentement. Donc, sélectionnez de petits écrans si possible.

Pour **installer les services Google** (comme l'AppStore) dans Genymotion, vous devez cliquer sur le bouton marqué en rouge de l'image suivante :

![](<../../images/image (277).png>)

De plus, notez que dans la **configuration de la VM Android dans Genymotion**, vous pouvez sélectionner le **mode réseau Bridge** (ce qui sera utile si vous vous connectez à la VM Android depuis une autre VM avec les outils).

#### Utiliser un appareil physique

Vous devez activer les **options de débogage** et il serait bien si vous pouviez le **rooter** :

1. **Paramètres**.
2. (À partir d'Android 8.0) Sélectionnez **Système**.
3. Sélectionnez **À propos du téléphone**.
4. Appuyez sur **Numéro de build** 7 fois.
5. Revenez en arrière et vous trouverez les **options de développement**.

> Une fois que vous avez installé l'application, la première chose que vous devriez faire est de l'essayer et d'enquêter sur ce qu'elle fait, comment elle fonctionne et vous y habituer.\
> Je vous suggérerai de **réaliser cette analyse dynamique initiale en utilisant l'analyse dynamique MobSF + pidcat**, afin que nous puissions **apprendre comment l'application fonctionne** pendant que MobSF **capture** beaucoup de **données intéressantes** que vous pourrez examiner plus tard.

### Fuite de données involontaire

**Journalisation**

Les développeurs doivent être prudents de ne pas exposer **des informations de débogage** publiquement, car cela peut entraîner des fuites de données sensibles. Les outils [**pidcat**](https://github.com/JakeWharton/pidcat) et `adb logcat` sont recommandés pour surveiller les journaux d'application afin d'identifier et de protéger les informations sensibles. **Pidcat** est privilégié pour sa facilité d'utilisation et sa lisibilité.

> [!WARNING]
> Notez qu'à partir de **versions plus récentes qu'Android 4.0**, **les applications ne peuvent accéder qu'à leurs propres journaux**. Donc, les applications ne peuvent pas accéder aux journaux d'autres applications.\
> Quoi qu'il en soit, il est toujours recommandé de **ne pas enregistrer d'informations sensibles**.

**Mise en cache du tampon Copier/Coller**

Le cadre **basé sur le presse-papiers** d'Android permet la fonctionnalité de copier-coller dans les applications, mais pose un risque car **d'autres applications** peuvent **accéder** au presse-papiers, exposant potentiellement des données sensibles. Il est crucial de **désactiver les fonctions de copier/coller** pour les sections sensibles d'une application, comme les détails de carte de crédit, afin de prévenir les fuites de données.

**Journaux de plantage**

Si une application **plante** et **enregistre des journaux**, ces journaux peuvent aider les attaquants, en particulier lorsque l'application ne peut pas être inversée. Pour atténuer ce risque, évitez de journaliser lors des plantages, et si des journaux doivent être transmis sur le réseau, assurez-vous qu'ils sont envoyés via un canal SSL pour des raisons de sécurité.

En tant que pentester, **essayez de jeter un œil à ces journaux**.

**Données analytiques envoyées à des tiers**

Les applications intègrent souvent des services comme Google Adsense, ce qui peut involontairement **fuir des données sensibles** en raison d'une mise en œuvre incorrecte par les développeurs. Pour identifier d'éventuelles fuites de données, il est conseillé de **intercepter le trafic de l'application** et de vérifier toute information sensible envoyée à des services tiers.

### Bases de données SQLite

La plupart des applications utiliseront des **bases de données SQLite internes** pour enregistrer des informations. Lors du pentest, jetez un **œil** aux **bases de données** créées, aux noms des **tables** et des **colonnes** et à toutes les **données** enregistrées car vous pourriez trouver des **informations sensibles** (ce qui constituerait une vulnérabilité).\
Les bases de données devraient être situées dans `/data/data/the.package.name/databases` comme `/data/data/com.mwr.example.sieve/databases`.

Si la base de données enregistre des informations confidentielles et est **cryptée**, mais que vous pouvez **trouver** le **mot de passe** à l'intérieur de l'application, c'est toujours une **vulnérabilité**.

Énumérez les tables en utilisant `.tables` et énumérez les colonnes des tables en faisant `.schema <table_name>`.

### Drozer (Exploitation des activités exportées, des fournisseurs de contenu et des services)

D'après [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf) : **Drozer** vous permet d'**assumer le rôle d'une application Android** et d'interagir avec d'autres applications. Il peut faire **tout ce qu'une application installée peut faire**, comme utiliser le mécanisme de communication inter-processus (IPC) d'Android et interagir avec le système d'exploitation sous-jacent.\
Drozer est un outil utile pour **exploiter les activités exportées, les services exportés et les fournisseurs de contenu** comme vous l'apprendrez dans les sections suivantes.

### Exploitation des activités exportées

[**Lisez ceci si vous voulez rafraîchir ce qu'est une activité Android.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Rappelez-vous également que le code d'une activité commence dans la méthode **`onCreate`**.

**Contournement de l'autorisation**

Lorsqu'une activité est exportée, vous pouvez invoquer son écran depuis une application externe. Par conséquent, si une activité contenant des **informations sensibles** est **exportée**, vous pourriez **contourner** les mécanismes **d'authentification** **pour y accéder.**

[**Apprenez comment exploiter les activités exportées avec Drozer.**](drozer-tutorial/index.html#activities)

Vous pouvez également démarrer une activité exportée depuis adb :

- Le nom du package est com.example.demo
- Le nom de l'activité exportée est com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF détectera comme malveillant l'utilisation de _**singleTask/singleInstance**_ comme `android:launchMode` dans une activité, mais en raison de [cela](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparemment cela n'est dangereux que sur les anciennes versions (versions API < 21).

> [!NOTE]
> Notez qu'un contournement d'autorisation n'est pas toujours une vulnérabilité, cela dépend de la manière dont le contournement fonctionne et des informations qui sont exposées.

**Fuite d'informations sensibles**

**Les activités peuvent également renvoyer des résultats**. Si vous parvenez à trouver une activité exportée et non protégée appelant la méthode **`setResult`** et **renvoyant des informations sensibles**, il y a une fuite d'informations sensibles.

#### Tapjacking

Si le tapjacking n'est pas prévenu, vous pourriez abuser de l'activité exportée pour faire en sorte que **l'utilisateur effectue des actions inattendues**. Pour plus d'informations sur [**ce qu'est le Tapjacking, suivez le lien**](#tapjacking).

### Exploitation des Content Providers - Accéder et manipuler des informations sensibles

[**Lisez ceci si vous voulez rafraîchir ce qu'est un Content Provider.**](android-applications-basics.md#content-provider)\
Les content providers sont essentiellement utilisés pour **partager des données**. Si une application dispose de content providers disponibles, vous pourriez être en mesure d'**extraire des données sensibles** à partir d'eux. Il est également intéressant de tester d'éventuelles **injections SQL** et **Path Traversals** car elles pourraient être vulnérables.

[**Apprenez à exploiter les Content Providers avec Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploitation des Services**

[**Lisez ceci si vous voulez rafraîchir ce qu'est un Service.**](android-applications-basics.md#services)\
Rappelez-vous que les actions d'un Service commencent dans la méthode `onStartCommand`.

Un service est essentiellement quelque chose qui **peut recevoir des données**, **les traiter** et **renvoyer** (ou non) une réponse. Donc, si une application exporte certains services, vous devriez **vérifier** le **code** pour comprendre ce qu'il fait et **le tester** **dynamiquement** pour extraire des informations confidentielles, contourner des mesures d'authentification...\
[**Apprenez à exploiter les Services avec Drozer.**](drozer-tutorial/index.html#services)

### **Exploitation des Broadcast Receivers**

[**Lisez ceci si vous voulez rafraîchir ce qu'est un Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Rappelez-vous que les actions d'un Broadcast Receiver commencent dans la méthode `onReceive`.

Un broadcast receiver attendra un type de message. Selon la manière dont le récepteur gère le message, il pourrait être vulnérable.\
[**Apprenez à exploiter les Broadcast Receivers avec Drozer.**](#exploiting-broadcast-receivers)

### **Exploitation des Schémas / Liens profonds**

Vous pouvez rechercher des liens profonds manuellement, en utilisant des outils comme MobSF ou des scripts comme [celui-ci](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Vous pouvez **ouvrir** un **schéma** déclaré en utilisant **adb** ou un **navigateur** :
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Remarque que tu peux **omettre le nom du package** et le mobile appellera automatiquement l'application qui devrait ouvrir ce lien._
```markup
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Code exécuté**

Pour trouver le **code qui sera exécuté dans l'App**, allez à l'activité appelée par le deeplink et recherchez la fonction **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Informations sensibles**

Chaque fois que vous trouvez un deep link, vérifiez qu'il **ne reçoit pas de données sensibles (comme des mots de passe) via des paramètres d'URL**, car toute autre application pourrait **usurper le deep link et voler ces données !**

**Paramètres dans le chemin**

Vous **devez également vérifier si un deep link utilise un paramètre à l'intérieur du chemin** de l'URL comme : `https://api.example.com/v1/users/{username}`, dans ce cas, vous pouvez forcer un parcours de chemin en accédant à quelque chose comme : `example://app/users?username=../../unwanted-endpoint%3fparam=value`.\
Notez que si vous trouvez les bons points de terminaison à l'intérieur de l'application, vous pourriez être en mesure de provoquer un **Open Redirect** (si une partie du chemin est utilisée comme nom de domaine), **prise de contrôle de compte** (si vous pouvez modifier les détails des utilisateurs sans jeton CSRF et que le point de terminaison vulnérable utilise la bonne méthode) et toute autre vulnérabilité. Plus [d'infos à ce sujet ici](http://dphoeniixx.com/2020/12/13-2/).

**Plus d'exemples**

Un [rapport de bug bounty intéressant](https://hackerone.com/reports/855618) concernant des liens (_/.well-known/assetlinks.json_).

### Échecs d'inspection et de vérification de la couche de transport

- **Les certificats ne sont pas toujours inspectés correctement** par les applications Android. Il est courant que ces applications ignorent les avertissements et acceptent des certificats auto-signés ou, dans certains cas, reviennent à utiliser des connexions HTTP.
- **Les négociations lors de la poignée de main SSL/TLS sont parfois faibles**, utilisant des suites de chiffrement non sécurisées. Cette vulnérabilité rend la connexion susceptible aux attaques de type homme du milieu (MITM), permettant aux attaquants de déchiffrer les données.
- **La fuite d'informations privées** est un risque lorsque les applications s'authentifient via des canaux sécurisés mais communiquent ensuite par des canaux non sécurisés pour d'autres transactions. Cette approche ne protège pas les données sensibles, telles que les cookies de session ou les détails des utilisateurs, contre l'interception par des entités malveillantes.

#### Vérification des certificats

Nous allons nous concentrer sur la **vérification des certificats**. L'intégrité du certificat du serveur doit être vérifiée pour améliorer la sécurité. Cela est crucial car des configurations TLS non sécurisées et la transmission de données sensibles par des canaux non chiffrés peuvent poser des risques significatifs. Pour des étapes détaillées sur la vérification des certificats de serveur et le traitement des vulnérabilités, [**cette ressource**](https://manifestsecurity.com/android-application-security-part-10/) fournit des conseils complets.

#### SSL Pinning

Le SSL Pinning est une mesure de sécurité où l'application vérifie le certificat du serveur par rapport à une copie connue stockée dans l'application elle-même. Cette méthode est essentielle pour prévenir les attaques MITM. Il est fortement recommandé de mettre en œuvre le SSL Pinning pour les applications traitant des informations sensibles.

#### Inspection du trafic

Pour inspecter le trafic HTTP, il est nécessaire d'**installer le certificat de l'outil proxy** (par exemple, Burp). Sans l'installation de ce certificat, le trafic chiffré pourrait ne pas être visible via le proxy. Pour un guide sur l'installation d'un certificat CA personnalisé, [**cliquez ici**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Les applications ciblant **API Level 24 et supérieur** nécessitent des modifications de la configuration de sécurité réseau pour accepter le certificat CA du proxy. Cette étape est cruciale pour inspecter le trafic chiffré. Pour des instructions sur la modification de la configuration de sécurité réseau, [**reportez-vous à ce tutoriel**](make-apk-accept-ca-certificate.md).

#### Contournement du SSL Pinning

Lorsque le SSL Pinning est mis en œuvre, le contournement devient nécessaire pour inspecter le trafic HTTPS. Diverses méthodes sont disponibles à cet effet :

- Modifiez automatiquement l'**apk** pour **contourner** le SSL Pinning avec [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Le meilleur avantage de cette option est que vous n'aurez pas besoin de root pour contourner le SSL Pinning, mais vous devrez supprimer l'application et réinstaller la nouvelle, et cela ne fonctionnera pas toujours.
- Vous pourriez utiliser **Frida** (discuté ci-dessous) pour contourner cette protection. Voici un guide pour utiliser Burp+Frida+Genymotion : [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Vous pouvez également essayer de **contourner automatiquement le SSL Pinning** en utilisant [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Vous pouvez également essayer de **contourner automatiquement le SSL Pinning** en utilisant **l'analyse dynamique MobSF** (expliqué ci-dessous)
- Si vous pensez toujours qu'il y a un trafic que vous ne capturez pas, vous pouvez essayer de **rediriger le trafic vers burp en utilisant iptables**. Lisez ce blog : [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Recherche de vulnérabilités web courantes

Il est également important de rechercher des vulnérabilités web courantes au sein de l'application. Des informations détaillées sur l'identification et l'atténuation de ces vulnérabilités dépassent le cadre de ce résumé mais sont largement couvertes ailleurs.

### Frida

[Frida](https://www.frida.re) est un outil d'instrumentation dynamique pour les développeurs, les ingénieurs en rétro-ingénierie et les chercheurs en sécurité.\
**Vous pouvez accéder à l'application en cours d'exécution et accrocher des méthodes en temps réel pour changer le comportement, changer des valeurs, extraire des valeurs, exécuter différents codes...**\
Si vous souhaitez effectuer un pentesting sur des applications Android, vous devez savoir comment utiliser Frida.

- Apprenez à utiliser Frida : [**Tutoriel Frida**](frida-tutorial/)
- Une sorte de "GUI" pour les actions avec Frida : [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection est excellent pour automatiser l'utilisation de Frida : [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Vous pouvez trouver des scripts Frida intéressants ici : [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Essayez de contourner les mécanismes anti-debugging / anti-frida en chargeant Frida comme indiqué dans [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (outil [linjector](https://github.com/erfur/linjector-rs))

### **Dump de mémoire - Fridump**

Vérifiez si l'application stocke des informations sensibles dans la mémoire qu'elle ne devrait pas stocker, comme des mots de passe ou des mnémoniques.

En utilisant [**Fridump3**](https://github.com/rootbsd/fridump3), vous pouvez dumper la mémoire de l'application avec :
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Cela va vider la mémoire dans le dossier ./dump, et là-dedans, vous pourriez grep avec quelque chose comme :
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Données sensibles dans le Keystore**

Dans Android, le Keystore est le meilleur endroit pour stocker des données sensibles, cependant, avec suffisamment de privilèges, il est toujours **possible d'y accéder**. Comme les applications ont tendance à y stocker **des données sensibles en texte clair**, les pentests devraient vérifier cela en tant qu'utilisateur root ou toute personne ayant un accès physique à l'appareil pourrait être en mesure de voler ces données.

Même si une application stocke des données dans le keystore, les données devraient être chiffrées.

Pour accéder aux données à l'intérieur du keystore, vous pouvez utiliser ce script Frida : [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Contour/Contournement Biométrique**

En utilisant le script Frida suivant, il pourrait être possible de **contourner l'authentification par empreinte digitale** que les applications Android pourraient effectuer afin de **protéger certaines zones sensibles :**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Images de Fond**

Lorsque vous mettez une application en arrière-plan, Android stocke un **instantané de l'application** afin que, lorsqu'elle est récupérée au premier plan, elle commence à charger l'image avant l'application, ce qui donne l'impression que l'application a été chargée plus rapidement.

Cependant, si cet instantané contient des **informations sensibles**, quelqu'un ayant accès à l'instantané pourrait **voler ces informations** (notez que vous avez besoin de root pour y accéder).

Les instantanés sont généralement stockés autour de : **`/data/system_ce/0/snapshots`**

Android fournit un moyen de **prévenir la capture d'écran en définissant le paramètre de mise en page FLAG_SECURE**. En utilisant ce drapeau, le contenu de la fenêtre est traité comme sécurisé, empêchant son apparition dans les captures d'écran ou d'être visualisé sur des affichages non sécurisés.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Analyseur d'Application Android**

Cet outil peut vous aider à gérer différents outils lors de l'analyse dynamique : [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Injection d'Intent

Les développeurs créent souvent des composants proxy comme des activités, des services et des récepteurs de diffusion qui gèrent ces Intents et les transmettent à des méthodes telles que `startActivity(...)` ou `sendBroadcast(...)`, ce qui peut être risqué.

Le danger réside dans le fait de permettre aux attaquants de déclencher des composants d'application non exportés ou d'accéder à des fournisseurs de contenu sensibles en détournant ces Intents. Un exemple notable est le composant `WebView` qui convertit les URL en objets `Intent` via `Intent.parseUri(...)` et les exécute ensuite, ce qui peut entraîner des injections d'Intent malveillantes.

### Points Essentiels

- **Injection d'Intent** est similaire au problème de Redirection Ouverte sur le web.
- Les exploits impliquent de passer des objets `Intent` en tant qu'extras, qui peuvent être redirigés pour exécuter des opérations non sécurisées.
- Cela peut exposer des composants non exportés et des fournisseurs de contenu aux attaquants.
- La conversion d'URL en `Intent` de `WebView` peut faciliter des actions non intentionnelles.

### Injections Côté Client Android et autres

Vous connaissez probablement ce type de vulnérabilités sur le Web. Vous devez être particulièrement prudent avec ces vulnérabilités dans une application Android :

- **Injection SQL :** Lors de la gestion de requêtes dynamiques ou de Content-Providers, assurez-vous d'utiliser des requêtes paramétrées.
- **Injection JavaScript (XSS) :** Vérifiez que le support JavaScript et Plugin est désactivé pour tous les WebViews (désactivé par défaut). [Plus d'infos ici](webview-attacks.md#javascript-enabled).
- **Inclusion de Fichiers Locaux :** Les WebViews ne devraient pas avoir accès au système de fichiers (activé par défaut) - `(webview.getSettings().setAllowFileAccess(false);)`. [Plus d'infos ici](webview-attacks.md#javascript-enabled).
- **Cookies éternels** : Dans plusieurs cas, lorsque l'application Android termine la session, le cookie n'est pas révoqué ou peut même être enregistré sur le disque.
- [**Drapeau Sécurisé** dans les cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Analyse Automatique

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Analyse statique**

![](<../../images/image (866).png>)

**Évaluation de la vulnérabilité de l'application** à l'aide d'une belle interface web. Vous pouvez également effectuer une analyse dynamique (mais vous devez préparer l'environnement).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Remarque que MobSF peut analyser des applications **Android**(apk)**, IOS**(ipa) **et Windows**(apx) (_Les applications Windows doivent être analysées depuis un MobSF installé sur un hôte Windows_).\
De plus, si vous créez un fichier **ZIP** avec le code source d'une application **Android** ou **IOS** (allez dans le dossier racine de l'application, sélectionnez tout et créez un fichier ZIP), il pourra également l'analyser.

MobSF permet également d'effectuer une analyse **diff/Compare** et d'intégrer **VirusTotal** (vous devrez définir votre clé API dans _MobSF/settings.py_ et l'activer : `VT_ENABLED = TRUE` `VT_API_KEY = <Votre clé API>` `VT_UPLOAD = TRUE`). Vous pouvez également définir `VT_UPLOAD` sur `False`, alors le **hash** sera **téléchargé** au lieu du fichier.

### Analyse dynamique assistée avec MobSF

**MobSF** peut également être très utile pour l'**analyse dynamique** sur **Android**, mais dans ce cas, vous devrez installer MobSF et **genymotion** sur votre hôte (une VM ou Docker ne fonctionnera pas). _Remarque : Vous devez **d'abord démarrer une VM dans genymotion** puis **MobSF.**_\
L'**analyseur dynamique MobSF** peut :

- **Dump des données d'application** (URLs, journaux, presse-papiers, captures d'écran réalisées par vous, captures d'écran réalisées par "**Exported Activity Tester**", e-mails, bases de données SQLite, fichiers XML et autres fichiers créés). Tout cela se fait automatiquement sauf pour les captures d'écran, vous devez appuyer lorsque vous souhaitez une capture d'écran ou vous devez appuyer sur "**Exported Activity Tester**" pour obtenir des captures d'écran de toutes les activités exportées.
- Capturer le **trafic HTTPS**
- Utiliser **Frida** pour obtenir des **informations d'exécution**

À partir des versions **Android > 5**, il **démarrera automatiquement Frida** et définira les paramètres de **proxy** globaux pour **capturer** le trafic. Il ne capturera que le trafic de l'application testée.

**Frida**

Par défaut, il utilisera également certains scripts Frida pour **contourner le SSL pinning**, **la détection de root** et **la détection de débogueur** et pour **surveiller des API intéressantes**.\
MobSF peut également **invoquer des activités exportées**, capturer des **captures d'écran** de celles-ci et **les enregistrer** pour le rapport.

Pour **démarrer** le test dynamique, appuyez sur le bouton vert : "**Start Instrumentation**". Appuyez sur "**Frida Live Logs**" pour voir les journaux générés par les scripts Frida et "**Live API Monitor**" pour voir toutes les invocations aux méthodes accrochées, les arguments passés et les valeurs retournées (cela apparaîtra après avoir appuyé sur "Start Instrumentation").\
MobSF vous permet également de charger vos propres **scripts Frida** (pour envoyer les résultats de vos scripts Frida à MobSF, utilisez la fonction `send()`). Il dispose également de **plusieurs scripts pré-écrits** que vous pouvez charger (vous pouvez en ajouter d'autres dans `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), il suffit de **les sélectionner**, d'appuyer sur "**Load**" et d'appuyer sur "**Start Instrumentation**" (vous pourrez voir les journaux de ces scripts dans "**Frida Live Logs**").

![](<../../images/image (419).png>)

De plus, vous avez quelques fonctionnalités auxiliaires de Frida :

- **Énumérer les classes chargées** : Il imprimera toutes les classes chargées
- **Capturer des chaînes** : Il imprimera toutes les chaînes capturées lors de l'utilisation de l'application (très bruyant)
- **Capturer les comparaisons de chaînes** : Pourrait être très utile. Il **montrera les 2 chaînes comparées** et si le résultat était vrai ou faux.
- **Énumérer les méthodes de classe** : Mettez le nom de la classe (comme "java.io.File") et il imprimera toutes les méthodes de la classe.
- **Rechercher un motif de classe** : Rechercher des classes par motif
- **Tracer les méthodes de classe** : **Tracer** une **classe entière** (voir les entrées et sorties de toutes les méthodes de la classe). N'oubliez pas qu'en mode par défaut, MobSF trace plusieurs méthodes d'API Android intéressantes.

Une fois que vous avez sélectionné le module auxiliaire que vous souhaitez utiliser, vous devez appuyer sur "**Start Intrumentation**" et vous verrez toutes les sorties dans "**Frida Live Logs**".

**Shell**

Mobsf vous propose également un shell avec quelques commandes **adb**, des **commandes MobSF**, et des **commandes shell** courantes en bas de la page d'analyse dynamique. Quelques commandes intéressantes :
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**Outils HTTP**

Lorsque le trafic http est capturé, vous pouvez voir une vue peu attrayante du trafic capturé sur "**HTTP(S) Traffic**" en bas ou une vue plus agréable dans "**Start HTTPTools**" en bas vert. À partir de la deuxième option, vous pouvez **envoyer** les **requêtes capturées** à des **proxies** comme Burp ou Owasp ZAP.\
Pour ce faire, _allumez Burp -->_ _désactivez Intercept --> dans MobSB HTTPTools, sélectionnez la requête_ --> appuyez sur "**Send to Fuzzer**" --> _sélectionnez l'adresse du proxy_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Une fois que vous avez terminé l'analyse dynamique avec MobSF, vous pouvez appuyer sur "**Start Web API Fuzzer**" pour **fuzz les requêtes http** et rechercher des vulnérabilités.

> [!NOTE]
> Après avoir effectué une analyse dynamique avec MobSF, les paramètres du proxy peuvent être mal configurés et vous ne pourrez pas les corriger depuis l'interface graphique. Vous pouvez corriger les paramètres du proxy en faisant :
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Analyse Dynamique Assistée avec Inspeckage

Vous pouvez obtenir l'outil depuis [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Cet outil utilisera des **Hooks** pour vous informer **de ce qui se passe dans l'application** pendant que vous effectuez une **analyse dynamique**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

C'est un **excellent outil pour effectuer une analyse statique avec une interface graphique**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Cet outil est conçu pour rechercher plusieurs **vulnérabilités liées à la sécurité des applications Android**, que ce soit dans le **code source** ou les **APKs empaquetés**. L'outil est également **capable de créer un APK déployable "Proof-of-Concept"** et des **commandes ADB**, pour exploiter certaines des vulnérabilités trouvées (Activités exposées, intents, tapjacking...). Comme avec Drozer, il n'est pas nécessaire de rooter l'appareil de test.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Affiche tous les fichiers extraits pour une référence facile
- Décompile automatiquement les fichiers APK en format Java et Smali
- Analyse AndroidManifest.xml pour des vulnérabilités et comportements courants
- Analyse statique du code source pour des vulnérabilités et comportements courants
- Informations sur l'appareil
- et plus encore
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER est une application en ligne de commande qui peut être utilisée sous Windows, MacOS X et Linux, qui analyse les fichiers _.apk_ à la recherche de vulnérabilités. Elle le fait en décompressant les APK et en appliquant une série de règles pour détecter ces vulnérabilités.

Toutes les règles sont centrées dans un fichier `rules.json`, et chaque entreprise ou testeur peut créer ses propres règles pour analyser ce dont ils ont besoin.

Téléchargez les derniers binaires sur la [page de téléchargement](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn est un outil **multiplateforme** qui aide les développeurs, les chasseurs de bugs et les hackers éthiques à effectuer une [analyse de code statique](https://en.wikipedia.org/wiki/Static_program_analysis) sur des applications mobiles.

Le concept est que vous faites glisser et déposer votre fichier d'application mobile (un fichier .apk ou .ipa) sur l'application StaCoAn et elle générera un rapport visuel et portable pour vous. Vous pouvez ajuster les paramètres et les listes de mots pour obtenir une expérience personnalisée.

Télécharger[ dernière version](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework est un système d'analyse de vulnérabilités Android qui aide les développeurs ou les hackers à trouver des vulnérabilités de sécurité potentielles dans les applications Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** est un outil dont le principal objectif est de détecter et d'avertir l'utilisateur des comportements malveillants potentiels développés par une application Android.

La détection est effectuée par l'**analyse statique** du bytecode Dalvik de l'application, représenté sous forme de **Smali**, avec la bibliothèque [`androguard`](https://github.com/androguard/androguard).

Cet outil recherche des **comportements courants des applications "malveillantes"** tels que : exfiltration d'identifiants de téléphonie, interception de flux audio/vidéo, modification de données PIM, exécution de code arbitraire...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** est un **M**obile **A**pplication **R**everse engineering et **A**nalysis Framework. C'est un outil qui regroupe des outils d'ingénierie inverse et d'analyse d'applications mobiles couramment utilisés, pour aider à tester les applications mobiles contre les menaces de sécurité mobile OWASP. Son objectif est de rendre cette tâche plus facile et plus conviviale pour les développeurs d'applications mobiles et les professionnels de la sécurité.

Il est capable de :

- Extraire du code Java et Smali en utilisant différents outils
- Analyser des APKs en utilisant : [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Extraire des informations privées de l'APK en utilisant des regexps.
- Analyser le Manifest.
- Analyser les domaines trouvés en utilisant : [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) et [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Déobfusquer l'APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Utile pour détecter les malwares : [https://koodous.com/](https://koodous.com)

## Obfuscating/Deobfuscating code

Notez qu'en fonction du service et de la configuration que vous utilisez pour obfusquer le code, les secrets peuvent ou non être obfusqués.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

D'après [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** est un outil en ligne de commande open source qui réduit, optimise et obfusque le code Java. Il est capable d'optimiser le bytecode ainsi que de détecter et de supprimer les instructions inutilisées. ProGuard est un logiciel libre et est distribué sous la licence publique générale GNU, version 2.

ProGuard est distribué dans le cadre du SDK Android et s'exécute lors de la construction de l'application en mode release.

### [DexGuard](https://www.guardsquare.com/dexguard)

Trouvez un guide étape par étape pour déobfusquer l'apk dans [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(D'après ce guide) La dernière fois que nous avons vérifié, le mode de fonctionnement de Dexguard était :

- charger une ressource en tant qu'InputStream ;
- alimenter le résultat à une classe héritant de FilterInputStream pour le déchiffrer ;
- faire une obfuscation inutile pour faire perdre quelques minutes à un reverseur ;
- alimenter le résultat déchiffré à un ZipInputStream pour obtenir un fichier DEX ;
- enfin, charger le DEX résultant en tant que ressource en utilisant la méthode `loadDex`.

### [DeGuard](http://apk-deguard.com)

**DeGuard inverse le processus d'obfuscation effectué par les outils d'obfuscation Android. Cela permet de nombreuses analyses de sécurité, y compris l'inspection du code et la prédiction des bibliothèques.**

Vous pouvez télécharger un APK obfusqué sur leur plateforme.

### [Deobfuscate android App](https://github.com/In3tinct/deobfuscate-android-app)

C'est un outil LLM pour trouver d'éventuelles vulnérabilités de sécurité dans les applications android et déobfusquer le code des applications android. Utilise l'API publique Gemini de Google.

### [Simplify](https://github.com/CalebFenton/simplify)

C'est un **déobfuscateur android générique.** Simplify **exécute virtuellement une application** pour comprendre son comportement et ensuite **essaie d'optimiser le code** afin qu'il se comporte de manière identique mais soit plus facile à comprendre pour un humain. Chaque type d'optimisation est simple et générique, donc peu importe le type spécifique d'obfuscation utilisé.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD vous donne des informations sur **comment un APK a été créé**. Il identifie de nombreux **compilateurs**, **packers**, **obfuscateurs**, et d'autres choses étranges. C'est [_PEiD_](https://www.aldeid.com/wiki/PEiD) pour Android.

### Manual

[Lire ce tutoriel pour apprendre quelques astuces sur **comment inverser une obfuscation personnalisée**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b est une machine virtuelle de sécurité Android basée sur ubuntu-mate qui inclut la collection des derniers frameworks, tutoriels et laboratoires de différents geeks et chercheurs en sécurité pour l'ingénierie inverse et l'analyse de malware.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) C'est une excellente liste de ressources
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Cours rapide sur Android
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)

## Yet to try

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
