# Android aplikacije Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Osnovi Android aplikacija

Preporučuje se da počnete sa čitanjem ove stranice kako biste saznali o **najvažnijim delovima vezanim za Android bezbednost i najopasnijim komponentama u Android aplikaciji**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Ovo je glavni alat koji vam treba da se povežete sa Android uređajem (emulator ili fizički).\  
**ADB** omogućava kontrolu uređaja preko **USB** ili **Network** sa računara. Ovaj alat omogućava **kopiranje** fajlova u oba smera, **instalaciju** i **deinstalaciju** aplikacija, **izvršavanje** shell komandi, **pravljenje bekapa** podataka, **čitanje** logova, među ostalim funkcijama.

Pogledajte sledeću listu [**ADB komande**](adb-commands.md) da naučite kako da koristite adb.

## Smali

Ponekad je interesantno **izmeniti kod aplikacije** da bi se pristupilo **skrivenim informacijama** (npr. jako obfuskovani passwordi ili flagovi). U tom slučaju može biti korisno dekompajlirati apk, izmeniti kod i ponovo ga kompajlirati.\  
[**U ovom tutorijalu** možete **naučiti kako da dekompajlirate APK, izmenite Smali kod i ponovo kompajlirate APK** sa novom funkcionalnošću](smali-changes.md). Ovo može biti veoma korisno kao **alternativa za nekoliko testova tokom dinamičke analize** koja će biti predstavljena. Zato, **uvek imajte ovu mogućnost na umu**.

## Ostali zanimljivi trikovi

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [Android IME / InputMethodService Abuse (Malicious Keyboards)](inputmethodservice-ime-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **Preuzimanje APK-ova**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Ekstraktovanje APK-a sa uređaja:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Spojite sve splits i base apks pomoću [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Android Enterprise & Work Profile Attacks

{{#ref}}
android-enterprise-work-profile-bypass.md
{{#endref}}

## Case Studies & Vulnerabilities


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}


{{#ref}}
../../binary-exploitation/linux-kernel-exploitation/arm64-static-linear-map-kaslr-bypass.md
{{#endref}}

## Static Analysis

Pre svega, za analizu APK-a treba **pogledati Java kod** koristeći dekompajler.\
Molimo, [**pročitaj ovde za informacije o različitim dostupnim dekompajlerima**](apk-decompilers.md).

### Looking for interesting Info

Samo pregledom **strings** APK-a možete tražiti **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** i sve što je zanimljivo... proverite čak i za code execution **backdoors** ili authentication backdoors (hardcoded admin credentials u aplikaciji).

**Firebase**

Obratite posebnu pažnju na **Firebase URLs** i proverite da li je loše konfigurisan. [Više informacija o tome šta je Firebase i kako ga eksploatisati ovde.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Basic understanding of the application - Manifest.xml, strings.xml

**Pregled _Manifest.xml_ i **_strings.xml_** fajlova aplikacije može otkriti potencijalne sigurnosne ranjivosti**. Ovi fajlovi se mogu pristupiti pomoću dekompajlera ili preimenovanjem APK fajla u .zip i raspakivanjem.

**Vulnerabilities** koje se mogu identifikovati iz **Manifest.xml** uključuju:

- **Debuggable Applications**: Aplikacije koje su označene kao debuggable (`debuggable="true"`) u _Manifest.xml_ predstavljaju rizik jer omogućavaju konekcije koje mogu dovesti do eksploatacije. Za dalje razumevanje kako eksploatisati debuggable aplikacije, pogledajte tutorijal o pronalaženju i eksploataciji debuggable aplikacija na uređaju.
- **Backup Settings**: `android:allowBackup="false"` treba eksplicitno postaviti za aplikacije koje rade sa osetljivim informacijama kako bi se sprečio neautorizovan backup podataka putem adb, posebno kada je usb debugging omogućen.
- **Network Security**: Custom network security konfiguracije (`android:networkSecurityConfig="@xml/network_security_config"`) u _res/xml/_ mogu specificirati bezbednosne detalje poput certificate pins i HTTP saobraćaja. Primer je dozvoljavanje HTTP saobraćaja za određene domene.
- **Exported Activities and Services**: Identifikovanje exported activities i services u manifestu može ukazati na komponente koje bi mogle biti zloupotrebljene. Dalja analiza tokom dynamic testing-a može otkriti kako eksploatisati ove komponente.
- **Content Providers and FileProviders**: Eksponirani content providers mogu omogućiti neautorizovan pristup ili modifikaciju podataka. Treba detaljno proveriti i konfiguraciju FileProviders.
- **Broadcast Receivers and URL Schemes**: Ove komponente se mogu iskoristiti za eksploataciju, sa posebnim akcentom na način upravljanja URL schemes za input ranjivosti.
- **SDK Versions**: `minSdkVersion`, `targetSDKVersion`, i `maxSdkVersion` atributi ukazuju na podržane Android verzije, naglašavajući važnost da se ne podržavaju zastarele, ranjive Android verzije iz bezbednosnih razloga.

Iz **strings.xml** fajla može se otkriti osetljive informacije kao što su API keys, custom schemas i druge developer napomene, što naglašava potrebu za pažljivim pregledom ovih resursa.

### Tapjacking

**Tapjacking** je napad gde se zlonamerna **aplikacija** pokrene i **pozicionira preko žrtvine aplikacije**. Kada vizuelno zakloni žrtvinu aplikaciju, njen UI je dizajniran tako da prevari korisnika da interaguje sa njom, dok zapravo prosleđuje interakciju žrtvinoj aplikaciji.\
U suštini, to **sledi da korisnik ne zna da zapravo izvršava akcije na žrtvinoj aplikaciji**.

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Activity sa `launchMode` podešenim na `singleTask` bez definisanog `taskAffinity` je ranjiva na Task Hijacking. To znači da se zlonamerna **aplikacija** može instalirati i, ako se pokrene pre prave aplikacije, može **hijack-ovati task prave aplikacije** (tako da će korisnik interagovati sa zlonamernom aplikacijom misleći da koristi pravu).

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Insecure data storage

**Internal Storage**

U Androidu, fajlovi **smešteni** u **internal** storage su **dizajnirani** da budu dostupni isključivo aplikaciji koja ih je **kreirala**. Ova mera bezbednosti se **sprovodi** od strane Android OS-a i obično je adekvatna za potrebe većine aplikacija. Ipak, developeri ponekad koriste mode-e kao što su `MODE_WORLD_READABLE` i `MODE_WORLD_WRITABLE` da bi **dozvolili** deljenje fajlova između različitih aplikacija. Međutim, ovi mode-i **ne ograničavaju pristup** tim fajlovima od strane drugih aplikacija, uključujući potencijalno zlonamerne.

1. **Static Analysis:**
- **Proveriti** upotrebu `MODE_WORLD_READABLE` i `MODE_WORLD_WRITABLE`. Ovi mode-i **mogu potencijalno izložiti** fajlove nepredviđenom ili neautorizovanom pristupu.
2. **Dynamic Analysis:**
- **Verifikovati** permisije postavljene na fajlovima koje kreira aplikacija. Konkretno, **proveriti** da li su neki fajlovi podešeni da budu čitljivi ili upisivi worldwide. Ovo može predstavljati značajan bezbednosni rizik, jer bi omogućilo **bilo kojoj aplikaciji** instaliranoj na uređaju, bez obzira na poreklo ili nameru, da **čitaju ili modifikuju** te fajlove.

**External Storage**

Kod rukovanja fajlovima na **external storage**, kao što su SD karte, treba preduzeti određene mere:

1. **Accessibility**:
- Fajlovi na external storage su **globalno čitljivi i upisivi**. To znači da svaka aplikacija ili korisnik može pristupiti tim fajlovima.
2. **Security Concerns**:
- S obzirom na lak pristup, preporučuje se **ne čuvati osetljive informacije** na external storage.
- External storage može biti uklonjen ili mu može pristupiti bilo koja aplikacija, što ga čini manje sigurnim.
3. **Handling Data from External Storage**:
- Uvek **izvršiti validaciju input-a** za podatke povučene sa external storage. Ovo je ključno jer podaci potiču iz nepouzdanog izvora.
- Ne preporučuje se skladištenje izvršnih fajlova ili class fajlova na external storage za dinamičko učitavanje.
- Ako aplikacija mora da učitava izvršne fajlove sa external storage, osigurajte da su ti fajlovi **potpisani i kriptografski verifikovani** pre dinamičkog učitavanja. Ovaj korak je ključan za održavanje bezbednosnog integriteta aplikacije.

External storage može biti **accessed** u `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> Počevši od Android 4.4 (**API 17**), SD kartica ima strukturu direktorijuma koja **ograničava pristup aplikaciji samo na direktorijum koji je specifičan za tu aplikaciju**. Ovo sprečava zlonamerne aplikacije da dobiju read ili write pristup fajlovima druge aplikacije.

**Sensitive data stored in clear-text**

- **Shared preferences**: Android dozvoljava svakoj aplikaciji da lako čuva xml fajlove u putanji `/data/data/<packagename>/shared_prefs/` i ponekad je moguće naći osetljive informacije u clear-text u tom folderu.
- **Databases**: Android dozvoljava svakoj aplikaciji da lako čuva sqlite databases u putanji `/data/data/<packagename>/databases/` i ponekad je moguće naći osetljive informacije u clear-text u tom folderu.

### Broken TLS

**Accept All Certificates**

Iz nekog razloga, ponekad developeri prihvataju sve sertifikate čak i kada, na primer, hostname ne odgovara, sa linijama koda kao u sledećem primeru:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Dobar način da se ovo testira je pokušaj presretanja saobraćaja pomoću proxy-ja kao što je Burp bez autorizovanja Burp CA unutar uređaja. Takođe, možete generisati u Burp-u sertifikat za drugi hostname i koristiti ga.

### Neispravna kriptografija

**Loši procesi upravljanja ključevima**

Neki developeri čuvaju osetljive podatke u lokalnoj memoriji i šifruju ih ključem hardkodiranim/predvidivim u kodu. To ne bi trebalo raditi jer reverzno inženjerstvo može omogućiti napadačima da izvuku poverljive informacije.

**Korišćenje nesigurnih i/ili zastarelih algoritama**

Developeri ne bi trebalo da koriste **deprecated algorithms** za izvođenje autorizacionih **checks**, **store** ili **send** podataka. Neki od ovih algoritama su: RC4, MD4, MD5, SHA1... Ako se za čuvanje lozinki koriste **hashes**, treba koristiti hash-ove otporne na brute-force uz salt.

### Other checks

- Preporučuje se da se **obfuscate the APK** kako bi se otežao posao reverznim inženjerima/napadačima.
- Ako je app osetljiva (kao bank apps), trebalo bi da obavi sopstvene provere da li je mobilni uređaj **rooted** i postupi u skladu s tim.
- Ako je app osetljiva (kao bank apps), trebalo bi da proveri da li se koristi **emulator**.
- Ako je app osetljiva (kao bank apps), trebalo bi da **check it's own integrity before executing** da proveri da li je izmenjena.
- Koristite [**APKiD**](https://github.com/rednaga/APKiD) da proverite koji compiler/packer/obfuscator je korišćen za izgradnju APK-a

### React Native Application

Pročitajte sledeću stranicu da naučite kako lako pristupiti javascript kodu React aplikacija:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Pročitajte sledeću stranicu da naučite kako lako pristupiti C# kodu Xamarin aplikacija:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

Prema ovom [**blog postu**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked je Meta algoritam koji kompresuje sadržaj aplikacije u jednu datoteku. Blog govori o mogućnosti kreiranja aplikacije koja dekompresuje ovakve aplikacije... i bržem načinu koji uključuje **izvršavanje aplikacije i prikupljanje dekompresovanih fajlova iz fajl sistema.**

### Automated Static Code Analysis

Alat [**mariana-trench**](https://github.com/facebook/mariana-trench) je sposoban da pronađe **vulnerabilities** skeniranjem **code** aplikacije. Ovaj alat sadrži seriju **known sources** (koji označavaju alatu **places** gde je **input** pod kontrolom korisnika), **sinks** (koji označavaju alatu **dangerous places** gde maliciozni korisnički input može prouzrokovati štetu) i **rules**. Ova pravila označavaju **combination** of **sources-sinks** koja ukazuje na ranjivost.

Sa ovim znanjem, **mariana-trench će pregledati kod i pronaći moguće vulnerabilities u njemu**.

### Secrets leaked

Aplikacija može sadržati secrets (API keys, passwords, hidden urls, subdomains...) unutar koje biste mogli otkriti. Možete koristiti alat kao što je [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)
- In-memory native code execution via JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dinamička analiza

> Prvo, potrebno je okruženje gde možete instalirati aplikaciju i celu okolinu (Burp CA cert, Drozer i Frida pre svega). Zbog toga je preporučljiv root-ovan uređaj (emuliran ili ne).

### Online Dynamic analysis

Možete napraviti **free account** na: [https://appetize.io/](https://appetize.io). Ova platforma vam omogućava da **upload** i **execute** APK-ove, pa je korisna da vidite kako se apk ponaša.

Možete čak **videti logove vaše aplikacije** na webu i povezati se preko **adb**.

![](<../../images/image (831).png>)

Zahvaljujući ADB konekciji možete koristiti **Drozer** i **Frida** unutar emulatora.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (Možete kreirati **x86** i **arm** uređaje, i prema [**ovome** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**najnovije x86** verzije **support ARM libraries** bez potrebe za sporim arm emulatorom).
- Naučite kako da ga podesite na ovoj stranici:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, potrebno je kreirati nalog. _Preporučuje se da **download** verziju **WITH** _**VirtualBox** kako biste izbegli potencijalne greške._)
- [**Nox**](https://es.bignox.com) (Besplatan, ali ne podržava Frida ili Drozer).

> [!TIP]
> Pri kreiranju novog emulatora na bilo kojoj platformi imajte na umu da što je ekran veći, emulator će sporije raditi. Zato izaberite male ekrane ako je moguće.

Da biste **install google services** (kao AppStore) u Genymotion-u potrebno je kliknuti na crveno obeleženo dugme sa sledeće slike:

![](<../../images/image (277).png>)

Takođe, obratite pažnju da u **konfiguraciji Android VM u Genymotion-u** možete izabrati **Bridge Network mode** (ovo će biti korisno ako se povezujete na Android VM sa drugog VM-a koji sadrži alate).

#### Use a physical device

Potrebno je aktivirati **debugging** opcije i bilo bi poželjno da uređaj bude **root-ovan**:

1. **Settings**.
2. (FromAndroid 8.0) Izaberite **System**.
3. Izaberite **About phone**.
4. Pritisnite **Build number** 7 puta.
5. Vratite se nazad i naći ćete **Developer options**.

> Kada instalirate aplikaciju, prvo što treba da uradite je da je probate, istražite šta radi, kako funkcioniše i upoznate se sa njom. Predlažem da **perform this initial dynamic analysis using MobSF dynamic analysis + pidcat**, tako da ćemo moći da **learn how the application works** dok MobSF **captures** puno **interesting** **data** koje možete kasnije pregledati.

Magisk/Zygisk quick notes (preporučeno na Pixel uređajima)
- Patch boot.img with the Magisk app and flash via fastboot to get systemless root
- Enable Zygisk + DenyList for root hiding; consider LSPosed/Shamiko when stronger hiding is required
- Keep original boot.img to recover from OTA updates; re-patch after each OTA
- For screen mirroring, use scrcpy on the host

### Unintended Data Leakage

**Logging**

Developeri bi trebalo da budu oprezni sa izlaganjem **debugging information** javno, jer to može dovesti do curenja osetljivih podataka. Alati [**pidcat**](https://github.com/JakeWharton/pidcat) i `adb logcat` su preporučeni za praćenje logova aplikacije kako biste identifikovali i zaštitili osetljive informacije. **Pidcat** je popularan zbog jednostavnosti korišćenja i čitljivosti.

> [!WARNING]
> Imajte na umu da od **anka novijih verzija od Android 4.0**, **aplikacije mogu pristupiti samo svojim logovima**. Dakle aplikacije ne mogu čitati logove drugih aplikacija.\
> U svakom slučaju, i dalje se preporučuje **ne logovati osetljive informacije**.

**Copy/Paste Buffer Caching**

Android-ov **clipboard-based** framework omogućava funkcionalnost kopiranja/lepljenja u aplikacijama, ali predstavlja rizik jer **druge aplikacije** mogu **access** clipboard i potencijalno otkriti osetljive podatke. Važno je **disable copy/paste** funkcije za osetljive delove aplikacije, poput podataka o kreditnim karticama, kako biste sprečili leak.

**Crash Logs**

Ako aplikacija **crashes** i **saves logs**, ti logovi mogu pomoći napadačima, posebno kada aplikacija ne može da se reverzno inženjerski analizira. Da biste umanjili rizik, izbegavajte logovanje pri padovima, i ako se logovi moraju slati preko mreže, obezbedite da se šalju preko SSL kanala.

Kao pentester, **pokušajte da pogledate ove logove**.

**Analytics Data Sent To 3rd Parties**

Aplikacije često integrišu servise poput Google Adsense, što može nenamerno dovesti do curenja osetljivih podataka usled nepravilne implementacije od strane developera. Da biste identifikovali potencijalna curenja podataka, preporučljivo je **intercept aplikacioni saobraćaj** i proveriti da li se osetljivi podaci šalju trećim stranama.

### SQLite DBs

Većina aplikacija će koristiti **internal SQLite databases** za čuvanje informacija. Tokom pentesta pregledajte **databases** koje su kreirane, imena **tables** i **columns** i sve sačuvane **data** jer možete naći **osetljive informacije** (što bi predstavljalo ranjivost).\
Baze bi trebalo da se nalaze u `/data/data/the.package.name/databases` kao `/data/data/com.mwr.example.sieve/databases`

Ako baza čuva poverljive informacije i encrypt-ovana je ali možete **pronaći** lozinku unutar aplikacije, to je i dalje ranjivost.

Enumerišite tabele koristeći `.tables` i enumerišite kolone tabele koristeći `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

Iz [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** vam omogućava da **assume the role of an Android app** i komunicirate sa drugim aplikacijama. Može raditi **anything that an installed application can do**, kao što je koristiti Android-ov Inter-Process Communication (IPC) mehanizam i komunicirati sa underlying operating system-om. .\
Drozer je koristan alat za **exploit exported activities, exported services and Content Providers** kao što ćete naučiti u sledećim sekcijama.

### Eksploatisanje eksportovanih aktivnosti

[**Pročitajte ovo ako želite da osvežite šta je Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Takođe, zapamtite da kod aktivnosti počinje u metodi **`onCreate`**.

**Authorisation bypass**

Kada je Activity eksportovana, možete pozvati njen ekran iz spoljne aplikacije. Dakle, ako je aktivnost sa **sensitive information** **exported**, mogli biste **bypass-ovati** mehanizme **authentication** da joj pristupite.

[**Naučite kako eksploatisati exported activities pomoću Drozer-a.**](drozer-tutorial/index.html#activities)

Takođe možete pokrenuti exportovanu aktivnost iz adb-a:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NAPOMENA**: MobSF će detektovati kao malicioznu upotrebu _**singleTask/singleInstance**_ kao `android:launchMode` u activity-ju, ali zbog [ovog](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), izgleda da je ovo opasno samo na starijim verzijama (API verzije < 21).

> [!TIP]
> Imajte na umu da authorisation bypass nije uvek ranjivost — zavisi od načina na koji bypass funkcioniše i koje informacije su izložene.

**Propuštanje osetljivih informacija**

**Aktivnosti takođe mogu vraćati rezultate**. Ako uspete da pronađete exported i nezaštićeni activity koji poziva metodu **`setResult`** i **vraća osetljive informacije**, dolazi do propuštanja osetljivih informacija.

#### Tapjacking

Ako Tapjacking nije sprečen, možete zloupotrebiti exported activity da naterate **korisnika da izvrši neočekivane radnje**. Za više informacija o [**šta je Tapjacking, pogledajte link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Pročitajte ovo ako želite da se podsetite šta je Content Provider.**](android-applications-basics.md#content-provider)\
Content providers se uglavnom koriste za **deljenje podataka**. Ako aplikacija ima dostupne content providere, možda ćete moći da **izvučete osetljive** podatke iz njih. Takođe je interesantno testirati moguće **SQL injections** i **Path Traversals** jer mogu biti ranjivi.

[**Saznajte kako eksploatisati Content Providers pomoću Drozer-a.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Pročitajte ovo ako želite da se podsetite šta je Service.**](android-applications-basics.md#services)\
Zapamtite da akcije Service-a počinju u metodi `onStartCommand`.

Service je u suštini nešto što **može primati podatke**, **obrađivati** ih i **vraćati** (ili ne) odgovor. Dakle, ako aplikacija eksportuje neke servise, treba da **proverite** **kod** da biste razumeli šta radi i da ga **testirate** **dinamički** radi izvlačenja poverljivih informacija, bypassing authentication measures...\
[**Saznajte kako eksploatisati Services pomoću Drozer-a.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Pročitajte ovo ako želite da se podsetite šta je Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Zapamtite da akcije Broadcast Receiver-a počinju u metodi `onReceive`.

Broadcast receiver će čekati određenu vrstu poruke. U zavisnosti od načina na koji receiver obrađuje poruku, može biti ranjiv.\
[**Saznajte kako eksploatisati Broadcast Receivers pomoću Drozer-a.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Možete tražiti deep links ručno, koristeći alate kao MobSF ili skripte kao [ovu](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Možete **otvoriti** deklarisani **scheme** koristeći **adb** ili **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Imajte na umu da možete **izostaviti ime paketa** i mobilni uređaj će automatski pozvati aplikaciju koja treba da otvori tu vezu._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Kod koji će se izvršiti**

Da biste pronašli **kod koji će se izvršiti u aplikaciji**, idite na activity koji je pozvan deeplink-om i potražite funkciju **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Osetljive informacije**

Svaki put kada pronađete deep link, proverite da li **ne prima osetljive podatke (kao što su lozinke) putem URL parametara**, jer bilo koja druga aplikacija može **lažno se predstaviti kao deep link i ukrasti te podatke!**

**Parametri u putanji**

Takođe **morate proveriti da li neki deep link koristi parametar unutar putanje** URL-a kao, na primer: `https://api.example.com/v1/users/{username}`, u tom slučaju možete forsirati path traversal pristupom nečemu poput: `example://app/users?username=../../unwanted-endpoint%3fparam=value`.\
Obratite pažnju da ako pronađete odgovarajuće endpoint-e unutar aplikacije, možete izazvati **Open Redirect** (ako se deo putanje koristi kao domain name), **account takeover** (ako možete izmeniti detalje korisnika bez CSRF tokena i ranjivi endpoint koristi odgovarajući metod) i bilo koju drugu vuln. Više [informacija o ovome](http://dphoeniixx.com/2020/12/13-2/).

**Još primera**

Zanimljiv [bug bounty izveštaj](https://hackerone.com/reports/855618) o linkovima (_/.well-known/assetlinks.json_).

### Inspekcija transportnog sloja i greške verifikacije

- **Sertifikati nisu uvek pravilno proveravani** od strane Android aplikacija. Često ove aplikacije zanemare upozorenja i prihvate samopotpisane sertifikate ili, u nekim slučajevima, pređu na korišćenje HTTP konekcija.
- **Pregovori tokom SSL/TLS handshake-a ponekad su slabi**, koristeći nesigurne cipher suite-ove. Ova ranjivost čini konekciju podložnom man-in-the-middle (MITM) napadima, omogućavajući napadačima da dešifruju podatke.
- **Curеnje privatnih informacija** predstavlja rizik kada se aplikacije autentifikuju koristeći sigurni kanal, ali zatim komuniciraju preko nesigurnih kanala za druge transakcije. Ovakav pristup ne štiti osetljive podatke, kao što su session cookies ili podaci o korisniku, od presretanja od strane zlonamernih entiteta.

#### Verifikacija sertifikata

Usredsredićemo se na **verifikaciju sertifikata**. Integritet sertifikata servera mora biti verifikovan kako bi se poboljšala bezbednost. Ovo je ključno jer nesigurne TLS konfiguracije i prenos osetljivih podataka preko nekriptovanih kanala predstavljaju značajne rizike. Za detaljne korake o verifikaciji server sertifikata i otklanjanju ranjivosti, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) pruža sveobuhvatne smernice.

#### SSL Pinning

SSL Pinning je bezbednosna mera gde aplikacija verifikuje serverov sertifikat u odnosu na poznatu kopiju sačuvanu unutar same aplikacije. Ova metoda je bitna za sprečavanje MITM napada. Preporučuje se implementacija SSL Pinning-a za aplikacije koje rukuju osetljivim informacijama.

#### Inspekcija saobraćaja

Da biste pregledali HTTP saobraćaj, neophodno je **instalirati sertifikat proxy alata** (npr. Burp). Bez instalacije tog sertifikata, šifrovani saobraćaj možda neće biti vidljiv kroz proxy. Za vodič o instalaciji custom CA sertifikata, [**kliknite ovde**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Aplikacije koje ciljaju **API Level 24 and above** zahtevaju izmene u Network Security Config kako bi prihvatile CA sertifikat proxy-a. Ovaj korak je kritičan za inspekciju šifrovanog saobraćaja. Za instrukcije o modifikaciji Network Security Config-a, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

Ako se koristi **Flutter**, potrebno je pratiti uputstva na [**ovoj strani**](flutter.md). Razlog je što samo dodavanje sertifikata u store neće raditi jer Flutter ima sopstvenu listu validnih CAs.

#### Statička detekcija SSL/TLS pinning

Pre nego što pokušate runtime bypass-ove, brzo mapirajte gde je pinning primenjen u APK-u. Statičko otkrivanje pomaže da planirate hooks/patches i fokusirate se na prave kodne puteve.

Tool: SSLPinDetect
- Open-source static-analysis utility that decompiles the APK to Smali (via apktool) and scans for curated regex patterns of SSL/TLS pinning implementations.
- Reports exact file path, line number, and a code snippet for each match.
- Covers common frameworks and custom code paths: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Korišćenje
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Primer pattern pravila (JSON)
Koristite ili proširite signatures da biste otkrili proprietary/custom pinning styles. Možete učitati sopstveni JSON i scan at scale.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Napomene i saveti
- Brzo skeniranje velikih aplikacija pomoću višestrukih niti (multi-threading) i memory-mapped I/O; prekompajlirani regex smanjuje režiju i lažno pozitivne rezultate.
- Kolekcija patterna: https://github.com/aancw/smali-sslpin-patterns
- Tipični ciljevi za sledeću proveru:
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Deklarativne pins u res/xml network security config i reference u manifestu
- Koristite podudaranja lokacija da isplanirate Frida hooks, static patches, ili pregled konfiguracija pre dinamičkog testiranja.



#### Zaobilaženje SSL Pinning

Kada je SSL Pinning implementiran, njegovo zaobilaženje postaje neophodno za inspekciju HTTPS saobraćaja. Za ovo postoje razne metode:

- Automatski **izmenite** **apk** da **zaobiđete** SSLPinning pomoću [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Najveća prednost ove opcije je što vam neće trebati root da zaobiđete SSL Pinning, ali ćete morati obrisati aplikaciju i ponovo instalirati izmenjenu verziju, i to ne funkcioniše uvek.
- Možete koristiti **Frida** (opisano niže) da zaobiđete ovu zaštitu. Ovde je vodič za korišćenje Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Takođe možete pokušati da **automatski zaobiđete SSL Pinning** koristeći [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Takođe možete pokušati da **automatski zaobiđete SSL Pinning** koristeći **MobSF dynamic analysis** (objašnjeno niže)
- Ako mislite da i dalje postoji saobraćaj koji ne hvatate, možete pokušati proslediti saobraćaj ka Burp-u koristeći iptables. Pročitajte ovaj blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Potraga za uobičajenim web ranjivostima

Važno je takođe pretražiti aplikaciju zbog uobičajenih web ranjivosti. Detaljne informacije o identifikaciji i ublažavanju ovih ranjivosti su izvan opsega ovog sažetka, ali su široko pokrivene na drugim mestima.

### Frida

[Frida](https://www.frida.re) je alat za dinamičku instrumentaciju namenjen developerima, reverse-engineerima i istraživačima bezbednosti.\
**Možete pristupiti pokrenutoj aplikaciji i hook-ovati metode u runtime-u da promenite ponašanje, menjate vrednosti, izvučete vrednosti, pokrenete drugi kod...**\
Ako želite pentest Android aplikacije, morate znati kako da koristite Frida.

- Naučite kako da koristite Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Neki "GUI" za rad sa Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection je odličan za automatizaciju korišćenja Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Možete pronaći neke Awesome Frida skripte ovde: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Pokušajte zaobići anti-debugging / anti-frida mehanizme učitavanjem Fride kako je naznačeno u [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation i workflow za zaobilaženje SSL pinning-a

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump memorije - Fridump**

Proverite da li aplikacija čuva osetljive informacije u memoriji koje ne bi trebalo, poput lozinki ili mnemonika.

Koristeći [**Fridump3**](https://github.com/rootbsd/fridump3) možete dump-ovati memoriju aplikacije sa:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Ovo će dump memoriju u ./dump folder, i tamo možete koristiti grep sa nečim poput:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Osetljivi podaci u Keystore**

Na Androidu je Keystore najbolje mesto za čuvanje osetljivih podataka, međutim, uz dovoljne privilegije i dalje je **moguće pristupiti njemu**. Pošto aplikacije obično ovde čuvaju **osetljive podatke u običnom tekstu**, pentests bi trebalo da provere to kao root korisnik, jer neko sa fizičkim pristupom uređaju može da ukrade te podatke.

Čak i ako aplikacija skladišti podatke u Keystore, podaci bi trebalo da budu šifrovani.

Za pristup podacima unutar Keystore-a možete koristiti ovaj Frida script: https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Koristeći sledeći Frida script, moguće je **bypass fingerprint authentication** koje Android aplikacije mogu koristiti kako bi **zaštitile određena osetljiva područja:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Pozadinske slike**

Kada aplikaciju pošaljete u pozadinu, Android sačuva **snimak aplikacije** tako da, kada se vrati u prvi plan, počne da učitava tu sliku pre same aplikacije kako bi izgledalo da se aplikacija brže učitala.

Međutim, ako taj snimak sadrži **osetljive informacije**, neko ko ima pristup snimku može **ukrasti te informacije** (napomena: za pristup je potreban root).

Snimci su obično smešteni na: **`/data/system_ce/0/snapshots`**

Android nudi način da se **spreči pravljenje snimaka ekrana postavljanjem FLAG_SECURE layout parametra**. Korišćenjem ovog flag-a, sadržaj prozora se tretira kao siguran, što sprečava njegovo pojavljivanje na snimcima ekrana ili pregled na nesigurnim prikazima.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Ovaj alat može pomoći u upravljanju različitim alatima tokom dynamic analysis: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Programeri često kreiraju proxy komponente poput activities, services i broadcast receivers koje obrađuju ove Intente i prosleđuju ih metodama kao što su `startActivity(...)` ili `sendBroadcast(...)`, što može biti rizično.

Opasnost leži u omogućavanju napadačima da pokrenu non-exported app components ili pristupe osetljivim content providers preusmeravanjem ovih Intenta. Značajan primer je `WebView` komponenta koja konvertuje URL-ove u `Intent` objekte preko `Intent.parseUri(...)` i zatim ih izvršava, što može dovesti do malicioznih Intent injections.

### Ključni zaključci

- **Intent Injection** je sličan web problemu Open Redirect.
- Eksploati uključuju prosleđivanje `Intent` objekata kao extras, koji mogu biti preusmereni da izvrše nesigurne operacije.
- Može izložiti non-exported komponente i content providers napadačima.
- Konverzija URL-a u `Intent` od strane `WebView`-a može omogućiti neželjene akcije.

### Android Client Side Injections and others

Verovatno poznajete ovaj tip ranjivosti sa weba. Posebno treba biti oprezan sa ovim ranjivostima u Android aplikaciji:

- **SQL Injection:** Prilikom rada sa dinamičkim upitima ili Content-Providers obezbedite upotrebu parametrizovanih upita.
- **JavaScript Injection (XSS):** Proverite da li je JavaScript i Plugin podrška onemogućena za sve WebViews (po defaultu onemogućeno). [Više informacija](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews bi trebalo da imaju pristup fajl sistemu onemogućen (po defaultu omogućen) - `(webview.getSettings().setAllowFileAccess(false);)`. [Više informacija](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: U nekoliko slučajeva, kada android aplikacija završi sesiju, cookie nije opozvan ili može biti sačuvan na disku
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatska analiza

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Statička analiza**

![](<../../images/image (866).png>)

**Procena ranjivosti aplikacije** koristeći lep web interfejs. Takođe možete izvesti dinamičku analizu (ali je potrebno pripremiti okruženje).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows aplikacije moraju biti analizirane sa MobSF instaliranim na Windows hostu_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Assisted Dynamic analysis with MobSF

**MobSF** can also be very helpful for **dynamic analysis** in **Android**, but in that case you will need to install MobSF and **genymotion** in your host (a VM or Docker won't work). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
The **MobSF dynamic analyser** can:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). Sve ovo se radi automatski osim za screenshot-ove — morate pritisnuti kada želite snimak ekrana ili pritisnuti "**Exported Activity Tester**" da dobijete screenshot-ove svih exported activities.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Frida scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: Ispisuje sve učitane klase
- **Capture Strings**: Ispisuje sve uhvaćene stringove tokom korišćenja aplikacije (veoma bučno)
- **Capture String Comparisons**: Može biti veoma korisno. Prikazaće dva stringa koja se porede i da li je rezultat True ili False.
- **Enumerate Class Methods**: Unesite ime klase (npr. "java.io.File") i ispiše sve metode te klase.
- **Search Class Pattern**: Pretražuje klase po obrascu
- **Trace Class Methods**: Trace celu klasu (vidite ulaze i izlaze svih metoda te klase). Zapamtite da MobSF po defaultu prati nekoliko interesantnih Android Api metoda.

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

MobSF takođe donosi shell sa nekim **adb** komandama, **MobSF commands**, i uobičajenim **shell** **commands** pri dnu stranice za dynamic analysis. Neke interesantne komande:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP alati**

Kada je HTTP saobraćaj capture-ovan možete videti ružan prikaz uhvaćenog saobraćaja na dugmetu "**HTTP(S) Traffic**" ili lepši prikaz na zelenom dugmetu "**Start HTTPTools**". Iz druge opcije možete **send** the **captured requests** to **proxies** kao što su Burp ili Owasp ZAP.\
Da biste to uradili, _power on Burp -->_ _turn off Intercept --> u MobSB HTTPTools izaberite request_ --> pritisnite "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Kada završite the dynamic analysis with MobSF možete pritisnuti "**Start Web API Fuzzer**" da biste fuzz http requests i tražili ranjivosti.

> [!TIP]
> Nakon što izvršite a dynamic analysis with MobSF, proxy podešavanja mogu biti pogrešno konfigurisana i nećete ih moći popraviti iz GUI-ja. Možete popraviti proxy podešavanja tako što ćete izvršiti:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

Alat možete preuzeti sa [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Ovaj alat koristi neke **Hooks** da bi vam pokazao **what is happening in the application** dok izvodite **dynamic analysis**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Ovo je **great tool to perform static analysis with a GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Ovaj alat je dizajniran da traži više **security related Android application vulnerabilities**, bilo u **source code** ili **packaged APKs**. Alat je takođe **capable of creating a "Proof-of-Concept" deployable APK** i **ADB commands**, da bi iskoristio neke od pronađenih ranjivosti (Exposed activities, intents, tapjacking...). Kao i kod Drozer, nema potrebe da root-ujete test uređaj.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Prikazuje sve izvađene datoteke radi lakšeg pregleda
- Automatski dekompajlira APK datoteke u Java i Smali format
- Analizira AndroidManifest.xml u potrazi za uobičajenim ranjivostima i ponašanjem
- Statička analiza izvornog koda za uobičajene ranjivosti i ponašanja
- Informacije o uređaju
- i više
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER je aplikacija komandne linije koja se može koristiti na Windows, MacOS X i Linux, i koja analizira _.apk_ fajlove u potrazi za ranjivostima. To radi dekompresovanjem APK-ova i primenom niza pravila kako bi otkrila te ranjivosti.

Sva pravila su smeštena u `rules.json` fajlu, i svaka kompanija ili tester može kreirati sopstvena pravila da analizira ono što im je potrebno.

Preuzmite najnovije binarne fajlove sa [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn je **višeplatformski** alat koji pomaže programerima, bugbounty hunters i ethical hackers pri izvođenju [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) na mobilnim aplikacijama.

Koncept je da prevučete i otpustite fajl vaše mobilne aplikacije (.apk ili .ipa) na StaCoAn aplikaciju i ona će generisati vizuelni i prenosivi izveštaj za vas. Možete prilagoditi podešavanja i wordlists da biste dobili prilagođeno iskustvo.

Download[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework je sistem za analizu ranjivosti Androida koji pomaže developers or hackers da pronađu potencijalne bezbednosne ranjivosti u Android aplikacijama.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** je alat čiji je glavni cilj da otkrije i upozori korisnika na potencijalno zlonamerna ponašanja koja razvija Android aplikacija.

Detekcija se vrši statičkom analizom Dalvik bytecode-a aplikacije, predstavljenog kao **Smali**, korišćenjem biblioteke [`androguard`](https://github.com/androguard/androguard).

Ovaj alat traži **uobičajeno ponašanje "loših" aplikacija** kao što su: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** je okvir za reverzno inženjerstvo i analizu mobilnih aplikacija (Mobile Application Reverse engineering and Analysis Framework). Alat je koji objedinjuje često korišćene alate za reverse engineering i analizu mobilnih aplikacija, kako bi pomogao pri testiranju mobilnih aplikacija protiv OWASP mobile security pretnji. Cilj mu je da ovaj zadatak učini lakšim i pristupačnijim za mobile application developere i security profesionalce.

Može da:

- Ekstrahuje Java i Smali kod koristeći različite alate
- Analizira APK-ove koristeći: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Izvlači privatne informacije iz APK-a koristeći regexps.
- Analizira Manifest.
- Analizira pronađene domene koristeći: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuskira APK preko [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Korisno za detekciju malvera: [https://koodous.com/](https://koodous.com/)

## Obfuskacija/Deobfuskacija koda

Imajte na umu da, u zavisnosti od servisa i konfiguracije kojom obfuskirate kod, tajne mogu, ali i ne moraju biti obfuskirane.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

Iz [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** je open source alat iz komandne linije koji smanjuje, optimizuje i obfuskira Java kod. Može optimizovati bytecode kao i detektovati i ukloniti neiskorišćene instrukcije. ProGuard je slobodan softver i distribuira se pod GNU General Public License, verzije 2.

ProGuard se distribuira kao deo Android SDK-a i pokreće se pri izgradnji aplikacije u release režimu.

### [DexGuard](https://www.guardsquare.com/dexguard)

Pronađite vodič korak po korak za deobfuskaciju apk-a u [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(Prema tom vodiču) Poslednji put kad smo proveravali, Dexguard način rada je bio:

- učitava resurs kao InputStream;
- prosleđuje rezultat klasi koja nasleđuje FilterInputStream da ga dekriptuje;
- izvrši neku besmislenu obfuskaciju da bi izgubio par minuta reverzera;
- prosledi dekriptovani rezultat u ZipInputStream da dobije DEX fajl;
- na kraju učitaj dobijeni DEX kao Resource koristeći `loadDex` metodu.

### [DeGuard](http://apk-deguard.com)

**DeGuard poništava proces obfuskacije koji su izvršili Android alati za obfuskaciju. Ovo omogućava brojne sigurnosne analize, uključujući inspekciju koda i predviđanje biblioteka.**

Možete otpremiti obfuskirani APK na njihovu platformu.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

Ovo je LLM alat za pronalaženje potencijalnih sigurnosnih ranjivosti u Android aplikacijama i deobfuskaciju koda Android aplikacija. Koristi Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

To je generički Android deobfusker. Simplify praktično izvršava aplikaciju da bi razumeo njeno ponašanje, a zatim pokušava da optimizuje kod tako da se ponaša identično, ali bude lakši za razumevanje čoveku. Svaka vrsta optimizacije je jednostavna i generička, tako da nije bitno koji je tačno tip obfuskacije korišćen.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD daje informacije o tome kako je APK napravljen. Identifikuje mnoge kompajlere, packere, obfuscators, i druge čudne stvari. To je [_PEiD_](https://www.aldeid.com/wiki/PEiD) za Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b je Android sigurnosna virtuelna mašina zasnovana na ubuntu-mate koja sadrži kolekciju najnovijih framework-a, tutorijala i laboratorija od različitih sigurnosnih entuzijasta i istraživača za reverse engineering i malware analysis.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) To je sjajna lista resursa
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Kratki kurs za Android
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/) Sigurnost Android aplikacija
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
