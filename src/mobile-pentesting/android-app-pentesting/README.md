# Android Applications Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Основи Android-застосунків

It's highly recommended to start reading this page to know about the **most important parts related to Android security and the most dangerous components in an Android application**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Це головний інструмент, який потрібен для підключення до пристрою Android (емулятор або фізичний).\
**ADB** дозволяє керувати пристроями як через **USB**, так і через **Network** з комп'ютера. Ця утиліта дає змогу **копіювати** файли в обидва боки, **інсталювати** та **деінсталювати** apps, **виконувати** shell-команди, **створювати резервні копії** даних, **читати** логи та виконувати інші функції.

Ознайомтесь зі списком [**ADB Commands**](adb-commands.md), щоб дізнатись, як використовувати adb.

## Smali

Інколи буває корисно **змінити код додатку**, щоб отримати доступ до **прихованої інформації** (наприклад, добре обфусковані паролі або flags). У такому випадку може бути доцільно декомпілювати APK, змінити код і перекомпілювати його.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Це може бути дуже корисно як **альтернатива для кількох тестів під час динамічного аналізу**, які будуть представлені. Тож **завжди майте на увазі цю можливість**.

## Інші цікаві трюки

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [Android IME / InputMethodService Abuse (Malicious Keyboards)](inputmethodservice-ime-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Витягти APK з пристрою:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Об'єднайте всі splits і base apks за допомогою [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Android Enterprise & Work Profile Attacks

{{#ref}}
android-enterprise-work-profile-bypass.md
{{#endref}}

## Кейс-дослідження & Вразливості


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

{{#ref}}
abusing-android-media-pipelines-image-parsers.md
{{#endref}}

{{#ref}}
../../binary-exploitation/linux-kernel-exploitation/arm64-static-linear-map-kaslr-bypass.md
{{#endref}}

## Статичний аналіз

По-перше, для аналізу APK слід **переглянути Java-код** за допомогою декомпілятора.\
Будь ласка, [**прочитайте тут, щоб знайти інформацію про різні доступні decompilers**](apk-decompilers.md).

### Пошук цікавої інформації

Просто переглянувши **strings** APK, ви можете шукати **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** та все, що здається цікавим... перевіряйте також на наявність code execution **backdoors** або authentication backdoors (hardcoded admin credentials to the app).

**Firebase**

Зверніть особливу увагу на **firebase URLs** та перевірте, чи не неправильно воно налаштоване. [Більше інформації про те, що таке Firebase і як це експлуатувати тут.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Базове розуміння додатку - Manifest.xml, strings.xml

Дослідження файлів додатку _Manifest.xml_ та **_strings.xml_** може виявити потенційні проблеми безпеки. До цих файлів можна отримати доступ за допомогою декомпіляторів або перейменувавши розширення APK на .zip та розпаковуючи файл.

Вразливості, виявлені в **Manifest.xml**, включають:

- **Debuggable Applications**: додатки, зазначені як debuggable (`debuggable="true"`) у _Manifest.xml_, становлять ризик, оскільки дозволяють підключення, що може призвести до експлуатації. Для детальнішого розуміння того, як використовувати debuggable додатки, дивіться посібник з пошуку та експлуатації debuggable додатків на пристрої.
- **Backup Settings**: атрибут `android:allowBackup="false"` слід явно вказувати для додатків, що працюють з чутливою інформацією, щоб запобігти несанкціонованому резервному копіюванню даних через adb, особливо коли увімкнено usb debugging.
- **Network Security**: користувацькі конфігурації безпеки мережі (`android:networkSecurityConfig="@xml/network_security_config"`) у _res/xml/_ можуть визначати такі деталі безпеки, як certificate pins та налаштування HTTP трафіку. Наприклад, це може дозволяти HTTP трафік для певних доменів.
- **Exported Activities and Services**: виявлення exported activities та services у манифесті може показати компоненти, які можуть бути зловживані. Подальший аналіз під час динамічного тестування може показати, як експлуатувати ці компоненти.
- **Content Providers and FileProviders**: відкриті content providers можуть дозволити несанкціонований доступ або зміну даних. Також слід уважно перевірити конфігурацію FileProviders.
- **Broadcast Receivers and URL Schemes**: ці компоненти можуть бути використані для експлуатації, з особливою увагою до того, як обробляються URL schemes і вхідні дані.
- **SDK Versions**: атрибути `minSdkVersion`, `targetSDKVersion` та `maxSdkVersion` вказують на підтримувані версії Android, підкреслюючи важливість не підтримувати застарілі, вразливі версії Android з міркувань безпеки.

З файлу **strings.xml** можна виявити чутливу інформацію, таку як API keys, custom schemas та інші нотатки розробників, що підкреслює необхідність ретельного перегляду цих ресурсів.

### Tapjacking

**Tapjacking** — атака, коли **malicious** **application** запускається і **розміщується зверху жертви додатку**. Коли воно візуально закриває додаток-жертву, його інтерфейс спроектовано так, щоб обдурити користувача і змусити його взаємодіяти з ним, при цьому події передаються додатку-жертві.\
Фактично, це **осліплює користувача, і він не розуміє, що фактично виконує дії в додатку-жертві**.

Детальніше дивіться у:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Activity з **`launchMode`**, встановленим у **`singleTask` без визначеного `taskAffinity`**, вразлива до Task Hijacking. Це означає, що **додаток** може бути встановлений і, якщо його запустити раніше ніж реальний додаток, він може **перехопити task реального додатку** (тому користувач буде взаємодіяти з **malicious application**, думаючи, що використовує справжній).

Більше інформації:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Ненадійне зберігання даних

Internal Storage

У Android файли, що зберігаються у внутрішньому сховищі, призначені для доступу виключно додатком, який їх створив. Цей механізм забезпечується операційною системою Android і зазвичай адекватний для потреб безпеки більшості додатків. Однак розробники інколи використовують режими, такі як `MODE_WORLD_READABLE` та `MODE_WORLD_WRITABLE`, щоб дозволити шаринг файлів між різними додатками. Ці режими не обмежують доступ до файлів іншими додатками, включаючи потенційно шкідливі.

1. **Статичний аналіз:**
- **Переконайтеся**, що використання `MODE_WORLD_READABLE` та `MODE_WORLD_WRITABLE` ретельно перевірено. Ці режими **можуть** дозволяти несанкціонований доступ до файлів.
2. **Динамічний аналіз:**
- **Перевірте** права доступу до файлів, створених додатком. Зокрема, **перевірте**, чи які-небудь файли **не встановлені як доступні для читання або запису всім**. Це може становити значний ризик безпеки, оскільки **будь-який додаток**, встановлений на пристрої, незалежно від походження чи намірів, зможе **читати або змінювати** ці файли.

External Storage

При роботі з файлами на **external storage**, наприклад SD Cards, слід врахувати певні запобіжні заходи:

1. **Доступність**:
- Файли на external storage є **загальнодоступними для читання та запису**. Це означає, що будь-який додаток або користувач може отримати доступ до цих файлів.
2. **Проблеми безпеки**:
- Через простоту доступу не рекомендується **зберігати чутливу інформацію** на external storage.
- External storage може бути вилучено або до нього може отримати доступ будь-який додаток, що робить його менш безпечним.
3. **Обробка даних з External Storage**:
- Завжди **виконуйте валідацію вводу** на даних, отриманих із external storage. Це критично, оскільки дані походять з ненадійного джерела.
- Зберігання виконуваних файлів або class файлів на external storage для динамічного завантаження суворо не рекомендовано.
- Якщо ваш додаток повинен отримувати виконувані файли з external storage, переконайтеся, що ці файли **підписані та криптографічно перевірені** перед динамічним завантаженням. Це важливий крок для збереження цілісності безпеки вашого додатку.

External storage можна **знайти** в /storage/emulated/0 , /sdcard , /mnt/sdcard

> [!TIP]
> Починаючи з Android 4.4 (**API 17**), SD card має структуру директорій, яка **обмежує доступ додатку до директорії, спеціально призначеної для цього додатку**. Це запобігає отриманню шкідливим додатком прав читання або запису файлів іншого додатку.

**Чутливі дані, збережені у відкритому тексті**

- **Shared preferences**: Android дозволяє кожному додатку легко зберігати xml-файли за шляхом /data/data/<packagename>/shared_prefs/ і іноді в цій папці можна знайти чутливу інформацію у відкритому тексті.
- **Databases**: Android дозволяє кожному додатку легко зберігати sqlite databases за шляхом /data/data/<packagename>/databases/ і іноді в цій папці можна знайти чутливу інформацію у відкритому тексті.

### Broken TLS

**Accept All Certificates**

З якоїсь причини іноді розробники приймають усі сертифікати навіть якщо, наприклад, hostname не збігається, використовуючи рядки коду такого вигляду:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Пошкоджена криптографія

**Недостатні процеси управління ключами**

Деякі розробники зберігають чутливі дані в local storage і шифрують їх ключем, захардкоженим/передбачуваним у коді. Так робити не слід, оскільки reversing може дозволити зловмисникам витягти конфіденційну інформацію.

**Використання небезпечних та/або застарілих алгоритмів**

Розробникам не слід використовувати **deprecated algorithms** для виконання авторизаційних **checks**, **store** або **send** даних. До таких алгоритмів належать: RC4, MD4, MD5, SHA1... Якщо, наприклад, для зберігання паролів використовуються **hashes**, слід застосовувати стійкі до brute-force **resistant** хеші з salt.

### Інші перевірки

- Рекомендується **обфускувати APK**, щоб ускладнити reverse engineer роботу для зловмисників.
- Якщо додаток є чутливим (наприклад банківські додатки), він повинен виконувати власні перевірки, щоб визначити, чи мобільний пристрій є **rooted**, і діяти відповідно.
- Якщо додаток є чутливим (наприклад банківські додатки), він повинен перевіряти, чи використовується **emulator**.
- Якщо додаток є чутливим (наприклад банківські додатки), він повинен **перевіряти власну цілісність перед виконанням**, щоб переконатися, що його не було модифіковано.
- Використовуйте [**APKiD**](https://github.com/rednaga/APKiD), щоб перевірити, який compiler/packer/obfuscator було використано для збірки APK

### React Native Application

Прочитайте наступну сторінку, щоб дізнатися, як легко отримати доступ до javascript коду React додатків:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Прочитайте наступну сторінку, щоб дізнатися, як легко отримати доступ до C# коду xamarin додатків:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

Згідно з цим [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked — це Meta алгоритм, який стискає вміст додатку в один файл. У публікації обговорюється можливість створення додатку, який розпаковує такого роду додатки... та швидший спосіб, який полягає у **запуску додатку і зборі розпакованих файлів з filesystem.**

### Automated Static Code Analysis

Інструмент [**mariana-trench**](https://github.com/facebook/mariana-trench) здатний знаходити **vulnerabilities** шляхом **scanning** **code** додатку. Цей інструмент містить набір **known sources** (що вказує інструменту **місця**, де **input** контролюється користувачем), **sinks** (що вказує інструменту **небезпечні** **місця**, де зловмисний ввід користувача може спричинити шкоду) та **rules**. Ці правила визначають **комбінацію** **sources-sinks**, яка вказує на вразливість.

Завдяки цьому **mariana-trench перегляне код і знайде можливі вразливості в ньому**.

### Secrets leaked

Додаток може містити secrets (API keys, passwords, hidden urls, subdomains...) всередині, які ви можете виявити. Ви можете використовувати інструмент, такий як [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Інші цікаві функції

- **Виконання коду**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Відправка SMS**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** оголошені як `native`: `public native, System.loadLibrary, System.load`
- [Прочитайте це, щоб дізнатися, **як reverse native functions**](reversing-native-libraries.md)
- Виконання native коду в пам'яті через JNI (завантажений shellcode → mmap/mprotect → виклик):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> По-перше, вам потрібне середовище, де ви зможете встановити додаток і все оточення (Burp CA cert, Drozer та Frida переважно). Тому strongly recommended використовувати rooted пристрій (емулятор чи реальний).

### Онлайн динамічний аналіз

Ви можете створити **free account** на: [https://appetize.io/](https://appetize.io). Ця платформа дозволяє **upload** та **execute** APKs, тому корисна, щоб побачити, як apk поводиться.

Ви навіть можете **переглядати логи вашого додатку** в вебі та підключитися через **adb**.

![](<../../images/image (831).png>)

Завдяки ADB з'єднанню ви можете використовувати **Drozer** та **Frida** всередині емуляторів.

### Локальний динамічний аналіз

#### Використання емулятора

- [**Android Studio**](https://developer.android.com/studio) (Ви можете створювати **x86** та **arm** пристрої, і згідно з [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** версії **підтримують ARM libraries** без потреби в повільному arm емуляторі).
- Навчіться налаштовувати його на цій сторінці:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, потрібно створити акаунт. _Рекомендується **download** версію **WITH** _**VirtualBox** щоб уникнути потенційних помилок._)
- [**Nox**](https://es.bignox.com) (Free, але не підтримує Frida або Drozer).

> [!TIP]
> При створенні нового emulator на будь-якій платформі пам'ятайте, що чим більший екран, тим повільніше буде працювати емулятор. Тому обирайте менш екрани, якщо це можливо.

Щоб **install google services** (наприклад AppStore) в Genymotion потрібно натиснути на червону позначену кнопку на наступному зображенні:

![](<../../images/image (277).png>)

Також зверніть увагу, що в **configuration of the Android VM in Genymotion** ви можете обрати **Bridge Network mode** (це буде корисно, якщо ви будете підключатися до Android VM з іншої VM з інструментами).

#### Використання фізичного пристрою

Потрібно активувати **debugging** опції і бажано, щоб ви могли **root** його:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Після встановлення додатку перш за все спробуйте ним користуватися, дослідити що він робить, як працює і ознайомитися з ним.\
> Рекомендую **виконати цей початковий динамічний аналіз за допомогою MobSF dynamic analysis + pidcat**, щоб ми могли **дізнатися, як працює додаток**, поки MobSF **capturе** багато **цікавих** **даних**, які ви зможете переглянути пізніше.

Короткі нотатки щодо Magisk/Zygisk (рекомендовано на Pixel пристроях)
- Патчити boot.img за допомогою Magisk app і флешити через fastboot для отримання systemless root
- Увімкнути Zygisk + DenyList для приховування root; розглянути LSPosed/Shamiko для сильнішого приховування
- Зберігати оригінальний boot.img для відновлення після OTA оновлень; повторно патчити після кожного OTA
- Для дзеркалювання екрану використовуйте scrcpy на хості



### Unintended Data Leakage

**Logging**

Розробники мають остерігатися публічного розкриття **debugging information**, оскільки це може призвести до витоку чутливої інформації. Рекомендуються інструменти [**pidcat**](https://github.com/JakeWharton/pidcat) та `adb logcat` для моніторингу логів додатку з метою ідентифікації та захисту чутливої інформації. **Pidcat** віддають перевагу за його простоту використання та зручність читання.

> [!WARNING]
> Зверніть увагу, що починаючи з **пізніших версій Android 4.0**, **додатки можуть отримувати доступ лише до своїх власних логів**. Тому додатки не можуть доступатися до логів інших додатків.\
> В будь-якому випадку, все ще рекомендовано **не логувати чутливу інформацію**.

**Copy/Paste Buffer Caching**

Android-фреймворк на основі **clipboard** дозволяє функціонал копіювання-вставки в додатках, проте несе ризик, оскільки **інші додатки** можуть **access** clipboard і потенційно розкрити чутливі дані. Важливо **відключати copy/paste** функції для чутливих секцій додатку, наприклад даних кредитної картки, щоб запобігти leak.

**Crash Logs**

Якщо додаток **crashes** і **зберігає логи**, ці логи можуть допомогти зловмисникам, особливо коли додаток важко reverse-engineer'ити. Щоб знизити цей ризик, уникайте логування при крашах, а якщо логи все ж мають передаватися мережею — впевніться, що вони відправляються через SSL канал.

Як pentester, **спробуйте переглянути ці логи**.

**Analytics Data Sent To 3rd Parties**

Додатки часто інтегрують сервіси на кшталт Google Adsense, які можуть ненавмисно leak sensitive data через неправильну реалізацію розробниками. Щоб виявити потенційні витоки, доцільно **intercept the application's traffic** і перевірити, чи не відправляється чутлива інформація до сторонніх сервісів.

### SQLite DBs

Більшість додатків використовують **internal SQLite databases** для збереження інформації. Під час pentest перегляньте **databases**, назви **tables** та **columns** і всі **дані**, що зберігаються, оскільки ви можете знайти **чутливу інформацію** (що буде вразливістю).\
Бази даних зазвичай розміщені в `/data/data/the.package.name/databases`, наприклад `/data/data/com.mwr.example.sieve/databases`

Якщо база даних зберігає конфіденційну інформацію і вона **encrypted**, але ви можете **find** **password** всередині додатку — це все одно є **vulnerability**.

Перелічуйте таблиці за допомогою `.tables` і перераховуйте колонки таблиць за допомогою `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

Згідно з [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** дозволяє вам **прикинутися Android app** і взаємодіяти з іншими додатками. Він може робити **все, що може робити встановлений додаток**, наприклад використовувати Android’s Inter-Process Communication (IPC) механізм та взаємодіяти з підлягаючою операційною системою. .\
Drozer — корисний інструмент для **exploit exported activities, exported services and Content Providers**, як ви дізнаєтесь у наступних розділах.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Також пам'ятайте, що код activity починається в методі **`onCreate`**.

**Authorisation bypass**

Коли Activity є exported, ви можете викликати її екран з зовнішнього додатку. Тому, якщо activity з **чутливою інформацією** є **exported**, ви можете **bypass** механізми автентифікації, щоб отримати до неї доступ.

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

Ви також можете запустити exported activity через adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**ПРИМІТКА**: MobSF позначить як шкідливе використання _**singleTask/singleInstance**_ як `android:launchMode` в activity, але згідно з [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), схоже, це небезпечно лише в старих версіях (API versions < 21).

> [!TIP]
> Зауважте, що authorisation bypass не завжди є вразливістю — це залежатиме від того, як працює bypass і яка інформація стає доступною.

**Витік чутливої інформації**

**Activities також можуть повертати результати**. Якщо вам вдасться знайти експортовану та незахищену activity, яка викликає метод **`setResult`** і **повертає чутливу інформацію**, це призводить до витоку чутливої інформації.

#### Tapjacking

Якщо tapjacking не запобігається, ви можете зловживати експортованою activity, щоб змусити **користувача виконувати непередбачувані дії**. Для докладнішої інформації про [**що таке Tapjacking — див. посилання**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Читайте це, якщо хочете освіжити, що таке Content Provider.**](android-applications-basics.md#content-provider)\
Content providers в основному використовуються для **обміну даними**. Якщо у додатку є доступні content providers, ви можете змогти **витягти чутливі** дані з них. Також варто перевіряти можливі **SQL injections** і **Path Traversals**, оскільки вони можуть бути вразливими.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Читайте це, якщо хочете освіжити, що таке Service.**](android-applications-basics.md#services)\
Пам'ятайте, що дії Service починаються в методі `onStartCommand`.

Сервіс по суті може **отримувати дані**, **обробляти** їх і **повертати** (або ні) відповідь. Тому, якщо додаток експортує якісь services, ви повинні **перевірити** **код**, щоб зрозуміти, що він робить, і **тестувати** його **динамічно** для вилучення конфіденційної інформації, bypassing заходів автентифікації...\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Читайте це, якщо хочете освіжити, що таке Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Пам'ятайте, що дії Broadcast Receiver починаються в методі `onReceive`.

Broadcast receiver очікуватиме певного типу повідомлення. Залежно від того, як receiver обробляє повідомлення, він може бути вразливим.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Ви можете шукати deep links вручну, використовуючи інструменти типу MobSF або скрипти, наприклад [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Ви можете **відкрити** оголошену **схему** за допомогою **adb** або **браузера**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Зауважте, що ви можете **omit the package name** і мобільний пристрій автоматично викличе додаток, який має відкрити це посилання._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Код, що виконається**

Щоб знайти **код, який буде виконано в додатку**, перейдіть до activity, яку викликає deeplink, і знайдіть функцію **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Чутлива інформація**

Кожного разу, коли ви знаходите deep link, перевіряйте, що **він не приймає чутливі дані (наприклад, паролі) через URL-параметри**, тому що будь-який інший додаток може **видати себе за deep link і викрасти ці дані!**

**Параметри в шляху**

Ви **також повинні перевірити, чи будь-який deep link використовує параметр всередині шляху** URL, наприклад: `https://api.example.com/v1/users/{username}` , у такому випадку ви можете спричинити path traversal, звернувшись до чогось на кшталт: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Зауважте, що якщо ви знайдете відповідні endpoints всередині додатку, ви можете спричинити **Open Redirect** (якщо частина шляху використовується як домен), **account takeover** (якщо ви можете змінювати дані користувачів без CSRF token і вразливий endpoint використовував правильний метод) та інші вразливості. Більше [інформації тут](http://dphoeniixx.com/2020/12/13-2/).

**Ще приклади**

Цікавий звіт bug bounty про links (_/.well-known/assetlinks.json_).

### Інспекція транспортного рівня та помилки перевірки

- **Certificates are not always inspected properly** Android-додатками. Часто такі додатки ігнорують попередження і приймають self-signed certificates або, в деяких випадках, повертаються до використання HTTP-з'єднань.
- **Negotiations during the SSL/TLS handshake are sometimes weak**, з використанням небезпечних cipher suites. Ця вразливість робить з'єднання вразливим до man-in-the-middle (MITM) атак, дозволяючи зловмисникам розшифровувати дані.
- **Leakage of private information** становить ризик, коли додатки автентифікуються через захищені канали, але потім для інших транзакцій використовують незахищені канали. Такий підхід не захищає чутливі дані, такі як session cookies або відомості про користувача, від перехоплення зловмисниками.

#### Certificate Verification

Ми зосередимося на **перевірці сертифікатів**. Цілісність сертифіката сервера має перевірятися для підвищення безпеки. Це критично, оскільки ненадійні TLS-конфігурації і передача чутливих даних по незашифрованих каналах можуть становити значні ризики. Для детальних кроків з перевірки сертифікатів сервера та виправлення вразливостей [**цей ресурс**](https://manifestsecurity.com/android-application-security-part-10/) надає всебічні рекомендації.

#### SSL Pinning

SSL Pinning — це захід безпеки, коли додаток перевіряє сертифікат сервера проти відомої копії, збереженої в самому додатку. Цей метод важливий для запобігання MITM атак. Рекомендується впроваджувати SSL Pinning для додатків, що обробляють чутливу інформацію.

#### Traffic Inspection

Щоб інспектувати HTTP-трафік, необхідно **встановити сертифікат проксі-інструменту** (наприклад, Burp). Без встановлення цього сертифіката зашифрований трафік може бути невидимим через проксі. Для керівництва з встановлення custom CA certificate, [**натисніть тут**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Додатки, що таргетять **API Level 24 and above**, потребують модифікацій Network Security Config, щоб приймати CA certificate проксі. Цей крок критичний для інспекції зашифрованого трафіку. Для інструкцій щодо модифікації Network Security Config [**зверніться до цього підручника**](make-apk-accept-ca-certificate.md).

Якщо використовується **Flutter**, потрібно виконати інструкції на [**цій сторінці**](flutter.md). Це тому, що просте додавання сертифіката в сховище не спрацює — Flutter має свій власний список дійсних CAs.

#### Static detection of SSL/TLS pinning

Перш ніж намагатися runtime bypasses, швидко визначте, де pinning застосовується в APK. Статичне виявлення допоможе вам спланувати hooks/patches і зосередитись на потрібних кодових шляхах.

Tool: SSLPinDetect
- Open-source утиліта статичного аналізу, яка декомпілює APK до Smali (через apktool) і сканує за кураційними regex-патернами реалізацій SSL/TLS pinning.
- Повертає точний шлях до файлу, номер рядка та фрагмент коду для кожного збігу.
- Охоплює поширені фреймворки та кастомні кодові шляхи: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init з кастомними TrustManagers/KeyManagers, а також Network Security Config XML pins.

Встановлення
- Вимоги: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Використання
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Приклад правил шаблонів (JSON)
Використовуйте або розширюйте signatures, щоб виявляти proprietary/custom pinning styles. Ви можете завантажити власний JSON і виконувати масштабні сканування.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Примітки та поради
- Швидке сканування великих apps через multi-threading і memory-mapped I/O; попередньо скомпільовані regex зменшують накладні витрати/false positives.
- Колекція патернів: https://github.com/aancw/smali-sslpin-patterns
- Типові цілі виявлення для подальшого розгляду:
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Декларативні pins у res/xml network security config та manifest references
- Використовуйте знайдені місця для планування Frida hooks, static patches або config reviews перед dynamic testing.



#### Обхід SSL Pinning

Коли реалізовано SSL Pinning, його обхід стає необхідним для аналізу HTTPS-трафіку. Для цього доступні різні методи:

- Автоматично **змінити** **apk** щоб **обійти** SSLPinning за допомогою [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Найбільша перевага цього варіанту в тому, що вам не потрібен root для обходу SSL Pinning, але доведеться видалити додаток і перевстановити змінений пакет, і це не завжди спрацьовує.
- Ви можете використати **Frida** (описано нижче) для обходу цього захисту. Ось гайд для використання Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Ви також можете спробувати **автоматично обійти SSL Pinning** за допомогою [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Ви також можете спробувати **автоматично обійти SSL Pinning** за допомогою **MobSF dynamic analysis** (описано нижче)
- Якщо ви все ще вважаєте, що частину трафіку ви не перехоплюєте, можна спробувати **перенаправити трафік до burp за допомогою iptables**. Прочитайте цей блог: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Пошук поширених веб-уразливостей

Важливо також шукати поширені веб-уразливості всередині додатку. Детальна інформація про виявлення та пом'якшення цих вразливостей виходить за межі цього резюме, але докладно розглянута в інших джерелах.

### Frida

[Frida](https://www.frida.re) — це набір інструментів для динамічної інструментації для розробників, реверс-інженерів та дослідників безпеки.\
**You can access running application and hook methods on run time to change the behaviour, change values, extract values, run different code...**\
Якщо ви хочете pentest Android applications вам потрібно знати, як використовувати Frida.

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Деякі "GUI" для роботи з Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- You can find some Awesome Frida scripts here: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Спробуйте обійти механізми anti-debugging / anti-frida, завантаживши Frida як показано в [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (інструмент [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Знімання пам'яті - Fridump**

Перевірте, чи додаток не зберігає в пам'яті конфіденційну інформацію, яку не повинен зберігати, наприклад паролі або мнемонічні фрази.

Using [**Fridump3**](https://github.com/rootbsd/fridump3) you can dump the memory of the app with:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Це вивантажить пам'ять у папку ./dump, і там ви можете виконати grep чимось на кшталт:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Чутливі дані в Keystore**

В Android Keystore — найкраще місце для зберігання чутливих даних, однак за наявності достатніх привілеїв все ще **можливо отримати до нього доступ**. Оскільки додатки схильні зберігати тут **чутливі дані у відкритому тексті**, під час pentests слід перевіряти це, оскільки root user або особа з фізичним доступом до пристрою може викрасти ці дані.

Навіть якщо додаток зберіг дані в Keystore, ці дані мають бути зашифровані.

Щоб отримати доступ до даних всередині Keystore, можна використати цей Frida script: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Використовуючи наведений Frida скрипт, можливо **bypass fingerprint authentication**, яку Android applications можуть використовувати для **захисту певних чутливих областей:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Background Images**

Коли ви переводите додаток у фон, Android зберігає **знімок додатка**, щоб при поверненні на передній план він починав завантажувати зображення перед самим додатком, тому здається, що додаток завантажився швидше.

Однак якщо цей знімок містить **чутливу інформацію**, той, хто має доступ до знімка, може **вкрасти цю інформацію** (зауважте, що для доступу потрібен root).

Знімки зазвичай зберігаються тут: **`/data/system_ce/0/snapshots`**

Android надає спосіб **запобігти захопленню скріншотів, встановивши параметр макета FLAG_SECURE**. Використовуючи цей прапорець, вміст вікна позначається як безпечний, що заважає йому з'являтися у скріншотах або переглядатися на небезпечних дисплеях.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Аналізатор Android-додатків**

Цей інструмент може допомогти вам керувати різними інструментами під час динамічного аналізу: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Розробники часто створюють проксі-компоненти, такі як activities, services та broadcast receivers, які обробляють ці Intent і передають їх у методи, такі як `startActivity(...)` або `sendBroadcast(...)`, що може бути ризиковано.

Небезпека полягає в тому, що атакувальникам можна дозволити запускати неекспортовані компоненти додатка або отримувати доступ до чутливих content providers, перенаправивши ці Intent. Помітним прикладом є компонент `WebView`, який перетворює URL на об'єкти `Intent` через `Intent.parseUri(...)` і потім виконує їх, що потенційно призводить до шкідливих Intent injections.

### Essential Takeaways

- **Intent Injection** схоже на вебову проблему Open Redirect.
- Експлойти передбачають передачу об'єктів `Intent` як extras, які можуть бути перенаправлені для виконання небезпечних операцій.
- Це може відкривати неекспортовані компоненти та content providers для атакувальників.
- Перетворення URL у `Intent` у `WebView` може сприяти небажаним діям.

### Android Client Side Injections and others

Напевно ви вже знайомі з цим типом вразливостей з Web. У Android-додатку слід бути особливо обережним із цими вразливостями:

- **SQL Injection:** Під час роботи з динамічними запитами або Content-Providers переконайтеся, що ви використовуєте параметризовані запити.
- **JavaScript Injection (XSS):** Переконайтеся, що підтримка JavaScript та Plugin вимкнена для будь-яких WebViews (вимкнена за замовчуванням). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** Доступ WebView до файлової системи має бути вимкнений (увімкнений за замовчуванням) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: У кількох випадках, коли Android-додаток завершує сесію, cookie не відкликається або навіть може бути збережено на диск
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Статичний аналіз**

![](<../../images/image (866).png>)

**Оцінка вразливостей додатку** з використанням зручного веб-інтерфейсу. Ви також можете виконувати динамічний аналіз (але потрібно підготувати середовище).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Зверніть увагу, що MobSF може аналізувати **Android**(apk)**, IOS**(ipa) **and Windows**(apx) додатки (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Також, якщо ви створите **ZIP** файл зі вихідним кодом для **Android** або **IOS** додатку (перейдіть у кореневу папку програми, виділіть усе і створіть ZIPfile), він також зможе його проаналізувати.

MobSF також дозволяє робити **diff/Compare** аналізів та інтегрувати **VirusTotal** (вам потрібно буде вказати свій API key у _MobSF/settings.py_ та увімкнути його: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). Ви також можете встановити `VT_UPLOAD` в `False`, тоді буде **upload** не файл, а **hash**.

### Assisted Dynamic analysis with MobSF

**MobSF** також може бути дуже корисним для **dynamic analysis** в **Android**, але в цьому випадку вам потрібно встановити MobSF та **genymotion** на ваш хост (VM або Docker не підходять). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
**MobSF dynamic analyser** може:

- **Dump application data** (URLs, логи, буфер обміну, скриншоти, зроблені вами, скриншоти, зроблені "**Exported Activity Tester**", електронні листи, SQLite бази даних, XML файли та інші створені файли). Усе це робиться автоматично, за винятком скриншотів — вам потрібно натиснути у потрібний момент, щоб зробити скриншот, або натиснути "**Exported Activity Tester**", щоб отримати скриншоти всіх exported activities.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

З Android **versions > 5**, він **автоматично запустить Frida** і встановить глобальні налаштування **proxy** для **capture** трафіку. Він буде захоплювати трафік лише від тестованого додатку.

**Frida**

За замовчуванням також використовуються деякі Frida Scripts для **bypass SSL pinning**, **root detection** та **debugger detection**, а також для **monitor interesting APIs**.\
MobSF також може **invoke exported activities**, робити їх **screenshots** і **save** їх для звіту.

Щоб **start** dynamic testing натисніть зелену кнопку: "**Start Instrumentation**". Натисніть "**Frida Live Logs**", щоб бачити логи, згенеровані Frida scripts, та "**Live API Monitor**", щоб бачити всі виклики hooked methods, передані аргументи та повернені значення (це з’явиться після натискання "Start Instrumentation").\
MobSF також дозволяє завантажувати власні **Frida scripts** (щоб відправити результати ваших Friday scripts в MobSF використовуйте функцію `send()`). Він також містить **кілька готових скриптів**, які можна завантажити (ви можете додати більше в `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), просто **select** їх, натисніть "**Load**" і натисніть "**Start Instrumentation**" (логи цих скриптів будуть доступні в "**Frida Live Logs**").

![](<../../images/image (419).png>)

Крім того, є деякі допоміжні Frida функціональності:

- **Enumerate Loaded Classes**: Виведе всі завантажені класи
- **Capture Strings**: Виводить усі capture strings під час використання додатку (дуже шумно)
- **Capture String Comparisons**: Може бути дуже корисним. Показує **2 strings being compared** і чи був результат True або False.
- **Enumerate Class Methods**: Введіть ім'я класу (наприклад "java.io.File") і воно виведе всі методи класу.
- **Search Class Pattern**: Пошук класів за шаблоном
- **Trace Class Methods**: **Trace** цілий **class** (дивитися inputs і outputs усіх методів класу). Пам'ятайте, що за замовчуванням MobSF трасує кілька цікавих Android Api методів.

Після того як ви вибрали допоміжний модуль, який хочете використовувати, потрібно натиснути "**Start Intrumentation**", і ви побачите всі виводи в "**Frida Live Logs**".

**Shell**

MobSF також надає shell з деякими **adb** командами, **MobSF** командами та загальними **shell** **commands** внизу сторінки dynamic analysis. Декілька цікавих команд:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP tools**

When http traffic is capture you can see an ugly view of the captured traffic on "**HTTP(S) Traffic**" bottom or a nicer view in "**Start HTTPTools**" green bottom. From the second option, you can **send** the **captured requests** to **proxies** like Burp or Owasp ZAP.\
To do so, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> press "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Once you finish the dynamic analysis with MobSF you can press on "**Start Web API Fuzzer**" to **fuzz http requests** an look for vulnerabilities.

> [!TIP]
> After performing a dynamic analysis with MobSF the proxy settings me be misconfigured and you won't be able to fix them from the GUI. You can fix the proxy settings by doing:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Асистований dynamic analysis за допомогою Inspeckage

You can get the tool from [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Цей інструмент використовує деякі **Hooks**, щоб повідомляти, що відбувається в додатку під час виконання **dynamic analysis**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Це **great tool to perform static analysis with a GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Цей інструмент призначений для пошуку кількох **security related Android application vulnerabilities**, як у **source code**, так і в **packaged APKs**. Інструмент також **capable of creating a "Proof-of-Concept" deployable APK** and **ADB commands**, щоб експлуатувати деякі знайдені вразливості (Exposed activities, intents, tapjacking...). Як і з Drozer, немає потреби root-ити тестовий пристрій.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Відображає всі витягнуті файли для зручного перегляду
- Автоматично декомпілює APK-файли у формати Java та Smali
- Аналізує AndroidManifest.xml на наявність поширених вразливостей та поведінки
- Статичний аналіз вихідного коду на наявність поширених вразливостей та поведінки
- Інформація про пристрій
- та інше
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER — це консольний додаток, який можна використовувати в Windows, MacOS X і Linux, що аналізує _.apk_ файли в пошуках вразливостей. Він робить це шляхом розпакування APKs і застосування низки правил для виявлення цих вразливостей.

Всі правила зосереджені у файлі `rules.json`, і кожна компанія або тестувальник можуть створити власні правила для аналізу того, що їм потрібно.

Завантажте останні бінарні файли зі сторінки [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn — це **crossplatform** інструмент, який допомагає розробникам, bugbounty hunters та етичним хакерам виконувати [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) мобільних застосунків.

Ідея полягає в тому, що ви перетягуєте файл мобільного застосунку (файл .apk або .ipa) у застосунок StaCoAn, і він згенерує для вас візуальний та переносний звіт. Ви можете налаштовувати параметри та wordlists, щоб отримати персоналізований досвід.

Завантажити[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework — це система аналізу вразливостей для Android, що допомагає розробникам або hackers знаходити потенційні проблеми безпеки в додатках Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** — інструмент, основна мета якого — виявляти та попереджувати користувача про потенційно шкідливу поведінку, реалізовану Android-додатком.

Виявлення здійснюється за допомогою **static analysis** байткоду Dalvik додатка, представленого як **Smali**, з використанням бібліотеки [`androguard`](https://github.com/androguard/androguard).

Цей інструмент шукає **поширені поведінкові ознаки "шкідливих" додатків**, такі як: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. Це інструмент, який об’єднує часто використовувані інструменти для mobile application reverse engineering and analysis, щоб допомогти з тестуванням мобільних додатків щодо OWASP mobile security threats. Його мета — зробити це завдання простішим та зручнішим для mobile application developers та security professionals.

It is able to:

- Extract Java and Smali code using different tools
- Analyze APKs using: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Extract private information from the APK using regexps.
- Analyze the Manifest.
- Analyze found domains using: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Корисно для виявлення malware: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Зверніть увагу, що в залежності від сервісу та конфігурації, яку ви використовуєте для обфускації коду, секрети можуть бути заобфусковані або ні.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. It is able to optimize bytecode as well as detect and remove unused instructions. ProGuard is free software and is distributed under the GNU General Public License, version 2.

ProGuard розповсюджується як частина Android SDK і запускається під час збірки додатка в release mode.

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Last time we checked, the Dexguard mode of operation was:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

Ви можете завантажити заобфускований APK на їхню платформу.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

It is a **generic android deobfuscator.** Simplify **virtually executes an app** to understand its behavior and then **tries to optimize the code** so it behaves identically but is easier for a human to understand. Each optimization type is simple and generic, so it doesn't matter what the specific type of obfuscation is used.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD gives you information about **how an APK was made**. It identifies many **compilers**, **packers**, **obfuscators**, and other weird stuff. It's [_PEiD_](https://www.aldeid.com/wiki/PEiD) for Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b is an Android security virtual machine based on ubuntu-mate includes the collection of latest framework, tutorials and labs from different security geeks and researchers for reverse engineering and malware analysis.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Це чудовий список ресурсів
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
