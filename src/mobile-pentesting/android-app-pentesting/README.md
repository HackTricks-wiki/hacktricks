# Pentesting Εφαρμογών Android

{{#include ../../banners/hacktricks-training.md}}

## Βασικά στοιχεία Εφαρμογών Android

Συνιστάται έντονα να ξεκινήσετε διαβάζοντας αυτή τη σελίδα για να μάθετε σχετικά με τα **πιο σημαντικά μέρη που σχετίζονται με την ασφάλεια Android και τα πιο επικίνδυνα components σε μια εφαρμογή Android**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Αυτό είναι το κύριο εργαλείο που χρειάζεστε για να συνδεθείτε σε μια συσκευή Android (emulated ή physical).\
**ADB** επιτρέπει τον έλεγχο συσκευών είτε μέσω **USB** είτε μέσω **Network** από έναν υπολογιστή. Αυτό το βοηθητικό πρόγραμμα επιτρέπει την **αντιγραφή** αρχείων και στις δύο κατευθύνσεις, την **εγκατάσταση** και **απεγκατάσταση** εφαρμογών, την **εκτέλεση** εντολών shell, τη **δημιουργία αντιγράφων ασφαλείας** δεδομένων, την **ανάγνωση** των logs, μεταξύ άλλων λειτουργιών.

Ρίξτε μια ματιά στην παρακάτω λίστα με [**ADB Commands**](adb-commands.md) για να μάθετε πώς να χρησιμοποιείτε το adb.

## Smali

Μερικές φορές είναι χρήσιμο να **τροποποιήσετε τον κώδικα της εφαρμογής** για να αποκτήσετε πρόσβαση σε **κρυφές πληροφορίες** (ίσως καλά obfuscated passwords ή flags). Τότε, μπορεί να είναι ενδιαφέρον να αποσυμπιέσετε το apk, να τροποποιήσετε τον κώδικα και να το ξανασυμπιέσετε.\
[**Σε αυτό το tutorial** μπορείτε να **μάθετε πώς να αποσυμπιέζετε ένα APK, να τροποποιείτε Smali κώδικα και να επανασυμπιέζετε το APK** με τη νέα λειτουργικότητα](smali-changes.md). Αυτό μπορεί να είναι πολύ χρήσιμο ως **εναλλακτική για αρκετές δοκιμές κατά τη διάρκεια της δυναμικής ανάλυσης** που θα παρουσιαστούν. Επομένως, **κρατήστε πάντα στο μυαλό σας αυτή τη δυνατότητα**.

## Άλλα ενδιαφέροντα κόλπα

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **Λήψη APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Εξαγωγή APK από συσκευή:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Συγχωνεύστε όλα τα splits και τα base apks με [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Μελέτες Περίπτωσης & Ευπάθειες


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Στατική Ανάλυση

Πρώτα απ' όλα, για την ανάλυση ενός APK θα πρέπει να **ρίξετε μια ματιά στον Java code** χρησιμοποιώντας έναν decompiler.\
Please, [**read here to find information about different available decompilers**](apk-decompilers.md).

### Αναζήτηση ενδιαφέρουσας πληροφορίας

Απλώς κοιτάζοντας τα **strings** του APK μπορείτε να αναζητήσετε **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **API keys**, **encryption**, **bluetooth uuids**, **tokens** και οτιδήποτε ενδιαφέρον... ψάξτε ακόμα και για code execution **backdoors** ή authentication backdoors (hardcoded admin credentials στην εφαρμογή).

**Firebase**

Δώστε ιδιαίτερη προσοχή σε **Firebase URLs** και ελέγξτε αν είναι κακώς ρυθμισμένο. [More information about whats is FIrebase and how to exploit it here.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Βασική κατανόηση της εφαρμογής - Manifest.xml, strings.xml

Η **εξέταση των αρχείων _Manifest.xml_ και **_strings.xml_** μιας εφαρμογής μπορεί να αποκαλύψει πιθανές ευπάθειες ασφάλειας**. Αυτά τα αρχεία μπορούν να προσπελαστούν χρησιμοποιώντας decompilers ή μετονομάζοντας την επέκταση του APK σε .zip και αποσυμπιέζοντας το.

**Ευπάθειες** που εντοπίζονται από το **Manifest.xml** περιλαμβάνουν:

- **Debuggable Applications**: Εφαρμογές που έχουν οριστεί ως debuggable (`debuggable="true"`) στο _Manifest.xml_ αποτελούν ρίσκο καθώς επιτρέπουν συνδέσεις που μπορούν να οδηγήσουν σε exploitation. Για περαιτέρω κατανόηση του πώς να εκμεταλλευτείτε debuggable applications, ανατρέξτε σε ένα tutorial για τον εντοπισμό και την εκμετάλλευση debuggable applications σε μια συσκευή.
- **Backup Settings**: Το `android:allowBackup="false"` attribute θα πρέπει να ορίζεται ρητά για εφαρμογές που χειρίζονται ευαίσθητες πληροφορίες ώστε να αποτραπούν μη εξουσιοδοτημένα backups δεδομένων μέσω adb, ιδιαίτερα όταν το usb debugging είναι ενεργοποιημένο.
- **Network Security**: Custom network security configurations (`android:networkSecurityConfig="@xml/network_security_config"`) στο _res/xml/_ μπορούν να καθορίσουν λεπτομέρειες ασφάλειας όπως certificate pins και ρυθμίσεις για HTTP traffic. Ένα παράδειγμα είναι η επιτρεπόμενη HTTP κίνηση για συγκεκριμένα domains.
- **Exported Activities and Services**: Η αναγνώριση exported activities και services στο manifest μπορεί να αναδείξει components που ενδέχεται να καταχραστούν. Περαιτέρω ανάλυση κατά τη διάρκεια dynamic testing μπορεί να δείξει πώς να εκμεταλλευτείτε αυτά τα components.
- **Content Providers and FileProviders**: Εκτεθειμένοι content providers θα μπορούσαν να επιτρέψουν μη εξουσιοδοτημένη πρόσβαση ή τροποποίηση δεδομένων. Η διαμόρφωση των FileProviders πρέπει επίσης να ελεγχθεί προσεκτικά.
- **Broadcast Receivers and URL Schemes**: Αυτά τα components θα μπορούσαν να αξιοποιηθούν για εκμετάλλευση, με ιδιαίτερη προσοχή στον τρόπο που διαχειρίζονται τα URL schemes για πιθανές εισόδους ευπαθειών.
- **SDK Versions**: Τα attributes `minSdkVersion`, `targetSDKVersion`, και `maxSdkVersion` δείχνουν τις υποστηριζόμενες εκδόσεις Android, υπογραμμίζοντας τη σημασία του να μην υποστηρίζονται παλιές, ευάλωτες εκδόσεις Android για λόγους ασφάλειας.

Από το αρχείο **strings.xml**, μπορούν να ανακαλυφθούν ευαίσθητες πληροφορίες όπως API keys, custom schemas, και άλλες σημειώσεις developers, επισημαίνοντας την ανάγκη για προσεκτική ανασκόπηση αυτών των resources.

### Tapjacking

**Tapjacking** είναι μια επίθεση όπου μια **malicious** **application** ξεκινάει και **τοποθετείται πάνω από την εφαρμογή-θύμα**. Μόλις καλύψει οπτικά την εφαρμογή-θύμα, το UI της σχεδιάζεται με τρόπο που να εξαπατά τον χρήστη να αλληλεπιδράσει με αυτό, ενώ ταυτόχρονα περνά την αλληλεπίδραση στην εφαρμογή-θύμα.\
Στην πράξη, είναι **σαν να τυφλώνεται ο χρήστης από το να ξέρει ότι πραγματοποιεί ενέργειες στην εφαρμογή-θύμα**.

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Μια **activity** με το **`launchMode`** ορισμένο σε **`singleTask` χωρίς κανένα `taskAffinity`** ορισμένο είναι ευάλωτη σε Task Hijacking. Αυτό σημαίνει ότι μια **application** μπορεί να εγκατασταθεί και αν ξεκινήσει πριν από την πραγματική εφαρμογή θα μπορούσε **να υπεξαιρέσει το task της πραγματικής εφαρμογής** (ώστε ο χρήστης να αλληλεπιδρά με την **malicious application νομίζοντας ότι χρησιμοποιεί την πραγματική**).

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Αποθήκευση δεδομένων με ανασφαλή τρόπο

**Internal Storage**

Στο Android, αρχεία **αποθηκευμένα** στο **internal** storage είναι **σχεδιασμένα** να είναι **προσβάσιμα αποκλειστικά από την εφαρμογή** που τα **δημιούργησε**. Αυτό το μέτρο ασφάλειας εφαρμόζεται από το Android OS και είναι γενικά επαρκές για τις ανάγκες ασφάλειας των περισσότερων εφαρμογών. Ωστόσο, οι developers κάποιες φορές χρησιμοποιούν modes όπως `MODE_WORLD_READABLE` και `MODE_WORLD_WRITABLE` για να **επιτρέψουν** στα αρχεία να **μοιράζονται** μεταξύ διαφορετικών εφαρμογών. Αυτά τα modes **δεν περιορίζουν την πρόσβαση** σε αυτά τα αρχεία από άλλες εφαρμογές, συμπεριλαμβανομένων πιθανώς malicious ones.

1. **Static Analysis:**
- **Ensure** ότι η χρήση των `MODE_WORLD_READABLE` και `MODE_WORLD_WRITABLE` εξετάζεται **προσεκτικά**. Αυτά τα modes **μπορούν να εκθέσουν** αρχεία σε **μη προοριζόμενη ή μη εξουσιοδοτημένη πρόσβαση**.
2. **Dynamic Analysis:**
- **Verify** τα **permissions** που ορίζονται στα αρχεία που δημιουργεί η εφαρμογή. Ειδικότερα, **ελέγξτε** αν κάποιο αρχείο έχει οριστεί να είναι readable ή writable worldwide. Αυτό μπορεί να αποτελέσει σημαντικό ρίσκο ασφάλειας, καθώς θα επέτρεπε σε **οποιαδήποτε εφαρμογή** εγκατεστημένη στη συσκευή, ανεξαρτήτως προέλευσης ή πρόθεσης, να **διαβάσει ή να τροποποιήσει** αυτά τα αρχεία.

**External Storage**

Όταν χειρίζεστε αρχεία σε **external storage**, όπως SD Cards, πρέπει να ληφθούν υπόψη τα εξής:

1. **Accessibility**:
- Τα αρχεία στο external storage είναι **παγκοσμίως readable και writable**. Αυτό σημαίνει ότι οποιαδήποτε εφαρμογή ή χρήστης μπορεί να έχει πρόσβαση σε αυτά.
2. **Security Concerns**:
- Δεδομένης της ευκολίας πρόσβασης, συνιστάται **να μην αποθηκεύετε ευαίσθητες πληροφορίες** στο external storage.
- Το external storage μπορεί να αφαιρεθεί ή να προσπελαστεί από οποιαδήποτε εφαρμογή, καθιστώντας το λιγότερο ασφαλές.
3. **Handling Data from External Storage**:
- Πάντα **εκτελείτε input validation** στα δεδομένα που ανακτάτε από το external storage. Αυτό είναι κρίσιμο επειδή τα δεδομένα προέρχονται από μη αξιόπιστη πηγή.
- Αποφύγετε να αποθηκεύετε executables ή class files στο external storage για dynamic loading.
- Αν η εφαρμογή σας πρέπει να ανακτήσει executable αρχεία από external storage, βεβαιωθείτε ότι αυτά τα αρχεία είναι **signed και cryptographically verified** πριν γίνει dynamic loading. Αυτό το βήμα είναι ζωτικής σημασίας για τη διατήρηση της ακεραιότητας ασφάλειας της εφαρμογής.

Το external storage μπορεί να προσπελαστεί στα /storage/emulated/0 , /sdcard , /mnt/sdcard

> [!TIP]
> Starting with Android 4.4 (**API 17**), the SD card has a directory structure which **limits access from an app to the directory which is specifically for that app**. This prevents malicious application from gaining read or write access to another app's files.

**Sensitive data stored in clear-text**

- **Shared preferences**: Το Android επιτρέπει σε κάθε εφαρμογή να αποθηκεύει εύκολα xml αρχεία στη διαδρομή `/data/data/<packagename>/shared_prefs/` και κάποιες φορές είναι πιθανό να βρεθούν ευαίσθητες πληροφορίες σε clear-text σε αυτόν το φάκελο.
- **Databases**: Το Android επιτρέπει σε κάθε εφαρμογή να αποθηκεύει εύκολα sqlite databases στη διαδρομή `/data/data/<packagename>/databases/` και κάποιες φορές είναι πιθανό να βρεθούν ευαίσθητες πληροφορίες σε clear-text σε αυτόν το φάκελο.

### Broken TLS

**Accept All Certificates**

Για κάποιο λόγο, μερικές φορές οι developers αποδέχονται όλα τα certificates ακόμα κι αν, για παράδειγμα, το hostname δεν ταιριάζει, με γραμμές κώδικα όπως η παρακάτω:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Broken Cryptography

**Poor Key Management Processes**

Κάποιοι developers αποθηκεύουν sensitive data στο local storage και την κρυπτογραφούν με ένα key hardcoded/predictable μέσα στον κώδικα. Αυτό δεν πρέπει να γίνεται, καθώς κάποιο reversing μπορεί να επιτρέψει σε attackers να εξάγουν τις εμπιστευτικές πληροφορίες.

**Use of Insecure and/or Deprecated Algorithms**

Οι developers δεν θα πρέπει να χρησιμοποιούν **deprecated algorithms** για να κάνουν authorisation **checks**, να **store** ή να **send** δεδομένα. Μερικοί από αυτούς τους αλγορίθμους είναι: RC4, MD4, MD5, SHA1... Αν χρησιμοποιούνται **hashes** για την αποθήκευση κωδικών, θα πρέπει να χρησιμοποιούνται hashes ανθεκτικά στο brute-force μαζί με salt.

### Other checks

- Συνιστάται να **obfuscate the APK** για να δυσκολέψετε το reverse engineer labour των attackers.
- Αν η app είναι ευαίσθητη (π.χ. bank apps), θα πρέπει να κάνει τα δικά της **checks to see if the mobile is rooted** και να δράσει αναλόγως.
- Αν η app είναι ευαίσθητη (π.χ. bank apps), θα πρέπει να ελέγξει αν χρησιμοποιείται **emulator**.
- Αν η app είναι ευαίσθητη (π.χ. bank apps), θα πρέπει να **check it's own integrity before executing** για να διαπιστώσει αν έχει τροποποιηθεί.
- Χρησιμοποιήστε [**APKiD**](https://github.com/rednaga/APKiD) για να δείτε ποιος compiler/packer/obfuscator χρησιμοποιήθηκε για να γίνει build το APK

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

Το εργαλείο [**mariana-trench**](https://github.com/facebook/mariana-trench) είναι ικανό να βρει **vulnerabilities** σαρώνοντας τον **code** της εφαρμογής. Το εργαλείο περιέχει μια σειρά από **known sources** (που υποδεικνύουν στο εργαλείο τα **places** όπου το **input** είναι **controlled by the user**), **sinks** (που υποδεικνύουν τα **dangerous** **places** όπου κακόβουλο user input θα μπορούσε να προκαλέσει ζημιά) και **rules**. Αυτοί οι κανόνες υποδεικνύουν τον **συνδυασμό** **sources-sinks** που δηλώνει μια ευπάθεια.

Με αυτή τη γνώση, το **mariana-trench θα ανασκοπήσει τον κώδικα και θα βρει πιθανές vulnerabilities σε αυτόν**.

### Secrets leaked

Μια εφαρμογή μπορεί να περιέχει secrets (API keys, passwords, hidden urls, subdomains...) μέσα της που μπορεί να καταφέρετε να ανακαλύψετε. Μπορείτε να χρησιμοποιήσετε ένα εργαλείο όπως [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> First of all, you need an environment where you can install the application and all the environment (Burp CA cert, Drozer and Frida mainly). Therefore, a rooted device (emulated or not) is extremely recommended.

### Online Dynamic analysis

You can create a **free account** in: [https://appetize.io/](https://appetize.io). This platform allows you to **upload** and **execute** APKs, so it is useful to see how an apk is behaving.

You can even **see the logs of your application** in the web and connect through **adb**.

![](<../../images/image (831).png>)

Thanks to the ADB connection you can use **Drozer** and **Frida** inside the emulators.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (You can create **x86** and **arm** devices, and according to [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** versions **support ARM libraries** without needing an slow arm emulator).
- Learn to set it up in this page:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, you need to create an account. _It's recommend to **download** the version **WITH**_ _**VirtualBox** to avoid potential errors._)
- [**Nox**](https://es.bignox.com) (Free, but it doesn't support Frida or Drozer).

> [!TIP]
> Όταν δημιουργείτε νέο emulator σε οποιαδήποτε πλατφόρμα, θυμηθείτε ότι όσο μεγαλύτερη είναι η οθόνη τόσο πιο αργά θα τρέχει ο emulator. Επιλέξτε όσο γίνεται μικρότερες οθόνες.

To **install google services** (like AppStore) in Genymotion you need to click on the red marked button of the following image:

![](<../../images/image (277).png>)

Also, notice that in the **configuration of the Android VM in Genymotion** you can select **Bridge Network mode** (this will be useful if you will be connecting to the Android VM from a different VM with the tools).

#### Use a physical device

You need to activate the **debugging** options and it will be cool if you can **root** it:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Once you have installed the application, the first thing you should do is to try it and investigate what does it do, how does it work and get comfortable with it.\
> I will suggest to **perform this initial dynamic analysis using MobSF dynamic analysis + pidcat**, so we will be able to **learn how the application works** while MobSF **captures** a lot of **interesting** **data** you can review later on.

### Unintended Data Leakage

**Logging**

Οι developers πρέπει να είναι προσεκτικοί στο να μην εκθέτουν **debugging information** δημόσια, καθώς αυτό μπορεί να οδηγήσει σε sensitive data leaks. Τα εργαλεία [**pidcat**](https://github.com/JakeWharton/pidcat) και `adb logcat` συστήνονται για την παρακολούθηση των application logs ώστε να εντοπιστούν και να προστατευτούν ευαίσθητες πληροφορίες. Το **Pidcat** προτιμάται για την ευκολία χρήσης και την αναγνωσιμότητα.

> [!WARNING]
> Σημειώστε ότι από **later newer than Android 4.0**, **applications are only able to access their own logs**. Έτσι οι εφαρμογές δεν μπορούν να έχουν πρόσβαση στα logs άλλων apps.\
> Παρ' όλα αυτά, εξακολουθεί να συνιστάται να **μην καταγράφονται sensitive information**.

**Copy/Paste Buffer Caching**

Το **clipboard-based** framework του Android επιτρέπει λειτουργία copy-paste στις εφαρμογές, αλλά ενέχει ρίσκο καθώς **other applications** μπορούν να **access** το clipboard και να εκθέσουν sensitive data. Είναι κρίσιμο να **disable copy/paste** για ευαίσθητες περιοχές της εφαρμογής, όπως λεπτομέρειες πιστωτικής κάρτας, για να αποφευχθούν data leaks.

**Crash Logs**

Αν μια εφαρμογή **crashes** και **saves logs**, αυτά τα logs μπορούν να βοηθήσουν attackers, ειδικά όταν η εφαρμογή δεν μπορεί να γίνει reverse-engineered. Για να μειωθεί ο κίνδυνος, αποφύγετε το logging σε crashes, και αν πρέπει να αποστέλλονται logs μέσω δικτύου, βεβαιωθείτε ότι στέλνονται μέσω SSL.

Ως pentester, **try to take a look to these logs**.

**Analytics Data Sent To 3rd Parties**

Οι εφαρμογές συχνά ενσωματώνουν υπηρεσίες όπως Google Adsense, που μπορούν άθελά τους να cause sensitive data leaks λόγω λανθασμένης υλοποίησης από τους developers. Για να εντοπίσετε πιθανά data leaks, είναι καλό να **intercept the application's traffic** και να ελέγξετε αν αποστέλλονται ευαίσθητες πληροφορίες σε third-party services.

### SQLite DBs

Οι περισσότερες εφαρμογές χρησιμοποιούν **internal SQLite databases** για να αποθηκεύουν πληροφορίες. Κατά το pentest, ρίξτε μια **ματιά** στις **databases** που δημιουργούνται, τα ονόματα των **tables** και **columns** και όλα τα **data** που αποθηκεύονται γιατί μπορεί να βρείτε sensitive information (το οποίο θα είναι vulnerability).\
Οι βάσεις δεδομένων θα πρέπει να βρίσκονται σε `/data/data/the.package.name/databases` όπως `/data/data/com.mwr.example.sieve/databases`

Αν η βάση δεδομένων αποθηκεύει εμπιστευτικές πληροφορίες και είναι **encrypted b**ut μπορείτε **find** το **password** μέσα στην εφαρμογή, εξακολουθεί να είναι **vulnerability**.

Αναγράψτε τα tables με `.tables` και αναλύστε τα σχήματα των table με `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer is s useful tool to **exploit exported activities, exported services and Content Providers** as you will learn in the following sections.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Also remember that the code of an activity starts in the **`onCreate`** method.

**Authorisation bypass**

When an Activity is exported you can invoke its screen from an external app. Therefore, if an activity with **sensitive information** is **exported** you could **bypass** the **authentication** mechanisms **to access it.**

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

You can also start an exported activity from adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**ΣΗΜΕΙΩΣΗ**: Το MobSF θα εντοπίσει ως κακόβουλη τη χρήση του _**singleTask/singleInstance**_ ως `android:launchMode` σε ένα activity, αλλά λόγω [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), προφανώς αυτό είναι επικίνδυνο μόνο σε παλιές εκδόσεις (API versions < 21).

> [!TIP]
> Σημειώστε ότι ένα authorisation bypass δεν είναι απαραίτητα ευπάθεια — εξαρτάται από το πώς λειτουργεί το bypass και ποιες πληροφορίες εκτίθενται.

**Sensitive information leakage**

**Activities can also return results**. Εάν καταφέρετε να βρείτε ένα exported και unprotected activity που καλεί τη μέθοδο **`setResult`** και **επιστρέφει ευαίσθητες πληροφορίες**, υπάρχει sensitive information leakage.

#### Tapjacking

If tapjacking isn't prevented, you could abuse the exported activity to make the **user perform unexpected actions**. For more info about [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers χρησιμοποιούνται βασικά για να **μοιράζουν δεδομένα**. Αν μια app έχει διαθέσιμους content providers μπορεί να μπορείτε να **εξάγετε ευαίσθητα** δεδομένα από αυτούς. Είναι επίσης σημαντικό να δοκιμάσετε πιθανές **SQL injections** και **Path Traversals** καθώς μπορεί να είναι ευάλωτες.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Θυμηθείτε ότι οι ενέργειες ενός Service ξεκινούν στη μέθοδο `onStartCommand`.

Ένα service είναι ουσιαστικά κάτι που **μπορεί να λαμβάνει δεδομένα**, **να τα επεξεργάζεται** και **να επιστρέφει** (ή όχι) μια απάντηση. Επομένως, αν μια εφαρμογή εξάγει services θα πρέπει να **ελέγξετε** τον **κώδικα** για να κατανοήσετε τι κάνει και να το **δοκιμάσετε** **δυναμικά** για εξαγωγή εμπιστευτικών πληροφοριών, παράκαμψη μέτρων αυθεντικοποίησης...\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Θυμηθείτε ότι οι ενέργειες ενός Broadcast Receiver ξεκινούν στη μέθοδο `onReceive`.

Ένας broadcast receiver θα περιμένει έναν τύπο μηνύματος. Ανάλογα με το πώς ο receiver χειρίζεται το μήνυμα, μπορεί να είναι ευάλωτος.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Μπορείτε να αναζητήσετε deep links χειροκίνητα, χρησιμοποιώντας εργαλεία όπως το MobSF ή scripts όπως [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Μπορείτε να **ανοίξετε** ένα δηλωμένο **scheme** χρησιμοποιώντας **adb** ή έναν **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Σημειώστε ότι μπορείτε να **παραλείψετε το package name** και το κινητό θα καλέσει αυτόματα την εφαρμογή που θα ανοίξει αυτόν τον σύνδεσμο._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Code executed**

In order to find the **code that will be executed in the App**, go to the activity called by the deeplink and search the function **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Sensitive info**

Every time you find a deep link check that i**t's not receiving sensitive data (like passwords) via URL parameters**, because any other application could **impersonate the deep link and steal that data!**

**Parameters in path**

You **must check also if any deep link is using a parameter inside the path** of the URL like: `https://api.example.com/v1/users/{username}` , in that case you can force a path traversal accessing something like: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Note that if you find the correct endpoints inside the application you may be able to cause a **Open Redirect** (if part of the path is used as domain name), **account takeover** (if you can modify users details without CSRF token and the vuln endpoint used the correct method) and any other vuln. More [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Transport Layer Inspection and Verification Failures

- **Certificates are not always inspected properly** by Android applications. It's common for these applications to overlook warnings and accept self-signed certificates or, in some instances, revert to using HTTP connections.
- **Negotiations during the SSL/TLS handshake are sometimes weak**, employing insecure cipher suites. This vulnerability makes the connection susceptible to man-in-the-middle (MITM) attacks, allowing attackers to decrypt the data.
- **Leakage of private information** is a risk when applications authenticate using secure channels but then communicate over non-secure channels for other transactions. This approach fails to protect sensitive data, such as session cookies or user details, from interception by malicious entities.

#### Certificate Verification

We will focus on **certificate verification**. The integrity of the server's certificate must be verified to enhance security. This is crucial because insecure TLS configurations and the transmission of sensitive data over unencrypted channels can pose significant risks. For detailed steps on verifying server certificates and addressing vulnerabilities, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) provides comprehensive guidance.

#### SSL Pinning

SSL Pinning is a security measure where the application verifies the server's certificate against a known copy stored within the application itself. This method is essential for preventing MITM attacks. Implementing SSL Pinning is strongly recommended for applications handling sensitive information.

#### Traffic Inspection

To inspect HTTP traffic, it's necessary to **install the proxy tool's certificate** (e.g., Burp). Without installing this certificate, encrypted traffic might not be visible through the proxy. For a guide on installing a custom CA certificate, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Applications targeting **API Level 24 and above** require modifications to the Network Security Config to accept the proxy's CA certificate. This step is critical for inspecting encrypted traffic. For instructions on modifying the Network Security Config, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

If **Flutter** is being used you need to to follow the instructions in [**this page**](flutter.md). This is becasue, just adding the certificate into the store won't work as Flutter has its own list of valid CAs.

#### Static detection of SSL/TLS pinning

Before attempting runtime bypasses, quickly map where pinning is enforced in the APK. Static discovery helps you plan hooks/patches and focus on the right code paths.

Tool: SSLPinDetect
- Open-source static-analysis utility that decompiles the APK to Smali (via apktool) and scans for curated regex patterns of SSL/TLS pinning implementations.
- Reports exact file path, line number, and a code snippet for each match.
- Covers common frameworks and custom code paths: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Χρήση
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Παραδείγματα κανόνων pattern (JSON)
Χρησιμοποιήστε ή επεκτείνετε τις signatures για να εντοπίσετε proprietary/custom pinning styles. Μπορείτε να φορτώσετε το δικό σας JSON και να κάνετε scan σε μεγάλη κλίμακα.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes and tips
- Γρήγορο σάρωμα σε μεγάλες εφαρμογές μέσω multi-threading και memory-mapped I/O· pre-compiled regex μειώνει το overhead/false positives.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Τυπικοί στόχοι ανίχνευσης για περαιτέρω αξιολόγηση:
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Declarative pins in res/xml network security config and manifest references
- Χρησιμοποιήστε τις αντιστοιχισμένες θέσεις για να σχεδιάσετε Frida hooks, static patches, ή ανασκοπήσεις config πριν από dynamic testing.



#### Παράκαμψη του SSL Pinning

Όταν εφαρμόζεται SSL Pinning, η παράκαμψή του γίνεται απαραίτητη για την επιθεώρηση της κίνησης HTTPS. Υπάρχουν διάφορες μέθοδοι για αυτό:

- Αυτόματα **τροποποιήστε** το **apk** για να **παρακάμψετε** το SSLPinning με [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Το μεγαλύτερο πλεονέκτημα αυτής της επιλογής είναι ότι δεν θα χρειαστείτε root για να παρακάμψετε το SSL Pinning, αλλά θα χρειαστεί να διαγράψετε την εφαρμογή και να εγκαταστήσετε ξανά τη νέα, και αυτό δεν δουλεύει πάντα.
- Μπορείτε να χρησιμοποιήσετε **Frida** (συζητείται παρακάτω) για να παρακάμψετε αυτήν την προστασία. Εδώ έχετε έναν οδηγό για να χρησιμοποιήσετε Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Μπορείτε επίσης να δοκιμάσετε να **αυτόματα παρακάμψετε το SSL Pinning** χρησιμοποιώντας [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Μπορείτε επίσης να δοκιμάσετε να **αυτόματα παρακάμψετε το SSL Pinning** χρησιμοποιώντας **MobSF dynamic analysis** (εξηγείται παρακάτω)
- Αν εξακολουθείτε να νομίζετε ότι υπάρχει κίνηση που δεν καταγράφετε, μπορείτε να δοκιμάσετε να **προωθήσετε την κίνηση στο burp χρησιμοποιώντας iptables**. Διαβάστε αυτό το blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Αναζήτηση κοινών web ευπαθειών

Είναι σημαντικό να ψάχνετε επίσης για κοινές web ευπάθειες μέσα στην εφαρμογή. Αναλυτικές πληροφορίες για την αναγνώριση και τη μετρίαση αυτών των ευπαθειών υπερβαίνουν το πλαίσιο αυτής της περίληψης αλλά καλύπτονται εκτενώς αλλού.

### Frida

[Frida](https://www.frida.re) είναι ένα dynamic instrumentation toolkit για developers, reverse-engineers, και security researchers.\
**Μπορείτε να έχετε πρόσβαση σε τρέχουσα εφαρμογή και να κάνετε hook μεθόδους σε run time για να αλλάξετε τη συμπεριφορά, να αλλάξετε τιμές, να εξάγετε τιμές, να εκτελέσετε άλλο κώδικα...**\
Αν θέλετε να κάνετε pentest σε Android εφαρμογές πρέπει να ξέρετε πώς να χρησιμοποιείτε Frida.

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Some "GUI" for actions with Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- You can find some Awesome Frida scripts here: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Προσπαθήστε να παρακάμψετε anti-debugging / anti-frida μηχανισμούς φορτώνοντας το Frida όπως υποδεικνύεται στο [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (εργαλείο [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### Εξαγωγή μνήμης - Fridump

Ελέγξτε αν η εφαρμογή αποθηκεύει ευαίσθητες πληροφορίες στη μνήμη που δεν θα έπρεπε να αποθηκεύει, όπως κωδικούς πρόσβασης ή mnemonics.

Χρησιμοποιώντας [**Fridump3**](https://github.com/rootbsd/fridump3) μπορείτε να εξάγετε τη μνήμη της εφαρμογής με:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Αυτό θα dump τη μνήμη στον φάκελο ./dump, και εκεί μπορείτε να κάνετε grep με κάτι σαν:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Sensitive data in Keystore**

Στο Android το Keystore είναι το καλύτερο μέρος για να αποθηκεύσετε ευαίσθητα δεδομένα, ωστόσο με επαρκή προνόμια εξακολουθεί να είναι **δυνατό να αποκτηθεί πρόσβαση σε αυτό**. Καθώς οι εφαρμογές τείνουν να αποθηκεύουν εδώ **ευαίσθητα δεδομένα σε απλό κείμενο**, οι pentests πρέπει να το ελέγξουν, καθώς ένας root user ή κάποιος με φυσική πρόσβαση στη συσκευή θα μπορούσε να κλέψει αυτά τα δεδομένα.

Ακόμη κι αν μια εφαρμογή αποθήκευσε δεδομένα στο keystore, τα δεδομένα θα πρέπει να είναι κρυπτογραφημένα.

Για να αποκτήσετε πρόσβαση στα δεδομένα μέσα στο keystore μπορείτε να χρησιμοποιήσετε αυτό το Frida script: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Χρησιμοποιώντας το παρακάτω Frida script, είναι πιθανό να γίνει **bypass fingerprint authentication** που ενδέχεται να εφαρμόζουν εφαρμογές Android για να **προστατεύσουν ορισμένες ευαίσθητες περιοχές:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Εικόνες φόντου**

Όταν βάζεις μια εφαρμογή στο παρασκήνιο, το Android αποθηκεύει ένα **στιγμιότυπο της εφαρμογής** ώστε όταν επανέλθει στο προσκήνιο να ξεκινήσει φορτώνοντας την εικόνα πριν από την εφαρμογή, ώστε να φαίνεται ότι η εφαρμογή φόρτωσε πιο γρήγορα.

Ωστόσο, αν αυτό το στιγμιότυπο περιέχει **ευαίσθητες πληροφορίες**, κάποιος με πρόσβαση στο στιγμιότυπο μπορεί να **κλέψει αυτές τις πληροφορίες** (σημείωση: χρειάζεστε root για να αποκτήσετε πρόσβαση).

Τα στιγμιότυπα συνήθως αποθηκεύονται εδώ: **`/data/system_ce/0/snapshots`**

Το Android παρέχει έναν τρόπο για να **αποτραπεί η λήψη screenshot ρυθμίζοντας την παράμετρο layout FLAG_SECURE**. Χρησιμοποιώντας αυτή τη σημαία, τα περιεχόμενα του παραθύρου θεωρούνται ασφαλή, αποτρέποντας την εμφάνισή τους σε screenshots ή την προβολή τους σε μη ασφαλείς οθόνες.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Αυτό το εργαλείο μπορεί να σας βοηθήσει στη διαχείριση διαφόρων εργαλείων κατά τη δυναμική ανάλυση: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Οι developers συχνά δημιουργούν proxy components όπως activities, services, και broadcast receivers που χειρίζονται αυτά τα Intents και τα περνούν σε μεθόδους όπως `startActivity(...)` ή `sendBroadcast(...)`, κάτι που μπορεί να είναι επικίνδυνο.

Ο κίνδυνος έγκειται στην δυνατότητα οι attackers να ενεργοποιήσουν μη-εξαγόμενα components της εφαρμογής ή να αποκτήσουν πρόσβαση σε ευαίσθητους content providers παραπλανώντας αυτά τα Intents. Ένα χαρακτηριστικό παράδειγμα είναι το `WebView` component που μετατρέπει URLs σε `Intent` objects μέσω `Intent.parseUri(...)` και στη συνέχεια τα εκτελεί, ενδεχομένως οδηγώντας σε κακόβουλες Intent injections.

### Essential Takeaways

- **Intent Injection** is similar to web's Open Redirect issue.
- Exploits involve passing `Intent` objects as extras, which can be redirected to execute unsafe operations.
- It can expose non-exported components and content providers to attackers.
- `WebView`’s URL to `Intent` conversion can facilitate unintended actions.

### Android Client Side Injections and others

Πιθανώς να γνωρίζετε αυτό το είδος ευπαθειών από το Web. Πρέπει να είστε ιδιαίτερα προσεκτικοί με αυτές τις ευπάθειες σε μια Android εφαρμογή:

- **SQL Injection:** Όταν χειρίζεστε δυναμικά queries ή Content-Providers βεβαιωθείτε ότι χρησιμοποιείτε parameterized queries.
- **JavaScript Injection (XSS):** Ελέγξτε ότι το JavaScript και το Plugin support είναι απενεργοποιημένα για οποιαδήποτε WebViews (disabled by default). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** Τα WebViews θα πρέπει να έχουν απενεργοποιημένη την πρόσβαση στο file system (enabled by default) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: Σε αρκετές περιπτώσεις όταν η android εφαρμογή τερματίζει τη συνεδρία, το cookie δεν ανακαλείται ή μπορεί ακόμα και να αποθηκευτεί στο δίσκο.
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Static analysis**

![](<../../images/image (866).png>)

**Vulnerability assessment of the application** χρησιμοποιώντας ένα ευχάριστο web-based frontend. Μπορείτε επίσης να εκτελέσετε dynamic analysis (αλλά χρειάζεται να προετοιμάσετε το περιβάλλον).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Σημειώστε ότι το MobSF μπορεί να αναλύσει εφαρμογές **Android**(apk), **IOS**(ipa) και **Windows**(apx) (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Επιπλέον, αν δημιουργήσετε ένα αρχείο **ZIP** με τον πηγαίο κώδικα μιας εφαρμογής **Android** ή **IOS** (μεταβείτε στον root φάκελο της εφαρμογής, επιλέξτε τα πάντα και δημιουργήστε ένα ZIPfile), το MobSF θα μπορέσει επίσης να το αναλύσει.

Το MobSF σας επιτρέπει επίσης να κάνετε **diff/Compare** αναλύσεων και να ενσωματώσετε το **VirusTotal** (θα χρειαστεί να ορίσετε το API key σας στο _MobSF/settings.py_ και να το ενεργοποιήσετε: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). Μπορείτε επίσης να ορίσετε το `VT_UPLOAD` σε `False`, οπότε το **hash** θα είναι **upload** αντί για το αρχείο.

### Βοηθημένη Δυναμική ανάλυση με MobSF

Το **MobSF** μπορεί επίσης να είναι πολύ χρήσιμο για **dynamic analysis** σε **Android**, αλλά σε αυτή την περίπτωση θα χρειαστεί να εγκαταστήσετε το MobSF και το **genymotion** στον host σας (ένα VM ή Docker δεν θα λειτουργήσει). _Σημείωση: Πρέπει να **start first a VM in genymotion** και **then MobSF.**_\
Ο **MobSF dynamic analyser** μπορεί:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). Όλα αυτά γίνονται αυτόματα εκτός από τα screenshots — πρέπει να πατήσετε όταν θέλετε ένα screenshot ή να πατήσετε "**Exported Activity Tester**" για να λάβετε screenshots όλων των exported activities.
- **Capture HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

Από android **versions > 5**, θα **automatically start Frida** και θα ορίσει τις παγκόσμιες ρυθμίσεις **proxy** για να καταγράψει την κίνηση. Θα καταγράφει μόνο την κίνηση από την εφαρμογή που δοκιμάζεται.

**Frida**

Κατά προεπιλογή, θα χρησιμοποιήσει επίσης ορισμένα Frida Scripts για να **bypass SSL pinning**, **root detection** και **debugger detection** και για να **monitor interesting APIs**.\
Το MobSF μπορεί επίσης να **invoke exported activities**, να τραβήξει **screenshots** τους και να τα **save** για την αναφορά.

Για να **start** το dynamic testing πατήστε το πράσινο κουμπί: "**Start Instrumentation**". Πατήστε τα "**Frida Live Logs**" για να δείτε τα logs που παράγονται από τα Frida scripts και το "**Live API Monitor**" για να δείτε όλες τις κλήσεις σε hooked methods, τα arguments που περνάνε και τις τιμές που επιστρέφονται (αυτό θα εμφανιστεί μετά το πάτημα του "Start Instrumentation").\
Το MobSF επίσης σας επιτρέπει να φορτώσετε τα δικά σας **Frida scripts** (για να στείλετε τα αποτελέσματα των Frida scripts στο MobSF χρησιμοποιήστε τη συνάρτηση `send()`). Έχει επίσης **several pre-written scripts** που μπορείτε να φορτώσετε (μπορείτε να προσθέσετε περισσότερα στο `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), απλώς **select them**, πατήστε "**Load**" και πατήστε "**Start Instrumentation**" (θα μπορείτε να δείτε τα logs αυτών των scripts μέσα στα "**Frida Live Logs**").

![](<../../images/image (419).png>)

Επιπλέον, έχετε μερικές βοηθητικές λειτουργίες του Frida:

- **Enumerate Loaded Classes**: Εκτυπώνει όλες τις φορτωμένες κλάσεις
- **Capture Strings**: Εκτυπώνει όλα τα capture strings κατά τη χρήση της εφαρμογής (πάρα πολύ noisy)
- **Capture String Comparisons**: Μπορεί να είναι πολύ χρήσιμο. Θα **show the 2 strings being compared** και αν το αποτέλεσμα ήταν True ή False.
- **Enumerate Class Methods**: Βάλτε το όνομα της κλάσης (όπως "java.io.File") και θα εκτυπώσει όλες τις μεθόδους της κλάσης.
- **Search Class Pattern**: Αναζήτηση κλάσεων με μοτίβο
- **Trace Class Methods**: **Trace** ολόκληρη μια **class** (δείτε inputs και outputs όλων των μεθόδων της κλάσης). Θυμηθείτε ότι κατά προεπιλογή το MobSF κάνει trace αρκετές ενδιαφέρουσες Android Api μεθόδους.

Μόλις επιλέξετε το auxiliary module που θέλετε να χρησιμοποιήσετε, πρέπει να πατήσετε "**Start Intrumentation**" και θα δείτε όλα τα outputs στα "**Frida Live Logs**".

**Shell**

Το MobSF επίσης παρέχει ένα shell με μερικές εντολές **adb**, **MobSF commands**, και κοινές εντολές **shell** στο κάτω μέρος της σελίδας dynamic analysis. Μερικές ενδιαφέρουσες εντολές:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP tools**

Όταν η HTTP κίνηση καταγράφεται μπορείς να δεις μια άσχημη προβολή της καταγεγραμμένης κίνησης στο κάτω μέρος "**HTTP(S) Traffic**" ή μια πιο καθαρή προβολή στο πράσινο κουμπί "**Start HTTPTools**". Από τη δεύτερη επιλογή, μπορείς να **send** τα **captured requests** σε **proxies** όπως Burp ή Owasp ZAP.\  
Για να το κάνεις, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> πάτησε "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Μόλις τελειώσεις το dynamic analysis με MobSF μπορείς να πατήσεις "**Start Web API Fuzzer**" για να **fuzz http requests** και να ψάξεις για ευπάθειες.

> [!TIP]
> Μετά από ένα dynamic analysis με MobSF οι proxy settings μπορεί να είναι λανθασμένες και να μην μπορείς να τα διορθώσεις από το GUI. Μπορείς να διορθώσεις τα proxy settings εκτελώντας:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

Μπορείς να πάρεις το εργαλείο από [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Αυτό το εργαλείο θα χρησιμοποιήσει μερικά **Hooks** για να σε ενημερώνει **what is happening in the application** ενώ πραγματοποιείς ένα **dynamic analysis**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Αυτό είναι ένα **great tool to perform static analysis with a GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Αυτό το εργαλείο έχει σχεδιαστεί για να εντοπίζει διάφορες **security related Android application vulnerabilities**, είτε σε **source code** είτε σε **packaged APKs**. Το εργαλείο είναι επίσης **capable of creating a "Proof-of-Concept" deployable APK** και **ADB commands**, για να εκμεταλλευτεί μερικές από τις εντοπισμένες ευπάθειες (Exposed activities, intents, tapjacking...). Όπως και με Drozer, δεν υπάρχει ανάγκη για root στη συσκευή δοκιμής.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Εμφανίζει όλα τα εξαγόμενα αρχεία για εύκολη αναφορά
- Απομεταγλωττίζει αυτόματα τα αρχεία APK σε μορφή Java και Smali
- Αναλύει το AndroidManifest.xml για κοινές ευπάθειες και συμπεριφορές
- Στατική ανάλυση πηγαίου κώδικα για κοινές ευπάθειες και συμπεριφορές
- Πληροφορίες συσκευής
- και άλλα
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

Το SUPER είναι μια εφαρμογή γραμμής εντολών που μπορεί να χρησιμοποιηθεί σε Windows, MacOS X και Linux, η οποία αναλύει _.apk_ αρχεία αναζητώντας ευπάθειες. Αυτό γίνεται αποσυμπιέζοντας τα APKs και εφαρμόζοντας μια σειρά κανόνων για να εντοπιστούν αυτές οι ευπάθειες.

Όλοι οι κανόνες είναι συγκεντρωμένοι σε ένα αρχείο `rules.json`, και κάθε εταιρεία ή tester μπορεί να δημιουργήσει τους δικούς της κανόνες για να αναλύσει ό,τι χρειάζεται.

Κατεβάστε τα πιο πρόσφατα binaries από τη [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

Το StaCoAn είναι ένα **πολυπλατφορμικό** εργαλείο που βοηθά προγραμματιστές, bugbounty hunters και ethical hackers να πραγματοποιούν [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) σε mobile εφαρμογές.

Η ιδέα είναι να σύρετε και να αποθέσετε το αρχείο της mobile εφαρμογής σας (ένα .apk ή .ipa αρχείο) στην εφαρμογή StaCoAn και αυτή θα δημιουργήσει για εσάς μια οπτική και φορητή αναφορά. Μπορείτε να προσαρμόσετε τις ρυθμίσεις και τις wordlists για να έχετε μια εξατομικευμένη εμπειρία.

Κατεβάστε[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

Το AndroBugs Framework είναι ένα σύστημα ανάλυσης ευπαθειών για Android που βοηθά προγραμματιστές ή hackers να εντοπίσουν πιθανές ευπάθειες ασφαλείας στις Android εφαρμογές.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** είναι ένα εργαλείο του οποίου ο κύριος στόχος είναι να εντοπίζει και να ειδοποιεί τον χρήστη σχετικά με πιθανές κακόβουλες συμπεριφορές που αναπτύσσει μια εφαρμογή Android.

Ο εντοπισμός πραγματοποιείται με την **static analysis** του Dalvik bytecode της εφαρμογής, που αναπαρίσταται ως **Smali**, χρησιμοποιώντας τη βιβλιοθήκη [`androguard`](https://github.com/androguard/androguard).

Αυτό το εργαλείο αναζητά **συνηθισμένες συμπεριφορές "κακών" εφαρμογών** όπως: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. Είναι ένα εργαλείο που συγκεντρώνει κοινά χρησιμοποιούμενα εργαλεία για mobile application reverse engineering και analysis, για να βοηθήσει στο testing mobile applications ενάντια στις OWASP mobile security απειλές. Σκοπός του είναι να κάνει αυτή την εργασία πιο εύκολη και φιλική για mobile application developers και security professionals.

It is able to:

- Extract Java and Smali code using different tools
- Analyze APKs using: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Extract private information from the APK using regexps.
- Analyze the Manifest.
- Analyze found domains using: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Χρήσιμο για τον εντοπισμό malware: [https://koodous.com/](https://koodous.com)

## Obfuscating/Deobfuscating code

Σημειώστε ότι ανάλογα με την υπηρεσία και τη ρύθμιση που χρησιμοποιείτε για να obfuscate τον code, τα secrets ενδέχεται να καταλήξουν obfuscated ή όχι.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. Μπορεί να optimize το bytecode καθώς και να εντοπίσει και να αφαιρέσει unused instructions. Το ProGuard είναι free software και διανέμεται υπό τη GNU General Public License, version 2.

Το ProGuard διανέμεται ως μέρος του Android SDK και εκτελείται όταν γίνεται build της εφαρμογής σε release mode.

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Last time we checked, the Dexguard mode of operation was:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

Μπορείτε να ανεβάσετε ένα obfuscated APK στην πλατφόρμα τους.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

Είναι ένας **generic android deobfuscator.** Το Simplify **virtually executes an app** για να κατανοήσει τη συμπεριφορά της και στη συνέχεια **προσπαθεί να optimize τον code** ώστε να συμπεριφέρεται ταυτόσημα αλλά να είναι πιο κατανοητός σε άνθρωπο. Κάθε τύπος optimization είναι απλός και generic, οπότε δεν έχει σημασία ποιος συγκεκριμένος τύπος obfuscation χρησιμοποιείται.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD σας δίνει πληροφορίες για **πώς φτιάχτηκε ένα APK**. Αναγνωρίζει πολλούς **compilers**, **packers**, **obfuscators** και άλλα περίεργα πράγματα. Είναι [_PEiD_](https://www.aldeid.com/wiki/PEiD) για Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b είναι μια Android security virtual machine βασισμένη σε ubuntu-mate που περιλαμβάνει μια συλλογή από τα πιο πρόσφατα frameworks, tutorials και labs από διάφορους security geeks και researchers για reverse engineering και malware analysis.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Είναι μια εξαιρετική λίστα πόρων
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)

## Yet to try

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
