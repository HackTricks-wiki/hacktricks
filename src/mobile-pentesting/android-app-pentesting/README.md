# Android-toepassings Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android-toepassings Basiese beginsels

Dit word sterk aanbeveel om hierdie bladsy eers te lees om te weet oor die **belangrijkste dele wat verband hou met Android-sekuriteit en die gevaarlikste komponente in 'n Android-toepassing**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Dit is die hoofinstrument wat jy nodig het om aan 'n android-toestel (gesimuleer of fisies) te koppel.\
**ADB** laat toe om toestelle óf oor **USB** of oor **Network** van 'n rekenaar af te beheer. Hierdie nutsprogram maak die **kopieer** van lêers in beide rigtings, **installasie** en **uninstallasie** van apps, **uitvoering** van shell-kommando's, **rugsteun** van data, **lees** van logs, onder andere funksies moontlik.

Kyk na die volgende lys van [**ADB Commands**](adb-commands.md) om te leer hoe om adb te gebruik.

## Smali

Soms is dit interessant om die **toepassingskode te wysig** om by **verborgen inligting** te kom (bv. goed geobfuseerde wagwoorde of flags). Dan kan dit sinvol wees om die apk te dekompileer, die kode te wysig en dit weer te compileer.\ [**In hierdie tutoriaal** kan jy **leer hoe om 'n APK te dekompileer, Smali-kode te wysig en die APK weer te compileer** met die nuwe funksionaliteit](smali-changes.md). Dit kan baie nuttig wees as 'n **alternatief vir verskeie toetse tydens die dinamiese analise** wat aangebied gaan word. Hou dus **altyd hierdie moontlikheid in gedagte**.

## Ander interessante truuks

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Onttrek APK vanaf toestel:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Voeg alle splits en base apks saam met [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Gevallestudies & Kwesbaarhede


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Statiese Analise

Eerstens, om 'n APK te ontleed moet jy **na die Java-kode kyk** met 'n dekompiler.\
Asseblief, [**lees hier om inligting oor verskillende beskikbare dekompilers te vind**](apk-decompilers.md).

### Op soek na interessante inligting

Net deur na die **strings** van die APK te kyk kan jy soek na **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** en enigiets interessant... kyk selfs vir code execution **backdoors** of authentication backdoors (hardcoded admin credentials to the app).

**Firebase**

Gee besondere aandag aan **firebase URLs** en kyk of dit verkeerd gekonfigureer is. [Meer inligting oor wat Firebase is en hoe om dit te exploit hier.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Basiese begrip van die toepassing - Manifest.xml, strings.xml

Die **ondersoek van 'n toepassing se _Manifest.xml_ en _strings.xml_ lêers kan potensiële sekuriteitskwesbaarhede openbaar**. Hierdie lêers kan met dekompilers verkry word of deur die APK-lêeruitbreiding na .zip te hernoem en dit dan uit te pak.

**Kwesbaarhede** geïdentifiseer uit die **Manifest.xml** sluit in:

- **Debuggable Applications**: Toepassings wat as debuggable (`debuggable="true"`) in die _Manifest.xml_ lêer gestel is vorm 'n risiko aangesien hulle verbindings toelaat wat tot exploit kan lei. Vir meer begrip oor hoe om debuggable applications te exploit, verwys na 'n tutorial oor die vind en exploit van debuggable applications op 'n toestel.
- **Backup Settings**: Die `android:allowBackup="false"` attribuut moet eksplisiet gestel word vir toepassings wat sensitiewe inligting hanteer om ongemagtigde databackups via adb te voorkom, veral wanneer usb debugging aangeskakel is.
- **Network Security**: Aangepaste netwerk-sekuriteitskonfigurasies (`android:networkSecurityConfig="@xml/network_security_config"`) in _res/xml/_ kan sekuriteitsbesonderhede soos certificate pins en HTTP-traffiek instellings spesifiseer. 'n Voorbeeld is om HTTP-verkeer vir spesifieke domeine toe te laat.
- **Exported Activities and Services**: Die identifisering van exported activities en services in die manifest kan komponente uitlig wat misbruik kan word. Verdere ontleding tydens dinamiese toetsing kan blootlê hoe om hierdie komponente te exploit.
- **Content Providers and FileProviders**: Blootgestelde content providers kan ongemagtigde toegang tot of wysiging van data toelaat. Die konfigurering van FileProviders moet ook deeglik nagegaan word.
- **Broadcast Receivers and URL Schemes**: Hierdie komponente kan vir exploit aangewend word, met spesiale aandag aan hoe URL schemes bestuur word vir invoer-kwesbaarhede.
- **SDK Versions**: Die `minSdkVersion`, `targetSDKVersion`, en `maxSdkVersion` attributte dui die ondersteunde Android-weergawe aan, wat die belangrikheid beklemtoon om nie ou, kwesbare Android-weergawes te ondersteun nie.

Uit die **strings.xml** lêer kan sensitiewe inligting soos API keys, custom schemas en ander ontwikkelaarsnotas gevind word, wat die behoefte aan 'n deeglike hersiening van hierdie hulpbronne beklemtoon.

### Tapjacking

**Tapjacking** is 'n aanval waar 'n **kwaadaardige toepassing** geloods word en homself bo 'n slagoffer-toepassing posisioneer. Sodra dit die slagoffer-app sigbaar oorbedek, is die gebruikerskoppelvlak so ontwerp dat dit die gebruiker mislei om daarmee te interaksie, terwyl die interaksie aan die slagoffer-app oorgedra word.\
In werklikheid **blind dit die gebruiker daarvan dat hulle eintlik aksies op die slagoffer-app uitvoer**.

Vind meer inligting in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

'n **activity** met die **`launchMode`** gestel op **`singleTask` sonder enige `taskAffinity`** gedefinieer is kwesbaar vir task Hijacking. Dit beteken dat 'n **application** geïnstalleer kan word en as dit voor die werklike toepassing geloods word, kan dit die **taak van die werklike toepassing kap** (sodat die gebruiker met die **kwaadaardige toepassing dink hy gebruik die werklike een**).

Meer info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Insecure data storage

**Internal Storage**

In Android is lêers wat in **internal** storage gestoor word ontwerp om uitsluitlik deur die **app** wat dit geskep het toeganklik te wees. Hierdie sekuriteitsmaatreël word deur die Android-bedryfstelsel afgedwing en is oor die algemeen voldoende vir die sekuriteitsbehoeftes van meeste toepassings. Ontwikkelaars gebruik egter soms modusse soos `MODE_WORLD_READABLE` en `MODE_WORLD_WRITABLE` om toe te laat dat lêers tussen verskillende toepassings **gedeel** word. Hierdie modusse **beperk egter nie toegang** tot hierdie lêers deur ander toepassings nie, insluitend potensieel kwaadaardige toepassings.

1. **Static Analysis:**
- **Maak seker** dat die gebruik van `MODE_WORLD_READABLE` en `MODE_WORLD_WRITABLE` noukeurig nagegaan word. Hierdie modusse **kan moontlik lêers blootstel** aan ongewenste of ongemagtigde toegang.
2. **Dynamic Analysis:**
- **Kontroleer** die **permisse** wat op lêers geskep deur die app gestel is. Spesifiek, **kry vas** of enige lêers ingestel is om wêreldwyd lees- of skryfbaar te wees. Dit kan 'n beduidende sekuriteitsrisiko inhou, aangesien dit **enige toepassing** op die toestel, ongeag herkoms of bedoeling, in staat sou stel om hierdie lêers te lees of te wysig.

**External Storage**

Wanneer jy met lêers op **external storage**, soos SD-kaarte, werk, moet sekere voorsorgmaatreëls in ag geneem word:

1. **Toeganklikheid**:
- Lêers op external storage is **wereldwyd lees- en skryfbaar**. Dit beteken enige toepassing of gebruiker kan toegang tot hierdie lêers kry.
2. **Sekuriteitskwessies**:
- Gegewe die maklike toegang, word dit nie aanbeveel om sensitiewe inligting op external storage te stoor nie.
- External storage kan verwyder word of deur enige toepassing verkry word, wat dit minder veilig maak.
3. **Hanering van data van external storage**:
- Voer altyd **invoervalidatie** op data wat van external storage verkry word uit. Dit is kritiek omdat die data uit 'n onbetroubare bron kom.
- Dit word sterk ontraden om uitvoerbare lêers of class-lêers op external storage te stoor vir dinamiese lading.
- As jou toepassing noodsaaklikerwys uitvoerbare lêers vanaf external storage moet haal, maak seker dat hierdie lêers **gesigneer en kriptografies geverifieer** is voordat hulle dinamies gelaai word. Hierdie stap is noodsaaklik om die sekuriteitsintegriteit van jou toepassing te handhaaf.

External storage kan in `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard` bereik word

> [!TIP]
> Beginne met Android 4.4 (**API 17**), het die SD-kaart 'n gidsstruktuur wat die toegang van 'n app beperk tot die gids wat spesifiek vir daardie app is. Dit keer dat 'n kwaadaardige toepassing lees- of skryf toegang tot 'n ander app se lêers kry.

**Sensitive data stored in clear-text**

- **Shared preferences**: Android laat elke toepassing toe om maklik xml-lêers in die pad `/data/data/<packagename>/shared_prefs/` te stoor en soms is dit moontlik om sensitiewe inligting in clear-text in daardie gids te vind.
- **Databases**: Android laat elke toepassing toe om maklik sqlite-databases in die pad `/data/data/<packagename>/databases/` te stoor en soms is dit moontlik om sensitiewe inligting in clear-text in daardie gids te vind.

### Gebroke TLS

**Accept All Certificates**

Om een of ander rede aanvaar ontwikkelaars soms alle sertifikate selfs as byvoorbeeld die hostname nie ooreenstem nie met reëls van kode soos die volgende:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Gebroke Kriptografie

**Swak Sleutelbestuursprosesse**

Sommige ontwikkelaars stoor sensitiewe data in die plaaslike stoorplek en enkripteer dit met 'n sleutel wat hardcoded/predictable in die kode is. Dit behoort nie gedoen te word nie, aangesien omgekeerde ingenieurswese aanvallers kan toelaat om die vertroulike inligting uit te haal.

**Gebruik van Onveilige en/of Verouderde Algoritmes**

Ontwikkelaars moet nie **deprecated algorithms** gebruik om authorisation **checks** uit te voer, data te **store** of te **send** nie. Sommige van hierdie algoritmes is: RC4, MD4, MD5, SHA1... As **hashes** byvoorbeeld gebruik word om wagwoorde te stoor, moet hashes wees wat brute-force **resistant** is en met 'n salt gebruik word.

### Ander kontroles

- It's recommended to **obfuscate the APK** om die reverse engineer-werk vir aanvallers moeiliker te maak.
- If the app is sensitive (like bank apps), dit behoort sy **own checks to see if the mobile is rooted** uit te voer en dienooreenkomstig op te tree.
- If the app is sensitive (like bank apps), dit behoort te kontroleer of 'n **emulator** gebruik word.
- If the app is sensitive (like bank apps), dit behoort **check it's own integrity before executing** om te kyk of dit verander is.
- Use [**APKiD**](https://github.com/rednaga/APKiD) om te kyk watter compiler/packer/obfuscator gebruik is om die APK te bou

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. Die blog bespreek die moontlikheid om 'n app te skep wat hierdie tipe apps dekomprimeer... en 'n vinniger manier wat behels om die toepassing te **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

Die hulpmiddel [**mariana-trench**](https://github.com/facebook/mariana-trench) is in staat om **vulnerabilities** te vind deur die **code** van die toepassing te **scan**. Hierdie hulpmiddel bevat 'n reeks **known sources** (wat aan die hulpmiddel aandui die **places** waar die **input** **controlled by the user** is), **sinks** (wat die hulpmiddel aandui as **dangerous** **places** waar kwaadwillige gebruikerinvoer skade kan veroorsaak) en **rules**. Hierdie rules dui die **combination** van **sources-sinks** aan wat op 'n vulnerability wys.

Met hierdie kennis, **mariana-trench will review the code and find possible vulnerabilities on it**.

### Secrets leaked

An application may contain secrets (API keys, passwords, hidden urls, subdomains...) inside of it that you might be able to discover. You could us a tool such as [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Ander interessante funksies

- **Kode-uitvoering**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Stuur SMS'e**: `sendTextMessage, sendMultipartTestMessage`
- **Native funksies** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)
- In-memory native code execution via JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dinamiese Analise

> Eerstens het jy 'n omgewing nodig waar jy die toepassing en al die omgewing (Burp CA cert, Drozer and Frida mainly) kan installeer. Daarom word 'n rooted device (geëmuleer of nie) sterk aanbeveel.

### Aanlyn dinamiese analise

Jy kan 'n **free account** skep by: [https://appetize.io/](https://appetize.io). Hierdie platform laat jou toe om APKs te **upload** en te **execute**, dus dit is nuttig om te sien hoe 'n apk optree.

Jy kan selfs die **logs van jou toepassing** in die web sien en deur **adb** koppel.

![](<../../images/image (831).png>)

Dankie aan die ADB-verbinding kan jy **Drozer** en **Frida** binne die emulators gebruik.

### Lokale dinamiese analise

#### Gebruik van 'n emulator

- [**Android Studio**](https://developer.android.com/studio) (Jy kan **x86** en **arm** toestelle skep, en volgens [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** versions **support ARM libraries** without needing an slow arm emulator).
- Leer om dit op te stel op hierdie bladsy:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, jy moet 'n rekening skep. _It's recommend to **download** the version **WITH**_ _**VirtualBox** om potensiële foute te vermy._)
- [**Nox**](https://es.bignox.com) (Gratis, maar dit ondersteun nie Frida of Drozer nie).

> [!TIP]
> Wanneer jy 'n nuwe emulator op enige platform skep, onthou dat hoe groter die skerm is, hoe stadiger sal die emulator loop. Kies dus indien moontlik klein skerms.

Om **google services** (soos AppStore) in Genymotion te installeer, moet jy op die rooi gemerkte knop in die volgende prent klik:

![](<../../images/image (277).png>)

Neem ook kennis dat in die **konfigurasie van die Android VM in Genymotion** jy **Bridge Network mode** kan kies (dit sal nuttig wees as jy vanaf 'n ander VM met die gereedskap aan die Android VM wil koppel).

#### Gebruik 'n fisiese toestel

Jy moet die **debugging** opsies aktiveer en dit sal goed wees as jy dit kan **root**:

1. **Settings**.
2. (FromAndroid 8.0) Kies **System**.
3. Kies **About phone**.
4. Druk **Build number** 7 keer.
5. Gaan terug en jy sal die **Developer options** vind.

> Sodra jy die toepassing geïnstalleer het, moet die eerste ding wat jy doen is om dit te probeer en ondersoek wat dit doen, hoe dit werk en gemaklik raak daarmee.\
> Ek raai aan om **perform this initial dynamic analysis using MobSF dynamic analysis + pidcat**, sodat ons kan **leer hoe die toepassing werk** terwyl MobSF **captures** baie **interesting** **data** wat jy later kan hersien.

Magisk/Zygisk quick notes (recommended on Pixel devices)
- Patch boot.img with the Magisk app and flash via fastboot to get systemless root
- Enable Zygisk + DenyList for root hiding; consider LSPosed/Shamiko when stronger hiding is required
- Keep original boot.img to recover from OTA updates; re-patch after each OTA
- For screen mirroring, use scrcpy on the host



### Onbedoelde Data Leakage

**Logging**

Ontwikkelaars moet versigtig wees om **debugging information** nie publiek bloot te stel nie, aangesien dit tot sensitiewe data leaks kan lei. Die gereedskap [**pidcat**](https://github.com/JakeWharton/pidcat) en `adb logcat` word aanbeveel om toepassingslogs te monitor om sensitiewe inligting te identifiseer en te beskerm. **Pidcat** word verkies weens sy gemak van gebruik en leesbaarheid.

> [!WARNING]
> Let daarop dat vanaf **later newer than Android 4.0**, **applications are only able to access their own logs**. So applications cannot access other apps logs.\
> In elk geval, dit word steeds aanbeveel om **not log sensitive information**.

**Copy/Paste Buffer Caching**

Android se **clipboard-based** raamwerk maak copy-paste funksionaliteit in apps moontlik, maar hou 'n risiko in aangesien **other applications** toegang tot die clipboard kan hê en moontlik sensitiewe data kan blootstel. Dit is noodsaaklik om copy/paste funksies vir sensitiewe gedeeltes van 'n toepassing, soos kredietkaartbesonderhede, uit te skakel om data leaks te voorkom.

**Crash Logs**

As 'n toepassing **crash** en logs stoor, kan hierdie logs aanvallers help, veral wanneer die toepassing nie maklik omgekeerd kan word nie. Om hierdie risiko te beperk, vermy logging by crashes, en as logs oor die netwerk oorgedra moet word, verseker dat dit via 'n SSL-kanaal gestuur word vir beveiliging.

As pentester, **try to take a look to these logs**.

**Analytics Data Sent To 3rd Parties**

Toepassings integreer dikwels dienste soos Google Adsense, wat per ongeluk sensitiewe data kan **leak** as gevolg van verkeerde implementering deur ontwikkelaars. Om potensiële data leaks te identifiseer, is dit raadsaam om die toepassing se verkeer te onderskep en te kyk of enige sensitiewe inligting aan derde-party dienste gestuur word.

### SQLite DBs

Die meeste toepassings sal **internal SQLite databases** gebruik om inligting te stoor. Tydens die pentest neem 'n kyk na die **databases** wat geskep is, die name van **tables** en **columns** en al die **data** wat gestoor is, want jy kan **sensitive information** vind (wat 'n vulnerability sou wees).\
Databases behoort geleë te wees in `/data/data/the.package.name/databases` soos `/data/data/com.mwr.example.sieve/databases`

As die database vertroulike inligting stoor en **encrypted** is maar jy die **password** binne die toepassing kan **find**, is dit steeds 'n **vulnerability**.

E­nume­reer die tables gebruikende `.tables` en e­nume­reer die kolomme van die tables deur `.schema <table_name>` uit te voer

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** laat jou toe om die **role of an Android app** aan te neem en met ander apps te kommunikeer. Dit kan **anything that an installed application can do**, soos die gebruik van Android’s Inter-Process Communication (IPC) meganisme en interaksie met die onderliggende operating system. .\
Drozer is 'n nuttige hulpmiddel om **exploit exported activities, exported services and Content Providers** te doen soos jy in die volgende afdelings sal leer.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Onthou ook dat die kode van 'n activity begin in die **`onCreate`** metodes.

**Authorisation bypass**

Wanneer 'n Activity exported is, kan jy sy skerm vanaf 'n eksterne app aanroep. Daarom, as 'n activity met **sensitive information** exported is, kan jy die **authentication** meganismes **bypass** om toegang daartoe te kry.

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

Jy kan ook 'n exported activity vanaf adb begin:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF sal die gebruik van _**singleTask/singleInstance**_ as `android:launchMode` in 'n activity as kwaadwillig beskou, maar weens [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750) blyk dit net gevaarlik te wees op ou weergawes (API versions < 21).

> [!TIP]
> Neem kennis dat 'n authorisation bypass nie altyd 'n vulnerability is nie; dit hang af van hoe die bypass werk en watter inligting blootgestel word.

**Sensitive information leakage**

**Activities can also return results**. As jy daarin slaag om 'n exported en unprotected activity te vind wat die **`setResult`**-metode aanroep en **sensitiewe inligting teruggee**, kan daar 'n blootstelling van sensitiewe inligting wees.

#### Tapjacking

As Tapjacking nie voorkom word nie, kan jy die exported activity misbruik om die **gebruiker onverwagte aksies te laat uitvoer**. Vir meer inligting oor [**wat Tapjacking is volg die skakel**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Lees dit as jy wil opfris wat 'n Content Provider is.**](android-applications-basics.md#content-provider)\
Content providers word hoofsaaklik gebruik om **data te deel**. As 'n app beskikbare content providers het, kan jy dalk **sensitiewe data onttrek** daaruit. Dit is ook interessant om moontlike **SQL injections** en **Path Traversals** te toets aangesien hulle dalk kwesbaar is.

[**Leer hoe om Content Providers met Drozer te exploit.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Lees dit as jy wil opfris wat 'n Service is.**](android-applications-basics.md#services)\
Onthou dat die handelinge van 'n Service begin in die metode `onStartCommand`.

'n Service is basies iets wat **data kan ontvang**, dit **prosesseer** en **(mag) teruggee** 'n reaksie. Dus, as 'n toepassing sekere services exporteer, moet jy die **kode** nagaan om te verstaan wat dit doen en dit **dynamies** toets om vertroulike inligting te onttrek, authorisation bypasses te probeer, ens.\
[**Leer hoe om Services met Drozer te exploit.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Lees dit as jy wil opfris wat 'n Broadcast Receiver is.**](android-applications-basics.md#broadcast-receivers)\
Onthou dat die handelinge van 'n Broadcast Receiver begin in die metode `onReceive`.

'n Broadcast Receiver sal wag vir 'n tipe boodskap. Afhangend van hoe die receiver die boodskap hanteer, kan dit kwesbaar wees.\
[**Leer hoe om Broadcast Receivers met Drozer te exploit.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Jy kan handmatig vir deep links soek, met hulpmiddels soos MobSF of skripte soos [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Jy kan 'n gedeclareerde **scheme** **open** met **adb** of 'n **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Let op dat jy die **pakketnaam** kan weglaat en die mobiele toestel outomaties die app sal oproep wat daardie skakel moet oopmaak._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Code executed**

Om die **kode wat in die App uitgevoer sal word** te vind, gaan na die activity wat deur die deeplink aangeroep word en soek die funksie **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Sensitive info**

Elke keer as jy 'n deep link vind, kontroleer dat i**dit nie sensitiewe data (soos wagwoorde) via URL parameters ontvang nie**, want enige ander toepassing kan **die deep link naboots en daardie data steel!**

**Parameters in path**

Jy **moet ook kontroleer of enige deep link 'n parameter binne die path gebruik** van die URL soos: `https://api.example.com/v1/users/{username}` , in daardie geval kan jy 'n path traversal dwing deur toegang te verkry tot iets soos: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Let daarop dat as jy die korrekte endpoints binne die toepassing vind, jy moontlik 'n **Open Redirect** (as 'n deel van die path as domeinnaam gebruik word), **account takeover** (as jy gebruikersbesonderhede kan wysig sonder 'n CSRF-token en die kwesbare endpoint die regte metode gebruik het) en enige ander vuln kan veroorsaak. More [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Inspeksie van die Transportlaag en Verifikasie-foute

- **Sertifikate word nie altyd behoorlik ondersoek nie** deur Android-toepassings. Dit is algemeen dat hierdie toepassings waarskuwings ignoreer en self-ondertekende sertifikate aanvaar of, in sommige gevalle, terugval na die gebruik van HTTP-verbindinge.
- **Onderhandelings tydens die SSL/TLS-handskakeling is soms swak**, wat onveilige cipher suites gebruik. Hierdie kwesbaarheid maak die verbinding vatbaar vir man-in-the-middle (MITM)-aanvalle, wat aanvallers in staat stel om die data te ontsleutel.
- **Leakage of private information** is 'n risiko wanneer toepassings met veilige kanaaltjies autentiseer maar dan oor nie-veilige kanale vir ander transaksies kommunikeer. Hierdie benadering beskerm nie sensitiewe data, soos sessiekoekies of gebruikerbesonderhede, teen onderskep deur kwaadwillige entiteite nie.

#### Certificate Verification

Ons sal fokus op **certificate verification**. Die integriteit van die bediener se sertifikaat moet geverifieer word om sekuriteit te verbeter. Dit is noodsaaklik omdat onveilige TLS-konfigurasies en die oordrag van sensitiewe data oor onversleutelde kanale beduidende risiko's kan meebring. Vir gedetailleerde stappe oor die verifikasie van bediener-sertifikate en die aanspreek van kwesbaarhede, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) provides comprehensive guidance.

#### SSL Pinning

SSL Pinning is 'n sekuriteitsmaatreël waar die toepassing die bediener se sertifikaat vergelyk met 'n bekende kopie wat binne die toepassing self gestoor is. Hierdie metode is noodsaaklik om MITM-aanvalle te voorkom. Die implementering van SSL Pinning word sterk aanbeveel vir toepassings wat sensitiewe inligting hanteer.

#### Traffic Inspection

Om HTTP-verkeer te inspekteer, is dit nodig om **die proxy tool se sertifikaat te installeer** (bv. Burp). Sonder die installering van hierdie sertifikaat mag versleutelde verkeer nie deur die proxy sigbaar wees nie. Vir 'n gids oor die installering van 'n pasgemaakte CA-sertifikaat, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Toepassings wat op **API Level 24 and above** mik, vereis wysigings aan die Network Security Config om die proxy se CA-sertifikaat te aanvaar. Hierdie stap is krities vir die inspeksie van versleutelde verkeer. Vir instruksies oor die wysiging van die Network Security Config, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

If **Flutter** is being used you need to to follow the instructions in [**this page**](flutter.md). This is becasue, just adding the certificate into the store won't work as Flutter has its own list of valid CAs.

#### Statiese opsporing van SSL/TLS pinning

Voordat jy runtime-bypasses probeer, karteer vinnig waar pinning in die APK afgedwing word. Statiese ontdekking help jou om hooks/patches te beplan en te fokus op die regte kodepaaie.

Tool: SSLPinDetect
- Open-source statiese-analise nut wat die APK na Smali dekompileer (via apktool) en skandeer vir gekureerde regex-patrone van SSL/TLS pinning-implementasies.
- Rapporteer die presiese lêerpad, reëlnommer, en 'n kodefragment vir elke pas.
- Omvat algemene frameworks en aangepaste kodepaaie: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

Install
- Vereistes: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Gebruik
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Voorbeeld patroonreëls (JSON)

Gebruik of brei signatures uit om proprietary/custom pinning styles op te spoor. Jy kan jou eie JSON laai en op skaal scan.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notas en wenke
- Vinnige skandering van groot apps via multi-threading en memory-mapped I/O; vooraf-gecompileerde regex verminder overhead en vals positiewe resultate.
- Patroonversameling: https://github.com/aancw/smali-sslpin-patterns
- Tipiese opsporingsdoelwitte om daarna te prioritiseer:
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Declarative pins in res/xml network security config and manifest references
- Gebruik die ooreenstemmende lokasies om Frida hooks, statiese pleisters, of konfigu­rasiereviews te beplan voordat jy dinamiese toetse doen.



#### Om SSL Pinning te omseil

As SSL Pinning geïmplementeer is, word dit nodig om dit te omseil om HTTPS-verkeer te inspekteer. Verskeie metodes is beskikbaar vir hierdie doel:

- Outomaties **wysig** die **apk** om SSLPinning te **omseil** met [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Die grootste voordeel van hierdie opsie is dat jy nie root nodig het om SSL Pinning te omseil nie, maar jy sal die toepassing moet verwyder en die nuwe een moet herinstalleer, en dit werk nie altyd nie.
- Jy kan **Frida** (hieronder bespreek) gebruik om hierdie beskerming te omseil. Hier is 'n gids om Burp+Frida+Genymotion te gebruik: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Jy kan ook probeer om **outomaties SSL Pinning te omseil** met [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Jy kan ook probeer om **outomaties SSL Pinning te omseil** deur **MobSF dynamic analysis** te gebruik (hieronder verduidelik)
- As jy steeds dink daar is verkeer wat jy nie vasvang nie, kan jy probeer om die verkeer na burp deur te stuur met iptables. Lees hierdie blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Soek na algemene web-kwesbaarhede

Dit is belangrik om ook na algemene web-kwesbaarhede binne die toepassing te soek. Gedetailleerde inligting oor die identifisering en verligting van hierdie kwesbaarhede val buite die omvang van hierdie opsomming, maar word elders uitvoerig behandel.

### Frida

[Frida](https://www.frida.re) is 'n dinamiese instrumenteringspakket vir ontwikkelaars, reverse-engineers en sekuriteitsnavorsers.\
**Jy kan toegang kry tot 'n lopende toepassing en op runtime methodes hook om die gedrag te verander, waardes te verander, waardes uit te trek, ander kode te laat uitvoer...**\
As jy Android-toepassings wil pentest, moet jy weet hoe om Frida te gebruik.

- Leer hoe om Frida te gebruik: [**Frida tutorial**](frida-tutorial/index.html)
- Sommige "GUI" vir aksies met Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Jy kan hier 'n paar uitstekende Frida-skripte vind: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Probeer om anti-debugging / anti-frida meganismes te omseil deur Frida te laai soos aangedui in [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning omseil werkvloei

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Geheue - Fridump**

Kontroleer of die toepassing sensitiewe inligting in die geheue stoor wat dit nie behoort te stoor nie, soos wagwoorde of mnemonics.

Deur [**Fridump3**](https://github.com/rootbsd/fridump3) te gebruik kan jy die geheue van die app dump met:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Dit sal die memory dump in die gids ./dump, en daarbinne kan jy met iets soos grep soek:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Sensitive data in Keystore**

In Android is die Keystore die beste plek om sensitiewe data te stoor, maar met genoeg voorregte is dit steeds **moontlik om daartoe toegang te kry**. Aangesien toepassings hier geneig is om **sensitiewe data in platte teks** te stoor, behoort pentests dit as root user of iemand met fisiese toegang tot die toestel na te gaan, aangesien hulle hierdie data kan steel.

Selfs as 'n app data in die keystore stoor, moet die data versleuteld wees.

Om toegang tot die data in die keystore te kry, kan jy hierdie Frida script gebruik: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Deur die volgende Frida-skrip te gebruik, is dit moontlik om **bypass fingerprint authentication** wat Android-toepassings moontlik toepas om **sekere sensitiewe gebiede te beskerm:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Agtergrondbeelde**

Wanneer jy 'n toepassing in die agtergrond plaas, stoor Android 'n **snapshot of the application** sodat wanneer dit na die voorgrond herstel word, dit eers die beeld begin laai voordat die app self dit doen, sodat dit lyk asof die app vinniger gelaai is.

As hierdie snapshot egter **sensitiewe inligting** bevat, kan iemand met toegang tot die snapshot daardie inligting **steel** (let wel: jy benodig root om daartoe toegang te kry).

Die snapshots word gewoonlik gestoor by: **`/data/system_ce/0/snapshots`**

Android bied 'n manier om die **screenshot capture** te voorkom deur die FLAG_SECURE layout-parameter te stel. Deur hierdie flag te gebruik, word die vensterinhoud as veilig behandel, wat verhoed dat dit in screenshots verskyn of op nie-veilige skerms besigtig kan word.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Hierdie hulpmiddel kan jou help om verskillende gereedskap tydens die dynamic analysis te bestuur: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Ontwikkelaars skep dikwels proxy-komponente soos activities, services, en broadcast receivers wat hierdie Intents hanteer en dit deurgee aan metodes soos `startActivity(...)` of `sendBroadcast(...)`, wat riskant kan wees.

Die gevaar lê daarin om aanvalleerders toe te laat om nie-geëksporteerde app-komponente of sensitiewe content providers te aktiveer deur hierdie Intents verkeerd te lei. ’n Opvallende voorbeeld is die `WebView` component wat URLs na `Intent`-objekte omskakel via `Intent.parseUri(...)` en dit dan uitvoer, wat moontlik lei tot kwaadwillige Intent-injections.

### Belangrike punte

- **Intent Injection** is soortgelyk aan die web se Open Redirect issue.
- Eksploite behels die deurgee van `Intent`-objekte as extras, wat omgerig kan word om onveilige operasies uit te voer.
- Dit kan nie-geëksporteerde komponente en content providers aan aanvalleerders blootstel.
- `WebView` se URL na `Intent` omskakeling kan onbeplande aksies fasiliteer.

### Android Client Side Injections and others

Jy ken waarskynlik hierdie tipe kwesbaarhede van die Web. Jy moet besonder versigtig wees met hierdie kwesbaarhede in 'n Android-toepassing:

- **SQL Injection:** Wanneer jy te doen het met dinamiese queries of Content-Providers, maak seker jy gebruik geparametriseerde navrae.
- **JavaScript Injection (XSS):** Maak seker dat JavaScript- en Plugin-ondersteuning gedeaktiveer is vir enige WebViews (gedeaktiveer by verstek). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews moet toegang tot die lêerstelsel gedeaktiveer hê (by verstek geaktiveer) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: In verskeie gevalle, wanneer die Android-toepassing die sessie beëindig, word die cookie nie herroep nie of dit kan selfs op skyf gestoor word
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Outomatiese Analise

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Statiese analise**

![](<../../images/image (866).png>)

**Kwetsbaarheidsevaluering van die toepassing** met 'n netjiese webgebaseerde frontend. Jy kan ook dynamic analysis uitvoer (maar jy moet die omgewing voorberei).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Neem kennis dat MobSF Android**(apk)**, IOS**(ipa)** en Windows**(apx)** toepassings kan analiseer (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Ook, as jy 'n **ZIP**-lêer met die bronkode van 'n **Android** of 'n **IOS** app skep (gaan na die root folder van die aplikasie, kies alles en skep 'n ZIPfile), sal dit dit ook kan analiseer.

MobSF laat jou ook toe om analises te **diff/Compare** en om **VirusTotal** te integreer (jy sal jou API sleutel in _MobSF/settings.py_ moet stel en dit aktiveer: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). Jy kan ook `VT_UPLOAD` op `False` stel, dan sal die **hash** in plaas van die lêer **opgelaai** word.

### Geassisteerde dinamiese ontleding met MobSF

**MobSF** kan ook baie nuttig wees vir **dynamiese ontleding** in **Android**, maar in daardie geval moet jy MobSF en **genymotion** op jou host installeer (n VM of Docker sal nie werk nie). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
Die **MobSF dynamic analyser** kan:

- **Dump application data** (URLs, logs, clipboard, skermskote deur jou gemaak, skermskote gemaak deur "**Exported Activity Tester**", e-posse, SQLite databases, XML-lêers en ander geskepte lêers). Dit gebeur alles outomaties behalwe vir die skermskote — jy moet druk wanneer jy 'n skermskoot wil neem of jy moet "**Exported Activity Tester**" druk om skermskote van al die exported activities te bekom.
- Capture **HTTPS traffic**
- Gebruik **Frida** om **runtime** **inligting** te bekom

Vanaf Android **versions > 5**, sal dit **automatically start Frida** en die globale **proxy**-instellings opstel om verkeer te vang. Dit sal slegs verkeer van die getoetste toepassing vang.

**Frida**

Per verstek sal dit ook sommige Frida-skripte gebruik om **bypass SSL pinning**, **root detection** en **debugger detection** te omseil en om **monitor interesting APIs**.\
MobSF kan ook **invoke exported activities**, neem **skermskote** daarvan en **stoor** dit vir die verslag.

Om die dinamiese toetsing te **start** druk die groen knoppie: "**Start Instrumentation**". Druk die "**Frida Live Logs**" om die logs wat deur die Frida-skripte gegenereer is te sien en "**Live API Monitor**" om alle aanroepe na hooked methods, deurgegewe argumente en teruggegewe waardes te sien (dit sal verskyn nadat jy op "Start Instrumentation" gedruk het).\
MobSF laat jou ook toe om jou eie **Frida scripts** te laai (om die resultate van jou Frida-skripte na MobSF te stuur gebruik die funksie `send()`). Dit het ook **several pre-written scripts** wat jy kan laai (jy kan meer byvoeg in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), kies hulle net, druk "**Load**" en druk "**Start Instrumentation**" (jy sal die logs van daardie skripte binne "**Frida Live Logs**" kan sien).

![](<../../images/image (419).png>)

Verder het jy 'n paar bykomende Frida-funksionaliteite:

- **Enumerate Loaded Classes**: Dit sal al die gelaaide klasse druk
- **Capture Strings**: Dit sal al die gevangen strings druk terwyl jy die toepassing gebruik (baie lawaaierig)
- **Capture String Comparisons**: Kan baie nuttig wees. Dit sal **wys die 2 strings wat vergelyk word** en of die resultaat True of False was.
- **Enumerate Class Methods**: Sit die klasnaam (soos "java.io.File") en dit sal al die metodes van die klas druk.
- **Search Class Pattern**: Soek klasse volgens 'n patroon
- **Trace Class Methods**: **Trace** 'n **hele klas** (sien insette en uitsette van alle metodes van die klas). Onthou dat per verstek MobSF verskeie interessante Android Api-metodes trace.

Sodra jy die bykomende module gekies het wat jy wil gebruik, moet jy op "**Start Intrumentation**" druk en jy sal al die uitsette in "**Frida Live Logs**" sien.

**Shell**

MobSF bied ook 'n shell met sommige **adb** commands, **MobSF commands**, en algemene **shell** **commands** onderaan die dynamic analysis bladsy. Sommige interessante commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP gereedskap**

Wanneer HTTP-verkeer opgevang word, kan jy 'n lelike uitsig van die opgevangde verkeer sien op die "**HTTP(S) Traffic**" knop of 'n netjiese uitsig op die groen knop "**Start HTTPTools**". Vanaf die tweede opsie kan jy die **opgevangde versoeke** na **proxies** soos Burp of Owasp ZAP **stuur**.\
Om dit te doen, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> druk "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Sodra jy die dinamiese analise met MobSF voltooi het, kan jy op "**Start Web API Fuzzer**" druk om **http requests te fuzz** en na kwesbaarhede te soek.

> [!TIP]
> Na die uitvoering van 'n dinamiese analise met MobSF kan die proxy-instellings verkeerd gekonfigureer wees en sal jy dit nie vanaf die GUI kan regstel nie. Jy kan die proxy-instellings regmaak deur die volgende te doen:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Geassisteerde dinamiese analise met Inspeckage

You can get the tool from [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Hierdie tool sal sommige **Hooks** gebruik om jou te laat weet **wat in die toepassing aangaan** terwyl jy 'n **dinamiese analise** doen.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Dit is 'n **uitstekende tool om statiese analise met 'n GUI uit te voer**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Hierdie tool is ontwerp om te soek na verskeie **security related Android application vulnerabilities**, óf in **source code** of in **packaged APKs**. Die tool is ook **in staat om 'n "Proof-of-Concept" deployable APK te skep** en **ADB commands**, om sommige van die gevonde kwesbaarhede te exploiteer (Exposed activities, intents, tapjacking...). Soos met Drozer, is daar geen behoefte om die toetsapparaat te root nie.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Wys alle uitgehaalde lêers vir maklike verwysing
- Decompileer APK-lêers outomaties na Java- en Smali-formaat
- Analiseer AndroidManifest.xml vir algemene kwesbaarhede en gedrag
- Statiese bronkode-analise vir algemene kwesbaarhede en gedrag
- Toestelinligting
- en meer
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER is 'n command-line toepassing wat op Windows, MacOS X en Linux gebruik kan word en analiseer _.apk_ lêers op soek na kwesbaarhede. Dit doen dit deur APKs te ontpak en 'n reeks reëls toe te pas om daardie kwesbaarhede op te spoor.

Alle reëls is in 'n `rules.json`-lêer gesentreer, en elke maatskappy of tester kan hul eie reëls skep om te analiseer wat hulle nodig het.

Laai die jongste binaries af vanaf die [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn is 'n **crossplatform** hulpmiddel wat ontwikkelaars, bugbounty hunters en ethical hackers help om [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) op mobiele toepassings uit te voer.

Die konsep is dat jy jou mobiele toepassingslêer ('n .apk of .ipa lêer) op die StaCoAn-toepassing sleep en los, en dit sal 'n visuele en draagbare verslag vir jou genereer. Jy kan die instellings en wordlists aanpas om 'n aangepaste ervaring te kry.

Laai[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework is 'n stelsel vir Android-kwesbaarheidsanalise wat ontwikkelaars of hackers help om potensiële sekuriteitskwesbaarhede in Android-toepassings te vind.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** is 'n hulpmiddel wat hoofsaaklik daarop gemik is om potensieel kwaadwillige gedrag wat deur 'n Android-toepassing ontwikkel is, op te spoor en die gebruiker daaroor te waarsku.

Die opsporing word uitgevoer deur middel van die **static analysis** van die toepassing se Dalvik bytecode, voorgestel as **Smali**, met die [`androguard`](https://github.com/androguard/androguard) biblioteek.

Hierdie hulpmiddel soek na **algemene gedrag van "slegte" toepassings** soos: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is 'n **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. Dit is 'n hulpmiddel wat gereeld gebruikte mobile application reverse engineering- en analysis-tools saamvoeg om te help met die toetsing van mobile applications teen OWASP mobile security threats. Die doel is om hierdie taak makliker en meer gebruikersvriendelik te maak vir mobile application developers en security professionals.

Dit kan:

- Onttrek Java- en Smali-kode met verskeie tools
- Analiseer APKs met: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Onttrek privaat inligting uit die APK met behulp van regexps.
- Analiseer die Manifest.
- Analiseer gevonde domains met: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) en [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuskeer APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Nuttig om malware op te spoor: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Let wel: afhangend van die diens en konfigurasie wat jy gebruik om die kode te obfuskeer, kan secrets wel of nie obfuskeer eindig nie.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is 'n open source command-line tool wat Java-kode verklein, optimaliseer en obfuskeer. Dit kan bytecode optimaliseer en onbruikte instruksies opspoor en verwyder. ProGuard is gratis sagteware en word versprei onder die GNU General Public License, weergawe 2.

ProGuard word as deel van die Android SDK versprei en loop wanneer die aansoek in release mode gebou word.

### [DexGuard](https://www.guardsquare.com/dexguard)

Vind 'n stap-vir-stap gids om die apk te deobfuskeer by [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Laas toe ons gekyk het, was die Dexguard modus van werking:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard keer die proses van obfuskering wat deur Android obfuscation tools uitgevoer is om. Dit stel verskeie security analyses in staat, insluitend kode-inspeksie en die voorspel van libraries.**

Jy kan 'n obfusceerde APK na hul platform oplaai.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

Dit is 'n LLM tool om potensiële security vulnerabilities in android apps te vind en android app kode te deobfuskeer. Gebruik Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

Dit is 'n **generic android deobfuscator.** Simplify **virtually executes an app** om die gedrag te verstaan en probeer dan **die kode te optimaliseer** sodat dit identies gedrag lewer maar makliker vir 'n mens is om te verstaan. Elke optimaliseringstipe is eenvoudig en generies, so dit maak nie saak watter spesifieke tipe obfuscation gebruik is nie.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD gee jou inligting oor **hoe 'n APK gemaak is**. Dit identifiseer baie **compilers**, **packers**, **obfuscators**, en ander vreemde dinge. Dit is die [_PEiD_](https://www.aldeid.com/wiki/PEiD) vir Android.

### Manual

[Lees hierdie handleiding om 'n paar wenke te leer oor hoe om custom obfuscation te reverse](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b is 'n Android security virtual machine gebaseer op ubuntu-mate wat 'n versameling van die nuutste framework, tutorials en labs van verskillende security geeks en navorsers vir reverse engineering en malware analysis insluit.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Dit is 'n uitstekende lys van resources
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android vinnige kursus
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
