# Pentesting aplikacji Android

{{#include ../../banners/hacktricks-training.md}}

## Podstawy aplikacji Android

Zaleca się rozpocząć od przeczytania tej strony, aby poznać **najważniejsze elementy związane z bezpieczeństwem Androida oraz najniebezpieczniejsze komponenty w aplikacji Android**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

To główne narzędzie potrzebne do połączenia z urządzeniem Android (emulowanym lub fizycznym).\
**ADB** umożliwia kontrolę urządzeń zarówno przez **USB**, jak i **Network** z komputera. To narzędzie pozwala na **kopiowanie** plików w obu kierunkach, **instalację** i **deinstalację** aplikacji, **wykonywanie** poleceń shell, **tworzenie kopii zapasowych** danych, **odczytywanie** logów oraz inne funkcje.

Zapoznaj się z następującą listą [**ADB Commands**](adb-commands.md), aby nauczyć się używać adb.

## Smali

Czasami warto **zmodyfikować kod aplikacji**, aby uzyskać dostęp do **ukrytych informacji** (np. dobrze obfuskowanych haseł lub flag). W takim wypadku może być przydatne zdekompilowanie apk, modyfikacja kodu i ponowne skompilowanie.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Może to być bardzo przydatne jako **alternatywa przy wielu testach podczas analizy dynamicznej**, które będą przedstawione. Dlatego **zawsze miej tę możliwość na uwadze**.

## Inne ciekawe triki

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [Android IME / InputMethodService Abuse (Malicious Keyboards)](inputmethodservice-ime-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **Pobieranie APKów**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Wyodrębnij APK z urządzenia:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Scal wszystkie splits i base apks za pomocą [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Android Enterprise & Work Profile Attacks

{{#ref}}
android-enterprise-work-profile-bypass.md
{{#endref}}

## Case Studies & Vulnerabilities


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}


{{#ref}}
../../binary-exploitation/linux-kernel-exploitation/arm64-static-linear-map-kaslr-bypass.md
{{#endref}}

## Static Analysis

Przede wszystkim, analizując APK powinieneś **rzucić okiem na kod Java** używając decompiler'a.\
Proszę, [**przeczytaj tutaj żeby znaleźć informacje o dostępnych decompilerach**](apk-decompilers.md).

### Looking for interesting Info

Wystarczy spojrzeć na **strings** APK, aby wyszukać **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** i inne interesujące rzeczy... szukaj również kodu wykonującego się jako **backdoors** lub backdoorów uwierzytelniania (hardcoded admin credentials w aplikacji).

**Firebase**

Zwróć szczególną uwagę na **firebase URLs** i sprawdź, czy nie jest źle skonfigurowany. [More information about whats is FIrebase and how to exploit it here.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Basic understanding of the application - Manifest.xml, strings.xml

**Examination of an application's _Manifest.xml_ and **_strings.xml_** files can reveal potential security vulnerabilities**. Te pliki można uzyskać używając decompilerów lub przez zmianę rozszerzenia APK na .zip i rozpakowanie go.

**Vulnerabilities** identyfikowane z **Manifest.xml** obejmują:

- **Debuggable Applications**: Aplikacje ustawione jako debuggable (`debuggable="true"`) w pliku _Manifest.xml_ stanowią ryzyko, ponieważ pozwalają na połączenia, które mogą prowadzić do exploitów. Aby lepiej zrozumieć jak exploitować debuggable applications, odnieś się do tutorialu o znajdowaniu i exploitowaniu debuggable applications na urządzeniu.
- **Backup Settings**: Atrybut `android:allowBackup="false"` powinien być ustawiony jawnie dla aplikacji przetwarzających wrażliwe informacje, aby zapobiec nieautoryzowanym backupom danych przez adb, zwłaszcza gdy usb debugging jest włączony.
- **Network Security**: Niestandardowe konfiguracje bezpieczeństwa sieci (`android:networkSecurityConfig="@xml/network_security_config"`) w _res/xml/_ mogą określać szczegóły bezpieczeństwa takie jak certificate pins i ustawienia ruchu HTTP. Przykładem jest zezwolenie na HTTP traffic dla określonych domen.
- **Exported Activities and Services**: Identyfikacja exported activities and services w manifeście może ujawnić komponenty, które mogą być niewłaściwie użyte. Dalsza analiza podczas dynamic testing może odkryć jak exploitować te komponenty.
- **Content Providers and FileProviders**: Udostępnione content providers mogą pozwolić na nieautoryzowany dostęp lub modyfikację danych. Konfiguracja FileProviders powinna być również dokładnie przeanalizowana.
- **Broadcast Receivers and URL Schemes**: Te komponenty mogą być wykorzystane do exploitów, ze szczególną uwagą na to, jak URL schemes są obsługiwane pod kątem podatności na input.
- **SDK Versions**: Atrybuty `minSdkVersion`, `targetSDKVersion` i `maxSdkVersion` wskazują obsługiwane wersje Androida, podkreślając znaczenie nieobsługiwania przestarzałych, podatnych wersji Androida z punktu widzenia bezpieczeństwa.

Z pliku **strings.xml** można odkryć wrażliwe informacje takie jak **API keys**, custom schemas i inne notatki deweloperskie, co podkreśla potrzebę dokładnego przeglądu tych zasobów.

### Tapjacking

**Tapjacking** to atak, w którym **malicious** **application** jest uruchamiana i **pozycjonuje się nad aplikacją ofiary**. Gdy widocznie zasłania aplikację ofiary, jego interfejs użytkownika jest zaprojektowany tak, by oszukać użytkownika, aby wchodził w interakcję z nim, podczas gdy interakcja jest przekazywana do aplikacji ofiary.\
W efekcie, jest to **oślepianie użytkownika, który nie wie, że faktycznie wykonuje akcje w aplikacji ofiary**.

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

An **activity** with the **`launchMode`** set to **`singleTask` without any `taskAffinity`** defined is vulnerable to task Hijacking. This means, that an **application** can be installed and if launched before the real application it could **hijack the task of the real application** (so the user will be interacting with the **malicious application thinking he is using the real one**).

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Insecure data storage

**Internal Storage**

W Androidzie pliki **przechowywane** w **internal** storage są **zaprojektowane** tak, aby były **dostępne wyłącznie** dla **aplikacji**, która je **utworzyła**. Ten mechanizm bezpieczeństwa jest **egzekwowany** przez system Android i zwykle wystarcza dla potrzeb bezpieczeństwa większości aplikacji. Jednak deweloperzy czasami używają trybów takich jak `MODE_WORLD_READABLE` i `MODE_WORLD_WRITABLE`, aby **pozwolić** na współdzielenie plików między różnymi aplikacjami. Te tryby **nie ograniczają dostępu** do tych plików przez inne aplikacje, w tym potencjalnie złośliwe.

1. **Static Analysis:**
- **Ensure** że użycie `MODE_WORLD_READABLE` i `MODE_WORLD_WRITABLE` jest **dokładnie przeanalizowane**. Te tryby **mogą potencjalnie ujawnić** pliki do **niezamierzonego lub nieautoryzowanego dostępu**.
2. **Dynamic Analysis:**
- **Verify** uprawnienia ustawione na plikach tworzonych przez aplikację. W szczególności **sprawdź**, czy jakiekolwiek pliki nie są ustawione jako czytelne lub zapisywalne dla wszystkich. To może stanowić poważne ryzyko bezpieczeństwa, ponieważ pozwoliłoby to **każdej aplikacji** zainstalowanej na urządzeniu, niezależnie od jej pochodzenia czy intencji, **czytać lub modyfikować** te pliki.

**External Storage**

Przy pracy z plikami na **external storage**, takimi jak SD Cards, należy zachować ostrożność:

1. **Accessibility**:
- Pliki na external storage są **globalnie czytelne i zapisywalne**. Oznacza to, że każda aplikacja lub użytkownik może mieć do nich dostęp.
2. **Security Concerns**:
- Ze względu na łatwość dostępu, zaleca się **nie przechowywać poufnych informacji** na external storage.
- External storage może zostać usunięty lub dostęp do niego może uzyskać dowolna aplikacja, co czyni go mniej bezpiecznym.
3. **Handling Data from External Storage**:
- Zawsze **przeprowadzaj walidację inputu** na danych pobieranych z external storage. To jest kluczowe, ponieważ dane pochodzą ze źródła nieufnego.
- Przechowywanie plików wykonywalnych lub class files na external storage w celu dynamicznego ładowania jest zdecydowanie odradzane.
- Jeśli Twoja aplikacja musi pobierać pliki wykonywalne z external storage, upewnij się, że pliki te są **signed i weryfikowane kryptograficznie** przed dynamicznym ładowaniem. Ten krok jest niezbędny dla zachowania integralności bezpieczeństwa aplikacji.

External storage można **dostępować** w /storage/emulated/0 , /sdcard , /mnt/sdcard

> [!TIP]
> Starting with Android 4.4 (**API 17**), the SD card has a directory structure which **limits access from an app to the directory which is specifically for that app**. This prevents malicious application from gaining read or write access to another app's files.

**Sensitive data stored in clear-text**

- **Shared preferences**: Android allows każdej aplikacji łatwo zapisywać xml files w ścieżce /data/data/<packagename>/shared_prefs/ i czasami można znaleźć wrażliwe informacje w clear-text w tym folderze.
- **Databases**: Android allows każdej aplikacji łatwo zapisywać sqlite databases w ścieżce /data/data/<packagename>/databases/ i czasami można znaleźć wrażliwe informacje w clear-text w tym folderze.

### Broken TLS

**Accept All Certificates**

For some reason sometimes developers accept all the certificates even if for example the hostname does not match with lines of code like the following one:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Błędna kryptografia

**Słabe procesy zarządzania kluczami**

Niektórzy deweloperzy zapisują dane wrażliwe w lokalnym storage i szyfrują je kluczem hardcoded/predictable w kodzie. Nie powinno się tego robić, ponieważ pewne reversing może pozwolić atakującym na wyciągnięcie poufnych informacji.

**Użycie niebezpiecznych i/lub przestarzałych algorytmów**

Deweloperzy nie powinni używać **deprecated algorithms** do wykonywania autoryzacyjnych **checks**, **store** lub **send** danych. Niektóre z tych algorytmów to: RC4, MD4, MD5, SHA1... Jeśli **hashes** są używane do przechowywania haseł na przykład, należy używać hashes odpornych na brute-force z saltą.

### Inne sprawdzenia

- Zaleca się **obfuscate the APK**, aby utrudnić pracę reverse engineerom.
- Jeśli aplikacja jest wrażliwa (np. aplikacje bankowe), powinna wykonać własne **checks to see if the mobile is rooted** i działać odpowiednio.
- Jeśli aplikacja jest wrażliwa (np. aplikacje bankowe), powinna sprawdzać, czy używany jest **emulator**.
- Jeśli aplikacja jest wrażliwa (np. aplikacje bankowe), powinna **check it's own integrity before executing**, aby zweryfikować, czy nie została zmodyfikowana.
- Use [**APKiD**](https://github.com/rednaga/APKiD) to check which compiler/packer/obfuscator was used to build the APK

### Aplikacja React Native

Przeczytaj następującą stronę, aby nauczyć się, jak łatwo uzyskać dostęp do kodu javascript aplikacji React:


{{#ref}}
react-native-application.md
{{#endref}}

### Aplikacje Xamarin

Przeczytaj następującą stronę, aby dowiedzieć się, jak łatwo uzyskać dostęp do kodu C# aplikacji xamarin:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automatyczna analiza statyczna kodu

The tool [**mariana-trench**](https://github.com/facebook/mariana-trench) is capable of finding **vulnerabilities** by **scanning** the **code** of the application. This tool contains a series of **known sources** (that indicates to the tool the **places** where the **input** is **controlled by the user**), **sinks** (which indicates to the tool **dangerous** **places** where malicious user input could cause damages) and **rules**. These rules indicates the **combination** of **sources-sinks** that indicates a vulnerability.

With this knowledge, **mariana-trench will review the code and find possible vulnerabilities on it**.

### Sekrety ujawnione

Aplikacja może zawierać sekrety (API keys, passwords, hidden urls, subdomains...) w swoim wnętrzu, które możesz być w stanie odkryć. Możesz użyć narzędzia takiego jak [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Inne interesujące funkcje

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Przeczytaj to, aby dowiedzieć się **how to reverse native functions**](reversing-native-libraries.md)
- In-memory native code execution via JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Inne sztuczki**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Analiza dynamiczna

> Przede wszystkim potrzebujesz środowiska, w którym możesz zainstalować aplikację i całe środowisko (głównie Burp CA cert, Drozer i Frida). Dlatego zdecydowanie zalecane jest urządzenie z rootem (emulowane lub nie).

### Online analiza dynamiczna

You can create a **free account** in: [https://appetize.io/](https://appetize.io). This platform allows you to **upload** and **execute** APKs, so it is useful to see how an apk is behaving.

You can even **see the logs of your application** in the web and connect through **adb**.

![](<../../images/image (831).png>)

Thanks to the ADB connection you can use **Drozer** and **Frida** inside the emulators.

### Lokalna analiza dynamiczna

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (You can create **x86** and **arm** devices, and according to [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** versions **support ARM libraries** without needing an slow arm emulator).
- Learn to set it up in this page:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, you need to create an account. _It's recommend to **download** the version **WITH**_ _**VirtualBox** to avoid potential errors._)
- [**Nox**](https://es.bignox.com) (Free, but it doesn't support Frida or Drozer).

> [!TIP]
> When creating a new emulator on any platform remember that the bigger the screen is, the slower the emulator will run. So select small screens if possible.

To **install google services** (like AppStore) in Genymotion you need to click on the red marked button of the following image:

![](<../../images/image (277).png>)

Also, notice that in the **configuration of the Android VM in Genymotion** you can select **Bridge Network mode** (this will be useful if you will be connecting to the Android VM from a different VM with the tools).

#### Use a physical device

You need to activate the **debugging** options and it will be cool if you can **root** it:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Once you have installed the application, the first thing you should do is to try it and investigate what does it do, how does it work and get comfortable with it.\
> I will suggest to **perform this initial dynamic analysis using MobSF dynamic analysis + pidcat**, so we will be able to **learn how the application works** while MobSF **captures** a lot of **interesting** **data** you can review later on.

Magisk/Zygisk quick notes (recommended on Pixel devices)
- Patch boot.img with the Magisk app and flash via fastboot to get systemless root
- Enable Zygisk + DenyList for root hiding; consider LSPosed/Shamiko when stronger hiding is required
- Keep original boot.img to recover from OTA updates; re-patch after each OTA
- For screen mirroring, use scrcpy on the host



### Niezamierzone wycieki danych

**Logging**

Deweloperzy powinni uważać na ujawnianie informacji debugowych publicznie, ponieważ może to prowadzić do wycieku danych wrażliwych. Narzędzia [**pidcat**](https://github.com/JakeWharton/pidcat) i `adb logcat` są rekomendowane do monitorowania logów aplikacji, aby zidentyfikować i zabezpieczyć informacje wrażliwe. **Pidcat** jest preferowany ze względu na łatwość użycia i czytelność.

> [!WARNING]
> Note that from **later newer than Android 4.0**, **applications are only able to access their own logs**. So applications cannot access other apps logs.\
> Anyway, it's still recommended to **not log sensitive information**.

**Copy/Paste Buffer Caching**

Androidowy framework oparty na **clipboard-based** umożliwia funkcje kopiuj-wklej w aplikacjach, jednak stwarza ryzyko, ponieważ **inne aplikacje** mogą **access** schowek i potencjalnie ujawnić dane wrażliwe. Kluczowe jest wyłączenie funkcji copy/paste dla wrażliwych sekcji aplikacji, takich jak dane karty kredytowej, aby zapobiec wyciekom.

**Crash Logs**

Jeśli aplikacja **crashuje** i **zapisuje logi**, te logi mogą pomóc atakującym, szczególnie gdy aplikacja nie może zostać odwrócona (reverse-engineered). Aby zmniejszyć to ryzyko, unikaj logowania przy awariach, a jeśli logi muszą być przesyłane przez sieć, upewnij się, że są wysyłane przez kanał SSL.

As pentester, **try to take a look to these logs**.

**Analytics Data Sent To 3rd Parties**

Aplikacje często integrują usługi takie jak Google Adsense, które mogą nieumyślnie **leak** dane wrażliwe z powodu niewłaściwej implementacji przez deweloperów. Aby zidentyfikować potencjalne wycieki danych, warto **intercept the application's traffic** i sprawdzić, czy jakiekolwiek wrażliwe informacje są wysyłane do usług third-party.

### SQLite DBs

Większość aplikacji używa **internal SQLite databases** do zapisywania informacji. Podczas pentestu przejrzyj **databases** tworzone przez aplikację, nazwy **tables** i **columns** oraz wszystkie zapisane **data**, ponieważ możesz znaleźć **sensitive information** (co stanowiłoby podatność).\
Databases powinny znajdować się w /data/data/the.package.name/databases jak /data/data/com.mwr.example.sieve/databases

Jeśli baza danych zapisuje informacje poufne i jest **encrypted** ale możesz **find** hasło wewnątrz aplikacji, to nadal jest to **vulnerability**.

Enumerate the tables using `.tables` and enumerate the columns of the tables doing `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer is s useful tool to **exploit exported activities, exported services and Content Providers** as you will learn in the following sections.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Also remember that the code of an activity starts in the **`onCreate`** method.

**Authorisation bypass**

When an Activity is exported you can invoke its screen from an external app. Therefore, if an activity with **sensitive information** is **exported** you could **bypass** the **authentication** mechanisms **to access it.**

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

You can also start an exported activity from adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> Zwróć uwagę, że an authorisation bypass nie zawsze jest a vulnerability — zależy to od sposobu działania bypassu i tego, jakie informacje są ujawnione.

**Sensitive information leakage**

**Aktywności mogą również zwracać wyniki**. Jeśli uda Ci się znaleźć eksportowaną i niechronioną aktywność wywołującą metodę **`setResult`** i **zwracającą wrażliwe informacje**, dochodzi do wycieku wrażliwych informacji.

#### Tapjacking

Jeśli Tapjacking nie jest zapobiegany, możesz wykorzystać eksportowaną aktywność, aby spowodować, że **użytkownik wykona nieoczekiwane działania**. Więcej informacji o [**czym jest Tapjacking — zobacz link**](#tapjacking).

### Wykorzystywanie Content Providers - dostęp i manipulacja wrażliwymi informacjami

[**Przeczytaj to, jeśli chcesz odświeżyć, czym jest Content Provider.**](android-applications-basics.md#content-provider)\
Content providers służą zasadniczo do **udostępniania danych**. Jeśli aplikacja ma dostępne content providers, możesz być w stanie **wyodrębnić wrażliwe** dane z nich. Warto też przetestować możliwe **SQL injections** i **Path Traversals**, ponieważ mogą być podatne.

[**Dowiedz się, jak eksploatować Content Providers za pomocą Drozer.**](drozer-tutorial/index.html#content-providers)

### **Wykorzystywanie Services**

[**Przeczytaj to, jeśli chcesz odświeżyć, czym jest Service.**](android-applications-basics.md#services)\
Pamiętaj, że działania Service zaczynają się w metodzie `onStartCommand`.

Service to w zasadzie komponent, który **może otrzymywać dane**, **przetwarzać** je i **zwracać** (lub nie) odpowiedź. Jeśli aplikacja eksportuje jakieś services, powinieneś **sprawdzić** **kod**, aby zrozumieć, co on robi, i **przetestować** go **dynamicznie** w celu wydobycia poufnych informacji, obejścia zabezpieczeń uwierzytelniania...\
[**Dowiedz się, jak eksploatować Services za pomocą Drozer.**](drozer-tutorial/index.html#services)

### **Wykorzystywanie Broadcast Receivers**

[**Przeczytaj to, jeśli chcesz odświeżyć, czym jest Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Pamiętaj, że działania Broadcast Receivera zaczynają się w metodzie `onReceive`.

Broadcast Receiver będzie oczekiwać na określony typ komunikatu. W zależności od tego, jak odbiornik obsługuje wiadomość, może być podatny.\
[**Dowiedz się, jak eksploatować Broadcast Receivers za pomocą Drozer.**](#exploiting-broadcast-receivers)

### **Wykorzystywanie Schemes / Deep links**

Możesz wyszukać deep links ręcznie, używając narzędzi takich jak MobSF lub skryptów takich jak [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Możesz **otworzyć** zadeklarowany **scheme** używając **adb** lub **przeglądarki**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Zauważ, że możesz **pominąć nazwę pakietu**, a urządzenie mobilne automatycznie uruchomi aplikację, która powinna otworzyć ten link._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Kod wykonywany**

Aby znaleźć **kod, który zostanie wykonany w App**, przejdź do activity wywoływanej przez deeplink i wyszukaj funkcję **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Wrażliwe informacje**

Za każdym razem, gdy znajdziesz deep link, sprawdź, czy **nie otrzymuje wrażliwych danych (np. haseł) przez parametry URL**, ponieważ każda inna aplikacja mogłaby **podszyć się pod deep link i ukraść te dane!**

**Parametry w ścieżce**

Musisz również sprawdzić, czy którykolwiek deep link **używa parametru wewnątrz ścieżki** URL, np.: `https://api.example.com/v1/users/{username}` — w takim przypadku możesz wymusić path traversal, uzyskując dostęp do czegoś w rodzaju: `example://app/users?username=../../unwanted-endpoint%3fparam=value`.  
Zauważ, że jeśli znajdziesz odpowiednie endpoints w aplikacji, możesz spowodować **Open Redirect** (jeśli część ścieżki jest używana jako nazwa domeny), **account takeover** (jeśli możesz modyfikować dane użytkowników bez CSRF token i podatny endpoint używał właściwej metody) oraz inne vuln. Więcej informacji znajdziesz [tutaj](http://dphoeniixx.com/2020/12/13-2/).

**Więcej przykładów**

Ciekawe zgłoszenie bug bounty: [interesting bug bounty report](https://hackerone.com/reports/855618) o linkach (_/.well-known/assetlinks.json_).

### Inspekcja warstwy transportowej i błędy weryfikacji

- **Certyfikaty nie zawsze są inspekcjonowane poprawnie** przez aplikacje Android. Często aplikacje ignorują ostrzeżenia i akceptują samopodpisane certyfikaty lub, w niektórych przypadkach, przechodzą na połączenia HTTP.
- **Negocjacje podczas SSL/TLS handshake bywają czasami słabe**, wykorzystując niebezpieczne zestawy szyfrów. Ta podatność naraża połączenie na ataki man-in-the-middle (MITM), umożliwiając atakującym odszyfrowanie danych.
- **Wycieki prywatnych informacji** są ryzykiem, gdy aplikacje uwierzytelniają się przy użyciu bezpiecznych kanałów, ale następnie komunikują się przez kanały nieszyfrowane dla innych operacji. Takie podejście nie chroni wrażliwych danych, takich jak session cookies czy dane użytkownika, przed przechwyceniem przez złośliwe podmioty.

#### Weryfikacja certyfikatu

Skoncentrujemy się na **weryfikacji certyfikatu**. Integralność certyfikatu serwera musi być zweryfikowana, aby zwiększyć bezpieczeństwo. To jest kluczowe, ponieważ niebezpieczne konfiguracje TLS i przesyłanie wrażliwych danych przez niezaszyfrowane kanały mogą stanowić poważne zagrożenie. Dla szczegółowych kroków dotyczących weryfikacji certyfikatów serwera i usuwania podatności, [**to źródło**](https://manifestsecurity.com/android-application-security-part-10/) zapewnia obszerne wskazówki.

#### SSL Pinning

SSL Pinning jest mechanizmem zabezpieczeń, w którym aplikacja weryfikuje certyfikat serwera względem znanej kopii przechowywanej w samej aplikacji. Ta metoda jest niezbędna do zapobiegania atakom MITM. Zdecydowanie zaleca się implementację SSL Pinning w aplikacjach obsługujących wrażliwe informacje.

#### Inspekcja ruchu

Aby analizować ruch HTTP, konieczne jest **zainstalowanie certyfikatu narzędzia proxy** (np. Burp). Bez zainstalowania tego certyfikatu zaszyfrowany ruch może być niewidoczny przez proxy. Po przewodnik dotyczący instalacji niestandardowego certyfikatu CA, [**kliknij tutaj**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Aplikacje targetujące **API Level 24 and above** wymagają modyfikacji Network Security Config, aby zaakceptować certyfikat CA proxy. Ten krok jest krytyczny do inspekcji zaszyfrowanego ruchu. Instrukcje dotyczące modyfikacji Network Security Config znajdziesz w [**tym tutorialu**](make-apk-accept-ca-certificate.md).

Jeśli używane jest **Flutter**, musisz postępować zgodnie z instrukcjami na [**tej stronie**](flutter.md). Wynika to z faktu, że samo dodanie certyfikatu do store nie zadziała, ponieważ Flutter ma własną listę zaufanych CA.

#### Statyczne wykrywanie SSL/TLS pinning

Zanim spróbujesz obejść mechanizmy w czasie wykonywania, szybko zmapuj miejsca, w których pinning jest egzekwowany w APK. Statyczne odkrywanie pomaga zaplanować hooki/patchy i skupić się na właściwych ścieżkach kodu.

Tool: SSLPinDetect
- Narzędzie open-source do analizy statycznej, które dekompiluje APK do Smali (via apktool) i skanuje pod kątem dobranych wzorców regex implementacji SSL/TLS pinning.
- Raportuje dokładną ścieżkę pliku, numer linii i fragment kodu dla każdego dopasowania.
- Obejmuje powszechne frameworki i niestandardowe ścieżki kodu: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, oraz Network Security Config XML pins.

Instalacja
- Wymagania wstępne: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Użycie
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Przykładowe reguły wzorców (JSON)
Użyj lub rozszerz signatures, aby wykryć proprietary/custom pinning styles. Możesz załadować własne JSON i skanować na dużą skalę.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notatki i wskazówki
- Szybkie skanowanie dużych aplikacji za pomocą wielowątkowości (multi-threading) i wejścia/wyjścia zmapowanego w pamięci (memory-mapped I/O); wstępnie skompilowane regex zmniejszają narzut i liczbę false positives.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Typowe cele do dalszej weryfikacji:
- OkHttp: użycie CertificatePinner, setCertificatePinner, odniesienia do pakietu okhttp3/okhttp
- Custom TrustManagers: javax.net.ssl.X509TrustManager, override'y checkServerTrusted
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init z custom managers
- Declarative pins w res/xml network security config i odniesienia w manifeście
- Wykorzystaj dopasowane lokalizacje do zaplanowania Frida hooks, patchy statycznych lub przeglądu konfiguracji przed testami dynamicznymi.



#### Ominięcie SSL Pinning

Gdy SSL Pinning jest zaimplementowany, konieczne staje się jego ominięcie, aby przeanalizować ruch HTTPS. Do tego celu dostępne są różne metody:

- Automatycznie **zmodyfikować** the **apk** aby **obejść** SSLPinning za pomocą [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Największą zaletą tej opcji jest to, że nie potrzebujesz root do obejścia SSL Pinning, ale będziesz musiał usunąć aplikację i zainstalować ją ponownie, i nie zawsze to zadziała.
- Możesz użyć **Frida** (omówione poniżej) aby obejść tę protekcję. Tutaj jest poradnik do użycia Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Możesz też spróbować **automatycznie obejść SSL Pinning** używając [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Możesz też spróbować **automatycznie obejść SSL Pinning** używając **MobSF dynamic analysis** (opisane poniżej)
- Jeśli nadal uważasz, że istnieje ruch, którego nie przechwytujesz, możesz spróbować **przekierować ruch do burp używając iptables**. Przeczytaj ten wpis: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Wyszukiwanie typowych podatności webowych

Ważne jest również przeszukanie aplikacji pod kątem typowych podatności webowych. Szczegółowe informacje dotyczące identyfikacji i łagodzenia tych podatności wykraczają poza zakres tego podsumowania, ale są szeroko omówione w innych źródłach.

### Frida

[Frida](https://www.frida.re) jest dynamicznym toolkitem do instrumentacji dla developerów, reverse-engineerów i badaczy bezpieczeństwa.\
**Możesz uzyskać dostęp do działającej aplikacji i hookować metody w czasie wykonania, aby zmieniać zachowanie, modyfikować wartości, ekstraktować dane, uruchamiać inny kod...**\
Jeśli chcesz pentestować aplikacje Android musisz wiedzieć jak używać Frida.

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Some "GUI" for actions with Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- You can find some Awesome Frida scripts here: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Spróbuj obejść mechanizmy anti-debugging / anti-frida ładując Frida zgodnie z opisem w [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (narzędzie [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Zrzucanie pamięci - Fridump**

Sprawdź, czy aplikacja nie przechowuje w pamięci wrażliwych informacji, których nie powinna przechowywać, takich jak hasła lub mnemonic phrases.

Using [**Fridump3**](https://github.com/rootbsd/fridump3) you can dump the memory of the app with:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
To wykona dump memory w folderze ./dump, a następnie możesz użyć grep, np.:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Dane wrażliwe w Keystore**

W Androidzie Keystore jest najlepszym miejscem do przechowywania danych wrażliwych, jednak przy odpowiednich uprawnieniach nadal **możliwe jest uzyskać do niego dostęp**. Ponieważ aplikacje mają tendencję do przechowywania tutaj **dane wrażliwe w clear text**, pentesty powinny to sprawdzać, ponieważ root user lub ktoś z fizycznym dostępem do urządzenia mógłby ukraść te dane.

Nawet jeśli aplikacja przechowywała dane w keystore, powinny być one zaszyfrowane.

Aby uzyskać dostęp do danych wewnątrz keystore możesz użyć tego skryptu Frida: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Używając poniższego Frida script, możliwe będzie **bypass fingerprint authentication**, które aplikacje Android stosują, aby **chronić określone wrażliwe obszary:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Obrazy w tle**

Kiedy umieścisz aplikację w tle, Android zapisuje migawkę aplikacji, dzięki czemu po przywróceniu jej na pierwszy plan system najpierw ładuje obraz — wygląda to, jakby aplikacja wczytała się szybciej.

Jednakże, jeśli ta migawka zawiera poufne informacje, osoba mająca dostęp do migawki może je ukraść (zwróć uwagę, że wymagany jest root, aby uzyskać do niej dostęp).

Migawki są zazwyczaj przechowywane w: **`/data/system_ce/0/snapshots`**

Android zapewnia sposób, by zapobiec przechwytywaniu zrzutów ekranu przez ustawienie parametru układu FLAG_SECURE. Używając tej flagi, zawartość okna jest traktowana jako zabezpieczona, co uniemożliwia jej pojawienie się na zrzutach ekranu lub wyświetlanie na niezabezpieczonych wyświetlaczach.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Analizator aplikacji Android**

To narzędzie może pomóc w zarządzaniu różnymi narzędziami podczas analizy dynamicznej: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Programiści często tworzą komponenty-proxy takie jak activities, services i broadcast receivers, które obsługują te Intents i przekazują je do metod takich jak `startActivity(...)` lub `sendBroadcast(...)`, co może być niebezpieczne.

Niebezpieczeństwo polega na umożliwieniu atakującym wywołania nieeksportowanych komponentów aplikacji lub dostępu do wrażliwych content providers przez przekierowanie tych Intentów. Dobrym przykładem jest komponent `WebView` konwertujący URL-e na obiekty `Intent` za pomocą `Intent.parseUri(...)` i następnie je wykonujący, co może prowadzić do złośliwych Intent injections.

### Kluczowe wnioski

- **Intent Injection** jest podobny do webowego problemu Open Redirect.
- Eksploity polegają na przekazywaniu obiektów `Intent` jako extras, które mogą zostać przekierowane, by wykonać niebezpieczne operacje.
- Może ujawnić nieeksportowane komponenty i content providers atakującym.
- Konwersja URL → `Intent` przez `WebView` może umożliwić niezamierzone akcje.

### Android Client Side Injections and others

Prawdopodobnie znasz tego rodzaju podatności z Weba. Należy zachować szczególną ostrożność względem tych podatności w aplikacji Android:

- **SQL Injection:** Podczas pracy z dynamicznymi zapytaniami lub Content-Providers upewnij się, że używasz zapytań parametryzowanych.
- **JavaScript Injection (XSS):** Upewnij się, że obsługa JavaScript i Pluginów jest wyłączona dla wszystkich WebViews (domyślnie wyłączona). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews powinny mieć dostęp do systemu plików wyłączony (domyślnie włączony) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: W kilku przypadkach, gdy aplikacja Android kończy sesję, cookie nie jest unieważniane lub może być nawet zapisane na dysku
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatyczna analiza

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Analiza statyczna**

![](<../../images/image (866).png>)

**Ocena podatności aplikacji** za pomocą ładnego webowego frontendu. Możesz także przeprowadzić analizę dynamiczną (ale musisz przygotować środowisko).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Zauważ, że MobSF może analizować **Android**(apk)**, IOS**(ipa) **and Windows**(apx) aplikacje (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Również, jeśli utworzysz plik **ZIP** ze źródłami aplikacji **Android** lub **IOS** (wejdź do katalogu głównego aplikacji, zaznacz wszystko i utwórz ZIPfile), będzie on w stanie przeanalizować także taki plik.

MobSF pozwala również na **diff/Compare** analiz oraz integrację z **VirusTotal** (musisz ustawić swój klucz API w _MobSF/settings.py_ i włączyć go: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). Możesz też ustawić `VT_UPLOAD` na `False`, wtedy zamiast pliku zostanie przesłany **hash**.

### Assisted Dynamic analysis with MobSF

**MobSF** może być także bardzo pomocny przy **dynamic analysis** w **Android**, ale w tym przypadku musisz zainstalować MobSF i **genymotion** na hoście (VM lub Docker nie zadziałają). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
**MobSF dynamic analyser** może:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). Wszystko to jest wykonywane automatycznie z wyjątkiem zrzutów ekranu — musisz nacisnąć, gdy chcesz zrobić zrzut ekranu, lub nacisnąć "**Exported Activity Tester**", aby uzyskać zrzuty wszystkich eksportowanych aktywności.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

Dla wersji android **> 5**, automatycznie uruchomi **Frida** i ustawi globalne ustawienia proxy, aby **capture** ruch. Będzie przechwytywać ruch tylko z testowanej aplikacji.

**Frida**

Domyślnie użyje też kilku Frida Scripts do **bypass SSL pinning**, **root detection** i **debugger detection** oraz do **monitor interesting APIs**.\
MobSF może także **invoke exported activities**, zrobić **screenshots** tych aktywności i **save** je do raportu.

Aby **start** testy dynamiczne naciśnij zielony przycisk: "**Start Instrumentation**". Naciśnij "**Frida Live Logs**", aby zobaczyć logi wygenerowane przez skrypty Frida oraz "**Live API Monitor**", aby zobaczyć wszystkie wywołania hookowanych metod, przekazane argumenty i zwrócone wartości (pojawi się to po naciśnięciu "Start Instrumentation").\
MobSF pozwala również załadować własne skrypty **Frida** (aby wysłać wyniki swoich Frida scripts do MobSF użyj funkcji `send()`). Ma też kilka predefiniowanych skryptów, które możesz załadować (możesz dodać więcej w `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), wystarczy je **select**, nacisnąć "**Load**" i potem "**Start Instrumentation**" (będziesz mógł zobaczyć logi tych skryptów w "**Frida Live Logs**").

![](<../../images/image (419).png>)

Ponadto masz kilka pomocniczych funkcji Frida:

- **Enumerate Loaded Classes**: Wypisze wszystkie załadowane klasy
- **Capture Strings**: Wypisze wszystkie przechwycone stringi podczas używania aplikacji (bardzo hałaśliwe)
- **Capture String Comparisons**: Może być bardzo przydatne. **Pokaże 2 porównywane stringi** i czy wynik był True czy False.
- **Enumerate Class Methods**: Wprowadź nazwę klasy (np. "java.io.File") i wypisze wszystkie metody tej klasy.
- **Search Class Pattern**: Wyszukuj klasy według wzorca
- **Trace Class Methods**: **Trace** całej klasy (zobacz wejścia i wyjścia wszystkich metod klasy). Pamiętaj, że domyślnie MobSF śledzi kilka interesujących metod Android API.

Gdy wybierzesz moduł pomocniczy, którego chcesz użyć, musisz nacisnąć "**Start Instrumentation**" i zobaczysz wszystkie wyjścia w "**Frida Live Logs**".

**Shell**

Mobsf udostępnia też shell z kilkoma poleceniami **adb**, poleceniami **MobSF** oraz zwykłymi poleceniami **shell** na dole strony dynamic analysis. Kilka interesujących poleceń:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**Narzędzia HTTP**

Kiedy ruch HTTP jest przechwycony, możesz zobaczyć surowy widok przechwyconego ruchu w dolnym przycisku "**HTTP(S) Traffic**" lub ładniejszy widok w zielonym przycisku "**Start HTTPTools**". Z drugiej opcji możesz **wysłać** **przechwycone żądania** do **proxies** takich jak Burp lub Owasp ZAP.\
Aby to zrobić, _włącz Burp -->_ _wyłącz Intercept --> w MobSB HTTPTools wybierz żądanie_ --> naciśnij "**Send to Fuzzer**" --> _wybierz adres proxy_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Po zakończeniu analizy dynamicznej z MobSF możesz nacisnąć "**Start Web API Fuzzer**", aby **fuzzować żądania HTTP** i szukać podatności.

> [!TIP]
> Po wykonaniu analizy dynamicznej z MobSF ustawienia proxy mogą być źle skonfigurowane i nie będziesz w stanie naprawić tego z GUI. Możesz naprawić ustawienia proxy wykonując:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

Narzędzie można pobrać z [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
To narzędzie użyje kilku **Hooks**, żeby poinformować cię **co dzieje się w aplikacji** podczas przeprowadzania **analizy dynamicznej**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

To **świetne narzędzie do wykonywania analizy statycznej z GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Narzędzie to zostało zaprojektowane do wyszukiwania różnych **podatności związanych z bezpieczeństwem aplikacji Android**, zarówno w **source code**, jak i w **packaged APKs**. Narzędzie jest również **zdolne do tworzenia deployowalnego APK „Proof-of-Concept”** oraz **ADB commands**, aby wykorzystać niektóre z znalezionych podatności (Exposed activities, intents, tapjacking...). Podobnie jak w przypadku Drozer, nie ma potrzeby rootowania urządzenia testowego.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Wyświetla wszystkie wyodrębnione pliki do szybkiego przeglądu
- Automatycznie dekompiluje pliki APK do formatu Java i Smali
- Analizuje AndroidManifest.xml pod kątem powszechnych podatności i zachowań
- Statyczna analiza kodu źródłowego pod kątem powszechnych podatności i zachowań
- Informacje o urządzeniu
- i więcej
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER jest aplikacją wiersza poleceń, którą można uruchomić w Windows, MacOS X i Linux; analizuje pliki _.apk_ w poszukiwaniu podatności. Robi to, dekompresując APKs i stosując zestaw reguł do wykrywania tych podatności.

Wszystkie reguły znajdują się w pliku `rules.json`, a każda firma lub tester może stworzyć własne reguły, aby analizować to, czego potrzebuje.

Pobierz najnowsze binaria ze strony [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn to narzędzie **crossplatform**, które wspomaga programistów, bugbounty hunters i ethical hackers w przeprowadzaniu [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) na aplikacjach mobilnych.

Koncepcja polega na przeciągnięciu i upuszczeniu pliku aplikacji mobilnej (plik .apk lub .ipa) na aplikację StaCoAn — aplikacja wygeneruje dla Ciebie wizualny i przenośny raport. Możesz dostosować ustawienia i wordlists, aby uzyskać spersonalizowane doświadczenie.

Pobierz[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework jest systemem analizy podatności dla Androida, który pomaga deweloperom lub hackers znaleźć potencjalne luki bezpieczeństwa w aplikacjach Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** to narzędzie, którego głównym celem jest wykrywanie i ostrzeganie użytkownika o potencjalnie złośliwych zachowaniach występujących w aplikacji Android.

Wykrywanie odbywa się poprzez **static analysis** Dalvik bytecode aplikacji, reprezentowanego jako **Smali**, z użyciem biblioteki [`androguard`](https://github.com/androguard/androguard).

Narzędzie wyszukuje **typowe zachowania "złych" aplikacji** takie jak: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. To narzędzie łączy powszechnie używane narzędzia do reverse engineeringu i analizy aplikacji mobilnych, aby wspomóc testowanie aplikacji mobilnych pod kątem zagrożeń bezpieczeństwa OWASP dla aplikacji mobilnych. Jego celem jest ułatwienie i uczynienie tego zadania bardziej przyjaznym dla deweloperów aplikacji mobilnych i specjalistów ds. bezpieczeństwa.

It is able to:

- Extract Java and Smali code using different tools
- Analizować APKi przy użyciu: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Wydobywać prywatne informacje z APK przy użyciu regexpów.
- Analizować Manifest.
- Analizować znalezione domeny przy użyciu: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuskować APK za pomocą [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Przydatne do wykrywania malware: [https://koodous.com/](https://koodous.com)

## Obfuscating/Deobfuscating code

Zwróć uwagę, że w zależności od usługi i konfiguracji użytej do obfuskacji kodu, sekrety mogą, ale nie muszą być obfuskowane.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** to narzędzie wiersza poleceń typu open source, które zmniejsza, optymalizuje i obfuskowuje kod Java. Potrafi optymalizować bytecode oraz wykrywać i usuwać nieużywane instrukcje. ProGuard jest oprogramowaniem wolnym i dystrybuowanym na licencji GNU General Public License, version 2.

ProGuard jest dystrybuowany jako część Android SDK i uruchamiany podczas budowania aplikacji w trybie release.

### [DexGuard](https://www.guardsquare.com/dexguard)

Znajdź przewodnik krok po kroku do deobfuskacji APK na [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(Z tego przewodnika) Ostatnio, gdy sprawdzaliśmy, tryb działania Dexguard był następujący:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard odwraca proces obfuskacji wykonywany przez narzędzia obfuskacyjne dla Androida. Umożliwia to liczne analizy bezpieczeństwa, w tym inspekcję kodu i identyfikację bibliotek.**

Możesz przesłać obfuskowany APK na ich platformę.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

To narzędzie LLM do znajdowania potencjalnych luk bezpieczeństwa w aplikacjach android i deobfuskacji kodu aplikacji android. Używa publicznego API Gemini od Google.

### [Simplify](https://github.com/CalebFenton/simplify)

It is a **generic android deobfuscator.** Simplify **virtually executes an app** to understand its behavior and then **tries to optimize the code** so it behaves identically but is easier for a human to understand. Each optimization type is simple and generic, so it doesn't matter what the specific type of obfuscation is used.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD dostarcza informacji o tym, **jak APK został zrobiony**. Identyfikuje wiele **kompilatorów**, **packers**, **obfuskatorów** i innych dziwnych rzeczy. To jest [_PEiD_](https://www.aldeid.com/wiki/PEiD) dla Androida.

### Podręcznik

[Przeczytaj ten samouczek, aby poznać triki dotyczące **odwracania niestandardowej obfuskacji**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b to wirtualna maszyna bezpieczeństwa Android oparta na ubuntu-mate, zawierająca zbiór najnowszych frameworków, tutoriali i laboratoriów od różnych entuzjastów bezpieczeństwa i badaczy do reverse engineeringu i analizy malware.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) To świetna lista zasobów
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Szybki kurs Androida
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097) — SSLPinDetect: Zaawansowane wykrywanie SSL Pinning w analizie bezpieczeństwa Androida
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect) — SSLPinDetect na GitHub
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools) — Zbuduj powtarzalne laboratorium Bug Bounty dla Androida: Emulator vs Magisk, Burp, Frida i Medusa
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone) — CoRPhone — wykonywanie JNI w pamięci i pipeline pakowania dla Androida

{{#include ../../banners/hacktricks-training.md}}
