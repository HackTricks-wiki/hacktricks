# Android Applications Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android Applications Basics

Toplo se preporučuje da prvo pročitate ovu stranicu kako biste se upoznali sa **najvažnijim delovima vezanim za Android sigurnost i najozbiljnijim komponentama u Android aplikaciji**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Ovo je glavni alat koji vam je potreban da se povežete sa Android uređajem (emuliranim ili fizičkim).\
**ADB** omogućava kontrolu uređaja bilo preko **USB** ili **Network** sa računara. Ovaj alat omogućava **copying** fajlova u oba smera, **installation** i **uninstallation** aplikacija, **execution** of shell commands, **backing up** podataka, **reading** logova, među ostalim funkcijama.

Pogledajte sledeću listu [**ADB Commands**](adb-commands.md) da naučite kako da koristite adb.

## Smali

Ponekad je korisno **modify the application code** kako biste pristupili **hidden information** (možda dobro obfuskovani passwords ili flags). U tom slučaju može biti korisno decompile the APK, modify the code i recompile it.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Ovo može biti veoma korisno kao **alternative for several tests during the dynamic analysis** koje će biti prikazane. Zato, **keep always in mid this possibility**.

## Other interesting tricks

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Extract APK from device:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Spojite sve splits i base apks pomoću [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Studije slučaja i ranjivosti


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Statička analiza

Prvo, za analizu APK-a trebalo bi da **pogledate Java kod** koristeći dekompajler.\
Molimo, [**read here to find information about different available decompilers**](apk-decompilers.md).

### Potraga za zanimljivim informacijama

Samo pregledom **stringova** APK-a možete tražiti **lozinke**, **URL-ove** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** ključeve, **enkripciju**, **bluetooth uuid-ove**, **tokene** i sve što je interesantno... tražite čak i backdoor-e za izvršavanje koda ili backdoor-e za autentifikaciju (hardkodirane administratorske kredencijale u aplikaciji).

**Firebase**

Obratite posebnu pažnju na **firebase URL-ove** i proverite da li je loše podešen. [More information about whats is FIrebase and how to exploit it here.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Osnovno razumevanje aplikacije - Manifest.xml, strings.xml

Pregled aplikacionih fajlova _Manifest.xml_ i **_strings.xml_** može otkriti potencijalne bezbednosne ranjivosti. Ovi fajlovi se mogu pristupiti pomoću dekompajlera ili preimenovanjem APK fajla u .zip i zatim njegovim raspakivanjem.

Ranjivosti identifikovane iz **Manifest.xml** uključuju:

- **Debagabilne aplikacije**: Aplikacije označene kao debuggable (`debuggable="true"`) u _Manifest.xml_ predstavljaju rizik jer omogućavaju konekcije koje mogu dovesti do eksploatacije. Za dodatno razumevanje kako iskoristiti debuggable aplikacije, pogledajte tutorijal o pronalaženju i eksploataciji debuggable aplikacija na uređaju.
- **Podešavanja rezervne kopije**: Atribut `android:allowBackup="false"` treba eksplicitno postaviti za aplikacije koje rukuju osetljivim informacijama kako bi se sprečile neautorizovane rezervne kopije podataka putem adb-a, posebno kada je usb debugging omogućen.
- **Mrežna bezbednost**: Prilagođena mrežna sigurnosna podešavanja (`android:networkSecurityConfig="@xml/network_security_config"`) u _res/xml/_ mogu specificirati bezbednosne detalje poput pinovanja sertifikata i podešavanja HTTP saobraćaja. Primer je dopuštanje HTTP saobraćaja za specifične domene.
- **Exportovane aktivnosti i servisi**: Identifikovanje exportovanih aktivnosti i servisa u manifestu može ukazati na komponente koje se mogu zloupotrebiti. Dalja analiza tokom dinamičkog testiranja može otkriti kako iskoristiti te komponente.
- **Content Providers i FileProviders**: Izloženi content provider-i mogli bi dozvoliti neautorizovan pristup ili izmenu podataka. Konfiguracija FileProvider-a takođe treba biti detaljno pregledana.
- **Broadcast Receiver-i i URL sheme**: Ove komponente mogu se iskoristiti za eksploataciju, s posebnom pažnjom na to kako se URL sheme obrađuju u pogledu ranjivosti unosa.
- **SDK verzije**: `minSdkVersion`, `targetSDKVersion` i `maxSdkVersion` atributi ukazuju na podržane Android verzije, naglašavajući važnost ne podržavanja zastarelih, ranjivih Android verzija iz sigurnosnih razloga.

Iz fajla **strings.xml** mogu se otkriti osetljive informacije poput API ključeva, prilagođenih shema i drugih beleški developera, što naglašava potrebu za pažljivim pregledom ovih resursa.

### Tapjacking

Tapjacking je napad gde se maliciozna aplikacija pokreće i pozicionira preko ciljne aplikacije. Kada vizuelno zakloni ciljnu aplikaciju, njen korisnički interfejs je dizajniran tako da prevari korisnika da sa njim interaguje, dok zapravo prosleđuje interakciju ciljnoj aplikaciji.\
U suštini, to **sprečava korisnika da zna da zapravo izvodi akcije na ciljnoj aplikaciji**.

Više informacija pronađite u:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Aktivnost sa **`launchMode`** postavljenim na **`singleTask` bez definisanog `taskAffinity`** je ranjiva na task hijacking. To znači da se maliciozna aplikacija može instalirati i, ako se pokrene pre prave aplikacije, može **oteti task prave aplikacije** (tako da će korisnik interagovati sa malicioznom aplikacijom misleći da koristi pravu).

Više informacija u:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Nesigurno čuvanje podataka

Internal Storage

U Androidu, fajlovi koji su **sačuvani** u **internoj** memoriji su **dizajnirani** da budu dostupni isključivo aplikaciji koja ih je **kreirala**. Ova bezbednosna mera je **sprovodena** od strane Android operativnog sistema i generalno je adekvatna za bezbednosne potrebe većine aplikacija. Međutim, developeri ponekad koriste režime kao što su `MODE_WORLD_READABLE` i `MODE_WORLD_WRITABLE` da bi **dozvolili** da fajlovi budu **deljeni** između različitih aplikacija. Ipak, ti režimi **ne ograničavaju pristup** tim fajlovima od strane drugih aplikacija, uključujući potencijalno maliciozne.

1. **Statička analiza:**
- **Proverite** pažljivo upotrebu `MODE_WORLD_READABLE` i `MODE_WORLD_WRITABLE`. Ovi režimi **mogu potencijalno izložiti** fajlove neželjenom ili neautorizovanom pristupu.
2. **Dinamička analiza:**
- **Verifikujte** dozvole postavljene na fajlovima kreiranim od strane aplikacije. Konkretno, **proverite** da li su neki fajlovi **postavljeni kao čitljivi ili zapisivi za sve**. Ovo može predstavljati značajan bezbednosni rizik, jer bi dozvolilo **svakoj aplikaciji** instaliranoj na uređaju, bez obzira na poreklo ili nameru, da **čita ili menja** te fajlove.

External Storage

Kada se radi o fajlovima na **eksternom skladištu**, kao što su SD kartice, treba preduzeti određene mere opreza:

1. **Pristupačnost**:
- Fajlovi na eksternom skladištu su **globalno čitljivi i zapisivi**. To znači da bilo koja aplikacija ili korisnik može pristupiti tim fajlovima.
2. **Bezbednosni problemi**:
- S obzirom na laku dostupnost, preporučuje se **ne čuvati osetljive informacije** na eksternom skladištu.
- Eksterno skladište može biti uklonjeno ili mu može pristupiti bilo koja aplikacija, što ga čini manje sigurnim.
3. **Rukovanje podacima sa eksternog skladišta**:
- Uvek **vršite validaciju unosa** podataka koji su preuzeti sa eksternog skladišta. Ovo je ključno jer podaci potiču iz nepouzdanog izvora.
- Preporučuje se da se ne čuvaju izvršni fajlovi ili class fajlovi na eksternom skladištu radi dinamičkog učitavanja.
- Ako vaša aplikacija mora da preuzme izvršne fajlove sa eksternog skladišta, obezbedite da su ti fajlovi **potpisani i kriptografski verifikovani** pre nego što budu dinamički učitani. Ovaj korak je vitalan za održavanje bezbednosnog integriteta vaše aplikacije.

External storage can be **accessed** in `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> Počevši od Android 4.4 (**API 17**), SD kartica ima strukturu direktorijuma koja **ograničava pristup aplikaciji na direktorijum koji je specifično za tu aplikaciju**. Ovo sprečava malicioznu aplikaciju da dobije pristup za čitanje ili pisanje fajlova druge aplikacije.

Osetljivi podaci sačuvani u običnom tekstu

- **Shared preferences**: Android omogućava svakoj aplikaciji da lako sačuva xml fajlove u putanji `/data/data/<packagename>/shared_prefs/` i ponekad je moguće pronaći osetljive informacije u običnom tekstu u tom folderu.
- **Databases**: Android omogućava svakoj aplikaciji da lako sačuva sqlite baze podataka u putanji `/data/data/<packagename>/databases/` i ponekad je moguće pronaći osetljive informacije u običnom tekstu u tom folderu.

### Pokvareni TLS

Prihvatanje svih sertifikata

Iz nekog razloga, ponekad developeri prihvataju sve sertifikate čak i kada, na primer, hostname ne odgovara, sa linijama koda poput sledeće:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Neispravna kriptografija

**Loši procesi upravljanja ključevima**

Neki developeri čuvaju osetljive podatke u lokalnoj memoriji i kriptuju ih ključem hardkodiranim/predvidljivim u kodu. Ovo ne bi trebalo raditi jer reverzno inženjerstvo može omogućiti napadačima da izvuku poverljive informacije.

**Korišćenje nesigurnih i/ili zastarelih algoritama**

Developeri ne bi trebali koristiti **zastarele algoritme** za izvođenje autorizacionih **provera**, **čuvanje** ili **slanje** podataka. Neki od ovih algoritama su: RC4, MD4, MD5, SHA1... Ako se koriste **hashes** za čuvanje lozinki, na primer, treba koristiti hashes otporne na brute-force uz salt.

### Ostale provere

- Preporučuje se da se **obfuscate the APK** kako bi se otežao rad reverse engineerima/napadačima.
- Ako je app osetljiv (kao bankarske aplikacije), treba da izvršava **svoje provere da li je mobilni uređaj rooted** i postupi u skladu sa tim.
- Ako je app osetljiv (kao bankarske aplikacije), treba da proveri da li se koristi **emulator**.
- Ako je app osetljiv (kao bankarske aplikacije), treba da **proveri svoju integritet pre izvršavanja** kako bi utvrdio/la da li je izmenjen.
- Koristite [**APKiD**](https://github.com/rednaga/APKiD) da proverite koji compiler/packer/obfuscator je korišćen za izgradnju APK

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

The tool [**mariana-trench**](https://github.com/facebook/mariana-trench) is capable of finding **vulnerabilities** by **scanning** the **code** of the application. This tool contains a series of **known sources** (that indicates to the tool the **places** where the **input** is **controlled by the user**), **sinks** (which indicates to the tool **dangerous** **places** where malicious user input could cause damages) and **rules**. These rules indicates the **combination** of **sources-sinks** that indicates a vulnerability.

With this knowledge, **mariana-trench will review the code and find possible vulnerabilities on it**.

### Secrets leaked

An application may contain secrets (API keys, passwords, hidden urls, subdomains...) inside of it that you might be able to discover. You could us a tool such as [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)
- In-memory native code execution via JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> First of all, you need an environment where you can install the application and all the environment (Burp CA cert, Drozer and Frida mainly). Therefore, a rooted device (emulated or not) is extremely recommended.

### Online Dynamic analysis

You can create a **free account** in: [https://appetize.io/](https://appetize.io). This platform allows you to **upload** and **execute** APKs, so it is useful to see how an apk is behaving.

You can even **see the logs of your application** in the web and connect through **adb**.

![](<../../images/image (831).png>)

Thanks to the ADB connection you can use **Drozer** and **Frida** inside the emulators.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (You can create **x86** and **arm** devices, and according to [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** versions **support ARM libraries** without needing an slow arm emulator).
- Learn to set it up in this page:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, you need to create an account. _It's recommend to **download** the version **WITH**_ _**VirtualBox** to avoid potential errors._)
- [**Nox**](https://es.bignox.com) (Free, but it doesn't support Frida or Drozer).

> [!TIP]
> Kada pravite novi emulator na bilo kojoj platformi, zapamtite da što je ekran veći to će emulator raditi sporije. Zato, ako je moguće, izaberite manje ekrane.

To **install google services** (like AppStore) in Genymotion you need to click on the red marked button of the following image:

![](<../../images/image (277).png>)

Also, notice that in the **configuration of the Android VM in Genymotion** you can select **Bridge Network mode** (this will be useful if you will be connecting to the Android VM from a different VM with the tools).

#### Use a physical device

You need to activate the **debugging** options and it will be cool if you can **root** it:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Once you have installed the application, the first thing you should do is to try it and investigate what does it do, how does it work and get comfortable with it.\
> I will suggest to **perform this initial dynamic analysis using MobSF dynamic analysis + pidcat**, so we will be able to **learn how the application works** while MobSF **captures** a lot of **interesting** **data** you can review later on.

Magisk/Zygisk quick notes (recommended on Pixel devices)
- Patch boot.img with the Magisk app and flash via fastboot to get systemless root
- Enable Zygisk + DenyList for root hiding; consider LSPosed/Shamiko when stronger hiding is required
- Keep original boot.img to recover from OTA updates; re-patch after each OTA
- For screen mirroring, use scrcpy on the host



### Unintended Data Leakage

**Logging**

Developeri treba da budu oprezni pri otkrivanju **debugging information** javno, jer to može dovesti do curenja osetljivih podataka. Alati [**pidcat**](https://github.com/JakeWharton/pidcat) i `adb logcat` se preporučuju za praćenje logova aplikacije kako bi se identifikovale i zaštitile osetljive informacije. **Pidcat** je poželjniji zbog jednostavnosti korišćenja i preglednosti.

> [!WARNING]
> Imajte na umu da od **Android 4.0 i novijih**, **aplikacije mogu pristupiti samo svojim logovima**. Dakle, aplikacije ne mogu pristupiti logovima drugih aplikacija.\
> U svakom slučaju, i dalje se preporučuje da se **ne loguju osetljive informacije**.

**Copy/Paste Buffer Caching**

Androidov **clipboard-based** framework omogućava funkcionalnost copy-paste u aplikacijama, ali predstavlja rizik jer **druge aplikacije** mogu **pristupiti** clipboard-u, potencijalno otkrivajući osetljive podatke. Ključno je **onemogućiti funkcije copy/paste** za osetljive delove aplikacije, poput podataka o kreditnim karticama, kako biste sprečili leak.

**Crash Logs**

Ako aplikacija **pukne** i **sačuva logove**, ti logovi mogu pomoći napadačima, naročito kada aplikacija ne može da se reverzno inženjerski analizira. Da biste umanjili ovaj rizik, izbegavajte logovanje prilikom crasha, a ako se logovi moraju slati preko mreže, postarajte se da se šalju preko SSL kanala radi bezbednosti.

Kao pentester, **pokušajte da bacite pogled na ove logove**.

**Analytics Data Sent To 3rd Parties**

Aplikacije često integrišu servise kao što je Google Adsense, što može nenamerno dovesti do curenja osetljivih podataka zbog nepravilne implementacije od strane developera. Da biste identifikovali potencijalne curenja podataka, preporučuje se da **interceptujete saobraćaj aplikacije** i proverite da li se osetljive informacije šalju trećim stranama.

### SQLite DBs

Većina aplikacija koristi **internal SQLite databases** za čuvanje informacija. Tokom pentesta proverite **baze podataka** koje su kreirane, imena **tabela** i **kolona** i sve **sačuvane podatke** jer možete naći **osetljive informacije** (što bi predstavljalo ranjivost).\
Baze podataka bi trebale biti locirane u `/data/data/the.package.name/databases` kao npr. `/data/data/com.mwr.example.sieve/databases`

Ako baza čuva poverljive informacije i **encrypted b**ut možete **naći** lozinku unutar aplikacije, to je i dalje **ranjivost**.

Enumerišite tabele koristeći `.tables` i enumerišite kolone tabele koristeći `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer is s useful tool to **exploit exported activities, exported services and Content Providers** as you will learn in the following sections.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Also remember that the code of an activity starts in the **`onCreate`** method.

**Authorisation bypass**

When an Activity is exported you can invoke its screen from an external app. Therefore, if an activity with **sensitive information** is **exported** you could **bypass** the **authentication** mechanisms **to access it.**

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

You can also start an exported activity from adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NAPOMENA**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> Imajte na umu da authorisation bypass nije uvek ranjivost — zavisi od toga kako bypass funkcioniše i koje informacije su izložene.

**Curеnje osetljivih informacija**

Aktivnosti takođe mogu vraćati rezultate. Ako uspete da pronađete eksportovanu i nezaštićenu aktivnost koja poziva metod `setResult` i vraća osetljive informacije, postoji curenje osetljivih informacija.

#### Tapjacking

Ako Tapjacking nije sprečen, možete zloupotrebiti eksportovanu aktivnost da naterate korisnika da izvrši neočekivane radnje. Za više informacija o [**what is Tapjacking follow the link**](#tapjacking).

### Iskorišćavanje Content Providers - pristup i manipulacija osetljivim informacijama

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers se u suštini koriste za deljenje podataka. Ako aplikacija ima dostupne content providers, možda ćete moći da izvučete osetljive podatke iz njih. Takođe je važno testirati moguće **SQL injections** i **Path Traversals** jer bi oni mogli biti ranjivi.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Iskorišćavanje Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Zapamtite da radnje Service-a počinju u metodi `onStartCommand`.

Service je u suštini nešto što može primati podatke, obrađivati ih i (opciono) vraćati odgovor. Dakle, ako aplikacija eksportuje neke servise, treba da proverite kod da biste razumeli šta radi i dinamički ga testirate kako biste izvukli poverljive informacije, zaobišli mere autentifikacije...\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Iskorišćavanje Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Zapamtite da radnje Broadcast Receiver-a počinju u metodi `onReceive`.

Broadcast receiver će čekati određenu vrstu poruke. U zavisnosti od toga kako receiver rukuje porukom, može biti ranjiv.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Možete tražiti deep links ručno, koristeći alate kao MobSF ili skripte poput [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Možete **open** deklarisani **scheme** koristeći **adb** ili **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Imajte na umu da možete **izostaviti package name** i mobilni uređaj će automatski pozvati aplikaciju koja bi trebalo da otvori tu vezu._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Kod koji će biti izvršen**

U cilju pronalaženja **koda koji će biti izvršen u App-u**, idi na aktivnost koju poziva deeplink i potraži funkciju **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Osetljivi podaci**

Svaki put kada nađeš deeplink proveri da li **ne prima osetljive podatke (npr. lozinke) preko URL parametara**, jer bilo koja druga aplikacija može **lažno predstavljati deeplink i ukrasti te podatke!**

**Parametri u putanji**

Takođe moraš proveriti da li neki deeplink koristi parametar unutar putanje URL-a kao npr.: `https://api.example.com/v1/users/{username}` , u tom slučaju možeš prisiliti path traversal pristupom nečemu poput: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Napomena da ako pronađeš odgovarajuće endpoint-e unutar aplikacije možda ćeš moći izazvati **Open Redirect** (ako se deo putanje koristi kao domain name), **account takeover** (ako možeš izmeniti korisničke podatke bez CSRF tokena i ranjivi endpoint koristi odgovarajući metod) i bilo koju drugu ranjivost. Više informacija [ovde](http://dphoeniixx.com/2020/12/13-2/).

**Više primera**

Zanimljiv bug bounty izveštaj o linkovima (_/.well-known/assetlinks.json_).

### Inspekcija transportnog sloja i greške u verifikaciji

- **Sertifikati nisu uvek pravilno proveravani** od strane Android aplikacija. Često ove aplikacije zanemare upozorenja i prihvate self-signed sertifikate ili, u nekim slučajevima, pređu na korišćenje HTTP veza.
- **Pregovori tokom SSL/TLS handshake-a su ponekad slabi**, koristeći nesigurne cipher suite-ove. Ova ranjivost čini konekciju podložnom MITM napadima, omogućavajući napadačima da dešifruju podatke.
- **Leakage of private information** predstavlja rizik kada se aplikacije autentifikuju koristeći sigurne kanale, ali zatim komuniciraju preko nesigurnih kanala za druge transakcije. Ovakav pristup ne štiti osetljive podatke, kao što su session cookies ili podaci o korisniku, od presretanja od strane zlonamernih entiteta.

#### Verifikacija sertifikata

Fokusiraćemo se na **verifikaciju sertifikata**. Integritet serverovog sertifikata mora biti potvrđen radi povećanja bezbednosti. Ovo je ključno jer nesigurne TLS konfiguracije i prenošenje osetljivih podataka preko nekriptovanih kanala mogu predstavljati značajne rizike. Za detaljne korake o verifikaciji server sertifikata i otklanjanju ranjivosti, [**ovaj resurs**](https://manifestsecurity.com/android-application-security-part-10/) pruža sveobuhvatne smernice.

#### SSL Pinning

SSL Pinning je mera bezbednosti gde aplikacija verifikuje serverov sertifikat u odnosu na poznatu kopiju smeštenu unutar same aplikacije. Ovaj metod je ključan za sprečavanje MITM napada. Implementacija SSL Pinning-a se snažno preporučuje za aplikacije koje obrađuju osetljive informacije.

#### Inspekcija saobraćaja

Da biste pregledali HTTP saobraćaj, neophodno je instalirati sertifikat proxy alata (npr. Burp). Bez instalacije tog sertifikata, enkriptovani saobraćaj možda neće biti vidljiv kroz proxy. Za vodič o instalaciji custom CA sertifikata, [**klikni ovde**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Aplikacije koje ciljaju **API Level 24 and above** zahtevaju izmene u Network Security Config kako bi prihvatile proxy-ev CA sertifikat. Ovaj korak je kritičan za inspekciju enkriptovanog saobraćaja. Za instrukcije kako izmeniti Network Security Config, [**pogledaj ovaj tutorijal**](make-apk-accept-ca-certificate.md).

Ako se koristi **Flutter** treba da pratiš instrukcije na [**ovoj stranici**](flutter.md). To je zato što samo dodavanje sertifikata u store neće raditi jer Flutter ima sopstvenu listu validnih CAs.

#### Statička detekcija SSL/TLS pinning-a

Pre nego što pokušaš runtime bypass-e, brzo mapiraj gde se pinning primenjuje u APK-u. Statičko otkrivanje pomaže da isplaniraš hook-ove/patch-e i fokusiraš se na prave kodne puteve.

Tool: SSLPinDetect
- Open-source utilitar za statičku analizu koji dekompajlira APK u Smali (via apktool) i skenira za kurirane regex pattern-e SSL/TLS pinning implementacija.
- Prikazuje tačnu putanju fajla, broj reda i isječak koda za svaki pronađeni match.
- Obuhvata uobičajene framework-e i custom kodne puteve: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

Instalacija
- Zahtevi: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Upotreba
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Primer pravila obrazaca (JSON)
Koristite ili proširite signatures da biste detektovali proprietary/custom pinning styles. Možete učitati sopstveni JSON i skenirati na velikoj skali.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Napomene i saveti
- Brzo skeniranje velikih aplikacija korišćenjem multi-threadinga i memory-mapped I/O; pre-compiled regex smanjuje overhead/false positives.
- Kolekcija patterna: https://github.com/aancw/smali-sslpin-patterns
- Tipični ciljevi za dalji triage:
- OkHttp: korišćenje CertificatePinner, setCertificatePinner, reference paketa okhttp3/okhttp
- Custom TrustManagers: javax.net.ssl.X509TrustManager, override-ovi checkServerTrusted
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init sa custom manager-ima
- Deklarativni pins u res/xml network security config i reference u manifestu
- Koristite pronađene lokacije za planiranje Frida hooks, static patches, ili pregleda konfiguracija pre dynamic testing.



#### Zaobilaženje SSL Pinning

Kada je SSL Pinning implementiran, potrebno ga je zaobići da biste pregledali HTTPS saobraćaj. Postoji nekoliko metoda za to:

- Automatski **izmenite** **apk** da biste **zaobišli** SSLPinning pomoću [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Najveća prednost ove opcije je što vam neće trebati root da zaobiđete SSL Pinning, ali moraćete da obrišete aplikaciju i ponovo instalirate novu verziju, i ovo neće uvek raditi.
- Možete koristiti **Frida** (opisano niže) da zaobiđete ovu zaštitu. Ovde je vodič za korišćenje Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Takođe možete pokušati **automatski da zaobiđete SSL Pinning** koristeći [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Takođe možete pokušati **automatski da zaobiđete SSL Pinning** koristeći **MobSF dynamic analysis** (objašnjeno niže)
- Ako i dalje mislite da postoji neki saobraćaj koji ne hvatate, možete pokušati da **prosledite saobraćaj ka burp koristeći iptables**. Pročitajte ovaj blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Traženje uobičajenih web ranjivosti

Važno je takođe tražiti uobičajene web ranjivosti unutar aplikacije. Detaljne informacije o identifikaciji i mitigaciji tih ranjivosti su izvan opsega ovog sažetka, ali su opširno obrađene drugde.

### Frida

[Frida](https://www.frida.re) je dinamički toolkit za instrumentaciju za developere, reverse inženjere i istraživače bezbednosti.\
**Možete pristupiti pokrenutoj aplikaciji i hook-ovati metode u runtime-u kako biste promenili ponašanje, promenili vrednosti, izvukli vrednosti, izvršili drugi kod...**\
Ako želite da pentest Android aplikacije morate znati kako da koristite Frida.

- Saznajte kako da koristite Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Neki "GUI" za rad sa Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection je odličan za automatizaciju korišćenja Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Možete pronaći neke Awesome Frida skripte ovde: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Pokušajte da zaobiđete anti-debugging / anti-frida mehanizme učitavajući Frida kako je prikazano u [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (alat [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump memorije - Fridump**

Proverite da li aplikacija čuva osetljive informacije u memoriji koje ne bi trebalo da čuva, poput lozinki ili mnemonika.

Koristeći [**Fridump3**](https://github.com/rootbsd/fridump3) možete dump-ovati memoriju aplikacije sa:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Ovo će napraviti dump memorije u ./dump folder, i tamo možete koristiti grep sa nečim poput:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Sensitive data in Keystore**

Na Androidu, Keystore je najbolje mesto za čuvanje osetljivih podataka, međutim, uz dovoljno privilegija i dalje je **moguće mu pristupiti**. Pošto aplikacije često ovde čuvaju **osetljive podatke u clear text**, pentests bi trebalo da to provere kao root user jer neko sa fizičkim pristupom uređaju može ukrasti te podatke.

Čak i ako aplikacija čuva podatke u Keystore, podaci bi trebalo da budu enkriptovani.

Za pristup podacima unutar Keystore možete koristiti ovaj Frida script: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Korišćenjem sledećeg Frida skripta može biti moguće izvršiti **bypass fingerprint authentication** koju Android aplikacije primenjuju kako bi **zaštitile određene osetljive oblasti:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Pozadinske slike**

Kada stavite aplikaciju u pozadinu, Android čuva **snapshot aplikacije** tako da kada se vrati u prvi plan počne da učitava sliku pre same aplikacije, što daje utisak da se aplikacija brže učitala.

Međutim, ako taj snapshot sadrži **osetljive informacije**, neko sa pristupom snapshotu može **ukrasti te informacije** (napomena: potreban je root za pristup).

Snapshoti se obično čuvaju na: **`/data/system_ce/0/snapshots`**

Android pruža način da se spreči snimanje screenshot-a podešavanjem FLAG_SECURE layout parametra. Korišćenjem ovog flag-a, sadržaj prozora se tretira kao bezbedan, sprečavajući njegovo pojavljivanje u screenshot-ovima ili pregled na nesigurnim ekranima.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Ovaj alat može pomoći pri upravljanju različitim alatima tokom dinamičke analize: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Programeri često kreiraju proxy komponente poput activities, services i broadcast receivers koje obrađuju ove Intents i prosleđuju ih metodama kao što su `startActivity(...)` ili `sendBroadcast(...)`, što može biti rizično.

Opasnost leži u tome što napadači mogu pokrenuti non-exported app components ili pristupiti osetljivim content providers tako što će preusmeriti ove Intents. Značajan primer je `WebView` komponenta koja konvertuje URL-ove u `Intent` objekte putem `Intent.parseUri(...)` i zatim ih izvršava, što može dovesti do malicious Intent injections.

### Essential Takeaways

- **Intent Injection** je sličan Open Redirect problemu na webu.
- Exploiti uključuju prosleđivanje `Intent` objekata kao extras, koji se mogu preusmeriti da izvrše unsafe operacije.
- Može izložiti non-exported komponente i content providers napadačima.
- Konverzija URL-ova u `Intent` od strane `WebView`-a može omogućiti neželjene akcije.

### Android Client Side Injections and others

Verovatno znate za ovaj tip ranjivosti sa Weba. Morate biti posebno oprezni sa ovim ranjivostima u Android aplikaciji:

- **SQL Injection:** Prilikom rada sa dinamičkim upitima ili Content-Providers obavezno koristite parametrizovane upite.
- **JavaScript Injection (XSS):** Proverite da li je podrška za JavaScript i Plugin onemogućena za sve WebViews (disabled by default). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews bi trebalo onemogućiti pristup fajl sistemu (enabled by default) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: U nekoliko slučajeva, kada Android aplikacija završi sesiju, cookie nije opozvan ili čak može biti sačuvan na disku
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Statička analiza**

![](<../../images/image (866).png>)

**Procena ranjivosti aplikacije** korišćenjem lepog web-based frontenda. Takođe možete izvesti dinamičku analizu (ali morate pripremiti okruženje).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Pomoć pri Dynamic analysis sa MobSF

**MobSF** can also be very helpful for **dynamic analysis** in **Android**, but in that case you will need to install MobSF and **genymotion** in your host (a VM or Docker won't work). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
The **MobSF dynamic analyser** can:

- **Dump application data** (URL-ove, logove, clipboard, snimke ekrana koje napravite ručno, snimke ekrana koje napravi "**Exported Activity Tester**", emailove, SQLite baze, XML fajlove i druge kreirane fajlove). Sve ovo se radi automatski osim snimaka ekrana — njih morate ručno napraviti kada želite screenshot ili pritisnuti "**Exported Activity Tester**" da biste dobili snimke svih exported activities.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From Android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: Ispisaće sve učitane klase
- **Capture Strings**: Ispisaće sve capture strings tokom korišćenja aplikacije (veoma šumno)
- **Capture String Comparisons**: Može biti veoma korisno. Pokazaće koje su to 2 stringa koja se porede i da li je rezultat bio True ili False.
- **Enumerate Class Methods**: Unesite ime klase (npr. "java.io.File") i ispišaće sve metode te klase.
- **Search Class Pattern**: Pretražuje klase po pattern-u
- **Trace Class Methods**: Trace cele klase (videti ulaze i izlaze svih metoda klase). Zapamtite da po defaultu MobSF trace-uje nekoliko interesantnih Android API metoda.

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf takođe donosi shell sa nekim **adb** komandoma, **MobSF commands**, i uobičajenim **shell** **commands** pri dnu stranice za dynamic analysis. Neke interesantne komande:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP alati**

When http traffic is capture you can see an ugly view of the captured traffic on "**HTTP(S) Traffic**" bottom or a nicer view in "**Start HTTPTools**" green bottom. From the second option, you can **send** the **captured requests** to **proxies** like Burp or Owasp ZAP.\
To do so, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> press "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Kada završite dinamičku analizu sa MobSF možete pritisnuti "**Start Web API Fuzzer**" da **fuzz http requests** i potražite ranjivosti.

> [!TIP]
> Nakon izvođenja dinamičke analize sa MobSF, proxy podešavanja mogu biti pogrešno konfigurisana i možda ih nećete moći popraviti iz GUI-ja. Možete popraviti proxy podešavanja tako što ćete uraditi:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

You can get the tool from [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Ovaj alat će koristiti neke **Hooks** da vam pokaže **šta se dešava u aplikaciji** dok vršite **dynamic analysis**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Ovo je **odličan alat za izvođenje static analysis sa GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Ovaj alat je dizajniran da traži više **security related Android application vulnerabilities**, bilo u **source code** ili **packaged APKs**. Alat je takođe **capable of creating a "Proof-of-Concept" deployable APK** i **ADB commands**, da iskoristi neke od pronađenih ranjivosti (Exposed activities, intents, tapjacking...). Kao i kod Drozer, nema potrebe da root-ujete test uređaj.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Prikazuje sve ekstrahovane fajlove radi lakšeg pregleda
- Automatski dekompajlira APK fajlove u Java i Smali format
- Analizira AndroidManifest.xml za uobičajene ranjivosti i ponašanje
- Statička analiza izvornog koda radi otkrivanja uobičajenih ranjivosti i ponašanja
- Informacije o uređaju
- i još toga
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER je aplikacija komandne linije koja se može koristiti na Windows, MacOS X i Linux, i koja analizira _.apk_ fajlove u potrazi za ranjivostima. To radi dekompresovanjem APK fajlova i primenom niza pravila kako bi otkrila te ranjivosti.

Sva pravila su smeštena u `rules.json` fajlu, a svaka kompanija ili tester može kreirati sopstvena pravila za analizu onoga što im treba.

Preuzmite najnovije binarne fajlove sa [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn je **crossplatform** alat koji pomaže programerima, bugbounty hunterima i ethical hackerima pri izvođenju [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) nad mobilnim aplikacijama.

Koncept je da prevučete i ispustite datoteku vaše mobilne aplikacije (.apk ili .ipa fajl) u StaCoAn aplikaciju i ona će vam generisati vizuelni i prenosivi izveštaj. Možete prilagoditi podešavanja i wordlists da biste dobili personalizovano iskustvo.

Preuzmite[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework je sistem za analizu ranjivosti Android aplikacija koji pomaže developerima ili hackers da pronađu potencijalne bezbednosne ranjivosti u Android aplikacijama.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** je alat čiji je glavni cilj da otkrije i upozori korisnika na potencijalno zlonamerna ponašanja koja razvija Android aplikacija.

Detekcija se vrši pomoću **static analysis** Dalvik bytekoda aplikacije, predstavljenog kao **Smali**, koristeći biblioteku [`androguard`](https://github.com/androguard/androguard).

Ovaj alat traži **uobičajena ponašanja "loših" aplikacija** kao što su: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** je **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. To je alat koji okuplja često korišćene alate za reverse engineering i analizu mobilnih aplikacija, kako bi pomogao pri testiranju mobilnih aplikacija protiv OWASP mobile security threats. Njegov cilj je da ovaj zadatak učini jednostavnijim i pristupačnijim za developere mobilnih aplikacija i bezbednosne profesionalce.

Može da:

- Extract Java and Smali code using different tools
- Analyze APKs using: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Izdvoji privatne informacije iz APK-a koristeći regexps.
- Analyze the Manifest.
- Analyze found domains using: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Koristan za detekciju malvera: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Imajte na umu da, u zavisnosti od servisa i konfiguracije koju koristite za obfuskaciju koda, tajne možda hoće ili neće biti obfuskirane.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** je alat komandne linije otvorenog koda koji smanjuje, optimizuje i obfuskira Java kod. Može da optimizuje bytecode kao i da detektuje i ukloni neiskorišćene instrukcije. ProGuard je besplatan softver i distribuiran je pod GNU General Public License, version 2.

ProGuard se distribuira kao deo Android SDK-a i pokreće se prilikom build-a aplikacije u release modu.

### [DexGuard](https://www.guardsquare.com/dexguard)

Nađite vodič korak po korak za deobfuskaciju apk-a na [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Poslednji put kada smo proveravali, način rada Dexguard-a je bio:

- učitaj resurs kao InputStream;
- prosledi rezultat klasi koja nasleđuje FilterInputStream da ga dekriptujes;
- uradi neku beskorisnu obfuskaciju da bi se izgubilo nekoliko minuta reverzeru;
- prosledi dekriptovani rezultat u ZipInputStream da bi dobio DEX fajl;
- konačno učitaj rezultujući DEX kao Resource koristeći metodu `loadDex`.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverzuje proces obfuskacije koji sprovode Android obfuscation alati. Ovo omogućava brojne sigurnosne analize, uključujući inspekciju koda i predviđanje biblioteka.**

Možete da otpremite obfuskovani APK na njihovu platformu.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

Ovo je LLM alat za pronalaženje potencijalnih bezbednosnih ranjivosti u android apps i deobfuscation android app koda. Koristi Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

To je **generički android deobfuscator.** Simplify **virtually executes an app** da bi razumeo njeno ponašanje i zatim **pokušava da optimizuje kod** tako da se ponaša identično, ali bude lakši za razumevanje od strane čoveka. Svaki tip optimizacije je jednostavan i generički, tako da nije bitno koja specifična vrsta obfuskacije je korišćena.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD vam daje informacije o **kako je APK napravljen**. Identifikuje mnoge **compilers**, **packers**, **obfuscators**, i druge neobične stvari. To je [_PEiD_](https://www.aldeid.com/wiki/PEiD) za Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b je Android security virtual machine bazirana na ubuntu-mate koja uključuje kolekciju najnovijih framework-ova, tutorijala i laboratorija od različitih security geeka i istraživača za reverse engineering i malware analysis.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) It is a great list of resources
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
