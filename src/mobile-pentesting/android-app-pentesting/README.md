# Android Applications Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android Applications Basics

이 페이지를 먼저 읽어 Android 보안과 Android 애플리케이션에서 가장 위험한 구성 요소에 관한 **가장 중요한 부분**을 아는 것을 강력히 권장합니다:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

이것은 에뮬레이터나 물리적 Android 기기에 연결하는 데 필요한 주요 도구입니다.\
**ADB**는 컴퓨터에서 **USB** 또는 **Network**를 통해 기기를 제어할 수 있게 해줍니다. 이 유틸리티는 파일의 양방향 **복사**, 앱의 **설치** 및 **제거**, 셸 명령의 **실행**, 데이터 **백업**, 로그 **읽기** 등 다양한 기능을 제공합니다.

다음 [**ADB Commands**](adb-commands.md) 목록을 확인하여 adb 사용법을 배우세요.

## Smali

때때로 **응용 프로그램 코드를 수정**하여 **숨겨진 정보**(예: 잘 난독화된 비밀번호나 플래그)에 접근하는 것이 유용할 수 있습니다. 그런 경우, apk를 디컴파일하고 코드를 수정한 뒤 다시 컴파일하는 것이 흥미로울 수 있습니다.\ [**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). 이는 동적 분석 중 제시될 여러 테스트의 **대안**으로 매우 유용할 수 있습니다. 따라서 **항상 이 가능성을 염두에 두세요**.

## Other interesting tricks

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **APK 다운로드**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- APK를 디바이스에서 추출:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- 모든 splits와 base apks를 [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## 사례 연구 및 취약점


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## 정적 분석

우선, APK를 분석할 때는 decompiler를 사용하여 **Java 코드를 살펴봐야 합니다**.\
[**다양한 사용 가능한 decompilers에 대한 정보를 보려면 여기를 읽으세요**](apk-decompilers.md).

### 흥미로운 정보 찾기

APK의 **strings**를 살펴보면 **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** 등 흥미로운 것들을 검색할 수 있습니다... 코드 실행 **backdoors**나 인증 백도어(앱에 하드코딩된 관리자 자격증명)도 확인하세요.

**Firebase**

Firebase URL에 특히 주의하고 잘못 구성되어 있는지 확인하세요. [Firebase가 무엇이며 이를 어떻게 악용할 수 있는지에 대한 자세한 정보는 여기](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md).

### 애플리케이션의 기본 이해 - Manifest.xml, strings.xml

애플리케이션의 _Manifest.xml_ 및 **_strings.xml_** 파일을 검토하면 잠재적인 보안 취약점을 발견할 수 있습니다. 이러한 파일들은 decompiler로 접근하거나 APK 파일 확장자를 .zip로 변경한 다음 압축을 풀어 확인할 수 있습니다.

**Manifest.xml**에서 확인되는 취약점에는 다음이 포함됩니다:

- **Debuggable Applications**: _Manifest.xml_ 파일에서 `debuggable="true"`로 설정된 애플리케이션은 연결을 허용하여 악용될 가능성이 있으므로 위험합니다. 디버깅 가능 애플리케이션을 기기에서 찾고 악용하는 방법에 대한 튜토리얼을 참조하세요.
- **Backup Settings**: 민감한 정보를 다루는 애플리케이션은 무단 adb 백업을 방지하기 위해 `android:allowBackup="false"` 속성을 명시적으로 설정해야 합니다. 특히 USB 디버깅이 활성화된 경우 중요합니다.
- **Network Security**: _res/xml/_의 사용자 정의 네트워크 보안 구성(`android:networkSecurityConfig="@xml/network_security_config"`)은 certificate pin이나 HTTP 트래픽 설정 같은 보안 세부사항을 명시할 수 있습니다. 예로 특정 도메인에 대해 HTTP 트래픽을 허용하는 설정이 있을 수 있습니다.
- **Exported Activities and Services**: manifest에서 exported된 activities 및 services를 식별하면 악용될 수 있는 컴포넌트를 찾아낼 수 있습니다. 동적 테스트 중 추가 분석을 통해 이러한 컴포넌트를 어떻게 악용할 수 있는지 알 수 있습니다.
- **Content Providers and FileProviders**: 노출된 Content Providers는 데이터에 대한 무단 접근 또는 수정을 허용할 수 있습니다. FileProviders의 구성 또한 면밀히 검토해야 합니다.
- **Broadcast Receivers and URL Schemes**: 이러한 컴포넌트는 악용될 여지가 있으며, 특히 URL schemes가 입력 취약성에 대해 어떻게 처리되는지 주의해야 합니다.
- **SDK Versions**: `minSdkVersion`, `targetSDKVersion`, 및 `maxSdkVersion` 속성은 지원되는 Android 버전을 나타내며, 오래되고 취약한 Android 버전을 지원하지 않는 것이 보안상 중요함을 강조합니다.

_strings.xml_ 파일에서는 API 키, custom schemas 및 기타 개발자 메모와 같은 민감한 정보를 발견할 수 있으므로 이러한 리소스를 주의 깊게 검토해야 합니다.

### Tapjacking

**Tapjacking**은 **악성** **애플리케이션**이 실행되어 **피해자 애플리케이션 위에 자신을 위치시키는** 공격입니다. 한 번 피해 앱을 시각적으로 가리면, 악성 앱의 사용자 인터페이스는 사용자가 상호작용하도록 속이도록 설계되어 있으며, 동시에 그 상호작용을 피해 앱으로 전달합니다.\
결과적으로 사용자는 자신이 실제로 피해 앱에서 동작을 수행하고 있다는 사실을 인지하지 못하게 됩니다.

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

`launchMode`가 **`singleTask`로 설정되고 `taskAffinity`가 정의되어 있지 않은** **activity**는 Task Hijacking에 취약합니다. 이는 악성 **application**이 설치되어 실제 애플리케이션보다 먼저 실행되면 **실제 애플리케이션의 task를 hijack**할 수 있음을 의미합니다(사용자는 실제 앱을 사용하는 줄 알고 **malicious application**과 상호작용하게 됩니다).

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### 안전하지 않은 데이터 저장

Internal Storage

Android에서 내부 저장소에 **저장된** 파일은 이를 **생성한** **앱**만 접근할 수 있도록 **설계되어** 있습니다. 이 보안 조치는 Android 운영체제에 의해 **강제**되며 대부분의 애플리케이션 보안 요구에는 일반적으로 적절합니다. 그러나 개발자들은 때때로 `MODE_WORLD_READABLE` 및 `MODE_WORLD_WRITABLE`과 같은 모드를 사용하여 파일을 다른 애플리케이션 간에 **공유 허용**하도록 합니다. 하지만 이러한 모드는 잠재적으로 악성인 다른 애플리케이션의 파일 접근을 **제한하지 않습니다**.

1. **정적 분석:**
- **확인**: `MODE_WORLD_READABLE` 및 `MODE_WORLD_WRITABLE`의 사용이 **면밀히 검토**되었는지 확인하세요. 이러한 모드는 **파일을 노출시킬 수 있습니다**(원치 않거나 무단 접근).
2. **동적 분석:**
- **검증**: 앱이 생성한 파일에 설정된 **권한**을 확인하세요. 특히 어떤 파일이 **전역 읽기 또는 쓰기 가능**으로 **설정되어 있는지** 확인하세요. 이는 심각한 보안 위험을 초래할 수 있으며, 기기에 설치된 **모든 애플리케이션**이 출처나 의도에 관계없이 해당 파일을 **읽거나 수정**할 수 있게 됩니다.

External Storage

SD 카드와 같은 **external storage**의 파일을 다룰 때는 다음과 같은 주의가 필요합니다:

1. **Accessibility**:
- 외부 저장소의 파일은 **전역적으로 읽기 및 쓰기 가능**합니다. 즉, 모든 애플리케이션이나 사용자가 이 파일들에 접근할 수 있습니다.
2. **Security Concerns**:
- 접근이 쉬우므로 **민감한 정보를 외부 저장소에 저장하지 않는 것**이 권장됩니다.
- 외부 저장소는 제거될 수 있으며 어떤 애플리케이션이라도 접근할 수 있어 보안성이 낮습니다.
3. **Handling Data from External Storage**:
- 외부 저장소에서 가져온 데이터에 대해 항상 **입력 검증을 수행**하세요. 외부 저장소의 데이터는 신뢰할 수 없는 소스이기 때문에 필수적입니다.
- 외부 저장소에 실행 파일이나 class 파일을 저장한 후 동적으로 로드하는 것은 강력히 권장되지 않습니다.
- 애플리케이션이 외부 저장소에서 실행 파일을 반드시 불러와야 한다면, 동적으로 로드하기 전에 해당 파일들이 **서명되어 있고 암호학적으로 검증**되었는지 확인하세요. 이 단계는 애플리케이션의 보안 무결성을 유지하는 데 중요합니다.

External storage는 `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`에서 접근할 수 있습니다.

> [!TIP]
> Android 4.4(**API 17**)부터 SD 카드는 애플리케이션이 특정 앱 전용 디렉터리로만 접근을 제한하는 디렉터리 구조를 가집니다. 이는 악성 애플리케이션이 다른 앱의 파일에 대한 읽기 또는 쓰기 접근을 얻는 것을 방지합니다.

민감한 데이터가 평문으로 저장됨

- **Shared preferences**: Android는 각 애플리케이션이 `/data/data/<packagename>/shared_prefs/` 경로에 xml 파일을 쉽게 저장할 수 있게 하며, 때때로 해당 폴더에서 평문으로 민감한 정보를 찾을 수 있습니다.
- **Databases**: Android는 각 애플리케이션이 `/data/data/<packagename>/databases/` 경로에 sqlite 데이터베이스를 쉽게 저장할 수 있게 하며, 때때로 해당 폴더에서 평문으로 민감한 정보를 찾을 수 있습니다.

### Broken TLS

Accept All Certificates

어떤 이유에서인지 개발자가 예를 들어 hostname이 일치하지 않더라도 모든 인증서를 수락하는 경우가 있습니다. 다음과 같은 코드 라인에서처럼:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### 잘못된 암호화

**취약한 키 관리 프로세스**

일부 개발자는 민감한 데이터를 로컬 스토리지에 저장하고 코드에 하드코딩되거나 예측 가능한 키로 암호화합니다. 이러한 방식은 리버싱으로 인해 공격자가 기밀 정보를 추출할 수 있으므로 해서는 안 됩니다.

**안전하지 않거나/또는 폐기된 알고리즘 사용**

개발자는 권한 검사(authorisation **checks**), 데이터 **저장** 또는 **전송**에 **deprecated algorithms**을 사용해서는 안 됩니다. 이러한 알고리즘의 예로는 RC4, MD4, MD5, SHA1 등이 있습니다. 예를 들어 비밀번호 저장에 **hashes**를 사용하는 경우, 솔트를 사용한 브루트포스에 **강한** 해시를 사용해야 합니다.

### 기타 점검사항

- APK를 난독화(obfuscate the APK)하여 역분석 작업을 어렵게 만드는 것을 권장합니다.
- 앱이 민감한 경우(예: 은행 앱) 모바일이 **rooted** 되었는지 자체적으로 검사하고 그에 따라 동작해야 합니다.
- 앱이 민감한 경우(예: 은행 앱) **emulator** 사용 여부를 확인해야 합니다.
- 앱이 민감한 경우(예: 은행 앱) 실행 전에 **자체 무결성 검사(check it's own integrity before executing)** 를 수행하여 수정 여부를 확인해야 합니다.
- APK를 빌드할 때 어떤 compiler/packer/obfuscator가 사용되었는지 확인하려면 [**APKiD**](https://github.com/rednaga/APKiD)를 사용하세요.

### React Native Application

React 애플리케이션의 javascript 코드를 쉽게 접근하는 방법을 배우려면 다음 페이지를 읽으세요:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Xamarin 애플리케이션의 C# 코드에 쉽게 접근하는 방법을 배우려면 다음 페이지를 읽으세요:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

이 [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/)에 따르면 superpacked는 애플리케이션의 내용을 단일 파일로 압축하는 Meta 알고리즘입니다. 블로그는 이러한 앱을 압축 해제하는 앱을 만드는 가능성에 대해 이야기하며... **애플리케이션을 실행하고 파일시스템에서 압축 해제된 파일을 수집하는 더 빠른 방법**에 대해서도 언급합니다.

### Automated Static Code Analysis

도구 [**mariana-trench**](https://github.com/facebook/mariana-trench)는 애플리케이션의 **코드**를 **스캔**하여 **취약점(vulnerabilities)** 을 찾을 수 있습니다. 이 도구는 **known sources**(사용자에 의해 **입력**이 **제어되는 위치**를 도구에 알려주는 것), **sinks**(악의적인 사용자 입력이 피해를 일으킬 수 있는 **위험한 위치**) 및 **rules**의 집합을 포함합니다. 이 규칙들은 취약점을 가리키는 **sources-sinks** 조합을 나타냅니다.

이 지식을 바탕으로 **mariana-trench는 코드를 검토하고 가능한 취약점을 찾아냅니다**.

### Secrets leaked

애플리케이션 내에 API 키, 비밀번호, 숨겨진 URL, 서브도메인 등과 같은 secrets가 포함되어 있을 수 있으며 이를 발견할 수 있습니다. 예를 들어 [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks) 같은 도구를 사용할 수 있습니다.

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [이 문서를 읽어 **네이티브 함수 리버싱 방법**을 배우세요](reversing-native-libraries.md)

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> 먼저, 애플리케이션을 설치하고 필요한 환경(Burp CA cert, Drozer 및 Frida 등)을 구성할 수 있는 환경이 필요합니다. 따라서 루팅된 기기(rooted device, 에뮬레이터 여부 무관)를 강력히 권장합니다.

### Online Dynamic analysis

[https://appetize.io/](https://appetize.io/)에서 **무료 계정**을 생성할 수 있습니다. 이 플랫폼은 APK를 **업로드**하고 **실행**할 수 있게 해주므로 APK가 어떻게 동작하는지 확인하는 데 유용합니다.

웹에서 **애플리케이션 로그를 확인**할 수 있고 **adb**로 연결할 수도 있습니다.

![](<../../images/image (831).png>)

ADB 연결 덕분에 에뮬레이터 내에서 **Drozer**와 **Frida**를 사용할 수 있습니다.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (x86 및 arm 디바이스를 생성할 수 있으며, [**이 글**](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)에 따르면 최신 x86 버전은 느린 arm 에뮬레이터 없이도 **ARM libraries**를 지원합니다).
- 설정 방법은 다음 페이지를 참고하세요:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(무료 버전:** Personal Edition, 계정 생성 필요. _가능한 오류를 피하기 위해 **VirtualBox**가 포함된 버전을 **다운로드**하는 것이 권장됩니다._)  
- [**Nox**](https://es.bignox.com) (무료이지만 Frida 또는 Drozer를 지원하지 않습니다).

> [!TIP]
> 어떤 플랫폼에서 새로운 에뮬레이터를 생성할 때 화면이 클수록 에뮬레이터가 느려집니다. 가능하면 작은 화면을 선택하세요.

Genymotion에 **google services**(예: AppStore)를 설치하려면 다음 이미지에서 빨간색으로 표시된 버튼을 클릭해야 합니다:

![](<../../images/image (277).png>)

또한 **Genymotion의 Android VM 구성(configuration of the Android VM in Genymotion)** 에서 **Bridge Network mode**를 선택할 수 있다는 점을 기억하세요(도구가 설치된 다른 VM에서 Android VM에 연결할 경우 유용합니다).

#### Use a physical device

디버깅 옵션을 활성화해야 하며 가능하면 루팅(root)하는 것이 좋습니다:

1. **Settings**.
2. (Android 8.0부터) **System** 선택.
3. **About phone** 선택.
4. **Build number**를 7번 누릅니다.
5. 뒤로 가면 **Developer options**를 찾을 수 있습니다.

> 애플리케이션을 설치한 후 가장 먼저 해야 할 일은 해당 앱을 사용해보고 무엇을 하는지, 어떻게 동작하는지 조사하여 익숙해지는 것입니다.\
> 초기 동적 분석은 **MobSF dynamic analysis + pidcat**을 사용하여 수행할 것을 권장합니다. 이렇게 하면 MobSF가 나중에 검토할 수 있는 많은 **흥미로운 데이터**를 **캡처**하는 동안 애플리케이션의 동작을 배우는 데 도움이 됩니다.

### Unintended Data Leakage

**로깅(Logging)**

개발자는 **디버깅 정보**를 공개적으로 노출하지 않도록 주의해야 하며, 이는 민감한 데이터의 유출로 이어질 수 있습니다. 애플리케이션 로그를 모니터링하여 민감한 정보를 식별하고 보호하기 위해 [**pidcat**](https://github.com/JakeWharton/pidcat) 및 `adb logcat`을 권장합니다. **Pidcat**은 사용 편의성과 가독성 때문에 선호됩니다.

> [!WARNING]
> Android 4.0 이후 버전부터는 **애플리케이션이 자신의 로그만 접근할 수 있습니다**. 따라서 앱은 다른 앱의 로그에 접근할 수 없습니다.\
> 그럼에도 불구하고 민감한 정보를 로그로 남기지 않는 것이 권장됩니다.

**복사/붙여넣기 버퍼 캐싱(Copy/Paste Buffer Caching)**

Android의 **클립보드 기반** 프레임워크는 앱 간 복사-붙여넣기 기능을 가능하게 하지만, **다른 애플리케이션이 클립보드에 접근**할 수 있어 민감한 데이터가 노출될 위험이 있습니다. 신용카드 정보와 같은 민감한 섹션에 대해 복사/붙여넣기 기능을 비활성화하는 것이 중요합니다.

**Crash Logs**

애플리케이션이 **충돌(crash)** 하고 로그를 저장하는 경우, 이러한 로그는 특히 애플리케이션을 역분석할 수 없을 때 공격자에게 도움이 될 수 있습니다. 이 위험을 줄이려면 충돌 시 로깅을 피하고, 로그를 네트워크로 전송해야 하는 경우 SSL 채널을 통해 전송되도록 하세요.

pentester로서 **이 로그들을 살펴보도록** 하세요.

**Analytics Data Sent To 3rd Parties**

애플리케이션은 종종 Google Adsense와 같은 서비스를 통합하는데, 개발자의 잘못된 구현으로 인해 민감한 데이터가 leak될 수 있습니다. 잠재적 데이터 유출을 식별하려면 애플리케이션의 트래픽을 가로채서 제3자 서비스로 전송되는 민감한 정보가 있는지 확인하는 것이 좋습니다.

### SQLite DBs

대부분의 애플리케이션은 정보를 저장하기 위해 **내부 SQLite 데이터베이스**를 사용합니다. 펜테스트 동안 생성된 **데이터베이스**, **테이블** 및 **컬럼 이름**, 저장된 모든 **데이터**를 확인하세요. 민감한 정보가 발견될 수 있습니다(이는 취약점입니다).\
데이터베이스는 일반적으로 `/data/data/the.package.name/databases`에 위치하며 예: `/data/data/com.mwr.example.sieve/databases`

데이터베이스가 기밀 정보를 암호화(encrypted)하고 있지만 애플리케이션 내에서 암호를 찾을 수 있다면 이는 여전히 **취약점**입니다.

`.tables`로 테이블을 나열하고 `.schema <table_name>`으로 테이블의 컬럼을 나열하세요.

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer**를 사용하면 **Android 앱의 역할을 가정하고 다른 앱과 상호작용**할 수 있습니다. 설치된 애플리케이션이 할 수 있는 모든 것을 수행할 수 있으며, Android의 IPC 메커니즘을 이용하고 기본 운영체제와 상호작용할 수 있습니다. .\
Drozer는 다음 섹션에서 배우게 될 것처럼 **exported activities, exported services 및 Content Providers를 공격(exploit)** 하는 데 유용한 도구입니다.

### Exploiting exported Activities

[**Android Activity가 무엇인지 복습하고 싶다면 이 문서를 읽으세요.**](android-applications-basics.md#launcher-activity-and-other-activities)\
또한 Activity의 코드는 **`onCreate`** 메서드에서 시작된다는 점을 기억하세요.

**권한 우회(Authorisation bypass)**

Activity가 exported 되어 있으면 외부 앱에서 해당 화면을 호출할 수 있습니다. 따라서 **민감한 정보**를 포함한 Activity가 **exported** 되어 있다면 인증(authentication) 메커니즘을 **우회(bypass)** 하여 접근할 수 있습니다.

[**Drozer로 exported activities를 공격하는 방법을 배우세요.**](drozer-tutorial/index.html#activities)

또한 adb에서 exported activity를 시작할 수도 있습니다:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**참고**: MobSF는 activity에서 `android:launchMode`로 _**singleTask/singleInstance**_를 사용하는 것을 악성으로 탐지합니다, 하지만 [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750) 때문에, 명백히 이는 구버전(API versions < 21)에서만 위험한 것으로 보입니다.

> [!TIP]
> authorisation bypass는 항상 취약점이 되는 것은 아니며, 우회 방식과 어떤 정보가 노출되는지에 따라 달라집니다.

**Sensitive information leakage**

**Activities can also return results**. 만약 export되어 있고 보호되지 않은 activity가 **`setResult`** 메서드를 호출하여 **민감한 정보를 반환**한다면, there is a sensitive information leakage.

#### Tapjacking

Tapjacking이 방지되지 않으면, export된 activity를 악용하여 **사용자가 예기치 않은 동작을 수행하도록** 만들 수 있습니다. For more info about [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers는 기본적으로 **데이터를 공유**하는 데 사용됩니다. 앱에 사용 가능한 content providers가 있다면, 거기서부터 **민감한 데이터**를 추출할 수 있습니다. 또한 취약할 수 있으므로 가능한 **SQL injections** 및 **Path Traversals**를 테스트해보는 것이 좋습니다.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Service의 동작은 `onStartCommand` 메서드에서 시작된다는 점을 기억하세요.

Service는 기본적으로 데이터를 **수신할 수 있고**, 이를 **처리**하며 **응답을 반환**(또는 반환하지 않을 수 있음)하는 것입니다. 따라서 애플리케이션이 일부 서비스를 export하고 있다면, 해당 서비스가 무엇을 하는지 이해하기 위해 **코드**를 확인하고 기밀 정보를 추출하거나 인증 우회 등을 위해 동적으로 **테스트**해야 합니다.\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Broadcast Receiver의 동작은 `onReceive` 메서드에서 시작된다는 점을 기억하세요.

Broadcast receiver는 특정 타입의 메시지를 기다립니다. 수신자가 메시지를 처리하는 방식에 따라 취약할 수 있습니다.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

You can look for deep links manually, using tools like MobSF or scripts like [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
선언된 **scheme**은 **adb** 또는 **browser**를 사용하여 열 수 있습니다:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_패키지 이름을 **생략할 수 있으며**, 모바일 기기는 해당 링크를 열 앱을 자동으로 호출합니다._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**실행되는 코드**

앱에서 실행될 **code**를 찾기 위해, deeplink에 의해 호출되는 activity로 이동하여 함수 **`onNewIntent`**을 검색하세요.

![](<../../images/image (436) (1) (1) (1).png>)

**민감 정보**

deep link를 찾을 때마다 해당 deep link가 **URL parameters를 통해 비밀번호 같은 민감한 데이터를 받지 않는지** 확인하세요. 다른 애플리케이션이 **deep link를 가장하여 해당 데이터를 탈취할 수 있기 때문입니다!**

**경로의 파라미터**

URL 경로 안에 파라미터를 사용하는 deep link가 있는지도 **반드시 확인해야 합니다**, 예: `https://api.example.com/v1/users/{username}`. 이 경우 `example://app/users?username=../../unwanted-endpoint%3fparam=value` 처럼 path traversal을 강제할 수 있습니다.\
앱 내부에서 올바른 엔드포인트를 찾으면 경로의 일부가 도메인으로 사용되는 경우 **Open Redirect**를 유발할 수 있고, CSRF token 없이 사용자 정보를 수정할 수 있고 취약한 엔드포인트가 올바른 메서드를 사용했다면 **account takeover**가 가능하며 기타 다른 vuln도 발생할 수 있습니다. 자세한 내용은 [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### 전송 계층 검사 및 검증 실패

- **인증서는 항상 제대로 검사되지 않습니다.** Android 애플리케이션에서는 경고를 무시하고 self-signed 인증서를 수락하거나 경우에 따라 HTTP 연결로 회귀하는 경우가 흔합니다.
- **SSL/TLS 핸드셰이크 중 협상이 약한 경우가 있습니다**, 취약한 cipher suites를 사용하는 경우가 있어 연결이 man-in-the-middle (MITM) 공격에 취약해져 공격자가 데이터를 복호화할 수 있습니다.
- **Leakage of private information**은 애플리케이션이 보안 채널로 인증한 후 다른 트랜잭션을 비보안 채널로 통신하면 발생할 수 있는 위험입니다. 이 접근 방식은 session cookies나 사용자 정보 같은 민감한 데이터를 악의적 주체가 가로채는 것으로부터 보호하지 못합니다.

#### 인증서 검증

우리는 **certificate verification**에 집중할 것입니다. 서버 인증서의 무결성을 검증하는 것은 보안을 강화하기 위해 필수적입니다. 이는 안전하지 않은 TLS 구성과 민감한 데이터를 암호화되지 않은 채널로 전송하는 것이 심각한 위험을 초래할 수 있기 때문입니다. 서버 인증서를 검증하고 취약점을 해결하는 자세한 단계는 [**this resource**](https://manifestsecurity.com/android-application-security-part-10/)에서 포괄적으로 안내합니다.

#### SSL Pinning

SSL Pinning은 애플리케이션이 서버의 인증서를 앱 내에 저장된 알려진 사본과 비교하여 검증하는 보안 조치입니다. 이 방법은 MITM 공격을 방지하는 데 필수적입니다. 민감한 정보를 다루는 애플리케이션에는 SSL Pinning 구현을 강력히 권장합니다.

#### 트래픽 검사

HTTP 트래픽을 검사하려면 프록시 도구의 인증서(예: Burp)를 **설치해야** 합니다. 이 인증서를 설치하지 않으면 암호화된 트래픽이 프록시를 통해 보이지 않을 수 있습니다. 커스텀 CA 인증서 설치 가이드는 [**여기**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine)를 참조하세요.

**API Level 24 이상**을 타깃으로 하는 애플리케이션은 프록시의 CA 인증서를 허용하도록 Network Security Config를 수정해야 합니다. 암호화된 트래픽을 검사하려면 이 단계가 중요합니다. Network Security Config 수정 방법은 [**refer to this tutorial**](make-apk-accept-ca-certificate.md)를 참고하세요.

만약 **Flutter**를 사용하고 있다면 [**this page**](flutter.md)의 지침을 따라야 합니다. 단순히 인증서를 스토어에 추가하는 것만으로는 동작하지 않으며, Flutter는 자체적으로 유효한 CA 목록을 사용하기 때문입니다.

#### SSL/TLS pinning의 정적 탐지

런타임 우회 시도를 하기 전에 APK에서 pinning이 적용된 위치를 빠르게 매핑하세요. 정적 탐지는 훅/패치 계획을 세우고 올바른 코드 경로에 집중하는 데 도움이 됩니다.

Tool: SSLPinDetect
- 오픈소스 정적 분석 유틸리티로 APK를 Smali로 디컴파일(apktool 사용)한 뒤 SSL/TLS pinning 구현의 curated regex 패턴을 스캔합니다.
- 각 매치에 대해 정확한 파일 경로, 라인 번호, 코드 스니펫을 보고합니다.
- 일반적인 프레임워크와 커스텀 코드 경로를 다룹니다: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, 그리고 Network Security Config XML pins 등.

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
사용법
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
예제 패턴 규칙 (JSON)
signatures를 사용하거나 확장하여 독점/커스텀 pinning 스타일을 탐지하세요. 자신만의 JSON을 로드하여 대규모로 스캔할 수 있습니다.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
노트 및 팁
- 대규모 앱을 빠르게 스캔하려면 멀티스레딩 및 memory-mapped I/O를 사용하세요; 사전 컴파일된 regex는 오버헤드와 오탐(false positives)을 줄여줍니다.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- 다음으로 우선 순위로 삼아야 할 대표적인 탐지 대상:
- OkHttp: CertificatePinner 사용, setCertificatePinner, okhttp3/okhttp 패키지 참조
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted 오버라이드
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- res/xml network security config 및 manifest 참조에 선언된 pins
- 매칭된 위치를 사용해 Frida hooks, static patches, 또는 config 리뷰를 계획하고 동적 테스트 전에 확인하세요.



#### SSL Pinning 우회

애플리케이션에 SSL Pinning이 구현되어 있으면 HTTPS 트래픽을 검사하기 위해 이를 우회해야 합니다. 이를 위한 여러 방법이 있습니다:

- 자동으로 [**apk-mitm**](https://github.com/shroudedcode/apk-mitm)을 사용해 **apk**를 **수정**하여 SSLPinning을 **우회**할 수 있습니다. 이 옵션의 가장 큰 장점은 SSL Pinning을 우회하기 위해 root가 필요 없다는 점이지만, 애플리케이션을 삭제하고 새로 설치해야 하며 항상 동작하지는 않습니다.
- 이 보호를 우회하기 위해 **Frida**(아래 참조)를 사용할 수 있습니다. Burp+Frida+Genymotion을 사용하는 가이드는 다음을 참조하세요: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- [**objection**](frida-tutorial/objection-tutorial.md)을 사용해 **자동으로 SSL Pinning을 우회**해 볼 수도 있습니다:**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- **MobSF dynamic analysis**(아래 설명)을 사용해 **자동으로 SSL Pinning을 우회**할 수도 있습니다
- 여전히 캡처되지 않은 트래픽이 있다고 생각되면 **iptables를 사용해 트래픽을 Burp로 포워딩**해 보세요. 다음 블로그를 참고하세요: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### 흔한 웹 취약점 탐색

애플리케이션 내에서 흔한 웹 취약점도 함께 찾아보는 것이 중요합니다. 이러한 취약점을 식별하고 완화하는 상세한 내용은 이 요약의 범위를 벗어나며 다른 자료에서 광범위하게 다루어집니다.

### Frida

[Frida](https://www.frida.re)는 개발자, 리버스 엔지니어, 보안 연구원을 위한 dynamic instrumentation toolkit입니다.\
**실행 중인 애플리케이션에 접근해 런타임에 메서드를 훅킹하여 동작을 변경하거나 값 변경/추출, 다른 코드 실행 등을 할 수 있습니다.**\
Android applications을 pentest하려면 Frida 사용법을 알아야 합니다.

- Frida 사용법 배우기: [**Frida tutorial**](frida-tutorial/index.html)
- Frida 작업용 일부 "GUI": [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection은 Frida 사용 자동화를 위해 유용함: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- 유용한 Frida 스크립트 모음: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Frida를 로드해 anti-debugging / anti-frida 메커니즘을 우회하는 방법 시도해 보기: [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (도구 [linjector](https://github.com/erfur/linjector-rs) 참조)

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **메모리 덤프 - Fridump**

애플리케이션이 비밀번호나 니모닉(mnemonics) 같은 민감한 정보를 저장해서는 안 되는 메모리에 저장하고 있는지 확인하세요.

[**Fridump3**](https://github.com/rootbsd/fridump3)를 사용하면 다음 명령으로 앱의 메모리를 덤프할 수 있습니다:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
이것은 메모리를 ./dump 폴더에 dump하고, 그 안에서 다음과 같이 grep할 수 있습니다:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Keystore의 민감한 데이터**

Android에서 Keystore는 민감한 데이터를 저장하기에 최적의 장소이지만, 충분한 권한이 있으면 여전히 **액세스할 수 있습니다**. 애플리케이션은 여기서 **sensitive data in clear text**를 저장하는 경향이 있으므로, pentests는 root 사용자 권한으로 이를 확인해야 하며 기기에 물리적 접근이 가능한 사람은 이 데이터를 탈취할 수 있습니다.

앱이 keystore에 데이터를 저장하더라도, 데이터는 암호화되어야 합니다.

keystore 내부의 데이터에 접근하려면 이 Frida 스크립트를 사용할 수 있습니다: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

다음 Frida 스크립트를 사용하면 Android 애플리케이션이 특정 민감 영역을 보호하기 위해 수행하는 **bypass fingerprint authentication**을 우회할 수 있습니다:
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **백그라운드 이미지**

애플리케이션을 백그라운드로 보낼 때, Android는 **애플리케이션의 스냅샷**을 저장합니다. 이렇게 하면 앱이 포그라운드로 복구될 때 앱보다 먼저 이미지를 로드해 앱이 더 빨리 로드된 것처럼 보입니다.

하지만 이 스냅샷에 **민감한 정보**가 포함되어 있다면, 스냅샷에 접근할 수 있는 사람이 그 정보를 **탈취할 수 있습니다** (접근하려면 root 권한이 필요하다는 점에 유의).

스냅샷은 일반적으로 다음 경로에 저장됩니다: **`/data/system_ce/0/snapshots`**

Android는 레이아웃 파라미터인 **FLAG_SECURE를 설정하여 스크린샷 캡처를 방지**하는 방법을 제공합니다. 이 플래그를 사용하면 창 내용이 보안 처리되어 스크린샷에 나타나지 않거나 비보안 디스플레이에서 표시되는 것을 방지합니다.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

이 도구는 동적 분석 중 여러 도구를 관리하는 데 도움이 됩니다: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

개발자는 종종 이러한 Intent를 처리하고 `startActivity(...)` 또는 `sendBroadcast(...)` 같은 메서드로 전달하는 proxy 컴포넌트(예: activities, services, broadcast receivers)를 만듭니다. 이는 위험할 수 있습니다.

문제는 공격자가 이러한 Intent를 오도하여 non-exported 앱 컴포넌트를 트리거하거나 민감한 content providers에 접근하도록 허용할 수 있다는 점입니다. 예로 `WebView` 컴포넌트가 URL을 `Intent.parseUri(...)`를 통해 `Intent` 객체로 변환한 뒤 실행하면, 악의적인 Intent 주입이 발생할 수 있습니다.

### 주요 요점

- **Intent Injection**은 웹의 Open Redirect 이슈와 유사합니다.
- 취약점은 `Intent` 객체를 extras로 전달하여 리디렉션되어 안전하지 않은 작업을 실행하도록 유도하는 방식으로 악용됩니다.
- 비-exported 컴포넌트 및 content providers가 공격자에게 노출될 수 있습니다.
- WebView의 URL→Intent 변환은 의도치 않은 동작을 유발할 수 있습니다.

### Android 클라이언트 측 인젝션 등

이러한 취약점은 웹에서 이미 익숙할 것입니다. Android 애플리케이션에서는 특히 주의해야 합니다:

- **SQL Injection:** 동적 쿼리나 Content-Providers를 다룰 때는 파라미터화된 쿼리를 사용해야 합니다.
- **JavaScript Injection (XSS):** 모든 WebView에서 JavaScript 및 Plugin 지원이 비활성화되어 있는지 확인하세요(기본적으로 비활성화되어 있음). [여기에서 자세히](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebView에서 파일 시스템 접근을 비활성화해야 합니다(기본적으로 활성화되어 있음) - `(webview.getSettings().setAllowFileAccess(false);)`. [여기에서 자세히](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: 일부 경우 Android 애플리케이션이 세션을 종료할 때 쿠키가 폐기되지 않거나 디스크에 저장될 수 있습니다.
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## 자동 분석

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**정적 분석**

![](<../../images/image (866).png>)

**애플리케이션의 취약점 평가**를 깔끔한 웹 기반 프런트엔드를 통해 제공합니다. 동적 분석도 수행할 수 있으나(환경을 준비해야 함)
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### MobSF를 이용한 Assisted Dynamic analysis

**MobSF**는 **Android**에서의 **dynamic analysis**에도 매우 유용하지만, 그 경우 호스트에 MobSF와 **genymotion**을 설치해야 합니다(가상 머신이나 Docker는 작동하지 않습니다). _참고: 먼저 genymotion에서 **VM을 시작한 후** **MobSF를 시작**해야 합니다._\
The **MobSF dynamic analyser** can:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). 이 모든 것은 스크린샷을 제외하고 자동으로 수행됩니다. 스크린샷은 원할 때 버튼을 눌러야 하며, 모든 exported activities의 스크린샷을 얻으려면 "**Exported Activity Tester**"를 눌러야 합니다.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Frida scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: 모든 로드된 클래스를 출력합니다
- **Capture Strings**: 애플리케이션 사용 중 모든 캡처된 문자열을 출력합니다 (super noisy)
- **Capture String Comparisons**: 매우 유용할 수 있습니다. 비교되는 두 문자열과 결과가 True인지 False인지 표시합니다.
- **Enumerate Class Methods**: 클래스 이름(예: "java.io.File")을 입력하면 해당 클래스의 모든 메서드를 출력합니다.
- **Search Class Pattern**: 패턴으로 클래스를 검색합니다
- **Trace Class Methods**: 전체 클래스를 **Trace**합니다 (클래스의 모든 메서드의 입력과 출력 확인). 기본적으로 MobSF는 여러 흥미로운 Android Api 메서드를 trace합니다.

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf also brings you a shell with some **adb** commands, **MobSF commands**, and common **shell** **commands** at the bottom of the dynamic analysis page. Some interesting commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP 도구**

When http traffic is capture you can see an ugly view of the captured traffic on "**HTTP(S) Traffic**" bottom or a nicer view in "**Start HTTPTools**" green bottom. From the second option, you can **send** the **captured requests** to **proxies** like Burp or Owasp ZAP.\
To do so, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> press "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Once you finish the dynamic analysis with MobSF you can press on "**Start Web API Fuzzer**" to **fuzz http requests** an look for vulnerabilities.

> [!TIP]
> After performing a dynamic analysis with MobSF the proxy settings me be misconfigured and you won't be able to fix them from the GUI. You can fix the proxy settings by doing:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

You can get the tool from [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
이 도구는 일부 **Hooks**를 사용하여 **dynamic analysis**를 수행하는 동안 애플리케이션에서 무슨 일이 일어나고 있는지 알려줍니다.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

This is a **great tool to perform static analysis with a GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

This tool is designed to look for several **security related Android application vulnerabilities**, either in **source code** or **packaged APKs**. The tool is also **capable of creating a "Proof-of-Concept" deployable APK** and **ADB commands**, to exploit some of the found vulnerabilities (Exposed activities, intents, tapjacking...). As with Drozer, there is no need to root the test device.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- 참고하기 쉽도록 추출된 모든 파일을 표시
- APK 파일을 자동으로 Java 및 Smali 형식으로 디컴파일
- AndroidManifest.xml을 분석하여 일반적인 취약점 및 동작을 확인
- 정적 소스 코드 분석을 통해 일반적인 취약점 및 동작을 확인
- 장치 정보
- 그리고 더 많은 기능
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER는 Windows, MacOS X and Linux에서 사용할 수 있는 명령줄 애플리케이션으로, _.apk_ 파일을 취약점을 찾기 위해 분석합니다. 이는 APKs를 압축 해제하고 일련의 규칙을 적용하여 취약점을 탐지하는 방식으로 동작합니다.

모든 규칙은 `rules.json` 파일에 중심화되어 있으며, 각 회사나 테스터는 필요한 분석을 위해 자체 규칙을 생성할 수 있습니다.

최신 바이너리는 [download page](https://superanalyzer.rocks/download.html)에서 다운로드하세요.
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn은 모바일 애플리케이션에서 [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis)를 수행하는 개발자, bugbounty hunters 및 ethical hackers를 돕는 **crossplatform** 도구입니다.

작동 방식은 모바일 애플리케이션 파일(.apk 또는 .ipa 파일)을 StaCoAn 애플리케이션에 드래그 앤 드롭하면 시각적이고 휴대 가능한 리포트를 생성해 준다는 것입니다. 설정과 wordlists를 조정하여 맞춤형 경험을 얻을 수 있습니다.

다운로드[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework는 개발자 또는 hackers가 Android 애플리케이션의 잠재적인 보안 취약점을 찾아내는 데 도움을 주는 Android 취약점 분석 시스템입니다.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn**은 Android 애플리케이션이 생성할 수 있는 잠재적 악성 동작을 탐지하고 사용자에게 경고하는 것을 주목적으로 하는 도구입니다.

감지는 [`androguard`](https://github.com/androguard/androguard) 라이브러리를 사용해 애플리케이션의 Dalvik bytecode로 표현된 **Smali**에 대해 **static analysis**를 수행함으로써 이루어집니다.

이 도구는 다음과 같은 **'나쁜' 애플리케이션의 일반적인 동작**을 찾아냅니다: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA**는 모바일 애플리케이션 역공학 및 분석 프레임워크입니다. 이 도구는 모바일 애플리케이션 역공학 및 분석에 자주 사용되는 도구들을 모아 OWASP 모바일 보안 위협에 대한 테스트를 지원합니다. 목적은 모바일 애플리케이션 개발자와 보안 전문가들이 이 작업을 더 쉽고 친화적으로 수행할 수 있게 하는 것입니다.

다음 작업을 수행할 수 있습니다:

- 다양한 도구를 사용해 Java 및 Smali 코드를 추출
- APK를 분석: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- regexps를 사용하여 APK에서 민감한 정보 추출
- Manifest 분석
- 발견된 도메인 분석: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) 및 [whatweb](https://github.com/urbanadventurer/WhatWeb)
- [apk-deguard.com]을 통해 APK 난독화 해제

### Koodous

악성코드 탐지에 유용: [https://koodous.com/](https://koodous.com/)

## 코드 난독화/난독화 해제

사용하는 서비스와 구성에 따라, Secrets(민감정보)는 난독화되거나 그렇지 않을 수 있습니다.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

위키피디아에 따르면([Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>)): **ProGuard**는 Java 코드를 축소(shrink), 최적화(optimize) 및 난독화(obfuscate)하는 오픈 소스 커맨드라인 도구입니다. 바이트코드(bytecode)를 최적화하고 사용되지 않는 명령어를 탐지 및 제거할 수 있습니다. ProGuard는 자유 소프트웨어이며 GNU GPL v2로 배포됩니다.

ProGuard는 Android SDK의 일부로 배포되며 release 모드로 애플리케이션을 빌드할 때 실행됩니다.

### [DexGuard](https://www.guardsquare.com/dexguard)

APK 난독화 해제에 대한 단계별 가이드는 [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)에서 찾을 수 있습니다.

(해당 가이드에 따르면) 마지막으로 확인했을 때 Dexguard의 동작 방식은 다음과 같았습니다:

- 리소스를 InputStream으로 로드;
- 결과를 FilterInputStream을 상속한 클래스에 전달하여 복호화;
- 리버서의 시간을 낭비하기 위한 쓸모없는 난독화 수행;
- 복호화된 결과를 ZipInputStream에 전달하여 DEX 파일 획득;
- 마지막으로 결과 DEX를 `loadDex` 메서드를 사용해 Resource로 로드.

### [DeGuard](http://apk-deguard.com)

**DeGuard는 Android 난독화 도구가 수행한 난독화 과정을 되돌립니다. 이를 통해 코드 검사 및 라이브러리 예측을 포함한 다양한 보안 분석이 가능해집니다.**

난독화된 APK를 해당 플랫폼에 업로드할 수 있습니다.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

이는 android 앱의 잠재적 보안 취약점을 찾고 android 앱 코드를 deobfuscate하는 LLM 도구입니다. Google의 Gemini public API를 사용합니다.

### [Simplify](https://github.com/CalebFenton/simplify)

이는 일반적인 android deobfuscator입니다. Simplify는 앱을 가상으로 실행(virtually executes)하여 동작을 이해한 다음, 동일하게 동작하지만 사람이 이해하기 쉬운 코드로 최적화하려고 시도합니다. 각 최적화 유형은 단순하고 일반적이어서 특정 난독화 기법이 무엇인지와 무관합니다.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD는 APK가 **어떻게 만들어졌는지**에 대한 정보를 제공합니다. 여러 **compilers**, **packers**, **obfuscators** 및 기타 이상한 것들을 식별합니다. Android용 [_PEiD_]입니다.

### Manual

[이 튜토리얼을 읽어 커스텀 난독화 역분석 방법에 대한 몇 가지 팁을 배우세요](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b는 ubuntu-mate 기반의 Android 보안 가상 머신으로, reverse engineering 및 malware analysis를 위한 최신 프레임워크, 튜토리얼 및 실습(labs) 모음이 포함되어 있습니다.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) 훌륭한 리소스 목록
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android 빠른 코스
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)

## Yet to try

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
