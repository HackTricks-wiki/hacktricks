# Android एप्लिकेशन Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android एप्लिकेशन बुनियादी बातें

इस पृष्ठ को पढ़ना अत्यधिक अनुशंसित है ताकि आप **Android सुरक्षा से संबंधित सबसे महत्वपूर्ण हिस्सों और किसी Android एप्लिकेशन में मौजूद सबसे खतरनाक घटकों** के बारे में जान सकें:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

यह मुख्य टूल है जिसकी आपको किसी Android device (emulated or physical) से कनेक्ट करने के लिए जरूरत होती है.\
**ADB** कंप्यूटर से **USB** या **Network** के माध्यम से डिवाइसों को नियंत्रित करने की सुविधा देता है। यह यूटिलिटी दोनों दिशाओं में फ़ाइलों की **कॉपीिंग**, ऐप्स की **इंस्टॉलेशन** और **अनइंस्टॉलेशन**, shell commands के **execution**, डेटा का **बैकअप**, और लॉग्स को **रीड** करने जैसी अन्य कार्यक्षमताएँ सक्षम बनाती है।

ADB का उपयोग कैसे करना है यह जानने के लिए निम्नलिखित सूची [**ADB Commands**](adb-commands.md) देखें।

## Smali

कभी-कभी किसी एप्लिकेशन के कोड को संशोधित करना रोचक होता है ताकि आप **छिपी हुई जानकारी** (शायद अच्छी तरह obfuscated पासवर्ड या फ्लैग्स) तक पहुँच सकें। ऐसे में, apk को decompile करना, कोड बदलना और फिर APK को पुनः compile करना उपयोगी हो सकता है.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). यह डायनामिक एनालिसिस के दौरान किए जाने वाले कई परीक्षणों के लिए एक **वैकल्पिक तरीका** के रूप में बहुत उपयोगी हो सकता है। इसलिए, इस संभावना को हमेशा ध्यान में रखें।

## अन्य रोचक ट्रिक्स

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Play Integrity attestation spoofing (SafetyNet replacement)](play-integrity-attestation-bypass.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [Android IME / InputMethodService Abuse (Malicious Keyboards)](inputmethodservice-ime-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- डिवाइस से APK निकालना:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- सभी splits और base apks को [APKEditor](https://github.com/REAndroid/APKEditor) के साथ मर्ज करें:
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Android Enterprise & Work Profile Attacks

{{#ref}}
android-enterprise-work-profile-bypass.md
{{#endref}}

## Case Studies & Vulnerabilities


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

{{#ref}}
abusing-android-media-pipelines-image-parsers.md
{{#endref}}

{{#ref}}
../../binary-exploitation/linux-kernel-exploitation/arm64-static-linear-map-kaslr-bypass.md
{{#endref}}

## Static Analysis

सबसे पहले, एक APK का विश्लेषण करने के लिए आपको **take a look to the to the Java code** करने के लिए एक decompiler का उपयोग करना चाहिए।\
Please, [**read here to find information about different available decompilers**](apk-decompilers.md).

### Looking for interesting Info

सिर्फ APK की **strings** को देखने से आप **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** और कोई भी दिलचस्प चीज़ खोज सकते हैं... यहाँ तक कि कोड execution के लिए मौजूद **backdoors** या authentication backdoors (app के लिए hardcoded admin credentials) भी मिल सकते हैं।

**Firebase**

**firebase URLs** पर विशेष ध्यान दें और जांचें कि क्या यह गलत तरीके से configured है। [More information about whats is FIrebase and how to exploit it here.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Basic understanding of the application - Manifest.xml, strings.xml

**एक एप्लिकेशन की _Manifest.xml_ और **_strings.xml_** फ़ाइलों की जाँच संभावित security vulnerabilities का पता लगा सकती है।** इन फाइलों को decompilers का उपयोग करके या APK का extension .zip में बदलकर और फिर unzip करके access किया जा सकता है।

**Manifest.xml** से पहचानी जाने वाली **Vulnerabilities** में शामिल हैं:

- **Debuggable Applications**: _Manifest.xml_ फ़ाइल में debuggable (`debuggable="true"`) के रूप में सेट किए गए Applications जोखिम में होते हैं क्योंकि वे ऐसी कनेक्शन की अनुमति देते हैं जिनसे exploitation हो सकती है। debuggable applications को खोजने और exploit करने के बारे में समझने के लिए संबंधित ट्यूटोरियल देखें।
- **Backup Settings**: संवेदनशील जानकारी से निपटने वाले applications के लिए `android:allowBackup="false"` attribute स्पष्ट रूप से सेट किया जाना चाहिए ताकि adb के माध्यम से unauthorized data backups से बचा जा सके, विशेष रूप से जब usb debugging सक्षम हो।
- **Network Security**: Custom network security configurations (`android:networkSecurityConfig="@xml/network_security_config"`) जो _res/xml/_ में होते हैं, certificate pins और HTTP ट्रैफिक सेटिंग्स जैसी security details निर्दिष्ट कर सकते हैं। उदाहरण के लिए विशिष्ट domains के लिए HTTP ट्रैफिक की अनुमति देना।
- **Exported Activities and Services**: manifest में exported activities और services की पहचान करने से ऐसे components उजागर हो सकते हैं जिनका दुरुपयोग किया जा सकता है। dynamic testing के दौरान आगे के विश्लेषण से यह पता चल सकता है कि इन components का exploitation कैसे किया जा सकता है।
- **Content Providers and FileProviders**: प्रकाशित content providers अनधिकृत पहुँच या डेटा में संशोधन की अनुमति दे सकते हैं। FileProviders की configuration की भी जाँच करनी चाहिए।
- **Broadcast Receivers and URL Schemes**: ये components exploitation के लिए उपयोग किए जा सकते हैं, खासकर यह ध्यान रखते हुए कि URL schemes इनपुट के लिए कैसे प्रबंधित किए जा रहे हैं।
- **SDK Versions**: `minSdkVersion`, `targetSDKVersion`, और `maxSdkVersion` attributes समर्थित Android versions को दर्शाते हैं, जो यह बताता है कि पुराने, vulnerable Android versions का समर्थन ना करना सुरक्षा के लिए कितना महत्वपूर्ण है।

**strings.xml** फ़ाइल से API keys, custom schemas और अन्य developer notes जैसी संवेदनशील जानकारी मिल सकती है, जिससे इन resources की सावधानीपूर्वक समीक्षा करने की आवश्यकता स्पष्ट होती है।

### Tapjacking

**Tapjacking** एक ऐसा attack है जिसमें एक **malicious** **application** लॉन्च की जाती है और वह **victim application** के ऊपर अपनी स्थिति ले लेती है। जब यह visible रूप से victim app को अस्पष्ट कर देता है, तो इसका user interface इस तरह डिज़ाइन किया जाता है कि यूज़र को धोखा देकर उस पर interact करवाया जाए, जबकि यह interaction को victim app तक पास कर देता है।\
प्रभावतः, यह **उपयोगकर्ता को अंधा कर देता है जिससे वह नहीं जान पाता कि वह वास्तव में victim app पर कार्रवाई कर रहा है**।

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

ऐसी एक **activity** जिसकी **`launchMode`** **`singleTask`** पर सेट है और किसी `taskAffinity` की परिभाषा नहीं है, वह Task Hijacking के लिए vulnerable होती है। इसका मतलब यह है कि एक **malicious application** install की जा सकती है और यदि वास्तविक एप्लिकेशन से पहले चालू की जाए तो यह **real application's task को hijack कर सकती है** (जिससे user **malicious application** के साथ interact करते हुए यह सोच सकता है कि वह वास्तविक एप्लिकेशन का उपयोग कर रहा है)।

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Insecure data storage

**Internal Storage**

Android में, internal storage में **stored** फ़ाइलें आमतौर पर केवल उसी **app** द्वारा access किए जाने के लिए डिज़ाइन की गई होती हैं जिसने उन्हें बनाया है। यह security measure Android operating system द्वारा लागू किया जाता है और अधिकांश applications की security जरूरतों के लिए पर्याप्त होता है। हालांकि, डेवलपर्स कभी-कभी `MODE_WORLD_READABLE` और `MODE_WORLD_WRITABLE` जैसे modes का उपयोग करते हैं ताकि फ़ाइलों को विभिन्न applications के बीच **share** किया जा सके। ये modes इन फ़ाइलों तक अन्य applications, संभावित रूप से malicious ones सहित, की पहुँच को प्रतिबंधित नहीं करते।

1. **Static Analysis:**
- **Ensure** करें कि `MODE_WORLD_READABLE` और `MODE_WORLD_WRITABLE` का उपयोग सावधानीपूर्वक जांचा गया है। ये modes फ़ाइलों को अनपेक्षित या अनधिकृत पहुँच के लिए **expose** कर सकते हैं।
2. **Dynamic Analysis:**
- एप्लिकेशन द्वारा बनाई गई फाइलों पर सेट किए गए **permissions** की **verify** करें। विशेष रूप से जाँचें कि क्या कोई फाइलें worldwide readable या writable के रूप में सेट की गई हैं। यह एक गंभीर सुरक्षा जोखिम हो सकता है, क्योंकि यह किसी भी installed application को, उसके स्रोत या उद्देश्य की परवाह किए बिना, इन फाइलों को **read या modify** करने की अनुमति देगा।

**External Storage**

SD Cards जैसे external storage पर फ़ाइलों के मामले में, कुछ सावधानियाँ बरतनी चाहिए:

1. **Accessibility**:
- external storage पर फ़ाइलें **globally readable and writable** होती हैं। इसका अर्थ है कि कोई भी application या user इन फाइलों तक पहुँच सकता है।
2. **Security Concerns**:
- इस आसान पहुँच को देखते हुए, संवेदनशील जानकारी को external storage पर स्टोर करने से बचना चाहिए।
- External storage को हटाया जा सकता है या किसी भी application द्वारा एक्सेस किया जा सकता है, जिससे यह कम सुरक्षित बन जाता है।
3. **Handling Data from External Storage**:
- external storage से प्राप्त डेटा पर हमेशा **input validation** करें। यह आवश्यक है क्योंकि यह डेटा untrusted स्रोत से आता है।
- external storage पर executables या class files को dynamic loading के लिए स्टोर करना सख्ती से discouraged है।
- यदि आपका application external storage से executable फाइलें प्राप्त करता है, तो सुनिश्चित करें कि ये फाइलें **signed and cryptographically verified** हों इससे पहले कि उन्हें dynamically load किया जाए। यह चरण आपके application की security integrity बनाए रखने के लिए महत्वपूर्ण है।

External storage को `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard` में **access** किया जा सकता है

> [!TIP]
> Android 4.4 (**API 17**) से शुरू होकर, SD card में एक directory structure है जो **एक app को केवल उसी directory तक पहुँच सीमित करता है जो विशेष रूप से उस app के लिए है**। यह malicious applications को दूसरे app की फाइलों तक read या write access प्राप्त करने से रोकता है।

**Sensitive data stored in clear-text**

- **Shared preferences**: Android प्रत्येक application को आसानी से xml फाइलें `/data/data/<packagename>/shared_prefs/` पाथ में save करने की अनुमति देता है और कभी-कभी उस फ़ोल्डर में clear-text में संवेदनशील जानकारी मिल सकती है।
- **Databases**: Android प्रत्येक application को आसानी से sqlite databases `/data/data/<packagename>/databases/` पाथ में save करने की अनुमति देता है और कभी-कभी उस फ़ोल्डर में clear-text में संवेदनशील जानकारी मिल सकती है।

### Broken TLS

**Accept All Certificates**

कई बार developers किसी कारणवश सभी certificates स्वीकार कर लेते हैं, भले ही उदाहरण के लिए hostname match न करे, ऐसे lines of code की तरह:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Broken Cryptography

**खराब कुंजी प्रबंधन प्रक्रियाएँ**

कुछ developers संवेदनशील डेटा को local storage में save करते हैं और उसे कोड में hardcoded/predictable key से encrypt कर देते हैं। यह नहीं किया जाना चाहिए क्योंकि कुछ reversing से attackers confidential जानकारी निकाल सकते हैं।

**असुरक्षित और/या Deprecated Algorithms का उपयोग**

Developers को authorisation **checks**, **store** या **send** करने के लिए **deprecated algorithms** का उपयोग नहीं करना चाहिए। इन algorithms में से कुछ हैं: RC4, MD4, MD5, SHA1... यदि पासवर्ड जैसे डेटा को स्टोर करने के लिए **hashes** का उपयोग किया जाता है तो salt के साथ brute-force **resistant** hashes का उपयोग होना चाहिए।

### Other checks

- यह सलाह दी जाती है कि attackers के लिए reverse engineer करना मुश्किल करने हेतु **APK को obfuscate** किया जाए।
- यदि ऐप sensitive है (जैसे bank apps), तो उसे mobile के **rooted** होने की अपनी **जांच** करनी चाहिए और उसके अनुसार प्रतिक्रिया देनी चाहिए।
- यदि ऐप sensitive है (जैसे bank apps), तो उसे यह चेक करना चाहिए कि **emulator** उपयोग किया जा रहा है या नहीं।
- यदि ऐप sensitive है (जैसे bank apps), तो उसे **execute करने से पहले अपनी integrity की जाँच** करनी चाहिए ताकि यह पता चले कि क्या इसे modify किया गया है।
- [**APKiD**](https://github.com/rednaga/APKiD) का उपयोग कर के जाँचें कि किस compiler/packer/obfuscator का उपयोग APK बनाने में किया गया था

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

The tool [**mariana-trench**](https://github.com/facebook/mariana-trench) is capable of finding **vulnerabilities** by **scanning** the **code** of the application. This tool contains a series of **known sources** (that indicates to the tool the **places** where the **input** is **controlled by the user**), **sinks** (which indicates to the tool **dangerous** **places** where malicious user input could cause damages) and **rules**. These rules indicates the **combination** of **sources-sinks** that indicates a vulnerability.

With this knowledge, **mariana-trench will review the code and find possible vulnerabilities on it**.

### Secrets leaked

An application may contain secrets (API keys, passwords, hidden urls, subdomains...) inside of it that you might be able to discover. You could us a tool such as [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)
- In-memory native code execution via JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> First of all, you need an environment where you can install the application and all the environment (Burp CA cert, Drozer and Frida mainly). Therefore, a rooted device (emulated or not) is extremely recommended.

### Online Dynamic analysis

You can create a **free account** in: [https://appetize.io/](https://appetize.io). This platform allows you to **upload** and **execute** APKs, so it is useful to see how an apk is behaving.

You can even **see the logs of your application** in the web and connect through **adb**.

![](<../../images/image (831).png>)

Thanks to the ADB connection you can use **Drozer** and **Frida** inside the emulators.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (You can create **x86** and **arm** devices, and according to [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** versions **support ARM libraries** without needing an slow arm emulator).
- Learn to set it up in this page:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, you need to create an account. _It's recommend to **download** the version **WITH**_ _**VirtualBox** to avoid potential errors._)
- [**Nox**](https://es.bignox.com) (Free, but it doesn't support Frida or Drozer).

> [!TIP]
> किसी भी platform पर नया emulator बनाते समय ध्यान रखें कि स्क्रीन जितनी बड़ी होगी, emulator उतना ही धीमे चलेगा। इसलिए संभव हो तो छोटे स्क्रीन चुनें।

To **install google services** (like AppStore) in Genymotion you need to click on the red marked button of the following image:

![](<../../images/image (277).png>)

Also, notice that in the **configuration of the Android VM in Genymotion** you can select **Bridge Network mode** (this will be useful if you will be connecting to the Android VM from a different VM with the tools).

#### Use a physical device

You need to activate the **debugging** options and it will be cool if you can **root** it:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Once you have installed the application, the first thing you should do is to try it and investigate what does it do, how does it work and get comfortable with it.\
> I will suggest to **perform this initial dynamic analysis using MobSF dynamic analysis + pidcat**, so we will be able to **learn how the application works** while MobSF **captures** a lot of **interesting** **data** you can review later on.

Magisk/Zygisk quick notes (recommended on Pixel devices)
- Patch boot.img with the Magisk app and flash via fastboot to get systemless root
- Enable Zygisk + DenyList for root hiding; consider LSPosed/Shamiko when stronger hiding is required
- Keep original boot.img to recover from OTA updates; re-patch after each OTA
- For screen mirroring, use scrcpy on the host



### Unintended Data Leakage

**Logging**

Developers को सार्वजनिक रूप से **debugging information** उजागर करने में सावधान रहना चाहिए, क्योंकि इससे संवेदनशील data leak हो सकता है। application logs को मॉनिटर करने के लिए [**pidcat**](https://github.com/JakeWharton/pidcat) और `adb logcat` tools की सिफारिश की जाती है ताकि संवेदनशील जानकारी की पहचान और सुरक्षा की जा सके। **Pidcat** अपनी आसानी और readability के कारण पसंद किया जाता है।

> [!WARNING]
> ध्यान दें कि **Android 4.0 के बाद की versions** में, **applications केवल अपने ही logs तक पहुँच सकते हैं**। इसलिए applications दूसरे apps के logs तक नहीं पहुँच सकते।\
> फिर भी, यह सलाह दी जाती है कि **संवेदनशील जानकारी को log न करें**।

**Copy/Paste Buffer Caching**

Android का **clipboard-based** फ्रेमवर्क apps में copy-paste कार्यक्षमता सक्षम करता है, फिर भी यह जोखिम पैदा करता है क्योंकि **अन्य applications** clipboard तक **access** कर सकते हैं, जिससे संवेदनशील डेटा उजागर हो सकता है। इसलिए application के संवेदनशील हिस्सों (जैसे credit card विवरण) के लिए copy/paste फ़ंक्शन disable करना महत्वपूर्ण है ताकि data leak न हो।

**Crash Logs**

यदि कोई application **crash** करती है और logs save करती है, तो ये logs attackers की मदद कर सकते हैं, विशेषकर जब application को reverse-engineer नहीं किया जा सकता। इस जोखिम को कम करने के लिए, crashes पर logging से बचें, और यदि logs नेटवर्क पर भेजने आवश्यक हों तो उन्हें एक SSL चैनल के माध्यम से भेजें।

As pentester, **try to take a look to these logs**.

**Analytics Data Sent To 3rd Parties**

Applications अक्सर Google Adsense जैसे services integrate करते हैं, जो developers की गलत implemention के कारण अनजाने में संवेदनशील डेटा को third-party को भेज सकते हैं। संभावित data leaks की पहचान करने के लिए, application's traffic को intercept करके देखें कि क्या कोई संवेदनशील जानकारी third-party सेवाओं को भेजी जा रही है।

### SQLite DBs

अधिकतर applications information save करने के लिए **internal SQLite databases** का उपयोग करते हैं। pentest के दौरान बनाए गए **databases**, **tables** और **columns** के नामों और उनमें saved सभी **data** को देखें क्योंकि आपको वहाँ पर **sensitive information** मिल सकती है (जो vulnerability होगी)।\
Databases आम तौर पर `/data/data/the.package.name/databases` में स्थित होते हैं जैसे `/data/data/com.mwr.example.sieve/databases`

यदि database confidential information save कर रहा है और वह **encrypted b**ut आप application के अंदर password ढूँढ सकते हैं तो वह फिर भी एक **vulnerability** है।

.tables का उपयोग करके tables enumerate करें और tables के columns को enumerate करने के लिए `.schema <table_name>` चलाएँ

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** आपको **एक Android app की भूमिका ग्रहण करने** और अन्य apps के साथ interact करने की अनुमति देता है। यह वह सब कुछ कर सकता है जो एक installed application कर सकता है, जैसे Android’s Inter-Process Communication (IPC) mechanism का उपयोग करना और underlying operating system के साथ interact करना। .\
Drozer एक उपयोगी tool है ताकि आप **exported activities, exported services और Content Providers** को exploit कर सकें जैसा कि आप अगले sections में जानेंगे।

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Also remember that the code of an activity starts in the **`onCreate`** method.

**Authorisation bypass**

जब एक Activity exported होती है तो आप उसकी screen को किसी external app से invoke कर सकते हैं। इसलिए, यदि किसी activity में **sensitive information** है और वह **exported** है, तो आप authentication mechanisms को **bypass** करके उस तक पहुँच सकते हैं।

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

You can also start an exported activity from adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF malicious के रूप में किसी activity में `android:launchMode` के रूप में _**singleTask/singleInstance**_ के उपयोग का पता लगाएगा, लेकिन [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750) के कारण, स्पष्ट रूप से यह केवल पुराने वर्ज़न (API versions < 21) में ही खतरनाक है।

> [!TIP]
> ध्यान रखें कि एक authorisation bypass हमेशा एक vulnerability नहीं होती — यह इस बात पर निर्भर करेगा कि bypass कैसे काम करता है और कौन सी जानकारी exposed होती है।

**Sensitive information leakage**

**Activities भी परिणाम वापस कर सकती हैं**. यदि आप कोई exported और unprotected activity ढूंढते हैं जो **`setResult`** method कॉल कर रही हो और **returning sensitive information** कर रही हो, तो वहाँ sensitive information leakage है।

#### Tapjacking

यदि tapjacking रोका नहीं गया है, तो आप exported activity का दुरुपयोग करके **user perform unexpected actions** करवाने के लिए मजबूर कर सकते हैं। अधिक जानकारी के लिए [**what is Tapjacking follow the link**](#tapjacking) देखें।

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers मूल रूप से डेटा साझा करने के लिए उपयोग होते हैं। यदि किसी app में content providers उपलब्ध हैं तो आप उनसे संवेदनशील डेटा निकाल (extract) सकते हैं। साथ ही संभावित **SQL injections** और **Path Traversals** का परीक्षण करना भी रुचिकर है क्योंकि वे vulnerable हो सकते हैं।

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
ध्यान रखें कि Service की क्रियाएँ method `onStartCommand` में शुरू होती हैं।

Service मूल रूप से ऐसी चीज़ है जो डेटा प्राप्त कर सकती है, उसे process कर सकती है और (या नहीं) एक response वापस कर सकती है। इसलिए, यदि कोई application कुछ services export कर रहा है तो आपको यह समझने के लिए code की जाँच करनी चाहिए कि वे क्या कर रहे हैं और confidential info निकालने, authentication measures को bypass करने आदि के लिए उन्हें dynamically test करना चाहिए...\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
ध्यान रखें कि Broadcast Receiver की क्रियाएँ method `onReceive` में शुरू होती हैं।

A broadcast receiver कुछ प्रकार के संदेशों का इंतज़ार करेगा। receiver संदेश को कैसे handle करता है, इसके आधार पर वह vulnerable हो सकता है।\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

आप deep links को मैन्युअली खोज सकते हैं, MobSF जैसे tools या [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py) जैसी scripts का उपयोग करके।\
आप adb या browser का उपयोग करके घोषित scheme को **open** कर सकते हैं:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_ध्यान दें कि आप **पैकेज नाम छोड़ सकते हैं** और मोबाइल स्वचालित रूप से उस ऐप को कॉल करेगा जो उस लिंक को खोलना चाहिए।_
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**कोड निष्पादित**

ऐप में जो **code that will be executed in the App** को खोजने के लिए, deeplink द्वारा कॉल की गई activity में जाएँ और फ़ंक्शन **`onNewIntent`** खोजें।

![](<../../images/image (436) (1) (1) (1).png>)

**संवेदनशील जानकारी**

हर बार जब आप कोई deep link पाते हैं तो जाँचें कि **यह sensitive data (like passwords) को URL parameters के माध्यम से प्राप्त तो नहीं कर रहा है**, क्योंकि कोई भी अन्य एप्लिकेशन उस deep link का **impersonate कर सकता है और वह डेटा चुरा सकता है!**

**पाथ में पैरामीटर**

आपको **यह भी जाँचना चाहिए कि कोई deep link URL के path के अंदर parameter का उपयोग तो नहीं कर रहा है** जैसे: `https://api.example.com/v1/users/{username}` , उस स्थिति में आप path traversal को मजबूर कर सकते हैं जैसे: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
ध्यान दें कि यदि आप एप्लिकेशन के अंदर सही endpoints पाएँ तो आप **Open Redirect** (यदि path का भाग domain name के रूप में उपयोग किया गया हो), **account takeover** (यदि आप users details बिना CSRF token के modify कर सकें और vulnerable endpoint ने सही method का उपयोग किया हो) और कोई भी अन्य vuln पैदा कर सकते हैं। More [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### ट्रांसपोर्ट लेयर निरीक्षण और सत्यापन विफलताएँ

- **Certificates हमेशा सही तरीके से निरीक्षण नहीं किए जाते** Android applications द्वारा। आमतौर पर ये applications warnings को अनदेखा कर self-signed certificates स्वीकार कर लेते हैं या, कुछ मामलों में, HTTP connections की ओर लौट जाते हैं।
- **SSL/TLS handshake के दौरान negotiations कभी-कभी कमजोर होते हैं**, जो insecure cipher suites का उपयोग करते हैं। यह vulnerability connection को man-in-the-middle (MITM) attacks के प्रति संवेदनशील बनाती है, जिससे attackers डेटा को decrypt कर सकते हैं।
- **निजी जानकारी का रिसाव** एक जोखिम है जब applications secure channels का उपयोग करके authenticate करती हैं लेकिन फिर अन्य transactions के लिए non-secure channels पर communicate करती हैं। यह तरीका sensitive data, जैसे session cookies या user details, को malicious entities द्वारा interception से सुरक्षित नहीं रखता।

#### Certificate Verification

हम **certificate verification** पर ध्यान देंगे। server के certificate की integrity को verify करना सुरक्षा बढ़ाने के लिए आवश्यक है। यह महत्वपूर्ण है क्योंकि insecure TLS configurations और sensitive data का unencrypted channels पर transmission गंभीर जोखिम पैदा कर सकता है। server certificates verify करने और vulnerabilities को संबोधित करने के विस्तृत चरणों के लिए, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) विस्तृत मार्गदर्शन प्रदान करता है।

#### SSL Pinning

SSL Pinning एक सुरक्षा उपाय है जहाँ application server के certificate को application में संग्रहीत ज्ञात कॉपी के खिलाफ verify करती है। यह तरीका MITM attacks को रोकने के लिए आवश्यक है। संवेदनशील जानकारी हैंडल करने वाले applications के लिए SSL Pinning लागू करना दृढ़ता से सुझाया जाता है।

#### Traffic Inspection

HTTP ट्रैफ़िक का निरीक्षण करने के लिए, जरूरी है कि आप proxy tool का certificate (उदा., Burp) install करें। इस certificate को install किए बिना, encrypted ट्रैफ़िक proxy के माध्यम से दिखाई नहीं दे सकती। custom CA certificate install करने के लिए guide के लिए, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine) देखें।

API Level 24 and above को target करने वाले applications को proxy के CA certificate को स्वीकार करने के लिए Network Security Config में परिवर्तन करने की आवश्यकता होती है। यह चरण encrypted ट्रैफ़िक का निरीक्षण करने के लिए महत्वपूर्ण है। Network Security Config बदलने के निर्देशों के लिए, [**refer to this tutorial**](make-apk-accept-ca-certificate.md) देखें।

यदि **Flutter** का उपयोग किया जा रहा है तो आपको [**this page**](flutter.md) में दिए निर्देशों का पालन करना होगा। ऐसा इसलिए है क्योंकि केवल certificate को store में जोड़ना काम नहीं करेगा क्योंकि Flutter के पास अपनी ही मान्य CAs की सूची होती है।

#### Static detection of SSL/TLS pinning

runtime bypasses का प्रयास करने से पहले, जल्दी से मानचित्र बनाएँ कि APK में कहाँ pinning लागू है। Static discovery आपको hooks/patches की योजना बनाने और सही code paths पर ध्यान केंद्रित करने में मदद करती है।

Tool: SSLPinDetect
- Open-source static-analysis utility जो APK को Smali (via apktool) में decompile करती है और SSL/TLS pinning implementations के curated regex patterns के लिए scan करती है।
- प्रत्येक match के लिए exact file path, line number, और एक code snippet रिपोर्ट करती है।
- सामान्य frameworks और custom code paths को cover करता है: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, और Network Security Config XML pins।

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
उपयोग
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
उदाहरण पैटर्न नियम (JSON)
प्रोप्राइटरी/कस्टम pinning शैलियों का पता लगाने के लिए signatures का उपयोग करें या उन्हें विस्तार करें। आप अपना JSON लोड कर सकते हैं और बड़े पैमाने पर scan कर सकते हैं।
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes and tips
- बड़े apps पर तेज़ स्कैनिंग के लिए multi-threading और memory-mapped I/O का उपयोग करें; pre-compiled regex overhead और false positives को कम करता है।
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Typical detection targets to triage next:
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Declarative pins in res/xml network security config and manifest references
- मैच हुए लोकेशन्स का उपयोग Frida hooks, static patches, या config reviews की योजना बनाने के लिए करें, dynamic testing से पहले।

#### Bypassing SSL Pinning

जब SSL Pinning लागू किया जाता है, तो HTTPS ट्रैफ़िक की जांच के लिए इसे bypass करना आवश्यक हो जाता है। इसके लिए कई तरीके उपलब्ध हैं:

- Automatically **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). इस विकल्प का मुख्य फायदा यह है कि SSL Pinning बायपास करने के लिए आपको root की आवश्यकता नहीं पड़ेगी, लेकिन आपको application को हटाकर नया install करना होगा, और यह हमेशा काम नहीं करेगा।
- You could use **Frida** (discussed below) to bypass this protection. यहाँ Burp+Frida+Genymotion के साथ उपयोग करने का एक गाइड है: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- You can also try to **automatically bypass SSL Pinning** using [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- You can also try to **automatically bypass SSL Pinning** using **MobSF dynamic analysis** (explained below)
- If you still think that there is some traffic that you aren't capturing you can try to **forward the traffic to burp using iptables**. Read this blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Looking for Common Web Vulnerabilities

ऐप्लिकेशन के भीतर सामान्य web vulnerabilities की खोज भी महत्वपूर्ण है। इन vulnerabilities की पहचान और उन्हें mitigate करने के विस्तृत विवरण इस सारांश के दायरे से बाहर हैं, लेकिन इन्हें अन्य जगहों पर विस्तार से कवर किया गया है।

### Frida

[Frida](https://www.frida.re) डेवलपर्स, reverse-engineers, और security researchers के लिए एक dynamic instrumentation toolkit है.\
**आप रनिंग application में access कर सकते हैं और रनटाइम पर methods को hook करके व्यवहार बदल सकते हैं, मान बदल सकते हैं, मान extract कर सकते हैं, अलग code चला सकते हैं...**\
अगर आप Android applications का pentest करना चाहते हैं तो आपको Frida का उपयोग करना आना चाहिए।

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Some "GUI" for actions with Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- You can find some Awesome Frida scripts here: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Try to bypass anti-debugging / anti-frida mechanisms loading Frida as in indicated in [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

जाँच करें कि क्या application मेमोरी में संवेदनशील जानकारी स्टोर कर रहा है जो उसे स्टोर नहीं करनी चाहिए, जैसे passwords या mnemonics।

Using [**Fridump3**](https://github.com/rootbsd/fridump3) you can dump the memory of the app with:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
यह मेमोरी को ./dump फ़ोल्डर में dump कर देगा, और वहां आप कुछ इस तरह grep कर सकते हैं:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Keystore में संवेदनशील डेटा**

Android में Keystore संवेदनशील डेटा स्टोर करने के लिए सबसे अच्छा स्थान है, हालांकि पर्याप्त privileges होने पर फिर भी **इसे एक्सेस करना संभव है**। चूंकि applications यहाँ अक्सर **सेंसिटिव डेटा सादा टेक्स्ट में** स्टोर करती हैं, pentests को इसे root user के रूप में जांचना चाहिए वरना किसी के पास डिवाइस का physical access होने पर वे यह डेटा चुरा सकते हैं।

भले ही किसी app ने keystore में data स्टोर किया हो, उस डेटा को एन्क्रिप्टेड होना चाहिए।

Keystore के अंदर के डेटा तक पहुँचने के लिए आप यह Frida script उपयोग कर सकते हैं: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

निम्नलिखित Frida स्क्रिप्ट का उपयोग करके संभवतः Android applications द्वारा लागू की जा रही **bypass fingerprint authentication** को दरकिनार किया जा सकता है, जो **कुछ संवेदनशील क्षेत्रों की सुरक्षा:** के लिए की जाती है:
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **बैकग्राउंड इमेजेज**

जब आप किसी ऐप को background में भेजते हैं, Android ऐप का एक **snapshot of the application** स्टोर कर देता है ताकि जब उसे foreground में वापस लाया जाए तो यह ऐप के पूरी तरह लोड होने से पहले इमेज लोड करना शुरू कर दे और ऐसा लगे कि ऐप तेज़ी से लोड हुआ।

हालाँकि, यदि इस snapshot में **संवेदनशील जानकारी** हो, तो snapshot तक पहुँच रखने वाला कोई भी व्यक्ति उस जानकारी को **चुरा** सकता है (ध्यान दें कि इसे access करने के लिए आपको root की आवश्यकता होती है)।

Snapshots आमतौर पर यहाँ स्टोर होते हैं: **`/data/system_ce/0/snapshots`**

Android एक तरीका प्रदान करता है जिससे आप layout parameter में **FLAG_SECURE सेट करके screenshot capture को रोक सकते हैं**। इस flag का उपयोग करने पर, window की सामग्री को secure माना जाता है, जिससे वह screenshots में नहीं दिखाई देती और असुरक्षित डिस्प्ले पर नहीं देखी जा सकती।
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

यह टूल dynamic analysis के दौरान विभिन्न टूल्स को प्रबंधित करने में मदद कर सकता है: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

डेवलपर्स अक्सर activities, services, और broadcast receivers जैसे proxy components बनाते हैं जो इन Intents को handle करते हैं और उन्हें `startActivity(...)` या `sendBroadcast(...)` जैसी methods को पास करते हैं, जो जोखिम भरा हो सकता है।

खतरा इस बात में है कि हमलावर इन Intents को misdirect करके non-exported app components को trigger कर सकते हैं या sensitive content providers तक पहुँच सकते हैं। एक उल्लेखनीय उदाहरण है `WebView` component का URLs को `Intent` objects में बदलना `Intent.parseUri(...)` के माध्यम से और फिर उन्हें execute करना, जिससे संभावित रूप से malicious Intent injections हो सकते हैं।

### आवश्यक निष्कर्ष

- **Intent Injection** वेब के Open Redirect issue के समान है।
- Exploits में `Intent` objects को extras के रूप में पास करना शामिल है, जिन्हें redirect करके unsafe operations execute करने के लिए उपयोग किया जा सकता है।
- यह non-exported components और content providers को हमलावरों के लिए expose कर सकता है।
- `WebView` की URL से `Intent` में conversion अनचाहे actions को सक्षम कर सकती है।

### Android Client Side Injections and others

संभवतः आप इन प्रकार की कमजोरियों के बारे में Web से जानते होंगे। Android application में इन कमजोरियों के साथ विशेष सावधानी बरतनी चाहिए:

- **SQL Injection:** जब dynamic queries या Content-Providers के साथ काम कर रहे हों तो सुनिश्चित करें कि आप parameterized queries का उपयोग कर रहे हैं।
- **JavaScript Injection (XSS):** सुनिश्चित करें कि किसी भी WebViews के लिए JavaScript और Plugin support disabled हो (डिफ़ॉल्ट रूप से disabled)। [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews के लिए file system की access disabled होनी चाहिए (डिफ़ॉल्ट रूप से enabled) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: कई मामलों में जब android application session समाप्त होती है तो cookie revoke नहीं की जाती या यह disk पर भी saved हो सकती है
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Static analysis**

![](<../../images/image (866).png>)

**Vulnerability assessment of the application** एक अच्छा web-based frontend का उपयोग करके किया जाता है। आप dynamic analysis भी कर सकते हैं (लेकिन आपको environment तैयार करना होगा)।
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
ध्यान दें कि MobSF **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
इसके अलावा, अगर आप किसी **Android** या **IOS** ऐप का source code लेकर **ZIP** फ़ाइल बनाते हैं (application के root फोल्डर में जाएँ, सब कुछ सेलेक्ट करें और एक ZIPfile बनाएं), तो MobSF उसे भी analyse कर सकता है।

MobSF आपको **diff/Compare** analysis करने की सुविधा भी देता है और **VirusTotal** को integrate करने की सुविधा भी है (आपको अपनी API key _MobSF/settings.py_ में सेट करनी होगी और इसे enable करना होगा: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). आप `VT_UPLOAD` को `False` भी कर सकते हैं, तब **hash** file की बजाय **upload** किया जाएगा।

### MobSF के साथ Assisted Dynamic analysis

**MobSF** Android में **dynamic analysis** के लिए भी बहुत मददगार हो सकता है, लेकिन उस स्थिति में आपको अपने host पर MobSF और **genymotion** install करना होगा (VM या Docker काम नहीं करेगा)। _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
**MobSF dynamic analyser** निम्न कर सकता है:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, और अन्य बनायी गई फाइलें)। यह सब automatic तरीके से होता है सिवाय screenshots के — screenshots लेने के लिए आपको जब चाहिए तब press करना होगा या सभी exported activities के screenshots पाने के लिए "**Exported Activity Tester**" को press करना होगा।
- Capture **HTTPS traffic**
- Use **Frida** से **runtime** **information** प्राप्त करना

android **versions > 5** से यह **automatically start Frida** कर देगा और global **proxy** settings सेट कर देगा ताकि traffic **capture** किया जा सके। यह केवल tested application से होने वाला traffic ही capture करेगा।

**Frida**

By default, यह कुछ Frida Scripts भी उपयोग करेगा ताकि **bypass SSL pinning**, **root detection** और **debugger detection** किया जा सके और **monitor interesting APIs** किया जा सके।\
MobSF exported activities को invoke भी कर सकता है, उनके **screenshots** ले सकता है और report के लिए **save** कर सकता है।

**Start** करने के लिए dynamic testing पर green बटन दबाएँ: "**Start Instrumentation**". "**Frida Live Logs**" पर क्लिक करके आप Frida scripts द्वारा जनरेट किये गए logs देख सकते हैं और "**Live API Monitor**" पर क्लिक करके आप hooked methods के सभी invocations, पास किये गए arguments और returned values देख सकते हैं (यह "Start Instrumentation" दबाने के बाद दिखेga)।\
MobSF आपको अपने खुद के **Frida scripts** भी load करने देता है (अपने Frida scripts के results MobSF को भेजने के लिए `send()` function का उपयोग करें)। इसमें कुछ **pre-written scripts** भी हैं जिन्हें आप load कर सकते हैं (आप और scripts `MobSF/DynamicAnalyzer/tools/frida_scripts/others/` में जोड़ सकते हैं), बस उन्हें **select** करें, "**Load**" दबाएँ और "**Start Instrumentation**" दबाएँ (आप उन scripts के logs "**Frida Live Logs**" के अंदर देख पाएँगे)।

![](<../../images/image (419).png>)

इसके अलावा, कुछ Auxiliary Frida सुविधाएँ हैं:

- **Enumerate Loaded Classes**: यह सभी loaded classes print करेगा
- **Capture Strings**: application का उपयोग करते समय सभी captured strings print करेगा (काफी noisy)
- **Capture String Comparisons**: बहुत उपयोगी हो सकता है। यह **दिखाएगा कि कौन सी 2 strings compare की जा रही थीं** और परिणाम True था या False।
- **Enumerate Class Methods**: क्लास का नाम डालें (जैसे "java.io.File") और यह उस क्लास के सभी methods print कर देगा।
- **Search Class Pattern**: pattern से classes search करें
- **Trace Class Methods**: किसी **पूरी class** को **Trace** करें (उस class के सभी methods के inputs और outputs देखें)। याद रखें कि default रूप से MobSF कई interesting Android Api methods को trace करता है।

एक बार जब आप auxiliary module select कर लेते हैं जो आप उपयोग करना चाहते हैं तो आपको "**Start Intrumentation**" दबाना होगा और आप सभी outputs "**Frida Live Logs**" में देखेंगे।

**Shell**

MobSF dynamic analysis पेज के नीचे यह कुछ **adb** commands, **MobSF commands**, और सामान्य **shell** **commands** के साथ एक shell भी लाता है। कुछ रोचक commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP टूल्स**

When http traffic is capture you can see an ugly view of the captured traffic on "**HTTP(S) Traffic**" bottom or a nicer view in "**Start HTTPTools**" green bottom. From the second option, you can **send** the **captured requests** to **proxies** like Burp or Owasp ZAP.\
To do so, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> press "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Once you finish the dynamic analysis with MobSF you can press on "**Start Web API Fuzzer**" to **fuzz http requests** an look for vulnerabilities.

> [!TIP]
> MobSF के साथ dynamic analysis करने के बाद proxy settings गलत कॉन्फ़िगर हो सकती हैं और आप GUI से उन्हें ठीक नहीं कर पाएँगे। आप proxy settings को ठीक करने के लिए यह कर सकते हैं:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

You can get the tool from [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
यह टूल कुछ **Hooks** का उपयोग करेगा ताकि आपको पता चल सके **एप्लिकेशन में क्या हो रहा है** जब आप **dynamic analysis** कर रहे हों।

### [Yaazhini](https://www.vegabird.com/yaazhini/)

यह **GUI के साथ static analysis करने के लिए एक शानदार टूल** है

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

यह टूल कई **security related Android application vulnerabilities** को खोजने के लिए बनाया गया है, चाहे वो **source code** में हों या **packaged APKs** में। यह टूल कुछ मिली हुई vulnerabilities (Exposed activities, intents, tapjacking...) का एक्सप्लॉइट करने के लिए एक **"Proof-of-Concept" deployable APK** और **ADB commands** बनाने में भी सक्षम है। Drozer की तरह, टेस्ट डिवाइस को root करने की आवश्यकता नहीं है।
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- संदर्भ के लिए सभी extracted files दिखाता है
- APK files को स्वतः Java और Smali फॉर्मेट में decompile करता है
- AndroidManifest.xml को सामान्य vulnerabilities और behavior के लिए analyze करता है
- सामान्य vulnerabilities और behavior के लिए Static source code analysis
- डिवाइस जानकारी
- और अधिक
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER एक command-line application है जिसे Windows, MacOS X और Linux पर इस्तेमाल किया जा सकता है, जो _.apk_ फ़ाइलों का विश्लेषण करके vulnerabilities की तलाश करता है। यह APKs को decompress करके और उन vulnerabilities का पता लगाने के लिए नियमों की एक श्रृंखला लागू करके ऐसा करता है।

सभी नियम `rules.json` फ़ाइल में केन्द्रित हैं, और हर कंपनी या परीक्षक अपनी ज़रूरत के अनुसार विश्लेषण के लिए अपने नियम बना सकते हैं।

नवीनतम binaries डाउनलोड करने के लिए [download page](https://superanalyzer.rocks/download.html) पर जाएँ
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn एक **crossplatform** टूल है जो डेवलपर्स, bugbounty hunters और ethical hackers को मोबाइल एप्लिकेशन पर [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) करने में मदद करता है।

सिद्धांत यह है कि आप अपनी मोबाइल एप्लिकेशन फ़ाइल (.apk या .ipa फ़ाइल) को StaCoAn एप्लिकेशन पर खींचकर छोड़ें और यह आपके लिए एक दृश्य और पोर्टेबल रिपोर्ट बना देगा। आप सेटिंग्स और wordlists को समायोजित करके एक अनुकूलित अनुभव प्राप्त कर सकते हैं।

डाउनलोड[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework एक Android vulnerability analysis सिस्टम है जो डेवलपर्स या hackers को Android applications में संभावित सुरक्षा कमजोरियों का पता लगाने में मदद करता है.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** एक उपकरण है जिसका मुख्य उद्देश्य किसी Android application द्वारा विकसित संभावित हानिकारक व्यवहारों का पता लगाना और उपयोगकर्ता को चेतावनी देना है।

डिटेक्शन एप्लिकेशन के Dalvik bytecode की **static analysis** के माध्यम से की जाती है, जो **Smali** के रूप में प्रस्तुत होती है, और इसके लिए [`androguard`](https://github.com/androguard/androguard) लाइब्रेरी का उपयोग किया जाता है।

यह टूल **"बुरे" एप्लिकेशन के सामान्य व्यवहार** की तलाश करता है, जैसे: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** एक **M**obile **A**pplication **R**everse engineering और **A**nalysis Framework है। यह एक टूल है जो सामान्यतः उपयोग किए जाने वाले mobile application reverse engineering और analysis tools को एक साथ रखता है, ताकि OWASP mobile security threats के खिलाफ mobile applications के परीक्षण में मदद मिल सके। इसका उद्देश्य mobile application developers और security professionals के लिए यह कार्य आसान और अधिक मित्रवत बनाना है।

यह सक्षम है:

- विभिन्न टूल्स का उपयोग करके Java और Smali code को निकालना
- APKs का विश्लेषण करने के लिए उपयोग: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- regexps का उपयोग करके APK से private information निकालना।
- Manifest का विश्लेषण।
- पाए गए domains का विश्लेषण करने के लिए उपयोग: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) और [whatweb](https://github.com/urbanadventurer/WhatWeb)
- APK को deobfuscate करना via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

malware का पता लगाने के लिए उपयोगी: [https://koodous.com/](https://koodous.com)

## Obfuscating/Deobfuscating code

ध्यान दें कि जिस सेवा और कॉन्फ़िगरेशन का आप उपयोग कोड को obfuscate करने के लिए करते हैं, उसके अनुसार secrets obfuscated हो सकते हैं या नहीं भी हो सकते हैं।

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** एक open source command-line टूल है जो Java कोड को shrink, optimize और obfuscate करता है। यह bytecode को optimize करने के साथ-साथ unused instructions का पता लगाकर उन्हें remove भी कर सकता है। ProGuard free software है और GNU General Public License, version 2 के तहत वितरित किया जाता है।

ProGuard Android SDK का हिस्सा के रूप में वितरित होता है और application को release mode में build करते समय चलता है।

### [DexGuard](https://www.guardsquare.com/dexguard)

APK को deobfuscate करने के चरण-दर-चरण गाइड के लिए देखें: [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(उस गाइड से) हमारी आख़िरी जाँच में, Dexguard का mode of operation निम्न था:

- एक resource को InputStream के रूप में लोड करना;
- परिणाम को decrypt करने के लिए FilterInputStream से inherit करने वाली क्लास को देना;
- reverser का कुछ समय बर्बाद करने के लिए कुछ बेकार obfuscation करना;
- decrypted परिणाम को ZipInputStream को देना ताकि DEX फ़ाइल मिले;
- अंततः `loadDex` मेथड का उपयोग करके resulting DEX को एक Resource के रूप में लोड करना।

### [DeGuard](http://apk-deguard.com)

**DeGuard Android obfuscation tools द्वारा किए गए obfuscation की प्रक्रिया को उलट देता है। यह कई security analyses को सक्षम बनाता है, जिनमें code inspection और libraries का अनुमान शामिल है।**

आप एक obfuscated APK को उनकी platform पर upload कर सकते हैं।

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

यह एक LLM टूल है जो android apps में किसी भी संभावित security vulnerabilities का पता लगाने और android app code को deobfuscate करने के लिए है। Google की Gemini public API का उपयोग करता है।

### [Simplify](https://github.com/CalebFenton/simplify)

यह एक generic android deobfuscator है। Simplify virtually executes एक app ताकि उसके व्यवहार को समझ सके और फिर code को optimize करने की कोशिश करता है ताकि वह identical व्यवहार करे पर मानव के लिए समझना आसान हो। हर optimization प्रकार सरल और generic है, इसलिए यह मायने नहीं रखता कि किस specific प्रकार का obfuscation इस्तेमाल किया गया है।

### [APKiD](https://github.com/rednaga/APKiD)

APKiD आपको यह जानकारी देता है कि एक APK कैसे बनाई गई थी। यह कई compilers, packers, obfuscators और अन्य अजीब चीज़ों की पहचान करता है। यह Android के लिए [_PEiD_](https://www.aldeid.com/wiki/PEiD) की तरह है।

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b एक Android security virtual machine है जो ubuntu-mate पर आधारित है और इसमें reverse engineering और malware analysis के लिए विभिन्न security geeks और researchers से latest framework, tutorials और labs का संग्रह शामिल है।

## References

- [Play Integrity API: How It Works & How to Bypass It](https://m4kr0.vercel.app/posts/play-integrity-api-how-it-works--how-to-bypass-it/)
- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) यह resources की एक शानदार सूची है
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
