# Android Uygulamaları Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android Uygulamaları Temelleri

Bu sayfayı okumaya başlamanız şiddetle tavsiye edilir; **Android güvenliği ile ilgili en önemli parçalar ve bir Android uygulamasındaki en tehlikeli bileşenler** hakkında bilgi edinmek için:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Bu, bir android cihaza (emüle edilmiş veya fiziksel) bağlanmak için ihtiyaç duyduğunuz ana araçtır.\
**ADB**, bilgisayardan **USB** veya **Network** üzerinden cihazları kontrol etmeye olanak tanır. Bu yardımcı program, dosyaların her iki yönde **kopyalanması**, uygulamaların **yüklenmesi** ve **kaldırılması**, shell komutlarının **çalıştırılması**, verilerin **yedeklenmesi**, logların **okunması** gibi işlevleri sağlar.

ADB'nin nasıl kullanılacağını öğrenmek için aşağıdaki [**ADB Commands**](adb-commands.md) listesine göz atın.

## Smali

Bazen gizli bilgilere erişmek (ör. iyi obfuskelenmiş parolalar veya flags) için uygulama kodunu **değiştirmek** ilginç olabilir. Bu durumda, apk'yi decompile edip, kodu değiştirip tekrar derlemek ilginç olabilir.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Bu, yapılacak dinamik analiz sırasında gerçekleştirilecek birkaç test için çok kullanışlı bir **alternatif** olabilir. Bu olasılığı her zaman aklınızda bulundurun.

## Other interesting tricks

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Cihazdan APK çıkarma:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Tüm split'leri ve base apk'ları [APKEditor](https://github.com/REAndroid/APKEditor) ile birleştir:
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Vaka İncelemeleri ve Güvenlik Açıkları


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Statik Analiz

Her şeyden önce bir APK'yı analiz etmek için bir decompiler kullanarak **Java koduna bakmalısınız**.\
Lütfen, [**farklı mevcut decompiler'lar hakkında bilgi almak için burayı okuyun**](apk-decompilers.md).

### İlginç Bilgiler Arama

Sadece APK'nın **strings**'ine bakarak **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** ve ilginç olabilecek her şeyi arayabilirsiniz... hatta kod çalıştırma için **backdoors** veya kimlik doğrulama backdoor'ları (uygulamaya gömülü admin kimlik bilgileri) arayın.

**Firebase**

**firebase URLs**'e özellikle dikkat edin ve kötü yapılandırılmış olup olmadığını kontrol edin. [More information about whats is FIrebase and how to exploit it here.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Uygulamanın Temel Anlaşılması - Manifest.xml, strings.xml

Bir uygulamanın _Manifest.xml_ ve _strings.xml_ dosyalarının **incelenmesi potansiyel güvenlik açıklarını ortaya çıkarabilir**. Bu dosyalara decompiler'lar kullanılarak veya APK dosyasının uzantısını .zip yapıp açarak erişilebilir.

**Manifest.xml** dosyasından tespit edilebilecek **güvenlik açıkları** şunlardır:

- **Debuggable Applications**: _Manifest.xml_ dosyasında `debuggable="true"` olarak ayarlanmış uygulamalar risklidir çünkü istismara yol açabilecek bağlantılara izin verirler. Hata ayıklanabilir uygulamaların nasıl bulunup istismar edileceğini öğrenmek için ilgili eğitime bakın.
- **Backup Settings**: Hassas bilgilerle uğraşan uygulamalar için `android:allowBackup="false"` özniteliği açıkça ayarlanmalıdır; özellikle usb debugging etkinse adb üzerinden yetkisiz veri yedeklemelerini önlemek için.
- **Network Security**: _res/xml/_ içindeki özel network security konfigürasyonları (`android:networkSecurityConfig="@xml/network_security_config"`) sertifika pinleri ve HTTP trafiği ayarları gibi güvenlik ayrıntılarını belirtebilir. Örneğin belirli domain'ler için HTTP trafiğine izin verme.
- **Exported Activities and Services**: Manifest'te dışa açık (exported) activity ve service'lerin tespit edilmesi, kötüye kullanılabilecek bileşenleri ortaya çıkarabilir. Dinamik testler sırasında daha fazla analiz, bu bileşenlerin nasıl istismar edilebileceğini gösterebilir.
- **Content Providers and FileProviders**: Açıkta bırakılmış content provider'lar yetkisiz erişime veya veri değişikliğine izin verebilir. FileProvider konfigürasyonu da dikkatle incelenmelidir.
- **Broadcast Receivers and URL Schemes**: Bu bileşenler istismar için kullanılabilir; özellikle URL scheme yönetimindeki giriş doğrulama zafiyetlerine dikkat edilmelidir.
- **SDK Versions**: `minSdkVersion`, `targetSDKVersion` ve `maxSdkVersion` öznitelikleri desteklenen Android sürümlerini gösterir; güvenlik açısından eski ve zayıf Android sürümlerini desteklememenin önemi vurgulanır.

**strings.xml** dosyasından API keys, custom schemas ve diğer geliştirici notları gibi hassas bilgiler keşfedilebilir; bu da bu kaynakların dikkatle incelenmesi gerektiğini gösterir.

### Tapjacking

**Tapjacking**, bir **kötü amaçlı** **uygulamanın** başlatıldığı ve **hedef uygulamanın** üstüne konumlandığı bir saldırıdır. Görsel olarak hedef uygulamayı örttüğünde, kullanıcıyı kandırıp onunla etkileşimde bulunmasını sağlayacak şekilde tasarlanmıştır; bu etkileşimler aynı zamanda hedef uygulamaya iletilir.\
Sonuç olarak, kullanıcıya aslında hedef uygulama üzerinde işlem yaptığını fark ettirmeden onu kör eder.

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Bir **activity**'nin **`launchMode`**'u **`singleTask`** olarak ayarlanmış ve herhangi bir `taskAffinity` tanımlanmamışsa task Hijacking'e karşı savunmasızdır. Bu, bir **application** yüklenip gerçek uygulamadan önce başlatılırsa gerçek uygulamanın görevini **hijack edebileceği** anlamına gelir (yani kullanıcı, gerçek uygulamayı kullanıyor zannederek **kötü amaçlı uygulama** ile etkileşimde bulunacaktır).

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Güvensiz veri depolama

**Dahili Depolama**

Android'de dahili depolamada **saklanan** dosyalar, onları **oluşturan** **uygulama** tarafından erişilebilir olacak şekilde tasarlanmıştır. Bu güvenlik önlemi Android işletim sistemi tarafından uygulanan bir mekanizmadır ve çoğu uygulamanın güvenlik ihtiyaçları için genellikle yeterlidir. Ancak geliştiriciler bazen dosyaların farklı uygulamalar arasında paylaşılmasına izin veren `MODE_WORLD_READABLE` ve `MODE_WORLD_WRITABLE` gibi modları kullanırlar. Bu modlar dosyaların diğer uygulamalar (potansiyel olarak kötü amaçlı olanlar dahil) tarafından erişilmesini kısıtlamaz.

1. **Statik Analiz:**
- **MODE_WORLD_READABLE** ve **MODE_WORLD_WRITABLE** kullanımının dikkatle incelenmesini **sağlayın**. Bu modlar dosyaları **istenmeyen veya yetkisiz erişime açabilir**.
2. **Dinamik Analiz:**
- Uygulama tarafından oluşturulan dosyalara atanmış **izinleri doğrulayın**. Özellikle herhangi bir dosyanın **tüm dünyaya okunabilir veya yazılabilir** olarak ayarlanıp ayarlanmadığını **kontrol edin**. Bu, cihazdaki herhangi bir uygulamanın, kaynağı veya amacı ne olursa olsun, bu dosyaları **okumasına veya değiştirmesine** izin verebileceği için büyük bir güvenlik riski oluşturur.

**Harici Depolama**

SD Kart gibi **harici depolama** ile uğraşırken bazı önlemler alınmalıdır:

1. **Erişilebilirlik**:
- Harici depolamadaki dosyalar **genel olarak okunabilir ve yazılabilir**dir. Yani herhangi bir uygulama veya kullanıcı bu dosyalara erişebilir.
2. **Güvenlik Endişeleri**:
- Kolay erişim nedeniyle hassas bilgilerin harici depolamada saklanmaması tavsiye edilir.
- Harici depolama çıkarılabilir veya herhangi bir uygulama tarafından erişilebilir, bu yüzden daha az güvenlidir.
3. **Harici Depolamadan Veri İşleme**:
- Harici depolamadan alınan veriler üzerinde her zaman **girdi doğrulaması** yapın. Bu çok önemlidir çünkü veriler güvenilmeyen bir kaynaktan gelmektedir.
- Harici depolamada saklanan yürütülebilir veya class dosyalarının dinamik yüklenmesi şiddetle önerilmez.
- Uygulamanızın harici depolamadan yürütülebilir dosyalar alması gerekiyorsa, bu dosyaların dinamik olarak yüklenmeden önce **imzalanmış ve kriptografik olarak doğrulanmış** olduğundan emin olun. Bu adım uygulamanızın güvenlik bütünlüğü için hayati önem taşır.

Harici depolamaya şu yollardan erişilebilir: /storage/emulated/0 , /sdcard , /mnt/sdcard

> [!TIP]
> Android 4.4 (**API 17**) ile başlayarak, SD kartın bir dizin yapısı vardır ve bu yapı bir uygulamanın yalnızca kendine ayrılmış dizine erişimini sınırlar. Bu, kötü amaçlı uygulamaların başka bir uygulamanın dosyalarına okuma veya yazma erişimi kazanmasını engeller.

**Düz metin olarak saklanan hassas veriler**

- **Shared preferences**: Android her uygulamanın `/data/data/<packagename>/shared_prefs/` yoluna xml dosyalarını kolayca kaydetmesine izin verir ve bazen bu klasörde hassas bilgilerin düz metin halinde bulunması mümkündür.
- **Databases**: Android her uygulamanın `/data/data/<packagename>/databases/` yoluna sqlite veritabanlarını kolayca kaydetmesine izin verir ve bazen bu klasörde hassas bilgilerin düz metin halinde bulunması mümkündür.

### Broken TLS

**Tüm Sertifikaları Kabul Etme**

Bazı nedenlerle geliştiriciler bazen tüm sertifikaları kabul ederler; örneğin hostname eşleşmese bile aşağıdaki gibi kod satırlarıyla:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Broken Cryptography

**Poor Key Management Processes**

Bazı geliştiriciler hassas verileri local storage içinde saklayıp, kodda hardcoded/öngörülebilir bir key ile şifreliyor. Bu yapılmamalıdır çünkü reversing ile saldırganlar gizli bilgileri çıkarabilirler.

**Use of Insecure and/or Deprecated Algorithms**

Geliştiriciler yetkilendirme **checks**, **store** veya **send** işlemleri için **deprecated algorithms** kullanmamalıdır. Bunlardan bazıları: RC4, MD4, MD5, SHA1... Örneğin şifreleri saklamak için **hashes** kullanılıyorsa, salt ile birlikte brute-force **resistant** hash algoritmaları tercih edilmelidir.

### Other checks

- APK'yı **obfuscate** etmek, reverse engineer işini zorlaştırmak için önerilir.
- Uygulama hassassa (ör. banka uygulamaları), mobilin **rooted** olup olmadığını **kendi kontrollerini** yapmalı ve sonuca göre davranmalıdır.
- Uygulama hassassa (ör. banka uygulamaları), bir **emulator** kullanılıp kullanılmadığını kontrol etmelidir.
- Uygulama hassassa (ör. banka uygulamaları), çalıştırmadan önce **kendi integrity'sini kontrol etmeli** ve değiştirilip değiştirilmediğini doğrulamalıdır.
- APK'nın hangi compiler/packer/obfuscator ile derlendiğini kontrol etmek için [**APKiD**](https://github.com/rednaga/APKiD) kullanın

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

The tool [**mariana-trench**](https://github.com/facebook/mariana-trench) is capable of finding **vulnerabilities** by **scanning** the **code** of the application. This tool contains a series of **known sources** (that indicates to the tool the **places** where the **input** is **controlled by the user**), **sinks** (which indicates to the tool **dangerous** **places** where malicious user input could cause damages) and **rules**. These rules indicates the **combination** of **sources-sinks** that indicates a vulnerability.

With this knowledge, **mariana-trench will review the code and find possible vulnerabilities on it**.

### Secrets leaked

An application may contain secrets (API keys, passwords, hidden urls, subdomains...) inside of it that you might be able to discover. You could us a tool such as [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> First of all, you need an environment where you can install the application and all the environment (Burp CA cert, Drozer and Frida mainly). Therefore, a rooted device (emulated or not) is extremely recommended.

### Online Dynamic analysis

You can create a **free account** in: [https://appetize.io/](https://appetize.io). This platform allows you to **upload** and **execute** APKs, so it is useful to see how an apk is behaving.

You can even **see the logs of your application** in the web and connect through **adb**.

![](<../../images/image (831).png>)

Thanks to the ADB connection you can use **Drozer** and **Frida** inside the emulators.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (You can create **x86** and **arm** devices, and according to [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** versions **support ARM libraries** without needing an slow arm emulator).
- Learn to set it up in this page:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, you need to create an account. _It's recommend to **download** the version **WITH**_ _**VirtualBox** to avoid potential errors._)
- [**Nox**](https://es.bignox.com) (Free, but it doesn't support Frida or Drozer).

> [!TIP]
> When creating a new emulator on any platform remember that the bigger the screen is, the slower the emulator will run. So select small screens if possible.

To **install google services** (like AppStore) in Genymotion you need to click on the red marked button of the following image:

![](<../../images/image (277).png>)

Also, notice that in the **configuration of the Android VM in Genymotion** you can select **Bridge Network mode** (this will be useful if you will be connecting to the Android VM from a different VM with the tools).

#### Use a physical device

You need to activate the **debugging** options and it will be cool if you can **root** it:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Once you have installed the application, the first thing you should do is to try it and investigate what does it do, how does it work and get comfortable with it.\
> I will suggest to **perform this initial dynamic analysis using MobSF dynamic analysis + pidcat**, so we will be able to **learn how the application works** while MobSF **captures** a lot of **interesting** **data** you can review later on.

### Unintended Data Leakage

**Logging**

Geliştiriciler **debugging information**'ı public olarak ifşa etmek konusunda dikkatli olmalıdır; aksi halde hassas veri leak'lerine yol açabilir. Uygulama loglarını izlemek ve hassas bilgileri tespit etmek için [**pidcat**](https://github.com/JakeWharton/pidcat) ve `adb logcat` önerilir. **Pidcat**, kullanım kolaylığı ve okunabilirliği nedeniyle tercih edilir.

> [!WARNING]
> Note that from **later newer than Android 4.0**, **applications are only able to access their own logs**. So applications cannot access other apps logs.\
> Anyway, it's still recommended to **not log sensitive information**.

**Copy/Paste Buffer Caching**

Android'in **clipboard-based** framework'ü uygulamalar arasında kopyala-yapıştır fonksiyonunu sağlar, fakat diğer uygulamaların clipboard'a erişebilmesi nedeniyle hassas verilerin ifşa olma riski vardır. Kredi kartı bilgileri gibi hassas bölümler için copy/paste fonksiyonlarını devre dışı bırakmak önemlidir.

**Crash Logs**

Eğer bir uygulama **crash** olup log kaydederse, bu loglar özellikle uygulama reverse edilemiyorsa saldırganlara yardımcı olabilir. Bu riski azaltmak için crash durumunda log tutmaktan kaçının ve loglar ağ üzerinden gönderilecekse SSL kanalı üzerinden gönderildiğinden emin olun.

Bir pentester olarak, **bu loglara göz atmayı** deneyin.

**Analytics Data Sent To 3rd Parties**

Uygulamalar sıklıkla Google Adsense gibi servisleri entegre eder; geliştiricinin hatalı uygulaması nedeniyle hassas veriler istemeden üçüncü taraflara **leak** edilebilir. Olası veri leak'lerini tespit etmek için uygulamanın trafiğini intercept etmek ve üçüncü taraflara gönderilen hassas bilgileri kontrol etmek önerilir.

### SQLite DBs

Çoğu uygulama bilgi saklamak için **internal SQLite databases** kullanır. Pentest sırasında oluşturulan **databaseları**, **tabloların** ve **sütunların** isimlerini ve saklanan tüm **verileri** inceleyin; hassas bilgi bulabilirsiniz (bu bir vulnerability olur).\
Databases genelde `/data/data/the.package.name/databases` içinde yer alır, örn `/data/data/com.mwr.example.sieve/databases`

Eğer database gizli bilgileri saklıyor ve **encrypted** ise ama uygulama içinde **password**'u bulabiliyorsanız bu hâlâ bir **vulnerability**'dir.

Tabloları `.tables` ile, tablolardaki sütunları ise `.schema <table_name>` ile enumerate edin.

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer is s useful tool to **exploit exported activities, exported services and Content Providers** as you will learn in the following sections.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Also remember that the code of an activity starts in the **`onCreate`** method.

**Authorisation bypass**

When an Activity is exported you can invoke its screen from an external app. Therefore, if an activity with **sensitive information** is **exported** you could **bypass** the **authentication** mechanisms **to access it.**

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

You can also start an exported activity from adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF, bir activity'de `android:launchMode` olarak _**singleTask/singleInstance**_ kullanımını kötü amaçlı olarak tespit edecektir, ancak [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), görünüşe göre bu yalnızca eski sürümlerde (API sürümleri < 21) tehlikelidir.

> [!TIP]
> Bir yetkilendirme bypass'ı her zaman bir zafiyet değildir; bu, bypass'ın nasıl çalıştığına ve hangi bilgilerin açığa çıktığına bağlıdır.

**Hassas bilgi sızıntısı**

Activity'ler ayrıca sonuç döndürebilir. Eğer dışa açılmış (exported) ve korunmasız bir activity bulur, bunun **`setResult`** metodunu çağırdığını ve **hassas bilgi döndürdüğünü** tespit ederseniz, hassas bilgi sızıntısı vardır.

#### Tapjacking

Eğer tapjacking engellenmemişse, dışa açılmış activity'yi kötüye kullanarak **kullanıcının beklenmeyen işlemler yapmasını** sağlayabilirsiniz. For more info about [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content provider'lar temel olarak veri paylaşmak için kullanılır. Eğer bir uygulamada erişilebilir content provider'lar varsa, bunlardan hassas verileri çekebilmeniz mümkün olabilir. Ayrıca potansiyel SQL injections ve Path Traversals için test etmek önemlidir çünkü bunlar zafiyete açık olabilir.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Unutmayın ki bir Service'in işlemleri `onStartCommand` metodunda başlar.

Service temelde veri alabilen, işleyebilen ve (veya) bir yanıt döndürebilen bir bileşendir. Bu nedenle, bir uygulama bazı servisleri export ediyorsa, ne yaptığını anlamak için kodu kontrol etmeli ve gizli bilgileri çıkarmak, kimlik doğrulama önlemlerini bypass etmek gibi amaçlarla dinamik olarak test etmelisiniz.\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Unutmayın ki bir Broadcast Receiver'ın işlemleri `onReceive` metodunda başlar.

Bir broadcast receiver belirli bir mesaj türünü bekler. Alıcının mesajı nasıl işlediğine bağlı olarak zafiyete açık olabilir.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Deep link'leri manuel olarak, MobSF gibi araçlar veya [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py) gibi script'ler kullanarak arayabilirsiniz.\
Bildirilen bir scheme'i adb veya bir browser kullanarak açabilirsiniz:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Paket adını **atlayabileceğinizi** unutmayın; mobil cihaz bu bağlantıyı açması gereken uygulamayı otomatik olarak çağıracaktır._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Yürütülen kod**

Uygulamada **yürütülecek kodu** bulmak için, deeplink tarafından çağrılan activity'ye gidin ve **`onNewIntent`** fonksiyonunu arayın.

![](<../../images/image (436) (1) (1) (1).png>)

**Hassas bilgi**

Her deeplink bulduğunuzda, **URL parametreleri aracılığıyla (ör. parolalar) hassas veri almadığından emin olun**, çünkü başka bir uygulama deeplink'i taklit ederek bu verileri çalabilir!

**Parameters in path**

Ayrıca herhangi bir deeplink'in URL path'inin içinde parametre kullanıp kullanmadığını da kontrol etmelisiniz; örneğin: `https://api.example.com/v1/users/{username}`. Bu durumda şu şekilde bir path traversal zorlayabilirsiniz: `example://app/users?username=../../unwanted-endpoint%3fparam=value`.\
Uygulama içinde doğru endpoint'leri bulursanız, path'in bir kısmı domain adı olarak kullanılıyorsa bir **Open Redirect** (yeniden yönlendirme) oluşturabilir, CSRF token olmadan kullanıcı detaylarını değiştirebiliyorsanız ve vuln endpoint doğru HTTP metodunu kullanıyorsa **account takeover** ve diğer zafiyetlere yol açabilirsiniz. More [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Transport Layer Inspection and Verification Failures

- **Certificates are not always inspected properly** by Android applications. Bu uygulamaların uyarıları göz ardı edip self-signed sertifikaları kabul etmesi veya bazı durumlarda HTTP bağlantılarına geri dönmesi yaygındır.
- **Negotiations during the SSL/TLS handshake are sometimes weak**, insecure cipher suite'ler kullanılabiliyor. Bu zayıflık bağlantıyı man-in-the-middle (MITM) saldırılarına açık hale getirir ve saldırganların veriyi çözmesine izin verebilir.
- **Leakage of private information** is a risk when applications authenticate using secure channels but then communicate over non-secure channels for other transactions. Bu yaklaşım, oturum çerezleri veya kullanıcı bilgileri gibi hassas verileri kötü niyetli kişilerin ele geçirmesine karşı koruyamaz.

#### Certificate Verification

Biz **certificate verification** üzerinde yoğunlaşacağız. Sunucunun sertifikasının bütünlüğünün doğrulanması güvenliği artırmak için kritik öneme sahiptir. Güvensiz TLS konfigürasyonları ve hassas verinin şifrelenmemiş kanallar üzerinden iletilmesi ciddi riskler oluşturabilir. Sunucu sertifikalarını doğrulama ve zafiyetleri ele alma adımları için [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) kapsamlı rehberlik sunar.

#### SSL Pinning

SSL Pinning, uygulamanın sunucunun sertifikasını uygulama içinde saklanan bilinen bir kopya ile doğruladığı bir güvenlik önlemidir. Bu yöntem MITM saldırılarını önlemek için önemlidir. Hassas bilgi işleyen uygulamalar için SSL Pinning uygulanması şiddetle tavsiye edilir.

#### Traffic Inspection

HTTP trafiğini incelemek için proxy aracının sertifikasını (örn. Burp) **yüklemeniz** gerekir. Bu sertifika yüklenmezse, şifrelenmiş trafik proxy üzerinden görünmeyebilir. Özel bir CA sertifikasının nasıl yükleneceğine dair rehber için [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

API Level 24 ve üzerini hedefleyen uygulamalar, proxy'nin CA sertifikasını kabul etmek için Network Security Config üzerinde değişiklik gerektirir. Bu adım şifrelenmiş trafiği incelemek için kritiktir. Network Security Config'i değiştirme talimatları için [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

Eğer **Flutter** kullanılıyorsa, [**this page**](flutter.md) içindeki talimatları takip etmelisiniz. Çünkü sadece sertifikayı store'a eklemek işe yaramaz; Flutter'ın kendi geçerli CA listesi vardır.

#### Static detection of SSL/TLS pinning

Runtime bypass denemelerine başlamadan önce, pinning'in APK içinde nerede uygulandığını hızlıca haritalayın. Statik keşif, hook/patch planlamanıza yardımcı olur ve doğru kod yollarına odaklanmanızı sağlar.

Tool: SSLPinDetect
- Open-source static-analysis utility that decompiles the APK to Smali (via apktool) and scans for curated regex patterns of SSL/TLS pinning implementations.
- Eşleşen her öğe için tam dosya yolu, satır numarası ve bir kod snippet'i raporlar.
- OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers ve Network Security Config XML pin'leri gibi yaygın framework ve custom kod yollarını kapsar.

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Kullanım
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Örnek pattern kuralları (JSON)
Özel/custom pinning stillerini tespit etmek için signatures'i kullanın veya genişletin. Kendi JSON'unuzu yükleyip ölçekli olarak tarama yapabilirsiniz.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes and tips
- Büyük uygulamalarda çok iş parçacıklı ve memory-mapped I/O ile hızlı tarama; önceden derlenmiş regex aşırı yükü/yanlış pozitifleri azaltır.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Sonraki önceliklendirme (triage) için tipik tespit hedefleri:
- OkHttp: CertificatePinner kullanım, setCertificatePinner, okhttp3/okhttp paket referansları
- Özel TrustManager'lar: javax.net.ssl.X509TrustManager, checkServerTrusted override'ları
- Özel SSL context'leri: SSLContext.getInstance + SSLContext.init ile özel manager'lar
- res/xml içindeki deklaratif pin'ler, network security config ve manifest referansları
- Eşleşen konumları, dinamik testlerden önce Frida hook'ları, statik yamalar veya konfigürasyon incelemelerini planlamak için kullanın.



#### SSL Pinning'i Atlatma

SSL Pinning uygulandığında, HTTPS trafiğini incelemek için bunu atlatmak gerekebilir. Bu amaçla çeşitli yöntemler mevcuttur:

- [**apk-mitm**](https://github.com/shroudedcode/apk-mitm) ile **apk**'yi otomatik olarak **değiştirip** SSLPinning'i **atlatabilirsiniz**. Bu seçeneğin en büyük avantajı, SSL Pinning'i atlatmak için root'a ihtiyaç duymamanızdır; ancak uygulamayı silip yeniden yüklemeniz gerekir ve bu her zaman işe yaramayabilir.
- Bu korumayı atlatmak için aşağıda bahsedilen **Frida**'yı kullanabilirsiniz. Burp+Frida+Genymotion kullanımı için bir rehber: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- [**objection**](frida-tutorial/objection-tutorial.md) kullanarak SSL Pinning'i otomatik olarak atlatmayı da deneyebilirsiniz: `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Ayrıca **MobSF dynamic analysis** kullanarak SSL Pinning'i otomatik olarak atlatmayı deneyebilirsiniz (aşağıda açıklanmıştır)
- Hâlâ yakalayamadığınız trafik olduğunu düşünüyorsanız, trafiği iptables kullanarak burp'a yönlendirmeyi deneyebilirsiniz. Bu blogu okuyun: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Yaygın Web Zafiyetleri Arama

Uygulama içinde yaygın web zafiyetlerini aramak da önemlidir. Bu zafiyetlerin tespiti ve hafifletilmesiyle ilgili detaylar bu özetin kapsamı dışında olup başka kaynaklarda genişçe ele alınmıştır.

### Frida

[Frida](https://www.frida.re) geliştiriciler, reverse-engineer'lar ve güvenlik araştırmacıları için bir dynamic instrumentation toolkit'tir.\
**Çalışan uygulamaya erişip çalışma zamanında metodları hook'layarak davranışı değiştirebilir, değerleri değiştirebilir, değerleri çıkartabilir, farklı kod çalıştırabilirsiniz...**\
Android uygulamalarını pentest etmek istiyorsanız Frida'yı nasıl kullanacağınızı bilmeniz gerekir.

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Some "GUI" for actions with Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection Frida kullanımını otomatikleştirmek için harikadır: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- You can find some Awesome Frida scripts here: [**https://codeshare.frida.re/**](https://codeshare.frida.re/)
- Anti-debugging / anti-frida mekanizmalarını atlatmaya çalışın; Frida'yı şu adreste gösterildiği şekilde yükleyerek: [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (araç [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning atlatma iş akışı

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Bellek Dökümü - Fridump**

Uygulamanın, parolalar veya mnemonikler gibi saklamaması gereken hassas bilgileri bellekte tutup tutmadığını kontrol edin.

Using [**Fridump3**](https://github.com/rootbsd/fridump3) you can dump the memory of the app with:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Bu, belleği ./dump klasörüne dökecek ve orada şöyle bir komutla grep yapabilirsiniz:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Keystore içindeki hassas veriler**

Android'de Keystore hassas verileri saklamak için en iyi yerdir, ancak yeterli ayrıcalığa sahip olunursa yine de **erişmek mümkün**. Uygulamalar burada genellikle **hassas verileri düz metin olarak** depolama eğiliminde olduğundan, pentests bunu kontrol etmelidir; root kullanıcı veya cihaza fiziksel erişimi olan kişiler bu verileri çalabilir.

Bir uygulama veriyi keystore'a depolamış olsa bile, veriler şifrelenmiş olmalıdır.

keystore içindeki verilere erişmek için bu Frida script'ini kullanabilirsiniz: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Aşağıdaki Frida script'ini kullanarak, Android uygulamalarının **belirli hassas alanları korumak için** uyguluyor olabileceği **bypass fingerprint authentication** işlemini atlamak mümkün olabilir:
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Arka Plan Görüntüleri**

Bir uygulamayı arka plana attığınızda, Android uygulamanın **anlık görüntüsünü** saklar; böylece uygulama öne getirildiğinde, uygulamanın kendisinden önce bu görüntüyü yüklemeye başlayarak uygulamanın daha hızlı yüklenmiş gibi görünmesini sağlar.

Ancak bu anlık görüntü **hassas bilgi** içeriyorsa, anlık görüntüye erişimi olan biri **o bilgiyi çalabilir** (erişim için root gerektiğini unutmayın).

Anlık görüntüler genellikle şu dizinde saklanır: **`/data/system_ce/0/snapshots`**

Android, layout parametresi olarak **FLAG_SECURE'i ayarlayarak ekran görüntüsü alınmasını engelleme** yolunu sağlar. Bu bayrağı kullanarak, pencere içeriği güvenli kabul edilir; böylece ekran görüntülerinde görünmesi veya güvenli olmayan ekranlarda görüntülenmesi engellenir.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Bu araç dinamik analiz sırasında farklı araçları yönetmenize yardımcı olabilir: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Geliştiriciler sıklıkla bu Intents ile ilgilenen ve `startActivity(...)` veya `sendBroadcast(...)` gibi yöntemlere ileten activities, services ve broadcast receivers gibi proxy bileşenler oluştururlar; bu durum riskli olabilir.

Tehlike, saldırganların bu Intents'i yanlış yönlendirerek non-exported app components'i tetiklemesine veya hassas content providers'a erişmesine izin vermekte yatar. Örnek olarak `WebView` bileşeninin URL'leri `Intent.parseUri(...)` ile `Intent` nesnelerine dönüştürmesi ve sonra bunları çalıştırması, potansiyel olarak kötü amaçlı Intent enjeksiyonlarına yol açabilir.

### Essential Takeaways

- **Intent Injection** web'deki Open Redirect sorununa benzer.
- Sömürüler, `Intent` nesnelerinin extras olarak geçirilmesini ve bunların güvenli olmayan işlemleri yürütmek üzere yönlendirilmesini içerir.
- Bu, non-exported components ve content providers'ı saldırganlara açabilir.
- `WebView`’ın URL'den `Intent` dönüşümü istenmeyen işlemleri kolaylaştırabilir.

### Android Client Side Injections and others

Muhtemelen bu tür zafiyetleri Web'den biliyorsunuzdur. Bir Android uygulamasında bu zafiyetlere özellikle dikkat etmelisiniz:

- **SQL Injection:** Dynamic sorgularla veya Content-Providers ile uğraşırken parametreli sorgular kullandığınızdan emin olun.
- **JavaScript Injection (XSS):** Herhangi bir WebView için JavaScript ve Plugin desteğinin devre dışı bırakıldığını doğrulayın (varsayılan olarak devre dışı). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebView'ların dosya sistemine erişiminin kapalı olması gerekir (varsayılan olarak açık) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: Birçok durumda Android uygulama oturumu sonlandırdığında cookie iptal edilmez veya hatta diske kaydedilmiş olabilir.
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Static analysis**

![](<../../images/image (866).png>)

**Vulnerability assessment of the application** hoş bir web tabanlı frontend kullanılarak yapılır. Ayrıca dinamik analiz de gerçekleştirebilirsiniz (ancak ortamı hazırlamanız gerekir).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
MobSF'in **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Ayrıca, bir **Android** veya bir **IOS** uygulamasının kaynak koduyla bir **ZIP** dosyası oluşturursanız (uygulamanın kök klasörüne gidin, her şeyi seçin ve bir ZIPfile oluşturun), MobSF bunu da analiz edebilir.

MobSF ayrıca analizleri **diff/Compare** etmenize ve **VirusTotal** ile entegre olmanıza olanak tanır (API anahtarınızı _MobSF/settings.py_ içinde ayarlamanız ve etkinleştirmeniz gerekir: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). `VT_UPLOAD`'ı `False` yaparsanız, dosya yerine **hash** **upload** edilecektir.

### MobSF ile Destekli Dinamik Analiz

**MobSF** ayrıca **Android** için dinamik analiz konusunda çok faydalı olabilir, ancak bu durumda host'unuza MobSF ve **genymotion** kurmanız gerekir (VM veya Docker çalışmaz). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
**MobSF dynamic analyser** şunları yapabilir:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). Tüm bunlar otomatik olarak yapılır; sadece ekran görüntüleri için, ekran görüntüsü almak istediğinizde butona basmanız veya tüm exported aktivitelerin ekran görüntülerini almak için "**Exported Activity Tester**"a basmanız gerekir.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

Android **versions > 5** sürümlerinden itibaren, **otomatik olarak Frida'yı başlatır** ve trafiği **capture** etmek için global **proxy** ayarlarını yapılandırır. Yalnızca test edilen uygulamanın trafiğini yakalar.

**Frida**

Varsayılan olarak, bazı Frida Scripts kullanarak **bypass SSL pinning**, **root detection** ve **debugger detection** yapar ve ilginç API'leri **monitor** eder.\
MobSF ayrıca **invoke exported activities** yapabilir, bunların **screenshots**'larını alabilir ve rapor için **save** edebilir.

Dinamik testi **start** etmek için yeşil butona basın: "**Start Instrumentation**". Frida script'leri tarafından üretilen logları görmek için "**Frida Live Logs**" a basın ve hooked metodlara yapılan tüm invokasyonları, geçirilen argümanları ve dönen değerleri görmek için "**Live API Monitor**" a basın (bu, "Start Instrumentation" a bastıktan sonra görünecektir).\
MobSF ayrıca kendi **Frida scripts**'lerinizi yüklemenize izin verir (Frida script'lerinizin sonuçlarını MobSF'ye göndermek için `send()` fonksiyonunu kullanın). Ayrıca yükleyebileceğiniz **several pre-written scripts** içerir (daha fazlasını `MobSF/DynamicAnalyzer/tools/frida_scripts/others/` dizinine ekleyebilirsiniz), sadece **select them**, "**Load**" a basın ve "**Start Instrumentation**" a basın (bu scriptlerin loglarını "**Frida Live Logs**" içinde görebileceksiniz).

![](<../../images/image (419).png>)

Ayrıca bazı yardımcı Frida fonksiyonları vardır:

- **Enumerate Loaded Classes**: Yüklenen tüm sınıfları yazdırır
- **Capture Strings**: Uygulamayı kullanırken tüm capture string'leri yazdırır (çok gürültülü)
- **Capture String Comparisons**: Çok faydalı olabilir. Karşılaştırılan iki string'i gösterir ve sonucun True veya False olduğunu bildirir.
- **Enumerate Class Methods**: Sınıf adını girin (ör. "java.io.File") ve sınıfın tüm metodlarını yazdırır.
- **Search Class Pattern**: Desene göre sınıfları arar
- **Trace Class Methods**: Bir sınıfın tamamını **Trace** eder (sınıftaki tüm metodların giriş ve çıkışlarını görür). Unutmayın, varsayılan olarak MobSF birkaç ilginç Android API metodunu trace eder.

Yardımcı modülü seçtikten sonra "**Start Intrumentation**" a basmanız gerekir ve tüm çıktıları "**Frida Live Logs**" içinde göreceksiniz.

**Shell**

MobSF ayrıca dynamic analysis sayfasının alt kısmında bazı **adb** komutları, **MobSF commands**, ve yaygın **shell** **commands** içeren bir shell sunar. Bazı ilginç komutlar:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP araçları**

HTTP trafiği yakalandığında, yakalanan trafiğin kaba bir görünümünü "**HTTP(S) Traffic**" alt kısmında veya daha hoş bir görünümünü "**Start HTTPTools**" yeşil butonunda görebilirsiniz. İkinci seçenekten, **send** the **captured requests** to **proxies** like Burp or Owasp ZAP yapabilirsiniz.\
Bunu yapmak için, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> basın "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

MobSF ile dinamik analizi bitirdikten sonra "**Start Web API Fuzzer**" tuşuna basarak **fuzz http requests** yapabilir ve zayıflıkları arayabilirsiniz.

> [!TIP]
> MobSF ile dinamik analiz yaptıktan sonra proxy ayarları yanlış yapılandırılmış olabilir ve GUI üzerinden düzeltemeyebilirsiniz. Proxy ayarlarını şu komutla düzeltebilirsiniz:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Inspeckage ile Yardımlı Dinamik Analiz

Aracı [**Inspeckage**](https://github.com/ac-pm/Inspeckage) adresinden edinebilirsiniz.\
Bu araç, **dynamic analysis** yaparken uygulamada **nelerin olduğunu** anlamanız için bazı **Hooks** kullanır.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Bu, GUI ile static analysis yapmak için harika bir araçtır.

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Bu araç, hem **source code** hem de **packaged APKs** içinde çeşitli **security related Android application vulnerabilities** aramak için tasarlanmıştır. Araç ayrıca bulunan bazı zayıflıkları (Exposed activities, intents, tapjacking...) kullanmak için dağıtılabilir bir **"Proof-of-Concept" deployable APK** ve **ADB commands** oluşturma yeteneğine sahiptir. Drozer'da olduğu gibi, test cihazını rootlamaya gerek yoktur.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Kolay referans için tüm çıkarılan dosyaları gösterir.
- APK dosyalarını otomatik olarak Java ve Smali formatına decompile eder.
- AndroidManifest.xml dosyasını yaygın güvenlik açıkları ve davranışlar açısından analiz eder.
- Yaygın güvenlik açıkları ve davranışlar için statik kaynak kodu analizi yapar.
- Cihaz bilgileri
- ve daha fazlası
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER, Windows, MacOS X ve Linux'ta kullanılabilen bir komut satırı uygulamasıdır; _.apk_ dosyalarını güvenlik açıkları açısından analiz eder. Bunu, APK'leri dekomprese ederek ve bu açıkları tespit etmek için bir dizi kural uygulayarak yapar.

Tüm kurallar `rules.json` dosyasında toplanmıştır ve her şirket veya test uzmanı ihtiyaçlarına göre kendi kurallarını oluşturabilir.

En son ikili dosyaları [download page](https://superanalyzer.rocks/download.html) üzerinden indirin.
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn, mobil uygulamalar üzerinde [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) yapan geliştiricilere, bugbounty hunters ve ethical hackers'e yardımcı olan bir **crossplatform** araçtır.

Konsept, mobil uygulama dosyanızı (.apk veya .ipa dosyası) StaCoAn uygulamasına sürükleyip bırakmanız ve bunun sizin için görsel ve taşınabilir bir rapor oluşturmasıdır. Ayarları ve wordlists'i düzenleyerek özelleştirilmiş bir deneyim elde edebilirsiniz.

İndir[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework, geliştiriciler veya hackers için Android uygulamalarındaki potansiyel güvenlik açıklarını bulmaya yardımcı olan bir Android zafiyet analiz sistemidir.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** Android uygulamalarının potansiyel kötü amaçlı davranışlarını tespit etmek ve kullanıcıyı uyarmak amacıyla geliştirilmiş bir araçtır.

Tespit, uygulamanın Dalvik bytecode'unun **Smali** olarak temsil edildiği **static analysis** ile [`androguard`](https://github.com/androguard/androguard) kütüphanesi kullanılarak gerçekleştirilir.

Bu araç, **kötü uygulamaların ortak davranışlarını** şu durumlarda arar: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. It is a tool that puts together commonly used mobile application reverse engineering and analysis tools, to assist in testing mobile applications against the OWASP mobile security threats. Its objective is to make this task easier and friendlier to mobile application developers and security professionals.

It is able to:

- Extract Java and Smali code using different tools
- Analyze APKs using: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Extract private information from the APK using regexps.
- Analyze the Manifest.
- Analyze found domains using: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Malware tespiti için faydalı: [https://koodous.com/](https://koodous.com/)

## Kodun Obfuskasyonu/Deobfuskasyonu

Kodu obfuskasyon için kullandığınız servis ve yapılandırmaya bağlı olarak, gizli bilgiler obfuskelenmiş olabilir ya da olmayabilir.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. It is able to optimize bytecode as well as detect and remove unused instructions. ProGuard is free software and is distributed under the GNU General Public License, version 2.

ProGuard is distributed as part of the Android SDK and runs when building the application in release mode.

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Last time we checked, the Dexguard mode of operation was:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

Platformlarına obfuskelenmiş bir APK yükleyebilirsiniz.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

It is a **generic android deobfuscator.** Simplify **virtually executes an app** to understand its behavior and then **tries to optimize the code** so it behaves identically but is easier for a human to understand. Each optimization type is simple and generic, so it doesn't matter what the specific type of obfuscation is used.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD gives you information about **how an APK was made**. It identifies many **compilers**, **packers**, **obfuscators**, and other weird stuff. It's [_PEiD_](https://www.aldeid.com/wiki/PEiD) for Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b, ubuntu-mate tabanlı bir Android güvenlik sanal makinesidir ve reverse engineering ile malware analysis için farklı güvenlik meraklıları ve araştırmacıların en son framework, tutorial ve lab koleksiyonlarını içerir.

## Referanslar

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Harika bir kaynak listesi
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)

## Denenecekler

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
