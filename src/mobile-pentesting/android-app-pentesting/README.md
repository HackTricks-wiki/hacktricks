# Android 应用 Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android 应用 基础

强烈建议先阅读此页面，以了解 **与 Android 安全相关的最重要的部分以及 Android 应用中最危险的组件**：


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

这是连接 Android 设备（模拟或物理）所需的主要工具。\
**ADB** 允许从计算机通过 **USB** 或 **Network** 控制设备。该工具支持双向 **copying** 文件、应用的 **installation** 和 **uninstallation**、**execution** shell 命令、数据 **backing up**、日志 **reading** 等功能。

查看以下[**ADB 命令**](adb-commands.md)列表以学习如何使用 adb。

## Smali

有时为了访问**隐藏信息**（例如经过强混淆的密码或 flag），修改应用程序代码是有意义的。此时，可以反编译 APK、修改 Smali 代码并重新编译 APK。 [**在本教程中**你可以**学习如何反编译 APK、修改 Smali 代码并重新编译具有新功能的 APK**](smali-changes.md)。这在作为即将介绍的 **dynamic analysis** 期间的多项测试的替代方法时非常有用。因此，**始终记住这种可能性**。

## Other interesting tricks

- [在 Play Store 中伪造你的位置](spoofing-your-location-in-play-store.md)
- [Play Integrity attestation spoofing (SafetyNet replacement)](play-integrity-attestation-bypass.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [Android IME / InputMethodService 滥用 (Malicious Keyboards)](inputmethodservice-ime-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **下载 APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- 从设备提取 APK:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- 使用 [APKEditor](https://github.com/REAndroid/APKEditor) 合并所有 splits 和 base apks:
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Android Enterprise & Work Profile Attacks

{{#ref}}
android-enterprise-work-profile-bypass.md
{{#endref}}

## 案例研究与漏洞


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

{{#ref}}
abusing-android-media-pipelines-image-parsers.md
{{#endref}}

{{#ref}}
../../binary-exploitation/linux-kernel-exploitation/arm64-static-linear-map-kaslr-bypass.md
{{#endref}}

## 静态分析

首先，分析 APK 时应使用反编译器**查看 Java 代码**。\
请[**在此阅读以了解可用反编译器的相关信息**](apk-decompilers.md)。

### 寻找有趣的信息

仅查看 APK 的 **strings** 就可以搜索 **passwords**、**URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep))、**api** keys、**encryption**、**bluetooth uuids**、**tokens** 以及任何有趣的内容……甚至查找代码执行的 **backdoors** 或认证 backdoors（应用的硬编码管理员凭据）。

**Firebase**

特别注意 **firebase URLs** 并检查其是否配置不当。[关于什么是 Firebase 以及如何利用它的更多信息请见这里。](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### 对应用的基本理解 - Manifest.xml, strings.xml

**检查应用的 _Manifest.xml_ 和 **_strings.xml_** 文件可以揭示潜在的安全漏洞**。这些文件可以通过反编译器访问，或将 APK 的扩展名改为 .zip 然后解压来获取。

从 **Manifest.xml** 中可识别的 **漏洞** 包括：

- **可调试的应用**：在 _Manifest.xml_ 中被设置为 debuggable (`debuggable="true"`) 的应用存在风险，因为它们允许连接并可能导致利用。有关如何在设备上发现并利用可调试应用的更多信息，请参考相关教程。
- **备份设置**：对于处理敏感信息的应用，应显式将 `android:allowBackup="false"` 设置为 false，以防止在 usb debugging 启用时通过 adb 进行未经授权的数据备份。
- **网络安全**：自定义网络安全配置（`android:networkSecurityConfig="@xml/network_security_config"`）位于 _res/xml/_，可指定证书 pin、HTTP 流量设置等安全细节。例如为特定域允许 HTTP 流量。
- **导出 Activities 和 Services**：识别 manifest 中导出的 activities 和 services 可以突出可能被滥用的组件。动态测试期间的进一步分析可以揭示如何利用这些组件。
- **Content Providers 和 FileProviders**：暴露的 content providers 可能允许未经授权的访问或修改数据。FileProviders 的配置也应仔细检查。
- **Broadcast Receivers 与 URL Schemes**：这些组件可能被用于利用，尤其要注意 URL schemes 的处理是否存在输入漏洞。
- **SDK 版本**：`minSdkVersion`、`targetSDKVersion` 和 `maxSdkVersion` 属性表明支持的 Android 版本，强调不要支持过时、存在漏洞的 Android 版本的重要性。

从 **strings.xml** 文件中，可以发现诸如 API keys、自定义 schema 以及其他开发者注释等敏感信息，强调需仔细审查这些资源。

### Tapjacking

**Tapjacking** 是一种攻击，攻击者启动一个 **malicious application** 并**将其置于受害者应用之上**。当它可见地遮挡受害应用时，其用户界面设计成欺骗用户与之交互，同时将交互事件传递给受害应用。\
实际上，它是**使用户看不见自己实际上在对 victim app 执行操作**。

更多信息请参见：


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

一个将 **`launchMode`** 设置为 **`singleTask` 且未定义任何 `taskAffinity`** 的 **activity** 易受 Task Hijacking 的影响。这意味着，如果一个 **malicious application** 被安装并且在真实应用之前被启动，它可能**劫持真实应用的 task**（因此用户会以为自己在使用真实应用，实际上在与恶意应用交互）。

更多信息见：


{{#ref}}
android-task-hijacking.md
{{#endref}}

### 不安全的数据存储

**Internal Storage**

在 Android 中，存储在 **internal** 存储中的文件**设计上只能被创建它们的应用访问**。这一安全措施由 Android 操作系统强制执行，并且通常能满足大多数应用的安全需求。然而，开发者有时会使用像 `MODE_WORLD_READABLE` 和 `MODE_WORLD_WRITABLE` 这样的模式以**允许文件在不同应用之间共享**。但这些模式**不会限制其他应用（包括可能的恶意应用）对这些文件的访问**。

1. 静态分析：
- **注意** 检查是否使用 `MODE_WORLD_READABLE` 和 `MODE_WORLD_WRITABLE`。这些模式**可能会将文件暴露给非预期或未授权的访问**。
2. 动态分析：
- **验证** 应用创建的文件的 **权限**。特别是，**检查** 是否有任何文件被设置为可被 worldwide 读取或写入。这可能构成严重的安全风险，因为它将允许设备上**任何安装的应用**（无论来源或意图）读取或修改这些文件。

**External Storage**

处理位于 **external storage**（如 SD 卡）上的文件时，应采取以下预防措施：

1. 可访问性：
- external storage 上的文件**可被全局读取和写入**。这意味着任何应用或用户都可以访问这些文件。
2. 安全考虑：
- 鉴于易访问性，建议**不要在 external storage 上存储敏感信息**。
- external storage 可以被移除或被任意应用访问，因此安全性较差。
3. 处理来自 External Storage 的数据：
- 始终对从 external storage 检索的数据执行 **输入验证**。这很关键，因为这些数据来自不受信任的来源。
- 不建议将可执行文件或 class 文件存放在 external storage 以便动态加载。
- 如果应用必须从 external storage 检索可执行文件，确保在动态加载前对这些文件进行**签名和加密验证**。这一步对维护应用的安全完整性至关重要。

External storage 的访问路径包括 /storage/emulated/0 、 /sdcard 、 /mnt/sdcard

> [!TIP]
> 从 Android 4.4 (**API 17**) 开始，SD 卡具有一种目录结构，**将应用的访问限制在专门为该应用创建的目录**中。这可以防止恶意应用获得对其他应用文件的读写访问。

**以明文存储的敏感数据**

- **Shared preferences**：Android 允许每个应用轻松地将 xml 文件保存在路径 `/data/data/<packagename>/shared_prefs/`，有时可以在该文件夹中发现以明文存储的敏感信息。
- **Databases**：Android 允许每个应用轻松地将 sqlite 数据库保存在路径 `/data/data/<packagename>/databases/`，有时可以在该文件夹中发现以明文存储的敏感信息。

### Broken TLS

**Accept All Certificates**

出于某些原因，开发者有时会接受所有证书，即使比如 hostname 不匹配，也会使用类似下面的代码行：
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### 加密问题

**不良的密钥管理流程**

有些开发者会将敏感数据保存在本地存储并用代码中硬编码/可预测的密钥进行加密。这样不应该做，因为逆向可能让攻击者提取到这些机密信息。

**使用不安全和/或已弃用的算法**

开发者不应使用**已弃用的算法**来执行授权**检查**、**存储**或**发送**数据。一些此类算法有：RC4、MD4、MD5、SHA1……例如，如果使用**hashes**来存储密码，应使用抗暴力破解的哈希并加盐。

### 其他检查

- 建议对 **APK 进行混淆**，以增加攻击者逆向工程的难度。
- 如果应用比较敏感（比如银行类应用），应**自行检测设备是否已 root**并据此采取措施。
- 如果应用比较敏感（比如银行类应用），应检测是否在**emulator**中运行。
- 如果应用比较敏感（比如银行类应用），应**在执行前检查自身完整性**以判断是否被篡改。
- 使用 [**APKiD**](https://github.com/rednaga/APKiD) 检查用于构建 APK 的 compiler/packer/obfuscator

### React Native 应用

阅读以下页面以了解如何轻松访问 React 应用的 javascript 代码：


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin 应用

阅读以下页面以了解如何轻松访问 xamarin 应用的 C# 代码：


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked 应用

根据这篇 [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/)，superpacked 是 Meta 的一种算法，会把应用的内容压缩到单个文件中。文中讨论了创建一个能解压这类应用的程序的可能性……以及一种更快的方法，涉及到**执行应用并从文件系统收集解压后的文件。**

### 自动化静态代码分析

工具 [**mariana-trench**](https://github.com/facebook/mariana-trench) 能通过**扫描**应用的**代码**来发现**漏洞**。该工具包含一系列**已知的 sources**（指示工具哪里**受用户输入控制**）、**sinks**（指示工具潜在**危险的位置**，恶意用户输入可能造成损害）和**rules**。这些规则指示哪些 **sources-sinks** 的组合表明存在漏洞。

有了这些信息，**mariana-trench 会审查代码并发现其中可能的漏洞**。

### Secrets leaked

应用中可能包含 secrets（API keys、密码、隐藏的 urls、子域名……），你可能能在其中发现这些信息。你可以使用诸如 [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks) 这样的工具。

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### 其他有趣的函数

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [阅读此文以了解**如何逆向 native 函数**](reversing-native-libraries.md)
- 通过 JNI 在内存中执行 native 代码（下载 shellcode → mmap/mprotect → 调用）:

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **其他技巧**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## 动态分析

> 首先，你需要一个能安装应用和所有环境（主要是 Burp CA 证书、Drozer 和 Frida）的环境。因此，强烈建议使用已 root 的设备（可以是模拟器或实体设备）。

### 在线动态分析

你可以在此创建一个**免费账户**: [https://appetize.io/](https://appetize.io)。该平台允许你**上传**并**执行** APK，因此有助于观察 apk 的行为。

你甚至可以在网页中**查看应用的日志**并通过 **adb** 连接。

![](<../../images/image (831).png>)

借助 ADB 连接，你可以在模拟器内使用 **Drozer** 和 **Frida**。

### 本地动态分析

#### 使用模拟器

- [**Android Studio**](https://developer.android.com/studio)（你可以创建 **x86** 和 **arm** 设备，并且根据[**这篇文章**](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html) **较新的 x86** 版本 **支持 ARM 库**，无需使用较慢的 arm 模拟器）。
- 在此页面学习如何设置：


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **（免费版：Personal Edition，需要注册账号。建议下载带有 VirtualBox 的版本以避免潜在错误。）**
- [**Nox**](https://es.bignox.com)（免费，但不支持 Frida 或 Drozer）。

> [!TIP]
> 在任何平台创建新模拟器时，请记住屏幕越大，模拟器运行越慢。如果可能，尽量选择小屏幕。

要在 Genymotion 中**安装 google services**（如 AppStore），需要点击下图中标红的按钮：

![](<../../images/image (277).png>)

另外，请注意在 **Genymotion 的 Android VM 配置** 中可以选择 **Bridge Network mode**（如果你会从另一个 VM 连接到 Android VM 的工具，这会很有用）。

#### 使用物理设备

你需要启用**开发者选项**并且如果能**获取 root 权限**会更好：

1. **Settings**。
2. （从 Android 8.0 起）选择 **System**。
3. 选择 **About phone**。
4. 连续点击 **Build number** 7 次。
5. 返回即可看到 **Developer options**。

> 一旦安装好应用，首先应该运行它并调查它的行为、工作原理并熟悉它。\
> 我建议使用 MobSF dynamic analysis + pidcat 来执行这一步初始动态分析，这样我们可以在 MobSF **捕获**大量**有价值的数据**的同时，通过 pidcat **学习应用的运行机制**，这些数据以后可以复查。

Magisk/Zygisk 速记（在 Pixel 设备上推荐）
- 使用 Magisk app patch boot.img 并通过 fastboot 刷入以获取 systemless root
- 启用 Zygisk + DenyList 用于隐藏 root；在需要更强隐藏时可考虑 LSPosed/Shamiko
- 保留原始 boot.img 以便从 OTA 更新中恢复；每次 OTA 后重新 patch
- 屏幕镜像使用 scrcpy 在主机上进行

### 非预期的数据泄露

**Logging**

开发者应谨慎避免将**调试信息**公开暴露，因为这可能导致敏感数据 leak。建议使用 [**pidcat**](https://github.com/JakeWharton/pidcat) 和 `adb logcat` 监控应用日志，以识别并保护敏感信息。**Pidcat** 因其易用性和可读性而常被推荐。

> [!WARNING]
> 注意，从 **Android 4.0 之后的版本** 起，**应用只能访问自身的日志**，因此应用无法访问其他应用的日志。\
> 无论如何，仍建议**不要记录敏感信息**。

**Copy/Paste 缓存**

Android 的**剪贴板**框架支持应用间复制粘贴，但存在风险，因为**其他应用**可以**访问**剪贴板，可能暴露敏感数据。对于应用中的敏感字段（如信用卡信息），应禁用复制/粘贴 功能以防止数据泄露。

**Crash Logs**

如果应用**崩溃**并**保存日志**，这些日志可能帮助攻击者（尤其当应用无法被逆向时）。为降低风险，应避免在崩溃时记录敏感信息；如果必须通过网络传输日志，确保通过 SSL 通道发送。

作为 pentester，**应查看这些日志**。

**发送给第三方的 Analytics 数据**

应用经常集成例如 Google Adsense 之类的服务，如果实现不当，可能会意外 **leak 敏感数据**。要识别潜在的数据泄露，建议**拦截应用流量**并检查是否有敏感信息发送到第三方服务。

### SQLite DBs

大多数应用会使用**内部 SQLite 数据库**保存信息。渗透测试时应查看创建的**数据库**、表名和列名以及所有保存的数据，因为你可能会发现**敏感信息**（这将构成一个漏洞）。\
数据库应位于 `/data/data/the.package.name/databases`，例如 `/data/data/com.mwr.example.sieve/databases`

如果数据库保存机密信息且**已加密**，但你能在应用中**找到密码**，这仍然是一个**漏洞**。

使用 `.tables` 列出表，使用 `.schema <table_name>` 列出某表的列结构。

### Drozer（利用、Content Providers 和 Services）

根据 [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf)：**Drozer** 允许你**扮演 Android 应用的角色**并与其他应用交互。它能做**已安装应用能做的任何事**，例如利用 Android 的进程间通信（IPC）机制并与底层操作系统交互。\
Drozer 是一个有用的工具，可用于**利用 exported activities、exported services 和 Content Providers**，你将在后续章节学习到这些内容。

### 利用已导出的 Activities

[**如果你想复习什么是 Android Activity，请阅读此处。**](android-applications-basics.md#launcher-activity-and-other-activities)\
还要记住，activity 的代码从 **`onCreate`** 方法开始执行。

**授权绕过**

当 Activity 被导出（exported）时，你可以从外部应用调用其界面。因此，如果带有**敏感信息**的 activity 被**导出**，你可能可以**绕过认证机制**来访问它。

[**了解如何使用 Drozer 利用 exported activities。**](drozer-tutorial/index.html#activities)

你也可以通过 adb 启动一个 exported activity：

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**注意**：MobSF 会将活动中将 _**singleTask/singleInstance**_ 用作 `android:launchMode` 检测为恶意，但根据 [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750)，显然这仅在旧版本（API versions < 21）上危险。

> [!TIP]
> 注意 authorisation bypass 并不总是一个漏洞，这取决于绕过的工作方式以及暴露了哪些信息。

**敏感信息泄露**

**Activities can also return results**。如果你找到一个已导出且未受保护的 activity 调用了 **`setResult`** 方法并**返回敏感信息**，就会发生敏感信息泄露。

#### Tapjacking

如果未防止 tapjacking，你可以滥用被导出的 activity 使 **用户执行意外操作**。更多关于 [**what is Tapjacking follow the link**](#tapjacking) 的信息。

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers 基本上用于**共享数据**。如果一个应用暴露了 content providers，你可能能够从中**提取敏感数据**。还应测试可能的 **SQL injections** 和 **Path Traversals**，因为它们可能存在漏洞。

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
请记住，Service 的动作从方法 `onStartCommand` 开始。

Service 基本上是可以**接收数据**、**处理**并**返回**（或不返回）响应的东西。因此，如果一个应用导出了一些 services，你应当**检查**其**代码**以了解其行为，并**动态测试**以提取机密信息、绕过认证措施等。\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
请记住，Broadcast Receiver 的动作从方法 `onReceive` 开始。

A broadcast receiver 会等待某种类型的消息。根据接收者如何处理该消息，它可能存在漏洞。\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

你可以手动查找 deep links，使用像 MobSF 这样的工具或像 [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py) 这样的脚本。\
你可以使用 **adb** 或 **browser** 打开声明的 **scheme**：
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_请注意，你可以 **省略包名**，手机会自动调用应该打开该链接的应用。_
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**被执行的代码**

为了找到 **code that will be executed in the App**，请定位由深度链接调用的 activity 并搜索函数 **`onNewIntent`**。

![](<../../images/image (436) (1) (1) (1).png>)

**敏感信息**

每次发现深度链接时，检查它是否没有通过 URL 参数接收敏感数据（例如密码），因为任何其他应用都可能伪装成该深度链接并**窃取这些数据！**

**路径参数**

你**必须检查是否有任何深度链接在 URL 的 path 中使用参数**，例如：`https://api.example.com/v1/users/{username}`，在这种情况下你可以通过访问类似 `example://app/users?username=../../unwanted-endpoint%3fparam=value` 的地址来强制进行路径遍历。\
注意，如果你在应用内找到了正确的 endpoints，你可能能够引发 **Open Redirect**（如果 path 的一部分被用作域名）、**account takeover**（如果你能在没有 CSRF token 的情况下修改用户详情并且漏洞 endpoint 使用了正确的方法）或其他任何漏洞。更多信息见 [info about this here](http://dphoeniixx.com/2020/12/13-2/)。

**更多示例**

一个关于 links (_/.well-known/assetlinks.json_) 的 [有趣的 bug bounty 报告](https://hackerone.com/reports/855618)。

### 传输层检查与验证失败

- **证书并不总是被正确检查**：Android 应用常常忽视警告并接受自签名证书，或者在某些情况下回退到使用 HTTP 连接。
- **SSL/TLS 握手期间的协商有时很弱**，使用不安全的 cipher suites。该漏洞使连接容易受到 man-in-the-middle (MITM) 攻击，使攻击者能够解密数据。
- **Leakage of private information** 是一个风险，当应用使用安全通道进行认证但随后在其他事务中通过非安全通道通信时。此类做法无法保护诸如 session cookies 或用户详情等敏感数据，容易被恶意实体拦截。

#### 证书验证

我们将重点关注 **certificate verification**。必须验证服务器证书的完整性以增强安全性。这一点很关键，因为不安全的 TLS 配置以及在未加密通道上传输敏感数据都会带来重大风险。关于验证服务器证书和修复漏洞的详细步骤，[**this resource**](https://manifestsecurity.com/android-application-security-part-10/) 提供了全面指导。

#### SSL Pinning

SSL Pinning 是一种安全措施，应用会将服务器证书与存储在应用内的已知副本进行比对。该方法对于防止 MITM 攻击至关重要。强烈建议在处理敏感信息的应用中实现 SSL Pinning。

#### 流量检查

要检查 HTTP 流量，需要**安装代理工具的证书**（例如 Burp）。如果不安装该证书，通过代理可能看不到加密流量。有关安装自定义 CA 证书的指南，见 [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine)。

针对 **API Level 24 and above** 的应用需要修改 Network Security Config 以接受代理的 CA 证书。这一步对于检查加密流量至关重要。有关修改 Network Security Config 的说明，见 [**refer to this tutorial**](make-apk-accept-ca-certificate.md)。

如果使用 **Flutter**，需要遵循 [**this page**](flutter.md) 中的说明。仅将证书添加到证书存储并不起作用，因为 Flutter 有其自己的有效 CA 列表。

#### SSL/TLS pinning 的静态检测

在尝试运行时绕过之前，先快速绘制出 APK 中强制 pinning 的位置。静态发现可以帮助你规划 hooks/patches 并集中在正确的代码路径上。

工具: SSLPinDetect
- 开源的静态分析工具，它将 APK 反编译为 Smali（通过 apktool）并扫描针对 SSL/TLS pinning 实现的精选正则模式。
- 为每个匹配报告精确的文件路径、行号和代码片段。
- 覆盖常见框架和自定义代码路径：OkHttp CertificatePinner、custom javax.net.ssl.X509TrustManager.checkServerTrusted、SSLContext.init with custom TrustManagers/KeyManagers，以及 Network Security Config XML pins。

安装
- 先决条件: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
用法
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
示例模式规则 (JSON)
使用或扩展 signatures 来检测专有/自定义的 pinning 风格。你可以加载你自己的 JSON 并进行大规模扫描。
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes and tips
- 在大型应用上通过 multi-threading 和 memory-mapped I/O 快速扫描；预编译的 regex 可减少开销/误报。
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- 典型的检测目标，作为下步分流：
- OkHttp: CertificatePinner 使用，setCertificatePinner，okhttp3/okhttp 包引用
- Custom TrustManagers: javax.net.ssl.X509TrustManager，checkServerTrusted 覆盖
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init 与自定义 managers
- 在 res/xml 的 network security config 和 manifest 引用中的声明式 pins
- 使用匹配到的位置来规划 Frida hooks、静态补丁或在动态测试前进行配置审查。



#### 绕过 SSL Pinning

当实现了 SSL Pinning 时，为了检查 HTTPS 流量需要绕过它。可以使用多种方法：

- 自动地使用 [**apk-mitm**](https://github.com/shroudedcode/apk-mitm) **modify** the **apk** 来 **bypass** SSLPinning。此选项的最大优点是无需 root 即可绕过 SSL Pinning，但你需要删除应用并重新安装修改后的应用，而且并非总是有效。
- 你可以使用 **Frida**（下文有讨论）来绕过该保护。这里有一篇使用 Burp+Frida+Genymotion 的指南： [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- 你也可以尝试使用 [**objection**](frida-tutorial/objection-tutorial.md)**:** 自动 **bypass SSL Pinning**：`objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- 你也可以尝试使用 **MobSF dynamic analysis**（下文有解释）自动 **bypass SSL Pinning**
- 如果你仍然认为有未捕获的流量，可以尝试使用 iptables 将流量转发到 burp。阅读这篇博客： [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### 寻找常见的 Web 漏洞

同样重要的是在应用内搜索常见的 web 漏洞。关于识别和缓解这些漏洞的详细信息超出本摘要范围，但在其他地方有详尽覆盖。

### Frida

[Frida](https://www.frida.re) 是一个面向开发者、逆向工程师和安全研究人员的动态插桩工具包。\
**你可以访问正在运行的应用并在运行时 hook 方法以改变行为、修改值、提取值、运行不同的代码...**\
如果你要 pentest Android 应用，就需要知道如何使用 Frida。

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Some "GUI" for actions with Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- You can find some Awesome Frida scripts here: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Try to bypass anti-debugging / anti-frida mechanisms loading Frida as in indicated in [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### 反插桩 & SSL pinning 绕过工作流程

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **导出内存 - Fridump**

检查应用是否在内存中存储了不应存储的敏感信息，例如密码或助记词。

使用 [**Fridump3**](https://github.com/rootbsd/fridump3) 你可以通过以下命令导出应用的内存：
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
这会将内存转储到 ./dump 文件夹，接着你可以在其中使用 grep 进行搜索，例如：
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Keystore 中的敏感数据**

在 Android 中，Keystore 是存储敏感数据的最佳位置，但在拥有足够权限的情况下仍然**可能被访问**。由于应用往往在此处以**明文 (clear text)** 存储敏感数据，pentests 应以 root user 身份检查，因为拥有设备物理访问权限的人可能会窃取这些数据。

即使应用将数据存储在 Keystore 中，数据也应被加密。

要访问 Keystore 中的数据，你可以使用这个 Frida script: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

使用下面的 Frida 脚本，可能可以 **bypass fingerprint authentication**，Android 应用可能会使用该机制来 **保护某些敏感区域：**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **后台快照**

当你把应用置于后台时，Android 会保存应用的一个 **快照（snapshot of the application）**，这样当它恢复到前台时，会先加载该图像，从而看起来应用加载更快。

不过，如果该快照包含 **敏感信息**，有权限访问快照的人可能会 **窃取这些信息**（注意：你需要 root 权限才能访问它）。

快照通常存放在： **`/data/system_ce/0/snapshots`**

Android 提供了一种通过设置 **FLAG_SECURE** 布局参数来 **阻止截图捕获** 的方法。使用该 flag 后，窗口内容将被视为安全，从而防止其出现在截图中或在非安全显示设备上被查看。
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android 应用分析器**

这个工具可以帮助你在动态分析期间管理不同的工具： [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

开发者经常创建代理组件（例如 activities、services 和 broadcast receivers）来处理这些 Intents，并将它们传递给诸如 `startActivity(...)` 或 `sendBroadcast(...)` 之类的方法，这可能很危险。

危险在于允许攻击者通过误导这些 Intents 来触发非导出（non-exported）的应用组件或访问敏感的 content providers。一个典型例子是 `WebView` 组件通过 `Intent.parseUri(...)` 将 URL 转换为 `Intent` 对象并执行它们，这可能导致恶意的 Intent Injection。

### Essential Takeaways

- **Intent Injection** 类似于 web 的 Open Redirect 问题。
- 利用方式通常通过将 `Intent` 对象作为 extras 传递，然后被重定向以执行不安全的操作。
- 它可能使非导出组件（non-exported components）和 content providers 暴露给攻击者。
- `WebView` 将 URL 转换为 `Intent` 的行为可能促成非预期的操作。

### Android Client Side Injections and others

这些漏洞你可能在 Web 上已经见过。在 Android 应用中，需特别注意以下漏洞：

- **SQL Injection:** 在处理动态查询或 Content-Providers 时，确保使用参数化查询。
- **JavaScript Injection (XSS):** 验证任何 WebView 的 JavaScript 和 Plugin 支持被禁用（默认禁用）。 [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews 应禁用对文件系统的访问（默认启用） - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: 在若干情况下，当 android application 结束会话时，cookie 未被撤销或甚至被保存到磁盘
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## 自动化分析

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**静态分析**

![](<../../images/image (866).png>)

**对应用的漏洞评估** 使用一个漂亮的 web 前端。你也可以执行动态分析（但需要准备好环境）。
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Assisted Dynamic analysis with MobSF

**MobSF** can also be very helpful for **dynamic analysis** in **Android**, but in that case you will need to install MobSF and **genymotion** in your host (a VM or Docker won't work). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
The **MobSF dynamic analyser** can:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). All of this is done automatically except for the screenshots, you need to press when you want a screenshot or you need to press "**Exported Activity Tester**" to obtain screenshots of all the exported activities.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: It will print all the loaded classes
- **Capture Strings**: It will print all the capture strings while using the application (super noisy)
- **Capture String Comparisons**: Could be very useful. It will **show the 2 strings being compared** and if the result was True or False.
- **Enumerate Class Methods**: Put the class name (like "java.io.File") and it will print all the methods of the class.
- **Search Class Pattern**: Search classes by pattern
- **Trace Class Methods**: **Trace** a **whole class** (see inputs and outputs of all methods of th class). Remember that by default MobSF traces several interesting Android Api methods.

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf also brings you a shell with some **adb** commands, **MobSF commands**, and common **shell** **commands** at the bottom of the dynamic analysis page. Some interesting commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP 工具**

When http traffic is capture you can see an ugly view of the captured traffic on "**HTTP(S) Traffic**" bottom or a nicer view in "**Start HTTPTools**" green bottom. From the second option, you can **发送** the **捕获的请求** to **proxies** like Burp or Owasp ZAP.\
To do so, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> press "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Once you finish the dynamic analysis with MobSF you can press on "**Start Web API Fuzzer**" to **fuzz http requests** an look for 漏洞。

> [!TIP]
> After performing a dynamic analysis with MobSF the proxy settings me be misconfigured and you won't be able to fix them from the GUI. You can fix the proxy settings by doing:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

You can get the tool from [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
This tool with use some **Hooks** to let you know **what is happening in the application** while you perform a **dynamic analysis**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

This is a **great tool to perform static analysis with a GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

This tool is designed to look for several **security related Android application vulnerabilities**, either in **source code** or **packaged APKs**. The tool is also **capable of creating a "Proof-of-Concept" deployable APK** and **ADB commands**, to exploit some of the found vulnerabilities (Exposed activities, intents, tapjacking...). As with Drozer, there is no need to root the test device.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- 显示所有提取的文件，便于参考
- 自动将 APK 文件反编译为 Java 和 Smali 格式
- 分析 AndroidManifest.xml 以识别常见漏洞和行为
- 对源代码进行静态分析以识别常见漏洞和行为
- 设备信息
- 以及更多
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER 是一个命令行应用，可在 Windows、MacOS X 和 Linux 上使用，用于分析 _.apk_ 文件以查找漏洞。它通过解压 APK 并应用一系列规则来检测这些漏洞。

所有规则集中在 `rules.json` 文件中，每家公司或测试人员都可以创建自己的规则来分析他们需要的内容。

从 [download page](https://superanalyzer.rocks/download.html) 下载最新的二进制文件。
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn 是一个 **crossplatform** 工具，帮助开发者、bugbounty hunters 和 ethical hackers 对移动应用执行 [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis)。

其工作原理是将你的移动应用文件（.apk 或 .ipa 文件）拖放到 StaCoAn 应用上，StaCoAn 会为你生成可视化且便携的报告。你可以调整设置和 wordlists 来获得定制化体验。

下载[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework 是一个 Android vulnerability analysis system，帮助开发者或 hackers 发现 Android 应用中的潜在 security vulnerabilities。\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** 是一个工具，主要目的是检测并警告用户 Android 应用可能表现出的潜在恶意行为。

检测是通过使用 [`androguard`](https://github.com/androguard/androguard) 库，对应用的 Dalvik bytecode（以 **Smali** 表示）进行 **static analysis** 来完成的。

该工具会查找类似以下的 **common behavior of "bad" applications**：Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. 它是一个将常用的移动应用逆向与分析工具整合在一起的框架，用于帮助针对 OWASP mobile security threats 测试移动应用。其目标是让移动应用开发者和安全专业人员更轻松、更友好地完成这项工作。

It is able to:

- 使用不同工具提取 Java 和 Smali 代码
- 分析 APK，使用: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- 使用正则从 APK 中提取敏感信息。
- 分析 Manifest。
- 分析发现的域名，使用: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- 通过 [apk-deguard.com](http://www.apk-deguard.com) 对 APK 进行去混淆

### Koodous

用于检测 malware: [https://koodous.com/](https://koodous.com)

## Obfuscating/Deobfuscating code

注意：根据用于混淆代码的服务和配置不同，secrets 可能会被混淆，也可能不会。

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** 是一个开源的命令行工具，用于缩小、优化并混淆 Java 代码。它能够优化字节码并检测和移除未使用的指令。ProGuard 是自由软件，并在 GNU General Public License 第2版下发布。

ProGuard 随 Android SDK 一起分发，并在以 release 模式构建应用时运行。

### [DexGuard](https://www.guardsquare.com/dexguard)

在 [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html) 可找到针对 apk 的去混淆逐步指南

(摘自该指南) 上次我们检查时，Dexguard 的运行模式为：

- 将资源作为 InputStream 加载；
- 将结果传递给继承自 FilterInputStream 的类以解密它；
- 做一些无用的混淆以浪费逆向工程师几分钟时间；
- 将解密后的结果传递给 ZipInputStream 以获取 DEX 文件；
- 最后使用 `loadDex` 方法将生成的 DEX 作为 Resource 加载。

### [DeGuard](http://apk-deguard.com)

**DeGuard 逆转 Android 混淆工具所执行的混淆过程。这使得许多安全分析成为可能，包括代码审查和库识别。**

你可以将混淆的 APK 上传到他们的平台。

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

It is a **generic android deobfuscator.** Simplify **virtually executes an app** to understand its behavior and then **tries to optimize the code** so it behaves identically but is easier for a human to understand. Each optimization type is simple and generic, so it doesn't matter what the specific type of obfuscation is used.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD gives you information about **how an APK was made**. It identifies many **compilers**, **packers**, **obfuscators**, and other weird stuff. It's [_PEiD_](https://www.aldeid.com/wiki/PEiD) for Android.

### Manual

[阅读本教程以了解一些关于 **如何逆向自定义混淆** 的技巧](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b 是一个基于 ubuntu-mate 的 Android 安全虚拟机，包含来自各类安全研究者的最新框架、教程和用于逆向工程与 malware 分析的实验。

## References

- [Play Integrity API: How It Works & How to Bypass It](https://m4kr0.vercel.app/posts/play-integrity-api-how-it-works--how-to-bypass-it/)
- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) 这是一个很棒的资源列表
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android 快速课程
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
