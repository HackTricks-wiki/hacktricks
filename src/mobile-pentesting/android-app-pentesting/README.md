# Android Uygulamaları Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android Uygulamaları Temelleri

Bu sayfayı okumaya başlamanız şiddetle tavsiye edilir; **Android güvenliği ile ilgili en önemli parçalar ve bir Android uygulamasındaki en tehlikeli bileşenler** hakkında bilgi edinmek için:

{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Bu, bir Android cihaza (emüle edilmiş veya fiziksel) bağlanmak için ihtiyaç duyduğunuz ana araçtır.\
**ADB**, bir bilgisayardan **USB** veya **Network** üzerinden cihazları kontrol etmeyi sağlar. Bu araç, dosyaların her iki yönde **kopyalanması**, uygulamaların **yüklenmesi** ve **kaldırılması**, shell komutlarının **çalıştırılması**, verilerin **yedeklenmesi**, logların **okunması** gibi işlevleri mümkün kılar.

Take a look to the following list of [**ADB Commands**](adb-commands.md) to learn how to use adb.

## Smali

Bazen **uygulama kodunu değiştirmek**, gizli bilgilere (ör. iyi obfuskelenmiş parolalar veya flags) erişmek için ilginç olabilir. Bu durumda apk'yı decompile edip, kodu değiştirip yeniden derlemek ilginç olabilir.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Bu, yapılacak dinamik analiz sırasında sunulacak çeşitli testler için bir **alternatif** olarak çok faydalı olabilir. Bu olasılığı **her zaman aklınızda bulundurun**.

## Diğer ilginç hileler

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **APK'leri İndirin**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Cihazdan APK çıkar:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Tüm splits ve base apks'i [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Vaka İncelemeleri & Zayıflıklar


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Statik Analiz

Öncelikle, bir APK'yı analiz ederken bir decompiler kullanarak **Java koduna göz atmalısınız**.\
Lütfen, [**farklı kullanılabilir decompiler'lar hakkında bilgi almak için burayı okuyun**](apk-decompilers.md).

### İlginç Bilgiler Arama

APK'nın **strings**'lerine bakarak **şifreler**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** anahtarları, **şifreleme**, **bluetooth uuids**, **tokens** ve ilginç olabilecek her şeyi arayabilirsiniz... ayrıca kod çalıştırma **backdoors** veya kimlik doğrulama backdoors (uygulamaya hardcoded admin credentials) arayın.

Firebase

Özellikle **firebase URLs**'lerine dikkat edin ve kötü yapılandırılmış olup olmadığını kontrol edin. [Firebase nedir ve nasıl exploit edileceği hakkında daha fazla bilgi için buraya bakın.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Uygulamayı Temel Düzeyde Anlama - Manifest.xml, strings.xml

Bir uygulamanın _Manifest.xml_ ve **_strings.xml_** dosyalarının incelenmesi potansiyel güvenlik zafiyetlerini ortaya çıkarabilir. Bu dosyalara decompiler ile veya APK uzantısını .zip yapıp açarak erişilebilir.

Manifest.xml'den tespit edilebilecek **zayıflıklar** şunlardır:

- **Debuggable Applications**: _Manifest.xml_ dosyasında debuggable (`debuggable="true"`) olarak ayarlanmış uygulamalar risk taşır; bu ayar bağlantılara izin vererek exploitation'a yol açabilir. Debuggable uygulamaların cihazda nasıl bulunup exploit edileceğini öğrenmek için ilgili eğitimlere bakın.
- **Backup Settings**: Hassas bilgiyle uğraşan uygulamalar için `android:allowBackup="false"` özniteliğinin açıkça ayarlanması gerekir; aksi halde adb ile yetkisiz veri yedeklemelerine izin verilebilir, özellikle usb debugging etkinse.
- **Network Security**: _res/xml/_ içindeki özel network security konfigürasyonları (`android:networkSecurityConfig="@xml/network_security_config"`) sertifika pinleme ve HTTP trafiği ayarları gibi güvenlik detaylarını belirtebilir. Örneğin belirli domain'ler için HTTP trafiğine izin verme.
- **Exported Activities and Services**: Manifest'te exported aktiviteler ve servislerin tespiti, kötüye kullanılabilecek bileşenleri vurgulayabilir. Dinamik testler sırasında bu bileşenlerin nasıl exploit edilebileceği daha iyi anlaşılır.
- **Content Providers and FileProviders**: Açıkta bırakılmış content provider'lar yetkisiz erişim veya veri değişikliğine izin verebilir. FileProviders yapılandırması da dikkatle incelenmelidir.
- **Broadcast Receivers and URL Schemes**: Bu bileşenler exploitation için kullanılabilir; özellikle URL şemalarının girdilerini nasıl yönettiğine dikkat edilmelidir.
- **SDK Versions**: `minSdkVersion`, `targetSDKVersion` ve `maxSdkVersion` öznitelikleri desteklenen Android sürümlerini gösterir; eski ve zayıf Android sürümlerine destek vermemek güvenlik açısından önemlidir.

**strings.xml** dosyasından API keys, özel schema'lar ve diğer geliştirici notları gibi hassas bilgiler bulunabilir; bu kaynakların dikkatle incelenmesi gerektiğini vurgular.

### Tapjacking

Tapjacking, kötü amaçlı bir **application**'ın başlatılıp **kurban uygulamanın üzerine konumlanmasıyla** gerçekleşen bir saldırıdır. Kurban uygulamayı görünür şekilde örttüğünde, kötü amaçlı uygulamanın UI'sı kullanıcıyı etkileşimde bulunmaya kandıracak şekilde tasarlanır; aynı zamanda bu etkileşimi kurban uygulamaya iletir.\
Sonuç olarak, kullanıcı aslında kurban uygulamada işlem yapıyor olduğunu bilmeden **körlenir**.

Daha fazla bilgi için bakın:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

`launchMode` değeri **`singleTask`** olarak ayarlanmış ve herhangi bir **`taskAffinity`** tanımlanmamış bir **activity**, task Hijacking'e karşı açıktır. Bu, kötü amaçlı bir **application** yüklenip gerçek uygulamadan önce çalıştırılırsa **gerçek uygulamanın task'ını ele geçirebileceği** anlamına gelir (kullanıcı gerçek uygulamayı kullanıyormuş sanarak **kötü amaçlı uygulamayla etkileşimde bulunur**).

Detaylar için:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Güvensiz veri depolama

Internal Storage

Android'de dahili depolamada saklanan dosyalar, onları oluşturan uygulama tarafından erişilebilir olacak şekilde tasarlanmıştır. Bu güvenlik mekanizması Android işletim sistemi tarafından uygulanır ve çoğu uygulama için yeterlidir. Ancak geliştiriciler bazen `MODE_WORLD_READABLE` ve `MODE_WORLD_WRITABLE` gibi modları kullanarak dosyaların farklı uygulamalar arasında paylaşılmasına izin verirler. Bu modlar dosyalara diğer uygulamalar, potansiyel olarak kötü amaçlı olanlar dahil, erişimini kısıtlamaz.

1. Statik Analiz:
- `MODE_WORLD_READABLE` ve `MODE_WORLD_WRITABLE` kullanımının dikkatle incelenmesini **sağlayın**. Bu modlar dosyaların **istemeden ya da yetkisiz biçimde** erişilebilir hale gelmesine yol açabilir.
2. Dinamik Analiz:
- Uygulama tarafından oluşturulan dosyalara verilen izinleri **doğrulayın**. Özellikle, herhangi bir dosyanın **genel okunabilir veya yazılabilir** olarak ayarlanıp ayarlanmadığını **kontrol edin**. Bu ciddi bir güvenlik riski oluşturur; cihazdaki herhangi bir uygulama, kaynağı veya amacı ne olursa olsun, bu dosyaları okuyup değiştirebilir.

External Storage

SD Kart gibi **external storage** üzerindeki dosyalarla uğraşırken alınması gereken önlemler:

1. Erişilebilirlik:
- Harici depolamadaki dosyalar **global olarak okunabilir ve yazılabilir**. Yani her uygulama veya kullanıcı bu dosyalara erişebilir.
2. Güvenlik Endişeleri:
- Bu nedenle hassas bilgileri harici depolamada saklamamak önerilir.
- Harici depolama çıkarılabilir veya herhangi bir uygulama tarafından erişilebilir, bu yüzden daha az güvenlidir.
3. Harici Depolamadan Gelen Veriyi İşleme:
- Harici depolamadan alınan verilerde her zaman **girdi doğrulaması** yapın. Çünkü veri güvenilmeyen bir kaynaktan gelmektedir.
- Harici depolamada dinamik yükleme için yürütülebilir veya class dosyaları saklamak şiddetle tavsiye edilmez.
- Eğer uygulamanız harici depolamadan yürütülebilir dosyalar almak zorundaysa, bu dosyaların **imzalanmış ve kriptografik olarak doğrulanmış** olmasını sağlayın; dinamik olarak yüklemeden önce bu adım güvenlik bütünlüğü için kritiktir.

External storage şu dizinlerden erişilebilir: /storage/emulated/0 , /sdcard , /mnt/sdcard

> [!TIP]
> Android 4.4 (**API 17**) ile başlayarak, SD kartın bir dizin yapısı vardır ve bu yapı **bir uygulamanın yalnızca o uygulamaya özel dizine erişimini sınırlar**. Bu, kötü amaçlı uygulamaların başka bir uygulamanın dosyalarına okuma veya yazma erişimi kazanmasını engeller.

Açık metin olarak depolanan hassas veriler

- **Shared preferences**: Android her uygulamanın kolayca xml dosyaları kaydetmesine izin verir; yol `/data/data/<packagename>/shared_prefs/` olup bazen bu klasörde açık metin halinde hassas bilgiler bulunabilir.
- **Databases**: Android her uygulamanın sqlite veritabanlarını kaydetmesine izin verir; yol `/data/data/<packagename>/databases/` olup bazen bu klasörde açık metin halinde hassas bilgiler bulunabilir.

### Bozuk TLS

Accept All Certificates

Bazı nedenlerle geliştiriciler bazen tüm sertifikaları kabul ederler; örneğin hostname eşleşmesi olmasa bile aşağıdaki gibi kod satırlarıyla:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Broken Cryptography

**Poor Key Management Processes**

Bazı geliştiriciler hassas verileri local storage içinde saklayıp, kod içinde hardcoded/öngörülebilir bir anahtar ile encrypt ederler. Bu yapılmamalıdır çünkü bazı reversing işlemleri saldırganların gizli bilgiyi çıkarmasına izin verebilir.

**Use of Insecure and/or Deprecated Algorithms**

Geliştiriciler yetkilendirme **checks**, veri **store** veya **send** etmek için **kullanımdan kaldırılmış algoritmaları** kullanmamalıdır. Bu algoritmalardan bazıları: RC4, MD4, MD5, SHA1... Eğer örneğin şifreleri saklamak için **hashes** kullanılıyorsa, salt ile birlikte brute-force'a **karşı dirençli** hashler kullanılmalıdır.

### Other checks

- APK'yi **obfuscate** ederek tersine mühendislik işini saldırganlar için zorlaştırmak önerilir.
- Uygulama hassassa (ör. bankacılık uygulamaları), cihazın **rooted** olup olmadığını **kendi kontrollerini** yapmalı ve buna göre davranmalıdır.
- Uygulama hassassa (ör. bankacılık uygulamaları), bir **emulator** kullanılıp kullanılmadığını kontrol etmelidir.
- Uygulama hassassa (ör. bankacılık uygulamaları), **çalıştırmadan önce bütünlüğünü kontrol ederek** değiştirilip değiştirilmediğini doğrulamalıdır.
- APK'nin hangi compiler/packer/obfuscator ile derlendiğini kontrol etmek için [**APKiD**](https://github.com/rednaga/APKiD) kullanın

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

Araç [**mariana-trench**](https://github.com/facebook/mariana-trench), uygulamanın **code**unu **scan** ederek **vulnerabilities** bulabilir. Bu araç, **bilinen kaynaklar**ı (kullanıcının **kontrol ettiği** **girdi**lerin bulunduğu **yerleri** araca bildirir), **sinks** (kötü niyetli kullanıcı girdisinin zarar verebileceği **tehlikeli** **yerleri** araca bildirir) ve **kurallar** içerir. Bu kurallar, bir vulnerability'yi gösterecek **sources-sinks** kombinasyonlarını belirtir.

Bu bilgiyle, **mariana-trench kodu inceleyip üzerinde olası vulnerability'leri bulacaktır**.

### Secrets leaked

An application may contain secrets (API keys, passwords, hidden urls, subdomains...) inside of it that you might be able to discover. You could us a tool such as [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> First of all, you need an environment where you can install the application and all the environment (Burp CA cert, Drozer and Frida mainly). Therefore, a rooted device (emulated or not) is extremely recommended.

### Online Dynamic analysis

Bir **ücretsiz hesap** oluşturabilirsiniz: [https://appetize.io/](https://appetize.io). Bu platform APK yüklemeye ve **çalıştırmaya** izin vererek bir APK'nın nasıl davrandığını görmek için faydalıdır.

Web üzerinden uygulamanızın loglarını **görebilir** ve **adb** üzerinden bağlanabilirsiniz.

![](<../../images/image (831).png>)

ADB bağlantısı sayesinde emülatörlerde **Drozer** ve **Frida** kullanabilirsiniz.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (x86 ve arm cihazlar oluşturabilirsiniz; ayrıca [**bu** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**en son x86** versiyonları **ARM kütüphanelerini** yavaş bir arm emülatöre ihtiyaç duymadan desteklemektedir).
- Kurulumunu bu sayfada öğrenin:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Ücretsiz sürüm:** Personal Edition, hesap oluşturmanız gerekir. _Hataları önlemek için **VirtualBox** İLE birlikte olan sürümü **İNDİRMENİZ** önerilir._)
- [**Nox**](https://es.bignox.com) (Ücretsiz, ancak Frida veya Drozer'ı desteklemiyor).

> [!TIP]
> Herhangi bir platformda yeni bir emülatör oluştururken ekran ne kadar büyükse emülatörün o kadar yavaş çalışacağını unutmayın. Mümkünse küçük ekranlar seçin.

Genymotion'da google servislerini (ör. AppStore) **install** etmek için aşağıdaki görüntüde kırmızı ile işaretlenmiş butona tıklamanız gerekir:

![](<../../images/image (277).png>)

Ayrıca, **Genymotion içindeki Android VM yapılandırmasında** **Bridge Network mode** seçeneğini seçebileceğinizi unutmayın (bu, Android VM'ine farklı bir VM'den araçlarla bağlanacaksanız faydalı olacaktır).

#### Use a physical device

Debug seçeneklerini aktifleştirmeniz gerekiyor ve mümkünse cihazı **root** yapmanız iyi olur:

1. **Settings**.
2. (Android 8.0 ve sonrası) **System** seçin.
3. **About phone** seçin.
4. **Build number** üzerine 7 kez basın.
5. Geri dönün ve **Developer options**'ı bulacaksınız.

> Uygulamayı yükledikten sonra, yapmanız gereken ilk şey onu çalıştırıp ne yaptığını, nasıl çalıştığını incelemek ve uygulamaya alışmaktır.\
> Bu ilk dinamik analiz için MobSF dynamic analysis + pidcat kullanmanızı öneririm; böylece uygulamanın nasıl çalıştığını öğrenirken MobSF birçok ilginç veriyi yakalar ve sonradan inceleyebilirsiniz.

Magisk/Zygisk kısa notlar (Pixel cihazlarda önerilir)
- Magisk uygulaması ile boot.img'yi patchleyip fastboot ile flashlayarak systemless root elde edin
- Zygisk + DenyList'i etkinleştirin; root gizleme için daha güçlü bir gizleme gerektiğinde LSPosed/Shamiko'yu düşünün
- OTA güncellemelerinden kurtulmak için orijinal boot.img'yi saklayın; her OTA sonrası tekrar patchleyin
- Ekran yansıtma için host üzerinde scrcpy kullanın

### Unintended Data Leakage

**Logging**

Geliştiriciler, **debugging bilgilerini** kamuya açmak konusunda dikkatli olmalıdır, çünkü bu hassas veri leak'lerine yol açabilir. Uygulama loglarını izleyerek hassas bilgileri tespit etmek için [**pidcat**](https://github.com/JakeWharton/pidcat) ve `adb logcat` araçları önerilir. **Pidcat** kullanım kolaylığı ve okunabilirliği nedeniyle tercih edilir.

> [!WARNING]
> Android 4.0'dan **daha yeni sürümlerde**, **uygulamalar yalnızca kendi loglarına erişebilir**. Yani uygulamalar diğer uygulamaların loglarına erişemez.\
> Yine de, hassas bilgileri **loglamamak** önerilir.

**Copy/Paste Buffer Caching**

Android'in **clipboard-based** framework'ü uygulamalarda kopyala-yapıştır işlevselliğini sağlar, ancak **diğer uygulamalar** panoya erişebildiği için hassas verileri ifşa etme riski taşır. Kredi kartı bilgileri gibi hassas bölümler için kopyala/yapıştır fonksiyonlarını **devre dışı bırakmak** önemlidir.

**Crash Logs**

Bir uygulama **çöküp** log kaydediyorsa, bu loglar özellikle uygulama tersine mühendislik yapılamıyorsa saldırganlar için yardımcı olabilir. Bu riski azaltmak için, çökme durumunda log kaydetmekten kaçının ve loglar ağ üzerinden gönderilecekse SSL kanalı ile iletildiğinden emin olun.

As pentester, **try to take a look to these logs**.

**Analytics Data Sent To 3rd Parties**

Uygulamalar sıklıkla Google Adsense gibi hizmetleri entegre eder; geliştiricinin yanlış uygulaması nedeniyle hassas veriler istemeden üçüncü taraflara **sızdırılabilir**. Potansiyel veri sızıntılarını tespit etmek için uygulamanın trafiğini intercept edip üçüncü taraf hizmetlere herhangi bir hassas bilgi gönderilip gönderilmediğini kontrol etmek önerilir.

### SQLite DBs

Çoğu uygulama bilgileri kaydetmek için **internal SQLite databases** kullanır. Pentest sırasında oluşturulan **databaseleri**, **tabloların** ve **sütunların** isimlerini ve kaydedilen tüm **verileri** inceleyin; çünkü burada **hassas bilgiler** (vulnerability) bulunabilir.\
Databaseler genelde `/data/data/the.package.name/databases` içinde yer alır, örn `/data/data/com.mwr.example.sieve/databases`

Eğer veritabanı gizli bilgileri şifreliyorsa ve şifre uygulama içinde bulunuyorsa bu yine bir **vulnerability**'dir.

Tabloları `.tables` ile sırala ve tabloların sütunlarını `.schema <table_name>` ile listele.

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer**, bir Android uygulamasının rolünü üstlenmenize ve diğer uygulamalarla etkileşime girmenize izin verir. Yüklü bir uygulamanın yapabileceği **her şeyi** yapabilir; Android’in Inter-Process Communication (IPC) mekanizmasını kullanmak ve alt işletim sistemi ile etkileşim kurmak gibi. .\
Drozer, export edilmiş activities, exported services ve Content Providers'ı **exploit etmek** için faydalı bir araçtır; bunu sonraki bölümlerde öğreneceksiniz.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Ayrıca bir activity kodunun **`onCreate`** metodunda başladığını unutmayın.

**Authorisation bypass**

Bir Activity export edilmişse, dış bir uygulamadan ekranı çağırabilirsiniz. Bu nedenle, içinde **hassas bilgi** bulunan bir activity **exported** ise, **authentication** mekanizmalarını **bypass** ederek ona erişebilirsiniz.

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

Ayrıca adb'den export edilmiş bir activity başlatabilirsiniz:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF bir aktivitede `android:launchMode` olarak _**singleTask/singleInstance**_ kullanımını kötü amaçlı olarak tespit edecektir, ancak due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), görünüşe göre bu yalnızca eski sürümlerde (API sürümleri < 21) tehlikelidir.

> [!TIP]
> Note that an authorisation bypass is not always a vulnerability, it would depend on how the bypass works and which information is exposed.

**Hassas bilgi sızıntısı**

**Activity'ler ayrıca sonuç döndürebilir**. Eğer dışa açılmış (exported) ve korunmasız bir activity bulup **`setResult`** metodunu çağırdığını ve **hassas bilgi döndürdüğünü** tespit ederseniz, hassas bilgi sızıntısı vardır.

#### Tapjacking

Eğer tapjacking önlenmemişse, exported activity'yi kötüye kullanarak **kullanıcının beklenmeyen işlemler yapmasını** sağlayabilirsiniz. Daha fazla bilgi için [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers temel olarak **veri paylaşmak** için kullanılır. Eğer bir uygulamanın erişilebilir content provider'ları varsa, bunlardan **hassas** verileri çıkartabiliyor olabilirsiniz. Olası **SQL injections** ve **Path Traversals**'ı da test etmek ilginçtir çünkü bunlar zafiyetli olabilir.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Unutmayın ki bir Service'in işlemleri `onStartCommand` metodunda başlar.

Service temelde **veri alabilen**, **işleyebilen** ve (veya) bir cevap **döndürebilen** bir bileşendir. Bu yüzden, bir uygulama bazı servisleri export ediyorsa ne yaptığını anlamak için **kodu** incelemeli ve gizli bilgileri çıkarmak, authentication önlemlerini bypass etmek gibi amaçlarla **dinamik** olarak test etmelisiniz.\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Unutmayın ki bir Broadcast Receiver'ın işlemleri `onReceive` metodunda başlar.

Bir broadcast receiver belirli bir tür mesajı bekler. Alıcının mesajı nasıl işlediğine bağlı olarak zafiyetli olabilir.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Deep link'leri elle, MobSF gibi araçları veya [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py) gibi script'leri kullanarak arayabilirsiniz.\
Declare edilmiş bir **scheme**'i **adb** veya bir **browser** kullanarak açabilirsiniz:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Unutmayın: **paket adını atlayabilirsiniz** ve mobil cihaz bu bağlantıyı açması gereken uygulamayı otomatik olarak çağıracaktır._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Çalıştırılan kod**

Uygulamada **çalıştırılacak kodu** bulmak için deeplink tarafından çağrılan activity'e gidin ve **`onNewIntent`** fonksiyonunu arayın.

![](<../../images/image (436) (1) (1) (1).png>)

**Hassas bilgi**

Her deep link bulduğunuzda, i**URL parametreleriyle hassas veri (like passwords) almıyor** olduğundan emin olun, çünkü başka herhangi bir uygulama **deep link'i taklit edip bu verileri çalabilir!**

**Path içindeki parametreler**

You **must check also if any deep link is using a parameter inside the path** of the URL like: `https://api.example.com/v1/users/{username}` , in that case you can force a path traversal accessing something like: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Uygulama içinde doğru endpoint'leri bulursanız, bir **Open Redirect** (eğer path'in bir kısmı domain adı olarak kullanılıyorsa), **account takeover** (kullanıcı detaylarını CSRF token olmadan değiştirebiliyorsanız ve the vuln endpoint doğru method'u kullandıysa) ve diğer zafiyetlere yol açabilirsiniz. Daha fazla bilgi için [bu kaynağa bakın](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Taşıma Katmanı İnceleme ve Doğrulama Hataları

- **Certificates are not always inspected properly** by Android applications. It's common for these applications to overlook warnings and accept self-signed certificates or, in some instances, revert to using HTTP connections.
- **Negotiations during the SSL/TLS handshake are sometimes weak**, employing insecure cipher suites. This vulnerability makes the connection susceptible to man-in-the-middle (MITM) attacks, allowing attackers to decrypt the data.
- **Leakage of private information** is a risk when applications authenticate using secure channels but then communicate over non-secure channels for other transactions. This approach fails to protect sensitive data, such as session cookies or user details, from interception by malicious entities.

#### Sertifika Doğrulama

Sertifika doğrulama üzerine odaklanacağız. Sunucunun sertifikasının bütünlüğü güvenliği artırmak için doğrulanmalıdır. Güvensiz TLS konfigürasyonları ve hassas verilerin şifrelenmemiş kanallarda iletilmesi ciddi riskler oluşturabilir. Sunucu sertifikalarını doğrulama ve zafiyetleri ele alma konusunda ayrıntılı adımlar için [**bu kaynak**](https://manifestsecurity.com/android-application-security-part-10/) kapsamlı rehberlik sağlar.

#### SSL Pinning

SSL Pinning, uygulamanın sunucunun sertifikasını uygulama içinde saklanan bilinen bir kopyayla doğruladığı bir güvenlik önlemidir. Bu yöntem MITM saldırılarını önlemek için kritiktir. Hassas bilgi işleyen uygulamalar için SSL Pinning uygulanması şiddetle tavsiye edilir.

#### Trafik İncelemesi

HTTP trafiğini incelemek için proxy aracının sertifikasını (ör. Burp) **yüklemeniz gereklidir**. Bu sertifika yüklü değilse, şifrelenmiş trafik proxy üzerinden görünmeyebilir. Özel bir CA sertifikasının nasıl yükleneceğine dair rehber için [**tıklayın**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

API Level 24 ve üzerini hedefleyen uygulamalar, proxy'nin CA sertifikasını kabul etmek için Network Security Config üzerinde değişiklik yapılmasını gerektirir. Bu adım, şifrelenmiş trafiği incelemek için kritiktir. Network Security Config'i değiştirme talimatları için [**bu eğitime bakın**](make-apk-accept-ca-certificate.md).

Eğer **Flutter** kullanılıyorsa, [**bu sayfa**](flutter.md) üzerindeki talimatları izlemelisiniz. Çünkü sertifikayı store'a eklemek tek başına işe yaramaz; Flutter'ın kendi geçerli CA listesi vardır.

#### SSL/TLS pinning'in statik tespiti

Runtime bypasses denemeden önce, pinning'in APK içinde nerede uygulandığını hızlıca haritalayın. Statik keşif, hooks/patches planlamanıza ve doğru kod yollarına odaklanmanıza yardımcı olur.

Tool: SSLPinDetect
- Açık kaynaklı bir statik-analiz aracı olup APK'yı Smali'ye (apktool aracılığıyla) decompile eder ve SSL/TLS pinning implementasyonlarına ait seçilmiş regex pattern'lerini tarar.
- Her eşleşme için tam dosya yolu, satır numarası ve bir kod snippet'i raporlar.
- OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers ve Network Security Config XML pin'leri gibi yaygın framework'leri ve custom kod yollarını kapsar.

Kurulum
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Kullanım
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Örnek pattern kuralları (JSON)
Özelleştirilmiş pinning stillerini tespit etmek için signatures kullanın veya bunları genişletin. Kendi JSON'unuzu yükleyerek ölçekli scan yapabilirsiniz.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notlar ve ipuçları
- Büyük uygulamalarda çoklu iş parçacığı ve memory-mapped I/O ile hızlı tarama; önceden derlenmiş regex, yükü/yanlış pozitifleri azaltır.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Bir sonraki önceliklendirme için tipik tespit hedefleri:
- OkHttp: CertificatePinner kullanımı, setCertificatePinner, okhttp3/okhttp paket referansları
- Özel TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted override'ları
- Özel SSL context'leri: SSLContext.getInstance + SSLContext.init ile özel manager'lar
- Declarative pins in res/xml network security config ve manifest referansları
- Eşleşen konumları Frida hook'ları, statik yamalar veya config incelemelerini dinamik testlerden önce planlamak için kullanın.



#### Bypassing SSL Pinning

SSL Pinning uygulandığında, HTTPS trafiğini incelemek için bunu atlamak gerekir. Bu amaç için çeşitli yöntemler mevcuttur:

- Automatically **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). The best pro of this option, is that you won't need root to bypass the SSL Pinning, but you will need to delete the application and reinstall the new one, and this won't always work.
- Bu korumayı atlamak için **Frida** (aşağıda tartışılmıştır) kullanabilirsiniz. Burp+Frida+Genymotion kullanımı için bir rehber: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Aşağıdaki komut ile [**objection**](frida-tutorial/objection-tutorial.md) kullanarak SSL Pinning'i **otomatik olarak atlamayı** de deneyebilirsiniz: `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Ayrıca **MobSF dynamic analysis** kullanarak SSL Pinning'i **otomatik olarak atlamayı** deneyebilirsiniz (aşağıda açıklanmıştır)
- Hâlâ yakalayamadığınız trafik olduğunu düşünüyorsanız trafiği iptables kullanarak burp'a iletmeyi deneyebilirsiniz. Bu blogu okuyun: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Looking for Common Web Vulnerabilities

Uygulama içinde yaygın web zayıflıklarını aramak da önemlidir. Bu zayıflıkların belirlenmesi ve hafifletilmesine dair ayrıntılı bilgiler bu özetin kapsamı dışında olup başka kaynaklarda genişçe ele alınmıştır.

### Frida

[Frida](https://www.frida.re) geliştiriciler, reverse-engineer'lar ve güvenlik araştırmacıları için dinamik bir instrumentation toolkit'idir.\
**Çalışan uygulamaya erişip runtime'da metotları hook'layarak davranışı değiştirebilir, değerleri değiştirebilir, değerleri çıkarabilir, farklı kod çalıştırabilirsiniz...**\
Android uygulamalarını pentest etmek istiyorsanız Frida'yı nasıl kullanacağınızı bilmelisiniz.

- Frida kullanmayı öğrenin: [**Frida tutorial**](frida-tutorial/index.html)
- Frida ile işlemler için bazı "GUI"ler: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection Frida kullanımını otomatikleştirmek için harikadır: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Bazı Awesome Frida script'lerini burada bulabilirsiniz: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Frida'yı, [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) adresinde belirtildiği gibi yükleyerek anti-debugging / anti-frida mekanizmalarını atlatmayı deneyin (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

Uygulamanın parolalar veya mnemonic'ler gibi saklamaması gereken hassas bilgileri bellek içinde saklayıp saklamadığını kontrol edin.

Using [**Fridump3**](https://github.com/rootbsd/fridump3) you can dump the memory of the app with:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Bu, belleği ./dump folder'a dump edecek ve orada şu gibi bir şeyle grep yapabilirsiniz:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Keystore'daki hassas veriler**

Android'de Keystore hassas verileri depolamak için en iyi yerdir; ancak yeterli ayrıcalığa sahip olunursa yine de **ona erişmek mümkündür**. Uygulamalar burada genellikle **hassas verileri açık metin olarak** depolama eğiliminde olduğundan, pentests bunu root user veya cihaza fiziksel erişimi olan birinin bu verileri çalabilme ihtimaline karşı kontrol etmelidir.

Bir uygulama verileri Keystore'da saklasa bile, veriler şifrelenmiş olmalıdır.

Keystore içindeki verilere erişmek için bu Frida script'ini kullanabilirsiniz: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Aşağıdaki Frida script'ini kullanarak, Android uygulamalarının **belirli hassas alanları korumak** amacıyla gerçekleştirebilecekleri **parmak izi doğrulamasını atlatmak** mümkün olabilir:
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Background Images**

Bir uygulamayı arka plana aldığınızda, Android uygulamanın bir **uygulamanın anlık görüntüsünü** saklar; böylece uygulama ön plana geri getirildiğinde, uygulama başlamadan önce bu görüntüyü yükleyerek uygulamanın daha hızlı açılmış gibi görünmesini sağlar.

Ancak bu **anlık görüntü** hassas bilgi içeriyorsa, anlık görüntüye erişimi olan biri bu bilgiyi **çalabilir** (erişim için root gerektiğini unutmayın).

Anlık görüntüler genellikle şu konumda saklanır: **`/data/system_ce/0/snapshots`**

Android, layout parametresi olarak **FLAG_SECURE ayarlanarak ekran görüntüsü alınmasını engelleme** imkanı sağlar. Bu flag kullanıldığında, pencere içeriği güvenli olarak işaretlenir; böylece ekran görüntülerinde görünmesi veya güvenli olmayan ekranlarda görüntülenmesi engellenir.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

This tool could help you managing different tools during the dynamic analysis: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Geliştiriciler genellikle activities, services ve broadcast receivers gibi proxy bileşenler oluşturur; bu bileşenler bu Intents'i işleyip `startActivity(...)` veya `sendBroadcast(...)` gibi metodlara iletebilir ve bu durum riskli olabilir.

Tehlike, saldırganların bu Intent'leri yanlış yönlendirerek export edilmeyen uygulama bileşenlerini tetiklemesine veya hassas content providers'a erişmesine izin verilmesinde yatıyor. Önemli bir örnek, `WebView` bileşeninin URL'leri `Intent.parseUri(...)` ile `Intent` objelerine çevirip sonra bunları çalıştırmasıdır; bu durum kötü amaçlı Intent injection'larına yol açabilir.

### Temel Çıkarımlar

- **Intent Injection** web'deki Open Redirect sorununa benzer.
- Sömürüler, `Intent` nesnelerinin extras olarak geçirilmesini ve bunların tehlikeli işlemler gerçekleştirecek şekilde yönlendirilmesini içerir.
- Bu, export edilmeyen bileşenleri ve content providers'ı saldırganlara açabilir.
- `WebView`'in URL'den `Intent`'e dönüşümü istenmeyen eylemleri kolaylaştırabilir.

### Android Client Side Injections and others

Muhtemelen bu tür zafiyetleri Web'den biliyorsunuzdur. Android uygulamalarında bu zafiyetlere karşı özellikle dikkatli olmalısınız:

- **SQL Injection:** Dinamik sorgular veya Content-Providers ile çalışırken parametreli sorgular kullandığınızdan emin olun.
- **JavaScript Injection (XSS):** Herhangi bir WebView için JavaScript ve Plugin desteğinin devre dışı bırakıldığını doğrulayın (varsayılan olarak devre dışıdır). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebView'ların dosya sistemine erişimi devre dışı olmalıdır (varsayılan olarak etkin) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: Bazı durumlarda Android uygulama oturumu kapattığında cookie iptal edilmiyor veya diske kaydedilebiliyor
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Otomatik Analiz

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Statik analiz**

![](<../../images/image (866).png>)

**Uygulamanın zafiyet değerlendirmesini** güzel bir web tabanlı ön yüz kullanarak yapar. Dinamik analiz de yapabilirsiniz (ancak ortamı hazırlamanız gerekir).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### MobSF ile Yardımlı Dynamic analysis

**MobSF** can also be very helpful for **dynamic analysis** in **Android**, but in that case you will need to install MobSF and **genymotion** in your host (a VM or Docker won't work). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
The **MobSF dynamic analyser** can:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). All of this is done automatically except for the screenshots, you need to press when you want a screenshot or you need to press "**Exported Activity Tester**" to obtain screenshots of all the exported activities.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: It will print all the loaded classes
- **Capture Strings**: It will print all the capture strings while using the application (super noisy)
- **Capture String Comparisons**: Could be very useful. It will **show the 2 strings being compared** and if the result was True or False.
- **Enumerate Class Methods**: Put the class name (like "java.io.File") and it will print all the methods of the class.
- **Search Class Pattern**: Search classes by pattern
- **Trace Class Methods**: **Trace** a **whole class** (see inputs and outputs of all methods of th class). Remember that by default MobSF traces several interesting Android Api methods.

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf also brings you a shell with some **adb** commands, **MobSF commands**, and common **shell** **commands** at the bottom of the dynamic analysis page. Some interesting commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP araçları**

HTTP trafiği yakalandığında, yakalanan trafiğin çirkin bir görünümünü "**HTTP(S) Traffic**" altından veya daha hoş bir görünümünü "**Start HTTPTools**" yeşil butondan görebilirsiniz. İkinci seçenekten **yakalanan istekleri** Burp veya Owasp ZAP gibi **proxies**'e **send** edebilirsiniz.\
Bunu yapmak için, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> basın "**Send to Fuzzer**" --> _proxy adresini seçin_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

MobSF ile dinamik analizi bitirdikten sonra "**Start Web API Fuzzer**" a basarak **fuzz http requests** yapıp zafiyet arayabilirsiniz.

> [!TIP]
> MobSF ile dinamik analiz yaptıktan sonra proxy ayarları yanlış yapılandırılabilir ve GUI üzerinden düzeltilemeyebilir. Proxy ayarlarını düzeltmek için şu komutu kullanabilirsiniz:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

Aracı [**Inspeckage**](https://github.com/ac-pm/Inspeckage) üzerinden edinebilirsiniz.\
Bu araç bazı **Hooks** kullanarak **dinamik analiz** sırasında uygulamada **nelerin olup bittiğini** görmenizi sağlar.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Bu, GUI ile **statik analiz** yapmak için harika bir araçtır

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Bu araç, hem **source code** hem de paketlenmiş APK'larda çeşitli güvenlik ile ilgili Android uygulama zafiyetlerini aramak için tasarlanmıştır. Araç ayrıca bulunan bazı zafiyetleri (Exposed activities, intents, tapjacking...) istismar etmek için deploy edilebilir bir "Proof-of-Concept" APK ve ADB commands oluşturabilme yeteneğine sahiptir. Drozer'da olduğu gibi test cihazını rootlamaya gerek yoktur.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Kolay başvuru için çıkarılan tüm dosyaları gösterir
- APK dosyalarını otomatik olarak Java ve Smali formatına decompile eder
- AndroidManifest.xml'i yaygın zafiyetler ve davranışlar için analiz eder
- Yaygın zafiyetler ve davranışlar için statik kaynak kod analizi
- Cihaz bilgisi
- ve daha fazlası
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER, Windows, MacOS X ve Linux'ta kullanılabilen bir komut satırı uygulamasıdır; _.apk_ dosyalarını vulnerabilities aramak için analiz eder. Bunu APK'leri açıp bir dizi kural uygulayarak gerçekleştirir.

Tüm kurallar `rules.json` dosyasında toplanmıştır ve her şirket veya tester ihtiyaçlarına göre kendi kurallarını oluşturabilir.

En son binaries'leri [download page](https://superanalyzer.rocks/download.html) üzerinden indirin.
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn, mobil uygulamalar üzerinde [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) yapan geliştiriciler, bugbounty hunters ve ethical hackers için yardımcı olan **çok platformlu** bir araçtır.

Konsept, mobil uygulama dosyanızı (.apk veya .ipa file) StaCoAn uygulamasına sürükleyip bırakmanız ve uygulamanın sizin için görsel ve taşınabilir bir rapor üretmesidir. Ayarları ve wordlists'i düzenleyerek özelleştirilmiş bir deneyim elde edebilirsiniz.

İndir[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework, geliştiricilerin veya hackers'ın Android uygulamalarındaki potansiyel güvenlik açıklarını bulmalarına yardımcı olan bir Android zafiyet analiz sistemidir.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** bir araçtır; temel amacı bir Android uygulaması tarafından geliştirilebilecek potansiyel kötü amaçlı davranışları tespit etmek ve kullanıcıyı uyarmaktır.

Tespit, uygulamanın Dalvik bytecode'unun **Smali** olarak temsil edilen kısmının **static analysis** ile [`androguard`](https://github.com/androguard/androguard) kütüphanesi kullanılarak yapılır.

Bu araç **"kötü" uygulamaların yaygın davranışlarını** arar, örneğin: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** bir **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework'tür. Mobil uygulamaları OWASP mobile security tehditlerine karşı test etmeye yardımcı olmak için yaygın olarak kullanılan mobil uygulama reverse engineering ve analysis araçlarını bir araya getiren bir araçtır. Amacı, bu görevi mobil uygulama geliştiricileri ve güvenlik profesyonelleri için daha kolay ve kullanıcı dostu hale getirmektir.

Yapabildiği şeyler:

- Farklı araçlar kullanarak Java ve Smali kodunu çıkarmak
- APK'leri analiz etmek için kullanır: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- APK'den regexp'ler kullanarak özel bilgileri çıkarmak.
- Manifest'i analiz etmek.
- Bulunan domainleri analiz etmek için kullanır: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) ve [whatweb](https://github.com/urbanadventurer/WhatWeb)
- APK'yi [apk-deguard.com](http://www.apk-deguard.com) üzerinden deobfuscate etmek

### Koodous

Malware tespitinde faydalı: [https://koodous.com/](https://koodous.com)

## Kodun Obfuskasyonu/Deobfuskasyonu

Unutmayın ki kodu obfuscate etmek için kullandığınız servis ve yapılandırmaya bağlı olarak, secret'lar obfuscated olarak kalabilir veya kalmayabilir.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** Java kodunu küçülten, optimize eden ve obfuscate eden açık kaynaklı bir komut satırı aracıdır. Hem bytecode'u optimize edebilir hem de kullanılmayan talimatları tespit edip kaldırabilir. ProGuard özgür yazılımdır ve GNU General Public License, version 2 altında dağıtılmaktadır.

ProGuard Android SDK'nin bir parçası olarak dağıtılır ve uygulama release modunda derlenirken çalışır.

### [DexGuard](https://www.guardsquare.com/dexguard)

APK'yi deobfuscate etmek için adım adım bir rehber bulabilirsiniz: [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(o rehberden) Son kontrol ettiğimizde, Dexguard’ın çalışma modu şunlardı:

- Bir kaynağı InputStream olarak yüklemek;
- Sonucu decrypt etmek için FilterInputStream'ten türeyen bir sınıfa beslemek;
- bir reverser'ın birkaç dakikasını boşa harcamak için bazı anlamsız obfuscation'lar yapmak;
- decrypt edilmiş sonucu bir ZipInputStream'e verip bir DEX dosyası elde etmek;
- son olarak oluşan DEX'i `loadDex` metodunu kullanarak bir Resource olarak yüklemek.

### [DeGuard](http://apk-deguard.com)

**DeGuard, Android obfuscation araçları tarafından uygulanan obfuscation sürecini tersine çevirir. Bu, kod incelemesi ve kütüphane tahmini dahil olmak üzere birçok güvenlik analizine olanak tanır.**

Obfuscated bir APK'yı platformlarına yükleyebilirsiniz.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

Bu, **generic android deobfuscator**'dır. Simplify **pratikte bir uygulamayı yürütür** (virtually executes an app) davranışını anlamak için ve ardından **kodu optimize etmeye çalışır** böylece kod insan tarafından anlaşılması daha kolay fakat davranışı aynı kalır. Her optimizasyon tipi basit ve generiktir, bu yüzden hangi spesifik obfuscation türünün kullanıldığı önemli değildir.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD size bir **APK'nin nasıl oluşturulduğu** hakkında bilgi verir. Birçok **compiler**, **packer**, **obfuscator** ve diğer tuhaf şeyleri tanımlar. Android için [_PEiD_](https://www.aldeid.com/wiki/PEiD) gibidir.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b, ubuntu-mate tabanlı bir Android security virtual machine'dir ve reverse engineering ve malware analysis için farklı güvenlik meraklıları ve araştırmacılardan en son framework'leri, eğitimleri ve laboratuvarları içerir.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Harika bir kaynak listesi
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android hızlı kursu
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)

## Yet to try

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
