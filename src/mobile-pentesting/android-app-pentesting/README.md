# Pentesting Android-додатків

{{#include ../../banners/hacktricks-training.md}}

## Основи Android-додатків

Сильно рекомендовано почати з читання цієї сторінки, щоб дізнатися про **найважливіші частини, пов'язані з безпекою Android, і найнебезпечніші компоненти в Android-додатку**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Це основний інструмент, який потрібен для підключення до Android-пристрою (емулятора або фізичного пристрою).\
**ADB** дозволяє керувати пристроями через **USB** або **Network** з комп'ютера. Ця утиліта дає змогу **копіювати** файли в обох напрямках, **встановлювати** та **видаляти** додатки, **виконувати** shell-команди, **робити резервні копії** даних, **читати** логи та виконувати інші функції.

Подивіться на наступний список [**ADB Commands**](adb-commands.md), щоб навчитися використовувати adb.

## Smali

Іноді буває корисно **змінити код додатка**, щоб отримати доступ до **прихованої інформації** (наприклад, сильно обфускованих паролів або флагів). У такому випадку може бути цікаво декомпілювати APK, змінити код і повторно скомпілювати його.\
[**У цьому посібнику** ви можете **навчитися декомпілювати APK, змінювати Smali-код і знову компілювати APK** з новою функціональністю](smali-changes.md). Це може бути дуже корисно як **альтернатива для кількох тестів під час динамічного аналізу**, які будуть представлені. Тому **завжди майте на увазі цю можливість**.

## Інші цікаві трюки

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Витягнути APK з пристрою:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Об'єднайте всі splits і base apks за допомогою [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Кейси та вразливості


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Статичний аналіз

По-перше, для аналізу APK слід **переглянути Java-код** за допомогою декомпілятора.\
Будь ласка, [**прочитайте тут, щоб знайти інформацію про різні доступні decompilers**](apk-decompilers.md).

### Пошук цікавої інформації

Навіть переглядаючи лише **strings** APK, можна шукати **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** та інше цікаве... перевіряйте також наявність кодових виконуваних **backdoors** або авторизаційних backdoors (hardcoded admin credentials у додатку).

**Firebase**

Зверніть особливу увагу на **firebase URLs** і перевірте, чи не погано він налаштований. [Більше інформації про те, що таке Firebase і як це експлуатувати тут.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Базове розуміння застосунку - Manifest.xml, strings.xml

**Огляд файлів застосунку _Manifest.xml_ та _strings.xml_ може виявити потенційні проблеми безпеки**. Ці файли можна переглянути за допомогою декомпіляторів або перейменувавши розширення APK на .zip і розпакувавши його.

**Вразливості**, які можуть бути виявлені у **Manifest.xml**:

- **Debuggable Applications**: Застосунки, позначені як debuggable (`debuggable="true"`) у _Manifest.xml_, становлять ризик, оскільки дозволяють підключення, що може призвести до експлуатації. Для детальнішого розуміння того, як експлуатувати debuggable застосунки, зверніться до керівництва щодо знаходження та експлуатації debuggable додатків на пристрої.
- **Backup Settings**: Атрибут `android:allowBackup="false"` повинен бути явно вказаний для застосунків, що працюють з чутливою інформацією, щоб запобігти несанкціонованому резервному копіюванню через adb, особливо коли usb debugging увімкнено.
- **Network Security**: Користувацькі конфігурації безпеки мережі (`android:networkSecurityConfig="@xml/network_security_config"`) у _res/xml/_ можуть визначати деталі безпеки, як-от certificate pins та налаштування HTTP-трафіку. Приклад — дозвіл HTTP-трафіку для конкретних доменів.
- **Exported Activities and Services**: Ідентифікація exported activities та services в маніфесті може вказати на компоненти, які можуть бути зловживані. Подальший аналіз під час динамічного тестування може виявити способи експлуатації цих компонентів.
- **Content Providers and FileProviders**: Відкриті content providers можуть дозволити несанкціонований доступ або зміну даних. Конфігурацію FileProviders також слід ретельно перевірити.
- **Broadcast Receivers and URL Schemes**: Ці компоненти можуть бути використані для експлуатації, зверніть особливу увагу на те, як обробляються URL schemes для вразливостей при введенні.
- **SDK Versions**: Атрибути `minSdkVersion`, `targetSDKVersion` та `maxSdkVersion` вказують на підтримувані версії Android, що підкреслює важливість не підтримувати застарілі, вразливі версії Android з міркувань безпеки.

З файлу **strings.xml** можна знайти чутливу інформацію, таку як API keys, custom schemas та інші нотатки розробників, тому ці ресурси потребують ретельного перегляду.

### Tapjacking

**Tapjacking** — це атака, коли **malicious** **application** запускається і **розміщується поверх жертви-додатку**. Коли воно візуально закриває жертву, інтерфейс створений таким чином, щоб обдурити користувача й змусити його взаємодіяти з ним, при цьому подія передається до жертви.\
Фактично, це **слепить користувача, не даючи йому зрозуміти, що він насправді виконує дії у жертві**.

Детальніше шукайте у:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Активність з `launchMode`, встановленим на **`singleTask` без визначеного `taskAffinity`**, вразлива до Task Hijacking. Це означає, що **application** може бути інстальовано і, якщо його запустити перед справжнім застосунком, воно може **перехопити task справжнього застосунку** (тому користувач взаємодіятиме з **malicious application**, думаючи, що використовує реальний).

Детальніше у:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Ненадійне зберігання даних

Internal Storage

У Android файли, **збережені** у **internal** storage, спроектовані так, щоб бути **доступні лише додатку**, який їх створив. Ця міра безпеки **примусово застосовується** операційною системою Android і зазвичай є достатньою для потреб більшості застосунків. Однак розробники іноді використовують режими, такі як `MODE_WORLD_READABLE` та `MODE_WORLD_WRITABLE`, щоб **дозволити** файлам **обмінюватися** між різними додатками. Ці режими **не обмежують доступ** до файлів іншими додатками, включно з потенційно шкідливими.

1. **Static Analysis:**
- **Переконайтеся**, що використання `MODE_WORLD_READABLE` та `MODE_WORLD_WRITABLE` **ретельно перевірене**. Ці режими **можуть потенційно виставити** файли для **непередбаченого або несанкціонованого доступу**.
2. **Dynamic Analysis:**
- **Перевірте** дозволи, встановлені на файлах, які створює додаток. Зокрема, **перевіряйте**, чи будь-які файли **встановлені як читаємими або записуваними для всіх**. Це може бути серйозним ризиком безпеки, оскільки дозволяє **будь-якому додатку**, встановленому на пристрої, незалежно від походження чи намірів, **читати або модифікувати** ці файли.

External Storage

При роботі з файлами на **external storage**, таких як SD Cards, варто врахувати такі застереження:

1. **Доступність**:
- Файли на external storage є **загальнодоступними для читання та запису**. Це означає, що будь-який додаток або користувач може отримати доступ до цих файлів.
2. **Проблеми безпеки**:
- Через легкість доступу не рекомендується **зберігати чутливу інформацію** на external storage.
- External storage можна вилучити або до нього може отримати доступ будь-який додаток, що робить його менш безпечним.
3. **Обробка даних з external storage**:
- Завжди **виконуйте перевірку введення** для даних, отриманих з external storage. Це критично, оскільки дані походять з ненадійного джерела.
- Не рекомендується зберігати виконувані файли або class-файли на external storage для динамічного завантаження.
- Якщо вашому застосунку все ж потрібно завантажувати виконувані файли з external storage, переконайтесь, що ці файли **підписані та криптографічно перевірені** перед динамічним завантаженням. Цей крок є критичним для збереження цілісності безпеки застосунку.

External storage можна **доступитися** за шляхами /storage/emulated/0 , /sdcard , /mnt/sdcard

> [!TIP]
> Починаючи з Android 4.4 (**API 17**), на SD карті існує структура директорій, яка **обмежує доступ додатка лише до директорії, що спеціально призначена для цього додатка**. Це запобігає отриманню зловмисним додатком прав читання або запису до файлів іншого застосунку.

**Чутливі дані, збережені у відкритому тексті**

- **Shared preferences**: Android дозволяє кожному додатку зберігати xml-файли у шляху `/data/data/<packagename>/shared_prefs/`, і іноді в цій теці можна знайти чутливу інформацію у відкритому тексті.
- **Databases**: Android дозволяє кожному додатку зберігати sqlite бази даних у шляху `/data/data/<packagename>/databases/`, і іноді в цій теці можна знайти чутливу інформацію у відкритому тексті.

### Проблеми з TLS

Accept All Certificates

З якоїсь причини іноді розробники приймають усі сертифікати, навіть якщо, наприклад, hostname не збігається, з рядками коду, подібними до наведених нижче:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Добрий спосіб перевірити це — спробувати перехопити трафік за допомогою проксі на кшталт Burp без авторизації Burp CA на самому пристрої. Також можна згенерувати в Burp сертифікат для іншого hostname і використати його.

### Ненадійна криптографія

**Неналежні процеси керування ключами**

Деякі розробники зберігають конфіденційні дані в локальному сховищі й шифрують їх ключем, захардкоженим або передбачуваним у коді. Так робити не слід, оскільки реверсінг може дозволити атакам отримати ці дані.

**Використання небезпечних і/або застарілих алгоритмів**

Розробникам не слід використовувати **deprecated algorithms** для виконання авторизаційних **checks**, для **store** або **send** даних. Деякі з цих алгоритмів: RC4, MD4, MD5, SHA1... Якщо, наприклад, **hashes** використовуються для зберігання паролів, потрібно застосовувати хеші, стійкі до brute-force, з сіллю.

### Інші перевірки

- Рекомендується **обфускувати APK**, щоб ускладнити роботу реверс-інженерів.
- Якщо додаток чутливий (наприклад bank apps), він має виконувати власні перевірки, щоб визначити, чи пристрій rooted, і діяти відповідно.
- Якщо додаток чутливий (наприклад bank apps), варто перевіряти, чи використовується **emulator**.
- Якщо додаток чутливий (наприклад bank apps), він має **перевіряти власну цілісність перед виконанням**, щоб упевнитися, що його не було змінено.
- Використовуйте [**APKiD**](https://github.com/rednaga/APKiD), щоб перевірити, який compiler/packer/obfuscator був використаний для побудови APK

### React Native Application

Прочитайте наступну сторінку, щоб дізнатися, як легко отримати доступ до javascript коду React додатків:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Прочитайте наступну сторінку, щоб дізнатися, як легко отримати доступ до C# коду xamarin додатків:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

Згідно з цим [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked — це Meta алгоритм, який стискає вміст додатку в один файл. У блозі йдеться про можливість створити додаток, який розпаковує такого роду апки... та про швидший спосіб, який передбачає **запуск додатку і збір розпакованих файлів з файлової системи.**

### Automated Static Code Analysis

Інструмент [**mariana-trench**](https://github.com/facebook/mariana-trench) здатен знаходити **vulnerabilities**, просканувавши **code** додатку. Цей інструмент містить набір **known sources** (вказує місця, де **input** контролюється користувачем), **sinks** (вказує **dangerous** місця, де зловмисний ввід може завдати шкоди) та **rules**. Ці правила визначають **combination** джерел та sinks, що сигналізує про вразливість.

Завдяки цьому **mariana-trench перегляне код і знайде можливі вразливості**.

### Secrets leaked

Додаток може містити secrets (API keys, passwords, hidden urls, subdomains...) всередині, які ви можете виявити. Ви можете використати інструмент на кшталт [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Інші цікаві функції

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)
- In-memory native code execution via JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> По-перше, вам потрібне середовище, де можна встановити додаток і все оточення (Burp CA cert, Drozer і Frida в першу чергу). Тому strongly рекомендується мати rooted пристрій (емулятор або фізичний).

### Online Dynamic analysis

Ви можете створити **free account** на: [https://appetize.io/](https://appetize.io). Ця платформа дозволяє **upload** і **execute** APK, тому вона корисна, щоб побачити, як apk поводиться.

Ви навіть можете **see the logs of your application** у вебі і підключитися через **adb**.

![](<../../images/image (831).png>)

Завдяки ADB-підключенню ви можете використовувати **Drozer** і **Frida** всередині емульованого середовища.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (ви можете створювати **x86** та **arm** пристрої, і згідно з [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** версії **підтримують ARM бібліотеки** без потреби у повільному ARM емуляторі).
- Навчіться налаштовувати це на цій сторінці:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, потрібно створити акаунт. _Рекомендується **download** версію **WITH** _**VirtualBox** щоб уникнути потенційних помилок._)
- [**Nox**](https://es.bignox.com) (Free, але не підтримує Frida або Drozer).

> [!TIP]
> При створенні нового емулятора на будь-якій платформі пам'ятайте, що чим більший екран — тим повільніше працюватиме емулятор. Тому за можливості обирайте невеликі екрани.

Щоб **install google services** (типу AppStore) в Genymotion потрібно натиснути на червону позначену кнопку на наступному зображенні:

![](<../../images/image (277).png>)

Також зверніть увагу, що в **configuration of the Android VM in Genymotion** можна вибрати **Bridge Network mode** (це буде корисно, якщо ви підключатиметесь до Android VM з іншої VM з інструментами).

#### Use a physical device

Потрібно активувати **debugging** опції, і було б добре, якщо ви зможете **root** його:

1. **Settings**.
2. (From Android 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Після встановлення додатку перше, що слід зробити — це спробувати його, вивчити, що він робить, як працює, і відчути себе з ним комфортно.\
> Рекомендую **виконати цей початковий dynamic analysis за допомогою MobSF dynamic analysis + pidcat**, щоб ми могли **learn how the application works**, поки MobSF **captures** багато **interesting** **data**, які ви зможете переглянути пізніше.

Magisk/Zygisk quick notes (recommended on Pixel devices)
- Patch boot.img with the Magisk app and flash via fastboot to get systemless root
- Enable Zygisk + DenyList for root hiding; consider LSPosed/Shamiko when stronger hiding is required
- Keep original boot.img to recover from OTA updates; re-patch after each OTA
- For screen mirroring, use scrcpy on the host



### Unintended Data Leakage

**Logging**

Розробникам слід обережно ставитися до оприлюднення **debugging information**, оскільки це може призвести до sensitive data leaks. Рекомендуються інструменти [**pidcat**](https://github.com/JakeWharton/pidcat) та `adb logcat` для моніторингу логів додатку з метою виявлення й захисту конфіденційної інформації. **Pidcat** переважно через простоту використання та читабельність.

> [!WARNING]
> Зверніть увагу, що з **пізніших версій, новіших за Android 4.0**, **додатки можуть отримувати доступ лише до своїх логів**. Тому додатки не можуть читати логи інших додатків.\
> У будь-якому випадку все ще рекомендовано **не логувати конфіденційну інформацію**.

**Copy/Paste Buffer Caching**

Android-рамка, що базується на **clipboard**, забезпечує функціональність copy-paste в додатках, але становить ризик, оскільки **інші додатки** можуть **access** буфер обміну, потенційно відкриваючи конфіденційні дані. Важливо **disable copy/paste** для чутливих секцій додатку, наприклад даних кредитної картки, щоб запобігти data leaks.

**Crash Logs**

Якщо додаток **crash** і **зберігає логи**, ці логи можуть допомогти атакам, особливо коли додаток важко реверсинжити. Щоб пом'якшити ризик, уникайте логування під час crash, а якщо логи потрібно відправляти по мережі — забезпечуйте передачу через SSL-канал.

Як pentester, **спробуйте переглянути ці логи**.

**Analytics Data Sent To 3rd Parties**

Додатки часто інтегрують сервіси типу Google Adsense, що може ненавмисно привести до sensitive data leaks через неправильну імплементацію розробника. Щоб виявити потенційні витоки, радимо **intercept the application's traffic** та перевірити, чи не надсилається конфіденційна інформація до third-party сервісів.

### SQLite DBs

Більшість додатків використовують **internal SQLite databases** для збереження інформації. Під час pentest перегляньте **databases**, імена **tables** і **columns** та всі **дані**, що зберігаються, оскільки ви можете знайти **sensitive information** (що буде вразливістю).\
Бази даних мають знаходитись у /data/data/the.package.name/databases, наприклад /data/data/com.mwr.example.sieve/databases

Якщо база даних зберігає конфіденційну інформацію і вона **encrypted**, але ви можете **find** **password** всередині додатку — це все ще вважається **vulnerability**.

Перелічіть таблиці за допомогою `.tables` і визначте схему таблиць командою `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

Згідно з [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** дозволяє вам **прикинутися Android app** і взаємодіяти з іншими додатками. Він може робити **anything that an installed application can do**, наприклад використовувати Inter-Process Communication (IPC) Android і взаємодіяти з підлягаючою операційною системою.\
Drozer — корисний інструмент для **exploit exported activities, exported services and Content Providers**, як ви дізнаєтесь у наступних розділах.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Також пам'ятайте, що код activity починається в методі **`onCreate`**.

**Authorisation bypass**

Коли Activity exported, ви можете викликати його екран з зовнішнього додатку. Тому, якщо activity з **sensitive information** exported, ви могли б **bypass** механізми **authentication**, щоб отримати до нього доступ.

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

Ви також можете запустити exported activity з adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**ПРИМІТКА**: MobSF виявляє як шкідливе використання _**singleTask/singleInstance**_ як `android:launchMode` в activity, але через [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), очевидно, що це небезпечно лише в старих версіях (API versions < 21).

> [!TIP]
> Зверніть увагу, що authorisation bypass не завжди є вразливістю — це залежить від того, як працює bypass і яка інформація стає доступною.

**Sensitive information leakage**

**Activities can also return results**. Якщо вам вдасться знайти exported і unprotected activity, яка викликає метод **`setResult`** і **повертає sensitive information**, це призводить до sensitive information leakage.

#### Tapjacking

Якщо tapjacking не запобігається, ви можете зловживати exported activity, щоб змусити **користувача виконувати небажані дії**. For more info about [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers, по суті, використовуються для **обміну даними**. Якщо в додатку є доступні content providers, ви можете мати можливість **витягти конфіденційні** дані з них. Також варто перевірити можливі **SQL injections** та **Path Traversals**, оскільки вони можуть бути вразливими.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Пам'ятайте, що дії Service починаються в методі `onStartCommand`.

Service, по суті, може отримувати дані, обробляти їх і повертати (або не повертати) відповідь. Тому, якщо додаток експортує якісь services, вам слід перевірити код, щоб зрозуміти, що він робить, і протестувати його динамічно для витягування конфіденційної інформації, обходу заходів аутентифікації...\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Пам'ятайте, що дії Broadcast Receiver починаються в методі `onReceive`.

Broadcast receiver очікує певний тип повідомлення. Залежно від того, як receiver обробляє повідомлення, він може бути вразливим.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

You can look for deep links manually, using tools like MobSF or scripts like [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Ви можете **відкрити** задекларований **scheme** за допомогою **adb** або **браузера**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Зверніть увагу, що ви можете **не вказувати ім'я пакета**, і мобільний пристрій автоматично відкриє додаток, який має відкрити це посилання._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Виконуваний код**

Щоб знайти **код, який буде виконано в додатку**, перейдіть до activity, викликаної deeplink, і знайдіть функцію **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Чутлива інформація**

Кожного разу, коли ви знаходите deep link, перевірте, що **він не отримує чутливих даних (наприклад паролів) через URL параметри**, бо будь-який інший додаток може **імітувати deep link і вкрасти ці дані!**

**Параметри в шляху**

Ви також повинні перевірити, чи якийсь deep link не використовує параметр всередині path URL, наприклад: `https://api.example.com/v1/users/{username}` , у такому випадку ви можете примусити path traversal, звернувшись до чогось на кшталт: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Зауважте, що якщо ви знайдете правильні endpoints всередині застосунку, ви можете спричинити **Open Redirect** (якщо частина шляху використовується як домен), **account takeover** (якщо ви можете змінити деталі користувачів без CSRF token і вразливий endpoint використовував правильний method) та інші вразливості. More [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**Більше прикладів**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Інспекція транспортного рівня та помилки перевірки

- **Сертифікати не завжди перевіряються належним чином** Android-додатками. Часто такі додатки ігнорують попередження і приймають self-signed certificates або, в окремих випадках, повертаються до використання HTTP-з'єднань.
- **Переговори під час SSL/TLS handshake іноді слабкі**, використовуються небезпечні cipher suites. Ця вразливість робить з'єднання вразливим до man-in-the-middle (MITM) атак, дозволяючи атакуючим розшифровувати дані.
- **Витік приватної інформації** — це ризик, коли додатки аутентифікуються через захищені канали, але потім для інших транзакцій використовують незахищені канали. Такий підхід не захищає чутливі дані, такі як session cookies або дані користувача, від перехоплення зловмисниками.

#### Перевірка сертифікатів

Ми зосередимося на **certificate verification**. Необхідно перевіряти цілісність серверного сертифіката для підвищення безпеки. Це критично, оскільки insecure TLS конфігурації та передача чутливих даних по незашифрованих каналах можуть становити значні ризики. Для детальних кроків з перевірки серверних сертифікатів та усунення вразливостей, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) надає вичерпні рекомендації.

#### SSL Pinning

SSL Pinning — це захід безпеки, коли додаток перевіряє серверний сертифікат порівняно з відомою копією, збереженою в самому додатку. Цей метод важливий для запобігання MITM атак. Рекомендується реалізувати SSL Pinning для додатків, що працюють із чутливою інформацією.

#### Інспекція трафіку

Щоб інспектувати HTTP-трафік, необхідно **встановити сертифікат proxy tool** (наприклад, Burp). Без встановлення цього сертифіката зашифрований трафік може бути невидимим через проксі. Для керівництва зі встановлення кастомного CA сертифіката, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Додатки, спрямовані на **API Level 24 and above**, вимагають змін у Network Security Config, щоб прийняти CA сертифікат проксі. Цей крок критично важливий для інспекції зашифрованого трафіку. Для інструкцій щодо модифікації Network Security Config, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

Якщо використовується **Flutter**, вам потрібно виконати інструкції на [**this page**](flutter.md). Це тому, що просто додати сертифікат у системний магазин не спрацює, оскільки Flutter має власний список валідних CAs.

#### Статичне виявлення SSL/TLS pinning

Перед тим, як пробувати runtime bypasses, швидко визначте, де в APK застосовується pinning. Статичне виявлення допомагає спланувати hooks/patches і зосередитися на потрібних code paths.

Tool: SSLPinDetect
- Open-source утиліта статичного аналізу, яка декомпілює APK у Smali (через apktool) і сканує куровані regex паттерни реалізацій SSL/TLS pinning.
- Повертає точний file path, номер рядка та фрагмент коду для кожного збігу.
- Охоплює поширені frameworks та кастомні code paths: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

Встановлення
- Вимоги: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Використання
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Приклад правил шаблонів (JSON)
Використовуйте або розширюйте signatures для виявлення пропрієтарних/власних стилів pinning. Ви можете завантажити власний JSON і виконувати масштабне сканування.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes and tips
- Швидке сканування великих додатків за допомогою багатопоточності та memory-mapped I/O; pre-compiled regex зменшують накладні витрати/false positives.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Типові цілі для виявлення та подальшого триажу:
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Declarative pins in res/xml network security config and manifest references
- Використайте знайдені місця для планування Frida hooks, статичних патчів або перегляду конфігурацій перед динамічним тестуванням.



#### Обхід SSL Pinning

Коли SSL Pinning реалізовано, його обхід стає необхідним для інспекції HTTPS-трафіку. Для цього доступні різні методи:

- Автоматично **модифікувати** **apk**, щоб **обійти** SSLPinning за допомогою [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Головна перевага цього варіанту — вам не потрібен root для обходу SSL Pinning, але доведеться видалити додаток і встановити модифіковану версію, і це не завжди працює.
- Можна використовувати **Frida** (описано нижче) для обходу цього захисту. Ось гайд для використання Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Можна також спробувати **автоматично обійти SSL Pinning** за допомогою [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Можна також спробувати **автоматично обійти SSL Pinning** за допомогою **MobSF dynamic analysis** (пояснюється нижче)
- Якщо ви все ще вважаєте, що якийсь трафік не перехоплюється, можна спробувати **переадресувати трафік до Burp за допомогою iptables**. Читайте цей блог: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Пошук поширених веб-уразливостей

Важливо також шукати поширені веб-уразливості в межах додатку. Детальна інформація про ідентифікацію та пом'якшення цих вразливостей виходить за рамки цього огляду, але детально розглянута в інших джерелах.

### Frida

[Frida](https://www.frida.re) — інструментарій для динамічної інструментації для розробників, реверс-інженерів та дослідників безпеки.\
**Ви можете отримувати доступ до запущеного додатку та перехоплювати методи під час виконання, змінювати поведінку, змінювати значення, витягувати значення, виконувати інший код...**\
Якщо ви хочете pentest Android applications, вам потрібно вміти користуватися Frida.

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Some "GUI" for actions with Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- You can find some Awesome Frida scripts here: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Try to bypass anti-debugging / anti-frida mechanisms loading Frida as in indicated in [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Дамп пам'яті - Fridump**

Перевірте, чи додаток зберігає в пам'яті чутливу інформацію, яку не повинен зберігати, наприклад паролі або мнемонічні фрази.

Using [**Fridump3**](https://github.com/rootbsd/fridump3) you can dump the memory of the app with:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Це згенерує дамп пам'яті в папку ./dump, і там ви можете виконати grep, наприклад:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Чутливі дані в Keystore**

У Android Keystore — найкраще місце для зберігання чутливих даних, однак за наявності достатніх привілеїв все ще **можливо отримати до нього доступ**. Оскільки додатки часто зберігають тут **чутливі дані у відкритому вигляді**, pentests повинні перевіряти це, оскільки root user або особи з фізичним доступом до пристрою можуть вкрасти ці дані.

Навіть якщо додаток зберіг дані в keystore, ці дані повинні бути зашифровані.

Щоб отримати доступ до даних всередині keystore, можна використати цей Frida скрипт: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Використовуючи наведений скрипт Frida, можливо **bypass fingerprint authentication**, яке Android-додатки можуть виконувати, щоб **захистити певні чутливі області:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Фонові зображення**

Коли ви переводите додаток у фон, Android зберігає **snapshot of the application**, тож коли його відновлюють на передній план, система спочатку завантажує це зображення перед самим додатком, щоб здавалося, ніби додаток завантажився швидше.

Однак, якщо цей snapshot містить **чутливу інформацію**, людина з доступом до snapshot може **вкрасти цю інформацію** (зауважте, для доступу потрібен root).

Snapshots зазвичай зберігаються за адресою: **`/data/system_ce/0/snapshots`**

Android надає спосіб **запобігти захопленню screenshot шляхом встановлення параметра макета FLAG_SECURE**. Використовуючи цей флаг, вміст вікна розглядається як захищений, що запобігає його появі у screenshots або перегляду на non-secure displays.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### Аналізатор Android-додатків

This tool could help you managing different tools during the dynamic analysis: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Розробники часто створюють proxy components like activities, services, and broadcast receivers, які обробляють ці Intents і передають їх у методи, такі як `startActivity(...)` або `sendBroadcast(...)`, що може бути ризиковано.

Небезпека полягає в тому, що атакувальники можуть спрямувати ці Intents так, щоб викликати non-exported app components або отримати доступ до чутливих content providers. Яскравим прикладом є компонент `WebView`, який перетворює URL на `Intent` через `Intent.parseUri(...)` і потім виконує їх, що потенційно дозволяє malicious Intent injections.

### Ключові висновки

- **Intent Injection** схожа на проблему Open Redirect у web.
- Експлойти пов'язані з передачею об'єктів `Intent` як extras, які можна перенаправити для виконання небезпечних операцій.
- Це може відкрити доступ до non-exported components і content providers для атакувальників.
- Перетворення URL на `Intent` у `WebView` може сприяти небажаним діям.

### Android Client Side Injections and others

Ймовірно, ви знайомі з цими типами вразливостей з Web. У Android-додатку слід бути особливо обережним із такими вразливостями:

- **SQL Injection:** При роботі з динамічними запитами або Content-Providers переконайтеся, що використовуєте parameterized queries.
- **JavaScript Injection (XSS):** Переконайтеся, що підтримка JavaScript і Plugin вимкнена для WebViews (disabled by default). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews мають мати доступ до файлової системи вимкненим (enabled by default) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: У деяких випадках, коли android application завершує сесію, cookie не відкликається або навіть може бути збережено на диск
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Автоматичний аналіз

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Статичний аналіз**

![](<../../images/image (866).png>)

**Vulnerability assessment of the application** using a nice web-based frontend. You can also perform dynamic analysis (but you need to prepare the environment).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Асистований динамічний аналіз з MobSF

**MobSF** також може бути дуже корисним для **dynamic analysis** на **Android**, але в цьому випадку потрібно встановити MobSF та **genymotion** на вашому хості (VM або Docker не підходять). _Примітка: потрібно **спочатку запустити VM у genymotion** і **потім MobSF.**_\
**MobSF dynamic analyser** може:

- **Dump application data** (URLs, логи, clipboard, скриншоти, зроблені вами, скриншоти, зроблені "**Exported Activity Tester**", електронні листи, SQLite databases, XML файли, та інші створені файли). Усе це виконується автоматично, крім скриншотів — потрібно натиснути, коли ви хочете зробити скриншот, або натиснути "**Exported Activity Tester**", щоб отримати скриншоти всіх exported activities.
- Перехоплювати **HTTPS traffic**
- Використовувати **Frida** для отримання **runtime** **information**

Для android **versions > 5** воно **автоматично запустить Frida** та встановить глобальні налаштування **proxy** для **capture** трафіку. Воно перехоплює трафік лише з тестованого додатка.

**Frida**

За замовчуванням також використовуються деякі Frida Scripts для **bypass SSL pinning**, **root detection** та **debugger detection** і для **monitor interesting APIs**.\
MobSF також може **invoke exported activities**, робити **screenshots** цих активностей та **save** їх для звіту.

Щоб **start** динамічне тестування натисніть зелену кнопку: "**Start Instrumentation**". Натисніть "**Frida Live Logs**", щоб побачити логи, згенеровані Frida scripts, та "**Live API Monitor**", щоб побачити всі виклики до hooked methods, передані аргументи та повернені значення (це з’явиться після натискання "Start Instrumentation").\
MobSF також дозволяє завантажувати власні **Frida scripts** (щоб відправити результати ваших Frida scripts до MobSF використовуйте функцію `send()`). Воно також має **several pre-written scripts**, які ви можете завантажити (ви можете додати більше в `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), просто **select them**, натисніть "**Load**" і натисніть "**Start Instrumentation**" (ви зможете побачити логи цих скриптів всередині "**Frida Live Logs**").

![](<../../images/image (419).png>)

Крім того, є кілька додаткових функцій Frida:

- **Enumerate Loaded Classes**: Виводить всі завантажені класи
- **Capture Strings**: Виводить усі захоплені рядки під час використання додатка (дуже шумно)
- **Capture String Comparisons**: Може бути дуже корисним. Він **показує 2 рядки, що порівнюються**, і чи був результат True або False.
- **Enumerate Class Methods**: Введіть ім'я класу (наприклад "java.io.File") і він виведе всі методи класу.
- **Search Class Pattern**: Пошук класів за шаблоном
- **Trace Class Methods**: **Trace** всього класу (див. вхідні та вихідні дані всіх методів класу). Пам'ятайте, що за замовчуванням MobSF трасує кілька цікавих Android Api methods.

Після того як ви обрали допоміжний модуль, який хочете використати, потрібно натиснути "**Start Intrumentation**" і ви побачите всі виходи в "**Frida Live Logs**".

**Shell**

MobSF також надає shell з деякими **adb** командами, **MobSF commands**, та поширеними **shell** **commands** внизу сторінки динамічного аналізу. Декілька цікавих команд:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP інструменти**

Коли HTTP трафік захоплено, ви можете побачити сирий вигляд захопленого трафіку у нижній частині "**HTTP(S) Traffic**" або більш приємний вигляд у зеленій кнопці "**Start HTTPTools**". З другого варіанту ви можете **відправити** **захоплені запити** до **проксі** (proxies) типу Burp або Owasp ZAP.\
Щоб це зробити, _запустіть Burp -->_ _вимкніть Intercept --> в MobSF HTTPTools виберіть запит_ --> натисніть "**Send to Fuzzer**" --> _виберіть адресу проксі_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Коли ви завершите dynamic analysis з MobSF, можна натиснути "**Start Web API Fuzzer**" щоб **fuzz http requests** і шукати вразливості.

> [!TIP]
> Після виконання dynamic analysis з MobSF налаштування проксі можуть бути некоректними і ви не зможете виправити їх через GUI. Ви можете виправити налаштування проксі виконавши:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

Інструмент можна отримати з [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Цей tool використовує деякі **Hooks**, щоб повідомляти, **що відбувається в додатку**, поки ви виконуєте **dynamic analysis**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Це **чудовий інструмент для виконання static analysis з GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Цей tool призначений для пошуку кількох **security related Android application vulnerabilities**, як у **source code**, так і в **packaged APKs**. Інструмент також **здатний створити "Proof-of-Concept" deployable APK** та **ADB commands**, щоб експлуатувати деякі виявлені вразливості (Exposed activities, intents, tapjacking...). Як і з Drozer, немає потреби рутувати тестовий пристрій.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Відображає всі витягнуті файли для зручного перегляду
- Автоматично декомпілює APK у формати Java і Smali
- Аналізує AndroidManifest.xml на предмет поширених вразливостей та поведінки
- Статичний аналіз вихідного коду на поширені вразливості та поведінку
- Інформація про пристрій
- та інше
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER — це програма командного рядка, яку можна використовувати в Windows, MacOS X і Linux, вона аналізує _.apk_ файли в пошуках уразливостей. Вона робить це шляхом розпакування APKs і застосування ряду правил для виявлення цих уразливостей.

Всі правила зосереджені у файлі `rules.json`, і кожна компанія або тестувальник може створити власні правила для аналізу того, що їм потрібно.

Завантажте останні бінарні файли на [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn — це **кросплатформений** інструмент, який допомагає розробникам, bugbounty hunters і ethical hackers виконувати [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) на мобільних додатках.

Ідея полягає в тому, що ви перетягуєте файл вашого мобільного додатка (an .apk or .ipa file) у додаток StaCoAn, і він згенерує для вас візуальний та портативний звіт. Ви можете коригувати налаштування та wordlists для отримання персоналізованого результату.

Завантажити[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework — це система аналізу вразливостей Android, яка допомагає розробникам або hackers виявляти потенційні вразливості безпеки в Android-додатках.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** — інструмент, головною метою якого є виявлення та попередження користувача про потенційно шкідливу поведінку, реалізовану Android-застосунком.

Виявлення виконується за допомогою **static analysis** байткоду Dalvik застосунку, представленого як **Smali**, з використанням бібліотеки [`androguard`](https://github.com/androguard/androguard).

Цей інструмент шукає **common behavior of "bad" applications**, такі як: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. Це інструмент, який поєднує широко вживані інструменти для reverse engineering та аналізу mobile application, щоб допомогти у тестуванні мобільних додатків проти загроз OWASP mobile security. Його мета — зробити це завдання простішим і зручнішим для розробників мобільних додатків та фахівців з безпеки.

Він може:

- Extract Java and Smali code using different tools
- Аналізувати APK за допомогою: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Витягувати приватну інформацію з APK за допомогою регулярних виразів.
- Аналізувати Manifest.
- Аналізувати знайдені домени за допомогою: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Корисний для виявлення шкідливого ПЗ: [https://koodous.com/](https://koodous.com/)

## Обфускація/Деобфускація коду

Зверніть увагу, що залежно від сервісу та конфігурації, які ви використовуєте для обфускації коду, секрети можуть бути обфусковані або ні.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. Він здатний оптимізувати bytecode, а також виявляти та видаляти невикористані інструкції. ProGuard є вільним програмним забезпеченням і розповсюджується під GNU General Public License, version 2.

ProGuard постачається як частина Android SDK і запускається при збірці додатку в release-режимі.

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Востаннє, коли ми перевіряли, режим роботи Dexguard був:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

Ви можете завантажити обфускований APK на їхню платформу.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

Це загальний інструмент для деобфускації android. Simplify **віртуально виконує додаток**, щоб зрозуміти його поведінку, а потім **намагається оптимізувати код**, щоб він поводився ідентично, але був легшим для розуміння людиною. Кожен тип оптимізації простий і загальний, тому не має значення, який конкретний тип обфускації використовувався.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD дає вам інформацію про **how an APK was made**. Він ідентифікує багато **compilers**, **packers**, **obfuscators**, та інших дивних речей. It's [_PEiD_](https://www.aldeid.com/wiki/PEiD) for Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Лабораторії

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b — це віртуальна машина для безпеки Android на базі ubuntu-mate, яка включає збірку останніх фреймворків, посібників і лабораторій від різних дослідників і ентузіастів безпеки для reverse engineering і аналізу шкідливого ПЗ.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Це чудовий список ресурсів
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
