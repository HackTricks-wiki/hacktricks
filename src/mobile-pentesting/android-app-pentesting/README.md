# Android Uygulamaları Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android Uygulamaları Temelleri

Bu sayfayı okumaya başlamanız kuvvetle tavsiye edilir; **Android güvenliğiyle ilgili en önemli parçalar ve bir Android uygulamasındaki en tehlikeli bileşenler** hakkında bilgi edinmek için:

{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Bu, bir android cihaza (emüle edilmiş veya fiziksel) bağlanmak için ihtiyaç duyduğunuz ana araçtır.\
**ADB**, bir bilgisayardan **USB** veya **ağ** üzerinden cihazları kontrol etmeyi sağlar. Bu yardımcı program, dosyaların iki yönlü **kopyalanması**, uygulamaların **yüklenmesi** ve **kaldırılması**, shell komutlarının **çalıştırılması**, verilerin **yedeklenmesi**, logların **okunması** ve diğer işlevleri sağlar.

ADB'yi nasıl kullanacağınızı öğrenmek için aşağıdaki [**ADB Commands**](adb-commands.md) listesine göz atın.

## Smali

Bazen **uygulama kodunu değiştirmek**, **gizli bilgilere** erişmek için ilginç olabilir (örneğin iyi obfuscated edilmiş parolalar veya flags). Bu durumda, apk'yi decompile edip kodu değiştirip yeniden derlemek ilginç olabilir.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Bu, sunulacak dinamik analiz sırasında gerçekleştirilecek çeşitli testler için faydalı bir **alternatif** olabilir. O halde, **bu olasılığı her zaman aklınızda bulundurun**.

## Diğer ilginç taktikler

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Cihazdan APK çıkar:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Tüm splits'leri ve base apks'leri [APKEditor](https://github.com/REAndroid/APKEditor) ile birleştirin:
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Vaka İncelemeleri & Güvenlik Açıkları


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Statik Analiz

Öncelikle, bir APK'yı analiz ederken bir decompiler kullanarak **Java koduna göz atmalısınız**.\
Lütfen, [**farklı kullanılabilir decompiler'lar hakkında bilgi bulmak için burayı okuyun**](apk-decompilers.md).

### İlginç Bilgiler Arama

APK'nın **strings**'lerine bakarak **parolalar**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** anahtarları, **şifreleme**, **bluetooth uuids**, **tokens** ve dikkat çeken diğer şeyleri arayabilirsiniz... hatta kod yürütme için **backdoor** veya kimlik doğrulama backdoor'larına (uygulamaya gömülü admin kimlik bilgileri) bakın.

**Firebase**

Özellikle **Firebase URL'lerine** dikkat edin ve yanlış yapılandırılmış olup olmadığını kontrol edin. [Firebase'in ne olduğu ve nasıl suistimal edileceği hakkında daha fazla bilgi burada.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Uygulamayı Temel Düzeyde Anlama - Manifest.xml, strings.xml

Bir uygulamanın **_Manifest.xml_ ve **_strings.xml_** dosyalarının incelenmesi potansiyel güvenlik açıklarını ortaya çıkarabilir**. Bu dosyalara decompiler'lar ile erişilebilir veya APK dosya uzantısını .zip olarak değiştirip açabilirsiniz.

**Manifest.xml** dosyasından tespit edilebilecek **güvenlik açıkları** şunlardır:

- **Debuggable Applications**: _Manifest.xml_ dosyasında `debuggable="true"` olarak işaretlenmiş uygulamalar, bağlantılara izin verdiği için istismara açık olabilir. Debuggable uygulamaların nasıl istismar edileceğini anlamak için ilgili eğitim materyallerine bakın.
- **Backup Settings**: Hassas bilgilerle uğraşan uygulamalar için `android:allowBackup="false"` özniteliğinin açıkça ayarlanması gerekir; aksi takdirde adb ile yetkisiz veri backup'u yapılabilir, özellikle usb debugging etkinse.
- **Network Security**: _res/xml/_ içinde tanımlanmış özel network security config (`android:networkSecurityConfig="@xml/network_security_config"`) sertifika pinleri ve HTTP trafiği ayarları gibi güvenlik detaylarını belirtebilir. Örneğin belirli domainler için HTTP trafiğine izin verilebilir.
- **Exported Activities and Services**: Manifest'te export edilmiş activity ve service'lerin belirlenmesi, kötüye kullanılabilecek bileşenleri ortaya çıkarabilir. Dinamik testler sırasında bu bileşenlerin nasıl istismar edilebileceği daha ayrıntılı analizle ortaya çıkabilir.
- **Content Providers and FileProviders**: Açığa çıkmış content provider'lar yetkisiz veri erişimine veya değiştirmeye izin verebilir. FileProvider yapılandırması da dikkatle incelenmelidir.
- **Broadcast Receivers and URL Schemes**: Bu bileşenler istismar için kullanılabilir; özellikle URL scheme'lerinin nasıl yönetildiğine ve giriş validasyonuna dikkat edilmelidir.
- **SDK Versions**: `minSdkVersion`, `targetSDKVersion` ve `maxSdkVersion` öznitelikleri desteklenen Android sürümlerini gösterir; eski ve zayıf Android sürümlerine destek vermemek güvenlik için önemlidir.

**strings.xml** dosyasından API anahtarları, özel şemalar ve diğer geliştirici notları gibi hassas bilgiler keşfedilebilir; bu kaynakların dikkatle incelenmesi gerekir.

### Tapjacking

Tapjacking, kötü niyetli bir uygulamanın hedef uygulamanın üzerine **konumlanması** ile yapılan bir saldırıdır. Hedef uygulamayı görsel olarak gizledikten sonra, kötü amaçlı uygulamanın kullanıcı arayüzü kullanıcıyı kandıracak şekilde tasarlanır ve etkileşimleri hedef uygulamaya iletir.\
Sonuç olarak, kullanıcı aslında hedef uygulama üzerinde işlem yaptığının farkında olmadan körlenmiş olur.

Daha fazla bilgi için bakınız:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

`launchMode`'u **`singleTask`** olarak ayarlanmış ve herhangi bir `taskAffinity` tanımlanmamış bir **activity**, task Hijacking'e açıktır. Bu, kötü amaçlı bir uygulamanın yüklenip gerçek uygulamadan önce çalıştırılması durumunda **gerçek uygulamanın task'ını ele geçirebileceği** anlamına gelir (kullanıcı, gerçek uygulamayı kullanıyor sanarak kötü amaçlı uygulama ile etkileşime girebilir).

Daha fazla bilgi:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Güvensiz veri depolama

**Internal Storage**

Android'de **internal** depolamada saklanan dosyalar, onları oluşturan **app** tarafından erişilecek şekilde tasarlanmıştır. Bu güvenlik önlemi Android işletim sistemi tarafından uygulanır ve çoğu uygulamanın güvenlik ihtiyaçları için yeterlidir. Ancak geliştiriciler bazen dosyaların farklı uygulamalar arasında paylaşılmasına izin vermek için `MODE_WORLD_READABLE` ve `MODE_WORLD_WRITABLE` gibi modları kullanırlar. Bu modlar dosyaların diğer uygulamalar, potansiyel olarak kötü amaçlı olanlar dahil, tarafından erişilmesini engellemez.

1. **Statik Analiz:**
- `MODE_WORLD_READABLE` ve `MODE_WORLD_WRITABLE` kullanımının **dikkatle incelenmesini** sağlayın. Bu modlar dosyaları **istenmeyen veya yetkisiz erişime** açık hale getirebilir.
2. **Dinamik Analiz:**
- Uygulama tarafından oluşturulan dosyaların **izinlerini** doğrulayın. Özellikle herhangi bir dosyanın **genel okunur veya yazılabilir** olarak ayarlanıp ayarlanmadığını kontrol edin. Bu, cihazdaki herhangi bir uygulamanın bu dosyaları okumasına veya değiştirmesine izin verebileceği için önemli bir güvenlik riski oluşturur.

**External Storage**

SD Kart gibi **external storage** üzerindeki dosyalarla uğraşırken bazı önlemler alınmalıdır:

1. **Erişilebilirlik**:
- External storage üzerindeki dosyalar **genel olarak okunabilir ve yazılabilir**dir. Yani herhangi bir uygulama veya kullanıcı bu dosyalara erişebilir.
2. **Güvenlik Endişeleri**:
- Kolay erişim nedeniyle, hassas bilgileri external storage üzerinde saklamamak önerilir.
- External storage çıkarılabilir veya herhangi bir uygulama tarafından erişilebilir, bu yüzden daha az güvenlidir.
3. **External Storage'dan Gelen Verilerin İşlenmesi**:
- External storage'dan alınan veriler üzerinde her zaman **girdi doğrulaması** yapın. Bu, verinin güvensiz bir kaynaktan geldiği düşünülerek önemlidir.
- External storage üzerinde dinamik yükleme için executable veya class dosyaları saklamak şiddetle önerilmez.
- Uygulamanız external storage'dan executable dosyaları almak zorundaysa, bu dosyaların dinamik olarak yüklenmeden önce **imzalanmış ve kriptografik olarak doğrulanmış** olmasını sağlayın. Bu adım, uygulamanızın güvenlik bütünlüğü için hayati öneme sahiptir.

External storage şu dizinlerden **erişilebilir**: /storage/emulated/0 , /sdcard , /mnt/sdcard

> [!TIP]
> Android 4.4 (**API 17**) ile başlayarak, SD kartın bir dizin yapısı vardır ve bu yapı **bir uygulamanın yalnızca o uygulamaya özel dizine erişimini sınırlar**. Bu, kötü amaçlı uygulamaların başka bir uygulamanın dosyalarına okuma veya yazma erişimi kazanmasını önler.

**Açık metin olarak saklanan hassas veriler**

- **Shared preferences**: Android, her uygulamaya `/data/data/<packagename>/shared_prefs/` yolunda kolayca xml dosyaları kaydetme imkanı verir ve bazen bu klasörde açık metin halinde hassas bilgiler bulunabilir.
- **Databases**: Android, her uygulamaya `/data/data/<packagename>/databases/` yolunda sqlite veritabanları kaydetme imkanı verir ve bazen bu klasörde açık metin halinde hassas bilgiler bulunabilir.

### Broken TLS

**Accept All Certificates**

Bazı durumlarda geliştiriciler, örneğin hostname eşleşmesi sağlanmasa bile tüm sertifikaları kabul ederler; bunu aşağıdaki gibi kod satırlarıyla yapabilirler:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Kırık Kriptografi

**Zayıf Anahtar Yönetimi Süreçleri**

Bazı geliştiriciler hassas verileri local storage içinde saklayıp kod içinde hardcoded/tahmin edilebilir bir anahtarla şifreler. Bu yapılmamalıdır çünkü tersine mühendislik saldırganların gizli bilgileri çıkarmasına izin verebilir.

**Güvenli Olmayan ve/veya Kullanımdan Kalmış Algoritmaların Kullanımı**

Geliştiriciler yetkilendirme **kontrolleri** yapmak, verileri **saklamak** veya **göndermek** için **kullanımdan kalmış algoritmaları** kullanmamalıdır. Bu algoritmalardan bazıları: RC4, MD4, MD5, SHA1... Örneğin parolaları saklamak için **hash**'ler kullanılıyorsa, salt ile birlikte brute-force'a karşı **dirençli** hash'ler kullanılmalıdır.

### Diğer kontroller

- APK'yı **obfuscate** ederek tersine mühendislik işini zorlaştırmanız önerilir.
- Eğer uygulama hassassa (ör. banka uygulamaları), cihazın rootlu olup olmadığını kontrol eden kendi **kontrollerini gerçekleştirmeli** ve buna göre davranmalıdır.
- Eğer uygulama hassassa (ör. banka uygulamaları), bir **emulator** kullanılıp kullanılmadığını kontrol etmelidir.
- Eğer uygulama hassassa (ör. banka uygulamaları), çalıştırmadan önce kendi bütünlüğünü **kontrol etmeli**; böylece değiştirilip değiştirilmediğini anlayabilir.
- APK'nın hangi compiler/packer/obfuscator ile oluşturulduğunu kontrol etmek için [**APKiD**](https://github.com/rednaga/APKiD) kullanın

### React Native Application

React uygulamalarının javascript kodlarına nasıl kolayca erişileceğini öğrenmek için aşağıdaki sayfayı okuyun:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Xamarin uygulamalarının C# kodlarına nasıl kolayca erişileceğini öğrenmek için aşağıdaki sayfayı okuyun:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

The tool [**mariana-trench**](https://github.com/facebook/mariana-trench) is capable of finding **vulnerabilities** by **scanning** the **code** of the application. This tool contains a series of **known sources** (that indicates to the tool the **places** where the **input** is **controlled by the user**), **sinks** (which indicates to the tool **dangerous** **places** where malicious user input could cause damages) and **rules**. These rules indicates the **combination** of **sources-sinks** that indicates a vulnerability.

With this knowledge, **mariana-trench will review the code and find possible vulnerabilities on it**.

### Secrets leaked

An application may contain secrets (API keys, passwords, hidden urls, subdomains...) inside of it that you might be able to discover. You could us a tool such as [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Diğer ilginç fonksiyonlar

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)
- In-memory native code execution via JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Diğer hileler**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dinamik Analiz

> Öncelikle, uygulamayı ve gerekli tüm ortamı (özellikle Burp CA cert, Drozer ve Frida) kurabileceğiniz bir ortama ihtiyacınız var. Bu nedenle, rootlu bir cihaz (emüle veya gerçek) şiddetle tavsiye edilir.

### Çevrimiçi Dinamik analiz

You can create a **free account** in: [https://appetize.io/](https://appetize.io). This platform allows you to **upload** and **execute** APKs, so it is useful to see how an apk is behaving.

You can even **see the logs of your application** in the web and connect through **adb**.

![](<../../images/image (831).png>)

Thanks to the ADB connection you can use **Drozer** and **Frida** inside the emulators.

### Yerel Dinamik Analiz

#### Bir emülatör kullanma

- [**Android Studio**](https://developer.android.com/studio) (x86 ve arm cihazlar oluşturabilirsiniz ve according to [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**güncel x86** sürümleri **ARM kütüphanelerini** yavaş bir arm emülatörüne ihtiyaç duymadan destekler).
- Learn to set it up in this page:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, you need to create an account. _It's recommend to **download** the version **WITH**_ _**VirtualBox** to avoid potential errors._)
- [**Nox**](https://es.bignox.com) (Ücretsiz, ancak Frida veya Drozer'ı desteklemiyor).

> [!TIP]
> Yeni bir emülatör oluştururken herhangi bir platformda ekran ne kadar büyükse emülatör o kadar yavaş çalışacaktır. Mümkünse küçük ekranlar seçin.

To **install google services** (like AppStore) in Genymotion you need to click on the red marked button of the following image:

![](<../../images/image (277).png>)

Also, notice that in the **configuration of the Android VM in Genymotion** you can select **Bridge Network mode** (this will be useful if you will be connecting to the Android VM from a different VM with the tools).

#### Fiziksel bir cihaz kullanma

Hata ayıklama seçeneklerini etkinleştirmeniz gerekir ve mümkünse cihazı rootlamanız faydalı olacaktır:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Once you have installed the application, the first thing you should do is to try it and investigate what does it do, how does it work and get comfortable with it.\
> I will suggest to **perform this initial dynamic analysis using MobSF dynamic analysis + pidcat**, so we will be able to **learn how the application works** while MobSF **captures** a lot of **interesting** **data** you can review later on.

Magisk/Zygisk quick notes (recommended on Pixel devices)
- Patch boot.img with the Magisk app and flash via fastboot to get systemless root
- Enable Zygisk + DenyList for root hiding; consider LSPosed/Shamiko when stronger hiding is required
- Keep original boot.img to recover from OTA updates; re-patch after each OTA
- For screen mirroring, use scrcpy on the host



### Kasıt Olmayan Veri Sızıntısı

**Logging**

Geliştiriciler hata ayıklama bilgilerini halka açık şekilde ifşa etme konusunda dikkatli olmalıdır; çünkü bu hassas verilerin sızmasına yol açabilir. Uygulama loglarını izlemek ve hassas bilgileri tespit etmek/korumak için [**pidcat**](https://github.com/JakeWharton/pidcat) ve `adb logcat` önerilir. **Pidcat** kullanım kolaylığı ve okunabilirliği nedeniyle tercih edilir.

> [!WARNING]
> Android 4.0'dan daha yeni sürümlerde uygulamalar yalnızca kendi log'larına erişebilir. Bu nedenle uygulamalar diğer uygulamaların log'larına erişemez.\
> Yine de hassas bilgileri loglamamak önerilir.

**Copy/Paste Buffer Caching**

Android'in pano (clipboard) tabanlı altyapısı uygulamalara kopyala-yapıştır işlevselliği sağlar, ancak diğer uygulamaların panoya erişebilmesi riski yüzünden hassas verilerin açığa çıkmasına neden olabilir. Kredi kartı bilgileri gibi hassas alanlar için kopyala/yapıştır fonksiyonlarını devre dışı bırakmak önemlidir.

**Crash Logs**

Bir uygulama çöker ve log tutarsa, bu loglar saldırganlara yardımcı olabilir; özellikle uygulama tersine mühendislikle çözülemiyorsa. Bu riski azaltmak için çökme durumlarında log tutmaktan kaçının; eğer loglar ağ üzerinden gönderilecekse, güvenlik için SSL kanalı üzerinden gönderildiğinden emin olun.

As pentester, **try to take a look to these logs**.

**Analytics Data Sent To 3rd Parties**

Uygulamalar sıklıkla Google Adsense gibi servisleri entegre eder; geliştiricilerin hatalı uygulamaları nedeniyle bu servisler istemeden hassas verileri sızdırabilir. Potansiyel veri sızıntılarını tespit etmek için uygulamanın trafiğini intercept etmek ve üçüncü taraf servislere hassas bilgi gönderilip gönderilmediğini kontrol etmek önerilir.

### SQLite DBs

Çoğu uygulama bilgi saklamak için dahili SQLite veritabanları kullanır. Pentest sırasında oluşturulan veritabanlarına, tabloların ve sütunların isimlerine ve kaydedilen tüm verilere bakın; çünkü hassas bilgiler (bu bir vulnerability olur) bulabilirsiniz.\
Veritabanları genellikle `/data/data/the.package.name/databases` altında bulunur, örn. `/data/data/com.mwr.example.sieve/databases`

If the database is saving confidential information and is **encrypted b**ut you can **find** the **password** inside the application it's still a **vulnerability**.

Tabloları `.tables` ile listeleyin ve tabloların sütunlarını `.schema <table_name>` ile öğrenin.

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer is s useful tool to **exploit exported activities, exported services and Content Providers** as you will learn in the following sections.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Also remember that the code of an activity starts in the **`onCreate`** method.

**Authorisation bypass**

When an Activity is exported you can invoke its screen from an external app. Therefore, if an activity with **sensitive information** is **exported** you could **bypass** the **authentication** mechanisms **to access it.**

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

You can also start an exported activity from adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> Unutmayın ki an authorisation bypass her zaman bir vulnerability değildir; bunun nasıl çalıştığına ve hangi bilgilerin açığa çıktığına bağlıdır.

**Sensitive information leakage**

**Activities can also return results**. Eğer exported ve korunmasız bir activity içerisinde **`setResult`** metodunu çağıran ve hassas bilgi döndüren bir durum bulursanız, sensitive information leakage vardır.

#### Tapjacking

Eğer Tapjacking önlenmezse, exported activity'yi kötüye kullanarak kullanıcının beklenmeyen eylemleri gerçekleştirmesini sağlayabilirsiniz. For more info about [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers temelde **veri paylaşımı** için kullanılır. Eğer bir uygulamanın kullanılabilir content providers'ı varsa, bunlardan **hassas veri çıkarma** şansınız olabilir. Ayrıca potansiyel **SQL injections** ve **Path Traversals**'ı test etmek ilginçtir çünkü bunlar zafiyetli olabilir.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Bir Service'in eylemlerinin `onStartCommand` metodunda başladığını unutmayın.

Service temelde **veri alabilir**, **işleyebilir** ve (ya da etmeyebilir) bir yanıt **geri döndürebilir**. Bu nedenle, bir uygulama bazı servisleri export ediyorsa ne yaptığını anlamak için **kodu** kontrol etmeli ve gizli bilgileri çıkarmak, kimlik doğrulama önlemlerini atlatmak vb. için dinamik olarak test etmelisiniz.\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Bir Broadcast Receiver'ın eylemlerinin `onReceive` metodunda başladığını unutmayın.

Bir broadcast receiver belirli bir tür mesajı bekler. Alıcının mesajı nasıl işlediğine bağlı olarak zafiyetli olabilir.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

You can look for deep links manually, using tools like MobSF or scripts like [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Bildirilmiş bir **scheme**'i **adb** veya bir **browser** kullanarak **open** edebilirsiniz:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Paket adını **belirtmeyebileceğinizi** unutmayın; mobil cihaz, o bağlantıyı açacak uygulamayı otomatik olarak çağırır._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Code executed**

Uygulamada çalıştırılacak **kodu bulmak için**, deeplink tarafından çağrılan activity'ye gidin ve **`onNewIntent`** fonksiyonunu arayın.

![](<../../images/image (436) (1) (1) (1).png>)

**Sensitive info**

Her deep link bulduğunuzda, **URL parametreleriyle hassas veri (ör. parolalar) alınıp alınmadığını** kontrol edin; çünkü başka herhangi bir uygulama **deep link'i taklit edip bu verileri çalabilir!**

**Parameters in path**

Ayrıca **herhangi bir deep link'in URL path içinde parametre kullanıp kullanmadığını** kontrol etmelisiniz; örneğin: `https://api.example.com/v1/users/{username}`. Bu durumda path traversal zorlayarak şu gibi bir şey deneyebilirsiniz: `example://app/users?username=../../unwanted-endpoint%3fparam=value`.\
Doğru endpoint'leri uygulama içinde bulursanız, path'in bir kısmı domain adı olarak kullanılıyorsa **Open Redirect**, eğer kullanıcı bilgilerini CSRF token olmadan değiştirebiliyorsanız ve vuln endpoint doğru method'u kullanıyorsa **account takeover** ve benzeri başka zafiyetlere yol açabilirsiniz. Daha fazla bilgi için [buraya bakın](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

İlginç bir bug bounty raporu: https://hackerone.com/reports/855618 (links (_/.well-known/assetlinks.json_)).

### Transport Layer Inspection and Verification Failures

- Android uygulamaları **sertifikaları her zaman düzgün şekilde doğrulamıyor**. Bu uygulamaların self-signed sertifikaları kabul etmesi veya bazı durumlarda HTTP bağlantısına geri dönmesi yaygındır.
- **SSL/TLS handshake sırasında müzakereler bazen zayıf** olup, insecure cipher suite'ler kullanılıyor. Bu durum bağlantıyı man-in-the-middle (MITM) saldırılarına karşı savunmasız hale getirir ve saldırganların veriyi deşifre etmesine izin verebilir.
- Uygulamalar güvenli kanallarla kimlik doğrulaması yapıp sonra diğer işlemler için güvenli olmayan kanallar üzerinden iletişim kurduğunda özel bilgilerin sızdırılması riski vardır. Bu yaklaşım, session cookie veya kullanıcı bilgileri gibi hassas verileri kötü niyetli kişilerin ele geçirmesine karşı koruma sağlamaz.

#### Certificate Verification

Odak noktamız **sertifika doğrulama** olacak. Sunucu sertifikasının bütünlüğü doğrulanmalıdır; bu güvenliği artırmak için kritik önemdedir. Güvensiz TLS konfigürasyonları ve hassas verilerin şifrelenmemiş kanallar üzerinden iletilmesi ciddi riskler doğurabilir. Sunucu sertifikalarını doğrulama ve zafiyetleri düzeltme adımları için [**bu kaynak**](https://manifestsecurity.com/android-application-security-part-10/) kapsamlı rehberlik sağlar.

#### SSL Pinning

SSL Pinning, uygulamanın sunucu sertifikasını uygulama içinde saklanan bilinen bir kopya ile doğruladığı bir güvenlik önlemidir. Bu yöntem MITM saldırılarını önlemek için önemlidir. Hassas bilgi işleyen uygulamalar için SSL Pinning uygulanması şiddetle tavsiye edilir.

#### Traffic Inspection

HTTP trafiğini incelemek için proxy aracının sertifikasını (ör. Burp) **kurmanız gerekir**. Bu sertifikayı kurmazsanız şifrelenmiş trafik proxy üzerinden görünmeyebilir. Özel bir CA sertifikası kurma rehberi için [**buraya tıklayın**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

API Level 24 ve üzerini hedefleyen uygulamaların proxy'nin CA sertifikasını kabul etmesi için Network Security Config üzerinde değişiklik yapması gerekir. Şifrelenmiş trafiği incelemek için Network Security Config'in nasıl değiştirileceğiyle ilgili talimatlar için [**bu eğitime bakın**](make-apk-accept-ca-certificate.md).

Eğer **Flutter** kullanılıyorsa [**bu sayfadaki**](flutter.md) talimatları izlemeniz gerekir. Sadece sertifikayı store'a eklemek yeterli olmaz çünkü Flutter'ın kendi geçerli CA listesi vardır.

#### Static detection of SSL/TLS pinning

Runtime bypass'lara başlamadan önce, pinning'in APK içinde nerede uygulandığını hızlıca haritalayın. Statik keşif, hook/patch planlamanıza ve doğru kod yollarına odaklanmanıza yardımcı olur.

Tool: SSLPinDetect
- APK'yı Smali'ye (apktool ile) decompile eden ve SSL/TLS pinning implementasyonlarının küratörlü regex pattern'lerini tarayan açık kaynaklı statik-analiz aracı.
- Her eşleşme için tam dosya yolu, satır numarası ve kod snippet'i raporlar.
- Yaygın framework'leri ve custom kod yollarını kapsar: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, ve Network Security Config XML pins.

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Kullanım
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Örnek desen kuralları (JSON)
Özelleştirilmiş/özel pinning stillerini tespit etmek için signatures kullanın veya genişletin. Kendi JSON'unuzu yükleyebilir ve büyük ölçekte tarama yapabilirsiniz.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notlar ve ipuçları
- Büyük uygulamalarda multi-threading ve memory-mapped I/O ile hızlı tarama; önceden derlenmiş regex, overhead ve false positives'i azaltır.
- Desen koleksiyonu: https://github.com/aancw/smali-sslpin-patterns
- Sıradaki öncelikli tespit hedefleri:
- OkHttp: CertificatePinner kullanımı, setCertificatePinner, okhttp3/okhttp package references
- Özel TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted override'ları
- Özel SSL context'leri: SSLContext.getInstance + SSLContext.init ile custom managers
- Deklaratif pin'ler res/xml içindeki network security config ve manifest referansları
- Eşleşen konumları Frida hooks, statik yamalar veya konfigürasyon incelemeleri planlamak için kullanın, dinamik testten önce.



#### SSL Pinning'i Aşma

SSL Pinning uygulandığında, HTTPS trafiğini incelemek için bunu atlatmak gerekebilir. Bu amaçla çeşitli yöntemler mevcuttur:

- Otomatik olarak **apk**'yı **değiştirip** SSLPinning'i atlatmak için [**apk-mitm**](https://github.com/shroudedcode/apk-mitm) kullanın. Bu seçeneğin en büyük artısı, SSL Pinning'i atlatmak için root gerekmemesi; ancak uygulamayı silip yeni olanı yeniden yüklemeniz gerekir ve bu her zaman işe yaramayabilir.
- Bu korumayı atlatmak için **Frida** (aşağıda tartışılıyor) kullanabilirsiniz. Burp+Frida+Genymotion kullanımı için rehber: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- [**objection**](frida-tutorial/objection-tutorial.md) kullanarak SSL Pinning'i **otomatik** olarak atlamayı da deneyebilirsiniz:**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- **MobSF dynamic analysis** kullanarak SSL Pinning'i **otomatik** olarak atlamayı da deneyebilirsiniz (aşağıda açıklanıyor)
- Hâlâ yakalamadığınızı düşündüğünüz trafik varsa trafiği iptables kullanarak burp'a yönlendirmeyi deneyebilirsiniz. Bu blogu okuyun: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Yaygın Web Zayıflıklarını Arama

Uygulama içinde yaygın web zayıflıklarını aramak da önemlidir. Bu zayıflıkları tespit etme ve hafifletme hakkında ayrıntılı bilgi bu özetin kapsamı dışında olup başka yerlerde geniş şekilde ele alınmaktadır.

### Frida

[Frida](https://www.frida.re) geliştiriciler, reverse-engineerler ve güvenlik araştırmacıları için dinamik enstrümantasyon araç takımıdır.\
**Çalışan uygulamaya erişip çalışma zamanında metotları hooklayarak davranışı değiştirebilir, değerleri değiştirebilir, değerleri çıkarabilir, farklı kodlar çalıştırabilirsiniz...**\
Android uygulamalarını pentest etmek istiyorsanız Frida'yı nasıl kullanacağınızı bilmelisiniz.

- Frida'yı nasıl kullanacağınızı öğrenin: [**Frida tutorial**](frida-tutorial/index.html)
- Frida ile eylemler için bazı "GUI"ler: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection, Frida kullanımını otomatikleştirmek için harikadır: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Bazı Awesome Frida script'lerini burada bulabilirsiniz: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Frida yükleyerek anti-debugging / anti-frida mekanizmalarını atlatmayı deneyin, örneğin şu gösterimde: [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (araç [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Bellek dökümü - Fridump**

Uygulamanın parolalar veya mnemonikler gibi bellekte saklamaması gereken hassas bilgileri bellekte depolayıp depolamadığını kontrol edin.

Using [**Fridump3**](https://github.com/rootbsd/fridump3) you can dump the memory of the app with:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Bu, belleği ./dump klasörüne dump edecek ve orada şu gibi bir şeyle grep yapabilirsiniz:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Keystore'daki hassas veriler**

Android'de Keystore hassas verileri saklamak için en iyi yerdir; ancak yeterli ayrıcalıklara sahip olunursa yine de **erişmek mümkün**.

Uygulamalar burada genellikle **açık metin hâlinde hassas veriler** saklama eğiliminde olduğundan, pentests bunu root user olarak kontrol etmelidir; aksi halde cihazın fiziksel erişimine sahip birisi bu verileri çalabilir.

Bir uygulama veriyi Keystore'a saklamış olsa bile, verilerin şifrelenmiş olması gerekir.

Keystore içindeki verilere erişmek için şu Frida script'ini kullanabilirsiniz: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Parmak İzi/Biyometrik Bypass**

Aşağıdaki Frida scriptini kullanarak, Android uygulamalarının belirli hassas alanları korumak için gerçekleştirdiği **parmak izi doğrulamasını bypass etmek** mümkün olabilir:
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Arka Plan Görüntüleri**

Bir uygulamayı arka plana aldığınızda, Android uygulamanın bir **anlık görüntüsünü** saklar; böylece uygulama ön plana geri getirildiğinde uygulamanın kendisinden önce bu görsel yüklenir ve uygulama daha hızlı yüklenmiş gibi görünür.

Ancak, bu **anlık görüntü** hassas bilgi içeriyorsa, anlık görüntüye erişimi olan biri bu bilgileri **çalabilir** (erişmek için root gerektiğini unutmayın).

Anlık görüntüler genellikle şu konumda saklanır: **`/data/system_ce/0/snapshots`**

Android, `FLAG_SECURE` layout parametresini ayarlayarak **ekran görüntüsü alınmasını engelleme** yöntemi sağlar. Bu flag kullanıldığında, pencere içeriği güvenli olarak kabul edilir; böylece ekran görüntülerinde görünmesi veya güvenli olmayan ekranlarda görüntülenmesi engellenir.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Bu araç dinamik analiz sırasında farklı araçları yönetmenize yardımcı olabilir: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Geliştiriciler genellikle bu Intents'leri işleyen ve `startActivity(...)` veya `sendBroadcast(...)` gibi metodlara ileten activities, services ve broadcast receivers gibi proxy bileşenler oluşturur; bu durum riskli olabilir.

Tehlike, saldırganların bu Intents'leri yanlış yönlendirerek export edilmeyen uygulama bileşenlerini tetiklemesine veya hassas content providers'a erişmesine izin vermekte yatar. Önemli bir örnek, `WebView` bileşeninin URL'leri `Intent.parseUri(...)` ile `Intent` nesnelerine dönüştürmesi ve ardından bunları çalıştırmasıdır; bu durum potansiyel olarak kötü niyetli Intent enjeksiyonlarına yol açabilir.

### Essential Takeaways

- **Intent Injection** web'deki Open Redirect sorununa benzer.
- Sömürüler, `Intent` nesnelerinin extras olarak geçirilmesini içerir; bunlar yönlendirilerek güvensiz işlemler çalıştırılabilir.
- Bu, export edilmeyen bileşenleri ve content providers'ı saldırganlara açabilir.
- `WebView`'in URL'den `Intent` dönüşümü istenmeyen eylemleri kolaylaştırabilir.

### Android Client Side Injections and others

Muhtemelen bu tür zafiyetleri Web tarafında biliyorsunuzdur. Bir Android uygulamasında bu zafiyetlere özellikle dikkat etmelisiniz:

- **SQL Injection:** Dinamik sorgularla veya Content-Providers ile çalışırken parametreli sorgular kullandığınızdan emin olun.
- **JavaScript Injection (XSS):** Herhangi bir WebView için JavaScript ve Plugin desteğinin devre dışı olduğundan emin olun (varsayılan olarak devre dışıdır). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebView'ların dosya sistemine erişiminin devre dışı olması gerekir (varsayılan olarak etkin) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: Birçok durumda, android uygulaması oturumu sonlandırdığında cookie iptal edilmez veya diske kaydedilmiş olabilir
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Static analysis**

![](<../../images/image (866).png>)

**Vulnerability assessment of the application** web tabanlı hoş bir frontend kullanılarak yapılır. Dinamik analiz de gerçekleştirebilirsiniz (ancak ortamı hazırlamanız gerekir).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Assisted Dynamic analysis with MobSF

**MobSF** can also be very helpful for **dynamic analysis** in **Android**, but in that case you will need to install MobSF and **genymotion** in your host (a VM or Docker won't work). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
The **MobSF dynamic analyser** can:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). All of this is done automatically except for the screenshots, you need to press when you want a screenshot or you need to press "**Exported Activity Tester**" to obtain screenshots of all the exported activities.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: It will print all the loaded classes
- **Capture Strings**: It will print all the capture strings while using the application (super noisy)
- **Capture String Comparisons**: Could be very useful. It will **show the 2 strings being compared** and if the result was True or False.
- **Enumerate Class Methods**: Put the class name (like "java.io.File") and it will print all the methods of the class.
- **Search Class Pattern**: Search classes by pattern
- **Trace Class Methods**: **Trace** a **whole class** (see inputs and outputs of all methods of th class). Remember that by default MobSF traces several interesting Android Api methods.

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf also brings you a shell with some **adb** commands, **MobSF commands**, and common **shell** **commands** at the bottom of the dynamic analysis page. Some interesting commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP araçları**

When http traffic is capture you can see an ugly view of the captured traffic on "**HTTP(S) Traffic**" bottom or a nicer view in "**Start HTTPTools**" green bottom. From the second option, you can **send** the **captured requests** to **proxies** like Burp or Owasp ZAP.\
To do so, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> press "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

MobSF ile dinamik analizini bitirdikten sonra "**Start Web API Fuzzer**"a basarak **fuzz http requests** yapabilir ve zafiyet arayabilirsiniz.

> [!TIP]
> MobSF ile dinamik analiz yaptıktan sonra proxy ayarları yanlış yapılandırılmış olabilir ve GUI'den düzeltemeyebilirsiniz. Proxy ayarlarını şu komutla düzeltebilirsiniz:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Inspeckage ile Yardımlı Dinamik Analiz

Aracı [**Inspeckage**](https://github.com/ac-pm/Inspeckage) adresinden edinebilirsiniz.\
Bu araç, **dinamik analiz** yaparken uygulamada **neler olduğunu** size bildirmek için bazı **Hooks** kullanır.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Bu, GUI ile **statik analiz yapmak için harika bir araçtır**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Bu araç, hem **güvenlikle ilgili Android uygulama zafiyetlerini** hem de **kaynak kodunda** veya **paketlenmiş APK'lerde** aramak için tasarlanmıştır. Araç ayrıca bulunan bazı zafiyetleri (Exposed activities, intents, tapjacking...) istismar etmek için **"Proof-of-Concept" deploy edilebilen bir APK** ve **ADB commands** oluşturabilme yeteneğine sahiptir. Drozer'da olduğu gibi, test cihazını rootlamaya gerek yoktur.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Kolay referans için tüm çıkarılmış dosyaları gösterir
- APK dosyalarını otomatik olarak Java ve Smali formatına decompile eder
- AndroidManifest.xml'i yaygın zafiyetler ve davranışlar açısından analiz eder
- Yaygın zafiyetler ve davranışlar için statik kaynak kodu analizi yapar
- Cihaz bilgileri
- ve daha fazlası
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER, Windows, MacOS X ve Linux'ta kullanılabilen bir komut satırı uygulamasıdır; _.apk_ dosyalarını zayıflık aramak için analiz eder. Bunu APK'leri açıp bir dizi kural uygulayarak yapar.

Tüm kurallar `rules.json` dosyasında toplanmıştır ve her şirket veya test uzmanı ihtiyaçlarına göre kendi kurallarını oluşturabilir.

En son ikili dosyaları [download page](https://superanalyzer.rocks/download.html) adresinden indirin.
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn, mobil uygulamalarda [statik kod analizi](https://en.wikipedia.org/wiki/Static_program_analysis) yapan geliştiricilere, bugbounty avcılarına ve etik hackerlara yardımcı olan bir **crossplatform** araçtır.

Kavram şu: mobil uygulama dosyanızı (.apk veya .ipa dosyası) StaCoAn uygulamasına sürükleyip bırakırsınız ve araç sizin için görsel ve taşınabilir bir rapor üretir. Ayarları ve wordlists'leri değiştirerek özelleştirilmiş bir deneyim elde edebilirsiniz.

İndir[ en son sürüm](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework, geliştiriciler ve hackers için Android uygulamalarındaki potansiyel güvenlik açıklarını bulmaya yardımcı olan bir analiz sistemidir.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn**'ın temel amacı, bir Android uygulaması tarafından geliştirilebilecek potansiyel zararlı davranışları tespit etmek ve kullanıcıyı uyarmaktır.

Tespit, uygulamanın Dalvik bytecode'u (Smali olarak temsil edilen) üzerinde [`androguard`](https://github.com/androguard/androguard) kütüphanesi ile yapılan **static analysis** ile gerçekleştirilir.

Bu araç, **"kötü" uygulamaların ortak davranışlarını** arar; örneğin: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA**, Mobil Uygulama Tersine Mühendislik ve Analiz Çerçevesidir. Yaygın olarak kullanılan mobil uygulama tersine mühendislik ve analiz araçlarını bir araya getiren bir araçtır; OWASP mobil güvenlik tehditlerine karşı mobil uygulamaları test etmeye yardımcı olur. Amacı, bu görevi mobil uygulama geliştiricileri ve güvenlik profesyonelleri için daha kolay ve daha kullanıcı dostu hale getirmektir.

Şunları yapabilir:

- Farklı araçlar kullanarak Java ve Smali kodunu çıkarmak
- APK'leri şu araçlarla analiz etmek: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- APK içinden regexp'ler kullanarak özel bilgileri çıkarmak.
- Manifest'i analiz etmek.
- Bulunan domainleri şu araçlarla analiz etmek: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) ve [whatweb](https://github.com/urbanadventurer/WhatWeb)
- APK'yi [apk-deguard.com](http://www.apk-deguard.com) üzerinden deobfuscate etmek

### Koodous

malware tespit etmek için kullanışlı: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Not: Kodu obfuscate etmek için kullandığınız servis ve yapılandırmaya bağlı olarak, secret'lar obfuscated şekilde veya obfuscated olmadan kalabilir.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

Wikipedia'dan: **ProGuard** açık kaynaklı, komut satırı tabanlı bir araçtır; Java kodunu küçültür, optimize eder ve obfuscate eder. Bytecode'u optimize edebilme ve kullanılmayan talimatları tespit edip kaldırma yeteneğine sahiptir. ProGuard özgür yazılımdır ve GNU General Public License, version 2 altında dağıtılır.

ProGuard, Android SDK'nin bir parçası olarak dağıtılır ve uygulama release modunda derlenirken çalışır.

### [DexGuard](https://www.guardsquare.com/dexguard)

APK'yi deobfuscate etmek için adım adım bir kılavuz bulabilirsiniz: [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(o kılavuzdan) En son kontrol ettiğimizde, Dexguard'ın çalışma modu şu şekildeydi:

- bir kaynağı InputStream olarak yüklemek;
- sonucu şifreyi çözmek için FilterInputStream'ten türeyen bir sınıfa vermek;
- tersine mühendislik yapan kişinin birkaç dakikasını boşa harcamak için bazı gereksiz obfuscation işlemleri yapmak;
- çözülmüş sonucu bir DEX dosyası almak için ZipInputStream'e vermek;
- son olarak `loadDex` metodunu kullanarak ortaya çıkan DEX'i bir Resource olarak yüklemek.

### [DeGuard](http://apk-deguard.com)

**DeGuard, Android obfuscation araçları tarafından yapılan obfuscation sürecini tersine çevirir. Bu, kod incelemesi ve kütüphane tahmini dahil olmak üzere birçok güvenlik analizine olanak sağlar.**

Obfuskate edilmiş bir APK'yi platformlarına yükleyebilirsiniz.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

Bu, android uygulamalardaki potansiyel güvenlik açıklarını bulmak ve android uygulama kodunu deobfuscate etmek için kullanılan bir LLM aracıdır. Google'ın Gemini public API'sini kullanır.

### [Simplify](https://github.com/CalebFenton/simplify)

Genel amaçlı bir android deobfuscator'dır. Simplify, bir uygulamayı neredeyse çalıştırarak davranışını anlamaya çalışır ve ardından kodu optimize etmeye çalışır; böylece davranış tamamen aynı kalır fakat insan için anlaşılması kolaylaşır. Her optimizasyon türü basit ve genel olduğu için, kullanılan obfuscation türü ne olursa olsun işlem etkili olur.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD size bir APK'nın nasıl yapıldığı hakkında bilgi verir. Birçok compiler, packer, obfuscator ve diğer tuhaf şeyleri tespit eder. Android için [_PEiD_](https://www.aldeid.com/wiki/PEiD) gibidir.

### Manual

[Bu öğreticiyi okuyarak **how to reverse custom obfuscation** ile ilgili bazı hileleri öğrenin](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b, ubuntu-mate tabanlı bir Android security virtual machine'dir; tersine mühendislik ve malware analysis için farklı güvenlik meraklıları ve araştırmacıların en son framework, tutorial ve lab koleksiyonlarını içerir.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Harika bir kaynak listesi
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android için hızlı kurs
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
