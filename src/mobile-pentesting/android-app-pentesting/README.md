# Android-Anwendungen Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Grundlagen von Android-Anwendungen

Es wird dringend empfohlen, diese Seite zuerst zu lesen, um die **wichtigsten Aspekte der Android-Sicherheit und die gefährlichsten Komponenten einer Android-Anwendung** kennenzulernen:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Dies ist das Hauptwerkzeug, das Sie benötigen, um ein Android-Gerät (emuliert oder physisch) zu verbinden.\
**ADB** ermöglicht die Steuerung von Geräten entweder über **USB** oder **Network** von einem Computer aus. Dieses Tool bietet das **Kopieren** von Dateien in beide Richtungen, die **Installation** und **Deinstallation** von Apps, die **Ausführung** von Shell-Befehlen, die **Sicherung** von Daten, das **Auslesen** von Logs, sowie weitere Funktionen.

Siehe die folgende Liste der [**ADB Commands**](adb-commands.md), um zu lernen, wie man adb verwendet.

## Smali

Manchmal ist es interessant, den **Anwendungscode zu verändern**, um auf **versteckte Informationen** zuzugreifen (z. B. stark obfuskierte Passwörter oder flags). Dann kann es sinnvoll sein, die APK zu dekompilieren, den Code zu verändern und sie wieder zu kompilieren.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Dies kann sehr nützlich sein als **Alternative für verschiedene Tests während der dynamischen Analyse**, die vorgestellt werden. Behalte diese Möglichkeit also **stets im Hinterkopf**.

## Other interesting tricks

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [Android IME / InputMethodService Abuse (Malicious Keyboards)](inputmethodservice-ime-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- APK vom Gerät extrahieren:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Alle Splits und Base-APKs mit [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Android Enterprise & Work Profile Attacks

{{#ref}}
android-enterprise-work-profile-bypass.md
{{#endref}}

## Case Studies & Vulnerabilities


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}


{{#ref}}
../../binary-exploitation/linux-kernel-exploitation/arm64-static-linear-map-kaslr-bypass.md
{{#endref}}

## Static Analysis

Zuerst solltest du bei der Analyse einer APK den Java-Code mit einem Decompiler ansehen.\
Bitte, [**lies hier, um Informationen über verschiedene verfügbare Decompiler zu finden**](apk-decompilers.md).

### Looking for interesting Info

Schon ein Blick in die **strings** der APK kann Hinweise auf **Passwörter**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **API keys**, **Verschlüsselung**, **bluetooth uuids**, **Tokens** und sonstige interessante Informationen liefern... suche sogar nach Code-Ausführungs-**backdoors** oder Authentifizierungs-Backdoors (hardcodierte Admin-Zugangsdaten in der App).

**Firebase**

Achte besonders auf **Firebase URLs** und prüfe, ob diese schlecht konfiguriert sind. [Mehr Informationen darüber, was Firebase ist und wie man es ausnutzen kann, findest du hier.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Basic understanding of the application - Manifest.xml, strings.xml

Die **Untersuchung der _Manifest.xml_ und der **_strings.xml_** einer Anwendung kann potenzielle Sicherheitslücken aufdecken**. Diese Dateien können mit Decompilern eingesehen oder durch Umbenennen der APK-Endung in .zip und anschließendes Entpacken extrahiert werden.

**Vulnerabilities** aus der **Manifest.xml** können unter anderem sein:

- **Debuggable Applications**: Anwendungen, die im _Manifest.xml_ als debuggable (`debuggable="true"`) gesetzt sind, stellen ein Risiko dar, da sie Verbindungen erlauben, die zur Ausnutzung führen können. Für ein besseres Verständnis, wie man debuggable Applications ausnutzt, siehe ein Tutorial zum Finden und Ausnutzen von debuggable Applications auf einem Gerät.
- **Backup Settings**: Das Attribut `android:allowBackup="false"` sollte explizit für Anwendungen gesetzt werden, die mit sensiblen Informationen umgehen, um unautorisierte Daten-Backups via adb zu verhindern, besonders wenn USB-Debugging aktiviert ist.
- **Network Security**: Eigene network security Konfigurationen (`android:networkSecurityConfig="@xml/network_security_config"`) in _res/xml/_ können Details wie Certificate Pins und HTTP-Traffic-Einstellungen spezifizieren. Ein Beispiel ist das Zulassen von HTTP-Traffic für bestimmte Domains.
- **Exported Activities and Services**: Das Identifizieren exportierter Activities und Services im Manifest kann Komponenten aufzeigen, die missbraucht werden könnten. Weitere Analyse während dynamischer Tests kann offenbaren, wie diese Komponenten ausgenutzt werden können.
- **Content Providers and FileProviders**: Offen zugängliche Content Providers könnten unautorisierte Zugriffe oder Modifikationen von Daten erlauben. Die Konfiguration von FileProviders sollte ebenfalls überprüft werden.
- **Broadcast Receivers and URL Schemes**: Diese Komponenten können für Exploits genutzt werden, wobei besonderes Augenmerk darauf gelegt werden sollte, wie URL-Schemes für Input-Schwachstellen gehandhabt werden.
- **SDK Versions**: Die Attribute `minSdkVersion`, `targetSDKVersion` und `maxSdkVersion` geben an, welche Android-Versionen unterstützt werden, und machen deutlich, wie wichtig es ist, keine veralteten, verwundbaren Android-Versionen zu unterstützen.

Aus der **strings.xml** können sensible Informationen wie API-Keys, Custom Schemas und andere Entwicklerhinweise entdeckt werden, was die Notwendigkeit einer sorgfältigen Überprüfung dieser Ressourcen unterstreicht.

### Tapjacking

Tapjacking ist ein Angriff, bei dem eine **malicious** **application** gestartet wird und sich **über einer Opfer-Anwendung positioniert**. Sobald sie die Opfer-App sichtbar verdeckt, ist die Benutzeroberfläche so gestaltet, dass der Benutzer getäuscht wird, mit ihr zu interagieren, während die Interaktion an die Opfer-App weitergereicht wird.\
Effektiv wird der Benutzer **darüber geblendet, dass er tatsächlich Aktionen in der Opfer-App ausführt**.

Weitere Informationen findest du in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Eine **activity** mit dem **`launchMode`** auf **`singleTask`** gesetzt, ohne eine definierte `taskAffinity`, ist anfällig für Task Hijacking. Das bedeutet, dass eine **application** installiert werden kann, die, wenn sie vor der echten Anwendung gestartet wird, **die Task der echten Anwendung hijacken** könnte (so dass der Benutzer mit der **malicious application interagiert und denkt, er benutze die echte**).

Mehr Infos in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Insecure data storage

**Internal Storage**

In Android sind Dateien, die im **internal** storage **gespeichert** werden, so konzipiert, dass sie ausschließlich von der **app**, die sie **erstellt** hat, **zugänglich** sind. Diese Sicherheitsmaßnahme wird vom Android-Betriebssystem durchgesetzt und ist für die meisten Anwendungen in der Regel ausreichend. Entwickler verwenden jedoch manchmal Modi wie `MODE_WORLD_READABLE` und `MODE_WORLD_WRITABLE`, um Dateien zwischen verschiedenen Anwendungen **zu teilen**. Diese Modi **schränken den Zugriff auf diese Dateien jedoch nicht ein**, auch nicht gegenüber potenziell bösartigen Apps.

1. **Static Analysis:**
- **Stelle sicher**, dass die Nutzung von `MODE_WORLD_READABLE` und `MODE_WORLD_WRITABLE` **sorgfältig geprüft** wird. Diese Modi **können Dateien potenziell unbeabsichtigt oder unautorisiert zugänglich machen**.
2. **Dynamic Analysis:**
- **Überprüfe** die **Berechtigungen** von Dateien, die von der App erstellt wurden. Insbesondere **prüfe**, ob Dateien **weltweit lesbar oder beschreibbar** gesetzt sind. Dies kann ein erhebliches Sicherheitsrisiko darstellen, da es **jeder installierten Anwendung** auf dem Gerät, unabhängig von Herkunft oder Absicht, erlauben würde, diese Dateien **zu lesen oder zu ändern**.

**External Storage**

Beim Umgang mit Dateien auf **external storage**, wie SD-Karten, sollten folgende Vorsichtsmaßnahmen beachtet werden:

1. **Accessibility**:
- Dateien auf external storage sind **global les- und schreibbar**. Das heißt, jede Anwendung oder jeder Benutzer kann auf diese Dateien zugreifen.
2. **Security Concerns**:
- Aufgrund des einfachen Zugriffs wird empfohlen, **keine sensiblen Informationen** auf external storage zu speichern.
- External storage kann entfernt oder von jeder Anwendung ausgelesen werden, was es weniger sicher macht.
3. **Handling Data from External Storage**:
- Führe immer **Input-Validation** auf Daten aus, die von external storage geladen werden. Das ist wichtig, da die Daten aus einer untrusted Quelle stammen.
- Das Speichern von Executables oder Class-Files auf external storage zum dynamischen Laden wird dringend abgeraten.
- Falls deine Anwendung ausführbare Dateien von external storage laden muss, stelle sicher, dass diese Dateien **signiert und kryptografisch verifiziert** sind, bevor sie dynamisch geladen werden. Dieser Schritt ist entscheidend für die Sicherheit der Anwendung.

External storage kann in /storage/emulated/0 , /sdcard , /mnt/sdcard accessed werden

> [!TIP]
> Beginnend mit Android 4.4 (**API 17**) hat die SD-Karte eine Verzeichnisstruktur, die **den Zugriff einer App auf das speziell für diese App vorgesehene Verzeichnis beschränkt**. Dies verhindert, dass bösartige Anwendungen Lese- oder Schreibzugriff auf die Dateien einer anderen App erhalten.

**Sensitive data stored in clear-text**

- **Shared preferences**: Android erlaubt jeder Anwendung, XML-Dateien im Pfad /data/data/<packagename>/shared_prefs/ zu speichern, und manchmal lassen sich dort sensible Informationen im Klartext finden.
- **Databases**: Android erlaubt jeder Anwendung, sqlite-Datenbanken im Pfad /data/data/<packagename>/databases/ zu speichern, und manchmal lassen sich dort sensible Informationen im Klartext finden.

### Broken TLS

**Accept All Certificates**

Aus irgendeinem Grund akzeptieren Entwickler manchmal alle Zertifikate, selbst wenn z. B. der Hostname nicht übereinstimmt, mit Codezeilen wie der folgenden:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Eine gute Möglichkeit, dies zu testen, ist zu versuchen, den Traffic mit einem Proxy wie Burp abzufangen, ohne das Burp CA auf dem Gerät zu autorisieren. Außerdem kann man mit Burp ein Zertifikat für einen anderen Hostnamen erzeugen und verwenden.

### Fehlerhafte Kryptographie

**Schlechte Schlüsselverwaltungsprozesse**

Einige Entwickler speichern sensitive Daten im lokalen Speicher und verschlüsseln sie mit einem im Code hardcodierten/vorhersagbaren Schlüssel. Das sollte nicht gemacht werden, da ein gewisses reversing Angreifern erlauben könnte, vertrauliche Informationen zu extrahieren.

**Verwendung unsicherer und/oder veralteter Algorithmen**

Entwickler sollten **deprecated algorithms** nicht verwenden, um Authorisation **checks** durchzuführen, Daten zu **store** oder **send**. Einige dieser Algorithmen sind: RC4, MD4, MD5, SHA1... Wenn **hashes** beispielsweise verwendet werden, um Passwörter zu speichern, sollten brute-force-resistente Hashes mit Salt verwendet werden.

### Weitere Checks

- Es wird empfohlen, das APK zu obfuskieren, um Angreifern die Arbeit des Reverse-Engineerings zu erschweren.
- Wenn die App sensibel ist (wie Bank-Apps), sollte sie eigene Prüfungen durchführen, um zu prüfen, ob das Mobilgerät rooted ist, und entsprechend reagieren.
- Wenn die App sensibel ist (wie Bank-Apps), sollte sie prüfen, ob ein **emulator** verwendet wird.
- Wenn die App sensibel ist (wie Bank-Apps), sollte sie ihre eigene Integrität vor der Ausführung prüfen, um festzustellen, ob sie verändert wurde.
- Use [**APKiD**](https://github.com/rednaga/APKiD) um zu prüfen, welcher Compiler/Packer/Obfuscator zum Erstellen des APK verwendet wurde

### React Native Application

Lies die folgende Seite, um zu erfahren, wie man einfach auf den javascript-Code von React-Anwendungen zugreift:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Lies die folgende Seite, um zu erfahren, wie man einfach auf den C#-Code einer xamarin-Anwendung zugreift:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

Laut diesem [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) ist superpacked ein Meta-Algorithmus, der den Inhalt einer Anwendung in eine einzige Datei komprimiert. Der Blog beschreibt die Möglichkeit, eine App zu erstellen, die derartige Apps dekomprimiert... und einen schnelleren Weg, der darin besteht, **die Anwendung auszuführen und die dekomprimierten Dateien aus dem Dateisystem zu sammeln.**

### Automated Static Code Analysis

Das Tool [**mariana-trench**](https://github.com/facebook/mariana-trench) kann **vulnerabilities** finden, indem es den **code** der Anwendung **scannt**. Dieses Tool enthält eine Reihe von **known sources** (die dem Tool die **Stellen** anzeigen, an denen die **input** vom **user** kontrolliert wird), **sinks** (die dem Tool **gefährliche** **Stellen** anzeigen, an denen bösartige Benutzereingaben Schäden verursachen könnten) und **rules**. Diese Regeln geben die **Kombination** von **sources-sinks** an, die auf eine Schwachstelle hinweist.

Mit diesem Wissen wird **mariana-trench den Code überprüfen und mögliche Schwachstellen darin finden**.

### Secrets leaked

Eine Anwendung kann Secrets (API keys, Passwörter, versteckte urls, Subdomains...) enthalten, die du entdecken könntest. Du könntest ein Tool wie [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks) verwenden.

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Lies dies, um zu lernen **wie man native Funktionen reverse-engineert**](reversing-native-libraries.md)
- In-memory native code execution via JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamische Analyse

> Zuerst brauchst du eine Umgebung, in der du die Anwendung und die gesamte Umgebung (Burp CA cert, Drozer und Frida hauptsächlich) installieren kannst. Daher wird ein gerootetes Gerät (emuliert oder nicht) dringend empfohlen.

### Online Dynamische Analyse

Du kannst ein **kostenloses Konto** bei: [https://appetize.io/](https://appetize.io) erstellen. Diese Plattform erlaubt es dir, APKs **hochzuladen** und **auszuführen**, daher ist sie nützlich, um zu sehen, wie sich ein apk verhält.

Du kannst sogar **die Logs deiner Anwendung** im Web sehen und dich über **adb** verbinden.

![](<../../images/image (831).png>)

Dank der ADB-Verbindung kannst du **Drozer** und **Frida** innerhalb der Emulatoren verwenden.

### Lokale Dynamische Analyse

#### Verwendung eines Emulators

- [**Android Studio**](https://developer.android.com/studio) (Du kannst **x86** und **arm** Geräte erstellen, und laut [**diesem** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**unterstützen die aktuellen x86** Versionen **ARM libraries** ohne einen langsamen ARM-Emulator zu benötigen).
- Lerne, wie du es auf dieser Seite einrichtest:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, du musst ein Konto erstellen. _Es wird empfohlen, die Version **WITH**_ _**VirtualBox** herunterzuladen, um mögliche Fehler zu vermeiden._)
- [**Nox**](https://es.bignox.com) (Kostenlos, unterstützt jedoch Frida oder Drozer nicht).

> [!TIP]
> Wenn du auf einer Plattform einen neuen Emulator erstellst, bedenke, dass je größer der Bildschirm ist, desto langsamer der Emulator laufen wird. Wähle also nach Möglichkeit kleine Bildschirme aus.

Um **google services** (wie AppStore) in Genymotion zu installieren, musst du auf die rot markierte Schaltfläche des folgenden Bildes klicken:

![](<../../images/image (277).png>)

Beachte außerdem, dass du in der **Konfiguration der Android-VM in Genymotion** den **Bridge Network mode** auswählen kannst (dies ist nützlich, wenn du von einer anderen VM mit den Tools eine Verbindung zur Android-VM herstellen wirst).

#### Verwenden eines physischen Geräts

Du musst die **debugging**-Optionen aktivieren und es wäre gut, wenn du es **root**en kannst:

1. **Settings**.
2. (From Android 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Sobald du die Anwendung installiert hast, solltest du sie zuerst ausprobieren und untersuchen, was sie tut, wie sie funktioniert und dich damit vertraut machen.\
> Ich empfehle, diese erste dynamische Analyse mit MobSF dynamic analysis + pidcat durchzuführen, sodass wir **lernen, wie die Anwendung arbeitet**, während MobSF eine Menge **interessanter** **Daten** erfasst, die du später überprüfen kannst.

Magisk/Zygisk Kurzanmerkungen (empfohlen auf Pixel-Geräten)
- Patch das boot.img mit der Magisk-App und flashe es via fastboot, um systemless root zu erhalten
- Aktiviere Zygisk + DenyList zum Verstecken von Root; erwäge LSPosed/Shamiko, wenn stärkeres Verstecken erforderlich ist
- Behalte das originale boot.img, um nach OTA-Updates wiederherstellen zu können; repatche nach jedem OTA
- Für Screen-Mirroring verwende scrcpy auf dem Host

### Unbeabsichtigte Datenübertragung

**Logging**

Entwickler sollten vorsichtig sein, Debug-Informationen öffentlich preiszugeben, da dies zu sensiblen Datenleaks führen kann. Die Tools [**pidcat**](https://github.com/JakeWharton/pidcat) und `adb logcat` werden empfohlen, um Anwendungslogs zu überwachen und sensible Informationen zu identifizieren und zu schützen. **Pidcat** wird wegen seiner Einfachheit und Lesbarkeit bevorzugt.

> [!WARNING]
> Beachte, dass seit **Android-Versionen neuer als 4.0** **Anwendungen nur auf ihre eigenen Logs zugreifen können**. Anwendungen können also nicht auf die Logs anderer Apps zugreifen.\
> Trotzdem wird empfohlen, **keine sensiblen Informationen zu loggen**.

**Copy/Paste Buffer Caching**

Androids **clipboard-basiertes** Framework ermöglicht Copy-Paste-Funktionalität in Apps, birgt jedoch ein Risiko, da **andere Anwendungen** auf die Zwischenablage **access** haben können und dadurch sensible Daten exponiert werden könnten. Es ist wichtig, für sensible Bereiche einer Anwendung, wie Kreditkartendetails, die **copy/paste**-Funktionen zu **disable**, um das Offenlegen sensibler Daten zu verhindern.

**Crash Logs**

Wenn eine Anwendung **crasht** und **Logs speichert**, können diese Logs Angreifern helfen, besonders wenn die Anwendung nicht reverse-engineert werden kann. Zur Minderung dieses Risikos sollte man vermeiden, bei Abstürzen zu loggen, und wenn Logs über das Netzwerk gesendet werden müssen, stelle sicher, dass sie über einen SSL-Kanal übertragen werden.

Als pentester, **versuche dir diese Logs anzusehen**.

**Analytics Data Sent To 3rd Parties**

Anwendungen integrieren oft Dienste wie Google Adsense, die aufgrund fehlerhafter Implementierung durch Entwickler sensible Daten unbeabsichtigt preisgeben können. Um potenzielle Datenlecks zu identifizieren, empfiehlt es sich, den Datenverkehr der Anwendung abzufangen und zu prüfen, ob sensible Informationen an Drittanbieter gesendet werden.

### SQLite DBs

Die meisten Anwendungen verwenden **interne SQLite-Datenbanken**, um Informationen zu speichern. Während des Pentests solltest du dir die **Datenbanken** ansehen, die Namen der **Tables** und **Columns** sowie alle gespeicherten **Daten**, weil du dort **sensitive information** (die eine Schwachstelle darstellen würde) finden könntest.\
Datenbanken sollten sich unter `/data/data/the.package.name/databases` wie `/data/data/com.mwr.example.sieve/databases` befinden

Wenn die Datenbank vertrauliche Informationen speichert und verschlüsselt ist, du aber das **password** innerhalb der Anwendung finden kannst, ist das immer noch eine Sicherheitslücke.

Enumeriere die Tabellen mit `.tables` und liste die Spalten der Tabellen mit `.schema <table_name>` auf

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** ermöglicht es dir, die Rolle einer Android-App anzunehmen und mit anderen Apps zu interagieren. Es kann **alles tun, was eine installierte Anwendung tun kann**, wie die Nutzung von Androids Inter-Process Communication (IPC)-Mechanismus und die Interaktion mit dem zugrunde liegenden Betriebssystem. .\
Drozer ist ein nützliches Tool, um **exported activities, exported services und Content Providers zu exploit**en, wie du in den folgenden Abschnitten lernen wirst.

### Exploiting exported Activities

[**Lies dies, wenn du auffrischen möchtest, was eine Android Activity ist.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Erinnere dich außerdem, dass der Code einer Activity in der **`onCreate`**-Methode startet.

**Authorisierungsumgehung**

Wenn eine Activity exportiert ist, kannst du ihren Bildschirm von einer externen App aus aufrufen. Daher könntest du, wenn eine Activity mit **sensiblen Informationen** exportiert ist, die **Authentifizierungsmechanismen** umgehen, um darauf zuzugreifen.

[**Lerne, wie man exportierte Activities mit Drozer ausnutzt.**](drozer-tutorial/index.html#activities)

Du kannst auch eine exportierte Activity von adb starten:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**HINWEIS**: MobSF wird die Verwendung von _**singleTask/singleInstance**_ als `android:launchMode` in einer Activity als bösartig erkennen, aber aufgrund von [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750) scheint dies offenbar nur auf alten Versionen (API versions < 21) gefährlich zu sein.

> [!TIP]
> Beachte, dass ein Authorisation bypass nicht immer eine Sicherheitslücke ist — es hängt davon ab, wie der Bypass funktioniert und welche Informationen offengelegt werden.

**Austritt sensibler Informationen**

**Activities können auch Ergebnisse zurückgeben**. Wenn es dir gelingt, eine exportierte und ungeschützte Activity zu finden, die die Methode **`setResult`** aufruft und **sensible Informationen zurückgibt**, liegt ein Austritt sensibler Informationen vor.

#### Tapjacking

Wenn Tapjacking nicht verhindert wird, könntest du die exportierte Activity ausnutzen, um den **Benutzer unerwartete Aktionen ausführen zu lassen**. Für mehr Infos zu [**was Tapjacking ist, siehe den Link**](#tapjacking).

### Exploiting Content Providers - Zugriff auf und Manipulation sensibler Informationen

[**Lies das, wenn du auffrischen willst, was ein Content Provider ist.**](android-applications-basics.md#content-provider)\
Content providers werden im Wesentlichen verwendet, um **Daten zu teilen**. Wenn eine App Content providers bereitstellt, könntest du in der Lage sein, **sensible** Daten daraus **zu extrahieren**. Es ist auch sinnvoll, mögliche **SQL injections** und **Path Traversals** zu testen, da diese verwundbar sein könnten.

[**Lerne, wie man Content Providers mit Drozer ausnutzt.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Lies das, wenn du auffrischen willst, was ein Service ist.**](android-applications-basics.md#services)\
Denk daran, dass die Aktionen eines Service in der Methode `onStartCommand` beginnen.

Ein Service ist im Grunde etwas, das **Daten empfangen kann**, diese **verarbeitet** und (oder nicht) eine Antwort **zurückgibt**. Wenn eine Anwendung also Services exportiert, solltest du den **Code** prüfen, um zu verstehen, was er macht, und ihn **dynamisch** testen, um vertrauliche Informationen zu extrahieren, Authentifizierungsmaßnahmen zu umgehen...\
[**Lerne, wie man Services mit Drozer ausnutzt.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Lies das, wenn du auffrischen willst, was ein Broadcast Receiver ist.**](android-applications-basics.md#broadcast-receivers)\
Denk daran, dass die Aktionen eines Broadcast Receivers in der Methode `onReceive` beginnen.

Ein Broadcast Receiver wartet auf eine Art Nachricht. Je nachdem, wie der Receiver die Nachricht verarbeitet, könnte er verwundbar sein.\
[**Lerne, wie man Broadcast Receivers mit Drozer ausnutzt.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Du kannst manuell nach Deep Links suchen, mit Tools wie MobSF oder Skripten wie [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Du kannst ein deklariertes **scheme** mit **adb** oder einem **Browser** **öffnen**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Hinweis: Du kannst **den Paketnamen weglassen** und das Mobilgerät ruft automatisch die App auf, die diesen Link öffnen soll._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Ausgeführter Code**

Um den **Code zu finden, der in der App ausgeführt wird**, gehe zur Activity, die vom deep link aufgerufen wird, und suche die Funktion **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Sensible Informationen**

Jedes Mal, wenn du einen deep link findest, prüfe, dass er **keine sensiblen Daten (z. B. Passwörter) über URL-Parameter empfängt**, denn jede andere Anwendung könnte sich als deep link ausgeben und diese Daten stehlen!

**Parameter im Pfad**

Du **musst außerdem prüfen, ob ein deep link einen Parameter innerhalb des Pfads** der URL verwendet, z. B.: `https://api.example.com/v1/users/{username}`. In diesem Fall kannst du einen path traversal erzwingen, indem du auf etwas wie `example://app/users?username=../../unwanted-endpoint%3fparam=value` zugreifst.\
Beachte, dass du, wenn du die korrekten Endpunkte in der Anwendung findest, möglicherweise einen **Open Redirect** verursachen kannst (wenn ein Teil des Pfads als Domainname verwendet wird), eine **account takeover** (wenn du Benutzerdetails ohne CSRF-Token ändern kannst und der verwundbare Endpunkt die richtige Methode verwendet) und andere Schwachstellen. Mehr [Info dazu hier](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

Ein [interessanter bug bounty report](https://hackerone.com/reports/855618) über Links (_/.well-known/assetlinks.json_).

### Transportschicht-Inspektion und Verifikationsfehler

- **Zertifikate werden nicht immer richtig geprüft** von Android-Anwendungen. Es ist üblich, dass diese Anwendungen Warnungen übersehen und selbstsignierte Zertifikate akzeptieren oder in einigen Fällen wieder auf HTTP-Verbindungen zurückfallen.
- **Die Aushandlungen während des SSL/TLS-Handshakes sind manchmal schwach**, es werden unsichere Cipher-Suites verwendet. Diese Schwachstelle macht die Verbindung anfällig für man-in-the-middle (MITM)-Angriffe und ermöglicht Angreifern, die Daten zu entschlüsseln.
- **Leakage of private information** ist ein Risiko, wenn Anwendungen sich über sichere Kanäle authentifizieren, dann aber für andere Transaktionen über unsichere Kanäle kommunizieren. Dieser Ansatz schützt sensible Daten, wie Session-Cookies oder Benutzerdaten, nicht vor Abfangen durch bösartige Akteure.

#### Zertifikatsprüfung

Wir konzentrieren uns auf **Zertifikatsprüfung**. Die Integrität des Serverzertifikats muss verifiziert werden, um die Sicherheit zu erhöhen. Das ist entscheidend, da unsichere TLS-Konfigurationen und die Übertragung sensibler Daten über unverschlüsselte Kanäle erhebliche Risiken darstellen können. Für detaillierte Schritte zur Überprüfung von Serverzertifikaten und zur Behebung von Schwachstellen bietet [**diese Ressource**](https://manifestsecurity.com/android-application-security-part-10/) umfassende Anleitungen.

#### SSL Pinning

SSL Pinning ist eine Sicherheitsmaßnahme, bei der die Anwendung das Serverzertifikat gegen eine innerhalb der Anwendung gespeicherte, bekannte Kopie prüft. Diese Methode ist essenziell, um MITM-Angriffe zu verhindern. Die Implementierung von SSL Pinning wird dringend empfohlen für Anwendungen, die mit sensiblen Informationen arbeiten.

#### Traffic Inspection

Um HTTP-Traffic zu inspizieren, ist es notwendig, **das Zertifikat des Proxy-Tools zu installieren** (z. B. Burp). Ohne die Installation dieses Zertifikats ist verschlüsselter Traffic möglicherweise nicht über den Proxy sichtbar. Eine Anleitung zum Installieren eines benutzerdefinierten CA-Zertifikats findest du [**hier**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Anwendungen, die auf **API Level 24 und höher** abzielen, benötigen Änderungen an der Network Security Config, um das CA-Zertifikat des Proxys zu akzeptieren. Dieser Schritt ist entscheidend, um verschlüsselten Traffic zu inspizieren. Anweisungen zum Ändern der Network Security Config findest du in [**diesem Tutorial**](make-apk-accept-ca-certificate.md).

Wenn **Flutter** verwendet wird, musst du die Anweisungen auf [**dieser Seite**](flutter.md) befolgen. Das liegt daran, dass das bloße Hinzufügen des Zertifikats in den Store nicht ausreicht, da Flutter eine eigene Liste gültiger CAs verwendet.

#### Statische Erkennung von SSL/TLS-Pinning

Bevor du Runtime-Bypässe versuchst, solltest du schnell kartieren, wo Pinning im APK durchgesetzt wird. Statische Erkennung hilft dir, Hooks/Patches zu planen und dich auf die richtigen Codepfade zu konzentrieren.

Tool: SSLPinDetect
- Open-Source statisches Analyse-Utility, das das APK nach Smali dekompiliert (via apktool) und nach kuratierten regex-Mustern von SSL/TLS pinning-Implementierungen scannt.
- Meldet den genauen Dateipfad, die Zeilennummer und einen Codeausschnitt für jeden Treffer.
- Deckt gängige Frameworks und benutzerdefinierte Codepfade ab: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init mit custom TrustManagers/KeyManagers und Network Security Config XML pins.

Installation
- Voraussetzungen: Python >= 3.8, Java im PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Verwendung
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Beispiel-Pattern-Regeln (JSON)
Verwenden oder erweitern Sie Signaturen, um proprietäre/benutzerdefinierte pinning-Stile zu erkennen. Sie können Ihre eigene JSON laden und in großem Maßstab scannen.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Hinweise und Tipps
- Schnelles Scannen großer Apps durch Multithreading und memory-mapped I/O; vorkompilierte regex reduziert Overhead/Falschpositive.
- Pattern-Sammlung: https://github.com/aancw/smali-sslpin-patterns
- Typische Erkennungsziele für die weitere Priorisierung:
- OkHttp: Verwendung von CertificatePinner, setCertificatePinner, Verweise auf okhttp3/okhttp-Pakete
- Benutzerdefinierte TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted-Overrides
- Benutzerdefinierte SSL-Kontexte: SSLContext.getInstance + SSLContext.init mit benutzerdefinierten Managern
- Deklarative Pins in res/xml network security config und Manifest-Verweisen
- Nutze die gefundenen Stellen, um Frida-Hooks, statische Patches oder Config-Reviews vor dynamischen Tests zu planen.



#### SSL Pinning umgehen

Wenn SSL Pinning implementiert ist, ist es notwendig, es zu umgehen, um HTTPS-Traffic zu inspizieren. Für diesen Zweck stehen verschiedene Methoden zur Verfügung:

- Automatisch die **apk** modifizieren, um **SSLPinning** mit [**apk-mitm**](https://github.com/shroudedcode/apk-mitm) zu **umgehen**. Der größte Vorteil dieser Option ist, dass du kein root benötigst, um das SSL Pinning zu umgehen, aber du musst die Anwendung löschen und die neue installieren, und das funktioniert nicht immer.
- Du kannst **Frida** (siehe unten) verwenden, um diesen Schutz zu umgehen. Hier ist eine Anleitung für Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Du kannst auch versuchen, SSL Pinning **automatisch zu umgehen** mit [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Du kannst auch versuchen, SSL Pinning **automatisch zu umgehen** mit **MobSF dynamic analysis** (unten erklärt)
- Wenn du trotzdem denkst, dass es Traffic gibt, den du nicht erfasst, kannst du versuchen, den Traffic mit iptables an Burp weiterzuleiten. Lies diesen Blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Nach häufigen Web-Schwachstellen suchen

Es ist wichtig, innerhalb der Anwendung auch nach häufigen Web-Schwachstellen zu suchen. Detaillierte Informationen zur Erkennung und Behebung dieser Schwachstellen gehen über den Rahmen dieser Zusammenfassung hinaus, sind aber an anderer Stelle ausführlich behandelt.

### Frida

[Frida](https://www.frida.re) ist ein dynamisches Instrumentierungs-Toolkit für Entwickler, Reverse-Engineer und Sicherheitsforscher.\
**Du kannst auf laufende Anwendungen zugreifen und Methoden zur Laufzeit hooken, um Verhalten zu ändern, Werte zu ändern, Werte zu extrahieren, anderen Code auszuführen...**\
Wenn du Android-Anwendungen pentestest, musst du wissen, wie man Frida benutzt.

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Einige "GUI" für Aktionen mit Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection ist großartig, um die Nutzung von Frida zu automatisieren: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Du findest einige Awesome Frida-Skripte hier: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Versuche, Anti-Debugging-/Anti-Frida-Mechanismen zu umgehen, indem du Frida wie in [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) beschrieben lädst (Tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Speicher auslesen - Fridump**

Prüfe, ob die Anwendung sensible Informationen im Speicher ablegt, die dort nicht hingehören, wie Passwörter oder mnemonics.

Mit [**Fridump3**](https://github.com/rootbsd/fridump3) kannst du den Speicher der App dumpen mit:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Dies schreibt den Speicher in den Ordner ./dump, und dort könntest du z. B. mit etwas wie grep suchen:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Sensitive Daten im Keystore**

Auf Android ist der Keystore der beste Ort, um sensible Daten zu speichern; mit ausreichenden Rechten ist es jedoch weiterhin **möglich, darauf zuzugreifen**. Da Anwendungen hier dazu neigen, **sensible Daten im Klartext** zu speichern, sollten diese bei pentests überprüft werden, da ein root user oder jemand mit physischem Zugriff auf das Gerät diese Daten stehlen könnte.

Selbst wenn eine App Daten im Keystore speichert, sollten die Daten verschlüsselt sein.

Um auf die Daten im Keystore zuzugreifen, kann dieses Frida-Skript verwendet werden: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Mit dem folgenden Frida-Skript könnte es möglich sein, die von Android-Anwendungen verwendete **bypass fingerprint authentication** zu umgehen, die zum **Schutz bestimmter sensibler Bereiche** dient:
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Hintergrundbilder**

Wenn du eine Anwendung in den Hintergrund legst, speichert Android einen **Snapshot der Anwendung**, sodass beim Wiederherstellen in den Vordergrund zuerst das Bild geladen wird, bevor die App, wodurch es so aussieht, als wäre die App schneller geladen worden.

Wenn dieser Snapshot jedoch **sensible Informationen** enthält, könnte jemand mit Zugriff auf den Snapshot **diese Informationen stehlen** (beachte, dass du root benötigst, um darauf zuzugreifen).

Die Snapshots werden üblicherweise hier gespeichert: **`/data/system_ce/0/snapshots`**

Android bietet eine Möglichkeit, das Erfassen von Screenshots zu **verhindern, indem man das FLAG_SECURE** Layout-Parameter setzt. Durch die Verwendung dieses Flags werden die Fensterinhalte als sicher behandelt, wodurch verhindert wird, dass sie in Screenshots erscheinen oder auf nicht-sicheren Displays angezeigt werden.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Dieses Tool kann dir dabei helfen, verschiedene Tools während der dynamischen Analyse zu verwalten: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Entwickler erstellen oft Proxy-Komponenten wie activities, services und broadcast receivers, die diese Intents verarbeiten und an Methoden wie `startActivity(...)` oder `sendBroadcast(...)` weiterreichen, was riskant sein kann.

Die Gefahr besteht darin, dass Angreifer durch Umleitung dieser Intents nicht-exportierte App-Komponenten oder sensible Content-Providers auslösen können. Ein bemerkenswertes Beispiel ist die Komponente WebView, die URLs mittels `Intent.parseUri(...)` in `Intent`-Objekte umwandelt und diese dann ausführt, was zu bösartigen Intent-Injections führen kann.

### Wesentliche Erkenntnisse

- **Intent Injection** ist vergleichbar mit einem Open Redirect im Web.
- Exploits beinhalten das Weitergeben von `Intent`-Objekten als Extras, die umgeleitet werden können, um unsichere Operationen auszuführen.
- Es kann nicht-exportierte Komponenten und Content-Providers für Angreifer öffnen.
- Die URL-zu-Intent-Konvertierung von WebView kann unbeabsichtigte Aktionen ermöglichen.

### Android Client Side Injections and others

Wahrscheinlich kennst du diese Art von Schwachstellen aus dem Web. Bei Android-Anwendungen ist bei folgenden Schwachstellen besondere Vorsicht geboten:

- **SQL Injection:** Bei dynamischen Queries oder Content-Providers sicherstellen, dass parameterisierte Abfragen verwendet werden.
- **JavaScript Injection (XSS):** Vergewissere dich, dass JavaScript- und Plugin-Support für alle WebViews deaktiviert sind (standardmäßig deaktiviert). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** Für WebViews sollte der Zugriff auf das Dateisystem deaktiviert sein (standardmäßig aktiviert) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: In mehreren Fällen wird beim Beenden der Android-Anwendung die Session-Cookie nicht widerrufen oder es kann sogar auf der Festplatte gespeichert werden
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Statische Analyse**

![](<../../images/image (866).png>)

Bewertung der Schwachstellen der Anwendung über ein ansprechendes webbasiertes Frontend. Du kannst auch dynamische Analyse durchführen (aber die Umgebung muss vorbereitet werden).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Beachte, dass MobSF **Android**(apk)**, IOS**(ipa) **und Windows**(apx) Anwendungen analysieren kann (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Außerdem kann es eine **ZIP**-Datei mit dem Quellcode einer **Android**- oder **IOS**-App analysieren (gehe in das Root-Verzeichnis der Anwendung, wähle alles aus und erstelle eine ZIP-Datei).

MobSF erlaubt außerdem, Analysen zu **diff/Compare** und sich mit **VirusTotal** zu integrieren (du musst deinen API-Key in _MobSF/settings.py_ setzen und aktivieren: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). Du kannst `VT_UPLOAD` auch auf `False` setzen, dann wird statt der Datei der **hash** **upload**.

### Assisted Dynamic analysis with MobSF

**MobSF** kann auch sehr hilfreich für **dynamic analysis** auf **Android** sein, in diesem Fall musst du jedoch MobSF und **genymotion** auf deinem Host installieren (eine VM oder Docker funktioniert nicht). _Hinweis: Du musst zuerst eine VM in genymotion starten und **dann** MobSF._\
Der **MobSF dynamic analyser** kann:

- **Dump application data** (URLs, logs, clipboard, screenshots, die du gemacht hast, Screenshots, die vom "**Exported Activity Tester**" erstellt wurden, E-Mails, SQLite databases, XML files und andere erzeugte Dateien). All dies geschieht automatisch, außer bei den Screenshots — diese musst du manuell auslösen oder "**Exported Activity Tester**" drücken, um Screenshots aller exportierten Activities zu erhalten.
- Capture **HTTPS traffic**
- Use **Frida** um **runtime** **information** zu erhalten

Ab Android **versions > 5** wird es **automatisch Frida starten** und globale **proxy**-Einstellungen setzen, um den Traffic zu **capture**. Es wird nur Traffic von der getesteten Anwendung erfassen.

**Frida**

Standardmäßig nutzt es außerdem einige Frida-Skripte, um **SSL pinning** zu **bypass**, **root detection** und **debugger detection** zu umgehen und um **interesting APIs** zu **monitoren**.\
MobSF kann außerdem **exported activities** aufrufen, **Screenshots** davon machen und diese für den Report **save**.

Um das dynamic testing zu **starten**, drücke den grünen Button: "**Start Instrumentation**". Drücke "**Frida Live Logs**", um die von den Frida-Skripten erzeugten Logs zu sehen, und "**Live API Monitor**", um alle Aufrufe an gehookte Methoden, übergebene Argumente und zurückgegebene Werte zu sehen (dies erscheint nach dem Drücken von "Start Instrumentation").\
MobSF erlaubt dir auch, eigene **Frida scripts** zu laden (um die Ergebnisse deiner Frida-Skripte an MobSF zu senden, verwende die Funktion `send()`). Es hat zudem **mehrere vorgefertigte Skripte**, die du laden kannst (du kannst weitere in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/` hinzufügen), wähle sie aus, drücke "**Load**" und dann "**Start Instrumentation**" (du wirst die Logs dieser Skripte in "**Frida Live Logs**" sehen).

![](<../../images/image (419).png>)

Außerdem gibt es einige zusätzliche Frida-Funktionalitäten:

- **Enumerate Loaded Classes**: Gibt alle geladenen Klassen aus
- **Capture Strings**: Gibt alle erfassten Strings während der Nutzung der Anwendung aus (sehr noisy)
- **Capture String Comparisons**: Sehr nützlich. Es wird **die 2 verglichenen Strings** anzeigen und ob das Ergebnis True oder False war.
- **Enumerate Class Methods**: Gib den Klassennamen ein (z. B. "java.io.File") und es werden alle Methoden der Klasse ausgegeben.
- **Search Class Pattern**: Suche Klassen nach Muster
- **Trace Class Methods**: **Trace** eine **gesamte Klasse** (siehe Ein- und Ausgaben aller Methoden der Klasse). Denk daran, dass MobSF standardmäßig mehrere interessante Android API-Methoden trace't.

Sobald du das Hilfsmodul ausgewählt hast, das du verwenden möchtest, musst du "**Start Intrumentation**" drücken und du wirst alle Ausgaben in "**Frida Live Logs**" sehen.

**Shell**

MobSF bietet außerdem eine Shell mit einigen **adb**-Befehlen, **MobSF commands** und gängigen **shell** **commands** am unteren Rand der dynamic analysis Seite. Einige interessante Befehle:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP tools**

When HTTP traffic is capture you can see an ugly view of the captured traffic on "**HTTP(S) Traffic**" bottom or a nicer view in "**Start HTTPTools**" green bottom. From the second option, you can **send** the **captured requests** to **proxies** like Burp or Owasp ZAP.\
To do so, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> press "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Sobald du die dynamische Analyse mit MobSF abgeschlossen hast, kannst du auf "**Start Web API Fuzzer**" klicken, um **HTTP-Requests** zu **fuzz**en und nach Schwachstellen zu suchen.

> [!TIP]
> Nach einer dynamischen Analyse mit MobSF können die Proxy-Einstellungen fehlerhaft sein und sich nicht über die GUI beheben lassen. Du kannst die Proxy-Einstellungen folgendermaßen korrigieren:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

You can get the tool from [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Dieses Tool verwendet einige **Hooks**, um dir während einer **dynamischen Analyse** zu zeigen, **was in der Anwendung passiert**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Dies ist ein **hervorragendes Tool, um statische Analyse mit einer GUI durchzuführen**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Dieses Tool ist dafür konzipiert, mehrere **security related Android application vulnerabilities** zu finden, entweder im **source code** oder in **packaged APKs**. Das Tool ist außerdem **capable of creating a "Proof-of-Concept" deployable APK** und **ADB commands**, um einige der gefundenen Schwachstellen auszunutzen (Exposed activities, intents, tapjacking...). Wie bei Drozer ist es nicht nötig, das Testgerät zu rooten.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Zeigt alle extrahierten Dateien zur einfachen Referenz an
- Dekompi liert APK-Dateien automatisch in Java- und Smali-Format
- Analysiert AndroidManifest.xml auf gängige Schwachstellen und Verhalten
- Statische Quellcode-Analyse auf gängige Schwachstellen und Verhalten
- Geräteinformationen
- und mehr
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER ist eine Kommandozeilenanwendung, die unter Windows, MacOS X und Linux verwendet werden kann und _.apk_ Dateien auf der Suche nach Schwachstellen analysiert. Dies geschieht, indem APKs dekomprimiert und eine Reihe von Regeln angewendet werden, um diese Schwachstellen zu erkennen.

Alle Regeln sind in einer `rules.json`-Datei zentralisiert, und jedes Unternehmen bzw. jeder Tester kann eigene Regeln erstellen, um gezielt das zu analysieren, was benötigt wird.

Lade die neuesten Binärdateien von der [download page](https://superanalyzer.rocks/download.html) herunter.
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn ist ein **plattformübergreifendes** Tool, das Entwicklern, Bug-Bounty-Huntern und ethischen Hackern beim Durchführen von [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) an mobilen Anwendungen hilft.

Das Konzept besteht darin, dass du per Drag-and-Drop deine mobile Anwendungsdatei (eine .apk- oder .ipa-Datei) auf die StaCoAn-Anwendung ziehst, woraufhin sie einen visuellen und portablen Bericht für dich erstellt. Du kannst die Einstellungen und wordlists anpassen, um eine maßgeschneiderte Erfahrung zu erhalten.

Herunterladen[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework ist ein System zur Analyse von Schwachstellen, das Entwicklern oder hackers hilft, potenzielle Sicherheitslücken in Android-Anwendungen zu finden.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** ist ein Tool, dessen Hauptziel darin besteht, den Benutzer vor potenziell bösartigem Verhalten einer Android-Anwendung zu erkennen und zu warnen.

Die Erkennung erfolgt durch die **static analysis** des Dalvik-Bytecodes der Anwendung, dargestellt als **Smali**, unter Verwendung der [`androguard`](https://github.com/androguard/androguard) Bibliothek.

Dieses Tool sucht nach **häufigem Verhalten von "bösen" Anwendungen** wie: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** ist ein **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. Es ist ein Tool, das häufig verwendete mobile application reverse engineering and analysis tools zusammenführt, um beim Testen mobiler Anwendungen gegen die OWASP mobile security threats zu unterstützen. Ziel ist es, diese Aufgabe für mobile Anwendungsentwickler und Security-Profis einfacher und benutzerfreundlicher zu machen.

Es kann:

- Java und Smali code mit verschiedenen Tools extrahieren
- APKs analysieren mit: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Private Informationen aus dem APK mit regexps extrahieren.
- Das Manifest analysieren.
- Gefundene Domains analysieren mit: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) und [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Nützlich zur Erkennung von Malware: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Beachte, dass abhängig vom Service und der Konfiguration, die du zum obfuscate des code verwendest, Secrets möglicherweise obfuscated bleiben oder nicht.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. It is able to optimize bytecode as well as detect and remove unused instructions. ProGuard is free software and is distributed under the GNU General Public License, version 2.

ProGuard wird als Teil des Android SDK verteilt und läuft beim Bauen der Anwendung im release mode.

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(Aus diesem Guide) Beim letzten Mal, als wir nachgesehen haben, war der Dexguard mode of operation:

- lädt eine Ressource als InputStream;
- leitet das Ergebnis an eine Klasse weiter, die von FilterInputStream erbt, um es zu decrypten;
- führt einige nutzlose obfuscation durch, um einem Reverser ein paar Minuten Zeit zu stehlen;
- leitet das entschlüsselte Ergebnis an einen ZipInputStream weiter, um eine DEX-Datei zu erhalten;
- lädt schließlich die resultierende DEX als Resource mit der `loadDex`-Methode.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

Du kannst ein obfuscated APK auf ihre Plattform hochladen.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

Dies ist ein LLM-Tool, um potenzielle security vulnerabilities in android apps zu finden und android app code zu deobfuscate. Verwendet Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

Es ist ein **generic android deobfuscator.** Simplify **virtually executes an app**, um ihr Verhalten zu verstehen, und versucht dann, den code zu optimieren, sodass er identisch funktioniert, aber für einen Menschen leichter zu verstehen ist. Jede Optimierungsart ist simpel und generisch, sodass es egal ist, welche spezifische Art der obfuscation verwendet wurde.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD gibt dir Informationen darüber, **how an APK was made**. Es identifiziert viele **compilers**, **packers**, **obfuscators** und anderes seltsames Zeug. It's [_PEiD_](https://www.aldeid.com/wiki/PEiD) for Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b ist eine Android security virtual machine basierend auf ubuntu-mate und enthält eine Sammlung der neuesten Frameworks, Tutorials und Labs von verschiedenen Security-Geeks und Researchern für reverse engineering und malware analysis.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Es ist eine großartige Liste von Ressourcen
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android Schnellkurs
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
