# Pentesting Εφαρμογών Android

{{#include ../../banners/hacktricks-training.md}}

## Βασικά Εφαρμογών Android

Συνιστάται ιδιαίτερα να ξεκινήσετε διαβάζοντας αυτή τη σελίδα για να μάθετε σχετικά με τα **πιο σημαντικά μέρη που σχετίζονται με την ασφάλεια Android και τα πιο επικίνδυνα στοιχεία σε μια εφαρμογή Android**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Αυτή είναι το κύριο εργαλείο που χρειάζεστε για να συνδεθείτε σε μια συσκευή Android (εξομοιωμένη ή φυσική).\
Το **ADB** επιτρέπει τον έλεγχο συσκευών είτε μέσω **USB** είτε μέσω **Network** από έναν υπολογιστή. Αυτή η βοηθητική εφαρμογή παρέχει τη δυνατότητα **αντιγραφής** αρχείων και στις δύο κατευθύνσεις, **εγκατάστασης** και **απεγκατάστασης** εφαρμογών, **εκτέλεσης** εντολών shell, **δημιουργίας αντιγράφων ασφαλείας** δεδομένων, **ανάγνωσης** logs, μεταξύ άλλων λειτουργιών.

Ρίξτε μια ματιά στην παρακάτω λίστα των [**ADB Commands**](adb-commands.md) για να μάθετε πώς να χρησιμοποιείτε το adb.

## Smali

Μερικές φορές είναι ενδιαφέρον να **τροποποιήσετε τον κώδικα της εφαρμογής** για να αποκτήσετε πρόσβαση σε **κρυφές πληροφορίες** (προφανώς καλά obfuscated passwords ή flags). Τότε, μπορεί να είναι χρήσιμο να αποσυμπιέσετε/decompile το APK, να τροποποιήσετε τον κώδικα και να το ανασυμπιέσετε/recompile.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Αυτό μπορεί να είναι πολύ χρήσιμο ως μια **εναλλακτική για διάφορες δοκιμές κατά την δυναμική ανάλυση** που πρόκειται να παρουσιαστούν. Επομένως, **κρατήστε πάντα αυτή την πιθανότητα στο μυαλό σας**.

## Άλλα ενδιαφέροντα κόλπα

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- Λήψη APKs: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Εξαγωγή APK από συσκευή:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Συγχώνευσε όλα τα splits και τα base apks με [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Μελέτες Περιπτώσεων & Ευπάθειες


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Στατική Ανάλυση

Πρώτα απ' όλα, για να αναλύσετε ένα APK θα πρέπει **να ρίξετε μια ματιά στον Java κώδικα** χρησιμοποιώντας έναν decompiler.\
Παρακαλώ, [**διαβάστε εδώ για να βρείτε πληροφορίες σχετικά με τους διάφορους διαθέσιμους decompilers**](apk-decompilers.md).

### Αναζήτηση ενδιαφέρουσας πληροφορίας

Απλώς κοιτάζοντας τις **strings** του APK μπορείτε να αναζητήσετε **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **API** keys, **encryption**, **bluetooth uuids**, **tokens** και οτιδήποτε ενδιαφέρον... ψάξτε ακόμα και για code execution **backdoors** ή authentication backdoors (hardcoded admin credentials στην εφαρμογή).

**Firebase**

Δώστε ιδιαίτερη προσοχή στα **Firebase URLs** και ελέγξτε αν είναι κακώς διαμορφωμένα. [Περισσότερες πληροφορίες για το τι είναι το Firebase και πώς να το εκμεταλλευτείτε εδώ.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Βασική κατανόηση της εφαρμογής - Manifest.xml, strings.xml

Η **εξέταση των αρχείων _Manifest.xml_ και _strings.xml_ μιας εφαρμογής μπορεί να αποκαλύψει πιθανές ευπάθειες ασφάλειας**. Αυτά τα αρχεία μπορούν να προσεγγιστούν με decompilers ή με την αλλαγή της επέκτασης του APK σε .zip και στη συνέχεια αποσυμπίεση.

**Ευπάθειες** που εντοπίζονται από το **Manifest.xml** περιλαμβάνουν:

- **Debuggable Applications**: Εφαρμογές που έχουν οριστεί ως debuggable (`debuggable="true"`) στο _Manifest.xml_ αποτελούν κίνδυνο καθώς επιτρέπουν συνδέσεις που μπορούν να οδηγήσουν σε exploitation. Για περαιτέρω κατανόηση σχετικά με το πώς να εκμεταλλευτείτε debuggable applications, ανατρέξτε σε ένα tutorial για το πώς να βρίσκετε και να εκμεταλλεύεστε debuggable applications σε μια συσκευή.
- **Backup Settings**: Το attribute `android:allowBackup="false"` πρέπει να ορίζεται ρητά για εφαρμογές που χειρίζονται ευαίσθητες πληροφορίες, ώστε να αποτρέπονται μη εξουσιοδοτημένα backups δεδομένων μέσω adb, ειδικά όταν είναι ενεργοποιημένο το usb debugging.
- **Network Security**: Custom network security configurations (`android:networkSecurityConfig="@xml/network_security_config"`) στο _res/xml/_ μπορούν να καθορίσουν λεπτομέρειες ασφάλειας όπως certificate pins και ρυθμίσεις HTTP traffic. Ένα παράδειγμα είναι η επιτρεπόμενη HTTP κίνηση για συγκεκριμένα domains.
- **Exported Activities and Services**: Η αναγνώριση exported activities και services στο manifest μπορεί να αναδείξει components που ενδέχεται να χρησιμοποιηθούν κακόβουλα. Περαιτέρω ανάλυση κατά τη διάρκεια dynamic testing μπορεί να αποκαλύψει πώς να εκμεταλλευτείτε αυτά τα components.
- **Content Providers and FileProviders**: Εκτεθειμένοι content providers μπορεί να επιτρέψουν μη εξουσιοδοτημένη πρόσβαση ή τροποποίηση δεδομένων. Η διαμόρφωση των FileProviders πρέπει επίσης να εξεταστεί προσεκτικά.
- **Broadcast Receivers and URL Schemes**: Αυτά τα components μπορούν να χρησιμοποιηθούν για exploitation, με ιδιαίτερη προσοχή στον τρόπο διαχείρισης των URL schemes για input vulnerabilities.
- **SDK Versions**: Τα attributes `minSdkVersion`, `targetSDKVersion`, και `maxSdkVersion` υποδεικνύουν τις υποστηριζόμενες εκδόσεις Android, υπογραμμίζοντας τη σημασία του να μην υποστηρίζονται παρωχημένες, ευάλωτες εκδόσεις Android για λόγους ασφάλειας.

Από το αρχείο **strings.xml**, μπορούν να εντοπιστούν ευαίσθητες πληροφορίες όπως API keys, custom schemas και άλλες σημειώσεις του developer, τονίζοντας την ανάγκη προσεκτικής ανασκόπησης αυτών των πόρων.

### Tapjacking

Το **Tapjacking** είναι μια επίθεση όπου μια **κακόβουλη** **εφαρμογή** εκκινείται και **τοποθετείται πάνω από μια εφαρμογή θύμα**. Μόλις αποκρύψει οπτικά την εφαρμογή θύμα, το UI της έχει σχεδιαστεί έτσι ώστε να ξεγελάει τον χρήστη να αλληλεπιδράσει με αυτό, ενώ παράλληλα προωθεί την αλληλεπίδραση στην εφαρμογή θύμα.\
Στην ουσία, **τυφλώνει τον χρήστη ώστε να μην γνωρίζει ότι στην πραγματικότητα εκτελεί ενέργειες στην εφαρμογή θύμα**.

Βρείτε περισσότερες πληροφορίες σε:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Μια **activity** με το **`launchMode`** ρυθμισμένο σε **`singleTask` χωρίς να έχει οριστεί `taskAffinity`** είναι ευάλωτη σε Task Hijacking. Αυτό σημαίνει ότι μια **εφαρμογή** μπορεί να εγκατασταθεί και αν εκκινήσει πριν από την πραγματική εφαρμογή θα μπορούσε **να καταλάβει το task της πραγματικής εφαρμογής** (ώστε ο χρήστης να αλληλεπιδρά με την **κακόβουλη εφαρμογή νομίζοντας ότι χρησιμοποιεί την πραγματική**).

Περισσότερες πληροφορίες στο:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Ανασφαλής αποθήκευση δεδομένων

**Internal Storage**

Στο Android, τα αρχεία που **αποθηκεύονται** στην **internal** αποθήκευση έχουν σχεδιαστεί ώστε να είναι **προσβάσιμα αποκλειστικά από την εφαρμογή** που τα **δημιούργησε**. Αυτό το μέτρο ασφάλειας **επιβάλλεται** από το λειτουργικό σύστημα Android και γενικά είναι επαρκές για τις ανάγκες ασφάλειας των περισσότερων εφαρμογών. Ωστόσο, οι developers μερικές φορές χρησιμοποιούν modes όπως `MODE_WORLD_READABLE` και `MODE_WORLD_WRITABLE` για να **επιτρέψουν** την κοινή χρήση αρχείων μεταξύ διαφορετικών εφαρμογών. Αυτά τα modes όμως **δεν περιορίζουν την πρόσβαση** σε αυτά τα αρχεία από άλλες εφαρμογές, συμπεριλαμβανομένων πιθανώς κακόβουλων.

1. **Static Analysis:**
- **Ελέγξτε** διεξοδικά αν γίνεται χρήση των `MODE_WORLD_READABLE` και `MODE_WORLD_WRITABLE`. Αυτά τα modes **μπορεί να εκθέσουν** αρχεία σε **μη επιθυμητή ή μη εξουσιοδοτημένη πρόσβαση**.
2. **Dynamic Analysis:**
- **Επαληθεύστε** τα **permissions** που ορίζονται σε αρχεία που δημιουργούνται από την εφαρμογή. Συγκεκριμένα, **ελέγξτε** αν κάποια αρχεία έχουν οριστεί να είναι readable ή writable worldwide. Αυτό μπορεί να αποτελέσει σημαντικό κίνδυνο ασφάλειας, καθώς θα επέτρεπε **οποιαδήποτε εφαρμογή** εγκατεστημένη στη συσκευή, ανεξαρτήτως προέλευσης ή προθέσεων, να **διαβάσει ή να τροποποιήσει** αυτά τα αρχεία.

**External Storage**

Όταν χειρίζεστε αρχεία στην **external storage**, όπως SD Cards, πρέπει να λάβετε ορισμένες προφυλάξεις:

1. **Accessibility**:
- Τα αρχεία στην external storage είναι **παγκοσμίως αναγνώσιμα και εγγράψιμα**. Αυτό σημαίνει ότι οποιαδήποτε εφαρμογή ή χρήστης μπορεί να έχει πρόσβαση σε αυτά τα αρχεία.
2. **Security Concerns**:
- Δε συνιστάται να αποθηκεύετε ευαίσθητες πληροφορίες στην external storage λόγω της εύκολης πρόσβασης.
- Η external storage μπορεί να αφαιρεθεί ή να προσπελαστεί από οποιαδήποτε εφαρμογή, καθιστώντας την λιγότερο ασφαλή.
3. **Handling Data from External Storage**:
- Πάντα **εκτελέστε input validation** στα δεδομένα που ανακτάτε από external storage. Αυτό είναι κρίσιμο επειδή τα δεδομένα προέρχονται από μη αξιόπιστη πηγή.
- Η αποθήκευση εκτελέσιμων αρχείων ή class files στην external storage για dynamic loading **αποθαρρύνεται έντονα**.
- Εάν η εφαρμογή σας πρέπει να ανακτήσει εκτελέσιμα αρχεία από external storage, βεβαιωθείτε ότι αυτά τα αρχεία είναι **υπογεγραμμένα και κρυπτογραφικά επαληθευμένα** πριν φορτωθούν δυναμικά. Αυτό το βήμα είναι ζωτικής σημασίας για τη διατήρηση της ασφάλειας της εφαρμογής σας.

Η εξωτερική αποθήκευση μπορεί να **προσπελαστεί** σε `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> Ξεκινώντας από το Android 4.4 (**API 17**), η SD card έχει μια δομή καταλόγων που **περιορίζει την πρόσβαση από μια εφαρμογή στον κατάλογο που προορίζεται ειδικά για εκείνη την εφαρμογή**. Αυτό αποτρέπει μια κακόβουλη εφαρμογή από το να αποκτήσει πρόσβαση ανάγνωσης ή εγγραφής στα αρχεία άλλης εφαρμογής.

**Ευαίσθητα δεδομένα αποθηκευμένα σε απλό κείμενο**

- **Shared preferences**: Το Android επιτρέπει σε κάθε εφαρμογή να αποθηκεύει εύκολα xml αρχεία στο μονοπάτι `/data/data/<packagename>/shared_prefs/` και μερικές φορές είναι δυνατό να βρεθούν ευαίσθητες πληροφορίες σε απλό κείμενο σε αυτόν τον φάκελο.
- **Databases**: Το Android επιτρέπει σε κάθε εφαρμογή να αποθηκεύει εύκολα sqlite βάσεις δεδομένων στο μονοπάτι `/data/data/<packagename>/databases/` και μερικές φορές είναι δυνατό να βρεθούν ευαίσθητες πληροφορίες σε απλό κείμενο σε αυτόν τον φάκελο.

### Broken TLS

**Accept All Certificates**

Για κάποιο λόγο μερικές φορές οι developers αποδέχονται όλα τα certificates ακόμα κι αν, για παράδειγμα, το hostname δεν ταιριάζει, με γραμμές κώδικα όπως η παρακάτω:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Ένας καλός τρόπος για να δοκιμάσετε αυτό είναι να προσπαθήσετε να καταγράψετε την κίνηση χρησιμοποιώντας κάποιο proxy όπως Burp χωρίς να εξουσιοδοτήσετε το Burp CA εντός της συσκευής. Επίσης, μπορείτε να δημιουργήσετε με το Burp ένα πιστοποιητικό για διαφορετικό hostname και να το χρησιμοποιήσετε.

### Broken Cryptography

**Κακές Διαδικασίες Διαχείρισης Κλειδιών**

Κάποιοι developers αποθηκεύουν ευαίσθητα δεδομένα στο local storage και τα κρυπτογραφούν με ένα key hardcoded/ προβλέψιμο στον κώδικα. Αυτό δεν θα έπρεπε να γίνεται γιατί κάποιο reversing μπορεί να επιτρέψει σε επιτιθέμενους να εξάγουν τις εμπιστευτικές πληροφορίες.

**Use of Insecure and/or Deprecated Algorithms**

Οι developers δεν πρέπει να χρησιμοποιούν **deprecated algorithms** για να πραγματοποιούν authorisation **checks**, **store** ή **send** δεδομένα. Μερικοί από αυτούς τους αλγορίθμους είναι: RC4, MD4, MD5, SHA1... Αν χρησιμοποιούνται **hashes** για αποθήκευση κωδικών, για παράδειγμα, θα πρέπει να χρησιμοποιηθούν hashes ανθεκτικά σε brute-force με salt.

### Other checks

- It's recommended to **obfuscate the APK** to difficult the reverse engineer labour to attackers.
- If the app is sensitive (like bank apps), it should perform it's **own checks to see if the mobile is rooted** and act in consequence.
- If the app is sensitive (like bank apps), it should check if an **emulator** is being used.
- If the app is sensitive (like bank apps), it should **check it's own integrity before executing** it to check if it was modified.
- Use [**APKiD**](https://github.com/rednaga/APKiD) to check which compiler/packer/obfuscator was used to build the APK

### React Native Application

Διαβάστε την παρακάτω σελίδα για να μάθετε πώς να έχετε εύκολα πρόσβαση στον javascript κώδικα των React εφαρμογών:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Διαβάστε την παρακάτω σελίδα για να μάθετε πώς να έχετε εύκολα πρόσβαση στον C# κώδικα μιας xamarin εφαρμογής:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

Σύμφωνα με αυτό το [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) το superpacked είναι ένας Meta αλγόριθμος που συμπιέζει το περιεχόμενο μιας εφαρμογής σε ένα single file. Το blog μιλάει για τη δυνατότητα δημιουργίας μιας εφαρμογής που αποσυμπιέζει αυτού του τύπου τις εφαρμογές... και έναν πιο γρήγορο τρόπο που περιλαμβάνει το **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

Το εργαλείο [**mariana-trench**](https://github.com/facebook/mariana-trench) είναι ικανό να βρίσκει **vulnerabilities** σαρώνοντας τον **code** της εφαρμογής. Αυτό το εργαλείο περιέχει μια σειρά από **known sources** (που υποδεικνύει στο εργαλείο τα **places** όπου το **input** είναι **controlled by the user**), **sinks** (που υποδεικνύει στο εργαλείο **dangerous** **places** όπου κακόβουλο user input θα μπορούσε να προκαλέσει ζημία) και **rules**. Αυτοί οι κανόνες υποδεικνύουν τον **συνδυασμό** **sources-sinks** που δηλώνει μια ευπάθεια.

Με αυτή τη γνώση, **mariana-trench will review the code and find possible vulnerabilities on it**.

### Secrets leaked

Μια εφαρμογή μπορεί να περιέχει secrets (API keys, passwords, hidden urls, subdomains...) μέσα της που μπορεί να είστε σε θέση να ανακαλύψετε. Μπορείτε να χρησιμοποιήσετε ένα εργαλείο όπως [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)
- In-memory native code execution via JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> Πρώτα απ' όλα, χρειάζεστε ένα περιβάλλον όπου μπορείτε να εγκαταστήσετε την εφαρμογή και όλο το περιβάλλον (Burp CA cert, Drozer and Frida mainly). Επομένως, μια rooted συσκευή (emulated ή όχι) συνιστάται έντονα.

### Online Dynamic analysis

Μπορείτε να δημιουργήσετε έναν **free account** στο: [https://appetize.io/](https://appetize.io). Αυτή η πλατφόρμα σας επιτρέπει να **upload** και να **execute** APKs, οπότε είναι χρήσιμη για να δείτε πώς συμπεριφέρεται ένα apk.

Μπορείτε ακόμα να **δειτε τα logs της εφαρμογής σας** στο web και να συνδεθείτε μέσω **adb**.

![](<../../images/image (831).png>)

Χάρη στη σύνδεση ADB μπορείτε να χρησιμοποιήσετε **Drozer** και **Frida** μέσα στους emulators.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (Μπορείτε να δημιουργήσετε **x86** και **arm** συσκευές, και σύμφωνα με [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** versions **support ARM libraries** χωρίς να χρειαστεί ένας αργός arm emulator).
- Μάθετε πώς να το ρυθμίσετε σε αυτή τη σελίδα:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, χρειάζεται να δημιουργήσετε account. _Συνιστάται να **download** την έκδοση **WITH**_ _**VirtualBox** για να αποφύγετε πιθανά σφάλματα._)
- [**Nox**](https://es.bignox.com) (Δωρεάν, αλλά δεν υποστηρίζει Frida ή Drozer).

> [!TIP]
> Όταν δημιουργείτε έναν νέο emulator σε οποιαδήποτε πλατφόρμα θυμηθείτε ότι όσο μεγαλύτερη είναι η οθόνη τόσο πιο αργά θα τρέχει ο emulator. Οπότε επιλέξτε μικρές οθόνες αν είναι δυνατό.

Για να **install google services** (όπως AppStore) στο Genymotion πρέπει να κάνετε κλικ στο κόκκινο κουμπί που σημειώνεται στην παρακάτω εικόνα:

![](<../../images/image (277).png>)

Επίσης, σημειώστε ότι στη **διαμόρφωση της Android VM στο Genymotion** μπορείτε να επιλέξετε **Bridge Network mode** (αυτό θα είναι χρήσιμο εάν θα συνδέεστε στην Android VM από διαφορετική VM με τα εργαλεία).

#### Use a physical device

Πρέπει να ενεργοποιήσετε τις **debugging** επιλογές και θα είναι καλό αν μπορείτε να το **root**:

1. **Settings**.
2. (FromAndroid 8.0) Επιλέξτε **System**.
3. Επιλέξτε **About phone**.
4. Πατήστε **Build number** 7 φορές.
5. Επιστρέψτε και θα βρείτε τις **Developer options**.

> Μόλις εγκαταστήσετε την εφαρμογή, το πρώτο πράγμα που πρέπει να κάνετε είναι να τη δοκιμάσετε και να ερευνήσετε τι κάνει, πώς λειτουργεί και να αισθανθείτε άνετα με αυτή.\
> Προτείνω να **εκτελέσετε αυτή την αρχική δυναμική ανάλυση χρησιμοποιώντας MobSF dynamic analysis + pidcat**, έτσι θα μπορέσουμε να **learn how the application works** ενώ το MobSF **captures** πολλά **interesting** **data** που μπορείτε να εξετάσετε αργότερα.

Magisk/Zygisk quick notes (recommended on Pixel devices)
- Patch boot.img with the Magisk app and flash via fastboot to get systemless root
- Enable Zygisk + DenyList for root hiding; consider LSPosed/Shamiko when stronger hiding is required
- Keep original boot.img to recover from OTA updates; re-patch after each OTA
- For screen mirroring, use scrcpy on the host



### Unintended Data Leakage

**Logging**

Οι developers πρέπει να είναι προσεκτικοί στο να μην εκθέτουν **debugging information** δημόσια, καθώς αυτό μπορεί να οδηγήσει σε ευαίσθητες data leaks. Τα εργαλεία [**pidcat**](https://github.com/JakeWharton/pidcat) και `adb logcat` συνιστώνται για την παρακολούθηση των application logs προκειμένου να εντοπίσετε και να προστατεύσετε ευαίσθητες πληροφορίες. **Pidcat** προτιμάται για την ευκολία χρήσης και την αναγνωσιμότητα του.

> [!WARNING]
> Σημειώστε ότι από **later newer than Android 4.0**, **applications are only able to access their own logs**. Έτσι οι εφαρμογές δεν μπορούν να έχουν πρόσβαση στα logs άλλων apps.\
> Παρ' όλα αυτά, εξακολουθεί να συνιστάται να **μην καταγράφετε ευαίσθητες πληροφορίες**.

**Copy/Paste Buffer Caching**

Το Android **clipboard-based** framework επιτρέπει λειτουργίες copy-paste στις εφαρμογές, αλλά παρουσιάζει κίνδυνο καθώς **άλλες applications** μπορούν να **access** το clipboard, εκθέτοντας ενδεχομένως ευαίσθητα δεδομένα. Είναι κρίσιμο να **απενεργοποιήσετε τις copy/paste** λειτουργίες για ευαίσθητα τμήματα μιας εφαρμογής, όπως οι πληροφορίες πιστωτικής κάρτας, για να αποτρέψετε τυχόν data leaks.

**Crash Logs**

Αν μια εφαρμογή **crashes** και **αποθηκεύει logs**, αυτά τα logs μπορούν να βοηθήσουν επιτιθέμενους, ειδικά όταν η εφαρμογή δεν μπορεί να γίνει reverse-engineered. Για να μετριαστεί αυτός ο κίνδυνος, αποφεύγετε το logging σε crashes, και αν τα logs πρέπει να σταλούν μέσω δικτύου, βεβαιωθείτε ότι αποστέλλονται μέσω SSL καναλιού για ασφάλεια.

Ως pentester, **προσπαθήστε να ρίξετε μια ματιά σε αυτά τα logs**.

**Analytics Data Sent To 3rd Parties**

Οι εφαρμογές συχνά ενσωματώνουν υπηρεσίες όπως Google Adsense, που ενδέχεται κατά λάθος να **leak sensitive data** λόγω ακατάλληλης υλοποίησης από τους developers. Για να εντοπίσετε πιθανές διαρροές δεδομένων, συνιστάται να **intercept the application's traffic** και να ελέγξετε αν αποστέλλεται ευαίσθητη πληροφορία σε third-party services.

### SQLite DBs

Οι περισσότερες εφαρμογές θα χρησιμοποιήσουν **internal SQLite databases** για να αποθηκεύουν πληροφορίες. Κατά τη διάρκεια του pentest ρίξτε μια **ματιά** στις **databases** που έχουν δημιουργηθεί, τα ονόματα των **tables** και **columns** και όλα τα **δεδομένα** που είναι αποθηκευμένα γιατί μπορεί να βρείτε **ευαίσθητες πληροφορίες** (που θα αποτελούσαν vulnerability).\
Οι βάσεις δεδομένων θα πρέπει να βρίσκονται στο `/data/data/the.package.name/databases` όπως `/data/data/com.mwr.example.sieve/databases`

Αν η βάση δεδομένων αποθηκεύει εμπιστευτικές πληροφορίες και είναι **encrypted** αλλά μπορείτε να **find** το **password** μέσα στην εφαρμογή, είναι ακόμα μια **vulnerability**.

Επισιματώστε τους πίνακες χρησιμοποιώντας `.tables` και επισιματώστε τις στήλες των πινάκων χρησιμοποιώντας `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

Από τα [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** σας επιτρέπει να **assume the role of an Android app** και να αλληλεπιδράτε με άλλες εφαρμογές. Μπορεί να κάνει **anything that an installed application can do**, όπως να χρησιμοποιεί τον μηχανισμό Inter-Process Communication (IPC) του Android και να αλληλεπιδρά με το underlying operating system. .\
Το Drozer είναι ένα χρήσιμο εργαλείο για να **exploit exported activities, exported services and Content Providers** όπως θα μάθετε στις επόμενες ενότητες.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Θυμηθείτε επίσης ότι ο κώδικας μιας activity ξεκινάει στη μέθοδο **`onCreate`**.

**Authorisation bypass**

Όταν μια Activity είναι exported μπορείτε να καλέσετε την οθόνη της από μια εξωτερική εφαρμογή. Επομένως, αν μια activity με **sensitive information** είναι **exported** θα μπορούσατε να **bypass** τους **authentication** μηχανισμούς για να αποκτήσετε πρόσβαση σε αυτή.

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

Μπορείτε επίσης να ξεκινήσετε μια exported activity από adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**ΣΗΜΕΙΩΣΗ**: MobSF θα χαρακτηρίσει ως κακόβουλη τη χρήση του _**singleTask/singleInstance**_ ως `android:launchMode` σε ένα activity, αλλά εξαιτίας [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), προφανώς αυτό είναι επικίνδυνο μόνο σε παλιότερες εκδόσεις (API versions < 21).

> [!TIP]
> Σημείωσε ότι ένα authorisation bypass δεν είναι πάντα μια vulnerability — εξαρτάται από το πώς λειτουργεί το bypass και ποια πληροφορία εκτίθεται.

**Sensitive information leakage**

**Activities can also return results**. Αν καταφέρεις να βρεις μια exported και unprotected Activity που καλεί τη μέθοδο **`setResult`** και **επιστρέφει ευαίσθητες πληροφορίες**, υπάρχει sensitive information leakage.

#### Tapjacking

Εάν το Tapjacking δεν αποτρέπεται, μπορείς να καταχραστείς την exported Activity για να κάνεις τον χρήστη να εκτελέσει **απροσδόκητες ενέργειες**. Για περισσότερες πληροφορίες σχετικά με [**τι είναι το Tapjacking — ακολούθησε τον σύνδεσμο**](#tapjacking).

### Exploiting Content Providers - Πρόσβαση και χειρισμός ευαίσθητων πληροφοριών

[**Διάβασε αυτό αν θέλεις να ανανεώσεις τι είναι ένα Content Provider.**](android-applications-basics.md#content-provider)\
Content providers χρησιμοποιούνται βασικά για να **μοιράζονται δεδομένα**. Αν μια εφαρμογή έχει διαθέσιμους content providers, μπορεί να καταφέρεις να **εξάγεις ευαίσθητα δεδομένα** από αυτούς. Είναι επίσης ενδιαφέρον να δοκιμάσεις πιθανές **SQL injections** και **Path Traversals**, καθώς μπορεί να είναι ευάλωτοι.

[**Μάθε πώς να εκμεταλλευτείς Content Providers με το Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Διάβασε αυτό αν θέλεις να ανανεώσεις τι είναι ένα Service.**](android-applications-basics.md#services)\
Θυμήσου ότι οι ενέργειες ενός Service ξεκινούν στη μέθοδο `onStartCommand`.

Ένα service είναι ουσιαστικά κάτι που **μπορεί να λαμβάνει δεδομένα**, τα **επεξεργάζεται** και **επιστρέφει** (ή όχι) μια απάντηση. Έτσι, αν μια εφαρμογή εξάγει κάποια services, πρέπει να **ελέγξεις** τον **κώδικα** για να καταλάβεις τι κάνει και να το **δοκιμάσεις** **δυναμικά** για να εξάγεις εμπιστευτικές πληροφορίες, να παρακάμψεις μέτρα αυθεντικοποίησης κ.λπ.\
[**Μάθε πώς να εκμεταλλευτείς Services με το Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Διάβασε αυτό αν θέλεις να ανανεώσεις τι είναι ένα Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Θυμήσου ότι οι ενέργειες ενός Broadcast Receiver ξεκινούν στη μέθοδο `onReceive`.

Ένας Broadcast Receiver θα περιμένει έναν τύπο μηνύματος. Ανάλογα με το πώς ο receiver χειρίζεται το μήνυμα, μπορεί να είναι ευάλωτος.\
[**Μάθε πώς να εκμεταλλευτείς Broadcast Receivers με το Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Μπορείς να αναζητήσεις deep links χειροκίνητα, χρησιμοποιώντας εργαλεία όπως το MobSF ή scripts όπως [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Μπορείς να **ανοίξεις** ένα δηλωμένο **scheme** χρησιμοποιώντας **adb** ή έναν **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Σημειώστε ότι μπορείτε να **παραλείψετε το package name** και το κινητό θα καλέσει αυτόματα την εφαρμογή που πρέπει να ανοίξει αυτόν τον σύνδεσμο._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Κώδικας που εκτελείται**

Για να βρείτε τον **κώδικα που θα εκτελεστεί στην App**, μεταβείτε στην activity που καλείται από το deeplink και αναζητήστε τη συνάρτηση **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Ευαίσθητες πληροφορίες**

Κάθε φορά που βρίσκετε ένα deep link ελέγξτε ότι **δεν λαμβάνει ευαίσθητα δεδομένα (όπως passwords) μέσω URL παραμέτρων**, γιατί οποιαδήποτε άλλη εφαρμογή θα μπορούσε **να προσποιηθεί το deep link και να κλέψει αυτά τα δεδομένα!**

**Παράμετροι στο path**

Πρέπει επίσης να ελέγξετε αν κάποιο deep link χρησιμοποιεί παράμετρο μέσα στο path του URL όπως: `https://api.example.com/v1/users/{username}` , σε αυτή την περίπτωση μπορείτε να αναγκάσετε ένα path traversal αποκτώντας πρόσβαση σε κάτι σαν: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Σημειώστε ότι αν βρείτε τα σωστά endpoints μέσα στην εφαρμογή ενδέχεται να προκαλέσετε ένα **Open Redirect** (αν μέρος του path χρησιμοποιείται ως domain name), **account takeover** (αν μπορείτε να τροποποιήσετε λεπτομέρειες χρηστών χωρίς CSRF token και το vuln endpoint χρησιμοποιεί τη σωστή μέθοδο) και οποιαδήποτε άλλη vuln. Περισσότερες [πληροφορίες εδώ](http://dphoeniixx.com/2020/12/13-2/).

**Περισσότερα παραδείγματα**

Μια ενδιαφέρουσα αναφορά bug bounty: [https://hackerone.com/reports/855618](https://hackerone.com/reports/855618) σχετικά με links (_/.well-known/assetlinks.json_).

### Επιθεώρηση Transport Layer και αποτυχίες επαλήθευσης

- **Τα certificates δεν ελέγχονται πάντα σωστά** από τις Android εφαρμογές. Είναι σύνηθες αυτές οι εφαρμογές να αγνοούν προειδοποιήσεις και να αποδέχονται self-signed certificates ή, σε ορισμένες περιπτώσεις, να επανέρχονται σε HTTP συνδέσεις.
- **Οι διαπραγματεύσεις κατά το SSL/TLS handshake είναι μερικές φορές αδύναμες**, χρησιμοποιώντας ανασφαλείς cipher suites. Αυτή η ευπάθεια κάνει τη σύνδεση ευάλωτη σε man-in-the-middle (MITM) επιθέσεις, επιτρέποντας σε επιτιθέμενους να αποκρυπτογραφήσουν τα δεδομένα.
- Η διαρροή ιδιωτικών πληροφοριών είναι ρίσκο όταν οι εφαρμογές αυθεντικοποιούνται χρησιμοποιώντας ασφαλή κανάλια αλλά στη συνέχεια επικοινωνούν μέσω μη-ασφαλών καναλιών για άλλες συναλλαγές. Αυτή η προσέγγιση αποτυγχάνει να προστατεύσει ευαίσθητα δεδομένα, όπως session cookies ή στοιχεία χρήστη, από υποκλοπή από κακόβουλους παράγοντες.

#### Επαλήθευση πιστοποιητικού

Θα επικεντρωθούμε στην **επικύρωση πιστοποιητικών**. Η ακεραιότητα του πιστοποιητικού του server πρέπει να επαληθεύεται για να ενισχυθεί η ασφάλεια. Αυτό είναι κρίσιμο γιατί οι ανασφαλείς ρυθμίσεις TLS και η μετάδοση ευαίσθητων δεδομένων μέσω μη κρυπτογραφημένων καναλιών μπορούν να προκαλέσουν σημαντικούς κινδύνους. Για λεπτομερή βήματα σχετικά με την επαλήθευση των server certificates και την αντιμετώπιση ευπαθειών, [**αυτός ο πόρος**](https://manifestsecurity.com/android-application-security-part-10/) παρέχει ολοκληρωμένη καθοδήγηση.

#### SSL Pinning

Το SSL Pinning είναι ένα μέτρο ασφαλείας όπου η εφαρμογή επαληθεύει το πιστοποιητικό του server σε σχέση με ένα γνωστό αντίγραφο αποθηκευμένο εντός της εφαρμογής. Αυτή η μέθοδος είναι ουσιώδης για την αποτροπή MITM επιθέσεων. Η υλοποίηση του SSL Pinning συνιστάται έντονα για εφαρμογές που χειρίζονται ευαίσθητες πληροφορίες.

#### Επιθεώρηση Traffic

Για να επιθεωρήσετε HTTP traffic, είναι απαραίτητο να **εγκαταστήσετε το πιστοποιητικό του proxy tool** (π.χ. Burp). Χωρίς την εγκατάσταση αυτού του πιστοποιητικού, η κρυπτογραφημένη κίνηση ενδέχεται να μην είναι ορατή μέσω του proxy. Για οδηγό εγκατάστασης ενός custom CA certificate, [**κάντε κλικ εδώ**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Οι εφαρμογές που στοχεύουν **API Level 24 and above** απαιτούν τροποποιήσεις στο Network Security Config για να αποδεχτούν το CA certificate του proxy. Αυτό το βήμα είναι κρίσιμο για την επιθεώρηση κρυπτογραφημένης κίνησης. Για οδηγίες σχετικά με την τροποποίηση του Network Security Config, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

Εάν χρησιμοποιείται **Flutter**, πρέπει να ακολουθήσετε τις οδηγίες σε [**αυτή τη σελίδα**](flutter.md). Αυτό συμβαίνει γιατί, απλώς προσθέτοντας το πιστοποιητικό στο store δεν θα λειτουργήσει καθώς το Flutter έχει τη δική του λίστα έγκυρων CAs.

#### Στατική ανίχνευση του SSL/TLS pinning

Πριν επιχειρήσετε runtime bypasses, εντοπίστε γρήγορα πού εφαρμόζεται το pinning στο APK. Η στατική ανίχνευση βοηθά να σχεδιάσετε hooks/patches και να εστιάσετε στα σωστά code paths.

Tool: SSLPinDetect
- Open-source static-analysis utility that decompiles the APK to Smali (via apktool) and scans for curated regex patterns of SSL/TLS pinning implementations.
- Reports exact file path, line number, and a code snippet for each match.
- Covers common frameworks and custom code paths: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Χρήση
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Παραδείγματα κανόνων προτύπων (JSON)
Χρησιμοποιήστε ή επεκτείνετε signatures για να εντοπίσετε ιδιόκτητους/προσαρμοσμένους pinning styles. Μπορείτε να φορτώσετε το δικό σας JSON και να σαρώσετε σε μεγάλη κλίμακα.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes and tips
- Γρήγορο σάρωμα μεγάλων εφαρμογών μέσω multi-threading και memory-mapped I/O; pre-compiled regex μειώνει το overhead/false positives.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Τυπικοί στόχοι ανίχνευσης για επόμενη triage:
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Declarative pins in res/xml network security config and manifest references
- Χρησιμοποιήστε τις αντιστοιχισμένες τοποθεσίες για να σχεδιάσετε Frida hooks, static patches, ή ανασκοπήσεις config πριν από δυναμικές δοκιμές.



#### Παράκαμψη SSL Pinning

Όταν η SSL Pinning είναι υλοποιημένη, η παράκαμψή της γίνεται αναγκαία για την επιθεώρηση της HTTPS κίνησης. Υπάρχουν διάφορες μέθοδοι διαθέσιμες για αυτόν τον σκοπό:

- Αυτόματα **modify** το **apk** για να **bypass** το SSLPinning με [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Το μεγαλύτερο πλεονέκτημα αυτής της επιλογής είναι ότι δεν θα χρειαστείτε root για να παρακάμψετε το SSL Pinning, αλλά θα χρειαστεί να διαγράψετε την εφαρμογή και να επανεγκαταστήσετε τη νέα, και αυτό δεν θα λειτουργήσει πάντα.
- Μπορείτε να χρησιμοποιήσετε **Frida** (συζητείται παρακάτω) για να παρακάμψετε αυτήν την προστασία. Εδώ είναι ένας οδηγός για χρήση Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Μπορείτε επίσης να δοκιμάσετε να **αυτοματοποιήσετε** την παράκαμψη του SSL Pinning χρησιμοποιώντας [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Μπορείτε επίσης να δοκιμάσετε να **αυτοματοποιήσετε** την παράκαμψη του SSL Pinning χρησιμοποιώντας **MobSF dynamic analysis** (εξηγείται παρακάτω)
- Αν νομίζετε ότι υπάρχει ακόμα κίνηση που δεν καταγράφετε, μπορείτε να δοκιμάσετε να **forward the traffic to burp using iptables**. Διαβάστε αυτό το blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Αναζήτηση για Κοινές Web Ευπάθειες

Είναι σημαντικό επίσης να αναζητήσετε κοινές web ευπάθειες μέσα στην εφαρμογή. Λεπτομερείς πληροφορίες σχετικά με τον τρόπο εντοπισμού και αντιμετώπισης αυτών των ευπαθειών υπερβαίνουν το πεδίο αυτής της περίληψης αλλά καλύπτονται εκτενώς αλλού.

### Frida

[Frida](https://www.frida.re) είναι ένα dynamic instrumentation toolkit για developers, reverse-engineers, και security researchers.\
**Μπορείτε να αποκτήσετε πρόσβαση στην τρέχουσα εφαρμογή και να κάνετε hook μεθόδους κατά το runtime για να αλλάξετε τη συμπεριφορά, να αλλάξετε τιμές, να εξαγάγετε τιμές, να τρέξετε διαφορετικό κώδικα...**\
Αν θέλετε να pentest Android applications πρέπει να ξέρετε πώς να χρησιμοποιείτε το Frida.

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Some "GUI" for actions with Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- You can find some Awesome Frida scripts here: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Προσπαθήστε να παρακάμψετε μηχανισμούς anti-debugging / anti-frida φορτώνοντας το Frida όπως υποδεικνύεται στο [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (εργαλείο [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Εξαγωγή μνήμης - Fridump**

Ελέγξτε εάν η εφαρμογή αποθηκεύει ευαίσθητες πληροφορίες στη μνήμη που δεν θα έπρεπε να αποθηκεύει, όπως passwords ή mnemonics.

Using [**Fridump3**](https://github.com/rootbsd/fridump3) you can dump the memory of the app with:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Αυτό θα dump την memory στον φάκελο ./dump, και εκεί μπορείτε να grep με κάτι σαν:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Ευαίσθητα δεδομένα στο Keystore**

Στο Android το Keystore είναι το καλύτερο μέρος για την αποθήκευση ευαίσθητων δεδομένων, ωστόσο, με αρκετά προνόμια εξακολουθεί να είναι **δυνατό να αποκτηθεί πρόσβαση σε αυτό**.

Καθώς οι εφαρμογές τείνουν να αποθηκεύουν εδώ **sensitive data in clear text**, τα pentests θα πρέπει να το ελέγχουν ως root user ή άτομα με φυσική πρόσβαση στη συσκευή θα μπορούσαν να κλέψουν αυτά τα δεδομένα.

Ακόμα κι αν μια εφαρμογή αποθήκευσε δεδομένα στο keystore, αυτά θα πρέπει να είναι κρυπτογραφημένα.

Για να αποκτήσετε πρόσβαση στα δεδομένα μέσα στο keystore μπορείτε να χρησιμοποιήσετε αυτό το Frida script: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Χρησιμοποιώντας το ακόλουθο Frida script, μπορεί να είναι δυνατό να γίνει **bypass fingerprint authentication** που πιθανώς εκτελούν εφαρμογές Android προκειμένου να **protect certain sensitive areas:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Εικόνες φόντου**

Όταν βάζετε μια εφαρμογή στο παρασκήνιο, Android αποθηκεύει ένα **στιγμιότυπο της εφαρμογής** ώστε όταν επανέλθει στο προσκήνιο αρχίζει να φορτώνει την εικόνα πριν την εφαρμογή, έτσι φαίνεται ότι η εφαρμογή φορτώθηκε πιο γρήγορα.

Ωστόσο, αν αυτό το στιγμιότυπο περιέχει **ευαίσθητες πληροφορίες**, κάποιος με πρόσβαση στο στιγμιότυπο μπορεί να **κλέψει αυτές τις πληροφορίες** (σημείωση: χρειάζεστε root για να έχετε πρόσβαση).

Τα στιγμιότυπα αποθηκεύονται συνήθως εδώ: **`/data/system_ce/0/snapshots`**

Το Android παρέχει έναν τρόπο να **αποτρέψετε την καταγραφή screenshot θέτοντας το FLAG_SECURE** ως παράμετρο διάταξης. Χρησιμοποιώντας αυτή τη flag, το περιεχόμενο του παραθύρου θεωρείται ασφαλές, αποτρέποντας να εμφανίζεται σε screenshots ή να προβάλλεται σε μη ασφαλείς οθόνες.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Αυτό το εργαλείο μπορεί να σας βοηθήσει στη διαχείριση διαφόρων εργαλείων κατά τη διάρκεια της δυναμικής ανάλυσης: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Οι προγραμματιστές συχνά δημιουργούν proxy components όπως activities, services, και broadcast receivers που χειρίζονται αυτά τα Intents και τα περνούν σε μεθόδους όπως `startActivity(...)` ή `sendBroadcast(...)`, κάτι που μπορεί να είναι επικίνδυνο.

Ο κίνδυνος προκύπτει από την δυνατότητα να επιτρέψουμε σε επιτιθέμενους να ενεργοποιήσουν μη-exported components της εφαρμογής ή να αποκτήσουν πρόσβαση σε ευαίσθητους content providers κατευθύνοντας λανθασμένα αυτά τα Intents. Ένα χαρακτηριστικό παράδειγμα είναι το component `WebView` που μετατρέπει URLs σε αντικείμενα `Intent` μέσω `Intent.parseUri(...)` και στη συνέχεια τα εκτελεί, ενδεχομένως να οδηγήσει σε malicious Intent injections.

### Βασικά Συμπεράσματα

- **Intent Injection** μοιάζει με το Open Redirect θέμα στο web.
- Οι εκμεταλλεύσεις περιλαμβάνουν το πέρασμα αντικειμένων `Intent` ως extras, τα οποία μπορούν να αναδρομολογηθούν για να εκτελέσουν επικίνδυνες ενέργειες.
- Μπορεί να εκθέσει μη-exported components και content providers σε επιτιθέμενους.
- Η μετατροπή URL σε `Intent` από το `WebView` μπορεί να διευκολύνει μη-επιθυμητές ενέργειες.

### Android Client Side Injections and others

Πιθανώς γνωρίζετε αυτού του είδους τις ευπάθειες από το Web. Πρέπει να είστε ιδιαίτερα προσεκτικοί με αυτές τις ευπάθειες σε μια εφαρμογή Android:

- **SQL Injection:** Όταν χειρίζεστε δυναμικά queries ή Content-Providers βεβαιωθείτε ότι χρησιμοποιείτε παραμετροποιημένες ερωτήσεις.
- **JavaScript Injection (XSS):** Ελέγξτε ότι η υποστήριξη JavaScript και Plugin είναι απενεργοποιημένη για οποιοδήποτε WebViews (απενεργοποιημένο από προεπιλογή). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** Τα WebViews πρέπει να έχουν απενεργοποιημένη την πρόσβαση στο file system (ενεργοποιημένη από προεπιλογή) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: Σε αρκετές περιπτώσεις όταν η εφαρμογή android τελειώνει τη συνεδρία το cookie δεν αναιρείται ή ακόμα μπορεί να αποθηκευτεί στο δίσκο
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Αυτόματη Ανάλυση

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Στατική ανάλυση**

![](<../../images/image (866).png>)

**Αξιολόγηση ευπαθειών της εφαρμογής** χρησιμοποιώντας μια καλή web-based διεπαφή. Μπορείτε επίσης να πραγματοποιήσετε δυναμική ανάλυση (αλλά πρέπει να προετοιμάσετε το περιβάλλον).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Assisted Dynamic analysis with MobSF

**MobSF** can also be very helpful for **dynamic analysis** in **Android**, but in that case you will need to install MobSF and **genymotion** in your host (a VM or Docker won't work). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
The **MobSF dynamic analyser** can:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). All of this is done automatically except for the screenshots, you need to press when you want a screenshot or you need to press "**Exported Activity Tester**" to obtain screenshots of all the exported activities.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: It will print all the loaded classes
- **Capture Strings**: It will print all the capture strings while using the application (super noisy)
- **Capture String Comparisons**: Could be very useful. It will **show the 2 strings being compared** and if the result was True or False.
- **Enumerate Class Methods**: Put the class name (like "java.io.File") and it will print all the methods of the class.
- **Search Class Pattern**: Search classes by pattern
- **Trace Class Methods**: **Trace** a **whole class** (see inputs and outputs of all methods of th class). Remember that by default MobSF traces several interesting Android Api methods.

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf also brings you a shell with some **adb** commands, **MobSF commands**, and common **shell** **commands** at the bottom of the dynamic analysis page. Some interesting commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP εργαλεία**

When http traffic is capture you can see an ugly view of the captured traffic on "**HTTP(S) Traffic**" bottom or a nicer view in "**Start HTTPTools**" green bottom. From the second option, you can **send** the **captured requests** to **proxies** like Burp or Owasp ZAP.\
To do so, _ενεργοποιήστε το Burp -->_ _απενεργοποιήστε το Intercept --> στο MobSB HTTPTools επιλέξτε το request_ --> πατήστε "**Send to Fuzzer**" --> _επιλέξτε τη διεύθυνση proxy_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Μόλις ολοκληρώσετε τη dynamic analysis με MobSF μπορείτε να πατήσετε το "**Start Web API Fuzzer**" για να **fuzz http requests** an look for vulnerabilities.

> [!TIP]
> After performing a dynamic analysis with MobSF the proxy settings me be misconfigured and you won't be able to fix them from the GUI. You can fix the proxy settings by doing:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Βοηθημένη Dynamic Analysis με Inspeckage

You can get the tool from [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
This tool with use some **Hooks** to let you know **τι συμβαίνει στην εφαρμογή** while you perform a **dynamic analysis**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Αυτό είναι ένα **εξαιρετικό εργαλείο για να πραγματοποιήσετε static analysis με GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

This tool is designed to look for several **security related Android application vulnerabilities**, either in **source code** or **packaged APKs**. The tool is also **capable of creating a "Proof-of-Concept" deployable APK** and **ADB commands**, to exploit some of the found vulnerabilities (Exposed activities, intents, tapjacking...). As with Drozer, there is no need to root the test device.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Εμφανίζει όλα τα εξαγόμενα αρχεία για εύκολη αναφορά
- Αυτόματα απομεταγλωττίζει APK αρχεία σε μορφή Java και Smali
- Αναλύει το AndroidManifest.xml για κοινές ευπάθειες και συμπεριφορά
- Στατική ανάλυση πηγαίου κώδικα για κοινές ευπάθειες και συμπεριφορά
- Πληροφορίες συσκευής
- και άλλα
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

Το SUPER είναι μια command-line εφαρμογή που μπορεί να χρησιμοποιηθεί σε Windows, MacOS X και Linux, η οποία αναλύει _.apk_ αρχεία αναζητώντας ευπάθειες. Το κάνει αυτό αποσυμπιέζοντας τα APKs και εφαρμόζοντας μια σειρά κανόνων για να εντοπίσει αυτές τις ευπάθειες.

Όλοι οι κανόνες βρίσκονται σε ένα αρχείο `rules.json`, και κάθε εταιρεία ή tester μπορεί να δημιουργήσει τους δικούς του κανόνες για να αναλύσει ό,τι χρειάζεται.

Κατεβάστε τα πιο πρόσφατα binaries από τη [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

Το StaCoAn είναι ένα **crossplatform** εργαλείο που βοηθά προγραμματιστές, bugbounty hunters και ethical hackers να πραγματοποιούν [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) σε mobile εφαρμογές.

Η ιδέα είναι ότι σύρετε και αποθέτετε το αρχείο της mobile εφαρμογής σας (ένα .apk ή .ipa αρχείο) στην εφαρμογή StaCoAn και αυτή θα δημιουργήσει για εσάς μια οπτική και φορητή αναφορά. Μπορείτε να προσαρμόσετε τα settings και wordlists για να αποκτήσετε μια εξατομικευμένη εμπειρία.

Κατεβάστε[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework είναι ένα σύστημα ανάλυσης ευπαθειών για Android που βοηθά προγραμματιστές ή hackers να εντοπίσουν πιθανές ευπάθειες ασφαλείας σε εφαρμογές Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** είναι ένα εργαλείο του οποίου ο κύριος στόχος είναι να εντοπίζει και να προειδοποιεί τον χρήστη για πιθανές κακόβουλες συμπεριφορές που αναπτύσσονται από μια εφαρμογή Android.

Η ανίχνευση γίνεται με την **static analysis** του Dalvik bytecode της εφαρμογής, που αναπαρίσταται ως **Smali**, χρησιμοποιώντας τη βιβλιοθήκη [`androguard`](https://github.com/androguard/androguard).

Αυτό το εργαλείο αναζητά **συνηθισμένες συμπεριφορές "bad" εφαρμογών** όπως: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** είναι ένα **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. Είναι ένα εργαλείο που συγκεντρώνει κοινώς χρησιμοποιούμενα εργαλεία για mobile application reverse engineering και analysis, για να βοηθήσει στο testing mobile applications ενάντια στις OWASP mobile security threats. Ο στόχος του είναι να κάνει αυτή τη δουλειά πιο εύκολη και φιλική για developers εφαρμογών και security professionals.

Μπορεί να:

- Εξάγει Java και Smali κώδικα χρησιμοποιώντας διάφορα εργαλεία
- Αναλύει APKs χρησιμοποιώντας: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Εξάγει προσωπικές πληροφορίες από το APK χρησιμοποιώντας regexps.
- Αναλύει το Manifest.
- Αναλύει τα εντοπισμένα domains χρησιμοποιώντας: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) και [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate το APK μέσω [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Χρήσιμο για την ανίχνευση malware: [https://koodous.com/](https://koodous.com/)

## Απόκρυψη/Αποαπόκρυψη κώδικα

Σημειώστε ότι, ανάλογα με την υπηρεσία και τη διαμόρφωση που χρησιμοποιείτε για να obfuscate τον κώδικα, τα secrets ενδέχεται να είναι ή να μην είναι obfuscated.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

Από τη [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** είναι ένα εργαλείο γραμμής εντολών ανοιχτού κώδικα που συρρικνώνει, βελτιστοποιεί και obfuscates Java κώδικα. Είναι ικανό να βελτιστοποιεί bytecode καθώς και να εντοπίζει και να αφαιρεί μη χρησιμοποιούμενες εντολές. Το ProGuard είναι free software και διανέμεται υπό την GNU General Public License, version 2.

Το ProGuard διανέμεται ως μέρος του Android SDK και τρέχει κατά το build της εφαρμογής σε release mode.

### [DexGuard](https://www.guardsquare.com/dexguard)

Βρείτε έναν οδηγό βήμα-προς-βήμα για να deobfuscate το apk στο [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(Από αυτόν τον οδηγό) Την τελευταία φορά που ελέγξαμε, ο τρόπος λειτουργίας του Dexguard ήταν:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard αντιστρέφει τη διαδικασία της obfuscation που πραγματοποιείται από εργαλεία obfuscation για Android. Αυτό επιτρέπει πολλαπλές security αναλύσεις, συμπεριλαμβανομένης της επιθεώρησης κώδικα και της πρόβλεψης βιβλιοθηκών.**

Μπορείτε να ανεβάσετε ένα obfuscated APK στην πλατφόρμα τους.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

Αυτό είναι ένα LLM εργαλείο για να βρει πιθανές security vulnerabilities σε android apps και να deobfuscate android app code. Χρησιμοποιεί το Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

Είναι ένας generic android deobfuscator. Το Simplify virtually executes μια app για να κατανοήσει τη συμπεριφορά της και στη συνέχεια προσπαθεί να optimize τον κώδικα ώστε να συμπεριφέρεται ταυτόσημα αλλά να είναι πιο εύκολος για έναν άνθρωπο να τον καταλάβει. Κάθε τύπος optimization είναι απλός και generic, οπότε δεν έχει σημασία ποιος συγκεκριμένος τύπος obfuscation έχει χρησιμοποιηθεί.

### [APKiD](https://github.com/rednaga/APKiD)

Το APKiD σας δίνει πληροφορίες για το πώς δημιουργήθηκε ένα APK. Αναγνωρίζει πολλούς compilers, packers, obfuscators και άλλα παράξενα πράγματα. Είναι το [_PEiD_](https://www.aldeid.com/wiki/PEiD) για Android.

### Manual

[Διαβάστε αυτόν τον οδηγό για να μάθετε μερικά κόλπα για **πώς να reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

Το AndroL4b είναι μια Android security virtual machine βασισμένη σε ubuntu-mate που περιλαμβάνει μια συλλογή των πιο πρόσφατων frameworks, tutorials και labs από διάφορους security geeks και researchers για reverse engineering και malware analysis.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Είναι μια εξαιρετική λίστα πόρων
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
