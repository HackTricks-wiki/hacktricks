# Android アプリケーション Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android アプリケーションの基礎

このページを最初に読むことを強く推奨します。**Android のセキュリティに関連する最も重要な部分と、Android アプリケーション内で最も危険なコンポーネント**について知ることができます:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

これは、エミュレートまたは実機の Android デバイスに接続するための主要なツールです。\
**ADB** を使用すると、コンピュータから **USB** または **Network** 経由でデバイスを制御できます。このユーティリティは、ファイルの双方向の **copying**、アプリの **installation** と **uninstallation**、シェルコマンドの **execution**、データの **backing up**、ログの **reading** などの機能を提供します。

adb の使い方を学ぶには、次の [**ADB Commands**](adb-commands.md) を参照してください。

## Smali

場合によっては、**modify the application code** して **hidden information**（難読化されたパスワードや flags など）にアクセスすることが有益です。そのため、apk を逆コンパイルしてコードを修正し、再コンパイルすることが有効な場合があります。\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md)。この手法は、これから示す**dynamic analysis**中のいくつかのテストの代替手段として非常に有用です。したがって、この可能性を常に念頭に置いてください。

## Other interesting tricks

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- デバイスから APK を抽出する方法:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- [APKEditor](https://github.com/REAndroid/APKEditor) を使って、すべての splits と base apks をマージする:
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## ケーススタディと脆弱性


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Static Analysis

まず、APKを解析するには、decompilerを使って**Java code**を確認してください。\
Please, [**read here to find information about different available decompilers**](apk-decompilers.md).

### Looking for interesting Info

APKの**strings**を確認するだけで、**passwords**、**URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep))、**api** keys、**encryption**、**bluetooth uuids**、**tokens**などの有用な情報を探せます。コード実行の**backdoors**や認証バックドア（アプリにハードコードされた管理者資格情報）なども見つかることがあります。

**Firebase**

Firebase に特に注意して、**firebase URLs** が誤設定されていないか確認してください。 [More information about whats is FIrebase and how to exploit it here.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Basic understanding of the application - Manifest.xml, strings.xml

アプリケーションの _Manifest.xml_ および _strings.xml_ ファイルを**調査することで潜在的なセキュリティ脆弱性が明らかになることがあります**。これらのファイルは decompiler を使うか、APK の拡張子を .zip に変更して解凍することで取得できます。

**Manifest.xml** から識別される脆弱性には以下があります:

- **Debuggable Applications**: _Manifest.xml_ 内で debuggable (`debuggable="true"`) に設定されたアプリケーションは、接続を許可し悪用につながる可能性があるためリスクがあります。デバッグ可能なアプリを発見して悪用する方法については、デバイス上でのデバッグ可能アプリの検出と悪用に関するチュートリアルを参照してください。
- **Backup Settings**: 機密情報を扱うアプリでは、adb 経由での不正なデータバックアップを防ぐために `android:allowBackup="false"` を明示的に設定するべきです（特に USB デバッグが有効な場合）。
- **Network Security**: _res/xml/_ 内のカスタム network security 設定（`android:networkSecurityConfig="@xml/network_security_config"`）は、証明書ピンや HTTP トラフィック許可などのセキュリティ詳細を指定できます。特定ドメインに対して HTTP トラフィックを許可する例などが考えられます。
- **Exported Activities and Services**: マニフェストにエクスポートされた activity や service を特定することで、悪用されうるコンポーネントを浮き彫りにできます。動的テスト時にさらに解析して、それらがどのように悪用され得るかを確認してください。
- **Content Providers and FileProviders**: 公開された content provider はデータへの不正アクセスや改ざんを許す可能性があります。FileProvider の設定も入念に確認してください。
- **Broadcast Receivers and URL Schemes**: これらのコンポーネントは悪用に利用され得るため、特に URL スキームの扱いによる入力脆弱性に注意してください。
- **SDK Versions**: `minSdkVersion`、`targetSDKVersion`、`maxSdkVersion` の属性はサポートされる Android バージョンを示し、古い脆弱なバージョンをサポートしないことが重要です。

**strings.xml** ファイルからは、API keys、カスタムスキーマ、その他の開発者メモのような機密情報が発見されることがあり、これらのリソースは注意深く確認する必要があります。

### Tapjacking

Tapjacking は、悪意のあるアプリケーションが起動して被害者アプリの上に自身を配置する攻撃です。視覚的に被害者アプリを覆い隠した状態で、UI がユーザをだまして操作させ、その操作を被害者アプリへ透過させるように設計されます。結果として、ユーザは実際には被害者アプリ上で操作を行っていることに気づかなくなります。

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

`launchMode` が **`singleTask`** に設定され、かつ `taskAffinity` が定義されていない activity は Task Hijacking の対象になります。つまり、悪意あるアプリをインストールしてそのアプリを本物のアプリより先に起動すると、本物のアプリのタスクを**乗っ取る**ことができ（ユーザは本物のアプリを操作しているつもりで実は悪意あるアプリを操作している）、ユーザを騙すことができます。

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Insecure data storage

**Internal Storage**

Android では、internal storage に保存されたファイルはそれを作成したアプリのみがアクセスできるよう設計されています。これは OS によって強制され、多くのアプリケーションにとって十分なセキュリティ手段です。しかし、開発者が `MODE_WORLD_READABLE` や `MODE_WORLD_WRITABLE` といったモードを利用してファイルを他のアプリ間で共有することがあり、これらのモードは他の（悪意ある可能性のある）アプリからのアクセスを制限しません。

1. **Static Analysis:**
- `MODE_WORLD_READABLE` や `MODE_WORLD_WRITABLE` の使用を慎重に調査してください。これらのモードはファイルを意図しない、または許可されていないアクセスにさらす可能性があります。
2. **Dynamic Analysis:**
- アプリが作成するファイルに設定されている権限を確認してください。特に、ファイルが全世界で読み取り可能または書き込み可能に設定されていないかをチェックしてください。これがあると、デバイスにインストールされた任意のアプリケーションが当該ファイルを読み取ったり変更したりできる重大なリスクになります。

**External Storage**

SD カードなどの external storage 上のファイルを扱う場合は、以下の点に注意してください:

1. **Accessibility**:
- external storage 上のファイルはグローバルに読み書き可能です。つまり任意のアプリケーションやユーザがアクセスできます。
2. **Security Concerns**:
- アクセスが容易であるため、機密情報を external storage に保存しないことが推奨されます。
- external storage は取り外し可能であり、任意のアプリケーションからアクセスされ得るため安全性は低くなります。
3. **Handling Data from External Storage**:
- external storage から取得したデータに対しては常に入力バリデーションを行ってください。これはデータが信頼できないソースから来るため重要です。
- external storage に実行ファイルや class ファイルを置いて動的にロードすることは強く推奨されません。
- もしアプリが external storage から実行可能ファイルを取得しなければならない場合、それらのファイルが署名されており暗号的に検証されていることを確認してから動的にロードしてください。これはアプリのセキュリティ整合性を保つために重要です。

External storage は `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard` でアクセスできます

> [!TIP]
> Android 4.4 (**API 17**) 以降、SD カードにはアプリごとに特定のディレクトリのみへアクセスを制限するディレクトリ構造が導入されています。これにより、悪意あるアプリが別のアプリのファイルへ読み書きアクセスすることを防ぎます。

**Sensitive data stored in clear-text**

- **Shared preferences**: Android は各アプリが `/data/data/<packagename>/shared_prefs/` に XML ファイルを簡単に保存できる仕組みを提供しており、しばしばそのフォルダ内に平文で機密情報が見つかることがあります。
- **Databases**: Android は各アプリが `/data/data/<packagename>/databases/` に sqlite データベースを簡単に保存できる仕組みを提供しており、しばしばそのフォルダ内に平文で機密情報が見つかることがあります。

### Broken TLS

**Accept All Certificates**

なぜか開発者が全ての証明書を受け入れてしまうことがあり、例えばホスト名が一致しない場合でも以下のようなコード行で検証を無効にしていることがあります。
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### 暗号の脆弱性

**鍵管理プロセスが不十分**

一部の開発者は機密データをローカルストレージに保存し、コード内にハードコードまたは予測可能なキーで暗号化しています。これは避けるべきで、reversing により攻撃者が機密情報を抽出できる可能性があります。

**安全でない、または非推奨のアルゴリズムの使用**

開発者は認可の**checks**、データの**store**や**send**に**deprecated algorithms**を使用すべきではありません。これらのアルゴリズムの例: RC4, MD4, MD5, SHA1... 例えばパスワードを保存するために**hashes**を使用する場合は、ソルトを付けたブルートフォースに**resistant**なハッシュを使用するべきです。

### その他のチェック

- APKを難読化して、攻撃者によるリバースエンジニアリングの作業を困難にすることが推奨されます。
- アプリが機密性の高いものであれば（銀行系アプリなど）、独自にモバイルがrootedかどうかをチェックし、それに応じて対応するべきです。
- アプリが機密性の高いものであれば（銀行系アプリなど）、**emulator**が使用されているかをチェックすべきです。
- アプリが機密性の高いものであれば（銀行系アプリなど）、実行前に自身の整合性をチェックして改変されていないか確認すべきです。
- [**APKiD**](https://github.com/rednaga/APKiD) を使用して、APK をビルドする際にどの compiler/packer/obfuscator が使われたかを確認してください

### React Native アプリケーション

React アプリケーションの javascript コードに簡単にアクセスする方法を知るには、次のページを参照してください:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin アプリケーション

Xamarin アプリケーションの C# コードに簡単にアクセスする方法を知るには、次のページを参照してください:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked アプリケーション

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### 自動静的コード解析

ツール [**mariana-trench**](https://github.com/facebook/mariana-trench) は、アプリケーションの**code**を**scanning**することで**vulnerabilities**を検出できます。このツールは一連の**known sources**（ツールに対して**input がユーザによって制御される場所**を示す）、**sinks**（悪意あるユーザ入力が被害を引き起こす可能性のある**dangerous な場所**を示す）および**rules**を含みます。これらのルールは、脆弱性を示す**sources-sinks の組み合わせ**を定義します。

この知識により、**mariana-trench はコードをレビューして潜在的な脆弱性を見つけます**。

### Secrets leaked

アプリケーションには機密情報（API keys、passwords、hidden urls、subdomains...）が含まれている可能性があり、これらを発見できる場合があります。次のようなツールを使用できます: [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### その他の興味深い機能

- **コード実行**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **SMS送信**: `sendTextMessage, sendMultipartTestMessage`
- **ネイティブ関数**宣言（`native`）: `public native, System.loadLibrary, System.load`
- [これを読んで、**ネイティブ関数をリバースする方法**を学んでください](reversing-native-libraries.md)

### **その他のトリック**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## 動的解析

> まず、アプリケーションと必要な環境（主に Burp CA cert、Drozer、Frida）をインストールできる環境が必要です。したがって、rooted デバイス（エミュレートされているかどうかに関わらず）が強く推奨されます。

### オンライン動的解析

次のサイトで**無料アカウント**を作成できます: [https://appetize.io/](https://appetize.io/)。このプラットフォームでは APK を**upload**して**execute**できるため、APK がどのように動作するかを確認するのに便利です。

ウェブ上でアプリケーションのログを閲覧したり、**adb**で接続したりできます。

![](<../../images/image (831).png>)

ADB 接続によりエミュレータ内で **Drozer** と **Frida** を使用できます。

### ローカル動的解析

#### エミュレータを使用する場合

- [**Android Studio**](https://developer.android.com/studio)（**x86** および **arm** デバイスを作成できます。さらに [**this**](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html) によると **最新の x86** バージョンは遅い arm エミュレータを必要とせずに **ARM ライブラリをサポート**します）。
- セットアップ方法は次のページを参照してください:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **（無料版:** Personal Edition、アカウント作成が必要です。_潜在的なエラーを避けるために**VirtualBox**付きのバージョンを**ダウンロード**することを推奨します._） 
- [**Nox**](https://es.bignox.com)（無料ですが、Frida や Drozer はサポートしていません）。

> [!TIP]
> 新しいエミュレータを作成する際は、画面が大きいほどエミュレータの動作が遅くなることに注意してください。可能であれば小さい画面を選んでください。

Genymotion に **google services**（AppStore など）を**インストール**するには、次の画像の赤いマークのボタンをクリックする必要があります:

![](<../../images/image (277).png>)

また、Genymotion の **Android VM の構成**で **Bridge Network mode** を選択できることに注意してください（これは、ツールを実行する別の VM から Android VM に接続する場合に便利です）。

#### 実機を使用する場合

デバッグオプションを有効にする必要があり、可能であれば root 化することを推奨します:

1. **設定**.
2. (Android 8.0以降) **システム** を選択.
3. **端末情報** を選択.
4. **ビルド番号** を7回押す.
5. 戻ると **開発者向けオプション** が表示されます.

> アプリをインストールしたら、まず最初にそれを試して、何をするのか、どのように動作するのかを調査し、使い方に慣れてください。\
> 初期の動的解析は **MobSF dynamic analysis + pidcat** を使用して行うことをお勧めします。そうすることで、MobSF が後で確認できる多くの**興味深いデータ**をキャプチャしながら、アプリの動作を学ぶことができます。

Magisk/Zygisk クイックノート（Pixel デバイスで推奨）
- Magisk アプリで boot.img をパッチし、fastboot 経由でフラッシュして systemless root を取得する
- root 隠蔽のために Zygisk + DenyList を有効にする；より強力な隠蔽が必要な場合は LSPosed/Shamiko を検討する
- OTA アップデートから復旧できるように元の boot.img を保管しておく；各 OTA 後に再パッチする
- 画面ミラーリングにはホスト上で scrcpy を使用する

### Unintended Data Leakage

**ログ出力**

開発者は**debugging information**を公開すると機密データの leak を招く可能性があるため注意すべきです。アプリケーションログを監視して機密情報を特定・保護するには、[**pidcat**](https://github.com/JakeWharton/pidcat) と `adb logcat` を推奨します。**Pidcat** は使いやすさと可読性から好まれます。

> [!WARNING]
> **Android 4.0 以降**では、**アプリケーションは自身のログにのみアクセス可能**です。したがって、アプリは他のアプリのログにアクセスできません。\
> それでも、機密情報をログに記録しないことを推奨します。

**コピー/ペースト バッファのキャッシュ**

Android の **clipboard-based** フレームワークはアプリのコピー＆ペースト機能を可能にしますが、**他のアプリケーション**がクリップボードに**アクセス**できるため、機密データが露出するリスクがあります。クレジットカード情報など機密性の高い箇所では、コピー/ペースト機能を無効にして data leak を防ぐことが重要です。

**クラッシュログ**

アプリケーションが**クラッシュ**して**ログを保存**する場合、これらのログは特にアプリをリバースエンジニアリングできない状況で攻撃者の助けとなる可能性があります。このリスクを軽減するため、クラッシュ時のログ記録は避け、もしログをネットワーク経由で送信する必要がある場合は SSL チャネルで送信するようにしてください。

pentester として、**これらのログを確認する**ことを試みてください。

**サードパーティへ送信される分析データ**

アプリはしばしば Google Adsense のようなサービスを統合していますが、開発者の実装ミスにより機密データを意図せずに leak してしまうことがあります。潜在的な data leak を特定するには、アプリのトラフィックを intercept して、サードパーティへ送信されている機密情報がないか確認することをお勧めします。

### SQLite DBs

多くのアプリは情報を保存するために **内部の SQLite データベース** を使用します。pentest 中は作成された **databases**、**tables** や **columns** の名前、保存されているすべての **data** を確認してください。機密情報が見つかる可能性があり（それは脆弱性になります）。データベースは通常 `/data/data/the.package.name/databases` にあり、例: `/data/data/com.mwr.example.sieve/databases`

データベースが機密情報を保存しており**暗号化されている**場合でも、その**password**をアプリ内で**見つけられる**なら、それは依然として**脆弱性**です。

テーブルは `.tables` で列挙し、テーブルのカラムは `.schema <table_name>` で確認してください。

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer is s useful tool to **exploit exported activities, exported services and Content Providers** as you will learn in the following sections.

### エクスポートされた Activity の悪用

[**Android Activity とは何かを再確認したい場合はこれを読んでください。**](android-applications-basics.md#launcher-activity-and-other-activities)\
また、Activity のコードは **`onCreate`** メソッドから始まることを覚えておいてください。

**Authorisation bypass**

Activity が exported されている場合、外部アプリからその画面を呼び出せます。したがって、**sensitive information** を含む Activity が **exported** されていると、認証メカニズムを **bypass** してアクセスされる可能性があります。

[**Drozer でエクスポートされた activities を悪用する方法を学ぶ。**](drozer-tutorial/index.html#activities)

また、adb から exported activity を起動することもできます:

- PackageName は com.example.demo
- Exported ActivityName は com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> 認可バイパスが必ずしも脆弱性であるとは限らないことに注意してください。脆弱性かどうかは、バイパスの仕組みやどの情報が露出するかによります。

**機密情報漏洩**

**Activitiesは結果を返すこともあります**。exportedかつ保護されていないアクティビティが**`setResult`**メソッドを呼び出して**機密情報を返している**場合、機密情報の漏洩があります。

#### Tapjacking

Tapjackingが防止されていない場合、exportedなアクティビティを悪用して**ユーザーに予期しない操作を行わせる**ことができます。詳細は[**what is Tapjacking follow the link**](#tapjacking)を参照してください。

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providersは基本的に**データを共有する**ために使われます。アプリに利用可能なcontent providersがある場合、そこから**機密データを抽出**できる可能性があります。また、脆弱である可能性があるため、**SQL injections**や**Path Traversals**のテストを行うことも重要です。

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Serviceの動作は`onStartCommand`メソッドから始まることを覚えておいてください。

Serviceは基本的にデータを**受け取り**、それを**処理**し、（場合によっては）レスポンスを**返す**ものです。したがって、アプリがいくつかのServiceをexportしている場合は、何をしているかを理解するために**コードを確認**し、機密情報の抽出や認可回避などを目的として**動的にテスト**するべきです。\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Broadcast Receiverの動作は`onReceive`メソッドから始まることを覚えておいてください。

Broadcast receiverは特定の種類のメッセージを待ち受けます。受信側がそのメッセージをどのように処理するかによって、脆弱になる可能性があります。\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

deep linksは手動で探すこともでき、MobSFのようなツールや[このスクリプト](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py)のようなものを使えます。\
宣言された**scheme**は、**adb**や**browser**を使って**開く**ことができます：
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_注意: **パッケージ名を省略**すると、モバイルはそのリンクを開くべきアプリを自動的に呼び出します._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**実行されるコード**

アプリで**実行されるコード**を見つけるには、deeplink によって呼ばれる activity に移動し、関数 **`onNewIntent`** を検索してください。

![](<../../images/image (436) (1) (1) (1).png>)

**機密情報**

deep link を見つけたら、必ず **URL パラメータ経由で機密情報（例えば passwords）が渡されていないか** を確認してください。なぜなら他のアプリがその deep link を **なりすましてデータを盗む** 可能性があるからです！

**パス内の Parameters**

URL のパス内でパラメータを使っている deep link がないかも **必ず確認** してください。例えば `https://api.example.com/v1/users/{username}` のような場合、次のように path traversal を強制できることがあります：`example://app/users?username=../../unwanted-endpoint%3fparam=value` 。\
アプリ内で正しいエンドポイントを見つけられれば、パスの一部がドメイン名として使われていた場合の **Open Redirect**、CSRF token なしでユーザ詳細を変更できる場合の **account takeover**、その他の脆弱性を引き起こせる可能性があります。詳細は [info about this here](http://dphoeniixx.com/2020/12/13-2/) を参照してください。

**More examples**

興味深いバグバウンティレポートの例：[https://hackerone.com/reports/855618](https://hackerone.com/reports/855618)（リンクに関する報告、_/.well-known/assetlinks.json_）。

### トランスポート層の検査と検証の失敗

- **Certificates are not always inspected properly** by Android applications. 多くのアプリは警告を見落とし、self-signed certificates を受け入れたり、場合によっては HTTP 接続に戻してしまうことがあります。  
- **Negotiations during the SSL/TLS handshake are sometimes weak**, insecure な cipher suites を用いていることがあります。この脆弱性により接続が man-in-the-middle (MITM) 攻撃に対して脆弱になり、攻撃者がデータを復号できる可能性があります。  
- Leakage of private information は、アプリが認証だけ secure なチャネルを使い、他の取引を非secure なチャネルで行う場合にリスクとなります。このやり方はセッション cookie やユーザ詳細などの機密データを悪意ある第三者による傍受から守れません。

#### 証明書の検証

ここでは **certificate verification** に焦点を当てます。サーバの証明書の整合性を検証することはセキュリティ強化に不可欠です。insecure な TLS 設定や暗号化されていないチャネルで機密データを送信することは重大なリスクを招くためです。サーバ証明書の検証手順や脆弱性対応の詳細については、[**this resource**](https://manifestsecurity.com/android-application-security-part-10/) を参照してください。

#### SSL Pinning

SSL Pinning は、アプリがサーバの証明書をアプリ内に保存された既知のコピーと照合するセキュリティ対策です。この手法は MITM 攻撃を防ぐ上で重要です。機密情報を扱うアプリでは SSL Pinning の実装を強く推奨します。

#### トラフィック検査

HTTP トラフィックを検査するには、プロキシツールの証明書（例：Burp）を **インストールする必要があります**。この証明書をインストールしないと、暗号化されたトラフィックはプロキシ上で見えない可能性があります。カスタム CA 証明書のインストール手順については [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine) を参照してください。

Applications targeting **API Level 24 and above** は、プロキシの CA 証明書を受け入れるよう Network Security Config を変更する必要があります。暗号化されたトラフィックを検査するにはこの手順が重要です。Network Security Config の変更手順については [**refer to this tutorial**](make-apk-accept-ca-certificate.md) を確認してください。

もし **Flutter** を使用している場合は、[**this page**](flutter.md) の指示に従ってください。単に証明書をストアに追加するだけでは動作しないことがあり、Flutter は独自の有効な CA リストを持っているためです。

#### SSL/TLS pinning の静的検出

runtime bypass を試みる前に、まず APK 内で pinning がどこに強制されているかを素早くマップしてください。静的検出によりフック／パッチの計画が立てやすく、正しいコードパスに集中できます。

Tool: SSLPinDetect
- オープンソースの static-analysis ユーティリティで、apk を Smali（apktool 経由）にデコンパイルし、SSL/TLS pinning 実装のためにキュレーションされた regex パターンをスキャンします。  
- 各一致について正確なファイルパス、行番号、コードスニペットを報告します。  
- OkHttp CertificatePinner、カスタム `javax.net.ssl.X509TrustManager.checkServerTrusted`、`SSLContext.init`（カスタム TrustManagers/KeyManagers 使用）や Network Security Config XML pins など、一般的なフレームワークとカスタムコードパスをカバーします。

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
使い方
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
パターンルールの例 (JSON)
独自/カスタムのpinningスタイルを検出するために、signaturesを使用または拡張してください。独自のJSONを読み込み、大規模にscanを実行できます。
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
注意とヒント
- 大規模なアプリをマルチスレッディングと memory-mapped I/O で高速スキャン；事前コンパイル済みの regex はオーバーヘッドと誤検知を減らします。
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- 次にトリアージすべき典型的な検出対象:
  - OkHttp: CertificatePinner の使用、setCertificatePinner、okhttp3/okhttp パッケージ参照
  - カスタム TrustManagers: javax.net.ssl.X509TrustManager、checkServerTrusted のオーバーライド
  - カスタム SSL contexts: SSLContext.getInstance + SSLContext.init とカスタムマネージャ
  - res/xml network security config と manifest の宣言的ピン設定
  - マッチした箇所を使って、Frida フック、静的パッチ、または設定レビューを動的テストの前に計画する。

#### SSL Pinning の回避

SSL Pinning が実装されている場合、HTTPS トラフィックを検査するためにそれを回避する必要があります。目的のために利用できる方法はいくつかあります:

- 自動的に **変更** して **apk** を **バイパス** するために [**apk-mitm**](https://github.com/shroudedcode/apk-mitm) を使う。 この方法の最大の利点は、SSL Pinning を回避するのに root が不要であることだが、アプリを削除して新しいものを再インストールする必要があり、常に動作するとは限らない。
- この保護を回避するために **Frida**（後述）を使うこともできる。Burp+Frida+Genymotion を使うガイド: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- [**objection**](frida-tutorial/objection-tutorial.md) を使って **自動的に SSL Pinning をバイパス** することも試せます:**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- **MobSF dynamic analysis** を使って **自動的に SSL Pinning をバイパス** することも試せます（以下に説明）
- まだ取得できていないトラフィックがあると思われる場合は、iptables を使ってトラフィックを Burp に **転送する** ことを試せます。この記事を読む: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### 一般的な Web 脆弱性の探索

アプリ内の一般的な Web 脆弱性も検索することが重要です。これら脆弱性の特定と緩和に関する詳細はこの要約の範囲外ですが、他所で広く解説されています。

### Frida

[Frida](https://www.frida.re) は開発者、リバースエンジニア、セキュリティ研究者向けの動的インストルメンテーションツールキットです。\
**実行中のアプリケーションにアクセスしてランタイムでメソッドにフックし、振る舞いを変えたり、値を変更したり、値を抽出したり、別のコードを実行したりできます...**\
Android アプリを pentest するなら、Frida の使い方を知っておく必要があります。

- Frida の使い方を学ぶ: [**Frida tutorial**](frida-tutorial/index.html)
- Frida 操作のための「GUI」的ツール: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection は Frida の利用を自動化するのに便利: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- いくつかの Awesome Frida スクリプト: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Frida をロードして anti-debugging / anti-frida 機構を回避することを試す: [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace)（ツール [linjector](https://github.com/erfur/linjector-rs)）

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **メモリダンプ - Fridump**

アプリがパスワードやニーモニック（シードフレーズ）など、本来メモリ内に保持すべきでない機密情報を保存していないか確認してください。

[**Fridump3**](https://github.com/rootbsd/fridump3) を使うと、以下のようにアプリのメモリをダンプできます:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
これにより ./dump フォルダにメモリが dump され、そこで次のように grep できます:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Keystore内の機密データ**

AndroidではKeystoreが機密データを保存する最良の場所ですが、十分な権限があればそれでも**アクセス可能です**。  
アプリケーションはここに**平文の機密データ**を保存する傾向があるため、pentestsはこれを確認するべきです。root userやデバイスに物理的にアクセスできる者がこのデータを盗める可能性があります。

アプリがkeystoreにデータを保存している場合でも、そのデータは暗号化されているべきです。

keystore内のデータにアクセスするには、次のFridaスクリプトを使用できます: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

以下のFridaスクリプトを使用すると、Androidアプリケーションが**特定の機密領域を保護するために**実行している**bypass fingerprint authentication**を回避できる可能性があります:
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **バックグラウンド画像**

アプリをバックグラウンドに移動すると、Android はアプリケーションの**スナップショット**を保存します。これにより、フォアグラウンドに復帰したときにアプリ本体より先にその画像を読み込んで、アプリがより速く読み込まれたように見せかけます。

しかし、このスナップショットに**機密情報**が含まれている場合、スナップショットにアクセスできる者がその情報を**盗む**可能性があります（アクセスするには root が必要である点に注意してください）。

スナップショットは通常次の場所に保存されます： **`/data/system_ce/0/snapshots`**

Android は、レイアウトパラメータに FLAG_SECURE を設定することで**スクリーンショットのキャプチャを防止する方法**を提供しています。このフラグを使用するとウィンドウの内容がセキュアとして扱われ、スクリーンショットに表示されたり、非セキュアなディスプレイで表示されたりするのを防ぎます。
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

このツールは動的解析中にさまざまなツールを管理するのに役立ちます: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

開発者はしばしば activity、service、broadcast receiver のようなプロキシコンポーネントを作成し、これらの Intents を処理して `startActivity(...)` や `sendBroadcast(...)` のようなメソッドに渡すことがありますが、これはリスクを伴います。

危険なのは、攻撃者がこれらの Intents を誤誘導して non-exported なアプリコンポーネントをトリガーしたり、機密性の高い content providers にアクセスしたりできる点です。顕著な例としては、`WebView` コンポーネントが URL を `Intent.parseUri(...)` を介して `Intent` オブジェクトに変換し、それを実行することで悪意のある Intent 注入を引き起こす可能性があります。

### Essential Takeaways

- **Intent Injection** は web の Open Redirect 問題に似ています。
- エクスプロイトは `Intent` オブジェクトを extras として渡し、それがリダイレクトされて安全でない操作を実行させることを含みます。
- 非エクスポートのコンポーネントや content providers を攻撃者に晒す可能性があります。
- `WebView` の URL から `Intent` への変換が意図しない動作を引き起こすことがあります。

### Android クライアントサイドの Injections とその他

おそらく Web でこの種の脆弱性を知っているでしょう。Android アプリケーションではこれらの脆弱性に特に注意する必要があります:

- **SQL Injection:** 動的クエリや Content-Providers を扱う場合は、パラメータ化クエリを使用していることを確認してください。
- **JavaScript Injection (XSS):** 任意の WebViews では JavaScript と Plugin サポートが無効になっていることを確認してください（デフォルトでは無効）。[より詳しくはこちら](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews はファイルシステムへのアクセスを無効にしておくべきです（デフォルトで有効） - `(webview.getSettings().setAllowFileAccess(false);)`。[より詳しくはこちら](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: 多くの場合、Android アプリケーションがセッションを終了しても cookie が取り消されない、あるいはディスクに保存されてしまうことがあります。
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## 自動解析

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**静的解析**

![](<../../images/image (866).png>)

**Vulnerability assessment of the application** を使った見やすい web ベースのフロントエンドでの解析。動的解析も実行できます（ただし環境の準備が必要です）。
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Assisted Dynamic analysis with MobSF

**MobSF** can also be very helpful for **dynamic analysis** in **Android**, but in that case you will need to install MobSF and **genymotion** in your host (a VM or Docker won't work). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
The **MobSF dynamic analyser** can:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). All of this is done automatically except for the screenshots, you need to press when you want a screenshot or you need to press "**Exported Activity Tester**" to obtain screenshots of all the exported activities.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: It will print all the loaded classes
- **Capture Strings**: It will print all the capture strings while using the application (super noisy)
- **Capture String Comparisons**: Could be very useful. It will **show the 2 strings being compared** and if the result was True or False.
- **Enumerate Class Methods**: Put the class name (like "java.io.File") and it will print all the methods of the class.
- **Search Class Pattern**: Search classes by pattern
- **Trace Class Methods**: **Trace** a **whole class** (see inputs and outputs of all methods of th class). Remember that by default MobSF traces several interesting Android Api methods.

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf also brings you a shell with some **adb** commands, **MobSF commands**, and common **shell** **commands** at the bottom of the dynamic analysis page. Some interesting commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTPツール**

HTTPトラフィックをキャプチャすると、"**HTTP(S) Traffic**" ボトムでキャプチャしたトラフィックの見にくい表示が見られるか、"**Start HTTPTools**" の緑色のボタンでより見やすい表示を見ることができます。後者のオプションから、キャプチャしたリクエストを Burp や Owasp ZAP のような **プロキシ** に **送信** できます。\
To do so, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> press "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

動的解析を MobSF で終えたら、"**Start Web API Fuzzer**" を押して **fuzz http requests** を行い、脆弱性を探すことができます。

> [!TIP]
> MobSF で動的解析を行った後、プロキシ設定が誤って構成され、GUI から修正できないことがあります。プロキシ設定は以下のように修正できます：
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Inspeckage を使った支援付き動的解析

ツールは [**Inspeckage**](https://github.com/ac-pm/Inspeckage) から入手できます。\
このツールはいくつかの **Hooks** を使用して、**動的解析** を行っている間にアプリケーション内で**何が起きているか**を知らせてくれます。

### [Yaazhini](https://www.vegabird.com/yaazhini/)

これは **GUI で静的解析を行うための優れたツール** です

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

このツールは、**セキュリティ関連の Android アプリケーション脆弱性** を、**ソースコード** または **packaged APKs** のいずれかで検出するように設計されています。さらに、このツールは発見した脆弱性（Exposed activities、intents、tapjacking...）を悪用するための "Proof-of-Concept" なデプロイ可能な APK と **ADB commands** を作成することができます。Drozer と同様に、テストデバイスを root 化する必要はありません。
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- 参照しやすいように抽出されたすべてのファイルを表示します
- APKファイルを自動的にJavaおよびSmali形式にデコンパイルします
- 一般的な脆弱性や挙動についてAndroidManifest.xmlを解析します
- 静的ソースコード解析により、一般的な脆弱性や挙動を検出します
- デバイス情報
- その他多数
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER は Windows、MacOS X、Linux で利用できるコマンドラインアプリケーションで、_.apk_ ファイルを解析して脆弱性を検出します。APK を展開し、一連のルールを適用して脆弱性を見つけます。

すべてのルールは `rules.json` ファイルに集約されており、各企業やテスターは必要に応じて独自のルールを作成できます。

最新のバイナリは [download page](https://superanalyzer.rocks/download.html) からダウンロードしてください。
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn は、モバイルアプリケーションに対して [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) を行う開発者、bugbounty hunters、ethical hackers を支援する**クロスプラットフォーム**ツールです。

コンセプトは、モバイルアプリケーションファイル（.apk または .ipa ファイル）を StaCoAn アプリケーションにドラッグアンドドロップすると、視覚的で持ち運び可能なレポートを生成するというものです。設定や wordlists を調整して、カスタマイズされた体験を得ることができます。

Download[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework は、開発者や hackers が Android アプリケーションの潜在的なセキュリティ脆弱性を発見するのに役立つ脆弱性解析システムです.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** は、Android アプリケーションによって発生する可能性のある悪意のある振る舞いを検出し、ユーザーに警告することを主目的としたツールです。

検出は、[`androguard`](https://github.com/androguard/androguard) ライブラリを用いて、アプリケーションの Dalvik bytecode（**Smali** 表現）に対する **static analysis** により行われます。

このツールは、**悪意のあるアプリケーションの一般的な挙動**（例：Telephony identifiers exfiltration、Audio/video flow interception、PIM data modification、Arbitrary code execution...）を検出します。
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** は **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework の略です。一般的に使用されるモバイルアプリのリバースエンジニアリングおよび解析ツールをまとめたツールで、モバイルアプリを OWASP のモバイルセキュリティ脅威に対してテストするのを支援します。目的は、モバイルアプリ開発者やセキュリティ専門家にとってこの作業をより簡単かつ扱いやすくすることです。

It is able to:

- Extract Java and Smali code using different tools
- Analyze APKs using: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Extract private information from the APK using regexps.
- Analyze the Manifest.
- Analyze found domains using: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

malware を検出するのに有用: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Note that depending the service and configuration you use to obfuscate the code. Secrets may or may not ended obfuscated.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. It is able to optimize bytecode as well as detect and remove unused instructions. ProGuard is free software and is distributed under the GNU General Public License, version 2.

ProGuard is distributed as part of the Android SDK and runs when building the application in release mode.

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Last time we checked, the Dexguard mode of operation was:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

You can upload an obfuscated APK to their platform.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

It is a **generic android deobfuscator.** Simplify **virtually executes an app** to understand its behavior and then **tries to optimize the code** so it behaves identically but is easier for a human to understand. Each optimization type is simple and generic, so it doesn't matter what the specific type of obfuscation is used.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD gives you information about **how an APK was made**. It identifies many **compilers**, **packers**, **obfuscators**, and other weird stuff. It's [_PEiD_](https://www.aldeid.com/wiki/PEiD) for Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b は ubuntu-mate ベースの Android セキュリティ仮想マシンで、リバースエンジニアリングおよび malware 分析のための最新フレームワーク、チュートリアル、ラボを様々なセキュリティ研究者や研究家から集めたコレクションを含みます。

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) 素晴らしいリソースの一覧です
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-sslpinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)

## Yet to try

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
