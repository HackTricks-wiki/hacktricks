# Pentesting Android aplikacija

{{#include ../../banners/hacktricks-training.md}}

## Osnove Android aplikacija

Toplo se preporučuje da počnete čitanjem ove stranice kako biste saznali o **najvažnijim delovima vezanim za bezbednost Androida i najopasnijim komponentama u Android aplikaciji**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Ovo je glavni alat koji vam treba da se povežete sa Android uređajem (emuliranim ili fizičkim).\
**ADB** omogućava kontrolu uređaja preko **USB-a** ili **mreže** sa računara. Ovaj alat omogućava **kopiranje** fajlova u oba smera, **instalaciju** i **deinstalaciju** aplikacija, **izvođenje** shell komandi, **pravljenje rezervnih kopija** podataka, **čitanje** logova, između ostalih funkcija.

Pogledajte sledeću listu [**ADB Commands**](adb-commands.md) da naučite kako koristiti adb.

## Smali

Ponekad je zanimljivo da **izmenite kod aplikacije** da biste pristupili **skrivenim informacijama** (možda jako obfuskovanim lozinkama ili flagovima). U tom slučaju, može biti korisno dekompajlirati apk, izmeniti kod i ponovo ga kompilirati.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Ovo može biti veoma korisno kao **alternativa za više testova tokom dinamičke analize** koji će biti predstavljeni. Dakle, **uvek imajte na umu ovu mogućnost**.

## Ostali zanimljivi trikovi

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Play Integrity attestation spoofing (SafetyNet replacement)](play-integrity-attestation-bypass.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [Android IME / InputMethodService Abuse (Malicious Keyboards)](inputmethodservice-ime-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Izdvajanje APK-a sa uređaja:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Spojite sve splits i base apks pomoću [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Android Enterprise & Work Profile Attacks

{{#ref}}
android-enterprise-work-profile-bypass.md
{{#endref}}

## Case Studies & Vulnerabilities


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

{{#ref}}
abusing-android-media-pipelines-image-parsers.md
{{#endref}}

{{#ref}}
../../binary-exploitation/linux-kernel-exploitation/arm64-static-linear-map-kaslr-bypass.md
{{#endref}}

## Static Analysis

Pre svega, za analizu APK treba **pogledati Java kod** koristeći dekompajler.\
Molimo, [**pročitajte ovde za informacije o različitim dostupnim dekompajlerima**](apk-decompilers.md).

### Looking for interesting Info

Već samo pregledajući **strings** iz APK možete tražiti **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** i sve što deluje interesantno... tražite čak i kod za izvršavanje komandi kao **backdoors** ili autentikacione backdoore (hardcoded admin credentials u aplikaciji).

**Firebase**

Obratite posebnu pažnju na **firebase URLs** i proverite da li je loše konfigurisan. [Više informacija o tome šta je Firebase i kako ga eksploatisati ovde.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Basic understanding of the application - Manifest.xml, strings.xml

**Pregled aplikacionog _Manifest.xml_ i **_strings.xml_** fajlova može otkriti potencijalne sigurnosne propuste**. Do ovih fajlova se može doći koristeći dekompajlere ili preimenovanjem APK fajla u .zip i njegovo raspakivanje.

**Vulnerabilities** identifikovane iz **Manifest.xml** uključuju:

- **Debuggable Applications**: Aplikacije koje su označene kao debuggable (`debuggable="true"`) u _Manifest.xml_ predstavljaju rizik jer dozvoljavaju konekcije koje mogu dovesti do eksploatacije. Za dalje razumevanje kako eksploatisati debuggable aplikacije, pogledajte tutorijal o pronalaženju i eksploatisanju debuggable aplikacija na uređaju.
- **Backup Settings**: Atribut `android:allowBackup="false"` treba eksplicitno postaviti za aplikacije koje rade sa osetljivim informacijama kako bi se sprečile neautorizovane rezervne kopije podataka putem adb, naročito kada je usb debugging uključen.
- **Network Security**: Custom network security konfiguracije (`android:networkSecurityConfig="@xml/network_security_config"`) u _res/xml/_ mogu specificirati detalje sigurnosti kao što su certificate pins i podešavanja HTTP saobraćaja. Primer je dozvoljavanje HTTP saobraćaja za specifične domene.
- **Exported Activities and Services**: Identifikovanje exported activities i services u manifestu može istaći komponente koje bi mogle biti zloupotrebljene. Dalja analiza tokom dinamičkog testiranja može otkriti kako eksploatisati ove komponente.
- **Content Providers and FileProviders**: Izloženi content providers mogu dozvoliti neautorizovan pristup ili modifikaciju podataka. Konfiguraciju FileProviders takođe treba pažljivo proveriti.
- **Broadcast Receivers and URL Schemes**: Ove komponente se mogu iskoristiti za eksploataciju, sa posebnom pažnjom na to kako se URL schemes obrađuju zbog potencijalnih input ranjivosti.
- **SDK Versions**: Atributi `minSdkVersion`, `targetSDKVersion`, i `maxSdkVersion` ukazuju na podržane Android verzije, naglašavajući važnost da aplikacije ne podržavaju zastarele, ranjive Android verzije.

Iz **strings.xml** fajla mogu se otkriti osetljive informacije kao što su API keys, custom schemas i druge developerske napomene, što naglašava potrebu za pažljivim pregledom ovih resursa.

### Tapjacking

Tapjacking je napad gde se **malicious** **application** pokreće i **pozicionira iznad victim application**. Kada vizuelno zaseni žrtvinu aplikaciju, korisnički interfejs je dizajniran tako da prevari korisnika da interaguje sa njim, dok se interakcija prosleđuje žrtvinoj aplikaciji.\
U praksi, to znači da je korisnik **oslepljen i ne zna da zapravo vrši akcije u victim app**.

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Activity sa `launchMode` postavljenim na `singleTask` bez definisanog `taskAffinity` je ranjiva na Task Hijacking. To znači da se maliciozna **application** može instalirati i, ako se pokrene pre prave aplikacije, može **hijack-ovati task prave aplikacije** (tako da će korisnik interagovati sa **malicious application misleći da koristi pravu aplikaciju**).

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Insecure data storage

**Internal Storage**

U Androidu, fajlovi **smešteni** u **internal** storage su **dizajnirani** da budu **pristupačni** isključivo aplikaciji koja ih je **kreirala**. Ova mera bezbednosti je **sprovodena** od strane Android OS-a i obično je dovoljna za potrebe većine aplikacija. Međutim, developeri ponekad koriste mode kao `MODE_WORLD_READABLE` i `MODE_WORLD_WRITABLE` da bi **dozvolili** deljenje fajlova između različitih aplikacija. Ipak, ovi modovi **ne ograničavaju pristup** ovim fajlovima drugim aplikacijama, uključujući potencijalno maliciozne.

1. **Static Analysis:**
- **Proverite** upotrebu `MODE_WORLD_READABLE` i `MODE_WORLD_WRITABLE`. Ovi modovi **mogu potencijalno izložiti** fajlove neželjenom ili neautorizovanom pristupu.
2. **Dynamic Analysis:**
- **Verifikujte** permisije postavljene na fajlovima koje aplikacija kreira. Konkretno, **proverite** da li su neki fajlovi **postavljeni kao readable ili writable worldwide**. Ovo može predstavljati značajan bezbednosni rizik, jer bi omogućilo **bilo kojoj aplikaciji** instaliranoj na uređaju, bez obzira na poreklo ili nameru, da **čitaju ili modifikuju** te fajlove.

**External Storage**

Kod rada sa fajlovima na **external storage**, kao što su SD kartice, treba preduzeti određene mere opreza:

1. **Accessibility**:
- Fajlovi na external storage su **globalno readable i writable**. To znači da bilo koja aplikacija ili korisnik može pristupiti tim fajlovima.
2. **Security Concerns**:
- Zbog lakog pristupa, preporučuje se **ne čuvati osetljive informacije** na external storage.
- External storage može biti uklonjen ili mu može pristupiti bilo koja aplikacija, što ga čini manje sigurnim.
3. **Handling Data from External Storage**:
- Uvek **sprovodite input validation** na podacima preuzetim sa external storage. Ovo je ključno jer podaci dolaze iz nepoverljivog izvora.
- Odustanite od skladištenja izvršnih fajlova ili class fajlova na external storage za dinamičko učitavanje.
- Ako aplikacija mora da preuzme izvršne fajlove sa external storage, osigurajte da su ti fajlovi **potpisani i kriptografski verifikovani** pre nego što se dinamički učitaju. Ovaj korak je ključan za održavanje sigurnosnog integriteta aplikacije.

External storage može se **pristupiti** u `/storage/emulated/0`, `/sdcard`, `/mnt/sdcard`

> [!TIP]
> Počevši od Android 4.4 (**API 17**), SD kartica ima strukturu direktorijuma koja **ograničava pristup aplikaciji na direktorijum koji je specifično namenjen toj aplikaciji**. Ovo sprečava maliciozne aplikacije da dobiju read ili write pristup fajlovima druge aplikacije.

**Sensitive data stored in clear-text**

- **Shared preferences**: Android dozvoljava svakoj aplikaciji da lako sačuva xml fajlove u putanji `/data/data/<packagename>/shared_prefs/` i ponekad je moguće naći osetljive informacije u clear-text u tom folderu.
- **Databases**: Android dozvoljava svakoj aplikaciji da lako sačuva sqlite baze podataka u putanji `/data/data/<packagename>/databases/` i ponekad je moguće naći osetljive informacije u clear-text u tom folderu.

### Broken TLS

**Accept All Certificates**

Iz nekog razloga, ponekad developeri prihvataju sve sertifikate čak i ako, na primer, hostname ne odgovara, sa linijama koda poput sledeće:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Dobar način da ovo testirate je pokušaj presretanja saobraćaja koristeći neki proxy kao Burp bez autorizovanja Burp CA unutar uređaja. Takođe, možete u Burp-u generisati sertifikat za drugačiji hostname i koristiti ga.

### Slaba kriptografija

**Loši procesi upravljanja ključevima**

Neki developeri čuvaju osetljive podatke u lokalnoj memoriji i šifruju ih ključem hardkodovanim/predvidljivim u kodu. To se ne bi smelo raditi jer reverse engineering može omogućiti napadačima da izvuku poverljive informacije.

**Korišćenje nesigurnih i/ili zastarelih algoritama**

Developeri ne bi trebalo da koriste **deprecated algorithms** za izvođenje autorizacionih **provera**, za **čuvanje** ili **slanje** podataka. Neki od ovih algoritama su: RC4, MD4, MD5, SHA1... Ako se, na primer, koriste **hashes** za čuvanje lozinki, treba koristiti hash-e otpornije na brute-force u kombinaciji sa salt-om.

### Ostale provere

- Preporučuje se da **obfuskujete APK** kako biste otežali reverse engineering napadačima.
- Ako je aplikacija osetljiva (kao bankarske aplikacije), treba da izvrši svoje **provere da li je mobilni uređaj root-ovan** i postupiti u skladu s tim.
- Ako je aplikacija osetljiva (kao bankarske aplikacije), treba da proveri da li se koristi **emulator**.
- Ako je aplikacija osetljiva (kao bankarske aplikacije), treba da **proveri sopstveni integritet pre izvršavanja** kako bi utvrdila da li je izmenjena.
- Koristite [**APKiD**](https://github.com/rednaga/APKiD) da proverite koji compiler/packer/obfuscator je korišćen za izgradnju APK-a

### React Native Application

Pročitajte sledeću stranicu da naučite kako lako pristupiti javascript kodu React aplikacija:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Pročitajte sledeću stranicu da naučite kako lako pristupiti C# kodu Xamarin aplikacija:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

Prema ovom [**blog postu**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked je Meta algoritam koji kompresuje sadržaj aplikacije u jednu datoteku. Blog govori o mogućnosti kreiranja aplikacije koja dekompresuje ovakve aplikacije... i o bržem načinu koji uključuje **pokretanje aplikacije i prikupljanje dekompresovanih fajlova iz fajl-sistema.**

### Automated Static Code Analysis

Alat [**mariana-trench**](https://github.com/facebook/mariana-trench) je sposoban da pronađe **vulnerabilities** skeniranjem **code** aplikacije. Ovaj alat sadrži niz **known sources** (koji označavaju mestu gde je **input** **controlled by the user**), **sinks** (koji označavaju **dangerous** **places** gde maliciozni user input može uzrokovati štetu) i **rules**. Ova pravila ukazuju na **combination** of **sources-sinks** koje ukazuju na ranjivost.

Sa tim znanjem, **mariana-trench će pregledati code i pronaći moguće vulnerabilities u njemu**.

### Otkrivene tajne

Aplikacija može sadržati tajne (API keys, passwords, hidden urls, subdomains...) u sebi koje možete otkriti. Možete koristiti alat kao što je [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Ostale zanimljive funkcije

- **Izvršavanje koda**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Slanje SMS-ova**: `sendTextMessage, sendMultipartTestMessage`
- **Native funkcije** deklarisane kao `native`: `public native, System.loadLibrary, System.load`
- [Pročitajte ovo da naučite **kako reverzno analizirati native funkcije**](reversing-native-libraries.md)
- Izvršavanje native koda u memoriji preko JNI (preuzet shellcode → mmap/mprotect → poziv):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Ostali trikovi**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dinamička analiza

> Prvo, potrebno je okruženje gde možete instalirati aplikaciju i celo okruženje (Burp CA cert, Drozer i Frida pre svega). Dakle, root-ovan uređaj (emuliran ili ne) se toplo preporučuje.

### Online dinamička analiza

Možete kreirati **besplatan nalog** na: [https://appetize.io/](https://appetize.io). Ova platforma omogućava da **upload-ujete** i **execute-ujete** APK-ove, pa je korisna da vidite kako se APK ponaša.

Možete čak **videti logove vaše aplikacije** na webu i povezati se preko **adb**.

![](<../../images/image (831).png>)

Zahvaljujući ADB konekciji možete koristiti **Drozer** i **Frida** unutar emulatora.

### Lokalna dinamička analiza

#### Korišćenje emulatora

- [**Android Studio**](https://developer.android.com/studio) (Možete kreirati **x86** i **arm** uređaje, i prema [**ovome**](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html) najnovije **x86** verzije **podržavaju ARM biblioteke** bez potrebe za sporim arm emulatorom).
- Naučite kako ga podesiti na ovoj stranici:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Besplatna verzija:** Personal Edition, potrebno je kreirati nalog. _Preporučuje se da **download-ujete** verziju **SA** _**VirtualBox** kako biste izbegli potencijalne greške._)
- [**Nox**](https://es.bignox.com) (Besplatno, ali ne podržava Frida ili Drozer).

> [!TIP]
> Kada kreirate novi emulator na bilo kojoj platformi, imajte na umu da što je ekran veći, to će emulator raditi sporije. Zato izaberite male ekrane ako je moguće.

Da biste **instalirali google services** (kao AppStore) u Genymotionu potrebno je kliknuti na crveno obeleženo dugme na sledećoj slici:

![](<../../images/image (277).png>)

Takođe, obratite pažnju da u **konfiguraciji Android VM-a u Genymotionu** možete izabrati **Bridge Network mode** (ovo će biti korisno ako se budete povezivali na Android VM iz druge VM sa alatima).

#### Korišćenje fizičkog uređaja

Treba da aktivirate opcije **debugging-a** i bilo bi dobro ako možete da ga **root-ujete**:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Kada instalirate aplikaciju, prvo što treba da uradite je da je isprobate, istražite šta radi, kako radi i da se upoznate sa njom. Predlažem da **izvršite ovu inicijalnu dinamičku analizu koristeći MobSF dynamic analysis + pidcat**, tako da ćemo moći da **naučimo kako aplikacija radi** dok MobSF **hvata** mnogo **zanimljivih** **podataka** koje možete kasnije pregledati.

Magisk/Zygisk kratke napomene (preporučeno za Pixel uređaje)
- Patch-ujte boot.img pomoću Magisk aplikacije i flash-ujte preko fastboot-a da biste dobili systemless root
- Omogućite Zygisk + DenyList za skrivanje roota; razmislite o LSPosed/Shamiko kada je potrebno snažnije skrivanje
- Sačuvajte originalni boot.img za oporavak nakon OTA update-a; ponovo ga patch-ujte nakon svakog OTA
- Za screen mirroring, koristite scrcpy na hostu



### Neočekivano curenje podataka

**Logovanje**

Developeri bi trebali biti oprezni pri izlaganju **debugging information** javno, jer to može dovesti do curenja osetljivih podataka. Preporučuju se alati [**pidcat**](https://github.com/JakeWharton/pidcat) i `adb logcat` za praćenje logova aplikacije kako biste identifikovali i zaštitili osetljive informacije. **Pidcat** je omiljen zbog jednostavnosti upotrebe i čitljivosti.

> [!WARNING]
> Imajte na umu da od **verzija novijih od Android 4.0**, **aplikacije mogu pristupiti samo svojim logovima**. Dakle, aplikacije ne mogu pristupiti logovima drugih aplikacija.\
> Ipak, i dalje se preporučuje da **ne logujete osetljive informacije**.

**Keširanje copy/paste bafera**

Android-ov **clipboard-based** framework omogućava copy-paste funkcionalnost u aplikacijama, ali predstavlja rizik jer **druge aplikacije** mogu **pristupiti** clipboard-u, potencijalno otkrivajući osetljive podatke. Ključno je **onemogućiti copy/paste** funkcije za osetljive delove aplikacije, kao što su podaci o kreditnoj kartici, kako biste sprečili curenje podataka.

**Crash logovi**

Ako aplikacija **crashes** i **čuva logove**, ti logovi mogu pomoći napadačima, naročito kada aplikacija ne može biti reverse-engineered. Da biste ublažili ovaj rizik, izbegavajte logovanje pri crash-ovima, i ako logovi moraju biti poslati preko mreže, osigurajte da su poslati putem SSL kanala radi sigurnosti.

Kao pentester, **pokušajte da pogledate te logove**.

**Analytics podaci poslati trećim stranama**

Aplikacije često integrišu servise poput Google Adsense, što može nenamerno dovesti do curenja osetljivih podataka zbog nepravilne implementacije od strane developera. Da biste identifikovali potencijalno curenje podataka, preporučuje se da **presretnete saobraćaj aplikacije** i proverite da li se bilo kakve osetljive informacije šalju ka servisima trećih strana.

### SQLite baze podataka

Većina aplikacija koristi **internal SQLite databases** za čuvanje informacija. Tokom pentesta pogledajte **baze podataka** koje su kreirane, imena **tabela** i **kolona** i sve sačuvane **podatke**, jer možete pronaći **osetljive informacije** (što bi predstavljalo ranjivost).\
Baze podataka bi trebale biti locirane u `/data/data/the.package.name/databases` kao `/data/data/com.mwr.example.sieve/databases`

Ako baza čuva poverljive informacije i **šifrovana je**, ali možete **pronaći** **password** unutar aplikacije, to je i dalje **vulnerability**.

Enumerišite tabele koristeći `.tables` i enumerišite kolone tabela koristeći `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

Iz [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** vam omogućava da preuzmete ulogu Android aplikacije i komunicirate sa drugim aplikacijama. Može uraditi bilo šta što instalirana aplikacija može, kao što je korišćenje Android’s Inter-Process Communication (IPC) mehanizma i interakcija sa osnovnim operativnim sistemom.\
Drozer je koristan alat za **eksploatisanje exported activities, exported services i Content Providers** kao što ćete naučiti u narednim sekcijama.

### Eksploatisanje exportovanih Activities

[**Pročitajte ovo ako želite da osvežite šta je Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Takođe zapamtite da kod aktivnosti počinje u **`onCreate`** metodi.

**Authorisation bypass**

Kada je Activity exportovan, možete pozvati njegov ekran iz eksterne aplikacije. Dakle, ako je aktivnost sa **osetljivim informacijama** **exported**, mogli biste **zaobići** **authentication** mehanizme da biste joj pristupili.

[**Naučite kako eksploatisati exported activities pomoću Drozer-a.**](drozer-tutorial/index.html#activities)

Takođe možete pokrenuti exportovanu aktivnost iz adb-a:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF će označiti kao maliciozno korišćenje _**singleTask/singleInstance**_ kao `android:launchMode` u jednoj activity, ali zbog [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), izgleda da je to opasno samo na starim verzijama (API versions < 21).

> [!TIP]
> Imajte na umu da authorisation bypass nije uvek ranjivost; zavisi od načina na koji bypass funkcioniše i koje informacije su izložene.

**Sensitive information leakage**

**Activities can also return results**. Ako uspete da pronađete eksportovanu i nezaštićenu activity koja poziva metod **`setResult`** i **vraća osetljive informacije**, dolazi do curenja osetljivih informacija.

#### Tapjacking

Ako Tapjacking nije sprečen, možete zloupotrebiti eksportovanu activity da navedete **korisnika da izvrši neočekivane radnje**. Za više informacija o [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers se uglavnom koriste za **deljenje podataka**. Ako aplikacija ima dostupne content provider-e, moguće je da ćete moći da **izvučete osetljive** podatke iz njih. Takođe je korisno testirati moguće **SQL injections** i **Path Traversals**, jer mogu biti ranjivi.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Zapamtite da se radnje Service počinju u metodu `onStartCommand`.

Service je, u suštini, nešto što **može primiti podatke**, **obraditi** ih i **vratiti** (ili ne) odgovor. Dakle, ako aplikacija eksportuje neke servise, trebalo bi da **proverite** **kod** da biste razumeli šta radi i da ga **testirate** **dinamički** radi izvlačenja poverljivih informacija, zaobilaženja mera autentifikacije...
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Zapamtite da se radnje Broadcast Receiver-a pokreću u metodu `onReceive`.

Broadcast receiver će čekati određenu vrstu poruke. U zavisnosti od toga kako receiver obrađuje poruku, može biti ranjiv.
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Možete ručno tražiti deep links, koristeći alate poput MobSF ili skripte poput [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Možete **otvoriti** deklarisani **scheme** koristeći **adb** ili **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Imajte na umu da možete **izostaviti ime paketa** i mobilni će automatski pozvati aplikaciju koja treba da otvori taj link._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Kod koji se izvršava**

Da biste pronašli **kod koji će biti izvršen u App-u**, otvorite aktivnost koju poziva deeplink i potražite funkciju **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Sensitive info**

Svaki put kada pronađete deep link proverite da li **ne prima sensitive data (like passwords) via URL parameters**, jer bilo koja druga aplikacija može **impersonate the deep link and steal that data!**

**Parameters in path**

Morate takođe da proverite da li neki deep link koristi parametar unutar path-a URL-a kao npr: `https://api.example.com/v1/users/{username}` , u tom slučaju možete prouzrokovati path traversal pristupom nečemu poput: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Imajte na umu da ako pronađete tačne endpoints unutar aplikacije možete izazvati **Open Redirect** (ako je deo path-a korišćen kao domain name), **account takeover** (ako možete izmeniti users details bez CSRF token i ranjivi endpoint koristi odgovarajući metod) i bilo koju drugu vuln. Više [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Transport Layer Inspection and Verification Failures

- **Certificates are not always inspected properly** od strane Android aplikacija. Često ove aplikacije zanemare upozorenja i prihvate self-signed certificates ili, u nekim slučajevima, vrate se na korišćenje HTTP konekcija.
- **Negotiations during the SSL/TLS handshake are sometimes weak**, koristeći insecure cipher suites. Ova ranjivost čini konekciju podložnom man-in-the-middle (MITM) napadima, omogućavajući napadačima da dešifruju podatke.
- **Leakage of private information** predstavlja rizik kada se aplikacije autentifikuju koristeći secure channels, ali zatim komuniciraju preko non-secure channels za druge transakcije. Ovakav pristup ne štiti sensitive data, kao što su session cookies ili user details, od presretanja od strane zlonamernih entiteta.

#### Certificate Verification

Fokusiraćemo se na **certificate verification**. Integritet serverovog certifikata mora biti verifikovan radi poboljšanja sigurnosti. Ovo je ključno zato što insecure TLS konfiguracije i slanje sensitive data preko nekriptovanih kanala mogu predstavljati značajne rizike. Za detaljne korake o verifikaciji serverovih certifikata i rešavanju ranjivosti, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) daje sveobuhvatne smernice.

#### SSL Pinning

SSL Pinning je mera bezbednosti gde aplikacija verifikuje serverov sertifikat upoređujući ga sa poznatom kopijom koja je smeštena unutar aplikacije. Ova metoda je bitna za sprečavanje MITM napada. Implementacija SSL Pinning-a se snažno preporučuje za aplikacije koje rukuju sensitive information.

#### Traffic Inspection

Da biste pregledali HTTP saobraćaj, neophodno je **install the proxy tool's certificate** (npr. Burp). Bez instaliranja tog certifikata, enkriptovani saobraćaj možda neće biti vidljiv kroz proxy. Za vodič o instaliranju custom CA certificate, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Aplikacije target-ovane na **API Level 24 and above** zahtevaju izmene u Network Security Config da bi prihvatile proxy-ev CA certificate. Ovaj korak je kritičan za inspekciju enkriptovanog saobraćaja. Za uputstva o modifikaciji Network Security Config, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

Ako se koristi **Flutter** potrebno je pratiti instrukcije na [**this page**](flutter.md). To je zato što samo dodavanje certifikata u store neće raditi, jer Flutter ima sopstvenu listu valid CAs.

#### Static detection of SSL/TLS pinning

Pre nego što pokušate runtime bypasses, brzo mapirajte gde je pinning enforced u APK-u. Static discovery vam pomaže da planirate hooks/patches i fokusirate se na prave code paths.

Tool: SSLPinDetect
- Open-source static-analysis utility koja dekompajlira APK u Smali (preko apktool) i skenira curated regex patterns SSL/TLS pinning implementacija.
- Izveštava tačnu file path, line number, i code snippet za svaki match.
- Pokriva common frameworks i custom code paths: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init sa custom TrustManagers/KeyManagers, i Network Security Config XML pins.

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Upotreba
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Primer pravila obrazaca (JSON)
Koristite ili proširite signatures da biste otkrili vlasničke/prilagođene pinning stilove. Možete učitati sopstveni JSON i skenirati u velikom obimu.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Beleške i saveti
- Brzo skeniranje velikih aplikacija pomoću multi-threading i memory-mapped I/O; prekompajlirani regex smanjuje overhead/lažno pozitivne rezultate.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Tipični ciljevi detekcije za dalju trijažu:
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Declarative pins in res/xml network security config and manifest references
- Iskoristite podudarna mesta da isplanirate Frida hooks, static patches, ili pregled konfiguracija pre dinamičkog testiranja.



#### Zaobilaženje SSL Pinninga

Kada je implementiran SSL Pinning, njegovo zaobilaženje postaje neophodno za inspekciju HTTPS saobraćaja. Za ovu svrhu dostupne su različite metode:

- Automatski **izmenite** the **apk** da biste **zaobišli** SSLPinning koristeći [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Najveća prednost ove opcije je što nećete trebati root da zaobiđete SSL Pinning, ali ćete morati obrisati aplikaciju i ponovo instalirati novu verziju, i ovo neće uvek raditi.
- Možete koristiti **Frida** (opisano dole) da zaobiđete ovu zaštitu. Vodič za korišćenje Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Takođe možete pokušati **automatski zaobići SSL Pinning** koristeći [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Takođe možete pokušati **automatski zaobići SSL Pinning** koristeći **MobSF dynamic analysis** (objašnjeno dole)
- Ako i dalje mislite da postoji saobraćaj koji ne presrećete, možete pokušati **preusmeriti saobraćaj na burp koristeći iptables**. Pročitajte ovaj blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Pretraga uobičajenih web ranjivosti

Važno je takođe pretražiti aplikaciju za uobičajene web ranjivosti. Detaljne informacije o identifikaciji i otklanjanju ovih ranjivosti su izvan opsega ovog sažetka, ali su obimno pokrivene drugde.

### Frida

[Frida](https://www.frida.re) je alat za dinamičku instrumentaciju za developere, reverse-engineere i security istraživače.\
**Možete pristupiti pokrenutoj aplikaciji i hook-ovati metode u runtime-u da biste promenili ponašanje, menjali vrednosti, ekstrahovali vrednosti, izvršavali drugi kod...**\
Ako želite da pentest Android applications morate znati kako da koristite Frida.

- Naučite kako da koristite Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Neki "GUI" za rad sa Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection je odličan za automatizaciju korišćenja Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Možete pronaći neke Awesome Frida skripte ovde: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Pokušajte da zaobiđete anti-debugging / anti-frida mehanizme učitavanjem Frida kako je prikazano u [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (alat [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

Proverite da li aplikacija čuva osetljive informacije u memoriji koje ne bi trebala čuvati, kao što su lozinke ili mnemonici.

Korišćenjem [**Fridump3**](https://github.com/rootbsd/fridump3) možete dump-ovati memoriju aplikacije pomoću:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Ovo će dump memoriju u ./dump folderu, i tamo možete pokrenuti grep sa nečim poput:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Osetljivi podaci u Keystore**

U Androidu Keystore je najbolje mesto za čuvanje osetljivih podataka, međutim, uz dovoljne privilegije i dalje je **moguće pristupiti njemu**. Pošto aplikacije često ovde čuvaju **osetljive podatke u čistom tekstu**, pentests bi trebalo da to provere, jer bi root user ili neko sa fizičkim pristupom uređaju mogao da ukrade te podatke.

Čak i ako aplikacija čuva podatke u Keystore-u, podaci bi trebalo da budu šifrovani.

Da biste pristupili podacima unutar Keystore-a možete koristiti ovaj Frida script: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Korišćenjem sledećeg Frida skripta može biti moguće **bypass fingerprint authentication** koje Android aplikacije mogu koristiti kako bi **zaštitile određene osetljive oblasti:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Pozadinske slike**

Kada aplikaciju pošaljete u pozadinu, Android čuva **snimak aplikacije** tako da kada se vrati u prvi plan počne da učitava tu sliku pre same aplikacije, pa izgleda kao da je aplikacija brže učitana.

Međutim, ako taj snimak sadrži **osetljive informacije**, neko ko ima pristup snimku može **ukrasti te informacije** (napomena: potreban je root da bi se pristupilo).

Snimci se obično čuvaju na lokaciji: **`/data/system_ce/0/snapshots`**

Android pruža način da se **onemogući pravljenje snimaka ekrana postavljanjem FLAG_SECURE** layout parametra. Korišćenjem ovog flag-a, sadržaj prozora se tretira kao siguran, sprečavajući njegovo pojavljivanje na snimcima ekrana ili pregled na nesigurnim ekranima.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Analizator Android aplikacija**

Ovaj alat može pomoći pri upravljanju različitim alatima tokom dinamičke analize: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Developeri često kreiraju proxy komponente kao što su activities, services i broadcast receivers koje obrađuju ove Intents i prosleđuju ih metodama kao što su `startActivity(...)` ili `sendBroadcast(...)`, što može biti rizično.

Opasnost je u tome što se napadačima može omogućiti da pokrenu non-exported komponente aplikacije ili pristupe osetljivim content providers preusmeravanjem ovih Intents. Značajan primer je `WebView` komponenta koja konvertuje URL-ove u `Intent` objekte preko `Intent.parseUri(...)` i zatim ih izvršava, što može dovesti do malicioznih Intent injectiona.

### Suštinski zaključci

- **Intent Injection** je sličan web Open Redirect issue-u.
- Eksploatacije uključuju prosleđivanje `Intent` objekata kao extras, koji mogu biti preusmereni da izvrše nesigurne operacije.
- Može izložiti non-exported komponente i content providers napadačima.
- `WebView`-ova konverzija URL-a u `Intent` može omogućiti nepredviđene akcije.

### Android Client Side Injections and others

Verovatno ste upoznati sa ovakvim vrstama ranjivosti sa Web-a. Morate biti posebno pažljivi sa ovim ranjivostima u Android aplikaciji:

- **SQL Injection:** Kada radite sa dinamičkim upitima ili Content-Providers, obavezno koristite parameterized queries.
- **JavaScript Injection (XSS):** Proverite da li je JavaScript i Plugin podrška onemogućena za bilo koje WebViews (disabled by default). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews treba onemogućiti pristup fajl sistemu (enabled by default) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: U nekoliko slučajeva kada android aplikacija završi sesiju, cookie nije opozvan ili može biti sačuvan na disku.
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatska analiza

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Static analysis**

![](<../../images/image (866).png>)

**Vulnerability assessment of the application** pomoću lepog web-based frontenda. Takođe možete izvršiti dynamic analysis (ali morate pripremiti okruženje).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Assisted Dynamic analysis with MobSF

**MobSF** može biti veoma koristan za **dynamic analysis** na **Android**-u, ali u tom slučaju treba da instalirate MobSF i **genymotion** na vaš host (a VM or Docker won't work). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
The **MobSF dynamic analyser** can:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). Sve ovo se radi automatski osim za screenshots — morate pritisnuti kada želite screenshot ili pritisnuti "**Exported Activity Tester**" da biste dobili screenshot-ove svih exported activities.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: Ispisaće sve učitane klase
- **Capture Strings**: Ispisaće sve capture strings dok koristite aplikaciju (super noisy)
- **Capture String Comparisons**: Može biti veoma korisno. Pokazaće **2 strings being compared** i da li je rezultat True ili False.
- **Enumerate Class Methods**: Unesite ime klase (like "java.io.File") i ispiše sve metode klase.
- **Search Class Pattern**: Pretražuje klase po pattern-u
- **Trace Class Methods**: **Trace** celu klasu (vidi ulaze i izlaze svih metoda klase). Zapamtite da po defaultu MobSF trace-uje nekoliko interesantnih Android Api metoda.

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf takođe pruža shell sa nekim **adb** commands, **MobSF commands**, i uobičajenim **shell** **commands** na dnu stranice za dynamic analysis. Some interesting commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP alati**

When http traffic is capture you can see an ugly view of the captured traffic on "**HTTP(S) Traffic**" bottom or a nicer view in "**Start HTTPTools**" green bottom. From the second option, you can **send** the **captured requests** to **proxies** like Burp or Owasp ZAP.\
To do so, _uključite Burp -->_ _isključite Intercept --> u MobSB HTTPTools izaberite request_ --> pritisnite "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Once you finish the dynamic analysis with MobSF you can press on "**Start Web API Fuzzer**" to **fuzz http requests** an look for vulnerabilities.

> [!TIP]
> Nakon performing a dynamic analysis with MobSF proxy podešavanja mogu biti misconfigured i you won't be able to fix them from the GUI. Možete popraviti proxy podešavanja izvršavanjem:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Asistirana dinamička analiza sa Inspeckage

You can get the tool from [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Ovaj alat koristi neke **Hooks** da vam pokaže **šta se dešava u aplikaciji** dok vršite **dynamic analysis**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Ovo je **great tool to perform static analysis with a GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Ovaj alat je dizajniran da traži više **security related Android application vulnerabilities**, bilo u **source code** ili u **packaged APKs**. Alat je takođe **capable of creating a "Proof-of-Concept" deployable APK** i **ADB commands**, da eksploatiše neke od pronađenih ranjivosti (Exposed activities, intents, tapjacking...). Kao i sa Drozer, nema potrebe da root-ujete test uređaj.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Prikazuje sve ekstrahovane fajlove radi lakšeg pregleda
- Automatski decompile APK fajlove u Java i Smali format
- Analizira AndroidManifest.xml za česte ranjivosti i ponašanje
- Statička analiza izvornog koda za česte ranjivosti i ponašanje
- Informacije o uređaju
- i još
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER je aplikacija komandne linije koja se može koristiti na Windows, MacOS X i Linux, i koja analizira _.apk_ fajlove u potrazi za ranjivostima. To radi dekompresovanjem APK-ova i primenom niza pravila kako bi detektovala te ranjivosti.

Sva pravila su smeštena u fajlu `rules.json`, i svaka kompanija ili tester može da kreira sopstvena pravila za analizu onoga što im treba.

Preuzmite najnovije binarne fajlove sa [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn je **cross-platform** alat koji pomaže developerima, bugbounty hunterima i etičkim hakerima pri izvođenju [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) na mobilnim aplikacijama.

Koncept je da prevučete i ispustite fajl vaše mobilne aplikacije (an .apk or .ipa file) na StaCoAn aplikaciju i ona će vam generisati vizuelni i prenosivi izveštaj. Možete prilagoditi podešavanja i wordlists da biste dobili prilagođeno iskustvo.

Preuzmi[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework je sistem za analizu ranjivosti za Android koji pomaže developerima ili hackers da pronađu potencijalne sigurnosne ranjivosti u Android aplikacijama.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** je alat čiji je glavni cilj da otkrije i upozori korisnika na potencijalna maliciozna ponašanja koju razvije Android aplikacija.

Detekcija se vrši pomoću **static analysis** Dalvik bytecode aplikacije, predstavljenog kao **Smali**, uz korišćenje biblioteke [`androguard`](https://github.com/androguard/androguard).

Ovaj alat traži **uobičajeno ponašanje "loših" aplikacija** kao što su: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** је оквир за реверзно инжењерство и анализу мобилних апликација. То је алат који окупља често коришћене алате за реверзно инжењерство и анализу мобилних апликација, како би помогао при тестирању мобилних апликација против OWASP мобилних претњи. Циљ је да овај посао учини лакшим и приступачнијим развијачима мобилних апликација и безбедносним професионалцима.

Може:

- Извући Java и Smali код користећи различите алате
- Анализирати APK-ове користећи: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Извући приватне информације из APK-а користећи regexps.
- Анализирати Manifest.
- Анализирати пронађене домене користећи: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) и [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Деобфускирати APK преко [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Корисно за откривање малвера: [https://koodous.com/](https://koodous.com/)

## Обфускирање/Деобфускирање кода

Имајте на уму да, у зависности од сервиса и конфигурације које користите за обфускацију кода, тајне можда хоће, а можда и неће бити обфускиране.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

Према [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** је алат отвореног кода са командном линијом који смањује, оптимизује и обфускира Java код. Може да оптимизује bytecode, као и да открије и уклони неискоришћена упутства. ProGuard је слободан софтвер и дистрибуиран је под GNU General Public License, верзија 2.

ProGuard се дистрибуира као део Android SDK-а и покреће се при грађењу апликације у release режиму.

### [DexGuard](https://www.guardsquare.com/dexguard)

Пронађите водич корак-по-корак за деобфускацију apk-а на [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(Према том водичу) Последњи пут када смо проверили, начин рада DexGuard-а је био:

- учита ресурс као InputStream;
- проследи резултат класи која наследује FilterInputStream да би га дешифровала;
- уради неку бескорисну обфускацију да потроши неколико минута реверсера;
- проследи дешифрован резултат у ZipInputStream да би добио DEX фајл;
- на крају учита добијени DEX као Resource користећи `loadDex` метод.

### [DeGuard](http://apk-deguard.com)

**DeGuard поништава процес обфускације који изводе Android обфускацијски алати. Ово омогућава бројне безбедносне анализе, укључујући инспекцију кода и предвиђање библиотека.**

Можете отпремити обфускирани APK на њихову платформу.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

Ово је LLM алат за проналажење потенцијалних безбедносних рањивости у Android апликацијама и деобфускацију Android кода апликација. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

То је општи android deobfuscator. Simplify виртуелно извршава апликацију да би разумео њено понашање и затим покушава да оптимизује код тако да се понаша идентично, али је лакши за разумевање човеку. Свака врста оптимизације је једноставна и генерализована, па није важно који конкретан тип обфускације је коришћен.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD вам даје информацију о томе **how an APK was made**. Идентификује многе **compilers**, **packers**, **obfuscators**, и друге чудне ствари. То је [_PEiD_](https://www.aldeid.com/wiki/PEiD) за Android.

### Manual

[Прочитајте овај туторијал да научите неке трикове о томе **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Лабораторије

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b је виртуелна машина за Android безбедност заснована на ubuntu-mate која укључује збирку најновијих framework-ова, туторијала и лабораторија од различитих безбедносних ентузијаста и истраживача за реверзно инжењерство и анализу малвера.

## References

- [Play Integrity API: How It Works & How to Bypass It](https://m4kr0.vercel.app/posts/play-integrity-api-how-it-works--how-to-bypass-it/)
- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) It is a great list of resources
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
