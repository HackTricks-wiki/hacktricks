# Pentesting delle Applicazioni Android

{{#include ../../banners/hacktricks-training.md}}

## Nozioni di base sulle Applicazioni Android

È fortemente consigliato iniziare leggendo questa pagina per conoscere le **parti più importanti relative alla sicurezza Android e i componenti più pericolosi in un'applicazione Android**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Questo è lo strumento principale necessario per connettersi a un dispositivo Android (emulato o fisico).\
**ADB** permette di controllare i dispositivi sia via **USB** che via **Network** da un computer. Questa utility consente la **copia** di file in entrambe le direzioni, **installazione** e **disinstallazione** di app, **esecuzione** di comandi shell, **backup** dei dati, **lettura** dei log, tra le altre funzioni.

Dai un'occhiata alla seguente lista di [**ADB Commands**](adb-commands.md) per imparare come usare adb.

## Smali

A volte è interessante **modificare il codice dell'applicazione** per accedere a **informazioni nascoste** (magari password ben offuscate o flag). In tal caso, può essere utile decompilare l'apk, modificare il codice e ricompilarlo.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Questo può essere molto utile come **alternativa per diversi test durante l'analisi dinamica** che verranno presentati. Quindi, **tieni sempre a mente questa possibilità**.

## Altri trucchi interessanti

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [Android IME / InputMethodService Abuse (Malicious Keyboards)](inputmethodservice-ime-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **Scarica APK**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Estrai APK dal dispositivo:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Unisci tutti gli splits e i base apks con [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Android Enterprise & Work Profile Attacks

{{#ref}}
android-enterprise-work-profile-bypass.md
{{#endref}}

## Case Studies & Vulnerabilities


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}


{{#ref}}
../../binary-exploitation/linux-kernel-exploitation/arm64-static-linear-map-kaslr-bypass.md
{{#endref}}

## Analisi statica

First of all, for analysing an APK you should **take a look to the to the Java code** using a decompiler.\
Please, [**read here to find information about different available decompilers**](apk-decompilers.md).

### Ricerca di informazioni interessanti

Dando semplicemente un'occhiata alle **strings** dell'APK puoi cercare **password**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** e tutto ciò che può risultare interessante... cerca anche backdoors per code execution o authentication backdoors (credenziali admin hardcoded nell'app).

**Firebase**

Presta particolare attenzione alle **firebase URLs** e verifica se è mal configurato. [More information about whats is FIrebase and how to exploit it here.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Comprensione di base dell'applicazione - Manifest.xml, strings.xml

L'**esame dei file _Manifest.xml_ e _strings.xml_ di un'applicazione può rivelare potenziali vulnerabilità di sicurezza**. Questi file possono essere accessi usando decompilers o rinominando l'estensione del file APK in .zip e poi scompattandolo.

**Vulnerabilities** identificate dal **Manifest.xml** includono:

- **Debuggable Applications**: Applicazioni impostate come debuggable (`debuggable="true"`) nel file _Manifest.xml_ rappresentano un rischio in quanto permettono connessioni che possono portare a exploitation. Per capire meglio come sfruttare applicazioni debuggable, consulta un tutorial su come trovare e sfruttare applicazioni debuggable su un dispositivo.
- **Backup Settings**: L'attributo `android:allowBackup="false"` dovrebbe essere impostato esplicitamente per le applicazioni che gestiscono informazioni sensibili per prevenire backup non autorizzati tramite adb, specialmente quando usb debugging è abilitato.
- **Network Security**: Configurazioni personalizzate di network security (`android:networkSecurityConfig="@xml/network_security_config"`) in _res/xml/_ possono specificare dettagli di sicurezza come certificate pins e impostazioni del traffico HTTP. Un esempio è permettere traffico HTTP per domini specifici.
- **Exported Activities and Services**: Identificare attività e servizi esportati nel manifest può evidenziare componenti che potrebbero essere abusati. Un'analisi più approfondita durante i test dinamici può rivelare come sfruttare questi componenti.
- **Content Providers and FileProviders**: Content provider esposti potrebbero permettere accessi non autorizzati o la modifica di dati. Anche la configurazione dei FileProviders deve essere esaminata attentamente.
- **Broadcast Receivers and URL Schemes**: Questi componenti potrebbero essere utilizzati per l'exploitation, prestando particolare attenzione a come gli URL schemes gestiscono l'input.
- **SDK Versions**: Gli attributi `minSdkVersion`, `targetSDKVersion` e `maxSdkVersion` indicano le versioni Android supportate, sottolineando l'importanza di non supportare versioni Android obsolete e vulnerabili per motivi di sicurezza.

Dal file **strings.xml** possono emergere informazioni sensibili come API keys, custom schemas e altri appunti degli sviluppatori, sottolineando la necessità di una revisione accurata di queste risorse.

### Tapjacking

**Tapjacking** è un attacco in cui un'applicazione **malicious** viene avviata e **si posiziona sopra un'applicazione vittima**. Una volta che oscura visibilmente l'app vittima, la sua interfaccia utente è progettata in modo da indurre l'utente a interagire con essa, mentre l'interazione viene passata all'app vittima.\
In sostanza, è **un'operazione che impedisce all'utente di sapere che sta effettivamente eseguendo azioni sull'app vittima**.

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Un'**activity** con il **`launchMode`** impostato su **`singleTask` senza alcun `taskAffinity`** definito è vulnerabile al Task Hijacking. Questo significa che un'**application** può essere installata e, se avviata prima dell'app reale, potrebbe **hijackare il task dell'app reale** (quindi l'utente interagirà con la **malicious application pensando di usare quella reale**).

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Archiviazione dati insicura

**Internal Storage**

In Android, i file **memorizzati** nello **storage interno** sono **progettati** per essere accessibili esclusivamente dall'**app** che li ha **creati**. Questa misura di sicurezza è **applicata** dal sistema operativo Android ed è generalmente adeguata per le esigenze di sicurezza della maggior parte delle applicazioni. Tuttavia, gli sviluppatori a volte utilizzano modalità come `MODE_WORLD_READABLE` e `MODE_WORLD_WRITABLE` per **permettere** la condivisione di file tra diverse applicazioni. Queste modalità, però, **non limitano l'accesso** a questi file da parte di altre applicazioni, incluse potenzialmente quelle malicious.

1. **Static Analysis:**
- **Verificare** attentamente l'uso di `MODE_WORLD_READABLE` e `MODE_WORLD_WRITABLE`. Queste modalità **possono esporre** i file a **accessi non intenzionati o non autorizzati**.
2. **Dynamic Analysis:**
- **Controllare** i permessi impostati sui file creati dall'app. In particolare, **verificare** se alcuni file sono **impostati come leggibili o scrivibili da tutti**. Questo può costituire un rischio significativo per la sicurezza, poiché permetterebbe a **qualsiasi applicazione** installata sul dispositivo, indipendentemente dalla sua provenienza o finalità, di **leggere o modificare** questi file.

**External Storage**

Quando si gestiscono file su **external storage**, come SD card, bisogna prendere alcune precauzioni:

1. **Accessibilità**:
- I file su external storage sono **globalmente leggibili e scrivibili**. Questo significa che qualsiasi applicazione o utente può accedervi.
2. **Problemi di sicurezza**:
- Data la facilità di accesso, è consigliato **non memorizzare informazioni sensibili** su external storage.
- L'external storage può essere rimossa o accessibile da qualsiasi applicazione, rendendola meno sicura.
3. **Gestione dei dati provenienti dall'external storage**:
- Effettuare sempre **validazione dell'input** sui dati recuperati dall'external storage. Questo è cruciale perché i dati provengono da una fonte non attendibile.
- È fortemente sconsigliato memorizzare eseguibili o file class su external storage per il caricamento dinamico.
- Se la tua applicazione deve recuperare file eseguibili dall'external storage, assicurati che questi file siano **firmati e verificati criptograficamente** prima di essere caricati dinamicamente. Questo passaggio è fondamentale per mantenere l'integrità di sicurezza della tua applicazione.

L'external storage può essere **accessed** in `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> Starting with Android 4.4 (**API 17**), the SD card has a directory structure which **limits access from an app to the directory which is specifically for that app**. This prevents malicious application from gaining read or write access to another app's files.

**Sensitive data stored in clear-text**

- **Shared preferences**: Android permette a ogni applicazione di salvare facilmente file xml nel percorso `/data/data/<packagename>/shared_prefs/` e talvolta è possibile trovare informazioni sensibili in chiaro in quella cartella.
- **Databases**: Android permette a ogni applicazione di salvare facilmente database sqlite nel percorso `/data/data/<packagename>/databases/` e talvolta è possibile trovare informazioni sensibili in chiaro in quella cartella.

### Broken TLS

**Accept All Certificates**

For some reason sometimes developers accept all the certificates even if for example the hostname does not match with lines of code like the following one:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Un buon modo per testare questo è cercare di catturare il traffico usando un proxy come Burp senza autorizzare Burp CA sul dispositivo. Inoltre, puoi generare con Burp un certificato per un hostname diverso e usarlo.

### Crittografia debole

**Processi di gestione delle chiavi carenti**

Alcuni sviluppatori salvano dati sensibili nello storage locale e li cifrano con una chiave hardcoded/predictable nel codice. Questo non dovrebbe essere fatto perché del reverse engineering potrebbe permettere ad attaccanti di estrarre le informazioni riservate.

**Uso di algoritmi insicuri e/o deprecati**

Gli sviluppatori non dovrebbero usare **deprecated algorithms** per effettuare authorisation **checks**, **store** o **send** data. Alcuni di questi algoritmi sono: RC4, MD4, MD5, SHA1... Se vengono usate **hashes** per memorizzare le password, per esempio, dovrebbero essere usati hash resistenti al brute-force con salt.

### Altri controlli

- È consigliato obfuscate the APK per rendere più difficile il lavoro di reverse engineering agli attaccanti.
- Se l'app è sensibile (come le app bancarie), dovrebbe effettuare i propri **controlli per verificare se il mobile è rooted** e agire di conseguenza.
- Se l'app è sensibile (come le app bancarie), dovrebbe verificare se viene usato un **emulator**.
- Se l'app è sensibile (come le app bancarie), dovrebbe **verificare la propria integrità prima di eseguirla** per controllare se è stata modificata.
- Usa [**APKiD**](https://github.com/rednaga/APKiD) per controllare quale compiler/packer/obfuscator è stato usato per costruire l'APK

### Applicazione React Native

Leggi la pagina seguente per imparare come accedere facilmente al codice javascript delle applicazioni React:


{{#ref}}
react-native-application.md
{{#endref}}

### Applicazioni Xamarin

Leggi la pagina seguente per imparare come accedere facilmente al codice C# di un'applicazione xamarin:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Applicazioni Superpacked

Secondo questo [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked è un algoritmo Meta che comprime il contenuto di un'applicazione in un unico file. Il blog parla della possibilità di creare un'app che decomprime questo tipo di applicazioni... e di un modo più veloce che prevede di **eseguire l'applicazione e raccogliere i file decompressi dal filesystem.**

### Analisi statica automatizzata del codice

Lo strumento [**mariana-trench**](https://github.com/facebook/mariana-trench) è in grado di individuare **vulnerabilità** scansionando il **codice** dell'applicazione. Questo strumento contiene una serie di **sorgenti note** (che indicano allo strumento i **punti** in cui l'**input** è **controllato dall'utente**), **sinks** (che indicano i **punti** **pericolosi** dove l'input utente malevolo potrebbe causare danni) e **regole**. Queste regole indicano la **combinazione** di **sorgenti-sink** che segnala una vulnerabilità.

Con questa conoscenza, **mariana-trench esaminerà il codice e troverà possibili vulnerabilità**.

### Segreti leakati

Un'applicazione può contenere segreti (API keys, passwords, hidden urls, subdomains...) al suo interno che potresti essere in grado di scoprire. Puoi usare uno strumento come [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass dell'autenticazione biometrica


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Altre funzioni interessanti

- **Esecuzione di codice**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Invio SMS**: `sendTextMessage, sendMultipartTestMessage`
- **Funzioni native** dichiarate come `native`: `public native, System.loadLibrary, System.load`
- [Leggi questo per imparare **come reverseggare le funzioni native**](reversing-native-libraries.md)
- Esecuzione in-memory di codice nativo via JNI (shellcode scaricato → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Altri trucchi**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Analisi Dinamica

> Prima di tutto, hai bisogno di un ambiente in cui puoi installare l'applicazione e tutto l'ambiente (Burp CA cert, Drozer e Frida principalmente). Pertanto, è fortemente raccomandato un dispositivo rooted (emulato o meno).

### Analisi dinamica online

Puoi creare un **account gratuito** su: [https://appetize.io/](https://appetize.io). Questa piattaforma permette di **caricare** e **eseguire** APK, quindi è utile per vedere come si comporta un apk.

Puoi anche **vedere i log della tua applicazione** sul web e connetterti tramite **adb**.

![](<../../images/image (831).png>)

Grazie alla connessione ADB puoi usare **Drozer** e **Frida** all'interno degli emulatori.

### Analisi dinamica locale

#### Usare un emulatore

- [**Android Studio**](https://developer.android.com/studio) (Puoi creare **x86** e **arm** devices, e secondo [**questa**](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html) le versioni **latest x86** supportano **ARM libraries** senza necessità di un lento emulatore arm).
- Impara a configurarlo in questa pagina:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Versione gratuita:** Personal Edition, è necessario creare un account. _Si raccomanda di scaricare la versione **CON** **VirtualBox** per evitare potenziali errori._)
- [**Nox**](https://es.bignox.com) (Gratuito, ma non supporta Frida o Drozer).

> [!TIP]
> Quando crei un nuovo emulatore su qualsiasi piattaforma ricorda che più grande è lo schermo, più lento girerà l'emulatore. Quindi seleziona schermi piccoli se possibile.

Per **installare google services** (come AppStore) in Genymotion devi cliccare sul pulsante evidenziato in rosso nell'immagine seguente:

![](<../../images/image (277).png>)

Inoltre, nota che nella **configurazione della Android VM in Genymotion** puoi selezionare **Bridge Network mode** (utile se ti connetterai alla Android VM da una VM diversa con gli strumenti).

#### Usa un dispositivo fisico

Devi attivare le opzioni di **debugging** e sarebbe utile se puoi **root**arlo:

1. **Impostazioni**.
2. (Da Android 8.0) Seleziona **Sistema**.
3. Seleziona **Informazioni sul telefono**.
4. Premi **Numero build** 7 volte.
5. Torna indietro e troverai le **Opzioni sviluppatore**.

> Una volta installata l'applicazione, la prima cosa che dovresti fare è provarla, investigare cosa fa, come funziona e prenderti confidenza con essa.\
> Suggerisco di **eseguire questa analisi dinamica iniziale usando MobSF dynamic analysis + pidcat**, così saremo in grado di **imparare come l'applicazione funziona** mentre MobSF **cattura** molti **dati interessanti** che potrai rivedere in seguito.

Magisk/Zygisk quick notes (recommended on Pixel devices)
- Patcha boot.img con l'app Magisk e flashalo via fastboot per ottenere systemless root
- Abilita Zygisk + DenyList per nascondere il root; considera LSPosed/Shamiko quando è richiesto un nascondimento più forte
- Conserva il boot.img originale per recuperare dagli OTA; ripatcha dopo ogni OTA
- Per il mirroring dello schermo, usa scrcpy sul host



### Perdita di dati non intenzionale

**Logging**

Gli sviluppatori dovrebbero stare attenti a esporre **debugging information** pubblicamente, poiché può portare a leak di dati sensibili. Gli strumenti [**pidcat**](https://github.com/JakeWharton/pidcat) e `adb logcat` sono raccomandati per monitorare i log dell'applicazione per identificare e proteggere informazioni sensibili. **Pidcat** è preferito per la sua facilità d'uso e leggibilità.

> [!WARNING]
> Nota che da **versioni successive a Android 4.0**, **le applicazioni possono accedere solo ai propri log**. Quindi le applicazioni non possono accedere ai log di altre app.\
> Comunque, è comunque raccomandato **di non loggare informazioni sensibili**.

**Caching della clipboard**

Il framework **clipboard-based** di Android abilita la funzionalità di copia-incolla nelle app, ma comporta un rischio in quanto **altre applicazioni** possono **accedere** alla clipboard, esponendo potenzialmente dati sensibili. È fondamentale **disabilitare le funzioni di copia/incolla** per sezioni sensibili dell'applicazione, come i dati di carte di credito, per prevenire data leak.

**Crash Logs**

Se un'applicazione **crasha** e **salva log**, questi log possono aiutare gli attaccanti, soprattutto quando l'app non può essere reverse-engineerizzata. Per mitigare questo rischio, evita di loggare su crash, e se i log devono essere trasmessi sulla rete, assicurati che siano inviati tramite un canale SSL per la sicurezza.

Come pentester, **prova a dare un'occhiata a questi log**.

**Analytics Data Sent To 3rd Parties**

Le applicazioni spesso integrano servizi come Google Adsense, che possono involontariamente **leak sensitive data** a causa di implementazioni improprie da parte degli sviluppatori. Per identificare potenziali data leak, è consigliabile **intercettare il traffico dell'applicazione** e controllare se informazioni sensibili vengono inviate a servizi di terze parti.

### SQLite DBs

La maggior parte delle applicazioni usa **internal SQLite databases** per salvare informazioni. Durante il pentest dai un'occhiata ai **databases** creati, ai nomi delle **tables** e delle **columns** e a tutti i **data** salvati perché potresti trovare **informazioni sensibili** (che sarebbero una vulnerability).\
I databases dovrebbero essere localizzati in `/data/data/the.package.name/databases` come `/data/data/com.mwr.example.sieve/databases`

Se il database salva informazioni confidenziali ed è **encrypted** ma puoi **trovare** la **password** all'interno dell'applicazione, è comunque una **vulnerability**.

Enumera le tables usando `.tables` e enumera le columns delle tabelle eseguendo `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

Da [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** ti permette di **assumere il ruolo di un'app Android** e interagire con altre app. Può fare **qualsiasi cosa che un'app installata può fare**, come usare il meccanismo IPC di Android e interagire con il sistema operativo sottostante. .\
Drozer è uno strumento utile per **sfruttare exported activities, exported services e Content Providers** come imparerai nelle sezioni seguenti.

### Sfruttare exported Activities

[**Leggi questo se vuoi rinfrescare cos'è un Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Ricorda anche che il codice di un activity inizia nel metodo **`onCreate`**.

**Bypass dell'autorizzazione**

Quando un Activity è exported puoi richiamare la sua schermata da un'app esterna. Pertanto, se un activity con **sensitive information** è **exported** potresti **bypassare** i meccanismi di **authentication** per **accedervi**.

[**Impara come sfruttare exported activities con Drozer.**](drozer-tutorial/index.html#activities)

Puoi anche avviare un activity exported da adb:

- PackageName è com.example.demo
- Exported ActivityName è com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTA**: MobSF rileverà come malevolo l'uso di _**singleTask/singleInstance**_ come `android:launchMode` in un'activity, ma a causa di [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparentemente questo è pericoloso solo su versioni vecchie (API versions < 21).

> [!TIP]
> Nota che un authorisation bypass non è sempre una vulnerabilità; dipende da come funziona il bypass e quali informazioni vengono esposte.

**Perdita di informazioni sensibili**

**Le Activity possono anche restituire risultati**. Se riesci a trovare un'activity esportata e non protetta che chiama il metodo **`setResult`** e **restituisce informazioni sensibili**, si verifica una perdita di informazioni sensibili.

#### Tapjacking

Se il tapjacking non è prevenuto, potresti abusare dell'activity esportata per far sì che l'**utente esegua azioni inaspettate**. Per maggiori informazioni su [**cos'è Tapjacking segui il link**](#tapjacking).

### Sfruttare Content Providers - Accesso e manipolazione di informazioni sensibili

[**Leggi questo se vuoi rinfrescarti su cos'è un Content Provider.**](android-applications-basics.md#content-provider)\
I Content provider sono sostanzialmente usati per **condividere dati**. Se un'app ha content provider disponibili potresti riuscire a **estrarre dati sensibili** da essi. È anche interessante testare possibili **SQL injections** e **Path Traversals** in quanto potrebbero essere vulnerabili.

[**Scopri come sfruttare Content Providers con Drozer.**](drozer-tutorial/index.html#content-providers)

### **Sfruttare i Service**

[**Leggi questo se vuoi rinfrescarti su cos'è un Service.**](android-applications-basics.md#services)\
Ricorda che le azioni di un Service iniziano nel metodo `onStartCommand`.

Un service è fondamentalmente qualcosa che **può ricevere dati**, **elaborarli** e **restituire** (o meno) una risposta. Quindi, se un'applicazione esporta dei service dovresti **controllare** il **codice** per capire cosa fa e **testarlo** **dinamicamente** per estrarre informazioni riservate, bypassare misure di autenticazione...\
[**Scopri come sfruttare i Service con Drozer.**](drozer-tutorial/index.html#services)

### **Sfruttare i Broadcast Receiver**

[**Leggi questo se vuoi rinfrescarti su cos'è un Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Ricorda che le azioni di un Broadcast Receiver iniziano nel metodo `onReceive`.

Un broadcast receiver aspetta un tipo di messaggio. A seconda di come il receiver gestisce il messaggio, potrebbe essere vulnerabile.\
[**Scopri come sfruttare i Broadcast Receiver con Drozer.**](#exploiting-broadcast-receivers)

### **Sfruttare Schemes / Deep links**

Puoi cercare i deep link manualmente, usando strumenti come MobSF o script come [questo](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Puoi **aprire** uno **scheme** dichiarato usando **adb** o un **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Nota che puoi **omettere il nome del package** e il dispositivo mobile chiamerà automaticamente l'app che dovrebbe aprire quel link._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Code executed**

In order to find the **code that will be executed in the App**, go to the activity called by the deeplink and search the function **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Informazioni sensibili**

Ogni volta che trovi un deep link verifica che **non stia ricevendo dati sensibili (come password) tramite i parametri URL**, perché qualsiasi altra applicazione potrebbe **impersonare il deep link e rubare quei dati!**

**Parametri nel path**

Devi anche verificare se un deep link sta usando un parametro all'interno del path dell'URL come: `https://api.example.com/v1/users/{username}` , in tal caso puoi forzare un path traversal accedendo a qualcosa del tipo: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Nota che se trovi gli endpoint corretti all'interno dell'applicazione potresti essere in grado di causare un **Open Redirect** (se parte del path è usata come nome di dominio), un **account takeover** (se puoi modificare i dettagli degli utenti senza token CSRF e l'endpoint vuln usava il metodo corretto) e qualsiasi altra vuln. Maggiori [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**Altri esempi**

Un [interessante bug bounty report](https://hackerone.com/reports/855618) sui link (_/.well-known/assetlinks.json_).

### Transport Layer Inspection and Verification Failures

- **I certificati non sono sempre ispezionati correttamente** dalle applicazioni Android. È comune che queste applicazioni ignorino gli avvisi e accettino certificati self-signed o, in alcuni casi, tornino a usare connessioni HTTP.
- **Le negoziazioni durante il handshake SSL/TLS sono talvolta deboli**, impiegando cipher suite insicure. Questa vulnerabilità rende la connessione suscettibile ad attacchi man-in-the-middle (MITM), permettendo agli attaccanti di decifrare i dati.
- **Leakage of private information** è un rischio quando le applicazioni si autenticano usando canali sicuri ma poi comunicano su canali non sicuri per altre transazioni. Questo approccio non protegge dati sensibili, come session cookies o dettagli dell'utente, dall'intercettazione da parte di entità malevole.

#### Certificate Verification

Ci concentreremo sulla **verifica dei certificati**. L'integrità del certificato del server deve essere verificata per aumentare la sicurezza. Questo è cruciale perché configurazioni TLS insicure e la trasmissione di dati sensibili su canali non cifrati possono comportare rischi significativi. Per passaggi dettagliati su come verificare i certificati del server e risolvere le vulnerabilità, [**questa risorsa**](https://manifestsecurity.com/android-application-security-part-10/) fornisce una guida completa.

#### SSL Pinning

SSL Pinning è una misura di sicurezza in cui l'applicazione verifica il certificato del server rispetto a una copia nota memorizzata all'interno dell'app stessa. Questo metodo è essenziale per prevenire attacchi MITM. Implementare SSL Pinning è fortemente raccomandato per applicazioni che trattano informazioni sensibili.

#### Traffic Inspection

Per ispezionare il traffico HTTP, è necessario **installare il certificato dello strumento proxy** (es., Burp). Senza installare questo certificato, il traffico cifrato potrebbe non essere visibile tramite il proxy. Per una guida sull'installazione di una CA certificate personalizzata, [**clicca qui**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Le applicazioni targettizzate per **API Level 24 and above** richiedono modifiche al Network Security Config per accettare la CA certificate del proxy. Questo passaggio è critico per ispezionare il traffico cifrato. Per istruzioni su come modificare il Network Security Config, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

Se viene utilizzato **Flutter** devi seguire le istruzioni in [**questa pagina**](flutter.md). Questo perché aggiungere semplicemente il certificato nello store non funzionerà, dato che Flutter ha la sua lista di CAs valide.

#### Static detection of SSL/TLS pinning

Prima di tentare bypass a runtime, mappa rapidamente dove il pinning è applicato nell'APK. La scoperta statica ti aiuta a pianificare hook/patch e a concentrarti sui code paths giusti.

Tool: SSLPinDetect
- Utility open-source di static-analysis che decompila l'APK in Smali (via apktool) e scansiona pattern regex curati di implementazioni di SSL/TLS pinning.
- Riporta il percorso file esatto, il numero di linea e uno snippet di codice per ogni corrispondenza.
- Copre framework comuni e percorsi di codice custom: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init con custom TrustManagers/KeyManagers, e pin nel Network Security Config XML.

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Uso
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Esempi di regole di pattern (JSON)
Usa o estendi signatures per rilevare stili di pinning proprietari/custom. Puoi caricare il tuo JSON e fare scan su larga scala.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes and tips
- Scansione veloce di grandi app via multi-threading e memory-mapped I/O; pre-compiled regex riduce overhead/false positives.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Tipici obiettivi di rilevamento da esaminare in seguito:
- OkHttp: utilizzo di CertificatePinner, setCertificatePinner, riferimenti ai package okhttp3/okhttp
- TrustManager personalizzati: javax.net.ssl.X509TrustManager, override di checkServerTrusted
- Contesti SSL personalizzati: SSLContext.getInstance + SSLContext.init con manager personalizzati
- Pin dichiarativi in res/xml network security config e riferimenti nel manifest
- Usa le posizioni corrispondenti per pianificare Frida hooks, patch statiche o revisioni di config prima del testing dinamico.



#### Bypassing SSL Pinning

Quando SSL Pinning è implementato, diventa necessario bypassarlo per ispezionare il traffico HTTPS. Sono disponibili diversi metodi per questo scopo:

- Modificare automaticamente l'**apk** per **bypassare** SSLPinning con [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Il principale vantaggio di questa opzione è che non avrai bisogno del root per bypassare SSL Pinning, ma dovrai cancellare l'applicazione e reinstallare la nuova, e questo non funziona sempre.
- Puoi usare **Frida** (discusso più sotto) per bypassare questa protezione. Qui trovi una guida per usare Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Puoi anche provare a **bypassare automaticamente SSL Pinning** usando [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Puoi anche provare a **bypassare automaticamente SSL Pinning** usando **MobSF dynamic analysis** (spiegato più sotto)
- Se pensi ancora che ci sia traffico che non stai catturando, puoi provare a **inoltrare il traffico a Burp usando iptables**. Leggi questo blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Looking for Common Web Vulnerabilities

È importante anche ricercare vulnerabilità web comuni all'interno dell'applicazione. Informazioni dettagliate su identificazione e mitigazione di queste vulnerabilità sono oltre lo scopo di questo sommario ma sono trattate approfonditamente altrove.

### Frida

[Frida](https://www.frida.re) è un toolkit di instrumentation dinamica per developer, reverse-engineer e security researcher.\
**Puoi accedere all'applicazione in esecuzione e hookare metodi a runtime per cambiare il comportamento, modificare valori, estrarre valori, eseguire codice diverso...**\
Se vuoi fare pentesting su applicazioni Android devi sapere come usare Frida.

- Impara a usare Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Alcune "GUI" per azioni con Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection è ottimo per automatizzare l'uso di Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Puoi trovare alcuni Awesome Frida scripts qui: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Prova a bypassare meccanismi anti-debugging / anti-frida caricando Frida come indicato in [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

Controlla se l'applicazione sta memorizzando informazioni sensibili nella memoria che non dovrebbe conservare, come password o mnemonic.

Usando [**Fridump3**](https://github.com/rootbsd/fridump3) puoi dumpare la memoria dell'app con:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Questo eseguirà un dump della memoria nella cartella ./dump, e lì puoi usare grep con qualcosa del genere:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Dati sensibili nel Keystore**

In Android il Keystore è il posto migliore per memorizzare dati sensibili, tuttavia, con privilegi sufficienti è ancora **possibile accedervi**. Poiché le applicazioni tendono a memorizzare qui **dati sensibili in clear text**, i pentests dovrebbero verificarne la presenza, poiché un utente root o qualcuno con accesso fisico al dispositivo potrebbe rubare questi dati.

Anche se un'app memorizza dati nel Keystore, i dati dovrebbero essere criptati.

Per accedere ai dati all'interno del Keystore puoi usare questo script Frida: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Usando il seguente script Frida, potrebbe essere possibile effettuare un **bypass fingerprint authentication** che le applicazioni Android potrebbero implementare per **proteggere alcune aree sensibili:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Immagini di sfondo**

Quando un'app viene mandata in background, Android salva una **istantanea dell'applicazione**: quando viene riportata in primo piano, il sistema carica prima quell'immagine così sembra che l'app sia stata avviata più velocemente.

Tuttavia, se questa istantanea contiene **informazioni sensibili**, qualcuno con accesso all'istantanea potrebbe **rubare tali informazioni** (nota che è necessario avere root per accedervi).

Le istantanee sono solitamente memorizzate in: **`/data/system_ce/0/snapshots`**

Android offre un modo per **impedire la cattura degli screenshot impostando il parametro di layout FLAG_SECURE**. Usando questa flag, i contenuti della finestra sono trattati come sicuri, evitando che compaiano in screenshot o che vengano visualizzati su display non sicuri.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Questo strumento può aiutarti a gestire diversi tool durante l'analisi dinamica: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Gli sviluppatori spesso creano componenti proxy come activities, services e broadcast receivers che gestiscono questi Intent e li passano a metodi come `startActivity(...)` o `sendBroadcast(...)`, il che può essere rischioso.

Il pericolo consiste nel permettere agli attackers di triggerare componenti non-exported dell'app o di accedere a content providers sensibili deviando questi Intent. Un esempio significativo è il componente `WebView` che converte URL in oggetti `Intent` tramite `Intent.parseUri(...)` e poi li esegue, potenzialmente portando a malicious Intent injections.

### Punti essenziali

- **Intent Injection** è simile al problema web Open Redirect.
- Gli exploit coinvolgono il passaggio di oggetti `Intent` come extras, che possono essere reindirizzati per eseguire operazioni non sicure.
- Può esporre componenti non-exported e content providers ad attackers.
- La conversione di URL in `Intent` da parte di `WebView` può facilitare azioni non volute.

### Android Client Side Injections and others

Probabilmente conosci questo tipo di vulnerabilità dal Web. Bisogna prestare particolare attenzione a queste vulnerabilità in un'app Android:

- **SQL Injection:** Quando si gestiscono query dinamiche o Content-Providers assicurati di usare query parametrizzate.
- **JavaScript Injection (XSS):** Verifica che JavaScript e il supporto ai plugin siano disabilitati per qualsiasi WebView (disabilitati di default). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** I WebView dovrebbero avere l'accesso al file system disabilitato (abilitato di default) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: In molti casi, quando l'app Android termina la sessione il cookie non viene revocato o può essere persino salvato su disco
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Analisi automatica

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Analisi statica**

![](<../../images/image (866).png>)

**Valutazione delle vulnerabilità dell'applicazione** utilizzando un gradevole frontend web. Puoi anche eseguire analisi dinamica (ma è necessario preparare l'ambiente).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Nota che MobSF può analizzare **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applicazioni (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Inoltre, se crei un file **ZIP** con il codice sorgente di un'app **Android** o un'app **IOS** (vai alla cartella root dell'applicazione, seleziona tutto e crea un ZIPfile), sarà in grado di analizzarlo.

MobSF permette anche di fare **diff/Compare** delle analisi e di integrare **VirusTotal** (dovrai impostare la tua API key in _MobSF/settings.py_ e abilitarla: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). Puoi anche impostare `VT_UPLOAD` a `False`, in tal caso verrà caricato l'**hash** invece del file.

### Assisted Dynamic analysis with MobSF

**MobSF** può essere molto utile anche per l'**analisi dinamica** su **Android**, ma in questo caso dovrai installare MobSF e **genymotion** sul tuo host (una VM o Docker non funzioneranno). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
Il **MobSF dynamic analyser** può:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). Tutto questo viene fatto automaticamente eccetto per gli screenshot: devi premere quando vuoi uno screenshot oppure devi premere "**Exported Activity Tester**" per ottenere screenshot di tutte le exported activities.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

Dalle versioni Android **> 5**, avvierà **automaticamente Frida** e imposterà le impostazioni globali di **proxy** per **capture** il traffico. Catturerà solo il traffico dell'applicazione testata.

**Frida**

Per default utilizzerà anche alcuni Frida Scripts per **bypass SSL pinning**, **root detection** e **debugger detection** e per **monitor interesting APIs**.\
MobSF può anche **invoke exported activities**, acquisirne **screenshots** e **save**li per il report.

Per **start** il testing dinamico premi il bottone verde: "**Start Instrumentation**". Premi "**Frida Live Logs**" per vedere i log generati dagli script Frida e "**Live API Monitor**" per vedere tutte le invocation ai metodi hookati, gli argomenti passati e i valori restituiti (questo apparirà dopo aver premuto "Start Instrumentation").\
MobSF ti permette anche di caricare i tuoi **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). Ha anche **several pre-written scripts** che puoi caricare (puoi aggiungerne altri in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), basta **select them**, premere "**Load**" e premere "**Start Instrumentation**" (potrai vedere i log di quegli script dentro "**Frida Live Logs**").

![](<../../images/image (419).png>)

Inoltre, hai alcune funzionalità ausiliarie di Frida:

- **Enumerate Loaded Classes**: Stamperà tutte le classi caricate
- **Capture Strings**: Stamperà tutte le stringhe catturate mentre usi l'applicazione (molto rumoroso)
- **Capture String Comparisons**: Potrebbe essere molto utile. Mostrerà le 2 stringhe confrontate e se il risultato era True o False.
- **Enumerate Class Methods**: Inserisci il nome della classe (come "java.io.File") e stamperà tutti i metodi della classe.
- **Search Class Pattern**: Cerca classi per pattern
- **Trace Class Methods**: **Trace** un'intera classe (vedi input e output di tutti i metodi della classe). Ricorda che per default MobSF traccia diversi metodi Android API interessanti.

Una volta selezionato il modulo ausiliario che vuoi usare devi premere "**Start Intrumentation**" e vedrai tutti gli output in "**Frida Live Logs**".

**Shell**

Mobsf fornisce anche una shell con alcuni comandi **adb**, **MobSF commands**, e comuni **shell** **commands** nella parte bassa della pagina di analisi dinamica. Alcuni comandi interessanti:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**Strumenti HTTP**

Quando il traffico HTTP viene catturato puoi vedere una vista grezza del traffico catturato nel pulsante "**HTTP(S) Traffic**" in basso oppure una vista più gradevole nel pulsante verde "**Start HTTPTools**". Dalla seconda opzione, puoi **inviare** le **richieste catturate** a **proxies** come Burp o Owasp ZAP.\
Per farlo, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> premi "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Una volta terminata l'analisi dinamica con MobSF puoi premere su "**Start Web API Fuzzer**" per **fuzz http requests** e cercare vulnerabilità.

> [!TIP]
> Dopo aver eseguito un'analisi dinamica con MobSF le impostazioni del proxy potrebbero essere mal configurate e potresti non riuscire a correggerle dalla GUI. Puoi sistemare le impostazioni del proxy eseguendo:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Analisi Dinamica Assistita con Inspeckage

Puoi ottenere lo strumento da [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Questo tool usa alcuni **Hooks** per farti capire **cosa sta succedendo nell'applicazione** mentre esegui un'**analisi dinamica**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Questo è un **ottimo tool per eseguire analisi statica con una GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Questo tool è progettato per cercare diverse **security related Android application vulnerabilities**, sia nel **source code** che in **packaged APKs**. Lo strumento è anche **capable of creating a "Proof-of-Concept" deployable APK** e comandi **ADB**, per sfruttare alcune delle vulnerabilità trovate (Exposed activities, intents, tapjacking...). Come con Drozer, non è necessario rootare il dispositivo di test.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Mostra tutti i file estratti per consultazione rapida
- Decompila automaticamente gli APK in formato Java e Smali
- Analizza AndroidManifest.xml per vulnerabilità e comportamenti comuni
- Analisi statica del codice sorgente per vulnerabilità e comportamenti comuni
- Informazioni sul dispositivo
- e altro
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER è un'applicazione da riga di comando che può essere usata in Windows, MacOS X e Linux, che analizza file _.apk_ alla ricerca di vulnerabilità. Lo fa decomprimendo gli APK e applicando una serie di regole per rilevare tali vulnerabilità.

Tutte le regole sono raccolte in un file `rules.json`, e ogni azienda o tester può creare le proprie regole per analizzare ciò di cui ha bisogno.

Scarica i binari più recenti dalla [pagina di download](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn è uno strumento **crossplatform** che aiuta developers, bugbounty hunters e ethical hackers nello svolgimento di [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) su applicazioni mobile.

Il concetto è che trascini e rilasci il file della tua applicazione mobile (un file .apk o .ipa) sull'applicazione StaCoAn e questa genererà per te un report visivo e portatile. Puoi modificare le impostazioni e le wordlists per ottenere un'esperienza personalizzata.

Scarica[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework è un sistema di analisi delle vulnerabilità per Android che aiuta sviluppatori o hackers a trovare potenziali vulnerabilità di sicurezza nelle applicazioni Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** è uno strumento il cui obiettivo principale è rilevare e avvisare l'utente riguardo a potenziali comportamenti malevoli sviluppati da un'applicazione Android.

La rilevazione viene eseguita mediante la **static analysis** del Dalvik bytecode dell'applicazione, rappresentato come **Smali**, con la libreria [`androguard`](https://github.com/androguard/androguard).

Questo strumento cerca **comportamenti comuni delle applicazioni "maligne"** come: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. È uno strumento che mette insieme strumenti comunemente usati per il reverse engineering e l'analysis delle applicazioni mobile, per assistere nei test delle applicazioni mobile contro le OWASP mobile security threats. Il suo obiettivo è rendere questo compito più semplice e accessibile agli sviluppatori di applicazioni mobile e ai professionisti della sicurezza.

È in grado di:

- Estrarre codice Java e Smali usando diversi strumenti
- Analizzare APK usando: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Estrarre informazioni private dall'APK usando regexps.
- Analizzare il Manifest.
- Analizzare i domini trovati usando: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Utile per rilevare malware: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Nota che, a seconda del servizio e della configurazione usati per offuscare il code, i secrets potrebbero essere offuscati o meno.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. È in grado di ottimizzare il bytecode oltre a individuare e rimuovere istruzioni inutilizzate. ProGuard è software libero e viene distribuito sotto la GNU General Public License, versione 2.

ProGuard è distribuito come parte dell'Android SDK e viene eseguito durante la build dell'applicazione in modalità release.

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Last time we checked, the Dexguard mode of operation was:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

Puoi caricare un APK offuscato sulla loro piattaforma.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

It is a **generic android deobfuscator.** Simplify **virtually executes an app** to understand its behavior and then **tries to optimize the code** so it behaves identically but is easier for a human to understand. Each optimization type is simple and generic, so it doesn't matter what the specific type of obfuscation is used.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD gives you information about **how an APK was made**. It identifies many **compilers**, **packers**, **obfuscators**, and other weird stuff. It's [_PEiD_](https://www.aldeid.com/wiki/PEiD) for Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b è una virtual machine per security Android basata su ubuntu-mate che include la raccolta dei più recenti framework, tutorial e lab da diversi security geeks e ricercatori per reverse engineering e malware analysis.

## Riferimenti

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) È un'ottima lista di risorse
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
