# Aplicações Android Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Noções Básicas sobre Aplicações Android

É fortemente recomendado começar lendo esta página para conhecer as **partes mais importantes relacionadas à segurança Android e os componentes mais perigosos em uma aplicação Android**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Esta é a ferramenta principal que você precisa para se conectar a um dispositivo Android (emulado ou físico).\
**ADB** permite controlar dispositivos tanto via **USB** quanto via **Network** a partir de um computador. Esta utilidade possibilita a **cópia** de arquivos em ambas as direções, **instalação** e **desinstalação** de apps, **execução** de comandos shell, **backup** de dados, **leitura** de logs, entre outras funções.

Dê uma olhada na seguinte lista de [**ADB Commands**](adb-commands.md) para aprender a usar o adb.

## Smali

Às vezes é interessante **modificar o código da aplicação** para acessar **informações ocultas** (talvez senhas ou flags bem ofuscadas). Nesse caso, pode ser interessante decompilar o APK, modificar o código e recompilá-lo.\
[**Neste tutorial** você pode **aprender como decompilar um APK, modificar código Smali e recompilar o APK** com a nova funcionalidade](smali-changes.md). Isso pode ser muito útil como uma **alternativa para vários testes durante a análise dinâmica** que serão apresentados. Portanto, **mantenha sempre em mente essa possibilidade**.

## Outros truques interessantes

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **Baixar APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Extrair APK do dispositivo:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Mescle todos os splits e os base apks com [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Estudos de Caso & Vulnerabilidades


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Análise Estática

First of all, for analysing an APK you should **take a look to the to the Java code** using a decompiler.\
Please, [**read here to find information about different available decompilers**](apk-decompilers.md).

### Procurando informações interessantes

Basta olhar as **strings** do APK para procurar **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** e qualquer coisa interessante... procure até por **backdoors** de execução de código ou backdoors de autenticação (credenciais de admin hardcoded no app).

**Firebase**

Preste atenção especial às URLs do **Firebase** e verifique se está mal configurado. [More information about whats is FIrebase and how to exploit it here.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Compreensão básica da aplicação - Manifest.xml, strings.xml

A **examinação dos arquivos _Manifest.xml_ e _strings.xml_ de uma aplicação pode revelar potenciais vulnerabilidades de segurança**. Esses arquivos podem ser acessados usando decompilers ou renomeando a extensão do APK para .zip e então descompactando-o.

**Vulnerabilidades** identificadas a partir do **Manifest.xml** incluem:

- **Debuggable Applications**: Aplicações definidas como debuggable (`debuggable="true"`) no _Manifest.xml_ representam um risco, pois permitem conexões que podem levar à exploração. Para mais detalhes sobre como explorar aplicações debuggable, consulte um tutorial sobre encontrar e explorar aplicações debuggable em um dispositivo.
- **Backup Settings**: O atributo `android:allowBackup="false"` deve ser explicitamente definido para aplicações que lidam com informações sensíveis, para prevenir backups não autorizados via adb, especialmente quando o usb debugging está habilitado.
- **Network Security**: Configurações customizadas de network security (`android:networkSecurityConfig="@xml/network_security_config"`) em _res/xml/_ podem especificar detalhes de segurança como certificate pins e configurações de HTTP. Um exemplo é permitir tráfego HTTP para domínios específicos.
- **Exported Activities and Services**: Identificar activities e services exportados no manifest pode evidenciar componentes que podem ser mal utilizados. Análises adicionais durante testes dinâmicos podem revelar como explorar esses componentes.
- **Content Providers and FileProviders**: Content providers expostos podem permitir acesso ou modificação não autorizada de dados. A configuração de FileProviders também deve ser examinada.
- **Broadcast Receivers and URL Schemes**: Esses componentes podem ser aproveitados para exploração, com atenção especial em como as URL schemes são gerenciadas para vulnerabilidades de input.
- **SDK Versions**: Os atributos `minSdkVersion`, `targetSDKVersion` e `maxSdkVersion` indicam as versões do Android suportadas, destacando a importância de não suportar versões antigas e vulneráveis do Android por motivos de segurança.

A partir do **strings.xml**, informações sensíveis como API keys, custom schemas e outras notas de desenvolvedores podem ser descobertas, ressaltando a necessidade de revisar cuidadosamente esses recursos.

### Tapjacking

**Tapjacking** é um ataque onde uma **malicious application** é lançada e se **posiciona sobre uma aplicação vítima**. Uma vez que obscurece visivelmente o app vítima, sua interface é projetada de forma a enganar o usuário para interagir com ela, enquanto repassa a interação para o app vítima.\
Em efeito, é **cegar o usuário quanto ao fato de que ele está realmente realizando ações no app vítima**.

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Uma **activity** com o **`launchMode`** definido como **`singleTask` sem qualquer `taskAffinity`** definida é vulnerável ao Task Hijacking. Isso significa que uma **application** pode ser instalada e, se iniciada antes da aplicação real, poderia **hijackar a task da aplicação real** (então o usuário estará interagindo com a **malicious application** pensando que está usando a aplicação real).

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Armazenamento de dados inseguro

**Armazenamento Interno**

No **Android**, arquivos **armazenados** no **internal storage** são **projetados** para serem **acessíveis** exclusivamente pela **app** que os **criou**. Essa medida de segurança é **aplicada** pelo sistema operacional Android e é geralmente adequada para as necessidades de segurança da maioria das aplicações. No entanto, desenvolvedores às vezes utilizam modos como `MODE_WORLD_READABLE` e `MODE_WORLD_WRITABLE` para **permitir** que arquivos sejam **compartilhados** entre diferentes aplicações. Ainda assim, esses modos **não restringem o acesso** a esses arquivos por outras aplicações, incluindo potenciais maliciosas.

1. **Static Analysis:**
- **Ensure** que o uso de `MODE_WORLD_READABLE` e `MODE_WORLD_WRITABLE` seja **cuidadosamente escrutinado**. Esses modos **podem expor potencialmente** arquivos a **acessos não intencionais ou não autorizados**.
2. **Dynamic Analysis:**
- **Verify** as **permissions** definidas em arquivos criados pelo app. Especificamente, **cheque** se algum arquivo está **definido como legível ou gravável mundialmente**. Isso pode representar um risco significativo de segurança, pois permitiria **qualquer aplicação** instalada no dispositivo, independentemente de sua origem ou intenção, a **ler ou modificar** esses arquivos.

**Armazenamento Externo**

Ao lidar com arquivos no **external storage**, como SD Cards, certas precauções devem ser tomadas:

1. **Accessibility**:
- Arquivos no external storage são **globalmente legíveis e graváveis**. Isso significa que qualquer aplicação ou usuário pode acessar esses arquivos.
2. **Security Concerns**:
- Dada a facilidade de acesso, é recomendado **não armazenar informações sensíveis** no external storage.
- O external storage pode ser removido ou acessado por qualquer aplicação, tornando-o menos seguro.
3. **Handling Data from External Storage**:
- Sempre **realize validação de entrada** nos dados recuperados do external storage. Isso é crucial porque os dados vêm de uma fonte não confiável.
- Evite armazenar executáveis ou arquivos de classe no external storage para carregamento dinâmico.
- Se sua aplicação precisar recuperar arquivos executáveis do external storage, assegure que esses arquivos estejam **signed and cryptographically verified** antes de serem carregados dinamicamente. Esse passo é vital para manter a integridade de segurança da sua aplicação.

External storage pode ser **acessado** em `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> A partir do Android 4.4 (**API 17**), o SD card possui uma estrutura de diretórios que **limita o acesso de um app ao diretório que é especificamente para aquele app**. Isso impede que aplicações maliciosas ganhem acesso de leitura ou escrita aos arquivos de outro app.

**Dados sensíveis armazenados em texto claro**

- **Shared preferences**: O Android permite que cada aplicação salve facilmente arquivos xml no caminho `/data/data/<packagename>/shared_prefs/` e às vezes é possível encontrar informações sensíveis em texto claro nessa pasta.
- **Databases**: O Android permite que cada aplicação salve facilmente bancos sqlite no caminho `/data/data/<packagename>/databases/` e às vezes é possível encontrar informações sensíveis em texto claro nessa pasta.

### Broken TLS

**Accept All Certificates**

Por alguma razão, às vezes os desenvolvedores aceitam todos os certificados mesmo que, por exemplo, o hostname não coincida, com linhas de código como a seguinte:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Uma boa forma de testar isso é tentar capturar o tráfego usando algum proxy como Burp sem autorizar o Burp CA dentro do dispositivo. Além disso, você pode gerar com o Burp um certificado para um hostname diferente e usá-lo.

### Criptografia Quebrada

**Processos de gerenciamento de chaves inadequados**

Alguns desenvolvedores salvam dados sensíveis no armazenamento local e os criptografam com uma chave hardcoded/predictable no código. Isso não deve ser feito, pois algum reversing pode permitir que atacantes extraiam as informações confidenciais.

**Uso de algoritmos inseguros e/ou obsoletos**

Developers não devem usar **deprecated algorithms** para realizar verificações de authorisation **checks**, **store** ou **send** data. Alguns desses algoritmos são: RC4, MD4, MD5, SHA1... Se **hashes** são usados para armazenar passwords por exemplo, devem ser usados hashes resistentes a brute-force com salt.

### Outras verificações

- É recomendado **obfuscar o APK** para dificultar o trabalho de reverse engineer aos atacantes.
- Se o app for sensível (como apps bancários), ele deve realizar suas **próprias verificações para ver se o mobile está rooted** e agir em conformidade.
- Se o app for sensível (como apps bancários), ele deve verificar se um **emulator** está sendo usado.
- Se o app for sensível (como apps bancários), ele deve **verificar sua própria integridade antes de executar** para checar se foi modificado.
- Use [**APKiD**](https://github.com/rednaga/APKiD) para checar qual compiler/packer/obfuscator foi usado para construir o APK

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

The tool [**mariana-trench**](https://github.com/facebook/mariana-trench) is capable of finding **vulnerabilities** by **scanning** the **code** of the application. This tool contains a series of **known sources** (that indicates to the tool the **places** where the **input** is **controlled by the user**), **sinks** (which indicates to the tool **dangerous** **places** where malicious user input could cause damages) and **rules**. These rules indicates the **combination** of **sources-sinks** that indicates a vulnerability.

With this knowledge, **mariana-trench will review the code and find possible vulnerabilities on it**.

### Secrets leaked

An application may contain secrets (API keys, passwords, hidden urls, subdomains...) inside of it that you might be able to discover. You could us a tool such as [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> First of all, you need an environment where you can install the application and all the environment (Burp CA cert, Drozer and Frida mainly). Therefore, a rooted device (emulated or not) is extremely recommended.

### Online Dynamic analysis

You can create a **free account** in: [https://appetize.io/](https://appetize.io). This platform allows you to **upload** and **execute** APKs, so it is useful to see how an apk is behaving.

You can even **see the logs of your application** in the web and connect through **adb**.

![](<../../images/image (831).png>)

Thanks to the ADB connection you can use **Drozer** and **Frida** inside the emulators.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (Você pode criar **x86** e **arm** devices, e de acordo com [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** versions **support ARM libraries** sem precisar de um lento emulator arm).
- Aprenda a configurá-lo nesta página:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Versão gratuita:** Personal Edition, é necessário criar uma conta. _É recomendado **baixar** a versão **WITH** _**VirtualBox** para evitar erros potenciais._)
- [**Nox**](https://es.bignox.com) (Gratuito, mas não suporta Frida ou Drozer).

> [!TIP]
> Ao criar um novo emulator em qualquer plataforma lembre-se que quanto maior a tela, mais lento o emulator irá rodar. Então selecione telas pequenas se possível.

To **install google services** (like AppStore) in Genymotion you need to click on the red marked button of the following image:

![](<../../images/image (277).png>)

Also, notice that in the **configuration of the Android VM in Genymotion** you can select **Bridge Network mode** (this will be useful if you will be connecting to the Android VM from a different VM with the tools).

#### Use a physical device

Você precisa ativar as opções de **debugging** e é recomendável que você possa **root** o dispositivo:

1. **Configurações**.
2. (A partir do Android 8.0) Selecione **Sistema**.
3. Selecione **Sobre o telefone**.
4. Pressione **Número da versão** 7 vezes.
5. Volte e você encontrará as **Opções do desenvolvedor**.

> Once you have installed the application, the first thing you should do is to try it and investigate what does it do, how does it work and get comfortable with it.\
> I will suggest to **perform this initial dynamic analysis using MobSF dynamic analysis + pidcat**, so we will be able to **learn how the application works** while MobSF **captures** a lot of **interesting** **data** you can review later on.

### Unintended Data Leakage

**Logging**

Desenvolvedores devem ter cautela ao expor **informações de debugging** publicamente, pois isso pode levar a leak de dados sensíveis. As ferramentas [**pidcat**](https://github.com/JakeWharton/pidcat) e `adb logcat` são recomendadas para monitorar os logs da aplicação para identificar e proteger informações sensíveis. **Pidcat** é preferida por sua facilidade de uso e legibilidade.

> [!WARNING]
> Note that from **later newer than Android 4.0**, **applications are only able to access their own logs**. So applications cannot access other apps logs.\
> Anyway, it's still recommended to **not log sensitive information**.

**Copy/Paste Buffer Caching**

O framework do Android baseado em **clipboard** habilita a funcionalidade de copiar/colar em apps, mas apresenta risco pois **outras aplicações** podem **acessar** a clipboard, potencialmente expondo dados sensíveis. É crucial **desabilitar** as funções de copy/paste para seções sensíveis de uma aplicação, como dados de cartão de crédito, para prevenir leaks de dados.

**Crash Logs**

Se uma aplicação **crasha** e **salva logs**, esses logs podem auxiliar atacantes, particularmente quando a aplicação não pode ser reverse-engineered. Para mitigar esse risco, evite logar em crashes, e se os logs precisarem ser transmitidos na rede, garanta que sejam enviados via um canal SSL para segurança.

Como pentester, **tente dar uma olhada nesses logs**.

**Analytics Data Sent To 3rd Parties**

Aplicações frequentemente integram serviços como Google Adsense, que podem inadvertidamente causar leak de dados sensíveis devido a implementação imprópria pelos desenvolvedores. Para identificar potenciais leaks de dados, é recomendável **interceptar o tráfego da aplicação** e checar por qualquer informação sensível sendo enviada para serviços de terceiros.

### SQLite DBs

A maioria das aplicações usa **bancos SQLite internos** para salvar informações. Durante o pentest dê uma **olhada** nos **databases** criados, nos nomes das **tabelas** e **colunas** e em todos os **dados** salvos pois você pode encontrar **informações sensíveis** (o que seria uma vulnerabilidade).\
Databases devem estar localizados em `/data/data/the.package.name/databases` como `/data/data/com.mwr.example.sieve/databases`

Se o banco de dados está salvando informações confidenciais e está **criptografado**, mas você consegue encontrar a **senha** dentro da aplicação, isso ainda é uma **vulnerabilidade**.

Enumere as tabelas usando `.tables` e enumere as colunas das tabelas com `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer is s useful tool to **exploit exported activities, exported services and Content Providers** as you will learn in the following sections.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Also remember that the code of an activity starts in the **`onCreate`** method.

**Authorisation bypass**

When an Activity is exported you can invoke its screen from an external app. Therefore, if an activity with **sensitive information** is **exported** you could **bypass** the **authentication** mechanisms **to access it.**

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

You can also start an exported activity from adb:

- PackageName é com.example.demo
- Exported ActivityName é com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> Note that an authorisation bypass is not always a vulnerability, it would depend on how the bypass works and which information is exposed.

**Vazamento de informações sensíveis**

Activities can also return results. If you manage to find an exported and unprotected activity calling the **`setResult`** method and **returning sensitive information**, there is a sensitive information leakage.

#### Tapjacking

If tapjacking isn't prevented, you could abuse the exported activity to make the **user perform unexpected actions**. For more info about [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Acessando e manipulando informações sensíveis

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers are basically used to **share data**. If an app has available content providers you may be able to **extract sensitive** data from them. It also interesting to test possible **SQL injections** and **Path Traversals** as they could be vulnerable.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Remember that a the actions of a Service start in the method `onStartCommand`.

As service is basically something that **can receive data**, **process** it and **returns** (or not) a response. Then, if an application is exporting some services you should **check** the **code** to understand what is it doing and **test** it **dynamically** for extracting confidential info, bypassing authentication measures...\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Remember that a the actions of a Broadcast Receiver start in the method `onReceive`.

A broadcast receiver will be waiting for a type of message. Depending on how the receiver handles the message it could be vulnerable.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

You can look for deep links manually, using tools like MobSF or scripts like [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
You can **open** a declared **scheme** using **adb** or a **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Observe que você pode **omitir o nome do pacote** e o dispositivo móvel chamará automaticamente o app que deve abrir esse link._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Código executado**

Para encontrar o **código que will be executed in the App**, vá para a activity chamada pelo deeplink e procure a função **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Informação sensível**

Cada vez que encontrar um deep link verifique que i**não está recebendo dados sensíveis (como senhas) via URL parameters**, porque qualquer outra aplicação poderia **se passar pelo deep link e roubar esses dados!**

**Parâmetros no path**

Você **deve também verificar se algum deep link está usando um parâmetro dentro do path** da URL como: `https://api.example.com/v1/users/{username}` , nesse caso você pode forçar um path traversal acessando algo como: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Note que se você encontrar os endpoints corretos dentro da aplicação pode ser capaz de causar um **Open Redirect** (se parte do path for usada como domain name), **account takeover** (se você conseguir modificar users details sem CSRF token e o vuln endpoint usar o método correto) e qualquer outra vuln. More [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Inspeção da Camada de Transporte e Falhas de Verificação

- **Certificates are not always inspected properly** por aplicações Android. É comum que essas aplicações ignorem avisos e aceitem self-signed certificates ou, em alguns casos, regressem para conexões HTTP.
- **Negotiations during the SSL/TLS handshake are sometimes weak**, empregando cipher suites inseguros. Essa vulnerabilidade torna a conexão suscetível a ataques man-in-the-middle (MITM), permitindo que atacantes decodifiquem os dados.
- **Leakage of private information** é um risco quando aplicações autenticam usando canais seguros, mas então comunicam por canais não seguros para outras transações. Essa abordagem não protege dados sensíveis, como session cookies ou detalhes do usuário, contra interceptação por entidades maliciosas.

#### Verificação de Certificados

Vamos focar em **verificação de certificados**. A integridade do certificado do servidor deve ser verificada para aumentar a segurança. Isso é crucial porque configurações TLS inseguras e a transmissão de dados sensíveis por canais não encriptados podem representar riscos significativos. Para passos detalhados sobre como verificar certificados de servidor e mitigar vulnerabilidades, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) fornece orientação abrangente.

#### SSL Pinning

SSL Pinning é uma medida de segurança onde a aplicação verifica o certificado do servidor contra uma cópia conhecida armazenada dentro da própria aplicação. Esse método é essencial para prevenir ataques MITM. Implementar SSL Pinning é fortemente recomendado para aplicações que lidam com informação sensível.

#### Inspeção de Tráfego

Para inspecionar tráfego HTTP, é necessário **instalar o certificado da ferramenta proxy** (e.g., Burp). Sem instalar esse certificado, o tráfego encriptado pode não ser visível através do proxy. Para um guia sobre como instalar um certificado CA customizado, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Aplicações direcionadas para **API Level 24 and above** requerem modificações no Network Security Config para aceitar o certificado CA do proxy. Esta etapa é crítica para inspecionar tráfego encriptado. Para instruções sobre modificar o Network Security Config, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

Se **Flutter** estiver sendo usado, você precisa seguir as instruções em [**this page**](flutter.md). Isso porque apenas adicionar o certificado ao store não funcionará, já que Flutter possui sua própria lista de CAs válidas.

#### Detecção estática de SSL/TLS pinning

Antes de tentar bypasses em runtime, mapeie rapidamente onde o pinning é aplicado no APK. A descoberta estática ajuda a planejar hooks/patches e a focar nos code paths corretos.

Tool: SSLPinDetect
- Utilitário de análise estática open-source que decompila o APK para Smali (via apktool) e escaneia por padrões regex curados de implementações de SSL/TLS pinning.
- Reporta o caminho exato do arquivo, número da linha, e um snippet de código para cada correspondência.
- Cobre frameworks comuns e caminhos de código customizados: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

Instalar
- Pré-requisitos: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Uso
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Exemplo de regras de padrão (JSON)
Use ou estenda signatures para detectar estilos de pinning proprietários/personalizados. Você pode carregar seu próprio JSON e escanear em larga escala.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes and tips
- Fast scanning on large apps via multi-threading and memory-mapped I/O; pre-compiled regex reduces overhead/false positives.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Typical detection targets to triage next:
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Declarative pins in res/xml network security config and manifest references
- Use the matched locations to plan Frida hooks, static patches, or config reviews before dynamic testing.



#### Contornando SSL Pinning

When SSL Pinning is implemented, bypassing it becomes necessary to inspect HTTPS traffic. Various methods are available for this purpose:

- Automatically **modificar** o **apk** para **contornar** SSLPinning com [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). The best pro of this option, is that you won't need root to bypass the SSL Pinning, but you will need to delete the application and reinstall the new one, and this won't always work.
- You could use **Frida** (discussed below) to bypass this protection. Here you have a guide to use Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- You can also try to **automatically bypass SSL Pinning** using [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- You can also try to **automatically bypass SSL Pinning** using **MobSF dynamic analysis** (explained below)
- If you still think that there is some traffic that you aren't capturing you can try to **forward the traffic to burp using iptables**. Read this blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Looking for Common Web Vulnerabilities

It's important to also search for common web vulnerabilities within the application. Detailed information on identifying and mitigating these vulnerabilities is beyond the scope of this summary but is extensively covered elsewhere.

### Frida

[Frida](https://www.frida.re) é um toolkit de instrumentação dinâmica para desenvolvedores, reverse-engineers, e pesquisadores de segurança.\
**You can access running application and hook methods on run time to change the behaviour, change values, extract values, run different code...**\
If you want to pentest Android applications you need to know how to use Frida.

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Some "GUI" for actions with Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- You can find some Awesome Frida scripts here: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Try to bypass anti-debugging / anti-frida mechanisms loading Frida as in indicated in [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

Check if the application is storing sensitive information inside the memory that it shouldn't be storing like passwords or mnemonics.

Using [**Fridump3**](https://github.com/rootbsd/fridump3) you can dump the memory of the app with:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Isso irá fazer o dump da memória na pasta ./dump, e lá você pode usar grep com algo como:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Dados sensíveis no Keystore**

No Android, o Keystore é o melhor lugar para armazenar dados sensíveis, porém, com privilégios suficientes ainda é **possível acessá-lo**. Como as aplicações tendem a armazenar aqui **dados sensíveis em texto claro**, os pentests devem verificar isso como usuário root ou alguém com acesso físico ao dispositivo poderia ser capaz de roubar esses dados.

Mesmo que um app tenha armazenado dados no Keystore, os dados devem estar criptografados.

Para acessar os dados dentro do Keystore você pode usar este script do Frida: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Usando o seguinte Frida script, pode ser possível **bypass fingerprint authentication** que aplicações Android realizem para **proteger certas áreas sensíveis:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Imagens de Fundo**

Quando você coloca um aplicativo em segundo plano, o Android armazena uma **captura (snapshot) da aplicação** para que, quando for trazido de volta ao primeiro plano, comece a carregar a imagem antes do app, dando a impressão de que o aplicativo carregou mais rápido.

No entanto, se essa captura contiver **informação sensível**, alguém com acesso à captura pode **roubar essa informação** (observe que é preciso root para acessá-la).

As capturas geralmente são armazenadas em: **`/data/system_ce/0/snapshots`**

O Android fornece uma forma de **impedir a captura de tela definindo o parâmetro de layout FLAG_SECURE**. Ao usar essa flag, o conteúdo da janela é tratado como seguro, impedindo que apareça em capturas de tela ou que seja exibido em displays não seguros.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Esta ferramenta pode ajudar a gerenciar diferentes ferramentas durante a análise dinâmica: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Developers often create proxy components like activities, services, and broadcast receivers that handle these Intents and pass them to methods such as `startActivity(...)` or `sendBroadcast(...)`, which can be risky.

The danger lies in allowing attackers to trigger non-exported app components or access sensitive content providers by misdirecting these Intents. A notable example is the `WebView` component converting URLs to `Intent` objects via `Intent.parseUri(...)` and then executing them, potentially leading to malicious Intent injections.

### Essential Takeaways

- **Intent Injection** é similar ao Open Redirect da web.
- Exploits involve passing `Intent` objects as extras, which can be redirected to execute unsafe operations.
- Pode expor componentes não-exportados e content providers a atacantes.
- `WebView`’s URL to `Intent` conversion pode facilitar ações não intencionais.

### Android Client Side Injections and others

Provavelmente você conhece este tipo de vulnerabilidade pela Web. Deve ter cuidado especial com estas vulnerabilidades em uma aplicação Android:

- **SQL Injection:** Ao lidar com queries dinâmicas ou Content-Providers, garanta que está usando queries parametrizadas.
- **JavaScript Injection (XSS):** Verifique se o suporte a JavaScript e Plugins está desativado para qualquer WebView (desativado por padrão). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** Os WebViews devem ter acesso ao sistema de arquivos desativado (ativado por padrão) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: Em vários casos, quando a aplicação android finaliza a sessão, o cookie não é revogado ou pode até ser salvo no disco
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Análise estática**

![](<../../images/image (866).png>)

**Avaliação de vulnerabilidades da aplicação** usando uma interface web agradável. Você também pode realizar análise dinâmica (mas precisa preparar o ambiente).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Assisted Dynamic analysis with MobSF

**MobSF** can also be very helpful for **dynamic analysis** in **Android**, but in that case you will need to install MobSF and **genymotion** in your host (a VM or Docker won't work). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
The **MobSF dynamic analyser** can:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). All of this is done automatically except for the screenshots, you need to press when you want a screenshot or you need to press "**Exported Activity Tester**" to obtain screenshots of all the exported activities.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: It will print all the loaded classes
- **Capture Strings**: It will print all the capture strings while using the application (super noisy)
- **Capture String Comparisons**: Could be very useful. It will **show the 2 strings being compared** and if the result was True or False.
- **Enumerate Class Methods**: Put the class name (like "java.io.File") and it will print all the methods of the class.
- **Search Class Pattern**: Search classes by pattern
- **Trace Class Methods**: **Trace** a **whole class** (see inputs and outputs of all methods of th class). Remember that by default MobSF traces several interesting Android Api methods.

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf also brings you a shell with some **adb** commands, **MobSF commands**, and common **shell** **commands** at the bottom of the dynamic analysis page. Some interesting commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**Ferramentas HTTP**

When http traffic is capture you can see an ugly view of the captured traffic on "**HTTP(S) Traffic**" botão or a nicer view in "**Start HTTPTools**" botão verde. From the second option, you can **send** the **captured requests** to **proxies** like Burp or Owasp ZAP.\
To do so, _power on Burp -->_ _turn off Intercept --> in MobSF HTTPTools select the request_ --> press "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Once you finish the análise dinâmica with MobSF you can press on "**Start Web API Fuzzer**" to **fuzz** requisições HTTP e procurar vulnerabilidades.

> [!TIP]
> Após realizar uma análise dinâmica com MobSF as configurações de proxy podem ficar mal configuradas e você não conseguirá corrigi-las pela GUI. Você pode corrigir as configurações de proxy executando:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

You can get the tool from [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Esta ferramenta vai usar alguns **Hooks** para informar **o que está acontecendo na aplicação** enquanto você realiza uma **análise dinâmica**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Esta é uma **ótima ferramenta para realizar análise estática com uma GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Esta ferramenta foi projetada para procurar várias **vulnerabilidades relacionadas à segurança em aplicações Android**, seja no **source code** ou em **packaged APKs**. A ferramenta também é **capaz de criar um "Proof-of-Concept" deployable APK** e **ADB commands**, para explorar algumas das vulnerabilidades encontradas (Exposed activities, intents, tapjacking...). Como com Drozer, não é necessário root no dispositivo de teste.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Exibe todos os arquivos extraídos para referência rápida
- Descompila automaticamente arquivos APK para os formatos Java e Smali
- Analisa AndroidManifest.xml em busca de vulnerabilidades comuns e comportamento
- Análise estática do código-fonte para detectar vulnerabilidades e comportamento comuns
- Informações do dispositivo
- e mais
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER é um aplicativo de linha de comando que pode ser usado em Windows, MacOS X e Linux, que analisa arquivos _.apk_ em busca de vulnerabilidades. Faz isso descompactando APKs e aplicando uma série de regras para detectar essas vulnerabilidades.

Todas as regras estão centralizadas em um arquivo `rules.json`, e cada empresa ou testador pode criar suas próprias regras para analisar o que precisarem.

Baixe os binários mais recentes na [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn é uma ferramenta **multiplataforma** que auxilia desenvolvedores, bugbounty hunters e ethical hackers na realização de [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) em aplicações móveis.

O conceito é que você arraste e solte o arquivo da sua aplicação móvel (um arquivo .apk ou .ipa) na aplicação StaCoAn e ele gerará um relatório visual e portátil para você. Você pode ajustar as configurações e wordlists para obter uma experiência personalizada.

Baixar[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework é um sistema de análise de vulnerabilidades do Android que ajuda desenvolvedores ou hackers a encontrar potenciais vulnerabilidades de segurança em aplicativos Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** é uma ferramenta cujo principal objetivo é detectar e alertar o usuário sobre comportamentos potencialmente maliciosos desenvolvidos por uma aplicação Android.

A detecção é realizada através da **static analysis** do bytecode Dalvik da aplicação, representado como **Smali**, usando a biblioteca [`androguard`](https://github.com/androguard/androguard).

Esta ferramenta procura por **common behavior of "bad" applications** como: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. É uma ferramenta que agrupa ferramentas comumente usadas para reverse engineering e analysis de aplicações móveis, para auxiliar nos testes de aplicações móveis contra as ameaças de segurança mobile do OWASP. Seu objetivo é tornar essa tarefa mais fácil e mais amigável para desenvolvedores de aplicações móveis e profissionais de segurança.

It is able to:

- Extract Java and Smali code using different tools
- Analyze APKs using: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Extract private information from the APK using regexps.
- Analyze the Manifest.
- Analyze found domains using: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Útil para detectar malware: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Note que, dependendo do serviço e da configuração que você usa para ofuscar o código, segredos podem ou não ficar ofuscados.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. It is able to optimize bytecode as well as detect and remove unused instructions. ProGuard is free software and is distributed under the GNU General Public License, version 2.

ProGuard é distribuído como parte do Android SDK e é executado ao construir a aplicação no modo release.

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Last time we checked, the Dexguard mode of operation was:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

Você pode enviar um APK ofuscado para a plataforma deles.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

It is a **generic android deobfuscator.** Simplify **virtually executes an app** to understand its behavior and then **tries to optimize the code** so it behaves identically but is easier for a human to understand. Each optimization type is simple and generic, so it doesn't matter what the specific type of obfuscation is used.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD gives you information about **how an APK was made**. It identifies many **compilers**, **packers**, **obfuscators**, and other weird stuff. It's [_PEiD_](https://www.aldeid.com/wiki/PEiD) for Android.

### Manual

[Leia este tutorial para aprender alguns truques sobre **como reverter ofuscação customizada**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b é uma máquina virtual de segurança Android baseada em ubuntu-mate que inclui uma coleção dos frameworks, tutoriais e labs mais recentes de diferentes entusiastas e pesquisadores de segurança para reverse engineering e malware analysis.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) É uma ótima lista de recursos
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)

## Yet to try

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
